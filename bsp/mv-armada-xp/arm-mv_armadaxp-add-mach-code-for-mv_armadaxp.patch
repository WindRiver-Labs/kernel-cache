From 094e2a6490ba4fa18e5356fa73e20de8b6ec3cc9 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Mon, 22 Oct 2012 15:39:49 +0800
Subject: [PATCH 01/50] arm: mv_armadaxp: add mach code for mv_armadaxp

The code is extracted from linux-3.2.27-axp_a370-2012_Q4.1, which
can be downloaded from:
https://extranet.marvell.com/extranet/dms/documents.do?groupID=4&\
subGroupID=53015

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-armadaxp/Kconfig                     |  122 +
 arch/arm/mach-armadaxp/Makefile                    |  201 ++
 arch/arm/mach-armadaxp/Makefile.boot               |    9 +
 .../armada_xp_family/boardEnv/mvBoardEnvLib.c      | 2746 ++++++++++++++++++++
 .../armada_xp_family/boardEnv/mvBoardEnvLib.h      |  450 ++++
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.c     | 1492 +++++++++++
 .../armada_xp_family/boardEnv/mvBoardEnvSpec.h     |  575 ++++
 .../arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c |  323 +++
 .../arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h |  112 +
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c    |  373 +++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h    |  194 ++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h        |   97 +
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.c        | 2189 ++++++++++++++++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvLib.h        |  278 ++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h       |  589 +++++
 .../armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h       |  493 ++++
 .../armada_xp_family/ctrlEnv/mvSemaphore.c         |  124 +
 .../armada_xp_family/ctrlEnv/mvSemaphore.h         |  106 +
 .../armada_xp_family/ctrlEnv/mvUnitMap.c           |  266 ++
 .../armada_xp_family/ctrlEnv/mvUnitMap.h           |  158 ++
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c     |  750 ++++++
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h     |   96 +
 .../armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h |  143 +
 .../armada_xp_family/ctrlEnv/sys/mvCpuIf.c         | 1054 ++++++++
 .../armada_xp_family/ctrlEnv/sys/mvCpuIf.h         |  124 +
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S     |  167 ++
 .../armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h     |  352 +++
 .../armada_xp_family/device/mvDevice.c             |  291 +++
 .../armada_xp_family/device/mvDevice.h             |   99 +
 .../armada_xp_family/device/mvDeviceRegs.h         |  270 ++
 arch/arm/mach-armadaxp/clcd.c                      |  557 ++++
 arch/arm/mach-armadaxp/clock.c                     |   50 +
 arch/arm/mach-armadaxp/clock.h                     |    5 +
 arch/arm/mach-armadaxp/config/mvRules.mk           |  183 ++
 arch/arm/mach-armadaxp/config/mvSysCesaConfig.h    |   45 +
 arch/arm/mach-armadaxp/config/mvSysCntmrConfig.h   |   36 +
 arch/arm/mach-armadaxp/config/mvSysDdrConfig.h     |   45 +
 arch/arm/mach-armadaxp/config/mvSysEthConfig.h     |  198 ++
 arch/arm/mach-armadaxp/config/mvSysEthPhyConfig.h  |   32 +
 arch/arm/mach-armadaxp/config/mvSysGppConfig.h     |   37 +
 arch/arm/mach-armadaxp/config/mvSysHwConfig.h      |  309 +++
 arch/arm/mach-armadaxp/config/mvSysNfcConfig.h     |   36 +
 arch/arm/mach-armadaxp/config/mvSysPciConfig.h     |   26 +
 arch/arm/mach-armadaxp/config/mvSysPexConfig.h     |   50 +
 arch/arm/mach-armadaxp/config/mvSysPonConfig.h     |   38 +
 arch/arm/mach-armadaxp/config/mvSysRtcConfig.h     |   36 +
 arch/arm/mach-armadaxp/config/mvSysSataConfig.h    |   36 +
 arch/arm/mach-armadaxp/config/mvSysSdmmcConfig.h   |   37 +
 arch/arm/mach-armadaxp/config/mvSysSpiConfig.h     |   36 +
 arch/arm/mach-armadaxp/config/mvSysTdmConfig.h     |   68 +
 arch/arm/mach-armadaxp/config/mvSysTsConfig.h      |   39 +
 arch/arm/mach-armadaxp/config/mvSysTwsiConfig.h    |   41 +
 arch/arm/mach-armadaxp/config/mvSysUsbConfig.h     |   36 +
 arch/arm/mach-armadaxp/config/mvSysXorConfig.h     |   36 +
 arch/arm/mach-armadaxp/core.c                      | 2103 +++++++++++++++
 arch/arm/mach-armadaxp/dump_cp15_regs.c            |  219 ++
 arch/arm/mach-armadaxp/export.c                    |  215 ++
 arch/arm/mach-armadaxp/flashmap.c                  |  255 ++
 arch/arm/mach-armadaxp/headsmp.S                   |   92 +
 arch/arm/mach-armadaxp/hwmon.c                     |  399 +++
 arch/arm/mach-armadaxp/include/mach/armadaxp.h     |  349 +++
 arch/arm/mach-armadaxp/include/mach/clkdev.h       |    7 +
 arch/arm/mach-armadaxp/include/mach/debug-macro.S  |   24 +
 arch/arm/mach-armadaxp/include/mach/dma.h          |   16 +
 arch/arm/mach-armadaxp/include/mach/dove_bl.h      |   35 +
 arch/arm/mach-armadaxp/include/mach/entry-macro.S  |  189 ++
 arch/arm/mach-armadaxp/include/mach/gpio.h         |   55 +
 arch/arm/mach-armadaxp/include/mach/hardware.h     |   14 +
 arch/arm/mach-armadaxp/include/mach/ide.h          |   15 +
 arch/arm/mach-armadaxp/include/mach/io.h           |   32 +
 arch/arm/mach-armadaxp/include/mach/irqs.h         |  171 ++
 arch/arm/mach-armadaxp/include/mach/kw_macro.h     |   39 +
 arch/arm/mach-armadaxp/include/mach/memory.h       |   44 +
 arch/arm/mach-armadaxp/include/mach/param.h        |   15 +
 arch/arm/mach-armadaxp/include/mach/serial.h       |   41 +
 arch/arm/mach-armadaxp/include/mach/smp.h          |   23 +
 arch/arm/mach-armadaxp/include/mach/system.h       |   37 +
 arch/arm/mach-armadaxp/include/mach/timex.h        |    9 +
 arch/arm/mach-armadaxp/include/mach/uncompress.h   |  138 +
 arch/arm/mach-armadaxp/irq.c                       |  362 +++
 arch/arm/mach-armadaxp/leds.c                      |   49 +
 arch/arm/mach-armadaxp/mpp.h                       |   34 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysCesa.c       |  117 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysCesaApi.h    |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysDdr.c        |  134 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysEth.c        |  132 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthApi.h     |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhy.c     |  104 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhyApi.h  |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c       |  150 ++
 arch/arm/mach-armadaxp/mv_hal_if/mvSysNetaApi.h    |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c        | 1382 ++++++++++
 arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.h        |  256 ++
 arch/arm/mach-armadaxp/mv_hal_if/mvSysPex.c        |  106 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysPexApi.h     |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysSFlash.c     |  226 ++
 arch/arm/mach-armadaxp/mv_hal_if/mvSysSata.c       |   82 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysSataApi.h    |   71 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysSpi.c        |  126 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysSpiApi.h     |   70 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysTdm.c        |  236 ++
 arch/arm/mach-armadaxp/mv_hal_if/mvSysTdmApi.h     |   78 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysTs.c         |   87 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysTsApi.h      |   73 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysUsb.c        |  103 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysUsbApi.h     |   70 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysXor.c        |   87 +
 arch/arm/mach-armadaxp/mv_hal_if/mvSysXorApi.h     |   70 +
 arch/arm/mach-armadaxp/pci.c                       |  243 ++
 arch/arm/mach-armadaxp/pex.c                       |  417 +++
 arch/arm/mach-armadaxp/platsmp.c                   |  375 +++
 arch/arm/mach-armadaxp/pm.c                        |  159 ++
 arch/arm/mach-armadaxp/proc_aurora_dbg.c           |   88 +
 arch/arm/mach-armadaxp/sysmap.c                    |  236 ++
 arch/arm/mach-armadaxp/time.c                      |  499 ++++
 arch/arm/mach-armadaxp/usb.c                       |  168 ++
 include/video/dovefb.h                             |  507 ++++
 include/video/dovefbreg.h                          |  695 +++++
 118 files changed, 28738 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-armadaxp/Kconfig
 create mode 100644 arch/arm/mach-armadaxp/Makefile
 create mode 100644 arch/arm/mach-armadaxp/Makefile.boot
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100755 arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
 create mode 100644 arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
 create mode 100644 arch/arm/mach-armadaxp/clcd.c
 create mode 100644 arch/arm/mach-armadaxp/clock.c
 create mode 100644 arch/arm/mach-armadaxp/clock.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvRules.mk
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysCesaConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysCntmrConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysDdrConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysEthConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysEthPhyConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysGppConfig.h
 create mode 100755 arch/arm/mach-armadaxp/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysNfcConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysPciConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysPexConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysPonConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysRtcConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysSataConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysSdmmcConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysSpiConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysTdmConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysTsConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysTwsiConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysUsbConfig.h
 create mode 100644 arch/arm/mach-armadaxp/config/mvSysXorConfig.h
 create mode 100755 arch/arm/mach-armadaxp/core.c
 create mode 100644 arch/arm/mach-armadaxp/dump_cp15_regs.c
 create mode 100644 arch/arm/mach-armadaxp/export.c
 create mode 100644 arch/arm/mach-armadaxp/flashmap.c
 create mode 100644 arch/arm/mach-armadaxp/headsmp.S
 create mode 100644 arch/arm/mach-armadaxp/hwmon.c
 create mode 100644 arch/arm/mach-armadaxp/include/mach/armadaxp.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-armadaxp/include/mach/dma.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/dove_bl.h
 create mode 100755 arch/arm/mach-armadaxp/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-armadaxp/include/mach/gpio.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/hardware.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/ide.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/io.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/irqs.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/kw_macro.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/memory.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/param.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/serial.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/smp.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/system.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/timex.h
 create mode 100644 arch/arm/mach-armadaxp/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-armadaxp/irq.c
 create mode 100644 arch/arm/mach-armadaxp/leds.c
 create mode 100644 arch/arm/mach-armadaxp/mpp.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysCesa.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysCesaApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysDdr.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysEth.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhy.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhyApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysNetaApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysPex.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysPexApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysSFlash.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysSata.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysSataApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysSpi.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysSpiApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysTdm.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysTdmApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysTs.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysTsApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysUsb.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysUsbApi.h
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysXor.c
 create mode 100644 arch/arm/mach-armadaxp/mv_hal_if/mvSysXorApi.h
 create mode 100644 arch/arm/mach-armadaxp/pci.c
 create mode 100644 arch/arm/mach-armadaxp/pex.c
 create mode 100644 arch/arm/mach-armadaxp/platsmp.c
 create mode 100644 arch/arm/mach-armadaxp/pm.c
 create mode 100644 arch/arm/mach-armadaxp/proc_aurora_dbg.c
 create mode 100644 arch/arm/mach-armadaxp/sysmap.c
 create mode 100644 arch/arm/mach-armadaxp/time.c
 create mode 100644 arch/arm/mach-armadaxp/usb.c
 create mode 100644 include/video/dovefb.h
 create mode 100644 include/video/dovefbreg.h

diff --git a/arch/arm/mach-armadaxp/Kconfig b/arch/arm/mach-armadaxp/Kconfig
new file mode 100644
index 0000000..0b4b999
--- /dev/null
+++ b/arch/arm/mach-armadaxp/Kconfig
@@ -0,0 +1,122 @@
+if ARCH_ARMADA_XP
+
+config  MV_HAL_RULES_PATH
+        string "path of the mvRules.mk file for HAL drivers"
+        default "arch/arm/mach-armadaxp/mv_hal_support/mvRules.mk"
+        ---help---
+	
+#source "arch/arm/plat-orion/mv_hal_drivers/Kconfig"
+
+menu "Marvell Armada Options"
+
+config ARMADA_XP
+	bool "Armada XP SoC Family"
+	default y
+
+choice
+	prompt "Armada XP Chip revision"
+	depends on ARMADA_XP
+	default ARMADA_XP_REV_B0
+
+config  ARMADA_XP_REV_Z1
+	bool "MV88F78x30 and MV88F78x60 Z1 SoC devices"
+	select ARMADA_XP_ERRATA_SMI_1
+#	select ARMADA_XP_DEEP_IDLE_L2_WA if CACHE_AURORA_L2
+#	select ARMADA_XP_DEEP_IDLE_UNMASK_INTS_WA
+	select SHEEVA_ERRATA_ARM_CPU_4742
+	select SHEEVA_ERRATA_ARM_CPU_4786 if (ARM_THUMB && VFP)
+#	select SHEEVA_ERRATA_ARM_CPU_5315
+	select SHEEVA_ERRATA_ARM_CPU_4413
+	select SHEEVA_ERRATA_ARM_CPU_4659
+	select SHEEVA_ERRATA_ARM_CPU_5114 if (CPU_SHEEVA_PJ4B_V6 && AURORA_IO_CACHE_COHERENCY)
+	select SHEEVA_ERRATA_ARM_CPU_4611
+#	select SHEEVA_ERRATA_ARM_CPU_4948
+	select SHEEVA_ERRATA_ARM_CPU_PMU_RESET
+	select SHEEVA_ERRATA_ARM_CPU_BTS61 if (SMP || AURORA_IO_CACHE_COHERENCY)
+	---help---
+	Choosing this option will generate a linux kernel for the
+	  MV78x30 and MV78x60 devices with revision Z1
+
+config  ARMADA_XP_REV_A0
+	bool "MV88F78x30 and MV88F78x60 A0 SoC devices"
+	---help---
+	Choosing this option will generate a linux kernel for the
+	  MV78x30 and MV78x60 devices with revision A0
+
+config  ARMADA_XP_REV_B0
+	bool "MV88F78x30 and MV88F78x60 B0 SoC devices"
+	---help---
+	Choosing this option will generate a linux kernel for the
+	  MV78x30 and MV78x60 devices with revision B0
+
+endchoice
+
+config  ARMADA_XP_A0_WITH_B0
+	bool "Armada XP A0 and B0 Runtime Support"
+	default n
+	depends on ARMADA_XP_REV_B0
+	---help---
+	Choosing this option will generate a linux kernel supporting both A0 and B0 revisions
+	Selection is done at runtime based on silicon revision.
+	Due to performance impact, it is recommended to disable this option in case of B0 only.
+
+
+config MACH_ARMADA_XP_DB
+	bool "Marvell Armada XP Development Board"	
+	default y
+	help
+
+config MACH_ARMADA_XP_GP
+	bool "Marvell Armada XP General Purpose Board"
+	default y
+	help
+
+config MACH_ARMADA_XP_RDSRV
+	bool "Marvell Armada XP Server Board"
+	default y
+	help
+
+config MACH_ARMADA_XP_RD_NAS
+	bool "Marvell Armada XP NAS RD Board"
+	default y
+	help
+
+config MACH_ARMADA_XP_FPGA
+	bool "Marvell Armada XP FPGA Board"	
+	depends on !MACH_ARMADA_XP_DB && !MACH_ARMADA_XP_RDSRV
+	default y
+	help
+
+config CFU_DRAM_BYPASS
+        bool "Bypass CFU to DRAM via Punit"
+	default n
+	help
+
+config ARMADA_XP_SPARSEMEM
+	bool "Use sparse memory model"
+	select ARCH_SPARSEMEM_ENABLE
+	default n
+
+config ARMADAXP_USE_IRQ_INDIRECT_MODE
+       bool "Use indirect mode for handling interrupt controller"
+       depends on !CRASH_DUMP
+       default n
+       help
+         This mode enables using indirect mode for handling interrupts, in this
+	 mode, the Interrupt Set Enable/Clear Enable registers are used for
+	 unmasking/masking shared interrupts, and Interrupt Set Mask/Clear Mask
+	 used for masking/unmasking per-cpu interrupts. Without this mode, the
+	 Interrupt Source register is used directly. and this requires the
+	 following:
+	 - Locking mechanism to protect the access to the Interrupt Source Register
+	 - Reads operation of those registers.
+	 - Using the affinity variable for restoring the mask values
+
+config ARMADAXP_USE_IRQ_INTERRUPT_ACK
+       bool "Use Interrupt Ack register to detect pending interrupts"
+       default n
+       help
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
new file mode 100644
index 0000000..9fb2095
--- /dev/null
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -0,0 +1,201 @@
+#*******************************************************************************
+# Marvell GPL License Option
+#
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
+# disclaimer.
+#*******************************************************************************/
+include 	  $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+
+
+# Objects list
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o $(COMMON_DIR)/mvIpc.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_RTC_DIR)/mvRtc.o					\
+                  $(HAL_CNTMR_DIR)/mvCntmr.o					\
+		  $(HAL_TWSI_DIR)/mvTwsi.o					\
+                  $(HAL_UART_DIR)/mvUart.o $(HAL_GPP_DIR)/mvGpp.o               \
+                  $(HAL_DRAM_DIR)/mvDramIf.o					\
+		  $(HAL_IF_DIR)/mvSysDdr.o
+#		  $(HAL_DRAM_SPD_DIR)/mvSpd.o
+
+KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o $(SOC_ENV_DIR)/mvCtrlEnvLib.o	\
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
+		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
+		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o
+
+QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
+                  $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o	\
+                  $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o	\
+                  $(HAL_QD_DIR)/src/platform/gtDebug.o $(HAL_QD_DIR)/src/msapi/gtBrgFdb.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgStp.o $(HAL_QD_DIR)/src/msapi/gtBrgVlan.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtEvents.o $(HAL_QD_DIR)/src/msapi/gtPortCtrl.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtPortStat.o $(HAL_QD_DIR)/src/msapi/gtPortStatus.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtQosMap.o $(HAL_QD_DIR)/src/msapi/gtPIRL.o  		\
+                  $(HAL_QD_DIR)/src/msapi/gtPhyCtrl.o $(HAL_QD_DIR)/src/msapi/gtPhyInt.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysConfig.o $(HAL_QD_DIR)/src/msapi/gtSysCtrl.o	\
+                  $(HAL_QD_DIR)/src/msapi/gtVersion.o $(HAL_QD_DIR)/src/msapi/gtUtils.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgVtu.o $(HAL_QD_DIR)/src/msapi/gtPortRmon.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o\
+                  $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o
+
+LSP_OBJS        = core.o irq.o time.o leds.o sysmap.o export.o clock.o
+
+obj-y   				:=  armadaxp.o
+armadaxp-objs  				:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
+					  $(KW_FAM_OBJS)
+
+armadaxp-$(CONFIG_MV_INCLUDE_SDIO) 	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
+armadaxp-$(CONFIG_MV_INCLUDE_XOR) 	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysXor.o
+armadaxp-$(CONFIG_MV_INCLUDE_PEX) 	+= $(HAL_PEX_DIR)/mvPex.o					\
+					   $(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
+armadaxp-$(CONFIG_MV_INCLUDE_PCI) 	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+armadaxp-$(CONFIG_MV_INCLUDE_USB) 	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysUsb.o
+armadaxp-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
+
+# Legacy Giga driver
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+armadaxp-$(CONFIG_MV_ETH_LEGACY)	+= $(HAL_ETH_GBE_DIR)/mvEth.o $(HAL_ETH_GBE_DIR)/mvEthDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvEthAddrDec.o $(HAL_IF_DIR)/mvSysEth.o
+endif
+
+# NETA Giga driver
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+armadaxp-$(CONFIG_MV_ETH_NETA)	        += $(HAL_ETH_GBE_DIR)/mvNeta.o $(HAL_ETH_GBE_DIR)/mvNetaDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvNetaAddrDec.o $(HAL_IF_DIR)/mvSysNeta.o
+armadaxp-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o  $(HAL_ETH_PNC_DIR)/mvPncAging.o \
+					   $(HAL_ETH_PNC_DIR)/mvPnc.o $(HAL_ETH_PNC_DIR)/mvPncLb.o
+armadaxp-$(CONFIG_MV_ETH_PNC_L3_FLOW)   += $(HAL_ETH_PNC_DIR)/mvPncRxq.o
+armadaxp-$(CONFIG_MV_ETH_PNC_WOL)       += $(HAL_ETH_PNC_DIR)/mvPncWol.o
+armadaxp-$(CONFIG_MV_ETH_BM) 	        += $(HAL_ETH_BM_DIR)/mvBm.o
+armadaxp-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o
+armadaxp-$(CONFIG_MV_ETH_HWF)           += $(HAL_ETH_GBE_DIR)/mvHwf.o
+endif
+
+armadaxp-$(CONFIG_MV_INCLUDE_CESA) 	+= $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaDebug.o 	\
+					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
+                        		   $(HAL_CESA_DIR)/mvMD5.o $(HAL_CESA_DIR)/mvSHA1.o 		\
+					   $(HAL_CESA_DIR)/mvSHA256.o					\
+					   $(HAL_CESA_AES_DIR)/mvAesAlg.o $(HAL_CESA_AES_DIR)/mvAesApi.o\
+					   $(HAL_IF_DIR)/mvSysCesa.o
+armadaxp-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
+					   $(HAL_SATA_DIR)/mvSataAddrDec.o
+armadaxp-$(CONFIG_MV_INCLUDE_SPI) 	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o 		\
+                         		   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
+					   $(HAL_IF_DIR)/mvSysSpi.o
+armadaxp-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
+armadaxp-$(CONFIG_MV_INCLUDE_AUDIO) 	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
+					   $(HAL_AUDIO_DIR)/mvAudioAddrDec.o
+armadaxp-$(CONFIG_MV_INCLUDE_TS) 	+= $(HAL_TS_DIR)/mvTsu.o $(HAL_IF_DIR)/mvSysTs.o		\
+					   $(HAL_TS_DIR)/mvTsuAddrDec.o
+armadaxp-$(CONFIG_MV_CPU_PERF_CNTRS)    += $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
+armadaxp-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
+armadaxp-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
+
+# drivers part
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+obj-$(CONFIG_MV_ETH_PNC)                += $(LSP_PNC_DIR)/pnc_sysfs.o
+obj-$(CONFIG_MV_ETH_PNC_L3_FLOW)        += $(LSP_PNC_DIR)/rxq_map_sysfs.o
+obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o  $(LSP_BM_DIR)/mv_eth_bm.o
+obj-$(CONFIG_MV_ETH_PNC_WOL)            += $(LSP_PNC_DIR)/wol_sysfs.o
+obj-$(CONFIG_MV_ETH_PMT)		+= $(LSP_PMT_DIR)/pmt_sysfs.o
+obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o
+ifndef CONFIG_MV_ETH_BM_CPU
+obj-$(CONFIG_MV_ETH_HWF)		+=  $(LSP_HWF_DIR)/hwf_bm.o
+endif
+obj-$(CONFIG_MV_ETH_L2FW)               += $(LSP_L2FW_DIR)/l2fw_sysfs.o $(LSP_L2FW_DIR)/mv_eth_l2fw.o
+obj-$(CONFIG_MV_ETH_L2SEC)              += $(LSP_L2FW_DIR)/mv_eth_l2sec.o
+endif
+
+obj-y                                  += $(LSP_PHY_DIR)/
+
+obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
+obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
+obj-$(CONFIG_MV_IPC_DRIVER)		+= $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
+#obj-y					+= $(PLAT_DRIVERS)/mv_btns/
+obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
+obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
+obj-$(CONFIG_SENSORS_ARMADA_XP)		+= hwmon.o
+# The rest of the drivers are compiled through the driver dir directly.
+
+
+# LSP part
+armadaxp-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
+armadaxp-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+armadaxp-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+armadaxp-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+armadaxp-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+armadaxp-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
+armadaxp-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvSemaphore.o
+armadaxp-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
+obj-$(CONFIG_FB_DOVE_CLCD)		+= clcd.o
+obj-$(CONFIG_PM)			+= pm.o
+
+
+ifdef CONFIG_MV_ETH_NFP
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o
+NFP_OBJS += $(LSP_NET_DEV_DIR)/mv_eth_nfp.o $(HAL_ETH_NFP_DIR)/mvNfp.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_fib_arp_sysfs.o
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpFib.o
+ifdef CONFIG_IPV6
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/ipv6_parsing.o $(LSP_NFP_MGR_DIR)/nfp_fib6_arp_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ct_sysfs.o
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpCt.o
+ifdef CONFIG_IPV6
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ct6_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_classification_sysfs.o $(LSP_NFP_MGR_DIR)/nfp_exact_classification_sysfs.o \
+	   $(LSP_NFP_MGR_DIR)/nfp_prio_classification_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_bridge_sysfs.o
+ifdef CONFIG_MV_ETH_NFP_FDB_MODE
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+else
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpBridge.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_VLAN
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_vlan_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_PPP
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ppp_sysfs.o
+endif
+
+nfp-objs = $(NFP_OBJS)
+obj-$(CONFIG_MV_ETH_NFP) += nfp.o
+
+nfp_learn-objs = $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o
+obj-$(CONFIG_MV_ETH_NFP_LEARN) += nfp_learn.o
diff --git a/arch/arm/mach-armadaxp/Makefile.boot b/arch/arm/mach-armadaxp/Makefile.boot
new file mode 100644
index 0000000..0ef7d93
--- /dev/null
+++ b/arch/arm/mach-armadaxp/Makefile.boot
@@ -0,0 +1,9 @@
+ifdef CONFIG_MV_AMP_ENABLE
+   zreladdr-y   := $(CONFIG_MV_ZREL_ADDR)
+params_phys-y   := $(CONFIG_MV_PARAM_PHYS)
+initrd_phys-y   := $(CONFIG_MV_INITRD_PHYS)
+else
+    zreladdr-y	:= 0x00008000
+ params_phys-y	:= 0x00000100
+ initrd_phys-y	:= 0x00800000
+endif
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
new file mode 100644
index 0000000..c52b9ba
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,2746 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPex.h"
+#include "device/mvDevice.h"
+#include "neta/gbe/mvEthRegs.h"
+#include "gpp/mvGppRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#define DB1(x)	x
+#else
+#define DB(x)
+#define DB1(x)
+#endif
+
+#define CODE_IN_ROM		MV_FALSE
+#define CODE_IN_RAM		MV_TRUE
+
+extern MV_BOARD_INFO *boardInfoTbl[];
+#define BOARD_INFO(boardId)	boardInfoTbl[boardId - BOARD_ID_BASE]
+
+/* Locals */
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+
+MV_U32 tClkRate = -1;
+extern MV_U8 mvDbDisableModuleDetection;
+
+MV_U32 gSerdesZ1AMode = 0;
+
+/*******************************************************************************
+* mvBoardEnvInit - Init board
+*
+* DESCRIPTION:
+*		In this function the board environment take care of device bank
+*		initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_U32 nandDev;
+	MV_U32 norDev;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardEnvInit:Board unknown.\n");
+		return;
+	}
+
+	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+	if (nandDev != 0xFFFFFFFF) {
+		/* Set NAND interface access parameters */
+		nandDev = BOOT_CS;
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), BOARD_INFO(boardId)->nandFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), BOARD_INFO(boardId)->nandFlashWriteParams);
+		MV_REG_WRITE(DEV_NAND_CTRL_REG, BOARD_INFO(boardId)->nandFlashControl);
+	}
+
+	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+	if (norDev != 0xFFFFFFFF) {
+		/* Set NOR interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), BOARD_INFO(boardId)->norFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), BOARD_INFO(boardId)->norFlashWriteParams);
+		MV_REG_WRITE(DEV_BUS_SYNC_CTRL, 0x11);
+	}
+
+	MV_REG_WRITE(MV_RUNIT_PMU_REGS_OFFSET + 0x4, BOARD_INFO(boardId)->pmuPwrUpPolarity);
+	MV_REG_WRITE(MV_RUNIT_PMU_REGS_OFFSET + 0x14, BOARD_INFO(boardId)->pmuPwrUpDelay);
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), BOARD_INFO(boardId)->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), BOARD_INFO(boardId)->gppOutValMid);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(2), BOARD_INFO(boardId)->gppOutValHigh);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValMid);
+	mvGppPolaritySet(2, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValHigh);
+
+	/* Set GPP Out Enable */
+	mvGppTypeSet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValMid);
+	mvGppTypeSet(2, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValHigh);
+}
+/*******************************************************************************
+* mvBoardModelGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns 16bit describing board model.
+*       Board model is constructed of one byte major and minor numbers in the
+*       following manner:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardModelGet(MV_VOID)
+{
+	return (mvBoardIdGet() >> 16);
+}
+/*******************************************************************************
+* mbBoardRevlGet - Get Board revision
+*
+* DESCRIPTION:
+*       This function returns a 32bit describing the board revision.
+*       Board revision is constructed of 4bytes. 2bytes describes major number
+*       and the other 2bytes describes minor munber.
+*       For example for board revision 3.4 the function will return
+*       0x00030004.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardRevGet(MV_VOID)
+{
+	return (mvBoardIdGet() & 0xFFFF);
+}
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsSPrintf(pNameBuff, "Board unknown.\n");
+		return MV_ERROR;
+	}
+	if (mvCtrlModelRevGet() ==  MV_6710_Z1_ID)
+		mvOsSPrintf(pNameBuff, "%s", "DB-6710-Z1");
+	else
+		mvOsSPrintf(pNameBuff, "%s", BOARD_INFO(boardId)->boardName);
+
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	switch (boardId) {
+	case DB_88F78XX0_BP_REV2_ID:
+	case DB_88F78XX0_BP_ID:  /* need to update since Gunit0 can be SGMII */
+		if (ethPortNum > 1)
+			return MV_TRUE;
+		break;
+	case DB_78X60_AMC_ID:
+		if (ethPortNum > 0)
+			return MV_TRUE;
+		break;
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+		if (ethPortNum > 0)
+			return MV_TRUE;
+		break;
+	case DB_78X60_PCAC_ID:
+	case RD_78460_GP_ID:
+	case RD_78460_NAS_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_PCAC_REV2_ID:
+		return MV_TRUE;
+		break;
+
+	default:
+		DB(mvOsPrintf("mvBoardSerdesCfgGet: Unsupported board!\n"));
+		return MV_FALSE;
+	}
+
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
+{
+	if (mvBoardIsGMIIModuleConnected() && (ethPortNum ==0))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardPhyLinkCryptPortAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].LinkCryptPortAddr;
+}
+
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMacSpeedGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (boardId == RD_78460_NAS_ID) {
+		if (mvBoardIsSwitchModuleConnected())
+			return BOARD_MAC_SPEED_1000M;
+	}
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardSpecInitGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: Return MV_TRUE and parameters in case board need spesific phy init,
+*	  otherwise return MV_FALSE.
+*
+*
+*******************************************************************************/
+MV_BOOL mvBoardSpecInitGet(MV_U32 *regOff, MV_U32 *data)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTclkGet - Get the board Tclk (Controller clock)
+*
+* DESCRIPTION:
+*       This routine extract the controller core clock.
+*       This function uses the controller counters to make identification.
+*		Note: In order to avoid interference, make sure task context switch
+*		and interrupts will not occure during this function operation
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardTclkGet(MV_VOID)
+{
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	if ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_TCLK_MASK) != 0)
+		return MV_BOARD_TCLK_200MHZ;
+	else
+		return MV_BOARD_TCLK_250MHZ;
+}
+
+/*******************************************************************************
+* mvBoardSysClkGet - Get the board SysClk (CPU bus clock , i.e. DDR clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU bus clock.
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardSysClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 cpuFreqMhz, ddrFreqMhz;
+	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)),
+									MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	if (clockRatioTbl[idx].vco2cpu != 0) {	/* valid ratio ? */
+		cpuFreqMhz = mvCpuPclkGet() / 1000000;	/* obtain CPU freq */
+		cpuFreqMhz *= clockRatioTbl[idx].vco2cpu;	/* compute VCO freq */
+		ddrFreqMhz = cpuFreqMhz / clockRatioTbl[idx].vco2ddr;
+		/* round up to integer MHz */
+		if (((cpuFreqMhz % clockRatioTbl[idx].vco2ddr) * 10 / clockRatioTbl[idx].vco2ddr) >= 5)
+			ddrFreqMhz++;
+
+		return ddrFreqMhz * 1000000;
+	} else
+		return 0;
+}
+
+/*******************************************************************************
+* mvBoardDebugLedNumGet - Get number of debug Leds
+*
+* DESCRIPTION:
+* INPUT:
+*       boardId
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId)
+{
+	return BOARD_INFO(boardId)->activeLedsNumber;
+}
+
+/*******************************************************************************
+* mvBoardDebugLeg - Set the board debug Leds
+*
+* DESCRIPTION: turn on/off status leds.
+* 	       Note: assume MPP leds are part of group 0 only.
+*
+* INPUT:
+*       hexNum - Number to be displied in hex by Leds.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardDebugLed(MV_U32 hexNum)
+{
+	MV_U32 val[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 mask[MV_GPP_MAX_GROUP] = {0};
+	MV_U32 digitMask;
+	MV_U32 i, pinNum, gppGroup;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (BOARD_INFO(boardId)->pLedGppPin == NULL)
+		return;
+
+	hexNum &= (1 << BOARD_INFO(boardId)->activeLedsNumber) - 1;
+
+	for (i = 0, digitMask = 1; i < BOARD_INFO(boardId)->activeLedsNumber; i++, digitMask <<= 1) {
+			pinNum = BOARD_INFO(boardId)->pLedGppPin[i];
+			gppGroup = pinNum / 32;
+			if (hexNum & digitMask)
+				val[gppGroup]  |= (1 << (pinNum - gppGroup * 32));
+			mask[gppGroup] |= (1 << (pinNum - gppGroup * 32));
+	}
+
+	for (gppGroup = 0; gppGroup < MV_GPP_MAX_GROUP; gppGroup++) {
+		/* If at least one bit is set in the mask, update the whole GPP group */
+		if (mask[gppGroup])
+			mvGppValueSet(gppGroup, mask[gppGroup], BOARD_INFO(boardId)->ledsPolarity == 0 ?
+					val[gppGroup] : ~val[gppGroup]);
+	}
+}
+
+/*******************************************************************************
+* mvBoarGpioPinGet - mvBoarGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		gppClass - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
+{
+	MV_U32 boardId, i;
+	MV_U32 indexFound = 0;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardRTCGpioPinGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == gppClass) {
+			if (indexFound == index)
+				return (MV_U32) BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+		}
+	}
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardReset - mvBoardReset
+*
+* DESCRIPTION:
+*			Reset the board
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvBoardReset(MV_VOID)
+{
+	MV_32 resetPin;
+
+	/* Get gpp reset pin if define */
+	resetPin = mvBoardResetGpioPinGet();
+	if (resetPin != MV_ERROR)
+		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
+	else
+	{
+		/* No gpp reset pin was found, try to reset using system reset out */
+		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
+		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
+	}
+}
+
+/*******************************************************************************
+* mvBoardResetGpioPinGet - mvBoardResetGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardResetGpioPinGet(MV_VOID)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_RESET, 0);
+}
+
+/*******************************************************************************
+* mvBoardSDIOGpioPinGet - mvBoardSDIOGpioPinGet
+*
+* DESCRIPTION:
+*	used for hotswap detection
+* INPUT:
+*	type - Type of SDIO GPP to get.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type)
+{
+	if ((type != BOARD_GPP_SDIO_POWER) && (type != BOARD_GPP_SDIO_DETECT) && (type != BOARD_GPP_SDIO_WP))
+		return MV_FAIL;
+
+	return mvBoarGpioPinNumGet(type, 0);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusGpioPinGet - return Vbus input GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS, devId);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusEnGpioPinGet - return Vbus Enable output GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS_EN, devId);
+}
+
+/*******************************************************************************
+* mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
+*
+* DESCRIPTION:
+*		This function returns a 32-bit mask of GPP pins that connected to
+*		interrupt generating sources on board.
+*		For example if UART channel A is hardwired to GPP pin 8 and
+*		UART channel B is hardwired to GPP pin 4 the fuinction will return
+*		the value 0x000000110
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		See description. The function return -1 if board is not identified.
+*
+*******************************************************************************/
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGpioIntMaskGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	switch (gppGrp) {
+	case (0):
+		return BOARD_INFO(boardId)->intsGppMaskLow;
+		break;
+	case (1):
+		return BOARD_INFO(boardId)->intsGppMaskMid;
+		break;
+	case (2):
+		return BOARD_INFO(boardId)->intsGppMaskHigh;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*	MPP settings are derived from board design.
+*	MPP group consist of 8 MPPs. An MPP group represents MPP
+*	control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	MV_U32 boardId;
+	MV_U32 mppMod;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	mppMod = BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod;
+	if (mppMod >= BOARD_INFO(boardId)->numBoardMppConfigValue)
+		mppMod = 0; /* default */
+
+	return BOARD_INFO(boardId)->pBoardMppConfigValue[mppMod].mppGroup[mppGroupNum];
+}
+
+/*******************************************************************************
+* mvBoardGppConfigGet
+*
+* DESCRIPTION:
+*	Get board configuration according to the input configuration GPP's.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The value of the board configuration GPP's.
+*
+*******************************************************************************/
+MV_U32 mvBoardGppConfigGet(void)
+{
+	MV_U32 boardId, i;
+	MV_U32 result = 0;
+	MV_U32 gpp;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGppConfigGet: Board unknown.\n");
+		return 0;
+	}
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++) {
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
+			gpp = BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			result <<= 1;
+			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
+		}
+	}
+	return result;
+
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiModeGet - return SLIC/DAA connection
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_32 mvBoardTdmSpiModeGet(MV_VOID)
+{
+	return DUAL_CHIP_SELECT_MODE;
+}
+
+/*******************************************************************************
+* mvBoardTdmDevicesCountGet
+*
+* DESCRIPTION:
+*	Return the number of TDM devices on board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	Number of devices.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmDevicesCountGet(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_16 index;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardTdmDevicesCountGet: Board unknown.\n");
+		return 0;
+	}
+
+	index = BOARD_INFO(boardId)->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	return BOARD_INFO(boardId)->numBoardTdmInfo[index];
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiCsGet
+*
+* DESCRIPTION:
+*	Return the SPI Chip-select number for a given device.
+*
+* INPUT:
+*	devId	- The Slic device ID to get the SPI CS for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The SPI CS if found, -1 otherwise.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_16 index;
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardTdmDevicesCountGet: Board unknown.\n");
+		return -1;
+	}
+
+	index = BOARD_INFO(boardId)->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	if (devId >= BOARD_INFO(boardId)->numBoardTdmInfo[index])
+		return -1;
+
+	return BOARD_INFO(boardId)->pBoardTdmInt2CsInfo[index][devId].spiCs;
+}
+
+/*******************************************************************************
+* mvBoardModuleTypePrint
+*
+* DESCRIPTION:
+*	Print on-board detected modules.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
+{
+	mvOsOutput("Modules Detected:\n");
+
+	/* TDM */
+	if (mvBoardTdmDevicesCountGet() > 0)
+		mvOsOutput("       TDM module.\n");
+
+	/* LCD DVI Module */
+	if (mvBoardIsLcdDviModuleConnected())
+		mvOsOutput("       LCD DVI module.\n");
+
+	/* Switch Module */
+	if (mvBoardIsSwitchModuleConnected())
+		mvOsOutput("       Switch module.\n");
+
+	/* GMII Module */
+	if (mvBoardIsGMIIModuleConnected())
+		mvOsOutput("       GMII module.\n");
+
+	return;
+}
+
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
+{
+	/* Pex Module */
+	if (mvBoardIsPexModuleConnected())
+		mvOsOutput("       PEX module.\n");
+	/* SETM Module */
+	if (mvBoardIsSetmModuleConnected())
+		mvOsOutput("       SETM module.\n");
+	/* LVDS Module */
+	if (mvBoardIsLvdsModuleConnected())
+		mvOsOutput("       LVDS module.\n");
+
+	return;
+}
+
+/*******************************************************************************
+* mvBoardIsGbEPortConnected
+*
+* DESCRIPTION:
+*	Checks if a given GbE port is actually connected to the GE-PHY, internal Switch or any RGMII module.
+*
+* INPUT:
+*	port - GbE port number (0 or 1).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_TRUE if port is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum)
+{
+	switch (ethPortNum) {
+	case 0:
+		if (mvBoardIsLcdDviModuleConnected())
+			return MV_FALSE;
+		break;
+	case 1:
+		if (mvBoardIsLcdDviModuleConnected())
+			return MV_FALSE;
+		else if (mvBoardIsGMIIModuleConnected())
+			return MV_FALSE;
+		break;
+	case 2:
+		if ( (mvBoardIsPexModuleConnected()) || (mvBoardIsSetmModuleConnected()) )
+			return MV_FALSE;
+		break;
+	case 3:
+		break;
+	default:
+		break;
+	}
+
+	return MV_TRUE;
+}
+
+/* Board devices API managments */
+
+/*******************************************************************************
+* mvBoardGetDeviceNumber - Get number of device of some type on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		number of those devices else the function returns 0
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devNum;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardGetDeviceNumber:Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devNum].devClass == devClass)
+			foundIndex++;
+	}
+
+	return foundIndex;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBaseAddr - Get base address of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*	Base address else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinBaseLowGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBusWidth - Get Bus width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		Bus width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->busWidth;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWidth - Get dev width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		dev width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->devWidth;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWinSize - Get the window size of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		window size else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return mvCpuIfTargetWinSizeGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* boardGetDevEntry - returns the entry pointer of a device on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devIndex;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("boardGetDevEntry: Board unknown.\n");
+		return NULL;
+	}
+
+	for (devIndex = START_DEV_CS; devIndex < BOARD_INFO(boardId)->numBoardDeviceIf; devIndex++) {
+		if (BOARD_INFO(boardId)->pDevCsInfo[devIndex].devClass == devClass) {
+			if (foundIndex == devNum)
+				return &(BOARD_INFO(boardId)->pDevCsInfo[devIndex]);
+			foundIndex++;
+		}
+	}
+
+	/* device not found */
+	return NULL;
+}
+
+/*******************************************************************************
+* boardGetDevCSNum
+*
+* DESCRIPTION:
+*	Return the device's chip-select number.
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("Board unknown.\n");
+		return 0xFFFFFFFF;
+	}
+
+	devEntry = boardGetDevEntry(devNum, devClass);
+	if (devEntry != NULL)
+		return devEntry->deviceCS;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrTypeGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address type for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address type.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+	}
+	return (MV_ERROR);
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrGet -
+*
+* DESCRIPTION:
+*	Return the TWSI address for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++) {
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+	}
+	return (0xFF);
+}
+
+/*******************************************************************************
+* mvBoardNandWidthGet -
+*
+* DESCRIPTION: Get the width of the first NAND device in bytes
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: 1, 2, 4 or MV_ERROR
+*
+*
+*******************************************************************************/
+MV_32 mvBoardNandWidthGet(void)
+{
+	MV_U32 devNum;
+	MV_U32 devWidth;
+	MV_U32 boardId = mvBoardIdGet();
+
+	for (devNum = START_DEV_CS; devNum < BOARD_INFO(boardId)->numBoardDeviceIf; devNum++) {
+		devWidth = mvBoardGetDeviceWidth(devNum, BOARD_DEV_NAND_FLASH);
+		if (devWidth != MV_ERROR)
+			return (devWidth / 8);
+	}
+
+	/* NAND wasn't found */
+	return MV_ERROR;
+}
+
+MV_U32 gBoardId = -1;
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       This function sets the board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       void
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_VOID)
+{
+	if (gBoardId == -1) {
+#if defined(DB_88F78X60)
+		gBoardId = DB_88F78XX0_BP_ID;
+#elif defined(RD_88F78460_SERVER)
+		gBoardId = RD_78460_SERVER_ID;
+#elif defined(RD_78460_SERVER_REV2)
+		gBoardId = RD_78460_SERVER_REV2_ID;
+#elif defined(DB_78X60_PCAC)
+		gBoardId = DB_78X60_PCAC_ID;
+#elif defined(DB_88F78X60_REV2)
+		gBoardId = DB_88F78XX0_BP_REV2_ID;
+#elif defined(RD_78460_NAS)
+		gBoardId = RD_78460_NAS_ID;
+#elif defined(DB_78X60_AMC)
+		gBoardId = DB_78X60_AMC_ID;
+#elif defined(DB_78X60_PCAC_REV2)
+		gBoardId = DB_78X60_PCAC_REV2_ID;
+#elif defined(RD_78460_GP)
+		gBoardId = RD_78460_GP_ID;
+#elif defined(RD_78460_CUSTOMER)
+		gBoardId = RD_78460_CUSTOMER_ID;
+#else
+		mvOsPrintf("mvBoardIdSet: Board ID must be defined!\n");
+		while (1) {
+			continue;
+		}
+#endif
+	}
+}
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	if (gBoardId == -1) {
+		mvOsWarning();
+		return INVALID_BAORD_ID;
+	}
+
+	return gBoardId;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U8 data;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+
+	twsiSlave.validOffset = MV_TRUE;
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, &data, 1)) {
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+
+	return data;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB1(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* SatR Configuration functions
+*******************************************************************************/
+MV_U8 mvBoardFabFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+	MV_U8 sar1;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	if (RD_78460_GP_ID == boardId)
+		return (sar0 & 0x0f);
+
+	sar1 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar1)
+		return MV_ERROR;
+
+	return ( ((sar1 & 0x1) << 4) | ((sar0 & 0x1E) >> 1) );
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+	if (RD_78460_GP_ID == boardId) {
+		sar0 &= ~(0x0F);
+		sar0 |= (freqVal & 0xF);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+			DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+			return MV_ERROR;
+		}
+		return MV_OK;
+	}
+
+	sar0 &= ~(0xF << 1);
+	sar0 |= (freqVal & 0xF) << 1;
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	sar0 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0x1);
+	sar0 |= ( (freqVal >> 4) & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardFabFreqModeGet(MV_VOID)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	return (sar0 & 0x1);
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0x1);
+	sar0 |= (freqVal & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuFreqModeGet(MV_VOID)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	return (sar0 & 0x1);
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	sar0 &= ~(0x1);
+	sar0 |= (freqVal & 0x1);
+	if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar0)) {
+		DB1(mvOsPrintf("Board: Write FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuFreqGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U8 sarMsb;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (RD_78460_GP_ID == boardId) {
+		return (sar & 0x0f);
+	}
+
+	sarMsb = mvBoardTwsiSatRGet(2, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (  ((sarMsb & 0x1) << 3) | ((sar & 0x1C) >> 2));
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	if (RD_78460_GP_ID == boardId) {
+		sar &= ~0x0f;
+		sar |= (freqVal & 0x0f);
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+	}
+	else{
+		sar &= ~(0x7 << 2);
+		sar |= (freqVal & 0x7) << 2;
+		if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+		sar = mvBoardTwsiSatRGet(2, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &= ~(0x1);
+		sar |= ( (freqVal >> 3) & 0x1);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+
+		sar = mvBoardTwsiSatRGet(2, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+
+		sar &= ~(0x1);
+		sar |= ( (freqVal >> 3) & 0x1);
+		if (MV_OK != mvBoardTwsiSatRSet(2, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write CpuFreq S@R fail\n"));
+			return MV_ERROR;
+		}
+	}
+
+	DB(mvOsPrintf("Board: Write CpuFreq S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardBootDevGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (RD_78460_GP_ID == mvBoardIdGet())
+		sar = (sar >> 1);
+
+	return (sar & 0x7);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardBootDevSet(MV_U8 val)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	if (RD_78460_GP_ID == boardId) {
+		sar &= ~(0x7 << 1);
+		sar |= ((val & 0x7) << 1);
+	}
+	else {
+		sar &= ~(0x7);
+		sar |= (val & 0x7);
+	}
+	if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write BootDev S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDev S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardBootDevWidthGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (RD_78460_GP_ID == boardId)
+		return (sar & 1);
+
+	return (sar & 0x18) >> 3;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+
+	sar = mvBoardTwsiSatRGet(0, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	if (RD_78460_GP_ID == boardId) {
+		sar &= ~(1);
+		sar |= (val & 0x1);
+	}
+	else {
+		sar &= ~(0x3 << 3);
+		sar |= ((val & 0x3) << 3);
+	}
+
+	if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write BootDevWidth S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write BootDevWidth S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+#ifdef MV88F78X60_Z1
+MV_U8 mvBoardCpu0CoreModeGet(MV_VOID)
+#else
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID)
+#endif
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+#ifdef MV88F78X60_Z1
+	return (sar & 0x18) >> 3;
+#else
+	return (sar & 0x08) >> 3;
+#endif
+}
+/*******************************************************************************/
+#ifdef MV88F78X60_Z1
+MV_STATUS mvBoardCpu0CoreModeSet(MV_U8 val)
+#else
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val)
+#endif
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+#ifdef MV88F78X60_Z1
+	sar &= ~(0x3 << 3);
+	sar |= ((val & 0x3) << 3);
+#else
+	sar &= ~(0x1 << 3);
+	sar |= ((val & 0x1) << 3);
+#endif
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write Cpu0CoreMode S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write Cpu0CoreMode S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardL2SizeGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId = mvBoardIdGet();
+	if (RD_78460_GP_ID == boardId) {
+		sar = mvBoardTwsiSatRGet(0, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		return ((sar & 0x10)>>4);
+	}
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x3);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardL2SizeSet(MV_U8 val)
+{
+	MV_U8 sar;
+	if (RD_78460_GP_ID == mvBoardIdGet()) {
+		sar = mvBoardTwsiSatRGet(0, 0);
+		if ((MV_8)MV_ERROR == (MV_8)sar)
+			return MV_ERROR;
+		sar &= ~(0x1 << 4);
+		sar |= ((val & 0x1) << 4);
+		if (MV_OK != mvBoardTwsiSatRSet(0, 0, sar)) {
+			DB1(mvOsPrintf("Board: Write L2Size S@R fail\n"));
+			return MV_ERROR;
+		}
+		return MV_OK;
+	}
+
+	sar = mvBoardTwsiSatRGet(1, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3);
+	sar |= (val & 0x3);
+	if (MV_OK != mvBoardTwsiSatRSet(1, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write L2Size S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write L2Size S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar = (sar & 0x6) >> 1;
+	if (sar == 1)
+		sar = 2;
+	else if (sar == 2)
+		sar =1;
+	return sar;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(3, 0);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+	/* MSB and LSB are swapped on DB board */
+	if (val == 1)
+		val = 2;
+	else if (val == 2)
+		val =1;
+
+	sar &= ~(0x3 << 1);
+	sar |= ((val & 0x3) << 1);
+	if (MV_OK != mvBoardTwsiSatRSet(3, 0, sar)) {
+		DB1(mvOsPrintf("Board: Write CpuCoreNum S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write CpuCoreNum S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvBoardConfIdSet(MV_U16 conf)
+{
+	if (MV_OK != mvBoardTwsiSatRSet(0, 1, conf)) {
+		DB1(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardConfIdGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(0, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0xFF);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= (conf & 0x1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(1, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U16 gPexCap = 0;
+MV_U16 mvBoardPexCapabilityGet(MV_VOID)
+{
+	MV_U8 sar;
+	MV_U32 boardId;
+
+	if (gPexCap)
+		return gPexCap;
+
+	boardId = mvBoardIdGet();
+	switch (boardId) {
+	case DB_78X60_PCAC_ID:
+	case RD_78460_NAS_ID:
+	case RD_78460_GP_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_AMC_ID:
+	case DB_78X60_PCAC_REV2_ID:
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+		sar = 0x1; /* Gen2 */
+		break;
+	case DB_88F78XX0_BP_ID:
+	case FPGA_88F78XX0_ID:
+	case DB_88F78XX0_BP_REV2_ID:
+	default:
+		sar = mvBoardTwsiSatRGet(1, 1);
+		break;
+	}
+	gPexCap = sar & 0x1;
+	
+	return (gPexCap);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardPexModeSet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x3 << 1);
+	sar |= ((conf & 0x3) << 1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(1, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_U16 mvBoardPexModeGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(1, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	return (sar & 0x6) >> 1;
+
+}
+/*******************************************************************************/
+MV_STATUS mvBoardDramEccSet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(3, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x2);
+	sar |= ((conf & 0x1) << 1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(3, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardDramEccGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(3, 1);
+	return ((sar & 0x2) >> 1);
+}
+
+/*******************************************************************************/
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf)
+{
+	MV_U8 sar;
+	sar = mvBoardTwsiSatRGet(3, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar)
+		return MV_ERROR;
+
+	sar &= ~(0x1);
+	sar |= (conf & 0x1);
+
+	if (MV_OK != mvBoardTwsiSatRSet(3, 1, sar)) {
+		DB(mvOsPrintf("Board: Write confID S@R fail\n"));
+		return MV_ERROR;
+	}
+
+	DB(mvOsPrintf("Board: Write confID S@R succeeded\n"));
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_U16 mvBoardDramBusWidthGet(MV_VOID)
+{
+	MV_U8 sar;
+
+	sar = mvBoardTwsiSatRGet(3, 1);
+	return (sar & 0x1);
+}
+
+/*******************************************************************************/
+MV_U8 mvBoardAltFabFreqGet(MV_VOID)
+{
+	MV_U8 sar0;
+
+	sar0 = mvBoardTwsiSatRGet(2, 1);
+	if ((MV_8)MV_ERROR == (MV_8)sar0)
+		return MV_ERROR;
+
+	return (sar0 & 0x1F);
+}
+/*******************************************************************************/
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal)
+{
+	if (MV_OK != mvBoardTwsiSatRSet(2, 1, freqVal)) {
+		DB1(mvOsPrintf("Board: Write Alt FreqOpt S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write Alt FreqOpt S@R succeeded\n"));
+	return MV_OK;
+}
+/*******************************************************************************
+* End of SatR Configuration functions
+*******************************************************************************/
+
+/*******************************************************************************
+* mvBoardMppModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through MPP lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardMppModulesScan(void)
+{
+	MV_U8 regVal;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* Perform scan only for DB board */
+	if ( (boardId == DB_88F78XX0_BP_ID) || (boardId == DB_88F78XX0_BP_REV2_ID) ) {
+		twsiSlave.slaveAddr.address = MV_BOARD_MPP_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_MPP_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			switch (regVal) {
+			case MV_BOARD_LCD_DVI_MODULE_ID:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_LCD_DVI;
+				return MV_OK;
+
+			case MV_BOARD_MII_GMII_MODULE_ID:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_MII_GMII;
+			    BOARD_INFO(boardId)->pBoardMacInfo[0].boardEthSmiAddr = 0x8;
+
+				return MV_OK;
+
+			case MV_BOARD_TDM_MODULE_ID:
+				/*
+				   TODO - how to distinguish between SLIC types?
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_3215;
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_880;
+				   BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_792;
+				   return MV_OK;
+				 */
+				BOARD_INFO(boardId)->boardTdmInfoIndex = BOARD_TDM_SLIC_OTHER;
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_TDM_32CH;
+				return MV_OK;
+
+			default:
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod = MV_BOARD_OTHER;
+				DB1(mvOsPrintf("mvBoardMppModulesScan: Unsupported module!\n"));
+				break;
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardOtherModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through SERDES/LVDS/... lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardOtherModulesScan(void)
+{
+	MV_U8 regVal;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* Perform scan only for DB board */
+	if ( (boardId == DB_88F78XX0_BP_ID) || (boardId == DB_88F78XX0_BP_REV2_ID) ) {
+		/* reset modules flags */
+		BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_NONE;
+
+        /* TWSI init */
+        slave.type = ADDR7_BIT;
+        slave.address = 0;
+        mvTwsiInit(0, TWSI_SPEED , mvBoardTclkGet(), &slave, 0);
+
+ 		/* SERDES module (PEX module and SETM module are supported now) */
+		twsiSlave.slaveAddr.address = MV_BOARD_PEX_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_PEX_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_PEX_MODULE_ID) {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "PEX module DETECTED!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_PEX;
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ PEX module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+
+		/* SERDES module (PEX module and SETM module are supported now) */
+		twsiSlave.slaveAddr.address = MV_BOARD_SETM_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_SETM_MODULE_ADDR_TYPE;
+		twsiSlave.validOffset = MV_TRUE;
+		twsiSlave.offset = 0;
+		twsiSlave.moreThen256 = MV_FALSE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_SETM_MODULE_ID) {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "SETM module DETECTED!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_SETM;
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ PEX module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+
+		/* LVDS (LCD) module */
+		twsiSlave.slaveAddr.address = MV_BOARD_LVDS_MODULE_ADDR;
+		twsiSlave.slaveAddr.type = MV_BOARD_LVDS_MODULE_ADDR_TYPE;
+		if (mvTwsiRead(0, &twsiSlave, &regVal, 1) == MV_OK) {
+			if (regVal == MV_BOARD_LVDS_MODULE_ID) {
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_LVDS;
+				mvCpuIfLvdsPadsEnable(MV_TRUE);
+			} else {
+				DB(mvOsPrintf("mvBoardOtherModulesScan: " "Unknown ID @ LVDS module address!\n"));
+				BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_UNKNOWN;
+			}
+		}
+	} else if (boardId == RD_78460_NAS_ID) {
+		if ((MV_REG_READ(GPP_DATA_IN_REG(2)) & MV_GPP66) == 0x0) {
+			DB(mvOsPrintf("mvBoardOtherModulesScan: SWITCH module DETECTED!\n"));
+			BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod |= MV_BOARD_SWITCH;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPexModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsPexModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_PEX)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsSetmModuleConnected
+*
+* DESCRIPTION:
+*	Check if SETM module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSetmModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsSetmModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_SETM)
+		return MV_TRUE;
+	return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSwitchModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (boardId != RD_78460_NAS_ID)
+		DB(mvOsPrintf("mvBoardIsSwitchModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_SWITCH)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLvdsModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLvdsModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsLvdsModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardOtherMod & MV_BOARD_LVDS)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLcdDviModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLcdDviModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsLcdDviModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod == MV_BOARD_LCD_DVI)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+
+/*******************************************************************************
+* mvBoardIsGMIIModuleConnected
+*
+* DESCRIPTION:
+*	Check if GMII module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGMIIModuleConnected(void)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if ( (boardId != DB_88F78XX0_BP_ID) && (boardId != DB_88F78XX0_BP_REV2_ID) )
+		DB(mvOsPrintf("mvBoardIsGMIIModuleConnected: Unsupported board!\n"));
+	else if (BOARD_INFO(boardId)->pBoardModTypeValue->boardMppMod == MV_BOARD_MII_GMII)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTwsiMuxChannelSet
+*
+* DESCRIPTION:
+*	Set the channel number of the on-board TWSI mux.
+*
+* INPUT:
+*	chNum	- The channel number to set.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum)
+{
+	static MV_U8 currChNum = 0xFF;
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	if (currChNum == muxChNum)
+		return MV_OK;
+
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_TWSI_MUX, 0);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_TWSI_MUX, 0);
+	twsiSlave.validOffset = 0;
+	twsiSlave.offset = 0;
+	twsiSlave.moreThen256 = MV_FALSE;
+	muxChNum += 4;
+	return mvTwsiWrite(0, &twsiSlave, &muxChNum, 1);
+}
+
+/*******************************************************************************
+* mvBoardTwsiReadByteThruMux
+*
+* DESCRIPTION:
+*	Read a single byte from a TWSI device through the TWSI Mux.
+*
+* INPUT:
+*	muxChNum	- The Twsi Mux channel number to read through.
+*	chNum		- The TWSI channel number.
+*	pTwsiSlave	- The TWSI slave address.
+*	data		- Buffer to read into (1 byte).
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data)
+{
+	MV_STATUS res;
+
+	/* Set Mux channel */
+	res = mvBoardTwsiMuxChannelSet(muxChNum);
+	if (res == MV_OK)
+		res = mvTwsiRead(chNum, pTwsiSlave, data, 1);
+
+	return res;
+}
+
+/*******************************************************************************
+* mvBoardSerdesZ1ASupport - Support Z1A silicon serdes configuration
+*
+* DESCRIPTION:
+* 	Default is fixed silicone Z1B. This routine should be called before
+*       calling the serdes initialization in ctrlEnvinit
+*
+* INPUT:
+*	None.
+* OUTPUT:
+*       None.
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_VOID mvBoardSerdesZ1ASupport(void)
+{
+	gSerdesZ1AMode = 1;
+}
+/*******************************************************************************
+* mvBoardIsSerdesConfigurationEnabled
+*
+* DESCRIPTION:
+*       Check if Serdes configuration is enabled on this board.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSerdesConfigurationEnabled(void)
+{
+
+	 MV_U32 boardId = mvBoardIdGet();
+
+	 if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+                mvOsPrintf("mvBoardIsSerdesConfigurationEnabled:Board unknown.\n");
+                return MV_ERROR;
+        }
+	return (BOARD_INFO(boardId)->pBoardSerdesConfigValue->enableSerdesConfiguration);
+}
+
+
+/*******************************************************************************
+* mvBoardSerdesConfigurationEnableSet
+*
+* DESCRIPTION:
+*	Check if Serdes configuration is enabled on this board.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS  mvBoardSerdesConfigurationEnableSet(MV_BOOL enableSerdesConfiguration)
+{
+
+	MV_U32 boardId = mvBoardIdGet();
+	if (!((boardId >= BOARD_ID_BASE) && (boardId < MV_MAX_BOARD_ID))) {
+		mvOsPrintf("mvBoardIsSerdesConfigurationEnabled:Board unknown.\n");
+		return MV_ERROR;
+        }
+	BOARD_INFO(boardId)->pBoardSerdesConfigValue->enableSerdesConfiguration=enableSerdesConfiguration;
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvBoardSledCpuNumGet - Get board SERDES configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_U32 mvBoardSledCpuNumGet(MV_VOID)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(GPP_DATA_IN_REG(0));
+
+	return ((reg & 0xF0000) >> 16);
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board SERDES configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       SERDES configuration structure or NULL on error
+*
+*******************************************************************************/
+MV_SERDES_CFG *mvBoardSerdesCfgGet(void)
+{
+	MV_U32 boardId;
+	MV_U32 serdesCfg = 0; /* default */
+	int pex0 = 1;
+	int pex1 = 1;
+
+	MV_BOOL moduleConnected = mvBoardIsPexModuleConnected();
+	MV_U16 pexMode = mvBoardPexModeGet();
+
+	switch (pexMode) {
+	case 0:
+		pex0 = 1;
+		pex1 = 1;
+		break;
+	case 1:
+		pex0 = 4;
+		pex1 = 1;
+		break;
+	case 2:
+		pex0 = 1;
+		pex1 = 4;
+		break;
+	case 3:
+		pex0 = 4;
+		pex1 = 4;
+		break;
+	}
+
+	boardId = mvBoardIdGet();
+
+	switch (boardId) {
+	case DB_88F78XX0_BP_ID:
+		if (moduleConnected)
+			serdesCfg = 1;
+		/* If backword compatability for Z1A is needed */
+		if (gSerdesZ1AMode)
+			serdesCfg += 2;
+		break;
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+		if (mvBoardSledCpuNumGet() > 0)
+			serdesCfg = 1;
+		break;
+	case DB_88F78XX0_BP_REV2_ID:
+		if ( (!moduleConnected) && (pex0 == 1)) /*if the module is not connected the PEX1 mode is not relevant*/
+			serdesCfg = 0;
+		if ( (moduleConnected) && (pex0 == 1) && (pex1 == 1))
+			serdesCfg = 1;
+		if ( (!moduleConnected) && (pex0 == 4))  /*if the module is not connected the PEX1 mode is not relevant*/
+			serdesCfg = 2;
+		if ( (moduleConnected) && (pex0 == 4) && (pex1 == 1))
+			serdesCfg = 3;
+		if ( (moduleConnected) && (pex0 == 1) && (pex1 == 4))
+			serdesCfg = 4;
+		if ( (moduleConnected) && (pex0 == 4) && (pex1 == 4))
+			serdesCfg = 5;
+		break;
+	case RD_78460_NAS_ID:
+		if (mvBoardIsSwitchModuleConnected())
+			serdesCfg = 1;
+		break;
+	}
+
+	return &BOARD_INFO(boardId)->pBoardSerdesConfigValue[serdesCfg];
+}
+
+
+/*******************************************************************************
+* mvBoardPexInfoGet - Get board PEX Info
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*******************************************************************************/
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	switch (boardId) {
+	case DB_88F78XX0_BP_ID:
+	case RD_78460_SERVER_ID:
+	case RD_78460_SERVER_REV2_ID:
+	case DB_78X60_PCAC_ID:
+	case FPGA_88F78XX0_ID:
+	case DB_88F78XX0_BP_REV2_ID:
+	case RD_78460_NAS_ID:
+	case RD_78460_GP_ID:
+	case RD_78460_CUSTOMER_ID:
+	case DB_78X60_AMC_ID:
+	case DB_78X60_PCAC_REV2_ID:
+		return &BOARD_INFO(boardId)->boardPexInfo;
+		break;
+	default:
+		DB(mvOsPrintf("mvBoardSerdesCfgGet: Unsupported board!\n"));
+		return NULL;
+	}
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
new file mode 100755
index 0000000..fd3611c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,450 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+/* DUART stuff for Tclk detection only */
+#define DUART_BAUD_RATE			115200
+#define MAX_CLOCK_MARGINE		5000000	/* Maximum detected clock margine */
+
+/* Voice devices assembly modes */
+#define DAISY_CHAIN_MODE		1
+#define DUAL_CHIP_SELECT_MODE	0
+#define INTERRUPT_TO_MPP		1
+#define INTERRUPT_TO_TDM		0
+
+/*
+#define BOARD_ETH_PORT_NUM		MV_ETH_MAX_PORTS
+*/
+#define	MV_BOARD_MAX_USB_IF		3
+#define MV_BOARD_MAX_MPP		9	/* number of MPP conf registers */
+#define MV_BOARD_NAME_LEN  		0x20
+
+/* EPPROM Modules detection information */
+
+#define MV_BOARD_EEPROM_MODULE_ADDR		0x50
+#define MV_BOARD_EEPROM_MODULE_ADDR_TYPE	ADDR7_BIT
+
+#define MV_BOARD_PEX_MODULE_ADDR		0x23
+#define MV_BOARD_PEX_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_PEX_MODULE_ID			0
+
+#define MV_BOARD_LVDS_MODULE_ADDR		0x21
+#define MV_BOARD_LVDS_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LVDS_MODULE_ID			0
+
+#define MV_BOARD_SETM_MODULE_ADDR		0x23
+#define MV_BOARD_SETM_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_SETM_MODULE_ID			1
+
+#define MV_BOARD_MPP_MODULE_ADDR		0x20
+#define MV_BOARD_MPP_MODULE_ADDR_TYPE		ADDR7_BIT
+#define MV_BOARD_LCD_DVI_MODULE_ID		0
+#define MV_BOARD_TDM_MODULE_ID			1
+#define MV_BOARD_MII_GMII_MODULE_ID		4
+
+typedef enum {
+	BOARD_EPON_CONFIG,
+	BOARD_GPON_CONFIG,
+	BOARD_PON_NONE,
+	BOARD_PON_AUTO
+} MV_BOARD_PON_CONFIG;
+
+typedef struct _boardData {
+	MV_U32 magic;
+	MV_U16 boardId;
+	MV_U8 boardVer;
+	MV_U8 boardRev;
+	MV_U32 reserved1;
+	MV_U32 reserved2;
+} BOARD_DATA;
+
+typedef enum _devBoardMppGroupClass {
+	MV_BOARD_MPP_GROUP_1,
+	MV_BOARD_MPP_GROUP_2,
+	MV_BOARD_MPP_GROUP_3,
+	MV_BOARD_MAX_MPP_GROUP
+} MV_BOARD_MPP_GROUP_CLASS;
+
+typedef enum _devBoardMppTypeClass {
+	MV_BOARD_AUTO = 0,
+	MV_BOARD_TDM_32CH,
+	MV_BOARD_LCD_DVI,
+	MV_BOARD_MII_GMII,
+	MV_BOARD_OTHER
+} MV_BOARD_MPP_TYPE_CLASS;
+
+typedef enum _devBoardOtherTypeClass {
+	MV_BOARD_NONE    = 0x00000000,
+	MV_BOARD_LVDS    = 0x00000001,
+	MV_BOARD_PEX     = 0x00000002,
+	MV_BOARD_SWITCH  = 0x00000004,
+	MV_BOARD_SETM 	 = 0x00000008,
+	MV_BOARD_UNKNOWN = 0x80000000
+} MV_BOARD_OTHER_TYPE_CLASS;
+
+
+#define MV_BOARD_TDM	MV_BOARD_TDM_32CH
+
+typedef struct _boardModuleTypeInfo {
+	MV_BOARD_MPP_TYPE_CLASS boardMppMod;
+	MV_BOARD_OTHER_TYPE_CLASS boardOtherMod;
+} MV_BOARD_MODULE_TYPE_INFO;
+
+typedef enum _devBoardClass {
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER
+} MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass {
+	BOARD_TWSI_RTC,
+	BOARD_DEV_TWSI_EXP,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_TWSI_MUX,
+	BOARD_TWSI_OTHER
+} MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass {
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+	BOARD_GPP_SDIO_POWER,
+	BOARD_GPP_SDIO_DETECT,
+	BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_CONF,
+	BOARD_GPP_OTHER
+} MV_BOARD_GPP_CLASS;
+
+typedef struct _devCsInfo {
+	MV_U8 deviceCS;
+	MV_U32 params;
+	MV_U32 devClass;	/* MV_BOARD_DEV_CLASS */
+	MV_U8 devWidth;
+	MV_U8 busWidth;
+} MV_DEV_CS_INFO;
+
+typedef struct _boardLedInfo {
+	MV_U8 activeLedsNumber;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+	MV_U8 *gppPinNum;	/* Pointer to GPP values */
+} MV_BOARD_LED_INFO;
+
+typedef struct _boardGppInfo {
+	MV_BOARD_GPP_CLASS devClass;
+	MV_U8 gppPinNum;
+} MV_BOARD_GPP_INFO;
+
+typedef struct _boardTwsiInfo {
+	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 twsiDevAddr;
+	MV_U8 twsiDevAddrType;
+} MV_BOARD_TWSI_INFO;
+
+typedef enum _boardMacSpeed {
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO
+} MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo {
+	MV_BOARD_MAC_SPEED boardMacSpeed;
+	MV_U8 boardEthSmiAddr;
+	MV_U16 LinkCryptPortAddr;
+} MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo {
+	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
+} MV_BOARD_MPP_INFO;
+
+typedef struct {
+	MV_U8 spiCs;
+} MV_BOARD_TDM_INFO;
+
+typedef struct _boardPexUnitCfg {
+	MV_PEX_UNIT_CFG 	pexCfg;
+	MV_U8			pexLaneStat[4];	/* 1: enabled, 2: disabled */
+} MV_BOARD_PEX_UNIT_CFG;
+
+typedef struct _boardPexInfo {
+	MV_PEXIF_INDX 		pexMapping[MV_PEX_MAX_IF];
+	MV_BOARD_PEX_UNIT_CFG 	pexUnitCfg[MV_PEX_MAX_UNIT];
+	MV_U32			boardPexIfNum;
+} MV_BOARD_PEX_INFO;
+
+typedef enum {
+	BOARD_TDM_SLIC_880 = 0,
+	BOARD_TDM_SLIC_792,
+	BOARD_TDM_SLIC_3215,
+	BOARD_TDM_SLIC_OTHER,
+	BOARD_TDM_SLIC_COUNT
+} MV_BOARD_TDM_SLIC_TYPE;
+
+typedef struct _boardInfo {
+	char boardName[MV_BOARD_NAME_LEN];
+	MV_U8 numBoardMppTypeValue;
+	MV_BOARD_MODULE_TYPE_INFO *pBoardModTypeValue;
+	MV_U8 numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO *pBoardMppConfigValue;
+	MV_U8 numBoardSerdesConfigValue;
+	MV_SERDES_CFG *pBoardSerdesConfigValue;
+	MV_U32 intsGppMaskLow;
+	MV_U32 intsGppMaskMid;
+	MV_U32 intsGppMaskHigh;
+	MV_U8 numBoardDeviceIf;
+	MV_DEV_CS_INFO *pDevCsInfo;
+	MV_U8 numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
+	MV_U8 numBoardMacInfo;
+	MV_BOARD_MAC_INFO *pBoardMacInfo;
+	MV_U8 numBoardGppInfo;
+	MV_BOARD_GPP_INFO *pBoardGppInfo;
+	MV_U8 activeLedsNumber;
+	MV_U8 *pLedGppPin;
+	MV_U8 ledsPolarity;	/* '0' or '1' to turn on led */
+
+	MV_U8	pmuPwrUpPolarity;
+	MV_U32	pmuPwrUpDelay;
+	/* GPP values */
+	MV_U32 gppOutEnValLow;
+	MV_U32 gppOutEnValMid;
+	MV_U32 gppOutEnValHigh;
+	MV_U32 gppOutValLow;
+	MV_U32 gppOutValMid;
+	MV_U32 gppOutValHigh;
+	MV_U32 gppPolarityValLow;
+	MV_U32 gppPolarityValMid;
+	MV_U32 gppPolarityValHigh;
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	 */
+	MV_U8 numBoardTdmInfo[BOARD_TDM_SLIC_COUNT];
+	MV_BOARD_TDM_INFO *pBoardTdmInt2CsInfo[BOARD_TDM_SLIC_COUNT];
+	MV_16 boardTdmInfoIndex;
+
+	/* NAND init params */
+	MV_U32 nandFlashReadParams;
+	MV_U32 nandFlashWriteParams;
+	MV_U32 nandFlashControl;
+	MV_BOARD_PEX_INFO	boardPexInfo;	/* filled in runtime */
+	MV_U32 norFlashReadParams;
+	MV_U32 norFlashWriteParams;
+
+} MV_BOARD_INFO;
+
+/* For backward compatability with Legacy mode */
+#define mvBoardSwitchConnectedPortGet(port)	(-1)
+#define mvBoardIsSwitchConnected(port)  	(mvBoardSwitchConnectedPortGet(port) != -1)
+/*#define mvBoardLinkStatusIrqGet(port)		mvBoardSwitchIrqGet()*/
+
+MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U16 mvBoardModelGet(MV_VOID);
+MV_U16 mvBoardRevGet(MV_VOID);
+MV_STATUS mvBoardNameGet(char *pNameBuff);
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
+
+MV_BOOL mvBoardSpecInitGet(MV_U32 *regOff, MV_U32 *data);
+MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardSysClkGet(MV_VOID);
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
+MV_VOID mvBoardDebugLed(MV_U32 hexNum);
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+MV_VOID mvBoardReset(MV_VOID);
+MV_32 mvBoardResetGpioPinGet(MV_VOID);
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type);
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId);
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId);
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
+MV_U32 mvBoardGppConfigGet(void);
+MV_32 mvBoardTdmSpiModeGet(MV_VOID);
+MV_U8 mvBoardTdmDevicesCountGet(void);
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_32 mvBoardNandWidthGet(void);
+MV_U32 mvBoardIdGet(MV_VOID);
+MV_VOID mvBoardIdSet(MV_VOID);
+MV_U32 mvBoardSledCpuNumGet(MV_VOID);
+
+MV_U8 mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum);
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U8 mvBoardFabFreqGet(MV_VOID);
+MV_STATUS mvBoardFabFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
+MV_U8 mvBoardFabFreqModeGet(MV_VOID);
+MV_STATUS mvBoardFabFreqModeSet(MV_U8 freqVal);
+MV_U8 mvBoardBootDevGet(MV_VOID);
+MV_STATUS mvBoardBootDevSet(MV_U8 val);
+MV_U8 mvBoardBootDevWidthGet(MV_VOID);
+MV_STATUS mvBoardBootDevWidthSet(MV_U8 val);
+#ifdef MV88F78X60_Z1
+MV_U8 mvBoardCpu0CoreModeGet(MV_VOID);
+MV_STATUS mvBoardCpu0CoreModeSet(MV_U8 val);
+#else
+MV_U8 mvBoardCpu0EndianessGet(MV_VOID);
+MV_STATUS mvBoardCpu0EndianessSet(MV_U8 val);
+#endif
+MV_U8 mvBoardL2SizeGet(MV_VOID);
+MV_STATUS mvBoardL2SizeSet(MV_U8 val);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
+MV_STATUS mvBoardConIdSet(MV_U16 conf);
+MV_U16 mvBoardConfIdGet(MV_VOID);
+MV_STATUS mvBoardPexCapabilitySet(MV_U16 conf);
+MV_U16 mvBoardPexCapabilityGet(MV_VOID);
+MV_STATUS mvBoardDramEccSet(MV_U16 conf);
+MV_U16 mvBoardDramEccGet(MV_VOID);
+MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf);
+MV_U16 mvBoardDramBusWidthGet(MV_VOID);
+MV_U8 mvBoardAltFabFreqGet(MV_VOID);
+MV_STATUS mvBoardAltFabFreqSet(MV_U8 freqVal);
+MV_STATUS mvBoardMppModulesScan(void);
+MV_STATUS mvBoardOtherModulesScan(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_BOOL mvBoardIsSwitchModuleConnected(void);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_BOOL mvBoardIsGMIIModuleConnected(void);
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_VOID mvBoardSerdesZ1ASupport(void);
+MV_BOOL mvBoardIsSerdesConfigurationEnabled(void);
+MV_STATUS  mvBoardSerdesConfigurationEnableSet(MV_BOOL enableSerdesconfig);
+MV_SERDES_CFG *mvBoardSerdesCfgGet(void);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
+MV_STATUS mvBoardConfIdSet(MV_U16 conf);
+MV_U16 mvBoardPexModeGet(MV_VOID);
+MV_STATUS mvBoardPexModeSet(MV_U16 conf);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
new file mode 100644
index 0000000..c1030cc
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,1492 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPexRegs.h"
+
+#define ARRSZ(x)	(sizeof(x)/sizeof(x[0]))
+
+/**********************/
+/* ARMADA-XP DB BOARD */
+/**********************/
+#define DB_88F78XX0_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_88F78XX0_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_88F78XX0_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_88F78XX0_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F78XX0_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_U8 mvDbDisableModuleDetection = 0;
+
+MV_U8	db88f6781InfoBoardDebugLedIf[] = {26, 27, 48};
+
+MV_BOARD_TWSI_INFO	db88f78XX0InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db88f78XX0InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x19,0x800},  /* Port 1 */
+	{BOARD_MAC_SPEED_AUTO, 0x1B,0x1800}  /* Port 3 */
+};
+
+MV_BOARD_MODULE_TYPE_INFO db88f78XX0InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db88f78XX0InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24}, /* from MPP map */
+	{BOARD_GPP_RESET,       47},
+};
+
+MV_DEV_CS_INFO db88f78XX0InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db88f78XX0InfoBoardMppConfigValue[] = {
+	{ {
+	DB_88F78XX0_MPP0_7,
+	DB_88F78XX0_MPP8_15,
+	DB_88F78XX0_MPP16_23,
+	DB_88F78XX0_MPP24_31,
+	DB_88F78XX0_MPP32_39,
+	DB_88F78XX0_MPP40_47,
+	DB_88F78XX0_MPP48_55,
+	DB_88F78XX0_MPP56_63,
+	DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_TDM_32CH */
+		DB_88F78XX0_MPP0_7,
+		DB_88F78XX0_MPP8_15,
+		DB_88F78XX0_MPP16_23,
+		(DB_88F78XX0_MPP24_31 & 0x00000000) | 0x33333333,
+		(DB_88F78XX0_MPP32_39 & 0xFFFF0000) | 0x00003333,
+		(DB_88F78XX0_MPP40_47 & 0xFFFFF0FF) | 0x00000300,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_LCD_DVI */
+		(DB_88F78XX0_MPP0_7   & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP8_15  & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP16_23 & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_MPP24_31 & 0xFFFF0000) | 0x00004444,
+		DB_88F78XX0_MPP32_39,
+		(DB_88F78XX0_MPP40_47 & 0xFFFFFF00) | 0x00000044,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_MII_GMII */
+		(DB_88F78XX0_MPP0_7 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_MPP8_15 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_MPP16_23 & 0x000000FF) | 0x11111100,
+		DB_88F78XX0_MPP24_31,
+		DB_88F78XX0_MPP32_39,
+		DB_88F78XX0_MPP40_47,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+	{ { /* MV_BOARD_OTHER */
+		DB_88F78XX0_MPP0_7,
+		DB_88F78XX0_MPP8_15,
+		DB_88F78XX0_MPP16_23,
+		DB_88F78XX0_MPP24_31,
+		DB_88F78XX0_MPP32_39,
+		DB_88F78XX0_MPP40_47,
+		DB_88F78XX0_MPP48_55,
+		DB_88F78XX0_MPP56_63,
+		DB_88F78XX0_MPP64_67,
+	} },
+};
+
+MV_SERDES_CFG db88f78XX0InfoBoardSerdesConfigValue[] = {
+	/* Z1B */
+	{MV_TRUE, 0x32221111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* Default */
+	{MV_TRUE, 0x31211111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X1,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* PEX module */
+	/* Z1A */
+	{MV_TRUE, 0x32220000, 0x00000000, PEX_BUS_DISABLED, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000030},	/* Default - Z1A */
+	{MV_TRUE, 0x31210000, 0x00000000, PEX_BUS_DISABLED, PEX_BUS_MODE_X1,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000030}	/* PEX module - Z1A */
+};
+
+MV_BOARD_TDM_INFO	db88f78XX0Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	db88f78XX0Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db88f78XX0Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO db88f78XX0Info = {
+	.boardName			= "DB-78460-BP",
+	.numBoardMppTypeValue		= ARRSZ(db88f78XX0InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f78XX0InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db88f78XX0InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db88f78XX0InfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(db88f78XX0InfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= db88f78XX0InfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db88f78XX0InfoBoardDeCsInfo),
+	.pDevCsInfo			= db88f78XX0InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f78XX0InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f78XX0InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f78XX0InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f78XX0InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db88f78XX0InfoBoardGppInfo),
+	.pBoardGppInfo			= db88f78XX0InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db88f6781InfoBoardDebugLedIf),
+	.pLedGppPin			= db88f6781InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_88F78XX0_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F78XX0_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F78XX0_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F78XX0_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F78XX0_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F78XX0_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F78XX0_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F78XX0_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F78XX0_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db88f78XX0Tdm880,
+					   db88f78XX0Tdm792,
+					   db88f78XX0Tdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_88F78XX0_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F78XX0_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_88F78XX0_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= DB_88F78XX0_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_88F78XX0_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP DB REV2 BOARD */
+/***************************/
+#define DB_88F78XX0_REV2_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_88F78XX0_REV2_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_88F78XX0_REV2_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_88F78XX0_REV2_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F78XX0_REV2_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_U8 mvDbDisableModuleDetection_rev2 = 0;
+
+MV_U8	db88f6781InfoBoardDebugLedIf_rev2[] = {26, 27, 48};
+
+MV_BOARD_TWSI_INFO	db88f78XX0rev2InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db88f78XX0rev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x19,0x800},  /* Port 1 */
+	{BOARD_MAC_SPEED_AUTO, 0x1B,0x1800}  /* Port 3 */
+};
+
+MV_BOARD_MODULE_TYPE_INFO db88f78XX0rev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db88f78XX0rev2InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+	/*{BOARD_GPP_RESET,       47},*/
+};
+
+MV_DEV_CS_INFO db88f78XX0rev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16} /* NOR DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db88f78XX0rev2InfoBoardMppConfigValue[] = {
+	{ {
+	DB_88F78XX0_REV2_MPP0_7,
+	DB_88F78XX0_REV2_MPP8_15,
+	DB_88F78XX0_REV2_MPP16_23,
+	DB_88F78XX0_REV2_MPP24_31,
+	DB_88F78XX0_REV2_MPP32_39,
+	DB_88F78XX0_REV2_MPP40_47,
+	DB_88F78XX0_REV2_MPP48_55,
+	DB_88F78XX0_REV2_MPP56_63,
+	DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_TDM_32CH */
+		DB_88F78XX0_REV2_MPP0_7,
+		DB_88F78XX0_REV2_MPP8_15,
+		DB_88F78XX0_REV2_MPP16_23,
+		(DB_88F78XX0_REV2_MPP24_31 & 0x00000000) | 0x33333333,
+		(DB_88F78XX0_REV2_MPP32_39 & 0xFFFF0000) | 0x00003333,
+		(DB_88F78XX0_REV2_MPP40_47 & 0xFFFFF0FF) | 0x00000300,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_LCD_DVI */
+		(DB_88F78XX0_REV2_MPP0_7   & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP8_15  & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP16_23 & 0x00000000) | 0x44444444,
+		(DB_88F78XX0_REV2_MPP24_31 & 0xFFFF0000) | 0x00004444,
+		DB_88F78XX0_REV2_MPP32_39,
+		(DB_88F78XX0_REV2_MPP40_47 & 0xFFFFFF00) | 0x00000044,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_MII_GMII */
+		(DB_88F78XX0_REV2_MPP0_7 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_REV2_MPP8_15 & 0x00000000) | 0x11111111,
+		(DB_88F78XX0_REV2_MPP16_23 & 0x000000FF) | 0x11111100,
+		DB_88F78XX0_REV2_MPP24_31,
+		DB_88F78XX0_REV2_MPP32_39,
+		DB_88F78XX0_REV2_MPP40_47,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+	{ { /* MV_BOARD_OTHER */
+		DB_88F78XX0_REV2_MPP0_7,
+		DB_88F78XX0_REV2_MPP8_15,
+		DB_88F78XX0_REV2_MPP16_23,
+		DB_88F78XX0_REV2_MPP24_31,
+		DB_88F78XX0_REV2_MPP32_39,
+		DB_88F78XX0_REV2_MPP40_47,
+		DB_88F78XX0_REV2_MPP48_55,
+		DB_88F78XX0_REV2_MPP56_63,
+		DB_88F78XX0_REV2_MPP64_67,
+	} },
+};
+
+MV_SERDES_CFG db88f78XX0rev2InfoBoardSerdesConfigValue[] = {
+	/* A0 */
+	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Default: No Pex module, PEX0 x1, disabled*/
+	{MV_TRUE, 0x31211111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x1*/
+	{MV_TRUE, 0x33221111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* no Pex module, PEX0 x4, PEX1 disabled*/
+	{MV_TRUE, 0x31211111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X1,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x1*/
+	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x1, PEX1 x4*/
+	{MV_TRUE, 0x11111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4,PEX_BUS_MODE_X4,PEX_BUS_MODE_X4, 0x00000030},/* Pex module, PEX0 x4, PEX1 x4*/
+};
+
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db88f78XX0rev2Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO db88f78XX0rev2Info = {
+	.boardName			= "DB-78460-BP rev 2.0",
+	.numBoardMppTypeValue		= ARRSZ(db88f78XX0rev2InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f78XX0rev2InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db88f78XX0rev2InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db88f78XX0rev2InfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(db88f78XX0rev2InfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= db88f78XX0rev2InfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db88f78XX0rev2InfoBoardDeCsInfo),
+	.pDevCsInfo			= db88f78XX0rev2InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f78XX0rev2InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f78XX0rev2InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f78XX0rev2InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f78XX0rev2InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db88f78XX0rev2InfoBoardGppInfo),
+	.pBoardGppInfo			= db88f78XX0rev2InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db88f6781InfoBoardDebugLedIf),
+	.pLedGppPin			= db88f6781InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_88F78XX0_REV2_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F78XX0_REV2_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F78XX0_REV2_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F78XX0_REV2_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F78XX0_REV2_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F78XX0_REV2_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F78XX0_REV2_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F78XX0_REV2_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F78XX0_REV2_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db88f78XX0rev2Tdm880,
+					   db88f78XX0rev2Tdm792,
+					   db88f78XX0rev2Tdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_88F78XX0_REV2_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F78XX0_REV2_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_88F78XX0_REV2_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= DB_88F78XX0_REV2_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_88F78XX0_REV2_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP RD NAS  BOARD */
+/***************************/
+#define RD_78460_NAS_BOARD_NAND_READ_PARAMS	0x000C0282
+#define RD_78460_NAS_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_NAS_BOARD_NAND_CONTROL		0x01c00543
+
+#define RD_78460_NAS_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define RD_78460_NAS_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_MAC_INFO rd78460nasInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+        /* speed will toggle to force link 1000 when SW module detected */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460nasInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO rd78460nasInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460nasInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460nasInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_NAS_MPP0_7,
+	RD_78460_NAS_MPP8_15,
+	RD_78460_NAS_MPP16_23,
+	RD_78460_NAS_MPP24_31,
+	RD_78460_NAS_MPP32_39,
+	RD_78460_NAS_MPP40_47,
+	RD_78460_NAS_MPP48_55,
+	RD_78460_NAS_MPP56_63,
+	RD_78460_NAS_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG rd78460nasInfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x00223001, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* Default */
+	{MV_TRUE, 0x33320201, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x000000f4},	/* Switch module */
+};
+
+MV_BOARD_INFO rd78460nasInfo = {
+	.boardName			= "RD-AXP-NAS rev 1.0",
+	.numBoardMppTypeValue		= ARRSZ(rd78460nasInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460nasInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460nasInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460nasInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(rd78460nasInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= rd78460nasInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460nasInfoBoardDeCsInfo),
+	.pDevCsInfo			= rd78460nasInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(rd78460nasInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460nasInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460nasInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460nasInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_NAS_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_NAS_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_NAS_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_NAS_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_NAS_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_NAS_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_NAS_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_NAS_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_NAS_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_NAS_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_NAS_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_NAS_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_NAS_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_NAS_BOARD_NOR_WRITE_PARAMS
+};
+
+/*****************************/
+/* ARMADA-XP RD SERVER BOARD */
+/*****************************/
+#define RD_78460_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_BOARD_NAND_CONTROL			0x01c00543
+
+MV_BOARD_MAC_INFO rd78460InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_1000M, 0x1,0x0},
+	{BOARD_MAC_SPEED_1000M, 0x2,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0},
+	{BOARD_MAC_SPEED_1000M, 0x1B,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_DEV_CS_INFO rd78460InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460InfoBoardMppConfigValue[] = {
+	{ {
+		RD_78460_MPP0_7,
+		RD_78460_MPP8_15,
+		RD_78460_MPP16_23,
+		RD_78460_MPP24_31,
+		RD_78460_MPP32_39,
+		RD_78460_MPP40_47,
+		RD_78460_MPP48_55,
+		RD_78460_MPP56_63,
+		RD_78460_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG rd78460InfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x22321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010},	/* CPU0 */
+	{MV_TRUE, 0x00321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010}	/* CPU1-3 */
+};
+
+MV_BOARD_INFO rd78460Info = {
+ .boardName				= "RD-78460-SERVER",
+ .numBoardMppTypeValue			= ARRSZ(rd78460InfoBoardModTypeInfo),
+ .pBoardModTypeValue			= rd78460InfoBoardModTypeInfo,
+ .numBoardMppConfigValue		= ARRSZ(rd78460InfoBoardMppConfigValue),
+ .pBoardMppConfigValue			= rd78460InfoBoardMppConfigValue,
+ .numBoardSerdesConfigValue		= ARRSZ(rd78460InfoBoardSerdesConfigValue),
+ .pBoardSerdesConfigValue		= rd78460InfoBoardSerdesConfigValue,
+ .intsGppMaskLow			= 0,
+ .intsGppMaskMid			= 0,
+ .intsGppMaskHigh			= 0,
+ .numBoardDeviceIf			= ARRSZ(rd78460InfoBoardDeCsInfo),
+ .pDevCsInfo				= rd78460InfoBoardDeCsInfo,
+ .numBoardTwsiDev			= 0,
+ .pBoardTwsiDev				= NULL,
+ .numBoardMacInfo			= ARRSZ(rd78460InfoBoardMacInfo),
+ .pBoardMacInfo				= rd78460InfoBoardMacInfo,
+ .numBoardGppInfo			= 0,
+ .pBoardGppInfo				= NULL,
+ .activeLedsNumber			= 0,
+ .pLedGppPin				= NULL,
+ .ledsPolarity				= 0,
+
+ /* GPP values */
+ .gppOutEnValLow			= RD_78460_GPP_OUT_ENA_LOW,
+ .gppOutEnValMid			= RD_78460_GPP_OUT_ENA_MID,
+ .gppOutEnValHigh			= RD_78460_GPP_OUT_ENA_HIGH,
+ .gppOutValLow				= RD_78460_GPP_OUT_VAL_LOW,
+ .gppOutValMid				= RD_78460_GPP_OUT_VAL_MID,
+ .gppOutValHigh				= RD_78460_GPP_OUT_VAL_HIGH,
+ .gppPolarityValLow			= RD_78460_GPP_POL_LOW,
+ .gppPolarityValMid			= RD_78460_GPP_POL_MID,
+ .gppPolarityValHigh			= RD_78460_GPP_POL_HIGH,
+
+ /* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+ ** can be connected to board.
+ ** When modules are scanned, then we select the index of the relevant
+ ** slic's information array.
+ ** For RD and Customers boards we only need to initialize a single
+ ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+ .numBoardTdmInfo			= {},
+ .pBoardTdmInt2CsInfo			= {},
+ .boardTdmInfoIndex			= -1,
+
+ /* NAND init params */
+ .nandFlashReadParams			= RD_78460_BOARD_NAND_READ_PARAMS,
+ .nandFlashWriteParams			= RD_78460_BOARD_NAND_WRITE_PARAMS,
+ .nandFlashControl			= RD_78460_BOARD_NAND_CONTROL
+};
+
+
+/*****************************/
+/* ARMADA-XP RD SERVER REV2 BOARD */
+/*****************************/
+#define RD_78460_SERVER_REV2_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_SERVER_REV2_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_SERVER_REV2_BOARD_NAND_CONTROL			0x01c00543
+
+MV_BOARD_MAC_INFO rd78460ServerRev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_1000M, 0x1,0x0},
+	{BOARD_MAC_SPEED_1000M, 0x2,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0},
+	{BOARD_MAC_SPEED_1000M, 0x1B,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460ServerRev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_DEV_CS_INFO rd78460ServerRev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460ServerRev2InfoBoardMppConfigValue[] = {
+	{ {
+		RD_78460_SERVER_REV2_MPP0_7,
+		RD_78460_SERVER_REV2_MPP8_15,
+		RD_78460_SERVER_REV2_MPP16_23,
+		RD_78460_SERVER_REV2_MPP24_31,
+		RD_78460_SERVER_REV2_MPP32_39,
+		RD_78460_SERVER_REV2_MPP40_47,
+		RD_78460_SERVER_REV2_MPP48_55,
+		RD_78460_SERVER_REV2_MPP56_63,
+		RD_78460_SERVER_REV2_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG rd78460ServerRev2InfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x00321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010},	/* CPU0 */
+	{MV_TRUE, 0x00321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010}	/* CPU1-3 */
+};
+
+MV_BOARD_INFO rd78460ServerRev2Info = {
+ .boardName				= "RD-78460-SERVER-REV2",
+ .numBoardMppTypeValue			= ARRSZ(rd78460ServerRev2InfoBoardModTypeInfo),
+ .pBoardModTypeValue			= rd78460ServerRev2InfoBoardModTypeInfo,
+ .numBoardMppConfigValue		= ARRSZ(rd78460ServerRev2InfoBoardMppConfigValue),
+ .pBoardMppConfigValue			= rd78460ServerRev2InfoBoardMppConfigValue,
+ .numBoardSerdesConfigValue		= ARRSZ(rd78460ServerRev2InfoBoardSerdesConfigValue),
+ .pBoardSerdesConfigValue		= rd78460ServerRev2InfoBoardSerdesConfigValue,
+ .intsGppMaskLow			= 0,
+ .intsGppMaskMid			= 0,
+ .intsGppMaskHigh			= 0,
+ .numBoardDeviceIf			= ARRSZ(rd78460ServerRev2InfoBoardDeCsInfo),
+ .pDevCsInfo				= rd78460ServerRev2InfoBoardDeCsInfo,
+ .numBoardTwsiDev			= 0,
+ .pBoardTwsiDev				= NULL,
+ .numBoardMacInfo			= ARRSZ(rd78460ServerRev2InfoBoardMacInfo),
+ .pBoardMacInfo				= rd78460ServerRev2InfoBoardMacInfo,
+ .numBoardGppInfo			= 0,
+ .pBoardGppInfo				= NULL,
+ .activeLedsNumber			= 0,
+ .pLedGppPin				= NULL,
+ .ledsPolarity				= 0,
+
+ /* GPP values */
+ .gppOutEnValLow			= RD_78460_SERVER_REV2_GPP_OUT_ENA_LOW,
+ .gppOutEnValMid			= RD_78460_SERVER_REV2_GPP_OUT_ENA_MID,
+ .gppOutEnValHigh			= RD_78460_SERVER_REV2_GPP_OUT_ENA_HIGH,
+ .gppOutValLow				= RD_78460_SERVER_REV2_GPP_OUT_VAL_LOW,
+ .gppOutValMid				= RD_78460_SERVER_REV2_GPP_OUT_VAL_MID,
+ .gppOutValHigh				= RD_78460_SERVER_REV2_GPP_OUT_VAL_HIGH,
+ .gppPolarityValLow			= RD_78460_SERVER_REV2_GPP_POL_LOW,
+ .gppPolarityValMid			= RD_78460_SERVER_REV2_GPP_POL_MID,
+ .gppPolarityValHigh			= RD_78460_SERVER_REV2_GPP_POL_HIGH,
+
+ /* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+ ** can be connected to board.
+ ** When modules are scanned, then we select the index of the relevant
+ ** slic's information array.
+ ** For RD and Customers boards we only need to initialize a single
+ ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+ .numBoardTdmInfo			= {},
+ .pBoardTdmInt2CsInfo			= {},
+ .boardTdmInfoIndex			= -1,
+
+ /* NAND init params */
+ .nandFlashReadParams			= RD_78460_SERVER_REV2_BOARD_NAND_READ_PARAMS,
+ .nandFlashWriteParams			= RD_78460_SERVER_REV2_BOARD_NAND_WRITE_PARAMS,
+ .nandFlashControl			= RD_78460_SERVER_REV2_BOARD_NAND_CONTROL
+};
+/***************************/
+/* ARMADA-XP DB PCAC BOARD */
+/***************************/
+#define DB_78X60_PCAC_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_PCAC_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_PCAC_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60pcacInfoBoardDebugLedIf[] = {53, 54, 55, 56};
+
+MV_BOARD_TWSI_INFO	db78X60pcacInfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO db78X60pcacInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0}		/* Dummy */
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60pcacInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod	= MV_BOARD_AUTO,
+		.boardOtherMod	= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db78X60pcacInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    23} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60pcacInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60pcacInfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_PCAC_MPP0_7,
+		DB_78X60_PCAC_MPP8_15,
+		DB_78X60_PCAC_MPP16_23,
+		DB_78X60_PCAC_MPP24_31,
+		DB_78X60_PCAC_MPP32_39,
+		DB_78X60_PCAC_MPP40_47,
+		DB_78X60_PCAC_MPP48_55,
+		DB_78X60_PCAC_MPP56_63,
+		DB_78X60_PCAC_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG db78X60pcacInfoBoardSerdesConfigValue[] = {
+	 {MV_TRUE, 0x22321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED,PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010} /* Default */
+};
+
+
+MV_BOARD_TDM_INFO	db78X60pcacTdm880[]		= { {1}, {2} };
+MV_BOARD_TDM_INFO	db78X60pcacTdm792[]		= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	db78X60pcacTdm3215[]	= { {1} };
+
+MV_BOARD_INFO db78X60pcacInfo = {
+	.boardName			= "DB-78460-PCAC",
+	.numBoardMppTypeValue		= ARRSZ(db78X60pcacInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60pcacInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60pcacInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60pcacInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(db78X60pcacInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= db78X60pcacInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60pcacInfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60pcacInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db78X60pcacInfoBoardTwsiDev),
+	.pBoardTwsiDev			= db78X60pcacInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db78X60pcacInfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60pcacInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60pcacInfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60pcacInfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60pcacInfoBoardDebugLedIf),
+	.pLedGppPin			= db78X60pcacInfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_PCAC_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_PCAC_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_PCAC_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_PCAC_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_PCAC_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_PCAC_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_PCAC_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_PCAC_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_PCAC_GPP_POL_HIGH,
+
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {2, 6, 1},
+	.pBoardTdmInt2CsInfo		= {db78X60pcacTdm880,
+					   db78X60pcacTdm792,
+					   db78X60pcacTdm3215},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_PCAC_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_PCAC_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_PCAC_BOARD_NAND_CONTROL
+};
+
+/********************************/
+/* ARMADA-XP DB PCAC REV2 BOARD */
+/********************************/
+#define DB_78X60_PCAC_REV2_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_PCAC_REV2_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_PCAC_REV2_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60pcacrev2InfoBoardDebugLedIf[] = {53, 54, 55, 56};
+
+MV_BOARD_MAC_INFO db78X60pcacrev2InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0}		/* Dummy */
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60pcacrev2InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod	= MV_BOARD_AUTO,
+		.boardOtherMod	= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO db78X60pcacrev2InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    23} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60pcacrev2InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60pcacrev2InfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_PCAC_REV2_MPP0_7,
+		DB_78X60_PCAC_REV2_MPP8_15,
+		DB_78X60_PCAC_REV2_MPP16_23,
+		DB_78X60_PCAC_REV2_MPP24_31,
+		DB_78X60_PCAC_REV2_MPP32_39,
+		DB_78X60_PCAC_REV2_MPP40_47,
+		DB_78X60_PCAC_REV2_MPP48_55,
+		DB_78X60_PCAC_REV2_MPP56_63,
+		DB_78X60_PCAC_REV2_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG db78X60pcacrev2InfoBoardSerdesConfigValue[] = {
+	 {MV_TRUE, 0x23321111, 0x00000000, PEX_BUS_MODE_X4, PEX_BUS_DISABLED, PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000010} /* Default */
+};
+
+MV_BOARD_INFO db78X60pcacrev2Info = {
+	.boardName			= "DB-78460-PCAC-REV2",
+	.numBoardMppTypeValue		= ARRSZ(db78X60pcacrev2InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60pcacrev2InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60pcacrev2InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60pcacrev2InfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(db78X60pcacrev2InfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= db78X60pcacrev2InfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60pcacrev2InfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60pcacrev2InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(db78X60pcacrev2InfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60pcacrev2InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60pcacrev2InfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60pcacrev2InfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60pcacrev2InfoBoardDebugLedIf),
+	.pLedGppPin			= db78X60pcacrev2InfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_PCAC_REV2_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_PCAC_REV2_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_PCAC_REV2_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_PCAC_REV2_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_PCAC_REV2_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_PCAC_REV2_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_PCAC_REV2_GPP_POL_HIGH,
+
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_PCAC_REV2_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_PCAC_REV2_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_PCAC_REV2_BOARD_NAND_CONTROL
+};
+
+/************************/
+/* ARMADA-XP FPGA BOARD */
+/************************/
+#define FPGA_88F78XX0_BOARD_NAND_READ_PARAMS	0x000C0282
+#define FPGA_88F78XX0_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define FPGA_88F78XX0_BOARD_NAND_CONTROL	0x01c00543
+
+MV_BOARD_TWSI_INFO	fpga88f78XX0InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4F, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO fpga88f78XX0InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x2,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x3,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x4,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO fpga88f78XX0InfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO fpga88f78XX0InfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    24} /* from MPP map */
+};
+
+MV_DEV_CS_INFO fpga88f78XX0InfoBoardDeCsInfo[] = {
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO fpga88f78XX0InfoBoardMppConfigValue[] = {
+	{ {
+	FPGA_88F78XX0_MPP0_7,
+	FPGA_88F78XX0_MPP8_15,
+	FPGA_88F78XX0_MPP16_23,
+	FPGA_88F78XX0_MPP24_31,
+	FPGA_88F78XX0_MPP32_39,
+	FPGA_88F78XX0_MPP40_47,
+	FPGA_88F78XX0_MPP48_55,
+	FPGA_88F78XX0_MPP56_63,
+	FPGA_88F78XX0_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG fpga88f78XX0InfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x00000000, 0x00000000, PEX_BUS_DISABLED, PEX_BUS_DISABLED, PEX_BUS_DISABLED, PEX_BUS_DISABLED, 0x00000000} /* No PEX in FPGA */
+};
+
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm880[]	= { {1}, {2} };
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm792[]	= { {1}, {2}, {3}, {4}, {6}, {7} };
+MV_BOARD_TDM_INFO	fpga88f78XX0Tdm3215[]	= { {1} };
+
+MV_BOARD_INFO fpga88f78XX0Info = {
+	.boardName			= "FPGA-88F78XX0",
+	.numBoardMppTypeValue		= ARRSZ(fpga88f78XX0InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= fpga88f78XX0InfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(fpga88f78XX0InfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= fpga88f78XX0InfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(fpga88f78XX0InfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= fpga88f78XX0InfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(fpga88f78XX0InfoBoardDeCsInfo),
+	.pDevCsInfo			= fpga88f78XX0InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(fpga88f78XX0InfoBoardTwsiDev),
+	.pBoardTwsiDev			= fpga88f78XX0InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(fpga88f78XX0InfoBoardMacInfo),
+	.pBoardMacInfo			= fpga88f78XX0InfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(fpga88f78XX0InfoBoardGppInfo),
+	.pBoardGppInfo			= fpga88f78XX0InfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= FPGA_88F78XX0_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= FPGA_88F78XX0_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= FPGA_88F78XX0_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= FPGA_88F78XX0_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= FPGA_88F78XX0_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= FPGA_88F78XX0_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= FPGA_88F78XX0_GPP_POL_LOW,
+	.gppPolarityValMid		= FPGA_88F78XX0_GPP_POL_MID,
+	.gppPolarityValHigh		= FPGA_88F78XX0_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= { 2, 6, 1 },
+	.pBoardTdmInt2CsInfo		= { fpga88f78XX0Tdm880,
+					    fpga88f78XX0Tdm792,
+					    fpga88f78XX0Tdm3215
+					  },
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= FPGA_88F78XX0_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= FPGA_88F78XX0_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= FPGA_88F78XX0_BOARD_NAND_CONTROL
+};
+
+/***************************/
+/* ARMADA-XP AMC BOARD     */
+/***************************/
+#define DB_78X60_AMC_BOARD_NAND_READ_PARAMS		0x000C0282
+#define DB_78X60_AMC_BOARD_NAND_WRITE_PARAMS		0x00010305
+/*NAND care support for small page chips*/
+#define DB_78X60_AMC_BOARD_NAND_CONTROL			0x01c00543
+
+MV_U8	db78X60amcInfoBoardDebugLedIf[] = {53, 54, 55, 56}; /* 7 segment MPPs*/
+
+MV_BOARD_TWSI_INFO	db78X60amcInfoBoardTwsiDev[] = {
+	/* No TWSI devices on board*/
+};
+
+MV_BOARD_MAC_INFO db78X60amcInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x1,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0xF,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0xE,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x0,0x0}
+};
+
+
+MV_BOARD_MODULE_TYPE_INFO db78X60amcInfoBoardModTypeInfo[] = {
+	/* No Modules */
+};
+
+MV_BOARD_GPP_INFO db78X60amcInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_USB_VBUS,    46} /* from MPP map */
+};
+
+MV_DEV_CS_INFO db78X60amcInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8}, /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db78X60amcInfoBoardMppConfigValue[] = {
+	{ {
+		DB_78X60_AMC_MPP0_7,
+		DB_78X60_AMC_MPP8_15,
+		DB_78X60_AMC_MPP16_23,
+		DB_78X60_AMC_MPP24_31,
+		DB_78X60_AMC_MPP32_39,
+		DB_78X60_AMC_MPP40_47,
+		DB_78X60_AMC_MPP48_55,
+		DB_78X60_AMC_MPP56_63,
+		DB_78X60_AMC_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG db78X60amcInfoBoardSerdesConfigValue[] = {
+	 {MV_TRUE, 0x33111111, 0x11111111, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030} /* Default */
+};
+
+
+MV_BOARD_TDM_INFO	db78X60amcTdm880[]	= {};
+MV_BOARD_TDM_INFO	db78X60amcTdm792[]	= {};
+MV_BOARD_TDM_INFO	db78X60amcTdm3215[]	= {};
+
+MV_BOARD_INFO db78X60amcInfo = {
+	.boardName			= "DB-78460-AMC",
+	.numBoardMppTypeValue		= ARRSZ(db78X60amcInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db78X60amcInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(db78X60amcInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= db78X60amcInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(db78X60amcInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= db78X60amcInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db78X60amcInfoBoardDeCsInfo),
+	.pDevCsInfo			= db78X60amcInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db78X60amcInfoBoardTwsiDev),
+	.pBoardTwsiDev			= db78X60amcInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db78X60amcInfoBoardMacInfo),
+	.pBoardMacInfo			= db78X60amcInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(db78X60amcInfoBoardGppInfo),
+	.pBoardGppInfo			= db78X60amcInfoBoardGppInfo,
+	.activeLedsNumber		= ARRSZ(db78X60amcInfoBoardDebugLedIf),
+	.pLedGppPin			= db78X60amcInfoBoardDebugLedIf,
+	.ledsPolarity			= 0,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_78X60_AMC_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_78X60_AMC_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_78X60_AMC_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_78X60_AMC_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_78X60_AMC_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_78X60_AMC_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_78X60_AMC_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_78X60_AMC_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_78X60_AMC_GPP_POL_HIGH,
+
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	 ** can be connected to board.
+	 ** When modules are scanned, then we select the index of the relevant
+	 ** slic's information array.
+	 ** For RD and Customers boards we only need to initialize a single
+	 ** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo		= {},
+	.pBoardTdmInt2CsInfo		= {},
+	.boardTdmInfoIndex		= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_78X60_AMC_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_78X60_AMC_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_78X60_AMC_BOARD_NAND_CONTROL
+};
+
+//////////////////////////////////////////////////////////////////////////////////
+
+/***************************/
+/* ARMADA-XP RD GP  BOARD */
+/***************************/
+#define RD_78460_GP_BOARD_NAND_READ_PARAMS		0x000C0282
+#define RD_78460_GP_BOARD_NAND_WRITE_PARAMS		0x00010305
+
+#define RD_78460_GP_BOARD_NAND_CONTROL			0x01c00543
+
+#define RD_78460_GP_BOARD_NOR_READ_PARAMS		0x403E07CF
+#define RD_78460_GP_BOARD_NOR_WRITE_PARAMS		0x000F0F0F
+
+
+MV_BOARD_TWSI_INFO   rd78460gpInfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT}
+};
+
+MV_BOARD_MAC_INFO rd78460gpInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+        /* speed will toggle to force link 1000 when SW module detected */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460gpInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+
+MV_BOARD_GPP_INFO rd78460gpInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460gpInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460gpInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_GP_MPP0_7,
+	RD_78460_GP_MPP8_15,
+	RD_78460_GP_MPP16_23,
+	RD_78460_GP_MPP24_31,
+	RD_78460_GP_MPP32_39,
+	RD_78460_GP_MPP40_47,
+	RD_78460_GP_MPP48_55,
+	RD_78460_GP_MPP56_63,
+	RD_78460_GP_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG rd78460gpInfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x00223001, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* Default */
+};
+
+MV_BOARD_INFO rd78460gpInfo = {
+	.boardName			= "RD-AXP-GP rev 1.0",
+	.numBoardMppTypeValue		= ARRSZ(rd78460gpInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460gpInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460gpInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460gpInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(rd78460gpInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= rd78460gpInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460gpInfoBoardDeCsInfo),
+	.pDevCsInfo				= rd78460gpInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(rd78460gpInfoBoardTwsiDev),
+	.pBoardTwsiDev			= rd78460gpInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(rd78460gpInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460gpInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460gpInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460gpInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_GP_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_GP_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_GP_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_GP_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_GP_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_GP_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_GP_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_GP_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_GP_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_GP_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_GP_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_GP_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_GP_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_GP_BOARD_NOR_WRITE_PARAMS
+};
+
+/***************************/
+/* ARMADA-XP CUSTOMER BOARD */
+/***************************/
+#define RD_78460_CUSTOMER_BOARD_NAND_READ_PARAMS	0x000C0282
+#define RD_78460_CUSTOMER_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define RD_78460_CUSTOMER_BOARD_NAND_CONTROL		0x01c00543
+
+#define RD_78460_CUSTOMER_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define RD_78460_CUSTOMER_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_MAC_INFO rd78460customerInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{BOARD_MAC_SPEED_AUTO, 0x10,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x11,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x12,0x0},
+	{BOARD_MAC_SPEED_AUTO, 0x13,0x0}
+};
+
+MV_BOARD_MODULE_TYPE_INFO rd78460customerInfoBoardModTypeInfo[] = {
+	{
+		.boardMppMod		= MV_BOARD_AUTO,
+		.boardOtherMod		= MV_BOARD_NONE
+	}
+};
+//////////////////////////////////////////////////////////////////////////////////
+
+MV_BOARD_GPP_INFO rd78460customerInfoBoardGppInfo[] = {
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{BOARD_GPP_RESET, 21}
+};
+
+MV_DEV_CS_INFO rd78460customerInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8} /* SPI DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO rd78460customerInfoBoardMppConfigValue[] = {
+	{ {
+	RD_78460_CUSTOMER_MPP0_7,
+	RD_78460_CUSTOMER_MPP8_15,
+	RD_78460_CUSTOMER_MPP16_23,
+	RD_78460_CUSTOMER_MPP24_31,
+	RD_78460_CUSTOMER_MPP32_39,
+	RD_78460_CUSTOMER_MPP40_47,
+	RD_78460_CUSTOMER_MPP48_55,
+	RD_78460_CUSTOMER_MPP56_63,
+	RD_78460_CUSTOMER_MPP64_67,
+	} }
+};
+
+MV_SERDES_CFG rd78460customerInfoBoardSerdesConfigValue[] = {
+	{MV_TRUE, 0x00223001, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* Default */
+	{MV_TRUE, 0x33320201, 0x11111111, PEX_BUS_MODE_X1, PEX_BUS_DISABLED,PEX_BUS_MODE_X4, PEX_BUS_MODE_X4, 0x00000030},	/* Switch module */
+};
+
+MV_BOARD_INFO rd78460customerInfo = {
+	.boardName			= "RD-AXP-CUSTOMER",
+	.numBoardMppTypeValue		= ARRSZ(rd78460customerInfoBoardModTypeInfo),
+	.pBoardModTypeValue		= rd78460customerInfoBoardModTypeInfo,
+	.numBoardMppConfigValue		= ARRSZ(rd78460customerInfoBoardMppConfigValue),
+	.pBoardMppConfigValue		= rd78460customerInfoBoardMppConfigValue,
+	.numBoardSerdesConfigValue	= ARRSZ(rd78460customerInfoBoardSerdesConfigValue),
+	.pBoardSerdesConfigValue	= rd78460customerInfoBoardSerdesConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(rd78460customerInfoBoardDeCsInfo),
+	.pDevCsInfo			= rd78460customerInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= 0,
+	.pBoardTwsiDev			= NULL,
+	.numBoardMacInfo		= ARRSZ(rd78460customerInfoBoardMacInfo),
+	.pBoardMacInfo			= rd78460customerInfoBoardMacInfo,
+	.numBoardGppInfo		= ARRSZ(rd78460customerInfoBoardGppInfo),
+	.pBoardGppInfo			= rd78460customerInfoBoardGppInfo,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= RD_78460_CUSTOMER_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_78460_CUSTOMER_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= RD_78460_CUSTOMER_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= RD_78460_CUSTOMER_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_78460_CUSTOMER_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= RD_78460_CUSTOMER_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= RD_78460_CUSTOMER_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_78460_CUSTOMER_GPP_POL_MID,
+	.gppPolarityValHigh		= RD_78460_CUSTOMER_GPP_POL_HIGH,
+
+	/* TDM configuration */
+	/* We hold a different configuration array for each possible slic that
+	** can be connected to board.
+	** When modules are scanned, then we select the index of the relevant
+	** slic's information array.
+	** For RD and Customers boards we only need to initialize a single
+	** entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	*/
+	.numBoardTdmInfo			= {},
+	.pBoardTdmInt2CsInfo			= {},
+	.boardTdmInfoIndex			= -1,
+
+	/* NAND init params */
+	.nandFlashReadParams		= RD_78460_CUSTOMER_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= RD_78460_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= RD_78460_CUSTOMER_BOARD_NAND_CONTROL,
+	/* NOR init params */
+	.norFlashReadParams		= RD_78460_CUSTOMER_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= RD_78460_CUSTOMER_BOARD_NOR_WRITE_PARAMS
+};
+//////////////////////////////////////////////////////////////////////////////////////
+
+MV_BOARD_INFO *boardInfoTbl[] = {
+	&db88f78XX0Info,
+	&rd78460Info,
+	&db78X60pcacInfo,
+	&fpga88f78XX0Info,
+	&db88f78XX0rev2Info,
+	&rd78460nasInfo,
+	&db78X60amcInfo,
+	&db78X60pcacrev2Info,
+	&rd78460ServerRev2Info,
+	&rd78460gpInfo,
+	&rd78460customerInfo
+};
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..4231351
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,575 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+/* For future use */
+#define BD_ID_DATA_START_OFFS			0x0
+#define BD_DETECT_SEQ_OFFS			0x0
+#define BD_SYS_NUM_OFFS				0x4
+#define BD_NAME_OFFS				0x8
+
+/* I2C bus addresses TODO - take from board design */
+#define MV_BOARD_DIMM0_I2C_ADDR			0x56
+#define MV_BOARD_DIMM0_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM1_I2C_ADDR			0x57
+#define MV_BOARD_DIMM1_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM_I2C_CHANNEL		0x0
+
+
+/* Board specific configuration */
+/* ============================ */
+
+/* boards ID numbers */
+#define BOARD_ID_BASE				0x0
+
+/* New board ID numbers */
+#define DB_88F78XX0_BP_ID			(BOARD_ID_BASE)
+#define RD_78460_SERVER_ID			(DB_88F78XX0_BP_ID + 1)
+#define DB_78X60_PCAC_ID			(RD_78460_SERVER_ID + 1)
+#define FPGA_88F78XX0_ID			(DB_78X60_PCAC_ID + 1)
+#define DB_88F78XX0_BP_REV2_ID		(FPGA_88F78XX0_ID + 1)
+#define RD_78460_NAS_ID				(DB_88F78XX0_BP_REV2_ID + 1)
+#define DB_78X60_AMC_ID				(RD_78460_NAS_ID + 1)
+#define DB_78X60_PCAC_REV2_ID		(DB_78X60_AMC_ID + 1)
+#define RD_78460_SERVER_REV2_ID		(DB_78X60_PCAC_REV2_ID + 1)
+#define RD_78460_GP_ID				(RD_78460_SERVER_REV2_ID + 1)
+#define RD_78460_CUSTOMER_ID		(RD_78460_GP_ID+ 1)
+#define MV_MAX_BOARD_ID				(RD_78460_CUSTOMER_ID + 1)
+#define INVALID_BAORD_ID			0xFFFFFFFF
+
+/******************/
+/* DB-88F78XX0-BP */
+/******************/
+#define DB_88F78XX0_MPP0_7			0x11111111
+#define DB_88F78XX0_MPP8_15			0x22221111
+#define DB_88F78XX0_MPP16_23			0x22222222
+/* TODO Kostap - change MPP29 (CPU0 Vdd) back to default value 5
+   when PM configuration changed to have it as active "high"
+   Otherwise setting it to default value will shut down CPU0 */
+#define DB_88F78XX0_MPP24_31			0x11040000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define DB_88F78XX0_MPP32_39			0x11111111
+#define DB_88F78XX0_MPP40_47			0x04221130 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define DB_88F78XX0_MPP48_55			0x11111110
+#define DB_88F78XX0_MPP56_63			0x11111101 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define DB_88F78XX0_MPP64_67			0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define DB_88F78XX0_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_88F78XX0_GPP_OUT_ENA_MID		(~(BIT16 | BIT15))
+#define DB_88F78XX0_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_88F78XX0_GPP_OUT_VAL_LOW		0x0
+#define DB_88F78XX0_GPP_OUT_VAL_MID		BIT15
+#define DB_88F78XX0_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_88F78XX0_GPP_POL_LOW			0x0
+#define DB_88F78XX0_GPP_POL_MID			0x0
+#define DB_88F78XX0_GPP_POL_HIGH		0x0
+
+/**********************/
+/* DB-88F78XX0-BP Rev2*/
+/**********************/
+#define DB_88F78XX0_REV2_MPP0_7			0x11111111
+#define DB_88F78XX0_REV2_MPP8_15		0x22221111
+#define DB_88F78XX0_REV2_MPP16_23		0x22222222
+/* TODO Kostap - change MPP29 (CPU0 Vdd) back to default value 5
+   when PM configuration changed to have it as active "high"
+   Otherwise setting it to default value will shut down CPU0 */
+#define DB_88F78XX0_REV2_MPP24_31		0x11040000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define DB_88F78XX0_REV2_MPP32_39		0x11111111
+#define DB_88F78XX0_REV2_MPP40_47		0x04221130 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define DB_88F78XX0_REV2_MPP48_55		0x11111113
+#define DB_88F78XX0_REV2_MPP56_63		0x11111101 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define DB_88F78XX0_REV2_MPP64_67		0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_LOW	(~(BIT26 | BIT27))
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_MID	(~(BIT16 | BIT15))
+#define DB_88F78XX0_REV2_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_LOW	0x0
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_MID	BIT15
+#define DB_88F78XX0_REV2_GPP_OUT_VAL_HIGH	0x0
+
+#define DB_88F78XX0_REV2_GPP_POL_LOW		0x0
+#define DB_88F78XX0_REV2_GPP_POL_MID		0x0
+#define DB_88F78XX0_REV2_GPP_POL_HIGH		0x0
+
+/**********************/
+/* DB-AXP-NAS         */
+/**********************/
+
+#define RD_78460_NAS_MPP0_7             0x00000000
+#define RD_78460_NAS_MPP8_15		0x00000000
+#define RD_78460_NAS_MPP16_23		0x33000000
+#define RD_78460_NAS_MPP24_31		0x11000000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define RD_78460_NAS_MPP32_39		0x11111111
+#define RD_78460_NAS_MPP40_47		0x00221100 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define RD_78460_NAS_MPP48_55		0x00000003
+#define RD_78460_NAS_MPP56_63		0x00000000 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define RD_78460_NAS_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_NAS_GPP_OUT_ENA_LOW	(~(BIT21))
+#define RD_78460_NAS_GPP_OUT_ENA_MID	(~(0x0))
+#define RD_78460_NAS_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_NAS_GPP_OUT_VAL_LOW	(BIT21)
+#define RD_78460_NAS_GPP_OUT_VAL_MID	0x0
+#define RD_78460_NAS_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_NAS_GPP_POL_LOW		0x0
+#define RD_78460_NAS_GPP_POL_MID		0x0
+#define RD_78460_NAS_GPP_POL_HIGH		0x0
+
+
+/*******************/
+/* RD-78460-SERVER */
+/*******************/
+#define RD_78460_MPP0_7				0x00000000
+#define RD_78460_MPP8_15			0x00000000
+#define RD_78460_MPP16_23			0x00000000
+#define RD_78460_MPP24_31			0x00000000
+#define RD_78460_MPP32_39			0x11110000
+#define RD_78460_MPP40_47			0x00000000
+#define RD_78460_MPP48_55			0x00000000
+#define RD_78460_MPP56_63			0x00000000
+#define RD_78460_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16		CPU ID		IN
+17		CPU ID		IN
+18		CPU ID		IN
+19		CPU ID		IN
+23		USER LED	OUT
+25		Touch SG/ MII Int#	IN
+28		RESET GPIO FOR OTHER DEVICES
+29		RESET GPIO FOR OTHER DEVICES
+30		RESET GPIO FOR OTHER DEVICES
+31		RESET GPIO FOR OTHER DEVICES
+32		RESET GPIO FOR OTHER DEVICES
+33		RESET GPIO FOR OTHER DEVICES
+
+40		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+41		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+42		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+43		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+44		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+
+*/
+
+#define RD_78460_GPP_OUT_ENA_LOW		(~(BIT23 | BIT28 | BIT29 | BIT30 | BIT31))
+#define RD_78460_GPP_OUT_ENA_MID		(~(BIT0 | BIT1 | BIT2 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12))
+#define RD_78460_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define RD_78460_GPP_OUT_VAL_LOW		(BIT28 | BIT29 | BIT30 | BIT31)
+#define RD_78460_GPP_OUT_VAL_MID		(BIT0)
+#define RD_78460_GPP_OUT_VAL_HIGH		0x0
+
+#define RD_78460_GPP_POL_LOW			0x0
+/* (BIT16 | BIT17 | BIT18 | BIT19) */
+#define RD_78460_GPP_POL_MID			0x0
+#define RD_78460_GPP_POL_HIGH			0x0
+
+/************************/
+/* RD-78460-SERVER-REV2 */
+/************************/
+#define RD_78460_SERVER_REV2_MPP0_7				0x00000000
+#define RD_78460_SERVER_REV2_MPP8_15			0x00000000
+#define RD_78460_SERVER_REV2_MPP16_23			0x00000000
+#define RD_78460_SERVER_REV2_MPP24_31			0x00000000
+#define RD_78460_SERVER_REV2_MPP32_39			0x11110000
+#define RD_78460_SERVER_REV2_MPP40_47			0x00000000
+#define RD_78460_SERVER_REV2_MPP48_55			0x00000000
+#define RD_78460_SERVER_REV2_MPP56_63			0x00000000
+#define RD_78460_SERVER_REV2_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16		CPU ID		IN
+17		CPU ID		IN
+18		CPU ID		IN
+19		CPU ID		IN
+23		USER LED	OUT
+25		Touch SG/ MII Int#	IN
+28		RESET GPIO FOR OTHER DEVICES
+29		RESET GPIO FOR OTHER DEVICES
+30		RESET GPIO FOR OTHER DEVICES
+31		RESET GPIO FOR OTHER DEVICES
+32		RESET GPIO FOR OTHER DEVICES
+33		RESET GPIO FOR OTHER DEVICES
+
+40		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+41		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+42		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+43		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+44		GPIOs TO SLED CONNECTOR(CPU0 ONLY)
+
+*/
+
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_LOW		(~(BIT23 | BIT28 | BIT29 | BIT30 | BIT31))
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_MID		(~(BIT0 | BIT1 | BIT2 | BIT8 | BIT9 | BIT10 | BIT11 | BIT12))
+#define RD_78460_SERVER_REV2_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_LOW		(BIT28 | BIT29 | BIT30 | BIT31)
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_MID		(BIT0)
+#define RD_78460_SERVER_REV2_GPP_OUT_VAL_HIGH		0x0
+
+#define RD_78460_SERVER_REV2_GPP_POL_LOW			0x0
+/* (BIT16 | BIT17 | BIT18 | BIT19) */
+#define RD_78460_SERVER_REV2_GPP_POL_MID			0x0
+#define RD_78460_SERVER_REV2_GPP_POL_HIGH			0x0
+
+
+/********************/
+/* DB-88F78XX0-PCAC */
+/********************/
+
+#define DB_78X60_PCAC_MPP0_7			0x00000000
+#define DB_78X60_PCAC_MPP8_15			0x00000000
+#define DB_78X60_PCAC_MPP16_23			0x00000000
+#define DB_78X60_PCAC_MPP24_31			0x11000000
+#define DB_78X60_PCAC_MPP32_39			0x11111111
+#define DB_78X60_PCAC_MPP40_47			0x00221105
+#define DB_78X60_PCAC_MPP48_55			0x00000000
+#define DB_78X60_PCAC_MPP56_63			0x00000000
+#define DB_78X60_PCAC_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+16	Jumper 1 			IN
+17	Jumper 2 			IN
+18	Jumper 3 			IN
+19	Jumper 4 			IN
+20	Jumper 5 			IN
+21	GP				OUT
+23	UsbDevice_Vbus			IN
+53	7seg bit0			OUT
+54	7seg bit1			OUT
+55	7seg bit2			OUT
+56	7seg bit3			OUT
+*/
+
+#define DB_78X60_PCAC_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_78X60_PCAC_GPP_OUT_ENA_MID		(~(BIT16 | BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_PCAC_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_PCAC_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_PCAC_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_PCAC_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_PCAC_GPP_POL_LOW		0x0
+#define DB_78X60_PCAC_GPP_POL_MID		0x0
+#define DB_78X60_PCAC_GPP_POL_HIGH		0x0
+
+/*************************/
+/* DB-88F78XX0-PCAC-REV2 */
+/*************************/
+
+#define DB_78X60_PCAC_REV2_MPP0_7			0x00000000
+#define DB_78X60_PCAC_REV2_MPP8_15			0x00000000
+#define DB_78X60_PCAC_REV2_MPP16_23			0x00000000
+#define DB_78X60_PCAC_REV2_MPP24_31			0x11000000
+#define DB_78X60_PCAC_REV2_MPP32_39			0x11111111
+#define DB_78X60_PCAC_REV2_MPP40_47			0x00221105
+#define DB_78X60_PCAC_REV2_MPP48_55			0x00000000
+#define DB_78X60_PCAC_REV2_MPP56_63			0x00000000
+#define DB_78X60_PCAC_REV2_MPP64_67			0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+16	Jumper 1 			IN
+17	Jumper 2 			IN
+18	Jumper 3 			IN
+19	Jumper 4 			IN
+20	Jumper 5 			IN
+21	GP				OUT
+23	UsbDevice_Vbus			IN
+53	7seg bit0			OUT
+54	7seg bit1			OUT
+55	7seg bit2			OUT
+56	7seg bit3			OUT
+*/
+
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_LOW		(~(BIT26 | BIT27))
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_MID		(~(BIT16 | BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_PCAC_REV2_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_PCAC_REV2_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_PCAC_REV2_GPP_POL_LOW		0x0
+#define DB_78X60_PCAC_REV2_GPP_POL_MID		0x0
+#define DB_78X60_PCAC_REV2_GPP_POL_HIGH		0x0
+
+/********************/
+/* FPGA-88F78XX0-BP */
+/********************/
+#define FPGA_88F78XX0_MPP0_7			0x11111111
+#define FPGA_88F78XX0_MPP8_15			0x22221111
+#define FPGA_88F78XX0_MPP16_23			0x22222222
+#define FPGA_88F78XX0_MPP24_31			0x11500000
+#define FPGA_88F78XX0_MPP32_39			0x11111111
+#define FPGA_88F78XX0_MPP40_47			0x44221133
+#define FPGA_88F78XX0_MPP48_55			0x11111111
+#define FPGA_88F78XX0_MPP56_63			0x11111111
+#define FPGA_88F78XX0_MPP64_67			0x00002111
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+24	UsbDevice_Vbus		IN
+25	Touch SG/ MII Int#	IN
+26	7seg bit0		OUT
+27	7seg bit1		OUT
+48	7seg bit2		OUT
+*/
+#define FPGA_88F78XX0_GPP_OUT_ENA_LOW		(BIT26 | BIT27)
+#define FPGA_88F78XX0_GPP_OUT_ENA_MID		(BIT16)
+#define FPGA_88F78XX0_GPP_OUT_ENA_HIGH		0x0
+
+#define FPGA_88F78XX0_GPP_OUT_VAL_LOW		0x0
+#define FPGA_88F78XX0_GPP_OUT_VAL_MID		0x0
+#define FPGA_88F78XX0_GPP_OUT_VAL_HIGH		0x0
+
+#define FPGA_88F78XX0_GPP_POL_LOW		0x0
+#define FPGA_88F78XX0_GPP_POL_MID		0x0
+#define FPGA_88F78XX0_GPP_POL_HIGH		0x0
+
+
+
+/********************/
+/* DB-78460-AMC     */
+/********************/
+
+#define DB_78X60_AMC_MPP0_7			0x11111111
+#define DB_78X60_AMC_MPP8_15			0x00001111
+#define DB_78X60_AMC_MPP16_23			0x00000000
+#define DB_78X60_AMC_MPP24_31			0x00000000
+#define DB_78X60_AMC_MPP32_39			0x11110000
+#define DB_78X60_AMC_MPP40_47			0x00004000
+#define DB_78X60_AMC_MPP48_55			0x00001113
+#define DB_78X60_AMC_MPP56_63			0x11111110
+#define DB_78X60_AMC_MPP64_67			0x00000111
+
+/* GPPs
+MPP#	NAME		IN/OUT
+----------------------------------------------
+16	MB_INT#		IN
+17	Phy1_INT#	IN
+18	Phy2_INT#	IN
+19	Brd_Led_0	IN (for next board)
+21	Brd_Led_1	OUT
+23	Brd_Led_2	OUT
+29	Brd_Led_3	OUT
+30	Brd_Led_4	OUT
+34	Dbg_JP0		IN
+35	Dbg_JP1		IN
+40	Dbg_JP2		IN
+41	Dbg_JP3		IN
+42	Dbg_JP4		IN
+53	7 Segment 0	OUT
+54	7 Segment 1	OUT
+55	7 Segment 2	OUT
+56	7 Segment 3	OUT
+*/
+
+#define DB_78X60_AMC_GPP_OUT_ENA_LOW		(~(BIT21 | BIT23 | BIT29 | BIT30))
+#define DB_78X60_AMC_GPP_OUT_ENA_MID		(~(BIT21 | BIT22 | BIT23 | BIT24))
+#define DB_78X60_AMC_GPP_OUT_ENA_HIGH		(~(0x0))
+
+#define DB_78X60_AMC_GPP_OUT_VAL_LOW		0x0
+#define DB_78X60_AMC_GPP_OUT_VAL_MID		0x0
+#define DB_78X60_AMC_GPP_OUT_VAL_HIGH		0x0
+
+#define DB_78X60_AMC_GPP_POL_LOW		0x0
+#define DB_78X60_AMC_GPP_POL_MID		0x0
+#define DB_78X60_AMC_GPP_POL_HIGH		0x0
+
+
+
+
+/*********************/
+/* DB-AXP-GP         */
+/*********************/
+
+#define RD_78460_GP_MPP0_7			0x00000000
+#define RD_78460_GP_MPP8_15			0x00000000
+#define RD_78460_GP_MPP16_23		0x33000000
+#define RD_78460_GP_MPP24_31		0x11000000
+#define RD_78460_GP_MPP32_39		0x11111111
+#define RD_78460_GP_MPP40_47		0x00221100
+#define RD_78460_GP_MPP48_55		0x00000003
+#define RD_78460_GP_MPP56_63		0x00000000
+#define RD_78460_GP_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_GP_GPP_OUT_ENA_LOW	(~(BIT21 | BIT20))
+#define RD_78460_GP_GPP_OUT_ENA_MID	(~(0x0))
+#define RD_78460_GP_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_GP_GPP_OUT_VAL_LOW	(BIT21 | BIT20)
+#define RD_78460_GP_GPP_OUT_VAL_MID	0x0
+#define RD_78460_GP_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_GP_GPP_POL_LOW		0x0
+#define RD_78460_GP_GPP_POL_MID		0x0
+#define RD_78460_GP_GPP_POL_HIGH	0x0
+
+
+
+
+/**********************/
+/* DB-AXP-CUSTOMER         */
+/**********************/
+
+#define RD_78460_CUSTOMER_MPP0_7             0x00000000
+#define RD_78460_CUSTOMER_MPP8_15		0x00000000
+#define RD_78460_CUSTOMER_MPP16_23		0x33000000
+#define RD_78460_CUSTOMER_MPP24_31		0x11000000 /* bits[27:24] = 0x5 to enable PMm for CPU0 */
+#define RD_78460_CUSTOMER_MPP32_39		0x11111111
+#define RD_78460_CUSTOMER_MPP40_47		0x00221100 /* bits[3:0] = 0x3 to enable PM for CPU1 */
+#define RD_78460_CUSTOMER_MPP48_55		0x00000003
+#define RD_78460_CUSTOMER_MPP56_63		0x00000000 /* bits[7:4] = 0x1 to enable PM for CPU2/3 */
+#define RD_78460_CUSTOMER_MPP64_67		0x00000000
+
+/* GPPs
+MPP#	NAME			IN/OUT
+----------------------------------------------
+21	SW_Reset_		OUT
+25      Phy_Int#                IN
+28      SDI_WP                  IN
+29      SDI_Status              IN
+54-61   On GPP Connector        ?
+62      Switch Interrupt        IN
+63-65   Reserved from SW Board  ?
+66      SW_BRD connected        IN
+
+*/
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_LOW	(~(BIT21))
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_MID	(~(0x0))
+#define RD_78460_CUSTOMER_GPP_OUT_ENA_HIGH	(~(0x0))
+
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_LOW	(BIT21)
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_MID	0x0
+#define RD_78460_CUSTOMER_GPP_OUT_VAL_HIGH	0x0
+
+#define RD_78460_CUSTOMER_GPP_POL_LOW		0x0
+#define RD_78460_CUSTOMER_GPP_POL_MID		0x0
+#define RD_78460_CUSTOMER_GPP_POL_HIGH		0x0
+
+
+
+#endif /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
new file mode 100644
index 0000000..699062c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.c
@@ -0,0 +1,323 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals */
+
+/*******************************************************************************
+* mvCpuPclkGet - Get the CPU pClk (pipe clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU core clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in MHertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 cpuClk[] = MV_CPU_CLK_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_CPU_CLK_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	return cpuClk[idx] * 1000000;
+}
+
+/*******************************************************************************
+* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU L2 clock.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuL2ClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz, l2FreqMhz;
+	MV_CPU_ARM_CLK_RATIO clockRatioTbl[] = MV_DDR_L2_CLK_RATIO_TBL;
+
+	if (mvBoardIdGet() == FPGA_88F78XX0_ID)
+		return MV_FPGA_CLK; /* FPGA is limited to 25Mhz */
+
+	idx = MSAR_DDR_L2_CLK_RATIO_IDX(MV_REG_READ(MPP_SAMPLE_AT_RESET(0)), MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+
+	if (clockRatioTbl[idx].vco2cpu != 0) {
+		freqMhz = mvCpuPclkGet() / 1000000;	/* CPU freq */
+		freqMhz *= clockRatioTbl[idx].vco2cpu;	/* VCO freq */
+		l2FreqMhz = freqMhz / clockRatioTbl[idx].vco2l2c;
+		/* round up to integer MHz */
+		if (((freqMhz % clockRatioTbl[idx].vco2l2c) * 10 / clockRatioTbl[idx].vco2l2c) >= 5)
+			l2FreqMhz++;
+
+		return l2FreqMhz * 1000000;
+	} else
+		return (MV_U32)-1;
+}
+
+/*******************************************************************************
+* mvCpuNameGet - Get CPU name
+*
+* DESCRIPTION:
+*       This function returns a string describing the CPU model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*       None.
+*******************************************************************************/
+MV_VOID mvCpuNameGet(char *pNameBuff)
+{
+	MV_U32 cpuModel;
+	MV_U32 archType;
+
+	cpuModel = mvOsCpuPartGet();
+	archType = mvOsCpuThumbEEGet();
+	/* The CPU module is indicated in the Processor Version Register (PVR) */
+	switch (cpuModel & 0xfff) {
+	case CPU_PART_ARM_V6UP:
+	case CPU_PART_ARM_V7UP:
+	case CPU_PART_MRVLPJ4B_UP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_MRVLPJ4B_MP:
+	case CPU_PART_ARM_V6MP:
+			if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v6", mvOsCpuRevGet());
+		break;
+	default:
+		mvOsSPrintf(pNameBuff, "??? (0x%04x) (Rev %d)", cpuModel, mvOsCpuRevGet());
+		break;
+	}			/* switch  */
+
+	return;
+}
+
+#define MV_PROC_STR_SIZE 50
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_ECC_MASK) == CL2ACR_ECC_EN)
+		mvOsSPrintf(buf, "L2 ECC Enabled");
+	else
+		mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2ParityMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PARITY_MASK) == CL2ACR_PARITY_EN)
+		mvOsSPrintf(buf, "L2 Parity Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Parity Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	if (regVal & CL2CR_L2_EN_MASK)
+		mvOsSPrintf(buf, "L2 Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PFU_MASK) == CL2ACR_PFU_DIS)
+		mvOsSPrintf(buf, "L2 Prefetch Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_FORCE_WA_MASK) == CL2ACR_FORCE_NO_WA)
+		mvOsSPrintf(buf, "L2 Write Allocate Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Write Allocate Enabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = 0;
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register */
+	if (regVal & BIT29)
+		mvOsSPrintf(buf, "CPU Streaming Enabled");
+	else
+		mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+	MV_U32 regVal = 0;
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register0 */
+	mvOsPrintf("Extra Features Reg[0] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (regVal));	/* Read Marvell extra features register1 */
+	mvOsPrintf("Extra Features Reg[1] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal));	/* Read Control register */
+	mvOsPrintf("Control Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal));	/* Read Main ID register */
+	mvOsPrintf("Main ID Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal));	/* Read Cache Type register */
+	mvOsPrintf("Cache Type Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	mvOsPrintf("L2 Control Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	mvOsPrintf("L2 Auxilary Control Reg = 0x%x\n", regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+	MV_U32 count = 0;
+
+	MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+	MV_8 L2_En_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+	MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+	MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Parity_str[MV_PROC_STR_SIZE];
+
+	mvCpuIfGetL2Mode(L2_En_str);
+	mvCpuIfGetL2EccMode(L2_ECC_str);
+	mvCpuIfGetL2ParityMode(L2_Parity_str);
+	mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+	mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+	mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+	mvCpuIfPrintCpuRegs();
+
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Parity_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+	return count;
+}
+
+/*******************************************************************************
+* whoAmI - Get the CPU ID
+*
+* DESCRIPTION:
+*       This function returns CPU ID in multiprocessor system
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       none.
+*
+* RETURN:
+*       CPU ID.
+*******************************************************************************/
+unsigned int whoAmI(void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPUID reg\n" : "=r"(value) : : "memory");
+	return (value & 0x7);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
new file mode 100644
index 0000000..c4e38d6
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/cpu/mvCpu.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#ifndef MV_ASMLANGUAGE
+#include "mvOs.h"
+#endif
+
+#define MASTER_CPU 0
+/* defines */
+#define CPU_PART_MRVL131                0x131
+#define CPU_PART_ARM926                 0x926
+#define CPU_PART_ARM946                 0x946
+#define CPU_PART_MRVL_A9                0xC09
+#define CPU_PART_MRVL571                0x571
+#define CPU_PART_MRVL521                0x521
+
+#define CPU_PART_ARM_V6UP               0xb76
+#define CPU_PART_ARM_V7UP               0xc08
+#define CPU_PART_ARM_V6MP               0xb02
+
+#define CPU_PART_MRVLPJ4B_UP               0x581
+#define CPU_PART_MRVLPJ4B_MP               0x584
+
+#define MV_CPU_ARM_CLK_ELM_SIZE	    12
+#define MV_CPU_ARM_CLK_RATIO_OFF    8
+#define MV_CPU_ARM_CLK_DDR_OFF	    4
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClkRatio {
+	MV_U32	vco2cpu;	/* VCO:PCLK0(CPU) clock ratio */
+	MV_U32	vco2l2c;	/* VCO:NB(L2 cache) clock ratio */
+	MV_U32	vco2hcl;	/* VCO:HCLK(DDR controller) clock ratio */
+	MV_U32	vco2ddr;	/* VCO:DDR(DDR memory) clock ratio */
+
+} MV_CPU_ARM_CLK_RATIO;
+
+MV_U32  mvCpuPclkGet(MV_VOID);
+MV_VOID mvCpuNameGet(char *pNameBuff);
+MV_U32  mvCpuL2ClkGet(MV_VOID);
+MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+MV_U32  whoAmI(MV_VOID);
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
new file mode 100755
index 0000000..e64ced1
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -0,0 +1,373 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvCtrlEnvAddrDec.h - Marvell controller address decode library
+*
+* DESCRIPTION:
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "sys/mvCpuIf.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* Default Attributes array */
+MV_TARGET_ATTRIB mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
+extern MV_TARGET sampleAtResetTargetArray[];
+
+/*******************************************************************************
+* mvCtrlAttribGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	targetAttrib->attrib = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib;
+	targetAttrib->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib  = targetAttrib->attrib;
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId= targetAttrib->targetId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlGetAttrib -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == targetAttrib->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == targetAttrib->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlTargetByWinInfoGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == unitWinInfo->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == unitWinInfo->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlAddrWinMapBuild
+*
+* DESCRIPTION:
+*	Build the windows address decoding table, to be used for initializing
+*	the unit's address decoding windows.
+*
+* INPUT:
+*	pAddrWinMap: An array to hold the address decoding windows parameters.
+*	len: Number of entries in pAddrWinMap.
+*
+* OUTPUT:
+*	pAddrWinMap: Address window information.
+*
+* RETURN:
+*	MV_BAD_PARAM: input array is smaller than needed to store all window
+*	addresses.
+*	MV_ERROR: Otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i, j;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+	MV_U64 startAddr, endAddr;
+	MV_UNIT_WIN_INFO ioDdrWin[4];
+	MV_U32 base;
+	MV_U64 size;
+
+	/* Check size of CPU address win table */
+	if (len <= MAX_TARGETS) {
+		mvOsPrintf("mvCtrlAddrWinMapBuild() - Table size too small.\n");
+		return MV_BAD_PARAM;
+	}
+
+	/* Prepare an array of DRAM info */
+	base = 0x0;
+	j = 0;
+	for (i = SDRAM_CS0; i <= SDRAM_CS3; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK) {
+			if (status == MV_NO_SUCH) {
+				ioDdrWin[i].enable = MV_FALSE;
+				continue;
+			} else {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCpuIfTargetWinGet() failed.\n");
+				return MV_ERROR;
+			}
+		}
+
+		/* As all IO address decode windows support only 32-bit
+		** addresses, limit the DRAM base / size to 4GB max.
+		*/
+		startAddr = (MV_U64)((((MV_U64)cpuAddrDecWin.addrWin.baseHigh << 32ll)) +
+				(MV_U64)cpuAddrDecWin.addrWin.baseLow);
+		endAddr = (MV_U64)(startAddr + (MV_U64)cpuAddrDecWin.addrWin.size) - 1;
+		if (endAddr > 0xFFFFFFFFll) {
+			if (startAddr <= 0xFFFFFFFFll)
+				cpuAddrDecWin.addrWin.size = (0x100000000ll -
+						cpuAddrDecWin.addrWin.baseLow);
+			else
+				cpuAddrDecWin.enable = MV_FALSE;
+		}
+
+		if (cpuAddrDecWin.enable == MV_FALSE)
+			continue;
+
+		/* If the endAddr passes minBase, then we need to split
+		** this window to several windows up to minBase.
+		** For example: minBase=0xE0000000, and CS0=2, CS1=2G,
+		** Then we need to split the windwos as follows:
+		** Win0: CS-0, 2GB (Base 0x0)
+		** win1: CS-1, 1GB (Base 0x80000000)
+		** Win2: CS-1, 0.5GB (Base 0xC0000000)
+		*/
+		if (endAddr > MV_DRAM_IO_RESERVE_BASE)
+			/* Need to cut down this CS to IO reserve base
+			** address.
+			*/
+			size = MV_DRAM_IO_RESERVE_BASE -
+				cpuAddrDecWin.addrWin.baseLow;
+		else
+			size = cpuAddrDecWin.addrWin.size;
+
+		if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+			mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+					"mvCtrlAttribGet() failed.\n");
+			return MV_ERROR;
+		}
+		/* Now, spread the last CS into several windows, and make sure
+		** that each of has a power-of-2 size.
+		*/
+		while (size != 0) {
+			ioDdrWin[j].enable = MV_TRUE;
+			ioDdrWin[j].attrib = targetAttrib.attrib;
+			ioDdrWin[j].targetId = targetAttrib.targetId;
+			ioDdrWin[j].addrWin.baseHigh = 0;
+			if (MV_IS_POWER_OF_2(size))
+				ioDdrWin[j].addrWin.size = size;
+			else
+				ioDdrWin[j].addrWin.size = (MV_U64)(1ll << (MV_U64)mvLog2(size));
+			size -= ioDdrWin[j].addrWin.size;
+			ioDdrWin[j].addrWin.baseLow = base;
+			base += ioDdrWin[j].addrWin.size;
+			j++;
+		}
+	}
+	
+	for (; j < 4; j++)
+		ioDdrWin[j].enable = MV_FALSE;
+
+	/* Fill in the pAddrWinMap fields       */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (MV_TARGET_IS_DRAM(i)) {
+			pAddrWinMap[i].addrWin.baseLow = ioDdrWin[i].addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh = ioDdrWin[i].addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size = ioDdrWin[i].addrWin.size;
+			pAddrWinMap[i].enable = ioDdrWin[i].enable;
+			pAddrWinMap[i].attrib = ioDdrWin[i].attrib;
+			pAddrWinMap[i].targetId = ioDdrWin[i].targetId;
+		} else {
+			status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+			if (status != MV_OK) {
+				if (status == MV_NO_SUCH) {
+					pAddrWinMap[i].enable = MV_FALSE;
+					continue;
+				} else {
+					mvOsPrintf("mvCtrlAddrWinMapBuild()"
+					" - mvCpuIfTargetWinGet() failed.\n");
+					return MV_ERROR;
+				}
+			}
+
+			pAddrWinMap[i].addrWin.baseLow =
+				cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh =
+				cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size =
+				cpuAddrDecWin.addrWin.size;
+			pAddrWinMap[i].enable = cpuAddrDecWin.enable;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+						"mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinMap[i].attrib = targetAttrib.attrib;
+			pAddrWinMap[i].targetId = targetAttrib.targetId;
+		}
+	}
+	pAddrWinMap[i].addrWin.baseLow = TBL_TERM;
+	pAddrWinMap[i].addrWin.baseHigh = TBL_TERM;
+	pAddrWinMap[i].addrWin.size = TBL_TERM;
+	pAddrWinMap[i].enable = TBL_TERM;
+	pAddrWinMap[i].attrib = TBL_TERM;
+	pAddrWinMap[i].targetId = TBL_TERM;
+
+	return MV_OK;
+}
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK)
+			continue;
+
+		if ((physAddr >= cpuAddrDecWin.addrWin.baseLow) &&
+		    (physAddr < cpuAddrDecWin.addrWin.baseLow + cpuAddrDecWin.addrWin.size)) {
+			/* Found */
+			pAddrWinInfo->addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinInfo->addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinInfo->addrWin.size = cpuAddrDecWin.addrWin.size;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinInfo->attrib = targetAttrib.attrib;
+			pAddrWinInfo->targetId = targetAttrib.targetId;
+			return MV_OK;
+		}
+	}
+	/* not found */
+	return MV_NOT_FOUND;
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
new file mode 100644
index 0000000..dcecd06
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAddrDech
+#define __INCmvCtrlEnvAddrDech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+
+/* defines  */
+/* DUnit attributes */
+#define ATMWCR_WIN_DUNIT_CS0_OFFS		0
+#define ATMWCR_WIN_DUNIT_CS0_MASK		BIT0
+#define ATMWCR_WIN_DUNIT_CS0_REQ		(0 << ATMWCR_WIN_DUNIT_CS0_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS1_OFFS		1
+#define ATMWCR_WIN_DUNIT_CS1_MASK		BIT1
+#define ATMWCR_WIN_DUNIT_CS1_REQ 		(0 << ATMWCR_WIN_DUNIT_CS1_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS2_OFFS		2
+#define ATMWCR_WIN_DUNIT_CS2_MASK		BIT2
+#define ATMWCR_WIN_DUNIT_CS2_REQ 		(0 << ATMWCR_WIN_DUNIT_CS2_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS3_OFFS		3
+#define ATMWCR_WIN_DUNIT_CS3_MASK		BIT3
+#define ATMWCR_WIN_DUNIT_CS3_REQ 		(0 << ATMWCR_WIN_DUNIT_CS3_OFFS)
+
+/* RUnit (Device)  attributes */
+#define ATMWCR_WIN_RUNIT_DEVCS0_OFFS		0
+#define ATMWCR_WIN_RUNIT_DEVCS0_MASK		BIT0
+#define ATMWCR_WIN_RUNIT_DEVCS0_REQ		(0 << ATMWCR_WIN_RUNIT_DEVCS0_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS1_OFFS		1
+#define ATMWCR_WIN_RUNIT_DEVCS1_MASK		BIT1
+#define ATMWCR_WIN_RUNIT_DEVCS1_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS1_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS2_OFFS		2
+#define ATMWCR_WIN_RUNIT_DEVCS2_MASK		BIT2
+#define ATMWCR_WIN_RUNIT_DEVCS2_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS2_OFFS)
+
+#define ATMWCR_WIN_RUNIT_BOOTCS_OFFS		4
+#define ATMWCR_WIN_RUNIT_BOOTCS_MASK		BIT4
+#define ATMWCR_WIN_RUNIT_BOOTCS_REQ 		(0 << ATMWCR_WIN_RUNIT_BOOTCS_OFFS)
+
+/* LMaster (PCI)  attributes */
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS		0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_MASK		BIT0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP		(0 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_BYTE_NO_SWP		(1 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+
+
+#define ATMWCR_WIN_LUNIT_WORD_SWP_OFFS		1
+#define ATMWCR_WIN_LUNIT_WORD_SWP_MASK		BIT1
+#define ATMWCR_WIN_LUNIT_WORD_SWP		(0 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_WORD_NO_SWP		(1 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+
+#define ATMWCR_WIN_LUNIT_NO_SNOOP		BIT2
+
+#define ATMWCR_WIN_LUNIT_TYPE_OFFS		3
+#define ATMWCR_WIN_LUNIT_TYPE_MASK		BIT3
+#define ATMWCR_WIN_LUNIT_TYPE_IO		(0 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+#define ATMWCR_WIN_LUNIT_TYPE_MEM		(1 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+
+#define ATMWCR_WIN_LUNIT_FORCE64_OFFS		4
+#define ATMWCR_WIN_LUNIT_FORCE64_MASK		BIT4
+#define ATMWCR_WIN_LUNIT_FORCE64		(0 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+#define ATMWCR_WIN_LUNIT_ORDERING_OFFS		6
+#define ATMWCR_WIN_LUNIT_ORDERING_MASK		BIT6
+#define ATMWCR_WIN_LUNIT_ORDERING		(1 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+/* PEX Attributes */
+#define ATMWCR_WIN_PEX_TYPE_OFFS		3
+#define ATMWCR_WIN_PEX_TYPE_MASK		BIT3
+#define ATMWCR_WIN_PEX_TYPE_IO			(0 << ATMWCR_WIN_PEX_TYPE_OFFS)
+#define ATMWCR_WIN_PEX_TYPE_MEM			(1 << ATMWCR_WIN_PEX_TYPE_OFFS)
+
+/* typedefs */
+
+/* Unsupported attributes for address decode:                               */
+/* 2) PCI0/1_REQ64n control                                                 */
+
+typedef struct _mvTargetAttrib {
+	MV_U8			attrib;			/* chip select attributes */
+	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
+} MV_TARGET_ATTRIB;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin {
+    MV_TARGET	target;         /* Target for addr decode window        */
+    MV_ADDR_WIN	addrWin;        /* Address window of target             */
+    MV_BOOL	enable;         /* Window enable/disable                */
+} MV_DEC_WIN;
+
+typedef struct _mvDecWinParams {
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+} MV_DEC_WIN_PARAMS;
+
+
+/* mvCtrlEnvAddrDec API list */
+
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo);
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, MV_DEC_WIN_PARAMS *pWinParam);
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, MV_DEC_WIN *pAddrDecWin);
+
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len);
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvCtrlEnvAddrDech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
new file mode 100644
index 0000000..1a14a79
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAsmh
+#define __INCmvCtrlEnvAsmh
+#include "pex/mvPexRegs.h"
+
+#define CHIP_BOND_REG			0x18238
+#define PCKG_OPT_MASK_AS 		#3
+#define PXCCARI_REVID_MASK_AS		#PXCCARI_REVID_MASK
+
+/* Read device ID into toReg bits 15:0 from 0xd0000000 */
+/* defines  */
+#define MV_DV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_DV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read device ID into toReg bits 15:0 from 0xf1000000*/
+#define MV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read Revision into toReg bits 7:0 0xd0000000*/
+#define MV_DV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_DV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+/* Read Revision into toReg bits 7:0 0xf1000000*/
+#define MV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+#endif /* __INCmvCtrlEnvAsmh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100644
index 0000000..87424a7
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,2189 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvSysEthConfig.h"
+
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+#include "eth/mvEth.h"
+#else
+#include "neta/gbe/mvNeta.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA */
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+#include "xor/mvXor.h"
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+#include "sata/CoreDriver/mvSata.h"
+#endif
+#if defined(MV_INCLUDE_USB)
+#include "usb/mvUsb.h"
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+#include "mvSysTdmConfig.h"
+#endif
+
+#include "ddr2_3/mvDramIfRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+MV_U32 dummyFlavour = 0;
+MV_BIOS_MODE bios_modes[BIOS_MODES_NUM] = {
+#ifdef MV88F78X60_Z1
+/*	DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq FabricFreqMode CPU1/2/3Enable cpuMode dramBusWidth*/
+/*	0x4d/[1:0] 0x4d/[4:2] 0x4e[0] 0x4e/[4:1] 0x4f[0] 0x4f/[2:1] 0x4f/[4:3]	*/
+       {"78130", 0x10, 0x7813, 0x1, 0x2, 0x0, 0xC, 0x0, 0x0, 0x1, 0x1},
+       {"6710" , 0x11, 0x6710, 0x0, 0x2, 0x0, 0x5, 0x0, 0x0, 0x1, 0x0},
+       {"78160", 0x12, 0x7816, 0x1, 0x2, 0x0, 0x5, 0x0, 0x0, 0x1, 0x0},
+       {"78230", 0x13, 0x7823, 0x1, 0x2, 0x0, 0xC, 0x0, 0x2, 0x2, 0x1},
+       {"78260", 0x14, 0x7826, 0x1, 0x2, 0x0, 0x5, 0x0, 0x2, 0x2, 0x0},
+       {"78460", 0x15, 0x7846, 0x3, 0x2, 0x0, 0x5, 0x0, 0x3, 0x2, 0x0},
+       {"78480", 0x16, 0x7846, 0x3, 0x2, 0x0, 0x5, 0x0, 0x3, 0x2, 0x0}
+};
+#else
+/*DBConf ConfID Code L2Size CPUFreq CpuFreqMode FabricFreq  Altfabricfreq     FabricFreqMode CPU1/2/3Enable cpuEndianess dramBusWidth BootSRC BootWidth */
+/*	                       0x4d/[1:0]  0x4d/[4:2]  0x4e[0]      0x4e/[4:1]  	0x4f[0]   0x4f/[2:1]      0x4f/[3]   	  */
+{"78130",0x10, 0x7813, 0x1,  0x3,      0x0,      0x1a,		0x5,		0x1,	     0x0,	    0x1,	0x1, 	     0x3,	0x1},
+{"78160",0x12, 0x7816, 0x1,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x0,	    0x1, 	0x0, 	     0x3,	0x1},
+{"78230",0x13, 0x7823, 0x1,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x1,	    0x0,	0x1, 	     0x3,	0x1},
+{"78260",0x14, 0x7826, 0x1,  0x3,      0x0,	 0x1a,		0x5,		0x1,	     0x1,	    0x0,	0x0, 	     0x3,	0x1},
+{"78460",0x15, 0x7846, 0x3,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x3,	    0x0,	0x0, 	     0x3,	0x1},
+{"78480",0x16, 0x7846, 0x3,  0x3,      0x0,	 0x1a, 		0x5,		0x1,	     0x3,	    0x0,	0x0, 	     0x3,	0x1}
+
+/*	{"6710" ,0x11, 0x6710,	0x0,	   0x3,		0x0,	      0x5, 		0x0,		0x0,		0x1,		0x0},     */
+};
+#endif
+
+#if 0
+table below before moving all flavour to 1333/667 mode only
+MV_BIOS_MODE bios_modes[BIOS_MODES_NUM] = {
+/*	DB Conf		Code		L2 size		CPU Freq	Fabric Freq		CPU1/2/3 Enable		CPU Mode v6UP/v6MP
+	0x4d/[1:0]	0x4d/[4:2]	0x4e/[4:1]		0x4f/[2:1]				4f/[4:3]*/
+	{"78130", 	0x7813, 	0x1, 		0x1, 		0x1, 			0x0,					0x0},
+	{"KW40", 	0x6710, 	0x1, 		0x1, 		0x1, 			0x0,					0x0},
+	{"78160", 	0x7816, 	0x1, 		0x3, 		0x5, 			0x0,					0x0},
+	{"78230", 	0x7823, 	0x1, 		0x1, 		0x1, 			0x2,					0x2},
+	{"78260", 	0x7826, 	0x1, 		0x3, 		0x5, 			0x2,					0x2},
+	{"78460", 	0x7846, 	0x3, 		0x3, 		0x5, 			0x3,					0x2},
+	{"78480", 	0x7846, 	0x3, 		0x5, 		0x5, 			0x3,					0x2}
+};
+#endif
+MV_U32 mvCtrlGetCpuNum(MV_VOID)
+{
+	return ((MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET);
+}
+MV_U32 mvCtrlGetQuadNum(MV_VOID)
+{
+	return ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_L2_SIZE_MASK) >> SAR0_L2_SIZE_OFFSET);
+}
+MV_BOOL mvCtrlIsValidSatR(MV_VOID)
+{
+	int i = 0;
+	MV_U32 tmpSocCores;
+	MV_U8 cpuEna = 0;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 fabricFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreqMode;
+
+	MV_U32 confId = mvBoardConfIdGet();
+
+	l2size = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_L2_SIZE_MASK) >> SAR0_L2_SIZE_OFFSET;
+	cpuFreq = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_CPU_FREQ_MASK) >> SAR0_CPU_FREQ_OFFSET;
+	fabricFreq = (MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_FABRIC_FREQ_MASK) >> SAR0_FABRIC_FREQ_OFFSET;
+	tmpSocCores = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET;
+	cpuFreqMode = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_MODE_MASK) >> SAR1_CPU_MODE_OFFSET;
+	fabricFreqMode = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_FABRIC_MODE_MASK) >> SAR1_FABRIC_MODE_OFFSET;
+	/* Bug fix in HW, bit0 & bit1 are swapped */
+	cpuEna |= (tmpSocCores & 0x2) >> 1;
+	cpuEna |= (tmpSocCores & 0x1) << 1;
+
+	/* Find out what is programmed in SAR and change device ID accordingly */
+	for (i = 0; i < BIOS_MODES_NUM; i++) {
+		if (bios_modes[i].confId == confId) {
+			DB(mvOsPrintf("confId = 0x%x\n", confId));
+			DB(mvOsPrintf("cpuFreq [0x%x] = 0x%x\n", cpuFreq, bios_modes[i].cpuFreq));
+			DB(mvOsPrintf("fabricFreq [0x%x] = 0x%x\n", fabricFreq, bios_modes[i].fabricFreq));
+			DB(mvOsPrintf("cpuEna [0x%x] = 0x%x\n", cpuEna, bios_modes[i].cpuEna));
+			DB(mvOsPrintf("cpuFreqMode [0x%x] = 0x%x\n", cpuFreqMode, bios_modes[i].cpuFreqMode));
+			DB(mvOsPrintf("fabricFreqMode [0x%x] = 0x%x\n", fabricFreqMode, bios_modes[i].fabricFreqMode));
+			DB(mvOsPrintf("l2size [0x%x] = 0x%x\n", l2size, bios_modes[i].l2size));
+			if ((cpuFreq == bios_modes[i].cpuFreq) &&
+				(fabricFreq ==  bios_modes[i].fabricFreq) &&
+				(cpuEna == bios_modes[i].cpuEna) &&
+				(cpuFreqMode == bios_modes[i].cpuFreqMode) &&
+				(fabricFreqMode == bios_modes[i].fabricFreqMode) &&
+				(l2size == bios_modes[i].l2size)) {
+				return MV_TRUE;
+			} else {
+				return MV_FALSE;
+			}
+		}
+	}
+	return MV_FALSE;
+}
+MV_STATUS mvCtrlUpdatePexId(MV_VOID)
+{
+	/* MV_U32 socFreq, tmpSocCores;		*/
+	/* MV_U32 socCores = 0;				*/
+	MV_U32 pmCtrl;
+#if defined(DB_88F78X60) || defined(RD_88F78460_SERVER) || defined (DB_88F78X60_REV2)
+	MV_U32 devVendId;
+	int i;
+	int j;
+	MV_U16 confId;
+	MV_U32 tmp;
+	MV_U32 NewVal;
+#endif
+
+	/* if PEX0 clock is disabled - enable it for reading the device ID */
+	pmCtrl = MV_REG_READ(POWER_MNG_CTRL_REG);
+	if ((pmCtrl & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
+		MV_REG_WRITE(POWER_MNG_CTRL_REG,
+			(pmCtrl & ~PMC_PEXSTOPCLOCK_MASK(0)) | PMC_PEXSTOPCLOCK_EN(0));
+	}
+#if defined(DB_88F78X60) || defined (DB_88F78X60_REV2)
+	devVendId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+	/* socFreq   = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & SAR0_DDR3_FREQ_MASK; */
+	/* tmpSocCores  = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)) & SAR1_CPU_CORE_MASK) >> SAR1_CPU_CORE_OFFSET; */
+	confId = mvBoardConfIdGet();
+
+	/* Bug fix in HW, bit0 & bit1 are swapped */
+/*	socCores |= (tmpSocCores & 0x2) >> 1;
+	socCores |= (tmpSocCores & 0x1) << 1;
+*/
+	/* Find out what is programmed in SAR and change device ID accordingly */
+/*	if ((socFreq == SAR_CPU_FAB_GET(bios_modes[i].cpuFreq, bios_modes[i].fabricFreq)) &&
+			(socCores == bios_modes[i].cpuEna)) {
+*/
+	tmp = MV_REG_READ(SOC_CTRL_REG); /*Saving old value of 0x18204 to tmp*/
+	NewVal = tmp;
+	NewVal |=0x00000080; /* writing 1 to bit 7 */
+	MV_REG_WRITE(SOC_CTRL_REG, NewVal); /* writing '1' to bit 7 in order to get an access to PEX registers */
+	for (i = 0; i < BIOS_MODES_NUM; i++) {
+		if (bios_modes[i].confId == confId) {
+			devVendId &= 0x0000FFFF;
+			devVendId |= bios_modes[i].code << 16;
+			for (j=0;j<mvCtrlPexMaxIfGet();j++){
+				MV_REG_WRITE(MV_PEX_IF_REGS_OFFSET(j), devVendId);
+			}
+		}
+	}
+	MV_REG_WRITE(SOC_CTRL_REG, tmp);/*returing 0x18204 to it's previous value. */
+
+#elif defined(RD_88F78460_SERVER)
+	devVendId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+	devVendId &= 0x0000FFFF;
+	devVendId |= 0x7846 << 16;
+	MV_REG_WRITE(MV_PEX_IF_REGS_OFFSET(0), devVendId);
+#endif
+	/* Reset the original value of PEX0 clock */
+	if ((pmCtrl & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, pmCtrl);
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+	MV_U32 mppGroup;
+	MV_U32 mppVal;
+	MV_BOARD_PEX_INFO  *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexUnit = 0;
+	MV_U32 i, gppMask;
+
+	/* Disable MBus Error Propagation */
+	MV_REG_BIT_RESET(SOC_COHERENCY_FABRIC_CTRL_REG, BIT8);
+
+	/* Use Background sync barrier (polling) for I/O cache coherency */
+	MV_REG_BIT_SET(SOC_CIB_CTRL_CFG_REG, BIT8);
+
+	/* MPP Init - scan which modeule is connected */
+	mvBoardMppModulesScan();
+
+	/* Read MPP config values from board level and write MPP options to HW */
+	for (mppGroup = 0; mppGroup < MV_MPP_MAX_GROUP; mppGroup++) {
+		mppVal = mvBoardMppGet(mppGroup);	/* get pre-defined values */
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+	/* disable all GPIO interrupts */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+	}
+
+	/* clear all int */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++)
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+
+	/* Set gpp interrupts as needed */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		gppMask = mvBoardGpioIntMaskGet(i);
+		mvGppTypeSet(i, gppMask , (MV_GPP_IN & gppMask));
+		mvGppPolaritySet(i, gppMask , (MV_GPP_IN_INVERT & gppMask));
+	}
+
+	/* Scan for other modules (SERDES/LVDS/...) */
+	mvBoardOtherModulesScan();
+
+	/* Update interfaces configuration based on above scan */
+	if (MV_OK != mvCtrlSerdesPhyConfig())
+		mvOsPrintf("mvCtrlEnvInit: Can't init some or all SERDES lanes\n");
+
+	for (pexUnit = 0; pexUnit < mvCtrlPexMaxUnitGet(); pexUnit++) {
+		/* PEX enabling */
+		if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg != PEX_BUS_DISABLED)
+			MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
+		else
+			MV_REG_BIT_RESET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
+	}
+
+	/* In case the sample at reset REG indicates a CLK 100MHZ is used for output we should enable the CLK through the SOC CTRL REG*/
+	if ( ((MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & PEX_CLK_100MHZ_MASK) >> PEX_CLK_100MHZ_OFFSET) == 0x1) {
+	        MV_REG_BIT_SET(SOC_CTRL_REG,PCIE0_CLK_OUT_EN_MASK);
+	        MV_REG_BIT_SET(SOC_CTRL_REG,PCIE1_CLK_OUT_EN_MASK);
+	}
+
+#ifndef MV88F78X60_Z1
+	MV_REG_BIT_SET(PUP_EN_REG,0x17); /* Enable GBE0, GBE1, LCD and NFC PUP */
+#endif
+	mvOsDelay(100);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+	MV_U32 ret;
+
+	if (mppGroup >= MV_MPP_MAX_GROUP)
+		mppGroup = 0;
+
+	ret = MPP_CONTROL_REG(mppGroup);
+
+	return ret;
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 7;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_PEX_MAX_IF;
+
+	default:
+		return 0;
+	}
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlPexMaxUnitGet - Get Marvell controller number of PEX units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxUnitGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 2;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+		return 3;
+
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_PEX_MAX_UNIT;
+
+	default:
+		return 0;
+	}
+}
+
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet - Get Marvell controller number of PEX interfaces.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPciMaxIfGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_FPGA_DEV_ID:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+#endif
+
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+	switch (devId) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return MV_78130_ETH_MAX_PORT;
+
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return MV_78460_ETH_MAX_PORT;
+
+	default:
+		return 0;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlEthMaxCPUsGet - Get Marvell controller number of CPUs.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of CPUs.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of CPUs.
+*
+*******************************************************************************/
+MV_U8 mvCtrlEthMaxCPUsGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+
+	/* FIXME - assuming MV_78460_DEV_ID */
+	devId = MV_78460_DEV_ID;
+
+	switch (devId) {
+	case MV_78130_DEV_ID:
+	case MV_78230_DEV_ID:
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+	case MV_78460_DEV_ID:
+		return 4;
+
+	default:
+		return 0;
+	}
+}
+
+
+#if defined(MV_INCLUDE_SATA)
+/*******************************************************************************
+* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of Sata ports.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of Sata ports.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_SATA_MAX_CHAN;
+		break;
+	}
+	return res;
+}
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+/*******************************************************************************
+* mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_XOR_MAX_CHAN;
+		break;
+	}
+	return res;
+}
+
+/*******************************************************************************
+* mvCtrlXorMaxUnitGet - Get Marvell controller number of XOR units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	default:
+		res = MV_XOR_MAX_UNIT;
+		break;
+	}
+	return res;
+}
+
+#endif
+
+#if defined(MV_INCLUDE_USB)
+/*******************************************************************************
+* mvCtrlUsbHostMaxGet - Get number of Marvell Usb  controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB  controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsbMaxGet(void)
+{
+	MV_U32 devId;
+	MV_U32 res = 0;
+
+	devId = mvCtrlModelGet();
+
+	switch (devId) {
+	case MV_FPGA_DEV_ID:
+		res = 0;
+		break;
+
+	default:
+		res = ARMADA_XP_MAX_USB_PORTS;
+		break;
+	}
+
+	return res;
+}
+#endif
+
+#if defined(MV_INCLUDE_LEGACY_NAND)
+/*******************************************************************************
+* mvCtrlNandSupport - Return if this controller has integrated NAND flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if NAND is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlNandSupport(MV_VOID)
+{
+	return ARMADA_XP_NAND;
+}
+#endif
+
+#if defined(MV_INCLUDE_SDIO)
+/*******************************************************************************
+* mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SDIO is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlSdioSupport(MV_VOID)
+{
+	return ARMADA_XP_SDIO;
+}
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmSupport(MV_VOID)
+{
+	return ARMADA_XP_TDM;
+}
+
+/*******************************************************************************
+* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       The number of TDM ports in device.
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmMaxGet(MV_VOID)
+{
+	return ARMADA_XP_MAX_TDM_PORTS;
+}
+
+/*******************************************************************************
+* mvCtrlTdmTypeGet
+*
+* DESCRIPTION:
+*	Return the TDM unit type being compiled in.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TDM unit type.
+*
+*******************************************************************************/
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID)
+{
+	return TDM_UNIT_32CH;
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitIrqGet
+*
+* DESCRIPTION:
+*	Return the TDM unit IRQ number depending on the TDM unit compilation
+*	options.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+******************************************************************************/
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
+{
+	return MV_TDM_IRQ_NUM;
+}
+
+#endif /* if defined(MV_INCLUDE_TDM) */
+
+/*******************************************************************************
+* mvCtrlModelGet - Get Marvell controller device model (Id)
+*
+* DESCRIPTION:
+*       This function returns 16bit describing the device model (ID) as defined
+*       in PCI Device and Vendor ID configuration register offset 0x0.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit desscribing Marvell controller ID
+*
+*******************************************************************************/
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	MV_U32 devId;
+	MV_U16 model = 0;
+	MV_U32 reg, reg2;
+
+	/* if PEX0 clocks are disabled - enabled it to read */
+	reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0)) {
+		reg2 = ((reg & ~PMC_PEXSTOPCLOCK_MASK(0)) | PMC_PEXSTOPCLOCK_EN(0));
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg2);
+	}
+
+	devId = MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PEX_DEVICE_AND_VENDOR_ID));
+
+	/* Reset the original value of the PEX0 clock */
+	if ((reg & PMC_PEXSTOPCLOCK_MASK(0)) == PMC_PEXSTOPCLOCK_STOP(0))
+		MV_REG_WRITE(POWER_MNG_CTRL_REG, reg);
+
+
+	model = (MV_U16) ((devId >> 16) & 0xFFFF);
+
+	return model;
+}
+
+/*******************************************************************************
+* mvCtrlRevGet - Get Marvell controller device revision number
+*
+* DESCRIPTION:
+*       This function returns 8bit describing the device revision as defined
+*       in PCI Express Class Code and Revision ID Register.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit desscribing Marvell controller revision number
+*
+*******************************************************************************/
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	MV_U8 revNum;
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Check pex power state */
+	MV_U32 pexPower;
+	pexPower = mvCtrlPwrClckGet(PEX_UNIT_ID, 0);
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_TRUE);
+#endif
+	revNum = (MV_U8) MV_REG_READ(PEX_CFG_DIRECT_ACCESS(0, PCI_CLASS_CODE_AND_REVISION_ID));
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	/* Return to power off state */
+	if (pexPower == MV_FALSE)
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 0, MV_FALSE);
+#endif
+	return ((revNum & PCCRIR_REVID_MASK) >> PCCRIR_REVID_OFFS);
+}
+
+/*******************************************************************************
+* mvCtrlNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlNameGet(char *pNameBuff)
+{
+	if (mvCtrlModelGet() == 0x7800)
+		mvOsSPrintf(pNameBuff, "%s78XX", SOC_NAME_PREFIX);
+	else
+		mvOsSPrintf(pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX, mvCtrlModelGet(), mvCtrlRevGet());
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlModelRevGet - Get Controller Model (Device ID) and Revision
+*
+* DESCRIPTION:
+*       This function returns 32bit value describing both Device ID and Revision
+*       as defined in PCI Express Device and Vendor ID Register and device revision
+*	    as defined in PCI Express Class Code and Revision ID Register.
+
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing both controller device ID and revision number
+*
+*******************************************************************************/
+MV_U32 mvCtrlModelRevGet(MV_VOID)
+{
+	return ((mvCtrlModelGet() << 16) | mvCtrlRevGet());
+}
+
+/*******************************************************************************
+* mvCtrlModelRevNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
+{
+	switch (mvCtrlModelRevGet()) {
+	case MV_78130_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78130_Z1_NAME);
+		break;
+
+	case MV_6710_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_6710_Z1_NAME);
+		break;
+
+	case MV_78230_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78230_Z1_NAME);
+		break;
+	case MV_78160_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78160_Z1_NAME);
+		break;
+	case MV_78260_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78260_Z1_NAME);
+		break;
+	case MV_78460_Z1_ID:
+		mvOsSPrintf(pNameBuff, "%s", MV_78460_Z1_NAME);
+		break;
+
+	 case MV_78130_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78130_A0_NAME);
+               break;
+
+       case MV_78230_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78230_A0_NAME);
+               break;
+       case MV_78160_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78160_A0_NAME);
+               break;
+       case MV_78260_A0_ID:
+               mvOsSPrintf(pNameBuff, "%s", MV_78260_A0_NAME);
+               break;
+       case MV_78460_A0_ID:
+              mvOsSPrintf(pNameBuff, "%s", MV_78460_A0_NAME);
+               break;
+	default:
+		mvCtrlNameGet(pNameBuff);
+		break;
+	}
+
+	return MV_OK;
+}
+
+static const char *cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
+{
+	if (target >= MAX_TARGETS)
+		return "target unknown";
+
+	return cntrlName[target];
+}
+
+/*******************************************************************************
+* mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
+*
+* DESCRIPTION:
+*		This function print the PEX address decode map (BARs and windows).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
+{
+	MV_PEX_BAR pexBar;
+	MV_PEX_DEC_WIN win;
+	MV_U32 pexIf;
+	MV_U32 bar, winNum;
+	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pexIf = 0; pexIf < boardPexInfo->boardPexIfNum; pexIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pexIf];
+
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("PEX%d:\n", pexHWInf);
+		mvOsOutput("-----\n");
+
+		mvOsOutput("\nPex Bars \n\n");
+
+		for (bar = 0; bar < PEX_MAX_BARS; bar++) {
+			memset(&pexBar, 0, sizeof(MV_PEX_BAR));
+
+			mvOsOutput("%s ", pexBarNameGet(bar));
+
+			if (mvPexBarGet(pexHWInf, bar, &pexBar) == MV_OK) {
+				if (pexBar.enable) {
+					mvOsOutput("base %08x, ", pexBar.addrWin.baseLow);
+					if (pexBar.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(pexBar.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+		mvOsOutput("\nPex Decode Windows\n\n");
+
+		for (winNum = 0; winNum < PEX_MAX_TARGET_WIN - 2; winNum++) {
+			memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+			mvOsOutput("win%d - ", winNum);
+
+			if (mvPexTargetWinRead(pexHWInf, winNum, &win) == MV_OK) {
+				if (win.winInfo.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win.winInfo)),
+						   win.winInfo.addrWin.baseLow);
+					mvOsOutput("....");
+					mvSizePrint(win.winInfo.addrWin.size);
+
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("default win - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_DEFAULT, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("Expansion ROM - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_EXP_ROM, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvUnitAddrDecShow - Print the Unit's address decode map.
+*
+* DESCRIPTION:
+*       This is a generic function for printing the different unit's address
+*	decode map.
+*
+* INPUT:
+*       unit	- The unit to print the address decode for.
+*	name	- The unit's name.
+*	winGetFuncPtr - A pointer to the HAL's window get function.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId, const char *name, MV_WIN_GET_FUNC_PTR winGetFuncPtr)
+{
+	MV_UNIT_WIN_INFO win;
+	MV_U32 unit, i;
+
+	for (unit = 0; unit < numUnits; unit++) {
+
+		if (MV_FALSE == mvCtrlPwrClckGet(unitId, unit))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("%s %d:\n", name, unit);
+		mvOsOutput("----\n");
+
+		for (i = 0; i < 16; i++) {
+			memset(&win, 0, sizeof(MV_UNIT_WIN_INFO));
+
+			mvOsOutput("win%d - ", i);
+
+			if (winGetFuncPtr(unit, i, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win)),
+						   win.addrWin.baseLow);
+					mvOsOutput("....");
+					if (win.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+	return;
+}
+
+/*******************************************************************************
+* mvCtrlAddrDecShow - Print the Controller units address decode map.
+*
+* DESCRIPTION:
+*		This function the Controller units address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlAddrDecShow(MV_VOID)
+{
+	mvCpuIfAddDecShow();
+	mvAhbToMbusAddDecShow();
+#if defined(MV_INCLUDE_PEX)
+	mvCtrlPexAddrDecShow();
+#endif
+#if defined(MV_INCLUDE_USB)
+	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
+#endif
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#else
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
+#endif /* MV_ETH_LEGACY */
+#endif /* MV_INCLUDE_GIG_ETH */
+
+#if defined(MV_INCLUDE_XOR)
+	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
+#endif
+#if defined(MV_INCLUDE_SATA)
+	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
+#endif
+}
+
+/*******************************************************************************
+* ctrlSizeToReg - Extract size value for register assignment.
+*
+* DESCRIPTION:
+*       Address decode size parameter must be programed from LSB to MSB as
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
+*       value of 0x00ff specifies 256x64k = 16 MB).
+*       This function extract the size value from the size parameter according
+*       to given aligment paramter. For example for size 0x1000000 (16MB) and
+*       aligment 0x10000 (64KB) the function will return 0x00FF.
+*
+* INPUT:
+*       size - Size.
+*       alignment - Size alignment. Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size register value correspond to size parameter.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 retVal;
+
+	/* Check size parameter alignment               */
+	if ((0 == size) || (MV_IS_NOT_ALIGN(size, alignment))) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
+		return -1;
+	}
+
+	/* Take out the "alignment" portion out of the size parameter */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+	/* and size is 0x1000000 (16MB) for example     */
+	while (alignment & 1) {	/* Check that alignmet LSB is set       */
+		size = (size >> 1);	/* If LSB is set, move 'size' one bit to right      */
+		alignment = (alignment >> 1);
+	}
+
+	/* If after the alignment first '0' was met we still have '1' in                */
+	/* it then aligment is invalid (not power of 2)                                 */
+	if (alignment) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", (MV_U32) alignment));
+		return -1;
+	}
+
+	/* Now the size is shifted right according to aligment: 0x0100                  */
+	size--;			/* Now the size is a sequance of '1': 0x00ff                    */
+	retVal = size;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	while (size & 1)	/* Check that LSB is set    */
+		size = (size >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (size) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", size));
+		return -1;
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+* ctrlRegToSize - Extract size value from register value.
+*
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*       according to given aligment paramter. For example for register size
+*       value 0xff and aligment 0x10000 the function will return 0x01000000.
+*
+* INPUT:
+*       regSize   - Size as in register format.	See ctrlSizeToReg.
+*       alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
+{
+	MV_U32 temp;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff            */
+
+	while (temp & 1)	/* Check that LSB is set                                    */
+		temp = (temp >> 1);	/* If LSB is set, move one bit to the right         */
+
+	if (temp) {		/* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n", regSize));
+		return -1;
+	}
+
+	/* Check that aligment is a power of two                                        */
+	temp = alignment - 1;	/* Now the alignmet is a sequance of '1' (0xffff)          */
+
+	while (temp & 1)	/* Check that alignmet LSB is set                           */
+		temp = (temp >> 1);	/* If LSB is set, move 'size' one bit to right      */
+
+	/* If after the 'temp' first '0' was met we still have '1' in 'temp'            */
+	/* then 'temp' is invalid (not power of 2)                                      */
+	if (temp) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", alignment));
+		return -1;
+	}
+
+	regSize++;		/* Now the size is 0x0100                                       */
+
+	/* Add in the "alignment" portion to the register size parameter                */
+	alignment--;		/* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+
+	while (alignment & 1) {	/* Check that alignmet LSB is set                       */
+		regSize = (regSize << 1);	/* LSB is set, move 'size' one bit left     */
+		alignment = (alignment >> 1);
+	}
+
+	return regSize;
+}
+
+/*******************************************************************************
+* ctrlSizeRegRoundUp - Round up given size
+*
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
+*       restrictions of size format given an aligment parameter.
+*		to given aligment paramter. For example for size parameter 0xa1000 and
+*		aligment 0x1000 the function will return 0xFF000.
+*
+* INPUT:
+*       size - Size.
+*		alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size value correspond to size in register.
+*******************************************************************************/
+MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 msbBit = 0;
+	MV_U32 retSize;
+
+	/* Check if size parameter is already comply with restriction   */
+	if (!(-1 == ctrlSizeToReg(size, alignment)))
+		return size;
+
+	while (size) {
+		size = (size >> 1);
+		msbBit++;
+	}
+
+	retSize = (1 << msbBit);
+
+	if (retSize < alignment)
+		return alignment;
+	else
+		return retSize;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNOR
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from NOR flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if (satr == MSAR_BOOT_NOR)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromSPI
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from SPI flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if (satr == MSAR_BOOT_SPI)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNAND
+*
+* DESCRIPTION:
+*       Check if device is confiogured to boot from NAND flash according to the SAR
+*	registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from NAND.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID)
+{
+	MV_U32 satr;
+
+	satr = MV_REG_READ(MPP_SAMPLE_AT_RESET(0)) & MSAR_BOOT_MODE_MASK;
+
+	if ((satr == MSAR_BOOT_DOVE_NAND) || (satr == MSAR_BOOT_LEGACY_NAND))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckSet - Set Power State for specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_PEXSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_GESTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATASTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_CESASTOPCLOCK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USBSTOPCLOCK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SDIOSTOPCLOCK_MASK);
+
+		break;
+#endif
+	case TDM_32CH_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_TDMSTOPCLOCK_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrClckGet - Get Power State of specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	MV_BOOL state = MV_TRUE;
+
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if ((reg & PMC_PEXSTOPCLOCK_MASK(index)) == PMC_PEXSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if ((reg & PMC_GESTOPCLOCK_MASK(index)) == PMC_GESTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		if ((reg & PMC_SATASTOPCLOCK_MASK(index)) == PMC_SATASTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((reg & PMC_CESASTOPCLOCK_MASK) == PMC_CESASTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if ((reg & PMC_USBSTOPCLOCK_MASK(index)) == PMC_USBSTOPCLOCK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if ((reg & PMC_SDIOSTOPCLOCK_MASK) == PMC_SDIOSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TDM)
+	case TDM_32CH_UNIT_ID:
+		if ((reg & PMC_TDMSTOPCLOCK_MASK) == PMC_TDMSTOPCLOCK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemSet - Set Power State for memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX), PMC_PEXSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE), PMC_GESTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA), PMC_SATASTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA), PMC_CESASTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB), PMC_USBSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_STOP(index));
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR), PMC_XORSTOPMEM_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM), PMC_BMSTOPMEM_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_SET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_STOP);
+		else
+			MV_REG_BIT_RESET(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC), PMC_PNCSTOPMEM_MASK);
+
+		break;
+#endif
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+* mvCtrlPwrMemGet - Get Power State of memory on specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg;
+	MV_BOOL state = MV_TRUE;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PEX));
+		if ((reg & PMC_PEXSTOPMEM_MASK(index)) == PMC_PEXSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_GE));
+		if ((reg & PMC_GESTOPMEM_MASK(index)) == PMC_GESTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_SATA));
+		if ((reg & PMC_SATASTOPMEM_MASK(index)) == PMC_SATASTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_CESA));
+		if ((reg & PMC_CESASTOPMEM_MASK) == PMC_CESASTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_USB));
+		if ((reg & PMC_USBSTOPMEM_MASK(index)) == PMC_USBSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_XOR)
+	case XOR_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_XOR));
+		if ((reg & PMC_XORSTOPMEM_MASK(index)) == PMC_XORSTOPMEM_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_BM)
+	case BM_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_BM));
+		if ((reg & PMC_BMSTOPMEM_MASK) == PMC_BMSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_PNC)
+	case PNC_UNIT_ID:
+		reg = MV_REG_READ(POWER_MNG_MEM_CTRL_REG(PMC_MCR_NUM_PNC));
+		if ((reg & PMC_PNCSTOPMEM_MASK) == PMC_PNCSTOPMEM_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+#else
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	return;
+}
+
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	return MV_TRUE;
+}
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+/*******************************************************************************
+* mvCtrlSerdesMaxLinesGet - Get Marvell controller number of SERDES lines.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID)
+{
+	switch (mvCtrlModelGet()) {
+	case MV_78130_DEV_ID:
+	case MV_6710_DEV_ID:
+	case MV_78230_DEV_ID:
+		return 7;
+	case MV_78160_DEV_ID:
+	case MV_78260_DEV_ID:
+		return 12;
+		break;
+	case MV_78460_DEV_ID:
+	case MV_78000_DEV_ID:
+		return 16;
+	default:
+		return 0;
+	}
+}
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x1400);
+
+	return (reg & 0x8000) ? 64 : 32;
+}
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(0x20184);
+
+	return (reg & 0x1) ? MV_FALSE : MV_TRUE;
+}
+
+MV_BOOL mvCtrlDDRECC(MV_VOID)
+{
+	MV_U32 reg;
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_ECC_OFFS)) ? MV_TRUE : MV_FALSE;
+}
+
+static const MV_U8 serdesCfg[][8] = SERDES_CFG;
+
+/*******************************************************************************
+* mvCtrlSerdesPhyConfig
+*
+* DESCRIPTION:
+*	Configure Serdes MUX and init PHYs connected to SERDES lines.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Status
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID)
+{
+	MV_U32		serdesLineCfg;
+	MV_U8		serdesLineNum;
+	MV_U8		pexUnit, pexLineNum;
+	MV_U8		step;
+	MV_U8		maxSerdesLines = mvCtrlSerdesMaxLinesGet();
+	MV_SERDES_CFG	*pSerdesInfo = mvBoardSerdesCfgGet();
+	MV_BOARD_PEX_INFO 	*boardPexInfo = mvBoardPexInfoGet();
+	MV_STATUS	status = MV_OK;
+	MV_U32		tmp;
+
+/* this is a mapping of the final power management clock gating control register value @ 0x18220.*/
+	MV_U32	powermngmntctrlregmap = 0x0;
+	MV_U32	ethport = 0;
+	MV_U32	tmpcounter = 0;
+
+	/* Check if no SERDESs available - FPGA */
+	if (maxSerdesLines == 0)
+		return MV_OK;
+
+	if (pSerdesInfo == NULL) {
+		DB(mvOsPrintf("%s: Error reading SERDES configuration!\n", __func__));
+		return MV_ERROR;
+	}
+
+	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
+
+	/* Prepare PHY parameters for each step according to  MUX selection */
+	for (serdesLineNum = 0; serdesLineNum < maxSerdesLines; serdesLineNum++) {
+		/* for each serdes lane*/
+		MV_U8	sgmiiPort = 0;
+
+		if (serdesLineNum < 8)
+			serdesLineCfg = (pSerdesInfo->serdesLine0_7 >> (serdesLineNum << 2)) & 0xF;
+		else
+			serdesLineCfg = (pSerdesInfo->serdesLine8_15 >> ((serdesLineNum - 8) << 2)) & 0xF;
+
+		if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_PEX]) {
+			pexUnit    = serdesLineNum >> 2;
+			pexLineNum = serdesLineNum % 4;
+
+			/* Map the PCI-E interfaces according to their HW mapping
+			   Map PCI-E virtual intrefaces in an array where we have information about
+			   every interface (e.g. HW mapping, x1,x4,x8 ( disabled) .. )
+			*/
+			switch (pexUnit) {
+			case 0:
+				boardPexInfo->pexUnitCfg[pexUnit].pexCfg = pSerdesInfo->pex0Mod;
+				break;
+			case 1:
+				boardPexInfo->pexUnitCfg[pexUnit].pexCfg = pSerdesInfo->pex1Mod;
+				break;
+			case 2:
+				boardPexInfo->pexUnitCfg[pexUnit].pexCfg = pSerdesInfo->pex2Mod;
+				break;
+			case 3:
+				boardPexInfo->pexUnitCfg[pexUnit].pexCfg = pSerdesInfo->pex3Mod;
+				break;
+			}
+			if ((pexUnit < 2) && (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_MODE_X1)) {
+
+				boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = pexUnit * 4 + pexLineNum;
+				boardPexInfo->boardPexIfNum++;
+				boardPexInfo->pexUnitCfg[pexUnit].pexLaneStat[pexLineNum] = 0x1;
+				powermngmntctrlregmap = powermngmntctrlregmap | (0x1<<(serdesLineNum+5));
+			} else if ((pexUnit < 4) &&
+				(boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_MODE_X4) &&
+				(pexLineNum == 0)) {
+
+				switch (pexUnit) {
+				case 0:
+				case 1:
+					boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = pexUnit*4 + pexLineNum;
+					powermngmntctrlregmap = powermngmntctrlregmap | (0x1 << (serdesLineNum+5));
+					break;
+				case 2:
+				case 3:
+					boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = PEX2_0x4 + (pexUnit - 2);
+					powermngmntctrlregmap = powermngmntctrlregmap | (0x1 << (pexUnit+24));
+					break;
+				}
+
+				boardPexInfo->boardPexIfNum++;
+
+			} else if ((pexUnit == 3) &&
+				(pSerdesInfo->pex3Mod == PEX_BUS_MODE_X8) &&
+				(pexLineNum == 0)) {
+
+				boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = PEX3_0x4;
+				boardPexInfo->boardPexIfNum++;
+			}
+
+			/* Needed for PEX_PHY_ACCESS_REG macro */
+			if ((serdesLineNum > 7) && (pSerdesInfo->pex3Mod == PEX_BUS_MODE_X8))
+				pexUnit = 3; /* lines 8 - 15 are belong to PEX3 in x8 mode */
+
+		} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SATA]) {
+
+			MV_U8	sataPort;
+
+			if ((serdesLineNum == 4) || (serdesLineNum == 6)) {
+				sataPort = 0;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_SATASTOPCLOCK_MASK(sataPort);
+			} else if (serdesLineNum == 5) {
+				sataPort = 1;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_SATASTOPCLOCK_MASK(sataPort);
+			} else
+				goto err_cfg;
+
+		} else {
+
+			if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII0]) {
+				sgmiiPort = 0;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(sgmiiPort);
+			} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII1]) {
+				sgmiiPort = 1;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(sgmiiPort);
+			} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII2]) {
+				sgmiiPort = 2;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(sgmiiPort);
+			} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_SGMII3]) {
+				sgmiiPort = 3;
+				powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(sgmiiPort);
+			} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_QSGMII]) {
+				sgmiiPort = 0;
+				powermngmntctrlregmap = powermngmntctrlregmap | \
+										PMC_GESTOPCLOCK_MASK(0) | PMC_GESTOPCLOCK_MASK(1) | \
+										PMC_GESTOPCLOCK_MASK(2) | PMC_GESTOPCLOCK_MASK(3);
+			} else if (serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_UNCONNECTED])
+				continue;
+
+
+		}
+
+	}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+	powermngmntctrlregmap = powermngmntctrlregmap | BIT4; /* Enabling port GE0 always since we need SMI 0 to access other PHYs*/
+	/*check if GE1 is not enabled via MPPs and not Serdes - if yes you have to enable the clock*/
+		if (MV_TRUE ==  mvBoardIsGbEPortConnected(1))
+			powermngmntctrlregmap = powermngmntctrlregmap | PMC_GESTOPCLOCK_MASK(1);
+
+
+	/* Hard core enable DDR, USB, SDIO, LCD, XOR, IDMA, CESA cause we don't support this at this momemt*/
+	powermngmntctrlregmap = powermngmntctrlregmap | (BIT0  | BIT13 | (0x1FF<<16) | BIT24 | BIT25 | BIT28 | BIT31);
+	DB(mvOsPrintf("%s:Shutting down unused interfaces:\n", __func__));
+	/*now report everything to the screen*/
+	if (!(powermngmntctrlregmap & PMC_SATASTOPCLOCK_MASK(0))) {
+		DB(mvOsPrintf("%s:       SATA0\n", __func__));
+		mvCtrlPwrClckSet(SATA_UNIT_ID, 0, MV_FALSE);
+	}
+	if (!(powermngmntctrlregmap & PMC_SATASTOPCLOCK_MASK(1))) {
+		DB(mvOsPrintf("%s:       SATA1\n", __func__));
+		mvCtrlPwrClckSet(SATA_UNIT_ID, 1, MV_FALSE);
+	}
+	for (tmpcounter = 0; tmpcounter < 4; tmpcounter++) {
+		if (!(powermngmntctrlregmap & (1 << (4 - tmpcounter)))) {
+			/*mvOsOutput("       GBE%d\n", tmpcounter );*/
+			DB(mvOsPrintf("%s:       GBE%d\n", __func__, tmpcounter));
+			mvCtrlPwrClckSet(ETH_GIG_UNIT_ID, tmpcounter, MV_FALSE);
+		}
+	}
+	for (tmpcounter = 0; tmpcounter < 8; tmpcounter++) {
+		if (!(powermngmntctrlregmap & (1 << (5 + tmpcounter)))) {
+			DB(mvOsPrintf("%s:       PEX%d.%d\n", __func__, tmpcounter>>2, tmpcounter % 4));
+			mvCtrlPwrClckSet(PEX_UNIT_ID, tmpcounter, MV_FALSE);
+		}
+	}
+	if (!(powermngmntctrlregmap & BIT26)) {
+		DB(mvOsPrintf("%s:       PEX2\n", __func__));
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 8, MV_FALSE);
+	}
+	if (!(powermngmntctrlregmap & BIT27)) {
+		DB(mvOsPrintf("%s:       PEX3\n", __func__));
+		mvCtrlPwrClckSet(PEX_UNIT_ID, 9, MV_FALSE);
+	}
+
+#ifndef MV88F78X60_Z1
+/*this code is valid for all devices after Z1*/
+	if(!(powermngmntctrlregmap & BIT25)) {
+		DB(mvOsPrintf("%s:       TDM\n", __func__));
+		mvCtrlPwrClckSet(TDM_32CH_UNIT_ID, 0, MV_FALSE);
+	}
+#endif
+	/*apply clock gatting*/
+	MV_REG_WRITE(POWER_MNG_CTRL_REG, MV_REG_READ(POWER_MNG_CTRL_REG) & powermngmntctrlregmap);
+	/*the Sata driver doesn't support clock gating at this point so we enable the logic to the block*/
+	MV_REG_WRITE(POWER_MNG_CTRL_REG, MV_REG_READ(POWER_MNG_CTRL_REG) | (BIT15 | BIT30));
+#endif /* defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+
+
+#if 0
+	#define MV_PEX_UNIT_TO_IF(pexUnit)	((pexUnit < 3) ? (pexUnit*4) : 9)
+	for (pexUnit = 0; pexUnit < mvCtrlPexMaxUnitGet(); pexUnit++) {
+		if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_DISABLED)
+			continue;
+                 /* PEX capability workaround: setting capability as GEN1 or GEN2 according to SatR (valid only for DB board) , (Mark , Moti) */
+                tmp = MV_REG_READ(PEX_LINK_CAPABILITIES_REG(MV_PEX_UNIT_TO_IF(pexUnit)));
+                tmp &= ~(0xF);
+                switch (mvBoardPexCapabilityGet()) {
+                    case 0x0:
+                             tmp |= 0x1;
+                              break;
+                    case 0x1:
+                    default:
+                              tmp |= 0x2;
+                              break;
+                  }
+                      MV_REG_WRITE(PEX_LINK_CAPABILITIES_REG(MV_PEX_UNIT_TO_IF(pexUnit)), tmp);
+		}
+#else
+#if 0
+		for (serdesLineNum = 0; serdesLineNum < maxSerdesLines; serdesLineNum++) {
+	                if (serdesLineNum < 8)
+                                serdesLineCfg = (pSerdesInfo->serdesLine0_7 >> (serdesLineNum << 2)) & 0xF;
+                        else
+                                serdesLineCfg = (pSerdesInfo->serdesLine8_15 >> ((serdesLineNum - 8) << 2)) & 0xF;
+
+			if(serdesLineCfg == serdesCfg[serdesLineNum][SERDES_UNIT_PEX]) {
+				pexUnit    = serdesLineNum >> 2;
+				pexLineNum = serdesLineNum % 4;
+				if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_DISABLED)
+					continue;
+				tmp = MV_REG_READ(PEX_LINK_CAPABILITIES_REG(MV_SERDES_NUM_TO_PEX_NUM(serdesLineNum)));
+				tmp &= ~(0xF);
+				switch (mvBoardPexCapabilityGet()) {
+				case 0x0:
+					tmp |= 0x1;
+					break;
+				case 0x1:
+				default:
+					tmp |= 0x2;
+					break;
+				}
+				MV_REG_WRITE(PEX_LINK_CAPABILITIES_REG(MV_SERDES_NUM_TO_PEX_NUM(serdesLineNum)), tmp);
+
+				if (boardPexInfo->pexUnitCfg[pexUnit].pexCfg == PEX_BUS_MODE_X4)
+                                        serdesLineNum += 3;
+                        }
+                }
+#endif
+#endif
+
+
+
+	return status;
+err_cfg:
+	DB(mvOsPrintf("%s: Wrong CFG (%#x) for SERDES line %d.\n",
+		__func__, serdesLineCfg, serdesLineNum));
+	return MV_ERROR;
+
+}
+
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100644
index 0000000..c8355ce
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,278 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+/* includes */
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+/*#include "boardEnv/mvBoardEnvLib.h"*/
+
+/* 0 for Auto scan mode, 1 for manual. */
+#define MV_INTERNAL_SWITCH_SMI_SCAN_MODE	0
+
+/* typedefs */
+typedef MV_STATUS(*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+/* This enumerator describes the possible HW cache coherency policies the   */
+/* controllers supports.                                                    */
+typedef enum _mvCachePolicy {
+    NO_COHERENCY,   /* No HW cache coherency support                        */
+    WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
+    WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
+} MV_CACHE_POLICY;
+
+
+/* The swapping is referred to a 64-bit words (as this is the controller    */
+/* internal data path width). This enumerator describes the possible        */
+/* data swap types. Below is an example of the data 0x0011223344556677      */
+typedef enum _mvSwapType {
+    MV_BYTE_SWAP,       /* Byte Swap                77 66 55 44 33 22 11 00 */
+    MV_NO_SWAP,         /* No swapping              00 11 22 33 44 55 66 77 */
+    MV_BYTE_WORD_SWAP,  /* Both byte and word swap  33 22 11 00 77 66 55 44 */
+    MV_WORD_SWAP,       /* Word swap                44 55 66 77 00 11 22 33 */
+    SWAP_TYPE_MAX	/* Delimiter for this enumerator                    */
+} MV_SWAP_TYPE;
+
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7,
+	SERDES_UNIT_LAST
+} MV_SERDES_UNIT_INDX;
+
+typedef enum {
+	PEX_BUS_DISABLED	= 0,
+	PEX_BUS_MODE_X1		= 1,
+	PEX_BUS_MODE_X4		= 2,
+	PEX_BUS_MODE_X8		= 3
+} MV_PEX_UNIT_CFG;
+
+/* Configuration per SERDES line.
+   Each nibble is MV_SERDES_LINE_TYPE */
+typedef struct _boardSerdesConf {
+	MV_U32 enableSerdesConfiguration; /*This will determine if mvCtrlSerdesPhyConfig will configure the serdes*/
+	MV_U32	serdesLine0_7;	/* Lines 0 to 7 SERDES MUX one nibble per line */
+	MV_U32	serdesLine8_15;	/* Lines 8 to 15 SERDES MUX one nibble per line */
+	MV_PEX_UNIT_CFG		pex0Mod;
+	MV_PEX_UNIT_CFG		pex1Mod;
+	MV_PEX_UNIT_CFG		pex2Mod;
+	MV_PEX_UNIT_CFG		pex3Mod;
+	MV_U32	busSpeed;	/* Bus speed - one bit per SERDES line:
+	Low speed (0)		High speed (1)
+	PEX	2.5 G (10 bit)		5 G (20 bit)
+	SATA	1.5 G			3 G
+	SGMII 	1.25 Gbps		3.125 Gbps	*/
+} MV_SERDES_CFG;
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG					0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+
+
+/* BIOS Modes related defines */
+#define SAR0_CPU_FREQ_MASK	0x00E00000
+#define SAR0_CPU_FREQ_OFFSET	21
+#define SAR0_FABRIC_FREQ_MASK	0x0F000000
+#define SAR0_FABRIC_FREQ_OFFSET	24
+#define SAR0_L2_SIZE_MASK	0x00180000
+#define SAR0_L2_SIZE_OFFSET	19
+#define SAR0_BOOTSRC_MASK	0X1E0
+#define SAR0_BOOTSRC_OFFSET	5
+#define SAR0_BOOTWIDTH_MASK	0X18
+#define SAR0_BOOTWIDTH_OFFSET	3
+#define SAR0_CPU0CORE_MASK	0X80000000
+#define SAR0_CPU0CORE_OFFSET	31
+#define PEX_CLK_100MHZ_MASK    0x00000004
+#define PEX_CLK_100MHZ_OFFSET  2
+#define SAR1_CPU0CORE_MASK	0x1
+#define SAR1_CPU0CORE_OFFSET	0
+#define SAR1_CPU_CORE_MASK	0x00000018
+#define SAR1_CPU_CORE_OFFSET	3
+#define SAR1_CPU_MODE_MASK	0x00100000
+#define SAR1_CPU_MODE_OFFSET	20
+#define SAR1_FABRIC_MODE_MASK	0x00080000
+#define SAR1_FABRIC_MODE_OFFSET	19
+
+#define SAR_CPU_FAB_GET(cpu, fab)	(((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+#ifdef MV88F78X60_Z1
+#define BIOS_MODES_NUM			7
+#else
+#define BIOS_MODES_NUM			6
+#endif
+
+
+typedef struct {
+	char *name;
+	MV_U16 confId;
+	MV_U16 code;
+	MV_U8 l2size;
+	MV_U8 cpuFreq;
+	MV_U8 cpuFreqMode;
+	MV_U8 fabricFreq;
+	MV_U8 AltfabricFreq;
+	MV_U8 fabricFreqMode;
+	MV_U8 cpuEna;
+#ifdef MV88F78X60_Z1
+	MV_U8 cpuMode;
+#else
+	MV_U8 cpuEndianess;
+#endif
+	MV_U8 dramBusWidth;
+	MV_U8 bootSource;
+	MV_U8 bootWidth;
+} MV_BIOS_MODE;
+
+extern MV_BIOS_MODE bios_modes[];
+
+/* mcspLib.h API list */
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_U32 mvCtrlGetQuadNum(MV_VOID);
+MV_STATUS mvCtrlUpdatePexId(MV_VOID);
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32	mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32	mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPexMaxIfGet()	(0)
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+MV_U32	mvCtrlPciMaxIfGet(MV_VOID);
+#else
+#define mvCtrlPciIfMaxIfGet()	(mvCtrlPexMaxIfGet())
+#endif
+
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+MV_U8	  mvCtrlEthMaxCPUsGet(MV_VOID);
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+MV_U32	  mvCtrlNandSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32	  mvCtrlSdioSupport(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+MV_U32	  mvCtrlTdmMaxGet(MV_VOID);
+MV_UNIT_ID mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32    mvCtrlTdmUnitIrqGet(MV_VOID);
+#endif
+
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID   mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32	  ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32	  ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32	  ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32	  mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+
+MV_VOID   mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_VOID   mvCtrlPwrMemSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL	  mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_BOOL	  mvCtrlPwrMemGet(MV_UNIT_ID unitId, MV_U32 index);
+
+MV_U32 mvCtrlSerdesMaxLinesGet(MV_VOID);
+MV_STATUS mvCtrlSerdesPhyConfig(MV_VOID);
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100644
index 0000000..cdf83ec
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,589 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0 	PEX0_MEM
+#define PCI0_MEM0	PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID		0x008
+#define PCCRIR_REVID_OFFS			0		/* Revision ID */
+#define PCCRIR_REVID_MASK			(0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM				56
+
+
+/* Coherent Fabric Control and Status */
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/* PMU_NFABRIC PMU_NFABRIC PMU_UNIT_SERVICE Units */
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_REG		(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x4)
+#define MV_L2C_NFABRIC_PM_CTRL_CFG_PWR_DOWN	(1 << 20)
+
+#define MV_L2C_NFABRIC_PWR_DOWN_FLOW_CTRL_REG	(MV_PMU_NFABRIC_UNIT_SERV_OFFSET + 0x8)
+
+#define PM_CONTROL_AND_CONFIG_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x4)
+#define PM_CONTROL_AND_CONFIG_DFS_REQ		(1 << 18)
+#define PM_CONTROL_AND_CONFIG_PWDDN_REQ		(1 << 16)
+#define PM_CONTROL_AND_CONFIG_L2_PWDDN		(1 << 20)
+
+#define PM_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0xc)
+#define PM_STATUS_AND_MASK_CPU_IDLE_WAIT	(1 << 16)
+#define PM_STATUS_AND_MASK_SNP_Q_EMPTY_WAIT	(1 << 17)
+#define PM_STATUS_AND_MASK_IRQ_WAKEUP		(1 << 20)
+#define PM_STATUS_AND_MASK_FIQ_WAKEUP		(1 << 21)
+#define PM_STATUS_AND_MASK_DBG_WAKEUP		(1 << 22)
+#define PM_STATUS_AND_MASK_IRQ_MASK		(1 << 24)
+#define PM_STATUS_AND_MASK_FIQ_MASK		(1 << 25)
+
+#define PM_EVENT_STATUS_AND_MASK_REG(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x20)
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_OFFS			1
+#define PM_EVENT_STATUS_AND_MASK_DFS_DONE_MASK_OFFS		17
+
+#define PM_CPU_BOOT_ADDR_REDIRECT(cpu)		(MV_CPU_PMU_UNIT_SERV_OFFSET(cpu) + 0x24)
+
+/* Power Management Memory Power Down Registers 1 - 6 */
+#define POWER_MNG_MEM_CTRL_REG(num)		((num) < 6 ? 0x1820C + (num) * 4 : 0x18228)
+#define PMC_MCR_NUM_COMM			6
+#define PMC_MCR_NUM_PEX				2
+#define PMC_MCR_NUM_USB				4
+#define PMC_MCR_NUM_DUNIT			3
+#define PMC_MCR_NUM_DEVB			4
+#define PMC_MCR_NUM_NF				4
+#define PMC_MCR_NUM_XOR				4
+#define PMC_MCR_NUM_SATA			5
+#define PMC_MCR_NUM_CESA			4
+#define PMC_MCR_NUM_GE				5
+#define PMC_MCR_NUM_PNC				5
+#define PMC_MCR_NUM_BM				5
+#define PMC_MCR_NUM_PDMA			1
+#define PMC_MCR_NUM_NCS				3
+#define PMC_MCR_NUM_CFU				3
+#define PMC_MCR_NUM_L2				3
+#define PMC_MCR_NUM_CIB				3
+#define PMC_MCR_NUM_CPU				3
+#define PMC_MCR_NUM_IDMA			4
+#define PMC_MCR_NUM_LCD				4
+#define PMC_MCR_NUM_PMU				6
+
+#define PMC_COMMSTOPMEM_OFFS			4
+#define PMC_COMMSTOPMEM_MASK			(7 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_EN			(0 << PMC_COMMSTOPMEM_OFFS)
+#define PMC_COMMSTOPMEM_STOP			(1 << PMC_COMMSTOPMEM_OFFS)
+
+#define PMC_PEXSTOPMEM_OFFS(port)		((port) < 10 ? ((port) * 3) : 0)
+#define PMC_PEXSTOPMEM_MASK(port)		(7 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_EN(port)			(0 << PMC_PEXSTOPMEM_OFFS(port))
+#define PMC_PEXSTOPMEM_STOP(port)		(1 << PMC_PEXSTOPMEM_OFFS(port))
+
+#define PMC_USBSTOPMEM_OFFS(port)		((port) < 3 ? (3 + (port) * 3) : 0)
+#define PMC_USBSTOPMEM_MASK(port)		(7 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_EN(port)			(0 << PMC_USBSTOPMEM_OFFS(port))
+#define PMC_USBSTOPMEM_STOP(port)		(1 << PMC_USBSTOPMEM_OFFS(port))
+
+#define PMC_DUNITSTOPMEM_OFFS			12
+#define PMC_DUNITSTOPMEM_MASK			(7 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_EN			(0 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_STOP			(1 << PMC_DUNITSTOPMEM_OFFS)
+
+#define PMC_NFSTOPMEM_OFFS			27
+#define PMC_NFSTOPMEM_MASK			(7 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_EN			(0 << PMC_NFSTOPMEM_OFFS)
+#define PMC_NFSTOPMEM_STOP			(1 << PMC_NFSTOPMEM_OFFS)
+
+#define PMC_DEVBSTOPMEM_OFFS			21
+#define PMC_DEVBSTOPMEM_MASK			(7 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_EN			(0 << PMC_DEVBSTOPMEM_OFFS)
+#define PMC_DEVBSTOPMEM_STOP			(1 << PMC_DEVBSTOPMEM_OFFS)
+
+#define PMC_XORSTOPMEM_OFFS(port)		((port) == 0 ? 15 : 24)
+#define PMC_XORSTOPMEM_MASK(port)		(7 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_EN(port)			(0 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_STOP(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+
+#define PMC_SATASTOPMEM_OFFS(port)		((port) == 0 ? 18 : 24)
+#define PMC_SATASTOPMEM_MASK(port)		(0x3F << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_EN(port)		(0 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_STOP(port)		(9 << PMC_SATASTOPMEM_OFFS(port))
+
+#define PMC_CESASTOPMEM_OFFS			18
+#define PMC_CESASTOPMEM_MASK			(7 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_EN			(0 << PMC_CESASTOPMEM_OFFS)
+#define PMC_CESASTOPMEM_STOP			(1 << PMC_CESASTOPMEM_OFFS)
+
+#define PMC_GESTOPMEM_OFFS(port)		((port) < 4 ? (9 - (port) * 3) : 0)
+#define PMC_GESTOPMEM_MASK(port)		(7 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_EN(port)			(0 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_STOP(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+
+#define PMC_PNCSTOPMEM_OFFS			12
+#define PMC_PNCSTOPMEM_MASK			(7 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_EN			(0 << PMC_PNCSTOPMEM_OFFS)
+#define PMC_PNCSTOPMEM_STOP			(1 << PMC_PNCSTOPMEM_OFFS)
+
+#define PMC_BMSTOPMEM_OFFS			15
+#define PMC_BMSTOPMEM_MASK			(7 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_EN			(0 << PMC_BMSTOPMEM_OFFS)
+#define PMC_BMSTOPMEM_STOP			(1 << PMC_BMSTOPMEM_OFFS)
+
+#define PMC_PDMASTOPMEM_OFFS			0
+#define PMC_PDMATOPMEM_MASK			(7 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_EN			(0 << PMC_PDMASTOPMEM_OFFS)
+#define PMC_PDMASTOPMEM_STOP			(1 << PMC_PDMASTOPMEM_OFFS)
+
+#define PMC_NCSSTOPMEM_OFFS			24
+#define PMC_NCSSTOPMEM_MASK			(7 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_EN			(0 << PMC_NCSSTOPMEM_OFFS)
+#define PMC_NCSSTOPMEM_STOP			(1 << PMC_NCSSTOPMEM_OFFS)
+
+#define PMC_CFUSTOPMEM_OFFS			21
+#define PMC_CFUSTOPMEM_MASK			(7 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_EN			(0 << PMC_CFUSTOPMEM_OFFS)
+#define PMC_CFUSTOPMEM_STOP			(1 << PMC_CFUSTOPMEM_OFFS)
+
+#define PMC_L2STOPMEM_OFFS			18
+#define PMC_L2STOPMEM_MASK			(7 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_EN			(0 << PMC_L2STOPMEM_OFFS)
+#define PMC_L2STOPMEM_STOP			(1 << PMC_L2STOPMEM_OFFS)
+
+#define PMC_CIBSTOPMEM_OFFS			15
+#define PMC_CIBSTOPMEM_MASK			(7 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_EN			(0 << PMC_CIBSTOPMEM_OFFS)
+#define PMC_CIBSTOPMEM_STOP			(1 << PMC_CIBSTOPMEM_OFFS)
+
+/* TODO - verify, the manual has no description */
+#define PMC_CPUSTOPMEM_OFFS(id)			((id) < 4 ? (id) * 3 : 0)
+#define PMC_CPUSTOPMEM_MASK(id)			(7 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_EN(id)			(0 << PMC_CPUSTOPMEM_OFFS(id))
+#define PMC_CPUSTOPMEM_STOP(id)			(1 << PMC_CPUSTOPMEM_OFFS(id))
+
+#define PMC_IDMASTOPMEM_OFFS			12
+#define PMC_IDMASTOPMEM_MASK			(7 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_EN			(0 << PMC_IDMASTOPMEM_OFFS)
+#define PMC_IDMASTOPMEM_STOP			(1 << PMC_IDMASTOPMEM_OFFS)
+
+#define PMC_LCDSTOPMEM_OFFS			0
+#define PMC_LCDSTOPMEM_MASK			(7 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_EN			(0 << PMC_LCDSTOPMEM_OFFS)
+#define PMC_LCDSTOPMEM_STOP			(1 << PMC_LCDSTOPMEM_OFFS)
+
+#define PMC_PMUSTOPMEM_OFFS			0
+#define PMC_PMUSTOPMEM_MASK			(7 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_EN			(0 << PMC_PMUSTOPMEM_OFFS)
+#define PMC_PMUSTOPMEM_STOP			(1 << PMC_PMUSTOPMEM_OFFS)
+
+
+/*  Power Management Clock Gating Control Register	*/
+#define POWER_MNG_CTRL_REG			0x18220
+#define L2C_MTCMOS_CONTROL_0_REG    0x22F00
+#define L2C_MTCMOS_CONTROL_1_REG    0x22F04
+
+#define PMU_DFS_CTRL_REG(cpu)			(MV_RUNIT_PMU_REGS_OFFSET + 0x54 + ((cpu) * 0x4))
+#define PMU_DFS_CTRL_INIT_RATIO_OFFS	24
+#define PMU_DFS_CTRL_INIT_RATIO_MASK	0x3F
+#define PMU_DFS_CTRL_RATIO_OFFS			16
+#define PMU_DFS_CTRL_RATIO_MASK			0x3F
+
+#define PMC_TDMSTOPCLOCK_OFFS			25
+#define PMC_TDMSTOPCLOCK_MASK			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_EN			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_STOP			(0 << PMC_TDMSTOPCLOCK_OFFS)
+
+#define PMC_PEXSTOPCLOCK_OFFS(port)		((port) < 8 ? (5 + (port)) : (18 + (port)))
+#define PMC_PEXSTOPCLOCK_MASK(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_EN(port)		(1 << PMC_PEXSTOPCLOCK_OFFS(port))
+#define PMC_PEXSTOPCLOCK_STOP(port)		(0 << PMC_PEXSTOPCLOCK_OFFS(port))
+
+#define PMC_USBSTOPCLOCK_OFFS(port)		((port) < 3 ? (18 + (port)) : 0)
+#define PMC_USBSTOPCLOCK_MASK(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_EN(port)		(1 << PMC_USBSTOPCLOCK_OFFS(port))
+#define PMC_USBSTOPCLOCK_STOP(port)		(0 << PMC_USBSTOPCLOCK_OFFS(port))
+
+#define PMC_SDIOSTOPCLOCK_OFFS			17
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_RUNITSTOPCLOCK_OFFS			24
+#define PMC_RUNITSTOPCLOCK_MASK			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_EN			(1 << PMC_RUNITSTOPCLOCK_OFFS)
+#define PMC_RUNITSTOPCLOCK_STOP			(0 << PMC_RUNITSTOPCLOCK_OFFS)
+
+#define PMC_XORSTOPCLOCK_OFFS			22
+#define PMC_XORSTOPCLOCK_MASK			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_EN			(1 << PMC_XORSTOPCLOCK_OFFS)
+#define PMC_XORSTOPCLOCK_STOP			(0 << PMC_XORSTOPCLOCK_OFFS)
+
+#define PMC_SATASTOPCLOCK_OFFS(ch)		(ch == 0 ? 14 : 29)
+#define PMC_SATASTOPCLOCK_MASK(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_EN(ch)		(3 << PMC_SATASTOPCLOCK_OFFS(ch))
+#define PMC_SATASTOPCLOCK_STOP(ch)		(0 << PMC_SATASTOPCLOCK_OFFS(ch))
+
+#define PMC_CESASTOPCLOCK_OFFS			23
+#define PMC_CESASTOPCLOCK_MASK			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_EN			(1 << PMC_CESASTOPCLOCK_OFFS)
+#define PMC_CESASTOPCLOCK_STOP			(0 << PMC_CESASTOPCLOCK_OFFS)
+
+#define PMC_GESTOPCLOCK_OFFS(port)		((port) < 4 ? (4 - (port)) : 0)
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+#define PMC_NETASTOPCLOCK_OFFS			13
+#define PMC_NETASTOPCLOCK_MASK			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_EN			(1 << PMC_NETASTOPCLOCK_OFFS)
+#define PMC_NETASTOPCLOCK_STOP			(0 << PMC_NETASTOPCLOCK_OFFS)
+
+#define PMC_LCDSTOPCLOCK_OFFS			16
+#define PMC_LCDSTOPCLOCK_MASK			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_EN			(1 << PMC_LCDSTOPCLOCK_OFFS)
+#define PMC_LCDSTOPCLOCK_STOP			(0 << PMC_LCDSTOPCLOCK_OFFS)
+
+#define PMC_IDMASTOPCLOCK_OFFS			21
+#define PMC_IDMASTOPCLOCK_MASK			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_EN			(1 << PMC_IDMASTOPCLOCK_OFFS)
+#define PMC_IDMASTOPCLOCK_STOP			(0 << PMC_IDMASTOPCLOCK_OFFS)
+
+#define PMC_DDRSTOPCLOCK_OFFS			28
+#define PMC_DDRSTOPCLOCK_MASK			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_EN			(1 << PMC_DDRSTOPCLOCK_OFFS)
+#define PMC_DDRSTOPCLOCK_STOP			(0 << PMC_DDRSTOPCLOCK_OFFS)
+
+#define SATA_IMP_TX_SSC_CTRL_REG(port)		(0xA2810 + (port)*0x2000)
+#define SATA_GEN_1_SET_0_REG(port)			(0xA2834 + (port)*0x2000)
+#define SATA_GEN_1_SET_1_REG(port)			(0xA2838 + (port)*0x2000)
+#define SATA_GEN_2_SET_0_REG(port)			(0xA283C + (port)*0x2000)
+#define SATA_GEN_2_SET_1_REG(port)			(0xA2840 + (port)*0x2000)
+
+#define SATA_PWR_PLL_CTRL_REG(port)			(0xA2804 + (port)*0x2000)
+#define SATA_DIG_LP_ENA_REG(port)			(0xA288C + (port)*0x2000)
+#define SATA_REF_CLK_SEL_REG(port)			(0xA2918 + (port)*0x2000)
+#define SATA_COMPHY_CTRL_REG(port)			(0xA2920 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_CTRL_REG(port)		(0xA2058 + (port)*0x2000)
+#define SATA_LP_PHY_EXT_STAT_REG(port)		(0xA205C + (port)*0x2000)
+
+#define SGMII_PWR_PLL_CTRL_REG(port)		(0x72E04 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_DIG_LP_ENA_REG(port)		(0x72E8C + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_REF_CLK_SEL_REG(port)		(0x72F18 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_CFG_REG(port)		(0x724A0 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_SERDES_STAT_REG(port)		(0x724A4 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define SGMII_COMPHY_CTRL_REG(port)		(0x72F20 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+#define QSGMII_GEN_1_SETTING_REG(port)		(0x72E38 + ((port)%2)*0x4000 - ((port)/2)*0x40000)
+
+#define SERDES_LINE_MUX_REG_0_7			0x18270
+#define SERDES_LINE_MUX_REG_8_15		0x18274
+#define QSGMII_CONTROL_1_REG                    0x18404
+/* Controler environment registers offsets */
+#define GEN_PURP_RES_1_REG			0x182F4
+#define GEN_PURP_RES_2_REG			0x182F8
+
+#define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
+
+/* Sample at Reset */
+#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
+
+/* SYSRSTn Length Counter */
+#define SYSRST_LENGTH_COUNTER_REG		0x18250
+#define SLCR_COUNT_OFFS				0
+#define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS				31
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
+
+/* Device ID */
+#define CHIP_BOND_REG				0x18238
+#define PCKG_OPT_MASK				0x3
+
+#define MPP_OUTPUT_DRIVE_REG			0x184E4
+#define MPP_GE_A_OUTPUT_DRIVE_OFFS		6
+#define MPP_GE_A_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_A_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_A_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_OUTPUT_DRIVE_OFFS		14
+#define MPP_GE_B_1_8_OUTPUT_DRIVE		(0x1 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+#define MPP_GE_B_2_5_OUTPUT_DRIVE		(0x2 << MPP_GE_B_OUTPUT_DRIVE_OFFS)
+
+#define MSAR_BOOT_MODE_OFFS			5
+#define MSAR_BOOT_MODE_MASK			(0xF << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_NOR				(0x0 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI				(0x3 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_DOVE_NAND			(0x1 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_LEGACY_NAND			(0x6 << MSAR_BOOT_MODE_OFFS)
+
+#define MSAR_TCLK_OFFS				28
+#define MSAR_TCLK_MASK				(0x1 << MSAR_TCLK_OFFS)
+
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG				0x1864C
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+#define MSAR_CPU_CLK_IDX(sar0, sar1)		((((sar0) >> 21) & 0x7) + ((((sar1) >> 20) & 1) << 3))
+#define MSAR_CPU_CLK_TWSI(sar0, sar1)		((((sar0) >> 2)  & 0x7) + (((sar1) & 1) << 3))
+#define MSAR_DDR_L2_CLK_RATIO_IDX(sar0, sar1)	((((sar0) >> 24) & 0xF) + ((((sar1) >> 19) & 1) << 4))
+#define MSAR_DDR_L2_CLK_RATIO_TWSI(sar0)	(((sar0) >> 1)  & 0xF)
+
+#ifndef MV_ASMLANGUAGE
+
+#define MV_CPU_CLK_TBL { 1000, 1066, 1200, 1333, 1500, 1666, 1800, 2000,\
+			  600,  667,  800, 1600, 2133, 2200, 2400, 0 }
+
+/*		cpu	l2c	hclk	ddr	*/
+#define MV_DDR_L2_CLK_RATIO_TBL    { \
+/*00*/	{	1,	1,	4,	2	},\
+/*01*/	{	1,	2,	2,	2	},\
+/*02*/	{	2,	2,	6,	3	},\
+/*03*/	{	2,	2,	3,	3	},\
+/*04*/	{	1,	2,	3,	3	},\
+/*05*/	{	1,	2,	4,	2	},\
+/*06*/	{	1,	1,	2,	2	},\
+/*07*/	{	2,	3,	6,	6	},\
+/*08*/	{	2,	3,	5,	5	},\
+/*09*/	{	1,	2,	6,	3	},\
+/*10*/	{	2,	4,	10,	5	},\
+/*11*/	{	1,	3,	6,	6	},\
+/*12*/	{	1,	2,	4,	4	},\
+/*13*/	{	1,	3,	6,	3	},\
+/*14*/	{	1,	2,	5,	5	},\
+/*15*/	{	2,	2,	5,	5	},\
+/*16*/	{	1,	1,	3,	3	},\
+/*17*/	{	2,	5,	10,	10	},\
+/*18*/	{	1,	3,	8,	4	},\
+/*19*/	{	1,	1,	2,	1	},\
+/*20*/	{	2,	3,	6,	3	},\
+/*21*/	{	1,	2,	8,	4	},\
+/*22*/	{	2,	5,	10,	5	} \
+}
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+		((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+		((target >= PEX0_MEM) && (target <= PEX0_IO))
+#define MV_TARGET_IS_PEX1(target)   \
+		((target >= PEX1_MEM) && (target <= PEX1_IO))
+#define MV_TARGET_IS_PEX2(target)   \
+		((target >= PEX2_MEM) && (target <= PEX2_IO))
+#define MV_TARGET_IS_PEX3(target)   \
+		((target >= PEX3_MEM) && (target <= PEX3_IO))
+#define MV_TARGET_IS_PEX4(target)   \
+		((target >= PEX4_MEM) && (target <= PEX4_IO))
+#define MV_TARGET_IS_PEX5(target)   \
+		((target >= PEX5_MEM) && (target <= PEX5_IO))
+#define MV_TARGET_IS_PEX6(target)   \
+		((target >= PEX6_MEM) && (target <= PEX6_IO))
+#define MV_TARGET_IS_PEX7(target)   \
+		((target >= PEX7_MEM) && (target <= PEX7_IO))
+#define MV_TARGET_IS_PEX8(target)   \
+		((target >= PEX8_MEM) && (target <= PEX8_IO))
+#define MV_TARGET_IS_PEX9(target)   \
+		((target >= PEX9_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_PEX(target)	((target >= PEX0_MEM) && (target <= PEX9_IO))
+
+#define MV_TARGET_IS_DEVICE(target)	((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_PCI_DRAM_BAR_TO_DRAM_TARGET(bar)   0
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define TCLK_TO_COUNTER_RATIO   1   /* counters running in Tclk */
+
+
+#define BOOT_TARGETS_NAME_ARRAY {	\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	BOOT_ROM_CS,			\
+	TBL_TERM, 			\
+	TBL_TERM, 			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	TBL_TERM,			\
+	BOOT_ROM_CS			\
+}
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0		PEX0_MEM
+#define PCI_IF0_IO		PEX0_IO
+
+/* This enumerator defines the Marvell controller target ID  (see Address map) */
+typedef enum _mvTargetId {
+    DRAM_TARGET_ID	= 0,	/* Port 0 -> DRAM interface		*/
+    DEV_TARGET_ID	= 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+    PEX0_2_TARGET_ID	= 4,	/* Port 4 -> PCI Express 0 and 2	*/
+    PEX1_3_TARGET_ID	= 8,	/* Port 4 -> PCI Express 1 and 3	*/
+    CRYPT_TARGET_ID	= 9,	/* Port 9 --> Crypto Engine SRAM	*/
+    PNC_BM_TARGET_ID	= 12,  	/* Port 12 -> PNC + BM Unit		*/
+    MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+/*
+typedef enum {
+	SERDES_UNIT_UNCONNECTED	= 0x0,
+	SERDES_UNIT_PEX		= 0x1,
+	SERDES_UNIT_SATA	= 0x2,
+	SERDES_UNIT_SGMII0	= 0x3,
+	SERDES_UNIT_SGMII1	= 0x4,
+	SERDES_UNIT_SGMII2	= 0x5,
+	SERDES_UNIT_SGMII3	= 0x6,
+	SERDES_UNIT_QSGMII	= 0x7
+} MV_SERDES_UNIT_INDX;
+*/
+
+/*
+	This structure refrect registers:
+	Serdes 0-7 selectors		0x18270
+	and Serdes 8-15 selectors  	0x18274
+*/
+#ifndef MV88F78X60_Z1
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1,  3}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1,  2 ,  4, -1,  3, -1, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 8 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+
+#else
+#define SERDES_CFG {	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 0 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 1 */	\
+	{0, 1, -1 ,  2, -1, -1, -1, -1}, /* Lane 2 */	\
+	{0, 1, -1 , -1,  2, -1, -1, -1}, /* Lane 3 */	\
+	{0, 1,  2 , -1, -1,  3, -1, -1}, /* Lane 4 */	\
+	{0, 1,  2 , -1,  3, -1, -1,  4}, /* Lane 5 */	\
+	{0, 1, -1 , -1, -1,  2,  3, -1}, /* Lane 6 */	\
+	{0, 1, -1 ,  2, -1, -1,  3, -1}, /* Lane 7*/	\
+	{0, 1,  2 , -1, -1, -1,  3,  4}, /* Lane 8 */	\
+	{0, 1,  2 ,  3, -1, -1, -1, -1}, /* Lane 9 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 10 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 11 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 12 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 13 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}, /* Lane 14 */	\
+	{0, 1, -1 , -1, -1, -1, -1, -1}	 /* Lane 15 */	\
+}
+#endif
+
+/*
+	This enum should reflect the units numbers in register
+	space which we will need when accessing the HW
+*/
+
+typedef enum {
+	PEX0_0x4	= 0,
+	PEX0_1x4	= 1,
+	PEX0_2x4	= 2,
+	PEX0_3x4	= 3,
+	PEX1_0x4	= 4,
+	PEX1_1x4	= 5,
+	PEX1_2x4	= 6,
+	PEX1_3x4	= 7,
+	PEX2_0x4	= 8,
+	PEX3_0x4	= 9,
+	PEXIF_MAX	= 10
+} MV_PEXIF_INDX;
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100644
index 0000000..eae4081
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,493 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX				"MV88F"
+
+/*
+ * Armada-XP Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET			(0x0)
+#define MV_AURORA_L2_REGS_OFFSET		(0x8000)
+#define MV_RTC_REGS_OFFSET			(0x10300)
+#define MV_DEV_BUS_REGS_OFFSET			(0x10400)
+#ifdef MV88F78X60_Z1
+#define MV_SPI_REGS_OFFSET(unit)               (0x10600)
+#else
+#define MV_SPI_REGS_OFFSET(unit)		(0x10600 + (unit * 0x80))
+#endif
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)	(0x11000 + (chanNum * 0x100))
+#define MV_UART_REGS_OFFSET(chanNum)		(0x12000 + (chanNum * 0x100))
+#define MV_RUNIT_PMU_REGS_OFFSET		(0x1C000)
+#define MV_MPP_REGS_OFFSET			(0x18000)
+#ifdef MV88F78X60_Z1
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x20))
+#else
+#define MV_GPP_REGS_OFFSET(unit)		(0x18100 + ((unit) * 0x40))
+#endif
+#define MV_MISC_REGS_OFFSET			(0x18200)
+#define MV_CLK_CMPLX_REGS_OFFSET	(0x18700)
+#define MV_MBUS_REGS_OFFSET			(0x20000)
+#define MV_COHERENCY_FABRIC_OFFSET		(0x20200)
+#define MV_CIB_CTRL_STATUS_OFFSET		(0x20280)
+#define MV_CNTMR_REGS_OFFSET			(0x20300)
+#define MV_CPUIF_LOCAL_REGS_OFFSET		(0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)		(0x21800 + (cpu) * 0x100)
+#define MV_PMU_NFABRIC_UNIT_SERV_OFFSET		(0x22000)
+#define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
+#define MV_CPU_HW_SEM_OFFSET			(0x20500)
+
+#if defined(MV_ETH_LEGACY)
+	#define MV_ETH_BASE_ADDR		(0x72000)
+#else
+	#define MV_ETH_BASE_ADDR		(0x70000)
+#endif
+#define MV_ETH_REGS_OFFSET(port)		(MV_ETH_BASE_ADDR - ((port) / 2) * 0x40000 + ((port) % 2) * 0x4000)
+#define MV_PEX_IF_REGS_OFFSET(pexIf)		(pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000)\
+							   : (0X42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)       		(0x50000 + (dev * 0x1000))
+#define MV_XOR_REGS_OFFSET(unit)		(unit ? 0xF0900 : 0x60900)
+#define MV_CESA_TDMA_REGS_OFFSET(chanNum)	(0x90000 + (chanNum * 0x2000))
+#define MV_CESA_REGS_OFFSET(chanNum)		(0x9D000 + (chanNum * 0x2000))
+#define MV_SATA_REGS_OFFSET			(0xA0000)
+#define MV_COMM_UNIT_REGS_OFFSET		(0xB0000)
+#define MV_NFC_REGS_OFFSET			(0xD0000)
+#define MV_BM_REGS_OFFSET			(0xC0000)
+#define MV_PNC_REGS_OFFSET			(0xC8000)
+#define MV_SDMMC_REGS_OFFSET			(0xD4000)
+
+#ifdef ARMADA_XP_ERRATA_SMI_1
+#define MV_ETH_SMI_PORT   1
+#else
+#define MV_ETH_SMI_PORT   0
+#endif
+
+#define MV_SERDES_NUM_TO_PEX_NUM(sernum)	((sernum < 8) ? (sernum) : (8 + (sernum/12)))
+/*
+ * Miscellanuous Controller Configurations
+ */
+#define INTER_REGS_SIZE				_1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)	CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)		((ch) + 3)
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS				68
+#define MV_GPP_MAX_GROUP    			3 /* group == configuration register? */
+#ifndef MV88F78X60_Z1
+#define MV_CNTMR_MAX_COUNTER 		8 /* 4 global + 1 global WD + 2 current private CPU + 1 private CPU WD*/
+#else
+#define MV_CNTMR_MAX_COUNTER 		17/* 4 global + 1 global WD + 2 per CPU + 4 CPU WD*/
+#endif
+/*
+	MV88F78X60_Z1								MV88F78X60_A0
+	-------------------------------             -------------------------------
+	Global Counters 0-3  : 0-3         		    Global Counters 0-3  		: 0-3
+	Global WD            : 4                    Global WD            		: 4
+
+	CPU 0 Counter 0-1    : 5-6					Private CPU Counter 0-1    : 5-6
+	CPU 0 WD             : 7                    Private CPU WD             : 7
+	CPU 1 Counter 0-1    : 8-9
+	CPU 1 WD             : 10
+	CPU 2 Counter 0-1    : 11-12
+	CPU 2 WD             : 13
+	CPU 3 Counter 0-1    : 14-15
+	CPU 3 WD             : 16
+*/
+
+#define MV_UART_MAX_CHAN			4
+
+#define MV_XOR_MAX_UNIT				2 /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN         		4 /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT		2 /* channels for units */
+
+#define MV_SATA_MAX_CHAN			2
+
+#define MV_MPP_MAX_GROUP			9
+
+#define MV_DRAM_MAX_CS				4
+#define MV_SPI_MAX_CS				8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+ #define MV_PCI_MAX_IF				1
+ #define MV_PCI_START_IF			0
+ #define PCI_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PCI_HOST_DEV_NUM(pciIf)               0
+#else
+ #define MV_PCI_MAX_IF				0
+ #define MV_PCI_START_IF			0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF				10
+#define MV_PEX_MAX_UNIT				4
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF				MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)				(PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)			(PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces 	*/
+#define MV_IDMA_MAX_CHAN			4
+#define ARMADA_XP_MAX_USB_PORTS			3
+#define ARMADA_XP_NAND				1
+#define ARMADA_XP_SDIO				1
+#define ARMADA_XP_MAX_TDM_PORTS			32
+#define ARMADA_XP_TDM				1
+#define MV_DEVICE_MAX_CS      			4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS (ARMADA_XP_MAX_USB_PORTS)
+#endif
+
+
+/* CESA version #3: One channel, 2KB SRAM, TDMA, CHAIN Mode support */
+#define MV_CESA_VERSION				3 /*TODO verify */
+#define MV_CESA_SRAM_SIZE               	(2 * 1024)
+
+
+/* This define describes the maximum number of supported Ethernet ports */
+/* TODO - verify all these numbers */
+#define MV_ETH_VERSION 				4 /* for Legacy mode */
+#define MV_NETA_VERSION				1 /* for NETA mode */
+#define MV_ETH_MAX_PORTS			4
+#define MV_ETH_MAX_RXQ              		8
+#define MV_ETH_MAX_TXQ              		8
+#define MV_ETH_TX_CSUM_MAX_SIZE 		9800
+#define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
+
+#if defined(MV88F78X60_A0) || defined(MV88F78X60_B0)
+/* New GMAC module is used */
+#define MV_ETH_GMAC_NEW
+/* New WRR/EJP module is used */
+#define MV_ETH_WRR_NEW
+/* IPv6 parsing support for Legacy parser */
+#define MV_ETH_LEGACY_PARSER_IPV6
+/* New PNC module - extra fields */
+#define MV_ETH_PNC_NEW
+/* PNC Load Balancing support */
+#define MV_ETH_PNC_LB
+#endif /* MV88F78X60_A0, MV88F78X60_B0*/
+#define MV_78130_ETH_MAX_PORT			3
+#define MV_78460_ETH_MAX_PORT			4
+
+/* This define describes the the support of USB */
+#define MV_USB_VERSION  			1
+
+#define MV_SPI_VERSION				2
+
+#define MV_INCLUDE_SDRAM_CS0
+#define MV_INCLUDE_SDRAM_CS1
+#define MV_INCLUDE_SDRAM_CS2
+#define MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED	0	/* Used to mark unused entry */
+
+typedef enum {
+	TDM_UNIT_32CH
+} MV_TDM_UNIT_TYPE;
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_32CH_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	SDIO_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,        /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*0 SDRAM chip select 0		*/
+	SDRAM_CS1,	/*1 SDRAM chip select 1		*/
+	SDRAM_CS2,	/*2 SDRAM chip select 2		*/
+	SDRAM_CS3,	/*3 SDRAM chip select 3		*/
+	DEVICE_CS0,	/*4 Device chip select 0		*/
+	DEVICE_CS1,	/*5 Device chip select 1		*/
+	DEVICE_CS2,	/*6 Device chip select 2		*/
+	DEVICE_CS3,	/*7 Device chip select 3		*/
+	PEX0_MEM,	/*8 PCI Express 0 Memory		*/
+	PEX0_IO,	/*9 PCI Express 0 IO		*/
+	PEX1_MEM,	/*10 PCI Express 1 Memory		*/
+	PEX1_IO,	/*11 PCI Express 1 IO		*/
+	PEX2_MEM,	/*12 PCI Express 2 Memory		*/
+	PEX2_IO,	/*13 PCI Express 2 IO		*/
+	PEX3_MEM,	/*14 PCI Express 3 Memory		*/
+	PEX3_IO,	/*15 PCI Express 3 IO		*/
+	PEX4_MEM,	/*16 PCI Express 4 Memory		*/
+	PEX4_IO,	/*17 PCI Express 4 IO		*/
+	PEX5_MEM,	/*18 PCI Express 5 Memory		*/
+	PEX5_IO,	/*19 PCI Express 5 IO		*/
+	PEX6_MEM,	/*20 PCI Express 6 Memory		*/
+	PEX6_IO,	/*21 PCI Express 6 IO		*/
+	PEX7_MEM,	/*22 PCI Express 7 Memory		*/
+	PEX7_IO,	/*23 PCI Express 7 IO		*/
+	PEX8_MEM,	/*24 PCI Express 8 Memory		*/
+	PEX8_IO,	/*25 PCI Express 8 IO		*/
+	PEX9_MEM,	/*26 PCI Express 9 Memory		*/
+	PEX9_IO,	/*27 PCI Express 9 IO		*/
+	INTER_REGS,	/*28 Internal registers		*/
+	DMA_UART,	/*29 DMA based UART request	*/
+	SPI_CS0,	/*30 SPI_CS0			*/
+	SPI_CS1,	/*31 SPI_CS1			*/
+	SPI_CS2,	/*32 SPI_CS2			*/
+	SPI_CS3,	/*33 SPI_CS3			*/
+	SPI_CS4,	/*34 SPI_CS4			*/
+	SPI_CS5,	/*35 SPI_CS5			*/
+	SPI_CS6,	/*36 SPI_CS6			*/
+	SPI_CS7,	/*37 SPI_CS7			*/
+	BOOT_ROM_CS, /*38 BOOT_ROM_CS			*/
+	DEV_BOOCS,	/*39 DEV_BOOCS			*/
+	PMU_SCRATCHPAD,	/*40 PMU Scratchpad		*/
+	CRYPT0_ENG,	/* 41 Crypto0 Engine		*/
+	CRYPT1_ENG,	/* 42 Crypto1 Engine		*/
+	PNC_BM,		/* 43 PNC + BM 		        */
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR		0x1E
+#define DRAM_CS1_ATTR		0x1D
+#define DRAM_CS2_ATTR		0x1B
+#define DRAM_CS3_ATTR		0x17
+#else
+#define DRAM_CS0_ATTR		0x0E
+#define DRAM_CS1_ATTR		0x0D
+#define DRAM_CS2_ATTR		0x0B
+#define DRAM_CS3_ATTR		0x07
+#endif
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define MAIN_BOOT_ATTR		0x2F	/* Boot Device CS - NOR */
+ #define SEC_BOOT_ATTR		0x1D	/* BootROM - Dummy */
+#else
+ #define MAIN_BOOT_ATTR		0x1D	/* BootROM */
+ #define SEC_BOOT_ATTR		0x2F	/* Boot Device CS */
+#endif
+
+#define TARGETS_DEF_ARRAY	{			\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID   }, /* SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID    }, /* DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID    }, /* DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID    }, /* DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID    }, /* DEVICE_CS3 */	\
+	{0xE8, PEX0_2_TARGET_ID }, /* PEX0_LANE0_MEM */	\
+	{0xE0, PEX0_2_TARGET_ID }, /* PEX0_LANE0_IO */	\
+	{0xD8, PEX0_2_TARGET_ID }, /* PEX0_LANE1_MEM */	\
+	{0xD0, PEX0_2_TARGET_ID }, /* PEX0_LANE1_IO */	\
+	{0xB8, PEX0_2_TARGET_ID }, /* PEX0_LANE2_MEM */	\
+	{0xB0, PEX0_2_TARGET_ID }, /* PEX0_LANE2_IO */	\
+	{0x78, PEX0_2_TARGET_ID }, /* PEX0_LANE3_MEM */	\
+	{0x70, PEX0_2_TARGET_ID }, /* PEX0_LANE3_IO */	\
+	{0xE8, PEX1_3_TARGET_ID }, /* PEX1_LANE0_MEM */	\
+	{0xE0, PEX1_3_TARGET_ID }, /* PEX1_LANE0_IO */	\
+	{0xD8, PEX1_3_TARGET_ID }, /* PEX1_LANE1_MEM */	\
+	{0xD0, PEX1_3_TARGET_ID }, /* PEX1_LANE1_IO */	\
+	{0xB8, PEX1_3_TARGET_ID }, /* PEX1_LANE2_MEM */	\
+	{0xB0, PEX1_3_TARGET_ID }, /* PEX1_LANE2_IO */	\
+	{0x78, PEX1_3_TARGET_ID }, /* PEX1_LANE3_MEM */	\
+	{0x70, PEX1_3_TARGET_ID }, /* PEX1_LANE3_IO */	\
+	{0xF8, PEX0_2_TARGET_ID }, /* PEX2_LANE0_MEM */	\
+	{0xF0, PEX0_2_TARGET_ID }, /* PEX2_LANE0_IO */	\
+	{0xF8, PEX1_3_TARGET_ID }, /* PEX3_LANE0_MEM */	\
+	{0xF0, PEX1_3_TARGET_ID }, /* PEX3_LANE0_IO */	\
+	{0xFF, 0xFF             }, /* INTER_REGS */	\
+	{0x01, DEV_TARGET_ID    }, /* DMA_UART */	\
+	{0x1E, DEV_TARGET_ID    }, /* SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID    }, /* SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID    }, /* SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID    }, /* SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID    }, /* SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID    }, /* SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID    }, /* SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID    }, /* SPI_CS7 */	\
+	{MAIN_BOOT_ATTR, DEV_TARGET_ID    }, /* Main Boot device */	\
+	{SEC_BOOT_ATTR, DEV_TARGET_ID    }, /* Secondary Boot device, */	\
+	{0x2D, DEV_TARGET_ID    }, /* PMU_SCRATCHPAD */	\
+	{0x01, CRYPT_TARGET_ID  }, /* CRYPT_ENG0 */	\
+	{0x05, CRYPT_TARGET_ID  }, /* CRYPT_ENG1 */     \
+	{0x00, PNC_BM_TARGET_ID }, /* PNC_BM */		\
+}
+
+#define CESA_TARGET_NAME_DEF	("CRYPT_ENG0", "CRYPT_ENG1")
+#define TARGETS_NAME_ARRAY	{		\
+	"SDRAM_CS0",    /* SDRAM_CS0 */		\
+	"SDRAM_CS1",    /* SDRAM_CS1 */		\
+	"SDRAM_CS2",    /* SDRAM_CS1 */		\
+	"SDRAM_CS3",    /* SDRAM_CS1 */		\
+	"DEVICE_CS0",	/* DEVICE_CS0 */	\
+	"DEVICE_CS1",	/* DEVICE_CS1 */	\
+	"DEVICE_CS2",	/* DEVICE_CS2 */	\
+	"DEVICE_CS3",	/* DEVICE_CS3 */	\
+	"PEX0_MEM",	/* PEX0_MEM */		\
+	"PEX0_IO",	/* PEX0_IO */		\
+	"PEX1_MEM",	/* PEX1_MEM */		\
+	"PEX1_IO",	/* PEX1_IO */		\
+	"PEX2_MEM",	/* PEX2_MEM */		\
+	"PEX2_IO",	/* PEX2_IO */		\
+	"PEX3_MEM",	/* PEX3_MEM */		\
+	"PEX3_IO",	/* PEX3_IO */		\
+	"PEX4_MEM",	/* PEX4_MEM */		\
+	"PEX4_IO",	/* PEX4_IO */		\
+	"PEX5_MEM",	/* PEX5_MEM */		\
+	"PEX5_IO",	/* PEX5_IO */		\
+	"PEX6_MEM",	/* PEX6_MEM */		\
+	"PEX6_IO",	/* PEX6_IO */		\
+	"PEX7_MEM",	/* PEX7_MEM */		\
+	"PEX7_IO",	/* PEX7_IO */		\
+	"PEX8_MEM",	/* PEX8_MEM */		\
+	"PEX8_IO",	/* PEX8_IO */		\
+	"PEX9_MEM",	/* PEX9_MEM */		\
+	"PEX9_IO",	/* PEX9_IO */		\
+	"INTER_REGS",	/* INTER_REGS */	\
+	"DMA_UART",	/* DMA_UART */		\
+	"SPI_CS0",	/* SPI_CS0 */		\
+	"SPI_CS1",	/* SPI_CS1 */		\
+	"SPI_CS2",	/* SPI_CS2 */		\
+	"SPI_CS3",	/* SPI_CS3 */		\
+	"SPI_CS4",	/* SPI_CS4 */		\
+	"SPI_CS5",	/* SPI_CS5 */		\
+	"SPI_CS6",	/* SPI_CS6 */		\
+	"SPI_CS7",	/* SPI_CS7 */		\
+	"BOOT_ROM_CS",	/* BOOT_ROM_CS */	\
+	"DEV_BOOTCS",	/* DEV_BOOCS */		\
+	"PMU_SCRATCHPAD",/* PMU_SCRATCHPAD */	\
+	"CRYPT1_ENG",	/* CRYPT1_ENG */	\
+	"CRYPT2_ENG",	/* CRYPT2_ENG */	\
+	"PNC_BM"	/* PNC_BM */		\
+}
+
+
+
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
new file mode 100644
index 0000000..d71df4e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.c
@@ -0,0 +1,124 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+
+MV_BOOL mvSemaLock(MV_32 num)
+{
+	MV_U32 tmp;
+	MV_U32 cpuId;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	cpuId = whoAmI();
+	do
+	{
+		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	} while ((tmp & 0xFF) != cpuId);
+	return MV_TRUE;
+}
+
+MV_BOOL mvSemaTryLock(MV_32 num)
+{
+	MV_U32 tmp;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	if ((tmp & 0xFF) != whoAmI())
+	{
+		return MV_FALSE;
+	}
+	else
+		return MV_TRUE;
+}
+
+MV_BOOL mvSemaUnlock(MV_32 num)
+{
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+	return MV_TRUE;
+}
+
+MV_32 mvReadAmpReg(int regId)
+{
+	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+}
+
+MV_32 mvWriteAmpReg(int regId, MV_32 value)
+{
+	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
new file mode 100644
index 0000000..a5a94d3
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvSemaphore.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvsemaphore_h
+#define mvsemaphore_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+#define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
+#define ADR_WIN_EN_REG			0
+
+#define MV_SEMA_REG_BASE	(0x20500)
+#define MV_MAX_SEMA 	    	128
+#define MV_SEMA_SMI 		50
+#define MV_SEMA_RTC 		51
+#define MV_SEMA_NOR_FLASH 	0
+#define MV_SEMA_BOOT 		1
+#define MV_SEMA_PEX0 		2
+#define MV_SEMA_BRIDGE 		3
+#define MV_SEMA_IRQ 		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_L2		6
+#define MV_SEMA_TWSI		7
+#define MV_SEMA_ADR_WIN		8
+
+#define MV_SEMA_BARRIER(cpu)	(50 + cpu)
+
+
+MV_BOOL mvSemaLock(MV_32 num);
+MV_BOOL mvSemaTryLock(MV_32 num);
+MV_BOOL mvSemaUnlock(MV_32 num);
+MV_32   mvReadAmpReg(int regId);
+MV_32 	mvWriteAmpReg(int regId, MV_32 value);
+
+/* Turn on HW semapores only if AMP is enabled */
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock
+#define mvSemaTryLock
+#define mvSemaUnlock
+#define mvHwBarrier
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvsemaphore_h */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
new file mode 100644
index 0000000..a2436d1
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.c
@@ -0,0 +1,266 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+static MV_BOOL mv_rsrc_limited = MV_FALSE;
+static MV_RES_MAP mv_res_table[] = {
+	/* Dividable units */
+	{0, "uart0"},
+	{0, "uart1"},
+	{0, "pex0"},
+	{0, "pex1"},
+	{0, "pex2"},
+	{0, "pex3"},
+	{0, "eth0"},
+	{0, "eth1"},
+	{0, "eth2"},
+	{0, "eth3"},
+	{0, "xor0"},
+	{0, "xor1"},
+	{0, "usb0"},
+	{0, "usb1"},
+	{0, "usb2"},
+	{0, "i2c0"},
+	{0, "i2c1"},
+	/* Single Allocation units */
+	{0, "sata"},
+	{0, "cesa"},
+	{0, "nor"},
+	{0, "nand"},
+	{0, "spi"},
+	{0, "tdm"},
+	{0, "sdio"},
+	{0, "lcd"},
+	{0, "hwmon"},
+	{0, "rtc"},
+	{0, "gpio"},
+	{0, "mstr"},
+	{-1, "last"}
+};
+
+MV_BOOL mvUnitMapIsRsrcLimited(void)
+{
+	return mv_rsrc_limited;
+}
+
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited)
+{
+	mv_rsrc_limited = isLimited;
+}
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx)
+{
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_BOOL mvUnitMapIsPexMine(int pciIf)
+{
+	MV_SOC_UNIT unitIdx;
+
+	/* Map line Number to PEX unit number */
+	/* This is compatible to mvCtrlSerdesPhyConfig in BoardEnvLib.c */
+	if(pciIf < PEX1_0x4)
+		unitIdx = PEX0;
+	else if(pciIf < PEX2_0x4)
+		unitIdx = PEX1;
+	else if(pciIf < PEX3_0x4)
+		unitIdx = PEX2;
+	else
+		unitIdx = PEX3;
+
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx)
+{
+	if (MV_TRUE == mv_res_table[unitIdx].isMine)
+		return;
+
+	mv_res_table[unitIdx].isMine = 1;
+}
+
+MV_BOOL mvUnitMapSetup(char* cmdLine, STRSTR_FUNCPTR strstr_func)
+{
+	int unitIdx;
+	char* match;
+
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		char *unitName = mv_res_table[unitIdx].unitName;
+		int len;
+		match = strstr_func(cmdLine, unitName);
+		if (!match) continue;
+		/*Look for start delimiter*/
+		if (match > cmdLine) {
+			if (match[-1] != ' ' && match[-1] != ':') {
+				continue;
+			}
+		}
+		/* Calc string length without using strlen() */
+		while (*unitName++ != '\0');
+		len = unitName - mv_res_table[unitIdx].unitName - 1;
+		/*Look for end delimiter*/
+		if (match[len] != ' ' && match[len] != ':' && match[len] != '\0') {
+			continue;
+		}
+		mvUnitMapSetMine(unitIdx);
+	}
+	return MV_TRUE;
+}
+
+/*MV_BOOL mvSocUnitMapFillTableFormBitMap(MV_U32 flag)
+{
+	int i,bit,cpuId;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++)
+	{
+		switch (i)
+		{
+		case UART0:  bit=UART0_T0_CPU1;   break;
+		case UART1:  bit=UART1_TO_CPU1;   break;
+		case PEX00:  bit=PEX0_TO_CPU1;    break;
+		case PEX10:  bit=PEX1_TO_CPU1;    break;
+		case GIGA0:  bit=GIGA0_TO_CPU1;   break;
+		case GIGA1:  bit=GIGA1_TO_CPU1;   break;
+		case GIGA2:  bit=GIGA2_TO_CPU1;   break;
+		case GIGA3:  bit=GIGA3_TO_CPU1;   break;
+		case SATA:   bit=SATA_TO_CPU1;    break;
+		case XOR:    bit=XOR_TO_CPU1;  	  break;
+		case IDMA:   bit=IDMA_TO_CPU1;    break;
+		case USB0:   bit=USB0_TO_CPU1;    break;
+		case USB1:   bit=USB1_TO_CPU1;    break;
+		case USB2:   bit=USB2_TO_CPU1;    break;
+		case CESA:   bit=CESA_TO_CPU1;    break;
+		case NOR_FLASH:	bit=NOR_TO_CPU1;    break;
+		case NAND_FLASH: bit=NAND_TO_CPU1;    break;
+		case SPI_FLASH:bit=SPI_TO_CPU1;    break;
+		case TDM: bit=TDM_TO_CPU1;    break;
+		default: bit=0;
+			break;
+		}
+		//cpuId = (flag & bit) ? SLAVE_CPU:MASTER_CPU;
+		mvSocUnitMapSet(i, cpuId);
+	}
+	return MV_TRUE;
+}
+
+MV_U32 mvSocUnitMapFillFlagFormTable(void)
+{
+	int i;
+	MV_U32 flag = 0;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++)
+	{
+	    if (mvSocUnitMapGet(i) == 0)//SLAVE_CPU)
+	    {
+		switch (i)
+		{
+		case UART0:  flag |= UART0_T0_CPU1;   	break;
+		case UART1:  flag |= UART1_TO_CPU1;   	break;
+		case PEX00:  flag |= PEX0_TO_CPU1;    	break;
+		case PEX10:  flag |= PEX1_TO_CPU1;    	break;
+		case GIGA0:  flag |= GIGA0_TO_CPU1;   	break;
+		case GIGA1:  flag |= GIGA1_TO_CPU1;   	break;
+		case GIGA2:  flag |= GIGA2_TO_CPU1;   	break;
+		case GIGA3:  flag |= GIGA3_TO_CPU1;   	break;
+		case SATA:   flag |= SATA_TO_CPU1;    	break;
+		case XOR:    flag |= XOR_TO_CPU1;	break;
+		case IDMA:   flag |= IDMA_TO_CPU1;    	break;
+		case USB0:   flag |= USB0_TO_CPU1;    	break;
+		case USB1:   flag |= USB1_TO_CPU1;    	break;
+		case USB2:   flag |= USB2_TO_CPU1;    	break;
+		case CESA:   flag |= CESA_TO_CPU1;    	break;
+		case NOR_FLASH: flag |= NOR_TO_CPU1;   break;
+		case NAND_FLASH: flag |= NAND_TO_CPU1;   break;
+		case SPI_FLASH: flag |= SPI_TO_CPU1;   break;
+		case TDM: flag |= TDM_TO_CPU1;   break;
+		default:
+			break;
+		}
+	    }
+	}
+
+	return flag;
+}*/
+MV_VOID mvUnitMapSetAllMine()
+{
+	int unitIdx;
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		mvUnitMapSetMine(unitIdx);
+	}
+}
+
+MV_VOID mvUnitMapPrint()
+{
+	int unitIdx;
+	mvOsPrintf("  AMP: Resources ");
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != -1; unitIdx++) {
+		if (mv_res_table[unitIdx].isMine) {
+			mvOsPrintf("- %s ", mv_res_table[unitIdx].unitName);
+		}
+	}
+	mvOsPrintf("\n");
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
new file mode 100644
index 0000000..0321d7b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/mvUnitMap.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvUnitMap_h
+#define mvUnitMap_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+typedef enum
+{
+	UART0=0,
+	UART1,
+	PEX0,
+	PEX1,
+	PEX2,
+	PEX3,
+	ETH0,
+	ETH1,
+	ETH2,
+	ETH3,
+	XOR0,
+	XOR1,
+	USB0,
+	USB1,
+	USB2,
+	I2C0,
+	I2C1,
+	SATA,
+	CESA,
+	NOR,
+	NAND,
+	SPI,
+	TDM,
+	SDIO,
+	LCD,
+	HWMON,
+	RTC,
+	GPIO,
+	MSTR,
+	MAX_UNITS
+} MV_SOC_UNIT;
+
+/* binary flags for mvSocUnitMapFillTableFormBitMap */
+/*#define UART0_T0_CPU1	0x0001
+#define UART1_TO_CPU1	0x0002
+#define PEX0_TO_CPU1	0x0004
+#define PEX1_TO_CPU1	0x0008
+#define GIGA0_TO_CPU1	0x0010
+#define GIGA1_TO_CPU1	0x0020
+#define GIGA2_TO_CPU1	0x0040
+#define GIGA3_TO_CPU1	0x0080
+#define SATA_TO_CPU1	0x0100
+#define XOR_TO_CPU1		0x0200
+#define IDMA_TO_CPU1	0x0400
+#define USB0_TO_CPU1	0x0800
+#define USB1_TO_CPU1    0x1000
+#define USB2_TO_CPU1    0x2000
+#define CESA_TO_CPU1	0x4000
+#define NOR_TO_CPU1		0x8000
+#define NAND_TO_CPU1	0x10000
+#define SPI_TO_CPU1		0x20000
+#define TDM_TO_CPU1		0x40000
+
+#define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
+
+typedef struct __MV_RES_MAP
+{
+	int	isMine;
+	char*	unitName;
+} MV_RES_MAP;
+
+typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapIsPexMine(int pciIf);
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
+MV_VOID mvUnitMapSetAllMine(void);
+MV_VOID mvUnitMapPrint(void);
+MV_BOOL mvUnitMapIsRsrcLimited(void);
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
+#else /* CONFIG_MV_AMP_ENABLE */
+#define mvUnitMapIsMine(rsrc) 		MV_TRUE
+#define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
+#define mvUnitMapIsRsrcLimited 	  	MV_TRUE
+#define mvUnitMapSetRsrcLimited(limit)
+#define mvUnitMapSetMine(rsrc)
+#define mvUnitMapSetAllMine
+#define mvUnitMapPrint
+#define mvUnitMapSetup(str, strstr_func) MV_TRUE
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
new file mode 100755
index 0000000..1cc1aa3
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -0,0 +1,750 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvCpuIfRegs.h"
+
+#undef MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* typedefs */
+
+/* CPU address remap registers offsets are inconsecutive. This struct		*/
+/* describes address remap register offsets					*/
+typedef struct _ahbToMbusRemapRegOffs {
+	MV_U32 lowRegOffs;	/* Low 32-bit remap register offset             */
+	MV_U32 highRegOffs;	/* High 32 bit remap register offset            */
+} AHB_TO_MBUS_REMAP_REG_OFFS;
+
+/* locals   */
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs);
+
+/*******************************************************************************
+* mvAhbToMbusInit - Initialize Ahb To Mbus Address Map !
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK laways.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusInit(void)
+{
+	return MV_OK;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinSet - Set CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*       This function sets
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified winNum address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the winNum window, allowing CPU to access
+*       the winNum window.
+*
+* INPUT:
+*       winNum      - Windows number.
+*       pAddrDecWin - CPU winNum window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU winNum window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU winNum window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the winNum is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 sizeToReg;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinSet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvAhbToMbusWinSet:Error setting AHB to MBUS window %d to "
+			   "target %s.\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			   winNum,
+			   mvCtrlTargetNameGet(pAddrDecWin->target),
+			   pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	/* Size parameter validity check.                       */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.size, ATMWCR_WIN_SIZE_ALIGNMENT)) {
+		mvOsPrintf("mvAhbToMbusWinSet: Failed, size not aligned to 0x%x.\n", ATMWCR_WIN_SIZE_ALIGNMENT);
+		return MV_BAD_PARAM;
+	}
+
+	/* Write to address decode Base Address Register        */
+	decRegs.baseReg = (pAddrDecWin->addrWin.baseLow & ATMWBR_BASE_MASK);
+
+	/* Get size register value according to window size     */
+	sizeToReg = (pAddrDecWin->addrWin.size / ATMWCR_WIN_SIZE_ALIGNMENT) - 1;
+
+	/* set size                                             */
+	decRegs.ctrlReg = (sizeToReg << ATMWCR_WIN_SIZE_OFFS);
+
+	/* enable\Disable */
+	if (MV_TRUE == pAddrDecWin->enable)
+		decRegs.ctrlReg |= ATMWCR_WIN_ENABLE;
+	else
+		decRegs.ctrlReg &= ~ATMWCR_WIN_ENABLE;
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* set attributes */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_ATTR_MASK;
+	decRegs.ctrlReg |= targetAttribs.attrib << ATMWCR_WIN_ATTR_OFFS;
+	/* set target ID */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_TARGET_MASK;
+	decRegs.ctrlReg |= targetAttribs.targetId << ATMWCR_WIN_TARGET_OFFS;
+
+#if !defined(MV_RUN_FROM_FLASH)
+	/* To be on the safe side we disable the window before writing the  */
+	/* new values.                                                      */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		mvAhbToMbusWinEnable(winNum, MV_FALSE);
+#endif
+
+	/* 3) Write to address decode Base Address Register                   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), decRegs.baseReg);
+	else
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
+
+
+	/* Internal register space have no size */
+	/* register. Do not perform size register assigment for those targets   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
+		/* Write to address decode Size Register                                */
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), decRegs.ctrlReg);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinGet - Get CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral winNum address window.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU winNum window information data structure.
+*
+* RETURN:
+*       MV_OK if winNum exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_U32 sizeRegVal;
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal register space size have no size register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+	else
+		decRegs.ctrlReg = 0;
+
+	/* Read base and size   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	else
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_INTEREG_REG);
+
+	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseLow = decRegs.baseReg & ATMWBR_BASE_MASK;
+	sizeRegVal = (decRegs.ctrlReg & ATMWCR_WIN_SIZE_MASK) >> ATMWCR_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * ATMWCR_WIN_SIZE_ALIGNMENT;
+
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN) {
+		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
+		pAddrDecWin->target = INTER_REGS;
+		pAddrDecWin->enable = MV_TRUE;
+
+		return MV_OK;
+	}
+
+	if (decRegs.ctrlReg & ATMWCR_WIN_ENABLE)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	if (-1 == pAddrDecWin->addrWin.size)
+		return MV_ERROR;
+
+	/* attrib and targetId */
+	targetAttrib.attrib = (decRegs.ctrlReg & ATMWCR_WIN_ATTR_MASK) >> ATMWCR_WIN_ATTR_OFFS;
+	targetAttrib.targetId = (decRegs.ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetGet - Get Window number associated with target
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	if (INTER_REGS == target)
+		return MV_AHB_TO_MBUS_INTREG_WIN;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_TRUE) {
+			if (decWin.target == target)
+				return winNum;
+		}
+	}
+
+	return 0xFFFFFFFF;
+
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinAvailGet - Get First Available window number.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinAvailGet(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_FALSE)
+			return winNum;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other winNum window.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinEnable: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal registers bar can't be disable or enabled */
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+		return (enable ? MV_OK : MV_ERROR);
+
+
+	if (enable == MV_TRUE) {
+		/* enable the window */
+		MV_REG_BIT_SET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	} else {
+		/* Disable address decode winNum window                             */
+		MV_REG_BIT_RESET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*       After a CPU address hits one of PCI address decode windows there is an
+*       option to remap the address to a different one. For example, CPU
+*       executes a read from PCI winNum window address 0x1200.0000. This
+*       can be modified so the address on the PCI bus would be 0x1400.0000
+*       Using the PCI address remap mechanism.
+*
+* INPUT:
+*       winNum      - Peripheral winNum enumerator. Must be a PCI winNum.
+*       pAddrDecWin - CPU winNum window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if winNum is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddr;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegOffs;
+	MV_U32 effectiveBaseAddress = 0, baseAddrValue = 0, windowSizeValue = 0;
+
+	/* Get registers offsets of given winNum                */
+	if (MV_NO_SUCH == ahbToMbusRemapRegOffsGet(winNum, &remapRegOffs))
+		return 0xffffffff;
+
+	/* 1) Set address remap low */
+	baseAddr = pAddrWin->baseLow;
+
+	/* Check base address aligment                                  */
+	/*
+	   if (MV_IS_NOT_ALIGN(baseAddr, ATMWRLR_REMAP_LOW_ALIGNMENT))
+	   {
+	   mvOsPrintf("mvAhbToMbusPciRemap: Warning. Target base 0x%x unaligned\n",
+	   baseAddr);
+	   return MV_ERROR;
+	   }
+	 */
+
+	/* BaseLow[31:16] => base register [31:16]              */
+	baseAddr = baseAddr & ATMWRLR_REMAP_LOW_MASK;
+
+	MV_REG_WRITE(remapRegOffs.lowRegOffs, baseAddr);
+	MV_REG_WRITE(remapRegOffs.highRegOffs, pAddrWin->baseHigh);
+
+	baseAddrValue = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	windowSizeValue = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+
+	baseAddrValue &= ATMWBR_BASE_MASK;
+	windowSizeValue &= ATMWCR_WIN_SIZE_MASK;
+
+	/* Start calculating the effective Base Address */
+	effectiveBaseAddress = baseAddrValue;
+
+	/* The effective base address will be combined from the chopped (if any)
+	   remap value (according to the size value and remap mechanism) and the
+	   window's base address */
+	effectiveBaseAddress |= (((windowSizeValue) | 0xffff) & pAddrWin->baseLow);
+	/* If the effectiveBaseAddress exceed the window boundaries return an
+	   invalid value. */
+
+	if (effectiveBaseAddress > (baseAddrValue + (windowSizeValue | 0xffff))) {
+		mvOsPrintf("mvAhbToMbusPciRemap: Error\n");
+		return 0xffffffff;
+	}
+
+	return effectiveBaseAddress;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetSwap - Swap AhbToMbus windows between targets
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       target1      - CPU Interface target 1
+*       target2      - CPU Interface target 2
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if targets are illigal, or if one of the targets is not
+*	    associated to a valid window .
+*       MV_OK otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2)
+{
+	MV_U32 winNum1, winNum2;
+	MV_AHB_TO_MBUS_DEC_WIN winDec1, winDec2, winDecTemp;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegs1, remapRegs2;
+	MV_U32 remapBaseLow1 = 0, remapBaseLow2 = 0;
+	MV_U32 remapBaseHigh1 = 0, remapBaseHigh2 = 0;
+
+	/* Check parameters */
+	if (target1 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	if (target2 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum1 = mvAhbToMbusWinTargetGet(target1);
+
+	if (winNum1 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target1, winNum1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum2 = mvAhbToMbusWinTargetGet(target2);
+	if (winNum2 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target2, winNum2);
+		return MV_ERROR;
+	}
+
+	/* now Get original values of both Windows */
+	if (MV_OK != mvAhbToMbusWinGet(winNum1, &winDec1)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinGet(winNum2, &winDec2)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* disable both windows */
+	if (MV_OK != mvAhbToMbusWinEnable(winNum1, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable window %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinEnable(winNum2, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable windo %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* now swap targets */
+
+	/* first save winDec2 values */
+	winDecTemp.addrWin.baseHigh = winDec2.addrWin.baseHigh;
+	winDecTemp.addrWin.baseLow = winDec2.addrWin.baseLow;
+	winDecTemp.addrWin.size = winDec2.addrWin.size;
+	winDecTemp.enable = winDec2.enable;
+	winDecTemp.target = winDec2.target;
+
+	/* winDec2 = winDec1 */
+	winDec2.addrWin.baseHigh = winDec1.addrWin.baseHigh;
+	winDec2.addrWin.baseLow = winDec1.addrWin.baseLow;
+	winDec2.addrWin.size = winDec1.addrWin.size;
+	winDec2.enable = winDec1.enable;
+	winDec2.target = winDec1.target;
+
+	/* winDec1 = winDecTemp */
+	winDec1.addrWin.baseHigh = winDecTemp.addrWin.baseHigh;
+	winDec1.addrWin.baseLow = winDecTemp.addrWin.baseLow;
+	winDec1.addrWin.size = winDecTemp.addrWin.size;
+	winDec1.enable = winDecTemp.enable;
+	winDec1.target = winDecTemp.target;
+
+	/* now set the new values */
+	mvAhbToMbusWinSet(winNum1, &winDec1);
+	mvAhbToMbusWinSet(winNum2, &winDec2);
+
+	/* now we will treat the remap windows if exist */
+
+	/* now check if one or both windows has a remap window
+	   as well after the swap ! */
+
+	/* if a window had a remap value differnt than the base value
+	   before the swap , then after the swap the remap value will be
+	   equal to the base value unless both windows has a remap windows */
+
+	/* first get old values */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		remapBaseLow1 = MV_REG_READ(remapRegs1.lowRegOffs);
+		remapBaseHigh1 = MV_REG_READ(remapRegs1.highRegOffs);
+	}
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		remapBaseLow2 = MV_REG_READ(remapRegs2.lowRegOffs);
+		remapBaseHigh2 = MV_REG_READ(remapRegs2.highRegOffs);
+	}
+
+	/* now do the swap */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+			/* Two windows has a remap !!! so swap */
+
+			MV_REG_WRITE(remapRegs2.highRegOffs, remapBaseHigh1);
+			MV_REG_WRITE(remapRegs2.lowRegOffs, remapBaseLow1);
+
+			MV_REG_WRITE(remapRegs1.highRegOffs, remapBaseHigh2);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, remapBaseLow2);
+		} else {
+			/* remap == base */
+			MV_REG_WRITE(remapRegs1.highRegOffs, winDec1.addrWin.baseHigh);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, winDec1.addrWin.baseLow);
+		}
+	} else if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		/* remap == base */
+		MV_REG_WRITE(remapRegs2.highRegOffs, winDec2.addrWin.baseHigh);
+		MV_REG_WRITE(remapRegs2.lowRegOffs, winDec2.addrWin.baseLow);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ahbToMbusRemapRegOffsGet - Get CPU address remap register offsets
+*
+* DESCRIPTION:
+* 		CPU to PCI address remap registers offsets are inconsecutive.
+*		This function returns PCI address remap registers offsets.
+*
+* INPUT:
+*       winNum - Address decode window number. See MV_U32 enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*		MV_ERROR if winNum is not a PCI one.
+*
+*******************************************************************************/
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs)
+{
+	switch (winNum) {
+	case 0:
+	case 1:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 2:
+	case 3:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			(mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			(mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_1281_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6183L_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_6710_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78130_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78160_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78230_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78260_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78460_DEV_ID) ||
+			   (mvCtrlModelGet() == MV_78000_DEV_ID)) {
+			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+			break;
+		} else {
+			pRemapRegs->lowRegOffs = 0;
+			pRemapRegs->highRegOffs = 0;
+
+			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+			return MV_NO_SUCH;
+		}
+		break;
+	default:
+		pRemapRegs->lowRegOffs = 0;
+		pRemapRegs->highRegOffs = 0;
+
+		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		return MV_NO_SUCH;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusAddDecShow - Print the AHB to MBus bridge address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN win;
+	MV_U32 winNum;
+	mvOsOutput("\n");
+	mvOsOutput("AHB To MBUS Bridge:\n");
+	mvOsOutput("-------------------\n");
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		memset(&win, 0, sizeof(MV_AHB_TO_MBUS_DEC_WIN));
+
+		mvOsOutput("win%d - ", winNum);
+
+		if (mvAhbToMbusWinGet(winNum, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("%s base %08x, ", mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+				mvOsOutput("....");
+				mvSizePrint(win.addrWin.size);
+
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		}
+	}
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
new file mode 100644
index 0000000..f91ee59
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -0,0 +1,96 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbush
+#define __INCmvAhbToMbush
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* defines  */
+
+typedef struct _mvAhbtoMbusDecWin {
+	MV_TARGET	target;
+	MV_ADDR_WIN	addrWin;    /* An address window*/
+	MV_BOOL		enable;     /* Address decode window is enabled/disabled    */
+
+} MV_AHB_TO_MBUS_DEC_WIN;
+
+/* mvAhbToMbus.h API list */
+
+MV_STATUS mvAhbToMbusInit(MV_VOID);
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
+MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
+MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
+
+MV_VOID   mvAhbToMbusAddDecShow(MV_VOID);
+
+#endif /* __INCmvAhbToMbush */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
new file mode 100755
index 0000000..50fd816
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -0,0 +1,143 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbusRegsh
+#define __INCmvAhbToMbusRegsh
+
+#define MAX_AHB_TO_MBUS_WINS			21
+#define MAX_AHB_TO_MBUS_REMAP_WINS		8
+#define MV_AHB_TO_MBUS_INTREG_WIN		20
+
+/***********************/
+/* AHB TO MBUS WINDOWS */
+/***********************/
+/* Window-X Control Registers */
+#define AHB_TO_MBUS_WIN_CTRL_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + winNum * 0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x90 + (winNum-8)*0x08))
+#define ATMWCR_WIN_ENABLE			BIT0
+#define ATMWCR_WIN_TARGET_OFFS			4
+#define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
+#define ATMWCR_WIN_ATTR_OFFS			8
+#define ATMWCR_WIN_ATTR_MASK			(0xff << ATMWCR_WIN_ATTR_OFFS)
+#define ATMWCR_WIN_SIZE_OFFS			16
+#define ATMWCR_WIN_SIZE_MASK			(0xffff << ATMWCR_WIN_SIZE_OFFS)
+#define ATMWCR_WIN_SIZE_ALIGNMENT		0x10000
+
+/* Window-X Base Register */
+#define AHB_TO_MBUS_WIN_BASE_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x4 + winNum*0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x94 + (winNum-8)*0x08))
+#define ATMWBR_BASE_OFFS			16
+#define ATMWBR_BASE_MASK			(0xffff << 	ATMWBR_BASE_OFFS)
+#define ATMWBR_BASE_ALIGNMENT			0x10000
+
+/* Window-X Remap Low Register */
+#define AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x8 + winNum*0x10) : \
+						 (0))
+#define ATMWRLR_REMAP_LOW_OFFS			16
+#define ATMWRLR_REMAP_LOW_MASK			(0xffff << ATMWRLR_REMAP_LOW_OFFS)
+#define ATMWRLR_REMAP_LOW_ALIGNMENT		0x10000
+
+/* Window-X Remap Hi Register */
+#define AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0xC + winNum*0x10) : \
+						 (0))
+#define ATMWRHR_REMAP_HIGH_OFFS			0
+#define ATMWRHR_REMAP_HIGH_MASK			(0xffffffff << ATMWRHR_REMAP_HIGH_OFFS)
+
+/*****************************/
+/* INTERNAL REGISTERS WINDOW */
+/*****************************/
+/* Internal Registers Base Address in set to be window 20 */
+#define AHB_TO_MBUS_WIN_INTEREG_REG		(MV_MBUS_REGS_OFFSET + 0x80)
+
+/************************/
+/* SDRAM DECODE WINDOWS */
+/************************/
+/* All DRAM Window definitions are declared under the ddr2_3 HAL */
+
+/****************************/
+/* SRAM (L2) DECODE WINDOWS */
+/****************************/
+#define SRAM_WIN_CTRL_REG(winNum)		(MV_MBUS_REGS_OFFSET + 0x240 + winNum * 0x4)
+#define SRAMWCR_ENABLE				BIT0
+#define SRAMWCR_SIZE_OFFS			8
+#define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
+#define SRAMWCR_BASE_OFFS			16
+#define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+
+/**********************/
+/* MBUS BRIDGE WINDOW */
+/**********************/
+#define MBUS_BRIDGE_WIN_CTRL_REG		(MV_MBUS_REGS_OFFSET + 0x250)
+#define BRIDGWCR_ENABLE				BIT0
+#define BRIDGWCR_SIZE_OFFS			16
+#define BRIDGWCR_SIZE_MASK			(0xFFFF << BRIDGWCR_SIZE_OFFS)
+#define MBUS_BRIDGE_WIN_BASE_REG		(MV_MBUS_REGS_OFFSET + 0x254)
+
+#endif /* __INCmvAhbToMbusRegsh */
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
new file mode 100755
index 0000000..09e4732
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.c
@@ -0,0 +1,1054 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+/*#include "cpu/mvCpu.h" *//* whoAmI() */
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "ddr2_3/mvDramIf.h"
+#include "ddr2_3/mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+
+/*#define MV_DEBUG*/
+/* defines  */
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals   */
+/* static functions */
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
+
+MV_TARGET sampleAtResetTargetArray[] = BOOT_TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCpuIfVerify - Verify that the address decode registers matches the table
+*
+* INPUT:
+*       cpuAddrWinMap 	- Address decode table
+*
+* RETURN:
+*       MV_OK - pass MV_ERROR - fail
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+	MV_32 diff;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		if(win.enable == cpuAddrWinMap->enable)
+		{
+			if(win.enable)
+			{
+				diff  = (win.addrWin.baseLow  - cpuAddrWinMap->addrWin.baseLow);
+				diff |= (win.addrWin.baseHigh - cpuAddrWinMap->addrWin.baseHigh);
+				diff |= (win.addrWin.size     - cpuAddrWinMap->addrWin.size);
+				/*TODO - Need to compare the window attributes as well */
+
+				if(diff)
+				{
+					mvOsOutput("mvCpuIfVerify: Mismatched window size in target %d\n", target);
+					return MV_ERROR;
+				}
+			}
+		}
+		else
+		{
+			mvOsOutput("mvCpuIfVerify: Mismatched enable field in target %d\n", target);
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCpuIfInitForCpu - Initialize Controller CPU interface
+*
+* DESCRIPTION:
+*       This function initialize Controller CPU interface:
+*       1. Set CPU interface configuration registers.
+*       2. Set CPU master Pizza arbiter control according to static
+*          configuration described in configuration file.
+*       3. Opens CPU address decode windows. DRAM windows are assumed to be
+*		   already set (auto detection).
+*
+* INPUT:
+*       cpu      	- CPU id.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_U32 regVal, i;
+	MV_TARGET target;
+	MV_ADDR_WIN addrWin;
+	MV_U32 minBase = 0xFFFFFFFF;
+	MV_U32 minSize;
+
+	if (cpuAddrWinMap == NULL) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. cpuAddrWinMap == NULL\n"));
+		return MV_ERROR;
+	}
+
+	/* Set IO Bypass base address and size according to the cpuAddrWinMap */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow == 0)
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow < minBase)
+			minBase = cpuAddrWinMap[target].addrWin.baseLow;
+	}
+	if (minBase != 0x0) {
+		minSize = 0xFFFFFFFF - minBase + 1;
+		if (!MV_IS_POWER_OF_2(minSize)) {
+			/* Round up to next power of 2. */
+			minSize = (1 << (mvLog2(minSize) + 1));
+			minBase = 0xFFFFFFFF - minSize + 1;
+		}
+
+		/* Now write the base and size */
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_BASE_REG, minBase);
+		/* Align window size to 64KB */
+		regVal = (minSize / SDRAMWBR_BASE_ALIGNMENT) - 1;
+		regVal = (regVal << 16) | 0x1;
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_CTRL_REG, regVal);
+	}
+
+	/* Set CPU Configuration register */
+	regVal = MV_REG_READ(CPU_CONFIG_REG(cpu));
+	regVal &= ~CPU_CONFIG_DEFAULT_MASK;
+	regVal |= CPU_CONFIG_DEFAULT;
+	MV_REG_WRITE(CPU_CONFIG_REG(cpu), regVal);
+
+	for (i = 0; i < MAX_AHB_TO_MBUS_WINS-2; i++)
+		mvAhbToMbusWinEnable(i, MV_FALSE);
+
+	/* Disable all SRAM windows  */
+	mvCpuIfSramWinDisable();
+
+	/* First disable all CPU target windows  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
+			continue;
+#ifdef CONFIG_MV_AMP_ENABLE
+		if(target == BOOT_ROM_CS)
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+#if defined(MV_RUN_FROM_FLASH)
+		/* Don't disable the boot device.                               */
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+		mvCpuIfTargetWinEnable(MV_CHANGE_BOOT_CS(target), MV_FALSE);
+	}
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
+	target = DEV_BOOCS;
+
+	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+		DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+		return MV_ERROR;
+	}
+
+	addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+	addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+	if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+		DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+			      cpuAddrWinMap[target].winNum));
+	}
+#endif /* MV_RUN_FROM_FLASH */
+
+	/* Go through all targets in user table until table terminator                  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+
+#if defined(MV_RUN_FROM_FLASH)
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+
+		/* if DRAM auto sizing is used do not initialized DRAM target windows,  */
+		/* assuming this already has been done earlier.                         */
+#ifdef	MV_DRAM_AUTO_SIZE
+		if (MV_TARGET_IS_DRAM(target))
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable)) {
+			#if 0 /* TODO: windows are already disabled above, we need to skip only*/
+			if (MV_OK != mvCpuIfTargetWinEnable(target, MV_FALSE)) {
+				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinEnable fail\n"));
+				return MV_ERROR;
+			}
+			#else
+			{continue; }
+			#endif
+		} else {
+			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+				DB(mvOsPrintf("mvCpuIfInit:ERR. mvCpuIfTargetWinSet fail\n"));
+				return MV_ERROR;
+			}
+
+			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+				DB(mvOsPrintf("mvCpuIfInit:WARN. mvAhbToMbusWinRemap can't remap winNum=%d\n",
+					      cpuAddrWinMap[target].winNum));
+			}
+		}
+	}
+#if 0
+/* This is not needed anymore cause pex enabled is already at CtrlEnvInit */
+#ifdef MV_INCLUDE_PEX
+	if (cpu == 0) {		/* Not needed for all CPUs */
+		MV_U32 pexUnits = mvCtrlPexMaxUnitGet();
+		for (i = 0; i < pexUnits; i++)
+			mvCpuIfEnablePex(i);
+	}
+#endif
+#endif
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	return mvCpuIfInitForCpu(whoAmI(), cpuAddrWinMap);
+}
+
+
+/*******************************************************************************
+* mvCpuIfDramInit - Initialize Controller DRAM Fastpath windows
+*
+* DESCRIPTION:
+*       This function initialize Controller DRAM Fastpath windows
+*		It takes the CS size information from the 0x1500 scratch registers
+*		and sets the correct windows sizes and base addresses accordingly
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfDramInit()
+{
+	MV_U64 base = 0;
+	MV_U32 size, cs, temp;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+//		if (size > 0 && base < SDRAM_MAX_ADDR) {
+		if (size != 0) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Set Base Address */
+			temp = (base & 0xFF000000ll) | ((base >> 32) & 0xF);
+			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
+
+			/* Check if out of max window size and resize the window */
+#if 0
+			if (base+size > SDRAM_MAX_ADDR) {
+				size = SDRAM_MAX_ADDR - base - 1;
+				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
+			}
+#endif
+			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
+			temp |= (size & SDRAM_ADDR_MASK);
+
+			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
+			base += ((MV_U64)size + 1);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSet - Set CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI0_MEM0)
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing CPU to access
+*       the target window.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - CPU target window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU target window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU target window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the target is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 existingWinNum;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		/* copy relevant data to MV_DRAM_DEC_WIN structure */
+		addrDecWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		addrDecWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		addrDecWin.addrWin.size = pAddrDecWin->addrWin.size;
+		addrDecWin.enable = pAddrDecWin->enable;
+
+		if (mvDramIfWinSet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvDramIfWinSet Failed\n");
+			return MV_ERROR;
+		}
+	} else {
+		/* copy relevant data to MV_AHB_TO_MBUS_DEC_WIN structure */
+		decWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		decWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		decWin.addrWin.size = pAddrDecWin->addrWin.size;
+		decWin.enable = pAddrDecWin->enable;
+		decWin.target = target;
+
+		existingWinNum = mvAhbToMbusWinTargetGet(target);
+
+		/* check if there is already another Window configured
+		   for this target */
+		if ((existingWinNum < MAX_AHB_TO_MBUS_WINS) && (existingWinNum != pAddrDecWin->winNum)) {
+			/* if we want to enable the new window number
+			   passed by the user , then the old one should
+			   be disabled */
+			if (MV_TRUE == pAddrDecWin->enable) {
+				/* be sure it is disabled */
+				mvAhbToMbusWinEnable(existingWinNum, MV_FALSE);
+			}
+		}
+
+		if (mvAhbToMbusWinSet(pAddrDecWin->winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvAhbToMbusWinSet Failed\n");
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinGet - Get CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral target address window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU target window information data structure.
+*
+* RETURN:
+*       MV_OK if target exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_U32 winNum = 0xffffffff;
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinGet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinGet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to get window target %d\n", target);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = addrDecWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = (MV_U64)addrDecWin.addrWin.size;
+		pAddrDecWin->enable = addrDecWin.enable;
+		pAddrDecWin->winNum = target;
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return MV_NO_SUCH;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: mvAhbToMbusWinGet Failed at winNum = %d\n", __func__, winNum);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = decWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = decWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = decWin.addrWin.size;
+		pAddrDecWin->enable = decWin.enable;
+		pAddrDecWin->winNum = winNum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       target - Peripheral target enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other target window.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable)
+{
+	MV_U32 winNum, temp;
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinEnable: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* get the window and check if it exist */
+	temp = mvCpuIfTargetWinGet(target, &addrDecWin);
+	if (MV_NO_SUCH == temp) {
+		return (enable ? MV_ERROR : MV_OK);
+	} else if (MV_OK != temp) {
+		mvOsPrintf("%s: ERR. Getting target %d failed.\n", __func__, target);
+		return MV_ERROR;
+	}
+
+	/* check overlap */
+	if (MV_TRUE == enable) {
+		if (MV_TRUE == cpuTargetWinOverlap(target, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("%s: ERR. Target %d overlap\n", __func__, target));
+			return MV_ERROR;
+		}
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinEnable(target, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: mvDramIfWinEnable Failed at \n");
+			return MV_ERROR;
+		}
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return (enable ? MV_ERROR : MV_OK);
+
+		if (mvAhbToMbusWinEnable(winNum, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to enable window = %d\n", winNum);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSizeGet - Get CPU target address window size
+*
+* DESCRIPTION:
+*		Get the size of CPU-to-peripheral target window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit size. Function also returns '0' if window is closed.
+*		Function returns 0xFFFFFFFF in case of an error.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinSizeGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet: target %d is illegal\n", target);
+		return 0;
+	}
+
+	/* Get the winNum window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet:ERR. Getting target %d failed.\n", target);
+		return 0;
+	}
+
+	/* Check if window is enabled   */
+	if (addrDecWin.enable == MV_TRUE)
+		return (addrDecWin.addrWin.size);
+	else
+		return 0;	/* Window disabled. return 0 */
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseLowGet - Get CPU target address window base low
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target low base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit low base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseLowGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0xffffffff;
+
+	return (addrDecWin.addrWin.baseLow);
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseHighGet - Get CPU target address window base high
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target high base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit high base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseHighGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseHighGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0;
+
+	return (addrDecWin.addrWin.baseHigh);
+}
+
+
+/*******************************************************************************
+* mvCpuIfSramWinDisable
+*
+* DESCRIPTION:
+*	Disable the SRAM windows.
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID)
+{
+	MV_U32 i;
+
+	for (i = 0; i < 4; i++)
+		MV_REG_WRITE(SRAM_WIN_CTRL_REG(i), SRAM_WIN_CTRL_DEFAULT_VAL);
+
+	return MV_OK;
+}
+
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfPexRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pexTarget   - Peripheral target enumerator. Must be a PEX target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PEX one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (mvCtrlPexMaxIfGet() > 1) {
+		if ((!MV_TARGET_IS_PEX0(pexTarget)) &&
+			(!MV_TARGET_IS_PEX1(pexTarget)) &&
+			(!MV_TARGET_IS_PEX2(pexTarget)) &&
+			(!MV_TARGET_IS_PEX3(pexTarget)) &&
+			(!MV_TARGET_IS_PEX4(pexTarget)) &&
+			(!MV_TARGET_IS_PEX5(pexTarget)) &&
+			(!MV_TARGET_IS_PEX6(pexTarget)) &&
+			(!MV_TARGET_IS_PEX7(pexTarget)) &&
+			(!MV_TARGET_IS_PEX8(pexTarget)) &&
+			(!MV_TARGET_IS_PEX9(pexTarget))) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	} else {
+		if (!MV_TARGET_IS_PEX0(pexTarget)) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	}
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pexTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCpuIfPciRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pciTarget   - Peripheral target enumerator. Must be a PCI target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPciRemap(MV_TARGET pciIfTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pciIfTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+/*******************************************************************************
+* mvCpuIfTargetOfBaseAddressGet - Get the target according to base address
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       baseAddress -  base address to be checked
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the target number that baseAddress belongs to or MAX_TARGETS is not
+*       found
+*
+*******************************************************************************/
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				if ((baseAddress >= win.addrWin.baseLow) &&
+				    (baseAddress < win.addrWin.baseLow + win.addrWin.size))
+					break;
+			}
+		} else
+			return MAX_TARGETS;
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* cpuTargetWinOverlap - Detect CPU address decode windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case CPU address decode
+*       windows overlapps.
+*       This function detects CPU address decode windows overlapping of a
+*       specified target. The function does not check the target itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlaps current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 targetNum;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_STATUS status;
+
+	for (targetNum = 0; targetNum < MAX_TARGETS; targetNum++) {
+		/* don't check our target or illegal targets */
+		if (targetNum == target)
+			continue;
+
+		/* Get window parameters        */
+		status = mvCpuIfTargetWinGet(targetNum, &addrDecWin);
+		if (MV_NO_SUCH == status)
+			continue;
+
+		if (MV_OK != status) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: ERR. TargetWinGet failed\n"));
+			return MV_TRUE;
+		}
+
+		/* Do not check disabled windows        */
+		if (MV_FALSE == addrDecWin.enable)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: Required target %d overlap current %d\n",
+				      target, targetNum));
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCpuIfAddDecShow - Print the CPU address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfAddDecShow(MV_VOID)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	mvOsOutput("\n");
+	mvOsOutput("CPU Interface\n");
+	mvOsOutput("-------------\n");
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		mvOsOutput("%s ", mvCtrlTargetNameGet(target));
+		mvOsOutput("....");
+
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("base %01x%08x, ", win.addrWin.baseHigh, win.addrWin.baseLow);
+				mvSizePrint(win.addrWin.size);
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		} else if (mvCpuIfTargetWinGet(target, &win) == MV_NO_SUCH) {
+			mvOsOutput("no such\n");
+		}
+	}
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfEnablePex - Enable PCI Express unit.
+*
+* DESCRIPTION:
+*	This function enables PCI Express access to the device address
+*	space.
+*
+* INPUT:
+*	pexUnit	- PEX unit (0 - 3).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfEnablePex(MV_U32 pexUnit)
+{
+	MV_U32 socMaxPexUnit = mvCtrlPexMaxUnitGet();
+
+	if (pexUnit > socMaxPexUnit) {
+		DB(mvOsPrintf("mvCpuIfEnablePex: Bad PEX unit ID (%x)\n", pexUnit));
+		return;
+	}
+
+	/* SOC config register Pex enable */
+	MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX_ENA_MASK(pexUnit));
+}
+
+/*******************************************************************************
+* mvCpuIfPex4x1Enable - Enable/Disable the 4x1 mode on PCI Express unit.
+*
+* DESCRIPTION:
+*	This function enables/disables 4x1 mode on PCI Express unit 0 or 1
+*
+* INPUT:
+*	pexUnit	- PEX unit (0 or 1).
+*	enable	- enable (MV_TRUE) or disable (MV_FALSE) 4x1 mode
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfPex4x1Enable(MV_U32 pexUnit, MV_BOOL enable)
+{
+	if (pexUnit == 0)
+		MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX0_4BY1_MASK);
+	else if (pexUnit == 1)
+		MV_REG_BIT_SET(SOC_CTRL_REG, SCR_PEX1_4BY1_MASK);
+	else
+		DB(mvOsPrintf("mvCpuIfPex4x1Enable: Bad PEX unit ID (%x)\n", pexUnit));
+}
+
+#endif
+
+/*******************************************************************************
+* mvCpuIfLvdsPadsEnable
+*
+* DESCRIPTION:
+*	Enable / Disable the LVDS pads.
+*
+* INPUT:
+*	enable - MV_TRUE to enable the pads, MV_FALSE to disable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable)
+{
+	MV_U32 reg;
+	MV_U32 i;
+
+	reg = MV_REG_READ(LVDS_PADS_CTRL_REG);
+
+	for (i = 0; i < 5; i++) {
+		reg &= ~LVDS_PADS_CONF_PD_MASK(i);
+		reg |= LVDS_PADS_CONF_PD_EN(i, enable);
+	}
+
+	MV_REG_WRITE(LVDS_PADS_CTRL_REG, reg);
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
new file mode 100644
index 0000000..41ff25c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIf.h
@@ -0,0 +1,124 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+MV_VOID   mvCpuIfEnablePex(MV_U32 pexUnit);
+MV_VOID   mvCpuIfPex4x1Enable(MV_U32 pexUnit, MV_BOOL enable);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..655d01b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvCommon.h"
+#include "mvOsAsm.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+	mov     r11, LR     		/* Save link register */
+	b       done
+#if 0
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+	/* goto calcConfigReg if device is 6281/6282 */
+	ldr     r5, =MV88F6281_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* goto calcConfigReg if device is 6192/6190 */
+	ldr     r5, =MV88F6192_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* Else 6180 */
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_CPUCLCK_MASK_6180
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3_1
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4_1
+	beq    setConfigReg
+	b    setConfigReg
+
+calcConfigReg:
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4
+	beq    setConfigReg
+
+	/* Else */
+	ldr    r4, =0
+
+setConfigReg:
+	/* Read CPU Config register */
+	MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+	ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+	and    r7, r7, r5       /* Clear register fields */
+	orr    r7, r7, r4       /* Set the values according to the findings */
+	MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+#endif
+
+done:
+	mov     PC, r11         /* r11 is saved link register */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
new file mode 100755
index 0000000..096b076
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -0,0 +1,352 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE		(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
+#define CPU_RESET_REG(cpu)			(MV_CPUIF_SHARED_REGS_BASE + (0x800+(cpu)*8))
+#define CPU_RESUME_CTRL_REG			(MV_CPUIF_SHARED_REGS_BASE + (0x988))
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK          (0x3 << CL2ACR_REP_STRGY_OFFS)
+
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)			(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)			(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_ENA_OFFS		28
+#define CPU_INT_SOURCE_CONTROL_ENA_MASK		(1 << CPU_INT_SOURCE_CONTROL_ENA_OFFS)
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+
+#define MV_IRQ_NR							116
+
+
+/*******************************************/
+/* ARM Doorbell Registers Map		   */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ						(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG					(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/*******************************************/
+/* CLOCK Complex Registers Map			   */
+/*******************************************/
+
+#define CPU_DIV_CLK_CTRL0_REG				(MV_CLK_CMPLX_REGS_OFFSET)
+#define CPU_DIV_CLK_CTRL0_RESET_MASK_OFFS	8
+#define CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0x8)
+#define CPU_DIV_CLK_CTRL2_NB_RATIO_OFFS		16
+#define CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0xC)
+#define CPU_DIV_CLK_CTRL3_CPU_RATIO_OFFS	8
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+
+#endif /* __INCmvCpuIfRegsh */
+
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
new file mode 100644
index 0000000..74c7f27
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "device/mvDevice.h"
+
+/* defines  */
+#ifdef DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvDevPramSet - Set device interface bank parameters
+*
+* DESCRIPTION:
+*       This function sets a device bank parameters to a given device.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*       *pDevParams - Device bank parameter struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+	if (pDevParams->turnOff > MAX_DBP_TURNOFF) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->turnOff out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2First > MAX_DBP_ACC2FIRST) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2First out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2Next > MAX_DBP_ACC2NEXT) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2Next out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->ale2Wr > MAX_DBP_ALE2WR) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrLow > MAX_DBP_WRLOW) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrHigh > MAX_DBP_WRHIGH) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->badrSkew << DBP_BADRSKEW_OFFS) > DBP_BADRSKEW_2CYCLE) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->badrSkew out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->deviceWidth != 8) && (pDevParams->deviceWidth != 16) && (pDevParams->deviceWidth != 32)) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth out of range\n"));
+		return MV_ERROR;
+	}
+
+	/* devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device)); */
+	/* setting values */
+	devParam |= DBP_TURNOFF_SET(pDevParams->turnOff);
+	devParam |= DBP_ACC2FIRST_SET(pDevParams->acc2First);
+	devParam |= DBP_ACC2NEXT_SET(pDevParams->acc2Next);
+	devParam |= ((pDevParams->badrSkew & DBP_BADRSKEW_MASK) << DBP_BADRSKEW_OFFS);
+
+	switch (pDevParams->deviceWidth) {
+	case 8:
+		devParam |= DBP_DEVWIDTH_8BIT;
+		break;
+	case 16:
+		devParam |= DBP_DEVWIDTH_16BIT;
+		break;
+	case 32:
+		devParam |= DBP_DEVWIDTH_32BIT;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	MV_REG_WRITE(DEV_BANK_PARAM_REG(device), devParam);
+
+	devParam = 0;
+	devParam |= DBP_ALE2WR_SET(pDevParams->ale2Wr);
+	devParam |= DBP_WRLOW_SET(pDevParams->wrLow);
+	devParam |= DBP_WRHIGH_SET(pDevParams->wrHigh);
+	MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(device), devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevPramget - Get device interface bank parameters
+*
+* DESCRIPTION:
+*       This function retrieves a device bank parameter settings.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       *pDevParams - Device bank parameter struct.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	pDevParams->turnOff = DBP_TURNOFF_GET(devParam);
+	pDevParams->acc2First = DBP_ACC2FIRST_GET(devParam);
+	pDevParams->acc2Next = DBP_ACC2NEXT_GET(devParam);
+	pDevParams->badrSkew = (devParam & DBP_BADRSKEW_MASK) >> DBP_BADRSKEW_OFFS;
+
+	switch (devParam & DBP_DEVWIDTH_MASK) {
+	case DBP_DEVWIDTH_8BIT:
+		pDevParams->deviceWidth = 8;
+		break;
+	case DBP_DEVWIDTH_16BIT:
+		pDevParams->deviceWidth = 16;
+		break;
+	case DBP_DEVWIDTH_32BIT:
+		pDevParams->deviceWidth = 32;
+		break;
+	default:
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth non valid value\n"));
+		return MV_ERROR;
+		break;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG_WR(device));
+	pDevParams->ale2Wr = DBP_ALE2WR_GET(devParam);
+	pDevParams->wrLow = DBP_WRLOW_GET(devParam);
+	pDevParams->wrHigh = DBP_WRHIGH_GET(devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevWidthGet - Get device width parameter
+*
+* DESCRIPTION:
+*       This function gets width parameter of a given device.
+*
+* INPUT:
+*       device - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Device width in bits (8,16,32...).
+*
+*******************************************************************************/
+MV_U32 mvDevWidthGet(MV_DEVICE device)
+{
+	MV_U32 devParam;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	devParam = (devParam & DBP_DEVWIDTH_MASK) >> DBP_DEVWIDTH_OFFS;
+
+	return (MV_U32) (0x8 << devParam);
+
+}
+
+/*******************************************************************************
+* mvDevNandDevCsSet - Set NAND chip-select, care mode and init sequence
+*
+* DESCRIPTION:
+*       This function set the NAND flash controller registers with NAND
+*       device chip-select.
+*
+* INPUT:
+*       devNum   - Device number. See MV_DEVICE enumerator.
+*       careMode - NAND device care mode (0 = Don't care, '1' = care).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode)
+{
+	MV_U32 nfCtrlReg;	/* NAND Flash Control Register */
+
+	/* Set chip select */
+	nfCtrlReg = MV_REG_READ(DEV_NAND_CTRL_REG);
+
+	nfCtrlReg |= (DINFCR_NF_CS_MASK(device));
+
+	if (careMode)
+		nfCtrlReg |= (DINFCR_NF_ACT_CE_MASK(device));
+	else
+		nfCtrlReg &= ~(DINFCR_NF_ACT_CE_MASK(device));
+
+	MV_REG_WRITE(DEV_NAND_CTRL_REG, nfCtrlReg);
+}
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
new file mode 100644
index 0000000..2f7d33f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDevice.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceH
+#define __INCmvDeviceH
+
+#include "device/mvDeviceRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* This structure describes device interface parameters to be assigned to   */
+/* device bank parameter                                                    */
+typedef struct _mvDeviceParam {
+				/* boundary values */
+    MV_U32       turnOff;	/* 0x0 - 0xf       */
+    MV_U32       acc2First;	/* 0x0 - 0x1f      */
+    MV_U32       acc2Next;	/* 0x0 - 0x1f      */
+    MV_U32       ale2Wr;	/* 0x0 - 0xf       */
+    MV_U32       wrLow;		/* 0x0 - 0xf       */
+    MV_U32       wrHigh;	/* 0x0 - 0xf       */
+    MV_U32       badrSkew;	/* 0x0 - 0x2       */
+    MV_U32       deviceWidth;	/* in Bytes        */
+} MV_DEVICE_PARAM;
+
+
+/* mvDevPramSet - Set device interface bank parameters */
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevPramget - Get device interface bank parameters */
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevWidthGet - Get device width parameter*/
+MV_U32 mvDevWidthGet(MV_DEVICE device);
+
+/* mvDevNandDevCsSet - Set the NAND flash control registers with NAND device- */
+/* select and care mode */
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode);
+
+#endif /* #ifndef __INCmvDeviceH */
diff --git a/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
new file mode 100644
index 0000000..25fea91
--- /dev/null
+++ b/arch/arm/mach-armadaxp/armada_xp_family/device/mvDeviceRegs.h
@@ -0,0 +1,270 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceRegsH
+#define __INCmvDeviceRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_DEVICE_MAX_XBAR_TIMEOUT  0x0FFF
+/* TODO - usage of DEV_BANK_PARAM_REG_DV is unclear */
+/* #define DEV_BANK_PARAM_REG_DV	    0x80000000 */
+/* registers offsets */
+
+static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
+{
+	switch (num) {
+	case (DEV_BOOCS):
+		return MV_DEV_BUS_REGS_OFFSET + 0x00;
+	case (DEVICE_CS0):
+		return MV_DEV_BUS_REGS_OFFSET + 0x08;
+	case (DEVICE_CS1):
+		return MV_DEV_BUS_REGS_OFFSET + 0x10;
+#ifdef MV_INCLUDE_DEVICE_CS2
+	case (DEVICE_CS2):
+		return MV_DEV_BUS_REGS_OFFSET + 0x18;
+#endif
+#ifdef MV_INCLUDE_DEVICE_CS3
+	case (DEVICE_CS3):
+		return MV_DEV_BUS_REGS_OFFSET + 0x20;
+#endif
+	default:
+		return 0xFFFFFFFF;
+	}
+}
+
+#define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
+
+/* Device Bank Parameters register fields (DBP_REG)*/
+/* Boot Device Bank Parameters (DBP) register fields (DEV_BOOT_BANK_PARAM_REG)*/
+/* DBP_XXX_MASK_HIGH is the offset of the extend bit from the msb of the input value */
+
+#define DBP_TURNOFF_OFFS_LOW		0
+#define DBP_TURNOFF_MASK_LOW		0x3F
+#define MAX_DBP_TURNOFF			0xf
+
+
+#define DBP_TURNOFF_SET(value)			\
+((value & DBP_TURNOFF_MASK_LOW) << DBP_TURNOFF_OFFS_LOW)
+
+#define DBP_TURNOFF_GET(value)			\
+((value >> DBP_TURNOFF_OFFS_LOW) & DBP_TURNOFF_MASK_LOW)
+
+#define DBP_ACC2FIRST_OFFS_LOW		6
+#define DBP_ACC2FIRST_MASK_LOW		0x3f
+#define MAX_DBP_ACC2FIRST		0x3f
+
+#define DBP_ACC2FIRST_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2FIRST_GET(value)			\
+((value >> DBP_ACC2FIRST_OFFS_LOW) & DBP_ACC2FIRST_MASK_LOW)
+
+#define DBP_ACC2NEXT_OFFS_LOW		17
+#define DBP_ACC2NEXT_MASK_LOW		0x3f
+#define MAX_DBP_ACC2NEXT		0x3f
+
+#define DBP_ACC2NEXT_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2NEXT_GET(value)			\
+((value >> DBP_ACC2NEXT_OFFS_LOW) & DBP_ACC2NEXT_MASK_LOW)
+
+#define DBP_DEVWIDTH_OFFS		30 /* Device Width */
+#define DBP_DEVWIDTH_MASK		(0x3 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_8BIT		(0x0 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_16BIT		(0x1 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_32BIT		(0x2 << DBP_DEVWIDTH_OFFS)
+
+#define DBP_BADRSKEW_OFFS		28
+#define DBP_BADRSKEW_MASK		(0x3 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_NOGAP		(0x0 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_1CYCLE		(0x1 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_2CYCLE		(0x2 << DBP_BADRSKEW_OFFS)
+
+
+#define DBP_ALE2WR_OFFS_LOW		0
+#define DBP_ALE2WR_MASK_LOW		0x3f
+#define MAX_DBP_ALE2WR			0x3F
+
+#define DBP_ALE2WR_SET(value)			\
+((value & DBP_ALE2WR_MASK_LOW) << DBP_ALE2WR_OFFS_LOW)
+
+#define DBP_ALE2WR_GET(value)			\
+((value >> DBP_ALE2WR_OFFS_LOW) & DBP_ALE2WR_MASK_LOW)
+
+#define DBP_WRLOW_OFFS_LOW		8
+#define DBP_WRLOW_MASK_LOW		0x3F
+#define MAX_DBP_WRLOW			0x3F
+
+#define DBP_WRLOW_SET(value)			\
+((value & DBP_WRLOW_MASK_LOW) << DBP_WRLOW_OFFS_LOW)
+
+#define DBP_WRLOW_GET(value)			\
+((value >> DBP_WRLOW_OFFS_LOW) & DBP_WRLOW_MASK_LOW)
+
+#define DBP_WRHIGH_OFFS_LOW		16
+#define DBP_WRHIGH_MASK_LOW		0x3F
+#define MAX_DBP_WRHIGH			0x3F
+
+#define DBP_WRHIGH_SET(value)			\
+((value & DBP_WRHIGH_MASK_LOW) << DBP_WRHIGH_OFFS_LOW)
+
+#define DBP_WRHIGH_GET(value)			\
+((value >> DBP_WRHIGH_OFFS_LOW) & DBP_WRHIGH_MASK_LOW)
+
+
+/* Device Interface Control register fields (DIC) (DIC_REG)*/
+#define DIC_TIMEOUT_OFFS 	0 /* Timeout Timer Preset Value. */
+#define DIC_TIMEOUT_MASK 	(0xffff << DIC_TIMEOUT_OFFS)
+#define MAX_DIC_TIMEOUT		0xffff
+
+/* NAND Flash Control register fields (NF) (NF_REG)*/
+#define NF_BOOTCS_OFFS			0 /* Define if BOOTCS is connected to NAND Flash */
+#define NF_BOOT_MASK			(1 << NF_BOOTCS_OFFS)
+#define NF_BOOT_NC			(0 << NF_BOOTCS_OFFS)
+#define NF_BOOT_C			(1 << NF_BOOTCS_OFFS)
+
+#define NF_BOOTCS_CE_ACT_OFFS		1 /* Define if NAND Flash on BOOTCS is CE care or CE don't care */
+#define NF_BOOTCS_CE_ACT_MASK 		(1 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_NCARE		(0 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_CARE		(1 << NF_BOOTCS_CE_ACT_OFFS)
+
+#define NF_CS0_OFFS			2 /* Define if CS0 is connected to NAND Flash */
+#define NF_CS0_MASK			(1 << NF_CS0_OFFS)
+#define NF_CS0_NC			(0 << NF_CS0_OFFS)
+#define NF_CS0_C			(1 << NF_CS0_OFFS)
+
+#define NF_CS0_CE_ACT_OFFS		3 /* Define if NAND Flash on CS0 is CE care or CE don't care */
+#define NF_CS0_CE_ACT_MASK 		(1 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_NCARE		(0 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_CARE		(1 << NF_CS0_CE_ACT_OFFS)
+
+#define NF_CS1_OFFS			4 /* Define if CS1 is connected to NAND Flash */
+#define NF_CS1_MASK			(1 << NF_CS1_OFFS)
+#define NF_CS1_NC			(0 << NF_CS1_OFFS)
+#define NF_CS1_C			(1 << NF_CS1_OFFS)
+
+#define NF_CS1_CE_ACT_OFFS		5 /* Define if NAND Flash on CS1 is CE care or CE don't care */
+#define NF_CS1_CE_ACT_MASK		(1 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_NCARE		(0 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_CARE		(1 << NF_CS1_CE_ACT_OFFS)
+
+#define NF_CS2_OFFS			6 /* Define if CS2 is connected to NAND Flash */
+#define NF_CS2_MASK			(1 << NF_CS2_OFFS)
+#define NF_CS2_NC			(0 << NF_CS2_OFFS)
+#define NF_CS2_C			(1 << NF_CS2_OFFS)
+
+#define NF_CS2_CE_ACT_OFFS		7 /* Define if NAND Flash on CS2 is CE care or CE don't care */
+#define NF_CS2_CE_ACT_MASK		(1 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_NCARE		(0 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_CARE		(1 << NF_CS2_CE_ACT_OFFS)
+
+#define NF_INIT_SEQ_OFFS		8 /* NAND Flash initialization sequence */
+#define NF_INIT_SEQ_MASK		(1 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_EN			(0 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_DIS			(1 << NF_INIT_SEQ_OFFS)
+
+#define NF_OE_HIGHW_OFFS		9 /* NAND Flash OE high width in core clocks units (value + 1) */
+#define NF_OE_HIGHW_MASK		(0x1f << NF_OE_HIGHW_OFFS)
+#define MAX_OE_HIGHW			(0x1f << NF_OE_HIGHW_OFFS)
+
+#define NF_TREADY_OFFS			14 /* NAND Flash time ready in core clocks units (value + 1) */
+#define NF_TREADY_MASK			(0x1f << NF_TREADY_OFFS)
+#define MAX_TREADY			(0x1f << NF_TREADY_OFFS)
+
+#define NF_OE_TCTRL_OFFS		19 /* NAND Flash OE toggle control */
+#define NF_OE_TCTRL_MASK		(1 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_1_CYC_AFT		(0 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_SAME_CYC		(1 << NF_OE_TCTRL_OFFS)
+
+#define NF_CS3_OFFS			20 /* Define if CS3 is connected to NAND Flash */
+#define NF_CS3_MASK			(1 << NF_CS3_OFFS)
+#define NF_CS3_NC			(0 << NF_CS3_OFFS)
+#define NF_CS3_C			(1 << NF_CS3_OFFS)
+
+#define NF_CS3_CE_ACT_OFFS		21 /* Define if NAND Flash on CS3 is CE care or CE don't care */
+#define NF_CS3_CE_ACT_MASK		(1 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_NCARE		(0 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_CARE		(1 << NF_CS3_CE_ACT_OFFS)
+
+
+/* Device Interface NAND Flash Control Register (DINFCR) */
+#define DINFCR_NF_CS_MASK(csNum)         \
+(csNum == BOOT_CS) ?  0x1 : ((csNum == DEV_CS3) ? (0x1 << 20) : (0x1 << (((csNum+1) % MV_DEV_MAX_CS) * 2)))
+
+
+#define DINFCR_NF_ACT_CE_MASK(csNum)     \
+(csNum == DEV_CS3) ? (0x2 << 20) : (0x2 << (((csNum+1) % MV_DEV_MAX_CS) * 2))
+
+#define NAND_ACTCEBOOT_BIT	BIT1
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCmvDeviceRegsH */
diff --git a/arch/arm/mach-armadaxp/clcd.c b/arch/arm/mach-armadaxp/clcd.c
new file mode 100644
index 0000000..dac86ce
--- /dev/null
+++ b/arch/arm/mach-armadaxp/clcd.c
@@ -0,0 +1,557 @@
+/*
+ *  linux/arch/arm/mach-dove/clcd.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/kmi.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <linux/param.h>		/* HZ */
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <asm/mach/time.h>
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+#ifdef CONFIG_FB_DOVE_DCON
+#include <video/dovedcon.h>
+#include <mach/dove_bl.h>
+#endif
+#include "gpp/mvGppRegs.h"
+#include <ctrlEnv/mvCtrlEnvRegs.h>
+
+#include <linux/module.h>
+
+int lcd_panel;
+module_param(lcd_panel, uint, 0);
+MODULE_PARM_DESC(lcd_panel, "set to 1 to enable LCD panel.");
+
+unsigned int lcd0_enable;
+module_param(lcd0_enable, uint, 0);
+MODULE_PARM_DESC(lcd0_enable, "set to 1 to enable LCD0 output.");
+
+#if defined(CONFIG_FB_DOVE_CLCD_FLAREON_GV) || \
+    defined(CONFIG_FB_DOVE_CLCD_FLAREON_GV_MODULE)
+	#ifndef CONFIG_ARCH_DOVENB_ON_TAHOE_AXI
+	#define	LCD_BASE_PHY_ADDR		0x80400000
+	#define	LCD1_BASE_PHY_ADDR		0x80410000
+	#define	DCON_BASE_PHY_ADDR		0x80420000
+	#else
+	#define	LCD_BASE_PHY_ADDR		0xB0020000
+	#define	LCD1_BASE_PHY_ADDR		0xB0010000
+	#define	DCON_BASE_PHY_ADDR		0xB0030000
+	#endif
+#elif defined(CONFIG_ARCH_DOVE)
+	#define	LCD_BASE_PHY_ADDR		(DOVE_LCD1_PHYS_BASE)
+	#define	LCD1_BASE_PHY_ADDR		(DOVE_LCD2_PHYS_BASE)
+	#define	DCON_BASE_PHY_ADDR		(DOVE_LCD_DCON_PHYS_BASE)
+#elif defined(CONFIG_ARCH_FEROCEON_KW)
+	#define	LCD_BASE_PHY_ADDR		(INTER_REGS_BASE | 0xC0000)
+#else
+	#ifdef CONFIG_ARCH_TAHOE_AXI
+	#define LCD_BASE_PHY_ADDR		0x1C010000
+	#define LCD1_BASE_PHY_ADDR		0x1C020000
+	#else
+	#define	LCD_BASE_PHY_ADDR		0x70000000
+	#define	LCD1_BASE_PHY_ADDR		0x70010000
+	#define	DCON_BASE_PHY_ADDR		0x70020000
+	#define	IRE_BASE_PHY_ADDR		0x70021000
+
+	#endif /* CONFIG_ARCH_TAHOE */
+#endif
+
+/*
+ * Default mode database.
+ */
+static struct fb_videomode video_modes[] = {
+	[0] = {			/* 640x480@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 640,
+	.yres		= 480,
+
+	.right_margin	= 16,
+	.hsync_len	= 96,
+	.left_margin	= 48,
+
+	.lower_margin	= 11,
+	.vsync_len	= 2,
+	.upper_margin	= 31,
+	.sync		= 0,
+	},
+	[1] = {			/* 640x480@72 */
+	.pixclock	= 0,
+	.refresh	= 72,
+	.xres		= 640,
+	.yres		= 480,
+
+	.right_margin	= 24,
+	.hsync_len	= 40,
+	.left_margin	= 128,
+
+	.lower_margin	= 9,
+	.vsync_len	= 3,
+	.upper_margin	= 28,
+	.sync		= 0,
+	},
+	[2] = {			/* 640x480@75 */
+	.pixclock	= 0,
+	.refresh	= 75,
+	.xres		= 640,
+	.yres		= 480,
+
+	.right_margin	= 16,
+	.hsync_len	= 96,
+	.left_margin	= 48,
+
+	.lower_margin	= 11,
+	.vsync_len	= 2,
+	.upper_margin	= 32,
+	.sync		= 0,
+	},
+	[3] = {			/* 640x480@85 */
+	.pixclock	= 0,
+	.refresh	= 85,
+	.xres		= 640,
+	.yres		= 480,
+
+	.right_margin	= 32,
+	.hsync_len	= 48,
+	.left_margin	= 112,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 25,
+	.sync		= 0,
+	},
+	[4] = {			/* 800x600@56 */
+	.pixclock	= 0,
+	.refresh	= 56,
+	.xres		= 800,
+	.yres		= 600,
+
+	.right_margin	= 32,
+	.hsync_len	= 128,
+	.left_margin	= 128,
+
+	.lower_margin	= 1,
+	.vsync_len	= 4,
+	.upper_margin	= 14,
+	.sync		= 0,
+	},
+	[5] = {			/* 800x600@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 800,
+	.yres		= 600,
+
+	.right_margin	= 40,
+	.hsync_len	= 128,
+	.left_margin	= 88,
+
+	.lower_margin	= 1,
+	.vsync_len	= 4,
+	.upper_margin	= 23,
+	.sync		= 0,
+	},
+	[6] = {			/* 800x600@72 */
+	.pixclock	= 0,
+	.refresh	= 72,
+	.xres		= 800,
+	.yres		= 600,
+
+	.right_margin	= 56,
+	.hsync_len	= 120,
+	.left_margin	= 64,
+
+	.lower_margin	= 37,
+	.vsync_len	= 6,
+	.upper_margin	= 23,
+	.sync		= 0,
+	},
+	[7] = {			/* 800x600@75 */
+	.pixclock	= 0,
+	.refresh	= 75,
+	.xres		= 800,
+	.yres		= 600,
+
+	.right_margin	= 16,
+	.hsync_len	= 80,
+	.left_margin	= 160,
+
+	.lower_margin	= 1,
+	.vsync_len	= 2,
+	.upper_margin	= 21,
+	.sync		= 0,
+	},
+	[8] = {			/* 800x600@85 */
+	.pixclock	= 0,
+	.refresh	= 85,
+	.xres		= 800,
+	.yres		= 600,
+
+	.right_margin	= 32,
+	.hsync_len	= 64,
+	.left_margin	= 152,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 27,
+	.sync		= 0,
+	},
+	[9] = {			/* 1024x600@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1024,
+	.yres		= 600,
+
+	.right_margin	= 38,
+	.hsync_len	= 100,
+	.left_margin	= 38,
+	.right_margin	= 38,
+
+	.lower_margin	= 8,
+	.vsync_len	= 4,
+	.upper_margin	= 8,
+	.sync		= 0,
+	},
+	[10] = {			/* 1024x768@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1024,
+	.yres		= 768,
+
+	.right_margin	= 24,
+	.hsync_len	= 136,
+	.left_margin	= 160,
+
+	.lower_margin	= 3,
+	.vsync_len	= 6,
+	.upper_margin	= 29,
+	.sync		= 0,
+	},
+	[11] = {			/* 1024x768@70 */
+	.pixclock	= 0,
+	.refresh	= 70,
+	.xres		= 1024,
+	.yres		= 768,
+
+	.right_margin	= 24,
+	.hsync_len	= 136,
+	.left_margin	= 144,
+
+	.lower_margin	= 3,
+	.vsync_len	= 6,
+	.upper_margin	= 29,
+	.sync		= 0,
+	},
+	[12] = {			/* 1024x768@75 */
+	.pixclock	= 0,
+	.refresh	= 75,
+	.xres		= 1024,
+	.yres		= 768,
+
+	.right_margin	= 16,
+	.hsync_len	= 96,
+	.left_margin	= 176,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 28,
+	.sync		= 0,
+	},
+	[12] = {			/* 1024x768@85 */
+	.pixclock	= 0,
+	.refresh	= 85,
+	.xres		= 1024,
+	.yres		= 768,
+
+	.right_margin	= 48,
+	.hsync_len	= 96,
+	.left_margin	= 208,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 36,
+	.sync		= 0,
+	},
+	[13] = {			/* 1280x720@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1280, /* 1328 */
+	.yres		= 720,  /* 816 */
+
+	.hsync_len	= 40,
+	.left_margin	= 220,
+	.right_margin	= 110,
+
+	.vsync_len	= 5,
+	.upper_margin	= 20,
+	.lower_margin	= 5,
+	.sync		= 0,
+	},
+	[14] = {			/* 1280x1024@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1280,
+	.yres		= 1024,
+
+	.right_margin	= 48,
+	.hsync_len	= 112,
+	.left_margin	= 248,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 38,
+	.sync		= 0,
+	},
+	[15] = {			/* 1366x768@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1366,
+	.yres		= 768,
+
+	.right_margin	= 72,
+	.hsync_len	= 144,
+	.left_margin	= 216,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 23,
+	.sync		= 0,
+	},
+#if 1
+	[16] = {			/* 1650x1050@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1650,
+	.yres		= 1050,
+
+	.right_margin	= 104,
+	.hsync_len	= 184,
+	.left_margin	= 288,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 33,
+	.sync		= 0,
+	},
+	[17] = {			/* 1920x1080@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1920,
+	.yres		= 1080,
+
+	.right_margin	= 88,
+	.hsync_len	= 44,
+	.left_margin	= 148,
+
+	.lower_margin	= 4,
+	.vsync_len	= 5,
+	.upper_margin	= 36,
+	.sync		= 0,
+	},
+	[18] = {			/* 1920x1200@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 1920,
+	.yres		= 1200,
+
+	.right_margin	= 128,
+	.hsync_len	= 208,
+	.left_margin	= 336,
+
+	.lower_margin	= 1,
+	.vsync_len	= 3,
+	.upper_margin	= 38,
+	.sync		= 0,
+	},
+#endif
+	[19] = {			/* 480x272@60 */
+	.pixclock	= 0,
+	.refresh	= 60,
+	.xres		= 480,
+	.yres		= 272,
+
+	.right_margin	= 2,
+	.hsync_len	= 41,
+	.left_margin	= 2,
+
+	.lower_margin	= 2,
+	.vsync_len	= 10,
+	.upper_margin	= 2,
+	.sync		= 0,
+	},
+
+
+};
+
+
+#if defined(CONFIG_FB_DOVE_CLCD)
+
+static struct resource lcd0_vid_res[] = {
+	[0] = {
+		.start	= LCD_PHYS_BASE,
+		.end	= LCD_PHYS_BASE+0x10000,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_LCD,
+		.end	= IRQ_AURORA_LCD,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct resource lcd0_res[] = {
+	[0] = {
+		.start	= LCD_PHYS_BASE,
+		.end	= LCD_PHYS_BASE+0x10000,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_LCD,
+		.end	= IRQ_AURORA_LCD,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct platform_device lcd0_platform_device = {
+	.name = "dovefb",
+	.id = 0,			/* lcd0 */
+	.dev = {
+		.coherent_dma_mask = ~0,
+		/*.platform_data = &lcd0_dmi,*/
+	},
+	.num_resources	= ARRAY_SIZE(lcd0_res),
+	.resource	= lcd0_res,
+};
+
+static struct platform_device lcd0_vid_platform_device = {
+	.name = "dovefb_ovly",
+	.id = 0,			/* lcd0 */
+	.dev = {
+		.coherent_dma_mask = ~0,
+		/*.platform_data = &lcd0_vid_dmi,*/
+	},
+	.num_resources	= ARRAY_SIZE(lcd0_vid_res),
+	.resource	= lcd0_vid_res,
+};
+#endif /* CONFIG_FB_DOVE_CLCD */
+
+#ifdef CONFIG_BACKLIGHT_DOVE
+static struct resource backlight_res[] = {
+	[0] = {
+		.start	= LCD_PHYS_BASE,
+		.end	= LCD_PHYS_BASE+0x1C8,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device backlight_platform_device = {
+	.name = "dove-bl",
+	.id = 0,
+	.num_resources	= ARRAY_SIZE(backlight_res),
+	.resource	= backlight_res,
+};
+
+#endif /* CONFIG_FB_DOVE_DCON */
+
+/*****************************************************************************
+ * I2C buses - adc, hdmi
+ ****************************************************************************/
+static struct i2c_board_info __initdata i2c_adi9889[] = {
+	{
+		I2C_BOARD_INFO("adi9889_i2c", 0x3D),
+	},
+	{
+		I2C_BOARD_INFO("adi9889_edid_i2c", 0x3F),
+	},
+};
+
+static struct i2c_board_info __initdata i2c_ths8200[] = {
+	{
+		I2C_BOARD_INFO("ths8200_i2c", 0x21),
+	},
+};
+
+
+
+int clcd_platform_init(struct dovefb_mach_info *lcd0_dmi_data,
+		       struct dovefb_mach_info *lcd0_vid_dmi_data,
+		       struct dovebl_platform_data *backlight_data)
+{
+	u32 total_x, total_y, i;
+	u64 div_result;
+
+	for (i = 0; i < ARRAY_SIZE(video_modes); i++) {
+		total_x = video_modes[i].xres + video_modes[i].hsync_len +
+			video_modes[i].left_margin +
+			video_modes[i].right_margin;
+		total_y = video_modes[i].yres + video_modes[i].vsync_len +
+			video_modes[i].upper_margin +
+			video_modes[i].lower_margin;
+		div_result = 1000000000000ll;
+		do_div(div_result,
+			(total_x * total_y * video_modes[i].refresh));
+		video_modes[i].pixclock	= div_result;
+	}
+
+	/*
+	 * Because DCON depends on lcd0 & lcd1 clk. Here we
+	 * try to reorder the load sequence. Fix me when h/w
+	 * changes.
+	 */
+#ifdef CONFIG_FB_DOVE_CLCD
+	/* lcd0 */
+	if (lcd0_enable && lcd0_dmi_data && lcd0_vid_dmi_data) {
+
+		lcd0_vid_dmi_data->modes = video_modes;
+		lcd0_vid_dmi_data->num_modes = ARRAY_SIZE(video_modes);
+		lcd0_vid_platform_device.dev.platform_data = lcd0_vid_dmi_data;
+
+		lcd0_dmi_data->modes = video_modes;
+		lcd0_dmi_data->num_modes = ARRAY_SIZE(video_modes);
+		lcd0_platform_device.dev.platform_data = lcd0_dmi_data;
+		platform_device_register(&lcd0_vid_platform_device);
+		platform_device_register(&lcd0_platform_device);
+	} else {
+		printk(KERN_INFO "LCD 0 disabled (%d).\n", lcd0_enable);
+	}
+#endif
+
+#ifdef CONFIG_BACKLIGHT_DOVE
+	if (lcd0_enable && lcd_panel) {
+		backlight_platform_device.dev.platform_data = backlight_data;
+		platform_device_register(&backlight_platform_device);
+	}
+#endif
+
+	if (lcd0_enable && !lcd_panel) {
+		i2c_register_board_info(1, i2c_adi9889,
+				ARRAY_SIZE(i2c_adi9889));
+		i2c_register_board_info(1, i2c_ths8200,
+				ARRAY_SIZE(i2c_ths8200));
+	}
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-armadaxp/clock.c b/arch/arm/mach-armadaxp/clock.c
new file mode 100644
index 0000000..15b04ae
--- /dev/null
+++ b/arch/arm/mach-armadaxp/clock.c
@@ -0,0 +1,50 @@
+/*
+ *  linux/arch/arm/mach-dove/clock.c
+ */
+
+/* TODO: Implement the functions below...	*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+
+#include "clock.h"
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+void clks_register(struct clk *clks, size_t num)
+{
+}
+
+static int __init clk_init(void)
+{
+	/* TODO: Call clks_register with appropriate params. */
+	clks_register(NULL, 0);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-armadaxp/clock.h b/arch/arm/mach-armadaxp/clock.h
new file mode 100644
index 0000000..3fd3a3b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/clock.h
@@ -0,0 +1,5 @@
+struct clk {
+	unsigned int dummy;
+};
+
+void clks_register(struct clk *clks, size_t num);
diff --git a/arch/arm/mach-armadaxp/config/mvRules.mk b/arch/arm/mach-armadaxp/config/mvRules.mk
new file mode 100644
index 0000000..f50433f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -0,0 +1,183 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F78xx0
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+PLAT_PATH	  = ../plat-armada
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR           = $(PLAT_PATH)/mv_hal
+COMMON_DIR        = $(PLAT_PATH)/common
+OSSERV_DIR        = $(PLAT_PATH)/linux_oss
+CONFIG_DIR        = config
+HAL_IF		  = mv_hal_if
+
+# HALs
+HAL_ETHPHY_DIR    = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR     = $(HAL_DIR)/flash
+HAL_RTC_DIR       = $(HAL_DIR)/rtc/integ_rtc
+HAL_VOICEBAND     = $(HAL_DIR)/voiceband
+HAL_SLIC_DIR      = $(HAL_VOICEBAND)/slic
+HAL_DAA_DIR       = $(HAL_VOICEBAND)/daa
+HAL_SATA_DIR      = $(HAL_DIR)/sata/CoreDriver
+HAL_QD_DIR        = $(HAL_DIR)/qd-dsdt
+HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
+HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3
+#HAL_DRAM_SPD_DIR  = $(HAL_DIR)/ddr2_3/spd
+HAL_GPP_DIR       = $(HAL_DIR)/gpp
+HAL_TWSI_DIR      = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR      = $(HAL_DIR)/uart
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+HAL_ETH_DIR       = $(HAL_DIR)/neta 
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
+HAL_ETH_NFP_DIR   = $(HAL_DIR)/neta/nfp
+HAL_ETH_PNC_DIR   = $(HAL_DIR)/neta/pnc
+HAL_ETH_BM_DIR    = $(HAL_DIR)/neta/bm
+HAL_ETH_PMT_DIR   = $(HAL_DIR)/neta/pmt
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_neta
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/net_dev
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+LSP_PNC_DIR       = $(LSP_NETWORK_DIR)/pnc
+LSP_BM_DIR        = $(LSP_NETWORK_DIR)/bm
+LSP_PMT_DIR       = $(LSP_NETWORK_DIR)/pmt
+LSP_HWF_DIR       = $(LSP_NETWORK_DIR)/hwf
+LSP_L2FW_DIR      = $(LSP_NETWORK_DIR)/l2fw
+endif
+
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+HAL_ETH_DIR       = $(HAL_DIR)/eth
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/eth/gbe
+HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_network
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/mv_etherent
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+endif
+
+HAL_CPU_DIR       = $(HAL_DIR)/cpu
+HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
+ifeq ($(CONFIG_MV_INCLUDE_PEX),y)
+HAL_PCI_DIR	  = $(HAL_DIR)/pci
+HAL_PEX_DIR       = $(HAL_DIR)/pex
+endif
+ifeq ($(CONFIG_MV_INCLUDE_TDM),y)
+HAL_TDM_DIR       = $(HAL_DIR)/voiceband/tdm
+endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+HAL_USB_DIR       = $(HAL_DIR)/usb
+endif
+ifeq ($(CONFIG_MV_INCLUDE_CESA),y)
+HAL_CESA_DIR	  = $(HAL_DIR)/cesa
+HAL_CESA_AES_DIR  = $(HAL_DIR)/cesa/AES
+endif
+ifeq ($(CONFIG_MV_INCLUDE_XOR),y)
+HAL_XOR_DIR       = $(HAL_DIR)/xor
+endif
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR       = $(HAL_DIR)/spi
+endif
+ifeq ($(CONFIG_MV_INCLUDE_AUDIO),y)
+HAL_AUDIO_DIR     = $(HAL_DIR)/audio
+endif
+ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
+HAL_NFC_DIR       = $(HAL_DIR)/nfc
+endif
+
+LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
+LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
+LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+
+# Environment components
+AXP_FAM_DIR	= armada_xp_family
+SOC_DEVICE_DIR	= $(AXP_FAM_DIR)/device
+SOC_CPU_DIR	= $(AXP_FAM_DIR)/cpu
+BOARD_ENV_DIR	= $(AXP_FAM_DIR)/boardEnv
+SOC_ENV_DIR	= $(AXP_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	= $(AXP_FAM_DIR)/ctrlEnv/sys
+HAL_IF_DIR	= mv_hal_if
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I      = $(srctree)/arch/arm/mach-armadaxp
+PLAT_PATH_I	= $(srctree)/arch/arm/plat-armada
+
+HAL_PATH        = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+AXP_FAM_PATH	= -I$(LSP_PATH_I)/$(AXP_FAM_DIR)
+QD_PATH         = -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
+                  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
+                     
+COMMON_PATH   	= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+ 
+OSSERV_PATH     = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH        = -I$(LSP_PATH_I)
+CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
+HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
+DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
+		 -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
+
+EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(AXP_FAM_PATH) \
+                  $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH) 
+
+
+ifeq ($(CONFIG_MV_GATEWAY),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX  
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+EXTRA_INCLUDE   += $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_CESA_TEST),y)
+EXTRA_CFLAGS 	+= -DCONFIG_MV_CESA_TEST
+endif
+
+ifeq ($(CONFIG_SATA_DEBUG_ON_ERROR),y)
+EXTRA_CFLAGS    += -DMV_LOG_ERROR
+endif
+
+ifeq ($(CONFIG_SATA_FULL_DEBUG),y)
+EXTRA_CFLAGS    += -DMV_LOG_DEBUG
+endif
+
+ifeq ($(CONFIG_MV_SATA_SUPPORT_ATAPI),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_ATAPI
+endif
+
+ifeq ($(CONFIG_MV_SATA_ENABLE_1MB_IOS),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_1MBYTE_IOS
+endif
+
+ifeq ($(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT),y)
+EXTRA_CFLAGS    +=-DPCIE_VIRTUAL_BRIDGE_SUPPORT
+endif
+
+ifeq ($(CONFIG_MV_CESA_CHAIN_MODE_SUPPORT),y)
+EXTRA_CFLAGS    += -DMV_CESA_CHAIN_MODE_SUPPORT
+endif
+
+EXTRA_CFLAGS 	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS 	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-armadaxp/config/mvSysCesaConfig.h b/arch/arm/mach-armadaxp/config/mvSysCesaConfig.h
new file mode 100644
index 0000000..141e9a4
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysCesaConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCesaConfig.h - Marvell Cesa unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+//#include "mvSysHwConfig.h"
+#include  "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for cesa registers.
+*/
+#define MV_CESA_REGS_BASE(chan) 	(MV_CESA_REGS_OFFSET(chan))
+
+#define MV_CESA_TDMA_REGS_BASE(chan)	(MV_CESA_TDMA_REGS_OFFSET(chan))
+
+#define MV_CESA_CHANNELS		(CONFIG_MV_CESA_CHANNELS)
+
+#ifdef CONFIG_MV_CESA_CHAIN_MODE
+	#define MV_CESA_CHAIN_MODE
+#endif
diff --git a/arch/arm/mach-armadaxp/config/mvSysCntmrConfig.h b/arch/arm/mach-armadaxp/config/mvSysCntmrConfig.h
new file mode 100644
index 0000000..de55150
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysCntmrConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCntmrConfig.h - Marvell Counter Manager unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for counter manager registers.
+*/
+#define MV_CNTMR_REGS_BASE		(MV_CNTMR_REGS_OFFSET)
diff --git a/arch/arm/mach-armadaxp/config/mvSysDdrConfig.h b/arch/arm/mach-armadaxp/config/mvSysDdrConfig.h
new file mode 100644
index 0000000..8332ebd
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysDdrConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for DDR registers.
+*/
+#define MV_DDR_WIN_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_DDR_CTRL_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+/* used for ddr2 "bak" files */
+#define MV_DDR_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+#ifndef MV_BOOTROM
+#define MV_STATIC_DRAM_ON_BOARD
+#endif
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysEthConfig.h b/arch/arm/mach-armadaxp/config/mvSysEthConfig.h
new file mode 100644
index 0000000..62f898e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysEthConfig.h
@@ -0,0 +1,198 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for ethernet registers.
+*/
+#ifdef CONFIG_MV_PON
+#define MV_PON_PORT_ID_GET()	MV_PON_PORT_ID
+#define MV_PON_PORT(p)		((p) == MV_PON_PORT_ID)
+#define MV_PON_REG_BASE         MV_PON_REGS_OFFSET
+#define MV_ETH_REGS_BASE(p)	(MV_PON_PORT(p) ? MV_PON_REGS_OFFSET : MV_ETH_REGS_OFFSET(p))
+#else
+#define MV_PON_PORT(p)		MV_FALSE
+#define MV_ETH_REGS_BASE(p)	MV_ETH_REGS_OFFSET(p)
+#endif /* CONFIG_MV_PON */ 
+
+#define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
+#define MV_PNC_REG_BASE         MV_PNC_REGS_OFFSET
+#define MV_ETH_COMPLEX_BASE		(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE		(MV_ETH_ONLY_REGS_OFFSET)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0  
+
+#ifdef CONFIG_MV_ETH_LEGACY 
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else 
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0   
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL    		    200
+#define ETH_RX_COAL    		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff --git a/arch/arm/mach-armadaxp/config/mvSysEthPhyConfig.h b/arch/arm/mach-armadaxp/config/mvSysEthPhyConfig.h
new file mode 100644
index 0000000..74cc239
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysEthPhyConfig.h
@@ -0,0 +1,32 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthPhyConfig.h - Marvell Ethernet-PHY specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysGppConfig.h b/arch/arm/mach-armadaxp/config/mvSysGppConfig.h
new file mode 100644
index 0000000..630d523
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysGppConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysGppConfig.h - Marvell GPP unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for GPP registers.
+*/
+#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-armadaxp/config/mvSysHwConfig.h b/arch/arm/mach-armadaxp/config/mvSysHwConfig.h
new file mode 100755
index 0000000..25e0f13
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysHwConfig.h
@@ -0,0 +1,309 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+#define CONFIG_MARVELL	1
+
+/* includes */
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+#ifdef CONFIG_DRAM_IO_RESERVE_BASE
+#define MV_DRAM_IO_RESERVE_BASE	CONFIG_DRAM_IO_RESERVE_BASE
+#endif
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX
+
+#ifdef CONFIG_MV_PEX_0_4X1
+#define MV_PEX_0_4X1		1
+#define MV_PEX_0_1X4		0
+#endif
+#ifdef CONFIG_MV_PEX_0_1X4
+#define MV_PEX_0_4X1		0
+#define MV_PEX_0_1X4		1
+#endif
+
+#ifdef CONFIG_MV_PEX_1_4X1
+#define MV_PEX_1_4X1		1
+#define MV_PEX_1_1X4		0
+#endif
+#ifdef CONFIG_MV_PEX_1_1X4
+#define MV_PEX_1_4X1		0
+#define MV_PEX_1_1X4		1
+#endif
+
+#ifdef CONFIG_MV_PEX_2_4X1
+#define MV_PEX_2_4X1		1
+#endif
+
+#ifdef CONFIG_MV_PEX_3_4X1
+#define MV_PEX_3_4X1		1
+#endif
+
+#endif /* CONFIG_MV_INCLUDE_PEX */
+
+#ifdef CONFIG_MV_INCLUDE_PCI
+#define MV_INCLUDE_PCI
+
+#define PCI_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PCI_HOST_DEV_NUM(pciIf)		0
+
+#define PEX_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PEX_HOST_DEV_NUM(pciIf)		0
+
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_CESA
+#define MV_INCLUDE_CESA
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_SATA
+#endif
+#ifdef CONFIG_MV_INCLUDE_USB
+#define MV_INCLUDE_USB
+//#define MV_USB_VOLTAGE_FIX
+#endif
+#ifdef CONFIG_MV_INCLUDE_LEGACY_NAND
+#define MV_INCLUDE_LEGACY_NAND
+#endif
+#ifdef CONFIG_MV_INCLUDE_TDM
+#define MV_INCLUDE_TDM
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+#define MV_INCLUDE_XOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_NOR
+#define MV_INCLUDE_NOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#define MV_INCLUDE_AUDIO
+#endif
+#ifdef CONFIG_MV_INCLUDE_TS
+#define MV_INCLUDE_TS
+#endif
+#ifdef CONFIG_MV_INCLUDE_SDIO
+#define MV_INCLUDE_SDIO
+#endif
+#ifdef CONFIG_MTD_NAND_LNC_BOOT
+#define MTD_NAND_LNC_BOOT
+#endif
+#ifdef CONFIG_MTD_NAND_LNC
+#define MTD_NAND_LNC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+#define MTD_NAND_NFC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+#define MTD_NAND_NFC_GANG_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+#define MTD_NAND_NFC_MLC_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_NEGLECT_RNB
+#define MTD_NAND_NFC_NEGLECT_RNB
+#endif
+#ifdef CONFIG_MV_INCLUDE_PDMA
+#define MV_INCLUDE_PDMA
+#endif
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define AURORA_IO_CACHE_COHERENCY
+#endif
+
+/* convert Definitions for Errata used in the HAL */
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4413
+#define SHEEVA_ERRATA_ARM_CPU_4413
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_BTS61
+#define SHEEVA_ERRATA_ARM_CPU_BTS61
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+#define SHEEVA_ERRATA_ARM_CPU_4611
+#endif
+
+/* convert chip revision definitions */
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define MV88F78X60_Z1
+#endif
+#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_A0_WITH_B0)
+#define MV88F78X60_A0
+#endif
+#if defined(CONFIG_ARMADA_XP_REV_B0) && !defined(CONFIG_ARMADA_XP_A0_WITH_B0)
+#define MV88F78X60_B0
+#endif
+/****************************************************************/
+/************* General    configuration ********************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Disable the DEVICE BAR in the PEX */
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+
+
+/****************************************************************/
+/************* CESA configuration ********************/
+/****************************************************************/
+
+#ifdef MV_INCLUDE_CESA
+
+#define MV_CESA_MAX_CHAN               4
+
+/* Use 2K of SRAM */
+#define MV_CESA_MAX_BUF_SIZE           1600
+
+#endif /* MV_INCLUDE_CESA */
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_LINEAR_MODE)
+ #define MV_TDM_LINEAR_MODE
+#elif defined(CONFIG_MV_TDM_ULAW_MODE)
+ #define MV_TDM_ULAW_MODE
+#endif
+
+#if defined(CONFIG_MV_TDM_5CHANNELS)
+ #define MV_TDM_5CHANNELS 
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+/****************************************************************/
+/******************* LPAE configuration *************************/
+/****************************************************************/
+#ifdef CONFIG_ARM_LPAE
+#define ARM_LPAE_SUPPORT
+#endif
+/* We use the following registers to store DRAM interface pre configuration   */
+/* auto-detection results													  */
+/* IMPORTANT: We are using mask register for that purpose. Before writing     */
+/* to units mask register, make sure main maks register is set to disable     */
+/* all interrupts.                                                            */
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */  
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */          
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Default FPGA Clock */
+#define MV_FPGA_CLK	25000000
+#endif /* __INCmvSysHwConfigh */
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysNfcConfig.h b/arch/arm/mach-armadaxp/config/mvSysNfcConfig.h
new file mode 100644
index 0000000..858497a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysNfcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_NFC_REGS_BASE		(MV_NFC_REGS_OFFSET)
diff --git a/arch/arm/mach-armadaxp/config/mvSysPciConfig.h b/arch/arm/mach-armadaxp/config/mvSysPciConfig.h
new file mode 100644
index 0000000..2783d1a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysPciConfig.h
@@ -0,0 +1,26 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PCI_IF_REGS_BASE(pciIf) 		(MV_PEX_IF_REGS_OFFSET(pciIf))
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysPexConfig.h b/arch/arm/mach-armadaxp/config/mvSysPexConfig.h
new file mode 100644
index 0000000..14a5292
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysPexConfig.h
@@ -0,0 +1,50 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysPciIfConfig.h - Marvell PCI / Pex units specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PEX_IF_REGS_BASE(unit) 		(MV_PEX_IF_REGS_OFFSET(unit))
+
+/* PEX Work arround */
+/* the target we will use for the workarround */
+#define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
+/*a flag that indicates if we are going to use the 
+size and base of the target we using for the workarround
+window */
+#define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
+/* if the above flag is 0 then the following values
+will be used for the workarround window base and size,
+otherwise the following defines will be ignored */
+#define PEX_CONFIG_RW_WA_BASE 0xF3000000
+#define PEX_CONFIG_RW_WA_SIZE _16M
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysPonConfig.h b/arch/arm/mach-armadaxp/config/mvSysPonConfig.h
new file mode 100644
index 0000000..7701866
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysPonConfig.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for PON registers.
+*/
+#define MV_EPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+#define MV_GPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysRtcConfig.h b/arch/arm/mach-armadaxp/config/mvSysRtcConfig.h
new file mode 100644
index 0000000..38a3b54
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysRtcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysRtcConfig.h - Marvell Real-Time clock unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for RTC registers.
+*/
+#define MV_RTC_REGS_BASE		(MV_RTC_REGS_OFFSET)
diff --git a/arch/arm/mach-armadaxp/config/mvSysSataConfig.h b/arch/arm/mach-armadaxp/config/mvSysSataConfig.h
new file mode 100644
index 0000000..057b5a7
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysSataConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSataConfig.h - Marvell Sata unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SATA_REGS_BASE		(MV_SATA_REGS_OFFSET)
diff --git a/arch/arm/mach-armadaxp/config/mvSysSdmmcConfig.h b/arch/arm/mach-armadaxp/config/mvSysSdmmcConfig.h
new file mode 100644
index 0000000..e5a4d3b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysSdmmcConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSdmmcConfig.h - Marvell SDMMC unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for audio registers.
+*/
+#define MV_SDMMC_REGS_BASE		(MV_SDMMC_REGS_OFFSET)
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysSpiConfig.h b/arch/arm/mach-armadaxp/config/mvSysSpiConfig.h
new file mode 100644
index 0000000..a13c1a4
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysSpiConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SPI_REGS_BASE(unit)		(MV_SPI_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armadaxp/config/mvSysTdmConfig.h b/arch/arm/mach-armadaxp/config/mvSysTdmConfig.h
new file mode 100644
index 0000000..7946fdf
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysTdmConfig.h
@@ -0,0 +1,68 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTdmConfig.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvOs.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_SUPPORT)
+	#define MV_TDM_SUPPORT
+	#define MV_TDM_REGS_BASE	MV_TDM_REGS_OFFSET
+#elif defined(CONFIG_MV_COMM_UNIT_SUPPORT)
+	#define MV_COMM_UNIT_SUPPORT
+	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
+#endif
+
+/* SLIC vendor */
+#if defined(CONFIG_SILABS_SLIC_SUPPORT)
+	#define SILABS_SLIC_SUPPORT
+	#if defined(CONFIG_SILABS_SLIC_3215)
+		#define SILABS_SLIC_3215
+	#elif defined(CONFIG_SILABS_SLIC_3217)
+		#define SILABS_SLIC_3217
+	#endif
+#elif defined(CONFIG_ZARLINK_SLIC_SUPPORT)
+	#define ZARLINK_SLIC_SUPPORT
+	#if defined(CONFIG_ZARLINK_SLIC_VE880)
+		#define ZARLINK_SLIC_VE880
+		#define SLIC_TIMER_EVENT_SUPPORT
+	#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+		#define ZARLINK_SLIC_VE792
+	#endif
+#else
+	#define SILABS_SLIC_3215_OLD_SUPPORT
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
diff --git a/arch/arm/mach-armadaxp/config/mvSysTsConfig.h b/arch/arm/mach-armadaxp/config/mvSysTsConfig.h
new file mode 100644
index 0000000..be94e0a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysTsConfig.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTsConfig.h - Marvell TS unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for TS registers.
+*/
+#define MV_TSU_GLOBAL_REGS_BASE		(MV_TSU_GLOBAL_REGS_OFFSET)
+#define MV_TSU_REGS_BASE(port)		(MV_TSU_REGS_OFFSET(port))
+
+
diff --git a/arch/arm/mach-armadaxp/config/mvSysTwsiConfig.h b/arch/arm/mach-armadaxp/config/mvSysTwsiConfig.h
new file mode 100644
index 0000000..6c9772d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysTwsiConfig.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTwsiConfig.h - Marvell TWSI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+/*
+** Base address for TWSI registers.
+*/
+#define MV_TWSI_SLAVE_REGS_BASE(unit) 	(MV_TWSI_SLAVE_REGS_OFFSET(unit))
+
+/*
+** Specific definition for Main CPU interrupt cause register.
+** Needed for TWSI operation completion monitoring.
+*/
+#define MV_TWSI_CPU_MAIN_INT_CAUSE(chNum, cpu)	TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)
diff --git a/arch/arm/mach-armadaxp/config/mvSysUsbConfig.h b/arch/arm/mach-armadaxp/config/mvSysUsbConfig.h
new file mode 100644
index 0000000..7c82f5c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysUsbConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysUsbConfig.h - Marvell USB unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for USB registers.
+*/
+#define MV_USB_REGS_BASE(unit) 		(MV_USB_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armadaxp/config/mvSysXorConfig.h b/arch/arm/mach-armadaxp/config/mvSysXorConfig.h
new file mode 100644
index 0000000..4681653
--- /dev/null
+++ b/arch/arm/mach-armadaxp/config/mvSysXorConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysXorConfig.h - Marvell XOR unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for XOR registers.
+*/
+#define MV_XOR_REGS_BASE(unit)		(MV_XOR_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
new file mode 100755
index 0000000..8f992ca
--- /dev/null
+++ b/arch/arm/mach-armadaxp/core.c
@@ -0,0 +1,2103 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/mbus.h>
+#include <asm/mach/time.h>
+#include <linux/clocksource.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <mach/system.h>
+
+#include <linux/tty.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/ata_platform.h>
+#include <linux/mv_neta.h>
+#include <asm/serial.h>
+#include <plat/cache-aurora-l2.h>
+
+#include <mach/serial.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "plat/gpio.h"
+#include "cpu/mvCpu.h"
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+#include "sdmmc/mvSdmmc.h"
+#include <plat/mvsdio.h>
+#endif
+#if defined(CONFIG_MV_INCLUDE_CESA)
+#include "cesa/mvCesa.h"
+#endif
+
+#include <plat/mv_xor.h>
+
+/* I2C */
+#include <linux/i2c.h>
+#include <linux/mv643xx_i2c.h>
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+/* SPI */
+#include "mvSysSpiApi.h"
+
+/* Eth Phy */
+#include "mvSysEthPhyApi.h"
+
+/* LCD */
+#include <video/dovefb.h>
+#include <video/dovefbreg.h>
+#include <mach/dove_bl.h>
+
+/* NAND */
+#ifdef CONFIG_MTD_NAND_NFC
+#include "mv_mtd/nand_nfc.h"
+#endif
+
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+#ifdef CONFIG_FB_DOVE
+extern unsigned int lcd0_enable;
+extern int lcd_panel;
+#endif
+extern unsigned int irq_int_type[];
+extern void __init axp_map_io(void);
+extern void __init mv_init_irq(void);
+extern struct sys_timer axp_timer;
+extern void axp_timer_resume();
+extern MV_CPU_DEC_WIN* mv_sys_map(void);
+#if defined(CONFIG_MV_INCLUDE_CESA)
+extern u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+extern void axp_init_irq(void);
+extern void __init set_core_count(unsigned int cpu_count);
+extern unsigned int group_cpu_mask;
+
+/* for debug putstr */
+static char arr[256];
+MV_U32 mvTclk = 166666667;
+MV_U32 mvSysclk = 200000000;
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+MV_U8 mvMacAddr[CONFIG_MV_ETH_PORTS_NUM][6];
+MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
+#endif
+
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0180 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)	(0x0184 + ((n) << 3))
+#define TARGET_DDR		0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC	0x1
+
+struct mbus_dram_target_info armadaxp_mbus_dram_info;
+
+/* XOR0 is disabled in Z1 Silicone */
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+ /* XOR0 is disabled in Z1 Silicone */
+#undef XOR0_ENABLE
+#else
+ /* XOR0 is disabled in A0 Silicone */
+#define XOR0_ENABLE
+#endif
+
+/*********************************************************************************/
+/**************                 Early Printk Support                **************/
+/*********************************************************************************/
+#ifdef MV_INCLUDE_EARLY_PRINTK
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0); 
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+extern void putstr(const char *ptr);
+void mv_early_printk(char *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	vsprintf(arr,fmt,args);
+	va_end(args);
+	putstr(arr);
+}
+#endif
+
+/*********************************************************************************/
+/**************               UBoot Tagging Parameters              **************/
+/*********************************************************************************/
+#ifdef CONFIG_BE8_ON_LE
+#define read_tag(a)    le32_to_cpu(a)
+#define read_mtu(a)    le16_to_cpu(a)
+#else
+#define read_tag(a)    a
+#define read_mtu(a)    a
+#endif
+
+extern MV_U32 gBoardId; 
+extern unsigned int elf_hwcap;
+extern u32 mvIsUsbHost;
+
+static int __init parse_tag_mv_uboot(const struct tag *tag)
+{
+    	unsigned int mvUbootVer = 0;
+	int i = 0;
+
+	printk("Using UBoot passing parameters structure\n");
+	mvUbootVer = read_tag(tag->u.mv_uboot.uboot_version);
+#ifdef CONFIG_MV_INCLUDE_USB
+	mvIsUsbHost = read_tag(tag->u.mv_uboot.isUsbHost);
+#endif
+	gBoardId =  (mvUbootVer & 0xff);
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+#if defined (CONFIG_OVERRIDE_ETH_CMDLINE)
+		memset(mvMacAddr[i], 0, 6);
+		mvMtu[i] = 0;
+#else
+		memcpy(mvMacAddr[i], tag->u.mv_uboot.macAddr[i], 6);
+		mvMtu[i] = read_mtu(tag->u.mv_uboot.mtu[i]);
+#endif
+	}
+#endif
+
+#ifdef CONFIG_MV_NAND
+               /* get NAND ECC type(1-bit or 4-bit) */
+	if ((mvUbootVer >> 8) >= 0x3040c)
+		mv_nand_ecc = read_tag(tag->u.mv_uboot.nand_ecc);
+	else
+		mv_nand_ecc = 1; /* fallback to 1-bit ECC */
+#endif
+	return 0;
+}
+
+__tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
+
+/*********************************************************************************/
+/**************                Command Line Parameters              **************/
+/*********************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+#include "mvSysUsbApi.h"
+/* Required to get the configuration string from the Kernel Command Line */
+static char *usb0Mode = "host";
+static char *usb1Mode = "host";
+static char *usb2Mode = "device";
+int mv_usb0_cmdline_config(char *s);
+int mv_usb1_cmdline_config(char *s);
+int mv_usb2_cmdline_config(char *s);
+__setup("usb0Mode=", mv_usb0_cmdline_config);
+__setup("usb1Mode=", mv_usb1_cmdline_config);
+__setup("usb2Mode=", mv_usb2_cmdline_config);
+
+int mv_usb0_cmdline_config(char *s)
+{
+    usb0Mode = s;
+    return 1;
+}
+
+int mv_usb1_cmdline_config(char *s)
+{
+    usb1Mode = s;
+    return 1;
+}
+
+int mv_usb2_cmdline_config(char *s)
+{
+    usb2Mode = s;
+    return 1;
+}
+#endif
+
+#ifdef CONFIG_CACHE_AURORA_L2
+static int noL2 = 0;
+static int __init noL2_setup(char *__unused)
+{
+     noL2 = 1;
+     return 1;
+}
+
+__setup("noL2", noL2_setup);
+#endif
+
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+unsigned int l0_disable_flag = 0;		/* L0 Enabled by Default */
+static int __init l0_disable_setup(char *__unused)
+{
+     l0_disable_flag = 1;
+     return 1;
+}
+
+__setup("l0_disable", l0_disable_setup);
+#endif
+
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+unsigned int sp_enable_flag = 0;		/* SP Disabled by Default */
+static int __init spec_prefesth_setup(char *__unused)
+{
+     sp_enable_flag = 1;
+     return 1;
+}
+
+__setup("sp_enable", spec_prefesth_setup);
+#endif
+
+#ifdef CONFIG_JTAG_DEBUG
+	MV_U32 support_wait_for_interrupt = 0x0;
+#else
+	MV_U32 support_wait_for_interrupt = 0x1;
+#endif
+
+static int __init noWFI_setup(char *__unused)
+{
+     support_wait_for_interrupt = 0;
+     return 1;
+}
+
+__setup("noWFI", noWFI_setup);
+
+MV_U32 support_Z1A_serdes_cfg = 0x0;
+static int __init serdesZ1A_setup(char *__unused)
+{
+     printk("Supporting Z1A Serdes Configurations.\n");
+     support_Z1A_serdes_cfg = 1;
+     return 1;
+}
+
+__setup("Z1A", serdesZ1A_setup);
+
+char *nfcConfig = NULL;
+static int __init nfcConfig_setup(char *s)
+{
+	nfcConfig = s;
+	return 1;
+}
+__setup("nfcConfig=", nfcConfig_setup);
+
+#ifdef CONFIG_SMP
+unsigned long mv_cpu_count = NR_CPUS;
+static int __init mv_cpu_count_setup(char *s)
+{
+	int fail;
+	unsigned int cpu_count;
+
+	/* Translate string to integer. If fails return to default*/
+	while (isspace(*s))
+		s++;
+
+	fail = strict_strtoul(s, 10, &cpu_count);
+	if(fail == 0)
+	{
+		set_core_count(cpu_count);
+	}
+
+	return 1;
+}
+__setup("mv_cpu_count=", mv_cpu_count_setup);
+
+static int __init mv_rsrc_setup(char *s)
+{
+	char* rsrc = strchr(s, ' ');
+
+	/*Verify NULL termination */
+	if (rsrc) (*rsrc) = '\0';
+	/* Parse string to table */
+	if (MV_FALSE == mvUnitMapSetup(s, strstr))
+		printk(KERN_ERR "Invalid resource string %s\n", s);
+
+	// Change to rsrc limited mode
+	mvUnitMapSetRsrcLimited(MV_TRUE);
+
+	return 1;
+}
+__setup("mv_rsrc=", mv_rsrc_setup);
+#endif /* CONFIG_SMP */
+
+#ifdef CONFIG_MV_AMP_ENABLE
+unsigned int sh_mem_base = 0, sh_mem_size = 0;
+static int __init mv_shared_mem_setup(char *s)
+{
+	char *delim = strchr(s, ':');
+	char *base_str  = s;
+	char *size_str  = delim + 1;
+	int fail;
+	void *sh_virt_base;
+
+	if(delim == NULL){
+		printk(KERN_WARNING "AMP: No delimiter in shared memory string %s. use format mv_sh_mem=base:size\n", s);
+		return 1;
+	}
+
+	/*Split the string to base and size strings*/
+	*delim = '\0';
+
+	fail  = strict_strtoul(base_str, 16, &sh_mem_base);
+	fail |= strict_strtoul(size_str, 16, &sh_mem_size);
+
+	if(fail)
+		printk(KERN_WARNING "AMP: Bad shared memory string %s:%s. Cant extract valid values\n", base_str,size_str);
+
+	return 1;
+}
+__setup("mv_sh_mem=", mv_shared_mem_setup);
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#ifdef CONFIG_MV_IPC_DRIVER
+int ipc_target_cpu;
+static int __init mv_ipc_setup(char *s)
+{
+	int fail;
+	unsigned int cpu_count;
+
+	while (isspace(*s))
+		s++;
+
+	/* Translate string to integer. If fails return to default*/
+	fail = strict_strtoul(s, 10, &ipc_target_cpu);
+	if(fail) {
+		printk(KERN_WARNING "IPC: Received bad target cpu id %s\n", s);
+		ipc_target_cpu = -1;
+	}
+
+	return 1;
+}
+__setup("mv_ipc=", mv_ipc_setup);
+#endif
+
+
+
+
+void __init armadaxp_setup_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+	u8	coherency_status = 0;
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
+#endif
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	armadaxp_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	addr = (void __iomem *)AXP_BRIDGE_VIRT_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+			if (base & 0xf)
+				/* BaseExtension is used (> 4GB).*/
+				continue;
+			w = &armadaxp_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->mbus_attr |= coherency_status << 4;
+			w->base = base & 0xff000000;
+			w->size = (size | 0x00ffffff) + 1;
+		}
+	}
+	armadaxp_mbus_dram_info.num_cs = cs;
+}
+
+/*********************************************************************************/
+/**************               I/O Devices Platform Info             **************/
+/*********************************************************************************/
+/*************
+ * I2C(TWSI) *
+ *************/
+static struct mv64xxx_i2c_pdata axp_i2c_pdata = {
+       .freq_m         = 9, /* assumes 166 MHz TCLK */
+       .freq_n         = 3,
+       .timeout        = 1000, /* Default timeout of 1 second */
+};
+
+static struct resource axp_i2c_0_resources[] = {
+	{
+		.name   = "i2c base",
+		.start  = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0),
+		.end    = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(0) + 0x20 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "i2c irq",
+		.start  = IRQ_AURORA_I2C0,
+		.end    = IRQ_AURORA_I2C0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+
+static struct resource axp_i2c_1_resources[] = {
+	{
+		.name   = "i2c base",
+		.start  = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(1),
+		.end    = INTER_REGS_PHYS_BASE + MV_TWSI_SLAVE_REGS_OFFSET(1) + 0x20 - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "i2c irq",
+		.start  = IRQ_AURORA_I2C1,
+		.end    = IRQ_AURORA_I2C1,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device axp_i2c0 = {
+	.name           = MV64XXX_I2C_CTLR_NAME,
+	.id             = 0,
+	.num_resources  = ARRAY_SIZE(axp_i2c_0_resources),
+	.resource       = axp_i2c_0_resources,
+	.dev            = {
+		.platform_data = &axp_i2c_pdata,
+	},
+};
+
+static struct platform_device axp_i2c1 = {
+	.name           = MV64XXX_I2C_CTLR_NAME,
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(axp_i2c_1_resources),
+	.resource       = axp_i2c_1_resources,
+	.dev            = {
+		.platform_data = &axp_i2c_pdata,
+	},
+};
+/**********
+ * UART-0 *
+ **********/
+static struct plat_serial8250_port aurora_uart0_data[] = {
+	{
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= 0,
+	},
+};
+
+static struct resource aurora_uart0_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART0,
+		.end		= IRQ_AURORA_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart0 = {
+	.name			= "dw-apb-uart",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart0_data,
+	},
+	.resource		= aurora_uart0_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart0_resources),
+};
+
+/**********
+ * UART-1 *
+ **********/
+ static struct plat_serial8250_port aurora_uart1_data[] = {
+	{
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= 0,
+	},
+};
+
+static struct resource aurora_uart1_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART1,
+		.end		= IRQ_AURORA_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart1 = {
+	.name			= "dw-apb-uart",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart1_data,
+	},
+	.resource		= aurora_uart1_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart1_resources),
+};
+
+void __init serial_initialize(int port)
+{
+	if(port == 0)
+	{
+		if(mvUnitMapIsMine(UART0) == MV_FALSE){
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART0);
+		}
+
+		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart0);
+	}
+	else
+	{
+		if(mvUnitMapIsMine(UART1) == MV_FALSE){
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART1);
+		}
+
+		aurora_uart1_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart1);
+	}
+}
+
+/********
+ * SDIO *
+ ********/
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+static struct resource mvsdio_resources[] = {
+	[0] = {
+		.start	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_SDMMC_REGS_OFFSET + SZ_1K -1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IRQ_AURORA_SDIO,
+		.end	= IRQ_AURORA_SDIO,
+		.flags	= IORESOURCE_IRQ,
+	},
+
+};
+
+static u64 mvsdio_dmamask = 0xffffffffUL;
+
+static struct mvsdio_platform_data mvsdio_data = {
+	.gpio_write_protect	= 0,
+	.gpio_card_detect	= 0,
+	.dram			= NULL,
+};
+
+static struct platform_device mv_sdio_plat = {
+	.name		= "mvsdio",
+	.id		= -1,
+	.dev		= {
+		.dma_mask = &mvsdio_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data	= &mvsdio_data,
+	},
+	.num_resources	= ARRAY_SIZE(mvsdio_resources),
+	.resource	= mvsdio_resources,
+};
+
+void __init sdio_initialize(void)
+{
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+			irq_int_type[mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT)+IRQ_AURORA_GPIO_START] = GPP_IRQ_TYPE_CHANGE_LEVEL;
+		}
+
+		if(mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+       }
+}
+#endif /* #if defined(CONFIG_MV_INCLUDE_SDIO) */
+
+/*******
+ * GBE *
+ *******/
+#ifdef CONFIG_MV_ETHERNET
+#if defined(CONFIG_MV_ETH_LEGACY)
+static struct platform_device mv88fx_eth = {
+	.name		= "mv88fx_eth",
+	.id		= 0,
+	.num_resources	= 0,
+};
+#elif defined(CONFIG_MV_ETH_NETA)
+static struct platform_device mv88fx_neta = {
+	.name		= "mv88fx_neta",
+	.id		= 0,
+	.num_resources	= 0,
+};
+#else
+#error "Ethernet Mode is not defined (should be Legacy or NETA)"
+#endif /* Ethernet mode: legacy or NETA */
+
+static void __init eth_init(void)
+{
+ struct netaSmpGroupStruct *netaSmpGroupStruct;
+        int cpu, found = 0, portMask;
+
+        netaSmpGroupStruct = kzalloc(sizeof(struct netaSmpGroupStruct), GFP_KERNEL);
+
+        if (!netaSmpGroupStruct) {
+                        printk(KERN_ERR "no memory for private data\n");
+                        return;
+        }
+        else {
+
+#ifdef  CONFIG_SMP
+                netaSmpGroupStruct->cpuMask  = group_cpu_mask;
+#else
+                netaSmpGroupStruct->cpuMask  = 1;
+#endif
+
+                portMask  = (mvUnitMapIsMine(ETH0) == MV_TRUE);
+                portMask |= (mvUnitMapIsMine(ETH1) == MV_TRUE) << 1;
+                portMask |= (mvUnitMapIsMine(ETH2) == MV_TRUE) << 2;
+                portMask |= (mvUnitMapIsMine(ETH3) == MV_TRUE) << 3;
+
+                netaSmpGroupStruct->portMask = portMask;
+        }
+
+        for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
+                if (MV_BIT_CHECK(netaSmpGroupStruct->cpuMask, cpu))
+                        found = 1;
+        }
+        if (!found) {
+                printk(KERN_ERR "%s: cpuMask does not contain any of the CPUs \n", __func__);
+                printk(KERN_ERR "%s: not initializing network driver\n", __func__);
+                return;
+        }
+        mv88fx_neta.dev.platform_data = netaSmpGroupStruct;
+
+#if defined(CONFIG_MV_ETH_LEGACY)
+        platform_device_register(&mv88fx_eth);
+#elif defined(CONFIG_MV_ETH_NETA)
+        platform_device_register(&mv88fx_neta);
+#endif /* Ethernet mode: legacy or NETA */
+}
+
+#endif /* CONFIG_MV_ETHERNET */
+
+/***********
+ * IPC NET *
+ ***********/
+
+#ifdef CONFIG_MV_IPC_NET
+static struct platform_device mv_ipc_net = {
+	.name	= "mv_ipc_net",
+	.id		= 0,
+	.num_resources	= 0,
+	.dev    = {
+		.platform_data = (void*)&ipc_target_cpu
+	}
+};
+#endif
+
+
+/*******
+ * RTC *
+ *******/
+static struct resource axp_rtc_resource[] = {
+	{
+		.start	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_AURORA_RTC,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static void __init rtc_init(void)
+{
+	platform_device_register_simple("rtc-mv", -1, axp_rtc_resource, 2);
+}
+
+/********
+ * SATA *
+ ********/
+#ifdef CONFIG_SATA_MV
+#define SATA_PHYS_BASE (INTER_REGS_PHYS_BASE | 0xA0000)
+#define IRQ_DSMP_SATA IRQ_AURORA_SATA0
+
+static struct mv_sata_platform_data dbdsmp_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct resource armadaxp_sata_resources[] = {
+	{
+		.name	= "sata base",
+		.start	= SATA_PHYS_BASE,
+		.end	= SATA_PHYS_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "sata irq",
+		.start	= IRQ_DSMP_SATA,
+		.end	= IRQ_DSMP_SATA,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device armadaxp_sata = {
+	.name		= "sata_mv",
+	.id		= 0,
+	.dev		= {
+		.coherent_dma_mask	= 0xffffffff,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_sata_resources),
+	.resource	= armadaxp_sata_resources,
+};
+
+void __init armadaxp_sata_init(struct mv_sata_platform_data *sata_data)
+{
+
+	armadaxp_sata.dev.platform_data = sata_data;
+	sata_data->dram = &armadaxp_mbus_dram_info;
+	platform_device_register(&armadaxp_sata);
+}
+#endif
+/*****************************************************************************
+ * SoC hwmon Thermal Sensor
+ ****************************************************************************/
+void __init armadaxp_hwmon_init(void)
+{
+	platform_device_register_simple("axp-temp", 0, NULL, 0);
+}
+
+/*************
+ * 7-Segment *
+ *************/
+static struct timer_list axp_db_timer;
+static void axp_db_7seg_event(unsigned long data)
+{
+	static int count = 0;
+
+	/* Update the 7 segment */
+	mvBoardDebugLed(count);
+
+	/* Incremnt count and arm the timer*/
+	count = (count + 1) & 7;
+	mod_timer(&axp_db_timer, jiffies + 1 * HZ);
+}
+
+static int __init axp_db_7seg_init(void)
+{
+	/* Create the 7segment timer */
+	setup_timer(&axp_db_timer, axp_db_7seg_event, 0);
+
+	/* Arm it expire in 1 second */
+	mod_timer(&axp_db_timer, jiffies + 1 * HZ);
+
+	return 0;
+}
+__initcall(axp_db_7seg_init);
+
+#ifdef CONFIG_FB_DOVE
+/*****************************************************************************
+ * LCD
+ ****************************************************************************/
+
+/*
+ * LCD HW output Red[0] to LDD[0] when set bit [19:16] of reg 0x190
+ * to 0x0. Which means HW outputs BGR format default. All platforms
+ * uses this controller should enable .panel_rbswap. Unless layout
+ * design connects Blue[0] to LDD[0] instead.
+ */
+static struct dovefb_mach_info kw_lcd0_dmi = {
+	.id_gfx			= "GFX Layer 0",
+	.id_ovly		= "Video Layer 0",
+	.pix_fmt		= PIX_FMT_RGB888PACK,
+	.lcd_ref_clk		= 25000000,
+#if defined(CONFIG_FB_DOVE_CLCD_DCONB_BYPASS0)
+	.io_pin_allocation	= IOPAD_DUMB24,
+	.panel_rgb_type		= DUMB24_RGB888_0,
+#else
+	.io_pin_allocation      = IOPAD_DUMB24,
+	.panel_rgb_type         = DUMB24_RGB888_0,
+#endif
+	.panel_rgb_reverse_lanes = 0,
+	.gpio_output_data	= 3,
+	.gpio_output_mask	= 3,
+	.ddc_polling_disable	= 1,
+	.ddc_i2c_address	= 0x50,
+	.ddc_i2c_adapter	= 0,
+	.invert_composite_blank	= 0,
+	.invert_pix_val_ena	= 0,
+	.invert_pixclock	= 0,
+	.invert_vsync		= 0,
+	.invert_hsync		= 0,
+	.panel_rbswap		= 1,
+	.active			= 1,
+	.lvds_info = {
+		.lvds_24b_option = 1,
+		.lvds_tick_drv = 2
+	}
+};
+
+static struct dovefb_mach_info kw_lcd0_vid_dmi = {
+	.id_ovly		= "Video Layer 0",
+	.pix_fmt		= PIX_FMT_RGB888PACK,
+	.io_pin_allocation	= IOPAD_DUMB24,
+	.panel_rgb_type		= DUMB24_RGB888_0,
+	.panel_rgb_reverse_lanes = 0,
+	.gpio_output_data	= 3,
+	.gpio_output_mask	= 3,
+	.ddc_i2c_adapter	= -1,
+	.invert_composite_blank	= 0,
+	.invert_pix_val_ena	= 0,
+	.invert_pixclock	= 0,
+	.invert_vsync		= 0,
+	.invert_hsync		= 0,
+	.panel_rbswap		= 0,
+	.active			= 1,
+	.enable_lcd0		= 0,
+};
+
+/*****************************************************************************
+ * BACKLIGHT
+ ****************************************************************************/
+static struct dovebl_platform_data dsmp_backlight_data = {
+	.default_intensity = 0xa,
+	.gpio_pm_control = 1,
+
+	.lcd_start = LCD_PHYS_BASE,	/* lcd power control reg base. */
+	.lcd_end = LCD_PHYS_BASE+0x1C8,	/* end of reg map. */
+	.lcd_offset = LCD_SPU_DUMB_CTRL,/* register offset */
+	.lcd_mapped = 0,		/* va = 0, pa = 1 */
+	.lcd_mask = 0x0,		/* mask, bit[21] */
+	.lcd_on = 0x0,			/* value to enable lcd power */
+	.lcd_off = 0x0,			/* value to disable lcd power */
+
+	.blpwr_start = LCD_PHYS_BASE, /* bl pwr ctrl reg base. */
+	.blpwr_end = LCD_PHYS_BASE+0x1C8,/* end of reg map. */
+	.blpwr_offset = LCD_SPU_DUMB_CTRL,/* register offset */
+	.blpwr_mapped = 0,		/* pa = 0, va = 1 */
+	.blpwr_mask = 0x0,		/* mask */
+	.blpwr_on = 0x0,		/* value to enable bl power */
+	.blpwr_off = 0x0,		/* value to disable bl power */
+
+	.btn_start = LCD_PHYS_BASE, /* brightness control reg base. */
+	.btn_end = LCD_PHYS_BASE+0x1C8,	/* end of reg map. */
+	.btn_offset = LCD_CFG_GRA_PITCH,	/* register offset */
+	.btn_mapped = 0,		/* pa = 0, va = 1 */
+	.btn_mask = 0xF0000000,	/* mask */
+	.btn_level = 15,	/* how many level can be configured. */
+	.btn_min = 0x1,	/* min value */
+	.btn_max = 0xF,	/* max value */
+	.btn_inc = 0x1,	/* increment */
+};
+
+#endif /* CONFIG_FB_DOVE */
+
+#ifdef CONFIG_MTD_NAND_NFC
+/*****************************************************************************
+ * NAND controller
+ ****************************************************************************/
+static struct resource axp_nfc_resources[] = {
+	{
+		.start  = INTER_REGS_BASE + MV_NFC_REGS_OFFSET,
+		.end    = INTER_REGS_BASE + MV_NFC_REGS_OFFSET + 0x400 -1,
+		.flags  = IORESOURCE_MEM,
+	}
+};
+
+
+static struct mtd_partition nand_parts_info[] = {
+	{
+		.name		= "UBoot",
+		.offset		= 0,
+		.size		= 1 * SZ_1M
+	},
+	{
+		.name		= "UImage",
+		.offset	= MTDPART_OFS_APPEND,
+		.size		= 4 * SZ_1M },
+	{
+		.name		= "Root",
+		.offset	= MTDPART_OFS_APPEND,
+		.size         = MTDPART_SIZ_FULL
+	},
+};
+
+
+static struct nfc_platform_data axp_nfc_data = {
+	.nfc_width	= 8,
+	.num_devs	= 1,
+	.num_cs		= 1,
+	.use_dma	= 0,
+	.ecc_type	= MV_NFC_ECC_BCH_2K,
+	.parts		= nand_parts_info,
+	.nr_parts	= ARRAY_SIZE(nand_parts_info),
+};
+
+static struct platform_device axp_nfc = {
+	.name           = "armada-nand",
+	.id             = 0,
+	.dev            = {
+							.platform_data = &axp_nfc_data,
+						},
+	.num_resources  = ARRAY_SIZE(axp_nfc_resources),
+	.resource       = axp_nfc_resources,
+
+};
+
+static void __init axp_db_nfc_init(void)
+{
+	/* Check for ganaged mode */
+	if (nfcConfig) {
+		if (strncmp(nfcConfig, "ganged", 6) == 0) {
+			axp_nfc_data.nfc_width = 16;
+			axp_nfc_data.num_devs = 2;
+			nfcConfig += 7;
+		}
+
+		/* Check for ECC type directive */
+		if (strcmp(nfcConfig, "8bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_1K;
+		} else if (strcmp(nfcConfig, "12bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_704B;
+		} else if (strcmp(nfcConfig, "16bitecc") == 0) {
+			axp_nfc_data.ecc_type = MV_NFC_ECC_BCH_512B;
+		}
+	}
+
+	axp_nfc_data.tclk = mvBoardTclkGet();
+
+	platform_device_register(&axp_nfc);
+}
+#endif
+/*********************************************************************************/
+/**************                      Helper Routines                **************/
+/*********************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+unsigned char*  mv_sram_usage_get(int* sram_size_ptr)
+{
+	int used_size = 0;
+
+#if defined(CONFIG_MV_CESA)
+	used_size = sizeof(MV_CESA_SRAM_MAP);
+#endif
+
+	if(sram_size_ptr != NULL)
+		*sram_size_ptr = _8K - used_size;
+
+	return (char *)(mv_crypto_virt_base_get(0) + used_size);
+}
+#endif
+
+void print_board_info(void)
+{
+	char name_buff[50];
+	printk("\n");
+	printk("  Marvell Armada-XP");
+
+	mvBoardNameGet(name_buff);
+	printk(" %s Board - ",name_buff);
+
+	mvCtrlModelRevNameGet(name_buff);
+	printk(" Soc: %s",  name_buff);
+#if defined(MV_CPU_LE)
+	printk(" LE\n");
+#else
+	printk(" BE\n");
+#endif
+	printk("  Detected Tclk %d, SysClk %d, FabricClk %d, PClk %d\n",mvTclk, mvSysclk, mvCpuL2ClkGet(), mvCpuPclkGet());
+	printk("  LSP version: %s\n", LSP_VERSION);
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvUnitMapPrint();
+#endif
+	printk("\n");
+}
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+static void io_coherency_init(void)
+{
+	MV_U32 reg;
+
+	/* set CIB read snoop command to ReadUnique */
+	reg = MV_REG_READ(MV_CIB_CTRL_CFG_REG);
+	reg &= ~(7 << 16);
+	reg |= (7 << 16);
+	MV_REG_WRITE(MV_CIB_CTRL_CFG_REG, reg);
+
+#ifndef CONFIG_SMP
+        /* enable CPUs in SMP group on Fabric coherency */
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CTRL_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CTRL_REG, reg);
+
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CFG_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CFG_REG, reg);
+#endif
+}
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(const char *);
+static void check_cpu_mode(void)
+{
+                u32 cpu_id_code_ext;
+                int cpu_mode = 0;
+                asm volatile("mrc p15, 1, %0, c15, c12, 0": "=r"(cpu_id_code_ext));
+
+                if (((cpu_id_code_ext >> 16) & 0xF) == 0x2)
+                        cpu_mode = 6;
+                else if (((cpu_id_code_ext >> 16) & 0xF) == 0x3)
+                        cpu_mode = 7;
+                else 
+                        pr_err("unknow cpu mode!!!\n");
+#ifdef CONFIG_DEBUGGER_MODE_V6
+		if (cpu_mode != 6) {
+			printascii("cpu mode (ARMv7) doesn't mach kernel configuration\n");
+			panic("cpu mode mismatch");
+		}
+#else
+#ifdef CONFIG_CPU_V7
+                if (cpu_mode != 7) {
+                        printascii("cpu mode (ARMv6) doesn't mach kernel configuration\n");
+                        panic("cpu mode mismatch");
+                }
+#endif
+#endif
+	printk("Aurora: Working in ARMv%d mode\n",cpu_mode);
+}
+#endif
+
+/*****************************************************************************
+ * XOR
+ ****************************************************************************/
+static struct mv_xor_platform_shared_data armadaxp_xor_shared_data = {
+	.dram		= &armadaxp_mbus_dram_info,
+};
+
+static u64 armadaxp_xor_dmamask = DMA_BIT_MASK(32);
+
+/*****************************************************************************
+ * XOR0
+ ****************************************************************************/
+#ifdef XOR0_ENABLE
+static struct resource armadaxp_xor0_shared_resources[] = {
+	{
+		.name	= "xor 0 low",
+		.start	= XOR0_PHYS_BASE,
+		.end	= XOR0_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 0 high",
+		.start	= XOR0_HIGH_PHYS_BASE,
+		.end	= XOR0_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device armadaxp_xor0_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 0,
+	.dev		= {
+		.platform_data = &armadaxp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_xor0_shared_resources),
+	.resource	= armadaxp_xor0_shared_resources,
+};
+
+static struct resource armadaxp_xor00_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR00,
+		.end	= IRQ_AURORA_XOR00,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor00_data = {
+	.shared		= &armadaxp_xor0_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor00_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor00_resources),
+	.resource	= armadaxp_xor00_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &armadaxp_xor00_data,
+	},
+};
+
+static struct resource armadaxp_xor01_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR01,
+		.end	= IRQ_AURORA_XOR01,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor01_data = {
+	.shared		= &armadaxp_xor0_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor01_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor01_resources),
+	.resource	= armadaxp_xor01_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &armadaxp_xor01_data,
+	},
+};
+
+static void __init armadaxp_xor0_init(void)
+{
+	platform_device_register(&armadaxp_xor0_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	dma_cap_set(DMA_MEMCPY, armadaxp_xor00_data.cap_mask);
+	dma_cap_set(DMA_XOR, armadaxp_xor00_data.cap_mask);
+	platform_device_register(&armadaxp_xor00_channel);
+
+	dma_cap_set(DMA_MEMCPY, armadaxp_xor01_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, armadaxp_xor01_data.cap_mask);
+	dma_cap_set(DMA_XOR, armadaxp_xor01_data.cap_mask);
+	platform_device_register(&armadaxp_xor01_channel);
+}
+#endif
+
+/*****************************************************************************
+ * XOR1
+ ****************************************************************************/
+static struct resource armadaxp_xor1_shared_resources[] = {
+	{
+		.name	= "xor 1 low",
+		.start	= XOR1_PHYS_BASE,
+		.end	= XOR1_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "xor 1 high",
+		.start	= XOR1_HIGH_PHYS_BASE,
+		.end	= XOR1_HIGH_PHYS_BASE + 0xff,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device armadaxp_xor1_shared = {
+	.name		= MV_XOR_SHARED_NAME,
+	.id		= 1,
+	.dev		= {
+		.platform_data = &armadaxp_xor_shared_data,
+	},
+	.num_resources	= ARRAY_SIZE(armadaxp_xor1_shared_resources),
+	.resource	= armadaxp_xor1_shared_resources,
+};
+
+static struct resource armadaxp_xor10_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR10,
+		.end	= IRQ_AURORA_XOR10,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor10_data = {
+	.shared		= &armadaxp_xor1_shared,
+	.hw_id		= 0,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor10_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor10_resources),
+	.resource	= armadaxp_xor10_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &armadaxp_xor10_data,
+	},
+};
+
+static struct resource armadaxp_xor11_resources[] = {
+	[0] = {
+		.start	= IRQ_AURORA_XOR11,
+		.end	= IRQ_AURORA_XOR11,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct mv_xor_platform_data armadaxp_xor11_data = {
+	.shared		= &armadaxp_xor1_shared,
+	.hw_id		= 1,
+	.pool_size	= PAGE_SIZE,
+};
+
+static struct platform_device armadaxp_xor11_channel = {
+	.name		= MV_XOR_NAME,
+	.id		= 3,
+	.num_resources	= ARRAY_SIZE(armadaxp_xor11_resources),
+	.resource	= armadaxp_xor11_resources,
+	.dev		= {
+		.dma_mask		= &armadaxp_xor_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &armadaxp_xor11_data,
+	},
+};
+
+static void __init armadaxp_xor1_init(void)
+{
+	platform_device_register(&armadaxp_xor1_shared);
+
+	/*
+	 * two engines can't do memset simultaneously, this limitation
+	 * satisfied by removing memset support from one of the engines.
+	 */
+	//dma_cap_set(DMA_MEMCPY, armadaxp_xor10_data.cap_mask);
+	dma_cap_set(DMA_XOR, armadaxp_xor10_data.cap_mask);
+	platform_device_register(&armadaxp_xor10_channel);
+
+	dma_cap_set(DMA_MEMCPY, armadaxp_xor11_data.cap_mask);
+	dma_cap_set(DMA_MEMSET, armadaxp_xor11_data.cap_mask);
+	//dma_cap_set(DMA_XOR, armadaxp_xor11_data.cap_mask);
+	platform_device_register(&armadaxp_xor11_channel);
+}
+
+static void cpu_fabric_common_init(void)
+{
+	MV_U32	reg;
+
+#ifdef CONFIG_DEBUG_LL
+        check_cpu_mode();
+#endif
+
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+	printk("L0 cache Disabled (by Errata #4948)\n");
+#else
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (reg));
+	if (l0_disable_flag) {
+		printk("L0 cache Disabled\n");	
+		reg |= (1 << 0);
+	} else {
+		printk("L0 cache Enabled\n");
+		reg &= ~(1 << 0);
+	}
+	__asm volatile ("mcr p15, 1, %0, c15, c1, 0" : : "r" (reg));
+#endif
+
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+	printk("Speculative Prefetch Disabled (by Errata #5315)\n");
+#else
+	__asm volatile ("mrc p15, 1, %0, c15, c2, 0" : "=r" (reg));
+	if (sp_enable_flag) {
+		printk("Speculative Prefetch Enabled\n");
+		reg &= ~(1 << 7);
+	} else {
+		printk("Speculative Prefetch Disabled\n");
+		reg |= (1 << 7);
+	}
+	__asm volatile ("mcr p15, 1, %0, c15, c2, 0" : : "r" (reg));
+#endif
+
+#ifdef CONFIG_CACHE_AURORA_L2
+	if (!noL2)
+		aurora_l2_init((void __iomem *)(INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET));
+#endif
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+	printk("Support IO coherency.\n");
+	io_coherency_init();
+#endif
+}
+
+
+#ifdef CONFIG_MV_AMP_ENABLE
+static int mvAmpInitCpuIf()
+{
+	if(mvUnitMapIsMine(MSTR) == MV_TRUE){
+
+		if(mvReadAmpReg(ADR_WIN_EN_REG) != 0)
+			printk("Warning: AMP Address decode windows reg != 0\n");
+
+		if (mvCpuIfInit(mv_sys_map()) != MV_OK)
+			return 1;
+
+		mvWriteAmpReg(ADR_WIN_EN_REG, 1);
+		printk("Initialized Address decode windows\n");
+	}
+	else
+	{
+		// Wait until master initializes address decode windows
+		while(mvReadAmpReg(ADR_WIN_EN_REG) == 0){
+			udelay(1);
+		}
+
+		if(mvCpuIfVerify(mv_sys_map()) != MV_OK)
+			return 1;
+
+		/*verify window decode */
+		printk("Verified Address decode windows\n");
+	}
+
+	return 0;
+}
+#endif
+
+/*****************************************************************************
+ * DB BOARD: Restore from suspend to RAM
+ * ****************************************************************************/
+void axp_db_restore(void)
+{
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if (mvCtrlEnvInit()) {
+		pr_warn("Controller env initialization failed.\n");
+		return;
+	}
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if (mvCpuIfInit(mv_sys_map())) {
+		pr_warn("Cpu Interface initialization failed.\n");
+		return;
+	}
+
+	mvSysEthPhyInit();
+
+	/* TODO - timer should be restored by kernel hook */
+	axp_timer_resume();
+}
+
+/*****************************************************************************
+ * DB BOARD: Main Initialization
+ ****************************************************************************/
+static void __init axp_db_init(void)
+{
+#ifdef CONFIG_MV_AMP_ENABLE
+	/* Init Resource sharing */
+	if(mvUnitMapIsRsrcLimited() == MV_FALSE)
+		mvUnitMapSetAllMine();
+#endif
+
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+
+	/* Select appropriate Board ID for Machine */
+#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_REV_B0)
+	gBoardId = DB_88F78XX0_BP_REV2_ID;
+#else
+	gBoardId = DB_88F78XX0_BP_ID;
+#endif
+	/* Before initializing the HAL, select Z1A serdes cfg if needed */
+	if (support_Z1A_serdes_cfg)
+		mvBoardSerdesZ1ASupport();
+	/* Bypass serdes reconfiguration since already done at bootloader */
+        mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+#ifdef CONFIG_MV_AMP_ENABLE
+	if(mvAmpInitCpuIf()){
+#else
+	if(mvCpuIfInit(mv_sys_map())) {
+#endif
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+#ifndef CONFIG_MV_UART_PORT
+	serial_initialize(0);
+#else
+	serial_initialize(CONFIG_MV_UART_PORT);
+#endif
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	if(mvUnitMapIsMine(RTC) == MV_TRUE)
+		rtc_init();
+
+	/* SPI */
+	if(mvUnitMapIsMine(SPI) == MV_TRUE)
+		mvSysSpiInit(0, _16M);
+
+	/* ETH-PHY */
+	mvSysEthPhyInit();
+
+	/* Sata */
+#ifdef CONFIG_SATA_MV
+	if(mvUnitMapIsMine(SATA) == MV_TRUE)
+		armadaxp_sata_init(&dbdsmp_sata_data);
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+	/* NAND */
+	if(mvUnitMapIsMine(NAND) == MV_TRUE)
+		axp_db_nfc_init();
+#endif
+	/* HWMON */
+	if(mvUnitMapIsMine(HWMON) == MV_TRUE)
+		armadaxp_hwmon_init();
+
+	/* XOR */
+#ifdef XOR0_ENABLE
+	if(mvUnitMapIsMine(XOR0) == MV_TRUE)
+		armadaxp_xor0_init();
+#endif
+	if(mvUnitMapIsMine(XOR1) == MV_TRUE)
+		armadaxp_xor1_init();
+
+	/* I2C */
+	if(mvUnitMapIsMine(I2C0) == MV_TRUE)
+		platform_device_register(&axp_i2c0);
+
+#ifdef CONFIG_FB_DOVE
+      if ((lcd0_enable == 1) && (lcd_panel == 0 ) && (mvUnitMapIsMine(I2C1) == MV_TRUE))
+        platform_device_register(&axp_i2c1);
+#endif
+	/* SDIO */
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+	if(mvUnitMapIsMine(SDIO) == MV_TRUE)
+		sdio_initialize();
+#endif
+
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
+#ifdef CONFIG_MV_IPC_NET
+	platform_device_register(&mv_ipc_net);
+#endif
+
+#ifdef CONFIG_FB_DOVE
+	if(mvUnitMapIsMine(LCD) == MV_TRUE){
+		kw_lcd0_dmi.dram = &armadaxp_mbus_dram_info;
+		if (lcd_panel) {
+			kw_lcd0_dmi.lvds_info.enabled = 1;
+			kw_lcd0_dmi.fixed_full_div = 1;
+			kw_lcd0_dmi.full_div_val = 7;
+	//		kw_lcd0_dmi.lcd_ref_clk = 27000000;
+			printk(KERN_INFO "LCD Panel enabled.\n");
+		}
+		clcd_platform_init(&kw_lcd0_dmi, &kw_lcd0_vid_dmi, &dsmp_backlight_data);
+	}
+#endif
+
+	return;
+}
+
+#ifdef CONFIG_FB_DOVE
+/*
+ * This fixup function is used to reserve memory for the LCD engine
+ * as these drivers require large chunks of consecutive memory.
+ */
+void __init axp_tag_fixup_mem32(struct machine_desc *mdesc, struct tag *t,
+		char **from, struct meminfo *meminfo)
+{
+	struct tag *last_tag = NULL;
+	int total_size = PAGE_ALIGN(DEFAULT_FB_SIZE*4) * 2;
+	uint32_t memory_start;
+
+	for (; read_tag(t->hdr.size); t = tag_next(t))
+		if ((read_tag(t->hdr.tag) == ATAG_MEM) && ( read_tag(t->u.mem.size) >= total_size)) {
+			if ((last_tag == NULL) ||
+			    (read_tag(t->u.mem.start) > last_tag->u.mem.start))
+				last_tag = t;
+		}
+
+	if (last_tag == NULL) {
+		early_printk(KERN_WARNING "No suitable memory tag was found, "
+				"required memory %d MB.\n", total_size);
+		return;
+	}
+
+	/* Resereve memory from last tag for LCD usage.	*/
+	last_tag->u.mem.size -= total_size;
+	memory_start = last_tag->u.mem.start + last_tag->u.mem.size;
+
+	kw_lcd0_dmi.fb_mem[0] = (void*)memory_start;
+	kw_lcd0_dmi.fb_mem_size[0] = total_size / 2;
+	kw_lcd0_dmi.fb_mem[1] = (void*)(memory_start + kw_lcd0_dmi.fb_mem_size[0]);
+	kw_lcd0_dmi.fb_mem_size[1] = total_size / 2;
+
+}
+#endif /* CONFIG_FB_DOVE */
+
+
+MACHINE_START(ARMADA_XP_DB, "Marvell Armada XP Development Board")
+	/* MAINTAINER("MARVELL") */
+	.atag_offset	= BOOT_PARAMS_OFFSET,
+	.map_io		= axp_map_io,
+	.init_irq	= axp_init_irq,
+	.timer		= &axp_timer,
+	.init_machine	= axp_db_init,
+#ifdef CONFIG_FB_DOVE
+	/* reserve memory for LCD */
+	.fixup		= axp_tag_fixup_mem32,
+#endif /* CONFIG_FB_DOVE */
+MACHINE_END
+
+/*****************************************************************************
+ * GP BOARD
+ ****************************************************************************/
+static void __init axp_gp_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Select appropriate Board ID for Machine */
+	gBoardId = RD_78460_GP_ID;
+
+	/* Bypass serdes reconfiguration since already done at bootloader */
+        mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	/* SPI */
+	mvSysSpiInit(0, _16M);
+
+	/* ETH-PHY */
+	mvSysEthPhyInit();
+
+	/* Sata */
+#ifdef CONFIG_SATA_MV
+	armadaxp_sata_init(&dbdsmp_sata_data);
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+	/* NAND */
+	axp_db_nfc_init();
+#endif
+	/* HWMON */
+	armadaxp_hwmon_init();
+
+	/* XOR */
+#ifdef XOR0_ENABLE
+	armadaxp_xor0_init();
+#endif
+	armadaxp_xor1_init();
+
+	/* I2C */
+	platform_device_register(&axp_i2c0);
+
+
+#ifdef CONFIG_FB_DOVE
+      if ((lcd0_enable == 1) && (lcd_panel == 0 ))
+        platform_device_register(&axp_i2c1);
+#endif
+
+
+
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		static MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+			irq_int_type[mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT)+IRQ_AURORA_GPIO_START] = GPP_IRQ_TYPE_CHANGE_LEVEL;
+		}
+
+		if(mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+       }
+#endif
+
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
+#ifdef CONFIG_FB_DOVE
+	kw_lcd0_dmi.dram = &armadaxp_mbus_dram_info;
+	if (lcd_panel) {
+		kw_lcd0_dmi.lvds_info.enabled = 1;
+		kw_lcd0_dmi.fixed_full_div = 1;
+		kw_lcd0_dmi.full_div_val = 7;
+//		kw_lcd0_dmi.lcd_ref_clk = 27000000;
+		printk(KERN_INFO "LCD Panel enabled.\n");
+	}
+	clcd_platform_init(&kw_lcd0_dmi, &kw_lcd0_vid_dmi, &dsmp_backlight_data);
+#endif
+
+	return;
+}
+
+MACHINE_START(ARMADA_XP_GP, "Marvell Armada XP GP Board")
+	/* MAINTAINER("MARVELL") */
+	.atag_offset	= 0x00000100,
+	.map_io		= axp_map_io,
+	.init_irq	= axp_init_irq,
+	.timer		= &axp_timer,
+	.init_machine	= axp_gp_init,
+#ifdef CONFIG_FB_DOVE
+	/* reserve memory for LCD */
+	.fixup		= axp_tag_fixup_mem32,
+#endif /* CONFIG_FB_DOVE */
+MACHINE_END
+
+/*****************************************************************************
+ * RD NAS BOARD
+ ****************************************************************************/
+static void __init axp_rd_nas_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Select appropriate Board ID for Machine */
+	gBoardId = RD_78460_NAS_ID;
+
+	/* Bypass serdes reconfiguration since already done at bootloader */
+        mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	/* SPI */
+	mvSysSpiInit(0, _16M);
+
+	/* ETH-PHY */
+	mvSysEthPhyInit();
+
+	/* Sata */
+#ifdef CONFIG_SATA_MV
+	armadaxp_sata_init(&dbdsmp_sata_data);
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+	/* NAND */
+	axp_db_nfc_init();
+#endif
+	/* HWMON */
+	armadaxp_hwmon_init();
+
+	/* XOR */
+#ifdef XOR0_ENABLE
+	armadaxp_xor0_init();
+#endif
+	armadaxp_xor1_init();
+
+	/* I2C */
+	platform_device_register(&axp_i2c0);
+
+
+#ifdef CONFIG_FB_DOVE
+      if ((lcd0_enable == 1) && (lcd_panel == 0 ))
+        platform_device_register(&axp_i2c1);
+#endif
+
+
+
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+			irq_int_type[mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT)+IRQ_AURORA_GPIO_START] = GPP_IRQ_TYPE_CHANGE_LEVEL;
+		}
+
+		if(mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+       }
+#endif
+
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
+#ifdef CONFIG_FB_DOVE
+	kw_lcd0_dmi.dram = &armadaxp_mbus_dram_info;
+	if (lcd_panel) {
+		kw_lcd0_dmi.lvds_info.enabled = 1;
+		kw_lcd0_dmi.fixed_full_div = 1;
+		kw_lcd0_dmi.full_div_val = 7;
+//		kw_lcd0_dmi.lcd_ref_clk = 27000000;
+		printk(KERN_INFO "LCD Panel enabled.\n");
+	}
+	clcd_platform_init(&kw_lcd0_dmi, &kw_lcd0_vid_dmi, &dsmp_backlight_data);
+#endif
+
+	return;
+}
+
+MACHINE_START(ARMADA_XP_RD_NAS, "Marvell Armada XP RD NAS Board")
+	/* MAINTAINER("MARVELL") */
+	.atag_offset	= 0x00000100,
+	.map_io		= axp_map_io,
+	.init_irq	= axp_init_irq,
+	.timer		= &axp_timer,
+	.init_machine	= axp_rd_nas_init,
+#ifdef CONFIG_FB_DOVE
+	/* reserve memory for LCD */
+	.fixup		= axp_tag_fixup_mem32,
+#endif /* CONFIG_FB_DOVE */
+MACHINE_END
+
+
+/*****************************************************************************
+* RDSRV BOARD: Main Initialization
+ ****************************************************************************/
+static void __init axp_rdsrv_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Select appropriate Board ID for Machine */
+#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_REV_B0)
+	gBoardId = RD_78460_SERVER_ID;
+#else
+	gBoardId = RD_78460_SERVER_ID;
+#endif
+	/* Bypass serdes reconfiguration since already done at bootloader */
+        mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	/* SPI */
+	mvSysSpiInit(0, _16M);
+
+	/* ETH-PHY */
+	mvSysEthPhyInit();
+
+	/* Sata */
+#ifdef CONFIG_SATA_MV
+	armadaxp_sata_init(&dbdsmp_sata_data);
+#endif
+
+	/* HWMON */
+	armadaxp_hwmon_init();
+
+	/* I2C */
+	platform_device_register(&axp_i2c0);
+
+#if defined(CONFIG_MV_INCLUDE_SDIO)
+	if (MV_TRUE == mvCtrlPwrClckGet(SDIO_UNIT_ID, 0)) {
+		int irq_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+		MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+
+		if (irq_detect != MV_ERROR) {
+			mvsdio_data.gpio_card_detect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT);
+			irq_int_type[mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_DETECT)+IRQ_AURORA_GPIO_START] = GPP_IRQ_TYPE_CHANGE_LEVEL;
+		}
+
+		if(mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP) != MV_ERROR)
+			mvsdio_data.gpio_write_protect = mvBoardSDIOGpioPinGet(BOARD_GPP_SDIO_WP);
+
+		if(MV_OK == mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1))
+			if (MV_OK == mvSdmmcWinInit(addrWinMap))
+				mvsdio_data.clock = mvBoardTclkGet();
+		platform_device_register(&mv_sdio_plat);
+	}
+#endif
+
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
+	return;
+}
+
+MACHINE_START(ARMADA_XP_RDSRV, "Marvell Armada XP Server Board")
+		/* MAINTAINER("MARVELL") */
+	.atag_offset	= BOOT_PARAMS_OFFSET,
+	 .map_io	= axp_map_io,
+  	.init_irq	= axp_init_irq,
+  	.timer		= &axp_timer,
+  	.init_machine	= axp_rdsrv_init,
+  MACHINE_END
+
+/*****************************************************************************
+ * FPGA BOARD: Main Initialization
+ ****************************************************************************/
+extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
+static void __init axp_fpga_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Select appropriate Board ID for Machine */
+	gBoardId = FPGA_88F78XX0_ID;
+	/* Bypass serdes reconfiguration since already done at bootloader */
+        mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+        /* init the Board environment */
+       	mvBoardEnvInit();
+
+        /* init the controller environment */
+        if( mvCtrlEnvInit() ) {
+            printk( "Controller env initialization failed.\n" );
+            return;
+        }
+	
+	/* Replace PCI-0 Attribute for FPGA 0xE => 0xD */
+	mvTargetDefaultsArray[PEX0_MEM].attrib = 0xD8;
+
+	/* Init the CPU windows setting and the access protection windows. */
+	/*if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}*/
+
+	armadaxp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+    	/* Init Tclk & SysClk */
+    	mvTclk = mvBoardTclkGet();
+   	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	return;
+}
+
+MACHINE_START(ARMADA_XP_FPGA, "Marvell Armada XP FPGA Board")
+	.atag_offset	= 0x00000100,
+	.map_io		= axp_map_io,
+	.init_irq	= axp_init_irq,
+	.timer		= &axp_timer,
+	.init_machine	= axp_fpga_init,
+MACHINE_END
diff --git a/arch/arm/mach-armadaxp/dump_cp15_regs.c b/arch/arm/mach-armadaxp/dump_cp15_regs.c
new file mode 100644
index 0000000..bc4901e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/dump_cp15_regs.c
@@ -0,0 +1,219 @@
+/*
+ * arch/arm/mach-dove/dump_cp15_regs.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+static int
+proc_dump_cp15_read(char *page, char **start, off_t off, int count, int *eof,
+			void *data)
+{
+	char *p = page;
+	int len;
+	unsigned int value;
+	
+	asm volatile("mrc p15, 0, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Main ID: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Cache Type: 0x%08x\n", value);
+	
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 2": "=r"(value));
+	p += sprintf(p, "TCM Type: 0x%08x\n", value);
+#endif	
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3": "=r"(value));
+	p += sprintf(p, "TLB Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 5": "=r"(value));
+	p += sprintf(p, "Microprocessor ID: 0x%08x\n", value);
+#endif	
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0": "=r"(value));
+	p += sprintf(p, "Processor Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 1": "=r"(value));
+	p += sprintf(p, "Processor Feature 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 2": "=r"(value));
+	p += sprintf(p, "Debug Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 3": "=r"(value));
+	p += sprintf(p, "Auxiliary Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 4": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 5": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 6": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 3: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 0": "=r"(value));
+	p += sprintf(p, "Set Attribute 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 1": "=r"(value));
+	p += sprintf(p, "Set Attribute 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 2": "=r"(value));
+	p += sprintf(p, "Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3": "=r"(value));
+	p += sprintf(p, "Set Attribute 3: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 4": "=r"(value));
+	p += sprintf(p, "Set Attribute 4: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 5": "=r"(value));
+	p += sprintf(p, "Set Attribute 5: 0x%08x\n", value);
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 1, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Current Cache Size ID: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 1, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 7": "=r"(value));
+	p += sprintf(p, "Silicon ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Cache Size Selection: 0x%08x\n", value);
+
+#endif
+	asm volatile("mrc p15, 0, %0, c1, c0, 0": "=r"(value));
+	p += sprintf(p, "Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2": "=r"(value));
+	p += sprintf(p, "Coprocessor Access Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c1, c1, 0": "=r"(value));
+	p += sprintf(p, "Secure Configuration : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 0": "=r"(value));
+	p += sprintf(p, "Translation Table Base 0 : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c2, c0, 1": "=r"(value));
+	p += sprintf(p, "Translation Table Base 1 : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c2, c0, 2": "=r"(value));
+	p += sprintf(p, "Translation Table Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c3, c0, 0": "=r"(value));
+	p += sprintf(p, "Domain Access Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c5, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1": "=r"(value));
+	p += sprintf(p, "Instruction Fault Status : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c6, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 1": "=r"(value));
+	p += sprintf(p, "Watchpoint Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2": "=r"(value));
+	p += sprintf(p, "Instruction Fault Address : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c7, c10, 6": "=r"(value));
+	p += sprintf(p, "Cache Dirty Status: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 1: 0x%08x\n", value);
+
+#if 1
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Control Configuration: 0x%08x\n", value);
+	p += sprintf(p, "    Write Buffer Coalescing\t: %s\n", (value & (1 << 8)) ?
+		     "Enabled" : "Disabled");
+	if (value & (1 << 8))
+		p += sprintf(p, "    WB WAIT CYC\t: 0x%x\n", (value >> 9) & 0x7);
+
+	p += sprintf(p, "    Coprocessor dual issue \t: %s\n", (value & (1 << 15)) ?
+		     "Disabled" : "Enabled");
+
+	p += sprintf(p, "    L2 write allocate\t: %s\n", (value & (1 << 28)) ?
+		     "Enabled" : "Disabled");
+
+	p += sprintf(p, "    Streaming\t: %s\n", (value & (1 << 29)) ?
+		     "Enabled" : "Disabled");
+#endif	
+	asm volatile("mrc p15, 1, %0, c15, c12, 0": "=r"(value));
+	p += sprintf(p, "CPU ID Code Extension: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c9, c14, 0": "=r"(value));
+	p += sprintf(p, "User mode access for PMC registers: %s\n", (value & 1) ?
+		     "Enabled" : "Disabled");
+	asm volatile("mrc p15, 0, %0, c10, c2, 0": "=r"(value));
+	p += sprintf(p, "Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1": "=r"(value));
+	p += sprintf(p, "Memory Attribute NMRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 2": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 1: 0x%08x\n", value);
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+	
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+int dump_init_module(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	res = create_proc_entry("mv_dump_cp15", S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+
+	res->read_proc = proc_dump_cp15_read;
+#endif
+
+	return 0;
+}
+
+void dump_cleanup_module(void)
+{
+	remove_proc_entry("mv_dump_cp15", NULL);
+}
+
+module_init(dump_init_module);
+module_exit(dump_cleanup_module);
+
+MODULE_AUTHOR("Saeed Bishara");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-armadaxp/export.c b/arch/arm/mach-armadaxp/export.c
new file mode 100644
index 0000000..92733f0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/export.c
@@ -0,0 +1,215 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvOs.h"
+
+
+/*************************************************************************************************************
+ * Environment 
+ *************************************************************************************************************/
+extern u32 mvTclk;
+extern u32 mvSysclk;
+
+EXPORT_SYMBOL(mv_early_printk);
+EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlModelRevGet);
+EXPORT_SYMBOL(mvTclk);
+EXPORT_SYMBOL(mvSysclk);
+EXPORT_SYMBOL(mvCtrlModelGet);
+EXPORT_SYMBOL(mvOsIoUncachedMalloc);
+EXPORT_SYMBOL(mvOsIoUncachedFree);
+EXPORT_SYMBOL(mvOsIoCachedMalloc);
+EXPORT_SYMBOL(mvOsIoCachedFree);
+EXPORT_SYMBOL(mvDebugMemDump);
+EXPORT_SYMBOL(mvHexToBin);
+EXPORT_SYMBOL(mvBinToHex);
+EXPORT_SYMBOL(mvSizePrint);
+EXPORT_SYMBOL(mvDebugPrintMacAddr);
+EXPORT_SYMBOL(mvCtrlEthMaxPortGet);
+EXPORT_SYMBOL(mvCtrlTargetNameGet);
+EXPORT_SYMBOL(mvBoardIdGet);
+EXPORT_SYMBOL(mvBoardPhyAddrGet);
+EXPORT_SYMBOL(mvCpuIfTargetWinGet);
+EXPORT_SYMBOL(mvMacStrToHex);
+EXPORT_SYMBOL(mvBoardTclkGet);
+EXPORT_SYMBOL(mvBoardMacSpeedGet);
+EXPORT_SYMBOL(mvWinOverlapTest);
+EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
+EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
+EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
+EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+
+#include "spi/mvSpiCmnd.h"
+EXPORT_SYMBOL(mvSpiWriteThenWrite);
+EXPORT_SYMBOL(mvSpiWriteThenRead);
+#include "spi/mvSpi.h"
+EXPORT_SYMBOL(mvSpiParamsSet);
+#include "gpp/mvGpp.h"
+EXPORT_SYMBOL(mvGppValueSet);
+
+/*************************************************************************************************************
+ * TDM
+ *************************************************************************************************************/
+#if defined(MV_INCLUDE_TDM)
+EXPORT_SYMBOL(mvCtrlTdmUnitIrqGet);
+EXPORT_SYMBOL(mvCtrlTdmUnitTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * Audio
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#include "audio/mvAudio.h"
+#include "mvSysAudioApi.h"
+EXPORT_SYMBOL(mvSPDIFRecordTclockSet);
+EXPORT_SYMBOL(mvSPDIFPlaybackCtrlSet);
+EXPORT_SYMBOL(mvI2SPlaybackCtrlSet);
+EXPORT_SYMBOL(mvAudioPlaybackControlSet);
+EXPORT_SYMBOL(mvAudioDCOCtrlSet);
+EXPORT_SYMBOL(mvI2SRecordCntrlSet);
+EXPORT_SYMBOL(mvAudioRecordControlSet);
+EXPORT_SYMBOL(mvSysAudioInit);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrGet);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * USB
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+extern u32 mvIsUsbHost;
+
+#include "usb/mvUsb.h"
+EXPORT_SYMBOL(mvIsUsbHost);
+EXPORT_SYMBOL(mvCtrlUsbMaxGet);
+EXPORT_SYMBOL(mvUsbGetCapRegAddr);
+#ifdef MV_USB_VOLTAGE_FIX
+EXPORT_SYMBOL(mvUsbGppInit);
+EXPORT_SYMBOL(mvUsbBackVoltageUpdate);
+#endif
+#endif /* CONFIG_MV_INCLUDE_USB */
+
+/*************************************************************************************************************
+ * CESA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+#include "mvSysCesaApi.h"
+#include "cesa/mvCesa.h"
+#include "cesa/mvMD5.h"
+#include "cesa/mvSHA1.h"
+extern unsigned char*  mv_sram_usage_get(int* sram_size_ptr);
+
+EXPORT_SYMBOL(mvSysCesaInit);
+EXPORT_SYMBOL(mvCesaSessionOpen);
+EXPORT_SYMBOL(mvCesaSessionClose);
+EXPORT_SYMBOL(mvCesaAction);
+EXPORT_SYMBOL(mvCesaReadyGet);
+EXPORT_SYMBOL(mvCesaCopyFromMbuf);
+EXPORT_SYMBOL(mvCesaCopyToMbuf);
+EXPORT_SYMBOL(mvCesaMbufCopy);
+EXPORT_SYMBOL(mvCesaCryptoIvSet);
+EXPORT_SYMBOL(mvMD5);
+EXPORT_SYMBOL(mvSHA1);
+
+EXPORT_SYMBOL(mvCesaDebugQueue);
+EXPORT_SYMBOL(mvCesaDebugSram);
+EXPORT_SYMBOL(mvCesaDebugSAD);
+EXPORT_SYMBOL(mvCesaDebugStatus);
+EXPORT_SYMBOL(mvCesaDebugMbuf);
+EXPORT_SYMBOL(mvCesaDebugSA);
+EXPORT_SYMBOL(mv_sram_usage_get);
+
+extern u32 mv_crypto_virt_base_get(void);
+extern u32 mv_crypto_phys_base_get(void);
+EXPORT_SYMBOL(mv_crypto_virt_base_get);
+EXPORT_SYMBOL(mv_crypto_phys_base_get);
+EXPORT_SYMBOL(cesaReqResources);
+EXPORT_SYMBOL(mvCesaFinish);
+
+#endif
+
+/*************************************************************************************************************
+ * Flashes
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_INCLUDE_SPI)
+#include <sflash/mvSFlash.h>
+#include <sflash/mvSFlashSpec.h>
+EXPORT_SYMBOL(mvSFlashInit);
+EXPORT_SYMBOL(mvSFlashSectorErase);
+EXPORT_SYMBOL(mvSFlashChipErase);
+EXPORT_SYMBOL(mvSFlashBlockRd);
+EXPORT_SYMBOL(mvSFlashBlockWr);
+EXPORT_SYMBOL(mvSFlashIdGet);
+EXPORT_SYMBOL(mvSFlashWpRegionSet);
+EXPORT_SYMBOL(mvSFlashWpRegionGet);
+EXPORT_SYMBOL(mvSFlashStatRegLock);
+EXPORT_SYMBOL(mvSFlashSizeGet);
+EXPORT_SYMBOL(mvSFlashPowerSaveEnter);
+EXPORT_SYMBOL(mvSFlashPowerSaveExit);
+EXPORT_SYMBOL(mvSFlashModelGet);
+#endif
+
+
+/*************************************************************************************************************
+ * SATA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#include <sata/CoreDriver/mvSata.h>
+EXPORT_SYMBOL(mvSataWinInit);
+#endif
+
+/*************************************************************************************************************
+ * DMA/XOR
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_XOR_MEMCOPY) || defined (CONFIG_MV_IDMA_MEMCOPY)
+EXPORT_SYMBOL(asm_memcpy);
+#endif
+
+#ifdef CONFIG_MV_SP_I_FTCH_DB_INV 
+EXPORT_SYMBOL(mv_l2_inv_range);
+#endif
+
+/*************************************************************************************************************
+ * Marvell TRACE
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_DBG_TRACE
+#include "dbg-trace.h"
+EXPORT_SYMBOL(TRC_INIT);
+EXPORT_SYMBOL(TRC_REC);
+EXPORT_SYMBOL(TRC_OUTPUT);
+EXPORT_SYMBOL(TRC_START);
+EXPORT_SYMBOL(TRC_RELEASE);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_MODULE
+#ifdef CONFIG_MV_ETH_BM
+#include "bm/mvBm.h"
+EXPORT_SYMBOL(mvBmVirtBase);
+#endif
+#include "mvList.h"
+EXPORT_SYMBOL(mvListCreate);
+EXPORT_SYMBOL(mvListDestroy);
+#endif
diff --git a/arch/arm/mach-armadaxp/flashmap.c b/arch/arm/mach-armadaxp/flashmap.c
new file mode 100644
index 0000000..d3569ef
--- /dev/null
+++ b/arch/arm/mach-armadaxp/flashmap.c
@@ -0,0 +1,255 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <drivers/mtd/mtdcore.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+#define MTD_FLASH_MAP_DEBUG
+
+#ifdef MTD_FLASH_MAP_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+#define MTD_MAX_FLASH_NUMBER	4
+#define MTD_DUMMY_BANK_WIDTH	2
+
+struct maps_init_info
+{
+	struct map_info mapInfo;
+	char ** mtdDrv;
+	struct mtd_info * mtdInfo;
+	char name[32];
+};
+
+static struct maps_init_info maps[MTD_MAX_FLASH_NUMBER];
+static unsigned int mapsNum = 0;
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+static char * cfiDev = "cfi_flash";
+static char * cfiMtdList[] = { "cfi_probe", NULL };
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+static char * sflashDev = "spi_flash";
+static char * sflashMtdList[] = {"sflash", NULL};
+#endif
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static struct mtd_partition *mtd_parts;
+static int                   mtd_parts_nb;
+static const char *part_probes[] __initdata = {"cmdlinepart", NULL};
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+static int flashInfoFill(void)
+{
+	int expectedDevs = 0;
+	int devs, i;
+
+	/* clear the whole array */
+	memset((void*)maps, 0x0, sizeof(maps));
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+	/* gather the CFI and JEDEC NOR flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_NOR_FLASH);
+
+	for(i=0; i<devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = cfiMtdList;	
+		sprintf(maps[expectedDevs].name, "%s_%d", cfiDev, i);
+		maps[expectedDevs].mapInfo.name = maps[expectedDevs].name;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = (mvBoardGetDeviceBusWidth(i, BOARD_DEV_NOR_FLASH) / 8);
+		
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) && 
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d", maps[expectedDevs].mapInfo.name, i,
+			   (unsigned int)maps[expectedDevs].mapInfo.phys, (unsigned int)maps[expectedDevs].mapInfo.size, maps[expectedDevs].mapInfo.bankwidth));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)", __FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+	
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+	/* gather the SPI flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_SPI_FLASH);
+
+	for(i=0; i<devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = sflashMtdList;
+		maps[expectedDevs].mapInfo.name = sflashDev;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = MTD_DUMMY_BANK_WIDTH;
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) && 
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+						(unsigned int)maps[expectedDevs].mapInfo.phys,
+						(unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+					__FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+	DB(printk("\nINFO: %s - Found %d Flash Devices", __FUNCTION__, expectedDevs));
+	return expectedDevs;
+}
+
+static int __init flashProbe(char ** mtdDrv, struct map_info * map, struct mtd_info ** mtd)
+{
+	if ((mtdDrv == NULL) || (map == NULL) || (mtd == NULL)) {
+		printk(KERN_NOTICE "\nERROR: NULL pointer parameter at %s entry", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* remap the physical address to a virtual address */
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt) {
+		printk(KERN_NOTICE "\nERROR: Failed to ioremap Flash device at physical base 0x%x.", (unsigned int)map->phys);
+		return -EIO;
+	}
+	
+	DB(printk("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+				(unsigned int)map->phys, (unsigned int)map->virt));
+
+	simple_map_init(map);
+
+	*mtd = NULL;
+	for(; (!(*mtd) && *mtdDrv); mtdDrv++) {
+		DB(printk("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+					*mtdDrv, map->name, (unsigned int)map->phys,
+					(unsigned int)map->size, map->bankwidth));
+		if ((*mtd = do_map_probe(*mtdDrv, map))) {
+			DB(printk(" - detected OK"));
+			/*map->size = (*mtd)->size;*/
+			(*mtd)->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0);
+
+			if (mtd_parts_nb > 0) {
+				add_mtd_partitions (*mtd, mtd_parts, mtd_parts_nb);
+				return 0;
+			}
+#endif
+
+			if (/*add_mtd_device(*mtd) != 0*/mtd_device_register(*mtd, NULL,0)){
+				printk(KERN_NOTICE "\nERROR: %s - Failed to add the mtd device", __FUNCTION__);
+				iounmap((void *)map->virt);
+				map->virt = 0;
+				return -ENXIO;
+			}
+
+			return 0;
+		} else {
+			DB(printk(" - Not detected"));
+		}
+	}
+ 
+	iounmap((void *)map->virt);
+	map->virt = 0;
+	return -ENXIO;
+}
+	
+static int __init flash_map_init(void)
+{	
+	int i;
+
+	if(mvUnitMapIsMine(SPI) == MV_FALSE)
+		return 0;
+
+	mapsNum = flashInfoFill();
+	DB(printk("\nINFO: flash_map_init - detected %d devices\n",  mapsNum));
+
+	for (i=0; i<mapsNum; i++) {
+		DB(printk("MTD: Initialize the %s device at address 0x%08x\n", maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
+		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0) {
+			DB(printk(" - OK.\n"));
+		} else {
+			maps[i].mtdInfo = NULL;
+			DB(printk(" - FAILED!\n"));
+		}
+	}
+
+	return 0;
+}
+
+static void __exit flash_map_exit(void)
+{
+	int i;
+
+	for (i=0; i<mapsNum; i++) {
+		if (maps[i].mtdInfo) {
+			//del_mtd_device(maps[i].mtdInfo);
+			  mtd_device_unregister(maps[i].mtdInfo);
+			map_destroy(maps[i].mtdInfo);
+		}
+
+		if (maps[i].mapInfo.virt) {
+			iounmap((void *)maps[i].mapInfo.virt);
+			maps[i].mapInfo.virt = 0;
+		}
+	}
+}
+
+module_init(flash_map_init);
+module_exit(flash_map_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for Marvell platforms");
diff --git a/arch/arm/mach-armadaxp/headsmp.S b/arch/arm/mach-armadaxp/headsmp.S
new file mode 100644
index 0000000..e58dd2d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/headsmp.S
@@ -0,0 +1,92 @@
+/*
+ *  linux/arch/arm/mach-armadaxp/headsmp.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/memory.h>
+
+	__INIT
+
+/*
+ * specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(axp_secondary_startup)
+#ifdef CONFIG_CPU_ENDIAN_BE32
+        /* convert CPU to big endian */
+        .word 0x100f11ee /* mrc p15, 0, r0, c1, c0 */
+        .word 0x800080e3 /* orr r0, r0, #0x80 */
+        .word 0x100f01ee /* mcr p15, 0, r0, c1, c0 */
+#endif
+#ifdef CONFIG_BE8_ON_LE
+        setend  be
+#endif
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+	/*
+	 * Disable L0 on secondary CPU if flag set
+	 */
+	adr	r7, l0_disable_flag_addr
+	ldr	r7, [r7]
+	sub	r7, r7, #(PAGE_OFFSET - PLAT_PHYS_OFFSET)
+	ldr	r7, [r7]
+	cmp	r7, #0
+	beq	l0_dis_skip
+	mrc	p15, 1, r7, c15, c1, 0
+	orr	r7, r7, #0x1
+	mcr	p15, 1, r7, c15, c1, 0
+l0_dis_skip:
+#endif
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+	/*
+	 * Speculative prefetch on secondary CPU if flag set
+	 * Auxiliary Functional Modes Control 0 Register
+	 * Bit[7]: 0-Enable, 1-Disable (reset default)
+	 */
+	adr	r7, sp_enable_flag_addr
+	ldr	r7, [r7]
+	sub	r7, r7, #(PAGE_OFFSET - PLAT_PHYS_OFFSET)
+	ldr	r7, [r7]
+	cmp	r7, #0
+	beq	sp_ena_skip
+	mrc	p15, 1, r7, c15, c2, 0
+	bic	r7, r7, #(1 << 7)
+	mcr	p15, 1, r7, c15, c2, 0	
+sp_ena_skip:
+#endif
+pen:
+#if __LINUX_ARM_ARCH__ >= 7
+	dsb
+#else
+	 mcr p15, 0, r0, c7, c10, 4
+#endif
+	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+1:	.long	.
+	.long	pen_release
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+l0_disable_flag_addr:
+	.word	l0_disable_flag
+#endif
+#ifndef CONFIG_SHEEVA_ERRATA_ARM_CPU_5315
+sp_enable_flag_addr:
+	.word	sp_enable_flag
+#endif
diff --git a/arch/arm/mach-armadaxp/hwmon.c b/arch/arm/mach-armadaxp/hwmon.c
new file mode 100644
index 0000000..eb87175
--- /dev/null
+++ b/arch/arm/mach-armadaxp/hwmon.c
@@ -0,0 +1,399 @@
+/*
+ * hwmon-axp.c - temperature monitoring driver for Dove SoC
+ *
+ * Inspired from other hwmon drivers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG				0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+
+#define ARMADAXP_OVERHEAT_TEMP	105		/* milidegree Celsius */
+#define ARMADAXP_OVERHEAT_DELAY	0x700
+#define ARMADAXP_OVERCOOL_TEMP	10		/* milidegree Celsius */
+#define	ARMADAXP_OVERCOOL_DELAY	0x700
+#define ARMADAXP_OVERHEAT_MIN	0
+#define ARMADAXP_OVERHEAT_MAX	110000
+#define ARMADAXP_OVERCOOL_MIN	0
+#define ARMADAXP_OVERCOOL_MAX	110000
+#define PMU_THERMAL_MNGR_REG	0x184c4
+#define	PMU_INT_MASK_REG        0x1C124
+#define	PMU_INT_CAUSE_REG	0x1c120
+#define PMU_INT_OVRHEAT_MASK	0x1
+#define PMU_INT_COOLING_MASK	0x2
+
+#define PMU_TM_COOL_THRSH_OFFS          10
+#define PMU_TM_COOL_THRSH_MASK          (0x1FF << PMU_TM_COOL_THRSH_OFFS)
+#define PMU_TM_OVRHEAT_THRSH_OFFS       19
+#define PMU_TM_OVRHEAT_THRSH_MASK       (0x1FF << PMU_TM_OVRHEAT_THRSH_OFFS)
+
+#define PMU_TM_DISABLE_OFFS             0
+#define PMU_TM_DISABLE_MASK             (0x1 << PMU_TM_DISABLE_OFFS)
+
+
+#define	PMU_TM_OVRHEAT_DLY_REG  0x184cc
+#define	PMU_TM_COOLING_DLY_REG	0x184c8
+
+/* Junction Temperature */
+#define ARMADAXP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define ARMADAXP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+
+#define LABEL "T-junction"
+static struct device *hwmon_dev;
+unsigned int temp_min = ARMADAXP_OVERCOOL_TEMP;
+unsigned int temp_max = ARMADAXP_OVERHEAT_TEMP;
+
+typedef enum {
+	SHOW_TEMP,
+	TEMP_MAX,
+	TEMP_MIN,
+	SHOW_NAME,
+	SHOW_TYPE,
+	SHOW_LABEL } SHOW;
+
+static void axptemp_set_thresholds(unsigned int max, unsigned int min)
+{
+	u32 temp, reg;
+
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+        reg &= ~PMU_TM_DISABLE_MASK;
+        writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the overheat threashold & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(max);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
+	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the cool threshole & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(min);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_COOL_THRSH_MASK;
+	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+}
+
+static int axptemp_init_sensor(void)
+{
+	u32 reg;
+
+	/* init the TSEN sensor once */
+	/* Enable On-The-Fly Calibration mode */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_OTF_CALIB_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Set the Reference Count value */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_REF_CAL_MASK);
+	reg |= (0xf1 << 11);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Do not start calibration sequence */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_START_CALIB_MASK);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Initiate Soft Reset
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_SOFT_RESET_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	*/
+	//udelay(1000);
+
+	/* Exit from Soft Reset
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	*/
+	//udelay(10000);
+
+
+	/* Set thresholds */
+	axptemp_set_thresholds(temp_max, temp_min);
+
+	/* Set delays */
+	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_BASE | PMU_TM_COOLING_DLY_REG));
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel(0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	return 0;
+}
+
+static int axptemp_read_temp(void)
+{
+	int reg;
+
+	reg = readl(INTER_REGS_BASE | TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+	return ARMADAXP_TSEN_RAW2TEMP(reg);
+}
+
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			  *devattr, char *buf) {
+	return sprintf(buf, "%s\n", "axp-hwmon");
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+
+	int alarm = 0;
+	u32 reg;
+
+	reg = readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG);
+	if (reg & PMU_INT_OVRHEAT_MASK)
+	{
+		alarm = 1;
+		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+	else if (reg & PMU_INT_COOLING_MASK)
+	{
+		alarm = 2;
+		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+
+	return sprintf(buf, "%d\n", alarm);
+}
+
+static ssize_t show_info(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TYPE)
+		ret = sprintf(buf, "%d\n", 3);
+	else if (attr->index == SHOW_LABEL)
+		ret = sprintf(buf, "%s\n", LABEL);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+	return ret;
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TEMP)
+		ret = sprintf(buf, "%d \n", axptemp_read_temp());
+	else if (attr->index == TEMP_MAX)
+		ret = sprintf(buf, "%d\n", temp_max);
+	else if (attr->index == TEMP_MIN)
+		ret = sprintf(buf, "%d\n", temp_min);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+
+	return ret;
+}
+
+static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
+			 const char *buf, size_t count) {
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	unsigned int temp;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		printk(KERN_WARNING "Invalid input string for temperature!");
+
+	if (attr->index == TEMP_MAX) {
+		if((temp < ARMADAXP_OVERHEAT_MIN) || (temp > ARMADAXP_OVERHEAT_MAX))
+			printk(KERN_WARNING "Invalid max temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERHEAT_MIN, ARMADAXP_OVERHEAT_MAX);
+		else {
+			temp_max = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else if (attr->index == TEMP_MIN) {
+		if((temp < ARMADAXP_OVERCOOL_MIN) || (temp > ARMADAXP_OVERCOOL_MAX))
+			printk(KERN_WARNING "Invalid min temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERCOOL_MIN, ARMADAXP_OVERCOOL_MAX);
+		else {
+			temp_min = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else
+		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel (0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_INFO "set_temp got string: %d\n", temp);
+	return count;
+}
+
+static irqreturn_t axptemp_irq_handler(int irq, void *data)
+{
+	u32 val, mask;
+	mask = readl(INTER_REGS_BASE | PMU_INT_MASK_REG);
+	val = (readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG) & mask);
+	/* Mask cooling/overheat interrupt */
+	writel((mask & ~val), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
+			((val & PMU_INT_OVRHEAT_MASK) ? "overheat" : "cooling"));
+
+	if (val & PMU_INT_OVRHEAT_MASK)
+		val &= ~PMU_INT_OVRHEAT_MASK;
+	else if (val & PMU_INT_COOLING_MASK)
+		val &= ~PMU_INT_COOLING_MASK;
+
+	/* Clear cooling/overheat interrupt */
+	writel(val, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+
+	return IRQ_HANDLED;
+}
+
+
+
+/* TODO - Add read/write support in order to support setting max/min */
+static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
+			  SHOW_TYPE);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_info, NULL,
+			  SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
+			  SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MAX);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MIN);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *axptemp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group axptemp_group = {
+	.attrs = axptemp_attributes,
+};
+
+static int __devinit axptemp_probe(struct platform_device *pdev)
+{
+	int err, irq;
+
+	err = axptemp_init_sensor();
+	if (err)
+		goto exit;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &axptemp_group);
+	if (err)
+		goto exit;
+
+	hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon_dev)) {
+		dev_err(&pdev->dev, "Class registration failed (%d)\n",
+			err);
+		goto exit;
+	}
+
+	/* Register cooling/overheat interrupt */
+	irq = IRQ_AURORA_PMU;
+	err = request_irq(irq, axptemp_irq_handler, IRQF_DISABLED ,
+				"axp-temp", NULL);
+	if (err)
+		printk(KERN_INFO "unable to request IRQ%d for axp-temp\n", irq);
+	printk(KERN_INFO "Armada XP hwmon thermal sensor initialized.\n");
+
+	return 0;
+exit:
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	return err;
+}
+
+static int __devexit axptemp_remove(struct platform_device *pdev)
+{
+	struct axptemp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(hwmon_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static int axptemp_resume(struct platform_device *dev)
+{
+	return axptemp_init_sensor();
+}
+
+static struct platform_driver axptemp_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "axp-temp",
+	},
+	.probe = axptemp_probe,
+	.remove = __devexit_p(axptemp_remove),
+	.resume = axptemp_resume,
+};
+
+static int __init axptemp_init(void)
+{
+	return platform_driver_register(&axptemp_driver);
+}
+
+static void __exit axptemp_exit(void)
+{
+	platform_driver_unregister(&axptemp_driver);
+}
+
+MODULE_AUTHOR("Marvell Semiconductors");
+MODULE_DESCRIPTION("Marvell Armada XP SoC hwmon driver");
+MODULE_LICENSE("GPL");
+
+module_init(axptemp_init)
+module_exit(axptemp_exit)
diff --git a/arch/arm/mach-armadaxp/include/mach/armadaxp.h b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
new file mode 100644
index 0000000..151a60e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
@@ -0,0 +1,349 @@
+/*
+ * include/asm-arm/arch-aurora/dove.h
+ *
+ * Generic definitions for Marvell Dove MV88F6781 SoC
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_AURORA_H
+#define __ASM_ARCH_AURORA_H
+
+/****************************************************************/
+/******************* System Address Mapping *********************/
+/****************************************************************/
+
+/* The base address of memory that should be reserved for IO windows.
+** The reserved end address is 0xFFFFFFFF.
+*/
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
+
+/*
+ * Armada-XP address maps.
+ *
+ * phys		virt		size
+ * e0000000	@runtime	128M	PCIe-0 Memory space
+ * e8000000	@runtime	128M	PCIe-1 Memory space
+ * f0000000	fab00000	16M	SPI-CS0 (Flash)
+ * f1000000	fbb00000	1M	Internal Registers
+ * f1100000	fbc00000	1M	PCIe-0 I/O space
+ * f1200000	fbd00000	1M	PCIe-1 I/O space
+ * f1300000	fbe00000	1M	PCIe-2 I/O space
+ * f1400000	fbf00000	1M	PCIe-3 I/O space
+ * f1500000	fc000000	1M	PCIe-4 I/O space
+ * f1600000	fc100000	1M	PCIe-5 I/O space
+ * f1700000	fc200000	1M	PCIe-6 I/O space
+ * f1800000	fc300000	1M	PCIe-7 I/O space
+ * f1900000	fc400000	1M	PCIe-8 I/O space
+ * f1a00000	fc500000	1M	PCIe-9 I/O space
+ * f1b00000	fc600000	1M	DMA based UART
+ * f4000000	fe700000	1M	Device-CS0
+ * f2000000	fc700000	32M	Boot-Device CS (NOR Flash)
+ * f4100000	fe800000	1M	Device-CS1 (NOR Flash)
+ * f4200000	fe900000	1M	Device-CS2 (NOR Flash)
+ * f4300000	fea00000	1M	Device-CS3 (NOR Flash)
+ * f4400000	feb00000	1M	CESA SRAM (2 units)
+ * f4500000	fec00000	1M	NETA-BM (PNC)
+ * fff00000	fed00000	1M	BootROM
+ * f4700000	fee00800	1M	PMU Scratch pad
+ * f4800000	fef00000	1M	Legacy Nand Flash
+ */
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE  		0x00000000
+#define SDRAM_CS0_SIZE  		_256M
+#define SDRAM_CS1_BASE  		0x10000000
+#define SDRAM_CS1_SIZE  		_256M
+#define SDRAM_CS2_BASE  		0x20000000
+#define SDRAM_CS2_SIZE  		_256M
+#define SDRAM_CS3_BASE  		0x30000000
+#define SDRAM_CS3_SIZE  		_256M
+
+/*
+ * PEX Address Decoding
+ * Virtual address not specified - remapped @runtime
+ */
+#define PEX0_MEM_PHYS_BASE		0xE0000000
+#define PEX0_MEM_SIZE			_32M
+#define PEX1_MEM_PHYS_BASE		0xE2000000
+#define PEX1_MEM_SIZE			_32M
+#define PEX2_MEM_PHYS_BASE		0xE4000000
+#define PEX2_MEM_SIZE			_32M
+#define PEX3_MEM_PHYS_BASE		0xE6000000
+#define PEX3_MEM_SIZE			_32M
+#define PEX4_MEM_PHYS_BASE		0xE8000000
+#define PEX4_MEM_SIZE			_32M
+#define PEX5_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX5_MEM_SIZE			_32M
+#define PEX6_MEM_PHYS_BASE		0xEA000000		
+#define PEX6_MEM_SIZE			_32M
+#define PEX7_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX7_MEM_SIZE			_32M
+#define PEX8_MEM_PHYS_BASE		0xEC000000		
+#define PEX8_MEM_SIZE			_32M
+#define PEX9_MEM_PHYS_BASE		0xEE000000
+#define PEX9_MEM_SIZE			_32M
+
+#ifdef CONFIG_ARM_LPAE
+
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_VIRT_BASE		0xFAA00000
+#define SPI_CS0_SIZE			_16M
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define INTER_REGS_PHYS_BASE		0xF1000000
+ /* Make sure that no other machines are compiled in */
+ #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
+ #error	"Conflicting Board Configuration!!"
+ #endif
+#else
+ #define INTER_REGS_PHYS_BASE		0xD0000000
+#endif
+
+/*
+ * Change INTER_REGS_BASE from 0xFBB00000 to 0xFBC00000 is mainly
+ * for CONFIG_DEBUG_LL. Before paging_init, the UART port is mapped
+ * by a section entry (2MB). In such case, the '1' in bit 20 is treated
+ * as 'offset' and make it fail to access the UART port.
+ */
+#define INTER_REGS_BASE			0xFBC00000
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_VIRT_BASE		0xFBE00000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_VIRT_BASE		0xFBF00000
+#define PEX1_IO_SIZE			_1M
+#define PEX2_IO_PHYS_BASE		0xF1300000
+#define PEX2_IO_VIRT_BASE		0xFC000000
+#define PEX2_IO_SIZE			_1M
+#define PEX3_IO_PHYS_BASE		0xF1400000
+#define PEX3_IO_VIRT_BASE		0xFC100000
+#define PEX3_IO_SIZE			_1M
+#define PEX4_IO_PHYS_BASE		0xF1500000
+#define PEX4_IO_VIRT_BASE		0xFC200000
+#define PEX4_IO_SIZE			_1M
+#define PEX5_IO_PHYS_BASE		0xF1600000
+#define PEX5_IO_VIRT_BASE		0xFC300000
+#define PEX5_IO_SIZE			_1M
+#define PEX6_IO_PHYS_BASE		0xF1700000
+#define PEX6_IO_VIRT_BASE		0xFC400000
+#define PEX6_IO_SIZE			_1M
+#define PEX7_IO_PHYS_BASE		0xF1800000
+#define PEX7_IO_VIRT_BASE		0xFC500000
+#define PEX7_IO_SIZE			_1M
+#define PEX8_IO_PHYS_BASE		0xF1900000
+#define PEX8_IO_VIRT_BASE		0xFC600000
+#define PEX8_IO_SIZE			_1M
+#define PEX9_IO_PHYS_BASE		0xF1A00000
+#define PEX9_IO_VIRT_BASE		0xFC700000
+#define PEX9_IO_SIZE			_1M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_VIRT_BASE			0xFC800000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_VIRT_BASE		0xFCA00000
+#define DEVICE_BOOTCS_SIZE		_32M
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_VIRT_BASE		0xFEA00000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_VIRT_BASE		0xFEB00000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_VIRT_BASE		0xFEC00000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_VIRT_BASE		0xFED00000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEE00000 : 0xFEE10000)
+#define CRYPT_ENG_SIZE			_64K
+
+
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
+#else
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
+#endif
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
+
+#define PNC_BM_PHYS_BASE		0xF4500000
+#define PNC_BM_VIRT_BASE		0xFEF00000
+#define PNC_BM_SIZE			_1M
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFF000000
+#define BOOTROM_SIZE			_1M
+
+#define PMU_SCRATCH_PHYS_BASE		0xF4700000
+#define PMU_SCRATCH_VIRT_BASE		0xFF100000
+#define PMU_SCRATCH_SIZE		_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_VIRT_BASE		0xFF200000
+#define LEGACY_NAND_SIZE		_1M
+
+#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
+
+#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#else /* !CONFIG_ARM_LPAE */
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_VIRT_BASE		0xFAB00000
+#define SPI_CS0_SIZE			_16M
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define INTER_REGS_PHYS_BASE		0xF1000000
+ /* Make sure that no other machines are compiled in */
+ #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
+ #error	"Conflicting Board Configuration!!"
+ #endif
+#else
+ #define INTER_REGS_PHYS_BASE		0xD0000000
+#endif
+#define INTER_REGS_BASE			0xFBB00000
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_VIRT_BASE		0xFBC00000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_VIRT_BASE		0xFBD00000
+#define PEX1_IO_SIZE			_1M
+#define PEX2_IO_PHYS_BASE		0xF1300000
+#define PEX2_IO_VIRT_BASE		0xFBE00000
+#define PEX2_IO_SIZE			_1M
+#define PEX3_IO_PHYS_BASE		0xF1400000
+#define PEX3_IO_VIRT_BASE		0xFBF00000
+#define PEX3_IO_SIZE			_1M
+#define PEX4_IO_PHYS_BASE		0xF1500000
+#define PEX4_IO_VIRT_BASE		0xFC000000
+#define PEX4_IO_SIZE			_1M
+#define PEX5_IO_PHYS_BASE		0xF1600000
+#define PEX5_IO_VIRT_BASE		0xFC100000
+#define PEX5_IO_SIZE			_1M
+#define PEX6_IO_PHYS_BASE		0xF1700000
+#define PEX6_IO_VIRT_BASE		0xFC200000
+#define PEX6_IO_SIZE			_1M
+#define PEX7_IO_PHYS_BASE		0xF1800000
+#define PEX7_IO_VIRT_BASE		0xFC300000
+#define PEX7_IO_SIZE			_1M
+#define PEX8_IO_PHYS_BASE		0xF1900000
+#define PEX8_IO_VIRT_BASE		0xFC400000
+#define PEX8_IO_SIZE			_1M
+#define PEX9_IO_PHYS_BASE		0xF1A00000
+#define PEX9_IO_VIRT_BASE		0xFC500000
+#define PEX9_IO_SIZE			_1M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_VIRT_BASE			0xFC600000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
+#define DEVICE_BOOTCS_SIZE		_32M
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_VIRT_BASE		0xFE700000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_VIRT_BASE		0xFE800000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_VIRT_BASE		0xFE900000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_VIRT_BASE		0xFEA00000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
+#define CRYPT_ENG_SIZE			_64K
+
+
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
+#else
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
+#endif
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
+
+#define PNC_BM_PHYS_BASE		0xF4500000
+#define PNC_BM_VIRT_BASE		0xFEC00000
+#define PNC_BM_SIZE			_1M
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFED00000
+#define BOOTROM_SIZE			_1M
+
+
+#define PMU_SCRATCH_PHYS_BASE		0xF4700000
+#define PMU_SCRATCH_VIRT_BASE		0xFEE00000
+#define PMU_SCRATCH_SIZE		_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_VIRT_BASE		0xFEF00000
+#define LEGACY_NAND_SIZE		_1M
+
+#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
+
+#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#endif /* CONFIG_ARM_LPAE */
+
+/*
+ * Linux native definitiotns
+ */
+#define SDRAM_OPERATION_REG		(INTER_REGS_BASE | 0x1418)
+#define SDRAM_CONFIG_REG		(INTER_REGS_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG		(INTER_REGS_BASE | 0x170C)
+
+#define AXP_UART_PHYS_BASE(port)	(INTER_REGS_PHYS_BASE | 0x12000 + (port * 0x100))
+#define DDR_VIRT_BASE			(INTER_REGS_BASE | 0x00000)
+#define AXP_BRIDGE_VIRT_BASE		(INTER_REGS_BASE | 0x20000)
+#define AXP_BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
+#define AXP_SW_TRIG_IRQ			(AXP_BRIDGE_VIRT_BASE | 0x0A04)
+#define AXP_SW_TRIG_IRQ_PHYS		(AXP_BRIDGE_PHYS_BASE | 0x0A04)
+#define AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define AXP_SW_TRIG_IRQ_INITID_MASK	0x1F
+#define AXP_PER_CPU_BASE		(AXP_BRIDGE_VIRT_BASE | 0x1000)
+#define AXP_IRQ_VIRT_BASE		(AXP_PER_CPU_BASE)
+#define AXP_CPU_INTACK			0xB4
+#define AXP_IRQ_SEL_CAUSE_OFF		0xA0
+#define AXP_IN_DOORBELL_CAUSE		0x78
+#define AXP_IN_DRBEL_CAUSE			(AXP_PER_CPU_BASE | 0x78)
+#define AXP_IN_DRBEL_MSK			(AXP_PER_CPU_BASE | 0x7c)
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | 0x984)
+#else
+#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | (0x2124+(cpu)*0x100))
+#endif
+#define AXP_CPU_RESUME_CTRL_REG		(AXP_BRIDGE_VIRT_BASE | 0x988)
+#define AXP_CPU_RESET_REG(cpu)		(AXP_BRIDGE_VIRT_BASE | (0x800+(cpu)*8))
+#define AXP_CPU_RESET_OFFS		0
+
+#define AXP_L2_CLEAN_WAY_REG		(INTER_REGS_BASE | 0x87BC) 
+#define AXP_L2_MNTNC_STAT_REG		(INTER_REGS_BASE | 0x8704)
+#define AXP_SNOOP_FILTER_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x21020)
+#define AXP_REVISION_ID_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x40008)
+#define AXP_REVISION_ID_VIRT_REG	(INTER_REGS_BASE | 0x40008)
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/clkdev.h b/arch/arm/mach-armadaxp/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/debug-macro.S b/arch/arm/mach-armadaxp/include/mach/debug-macro.S
new file mode 100644
index 0000000..db547b6
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/debug-macro.S
@@ -0,0 +1,24 @@
+/*
+ * debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <mach/armadaxp.h>
+
+	
+	.macro  addruart, rp, rv, tmp
+	ldr     \rp, =INTER_REGS_PHYS_BASE
+	ldr	\rv, =INTER_REGS_BASE
+	orr     \rp, \rp, #0x00012000
+        orr     \rv, \rv, #0x00012000
+#ifdef CONFIG_MV_UART_PORT
+	orr     \rp, \rp, #0x100 * CONFIG_MV_UART_PORT
+        orr     \rv, \rv, #0x100 * CONFIG_MV_UART_PORT
+#endif
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-armadaxp/include/mach/dma.h b/arch/arm/mach-armadaxp/include/mach/dma.h
new file mode 100644
index 0000000..8e2f2d0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/dma.h
@@ -0,0 +1,16 @@
+/*
+ * DaVinci DMA definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS			0xffffffff
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-armadaxp/include/mach/dove_bl.h b/arch/arm/mach-armadaxp/include/mach/dove_bl.h
new file mode 100644
index 0000000..8a447f2
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/dove_bl.h
@@ -0,0 +1,35 @@
+#ifndef __ASM_ARCH_DOVE_BL_H
+#define __ASM_ARCH_DOVE_BL_H
+#include <linux/ioport.h>
+
+struct dovebl_platform_data {
+	int	default_intensity;
+	int	gpio_pm_control; /* enable LCD/panel power management via gpio*/
+
+	resource_size_t lcd_start;	/* lcd power control reg base. */
+	resource_size_t lcd_end;	/* end of reg map. */
+	unsigned long lcd_offset;	/* register offset */
+	unsigned long lcd_mapped;	/* pa = 0, va = 1 */
+	unsigned long lcd_mask;		/* mask */
+	unsigned long lcd_on;		/* value to enable lcd power */
+	unsigned long lcd_off;		/* value to disable lcd power */
+
+	resource_size_t blpwr_start;	/* backlight pwr ctrl reg base. */
+	resource_size_t blpwr_end;	/* end of reg map. */
+	unsigned long blpwr_offset;	/* register offset */
+	unsigned long blpwr_mapped;	/* pa = 0, va = 1 */
+	unsigned long blpwr_mask;	/* mask */
+	unsigned long blpwr_on;		/* value to enable bl power */
+	unsigned long blpwr_off;	/* value to disable bl power */
+
+	resource_size_t btn_start;	/* brightness control reg base. */
+	resource_size_t btn_end;	/* end of reg map. */
+	unsigned long btn_offset;	/* register offset */
+	unsigned long btn_mapped;	/* pa = 0, va = 1 */
+	unsigned long btn_mask;	/* mask */
+	unsigned long btn_level;	/* how many level can be configured. */
+	unsigned long btn_min;	/* min value */
+	unsigned long btn_max;	/* max value */
+	unsigned long btn_inc;	/* increment */
+};
+#endif /* __ASM_ARCH_DOVE_BL_H */
diff --git a/arch/arm/mach-armadaxp/include/mach/entry-macro.S b/arch/arm/mach-armadaxp/include/mach/entry-macro.S
new file mode 100755
index 0000000..e0dc611
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/entry-macro.S
@@ -0,0 +1,189 @@
+/*
+ * include/asm-arm/arch-mv78xx0/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell MV78xx0 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/armadaxp.h>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =AXP_IRQ_VIRT_BASE
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+#ifndef CONFIG_ARMADAXP_USE_IRQ_INTERRUPT_ACK
+
+#if defined(CONFIG_CPU_BIG_ENDIAN)
+		.macro	HTOLL sr, tt		@ sr   = A  ,B  ,C  ,D
+		rev \sr, \sr
+        	.endm
+#else		
+        	.macro	HTOLL sr, tt	
+        	.endm
+#endif
+	/* TBD - need to be optimized 29*(sel-1) + cls 						*/
+	/* r1 - we shouldnt use it here 							*/
+	/* in case of SMP we only handle bit 0,1 (doorbell) and 5,6 (timer) from cause Vec 0 	*/
+	/* return value is: irqnr and the flag state!!!!!!!!!!!!				*/
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ check low interrupts
+	ldr	\irqstat, [\base, #AXP_IRQ_SEL_CAUSE_OFF]			
+	HTOLL	\irqstat, \tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1001f	
+	mov 	\tmp, \irqstat
+
+	mov 	\tmp, \tmp, lsr #29 			@ determine the irq group,  
+	bics	\tmp, \tmp, #4 	 			@ clear irq_stat bit
+
+#ifdef CONFIG_SMP
+	@ if vec sel is 0 and bits 0-4 are set then it is IPI timer handled seperatly.
+	bne	1000f
+	ands	\tmp, \irqstat, #0x5
+	beq 	1000f
+
+	@restore tmp - should be optimized!!!!
+        mov     \tmp, \irqstat
+
+        mov     \tmp, \tmp, lsr #29                     @ determine the irq group,
+        bics    \tmp, \tmp, #4                          @ clear irq_stat bit
+	beq	1001f
+
+#endif
+1000:
+	bic	\irqstat, \irqstat, #(0xE0000000) 	@ leave irq bits, clear the rest				
+	mov    	\irqnr, #0x1F
+	orrs    \irqnr, \irqnr, \tmp, lsl #5    	@ irqnr = 0x1F, 0x3F, 0x5F, 0x7f, make sure Z is off	
+	clz	\irqstat, \irqstat	              	@ find first active interrupt source
+	sub	\irqnr, \irqnr, \irqstat
+	mov 	r1, #3	
+	mul	\tmp, r1, \tmp
+	sub 	\irqnr, \irqnr, \tmp
+1001:	
+	.endm
+
+
+        /* We assume that irqstat (the raw value of the IRQ acknowledge
+         * register) is preserved from the macro above.
+         */
+
+	.macro test_for_ipi, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1002f
+	ands 	\tmp, \irqstat, #0x00000001		@ was it doorbell
+	beq	1002f
+	ldr	\irqnr, [\base, #AXP_IN_DOORBELL_CAUSE]
+	HTOLL	\irqnr, \tmp
+	ands    \irqnr, \irqnr, #0xFF		@ 8 lower doorbells are considered IPI
+	beq     1002f
+	clz	\irqnr, \irqnr
+	mov	\tmp, #31
+	sub	\irqnr, \tmp, \irqnr
+	mov     \tmp, #1
+	lsl     \tmp, \irqnr
+	HTOLL 	\tmp, \tmp
+	mvn     \tmp, \tmp
+	str   	\tmp, [\base, #AXP_IN_DOORBELL_CAUSE]	@ clean irq
+1002:
+	.endm
+
+
+	/* As above, this assumes that irqstat and base are preserved.. */
+
+	.macro test_for_ltirq, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1003f
+	ands 	\tmp, \irqstat, #0x00000060		@ was it timer
+1003:
+	.endm
+
+	.macro test_for_ipc, irqnr, irqstat, base, tmp
+	ands 	\tmp, \irqstat, #0x80000000		@ did we get irq
+	beq	1006f
+	ands 	\tmp, \irqstat, #0x00000001		@ was it doorbell
+	beq	1006f
+	ldr	\irqnr, [\base, #AXP_IN_DOORBELL_CAUSE]
+	HTOLL	\irqnr, \tmp
+	ands    \irqnr, \irqnr, #0xF000		@ 12-15 doorbells are considered IPC
+	beq     1006f
+	clz	\irqnr, \irqnr
+	mov	\tmp, #31
+	sub	\irqnr, \tmp, \irqnr
+	mov 	\tmp, #1
+	lsl	\tmp, \irqnr
+	mvn	\tmp, \tmp
+	strh   	\tmp, [\base, #AXP_IN_DOORBELL_CAUSE]	@ clean irq
+1006:
+	.endm
+
+#else /* CONFIG_ARMADAXP_USE_IRQ_INTERRUPT_ACK */
+		/*
+		 * The interrupt numbering scheme is defined in the
+		 * interrupt controller spec.
+		 *
+		 * Interrupts 0-2 are IPI
+		 * 0-31 are local.
+		 * 32-1022 are global
+		 * 1023 is "spurious" (no interrupt)
+		 */
+
+		.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+		ldr     \irqstat, [\base, #AXP_CPU_INTACK]
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+#ifdef CONFIG_SMP
+		cmp     \irqnr, #7	
+		cmpcc	\irqnr, \irqnr
+		cmpne	\irqnr, \tmp
+		cmpcs	\irqnr, \irqnr
+#else
+		cmp     \irqnr, \tmp
+#endif
+		.endm
+
+		/* We assume that irqstat (the raw value of the IRQ acknowledge
+		 * register) is preserved from the macro above.
+		 * If there is an IPI, we immediately signal end of interrupt on the
+		 * controller, since this requires the original irqstat value which
+		 * we won't easily be able to recreate later.
+		 */
+
+		.macro test_for_ipi, irqnr, irqstat, base, tmp
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		cmp	\irqnr, #3
+		movcc	\tmp, #0
+		strcc	\tmp, [\base, #AXP_IN_DOORBELL_CAUSE]   @ clean ipi irq
+		cmpcs	\irqnr, \irqnr
+
+		.endm
+
+		/* As above, this assumes that irqstat and base are preserved.. */
+
+		.macro test_for_ltirq, irqnr, irqstat, base, tmp
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		mov	\tmp, #0
+		cmp	\irqnr, #5
+		moveq   \tmp, #1
+		cmp     \tmp, #0
+		.endm
+
+		.macro test_for_ipc, irqnr, irqstat, base, tmp @ YY - check this one again
+		ldr	\tmp, =1023
+		and     \irqnr, \irqstat, \tmp
+		cmp	\irqnr, #3
+		movcc	\tmp, #0
+		strcc	\tmp, [\base, #AXP_IN_DOORBELL_CAUSE]   @ clean ipi irq
+		cmpcs	\irqnr, \irqnr
+		.endm
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/gpio.h b/arch/arm/mach-armadaxp/include/mach/gpio.h
new file mode 100644
index 0000000..7ca789d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * include/asm-arm/arch-dove/gpio.h
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/errno.h>
+#include <mach/irqs.h>
+#include <plat/gpio.h>
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+
+#define GPIO_MAX	64
+
+#define GPIO_BASE_LO		(AURORA_GPIO_VIRT_BASE + 0x00)
+#define GPIO_BASE_HI		(AURORA_GPIO_VIRT_BASE + 0x20)
+
+#define GPIO_BASE(pin)		((pin < 32) ? GPIO_BASE_LO : GPIO_BASE_HI)
+
+#define GPIO_OUT(pin)		(GPIO_BASE(pin) + 0x00)
+#define GPIO_IO_CONF(pin)	(GPIO_BASE(pin) + 0x04)
+#define GPIO_BLINK_EN(pin)	(GPIO_BASE(pin) + 0x08)
+#define GPIO_IN_POL(pin)	(GPIO_BASE(pin) + 0x0c)
+#define GPIO_DATA_IN(pin)	(GPIO_BASE(pin) + 0x10)
+#define GPIO_EDGE_CAUSE(pin)	(GPIO_BASE(pin) + 0x14)
+#define GPIO_EDGE_MASK(pin)	(GPIO_BASE(pin) + 0x18)
+#define GPIO_LEVEL_MASK(pin)	(GPIO_BASE(pin) + 0x1c)
+
+static inline int gpio_to_irq(int pin)
+{
+	if (pin < NR_GPIO_IRQS)
+		return pin + IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+static inline int irq_to_gpio(int irq)
+{
+	if (IRQ_AURORA_GPIO_START < irq && irq < NR_IRQS)
+		return irq - IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/hardware.h b/arch/arm/mach-armadaxp/include/mach/hardware.h
new file mode 100644
index 0000000..6c1ce4e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * include/mach/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "armadaxp.h"
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/ide.h b/arch/arm/mach-armadaxp/include/mach/ide.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/ide.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-armadaxp/include/mach/io.h b/arch/arm/mach-armadaxp/include/mach/io.h
new file mode 100644
index 0000000..0d8a34a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/io.h
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-dove/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "armadaxp.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define IO_SPACE_REMAP 		PEX0_IO_PHYS_BASE
+
+#define __io(a)			((a) + PEX0_IO_VIRT_BASE)
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(a)
+
+/*#define aurora_setbits(r, mask)	writel(readl(r) | (mask), (r))
+#define aurora_clrbits(r, mask)	writel(readl(r) & ~(mask), (r))*/
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define dma_io_sync()	do {				\
+	writel(0x1, INTER_REGS_BASE + 0x21810);		\
+	while (readl(INTER_REGS_BASE + 0x21810) & 0x1);	\
+} while (0)
+#else
+#define dma_io_sync()	do { } while (0)
+#endif
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/irqs.h b/arch/arm/mach-armadaxp/include/mach/irqs.h
new file mode 100644
index 0000000..3968cf9
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/irqs.h
@@ -0,0 +1,171 @@
+/*
+ * include/asm-arm/arch-aurora/irqs.h
+ *
+ * IRQ definitions for Marvell Dove MV88F6781 SoC
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * Aurora Low Interrupt Controller
+ */
+
+#define IRQ_AURORA_IN_DRBL_LOW	0
+#define IRQ_AURORA_IN_DRBL_HIGH	1
+#define IRQ_AURORA_OUT_DRBL 	2
+#define IRQ_AURORA_MP		3
+#define IRQ_AURORA_SOC_ERROR	4
+#define IRQ_AURORA_TIMER0	5
+#define IRQ_LOCALTIMER 		IRQ_AURORA_TIMER0
+#define IRQ_AURORA_TIMER1	6
+#define IRQ_AURORA_WD		7
+
+#define IRQ_AURORA_GBE0_FIC	8
+#define IRQ_AURORA_GBE0_SIC	9
+#define IRQ_AURORA_GBE1_FIC	10
+#define IRQ_AURORA_GBE1_SIC	11
+#define IRQ_AURORA_GBE2_FIC     12
+#define IRQ_AURORA_GBE2_SIC	13
+#define IRQ_AURORA_GBE3_FIC	14
+#define IRQ_AURORA_GBE3_SIC	15
+
+#define IRQ_AURORA_LCD		29
+#define IRQ_AURORA_SPI          30
+#define IRQ_AURORA_I2C0		31
+#define IRQ_AURORA_I2C1		32
+
+#define IRQ_AURORA_DMA0		33
+#define IRQ_AURORA_DMA1		34
+#define IRQ_AURORA_DMA2		35
+#define IRQ_AURORA_DMA3		36
+
+#define IRQ_AURORA_GLOB_TIMER0	37
+#define IRQ_AURORA_GLOB_TIMER1	38
+#define IRQ_AURORA_GLOB_TIMER2	39
+#define IRQ_AURORA_GLOB_TIMER3	40
+
+#define IRQ_AURORA_UART0	41
+#define IRQ_AURORA_UART1	42
+#define IRQ_AURORA_UART2	43
+#define IRQ_AURORA_UART3	44
+
+#define IRQ_AURORA_USB0		45
+#define IRQ_AURORA_USB1		46
+#define IRQ_AURORA_USB2		47
+
+#define IRQ_AURORA_CRYPTO(chan)	((chan == 0) ? 48 : 49)
+
+#define IRQ_AURORA_RTC		50
+
+#define IRQ_AURORA_XOR00	51
+#define IRQ_AURORA_XOR01	52
+
+#define IRQ_AURORA_BM		53
+#define IRQ_AURORA_SDIO		54
+#define IRQ_AURORA_SATA0	55
+#define IRQ_AURORA_TDM		56
+#define IRQ_AURORA_SATA1	57
+	
+#define IRQ_AURORA_PCIE0	58
+#define IRQ_AURORA_PCIE1	59
+#define IRQ_AURORA_PCIE2	60
+#define IRQ_AURORA_PCIE3	61
+#define IRQ_AURORA_PCIE4	62
+#define IRQ_AURORA_PCIE5	63
+#define IRQ_AURORA_PCI0		63	/* FPGA only */
+#define IRQ_AURORA_PCIE6	64
+#define IRQ_AURORA_PCIE7	65
+
+#define IRQ_AURORA_GBE0		66
+#define IRQ_AURORA_GBE0_RX	67
+#define IRQ_AURORA_GBE0_TX	68
+#define IRQ_AURORA_GBE0_MISC	69
+#define IRQ_AURORA_GBE1		70
+#define IRQ_AURORA_GBE1_RX	71
+#define IRQ_AURORA_GBE1_TX	72
+#define IRQ_AURORA_GBE1_MISC	73
+#define IRQ_AURORA_GBE2		74
+#define IRQ_AURORA_GBE2_RX	75
+#define IRQ_AURORA_GBE2_TX	76
+#define IRQ_AURORA_GBE2_MISC	77
+#define IRQ_AURORA_GBE3		78
+#define IRQ_AURORA_GBE3_RX	79
+#define IRQ_AURORA_GBE3_TX	80
+#define IRQ_AURORA_GBE3_MISC	81
+
+#define IRQ_AURORA_GPIO_0_7	82
+#define IRQ_AURORA_GPIO_8_15	83
+#define IRQ_AURORA_GPIO_16_23	84
+#define IRQ_AURORA_GPIO_24_31	85
+#define IRQ_AURORA_GPIO_32_39	87
+#define IRQ_AURORA_GPIO_40_47	88
+#define IRQ_AURORA_GPIO_48_55	89
+#define IRQ_AURORA_GPIO_56_63	90
+#define IRQ_AURORA_GPIO_64_66	91
+
+#define IRQ_AURORA_XOR10	94
+#define IRQ_AURORA_XOR11	95
+
+#define IRQ_AURORA_SHARE_INB_DB0	96
+#define IRQ_AURORA_SHARE_INB_DB1	97
+#define IRQ_AURORA_SHARE_INB_DB2	98
+
+#define IRQ_AURORA_PCIE8	99
+#define IRQ_AURORA_PCIE9	103
+
+#define IRQ_AURORA_PMU		107
+
+#define IRQ_AURORA_DRAM		108
+
+#define IRQ_AURORA_NET_WKUP0	109
+#define IRQ_AURORA_NET_WKUP1	110
+#define IRQ_AURORA_NET_WKUP2	111
+#define IRQ_AURORA_NET_WKUP3	112
+
+#define IRQ_AURORA_NFC		113
+
+#define IRQ_AURORA_MTL_FIX	114
+
+#define IRQ_AURORA_OVRCL	115
+
+#define IRQ_MAIN_INTS_NUM	116
+
+#define MAX_PER_CPU_IRQ_NUMBER  7
+/*
+ * AURORA General Purpose Pins
+ */
+#define IRQ_AURORA_GPIO_START		128
+#define NR_GPIO_IRQS			67
+
+/*
+ * AURORA MSI interrupts
+ */
+#define NR_PRIVATE_MSI_GROUP		16
+#define NR_PRIVATE_MSI_IRQS		NR_PRIVATE_MSI_GROUP
+#define NR_MSI_IRQS			NR_PRIVATE_MSI_IRQS
+#define IRQ_AURORA_MSI_START		(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)
+#define NR_IRQS				(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS + NR_MSI_IRQS)
+#define GPP_IRQ_TYPE_LEVEL		0
+#define GPP_IRQ_TYPE_CHANGE_LEVEL	1
+
+/*
+ * Aurora Error interrupts
+ */
+
+#define INT_ERR_CESA0         		0
+#define INT_ERR_DEVBUS         		1
+
+/*
+ * IRQ HAL remapping
+ */
+#define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_AURORA_GBE0_FIC + ((x) * 2))
+#define SATA_IRQ_NUM			(IRQ_AURORA_SATA0)
+#define CESA_IRQ(chan)			IRQ_AURORA_CRYPTO(chan)
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/kw_macro.h b/arch/arm/mach-armadaxp/include/mach/kw_macro.h
new file mode 100644
index 0000000..9e0525a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/kw_macro.h
@@ -0,0 +1,39 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Assembler-only file 
+ */
+
+
+support_wait_for_interrupt_address:
+        .word   support_wait_for_interrupt
+
+/* rd, rs, rt, re - are temp registers that will b used (non are input/output) */
+.macro mv_flush_all, rd, rs, rt, re
+	mov     \re, #0
+
+        mov     \rd, #(4 - 1) << 30      @ 4 way cache
+        mov     \rs, #(256 * CACHE_DLINESIZE)
+
+1:      orr     \rt, \re, \rd
+2:      mcr     p15, 0, \rt, c7, c14, 2          @ clean & invalidate D index
+        subs    \rt, \rt, #1 << 30
+        bcs     2b                              @ entries 3 to 0
+        add     \re, \re, #32
+        cmp     \re, \rs
+        bne     1b
+
+/* exit */	
+	.endm
diff --git a/arch/arm/mach-armadaxp/include/mach/memory.h b/arch/arm/mach-armadaxp/include/mach/memory.h
new file mode 100644
index 0000000..6740ff2
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/memory.h
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-mv78xx0/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#ifdef CONFIG_MV_DRAM_BASE
+#define PLAT_PHYS_OFFSET		UL(CONFIG_MV_DRAM_BASE)
+#else
+#define PLAT_PHYS_OFFSET		UL(0x00000000)
+#endif
+
+#define BOOT_PARAMS_OFFSET      PLAT_PHYS_OFFSET + 0x100
+/* #define __virt_to_bus(x)	__virt_to_phys(x) */
+/* #define __bus_to_virt(x)	__phys_to_virt(x) */
+
+
+/* Override the ARM default */
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS       35
+#define SECTION_SIZE_BITS      29
+#endif
+
+#if 0
+#ifdef CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE
+
+#if (CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE == 0)
+#undef CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE
+#define CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE 2
+#endif
+
+#define CONSISTENT_DMA_SIZE \
+	(((CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE + 1) & ~1) * 1024 * 1024)
+
+#endif
+#endif
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define arch_is_coherent()  1  
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/param.h b/arch/arm/mach-armadaxp/include/mach/param.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/param.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-armadaxp/include/mach/serial.h b/arch/arm/mach-armadaxp/include/mach/serial.h
new file mode 100644
index 0000000..7f57c8c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/serial.h
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/irq.h>
+//#include <linux/autoconf.h>
+
+#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
+
+extern unsigned int mvTclk;
+
+#undef  BASE_BAUD
+#define BASE_BAUD (mvTclk / 16)
+
+#define PORT0_BASE	(INTER_REGS_BASE + 0x12000) /* port 0 base */
+#define PORT1_BASE 	(INTER_REGS_BASE + 0x12100) /* port 1 base */
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST /* | ASYNC_SPD_VHI  115200 */ )
+
+#define STD_SERIAL_PORT_DEFNS
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/smp.h b/arch/arm/mach-armadaxp/include/mach/smp.h
new file mode 100644
index 0000000..f12d59e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/smp.h
@@ -0,0 +1,23 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+#include <asm/io.h>
+#include <mach/armadaxp.h>
+
+extern unsigned int master_cpu_id;
+extern unsigned int group_cpu_mask;
+extern unsigned long mv_cpu_count;
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#define get_hw_cpu_mask(cpu_mask)	((cpu_mask << master_cpu_id) & group_cpu_mask)
+#define get_hw_cpu_id(cpu)		(cpu + master_cpu_id)
+#define is_primary_amp()		(master_cpu_id == 0 ? 1 : 0)
+
+#endif //ASMARM_ARCH_SMP_H
diff --git a/arch/arm/mach-armadaxp/include/mach/system.h b/arch/arm/mach-armadaxp/include/mach/system.h
new file mode 100644
index 0000000..a359b34
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/mach/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
+#define LSP_PG_SZ_VER  " (Large Page)"
+#else
+#define LSP_PG_SZ_VER  ""
+#endif
+
+#define LSP_VERSION    "linux-3.2.27-axp_a370-2012_Q4.1" LSP_PG_SZ_VER
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk("Reseting...\n");
+	mvBoardReset();
+	while (1);/* This should never be reached */
+}
+
+#endif
diff --git a/arch/arm/mach-armadaxp/include/mach/timex.h b/arch/arm/mach-armadaxp/include/mach/timex.h
new file mode 100644
index 0000000..c8cf294
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-dove/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
diff --git a/arch/arm/mach-armadaxp/include/mach/uncompress.h b/arch/arm/mach-armadaxp/include/mach/uncompress.h
new file mode 100644
index 0000000..ca4313f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/include/mach/uncompress.h
@@ -0,0 +1,138 @@
+/*
+ * include/asm-arm/arch-aurora/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/armadaxp.h>
+
+#ifndef CONFIG_MV_UART_PORT
+#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x14))
+#else
+#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
+#endif
+
+#define LSR_THRE	0x20
+
+static void putc(const char c)
+{
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		/* Transmit fifo not full? */
+		if (*UART_LSR & LSR_THRE)
+			break;
+	}
+
+	*UART_THR = c;
+}
+
+static void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#if 0
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include <linux/autoconf.h>
+#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
+#include <linux/serial_reg.h>
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))	 
+
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+	
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+		
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0); 
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+
+#if 0
+static void putc(const char c)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+#endif
+#if 0
+static void flush(void)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+#endif
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+#endif
diff --git a/arch/arm/mach-armadaxp/irq.c b/arch/arm/mach-armadaxp/irq.c
new file mode 100644
index 0000000..ee2597f
--- /dev/null
+++ b/arch/arm/mach-armadaxp/irq.c
@@ -0,0 +1,362 @@
+/*
+* arch/arm/mach/irq.c
+*
+* This file is licensed under the terms of the GNU General Public
+* License version 2.  This program is licensed "as is" without any
+* warranty of any kind, whether express or implied.
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <plat/msi.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvOs.h"
+#include "include/mach/smp.h"
+
+unsigned int  irq_int_type[NR_IRQS];
+static DEFINE_SPINLOCK(irq_controller_lock);
+
+int max_per_cpu_irq = 28; // not enabled, default.
+static int __init per_cpu_irq_setup(char *__unused)
+{
+max_per_cpu_irq=7;
+return 1;
+}
+
+__setup("per_cpu_irq_enable", per_cpu_irq_setup);
+
+static void axp_unmask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val |=  (1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+	if (cpu > 0) { /*enabled for both cpu */
+		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+		/* FIXME: assuming all 4 cpus */
+		val |= 0xf;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+	}
+#endif
+}
+
+static void axp_mask_fabric_interrupt(int cpu)
+{
+	u32 val;
+	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
+	val &=  ~(1 << cpu);
+	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
+
+#ifdef CONFIG_SMP
+if (cpu > 0) { /*disabled for both cpu */
+	val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
+	/* FIXME: assuming all 4 cpus */
+	val &= ~0xf;
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+}
+#endif	
+}
+
+#ifdef CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE
+void axp_irq_mask(struct irq_data *d)
+{	
+	int i;
+	u32 irq=d->irq;
+	if (irq < 8){ // per CPU; treat giga as shared interrupt
+		MV_REG_WRITE(CPU_INT_SET_MASK_LOCAL_REG, irq);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+		if(irq==IRQ_AURORA_MP){
+			for_each_online_cpu(i) {
+                        axp_mask_fabric_interrupt(i);
+			}
+		}
+#endif
+	}
+	else
+		MV_REG_WRITE(CPU_INT_CLEAR_ENABLE_REG, irq);
+}
+
+void axp_irq_unmask(struct irq_data *d)
+{	
+	int i;
+	if (d->irq < 8){ // per CPU
+		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, d->irq);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+		if(d->irq==IRQ_AURORA_MP){
+			for_each_online_cpu(i) {
+				axp_unmask_fabric_interrupt(i);
+			}
+		}
+#endif
+	}else
+		MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, d->irq);
+}
+
+void axp_irq_disable(struct irq_data *d)
+{	
+	int i;
+	u32 irq=d->irq;
+	MV_REG_WRITE(CPU_INT_CLEAR_ENABLE_REG, irq);
+	for_each_online_cpu(i) {
+                axp_mask_fabric_interrupt(i);
+        }
+
+}
+
+void axp_irq_enable(struct irq_data *d)
+{	
+	u32 irq=d->irq;
+	int i;
+	MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, irq);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+	if(irq == IRQ_AURORA_MP){
+		for_each_online_cpu(i) {
+			axp_unmask_fabric_interrupt(i);
+		}
+	}
+#endif
+}
+
+#ifdef CONFIG_SMP
+int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool force)
+{
+	MV_U32 addr, temp;
+	u32 irq=d->irq;
+	addr = (CPU_INT_SOURCE_CONTROL_REG(irq));
+
+	spin_lock(&irq_controller_lock);
+	cpumask_copy(d->affinity, mask_val);
+	d->node = cpumask_first(mask_val);
+	temp = MV_REG_READ(addr);
+	temp &= ~0xf;
+	temp |= *cpus_addr(*mask_val);
+	MV_REG_WRITE(addr, temp);
+	spin_unlock(&irq_controller_lock);
+
+return 0;
+}
+#endif
+#else /* CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE */
+
+void axp_irq_mask(struct irq_data *d)
+{	
+	int i;
+	u32 irq = d->irq;
+	MV_U32 addr, temp, gpio_indx;
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		/* GPIO Interrupts */
+		/* calculate index in main interrupt */
+		gpio_indx = IRQ_AURORA_GPIO_0_7 + ((irq - IRQ_AURORA_GPIO_START) >> 3);
+		/* add 1 because there is a gap between IRQ_AURORA_GPIO_24_31
+		   and IRQ_AURORA_GPIO_32_39 */
+		if (gpio_indx > IRQ_AURORA_GPIO_24_31)
+			gpio_indx++;
+		addr = (CPU_INT_SOURCE_CONTROL_REG(gpio_indx));
+	} else if (irq >= IRQ_AURORA_MSI_START) {
+		/* Per CPU MSI Interrupts */
+		if ((irq - IRQ_AURORA_MSI_START) < NR_PRIVATE_MSI_GROUP)
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW);
+		else
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH);
+	} else
+		addr = CPU_INT_SOURCE_CONTROL_REG(irq);
+#ifdef CONFIG_MV_AMP_ENABLE
+	 mvSemaLock(MV_SEMA_IRQ);
+#else
+	spin_lock(&irq_controller_lock);
+#endif
+	temp = MV_REG_READ(addr);
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		MV_U32 bitmask = 1 << (irq & (32-1));
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_RESET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+
+	if (irq <= max_per_cpu_irq) // per CPU
+		temp &= ~(1 << hard_smp_processor_id());
+	/* for GPIO IRQs , don't disable INTS , they will be disabled in the units mask */
+	else if (irq < IRQ_MAIN_INTS_NUM)
+		temp &= ~0xf;
+
+	MV_REG_WRITE(addr, temp);
+#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
+	 if(irq==IRQ_AURORA_MP){
+		for_each_online_cpu(i) {
+			axp_unmask_fabric_interrupt(i);
+		}
+	}
+#endif
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaUnlock(MV_SEMA_IRQ);
+#else
+	spin_unlock(&irq_controller_lock);
+#endif
+}
+
+void axp_irq_unmask(struct irq_data *d)
+{	
+	u32 irq=d->irq;
+	MV_U32 addr, temp, gpio_indx;
+	unsigned int map = 0x1;
+	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
+		/* GPIO Interrupts */
+		/* calculate index in main interrupt */
+		gpio_indx = IRQ_AURORA_GPIO_0_7 + ((irq - IRQ_AURORA_GPIO_START) >> 3);
+		/* add 1 because there is a gap between IRQ_AURORA_GPIO_24_31
+		   and IRQ_AURORA_GPIO_32_39 */
+		if (gpio_indx > IRQ_AURORA_GPIO_24_31)
+			gpio_indx++;
+		addr = (CPU_INT_SOURCE_CONTROL_REG(gpio_indx));
+	} else if (irq >= IRQ_AURORA_MSI_START) {
+		/* Per CPU MSI Interrupts */
+		if ((irq - IRQ_AURORA_MSI_START) < NR_PRIVATE_MSI_GROUP)
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW);
+		else
+			addr = CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH);
+	} else
+		addr = CPU_INT_SOURCE_CONTROL_REG(irq);
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaLock(MV_SEMA_IRQ);
+#else
+	spin_lock(&irq_controller_lock);
+#endif
+	temp = MV_REG_READ(addr);
+
+	if (irq >= IRQ_AURORA_GPIO_START) {
+		MV_U32 bitmask = 1 << (irq & (32-1));
+		MV_U32 reg = (irq - IRQ_AURORA_GPIO_START) >> 5;
+		MV_REG_BIT_SET(GPP_INT_LVL_REG(reg), bitmask);
+	}
+#ifdef CONFIG_SMP
+	else{
+		map = get_hw_cpu_mask(*cpus_addr(*(d->affinity)));
+       }
+#endif
+//temp &= ~0xf;
+	temp |= map;
+	temp |= (0x1 << 28); /* Set IntEn for this source */
+	MV_REG_WRITE(addr, temp);
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaUnlock(MV_SEMA_IRQ);
+#else
+	spin_unlock(&irq_controller_lock);
+#endif
+}
+
+
+#ifdef CONFIG_SMP
+int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool force)
+{
+	cpumask_copy((*d).affinity, mask_val);
+	spin_lock(&irq_controller_lock);
+	(*d).node = cpumask_first(mask_val);
+	spin_unlock(&irq_controller_lock);
+	axp_irq_unmask(d);
+	return 0;
+}
+#endif
+#endif /* CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE */
+
+#ifdef CONFIG_SMP
+void second_cpu_init(void)
+{
+	struct irq_data *d = irq_get_irq_data(IRQ_AURORA_IN_DRBL_LOW);
+	unsigned long temp;
+	/* open IPI mask */
+	temp = MV_REG_READ(AXP_IN_DRBEL_MSK) | 0xff;
+	MV_REG_WRITE(AXP_IN_DRBEL_MSK, temp);
+
+	axp_irq_unmask(d);
+}
+#endif
+
+static struct irq_chip axp_irq_chip = {
+	.name		= "axp_irq",
+	.irq_mask	= axp_irq_mask,
+	.irq_mask_ack	= axp_irq_mask,
+	.irq_unmask	= axp_irq_unmask,
+#ifdef CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE
+	.irq_disable	= axp_irq_disable,
+	.irq_enable	= axp_irq_enable,
+#else
+	.irq_disable	= axp_irq_mask,
+	.irq_enable	= axp_irq_unmask,
+#endif
+#ifdef CONFIG_SMP
+	.irq_set_affinity   = axp_set_affinity,
+#endif
+};
+
+
+void __init axp_init_irq(void)
+{
+	u32 irq;
+	/* MASK all interrupts */
+	/* Enable IRQ in control register */
+	for (irq = 0; irq < IRQ_MAIN_INTS_NUM; irq++) {
+		axp_irq_mask(irq_get_irq_data(irq));
+#ifndef CONFIG_SMP
+#ifdef CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE
+		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, irq);
+#endif
+#endif
+
+	}
+/*
+ * Register IRQ sources
+ */
+	for (irq = 0; irq < IRQ_AURORA_MSI_START ; irq++) {
+		irq_set_chip(irq, &axp_irq_chip);
+		irq_set_chip_data(irq, 0);
+		irq_set_handler(irq, handle_level_irq);
+		irq_set_status_flags(irq,IRQ_LEVEL);
+#ifdef CONFIG_SMP
+		/*Warninig  - Seif Mazreeb, in Linux 3.2 you must declare that an
+		interrupt is a percpu .....without doing this timer interrupt won't happen.
+		If we declare network interrupt in the same way ( which I think we should),
+		we crash duing boot, keep this for timers for now.
+		This is a  TODO at a second stage, evalute perfrmance and fix as needed
+		*/
+		if( irq < MAX_PER_CPU_IRQ_NUMBER && irq != IRQ_AURORA_MP) {
+				irq_set_chip_and_handler(irq, &axp_irq_chip,
+							 handle_percpu_devid_irq);
+				irq_set_percpu_devid(irq);
+		}
+#endif
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+#ifdef CONFIG_SMP
+	{
+		u32/*void __iomem **/addr;
+        	/* Set the default affinity to the boot cpu. */
+        	cpumask_clear(irq_default_affinity);
+        	cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
+		/* open IPI mask */
+		/* this  register write does the job of axp_irq_unmask(IRQ_AURORA_IN_DRBL_LOW)
+		   i.e. enable / unmask the DRBL_LOW interrupt.
+		*/
+	        MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, 0);
+		addr = /*(void __iomem *)*/(AXP_IN_DRBEL_MSK);
+		MV_REG_WRITE(addr, 0xf0ff); // only IPI 0
+	}
+#endif
+
+	armada_msi_init();
+
+}
+
+
+
diff --git a/arch/arm/mach-armadaxp/leds.c b/arch/arm/mach-armadaxp/leds.c
new file mode 100644
index 0000000..66639b2
--- /dev/null
+++ b/arch/arm/mach-armadaxp/leds.c
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include "boardEnv/mvBoardEnvLib.h"
+
+static	u32		last_jiffies = 0;
+static	u32		led_val = 0;
+
+
+void mv_leds_hearbeat(void)
+{
+	u32 sec = jiffies_to_msecs(jiffies - last_jiffies) / 1000;
+	
+	if (!sec)
+		return;
+
+	led_val = (led_val % (1 << mvBoardDebugLedNumGet(mvBoardIdGet())));
+	mvBoardDebugLed(led_val);
+	led_val++;
+	last_jiffies = jiffies;
+}
+
+static int __init leds_init(void)
+{
+	return 0;
+}
+
+__initcall(leds_init);
diff --git a/arch/arm/mach-armadaxp/mpp.h b/arch/arm/mach-armadaxp/mpp.h
new file mode 100644
index 0000000..1065468
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mpp.h
@@ -0,0 +1,34 @@
+#ifndef __ARCH_DOVE_MPP_H
+#define __ARCH_DOVE_MPP_H
+
+enum aurora_mpp_type {
+	/*
+	 * This MPP is unused.
+	 */
+	MPP_UNUSED,
+
+	/*
+	 * This MPP pin is used as a generic GPIO pin.
+	 */
+	MPP_GPIO,
+
+        /*
+         * This MPP is used as a SATA activity LED.
+         */
+        MPP_SATA_LED,
+        /*
+         * This MPP is used as a functional pad.
+         */
+        MPP_FUNCTIONAL,
+
+};
+
+struct aurora_mpp_mode {
+	int			mpp;
+	enum aurora_mpp_type	type;
+};
+
+void aurora_mpp_conf(struct aurora_mpp_mode *mode);
+
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesa.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesa.c
new file mode 100644
index 0000000..49f6154
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesa.c
@@ -0,0 +1,117 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mv_cesa/cesa_if.h"
+
+extern u32 mv_crypto_phys_base_get(u8 chan);
+extern u32 mv_crypto_virt_base_get(u8 chan);
+
+/*******************************************************************************
+* mvSysCesaInit - Initialize the Cesa subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle)
+{
+	MV_CESA_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	MV_U8 chan;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+
+	if(status == MV_OK) {
+		for(chan = 0; chan < MV_CESA_CHANNELS; chan++) {
+			status = mvCesaIfTdmaWinInit(chan, addrWinMap);
+			
+			if(status != MV_OK) {
+				mvOsPrintf("Error, unable to initialize CESA windows for channel(%d)\n", chan);
+				break;
+			}
+			halData.sramPhysBase[chan] = (MV_ULONG)mv_crypto_phys_base_get(chan);
+			halData.sramVirtBase[chan] = (MV_U8*)mv_crypto_virt_base_get(chan);
+			halData.sramOffset[chan] = 0;
+		}
+
+		if(status == MV_OK) {
+			halData.ctrlModel = mvCtrlModelGet();
+			halData.ctrlRev = mvCtrlRevGet();
+			status = mvCesaIfInit (numOfSession, queueDepth, osHandle, &halData);
+		}
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesaApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesaApi.h
new file mode 100644
index 0000000..ce8aa9b
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysCesaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_CESA_API_H__
+#define __MV_SYS_CESA_API_H__
+
+
+MV_STATUS mvSysCesaInit (int numOfSession, int queueDepth, void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysDdr.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysDdr.c
new file mode 100644
index 0000000..38dc444
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysDdr.c
@@ -0,0 +1,134 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+
+/*******************************************************************************
+* mvSysDdrSpdRead
+*
+* DESCRIPTION:
+*	System interface for reading DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer to read data into.
+*       size:	Number of bytes to read.
+*
+* OUTPUT:
+*       data:	SPD data.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
+
+/*******************************************************************************
+* mvSysDdrSpdWrite
+*
+* DESCRIPTION:
+*	System interface for writing DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer holding the data to be written.
+*       size:	Number of bytes to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return	mvTwsiWrite(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysEth.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEth.c
new file mode 100644
index 0000000..f8b64b6
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEth.c
@@ -0,0 +1,132 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "eth/mvEth.h"
+
+
+/*******************************************************************************
+* mvSysEthInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysEthInit(MV_VOID)
+{
+	MV_ETH_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status != MV_OK)
+		return;
+
+	{
+		int i;
+		for(i = 0; i < MAX_TARGETS; i++) {
+			if(addrWinMap[i].enable == MV_FALSE)
+				continue;
+			printk("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+					addrWinMap[i].addrWin.baseLow,
+					addrWinMap[i].addrWin.size);
+		}
+	}
+	halData.maxPortNum = mvCtrlEthMaxPortGet();
+	halData.cpuPclk = mvCpuPclkGet();
+	halData.tclk = mvBoardTclkGet();
+#ifdef ETH_DESCR_IN_SRAM
+	halData.sramSize = mvCtrlSramSizeGet();
+#endif
+
+	for (port=0;port < halData.maxPortNum;port++) {
+		if(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE) {
+			halData.portData[port].powerOn = MV_FALSE;
+			continue;
+		}
+		status = mvEthWinInit(port, addrWinMap);
+		if(status == MV_OK) {
+			halData.portData[port].powerOn = MV_TRUE;
+			halData.portData[port].phyAddr = mvBoardPhyAddrGet(port);
+			halData.portData[port].isSgmii = mvBoardIsPortInSgmii(port);
+			halData.portData[port].macSpeed = mvBoardMacSpeedGet(port);
+		}
+	}
+
+	mvEthHalInit(&halData);
+
+	return;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthApi.h
new file mode 100644
index 0000000..e1016e4
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETH_API_H__
+#define __MV_SYS_ETH_API_H__
+
+
+MV_VOID mvSysEthInit(void);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhy.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhy.c
new file mode 100644
index 0000000..0c9cdf5
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhy.c
@@ -0,0 +1,104 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "eth-phy/mvEthPhy.h"
+#if defined(MV_ETH_LEGACY)
+#include "eth/gbe/mvEthRegs.h"
+#else
+#include "neta/gbe/mvEthRegs.h"
+#endif
+
+
+/*******************************************************************************
+* mvSysEthPhyInit - Initialize the EthPhy subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysEthPhyInit(void)
+{
+	MV_ETHPHY_HAL_DATA halData;
+	MV_U32 port;
+
+	for (port=0; port < mvCtrlEthMaxPortGet(); port++) {
+		halData.phyAddr[port] = mvBoardPhyAddrGet(port);
+		halData.boardSpecInit = MV_FALSE;
+	}
+
+	halData.ethPhySmiReg = ETH_SMI_REG(MV_ETH_SMI_PORT); 
+
+	return mvEthPhyHalInit(&halData);
+}
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhyApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhyApi.h
new file mode 100644
index 0000000..eab268a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysEthPhyApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETHPHY_API_H__
+#define __MV_SYS_ETHPHY_API_H__
+
+
+MV_STATUS mvSysEthPhyInit(void);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
new file mode 100644
index 0000000..d5f1c39
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
@@ -0,0 +1,150 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "neta/gbe/mvNeta.h"
+
+
+/*******************************************************************************
+* mvSysNetaInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+void 	mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask)
+{
+	MV_NETA_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	int i;
+
+	memset(&halData, 0, sizeof(halData));
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK)
+		return;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (addrWinMap[i].enable == MV_FALSE)
+			continue;
+
+#ifdef CONFIG_MV_SUPPORT_L2_DEPOSIT
+		/* Setting DRAM windows attribute to :
+		   0x3 - Shared transaction + L2 write allocate (L2 Deposit) */
+		if (MV_TARGET_IS_DRAM(i)) {
+			addrWinMap[i].attrib &= ~(0x30);
+			addrWinMap[i].attrib |= 0x30;
+		}
+#endif
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08llx.\n", i,
+						addrWinMap[i].addrWin.baseLow, addrWinMap[i].addrWin.size);
+	}
+
+	halData.portMask = portMask;
+	halData.cpuMask  = cpuMask;
+	halData.maxPort = mvCtrlEthMaxPortGet();
+	halData.pClk = mvCpuPclkGet();
+	halData.tClk = mvBoardTclkGet();
+	halData.maxCPUs = mvCtrlEthMaxCPUsGet();
+	halData.iocc = arch_is_coherent();
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+#ifdef CONFIG_MV_ETH_BM
+	halData.bmPhysBase = PNC_BM_PHYS_BASE;
+	halData.bmVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_BM */
+
+#ifdef CONFIG_MV_ETH_PNC
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_PNC */
+
+	for (port = 0; port < halData.maxPort; port++) {
+		if (!(MV_BIT_CHECK(portMask, port)))
+			continue;
+
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE)
+			continue;
+
+		mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), !mvBoardIsPortInGmii(port));
+		status = mvNetaWinInit(port, addrWinMap);
+		if (status != MV_OK)
+			continue;
+	}
+	mvNetaHalInit(&halData);
+
+	return;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysNetaApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNetaApi.h
new file mode 100644
index 0000000..be0aaa0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNetaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_NETA_API_H__
+#define __MV_SYS_NETA_API_H__
+
+
+void mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask);
+
+#endif /* __MV_SYS_NETA_API_H__ */
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
new file mode 100644
index 0000000..ce4e013
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
@@ -0,0 +1,1382 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysPci.h"
+#include "ddr2_3/mvDramIf.h"
+
+/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
+/* register offsets	and its function where its is located.			*/
+/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
+/* describes address remap register offsets					*/
+typedef struct _pciBarRegInfo
+{
+	MV_U32 funcNum;
+	MV_U32 baseLowRegOffs;
+	MV_U32 baseHighRegOffs;
+	MV_U32 sizeRegOffs;
+	MV_U32 remapLowRegOffs;
+	MV_U32 remapHighRegOffs;
+}PCI_BAR_REG_INFO;
+
+typedef struct _pciBarStatus
+{
+	MV_PCI_BAR	bar;
+	int		enable;
+}PCI_BAR_STATUS;
+
+PCI_BAR_STATUS pciBarStatusMap[] = 
+{
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	{CS0_BAR, EN},      
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+        {CS1_BAR, EN}, 	
+#endif	      		
+#if defined(MV_INCLUDE_SDRAM_CS2)
+        {CS2_BAR, EN}, 	
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+        {CS3_BAR, EN},   		
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)          		
+	{DEVCS0_BAR, EN},    	
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)          		
+	{DEVCS1_BAR, EN},    	
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)          		
+	{DEVCS2_BAR, EN},    	
+#endif
+	{BOOTCS_BAR, EN},     	
+	{MEM_INTER_REGS_BAR, EN},
+	{IO_INTER_REGS_BAR, EN}, 
+	{P2P_MEM0, DIS},     		
+	{P2P_IO, DIS},
+	{TBL_TERM, TBL_TERM}       	
+};
+
+/* PCI BAR table. Note that table entry number must match its target 		*/
+/* enumerator. For example, table entry '4' must describe Deivce CS0 		*/
+/* target which is represent by DEVICE_CS0 enumerator (4).                  */
+#if 0
+MV_PCI_BAR_WIN pciBarMap[] = 
+{
+/*     base low      base high      size        enable/disable				*/
+	{{SDRAM_CS0_BASE , 0, SDRAM_CS0_SIZE      	 },   EN},          
+	{{SDRAM_CS1_BASE , 0, SDRAM_CS1_SIZE      	 },   EN},          
+	{{SDRAM_CS2_BASE , 0, SDRAM_CS2_SIZE      	 },   EN},          
+	{{SDRAM_CS3_BASE , 0, SDRAM_CS3_SIZE      	 },   EN},          
+	{{DEVICE_CS0_BASE, 0, DEVICE_CS0_SIZE     	 },   EN},          
+	{{DEVICE_CS1_BASE, 0, DEVICE_CS1_SIZE     	 },   EN},          
+	{{DEVICE_CS2_BASE, 0, DEVICE_CS2_SIZE     	 },   EN},          
+	{{BOOTDEV_CS_BASE, 0, BOOTDEV_CS_SIZE     	 },   EN},          
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS}, 	/* Ignore P2P 	*/ 
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS},	/* Ignore P2P 	*/ 
+    /* Table terminator */
+    {{TBL_TERM, TBL_TERM, TBL_TERM}, TBL_TERM} 
+};
+#endif
+
+/* Locals */
+static MV_U32 pciBurstBytes2Reg(MV_U32 size);
+static MV_U32 pciBurstReg2Bytes(MV_U32 size);
+
+static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar,
+									 MV_ADDR_WIN *pAddrWin);
+
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, MV_PCI_BAR bar, 
+								  PCI_BAR_REG_INFO *pBarRegInfo);
+
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
+
+/* Forward declarations */
+const MV_8* pciBarNameGet(MV_PCI_BAR bar);
+
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*       This function initiate the PCI interface:
+*       1) Set local bus number. In case of convential PCI it gets the bus
+*          number using mvPciLocalBusNumGet(). In case of PCI-X this 
+*          information is read only.
+*       2) Interface device number. In case of conventional PCI it gets the
+*          device number using mvPciLocalDevNumGet(). In case of PCI-X this 
+*          information is read only.
+*       3) PCI Arbiter if needed.
+*       4) Enable Master and Slave on PCI interfaces.
+*	5) Open PCI BARs according to default setting. 
+*	   Note that PCI bridge (P2P) is NOT initialized.
+*	6) Enable CPU to PCI ordering.
+*
+* INPUT:
+*
+*       pciIf   - PCI interface number.
+*		localBus - Local Bus of the PCI interface to be set
+*		localDev - Local Dev of the PCI interface to be set
+*		bFirstCall - Indicates wether this is the first call of this
+*					 function .
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
+{
+	MV_PCI_BAR     bar, barix=0;
+	MV_PCI_MODE    pciMode;
+	MV_PCI_PROT_WIN pciProtWin;
+   	MV_PCI_BAR_WIN pciBarMap[PCI_MAX_BARS];  
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_TARGET target;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/* Parameter checking  */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	/* device and bus numbers */
+	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
+		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
+		return MV_ERROR;
+	}
+
+	/* First disable all PCI target windows  */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++)
+		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+
+	/* WA CQ 4382*/
+	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf) ,BIT15);
+
+	/* Loop over all BARs and copy enabled SDRAM windows only */
+	if (MV_OK != mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1)){
+		mvOsPrintf("mvPciInit: ERR. mvCtrlAddrWinMapBuild failed\n");
+		return MV_ERROR;
+	}
+
+	for (target = SDRAM_CS0; target <= SDRAM_CS3; target++) {
+		addrDecWin = &addrWinMap[target];
+		if (addrDecWin->enable == MV_TRUE) {
+			pciBarMap[barix].addrWin.baseLow = addrDecWin->addrWin.baseLow;
+			pciBarMap[barix].addrWin.baseHigh = addrDecWin->addrWin.baseHigh;
+			pciBarMap[barix].addrWin.size = addrDecWin->addrWin.size;
+			pciBarMap[barix].enable = EN;
+			barix++;
+		}
+	}
+
+	/* Initialize all non used BARs */
+	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
+		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
+		pciBarMap[bar].addrWin.baseHigh = 0;
+		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
+		pciBarMap[bar].enable = DIS;
+	}
+
+	/* finally fill table with TBL_TERM entry */
+	bar = PCI_MAX_BARS - 1;
+	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
+	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
+	pciBarMap[bar].addrWin.size = TBL_TERM;
+	pciBarMap[bar].enable =  TBL_TERM;
+
+
+    	/* Memory Mapped Internal Registers BAR can not be disabled.            */
+    	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
+    	if (MV_OK != mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR, &pciBarMap[MEM_INTER_REGS_BAR])) {
+        	mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
+        	return MV_ERROR;
+    	}        
+
+	/* Now, go through all targets in default table until table terminator	*/
+	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++)
+    	{
+		/* Skip the P2P BARs. They should be configured seperately			*/
+		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
+            		continue;
+
+		/* check if the size passed is zero ! */
+		if (0 == pciBarMap[bar].addrWin.size) {
+			/* disable the bar */
+			mvPciTargetWinEnable(pciIf,bar,MV_FALSE);
+			continue;
+		}
+
+		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
+			mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet %d failed\n", bar);
+			return MV_ERROR;
+		}        
+    	}
+	
+	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf), PADCR_REMAP_REG_WR_DIS);
+
+	/* configure access control unit 0 to DDR to enhance performance */
+	pciProtWin.addrWin.baseLow = 0;
+	pciProtWin.addrWin.baseHigh = 0;
+	pciProtWin.addrWin.size = mvDramIfSizeGet();
+#ifdef AURORA_IO_CACHE_COHERENCY
+	pciProtWin.attributes.snoop = WT_CACHE_COHER;
+#else
+	pciProtWin.attributes.snoop = NO_CACHE_COHER;
+#endif
+	pciProtWin.attributes.access = ALLOWED;
+	pciProtWin.attributes.write = ALLOWED;
+	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
+	pciProtWin.attributes.readMaxBurst = 128; 
+	pciProtWin.attributes.readBurst = 256;
+	pciProtWin.attributes.writeMaxBurst = 128;
+	pciProtWin.attributes.pciOrder = MV_FALSE;
+	pciProtWin.enable = MV_TRUE;
+	if( mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK ) {
+		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	mvPciHalInit(pciIf, pciIfmod);
+
+	return MV_OK;
+}
+
+
+
+/*******************************************************************************
+* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
+*
+* DESCRIPTION:
+*       This function sets an address window from PCI to a peripheral 
+*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs. 
+*       A new PCI BAR window is set for specified target address window.
+*       If address decode window parameter structure enables the window, 
+*       the routine will also enable the target window, allowing PCI to access
+*       the target window.
+*
+* INPUT:
+*       pciIf       - PCI interface number.
+*       bar         - BAR to be accessed by slave.
+*       pAddrBarWin - PCI target window information data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params 
+*       MV_ERROR otherwise 
+*       (e.g. address window overlapps with other active PCI target window).
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf,
+							MV_PCI_BAR bar, 
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 pciData;
+	MV_U32 sizeToReg;
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	size     = pAddrBarWin->addrWin.size;
+	baseLow  = pAddrBarWin->addrWin.baseLow;
+	baseHigh = pAddrBarWin->addrWin.baseHigh;
+
+	/* Parameter checking   */
+	if(pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if(bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+
+	/* if the address windows is disabled , we only disable the appropriare
+	pci bar and ignore other settings */
+
+	if (MV_FALSE == pAddrBarWin->enable)
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+		return MV_OK;
+	}
+
+	if (0 == pAddrBarWin->addrWin.size)
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n",bar);
+        return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(baseLow, size))
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+    /* 2) Check if the requested window overlaps with current windows		*/
+	if(MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin))
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Overlap detected for target %d\n",
+																		bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Get size register value according to window size						*/
+	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
+
+	/* Size parameter validity check.                                   */
+	if (-1 == sizeToReg)
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n",bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+	
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+	
+	/* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{    
+		/* Update size register */
+		MV_REG_WRITE(barRegInfo.sizeRegOffs, (sizeToReg << BAR_SIZE_OFFS));
+	}
+	
+	/* Read current address */
+	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+													barRegInfo.baseLowRegOffs);
+
+	/* Clear current address */
+	pciData &= ~PBBLR_BASE_MASK;
+	pciData |= (baseLow & PBBLR_BASE_MASK);
+		
+	/* Write new address */
+	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+											barRegInfo.baseLowRegOffs, pciData);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum, 
+										barRegInfo.baseHighRegOffs, baseHigh);	
+	}
+
+	/* Enable/disable the BAR */
+    if (MV_TRUE == pAddrBarWin->enable)
+    {
+        MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+    }
+	else
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinGet - Get PCI to peripheral target address window
+*
+* DESCRIPTION:
+*		Get the PCI to peripheral target address window BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*       bar   - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       pAddrBarWin - PCI target window information data structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR bar, 
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	MV_U32 barEnable;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Reading Base Low bar */
+	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+												barRegInfo.baseLowRegOffs);
+
+	baseLow &= PBBLR_BASE_MASK;
+
+	/* Skip base high if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		/* Reading Base High */
+		baseHigh = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+												barRegInfo.baseHighRegOffs);
+	}
+	else
+	{
+		baseHigh = 0;
+	}
+
+    /* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{    
+		/* Reading bar size*/
+		size = ctrlRegToSize(
+					(MV_REG_READ(barRegInfo.sizeRegOffs) >> PBSR_SIZE_OFFS), 
+														PBBLR_BASE_ALIGNMET);
+	}
+	else
+	{
+		size = INTER_REGS_SIZE;
+	}
+
+	/* Assign value to user struct */
+	pAddrBarWin->addrWin.baseLow  = baseLow;
+	pAddrBarWin->addrWin.baseHigh = baseHigh;
+	pAddrBarWin->addrWin.size     = size;
+
+	/* Check if window is enabled   */
+	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+	
+	if (~barEnable & (BARER_ENABLE(bar)))
+    {
+        pAddrBarWin->enable = MV_TRUE;
+    }
+    else
+    {
+        pAddrBarWin->enable = MV_FALSE;
+    }
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetWinEnable - Enable/disable a PCI BAR window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI BAR window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the 
+*       window, thus enabling PCI accesses for that BAR (before enabling the 
+*       window it is tested for overlapping). Otherwise, the window will 
+*       be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       bar    - BAR to be accessed by slave.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, MV_PCI_BAR bar, MV_BOOL enable)
+{
+	MV_PCI_BAR_WIN barWin;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n",
+                                                                        pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+	
+	if (MV_TRUE == enable)
+	{   /* First check for overlap with other enabled windows				*/
+        /* Get current window */
+		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin))
+		{
+			mvOsPrintf("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+
+		/* Check for overlapping */
+		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin))
+		
+		{   /* Overlap detected	*/
+			mvOsPrintf("mvPciTargetWinEnable: ERR. Overlap detected\n");
+			return MV_ERROR;
+		}
+		else
+		{
+			/* No Overlap. Enable address decode target window              */
+			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf),BARER_ENABLE(bar));
+		}
+	}
+	else
+	{
+		/* Disable address decode target window                             */
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinSet - Set PCI protection access window
+*
+* DESCRIPTION:
+*       This function sets a specified address window with access protection 
+*       attributes. If protection structure enables the window the routine will
+*       also enable the protection window.
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - Protection window structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, 
+						  MV_U32 winNum, 
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow, 
+                                 pProtWin->addrWin.size))
+	{
+        mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
+                   pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
+
+		return MV_BAD_PARAM;
+	}
+
+	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
+					                            pProtWin->attributes.swapType);
+		return MV_BAD_PARAM;
+
+	}
+
+	/* 1) Calculate protection window base low register value	*/
+	protBaseLow  =  pProtWin->addrWin.baseLow;
+
+	/* Setting the appropriate bits according to the passed values */
+	if (MV_TRUE == pProtWin->enable) 
+	{
+		protBaseLow |= PACBLR_EN;
+	}
+	else
+	{
+		protBaseLow &= ~PACBLR_EN;
+	}
+
+	/* I/O Cache Coherency */
+	protBaseLow |= ((MV_U32)pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
+
+	/* Access protect */
+	if (ALLOWED == pProtWin->attributes.access)
+	{
+		protBaseLow &= ~PACBLR_ACCPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_ACCPROT;
+	}
+
+	/* Write Protect */
+	if (ALLOWED == pProtWin->attributes.write)
+	{
+		protBaseLow &= ~PACBLR_WRPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_WRPROT;
+	}
+	
+	/* PCI slave Data Swap Control */
+	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
+
+
+	/* Read Max Burst */
+	if (( pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS);
+
+
+	/* Typical PCI read transaction Size. Only valid for PCI conventional */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS);
+
+
+	/* 2) Calculate protection window base high register value	*/
+	protBaseHigh =  pProtWin->addrWin.baseHigh;
+
+	/* 3) Calculate protection window size register value	*/
+	protSize     =  ctrlSizeToReg(pProtWin->addrWin.size, PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
+    
+
+	/* Write Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
+		return MV_ERROR;
+	}
+	protSize |= (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+    if (MV_TRUE == pProtWin->attributes.pciOrder)
+	{
+		protSize |= PACSR_PCI_ORDERING;
+	}
+	else
+	{
+		protSize &= ~PACSR_PCI_ORDERING;
+	}
+		    
+	/* Writing protection window walues into registers */
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), protBaseLow);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum), protBaseHigh);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum),  protSize);
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvPciProtWinGet - Get PCI protection access window
+*
+* DESCRIPTION:
+*       This function gets a specified address window and access protection 
+*       attributes for a specific protection window .
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - pointer to a Protection window structure.
+*
+* OUTPUT:
+*       pProtWin - Protection window structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, 
+						  MV_U32 winNum, 
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Writing protection window walues into registers */
+	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum));
+	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum));
+	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum));
+
+
+	/* 1) Get Protection Windows base low 	*/
+	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
+
+	/* Get the appropriate protection attributes according to register bits*/
+
+	/* Is Windows enabled ? */
+	if (protBaseLow & PACBLR_EN)
+	{
+		pProtWin->enable = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->enable = MV_FALSE;
+	}
+
+
+	/* What is access protect ? */
+	if (protBaseLow & PACBLR_ACCPROT)
+	{
+		pProtWin->attributes.access = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.access = ALLOWED;
+	}
+
+	/* Is write protect ? */
+	if (protBaseLow & PACBLR_WRPROT)
+	{
+		pProtWin->attributes.write = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.write = ALLOWED;
+	}
+
+
+    	/* PCI slave Data Swap Control */
+	pProtWin->attributes.swapType = (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
+
+
+	/* Read Max Burst */
+	pProtWin->attributes.readMaxBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >> PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. */
+	pProtWin->attributes.readBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >> PACBLR_RDSIZE_OFFS);
+
+
+	/* window base high register value	*/
+	pProtWin->addrWin.baseHigh = protBaseHigh;
+
+	/*Calculate protection window size register value	*/
+	pProtWin->addrWin.size = ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS),PACSR_SIZE_ALIGNMENT);
+
+
+	/* Write Max Burst */
+	pProtWin->attributes.writeMaxBurst = pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >> PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (protSize & PACSR_PCI_ORDERING)
+	{
+		pProtWin->attributes.pciOrder = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->attributes.pciOrder = MV_FALSE;
+	}
+
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinEnable - Enable/disable a PCI protection access window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI protection access window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the 
+*       protection window, otherwise, the protection window will be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       winNum - Protecion window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n", 
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+    if (MV_TRUE == enable)
+    {
+        MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+    }
+	else
+	{
+        MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetRemap - Set PCI to target address window remap.
+*
+* DESCRIPTION:
+*       The PCI interface supports remap of the BAR original address window.
+*       For each BAR it is possible to define a remap address. For example
+*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
+*       according to remap register but will also be targeted to the 
+*       SDRAM CS[0].
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       bar      - Peripheral target enumerator accessed by slave.
+*       pAddrWin - Address window to be checked.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf,
+						   MV_PCI_BAR bar,
+                           MV_ADDR_WIN *pAddrWin)
+{
+	PCI_BAR_REG_INFO barRegInfo;
+	
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n", 
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT))
+	{
+		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
+				   "\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+				   pciIf,
+				   pciBarNameGet(bar),
+                   pAddrWin->baseLow,
+				   pAddrWin->size);
+		return MV_ERROR;
+	}
+
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Set remap low register value */
+	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
+	
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.remapHighRegOffs)
+	{
+		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciWinOverlapDetect - Detect address windows overlapping
+*
+* DESCRIPTION:
+*       This function detects address window overlapping of a given address 
+*       window in PCI BARs.
+*
+* INPUT:
+*       pAddrWin - Address window to be checked.
+*       bar      - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32		barEnableReg;
+	MV_U32		targetBar;
+	MV_PCI_BAR_WIN	barAddrWin;
+
+	/* Read base address enable register. Do not check disabled windows		*/
+	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+	
+	for(targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
+	        /* don't check our target or illegal targets */
+        	if (targetBar == bar)
+            		continue;
+        
+		/* Do not check disabled windows	*/
+		if (barEnableReg & (BARER_ENABLE(targetBar)))
+			continue;
+
+		/* Get window parameters 	*/
+		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+        
+		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR*/
+		if (((bar == MEM_INTER_REGS_BAR)&&(targetBar == IO_INTER_REGS_BAR)) ||
+			((bar == IO_INTER_REGS_BAR)&&(targetBar == MEM_INTER_REGS_BAR))) {
+			return MV_FALSE;
+		} else if(MV_TRUE == mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {                    
+			mvOsPrintf("pciWinOverlapDetect: BAR %d overlap current %d\n", bar, targetBar);
+			return MV_TRUE;           
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* cpuWinIsValid - Check if the given address window is valid
+*
+* DESCRIPTION:
+*		PCI spec restrict BAR base to be aligned to BAR size.
+*		This function checks if the given address window is valid.
+*
+* INPUT:
+*       baseLow - 32bit low base address.
+*       size    - Window size.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
+{
+
+	/* PCI spec restrict BAR base to be aligned to BAR size					*/
+	if(MV_IS_NOT_ALIGN(baseLow, size))
+	{
+		return MV_ERROR;
+	}
+	else
+	{
+		return MV_TRUE;
+	}
+}
+
+/*******************************************************************************
+* pciBarRegInfoGet - Get BAR register information
+*
+* DESCRIPTION:
+* 		PCI BARs registers offsets are inconsecutive. 
+*		This function gets a PCI BAR register information like register offsets
+*		and function location of the BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*		bar	  - The PCI BAR in question.	
+*
+* OUTPUT:
+*       pBarRegInfo - BAR register info struct.
+*
+* RETURN:
+*		MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
+*
+*******************************************************************************/
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, 
+								  MV_PCI_BAR bar,
+								  PCI_BAR_REG_INFO *pBarRegInfo)
+{
+	switch (bar)
+	{
+		/* Function 0 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR:      		/* SDRAM chip select 0 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR:      		/* SDRAM chip select 1 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case MEM_INTER_REGS_BAR: /* Memory Mapped Internal bar */
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
+			pBarRegInfo->baseHighRegOffs  = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
+			pBarRegInfo->sizeRegOffs      = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+		/* Function 1 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR:      		/* SDRAM chip select 2 bar*/
+			pBarRegInfo->funcNum          = 1;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR:      		/* SDRAM chip select 3 bar*/
+			pBarRegInfo->funcNum		  = 1;
+			pBarRegInfo->baseLowRegOffs	  = PCI_SCS3_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS3_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_CS3_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS3_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS0) 
+		/* Function 2 Bars */
+		case DEVCS0_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS1) 
+		case DEVCS1_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS2) 
+		case DEVCS2_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case BOOTCS_BAR:      	/* Boot device chip select bar*/
+			pBarRegInfo->funcNum		  = 3;
+			pBarRegInfo->baseLowRegOffs	  = PCI_BOOTCS_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_BOOTCS_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_BOOTCS_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+		/* Function 4 Bars */
+		case P2P_MEM0:      		/* P2P memory 0 */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_P2P_MEM0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_P2P_MEM0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
+			break;
+		case P2P_IO:        		/* P2P IO */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs   = PCI_P2P_IO_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_IO_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		case IO_INTER_REGS_BAR: /* IO Mapped Internal bar */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+	
+		default: 
+			mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
+			return MV_ERROR;
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciBarNameGet - Get the string name of PCI BAR.
+*
+* DESCRIPTION:
+*		This function get the string name of PCI BAR.
+*
+* INPUT:
+*       bar - PCI bar number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       pointer to the string name of PCI BAR.
+*
+*******************************************************************************/
+const MV_8* pciBarNameGet( MV_PCI_BAR bar )
+{
+	switch( bar ) 
+	{
+	#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR: 
+			return "CS0_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR: 
+			return "CS1_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR: 
+			return "CS2_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR: 
+			return "CS3_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS0)
+		case DEVCS0_BAR: 
+			return "DEVCS0_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS1)
+		case DEVCS1_BAR: 
+			return "DEVCS1_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS2)
+		case DEVCS2_BAR: 
+			return "DEVCS2_BAR...........";
+	#endif
+		case BOOTCS_BAR: 
+			return "BOOTCS_BAR...........";
+		case MEM_INTER_REGS_BAR: 
+			return "MEM_INTER_REGS_BAR...";
+		case IO_INTER_REGS_BAR: 
+			return "IO_INTER_REGS_BAR....";
+		case P2P_MEM0: 
+			return "P2P_MEM0.............";
+		case P2P_IO: 
+			return "P2P_IO...............";
+		default:
+			 return "target unknown";
+	}
+}
+
+/*******************************************************************************
+* mvPciAddrDecShow - Print the PCI address decode map (BARs).
+*
+* DESCRIPTION:
+*		This function print the PCI address decode map (BARs).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvPciAddrDecShow(MV_VOID)
+{
+	MV_PCI_BAR_WIN win;
+	MV_PCI_BAR bar;
+	MV_U32 pciIf;
+
+	for( pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++ )
+	{ 
+		mvOsOutput( "\n" );
+		mvOsOutput( "PCI%d:\n", pciIf );
+		mvOsOutput( "-----\n" );
+
+		for( bar = 0; bar < PCI_MAX_BARS; bar++ ) 
+		{
+			memset( &win, 0, sizeof(MV_PCI_BAR_WIN) );
+
+			mvOsOutput( "%s ", pciBarNameGet(bar) );
+
+			if( mvPciTargetWinGet( pciIf, bar, &win ) == MV_OK )
+			{
+				if( win.enable )
+				{
+                    mvOsOutput( "base %08x, ", win.addrWin.baseLow );
+                    mvSizePrint( win.addrWin.size );
+                    mvOsOutput( "\n" );
+				}
+				else
+					mvOsOutput( "disable\n" );
+			}
+		}
+	}	
+}
+
+/* convert burst bytes to register value*/
+static MV_U32 pciBurstBytes2Reg(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 32: ret = 0; break;
+                case 64: ret = 1; break;
+                case 128: ret = 2; break;
+                case 256: ret = 3; break;
+                default: ret = 0xF; /* error */
+        }
+        return ret;
+}
+
+/* convert register value to burst bytes*/
+static MV_U32 pciBurstReg2Bytes(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 0: ret = 32; break;
+                case 1: ret = 64; break;
+                case 2: ret = 128; break;
+                case 3: ret = 256; break;
+                default: ret = 0x0; /* error */
+        }
+        return ret;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.h
new file mode 100644
index 0000000..9f58f04
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.h
@@ -0,0 +1,256 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCSysPCIH
+#define __INCSysPCIH
+
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "pci/mvPci.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvSysPciConfig.h"
+
+#define PCI_MAX_PROT_WIN			6
+
+/* 4KB granularity */
+#define MINIMUM_WINDOW_SIZE     		0x1000
+#define MINIMUM_BAR_SIZE        		0x1000
+#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
+#define BAR_SIZE_OFFS				12
+#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
+
+#define PCI_IO_WIN_NUM          		1   /* Number of PCI_IO windows  */
+#define PCI_MEM_WIN_NUM         		4   /* Number of PCI_MEM windows */
+
+#ifndef MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvLib.h"
+typedef enum _mvPCIBars
+{
+	PCI_BAR_TBL_TERM = -1, /* none valid bar, used as bars list terminator */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	CS0_BAR,
+#endif	
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	CS1_BAR,
+#endif	      		
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	CS2_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	CS3_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)          		
+	DEVCS0_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)          		
+	DEVCS1_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)          		
+	DEVCS2_BAR,
+#endif
+	BOOTCS_BAR,      	/* Boot device chip select bar*/
+	MEM_INTER_REGS_BAR, 	/* Memory Mapped Internal bar */
+	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
+	P2P_MEM0,      		/* P2P memory 0 */
+	P2P_IO,        		/* P2P IO */
+	PCI_MAX_BARS
+}MV_PCI_BAR;
+#endif /* MV_ASMLANGUAGE */
+
+#if defined(MV_INCLUDE_SDRAM_CS3)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar) 		((bar >= CS0_BAR) && (bar <= CS3_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS2)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS1)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS0)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
+#endif
+
+
+/****************************************/
+/* PCI Slave Address Decoding registers */
+/****************************************/
+#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
+#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
+#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
+#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
+#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80)) 
+#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80)) 
+#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80)) 
+#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80)) 
+#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80)) 
+#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80)) 
+#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80)) 
+#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80)) 
+#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80)) 
+#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80)) 
+#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80)) 
+#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80)) 
+#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80)) 
+#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
+#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
+#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
+
+/* PCI Bars Size Registers (PBSR) */
+#define PBSR_SIZE_OFFS				12
+#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
+
+/* Base Address Registers Enable Register (BARER) */
+#define BARER_ENABLE(target)			(1 << (target))
+
+/* PCI Base Address Remap Registers (PBARR) */
+#define PBARR_REMAP_OFFS			12
+#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
+#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
+
+/* PCI DRAM Bar Bank Select Register (PDBBSR) */
+#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
+#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
+
+/* PCI Address Decode Control Register (PADCR)*/
+#define PADCR_REMAP_REG_WR_DIS			BIT0
+#define PADCR_MSG_REG_ACC			BIT3
+
+#define PADCR_VPD_HIGH_ADDR_OFFS		8 /* Bits [31:15] of the VPD address */
+#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
+
+/* PCI Headers Retarget Control Register (PHRCR) */
+#define PHRCR_ENABLE				BIT0
+#define PHRCR_BUFF_SIZE_OFFS			1 
+#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_MASK1_OFFS			16
+#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
+
+/* PCI Headers Retarget Base Register (PHRBR) */
+#define PHRBR_BASE_OFFS				16
+#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
+
+/* PCI Headers Retarget Base High Register (PHRBHR) */
+#define PHRBHR_BASE_OFFS			0
+#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
+
+/* This structure describes a PCI BAR. It is also refered as PCI target     */
+/* window to keep consistency with other address decode units in the system */
+typedef struct _mvPciBarWin 
+{
+    MV_ADDR_WIN		addrWin;	/* Address window       */
+    MV_BOOL     	enable;		/* BAR enable/disable   */
+}MV_PCI_BAR_WIN;
+
+typedef enum
+{
+    NO_CACHE_COHER = 0,
+    WT_CACHE_COHER,
+    WB_CACHE_COHER
+}MV_PCI_SNOOP;
+
+/* This structure describes PCI region attributes                           */
+typedef struct _mvPciRegionAttr
+{
+    MV_PCI_SNOOP	snoop;		/* Cache Coherenc			*/
+    MV_PROT_RIGHT	access;         /* Access protection                    */
+    MV_PROT_RIGHT	write;          /* Write protection                     */
+    MV_SWAP_TYPE	swapType;       /* Data swap mode for that region       */
+    MV_U32		readMaxBurst;   /* Read max burst                       */
+    MV_U32		readBurst;      /* Read burst. Conventional PCI only    */
+    MV_U32		writeMaxBurst;  /* Write max burst                      */
+    MV_BOOL		pciOrder;       /* Hardware support for PCI ordering    */
+}MV_PCI_REGION_ATTR;
+
+/* The PCI slave interface supports configurable access control.            */
+/* It is possible to define up to six address ranges to different           */
+/* configurations. This structure describes the PCI access region           */
+typedef struct _mvPciProtWin
+{
+    MV_ADDR_WIN         addrWin;	/* An address window                    */
+    MV_PCI_REGION_ATTR  attributes;	/* Window attributes                    */
+    MV_BOOL             enable;		/* Window enabled/disabled              */
+}MV_PCI_PROT_WIN;
+
+/* Global Functions prototypes */
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf,MV_PCI_BAR slaveTarget, MV_BOOL enable);
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_ADDR_WIN *pAddrWin);
+MV_VOID   mvPciAddrDecShow(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPex.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPex.c
new file mode 100644
index 0000000..e04ed71
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPex.c
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum, MV_PEX_DEC_WIN *pAddrDecWin);
+
+
+/*******************************************************************************
+* mvSysPexInit - Initialize the Pex subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
+{
+	MV_PEX_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvPexWinInit(pexIf, pexType, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.maxPexIf = mvCtrlPexMaxIfGet();
+		status = mvPexInit(pexIf, pexType, &halData);
+	}
+
+	return status;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPexApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPexApi.h
new file mode 100644
index 0000000..1b6a6bf
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPexApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_PEX_API_H__
+#define __MV_SYS_PEX_API_H__
+
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysSFlash.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSFlash.c
new file mode 100644
index 0000000..2b84d9c
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSFlash.c
@@ -0,0 +1,226 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "sflash/mvSysSFlash.h"
+
+#define MV_SYS_SFLASH_MAX_CMD_LEN 4
+
+static struct {
+	MV_U8 buf[MV_SYS_SFLASH_MAX_CMD_LEN];
+	MV_U32 bufLen;
+	MV_U8  transType;
+} mvSysSflashCmd;
+
+/*******************************************************************************
+* mvSysSflashCommandSet
+*
+* DESCRIPTION:
+*	System interface for sending a command to the SPI flash.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*      	cmdBuff:     Command data to be written.
+*	cmdLen:	     Command length in bytes.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashCommandSet(MV_VOID *flashHandle, MV_U8* cmdBuff, MV_U32 cmdLen,
+		MV_U8 transType)
+{
+	if (cmdLen > MV_SYS_SFLASH_MAX_CMD_LEN)
+		return MV_ERROR;
+
+	if (!(transType & SYS_SFLASH_TRANS_START) || (mvSysSflashCmd.transType != 0))
+		return MV_ERROR;	
+
+	mvSpiParamsSet(0, 0, SPI_TYPE_FLASH);
+
+	memcpy(mvSysSflashCmd.buf,cmdBuff,cmdLen);	
+	mvSysSflashCmd.bufLen = cmdLen;
+	mvSysSflashCmd.transType = transType;
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		return mvSysSflashDataWrite(flashHandle, NULL, 0, transType);
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataRead
+*
+* DESCRIPTION:
+*	System interface for reading SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer to read the data into.
+*	dataLen:     Number of bytes to read.
+*	dummyBytes:  Number of dummy bytes to read before reading the real
+*		     data.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	dataBuff: The data as read from flash.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataRead(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U32 dummyBytes, MV_U8 transType)
+{
+	MV_STATUS  ret;	
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+
+	ret = mvSpiWriteThenRead (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+			dataBuff, dataLen, dummyBytes);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataWrite
+*
+* DESCRIPTION:
+*	System interface for writing SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer holding the data to be written.
+*	dataLen:     Number of bytes to write.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataWrite(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenWrite (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen, dataBuff, dataLen);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashFreqSet
+*
+* DESCRIPTION:
+*	System interface for controlling the SPI interface frequency.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	freq:	     The new frequency to be configured for the SPI IF.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashFreqSet(MV_VOID *flashHandle, MV_U32 freq)
+{
+
+	return mvSpiBaudRateSet(0, freq);
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysSata.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSata.c
new file mode 100644
index 0000000..a0317c9
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSata.c
@@ -0,0 +1,82 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "sata/CoreDriver/mvSata.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+MV_STATUS mvSysSataWinInit(MV_VOID)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvSataWinInit(addrWinMap);
+
+	return status;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysSataApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSataApi.h
new file mode 100644
index 0000000..575a8d6
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSataApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SATA_API_H__
+#define __MV_SYS_SATA_API_H__
+
+MV_STATUS mvSysSataWinInit(MV_VOID);
+
+#endif 
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpi.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpi.c
new file mode 100644
index 0000000..b407634
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpi.c
@@ -0,0 +1,126 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSysSpi.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+
+/*******************************************************************************
+* mvSysSpiInit - Initialize the SPI subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
+{
+	MV_SPI_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.tclk = mvBoardTclkGet();
+
+	return mvSpiInit(spiId, serialBaudRate, &halData);
+}
+
+
+/*******************************************************************************
+* mvSysSpiMppConfig
+*
+* DESCRIPTION:
+*	System interface for configuring the MPP's configuration to enable /
+*	disable SPI mode.
+*
+* INPUT:
+*      	mode:	The mode to be set into MPP unit.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
+{
+#if 0
+	if(mode == SYS_SPI_MPP_ENABLE)
+		mvMPPConfigToSPI();
+	else
+		mvMPPConfigToDefault();
+#endif
+	return MV_OK;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpiApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpiApi.h
new file mode 100644
index 0000000..80888c0
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysSpiApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SPI_API_H__
+#define __MV_SYS_SPI_API_H__
+
+MV_STATUS   mvSysSpiInit(MV_U8 spi_id, MV_U32 serialBaudRate);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdm.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdm.c
new file mode 100644
index 0000000..83c9d59
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdm.c
@@ -0,0 +1,236 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#ifdef CONFIG_MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+ #include "gpp/mvGpp.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "spi/mvSpi.h"
+
+#define MAX_DATA_LENGTH		255
+
+/*******************************************************************************
+* mvSysTdmInit - Initialize the TDM subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
+{
+	MV_TDM_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmWinInit(addrWinMap);
+#else
+		status = mvCommUnitWinInit(addrWinMap);
+#endif
+
+	if(status == MV_OK) {
+		halData.spiMode = mvBoardTdmSpiModeGet();
+		halData.model = mvCtrlModelGet();
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmHalInit (tdmParams, &halData);
+#else
+		halData.maxCs = mvBoardTdmDevicesCountGet();
+		status = mvCommUnitHalInit (tdmParams, &halData);
+		
+		/* Issue SLIC reset */
+		mvGppValueSet(0, BIT24, 0);
+		mvOsDelay(1);
+		mvGppValueSet(0, BIT24, BIT24);
+#endif
+	}
+
+	return status;
+}
+
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+	
+	if(MV_OK != mvSpiWriteThenRead (0, cmdBuff, cmdSize, dataBuff, dataSize, 0))
+		printk("SPI read failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmSpiWrite - telephony register write via SPI interface
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+	
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenWrite (0, cmdBuff, cmdSize, dataBuff, dataSize))
+		printk("SPI write failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmIntEnable - Enable CSLAC device interrupts. 
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntEnable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntEnable(deviceId);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmIntDisable - Disable CSLAC device interrupts. 
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntDisable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntDisable(deviceId);
+
+#endif
+}
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdmApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdmApi.h
new file mode 100644
index 0000000..74ca023
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTdmApi.h
@@ -0,0 +1,78 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TDM_API_H__
+#define __MV_SYS_TDM_API_H__
+
+#include "mvSysTdmConfig.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+  #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+MV_STATUS mvSysTdmInit (MV_TDM_PARAMS* tdmParams);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysTs.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTs.c
new file mode 100644
index 0000000..79ea4e8
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTs.c
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ts/mvTsu.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ts/mvTsuRegs.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvTsuWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		status = mvTsuHalInit(coreClock, mode, osHandle);
+	return status;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysTsApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTsApi.h
new file mode 100644
index 0000000..837782d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysTsApi.h
@@ -0,0 +1,73 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TS_API_H__
+#define __MV_SYS_TS_API_H__
+
+#include "ts/mvTsu.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsb.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsb.c
new file mode 100644
index 0000000..f84e065
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsb.c
@@ -0,0 +1,103 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "usb/mvUsb.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "usb/mvUsbRegs.h"
+
+/*******************************************************************************
+* mvSysUsbHalInit - Initialize the USB subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
+{
+	MV_USB_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvUsbWinInit(dev, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+		status = mvUsbHalInit(dev, isHost, &halData);
+	}
+
+	return status;
+}
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsbApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsbApi.h
new file mode 100644
index 0000000..675b608
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysUsbApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_USB_API_H__
+#define __MV_SYS_USB_API_H__
+
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysXor.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysXor.c
new file mode 100644
index 0000000..20acd3e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysXor.c
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "xor/mvXor.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "xor/mvXorRegs.h"
+
+MV_VOID mvSysXorInit (void)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvXorWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		mvXorHalInit(MV_XOR_MAX_CHAN);
+	return;
+}
+
+
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysXorApi.h b/arch/arm/mach-armadaxp/mv_hal_if/mvSysXorApi.h
new file mode 100644
index 0000000..fb2b06d
--- /dev/null
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysXorApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_XOR_API_H__
+#define __MV_SYS_XOR_API_H__
+
+MV_VOID mvSysXorInit (void);
+
+#endif
diff --git a/arch/arm/mach-armadaxp/pci.c b/arch/arm/mach-armadaxp/pci.c
new file mode 100644
index 0000000..6951093
--- /dev/null
+++ b/arch/arm/mach-armadaxp/pci.c
@@ -0,0 +1,243 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+                                                                                                                             
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysPci.h"
+#include "pci/mvPci.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x) 
+#endif
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+	
+	if (mvCtrlPciMaxIfGet() > 1)
+		panic("Single PCI is supported ONLY!");
+
+       	mvPciInit(0, MV_PCI_MOD_HOST);
+
+	/* I/O remmap */
+	win.baseLow = 0x0;
+	win.baseHigh = 0x0;
+	mvCpuIfPciRemap(PCI_IF0_IO, &win);
+}
+
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+                          int size, u32 *val)
+{
+
+        MV_U32 bus_num,func,regOff,dev_no,temp;
+	MV_U32 localBus;
+ 
+	*val = 0xffffffff;
+
+        bus_num = bus->number;
+        dev_no = PCI_SLOT(devfn);
+ 
+	/* don't return for our device */
+	localBus = mvPciLocalBusNumGet(0);
+	if((dev_no == 0) && ( bus_num == localBus)) {
+		DB(printk("PCI 0 read from our own dev return 0xffffffff \n"));
+		return 0xffffffff;
+	}
+
+        func = PCI_FUNC(devfn); 
+        regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	if ((func == 0)&&(dev_no < 2))
+		DB(printk("PCI 0 read: bus = %x dev = %x func = %x regOff = %x ",bus_num,dev_no,func,regOff));
+	
+
+        temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+
+        switch (size) {
+        case 1:
+                temp = (temp >>  (8*(where & 0x3))) & 0xff;
+                break;
+ 
+        case 2:
+                temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+                break;
+ 
+        default:
+                break;
+        }
+	
+	*val = temp;
+
+	if ((func == 0)&&(dev_no < 2)) {
+		DB(printk(" got %x \n",temp));
+	}
+	
+        return 0;
+}
+
+static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+        MV_U32 bus_num,func,regOff,dev_no,temp, mask , shift;
+ 
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn); 
+	func = PCI_FUNC(devfn); 
+	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	DB(printk("PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x \n",val,size,bus_num,dev_no,func,regOff));
+	if( size != 4)
+        	temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+        switch (size) {
+        case 1:
+		shift = (8*(where & 0x3));
+		mask = 0xff;
+                break;
+ 
+        case 2:
+		shift = (8*(where & 0x2));
+                mask = 0xffff; 
+                break;
+ 
+        default:
+		shift = 0;
+		mask = 0xffffffff;
+                break;
+        }
+	
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
+
+        return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci0_read_config,
+        .write  = mv_pci0_write_config,
+};
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+        struct resource *res;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+        sys->map_irq = mv_map_irq;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+        if (!res)
+                panic("PCI: unable to alloc resources");
+                                                                                                                             
+        memset(res, 0, sizeof(struct resource) * 2);
+                                                                                                                             
+	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
+	res[0].end   =  mv_pci_io_base_get(0) - IO_SPACE_REMAP +  mv_pci_io_size_get(0) - 1;
+	res[0].name  = "PCI0 IO Primary";
+	res[0].flags = IORESOURCE_IO;
+                                                                                                                             
+	res[1].start =  mv_pci_mem_base_get(0);
+	res[1].end   =  mv_pci_mem_base_get(0) +  mv_pci_mem_size_get(0) - 1;
+	res[1].name  = "PCI0 Memory Primary";
+	res[1].flags = IORESOURCE_MEM;
+ 
+        if (request_resource(&ioport_resource, &res[0]))
+		printk ("IO Request resource failed - Pci If %x\n",nr);
+
+	if (request_resource(&iomem_resource, &res[1]))
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+ 
+        sys->resource[0] = &res[0];
+        sys->resource[1] = &res[1];
+        sys->resource[2] = NULL;
+        sys->io_offset   = 0x0;
+ 
+        return 1;
+
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops;
+	struct pci_bus *bus;
+
+        if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	ops = &mv_pci_ops;
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCI0;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .map_irq                = mv_map_irq,
+        .setup                  = mv_pci_setup,
+        .scan                   = mv_pci_scan_bus,
+        .preinit                = mv_pci_preinit,
+};
+ 
+static int __init mv_pci_init(void)
+{
+	MV_U32 ifnum = mvCtrlPciMaxIfGet();
+	if (ifnum) {
+		mv_pci.nr_controllers = ifnum; 
+		pci_common_init(&mv_pci);
+	}
+
+    return 0;
+}
+
+subsys_initcall(mv_pci_init);
+
diff --git a/arch/arm/mach-armadaxp/pex.c b/arch/arm/mach-armadaxp/pex.c
new file mode 100644
index 0000000..ab2f3bd
--- /dev/null
+++ b/arch/arm/mach-armadaxp/pex.c
@@ -0,0 +1,417 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+                                                                                                                             
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "pex/mvPexRegs.h"
+#include "mvSysPexApi.h"
+
+#ifdef MV_DEBUG
+#	define DB(x) x
+#else
+#	define DB(x) 
+#endif
+
+#define MV_PEX_MASK_ABCD              (BIT24 | BIT25 | BIT26 | BIT27)
+
+static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+extern int mv_is_pci_io_mapped(int ifNum);
+extern MV_TARGET mv_pci_io_target_get(int ifNum);
+
+static void* mv_get_irqmap_func[] __initdata =
+{
+	mv_map_irq_0,
+	mv_map_irq_1,
+	mv_map_irq_2,
+	mv_map_irq_3,
+	mv_map_irq_4,
+	mv_map_irq_5,
+	mv_map_irq_6,
+	mv_map_irq_7,
+	mv_map_irq_8,
+	mv_map_irq_9
+};
+
+void __init mv_pex_preinit(void)
+{
+	static MV_U32 pex0flg = 0;
+	unsigned int pciIf, temp;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pciIf = 0; pciIf < boardPexInfo->boardPexIfNum; pciIf++) 
+	{
+		/* Translate logical interface number to physical */
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		printk("PCI-E: Cheking physical bus #%d (controller #%d): ", pciIf, pexHWInf);
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+		{
+			printk("Disabled\n");
+			continue;
+		}
+
+		/* init the PCI interface */
+		temp = mvSysPexInit(pexHWInf, MV_PEX_ROOT_COMPLEX);
+
+		if (MV_NO_SUCH == temp)
+		{
+			printk("Enabled - No Link\n");
+			/* No Link - shutdown interface */
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pexHWInf, MV_FALSE);;
+			continue;
+		}
+		else if ((MV_OK != temp) && (MV_NO_SUCH != temp)){
+			printk("Init FAILED!!!\n");
+			printk("PCI-E %d: Init Failed.\n", pexHWInf);
+		}
+
+		printk("Enabled - Link UP\n");
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == 0) {
+	       		mvPexLocalBusNumSet(pexHWInf, 0x0);
+	       		pex0flg = 1;
+		}
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
+		if (mv_is_pci_io_mapped(pexHWInf))
+		{
+			pciIoRemap.baseLow = mv_pci_io_base_get(pexHWInf) - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0; 		
+			pciIoRemap.size = mv_pci_io_size_get(pexHWInf);
+			mvCpuIfPexRemap(mv_pci_io_target_get(pexHWInf), &pciIoRemap);
+		}
+	}
+}
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci_read_config(struct pci_bus *bus, 
+				  unsigned int devfn, int where,
+				  int size, u32 *val)
+{
+	u32 bus_num,func,regOff,dev_no,temp, localBus;		
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
+	u32 pciIf = sysdata->mv_controller_num;
+
+	*val = 0xffffffff;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if ((dev_no == 0) && ( bus_num == localBus))
+	{
+		DB(printk("PCI %d read from our own dev return 0xffffffff \n", pciIf));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn); 
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+
+	DB(printk("PCI %d read: bus = %x dev = %x func = %x regOff = %x ",pciIf, bus_num,dev_no,func,regOff));
+	
+	temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	switch (size) {
+		case 1:
+			temp = (temp >>  (8*(where & 0x3))) & 0xff;
+			break;
+
+		case 2:
+			temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+			break;
+
+		default:
+			break;
+	}
+		
+	*val = temp;
+
+	DB(printk(" got %x \n",temp));
+	
+    return 0;
+}
+
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+	u32 bus_num,func,regOff,dev_no,temp, mask , shift;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
+	u32 pciIf = sysdata->mv_controller_num;		
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0xFFFFFFFF;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+
+	DB(printk("PCI %d: writing data %x size %x to bus %x dev %x func %x offs %x \n",
+			  pciIf, val,size,bus_num,dev_no,func,regOff));
+	if (size != 4)
+	{
+		temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	}
+	else
+	{
+		temp = val;
+	}
+
+	switch (size) {
+		case 1:
+			shift = (8*(where & 0x3));
+			mask = 0xff;
+			break;
+		case 2:
+			shift = (8*(where & 0x2));
+			mask = 0xffff;
+			break;
+
+		default:
+			shift = 0;
+			mask = 0xffffffff;
+			break;
+	}
+
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPexConfigWrite(pciIf, bus_num, dev_no, func, regOff, temp);
+	return 0;
+}
+
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci_read_config,
+        .write  = mv_pci_write_config,
+};
+
+
+int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+	u32 membase, iobase, index = 0;	
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	/* Translate logical interface number to physical */
+	pexHWInf = boardPexInfo->pexMapping[nr];
+
+	if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+		return 0;
+
+	/* Check if this interface is used or not */
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+		return 0;
+
+	/* Allocate resources memory */	
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+	{
+		panic("PCI: unable to alloc resources");
+		return 0;
+	}
+                                                                                                                             
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	/* Save the H/W if number for this PEX bus */
+	sys->mv_controller_num = pexHWInf;
+	sys->map_irq = mv_get_irqmap_func[sys->mv_controller_num];
+	
+	membase = mv_pci_mem_base_get(sys->mv_controller_num);
+	if (mv_is_pci_io_mapped(sys->mv_controller_num))
+	{
+	
+		iobase = mv_pci_io_base_get(sys->mv_controller_num);
+		res[index].start = iobase - IO_SPACE_REMAP;
+		res[index].end   = iobase - IO_SPACE_REMAP + mv_pci_io_size_get(sys->mv_controller_num)-1;
+		res[index].name  = "PCIx IO Primary";
+		res[index].flags = IORESOURCE_IO;		
+		if (request_resource(&ioport_resource, &res[index]))
+		{	
+			printk ("IO Request resource failed - Pci If %x\n",nr);
+		}
+		else
+			index++;
+	}
+	res[index].start = membase;
+	res[index].end   = membase + mv_pci_mem_size_get(sys->mv_controller_num)-1;
+	res[index].name  = "PCIx Memory Primary";
+	res[index].flags = IORESOURCE_MEM;
+
+	if (request_resource(&iomem_resource, &res[index]))
+	{	
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+	}
+ 
+	sys->resource[0] = &res[0];
+	if (index > 0) 
+	{
+		sys->resource[1] = &res[1];
+		sys->resource[2] = NULL;
+	}
+	else
+		sys->resource[1] = NULL;
+	sys->io_offset   = 0x0;
+
+	return 1;
+}
+
+
+struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops = &mv_pci_ops;	
+	struct pci_bus *bus;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexNextHWInf, ifnum;
+
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+
+	/* Set the bus number in the following controller */
+	for (ifnum = (nr+1); ifnum < boardPexInfo->boardPexIfNum; ifnum++) {
+
+		pexNextHWInf = boardPexInfo->pexMapping[ifnum];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexNextHWInf))
+			continue;
+
+		if (MV_TRUE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexNextHWInf)) {
+			mvPexLocalBusNumSet(pexNextHWInf, (bus->subordinate + 1));
+			break;
+		}
+	}
+
+	return bus;
+}
+
+
+static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin)
+{	
+	return IRQ_AURORA_PCIE0;
+}
+
+static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE1;
+}
+
+static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE2;
+}
+
+static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE3;
+}
+
+static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE4;
+}
+
+static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE5;
+}
+
+static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE6;
+}
+
+static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE7;
+}
+
+static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE8;
+}
+
+static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE9;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .setup                  = mv_pex_setup,
+        .scan                   = mv_pex_scan_bus,
+        .preinit                = mv_pex_preinit,
+};
+
+
+static int __init mv_pci_init(void)
+{
+    /* WA - Disable PEX on RD-SERVER board */
+    if (mvBoardIdGet() == RD_78460_SERVER_ID)
+	return 0;
+
+    mv_pci.nr_controllers = (mvBoardPexInfoGet())->boardPexIfNum;
+    mv_pci.swizzle        = pci_std_swizzle;
+    mv_pci.map_irq         = mv_map_irq_0;
+    mv_pci.setup           = mv_pex_setup;
+    mv_pci.scan            = mv_pex_scan_bus;
+    mv_pci.preinit         = mv_pex_preinit;
+    pci_common_init(&mv_pci);
+    return 0;
+}
+
+
+subsys_initcall(mv_pci_init);
+
diff --git a/arch/arm/mach-armadaxp/platsmp.c b/arch/arm/mach-armadaxp/platsmp.c
new file mode 100644
index 0000000..c45f6e2
--- /dev/null
+++ b/arch/arm/mach-armadaxp/platsmp.c
@@ -0,0 +1,375 @@
+/*
+ *  linux/arch/arm/mach-armadaxp/platsmp.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/unified.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "include/mach/smp.h"
+
+extern void axp_secondary_startup(void);
+extern void second_cpu_init(void);
+extern void second_cpu_msi_init(void);
+extern MV_CPU_DEC_WIN *mv_sys_map(void);
+extern unsigned long mv_cpu_count;
+extern void armadaxp_fabric_restore_deepIdle(void);
+
+unsigned int master_cpu_id  = 0;
+unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
+
+/*
+ * We use IRQ1 as the IPI
+ */
+static inline void axp_smp_cross_call(const struct cpumask *mask, unsigned int irqnr)
+{
+	unsigned long map = *cpus_addr(*mask);
+	void __iomem *addr = (void __iomem *)(AXP_SW_TRIG_IRQ);
+
+	map = get_hw_cpu_mask(map);
+
+	writel((((map & 0xf) << 8) | irqnr), addr);
+
+	return;
+}
+
+
+static inline unsigned int get_sample_at_reset_core_count(void)
+{
+	/* Read the number of availabe CPUs in the SoC */
+	return ((MV_REG_READ(SOC_COHERENCY_FABRIC_CFG_REG) & 0xF) + 1);
+}
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+static unsigned int __init get_core_count(void)
+{
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+	return 2;
+#else
+	/* The number of CPUs in this SMP group is given by
+	 * CMD line. The default is NR_CPUS */
+	return mv_cpu_count;
+#endif
+}
+
+void __init set_core_count(unsigned int cpu_count)
+{
+	/* Update cpu count */
+	mv_cpu_count = cpu_count;
+
+	/* Update group mask as well */
+	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	trace_hardirqs_off();
+#ifndef CONFIG_ARMADA_XP_REV_Z1
+#ifdef	CONFIG_SHEEVA_DEEP_IDLE
+	armadaxp_fabric_restore_deepIdle();
+#endif
+#endif
+
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	second_cpu_init();
+#ifdef CONFIG_PCI_MSI
+	/* Support for MSI interrupts */
+	second_cpu_msi_init();
+#endif
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	flush_cache_all();
+	pen_release = get_hw_cpu_id(cpu);
+	flush_cache_all();
+
+	/* send ipi to wake cpu in case it in offline state */
+	axp_smp_cross_call(cpumask_of(cpu), 0);
+
+	timeout = jiffies + (10 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+static void __init wakeup_cpus(void)
+{
+	MV_U32 val = 0;
+	MV_U32 ncores = get_core_count();
+	MV_U32 cpu_id, cpu_mask;
+
+#ifndef CONFIG_MACH_ARMADA_XP_FPGA
+#ifndef CONFIG_ARMADA_XP_REV_Z1
+	/* Scale up CPU#1 clock to max */
+	MV_U32 divider = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+	divider = (divider & 0x3F);
+
+	for (cpu_id = master_cpu_id + 1; cpu_id < (master_cpu_id + ncores); cpu_id++) {
+		if (cpu_id == 1) {
+			val = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+			val &= ~(0x0000FF00); 	/* cpu1 clkdiv ratio; cpu0 based on SAR */
+			val |= divider << 8;
+			MV_REG_WRITE(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG, val);
+		} else if (cpu_id == 2) {
+			val = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+			val &= ~(0x00FF0000);   /* cpu1 clkdiv ratio; cpu0 based on SAR */
+			val |= divider << 16;
+			MV_REG_WRITE(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG, val);
+		} else if (cpu_id == 3) {
+			val = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+			val &= ~0xFF000000;	/* cpus 3 clkdiv ratios */
+			val |= divider << 24;
+			MV_REG_WRITE(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG, val);
+		}
+	}
+#else /*CONFIG_ARMADA_XP_REV_Z1*/
+       /* Scale up CPU#1 clock to max */
+	if (ncores > 1) {
+		val = MV_REG_READ(CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG);
+		val &= ~(0xFF000000);   /* cpu1 clkdiv ratio; cpu0 based on SAR */
+		val |= 0x1 << 24;
+		MV_REG_WRITE(CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG, val);
+	}
+
+	/* Scale up CPU#2 clock to max */
+	if (ncores > 2) {
+		val = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+		val &= ~0x00FF0000;     /* cpus 2 clkdiv ratios */
+		val |= 0x1 << 16;
+		MV_REG_WRITE(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG, val);
+	}
+
+	/* Scale up CPU#3 clock to max */
+	if (ncores > 3) {
+		val = MV_REG_READ(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG);
+		val &= ~0xFF000000;     /* cpus 3 clkdiv ratios */
+		val |= 0x1 << 24;
+		MV_REG_WRITE(CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG, val);
+	}
+#endif/*CONFIG_ARMADA_XP_REV_Z1*/
+
+	cpu_mask = ((0x1 << (ncores-1)) - 1) << master_cpu_id;
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaLock(MV_SEMA_CLOCK);
+#endif
+	/* Set clock devider reload smooth bit mask */
+	val = MV_REG_READ(CPU_DIV_CLK_CTRL0_REG);
+	val |= (cpu_mask) << 21;
+	MV_REG_WRITE(CPU_DIV_CLK_CTRL0_REG, val);
+
+	/* Request clock devider reload */
+	val = MV_REG_READ(CPU_DIV_CLK_CTRL0_REG);
+	val |= 1 << 24;
+	MV_REG_WRITE(CPU_DIV_CLK_CTRL0_REG, val);
+
+	/* Wait for clocks to settle down then release reload request */
+	udelay(100);
+	val &= ~(0xf << 21);
+	MV_REG_WRITE(CPU_DIV_CLK_CTRL0_REG, val);
+	udelay(100);
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaUnlock(MV_SEMA_CLOCK);
+#endif
+#endif /*CONFIG_MACH_ARMADA_XP_FPGA*/
+
+	/* Set resume control and address */
+	MV_REG_WRITE(AXP_CPU_RESUME_CTRL_REG, 0x0);
+
+	for (cpu_id = master_cpu_id + 1; cpu_id < (master_cpu_id + ncores); cpu_id++)
+		MV_REG_WRITE(AXP_CPU_RESUME_ADDR_REG(cpu_id), virt_to_phys(axp_secondary_startup));
+
+	/* nobody is to be released from the pen yet */
+	pen_release = -1;
+
+	/* Kick secondary CPUs */
+	for (cpu_id = master_cpu_id + 1; cpu_id < (master_cpu_id + ncores); cpu_id++) {
+		/* TODO YY - check that the core is activated in coherency fabric */
+		printk("SMP: CPU %d Waking up CPU %d\n", master_cpu_id, cpu_id);
+		val = MV_REG_READ(AXP_CPU_RESET_REG(cpu_id)) & ~(1 << AXP_CPU_RESET_OFFS);
+		MV_REG_WRITE(AXP_CPU_RESET_REG(cpu_id), val);
+	}
+
+	mb();
+	udelay(10);
+}
+
+static void __init initialize_bridge(void)
+{
+	MV_U32 reg;
+	MV_U32 ncores = get_core_count();
+	MV_U32 core_bits;
+
+	/* Set 1 bits for cores in this group */
+	core_bits = ((0x1 << ncores) - 1) << master_cpu_id;
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaLock(MV_SEMA_BRIDGE);
+#endif
+	/* Associate group cores to the same SMP group */
+	reg = MV_REG_READ(SOC_COHERENCY_FABRIC_CFG_REG);
+	reg |= (core_bits << 24);
+	MV_REG_WRITE(SOC_COHERENCY_FABRIC_CFG_REG, reg);
+
+	/* enable Snooping on coherency fabric */
+	reg = MV_REG_READ(SOC_COHERENCY_FABRIC_CTRL_REG);
+	reg |= (core_bits << 24);
+	MV_REG_WRITE(SOC_COHERENCY_FABRIC_CTRL_REG, reg);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvSemaUnlock(MV_SEMA_BRIDGE);
+#endif
+}
+
+/*
+ * Initialize the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	MV_U32 i;
+	MV_U32 ncores = get_core_count();
+
+	printk("SMP: init cpus\n");
+
+	/* Set the HW CPU id of the master core */
+	master_cpu_id  = hard_smp_processor_id();
+
+	/* Set CPU address decoding */
+	if (mvCpuIfInit(mv_sys_map())) {
+		printk("Cpu Interface initialization failed.\n");
+		return;
+	}
+	/*mvCpuIfAddDecShow();*/
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+	set_smp_cross_call(axp_smp_cross_call);
+
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = get_core_count();
+	int i;
+
+	printk("SMP: prepare CPUs (%d cores)\n", ncores);
+	/* sanity check */
+	if (ncores == 0) {
+		printk(KERN_ERR
+		       "strange CM count of 0? Default to 1\n");
+
+		ncores = 1;
+	}
+
+	if (ncores > NR_CPUS) {
+		printk(KERN_WARNING
+		       "no. of cores (%d) greater than configured "
+		       "maximum of %d - clipping\n",
+		       ncores, NR_CPUS);
+		ncores = NR_CPUS;
+	}
+
+	if ((ncores + master_cpu_id) > NR_CPUS) {
+		printk(KERN_WARNING
+		       "Bad core count (%d) for SMP group starting at cpu no (%d). There is no CPU %d. Clipping\n",
+				ncores, master_cpu_id, ncores + master_cpu_id);
+		ncores = (NR_CPUS - master_cpu_id);
+	}
+
+	if (ncores > get_sample_at_reset_core_count())
+		ncores = get_sample_at_reset_core_count();
+
+	/* Adjust core count in case fixing was done */
+	set_core_count(ncores);
+
+	/*
+	 * are we trying to boot more cores than exist?
+	 */
+	if (max_cpus > ncores)
+		max_cpus = ncores;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		set_cpu_possible(i, false);
+		set_cpu_present(i, false);
+	}
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++) {
+		set_cpu_possible(i, true);
+		set_cpu_present(i, true);
+	}
+	if (max_cpus > 1) {
+		flush_cache_all();
+		wakeup_cpus();
+	}
+	initialize_bridge();
+}
diff --git a/arch/arm/mach-armadaxp/pm.c b/arch/arm/mach-armadaxp/pm.c
new file mode 100644
index 0000000..7c16339
--- /dev/null
+++ b/arch/arm/mach-armadaxp/pm.c
@@ -0,0 +1,159 @@
+/*
+ * pm.c
+ *
+ * Power Management functions for Marvell ArmadaXP System On Chip
+ *
+ * Maintainer: Nadav Haklai <nadavh@marvell.com>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/sysfs.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/suspend.h>
+#include <linux/interrupt.h>
+
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+#ifdef CONFIG_SHEEVA_DEEP_IDLE
+extern void armadaxp_deepidle(int power_state);
+extern void armadaxp_suspend(void);
+extern void axp_db_restore(void);
+
+typedef enum  {
+	DISABLED,
+	WFI,
+	DEEP_IDLE,
+	SNOOZE,
+} MV_PM_STATES;
+
+/*
+ * Logical check for Armada XP valid PM states
+ */
+static int armadaxp_pm_valid(suspend_state_t state)
+{
+	return ((state == PM_SUSPEND_STANDBY) ||
+		(state == PM_SUSPEND_MEM));
+}
+
+/*
+ * Enter the requested PM state
+ */
+static int armadaxp_pm_enter(suspend_state_t state)
+{
+
+	MV_U32 reg;
+
+	switch (state)	{
+	case PM_SUSPEND_STANDBY:
+
+		/* Reenable the Uart IRQ in order to wake from it */
+		/* Enable Uart IRQ */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0), reg);
+
+		/* Disable IPI IRQs */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW), reg);
+
+#ifdef CONFIG_MV_ETH_PNC_WOL
+
+		printk(KERN_INFO "Entering Wol Mode (Neta IRQs 8,10,12,14 are enabled now)...\n");
+
+		/* Reenable the NETA IRQ in order to wake from it */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC), reg);
+#endif /* CONFIG_MV_ETH_PNC_WOL */
+
+		armadaxp_deepidle(SNOOZE);
+
+		/* Enable IPI IRQs - return to original state */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW), reg);
+
+		/* Disable it since it will be re-enabled by the stack */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0), reg);
+#ifdef CONFIG_MV_ETH_PNC_WOL
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC), reg);
+
+		printk(KERN_INFO "Exiting Wol Mode (Neta IRQs 8,10,12,14 are disabled now)...\n");
+#endif /* CONFIG_MV_ETH_PNC_WOL */
+		break;
+
+	case PM_SUSPEND_MEM:
+
+		pr_info("Suspending Armada XP\n");
+		armadaxp_suspend();
+
+		pr_info("Restoring Armada XP\n");
+		axp_db_restore();
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct platform_suspend_ops armadaxp_pm_ops = {
+	.valid		= armadaxp_pm_valid,
+	.enter		= armadaxp_pm_enter,
+};
+
+static int __init armadaxp_pm_init(void)
+{
+	printk(KERN_INFO "ArmadaXP Power Managament Suspend Operations Initialized\n");
+	suspend_set_ops(&armadaxp_pm_ops);
+	return 0;
+}
+
+__initcall(armadaxp_pm_init);
+
+#else
+
+static int __init armadaxp_pm_init(void)
+{
+	printk(KERN_INFO "ArmadaXP Power Managament NOT Initialized (Missing Deep-Idle Support)\n");
+	return 0;
+}
+
+__initcall(armadaxp_pm_init);
+
+#endif /* CONFIG_SHEEVA_DEEP_IDLE */
diff --git a/arch/arm/mach-armadaxp/proc_aurora_dbg.c b/arch/arm/mach-armadaxp/proc_aurora_dbg.c
new file mode 100644
index 0000000..ed59c0a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/proc_aurora_dbg.c
@@ -0,0 +1,88 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h> 
+ 
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+static struct proc_dir_entry *aurora_dbg;
+
+unsigned int aurora_core_index(void)
+{
+        unsigned int value;
+
+        __asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPU ID reg\n"
+                : "=r" (value) :: "memory");
+        return (value & 0xF);
+}
+
+/********************************************************************/
+int aurora_dbg_read (char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr) {
+
+	char *p = buffer;
+  	unsigned int val, len;
+
+#ifdef CONFIG_SMP
+	p += sprintf(p,"CPU %d:\n", aurora_core_index());
+#endif
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 1" : "=r" (val));
+	p += sprintf(p, "c1, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 2" : "=r" (val));
+	p += sprintf(p, "c1, 2 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 0" : "=r" (val));
+	p += sprintf(p, "c2, 0 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 1" : "=r" (val));
+	p += sprintf(p, "c2, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 0" : "=r" (val));
+	p += sprintf(p, "c1, 0 %x \n", val);
+
+#ifdef CONFIG_PERF_EVENTS
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 0" : "=r" (val));
+	p += sprintf(p, "pmon ctrl %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 1" : "=r" (val));
+	p += sprintf(p, "pmon cntrs en %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 3" : "=r" (val));
+	p += sprintf(p, "pmon cntrs oflow %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 5" : "=r" (val));
+	p += sprintf(p, "pmon cntr sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 0" : "=r" (val));
+	p += sprintf(p, "pmon cycle cnt %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 1" : "=r" (val));
+	p += sprintf(p, "pmon evt sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 2" : "=r" (val));
+	p += sprintf(p, "pmon cntr val %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c14, 1" : "=r" (val));
+	p += sprintf(p, "pmon int en %x \n", val);
+#endif
+
+	len = (p - buffer);
+  	return len;
+}
+
+/********************************************************************/
+int __init start_aurora_dbg(void)
+{
+        aurora_dbg = create_proc_entry ("aurora_dbg" , 0666 , NULL);
+  	aurora_dbg->read_proc = aurora_dbg_read;
+  	aurora_dbg->write_proc = NULL;
+  	aurora_dbg->nlink = 1;
+	return 0;
+}
+void __exit stop_aurora_dbg(void)
+{
+        remove_proc_entry("aurora_dbg",  NULL);
+        return;
+}
+module_init(start_aurora_dbg);
+module_exit(stop_aurora_dbg);
+
diff --git a/arch/arm/mach-armadaxp/sysmap.c b/arch/arm/mach-armadaxp/sysmap.c
new file mode 100644
index 0000000..eecef4e
--- /dev/null
+++ b/arch/arm/mach-armadaxp/sysmap.c
@@ -0,0 +1,236 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <asm/mach/map.h>
+
+/* for putstr */
+/* #include <asm/arch/uncompress.h> */
+
+MV_CPU_DEC_WIN* mv_sys_map(void);
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan);
+u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+
+struct map_desc  MEM_TABLE[] =	{
+	/* no use for pex mem remap */	
+	{ INTER_REGS_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
+	{ PEX0_IO_VIRT_BASE,   		__phys_to_pfn(PEX0_IO_PHYS_BASE),	PEX0_IO_SIZE,  		MT_DEVICE},
+	{ PEX1_IO_VIRT_BASE,   		__phys_to_pfn(PEX1_IO_PHYS_BASE),	PEX1_IO_SIZE,  		MT_DEVICE},
+	{ PEX2_IO_VIRT_BASE,   		__phys_to_pfn(PEX2_IO_PHYS_BASE),	PEX2_IO_SIZE,  		MT_DEVICE},
+	{ PEX3_IO_VIRT_BASE,   		__phys_to_pfn(PEX3_IO_PHYS_BASE),	PEX3_IO_SIZE,  		MT_DEVICE},
+	{ PEX4_IO_VIRT_BASE,   		__phys_to_pfn(PEX4_IO_PHYS_BASE),	PEX4_IO_SIZE,  		MT_DEVICE},
+	{ PEX5_IO_VIRT_BASE,   		__phys_to_pfn(PEX5_IO_PHYS_BASE),	PEX5_IO_SIZE,  		MT_DEVICE},
+	{ PEX6_IO_VIRT_BASE,   		__phys_to_pfn(PEX6_IO_PHYS_BASE),	PEX6_IO_SIZE,  		MT_DEVICE},
+	{ PEX7_IO_VIRT_BASE,   		__phys_to_pfn(PEX7_IO_PHYS_BASE),	PEX7_IO_SIZE,  		MT_DEVICE},
+	{ PEX8_IO_VIRT_BASE,   		__phys_to_pfn(PEX8_IO_PHYS_BASE),	PEX8_IO_SIZE,  		MT_DEVICE},
+	{ PEX9_IO_VIRT_BASE,   		__phys_to_pfn(PEX9_IO_PHYS_BASE),	PEX9_IO_SIZE,  		MT_DEVICE},
+#ifdef MV_INCLUDE_LEGACY_NAND
+	{ LEGACY_NAND_VIRT_BASE,	__phys_to_pfn(LEGACY_NAND_PHYS_BASE),	LEGACY_NAND_SIZE, 	MT_DEVICE},
+#endif
+	{ SPI_CS0_VIRT_BASE,		__phys_to_pfn(SPI_CS0_PHYS_BASE),	SPI_CS0_SIZE,		MT_DEVICE},
+
+	{ CRYPT_ENG_VIRT_BASE(0),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(0)),	CRYPT_ENG_SIZE,		MT_DEVICE},
+#if (CONFIG_MV_CESA_CHANNELS > 1)
+	{ CRYPT_ENG_VIRT_BASE(1),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(1)),	CRYPT_ENG_SIZE,		MT_DEVICE},
+#endif
+#ifdef CONFIG_MV_ETH_BM
+	{ PNC_BM_VIRT_BASE,		__phys_to_pfn(PNC_BM_PHYS_BASE),	PNC_BM_SIZE,		MT_DEVICE}
+#endif
+};
+
+MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
+	/* base low       	     base high        size       		WinNum     	enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS3 */
+	{{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	0x8,		EN},	/* DEVICE_CS0 */
+	{{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS1 */
+	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS3 */
+	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0x0,		EN},	/* PEX0_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	0x1,		EN},	/* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX1_IO */
+	{{PEX2_MEM_PHYS_BASE,		0,	PEX2_MEM_SIZE		},	0x2,		EN},	/* PEX2_MEM */
+	{{PEX2_IO_PHYS_BASE,		0,	PEX2_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX2_IO */
+	{{PEX3_MEM_PHYS_BASE,		0,	PEX3_MEM_SIZE		},	0x3,		EN},	/* PEX3_MEM */
+	{{PEX3_IO_PHYS_BASE,		0,	PEX3_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX3_IO */
+	{{PEX4_MEM_PHYS_BASE,		0,	PEX4_MEM_SIZE		},	0x4,		EN},	/* PEX4_MEM */
+	{{PEX4_IO_PHYS_BASE,		0,	PEX4_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX4_IO */
+	{{PEX5_MEM_PHYS_BASE,		0,	PEX5_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_MEM */
+	{{PEX5_IO_PHYS_BASE,		0,	PEX5_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_IO */
+	{{PEX6_MEM_PHYS_BASE,		0,	PEX6_MEM_SIZE		},	0x5,		EN},	/* PEX6_MEM */
+	{{PEX6_IO_PHYS_BASE,		0,	PEX6_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX6_IO */
+	{{PEX7_MEM_PHYS_BASE,		0,	PEX7_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_MEM */
+	{{PEX7_IO_PHYS_BASE,		0,	PEX7_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_IO */
+	{{PEX8_MEM_PHYS_BASE,		0,	PEX8_MEM_SIZE		},	0x6,		EN},	/* PEX8_MEM */
+	{{PEX8_IO_PHYS_BASE,		0,	PEX8_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX8_IO */
+	{{PEX9_MEM_PHYS_BASE,		0,	PEX9_MEM_SIZE		},	0x7,		EN},	/* PEX9_MEM */
+	{{PEX9_IO_PHYS_BASE,		0,	PEX9_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX9_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS4 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		EN},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		EN},	/* DEV_BOOCS */
+	{{PMU_SCRATCH_PHYS_BASE,	0,	PMU_SCRATCH_SIZE	},	TBL_UNUSED,	DIS},	/* PMU SCRATCHPAD */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xb,		EN},	/* CRYPT0_ENG */
+	{{CRYPT_ENG_PHYS_BASE(1),	0,	CRYPT_ENG_SIZE		},	0xc,		EN},	/* CRYPT1_ENG */
+	{{PNC_BM_PHYS_BASE,		0,	PNC_BM_SIZE		},	0xd,		EN},	/* PNC_BM */
+	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
+};
+
+
+MV_CPU_DEC_WIN* mv_sys_map(void)
+{
+	return SYSMAP_ARMADA_XP;
+}
+
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan)
+{
+	return CRYPT_ENG_PHYS_BASE(chan);
+}
+u32 mv_crypto_virt_base_get(u8 chan)
+{
+	return CRYPT_ENG_VIRT_BASE(chan);
+}
+#endif
+
+void __init axp_map_io(void)
+{
+        iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+}
+
+static u32 mv_pci_mem_base[] = 
+{
+	PEX0_MEM_PHYS_BASE,
+	PEX1_MEM_PHYS_BASE,
+	PEX2_MEM_PHYS_BASE,
+	PEX3_MEM_PHYS_BASE,
+	PEX4_MEM_PHYS_BASE,
+	PEX5_MEM_PHYS_BASE,
+	PEX6_MEM_PHYS_BASE,
+	PEX7_MEM_PHYS_BASE,
+	PEX8_MEM_PHYS_BASE,
+	PEX9_MEM_PHYS_BASE,
+};
+
+static u32 mv_pci_mem_size[] = 
+{
+	PEX0_MEM_SIZE,
+	PEX1_MEM_SIZE,
+	PEX2_MEM_SIZE,
+	PEX3_MEM_SIZE,
+	PEX4_MEM_SIZE,
+	PEX5_MEM_SIZE,
+	PEX6_MEM_SIZE,
+	PEX7_MEM_SIZE,
+	PEX8_MEM_SIZE,
+	PEX9_MEM_SIZE,
+};
+
+static u32 mv_pci_io_base[] = 
+{
+	PEX0_IO_PHYS_BASE,
+	PEX1_IO_PHYS_BASE,
+	PEX2_IO_PHYS_BASE,
+	PEX3_IO_PHYS_BASE,
+	PEX4_IO_PHYS_BASE,
+	PEX5_IO_PHYS_BASE,
+	PEX6_IO_PHYS_BASE,
+	PEX7_IO_PHYS_BASE,
+	PEX8_IO_PHYS_BASE,
+	PEX9_IO_PHYS_BASE
+};
+
+static u32 mv_pci_io_size[] = 
+{
+	PEX0_IO_SIZE,
+	PEX1_IO_SIZE,
+	PEX2_IO_SIZE,
+	PEX3_IO_SIZE,
+	PEX4_IO_SIZE,
+	PEX5_IO_SIZE,
+	PEX6_IO_SIZE,
+	PEX7_IO_SIZE,
+	PEX8_IO_SIZE,
+	PEX9_IO_SIZE,
+};
+
+static MV_TARGET mv_pci_io_target[] = 
+{
+	PEX0_IO,
+	PEX1_IO,
+	PEX2_IO,
+	PEX3_IO,
+	PEX4_IO,
+	PEX5_IO,
+	PEX6_IO,
+	PEX7_IO,
+	PEX8_IO,
+	PEX9_IO,
+};
+
+u32 mv_pci_mem_base_get(int ifNum)
+{
+	return mv_pci_mem_base[ifNum];
+}
+
+u32 mv_pci_mem_size_get(int ifNum)
+{
+	return mv_pci_mem_size[ifNum];
+}
+
+u32 mv_pci_io_base_get(int ifNum)
+{
+	return mv_pci_io_base[ifNum];
+}
+
+u32 mv_pci_io_size_get(int ifNum)
+{
+	return mv_pci_io_size[ifNum];
+}
+
+MV_TARGET mv_pci_io_target_get(int ifNum)
+{
+	return mv_pci_io_target[ifNum];
+}
+
+int mv_is_pci_io_mapped(int ifNum)
+{
+	/* FIXME: First 8 address decode windows are statically assigned
+	   for 8 PCIE mem BARs.
+	   This is disabled as long that no more windows are available for
+	   I/O BARs
+	*/
+	    
+	return 0;
+}
diff --git a/arch/arm/mach-armadaxp/time.c b/arch/arm/mach-armadaxp/time.c
new file mode 100644
index 0000000..6da584a
--- /dev/null
+++ b/arch/arm/mach-armadaxp/time.c
@@ -0,0 +1,499 @@
+/*
+ * arch/arm/mach-armadaxp/time.c
+ *
+ * Marvell Aurora SoC timer handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * Timer 0 is used as free-running clocksource, while timer 1 is
+ * used as clock_event_device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+
+#ifdef CONFIG_SMP
+static struct clock_event_device __percpu ** axp_local_clockevent;
+#endif
+
+extern void axp_irq_mask(struct irq_data *d);
+extern void axp_irq_unmask(struct irq_data *d);
+extern unsigned int master_cpu_id;
+
+static int __cpuinit axp_local_timer_init(void);
+
+#define  TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER_WD_RELOAD	(MV_CNTMR_REGS_OFFSET + 0x0020)
+#define  TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
+#define  TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0028)
+
+#define  TIMER_EN(x)		(0x0001 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(0x0002 << (2 * x))
+#define  TIMER_RELOAD(x)	(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define  TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
+#define  INT_TIMER_CLR(x)	(~(1 << (8*x)))
+
+
+#define  LCL_TIMER_BASE		(0x21000 | 0x40)
+#define  LCL_TIMER_CTRL		(LCL_TIMER_BASE + 0x0000)
+#define    LCL_TIMER0_EN		0x0001
+#define    LCL_TIMER0_RELOAD_EN		0x0002
+#define    LCL_TIMER1_EN		0x0004
+#define    LCL_TIMER1_RELOAD_EN		0x0008
+#define  LCL_TIMER0_RELOAD	(LCL_TIMER_BASE + 0x0010)
+#define  LCL_TIMER0_VAL		(LCL_TIMER_BASE + 0x0014)
+#define  LCL_TIMER1_RELOAD	(LCL_TIMER_BASE + 0x0018)
+#define  LCL_TIMER1_VAL		(LCL_TIMER_BASE + 0x001c)
+#define  LCL_TIMER_WD_RELOAD	(LCL_TIMER_BASE + 0x0020)
+#define  LCL_TIMER_WD_VAL	(LCL_TIMER_BASE + 0x0024)
+#define  LCL_TIMER_CAUSE	(LCL_TIMER_BASE + 0x0028)
+#define   LCL_INT_TIMER0_CLR 	~(1 << 0)
+#define   LCL_INT_TIMER1_CLR	~(1 << 8)
+#define LCL_TIMER_TURN_25MHZ	(1 << 11)
+
+#define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
+#define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
+#define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
+#define BRIDGE_INT_TIMER(x)	(1 << (24 + x))
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
+static unsigned int soc_timer_id;
+
+
+static u32 notrace axp_read_sched_clock(void)
+{
+	return ~MV_REG_READ(TIMER_VAL(soc_timer_id));
+}
+
+
+/*
+ * Clocksource handling.
+ */
+static cycle_t axp_clksrc_read(struct clocksource *cs)
+{
+	return (0xffffffff - MV_REG_READ(TIMER_VAL(soc_timer_id)));
+}
+
+static struct clocksource axp_clksrc = {
+	.name		= "axp_clocksource",
+	.shift		= 20,
+	.rating		= 300,
+	.read		= axp_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+
+/*
+ * Clockevent handling.
+ */
+int axp_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+
+	if (delta == 0)
+		return -ETIME;	
+
+	local_irq_save(flags);
+
+	/* Clear and enable clockevent timer interrupt */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	/*axp_irq_unmask(IRQ_LOCALTIMER);*/
+	axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	/* Setup new clockevent timer value */
+	MV_REG_WRITE(LCL_TIMER0_VAL, delta);
+
+
+	/* Enable the timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u = (u & ~LCL_TIMER0_RELOAD_EN) | LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static void axp_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+{
+	unsigned long flags;
+	u32 u;
+	local_irq_save(flags);
+
+	if (mode == CLOCK_EVT_MODE_PERIODIC) {
+		/* Setup timer to fire at 1/HZ intervals */
+		MV_REG_WRITE(LCL_TIMER0_RELOAD, (ticks_per_jiffy - 1));
+		MV_REG_WRITE(LCL_TIMER0_VAL, (ticks_per_jiffy - 1));
+
+
+		/* Enable timer interrupt */
+		/*axp_irq_unmask(IRQ_LOCALTIMER);*/
+		axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+
+		/* Enable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) && !defined (CONFIG_MACH_ARMADA_XP_FPGA)
+		u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN | LCL_TIMER_TURN_25MHZ);
+#else
+		u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN);
+#endif
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	} else {
+		/* Disable timer */
+		u = MV_REG_READ(LCL_TIMER_CTRL);
+		u &= ~LCL_TIMER0_EN;
+		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+
+		/* Disable timer interrupt */
+		//axp_irq_mask(IRQ_LOCALTIMER);
+		axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+
+		/* ACK pending timer interrupt */
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	}
+
+
+	local_irq_restore(flags);
+}
+
+static struct clock_event_device axp_clkevt;
+static irqreturn_t axp_timer_interrupt(int irq, void *dev_id)
+{
+	/* ACK timer interrupt and call event handler */
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	axp_clkevt.event_handler(&axp_clkevt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction axp_timer_irq = {
+	.name		= "axp_tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= axp_timer_interrupt,
+	.dev_id         = &axp_clkevt,
+};
+
+static struct clock_event_device axp_clockevent = {
+	.name		= "local_timer",
+};
+
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+void __cpuinit mv_timer_setup(struct clock_event_device *clk, unsigned int fabric_clk)
+{
+	unsigned int cpu = smp_processor_id();
+
+	clk->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	clk->shift		= 32,
+	clk->rating		= 300,
+	clk->set_next_event	= axp_clkevt_next_event,
+	clk->set_mode		= axp_clkevt_mode,
+	clk->cpumask		= cpumask_of(cpu);
+	clk->mult		= div_sc(fabric_clk, NSEC_PER_SEC, clk->shift);
+	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
+	clk->min_delta_ns	= clockevent_delta2ns(0x1, clk);
+}
+
+/*
+ * Resume timer from suspend to RAM
+ * TODO - need to implement kernel hooks for suspend/resume
+ */
+void axp_timer_resume(void)
+{
+	u32 u;
+
+	pr_info("Resuming ArmadaXP SOC Timer %d\n", soc_timer_id);
+
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) |
+			TIMER_TURN_25MHZ(soc_timer_id));
+	MV_REG_WRITE(TIMER_CTRL, u);
+}
+#ifdef CONFIG_LOCAL_TIMERS
+static int __cpuinit axp_local_timer_setup(struct clock_event_device *evt)
+{
+	unsigned int fabric_clk = 25000000;
+	struct clock_event_device **this_cpu_clk;
+
+	/* Use existing clock_event for cpu 0 */
+
+	if (!smp_processor_id())
+		return 0;
+
+	evt->name = "local_timer";
+	evt->irq = IRQ_LOCALTIMER;
+	mv_timer_setup(evt, fabric_clk);
+	enable_percpu_irq(evt->irq, 0);
+	this_cpu_clk = __this_cpu_ptr(axp_local_clockevent);
+	*this_cpu_clk = evt;
+
+	clockevents_config_and_register(evt, fabric_clk, 1, 0xffffffff);
+	enable_percpu_irq(evt->irq, 0);
+	return 0;
+}
+
+static void axp_local_timer_stop(struct clock_event_device *evt)
+{
+	evt->set_mode(CLOCK_EVT_MODE_UNUSED, evt);
+	disable_percpu_irq(evt->irq);
+}
+
+static struct local_timer_ops axp_local_timer_ops __cpuinitdata = {
+	.setup	= axp_local_timer_setup,
+	.stop	= axp_local_timer_stop,
+};
+#endif /* CONFIG_LOCAL_TIMERS */
+
+
+void __init axp_time_init(unsigned int fabric_clk)
+{
+	u32 u;
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	soc_timer_id = (master_cpu_id == 0 ? 0 : 3);
+#else
+	soc_timer_id = 0;
+#endif
+
+	printk("Initializing ArmadaXP SOC Timer %d\n", soc_timer_id);
+
+	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+	
+	setup_sched_clock(axp_read_sched_clock, 32, fabric_clk);
+
+	/* Setup free-running clocksource timer (interrupts disabled) */
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+	u = MV_REG_READ(TIMER_CTRL);
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) && !defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
+#else
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id));
+#endif
+	MV_REG_WRITE(TIMER_CTRL, u);
+	axp_clksrc.mult = clocksource_hz2mult(fabric_clk, axp_clksrc.shift);
+	clocksource_register(&axp_clksrc);
+
+#ifdef CONFIG_SMP
+	{
+		axp_local_timer_init();
+	        return;
+	}
+#endif
+	/* Setup clockevent timer (interrupt-driven) */
+	axp_clkevt.name = "axp_tick";
+	axp_clkevt.irq = IRQ_LOCALTIMER;
+	mv_timer_setup(&axp_clkevt, fabric_clk);
+	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
+	clockevents_register_device(&axp_clkevt);
+}
+
+static void axp_timer_init(void)
+{
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) || defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
+	axp_time_init(25000000);
+#else
+	axp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
+#endif
+}
+
+struct sys_timer axp_timer = {
+	.init = axp_timer_init,
+};
+
+
+#if defined (CONFIG_SMP) && defined (CONFIG_LOCAL_TIMERS)
+/*
+ * Used on SMP for either the local timer or IPI_TIMER
+ */
+/*void local_timer_interrupt(void)
+{
+	struct clock_event_device *clk = &__get_cpu_var(axp_local_clockevent);
+
+	clk->event_handler(clk);
+}
+*/
+
+/*
+ * local_timer_ack: checks for a local timer interrupt.
+ *
+ * If a local timer interrupt has occurred, acknowledge and return 1.
+ * Otherwise, return 0.
+ */
+
+int local_timer_ack(void)
+{
+	if(MV_REG_READ(LCL_TIMER_CAUSE) & ~LCL_INT_TIMER0_CLR) {
+		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+		return 1;
+	}
+	return 0;
+}
+
+static irqreturn_t axp_localtimer_handler(int irq, void *dev_id)
+{
+
+	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
+	if (local_timer_ack()) {
+		evt->event_handler(evt);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+ __cpuinit local_timer_setup(struct clock_event_device *clk)
+{
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) || defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	/* FPGA hardcoded to 25Mhz and in DSMP-A0 the referance clock for the timers is 25MHz */
+	unsigned int fabric_clk = 25000000;
+#else
+	unsigned int fabric_clk = mvCpuL2ClkGet(); /* DSMP-Z1 clock is taken from Fabric */
+#endif
+	static cpu0_flag=0;
+	int cpu = smp_processor_id();
+	struct clock_event_device **this_cpu_clk;
+
+
+	if (!axp_local_clockevent) {
+		int err;
+
+		axp_local_clockevent = alloc_percpu(struct clock_event_device *);
+		if (!axp_local_clockevent) {
+			pr_err("axp_local_clockevent: can't allocate memory\n");
+			return 0;
+		}
+		err = request_percpu_irq(IRQ_LOCALTIMER, axp_localtimer_handler,
+				"axp_local_clockevent", axp_local_clockevent);
+		if (err) {
+			pr_err("axp_local_clockevent: can't register interrupt %d (%d)\n",
+				IRQ_LOCALTIMER, err);
+			return 0;
+		}
+	}
+
+	if((cpu) || (!cpu && !cpu0_flag)){
+		ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+		clk->name = "local_timer";
+		clk->irq = IRQ_LOCALTIMER;
+		mv_timer_setup(clk, fabric_clk);
+		this_cpu_clk = __this_cpu_ptr(axp_local_clockevent);
+		*this_cpu_clk = clk;
+		clockevents_register_device(clk);
+	 if(!cpu)
+		cpu0_flag++;
+	}
+	enable_percpu_irq(clk->irq, 0);
+	return 0;
+}
+
+static int __cpuinit axp_local_timer_init(void)
+{
+#if !defined (CONFIG_ARMADA_XP_REV_Z1) || defined (CONFIG_MACH_ARMADA_XP_FPGA)
+	/* FPGA hardcoded to 25Mhz and in DSMP-A0 the referance clock for the timers is 25MHz */
+	unsigned int fabric_clk = 25000000;
+#else
+	unsigned int fabric_clk = mvCpuL2ClkGet(); /* DSMP-Z1 clock is taken from Fabric */
+#endif
+	struct clock_event_device **this_cpu_clk;
+
+#ifdef CONFIG_SMP
+	if (!axp_local_clockevent) {
+		int err;
+
+		axp_local_clockevent = alloc_percpu(struct clock_event_device *);
+		if (!axp_local_clockevent) {
+			pr_err("axp_local_clockevent: can't allocate memory\n");
+			return 0;
+		}
+		err = request_percpu_irq(IRQ_LOCALTIMER, axp_localtimer_handler,
+				"axp_local_clockevent", axp_local_clockevent);
+		if (err) {
+			pr_err("axp_local_clockevent: can't register interrupt %d (%d)\n",
+				IRQ_LOCALTIMER, err);
+			return 0;
+		}
+	}
+
+		mv_timer_setup(&axp_clockevent, fabric_clk);
+		axp_clockevent.irq = IRQ_LOCALTIMER;
+	clockevents_config_and_register(&axp_clockevent, fabric_clk, 1, 0xffffffff);
+
+	this_cpu_clk = __this_cpu_ptr(axp_local_clockevent);
+	*this_cpu_clk = &axp_clockevent;
+
+	enable_percpu_irq(IRQ_LOCALTIMER, 0);
+	local_timer_register(&axp_local_timer_ops);
+#else
+	printk(KERN_ERR "No Handling for Non-SMP Mode yet.\n");
+	BUG();
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+/*
+ * take a local timer down
+ */
+void  __cpuexit local_timer_stop(struct clock_event_device * evt)
+{
+	unsigned long flags;
+	u32 u;
+	local_irq_save(flags);
+
+	/* Disable timer */
+	u = MV_REG_READ(LCL_TIMER_CTRL);
+	u &= ~LCL_TIMER0_EN;
+	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+	/* Disable timer interrupt */
+	/*axp_irq_mask(IRQ_LOCALTIMER);*/
+	axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
+
+	local_irq_restore(flags);
+}
+#endif
+#endif	/* CONFIG_LOCAL_TIMERS && CONFIG_SMP */
diff --git a/arch/arm/mach-armadaxp/usb.c b/arch/arm/mach-armadaxp/usb.c
new file mode 100644
index 0000000..80d8763
--- /dev/null
+++ b/arch/arm/mach-armadaxp/usb.c
@@ -0,0 +1,168 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+//#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+                                                                                                                             
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "mvSysUsbApi.h"
+#include "usb/mvUsbRegs.h"
+#include "usb/mvUsb.h"
+
+u32 mvIsUsbHost = 0x03;
+
+#define MV_USB_DMA_MASK		0xffffffff
+#define MAX_USB_PORTS		3
+
+static char usb_dev_name[]  = "mv_udc";
+static char usb_host_name[] = "ehci_marvell";
+static char usb_bus_name[]  = "platform";
+
+
+static void mv_usb_release(struct device *dev)
+{
+    struct platform_device  *pdev = to_platform_device(dev); 
+
+    /* normally not freed */
+    printk("mv_usb_release\n");
+
+    kfree(pdev->resource);
+    kfree(pdev->dev.dma_mask);
+    kfree(pdev);
+} 
+
+
+static int __init   mv_usb_init(void)
+{
+	int                     status, dev, num, isHost;
+	char*                   name_ptr;
+	struct platform_device* mv_usb_dev_ptr;
+	int 			irq_num[3] = {	IRQ_AURORA_USB0,
+						IRQ_AURORA_USB1,
+						IRQ_AURORA_USB2};
+
+	num = mvCtrlUsbMaxGet(); 
+	if (num > MAX_USB_PORTS) {
+		printk("WARNING: Limited USB ports number to %d\n", MAX_USB_PORTS);
+		num = MAX_USB_PORTS;
+	}
+
+	for(dev=0; dev<num; dev++)
+	{
+		if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev))
+		{
+			printk("\nWarning Integrated USB %d is Powered Off\n",dev);
+			continue;
+		}
+
+		/* Check if this USB is mapped to this AMP group - YY */
+		if(MV_FALSE == mvUnitMapIsMine(USB0 + dev))
+		{
+			continue;
+		}
+
+		isHost = mvIsUsbHost & (1 << dev);
+
+		if(isHost)
+			name_ptr = usb_host_name;
+		else
+			name_ptr = usb_dev_name;
+
+		printk("registered dev#%d asa %s\n",dev,name_ptr);
+		status = mvSysUsbInit(dev, isHost);
+
+		mv_usb_dev_ptr = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if(mv_usb_dev_ptr == NULL)
+		{
+			printk("Can't allocate platform_device structure - %d bytes\n",
+					sizeof(struct platform_device) );
+			return 1;
+		}
+		memset(mv_usb_dev_ptr, 0, sizeof(struct platform_device) );
+
+		mv_usb_dev_ptr->name               = name_ptr;
+		mv_usb_dev_ptr->id                 = dev;
+
+		mv_usb_dev_ptr->num_resources  = 2;
+
+		mv_usb_dev_ptr->resource = (struct resource*)kmalloc(2*sizeof(struct resource), GFP_KERNEL);
+		if(mv_usb_dev_ptr->resource == NULL)
+		{
+			printk("Can't allocate 2 resource structure - %d bytes\n",
+					2*sizeof(struct resource) );
+			kfree(mv_usb_dev_ptr);
+			return 1;
+		}
+		memset(mv_usb_dev_ptr->resource, 0, 2*sizeof(struct resource));
+
+		mv_usb_dev_ptr->resource[0].start =
+			( INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
+		mv_usb_dev_ptr->resource[0].end   =
+			((INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
+		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
+
+		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
+		mv_usb_dev_ptr->resource[1].flags = IORESOURCE_IRQ;
+
+		mv_usb_dev_ptr->dev.dma_mask           = kmalloc(sizeof(u64), GFP_KERNEL);
+		*mv_usb_dev_ptr->dev.dma_mask          = MV_USB_DMA_MASK;
+
+		mv_usb_dev_ptr->dev.coherent_dma_mask  = ~0;
+		mv_usb_dev_ptr->dev.release            = mv_usb_release;
+		dev_set_name(&mv_usb_dev_ptr->dev, "%s", usb_bus_name);
+
+		printk("Marvell USB %s controller #%d: %p\n",
+				isHost ? "EHCI Host" : "Gadget", dev, mv_usb_dev_ptr);
+
+		status = platform_device_register(mv_usb_dev_ptr);
+		if (status)
+		{
+			printk("Can't register Marvell USB EHCI controller #%d, status=%d\n", 
+					dev, status);
+			return status;
+		}
+	}
+	return 0;
+}
+
+subsys_initcall(mv_usb_init);
+
diff --git a/include/video/dovefb.h b/include/video/dovefb.h
new file mode 100644
index 0000000..665eba5
--- /dev/null
+++ b/include/video/dovefb.h
@@ -0,0 +1,507 @@
+/*
+ * linux/include/video/dovefb.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _DOVEFB_H_
+#define _DOVEFB_H_
+
+/* ---------------------------------------------- */
+/*              Header Files                      */
+/* ---------------------------------------------- */
+#include <linux/fb.h>
+
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define DOVEFB_IOC_MAGIC			'm'
+#define DOVEFB_IOCTL_CONFIG_CURSOR		_IO(DOVEFB_IOC_MAGIC, 0)
+#define DOVEFB_IOCTL_DUMP_REGS			_IO(DOVEFB_IOC_MAGIC, 1)
+#define DOVEFB_IOCTL_CLEAR_IRQ			_IO(DOVEFB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define DOVEFB_IOCTL_SET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 3)
+#define DOVEFB_IOCTL_GET_VIDEO_MODE		_IO(DOVEFB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define DOVEFB_IOCTL_CREATE_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define DOVEFB_IOCTL_SET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 6)
+#define DOVEFB_IOCTL_GET_VIEWPORT_INFO		_IO(DOVEFB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    DOVEFB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define DOVEFB_IOCTL_FLIP_VID_BUFFER		_IO(DOVEFB_IOC_MAGIC, 8)
+
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use DOVEFB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define DOVEFB_IOCTL_GET_BUFF_ADDR		_IO(DOVEFB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define DOVEFB_IOCTL_SET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 10)
+#define DOVEFB_IOCTL_GET_VID_OFFSET		_IO(DOVEFB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_MEMORY_TOGGLE		_IO(DOVEFB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define DOVEFB_IOCTL_SET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 13)
+#define DOVEFB_IOCTL_GET_COLORKEYnALPHA		_IO(DOVEFB_IOC_MAGIC, 14)
+#define DOVEFB_IOCTL_SWITCH_GRA_OVLY		_IO(DOVEFB_IOC_MAGIC, 15)
+#define DOVEFB_IOCTL_SWITCH_VID_OVLY		_IO(DOVEFB_IOC_MAGIC, 16)
+
+/* For Vmeta integration */
+#define DOVEFB_IOCTL_GET_FREELIST		_IO(DOVEFB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define DOVEFB_IOCTL_WAIT_VSYNC			_IO(DOVEFB_IOC_MAGIC, 18)
+
+/* for xv+vmeta/sw decoder w/o memory move. */
+#define DOVEFB_IOCTL_GET_FBPA			_IO(DOVEFB_IOC_MAGIC, 19)
+#define DOVEFB_IOCTL_GET_FBID			_IO(DOVEFB_IOC_MAGIC, 20)
+#define DOVEFB_IOCTL_SET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 21)
+#define DOVEFB_IOCTL_GET_SRC_MODE		_IO(DOVEFB_IOC_MAGIC, 22)
+
+/* Dynamic get EDID data */
+#define DOVEFB_IOCTL_GET_EDID_INFO		_IO(DOVEFB_IOC_MAGIC, 23)
+#define DOVEFB_IOCTL_GET_EDID_DATA		_IO(DOVEFB_IOC_MAGIC, 24)
+#define DOVEFB_IOCTL_SET_EDID_INTERVAL		_IO(DOVEFB_IOC_MAGIC, 25)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FBIO_CLEAR_FRAMEBUFFER			_IO(FB_IOC_MAGIC, 19)
+
+/* Global alpha blend controls - Maintaining compatibility with existing
+   user programs. */
+#define FBIOPUT_VIDEO_ALPHABLEND            0xeb
+#define FBIOPUT_GLOBAL_ALPHABLEND           0xe1
+#define FBIOPUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FBIOPUT_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FBIOPUT_SWAP_GRAPHIC_U_V            0xe4
+#define FBIOPUT_SWAP_GRAPHIC_Y_UV           0xe5
+#define FBIOPUT_SWAP_VIDEO_RED_BLUE         0xe6
+#define FBIOPUT_SWAP_VIDEO_U_V              0xe7
+#define FBIOPUT_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FBIOGET_CHROMAKEYS                  0xe9
+#define FBIOPUT_CHROMAKEYS                  0xea
+
+#define DOVEFB_VMODE_RGB565			0x100
+#define DOVEFB_VMODE_BGR565			0x101
+#define DOVEFB_VMODE_RGB1555			0x102
+#define DOVEFB_VMODE_BGR1555			0x103
+#define DOVEFB_VMODE_RGB888PACK			0x104
+#define DOVEFB_VMODE_BGR888PACK			0x105
+#define DOVEFB_VMODE_RGB888UNPACK		0x106
+#define DOVEFB_VMODE_BGR888UNPACK		0x107
+#define DOVEFB_VMODE_RGBA888			0x108
+#define DOVEFB_VMODE_BGRA888			0x109
+
+#define	DOVEFB_VMODE_YUV422PACKED		0x0
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPUV	0x1
+#define	DOVEFB_VMODE_YUV422PACKED_SWAPYUorV	0x2
+#define	DOVEFB_VMODE_YUV422PLANAR		0x3
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPUV	0x4
+#define	DOVEFB_VMODE_YUV422PLANAR_SWAPYUorV	0x5
+#define	DOVEFB_VMODE_YUV420PLANAR		0x6
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPUV	0x7
+#define	DOVEFB_VMODE_YUV420PLANAR_SWAPYUorV	0x8
+
+#define	DOVEFB_HWCMODE_1BITMODE			0x0
+#define	DOVEFB_HWCMODE_2BITMODE			0x1
+
+#define	DOVEFB_DISABLE_COLORKEY_MODE		0x0
+#define	DOVEFB_ENABLE_Y_COLORKEY_MODE		0x1
+#define	DOVEFB_ENABLE_U_COLORKEY_MODE		0x2
+#define	DOVEFB_ENABLE_V_COLORKEY_MODE		0x4
+#define	DOVEFB_ENABLE_RGB_COLORKEY_MODE		0x3
+#define	DOVEFB_ENABLE_R_COLORKEY_MODE		0x5
+#define	DOVEFB_ENABLE_G_COLORKEY_MODE		0x6
+#define	DOVEFB_ENABLE_B_COLORKEY_MODE		0x7
+
+#define DOVEFB_VID_PATH_ALPHA               0x0
+#define DOVEFB_GRA_PATH_ALPHA               0x1
+#define DOVEFB_CONFIG_ALPHA                 0x2
+
+#define DOVEFB_SYNC_COLORKEY_TO_CHROMA          1
+#define DOVEFB_SYNC_CHROMA_TO_COLORKEY          2
+
+/* Compatible to pxa168. */
+#define FB_IOCTL_SET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA            _IO(FB_IOC_MAGIC, 14)
+#define FB_VID_PATH_ALPHA               0x0
+#define FB_GRA_PATH_ALPHA               0x1
+#define FB_CONFIG_ALPHA                 0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define DOVEFB_FB_NUM		2
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+struct _sEdidInfo {
+	int connect;			/* is monitor connected */
+	int change;			/* is edid data changed */
+	int extension;			/* the number of extension edid block */
+	int interval;			/* the interval to check edid */
+};
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define DOVEFBVideoMode signed int
+
+struct _sViewPortInfo {
+	unsigned short srcWidth;	/* video source size */
+	unsigned short srcHeight;
+	unsigned short zoomXSize;	/* size after zooming */
+	unsigned short zoomYSize;
+	unsigned short ycPitch;
+	unsigned short uvPitch;
+};
+
+struct _sViewPortOffset {
+	unsigned short xOffset;		/* position on screen */
+	unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+	unsigned char	frameID;	/* which frame wants */
+	unsigned char *startAddr;	/* new buffer (PA) */
+	unsigned char *inputData;	/* input buf address (VA) */
+	unsigned int length;		/* input data's length */
+};
+
+struct dovefb_chroma {
+        u_char     mode;
+        u_char     y_alpha;
+        u_char     y;
+        u_char     y1;
+        u_char     y2;
+        u_char     u_alpha;
+        u_char     u;
+        u_char     u1;
+        u_char     u2;
+        u_char     v_alpha;
+        u_char     v;
+        u_char     v1;
+        u_char     v2;
+};
+
+struct _sColorKeyNAlpha {
+        unsigned int mode;
+        unsigned int alphapath;
+        unsigned int config;
+        unsigned int Y_ColorAlpha;
+        unsigned int U_ColorAlpha;
+        unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+	DOVEFBVideoMode videoMode;
+	struct _sViewPortInfo viewPortInfo;
+	struct _sViewPortOffset viewPortOffset;
+	struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct _sCursorConfig {
+	unsigned char	enable;		/* enable cursor or not */
+	unsigned char	mode;		/* 1bit or 2bit mode */
+	unsigned int color1;		/* foreground color */
+	unsigned int color2;		/* background color */
+	unsigned short xoffset;
+	unsigned short yoffset;
+	unsigned short	width;
+	unsigned short height;
+	unsigned char *pBuffer;		/* cursor data */
+};
+
+#define SHM_NORMAL		0x01
+#define SHM_VMETA		0x02
+#define SHM_SOFTWARE_MAP	0x04
+
+struct shm_private_info {
+	unsigned int method;
+	unsigned int fbid;
+	unsigned int format;
+	unsigned int width;
+	unsigned int height;
+	unsigned long fb_pa;
+};
+
+/* MAX bytes per yuv pixel. */
+#define MAX_YUV_PIXEL	2
+
+/* Dumb interface */
+#define DOVEFB_PINS_DUMB_24		0
+#define DOVEFB_PINS_DUMB_18_SPI		1
+#define DOVEFB_PINS_DUMB_18_GPIO	2
+#define DOVEFB_PINS_DUMB_16_SPI		3
+#define DOVEFB_PINS_DUMB_16_GPIO	4
+#define DOVEFB_PINS_DUMB_12_SPI_GPIO	5
+#define DOVEFB_PINS_SMART_18_SPI	6
+#define DOVEFB_PINS_SMART_16_SPI	7
+#define DOVEFB_PINS_SMART_8_SPI_GPIO	8
+
+/* Dumb interface pin allocation */
+#define DOVEFB_DUMB_PANEL_RGB565	0
+#define DOVEFB_DUMB_PANEL_RGB565_UPPER	1
+#define DOVEFB_DUMB_PANEL_RGB666	2
+#define DOVEFB_DUMB_PANEL_RGB666_UPPER	3
+#define DOVEFB_DUMB_PANEL_RGB444	4
+#define DOVEFB_DUMB_PANEL_RGB444_UPPER	5
+#define DOVEFB_DUMB_PANEL_RGB888	6
+
+/* Max fb buffer. 1048x2048-32bits */
+#define DEFAULT_FB_SIZE	(1024 * 2048 * 4)
+
+/*
+ * Buffer pixel format
+ * bit0 is for rb swap.
+ * bit12 is for Y UorV swap
+ */
+#define PIX_FMT_RGB565		0
+#define PIX_FMT_BGR565		1
+#define PIX_FMT_RGB1555		2
+#define PIX_FMT_BGR1555		3
+#define PIX_FMT_RGB888PACK	4
+#define PIX_FMT_BGR888PACK	5
+#define PIX_FMT_RGB888UNPACK	6
+#define PIX_FMT_BGR888UNPACK	7
+#define PIX_FMT_RGBA888		8
+#define PIX_FMT_BGRA888		9
+#define PIX_FMT_YUV422PACK	10
+#define PIX_FMT_YVU422PACK	11
+#define PIX_FMT_YUV422PLANAR	12
+#define PIX_FMT_YVU422PLANAR	13
+#define PIX_FMT_YUV420PLANAR	14
+#define PIX_FMT_YVU420PLANAR	15
+#define PIX_FMT_PSEUDOCOLOR	20
+#define PIX_FMT_UYVY422PACK	(0x1000|PIX_FMT_YUV422PACK)
+
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+
+enum dovefb_type {
+	DOVEFB_GFX_PLANE,
+	DOVEFB_OVLY_PLANE
+};
+
+#define MRVL_AXI_CLK		0
+#define MRVL_EXT_CLK0	1
+#define MRVL_PLL_CLK		2
+#define MRVL_EXT_CLK1	3
+
+struct dovefb_layer_info {
+	struct device		*dev;
+	enum dovefb_type	type;
+	struct dovefb_info	*info;
+	struct fb_info		*fb_info;
+
+	void			*reg_base;
+
+	unsigned long		new_addr;
+	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	atomic_t		w_intr;
+	wait_queue_head_t	w_intr_wq;
+	struct mutex		access_ok;
+	struct _sOvlySurface	surface;
+	struct _sColorKeyNAlpha ckey_alpha;
+
+	unsigned char		*hwc_buf;
+	unsigned int		pseudo_palette[16];
+	struct tasklet_struct	tasklet;
+	char			*mode_option;
+
+	int			ddc_polling_disable;
+	struct timer_list	get_edid_timer;
+	unsigned char*		raw_edid;
+	struct _sEdidInfo	edid_info;
+	struct work_struct      work_queue;
+
+	int			pix_fmt;
+	unsigned		is_blanked:1;
+	unsigned		cursor_enabled:1;
+	unsigned		cursor_cfg:1;
+	unsigned		active:1;
+	unsigned		enabled:1;
+	unsigned                checkbuf_timer_exist:1;
+
+	/*
+	 * 0: DMA mem is from DMA region.
+	 * 1: DMA mem is from normal region.
+	 */
+	unsigned		mem_status:1;
+
+	/*
+	 * current frame id for mapping to user.
+	 */
+	int			cur_fbid;
+	int			src_mode;
+
+	unsigned int		reserved;
+};
+
+/*
+ * Dove LCD controller private state.
+ */
+struct dovefb_info {
+	struct device			*dev;
+	int				id;
+
+	void				*reg_base;
+	struct dovefb_layer_info	*gfx_plane;
+	struct dovefb_layer_info	*vid_plane;
+
+	struct fb_videomode		dft_vmode;
+	struct fb_videomode		out_vmode;
+	int				fixed_output;
+
+	char				*mode_option;
+	struct clk			*clk;
+	int				clk_src;
+	int				io_pin_allocation;
+
+	int			pix_fmt;
+	unsigned		edid:1;
+	unsigned		panel_rbswap:1;
+	unsigned		edid_en:1;
+	unsigned		fixed_full_div:1;
+	unsigned		full_div_val;
+
+        /* Hardware cursor related registers */
+	unsigned int LCD_SPU_HWC_HPXL_VLN_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR1_saved_value;
+	unsigned int LCD_SPU_ALPHA_COLOR2_saved_value;
+
+	/* Colorkey related registers */
+	unsigned int LCD_SPU_COLORKEY_Y_saved_value;
+	unsigned int LCD_SPU_COLORKEY_U_saved_value;
+	unsigned int LCD_SPU_COLORKEY_V_saved_value;
+	unsigned int LCD_SPU_DMA_CTRL1_saved_value;
+	unsigned int LCD_SPU_ADV_REG_saved_value;
+};
+
+/*
+ * Dove fb machine information
+ */
+struct dovefb_mach_info {
+	char		id_gfx[16];
+	char		id_ovly[16];
+//KW	unsigned int	sclk_clock;
+
+	int		num_modes;
+	struct fb_videomode *modes;
+	struct mbus_dram_target_info *dram;
+ 
+	/* LCD reference clock value.	*/
+	unsigned int	lcd_ref_clk;
+
+	/* KW
+	** FrameBuffer memory.
+	*/
+	void		*fb_mem[2];
+	unsigned int	fb_mem_size[2];
+
+	/*
+	 * Pix_fmt
+	 */
+	unsigned	pix_fmt;
+
+	/*
+	 * I/O pin allocation.
+	 */
+	unsigned	io_pin_allocation:4;
+	/* 
+	 * auto poll EDID data periodically
+	 */
+	unsigned ddc_polling_disable:1;
+	
+	/*
+	 * I2C bus and address to read DDC data through. -1 not available
+	 */
+	int		ddc_i2c_adapter;
+	int		ddc_i2c_address;
+
+
+	/*
+	 * Dumb panel -- assignment of R/G/B component info to the 24
+	 * available external data lanes.
+	 */
+	unsigned	panel_rgb_type:4;
+	unsigned	panel_rgb_reverse_lanes:1;
+
+	/*
+	 * Dumb panel -- GPIO output data.
+	 */
+	unsigned	gpio_output_mask:8;
+	unsigned	gpio_output_data:8;
+
+	/*
+	 * Dumb panel -- configurable output signal polarity.
+	 */
+	unsigned	invert_composite_blank:1;
+	unsigned	invert_pix_val_ena:1;
+	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
+	unsigned	panel_rbswap:1;
+	unsigned	active:1;
+	unsigned	enable_lcd0:1;
+	unsigned	fixed_full_div:1;
+	unsigned	full_div_val;
+
+	struct {
+		unsigned enabled;
+		unsigned lvds_24b_option;
+		unsigned lvds_tick_drv;
+	} lvds_info;
+};
+
+struct dovebl_platform_data;
+
+int clcd_platform_init(struct dovefb_mach_info *lcd0_dmi_data,
+		       struct dovefb_mach_info *lcd0_vid_dmi_data,
+		       struct dovebl_platform_data *backlight_data);
+
+#endif /* _KERNEL_ */
+#endif /* _DOVEFB_H_ */
diff --git a/include/video/dovefbreg.h b/include/video/dovefbreg.h
new file mode 100644
index 0000000..5f10ec1
--- /dev/null
+++ b/include/video/dovefbreg.h
@@ -0,0 +1,695 @@
+/*
+ * linux/include/video/dovefbreg.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _DOVEFB_REG_H_
+#define	_DOVEFB_REG_H_
+
+/* ------------< LCD register >------------ */
+/* Video Frame 0&1 start address registers */
+#define	LCD_SPU_ADV_REG				0x0084
+
+/* Video Frame 0&1 start address registers */
+#define	LCD_SPU_DMA_START_ADDR_Y0		0x00C0
+#define	LCD_SPU_DMA_START_ADDR_U0		0x00C4
+#define	LCD_SPU_DMA_START_ADDR_V0		0x00C8
+#define LCD_CFG_DMA_START_ADDR_0		0x00CC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y1		0x00D0
+#define	LCD_SPU_DMA_START_ADDR_U1		0x00D4
+#define	LCD_SPU_DMA_START_ADDR_V1		0x00D8
+#define LCD_CFG_DMA_START_ADDR_1		0x00DC /* Cmd address */
+
+/* YC & UV Pitch */
+#define LCD_SPU_DMA_PITCH_YC			0x00E0
+#define     SPU_DMA_PITCH_C(c)			(c<<16)
+#define     SPU_DMA_PITCH_Y(y)			(y)
+#define LCD_SPU_DMA_PITCH_UV			0x00E4
+#define     SPU_DMA_PITCH_V(v)			(v<<16)
+#define     SPU_DMA_PITCH_U(u)			(u)
+
+/* Video Starting Point on Screen Register */
+#define LCD_SPUT_DMA_OVSA_HPXL_VLN		0x00E8
+#define     CFG_DMA_OVSA_VLN(y)			(y<<16) /* 0~0xfff */
+#define     CFG_DMA_OVSA_HPXL(x)		(x)     /* 0~0xfff */
+
+/* Video Size Register */
+#define LCD_SPU_DMA_HPXL_VLN			0x00EC
+#define     CFG_DMA_VLN(y)			(y<<16)
+#define     CFG_DMA_HPXL(x)			(x)
+
+/* Video Size After zooming Register */
+#define LCD_SPU_DZM_HPXL_VLN			0x00F0
+#define     CFG_DZM_VLN(y)			(y<<16)
+#define     CFG_DZM_HPXL(x)			(x)
+
+/* Graphic Frame 0&1 Starting Address Register */
+#define LCD_CFG_GRA_START_ADDR0			0x00F4
+#define LCD_CFG_GRA_START_ADDR1			0x00F8
+
+/* Graphic Frame Pitch */
+#define LCD_CFG_GRA_PITCH			0x00FC
+
+/* Graphic Starting Point on Screen Register */
+#define LCD_SPU_GRA_OVSA_HPXL_VLN		0x0100
+#define     CFG_GRA_OVSA_VLN(y)			(y<<16)
+#define     CFG_GRA_OVSA_HPXL(x)		(x)
+
+/* Graphic Size Register */
+#define LCD_SPU_GRA_HPXL_VLN			0x0104
+#define     CFG_GRA_VLN(y)			(y<<16)
+#define     CFG_GRA_HPXL(x)			(x)
+
+/* Graphic Size after Zooming Register */
+#define LCD_SPU_GZM_HPXL_VLN			0x0108
+#define     CFG_GZM_VLN(y)			(y<<16)
+#define     CFG_GZM_HPXL(x)			(x)
+
+/* HW Cursor Starting Point on Screen Register */
+#define LCD_SPU_HWC_OVSA_HPXL_VLN		0x010C
+#define     CFG_HWC_OVSA_VLN(y)			(y<<16)
+#define     CFG_HWC_OVSA_HPXL(x)		(x)
+
+/* HW Cursor Size */
+#define LCD_SPU_HWC_HPXL_VLN			0x0110
+#define     CFG_HWC_VLN(y)			(y<<16)
+#define     CFG_HWC_HPXL(x)			(x)
+
+/* Total Screen Size Register */
+#define LCD_SPUT_V_H_TOTAL			0x0114
+#define     CFG_V_TOTAL(y)			((y)<<16)
+#define     CFG_H_TOTAL(x)			(x)
+
+/* Total Screen Active Size Register */
+#define LCD_SPU_V_H_ACTIVE			0x0118
+#define     CFG_V_ACTIVE(y)			((y)<<16)
+#define     CFG_H_ACTIVE(x)			(x)
+
+/* Screen H&V Porch Register */
+#define LCD_SPU_H_PORCH				0x011C
+#define     CFG_H_BACK_PORCH(b)			(b<<16)
+#define     CFG_H_FRONT_PORCH(f)		(f)
+#define LCD_SPU_V_PORCH				0x0120
+#define     CFG_V_BACK_PORCH(b)			(b<<16)
+#define     CFG_V_FRONT_PORCH(f)		(f)
+
+/* Screen Blank Color Register */
+#define LCD_SPU_BLANKCOLOR			0x0124
+#define     CFG_BLANKCOLOR_MASK			0x00FFFFFF
+#define     CFG_BLANKCOLOR_R_MASK		0x000000FF
+#define     CFG_BLANKCOLOR_G_MASK		0x0000FF00
+#define     CFG_BLANKCOLOR_B_MASK		0x00FF0000
+
+/* HW Cursor Color 1&2 Register */
+#define LCD_SPU_ALPHA_COLOR1			0x0128
+#define     CFG_HWC_COLOR1			0x00FFFFFF
+#define     CFG_HWC_COLOR1_R(red)		(red<<16)
+#define     CFG_HWC_COLOR1_G(green)		(green<<8)
+#define     CFG_HWC_COLOR1_B(blue)		(blue)
+#define     CFG_HWC_COLOR1_R_MASK		0x000000FF
+#define     CFG_HWC_COLOR1_G_MASK		0x0000FF00
+#define     CFG_HWC_COLOR1_B_MASK		0x00FF0000
+#define LCD_SPU_ALPHA_COLOR2			0x012C
+#define     CFG_HWC_COLOR2			0x00FFFFFF
+#define     CFG_HWC_COLOR2_R_MASK		0x000000FF
+#define     CFG_HWC_COLOR2_G_MASK		0x0000FF00
+#define     CFG_HWC_COLOR2_B_MASK		0x00FF0000
+
+/* Video YUV Color Key Control */
+#define LCD_SPU_COLORKEY_Y			0x0130
+#define     CFG_CKEY_Y2(y2)			((y2)<<24)
+#define     CFG_CKEY_Y2_MASK			0xFF000000
+#define     CFG_CKEY_Y1(y1)			((y1)<<16)
+#define     CFG_CKEY_Y1_MASK			0x00FF0000
+#define     CFG_CKEY_Y(y)			((y)<<8)
+#define     CFG_CKEY_Y_MASK			0x0000FF00
+#define     CFG_ALPHA_Y(y)			(y)
+#define     CFG_ALPHA_Y_MASK			0x000000FF
+#define LCD_SPU_COLORKEY_U			0x0134
+#define     CFG_CKEY_U2(u2)			((u2)<<24)
+#define     CFG_CKEY_U2_MASK			0xFF000000
+#define     CFG_CKEY_U1(u1)			((u1)<<16)
+#define     CFG_CKEY_U1_MASK			0x00FF0000
+#define     CFG_CKEY_U(u)			((u)<<8)
+#define     CFG_CKEY_U_MASK			0x0000FF00
+#define     CFG_ALPHA_U(u)			(u)
+#define     CFG_ALPHA_U_MASK			0x000000FF
+#define LCD_SPU_COLORKEY_V			0x0138
+#define     CFG_CKEY_V2(v2)			((v2)<<24)
+#define     CFG_CKEY_V2_MASK			0xFF000000
+#define     CFG_CKEY_V1(v1)			((v1)<<16)
+#define     CFG_CKEY_V1_MASK			0x00FF0000
+#define     CFG_CKEY_V(v)			((v)<<8)
+#define     CFG_CKEY_V_MASK			0x0000FF00
+#define     CFG_ALPHA_V(v)			(v)
+#define     CFG_ALPHA_V_MASK			0x000000FF
+
+/* LCD General Configuration Register */
+#define LCD_CFG_RDREG4F				0x013C
+
+/* SPI Read Data Register */
+#define LCD_SPU_SPI_RXDATA			0x0140
+
+/* Smart Panel Read Data Register */
+#define LCD_SPU_ISA_RSDATA			0x0144
+#define     ISA_RXDATA_16BIT_1_DATA_MASK	0x000000FF
+#define     ISA_RXDATA_16BIT_2_DATA_MASK	0x0000FF00
+#define     ISA_RXDATA_16BIT_3_DATA_MASK	0x00FF0000
+#define     ISA_RXDATA_16BIT_4_DATA_MASK	0xFF000000
+#define     ISA_RXDATA_32BIT_1_DATA_MASK	0x00FFFFFF
+
+/* HWC SRAM Read Data Register */
+#define LCD_SPU_HWC_RDDAT			0x0158
+
+/* Gamma Table SRAM Read Data Register */
+#define LCD_SPU_GAMMA_RDDAT			0x015c
+#define     CFG_GAMMA_RDDAT_MASK		0x000000FF
+
+/* Palette Table SRAM Read Data Register */
+#define LCD_SPU_PALETTE_RDDAT			0x0160
+#define     CFG_PALETTE_RDDAT_MASK		0x00FFFFFF
+
+/* I/O Pads Input Read Only Register */
+#define LCD_SPU_IOPAD_IN			0x0178
+#define     CFG_IOPAD_IN_MASK			0x0FFFFFFF
+
+/* Reserved Read Only Registers */
+#define LCD_CFG_RDREG5F				0x017C
+#define     IRE_FRAME_CNT_MASK			0x000000C0
+#define     IPE_FRAME_CNT_MASK			0x00000030
+#define     GRA_FRAME_CNT_MASK			0x0000000C  /* Graphic */
+#define     DMA_FRAME_CNT_MASK			0x00000003  /* Video */
+
+/* SPI Control Register. */
+#define LCD_SPU_SPI_CTRL			0x0180
+#define     CFG_SCLKCNT(div)			(div<<24)  /* 0xFF~0x2 */
+#define     CFG_SCLKCNT_MASK			0xFF000000
+#define     CFG_RXBITS(rx)			(rx<<16)   /* 0x1F~0x1 */
+#define     CFG_RXBITS_MASK			0x00FF0000
+#define     CFG_TXBITS(tx)			(tx<<8)    /* 0x1F~0x1 */
+#define     CFG_TXBITS_MASK			0x0000FF00
+#define     CFG_CLKINV(clk)			(clk<<7)
+#define     CFG_CLKINV_MASK			0x00000080
+#define     CFG_KEEPXFER(transfer)		(transfer<<6)
+#define     CFG_KEEPXFER_MASK			0x00000040
+#define     CFG_RXBITSTO0(rx)			(rx<<5)
+#define     CFG_RXBITSTO0_MASK			0x00000020
+#define     CFG_TXBITSTO0(tx)			(tx<<4)
+#define     CFG_TXBITSTO0_MASK			0x00000010
+#define     CFG_SPI_ENA(spi)			(spi<<3)
+#define     CFG_SPI_ENA_MASK			0x00000008
+#define     CFG_SPI_SEL(spi)			(spi<<2)
+#define     CFG_SPI_SEL_MASK			0x00000004
+#define     CFG_SPI_3W4WB(wire)			(wire<<1)
+#define     CFG_SPI_3W4WB_MASK			0x00000002
+#define     CFG_SPI_START(start)		(start)
+#define     CFG_SPI_START_MASK			0x00000001
+
+/* SPI Tx Data Register */
+#define LCD_SPU_SPI_TXDATA			0x0184
+
+/*
+   1. Smart Pannel 8-bit Bus Control Register.
+   2. AHB Slave Path Data Port Register
+*/
+#define LCD_SPU_SMPN_CTRL			0x0188
+
+/* DMA Control 0 Register */
+#define LCD_SPU_DMA_CTRL0			0x0190
+#define     CFG_NOBLENDING(nb)			(nb<<31)
+#define     CFG_NOBLENDING_MASK			0x80000000
+#define     CFG_GAMMA_ENA(gn)			(gn<<30)
+#define     CFG_GAMMA_ENA_MASK			0x40000000
+#define     CFG_CBSH_ENA(cn)			(cn<<29)
+#define     CFG_CBSH_ENA_MASK			0x20000000
+#define     CFG_PALETTE_ENA(pn)			(pn<<28)
+#define     CFG_PALETTE_ENA_MASK		0x10000000
+#define     CFG_ARBFAST_ENA(an)			(an<<27)
+#define     CFG_ARBFAST_ENA_MASK		0x08000000
+#define     CFG_HWC_1BITMOD(mode)		(mode<<26)
+#define     CFG_HWC_1BITMOD_MASK		0x04000000
+#define     CFG_HWC_1BITENA(mn)			(mn<<25)
+#define     CFG_HWC_1BITENA_MASK		0x02000000
+#define     CFG_HWC_ENA(cn)		        (cn<<24)
+#define     CFG_HWC_ENA_MASK			0x01000000
+#define     CFG_DMAFORMAT(dmaformat)		(dmaformat<<20)
+#define     CFG_DMAFORMAT_MASK			0x00F00000
+#define     CFG_GRAFORMAT(graformat)		(graformat<<16)
+#define     CFG_GRAFORMAT_MASK			0x000F0000
+/* for graphic part */
+#define     CFG_GRA_FTOGGLE(toggle)		(toggle<<15)
+#define     CFG_GRA_FTOGGLE_MASK		0x00008000
+#define     CFG_GRA_HSMOOTH(smooth)		(smooth<<14)
+#define     CFG_GRA_HSMOOTH_MASK		0x00004000
+#define     CFG_GRA_TSTMODE(test)		(test<<13)
+#define     CFG_GRA_TSTMODE_MASK		0x00002000
+#define     CFG_GRA_SWAPRB(swap)		(swap<<12)
+#define     CFG_GRA_SWAPRB_MASK			0x00001000
+#define     CFG_GRA_SWAPUV(swap)		(swap<<11)
+#define     CFG_GRA_SWAPUV_MASK			0x00000800
+#define     CFG_GRA_SWAPYU(swap)		(swap<<10)
+#define     CFG_GRA_SWAPYU_MASK			0x00000400
+#define     CFG_YUV2RGB_GRA(cvrt)		(cvrt<<9)
+#define     CFG_YUV2RGB_GRA_MASK		0x00000200
+#define     CFG_GRA_ENA(gra)			(gra<<8)
+#define     CFG_GRA_ENA_MASK			0x00000100
+/* for video part */
+#define     CFG_DMA_FTOGGLE(toggle)		(toggle<<7)
+#define     CFG_DMA_FTOGGLE_MASK		0x00000080
+#define     CFG_DMA_HSMOOTH(smooth)		(smooth<<6)
+#define     CFG_DMA_HSMOOTH_MASK		0x00000040
+#define     CFG_DMA_TSTMODE(test)		(test<<5)
+#define     CFG_DMA_TSTMODE_MASK		0x00000020
+#define     CFG_DMA_SWAPRB(swap)		(swap<<4)
+#define     CFG_DMA_SWAPRB_MASK			0x00000010
+#define     CFG_DMA_SWAPUV(swap)		(swap<<3)
+#define     CFG_DMA_SWAPUV_MASK			0x00000008
+#define     CFG_DMA_SWAPYU(swap)		(swap<<2)
+#define     CFG_DMA_SWAPYU_MASK			0x00000004
+#define     CFG_DMA_SWAP_MASK			0x0000001C
+#define     CFG_YUV2RGB_DMA(cvrt)		(cvrt<<1)
+#define     CFG_YUV2RGB_DMA_MASK		0x00000002
+#define     CFG_DMA_ENA(video)			(video)
+#define     CFG_DMA_ENA_MASK			0x00000001
+
+/* DMA Control 1 Register */
+#define LCD_SPU_DMA_CTRL1			0x0194
+#define     CFG_FRAME_TRIG(trig)		(trig<<31)
+#define     CFG_FRAME_TRIG_MASK			0x80000000
+#define     CFG_VSYNC_TRIG(trig)		(trig<<28)
+#define     CFG_VSYNC_TRIG_MASK			0x70000000
+#define     CFG_VSYNC_INV(inv)			(inv<<27)
+#define     CFG_VSYNC_INV_MASK			0x08000000
+#define     CFG_COLOR_KEY_MODE(cmode)		(cmode<<24)
+#define     CFG_COLOR_KEY_MASK			0x07000000
+#define     CFG_CARRY(carry)			(carry<<23)
+#define     CFG_CARRY_MASK			0x00800000
+#define     CFG_LNBUF_ENA(lnbuf)		(lnbuf<<22)
+#define     CFG_LNBUF_ENA_MASK			0x00400000
+#define     CFG_GATED_ENA(gated)		(gated<<21)
+#define     CFG_GATED_ENA_MASK			0x00200000
+#define     CFG_PWRDN_ENA(power)		(power<<20)
+#define     CFG_PWRDN_ENA_MASK			0x00100000
+#define     CFG_DSCALE(dscale)			(dscale<<18)
+#define     CFG_DSCALE_MASK			0x000C0000
+#define     CFG_ALPHA_MODE(amode)		(amode<<16)
+#define     CFG_ALPHA_MODE_MASK			0x00030000
+#define     CFG_ALPHA(alpha)			(alpha<<8)
+#define     CFG_ALPHA_MASK			0x0000FF00
+#define     CFG_PXLCMD(pxlcmd)			(pxlcmd)
+#define     CFG_PXLCMD_MASK			0x000000FF
+
+/* SRAM Control Register */
+#define LCD_SPU_SRAM_CTRL			0x0198
+#define     CFG_SRAM_INIT_WR_RD(mode)		(mode<<14)
+#define     CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
+#define     CFG_SRAM_ADDR_LCDID(id)		(id<<8)
+#define     CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
+#define     CFG_SRAM_ADDR(addr)			(addr)
+#define     CFG_SRAM_ADDR_MASK			0x000000FF
+
+/* SRAM Write Data Register */
+#define LCD_SPU_SRAM_WRDAT			0x019C
+
+/* SRAM RTC/WTC Control Register */
+#define LCD_SPU_SRAM_PARA0			0x01A0
+
+/* SRAM Power Down Control Register */
+#define LCD_SPU_SRAM_PARA1			0x01A4
+#define     CFG_CSB_256x32(hwc)			(hwc<<15)	/* HWC */
+#define     CFG_CSB_256x32_MASK			0x00008000
+#define     CFG_CSB_256x24(palette)		(palette<<14)	/* Palette */
+#define     CFG_CSB_256x24_MASK			0x00004000
+#define     CFG_CSB_256x8(gamma)		(gamma<<13)	/* Gamma */
+#define     CFG_CSB_256x8_MASK			0x00002000
+#define     CFG_PDWN256x32(pdwn)		(pdwn<<7)	/* HWC */
+#define     CFG_PDWN256x32_MASK			0x00000080
+#define     CFG_PDWN256x24(pdwn)		(pdwn<<6)	/* Palette */
+#define     CFG_PDWN256x24_MASK			0x00000040
+#define     CFG_PDWN256x8(pdwn)			(pdwn<<5)	/* Gamma */
+#define     CFG_PDWN256x8_MASK			0x00000020
+#define     CFG_PDWN32x32(pdwn)			(pdwn<<3)
+#define     CFG_PDWN32x32_MASK			0x00000008
+#define     CFG_PDWN16x66(pdwn)			(pdwn<<2)
+#define     CFG_PDWN16x66_MASK			0x00000004
+#define     CFG_PDWN32x66(pdwn)			(pdwn<<1)
+#define     CFG_PDWN32x66_MASK			0x00000002
+#define     CFG_PDWN64x66(pdwn)			(pdwn)
+#define     CFG_PDWN64x66_MASK			0x00000001
+
+/* Smart or Dumb Panel Clock Divider */
+#define LCD_CFG_SCLK_DIV			0x01A8
+#define     SCLK_SOURCE_SELECT(src)		(src<<31)
+#define     SCLK_SOURCE_SELECT_MASK		0x80000000
+#define     CLK_FRACDIV(frac)			(frac<<16)
+#define     CLK_FRACDIV_MASK			0x0FFF0000
+#define     CLK_INT_DIV(div)			(div)
+#define     CLK_INT_DIV_MASK			0x0000FFFF
+
+/* Video Contrast Register */
+#define LCD_SPU_CONTRAST			0x01AC
+#define     CFG_BRIGHTNESS(bright)		(bright<<16)
+#define     CFG_BRIGHTNESS_MASK			0xFFFF0000
+#define     CFG_CONTRAST(contrast)		(contrast)
+#define     CFG_CONTRAST_MASK			0x0000FFFF
+
+/* Video Saturation Register */
+#define LCD_SPU_SATURATION			0x01B0
+#define     CFG_C_MULTS(mult)			(mult<<16)
+#define     CFG_C_MULTS_MASK			0xFFFF0000
+#define     CFG_SATURATION(sat)			(sat)
+#define     CFG_SATURATION_MASK			0x0000FFFF
+
+/* Video Hue Adjust Register */
+#define LCD_SPU_CBSH_HUE			0x01B4
+#define     CFG_SIN0(sin0)			(sin0<<16)
+#define     CFG_SIN0_MASK			0xFFFF0000
+#define     CFG_COS0(con0)			(con0)
+#define     CFG_COS0_MASK			0x0000FFFF
+
+/* Dump LCD Panel Control Register */
+#define LCD_SPU_DUMB_CTRL			0x01B8
+#define     CFG_DUMBMODE(mode)			(mode<<28)
+#define     CFG_DUMBMODE_MASK			0xF0000000
+#define     CFG_LCDGPIO_O(data)			(data<<20)
+#define     CFG_LCDGPIO_O_MASK			0x0FF00000
+#define     CFG_LCDGPIO_ENA(gpio)		(gpio<<12)
+#define     CFG_LCDGPIO_ENA_MASK		0x000FF000
+#define     CFG_BIAS_OUT(bias)			(bias<<8)
+#define     CFG_BIAS_OUT_MASK			0x00000100
+#define     CFG_REVERSE_RGB(rRGB)		(rRGB<<7)
+#define     CFG_REVERSE_RGB_MASK		0x00000080
+#define     CFG_INV_COMPBLANK(blank)		(blank<<6)
+#define     CFG_INV_COMPBLANK_MASK		0x00000040
+#define     CFG_INV_COMPSYNC(sync)		(sync<<5)
+#define     CFG_INV_COMPSYNC_MASK		0x00000020
+#define     CFG_INV_HENA(hena)			(hena<<4)
+#define     CFG_INV_HENA_MASK			0x00000010
+#define     CFG_INV_VSYNC(vsync)		(vsync<<3)
+#define     CFG_INV_VSYNC_MASK			0x00000008
+#define     CFG_INV_HSYNC(hsync)		(hsync<<2)
+#define     CFG_INV_HSYNC_MASK			0x00000004
+#define     CFG_INV_PCLK(pclk)			(pclk<<1)
+#define     CFG_INV_PCLK_MASK			0x00000002
+#define     CFG_DUMB_ENA(dumb)			(dumb)
+#define     CFG_DUMB_ENA_MASK			0x00000001
+
+/* LCD I/O Pads Control Register */
+#define SPU_IOPAD_CONTROL			0x01BC
+#define     CFG_GRA_VM_ENA(vm)			(vm<<15)        /* gfx */
+#define     CFG_GRA_VM_ENA_MASK			0x00008000
+#define     CFG_DMA_VM_ENA(vm)			(vm<<13)	/* video */
+#define     CFG_DMA_VM_ENA_MASK			0x00002000
+#define     CFG_CMD_VM_ENA(vm)			(vm<<13)
+#define     CFG_CMD_VM_ENA_MASK			0x00000800
+#define     CFG_CSC(csc)			(csc<<8)	/* csc */
+#define     CFG_CSC_MASK			0x00000300
+#define     CFG_AXICTRL(axi)			(axi<<4)
+#define     CFG_AXICTRL_MASK			0x000000F0
+#define     CFG_IOPADMODE(iopad)		(iopad)
+#define     CFG_IOPADMODE_MASK			0x0000000F
+
+/* LCD Interrupt Control Register */
+#define SPU_IRQ_ENA				0x01C0
+#define     DMA_FRAME_IRQ0_ENA(irq)		(irq<<31)
+#define     DMA_FRAME_IRQ0_ENA_MASK		0x80000000
+#define     DMA_FRAME_IRQ1_ENA(irq)		(irq<<30)
+#define     DMA_FRAME_IRQ1_ENA_MASK		0x40000000
+#define     DMA_FF_UNDERFLOW_ENA(ff)		(ff<<29)
+#define     DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
+#define     GRA_FRAME_IRQ0_ENA(irq)		(irq<<27)
+#define     GRA_FRAME_IRQ0_ENA_MASK		0x08000000
+#define     GRA_FRAME_IRQ1_ENA(irq)		(irq<<26)
+#define     GRA_FRAME_IRQ1_ENA_MASK		0x04000000
+#define     GRA_FF_UNDERFLOW_ENA(ff)		(ff<<25)
+#define     GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
+#define     VSYNC_IRQ_ENA(vsync_irq)		(vsync_irq<<23)
+#define     VSYNC_IRQ_ENA_MASK			0x00800000
+#define     DUMB_FRAMEDONE_ENA(fdone)		(fdone<<22)
+#define     DUMB_FRAMEDONE_ENA_MASK		0x00400000
+#define     TWC_FRAMEDONE_ENA(fdone)		(fdone<<21)
+#define     TWC_FRAMEDONE_ENA_MASK		0x00200000
+#define     HWC_FRAMEDONE_ENA(fdone)		(fdone<<20)
+#define     HWC_FRAMEDONE_ENA_MASK		0x00100000
+#define     SLV_IRQ_ENA(irq)			(irq<<19)
+#define     SLV_IRQ_ENA_MASK			0x00080000
+#define     SPI_IRQ_ENA(irq)			(irq<<18)
+#define     SPI_IRQ_ENA_MASK			0x00040000
+#define     PWRDN_IRQ_ENA(irq)			(irq<<17)
+#define     PWRDN_IRQ_ENA_MASK			0x00020000
+#define     ERR_IRQ_ENA(irq)			(irq<<16)
+#define     ERR_IRQ_ENA_MASK			0x00010000
+#define     CLEAN_SPU_IRQ_ISR(irq)		(irq)
+#define     CLEAN_SPU_IRQ_ISR_MASK		0x0000FFFF
+
+/* LCD Interrupt Status Register */
+#define SPU_IRQ_ISR				0x01C4
+#define     DMA_FRAME_IRQ0(irq)			(irq<<31)
+#define     DMA_FRAME_IRQ0_MASK			0x80000000
+#define     DMA_FRAME_IRQ1(irq)			(irq<<30)
+#define     DMA_FRAME_IRQ1_MASK			0x40000000
+#define     DMA_FF_UNDERFLOW(ff)		(ff<<29)
+#define     DMA_FF_UNDERFLOW_MASK		0x20000000
+#define     GRA_FRAME_IRQ0(irq)			(irq<<27)
+#define     GRA_FRAME_IRQ0_MASK			0x08000000
+#define     GRA_FRAME_IRQ1(irq)			(irq<<26)
+#define     GRA_FRAME_IRQ1_MASK			0x04000000
+#define     GRA_FF_UNDERFLOW(ff)		(ff<<25)
+#define     GRA_FF_UNDERFLOW_MASK		0x02000000
+#define     VSYNC_IRQ(vsync_irq)		(vsync_irq<<23)
+#define     VSYNC_IRQ_MASK			0x00800000
+#define     DUMB_FRAMEDONE(fdone)		(fdone<<22)
+#define     DUMB_FRAMEDONE_MASK			0x00400000
+#define     TWC_FRAMEDONE(fdone)		(fdone<<21)
+#define     TWC_FRAMEDONE_MASK			0x00200000
+#define     HWC_FRAMEDONE(fdone)		(fdone<<20)
+#define     HWC_FRAMEDONE_MASK			0x00100000
+#define     SLV_IRQ(irq)			(irq<<19)
+#define     SLV_IRQ_MASK			0x00080000
+#if 0 //KW-LCD
+#define     SPI_IRQ(irq)			(irq<<18)
+#define     SPI_IRQ_MASK			0x00040000
+#endif
+
+#define     PWRDN_IRQ(irq)			(irq<<17)
+#define     PWRDN_IRQ_MASK			0x00020000
+#define     ERR_IRQ(irq)			(irq<<16)
+#define     ERR_IRQ_MASK			0x00010000
+/* read-only */
+#define     DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
+#define     DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
+#define     DMA_FRAME_CNT_ISR_MASK		0x00003000
+#define     GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
+#define     GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
+#define     GRA_FRAME_CNT_ISR_MASK		0x00000300
+#define     VSYNC_IRQ_LEVEL_MASK		0x00000080
+#define     DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
+#define     TWC_FRAMEDONE_LEVEL_MASK		0x00000020
+#define     HWC_FRAMEDONE_LEVEL_MASK		0x00000010
+#define     SLV_FF_EMPTY_MASK			0x00000008
+#define     DMA_FF_ALLEMPTY_MASK		0x00000004
+#define     GRA_FF_ALLEMPTY_MASK		0x00000002
+#define     PWRDN_IRQ_LEVEL_MASK		0x00000001
+
+/*
+ * interrupt definition.
+ */
+#define DOVEFB_VSYNC_INT_MASK	(VSYNC_IRQ_ENA_MASK)
+#define DOVEFB_VID_INT_MASK	(DMA_FRAME_IRQ0_ENA_MASK |\
+				DMA_FRAME_IRQ1_ENA_MASK)
+#define DOVEFB_GFX_INT_MASK	(GRA_FRAME_IRQ0_ENA_MASK |\
+				GRA_FRAME_IRQ1_ENA_MASK)
+
+/*
+ * defined Video Memory Color format for DMA control 0 register
+ * DMA0 bit[23:20]
+ */
+#define VMODE_RGB565                    0x0
+#define VMODE_RGB1555                   0x1
+#define VMODE_RGB888PACKED              0x2
+#define VMODE_RGB888UNPACKED            0x3
+#define VMODE_RGBA888                   0x4
+#define VMODE_YUV422PACKED              0x5
+#define VMODE_YUV422PLANAR              0x6
+#define VMODE_YUV420PLANAR              0x7
+#define VMODE_SMPNCMD                   0x8
+#define VMODE_PALETTE4BIT               0x9
+#define VMODE_PALETTE8BIT               0xa
+#define VMODE_RESERVED                  0xb
+
+/*
+ * defined Graphic Memory Color format for DMA control 0 register
+ * DMA0 bit[19:16]
+ */
+#define GMODE_RGB565                    0x0
+#define GMODE_RGB1555                   0x1
+#define GMODE_RGB888PACKED              0x2
+#define GMODE_RGB888UNPACKED            0x3
+#define GMODE_RGBA888                   0x4
+#define GMODE_YUV422PACKED              0x5
+#define GMODE_YUV422PLANAR              0x6
+#define GMODE_YUV420PLANAR              0x7
+#define GMODE_SMPNCMD                   0x8
+#define GMODE_PALETTE4BIT               0x9
+#define GMODE_PALETTE8BIT               0xa
+#define GMODE_RESERVED                  0xb
+
+/*
+ * define for DMA control 1 register
+ */
+#define DMA1_FRAME_TRIG             31      /* bit location */
+#define DMA1_VSYNC_MODE             28
+#define DMA1_VSYNC_INV              27
+#define DMA1_CKEY                   24
+#define DMA1_CARRY                  23
+#define DMA1_LNBUF_ENA              22
+#define DMA1_GATED_ENA              21
+#define DMA1_PWRDN_ENA              20
+#define DMA1_DSCALE                 18
+#define DMA1_ALPHA_MODE             16
+#define DMA1_ALPHA                  08
+#define DMA1_PXLCMD                 00
+
+/*
+ * defined for Configure Dumb Mode
+ * DUMB LCD Panel bit[31:28]
+ */
+#define DUMB16_RGB565_0             0x0
+#define DUMB16_RGB565_1             0x1
+#define DUMB18_RGB666_0             0x2
+#define DUMB18_RGB666_1             0x3
+#define DUMB12_RGB444_0             0x4
+#define DUMB12_RGB444_1             0x5
+#define DUMB24_RGB888_0             0x6
+#define DUMB_BLANK                  0x7
+
+/*
+ * defined for Configure I/O Pin Allocation Mode
+ * LCD LCD I/O Pads control register bit[3:0]
+ */
+#define IOPAD_DUMB24                0x0
+#define IOPAD_DUMB18SPI             0x1
+#define IOPAD_DUMB18GPIO            0x2
+#define IOPAD_DUMB16SPI             0x3
+#define IOPAD_DUMB16GPIO            0x4
+#define IOPAD_DUMB12                0x5
+#define IOPAD_SMART18SPI            0x6
+#define IOPAD_SMART16SPI            0x7
+#define IOPAD_SMART8BOTH            0x8
+
+/*
+ * defined Dumb Panel Clock Divider register
+ * SCLK_Source bit[31]
+ */
+#define AXI_BUS_SEL                 0x80000000 /* 0: PLL clock select*/
+#define CCD_CLK_SEL                 0x40000000
+#define DCON_CLK_SEL                0x20000000
+#define ENA_CLK_INT_DIV             CONFIG_FB_DOVE_CLCD_SCLK_DIV
+#define IDLE_CLK_INT_DIV            0x1      /* idle Integer Divider */
+#define DIS_CLK_INT_DIV             0x0      /* Disable Integer Divider */
+
+/* SRAM ID */
+#define SRAMID_gamma_yr             0x0
+#define SRAMID_gamma_ug             0x1
+#define SRAMID_gamma_vb             0x2
+#define SRAMID_palette              0x3
+#define SRAMID_hwc                  0xf
+
+/* SRAM INIT Read/Write */
+#define SRAMID_INIT_READ			0x0
+#define SRAMID_INIT_WRITE			0x2
+#define SRAMID_INIT_DEFAULT			0x3
+
+/*
+ * defined VSYNC selection mode for DMA control 1 register
+ * DMA1 bit[30:28]
+ */
+#define VMODE_SMPN                  0x0
+#define VMODE_SMPNIRQ               0x1
+#define VMODE_DUMB                  0x2
+#define VMODE_IPE                   0x3
+#define VMODE_IRE                   0x4
+
+/*
+ * defined Configure Alpha and Alpha mode for DMA control 1 register
+ * DMA1 bit[15:08](alpha) / bit[17:16](alpha mode)
+ */
+/* ALPHA mode */
+#define MODE_ALPHA_DMA              0x0
+#define MODE_ALPHA_GRA              0x1
+#define MODE_ALPHA_CFG              0x2
+
+/* alpha value */
+#define ALPHA_NOGRAPHIC		0xFF      /* all video, no graphic */
+#define ALPHA_NOVIDEO		0x00      /* all graphic, no video */
+#define ALPHA_GRAPHnVIDEO	0x0F      /* Selects graphic & video */
+
+/*
+ * defined Pixel Command for DMA control 1 register
+ * DMA1 bit[07:00]
+ */
+#define PIXEL_CMD                  0x81
+
+
+/* KW / DSMP specific registers. */
+#define LCD_CLK_CFG0_REG		0xF0A0
+#define LCD_PLL_LPF_MASK		(0xF << 0)
+#define LCD_PLL_LPF(x)			(x << 0)
+#define LCD_PLL_NDIV_MASK		(0x1FF << 4)
+#define LCD_PLL_NDIV(x)			((x) << 4)
+#define LCD_PLL_VCO_BAND_MASK		(0xF << 13)
+#define LCD_PLL_VCO_BAND(x)		(x << 13)
+#define LCD_PLL_MDIV_MASK		(0x1FF << 17)
+#define LCD_PLL_MDIV(x)			((x) << 17)
+#define LCD_PLL_KDIV_MASK		(0x3 << 26)
+#define LCD_PLL_KDIV(x)			((x) << 26)
+#define LCD_PLL_PWR_DOWN_MASK		(1 << 31)
+#define LCD_PLL_PWR_DOWN(en)		((en) << 31)
+
+
+#define LCD_CLK_CFG1_REG		0xF0A4
+#ifdef CONFIG_ARCH_ARMADA_XP
+#define LCD_FULL_DIV_MASK		(0x1FFF)
+#define LCD_FULL_DIV(x)			(x)
+#define LCD_HALF_DIV_MASK		(1 << 15)
+#define LCD_HALF_DIV(x)			(x << 15)
+#else
+#define LCD_FULL_DIV_MASK		(0x7F)
+#define LCD_FULL_DIV(x)			(x)
+#define LCD_HALF_DIV_MASK		(1 << 8)
+#define LCD_HALF_DIV(x)			(x << 8)
+#endif /* CONFIG_ARCH_ARMADA_XP */
+#define LCD_REF_CLK_MASK		(1 << 16)
+#define LCD_REF_CLK(x)			(x << 16)
+#define LCD_SMPN_EN_MASK		(1 << 17)
+#define LCD_SMPN_EN(x)			(x << 17)
+
+#define LCD_WIN_NUM			6
+#define LCD_WIN_CTRL(n)			(0xF000 + (n * 0x10))
+#define LCD_WIN_BASE(n)			(0xF004 + (n * 0x10))
+
+/* LVDS related registers. */
+#define LCD_LVDS_CLK_CFG		0xF0AC
+#define LCD_LVDS_CFG_SER_MASK		(1 << 30)
+#define LCD_LVDS_CFG_SER_EN(x)		(x << 30)
+#define LCD_LVDS_CFG_TICK_DRV_MASK	(0x7 << 8)
+#define LCD_LVDS_CFG_TICK_DRV(x)	(x << 8)
+#define LCD_LVDS_CFG_24BIT_MODE_MASK	(1 << 1)
+#define LCD_LVDS_CFG_24BIT_OPT1		(0 << 1)
+#define LCD_LVDS_CFG_24BIT_OPT2		(1 << 1)
+#define LCD_LVDS_CFG_PIN_CNT_MASK	(1 << 0)
+#define LCD_LVDS_CFG_PIN_CNT_18		(0 << 0)
+#define LCD_LVDS_CFG_PIN_CNT_24		(1 << 0)
+
+
+#endif
-- 
1.7.0

