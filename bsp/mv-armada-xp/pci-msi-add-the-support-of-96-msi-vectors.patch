From 14a4a5a96a55b2f9af9d7360b378d51d5802e74e Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Tue, 30 Jun 2015 14:00:33 +0800
Subject: [PATCH 1/3] pci/msi: add the support of 96 msi vectors

use the shared Inbound Doorbell Registers to replace the Inbound
Doorbell Register, and increase the max of msi vectors from 16 to
96.

Some PCI devices, such as WY580-T4 NIC, request memory size larger
than 2MB. Those deivce drivers will use legacy interrupts when
requesting memory failed. Increase PEX0/8/9 mem size to 4MB from 2MB to
support such devices on GP board.

Signed-off-by: czou <cao.zou@windriver.com>
---
 arch/arm/mach-armadaxp/include/mach/armadaxp.h |   17 +++--
 arch/arm/mach-armadaxp/include/mach/irqs.h     |    2 +-
 arch/arm/plat-armada/msi.c                     |   92 +++++++++++++++++-------
 3 files changed, 76 insertions(+), 35 deletions(-)

diff --git a/arch/arm/mach-armadaxp/include/mach/armadaxp.h b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
index 507f7bf..81d47fb 100644
--- a/arch/arm/mach-armadaxp/include/mach/armadaxp.h
+++ b/arch/arm/mach-armadaxp/include/mach/armadaxp.h
@@ -147,10 +147,10 @@
  * Reserve 127MB for PEX MEM space, so that in case an interface needs more
  * than 2MB, it will be possible to relocate it within the reserved 127MB.
  */
-#define PEX0_MEM_PHYS_BASE		0xF2000000
-#define PEX0_MEM_SIZE			_2M
-#define PEX1_MEM_PHYS_BASE		0xF2200000
-#define PEX1_MEM_SIZE			_2M
+#define PEX0_MEM_PHYS_BASE		0xF8000000
+#define PEX0_MEM_SIZE			_4M
+#define PEX1_MEM_PHYS_BASE		0xF2000000
+#define PEX1_MEM_SIZE			_4M
 #define PEX2_MEM_PHYS_BASE		0xF2400000
 #define PEX2_MEM_SIZE			_2M
 #define PEX3_MEM_PHYS_BASE		0xF2600000
@@ -164,9 +164,9 @@
 #define PEX7_MEM_PHYS_BASE		0xF2E00000
 #define PEX7_MEM_SIZE			_2M
 #define PEX8_MEM_PHYS_BASE		0xF3000000
-#define PEX8_MEM_SIZE			_2M
-#define PEX9_MEM_PHYS_BASE		0xF3200000
-#define PEX9_MEM_SIZE			_2M
+#define PEX8_MEM_SIZE			_4M
+#define PEX9_MEM_PHYS_BASE		0xF8400000
+#define PEX9_MEM_SIZE			_4M
 
 /*
  * Device Bus address decode windows.
@@ -284,6 +284,9 @@
 #define AXP_IRQ_VIRT_BASE		(AXP_PER_CPU_BASE)
 #define AXP_CPU_INTACK			0xB4
 #define AXP_IRQ_SEL_CAUSE_OFF		0xA0
+#define AXP_IN_SHARE_DOORBELL1 (AXP_BRIDGE_VIRT_BASE | 0x400)
+#define AXP_IN_SHARE_DOORBELL2 (AXP_BRIDGE_VIRT_BASE | 0x404)
+#define AXP_IN_SHARE_DOORBELL3 (AXP_BRIDGE_VIRT_BASE | 0x408)
 #define AXP_IN_DOORBELL_CAUSE		0x78
 #define AXP_IN_DRBEL_CAUSE		(AXP_PER_CPU_BASE | 0x78)
 #define AXP_IN_DRBEL_MSK		(AXP_PER_CPU_BASE | 0x7c)
diff --git a/arch/arm/mach-armadaxp/include/mach/irqs.h b/arch/arm/mach-armadaxp/include/mach/irqs.h
index 3968cf9..aa10681 100644
--- a/arch/arm/mach-armadaxp/include/mach/irqs.h
+++ b/arch/arm/mach-armadaxp/include/mach/irqs.h
@@ -147,7 +147,7 @@
 /*
  * AURORA MSI interrupts
  */
-#define NR_PRIVATE_MSI_GROUP		16
+#define NR_PRIVATE_MSI_GROUP		96
 #define NR_PRIVATE_MSI_IRQS		NR_PRIVATE_MSI_GROUP
 #define NR_MSI_IRQS			NR_PRIVATE_MSI_IRQS
 #define IRQ_AURORA_MSI_START		(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)
diff --git a/arch/arm/plat-armada/msi.c b/arch/arm/plat-armada/msi.c
index 77ac0cc..3c1e0ac 100644
--- a/arch/arm/plat-armada/msi.c
+++ b/arch/arm/plat-armada/msi.c
@@ -16,42 +16,85 @@
 
 static DECLARE_BITMAP(msi_irq_in_use, NR_PRIVATE_MSI_IRQS);
 
-void armada_msi_irq_handler(unsigned int irq, struct irq_desc *desc)
+void armada_msi_irq_handler1(unsigned int irq, struct irq_desc *desc)
 {
 	int j;
 	unsigned long status;
+	int irq_msi;
 
 	/* Read Inbound Shared Doorbell registers and find any active interrupts,
 	* then call ISR for each active interrupt
 	*/
-	status = MV_REG_READ(AXP_IN_DRBEL_CAUSE) & 0xFFFF0000;
-	if (!status)
-		return;
+	status = MV_REG_READ(AXP_IN_SHARE_DOORBELL1);
+	if (status) {
+		j = find_first_bit(&status, 32);
+
+		MV_REG_WRITE(AXP_IN_SHARE_DOORBELL1, ~(1 << j));
+		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL1);
+		/* write back to clear bit */
+		irq_msi = IRQ_AURORA_MSI_START + j;
+		generic_handle_irq(irq_msi);
+	}
+}
 
-	j = find_first_bit(&status, 32);
-	
-	MV_REG_WRITE(AXP_IN_DRBEL_CAUSE, ~(1 << j));
-	status = MV_REG_READ(AXP_IN_DRBEL_CAUSE);
-	/* write back to clear bit */
-	generic_handle_irq(IRQ_AURORA_MSI_START + j - NR_PRIVATE_MSI_IRQS);
+void armada_msi_irq_handler2(unsigned int irq, struct irq_desc *desc)
+{
+	int j;
+	unsigned long status;
+	int irq_msi;
+
+	status = MV_REG_READ(AXP_IN_SHARE_DOORBELL2);
+	if (status) {
+		j = find_first_bit(&status, 32);
+
+		MV_REG_WRITE(AXP_IN_SHARE_DOORBELL2, ~(1 << j));
+		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL2);
+		/* write back to clear bit */
+		irq_msi = IRQ_AURORA_MSI_START + j + 32;
+		generic_handle_irq(irq_msi);
+		return ;
+	}
+}
+
+void armada_msi_irq_handler3(unsigned int irq, struct irq_desc *desc)
+{
+	int j;
+	unsigned long status;
+	int irq_msi;
+
+	status = MV_REG_READ(AXP_IN_SHARE_DOORBELL3);
+	if (status) {
+		j = find_first_bit(&status, 32);
+
+		MV_REG_WRITE(AXP_IN_SHARE_DOORBELL3, ~(1 << j));
+		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL3);
+		/* write back to clear bit */
+		irq_msi = IRQ_AURORA_MSI_START + j + 64;
+		generic_handle_irq(irq_msi);
+		return ;
+	}
 }
 
 void __init armada_msi_init(void)
 {
 	unsigned long temp;
 
-	irq_set_chained_handler(IRQ_AURORA_IN_DRBL_HIGH, armada_msi_irq_handler);
+	irq_set_chained_handler(IRQ_AURORA_SHARE_INB_DB0, armada_msi_irq_handler1);
+	irq_set_chained_handler(IRQ_AURORA_SHARE_INB_DB1, armada_msi_irq_handler2);
+	irq_set_chained_handler(IRQ_AURORA_SHARE_INB_DB2, armada_msi_irq_handler3);
 
-	/* Unmask private doorbells 16-31 */
-	temp = MV_REG_READ(AXP_IN_DRBEL_MSK) | (0xFFFF0000);
-	MV_REG_WRITE(AXP_IN_DRBEL_MSK, temp);
+	temp = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB0));
+	temp |= 0xf;
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB0), temp);
 
-#ifdef CONFIG_SMP
-	/* Unmask doorbell high IRQ for all CPUs */
-	temp = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH));
+	temp = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB1));
 	temp |= 0xf;
-	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH), temp);
-#endif
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB1), temp);
+
+	temp = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB2));
+	temp |= 0xf;
+	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_SHARE_INB_DB2), temp);
+
 }
 
 /*
@@ -106,7 +149,8 @@ int armada_msi_set_affinity(struct irq_data *d, const struct cpumask *mask_val,b
 	msi_irq = irq - IRQ_AURORA_MSI_START;
 	msg.address_hi = 0x0;
 	msg.address_lo = AXP_SW_TRIG_IRQ_PHYS;
-	msg.data = ((msi_irq + NR_PRIVATE_MSI_GROUP) & AXP_SW_TRIG_IRQ_INITID_MASK);
+	msg.data = (0x1 << AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS) |
+			msi_irq  + 0x20;
 
 	for_each_cpu(i, mask_val)
 		msg.data |= (0x1 << (AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS + i));
@@ -124,12 +168,6 @@ void second_cpu_msi_init(void)
 	temp = MV_REG_READ(AXP_IN_DRBEL_MSK) | (0xFFFF0000);
 	MV_REG_WRITE(AXP_IN_DRBEL_MSK, temp);
 
-#ifdef CONFIG_SMP
-	/* Unmask doorbell high IRQ for all CPUs */
-	temp = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH));
-	temp |= 0xf;
-	MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_HIGH), temp);
-#endif
 }
 #endif
 
@@ -160,7 +198,7 @@ int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
 	msg.address_hi = 0x0;
 	msg.address_lo = AXP_SW_TRIG_IRQ_PHYS;
 	msg.data = (0x1 << AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS) | 
-			((msi_irq + NR_PRIVATE_MSI_GROUP) & AXP_SW_TRIG_IRQ_INITID_MASK);
+			msi_irq  + 0x20;
 
 	write_msi_msg(irq, &msg);
 	irq_set_chip_and_handler(irq, &armada_msi_irq_chip, handle_edge_irq);
-- 
1.7.0

