From 53fe4e3e8e689b600224559badcad57fa7c5967a Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 31 Jan 2013 17:55:36 +0800
Subject: [PATCH 49/50] arm: mmu: fix unaligned system memory size problem

When i tested kdump in the lpae enabled kernel and i passed
crashkernel=128M@128M to the crash kernel, the dump kernel can't
boot successfully after a crash occurs.

Through investigation, i found if we pass 128M ram to dump kernel,
the dump kernel will reserve 1M for elfheader, so only left 127M
system memory for dump kernel. When arm in lpae mode, the section
size is 2M, that is to say the 127M is not aligned to the section
size boundary, this will make the system call alloc_init_pte() from
alloc_init_section(), and this calling will end at calling
memblock_alloc(), memblock_alloc() will alloc memory from high
address first, under this situation, the allocated address has not
been mapped yet.

to resolve this problem, we limit memblock allocable address to mapped
address space before call alloc_init_pte().

This problem not only exist in the lpae enabled kernel, but also exist
in non-lpae kernel, if we pass a memory size that is not algined to
section size (1M for non-lpae), this problem will expose.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mm/mmu.c |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index 32d6c0a..51883f6 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -648,6 +648,21 @@ static void __init alloc_init_section(pud_t *pud, unsigned long addr,
 	}
 }
 
+#ifdef CONFIG_ARM_LPAE
+static void __init alloc_init_pmd(pud_t *pud, unsigned long addr,
+	unsigned long end, unsigned long phys, const struct mem_type *type)
+{
+	pmd_t *pmd = pmd_offset(pud, addr);
+	unsigned long next;
+
+	do {
+		next = pmd_addr_end(addr, end);
+		alloc_init_section(pud, addr, next, phys, type);
+		phys += next - addr;
+	} while (pmd++, addr = next, addr != end);
+}
+#endif
+
 static void __init alloc_init_pud(pgd_t *pgd, unsigned long addr,
 	unsigned long end, unsigned long phys, const struct mem_type *type)
 {
@@ -656,7 +671,11 @@ static void __init alloc_init_pud(pgd_t *pgd, unsigned long addr,
 
 	do {
 		next = pud_addr_end(addr, end);
+#ifndef CONFIG_ARM_LPAE
 		alloc_init_section(pud, addr, next, phys, type);
+#else
+		alloc_init_pmd(pud, addr, next, phys, type);
+#endif
 		phys += next - addr;
 	} while (pud++, addr = next, addr != end);
 }
@@ -1203,6 +1222,8 @@ static void __init map_lowmem(void)
 			end = arm_lowmem_limit;
 		if (start >= end)
 			break;
+		if (end & ~SECTION_MASK)
+			memblock_set_current_limit(end & (SECTION_MASK << 1));
 
 		map.pfn = __phys_to_pfn(start);
 		map.virtual = __phys_to_virt(start);
@@ -1211,6 +1232,7 @@ static void __init map_lowmem(void)
 
 		create_mapping(&map);
 	}
+	memblock_set_current_limit(arm_lowmem_limit);
 }
 
 /*
-- 
1.7.0

