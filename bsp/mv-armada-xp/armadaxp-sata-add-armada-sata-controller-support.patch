From d18ab2f572e08575e30a041b401c395fee078c1c Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 16 Jan 2013 11:02:52 +0800
Subject: [PATCH 19/50] armadaxp: sata: add armada sata controller support

Current driver only supports Orion platforms, we need to do some
change to let it support armada sata controller.
 - add a link quirk for aramda controller
 - implement mv_mbus_dram_info() since current driver needs it

The code is extracted from linux-3.2.27-axp_a370-2012_Q4.1, which
can be downloaded from:
https://extranet.marvell.com/extranet/dms/documents.do?groupID=4&\
subGroupID=53015

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-armadaxp/core.c |    6 ++++++
 drivers/ata/libata-pmp.c      |    9 +++++++++
 drivers/ata/sata_mv.c         |   28 +++++++++++++++++++++++++++-
 include/linux/ata_platform.h  |    3 +++
 include/linux/mbus.h          |    2 +-
 5 files changed, 46 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 8f992ca..5eceb38 100755
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -135,6 +135,12 @@ MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
 
 struct mbus_dram_target_info armadaxp_mbus_dram_info;
 
+const struct mbus_dram_target_info *mv_mbus_dram_info(void)
+{
+	return &armadaxp_mbus_dram_info;
+}
+EXPORT_SYMBOL_GPL(mv_mbus_dram_info);
+
 /* XOR0 is disabled in Z1 Silicone */
 #ifdef CONFIG_ARMADA_XP_REV_Z1
  /* XOR0 is disabled in Z1 Silicone */
diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c
index 21b80c5..195be15 100644
--- a/drivers/ata/libata-pmp.c
+++ b/drivers/ata/libata-pmp.c
@@ -456,7 +456,16 @@ static void sata_pmp_quirks(struct ata_port *ap)
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
+	} else if (vendor == 0x11ab && devid == 0x4140) {
+		/* Marvell 4140 quirks */
+
+		ata_for_each_link(link, ap, EDGE) {
+			/* port 4 is for SEMB device and it doesn't like SRST */
+			if (link->pmp == 4)
+				link->flags |= ATA_LFLAG_DISABLED;
+		}
 	}
+
 }
 
 /**
diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
index 7336d4a..1e3c781 100644
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@ -302,6 +302,7 @@ enum {
 	MV5_LTMODE		= 0x30,
 	MV5_PHY_CTL		= 0x0C,
 	SATA_IFCFG		= 0x050,
+	LP_PHY_CTL		= 0x058,
 
 	MV_M2_PREAMP_MASK	= 0x7e0,
 
@@ -1348,6 +1349,7 @@ static int mv_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val)
 
 	if (ofs != 0xffffffffU) {
 		void __iomem *addr = mv_ap_base(link->ap) + ofs;
+		void __iomem *lp_phy_addr = mv_ap_base(link->ap) + LP_PHY_CTL;
 		if (sc_reg_in == SCR_CONTROL) {
 			/*
 			 * Workaround for 88SX60x1 FEr SATA#26:
@@ -1364,6 +1366,16 @@ static int mv_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val)
 			 */
 			if ((val & 0xf) == 1 || (readl(addr) & 0xf) == 1)
 				val |= 0xf000;
+
+#ifdef CONFIG_PLAT_ARMADA
+			/*
+			 * Setting PHY speed according to SControl speed
+			 */
+			if ((val & 0xf0) == 0x10)
+				writelfl(0x7, lp_phy_addr);
+			else
+				writelfl(0x227, lp_phy_addr);
+#endif
 		}
 		writelfl(val, addr);
 		return 0;
@@ -2391,10 +2403,22 @@ static struct ata_queued_cmd *mv_get_active_qc(struct ata_port *ap)
 {
 	struct mv_port_priv *pp = ap->private_data;
 	struct ata_queued_cmd *qc;
+	struct ata_link *link = NULL;
 
 	if (pp->pp_flags & MV_PP_FLAG_NCQ_EN)
 		return NULL;
+#ifdef CONFIG_PLAT_ARMADA
+	ata_for_each_link(link, ap, EDGE)
+		if (ata_link_active(link))
+			break;
+
+        if (!link)
+                link = &ap->link;
+
+	qc = ata_qc_from_tag(ap, link->active_tag);
+#else
 	qc = ata_qc_from_tag(ap, ap->link.active_tag);
+#endif
 	if (qc && !(qc->tf.flags & ATA_TFLAG_POLLING))
 		return qc;
 	return NULL;
@@ -2779,7 +2803,9 @@ static void mv_process_crpb_entries(struct ata_port *ap, struct mv_port_priv *pp
 	/* Get the hardware queue position index */
 	in_index = (readl(port_mmio + EDMA_RSP_Q_IN_PTR)
 			>> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
-
+#ifdef CONFIG_PLAT_ARMADA
+		dma_io_sync();
+#endif
 	/* Process new responses from since the last time we looked */
 	while (in_index != pp->resp_idx) {
 		unsigned int tag;
diff --git a/include/linux/ata_platform.h b/include/linux/ata_platform.h
index b856a2a..9a26c83 100644
--- a/include/linux/ata_platform.h
+++ b/include/linux/ata_platform.h
@@ -27,7 +27,10 @@ extern int __devexit __pata_platform_remove(struct device *dev);
 /*
  * Marvell SATA private data
  */
+struct mbus_dram_target_info;
+
 struct mv_sata_platform_data {
+	struct mbus_dram_target_info	*dram;
 	int	n_ports; /* number of sata ports */
 };
 
diff --git a/include/linux/mbus.h b/include/linux/mbus.h
index efa1a6d..a6a0de2 100644
--- a/include/linux/mbus.h
+++ b/include/linux/mbus.h
@@ -36,7 +36,7 @@ struct mbus_dram_target_info
  * The Marvell mbus is to be found only on SOCs from the Orion family
  * at the moment.  Provide a dummy stub for other architectures.
  */
-#ifdef CONFIG_PLAT_ORION
+#if defined(CONFIG_PLAT_ORION) || defined(CONFIG_PLAT_ARMADA)
 extern const struct mbus_dram_target_info *mv_mbus_dram_info(void);
 #else
 static inline const struct mbus_dram_target_info *mv_mbus_dram_info(void)
-- 
1.7.0

