From 570ab603c68598bcf6eee94b6bbb6466e9886bb9 Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Tue, 11 Aug 2015 10:54:05 +0800
Subject: [PATCH 2/3] msi: marvell-xp: move the smp_affinity and add lock in interrupt of msi

for supporting more msi vectors, DB0 has been replaced with DB1/DB2/DB3,
they can not send msi interrupt to specific cpu, so move the interface
of smp_affinity. add lock in interrupt of mis, otherwise if more one cpu
entry the same interrupt, race error will be occured, and cpus will read
the error value in the same time, so add a spin_lock to protect the read.

for DB1/DB2/DB3 interrupt in smp, dispatch interrupts to cpu in order.
if there are three interrupts in DB1/DB2/DB3 and all cpus are free, cpu0,
cpu1, cpu2 will entry interrupts, if two, cpu0, cpu1 will be used.

Signed-off-by: czou <cao.zou@windriver.com>
---
 arch/arm/plat-armada/msi.c |   21 ++++++++++++++-------
 1 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/arch/arm/plat-armada/msi.c b/arch/arm/plat-armada/msi.c
index 3c1e0ac..e0c2ad3 100644
--- a/arch/arm/plat-armada/msi.c
+++ b/arch/arm/plat-armada/msi.c
@@ -22,6 +22,7 @@ void armada_msi_irq_handler1(unsigned int irq, struct irq_desc *desc)
 	unsigned long status;
 	int irq_msi;
 
+	raw_spin_lock(&desc->lock);
 	/* Read Inbound Shared Doorbell registers and find any active interrupts,
 	* then call ISR for each active interrupt
 	*/
@@ -33,7 +34,11 @@ void armada_msi_irq_handler1(unsigned int irq, struct irq_desc *desc)
 		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL1);
 		/* write back to clear bit */
 		irq_msi = IRQ_AURORA_MSI_START + j;
+		raw_spin_unlock(&desc->lock);
 		generic_handle_irq(irq_msi);
+	} else {
+		desc->irq_data.chip->irq_unmask(&desc->irq_data);
+		raw_spin_unlock(&desc->lock);
 	}
 }
 
@@ -43,6 +48,7 @@ void armada_msi_irq_handler2(unsigned int irq, struct irq_desc *desc)
 	unsigned long status;
 	int irq_msi;
 
+	raw_spin_lock(&desc->lock);
 	status = MV_REG_READ(AXP_IN_SHARE_DOORBELL2);
 	if (status) {
 		j = find_first_bit(&status, 32);
@@ -51,8 +57,10 @@ void armada_msi_irq_handler2(unsigned int irq, struct irq_desc *desc)
 		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL2);
 		/* write back to clear bit */
 		irq_msi = IRQ_AURORA_MSI_START + j + 32;
+		raw_spin_unlock(&desc->lock);
 		generic_handle_irq(irq_msi);
-		return ;
+	} else {
+		raw_spin_unlock(&desc->lock);
 	}
 }
 
@@ -62,6 +70,7 @@ void armada_msi_irq_handler3(unsigned int irq, struct irq_desc *desc)
 	unsigned long status;
 	int irq_msi;
 
+	raw_spin_lock(&desc->lock);
 	status = MV_REG_READ(AXP_IN_SHARE_DOORBELL3);
 	if (status) {
 		j = find_first_bit(&status, 32);
@@ -70,8 +79,10 @@ void armada_msi_irq_handler3(unsigned int irq, struct irq_desc *desc)
 		status = MV_REG_READ(AXP_IN_SHARE_DOORBELL3);
 		/* write back to clear bit */
 		irq_msi = IRQ_AURORA_MSI_START + j + 64;
+		raw_spin_unlock(&desc->lock);
 		generic_handle_irq(irq_msi);
-		return ;
+	} else {
+		raw_spin_unlock(&desc->lock);
 	}
 }
 
@@ -145,7 +156,7 @@ int armada_msi_set_affinity(struct irq_data *d, const struct cpumask *mask_val,b
 	u32 irq=d->irq;
 	int msi_irq;
 	int i;
-	
+
 	msi_irq = irq - IRQ_AURORA_MSI_START;
 	msg.address_hi = 0x0;
 	msg.address_lo = AXP_SW_TRIG_IRQ_PHYS;
@@ -157,7 +168,6 @@ int armada_msi_set_affinity(struct irq_data *d, const struct cpumask *mask_val,b
 
 	write_msi_msg(irq, &msg);
 	cpumask_copy(d->affinity, mask_val);
-	
 	return 0;
 }
 
@@ -178,9 +188,6 @@ struct irq_chip armada_msi_irq_chip = {
 	.irq_disable 		= mask_msi_irq,
 	.irq_mask 		= mask_msi_irq,
 	.irq_unmask 		= unmask_msi_irq,
-#ifdef CONFIG_SMP
-	.irq_set_affinity	= armada_msi_set_affinity,
-#endif
 };
 
 int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
-- 
1.7.0

