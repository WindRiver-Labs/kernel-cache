From 8512798f7183935795c9704f1e664c4687963924 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 16 Jan 2013 10:45:07 +0800
Subject: [PATCH 33/50] armadaxp: cpuidle: fix deep idle identity map

In the deep idle, cpu will disable MMU and enter power-saving state,
so the MMU disabling code should be run in the identity map context,
in the current kernel version, the identity map uses a new section
to handle it.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/plat-armada/armada_suspend.S |   28 +++++++++++++++++++++-------
 arch/arm/plat-armada/cpuidle.c        |   11 ++---------
 2 files changed, 23 insertions(+), 16 deletions(-)

diff --git a/arch/arm/plat-armada/armada_suspend.S b/arch/arm/plat-armada/armada_suspend.S
index de6c7a5..eaf56d2 100644
--- a/arch/arm/plat-armada/armada_suspend.S
+++ b/arch/arm/plat-armada/armada_suspend.S
@@ -265,6 +265,25 @@ dowfi:
 ENDPROC(armadaxp_cpu_suspend)
 
 /*
+* armadaxp_enable_mmu: enable mmu
+*
+* input:
+* r3 = identity mapping table
+* r4 = *virtual* address to jump to upon completion
+*/
+	.align	5
+	.pushsection	.idmap.text, "ax"
+ENTRY(armadaxp_enable_mmu)
+	mcr	p15, 0, r3, c2, c0, 0		@ set CP15 - TTBR
+	mov	r3, #0
+	mcr	p15, 0, r3, c13, c0, 1          @ set 0 in CP15 - context ID
+	mcr	p15, 0, r2, c1, c0, 0		@ restore CP15 - CR  @enable mmu
+	mrc     p15, 0, r3, c0, c0, 0           @ read id reg
+	mov	pc, r4
+ENDPROC(armadaxp_enable_mmu)
+	.popsection
+
+/*
 * armadaxp_cpu_resume: resume from cpu deepIdle state
 * input:
 */
@@ -330,14 +349,9 @@ ENTRY(armadaxp_cpu_resume)
 
 	/* load identity page table */
 	ldr	r3, identity_page_table_phys
-	mcr	p15, 0, r3, c2, c0, 0		@ set CP15 - TTBR
-	mov	r3, #0
-	mcr	p15, 0, r3, c13, c0, 1          @ set 0 in CP15 - context ID
-	mcr	p15, 0, r2, c1, c0, 0		@ restore CP15 - CR  @enable mmu
-	mrc     p15, 0, r3, c0, c0, 0           @ read id reg
 
-	ldr	r3, resume2
-	mov	pc, r3
+	ldr	r4, resume2
+	b       armadaxp_enable_mmu
 ENDPROC(armadaxp_cpu_resume)
 
 	/* stage 2 of the resume function that runs from PAGE_OFFSET virtual space */
diff --git a/arch/arm/plat-armada/cpuidle.c b/arch/arm/plat-armada/cpuidle.c
index 5c42577..6a064bc 100644
--- a/arch/arm/plat-armada/cpuidle.c
+++ b/arch/arm/plat-armada/cpuidle.c
@@ -23,6 +23,7 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 #include <asm/pgalloc.h>
+#include <asm/idmap.h>
 #include <asm/sections.h>
 #include <linux/export.h>
 #include <asm/sections.h>
@@ -76,15 +77,7 @@ extern u32 identity_page_table_phys;
 
 static int build_identity_page_table(void)
 {
-	pgd_t *pgd = pgd_alloc(&init_mm);
-	if (!pgd)
-		return -ENOMEM;
-
-	if (PHYS_OFFSET != PAGE_OFFSET) {
-		identity_mapping_add(pgd, __pa(_stext), __pa(_etext));
-		identity_mapping_add(pgd, __pa(_sdata), __pa(_edata)); /* is this needed?*/
-	}
-	identity_page_table_phys = virt_to_phys(*pgd);
+	identity_page_table_phys = virt_to_phys(idmap_pgd);
 	return 0;
 }
 
-- 
1.7.0

