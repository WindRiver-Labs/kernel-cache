From a5ac507b314b4121e652e48ad71303b4c52a5ce2 Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Wed, 17 Mar 2010 19:39:38 +0800
Subject: [PATCH 41/47] hwclock API support

timer2 is not used currently, so using it as the dedicated timer
for hwclock API.

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/core.c |  151 ++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 151 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-bcmring/core.c b/arch/arm/mach-bcmring/core.c
index b308a37..4c500ee 100644
--- a/arch/arm/mach-bcmring/core.c
+++ b/arch/arm/mach-bcmring/core.c
@@ -59,6 +59,10 @@
 #include <mach/csp/tmrHw_reg.h>
 #include <mach/csp/gpiomux.h>
 
+#ifdef CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 #define AMBA_DEVICE(name, initname, base, plat, size)       \
 static struct amba_device name##_device = {     \
    .dev = {                                     \
@@ -271,16 +275,19 @@ void __init bcmring_amba_init(void)
 /* slow down Linux's sense of time */
 #define TIMER0_FREQUENCY_MHZ  (tmrHw_LOW_FREQUENCY_MHZ * 30)
 #define TIMER1_FREQUENCY_MHZ  (tmrHw_LOW_FREQUENCY_MHZ * 30)
+#define TIMER2_FREQUENCY_MHZ  (tmrHw_HIGH_FREQUENCY_MHZ * 30)
 #define TIMER3_FREQUENCY_MHZ  (tmrHw_HIGH_FREQUENCY_MHZ * 30)
 #define TIMER3_FREQUENCY_KHZ   (tmrHw_HIGH_FREQUENCY_HZ / 1000 * 30)
 #else
 #define TIMER0_FREQUENCY_MHZ  tmrHw_LOW_FREQUENCY_MHZ
 #define TIMER1_FREQUENCY_MHZ  tmrHw_LOW_FREQUENCY_MHZ
+#define TIMER2_FREQUENCY_MHZ  tmrHw_HIGH_FREQUENCY_MHZ
 #define TIMER3_FREQUENCY_MHZ  tmrHw_HIGH_FREQUENCY_MHZ
 #define TIMER3_FREQUENCY_KHZ  (tmrHw_HIGH_FREQUENCY_HZ / 1000)
 #endif
 
 #define TICKS_PER_uSEC     TIMER0_FREQUENCY_MHZ
+#define TICKS_PER_uSEC_T2  TIMER2_FREQUENCY_MHZ
 
 /*
  *  These are useconds NOT ticks.
@@ -434,11 +441,134 @@ static int __init bcmring_clocksource_init(void)
 	return 0;
 }
 
+
+#ifdef CONFIG_HWTIMER_HOOKS
+
+#define HWTIMER_MIN_FREQ 2
+#define HWTIMER_MAX_FREQ 8192
+#define HWTIMER_DEF_FREQ 1024
+
+static DECLARE_HWTIMER_LOCK(bcmring_hwtimer_lock);
+static int bcmring_freq = HWTIMER_DEF_FREQ;
+
+static struct hwtimer_data bcmring_hwtimer_data = {
+	.name		= "Bcmring hwtimer",
+	.desc		= "Bcmring on-chip timer2",
+	.def_freq	= HWTIMER_DEF_FREQ,
+	.min_freq	= HWTIMER_MIN_FREQ,
+	.max_freq	= HWTIMER_MAX_FREQ
+};
+
+static int bcmring_hwtimer_get_freq(void)
+{
+	return bcmring_freq;
+}
+
+static int bcmring_hwtimer_set_freq(int freq)
+{
+	unsigned long reload;
+	unsigned int ctrl;
+	unsigned long flags;
+
+	if ((freq < HWTIMER_MIN_FREQ) || (freq > HWTIMER_MAX_FREQ))
+		return -EINVAL;
+
+	spin_lock_irqsave(&bcmring_hwtimer_lock, flags);
+
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) & ~(3 << 2);
+
+	reload = (TICKS_PER_uSEC_T2 * 1000000 + freq/2) / freq;
+
+	if (reload >= 0x100000) {
+		reload >>= 8;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (reload >= 0x10000) {
+		reload >>= 4;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+
+	writel(reload, TIMER2_VA_BASE + TIMER_LOAD);
+	writel(reload, TIMER2_VA_BASE + TIMER_VALUE);
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+
+	bcmring_freq = freq;
+
+	spin_unlock_irqrestore(&bcmring_hwtimer_lock, flags);
+	return 0;
+}
+
+static int bcmring_hwtimer_start(void)
+{
+	unsigned long flags;
+	unsigned int ctrl;
+
+	/* Start timer */
+	spin_lock_irqsave(&bcmring_hwtimer_lock, flags);
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) | TIMER_CTRL_ENABLE;
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+	spin_unlock_irqrestore(&bcmring_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static int bcmring_hwtimer_stop(void)
+{
+	unsigned long flags;
+	unsigned int ctrl;
+
+	/* Stop timer */
+	spin_lock_irqsave(&bcmring_hwtimer_lock, flags);
+	ctrl = readl(TIMER2_VA_BASE + TIMER_CTRL) & ~TIMER_CTRL_ENABLE;
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+	spin_unlock_irqrestore(&bcmring_hwtimer_lock, flags);
+
+	return 0;
+}
+
+static struct hwtimer bcmring_hwtimer = {
+	.data		= &bcmring_hwtimer_data,
+	.set_freq	= bcmring_hwtimer_set_freq,
+	.get_freq	= bcmring_hwtimer_get_freq,
+	.start		= bcmring_hwtimer_start,
+	.stop		= bcmring_hwtimer_stop,
+	.lock		= &bcmring_hwtimer_lock,
+	.hook		= NULL,
+	.hook_data	= NULL
+};
+
+/*
+ * IRQ handler for the clock API hwtimer
+ */
+static irqreturn_t bcmring_hwtimer_interrupt(int irq, void *dev_id)
+{
+	/* ...clear the interrupt */
+	writel(1, TIMER2_VA_BASE + TIMER_INTCLR);
+
+	spin_lock(bcmring_hwtimer.lock);
+
+	if (bcmring_hwtimer.hook != NULL)
+		(bcmring_hwtimer.hook) (bcmring_hwtimer.hook_data);
+
+	spin_unlock(bcmring_hwtimer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bcmring_hwtimer_irq = {
+	.name		= "Bcmring HWTimer Tick",
+	.flags		= IRQF_DISABLED | IRQF_TIMER,
+	.handler	= bcmring_hwtimer_interrupt,
+};
+#endif  /* CONFIG_HWTIMER_HOOKS */
 /*
  * Set up timer interrupt, and return the current time in seconds.
  */
 void __init bcmring_init_timer(void)
 {
+#ifdef CONFIG_HWTIMER_HOOKS
+	unsigned long reload;
+	unsigned int ctrl;
+#endif
 	printk(KERN_INFO "bcmring_init_timer\n");
 	/*
 	 * Initialise to a known state (all timers off)
@@ -453,6 +583,27 @@ void __init bcmring_init_timer(void)
 	 */
 	setup_irq(IRQ_TIMER0, &bcmring_timer_irq);
 
+#ifdef CONFIG_HWTIMER_HOOKS
+	reload = (TICKS_PER_uSEC_T2 * 1000000 + HWTIMER_DEF_FREQ/2) / HWTIMER_DEF_FREQ;
+	ctrl = TIMER_CTRL_PERIODIC | TIMER_CTRL_IE;
+
+	if (reload > 0x100000) {
+		reload >>= 8;
+		ctrl |= TIMER_CTRL_DIV256;
+	} else if (reload > 0x010000) {
+		reload >>= 4;
+		ctrl |= TIMER_CTRL_DIV16;
+	}
+
+	writel(reload, TIMER2_VA_BASE + TIMER_LOAD);
+	writel(reload, TIMER2_VA_BASE + TIMER_VALUE);
+	writel(ctrl, TIMER2_VA_BASE + TIMER_CTRL);
+
+	setup_irq(IRQ_TIMER2, &bcmring_hwtimer_irq);
+
+	register_hwtimer(&bcmring_hwtimer);
+#endif  /*  CONFIG_HWTIMER_HOOKS */
+
 	bcmring_clocksource_init();
 
 	timer0_clockevent.mult =
-- 
1.7.0.4

