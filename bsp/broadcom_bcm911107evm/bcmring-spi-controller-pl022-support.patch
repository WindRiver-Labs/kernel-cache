From d37b0b4ba7825fb6125280efa05000463a440a43 Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Wed, 17 Mar 2010 19:39:31 +0800
Subject: [PATCH 34/47] bcmring: spi controller pl022 support

spi controller (pl022) on bcmring is an AMBA device,
here add the driver to support it.

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/core.c                       |   57 +-
 arch/arm/mach-bcmring/csp/Makefile                 |    1 +
 arch/arm/mach-bcmring/csp/spi/Makefile             |    1 +
 arch/arm/mach-bcmring/csp/spi/spiHw_pl022.c        | 1052 ++++++++++++
 arch/arm/mach-bcmring/dma_device.c                 |   47 +
 arch/arm/mach-bcmring/include/csp/spiHw.h          |  692 ++++++++
 .../mach-bcmring/include/mach/csp/spiHw_inline.h   |  210 +++
 arch/arm/mach-bcmring/include/mach/csp/spiHw_reg.h |  117 ++
 arch/arm/mach-bcmring/include/mach/spih.h          |   38 +
 drivers/spi/Kconfig                                |   12 +
 drivers/spi/Makefile                               |    1 +
 drivers/spi/spi_bcmring.c                          | 1666 ++++++++++++++++++++
 12 files changed, 3893 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/csp/spi/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/spi/spiHw_pl022.c
 create mode 100644 arch/arm/mach-bcmring/include/csp/spiHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/spiHw_inline.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/spiHw_reg.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/spih.h
 create mode 100644 drivers/spi/spi_bcmring.c

diff --git a/arch/arm/mach-bcmring/core.c b/arch/arm/mach-bcmring/core.c
index 4552053..0f0f033 100644
--- a/arch/arm/mach-bcmring/core.c
+++ b/arch/arm/mach-bcmring/core.c
@@ -30,6 +30,7 @@
 #include <linux/amba/bus.h>
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
+#include <linux/spi/spi.h>
 
 #include <linux/amba/bus.h>
 #include <mach/csp/mm_addr.h>
@@ -39,6 +40,7 @@
 #include <asm/irq.h>
 #include <asm/hardware/arm_timer.h>
 #include <asm/mach-types.h>
+#include <mach/spih.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach/flash.h>
@@ -74,12 +76,49 @@ static struct amba_device name##_device = {     \
    }                                            \
 }
 
+/* sample CS control function */
+static void spi_sample_cs_control(u32 command)
+{
+	/* TODO: depends on which GPIO to use */
+	if (command & BCMRING_CS_ASSERT) {
+		/* active low? */
+	} else {
+		/* inactive */
+	}
+}
+
+/* sample SPI slave */
+static struct bcmring_spi_chip spi_sample_slave = {
+	.enable_dma = 1, /* enable/disable DMA */
+	.cs_control = spi_sample_cs_control,
+};
+
+/*
+ * SPI board info for the slaves
+ */
+static struct spi_board_info spi_slave_board_info[] __initdata = {
+	{
+		.modalias = "spidev", /* use spidev generic driver */
+		.max_speed_hz = 150000000, /* use max speed */
+		.bus_num = 0, /* framework bus number */
+		.chip_select = 0, /* for each slave */
+		.platform_data = NULL, /* no spi_driver specific */
+		.controller_data = &spi_sample_slave,
+		.irq = 0, /* IRQ for this device */
+		.mode = SPI_MODE_0, /* SPI mode 0 */
+	},
+};
+
+static struct bcmring_spi_master spi_master_info = {
+	.num_chipselect = 1,
+};
 
 AMBA_DEVICE(uartA, "uarta", UARTA, NULL, SZ_4K);
 AMBA_DEVICE(uartB, "uartb", UARTB, NULL, SZ_4K);
 AMBA_DEVICE(gpio0, "GPIO0", GPIO0, NULL, SZ_4K >> 1);
 AMBA_DEVICE(gpio1, "GPIO1", GPIO1, NULL, SZ_4K >> 1);
 AMBA_DEVICE(wdog, "WDOG", WATCHDOG, NULL, SZ_4K >> 1);
+AMBA_DEVICE(spih, "SPI", SPIH, &spi_master_info, SZ_4K);
 
 static struct clk pll1_clk = {
 	.name = "PLL1",
@@ -113,6 +152,14 @@ static struct clk i2c_clk = {
 	.parent = &xtal_clk,
 };
 
+static struct clk spi_clk = {
+	.name = "SPI",
+	.type = CLK_TYPE_PROGRAMMABLE,
+	.csp_id = chipcHw_CLOCK_SPI,
+	.rate_hz = 50000000,
+	.parent = &pll1_clk,
+};
+
 static struct clk_lookup lookups[] = {
 	{			/* UART0 */
 	 .dev_id = "uarta",
@@ -127,6 +174,9 @@ static struct clk_lookup lookups[] = {
 	}, {
 		.con_id = "I2C",
 		.clk = &i2c_clk,
+	}, {
+		.con_id = "SPI",
+		.clk = &spi_clk,
 	}
 };
 
@@ -135,6 +185,7 @@ static struct amba_device *amba_devs[] __initdata = {
 	&uartB_device,
 	&gpio0_device,
 	&gpio1_device,
+	&spih_device,
 	&wdog_device,
 };
 
@@ -170,7 +221,8 @@ void __init bcmring_amba_init(void)
 	/* driver to access these blocks. The bus is probed, and the drivers are loaded. */
 	/* FIXME Need to remove enable of PIF once CLCD clock enable used properly in FPGA. */
 	bus_clock = chipcHw_REG_BUS_CLOCK_GE
-	    | chipcHw_REG_BUS_CLOCK_SDIO0 | chipcHw_REG_BUS_CLOCK_SDIO1;
+	    | chipcHw_REG_BUS_CLOCK_SDIO0 | chipcHw_REG_BUS_CLOCK_SDIO1
+	    | chipcHw_REG_BUS_CLOCK_SPIH;
 
 	chipcHw_busInterfaceClockEnable(bus_clock);
 
@@ -181,6 +233,9 @@ void __init bcmring_amba_init(void)
 		struct amba_device *d = amba_devs[i];
 		amba_device_register(d, &iomem_resource);
 	}
+
+	/* register SPI slave device */
+	spi_register_board_info(spi_slave_board_info, ARRAY_SIZE(spi_slave_board_info));
 }
 
 /*
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index 6f69a83..979c23c 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -5,3 +5,4 @@ obj-y += gpio/
 obj-y += gpiomux/
 obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
 obj-$(CONFIG_I2C_BCM11XX) += i2c/
+obj-$(CONFIG_SPI_BCMRING) += spi/
diff --git a/arch/arm/mach-bcmring/csp/spi/Makefile b/arch/arm/mach-bcmring/csp/spi/Makefile
new file mode 100644
index 0000000..458c7d7
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/spi/Makefile
@@ -0,0 +1 @@
+obj-y += spiHw_pl022.o   
diff --git a/arch/arm/mach-bcmring/csp/spi/spiHw_pl022.c b/arch/arm/mach-bcmring/csp/spi/spiHw_pl022.c
new file mode 100644
index 0000000..82f260c
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/spi/spiHw_pl022.c
@@ -0,0 +1,1052 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file	 spiHw_pl022.c
+*
+*  @brief	Lower level SPI host device driver for BCMRING
+*/
+/****************************************************************************/
+
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/stdint.h>
+#include <csp/reg.h>
+
+#include <mach/csp/mm_io.h>
+#include <csp/spiHw.h>
+#include <mach/csp/spiHw_reg.h>
+#include <csp/gpioHw.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <mach/gpio_defs.h>
+#include <mach/csp/gpiomux.h>
+#include <csp/delay.h>
+#include <csp/module.h>  /* for EXPORT_SYMBOL */
+
+/* ---- Private Constants and Types ---------------------------------------- */
+
+#define SPIHW_SCR_MIN			0
+#define SPIHW_SCR_MAX			255
+#define SPIHW_DVSR_MIN			2
+#define SPIHW_DVSR_MAX			254
+
+#define SPIHW_BR_TARGET_MIN		2
+#define SPIHW_BR_DVSR_START		2
+#define SPIHW_BR_DVSR_INCR		2
+#define SPIHW_BR_TARGET_MAX		((1 + SPIHW_SCR_MAX)*SPIHW_DVSR_MAX)
+
+#define SPIHW_8BITS			8
+#define SPIHW_FIFODEPTH			8
+
+#define SPIHW_TIMEOUT			60000000
+
+#define DEFAULT_SPI_CLK_FREQ		99995117
+
+#if !defined(BOOT0_BUILD)
+static uint8_t gCsNumSel;	 /* SPI chip select profile value */
+#endif
+
+#if !defined(BOOT0_BUILD)
+/* Function pointers */
+SPIHW_TRANSFER_FNCS  gSpiHw_TransferFncs;
+#endif
+
+static int SpiHw_DefaultStartTransferFunc(uint8_t csNum)
+{
+	switch (csNum) {
+	case 0:
+		GpioHw_SetVal(SPIHW_CS0_GPIOPIN, 0);
+		break;
+#if !defined(BOOT0_BUILD)
+	case 1:
+		GpioHw_SetVal(SPIHW_CS1_GPIOPIN, 0);
+		break;
+	case 2:
+		GpioHw_SetVal(SPIHW_CS2_GPIOPIN, 0);
+		break;
+#endif
+	default:
+		/* do nothing*/
+		break;
+	}
+	return 0;
+}
+
+static int SpiHw_DefaultStopTransferFunc(uint8_t csNum)
+{
+	switch (csNum) {
+	case 0:
+		GpioHw_SetVal(SPIHW_CS0_GPIOPIN, 1);
+		break;
+#if !defined(BOOT0_BUILD)
+	case 1:
+		GpioHw_SetVal(SPIHW_CS1_GPIOPIN, 1);
+		break;
+	case 2:
+		GpioHw_SetVal(SPIHW_CS2_GPIOPIN, 1);
+		break;
+#endif
+	default:
+		/* do nothing*/
+		break;
+	}
+	return 0;
+}
+
+static int SpiHw_StartTransfer(uint8_t csNum)
+{
+#if !defined(BOOT0_BUILD)
+	if (gSpiHw_TransferFncs.startTransfer)
+		return gSpiHw_TransferFncs.startTransfer(csNum);
+	else
+#endif
+		return SpiHw_DefaultStartTransferFunc(csNum);
+}
+
+static int SpiHw_StopTransfer(uint8_t csNum)
+{
+#if !defined(BOOT0_BUILD)
+	if (gSpiHw_TransferFncs.stopTransfer)
+		return gSpiHw_TransferFncs.stopTransfer(csNum);
+	else
+#endif
+		return SpiHw_DefaultStopTransferFunc(csNum);
+}
+
+static void SpiHw_ClearRxFifo(void)
+{
+	/* Clear out FIFO */
+	while (SpiHw_IsRxNotEmpty()) {
+		/* Access FIFO to empty contents */
+		reg16_read(&spiHwRegp->sspdr);
+	}
+}
+
+static int SpiHw_WaitForIdle(uint32_t timeout_us)
+{
+	while (SpiHw_IsBusy()) {
+		timeout_us--;
+#if !defined(BOOT0_BUILD)
+		udelay(1);
+#else
+		__asm("nop \n\t"
+		      "nop \n\t");
+#endif
+		if (timeout_us <= 0)
+			return -1;
+	}
+	return 0;
+}
+
+#if !defined(BOOT0_BUILD)
+static unsigned int SpiHw_ReadPoll8(void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j;
+	unsigned int numRecv = 0;
+	uint8_t *ptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	ptr = (uint8_t *)rx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		/* Write out dummy values to receive the correct amount of data */
+		while (SpiHw_IsTxNotFull() && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, 0);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		/* Store received data */
+		while (j != 0) {
+			ptr[numRecv] = reg8_read((uint8_t *)&spiHwRegp->sspdr);
+			numRecv++;
+			j--;
+		}
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRecv;
+}
+
+static unsigned int SpiHw_ReadPoll16(void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j;
+	unsigned int numRecv = 0;
+	uint16_t *ptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	ptr = (uint16_t *)rx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		/* Write out dummy values to receive the correct amount of data */
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg16_write(&spiHwRegp->sspdr, 0);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		/* Store received data */
+		while (j != 0) {
+			ptr[numRecv] = reg16_read(&spiHwRegp->sspdr);
+			numRecv++;
+			j--;
+		}
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRecv;
+}
+
+static unsigned int SpiHw_WritePoll8(void *tx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j;
+	uint8_t *ptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	ptr = (uint8_t *)tx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, ptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numFrames;
+}
+
+static unsigned int SpiHw_WritePoll16(void *tx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j;
+	uint16_t *ptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	ptr = (uint16_t *)tx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg16_write(&spiHwRegp->sspdr, ptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numFrames;
+}
+#endif
+
+static unsigned int SpiHw_ReadCmdDataPoll8(void *cmd_bufp, unsigned int numCmdFrames, void *rx_bufp, unsigned int numRxFrames)
+{
+	unsigned int i, j;
+	unsigned int numRecv = 0;
+	uint8_t *cmdtxptr, *rxptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	cmdtxptr = (uint8_t *)cmd_bufp;
+	rxptr = (uint8_t *)rx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numCmdFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numCmdFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, cmdtxptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+	i = 0;
+	while (i < numRxFrames) {
+		j = 0;
+		/* Write out dummy values to receive the correct amount of data */
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numRxFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, 0);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		/* Store received data */
+		while (j != 0) {
+			rxptr[numRecv] = reg8_read((uint8_t *)&spiHwRegp->sspdr);
+			numRecv++;
+			j--;
+		}
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRecv;
+}
+
+#if !defined(BOOT0_BUILD)
+static unsigned int SpiHw_ReadCmdDataPoll16(void *cmd_bufp, unsigned int numCmdFrames, void *rx_bufp, unsigned int numRxFrames)
+{
+	unsigned int i, j;
+	unsigned int numRecv = 0;
+	uint16_t *cmdtxptr, *rxptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	cmdtxptr = (uint16_t *)cmd_bufp;
+	rxptr = (uint16_t *)rx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numCmdFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numCmdFrames) {
+			reg16_write(&spiHwRegp->sspdr, cmdtxptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+	i = 0;
+	while (i < numRxFrames) {
+		j = 0;
+		/* Write out dummy values to receive the correct amount of data */
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numRxFrames) {
+			reg16_write(&spiHwRegp->sspdr, 0);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		/* Store received data */
+		while (j != 0) {
+			rxptr[numRecv] = reg16_read(&spiHwRegp->sspdr);
+			numRecv++;
+			j--;
+		}
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRecv;
+}
+
+static unsigned int SpiHw_WriteCmdDataPoll8(void *cmd_bufp, unsigned int numCmdFrames, void *tx_bufp, unsigned int numTxFrames)
+{
+	unsigned int i, j;
+	uint8_t *cmdtxptr, *txptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	cmdtxptr = (uint8_t *)cmd_bufp;
+	txptr = (uint8_t *)tx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numCmdFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numCmdFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, cmdtxptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+	i = 0;
+	while (i < numTxFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numTxFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, txptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numTxFrames;
+}
+
+static unsigned int SpiHw_WriteCmdDataPoll16(void *cmd_bufp, unsigned int numCmdFrames, void *tx_bufp, unsigned int numTxFrames)
+{
+	unsigned int i, j;
+	uint16_t *cmdtxptr, *txptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	cmdtxptr = (uint16_t *)cmd_bufp;
+	txptr = (uint16_t *)tx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numCmdFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numCmdFrames) {
+			reg16_write(&spiHwRegp->sspdr, cmdtxptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+	i = 0;
+	while (i < numTxFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numTxFrames) {
+			reg16_write(&spiHwRegp->sspdr, txptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		SpiHw_ClearRxFifo();
+	}
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numTxFrames;
+}
+
+static unsigned int SpiHw_WriteReadPoll8(void *tx_bufp, void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j;
+	unsigned int numRead = 0;
+	uint8_t *txptr, *rxptr;
+
+	/* Ensure device is no longer busy */
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	txptr = (uint8_t *)tx_bufp;
+	rxptr = (uint8_t *)rx_bufp;
+
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull()  && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, txptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		while (j != 0) {
+			rxptr[numRead] = reg8_read((uint8_t *)&spiHwRegp->sspdr);
+			numRead++;
+			j--;
+		}
+	}
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRead;
+}
+
+static unsigned int SpiHw_WriteReadPoll16(void *tx_bufp, void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int i, j, to;
+	unsigned int numRead = 0;
+	uint16_t *txptr, *rxptr;
+
+	/* Ensure device is no longer busy */
+	to = SPIHW_TIMEOUT;
+	if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+		return 0;
+
+	SpiHw_ClearRxFifo();
+
+	txptr = (uint16_t *)tx_bufp;
+	rxptr = (uint16_t *)rx_bufp;
+
+#if !defined(BOOT0_BUILD)
+	SpiHw_StartTransfer(gCsNumSel);
+#else
+	SpiHw_StartTransfer(0);
+#endif
+
+	i = 0;
+	while (i < numFrames) {
+		j = 0;
+		while (SpiHw_IsTxNotFull() && !SpiHw_IsRxFull() && j < (SPIHW_FIFODEPTH) && i < numFrames) {
+			reg16_write(&spiHwRegp->sspdr, txptr[i]);
+			i++;
+			j++;
+		}
+
+		/* Wait for transmit/receive to occur */
+		if (SpiHw_WaitForIdle(SPIHW_TIMEOUT))
+			break;
+
+		while (j != 0) {
+			rxptr[numRead] = reg16_read(&spiHwRegp->sspdr);
+			numRead++;
+			j--;
+		}
+	}
+#if !defined(BOOT0_BUILD)
+	SpiHw_StopTransfer(gCsNumSel);
+#else
+	SpiHw_StopTransfer(0);
+#endif
+	return numRead;
+}
+
+static unsigned int SpiHw_ReadFifo8(void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int numRead = 0;
+	uint8_t *rxptr = (uint8_t *)rx_bufp;
+
+	while (numRead < numFrames) {
+		if (SpiHw_IsRxNotEmpty()) {
+			rxptr[numRead] = reg8_read((uint8_t *)&spiHwRegp->sspdr);
+			numRead++;
+		} else
+			break;
+	}
+	return numRead;
+}
+
+static unsigned int SpiHw_ReadFifo16(void *rx_bufp, unsigned int numFrames)
+{
+	unsigned int numRead = 0;
+	uint16_t *rxptr = (uint16_t *)rx_bufp;
+
+	while (numRead < numFrames) {
+		if (SpiHw_IsRxNotEmpty()) {
+			rxptr[numRead] = reg16_read(&spiHwRegp->sspdr);
+			numRead++;
+		} else
+			break;
+	}
+	return numRead;
+}
+
+static unsigned int SpiHw_WriteFifo8(void *tx_bufp, unsigned int numFrames)
+{
+	unsigned int numWrite = 0;
+	uint8_t *txptr = (uint8_t *)tx_bufp;
+
+	while (numWrite < numFrames) {
+		if (SpiHw_IsTxNotFull()) {
+			reg8_write((uint8_t *)&spiHwRegp->sspdr, txptr[numWrite]);
+			numWrite++;
+		} else
+			break;
+	}
+	return numWrite;
+}
+
+static unsigned int SpiHw_WriteFifo16(void *tx_bufp, unsigned int numFrames)
+{
+	unsigned int numWrite = 0;
+	uint16_t *txptr = (uint16_t *)tx_bufp;
+
+	while (numWrite < numFrames) {
+		if (SpiHw_IsTxNotFull()) {
+			reg16_write(&spiHwRegp->sspdr, txptr[numWrite]);
+			numWrite++;
+		} else
+			break;
+	}
+	return numWrite;
+}
+#endif
+
+static int SpiHw_SetSCR(unsigned int scr)
+{
+	SPIHW_REG_SET_SSPCR0_SCR(&spiHwRegp->sspcr0, scr);
+	return 0;
+}
+
+#if !defined(BOOT0_BUILD)
+static int SpiHw_GetSCR(void)
+{
+	return SPIHW_REG_GET_SSPCR0_SCR(&spiHwRegp->sspcr0);
+}
+#endif
+
+static int SpiHw_SetCPS_DVSR(int cpsdvsr)
+{
+	/* Validate given divisor.  Value must be even and between 2 and 254 */
+	if ((cpsdvsr & 0x1) || cpsdvsr < SPIHW_DVSR_MIN || cpsdvsr > SPIHW_DVSR_MAX)
+		return -1;
+
+	reg8_write(&spiHwRegp->sspcpsr, SPIHW_REG_SSPCPSR(cpsdvsr));
+	return 0;
+}
+
+#if !defined(BOOT0_BUILD)
+static int SpiHw_GetCPS_DVSR(void)
+{
+	return SPIHW_REG_SSPCPSR(reg8_read(&spiHwRegp->sspcpsr));
+}
+#endif
+
+#if !defined(BOOT0_BUILD)
+int SpiHw_Init(SPIHW_TRANSFER_FNCS *spiHw_fncp)
+#else
+int SpiHw_Init(void)
+#endif
+{
+#if !defined(BOOT0_BUILD)
+	if (spiHw_fncp) {
+		/* Initialize Function pointers */
+		gSpiHw_TransferFncs.startTransfer = spiHw_fncp->startTransfer;
+		gSpiHw_TransferFncs.stopTransfer = spiHw_fncp->stopTransfer;
+	} else
+#endif
+	{
+		/* By default, configure SPI pins to SPI mode */
+#ifdef __KERNEL__
+		gSpiHw_TransferFncs.startTransfer = 0;
+		gSpiHw_TransferFncs.stopTransfer = 0;
+
+		gpiomux_requestGroup(gpiomux_group_spi, "spiHw_plo22");
+
+		/* Setup CS output enable pins */
+		gpiomux_request(SPIHW_CS0_GPIOPIN, chipcHw_GPIO_FUNCTION_GPIO, "spiHw_plo22");
+		gpiomux_request(SPIHW_CS1_GPIOPIN, chipcHw_GPIO_FUNCTION_GPIO, "spiHw_plo22");
+		gpiomux_request(SPIHW_CS2_GPIOPIN, chipcHw_GPIO_FUNCTION_GPIO, "spiHw_plo22");
+
+		GpioHw_SetDirOutput(SPIHW_CS0_GPIOPIN);
+		GpioHw_SetDirOutput(SPIHW_CS1_GPIOPIN);
+		GpioHw_SetDirOutput(SPIHW_CS2_GPIOPIN);
+
+		GpioHw_SetVal(SPIHW_CS0_GPIOPIN, 1);
+		GpioHw_SetVal(SPIHW_CS1_GPIOPIN, 1);
+		GpioHw_SetVal(SPIHW_CS2_GPIOPIN, 1);
+#else
+		/* boot0 and serial loaders don't include gpiomux.c for space reasons. */
+		chipcHw_setGpioPinFunction(SPIHW_MISO_GPIOPIN, chipcHw_GPIO_FUNCTION_SPI);
+		chipcHw_setGpioPinFunction(SPIHW_CLK_GPIOPIN, chipcHw_GPIO_FUNCTION_SPI);
+		chipcHw_setGpioPinFunction(SPIHW_MOSI_GPIOPIN, chipcHw_GPIO_FUNCTION_SPI);
+
+		/* Setup CS output enable pins */
+		chipcHw_setGpioPinFunction(SPIHW_CS0_GPIOPIN, chipcHw_GPIO_FUNCTION_GPIO);
+		GpioHw_SetDirOutput(SPIHW_CS0_GPIOPIN);
+		GpioHw_SetVal(SPIHW_CS0_GPIOPIN, 1);
+#endif
+
+#if !defined(BOOT0_BUILD)
+		/* Initialize Function pointers */
+		gSpiHw_TransferFncs.startTransfer = (void *)0;
+		gSpiHw_TransferFncs.stopTransfer = (void *)0;
+#endif
+	}
+
+#if !defined(BOOT0_BUILD)
+	/* By default, select chip select 0 */
+	SpiHw_SetChipSelect(0);
+
+	/*
+	 *  Clock to SPI will be enabled in the linux driver.  Not required for BOOT0 since SPI clock is enabled
+	 *  by default.
+	 */
+#endif
+
+	/* Set to Motorola SPI frame format by default*/
+	SPIHW_REG_SET_SSPCR0_FRF(&spiHwRegp->sspcr0, SPIHW_FRF_MOTOROLA_SPI);
+
+	/* Set to Motorola format mode 3 by default (required for flash) */
+	reg16_set_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCR0_SPO);
+	reg16_set_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCRO_SPH);
+
+	/* Set in master mode */
+	reg8_clear_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_MS);
+
+	/* Ensure slave output disabled */
+	reg8_clear_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_SOD);
+
+	/* Set the default frame size to 8 */
+	SpiHw_SetFrameSize(8);
+
+	/* Ensure not in loopback testing mode */
+	SpiHw_LoopBackModeDisable();
+
+	return 0;
+}
+EXPORT_SYMBOL(SpiHw_Init);
+
+#if !defined(BOOT0_BUILD)
+int SpiHw_Exit(void)
+{
+	/* Ensure all chip selects are high */
+	GpioHw_SetVal(SPIHW_CS0_GPIOPIN, 1);
+	GpioHw_SetVal(SPIHW_CS1_GPIOPIN, 1);
+	GpioHw_SetVal(SPIHW_CS2_GPIOPIN, 1);
+
+	/* Return back to input mode */
+	GpioHw_SetDirInput(SPIHW_CS0_GPIOPIN);
+	GpioHw_SetDirInput(SPIHW_CS1_GPIOPIN);
+	GpioHw_SetDirInput(SPIHW_CS2_GPIOPIN);
+
+	return 0;
+}
+
+int SpiHw_SetChipSelect(uint8_t csNum)
+{
+	gCsNumSel = csNum;
+	return 0;
+}
+
+int SpiHw_GetChipSelect(void)
+{
+	return gCsNumSel;
+}
+
+
+unsigned int SpiHw_ReadPoll(void *rx_bufp, unsigned int numFrames)
+{
+	if (SpiHw_GetFrameFormat() != SPIHW_FRMFORMAT_NAT_MW) {
+		/* Check on data size per frame */
+		if (SpiHw_GetFrameSize() > SPIHW_8BITS) {
+			return SpiHw_ReadPoll16(rx_bufp, numFrames);
+		} else {
+			return SpiHw_ReadPoll8(rx_bufp, numFrames);
+		}
+	} else {
+		 /* Unable to simply read in microwire format as
+		 * we must send 8 bit command
+		 */
+		return 0;
+	}
+}
+
+unsigned int SpiHw_WritePoll(void *tx_bufp, unsigned int numFrames)
+{
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS)
+		return SpiHw_WritePoll16(tx_bufp, numFrames);
+	else
+		return SpiHw_WritePoll8(tx_bufp, numFrames);
+}
+EXPORT_SYMBOL(SpiHw_WritePoll);
+#endif
+
+unsigned int SpiHw_ReadCmdDataPoll(void *cmd_bufp, unsigned int numCmdFrames, void *rx_bufp, unsigned int numRxFrames)
+{
+#if !defined(BOOT0_BUILD)
+	/* Check on data size per frame */
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS) {
+		return SpiHw_ReadCmdDataPoll16(cmd_bufp, numCmdFrames, rx_bufp, numRxFrames);
+	} else
+#endif
+	{
+		return SpiHw_ReadCmdDataPoll8(cmd_bufp, numCmdFrames, rx_bufp, numRxFrames);
+	}
+}
+
+#if !defined(BOOT0_BUILD)
+unsigned int SpiHw_WriteCmdDataPoll(void *cmd_bufp, unsigned int numCmdFrames, void *tx_bufp, unsigned int numTxFrames)
+{
+	/* Check on data size per frame */
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS)
+		return SpiHw_WriteCmdDataPoll16(cmd_bufp, numCmdFrames, tx_bufp, numTxFrames);
+	else
+		return SpiHw_WriteCmdDataPoll8(cmd_bufp, numCmdFrames, tx_bufp, numTxFrames);
+}
+
+unsigned int SpiHw_WriteReadPoll(void *tx_bufp, void *rx_bufp, unsigned int numFrames)
+{
+	/* Check on data size per frame */
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS)
+		return SpiHw_WriteReadPoll16(tx_bufp, rx_bufp, numFrames);
+	else
+		return SpiHw_WriteReadPoll8(tx_bufp, rx_bufp, numFrames);
+}
+
+unsigned int SpiHw_ReadFifo(void *rx_bufp, unsigned int numFrames)
+{
+	/* Check on data size per frame */
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS)
+		return SpiHw_ReadFifo16(rx_bufp, numFrames);
+	else
+		return SpiHw_ReadFifo8(rx_bufp, numFrames);
+}
+
+unsigned int SpiHw_WriteFifo(void *tx_bufp, unsigned int numFrames)
+{
+	/* Check on data size per frame */
+	if (SpiHw_GetFrameSize() > SPIHW_8BITS)
+		return SpiHw_WriteFifo16(tx_bufp, numFrames);
+	else
+		return SpiHw_WriteFifo8(tx_bufp, numFrames);
+}
+#endif
+
+int SpiHw_SetBitRate(unsigned int bitRate)
+{
+	uint32_t clockFreq;
+	uint16_t target;
+	uint16_t approxTarget = SPIHW_BR_TARGET_MAX;
+	uint16_t trialVal = 0;
+
+	int approxScr = 0;
+	int approxDvsr = SPIHW_BR_TARGET_MIN;
+	int scr, dvsr;
+
+#if defined(BOOT0_BUILD)
+	/* No query function to save code space.  Assume default clock frequency set */
+	clockFreq = DEFAULT_SPI_CLK_FREQ;
+#else
+	/* Query for base clock frequency */
+	clockFreq = chipcHw_getClockFrequency(chipcHw_CLOCK_SPI);
+#endif
+
+	/* Round up if we have remainder.
+	 * This will ensure bitrate calculated does not exceed requested value.
+	 */
+	target = clockFreq / (bitRate + ((clockFreq % bitRate) ? 1 : 0));
+
+	/* Overall clock divider must be a minimum of 2 */
+	if (target < SPIHW_BR_TARGET_MIN || target > SPIHW_BR_TARGET_MAX) {
+		/* Set to max bitrate if target too great. Min bitrate if target too small */
+		if (target > SPIHW_BR_TARGET_MAX) {
+			SpiHw_SetCPS_DVSR(SPIHW_DVSR_MIN);
+			SpiHw_SetSCR(SPIHW_SCR_MIN);
+		} else {
+			SpiHw_SetCPS_DVSR(SPIHW_DVSR_MAX);
+			SpiHw_SetSCR(SPIHW_SCR_MAX);
+		}
+		return 0;
+	}
+
+	for (scr = 0; scr <= SPIHW_SCR_MAX; scr++) {
+		/* Clock divisor value must always be even */
+		for (dvsr = SPIHW_BR_DVSR_START; dvsr <= SPIHW_DVSR_MAX; dvsr += SPIHW_BR_DVSR_INCR) {
+			trialVal = ((1 + scr) * dvsr);
+
+			/* Search for target.  If greater than target and less than last
+			 * saved approx target, save as new approx target
+			 */
+			if (trialVal == target) {
+				/* Found value, set registers and return success*/
+				SpiHw_SetSCR(scr);
+				SpiHw_SetCPS_DVSR(dvsr);
+				return 0;
+			} else if (trialVal > target) {
+				if (trialVal < approxTarget) {
+					/* Store closest approx target without going under*/
+					approxTarget = trialVal;
+					approxScr = scr;
+					approxDvsr = dvsr;
+				}
+				break;	/*Break here as more iterations will move further from target */
+			}
+		}
+	}
+
+	/* We have not found a match at this point.  We use our approx target here */
+	SpiHw_SetSCR(approxScr);
+	SpiHw_SetCPS_DVSR(approxDvsr);
+	return 0;
+}
+EXPORT_SYMBOL(SpiHw_SetBitRate);
+
+#if !defined(BOOT0_BUILD)
+uint32_t SpiHw_GetBitRate(void)
+{
+	/* Check if divisor was set to min value of 2 */
+	if (SpiHw_GetCPS_DVSR() != 0)
+		return chipcHw_getClockFrequency(chipcHw_CLOCK_SPI) / ((1 + SpiHw_GetSCR()) * SpiHw_GetCPS_DVSR());
+	else
+		return chipcHw_getClockFrequency(chipcHw_CLOCK_SPI) / 2;
+}
+#endif
+
diff --git a/arch/arm/mach-bcmring/dma_device.c b/arch/arm/mach-bcmring/dma_device.c
index ca0ad73..9db0fc5 100644
--- a/arch/arm/mach-bcmring/dma_device.c
+++ b/arch/arm/mach-bcmring/dma_device.c
@@ -48,6 +48,53 @@ DMA_DeviceAttribute_t DMA_gDeviceAttribute[DMA_NUM_DEVICE_ENTRIES] = {
 	 .dedicatedChannel = 0,
 	 /* reserve DMA0:0 for VPM */
 	 },
+	[DMA_DEVICE_SPIH_MEM_TO_DEV] = /* SPI TX */
+	{
+	 .flags = DMA_DEVICE_FLAG_ON_DMA0 | DMA_DEVICE_FLAG_ON_DMA1 | DMA_DEVICE_FLAG_ALLOC_DMA1_FIRST,
+	 .name = "spi_tx",
+	 .config = {
+		    .srcPeripheralPort          = 0, /* SRC: memory */
+		    .dstPeripheralPort          = 9, /* DST: SPIH */
+		    .srcStatusRegisterAddress   = 0x00000000,
+		    .dstStatusRegisterAddress   = 0x00000000,
+		    .srcUpdate                  = dmacHw_SRC_ADDRESS_UPDATE_MODE_INC,
+		    .dstUpdate                  = dmacHw_DST_ADDRESS_UPDATE_MODE_INC,
+		    .transferType               = dmacHw_TRANSFER_TYPE_MEM_TO_PERIPHERAL,
+		    .srcMasterInterface         = dmacHw_SRC_MASTER_INTERFACE_1,
+		    .dstMasterInterface         = dmacHw_DST_MASTER_INTERFACE_1,
+		    .completeTransferInterrupt  = dmacHw_INTERRUPT_ENABLE,
+		    .errorInterrupt             = dmacHw_INTERRUPT_ENABLE,
+		    .channelPriority            = dmacHw_CHANNEL_PRIORITY_6,
+		    .srcMaxTransactionWidth     = dmacHw_SRC_TRANSACTION_WIDTH_16,
+		    .dstMaxTransactionWidth     = dmacHw_DST_TRANSACTION_WIDTH_16,
+		    .srcMaxBurstWidth           = dmacHw_SRC_BURST_WIDTH_4,
+		    .dstMaxBurstWidth           = dmacHw_DST_BURST_WIDTH_4,
+		},
+	},
+
+	[DMA_DEVICE_SPIH_DEV_TO_MEM] = /* SPI RX */
+	{
+	 .flags = DMA_DEVICE_FLAG_ON_DMA0 | DMA_DEVICE_FLAG_ON_DMA1 | DMA_DEVICE_FLAG_ALLOC_DMA1_FIRST,
+	 .name = "spi_rx",
+	 .config = {
+	 	    .srcPeripheralPort          = 8, /* SRC: SPIH */
+	 	    .dstPeripheralPort          = 0, /* DST: memory */
+	 	    .srcStatusRegisterAddress   = 0x00000000,
+	 	    .dstStatusRegisterAddress   = 0x00000000,
+	 	    .srcUpdate                  = dmacHw_SRC_ADDRESS_UPDATE_MODE_INC,
+	 	    .dstUpdate                  = dmacHw_DST_ADDRESS_UPDATE_MODE_INC,
+	 	    .transferType               = dmacHw_TRANSFER_TYPE_PERIPHERAL_TO_MEM,
+	 	    .srcMasterInterface         = dmacHw_SRC_MASTER_INTERFACE_1,
+	 	    .dstMasterInterface         = dmacHw_DST_MASTER_INTERFACE_1,
+	 	    .completeTransferInterrupt  = dmacHw_INTERRUPT_ENABLE,
+	 	    .errorInterrupt             = dmacHw_INTERRUPT_ENABLE,
+	 	    .channelPriority            = dmacHw_CHANNEL_PRIORITY_6,
+	 	    .srcMaxTransactionWidth     = dmacHw_SRC_TRANSACTION_WIDTH_16,
+	 	    .dstMaxTransactionWidth     = dmacHw_DST_TRANSACTION_WIDTH_16,
+	 	    .srcMaxBurstWidth           = dmacHw_SRC_BURST_WIDTH_4,
+	 	    .dstMaxBurstWidth           = dmacHw_DST_BURST_WIDTH_4,
+	 	},
+	 },
 	[DMA_DEVICE_NAND_MEM_TO_MEM] =	/* NAND */
 	{
 	 .flags = DMA_DEVICE_FLAG_ON_DMA0 | DMA_DEVICE_FLAG_ON_DMA1,
diff --git a/arch/arm/mach-bcmring/include/csp/spiHw.h b/arch/arm/mach-bcmring/include/csp/spiHw.h
new file mode 100644
index 0000000..6e3f013
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/spiHw.h
@@ -0,0 +1,692 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    spihHw.h
+*
+*  @brief   API definitions for low level spi host device driver
+*
+*/
+/****************************************************************************/
+
+#ifndef SPIHW_H
+#define SPIHW_H
+
+/* ---- Include Files ----------------------------------------------------- */
+/* ---- Public Constants and Types ---------------------------------------- */
+
+typedef enum {
+	SPIHW_CLKPHASE_FIRSTEDGE = 0,
+	SPIHW_CLKPHASE_SECONDEDGE
+} SPIHW_CLKPHASE;
+
+typedef enum {
+	SPIHW_CLKPOLARITY_LOWIDLE = 0,
+	SPIHW_CLKPOLARITY_HIGHIDLE
+} SPIHW_CLKPOLARITY;
+
+typedef enum {
+	SPIHW_FRMFORMAT_MOT_SPI = 0,
+	SPIHW_FRMFORMAT_NAT_MW,
+	SPIHW_FRMFORMAT_TI_SYNCH
+} SPIHW_FRMFORMAT;
+
+#if !defined(BOOT0_BUILD)
+typedef int (*SPIHW_TRANSFERSTART_FUNCPTR)(uint8_t csNum);
+typedef int (*SPIHW_TRANSFERSTOP_FUNCPTR)(uint8_t csNum);
+
+typedef struct {
+	SPIHW_TRANSFERSTART_FUNCPTR startTransfer;
+	SPIHW_TRANSFERSTOP_FUNCPTR stopTransfer;
+} SPIHW_TRANSFER_FNCS;
+#endif
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_Init
+*
+*  Initialize the SPI host interface.  Will setup in master interface mode
+*  and use Motorola SPI protocol.  Requires function pointers to be setup for
+*  hardware control of start and stop of transfer.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+#if !defined(BOOT0_BUILD)
+int SpiHw_Init
+(
+	SPIHW_TRANSFER_FNCS *spiHw_fncp   /* [IN]   Function pointers */
+);
+#else
+int SpiHw_Init(void);
+#endif
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_Exit
+*
+*  Powers down the SPI block
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int SpiHw_Exit(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetChipSelect
+*
+*  Set the chip select value
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int SpiHw_SetChipSelect
+(
+   uint8_t csNum   /* [IN]   Chip select value */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetChipSelect
+*
+*  Set the chip select value
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int SpiHw_GetChipSelect(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetFrameFormat
+*
+*  Setup to use specified frame format protocol.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_SetFrameFormat
+(
+   SPIHW_FRMFORMAT format   /* [IN]   Frame size format */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetFrameFormat
+*
+*  Get current specified frame format protocol.
+*
+*  @return
+*     Return frame format of type SPIHW_FRMFORMAT
+*/
+/****************************************************************************/
+
+static inline SPIHW_FRMFORMAT SpiHw_GetFrameFormat(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_Enable
+*
+*  Enable the SPI host device.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_Enable(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_Disable
+*
+*  Enable/disable the SPI host device.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_Disable(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsEnabled
+*
+*  Queries enable/disable status of the SPI host device.
+*
+*  @return
+*     Returns 1 if enabled, 0 if disabled
+*/
+/****************************************************************************/
+static inline int SpiHw_IsEnabled(void);
+
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_EnableTxDMA
+*
+*  Enable the DMA transmit block.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_EnableTxDMA(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_DisableTxDMA
+*
+*  Disable the DMA transmit block.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_DisableTxDMA(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_DisableRxDMA
+*
+*  Enable the DMA recieve block
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_EnableRxDMA(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_DisableRxDMA
+*
+*  Disable the DMA recieve block
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_DisableRxDMA(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_FifoAddr
+*
+*  Provides address of rx/tx FIFO data register
+*
+*  Note: Control of start/stop transfer is required when invoking i/o directly
+*  to the FIFO address
+*
+*  @return
+*     Returns address of receive and transmit FIFO data register
+*/
+/****************************************************************************/
+static inline uint32_t *SpiHw_FifoAddr(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_DmaFifoAddr
+*
+*  Provides start address of rx/tx FIFO data register through FIFO.  Allows
+*  for maximum of 128 16-bit frames to be transferred.
+*
+*  @return
+*     Returns address of receive and transmit FIFO data register for DMA
+*/
+/****************************************************************************/
+static inline uint32_t *SpiHw_DmaFifoAddr(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_ReadPoll
+*
+*  Read a given amount of frames.  Will write the value 0 in the
+*  amount of frames requested to be read.  If data size per frame is 8 bits
+*  or less, will store in rx_buf as 8 bit values.  If size is greater than 8 bits,
+*  will store in rx_buf as 16 bit values.
+*
+*  Operation will busy wait for transaction to complete
+*
+*  @return
+*     Number of frames read
+*/
+/****************************************************************************/
+unsigned int SpiHw_ReadPoll
+(
+   void *rx_bufp,              /* [IN]   Receive buffer.  See notes above for packing details */
+   unsigned int numFrames      /* [IN]   Amount of frames to be read */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_WritePoll
+*
+*  Write a given amount of frames.  Will empty the receive FIFO and toss
+*  read data.  If data size per frame is 8 bits or less, the given data
+*  is expected to be formatted in values of 8 bits.  If greater than 8 bits,
+*  expected to be formatted in values of 16 bits.
+*
+*  Operation will busy wait for transaction to complete
+*
+*  @return
+*     Number of frames written
+*/
+/****************************************************************************/
+unsigned int SpiHw_WritePoll
+(
+   void *tx_bufp,              /* [IN]   Transmit buffer.  See notes above for packing details */
+   unsigned int numFrames      /* [IN]   Amount of frames to write. */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_ReadPoll
+*
+*  Begin with writing a cmd the size of the given amount of frames.
+*  After, read a given amount of frames.  Will write the value 0 in the
+*  amount of frames requested to be read.  If data size per frame is 8 bits
+*  or less, will store in rx_buf as 8 bit values.  If size is greater than 8 bits,
+*  will store in rx_buf as 16 bit values.
+*
+*  Operation will busy wait for transaction to complete
+*
+*  @return
+*     Number of frames read
+*/
+/****************************************************************************/
+unsigned int SpiHw_ReadCmdDataPoll
+(
+   void *cmd_bufp,             /* [IN]   cmd buffer.  See notes above for packing details */
+   unsigned int numCmdFrames,  /* [IN]   Amount of cmd frames to write */
+   void *rx_bufp,              /* [IN]   Receive buffer.  See notes above for packing details */
+   unsigned int numRxFrames    /* [IN]   Amount of rx frames to be read */
+);
+
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_WriteCmdDataPoll
+*
+*  Begin with writing a cmd the size of the given amount of frames.
+*  After, write a given amount of frames.  Will empty the receive FIFO and toss
+*  read data.  If data size per frame is 8 bits or less, the given data
+*  is expected to be formatted in values of 8 bits.  If greater than 8 bits,
+*  expected to be formatted in values of 16 bits.
+*
+*  Operation will busy wait for transaction to complete
+*
+*  @return
+*     Number of frames written
+*/
+/****************************************************************************/
+unsigned int SpiHw_WriteCmdDataPoll
+(
+   void *cmd_bufp,             /* [IN]   Command buffer.  See notes above for packing details */
+   unsigned int numCmdFrames,  /* [IN]   Amount of command frames to read. */
+   void *tx_bufp,              /* [IN]   Transmit buffer.  See notes above for packing details */
+   unsigned int numTxFrames    /* [IN]   Amount of transmit frames to read. */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_WriteReadPoll
+*
+*  Write and read a given amount of frames.
+*  If data size per frame is 8 bits or less, the given data
+*  is expected to be formatted in values of 8 bits.  If greater than 8 bits,
+*  expected to be formatted in values of 16 bits.
+*
+*  Operation will busy wait for transaction to complete
+*
+*  @return
+*     Number of frames read
+*/
+/****************************************************************************/
+unsigned int SpiHw_WriteReadPoll
+(
+   void *tx_bufp,           /* [IN]   Transmit buffer.  See notes above for packing details */
+   void *rx_bufp,           /* [IN]   Receive buffer.  See notes above for packing details */
+   unsigned int numFrames   /* [IN]   Amount of frames to read and write. */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_ReadFifo
+*
+*  Read directly from the RX FIFO.
+*  If data size per frame is 8 bits or less, the given data
+*  is expected to be formatted in values of 8 bits.  If greater than 8 bits,
+*  expected to be formatted in values of 16 bits.
+*
+*  Note: Control of start/stop transfer is expected to be outside of this function
+*
+*  @return
+*     Number of frames read.  Possibly less than value specified if FIFO
+*     is empty.
+*/
+/****************************************************************************/
+unsigned int SpiHw_ReadFifo
+(
+   void *rx_bufp,           /* [IN] Recieve buffer.  See notes above for packing details */
+   unsigned int numFrames   /* [IN] Amount of frames to read */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_WriteFifo
+*
+*  Write directly from the TX FIFO.
+*  If data size per frame is 8 bits or less, the given data
+*  is expected to be formatted in values of 8 bits.  If greater than 8 bits,
+*  expected to be formatted in values of 16 bits.
+*
+*  Note: Control of start/stop transfer is expected to be outside of this function
+*
+*  @return
+*     Number of frames written.  Possibly less than value specified if
+*     FIFO is full.
+*/
+/****************************************************************************/
+unsigned int SpiHw_WriteFifo
+(
+   void *tx_bufp,           /* [IN] Transmit buffer.  See notes above for packing details */
+   unsigned int numFrames   /* [IN] Amount of frames to write */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetBitRate
+*
+*  Set the bit rate as desired.
+*  Overall bit rate is calculated as follows:
+*
+*  Bit rate = Frequency of SSP clock / ((1 + SCR) * CPS_DVSR)
+*
+*  @return
+*     Returns 0 if successful else error code
+*/
+/****************************************************************************/
+int SpiHw_SetBitRate
+(
+   unsigned int bitRate        /* [IN] Bit rate desired (bps) */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetBitRate
+*
+*  Get the current bit rate
+*  Overall bit rate is calculated as follows:
+*
+*  Bit rate = Frequency of SSP clock / ((1 + SCR) * CPS_DVSR)
+*
+*  @return
+*     Returns the current bit rate set
+*/
+/****************************************************************************/
+uint32_t SpiHw_GetBitRate(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetClkPhase
+*
+*  Set the clock out phase.  Setting to 1 selects to capture the data on the
+*  second clock edge transition.  Setting to 0 selects to capture the data
+*  on the first clock edge transition.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_SetClkPhase
+(
+   SPIHW_CLKPHASE phase      /* [IN]   Clock out phase setting */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetClkPhase
+*
+*  Get the current clock out phase.
+*
+*  @return
+*     Returns current clock out phase value
+*/
+/****************************************************************************/
+static inline SPIHW_CLKPHASE SpiHw_GetClkPhase(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetClkPolarity
+*
+*  Set the clock out polarity.  Setting to 1 selects a HIGH idle state.
+*  Setting to 0 selects a LOW idle state.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_SetClkPolarity
+(
+   SPIHW_CLKPOLARITY polarity      /* [IN]   Clock out polarity setting */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetClkPolarity
+*
+*  Get the current clock out polarity.
+*
+*  @return
+*     Returns the clock out polarity value.
+*/
+/****************************************************************************/
+static inline SPIHW_CLKPOLARITY SpiHw_GetClkPolarity(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_SetFrameSize
+*
+*  Sets the data size per frame.  Valid values are between 4 and 16 bits
+*
+*  @return
+*     Returns 0 if successful else error code
+*/
+/****************************************************************************/
+static inline int SpiHw_SetFrameSize
+(
+   unsigned int frameSize   /* [IN]   Data size per frame in bits */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetFrameSize
+*
+*  Retrieves the data size per frame.  Valid values are between 4 and 16 bits
+*
+*  @return
+*     Size of data per frame in bits
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_GetFrameSize(void);
+
+/****************************************************************************/
+/*
+*  @brief   SpiHw_LoopBackModeEnable
+*
+*  Enables loopback mode. Intended for testing/debugging puposes
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_LoopBackModeEnable(void);
+
+/****************************************************************************/
+/*
+*  @brief   SpiHw_LoopBackModeDisable
+*
+*  Disables loopback mode. Intended for testing/debugging puposes
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_LoopBackModeDisable(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsBusy
+*
+*  Queries the status flag to check if block is currently transmitting/receiving
+*  a frame.
+*
+*  @return
+*     Returns 1 if busy, else 0
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_IsBusy(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsRxFull
+*
+*  Queries the status flag to check if the RX FIFO is full.
+*
+*  @return
+*     Returns 1 if full, else 0
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_IsRxFull(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsRxNotEmpty
+*
+*  Queries the status flag to check if the RX FIFO is not empty
+*
+*  @return
+*     Returns 1 if not empty, 0 if full.
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_IsRxNotEmpty(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsTxNotFull
+*
+*  Queries the status flag to check if the RX FIFO is not empty
+*
+*  @return
+*     Returns 1 if not empty, 0 if full.
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_IsTxNotFull(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IsTxEmpty
+*
+*  Queries the status flag to check if the TX FIFO is empty
+*
+*  @return
+*     Returns 1 if not empty, 0 if full.
+*/
+/****************************************************************************/
+static inline unsigned int SpiHw_IsTxEmpty(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IntrEnable
+*
+*  Enables the specified interrupts based on the irqMask
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_IntrEnable
+(
+   uint8_t irqMask  /* [IN]   IRQ mask.  Raised bits indicate which interrupts enabled */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IntrEnable
+*
+*  Disables the specified interrupts based on the irqMask
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_IntrDisable
+(
+   uint8_t irqMask  /* [IN]   IRQ mask.  Raised bits indicate which interrupts disabled */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_IntrClear
+*
+*  Clears the specified interrupts based on the irqMask.  TX/RX FIFO interrupts
+*  cannot be cleared as it is based on the status of the level in the FIFO and
+*  clears itself depending on conditions.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int SpiHw_IntrClear
+(
+   uint8_t irqMask  /* [IN]   IRQ mask.  Raised bits indicate which interrupts cleared */
+);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetRawIntrStatus
+*
+*  Retrieves the raw status of the interrupt.
+*
+*  @return
+*     Returns the raw status 8 bit register of the interrupts.
+*/
+/****************************************************************************/
+static inline uint8_t SpiHw_GetRawIntrStatus(void);
+
+/****************************************************************************/
+/**
+*  @brief   SpiHw_GetMaskIntrStatus
+*
+*  Retrieves the masked status of the interrupt.
+*
+*  @return
+*     Returns the masked status 8 bit register of the interrupts.
+*/
+/****************************************************************************/
+static inline uint8_t SpiHw_GetMaskIntrStatus(void);
+
+#include <mach/csp/spiHw_inline.h>
+
+#endif /* SPIHW_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/spiHw_inline.h b/arch/arm/mach-bcmring/include/mach/csp/spiHw_inline.h
new file mode 100644
index 0000000..13934c1
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/spiHw_inline.h
@@ -0,0 +1,210 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+#ifndef SPIHW_INLINE_H
+#define SPIHW_INLINE_H
+
+#ifndef SPIHW_H
+#error *** Do not include spiHw_inline.h directly. Use spiHw.h instead. ***
+#endif
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <mach/csp/mm_io.h>
+#include <mach/csp/spiHw_reg.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+
+static inline int SpiHw_SetFrameFormat(SPIHW_FRMFORMAT format)
+{
+	SPIHW_REG_SET_SSPCR0_FRF(&spiHwRegp->sspcr0, format);
+	return 0;
+}
+
+static inline SPIHW_FRMFORMAT SpiHw_GetFrameFormat(void)
+{
+	return SPIHW_REG_GET_SSPCR0_FRF(&spiHwRegp->sspcr0);
+}
+
+static inline int SpiHw_Enable(void)
+{
+	reg8_set_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_SSE);
+	return 0;
+}
+
+static inline int SpiHw_Disable(void)
+{
+	reg8_clear_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_SSE);
+	return 0;
+}
+
+static inline int SpiHw_IsEnabled(void)
+{
+	return (reg8_read(&spiHwRegp->sspcr1) & SPIHW_REG_SSPCR1_SSE) ? 1 : 0;
+}
+
+static inline int SpiHw_EnableTxDMA(void)
+{
+	reg8_set_bits(&spiHwRegp->sspdmacr, SPIHW_REG_SSPDMACR_TXDMAE);
+	return 0;
+}
+
+static inline int SpiHw_DisableTxDMA(void)
+{
+	reg8_clear_bits(&spiHwRegp->sspdmacr, SPIHW_REG_SSPDMACR_TXDMAE);
+	return 0;
+}
+
+static inline int SpiHw_EnableRxDMA(void)
+{
+	reg8_set_bits(&spiHwRegp->sspdmacr, SPIHW_REG_SSPDMACR_RXDMAE);
+	return 0;
+}
+
+static inline int SpiHw_DisableRxDMA(void)
+{
+	reg8_clear_bits(&spiHwRegp->sspdmacr, SPIHW_REG_SSPDMACR_RXDMAE);
+	return 0;
+}
+
+static inline uint32_t *SpiHw_FifoAddr(void)
+{
+	return (uint32_t *)&spiHwRegp->sspdr;
+}
+
+static inline uint32_t *SpiHw_DmaFifoAddr(void)
+{
+	return (uint32_t *)&spiHwRegp->sspdmafifo;
+}
+
+static inline int SpiHw_SetClkPhase(SPIHW_CLKPHASE phase)
+{
+	if (phase == SPIHW_CLKPHASE_SECONDEDGE)
+		reg16_set_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCRO_SPH);
+	else
+		reg16_clear_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCRO_SPH);
+	return 0;
+}
+
+static inline SPIHW_CLKPHASE SpiHw_GetClkPhase(void)
+{
+	return (reg16_read(&spiHwRegp->sspcr0) & SPIHW_REG_SSPCRO_SPH) ? SPIHW_CLKPHASE_SECONDEDGE : SPIHW_CLKPHASE_FIRSTEDGE;
+}
+
+static inline int SpiHw_SetClkPolarity(SPIHW_CLKPOLARITY polarity)
+{
+	if (polarity == SPIHW_CLKPOLARITY_HIGHIDLE)
+		reg16_set_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCR0_SPO);
+	else
+		reg16_clear_bits(&spiHwRegp->sspcr0, SPIHW_REG_SSPCR0_SPO);
+	return 0;
+}
+
+static inline SPIHW_CLKPOLARITY SpiHw_GetClkPolarity(void)
+{
+	return (reg16_read(&spiHwRegp->sspcr0) & SPIHW_REG_SSPCR0_SPO) ? SPIHW_CLKPOLARITY_HIGHIDLE : SPIHW_CLKPOLARITY_LOWIDLE;
+}
+
+static inline int SpiHw_SetFrameSize(unsigned int frameSize)
+{
+	frameSize -= 1;
+	SPIHW_REG_SET_SSPCR0_DSS(&spiHwRegp->sspcr0, frameSize);
+	return 0;
+}
+
+static inline unsigned int SpiHw_GetFrameSize(void)
+{
+	int frameSize = reg16_read(&spiHwRegp->sspcr0) & 0xF;
+	return frameSize + 1;
+}
+
+static inline int SpiHw_LoopBackModeEnable(void)
+{
+	reg8_set_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_LBM);
+	return 0;
+}
+
+static inline int SpiHw_LoopBackModeDisable(void)
+{
+	reg8_clear_bits(&spiHwRegp->sspcr1, SPIHW_REG_SSPCR1_LBM);
+	return 0;
+}
+
+static inline unsigned int SpiHw_IsBusy(void)
+{
+	return reg8_read(&spiHwRegp->sspsr) & SPIHW_REG_SSPSR_BSY;
+}
+
+static inline unsigned int SpiHw_IsRxFull(void)
+{
+	return reg8_read(&spiHwRegp->sspsr) & SPIHW_REG_SSPSR_RFF;
+}
+
+static inline unsigned int SpiHw_IsRxNotEmpty(void)
+{
+	return reg8_read(&spiHwRegp->sspsr) & SPIHW_REG_SSPSR_RNE;
+}
+
+static inline unsigned int SpiHw_IsTxNotFull(void)
+{
+	return reg8_read(&spiHwRegp->sspsr) & SPIHW_REG_SSPSR_TNF;
+}
+
+static inline unsigned int SpiHw_IsTxEmpty(void)
+{
+	return reg8_read(&spiHwRegp->sspsr) & SPIHW_REG_SSPSR_TFE;
+}
+
+static inline int SpiHw_IntrEnable(uint8_t irqMask)
+{
+	/* Only lower 4 bits available */
+	irqMask &= 0xF;
+
+	reg8_set_bits(&spiHwRegp->sspimsc, irqMask);
+	return 0;
+}
+
+static inline int SpiHw_IntrDisable(uint8_t irqMask)
+{
+	/* Only lower 4 bits available */
+	irqMask &= 0xF;
+
+	reg8_clear_bits(&spiHwRegp->sspimsc, irqMask);
+	return 0;
+}
+
+static inline int SpiHw_IntrClear(uint8_t irqMask)
+{
+	/* Only lower 2 bits available */
+	irqMask &= 0x3;
+
+	reg8_write(&spiHwRegp->sspicr, irqMask);
+	return 0;
+}
+
+static inline uint8_t SpiHw_GetRawIntrStatus(void)
+{
+	return reg8_read(&spiHwRegp->sspris);
+}
+
+static inline uint8_t SpiHw_GetMaskIntrStatus(void)
+{
+	return reg8_read(&spiHwRegp->sspmis);
+}
+
+#endif /* SPIHW_INLINE_H */
+
diff --git a/arch/arm/mach-bcmring/include/mach/csp/spiHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/spiHw_reg.h
new file mode 100644
index 0000000..1ad35d8
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/spiHw_reg.h
@@ -0,0 +1,117 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    spiHw_reg.h
+*
+*  @brief   SPI host register definitions
+*
+*/
+/****************************************************************************/
+
+#ifndef BCMRING_SPIHW_REG_H
+#define BCMRING_SPIHW_REG_H
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/reg.h>
+#include <mach/gpio_defs.h>
+/* ---- Public Constants and Types ---------------------------------------- */
+typedef struct {
+	uint16_t sspcr0;
+	uint16_t dummy0;
+	uint8_t  sspcr1;
+	uint8_t  dummy1[3];
+	uint16_t sspdr;
+	uint16_t dummy2;
+	uint8_t  sspsr;
+	uint8_t  dummy3[3];
+	uint8_t  sspcpsr;
+	uint8_t  dummy4[3];
+	uint8_t  sspimsc;
+	uint8_t  dummy5[3];
+	uint8_t  sspris;
+	uint8_t  dummy6[3];
+	uint8_t  sspmis;
+	uint8_t  dummy7[3];
+	uint8_t  sspicr;
+	uint8_t  dummy8[3];
+	uint8_t  sspdmacr;
+	uint8_t  dummy9[3];
+	uint32_t dummy10[54];
+	uint32_t sspdmafifo;
+} SPIHW_REG_t;
+
+/* Frame formats */
+#define  SPIHW_FRF_MOTOROLA_SPI  	0
+#define  SPIHW_FRF_TI_SYNCH		1
+#define  SPIHW_FRF_NAT_MW		2
+
+
+/* Interrupt mask/status/clear register defines */
+#define  SPIHW_REG_INTR_ROR		(1 << 0)
+#define  SPIHW_REG_INTR_RT		(1 << 1)
+#define  SPIHW_REG_INTR_RX		(1 << 2)
+#define  SPIHW_REG_INTR_TX		(1 << 3)
+
+
+#define  SPIHW_BASE			MM_IO_BASE_SPIH
+
+#define  spiHwRegp			((volatile SPIHW_REG_t *) SPIHW_BASE)
+
+#define  SPIHW_REG_FIFO_DEPTH		8
+
+#define  SPIHW_REG_SET_SSPCR0_DSS(cr0, dss)	reg16_write_masked(cr0, (0xF << 0), ((dss & 0xF) << 0))
+#define  SPIHW_REG_SET_SSPCR0_FRF(cr0, frf)	reg16_write_masked(cr0, (0x3 << 4), ((frf & 0x3) << 4))
+#define  SPIHW_REG_GET_SSPCR0_FRF(cr0)		((reg16_read(cr0) >> 4) & 0x3)
+
+#define  SPIHW_REG_SET_SSPCR0_SCR(cr0, scr)	reg16_write_masked(cr0, (0xFF << 8), ((scr & 0xFF) << 8))
+#define  SPIHW_REG_GET_SSPCR0_SCR(cr0)		((reg16_read(cr0) >> 8) & 0xFF)
+
+#define  SPIHW_REG_SSPCR0_SPO		(1 << 6)
+#define  SPIHW_REG_SSPCRO_SPH		(1 << 7)
+
+#define  SPIHW_REG_SSPCR1_LBM		(1 << 0)
+#define  SPIHW_REG_SSPCR1_SSE		(1 << 1)
+#define  SPIHW_REG_SSPCR1_MS		(1 << 2)
+#define  SPIHW_REG_SSPCR1_SOD		(1 << 3)
+
+#define  SPIHW_REG_SSPSR_TFE		(1 << 0)
+#define  SPIHW_REG_SSPSR_TNF		(1 << 1)
+#define  SPIHW_REG_SSPSR_RNE		(1 << 2)
+#define  SPIHW_REG_SSPSR_RFF		(1 << 3)
+#define  SPIHW_REG_SSPSR_BSY		(1 << 4)
+
+#define  SPIHW_REG_SSPCPSR(cpsr)	(cpsr & 0xFF)
+
+#define  SPIHW_REG_SSPDMACR_RXDMAE	(1 << 0)
+#define  SPIHW_REG_SSPDMACR_TXDMAE	(1 << 1)
+
+#define SPIHW_CS0_GPIOPIN  GPIO25_SPI_SS0_B
+#define SPIHW_CS1_GPIOPIN  GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25
+#define SPIHW_CS2_GPIOPIN  GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24
+
+#define SPIHW_MISO_GPIOPIN GPIO22_SPI_MISO
+#define SPIHW_CLK_GPIOPIN  GPIO23_SPI_CLK
+#define SPIHW_MOSI_GPIOPIN GPIO24_SPI_MOSI
+
+/* ---- Public Variables -------------------------------------------------- */
+/* ---- Public Function Prototypes ---------------------------------------- */
+
+
+
+#endif /* BCMRING_SPIHW_REG_H */
diff --git a/arch/arm/mach-bcmring/include/mach/spih.h b/arch/arm/mach-bcmring/include/mach/spih.h
new file mode 100644
index 0000000..fa3b94c
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/spih.h
@@ -0,0 +1,38 @@
+/*
+ * Broadcom SPI Host Header
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef SPIH_H_
+#define SPIH_H_
+
+#define BCMRING_CS_ASSERT (0x01)
+#define BCMRING_CS_DEASSERT (0x02)
+
+/* device.platform_data for SSP controller devices */
+struct bcmring_spi_master {
+	u32 num_chipselect;
+};
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct bcmring_spi_chip {
+	u32 enable_dma;
+	void (*cs_control)(u32 command);
+};
+
+#endif /* SPIH_H_*/
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 1cf0579..a206548 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -181,6 +181,18 @@ config SPI_PXA2XX
 	  The driver can be configured to use any SSP port and additional
 	  documentation can be found a Documentation/spi/pxa2xx.
 
+config SPI_BCMRING
+        tristate "Broadcom SPIH master"
+        depends on SPI_MASTER && ARCH_BCMRING
+        help
+          This enables using the BCMRING SPIH as a SPI master controller.
+
+menuconfig BCM2153_SPI
+  tristate "Broadcom SPI master for BCM2153"
+  depends on SPI_MASTER && ARCH_BCM2153
+  help
+    This enables using BCM2153's SSP core as a SPI master controller
+
 config SPI_S3C24XX
 	tristate "Samsung S3C24XX series SPI"
 	depends on ARCH_S3C2410 && EXPERIMENTAL
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 2a613ac..5fdb1fc 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_SPI_DAVINCI)       += davinci_spi.o
 obj-$(CONFIG_SPI_IMX)			+= spi_imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi_lm70llp.o
 obj-$(CONFIG_SPI_PXA2XX)		+= pxa2xx_spi.o
+obj-$(CONFIG_SPI_BCMRING)              += spi_bcmring.o
 obj-$(CONFIG_SPI_OMAP_UWIRE)		+= omap_uwire.o
 obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
diff --git a/drivers/spi/spi_bcmring.c b/drivers/spi/spi_bcmring.c
new file mode 100644
index 0000000..dfcb616
--- /dev/null
+++ b/drivers/spi/spi_bcmring.c
@@ -0,0 +1,1666 @@
+/*
+ * Broadcom SPI Host controller
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/spi/spi.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/amba/bus.h>
+#include <linux/proc_fs.h>
+#include <linux/completion.h>
+#include <linux/version.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+
+#include <linux/uaccess.h>
+
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <linux/delay.h>
+#include <asm/dma.h>
+#include <mach/dma.h>
+
+#include <mach/gpio_defs.h>
+#include <mach/csp/gpiomux.h>
+
+#include <mach/csp/spiHw_reg.h>
+#include <mach/csp/mm_io.h>
+#include <csp/spiHw.h>
+#include <mach/spih.h>
+
+
+#define SPI_TEST
+
+#define DEFAULT_DELTA       100
+#define DEFAULT_BAUD_RATE   9375000
+#define DEFAULT_FRAME_SIZE  16
+
+/* max number of frames per DMA session */
+#define MAX_DMA_FRAME       128
+#define DMA_BUF_SIZE        (MAX_DMA_FRAME * 2)
+#define MAX_PROC_BUF_SIZE   256
+
+/* TODO: check for SPI DMA alignment */
+#define IS_DMA_ALIGNED(x)   (((u32)(x) & 0x07) == 0)
+
+#define START_STATE         ((void *)0)
+#define RUNNING_STATE       ((void *)1)
+#define DONE_STATE          ((void *)2)
+#define ERROR_STATE         ((void *)-1)
+
+#define QUEUE_RUNNING       0
+#define QUEUE_STOPPED       1
+
+#ifdef SPI_TEST
+struct test_cfg {
+	u32 rate; /* baud rate */
+	atomic_t delta_time; /* time btw transfer in ms */
+	u32 frame_size; /* frame size (bits/frame) */
+	atomic_t enable_dma; /* flag to enable/disable dma */
+	atomic_t start; /* flag to start the dummy test thread */
+
+	long id; /* thread ID */
+	struct completion exit_lock; /* exit sync */
+};
+#endif
+
+struct dma_cfg {
+	struct semaphore tx_lock;
+	struct semaphore rx_lock;
+	DMA_Handle_t tx_handle;
+	DMA_Handle_t rx_handle;
+};
+
+struct driver_data {
+	/* Driver model hookup */
+	struct platform_device *pdev;
+
+	/* SPI framework hookup */
+	struct spi_master *master;
+
+	/* DMA configuration */
+	struct dma_cfg dma_cfg;
+
+	/* dummy DMA buffer */
+	void *dummy_dma_buf;
+	dma_addr_t dummy_dma_addr;
+
+	atomic_t loopback_enable;
+
+	/* Driver message queue */
+	struct workqueue_struct *workqueue;
+	struct work_struct pump_messages;
+	struct list_head queue;
+	int busy;
+	int run;
+
+	/* Current message transfer state info */
+	struct spi_message *cur_msg;
+	struct spi_transfer *cur_transfer;
+	struct chip_data *cur_chip;
+	void *tx;
+	void *rx;
+	dma_addr_t rx_dma;
+	dma_addr_t tx_dma;
+	u32 n_bytes;
+
+#ifdef SPI_TEST
+	struct test_cfg test_cfg;
+#endif
+};
+
+struct chip_data {
+	u32 bits_per_word;
+	u32 speed_hz;
+	u32 enable_dma;
+	void (*cs_control)(u32 command);
+};
+
+struct proc_dirs {
+	struct proc_dir_entry *parent_dir;
+#ifdef SPI_TEST
+	struct proc_dir_entry *test_dir;
+#endif
+};
+
+/*
+ * Function Prototypes
+ */
+static int null_cs_assert(u8 cs_num);
+static int null_cs_deassert(u8 cs_num);
+static inline void dma_tx_transfer_complete(struct dma_cfg *dma);
+static inline void dma_rx_transfer_complete(struct dma_cfg *dma);
+
+static struct semaphore spi_lock;
+static struct clk *spi_clk;
+
+SPIHW_TRANSFER_FNCS cs_ctrl = {&null_cs_assert, &null_cs_deassert};
+
+static struct proc_dirs spi_proc;
+
+static int null_cs_assert(u8 cs_num)
+{
+	return 0;
+}
+
+static int null_cs_deassert(u8 cs_num)
+{
+	return 0;
+}
+
+static int flush(struct driver_data *drv_data)
+{
+	return loops_per_jiffy << 1;
+}
+
+static void cs_control(u32 command)
+{
+}
+
+static void irq_tx_dma(DMA_Device_t dev, int reason, void *data)
+{
+	struct dma_cfg *dma = (struct dma_cfg *)data;
+
+	dma_tx_transfer_complete(dma);
+}
+
+static void irq_rx_dma(DMA_Device_t dev, int reason, void *data)
+{
+	struct dma_cfg *dma = (struct dma_cfg *)data;
+
+	dma_rx_transfer_complete(dma);
+}
+
+static irqreturn_t irq_spi(int irq, void *data)
+{
+	/* struct driver_data *drv_data = (struct driver_data *)data; */
+	u8 irq_status;
+
+	irq_status = SpiHw_GetMaskIntrStatus();
+	SpiHw_IntrClear(irq_status);
+
+	if (irq_status & SPIHW_REG_INTR_RT) {
+		u16 read_buf;
+
+		/* error condition, clean the RX FIFO */
+		while (SpiHw_IsRxNotEmpty()) {
+			SpiHw_ReadFifo(&read_buf, 1);
+			while (SpiHw_IsBusy())
+				;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int dma_txrx_init(struct dma_cfg *dma)
+{
+	int rc;
+
+	/* init locks as LOCKED */
+	init_MUTEX_LOCKED(&dma->tx_lock);
+	init_MUTEX_LOCKED(&dma->rx_lock);
+
+	/* register IRQ handlers */
+	rc = dma_set_device_handler(DMA_DEVICE_SPIH_MEM_TO_DEV, irq_tx_dma, dma);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_init: TX dma_set_device_handler failed "
+				"with status=%d\n", rc);
+		return rc;
+	}
+	rc = dma_set_device_handler(DMA_DEVICE_SPIH_DEV_TO_MEM, irq_rx_dma, dma);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_init: RX dma_set_device_handler failed "
+				"with status=%d\n", rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static inline void dma_txrx_transfer(struct dma_cfg *dma, dma_addr_t tx_dma,
+		dma_addr_t rx_dma, u32 num_bytes, u32 frame_size_bytes)
+{
+	int rc;
+	dma_addr_t spi_dma;
+
+	spi_dma = (dma_addr_t)SpiHw_DmaFifoAddr();
+	spi_dma = MM_IO_VIRT_TO_PHYS(spi_dma);
+
+	if (frame_size_bytes == 1) {
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_MEM_TO_DEV].config.srcMaxTransactionWidth =
+			dmacHw_SRC_TRANSACTION_WIDTH_8;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_DEV_TO_MEM].config.dstMaxTransactionWidth =
+			dmacHw_DST_TRANSACTION_WIDTH_8;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_MEM_TO_DEV].config.dstMaxTransactionWidth =
+			dmacHw_DST_TRANSACTION_WIDTH_8;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_DEV_TO_MEM].config.srcMaxTransactionWidth =
+			dmacHw_SRC_TRANSACTION_WIDTH_8;
+	} else if (frame_size_bytes == 2) {
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_MEM_TO_DEV].config.srcMaxTransactionWidth =
+			dmacHw_SRC_TRANSACTION_WIDTH_16;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_DEV_TO_MEM].config.dstMaxTransactionWidth =
+			dmacHw_DST_TRANSACTION_WIDTH_16;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_MEM_TO_DEV].config.dstMaxTransactionWidth =
+			dmacHw_DST_TRANSACTION_WIDTH_16;
+		DMA_gDeviceAttribute[DMA_DEVICE_SPIH_DEV_TO_MEM].config.srcMaxTransactionWidth =
+			dmacHw_SRC_TRANSACTION_WIDTH_16;
+	} else {
+		printk(KERN_ERR "SPI: Invalid frame size = %u bytes\n",
+				frame_size_bytes);
+		goto dma_end;
+	}
+
+	/* request DMA channels */
+	dma->tx_handle = dma_request_channel(DMA_DEVICE_SPIH_MEM_TO_DEV);
+	if (dma->tx_handle < 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: TX dma_request_channel "
+				"failed\n");
+
+		goto dma_end;
+	}
+	dma->rx_handle = dma_request_channel(DMA_DEVICE_SPIH_DEV_TO_MEM);
+	if (dma->rx_handle < 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: RX dma_request_channel "
+				"failed\n");
+		goto dma_end;
+	}
+
+	/* RX DMA */
+	rc = dma_transfer_from_device(dma->rx_handle,
+			spi_dma, rx_dma, num_bytes);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: RX DMA failed\n");
+		goto dma_end;
+	}
+
+	/* TX DMA */
+	rc = dma_transfer_to_device(dma->tx_handle,
+			tx_dma, spi_dma, num_bytes);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: TX DMA failed\n");
+		goto dma_end;
+	}
+
+	/* wait for TX DMA to complete */
+	down(&dma->tx_lock);
+
+	/* wait for RX DMA to complete */
+	down(&dma->rx_lock);
+
+	rc = dma_free_channel(dma->tx_handle);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: TX dma_free_channel "
+				"failed\n");
+		goto dma_end;
+	}
+
+	rc = dma_free_channel(dma->rx_handle);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: dma_txrx_transfer: RX dma_free_channel "
+				"failed\n");
+		goto dma_end;
+	}
+
+dma_end:
+	return;
+}
+
+static inline void dma_tx_transfer_complete(struct dma_cfg *dma)
+{
+	up(&dma->tx_lock);
+}
+
+static inline void dma_rx_transfer_complete(struct dma_cfg *dma)
+{
+	up(&dma->rx_lock);
+}
+
+/* caller already set message->status; dma and pio irqs are blocked */
+static void giveback(struct driver_data *drv_data)
+{
+	struct spi_transfer *last_transfer;
+	struct spi_message *msg;
+
+	msg = drv_data->cur_msg;
+	drv_data->cur_msg = NULL;
+	drv_data->cur_transfer = NULL;
+	drv_data->cur_chip = NULL;
+	queue_work(drv_data->workqueue, &drv_data->pump_messages);
+
+	last_transfer = list_entry(msg->transfers.prev,
+			struct spi_transfer,
+			transfer_list);
+
+	msg->state = NULL;
+	if (msg->complete)
+		msg->complete(msg->context);
+}
+
+static void *next_transfer(struct driver_data *drv_data)
+{
+	struct spi_message *msg = drv_data->cur_msg;
+	struct spi_transfer *trans = drv_data->cur_transfer;
+
+	/* Move to next transfer */
+	if (trans->transfer_list.next != &msg->transfers) {
+		drv_data->cur_transfer =
+			list_entry(trans->transfer_list.next,
+					struct spi_transfer,
+					transfer_list);
+		return RUNNING_STATE;
+	} else
+		return DONE_STATE;
+}
+
+static int map_dma_buffers(struct driver_data *drv_data, u32 num_bytes,
+		int is_dma_mapped)
+{
+	struct spi_message *msg = drv_data->cur_msg;
+	struct device *dev = &msg->spi->dev;
+
+	if (!IS_DMA_ALIGNED(drv_data->rx) || !IS_DMA_ALIGNED(drv_data->tx)) {
+		printk(KERN_ERR "SPI: map_dma_buffers failed with unaligned DMA "
+				"memory\n");
+		return -EFAULT;
+	}
+
+	/* use dummy DMA buffer if TX buffer is NULL */
+	if (drv_data->tx == NULL) {
+		drv_data->tx = drv_data->dummy_dma_buf;
+		memset(drv_data->tx, 0, num_bytes);
+		dma_sync_single_for_device(dev, drv_data->dummy_dma_addr, num_bytes,
+				DMA_TO_DEVICE);
+		drv_data->tx_dma = dma_map_single(dev, drv_data->tx,
+				num_bytes, DMA_TO_DEVICE);
+	} else if (!is_dma_mapped || drv_data->tx != drv_data->dummy_dma_buf) {
+		/* map the TX buffer */
+		drv_data->tx_dma = dma_map_single(dev, drv_data->tx,
+				num_bytes, DMA_TO_DEVICE);
+
+		if (dma_mapping_error(dev, drv_data->tx_dma)) {
+			printk(KERN_ERR "SPI: dma_map_single failed tx_dma=0x%x\n",
+					drv_data->tx_dma);
+			return -EFAULT;
+		}
+	}
+
+	/* Modify setup if RX buffer is null */
+	if (drv_data->rx == NULL) {
+		drv_data->rx = drv_data->dummy_dma_buf;
+	} else if (!is_dma_mapped || drv_data->rx != drv_data->dummy_dma_buf) {
+		/* map the RX buffer */
+		drv_data->rx_dma = dma_map_single(dev, drv_data->rx, num_bytes,
+				DMA_FROM_DEVICE);
+
+		if (dma_mapping_error(dev, drv_data->rx_dma)) {
+			printk(KERN_ERR "SPI: dma_map_single failed rx_dma=0x%x\n",
+					drv_data->rx_dma);
+			return -EFAULT;
+		}
+	}
+
+	return 0;
+}
+
+static void unmap_dma_buffers(struct driver_data *drv_data, u32 num_bytes,
+		int is_dma_mapped)
+{
+	struct device *dev = &drv_data->cur_msg->spi->dev;
+
+	if (is_dma_mapped)
+		return;
+
+	if (drv_data->tx != drv_data->dummy_dma_buf) {
+		dma_unmap_single(dev, drv_data->tx_dma,
+					num_bytes, DMA_TO_DEVICE);
+	}
+
+	if (drv_data->rx != drv_data->dummy_dma_buf) {
+		dma_unmap_single(dev, drv_data->rx_dma,
+					num_bytes, DMA_FROM_DEVICE);
+	}
+}
+
+static struct spi_transfer *configure_transfer(struct driver_data *drv_data)
+{
+	struct chip_data *chip = drv_data->cur_chip;
+	struct spi_transfer *transfer = drv_data->cur_transfer;
+	int rc;
+
+	u8 bits = 0;
+	u32 speed = 0;
+
+	bits = chip->bits_per_word;
+	speed = chip->speed_hz;
+
+	if (transfer->tx_buf == NULL && transfer->rx_buf == NULL) {
+		printk(KERN_ERR "SPI: configure_transfer failed: Both TX and RX "
+				"buffers point to NULL\n");
+		return NULL;
+	}
+
+	drv_data->tx = (void *)transfer->tx_buf;
+	drv_data->rx = transfer->rx_buf;
+
+	drv_data->tx_dma = transfer->tx_dma;
+	drv_data->rx_dma = transfer->rx_dma;
+
+	if (transfer->bits_per_word)
+		bits = transfer->bits_per_word;
+
+	if (transfer->speed_hz)
+		speed = transfer->speed_hz;
+
+	/* validate and configure frame size */
+	bits = transfer->bits_per_word;
+	if (bits >= 4 && bits <= 8) {
+		drv_data->n_bytes = 1;
+	} else if (bits > 8 && bits <= 16) {
+		drv_data->n_bytes = 2;
+	} else {
+		printk(KERN_ERR "SPI: configure_transfer failed: bits_per_word=%u\n",
+				bits);
+		return NULL;
+	}
+	rc = SpiHw_SetFrameSize(bits);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: configure_transfer failed: SpiHw_SetFrameSize "
+				"failed\n");
+		return NULL;
+	}
+
+	/* configure bit rate */
+	rc = SpiHw_SetBitRate(speed);
+	if (rc != 0) {
+		printk(KERN_ERR "SPI: configure_transfer failed: SpiHw_SetBitRate failed\n");
+		return NULL;;
+	}
+
+	return transfer;
+}
+
+static void pump_transfers(unsigned long data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct spi_message *message = NULL;
+	struct spi_transfer *transfer = NULL;
+	struct spi_transfer *previous = NULL;
+	struct chip_data *chip = NULL;
+
+	/* Get current state information */
+	message = drv_data->cur_msg;
+	transfer = drv_data->cur_transfer;
+	chip = drv_data->cur_chip;
+
+	/* Handle for abort */
+	if (message->state == ERROR_STATE) {
+		goto transfer_fail;
+	}
+
+	/* Handle end of message */
+	if (message->state == DONE_STATE) {
+		goto message_done;
+	}
+
+	/* Delay if requested at end of transfer*/
+	if (message->state == RUNNING_STATE) {
+		previous = list_entry(transfer->transfer_list.prev,
+				struct spi_transfer,
+				transfer_list);
+		if (previous->delay_usecs)
+			udelay(previous->delay_usecs);
+	}
+
+	/* Setup the transfer state based on the type of transfer */
+	if (flush(drv_data) == 0) {
+		goto transfer_fail;
+	}
+
+	if (atomic_read(&drv_data->loopback_enable))
+		SpiHw_LoopBackModeEnable();
+
+	message->state = RUNNING_STATE;
+	chip->cs_control(BCMRING_CS_ASSERT);
+
+	do {
+		unsigned int tot_frames;
+
+		/* set up buffers, frame size, and bit rate for this transfer */
+		transfer = configure_transfer(drv_data);
+
+		if (transfer == NULL) {
+			goto transfer_fail;
+		}
+
+		tot_frames = transfer->len / drv_data->n_bytes;
+
+		if (chip->enable_dma) {
+			unsigned int remain_frames = tot_frames;
+			unsigned int cur_frames = 0;
+
+			SpiHw_EnableTxDMA();
+			SpiHw_EnableRxDMA();
+
+			while (remain_frames > 0) {
+				if (remain_frames > MAX_DMA_FRAME) {
+					cur_frames = MAX_DMA_FRAME;
+					remain_frames -= MAX_DMA_FRAME;
+				} else {
+					cur_frames = remain_frames;
+					remain_frames = 0;
+				}
+
+				if (map_dma_buffers(drv_data, cur_frames * drv_data->n_bytes,
+							message->is_dma_mapped) != 0) {
+						goto transfer_fail;
+				}
+
+				/* start DMA transfer, block until finish */
+				dma_txrx_transfer(&drv_data->dma_cfg, drv_data->tx_dma,
+						drv_data->rx_dma, cur_frames * drv_data->n_bytes,
+						drv_data->n_bytes);
+
+				unmap_dma_buffers(drv_data, cur_frames * drv_data->n_bytes,
+						message->is_dma_mapped);
+
+				if (drv_data->tx != drv_data->dummy_dma_buf) {
+					drv_data->tx = (u8 *)drv_data->tx + cur_frames *
+						drv_data->n_bytes;
+				}
+
+				if (drv_data->rx != drv_data->dummy_dma_buf) {
+					drv_data->rx = (u8 *)drv_data->rx + cur_frames *
+						drv_data->n_bytes;
+				}
+			}
+
+			SpiHw_DisableTxDMA();
+			SpiHw_DisableRxDMA();
+
+		} else { /* NOT using DMA */
+
+			if (transfer->tx_buf == NULL) {
+				tot_frames = SpiHw_ReadPoll(drv_data->rx, tot_frames);
+			} else if (transfer->rx_buf == NULL) {
+				tot_frames = SpiHw_WritePoll(drv_data->tx, tot_frames);
+			} else {
+				tot_frames = SpiHw_WriteReadPoll(drv_data->tx,
+						drv_data->rx, tot_frames);
+			}
+
+			if (tot_frames != transfer->len / drv_data->n_bytes) {
+				printk(KERN_ERR "SPI: transfer error: Frames to be processed = %u "
+						"Frames processed = %u\n",
+						transfer->len / drv_data->n_bytes, tot_frames);
+			}
+		}
+
+		message->actual_length += transfer->len;
+
+	} while ((drv_data->cur_msg->state = next_transfer(drv_data))
+			!= DONE_STATE);
+
+	chip->cs_control(BCMRING_CS_DEASSERT);
+	SpiHw_LoopBackModeDisable();
+
+	goto message_done;
+
+transfer_fail:
+	message->status = -EIO;
+	giveback(drv_data);
+	return;
+
+message_done:
+	message->status = 0;
+	giveback(drv_data);
+	/* go on */
+	return;
+}
+
+static void pump_messages(struct work_struct *work)
+{
+	struct driver_data *drv_data =
+		container_of(work, struct driver_data, pump_messages);
+
+	/* Lock queue and check for queue work */
+	if (list_empty(&drv_data->queue) || drv_data->run == QUEUE_STOPPED) {
+		drv_data->busy = 0;
+		return;
+	}
+
+	/* Make sure we are not already running a message */
+	if (drv_data->cur_msg) {
+		return;
+	}
+
+	down(&spi_lock);
+
+	/* Extract head of queue */
+	drv_data->cur_msg = list_entry(drv_data->queue.next,
+			struct spi_message, queue);
+	list_del_init(&drv_data->cur_msg->queue);
+
+	/* Initial message state*/
+	drv_data->cur_msg->state = START_STATE;
+	drv_data->cur_transfer = list_entry(drv_data->cur_msg->transfers.next,
+			struct spi_transfer,
+			transfer_list);
+
+	/* Setup the SSP using the per chip configuration */
+	drv_data->cur_chip = spi_get_ctldata(drv_data->cur_msg->spi);
+
+	/* Mark as busy and launch transfers */
+	pump_transfers((unsigned long)drv_data);
+
+	drv_data->busy = 1;
+
+	up(&spi_lock);
+}
+
+static int transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
+
+	if (drv_data->run == QUEUE_STOPPED) {
+		return -ESHUTDOWN;
+	}
+
+	msg->actual_length = 0;
+	msg->status = -EINPROGRESS;
+	msg->state = START_STATE;
+
+	list_add_tail(&msg->queue, &drv_data->queue);
+
+	if (drv_data->run == QUEUE_RUNNING && !drv_data->busy)
+		queue_work(drv_data->workqueue, &drv_data->pump_messages);
+
+	return 0;
+}
+
+#define MODEBITS (SPI_MODE_0)
+
+static int setup(struct spi_device *spi)
+{
+	struct driver_data *drv_data = spi_master_get_devdata(spi->master);
+	struct bcmring_spi_chip *chip_info = NULL;
+	struct chip_data *chip;
+	u32 bits;
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	if (spi->mode & ~MODEBITS) {
+		printk(KERN_ERR "SPI: setup failed: unsupported mode bits %x\n",
+				spi->mode & ~MODEBITS);
+		return -EINVAL;
+	}
+
+	/* Only destroy_queue (or use chip_info) on first setup */
+	chip = spi_get_ctldata(spi);
+	if (!chip) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip) {
+			printk(KERN_ERR "SPI: setup failed: can't allocate chip data\n");
+			return -ENOMEM;
+		}
+		/* TODO: cs_control will not work, should default to something */
+		chip->cs_control = cs_control;
+		chip->enable_dma = 0;
+	}
+
+	/*
+	 * Protocol drivers may change the chip settings, so if chip_info exists,
+	 * use it
+	 */
+	chip_info = spi->controller_data;
+
+	if (chip_info) {
+		if (chip_info->cs_control)
+			chip->cs_control = chip_info->cs_control;
+		chip->enable_dma = chip_info->enable_dma;
+	}
+
+	chip->speed_hz = spi->max_speed_hz;
+
+	/* validate and configure frame size */
+	bits = spi->bits_per_word;
+	if (bits >= 4 && bits <= 8) {
+		drv_data->n_bytes = 1;
+	} else if (bits > 8 && bits <= 16) {
+		drv_data->n_bytes = 2;
+	} else {
+		printk(KERN_ERR "SPI: setup failed: invalid bits_per_word=%u\n",
+				bits);
+		return -EINVAL;
+	}
+	chip->bits_per_word = bits;
+
+	spi_set_ctldata(spi, chip);
+
+	if (SpiHw_SetClkPhase(SPIHW_CLKPHASE_FIRSTEDGE) != 0) {
+		printk(KERN_ERR "SPI: setup: SpiHw_SetClkPhase failed\n");
+		return -EFAULT;
+	}
+
+	if (SpiHw_SetClkPolarity(SPIHW_CLKPOLARITY_LOWIDLE) != 0) {
+		printk(KERN_ERR "SPI: setup: SpiHw_SetClkPolarity failed\n");
+		return -EFAULT;
+	}
+
+	printk(KERN_NOTICE "SPI: setup: bits_per_word=%u speed_hz=%u\n",
+			chip->bits_per_word,	chip->speed_hz);
+
+	return 0;
+}
+
+static void cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata((struct spi_device *)spi);
+
+	kfree(chip);
+}
+
+static int init_queue(struct driver_data *drv_data)
+{
+	INIT_LIST_HEAD(&drv_data->queue);
+
+	drv_data->run = QUEUE_STOPPED;
+	drv_data->busy = 0;
+
+	INIT_WORK(&drv_data->pump_messages, pump_messages);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+	drv_data->workqueue = create_singlethread_workqueue(drv_data->master->dev.init_name);
+#else
+	drv_data->workqueue = create_singlethread_workqueue(drv_data->master->dev.bus_id);
+#endif
+	if (drv_data->workqueue == NULL)
+		return -EBUSY;
+
+	return 0;
+}
+
+static int start_queue(struct driver_data *drv_data)
+{
+	if (drv_data->run == QUEUE_RUNNING || drv_data->busy) {
+		return -EBUSY;
+	}
+
+	drv_data->run = QUEUE_RUNNING;
+	drv_data->cur_msg = NULL;
+	drv_data->cur_transfer = NULL;
+	drv_data->cur_chip = NULL;
+
+	queue_work(drv_data->workqueue, &drv_data->pump_messages);
+
+	return 0;
+}
+
+static int stop_queue(struct driver_data *drv_data)
+{
+	unsigned limit = 500;
+	int status = 0;
+
+	/* This is a bit lame, but is optimized for the common execution path.
+	 * A wait_queue on the drv_data->busy could be used, but then the common
+	 * execution path (pump_messages) would be required to call wake_up or
+	 * friends on every SPI message. Do this instead */
+	drv_data->run = QUEUE_STOPPED;
+	while (!list_empty(&drv_data->queue) && drv_data->busy && limit--) {
+		msleep(10);
+	}
+
+	if (!list_empty(&drv_data->queue) || drv_data->busy)
+		status = -EBUSY;
+
+	return status;
+}
+
+static int destroy_queue(struct driver_data *drv_data)
+{
+	int status;
+
+	status = stop_queue(drv_data);
+	if (status != 0)
+		return status;
+
+	destroy_workqueue(drv_data->workqueue);
+
+	return 0;
+}
+
+#ifdef SPI_TEST
+static int
+proc_test_rate_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	unsigned int len = 0;
+	u32 rate;
+
+	if (off > 0)
+		return 0;
+
+	rate = SpiHw_GetBitRate();
+
+	len += sprintf(buffer + len, "Current baud rate is %u bps\n", rate);
+
+	return len;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_rate_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	u32 rate;
+	int rc;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &rate) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	rc = SpiHw_SetBitRate(rate);
+	cfg->rate = SpiHw_GetBitRate();
+
+	printk(KERN_WARNING "Baud rate set at: %u\n", cfg->rate);
+
+	return count;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_delta_time_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	unsigned int len = 0;
+
+	if (off > 0)
+		return 0;
+
+	len += sprintf(buffer + len, "Current delta time is %u ms\n",
+			atomic_read(&cfg->delta_time));
+
+	return len;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_delta_time_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	u32 delta_time;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &delta_time) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	atomic_set(&cfg->delta_time, delta_time);
+
+	return count;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_frame_size_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	unsigned int len = 0;
+	u32 frame_size;
+
+	if (off > 0)
+		return 0;
+
+	frame_size = SpiHw_GetFrameSize();
+
+	len += sprintf(buffer + len, "Current frame size is %u bits/frame\n",
+			frame_size);
+
+	return len;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_frame_size_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	u32 frame_size;
+	int rc;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &frame_size) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	if (frame_size > 16 || frame_size < 4) {
+		printk(KERN_ERR "SPI: Inalid frame size: %u\n", frame_size);
+		return count;
+	}
+
+	rc = SpiHw_SetFrameSize(frame_size);
+	cfg->frame_size = SpiHw_GetFrameSize();
+	printk(KERN_WARNING "Frame size set at: %u\n", cfg->frame_size);
+
+	return count;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_enable_dma_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	unsigned int len = 0;
+
+	if (off > 0)
+		return 0;
+
+	len += sprintf(buffer + len, "DMA is %s\n",
+			atomic_read(&cfg->enable_dma) ? "enabled" : "disabled");
+
+	return len;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_enable_dma_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	u32 enable_dma;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &enable_dma) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	if (enable_dma) {
+		atomic_set(&cfg->enable_dma, 1);
+	} else {
+		atomic_set(&cfg->enable_dma, 0);
+	}
+
+	return count;
+}
+#endif
+
+#ifdef SPI_TEST
+static int test_thread_main(void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	u16 read_buf;
+	void *tx_buf = NULL;
+	void *rx_buf = NULL;
+	dma_addr_t tx_dma, rx_dma;
+	u32 i;
+	u32 frame_size;
+	u32 n_bytes;
+
+	daemonize("SPI_THREAD");
+	printk(KERN_INFO "SPI: Entering Thread...");
+
+	/* ensure the RX FIFO is clear */
+	while (SpiHw_IsRxNotEmpty()) {
+		SpiHw_ReadFifo(&read_buf, 1);
+		while (SpiHw_IsBusy())
+			;
+	}
+
+	SpiHw_LoopBackModeEnable();
+
+	tx_buf = dma_alloc_coherent(NULL, DMA_BUF_SIZE,
+					&tx_dma, GFP_KERNEL);
+	if (!tx_buf) {
+		printk(KERN_ERR "SPI: cannot allocate TX buffer\n");
+		goto test_thread_exit;
+	}
+
+	rx_buf = dma_alloc_coherent(NULL, DMA_BUF_SIZE,
+					&rx_dma, GFP_KERNEL);
+	if (!rx_buf) {
+		printk(KERN_ERR "SPI: cannot allocate RX buffer\n");
+		goto test_thread_exit;
+	}
+
+	while (1) {
+		unsigned char *tx8 = tx_buf;
+		unsigned char *rx8 = rx_buf;
+		u16 *tx16 = tx_buf;
+		u16 *rx16 = rx_buf;
+
+		if (!atomic_read(&cfg->start))
+			break;
+
+		frame_size = SpiHw_GetFrameSize();
+		n_bytes = frame_size > 8 ? 2 : 1;
+
+		for (i = 0; i < MAX_DMA_FRAME; i++) {
+			if (frame_size <= 8) {
+				tx8[i] = i;
+				rx8[i] = 0;
+			} else {
+				tx16[i] = 0xCE00 + i;
+				rx16[i] = 0;
+			}
+		}
+
+		if (atomic_read(&cfg->enable_dma)) {
+			SpiHw_EnableTxDMA();
+			SpiHw_EnableRxDMA();
+
+			/* start DMA transfer, block until finish */
+			dma_txrx_transfer(&drv_data->dma_cfg, tx_dma, rx_dma,
+					MAX_DMA_FRAME * n_bytes, n_bytes);
+
+			SpiHw_DisableTxDMA();
+			SpiHw_DisableRxDMA();
+		} else {
+			SpiHw_WriteReadPoll(tx_buf, rx_buf, MAX_DMA_FRAME);
+		}
+
+		for (i = 0; i < MAX_DMA_FRAME; i++) {
+			if (frame_size <= 8) {
+				if (rx8[i] != (tx8[i] & ((1 << frame_size) - 1))) {
+					printk(KERN_ERR "SPI: tx_buf[%u] = 0x%x does not match "
+							"rx_buf[%u] = 0x%x\n", i,
+							tx8[i] & ((1 << frame_size) - 1), i, rx8[i]);
+				}
+			} else {
+				if (rx16[i] != (tx16[i] & ((1 << frame_size) - 1))) {
+					printk(KERN_ERR "SPI: tx_buf[%u] = 0x%x does not match "
+							"rx_buf[%u] = 0x%x\n", i,
+							tx16[i] & ((1 << frame_size) - 1), i, rx16[i]);
+				}
+			}
+		}
+
+		if (atomic_read(&cfg->delta_time)) {
+			msleep(atomic_read(&cfg->delta_time));
+		}
+	}
+
+test_thread_exit:
+	printk(KERN_INFO "SPI: Exiting Thread...\n");
+	SpiHw_LoopBackModeDisable();
+	atomic_set(&cfg->start, 0);
+	if (tx_buf != NULL) {
+		dma_free_coherent(NULL, DMA_BUF_SIZE, tx_buf, tx_dma);
+		tx_buf = NULL;
+	}
+	if (rx_buf != NULL) {
+		dma_free_coherent(NULL, DMA_BUF_SIZE, rx_buf, rx_dma);
+		rx_buf = NULL;
+	}
+	complete_and_exit(&cfg->exit_lock, 0);
+	return 0;
+}
+#endif
+
+#ifdef SPI_TEST
+static int test_thread_init(struct driver_data *drv_data)
+{
+	struct test_cfg *cfg = &drv_data->test_cfg;
+
+	init_completion(&cfg->exit_lock); /* incomplete */
+
+	/* don't use DMA by default */
+	atomic_set(&cfg->enable_dma, 0);
+
+	/* default delta time */
+	atomic_set(&cfg->delta_time, DEFAULT_DELTA);
+
+	SpiHw_SetFrameSize(DEFAULT_FRAME_SIZE);
+	SpiHw_SetBitRate(DEFAULT_BAUD_RATE);
+
+	return 0;
+}
+#endif
+
+#ifdef SPI_TEST
+static void test_thread_start(struct driver_data *drv_data)
+{
+	struct test_cfg *cfg = &drv_data->test_cfg;
+
+	/* already started */
+	if (atomic_read(&cfg->start)) {
+		return;
+	}
+
+	/* mark exit_lock as incomplete */
+	INIT_COMPLETION(cfg->exit_lock);
+	atomic_set(&cfg->start, 1);
+	cfg->id = kernel_thread(test_thread_main, (void *)drv_data, 0);
+}
+#endif
+
+#ifdef SPI_TEST
+static void test_thread_stop(struct driver_data *drv_data)
+{
+	struct test_cfg *cfg = &drv_data->test_cfg;
+
+	atomic_set(&cfg->start, 0);
+
+	if (cfg->id > 0) {
+		kill_proc_info(SIGTERM, SEND_SIG_PRIV, cfg->id);
+		wait_for_completion(&cfg->exit_lock);
+	}
+
+	cfg->id = 0;
+}
+#endif
+
+static int
+proc_loopback_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	unsigned int len = 0;
+
+	if (off > 0)
+		return 0;
+
+	len += sprintf(buffer + len, "SPI loopback mode is %s\n",
+			atomic_read(&drv_data->loopback_enable) ? "ON" : "OFF");
+
+	return len;
+}
+
+static int
+proc_loopback_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	u32 enable;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &enable) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	if (enable)
+		atomic_set(&drv_data->loopback_enable, 1);
+	else
+			atomic_set(&drv_data->loopback_enable, 0);
+
+	return count;
+}
+
+#ifdef SPI_TEST
+static int
+proc_test_start_read(char *buffer, char **start, off_t off, int count,
+		int *eof, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	struct test_cfg *cfg = &drv_data->test_cfg;
+	unsigned int len = 0;
+
+	if (off > 0)
+		return 0;
+
+	len += sprintf(buffer + len, "Test SPI thread is %s\n",
+			atomic_read(&cfg->start) ? "running" : "NOT running");
+
+	return len;
+}
+#endif
+
+#ifdef SPI_TEST
+static int
+proc_test_start_write(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	struct driver_data *drv_data = (struct driver_data *)data;
+	u32 start;
+	unsigned char kernel_buffer[MAX_PROC_BUF_SIZE];
+
+	if (count > MAX_PROC_BUF_SIZE)
+		count = MAX_PROC_BUF_SIZE;
+
+	if (copy_from_user(kernel_buffer, buffer, count)) {
+		printk(KERN_WARNING "SPI: copy_from_user failed\n");
+		return -EFAULT;
+	}
+
+	if (sscanf(kernel_buffer, "%u", &start) != 1) {
+		printk(KERN_WARNING "SPI: proc write syntax error\n");
+		return count;
+	}
+
+	if (start) {
+		test_thread_start(drv_data);
+	} else {
+		test_thread_stop(drv_data);
+	}
+
+	return count;
+}
+#endif
+
+/*
+ * Set up proc entries
+ */
+static int proc_setup(struct driver_data *drv_data)
+{
+	struct proc_dir_entry *proc_loopback;
+#ifdef SPI_TEST
+	struct proc_dir_entry *proc_test_rate;
+	struct proc_dir_entry *proc_test_delta_time;
+	struct proc_dir_entry *proc_test_frame_size;
+	struct proc_dir_entry *proc_test_enable_dma;
+	struct proc_dir_entry *proc_test_start;
+#endif
+
+	spi_proc.parent_dir = proc_mkdir("spih", NULL);
+
+	proc_loopback = create_proc_entry("loopbackEnable", 0644,
+			spi_proc.parent_dir);
+	if (proc_loopback == NULL) {
+		return -ENOMEM;
+	}
+	proc_loopback->read_proc = proc_loopback_read;
+	proc_loopback->write_proc = proc_loopback_write;
+	proc_loopback->data = drv_data;
+
+
+#ifdef SPI_TEST
+	spi_proc.test_dir = proc_mkdir("perfTest", spi_proc.parent_dir);
+#endif
+
+#ifdef SPI_TEST
+	proc_test_rate = create_proc_entry("rate", 0644,
+			spi_proc.test_dir);
+	if (proc_test_rate == NULL) {
+		return -ENOMEM;
+	}
+	proc_test_rate->read_proc = proc_test_rate_read;
+	proc_test_rate->write_proc = proc_test_rate_write;
+	proc_test_rate->data = drv_data;
+
+	proc_test_delta_time = create_proc_entry("deltaTime", 0644,
+			spi_proc.test_dir);
+	if (proc_test_delta_time == NULL) {
+		return -ENOMEM;
+	}
+	proc_test_delta_time->read_proc = proc_test_delta_time_read;
+	proc_test_delta_time->write_proc = proc_test_delta_time_write;
+	proc_test_delta_time->data = drv_data;
+
+	proc_test_frame_size = create_proc_entry("frameSize", 0644,
+			spi_proc.test_dir);
+	if (proc_test_frame_size == NULL) {
+		return -ENOMEM;
+	}
+	proc_test_frame_size->read_proc = proc_test_frame_size_read;
+	proc_test_frame_size->write_proc = proc_test_frame_size_write;
+	proc_test_frame_size->data = drv_data;
+
+	proc_test_enable_dma = create_proc_entry("enableDMA", 0644,
+			spi_proc.test_dir);
+	if (proc_test_enable_dma == NULL) {
+		return -ENOMEM;
+	}
+	proc_test_enable_dma->read_proc = proc_test_enable_dma_read;
+	proc_test_enable_dma->write_proc = proc_test_enable_dma_write;
+	proc_test_enable_dma->data = drv_data;
+
+	proc_test_start = create_proc_entry("start", 0644,
+			spi_proc.test_dir);
+	if (proc_test_start == NULL) {
+		return -ENOMEM;
+	}
+	proc_test_start->read_proc = proc_test_start_read;
+	proc_test_start->write_proc = proc_test_start_write;
+	proc_test_start->data = drv_data;
+#endif
+
+	return 0;
+}
+
+static int bcmring_spi_probe(struct amba_device *pdev, void *id)
+{
+	struct device *dev = &pdev->dev;
+	struct bcmring_spi_master *platform_info;
+	struct spi_master *master;
+	struct driver_data *drv_data = 0;
+	int status = 0;
+
+	platform_info = dev->platform_data;
+	if (!platform_info) {
+		printk(KERN_ERR "SPI: cannot obtain platform data\n");
+		return -EINVAL;
+	}
+
+	status = amba_request_regions(pdev, NULL);
+	if (status) {
+		printk(KERN_ERR "SPI: cannot to reserve regs region\n");
+		return status;
+	}
+
+	/* Allocate master with space for drv_data */
+	master = spi_alloc_master(dev, sizeof(struct driver_data) + 16);
+	if (!master) {
+		printk(KERN_ERR "SPI: cannot alloc spi_master\n");
+		goto error_free_region;
+	}
+
+	drv_data = spi_master_get_devdata(master);
+	drv_data->master = master;
+
+	/* TODO: find a way to determine bus num */
+	master->bus_num = 0;
+	master->num_chipselect = platform_info->num_chipselect;
+	master->setup = setup;
+	master->transfer = transfer;
+	master->cleanup = cleanup;
+
+	/* turn off loopback mode by default */
+	atomic_set(&drv_data->loopback_enable, 0);
+
+	/* initialize the SPI deivce */
+	status = SpiHw_Init(&cs_ctrl);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: Init device failed\n");
+		goto error_free_region;
+	}
+
+	/* Enable the clock via clock framework */
+
+	spi_clk = clk_get(NULL, "SPI");
+	if (IS_ERR(spi_clk)) {
+		printk(KERN_ERR "SPI: Unable to find SPI clock\n");
+		goto error_free_clk;
+	}
+
+	clk_set_rate(spi_clk, 50000000);
+	status = clk_enable(spi_clk);
+	if (status < 0) {
+		printk(KERN_ERR "SPI: Unable to enable SPI clock\n");
+		goto error_free_clk;
+	}
+
+	/* dummy DMA buffer is used for throw-away TX and RX data */
+	drv_data->dummy_dma_buf = dma_alloc_coherent(dev, DMA_BUF_SIZE,
+					&drv_data->dummy_dma_addr, GFP_KERNEL);
+	if (!drv_data->dummy_dma_buf) {
+		printk(KERN_ERR "SPI: cannot allocate dummy DMA buffer\n");
+		goto error_free_region;
+	}
+
+	status = dma_txrx_init(&drv_data->dma_cfg);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: problem initializing DMA\n");
+		goto error_free_dummy_dma;
+	}
+
+	/* Initial and start queue */
+	status = init_queue(drv_data);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: problem initializing queue\n");
+		goto error_free_dummy_dma;
+	}
+
+	status = start_queue(drv_data);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: problem starting queue\n");
+		goto error_destroy_queue;
+	}
+
+	/* Register with the SPI framework */
+	amba_set_drvdata(pdev, drv_data);
+
+	status = spi_register_master(master);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: problem registering spi master\n");
+		goto error_destroy_queue;
+	}
+
+	status = request_irq(IRQ_SPIH, irq_spi, IRQF_SHARED, "SPIH", drv_data);
+	if (status < 0) {
+		printk(KERN_ERR "SPI: problem requesting IRQ\n");
+		goto error_destroy_queue;
+	}
+	/* disable all interrupts except the Receive Timeout */
+	SpiHw_IntrDisable(SPIHW_REG_INTR_ROR | SPIHW_REG_INTR_RT |
+			SPIHW_REG_INTR_RX | SPIHW_REG_INTR_TX);
+	SpiHw_IntrEnable(SPIHW_REG_INTR_RT);
+
+	status = SpiHw_Enable();
+	if (status != 0) {
+		printk(KERN_ERR "SPI: SpiHw_Enable failed\n");
+		goto error_free_irq;
+	}
+
+	status = proc_setup(drv_data);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: problem creating proc entries\n");
+		goto error_free_irq;
+	}
+
+#ifdef SPI_TEST
+	test_thread_init(drv_data);
+#endif
+
+	return status;
+
+error_free_irq:
+	free_irq(IRQ_SPIH, 0);
+
+error_destroy_queue:
+	destroy_queue(drv_data);
+
+error_free_dummy_dma:
+	dma_free_coherent(dev, DMA_BUF_SIZE, drv_data->dummy_dma_buf,
+			drv_data->dummy_dma_addr);
+	drv_data->dummy_dma_buf = NULL;
+
+error_free_clk:
+	clk_disable(spi_clk);
+	clk_put(spi_clk);
+
+error_free_region:
+	amba_release_regions(pdev);
+	return status;
+}
+
+static int bcmring_spi_remove(struct amba_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct driver_data *drv_data = amba_get_drvdata(pdev);
+	int status = 0;
+
+	if (!drv_data)
+		return 0;
+
+	status = SpiHw_Disable();
+	if (status != 0) {
+		printk(KERN_ERR "SPI: bcmring_spi_remove: SpiHw_Disable failed\n");
+		return -EFAULT;
+	}
+
+	free_irq(IRQ_SPIH, 0);
+
+	/* Remove the queue */
+	status = destroy_queue(drv_data);
+	if (status != 0) {
+		printk(KERN_ERR "SPI: bcmring_spi_remove: workqueue will not "
+			"complete, message memory not freed\n");
+		return status;
+	}
+
+	remove_proc_entry("spih", NULL);
+
+	dma_free_coherent(dev, DMA_BUF_SIZE, drv_data->dummy_dma_buf,
+			drv_data->dummy_dma_addr);
+	drv_data->dummy_dma_buf = NULL;
+
+	/* disconnect from the SPI framework */
+	spi_unregister_master(drv_data->master);
+
+	/* prevent double remove */
+	amba_set_drvdata(pdev, NULL);
+
+	amba_release_regions(pdev);
+
+	SpiHw_Exit();
+	clk_disable(spi_clk);
+	clk_put(spi_clk);
+
+	return 0;
+}
+
+static struct amba_id bcmring_id_table[] = {
+	{
+		.id	= 0x00041022,
+		.mask	= 0x000fffff,
+	},
+	{0, 0},
+};
+
+#ifdef CONFIG_PM
+static int bcmring_spi_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	down(&spi_lock);
+	clk_disable(spi_clk);
+	return 0;
+}
+
+static int bcmring_spi_resume(struct platform_device *pdev)
+{
+	int status = 0;
+
+	status = clk_enable(spi_clk);
+	if (status < 0) {
+		printk(KERN_ERR "bcmring_spi_resume: Unable to enable SPI clock\n");
+	}
+
+	up(&spi_lock);
+	return 0;
+}
+#else
+#define bcmring_spi_suspend	NULL
+#define bcmring_spi_resume	NULL
+#endif
+
+static struct amba_driver bcmring_driver = {
+	.drv = {
+		.name = "bcmring-spi",
+	},
+	.probe = bcmring_spi_probe,
+	.remove = bcmring_spi_remove,
+	.id_table = bcmring_id_table,
+	.suspend = bcmring_spi_suspend,
+	.resume = bcmring_spi_resume,
+};
+
+static int __init bcmring_spi_init(void)
+{
+	init_MUTEX(&spi_lock);
+
+	/* set GPIOs to SPI mode */
+	gpiomux_requestGroup(gpiomux_group_spi, "SPI");
+
+	return amba_driver_register(&bcmring_driver);
+}
+module_init(bcmring_spi_init);
+
+static void __exit bcmring_spi_exit(void)
+{
+	amba_driver_unregister(&bcmring_driver);
+
+	/* free the SPI GPIO pins */
+	gpiomux_freeGroup(gpiomux_group_spi);
+}
+module_exit(bcmring_spi_exit);
+
+MODULE_AUTHOR("Broadcom Corporation <@broadcom.com>");
+MODULE_DESCRIPTION("SPIH Controller");
+MODULE_LICENSE("GPL");
-- 
1.7.0.4

