From e12720fa40261c759688cb9e04198bf6b309c51b Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Wed, 17 Mar 2010 19:39:30 +0800
Subject: [PATCH 33/47] bcm11xx: i2c support

add the BCM11XX i2c adpater driver

originated from broadcom SDK PhonexChange6.1

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/arch.c                       |    6 +
 arch/arm/mach-bcmring/core.c                       |   26 +-
 arch/arm/mach-bcmring/csp/Makefile                 |    1 +
 arch/arm/mach-bcmring/csp/i2c/Makefile             |    1 +
 arch/arm/mach-bcmring/csp/i2c/i2cHw.c              |  194 ++++
 arch/arm/mach-bcmring/include/csp/i2cHw.h          |  458 ++++++++++
 .../mach-bcmring/include/mach/csp/i2cHw_inline.h   |  223 +++++
 arch/arm/mach-bcmring/include/mach/csp/i2cHw_reg.h |  180 ++++
 arch/arm/mach-bcmring/include/mach/reg_i2c.h       |  174 ++++
 drivers/i2c/busses/Kconfig                         |    7 +
 drivers/i2c/busses/Makefile                        |    1 +
 drivers/i2c/busses/i2c-bcm11xx-hw.c                |  930 ++++++++++++++++++++
 include/linux/i2c-id.h                             |    2 +
 13 files changed, 2202 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/csp/i2c/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/i2c/i2cHw.c
 create mode 100644 arch/arm/mach-bcmring/include/csp/i2cHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/i2cHw_inline.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/i2cHw_reg.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/reg_i2c.h
 create mode 100644 drivers/i2c/busses/i2c-bcm11xx-hw.c

diff --git a/arch/arm/mach-bcmring/arch.c b/arch/arm/mach-bcmring/arch.c
index 074dad6..5c11e49 100644
--- a/arch/arm/mach-bcmring/arch.c
+++ b/arch/arm/mach-bcmring/arch.c
@@ -91,8 +91,14 @@ static struct platform_device nand_device = {
 	.num_resources	= ARRAY_SIZE(nand_resource),
 };
 
+static struct platform_device i2c_device = {
+	.name = "bcm-i2c",
+	.id = -1,
+};
+
 static struct platform_device *devices[] __initdata = {
 	&nand_device,
+	&i2c_device,
 };
 
 /****************************************************************************
diff --git a/arch/arm/mach-bcmring/core.c b/arch/arm/mach-bcmring/core.c
index 1c9608c..4552053 100644
--- a/arch/arm/mach-bcmring/core.c
+++ b/arch/arm/mach-bcmring/core.c
@@ -96,6 +96,23 @@ static struct clk uart_clk = {
 	.parent = &pll1_clk,
 };
 
+static struct clk xtal_clk = {
+	.name = "XTAL",
+	.type = CLK_TYPE_PRIMARY,
+	.mode = CLK_MODE_XTAL,
+	.rate_hz = 25000000,
+	.use_cnt = 0,
+};
+
+static struct clk i2c_clk = {
+	.name = "I2C",
+	.type = CLK_TYPE_BYPASSABLE | CLK_TYPE_PROGRAMMABLE,
+	.mode = CLK_MODE_XTAL,
+	.csp_id = chipcHw_CLOCK_I2C,
+	.rate_hz = 12500000,
+	.parent = &xtal_clk,
+};
+
 static struct clk_lookup lookups[] = {
 	{			/* UART0 */
 	 .dev_id = "uarta",
@@ -103,7 +120,14 @@ static struct clk_lookup lookups[] = {
 	 }, {			/* UART1 */
 	     .dev_id = "uartb",
 	     .clk = &uart_clk,
-	     }
+	     },
+	{
+		.con_id = "XTAL",
+		.clk = &xtal_clk,
+	}, {
+		.con_id = "I2C",
+		.clk = &i2c_clk,
+	}
 };
 
 static struct amba_device *amba_devs[] __initdata = {
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index 1e03646..6f69a83 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -4,3 +4,4 @@ obj-y += chipc/
 obj-y += gpio/
 obj-y += gpiomux/
 obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
+obj-$(CONFIG_I2C_BCM11XX) += i2c/
diff --git a/arch/arm/mach-bcmring/csp/i2c/Makefile b/arch/arm/mach-bcmring/csp/i2c/Makefile
new file mode 100644
index 0000000..c178545
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/i2c/Makefile
@@ -0,0 +1 @@
+obj-y += i2cHw.o   
diff --git a/arch/arm/mach-bcmring/csp/i2c/i2cHw.c b/arch/arm/mach-bcmring/csp/i2c/i2cHw.c
new file mode 100644
index 0000000..5a86100
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/i2c/i2cHw.c
@@ -0,0 +1,194 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file	 i2cHw.c
+*
+*  @brief	Low level I2C host driver
+*/
+/****************************************************************************/
+
+
+/* ---- Include Files ----------------------------------------------------- */
+
+#include <csp/stdint.h>
+#include <csp/reg.h>
+
+#include <mach/csp/mm_io.h>
+#include <mach/csp/i2cHw_reg.h>
+#include <csp/i2cHw.h>
+#include <csp/delay.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <csp/module.h>
+
+/* ---- Private Functions ------------------------------------------------- */
+/* ---- Functions ----------------------------------------------------------*/
+
+/* Function descriptions can be found in i2cHw.h */
+int I2CHw_Init(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(I2CHw_Init);
+
+int I2CHw_Exit(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(I2CHw_Exit);
+
+int I2CHw_SetClkSpd(I2CHW_CLKSPD clkSpd)
+{
+	uint8_t clkSpdReg = I2CHW_REG_CLK_26K;
+
+	switch (clkSpd) {
+	case I2CHW_CLKSPD_22K:
+		clkSpdReg = I2CHW_REG_CLK_22K;
+		break;
+	case I2CHW_CLKSPD_46K:
+		clkSpdReg = I2CHW_REG_CLK_46K;
+		break;
+	case I2CHW_CLKSPD_93K:
+		clkSpdReg = I2CHW_REG_CLK_93K;
+		break;
+	case I2CHW_CLKSPD_186K:
+		clkSpdReg = I2CHW_REG_CLK_186K;
+		break;
+	case I2CHW_CLKSPD_26K:
+		clkSpdReg = I2CHW_REG_CLK_26K;
+		break;
+	case I2CHW_CLKSPD_52K:
+		clkSpdReg = I2CHW_REG_CLK_52K;
+		break;
+	case I2CHW_CLKSPD_105K:
+		clkSpdReg = I2CHW_REG_CLK_105K;
+		break;
+	case I2CHW_CLKSPD_210K:
+		clkSpdReg = I2CHW_REG_CLK_210K;
+		break;
+	case I2CHW_CLKSPD_30K:
+		clkSpdReg = I2CHW_REG_CLK_30K;
+		break;
+	case I2CHW_CLKSPD_60K:
+		clkSpdReg = I2CHW_REG_CLK_60K;
+		break;
+	case I2CHW_CLKSPD_120K:
+		clkSpdReg = I2CHW_REG_CLK_120K;
+		break;
+	case I2CHW_CLKSPD_241K:
+		clkSpdReg = I2CHW_REG_CLK_241K;
+		break;
+	case I2CHW_CLKSPD_35K:
+		clkSpdReg = I2CHW_REG_CLK_35K;
+		break;
+	case I2CHW_CLKSPD_71K:
+		clkSpdReg = I2CHW_REG_CLK_71K;
+		break;
+	case I2CHW_CLKSPD_141K:
+		clkSpdReg = I2CHW_REG_CLK_141K;
+		break;
+	case I2CHW_CLKSPD_283K:
+		clkSpdReg = I2CHW_REG_CLK_283K;
+		break;
+	case I2CHW_CLKSPD_43K:
+		clkSpdReg = I2CHW_REG_CLK_43K;
+		break;
+	case I2CHW_CLKSPD_86K:
+		clkSpdReg = I2CHW_REG_CLK_86K;
+		break;
+	case I2CHW_CLKSPD_171K:
+		clkSpdReg = I2CHW_REG_CLK_171K;
+		break;
+	case I2CHW_CLKSPD_342K:
+		clkSpdReg = I2CHW_REG_CLK_342K;
+		break;
+	case I2CHW_CLKSPD_54K:
+		clkSpdReg = I2CHW_REG_CLK_54K;
+		break;
+	case I2CHW_CLKSPD_108K:
+		clkSpdReg = I2CHW_REG_CLK_108K;
+		break;
+	case I2CHW_CLKSPD_217K:
+		clkSpdReg = I2CHW_REG_CLK_217K;
+		break;
+	case I2CHW_CLKSPD_433K:
+		clkSpdReg = I2CHW_REG_CLK_433K;
+		break;
+	case I2CHW_CLKSPD_74K:
+		clkSpdReg = I2CHW_REG_CLK_74K;
+		break;
+	case I2CHW_CLKSPD_148K:
+		clkSpdReg = I2CHW_REG_CLK_148K;
+		break;
+	case I2CHW_CLKSPD_295K:
+		clkSpdReg = I2CHW_REG_CLK_295K;
+		break;
+	case I2CHW_CLKSPD_591K:
+		clkSpdReg = I2CHW_REG_CLK_591K;
+		break;
+	case I2CHW_CLKSPD_116K:
+		clkSpdReg = I2CHW_REG_CLK_116K;
+		break;
+	case I2CHW_CLKSPD_232K:
+		clkSpdReg = I2CHW_REG_CLK_232K;
+		break;
+	case I2CHW_CLKSPD_464K:
+		clkSpdReg = I2CHW_REG_CLK_464K;
+		break;
+	case I2CHW_CLKSPD_928K:
+		clkSpdReg = I2CHW_REG_CLK_928K;
+		break;
+	default:
+		/* Default to lowest speed */
+		clkSpdReg = I2CHW_REG_CLK_22K;
+		break;
+	}
+
+	reg32_write(&i2cHwReg->tim, clkSpdReg);
+
+	return 0;
+}
+
+int I2CHw_ResetSclSda(void)
+{
+	/* Set all pins low on CS register. Will be in software control mode */
+	reg32_write(&i2cHwReg->cs, 0);
+	udelay(80);
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SCL);
+	udelay(80);
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL);	/* Stop command */
+	udelay(80);
+
+	/* Re-enable hardware controlled mode */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_EN);
+
+	return 0;
+}
+
+int I2CHw_GetBusClkPeriod(void)
+{
+	uint8_t tim, div, p;
+
+	tim = reg32_read(&i2cHwReg->tim);
+	div = tim & I2CHW_REG_TIM_DIVMSK;
+	p = (tim & I2CHW_REG_TIM_PMSK) >> I2CHW_REG_TIM_PVAL_BITSHIFT;
+
+	div = 1 << (4 - div);
+	p = 2 * (p + 1) + 1 + 2 * (p + 1) + 2;
+
+	return (div * p * 1000000 + (I2CHW_REG_MASTER_CLK_FREQ >> 1) - 1) / I2CHW_REG_MASTER_CLK_FREQ;
+}
diff --git a/arch/arm/mach-bcmring/include/csp/i2cHw.h b/arch/arm/mach-bcmring/include/csp/i2cHw.h
new file mode 100644
index 0000000..4f773d2
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/i2cHw.h
@@ -0,0 +1,458 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    i2cHw.h
+*
+*  @brief   API definitions for low level I2C Host device driver
+*
+*/
+/****************************************************************************/
+
+#ifndef I2CHW_H
+#define I2CHW_H
+
+/* ---- Include Files ----------------------------------------------------- */
+/* ---- Public Constants and Types ---------------------------------------- */
+
+typedef enum {
+	I2CHW_CLKSPD_22K,
+	I2CHW_CLKSPD_26K,
+	I2CHW_CLKSPD_30K,
+	I2CHW_CLKSPD_35K,
+	I2CHW_CLKSPD_43K,
+	I2CHW_CLKSPD_46K,
+	I2CHW_CLKSPD_52K,
+	I2CHW_CLKSPD_54K,
+	I2CHW_CLKSPD_60K,
+	I2CHW_CLKSPD_71K,
+	I2CHW_CLKSPD_74K,
+	I2CHW_CLKSPD_86K,
+	I2CHW_CLKSPD_93K,
+	I2CHW_CLKSPD_105K,
+	I2CHW_CLKSPD_108K,
+	I2CHW_CLKSPD_116K,
+	I2CHW_CLKSPD_120K,
+	I2CHW_CLKSPD_141K,
+	I2CHW_CLKSPD_148K,
+	I2CHW_CLKSPD_171K,
+	I2CHW_CLKSPD_186K,
+	I2CHW_CLKSPD_210K,
+	I2CHW_CLKSPD_217K,
+	I2CHW_CLKSPD_232K,
+	I2CHW_CLKSPD_241K,
+	I2CHW_CLKSPD_283K,
+	I2CHW_CLKSPD_295K,
+	I2CHW_CLKSPD_342K,
+	I2CHW_CLKSPD_433K,
+	I2CHW_CLKSPD_464K,
+	I2CHW_CLKSPD_591K,
+	I2CHW_CLKSPD_928K
+} I2CHW_CLKSPD;
+
+#define I2CHW_ISR_MASKALL       0x0F         /* Mask for all interrupts */
+#define I2CHW_ISR_SES_DONE      0x08         /*  Read 0: I2C session busy 1: I2C session done
+						 Write 0: No action 1: Clear the interrupt */
+#define I2CHW_ISR_I2CERR        0x04         /* I2C Bus Error Status */
+#define I2CHW_ISR_TXFIFOEMPTY   0x02         /* I2C Tx FIFO Empty */
+#define I2CHW_ISR_NOACK         0x01         /* I2C No Acknowledge interrupt */
+
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_Init
+*
+*  Initializes the block
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int I2CHw_Init(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_Exit
+*
+*  Powers down the block
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int I2CHw_Exit(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_EnableController
+*
+*  Enable the I2C host controller.  Activates the clock and place controller
+*  in hardware controlled mode.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_EnableController(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_DisableController
+*
+*  Disables the I2C host controller.  Disables the clock and flushes the FIFO
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_DisableController(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IsControllerEnabled
+*
+*  Queries the enable/disable status of the controller.
+*
+*  @return
+*     Returns 1 if enabled and 0 if disabled
+*/
+/****************************************************************************/
+static inline int I2CHw_IsControllerEnabled(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_SetClkSpd
+*
+*  Sets the clock speed to interface with device.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+int   I2CHw_SetClkSpd
+(
+   I2CHW_CLKSPD clkSpd            /* [IN]   Clock speed value enum type I2CHW_CLKSPD */
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_StartCmd
+*
+*  Sends a start command from the I2C Host
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_StartCmd(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_RepStartCmd
+*
+*  Initiates a repeated start command sequence.
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_RepStartCmd(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_StopCmd
+*
+*  Sends a stop command from the I2C Host
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_StopCmd(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_WriteCmd
+*
+*  Sets up I2C Host for a write operation
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_WriteCmd(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_WriteFifoByte
+*
+*  Write to FIFO a byte of data from I2C host to peripheral
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_WriteFifoByte
+(
+   uint8_t data
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_ReadCmd
+*
+*  Sends a read command from the I2C Host
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_ReadCmd(int ack);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_ReadFifoByte
+*
+*  Receive a byte of data off the FIFO from I2C host to peripheral
+*
+*  @return
+*     Returns the byte of data read
+*/
+/****************************************************************************/
+static inline uint8_t I2CHw_ReadFifoByte(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_CheckForAck
+*
+*  Query if ack was returned from last I2C byte write.
+*
+*  @return
+*     Returns 0 if ack is set from last I2C write, else 1
+*/
+/****************************************************************************/
+static inline int I2CHw_CheckForAck(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_CheckSclSdaReady
+*
+*  Checks SCL and SDA lines are set high and ready for command
+*
+*  @return
+*     Returns 1 if true, else 0
+*/
+/****************************************************************************/
+static inline int I2CHw_CheckSclSdaReady(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_ResetSclSda
+*
+*  Forces through software mode both SCL and SDA lines high.
+*
+*  @return
+*     Returns 1 if true, else 0
+*/
+/****************************************************************************/
+int   I2CHw_ResetSclSda(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IsCmdBusy
+*
+*  Query if current command is busy
+*
+*  @return
+*     Return 1 if command is busy, else 0
+*/
+/****************************************************************************/
+static inline int I2CHw_IsCmdBusy(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_ClearCmd
+*
+*  Clear the command issued
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_ClearCmd(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_SetTimeoutVal
+*
+*  Set the timeout counter on I2C host operations.  Value is number of ticks
+*  based on a 6.5 MHz clock
+*
+*  @return
+*     Always return 0
+*/
+/****************************************************************************/
+static inline int I2CHw_SetTimeoutVal
+(
+   int to
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_GetTimeoutVal
+*
+*  Get the timeout value on I2C host operations
+*
+*  @return
+*     Return timeout counter based on a tick of 6.5MHz clock
+*/
+/****************************************************************************/
+static inline int I2CHw_GetTimeoutVal(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_TimeoutEnable
+*
+*  Enable the timeout for I2C host operations
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_TimeoutEnable(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_TimeoutDisable
+*
+*  Disable the timeout for I2C host operations
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_TimeoutDisable(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IsTimeoutEnabled
+*
+*  Query if timeout is enabled for I2C host operations
+*
+*  @return
+*     Return 1 if enabled, else 0
+*/
+/****************************************************************************/
+static inline int I2CHw_IsTimeoutEnabled(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_FlushFIFO
+*
+*  Clear the FIFO on the I2C host
+*
+*  @return
+*     Always return 0
+*/
+/****************************************************************************/
+static inline int I2CHw_FlushFIFO(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_FlushFIFO
+*
+*  Query the current count in the FIFO
+*
+*  @return
+*     Return the number of units residing in the FIFO
+*/
+/****************************************************************************/
+static inline int I2CHw_GetFIFOCount(void);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IntrEnable
+*
+*  Enable interrupts based on the bit mask value given
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_IntrEnable(int mask);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IntrDisable
+*
+*  Disable interrupts based on the bit mask value given
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_IntrDisable
+(
+   int mask
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IntrDisable
+*
+*  Clear interrupts based on the bit mask value given
+*
+*  @return
+*     Always returns 0
+*/
+/****************************************************************************/
+static inline int I2CHw_IntrClear
+(
+   int mask
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_IntrStatus
+*
+*  Query status of interrupts based on the bit mask value given
+*
+*  @return
+*     Returns a bit mask indicating which interrupts are triggered
+*/
+/****************************************************************************/
+static inline int I2CHw_IntrStatus
+(
+   int mask
+);
+
+/****************************************************************************/
+/**
+*  @brief   I2CHw_GetBusClkPeriod
+*
+*  Retrieves the clock period required for the delay between i2c transactions
+*
+*  @return
+*     Returns the clock period in microseconds
+*/
+/****************************************************************************/
+int   I2CHw_GetBusClkPeriod(void);
+
+#include <mach/csp/i2cHw_inline.h>
+
+#endif /* I2CHW_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/i2cHw_inline.h b/arch/arm/mach-bcmring/include/mach/csp/i2cHw_inline.h
new file mode 100644
index 0000000..f67de3e
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/i2cHw_inline.h
@@ -0,0 +1,223 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+#ifndef I2CHW_INLINE_H
+#define I2CHW_INLINE_H
+
+#ifndef I2CHW_H
+#error *** Do not include i2cHw_inline.h directly. Use i2cHw.h instead. ***
+#endif
+
+#define  GNATS_8295_WORKAROUND		1
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <csp/reg.h>
+#include <mach/csp/mm_io.h>
+#include <mach/csp/i2cHw_reg.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+
+static inline int I2CHw_EnableController(void)
+{
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL); /* Set register to default value */
+	reg32_write(&i2cHwReg->rcm, 0);	/* Disable CRC */
+
+	reg32_set_bits(&i2cHwReg->clken, I2CHW_REG_CLKEN_CLKEN); /* Enable clock */
+
+	I2CHw_FlushFIFO(); /* Flush the FIFO */
+	reg32_set_bits(&i2cHwReg->cs, I2CHW_REG_CS_EN);	/* Enable hardware control mode */
+
+	return 0;
+}
+
+static inline int I2CHw_DisableController(void)
+{
+	reg32_write(&i2cHwReg->clken, 0); /* Disable clock */
+	I2CHw_FlushFIFO(); /* Flush the FIFO */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL); /* Set register to default value */
+
+	return 0;
+}
+
+static inline int I2CHw_IsControllerEnabled(void)
+{
+	return (reg32_read(&i2cHwReg->clken) & I2CHW_REG_CLKEN_CLKEN) ? 1 : 0;
+}
+
+static inline int I2CHw_StartCmd(void)
+{
+	/* Send out START command */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_CMDSTART | I2CHW_REG_CS_EN);
+
+	return 0;
+}
+
+static inline int I2CHw_RepStartCmd(void)
+{
+	/* Issue repeated start command */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_CMDRESTART | I2CHW_REG_CS_EN);
+
+	return 0;
+}
+
+static inline int I2CHw_StopCmd(void)
+{
+	/* Issue stop command */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_CMDSTOP | I2CHW_REG_CS_EN);
+
+	return 0;
+}
+
+static inline int I2CHw_WriteCmd(void)
+{
+	/* Setup SDA and SCL lines */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_EN);
+
+	return 0;
+}
+
+static inline int I2CHw_WriteFifoByte(uint8_t data)
+{
+	/* Send byte */
+	reg32_write(&i2cHwReg->dat, data);
+	return 0;
+}
+
+static inline int I2CHw_ReadCmd(int ack)
+{
+	if (!ack)
+		ack = I2CHW_REG_CS_ACK;
+
+	/* Setup SDA and SCL lines.  Send read command with optional ack */
+	reg32_write(&i2cHwReg->cs, I2CHW_REG_CS_SDA | I2CHW_REG_CS_SCL | I2CHW_REG_CS_CMDREAD | I2CHW_REG_CS_EN | ack);
+
+	return 0;
+}
+
+static inline uint8_t I2CHw_ReadFifoByte(void)
+{
+	uint8_t data;
+
+	/* Check for command to be done */
+	data = reg32_read(&i2cHwReg->dat);
+	return data;
+}
+
+static inline int I2CHw_CheckForAck(void)
+{
+	return (reg32_read(&i2cHwReg->cs) & I2CHW_REG_CS_ACK) ? 0 : 1;
+}
+
+static inline int I2CHw_CheckSclSdaReady(void)
+{
+	return ((reg32_read(&i2cHwReg->cs) & I2CHW_REG_CS_SDA) &&
+				(reg32_read(&i2cHwReg->cs) & I2CHW_REG_CS_SCL)) ? 1 : 0;
+}
+
+static inline int I2CHw_IsCmdBusy(void)
+{
+	/*
+	 * Command busy bit will be set at beginning of session
+	 * and clear itself when done.
+	 */
+	return (reg32_read(&i2cHwReg->isr) & I2CHW_REG_ISR_CMD_BUSY) ? 1 : 0;
+}
+
+static inline int I2CHw_ClearCmd(void)
+{
+	/* Mask out command bits */
+	reg32_clear_bits(&i2cHwReg->cs, I2CHW_REG_CS_CMDMASK);
+
+	return 0;
+}
+
+static inline int I2CHw_SetTimeoutVal(int to)
+{
+#if !GNATS_8295_WORKAROUND
+	reg32_write_masked(&i2cHwReg->tout, I2CHW_REG_TOUT_CNTMASK, to);
+#else
+	(void)to;
+#endif
+	return 0;
+}
+
+static inline int I2CHw_GetTimeoutVal(void)
+{
+	/* Timeout value is expressed in ticks of a 6.5MHz clock */
+	return reg32_read(&i2cHwReg->tout) & I2CHW_REG_TOUT_CNTMASK;
+}
+
+static inline int I2CHw_TimeoutEnable(void)
+{
+#if !GNATS_8295_WORKAROUND
+	reg32_set_bits(&i2cHwReg->tout, I2CHW_REG_TOUT_EN);
+#endif
+	return 0;
+}
+
+static inline int I2CHw_TimeoutDisable(void)
+{
+	reg32_clear_bits(&i2cHwReg->tout, I2CHW_REG_TOUT_EN);
+	return 0;
+}
+
+static inline int I2CHw_IsTimeoutEnabled(void)
+{
+	return (reg32_read(&i2cHwReg->tout) & I2CHW_REG_TOUT_EN) ? 1 : 0;
+}
+
+static inline int I2CHw_FlushFIFO(void)
+{
+	reg32_write(&i2cHwReg->fcr, I2CHW_REG_FCR_FLUSH);
+	return 0;
+}
+
+static inline int I2CHw_GetFIFOCount(void)
+{
+	return reg32_read(&i2cHwReg->fcr) & I2CHW_REG_FCR_CNTMASK;
+}
+
+static inline int I2CHw_IntrEnable(int mask)
+{
+	/* When bit is high, interrupt is enabled. */
+	reg32_set_bits(&i2cHwReg->ier, (mask & I2CHW_ISR_MASKALL));
+	return 0;
+}
+
+static inline int I2CHw_IntrDisable(int mask)
+{
+	/* When bit is low, interrupt is disabled. */
+	reg32_clear_bits(&i2cHwReg->ier, (mask & I2CHW_ISR_MASKALL));
+	return 0;
+}
+
+static inline int I2CHw_IntrClear(int mask)
+{
+	/* Writing to isr register will clear the interrupt */
+	reg32_set_bits(&i2cHwReg->isr, (mask & I2CHW_ISR_MASKALL));
+	return 0;
+}
+
+static inline int I2CHw_IntrStatus(int mask)
+{
+	/* Reading from isr register will provide current interrupt status */
+	return reg32_read(&i2cHwReg->isr) & (mask & I2CHW_ISR_MASKALL);
+}
+
+#endif /* I2CHW_INLINE_H */
+
diff --git a/arch/arm/mach-bcmring/include/mach/csp/i2cHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/i2cHw_reg.h
new file mode 100644
index 0000000..70b4268
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/i2cHw_reg.h
@@ -0,0 +1,180 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    i2cHw_reg.h
+*
+*  @brief   I2C register definitions
+*
+*/
+/****************************************************************************/
+
+#ifndef I2CHW_REG_H
+#define I2CHW_REG_H
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <mach/csp/mm_io.h>
+
+/* ---- Public Constants and Types ---------------------------------------- */
+/* ---- Public Variables -------------------------------------------------- */
+/* ---- Public Function Prototypes ---------------------------------------- */
+
+typedef struct {
+	uint32_t cs;
+	uint32_t tim;
+	uint32_t dat;
+	uint32_t tout;
+	uint32_t rcm;
+	uint32_t rcp;
+	uint32_t rcd;
+	uint32_t fcr;
+	uint32_t fifordout;
+	uint32_t ier;
+	uint32_t isr;
+	uint32_t clken;
+} I2CHW_REG_t;
+
+#define I2CHW_BASE	MM_IO_BASE_I2CH
+#define i2cHwReg	((volatile I2CHW_REG_t *) I2CHW_BASE)
+
+/*
+ * Required frequency of the I2C block. Note that the ideal clock frequency
+ * is 13MHz.  But since the external clock is at 25MHz, the closest frequency
+ * (using any divider combination) is 12.5 MHz (div by 2).
+ */
+#define I2CHW_REG_MASTER_CLK_FREQ	12500000UL
+
+/* I2CHW_REG_CCS bits */
+#define I2CHW_REG_CS_EN			0x01	/* 1:Enable I2C hardware 0:Reset I2C hardware */
+#define I2CHW_REG_CS_CMDMASK		0x06	/* bits 2:1 */
+#define I2CHW_REG_CS_ACK		0x08	/* ACK bit
+						 * Write: CMD=11 ACK to send out after I2C byte read
+						 *	CMD=01 0: Normal start 1: Repeated start
+						 * Read: ACK returned from last I2C byte write */
+#define I2CHW_REG_CS_SCL		0x40	/* I2C clock Write:Set SCL pin value when EN=0 Read:SCL pin value */
+#define I2CHW_REG_CS_SDA		0x80	/* I2C data  Write:Set SDA pin value when EN=0 Read:SDA pin value */
+
+/* I2C Host Commands */
+#define I2CHW_REG_CS_CMDNULL		0x00	/* No immediate action */
+#define I2CHW_REG_CS_CMDSTART		0x02	/* Generate start condition */
+#define I2CHW_REG_CS_CMDSTOP		0x04	/* Generate stop condition */
+#define I2CHW_REG_CS_CMDREAD		0x06	/* Read a byte */
+#define I2CHW_REG_CS_CMDRESTART		(I2CHW_REG_CS_CMDSTART | I2CHW_REG_CS_ACK)
+
+
+/* I2CHW_REG_TIM bits
+ * --- I2C speed. Master clock is 13MHz */
+#define I2CHW_REG_TIM_DIVMSK		0x03	/* clock division bits */
+#define I2CHW_REG_TIM_PMSK		0x38	/* # cycles for SCL, high=2*p+1, low=2*p+2 */
+#define I2CHW_REG_TIM_PVAL_BITSHIFT 	3	/* Bit offset for P value */
+
+/* I2C Timing Settings */
+#define I2CHW_REG_TIM_DIV16	0	/* MCLK /16 */
+#define I2CHW_REG_TIM_DIV8	1	/* MCLK /8 */
+#define I2CHW_REG_TIM_DIV4	2	/* MCLK /4 */
+#define I2CHW_REG_TIM_DIV2	3	/* MCLK /2 */
+#define I2CHW_REG_TIM_P0	(0 << 3)
+#define I2CHW_REG_TIM_P1	(1 << 3)
+#define I2CHW_REG_TIM_P2	(2 << 3)
+#define I2CHW_REG_TIM_P3	(3 << 3)
+#define I2CHW_REG_TIM_P4	(4 << 3)
+#define I2CHW_REG_TIM_P5	(5 << 3)
+#define I2CHW_REG_TIM_P6	(6 << 3)
+#define I2CHW_REG_TIM_P7	(7 << 3)
+
+/* --- SCL speed
+ * Frequency below are based on a 13MHz frequency
+ * --- I2CTIM_P bits = 111 group */
+#define I2CHW_REG_CLK_22K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P7)
+#define I2CHW_REG_CLK_46K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P7)
+#define I2CHW_REG_CLK_93K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P7)
+#define I2CHW_REG_CLK_186K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P7)
+
+/* I2CTIM_P bits = 110 group */
+#define I2CHW_REG_CLK_26K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P6)
+#define I2CHW_REG_CLK_52K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P6)
+#define I2CHW_REG_CLK_105K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P6)
+#define I2CHW_REG_CLK_210K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P6)
+
+/* I2CTIM_P bits = 101 group */
+#define I2CHW_REG_CLK_30K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P5)
+#define I2CHW_REG_CLK_60K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P5)
+#define I2CHW_REG_CLK_120K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P5)
+#define I2CHW_REG_CLK_241K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P5)
+
+/* I2CTIM_P bits = 100 group */
+#define I2CHW_REG_CLK_35K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P4)
+#define I2CHW_REG_CLK_71K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P4)
+#define I2CHW_REG_CLK_141K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P4)
+#define I2CHW_REG_CLK_283K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P4)
+
+/* I2CTIM_P bits = 011 group */
+#define I2CHW_REG_CLK_43K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P3)
+#define I2CHW_REG_CLK_86K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P3)
+#define I2CHW_REG_CLK_171K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P3)
+#define I2CHW_REG_CLK_342K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P3)
+
+/* I2CTIM_P bits = 010 group */
+#define I2CHW_REG_CLK_54K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P2)
+#define I2CHW_REG_CLK_108K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P2)
+#define I2CHW_REG_CLK_217K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P2)
+#define I2CHW_REG_CLK_433K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P2)
+
+/* I2CTIM_P bits = 001 group */
+#define I2CHW_REG_CLK_74K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P1)
+#define I2CHW_REG_CLK_148K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P1)
+#define I2CHW_REG_CLK_295K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P1)
+#define I2CHW_REG_CLK_591K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P1)
+
+/* I2CTIM_P bits = 000 group */
+#define I2CHW_REG_CLK_116K	(I2CHW_REG_TIM_DIV16 | I2CHW_REG_TIM_P0)
+#define I2CHW_REG_CLK_232K	(I2CHW_REG_TIM_DIV8 | I2CHW_REG_TIM_P0)
+#define I2CHW_REG_CLK_464K	(I2CHW_REG_TIM_DIV4 | I2CHW_REG_TIM_P0)
+#define I2CHW_REG_CLK_928K	(I2CHW_REG_TIM_DIV2 | I2CHW_REG_TIM_P0)
+
+/* I2CHW_REG_I2CTOUT bits */
+#define I2CHW_REG_TOUT_EN	0x80	/* Enables the Timeout counter */
+#define I2CHW_REG_TOUT_CNTMASK	0x7F	/* Timeout counter value */
+
+/* I2CHW_REG_RCM bits */
+#define I2CHW_REG_RCM_EN	0x01	/* enable CRC generation */
+#define I2CHW_REG_RCM_LSB0	0x02	/* =1, Force LSB to be 0 */
+
+/* I2CHW_REG_FCR bits */
+#define I2CHW_REG_FCR_FLUSH	0x80	/* Writing 1 will flush the Tx FIFO; Write Only */
+#define I2CHW_REG_FCR_EN	0x40	/* FIFO Enable */
+#define I2CHW_REG_FCR_CNTMASK	0x0F	/* FIFO Data Counter; Read Only */
+
+/* I2CHW_REG_IER bits */
+#define I2CHW_REG_IER_INT_EN	0x08	/* 1: Enable I2C busy status interrupt */
+#define I2CHW_REG_IER_ERRINT_EN	0x04	/* 1: Enable I2C error status interrupt */
+#define I2CHW_REG_IER_FIFOINT_EN	0x02	/* 1: Enable I2C Tx FIFO empty interrupt */
+#define I2CHW_REG_IER_NOACK_EN	0x01	/* 1: Enable I2C No Acknowledge interrupt */
+
+/* I2CHW_REG_ISR bits */
+#define I2CHW_REG_ISR_CMD_BUSY	0x80	/* Command busy */
+#define I2CHW_REG_ISR_SES_DONE	0x08	/* Read 0: I2C session busy 1: I2C session done
+					 * Write 0: No action 1: Clear the interrupt */
+#define I2CHW_REG_ISR_I2CERR	0x04	/* I2C Bus Error Status */
+#define I2CHW_REG_ISR_TXFIFOEMPTY	0x02	/* I2C Tx FIFO Empty */
+#define I2CHW_REG_ISR_NOACK	0x01	/* I2C No Acknowledge interrupt */
+
+/* I2CHW_REG_CLKEN bits */
+#define I2CHW_REG_CLKEN_CLKEN	0x01	/* 1: Enable I2C clock */
+
+#endif /* I2CHW_REG_H */
diff --git a/arch/arm/mach-bcmring/include/mach/reg_i2c.h b/arch/arm/mach-bcmring/include/mach/reg_i2c.h
new file mode 100644
index 0000000..342d648
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/reg_i2c.h
@@ -0,0 +1,174 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/*
+*
+*****************************************************************************
+*
+*  reg_i2c.h
+*
+*  PURPOSE:
+*
+*     This file contains definitions for the I2C Registers.
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+
+#if !defined(__ASM_ARCH_REG_I2C_H)
+#define __ASM_ARCH_REG_I2C_H
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <csp/reg.h>
+#include <mach/hardware.h>
+
+/* ---- Constants and Types ---------------------------------------------- */
+
+#define HW_I2C_BASE MM_IO_BASE_I2CH
+
+#define REG_I2C_CS		__REG8(HW_I2C_BASE + 0x00)	/* I2C Control and Status Register */
+#define REG_I2C_TIM		__REG8(HW_I2C_BASE + 0x04)	/* I2C Timing Register */
+#define REG_I2C_DAT		__REG8(HW_I2C_BASE + 0x08)	/* I2C Data Register */
+#define REG_I2C_TOUT		__REG8(HW_I2C_BASE + 0x0c)	/* I2C Timeout Register */
+#define REG_I2C_RCM		__REG8(HW_I2C_BASE + 0x10)	/* I2C CRC Main Register */
+#define REG_I2C_RCP		__REG8(HW_I2C_BASE + 0x14)	/* I2C CRC Polynomial Register */
+#define REG_I2C_RCD		__REG8(HW_I2C_BASE + 0x18)	/* I2C CRC Data Register */
+#define REG_I2C_FCR		__REG8(HW_I2C_BASE + 0x1c)	/* I2C FIFO Control Register */
+#define REG_I2C_FIFORDOUT	__REG8(HW_I2C_BASE + 0x20)	/* I2C FIFO Read Out Register */
+#define REG_I2C_IER		__REG8(HW_I2C_BASE + 0x24)	/* I2C FIFO Interrupt Enable Register */
+#define REG_I2C_ISR		__REG8(HW_I2C_BASE + 0x28)	/* I2C FIFO Interrupt Status Register */
+#define REG_I2C_CLKEN		__REG8(HW_I2C_BASE + 0x2c)	/* I2C clock enable */
+
+/* REG_I2C_CCS bits */
+#define REG_I2C_CS_EN		0x01	/* 1:Enable I2C hardware 0:Reset I2C hardware */
+#define REG_I2C_CS_CMDMASK	0x06	/* bits 2:1 */
+#define REG_I2C_CS_CMDNULL	0x00	/* No immediate action */
+#define REG_I2C_CS_CMDSTART	0x02	/* Generate start condition */
+#define REG_I2C_CS_CMDSTOP	0x04	/* Generate stop condition */
+#define REG_I2C_CS_CMDREAD	0x06	/* Read a byte */
+#define REG_I2C_CS_ACK		0x08	/*
+					 * ACK bit
+					 * Write: CMD=11 ACK to send out after I2C byte read
+					 *	CMD=01 0: Normal start 1: Repeated start
+					 * Read: ACK returned from last I2C byte write
+					 */
+#define REG_I2C_CS_SCL		0x40	/* I2C clock Write:Set SCL pin value when EN=0 Read:SCL pin value */
+#define REG_I2C_CS_SDA		0x80	/* I2C data  Write:Set SDA pin value when EN=0 Read:SDA pin value */
+#define REG_I2C_CS_CMDRESTART	(REG_I2C_CS_CMDSTART | REG_I2C_CS_ACK)
+
+
+/*
+ * REG_I2C_TIM bits
+ * --- I2C speed. Master clock is 13MHz
+ */
+#define REG_I2C_TIM_DIVMSK	0x03	/* clock division bits */
+#define REG_I2C_TIM_DIV16	0	/* MCLK /16 */
+#define REG_I2C_TIM_DIV8	1	/* MCLK /8 */
+#define REG_I2C_TIM_DIV4	2	/* MCLK /4 */
+#define REG_I2C_TIM_DIV2	03	/* MCLK /2 */
+#define REG_I2C_TIM_PMSK	0x38	/* # cycles for SCL, high=2*p+1, low=2*p+2 */
+#define REG_I2C_TIM_P0		(0<<3)
+#define REG_I2C_TIM_P1		(1<<3)
+#define REG_I2C_TIM_P2		(2<<3)
+#define REG_I2C_TIM_P3		(3<<3)
+#define REG_I2C_TIM_P4		(4<<3)
+#define REG_I2C_TIM_P5		(5<<3)
+#define REG_I2C_TIM_P6		(6<<3)
+#define REG_I2C_TIM_P7		(7<<3)
+
+/*
+ * --- SCL speed
+ * --- I2CTIM_P bits = 111 group
+ */
+#define REG_I2C_CLK_22K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P7)
+#define REG_I2C_CLK_46K		(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P7)
+#define REG_I2C_CLK_93K		(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P7)
+#define REG_I2C_CLK_186K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P7)
+
+/* I2CTIM_P bits = 110 group */
+#define REG_I2C_CLK_26K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P6)
+#define REG_I2C_CLK_52K		(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P6)
+#define REG_I2C_CLK_105K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P6)
+#define REG_I2C_CLK_210K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P6)
+
+/* I2CTIM_P bits = 101 group */
+#define REG_I2C_CLK_30K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P5)
+#define REG_I2C_CLK_60K		(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P5)
+#define REG_I2C_CLK_120K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P5)
+#define REG_I2C_CLK_241K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P5)
+
+/* I2CTIM_P bits = 100 group */
+#define REG_I2C_CLK_35K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P4)
+#define REG_I2C_CLK_71K		(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P4)
+#define REG_I2C_CLK_141K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P4)
+#define REG_I2C_CLK_283K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P4)
+
+/* I2CTIM_P bits = 011 group */
+#define REG_I2C_CLK_43K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P3)
+#define REG_I2C_CLK_86K		(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P3)
+#define REG_I2C_CLK_171K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P3)
+#define REG_I2C_CLK_342K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P3)
+
+/* I2CTIM_P bits = 010 group */
+#define REG_I2C_CLK_54K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P2)
+#define REG_I2C_CLK_108K	(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P2)
+#define REG_I2C_CLK_217K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P2)
+#define REG_I2C_CLK_433K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P2)
+
+/* I2CTIM_P bits = 001 group */
+#define REG_I2C_CLK_74K		(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P1)
+#define REG_I2C_CLK_148K	(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P1)
+#define REG_I2C_CLK_295K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P1)
+#define REG_I2C_CLK_591K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P1)
+
+/* I2CTIM_P bits = 000 group */
+#define REG_I2C_CLK_116K	(REG_I2C_TIM_DIV16 | REG_I2C_TIM_P0)
+#define REG_I2C_CLK_232K	(REG_I2C_TIM_DIV8 | REG_I2C_TIM_P0)
+#define REG_I2C_CLK_464K	(REG_I2C_TIM_DIV4 | REG_I2C_TIM_P0)
+#define REG_I2C_CLK_928K	(REG_I2C_TIM_DIV2 | REG_I2C_TIM_P0)
+
+/* REG_I2C_I2CTOUT bits */
+#define REG_I2C_TOUT_EN		0x80 /* Enables the Timeout counter */
+
+/* REG_I2C_RCM bits */
+#define REG_I2C_RCM_EN		0x01 /* enable CRC generation */
+#define REG_I2C_RCM_LSB0	0x02 /* =1, Force LSB to be 0 */
+
+/* REG_I2C_FCR bits */
+#define REG_I2C_FCR_FLUSH	0x80 /* Writing 1 will flush the Tx FIFO; Write Only */
+#define REG_I2C_FCR_EN		0x40 /* FIFO Enable */
+#define REG_I2C_FCR_CNTMASK	0x07 /* FIFO Data Counter; Read Only */
+
+/* REG_I2C_IER bits */
+#define REG_I2C_IER_INT_EN	0x08 /* 1: Enable I2C busy status interrupt */
+#define REG_I2C_IER_ERRINT_EN	0x04 /* 1: Enable I2C error status interrupt */
+#define REG_I2C_IER_FIFOINT_EN	0x02 /* 1: Enable I2C Tx FIFO empty interrupt */
+#define REG_I2C_IER_NOACK_EN	0x01 /* 1: Enable I2C No Acknowledge interrupt */
+
+/* REG_I2C_ISR bits */
+#define REG_I2C_ISR_CMD_BUSY	0x80 /* Command busy */
+#define REG_I2C_ISR_SES_DONE	0x08 /* Read 0: I2C session busy 1: I2C session done
+				      * Write 0: No action 1: Clear the interrupt */
+#define REG_I2C_ISR_I2CERR	0x04 /* I2C Bus Error Status */
+#define REG_I2C_ISR_TXFIFOEMPTY	0x02 /* I2C Tx FIFO Empty */
+#define REG_I2C_ISR_NOACK	0x01 /* I2C No Acknowledge interrupt */
+
+/* REG_I2C_CLKEN bits */
+#define REG_I2C_CLKEN_CLKEN	0x01 /* 1: Enable I2C clock */
+#endif
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..ad44309 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -504,6 +504,13 @@ config I2C_VERSATILE
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-versatile.
 
+config I2C_BCM11XX
+    tristate "BCM11XX adapter"
+    depends on (ARCH_BCM116X || ARCH_BCMRING) && I2C
+    help
+        Enable the i2c adapter on the BCM116X or BCMRING, which is used for
+        Power Management.
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_PARPORT
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..01088ad 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 # Embebbed system I2C/SMBus host controller drivers
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
+obj-$(CONFIG_I2C_BCM11XX)	+= i2c-bcm11xx-hw.o
 obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
 obj-$(CONFIG_I2C_CPM)		+= i2c-cpm.o
 obj-$(CONFIG_I2C_DAVINCI)	+= i2c-davinci.o
diff --git a/drivers/i2c/busses/i2c-bcm11xx-hw.c b/drivers/i2c/busses/i2c-bcm11xx-hw.c
new file mode 100644
index 0000000..4d284a8
--- /dev/null
+++ b/drivers/i2c/busses/i2c-bcm11xx-hw.c
@@ -0,0 +1,930 @@
+/*****************************************************************************
+* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/semaphore.h>
+
+#include <mach/reg_i2c.h>
+
+#include <mach/timer.h>
+
+#if defined(CONFIG_ARCH_BCMRING)
+#   include <csp/i2cHw.h>
+#   include <mach/csp/gpiomux.h>
+#endif
+
+/* ----- global variables ---------------------------------------------	*/
+
+#define I2C_POLL_COMMAND_DONE 1
+
+/* Debug logging */
+#ifdef DEBUG
+#undef DEBUG
+#endif
+#define DEBUG 1
+
+#define DBG_ERROR	0x01
+#define DBG_INFO	0x02
+#define DBG_TRACE	0x04
+#define DBG_TRACE2	0x08
+#define DBG_DATA	0x10
+#define DBG_DATA2	0x20
+
+#if defined(CONFIG_ARCH_BCM2153) || defined(CONFIG_ARCH_BCMRING)
+#define ADD_TURNAROUND_DELAY	1
+#else
+#define ADD_TURNAROUND_DELAY	0
+#endif
+
+#define I2C_ISR_MASK_ALL	(REG_I2C_ISR_SES_DONE | REG_I2C_ISR_I2CERR | REG_I2C_ISR_TXFIFOEMPTY | REG_I2C_ISR_NOACK)
+
+#if ADD_TURNAROUND_DELAY
+
+#define BSC_TIM_P_VAL_BIT_SHIFT 3
+
+#if defined(CONFIG_ARCH_BCMRING)
+#define BSC_MASTER_CLK_FREQ	I2CHW_REG_MASTER_CLK_FREQ
+#else
+/* Assumption of fixed 13 MHz clock signal */
+#define BSC_MASTER_CLK_FREQ	13000000UL
+#endif
+
+#endif
+
+#define DBG_DEFAULT_LEVEL  (DBG_ERROR)
+static int i2c_debug_level = DBG_DEFAULT_LEVEL;
+
+#if DEBUG
+#define I2C_DEBUG(level, fmt, args...) do { printk(KERN_DEBUG "%s: " fmt, __func__, ##args); } while (0)
+#else
+#define I2C_DEBUG(level, fmt, args...)
+#endif
+
+static unsigned int i2c_errors;
+static unsigned int i2c_max_irq_wait;
+static unsigned int i2c_max_cmdbusy_cnt;
+static unsigned int i2c_max_cmdbusy_clk;
+
+static struct ctl_table gSysCtlLocal[] = {
+	{
+		.ctl_name	= 1,
+		.procname	= "level",
+		.data		= &i2c_debug_level,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= 2,
+		.procname	= "errors",
+		.data		= &i2c_errors,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= 3,
+		.procname	= "max_irq_wait",
+		.data		= &i2c_max_irq_wait,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= 4,
+		.procname	= "max_cmdbusy_cnt",
+		.data		= &i2c_max_cmdbusy_cnt,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{
+		.ctl_name	= 5,
+		.procname	= "max_cmdbusy_clk",
+		.data		= &i2c_max_cmdbusy_clk,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec
+	},
+	{}
+};
+
+#define CTL_BCM_I2C	118
+static struct ctl_table gSysCtl[] = {
+	{
+		.ctl_name		= CTL_BCM_I2C,
+		.procname		= "i2c",
+		.mode			 = 0555,
+		.child			= gSysCtlLocal
+	},
+	{}
+};
+
+struct bcm11xx_i2c {
+	u32 interrupt;
+#if !I2C_POLL_COMMAND_DONE
+	wait_queue_head_t queue;
+#endif
+	struct i2c_adapter adap;
+	struct ctl_table_header *sysCtlHeader; /* sysctl table */
+};
+
+static struct bcm11xx_i2c *i2c;
+static struct clk *i2c_clk;
+static struct semaphore i2c_lock;
+
+#if ADD_TURNAROUND_DELAY
+
+static unsigned long i2c_bus_clk_period; /* in micro seconds */
+
+/* Turn-around delay (2 bus clocks time) after write / read needed for BCM2153 BSC */
+#define TURN_AROUND_DELAY	(i2c_bus_clk_period * 2)
+
+/* compute the clock period required for the delay between i2c transactions */
+static unsigned long bcm11xx_i2c_bus_clk_period(void)
+{
+	u8 tim, div, p;
+
+	tim = REG_I2C_TIM;
+	div = tim & REG_I2C_TIM_DIVMSK;
+	p = (tim & REG_I2C_TIM_PMSK) >> BSC_TIM_P_VAL_BIT_SHIFT;
+
+	I2C_DEBUG(DBG_INFO, " tim[%d]\t div[%d]\t p[%d]\n", tim, div, p);
+
+	div = 1 << (4 - div);
+	p = 2 * (p + 1) + 1 + 2 * (p + 1) + 2;
+
+	return (div * p * 1000000 + (BSC_MASTER_CLK_FREQ >> 1) - 1) / BSC_MASTER_CLK_FREQ;
+}
+#endif
+
+static int bcm11xx_check_cmdbusy(void)
+{
+	int i = 0;
+	timer_tick_count_t clk = timer_get_tick_count();
+	timer_tick_count_t clk2;
+
+	if (REG_I2C_ISR & REG_I2C_ISR_CMD_BUSY) {
+		/* wait for I2C CMD not busy */
+		while (REG_I2C_ISR & REG_I2C_ISR_CMD_BUSY) {
+			if (i > 100000) {
+				i2c_errors++;
+				return -ETIMEDOUT;
+			}
+			i++;
+		}
+	}
+
+	clk2 = timer_get_tick_count();
+	clk = clk2 - clk;
+	if (i > i2c_max_cmdbusy_cnt)
+		i2c_max_cmdbusy_cnt = i;
+	if (clk > i2c_max_cmdbusy_clk)
+		i2c_max_cmdbusy_clk = clk;
+	return 0;
+}
+
+#if !I2C_POLL_COMMAND_DONE
+static irqreturn_t bcm11xx_i2c_isr(int irq, void *dev_id)
+{
+	if (REG_I2C_ISR) {
+		/* Read again to allow register to stabilise */
+		i2c->interrupt = REG_I2C_ISR;
+
+		REG_I2C_ISR = i2c->interrupt; /* clear interrupts */
+
+		wake_up_interruptible(&i2c->queue);
+	}
+	return IRQ_HANDLED;
+}
+
+static int bcm11xx_wait_interrupt(void)
+{
+	int res = 0;
+	timer_tick_count_t clk;
+
+	clk = timer_get_tick_count();
+	res = wait_event_interruptible_timeout(i2c->queue, i2c->interrupt, HZ);
+	clk = timer_get_tick_count() - clk;
+	if (clk > i2c_max_irq_wait)
+		i2c_max_irq_wait = clk;
+
+	if (res < 0) {
+		I2C_DEBUG(DBG_ERROR, "interrupted\n");
+	} else if (!i2c->interrupt) {
+		I2C_DEBUG(DBG_ERROR, "wait timed out, %d\n", clk);
+		i2c_errors++;
+		res = -ETIMEDOUT;
+	} else
+		res = i2c->interrupt;
+
+	i2c->interrupt = 0;
+
+	return res;
+}
+
+#else
+
+static int bcm11xx_wait_interrupt(void)
+{
+	/* wait for I2C Controller Interrupt */
+	unsigned int i = 0;
+	timer_tick_count_t clk;
+	timer_tick_count_t clk2;
+	int isr;
+
+	clk = timer_get_tick_count();
+	while ((REG_I2C_ISR & I2C_ISR_MASK_ALL) == 0) {
+		i++;
+		if (i == (unsigned int)(-1)) {
+			I2C_DEBUG(DBG_ERROR, "wait timed out, %d\n", clk);
+			return -ETIMEDOUT;
+		}
+	}
+
+	clk2 = timer_get_tick_count();
+	clk = clk2 - clk;
+	if (clk > i2c_max_irq_wait)
+		i2c_max_irq_wait = clk;
+
+	isr = REG_I2C_ISR;
+	REG_I2C_ISR = isr;
+
+	return isr;
+}
+#endif
+
+static int bcm11xx_wait_sesdone(int clear_cmd)
+{
+	int ret;
+	u8 isr;
+	u8 cs = REG_I2C_CS;
+
+	ret = bcm11xx_wait_interrupt();
+	if (ret < 0) {
+		I2C_DEBUG(DBG_ERROR, "wait interrupt timed out %d cs = 0x%02X\n", ret, cs);
+		i2c_errors++;
+
+		/* Clear command */
+		if (clear_cmd) {
+			cs = REG_I2C_CS;
+			REG_I2C_CS = (cs & ~REG_I2C_CS_CMDMASK);
+		}
+		return ret;
+	}
+
+	/* Get status from interrupt status register */
+	isr = ret;
+
+	/* Clear command */
+	cs = REG_I2C_CS;
+	if (clear_cmd)
+		REG_I2C_CS = (cs & ~REG_I2C_CS_CMDMASK);
+
+	if (isr & REG_I2C_ISR_I2CERR) {
+		I2C_DEBUG(DBG_ERROR, "bus error detected\n");
+		i2c_errors++;
+		return -EIO;
+	}
+
+	if (isr & REG_I2C_ISR_NOACK) {
+		I2C_DEBUG(DBG_ERROR, "no ack\n");
+		i2c_errors++;
+	}
+
+	if (!(isr & REG_I2C_ISR_SES_DONE)) {
+		I2C_DEBUG(DBG_ERROR, "ses done timedout\n");
+		i2c_errors++;
+		return -EIO;
+	}
+
+	return (cs & REG_I2C_CS_ACK) ? 0 : 1;
+}
+
+static int bcm11xx_i2c_start(void)
+{
+	u8 cs;
+	int i = 0;
+
+	I2C_DEBUG(DBG_TRACE, "\n");
+
+#if ADD_TURNAROUND_DELAY
+	udelay(TURN_AROUND_DELAY);
+#endif
+
+	/*
+	 * Wait for the I2C bus to go idle (SDA = SCL = 1).
+	 * However, we're the master, so we only need to wait for a few milliseconds for this.
+	 */
+
+	while (((cs = REG_I2C_CS) & (REG_I2C_CS_SDA | REG_I2C_CS_SCL)) != (REG_I2C_CS_SDA | REG_I2C_CS_SCL)) {
+		i2c_errors++;
+		I2C_DEBUG(DBG_ERROR, "waiting for cs = 0x%2x [i = %d]\n", cs, i);
+		REG_I2C_CS = 0;
+		udelay(80);
+		REG_I2C_CS = REG_I2C_CS_SCL;
+		udelay(80);
+		REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL;
+		udelay(80);
+		REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_EN;
+		udelay(100);
+
+		msleep(2);
+
+		if (++i >= 16) {
+			I2C_DEBUG(DBG_ERROR, "bus appears to be hung - bailing\n");
+			return -EIO;
+		}
+	}
+
+	/* Wait for controller to be done with last command */
+	if (bcm11xx_check_cmdbusy() < 0) {
+		I2C_DEBUG(DBG_ERROR, "cmdbusy always high\n");
+		return -EIO;
+	}
+
+	/* Send normal start condition */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_CMDSTART | REG_I2C_CS_EN;
+
+	/* Wait for command to be done */
+	if (bcm11xx_wait_sesdone(1) < 0) {
+		I2C_DEBUG(DBG_ERROR, "sesdone timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int bcm11xx_i2c_repstart(void)
+{
+	I2C_DEBUG(DBG_TRACE, "\n");
+
+	/* Wait for controller to be done with last command */
+	if (bcm11xx_check_cmdbusy() < 0) {
+		I2C_DEBUG(DBG_ERROR, "cmdbusy always high\n");
+		return -EIO;
+	}
+
+	/* Send repeated start condition */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_CMDRESTART | REG_I2C_CS_EN;
+
+	/* Wait for command to be done */
+	if (bcm11xx_wait_sesdone(1) < 0) {
+		I2C_DEBUG(DBG_ERROR, "sesdone timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int bcm11xx_i2c_stop(void)
+{
+	u8 cs = REG_I2C_CS;
+
+	I2C_DEBUG(DBG_TRACE, "\n");
+
+	/* Wait for controller to be done with last command */
+	if (bcm11xx_check_cmdbusy() < 0) {
+		I2C_DEBUG(DBG_ERROR, "cmdbusy always high\n");
+		return -EIO;
+	}
+
+	/* Send stop condition */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_CMDSTOP | REG_I2C_CS_EN;
+
+	/* Wait for command to be done */
+	if (bcm11xx_wait_sesdone(1) < 0) {
+		I2C_DEBUG(DBG_ERROR, "sesdone timed out, cs = 0x%02x\n", cs);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+/* send a byte without start cond., look for arbitration,
+   check ackn. from slave */
+/* returns:
+ * 1 if the device acknowledged
+ * 0 if the device did not ack
+ * -ETIMEDOUT if an error occurred (while raising the scl line)
+ */
+static int bcm11xx_i2c_outb(char c)
+{
+	int ack;
+
+	I2C_DEBUG(DBG_TRACE, "0x%2x\n", c);
+
+	udelay(5);
+
+	/* Wait for controller to be done with last command */
+	if (bcm11xx_check_cmdbusy() < 0) {
+		I2C_DEBUG(DBG_ERROR, "cmdbusy always high\n");
+		return -EIO;
+	}
+
+	/* Send data */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_EN;
+
+	REG_I2C_DAT = (u8)c;
+
+	/* Wait for command to be done */
+	ack = bcm11xx_wait_sesdone(0);
+	if (ack < 0) {
+		I2C_DEBUG(DBG_ERROR, "sesdone timed out\n");
+		return -ETIMEDOUT;
+	}
+
+	return ack;
+}
+
+
+static int bcm11xx_i2c_inb(int no_ack)
+{
+	u8 cs = REG_I2C_CS;
+	u8 data;
+
+	I2C_DEBUG(DBG_TRACE, "%d\n", no_ack);
+
+	/* Wait for controller to be done with last command */
+	if (bcm11xx_check_cmdbusy() < 0) {
+		I2C_DEBUG(DBG_ERROR, "cmdbusy always high\n");
+		return -EIO;
+	}
+
+	/* Initiate data read with ACK low */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_CMDREAD | REG_I2C_CS_EN | (no_ack ? REG_I2C_CS_ACK : 0);
+
+	/* Wait for command to be done */
+	if (bcm11xx_wait_sesdone(1) < 0) {
+		I2C_DEBUG(DBG_ERROR, "sesdone timed out, cs = 0x%02x\n", cs);
+		return -ETIMEDOUT;
+	}
+
+	/* Read data */
+	data = REG_I2C_DAT;
+
+	udelay(5);
+	return (int)data;
+}
+
+/* try_address tries to contact a chip for a number of
+ * times before it gives up.
+ * return values:
+ * 1 chip answered
+ * 0 chip did not answer
+ * -x transmission error
+ */
+static int bcm11xx_try_address(struct i2c_adapter *i2c_adap,
+		       unsigned char addr, int retries)
+{
+	int i, ret = -1;
+
+	I2C_DEBUG(DBG_TRACE, "0x%02x, %d\n", addr, retries);
+
+	for (i = 0; i <= retries; i++) {
+		ret = bcm11xx_i2c_outb(addr);
+		if (ret == 1)
+			break;	/* success! */
+		bcm11xx_i2c_stop();
+		udelay(5);
+		if (i == retries)  /* no success */
+			break;
+		bcm11xx_i2c_start();
+		udelay(100);
+	}
+	udelay(5);
+	if (i) {
+		I2C_DEBUG(DBG_INFO, "Used %d tries to %s client at 0x%02x : %s\n",
+			 i+1, addr & 1 ? "read" : "write", addr>>1,
+			 ret == 1 ? "success" : ret == 0 ? "no ack" : "failed, timeout?");
+	}
+	return ret;
+}
+
+static int bcm11xx_sendbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)
+{
+	char c;
+	const char *temp = msg->buf;
+	int count = msg->len;
+	unsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;
+	int retval;
+	int wrcount = 0;
+
+	while (count > 0) {
+		c = *temp;
+		I2C_DEBUG(DBG_TRACE2, "writing %2.2X\n", c & 0xff);
+		retval = bcm11xx_i2c_outb(c);
+		if ((retval > 0) || (nak_ok && (retval == 0)))  { /* ok or ignored NAK */
+			count--;
+			temp++;
+			wrcount++;
+		} else { /* arbitration or no acknowledge */
+			I2C_DEBUG(DBG_ERROR, "error %d/%d.\n", wrcount, msg->len);
+			i2c_errors++;
+			bcm11xx_i2c_stop();
+			return (retval < 0) ? retval : -EFAULT;
+					  /* got a better one ?? */
+		}
+	}
+	return wrcount;
+}
+
+static int bcm11xx_readbytes(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)
+{
+	int inval;
+	int rdcount = 0;		/* counts bytes read */
+	char *temp = msg->buf;
+	int count = msg->len;
+
+	while (count > 0) {
+		inval = bcm11xx_i2c_inb((msg->flags & I2C_M_NO_RD_ACK) || (count == 1));
+		if (inval >= 0) {
+			I2C_DEBUG(DBG_TRACE2, "reading %2.2X\n", inval&0xff);
+			*temp = inval;
+			rdcount++;
+		} else {	/* read timed out */
+			i2c_errors++;
+			I2C_DEBUG(DBG_ERROR, "timed out.\n");
+			break;
+		}
+
+		temp++;
+		count--;
+	}
+	return rdcount;
+}
+
+/* doAddress initiates the transfer by generating the start condition (in
+ * try_address) and transmits the address in the necessary format to handle
+ * reads, writes as well as 10bit-addresses.
+ * returns:
+ *  0 everything went okay, the chip ack'ed, or IGNORE_NAK flag was set
+ * -x an error occurred (like: -EREMOTEIO if the device did not answer, or
+ *	-ETIMEDOUT, for example if the lines are stuck...)
+ */
+static int bcm11xx_doAddress(struct i2c_adapter *i2c_adap, struct i2c_msg *msg)
+{
+	unsigned short flags = msg->flags;
+	unsigned short nak_ok = msg->flags & I2C_M_IGNORE_NAK;
+
+	unsigned char addr;
+	int ret, retries;
+
+	retries = nak_ok ? 0 : i2c_adap->retries;
+
+	if ((flags & I2C_M_TEN)) {
+		/* a ten bit address */
+		addr = 0xf0 | ((msg->addr >> 7) & 0x03);
+		I2C_DEBUG(DBG_TRACE2, "addr: %d\n", addr);
+		/* try extended address code...*/
+		ret = bcm11xx_try_address(i2c_adap, addr, retries);
+		if ((ret != 1) && !nak_ok)  {
+			I2C_DEBUG(DBG_ERROR, "died at extended address code.\n");
+			return -EREMOTEIO;
+		}
+		/* the remaining 8 bit address */
+		ret = bcm11xx_i2c_outb(msg->addr & 0x7f);
+		if ((ret != 1) && !nak_ok) {
+			/* the chip did not ack / xmission error occurred */
+			I2C_DEBUG(DBG_ERROR, "died at 2nd address code.\n");
+			return -EREMOTEIO;
+		}
+		if (flags & I2C_M_RD) {
+			ret = bcm11xx_i2c_repstart();
+			if (ret < 0)
+				return -EIO;
+			/* okay, now switch into reading mode */
+			addr |= 0x01;
+			ret = bcm11xx_try_address(i2c_adap, addr, retries);
+			if ((ret != 1) && !nak_ok) {
+				I2C_DEBUG(DBG_ERROR, "died at extended address code.\n");
+				return -EREMOTEIO;
+			}
+		}
+	} else {		/* normal 7bit address	*/
+		addr = (msg->addr << 1);
+		if (flags & I2C_M_RD)
+			addr |= 1;
+		if (flags & I2C_M_REV_DIR_ADDR)
+			addr ^= 1;
+		ret = bcm11xx_try_address(i2c_adap, addr, retries);
+		if ((ret != 1) && !nak_ok) {
+			i2c_errors++;
+			return -EREMOTEIO;
+		}
+	}
+
+	return 0;
+}
+
+/* Master tranfer function */
+static int bcm11xx_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
+{
+	/* Based on i2c-algo-bit */
+	struct i2c_msg *pmsg;
+	int i, ret;
+	unsigned short nak_ok;
+
+	down(&i2c_lock);
+
+	/* Send first start */
+	ret = bcm11xx_i2c_start();
+	if (ret < 0) {
+		up(&i2c_lock);
+		return ret;
+	}
+
+	/* Loop through all messages */
+	for (i = 0; i < num; i++) {
+		pmsg = &msgs[i];
+		nak_ok = pmsg->flags & I2C_M_IGNORE_NAK;
+
+		if (!(pmsg->flags & I2C_M_NOSTART)) {
+			/* Send repeated start only on subsequent messages */
+			if (i) {
+				ret = bcm11xx_i2c_repstart();
+				if (ret < 0) {
+					up(&i2c_lock);
+					return ret;
+				}
+			}
+			ret = bcm11xx_doAddress(i2c_adap, pmsg);
+			if ((ret != 0) && !nak_ok) {
+				I2C_DEBUG(DBG_INFO, "NAK from device addr %2.2x msg #%d\n", msgs[i].addr, i);
+				up(&i2c_lock);
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		}
+		if (pmsg->flags & I2C_M_RD) {
+			/* read bytes into buffer*/
+			ret = bcm11xx_readbytes(i2c_adap, pmsg);
+			I2C_DEBUG(DBG_INFO, "read %d bytes.\n", ret);
+			if (ret < pmsg->len) {
+				up(&i2c_lock);
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		} else {
+			/* write bytes from buffer */
+			ret = bcm11xx_sendbytes(i2c_adap, pmsg);
+			I2C_DEBUG(DBG_INFO, "wrote %d bytes.\n", ret);
+			if (ret < pmsg->len) {
+				up(&i2c_lock);
+				return (ret < 0) ? ret : -EREMOTEIO;
+			}
+		}
+	}
+	ret = bcm11xx_i2c_stop();
+	up(&i2c_lock);
+	return (ret < 0) ? ret : num;
+}
+
+/* Controller initialization function */
+static void bcm11xx_i2c_enable_controller(struct bcm11xx_i2c *i2c)
+{
+	int rc;
+	I2C_DEBUG(DBG_TRACE, "");
+
+#if defined(CONFIG_ARCH_BCMRING)
+	/* Enable I2C clock via clock framework */
+	chipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_I2CH);
+
+	i2c_clk = clk_get(NULL, "I2C");
+	rc =  IS_ERR(i2c_clk);
+	if (rc)
+		printk(KERN_ERR "I2C: Unable to find I2C clock\n");
+
+	rc = clk_set_rate(i2c_clk, I2CHW_REG_MASTER_CLK_FREQ);
+	if (rc) {
+		printk(KERN_ERR "I2C: Failed to set the I2C clock to %lu Hz\n",
+			I2CHW_REG_MASTER_CLK_FREQ);
+	}
+
+	rc = clk_enable(i2c_clk);
+	if (rc)
+		printk(KERN_ERR "I2C: Failed to enable I2C clock\n");
+
+	I2CHw_Init();
+#endif
+
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL;	/* reset controller (EN=0) */
+	REG_I2C_RCM = 0;				/* disable CRC */
+#if defined(CONFIG_ARCH_BCMRING)
+	REG_I2C_TIM = REG_I2C_CLK_93K;			/* select clock */
+#else
+	REG_I2C_TIM = REG_I2C_CLK_85K;			/* select clock */
+#endif
+	REG_I2C_CLKEN = REG_I2C_CLKEN_CLKEN;		/* enable clock */
+	REG_I2C_ISR = REG_I2C_ISR_SES_DONE | REG_I2C_ISR_I2CERR |
+		REG_I2C_ISR_TXFIFOEMPTY | REG_I2C_ISR_NOACK;	/* clear interrupts */
+	REG_I2C_IER = REG_I2C_IER_INT_EN | REG_I2C_IER_ERRINT_EN |
+		REG_I2C_IER_NOACK_EN;	 		/* enable interrupts */
+	REG_I2C_TOUT = REG_I2C_TOUT_EN | 0x7F;		/* initialize timeout */
+	REG_I2C_FCR = REG_I2C_FCR_FLUSH;		/* flush fifo */
+	REG_I2C_CS = REG_I2C_CS_SDA | REG_I2C_CS_SCL | REG_I2C_CS_EN;  /* enable controller */
+}
+
+/* BCM11xx I2C adaptor and algorithm definitions */
+static u32 bcm11xx_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL |
+			 I2C_FUNC_10BIT_ADDR | I2C_FUNC_PROTOCOL_MANGLING;
+}
+
+static struct i2c_algorithm bcm11xx_algo = {
+	.master_xfer = bcm11xx_xfer,
+	.functionality = bcm11xx_functionality,
+};
+
+static struct i2c_adapter bcm11xx_ops = {
+	.owner = THIS_MODULE,
+	.name = "bcm11xx-i2c",
+	.id = I2C_HW_B_BCM11XX,
+	.algo = &bcm11xx_algo,
+	.timeout = 1,
+	.retries = 1
+};
+
+/* Module initialization function */
+static int i2c_bcm11xx_probe(struct platform_device *pdev)
+{
+	int rc = 0;
+
+	if (i2c) {
+		printk(KERN_INFO "BCM11xx i2c adapter module already initialized.\n");
+		return 0;
+	}
+
+	printk(KERN_INFO "BCM11xx i2c adapter module\n");
+
+	/* Allocate memory for control sturcture */
+	i2c = kmalloc(sizeof(*i2c), GFP_KERNEL);
+	if (!i2c)
+		return -ENOMEM;
+
+	memset(i2c, 0, sizeof(*i2c));
+
+	i2c->sysCtlHeader = register_sysctl_table(gSysCtl);
+
+#if defined(CONFIG_ARCH_BCMRING)
+	{
+		/* Setup GPIO MUX */
+		gpiomux_rc_e gpiorc;
+
+		gpiorc = gpiomux_requestGroup(gpiomux_group_i2ch, "I2C Host");
+		if (gpiorc != gpiomux_rc_SUCCESS) {
+			printk(KERN_ERR "%s i2c failed to request gpio group rc=%u\n", __func__, gpiorc);
+			return -EBUSY;
+		}
+	}
+#endif
+
+#if !I2C_POLL_COMMAND_DONE
+	/* Initialize IRQ and wait queue */
+	init_waitqueue_head(&i2c->queue);
+
+	rc = request_irq(IRQ_I2C, bcm11xx_i2c_isr, IRQF_DISABLED, "bcm11xx-i2c", i2c);
+
+	if (rc < 0) {
+		printk(KERN_ERR "i2c-bcm11xx: %s failed to attach interrupt, rc = %d\n", __func__, rc);
+		goto fail_irq;
+	}
+#endif
+
+	/* Enable controller */
+	bcm11xx_i2c_enable_controller(i2c);
+
+#if ADD_TURNAROUND_DELAY
+	i2c_bus_clk_period = bcm11xx_i2c_bus_clk_period();
+	printk(KERN_DEBUG "%s:%s(): i2c_bus_clk_period[%ld]\n", __FILE__, __func__, i2c_bus_clk_period);
+#endif
+
+	/* Add I2C adaptor */
+	i2c->adap = bcm11xx_ops;
+	i2c_set_adapdata(&i2c->adap, i2c);
+	rc = i2c_add_adapter(&i2c->adap);
+	if (rc < 0) {
+		printk(KERN_ERR "i2c-bcm11xx: %s failed to add adapter, rc = %d\n", __func__, rc);
+		goto fail_add;
+	}
+
+	platform_set_drvdata(pdev, i2c);
+	return rc;
+
+fail_add:
+
+#if !I2C_POLL_COMMAND_DONE
+	free_irq(IRQ_I2C, 0);
+fail_irq:
+#endif
+
+	kfree(i2c);
+	i2c = NULL;
+	return rc;
+}
+
+/* Module exit function */
+static int i2c_bcm11xx_remove(struct platform_device *pdev)
+{
+	if (!i2c)
+		return 0;
+
+	i2c_del_adapter(&i2c->adap);
+
+#if !I2C_POLL_COMMAND_DONE
+	free_irq(IRQ_I2C, i2c);
+#endif
+
+	/* unregister sysctl table */
+	if (i2c->sysCtlHeader != NULL) {
+		unregister_sysctl_table(i2c->sysCtlHeader);
+		i2c->sysCtlHeader = NULL;
+	}
+
+	kfree(i2c);
+	i2c = NULL;
+
+#if defined(CONFIG_ARCH_BCMRING)
+	I2CHw_Exit();
+	/* Disable I2C clock via clock framework */
+	clk_disable(i2c_clk);
+	clk_put(i2c_clk);
+	/* free gpiomux group */
+	gpiomux_freeGroup(gpiomux_group_i2ch);
+#endif
+
+	printk(KERN_INFO "BCM11xx i2c adapter module exited\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* Power Management Suspend Callback */
+static int i2c_bcm11xx_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	down(&i2c_lock);
+	clk_disable(i2c_clk);
+	return 0;
+}
+
+/* Power Management Resume Callback */
+static int i2c_bcm11xx_resume(struct platform_device *pdev)
+{
+	int rc;
+	rc = clk_enable(i2c_clk);
+	up(&i2c_lock);
+	return rc;
+}
+#else
+#define i2c_bcm11xx_suspend    NULL
+#define i2c_bcm11xx_resume     NULL
+#endif
+
+static struct platform_driver i2c_bcm11xx_driver = {
+	.driver = {
+		.name = "bcm-i2c",
+		.owner = THIS_MODULE,
+	},
+	.probe	= i2c_bcm11xx_probe,
+	.remove  = i2c_bcm11xx_remove,
+	.suspend = i2c_bcm11xx_suspend,
+	.resume  = i2c_bcm11xx_resume,
+};
+
+int __init i2c_bcm11xx_init(void)
+{
+	init_MUTEX(&i2c_lock);
+	return platform_driver_register(&i2c_bcm11xx_driver);
+}
+
+static void i2c_bcm11xx_exit(void)
+{
+	platform_driver_unregister(&i2c_bcm11xx_driver);
+}
+
+module_init(i2c_bcm11xx_init);
+module_exit(i2c_bcm11xx_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("I2C hardware driver for BCM11xx");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c-id.h b/include/linux/i2c-id.h
index 3ae0f76..aec5f64 100644
--- a/include/linux/i2c-id.h
+++ b/include/linux/i2c-id.h
@@ -123,6 +123,8 @@
 #define I2C_HW_B_INTELFB	0x010021 /* intel framebuffer driver */
 #define I2C_HW_B_CX23885	0x010022 /* conexant 23885 based tv cards (bus1) */
 #define I2C_HW_B_AU0828		0x010023 /* auvitek au0828 usb bridge */
+#define I2C_HW_B_BCM11XX   0x01002B /* BCM11XX chipset*/
+#define I2C_HW_B_BCM5892   0x01002C /* BCM5892 chipset*/
 
 /* --- PCF 8584 based algorithms					*/
 #define I2C_HW_P_ELEK		0x020002 /* Elektor ISA Bus inteface card */
-- 
1.7.0.4

