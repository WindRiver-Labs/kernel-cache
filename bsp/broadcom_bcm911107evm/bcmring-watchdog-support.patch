From 92e579d9658291a39e3a05498f561ce658d73dbb Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Wed, 17 Mar 2010 19:39:28 +0800
Subject: [PATCH 31/47] bcmring: watchdog support

Add the hardware watchdog driver, it will reboot your system
when timeout is reached.

Original patch taken from broadcom SDK PhonexChange6.1

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/core.c                       |    2 +
 arch/arm/mach-bcmring/csp/Makefile                 |    1 +
 arch/arm/mach-bcmring/csp/wdog/Makefile            |    1 +
 arch/arm/mach-bcmring/csp/wdog/wdogHw.c            |  187 +++++++++
 arch/arm/mach-bcmring/include/csp/wdogHw.h         |  105 +++++
 .../arm/mach-bcmring/include/mach/csp/wdogHw_reg.h |   57 +++
 drivers/watchdog/Kconfig                           |    9 +
 drivers/watchdog/Makefile                          |    1 +
 drivers/watchdog/bcmring_wdt.c                     |  398 ++++++++++++++++++++
 9 files changed, 761 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/csp/wdog/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/wdog/wdogHw.c
 create mode 100644 arch/arm/mach-bcmring/include/csp/wdogHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/wdogHw_reg.h
 create mode 100644 drivers/watchdog/bcmring_wdt.c

diff --git a/arch/arm/mach-bcmring/core.c b/arch/arm/mach-bcmring/core.c
index 335e04c..2af6182 100644
--- a/arch/arm/mach-bcmring/core.c
+++ b/arch/arm/mach-bcmring/core.c
@@ -77,6 +77,7 @@ static struct amba_device name##_device = {     \
 
 AMBA_DEVICE(uartA, "uarta", UARTA, NULL, SZ_4K);
 AMBA_DEVICE(uartB, "uartb", UARTB, NULL, SZ_4K);
+AMBA_DEVICE(wdog, "WDOG", WATCHDOG, NULL, SZ_4K >> 1);
 
 static struct clk pll1_clk = {
 	.name = "PLL1",
@@ -106,6 +107,7 @@ static struct clk_lookup lookups[] = {
 static struct amba_device *amba_devs[] __initdata = {
 	&uartA_device,
 	&uartB_device,
+	&wdog_device,
 };
 
 void __init bcmring_amba_init(void)
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index 648c037..134d634 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -1,3 +1,4 @@
 obj-y += dmac/
 obj-y += tmr/
 obj-y += chipc/
+obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
diff --git a/arch/arm/mach-bcmring/csp/wdog/Makefile b/arch/arm/mach-bcmring/csp/wdog/Makefile
new file mode 100644
index 0000000..c01cf1c
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/wdog/Makefile
@@ -0,0 +1 @@
+obj-y += wdogHw.o
diff --git a/arch/arm/mach-bcmring/csp/wdog/wdogHw.c b/arch/arm/mach-bcmring/csp/wdog/wdogHw.c
new file mode 100644
index 0000000..d9c768e
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/wdog/wdogHw.c
@@ -0,0 +1,187 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file    wdogHw.c
+*
+*  @brief   Low level Watchdog driver routines
+*
+*  @note
+*
+*   These routines provide basic watchdog functionality only.
+*/
+/****************************************************************************/
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <csp/errno.h>
+#include <csp/stdint.h>
+
+#include <csp/wdogHw.h>
+#include <csp/reg.h>
+#include <mach/csp/wdogHw_reg.h>
+
+#define wdoghw_MILISEC_PER_SEC	(1000)
+#define wdoghw_MS_COUNT		(wdoghw_CLOCK_RESOLUTION / wdoghw_MILISEC_PER_SEC)
+#define wdoghw_MAX_MILISEC	(0xFFFFFFFF / wdoghw_MS_COUNT)
+
+
+
+/****************************************************************************/
+/**
+*  @brief   Resets watchdog
+*
+*  This function initializes  watchdog
+*
+*  @return  void
+*
+*/
+/****************************************************************************/
+static void ResetWatchdog(void)
+{
+	/* Reset Watchdog */
+	reg32_write(&pWdogHw->LoadValue, 1);
+	reg32_write(&pWdogHw->Control, 0);
+	reg32_write(&pWdogHw->InterruptClear, 0);
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_ENABLE);
+}
+
+
+/****************************************************************************/
+/**
+*  @brief   Sets counter value for an interval in ms
+*
+*  @return   On success: Effective counter value set
+*            On failure: 0
+*
+*/
+/****************************************************************************/
+static uint32_t SetWatchdogPeriod(uint32_t msec)
+{
+	if (msec <= wdoghw_MAX_MILISEC)
+		reg32_write(&pWdogHw->LoadValue, (msec * wdoghw_MS_COUNT));
+	else
+		return 0;
+	return msec;
+}
+
+/****************************************************************************/
+/**
+*  @brief   Configures a periodic Watch dog to generate Watch dog interrupt after
+*           certain time interval
+*
+*  This function initializes a periodic Watch dog to generate Watch dog
+*  interrupt after every time interval in milisecond
+*
+*  @return   On success: Effective interval set in mili-second
+*            On failure: 0
+*
+*/
+/****************************************************************************/
+uint32_t wdogHw_setWatchdogInterval(uint32_t msec)
+{
+	ResetWatchdog();
+	return SetWatchdogPeriod(msec);
+}
+
+
+/****************************************************************************/
+/**
+*  @brief   Starts a Watch dog
+*
+*  This function starts a preconfigured Watch dog
+*
+*  @return  -1     - On Failure
+*            0     - On Success
+*/
+/****************************************************************************/
+int wdogHw_startWatchdog(void)
+{
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_ENABLE);
+	reg32_set_bits(&pWdogHw->Control, wdoghw_CONTROL_INTERRUPT_ENABLE | wdoghw_CONTROL_RESET_ENABLE);
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_DISABLE);
+	return 0;
+}
+
+
+/****************************************************************************/
+/**
+*  @brief   Stops a Watch dog
+*
+*  This function stops a running Watch dog
+*
+*  @return  -1     - On Failure
+*            0     - On Success
+*/
+/****************************************************************************/
+int wdogHw_stopWatchdog(void)
+{
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_ENABLE);
+	reg32_clear_bits(&pWdogHw->Control, wdoghw_CONTROL_INTERRUPT_ENABLE | wdoghw_CONTROL_RESET_ENABLE);
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_DISABLE);
+	return 0;
+}
+
+
+
+/****************************************************************************/
+/**
+*  @brief   Restarts the watchdog
+*
+*  This function reloads the watchdog timer
+*
+*  @return   ms to expire
+*
+*/
+/****************************************************************************/
+uint32_t wdogHw_restartWatchdog(void)
+{
+	uint32_t curvalue = reg32_read(&pWdogHw->CurrentValue);
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_ENABLE);
+	reg32_write(&pWdogHw->InterruptClear, 0x1);
+	reg32_write(&pWdogHw->WatchdogLock, wdoghw_LOCK_WRITE_DISABLE);
+	return curvalue / wdoghw_MS_COUNT;
+}
+
+
+/****************************************************************************/
+/**
+*  @brief   Displays Watchdog registers
+*
+*
+*  @return  void
+*
+*/
+/****************************************************************************/
+void wdogHw_printDebugInfo(int (*fpPrint) (const char *, ...))
+{
+	(*fpPrint)("Displaying register contents \n\n");
+	(*fpPrint)("Watchdog: Load value              0x%X\n",
+			reg32_read(&pWdogHw->LoadValue));
+	(*fpPrint)("Watchdog: Current value           0x%X\n",
+			reg32_read(&pWdogHw->CurrentValue));
+	(*fpPrint)("Watchdog: Control                 0x%X\n",
+			reg32_read(&pWdogHw->Control));
+	(*fpPrint)("Watchdog: Interrupt clear         0x%X\n",
+			reg32_read(&pWdogHw->InterruptClear));
+	(*fpPrint)("Watchdog: Interrupt raw interrupt 0x%X\n",
+			reg32_read(&pWdogHw->RawInterruptStatus));
+	(*fpPrint)("Watchdog: Interrupt status        0x%X\n",
+			reg32_read(&pWdogHw->InterruptStatus));
+	(*fpPrint)("Watchdog: Lock write              0x%X\n",
+			reg32_read(&pWdogHw->WatchdogLock));
+}
diff --git a/arch/arm/mach-bcmring/include/csp/wdogHw.h b/arch/arm/mach-bcmring/include/csp/wdogHw.h
new file mode 100644
index 0000000..6ced5ee
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/wdogHw.h
@@ -0,0 +1,105 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    wdogHw.h
+*
+*  @brief   API definitions for low level Watch Dog driver
+*
+*/
+/****************************************************************************/
+#ifndef WDOGHW_H
+#define WDOGHW_H
+
+/****************************************************************************/
+/**
+*  @brief   Configures a periodic Watch dog to generate Watch dog interrupt after
+*           certain time interval
+*
+*  This function initializes a periodic Watch dog to generate Watch dog
+*  interrupt after every time interval in milisecond
+*
+*  @return   On success: Effective interval set in mili-second
+*            On failure: 0
+*
+*/
+/****************************************************************************/
+uint32_t wdogHw_setWatchdogInterval(uint32_t msec);
+
+
+
+/****************************************************************************/
+/**
+*  @brief   Starts a Watchdog
+*
+*  This function starts a preconfigured Watchdog
+*
+*  @return  -1     - On Failure
+*            0     - On Success
+*/
+/****************************************************************************/
+int wdogHw_startWatchdog(void);
+
+
+/****************************************************************************/
+/**
+*  @brief   Stops a Watchdog
+*
+*  This function stops a running Watch dog
+*
+*  @return  -1     - On Failure
+*            0     - On Success
+*/
+/****************************************************************************/
+int wdogHw_stopWatchdog(void);
+
+
+/****************************************************************************/
+/**
+*  @brief   Restarts the watchdog
+*
+*  This function reloads the watchdog timer
+*
+*  @return   ms to expire
+*
+*/
+/****************************************************************************/
+uint32_t wdogHw_restartWatchdog(void);
+
+
+/****************************************************************************/
+/**
+*  @brief   Displays specific Watch dog registers
+*
+*
+*  @return  void
+*
+*/
+/****************************************************************************/
+void wdogHw_printDebugInfo(int (*fpPrint) (const char *, ...));
+
+
+#endif /* WDOGHW_H */
+
+
+
+
+
+
+
+
diff --git a/arch/arm/mach-bcmring/include/mach/csp/wdogHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/wdogHw_reg.h
new file mode 100644
index 0000000..cd3d59d
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/wdogHw_reg.h
@@ -0,0 +1,57 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    wdogHw_reg.h
+*
+*  @brief   Definitions for low level watchdog registers
+*
+*/
+/****************************************************************************/
+#ifndef WDOGHW_REG_H
+#define WDOGHW_REG_H
+
+#include <mach/csp/mm_io.h>
+
+#define wdoghw_MODULE_BASE_ADDR       MM_IO_BASE_WATCHDOG
+
+#define wdoghw_CLOCK_RESOLUTION       (25 * 1000 * 1000) /* Hz */
+
+typedef struct {
+	uint32_t LoadValue;                /* Load value for timer */
+	uint32_t CurrentValue;             /* Current value for timer */
+	uint32_t Control;                  /* Control register */
+	uint32_t InterruptClear;           /* Interrupt clear register */
+	uint32_t RawInterruptStatus;       /* Raw interrupt status */
+	uint32_t InterruptStatus;          /* Masked interrupt status */
+	uint32_t pad[250];                 /* padding */
+	uint32_t WatchdogLock;             /* Lock register */
+} wdoghw_REG_t;
+
+/* Control bit masks */
+#define wdoghw_CONTROL_INTERRUPT_ENABLE        0x00000001
+#define wdoghw_CONTROL_RESET_ENABLE            0x00000002
+
+#define wdoghw_STATUS_INTERRUPT                0x00000001
+
+#define wdoghw_LOCK_WRITE_DISABLE              0x0ACCE550
+#define wdoghw_LOCK_WRITE_ENABLE               0x1ACCE551
+
+#define pWdogHw ((volatile wdoghw_REG_t *)wdoghw_MODULE_BASE_ADDR)
+
+#endif /* WDOGHW_REG_H */
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 8b5bfde..719781c 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -58,6 +58,15 @@ config SOFT_WATCHDOG
 # ALPHA Architecture
 
 # ARM Architecture
+config BCMRING_WATCHDOG
+	tristate "BCMRING watchdog"
+	depends on WATCHDOG && ( ARCH_BCMRING )
+	help
+	  Watchdog timer embedded into BCMRING chips. This will
+	  reboot your system when timeout is reached.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bcmring_wdt.
 
 config AT91RM9200_WATCHDOG
 	tristate "AT91RM9200 watchdog"
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 0a32c33..6156875 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_USBPCWATCHDOG) += pcwd_usb.o
 # ALPHA Architecture
 
 # ARM Architecture
+obj-$(CONFIG_BCMRING_WATCHDOG) += bcmring_wdt.o
 obj-$(CONFIG_AT91RM9200_WATCHDOG) += at91rm9200_wdt.o
 obj-$(CONFIG_OMAP_WATCHDOG) += omap_wdt.o
 obj-$(CONFIG_21285_WATCHDOG) += wdt285.o
diff --git a/drivers/watchdog/bcmring_wdt.c b/drivers/watchdog/bcmring_wdt.c
new file mode 100644
index 0000000..9c3d45f
--- /dev/null
+++ b/drivers/watchdog/bcmring_wdt.c
@@ -0,0 +1,398 @@
+/*****************************************************************************
+* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
+*
+*  Unless you and Broadcom execute a separate written software license
+*  agreement governing use of this software, this software is licensed to you
+*  under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+*  Notwithstanding the above, under no circumstances may you combine this
+*  software in any way with any other Broadcom software provided under a
+*  license other than the GPL, without Broadcom's express prior written
+*  consent.
+*****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <csp/wdogHw.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <linux/interrupt.h>
+#include <mach/irqs.h>
+
+#include <linux/device.h>
+#include <linux/amba/bus.h>
+#include <linux/platform_device.h>
+
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+#define PFX "watchdog: "
+
+#define WATCHDOG_MAX_TIMEOUT 60		/* 60 sec default timeout */
+
+static uint32_t tmr_margin = WATCHDOG_MAX_TIMEOUT;
+module_param(tmr_margin, int, 0);
+MODULE_PARM_DESC(tmr_margin, "WDT timer margin in seconds. default=" __MODULE_STRING(WATCHDOG_MAX_TIMEOUT) ")");
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started (default=" __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+static int boot_status;
+
+static DECLARE_MUTEX(open_lock);
+
+typedef enum close_state {
+	CLOSE_STATE_NOT,
+	CLOSE_STATE_ALLOW = 0x4021
+} close_state_t;
+
+static close_state_t allow_close;
+static int timer_activated;
+
+static void watchdog_start(void)
+{
+	wdogHw_startWatchdog();
+}
+
+static void watchdog_stop(void)
+{
+	if (allow_close == CLOSE_STATE_ALLOW) {
+		wdogHw_stopWatchdog();
+		printk(KERN_INFO PFX "Stopped watchdog timer.\n");
+	} else {
+		printk(KERN_INFO PFX "Did NOT stop watchdog timer.\n");
+	}
+}
+
+/*
+ *	watchdog_keepalive - reload the timer
+ *
+ */
+static void watchdog_keepalive(void)
+{
+	wdogHw_restartWatchdog();
+}
+
+/****************************************************************************
+*
+*  watchdog_interrupt
+*
+***************************************************************************/
+static irqreturn_t watchdog_interrupt(int irq, void *data)
+{
+#if defined(CFG_GLOBAL_WDOG_QUIET) && CFG_GLOBAL_WDOG_QUIET
+	static int first = 1;
+
+	if (first) {
+		/* "Quiet" mode, so just print message once */
+#endif
+	printk(KERN_INFO PFX "watchdog interrupt - we're all going to die!\n");
+#if defined(CFG_GLOBAL_WDOG_QUIET) && CFG_GLOBAL_WDOG_QUIET
+		first = 0;
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *	/dev/watchdog handling
+ *	Allow only one person to hold it open
+*/
+static int watchdog_open(struct inode *inode, struct file *file)
+{
+	if (down_trylock(&open_lock))
+		return -EBUSY;
+
+	if (nowayout)
+		__module_get(THIS_MODULE);
+	else
+		allow_close = CLOSE_STATE_ALLOW;
+
+	/* Activate timer */
+	timer_activated = 1;
+	watchdog_start();
+	watchdog_keepalive();
+
+	printk(KERN_INFO "Started watchdog timer.\n");
+
+	return nonseekable_open(inode, file);
+}
+
+static int watchdog_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * Shut off the timer.
+	 *	Lock it in if it's a module and we set nowayout
+	 */
+	if (allow_close == CLOSE_STATE_ALLOW) {
+		watchdog_stop();		/* Turn the WDT off */
+	} else {
+		printk(KERN_INFO "not stopping watchdog!\n");
+		watchdog_keepalive();
+	}
+
+	allow_close = CLOSE_STATE_NOT;
+	up(&open_lock);
+	return 0;
+}
+
+static ssize_t watchdog_write(struct file *file, const char *data, size_t len,
+				loff_t *ppos)
+{
+	/* Refresh the timer. */
+	if (len) {
+		if (!nowayout) {
+			if (data[0] == 'N') {
+				/* Lock the watchdog driver and do not allow it
+				 * to be shutdown */
+				allow_close = CLOSE_STATE_NOT;
+				nowayout = 1;
+			}
+		}
+		watchdog_keepalive();
+	}
+	return len;
+}
+
+static struct watchdog_info ident = {
+	.options		= WDIOF_CARDRESET | WDIOF_SETTIMEOUT |
+				  WDIOF_KEEPALIVEPING | WDIOF_MAGICCLOSE,
+	.firmware_version	= 0,
+	.identity		= "Hardware Watchdog",
+};
+
+static int watchdog_ioctl(struct inode *inode, struct file *file,
+				  unsigned int cmd, unsigned long arg)
+{
+	int ret = -ENOIOCTLCMD;
+	int time, options;
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+
+	switch (cmd) {
+	default:
+		break;
+	case WDIOC_GETSUPPORT:
+		ret = copy_to_user(argp, &ident,
+			sizeof(ident)) ? -EFAULT : 0;
+		break;
+
+	case WDIOC_GETSTATUS:
+		ret = put_user(0, p);
+		break;
+
+	case WDIOC_GETBOOTSTATUS:
+		ret = put_user(boot_status, p);
+		break;
+
+	case WDIOC_SETOPTIONS:
+		ret = get_user(options, p);
+		if (ret)
+			break;
+
+		if (options & WDIOS_DISABLECARD) {
+			watchdog_stop();
+			ret = 0;
+		}
+
+		if (options & WDIOS_ENABLECARD) {
+			watchdog_start();
+			ret = 0;
+		}
+		break;
+
+	case WDIOC_SETTIMEOUT:
+		ret = get_user(time, p);
+		if (ret)
+			break;
+
+		if (time <= 0 || time > WATCHDOG_MAX_TIMEOUT) {
+			ret = -EINVAL;
+			break;
+		}
+
+		tmr_margin = wdogHw_setWatchdogInterval(time*1000)/1000;
+		if (tmr_margin != time) {
+			ret = -EINVAL;
+			break;
+		}
+		/*fall through*/
+	case WDIOC_GETTIMEOUT:
+		ret = put_user(tmr_margin, p);
+		break;
+
+	case WDIOC_KEEPALIVE:
+		watchdog_keepalive();
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+/*
+ *	Notifier for system down
+ */
+
+static int watchdog_notify_sys(struct notifier_block *this, unsigned long code,
+				void *unused)
+{
+	if (code == SYS_DOWN || code == SYS_HALT)
+		watchdog_stop();		/* Turn the WDT off */
+
+	return NOTIFY_DONE;
+}
+
+/*
+ *	Kernel Interfaces
+ */
+static struct file_operations watchdog_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= watchdog_write,
+	.ioctl		= watchdog_ioctl,
+	.open		= watchdog_open,
+	.release	= watchdog_release,
+};
+
+static struct miscdevice watchdog_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &watchdog_fops,
+};
+
+static struct notifier_block watchdog_notifier = {
+	.notifier_call = watchdog_notify_sys,
+};
+
+static const __devinitconst char banner[] =
+	KERN_INFO PFX "BROADCOM WDT driver\n";
+
+
+static int __devinit bcmring_wdt_probe(struct amba_device *pdev, void *id)
+{
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	printk(banner);
+
+	/* Setup interrupt handler for 1/2 done watchdog interrupt */
+	ret = request_irq(IRQ_WATCHDOG, watchdog_interrupt, 0, "wdog", dev);
+	if (ret) {
+		printk(KERN_ERR "Failed to get wdog IRQ\n");
+		return ret;
+	}
+
+	/*
+	 * Determine if the watchdog reset occured or if it was a normal
+	 * power-up
+	 */
+	boot_status = 0;
+	if (chipcHw_getStickyBits() & chipcHw_REG_STICKY_WDOG_RESET) {
+		/* Watchdog reset occured */
+		boot_status = 1;
+		chipcHw_clearStickyBits(chipcHw_REG_STICKY_WDOG_RESET);
+	}
+
+	/* This call checks if timeout is valid */
+	wdogHw_setWatchdogInterval(tmr_margin*1000);
+
+	ret = register_reboot_notifier(&watchdog_notifier);
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register reboot notifier (err=%d)\n",
+			ret);
+		return ret;
+	}
+
+	ret = misc_register(&watchdog_miscdev);
+	if (ret) {
+		printk(KERN_ERR PFX "cannot register miscdev on minor=%d (err=%d)\n",
+			WATCHDOG_MINOR, ret);
+		unregister_reboot_notifier(&watchdog_notifier);
+	}
+
+	return ret;
+}
+
+static int bcmring_wdt_remove(struct amba_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	misc_deregister(&watchdog_miscdev);
+	unregister_reboot_notifier(&watchdog_notifier);
+
+	free_irq(IRQ_WATCHDOG, dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int bcmring_wdt_suspend(struct amba_device *pdev, pm_message_t msg)
+{
+	if (allow_close == CLOSE_STATE_ALLOW) {
+		watchdog_stop();		/* Turn the WDT off */
+		allow_close = CLOSE_STATE_NOT;
+	}
+
+	return 0;
+}
+
+static int bcmring_wdt_resume(struct amba_device *pdev)
+{
+	if (!nowayout && timer_activated) {
+		/* re-activate timer */
+		watchdog_start();
+		watchdog_keepalive();
+		allow_close = CLOSE_STATE_ALLOW;
+	}
+
+	return 0;
+}
+#else
+#define bcmring_wdt_suspend    NULL
+#define bcmring_wdt_resume     NULL
+#endif
+
+static struct amba_id bcmring_id_table[] __initdata = {
+	{
+		.id	= 0x00041805,
+		.mask	= 0x000fffff,
+	},
+	{ 0, 0 },
+};
+
+static struct amba_driver bcmring_driver = {
+	.drv = {
+		.name	= "bcmring-wdt",
+	},
+	.probe		= bcmring_wdt_probe,
+	.remove		= bcmring_wdt_remove,
+	.suspend	= bcmring_wdt_suspend,
+	.resume		= bcmring_wdt_resume,
+	.id_table	= bcmring_id_table,
+};
+
+static int __init watchdog_init(void)
+{
+	return amba_driver_register(&bcmring_driver);
+}
+module_init(watchdog_init);
+
+static void __exit watchdog_exit(void)
+{
+	amba_driver_unregister(&bcmring_driver);
+}
+module_exit(watchdog_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("BROADCOM WDT");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
-- 
1.7.0.4

