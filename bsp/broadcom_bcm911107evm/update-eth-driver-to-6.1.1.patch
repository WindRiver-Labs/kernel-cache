From 5db65d2124718f4e0b70b6e6d5d03be09eb7fc6e Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Fri, 21 May 2010 11:28:25 +0800
Subject: [PATCH 44/47] update eth driver to 6.1.1

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/arch.c                       |    6 +
 arch/arm/mach-bcmring/csp/Makefile                 |    1 +
 arch/arm/mach-bcmring/csp/eth/Makefile             |    1 +
 arch/arm/mach-bcmring/csp/eth/ethDma.c             |  178 ++
 arch/arm/mach-bcmring/csp/eth/ethDma.h             |  122 ++
 arch/arm/mach-bcmring/csp/eth/ethHw.c              |  745 ++++++++
 arch/arm/mach-bcmring/csp/eth/ethHw_asm.S          |   49 +
 arch/arm/mach-bcmring/include/csp/ethHw.h          |  423 +++++
 .../arm/mach-bcmring/include/mach/csp/dmacHw_reg.h |    2 +
 .../include/mach/csp/dmacHw_reg_standalone.h       |   29 +
 arch/arm/mach-bcmring/include/mach/csp/ethHw_dma.h |  247 +++
 arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h |  370 ++++
 arch/arm/mach-bcmring/include/mach/pm.h            |   57 +
 drivers/net/Kconfig                                |   15 +
 drivers/net/Makefile                               |    1 +
 drivers/net/bcmring_ethtool.c                      |  881 +++++++++
 drivers/net/bcmring_net.c                          | 1990 ++++++++++++++++++++
 17 files changed, 5117 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/csp/eth/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/eth/ethDma.c
 create mode 100644 arch/arm/mach-bcmring/csp/eth/ethDma.h
 create mode 100644 arch/arm/mach-bcmring/csp/eth/ethHw.c
 create mode 100644 arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
 create mode 100644 arch/arm/mach-bcmring/include/csp/ethHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg_standalone.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/ethHw_dma.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/pm.h
 create mode 100644 drivers/net/bcmring_ethtool.c
 create mode 100644 drivers/net/bcmring_net.c

diff --git a/arch/arm/mach-bcmring/arch.c b/arch/arm/mach-bcmring/arch.c
index 5c11e49..46dd70a 100644
--- a/arch/arm/mach-bcmring/arch.c
+++ b/arch/arm/mach-bcmring/arch.c
@@ -91,6 +91,11 @@ static struct platform_device nand_device = {
 	.num_resources	= ARRAY_SIZE(nand_resource),
 };
 
+static struct platform_device net_device = {
+	.name = "bcmring-net",
+	.id = -1,
+};
+
 static struct platform_device i2c_device = {
 	.name = "bcm-i2c",
 	.id = -1,
@@ -98,6 +103,7 @@ static struct platform_device i2c_device = {
 
 static struct platform_device *devices[] __initdata = {
 	&nand_device,
+	&net_device,
 	&i2c_device,
 };
 
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index 979c23c..ce693bd 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -6,3 +6,4 @@ obj-y += gpiomux/
 obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
 obj-$(CONFIG_I2C_BCM11XX) += i2c/
 obj-$(CONFIG_SPI_BCMRING) += spi/
+obj-$(CONFIG_NET_BCMRING) += eth/
diff --git a/arch/arm/mach-bcmring/csp/eth/Makefile b/arch/arm/mach-bcmring/csp/eth/Makefile
new file mode 100644
index 0000000..c6732e6
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/eth/Makefile
@@ -0,0 +1 @@
+obj-y += ethHw_asm.o ethHw.o ethDma.o
diff --git a/arch/arm/mach-bcmring/csp/eth/ethDma.c b/arch/arm/mach-bcmring/csp/eth/ethDma.c
new file mode 100644
index 0000000..41863fc
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/eth/ethDma.c
@@ -0,0 +1,178 @@
+/*****************************************************************************
+* Copyright 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <csp/stdint.h>
+#include "ethDma.h"
+
+int ethVerbose;
+
+#if 0
+#include <csp/stdio.h>
+#define SET8(a, b) \
+do { \
+	REG8((a)) = (b); \
+	if (ethVerbose) \
+		printf("REG8(0x%08x)  = 0x%02x;\n", (a), (b));
+} while (0)
+
+#define SET32(a, b) \
+do { \
+	REG32((a)) = (b); \
+	if (ethVerbose) \
+		printf("REG32(0x%08x) = 0x%08x;\n", (a), (b));
+} while (0)
+#else
+#define SET8(a, b)    REG8((a)) = (b)
+#define SET32(a, b)   REG32((a)) = (b)
+#endif
+
+int dmaTxConfig(int burst)
+{
+	uint8_t reg8;
+
+	reg8 = REG8(0x3041a030);
+	SET8(0x3041a030, reg8 | 0x01);
+	if (REG32(0x80000000) == 0x11070a00)
+		SET32(0x30490000, 0x90000001 | (burst << 1));
+	else {
+		/*
+		 * Non-A0 silicon requires the burst size in the bus i/f to be one
+		 * greater than the DMA burst length
+		 */
+		SET32(0x30490000, 0x90000001 | ((burst + 1) << 1));
+	}
+
+	return 1;
+}
+
+
+int dmaRxConfig(int burst, int block)
+{
+	SET32(0x30480008, 0x90000000 | (burst << 1) | (block << 10));
+
+	return 1;
+}
+
+
+int dmaInit(int controller)
+{
+	register uint32_t controllerOffset;
+
+	controllerOffset = controller * 0x00100000;
+
+	SET32(0x30200398 + controllerOffset, 0x00000001);
+	SET32(0x3020039c + controllerOffset, 0x00000000);
+
+	return 1;
+}
+
+
+#if 1
+int dmaConfig(int controller, int ch,
+	      uint32_t ctlHi, uint32_t ctlLo,
+	      uint32_t cfgHi, uint32_t cfgLo,
+	      uint32_t sstat, uint32_t dstat)
+{
+	register uint32_t controllerOffset;
+	register uint32_t chOffset;
+
+	controllerOffset = controller * 0x00100000;
+	chOffset = ch * 0x58;
+
+	SET32(0x30200018 + controllerOffset + chOffset, ctlLo);
+	SET32(0x3020001c + controllerOffset + chOffset, ctlHi);
+	SET32(0x30200040 + controllerOffset + chOffset, cfgLo);
+	SET32(0x30200044 + controllerOffset + chOffset, cfgHi);
+	SET32(0x30200030 + controllerOffset + chOffset, sstat);
+	SET32(0x30200034 + controllerOffset + chOffset, 0x00000000);
+	SET32(0x30200038 + controllerOffset + chOffset, dstat);
+	SET32(0x3020003c + controllerOffset + chOffset, 0x00000000);
+
+	return 1;
+}
+#else
+int dmaConfig(int controller, int ch)
+{
+	register uint32_t controllerOffset;
+	register uint32_t chOffset;
+
+	controllerOffset = controller * 0x00100000;
+	chOffset = ch * 0x58;
+
+	SET32(0x30200018 + controllerOffset + chOffset, 0x18901036);
+	SET32(0x3020001c + controllerOffset + chOffset, 0x00000000);
+	SET32(0x30200040 + controllerOffset + chOffset, 0x000000e0);
+	SET32(0x30200044 + controllerOffset + chOffset, 0x00000826);
+	SET32(0x30200038 + controllerOffset + chOffset, 0x30490010);
+	SET32(0x3020003c + controllerOffset + chOffset, 0x00000000);
+
+	return 1;
+}
+#endif
+
+
+int dmaIntClr(int controller, int ch)
+{
+	register uint32_t controllerOffset;
+	register uint32_t mask;
+
+	controllerOffset = controller * 0x00100000;
+	mask = 0x0001 << ch;
+
+	SET32(0x30200338 + controllerOffset, mask);
+	SET32(0x3020033c + controllerOffset, 0x00000000);
+	SET32(0x30200340 + controllerOffset, mask);
+	SET32(0x30200344 + controllerOffset, 0x00000000);
+	SET32(0x30200348 + controllerOffset, mask);
+	SET32(0x3020034c + controllerOffset, 0x00000000);
+	SET32(0x30200350 + controllerOffset, mask);
+	SET32(0x30200354 + controllerOffset, 0x00000000);
+	SET32(0x30200358 + controllerOffset, mask);
+	SET32(0x3020035c + controllerOffset, 0x00000000);
+
+	return 1;
+}
+
+
+int dmaEnable(int controller, int ch, void *descp)
+{
+	register uint32_t controllerOffset;
+	register uint32_t chOffset;
+	register uint32_t mask;
+
+	controllerOffset = controller * 0x00100000;
+	chOffset = ch * 0x58;
+	mask = 0x0101 << ch;
+
+	SET32(0x30200010 + controllerOffset + chOffset, (uint32_t)(descp));
+	SET32(0x302003a0 + controllerOffset, mask);
+	SET32(0x302003a4 + controllerOffset, 0x00000000);
+
+	return 1;
+}
+
+
+int dmaDisable(int controller, int ch)
+{
+	register uint32_t controllerOffset;
+	register uint32_t mask;
+
+	controllerOffset = controller * 0x00100000;
+	mask = 0x0100 << ch;
+
+	SET32(0x302003a0 + controllerOffset, mask);
+	SET32(0x302003a4 + controllerOffset, 0x00000000);
+
+	return 1;
+}
diff --git a/arch/arm/mach-bcmring/csp/eth/ethDma.h b/arch/arm/mach-bcmring/csp/eth/ethDma.h
new file mode 100644
index 0000000..85697eb
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/eth/ethDma.h
@@ -0,0 +1,122 @@
+/*****************************************************************************
+* Copyright 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#ifndef _ETHDMA_H
+#define _ETHDMA_H
+
+#include <csp/stdint.h>
+
+#define CFG_EOP_MASK             0x00010000
+#define CFG_OFFSET(bp, len)      ((CFG_OFFSET_LAST((bp), (len)) << 8) | \
+				 (CFG_OFFSET_INIT((bp))))
+#define CFG_OFFSET_INIT(bp)      ((uint32_t)(bp) % 8)
+#define CFG_OFFSET_LAST(bp, len) ((((uint32_t)(bp) + (len)) - 1) % 8)
+
+#define DMA_MTP_TRANSACTION_SIZE(len)  (((len) + 7) / 8)
+
+#define DMA_MTP_FIFO_ADDR_CFG    0x30490008
+#define DMA_MTP_FIFO_ADDR_DATA   0x30498000
+
+#define DMA_MTP_CTL_LO           0x18901036     /* See data sheet for bit details */
+#define DMA_MTP_CTL_HI           0x00000000
+#define DMA_MTP_CFG_LO           0x000000e0
+#define DMA_MTP_CFG_HI           0x00000826
+#define DMA_MTP_DSTAT            0x30490010
+
+#define DMA_PTM_FIFO_ADDR        0x30488000
+
+#define DMA_PTM_CTL_LO           0x1a408036     /* See data sheet for bit details */
+#define DMA_PTM_CTL_HI           0x00000000
+#define DMA_PTM_CFG_LO           0x000000e0
+#define DMA_PTM_CFG_HI           0x00000046
+#define DMA_PTM_SSTAT            0x30480010
+
+
+#define DMA_DESC_CREATE(descp, _sar, _dar, _ctlLo, _ctlHi) \
+do { \
+	(descp)->sar = MM_IO_VIRT_TO_PHYS((uint32_t)(_sar)); \
+	(descp)->dar = MM_IO_VIRT_TO_PHYS((uint32_t)(_dar)); \
+	(descp)->lli = MM_IO_VIRT_TO_PHYS((uint32_t)((descp) + 1)); \
+	(descp)->ctlLo = (_ctlLo); \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+	(descp)->stat2 = 0; \
+	(descp)->rsvd = 0; \
+} while (0)
+
+#define DMA_DESC_CREATE_NEXT(descp, _sar, _dar, _lli, _ctlLo, _ctlHi) \
+do { \
+	(descp)->sar = MM_IO_VIRT_TO_PHYS((uint32_t)(_sar)); \
+	(descp)->dar = MM_IO_VIRT_TO_PHYS((uint32_t)(_dar)); \
+	(descp)->lli = MM_IO_VIRT_TO_PHYS((uint32_t)(_lli)); \
+	(descp)->ctlLo = (_ctlLo); \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+	(descp)->stat2 = 0; \
+	(descp)->rsvd = 0; \
+} while (0)
+
+#define DMA_DESC_RX_UPDATE(descp, _ctlHi) \
+do { \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+} while (0)
+
+
+typedef struct {
+	uint32_t sar;
+	uint32_t dar;
+	uint32_t lli;
+	uint32_t ctlLo;
+	uint32_t ctlHi;
+	uint32_t stat1;
+	uint32_t stat2;
+	uint32_t rsvd;       /* To create buffers on 64-bit alignment */
+} DMA_DESC;
+
+/* Force to 64-bit alignment */
+#define DMA_ALIGN    __attribute__ ((aligned (16)))
+
+/* DMA setup extracted from sim environment. */
+
+#ifndef REG32
+#define REG32(x)     (*((volatile uint32_t *)(x)))
+#endif
+
+#ifndef REG8
+#define REG8(x)      (*((volatile uint8_t *)(x)))
+#endif
+
+#define dmaRxReady(descp)     ((descp)->ctlHi & 0x1000)
+#define dmaDescNext(descp)    ((DMA_DESC *)(descp)->lli)
+#define dmaDescCreate         DMA_DESC_CREATE
+#define dmaDescCreateNext     DMA_DESC_CREATE_NEXT
+#define dmaDescRxUpdate       DMA_DESC_RX_UPDATE
+
+extern int dmaTxConfig(int burst);
+extern int dmaRxConfig(int burst, int block);
+extern int dmaInit(int controller);
+#if 1
+int dmaConfig(int controller, int ch,
+	      uint32_t ctlHi, uint32_t ctlLo,
+	      uint32_t cfgHi, uint32_t cfgLo,
+	      uint32_t sstat, uint32_t dstat);
+#else
+extern int dmaConfig(int controller, int ch);
+#endif
+extern int dmaIntClr(int controller, int ch);
+extern int dmaEnable(int controller, int ch, void *descp);
+extern int dmaDisable(int controller, int ch);
+
+#endif
diff --git a/arch/arm/mach-bcmring/csp/eth/ethHw.c b/arch/arm/mach-bcmring/csp/eth/ethHw.c
new file mode 100644
index 0000000..f29ebfa
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/eth/ethHw.c
@@ -0,0 +1,745 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+/****************************************************************************/
+/**
+*  @file    ethHw.c
+*
+*  @brief   Low level ETH driver routines
+*
+*  @note
+*
+*   These routines provide basic ETH functionality only. Intended for use
+*   with boot and other simple applications.
+*/
+/****************************************************************************/
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <csp/string.h>
+#include <csp/module.h>
+#include <csp/delay.h>
+
+#include <csp/ethHw.h>
+
+#include <mach/csp/ethHw_reg.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <mach/csp/secHw_def.h>
+#include <mach/csp/cap.h>
+
+/* ---- External Variable Declarations ----------------------------------- */
+/* ---- External Function Prototypes ------------------------------------- */
+/* ---- Public Variables ------------------------------------------------- */
+/* ---- Private Constants and Types -------------------------------------- */
+/* ---- Private Variables ------------------------------------------------ */
+
+static uint16_t linkStatChg;
+
+#define ONE_MHZ      (1 * 1000 * 1000)
+#define CLOCK_FREQ   (100 * ONE_MHZ)
+
+/* ---- Private Function Prototypes -------------------------------------- */
+/* TODO: handle endianness */
+/* mactou64(mac) and u64tomac(u64, mac) assumed little endian */
+
+#define mactou64(mac)   (((uint64_t)((mac)[0]) << 40) + ((uint64_t)((mac)[1]) << 32) + \
+			 ((uint64_t)((mac)[2]) << 24) + ((uint64_t)((mac)[3]) << 16) + \
+			 ((uint64_t)((mac)[4]) << 8) + ((uint64_t)((mac)[5])))
+
+#define u64tomac(u64, mac) {\
+	mac[0] = ((uint8_t *)&u64)[5]; \
+	mac[1] = ((uint8_t *)&u64)[4]; \
+	mac[2] = ((uint8_t *)&u64)[3]; \
+	mac[3] = ((uint8_t *)&u64)[2]; \
+	mac[4] = ((uint8_t *)&u64)[1]; \
+	mac[5] = ((uint8_t *)&u64)[0]; }
+
+static int miiAccessDone(void);
+static int arlAccessDone(void);
+
+/* ==== Public Functions ================================================= */
+
+/*****************************************************************************
+* See ethHw.h for API documentation
+*****************************************************************************/
+
+int ethHw_Init(void)
+{
+	int timeout;
+	volatile uint32_t reg;
+
+	/* Put switch registers in unsecure mode
+	*  TODO:  This needs to be controlled some secure process
+	*/
+	secHw_setUnsecure(secHw_BLK_MASK_ESW);
+
+	if (chipcHw_setClock(chipcHw_CLOCK_ESW, chipcHw_OPTYPE_GET_OUTPUT, 0)) {
+		/* Switch clock is already enabled */
+	} else {
+		/* Enable switch clock */
+		chipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_ESW);
+
+		chipcHw_setClockFrequency(chipcHw_CLOCK_ESW, CLOCK_FREQ);
+		chipcHw_setClockEnable(chipcHw_CLOCK_ESW);
+	}
+
+	/* Check if switch and PHY are ready */
+	udelay(50);
+
+	timeout = 0;
+	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
+	while (!(reg & ETHHW_REG_IMP_PHY_MISC_READY)) {
+		ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
+		if (timeout++ > ETHHW_REG_READY_TIMEOUT)
+			return ETHHW_RC_TIMEOUT;
+	}
+
+	/* Apply chip-specific configuration */
+	ethHw_chipConfig();
+
+	/* Configure internal port forwarding */
+	ETHHW_REG_MASK_SET(ethHw_regCtrlSwitchMode,
+	ETHHW_REG_CTRL_SW_FWDG_EN | ETHHW_REG_CTRL_SW_FWDG_MODE);
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlImpCtrl);
+	reg |= ETHHW_REG_CTRL_IMPCTRL_RX_BCAST_EN;	/* Allow broadcast */
+#if 0
+	reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN;  /* Drop unlearned multicast */
+#else
+	/* Enable multicast forwarding until multicast groups are supported */
+	reg |= ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN;	/* Allow unlearned multicast */
+#endif
+	reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN;  /* Drop unlearned unicast */
+	ETHHW_REG_SET(ethHw_regCtrlImpCtrl, reg);
+
+	/* Note that the internal port is only configured at this point and not
+	*  actually enabled yet.  The user needs to set-up the DMA first, and then
+	*  enable the internal port by calling ethHw_impEnableSet()
+	*/
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_Exit(void)
+{
+	/* Application code will normally control shutdown of the driver */
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_chipConfig(void)
+{
+	int port;
+	uint32_t reg32;
+
+	/* Apply chip-specific configuration */
+
+	/* NOTE: User is responsible for re-applying the configuration if the PHY is reset */
+
+	for (port = ETHHW_PORT_MIN; port <= ETHHW_PORT_MAX; port++) {
+		if (cap_isPresent(CAP_ETH_PHY, port)) {
+			if (cap_isPresent(CAP_ETH_GMII, port)) {
+				/* Disable auto_early_dac_wake to improve 1000t interop when PHY resolves as slave */
+				ethHw_miiSet(port, 0, 0x17, 0x0f08);	/* Enable expansion register 8 */
+				ethHw_miiGet(port, 0, 0x15, &reg32);	/* Get value of expansion register */
+				reg32 &= ~0x00000200;			/* Set auto_early_dac_wake = 0 (bit 9) */
+				ethHw_miiSet(port, 0, 0x15, reg32);	/* Set new value of expansion register */
+				ethHw_miiSet(port, 0, 0x17, 0x0000);	/* Disable expansion register 8 */
+			} else {
+				/* The chip does not support 1000Mbps, so disable 1000Mbps
+				*  advertisement.  To simplify the silicon design, this needs to be
+				*  handled by software
+				*/
+				ethHw_miiGet(port, 0, 9, &reg32);
+				reg32 &= ~0x00000300;			/* Disable 1000-half/full advertisement */
+				ethHw_miiSet(port, 0, 9, reg32);
+			}
+
+			/* Put PHY in auto-powerdown mode (consume less power when link is not active) */
+			ethHw_miiSet(port, 0, 0x1c, 0x2800);		/* Enable shadow register 0xa */
+			ethHw_miiGet(port, 0, 0x1c, &reg32);		/* Get value of shadow register 0xa */
+			reg32 = 0xa821;					/* Enable auto-powerdown with 2.7s sleep timer and 84ms wake-up timer */
+			ethHw_miiSet(port, 0, 0x1c, reg32);		/* Set new value of shadow register 0xa */
+		} else {
+			/* PHY is not available, so make sure it is powered-down */
+			ethHw_phyPowerdownSet(port, 1);
+		}
+	}
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_stpStateSet(int port, ETHHW_STP_STATE state)
+{
+	volatile uint32_t reg;
+
+	if (!ETHHW_VALID_PORT_EXT(port))
+		return ETHHW_RC_PORT;
+	if (!ETHHW_VALID_STP_STATE(state))
+		return ETHHW_RC_PARAM;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
+	reg &= ~ETHHW_REG_CTRL_PORTCTRL_STP_STATE_MASK;
+	reg |= (state << ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT);
+	ETHHW_REG_SET(ethHw_regCtrlPortCtrl(port), reg);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_stpStateGet(int port, ETHHW_STP_STATE *statep)
+{
+	volatile uint32_t reg;
+
+	*statep = ETHHW_VAR_UNINITIALIZED;
+	if (!ETHHW_VALID_PORT_EXT(port))
+		return ETHHW_RC_PORT;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
+	reg &= ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT;
+
+	*statep = reg >> ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT;
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_miiSet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t data)
+{
+	uint32_t mdioAddr;
+	uint32_t cmd;
+
+	if (!ETHHW_VALID_PORT_EXT(port))
+		return ETHHW_RC_PORT;
+
+	addr <<= 1;	 /* Convert MII register address to physical address */
+
+	if (flags & ETHHW_MII_FLAGS_EXT)
+		mdioAddr = ETHHW_REG_MII_EXT(port, addr);
+	else
+		mdioAddr = ETHHW_REG_MII(port, addr);
+
+	cmd = ETHHW_REG_MDIO_DONE_MASK | ETHHW_REG_MDIO_EXTRA_MASK | ETHHW_REG_MDIO_WRITE_MASK;
+	if (flags & ETHHW_MII_FLAGS_SERDES)
+		cmd |= ETHHW_REG_MDIO_SERDES_MASK;
+
+	ETHHW_REG_SET(ethHw_regMdioAddr, mdioAddr);
+	ETHHW_REG_SET(ethHw_regMdioWriteData, data & 0x0000ffff);
+	ETHHW_REG_SET(ethHw_regMdioStatus, cmd);
+
+	if (!miiAccessDone())
+		return ETHHW_RC_TIMEOUT;
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_miiGet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t *datap)
+{
+	uint32_t mdioAddr;
+	uint32_t cmd;
+
+	*datap = ETHHW_VAR_UNINITIALIZED;
+	if (!ETHHW_VALID_PORT_EXT(port))
+		return ETHHW_RC_PORT;
+
+	addr <<= 1;	 /* Convert MII register address to physical address */
+
+	if (flags & ETHHW_MII_FLAGS_EXT)
+		mdioAddr = ETHHW_REG_MII_EXT(port, addr);
+	else
+		mdioAddr = ETHHW_REG_MII(port, addr);
+
+	cmd = (ETHHW_REG_MDIO_DONE_MASK | ETHHW_REG_MDIO_EXTRA_MASK | ETHHW_REG_MDIO_READ_MASK);
+	if (flags & ETHHW_MII_FLAGS_SERDES)
+		cmd |= ETHHW_REG_MDIO_SERDES_MASK;
+
+	ETHHW_REG_SET(ethHw_regMdioAddr, mdioAddr);
+	ETHHW_REG_SET(ethHw_regMdioStatus, cmd);
+
+	if (!miiAccessDone())
+		return ETHHW_RC_TIMEOUT;
+
+	*datap = ETHHW_REG_GET_VAL(ethHw_regMdioReadData) & 0x0000ffff;
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_impEnableSet(int enable)
+{
+	volatile uint32_t reg;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regMgmtGblMgmtCtrl);
+	reg &= ~ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_MASK;
+	if (enable)
+		reg |= ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN;
+
+	ETHHW_REG_SET(ethHw_regMgmtGblMgmtCtrl, reg);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_impEnableGet(int *enablep)
+{
+	volatile uint32_t reg;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regMgmtGblMgmtCtrl);
+	*enablep = (((reg & ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN) == ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN) ? 1 : 0);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_impSpeedSet(int mbpsRx, int mbpsTx)
+{
+	volatile uint32_t reg;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regImpSpeed);
+	reg &= ~ETHHW_REG_IMP_SPEED(ETHHW_REG_IMP_SPEED_MASK);
+
+	if (mbpsRx == 1000)
+		reg |= ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_1000MBPS);
+	else if (mbpsRx == 100)
+		reg |= ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_100MBPS);
+	else if (mbpsRx == 10)
+		reg |= ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_10MBPS);
+
+	if (mbpsTx == 1000)
+		reg |= ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_1000MBPS);
+	else if (mbpsTx == 100)
+		reg |= ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_100MBPS);
+	else if (mbpsTx == 10)
+		reg |= ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_10MBPS);
+
+	ETHHW_REG_SET(ethHw_regImpSpeed, reg);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_impSpeedGet(int *mbpsRxp, int *mbpsTxp)
+{
+	volatile uint32_t reg;
+	uint32_t mask;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regImpSpeed);
+
+	mask = reg & ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK);
+	if (mask == ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_1000MBPS))
+		*mbpsRxp = 1000;
+	else if (mask == ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_100MBPS))
+		*mbpsRxp = 100;
+	else if (mask == ETHHW_REG_IMP_SPEED_RX(ETHHW_REG_IMP_SPEED_MASK_10MBPS))
+		*mbpsRxp = 10;
+	else
+		*mbpsRxp = -1;
+
+	mask = reg & ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK);
+	if (mask == ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_1000MBPS))
+		*mbpsTxp = 1000;
+	else if (mask == ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_100MBPS))
+		*mbpsTxp = 100;
+	else if (mask == ETHHW_REG_IMP_SPEED_TX(ETHHW_REG_IMP_SPEED_MASK_10MBPS))
+		*mbpsTxp = 10;
+	else
+		*mbpsTxp = -1;
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_arlEntrySet(char *macp, int vid, int port, int cos,
+		      int entryValid, int entryStatic)
+{
+	int i;
+	uint64_t mac, mac2;
+	volatile uint32_t reg;
+
+	/*
+	 * mac is endian-dependent.  Cannot use *((uint64_t *)(macp))
+	 * mac = *((uint64_t *)(macp));
+	 */
+	mac = mactou64(macp);
+	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_INDEX, mac);
+	ETHHW_REG_SET(ethHw_regArlVlanIndex, vid);
+	ETHHW_REG_SET(ethHw_regArlRwCtrl, (ETHHW_REG_ARL_RWCTRL_START_DONE | ETHHW_REG_ARL_RWCTRL_READ));
+	if (!arlAccessDone())
+		return ETHHW_RC_TIMEOUT;
+
+	mac |= (((uint64_t)vid) << 48);
+
+	for (i = ETHHW_REG_ARL_ENTRY_MIN; i <= ETHHW_REG_ARL_ENTRY_MAX; i++) {
+		/* current entry is not valid */
+		if ((ETHHW_REG_GET_VAL(ethHw_regArlFwdEntry(i)) & ETHHW_REG_ARL_FWDENTRY_VALID)) {
+			/* check if MAC and VID are the same as existing entry */
+			/* if yes, then update entry instead */
+			ETHHW_REG_GET64(ETHHW_REG_ARL_MAC_VID_ENTRY(i), &mac2);
+			if (mac2 == mac)
+				break;
+		} else {
+			break;
+		}
+	}
+
+	/* All entries are used */
+	if (i > ETHHW_REG_ARL_ENTRY_MAX)
+		return ETHHW_RC_FULL;
+
+	/* Validate entry */
+	reg = ETHHW_REG_ARL_FWDENTRY_AGE | (cos << ETHHW_REG_ARL_FWDENTRY_TC_SHIFT) | port;
+
+	/* Validate entry */
+	if (entryValid)
+		reg |= ETHHW_REG_ARL_FWDENTRY_VALID;
+
+	/* Static entry */
+	if (entryStatic)
+		reg |= ETHHW_REG_ARL_FWDENTRY_STATIC;
+
+	ETHHW_REG_SET (ethHw_regArlFwdEntry(i), reg);
+
+	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_VID_ENTRY(i), mac);
+
+	mac = mactou64(macp);
+	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_INDEX, mac);
+	ETHHW_REG_SET(ethHw_regArlVlanIndex, vid);
+	ETHHW_REG_SET(ethHw_regArlRwCtrl, (ETHHW_REG_ARL_RWCTRL_START_DONE | ETHHW_REG_ARL_RWCTRL_WRITE));
+	if (!arlAccessDone())
+		return ETHHW_RC_TIMEOUT;
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_portLinkStatus(int port)
+{
+	int up;
+
+	up = ETHHW_VAR_UNINITIALIZED;
+	if (!ETHHW_VALID_PORT(port))
+		return ETHHW_RC_PORT;
+
+	up = ((ETHHW_REG_GET_VAL(ethHw_regStatusLinkStatus) & ETHHW_PORT_MASK(port)) ? 1 : 0);
+
+	return up;
+}
+
+
+int ethHw_portLinkStatusChange(int port)
+{
+	int change;
+
+	change = ETHHW_VAR_UNINITIALIZED;
+	if (!ETHHW_VALID_PORT(port))
+		return ETHHW_RC_PORT;
+
+	linkStatChg |= ETHHW_REG_GET_VAL(ethHw_regStatusLinkStatusChange);
+	change = ((linkStatChg & ETHHW_PORT_MASK(port)) ? 1 : 0);
+	linkStatChg &= ~ETHHW_PORT_MASK(port);
+
+	return change;
+}
+
+
+int ethHw_portSpeed(int port)
+{
+	int speed;
+	int speed_bmp;
+
+	speed = ETHHW_VAR_UNINITIALIZED;
+	if (!ETHHW_VALID_PORT(port))
+		return ETHHW_RC_PORT;
+
+	speed_bmp = (ETHHW_REG_GET_VAL(ethHw_regStatusPortSpeed) >> ETHHW_REG_STATUS_PORT_SPEED_SHIFT(port)) &
+		     ETHHW_REG_STATUS_PORT_SPEED_MASK;
+
+	if (speed_bmp & ETHHW_REG_STATUS_PORT_SPEED_1000MB)
+		speed = 1000;
+	else if (speed_bmp & ETHHW_REG_STATUS_PORT_SPEED_100MB)
+		speed = 100;
+	else
+		speed = 10;
+
+	return speed;
+}
+
+
+int ethHw_macEnableSet(int port, int tx, int rx)
+{
+	volatile uint32_t reg;
+
+	if (!(ETHHW_VALID_PORT_EXT(port) || ETHHW_VALID_PORT_INT(port)))
+		return ETHHW_RC_PORT;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
+
+	if (tx)
+		reg &= ~ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE;
+	else
+		reg |= ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE;
+
+	if (rx)
+		reg &= ~ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE;
+	else
+		reg |= ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE;
+
+	ETHHW_REG_SET(ethHw_regCtrlPortCtrl(port), reg);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_macEnableGet(int port, int *txp, int *rxp)
+{
+	volatile uint32_t reg;
+
+	*txp = ETHHW_VAR_UNINITIALIZED;
+	*rxp = ETHHW_VAR_UNINITIALIZED;
+	if (!(ETHHW_VALID_PORT_EXT(port) || ETHHW_VALID_PORT_INT(port)))
+		return ETHHW_RC_PORT;
+
+	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
+
+	*txp = ((reg & ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE) ? 0 : 1);
+	*rxp = ((reg & ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE) ? 0 : 1);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_phyPowerdownSet(int port, int enable)
+{
+	volatile uint32_t reg;
+
+	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
+
+	if (enable)
+		reg |= ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port);
+	else
+		reg &= ~ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port);
+
+	ETHHW_REG_SET(ethHw_regImpPhyMisc, reg);
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_phyPowerdownGet(int port, int *enablep)
+{
+	volatile uint32_t reg;
+
+	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
+
+	*enablep = ((reg & ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port)) ==
+					ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port));
+
+	return ETHHW_RC_NONE;
+}
+
+
+int ethHw_Loopback(int port, int enable)
+{
+	volatile uint32_t reg;
+	uint32_t reg32;
+
+	if (enable) {
+		ethHw_stpStateSet(port, ETHHW_STP_STATE_FORWARDING);
+
+		/* Enable forwarding of unlearned packets
+		 */
+		reg = ETHHW_REG_GET_VAL(ethHw_regCtrlImpCtrl);
+		reg |= ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN;  /* Forward unlearned multicast */
+		reg |= ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN;  /* Forward unlearned unicast */
+		ETHHW_REG_SET(ethHw_regCtrlImpCtrl, reg);
+
+		/* Disable bridging
+		 */
+		reg = ETHHW_REG_GET_VAL(ethHw_regCtrlProtectPortSel);
+		reg |= 1<<port;
+		ETHHW_REG_SET(ethHw_regCtrlProtectPortSel, reg);
+
+		/* Configure port for loopback
+		 */
+		ethHw_miiGet(port, 0, 0, &reg32);
+		reg32 |= 0x4000;
+		ethHw_miiSet(port, 0, 0, reg32);
+	} else {
+		ethHw_stpStateSet(port, ETHHW_STP_STATE_DISABLED);
+
+		/* Disable forwarding of unlearned packets
+		 */
+		reg = ETHHW_REG_GET_VAL(ethHw_regCtrlImpCtrl);
+		reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN;  /* Forward unlearned multicast */
+		reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN;  /* Forward unlearned unicast */
+		ETHHW_REG_SET(ethHw_regCtrlImpCtrl, reg);
+
+		/* Enable bridging
+		 */
+		reg = ETHHW_REG_GET_VAL(ethHw_regCtrlProtectPortSel);
+		reg &= ~(1<<port);
+		ETHHW_REG_SET(ethHw_regCtrlProtectPortSel, reg);
+
+		/* Configure port for loopback
+		 */
+		ethHw_miiGet(port, 0, 0, &reg32);
+		reg32 &= ~0x4000;
+		ethHw_miiSet(port, 0, 0, reg32);
+	}
+
+	return ETHHW_RC_NONE;
+}
+
+/* MIB functions */
+#define MIB_FUNC_32(type) \
+uint32_t ethHw_mib ## type (int port) \
+{\
+	if (!ETHHW_VALID_PORT_MIB(port)) \
+		return 0; \
+	\
+	return ethHw_regMib ## type (port); \
+} \
+\
+EXPORT_SYMBOL(ethHw_mib ## type);
+
+#define MIB_FUNC_64(type) \
+uint64_t ethHw_mib ## type (int port) \
+{\
+	uint64_t mib; \
+	\
+	if (!ETHHW_VALID_PORT_MIB(port)) \
+		return 0; \
+	\
+	ethHw_get64(ETHHW_REG_MIB_ ## type (port), &mib); \
+	\
+	return mib; \
+} \
+\
+EXPORT_SYMBOL(ethHw_mib ## type);
+
+MIB_FUNC_64(TxOctets);
+MIB_FUNC_32(TxDropPkts);
+MIB_FUNC_32(TxQ0Pkt);
+MIB_FUNC_32(TxBroadcastPkts);
+MIB_FUNC_32(TxMulticastPkts);
+MIB_FUNC_32(TxUnicastPkts);
+MIB_FUNC_32(TxCollisions);
+MIB_FUNC_32(TxSingleCollision);
+MIB_FUNC_32(TxMultipleCollision);
+MIB_FUNC_32(TxDeferredTransmit);
+MIB_FUNC_32(TxLateCollision);
+MIB_FUNC_32(TxExcessiveCollision);
+MIB_FUNC_32(TxFrameInDisc);
+MIB_FUNC_32(TxPausePkts);
+MIB_FUNC_32(TxQ1Pkt);
+MIB_FUNC_32(TxQ2Pkt);
+MIB_FUNC_32(TxQ3Pkt);
+MIB_FUNC_32(TxQ4Pkt);
+MIB_FUNC_32(TxQ5Pkt);
+MIB_FUNC_64(RxOctets);
+MIB_FUNC_32(RxUndersizePkts);
+MIB_FUNC_32(RxPausePkts);
+MIB_FUNC_32(Pkts64Octets);
+MIB_FUNC_32(Pkts65To127Octets);
+MIB_FUNC_32(Pkts128To255Octets);
+MIB_FUNC_32(Pkts256To511Octets);
+MIB_FUNC_32(Pkts512To1023Octets);
+MIB_FUNC_32(Pkts1024ToMaxPktOctets);
+MIB_FUNC_32(RxOversizePkts);
+MIB_FUNC_32(RxJabbers);
+MIB_FUNC_32(RxAlignmentErrors);
+MIB_FUNC_32(RxFcsErrors);
+MIB_FUNC_64(RxGoodOctets);
+MIB_FUNC_32(RxDropPkts);
+MIB_FUNC_32(RxUnicastPkts);
+MIB_FUNC_32(RxMulticastPkts);
+MIB_FUNC_32(RxBroadcastPkts);
+MIB_FUNC_32(RxSaChanges);
+MIB_FUNC_32(RxFragments);
+MIB_FUNC_32(JumboPktCount);
+MIB_FUNC_32(RxSymbolError);
+MIB_FUNC_32(InRangeErrorCount);
+MIB_FUNC_32(OutRangeErrorCount);
+MIB_FUNC_32(RxDiscard);
+MIB_FUNC_32(DosAssertCount);
+MIB_FUNC_32(DosDropCount);
+MIB_FUNC_32(IngressRateAssertCount);
+MIB_FUNC_32(IngressRateDropCount);
+MIB_FUNC_32(EgressRateAssertCount);
+
+
+/* ==== Exported Public Functions ======================================== */
+
+EXPORT_SYMBOL(ethHw_Init);
+EXPORT_SYMBOL(ethHw_Exit);
+
+EXPORT_SYMBOL(ethHw_stpStateSet);
+EXPORT_SYMBOL(ethHw_stpStateGet);
+
+EXPORT_SYMBOL(ethHw_miiSet);
+EXPORT_SYMBOL(ethHw_miiGet);
+
+EXPORT_SYMBOL(ethHw_impEnableSet);
+EXPORT_SYMBOL(ethHw_impEnableGet);
+EXPORT_SYMBOL(ethHw_impSpeedSet);
+EXPORT_SYMBOL(ethHw_impSpeedGet);
+
+EXPORT_SYMBOL(ethHw_arlEntrySet);
+
+EXPORT_SYMBOL(ethHw_portLinkStatus);
+EXPORT_SYMBOL(ethHw_portLinkStatusChange);
+EXPORT_SYMBOL(ethHw_portSpeed);
+
+EXPORT_SYMBOL(ethHw_macEnableSet);
+EXPORT_SYMBOL(ethHw_macEnableGet);
+
+EXPORT_SYMBOL(ethHw_phyPowerdownSet);
+EXPORT_SYMBOL(ethHw_phyPowerdownGet);
+
+EXPORT_SYMBOL(ethHw_get64);
+EXPORT_SYMBOL(ethHw_set64_byVal);
+EXPORT_SYMBOL(ethHw_set64_byRef);
+
+/* MIB public functions are exported in the function macros */
+
+/* ==== Private Functions ================================================ */
+
+static int miiAccessDone(void)
+{
+	int timeout;
+
+	timeout = 0;
+	while (ETHHW_REG_GET_VAL(ethHw_regMdioStatus) & ETHHW_REG_MDIO_DONE_MASK)
+		if (timeout++ >= ETHHW_REG_MII_TIMEOUT)
+			return 0;
+
+	return 1;
+}
+
+
+static int arlAccessDone(void)
+{
+	int timeout;
+
+	timeout = 0;
+	while (ETHHW_REG_GET_VAL(ethHw_regArlRwCtrl) & ETHHW_REG_ARL_RWCTRL_START_DONE)
+		if (timeout++ >= ETHHW_REG_ARL_TIMEOUT)
+			return 0;
+
+	return 1;
+}
diff --git a/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S b/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
new file mode 100644
index 0000000..f5d5b69
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
@@ -0,0 +1,49 @@
+/*****************************************************************************
+*  Copyright 2009 - 2009 Broadcom Corporation.  All rights reserved.
+*
+*  Unless you and Broadcom execute a separate written software license
+*  agreement governing use of this software, this software is licensed to you
+*  under the terms of the GNU General Public License version 2, available at
+*  http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+*  Notwithstanding the above, under no circumstances may you combine this
+*  software in any way with any other Broadcom software provided under a
+*  license other than the GPL, without Broadcom's express prior written
+*  consent.
+*
+*****************************************************************************/
+
+// ***************************************************************************
+// void ethHw_get64( uint32_t addr, uint64_t *datap );
+
+   .global ethHw_get64
+
+ethHw_get64:
+   push  {r4}
+   ldm   r0, {r3, r4}
+   stm   r1, {r3, r4}
+   pop   {r4}
+   bx    lr
+
+
+// ***************************************************************************
+// void ethHw_set64_byVal( uint32_t addr, uint64_t data )
+
+   .global ethHw_set64_byVal
+
+ethHw_set64_byVal:
+   stm   r0, {r2, r3}
+   bx    lr
+
+
+// ***************************************************************************
+// void ethHw_set64_byRef( uint32_t addr, uint64_t *datap )
+
+   .global ethHw_set64_byRef
+
+ethHw_set64_byRef:
+   push  {r4}
+   ldm   r1, {r3, r4}
+   stm   r0, {r3, r4}
+   pop   {r4}
+   bx    lr
diff --git a/arch/arm/mach-bcmring/include/csp/ethHw.h b/arch/arm/mach-bcmring/include/csp/ethHw.h
new file mode 100644
index 0000000..982efa9
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/ethHw.h
@@ -0,0 +1,423 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file    ethHw.h
+*
+*  @brief   API definitions for low level ETH driver.
+*
+*  @note    This file includes all the custom APIs not defined in SDK Robo
+*/
+/****************************************************************************/
+
+#ifndef _ETHHW_H
+#define _ETHHW_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <csp/stdint.h>
+/* TODO:  Include file really shouldn't reference a Linux include path in the CSP */
+/* #include <linux/broadcom/bcmring/eth_defs.h> */
+
+#define ETHHW_PORT_0             0
+#define ETHHW_PORT_1             1
+#define ETHHW_PORT_INT           8
+#define ETHHW_PORT_SNAPSHOT      0x51
+#define ETHHW_PORT_ALL           -1
+
+#define ETHHW_PORT_MIN           ETHHW_PORT_0
+#define ETHHW_PORT_MAX           ETHHW_PORT_1
+#define ETHHW_PORT_NUM           (ETHHW_PORT_MAX - ETHHW_PORT_MIN + 1)
+#define ETHHW_PORT_MASK(p)       (1 << (p))
+
+#define ETHHW_PORTMASK_NONE      0
+#define ETHHW_PORTMASK_PORT_0    ETHHW_PORT_MASK(ETHHW_PORT_0)
+#define ETHHW_PORTMASK_PORT_1    ETHHW_PORT_MASK(ETHHW_PORT_1)
+#define ETHHW_PORTMASK_INT       ETHHW_PORT_MASK(ETHHW_PORT_INT)
+#define ETHHW_PORTMASK_EXT       (ETHHW_PORT_MASK(ETHHW_PORT_0) | \
+				  ETHHW_PORT_MASK(ETHHW_PORT_1))
+#define ETHHW_PORTMASK_ALL       (ETHHW_PORTMASK_INT | ETHHW_PORTMASK_EXT)
+
+#define ETHHW_BRCM_HDR_LEN       sizeof(uint32_t)
+
+typedef enum {
+	ETHHW_STP_STATE_NONE = 0,
+	ETHHW_STP_STATE_DISABLED,
+	ETHHW_STP_STATE_BLOCKING,
+	ETHHW_STP_STATE_LISTENING,
+	ETHHW_STP_STATE_LEARNING,
+	ETHHW_STP_STATE_FORWARDING,
+} ETHHW_STP_STATE;
+
+typedef enum {
+	ETHHW_TC_0 = 0,
+	ETHHW_TC_1 = 1,
+	ETHHW_TC_2 = 2,
+	ETHHW_TC_3 = 3,
+	ETHHW_TC_4 = 4,
+	ETHHW_TC_5 = 5,
+	ETHHW_TC_6 = 6,
+	ETHHW_TC_7 = 7,
+} ETHHW_TC;
+
+#define ETHHW_TC_LOWEST          ETHHW_TC_0
+#define ETHHW_TC_HIGHEST         ETHHW_TC_7
+#define ETHHW_TC_MASK            0x7
+
+typedef enum {
+	ETHHW_TE_FOLLOW = 0,
+	ETHHW_TE_UNTAG = 1,
+	ETHHW_TE_KEEP = 2,
+	ETHHW_TE_RSVD = 3,
+} ETHHW_TE;
+
+#define ETHHW_TE_MASK            0x3
+
+#define ETHHW_MII_FLAGS_EXT      0x80000000     /* External PHY */
+#define ETHHW_MII_FLAGS_SERDES   0x40000000     /* SERDES PHY */
+typedef uint32_t ETHHW_MII_FLAGS;
+
+/* Note that this assumes the buffers are 16-bit aligned */
+#define ethHw_macCopy(dp,sp) \
+	{ \
+		(((uint16_t *)(dp))[0] = ((uint16_t *)(sp))[0]); \
+		(((uint16_t *)(dp))[1] = ((uint16_t *)(sp))[1]); \
+		(((uint16_t *)(dp))[2] = ((uint16_t *)(sp))[2]); \
+	}
+
+#define ethHw_macIsSame(m1p,m2p) \
+	((((uint16_t *)(m1p))[0] == ((uint16_t *)(m2p))[0]) && \
+	(((uint16_t *)(m1p))[1] == ((uint16_t *)(m2p))[1]) && \
+	(((uint16_t *)(m1p))[2] == ((uint16_t *)(m2p))[2]))
+
+#define ETHHW_VALID_PORT_EXT(port)           (((port) == ETHHW_PORT_0) || ((port) == ETHHW_PORT_1))
+#define ETHHW_VALID_PORT_INT(port)           ((port) == ETHHW_PORT_INT)
+#define ETHHW_VALID_PORT_ALL(port)           ((port) == ETHHW_PORT_ALL)
+#define ETHHW_VALID_PORT(port)               (ETHHW_VALID_PORT_EXT((port)) || ETHHW_VALID_PORT_INT((port)))
+#define ETHHW_VALID_PORT_MIB(port)           (ETHHW_VALID_PORT((port)) || ((port) == ETHHW_PORT_SNAPSHOT))
+#define ETHHW_VALID_PORTMAP(p)               (((p) & ~(ETHHW_PORT_MASK(ETHHW_PORT_0) | ETHHW_PORT_MASK(ETHHW_PORT_1) | ETHHW_PORT_MASK(ETHHW_PORT_INT))) == 0)
+#define ETHHW_VALID_STP_STATE(state)         (((state) >= ETHHW_STP_STATE_DISABLED) && ((state) <= ETHHW_STP_STATE_FORWARDING))
+
+#define ETHHW_VAR_UNINITIALIZED              -1
+
+/* Define result codes to maintain backward compatibility */
+typedef enum {
+	ETHHW_RC_NONE		= 0,
+	ETHHW_RC_PARAM		= -4,
+	ETHHW_RC_FULL		= -6,
+	ETHHW_RC_TIMEOUT	= -9,
+	ETHHW_RC_UNAVAIL	= -16,
+	ETHHW_RC_PORT		= -18
+} ETHHW_RC;
+
+#define ETHHW_RC_SUCCESS(rc)        ((rc) >= 0)
+#define ETHHW_RC_FAILURE(rc)        ((rc) < 0)
+
+#define ETHHW_BRCM_TYPE             0x8874
+#define ETHHW_BRCM_TYPE_MSB         ((ETHHW_BRCM_TYPE >> 8) & 0xff)
+#define ETHHW_BRCM_TYPE_LSB         ((ETHHW_BRCM_TYPE >> 0) & 0xff)
+
+/* Broadcom header/tag macros */
+#define ethHw_brcmTagInit(tagp, tc, te) \
+{ \
+	(tagp)[0] = (((tc) & ETHHW_TC_MASK) << 2) | ((te) & ETHHW_TE_MASK); \
+	(tagp)[1] = 0; \
+	(tagp)[2] = 0; \
+	(tagp)[3] = 0; \
+}
+
+#define ethHw_brcmTagInitRaw(tagp) \
+{ \
+	tagp[0] = tagp[2]; \
+	tagp[1] = 0; \
+	tagp[2] = 0; \
+	tagp[3] = 0; \
+}
+
+#define ethHw_brcmTagSetPortMask(tagp,portMask) \
+{ \
+	(tagp)[0] |= 0x20; \
+	(tagp)[3] = ((portMask) & ETHHW_PORTMASK_EXT); \
+}
+
+#define ethHw_brcmTagGetPort(tagp)     ((tagp)[3] & 0x1)
+
+int ethHw_Init(void);
+int ethHw_Exit(void);
+
+int ethHw_chipConfig(void);
+
+int ethHw_stpStateSet(int port, ETHHW_STP_STATE state);
+int ethHw_stpStateGet(int port, ETHHW_STP_STATE *statep);
+
+int ethHw_impEnableSet(int enable);
+int ethHw_impEnableGet(int *enablep);
+int ethHw_impSpeedSet(int mbpsRx, int mbpsTx);
+int ethHw_impSpeedGet(int *mbpsRxp, int *mbpsTxp);
+
+int ethHw_arlEntrySet(char *macp, int vid, int port, int cos,
+		int entryValid, int entryStatic);
+
+int ethHw_miiSet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t data);
+int ethHw_miiGet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t *datap);
+
+int ethHw_portLinkStatus(int port);
+int ethHw_portSpeed(int port);
+int ethHw_portLinkStatusChange(int port);
+
+int ethHw_phyPowerdownSet(int port, int enable);
+int ethHw_phyPowerdownGet(int port, int *enablep);
+
+int ethHw_macEnableSet(int port, int tx, int rx);
+int ethHw_macEnableGet(int port, int *txp, int *rxp);
+
+int ethHw_Loopback(int port, int enable);
+
+uint64_t ethHw_mibTxOctets(int port);
+uint32_t ethHw_mibTxDropPkts(int port);
+uint32_t ethHw_mibTxQ0Pkt(int port);
+uint32_t ethHw_mibTxBroadcastPkts(int port);
+uint32_t ethHw_mibTxMulticastPkts(int port);
+uint32_t ethHw_mibTxUnicastPkts(int port);
+uint32_t ethHw_mibTxCollisions(int port);
+uint32_t ethHw_mibTxSingleCollision(int port);
+uint32_t ethHw_mibTxMultipleCollision(int port);
+uint32_t ethHw_mibTxDeferredTransmit(int port);
+uint32_t ethHw_mibTxLateCollision(int port);
+uint32_t ethHw_mibTxExcessiveCollision(int port);
+uint32_t ethHw_mibTxFrameInDisc(int port);
+uint32_t ethHw_mibTxPausePkts(int port);
+uint32_t ethHw_mibTxQ1Pkt(int port);
+uint32_t ethHw_mibTxQ2Pkt(int port);
+uint32_t ethHw_mibTxQ3Pkt(int port);
+uint32_t ethHw_mibTxQ4Pkt(int port);
+uint32_t ethHw_mibTxQ5Pkt(int port);
+uint64_t ethHw_mibRxOctets(int port);
+uint32_t ethHw_mibRxUndersizePkts(int port);
+uint32_t ethHw_mibRxPausePkts(int port);
+uint32_t ethHw_mibPkts64Octets(int port);
+uint32_t ethHw_mibPkts65To127Octets(int port);
+uint32_t ethHw_mibPkts128To255Octets(int port);
+uint32_t ethHw_mibPkts256To511Octets(int port);
+uint32_t ethHw_mibPkts512To1023Octets(int port);
+uint32_t ethHw_mibPkts1024ToMaxPktOctets(int port);
+uint32_t ethHw_mibRxOversizePkts(int port);
+uint32_t ethHw_mibRxJabbers(int port);
+uint32_t ethHw_mibRxAlignmentErrors(int port);
+uint32_t ethHw_mibRxFcsErrors(int port);
+uint64_t ethHw_mibRxGoodOctets(int port);
+uint32_t ethHw_mibRxDropPkts(int port);
+uint32_t ethHw_mibRxUnicastPkts(int port);
+uint32_t ethHw_mibRxMulticastPkts(int port);
+uint32_t ethHw_mibRxBroadcastPkts(int port);
+uint32_t ethHw_mibRxSaChanges(int port);
+uint32_t ethHw_mibRxFragments(int port);
+uint32_t ethHw_mibJumboPktCount(int port);
+uint32_t ethHw_mibRxSymbolError(int port);
+uint32_t ethHw_mibInRangeErrorCount(int port);
+uint32_t ethHw_mibOutRangeErrorCount(int port);
+uint32_t ethHw_mibRxDiscard(int port);
+uint32_t ethHw_mibDosAssertCount(int port);
+uint32_t ethHw_mibDosDropCount(int port);
+uint32_t ethHw_mibIngressRateAssertCount(int port);
+uint32_t ethHw_mibIngressRateDropCount(int port);
+uint32_t ethHw_mibEgressRateAssertCount(int port);
+
+static inline int ethHw_rxFrameFormat(char **bufpp, int *lenp)
+{
+	char *srcp;
+	char *dstp;
+	uint8_t *tagp;
+	register int i;
+
+	/*
+	*  *bufp in:
+	*     byte  0    5 6   11 12      15 16  19
+	*           [ DA ] [ SA ] [BRCM_HDR] [TYPE]
+	*
+	*  *bufp out (Broadcom header removed):
+	*     byte  0 3 4    9 10  15 16  19
+	*           [x] [ DA ] [ SA ] [TYPE]
+	*
+	*  Broadcom header contains source port information
+	*/
+
+	srcp = *bufpp + 11;
+	dstp = srcp + ETHHW_BRCM_HDR_LEN;
+	tagp = (uint8_t *)(*bufpp + 12);
+
+	/* Update length to remove Broadcom header and ethernet FCS */
+	*lenp -= (ETHHW_BRCM_HDR_LEN + sizeof(uint32_t));
+
+	/* Update start of buffer */
+	*bufpp += ETHHW_BRCM_HDR_LEN;
+
+	/* Move DA and SA */
+	for (i = 0; i < 12; i++) {
+	   *dstp-- = *srcp--;
+	}
+
+	return ETHHW_BRCM_HDR_LEN;
+}
+
+
+static inline int ethHw_rxFrameFormatRaw(char **bufpp, int *lenp)
+{
+	char *bufp;
+	uint8_t *tagp;
+
+	/*
+	*  *bufp in:
+	*     byte  0  5 6 11 12      15 16  19
+	*           [DA] [SA] [BRCM_HDR] [TYPE]
+	*
+	*  *bufp out (Broadcom header modified):
+	*     byte  0  5 6 11 12      15 16  19
+	*           [DA] [SA] [RAW_HDR] [TYPE]
+	*
+	*  Raw socket requires ingress specific information, so format
+	*  slightly to add a custom L2 protocol type
+	*
+	*  RAW_HDR[0]:  ETHHW_BRCM_TYPE_MSB
+	*  RAW_HDR[1]:  ETHHW_BRCM_TYPE_LSB
+	*  RAW_HDR[2]:  0
+	*  RAW_HDR[3]:  port
+	*
+	*  Broadcom header contains source port information
+	*/
+
+	bufp = *bufpp;
+	tagp = (uint8_t *)&bufp[12];
+	tagp[0] = ETHHW_BRCM_TYPE_MSB;
+	tagp[1] = ETHHW_BRCM_TYPE_LSB;
+	tagp[2] = 0;
+	tagp[3] = tagp[3];
+
+	/* Update length to remove ethernet FCS */
+	*lenp -= sizeof(uint32_t);
+
+	return 0;
+}
+
+
+static inline int ethHw_txFrameFormat(char **bufpp, int *lenp, int portMask, ETHHW_TC tc, ETHHW_TE te)
+{
+	char *bufp;
+	char *srcp;
+	char *dstp;
+	uint8_t *tagp;
+	register int i;
+	int offset;
+
+	/*
+	*  *bufp out (Broadcom header inserted):
+	*     byte  0  5 6 11 12      15 16  19
+	*           [DA] [SA] [BRCM_HDR] [TYPE]
+	*
+	*  Broadcom header contains destination port information
+	*/
+
+	bufp = *bufpp;
+
+	if ((bufp[12] == ETHHW_BRCM_TYPE_MSB) && (bufp[13] == ETHHW_BRCM_TYPE_LSB)) {
+		/*
+		*  *bufp in:
+		*     byte  0  5 6 11 12     15 16  19
+		*           [DA] [SA] [RAW_HDR] [TYPE]
+		*
+		*  Custom L2 protocol type detected, so raw socket has inserted egress
+		*  specific information, but type needs to be formatted slightly for
+		*  ASIC.  The portMask, tc, and te arguments will be overridden since
+		*  the RAW_HDR already contains this information
+		*
+		*  RAW_HDR[0]:  ETHHW_BRCM_TYPE_MSB
+		*  RAW_HDR[1]:  ETHHW_BRCM_TYPE_LSB
+		*  RAW_HDR[2]:  tc[4:2], te[1:0]
+		*  RAW_HDR[3]:  portMask
+		*/
+
+		tagp = (uint8_t *)&bufp[12];
+		portMask = (int)tagp[3];
+#if 1
+		/* Optimized tag initialization (tc and te do not need to be decoded,
+		*  then encoded since the bit positions are aligned and only require a
+		*  byte shift)
+		*/
+		ethHw_brcmTagInitRaw(tagp);
+#else
+		tc = (int)((tagp[2] >> 2) & ETHHW_TC_MASK);
+		te = (int)(tagp[2] & ETHHW_TE_MASK);
+		ethHw_brcmTagInit(tagp, tc, te);
+#endif
+		if (portMask == 0) {
+			/* User only wants to specify the tc and te and let the ARL determine
+			*  the port forwarding
+			*/
+		} else {
+			ethHw_brcmTagSetPortMask(tagp, portMask);
+		}
+
+		/* Update length to include FCS */
+		*lenp += sizeof(uint32_t);
+
+		offset = 0;
+	} else {
+		/*
+		*  *bufp in:
+		*     byte  0  5 6 11 12  15
+		*           [DA] [SA] [TYPE]
+		*/
+
+		srcp = bufp;
+		dstp = srcp - ETHHW_BRCM_HDR_LEN;
+
+		/* Move DA and SA */
+		for (i = 0; i < 12; i++) {
+			*dstp++ = *srcp++;
+		}
+
+		tagp = (uint8_t *)dstp;
+
+		/* Set Broadcom tag */
+		ethHw_brcmTagInit(tagp, tc, te);
+		if (portMask >= 0) {
+			ethHw_brcmTagSetPortMask(tagp, portMask);
+		}
+
+		/* Update length to include Broadcom header and FCS */
+		*lenp += (ETHHW_BRCM_HDR_LEN + sizeof(uint32_t));
+
+		/* Update start of buffer */
+		*bufpp -= ETHHW_BRCM_HDR_LEN;
+
+		offset = ETHHW_BRCM_HDR_LEN;
+	}
+
+	return offset;
+}
+
+
+#ifdef __cplusplus
+ /* end extern "C" */
+}
+#endif
+
+#endif /* _ETHHW_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg.h
index 891cea8..61786bf 100644
--- a/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg.h
+++ b/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg.h
@@ -397,6 +397,8 @@ extern uint32_t dmaChannelCount_1;
 #define dmacHw_TRAN_INT_CLEAR(module, channel)         (dmacHw_REG_INT_CLEAR_TRAN((module)) = (0x00000001 << (channel)))
 #define dmacHw_BLOCK_INT_CLEAR(module, channel)        (dmacHw_REG_INT_CLEAR_BLOCK((module)) = (0x00000001 << (channel)))
 #define dmacHw_ERROR_INT_CLEAR(module, channel)        (dmacHw_REG_INT_CLEAR_ERROR((module)) = (0x00000001 << (channel)))
+#define dmacHw_STRAN_INT_CLEAR(module, channel)        (dmacHw_REG_INT_CLEAR_DTRAN((module)) = (0x00000001 << (channel)))
+#define dmacHw_DTRAN_INT_CLEAR(module, channel)        (dmacHw_REG_INT_CLEAR_DTRAN((module)) = (0x00000001 << (channel)))
 
 #define dmacHw_GET_NUM_CHANNEL(module)                 (((dmacHw_REG_MISC_COMP_PARAM1_HI((module)) & dmacHw_REG_COMP_PARAM_NUM_CHANNELS) >> 8) + 1)
 #define dmacHw_GET_NUM_INTERFACE(module)               (((dmacHw_REG_MISC_COMP_PARAM1_HI((module)) & dmacHw_REG_COMP_PARAM_NUM_INTERFACE) >> 11) + 1)
diff --git a/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg_standalone.h b/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg_standalone.h
new file mode 100644
index 0000000..5f5e7c7
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/dmacHw_reg_standalone.h
@@ -0,0 +1,29 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+/****************************************************************************/
+/**
+*  @file    dmacHw_reg_standalone.h
+*
+*  @brief   Standalone definitions for low level DMA registers
+*
+*/
+/****************************************************************************/
+
+#ifndef _DMACHW_REG_STANDALONE_H
+#define _DMACHW_REG_STANDALONE_H
+
+#include <mach/csp/dmacHw_reg.h>
+
+#endif
diff --git a/arch/arm/mach-bcmring/include/mach/csp/ethHw_dma.h b/arch/arm/mach-bcmring/include/mach/csp/ethHw_dma.h
new file mode 100644
index 0000000..0a4919f
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/ethHw_dma.h
@@ -0,0 +1,247 @@
+/*****************************************************************************
+* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+#ifndef _ETHHW_DMA_H
+#define _ETHHW_DMA_H
+
+/* #include <linux/broadcom/bcmtypes.h> */
+#include <mach/csp/mm_io.h>
+#include <mach/csp/dmacHw_reg_standalone.h>
+#include <mach/csp/ethHw_reg.h>
+
+#define ETHHW_DMA_CFG_EOP_MASK         0x00010000
+#define ETHHW_DMA_CFG_OFFSET_INIT(bp)  ((uint32_t)(bp) % 8)
+#define ETHHW_DMA_CFG_OFFSET_LAST(bp, len) \
+		((((uint32_t)(bp) + (len)) - 1) % 8)
+#define ETHHW_DMA_CFG_OFFSET(bp, len)  ((ETHHW_DMA_CFG_OFFSET_LAST((bp), (len)) << 8) | \
+					(ETHHW_DMA_CFG_OFFSET_INIT((bp))))
+
+#define ETHHW_DMA_MTP_TRANSACTION_SIZE(bp, len) \
+		((ETHHW_DMA_CFG_OFFSET_INIT((bp)) + (len) + 7) / 8)
+#define ETHHW_DMA_MTP_FIFO_ADDR_CFG    MM_IO_VIRT_TO_PHYS((uint32_t)&ethHw_regMtpFifoConfig)
+#define ETHHW_DMA_MTP_FIFO_ADDR_DATA   MM_IO_VIRT_TO_PHYS((uint32_t)&ethHw_regMtpFifoData)
+#define ETHHW_DMA_MTP_CTL_LO           (dmacHw_REG_CTL_LLP_SRC_EN | \
+					dmacHw_REG_CTL_LLP_DST_EN | \
+					dmacHw_REG_CTL_DMS_2 | \
+					dmacHw_REG_CTL_TTFC_MP_DMAC | \
+					dmacHw_REG_CTL_DST_MSIZE_8 | \
+					dmacHw_REG_CTL_SRC_TR_WIDTH_64 | \
+					dmacHw_REG_CTL_DST_TR_WIDTH_64)
+#define ETHHW_DMA_MTP_CTL_HI           (0)
+#define ETHHW_DMA_MTP_CFG_LO           (dmacHw_REG_CFG_LO_CH_PRIORITY_7)
+#define ETHHW_DMA_MTP_CFG_HI           (dmacHw_DST_PERI_INTF(1) | \
+					dmacHw_REG_CFG_HI_UPDATE_DST_STAT | \
+					dmacHw_REG_CFG_HI_AHB_HPROT_1 | \
+					dmacHw_REG_CFG_HI_FIFO_ENOUGH)
+#define ETHHW_DMA_MTP_DSTAT            MM_IO_VIRT_TO_PHYS((uint32_t)&ethHw_regMtpDmaStatus)
+
+#define ETHHW_DMA_PTM_FIFO_ADDR        MM_IO_VIRT_TO_PHYS((uint32_t)&ethHw_regPtmFifoConfig)
+#define ETHHW_DMA_PTM_CTL_LO           (dmacHw_REG_CTL_LLP_SRC_EN | \
+					dmacHw_REG_CTL_LLP_DST_EN | \
+					dmacHw_REG_CTL_SMS_2 | \
+					dmacHw_REG_CTL_TTFC_PM_PERI | \
+					dmacHw_REG_CTL_SRC_MSIZE_8 | \
+					dmacHw_REG_CTL_SRC_TR_WIDTH_64 | \
+					dmacHw_REG_CTL_DST_TR_WIDTH_64)
+#define ETHHW_DMA_PTM_CTL_HI           (0)
+#define ETHHW_DMA_PTM_CFG_LO           (dmacHw_REG_CFG_LO_CH_PRIORITY_7)
+#define ETHHW_DMA_PTM_CFG_HI           (dmacHw_REG_CFG_HI_UPDATE_SRC_STAT | \
+					dmacHw_REG_CFG_HI_AHB_HPROT_1 | \
+					dmacHw_REG_CFG_HI_FIFO_ENOUGH)
+#define ETHHW_DMA_PTM_SSTAT            MM_IO_VIRT_TO_PHYS((uint32_t)&ethHw_regPtmDmaStatus)
+
+#define ETHHW_DMA_BUF_LEN(descp)       (((descp)->stat1 >> 13) & 0x0000ffff)
+#define ETHHW_DMA_CTL_INT_EN           dmacHw_REG_CTL_INT_EN
+#define ETHHW_DMA_TRANSFER_DONE(descp) ((descp)->ctlHi & dmacHw_REG_CTL_DONE)
+
+#define ETHHW_DMA_DESC_CREATE(descp, _sar, _dar, handlep, _ctlLo, _ctlHi) \
+do { \
+	(descp)->sar = (uint32_t)(_sar); \
+	(descp)->dar = (uint32_t)(_dar); \
+	(descp)->lli = (uint32_t)((handlep) + 1); \
+	(descp)->ctlLo = (_ctlLo); \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+	(descp)->stat2 = 0; \
+	(descp)->rsvd = 0; \
+} while (0);
+
+#define ETHHW_DMA_DESC_CREATE_NEXT(descp, _sar, _dar, _lli, _ctlLo, _ctlHi) \
+do { \
+	(descp)->sar = (uint32_t)(_sar); \
+	(descp)->dar = (uint32_t)(_dar); \
+	(descp)->lli = (uint32_t)(_lli); \
+	(descp)->ctlLo = (_ctlLo); \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+	(descp)->stat2 = 0; \
+	(descp)->rsvd = 0; \
+} while (0);
+
+#define ETHHW_DMA_DESC_RX_UPDATE(descp, _dar, _ctlHi) \
+do { \
+	(descp)->dar = (uint32_t)(_dar); \
+	(descp)->ctlHi = (_ctlHi); \
+	(descp)->stat1 = 0; \
+} while (0);
+
+#define ETHHW_DMA_DESC_WRAP(descp,_lli) \
+do {\
+	(descp)->lli = _lli; \
+} while (0);
+
+#define ETHHW_DMA_DESC_TX_DONE(descp) \
+do {\
+	(descp)->lli = 0; \
+	(descp)->ctlLo |= ETHHW_DMA_CTL_INT_EN; \
+} while (0);
+
+
+typedef struct {
+	uint32_t sar;
+	uint32_t dar;
+	uint32_t lli;
+	uint32_t ctlLo;
+	uint32_t ctlHi;
+	uint32_t stat1;
+	uint32_t stat2;
+	uint32_t rsvd;
+} ETHHW_DMA_DESC;
+
+
+/* Force to 64-bit alignment (in this case, to a cache line) */
+#define __ETHHW_DMA_ALIGN__   __attribute__ ((aligned (16)))
+
+
+static inline int ethHw_dmaInit(int controller)
+{
+	dmacHw_DMA_ENABLE(controller);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaConfig(int controller, int ch,
+				  uint32_t ctlHi, uint32_t ctlLo,
+				  uint32_t cfgHi, uint32_t cfgLo,
+				  uint32_t sstat, uint32_t dstat)
+{
+	/* Clear control and config registers first.  The dmacHw_SET_ APIs are not
+	*  consistent.  In some cases, the set value is or'ed, in others, it will
+	*  overwrite the register.  Use dmacHw_RESET_ to clear these or'ed
+	*  registers first.
+	*/
+	dmacHw_RESET_CONTROL_LO(controller, ch);
+	dmacHw_RESET_CONTROL_HI(controller, ch);
+	dmacHw_RESET_CONFIG_LO(controller, ch);
+	dmacHw_RESET_CONFIG_HI(controller, ch);
+
+	dmacHw_SET_CONTROL_LO(controller, ch, ctlLo);
+	dmacHw_SET_CONTROL_HI(controller, ch, ctlHi);
+	dmacHw_SET_CONFIG_LO(controller, ch, cfgLo);
+	dmacHw_SET_CONFIG_HI(controller, ch, cfgHi);
+
+	dmacHw_SET_SSTATAR(controller, ch, sstat);
+	dmacHw_SET_DSTATAR(controller, ch, dstat);
+
+	/* Clear interrupt status and disable interrupts */
+	dmacHw_TRAN_INT_CLEAR(controller, ch);
+	dmacHw_BLOCK_INT_CLEAR(controller, ch);
+	dmacHw_STRAN_INT_CLEAR(controller, ch);
+	dmacHw_DTRAN_INT_CLEAR(controller, ch);
+	dmacHw_ERROR_INT_CLEAR(controller, ch);
+
+	dmacHw_TRAN_INT_DISABLE(controller, ch);
+	dmacHw_BLOCK_INT_DISABLE(controller, ch);
+	dmacHw_STRAN_INT_DISABLE(controller, ch);
+	dmacHw_DTRAN_INT_DISABLE(controller, ch);
+	dmacHw_ERROR_INT_DISABLE(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaTxConfig(int burst)
+{
+	reg32_set_bits((volatile uint32_t *)&ethHw_regImpEnable, ETHHW_REG_IMP_ENABLE);
+
+	reg32_write(&ethHw_regMtpConfig,
+		ETHHW_REG_MTP_CONFIG_ENABLE |
+		ETHHW_REG_MTP_CONFIG_BURST(burst));
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaRxConfig(int burst, int block)
+{
+	reg32_write(&ethHw_regPtmConfig,
+		ETHHW_REG_PTM_CONFIG_ENABLE |
+		ETHHW_REG_PTM_CONFIG_BURST(burst) |
+		ETHHW_REG_PTM_CONFIG_BLOCK(block));
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaEnable(int controller, int ch, void *descp)
+{
+	dmacHw_SET_LLP(controller, ch, descp);
+	dmacHw_DMA_START(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaDisable(int controller, int ch)
+{
+	dmacHw_DMA_STOP(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaIrqEnable(int controller, int ch)
+{
+	dmacHw_BLOCK_INT_ENABLE(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaIrqDisable(int controller, int ch)
+{
+	dmacHw_BLOCK_INT_DISABLE(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaIrqClear(int controller, int ch)
+{
+	dmacHw_ERROR_INT_CLEAR(controller, ch);
+	dmacHw_BLOCK_INT_CLEAR(controller, ch);
+
+	return 1;
+}
+
+
+static inline int ethHw_dmaIsBusy(int controller, int ch)
+{
+	return CHANNEL_BUSY(controller, ch);
+}
+
+
+#endif
diff --git a/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
new file mode 100644
index 0000000..a43e7ea
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
@@ -0,0 +1,370 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+/****************************************************************************/
+/**
+*  @file    xxx.h
+*
+*  @brief   short desc
+*
+*  more detail.
+*
+*  @note
+*
+*  This file includes all the register definition for the Ethernet block
+*
+*  Defines are used over structure because of how the registers are mapped
+*  to memory. The registers are not contiguous and are seperated by multiple
+*  of 8. Some of the registers are not defined on a valid word boundary
+*  (for example: an 32-bit word on offset 0x06) but they will be on a correct
+*  word boundary after multiplying by 8. Therefore, if struct was used,
+*  the registers will either be on an invalid word boundary, or the struct
+*  will be expanded by multiple of 8 with a lot of reserved space. Defines
+*  are used as a workaround to avoid numerous reserved register space
+*  In addition, all 64-bit switch registers must be accessed with an atomic
+*  64-bit operation.  Such registers are indicated by
+*  "use_ethHw_get64_or_ethHw_set64_function" in the definitions below.  These
+*  registers should use the ethHw_get64() and ethHw_set64() functions to
+*  write and read to/from the appropriate register.
+*/
+/****************************************************************************/
+
+#ifndef _ETHHW_REG_H
+#define _ETHHW_REG_H
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <csp/reg.h>
+#include <mach/csp/mm_io.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+#define ETHHW_PORT_0         0
+#define ETHHW_PORT_1         1
+#define ETHHW_PORT_INT       8
+
+#define ETHHW_REG_BASE              MM_IO_BASE_ESW
+
+#define ETHHW_REG8(x)               (*((volatile uint8_t *)(x)))
+#define ETHHW_REG16(x)              (*((volatile uint16_t *)(x)))
+#define ETHHW_REG32(x)              (*((volatile uint32_t *)(x)))
+#define ETHHW_REG48(x)              (*((volatile uint64_t *)(x)))
+#define ETHHW_REG64(x)              (*((volatile uint64_t *)(x)))
+
+extern void ethHw_get64(uint32_t addr, volatile uint64_t *datap);
+extern void ethHw_set64_byVal(uint32_t addr, volatile uint64_t data);
+extern void ethHw_set64_byRef(uint32_t addr, volatile uint64_t *datap);
+
+/* A dummy chipc register read is required before any switch register read
+ * to ensure the value read back is correct.  Sometimes a 0 is read without
+ * the extra dummy read.  A dummy read is only required for read-modify-write
+ * or read, but not write.
+*/
+
+static volatile uint32_t dummy;
+#define regDummyRead()   dummy = reg32_read((uint32_t *)(MM_IO_PHYS_TO_VIRT(0x80000000)))
+
+#define ETHHW_REG_SET(reg, val) reg32_write((uint32_t *)(&(reg)), (uint32_t)(val))
+
+#define ETHHW_REG_GET(reg, val) \
+{ \
+	regDummyRead(); \
+	(val) = reg32_read((uint32_t *)(&(reg))); \
+}
+
+#define ETHHW_REG_GET_VAL(reg)    (regDummyRead(), reg32_read((uint32_t *)(&(reg))))
+
+#define ETHHW_REG_MASK_SET(reg, mask)   reg32_set_bits((uint32_t *)(&(reg)), (uint32_t)(mask))
+#define ETHHW_REG_MASK_CLR(reg, mask)   reg32_clear_bits((uint32_t *)(&(reg)), (uint32_t)(mask))
+
+#define ETHHW_REG_WRITE_MASKED(reg, mask, data) \
+{ \
+	volatile uint32_t val; \
+	ETHHW_REG_GET((reg), (val)); \
+	val &= ~(mask); \
+	val |= ((data) & (mask)); \
+	ETHHW_REG_SET((reg), (val)); \
+}
+
+#define ethHw_reg_get64(addr, datap) \
+do { \
+	REG_LOCAL_IRQ_SAVE; \
+	REG_LOCK_ACCESS; \
+	regDummyRead(); \
+	ethHw_get64((addr), (datap)); \
+	REG_UNLOCK_ACCESS; \
+	REG_LOCAL_IRQ_RESTORE; \
+} while (0)
+
+#if 1
+/* Use byRef since the compiler builds images differently for different targets
+ * For example, in the byVal code:
+ *    -csptest image uses:
+ *       -r0 for the addr argument
+ *       -r1 and r2 for the data argument
+ *    -Linux image uses:
+ *       -r0 for the addr argument
+ *       -r2 and r3 for the data argument
+ * In the byRef code:
+ *    -Both csptest and Linux images use:
+ *       -r0 for the addr argument
+ *       -r1 for the datap argument
+ */
+/* TODO: Figure out why the same toolchain uses different calling convention
+ *       when building certain targets (possibly due to 64-bit data type)
+ */
+#define ethHw_reg_set64(a, d) \
+do { \
+	REG_LOCAL_IRQ_SAVE; \
+	REG_LOCK_ACCESS; \
+	regDummyRead(); \
+	ethHw_set64_byRef((a), &(d)); \
+	REG_UNLOCK_ACCESS; \
+	REG_LOCAL_IRQ_RESTORE; \
+} while (0)
+
+#else
+#define ethHw_reg_set64(a, d) \
+do { \
+	REG_LOCAL_IRQ_SAVE; \
+	REG_LOCK_ACCESS; \
+	regDummyRead(); \
+	ethHw_set64_byVal((a), (d)); \
+	REG_UNLOCK_ACCESS; \
+	REG_LOCAL_IRQ_RESTORE; \
+} while (0)
+#endif
+
+#define ethHw_reg_mask_set64(addr, mask) \
+do { \
+	volatile uint64_t data; \
+	ethHw_reg_get64((addr), &(data)); \
+	(data) |= (mask); \
+	ethHw_reg_set64((addr), (data)); \
+} while (0)
+
+#define ethHw_reg_mask_clr64(addr, mask) \
+do { \
+	volatile uint64_t data; \
+	ethHw_reg_get64((addr), &(data)); \
+	(data) &= ~(mask); \
+	ethHw_reg_set64((addr), (data)); \
+} while (0)
+
+#define ETHHW_REG_GET64(addr, datap)                ethHw_reg_get64((addr), (datap))
+#define ETHHW_REG_SET64(addr, data)                 ethHw_reg_set64((addr), (data))
+#define ETHHW_REG_MASK_SET64(addr, mask)            ethHw_reg_mask_set64((addr), (mask))
+#define ETHHW_REG_MASK_CLR64(addr, mask)            ethHw_reg_mask_clr64((addr), (mask))
+#define ETHHW_REG_WRITE_MASKED64(addr, mask, data) \
+{ \
+	volatile uint64_t val; \
+	ETHHW_REG_GET64((addr), &(val)); \
+	val &= ~(mask); \
+	val |= ((data) & (mask)); \
+	ETHHW_REG_SET64((addr), (val)); \
+}
+
+#define ETHHW_REG_PAGEADDR(p, a)             (ETHHW_REG_BASE | (((uint8_t)(p) << 8) + (uint8_t)(a)) * 8)
+
+#define ETHHW_REG_PAGE_CTRL                  0x00
+#define ETHHW_REG_PAGE_STATUS                0x01
+#define ETHHW_REG_PAGE_MGMT                  0x02
+#define ETHHW_REG_PAGE_ARL                   0x05
+#define ETHHW_REG_PAGE_MII(port)             (0x10+(port))
+#define ETHHW_REG_PAGE_MIB(port)             (0x20+(port))
+#define ETHHW_REG_PAGE_IMP_CTRL              0x34
+#define ETHHW_REG_PAGE_MII_EXT(port)         (0x80+(port))
+
+
+/* Page 00h, Control Register */
+#define ethHw_regCtrlPortCtrl(port)                   ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, (port)))
+#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_ENUM_OFFSET 1
+#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT       5
+#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_MASK        (7 << ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT)
+#define ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE        0x002
+#define ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE        0x001
+#define ETHHW_REG_CTRL_PORTCTRL_MAC_DISABLE           (ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE|ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE)
+
+#define ethHw_regCtrlImpCtrl                          ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, 0x08))
+#define ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN            0x10
+#define ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN            0x08
+#define ETHHW_REG_CTRL_IMPCTRL_RX_BCAST_EN            0x04
+
+#define ethHw_regCtrlSwitchMode                       ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, 0x0B))
+#define ETHHW_REG_CTRL_SW_FWDG_EN                     0x02
+#define ETHHW_REG_CTRL_SW_FWDG_MODE                   0x01
+
+#define ethHw_regCtrlProtectPortSel                   ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, 0x24))
+
+/* Page 01h, Status Register */
+#define ethHw_regStatusLinkStatus                     ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x00))
+#define ethHw_regStatusLinkStatusChange               ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x02))
+#define ethHw_regStatusPortSpeed                      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x04))
+#define ETHHW_REG_STATUS_PORT_SPEED_MASK              0x3
+#define ETHHW_REG_STATUS_PORT_SPEED_10MB              0x0
+#define ETHHW_REG_STATUS_PORT_SPEED_100MB             0x1
+#define ETHHW_REG_STATUS_PORT_SPEED_1000MB            0x2
+#define ETHHW_REG_STATUS_PORT_SPEED_SHIFT(port)       (2*(port))
+
+
+/* Page 02h, Management Mode Register */
+#define ethHw_regMgmtGblMgmtCtrl                      ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MGMT, 0x00))
+#define ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_MASK      0xC0
+#define ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN        0x80
+#define ETHHW_REG_MGMT_GBLMGMTCTRL_RX_BPDU_EN         0x02
+
+
+/* Page 05h, ARL Access Register */
+#define ethHw_regArlRwCtrl                            ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x00))
+#define ETHHW_REG_ARL_RWCTRL_START_DONE               0x80
+#define ETHHW_REG_ARL_RWCTRL_READ                     0x01
+#define ETHHW_REG_ARL_RWCTRL_WRITE                    0x00
+#define ETHHW_REG_ARL_MAC_INDEX                       ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x02)
+#define ethHw_regArlMacIndex                          use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG48(ETHHW_REG_ARL_MAC_INDEX) */
+#define ethHw_regArlVlanIndex                         ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x08))
+#define ETHHW_REG_ARL_MAC_VID_ENTRY(x)                ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x10 + ((x)*0x10)))
+#define ethHw_regArlMacVidEntry(x)                    use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG64(ETHHW_REG_ARL_MAC_VID_ENTRY((x))) */
+#define ethHw_regArlFwdEntry(x)                       ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x18 + ((x)*0x10))))
+#define ETHHW_REG_ARL_FWDENTRY_VALID                  0x00010000
+#define ETHHW_REG_ARL_FWDENTRY_STATIC                 0x00008000
+#define ETHHW_REG_ARL_FWDENTRY_AGE                    0x00004000
+#define ETHHW_REG_ARL_FWDENTRY_TC_SHIFT               11
+#define ethHw_regArlSearchCtrl                        ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x50))
+#define ethHw_regArlSearchAddr                        ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x51))
+#define ETHHW_REG_ARL_SEARCH_MAC_VID(x)               ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x60 + ((x)*0x10)))
+#define ethHw_regArlSearchMacVid(x)                   use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG64(ETHHW_REG_ARL_SEARCH_MAC_VID((x)) */
+#define ethHw_regArlSearchResult(x)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x68 + ((x)*0x10))))
+
+/* #define ETHHW_REG_ARL_MAC_VID_ENTRY0                  ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x10) */
+/* #define ethHw_regArlMacVidEntry0                      use_ethHw_get64_or_ethHw_set64_function ETHHW_REG64(ETHHW_REG_ARL_MAC_VID_ENTRY0) */
+/* #define ethHw_regArlFwdEntry0                         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x18)) */
+
+#define ETHHW_REG_ARL_TIMEOUT                         100
+#define ETHHW_REG_ARL_ENTRY_MIN                       0
+#define ETHHW_REG_ARL_ENTRY_MAX                       3
+
+/* Page 34h, IMP Control Register */
+#define ethHw_regImpEnable                               ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_IMP_CTRL, 0x06))
+#define ETHHW_REG_IMP_ENABLE                          0x00000001
+
+/* Page 10h-11h, MII Register */
+#define ethHw_regMdioAddr                                ETHHW_REG32(ETHHW_REG_BASE + 0x000A0008)
+#define ethHw_regMdioWriteData                           ETHHW_REG32(ETHHW_REG_BASE + 0x000A0010)
+#define ethHw_regMdioReadData                            ETHHW_REG32(ETHHW_REG_BASE + 0x000A0018)
+#define ethHw_regMdioStatus                              ETHHW_REG32(ETHHW_REG_BASE + 0x000A0020)
+#define ETHHW_REG_MDIO_SERDES_MASK                    0x00000010
+#define ETHHW_REG_MDIO_DONE_MASK                      0x00000008
+#define ETHHW_REG_MDIO_EXTRA_MASK                     0x00000004
+#define ETHHW_REG_MDIO_READ_MASK                      0x00000002
+#define ETHHW_REG_MDIO_WRITE_MASK                     0x00000001
+
+#define ETHHW_REG_MII_TIMEOUT                         10000
+
+
+/* Use physical address when specifying MDIO address */
+#define ETHHW_REG_MII_EXT(port, offset)               ((ETHHW_REG_PAGE_MII_EXT((port)) << 8) | (uint8_t)(offset))
+#define ETHHW_REG_MII_GPHY(port, offset)              ((ETHHW_REG_PAGE_MII((port)) << 8) | (uint8_t)(offset))
+
+#define ETHHW_REG_MII                                 ETHHW_REG_MII_GPHY
+
+/* Page 20h, Port MIB Register */
+#define ETHHW_REG_MIB_TX_OCTETS(port)                 ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x00)
+#define ETHHW_REG_MIB_TxOctets                        ETHHW_REG_MIB_TX_OCTETS
+#define ethHw_regMibTxDropPkts(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x08))
+#define ethHw_regMibTxQ0Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x0C))
+#define ethHw_regMibTxBroadcastPkts(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x10))
+#define ethHw_regMibTxMulticastPkts(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x14))
+#define ethHw_regMibTxUnicastPkts(port)               ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x18))
+#define ethHw_regMibTxCollisions(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x1C))
+#define ethHw_regMibTxSingleCollision(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x20))
+#define ethHw_regMibTxMultipleCollision(port)         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x24))
+#define ethHw_regMibTxDeferredTransmit(port)          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x28))
+#define ethHw_regMibTxLateCollision(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x2C))
+#define ethHw_regMibTxExcessiveCollision(port)        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x30))
+#define ethHw_regMibTxFrameInDisc(port)               ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x34))
+#define ethHw_regMibTxPausePkts(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x38))
+#define ethHw_regMibTxQ1Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x3C))
+#define ethHw_regMibTxQ2Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x40))
+#define ethHw_regMibTxQ3Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x44))
+#define ethHw_regMibTxQ4Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x48))
+#define ethHw_regMibTxQ5Pkt(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x4C))
+#define ETHHW_REG_MIB_RX_OCTETS(port)                 ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x50)
+#define ETHHW_REG_MIB_RxOctets                        ETHHW_REG_MIB_RX_OCTETS
+#define ethHw_regMibRxUndersizePkts(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x58))
+#define ethHw_regMibRxPausePkts(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x5C))
+#define ethHw_regMibPkts64Octets(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x60))
+#define ethHw_regMibPkts65To127Octets(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x64))
+#define ethHw_regMibPkts128To255Octets(port)          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x68))
+#define ethHw_regMibPkts256To511Octets(port)          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x6C))
+#define ethHw_regMibPkts512To1023Octets(port)         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x70))
+#define ethHw_regMibPkts1024ToMaxPktOctets(port)      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x74))
+#define ethHw_regMibRxOversizePkts(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x78))
+#define ethHw_regMibRxJabbers(port)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x7C))
+#define ethHw_regMibRxAlignmentErrors(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x80))
+#define ethHw_regMibRxFcsErrors(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x84))
+#define ETHHW_REG_MIB_RX_GOOD_OCTETS(port)            ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x88)
+#define ETHHW_REG_MIB_RxGoodOctets                    ETHHW_REG_MIB_RX_GOOD_OCTETS
+#define ethHw_regMibRxDropPkts(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x90))
+#define ethHw_regMibRxUnicastPkts(port)               ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x94))
+#define ethHw_regMibRxMulticastPkts(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x98))
+#define ethHw_regMibRxBroadcastPkts(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x9C))
+#define ethHw_regMibRxSaChanges(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA0))
+#define ethHw_regMibRxFragments(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA4))
+#define ethHw_regMibJumboPktCount(port)               ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA8))
+#define ethHw_regMibRxSymbolError(port)               ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xAC))
+#define ethHw_regMibInRangeErrorCount(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xB0))
+#define ethHw_regMibOutRangeErrorCount(port)          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xB4))
+#define ethHw_regMibRxDiscard(port)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC0))
+#define ethHw_regMibDosAssertCount(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC4))
+#define ethHw_regMibDosDropCount(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC8))
+#define ethHw_regMibIngressRateAssertCount(port)      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xCC))
+#define ethHw_regMibIngressRateDropCount(port)        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xD0))
+#define ethHw_regMibEgressRateAssertCount(port)       ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xD4))
+
+
+/* Switch interface register definitions */
+#define ethHw_regPtmConfig                               ETHHW_REG32(ETHHW_REG_BASE | 0x80008)
+#define ETHHW_REG_PTM_CONFIG_ENABLE                   0x90000000
+#define ETHHW_REG_PTM_CONFIG_BURST(burst)             ((burst) << 1)
+#define ETHHW_REG_PTM_CONFIG_BLOCK(block)             ((block) << 10)
+
+#define ethHw_regPtmDmaStatus                            ETHHW_REG32(ETHHW_REG_BASE | 0x80010)
+
+#define ethHw_regPtmFifoConfig                           ETHHW_REG32(ETHHW_REG_BASE | 0x88000)
+
+#define ethHw_regMtpConfig                               ETHHW_REG32(ETHHW_REG_BASE | 0x90000)
+#define ETHHW_REG_MTP_CONFIG_ENABLE                   0x90000001
+/* Per design, burst size needs to be increased by one for non-A0 silicon */
+#define ETHHW_REG_MTP_CONFIG_BURST(burst)             (((burst) + 1) << 1)
+
+#define ethHw_regMtpFifoConfig                           ETHHW_REG32(ETHHW_REG_BASE | 0x90008)
+
+#define ethHw_regMtpDmaStatus                            ETHHW_REG32(ETHHW_REG_BASE | 0x90010)
+
+#define ethHw_regMtpFifoData                             ETHHW_REG32(ETHHW_REG_BASE | 0x98000)
+
+#define ethHw_regImpPhyMisc                              ETHHW_REG32(ETHHW_REG_BASE | 0xa0000)
+
+#define ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port)        ((0x5 << (13 + (port))) & 0x0001e000)
+#define ETHHW_REG_IMP_PHY_MISC_READY                  0x00800000
+#define ETHHW_REG_READY_TIMEOUT                       100
+
+#define ethHw_regImpSpeed                                ETHHW_REG32(ETHHW_REG_BASE | 0xa0090)
+#define ETHHW_REG_IMP_SPEED_TX(s)                     ((s) << 4)
+#define ETHHW_REG_IMP_SPEED_RX(s)                     ((s) << 0)
+#define ETHHW_REG_IMP_SPEED(s)                        (ETHHW_REG_IMP_SPEED_TX(s) | ETHHW_REG_IMP_SPEED_RX(s))
+#define ETHHW_REG_IMP_SPEED_MASK                      0xf
+#define ETHHW_REG_IMP_SPEED_MASK_1000MBPS             0x4
+#define ETHHW_REG_IMP_SPEED_MASK_100MBPS              0x1
+#define ETHHW_REG_IMP_SPEED_MASK_10MBPS               0x2
+
+#endif /* _ETHHW_REG_H */
diff --git a/arch/arm/mach-bcmring/include/mach/pm.h b/arch/arm/mach-bcmring/include/mach/pm.h
new file mode 100644
index 0000000..cb950fa
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/pm.h
@@ -0,0 +1,57 @@
+/*****************************************************************************
+* Copyright 2005 - 2009 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+#ifndef __ASM_ARCH_PM_H
+#define __ASM_ARCH_PM_H
+
+#include <cfg_global.h>
+
+/*
+ * Power states
+ */
+typedef enum {
+	pm_state_sleep,
+	pm_state_alive
+}
+pm_state_e;
+
+/*
+ * This is the callout definition for the display\
+ * update code.
+ */
+typedef void (*pm_lcd_callout_t)(void);
+
+/*
+ * Get the LCD power state
+ */
+pm_state_e pm_lcd_get_state(void);
+
+/*
+ * Register a callout to have the low power suspend
+ * code call when the LCD is active. Note that this
+ * callout code is responsible for updating the display
+ * should clock, animation, etc be required while the
+ * system is 'sleeping'.
+ */
+void pm_lcd_register_callout(pm_lcd_callout_t callout);
+
+/*
+ * Get the NET power state
+ */
+pm_state_e pm_net_get_state(void);
+
+#endif /* __ASM_ARCH_PM_H */
+
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2b4bbc4..d47655d 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2313,6 +2313,21 @@ config ATL1E
 	  To compile this driver as a module, choose M here.  The module
 	  will be called atl1e.
 
+config NET_BCMRING
+	tristate "Broadcom BCMRING Ethernet support"
+	depends on NET_ETHERNET && ARCH_BCMRING
+	help
+	  Say Y to enable ethernet support on the BCMRING platforms.
+	  Otherwise, say N.
+
+config NET_BCMRING_ETHTOOL
+	bool "Broadcom BCMRING Ethernet Ethtool support"
+	depends on NET_BCMRING
+	help
+	  Say Y to enable the ethtool support on BCMRING Ethernet.
+	  Otherwise, say N.
+
+
 endif # NETDEV_1000
 
 #
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 0818ce2..95bae5a 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -68,6 +68,7 @@ obj-$(CONFIG_TIGON3) += tg3.o
 obj-$(CONFIG_BNX2) += bnx2.o
 obj-$(CONFIG_BNX2X) += bnx2x.o
 bnx2x-objs := bnx2x_main.o bnx2x_link.o
+obj-$(CONFIG_NET_BCMRING) += bcmring_net.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
 obj-$(CONFIG_GELIC_NET) += ps3_gelic.o
diff --git a/drivers/net/bcmring_ethtool.c b/drivers/net/bcmring_ethtool.c
new file mode 100644
index 0000000..640d3b2
--- /dev/null
+++ b/drivers/net/bcmring_ethtool.c
@@ -0,0 +1,881 @@
+/*****************************************************************************
+* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#ifndef CONFIG_NET_BCMRING_ETHTOOL
+/* Ideally, bcmring_ethtool.c is compiled separately and linked with
+*  bcmring_net.c, however, the build env will create a separate module.  For
+*  now, this file is simply included in bcmring_net.c
+*/
+#error This file is meant to be included by network wrapper file such as bcmring_net.c
+#endif
+
+#include <linux/ethtool.h>
+
+/* The way in which ethtool dumps the register values is not easy for a
+*  developer to work with.  This custom dump will print the register contents
+*  from within the ethtool hook function.
+*/
+#define GET_REGS_CUSTOM       0
+
+/* Maximum duration for PHY identification (in seconds)
+*/
+#define PHYS_ID_DURATION_MAX  30
+
+/* Extensions to linux/mii.h */
+
+/* Extended mode status register */
+#ifndef EMSR_1000HALF
+#define EMSR_1000HALF         0x0100
+#endif
+#ifndef EMSR_1000FULL
+#define EMSR_1000FULL         0x0200
+#endif
+
+typedef char ETHTOOL_STAT_STR[ETH_GSTRING_LEN];
+
+static const ETHTOOL_STAT_STR ethtoolStrStat[] = {
+	/* The order of the strings should not be changed since other code depends
+	*  on this specific order (same as bcmring_ethtool_get_ethtool_stats())
+	*/
+
+	/* TODO:  Since /phy stats can be displayed, consider adding collision
+	*         counters
+	*/
+
+	"Octets    <eth>|<phy>->Rx|Rx",
+	"DropPkts               Rx|Rx",
+	"Q0Pkt                  Rx|Tx",
+	"BroadcastPkts          Rx|Rx",
+	"MulticastPkts          Rx|Rx",
+	"UnicastPkts            Rx|Rx",
+	"PausePkts              Rx|Rx",
+	"Q1Pkt                  Rx|Tx",
+	"Q2Pkt                  Rx|Tx",
+	"Q3Pkt                  Rx|Tx",
+	"Q4Pkt                  Rx|Tx",
+	"Q5Pkt                  Rx|Tx",
+	"Octets                 Tx|Tx",
+	"UndersizePkts          Tx|Rx",
+	"PausePkts              Tx|Tx",
+	"Pkts64Octets           Tx|Rx",
+	"Pkts65To127Octets      Tx|Rx",
+	"Pkts128To255Octets     Tx|Rx",
+	"Pkts256To511Octets     Tx|Rx",
+	"Pkts512To1023Octets    Tx|Rx",
+	"Pkts1024ToMaxPktOctets Tx|Rx",
+	"GoodOctets             Tx|Tx",
+	"DropPkts               Tx|Tx",
+	"UnicastPkts            Tx|Tx",
+	"MulticastPkts          Tx|Tx",
+	"BroadcastPkts          Tx|Tx",
+	"SaChanges              Tx|Rx",
+	"JumboPktCount          Tx|Rx",
+	"InRangeErrorCount      Tx|Rx",
+	"OutRangeErrorCount     Tx|Rx",
+	"Discard                Tx|Rx",
+};
+
+
+static const ETHTOOL_STAT_STR ethtoolStrTest[] =
+{
+	"Register Access         ",
+	"Internal Memory         ",
+	"PHY Loopback (local)    ",
+};
+
+
+static u32 alwaysEnabled(struct net_device *dev);
+#if 0
+static u32 alwaysDisabled(struct net_device *dev);
+#endif
+
+static int bcmring_ethtool_get_settings(struct net_device *dev,
+					struct ethtool_cmd *cmd);
+static int bcmring_ethtool_set_settings(struct net_device *dev,
+					struct ethtool_cmd *cmd);
+static void bcmring_ethtool_get_drvinfo(struct net_device *dev,
+					struct ethtool_drvinfo *info);
+static int bcmring_ethtool_get_regs_len(struct net_device *dev);
+static void bcmring_ethtool_get_regs(struct net_device *dev,
+				     struct ethtool_regs *regs, void *p);
+static u32 bcmring_ethtool_get_msglevel(struct net_device *dev);
+static void bcmring_ethtool_set_msglevel(struct net_device *dev, u32 level);
+static int bcmring_ethtool_nway_reset(struct net_device *dev);
+static void bcmring_ethtool_get_ringparam(struct net_device *dev,
+					  struct ethtool_ringparam *ering);
+static int bcmring_ethtool_set_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *ering);
+static void bcmring_ethtool_get_pauseparam(struct net_device *dev,
+					   struct ethtool_pauseparam *epause);
+static int bcmring_ethtool_set_pauseparam(struct net_device *dev,
+					  struct ethtool_pauseparam *epause);
+static int bcmring_ethtool_get_test_count(struct net_device *dev);
+static void bcmring_ethtool_self_test(struct net_device *dev,
+				      struct ethtool_test *etest,
+				      u64 *data);
+static void bcmring_ethtool_get_strings(struct net_device *dev,
+					u32 strSet, u8 *buf);
+static int bcmring_ethtool_phys_id(struct net_device *dev, u32 data);
+static int bcmring_ethtool_get_stats_count(struct net_device *dev);
+static void bcmring_ethtool_get_ethtool_stats(struct net_device *dev,
+					      struct ethtool_stats *estats,
+					      u64 *tmp_stats);
+
+static struct ethtool_ops bcmring_ethtool_ops = {
+	.get_settings		= bcmring_ethtool_get_settings,
+	.set_settings		= bcmring_ethtool_set_settings,
+	.get_drvinfo		= bcmring_ethtool_get_drvinfo,
+	.get_regs_len		= bcmring_ethtool_get_regs_len,
+	.get_regs		= bcmring_ethtool_get_regs,
+	.get_wol		= NULL,        /* Not supported */
+	.set_wol		= NULL,        /* Not supported */
+	.get_msglevel		= bcmring_ethtool_get_msglevel,
+	.set_msglevel		= bcmring_ethtool_set_msglevel,
+	.nway_reset		= bcmring_ethtool_nway_reset,
+	.get_link		= ethtool_op_get_link,
+	.get_eeprom_len		= NULL,        /* Not supported */
+	.get_eeprom		= NULL,        /* Not supported */
+	.set_eeprom		= NULL,        /* Not supported */
+	.get_coalesce		= NULL,        /* Not supported */
+	.set_coalesce		= NULL,        /* Not supported */
+	.get_ringparam		= bcmring_ethtool_get_ringparam,
+	.set_ringparam		= bcmring_ethtool_set_ringparam,
+	.get_pauseparam		= bcmring_ethtool_get_pauseparam,
+	.set_pauseparam		= bcmring_ethtool_set_pauseparam,
+	.get_rx_csum		= alwaysEnabled,
+	.set_rx_csum		= NULL,        /* Not supported */
+	.get_tx_csum		= alwaysEnabled,
+	.set_tx_csum		= NULL,        /* Not supported */
+	.get_sg			= NULL,        /* Not supported */
+	.set_sg			= NULL,        /* Not supported */
+	.get_tso		= NULL,        /* Not supported */
+	.set_tso		= NULL,        /* Not supported */
+	.self_test_count	= bcmring_ethtool_get_test_count,
+	.self_test		= bcmring_ethtool_self_test,
+	.get_strings		= bcmring_ethtool_get_strings,
+	.phys_id		= bcmring_ethtool_phys_id,
+	.get_stats_count	= bcmring_ethtool_get_stats_count,
+	.get_ethtool_stats	= bcmring_ethtool_get_ethtool_stats,
+	.begin			= NULL,        /* Not supported */
+	.complete		= NULL,        /* Not supported */
+	.get_ufo		= ethtool_op_get_ufo,
+	.set_ufo		= ethtool_op_set_ufo,
+};
+
+
+/* TODO: Add proper register defs */
+#define REG_LED_MODE_MAP_0       (*((uint16_t *)MM_IO_PHYS_TO_VIRT(0x304000c0)))
+#define REG_LED_MODE_MAP_1       (*((uint16_t *)MM_IO_PHYS_TO_VIRT(0x304000d0)))
+
+typedef enum {
+	PHY_MODE_INTERNAL,
+	PHY_MODE_EXTERNAL,
+} PHY_MODE_t;
+
+#define ethHw_phy_mode_get(n)    PHY_MODE_INTERNAL
+#define ethHw_phy_mode_set(n, t)  /* Do nothing for now */
+
+
+static u32 alwaysEnabled(struct net_device *dev)
+{
+	(void)dev;
+
+	return 1;
+}
+
+
+#if 0
+static u32 alwaysDisabled(struct net_device *dev)
+{
+	(void)dev;
+
+	return 0;
+}
+#endif
+
+
+static int bcmring_ethtool_get_settings(struct net_device *dev,
+					struct ethtool_cmd *cmd)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	int reg;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	reg = ethMiiGet(ethp->phyPort, MII_BMSR);
+	cmd->supported = 0;
+	cmd->supported |= ((reg & BMSR_10HALF) ? SUPPORTED_10baseT_Half : 0);
+	cmd->supported |= ((reg & BMSR_10FULL) ? SUPPORTED_10baseT_Full : 0);
+	cmd->supported |= ((reg & BMSR_100HALF) ? SUPPORTED_100baseT_Half : 0);
+	cmd->supported |= ((reg & BMSR_100FULL) ? SUPPORTED_100baseT_Full : 0);
+	cmd->supported |= ((reg & BMSR_ANEGCAPABLE) ? SUPPORTED_Autoneg : 0);
+	cmd->supported |= SUPPORTED_Autoneg;
+	cmd->supported |= SUPPORTED_TP;
+	cmd->supported |= (SUPPORTED_Pause | SUPPORTED_Asym_Pause);
+
+	if (privp->chip.gmiiAvailable[ethp->phyPort]) {
+		if (reg & BMSR_ESTATEN) {
+			reg = ethMiiGet(ethp->phyPort, MII_ESTATUS);
+			cmd->supported |= ((reg & ESTATUS_1000_THALF) ? SUPPORTED_1000baseT_Half : 0);
+			cmd->supported |= ((reg & ESTATUS_1000_TFULL) ? SUPPORTED_1000baseT_Full : 0);
+		}
+	}
+
+	reg = ethMiiGet(ethp->phyPort, MII_BMCR);
+	cmd->autoneg = ((reg & BMCR_ANENABLE) ? AUTONEG_ENABLE : AUTONEG_DISABLE);
+	if (cmd->autoneg) {
+		struct {
+			int speed;
+			int duplex;
+		} link[] = {
+			{ SPEED_10, DUPLEX_HALF },	/* [0] No HCD */
+			{ SPEED_10, DUPLEX_HALF },
+			{ SPEED_10, DUPLEX_FULL },
+			{ SPEED_100, DUPLEX_HALF },
+			{ SPEED_100, DUPLEX_HALF },
+			{ SPEED_100, DUPLEX_FULL },
+			{ SPEED_1000, DUPLEX_HALF },
+			{ SPEED_1000, DUPLEX_FULL }
+		};
+
+		/* Autonegotiation is enabled, so report settings */
+		/* TODO: Current link state is reported in vendor-specific MII
+		*		  registers, so this code may not work for non-Broadcom PHYs
+		*/
+		reg = ethMiiGet(ethp->phyPort, 0x19);
+		cmd->speed = link[(reg >> 8) & 0x0007].speed;
+		cmd->duplex = link[(reg >> 8) & 0x0007].duplex;
+	} else {
+		int speed[] = { SPEED_10, SPEED_100, SPEED_1000, -1 };
+
+		/* Autonegotiation is disabled, so report forced settings */
+		cmd->speed = speed[((reg & BMCR_SPEED100) ? 1 : 0) | ((reg & BMCR_SPEED1000) ? 2 : 0)];
+		cmd->duplex = ((reg & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF);
+	}
+
+	reg = ethMiiGet(ethp->phyPort, MII_ADVERTISE);
+	cmd->advertising = 0;
+	cmd->advertising |= ((reg & ADVERTISE_10HALF) ? ADVERTISED_10baseT_Half : 0);
+	cmd->advertising |= ((reg & ADVERTISE_10FULL) ? ADVERTISED_10baseT_Full : 0);
+	cmd->advertising |= ((reg & ADVERTISE_100HALF) ? ADVERTISED_100baseT_Half : 0);
+	cmd->advertising |= ((reg & ADVERTISE_100FULL) ? ADVERTISED_100baseT_Full : 0);
+	cmd->advertising |= ((reg & ADVERTISE_PAUSE_CAP) ? ADVERTISED_Pause : 0);
+	cmd->advertising |= ((reg & ADVERTISE_PAUSE_ASYM) ? ADVERTISED_Asym_Pause : 0);
+
+	cmd->advertising |= ADVERTISED_TP;
+
+	reg = ethMiiGet(ethp->phyPort, MII_CTRL1000);
+	cmd->advertising |= ((reg & ADVERTISE_1000HALF) ? ADVERTISED_1000baseT_Half : 0);
+	cmd->advertising |= ((reg & ADVERTISE_1000FULL) ? ADVERTISED_1000baseT_Full : 0);
+	cmd->advertising |= ((cmd->autoneg == AUTONEG_ENABLE) ? ADVERTISED_Autoneg : 0);
+
+	/* Treat phy_address as physical port number */
+	cmd->phy_address = ethp->phyPort;
+
+	cmd->transceiver = ((ethHw_phy_mode_get(UNIT_NUM) == PHY_MODE_INTERNAL) ?
+					XCVR_INTERNAL : XCVR_EXTERNAL);
+
+	/* Hard-coded configuration */
+	cmd->port = PORT_TP;
+	cmd->maxtxpkt = 0;
+	cmd->maxrxpkt = 0;
+
+	return 0;
+}
+
+
+static int bcmring_ethtool_set_settings(struct net_device *dev,
+					struct ethtool_cmd *cmd)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	int reg;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	/* Override LAN port */
+	ethp->phyPort = cmd->phy_address;
+
+	/* Get currrent advertised link settings */
+	reg = ethMiiGet(ethp->phyPort, MII_ADVERTISE);
+
+	/* Default to advertise nothing */
+	reg &= ~(ADVERTISE_10FULL    | ADVERTISE_10HALF |
+		 ADVERTISE_100FULL   | ADVERTISE_100HALF |
+		 ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+	reg |= ((cmd->advertising & ADVERTISED_10baseT_Half)  ? ADVERTISE_10HALF     : 0);
+	reg |= ((cmd->advertising & ADVERTISED_10baseT_Full)  ? ADVERTISE_10FULL     : 0);
+	reg |= ((cmd->advertising & ADVERTISED_100baseT_Half) ? ADVERTISE_100HALF    : 0);
+	reg |= ((cmd->advertising & ADVERTISED_100baseT_Full) ? ADVERTISE_100FULL    : 0);
+	reg |= ((cmd->advertising & ADVERTISED_Pause)         ? ADVERTISE_PAUSE_CAP  : 0);
+	reg |= ((cmd->advertising & ADVERTISED_Asym_Pause)    ? ADVERTISE_PAUSE_ASYM : 0);
+
+	/* Set advertised link settings */
+	ethMiiSet(ethp->phyPort, MII_ADVERTISE, reg);
+
+	/* Get currrent extended advertised link settings */
+	reg = ethMiiGet(ethp->phyPort, MII_CTRL1000);
+
+	/* Default to advertise nothing */
+	reg &= ~(ADVERTISE_1000FULL | ADVERTISE_1000HALF);
+
+	/* Set advertised link settings */
+	/* NOTE:  Allow user to advertise 1000Mbps support even though it may not
+	*         supported.
+	*/
+	reg |= ((cmd->advertising & ADVERTISED_1000baseT_Half) ? ADVERTISE_1000HALF : 0);
+	reg |= ((cmd->advertising & ADVERTISED_1000baseT_Full) ? ADVERTISE_1000FULL : 0);
+
+	/* Set extended advertised link settings */
+	ethMiiSet(ethp->phyPort, MII_CTRL1000, reg);
+
+	/* Get current autonegotiation and forced state */
+	reg = ethMiiGet(ethp->phyPort, MII_BMCR);
+
+	/* Default to:
+	*     autoneg = disabled
+	*     dulpex  = half
+	*     speed   = 10Mbps
+	*/
+	reg &= ~(BMCR_ANENABLE | BMCR_FULLDPLX | BMCR_SPEED100 | BMCR_SPEED1000);
+
+	reg |= ((cmd->autoneg == AUTONEG_ENABLE) ? BMCR_ANENABLE : 0);
+
+	if (cmd->speed == SPEED_100) {
+		reg |= BMCR_SPEED100;
+	} else if (cmd->speed == SPEED_1000) {
+		/* NOTE:  Allow user to force 1000Mbps support even though it may not
+		*			supported.
+		*/
+		reg |= BMCR_SPEED1000;
+	}
+
+	reg |= ((cmd->duplex == DUPLEX_FULL) ? BMCR_FULLDPLX : 0);
+
+	/* Set autonegotiation and forced state */
+	ethMiiSet(ethp->phyPort, MII_BMCR, reg);
+
+	/* Set PHY type */
+	if ((cmd->transceiver == XCVR_EXTERNAL) && (privp->chip.portNumExt == 0)) {
+		/* Attempting to set external PHY, but not supported */
+	} else {
+		/* TODO:  Although the chip supports both internal and external PHYs,
+		*			the hardware may only support one mode.  Perhaps add some
+		*			smarts to see if the PHY is connected
+		*/
+		ethHw_phy_mode_set(UNIT_NUM, ((cmd->transceiver == XCVR_INTERNAL) ?
+					PHY_MODE_INTERNAL : PHY_MODE_EXTERNAL));
+	}
+
+	/* Read-only settings:
+	*     cmd->supported
+	*/
+
+	/* Unsupported settings:
+	*     cmd->port
+	*     cmd->maxtxpkt
+	*     cmd->maxrxpkt
+	*/
+	if (cmd->port != PORT_TP)
+		printk("Unable to change port type.  Only twisted-pair is supported\n");
+
+	if ((cmd->maxtxpkt != 0) || (cmd->maxrxpkt != 0))
+		printk("Unable to change packet interrupts.  This setting is not supported\n");
+
+	/* NOTE: User is responsible for restarting autonegotiation with
+	*        "ethool -r"
+	*/
+
+	return 0;
+}
+
+
+static void bcmring_ethtool_get_drvinfo(struct net_device *dev,
+					struct ethtool_drvinfo *info)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	strcpy(info->driver, BCM_NET_MODULE_DESCRIPTION);
+	strcpy(info->version, BCM_NET_MODULE_VERSION);
+#ifndef SVNVERSION
+#define SVNVERSION "?"
+#endif
+
+	strcpy(info->fw_version, "SVN Build " SVNVERSION);
+#if 0
+	/* TODO:  Add support for external PHY */
+	if (ethlExtPhyIsEnabled(privp->eth.drvp))
+		strcpy(info->bus_info, "Internal bus, external PHY (SGMII)");
+	else
+#endif
+	{
+		strcpy(info->bus_info, "Internal bus, internal PHY (GMII)");
+	}
+}
+
+
+typedef struct {
+	uint32_t start;
+	uint32_t end;
+} ADDR_RANGE;
+
+static ADDR_RANGE regRange[] = {
+	{ 0x30400000, 0x304003f0 },
+	{ 0x30400800, 0x30400850 },
+	{ 0x30401000, 0x30401280 },
+	{ 0x30402000, 0x304020c0 },
+	{ 0x30402800, 0x30402c18 },
+	{ 0x30410000, 0x304107f8 },
+	{ 0x30410800, 0x30410ff8 },
+	{ 0x30414000, 0x304147f8 },
+	{ 0x304a0000, 0x304a0090 },
+};
+
+
+#if GET_REGS_CUSTOM
+static const char *regRangeStr[] = {
+	"Control",
+	"Status",
+	"Management",
+	"ARL Access",
+	"ARL Vtbl Access",
+	"External Port 0 MIB",
+	"External Port 1 MIB",
+	"IMP Port MIB",
+	"IMP port and dual gphy misc.",
+};
+
+
+static void dumpRegs(uint32_t start, uint32_t end, char *descp)
+{
+	uint32_t addr;
+
+	/* NOTE:  The register space only has valid registers every second 32-bit
+	*         word
+	*/
+
+	/*      "0x00000000: 00000000 00000000 00000000 00000000\n" */
+	printk("\n%s:\n", descp);
+	printk("             +0x00    +0x08    +0x10    +0x18");
+
+	for (addr = start; addr <= end; addr += 8) {
+		if ((addr % 0x20) == 0)
+			printk("\n0x%08x: ", addr);
+
+		printk("%08x ", *((uint32_t *)MM_IO_PHYS_TO_VIRT(addr)));
+	}
+
+	printk("\n");
+}
+#endif
+
+
+static int bcmring_ethtool_get_regs_len(struct net_device *dev)
+{
+#if GET_REGS_CUSTOM
+	return 0;
+#else
+	return 16 * 1024;
+#endif
+}
+
+
+static void bcmring_ethtool_get_regs(struct net_device *dev,
+				     struct ethtool_regs *regs, void *p)
+{
+	register int i;
+	uint32_t *bufp;
+
+	regs->version = 0;
+	regs->len = 0;
+
+	bufp = (uint32_t *)p;
+
+	for (i = 0; i < (sizeof(regRange) / sizeof(regRange[0])); i++) {
+#if GET_REGS_CUSTOM
+		dumpRegs(regRange[i].start, regRange[i].end, regRangeStr[i]);
+#else
+		register int addr;
+
+		/* NOTE:  The register space only has valid registers every
+		 * second 32-bit word
+		 */
+
+		for (addr = regRange[i].start; addr <= regRange[i].end; addr += (2 * sizeof(uint32_t))) {
+			*bufp++ = *((uint32_t *)MM_IO_PHYS_TO_VIRT(addr));
+			regs->len += sizeof(uint32_t);
+		}
+#endif
+	}
+}
+
+
+static u32 bcmring_ethtool_get_msglevel(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	/* Share the sysctl message level */
+	return sysCtlMsgLevel;
+}
+
+
+static void bcmring_ethtool_set_msglevel(struct net_device *dev, u32 level)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	/* Share the sysctl message level */
+	sysCtlMsgLevel = level;
+}
+
+
+static int bcmring_ethtool_nway_reset(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	int reg;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	reg = ethMiiGet(ethp->phyPort, MII_BMCR);
+	ethMiiSet(ethp->phyPort, MII_BMCR, reg | BMCR_ANRESTART);
+
+	return 0;
+}
+
+
+static void bcmring_ethtool_get_ringparam(struct net_device *dev,
+					  struct ethtool_ringparam *ering)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	ering->rx_max_pending = privp->dma.rx.ringSize;
+	ering->rx_mini_max_pending = 0;
+	ering->rx_jumbo_max_pending = 0;
+	ering->tx_max_pending = privp->dma.tx.ringSize;
+	/* TODO:  No easy way to determine rx_pending without traversing the
+	*         descriptor ring
+	*/
+	ering->rx_pending = 0;
+	ering->rx_mini_pending = 0;
+	ering->rx_jumbo_pending = 0;
+	ering->tx_pending = kfifo_len(privp->dma.txFifop) / sizeof(struct sk_buff *);
+}
+
+
+static int bcmring_ethtool_set_ringparam(struct net_device *dev,
+					 struct ethtool_ringparam *ering)
+{
+	(void)dev;
+	(void)ering;
+
+	/* TODO:  Not required, but may add later for debugging purposes */
+
+	return -EOPNOTSUPP;
+}
+
+
+static void bcmring_ethtool_get_pauseparam(struct net_device *dev,
+					   struct ethtool_pauseparam *epause)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	int reg;
+	int pause;
+	int asm_dir;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	reg = ethMiiGet(ethp->phyPort, MII_ADVERTISE);
+
+	pause = reg & ADVERTISE_PAUSE_CAP;
+	asm_dir = reg & ADVERTISE_PAUSE_ASYM;
+
+	if (pause && !asm_dir) {
+		/* Symmetric pause */
+		epause->rx_pause = 1;
+		epause->tx_pause = 1;
+	} else if (asm_dir) {
+		/* Asymmetric pause */
+
+		/* Per 802.3 37.2.4.2, when ASM_DIR = 1:
+		*	  PAUSE = 1 advertises receiver but no transmitter
+		*	  PAUSE = 0 advertises transmitter but no receiver
+		*/
+		if (reg & ADVERTISE_PAUSE_CAP) {
+			epause->rx_pause = 1;
+			epause->tx_pause = 0;
+		} else {
+			epause->rx_pause = 0;
+			epause->tx_pause = 1;
+		}
+	} else {
+		/* No pause */
+		epause->rx_pause = 0;
+		epause->tx_pause = 0;
+	}
+
+	reg = ethMiiGet(ethp->phyPort, MII_BMCR);
+	epause->autoneg = ((reg & BMCR_ANENABLE) ? 1 : 0);
+}
+
+
+static int bcmring_ethtool_set_pauseparam(struct net_device *dev,
+					  struct ethtool_pauseparam *epause)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	int reg;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	reg = ethMiiGet(ethp->phyPort, MII_ADVERTISE);
+
+	/* Start with no pause support */
+	reg &= ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+	if (epause->rx_pause && epause->tx_pause) {
+		/* Symmetric pause */
+		reg |= ADVERTISE_PAUSE_CAP;
+	} else if (epause->rx_pause ^ epause->tx_pause) {
+		/* Asymmetric pause */
+		reg |= ADVERTISE_PAUSE_ASYM;
+
+		/* Per 802.3 37.2.4.2, when ASM_DIR = 1:
+		*	  PAUSE = 1 advertises receiver but no transmitter
+		*	  PAUSE = 0 advertises transmitter but no receiver
+		*/
+		if (epause->rx_pause)
+			reg |= ADVERTISE_PAUSE_CAP;
+	}
+
+	ethMiiSet(ethp->phyPort, MII_ADVERTISE, reg);
+
+	reg = ethMiiGet(ethp->phyPort, MII_BMCR);
+
+	if (epause->autoneg)
+		reg |= BMCR_ANENABLE;
+	else
+		reg &= ~BMCR_ANENABLE;
+
+	ethMiiSet(ethp->phyPort, MII_BMCR, reg);
+
+	/* NOTE: User is responsible for restarting autonegotiation with
+	*        "ethtool -r"
+	*/
+
+	return 0;
+}
+
+
+static int bcmring_ethtool_get_test_count(struct net_device *dev)
+{
+	(void)dev;
+
+	return sizeof(ethtoolStrTest) / sizeof(ethtoolStrTest[0]);
+}
+
+
+static void bcmring_ethtool_self_test(struct net_device *dev,
+				      struct ethtool_test *etest,
+				      u64 *data)
+{
+	register int i;
+
+	etest->len = bcmring_ethtool_get_test_count(dev);
+
+	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+		/* TODO: Run test while interface is offline */
+	}
+
+	for (i = 0; i < etest->len; i++) {
+#if 0
+		/* TODO: Go through list of self tests */
+		/* if (!(*data++ = TODO_add_test_function_array())) */
+#else
+		{
+			/* Temporary return codes for testing purposes */
+			*data++ = 100 + i;
+		}
+#endif
+		{
+			etest->flags |= ETH_TEST_FL_FAILED;
+		}
+	}
+
+	if (etest->flags & ETH_TEST_FL_OFFLINE) {
+		/* TODO: Restore original state before taking interface offline */
+	}
+}
+
+
+static void bcmring_ethtool_get_strings(struct net_device *dev,
+					u32 strSet, u8 *buf)
+{
+	switch (strSet) {
+	case ETH_SS_STATS:
+		memcpy(buf, ethtoolStrStat, sizeof(ethtoolStrStat));
+		break;
+
+	case ETH_SS_TEST:
+		memcpy(buf, ethtoolStrTest, sizeof(ethtoolStrTest));
+		break;
+
+	default:
+		myPrintk(KERN_WARNING "Unsupported string set %d\n", strSet);
+		break;
+	}
+}
+
+
+static int bcmring_ethtool_phys_id(struct net_device *dev, u32 seconds)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	volatile uint16_t ledModeMap0;
+	volatile uint16_t ledModeMap1;
+
+	/* Set maximum duration */
+	if (seconds > PHYS_ID_DURATION_MAX)
+		seconds = PHYS_ID_DURATION_MAX;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	/* Backup original LED configuration */
+	ledModeMap0 = REG_LED_MODE_MAP_0;
+	ledModeMap1 = REG_LED_MODE_MAP_1;
+
+	/* Blink only the LAN port */
+	REG_LED_MODE_MAP_0 = 0;
+	REG_LED_MODE_MAP_1 = 1 << ethp->phyPort;
+
+	msleep_interruptible(seconds * 1000);
+
+	/* Restore original LED configuration */
+	REG_LED_MODE_MAP_0 = ledModeMap0;
+	REG_LED_MODE_MAP_1 = ledModeMap1;
+
+	return 0;
+}
+
+
+static int bcmring_ethtool_get_stats_count(struct net_device *dev)
+{
+	return sizeof(ethtoolStrStat) / sizeof(ethtoolStrStat[0]);
+}
+
+
+static void bcmring_ethtool_get_ethtool_stats(struct net_device *dev,
+					      struct ethtool_stats *estats,
+					      u64 *stats)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	if (strncmp(dev->name, "phy", 3) == 0) {
+		/* /phy device, so report external port MIB */
+
+#define GET_MIB(m)      (*stats++ = ethHw_mib ## m (ethp->phyPort))
+
+		GET_MIB(RxOctets);               /* RxOctets */
+		GET_MIB(RxDropPkts);             /* RxDropPkts */
+		GET_MIB(TxQ0Pkt);                /* TxQ0Pkt */
+		GET_MIB(RxBroadcastPkts);        /* RxBroadcastPkts */
+		GET_MIB(RxMulticastPkts);        /* RxMulticastPkts */
+		GET_MIB(RxUnicastPkts);          /* RxUnicastPkts */
+		GET_MIB(RxPausePkts);            /* RxPausePkts */
+		GET_MIB(TxQ1Pkt);                /* TxQ1Pkt */
+		GET_MIB(TxQ2Pkt);                /* TxQ2Pkt */
+		GET_MIB(TxQ3Pkt);                /* TxQ3Pkt */
+		GET_MIB(TxQ4Pkt);                /* TxQ4Pkt */
+		GET_MIB(TxQ5Pkt);                /* TxQ5Pkt */
+		GET_MIB(TxOctets);               /* TxOctets */
+		GET_MIB(RxUndersizePkts);        /* RxUndersizePkts */
+		GET_MIB(TxPausePkts);            /* TxPausePkts */
+		GET_MIB(Pkts64Octets);           /* RxPkts64Octets */
+		GET_MIB(Pkts65To127Octets);      /* RxPkts65To127Octets */
+		GET_MIB(Pkts128To255Octets);     /* RxPkts128To255Octets */
+		GET_MIB(Pkts256To511Octets);     /* RxPkts256To511Octets */
+		GET_MIB(Pkts512To1023Octets);    /* RxPkts512To1023Octets */
+		GET_MIB(Pkts1024ToMaxPktOctets); /* RxPkts1024ToMaxPktOctets */
+		GET_MIB(TxOctets);               /* TxGoodOctets */
+		GET_MIB(TxDropPkts);             /* TxDropPkts */
+		GET_MIB(TxUnicastPkts);          /* TxUnicastPkts */
+		GET_MIB(TxMulticastPkts);        /* TxMulticastPkts */
+		GET_MIB(TxBroadcastPkts);        /* TxBroadcastPkts */
+		GET_MIB(RxSaChanges);            /* RxSaChanges */
+		GET_MIB(JumboPktCount);          /* RxJumboPktCount */
+		GET_MIB(InRangeErrorCount);      /* RxInRangeErrorCount */
+		GET_MIB(OutRangeErrorCount);     /* RxOutRangeErrorCount */
+		GET_MIB(RxDiscard);              /* RxDiscard */
+	} else {
+	/* The order of the following function calls must match the order of
+	 *  ethtoolStrStat[].  Note that Rx/Tx from the NIC perspective is actually
+	 *  Tx/Rx from the internal port and Rx/Tx from the LAN port.
+	 */
+
+#define GET_MIB_IMP(m)     (*stats++ = ethHw_mib ## m (ETHHW_PORT_INT))
+#define GET_MIB_LAN(m)     (*stats++ = ethHw_mib ## m (ethp->phyPort))
+
+		GET_MIB_IMP(TxOctets);                  /* RxOctets */
+		GET_MIB_IMP(TxDropPkts);                /* RxDropPkts */
+		GET_MIB_IMP(TxQ0Pkt);                   /* RxQ0Pkt */
+		GET_MIB_IMP(TxBroadcastPkts);           /* RxBroadcastPkts */
+		GET_MIB_IMP(TxMulticastPkts);           /* RxMulticastPkts */
+		GET_MIB_IMP(TxUnicastPkts);             /* RxUnicastPkts */
+		GET_MIB_LAN(RxPausePkts);               /* RxPausePkts */
+		GET_MIB_IMP(TxQ1Pkt);                   /* RxQ1Pkt */
+		GET_MIB_IMP(TxQ2Pkt);                   /* RxQ2Pkt */
+		GET_MIB_IMP(TxQ3Pkt);                   /* RxQ3Pkt */
+		GET_MIB_IMP(TxQ4Pkt);                   /* RxQ4Pkt */
+		GET_MIB_IMP(TxQ5Pkt);                   /* RxQ5Pkt */
+		GET_MIB_IMP(RxOctets);                  /* TxOctets */
+		GET_MIB_IMP(RxUndersizePkts);           /* TxUndersizePkts */
+		GET_MIB_LAN(TxPausePkts);               /* TxPausePkts */
+		GET_MIB_IMP(Pkts64Octets);              /* TxPkts64Octets */
+		GET_MIB_IMP(Pkts65To127Octets);         /* TxPkts65To127Octets */
+		GET_MIB_IMP(Pkts128To255Octets);        /* TxPkts128To255Octets */
+		GET_MIB_IMP(Pkts256To511Octets);        /* TxPkts256To511Octets */
+		GET_MIB_IMP(Pkts512To1023Octets);       /* TxPkts512To1023Octets */
+		GET_MIB_IMP(Pkts1024ToMaxPktOctets);    /* TxPkts1024ToMaxPktOctets */
+		GET_MIB_IMP(RxGoodOctets);              /* TxGoodOctets */
+		GET_MIB_IMP(RxDropPkts);                /* TxDropPkts */
+		GET_MIB_IMP(RxUnicastPkts);             /* TxUnicastPkts */
+		GET_MIB_IMP(RxMulticastPkts);           /* TxMulticastPkts */
+		GET_MIB_IMP(RxBroadcastPkts);           /* TxBroadcastPkts */
+		GET_MIB_IMP(RxSaChanges);               /* TxSaChanges */
+		GET_MIB_IMP(JumboPktCount);             /* TxJumboPktCount */
+		GET_MIB_IMP(InRangeErrorCount);         /* TxInRangeErrorCount */
+		GET_MIB_IMP(OutRangeErrorCount);        /* TxOutRangeErrorCount */
+		GET_MIB_IMP(RxDiscard);                 /* TxDiscard */
+	}
+}
diff --git a/drivers/net/bcmring_net.c b/drivers/net/bcmring_net.c
new file mode 100644
index 0000000..ec50555
--- /dev/null
+++ b/drivers/net/bcmring_net.c
@@ -0,0 +1,1990 @@
+/*****************************************************************************
+* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/mii.h>
+#include <linux/workqueue.h>
+#include <linux/dma-mapping.h>
+#include <linux/proc_fs.h>
+#include <linux/kfifo.h>
+#include <linux/sysctl.h>
+#include <linux/reboot.h>
+
+#define ENABLE_NET_KNLLOG 0
+#if ENABLE_NET_KNLLOG
+#include <linux/broadcom/knllog.h>
+#define NET_KNLLOG(fmt, args...) KNLLOG(fmt, ## args)
+#else
+#define NET_KNLLOG(fmt, args...)
+#endif
+
+#include <mach/csp/ethHw_dma.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <mach/csp/cap.h>
+
+#include <mach/irqs.h>
+#include <mach/dma.h>
+#include <mach/pm.h>
+
+#include <asm/dma.h>
+
+#include <csp/intcHw.h>
+#include <csp/ethHw.h>
+#include <csp/intcHw.h>
+
+/*--------------------------------------------------------------------------*/
+
+/* Driver configuration (compile-time) */
+
+/* Number of Rx descriptors */
+#define DMA_RX_DESC_NUM_DEFAULT  64
+
+/* 802.3as defines the max packet size to be 2000bytes and is rounded here to
+*  a nice boundary
+*/
+#define DMA_RX_BUF_LEN           2048
+
+/* At least 2*350 Tx descriptors are required (determined empirically) to
+*  sustain ping attack.  Normally, DoS will be enabled, but this will handle
+*  the worst possible case.
+*/
+#define DMA_TX_DESC_NUM_DEFAULT  (16 * DMA_RX_DESC_NUM_DEFAULT)
+
+#define MARKER                   "------->"
+
+/* This will be overridden if ethtool is not supported */
+#define PHY_DEVICE_SUPPORT       1
+
+/* All outgoing frames will be marked with the following traffic class */
+#define TRAFFIC_CLASS            ETHHW_TC_HIGHEST
+
+#define BCM_NET_MODULE_DESCRIPTION     "Broadcom BCMRING network driver"
+#define BCM_NET_MODULE_VERSION         "0.2.0"
+
+/*--------------------------------------------------------------------------*/
+
+static const __devinitconst char banner[] =
+   KERN_INFO BCM_NET_MODULE_DESCRIPTION " " BCM_NET_MODULE_VERSION "\n";
+
+#ifndef CONFIG_NET_BCMRING_ETHTOOL
+#undef PHY_DEVICE_SUPPORT
+#define PHY_DEVICE_SUPPORT       0
+#endif
+
+#if 0
+#define TXCFG_SIZE               ((sizeof(uint64_t) + sizeof(struct sk_buff *))
+#else
+/* Force onto 64-bit boundary */
+#define TXCFG_SIZE               16
+#endif
+#define TXCFG_BUF(bp, i)         (uint64_t *)((char *)(bp) + (TXCFG_SIZE * (i)))
+#define TXCFG_BUF_SIZE           (TXCFG_SIZE * DMA_TX_DESC_NUM)
+
+#define RX_DESC(bp, i)           (ETHHW_DMA_DESC *)((char *)(bp) + ((i) * sizeof(ETHHW_DMA_DESC)))
+#define TX_DESC                  RX_DESC
+
+static struct workqueue_struct *ethStatusWorkQueuep;
+
+static void ethStatusWork(struct work_struct *work);
+DECLARE_DELAYED_WORK(ethStatusTask, ethStatusWork);
+/* TODO: Needed for ethStatusWork, but should supply argument at run-time */
+static struct net_device *localDevp;
+
+#ifndef MARKER
+#define MARKER
+#endif
+
+#define myPrintk(f, s...)        printk(MARKER "%s(): " f, __func__, ## s)
+#define myPanic(f, s...)         panic(MARKER "%s(): " f, __func__, ## s)
+
+/* TODO: Replace DMA_ESW_xxx with appropriate value from header file */
+#define DMA_ESW_MODULE           1
+#define DMA_ESW_CH_RX            2           /* PTM direction */
+#define DMA_ESW_CH_TX            3           /* MTP direction */
+
+#define DMA_BURST_SIZE           8
+#define DMA_BLOCK_SIZE           256
+
+#define IRQ_DMA_ESW_RX           IRQ_DMA1C0  /* PTM */
+#define IRQ_DMA_ESW_TX           IRQ_DMA1C1  /* MTP */
+
+#define PORT_PC                  ETHHW_PORT_0
+#define PORT_LAN                 ETHHW_PORT_1
+
+#define PHY_DEV_NUM              ETHHW_PORT_NUM
+
+#define isDaMcast(bp)            ((bp)[0] == 0x01)
+
+#define TX_TIMEOUT               (5 * HZ)
+#define MIN_FRAME_LEN            60
+#define PAD_BUF_SIZE             (MIN_FRAME_LEN + sizeof(struct sk_buff *))
+
+#define BRCM_ENCAP_MODE_REMOVE         0  /* Remove Broadcom field */
+#define BRCM_ENCAP_MODE_KEEP_SKIP      1  /* Keep Broadcom field, but bypass in Rx driver */
+#define BRCM_ENCAP_MODE_KEEP_HANDLER   2  /* Keep Broadcom field, but bypass in packet handler */
+
+static unsigned int brcmMode = BRCM_ENCAP_MODE_REMOVE;
+module_param(brcmMode, uint, 0644);
+MODULE_PARM_DESC(brcmMode, "Rx Broadcom type encapsulation mode");
+#define BRCM_ENCAP_MODE    brcmMode
+
+static unsigned int descRx = DMA_RX_DESC_NUM_DEFAULT;
+module_param(descRx, uint, 0644);
+MODULE_PARM_DESC(descRx, "Number of Rx descriptors");
+#define DMA_RX_DESC_NUM    descRx
+
+static unsigned int descTx = DMA_TX_DESC_NUM_DEFAULT;
+module_param(descTx, uint, 0644);
+MODULE_PARM_DESC(descTx, "Number of Tx descriptors");
+#define DMA_TX_DESC_NUM    descTx
+
+static int sysCtlStatusPoll;
+static uint32_t sysCtlMsgLevel;
+static unsigned int sysCtlTxFifoMax;
+static unsigned int sysCtlRxFifoMax;
+static unsigned int sysCtlRxDiscard;
+static unsigned int sysCtlPmDisablePortPc;
+static unsigned int sysCtlPmDisablePortLan;
+static unsigned int sysCtlPmDisablePortInternal;
+
+#define CTL_TABLE_ENTRY(_ctl_name, _procname, _data, _mode) \
+   .ctl_name = (_ctl_name), \
+   .procname = (_procname), \
+   .data = (void *)&(_data), \
+   .maxlen = sizeof((_data)), \
+   .mode = (_mode), \
+   .proc_handler = &proc_dointvec
+
+static struct ctl_table sysCtlEth[] = {
+	{CTL_TABLE_ENTRY(1, "statusPoll", sysCtlStatusPoll, 0644)},
+	{CTL_TABLE_ENTRY(2, "msgLevel", sysCtlMsgLevel, 0644)},
+	{CTL_TABLE_ENTRY(3, "txFifoMax", sysCtlTxFifoMax, 0644)},
+	{CTL_TABLE_ENTRY(4, "rxFifoMax", sysCtlRxFifoMax, 0644)},
+	{CTL_TABLE_ENTRY(5, "pmDisablePortPc", sysCtlPmDisablePortPc, 0644)},
+	{CTL_TABLE_ENTRY(6, "pmDisablePortLan", sysCtlPmDisablePortLan, 0644)},
+	{CTL_TABLE_ENTRY(7, "pmDisablePortInternal", sysCtlPmDisablePortInternal, 0644)},
+	{CTL_TABLE_ENTRY(8, "rxDiscard", sysCtlRxDiscard, 0644)},
+	{}
+};
+
+#define CTL_BCM_ETH 205	/* originate from bcm_sysctl.h which is not integrated */
+static struct ctl_table sysCtl[] = {
+	{
+	   .ctl_name = CTL_BCM_ETH,
+	   .procname = "eth",
+	   .mode = 0555,
+	   .child = sysCtlEth
+	},
+	{}
+};
+
+static struct ctl_table_header *sysCtlHeaderp;
+
+/* The message level is actually a mask for this driver */
+#define MSG_LEVEL_OFF            0x000000000
+#define MSG_LEVEL_RX             0x000000001
+#define MSG_LEVEL_RX_RAW         0x000000002
+#define MSG_LEVEL_RX_VERBOSE     0x000000004
+#define MSG_LEVEL_TX             0x000000100
+#define MSG_LEVEL_TX_RAW         0x000000200
+#define MSG_LEVEL_TX_VERBOSE     0x000000400
+#define MSG_LEVEL_STATUS_VERBOSE 0x000001000
+
+#define MSG_LEVEL_RX_RAW_VERBOSE MSG_LEVEL_RX_VERBOSE
+#define MSG_LEVEL_TX_RAW_VERBOSE MSG_LEVEL_TX_VERBOSE
+
+#define STR_OCTETS_FORMAT        "%02x %02x %02x %02x %02x %02x %02x %02x"
+#define STR_OCTETS_ARGS(bp)      (bp)[0], (bp)[1], (bp)[2], (bp)[3], (bp)[4], (bp)[5], (bp)[6], (bp)[7]
+#define FRAME_DUMP(msgLevel, strp, bufp, len) \
+if (sysCtlMsgLevel & (msgLevel)) { \
+	printk("%s: len=%i, bufp=0x%08x\n", (strp), (len), (int)(bufp)); \
+	if (sysCtlMsgLevel & msgLevel ## _VERBOSE) { \
+		printk(STR_OCTETS_FORMAT " " STR_OCTETS_FORMAT " " \
+		       STR_OCTETS_FORMAT " ... " STR_OCTETS_FORMAT "\n", \
+		       STR_OCTETS_ARGS(&bufp[0]), STR_OCTETS_ARGS(&bufp[8]), \
+		       STR_OCTETS_ARGS(&bufp[16]), STR_OCTETS_ARGS(&bufp[len - 8])); \
+	} \
+}
+
+#define FRAME_DUMP_ALWAYS(strp, bufp, len) \
+do { \
+	printk("%s: len=%i, bufp=0x%08x\n", (strp), (len), (int)(bufp)); \
+	printk(STR_OCTETS_FORMAT " " STR_OCTETS_FORMAT " " \
+	       STR_OCTETS_FORMAT " ... " STR_OCTETS_FORMAT "\n", \
+	       STR_OCTETS_ARGS(&bufp[0]), STR_OCTETS_ARGS(&bufp[8]), \
+	       STR_OCTETS_ARGS(&bufp[16]), STR_OCTETS_ARGS(&bufp[len - 8])); \
+} while (0)
+
+#define msg_printk(msgLevel, s, ...) \
+	if (sysCtlMsgLevel & (msgLevel)) \
+		printk(s, ##__VA_ARGS__)
+
+#define SKB_BUF_HDR(bp)          (*(struct sk_buff **)((void *)(bp) - sizeof(struct sk_buff *)))
+
+typedef struct {
+	struct net_device *dev;
+} IRQ_CONTEXT;
+
+typedef struct {
+	int descLen;
+	void *descBufp;      /* Virtual address */
+	dma_addr_t handle;   /* Physical address */
+	int index;
+	int tail;
+	int count;
+	unsigned int countAlloc;
+	unsigned int countFree;
+	int ringSize;
+	IRQ_CONTEXT irqContext;
+} DMA_DRV_PRIV;
+
+typedef u64 mib_t;
+
+typedef struct {
+	/* NOTE: Do not change the case or the name of these structure members.
+	*        The structure member name was chosen to simplify the coding later
+	*        by creating macros.
+	*/
+	mib_t TxOctets;
+	mib_t TxDropPkts;
+	mib_t TxBroadcastPkts;
+	mib_t TxMulticastPkts;
+	mib_t TxUnicastPkts;
+	mib_t TxCollisions;
+	mib_t TxSingleCollision;
+	mib_t TxMultipleCollision;
+	mib_t TxDeferredTransmit;
+	mib_t TxLateCollision;
+	mib_t TxExcessiveCollision;
+	mib_t TxFrameInDisc;
+	mib_t TxPausePkts;
+	mib_t RxOctets;
+	mib_t RxUndersizePkts;
+	mib_t RxPausePkts;
+	mib_t Pkts64octets;
+	mib_t Pkts65to127octets;
+	mib_t Pkts128to255octets;
+	mib_t Pkts256to511octets;
+	mib_t Pkts512to1023octets;
+	mib_t Pkts1024to1522octets;
+	mib_t RxOversizePkts;
+	mib_t RxJabbers;
+	mib_t RxAlignmentErrors;
+	mib_t RxFcsErrors;
+	mib_t RxGoodOctets;
+	mib_t RxDropPkts;
+	mib_t RxUnicastPkts;
+	mib_t RxMulticastPkts;
+	mib_t RxBroadcastPkts;
+	mib_t RxSaChanges;
+	mib_t RxFragments;
+	mib_t RxExcessSizeDisc;
+	mib_t RxSymbolError;
+} ETH_DRV_MIB;
+
+typedef struct {
+	char *padBufp;
+	dma_addr_t padHandle;
+	int phyPort;
+	struct {
+		int lan;
+		int pc;
+	} port;
+	ETH_DRV_MIB mib;
+} ETH_PRIV;
+
+typedef struct {
+	DMA_DRV_PRIV rx;
+	DMA_DRV_PRIV tx;
+	struct kfifo *txFifop;
+	struct {
+		char *bufp;
+		int index;
+	} txCfg;
+} DMA_PRIV;
+
+typedef struct {
+	int portNum;                        /* Number of external ports available */
+	int portNumExt;                     /* Number of external ports for external PHY */
+	int phyAvailable[ETHHW_PORT_NUM];   /* Per-port PHY available */
+	int gmiiAvailable[ETHHW_PORT_NUM];  /* Per-port GMII/1000Mbps available */
+	int sgmiiAvailable[ETHHW_PORT_NUM]; /* Per-port SGMII available */
+} CHIP_PRIV;
+
+#define CHIP_PORTS(privp)	((privp)->chip.portNum)
+
+typedef struct {
+	struct net_device_stats stat;
+	struct mii_if_info mii_if;
+	ETH_PRIV eth;
+	DMA_PRIV dma;
+	CHIP_PRIV chip;
+#ifdef CONFIG_PM
+	int wasRunning;
+#endif
+	struct napi_struct napi;
+#if PHY_DEVICE_SUPPORT
+	struct net_device *phyDev[PHY_DEV_NUM];
+#endif
+} BCMRING_PRIV;
+
+static BCMRING_PRIV *procPrivp;
+
+static void *allocFuncp(int len);
+static void freeFunc(void *bufp);
+static int dmaStart(DMA_PRIV *dmap);
+static int dmaStop(DMA_PRIV *dmap);
+static int ethStart(ETH_PRIV *ethp);
+static int txClean(DMA_PRIV *dmap);
+static void tx(BCMRING_PRIV *privp);
+static void txWork(unsigned long data);
+DECLARE_TASKLET(txTasklet, txWork, 0);
+static BCMRING_PRIV *txPrivp;
+static struct workqueue_struct *txWorkQueuep;
+
+static int miiGet(struct net_device *dev, int phy_id, int location);
+static void miiSet(struct net_device *dev, int phy_id, int location, int val);
+
+static void ethIsrRx(DMA_Device_t dev, int reason, void *userData);
+static void ethIsrTx(DMA_Device_t dev, int reason, void *userData);
+
+static int brcmPacketTypeHandler(struct sk_buff *skb, struct net_device *dev,
+				 struct packet_type *ptype,
+				 struct net_device *orig_dev);
+
+static int bcmring_net_open(struct net_device *dev);
+static int bcmring_net_close(struct net_device *dev);
+static int bcmring_net_do_ioctl(struct net_device *dev, struct ifreq *ifr,
+				int cmd);
+static int bcmring_net_hard_start_xmit(struct sk_buff *skb,
+				struct net_device *dev);
+static int bcmring_net_poll(struct napi_struct *napi, int quota);
+static void bcmring_net_set_multicast_list(struct net_device *dev);
+static int bcmring_net_set_mac_address(struct net_device *dev, void *addr);
+static struct net_device_stats *bcmring_net_get_stats(struct net_device *dev);
+static void bcmring_net_tx_timeout(struct net_device *dev);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void bcmring_net_poll_controller(struct net_device *dev);
+#endif
+static int bcmring_net_init(void);
+static void bcmring_net_exit(void);
+#ifdef CONFIG_PM
+static int bcmring_net_notify_reboot(struct notifier_block *nb,
+		unsigned long event, void *ptr);
+static int bcmring_net_suspend(struct platform_device *pdev,
+		pm_message_t state);
+static int bcmring_net_resume(struct platform_device *pdev);
+static struct notifier_block bcmring_net_notifier_reboot = {
+	.notifier_call = bcmring_net_notify_reboot,
+	.next          = NULL,
+	.priority      = 0
+
+};
+#else
+#define bcmring_net_suspend      NULL
+#define bcmring_net_resume       NULL
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops bcmring_netdev_ops = {
+	.ndo_open               = bcmring_net_open,
+	.ndo_stop               = bcmring_net_close,
+	.ndo_get_stats          = bcmring_net_get_stats,
+	.ndo_start_xmit         = bcmring_net_hard_start_xmit,
+	.ndo_set_multicast_list = bcmring_net_set_multicast_list,
+	.ndo_set_mac_address    = bcmring_net_set_mac_address,
+	.ndo_tx_timeout         = bcmring_net_tx_timeout,
+	.ndo_do_ioctl           = bcmring_net_do_ioctl,
+};
+
+#if PHY_DEVICE_SUPPORT
+static const struct net_device_ops phy_netdev_ops;
+#endif
+#endif
+
+static struct packet_type brcmPacketType = {
+	.type = cpu_to_be16(ETHHW_BRCM_TYPE),
+	.func = brcmPacketTypeHandler,
+};
+
+static inline int ethMiiGet(int port, int addr)
+{
+	uint32_t val;
+
+	ethHw_miiGet(port, 0, (uint32_t)addr, &val);
+
+	return val;
+}
+
+static inline void ethMiiSet(int port, int addr, int data)
+{
+	ethHw_miiSet(port, 0, (uint32_t)addr, (uint32_t)data);
+}
+
+#ifdef CONFIG_NET_BCMRING_ETHTOOL
+#include "bcmring_ethtool.c"
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+static void *allocFuncp(int len)
+{
+	struct sk_buff *skb;
+	char *bufp;
+	int offset;
+
+	/* Allocate socket buffer */
+	skb = dev_alloc_skb(len);
+	if (likely(skb)) {
+		/* Reserve space for a buffer header used to identify the sk_buff when
+		*  freeing the socket buffer.  At the same time, ensure skb->data is on
+		*  64bit alignment for DMA purposes.
+		*/
+		bufp = (char *)(((int)skb->data + sizeof(struct sk_buff *) + 7) & 0xfffffff8);
+		offset = (int)bufp - (int)skb->data;
+
+		skb_reserve(skb, offset);
+		SKB_BUF_HDR(skb->data) = skb;
+	} else {
+		return NULL;
+	}
+
+	return (void *)skb->data;
+}
+
+static void freeFunc(void *bufp)
+{
+	struct sk_buff *skb;
+
+	skb = SKB_BUF_HDR(bufp);
+	if (skb) {
+		/* Unmap data buffer */
+		dma_unmap_single(NULL, (dma_addr_t) bufp, skb->len, DMA_FROM_DEVICE);
+
+		/* Free socket buffer */
+		dev_kfree_skb_any(skb);
+	} else {
+		/* Buffer is a zero padding buffer used to enforce the minimum ethernet
+		*  frame size requirements.  This buffer can be used many times so it
+		*  does need to be freed here.  It will be freed when the driver is
+		*  closed in bcmring_net_close()
+		*/
+	}
+}
+
+static int dmaStart(DMA_PRIV *dmap)
+{
+	ethHw_dmaInit(DMA_ESW_MODULE);
+
+	/* Start Rx DMA */
+
+	ethHw_dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+
+	/* Configure Rx DMA */
+	ethHw_dmaRxConfig(DMA_BURST_SIZE, DMA_BLOCK_SIZE);
+	ethHw_dmaConfig(DMA_ESW_MODULE, DMA_ESW_CH_RX,
+			ETHHW_DMA_PTM_CTL_HI, ETHHW_DMA_PTM_CTL_LO,
+			ETHHW_DMA_PTM_CFG_HI, ETHHW_DMA_PTM_CFG_LO, ETHHW_DMA_PTM_SSTAT, 0);
+
+	dmap->rx.count = 0;  /* Use count to keep track of Rx updates */
+	dmap->rx.index = 0;
+	dmap->rx.tail = 0;
+	dmap->rx.descLen = DMA_RX_DESC_NUM * sizeof(ETHHW_DMA_DESC);
+	dmap->rx.descBufp = (void *)dma_alloc_coherent(NULL, dmap->rx.descLen,
+			&dmap->rx.handle,
+			GFP_KERNEL);
+	if (!dmap->rx.descBufp) {
+		myPrintk(KERN_ERR "Failed to alloc Rx DMA descriptor memory\n");
+
+		return -ENOMEM;
+	}
+
+	/* Configure Rx descriptors */
+	{
+		int i;
+		uint8_t *bufp;
+		ETHHW_DMA_DESC *descp;
+		ETHHW_DMA_DESC *handlep;
+		dma_addr_t dmaBuf;
+
+		/* Remove compiler warning when DMA_RX_DESC_NUM = 0 */
+		descp = NULL;
+
+		for (i = 0; i < DMA_RX_DESC_NUM; i++) {
+			descp = RX_DESC(dmap->rx.descBufp, i);
+			handlep = RX_DESC(dmap->rx.handle, i);
+			bufp = (uint8_t *)allocFuncp(DMA_RX_BUF_LEN);
+			if (!bufp) {
+				myPrintk(KERN_ERR "Failed to allocate Rx DMA buffer\n");
+				dmaStop(dmap);
+				return -ENOMEM;
+			}
+
+			/* Map data buffer to invalidate cache */
+			dmaBuf = dma_map_single(NULL, bufp, DMA_RX_BUF_LEN,
+					DMA_FROM_DEVICE);
+
+			/* Rx config descriptor
+			*  The config descriptor allows transfer to be purely 64-bit
+			*  transactions, spanning an arbitrary number of descriptors,
+			*  so information must be provided to define offsets and EOP
+			*/
+			ETHHW_DMA_DESC_CREATE(descp,
+					ETHHW_DMA_PTM_FIFO_ADDR,
+					dmaBuf,
+					handlep,
+					ETHHW_DMA_PTM_CTL_LO | ETHHW_DMA_CTL_INT_EN,   /* Enable interrupts per Rx descriptor */
+					DMA_RX_BUF_LEN);
+
+			/* Save virtual address of buffer */
+			descp->rsvd = (uint32_t)bufp;
+		}
+
+		/* Wrap last descriptor back to beginning */
+		ETHHW_DMA_DESC_WRAP(descp, (uint32_t)RX_DESC(dmap->rx.handle, 0));
+	}
+
+	dma_set_device_handler(DMA_DEVICE_ESW_DEV_TO_MEM,
+			(DMA_DeviceHandler_t) ethIsrRx,
+			(void *)&dmap->rx.irqContext);
+	ethHw_dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+	ethHw_dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+
+	/* Start Tx DMA */
+
+	/* Allocate buffer for Tx config */
+	dmap->txCfg.index = 0;
+	dmap->txCfg.bufp = (char *)kmalloc(TXCFG_BUF_SIZE, GFP_KERNEL);
+	if (!dmap->txCfg.bufp) {
+		myPrintk(KERN_ERR "Failed to alloc Tx config buffer memory\n");
+		dmaStop(dmap);
+		return -ENOMEM;
+	}
+
+	ethHw_dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+
+	/* Configure Tx DMA */
+	ethHw_dmaTxConfig(DMA_BURST_SIZE);
+	ethHw_dmaConfig(DMA_ESW_MODULE, DMA_ESW_CH_TX,
+			ETHHW_DMA_MTP_CTL_HI, ETHHW_DMA_MTP_CTL_LO,
+			ETHHW_DMA_MTP_CFG_HI, ETHHW_DMA_MTP_CFG_LO, 0, ETHHW_DMA_MTP_DSTAT);
+
+	dmap->tx.count = dmap->tx.ringSize;    /* Use count to keep track of queue level */
+	dmap->tx.countAlloc = 0;
+	dmap->tx.countFree = 0;
+	dmap->tx.index = 0;
+	dmap->tx.tail = 0;
+	dmap->tx.descLen = DMA_TX_DESC_NUM * sizeof(ETHHW_DMA_DESC);
+	dmap->tx.descBufp = (void *)dma_alloc_coherent(NULL, dmap->tx.descLen,
+			&dmap->tx.handle,
+			GFP_KERNEL);
+	if (!dmap->tx.descBufp) {
+		myPrintk(KERN_ERR "Failed to alloc Tx DMA descriptor memory\n");
+		dmaStop(dmap);
+		return -ENOMEM;
+	}
+
+	dma_set_device_handler(DMA_DEVICE_ESW_MEM_TO_DEV,
+			(DMA_DeviceHandler_t) ethIsrTx,
+			(void *)&dmap->tx.irqContext);
+	ethHw_dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+	ethHw_dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+
+	/* Enable Rx DMA (Tx DMA is enabled when a Tx frame is ready to send) */
+	ethHw_dmaEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX, RX_DESC(dmap->rx.handle, 0));
+
+	return 0;
+}
+
+static int dmaStop(DMA_PRIV *dmap)
+{
+	/* Stop Rx DMA */
+
+	/* Disable Rx DMA */
+	ethHw_dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+
+	/* Free pending Rx buffers */
+	{
+		int i;
+		ETHHW_DMA_DESC *descp;
+		char *bufp;
+
+		for (i = 0; i < DMA_RX_DESC_NUM; i++) {
+			descp = RX_DESC(dmap->rx.descBufp, i);
+			bufp = (char *)descp->rsvd;
+			freeFunc(bufp);
+		}
+	}
+
+	/* Free memory used for descriptor ring */
+	dma_free_coherent(NULL, dmap->rx.descLen, dmap->rx.descBufp,
+			  dmap->rx.handle);
+
+	/* Stop Tx DMA */
+
+	/* Disable Tx DMA */
+	ethHw_dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+
+	/* Free pending Tx buffers */
+	txClean(dmap);
+
+	/* Free memory used for descriptor ring */
+	dma_free_coherent(NULL, dmap->tx.descLen, dmap->tx.descBufp,
+			  dmap->tx.handle);
+	kfree(dmap->txCfg.bufp);
+
+	return 0;
+}
+
+static int ethStart(ETH_PRIV *ethp)
+{
+	int rc;
+	int reg;
+
+	rc = ethHw_Init();
+	printk("Ethernet initialization %s (rc=%i)\n",
+			ETHHW_RC_SUCCESS(rc) ? "successful" : "failed", rc);
+
+	/* Disable forwarding to internal port (this must be done before
+	*  forwarding is enabled on the external ports)
+	*/
+	ethHw_macEnableSet(ETHHW_PORT_INT, 0, 0);
+
+	/* STP not used so put external ports in forwarding state */
+	/* TODO:  If STP support is required, this state control will need to be
+	*         moved to the STP application
+	*/
+	ethHw_stpStateSet(ETHHW_PORT_0, ETHHW_STP_STATE_FORWARDING);
+	ethHw_stpStateSet(ETHHW_PORT_1, ETHHW_STP_STATE_FORWARDING);
+
+	/* Assign ports */
+	ethp->port.lan = PORT_LAN;
+	ethp->port.pc = PORT_PC;
+
+	ethp->phyPort = ethp->port.lan;
+
+	/* Set LRE Access Register to enable
+	 * LRE Register Set for LAN port
+	 */
+	reg = ethMiiGet(ethp->port.lan, 14);
+	if (!reg & 0x0001) {
+		reg = ethMiiGet(ethp->port.lan, 14);
+		reg |= 0x0004;
+		ethMiiSet(ethp->port.lan, 14, reg);
+	}
+
+	/*Enable WireSpeed mode for LAN port*/
+	ethMiiSet(ethp->port.lan, 0x18, 0x7007);
+	reg = ethMiiGet(ethp->port.lan, 0x18);
+	reg |= 0x8017;
+	ethMiiSet(ethp->port.lan, 0x18, reg);
+
+	/* Set LRE Access Register to enable
+	 * LRE Register Set for PC port
+	 */
+	reg = ethMiiGet(ethp->port.pc, 14);
+	if (!reg & 0x0001) {
+		reg = ethMiiGet(ethp->port.pc, 14);
+		reg |= 0x0004;
+		ethMiiSet(ethp->port.pc, 14, reg);
+	}
+
+	/*Enable WireSpeed mode for PC port*/
+	ethMiiSet(ethp->port.pc, 0x18, 0x7007);
+	reg = ethMiiGet(ethp->port.pc, 0x18);
+	reg |= 0x8017;
+	ethMiiSet(ethp->port.pc, 0x18, reg);
+
+	/* Disable forwarding to internal port */
+	ethHw_impEnableSet(0);
+
+	/* Clear MIB */
+	memset(&ethp->mib, 0, sizeof(ethp->mib));
+
+	return 0;
+}
+
+static int miiGet(struct net_device *dev, int phy_id, int location)
+{
+	uint32_t val;
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	ethHw_miiGet(phy_id, 0, (uint32_t) location, &val);
+
+	return val;
+}
+
+static void miiSet(struct net_device *dev, int phy_id, int location, int val)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	ethHw_miiSet(phy_id, 0, (uint32_t) location, (uint32_t) val);
+}
+
+static void ethIsrRx(DMA_Device_t dev, int reason, void *userData)
+{
+	IRQ_CONTEXT *contextp;
+	BCMRING_PRIV *privp;
+
+	(void)reason;
+
+	if (unlikely(dev != DMA_DEVICE_ESW_DEV_TO_MEM)) {
+		myPrintk(KERN_ERR "Invalid device.  Received %d, expected %d.\n", dev,
+				DMA_DEVICE_ESW_DEV_TO_MEM);
+	}
+
+	contextp = (IRQ_CONTEXT *)userData;
+
+	/* Disable and acknowledge Rx DMA interrupt */
+	ethHw_dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+	ethHw_dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+
+	/* Rx frame is available, so schedule poll using NAPI */
+	privp = netdev_priv(contextp->dev);
+	napi_schedule(&privp->napi);
+}
+
+static void ethIsrTx(DMA_Device_t dev, int reason, void *userData)
+{
+	IRQ_CONTEXT *contextp;
+	BCMRING_PRIV *privp;
+
+	(void)reason;
+	(void)userData;
+
+	if (unlikely(dev != DMA_DEVICE_ESW_MEM_TO_DEV)) {
+		myPrintk(KERN_ERR "Invalid device.  Received %d, expected %d.\n", dev,
+				DMA_DEVICE_ESW_DEV_TO_MEM);
+	}
+
+	/* Acknowledge Tx DMA interrupt */
+	ethHw_dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+
+	contextp = (IRQ_CONTEXT *)userData;
+	privp = netdev_priv(contextp->dev);
+
+	if (ethHw_dmaIsBusy(DMA_ESW_MODULE, DMA_ESW_CH_TX)) {
+		/* Tx DMA transfer in progress, so just leave frame in Tx FIFO.  Another
+		*  attempt to send the frame will be made when the DMA interrupt signals
+		*  the completion of the current DMA transfer
+		*/
+	} else {
+		tasklet_schedule(&txTasklet);
+	}
+}
+
+static inline __be16 brcmPacketType_eth_type_trans(struct sk_buff *skb)
+{
+	__be16 type;
+
+	/* This function is modelled after eth_type_trans() */
+
+	type = *((__be16 *)skb->data);
+
+	/* Move data pointer to start of payload */
+	skb_pull(skb, sizeof(__be16));
+
+	/* Determine ethernet type.  Please refer to eth_type_trans() for an
+	*  explaination on the logic below
+	*/
+	if (ntohs(type) < 1536) {
+		if (type == 0xFFFF)
+			type = htons(ETH_P_802_3);
+		else
+			type = htons(ETH_P_802_2);
+	}
+
+	return type;
+}
+
+static inline void __brcmPacketTypeHandler(struct sk_buff *skb)
+{
+	/* Adjust skb to start of the true ethernet type field */
+	skb_pull(skb, ETHHW_BRCM_HDR_LEN - sizeof(__be16));
+
+	/* Update ethernet type field in skb */
+	skb->protocol = brcmPacketType_eth_type_trans(skb);
+}
+
+static int brcmPacketTypeHandler(struct sk_buff *skb, struct net_device *dev,
+		struct packet_type *ptype,
+		struct net_device *orig_dev)
+{
+	/* The intent of the Broadcom ethernet type is to allow a raw socket
+	*  application to control the egress port for tx/send() frames and/or
+	*  determine the ingress port for rx/recv() frames while maintaining
+	*  original compatibility
+	*/
+
+	(void)dev;
+	(void)ptype;
+	(void)orig_dev;
+
+	__brcmPacketTypeHandler(skb);
+
+	/* Re-queue packet to IP stack */
+	netif_rx(skb);
+
+	return NET_RX_SUCCESS;
+}
+
+static int bcmring_net_open(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+	char *padBufp;
+	int rc;
+
+	sysCtlStatusPoll = 1000;
+	sysCtlMsgLevel = MSG_LEVEL_OFF;
+	sysCtlTxFifoMax = 0;
+	sysCtlRxFifoMax = 0;
+	sysCtlRxDiscard = 0;
+	sysCtlPmDisablePortPc = 1;
+	sysCtlPmDisablePortLan = 0;
+	sysCtlPmDisablePortInternal = 0;
+	sysCtlHeaderp = register_sysctl_table(sysCtl);
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+	txPrivp = privp;
+
+	/* Create Tx FIFO (enough to hold DMA_TX_DESC_NUM amount of pointers */
+	privp->dma.txFifop = kfifo_alloc(DMA_TX_DESC_NUM * 4, GFP_KERNEL, NULL);
+	if (!privp->dma.txFifop) {
+		myPrintk(KERN_ERR "Failed to create Tx FIFO\n");
+		return -ENOMEM;
+	}
+
+	/* Allocate buffer for zero padding Tx frames to meet minimum frame length
+	*  requirements.
+	*/
+	padBufp = (char *)dma_alloc_coherent(NULL, PAD_BUF_SIZE,
+					     &ethp->padHandle, GFP_KERNEL);
+	if (!padBufp) {
+		myPrintk(KERN_ERR "Failed to alloc Tx pad buffer memory\n");
+		kfifo_free(privp->dma.txFifop);
+		return -ENOMEM;
+	}
+
+	/* Initialize DMA parameters */
+	privp->dma.rx.ringSize = DMA_RX_DESC_NUM;
+	privp->dma.tx.ringSize = DMA_TX_DESC_NUM;
+
+	privp->dma.rx.irqContext.dev = dev;
+	privp->dma.tx.irqContext.dev = dev;
+
+	/* Start DMA block */
+	rc = dmaStart(&privp->dma);
+	if (rc) {
+		myPrintk(KERN_ERR "Failed to start DMA block\n");
+		kfifo_free(privp->dma.txFifop);
+		dma_free_coherent(NULL, PAD_BUF_SIZE, padBufp, ethp->padHandle);
+
+		return rc;
+	}
+
+	/* Treat zero padding Tx buffer like a socket buffer to handle the case
+	*  when the driver tries to free the padding buffer in freeFunc()
+	*/
+	ethp->padBufp = padBufp + sizeof(struct sk_buff *);
+	memset(ethp->padBufp, 0, MIN_FRAME_LEN);
+	SKB_BUF_HDR(ethp->padBufp) = (struct sk_buff *)NULL;
+
+	/* Create new workqueue/thread */
+	txWorkQueuep = create_workqueue("ethTx");
+	ethStatusWorkQueuep = create_workqueue("ethStatus");
+	queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask, 0);
+
+	napi_enable(&privp->napi);
+
+	if (CHIP_PORTS(privp) == 1) {
+		/* Single port configuration */
+
+		/* Power-up the PHY */
+		ethHw_phyPowerdownSet(privp->eth.phyPort, 0);
+	} else {
+		/* Non-single port configuration */
+
+		/* The PHYs cannot be powered-down since the external ports may still be
+		*  bridging network traffic
+		*/
+
+		/* TODO: Define other power saving operations for this configuration,
+		*        for example, if only there is only one port has a link, perhaps
+		*        keep PHYs enabled and disable MAC and switch clock.
+		*/
+	}
+
+	if (BRCM_ENCAP_MODE == BRCM_ENCAP_MODE_KEEP_HANDLER) {
+		/* Add packet handler for Broadcom raw socket packet type */
+		dev_add_pack(&brcmPacketType);
+	}
+
+	netif_start_queue(dev);
+
+	/* Enable forwarding to internal port */
+	ethHw_impEnableSet(1);
+	ethHw_macEnableSet(ETHHW_PORT_INT, 1, 1);
+
+	return 0;
+}
+
+static int bcmring_net_close(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+	ETH_PRIV *ethp;
+
+	netif_stop_queue(dev);
+
+	if (BRCM_ENCAP_MODE == BRCM_ENCAP_MODE_KEEP_HANDLER) {
+		/* Remove packet handler for Broadcom raw socket packet type */
+		dev_remove_pack(&brcmPacketType);
+	}
+
+	privp = netdev_priv(dev);
+	ethp = &privp->eth;
+
+	napi_disable(&privp->napi);
+
+	/* Disable and free interrupts */
+	ethHw_dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+	ethHw_dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+
+	/* Stop DMA and ethernet */
+	dmaStop(&privp->dma);
+
+	/* Disable forwarding to internal port */
+	ethHw_macEnableSet(ETHHW_PORT_INT, 0, 0);
+	ethHw_impEnableSet(0);
+
+	/* Free Tx FIFO */
+	kfifo_free(privp->dma.txFifop);
+
+	/* Unmap and free buffer for zero padding Tx frames */
+	dma_unmap_single(NULL, (dma_addr_t) ethp->padBufp, MIN_FRAME_LEN,
+			DMA_FROM_DEVICE);
+	dma_free_coherent(NULL, PAD_BUF_SIZE,
+			ethp->padBufp - sizeof(struct sk_buff *),
+			ethp->padHandle);
+
+	if (sysCtlHeaderp) {
+		unregister_sysctl_table(sysCtlHeaderp);
+	}
+
+	/* Flush and destroy workqueue/thread */
+	flush_workqueue(txWorkQueuep);
+	destroy_workqueue(txWorkQueuep);
+
+	cancel_delayed_work(&ethStatusTask);
+	flush_workqueue(ethStatusWorkQueuep);
+	destroy_workqueue(ethStatusWorkQueuep);
+
+	if (CHIP_PORTS(privp) == 1) {
+		/* Power-down the PHY */
+		ethHw_phyPowerdownSet(privp->eth.phyPort, 1);
+	} else {
+		/* Non-single port configuration */
+
+		/* The PHYs cannot be powered-down since the external ports may still be
+		*  bridging network traffic
+		*/
+
+		/* TODO: Define other power saving operations for this configuration,
+		*        for example, if only there is only one port has a link, perhaps
+		*        keep PHYs enabled and disable MAC and switch clock.
+		*/
+	}
+
+	return 0;
+}
+
+static int bcmring_net_do_ioctl(struct net_device *dev, struct ifreq *ifr,
+		int cmd)
+{
+	int rc;
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+	rc = 0;
+
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		{
+			struct mii_ioctl_data *datap;
+			datap = if_mii(ifr);
+			datap->phy_id = privp->eth.phyPort;
+		}
+		break;
+
+	case SIOCGMIIREG:
+		{
+			struct mii_ioctl_data *datap;
+			datap = if_mii(ifr);
+			datap->val_out = (__u16)ethMiiGet(datap->phy_id, datap->reg_num);
+		}
+		break;
+
+	case SIOCSMIIREG:
+		{
+			struct mii_ioctl_data *datap;
+			datap = if_mii(ifr);
+			ethMiiSet(datap->phy_id, datap->reg_num, (int)datap->val_in);
+		}
+		break;
+
+	default:
+		{
+			return -EOPNOTSUPP;
+		}
+	}
+
+	return rc;
+}
+
+static int txClean(DMA_PRIV *dmap)
+{
+	ETHHW_DMA_DESC *descp;
+
+	NET_KNLLOG("[start net txClean]");
+
+	/* Update Tx DMA to free socket buffers from previous Tx */
+	while (dmap->tx.countFree != dmap->tx.countAlloc) {
+		/* Tail should contain the start of completed Tx transfers.  For each
+		*  of these completed transfers, free the associated buffers
+		*/
+
+		descp = TX_DESC(dmap->tx.descBufp, dmap->tx.tail);
+		if (ETHHW_DMA_TRANSFER_DONE(descp)) {
+			freeFunc((void *)descp->rsvd);
+			dmap->tx.tail++;
+			dmap->tx.countFree++;
+			dmap->tx.count++;
+		} else {
+			/* Last Tx still in progress */
+			NET_KNLLOG("[stop net txClean]");
+			return 0;
+		}
+	}
+
+	/* Last Tx completed, so start from beginning of Tx descriptor chain */
+	dmap->tx.tail = 0;
+	dmap->tx.index = 0;
+	dmap->txCfg.index = 0;
+
+	NET_KNLLOG("[stop net txClean]");
+	return 1;
+}
+
+static void txWork(unsigned long data)
+{
+	if (txClean(&txPrivp->dma)) {
+		NET_KNLLOG("[start net tx]");
+		tx(txPrivp);
+		NET_KNLLOG("[stop net tx]");
+	} else {
+		/* Defer Tx until last Tx DMA transaction has completed */
+	}
+}
+
+static void ethStatusWork(struct work_struct *work)
+{
+	static int portPrev = -1;
+	static uint32_t impSpeedPrev = -1;
+
+	BCMRING_PRIV *privp;
+	int port;
+	int up;
+	int change;
+	uint32_t impSpeed;
+
+	(void)work;
+
+	/* Check link state of LAN port */
+	privp = netdev_priv(localDevp);
+	port = privp->eth.phyPort;
+
+	impSpeed = ethHw_portSpeed(port);
+
+	if ((impSpeed != impSpeedPrev) || (port != portPrev)) {
+		msg_printk(MSG_LEVEL_STATUS_VERBOSE,
+				"Changing internal port Rx speed to %i\n", impSpeed);
+		ethHw_impSpeedSet(impSpeed, 1000);
+		impSpeedPrev = impSpeed;
+		portPrev = port;
+	}
+
+	change = ethHw_portLinkStatusChange(port);
+
+	if (change || (port != portPrev)) {
+		portPrev = port;
+
+		/* Link status has changed */
+		up = ethHw_portLinkStatus(port);
+
+		if (up || (port != portPrev)) {
+			msg_printk(MSG_LEVEL_STATUS_VERBOSE, "link up\n");
+			netif_carrier_on(localDevp);
+		} else {
+			msg_printk(MSG_LEVEL_STATUS_VERBOSE, "link down\n");
+			netif_carrier_off(localDevp);
+		}
+		portPrev = port;
+	}
+
+	queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask,
+			   msecs_to_jiffies(sysCtlStatusPoll));
+}
+
+static void tx(BCMRING_PRIV *privp)
+{
+	char *bufp;
+	int len;
+	dma_addr_t dmaBuf;
+	uint64_t *cfgBufp;
+	int dmaLen;
+	struct sk_buff *skb;
+	ETHHW_DMA_DESC *descp;
+	ETHHW_DMA_DESC *handlep;
+	size_t fifoLen;
+	int portMask;
+	int offset;
+	int tc;
+
+	descp = NULL;
+
+	/* Build descriptor chain */
+	while ((fifoLen = __kfifo_len(privp->dma.txFifop)) > 0) {
+		/* Keep track of worst-case Tx FIFO usage */
+		len = fifoLen / sizeof(struct sk_buff *);
+		if (len > sysCtlTxFifoMax)
+			sysCtlTxFifoMax = len;
+
+		/* Get data from Tx FIFO */
+		kfifo_get(privp->dma.txFifop, (unsigned char *)&skb,
+				sizeof(struct sk_buff *));
+		bufp = skb->data;
+		len = skb->len;
+
+		/* Adjust length to meet minimum size */
+		if (len < MIN_FRAME_LEN)
+			len = MIN_FRAME_LEN;
+
+		/* Process buffer (frame may require a Broadcom field to be inserted) */
+		if (unlikely(skb_headroom(skb) < ETHHW_BRCM_HDR_LEN)) {
+			/* This case should not happen since we initialized the net device to
+			*  increase dev->hard_header_len to account for the Broadcom field
+			*/
+			dev_kfree_skb_any(skb);
+			myPrintk(KERN_ERR "Tx function requires %i bytes of headroom in "
+				"socket buffer\n", ETHHW_BRCM_HDR_LEN);
+
+			return;
+		}
+
+		FRAME_DUMP(MSG_LEVEL_TX, "Tx", bufp, len);
+
+		/* Allow switch ARL to make forwarding decision */
+		portMask = -1;
+
+		if (isDaMcast(bufp)) {
+			/* Force all multicast frames from the CPU to both external ports.
+			*  Some protocols such as EAPOL and LLDP are terminated at each hop
+			*  so they will be discarded by the switch unless we format the frame
+			*  to bypass the switch ARL forwarding rules
+			*/
+			portMask = ETHHW_PORT_MASK(ETHHW_PORT_1) |
+				   ETHHW_PORT_MASK(ETHHW_PORT_0);
+		}
+
+		/* Format the frame according to ASIC requirements and adjust buffer */
+		if ((bufp[12] == 0x81) && (bufp[13] == 0x00)) {
+			/* Frame is 802.1pQ tagged so match traffic class with PCP */
+			tc = (bufp[14] >> 5) & 0x7;
+		} else {
+			/* Use default traffic class */
+			tc = TRAFFIC_CLASS;
+		}
+		offset = ethHw_txFrameFormat(&bufp, &len, portMask, tc, ETHHW_TE_FOLLOW);
+		skb_push(skb, offset);
+
+		FRAME_DUMP(MSG_LEVEL_TX_RAW, "Tx Raw", bufp, len);
+
+		/* Insert buffer header used to identify the sk_buff when freeing the
+		*  socket buffer
+		*/
+		SKB_BUF_HDR(bufp) = skb;
+
+		/* Get Tx config buffer and configure */
+		cfgBufp = TXCFG_BUF(privp->dma.txCfg.bufp, privp->dma.txCfg.index);
+
+		privp->dma.txCfg.index++;
+
+#if TXCFG_SIZE == 16
+		/* Keep on 64-bit boundary */
+		cfgBufp = (uint64_t *)((uint8_t *)cfgBufp + 8);
+#else
+		cfgBufp = (uint64_t *)((uint8_t *)cfgBufp + sizeof(struct sk_buff *));
+#endif
+		SKB_BUF_HDR(cfgBufp) = (struct sk_buff *)NULL;
+
+		*cfgBufp = ETHHW_DMA_CFG_OFFSET(bufp, len) | ETHHW_DMA_CFG_EOP_MASK;
+
+		/* Map Tx config buffer to update external memory */
+		dmaBuf = dma_map_single(NULL, cfgBufp, sizeof(uint64_t),
+				DMA_TO_DEVICE);
+		dmaLen = ETHHW_DMA_MTP_TRANSACTION_SIZE(dmaBuf, sizeof(uint64_t));
+
+		/* Send config to Tx DMA */
+		descp = TX_DESC(privp->dma.tx.descBufp, privp->dma.tx.index);
+		handlep = TX_DESC(privp->dma.tx.handle, privp->dma.tx.index);
+		privp->dma.tx.index++;
+
+		/* Tx config descriptor
+		*  The config descriptor allows transfer to be purely 64-bit
+		*  transactions, spanning an arbitrary number of descriptors,
+		*  so information must be provided to define offsets and EOP
+		*/
+		ETHHW_DMA_DESC_CREATE(descp,
+				dmaBuf,
+				ETHHW_DMA_MTP_FIFO_ADDR_CFG,
+				handlep,
+				ETHHW_DMA_MTP_CTL_LO,
+				dmaLen);
+
+		/* Save virtual address of buffer */
+		descp->rsvd = (uint32_t) cfgBufp;
+
+		/* Map data buffer to update external memory */
+		dmaBuf = dma_map_single(NULL, bufp, len, DMA_TO_DEVICE);
+
+		/* Make length a multiple of 64-bits and put data buffer on 64-bit boundary */
+		dmaLen = ETHHW_DMA_MTP_TRANSACTION_SIZE(dmaBuf, len);
+		dmaBuf &= 0xfffffff8;
+
+		/* Send data to Tx DMA */
+		descp = TX_DESC(privp->dma.tx.descBufp, privp->dma.tx.index);
+		handlep = TX_DESC(privp->dma.tx.handle, privp->dma.tx.index);
+		privp->dma.tx.index++;
+
+		/* Tx config descriptor
+		*  The config descriptor allows transfer to be purely 64-bit
+		*  transactions, spanning an arbitrary number of descriptors,
+		*  so information must be provided to define offsets and EOP
+		*/
+		ETHHW_DMA_DESC_CREATE(descp,
+				dmaBuf,
+				ETHHW_DMA_MTP_FIFO_ADDR_DATA,
+				handlep,
+				ETHHW_DMA_MTP_CTL_LO,
+				dmaLen);
+
+		/* Save virtual address of buffer */
+		descp->rsvd = (uint32_t) bufp;
+
+		privp->stat.tx_packets++;
+		privp->stat.tx_bytes += (len - ETHHW_BRCM_HDR_LEN);
+
+		privp->dma.tx.countAlloc += 2;
+		privp->dma.tx.count -= 2;
+	}
+
+	/* Start Tx DMA transfer */
+	if (descp) {
+		ETHHW_DMA_DESC_TX_DONE(descp);
+		handlep = TX_DESC(privp->dma.tx.handle, 0);
+		ethHw_dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
+		ethHw_dmaEnable(DMA_ESW_MODULE, DMA_ESW_CH_TX, handlep);
+	}
+}
+
+static int bcmring_net_hard_start_xmit(struct sk_buff *skb,
+				       struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+	int len;
+	privp = netdev_priv(dev);
+
+	len = sizeof(struct sk_buff *);
+	if (__kfifo_put(privp->dma.txFifop, (unsigned char *)&skb, len) != len) {
+		/* Not enough space in Tx DMA to send frame */
+		myPrintk(KERN_INFO "Ethernet DMA Tx FIFO full\n");
+		netif_stop_queue(dev);
+
+		return NETDEV_TX_BUSY;
+	}
+
+	dev->trans_start = jiffies;
+
+	if (ethHw_dmaIsBusy(DMA_ESW_MODULE, DMA_ESW_CH_TX)) {
+		/* Tx DMA transfer in progress, so just leave frame in Tx FIFO.  Another
+		*  attempt to send the frame will be made when the DMA interrupt signals
+		*  the completion of the current DMA transfer
+		*/
+	} else {
+		tasklet_schedule(&txTasklet);
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int bcmring_net_poll(struct napi_struct *napi, int budget)
+{
+	BCMRING_PRIV *privp;
+	struct sk_buff *skb;
+	char *bufp;
+	char *newBufp;
+	int offset;
+	int len;
+	int quota;
+	int rxCount;
+	ETHHW_DMA_DESC *descp;
+	dma_addr_t dmaBuf;
+
+	struct net_device *dev;
+	privp = container_of(napi, BCMRING_PRIV, napi);
+	dev = privp->mii_if.dev;
+	quota = budget;
+	rxCount = 0;
+
+	while (rxCount < quota) {
+		/* Get next frame from Rx DMA */
+		descp = RX_DESC(privp->dma.rx.descBufp, privp->dma.rx.index);
+		if (ETHHW_DMA_TRANSFER_DONE(descp)) {
+			bufp = (char *)descp->rsvd;
+			len = ETHHW_DMA_BUF_LEN(descp);
+
+			/* Update descriptor with new buffer */
+			newBufp = (uint8_t *)allocFuncp(DMA_RX_BUF_LEN);
+			if (!newBufp) {
+				myPrintk(KERN_ERR "Failed to allocate Rx DMA buffer\n");
+				break;
+			}
+
+			/* Map data buffer to invalidate cache */
+			dmaBuf = dma_map_single(NULL, newBufp, DMA_RX_BUF_LEN,
+						DMA_FROM_DEVICE);
+
+			/* Update descriptor */
+			ETHHW_DMA_DESC_RX_UPDATE(descp, dmaBuf, DMA_RX_BUF_LEN);
+
+			/* Save virtual address of buffer */
+			descp->rsvd = (uint32_t) newBufp;
+
+			/* Go to next descriptor */
+			if (++privp->dma.rx.index >= DMA_RX_DESC_NUM)
+				privp->dma.rx.index = 0;
+		} else {
+			/* No frame available */
+
+			/* See if sync-up is required */
+			{
+				ETHHW_DMA_DESC *dp;
+				int index;
+				int sync;
+
+				sync = 0;
+				index = privp->dma.rx.index;
+				if (++index >= DMA_RX_DESC_NUM)
+					index = 0;
+
+				while (index != privp->dma.rx.index) {
+					dp = RX_DESC(privp->dma.rx.descBufp, index);
+					if (ETHHW_DMA_TRANSFER_DONE(dp)) {
+						/* Sync-up required */
+						sync = 1;
+						break;
+					}
+
+					if (++index >= DMA_RX_DESC_NUM)
+						index = 0;
+				}
+
+				if (unlikely(sync)) {
+					privp->dma.rx.index = index;
+					continue;
+				}
+			}
+
+			break;
+		}
+
+		/* Unmap buffer */
+		dma_unmap_single(NULL, (dma_addr_t) bufp, len, DMA_FROM_DEVICE);
+
+		/* Update Rx DMA to reallocate a buffer for the descriptor ring */
+		privp->dma.rx.count++;
+
+		/* Get socket buffer information from Rx DMA buffer */
+		skb = SKB_BUF_HDR(bufp);
+
+		FRAME_DUMP(MSG_LEVEL_RX_RAW, "Rx Raw", bufp, len);
+
+		/* Format the frame according to ASIC requirements and adjust buffer */
+		if (BRCM_ENCAP_MODE == BRCM_ENCAP_MODE_REMOVE) {
+			offset = ethHw_rxFrameFormat(&bufp, &len);
+		} else {
+			offset = ethHw_rxFrameFormatRaw(&bufp, &len);
+		}
+		skb_reserve(skb, offset);
+
+		FRAME_DUMP(MSG_LEVEL_RX, "Rx", bufp, len);
+
+		if (unlikely(len < MIN_FRAME_LEN)) {
+			/* Frame size is invalid, so discard */
+			FRAME_DUMP_ALWAYS(KERN_WARNING "Invalid frame size received\n", bufp, len);
+			dev_kfree_skb_any(skb);
+
+			privp->stat.rx_dropped++;
+
+			continue;
+		}
+
+		/* Update remainder of socket buffer information */
+		skb_put(skb, len);
+		skb->dev = dev;
+		skb->protocol = eth_type_trans(skb, dev);
+
+		if (BRCM_ENCAP_MODE == BRCM_ENCAP_MODE_KEEP_SKIP) {
+			__brcmPacketTypeHandler(skb);
+		}
+
+		skb->ip_summed = CHECKSUM_NONE;
+#if 0
+		if (unlikely(sysCtlRxDiscard)) {
+			/* Discard for debugging purposes */
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+#endif
+
+		/* Forward socket buffer to kernel for processing by IP stack */
+		netif_receive_skb(skb);
+
+		/* Update counts and stats */
+		rxCount++;
+
+		privp->stat.rx_packets++;
+		if (BRCM_ENCAP_MODE == BRCM_ENCAP_MODE_REMOVE) {
+			privp->stat.rx_bytes += len;
+		} else {
+			/* Report length of Rx data that was received over the wire, so
+			*  account for Broadcom type field
+			*/
+			privp->stat.rx_bytes += (len - ETHHW_BRCM_HDR_LEN);
+		}
+	}
+
+	if (rxCount > sysCtlRxFifoMax)
+		sysCtlRxFifoMax = rxCount;
+
+	if (likely(rxCount < quota)) {
+		/* Notify kernel that no more Rx frames are available */
+		napi_complete(napi);
+
+		/* Acknowledge and enable Rx DMA interrupt */
+		ethHw_dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+		ethHw_dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
+	}
+
+	return rxCount;
+}
+
+static void bcmring_net_set_multicast_list(struct net_device *dev)
+{
+	/* TODO:  Add multicast list support */
+}
+
+static int bcmring_net_set_mac_address(struct net_device *dev, void *addr)
+{
+	BCMRING_PRIV *privp;
+	unsigned char *macp;
+
+	privp = netdev_priv(dev);
+
+	macp = ((struct sockaddr *)addr)->sa_data;
+	ethHw_arlEntrySet(macp, 0, ETHHW_PORT_INT, 0, 1, 1);
+
+	memcpy(dev->dev_addr, macp, dev->addr_len);
+
+	return 0;
+}
+
+static struct net_device_stats *bcmring_net_get_stats(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+	struct net_device_stats *statp;
+
+	privp = netdev_priv(dev);
+	statp = &privp->stat;
+
+	return statp;
+}
+
+static void bcmring_net_tx_timeout(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	netif_wake_queue(dev);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void bcmring_net_poll_controller(struct net_device *dev)
+{
+	BCMRING_PRIV *privp;
+
+	privp = netdev_priv(dev);
+
+	/* TODO:  Add polling support */
+}
+#endif
+
+#if PHY_DEVICE_SUPPORT
+static int bcmring_net_create_phy_if(int index, struct net_device **dev)
+{
+	struct net_device *phyDev;
+	BCMRING_PRIV *privp;
+	int rc;
+	char name[] = "phy_";
+
+	if (index > 9) {
+		myPrintk(KERN_ERR "Can only support upto 9 PHY devices\n");
+		return -EFAULT;
+	}
+
+	phyDev = alloc_etherdev(sizeof(BCMRING_PRIV));
+	if (!phyDev) {
+		myPrintk(KERN_ERR "Failed to alloc PHY device\n");
+		return -ENOMEM;
+	}
+
+	privp = netdev_priv(phyDev);
+
+	/* Map port directly to supplied index */
+	privp->eth.phyPort = index;
+
+	/* Build device name, ie phy0, phy1, etc */
+	name[3] = '0' + index;
+	strcpy(phyDev->name, name);
+
+	/* Assign device ops */
+	phyDev->ethtool_ops = &bcmring_ethtool_ops;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	/* Not needed, but added to prevent kernel warnings in console */
+	phyDev->netdev_ops = &phy_netdev_ops;
+#endif
+
+	rc = register_netdev(phyDev);
+	if (rc) {
+		printk(KERN_ERR "Failed to register PHY device\n");
+		free_netdev(phyDev);
+		return rc;
+	}
+
+	*dev = phyDev;
+
+	return 0;
+}
+#endif
+
+static int bcmring_net_probe(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	BCMRING_PRIV *privp;
+	int rc;
+	int reg;
+	int i;
+
+	printk(banner);
+	printk("bcmring_net configuration: brcmMode=%i, descRx=%i, descTx=%i\n",
+	       brcmMode, descRx, descTx);
+
+	/* Initialize resources required by the driver */
+	dev = alloc_etherdev(sizeof(BCMRING_PRIV));
+	if (!dev) {
+		myPrintk(KERN_ERR "Failed to alloc device\n");
+
+		return -ENOMEM;
+	}
+
+	privp = netdev_priv(dev);
+	platform_set_drvdata(pdev, dev);
+
+	/* Create copy of driver handle for proc interface */
+	procPrivp = privp;
+	localDevp = dev;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	dev->netdev_ops = &bcmring_netdev_ops;
+#else
+	dev->get_stats = bcmring_net_get_stats;
+	dev->open = bcmring_net_open;
+	dev->stop = bcmring_net_close;
+	dev->hard_start_xmit = bcmring_net_hard_start_xmit;
+	dev->set_mac_address = bcmring_net_set_mac_address;
+	dev->do_ioctl = bcmring_net_do_ioctl;
+	dev->tx_timeout = bcmring_net_tx_timeout;
+#endif
+	dev->watchdog_timeo = TX_TIMEOUT;
+	netif_napi_add(dev, &privp->napi, bcmring_net_poll, 64);
+#ifdef CONFIG_NET_BCMRING_ETHTOOL
+	dev->ethtool_ops = &bcmring_ethtool_ops;
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = bcmring_net_poll_controller;
+#endif
+	/* Assign Rx interrupt even though both Rx and Tx interrupts are required.
+	*  This is for informational purposes only
+	*/
+	dev->irq = IRQ_DMA_ESW_RX;
+	dev->hard_header_len += ETHHW_BRCM_HDR_LEN;
+	dev->features &= ~(NETIF_F_SG | NETIF_F_FRAGLIST);
+	dev->tx_queue_len = DMA_TX_DESC_NUM;
+
+	rc = register_netdev(dev);
+	if (rc) {
+		myPrintk(KERN_ERR "Failed to register device\n");
+		free_netdev(dev);
+
+		return rc;
+	}
+
+	/* Start ethernet block.  This should be done as early as possible to allow
+	*  the switch to begin bridging frames on the external ports
+	*/
+	rc = ethStart(&privp->eth);
+	if (rc) {
+		myPrintk(KERN_ERR "Failed to start ethernet block\n");
+		free_netdev(dev);
+
+		return rc;
+	}
+
+	/* Clear stats */
+	memset(&privp->stat, 0, sizeof(privp->stat));
+
+	/* Initialize MII support */
+	privp->mii_if.phy_id = privp->eth.phyPort;
+	privp->mii_if.phy_id_mask = ETHHW_PORT_NUM - 1;    /* ETHHW_PORT_NUM must be 2^x */
+	privp->mii_if.reg_num_mask = 32 - 1;               /* Number of MII registers (32 per spec) */
+	privp->mii_if.dev = dev;
+	privp->mii_if.mdio_read = miiGet;
+	privp->mii_if.mdio_write = miiSet;
+
+	reg = ethMiiGet(privp->mii_if.phy_id, MII_ADVERTISE);
+	privp->mii_if.advertising = reg;
+
+	reg = ethMiiGet(privp->mii_if.phy_id, 24);
+	privp->mii_if.full_duplex = ((reg & 0x0001) ? 1 : 0);
+
+	reg = ethMiiGet(privp->mii_if.phy_id, MII_BMCR);
+	privp->mii_if.force_media = ((reg & BMCR_ANENABLE) ? 0 : 1);
+
+	/* Get chip configuration */
+	privp->chip.portNum = 0;
+	privp->chip.portNumExt = 0;
+
+	for (i = ETHHW_PORT_MIN; i <= ETHHW_PORT_MAX; i++) {
+		privp->chip.phyAvailable[i] = cap_isPresent(CAP_ETH_PHY, i);
+		privp->chip.gmiiAvailable[i] = cap_isPresent(CAP_ETH_GMII, i);
+		privp->chip.sgmiiAvailable[i] = cap_isPresent(CAP_ETH_SGMII, i);
+
+		if (privp->chip.phyAvailable[i] == CAP_PRESENT)
+			privp->chip.portNum++;
+
+		if (privp->chip.sgmiiAvailable[i] == CAP_PRESENT)
+			privp->chip.portNumExt++;
+	}
+
+	if (privp->chip.portNum == 0) {
+		myPrintk(KERN_ERR "No ethernet ports available\n");
+		return -EFAULT;
+	}
+
+#if PHY_DEVICE_SUPPORT
+	for (i = 0; i < PHY_DEV_NUM; i++)
+		privp->phyDev[i] = NULL;
+
+	if (privp->chip.portNumExt > 1) {
+		int num;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+		/* Clear structure since it will not be used by the /phy devices */
+		memset((void *)&phy_netdev_ops, 0, sizeof(struct net_device_ops));
+#endif
+
+		/* At least two external ports exist so create /phy devices
+		*  for ethtool.  This will give the user the ability to configure
+		*  each external port with ethtool.  The mapping is as follows:
+		*
+		*  phy0 - ethernet port 0
+		*  phy1 - ethernet port 1
+		*  eth0 - PHY port (typically the LAN port, but is user defined)
+		*/
+		if (privp->chip.portNumExt > ETHHW_PORT_NUM) {
+			myPrintk(KERN_WARNING "Detected %i ports, but only upto %i are "
+				"supported", privp->chip.portNumExt, ETHHW_PORT_NUM);
+			num = ETHHW_PORT_NUM;
+		} else
+			num = privp->chip.portNumExt;
+
+		for (i = 0; i < num; i++)
+			bcmring_net_create_phy_if(i, &privp->phyDev[i]);
+	}
+#endif
+
+	return 0;
+}
+
+static int bcmring_net_remove(struct platform_device *pdev)
+{
+	struct net_device *dev;
+
+	dev = platform_get_drvdata(pdev);
+
+#if PHY_DEVICE_SUPPORT
+	{
+		BCMRING_PRIV *privp;
+		int i;
+
+		privp = netdev_priv(dev);
+
+		if (privp->chip.portNumExt > 1) {
+			for (i = 0; i < ETHHW_PORT_NUM; i++) {
+				if (privp->phyDev[i]) {
+					unregister_netdev(privp->phyDev[i]);
+					free_netdev(privp->phyDev[i]);
+				}
+			}
+		}
+	}
+#endif
+
+	unregister_netdev(dev);
+	free_netdev(dev);
+
+	return 0;
+}
+
+static void bcmring_net_shutdown(struct platform_device *pdev)
+{
+	(void)pdev;
+
+	/* Disable forwarding to CPU from internal port */
+	ethHw_macEnableSet(ETHHW_PORT_INT, 0, 0);
+	ethHw_impEnableSet(0);
+}
+
+#ifdef CONFIG_PM
+static int bcmring_net_notify_reboot(struct notifier_block *nb,
+		unsigned long event, void *ptr)
+{
+	(void)nb;
+	(void)ptr;
+
+	switch (event) {
+	case SYS_DOWN:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		{
+			/* Disable forwarding to CPU from internal port */
+			ethHw_macEnableSet(ETHHW_PORT_INT, 0, 0);
+			ethHw_impEnableSet(0);
+		}
+		break;
+
+	default:
+		{
+		}
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static int bcmring_net_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev;
+	BCMRING_PRIV *privp;
+	int net_alive;
+	int disable_lan, disable_pc, disable_int;
+
+	dev = platform_get_drvdata(pdev);
+	privp = netdev_priv(dev);
+
+	/* Backup current device state */
+	privp->wasRunning = netif_running(dev);
+
+	if (privp->wasRunning) {
+		/* Shutdown network i/f */
+		netif_device_detach(dev);
+
+		/* Pause any existing work */
+		cancel_delayed_work(&ethStatusTask);
+		flush_workqueue(ethStatusWorkQueuep);
+	}
+
+	net_alive   = (pm_net_get_state() == pm_state_alive);
+	disable_lan = net_alive ? sysCtlPmDisablePortLan : 1;
+	disable_pc  = net_alive ? sysCtlPmDisablePortPc : 1;
+	disable_int = net_alive ? sysCtlPmDisablePortInternal : 1;
+
+	/* Disable MAC Rx */
+	if (disable_lan) {
+		ethHw_macEnableSet(PORT_LAN, 0, 1);
+	}
+	if ((CHIP_PORTS(privp) > 1) && disable_pc) {
+		ethHw_macEnableSet(PORT_PC, 0, 1);
+	}
+
+	/* Let Tx DMA drain */
+	if (privp->wasRunning) {
+		while (__kfifo_len(privp->dma.txFifop) != 0)
+		;
+	}
+
+	/* Disable MAC Tx as well */
+	if (disable_lan) {
+		ethHw_macEnableSet(PORT_LAN, 0, 0);
+	}
+	if ((CHIP_PORTS(privp) > 1) && disable_pc) {
+		ethHw_macEnableSet(PORT_PC, 0, 0);
+	}
+
+	/* Disable internal port */
+	if (disable_int) {
+		ethHw_macEnableSet(ETHHW_PORT_INT, 0, 0);
+	}
+
+	/* Power-down PHY(s) */
+	if (disable_lan) {
+		ethHw_phyPowerdownSet(PORT_LAN, 1);
+	}
+	if ((CHIP_PORTS(privp) > 1) && disable_pc) {
+		ethHw_phyPowerdownSet(PORT_PC, 1);
+	}
+
+	/* Disable switch clock if PHYs are powered down */
+	if ((disable_lan && (CHIP_PORTS(privp) == 1)) ||
+	    (disable_lan && disable_pc && (CHIP_PORTS(privp) > 1))) {
+		chipcHw_setClockDisable(chipcHw_CLOCK_ESW);
+		chipcHw_busInterfaceClockDisable(chipcHw_REG_BUS_CLOCK_ESW);
+	}
+
+	return 0;
+}
+
+static int bcmring_net_resume(struct platform_device *pdev)
+{
+	struct net_device *dev;
+	BCMRING_PRIV *privp;
+	int net_alive;
+	int disable_lan, disable_pc, disable_int;
+
+	dev = platform_get_drvdata(pdev);
+	privp = netdev_priv(dev);
+
+	net_alive   = (pm_net_get_state() == pm_state_alive);
+	disable_lan = net_alive ? sysCtlPmDisablePortLan : 1;
+	disable_pc  = net_alive ? sysCtlPmDisablePortPc : 1;
+	disable_int = net_alive ? sysCtlPmDisablePortInternal : 1;
+
+	/* Enable switch clock if necessary */
+	if ((disable_lan && (CHIP_PORTS(privp) == 1)) ||
+	    (disable_lan && disable_pc && (CHIP_PORTS(privp) > 1))) {
+		chipcHw_setClockEnable(chipcHw_CLOCK_ESW);
+		chipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_ESW);
+	}
+
+	/* Power-up the PHY(s) */
+	if (disable_lan) {
+		ethHw_phyPowerdownSet(PORT_LAN, 0);
+	}
+	if ((CHIP_PORTS(privp) > 1) && disable_pc) {
+		ethHw_phyPowerdownSet(PORT_PC, 0);
+	}
+
+	/* Enable internal port */
+	if (disable_int) {
+		ethHw_macEnableSet(ETHHW_PORT_INT, 1, 1);
+	}
+
+	/* Enable external port */
+	if (disable_lan) {
+		ethHw_macEnableSet(PORT_LAN, 1, 1);
+	}
+	if ((CHIP_PORTS(privp) > 1) && disable_pc) {
+		ethHw_macEnableSet(PORT_PC, 1, 1);
+	}
+
+	if (privp->wasRunning) {
+		/* Resume any existing work */
+		queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask, 0);
+
+		/* Restore network i/f */
+		netif_device_attach(dev);
+	}
+
+	return 0;
+}
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+static struct platform_driver bcmring_net_driver = {
+	.driver = {
+		.name = "bcmring-net",
+		.owner = THIS_MODULE,
+	},
+	.probe = bcmring_net_probe,
+	.remove = bcmring_net_remove,
+	.shutdown = bcmring_net_shutdown,
+	.suspend = bcmring_net_suspend,
+	.resume = bcmring_net_resume,
+};
+
+static int __init bcmring_net_init(void)
+{
+#ifdef CONFIG_PM
+	register_reboot_notifier(&bcmring_net_notifier_reboot);
+#endif
+	return platform_driver_register(&bcmring_net_driver);
+}
+
+static void __exit bcmring_net_exit(void)
+{
+#ifdef CONFIG_PM
+	unregister_reboot_notifier(&bcmring_net_notifier_reboot);
+#endif
+	platform_driver_unregister(&bcmring_net_driver);
+}
+
+module_init(bcmring_net_init);
+module_exit(bcmring_net_exit);
+
+MODULE_DESCRIPTION(BCM_NET_MODULE_DESCRIPTION);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(BCM_NET_MODULE_VERSION);
-- 
1.7.0.4

