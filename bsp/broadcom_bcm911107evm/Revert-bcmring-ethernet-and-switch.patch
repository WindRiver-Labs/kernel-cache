From 2d8c1f535ad11a7b49891e8e043f39b0d449d4f3 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 24 May 2010 13:28:46 +0800
Subject: [PATCH 43/47] Revert "bcmring: ethernet and switch"

This reverts commit 4e16a7d19394b893a083234ff17b18f1c895f2a1.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/arm/mach-bcmring/arch.c                       |    6 -
 arch/arm/mach-bcmring/csp/Makefile                 |    1 -
 arch/arm/mach-bcmring/csp/eth/Makefile             |    1 -
 arch/arm/mach-bcmring/csp/eth/ethHw.c              |  585 -----
 arch/arm/mach-bcmring/csp/eth/ethHw_asm.S          |   49 -
 arch/arm/mach-bcmring/include/csp/ethHw.h          |  188 --
 arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h |  296 ---
 drivers/net/Kconfig                                |    7 -
 drivers/net/Makefile                               |    1 -
 drivers/net/bcmring_ethDma.c                       |  228 --
 drivers/net/bcmring_ethDma.h                       |  124 --
 drivers/net/bcmring_net.c                          | 2325 --------------------
 12 files changed, 0 insertions(+), 3811 deletions(-)
 delete mode 100644 arch/arm/mach-bcmring/csp/eth/Makefile
 delete mode 100644 arch/arm/mach-bcmring/csp/eth/ethHw.c
 delete mode 100644 arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
 delete mode 100644 arch/arm/mach-bcmring/include/csp/ethHw.h
 delete mode 100644 arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
 delete mode 100644 drivers/net/bcmring_ethDma.c
 delete mode 100644 drivers/net/bcmring_ethDma.h
 delete mode 100644 drivers/net/bcmring_net.c

diff --git a/arch/arm/mach-bcmring/arch.c b/arch/arm/mach-bcmring/arch.c
index 46dd70a..5c11e49 100644
--- a/arch/arm/mach-bcmring/arch.c
+++ b/arch/arm/mach-bcmring/arch.c
@@ -91,11 +91,6 @@ static struct platform_device nand_device = {
 	.num_resources	= ARRAY_SIZE(nand_resource),
 };
 
-static struct platform_device net_device = {
-	.name = "bcmring-net",
-	.id = -1,
-};
-
 static struct platform_device i2c_device = {
 	.name = "bcm-i2c",
 	.id = -1,
@@ -103,7 +98,6 @@ static struct platform_device i2c_device = {
 
 static struct platform_device *devices[] __initdata = {
 	&nand_device,
-	&net_device,
 	&i2c_device,
 };
 
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index ce693bd..979c23c 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -6,4 +6,3 @@ obj-y += gpiomux/
 obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
 obj-$(CONFIG_I2C_BCM11XX) += i2c/
 obj-$(CONFIG_SPI_BCMRING) += spi/
-obj-$(CONFIG_NET_BCMRING) += eth/
diff --git a/arch/arm/mach-bcmring/csp/eth/Makefile b/arch/arm/mach-bcmring/csp/eth/Makefile
deleted file mode 100644
index a68c1ad..0000000
--- a/arch/arm/mach-bcmring/csp/eth/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-y += ethHw_asm.o ethHw.o
diff --git a/arch/arm/mach-bcmring/csp/eth/ethHw.c b/arch/arm/mach-bcmring/csp/eth/ethHw.c
deleted file mode 100644
index 88dd9fb..0000000
--- a/arch/arm/mach-bcmring/csp/eth/ethHw.c
+++ /dev/null
@@ -1,585 +0,0 @@
-/*****************************************************************************
-* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-
-/****************************************************************************/
-/**
-*  @file    ethHw.c
-*
-*  @brief   Low level ETH driver routines
-*
-*  @note
-*
-*   These routines provide basic ETH functionality only. Intended for use
-*   with boot and other simple applications.
-*/
-/****************************************************************************/
-
-/* ---- Include Files ---------------------------------------------------- */
-#include <csp/string.h>
-#include <csp/module.h>
-#include <csp/delay.h>
-
-#include <csp/ethHw.h>
-
-#include <mach/csp/ethHw_reg.h>
-#include <mach/csp/chipcHw_inline.h>
-
-/* ---- External Variable Declarations ----------------------------------- */
-/* ---- External Function Prototypes ------------------------------------- */
-/* ---- Public Variables ------------------------------------------------- */
-/* ---- Private Constants and Types -------------------------------------- */
-/* ---- Private Variables ------------------------------------------------ */
-
-static uint16_t linkStatChg;
-
-#define ONE_MHZ      (1 * 1000 * 1000)
-#define CLOCK_FREQ   (100 * ONE_MHZ)
-
-/* ---- Private Function Prototypes -------------------------------------- */
-/* TODO: handle endianness */
-/* mactou64(mac) and u64tomac(u64, mac) assumed little endian */
-
-#define mactou64(mac)	(((uint64_t)((mac)[0]) << 40) + ((uint64_t)((mac)[1]) << 32) + \
-			((uint64_t)((mac)[2]) << 24) + ((uint64_t)((mac)[3]) << 16) + \
-			((uint64_t)((mac)[4]) << 8) + ((uint64_t)((mac)[5])))
-
-#define u64tomac(u64, mac) {\
-	mac[0] = ((uint8_t *)&u64)[5]; \
-	mac[1] = ((uint8_t *)&u64)[4]; \
-	mac[2] = ((uint8_t *)&u64)[3]; \
-	mac[3] = ((uint8_t *)&u64)[2]; \
-	mac[4] = ((uint8_t *)&u64)[1]; \
-	mac[5] = ((uint8_t *)&u64)[0]; }
-
-static int miiAccessDone(void);
-static int arlAccessDone(void);
-
-/* ==== Public Functions ================================================= */
-
-/*****************************************************************************
-* See ethHw.h for API documentation
-*****************************************************************************/
-
-int ethHw_Init(void)
-{
-	int timeout;
-	volatile uint32_t reg;
-
-	if (chipcHw_setClock(chipcHw_CLOCK_ESW, chipcHw_OPTYPE_GET_OUTPUT, 0)) {
-		/* Switch clock is already enabled */
-	} else {
-		/* Enable switch clock */
-		chipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_ESW);
-
-		chipcHw_setClockFrequency(chipcHw_CLOCK_ESW, CLOCK_FREQ);
-		chipcHw_setClockEnable(chipcHw_CLOCK_ESW);
-	}
-
-	/* Check if switch and PHY are ready */
-	udelay(50);
-
-	timeout = 0;
-	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
-	while (!(reg & ETHHW_REG_IMP_PHY_MISC_READY)) {
-		ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
-		if (timeout++ > ETHHW_REG_READY_TIMEOUT)
-			return ETHHW_RC_TIMEOUT;
-	}
-
-	/* Configure internal port forwarding */
-	ETHHW_REG_MASK_SET(ethHw_regCtrlSwitchMode,
-	ETHHW_REG_CTRL_SW_FWDG_EN | ETHHW_REG_CTRL_SW_FWDG_MODE);
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlImpCtrl);
-	reg |= ETHHW_REG_CTRL_IMPCTRL_RX_BCAST_EN;   /* Allow broadcast */
-	reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN;  /* Drop unlearned multicast */
-	reg &= ~ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN;  /* Drop unlearned unicast */
-	ETHHW_REG_SET(ethHw_regCtrlImpCtrl, reg);
-
-	/* Note that the internal port is only configured at this point and not
-	*  actually enabled yet.  The user needs to set-up the DMA first, and then
-	*  enable the internal port by calling ethHw_impEnableSet()
-	*/
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_Exit(void)
-{
-	/* Application code will normally control shutdown of the driver */
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_stpStateSet(int port, ETHHW_STP_STATE state)
-{
-	volatile uint32_t reg;
-
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-	if (!ETHHW_VALID_STP_STATE(state))
-		return ETHHW_RC_PARAM;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
-	reg &= ~ETHHW_REG_CTRL_PORTCTRL_STP_STATE_MASK;
-	reg |= (state << ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT);
-	ETHHW_REG_SET(ethHw_regCtrlPortCtrl(port), reg);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_stpStateGet(int port, ETHHW_STP_STATE *statep)
-{
-	volatile uint32_t reg;
-
-	*statep = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
-	reg &= ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT;
-
-	*statep = reg >> ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT;
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_miiSet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t data)
-{
-	uint32_t mdioAddr;
-	uint32_t cmd;
-
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-
-	addr <<= 1;	 /* Convert MII register address to physical address */
-
-	if (flags & ETHHW_MII_FLAGS_EXT)
-		mdioAddr = ETHHW_REG_MII_EXT(port, addr);
-	else
-		mdioAddr = ETHHW_REG_MII(port, addr);
-
-	cmd = ETHHW_REG_MDIO_DONE_MASK | ETHHW_REG_MDIO_EXTRA_MASK | ETHHW_REG_MDIO_WRITE_MASK;
-	if (flags & ETHHW_MII_FLAGS_SERDES)
-		cmd |= ETHHW_REG_MDIO_SERDES_MASK;
-
-	ETHHW_REG_SET(ethHw_regMdioAddr, mdioAddr);
-	ETHHW_REG_SET(ethHw_regMdioWriteData, data & 0x0000ffff);
-	ETHHW_REG_SET(ethHw_regMdioStatus, cmd);
-#if defined(CFG_GLOBAL_CHIP) && (CFG_GLOBAL_CHIP == FPGA11107)
-	/* Handle bus timing in FPGA */
-	ETHHW_REG_SET(ethHw_regMdioStatus, cmd & ~ETHHW_REG_MDIO_EXTRA_MASK);
-#endif
-
-	if (!miiAccessDone())
-		return ETHHW_RC_TIMEOUT;
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_miiGet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t *datap)
-{
-	uint32_t mdioAddr;
-	uint32_t cmd;
-
-	*datap = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-
-	addr <<= 1;	 /* Convert MII register address to physical address */
-
-	if (flags & ETHHW_MII_FLAGS_EXT)
-		mdioAddr = ETHHW_REG_MII_EXT(port, addr);
-	else
-		mdioAddr = ETHHW_REG_MII(port, addr);
-
-	cmd = (ETHHW_REG_MDIO_DONE_MASK | ETHHW_REG_MDIO_EXTRA_MASK | ETHHW_REG_MDIO_READ_MASK);
-	if (flags & ETHHW_MII_FLAGS_SERDES)
-		cmd |= ETHHW_REG_MDIO_SERDES_MASK;
-
-	ETHHW_REG_SET(ethHw_regMdioAddr, mdioAddr);
-	ETHHW_REG_SET(ethHw_regMdioStatus, cmd);
-#if defined(CFG_GLOBAL_CHIP) && (CFG_GLOBAL_CHIP == FPGA11107)
-	/* Handle bus timing in FPGA */
-	ETHHW_REG_SET(ethHw_regMdioStatus, cmd & ~ETHHW_REG_MDIO_EXTRA_MASK);
-#endif
-
-	if (!miiAccessDone())
-		return ETHHW_RC_TIMEOUT;
-
-	*datap = ETHHW_REG_GET_VAL(ethHw_regMdioReadData) & 0x0000ffff;
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_impEnableSet(int enable)
-{
-	volatile uint32_t reg;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regMgmtGblMgmtCtrl);
-	reg &= ~ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_MASK;
-	if (enable)
-		reg |= ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN;
-
-	ETHHW_REG_SET(ethHw_regMgmtGblMgmtCtrl, reg);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_impEnableGet(int *enablep)
-{
-	volatile uint32_t reg;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regMgmtGblMgmtCtrl);
-	*enablep = (((reg & ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN) ==
-	ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN) ? 1 : 0);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_arlEntrySet(char *macp, int vid, int port, int cos,
-	int entryValid, int entryStatic)
-{
-	int i;
-	uint64_t mac, mac2;
-	volatile uint32_t reg;
-
-	/*
-	 * mac is endian-dependent.  Cannot use *((uint64_t *)(macp))
-	 * mac = *((uint64_t *)(macp));
-	 */
-	mac = mactou64(macp);
-	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_INDEX, mac);
-	ETHHW_REG_SET(ethHw_regArlVlanIndex, vid);
-	ETHHW_REG_SET(ethHw_regArlRwCtrl, (ETHHW_REG_ARL_RWCTRL_START_DONE | ETHHW_REG_ARL_RWCTRL_READ));
-	if (!arlAccessDone())
-		return ETHHW_RC_TIMEOUT;
-
-	mac |= (((uint64_t)vid) << 48);
-
-	for (i = ETHHW_REG_ARL_ENTRY_MIN; i <= ETHHW_REG_ARL_ENTRY_MAX; i++) {
-		/* current entry is not valid */
-		if ((ETHHW_REG_GET_VAL(ethHw_regArlFwdEntry(i)) & ETHHW_REG_ARL_FWDENTRY_VALID)) {
-			/* check if MAC and VID are the same as existing entry */
-			/* if yes, then update entry instead */
-			ETHHW_REG_GET64(ETHHW_REG_ARL_MAC_VID_ENTRY(i), &mac2);
-			if (mac2 == mac)
-				break;
-			} else {
-				break;
-			}
-	}
-
-	/* All entries are used */
-	if (i > ETHHW_REG_ARL_ENTRY_MAX)
-		return ETHHW_RC_FULL;
-
-	/* Validate entry */
-	reg = ETHHW_REG_ARL_FWDENTRY_AGE | (cos << ETHHW_REG_ARL_FWDENTRY_TC_SHIFT) | port;
-
-	/* Validate entry */
-	if (entryValid)
-		reg |= ETHHW_REG_ARL_FWDENTRY_VALID;
-
-	/* Static entry */
-	if (entryStatic)
-		reg |= ETHHW_REG_ARL_FWDENTRY_STATIC;
-
-	ETHHW_REG_SET(ethHw_regArlFwdEntry(i), reg);
-
-	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_VID_ENTRY(i), mac);
-
-	mac = mactou64(macp);
-	ETHHW_REG_SET64(ETHHW_REG_ARL_MAC_INDEX, mac);
-	ETHHW_REG_SET(ethHw_regArlVlanIndex, vid);
-	ETHHW_REG_SET(ethHw_regArlRwCtrl, (ETHHW_REG_ARL_RWCTRL_START_DONE | ETHHW_REG_ARL_RWCTRL_WRITE));
-	if (!arlAccessDone())
-		return ETHHW_RC_TIMEOUT;
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_portLinkStatus(int port)
-{
-	int up;
-
-	up = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT(port))
-		return ETHHW_RC_PORT;
-
-	up = ((ETHHW_REG_GET_VAL(ethHw_regStatusLinkStatus) & ETHHW_PORT_MASK(port)) ? 1 : 0);
-
-	return up;
-}
-
-
-int ethHw_portLinkStatusChange(int port)
-{
-	int change;
-
-	change = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT(port))
-		return ETHHW_RC_PORT;
-
-	linkStatChg |= ETHHW_REG_GET_VAL(ethHw_regStatusLinkStatusChange);
-	change = ((linkStatChg & ETHHW_PORT_MASK(port)) ? 1 : 0);
-	linkStatChg &= ~ETHHW_PORT_MASK(port);
-
-	return change;
-}
-
-
-int ethHw_portSpeed(int port)
-{
-	int speed;
-	int speed_bmp;
-
-	speed = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT(port))
-		return ETHHW_RC_PORT;
-
-	speed_bmp = (ETHHW_REG_GET_VAL(ethHw_regStatusPortSpeed) >> ETHHW_REG_STATUS_PORT_SPEED_SHIFT(port)) &
-	ETHHW_REG_STATUS_PORT_SPEED_MASK;
-
-	if (speed_bmp & ETHHW_REG_STATUS_PORT_SPEED_1000MB) {
-		speed = 1000;
-	} else if (speed_bmp & ETHHW_REG_STATUS_PORT_SPEED_100MB) {
-		speed = 100;
-	} else {
-		speed = 10;
-	}
-
-	return speed;
-}
-
-
-int ethHw_macEnableSet(int port, int tx, int rx)
-{
-	volatile uint32_t reg;
-
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
-
-	if (tx)
-		reg &= ~ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE;
-	else
-		reg |= ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE;
-
-	if (rx)
-		reg &= ~ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE;
-	else
-		reg |= ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE;
-
-	ETHHW_REG_SET(ethHw_regCtrlPortCtrl(port), reg);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_macEnableGet(int port, int *txp, int *rxp)
-{
-	volatile uint32_t reg;
-
-	*txp = ETHHW_VAR_UNINITIALIZED;
-	*rxp = ETHHW_VAR_UNINITIALIZED;
-	if (!ETHHW_VALID_PORT_EXT(port))
-		return ETHHW_RC_PORT;
-
-	reg = ETHHW_REG_GET_VAL(ethHw_regCtrlPortCtrl(port));
-
-	*txp = ((reg & ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE) ? 0 : 1);
-	*rxp = ((reg & ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE) ? 0 : 1);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_phyPowerdownSet(int port, int enable)
-{
-	volatile uint32_t reg;
-
-	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
-
-	if (enable)
-		reg |= ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port);
-	else
-		reg &= ~ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port);
-
-	ETHHW_REG_SET(ethHw_regImpPhyMisc, reg);
-
-	return ETHHW_RC_NONE;
-}
-
-
-int ethHw_phyPowerdownGet(int port, int *enablep)
-{
-	volatile uint32_t reg;
-
-	ETHHW_REG_GET(ethHw_regImpPhyMisc, reg);
-
-	*enablep = ((reg & ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port)) ==
-	ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port));
-
-	return ETHHW_RC_NONE;
-}
-
-
-/* MIB functions */
-#define MIB_FUNC_32(type) \
-uint32_t ethHw_mib ## type(int port) \
-{\
-	if (!ETHHW_VALID_PORT_MIB(port)) \
-		return 0; \
-	\
-	return ethHw_regMib ## type(port); \
-} \
-\
-EXPORT_SYMBOL(ethHw_mib ## type);
-
-#define MIB_FUNC_64(type) \
-uint64_t ethHw_mib ## type(int port) \
-{\
-	uint64_t mib; \
-	\
-	if (!ETHHW_VALID_PORT_MIB(port)) \
-		return 0; \
-	\
-	ethHw_get64(ETHHW_REG_MIB_ ## type(port), &mib); \
-	\
-	return mib; \
-} \
-\
-EXPORT_SYMBOL(ethHw_mib ## type);
-
-MIB_FUNC_64(TxOctets);
-MIB_FUNC_32(TxDropPkts);
-MIB_FUNC_32(TxQ0Pkt);
-MIB_FUNC_32(TxBroadcastPkts);
-MIB_FUNC_32(TxMulticastPkts);
-MIB_FUNC_32(TxUnicastPkts);
-MIB_FUNC_32(TxCollisions);
-MIB_FUNC_32(TxSingleCollision);
-MIB_FUNC_32(TxMultipleCollision);
-MIB_FUNC_32(TxDeferredTransmit);
-MIB_FUNC_32(TxLateCollision);
-MIB_FUNC_32(TxExcessiveCollision);
-MIB_FUNC_32(TxFrameInDisc);
-MIB_FUNC_32(TxPausePkts);
-MIB_FUNC_32(TxQ1Pkt);
-MIB_FUNC_32(TxQ2Pkt);
-MIB_FUNC_32(TxQ3Pkt);
-MIB_FUNC_32(TxQ4Pkt);
-MIB_FUNC_32(TxQ5Pkt);
-MIB_FUNC_64(RxOctets);
-MIB_FUNC_32(RxUndersizePkts);
-MIB_FUNC_32(RxPausePkts);
-MIB_FUNC_32(Pkts64Octets);
-MIB_FUNC_32(Pkts65To127Octets);
-MIB_FUNC_32(Pkts128To255Octets);
-MIB_FUNC_32(Pkts256To511Octets);
-MIB_FUNC_32(Pkts512To1023Octets);
-MIB_FUNC_32(Pkts1024ToMaxPktOctets);
-MIB_FUNC_32(RxOversizePkts);
-MIB_FUNC_32(RxJabbers);
-MIB_FUNC_32(RxAlignmentErrors);
-MIB_FUNC_32(RxFcsErrors);
-MIB_FUNC_64(RxGoodOctets);
-MIB_FUNC_32(RxDropPkts);
-MIB_FUNC_32(RxUnicastPkts);
-MIB_FUNC_32(RxMulticastPkts);
-MIB_FUNC_32(RxBroadcastPkts);
-MIB_FUNC_32(RxSaChanges);
-MIB_FUNC_32(RxFragments);
-MIB_FUNC_32(JumboPktCount);
-MIB_FUNC_32(RxSymbolError);
-MIB_FUNC_32(InRangeErrorCount);
-MIB_FUNC_32(OutRangeErrorCount);
-MIB_FUNC_32(RxDiscard);
-MIB_FUNC_32(DosAssertCount);
-MIB_FUNC_32(DosDropCount);
-MIB_FUNC_32(IngressRateAssertCount);
-MIB_FUNC_32(IngressRateDropCount);
-MIB_FUNC_32(EgressRateAssertCount);
-
-
-/* ==== Exported Public Functions ======================================== */
-
-EXPORT_SYMBOL(ethHw_Init);
-EXPORT_SYMBOL(ethHw_Exit);
-
-EXPORT_SYMBOL(ethHw_stpStateSet);
-EXPORT_SYMBOL(ethHw_stpStateGet);
-
-EXPORT_SYMBOL(ethHw_miiSet);
-EXPORT_SYMBOL(ethHw_miiGet);
-
-EXPORT_SYMBOL(ethHw_impEnableSet);
-EXPORT_SYMBOL(ethHw_impEnableGet);
-
-EXPORT_SYMBOL(ethHw_arlEntrySet);
-
-EXPORT_SYMBOL(ethHw_portLinkStatus);
-EXPORT_SYMBOL(ethHw_portLinkStatusChange);
-EXPORT_SYMBOL(ethHw_portSpeed);
-
-EXPORT_SYMBOL(ethHw_macEnableSet);
-EXPORT_SYMBOL(ethHw_macEnableGet);
-
-EXPORT_SYMBOL(ethHw_phyPowerdownSet);
-EXPORT_SYMBOL(ethHw_phyPowerdownGet);
-
-EXPORT_SYMBOL(ethHw_get64);
-EXPORT_SYMBOL(ethHw_set64_byVal);
-EXPORT_SYMBOL(ethHw_set64_byRef);
-
-/* MIB public functions are exported in the function macros */
-
-/* ==== Private Functions ================================================ */
-
-static int miiAccessDone(void)
-{
-	int timeout;
-
-	timeout = 0;
-	while (ETHHW_REG_GET_VAL(ethHw_regMdioStatus) & ETHHW_REG_MDIO_DONE_MASK)
-		if (timeout++ >= ETHHW_REG_MII_TIMEOUT)
-			return 0;
-
-	return 1;
-}
-
-
-static int arlAccessDone(void)
-{
-	int timeout;
-
-	timeout = 0;
-	while (ETHHW_REG_GET_VAL(ethHw_regArlRwCtrl) & ETHHW_REG_ARL_RWCTRL_START_DONE)
-		if (timeout++ >= ETHHW_REG_ARL_TIMEOUT)
-			return 0;
-
-	return 1;
-}
diff --git a/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S b/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
deleted file mode 100644
index 964e10b..0000000
--- a/arch/arm/mach-bcmring/csp/eth/ethHw_asm.S
+++ /dev/null
@@ -1,49 +0,0 @@
-/*****************************************************************************
-*  Copyright 2009 - 2009 Broadcom Corporation.  All rights reserved.
-*
-*  Unless you and Broadcom execute a separate written software license
-*  agreement governing use of this software, this software is licensed to you
-*  under the terms of the GNU General Public License version 2, available at
-*  http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-*  Notwithstanding the above, under no circumstances may you combine this
-*  software in any way with any other Broadcom software provided under a
-*  license other than the GPL, without Broadcom's express prior written
-*  consent.
-*
-*****************************************************************************/
-
-// ***************************************************************************
-// void ethHw_get64( uint32_t addr, uint64_t *datap );
-
-   .global ethHw_get64
-
-ethHw_get64:
-	push  {r4}
-	ldm   r0, {r3, r4}
-	stm   r1, {r3, r4}
-	pop   {r4}
-	bx    lr
-
-
-// ***************************************************************************
-// void ethHw_set64_byVal( uint32_t addr, uint64_t data )
-
-	.global ethHw_set64_byVal
-
-ethHw_set64_byVal:
-	stm   r0, {r2, r3}
-	bx    lr
-
-
-// ***************************************************************************
-// void ethHw_set64_byRef( uint32_t addr, uint64_t *datap )
-
-	.global ethHw_set64_byRef
-
-ethHw_set64_byRef:
-	push  {r4}
-	ldm   r1, {r3, r4}
-	stm   r0, {r3, r4}
-	pop   {r4}
-	bx    lr
diff --git a/arch/arm/mach-bcmring/include/csp/ethHw.h b/arch/arm/mach-bcmring/include/csp/ethHw.h
deleted file mode 100644
index 590e50e..0000000
--- a/arch/arm/mach-bcmring/include/csp/ethHw.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/*****************************************************************************
-* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-
-/****************************************************************************/
-/**
-*  @file    ethHw.h
-*
-*  @brief   API definitions for low level ETH driver.
-*
-*  @note    This file includes all the custom APIs not defined in SDK Robo
-*/
-/****************************************************************************/
-
-#ifndef _ETHHW_H
-#define _ETHHW_H
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-/* ---- Include Files ---------------------------------------------------- */
-#include <csp/stdint.h>
-/* TODO:  Include file really shouldn't reference a Linux include path in the CSP */
-/* #include <linux/broadcom/bcmring/eth_defs.h> */
-
-#define ETHHW_PORT_0             0
-#define ETHHW_PORT_1             1
-#define ETHHW_PORT_INT           8
-#define ETHHW_PORT_SNAPSHOT      0x51
-#define ETHHW_PORT_ALL           -1
-
-#define ETHHW_PORT_MIN           ETHHW_PORT_0
-#define ETHHW_PORT_MAX           ETHHW_PORT_1
-#define ETHHW_PORT_NUM           (ETHHW_PORT_MAX - ETHHW_PORT_MIN + 1)
-#define ETHHW_PORT_MASK(p)       (1 << (p))
-
-#define ETHHW_PORTMASK_NONE      0
-#define ETHHW_PORTMASK_PORT_0    ETHHW_PORT_MASK(ETHHW_PORT_0)
-#define ETHHW_PORTMASK_PORT_1    ETHHW_PORT_MASK(ETHHW_PORT_1)
-#define ETHHW_PORTMASK_INT       ETHHW_PORT_MASK(ETHHW_PORT_INT)
-#define ETHHW_PORTMASK_EXT       (ETHHW_PORT_MASK(ETHHW_PORT_0) | \
-				ETHHW_PORT_MASK(ETHHW_PORT_1))
-#define ETHHW_PORTMASK_ALL       (ETHHW_PORTMASK_INT | ETHHW_PORTMASK_EXT)
-
-typedef enum {
-	ETHHW_STP_STATE_NONE = 0,
-	ETHHW_STP_STATE_DISABLED,
-	ETHHW_STP_STATE_BLOCKING,
-	ETHHW_STP_STATE_LISTENING,
-	ETHHW_STP_STATE_LEARNING,
-	ETHHW_STP_STATE_FORWARDING,
-} ETHHW_STP_STATE;
-
-#define ETHHW_MII_FLAGS_EXT                                 0x80000000     /* External PHY */
-#define ETHHW_MII_FLAGS_SERDES                              0x40000000     /* SERDES PHY */
-typedef uint32_t ETHHW_MII_FLAGS;
-
-/* <section> TODO:  Move to non-reg header file */
-/* Note that this assumes the buffers are 16-bit aligned */
-#define ethHw_macCopy(dp, sp) \
-{\
-	(((uint16_t *)(dp))[0] = ((uint16_t *)(sp))[0]); \
-	(((uint16_t *)(dp))[1] = ((uint16_t *)(sp))[1]); \
-	(((uint16_t *)(dp))[2] = ((uint16_t *)(sp))[2]); \
-}
-
-#define ethHw_macIsSame(m1p, m2p) \
-	((((uint16_t *)(m1p))[0] == ((uint16_t *)(m2p))[0]) && \
-	(((uint16_t *)(m1p))[1] == ((uint16_t *)(m2p))[1]) && \
-	(((uint16_t *)(m1p))[2] == ((uint16_t *)(m2p))[2]))
-
-#define ETHHW_VALID_PORT_EXT(port)           (((port) == ETHHW_PORT_0) || ((port) == ETHHW_PORT_1))
-#define ETHHW_VALID_PORT_INT(port)           ((port) == ETHHW_PORT_INT)
-#define ETHHW_VALID_PORT_ALL(port)           ((port) == ETHHW_PORT_ALL)
-#define ETHHW_VALID_PORT(port)               (ETHHW_VALID_PORT_EXT((port)) || ETHHW_VALID_PORT_INT((port)))
-#define ETHHW_VALID_PORT_MIB(port)           (ETHHW_VALID_PORT((port)) || ((port) == ETHHW_PORT_SNAPSHOT))
-#define ETHHW_VALID_PORTMAP(p)               (((p) & ~(ETHHW_PORT_MASK(ETHHW_PORT_0) | ETHHW_PORT_MASK(ETHHW_PORT_1) | ETHHW_PORT_MASK(ETHHW_PORT_INT))) == 0)
-#define ETHHW_VALID_STP_STATE(state)         (((state) >= ETHHW_STP_STATE_DISABLED) && ((state) <= ETHHW_STP_STATE_FORWARDING))
-
-#define ETHHW_VAR_UNINITIALIZED              -1
-
-/* Define result codes to maintain backward compatibility */
-typedef enum {
-	ETHHW_RC_NONE       = 0,
-	ETHHW_RC_PARAM      = -4,
-	ETHHW_RC_FULL       = -6,
-	ETHHW_RC_TIMEOUT    = -9,
-	ETHHW_RC_UNAVAIL    = -16,
-	ETHHW_RC_PORT       = -18
-} ETHHW_RC;
-
-#define ETHHW_RC_SUCCESS(rc)        ((rc) >= 0)
-#define ETHHW_RC_FAILURE(rc)        ((rc) < 0)
-
-int ethHw_Init(void);
-int ethHw_Exit(void);
-
-int ethHw_stpStateSet(int port, ETHHW_STP_STATE state);
-int ethHw_stpStateGet(int port, ETHHW_STP_STATE *statep);
-
-int ethHw_impEnableSet(int enable);
-int ethHw_impEnableGet(int *enablep);
-
-int ethHw_arlEntrySet(char *macp, int vid, int port, int cos,
-			int entryValid, int entryStatic);
-
-int ethHw_miiSet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t data);
-int ethHw_miiGet(int port, ETHHW_MII_FLAGS flags, uint32_t addr, uint32_t *datap);
-
-int ethHw_portLinkStatus(int port);
-int ethHw_portSpeed(int port);
-int ethHw_portLinkStatusChange(int port);
-
-int ethHw_phyPowerdownSet(int port, int enable);
-int ethHw_phyPowerdownGet(int port, int *enablep);
-
-int ethHw_macEnableSet(int port, int tx, int rx);
-int ethHw_macEnableGet(int port, int *txp, int *rxp);
-
-uint64_t ethHw_mibTxOctets(int port);
-uint32_t ethHw_mibTxDropPkts(int port);
-uint32_t ethHw_mibTxQ0Pkt(int port);
-uint32_t ethHw_mibTxBroadcastPkts(int port);
-uint32_t ethHw_mibTxMulticastPkts(int port);
-uint32_t ethHw_mibTxUnicastPkts(int port);
-uint32_t ethHw_mibTxCollisions(int port);
-uint32_t ethHw_mibTxSingleCollision(int port);
-uint32_t ethHw_mibTxMultipleCollision(int port);
-uint32_t ethHw_mibTxDeferredTransmit(int port);
-uint32_t ethHw_mibTxLateCollision(int port);
-uint32_t ethHw_mibTxExcessiveCollision(int port);
-uint32_t ethHw_mibTxFrameInDisc(int port);
-uint32_t ethHw_mibTxPausePkts(int port);
-uint32_t ethHw_mibTxQ1Pkt(int port);
-uint32_t ethHw_mibTxQ2Pkt(int port);
-uint32_t ethHw_mibTxQ3Pkt(int port);
-uint32_t ethHw_mibTxQ4Pkt(int port);
-uint32_t ethHw_mibTxQ5Pkt(int port);
-uint64_t ethHw_mibRxOctets(int port);
-uint32_t ethHw_mibRxUndersizePkts(int port);
-uint32_t ethHw_mibRxPausePkts(int port);
-uint32_t ethHw_mibPkts64Octets(int port);
-uint32_t ethHw_mibPkts65To127Octets(int port);
-uint32_t ethHw_mibPkts128To255Octets(int port);
-uint32_t ethHw_mibPkts256To511Octets(int port);
-uint32_t ethHw_mibPkts512To1023Octets(int port);
-uint32_t ethHw_mibPkts1024ToMaxPktOctets(int port);
-uint32_t ethHw_mibRxOversizePkts(int port);
-uint32_t ethHw_mibRxJabbers(int port);
-uint32_t ethHw_mibRxAlignmentErrors(int port);
-uint32_t ethHw_mibRxFcsErrors(int port);
-uint64_t ethHw_mibRxGoodOctets(int port);
-uint32_t ethHw_mibRxDropPkts(int port);
-uint32_t ethHw_mibRxUnicastPkts(int port);
-uint32_t ethHw_mibRxMulticastPkts(int port);
-uint32_t ethHw_mibRxBroadcastPkts(int port);
-uint32_t ethHw_mibRxSaChanges(int port);
-uint32_t ethHw_mibRxFragments(int port);
-uint32_t ethHw_mibJumboPktCount(int port);
-uint32_t ethHw_mibRxSymbolError(int port);
-uint32_t ethHw_mibInRangeErrorCount(int port);
-uint32_t ethHw_mibOutRangeErrorCount(int port);
-uint32_t ethHw_mibRxDiscard(int port);
-uint32_t ethHw_mibDosAssertCount(int port);
-uint32_t ethHw_mibDosDropCount(int port);
-uint32_t ethHw_mibIngressRateAssertCount(int port);
-uint32_t ethHw_mibIngressRateDropCount(int port);
-uint32_t ethHw_mibEgressRateAssertCount(int port);
-
-#ifdef __cplusplus
- /* end extern "C" */
-}
-#endif
-
-#endif /* _ETHHW_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
deleted file mode 100644
index 074c432..0000000
--- a/arch/arm/mach-bcmring/include/mach/csp/ethHw_reg.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/*****************************************************************************
-* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-/****************************************************************************/
-/**
-*  @file    xxx.h
-*
-*  @brief   short desc
-*
-*  more detail.
-*
-*  @note
-*
-*  This file includes all the register definition for the Ethernet block
-*
-*  Defines are used over structure because of how the registers are mapped
-*  to memory. The registers are not contiguous and are seperated by multiple
-*  of 8. Some of the registers are not defined on a valid word boundary
-*  (for example: an 32-bit word on offset 0x06) but they will be on a correct
-*  word boundary after multiplying by 8. Therefore, if struct was used,
-*  the registers will either be on an invalid word boundary, or the struct
-*  will be expanded by multiple of 8 with a lot of reserved space. Defines
-*  are used as a workaround to avoid numerous reserved register space
-*  In addition, all 64-bit switch registers must be accessed with an atomic
-*  64-bit operation.  Such registers are indicated by
-*  "use_ethHw_get64_or_ethHw_set64_function" in the definitions below.  These
-*  registers should use the ethHw_get64() and ethHw_set64() functions to
-*  write and read to/from the appropriate register.
-*/
-/****************************************************************************/
-
-#ifndef _ETHHW_REG_H
-#define _ETHHW_REG_H
-
-/* ---- Include Files ---------------------------------------------------- */
-#include <mach/csp/mm_io.h>
-
-/* ---- Public Constants and Types --------------------------------------- */
-#define ETHHW_PORT_0         0
-#define ETHHW_PORT_1         1
-#define ETHHW_PORT_INT       8
-
-#define ETHHW_REG_BASE              MM_IO_BASE_ESW
-
-#define ETHHW_REG8(x)               (*((volatile uint8_t *)(x)))
-#define ETHHW_REG16(x)              (*((volatile uint16_t *)(x)))
-#define ETHHW_REG32(x)              (*((volatile uint32_t *)(x)))
-#define ETHHW_REG48(x)              (*((volatile uint64_t *)(x)))
-#define ETHHW_REG64(x)              (*((volatile uint64_t *)(x)))
-
-extern void ethHw_get64(uint32_t addr, uint64_t *datap);
-extern void ethHw_set64_byVal(uint32_t addr, uint64_t data);
-extern void ethHw_set64_byRef(uint32_t addr, uint64_t *datap);
-
-/* A dummy chipc register read is required before any switch register read
- * to ensure the value read back is correct.  Sometimes a 0 is read without
- * the extra dummy read.  A dummy read is only required for read-modify-write
- * or read, but not write.
-*/
-
-static volatile uint32_t dummy;
-#define regDummyRead()   dummy = ETHHW_REG32(MM_IO_PHYS_TO_VIRT(0x80000000))
-
-#define ETHHW_REG_SET(reg, val) (reg) = (val)
-#define ETHHW_REG_GET(reg, val) {regDummyRead(); \
-				(val) = (reg); \
-				}
-#define ETHHW_REG_GET_VAL(reg)    (regDummyRead(), (reg))
-
-#define ETHHW_REG_MASK_SET(reg, mask)   ETHHW_REG_SET((reg), ETHHW_REG_GET_VAL((reg)) | (mask))
-#define ETHHW_REG_MASK_CLR(reg, mask)   ETHHW_REG_SET((reg), ETHHW_REG_GET_VAL((reg)) & ~(mask))
-
-#define ethHw_reg_get64(addr, datap) do { \
-					regDummyRead(); \
-					ethHw_get64(addr, datap); \
-					} while (0);
-
-#define ethHw_reg_mask_set64(addr, mask)  do { \
-						uint64_t data; \
-						ethHw_reg_get64(addr, &data); \
-						(data) |= (mask); \
-						ethHw_reg_set64(addr, data); \
-					} while (0);
-
-#define ethHw_reg_mask_clr64(addr, mask)  do { \
-						uint64_t data; \
-						ethHw_reg_get64(addr, &data); \
-						(data) &= ~(mask); \
-						ethHw_reg_set64(addr, data); \
-					} while (0);
-
-#if 1
-/* Use byRef since the compiler builds images differently for different targets
- * For example, in the byVal code:
- *    -csptest image uses:
- *       -r0 for the addr argument
- *       -r1 and r2 for the data argument
- *    -Linux image uses:
- *       -r0 for the addr argument
- *       -r2 and r3 for the data argument
- * In the byRef code:
- *    -Both csptest and Linux images use:
- *       -r0 for the addr argument
- *       -r1 for the datap argument
- */
-/* TODO: Figure out why the same toolchain uses different calling convention
- *       when building certain targets (possibly due to 64-bit data type)
- */
-#define ethHw_reg_set64(a, d)      ethHw_set64_byRef((a), &(d))
-#else
-#define ethHw_reg_set64           ethHw_set64_byVal
-#endif
-
-#define ETHHW_REG_GET64(addr, datap)       ethHw_reg_get64(addr, datap)
-#define ETHHW_REG_SET64(addr, data)        ethHw_reg_set64(addr, data)
-#define ETHHW_REG_SET64_BYVAL(addr, data)  ethHw_set64_byVal(addr, data)
-#define ETHHW_REG_SET64_BYREF(addr, datap) ethHw_set64_byRef(addr, datap)
-#define ETHHW_REG_MASK_SET64(addr, mask)   ethHw_reg_mask_set64(addr, mask)
-#define ETHHW_REG_MASK_CLR64(addr, mask)   ethHw_reg_mask_clr64(addr, mask)
-
-#define ETHHW_REG_PAGEADDR(p, a)           (ETHHW_REG_BASE | (((uint8_t)(p) << 8) + (uint8_t)(a)) * 8)
-
-#define ETHHW_REG_PAGE_CTRL               0x00
-#define ETHHW_REG_PAGE_STATUS             0x01
-#define ETHHW_REG_PAGE_MGMT               0x02
-#define ETHHW_REG_PAGE_ARL                0x05
-#define ETHHW_REG_PAGE_MII(port)          (0x10+(port))
-#define ETHHW_REG_PAGE_MIB(port)          (0x20+(port))
-#define ETHHW_REG_PAGE_MII_EXT(port)      (0x80+(port))
-
-
-/* Page 00h, Control Register */
-#define ethHw_regCtrlPortCtrl(port)                      ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, (port)))
-#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_ENUM_OFFSET 1
-#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT       5
-#define ETHHW_REG_CTRL_PORTCTRL_STP_STATE_MASK        (7 << ETHHW_REG_CTRL_PORTCTRL_STP_STATE_SHIFT)
-#define ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE        0x002
-#define ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE        0x001
-#define ETHHW_REG_CTRL_PORTCTRL_MAC_DISABLE           (ETHHW_REG_CTRL_PORTCTRL_MAC_TX_DISABLE|ETHHW_REG_CTRL_PORTCTRL_MAC_RX_DISABLE)
-
-#define ethHw_regCtrlImpCtrl                             ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, 0x08))
-#define ETHHW_REG_CTRL_IMPCTRL_RX_UCAST_EN            0x10
-#define ETHHW_REG_CTRL_IMPCTRL_RX_MCAST_EN            0x08
-#define ETHHW_REG_CTRL_IMPCTRL_RX_BCAST_EN            0x04
-
-#define ethHw_regCtrlSwitchMode                          ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_CTRL, 0x0B))
-#define ETHHW_REG_CTRL_SW_FWDG_EN                     0x02
-#define ETHHW_REG_CTRL_SW_FWDG_MODE                   0x01
-
-
-/* Page 01h, Status Register */
-#define ethHw_regStatusLinkStatus                        ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x00))
-#define ethHw_regStatusLinkStatusChange                  ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x02))
-#define ethHw_regStatusPortSpeed                         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_STATUS, 0x04))
-#define ETHHW_REG_STATUS_PORT_SPEED_MASK              0x3
-#define ETHHW_REG_STATUS_PORT_SPEED_10MB              0x0
-#define ETHHW_REG_STATUS_PORT_SPEED_100MB             0x1
-#define ETHHW_REG_STATUS_PORT_SPEED_1000MB            0x2
-#define ETHHW_REG_STATUS_PORT_SPEED_SHIFT(port)       (2*(port))
-
-
-/* Page 02h, Management Mode Register */
-#define ethHw_regMgmtGblMgmtCtrl                         ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MGMT, 0x00))
-#define ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_MASK      0xC0
-#define ETHHW_REG_MGMT_GBLMGMTCTRL_IMP_MODE_EN        0x80
-#define ETHHW_REG_MGMT_GBLMGMTCTRL_RX_BPDU_EN         0x02
-
-
-/* Page 05h, ARL Access Register */
-#define ethHw_regArlRwCtrl                               ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x00))
-#define ETHHW_REG_ARL_RWCTRL_START_DONE               0x80
-#define ETHHW_REG_ARL_RWCTRL_READ                     0x01
-#define ETHHW_REG_ARL_RWCTRL_WRITE                    0x00
-#define ETHHW_REG_ARL_MAC_INDEX                          ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x02)
-#define ethHw_regArlMacIndex                             use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG48(ETHHW_REG_ARL_MAC_INDEX) */
-#define ethHw_regArlVlanIndex                            ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x08))
-#define ETHHW_REG_ARL_MAC_VID_ENTRY(x)                   ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x10 + ((x)*0x10)))
-#define ethHw_regArlMacVidEntry(x)                       use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG64(ETHHW_REG_ARL_MAC_VID_ENTRY((x))) */
-#define ethHw_regArlFwdEntry(x)                          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x18 + ((x)*0x10))))
-#define ETHHW_REG_ARL_FWDENTRY_VALID                  0x00010000
-#define ETHHW_REG_ARL_FWDENTRY_STATIC                 0x00008000
-#define ETHHW_REG_ARL_FWDENTRY_AGE                    0x00004000
-#define ETHHW_REG_ARL_FWDENTRY_TC_SHIFT               11
-#define ethHw_regArlSearchCtrl                           ETHHW_REG8(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x50))
-#define ethHw_regArlSearchAddr                           ETHHW_REG16(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x51))
-#define ETHHW_REG_ARL_SEARCH_MAC_VID(x)                  ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x60 + ((x)*0x10)))
-#define ethHw_regArlSearchMacVid(x)                      use_ethHw_get64_or_ethHw_set64_function /*ETHHW_REG64(ETHHW_REG_ARL_SEARCH_MAC_VID((x)) */
-#define ethHw_regArlSearchResult(x)                      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, (0x68 + ((x)*0x10))))
-
-/* #define ETHHW_REG_ARL_MAC_VID_ENTRY0                     ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x10) */
-/* #define ethHw_regArlMacVidEntry0                         use_ethHw_get64_or_ethHw_set64_function ETHHW_REG64(ETHHW_REG_ARL_MAC_VID_ENTRY0) */
-/* #define ethHw_regArlFwdEntry0                            ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_ARL, 0x18)) */
-
-#define ETHHW_REG_ARL_TIMEOUT                            100
-#define ETHHW_REG_ARL_ENTRY_MIN                          0
-#define ETHHW_REG_ARL_ENTRY_MAX                          3
-
-/* Page 10h-11h, MII Register */
-#define ethHw_regMdioAddr                                ETHHW_REG32(MM_IO_BASE_ESW + 0x000A0008)
-#define ethHw_regMdioWriteData                           ETHHW_REG32(MM_IO_BASE_ESW + 0x000A0010)
-#define ethHw_regMdioReadData                            ETHHW_REG32(MM_IO_BASE_ESW + 0x000A0018)
-#define ethHw_regMdioStatus                              ETHHW_REG32(MM_IO_BASE_ESW + 0x000A0020)
-#define ETHHW_REG_MDIO_SERDES_MASK                    0x00000010
-#define ETHHW_REG_MDIO_DONE_MASK                      0x00000008
-#define ETHHW_REG_MDIO_EXTRA_MASK                     0x00000004
-#define ETHHW_REG_MDIO_READ_MASK                      0x00000002
-#define ETHHW_REG_MDIO_WRITE_MASK                     0x00000001
-
-#define ETHHW_REG_MII_TIMEOUT                            10000
-
-
-/* Use physical address when specifying MDIO address */
-#define ETHHW_REG_MII_EXT(port, offset)                   ((ETHHW_REG_PAGE_MII_EXT((port)) << 8) | (uint8_t)(offset))
-#define ETHHW_REG_MII_GPHY(port, offset)                  ((ETHHW_REG_PAGE_MII((port)) << 8) | (uint8_t)(offset))
-
-#if defined(CFG_GLOBAL_CHIP) && (CFG_GLOBAL_CHIP == FPGA11107)
-#define ETHHW_REG_MII                                    ETHHW_REG_MII_EXT
-#else
-#define ETHHW_REG_MII                                    ETHHW_REG_MII_GPHY
-#endif
-
-
-/* Page 20h, Port MIB Register */
-#define ETHHW_REG_MIB_TX_OCTETS(port)                    ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x00)
-#define ETHHW_REG_MIB_TxOctets                           ETHHW_REG_MIB_TX_OCTETS
-#define ethHw_regMibTxDropPkts(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x08))
-#define ethHw_regMibTxQ0Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x0C))
-#define ethHw_regMibTxBroadcastPkts(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x10))
-#define ethHw_regMibTxMulticastPkts(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x14))
-#define ethHw_regMibTxUnicastPkts(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x18))
-#define ethHw_regMibTxCollisions(port)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x1C))
-#define ethHw_regMibTxSingleCollision(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x20))
-#define ethHw_regMibTxMultipleCollision(port)            ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x24))
-#define ethHw_regMibTxDeferredTransmit(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x28))
-#define ethHw_regMibTxLateCollision(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x2C))
-#define ethHw_regMibTxExcessiveCollision(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x30))
-#define ethHw_regMibTxFrameInDisc(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x34))
-#define ethHw_regMibTxPausePkts(port)                    ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x38))
-#define ethHw_regMibTxQ1Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x3C))
-#define ethHw_regMibTxQ2Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x40))
-#define ethHw_regMibTxQ3Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x44))
-#define ethHw_regMibTxQ4Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x48))
-#define ethHw_regMibTxQ5Pkt(port)                        ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x4C))
-#define ETHHW_REG_MIB_RX_OCTETS(port)                    ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x50)
-#define ETHHW_REG_MIB_RxOctets                           ETHHW_REG_MIB_RX_OCTETS
-#define ethHw_regMibRxUndersizePkts(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x58))
-#define ethHw_regMibRxPausePkts(port)                    ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x5C))
-#define ethHw_regMibPkts64Octets(port)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x60))
-#define ethHw_regMibPkts65To127Octets(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x64))
-#define ethHw_regMibPkts128To255Octets(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x68))
-#define ethHw_regMibPkts256To511Octets(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x6C))
-#define ethHw_regMibPkts512To1023Octets(port)            ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x70))
-#define ethHw_regMibPkts1024ToMaxPktOctets(port)         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x74))
-#define ethHw_regMibRxOversizePkts(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x78))
-#define ethHw_regMibRxJabbers(port)                      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x7C))
-#define ethHw_regMibRxAlignmentErrors(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x80))
-#define ethHw_regMibRxFcsErrors(port)                    ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x84))
-#define ETHHW_REG_MIB_RX_GOOD_OCTETS(port)               ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x88)
-#define ETHHW_REG_MIB_RxGoodOctets                       ETHHW_REG_MIB_RX_GOOD_OCTETS
-#define ethHw_regMibRxDropPkts(port)                     ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x90))
-#define ethHw_regMibRxUnicastPkts(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x94))
-#define ethHw_regMibRxMulticastPkts(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x98))
-#define ethHw_regMibRxBroadcastPkts(port)                ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0x9C))
-#define ethHw_regMibRxSaChanges(port)                    ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA0))
-#define ethHw_regMibRxFragments(port)                    ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA4))
-#define ethHw_regMibJumboPktCount(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xA8))
-#define ethHw_regMibRxSymbolError(port)                  ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xAC))
-#define ethHw_regMibInRangeErrorCount(port)              ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xB0))
-#define ethHw_regMibOutRangeErrorCount(port)             ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xB4))
-#define ethHw_regMibRxDiscard(port)                      ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC0))
-#define ethHw_regMibDosAssertCount(port)                 ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC4))
-#define ethHw_regMibDosDropCount(port)                   ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xC8))
-#define ethHw_regMibIngressRateAssertCount(port)         ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xCC))
-#define ethHw_regMibIngressRateDropCount(port)           ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xD0))
-#define ethHw_regMibEgressRateAssertCount(port)          ETHHW_REG32(ETHHW_REG_PAGEADDR(ETHHW_REG_PAGE_MIB(port), 0xD4))
-
-
-/* Switch interface register definitions */
-#define ethHw_regImpPhyMisc                              ETHHW_REG32(ETHHW_REG_BASE | 0xa0000)
-#define ETHHW_REG_IMP_PHY_MISC_POWERDOWN(port)        ((0x5 << (13 + (port))) & 0x0001e000)
-#define ETHHW_REG_IMP_PHY_MISC_READY                  0x00800000
-#define ETHHW_REG_READY_TIMEOUT                       100
-
-
-#endif /* _ETHHW_REG_H */
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index a4b42d0..2b4bbc4 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2313,13 +2313,6 @@ config ATL1E
 	  To compile this driver as a module, choose M here.  The module
 	  will be called atl1e.
 
-config NET_BCMRING
-	tristate "Broadcom BCMRING Ethernet support"
-	depends on NET_ETHERNET && ARCH_BCMRING
-	help
-		Say Y to enable ethernet support on the BCMRING platforms.
-		Otherwise, say N.
-
 endif # NETDEV_1000
 
 #
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 1e56d8a..0818ce2 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -68,7 +68,6 @@ obj-$(CONFIG_TIGON3) += tg3.o
 obj-$(CONFIG_BNX2) += bnx2.o
 obj-$(CONFIG_BNX2X) += bnx2x.o
 bnx2x-objs := bnx2x_main.o bnx2x_link.o
-obj-$(CONFIG_NET_BCMRING) += bcmring_net.o bcmring_ethDma.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
 obj-$(CONFIG_GELIC_NET) += ps3_gelic.o
diff --git a/drivers/net/bcmring_ethDma.c b/drivers/net/bcmring_ethDma.c
deleted file mode 100644
index aa480fd..0000000
--- a/drivers/net/bcmring_ethDma.c
+++ /dev/null
@@ -1,228 +0,0 @@
-/*****************************************************************************
-* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-
-#include <linux/types.h>
-#include <linux/module.h>
-#include "bcmring_ethDma.h"
-
-#if 0
-int ethVerbose;
-
-#include <linux/kernel.h>
-#define SET8(a, b)	do { REG8((a)) = (b);  if (ethVerbose) printk("REG8(0x%08x)  = 0x%02x;\n", (a), (b)) } while (0);
-#define SET32(a, b)	do { REG32((a)) = (b); if (ethVerbose) printk("REG32(0x%08x) = 0x%08x;\n", (a), (b)) } while (0);
-#else
-#define SET8(a, b)	REG8((a)) = (b)
-#define SET32(a, b)	REG32((a)) = (b)
-#endif
-
-int dmaTxConfig(int burst)
-{
-	uint8_t reg8;
-
-	reg8 = REG8(0x3041a030);
-	SET8(0x3041a030, reg8 | 0x01);
-	if (REG32(0x80000000) == 0x11070a00) {
-		SET32(0x30490000, 0x90000001 | (burst << 1));
-	} else {
-		/*
-		 * Non-A0 silicon requires the burst size in the bus i/f to be one
-		 * greater than the DMA burst length
-		 */
-		SET32(0x30490000, 0x90000001 | ((burst + 1) << 1));
-	}
-
-	return 1;
-}
-
-
-int dmaRxConfig(int burst, int block)
-{
-	SET32(0x30480008, 0x90000000 | (burst << 1) | (block << 10));
-
-	return 1;
-}
-
-
-int dmaInit(int controller)
-{
-	register uint32_t controllerOffset;
-
-	controllerOffset = controller * 0x00100000;
-
-	SET32(0x30200398 + controllerOffset, 0x00000001);
-	SET32(0x3020039c + controllerOffset, 0x00000000);
-
-	return 1;
-}
-
-
-#if 1
-int dmaConfig(int controller, int ch,
-		uint32_t ctlHi, uint32_t ctlLo,
-		uint32_t cfgHi, uint32_t cfgLo,
-		uint32_t sstat, uint32_t dstat)
-{
-	register uint32_t controllerOffset;
-	register uint32_t chOffset;
-
-	controllerOffset = controller * 0x00100000;
-	chOffset = ch * 0x58;
-
-	SET32(0x30200018 + controllerOffset + chOffset, ctlLo);
-	SET32(0x3020001c + controllerOffset + chOffset, ctlHi);
-	SET32(0x30200040 + controllerOffset + chOffset, cfgLo);
-	SET32(0x30200044 + controllerOffset + chOffset, cfgHi);
-	SET32(0x30200030 + controllerOffset + chOffset, sstat);
-	SET32(0x30200034 + controllerOffset + chOffset, 0x00000000);
-	SET32(0x30200038 + controllerOffset + chOffset, dstat);
-	SET32(0x3020003c + controllerOffset + chOffset, 0x00000000);
-
-	return 1;
-}
-#else
-int dmaConfig(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t chOffset;
-
-	controllerOffset = controller * 0x00100000;
-	chOffset = ch * 0x58;
-
-	SET32(0x30200018 + controllerOffset + chOffset, 0x18901036);
-	SET32(0x3020001c + controllerOffset + chOffset, 0x00000000);
-	SET32(0x30200040 + controllerOffset + chOffset, 0x000000e0);
-	SET32(0x30200044 + controllerOffset + chOffset, 0x00000826);
-	SET32(0x30200038 + controllerOffset + chOffset, 0x30490010);
-	SET32(0x3020003c + controllerOffset + chOffset, 0x00000000);
-
-	return 1;
-}
-#endif
-
-
-int dmaIrqClear(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	mask = 0x0001 << ch;
-
-/*
- *	SET32(0x30200338 + controllerOffset, mask);		// IntTfr
- *	SET32(0x3020033c + controllerOffset, 0x00000000);
- *	SET32(0x30200340 + controllerOffset, mask);		// IntBlock
- *	SET32(0x30200344 + controllerOffset, 0x00000000);
- *	SET32(0x30200348 + controllerOffset, mask);		// IntSrcTran
- *	SET32(0x3020034c + controllerOffset, 0x00000000);
- */
-	SET32(0x30200350 + controllerOffset, mask);		/* IntDstTran */
-/*	SET32(0x30200354 + controllerOffset, 0x00000000); */
-	SET32(0x30200358 + controllerOffset, mask);		/* IntErr */
-/*	SET32(0x3020035c + controllerOffset, 0x00000000); */
-
-	return 1;
-}
-
-
-int dmaEnable(int controller, int ch, void *descp)
-{
-	register uint32_t controllerOffset;
-	register uint32_t chOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	chOffset = ch * 0x58;
-	mask = 0x0101 << ch;
-
-	SET32(0x30200010 + controllerOffset + chOffset, (uint32_t)(descp));
-	SET32(0x302003a0 + controllerOffset, mask);
-	SET32(0x302003a4 + controllerOffset, 0x00000000);
-
-	return 1;
-}
-
-
-int dmaDisable(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	mask = 0x0100 << ch;
-
-	SET32(0x302003a0 + controllerOffset, mask);
-	SET32(0x302003a4 + controllerOffset, 0x00000000);
-
-	return 1;
-}
-
-
-int dmaIrqEnable(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	mask = 0x0101 << ch;
-
-	SET32(0x30200328 + controllerOffset, mask);  /* IntDstTran */
-	SET32(0x3020032c + controllerOffset, 0x00000000);
-
-	return 1;
-}
-
-
-int dmaIrqDisable(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	mask = 0x0100 << ch;
-
-	SET32(0x30200328 + controllerOffset, mask);  /* IntDstTran */
-	SET32(0x3020032c + controllerOffset, 0x00000000);
-
-	return 1;
-}
-
-
-int dmaIsBusy(int controller, int ch)
-{
-	register uint32_t controllerOffset;
-	register uint32_t chOffset;
-	register uint32_t mask;
-
-	controllerOffset = controller * 0x00100000;
-	chOffset = ch * 0x58;
-	mask = 0x0001 << ch;
-
-	/* Enable bit can be polled to determine if DMA channel is busy */
-
-	return REG32(0x302003a0 + controllerOffset + chOffset) & mask;
-}
-
-EXPORT_SYMBOL(dmaTxConfig);
-EXPORT_SYMBOL(dmaRxConfig);
-EXPORT_SYMBOL(dmaInit);
-EXPORT_SYMBOL(dmaConfig);
-EXPORT_SYMBOL(dmaIrqClear);
-EXPORT_SYMBOL(dmaEnable);
-EXPORT_SYMBOL(dmaDisable);
-EXPORT_SYMBOL(dmaIrqEnable);
-EXPORT_SYMBOL(dmaIrqDisable);
-EXPORT_SYMBOL(dmaIsBusy);
diff --git a/drivers/net/bcmring_ethDma.h b/drivers/net/bcmring_ethDma.h
deleted file mode 100644
index cac03cd..0000000
--- a/drivers/net/bcmring_ethDma.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/*****************************************************************************
-* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-
-#ifndef _BCMRING_ETHDMA_H
-#define _BCMRING_ETHDMA_H
-
-#include <linux/types.h>
-#include <mach/csp/mm_io.h>
-
-#define CFG_EOP_MASK		0x00010000
-#define CFG_OFFSET(bp, len)	((CFG_OFFSET_LAST((bp), (len)) << 8) | \
-				(CFG_OFFSET_INIT((bp))))
-#define CFG_OFFSET_INIT(bp)	((uint32_t)(bp) % 8)
-#define CFG_OFFSET_LAST(bp, len)  ((((uint32_t)(bp) + (len)) - 1) % 8)
-/* #define CFG_OFFSET_LAST(bp, len)  (8-((((uint32_t)(bp) + (len)) - 1) % 8)) */
-
-#define DMA_MTP_TRANSACTION_SIZE(bp, len)  ((CFG_OFFSET_INIT((bp)) + (len) + 7) / 8)
-
-#define DMA_MTP_FIFO_ADDR_CFG	0x30490008
-#define DMA_MTP_FIFO_ADDR_DATA	0x30498000
-
-#define DMA_MTP_CTL_LO		0x18901036	/* See data sheet for bit details */
-#define DMA_MTP_CTL_HI		0x00000000
-#define DMA_MTP_CFG_LO		0x000000e0
-#define DMA_MTP_CFG_HI		0x00000826
-#define DMA_MTP_DSTAT		0x30490010
-
-#define DMA_PTM_FIFO_ADDR	0x30488000
-
-#define DMA_PTM_CTL_LO		0x1a408036	/* See data sheet for bit details */
-#define DMA_PTM_CTL_HI		0x00000000
-#define DMA_PTM_CFG_LO		0x000000e0
-#define DMA_PTM_CFG_HI		0x00000046
-#define DMA_PTM_SSTAT		0x30480010
-
-
-#define DMA_DESC_CREATE(descp, _sar, _dar, handlep, _ctlLo, _ctlHi) \
-do { \
-	(descp)->sar = (uint32_t)(_sar); \
-	(descp)->dar = (uint32_t)(_dar); \
-	(descp)->lli = (uint32_t)((handlep) + 1); \
-	(descp)->ctlLo = (_ctlLo); \
-	(descp)->ctlHi = (_ctlHi); \
-	(descp)->stat1 = 0; \
-	(descp)->stat2 = 0; \
-	(descp)->rsvd = 0; \
-} while (0);
-
-#define DMA_DESC_CREATE_NEXT(descp, _sar, _dar, _lli, _ctlLo, _ctlHi) \
-do { \
-	(descp)->sar = (uint32_t)(_sar); \
-	(descp)->dar = (uint32_t)(_dar); \
-	(descp)->lli = (uint32_t)(_lli); \
-	(descp)->ctlLo = (_ctlLo); \
-	(descp)->ctlHi = (_ctlHi); \
-	(descp)->stat1 = 0; \
-	(descp)->stat2 = 0; \
-	(descp)->rsvd = 0; \
-} while (0);
-
-#define DMA_DESC_RX_UPDATE(descp, _dar, _ctlHi) \
-do { \
-	(descp)->dar = (uint32_t)(_dar); \
-	(descp)->ctlHi = (_ctlHi); \
-	(descp)->stat1 = 0; \
-} while (0);
-
-
-typedef struct {
-	uint32_t sar;
-	uint32_t dar;
-	uint32_t lli;
-	uint32_t ctlLo;
-	uint32_t ctlHi;
-	uint32_t stat1;
-	uint32_t stat2;
-	uint32_t rsvd;	/* To create buffers on 64-bit alignment */
-} DMA_DESC;
-
-/* Force to 64-bit alignment */
-#define DMA_ALIGN	__attribute__((aligned(16)))
-
-/* DMA setup extracted from sim environment. */
-
-#ifndef REG32
-#define REG32(x)	(*((uint32_t *)MM_IO_PHYS_TO_VIRT((x))))
-#endif
-
-#ifndef REG8
-#define REG8(x)		(*((uint8_t *)MM_IO_PHYS_TO_VIRT((x))))
-#endif
-
-
-extern int dmaTxConfig(int burst);
-extern int dmaRxConfig(int burst, int block);
-extern int dmaInit(int controller);
-#if 1
-int dmaConfig(int controller, int ch,
-		uint32_t ctlHi, uint32_t ctlLo,
-		uint32_t cfgHi, uint32_t cfgLo,
-		uint32_t sstat, uint32_t dstat);
-#else
-extern int dmaConfig(int controller, int ch);
-#endif
-extern int dmaIrqClear(int controller, int ch);
-extern int dmaEnable(int controller, int ch, void *descp);
-extern int dmaDisable(int controller, int ch);
-extern int dmaIrqEnable(int controller, int ch);
-extern int dmaIrqDisable(int controller, int ch);
-extern int dmaIsBusy(int controller, int ch);
-
-#endif
diff --git a/drivers/net/bcmring_net.c b/drivers/net/bcmring_net.c
deleted file mode 100644
index f090acd..0000000
--- a/drivers/net/bcmring_net.c
+++ /dev/null
@@ -1,2325 +0,0 @@
-/*****************************************************************************
-* Copyright 2006 - 2008 Broadcom Corporation.  All rights reserved.
-*
-* Unless you and Broadcom execute a separate written software license
-* agreement governing use of this software, this software is licensed to you
-* under the terms of the GNU General Public License version 2, available at
-* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
-*
-* Notwithstanding the above, under no circumstances may you combine this
-* software in any way with any other Broadcom software provided under a
-* license other than the GPL, without Broadcom's express prior written
-* consent.
-*****************************************************************************/
-
-#include <mach/csp/chipcHw_inline.h>
-#include <mach/csp/cap.h>
-#include <csp/ethHw.h>
-#include <cfg_global.h>
-
-/*--------------------------------------------------------------------------*/
-/* Driver configuration (compile-time)
-*/
-#define USE_WORKQUEUE            0
-#define USE_DEFAULT_WORKQUEUE    0
-
-#define WORKQUEUE_DEBUG          0
-#if WORKQUEUE_DEBUG
-#include <linux/broadcom/knllog.h>
-#define WQ_KNLLOG(fmt, args...) KNLLOG(fmt, ## args)
-#else
-#define WQ_KNLLOG(fmt, args...)
-#endif
-
-#define CTL_BCM_ETH                    205
-#define BRCM_HDR_LEN       4	/*
-				 * TODO: Move to chip file */
-/* #define BRCM_HDR_LEN       0               * Disable use of Broadcom header */
-/* #define BRCM_HDR_LEN       0               */
-
-/* #define DMA_RX_DESC_NUM    128 */
-#define DMA_RX_DESC_NUM    64
-#define DMA_RX_BUF_LEN     2048	/* 802.3as defines the max packet
-				 *  size to be 2000bytes and is
-				 *  rounded here to a nice boundary
-				 */
-
-/* At least 2*350 Tx descriptors are required (determined empirically) to
-*  sustain ping attack.  Normally, DoS will be enabled, but this will handle
-*  the worst possible case.
-*/
-#define DMA_TX_DESC_NUM    (16 * DMA_RX_DESC_NUM)
-
-#define INT_PORT_STATS     1
-
-#define DUAL_MAC           0
-
-#define DEBUG_STATS        1
-
-#define BRCM_PHY           0
-
-#define DEBUG              0
-#if DEBUG
-#define MARKER             "------->"
-#endif
-
-#define MSG_LEVEL_SUPPORT  1
-
-#define BCM_NET_MODULE_DESCRIPTION     "Broadcom BCMRING network driver"
-#define BCM_NET_MODULE_VERSION         "0.2.0"
-
-#include <linux/module.h>
-
-#include <linux/version.h>
-
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/mii.h>
-#if USE_WORKQUEUE
-#include <linux/workqueue.h>
-#endif
-#include <linux/dma-mapping.h>
-#include <linux/proc_fs.h>
-
-#include <linux/kfifo.h>
-#include <linux/sysctl.h>
-/* #include <linux/broadcom/bcm_sysctl.h> */
-
-#include <csp/dmacHw.h>
-#include <csp/intcHw.h>
-#include <mach/irqs.h>
-#include <mach/dma.h>
-#include <asm/dma.h>
-
-#include "bcmring_ethDma.h"
-
-#if BRCM_PHY
-#include "bcm_mii.h"
-#endif
-
-static const __devinitconst char banner[] =
-    KERN_INFO BCM_NET_MODULE_DESCRIPTION " " BCM_NET_MODULE_VERSION "\n";
-
-/*
- *--------------------------------------------------------------------------
- * ethl shim functions
- */
-
-#define ETHL_INLINE     inline
-
-#undef REG32
-#undef REG8
-#define REG64(x)        (*((unsigned long long *)MM_IO_PHYS_TO_VIRT((x))))
-#define REG32(x)        (*((uint32_t *)MM_IO_PHYS_TO_VIRT((x))))
-#define REG16(x)        (*((uint16_t *)MM_IO_PHYS_TO_VIRT((x))))
-#define REG8(x)         (*((uint8_t *)MM_IO_PHYS_TO_VIRT((x))))
-
-#define ETH_REG_BASE       0x30400000
-
-/*
- * "offset" is a 16-bit value, formatted as 0xPPAA, where PP is the page and
- * AA is the address within the page
- */
-#define ETH_REG64(offset)  REG64(ETH_REG_BASE + (offset))
-#define ETH_REG32(offset)  REG32(ETH_REG_BASE + (offset))
-#define ETH_REG16(offset)  REG16(ETH_REG_BASE + (offset))
-#define ETH_REG8(offset)   REG8(ETH_REG_BASE + (offset))
-
-/* The MII begins at page 0x10.  The address is a 16-bit address */
-#define MII_OFFSET(port, addr)    ((0x1000 + ((port) << 8)) | ((addr) << 1))
-
-/* #define TXCFG_SIZE               ((sizeof(uint64_t) + sizeof(struct sk_buff *)) */
-#define TXCFG_SIZE               16
-#define TXCFG_BUF(bp, i)          (uint64_t *)((char *)(bp) + (TXCFG_SIZE * (i)))
-#define TXCFG_BUF_SIZE           (TXCFG_SIZE * DMA_TX_DESC_NUM)
-
-#define CFG_EOP_MASK             0x00010000
-#define CFG_OFFSET(bp, len)	((CFG_OFFSET_LAST((bp), (len)) << 8) | \
-				(CFG_OFFSET_INIT((bp))))
-#define CFG_OFFSET_INIT(bp)      ((uint32_t)(bp) % 8)
-#define CFG_OFFSET_LAST(bp, len)  ((((uint32_t)(bp) + (len)) - 1) % 8)
-
-#define RX_DESC(bp, i)            (DMA_DESC *)((char *)(bp) + ((i) * sizeof(DMA_DESC)))
-#define TX_DESC                  RX_DESC
-
-static int ethDelayTx;
-volatile int ethThreshTx;
-static int ethStatusVerbose;
-
-static int ethStatusPoll = 1000;
-static int ethStatusLAN;
-static struct workqueue_struct *ethStatusWorkQueuep;
-
-static void ethStatusWork(struct work_struct *unused);
-DECLARE_DELAYED_WORK(ethStatusTask, ethStatusWork);
-static struct net_device *localDevp;	/* TODO: Needed for ethStatusWork, but need to supply argument at run-time */
-
-typedef void ETHL_DRV;
-
-static ETHL_INLINE int ethlInit(ETHL_DRV *drvp)
-{
-	int rc;
-
-	(void)drvp;
-
-	/*
-	 * Put switch registers in non-secure mode
-	 * TODO:  This should be controlled by some secure process
-	 */
-	REG32(0x80008004) |= 0x00000200;
-
-	rc = ethHw_Init();
-	printk(KERN_INFO "Ethernet initialization %s (rc=%i)\n",
-	       ETHHW_RC_SUCCESS(rc) ? "successful" : "failed", rc);
-
-#if BRCM_HDR_LEN == 0
-	/*
-	 * Don't use Broadcom header
-	 * For basic switch usage, this is fine.  However, if external port
-	 * control/status is required (ie egress direction or ingress port status),
-	 * the Broadcom header must be used to embed this info.
-	 */
-	REG8(0x30401018) = 0x00;
-#endif
-
-#if defined(CFG_GLOBAL_ETH_STP_SUPPORT) && CFG_GLOBAL_ETH_STP_SUPPORT
-	/* Application is responsible for building up spanning tree */
-#else
-	/* STP not used so put external ports in forwarding state */
-	ethHw_stpStateSet(ETHHW_PORT_0, ETHHW_STP_STATE_FORWARDING);
-	ethHw_stpStateSet(ETHHW_PORT_1, ETHHW_STP_STATE_FORWARDING);
-#endif
-
-	/* set default throttle level for internal speed mismatch based on silicon version */
-	if (chipcHw_getChipId() == 0x11070a00) {
-		/*
-		 * A0 silicon
-		 * TODO: Suggested value is ethThreshTx=1.  Performance to be verified
-		 */
-		ethThreshTx = 0;
-	} else {
-		/* B0 silicon.  No fix is required for now. */
-		ethThreshTx = 0;
-	}
-
-	return 1;
-}
-
-static ETHL_INLINE int ethlRxOffset(ETHL_DRV *drvp)
-{
-	(void)drvp;
-
-	return BRCM_HDR_LEN;
-}
-
-static ETHL_INLINE int ethlExtPhyEnable(ETHL_DRV *drvp, int enable)
-{
-	(void)drvp;
-
-	/* TODO: Need registers for enabling the SGMII i/f (PHY addr, etc) */
-	return 1;
-}
-
-static ETHL_INLINE int ethlMiiGet(ETHL_DRV *drvp, int port, int addr)
-{
-	uint32_t val;
-
-	(void)drvp;
-
-	ethHw_miiGet(port, 0, (uint32_t) addr, &val);
-
-	return val;
-}
-
-static ETHL_INLINE int ethlMiiSet(ETHL_DRV *drvp, int port, int addr, int data)
-{
-	uint32_t val;
-
-	(void)drvp;
-
-	ethHw_miiSet(port, 0, (uint32_t) addr, (uint32_t) data);
-	ethHw_miiGet(port, 0, (uint32_t) addr, &val);
-
-	return val;
-}
-
-static ETHL_INLINE int ethlTxFrameFormat(ETHL_DRV *drvp, char **bufpp,
-					 int *lenp, int portMask)
-{
-#if BRCM_HDR_LEN == 0
-	(void)drvp;
-	(void)bufpp;
-	(void)lenp;
-	(void)portMask;
-
-	/* Do nothing since the Broadcom header is not required */
-#else
-	char *srcp;
-	char *dstp;
-	uint32_t *tagp;
-	register int i;
-
-	(void)drvp;
-
-	srcp = *bufpp;
-	dstp = srcp - BRCM_HDR_LEN;
-
-	/* Move DA and SA */
-	for (i = 0; i < 12; i++) {
-		*dstp++ = *srcp++;
-	}
-
-	tagp = (uint32_t *) dstp;
-
-	/* Set Broadcom tag */
-	if (portMask >= 0) {
-		*tagp = (portMask << 24) | 0x20;	/* Assumes little endian */
-	} else {
-		*tagp = 0x00000000;
-	}
-
-	/* Update length to include Broadcom header and FCS */
-	*lenp += (BRCM_HDR_LEN + sizeof(uint32_t));
-
-	/* Update start of buffer */
-	*bufpp -= BRCM_HDR_LEN;
-#endif
-
-	return 1;
-}
-
-static ETHL_INLINE int ethlRxFrameFormat(ETHL_DRV *drvp, char **bufpp,
-					 int *lenp, int *portp)
-{
-#if BRCM_HDR_LEN == 0
-	(void)drvp;
-	(void)bufpp;
-	(void)lenp;
-	(void)port;
-
-	/* Do nothing since the Broadcom header is not required */
-#else
-	char *srcp;
-	char *dstp;
-	uint32_t tag;
-	register int i;
-
-	(void)drvp;
-
-	srcp = *bufpp + 11;
-	dstp = srcp + BRCM_HDR_LEN;
-	tag = *((uint32_t *) (*bufpp + 12));
-
-	/* Update length to remove Broadcom header and ethernet FCS */
-	*lenp -= (BRCM_HDR_LEN + sizeof(uint32_t));
-
-	/* Update start of buffer */
-	*bufpp += BRCM_HDR_LEN;
-
-	/* Move DA and SA */
-	for (i = 0; i < 12; i++) {
-		*dstp-- = *srcp--;
-	}
-
-	/* Return port */
-	*portp = (tag >> 24) & 0x1;
-#endif
-
-	return 1;
-}
-
-/* TODO:  Add support for link callbacks to user apps
-void netif_carrier_off(struct net_device *dev);
-void netif_carrier_on(struct net_device *dev);
-*/
-
-/*--------------------------------------------------------------------------*/
-
-/* TODO: Add default #define's */
-
-#if DUAL_MAC
-/* TODO: Add dual MAC support to support mulitple ethernet interfaces (ie
-*        bypasses the BCMRING switch)
-*/
-#error Dual MAC is currently not supported
-#endif
-
-#ifndef MARKER
-#define MARKER
-#endif
-
-#if DEBUG_STATS
-/* TODO: Add /proc support to dump driver stats */
-#define DEBUG_STAT(x)         x
-#else
-#define DEBUG_STAT(x)
-#endif
-
-#if INT_PORT_STATS
-#define INT_PORT_STAT(x)      x
-#else
-#define INT_PORT_STAT(x)
-#endif
-
-#define myPrintk(f, s...)      printk(MARKER "%s(): " f, __func__, ## s)
-#define myPanic(f, s...)       panic(MARKER "%s(): " f, __func__, ## s)
-
-#define _FUNC_ENTRY(f, s...)   myPrintk("***ENTRY*** " f, ## s)
-#define _FUNC_EXIT(f, s...)    myPrintk("***EXIT*** " f, ## s)
-#if DEBUG
-#define FUNC_ENTRY            _FUNC_ENTRY
-#define FUNC_EXIT             _FUNC_EXIT
-#else
-#define FUNC_ENTRY(f, s...)
-#define FUNC_EXIT(f, s...)
-#endif
-
-#define printSkb(skb)	printk("skb=%08x, head=%08x, data=%08x, " \
-			"tail=%08x, end=%08x, len=%i\n", \
-			(int)(skb), (int)(skb)->head, \
-			(int)(skb)->data, (int)(skb)->tail, \
-			(int)(skb)->end, (int)(skb)->len);
-
-/* TODO: Put in proper FIFO addresses */
-#define ESW_FIFO_ADDR_RX      0x30488000
-#define ESW_FIFO_ADDR_TX      0x30498000
-#define ESW_FIFO_ADDR_TX_CFG  0x30490008
-
-/* TODO: Replace DMA_ESW_xxx with appropriate value from header file */
-#define DMA_ESW_MODULE        1
-#define DMA_ESW_CH_RX         2	/* PTM direction */
-#define DMA_ESW_CH_TX         3	/* MTP direction */
-
-#define DMA_BURST_SIZE    8
-#define DMA_BLOCK_SIZE    256
-
-#define IRQ_DMA_ESW_RX        IRQ_DMA1C0	/* PTM */
-#define IRQ_DMA_ESW_TX        IRQ_DMA1C1	/* MTP */
-
-#define PORT_PC               ETHHW_PORT_0
-#define PORT_LAN              ETHHW_PORT_1
-
-#define isRsvdMcastMac(bp)	(((bp)[0] == 0x01) && \
-				((bp)[1] == 0x80) && \
-				((bp)[2] == 0xc2) && \
-				((bp)[3] == 0x00) && \
-				((bp)[4] == 0x00))
-#define isRsvdMcastMacEapol(bp)     ((bp)[5] == 0x03)
-#define isRsvdMcastMacLldp(bp)      ((bp)[5] == 0x0e)
-
-#define TX_TIMEOUT            (5 * HZ)
-#define MIN_FRAME_LEN         60
-/* #define MIN_FRAME_LEN         (60 + 4) */
-
-static unsigned int fifoMax;
-
-#define PAD_BUF_SIZE          (MIN_FRAME_LEN + sizeof(struct sk_buff *))
-
-#define PROC_NAME_DMA_RX      "ethdmarx"
-#define PROC_NAME_DMA_TX      "ethdmatx"
-
-static int ethVerboseRx;
-static int ethVerboseTx;
-static int ethVerboseTx2;
-
-#define CTL_TABLE_ENTRY(_ctl_name, _procname, _data, _mode) \
-   .ctl_name = (_ctl_name), \
-   .procname = (_procname), \
-   .data = (void *)&(_data), \
-   .maxlen = sizeof((_data)), \
-   .mode = (_mode), \
-   .proc_handler = &proc_dointvec
-
-static struct ctl_table debugSysCtlEth[] = {
-	{CTL_TABLE_ENTRY(1, "verboseRx", ethVerboseRx, 0644)},
-	{CTL_TABLE_ENTRY(2, "verboseTx", ethVerboseTx, 0644)},
-	{CTL_TABLE_ENTRY(2, "verboseTx2", ethVerboseTx2, 0644)},
-	{CTL_TABLE_ENTRY(3, "fifoMax", fifoMax, 0644)},
-	{CTL_TABLE_ENTRY(4, "delayTx", ethDelayTx, 0644)},
-	{CTL_TABLE_ENTRY(5, "threshTx", ethThreshTx, 0644)},
-	{CTL_TABLE_ENTRY(6, "statLAN", ethStatusLAN, 0444)},
-	{CTL_TABLE_ENTRY(7, "statPoll", ethStatusPoll, 0644)},
-	{CTL_TABLE_ENTRY(8, "statusVerbose", ethStatusVerbose, 0644)},
-	{}
-};
-
-static struct ctl_table debugSysCtl[] = {
-	{
-	 .ctl_name = CTL_BCM_ETH,
-	 .procname = "eth",
-	 .mode = 0555,
-	 .child = debugSysCtlEth},
-	{}
-};
-
-static struct ctl_table_header *debugSysCtlHeaderp;
-
-/* The message level is actually a mask for this driver.  Using a mask allows
-*  more flexibility in terms of filtering out unwanted messages
-*/
-#define MSG_LEVEL_OFF            0x000000000
-#define MSG_LEVEL_RX             0x000000001
-#define MSG_LEVEL_RX_VERBOSE     0x000000002
-#define MSG_LEVEL_RX_UCAST_ONLY  0x000000004
-#define MSG_LEVEL_TX             0x000000010
-#define MSG_LEVEL_TX_VERBOSE     0x000000020
-
-#define SKB_BUF_HDR(bp)       (*(struct sk_buff **)((void *)(bp) - sizeof(struct sk_buff *)))
-
-typedef struct {
-	struct net_device *dev;
-} IRQ_CONTEXT;
-
-typedef struct {
-	int descLen;
-	void *descBufp;		/* Virtual address */
-	dma_addr_t handle;	/* Physical address */
-	int index;
-	int tail;
-	int count;
-	unsigned int countAlloc;
-	unsigned int countFree;
-	int ringSize;
-	IRQ_CONTEXT irqContext;
-} DMA_DRV_PRIV;
-
-typedef u64 mib_t;
-
-typedef struct {
-	/* NOTE: Do not change the case or the name of these structure members.
-	 *        The structure member name was chosen to correspond with an
-	 *        ethlMibxxx function, for example TxOctets -> ethlMibTxOctets.
-	 *        This simplifies the coding later by creating macros.
-	 */
-	mib_t TxOctets;
-	mib_t TxDropPkts;
-	mib_t TxBroadcastPkts;
-	mib_t TxMulticastPkts;
-	mib_t TxUnicastPkts;
-	mib_t TxCollisions;
-	mib_t TxSingleCollision;
-	mib_t TxMultipleCollision;
-	mib_t TxDeferredTransmit;
-	mib_t TxLateCollision;
-	mib_t TxExcessiveCollision;
-	mib_t TxFrameInDisc;
-	mib_t TxPausePkts;
-	mib_t RxOctets;
-	mib_t RxUndersizePkts;
-	mib_t RxPausePkts;
-	mib_t Pkts64octets;
-	mib_t Pkts65to127octets;
-	mib_t Pkts128to255octets;
-	mib_t Pkts256to511octets;
-	mib_t Pkts512to1023octets;
-	mib_t Pkts1024to1522octets;
-	mib_t RxOversizePkts;
-	mib_t RxJabbers;
-	mib_t RxAlignmentErrors;
-	mib_t RxFcsErrors;
-	mib_t RxGoodOctets;
-	mib_t RxDropPkts;
-	mib_t RxUnicastPkts;
-	mib_t RxMulticastPkts;
-	mib_t RxBroadcastPkts;
-	mib_t RxSaChanges;
-	mib_t RxFragments;
-	mib_t RxExcessSizeDisc;
-	mib_t RxSymbolError;
-} ETH_DRV_MIB;
-
-typedef struct {
-	ETHL_DRV *drvp;
-	char *padBufp;
-	dma_addr_t padHandle;
-#if DUAL_MAC
-	int port;
-#else
-	struct {
-		int lan;
-		int pc;
-	} port;
-#endif
-	ETH_DRV_MIB mib;
-#if DEBUG_STATS
-	struct {
-		struct {
-			int frames;
-			int bytes;
-		} rx;
-		struct {
-			int timeouts;
-		} tx;
-	} stat;
-#endif
-} ETH_PRIV;
-
-#if DUAL_MAC
-#define phyPort               port
-#else
-/* Some operations on the connected PHY doesn't make much sense on a chip with
-*  a switch since frames could go out multiple ports.  Assume the connected
-*  port is the LAN port since this is the expected port for handling a voice
-*  call.
-*/
-#define phyPort               port.lan
-#endif
-
-typedef struct {
-	DMA_DRV_PRIV rx;
-	DMA_DRV_PRIV tx;
-	struct kfifo *txFifop;
-	struct {
-		char *bufp;
-		int index;
-	} txCfg;
-#if DEBUG_STATS
-	struct {
-		struct {
-			int full;
-			int countMax;
-		} rx;
-		struct {
-			int countMin;
-		} tx;
-	} stat;
-#endif
-} DMA_PRIV;
-
-typedef struct {
-	int portNum;		/* Number of external ports available */
-	int portNumExt;		/* Number of external ports for external PHY */
-	int phyAvailable[ETHHW_PORT_NUM];	/* Per-port PHY available */
-	int gmiiAvailable[ETHHW_PORT_NUM];	/* Per-port GMII/1000Mbps available */
-	int sgmiiAvailable[ETHHW_PORT_NUM];	/* Per-port SGMII available */
-} CHIP_PRIV;
-
-/* TODO: Handle SGMII/external PHY */
-/* #define CHIP_PORTS(privp)              (privp)->chip.portNum */
-#define CHIP_PORTS(privp)              1
-
-typedef struct {
-	struct net_device_stats stat;
-	struct mii_if_info mii_if;
-	ETH_PRIV eth;
-	DMA_PRIV dma;
-	CHIP_PRIV chip;
-	int msgLevel;
-#ifdef CONFIG_PM
-	int wasRunning;
-#endif
-	struct napi_struct napi;
-} BCMRING_PRIV;
-
-static BCMRING_PRIV *procPrivp;
-
-static void *allocFuncp(int len);
-static void freeFunc(void *bufp);
-static int dmaStart(DMA_PRIV *dmap);
-static int dmaStop(DMA_PRIV *dmap);
-static int ethStart(ETH_PRIV *ethp);
-static int txClean(DMA_PRIV *dmap);
-static void tx(BCMRING_PRIV *privp);
-
-static BCMRING_PRIV *txTaskletPrivp;
-#if USE_WORKQUEUE
-static void txWork(void *unused);
-DECLARE_WORK(tx_work, txWork);
-#if !USE_DEFAULT_WORKQUEUE
-static struct workqueue_struct *txWorkQueuep;
-#endif
-#else
-static void txTasklet(unsigned long unused);
-DECLARE_TASKLET(tx_tasklet, txTasklet, 0);
-#endif
-
-static int miiGet(struct net_device *dev, int phy_id, int location);
-static void miiSet(struct net_device *dev, int phy_id, int location, int val);
-#if BRCM_PHY
-static void miiShadowSet(ETHL_DRV *drvp, int port, int reg, int data,
-			 int clrMask, int setMask);
-#endif
-static void dumpFrame(char *bufp, int len);
-
-static void ethIsrRx(DMA_Device_t dev, int reason, void *userData);
-static void ethIsrTx(DMA_Device_t dev, int reason, void *userData);
-
-static int bcmring_net_open(struct net_device *dev);
-static int bcmring_net_close(struct net_device *dev);
-static int bcmring_net_do_ioctl(struct net_device *dev, struct ifreq *ifr,
-				int cmd);
-static int bcmring_net_hard_start_xmit(struct sk_buff *skb,
-				       struct net_device *dev);
-static int bcmring_net_poll(struct napi_struct *napi, int quota);
-static int bcmring_net_set_mac_address(struct net_device *dev, void *addr);
-static struct net_device_stats *bcmring_net_get_stats(struct net_device *dev);
-static void bcmring_net_tx_timeout(struct net_device *dev);
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcmring_net_poll_controller(struct net_device *dev);
-#endif
-static int bcmring_net_init(void);
-static void bcmring_net_exit(void);
-#ifdef CONFIG_PM
-/* static int bcmring_net_notify_reboot(struct notifier_block *nb, unsigned long event, void *ptr); */
-static int bcmring_net_suspend(struct platform_device *pdev,
-			       pm_message_t state);
-static int bcmring_net_resume(struct platform_device *pdev);
-/* static struct notifier_block bcmring_net_notifier_reboot = { */
-/*
- *   .notifier_call  = bcmring_net_notify_reboot,
- *   .next           = NULL,
- *   .priority       = 0
- */
-/* }; */
-#else
-#define bcmring_net_suspend      NULL
-#define bcmring_net_resume       NULL
-#endif
-
-#ifdef CFG_GLOBAL_ETHTOOL_SUPPORT
-#define BCMRING_ETHTOOL
-#include "bcmring_ethtool.c"
-#endif
-
-#define STR_OCTETS_FORMAT     "%02x %02x %02x %02x %02x %02x %02x %02x"
-#define STR_OCTETS_ARGS(bp)   (bp)[0], (bp)[1], (bp)[2], (bp)[3], (bp)[4], (bp)[5], (bp)[6], (bp)[7]
-static char *dumpBytes(uint8_t *bufp, size_t len)
-{
-	static char str[256];
-
-	(void)len;
-
-	sprintf(str,
-		STR_OCTETS_FORMAT " " STR_OCTETS_FORMAT " " STR_OCTETS_FORMAT
-		" ... " STR_OCTETS_FORMAT,
-		STR_OCTETS_ARGS(&bufp[0]), STR_OCTETS_ARGS(&bufp[8]),
-		STR_OCTETS_ARGS(&bufp[16]), STR_OCTETS_ARGS(&bufp[len - 8]));
-
-	return str;
-}
-
-static void *allocFuncp(int len)
-{
-	struct sk_buff *skb;
-	char *bufp;
-	int offset;
-
-	/* Allocate socket buffer */
-	skb = dev_alloc_skb(len);
-	if (likely(skb)) {
-		/* Reserve space for a buffer header used to identify the
-		 * sk_buff when freeing the socket buffer.  At the same time,
-		 * ensure skb->data is on 64bit alignment for DMA purposes.
-		 */
-		bufp =
-		    (char *)(((int)skb->data + sizeof(struct sk_buff *) + 7) &
-			     0xfffffff8);
-		offset = (int)bufp - (int)skb->data;
-		/* printk("offset=%i, skbsize=%i, bufp=0x%08x, skb=0x%08x, skb->data=0x%08x\n", offset, sizeof(struct sk_buff *), (int)bufp, (int)skb, (int)skb->data); */
-
-		skb_reserve(skb, offset);
-		SKB_BUF_HDR(skb->data) = skb;
-		/* printk("skb=0x%08x, skb->data=0x%08x\n", (int)skb, (int)skb->data); */
-	} else {
-		return NULL;
-	}
-
-	return (void *)skb->data;
-}
-
-static void freeFunc(void *bufp)
-{
-	struct sk_buff *skb;
-
-	skb = SKB_BUF_HDR(bufp);
-	/* printk("Freeing buffer 0x%08x, skb 0x%08x\n", (int)bufp, (int)skb); */
-	if (skb) {
-		/* Unmap data buffer */
-		dma_unmap_single(NULL, (dma_addr_t) bufp, skb->len,
-				 DMA_FROM_DEVICE);
-
-		/* Free socket buffer */
-		dev_kfree_skb(skb);
-	} else {
-		/* Buffer is a zero padding buffer used to enforce the minimum
-		 * ethernet frame size requirements.  This buffer can be used
-		 * many times so it does need to be freed here.  It will be
-		 * freed when the driver is closed in bcmring_net_close()
-		 */
-	}
-}
-
-/* #define dmaStart_printk(s,...)  printk(s, ##__VA_ARGS__) */
-#define dmaStart_printk(s, ...)
-static int dmaStart(DMA_PRIV *dmap)
-{
-	dmaInit(DMA_ESW_MODULE);
-
-	/*
-	 *  Start Rx DMA
-	 */
-
-	dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-
-	/* Configure Rx DMA */
-	dmaRxConfig(DMA_BURST_SIZE, DMA_BLOCK_SIZE);
-	dmaConfig(DMA_ESW_MODULE, DMA_ESW_CH_RX,
-		  DMA_PTM_CTL_HI, DMA_PTM_CTL_LO,
-		  DMA_PTM_CFG_HI, DMA_PTM_CFG_LO, DMA_PTM_SSTAT, 0);
-
-	dmap->rx.count = 0;	/* Use count to keep track of Rx updates */
-	dmap->rx.index = 0;
-	dmap->rx.tail = 0;
-	dmap->rx.descLen = DMA_RX_DESC_NUM * sizeof(DMA_DESC);
-	dmap->rx.descBufp = (void *)dma_alloc_coherent(NULL, dmap->rx.descLen,
-						       &dmap->rx.handle,
-						       GFP_KERNEL);
-	dmaStart_printk("rx.descBufp=0x%08x, handle=0x%08x\n",
-			(int)dmap->rx.descBufp, (int)dmap->rx.handle);
-	if (!dmap->rx.descBufp) {
-		myPrintk(KERN_ERR "Failed to alloc Rx DMA descriptor memory\n");
-
-		return -ENOMEM;
-	}
-
-	/* Configure Rx descriptors */
-	{
-		int i;
-		uint8_t *bufp;
-		DMA_DESC *descp;
-		DMA_DESC *handlep;
-		dma_addr_t dmaBuf;
-
-		for (i = 0; i < DMA_RX_DESC_NUM; i++) {
-			descp = RX_DESC(dmap->rx.descBufp, i);
-			handlep = RX_DESC(dmap->rx.handle, i);
-			bufp = (uint8_t *) allocFuncp(DMA_RX_BUF_LEN);
-			if (!bufp) {
-				myPrintk(KERN_ERR
-					 "Failed to allocate Rx DMA buffer\n");
-				/* TODO:  Free previously allocated memory */
-				return -ENOMEM;
-			}
-
-			/* Map data buffer to invalidate cache */
-			dmaBuf =
-			    dma_map_single(NULL, bufp, DMA_RX_BUF_LEN,
-					   DMA_FROM_DEVICE);
-
-			/*
-			 * Rx config descriptor
-			 * The config descriptor allows transfer to be purely
-			 * 64-bit transactions, spanning an arbitrary number of
-			 * descriptors, so information must be provided to
-			 * define offsets and EOP
-			 */
-			DMA_DESC_CREATE(descp, DMA_PTM_FIFO_ADDR, dmaBuf, handlep, DMA_PTM_CTL_LO | 0x00000001,	/* Enable interrupts per Rx descriptor */
-					DMA_RX_BUF_LEN);
-
-			/* Save virtual address of buffer */
-			descp->rsvd = (uint32_t) bufp;
-			dmaStart_printk("Rx descp %i 0x%08x [%s]\n", i,
-					(int)descp, dumpDesc(descp));
-			dmaStart_printk("Rx bufp  %i 0x%08x, dmaBuf 0x%08x\n",
-					i, (int)bufp, (int)dmaBuf);
-		}
-
-		/* Wrap last descriptor back to beginning */
-		descp->lli = (uint32_t) RX_DESC(dmap->rx.handle, 0);
-	}
-
-	dma_set_device_handler(DMA_DEVICE_ESW_DEV_TO_MEM,
-			       (DMA_DeviceHandler_t) ethIsrRx,
-			       (void *)&dmap->rx.irqContext);
-	dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-	dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-
-	/*
-	 *  Start Tx DMA
-	 */
-
-	/* Allocate buffer for Tx config */
-	dmap->txCfg.index = 0;
-	dmap->txCfg.bufp = (char *)kmalloc(TXCFG_BUF_SIZE, GFP_KERNEL);
-	if (!dmap->txCfg.bufp) {
-		myPrintk(KERN_ERR "Failed to alloc Tx config buffer memory\n");
-
-		return -ENOMEM;
-	}
-
-	dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-
-	/* Configure Tx DMA */
-	dmaInit(DMA_ESW_MODULE);
-	dmaTxConfig(DMA_BURST_SIZE);
-	dmaConfig(DMA_ESW_MODULE, DMA_ESW_CH_TX,
-		  DMA_MTP_CTL_HI, DMA_MTP_CTL_LO,
-		  DMA_MTP_CFG_HI, DMA_MTP_CFG_LO, 0, DMA_MTP_DSTAT);
-
-	dmap->tx.count = dmap->tx.ringSize;	/* Use count to keep track of queue level */
-	dmap->tx.countAlloc = 0;
-	dmap->tx.countFree = 0;
-	dmap->tx.index = 0;
-	dmap->tx.tail = 0;
-	dmap->tx.descLen = DMA_TX_DESC_NUM * sizeof(DMA_DESC);
-	dmap->tx.descBufp = (void *)dma_alloc_coherent(NULL, dmap->tx.descLen,
-						       &dmap->tx.handle,
-						       GFP_KERNEL);
-	dmaStart_printk("tx.descBufp=0x%08x, handle=0x%08x\n",
-			(int)dmap->tx.descBufp, (int)dmap->tx.handle);
-	if (!dmap->tx.descBufp) {
-		myPrintk(KERN_ERR "Failed to alloc Tx DMA descriptor memory\n");
-		/* TODO:  Free previously allocated memory */
-		return -ENOMEM;
-	}
-
-	dma_set_device_handler(DMA_DEVICE_ESW_MEM_TO_DEV,
-			       (DMA_DeviceHandler_t) ethIsrTx,
-			       (void *)&dmap->tx.irqContext);
-	dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-	dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-
-	/* Clear stats */
-	DEBUG_STAT(dmap->stat.rx.full = 0);
-	DEBUG_STAT(dmap->stat.rx.countMax = dmap->rx.count);
-	DEBUG_STAT(dmap->stat.tx.countMin = dmap->tx.count);
-
-	/* Enable Rx DMA (Tx DMA is enabled when a Tx frame is ready to send) */
-	dmaEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX, RX_DESC(dmap->rx.handle, 0));
-
-	return 0;
-}
-
-static int dmaStop(DMA_PRIV *dmap)
-{
-	/*
-	 *  Stop Rx DMA
-	 */
-
-	/* Disable Rx DMA */
-	dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-
-	/* Free pending Rx buffers */
-	{
-		int i;
-		DMA_DESC *descp;
-		char *bufp;
-
-		for (i = 0; i < DMA_RX_DESC_NUM; i++) {
-			descp = RX_DESC(dmap->rx.descBufp, i);
-			bufp = (char *)descp->rsvd;
-			freeFunc(bufp);
-		}
-	}
-
-	/* Free memory used for descriptor ring */
-	dma_free_coherent(NULL, dmap->rx.descLen, dmap->rx.descBufp,
-			  dmap->rx.handle);
-
-	/*
-	 *  Stop Tx DMA
-	 */
-
-	/* Disable Tx DMA */
-	dmaDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-
-	/* Free pending Tx buffers */
-	txClean(dmap);
-
-	/* Free memory used for descriptor ring */
-	dma_free_coherent(NULL, dmap->tx.descLen, dmap->tx.descBufp,
-			  dmap->tx.handle);
-	kfree(dmap->txCfg.bufp);
-
-	return 0;
-}
-
-static int ethStart(ETH_PRIV *ethp)
-{
-	/* Initialize ethernet block */
-	ethlInit(ethp->drvp);
-
-	/* Assign ports */
-	/* TODO: Will probably need to move the port assignment code when
-	 *        DUAL_MAC is supported since it needs to know which interface
-	 *        is being configured (ie eth0 or eth1)
-	 */
-#if DUAL_MAC
-	/* TODO: Setup port for dual MAC mode */
-#else
-	ethp->port.lan = PORT_LAN;
-	ethp->port.pc = PORT_PC;
-#endif
-
-	/* Check for addition header field */
-	if (ethlRxOffset(ethp->drvp) != BRCM_HDR_LEN) {
-		myPanic
-		    ("Additional header of %i bytes reported by driver, but code"
-		     "is expecting %i bytes.  Please check configuration\n",
-		     ethlRxOffset(ethp->drvp), BRCM_HDR_LEN);
-
-		return -EPERM;
-	}
-
-	/* Disable forwarding to internal port */
-	ethHw_impEnableSet(0);
-
-	/* Clear MIB */
-	memset(&ethp->mib, 0, sizeof(ethp->mib));
-
-	/* Clear stats */
-	DEBUG_STAT(ethp->stat.rx.frames = 0);
-	DEBUG_STAT(ethp->stat.rx.bytes = 0);
-	DEBUG_STAT(ethp->stat.tx.timeouts = 0);
-
-	return 0;
-}
-
-static int miiGet(struct net_device *dev, int phy_id, int location)
-{
-	uint32_t val;
-	BCMRING_PRIV *privp;
-
-	privp = netdev_priv(dev);
-
-	ethHw_miiGet(phy_id, 0, (uint32_t) location, &val);
-
-	return val;
-}
-
-static void miiSet(struct net_device *dev, int phy_id, int location, int val)
-{
-	BCMRING_PRIV *privp;
-
-	privp = netdev_priv(dev);
-
-	ethHw_miiSet(phy_id, 0, (uint32_t) location, (uint32_t) val);
-}
-
-static void dumpFrame(char *bufp, int len)
-{
-	register int i;
-
-	printk(KERN_DEBUG "bufp=0x%08x, len=%i\n", (int)bufp, len);
-
-	for (i = 0; i < len; i++) {
-		if ((i % 16) == 0) {
-			printk("\n");
-		}
-
-		printk(KERN_DEBUG "%02x ", (unsigned char)*bufp++);
-	}
-
-	printk(KERN_DEBUG "\n");
-}
-
-static void ethIsrRx(DMA_Device_t dev, int reason, void *userData)
-{
-	IRQ_CONTEXT *contextp;
-	BCMRING_PRIV *privp;
-
-	(void)reason;
-
-	if (unlikely(dev != DMA_DEVICE_ESW_DEV_TO_MEM)) {
-		myPrintk(KERN_ERR
-			 "Invalid device.  Received %d, expected %d.\n", dev,
-			 DMA_DEVICE_ESW_DEV_TO_MEM);
-
-		/* TODO:  Check if this is the proper return value for handling
-		 * IRQ errors
-		 */
-		/*      return IRQ_NONE; */
-	}
-
-	contextp = (IRQ_CONTEXT *) userData;
-
-	/* Disable and acknowledge Rx DMA interrupt */
-	dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-	dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-
-	/* Rx frame is available, so schedule poll using NAPI */
-	privp = netdev_priv(contextp->dev);
-	napi_schedule(&privp->napi);
-}
-
-static void ethIsrTx(DMA_Device_t dev, int reason, void *userData)
-{
-	IRQ_CONTEXT *contextp;
-	BCMRING_PRIV *privp;
-
-	(void)reason;
-	(void)userData;
-
-	if (unlikely(dev != DMA_DEVICE_ESW_MEM_TO_DEV)) {
-		myPrintk(KERN_ERR
-			 "Invalid device.  Received %d, expected %d.\n", dev,
-			 DMA_DEVICE_ESW_DEV_TO_MEM);
-
-		/* TODO:  Check if this is the proper return value for handling
-		 * IRQ errors
-		 */
-		/* return IRQ_NONE; */
-	}
-
-	/* Disable and acknowledge Rx DMA interrupt */
-	dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-	dmaIrqClear(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-
-	contextp = (IRQ_CONTEXT *) userData;
-	privp = netdev_priv(contextp->dev);
-
-	if (dmaIsBusy(DMA_ESW_MODULE, DMA_ESW_CH_TX)) {
-		/* Tx DMA transfer in progress, so just leave frame in Tx FIFO.
-		 * Another attempt to send the frame will be made when the DMA
-		 * interrupt signals the completion of the current DMA transfer
-		 */
-	} else {
-		/* No Tx in progress, so send frame */
-#if USE_WORKQUEUE
-#if USE_DEFAULT_WORKQUEUE
-		schedule_work(&tx_work);
-#else
-		queue_work(txWorkQueuep, &tx_work);
-#endif
-#else
-		tasklet_schedule(&tx_tasklet);
-#endif
-	}
-/*   return IRQ_HANDLED; */
-}
-
-static int bcmring_net_open(struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-	ETH_PRIV *ethp;
-	char *padBufp;
-	int rc;
-	int i;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)dev);
-
-	debugSysCtlHeaderp = register_sysctl_table(debugSysCtl);
-
-	privp = netdev_priv(dev);
-	ethp = &privp->eth;
-	txTaskletPrivp = privp;
-
-	/* Get chip configuration */
-	privp->chip.portNum = 0;
-	privp->chip.portNumExt = 0;
-
-	for (i = ETHHW_PORT_MIN; i <= ETHHW_PORT_MAX; i++) {
-		privp->chip.phyAvailable[i] = cap_isPresent(CAP_ETH_PHY, i);
-		privp->chip.gmiiAvailable[i] = cap_isPresent(CAP_ETH_GMII, i);
-		privp->chip.sgmiiAvailable[i] = cap_isPresent(CAP_ETH_SGMII, i);
-
-		if (privp->chip.phyAvailable[i] == CAP_PRESENT)
-			privp->chip.portNum++;
-
-		if (privp->chip.sgmiiAvailable[i] == CAP_PRESENT)
-			privp->chip.portNumExt++;
-	}
-
-	if (privp->chip.portNum == 0) {
-		myPrintk(KERN_ERR "No ethernet ports available\n");
-		return -EFAULT;
-	}
-
-	/* Create Tx FIFO (enough to hold DMA_TX_DESC_NUM amount of pointers */
-	privp->dma.txFifop = kfifo_alloc(DMA_TX_DESC_NUM * 4, GFP_KERNEL, NULL);
-	if (!privp->dma.txFifop) {
-		myPrintk(KERN_ERR "Failed to create Tx FIFO\n");
-		return -ENOMEM;
-	}
-
-	fifoMax = 0;
-
-	/* Allocate buffer for zero padding Tx frames to meet minimum frame length
-	 *  requirements.
-	 */
-	padBufp = (char *)dma_alloc_coherent(NULL, PAD_BUF_SIZE,
-					     &ethp->padHandle, GFP_KERNEL);;
-	if (!padBufp) {
-		myPrintk(KERN_ERR "Failed to alloc Tx pad buffer memory\n");
-		kfifo_free(privp->dma.txFifop);
-		return -ENOMEM;
-	}
-
-	/* Initialize DMA parameters */
-	privp->dma.rx.ringSize = DMA_RX_DESC_NUM;
-	privp->dma.tx.ringSize = DMA_TX_DESC_NUM;
-
-	privp->dma.rx.irqContext.dev = dev;
-	privp->dma.tx.irqContext.dev = dev;
-
-	/* Start DMA block */
-	rc = dmaStart(&privp->dma);
-	if (rc) {
-		myPrintk(KERN_ERR "Failed to start DMA block\n");
-		kfifo_free(privp->dma.txFifop);
-		dma_free_coherent(NULL, PAD_BUF_SIZE, padBufp, ethp->padHandle);
-
-		return rc;
-	}
-
-	/* Treat zero padding Tx buffer like a socket buffer to handle the case
-	 *  when the driver tries to free the padding buffer in freeFunc()
-	 */
-	ethp->padBufp = padBufp + sizeof(struct sk_buff *);
-	memset(ethp->padBufp, 0, MIN_FRAME_LEN);
-	SKB_BUF_HDR(ethp->padBufp) = (struct sk_buff *)NULL;
-
-	/* Enable forwarding to internal port */
-	ethHw_impEnableSet(1);
-
-#if USE_WORKQUEUE && !USE_DEFAULT_WORKQUEUE
-	/* Create new workqueue/thread */
-	txWorkQueuep = create_workqueue("ethTx");
-#endif
-
-	ethStatusWorkQueuep = create_workqueue("ethStatus");
-	queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask, 0);
-
-	napi_enable(&privp->napi);
-
-	if (CHIP_PORTS(privp) == 1) {
-		/* Single port configuration */
-
-		/* Power-up the PHY */
-		ethHw_phyPowerdownSet(privp->eth.phyPort, 0);
-	} else {
-		/* Non-single port configuration */
-
-		/*
-		 * The PHYs cannot be powered-down since the external ports may
-		 * still be bridging network traffic
-		 */
-
-		/*
-		 * TODO: Define other power saving operations for this
-		 * configuration, for example, if only there is only one port
-		 * has a link, perhaps keep PHYs enabled and disable MAC and
-		 * switch clock.
-		 */
-	}
-
-	netif_start_queue(dev);
-
-	return 0;
-}
-
-/* #undef REG32 */
-#undef REG32_UC
-#undef REG32_DUMP_STR
-
-static int bcmring_net_close(struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-	ETH_PRIV *ethp;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)dev);
-
-	netif_stop_queue(dev);
-
-	privp = netdev_priv(dev);
-	ethp = &privp->eth;
-
-	napi_disable(&privp->napi);
-
-	/* Disable and free interrupts */
-	dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-	dmaIrqDisable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-
-	/* Stop DMA and ethernet */
-	dmaStop(&privp->dma);
-
-	/* Disable forwarding to internal port */
-	ethHw_impEnableSet(0);
-
-	/* Free Tx FIFO */
-	kfifo_free(privp->dma.txFifop);
-
-	/* Unmap and free buffer for zero padding Tx frames */
-	dma_unmap_single(NULL, (dma_addr_t) ethp->padBufp, MIN_FRAME_LEN,
-			 DMA_FROM_DEVICE);
-	dma_free_coherent(NULL, PAD_BUF_SIZE,
-			  ethp->padBufp - sizeof(struct sk_buff *),
-			  ethp->padHandle);
-
-	if (debugSysCtlHeaderp) {
-		unregister_sysctl_table(debugSysCtlHeaderp);
-	}
-#if USE_WORKQUEUE
-#if USE_DEFAULT_WORKQUEUE
-	flush_scheduled_work();
-#else
-	/* Flush and destroy workqueue/thread */
-	flush_workqueue(txWorkQueuep);
-	destroy_workqueue(txWorkQueuep);
-#endif
-#endif
-
-	cancel_delayed_work(&ethStatusTask);
-	flush_workqueue(ethStatusWorkQueuep);
-	destroy_workqueue(ethStatusWorkQueuep);
-
-	if (CHIP_PORTS(privp) == 1) {
-		/* Power-down the PHY */
-		ethHw_phyPowerdownSet(privp->eth.phyPort, 1);
-	} else {
-		/* Non-single port configuration */
-
-		/*
-		 * The PHYs cannot be powered-down since the external ports may
-		 * still be bridging network traffic
-		 */
-
-		/*
-		 * TODO: Define other power saving operations for this
-		 * configuration, for example, if only there is only one port
-		 * has a link, perhaps keep PHYs enabled and disable MAC and
-		 * switch clock.
-		 */
-	}
-
-	return 0;
-}
-
-static int bcmring_net_do_ioctl(struct net_device *dev, struct ifreq *ifr,
-				int cmd)
-{
-	int rc;
-	BCMRING_PRIV *privp;
-
-	FUNC_ENTRY("dev=0x%08x, rq=0x%08x, cmd=0x%08x\n", (int)dev, (int)ifr,
-		   cmd);
-
-	privp = netdev_priv(dev);
-	rc = 0;
-
-	/* Interpret datap->phy_id as a port enumeration consistent with the
-	 *  switch port enumeration (ie 0 for external port 0 and 1 for external
-	 *  port 1)
-	 */
-
-	switch (cmd) {
-	case SIOCGMIIPHY:
-		{
-			struct mii_ioctl_data *datap;
-			datap = if_mii(ifr);
-			datap->phy_id = privp->eth.phyPort;
-		}
-		break;
-
-	case SIOCGMIIREG:
-		{
-			struct mii_ioctl_data *datap;
-			datap = if_mii(ifr);
-			datap->val_out =
-			    (u16) ethlMiiGet(privp->eth.drvp, datap->phy_id,
-					     datap->reg_num);
-		}
-		break;
-
-	case SIOCSMIIREG:
-		{
-			struct mii_ioctl_data *datap;
-			datap = if_mii(ifr);
-			ethlMiiSet(privp->eth.drvp, datap->phy_id,
-				   datap->reg_num, (int)datap->val_in);
-		}
-		break;
-
-	default:
-		{
-			return -EOPNOTSUPP;
-		}
-	}
-
-	return rc;
-}
-
-/* #define xmit_printk(s,...)  printk(s, ##__VA_ARGS__) */
-#define xmit_printk(s, ...)
-
-static int txClean(DMA_PRIV *dmap)
-{
-	DMA_DESC *descp;
-
-	/* Update Tx DMA to free socket buffers from previous Tx */
-	while (dmap->tx.countFree != dmap->tx.countAlloc) {
-		/*
-		 * Tail should contain the start of completed Tx transfers.
-		 * For each of these completed transfers, free the associated
-		 * buffers
-		 */
-
-		descp = TX_DESC(dmap->tx.descBufp, dmap->tx.tail);
-		if (descp->ctlHi & 0x1000) {
-			freeFunc((void *)descp->rsvd);
-			dmap->tx.tail++;
-			dmap->tx.countFree++;
-			dmap->tx.count++;
-		} else {
-			/* Last Tx still in progress */
-			return 0;
-		}
-	}
-
-	/* Last Tx completed, so start from beginning of Tx descriptor chain */
-	dmap->tx.tail = 0;
-	dmap->tx.index = 0;
-	dmap->txCfg.index = 0;
-
-	return 1;
-}
-
-#if USE_WORKQUEUE
-static void txWork(void *unused)
-#else
-static void txTasklet(unsigned long unused)
-#endif
-{
-	(void)unused;
-
-	if (txClean(&txTaskletPrivp->dma)) {
-		tx(txTaskletPrivp);
-	} else {
-/* printk("Defer Tx\n"); */
-	}
-}
-
-#define status_printk(s, ...)  if (ethStatusVerbose) printk(s, ##__VA_ARGS__)
-
-static void ethStatusWork(struct work_struct *unused)
-{
-	static int portPrev = -1;
-	static uint32_t impSpeedPrev = -1;
-
-	BCMRING_PRIV *privp;
-	int port, up, change;
-	volatile uint32_t reg32;
-	uint32_t impSpeed;
-
-/* TODO: Move to CSP header */
-#define IMP_SPEED_TX(s)             ((s) << 4)
-#define IMP_SPEED_RX(s)             ((s) << 0)
-#define IMP_SPEED(s)                (IMP_SPEED_TX(s) | IMP_SPEED_RX(s))
-#define IMP_SPEED_MASK              0xf
-#define IMP_SPEED_MASK_1000MBPS     0x4
-#define IMP_SPEED_MASK_100MBPS      0x1
-#define IMP_SPEED_MASK_10MBPS       0x2
-
-	(void)unused;
-
-	/* Check link state of LAN port */
-	privp = netdev_priv(localDevp);
-	port = privp->eth.phyPort;
-
-	ethStatusLAN = ethHw_portSpeed(port);
-
-	if (ethStatusLAN == 1000) {
-		impSpeed = IMP_SPEED_MASK_1000MBPS;
-	} else if (ethStatusLAN == 100) {
-		impSpeed = IMP_SPEED_MASK_100MBPS;
-	} else {
-		impSpeed = IMP_SPEED_MASK_10MBPS;
-	}
-
-	if ((impSpeed != impSpeedPrev) || (port != portPrev)) {
-		status_printk("Changing internal port speed to %i\n",
-			      ethStatusLAN);
-		reg32 = REG32(0x304a0090);
-		reg32 &= ~IMP_SPEED(IMP_SPEED_MASK);
-		reg32 |=
-		    (IMP_SPEED_TX(IMP_SPEED_MASK_1000MBPS) |
-		     IMP_SPEED_RX(impSpeed));
-		REG32(0x304a0090) = reg32;
-
-		impSpeedPrev = impSpeed;
-		portPrev = port;
-	}
-
-	change = ethHw_portLinkStatusChange(port);
-
-	if ((change) || (port != portPrev)) {
-		portPrev = port;
-
-		/* link status has changed */
-		up = ethHw_portLinkStatus(port);
-
-		if ((up) || (port != portPrev)) {
-			status_printk("link up\n");
-			netif_carrier_on(localDevp);
-		} else {
-			status_printk("link down\n");
-			netif_carrier_off(localDevp);
-		}
-		portPrev = port;
-	}
-
-	queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask,
-			   msecs_to_jiffies(ethStatusPoll));
-}
-
-static void tx(BCMRING_PRIV *privp)
-{
-	char *bufp;
-	int len;
-	dma_addr_t dmaBuf;
-	uint64_t *cfgBufp;
-	int dmaLen;
-	struct sk_buff *skb;
-	DMA_DESC *descp;
-	DMA_DESC *handlep;
-	int count;
-	size_t fifoLen;
-	int portMask;
-
-	int total_bytes, total_packet, total_delay;
-	int delay_factor, thresholdExceeded;
-
-	total_bytes = 0;
-	total_packet = 0;
-	total_delay = 0;
-	delay_factor = 0;
-
-	FUNC_ENTRY("privp=0x%08x\n", (int)privp);
-
-	count = 0;
-	descp = NULL;
-
-	/* Build descriptor chain */
-	while ((fifoLen = __kfifo_len(privp->dma.txFifop)) > 0) {
-		/* Keep track of worst-case Tx FIFO usage */
-		len = fifoLen / sizeof(struct sk_buff *);
-		if (len > fifoMax)
-			fifoMax = len;
-
-		/* Get data from Tx FIFO */
-		kfifo_get(privp->dma.txFifop, (unsigned char *)&skb,
-			  sizeof(struct sk_buff *));
-		bufp = skb->data;
-		len = skb->len;
-
-		/* TODO:  Add proper zero-padding support. */
-		if (len < MIN_FRAME_LEN) {
-			len = MIN_FRAME_LEN;
-		}
-
-		/* Process buffer (frame may require a Broadcom field to be inserted) */
-#if BRCM_HDR_LEN > 0
-		if (unlikely(skb_headroom(skb) < BRCM_HDR_LEN)) {
-			/* This case should not happen since we initialized the
-			 * net device to increase dev->hard_header_len to
-			 * account for the Broadcom field
-			 */
-			dev_kfree_skb(skb);
-			myPrintk(KERN_ERR
-				 "Tx function requires %i bytes of headroom in socket"
-				 "buffer\n", BRCM_HDR_LEN);
-
-			return;
-		}
-#endif
-
-#if MSG_LEVEL_SUPPORT
-		if (privp->msgLevel & MSG_LEVEL_TX) {
-			printk(KERN_DEBUG "Tx: dma_free=%d/%d", privp->dma.tx.count,
-			       privp->dma.tx.ringSize);
-
-			if (privp->msgLevel & MSG_LEVEL_TX_VERBOSE) {
-				printk(", ");
-				dumpFrame(bufp, len);
-			} else {
-				printk("\n");
-			}
-		}
-#endif
-
-		if (ethVerboseTx) {
-			printk(KERN_DEBUG "Tx: %i skb 0x%08x, bufp 0x%08x, len %i [%s]\n",
-			       count++, (int)skb, (int)bufp, len,
-			       dumpBytes(bufp, len));
-		}
-
-		total_packet++;
-		total_bytes += len;
-
-		/* xmit_printk("before tx frame format: bufp=0x%08x, len=%i [%s]\n", (int)bufp, (int)len, dumpBytes(bufp, 16)); */
-
-		/* Allow switch ARL to make forwarding decision */
-		portMask = -1;
-
-		if (isRsvdMcastMac(bufp)) {
-			if (isRsvdMcastMacEapol(bufp) ||
-			    isRsvdMcastMacLldp(bufp)) {
-				/*
-				 * DA is an EAPOL or LLDP reserved multicast
-				 * address.  The switch will not forward these
-				 * frames since these frames are supposed to be
-				 * terminated at each hop.  Format the frame to
-				 * bypass the switch ARL forwarding rules and
-				 * force the frame to both external ports
-				 * (egress directed forwarding)
-				 */
-				portMask =
-				    ETHHW_PORT_MASK(ETHHW_PORT_1) |
-				    ETHHW_PORT_MASK(ETHHW_PORT_0);
-			}
-		}
-
-		/* Format the frame according to ASIC requirements */
-		ethlTxFrameFormat(privp->eth.drvp, &bufp, &len, portMask);
-		/* xmit_printk("after tx frame format:  bufp=0x%08x, len=%i [%s]\n", (int)bufp, (int)len, dumpBytes(bufp, 16)); */
-
-#if DUAL_MAC
-		/* TODO: Set port value to support dual MAC (if necessary) */
-#endif
-
-#if BRCM_HDR_LEN > 0
-		/* Data shift required to add offset created by Broadcom field
-		 *  embedded in frame
-		 */
-		skb_push(skb, BRCM_HDR_LEN);
-#else
-		/* Data shift not required since no Broadcom field embedded in frame */
-#endif
-
-		/* Insert buffer header used to identify the sk_buff when freeing the
-		 *  socket buffer
-		 */
-		SKB_BUF_HDR(bufp) = skb;
-
-		/* Get Tx config buffer and configure */
-		cfgBufp =
-		    TXCFG_BUF(privp->dma.txCfg.bufp, privp->dma.txCfg.index);
-		privp->dma.txCfg.index++;
-
-/* xmit_printk("cfgBufp before 0x%08x\n", (int)cfgBufp); */
-/* xmit_printk("sizeof(sk_buff) =%i\n", sizeof(struct sk_buff *)); */
-#if TXCFG_SIZE == 16
-		cfgBufp = (uint64_t *) ((uint8_t *) cfgBufp + 8);
-#else
-		cfgBufp =
-		    (uint64_t *) ((uint8_t *) cfgBufp +
-				  sizeof(struct sk_buff *));
-#endif
-		SKB_BUF_HDR(cfgBufp) = (struct sk_buff *)NULL;
-/* xmit_printk("cfgBufp after  0x%08x\n", (int)cfgBufp); */
-
-		/* TODO:  Use dmaBuf for bufp, ie physical address.  Should be ok with just bufp since alignment should be the same */
-/* xmit_printk("offset 0x%08x", CFG_OFFSET(bufp, len)); */
-		*cfgBufp = CFG_OFFSET(bufp, len) | CFG_EOP_MASK;
-
-		/* Map Tx config buffer to update external memory */
-		dmaBuf =
-		    dma_map_single(NULL, cfgBufp, sizeof(uint64_t),
-				   DMA_TO_DEVICE);
-		dmaLen = DMA_MTP_TRANSACTION_SIZE(dmaBuf, sizeof(uint64_t));
-
-		/* Send config to Tx DMA */
-		descp = TX_DESC(privp->dma.tx.descBufp, privp->dma.tx.index);
-		handlep = TX_DESC(privp->dma.tx.handle, privp->dma.tx.index);
-		privp->dma.tx.index++;
-
-		/*
-		 * Tx config descriptor
-		 * The config descriptor allows transfer to be purely 64-bit
-		 * transactions, spanning an arbitrary number of descriptors,
-		 * so information must be provided to define offsets and EOP
-		 */
-		DMA_DESC_CREATE(descp, dmaBuf, DMA_MTP_FIFO_ADDR_CFG, handlep,
-				DMA_MTP_CTL_LO, dmaLen);
-
-		/* Save virtual address of buffer */
-		descp->rsvd = (uint32_t) cfgBufp;
-
-		xmit_printk("TxCfg:\n");
-		xmit_printk("   dmaBuf=0x%08x\n", (int)dmaBuf);
-		xmit_printk("   buf=0x%08x  [%s]\n", (int)cfgBufp,
-			    dumpBytes((uint8_t *) cfgBufp, sizeof(uint64_t)));
-		xmit_printk("   desc=0x%08x [%s]\n", (int)descp,
-			    dumpDesc(descp));
-
-		/* Map data buffer to update external memory */
-		dmaBuf = dma_map_single(NULL, bufp, len, DMA_TO_DEVICE);
-
-		/* Make length a multiple of 64-bits and put data buffer on 64-bit boundary */
-		dmaLen = DMA_MTP_TRANSACTION_SIZE(dmaBuf, len);
-		dmaBuf &= 0xfffffff8;
-
-		/* Send data to Tx DMA */
-		descp = TX_DESC(privp->dma.tx.descBufp, privp->dma.tx.index);
-		handlep = TX_DESC(privp->dma.tx.handle, privp->dma.tx.index);
-		privp->dma.tx.index++;
-
-		/*
-		 * Tx config descriptor
-		 * The config descriptor allows transfer to be purely 64-bit
-		 * transactions, spanning an arbitrary number of descriptors,
-		 * so information must be provided to define offsets and EOP
-		 */
-		DMA_DESC_CREATE(descp, dmaBuf, DMA_MTP_FIFO_ADDR_DATA, handlep,
-				DMA_MTP_CTL_LO, dmaLen);
-
-		/* Save virtual address of buffer */
-		descp->rsvd = (uint32_t) bufp;
-
-		xmit_printk("Tx:\n");
-		xmit_printk("   dmaBuf=0x%08x\n", (int)dmaBuf);
-		xmit_printk("   buf=0x%08x, len=%i [%s]\n", (int)bufp, len,
-			    dumpBytes((uint8_t *) bufp, sizeof(uint64_t)));
-		xmit_printk("   desc=0x%08x [%s]\n", (int)descp,
-			    dumpDesc(descp));
-
-		if (ethVerboseTx2) {
-			printk(KERN_DEBUG "Tx2: %i skb 0x%08x, bufp 0x%08x, len %i [%s]\n",
-			       count++, (int)skb, (int)bufp, len,
-			       dumpBytes(bufp, len));
-		}
-
-		/* Update counts and stats */
-		/* TODO: Move the update of the Tx packet counter to the Tx DMA ISR since
-		 *        the frame hasn't been sent yet, so it is premature to increment
-		 *        the packet count here
-		 */
-		INT_PORT_STAT(privp->stat.tx_packets++);
-		INT_PORT_STAT(privp->stat.tx_bytes += (len - BRCM_HDR_LEN));
-
-		DEBUG_STAT(if
-			   (privp->dma.tx.count < privp->dma.stat.tx.countMin)
-			   privp->dma.stat.tx.countMin = privp->dma.tx.count) ;
-
-		privp->dma.tx.countAlloc += 2;
-		privp->dma.tx.count -= 2;
-
-		thresholdExceeded = 0;
-		if ((ethStatusLAN != 1000) && (ethThreshTx > 0)) {
-			if (total_packet >= ethThreshTx) {
-				/* Exit after ethThreshTx frames have been sent.  This will allow
-				 *  the DMA transfer to start sooner
-				 */
-				thresholdExceeded = 1;
-				break;
-			}
-		}
-	}
-
-	/* Start Tx DMA transfer */
-	if (descp) {
-		descp->lli = 0;	/* Terminate descriptor chain */
-		descp->ctlLo |= 0x00000001;	/* Enable interrupt on last descriptor */
-		handlep = TX_DESC(privp->dma.tx.handle, 0);
-		dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_TX);
-		dmaEnable(DMA_ESW_MODULE, DMA_ESW_CH_TX, handlep);
-
-		WQ_KNLLOG("=====> LAN Port link speed = %iMbps\n",
-			  ethStatusLAN);
-
-		if (thresholdExceeded) {
-#if USE_WORKQUEUE
-			if (ethStatusLAN == 100)
-				delay_factor = 10;
-			else if (ethStatusLAN == 10)
-				delay_factor = 100;
-			else
-				delay_factor = 0;
-
-			total_delay =
-			    ((total_bytes) * 8 +
-			     (total_packet) * (96 + 64 +
-					       ethDelayTx)) * delay_factor;
-
-			if (total_delay > 0) {
-				WQ_KNLLOG
-				    ("=====> START: total_bytes=%i, total_packet=%i\n",
-				     total_bytes, total_packet);
-				/* TODO: use non-block delay instead of ndelay() */
-				ndelay(total_delay);
-				WQ_KNLLOG("=====> ndelay(%i)\n", total_delay);
-			}
-#endif
-		}
-
-	}
-}
-
-static int bcmring_net_hard_start_xmit(struct sk_buff *skb,
-				       struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-	int len;
-	privp = netdev_priv(dev);
-
-	FUNC_ENTRY("skb=0x%08x, dev=0x%08x\n", (int)skb, (int)dev);
-
-	len = sizeof(struct sk_buff *);
-	if (__kfifo_put(privp->dma.txFifop, (unsigned char *)&skb, len) != len) {
-		/*
-		 * Not enough space in Tx DMA to send frame
-		 * TODO:  silently drop frame?
-		 */
-		printk(KERN_INFO "Ethernet DMA Tx FIFO full\n");
-		netif_stop_queue(dev);
-
-		return NETDEV_TX_BUSY;
-	}
-
-	dev->trans_start = jiffies;
-
-	if (dmaIsBusy(DMA_ESW_MODULE, DMA_ESW_CH_TX)) {
-		/* Tx DMA transfer in progress, so just leave frame in Tx FIFO.
-		 * Another attempt to send the frame will be made when the DMA
-		 * interrupt signals the completion of the current DMA transfer
-		 */
-	} else {
-		/* No Tx in progress, so send frame */
-#if USE_WORKQUEUE
-#if USE_DEFAULT_WORKQUEUE
-		schedule_work(&tx_work);
-#else
-		queue_work(txWorkQueuep, &tx_work);
-#endif
-#else
-		tasklet_schedule(&tx_tasklet);
-#endif
-	}
-
-	return NETDEV_TX_OK;
-}
-
-static int bcmring_net_poll(struct napi_struct *napi, int budget)
-{
-	BCMRING_PRIV *privp;
-	struct sk_buff *skb;
-	char *bufp;
-	char *newBufp;
-	int rc;
-	int len;
-	int quota;
-	int rxCount;
-	int done;
-	int port;
-	DMA_DESC *descp;
-	uint32_t ctlHi;
-	uint32_t status;
-	dma_addr_t dmaBuf;
-
-	struct net_device *dev;
-	privp = container_of(napi, BCMRING_PRIV, napi);
-	dev = privp->mii_if.dev;
-	FUNC_ENTRY("dev=0x%08x, budget=%i\n", (int)dev, budget);
-	quota = budget;
-	rxCount = 0;
-	done = 0;
-
-	while (rxCount < quota) {
-		/* Get next frame from Rx DMA */
-		descp = RX_DESC(privp->dma.rx.descBufp, privp->dma.rx.index);
-		/* printk("descp 0x%08x [%s]\n", (int)descp, dumpDesc(descp)); */
-		if (descp->ctlHi & 0x1000) {
-			bufp = (char *)descp->rsvd;
-			status = descp->stat1;
-			len = (status >> 13) & 0x0000ffff;
-			ctlHi = descp->ctlHi;
-
-			/* Update descriptor with new buffer */
-			newBufp = (uint8_t *) allocFuncp(DMA_RX_BUF_LEN);
-			if (!newBufp) {
-				myPrintk(KERN_ERR
-					 "Failed to allocate Rx DMA buffer\n");
-				done = 1;
-				break;
-			}
-
-			/* Map data buffer to invalidate cache */
-			dmaBuf = dma_map_single(NULL, newBufp, DMA_RX_BUF_LEN,
-					   DMA_FROM_DEVICE);
-
-			/* Update descriptor */
-			DMA_DESC_RX_UPDATE(descp, dmaBuf, DMA_RX_BUF_LEN);
-
-			/* Save virtual address of buffer */
-			descp->rsvd = (uint32_t) newBufp;
-
-			/* Go to next descriptor */
-			if (++privp->dma.rx.index >= DMA_RX_DESC_NUM)
-				privp->dma.rx.index = 0;
-		} else {
-			/* No frame available */
-			done = 1;
-			break;
-		}
-
-		/* Unmap buffer */
-		dma_unmap_single(NULL, (dma_addr_t) bufp, len, DMA_FROM_DEVICE);
-
-		/* Update Rx DMA to reallocate a buffer for the descriptor ring */
-		privp->dma.rx.count++;
-		DEBUG_STAT(if
-			   (privp->dma.rx.count > privp->dma.stat.rx.countMax)
-			   privp->dma.stat.rx.countMax = privp->dma.rx.count) ;
-
-		/* Get socket buffer information from Rx DMA buffer */
-		skb = SKB_BUF_HDR(bufp);
-
-		/* Process buffer (frame may contain Broadcom field, so this function
-		 *  call will remove it)
-		 */
-		rc = ethlRxFrameFormat(privp->eth.drvp, &bufp, &len, &port);
-
-		if (ethVerboseRx)
-			printk
-			    ("Rx: skb 0x%08x, bufp 0x%08x, len %i, port %i [%s]\n",
-			     (int)skb, (int)bufp, len, port, dumpBytes(bufp,
-								       len));
-
-#if MSG_LEVEL_SUPPORT
-		if (privp->msgLevel & MSG_LEVEL_RX) {
-			if ((privp->msgLevel & MSG_LEVEL_RX_UCAST_ONLY) &&
-			    (bufp[0] & 0x01)) {
-				/* Skip reporting of Rx multicast and broadcast frames */
-			} else {
-				printk(KERN_DEBUG "Rx: port=%d, dma_used=%d/%d", port,
-				       privp->dma.rx.count,
-				       privp->dma.rx.ringSize);
-
-				if (privp->msgLevel & MSG_LEVEL_RX_VERBOSE) {
-					printk(", ");
-					dumpFrame(bufp, len);
-				} else {
-					printk("\n");
-				}
-			}
-		}
-#endif
-
-		if (unlikely(!rc)) {
-			/* Frame is invalid, so discard */
-			myPrintk(KERN_ERR "Invalid frame received:\n");
-			dumpFrame(bufp, len);
-			dev_kfree_skb(skb);
-
-			INT_PORT_STAT(privp->stat.rx_dropped++);
-
-			continue;
-		}
-#if DUAL_MAC
-		/* TODO: Use port value to support dual MAC (if necessary) */
-#endif
-
-		/* Update remainder of socket buffer information */
-#if BRCM_HDR_LEN > 0
-		/* Data shift required to remove offset created by Broadcom field
-		 *  embedded in frame
-		 */
-		skb_reserve(skb, BRCM_HDR_LEN);
-#else
-		/* Data shift not required since no Broadcom field embedded in frame */
-#endif
-		skb_put(skb, len);
-
-		skb->dev = dev;
-		skb->protocol = eth_type_trans(skb, dev);
-		skb->ip_summed = CHECKSUM_NONE;	/* IP checksum offload not supported */
-
-		/* Forward socket buffer to kernel for processing by IP stack */
-		netif_receive_skb(skb);
-
-		/* Update counts and stats */
-		rxCount++;
-
-		INT_PORT_STAT(privp->stat.rx_packets++);
-		INT_PORT_STAT(privp->stat.rx_bytes += len);
-
-		DEBUG_STAT(privp->eth.stat.rx.frames++);
-		DEBUG_STAT(privp->eth.stat.rx.bytes += len);
-	}
-
-	if (done) {
-		/* Notify kernel that no more Rx frames are available */
-		napi_complete(napi);
-
-		/* Enable Rx DMA interrupt */
-		dmaIrqEnable(DMA_ESW_MODULE, DMA_ESW_CH_RX);
-
-		return 0;
-	}
-
-	return rxCount;
-}
-
-static int bcmring_net_set_mac_address(struct net_device *dev, void *addr)
-{
-	BCMRING_PRIV *privp;
-	unsigned char *macp;
-
-	macp = ((struct sockaddr *)addr)->sa_data;
-
-	FUNC_ENTRY("dev=0x%08x, addr=%02X:%02X:%02X:%02X:%02X:%02X\n", (int)dev,
-		   macp[0], macp[1], macp[2], macp[3], macp[4], macp[5]);
-
-	privp = netdev_priv(dev);
-
-	ethHw_arlEntrySet(macp, 0, ETHHW_PORT_INT, 0, 1, 1);
-
-	memcpy(dev->dev_addr, macp, dev->addr_len);
-
-	return 0;
-}
-
-static struct net_device_stats *bcmring_net_get_stats(struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-	struct net_device_stats *statp;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)dev);
-
-	privp = netdev_priv(dev);
-	statp = &privp->stat;
-
-	return statp;
-}
-
-static void bcmring_net_tx_timeout(struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)dev);
-
-	privp = netdev_priv(dev);
-
-	/*
-	 * Update Tx DMA to free socket buffers from previous Tx
-	 *   privp->dma.tx.count += dmacHw_freeMem(privp->dma.tx.configp,
-	 *                                          privp->dma.tx.descBufp,
-	 *                                          freeFunc);
-	 */
-
-	DEBUG_STAT(privp->eth.stat.tx.timeouts++);
-
-	netif_wake_queue(dev);
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void bcmring_net_poll_controller(struct net_device *dev)
-{
-	BCMRING_PRIV *privp;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)dev);
-
-	privp = netdev_priv(dev);
-
-/*   dmacHw_TRAN_INT_DISABLE(privp->dma.rx.module, privp->dma.rx.ch); */
-
-/*   ethIsr(IRQ_DMA_ESW_RX, dev, NULL); */
-
-/*   dmacHw_TRAN_INT_ENABLE(privp->dma.rx.module, privp->dma.rx.ch); */
-}
-#endif
-
-static int bcmring_net_probe(struct platform_device *pdev)
-{
-	struct net_device *dev;
-	BCMRING_PRIV *privp;
-	int rc;
-	int reg;
-
-	FUNC_ENTRY("pdev=0x%08x\n", (int)pdev);
-
-	printk(banner);
-
-	/* Initialize resources required by the driver */
-	dev = alloc_etherdev(sizeof(BCMRING_PRIV));
-	if (!dev) {
-		myPrintk(KERN_ERR "Failed to alloc device\n");
-
-		return -ENOMEM;
-	}
-
-	privp = netdev_priv(dev);
-	platform_set_drvdata(pdev, dev);
-
-	/* Create copy of driver handle for proc interface */
-	procPrivp = privp;
-	localDevp = dev;
-
-	dev->get_stats = bcmring_net_get_stats;
-	dev->watchdog_timeo = TX_TIMEOUT;
-	netif_napi_add(dev, &privp->napi, bcmring_net_poll, 64);
-	dev->open = bcmring_net_open;
-	dev->stop = bcmring_net_close;
-	dev->hard_start_xmit = bcmring_net_hard_start_xmit;
-	dev->set_mac_address = bcmring_net_set_mac_address;
-	dev->do_ioctl = bcmring_net_do_ioctl;
-	dev->tx_timeout = bcmring_net_tx_timeout;
-#ifdef BCMRING_ETHTOOL
-	dev->ethtool_ops = &bcmring_ethtool_ops;
-#endif
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	dev->poll_controller = bcmring_net_poll_controller;
-#endif
-	dev->irq = IRQ_DMA_ESW_RX;	/* Assign Rx interrupt even though both
-					 * Rx and Tx interrupts are required.
-					 * This is for informational purposes
-					 * only
-					 */
-	dev->hard_header_len += BRCM_HDR_LEN;
-	/* TODO: Add support for multiple socket buffer fragments (if required) */
-	dev->features &= ~(NETIF_F_SG | NETIF_F_FRAGLIST);
-	dev->tx_queue_len = DMA_TX_DESC_NUM;
-
-	rc = register_netdev(dev);
-	if (rc) {
-		myPrintk(KERN_ERR "Failed to register device\n");
-		free_netdev(dev);
-
-		return rc;
-	}
-
-	/* Start ethernet block.  This should be done as early as possible to
-	 * allow the switch to begin bridging frames on the external ports
-	 */
-	rc = ethStart(&privp->eth);
-	if (rc) {
-		myPrintk(KERN_ERR "Failed to start ethernet block\n");
-		free_netdev(dev);
-
-		return rc;
-	}
-
-	/* Clear stats */
-	memset(&privp->stat, 0, sizeof(privp->stat));
-
-	/* Initialize MII support */
-	privp->mii_if.phy_id = privp->eth.phyPort;
-	privp->mii_if.phy_id_mask = ETHHW_PORT_NUM - 1;	/* ETHHW_PORT_NUM must be 2^x */
-	privp->mii_if.reg_num_mask = 32 - 1;
-	privp->mii_if.dev = dev;
-	privp->mii_if.mdio_read = miiGet;
-	privp->mii_if.mdio_write = miiSet;
-
-#if 1
-	reg = ethlMiiGet(privp->eth.drvp, privp->mii_if.phy_id, MII_ADVERTISE);
-	privp->mii_if.advertising = reg;
-
-	reg = ethlMiiGet(privp->eth.drvp, privp->mii_if.phy_id, 24);
-	privp->mii_if.full_duplex = ((reg & 0x0001) ? 1 : 0);
-
-	reg = ethlMiiGet(privp->eth.drvp, privp->mii_if.phy_id, MII_BMCR);
-	privp->mii_if.force_media = ((reg & BMCR_ANENABLE) ? 0 : 1);
-#endif
-
-	/* Set message level */
-	privp->msgLevel = MSG_LEVEL_OFF;
-
-	return 0;
-}
-
-static int bcmring_net_remove(struct platform_device *pdev)
-{
-	struct net_device *dev;
-
-	FUNC_ENTRY("pdev=0x%08x\n", (int)pdev);
-
-	dev = platform_get_drvdata(pdev);
-	unregister_netdev(dev);
-	free_netdev(dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int bcmring_net_notify_reboot(struct notifier_block *nb,
-				     unsigned long event, void *ptr)
-{
-/*   BCMRING_PRIV *privp; */
-
-	FUNC_ENTRY("nb=0x%08x, event=0x%08x, ptr=0x%08x\n", (int)nb, event,
-		   (int)ptr);
-
-	(void)nb;
-	(void)ptr;
-
-/*   privp = netdev_priv(dev); */
-
-	switch (event) {
-	case SYS_DOWN:
-	case SYS_HALT:
-	case SYS_POWER_OFF:
-		{
-			/* TODO: Is anything special required for reboot wrt PM? */
-		}
-		break;
-
-	default:
-		{
-		}
-		break;
-	}
-	return NOTIFY_DONE;
-}
-
-static int bcmring_net_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct net_device *dev;
-	BCMRING_PRIV *privp;
-
-	FUNC_ENTRY("dev=0x%08x, state=0x%08x\n", (int)pdev, state);
-
-	/* TODO: Handle state */
-
-	dev = platform_get_drvdata(pdev);
-	privp = netdev_priv(dev);
-
-	/* Backup current device state */
-	privp->wasRunning = netif_running(dev);
-
-	if (privp->wasRunning) {
-		/* Shutdown network i/f */
-		netif_device_detach(dev);
-
-		/* Pause any existing work */
-		cancel_delayed_work(&ethStatusTask);
-		flush_workqueue(ethStatusWorkQueuep);
-	}
-
-	if (CHIP_PORTS(privp) == 1) {
-		/* Single port configuration */
-
-		/* Disable MAC Rx and let Tx DMA drain */
-		ethHw_macEnableSet(privp->eth.phyPort, 0, 1);
-		if (privp->wasRunning) {
-			while (__kfifo_len(privp->dma.txFifop) != 0)
-				;
-		}
-
-		/* Disable external and internal ports */
-		ethHw_macEnableSet(privp->eth.phyPort, 0, 0);
-		ethHw_impEnableSet(0);
-
-		/* Power-down the PHY */
-		ethHw_phyPowerdownSet(privp->eth.phyPort, 1);
-
-		/* Disable the switch clock */
-		chipcHw_setClockDisable(chipcHw_CLOCK_ESW);
-		chipcHw_busInterfaceClockDisable(chipcHw_REG_BUS_CLOCK_ESW);
-	} else {
-		/* Non-single port configuration */
-
-		/* Let Tx DMA drain and disable internal port */
-		if (privp->wasRunning) {
-			while (__kfifo_len(privp->dma.txFifop) != 0)
-				;
-		}
-		ethHw_impEnableSet(0);
-
-		/*
-		 * The PHYs cannot be powered-down since the external ports may still be
-		 * bridging network traffic
-		 */
-
-		/*
-		 * TODO: Define other power saving operations for this configuration,
-		 *       for example, if only there is only one port has a link, perhaps
-		 *       keep PHYs enabled and disable MAC and switch clock.
-		 */
-	}
-
-	return 0;
-}
-
-static int bcmring_net_resume(struct platform_device *pdev)
-{
-	struct net_device *dev;
-	BCMRING_PRIV *privp;
-
-	FUNC_ENTRY("dev=0x%08x\n", (int)pdev);
-
-	dev = platform_get_drvdata(pdev);
-	privp = netdev_priv(dev);
-
-	if (CHIP_PORTS(privp) == 1) {
-		/* Single port configuration */
-
-		/* Enable the switch clock */
-		chipcHw_setClockEnable(chipcHw_CLOCK_ESW);
-		chipcHw_busInterfaceClockEnable(chipcHw_REG_BUS_CLOCK_ESW);
-
-		/* Power-up the PHY */
-		ethHw_phyPowerdownSet(privp->eth.phyPort, 0);
-
-		/* Enable internal and external ports */
-		ethHw_impEnableSet(1);
-		ethHw_macEnableSet(privp->eth.phyPort, 1, 1);
-	} else {
-		/* Non-single port configuration */
-
-		/* Enable internal port */
-		ethHw_impEnableSet(1);
-
-		/*
-		 * The PHYs cannot be powered-down since the external ports may
-		 * still be bridging network traffic
-		 */
-
-		/*
-		 * TODO: Define other power saving operations for this
-		 * configuration, for example, if only there is only one port
-		 * has a link, perhaps keep PHYs enabled and disable MAC and
-		 * switch clock.
-		 */
-	}
-
-	if (privp->wasRunning) {
-		/* Resume any existing work */
-		queue_delayed_work(ethStatusWorkQueuep, &ethStatusTask, 0);
-
-		/* Restore network i/f */
-		netif_device_attach(dev);
-	}
-
-	return 0;
-}
-#endif
-
-/*--------------------------------------------------------------------------*/
-#include <linux/module.h>
-
-static struct platform_driver bcmring_net_driver = {
-	.driver = {
-		   .name = "bcmring-net",
-		   .owner = THIS_MODULE,
-		   },
-	.probe = bcmring_net_probe,
-	.remove = bcmring_net_remove,
-	.suspend = bcmring_net_suspend,
-	.resume = bcmring_net_resume,
-};
-
-static int __init bcmring_net_init(void)
-{
-#ifdef CONFIG_PM
-/*   register_reboot_notifier(&bcmring_net_notifier_reboot); */
-#endif
-	return platform_driver_register(&bcmring_net_driver);
-}
-
-static void __exit bcmring_net_exit(void)
-{
-#ifdef CONFIG_PM
-/*   unregister_reboot_notifier(&bcmring_net_notifier_reboot); */
-#endif
-	platform_driver_unregister(&bcmring_net_driver);
-}
-
-module_init(bcmring_net_init);
-module_exit(bcmring_net_exit);
-
-MODULE_DESCRIPTION(BCM_NET_MODULE_DESCRIPTION);
-MODULE_LICENSE("GPL");
-MODULE_VERSION(BCM_NET_MODULE_VERSION);
-- 
1.7.0.4

