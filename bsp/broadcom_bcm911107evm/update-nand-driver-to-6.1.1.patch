From 5342c6b89f31b23911bf307d57605af1c6dee0fe Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Fri, 21 May 2010 11:28:28 +0800
Subject: [PATCH 47/47] update nand driver to 6.1.1

update the ecc handle

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 drivers/mtd/nand/bcm_umi_bch.c  |   19 +++++++++----
 drivers/mtd/nand/nand_bcm_umi.c |   56 +++++++++++++++++++++++++++++++-------
 drivers/mtd/nand/nand_bcm_umi.h |    4 +-
 3 files changed, 60 insertions(+), 19 deletions(-)

diff --git a/drivers/mtd/nand/bcm_umi_bch.c b/drivers/mtd/nand/bcm_umi_bch.c
index 4b82a1f..6f8639a 100644
--- a/drivers/mtd/nand/bcm_umi_bch.c
+++ b/drivers/mtd/nand/bcm_umi_bch.c
@@ -22,7 +22,7 @@
 
 /* ---- Private Function Prototypes -------------------------------------- */
 static int bcm_umi_bch_read_page_hwecc(struct mtd_info *mtd,
-	struct nand_chip *chip, uint8_t *buf, int page);
+	struct nand_chip *chip, uint8_t *buf);
 static void bcm_umi_bch_write_page_hwecc(struct mtd_info *mtd,
 	struct nand_chip *chip, const uint8_t *buf);
 
@@ -106,8 +106,7 @@ static struct nand_ecclayout nand_hw_eccoob_4096 = {
 *
 ***************************************************************************/
 static int bcm_umi_bch_read_page_hwecc(struct mtd_info *mtd,
-				       struct nand_chip *chip, uint8_t *buf,
-						 int page)
+				       struct nand_chip *chip, uint8_t * buf)
 {
 	int sectorIdx = 0;
 	int eccsize = chip->ecc.size;
@@ -135,8 +134,16 @@ static int bcm_umi_bch_read_page_hwecc(struct mtd_info *mtd,
 		nand_bcm_umi_bch_pause_read_ecc_calc();
 
 		/* Read the OOB ECC */
-		chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
-			      mtd->writesize + sectorIdx * sectorOobSize, -1);
+		if (mtd->writesize > 512) {
+			/* 
+			 * For 512 byte page devices, we are already at the oob
+			 * location and don't need a READOOB command. Also
+			 * RNDOUT isn't available in general on 512 byte
+			 * devices.
+			 */
+			chip->cmdfunc(mtd, NAND_CMD_RNDOUT,
+				mtd->writesize + sectorIdx * sectorOobSize, -1);
+		}
 		nand_bcm_umi_bch_read_oobEcc(mtd->writesize, eccCalc,
 					     NAND_ECC_NUM_BYTES,
 					     chip->oob_poi +
@@ -144,7 +151,7 @@ static int bcm_umi_bch_read_page_hwecc(struct mtd_info *mtd,
 
 		/* Correct any ECC detected errors */
 		stat =
-		    nand_bcm_umi_bch_correct_page(datap, eccCalc,
+		    nand_bcm_umi_bch_correct_page(datap, eccsize, eccCalc,
 						  NAND_ECC_NUM_BYTES);
 
 		/* Update Stats */
diff --git a/drivers/mtd/nand/nand_bcm_umi.c b/drivers/mtd/nand/nand_bcm_umi.c
index 46a6bc9..716e270 100644
--- a/drivers/mtd/nand/nand_bcm_umi.c
+++ b/drivers/mtd/nand/nand_bcm_umi.c
@@ -42,11 +42,12 @@
 *  RETURNS:
 *     None
 ****************************************************************************/
-static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int errorLocation)
+static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int datalen, int errorLocation)
 {
 	int locWithinAByte = (errorLocation & REG_UMI_BCH_ERR_LOC_BYTE) >> 0;
 	int locWithinAWord = (errorLocation & REG_UMI_BCH_ERR_LOC_WORD) >> 3;
 	int locWithinAPage = (errorLocation & REG_UMI_BCH_ERR_LOC_PAGE) >> 5;
+	int offset;
 
 	uint8_t errorByte = 0;
 	uint8_t byteMask = 1 << locWithinAByte;
@@ -55,11 +56,17 @@ static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int errorLocation)
 	 * bits to little endian */
 	locWithinAWord = 3 - locWithinAWord;
 
-	errorByte = datap[locWithinAPage * sizeof(uint32_t) + locWithinAWord];
+	offset = locWithinAPage * sizeof(uint32_t) + locWithinAWord;
+	
+	if (offset >= datalen)
+	{
+		/* bad bit in ECC bytes */
+		return;
+	}
+	errorByte = datap[offset];
 
 #ifdef BOOT0_BUILD
-	puthexs("\nECC Correct Offset: ",
-		locWithinAPage * sizeof(uint32_t) + locWithinAWord);
+	puthexs("\nECC Correct Offset: ", offset);
 	puthexs(" errorByte:", errorByte);
 	puthex8(" Bit: ", locWithinAByte);
 #endif
@@ -73,7 +80,7 @@ static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int errorLocation)
 	}
 
 	/* write back the value with the fixed bit */
-	datap[locWithinAPage * sizeof(uint32_t) + locWithinAWord] = errorByte;
+	datap[offset] = errorByte;
 }
 
 /****************************************************************************
@@ -86,19 +93,23 @@ static void nand_bcm_umi_bch_ecc_flip_bit(uint8_t *datap, int errorLocation)
 *
 *  PARAMETERS:
 *     datap - Container that holds the 512 byte data
+*     len - data ecc is over length
+*     readEccData - ecc data read into a buffer
+*     numEccBytes - ecc length
 *
 *  RETURNS:
 *     0 or greater = Number of errors corrected
 *                    (No errors are found or errors have been fixed)
 *    -1 = Error(s) cannot be fixed
 ****************************************************************************/
-int nand_bcm_umi_bch_correct_page(uint8_t *datap, uint8_t *readEccData,
-				  int numEccBytes)
+int nand_bcm_umi_bch_correct_page(uint8_t *datap, int datalen,
+				  uint8_t *readEccData, int numEccBytes)
 {
 	int numErrors;
 	int errorLocation;
 	int idx;
 	uint32_t regValue;
+	uint32_t *longwordp;
 
 	/* wait for read ECC to be valid */
 	regValue = nand_bcm_umi_bch_poll_read_ecc_calc();
@@ -117,9 +128,32 @@ int nand_bcm_umi_bch_correct_page(uint8_t *datap, uint8_t *readEccData,
 				return -1;
 			}
 		}
-		/* If ECC is unprogrammed then we can't correct,
-		 * assume everything OK */
-		return 0;
+		/* 
+		 * If bits in an erased page are stuck low and 
+		 * the ECC is all FF, then we should report
+		 * the stuck low bits as uncorrectible errors
+		 * as the ECC is unprogrammed. Later, if the
+		 * page is still in use (block not marked bad
+		 * by filesystem code) and programmed, the ECC 
+		 * can then recover stuck low bits. For stuck 
+		 * high bits, this check won't help, but that
+		 * will be detected upon initial programming 
+		 * and again handled by the file system.
+		 */
+		numErrors = 0;
+		longwordp = (uint32_t *)datap;
+		for (i = 0; i < (int)(datalen/sizeof(uint32_t));
+			    i++, longwordp++) {
+			if (*longwordp != 0xffffffff) {
+				int j;
+				for (j = 0; j < 32; j++) {
+					if ((*longwordp & (1<<j)) == 0)
+						numErrors++;
+				}
+				*longwordp = 0xffffffff; /* Fake correction */
+			}
+		}
+		return numErrors;
 	}
 
 	if ((regValue & REG_UMI_BCH_CTRL_STATUS_CORR_ERR) == 0) {
@@ -141,7 +175,7 @@ int nand_bcm_umi_bch_correct_page(uint8_t *datap, uint8_t *readEccData,
 		    REG_UMI_BCH_ERR_LOC_ADDR(idx) & REG_UMI_BCH_ERR_LOC_MASK;
 
 		/* Flip bit */
-		nand_bcm_umi_bch_ecc_flip_bit(datap, errorLocation);
+		nand_bcm_umi_bch_ecc_flip_bit(datap, datalen, errorLocation);
 	}
 	/* Errors corrected */
 	return numErrors;
diff --git a/drivers/mtd/nand/nand_bcm_umi.h b/drivers/mtd/nand/nand_bcm_umi.h
index 7cec2cd..29d0307 100644
--- a/drivers/mtd/nand/nand_bcm_umi.h
+++ b/drivers/mtd/nand/nand_bcm_umi.h
@@ -42,8 +42,8 @@
 
 /* ---- Variable Externs ------------------------------------------ */
 /* ---- Function Prototypes --------------------------------------- */
-int nand_bcm_umi_bch_correct_page(uint8_t *datap, uint8_t *readEccData,
-				  int numEccBytes);
+int nand_bcm_umi_bch_correct_page(uint8_t *datap, int datalen,
+				  uint8_t *readEccData, int numEccBytes);
 
 /* Check in device is ready */
 static inline int nand_bcm_umi_dev_ready(void)
-- 
1.7.0.4

