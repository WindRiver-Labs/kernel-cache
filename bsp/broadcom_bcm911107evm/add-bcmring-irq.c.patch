From a6fe0ce4fe629fe9d868df3bcb4184661d9c70db Mon Sep 17 00:00:00 2001
From: Leo Chen <leochen@broadcom.com>
Date: Wed, 17 Mar 2010 19:39:04 +0800
Subject: [PATCH 07/47] add bcmring irq.c

commit b7462d654f623738b4b3e03cff20f68b5b9a77f5 upstream

init irq and handler
add irq controller register file and header files

Signed-off-by: Leo Hao Chen <leochen@broadcom.com>
Integrated-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/include/csp/intcHw.h         |   40 ++++
 .../arm/mach-bcmring/include/mach/csp/intcHw_reg.h |  246 ++++++++++++++++++++
 arch/arm/mach-bcmring/include/mach/irqs.h          |  132 +++++++++++
 arch/arm/mach-bcmring/irq.c                        |  127 ++++++++++
 4 files changed, 545 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/include/csp/intcHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/irqs.h
 create mode 100644 arch/arm/mach-bcmring/irq.c

diff --git a/arch/arm/mach-bcmring/include/csp/intcHw.h b/arch/arm/mach-bcmring/include/csp/intcHw.h
new file mode 100644
index 0000000..1c639c8
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/intcHw.h
@@ -0,0 +1,40 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+/****************************************************************************/
+/**
+*  @file    intcHw.h
+*
+*  @brief   generic interrupt controller API
+*
+*  @note
+*     None
+*/
+/****************************************************************************/
+
+#ifndef _INTCHW_H
+#define _INTCHW_H
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <mach/csp/intcHw_reg.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+static inline void intcHw_irq_disable(void *basep, uint32_t mask);
+static inline void intcHw_irq_enable(void *basep, uint32_t mask);
+
+#endif /* _INTCHW_H */
+
diff --git a/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
new file mode 100644
index 0000000..e01fc46
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/intcHw_reg.h
@@ -0,0 +1,246 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+/****************************************************************************/
+/**
+*  @file    intcHw_reg.h
+*
+*  @brief   platform specific interrupt controller bit assignments
+*
+*  @note
+*     None
+*/
+/****************************************************************************/
+
+#ifndef _INTCHW_REG_H
+#define _INTCHW_REG_H
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <csp/stdint.h>
+#include <csp/reg.h>
+#include <mach/csp/mm_io.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+
+#define INTCHW_NUM_IRQ_PER_INTC   32	/* Maximum number of interrupt controllers */
+#define INTCHW_NUM_INTC           3
+
+/* Defines for interrupt controllers. This simplifies and cleans up the function calls. */
+#define INTCHW_INTC0    ((void *)MM_IO_BASE_INTC0)
+#define INTCHW_INTC1    ((void *)MM_IO_BASE_INTC1)
+#define INTCHW_SINTC    ((void *)MM_IO_BASE_SINTC)
+
+/* INTC0 - interrupt controller 0 */
+#define INTCHW_INTC0_PIF_BITNUM           31	/* Peripheral interface interrupt */
+#define INTCHW_INTC0_CLCD_BITNUM          30	/* LCD Controller interrupt */
+#define INTCHW_INTC0_GE_BITNUM            29	/* Graphic engine interrupt */
+#define INTCHW_INTC0_APM_BITNUM           28	/* Audio process module interrupt */
+#define INTCHW_INTC0_ESW_BITNUM           27	/* Ethernet switch interrupt */
+#define INTCHW_INTC0_SPIH_BITNUM          26	/* SPI host interrupt */
+#define INTCHW_INTC0_TIMER3_BITNUM        25	/* Timer3 interrupt */
+#define INTCHW_INTC0_TIMER2_BITNUM        24	/* Timer2 interrupt */
+#define INTCHW_INTC0_TIMER1_BITNUM        23	/* Timer1 interrupt */
+#define INTCHW_INTC0_TIMER0_BITNUM        22	/* Timer0 interrupt */
+#define INTCHW_INTC0_SDIOH1_BITNUM        21	/* SDIO1 host interrupt */
+#define INTCHW_INTC0_SDIOH0_BITNUM        20	/* SDIO0 host interrupt */
+#define INTCHW_INTC0_USBD_BITNUM          19	/* USB device interrupt */
+#define INTCHW_INTC0_USBH1_BITNUM         18	/* USB1 host interrupt */
+#define INTCHW_INTC0_USBHD2_BITNUM        17	/* USB host2/device2 interrupt */
+#define INTCHW_INTC0_VPM_BITNUM           16	/* Voice process module interrupt */
+#define INTCHW_INTC0_DMA1C7_BITNUM        15	/* DMA1 channel 7 interrupt */
+#define INTCHW_INTC0_DMA1C6_BITNUM        14	/* DMA1 channel 6 interrupt */
+#define INTCHW_INTC0_DMA1C5_BITNUM        13	/* DMA1 channel 5 interrupt */
+#define INTCHW_INTC0_DMA1C4_BITNUM        12	/* DMA1 channel 4 interrupt */
+#define INTCHW_INTC0_DMA1C3_BITNUM        11	/* DMA1 channel 3 interrupt */
+#define INTCHW_INTC0_DMA1C2_BITNUM        10	/* DMA1 channel 2 interrupt */
+#define INTCHW_INTC0_DMA1C1_BITNUM         9	/* DMA1 channel 1 interrupt */
+#define INTCHW_INTC0_DMA1C0_BITNUM         8	/* DMA1 channel 0 interrupt */
+#define INTCHW_INTC0_DMA0C7_BITNUM         7	/* DMA0 channel 7 interrupt */
+#define INTCHW_INTC0_DMA0C6_BITNUM         6	/* DMA0 channel 6 interrupt */
+#define INTCHW_INTC0_DMA0C5_BITNUM         5	/* DMA0 channel 5 interrupt */
+#define INTCHW_INTC0_DMA0C4_BITNUM         4	/* DMA0 channel 4 interrupt */
+#define INTCHW_INTC0_DMA0C3_BITNUM         3	/* DMA0 channel 3 interrupt */
+#define INTCHW_INTC0_DMA0C2_BITNUM         2	/* DMA0 channel 2 interrupt */
+#define INTCHW_INTC0_DMA0C1_BITNUM         1	/* DMA0 channel 1 interrupt */
+#define INTCHW_INTC0_DMA0C0_BITNUM         0	/* DMA0 channel 0 interrupt */
+
+#define INTCHW_INTC0_PIF                  (1<<INTCHW_INTC0_PIF_BITNUM)
+#define INTCHW_INTC0_CLCD                 (1<<INTCHW_INTC0_CLCD_BITNUM)
+#define INTCHW_INTC0_GE                   (1<<INTCHW_INTC0_GE_BITNUM)
+#define INTCHW_INTC0_APM                  (1<<INTCHW_INTC0_APM_BITNUM)
+#define INTCHW_INTC0_ESW                  (1<<INTCHW_INTC0_ESW_BITNUM)
+#define INTCHW_INTC0_SPIH                 (1<<INTCHW_INTC0_SPIH_BITNUM)
+#define INTCHW_INTC0_TIMER3               (1<<INTCHW_INTC0_TIMER3_BITNUM)
+#define INTCHW_INTC0_TIMER2               (1<<INTCHW_INTC0_TIMER2_BITNUM)
+#define INTCHW_INTC0_TIMER1               (1<<INTCHW_INTC0_TIMER1_BITNUM)
+#define INTCHW_INTC0_TIMER0               (1<<INTCHW_INTC0_TIMER0_BITNUM)
+#define INTCHW_INTC0_SDIOH1               (1<<INTCHW_INTC0_SDIOH1_BITNUM)
+#define INTCHW_INTC0_SDIOH0               (1<<INTCHW_INTC0_SDIOH0_BITNUM)
+#define INTCHW_INTC0_USBD                 (1<<INTCHW_INTC0_USBD_BITNUM)
+#define INTCHW_INTC0_USBH1                (1<<INTCHW_INTC0_USBH1_BITNUM)
+#define INTCHW_INTC0_USBHD2               (1<<INTCHW_INTC0_USBHD2_BITNUM)
+#define INTCHW_INTC0_VPM                  (1<<INTCHW_INTC0_VPM_BITNUM)
+#define INTCHW_INTC0_DMA1C7               (1<<INTCHW_INTC0_DMA1C7_BITNUM)
+#define INTCHW_INTC0_DMA1C6               (1<<INTCHW_INTC0_DMA1C6_BITNUM)
+#define INTCHW_INTC0_DMA1C5               (1<<INTCHW_INTC0_DMA1C5_BITNUM)
+#define INTCHW_INTC0_DMA1C4               (1<<INTCHW_INTC0_DMA1C4_BITNUM)
+#define INTCHW_INTC0_DMA1C3               (1<<INTCHW_INTC0_DMA1C3_BITNUM)
+#define INTCHW_INTC0_DMA1C2               (1<<INTCHW_INTC0_DMA1C2_BITNUM)
+#define INTCHW_INTC0_DMA1C1               (1<<INTCHW_INTC0_DMA1C1_BITNUM)
+#define INTCHW_INTC0_DMA1C0               (1<<INTCHW_INTC0_DMA1C0_BITNUM)
+#define INTCHW_INTC0_DMA0C7               (1<<INTCHW_INTC0_DMA0C7_BITNUM)
+#define INTCHW_INTC0_DMA0C6               (1<<INTCHW_INTC0_DMA0C6_BITNUM)
+#define INTCHW_INTC0_DMA0C5               (1<<INTCHW_INTC0_DMA0C5_BITNUM)
+#define INTCHW_INTC0_DMA0C4               (1<<INTCHW_INTC0_DMA0C4_BITNUM)
+#define INTCHW_INTC0_DMA0C3               (1<<INTCHW_INTC0_DMA0C3_BITNUM)
+#define INTCHW_INTC0_DMA0C2               (1<<INTCHW_INTC0_DMA0C2_BITNUM)
+#define INTCHW_INTC0_DMA0C1               (1<<INTCHW_INTC0_DMA0C1_BITNUM)
+#define INTCHW_INTC0_DMA0C0               (1<<INTCHW_INTC0_DMA0C0_BITNUM)
+
+/* INTC1 - interrupt controller 1 */
+#define INTCHW_INTC1_DDRVPMP_BITNUM       27	/* DDR and VPM PLL clock phase relationship interupt (Not for A0) */
+#define INTCHW_INTC1_DDRVPMT_BITNUM       26	/* DDR and VPM HW phase align timeout interrupt (Not for A0) */
+#define INTCHW_INTC1_DDRP_BITNUM          26	/* DDR and PLL clock phase relationship interupt (For A0 only)) */
+#define INTCHW_INTC1_RTC2_BITNUM          25	/* Real time clock tamper interrupt */
+#define INTCHW_INTC1_VDEC_BITNUM          24	/* Hantro Video Decoder interrupt */
+/* Bits 13-23 are non-secure versions of the corresponding secure bits in SINTC bits 0-10. */
+#define INTCHW_INTC1_SPUM_BITNUM          23	/* Secure process module interrupt */
+#define INTCHW_INTC1_RTC1_BITNUM          22	/* Real time clock one-shot interrupt */
+#define INTCHW_INTC1_RTC0_BITNUM          21	/* Real time clock periodic interrupt */
+#define INTCHW_INTC1_RNG_BITNUM           20	/* Random number generator interrupt */
+#define INTCHW_INTC1_FMPU_BITNUM          19	/* Flash memory parition unit interrupt */
+#define INTCHW_INTC1_VMPU_BITNUM          18	/* VRAM memory partition interrupt */
+#define INTCHW_INTC1_DMPU_BITNUM          17	/* DDR2 memory partition interrupt */
+#define INTCHW_INTC1_KEYC_BITNUM          16	/* Key pad controller interrupt */
+#define INTCHW_INTC1_TSC_BITNUM           15	/* Touch screen controller interrupt */
+#define INTCHW_INTC1_UART0_BITNUM         14	/* UART 0 */
+#define INTCHW_INTC1_WDOG_BITNUM          13	/* Watchdog timer interrupt */
+
+#define INTCHW_INTC1_UART1_BITNUM         12	/* UART 1 */
+#define INTCHW_INTC1_PMUIRQ_BITNUM        11	/* ARM performance monitor interrupt */
+#define INTCHW_INTC1_COMMRX_BITNUM        10	/* ARM DDC receive interrupt */
+#define INTCHW_INTC1_COMMTX_BITNUM         9	/* ARM DDC transmit interrupt */
+#define INTCHW_INTC1_FLASHC_BITNUM         8	/* Flash controller interrupt */
+#define INTCHW_INTC1_GPHY_BITNUM           7	/* Gigabit Phy interrupt */
+#define INTCHW_INTC1_SPIS_BITNUM           6	/* SPI slave interrupt */
+#define INTCHW_INTC1_I2CS_BITNUM           5	/* I2C slave interrupt */
+#define INTCHW_INTC1_I2CH_BITNUM           4	/* I2C host interrupt */
+#define INTCHW_INTC1_I2S1_BITNUM           3	/* I2S1 interrupt */
+#define INTCHW_INTC1_I2S0_BITNUM           2	/* I2S0 interrupt */
+#define INTCHW_INTC1_GPIO1_BITNUM          1	/* GPIO bit 64//32 combined interrupt */
+#define INTCHW_INTC1_GPIO0_BITNUM          0	/* GPIO bit 31//0 combined interrupt */
+
+#define INTCHW_INTC1_DDRVPMT              (1<<INTCHW_INTC1_DDRVPMT_BITNUM)
+#define INTCHW_INTC1_DDRVPMP              (1<<INTCHW_INTC1_DDRVPMP_BITNUM)
+#define INTCHW_INTC1_DDRP                 (1<<INTCHW_INTC1_DDRP_BITNUM)
+#define INTCHW_INTC1_VDEC                 (1<<INTCHW_INTC1_VDEC_BITNUM)
+#define INTCHW_INTC1_SPUM                 (1<<INTCHW_INTC1_SPUM_BITNUM)
+#define INTCHW_INTC1_RTC2                 (1<<INTCHW_INTC1_RTC2_BITNUM)
+#define INTCHW_INTC1_RTC1                 (1<<INTCHW_INTC1_RTC1_BITNUM)
+#define INTCHW_INTC1_RTC0                 (1<<INTCHW_INTC1_RTC0_BITNUM)
+#define INTCHW_INTC1_RNG                  (1<<INTCHW_INTC1_RNG_BITNUM)
+#define INTCHW_INTC1_FMPU                 (1<<INTCHW_INTC1_FMPU_BITNUM)
+#define INTCHW_INTC1_IMPU                 (1<<INTCHW_INTC1_IMPU_BITNUM)
+#define INTCHW_INTC1_DMPU                 (1<<INTCHW_INTC1_DMPU_BITNUM)
+#define INTCHW_INTC1_KEYC                 (1<<INTCHW_INTC1_KEYC_BITNUM)
+#define INTCHW_INTC1_TSC                  (1<<INTCHW_INTC1_TSC_BITNUM)
+#define INTCHW_INTC1_UART0                (1<<INTCHW_INTC1_UART0_BITNUM)
+#define INTCHW_INTC1_WDOG                 (1<<INTCHW_INTC1_WDOG_BITNUM)
+#define INTCHW_INTC1_UART1                (1<<INTCHW_INTC1_UART1_BITNUM)
+#define INTCHW_INTC1_PMUIRQ               (1<<INTCHW_INTC1_PMUIRQ_BITNUM)
+#define INTCHW_INTC1_COMMRX               (1<<INTCHW_INTC1_COMMRX_BITNUM)
+#define INTCHW_INTC1_COMMTX               (1<<INTCHW_INTC1_COMMTX_BITNUM)
+#define INTCHW_INTC1_FLASHC               (1<<INTCHW_INTC1_FLASHC_BITNUM)
+#define INTCHW_INTC1_GPHY                 (1<<INTCHW_INTC1_GPHY_BITNUM)
+#define INTCHW_INTC1_SPIS                 (1<<INTCHW_INTC1_SPIS_BITNUM)
+#define INTCHW_INTC1_I2CS                 (1<<INTCHW_INTC1_I2CS_BITNUM)
+#define INTCHW_INTC1_I2CH                 (1<<INTCHW_INTC1_I2CH_BITNUM)
+#define INTCHW_INTC1_I2S1                 (1<<INTCHW_INTC1_I2S1_BITNUM)
+#define INTCHW_INTC1_I2S0                 (1<<INTCHW_INTC1_I2S0_BITNUM)
+#define INTCHW_INTC1_GPIO1                (1<<INTCHW_INTC1_GPIO1_BITNUM)
+#define INTCHW_INTC1_GPIO0                (1<<INTCHW_INTC1_GPIO0_BITNUM)
+
+/* SINTC secure int controller */
+#define INTCHW_SINTC_RTC2_BITNUM          15	/* Real time clock tamper interrupt */
+#define INTCHW_SINTC_TIMER3_BITNUM        14	/* Secure timer3 interrupt */
+#define INTCHW_SINTC_TIMER2_BITNUM        13	/* Secure timer2 interrupt */
+#define INTCHW_SINTC_TIMER1_BITNUM        12	/* Secure timer1 interrupt */
+#define INTCHW_SINTC_TIMER0_BITNUM        11	/* Secure timer0 interrupt */
+#define INTCHW_SINTC_SPUM_BITNUM          10	/* Secure process module interrupt */
+#define INTCHW_SINTC_RTC1_BITNUM           9	/* Real time clock one-shot interrupt */
+#define INTCHW_SINTC_RTC0_BITNUM           8	/* Real time clock periodic interrupt */
+#define INTCHW_SINTC_RNG_BITNUM            7	/* Random number generator interrupt */
+#define INTCHW_SINTC_FMPU_BITNUM           6	/* Flash memory parition unit interrupt */
+#define INTCHW_SINTC_VMPU_BITNUM           5	/* VRAM memory partition interrupt */
+#define INTCHW_SINTC_DMPU_BITNUM           4	/* DDR2 memory partition interrupt */
+#define INTCHW_SINTC_KEYC_BITNUM           3	/* Key pad controller interrupt */
+#define INTCHW_SINTC_TSC_BITNUM            2	/* Touch screen controller interrupt */
+#define INTCHW_SINTC_UART0_BITNUM          1	/* UART0 interrupt */
+#define INTCHW_SINTC_WDOG_BITNUM           0	/* Watchdog timer interrupt */
+
+#define INTCHW_SINTC_TIMER3               (1<<INTCHW_SINTC_TIMER3_BITNUM)
+#define INTCHW_SINTC_TIMER2               (1<<INTCHW_SINTC_TIMER2_BITNUM)
+#define INTCHW_SINTC_TIMER1               (1<<INTCHW_SINTC_TIMER1_BITNUM)
+#define INTCHW_SINTC_TIMER0               (1<<INTCHW_SINTC_TIMER0_BITNUM)
+#define INTCHW_SINTC_SPUM                 (1<<INTCHW_SINTC_SPUM_BITNUM)
+#define INTCHW_SINTC_RTC2                 (1<<INTCHW_SINTC_RTC2_BITNUM)
+#define INTCHW_SINTC_RTC1                 (1<<INTCHW_SINTC_RTC1_BITNUM)
+#define INTCHW_SINTC_RTC0                 (1<<INTCHW_SINTC_RTC0_BITNUM)
+#define INTCHW_SINTC_RNG                  (1<<INTCHW_SINTC_RNG_BITNUM)
+#define INTCHW_SINTC_FMPU                 (1<<INTCHW_SINTC_FMPU_BITNUM)
+#define INTCHW_SINTC_IMPU                 (1<<INTCHW_SINTC_IMPU_BITNUM)
+#define INTCHW_SINTC_DMPU                 (1<<INTCHW_SINTC_DMPU_BITNUM)
+#define INTCHW_SINTC_KEYC                 (1<<INTCHW_SINTC_KEYC_BITNUM)
+#define INTCHW_SINTC_TSC                  (1<<INTCHW_SINTC_TSC_BITNUM)
+#define INTCHW_SINTC_UART0                (1<<INTCHW_SINTC_UART0_BITNUM)
+#define INTCHW_SINTC_WDOG                 (1<<INTCHW_SINTC_WDOG_BITNUM)
+
+/* PL192 Vectored Interrupt Controller (VIC) layout */
+#define INTCHW_IRQSTATUS      0x00	/* IRQ status register */
+#define INTCHW_FIQSTATUS      0x04	/* FIQ status register */
+#define INTCHW_RAWINTR        0x08	/* Raw Interrupt Status register */
+#define INTCHW_INTSELECT      0x0c	/* Interrupt Select Register */
+#define INTCHW_INTENABLE      0x10	/* Interrupt Enable Register */
+#define INTCHW_INTENCLEAR     0x14	/* Interrupt Enable Clear Register */
+#define INTCHW_SOFTINT        0x18	/* Soft Interrupt Register */
+#define INTCHW_SOFTINTCLEAR   0x1c	/* Soft Interrupt Clear Register */
+#define INTCHW_PROTECTION     0x20	/* Protection Enable Register */
+#define INTCHW_SWPRIOMASK     0x24	/* Software Priority Mask Register */
+#define INTCHW_PRIODAISY      0x28	/* Priority Daisy Chain Register */
+#define INTCHW_VECTADDR0      0x100	/* Vector Address Registers */
+#define INTCHW_VECTPRIO0      0x200	/* Vector Priority Registers 0-31 */
+#define INTCHW_ADDRESS        0xf00	/* Vector Address Register 0-31 */
+#define INTCHW_PID            0xfe0	/* Peripheral ID Register 0-3 */
+#define INTCHW_PCELLID        0xff0	/* PrimeCell ID Register 0-3 */
+
+/* Example Usage: intcHw_irq_enable(INTCHW_INTC0, INTCHW_INTC0_TIMER0); */
+/*                intcHw_irq_clear(INTCHW_INTC0, INTCHW_INTC0_TIMER0); */
+/*                uint32_t bits = intcHw_irq_status(INTCHW_INTC0); */
+/*                uint32_t bits = intcHw_irq_raw_status(INTCHW_INTC0); */
+
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+/* Clear one or more IRQ interrupts. */
+static inline void intcHw_irq_disable(void *basep, uint32_t mask)
+{
+	__REG32(basep + INTCHW_INTENCLEAR) = mask;
+}
+
+/* Enables one or more IRQ interrupts. */
+static inline void intcHw_irq_enable(void *basep, uint32_t mask)
+{
+	__REG32(basep + INTCHW_INTENABLE) = mask;
+}
+
+#endif /* _INTCHW_REG_H */
diff --git a/arch/arm/mach-bcmring/include/mach/irqs.h b/arch/arm/mach-bcmring/include/mach/irqs.h
new file mode 100644
index 0000000..b279b82
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/irqs.h
@@ -0,0 +1,132 @@
+/*
+ *  Copyright (C) 2007 Broadcom
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#if !defined(ARCH_BCMRING_IRQS_H)
+#define ARCH_BCMRING_IRQS_H
+
+/* INTC0 - interrupt controller 0 */
+#define IRQ_INTC0_START     0
+#define IRQ_DMA0C0          0	/* DMA0 channel 0 interrupt */
+#define IRQ_DMA0C1          1	/* DMA0 channel 1 interrupt */
+#define IRQ_DMA0C2          2	/* DMA0 channel 2 interrupt */
+#define IRQ_DMA0C3          3	/* DMA0 channel 3 interrupt */
+#define IRQ_DMA0C4          4	/* DMA0 channel 4 interrupt */
+#define IRQ_DMA0C5          5	/* DMA0 channel 5 interrupt */
+#define IRQ_DMA0C6          6	/* DMA0 channel 6 interrupt */
+#define IRQ_DMA0C7          7	/* DMA0 channel 7 interrupt */
+#define IRQ_DMA1C0          8	/* DMA1 channel 0 interrupt */
+#define IRQ_DMA1C1          9	/* DMA1 channel 1 interrupt */
+#define IRQ_DMA1C2         10	/* DMA1 channel 2 interrupt */
+#define IRQ_DMA1C3         11	/* DMA1 channel 3 interrupt */
+#define IRQ_DMA1C4         12	/* DMA1 channel 4 interrupt */
+#define IRQ_DMA1C5         13	/* DMA1 channel 5 interrupt */
+#define IRQ_DMA1C6         14	/* DMA1 channel 6 interrupt */
+#define IRQ_DMA1C7         15	/* DMA1 channel 7 interrupt */
+#define IRQ_VPM            16	/* Voice process module interrupt */
+#define IRQ_USBHD2         17	/* USB host2/device2 interrupt */
+#define IRQ_USBH1          18	/* USB1 host interrupt */
+#define IRQ_USBD           19	/* USB device interrupt */
+#define IRQ_SDIOH0         20	/* SDIO0 host interrupt */
+#define IRQ_SDIOH1         21	/* SDIO1 host interrupt */
+#define IRQ_TIMER0         22	/* Timer0 interrupt */
+#define IRQ_TIMER1         23	/* Timer1 interrupt */
+#define IRQ_TIMER2         24	/* Timer2 interrupt */
+#define IRQ_TIMER3         25	/* Timer3 interrupt */
+#define IRQ_SPIH           26	/* SPI host interrupt */
+#define IRQ_ESW            27	/* Ethernet switch interrupt */
+#define IRQ_APM            28	/* Audio process module interrupt */
+#define IRQ_GE             29	/* Graphic engine interrupt */
+#define IRQ_CLCD           30	/* LCD Controller interrupt */
+#define IRQ_PIF            31	/* Peripheral interface interrupt */
+#define IRQ_INTC0_END      31
+
+/* INTC1 - interrupt controller 1 */
+#define IRQ_INTC1_START    32
+#define IRQ_GPIO0          32	/*  0 GPIO bit 31//0 combined interrupt */
+#define IRQ_GPIO1          33	/*  1 GPIO bit 64//32 combined interrupt */
+#define IRQ_I2S0           34	/*  2 I2S0 interrupt */
+#define IRQ_I2S1           35	/*  3 I2S1 interrupt */
+#define IRQ_I2CH           36	/*  4 I2C host interrupt */
+#define IRQ_I2CS           37	/*  5 I2C slave interrupt */
+#define IRQ_SPIS           38	/*  6 SPI slave interrupt */
+#define IRQ_GPHY           39	/*  7 Gigabit Phy interrupt */
+#define IRQ_FLASHC         40	/*  8 Flash controller interrupt */
+#define IRQ_COMMTX         41	/*  9 ARM DDC transmit interrupt */
+#define IRQ_COMMRX         42	/* 10 ARM DDC receive interrupt */
+#define IRQ_PMUIRQ         43	/* 11 ARM performance monitor interrupt */
+#define IRQ_UARTB          44	/* 12 UARTB */
+#define IRQ_WATCHDOG       45	/* 13 Watchdog timer interrupt */
+#define IRQ_UARTA          46	/* 14 UARTA */
+#define IRQ_TSC            47	/* 15 Touch screen controller interrupt */
+#define IRQ_KEYC           48	/* 16 Key pad controller interrupt */
+#define IRQ_DMPU           49	/* 17 DDR2 memory partition interrupt */
+#define IRQ_VMPU           50	/* 18 VRAM memory partition interrupt */
+#define IRQ_FMPU           51	/* 19 Flash memory parition unit interrupt */
+#define IRQ_RNG            52	/* 20 Random number generator interrupt */
+#define IRQ_RTC0           53	/* 21 Real time clock periodic interrupt */
+#define IRQ_RTC1           54	/* 22 Real time clock one-shot interrupt */
+#define IRQ_SPUM           55	/* 23 Secure process module interrupt */
+#define IRQ_VDEC           56	/* 24 Hantro video decoder interrupt */
+#define IRQ_RTC2           57	/* 25 Real time clock tamper interrupt */
+#define IRQ_DDRP           58	/* 26 DDR Panic interrupt */
+#define IRQ_INTC1_END      58
+
+/* SINTC secure int controller */
+#define IRQ_SINTC_START    59
+#define IRQ_SEC_WATCHDOG   59	/*  0 Watchdog timer interrupt */
+#define IRQ_SEC_UARTA      60	/*  1 UARTA interrupt */
+#define IRQ_SEC_TSC        61	/*  2 Touch screen controller interrupt */
+#define IRQ_SEC_KEYC       62	/*  3 Key pad controller interrupt */
+#define IRQ_SEC_DMPU       63	/*  4 DDR2 memory partition interrupt */
+#define IRQ_SEC_VMPU       64	/*  5 VRAM memory partition interrupt */
+#define IRQ_SEC_FMPU       65	/*  6 Flash memory parition unit interrupt */
+#define IRQ_SEC_RNG        66	/*  7 Random number generator interrupt */
+#define IRQ_SEC_RTC0       67	/*  8 Real time clock periodic interrupt */
+#define IRQ_SEC_RTC1       68	/*  9 Real time clock one-shot interrupt */
+#define IRQ_SEC_SPUM       69	/* 10 Secure process module interrupt */
+#define IRQ_SEC_TIMER0     70	/* 11 Secure timer0 interrupt */
+#define IRQ_SEC_TIMER1     71	/* 12 Secure timer1 interrupt */
+#define IRQ_SEC_TIMER2     72	/* 13 Secure timer2 interrupt */
+#define IRQ_SEC_TIMER3     73	/* 14 Secure timer3 interrupt */
+#define IRQ_SEC_RTC2       74	/* 15 Real time clock tamper interrupt */
+
+#define IRQ_SINTC_END      74
+
+/* Note: there are 3 INTC registers of 32 bits each. So internal IRQs could go from 0-95 */
+/*       Since IRQs are typically viewed in decimal, we start the gpio based IRQs off at 100 */
+/*       to make the mapping easy for humans to decipher. */
+
+#define IRQ_GPIO_0                  100
+
+#define NUM_INTERNAL_IRQS          (IRQ_SINTC_END+1)
+
+/* I couldn't get the gpioHw_reg.h file to be included cleanly, so I hardcoded it */
+/* define NUM_GPIO_IRQS               GPIOHW_TOTAL_NUM_PINS */
+#define NUM_GPIO_IRQS               62
+
+#define NR_IRQS                     (IRQ_GPIO_0 + NUM_GPIO_IRQS)
+
+#define IRQ_UNKNOWN                 -1
+
+/* Tune these bits to preclude noisy or unsupported interrupt sources as required. */
+#define IRQ_INTC0_VALID_MASK        0xffffffff
+#define IRQ_INTC1_VALID_MASK        0x07ffffff
+#define IRQ_SINTC_VALID_MASK        0x0000ffff
+
+#endif /* ARCH_BCMRING_IRQS_H */
diff --git a/arch/arm/mach-bcmring/irq.c b/arch/arm/mach-bcmring/irq.c
new file mode 100644
index 0000000..dc1c493
--- /dev/null
+++ b/arch/arm/mach-bcmring/irq.c
@@ -0,0 +1,127 @@
+/*
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/stddef.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/version.h>
+#include <linux/io.h>
+
+#include <mach/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/irq.h>
+#include <mach/csp/intcHw_reg.h>
+#include <mach/csp/mm_io.h>
+
+static void bcmring_mask_irq0(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_INTC0_START),
+	       MM_IO_BASE_INTC0 + INTCHW_INTENCLEAR);
+}
+
+static void bcmring_unmask_irq0(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_INTC0_START),
+	       MM_IO_BASE_INTC0 + INTCHW_INTENABLE);
+}
+
+static void bcmring_mask_irq1(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_INTC1_START),
+	       MM_IO_BASE_INTC1 + INTCHW_INTENCLEAR);
+}
+
+static void bcmring_unmask_irq1(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_INTC1_START),
+	       MM_IO_BASE_INTC1 + INTCHW_INTENABLE);
+}
+
+static void bcmring_mask_irq2(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_SINTC_START),
+	       MM_IO_BASE_SINTC + INTCHW_INTENCLEAR);
+}
+
+static void bcmring_unmask_irq2(unsigned int irq)
+{
+	writel(1 << (irq - IRQ_SINTC_START),
+	       MM_IO_BASE_SINTC + INTCHW_INTENABLE);
+}
+
+static struct irq_chip bcmring_irq0_chip = {
+	.typename = "ARM-INTC0",
+	.ack = bcmring_mask_irq0,
+	.mask = bcmring_mask_irq0,	/* mask a specific interrupt, blocking its delivery. */
+	.unmask = bcmring_unmask_irq0,	/* unmaks an interrupt */
+};
+
+static struct irq_chip bcmring_irq1_chip = {
+	.typename = "ARM-INTC1",
+	.ack = bcmring_mask_irq1,
+	.mask = bcmring_mask_irq1,
+	.unmask = bcmring_unmask_irq1,
+};
+
+static struct irq_chip bcmring_irq2_chip = {
+	.typename = "ARM-SINTC",
+	.ack = bcmring_mask_irq2,
+	.mask = bcmring_mask_irq2,
+	.unmask = bcmring_unmask_irq2,
+};
+
+static void vic_init(void __iomem *base, struct irq_chip *chip,
+		     unsigned int irq_start, unsigned int vic_sources)
+{
+	unsigned int i;
+	for (i = 0; i < 32; i++) {
+		unsigned int irq = irq_start + i;
+		set_irq_chip(irq, chip);
+		set_irq_chip_data(irq, base);
+
+		if (vic_sources & (1 << i)) {
+			set_irq_handler(irq, handle_level_irq);
+			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		}
+	}
+	writel(0, base + INTCHW_INTSELECT);
+	writel(0, base + INTCHW_INTENABLE);
+	writel(~0, base + INTCHW_INTENCLEAR);
+	writel(0, base + INTCHW_IRQSTATUS);
+	writel(~0, base + INTCHW_SOFTINTCLEAR);
+}
+
+void __init bcmring_init_irq(void)
+{
+	vic_init((void __iomem *)MM_IO_BASE_INTC0, &bcmring_irq0_chip,
+		 IRQ_INTC0_START, IRQ_INTC0_VALID_MASK);
+	vic_init((void __iomem *)MM_IO_BASE_INTC1, &bcmring_irq1_chip,
+		 IRQ_INTC1_START, IRQ_INTC1_VALID_MASK);
+	vic_init((void __iomem *)MM_IO_BASE_SINTC, &bcmring_irq2_chip,
+		 IRQ_SINTC_START, IRQ_SINTC_VALID_MASK);
+
+	/* special cases */
+	if (INTCHW_INTC1_GPIO0 & IRQ_INTC1_VALID_MASK) {
+		set_irq_handler(IRQ_GPIO0, handle_simple_irq);
+	}
+	if (INTCHW_INTC1_GPIO1 & IRQ_INTC1_VALID_MASK) {
+		set_irq_handler(IRQ_GPIO1, handle_simple_irq);
+	}
+}
-- 
1.7.0.4

