From d391837d51485aec1cf82f5773389b6357842584 Mon Sep 17 00:00:00 2001
From: Fei Wu <fei.wu@windriver.com>
Date: Wed, 17 Mar 2010 19:39:29 +0800
Subject: [PATCH 32/47] bcmring: gpio support

include the gpio and gpiomux driver

originated from broadcom SDK PhonexChange6.1

Signed-off-by: Fei Wu <fei.wu@windriver.com>
---
 arch/arm/mach-bcmring/Makefile                     |    2 +-
 arch/arm/mach-bcmring/core.c                       |    4 +
 arch/arm/mach-bcmring/csp/Makefile                 |    2 +
 arch/arm/mach-bcmring/csp/gpio/Makefile            |    1 +
 arch/arm/mach-bcmring/csp/gpio/gpioHw_pl061.c      |  172 ++++++
 arch/arm/mach-bcmring/csp/gpiomux/Makefile         |    1 +
 arch/arm/mach-bcmring/csp/gpiomux/gpiomux.c        |  634 ++++++++++++++++++++
 arch/arm/mach-bcmring/gpio.c                       |  280 +++++++++
 arch/arm/mach-bcmring/gpio_irq.c                   |  379 ++++++++++++
 arch/arm/mach-bcmring/include/csp/gpioHw.h         |   71 +++
 .../mach-bcmring/include/mach/csp/gpioHw_inline.h  |  323 ++++++++++
 .../arm/mach-bcmring/include/mach/csp/gpioHw_reg.h |  428 +++++++++++++
 arch/arm/mach-bcmring/include/mach/csp/gpiomux.h   |  239 ++++++++
 arch/arm/mach-bcmring/include/mach/gpio.h          |  104 ++++
 arch/arm/mach-bcmring/include/mach/gpio_defs.h     |  105 ++++
 arch/arm/mach-bcmring/include/mach/gpio_irq.h      |   69 +++
 arch/arm/mach-bcmring/include/mach/gpio_types.h    |   57 ++
 arch/arm/mach-bcmring/include/mach/reg_gpio.h      |  132 ++++
 arch/arm/mach-bcmring/irq.c                        |    5 +
 19 files changed, 3007 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-bcmring/csp/gpio/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/gpio/gpioHw_pl061.c
 create mode 100644 arch/arm/mach-bcmring/csp/gpiomux/Makefile
 create mode 100644 arch/arm/mach-bcmring/csp/gpiomux/gpiomux.c
 create mode 100644 arch/arm/mach-bcmring/gpio.c
 create mode 100644 arch/arm/mach-bcmring/gpio_irq.c
 create mode 100644 arch/arm/mach-bcmring/include/csp/gpioHw.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/gpioHw_inline.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/gpioHw_reg.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/csp/gpiomux.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/gpio.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/gpio_defs.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/gpio_irq.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/gpio_types.h
 create mode 100644 arch/arm/mach-bcmring/include/mach/reg_gpio.h

diff --git a/arch/arm/mach-bcmring/Makefile b/arch/arm/mach-bcmring/Makefile
index f8d9fce..6836883 100644
--- a/arch/arm/mach-bcmring/Makefile
+++ b/arch/arm/mach-bcmring/Makefile
@@ -4,5 +4,5 @@
 
 # Object file lists.
 
-obj-y := arch.o mm.o irq.o clock.o core.o timer.o dma.o
+obj-y := arch.o mm.o irq.o clock.o core.o timer.o dma.o gpio.o gpio_irq.o
 obj-y += csp/
diff --git a/arch/arm/mach-bcmring/core.c b/arch/arm/mach-bcmring/core.c
index 2af6182..1c9608c 100644
--- a/arch/arm/mach-bcmring/core.c
+++ b/arch/arm/mach-bcmring/core.c
@@ -77,6 +77,8 @@ static struct amba_device name##_device = {     \
 
 AMBA_DEVICE(uartA, "uarta", UARTA, NULL, SZ_4K);
 AMBA_DEVICE(uartB, "uartb", UARTB, NULL, SZ_4K);
+AMBA_DEVICE(gpio0, "GPIO0", GPIO0, NULL, SZ_4K >> 1);
+AMBA_DEVICE(gpio1, "GPIO1", GPIO1, NULL, SZ_4K >> 1);
 AMBA_DEVICE(wdog, "WDOG", WATCHDOG, NULL, SZ_4K >> 1);
 
 static struct clk pll1_clk = {
@@ -107,6 +109,8 @@ static struct clk_lookup lookups[] = {
 static struct amba_device *amba_devs[] __initdata = {
 	&uartA_device,
 	&uartB_device,
+	&gpio0_device,
+	&gpio1_device,
 	&wdog_device,
 };
 
diff --git a/arch/arm/mach-bcmring/csp/Makefile b/arch/arm/mach-bcmring/csp/Makefile
index 134d634..1e03646 100644
--- a/arch/arm/mach-bcmring/csp/Makefile
+++ b/arch/arm/mach-bcmring/csp/Makefile
@@ -1,4 +1,6 @@
 obj-y += dmac/
 obj-y += tmr/
 obj-y += chipc/
+obj-y += gpio/
+obj-y += gpiomux/
 obj-$(CONFIG_BCMRING_WATCHDOG) += wdog/
diff --git a/arch/arm/mach-bcmring/csp/gpio/Makefile b/arch/arm/mach-bcmring/csp/gpio/Makefile
new file mode 100644
index 0000000..8bfc1ec
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/gpio/Makefile
@@ -0,0 +1 @@
+obj-y += gpioHw_pl061.o   
diff --git a/arch/arm/mach-bcmring/csp/gpio/gpioHw_pl061.c b/arch/arm/mach-bcmring/csp/gpio/gpioHw_pl061.c
new file mode 100644
index 0000000..1c38673
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/gpio/gpioHw_pl061.c
@@ -0,0 +1,172 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file    gpioHw_pl061.c
+*
+*  @brief   Lower level GPIO device driver
+*/
+/****************************************************************************/
+
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/stdint.h>
+
+#include <mach/csp/mm_io.h>
+#include <csp/gpioHw.h>
+#include <csp/reg.h>
+#include <mach/csp/gpioHw_reg.h>
+#include <mach/csp/gpioHw_inline.h>
+
+/* ---- Private Constants and Types ---------------------------------------- */
+/* ---- Private Variables ------------------------------------------------ */
+/* ---- Private Functions ------------------------------------------------- */
+/* ---- Functions ----------------------------------------------------------*/
+
+void GpioHwReg_SetDirReg(volatile GPIOHW_REG_t *regp, uint32_t dirRegVal)
+{
+	reg32_set_bits(&regp->gpioDir, dirRegVal);
+}
+
+uint32_t GpioHwReg_GetDirReg(volatile GPIOHW_REG_t *regp)
+{
+	return reg32_read(&regp->gpioDir);
+}
+
+void GpioHwReg_SetValReg(volatile GPIOHW_REG_t *regp, uint32_t gpioMask, uint32_t maskVal)
+{
+	/* Change only set bits in the mask to the corresponding maskVal value
+	 * bit.  Bits not set in the mask are to be unchanged.
+	 */
+	reg32_write_masked(&regp->gpioData, gpioMask, maskVal);
+}
+
+uint32_t GpioHwReg_GetValReg(volatile GPIOHW_REG_t *regp)
+{
+	return reg32_read(&regp->gpioData);
+}
+
+void GpioHwReg_SetModeCtrl(volatile GPIOHW_REG_t *regp, unsigned int gpioNum, GPIOHW_MODE_CONTROL_SELECT mode)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	if (mode == GPIOHW_MODE_CONTROL_SELECT_SOFTWARE)
+		reg32_clear_bits(&regp->gpioAfSel, gpioMask);
+	else
+		reg32_set_bits(&regp->gpioAfSel, gpioMask);
+}
+
+GPIOHW_MODE_CONTROL_SELECT GpioHwReg_GetModeCtrl(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	return (reg32_read(&regp->gpioAfSel) & gpioMask) ?
+		GPIOHW_MODE_CONTROL_SELECT_HARDWARE : GPIOHW_MODE_CONTROL_SELECT_SOFTWARE;
+}
+
+void GpioHwReg_SetIrqType(volatile GPIOHW_REG_t *regp, unsigned int gpioNum, GPIOHW_INTERRUPT_TYPE irqType)
+{
+	uint32_t gpioMask;
+	uint32_t gpioMaskStateReg;
+
+	REG_LOCAL_IRQ_SAVE;
+
+	gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Store current mask state to revert towards when done */
+	gpioMaskStateReg = reg32_read(&regp->gpioIe);
+
+	/* Mask and clear interrupt before changing type */
+	reg32_clear_bits(&regp->gpioIe, gpioMask);
+	reg32_clear_bits(&regp->gpioIc, gpioMask);
+
+	switch (irqType) {
+	case GPIOHW_INTERRUPT_TYPE_LEVEL_HIGH:
+		/* GPIOIS = 1 */
+		/* GPIOIEV = 1 */
+		reg32_set_bits(&regp->gpioIev, gpioMask);
+		reg32_set_bits(&regp->gpioIs, gpioMask);
+		break;
+
+	case GPIOHW_INTERRUPT_TYPE_LEVEL_LOW:
+		/* GPIOIS = 1 */
+		/* GPIOIEV = 0 */
+		reg32_clear_bits(&regp->gpioIev, gpioMask);
+		reg32_set_bits(&regp->gpioIs, gpioMask);
+		break;
+
+	case GPIOHW_INTERRUPT_TYPE_EDGE_RISING:
+		/* GPIOIS = 0 */
+		/* GPIOIBE = 0 */
+		/* GPIOIEV = 1 */
+		reg32_clear_bits(&regp->gpioIbe, gpioMask);
+		reg32_set_bits(&regp->gpioIev, gpioMask);
+		reg32_clear_bits(&regp->gpioIs, gpioMask);
+		break;
+
+	case GPIOHW_INTERRUPT_TYPE_EDGE_FALLING:
+		/* GPIOIS = 0 */
+		/* GPIOIBE = 0 */
+		/* GPIOIEV = 0 */
+		reg32_clear_bits(&regp->gpioIbe, gpioMask);
+		reg32_clear_bits(&regp->gpioIev, gpioMask);
+		reg32_clear_bits(&regp->gpioIs, gpioMask);
+		break;
+
+	case GPIOHW_INTERRUPT_TYPE_EDGE_BOTH:
+		/* GPIOIS = 0 */
+		/* GPIOIBE = 1 */
+		reg32_set_bits(&regp->gpioIbe, gpioMask);
+		reg32_clear_bits(&regp->gpioIs, gpioMask);
+		break;
+
+	default:
+		/* Do nothing */
+		break;
+	}
+
+	/* Restore mask state to gpio interrupt */
+	reg32_write(&regp->gpioIe, gpioMaskStateReg);
+
+	REG_LOCAL_IRQ_RESTORE;
+}
+
+GPIOHW_INTERRUPT_TYPE GpioHwReg_GetIrqType(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask;
+	GPIOHW_INTERRUPT_TYPE retType;
+
+	gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	if (reg32_read(&regp->gpioIs) & gpioMask) {
+		if (reg32_read(&regp->gpioIev) & gpioMask)
+			retType = GPIOHW_INTERRUPT_TYPE_LEVEL_HIGH;
+		else
+			retType = GPIOHW_INTERRUPT_TYPE_LEVEL_LOW;
+	} else {
+		if (reg32_read(&regp->gpioIbe) & gpioMask) {
+			retType = GPIOHW_INTERRUPT_TYPE_EDGE_BOTH;
+		} else {
+			if (reg32_read(&regp->gpioIev) & gpioMask)
+				retType = GPIOHW_INTERRUPT_TYPE_EDGE_RISING;
+			else
+				retType = GPIOHW_INTERRUPT_TYPE_EDGE_FALLING;
+		}
+	}
+	return retType;
+}
+
diff --git a/arch/arm/mach-bcmring/csp/gpiomux/Makefile b/arch/arm/mach-bcmring/csp/gpiomux/Makefile
new file mode 100644
index 0000000..510fb5d
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/gpiomux/Makefile
@@ -0,0 +1 @@
+obj-y += gpiomux.o   
diff --git a/arch/arm/mach-bcmring/csp/gpiomux/gpiomux.c b/arch/arm/mach-bcmring/csp/gpiomux/gpiomux.c
new file mode 100644
index 0000000..e9856ca
--- /dev/null
+++ b/arch/arm/mach-bcmring/csp/gpiomux/gpiomux.c
@@ -0,0 +1,634 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/****************************************************************************/
+/**
+*  @file    gpiomux.c
+*
+*  @brief   Lower level GPIOMUX utility. Note that critical section protection
+*           is the responsibility of the higher level software.
+*/
+/****************************************************************************/
+
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/string.h>
+#include <csp/stdint.h>
+#include <csp/module.h>
+#include <mach/csp/mm_io.h>
+#include <mach/gpio_defs.h>
+#include <mach/csp/gpiomux.h>
+#include <mach/csp/chipcHw_inline.h>
+
+/* ---- Private Constants and Types ---------------------------------------- */
+
+#define GMUX_DEBUG 1
+
+#ifdef GMUX_DEBUG
+#if defined(__KERNEL__)
+#define DBGPRINT(fmt, args...) printk(KERN_DEBUG "%s: " fmt, __func__, ##args)
+#else
+#include <csp/stdio.h>
+#define DBGPRINT(fmt, args...) printf("%s: " fmt, __func__, ##args)
+#endif /* defined(__KERNEL__) */
+#else
+#define DBGPRINT(level, fmt, args...)
+#endif /* GMUX_DEBUG */
+
+#if defined(__KERNEL__)
+
+#define FORCE_CONFLICT_CHECK 1
+
+#else
+
+/*
+ * For Linux, conflict checking is on by default. For csptest, we can turn it on
+ * with this flag for local testing. Production csptest must turn
+ * this flag off unless the registrations/deregistrations are balanced.
+ */
+#define FORCE_CONFLICT_CHECK  0
+
+#endif
+
+
+
+/* ---- Private Variables ------------------------------------------------ */
+/* init called before other functions check */
+static int initialized;
+
+/*
+ * Following is a number of lists of gpio pins, which are collected
+ * by logical function.
+ */
+static const gpio_defs_e gphyledList[] = {
+	GPIO00_SCL_MTX_X0_EPHYLED_DATA,
+	GPIO01_SDA_MTX_X1_EPHYLED_CLK
+};
+
+static const gpio_defs_e ext_gphyList[] = {
+	GPIO57_KEY_OUT5_SPIS_SSN_ETM12_EXTPHY_MDC,
+	GPIO58_KEY_OUT6_ETM13_EXTPHY_MDIO
+};
+
+/* Shows up in 2 places below so reduce duplication */
+#define ETM16_LIST \
+	GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL,\
+	GPIO44_KEY_IN1_UART0_RTS_B_I2S1LRCIN_ETMCLK_VPMRTCK,\
+	GPIO45_KEY_IN2_ETM0_I2S0MCLK,\
+	GPIO46_KEY_IN3_ETM1,\
+	GPIO47_KEY_IN4_ETM2,\
+	GPIO48_KEY_IN5_ETM3,\
+	GPIO49_KEY_IN6_SSCL_ETM4,\
+	GPIO50_KEY_IN7_SSDA_ETM5,\
+	GPIO51_KEY_IN8_SPIS_MISO_ETM6,\
+	GPIO52_KEY_OUT0_ETM7,\
+	GPIO53_KEY_OUT1_ETM8,\
+	GPIO54_KEY_OUT2_ETM9,\
+	GPIO55_KEY_OUT3_SPIS_CLK_ETM10,\
+	GPIO56_KEY_OUT4_SPIS_MOSI_ETM11,\
+	GPIO57_KEY_OUT5_SPIS_SSN_ETM12_EXTPHY_MDC,\
+	GPIO58_KEY_OUT6_ETM13_EXTPHY_MDIO,\
+	GPIO59_KEY_OUT7_ETM14_USB1_PWRON,\
+	GPIO60_KEY_OUT8_ETM15_USB1_PWRFLT
+
+static const gpio_defs_e etm16List[] = {
+	ETM16_LIST
+};
+static const gpio_defs_e etm32List[] = {
+	ETM16_LIST,
+
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK,
+	GPIO06_MTX_X6_SDIO1D2_ETM22,
+	GPIO07_MTX_X7_SDIO1D3_ETM23,
+	GPIO10_MTX_X10_SDIO1CMD_ETM16,
+	GPIO11_MTX_X11_SDIO1CLK_ETM17,
+	GPIO16_MTX_Y0_MTX_SCAN_DA_ETM26,
+	GPIO17_MTX_Y1_MTX_SCAN_CLK_ETM27,
+	GPIO18_MTX_Y2_SDIO0D2_ETM28,
+	GPIO19_MTX_Y3_SDIO0D3_ETM29,
+	GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24,
+	GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25,
+	GPIO27_SDIO1D0_ETM30,
+	GPIO28_SDIO1D1_ETM31
+};
+
+static const gpio_defs_e vpm_jtagList[] = {
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK,
+	GPIO44_KEY_IN1_UART0_RTS_B_I2S1LRCIN_ETMCLK_VPMRTCK
+};
+static const gpio_defs_e pcm0List[] = {
+	GPIO08_MTX_X8_PCM0FS_I2S0LRCOUT,
+	GPIO09_MTX_X9_PCM0DI_I2S0DI,
+	GPIO33_PCM0CLK_I2S0BCLK,
+	GPIO34_PCM0D0_I2S0DO
+};
+static const gpio_defs_e pcm1List[] = {
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK
+};
+static const gpio_defs_e mtx_scanList[] = {
+	GPIO16_MTX_Y0_MTX_SCAN_DA_ETM26,
+	GPIO17_MTX_Y1_MTX_SCAN_CLK_ETM27
+};
+static const gpio_defs_e uart0_mdmList[] = {
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK
+};
+static const gpio_defs_e uart0_fcList[] = {
+	GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL,
+	GPIO44_KEY_IN1_UART0_RTS_B_I2S1LRCIN_ETMCLK_VPMRTCK
+};
+static const gpio_defs_e uart1List[] = {
+	GPIO14_UART1_TXD,
+	GPIO15_UART1_RXD
+};
+static const gpio_defs_e uart1_fcList[] = {
+	GPIO12_UART1_CTS_B,
+	GPIO13_UART1_RTS_B
+};
+static const gpio_defs_e i2chList[] = {
+	GPIO00_SCL_MTX_X0_EPHYLED_DATA,
+	GPIO01_SDA_MTX_X1_EPHYLED_CLK
+};
+static const gpio_defs_e i2ch_v2List[] = {
+	GPIO38_SDA_V2_SPI_V2,
+	GPIO39_SCL_V2_SPI_CLK_V2
+};
+static const gpio_defs_e usb0_pwronfltList[] = {
+	GPIO36_USB0_PWRON,
+	GPIO37_USB0_PWRFLT
+};
+static const gpio_defs_e usb1_pwronfltList[] = {
+	GPIO59_KEY_OUT7_ETM14_USB1_PWRON,
+	GPIO60_KEY_OUT8_ETM15_USB1_PWRFLT
+};
+static const gpio_defs_e spiList[] = {
+	GPIO22_SPI_MISO,
+	GPIO23_SPI_CLK,
+	GPIO24_SPI_MOSI
+};
+static const gpio_defs_e spisList[] = {
+	GPIO51_KEY_IN8_SPIS_MISO_ETM6,
+	GPIO55_KEY_OUT3_SPIS_CLK_ETM10,
+	GPIO56_KEY_OUT4_SPIS_MOSI_ETM11
+};
+static const gpio_defs_e i2csList[] = {
+	GPIO49_KEY_IN6_SSCL_ETM4,
+	GPIO50_KEY_IN7_SSDA_ETM5
+};
+static const gpio_defs_e sdio0_1List[] = {
+	GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24,
+	GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25,
+	GPIO29_SDIO0CMD,
+	GPIO30_SDIO0CLK,
+	GPIO31_SDIO0D0
+};
+static const gpio_defs_e sdio0_4List[] = {
+	GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24,
+	GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25,
+	GPIO29_SDIO0CMD,
+	GPIO30_SDIO0CLK,
+	GPIO31_SDIO0D0,
+	GPIO32_SDIO0D1,
+	GPIO18_MTX_Y2_SDIO0D2_ETM28,
+	GPIO19_MTX_Y3_SDIO0D3_ETM29
+};
+static const gpio_defs_e sdio0_8List[] = {
+	GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24,
+	GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25,
+	GPIO29_SDIO0CMD,
+	GPIO30_SDIO0CLK,
+	GPIO31_SDIO0D0,
+	GPIO32_SDIO0D1,
+	GPIO18_MTX_Y2_SDIO0D2_ETM28,
+	GPIO19_MTX_Y3_SDIO0D3_ETM29,
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK
+};
+static const gpio_defs_e sdio1_1List[] = {
+	GPIO10_MTX_X10_SDIO1CMD_ETM16,
+	GPIO11_MTX_X11_SDIO1CLK_ETM17,
+	GPIO27_SDIO1D0_ETM30
+};
+static const gpio_defs_e sdio1_4List[] = {
+	GPIO10_MTX_X10_SDIO1CMD_ETM16,
+	GPIO11_MTX_X11_SDIO1CLK_ETM17,
+	GPIO27_SDIO1D0_ETM30,
+	GPIO28_SDIO1D1_ETM31,
+	GPIO06_MTX_X6_SDIO1D2_ETM22,
+	GPIO07_MTX_X7_SDIO1D3_ETM23
+};
+static const gpio_defs_e i2s0List[] = {
+	GPIO08_MTX_X8_PCM0FS_I2S0LRCOUT,
+	GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL,
+	GPIO09_MTX_X9_PCM0DI_I2S0DI,
+	GPIO34_PCM0D0_I2S0DO,
+	GPIO33_PCM0CLK_I2S0BCLK,
+	GPIO45_KEY_IN2_ETM0_I2S0MCLK,
+};
+static const gpio_defs_e i2s1List[] = {
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK,
+	GPIO44_KEY_IN1_UART0_RTS_B_I2S1LRCIN_ETMCLK_VPMRTCK,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO26_I2S1MCLK,
+};
+
+/*
+ * A table of logical groupings of gpio pins. Each group has an associate group enum, and chipc
+ * gpio function, and a number of pins, followed by the pin numbers in a list. This table is used
+ * by the gpiomux_requestGroup() and gpiomux_freeGroup() functions to check for conflicts
+ * and to make chipc assignments.
+ */
+const gpiomux_group_t gpiomux_GroupList[] =
+{
+	{gpiomux_group_gphyled,		chipcHw_GPIO_FUNCTION_MISC,	ARRAY_LEN(gphyledList),		gphyledList},
+	{gpiomux_group_ext_gphy,	chipcHw_GPIO_FUNCTION_MISC,	ARRAY_LEN(ext_gphyList),	ext_gphyList},
+	{gpiomux_group_etm16,		chipcHw_GPIO_FUNCTION_ETM,	ARRAY_LEN(etm16List),		etm16List},
+	{gpiomux_group_etm32,		chipcHw_GPIO_FUNCTION_ETM,	ARRAY_LEN(etm32List),		etm32List},
+	{gpiomux_group_vpm_jtag,	chipcHw_GPIO_FUNCTION_MISC,	ARRAY_LEN(vpm_jtagList),	vpm_jtagList},
+	{gpiomux_group_pcm0,		chipcHw_GPIO_FUNCTION_PCM,	ARRAY_LEN(pcm0List),		pcm0List},
+	{gpiomux_group_pcm1,		chipcHw_GPIO_FUNCTION_PCM,	ARRAY_LEN(pcm1List),		pcm1List},
+	{gpiomux_group_mtx_scan,	chipcHw_GPIO_FUNCTION_LEDMTXS,	ARRAY_LEN(mtx_scanList),	mtx_scanList},
+	{gpiomux_group_uart0_mdm,	chipcHw_GPIO_FUNCTION_UART,	ARRAY_LEN(uart0_mdmList),	uart0_mdmList},
+	{gpiomux_group_uart0_fc,	chipcHw_GPIO_FUNCTION_UART,	ARRAY_LEN(uart0_fcList),	uart0_fcList},
+	{gpiomux_group_uart1,		chipcHw_GPIO_FUNCTION_UART,	ARRAY_LEN(uart1List),		uart1List},
+	{gpiomux_group_uart1_fc,	chipcHw_GPIO_FUNCTION_UART,	ARRAY_LEN(uart1_fcList),	uart1_fcList},
+	{gpiomux_group_i2ch,		chipcHw_GPIO_FUNCTION_I2CH,	ARRAY_LEN(i2chList),		i2chList},
+	{gpiomux_group_i2ch_v2,		chipcHw_GPIO_FUNCTION_I2CH,	ARRAY_LEN(i2ch_v2List),		i2ch_v2List},
+	{gpiomux_group_usb0_pwronflt,	chipcHw_GPIO_FUNCTION_MISC,	ARRAY_LEN(usb0_pwronfltList),	usb0_pwronfltList},
+	{gpiomux_group_usb1_pwronflt,	chipcHw_GPIO_FUNCTION_MISC,	ARRAY_LEN(usb1_pwronfltList),	usb1_pwronfltList},
+	{gpiomux_group_spi,		chipcHw_GPIO_FUNCTION_SPI,	ARRAY_LEN(spiList),		spiList},
+	{gpiomux_group_spis,		chipcHw_GPIO_FUNCTION_DEBUG,	ARRAY_LEN(spisList),		spisList},
+	{gpiomux_group_i2cs,		chipcHw_GPIO_FUNCTION_DEBUG,	ARRAY_LEN(i2csList),		i2csList},
+	{gpiomux_group_sdio0_1,		chipcHw_GPIO_FUNCTION_SDIO0,	ARRAY_LEN(sdio0_1List),		sdio0_1List},
+	{gpiomux_group_sdio0_4,		chipcHw_GPIO_FUNCTION_SDIO0,	ARRAY_LEN(sdio0_4List),		sdio0_4List},
+	{gpiomux_group_sdio0_8,		chipcHw_GPIO_FUNCTION_SDIO0,	ARRAY_LEN(sdio0_8List),		sdio0_8List},
+	{gpiomux_group_sdio1_1,		chipcHw_GPIO_FUNCTION_SDIO1,	ARRAY_LEN(sdio1_1List),		sdio1_1List},
+	{gpiomux_group_sdio1_4,		chipcHw_GPIO_FUNCTION_SDIO1,	ARRAY_LEN(sdio1_4List),		sdio1_4List},
+	{gpiomux_group_i2s0,		chipcHw_GPIO_FUNCTION_I2S,	ARRAY_LEN(i2s0List),		i2s0List},
+	{gpiomux_group_i2s1,		chipcHw_GPIO_FUNCTION_I2S,	ARRAY_LEN(i2s1List),		i2s1List},
+};
+
+
+/* global init structure */
+static gpiomux_init_t gInit;
+
+/* ---- Private Functions ------------------------------------------------- */
+/* ---- Functions ----------------------------------------------------------*/
+/****************************************************************************/
+/**
+*  @brief   gpiomux_Init
+*
+*  Used to initialize the mux table and set all pin functions to GPIO.
+*
+*  @return
+*     none
+*/
+/****************************************************************************/
+void gpiomux_Init
+(
+   gpiomux_init_t *initp   /* [IN] initialization structure pointer */
+)
+{
+	unsigned int i;
+	for (i = 0; i < gpio_defs_MAX_PINS; i++) {
+		if ((i != GPIO14_UART1_TXD) && (i != GPIO15_UART1_RXD))
+			chipcHw_setGpioPinFunction((int)i, chipcHw_GPIO_FUNCTION_GPIO);
+	}
+	gInit = *initp;		/* structure copy */
+	initialized = 1;
+}
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_request
+*
+*  Used to register a function with the gpiomux. It is acceptable to
+*  use the GPIO function as an argument when simple gpio reservations
+*  are required, in which case we don't activate the mux.
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_request
+(
+   gpio_defs_e pin,                    /* [IN] GPIO pin */
+   chipcHw_GPIO_FUNCTION_e function,   /* [IN] GPIO pin function */
+   const char *label                   /* [IN] description of pin usage */
+)
+{
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if (pin >= gpio_defs_MAX_PINS)
+		return gpiomux_rc_BADPIN;
+
+#if FORCE_CONFLICT_CHECK
+	if (chipcHw_getGpioPinFunction(pin) != chipcHw_GPIO_FUNCTION_GPIO) {
+		DBGPRINT("pin=%d gpiomux_rc_ASSIGNED - chipcHw_getGpioPinFunction(pin) != chipcHw_GPIO_FUNCTION_GPIO\n", pin);
+		return gpiomux_rc_ASSIGNED;	/* Pin function already assigned, exit */
+	}
+#endif
+
+	if ((gInit.request_gpio) && (gInit.request_gpio(pin, label) < 0)) {
+		DBGPRINT("pin=%d gpiomux_rc_CONFLICT - (gInit.request_gpio(pin, label) < 0)\n", pin);
+		return gpiomux_rc_CONFLICT;	/* Could not request this pin externally */
+	}
+
+	/* Assign new function */
+	chipcHw_setGpioPinFunction((int)pin, function);
+
+	return gpiomux_rc_SUCCESS;
+}
+EXPORT_SYMBOL(gpiomux_request);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_free
+*
+*  Used to deregister a pin assignment
+*
+*  @return
+*     success - assigned function was unregistered
+*     notfound - there was not registered function for this pin
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_free
+(
+   gpio_defs_e pin                    /* [IN] GPIO pin */
+)
+{
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if (pin >= gpio_defs_MAX_PINS)
+		return gpiomux_rc_BADPIN;
+
+	/*
+	 * If a user is reserving a gpio pin for a GPIO function and
+	 * does not require the mux, then the free must not fail if
+	 * the assigned function is GPIO, so we don't need to do a
+	 * conflict check here similar to the gpiomux_freeGroup() (to
+	 * make sure the current function is assigned).
+	 */
+
+	/* Free the pin externally */
+	if (gInit.free_gpio)
+		gInit.free_gpio(pin);
+
+	/* Revert back to default gpio function */
+	chipcHw_setGpioPinFunction((int)pin, chipcHw_GPIO_FUNCTION_GPIO);
+
+	return gpiomux_rc_SUCCESS;
+}
+EXPORT_SYMBOL(gpiomux_free);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_requestGroup
+*
+*  Used to register a logical group of pin functions with the gpiomux
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_requestGroup
+(
+   const gpiomux_group_e group,        /* [IN] GPIO group */
+   const char *label                   /* [IN] description of group usage */
+)
+{
+	unsigned int groupidx;
+	const gpiomux_group_t *groupp;
+
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if (group >= gpiomux_group_MaxNum)
+		return gpiomux_rc_BADGROUP;
+
+	/* Check for conflicts before assigning functions */
+	for (groupidx = 0; groupidx < ARRAY_LEN(gpiomux_GroupList); groupidx++) {
+		/* Find matching list */
+		groupp = &gpiomux_GroupList[groupidx];
+		if (groupp->group == group) {
+			unsigned int pinidx;
+
+			for (pinidx = 0; pinidx < groupp->numPins; pinidx++) {
+				const char *str;
+				unsigned int pin = groupp->listp[pinidx];
+
+#if FORCE_CONFLICT_CHECK
+				if (chipcHw_getGpioPinFunction(pin) != chipcHw_GPIO_FUNCTION_GPIO) {
+					DBGPRINT("group=%d pin=%d gpiomux_rc_ASSIGNED - chipcHw_getGpioPinFunction(pin) != chipcHw_GPIO_FUNCTION_GPIO\n", group, pin);
+					return gpiomux_rc_ASSIGNED;	/* Pin function already assigned, exit */
+				}
+#endif
+				str = gInit.is_requested(pin);
+				if (gInit.is_requested && (str != NULL)) {
+					DBGPRINT("group=%d pin=%d ggpiomux_rc_CONFLICT - gInit.is_requested && (gInit.is_requested(pin) != NULL) \'%s\'\n", group, pin, str);
+					return gpiomux_rc_CONFLICT;	/* Pin already assigned externally, exit */
+				}
+			}
+
+			/* Pins all unassigned, so assign new functions now. */
+			for (pinidx = 0; pinidx < groupp->numPins; pinidx++) {
+				int pin = groupp->listp[pinidx];
+				int rc = gpiomux_request(pin, groupp->function, label);
+				if (rc != 0) {
+					DBGPRINT("ERROR gpiomux_request group=%d pin=%d rc=%d\n", group, pin, rc);
+					return rc;
+				}
+			}
+			break;
+		}
+	}
+	return gpiomux_rc_SUCCESS;
+}
+EXPORT_SYMBOL(gpiomux_requestGroup);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_freeGroup
+*
+*  Used to deregister a logical set of pin functions
+*
+*  @return
+*     success - assigned function was unregistered
+*     notfound - there was not registered function for this pin
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_freeGroup
+(
+   gpiomux_group_e group                  /* [IN] GPIO group */
+)
+{
+	unsigned int groupidx;
+	const gpiomux_group_t *groupp;
+
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if (group >= gpiomux_group_MaxNum)
+		return gpiomux_rc_BADGROUP;
+
+	/* Check for conflicts before deassigning functions */
+	for (groupidx = 0; groupidx < ARRAY_LEN(gpiomux_GroupList); groupidx++) {
+		/* Find matching list */
+		groupp = &gpiomux_GroupList[groupidx];
+		if (groupp->group == group) {
+			unsigned int pinidx;
+			for (pinidx = 0; pinidx < groupp->numPins; pinidx++) {
+				unsigned int pin = groupp->listp[pinidx];
+#if FORCE_CONFLICT_CHECK
+				if (chipcHw_getGpioPinFunction(pin) == chipcHw_GPIO_FUNCTION_GPIO) {
+					DBGPRINT("group=%d pin=%d gpiomux_rc_UNASSIGNED - chipcHw_getGpioPinFunction(pin) == chipcHw_GPIO_FUNCTION_GPIO\n", group, pin);
+					return gpiomux_rc_UNASSIGNED;	/* pin already unassigned, cannot free */
+				}
+#endif
+				/* Do not free an already externally freed pin */
+				if (gInit.is_requested && (gInit.is_requested(pin) == NULL)) {
+					DBGPRINT("group=%d pin=%d gpiomux_rc_CONFLICT - gInit.is_requested && (gInit.is_requested(pin) != NULL)\n", group, pin);
+					return gpiomux_rc_CONFLICT;	/* Pin already assigned externally, exit */
+				}
+			}
+			/* Pins all unassigned, so revert to GPIO function now. */
+			for (pinidx = 0; pinidx < groupp->numPins; pinidx++) {
+				unsigned int pin = groupp->listp[pinidx];
+				gpiomux_free(pin); /* cannot fail or we have a logic error */
+			}
+			break;
+		}
+	}
+	return gpiomux_rc_SUCCESS;
+}
+EXPORT_SYMBOL(gpiomux_freeGroup);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_requestKeypad
+*
+*  Used to register a logical set of pin functions with the gpiomux. If the
+*  keypad pins are not sequential, then use the individual setPin functions.
+*  Example: gpiomux_requestKeypad(0,5,0,4);
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_requestKeypad
+(
+   uint8_t in_first,                /* [IN] keypad_in[in_first] is start of array */
+   uint8_t in_last,                 /* [IN] keypad_in[in_last] is end of array */
+   uint8_t out_first,               /* [IN] keypad_out[out_first] is start of array */
+   uint8_t out_last,                /* [IN] keypad_out[out_last] is end of array */
+   const char *label                /* [IN] description of group usage */
+)
+{
+	int i;
+	gpiomux_rc_e rc;
+
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if ((in_last > GPIO_MAX_INKEY_IDX) || (in_first > in_last))
+		return gpiomux_rc_BADPIN;
+
+	if ((out_last > GPIO_MAX_OUTKEY_IDX) || (out_first > in_last))
+		return gpiomux_rc_BADPIN;
+
+	for (i = in_first; i < (in_last+1); i++) {
+		rc = gpiomux_request(GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL+i, chipcHw_GPIO_FUNCTION_KEYPAD, label);
+		if (rc != gpiomux_rc_SUCCESS) {
+			DBGPRINT("rc != gpiomux_rc_SUCCESS rc=%d\n", rc);
+			return rc;
+		}
+	}
+	for (i = out_first; i < (out_last+1); i++) {
+		rc = gpiomux_request(GPIO52_KEY_OUT0_ETM7+i, chipcHw_GPIO_FUNCTION_KEYPAD, label);
+		if (rc != gpiomux_rc_SUCCESS) {
+			DBGPRINT("rc != gpiomux_rc_SUCCESS rc=%d\n", rc);
+			return rc;
+		}
+	}
+	return gpiomux_rc_SUCCESS;
+}
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_freeKeypad
+*
+*  Used to deregister a logical set of keypad pin functions
+*
+*  @return
+*     success - assigned function was unregistered
+*     notfound - one or more pins were not registered for the keypad
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_freeKeypad
+(
+   uint8_t in_first,                /* [IN] keypad_in[in_first] is start of array */
+   uint8_t in_last,                 /* [IN] keypad_in[in_last] is end of array */
+   uint8_t out_first,               /* [IN] keypad_out[out_first] is start of array */
+   uint8_t out_last                 /* [IN] keypad_out[out_last] is end of array */
+)
+{
+	int i;
+	gpiomux_rc_e rc;
+
+	if (!initialized)
+		return gpiomux_rc_UNINITIALIZED;
+
+	if ((in_last > GPIO_MAX_INKEY_IDX) || (in_first > in_last))
+		return gpiomux_rc_BADPIN;
+
+	if ((out_last > GPIO_MAX_OUTKEY_IDX) || (out_first > in_last))
+		return gpiomux_rc_BADPIN;
+
+	for (i = in_first; i < (in_last+1); i++) {
+		rc = gpiomux_free(GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL+i);
+		if (rc != gpiomux_rc_SUCCESS) {
+			DBGPRINT("rc != INKEY gpiomux_rc_SUCCESS rc=%d\n", rc);
+			return rc;
+		}
+	}
+	for (i = out_first; i < (out_last+1); i++) {
+		rc = gpiomux_free(GPIO52_KEY_OUT0_ETM7+i);
+		if (rc != gpiomux_rc_SUCCESS) {
+			DBGPRINT("rc != OUTKEY gpiomux_rc_SUCCESS rc=%d\n", rc);
+			return rc;
+		}
+	}
+	return gpiomux_rc_SUCCESS;
+}
+
+
diff --git a/arch/arm/mach-bcmring/gpio.c b/arch/arm/mach-bcmring/gpio.c
new file mode 100644
index 0000000..d81a79d
--- /dev/null
+++ b/arch/arm/mach-bcmring/gpio.c
@@ -0,0 +1,280 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+/****************************************************************************
+*
+*  gpio.c
+*
+*  PURPOSE:
+*
+*       This file implements the GPIO chips required to support the onchip
+*       gpio pins, as per gpiolib
+*
+*****************************************************************************/
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include <linux/irq.h>
+
+#include <mach/gpio.h>
+#include <mach/gpio_defs.h>
+#include <mach/csp/gpiomux.h>
+#include <mach/csp/chipcHw_inline.h>
+
+/* ---- Public Variables ------------------------------------------------- */
+
+/* ---- Private Constants and Types -------------------------------------- */
+
+typedef struct {
+	struct gpio_chip chip;
+	volatile GPIOHW_REG_t  *reg;
+} bcmring_gpio_chip;
+
+/* ---- Private Function Prototypes -------------------------------------- */
+
+/* ---- Private Variables ------------------------------------------------ */
+
+/* ---- Functions -------------------------------------------------------- */
+
+/****************************************************************************
+*
+*  Called whenever gpio_request is called. This will force the pin to be
+*  a GPIO pin. If you want it to be something else, then gpiomux_request
+*  should be called instead.
+*
+*****************************************************************************/
+
+static int gpio_bcmring_request(struct gpio_chip *chip, unsigned offset)
+{
+	unsigned gpio;
+	bcmring_gpio_chip	   *bcmring_chip = container_of(chip, bcmring_gpio_chip, chip);
+
+	gpio = bcmring_chip->chip.base + offset;
+
+	/*
+	 * Ensure that the pin is actually configured as a GPIO. If it isn't then
+	 * that means that somebody called chipcHW_setGpioPinFunction directly
+	 * which is a no-no.
+	 */
+
+	if (chipcHw_getGpioPinFunction(gpio) != chipcHw_GPIO_FUNCTION_GPIO) {
+		printk(KERN_ERR "%s: Error - gpio %d not configured as a GPIO pin\n", __func__, gpio);
+		return -EBUSY;
+	}
+
+	return 0;
+
+} /* gpio_bcmring_request */
+
+/****************************************************************************
+*
+*  Configure a GPIO pin as an input pin
+*
+*****************************************************************************/
+
+static int gpio_bcmring_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	bcmring_gpio_chip *bcmring_chip = container_of(chip, bcmring_gpio_chip, chip);
+
+	GpioHwReg_SetDirInput(bcmring_chip->reg, offset);
+
+	return 0;
+} /* gpio_bcmring_direction_input */
+
+/****************************************************************************
+*
+*  Configure a GPIO pin as an output pin and sets its initial value.
+*
+*****************************************************************************/
+
+static int gpio_bcmring_direction_output(struct gpio_chip *chip, unsigned offset, int value)
+{
+	bcmring_gpio_chip *bcmring_chip = container_of(chip, bcmring_gpio_chip, chip);
+
+	GpioHwReg_SetValDirOutput(bcmring_chip->reg, offset, value);
+
+	return 0;
+} /* gpio_bcmring_direction_output */
+
+/****************************************************************************
+*
+*  Retrieve the value of a GPIO pin. Note that this returns zero or the raw
+*   value.
+*
+*****************************************************************************/
+
+static int gpio_bcmring_get(struct gpio_chip *chip, unsigned offset)
+{
+	bcmring_gpio_chip *bcmring_chip = container_of(chip, bcmring_gpio_chip, chip);
+	int val;
+
+	val = GpioHwReg_GetVal(bcmring_chip->reg, offset);
+
+	return val;
+} /* gpio_bcmring_get */
+
+/****************************************************************************
+*
+*  Set the value of a GPIO pin
+*
+*****************************************************************************/
+
+static void gpio_bcmring_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	bcmring_gpio_chip *bcmring_chip = container_of(chip, bcmring_gpio_chip, chip);
+	GpioHwReg_SetVal(bcmring_chip->reg, offset, value);
+} /* gpio_bcmring_set */
+
+
+/****************************************************************************
+*
+*  gpiolib chip description
+*
+*****************************************************************************/
+
+/*
+ * Note: If you need to add a field, like a register base, then create a new
+ *       structure which includes the gpio_chip as the first element and has
+ *       the custom fields after. See asm-arm/arch-pxa/gpio.c for an example.
+ */
+
+static bcmring_gpio_chip gpio_bcmring_chip[] =
+{
+	[0] =
+	{
+		.reg  = gpioRegP(0),
+		.chip =
+		{
+			.label			= "bcmring-low",
+			.request		= gpio_bcmring_request,
+			.direction_input	= gpio_bcmring_direction_input,
+			.direction_output	= gpio_bcmring_direction_output,
+			.get			= gpio_bcmring_get,
+			.set			= gpio_bcmring_set,
+			.base			= 0,
+			.ngpio			= GPIOHW_NUM_PINS_LOWER_BLOCK,
+		},
+	},
+	[1] =
+	{
+		.reg  = gpioRegP(1),
+		.chip =
+		{
+			.label			= "bcmring-high",
+			.request		= gpio_bcmring_request,
+			.direction_input	= gpio_bcmring_direction_input,
+			.direction_output	= gpio_bcmring_direction_output,
+			.get			= gpio_bcmring_get,
+			.set			= gpio_bcmring_set,
+			.base			= GPIOHW_NUM_PINS_LOWER_BLOCK,
+			.ngpio			= GPIOHW_NUM_PINS_HIGHER_BLOCK,
+		},
+	},
+};
+
+/****************************************************************************/
+/**
+*  @brief   mux_isRequested
+*
+*  Find out if a gpio pin has already been requested in the gpiolib sense.
+*
+*  @return
+*     none
+*/
+/****************************************************************************/
+static const char *mux_isRequested(gpio_defs_e pin)
+{
+	int i;
+
+	/*
+	 * For now, convert pin number to chip and offset.  Later, convert this
+	 * into a gpiomux register/chip array structure. Since this is
+	 * typically init time code, it may not be worth worrying about for
+	 * this one case.
+	 */
+	for (i = 0; i < ARRAY_LEN(gpio_bcmring_chip); i++) {
+		struct gpio_chip *chipp = &gpio_bcmring_chip[i].chip;
+		int base = chipp->base;
+		if ((pin >= base) && (pin < base + chipp->ngpio))
+			return gpiochip_is_requested(chipp, pin - base);
+	}
+
+	return NULL;
+} /* mux_isRequested */
+
+/****************************************************************************/
+/**
+*  @brief   mux_request
+*
+*  Request a pin from gpiolib.
+*
+*/
+/****************************************************************************/
+static int mux_request(gpio_defs_e pin, const char *label)
+{
+	return gpio_request(pin, label);
+} /* mux_request */
+
+/****************************************************************************/
+/**
+*  @brief   mux_free
+*
+*  Free a pin from gpiolib.
+*
+*/
+/****************************************************************************/
+static void mux_free(gpio_defs_e pin)
+{
+	return gpio_free(pin);
+} /* mux_free */
+
+/****************************************************************************
+*
+*  brcm_init_gpio
+*
+*   Sets up gpiolib so that it's aware of how to manipulate our GPIOs
+*
+*****************************************************************************/
+
+void __init brcm_init_gpio(void)
+{
+	gpiomux_init_t initstruct;
+
+	gpiochip_add(&gpio_bcmring_chip[0].chip);
+	gpiochip_add(&gpio_bcmring_chip[1].chip);
+
+	/* Initialize callbacks for gpiomux function calls into gpiolib */
+	initstruct.request_gpio = mux_request;
+	initstruct.free_gpio = mux_free;
+	initstruct.is_requested = mux_isRequested;
+	gpiomux_Init(&initstruct);
+
+	/*
+	 * gpiomux_Init skips pins 14 and 15 (which makes sense when gpiomux_Init
+	 * is called from within the bootloaders.
+	 *
+	 * However, from this point forward in the code, gpiolib "owns" the pins. So
+	 * if you want these pins to be UART1, then you should call gpiomux_request
+	 * after this so that the pins gets reserved inside gpiolib.
+	 */
+	chipcHw_setGpioPinFunction(GPIO14_UART1_TXD, chipcHw_GPIO_FUNCTION_GPIO);
+	chipcHw_setGpioPinFunction(GPIO15_UART1_RXD, chipcHw_GPIO_FUNCTION_GPIO);
+} /* brcm_init_gpio */
+
diff --git a/arch/arm/mach-bcmring/gpio_irq.c b/arch/arm/mach-bcmring/gpio_irq.c
new file mode 100644
index 0000000..c3c079c
--- /dev/null
+++ b/arch/arm/mach-bcmring/gpio_irq.c
@@ -0,0 +1,379 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/*
+*
+*****************************************************************************
+*
+*  gpio_irq.c
+*
+*  PURPOSE:
+*
+*     This implements the gpio driver interrupt rising/falling edge driver.
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <mach/gpio_irq.h>
+#include <linux/gpio.h>
+#include <asm/mach/irq.h>
+
+#include <mach/gpio.h>
+#include <mach/gpio_defs.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <csp/gpioHw.h>
+#include <mach/csp/gpioHw_inline.h>
+
+/* ---- Public Variables ------------------------------------------------- */
+
+/* ---- Private Constants and Types -------------------------------------- */
+
+/* Debug logging */
+#ifdef DEBUG
+#undef DEBUG
+#endif
+#define DEBUG 1
+
+#define DBG_ERROR	0x01
+#define DBG_INFO	0x02
+#define DBG_TRACE	0x04
+#define DBG_TRACE2	0x08
+#define DBG_DATA	0x10
+#define DBG_DATA2	0x20
+
+#define DBG_DEFAULT_LEVEL	(DBG_ERROR | DBG_INFO)
+
+#if DEBUG
+#	define GPIO_DEBUG(level, x) { if (level & gLevel) printk x; }
+#else
+#	define GPIO_DEBUG(level, x)
+#endif
+
+
+static char banner[] __initdata = KERN_INFO "GPIO Control Driver: 1.00 (built on "__DATE__" "__TIME__")\n";
+static int gLevel = DBG_DEFAULT_LEVEL;
+
+/* ---- Private Variables ------------------------------------------------ */
+
+/* ---- Functions -------------------------------------------------------- */
+
+/****************************************************************************
+*
+*  gpio_irq_ack
+*
+*     Called by the interrupt handler to acknowledge (i.e. clear)
+*     the interrupt.
+*
+***************************************************************************/
+
+static void gpio_irq_ack(unsigned irq)
+{
+	/*
+	 * Since this function is ONLY called with interrupts disabled, we
+	 * don't need to disable irqs around the following
+	 */
+
+	GpioHw_IrqClear(irq_to_gpio(irq));
+}
+
+/****************************************************************************
+*
+*  gpio_irq_mask
+*
+*     Called to mask (i.e. disable) an interrupt.
+*
+***************************************************************************/
+
+static void gpio_irq_mask(unsigned irq)
+{
+	/*
+	 * Since this function is ONLY called with interrupts disabled, we
+	 * don't need to disable irqs around the following
+	 */
+
+	GpioHw_IrqDisable(irq_to_gpio(irq));
+}
+
+/****************************************************************************
+*
+*  gpio_irq_unmask
+*
+*     Called to unmask (i.e. enable) an interrupt.
+*
+***************************************************************************/
+
+static void gpio_irq_unmask(unsigned irq)
+{
+	/*
+	 * Since this function is ONLY called with interrupts disabled, we
+	 * don't need to disable irqs around the following
+	 */
+
+	GpioHw_IrqEnable(irq_to_gpio(irq));
+}
+
+/****************************************************************************
+*
+*  gpio_irq_type
+*
+*     Sets the type of the GPIO irq.
+*
+***************************************************************************/
+
+static int gpio_irq_set_type(unsigned irq, unsigned type)
+{
+	int	gpio;
+
+	gpio = irq_to_gpio(irq);
+
+	/*
+	 * Since this function is ONLY called with interrupts disabled, we
+	 * don't need to disable irqs around the following
+	 */
+
+	if (type == IRQ_TYPE_PROBE) {
+		/* Don't mess GPIOs which already have interrupt handlers registered. */
+
+		if (GpioHw_IsIrqEnabled(gpio) == GPIOHW_IRQ_UNMASKED_INTERRUPT)
+			return 0;
+
+		type = IRQ_TYPE_EDGE_BOTH;
+	}
+
+	printk(KERN_INFO "IRQ%d (gpio%d): ", irq, gpio);
+
+	GpioHw_IrqDisable(gpio);
+	GpioHw_SetDirInput(gpio);
+	GpioHw_IrqClear(gpio);
+	GpioHw_IrqEnable(gpio);
+
+	if (type & IRQ_TYPE_EDGE_RISING) {
+		if (type & IRQ_TYPE_EDGE_FALLING) {
+			printk(KERN_INFO "both edges\n");
+			GpioHw_SetIrqType(gpio, GPIOHW_INTERRUPT_TYPE_EDGE_BOTH);
+		} else {
+			printk(KERN_INFO "rising edges\n");
+			GpioHw_SetIrqType(gpio, GPIOHW_INTERRUPT_TYPE_EDGE_RISING);
+		}
+	} else if (type & IRQ_TYPE_EDGE_FALLING) {
+		printk(KERN_INFO "falling edges\n");
+		GpioHw_SetIrqType(gpio, GPIOHW_INTERRUPT_TYPE_EDGE_FALLING);
+	} else if (type & IRQ_TYPE_LEVEL_HIGH) {
+		printk(KERN_INFO "high level\n");
+		GpioHw_SetIrqType(gpio, GPIOHW_INTERRUPT_TYPE_LEVEL_HIGH);
+	} else if (type & IRQ_TYPE_LEVEL_LOW) {
+		printk(KERN_INFO "low level\n");
+		GpioHw_SetIrqType(gpio, GPIOHW_INTERRUPT_TYPE_LEVEL_LOW);
+	} else {
+		printk(KERN_ERR "no edges\n");
+		printk(KERN_ERR "%s: Failed to set type for IRQ%d (gpio%d): ", __func__, irq, gpio);
+		GpioHw_IrqDisable(gpio);
+		return -EINVAL;
+	}
+
+	return 0;
+
+} /* gpio_irq_set_type */
+
+/****************************************************************************
+*
+*  gpio_isr_handler0
+*
+*     Figures out which GPIO caused the interrupt and calls the register
+*     handler to deal with it.
+*
+*     The handler function will in all likelyhood be do_edge_IRQ.
+*
+***************************************************************************/
+
+static void gpio_isr_handler0(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned mask;
+	int loop;
+
+	do {
+		loop = 0;
+
+		mask = GpioHw_GetMaskIrqRegStatus(GPIOHW_BLOCK_LOW);
+		if (mask) {
+			/* Clear the interrupts */
+
+			GpioHw_IrqClearReg(GPIOHW_BLOCK_LOW, mask);
+
+			irq = gpio_to_irq(0);
+			desc = irq_desc + irq;
+			do {
+				if (mask & 1)
+					desc->handle_irq(irq, desc);
+				irq++;
+				desc++;
+				mask >>= 1;
+
+			} while (mask);
+
+			loop = 1;
+		}
+
+	} while (loop);
+
+} /* gpio_isr_handler0 */
+
+/****************************************************************************
+*
+*  gpio_isr_handler1
+*
+*     Figures out which GPIO caused the interrupt and calls the register
+*     handler to deal with it.
+*
+*     The handler function will in all likelyhood be do_edge_IRQ.
+*
+***************************************************************************/
+
+static void gpio_isr_handler1(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned mask;
+	int loop;
+
+	do {
+		loop = 0;
+
+		mask = GpioHw_GetMaskIrqRegStatus(GPIOHW_BLOCK_HIGH);
+		if (mask) {
+			/* Clear the interrupts */
+
+			GpioHw_IrqClearReg(GPIOHW_BLOCK_HIGH, mask);
+
+			irq = gpio_to_irq(32);
+			desc = irq_desc + irq;
+			do {
+				if (mask & 1)
+					desc->handle_irq(irq, desc);
+				irq++;
+				desc++;
+				mask >>= 1;
+
+			} while (mask);
+
+			loop = 1;
+		}
+
+	} while (loop);
+
+} /* gpio_isr_handler1 */
+
+/****************************************************************************
+*
+*  gpio_chip data structure.
+*
+***************************************************************************/
+
+static struct irq_chip gpio_chip = {
+	.typename	= "GPIO-IRQ",
+	.ack		= gpio_irq_ack,
+	.mask		= gpio_irq_mask,
+	.unmask		= gpio_irq_unmask,
+	.set_type	= gpio_irq_set_type,
+};
+
+/****************************************************************************
+*
+*  gpio_cleanup
+*
+*       Called to perform module cleanup when the module is unloaded.
+*
+***************************************************************************/
+static void gpio_cleanup(void)
+{
+	GPIO_DEBUG(DBG_TRACE, ("gpio_cleanup()\n"));
+
+}
+
+/****************************************************************************
+*
+*  gpio_init
+*
+*     Called to perform module initialization when the module is loaded
+*
+***************************************************************************/
+
+static int __init gpio_init(void)
+{
+	/* Initialize debug level */
+	gLevel = DBG_DEFAULT_LEVEL;
+
+	GPIO_DEBUG(DBG_INFO, ("gpio_init called\n"));
+
+	printk(banner);
+	{
+		int	irq;
+
+		for (irq = gpio_to_irq(0); irq <= gpio_to_irq(NUM_GPIO_IRQS-1); irq++) {
+			set_irq_chip(irq, &gpio_chip);
+			set_irq_handler(irq, handle_edge_irq);
+			set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		}
+		set_irq_chained_handler(IRQ_GPIO0, gpio_isr_handler0);
+		set_irq_chained_handler(IRQ_GPIO1, gpio_isr_handler1);
+	}
+
+	return 0;
+} /* gpio_init */
+
+/****************************************************************************
+*
+*  gpio_exit
+*
+*       Called to perform module cleanup when the module is unloaded.
+*
+***************************************************************************/
+
+static void __exit gpio_exit(void)
+{
+	GPIO_DEBUG(DBG_INFO, ("gpio_exit called\n"));
+
+	gpio_cleanup();
+} /* gpio_exit */
+
+/* Changed from module_init to fs_initcall so that GPIO driver
+ * is loaded before the any of the PMU drivers were loaded on
+ * other products - leave it this way for future.
+ */
+
+fs_initcall(gpio_init);
+module_exit(gpio_exit);
+
+MODULE_AUTHOR("Broadcom");
+MODULE_DESCRIPTION("GPIO Control Driver");
+MODULE_LICENSE("GPL v2");
+
+
+
diff --git a/arch/arm/mach-bcmring/include/csp/gpioHw.h b/arch/arm/mach-bcmring/include/csp/gpioHw.h
new file mode 100644
index 0000000..eeb7379
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/csp/gpioHw.h
@@ -0,0 +1,71 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    gpioHw.h
+*
+*  @brief   API definitions for low level gpio device driver
+*
+*/
+/****************************************************************************/
+
+#ifndef GPIOHW_H
+#define GPIOHW_H
+
+/* ---- Include Files ----------------------------------------------------- */
+
+#include <csp/stdint.h>
+
+/* ---- Public Constants and Types ---------------------------------------- */
+
+typedef enum {
+	GPIOHW_BLOCK_LOW = 0,
+	GPIOHW_BLOCK_HIGH
+
+} GPIOHW_BLOCK_LEVEL;
+
+typedef enum {
+	GPIOHW_DIR_INPUT = 0,
+	GPIOHW_DIR_OUTPUT,
+
+} GPIOHW_DIRECTION;
+
+typedef enum {
+	GPIOHW_IRQ_UNMASKED_INTERRUPT = 0,
+	GPIOHW_IRQ_MASKED_INTERRUPT,
+
+} GPIOHW_IRQ_MASK_STATE;
+
+typedef enum {
+	GPIOHW_INTERRUPT_TYPE_LEVEL_HIGH = 0,
+	GPIOHW_INTERRUPT_TYPE_LEVEL_LOW,
+	GPIOHW_INTERRUPT_TYPE_EDGE_RISING,
+	GPIOHW_INTERRUPT_TYPE_EDGE_FALLING,
+	GPIOHW_INTERRUPT_TYPE_EDGE_BOTH
+
+} GPIOHW_INTERRUPT_TYPE;
+
+typedef enum {
+	GPIOHW_MODE_CONTROL_SELECT_SOFTWARE = 0,
+	GPIOHW_MODE_CONTROL_SELECT_HARDWARE
+
+} GPIOHW_MODE_CONTROL_SELECT;
+
+#include <mach/csp/gpioHw_inline.h>
+
+#endif /* GPIOHW_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/gpioHw_inline.h b/arch/arm/mach-bcmring/include/mach/csp/gpioHw_inline.h
new file mode 100644
index 0000000..f586161
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/gpioHw_inline.h
@@ -0,0 +1,323 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+#ifndef GPIOHW_INLINE_H
+#define GPIOHW_INLINE_H
+
+#ifndef GPIOHW_H
+#error *** Do not include gpioHw_inline.h directly. Use gpioHw.h instead. ***
+#endif
+
+/* ---- Include Files ---------------------------------------------------- */
+#include <mach/csp/mm_io.h>
+#include <mach/csp/gpioHw_reg.h>
+#include <csp/reg.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+
+static inline void GpioHwReg_SetDirOutput(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Set bit to set to output direction */
+	reg32_set_bits(&regp->gpioDir, gpioMask);
+}
+
+static inline void GpioHwReg_SetDirInput(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Clear bit to set to input direction */
+	reg32_clear_bits(&regp->gpioDir, gpioMask);
+}
+
+static inline GPIOHW_DIRECTION GpioHwReg_GetDir(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Check register against mask and return if set to input or output */
+	return (reg32_read(&regp->gpioDir) & gpioMask) ? GPIOHW_DIR_OUTPUT : GPIOHW_DIR_INPUT;
+}
+
+static inline void GpioHwReg_SetVal(volatile GPIOHW_REG_t *regp, unsigned int gpioNum, int setVal)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	if (setVal) {
+		/* Set data bit */
+		reg32_set_bits(&regp->gpioData, gpioMask);
+	} else {
+		/* Clear data bit */
+		reg32_clear_bits(&regp->gpioData, gpioMask);
+	}
+}
+
+static inline void GpioHwReg_SetValDirOutput(volatile GPIOHW_REG_t *regp, unsigned int gpioNum, int setVal)
+{
+	REG_LOCAL_IRQ_SAVE;
+	/*
+	 * The hardware ignores sets to the data register when the pin is configured as an
+	 * input, so we need to set the direction before setting the value.
+	 */
+	GpioHwReg_SetDirOutput(regp, gpioNum);
+	GpioHwReg_SetVal(regp, gpioNum, setVal);
+	REG_LOCAL_IRQ_RESTORE;
+}
+
+static inline int GpioHwReg_GetVal(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+	return (reg32_read(&regp->gpioData) & gpioMask) ? 1 : 0;
+}
+
+static inline void GpioHwReg_IrqEnable(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Set register bit to unmask interrupt */
+	reg32_set_bits(&regp->gpioIe, gpioMask);
+}
+
+static inline void GpioHwReg_IrqDisable(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Clear register bit to mask interrupt */
+	reg32_clear_bits(&regp->gpioIe, gpioMask);
+}
+
+static inline GPIOHW_IRQ_MASK_STATE GpioHwReg_IsIrqEnabled(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+	return (reg32_read(&regp->gpioIe) & gpioMask) ? GPIOHW_IRQ_MASKED_INTERRUPT : GPIOHW_IRQ_UNMASKED_INTERRUPT;
+}
+
+static inline void GpioHwReg_IrqClear(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+
+	/* Raise register bit to clear interrupt status */
+	reg32_set_bits(&regp->gpioIc, gpioMask);
+}
+
+static inline void GpioHwReg_IrqClearReg(volatile GPIOHW_REG_t *regp, uint32_t mask)
+{
+	/* Raise register bit to clear interrupt status */
+	reg32_set_bits(&regp->gpioIc, mask);
+}
+
+static inline int GpioHwReg_GetRawIrqStatus(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+	return (reg32_read(&regp->gpioRis) & gpioMask) ? 1 : 0;
+}
+
+static inline int GpioHwReg_GetMaskIrqStatus(volatile GPIOHW_REG_t *regp, unsigned int gpioNum)
+{
+	uint32_t gpioMask = GPIOHW_MASK_GENERATE(gpioNum);
+	return (reg32_read(&regp->gpioMis) & gpioMask) ? 1 : 0;
+}
+
+static inline uint32_t GpioHwReg_GetRawIrqRegStatus(volatile GPIOHW_REG_t *regp)
+{
+	return reg32_read(&regp->gpioRis);
+}
+
+static inline uint32_t GpioHwReg_GetMaskIrqRegStatus(volatile GPIOHW_REG_t *regp)
+{
+	return reg32_read(&regp->gpioMis);
+}
+
+
+
+/****************************************************************************/
+/**
+*     Note: The following are inline functions to help decipher the block to
+*     perform the operation requested upon based on the gpio pin or block
+*     passed in the parameters.
+*/
+/****************************************************************************/
+
+/* Helper function to return register pointer and modified gpio number */
+static inline unsigned int GpioHw_GetGpioNumAndRegp(unsigned int gpioNum, volatile GPIOHW_REG_t **regpp)
+{
+	unsigned int num = gpioNum;
+
+	if (num < GPIOHW_NUM_PINS_LOWER_BLOCK) {
+		*regpp = gpioRegP(GPIOHW_BLOCK_LOW);
+	} else {
+		*regpp = gpioRegP(GPIOHW_BLOCK_HIGH);
+		num &= GPIOHW_BLOCK_PINS_MASK;
+	}
+	return num;
+}
+
+static inline void GpioHw_SetDirOutput(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_SetDirOutput(regp, num);
+}
+
+static inline void GpioHw_SetDirInput(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_SetDirInput(regp, num);
+}
+
+static inline void GpioHw_SetDirReg(GPIOHW_BLOCK_LEVEL blockLevel, uint32_t dirRegVal)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	GpioHwReg_SetDirReg(regp, dirRegVal);
+}
+
+static inline GPIOHW_DIRECTION GpioHw_GetDir(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetDir(regp, num);
+}
+
+static inline uint32_t GpioHw_GetDirReg(GPIOHW_BLOCK_LEVEL blockLevel)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	return GpioHwReg_GetDirReg(regp);
+}
+
+static inline void GpioHw_SetVal(unsigned int gpioNum, int setVal)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_SetVal(regp, num, setVal);
+}
+
+static inline void GpioHw_SetValDirOutput(unsigned int gpioNum, int setVal)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_SetValDirOutput(regp, num, setVal);
+}
+
+static inline void GpioHw_SetValReg(uint32_t gpioMask, uint32_t maskVal, GPIOHW_BLOCK_LEVEL blockLevel)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	GpioHwReg_SetValReg(regp, gpioMask, maskVal);
+}
+
+static inline int GpioHw_GetVal(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetVal(regp, num);
+}
+
+static inline uint32_t GpioHw_GetValReg(GPIOHW_BLOCK_LEVEL blockLevel)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	return GpioHwReg_GetValReg(regp);
+}
+
+static inline void GpioHw_IrqEnable(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_IrqEnable(regp, num);
+}
+
+static inline void GpioHw_IrqDisable(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_IrqDisable(regp, num);
+}
+
+static inline GPIOHW_IRQ_MASK_STATE GpioHw_IsIrqEnabled(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_IsIrqEnabled(regp, num);
+}
+
+static inline void GpioHw_IrqClear(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_IrqClear(regp, num);
+}
+
+static inline void GpioHw_IrqClearReg(GPIOHW_BLOCK_LEVEL blockLevel, uint32_t mask)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	GpioHwReg_IrqClear(regp, mask);
+}
+
+static inline int GpioHw_GetRawIrqStatus(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetRawIrqStatus(regp, num);
+}
+
+static inline int GpioHw_GetMaskIrqStatus(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetMaskIrqStatus(regp, num);
+}
+
+static inline uint32_t GpioHw_GetRawIrqRegStatus(GPIOHW_BLOCK_LEVEL blockLevel)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	return GpioHwReg_GetRawIrqRegStatus(regp);
+}
+
+static inline uint32_t GpioHw_GetMaskIrqRegStatus(GPIOHW_BLOCK_LEVEL blockLevel)
+{
+	volatile GPIOHW_REG_t *regp = gpioRegP(blockLevel);
+	return GpioHwReg_GetMaskIrqRegStatus(regp);
+}
+
+static inline void GpioHw_SetModeCtrl(unsigned int gpioNum, GPIOHW_MODE_CONTROL_SELECT mode)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_SetModeCtrl(regp, num, mode);
+}
+
+static inline GPIOHW_MODE_CONTROL_SELECT GpioHw_GetModeCtrl(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetModeCtrl(regp, num);
+}
+
+static inline void GpioHw_SetIrqType(unsigned int gpioNum, GPIOHW_INTERRUPT_TYPE irqType)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	GpioHwReg_SetIrqType(regp, num, irqType);
+}
+
+static inline GPIOHW_INTERRUPT_TYPE GpioHw_GetIrqType(unsigned int gpioNum)
+{
+	volatile GPIOHW_REG_t *regp;
+	unsigned int num = GpioHw_GetGpioNumAndRegp(gpioNum, &regp);
+	return GpioHwReg_GetIrqType(regp, num);
+}
+#endif /* GPIOHW_INLINE_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/gpioHw_reg.h b/arch/arm/mach-bcmring/include/mach/csp/gpioHw_reg.h
new file mode 100644
index 0000000..b348c4a
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/gpioHw_reg.h
@@ -0,0 +1,428 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/****************************************************************************/
+/**
+*  @file    gpio_reg.h
+*
+*  @brief   GPIO register definitions
+*
+*/
+/****************************************************************************/
+
+#ifndef GPIOHW_REG_H
+#define GPIOHW_REG_H
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/stdint.h>
+#include <mach/csp/mm_io.h>
+/* ---- Public Constants and Types ---------------------------------------- */
+
+#define  GPIOHW_BLOCK_CNT              2
+#define  GPIOHW_NUM_PINS_LOWER_BLOCK   32
+#define  GPIOHW_NUM_PINS_HIGHER_BLOCK  29
+#define  GPIOHW_TOTAL_NUM_PINS         61
+
+#define  GPIOHW_BLOCK_PINS_MASK        0x1F /* Masks out number of pins per block */
+#define  GPIOHW_MASK_GENERATE(num)     (1 << num)
+
+typedef struct {
+	uint32_t gpioData;
+	uint32_t gpioDummy[255];
+	uint32_t gpioDir;
+	uint32_t gpioIs;
+	uint32_t gpioIbe;
+	uint32_t gpioIev;
+	uint32_t gpioIe;
+	uint32_t gpioRis;
+	uint32_t gpioMis;
+	uint32_t gpioIc;
+	uint32_t gpioAfSel;
+}  GPIOHW_REG_t;
+
+#define  gpioRegP(x) (x ? ((volatile GPIOHW_REG_t *)MM_IO_BASE_GPIO1) : ((volatile GPIOHW_REG_t *)MM_IO_BASE_GPIO0))
+
+/* ---- Public Variables -------------------------------------------------- */
+/* ---- Public Function Prototypes ---------------------------------------- */
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetDirOutput
+*
+*  Used to set the specified GPIO pin to the output mode/direction.
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_SetDirOutput
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN] Pointer to register block */
+   unsigned int gpioNum                   /* [IN] GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetDirInput
+*
+*  This function is used to set the specified GPIO pin to the input direction.
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_SetDirInput
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetDirReg
+*
+*  This function is used to set the
+*  GPIO pins to the register value specified
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+void GpioHwReg_SetDirReg
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN] Pointer to register block */
+   uint32_t dirRegVal                     /* [IN] Value of 32-bit register */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetDir
+*
+*  This function is used to get the direction of the GPIO pin specified
+*
+*  @return
+*     The direction of the GPIO pin of type GPIOHW_DIRECTION
+*/
+/****************************************************************************/
+static inline GPIOHW_DIRECTION GpioHwReg_GetDir
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetDirReg
+*
+*  This function is used to set the GPIO pins to the register value specified
+*
+*  @return
+*     The register containing bitmapped values of the direction for the GPIO pin block
+*/
+/****************************************************************************/
+uint32_t GpioHwReg_GetDirReg
+(
+   volatile GPIOHW_REG_t *regp            /* [IN]   Pointer to register block */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHw_SetVal
+*
+*  This function is used to set the value of a specified GPIO pin
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_SetVal
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum,                  /* [IN]   GPIO pin number selected */
+   int setVal                             /* [IN]   Value of pin to set */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetValDirOutput
+*
+*  This function is used to set the value of a specified GPIO pin and to set
+*  it to be an output, atomically.
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_SetValDirOutput
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum,                  /* [IN]   GPIO pin number selected */
+   int setVal                             /* [IN]   Value of pin to set */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetValReg
+*
+*  This function is used to set the value for the GPIO pins specified
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+void GpioHwReg_SetValReg
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   uint32_t gpioMask,                     /* [IN]   GPIO mask of pins to set */
+   uint32_t maskVal                       /* [IN]   Value of the register.  Will only set masked pins */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetVal
+*
+*  This function is used to get the value
+*  of a specified GPIO pin
+*
+*  @return
+*     1 if the pin is set high, 0 if low
+*/
+/****************************************************************************/
+static inline int GpioHwReg_GetVal
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetValReg
+*
+*  This function is used to set the value
+*  of a specified GPIO pin
+*
+*  @return
+*     Register of bits indicating current value of all pins for the block specified
+*/
+/****************************************************************************/
+uint32_t GpioHwReg_GetValReg
+(
+   volatile GPIOHW_REG_t *regp            /* [IN]   Pointer to register block */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_IrqEnable
+*
+*  This function is used to enable the interrupt of the
+*  specified GPIO pin
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_IrqEnable
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN] Number of the GPIO pin to enable interrupt */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_IrqDisable
+*
+*  This function is used to disable the interrupt of the
+*  specified GPIO pin
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_IrqDisable
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN] Number of the GPIO pin to disable interrupt */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_IsIrqEnabled
+*
+*  This function is used to query if IRQ is enabled or not for the
+*  specified GPIO pin
+*
+*  @return
+*     Returns the status of the IRQ of type GPIOHW_IRQ_MASK_STATE
+*/
+/****************************************************************************/
+static inline GPIOHW_IRQ_MASK_STATE GpioHwReg_IsIrqEnabled
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_IrqClear
+*
+*  This function is used to clear the IRQ of the GPIO pin specified
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+static inline void GpioHwReg_IrqClear
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetRawIrqStatus
+*
+*  This function is used to retrieve the raw IRQ status (ignores masked status)
+*
+*  @return
+*     Return 1 if interrupt triggered, else 0
+*/
+/****************************************************************************/
+static inline int GpioHwReg_GetRawIrqStatus
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetMaskIrqStatus
+*
+*  This function is used to retrieve the masked IRQ status
+*
+*  @return
+*     Return 1 if interrupt triggered, else 0 if not triggered or not enabled
+*/
+/****************************************************************************/
+static inline int GpioHwReg_GetMaskIrqStatus
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetRawIrqRegStatus
+*
+*  This function is used to retrieve the block of GPIO pin IRQ raw status
+*
+*  @return
+*     Return register set of GPIO pin status. Raised bit indicates interrupt
+*     triggered
+*/
+/****************************************************************************/
+static inline uint32_t GpioHwReg_GetRawIrqRegStatus
+(
+   volatile GPIOHW_REG_t *regp            /* [IN]   Pointer to register block */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetMaskIrqRegStatus
+*
+*  This function is used to retrieve the block of GPIO pin IRQ masked status
+*
+*  @return
+*     Return register set of GPIO pin status. Raised bit indicates
+*     interrupt triggered
+*/
+/****************************************************************************/
+static inline uint32_t GpioHwReg_GetMaskIrqRegStatus
+(
+   volatile GPIOHW_REG_t *regp            /* [IN]   Pointer to register block */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetModeCtrl
+*
+*  This function is used to set the control mode of the GPIO pin
+*
+*  @return
+*     None
+*/
+/****************************************************************************/
+void GpioHwReg_SetModeCtrl
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum,                  /* [IN]   GPIO pin number selected */
+   GPIOHW_MODE_CONTROL_SELECT mode        /* [IN]   mode select for HW or SW */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetModeCtrl
+*
+*  This function is used to get the control mode of the GPIO pin
+*
+*  @return
+*     Current mode selected for pin of type GPIOHW_MODE_CONTROL_SELECT
+*/
+/****************************************************************************/
+GPIOHW_MODE_CONTROL_SELECT GpioHwReg_GetModeCtrl
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_SetIrqType
+*
+*  Sets the IRQ trigger mode (falling edge, rising edge, level).  Deciphers
+*  which block to select based on gpio pin selected.  IRQ should be disabled
+*  before selecting to avoid spurrious interrupts
+*
+*  @return
+*   None
+*/
+/****************************************************************************/
+void GpioHwReg_SetIrqType
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum,                  /* [IN]   GPIO pin number selected */
+   GPIOHW_INTERRUPT_TYPE irqType          /* [IN]   Type of IRQ trigger */
+);
+
+/****************************************************************************/
+/**
+*  @brief   GpioHwReg_GetIrqType
+*
+*  Retrieves the IRQ trigger mode.  Deciphers which block to select based on
+*  gpio pin selected
+*
+*  @return
+*   Interrupt trigger mode of type GPIOHW_INTERRUPT_TYPE
+*
+*/
+/****************************************************************************/
+GPIOHW_INTERRUPT_TYPE GpioHwReg_GetIrqType
+(
+   volatile GPIOHW_REG_t *regp,           /* [IN]   Pointer to register block */
+   unsigned int gpioNum                   /* [IN]   GPIO pin number selected */
+);
+
+#endif /* GPIOHW_REG_H */
diff --git a/arch/arm/mach-bcmring/include/mach/csp/gpiomux.h b/arch/arm/mach-bcmring/include/mach/csp/gpiomux.h
new file mode 100644
index 0000000..ec46460
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/csp/gpiomux.h
@@ -0,0 +1,239 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+/****************************************************************************/
+/**
+*  @file    gpiomux.h
+*
+*  @brief   GPIOMUX utility
+*
+*/
+/****************************************************************************/
+
+#ifndef GPIOMUX_H
+#define GPIOMUX_H
+
+/* ---- Include Files ----------------------------------------------------- */
+#include <csp/stdint.h>
+#include <mach/csp/mm_io.h>
+#include <mach/csp/chipcHw_inline.h>
+#include <mach/gpio_defs.h>
+
+/* ---- Public Constants and Types ---------------------------------------- */
+#ifndef ARRAY_LEN
+#define ARRAY_LEN(x) (sizeof(x)/sizeof(x[0]))
+#endif
+
+/* This is a table of group identifiers. Each group is a logical
+ * entity that contains related gpio functions. */
+typedef enum {
+   gpiomux_group_gphyled = 0,     /* gphyled data/clk */
+   gpiomux_group_ext_gphy,        /* mdc_extgphy/mdio_extgphy */
+   gpiomux_group_etm16,           /* etm 16-bit bus */
+   gpiomux_group_etm32,           /* etm 32-bit bus */
+   gpiomux_group_vpm_jtag,        /* vpm tdi/tdo/tms/tck (rtck done as needed) */
+   gpiomux_group_pcm0,            /* pcm0 clk/fs/di/do */
+   gpiomux_group_pcm1,            /* pcm1 clk/fs/di/do */
+   gpiomux_group_mtx_scan,        /* mtx serial (parallel done individually) */
+   gpiomux_group_uart0_mdm,       /* uart0 dtr/dcd/ri/dsr */
+   gpiomux_group_uart0_fc,        /* uart0 cts/rts */
+   gpiomux_group_uart1,           /* uart1 txd/rxd */
+   gpiomux_group_uart1_fc,        /* uart1 cts/rts */
+   gpiomux_group_i2ch,            /* i2c host - sda/scl */
+   gpiomux_group_i2ch_v2,         /* i2c host V2 - sda/scl */
+   gpiomux_group_usb0_pwronflt,   /* usb0 pwron/pwrflt */
+   gpiomux_group_usb1_pwronflt,   /* usb1 pwron/pwrflt */
+   gpiomux_group_spi,             /* spi master - miso/mosi/clk only (ssn done as needed) */
+   gpiomux_group_spis,            /* spi slave - miso/mosi/clk only (ssn done as needed) */
+   gpiomux_group_i2cs,            /* i2c slave - ssda/sscl */
+   gpiomux_group_sdio0_1,         /* sdio0 cmd/clk, D0 */
+   gpiomux_group_sdio0_4,         /* sdio0 cmd/clk, D0-D3 */
+   gpiomux_group_sdio0_8,         /* sdio0 cmd/clk, D0-D7 */
+   gpiomux_group_sdio1_1,         /* sdio1 cmd/clk, D0 */
+   gpiomux_group_sdio1_4,         /* sdio1 cmd/clk, D0-D3 */
+   gpiomux_group_i2s0,            /* i2s0 sdo/sdi/bclk/lrcout/mclk/lrcin */
+   gpiomux_group_i2s1,            /* i2s1 sdo/sdi/bclk/lrcout/mclk/lrcin */
+   gpiomux_group_MaxNum
+}
+gpiomux_group_e;
+
+/* A group is a logical collection of pins. They all
+ * are set to the same chipc gpio function. */
+typedef struct {
+   const gpiomux_group_e group;              /* group identifier */
+   const chipcHw_GPIO_FUNCTION_e function;   /* chipc gpio function for this group */
+   const uint8_t numPins;                    /* Number of pins for this group */
+   const gpio_defs_e *listp;                 /* An array of pins for this group */
+}
+gpiomux_group_t;
+
+/* Function return codes */
+typedef enum {
+   gpiomux_rc_SUCCESS = 0,
+   gpiomux_rc_UNINITIALIZED,  /* Calling functions before initialization */
+   gpiomux_rc_ASSIGNED,       /* Pin already assigned, cannot request */
+   gpiomux_rc_UNASSIGNED,     /* Pin unassigned, cannot free */
+   gpiomux_rc_CONFLICT,       /* Conflict in external request/free */
+   gpiomux_rc_BADPIN,         /* Bad pin enum parameter */
+   gpiomux_rc_BADGROUP        /* Bad group enum parameter */
+}
+gpiomux_rc_e;
+
+/* Initialization structure */
+typedef struct {
+   /* If not NULL, this function is called to find out of a gpio pin has already
+    * been requested. In linux this would presumably call the gpiolib is_requested
+    * function to find out if a gpio_request() had been called. If the pin has
+    * not been requested, then the gpiomux request calls should also fail.
+    * Returns the original label if the function was already requested, else NULL. */
+   const char * (*is_requested)(gpio_defs_e pin);
+
+   /* If not NULL, this function is called to request a gpio pin. In linux this
+    * would presumably call the gpiolib request_gpio function to allocate the
+    * pin. This keeps gpiomux and gpiolib in sync, and only gpiomux calls are
+    * required to both allocate and setup the mux.
+    * Returns 0 on success, < 0 on failure (busy or invalid pin) */
+   int (*request_gpio)(gpio_defs_e pin, const char *label);
+
+   /* If not NULL, this function is called to free a gpio pin. In linux this
+    * would presumably call the gpiolib free_gpio function to free the pin. */
+   void (*free_gpio)(gpio_defs_e pin);
+}
+gpiomux_init_t;
+
+/* ---- Public Variables -------------------------------------------------- */
+extern const gpiomux_group_t gpiomux_GroupList[];
+
+/* ---- Public Function Prototypes ---------------------------------------- */
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_Init
+*
+*  Used to initialize the mux table and set all pin functions to GPIO.
+*
+*  @return
+*     none
+*/
+/****************************************************************************/
+void gpiomux_Init
+(
+   gpiomux_init_t *initp   /* [IN] initialization structure pointer */
+);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_request
+*
+*  Used to register a chip function with the gpiomux
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_request
+(
+   gpio_defs_e pin,                    /* [IN] GPIO pin */
+   chipcHw_GPIO_FUNCTION_e function,   /* [IN] GPIO pin function */
+   const char *label                   /* [IN] description of pin usage */
+);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_free
+*
+*  Used to deregister a pin assignment
+*
+*  @return
+*     success - assigned function was unregistered
+*     notfound - there was not registered function for this pin
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_free
+(
+   gpio_defs_e pin                   /* [IN] GPIO pin */
+);
+/****************************************************************************/
+/**
+*  @brief   gpiomux_requestGroup
+*
+*  Used to register a group of pin functions with the gpiomux
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_requestGroup
+(
+   const gpiomux_group_e group,        /* [IN] GPIO group */
+   const char *label                   /* [IN] description of group usage */
+);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_freeGroup
+*
+*  Used to deregister a group of pin assignments
+*
+*  @return
+*     success - assigned group was unregistered
+*     notfound - there was not registered group for this pin
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_freeGroup
+(
+   gpiomux_group_e group               /* [IN] GPIO group */
+);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_requestKeypad
+*
+*  Used to register a logical set of pin functions with the gpiomux. If the
+*  keypad pins are not sequential, then use the individual setPin functions.
+*  Example: gpiomux_requestKeypad(0,5,0,4);
+*
+*  @return
+*     success or conflict return code
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_requestKeypad
+(
+   uint8_t in_first,                /* [IN] keypad_in[in_first] is start of array */
+   uint8_t in_last,                 /* [IN] keypad_in[in_last] is end of array */
+   uint8_t out_first,               /* [IN] keypad_out[out_first] is start of array */
+   uint8_t out_last,                /* [IN] keypad_out[out_last] is end of array */
+   const char *label                /* [IN] description of group usage */
+);
+
+/****************************************************************************/
+/**
+*  @brief   gpiomux_freeKeypad
+*
+*  Used to deregister a logical set of keypad pin functions
+*
+*  @return
+*     success - assigned function was unregistered
+*     notfound - one or more pins were not registered for the keypad
+*/
+/****************************************************************************/
+gpiomux_rc_e gpiomux_freeKeypad
+(
+   uint8_t in_first,                /* [IN] keypad_in[in_first] is start of array */
+   uint8_t in_last,                 /* [IN] keypad_in[in_last] is end of array */
+   uint8_t out_first,               /* [IN] keypad_out[out_first] is start of array */
+   uint8_t out_last                 /* [IN] keypad_out[out_last] is end of array */
+);
+
+#endif /* GPIOMUX_H */
diff --git a/arch/arm/mach-bcmring/include/mach/gpio.h b/arch/arm/mach-bcmring/include/mach/gpio.h
new file mode 100644
index 0000000..2f0ee58
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/gpio.h
@@ -0,0 +1,104 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/*
+*
+*****************************************************************************
+*
+*  gpio.h
+*
+*  PURPOSE:
+*
+*     This file defines the architecture-independent interface for
+*     the GPIO driver.
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+
+#ifndef LINUX_GPIO_H
+#define LINUX_GPIO_H
+
+
+#if defined(CONFIG_ARM)
+   #include <mach/reg_gpio.h>
+   #include <linux/gpio.h>
+#else
+   #error "Unknown ARCH!"
+#endif
+
+#if defined(USE_BCM_GPIO)
+
+#define gpio_get_value(gpio)			bcm_gpio_get(gpio)
+#define gpio_set_value(gpio, value)		bcm_gpio_set(gpio, value)
+#define gpio_direction_input(gpio)		bcm_gpio_direction_input(gpio)
+#define gpio_direction_output(gpio, value)	bcm_gpio_direction_output(gpio, value)
+
+static inline int  gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+}
+
+#else
+
+#if defined(CONFIG_GPIOLIB) && !defined(STANDALONE)
+
+   /*
+    * This side of the if is chip specific, so the definitions should occur
+    * in one of the header files included above.
+    */
+
+#else
+/*
+ * Compatability code so that code which uses the gpiolib calls will still
+ * work on platforms which don't yet support it.
+ */
+#define gpio_get_value(gpio)		gpio_get_pin_val(gpio)
+#define gpio_set_value(gpio, value)	gpio_set_pin_val(gpio, value)
+static inline int gpio_direction_input(unsigned gpio)
+{
+	gpio_set_pin_type(gpio, GPIO_PIN_TYPE_INPUT);
+	return 0;
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	gpio_set_pin_val(gpio, value);
+	gpio_set_pin_type(gpio, GPIO_PIN_TYPE_OUTPUT);
+	return 0;
+}
+
+#define gpio_direction_is_output(gpio) (gpio_get_pin_type(gpio) == GPIO_PIN_TYPE_OUTPUT)
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	return 0;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+}
+#endif
+
+#endif
+
+#endif  /* LINUX_GPIO_H  */
diff --git a/arch/arm/mach-bcmring/include/mach/gpio_defs.h b/arch/arm/mach-bcmring/include/mach/gpio_defs.h
new file mode 100644
index 0000000..ebf4bf8
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/gpio_defs.h
@@ -0,0 +1,105 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+/*
+ *   GPIO pin definitions
+ *
+ *   This file must contain only defines as it is shared between user and
+ *   kernel space.  As such, it is placed in the linux/broadcom/bcmring
+ *   directory so it can be exposed using install-headers.  It can not be in
+ *   the asm/arch directory.
+ */
+
+#ifndef GPIO_DEFS_H
+#define GPIO_DEFS_H
+
+/* ---- Include Files ----------------------------------------------------- */
+/* ---- Public Constants and Types ---------------------------------------- */
+
+/* BCMRING GPIO pins */
+typedef enum {
+	GPIO00_SCL_MTX_X0_EPHYLED_DATA = 0,
+	GPIO01_SDA_MTX_X1_EPHYLED_CLK,
+	GPIO02_UART0_DTR_B_MTX_X2_SDIO0D4_PCM1DO_I2S1DO_ETM18_VPMTDI,
+	GPIO03_UART0_DCD_B_MTX_X3_SDIO0D5_PCM1DI_I2S1DI_ETM19_VPMTDO,
+	GPIO04_UART0_RI_B_MTX_X4_SDIO0D6_PCM1CLK_I2S1BCLK_ETM20_VPMTMS,
+	GPIO05_UART0_DSR_B_MTX_X5_SDIO0D7_PCM1FS_I2S1LRCOUT_ETM21_VPMTCK,
+	GPIO06_MTX_X6_SDIO1D2_ETM22,
+	GPIO07_MTX_X7_SDIO1D3_ETM23,
+	GPIO08_MTX_X8_PCM0FS_I2S0LRCOUT,
+	GPIO09_MTX_X9_PCM0DI_I2S0DI,
+	GPIO10_MTX_X10_SDIO1CMD_ETM16,
+	GPIO11_MTX_X11_SDIO1CLK_ETM17,
+	GPIO12_UART1_CTS_B,
+	GPIO13_UART1_RTS_B,
+	GPIO14_UART1_TXD,
+	GPIO15_UART1_RXD,
+	GPIO16_MTX_Y0_MTX_SCAN_DA_ETM26,
+	GPIO17_MTX_Y1_MTX_SCAN_CLK_ETM27,
+	GPIO18_MTX_Y2_SDIO0D2_ETM28,
+	GPIO19_MTX_Y3_SDIO0D3_ETM29,
+	GPIO20_SPI_SS2_B_MTX_Y4_SDIO0SDCD_B_ETM24,
+	GPIO21_SPI_SS1_B_MTX_Y5_SDIO0WP_ETM25,
+	GPIO22_SPI_MISO,
+	GPIO23_SPI_CLK,
+	GPIO24_SPI_MOSI,
+	GPIO25_SPI_SS0_B,
+	GPIO26_I2S1MCLK,
+	GPIO27_SDIO1D0_ETM30,
+	GPIO28_SDIO1D1_ETM31,
+	GPIO29_SDIO0CMD,
+	GPIO30_SDIO0CLK,
+	GPIO31_SDIO0D0,
+	GPIO32_SDIO0D1,
+	GPIO33_PCM0CLK_I2S0BCLK,
+	GPIO34_PCM0D0_I2S0DO,
+	GPIO35_PWM_OUT,
+	GPIO36_USB0_PWRON,
+	GPIO37_USB0_PWRFLT,
+	GPIO38_SDA_V2_SPI_V2,
+	GPIO39_SCL_V2_SPI_CLK_V2,
+	GPIO40_PIF_HRDY_2_SPI_MOSI_V2,
+	GPIO41_SPI_SS2_B_V2,
+	GPIO42_PIF_HAT2,
+	GPIO43_KEY_IN0_UART0_CTS_B_I2S0LRCIN_ETMCTL,
+	GPIO44_KEY_IN1_UART0_RTS_B_I2S1LRCIN_ETMCLK_VPMRTCK,
+	GPIO45_KEY_IN2_ETM0_I2S0MCLK,
+	GPIO46_KEY_IN3_ETM1,
+	GPIO47_KEY_IN4_ETM2,
+	GPIO48_KEY_IN5_ETM3,
+	GPIO49_KEY_IN6_SSCL_ETM4,
+	GPIO50_KEY_IN7_SSDA_ETM5,
+	GPIO51_KEY_IN8_SPIS_MISO_ETM6,
+	GPIO52_KEY_OUT0_ETM7,
+	GPIO53_KEY_OUT1_ETM8,
+	GPIO54_KEY_OUT2_ETM9,
+	GPIO55_KEY_OUT3_SPIS_CLK_ETM10,
+	GPIO56_KEY_OUT4_SPIS_MOSI_ETM11,
+	GPIO57_KEY_OUT5_SPIS_SSN_ETM12_EXTPHY_MDC,
+	GPIO58_KEY_OUT6_ETM13_EXTPHY_MDIO,
+	GPIO59_KEY_OUT7_ETM14_USB1_PWRON,
+	GPIO60_KEY_OUT8_ETM15_USB1_PWRFLT,
+	gpio_defs_MAX_PINS
+}
+gpio_defs_e;
+
+/* Max in and out keys indexes */
+#define GPIO_MAX_INKEY_IDX  9
+#define GPIO_MAX_OUTKEY_IDX 9
+
+/* ---- Public Variables -------------------------------------------------- */
+/* ---- Public Function Prototypes ---------------------------------------- */
+
+
+#endif /* GPIO_DEFS_H */
diff --git a/arch/arm/mach-bcmring/include/mach/gpio_irq.h b/arch/arm/mach-bcmring/include/mach/gpio_irq.h
new file mode 100644
index 0000000..d418841
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/gpio_irq.h
@@ -0,0 +1,69 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/*
+*
+*****************************************************************************
+*
+*  gpio_irq.h
+*
+*  PURPOSE:
+*
+*     This file defines the architecture-independent kernel API for the GPIO
+*     IRQ driver. This allows clients to register ISR handlers that are
+*     triggered by external interrupts on GPIO lines.
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+
+#if !defined(LINUX_GPIO_IRQ_H)
+#define LINUX_GPIO_IRQ_H
+
+#if defined(__KERNEL__)
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <linux/interrupt.h>
+#include <mach/gpio_types.h>
+
+
+/* ---- Constants and Types ---------------------------------------------- */
+
+typedef void *GPIO_IRQ_DATA;
+typedef irqreturn_t (*GPIO_IRQ_HANDLER)(GPIO_IRQ_DATA);
+
+/*
+ * ---- Variable Externs -------------------------------------------------
+ * ---- Function Prototypes ----------------------------------------------
+ */
+
+int gpio_request_irq
+(
+   int                  pin,
+   GPIO_INTERRUPT_TYPE  interruptType,
+   GPIO_IRQ_HANDLER     irqHandler,
+   void                *devId
+);
+
+int gpio_free_irq(int pin);
+int gpio_enable_irq(int pin);
+int gpio_disable_irq(int pin);
+
+#endif   /* __KERNEL__ */
+#endif  /* LINUX_GPIO_IRQ_H */
diff --git a/arch/arm/mach-bcmring/include/mach/gpio_types.h b/arch/arm/mach-bcmring/include/mach/gpio_types.h
new file mode 100644
index 0000000..00e751e
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/gpio_types.h
@@ -0,0 +1,57 @@
+/*****************************************************************************
+* Copyright 2004 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+
+/*
+*
+*****************************************************************************
+*
+*  gpio_types.h
+*
+*  PURPOSE:
+*
+*     This file defines generic types used by the GPIO and GPIO IRQ driver.
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+
+#if !defined(LINUX_GPIO_TYPES_H)
+#define LINUX_GPIO_TYPES_H
+
+/*
+ * ---- Include Files ----------------------------------------------------
+ * ---- Constants and Types ----------------------------------------------
+ */
+
+
+typedef enum {
+	GPIO_NO_INTERRUPT                   = 0x00,
+	GPIO_RISING_EDGE_INTERRUPT_TRIGGER  = 0x01,
+	GPIO_FALLING_EDGE_INTERRUPT_TRIGGER = 0x02,
+	GPIO_BOTH_EDGE_INTERRUPT_TRIGGER    = 0x03,
+	GPIO_LOW_LEVEL_INTERRUPT_TRIGGER    = 0x04,
+	GPIO_HIGH_LEVEL_INTERRUPT_TRIGGER   = 0x05,
+	GPIO_MAX_INTERRUPT_TYPES
+} GPIO_INTERRUPT_TYPE;
+
+/*
+ * ---- Variable Externs -------------------------------------------------
+ * ---- Function Prototypes ----------------------------------------------
+ */
+
+#endif  /* LINUX_GPIO_TYPES_H */
diff --git a/arch/arm/mach-bcmring/include/mach/reg_gpio.h b/arch/arm/mach-bcmring/include/mach/reg_gpio.h
new file mode 100644
index 0000000..22f9c33
--- /dev/null
+++ b/arch/arm/mach-bcmring/include/mach/reg_gpio.h
@@ -0,0 +1,132 @@
+/*****************************************************************************
+* Copyright 2003 - 2008 Broadcom Corporation.  All rights reserved.
+*
+* Unless you and Broadcom execute a separate written software license
+* agreement governing use of this software, this software is licensed to you
+* under the terms of the GNU General Public License version 2, available at
+* http://www.broadcom.com/licenses/GPLv2.php (the "GPL").
+*
+* Notwithstanding the above, under no circumstances may you combine this
+* software in any way with any other Broadcom software provided under a
+* license other than the GPL, without Broadcom's express prior written
+* consent.
+*****************************************************************************/
+
+
+
+/*
+*****************************************************************************
+*
+*  reg_gpio.h
+*
+*  PURPOSE:
+*
+*       This file contains an emulation layer which is used by code which
+*       can't use gpiolib (like boot-loaders and non-GPL code)
+*
+*  NOTES:
+*
+*****************************************************************************/
+
+#if !defined(ASM_ARCH_REG_GPIO_H)
+#define ASM_ARCH_REG_GPIO_H
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <csp/gpioHw.h>
+
+#if defined(CONFIG_BCM_VC03B0) || defined(CONFIG_BCM_VCHIQ)
+#include <linux/broadcom/vc03/vc_gpio.h>
+#include <linux/broadcom/videocore_settings.h>
+
+#ifdef GPIOHW_TOTAL_NUM_PINS
+#undef GPIOHW_TOTAL_NUM_PINS
+#endif
+
+#if (defined(HW_VC03_RUN2_GPIO) && defined(HW_VC03_HAT2_GPIO))
+#define  GPIOHW_TOTAL_NUM_PINS         (VC03_1_GPIO_PIN_OFFSET + VC03_1_GPIO_NUM_PINS)
+#else
+#define  GPIOHW_TOTAL_NUM_PINS         (VC03_0_GPIO_PIN_OFFSET + VC03_0_GPIO_NUM_PINS)
+#endif
+#endif
+
+#if defined(CONFIG_GPIOLIB) && !defined(STANDALONE) && !defined(USE_BCM_GPIO)
+	#define   ARCH_NR_GPIOS   GPIOHW_TOTAL_NUM_PINS
+	#include <asm-generic/gpio.h>
+	#define gpio_get_value(gpio)        __gpio_get_value(gpio)
+	#define gpio_set_value(gpio, value)  __gpio_set_value(gpio, value)
+	#define gpio_cansleep(gpio)         __gpio_cansleep(gpio)
+#else
+	/*
+	 * The else side of this definition provides a gpiolib emulation for versions
+	 * of the kernel which haven't got gpiolib ported to it yet.
+	 */
+	/* These definitions occur in include/linux/broadcom/gpio.h */
+#endif
+
+/* ---- Constants and Types ---------------------------------------------- */
+
+/* ---- Variable Externs ------------------------------------------------- */
+
+/* ---- Function Prototypes ---------------------------------------------- */
+
+/****************************************************************************
+*
+*  Configure a GPIO pin as an input pin
+*
+*****************************************************************************/
+
+static inline int bcm_gpio_direction_input(unsigned gpio)
+{
+	GpioHw_SetDirInput(gpio);
+
+	return 0;
+
+} /* bcm_gpio_direction_input */
+
+/****************************************************************************
+*
+*  Configure a GPIO pin as an output pin and sets its initial value.
+*
+*****************************************************************************/
+
+static inline int bcm_gpio_direction_output(unsigned gpio, int initial_value)
+{
+	GpioHw_SetValDirOutput(gpio, initial_value);
+
+	return 0;
+
+} /* bcm_gpio_direction_output */
+
+/****************************************************************************
+*
+*  Retrieve the value of a GPIO pin. Note that this returns zero or the raw
+*   value.
+*
+*****************************************************************************/
+
+static inline int bcm_gpio_get(unsigned gpio)
+{
+	return GpioHw_GetVal(gpio);
+
+} /* bcm_gpio_get */
+
+/****************************************************************************
+*
+*  Set the value of a GPIO pin
+*
+*****************************************************************************/
+
+static inline void bcm_gpio_set(unsigned gpio, int value)
+{
+	GpioHw_SetVal(gpio, value);
+
+} /* bcm_gpio_set */
+
+#if defined(__KERNEL__)
+#include <linux/init.h>
+void __init brcm_init_gpio(void);
+#endif
+
+#endif  /* ASM_ARCH_REG_GPIO_H */
+
diff --git a/arch/arm/mach-bcmring/irq.c b/arch/arm/mach-bcmring/irq.c
index dc1c493..59cf710 100644
--- a/arch/arm/mach-bcmring/irq.c
+++ b/arch/arm/mach-bcmring/irq.c
@@ -29,6 +29,7 @@
 #include <asm/mach/irq.h>
 #include <mach/csp/intcHw_reg.h>
 #include <mach/csp/mm_io.h>
+#include <mach/reg_gpio.h>  /* for brcm_init_gpio prototype */
 
 static void bcmring_mask_irq0(unsigned int irq)
 {
@@ -124,4 +125,8 @@ void __init bcmring_init_irq(void)
 	if (INTCHW_INTC1_GPIO1 & IRQ_INTC1_VALID_MASK) {
 		set_irq_handler(IRQ_GPIO1, handle_simple_irq);
 	}
+
+#ifdef CONFIG_GPIOLIB
+	brcm_init_gpio();
+#endif
 }
-- 
1.7.0.4

