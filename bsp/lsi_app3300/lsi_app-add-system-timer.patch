From 3fa5bf7d8d5600ed2d1b689a6c9daaeeed3e8425 Mon Sep 17 00:00:00 2001
From: Tony Liu <Bo.Liu@windriver.com>
Date: Tue, 30 Mar 2010 15:23:35 +0800
Subject: [PATCH 07/13] lsi_app: add system timer

Merge system timer implementation from vendor drop -- Agere APP Linux
Version 2.6.1.5.pre10 05/07/2009.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-app/include/mach/common.h |   27 +++++
 arch/arm/mach-app/include/mach/timers.h |   81 ++++++++++++++
 arch/arm/mach-app/include/mach/timex.h  |   32 ++++++
 arch/arm/mach-app/timer.c               |  183 +++++++++++++++++++++++++++++++
 4 files changed, 323 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-app/include/mach/common.h
 create mode 100644 arch/arm/mach-app/include/mach/timers.h
 create mode 100644 arch/arm/mach-app/include/mach/timex.h
 create mode 100644 arch/arm/mach-app/timer.c

diff --git a/arch/arm/mach-app/include/mach/common.h b/arch/arm/mach-app/include/mach/common.h
new file mode 100644
index 0000000..23f3a01
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/common.h
@@ -0,0 +1,27 @@
+/*
+ *  include/mach/common.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_COMMON_H
+#define __ASM_ARCH_COMMON_H
+
+struct sys_timer;
+
+extern void app_map_io(void);
+extern struct sys_timer app_timer;
+
+#endif /*__ASM_ARCH_COMMON_H*/
diff --git a/arch/arm/mach-app/include/mach/timers.h b/arch/arm/mach-app/include/mach/timers.h
new file mode 100644
index 0000000..9c257ce
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/timers.h
@@ -0,0 +1,81 @@
+/*
+ *  include/mach/timers.h
+ *
+ *  Copyright (C) 2004 Agere Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMERS_H
+#define __ASM_ARCH_TIMERS_H
+
+#include <mach/hardware.h>
+
+/*
+  Base addresses of the timers.  Use these plus a register offset
+  in calls to readl/writel (readl/writel add in the IO_ADDRESS).
+*/
+
+#define TIMER0_BASE (APP3XX_CT_BASE + APP3XX_TIMER0_OFFSET)
+#define TIMER1_BASE (APP3XX_CT_BASE + APP3XX_TIMER1_OFFSET)
+#define TIMER2_BASE (APP3XX_CT_BASE + APP3XX_TIMER2_OFFSET)
+#define TIMER3_BASE (APP3XX_CT_BASE + APP3XX_TIMER3_OFFSET)
+#define TIMER4_BASE (APP3XX_CT_BASE + APP3XX_TIMER4_OFFSET)
+#define TIMER5_BASE (APP3XX_CT_BASE + APP3XX_TIMER5_OFFSET)
+#define TIMER6_BASE (APP3XX_CT_BASE + APP3XX_TIMER6_OFFSET)
+#define TIMER7_BASE (APP3XX_CT_BASE + APP3XX_TIMER7_OFFSET)
+
+/*
+ * Register offsets and bit masks.
+ */
+
+/*-- Load --*/
+#define TIMER_n_LOAD 0x00
+
+/*-- Value  --*/
+#define TIMER_n_VALUE 0x04
+
+/*-- Control --*/
+#define TIMER_n_CONTROL 0x08
+
+#define TIMER_n_CONTROL_ENABLE           0x80
+#define TIMER_n_CONTROL_MODE             0x40
+#define TIMER_n_CONTROL_INTERRUPT_ENABLE 0x20
+#define TIMER_n_CONTROL_OUTPUT_MODE      0x10 /* Added by Agere... */
+#define TIMER_n_CONTROL_PRESCALER        0x0c
+#define TIMER_n_CONTROL_SIZE             0x02
+#define TIMER_n_CONTROL_ONE_SHOT         0x01
+
+#define TIMER_n_CONTROL_SET_PRESCALER(control, prescale) do { \
+(control) &= ~TIMER_n_CONTROL_PRESCALER ; \
+(control) |= (((prescale) & 0x3) << 2) ; \
+} while (0)
+
+#define TIMER_n_CONTROL_GET_PRESCALER(control) \
+(((control) & TIMER_n_CONTROL_PRESCALER) >> 2)
+
+/* -- Interrupt Clear -- */
+#define TIMER_n_INTERRUPT_CLEAR 0x0c
+
+/* -- Raw Interrupt Status -- */
+#define TIMER_n_RAW_INTERRUPT_STATUS 0x10
+
+/* -- Masked Interrupt Status -- */
+#define TIMER_n_MASKED_INTERRUPT_STATUS 0x14
+
+/* -- Background Load -- */
+#define TIMER_n_BACKGROUND_LOAD 0x18
+
+#endif /*__ASM_ARCH_TIMERS_H*/
diff --git a/arch/arm/mach-app/include/mach/timex.h b/arch/arm/mach-app/include/mach/timex.h
new file mode 100644
index 0000000..e6cdacd
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/timex.h
@@ -0,0 +1,32 @@
+/*
+ *  include/mach/timex.h
+ *
+ *  APP3XX architecture timex specifications
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+#include <mach/pll.h>
+
+#ifdef CONFIG_ARCH_APP3K
+#define CLOCK_TICK_RATE (133844000)
+#endif
+
+#endif /*__ASM_ARCH_TIMEX_H*/
diff --git a/arch/arm/mach-app/timer.c b/arch/arm/mach-app/timer.c
new file mode 100644
index 0000000..bdc8e91
--- /dev/null
+++ b/arch/arm/mach-app/timer.c
@@ -0,0 +1,183 @@
+/*
+ * arch/arm/mach-app/timer.c
+ *
+ * Copyright (C) 2009 LSI Logic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+  System tick for APP3K.
+  The input frequency is variable.  The current approach is as follows.
+
+  --1--
+  Figure out shift and mult values to use.
+
+  At 200,000,000 Hz, each cycle will be 5 nsec.  So, ideally, the
+  multiplier would be 1/5.  Since 1/5 is rather difficult to represent
+  as an integer, everything will be shifted. For example, with a shift
+  value of 20, the multiplier should convert shifted as follows.
+
+       ( 1 cycle * multiplier ) >> 20 = 5
+
+  So, multiplier, in this case, would be
+
+       ( 5 << 20 ) / 1 = 5242880
+
+  Now cycles * multiplier yield shifted nsecs.
+
+       1 cycle * 5242880 = 5242880
+       5242880 >> 20 = 5
+
+  So multiplier, in general, can be calculated as follows.
+
+       multiplier = ( 1,000,000,000 / frequency ) << shift
+*/
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/clockchips.h>
+#include <linux/cpumask.h>
+
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <mach/common.h>
+#include <mach/timers.h>
+
+static void timer_set_mode(enum clock_event_mode mode,
+		struct clock_event_device *clock)
+{
+	unsigned long core_speed = get_core_speed() / 2;
+	unsigned long ctrl;
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		__raw_writel(0, (TIMER0_BASE + TIMER_n_CONTROL));
+		__raw_writel((core_speed / HZ), (TIMER0_BASE + TIMER_n_LOAD));
+		ctrl = (TIMER_n_CONTROL_ENABLE |
+				TIMER_n_CONTROL_MODE |
+				TIMER_n_CONTROL_INTERRUPT_ENABLE |
+				TIMER_n_CONTROL_SIZE);
+		break;
+	case CLOCK_EVT_MODE_ONESHOT:
+		/*period set, and timer enabled in 'next_event' hook */
+		ctrl = (TIMER_n_CONTROL_ENABLE |
+				TIMER_n_CONTROL_MODE |
+				TIMER_n_CONTROL_INTERRUPT_ENABLE |
+				TIMER_n_CONTROL_SIZE |
+				TIMER_n_CONTROL_ONE_SHOT);
+		break;
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	default:
+		ctrl = 0;
+	}
+
+	__raw_writel(ctrl, (TIMER0_BASE + TIMER_n_CONTROL));
+}
+
+static int timer_set_next_event(unsigned long evt,
+		struct clock_event_device *unused)
+{
+	unsigned long ctrl = __raw_readl(TIMER0_BASE + TIMER_n_CONTROL);
+
+	__raw_writel(evt, (TIMER0_BASE + TIMER_n_LOAD));
+	__raw_writel(evt, (TIMER0_BASE + TIMER_n_VALUE));
+	__raw_writel(ctrl | TIMER_n_CONTROL_ENABLE,
+		(TIMER0_BASE + TIMER_n_CONTROL));
+
+	return 0;
+}
+
+static struct clock_event_device timer0_clockevent = {
+	.name			= "timer0",
+	.features		= CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+	.set_mode		= timer_set_mode,
+	.set_next_event	= timer_set_next_event,
+	.rating			= 300,
+	.cpumask		= cpu_all_mask,
+	.shift			= 20,
+};
+
+static void __init app_clockevents_init(unsigned int timer_irq)
+{
+	unsigned long core_speed = get_core_speed() / 2;
+
+	timer0_clockevent.irq = timer_irq;
+	timer0_clockevent.mult =
+		clocksource_khz2mult((core_speed / 1000),
+				      timer0_clockevent.shift);
+	timer0_clockevent.max_delta_ns =
+		clockevent_delta2ns(0xffffffff, &timer0_clockevent);
+	timer0_clockevent.min_delta_ns =
+		clockevent_delta2ns(1, &timer0_clockevent);
+	clockevents_register_device(&timer0_clockevent);
+}
+
+static irqreturn_t app_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &timer0_clockevent;
+
+	/*clear the interrupt*/
+	__raw_writel(0, (TIMER0_BASE + TIMER_n_INTERRUPT_CLEAR));
+
+	/*tick_handle_periodic() or hrtimer_interrupt()*/
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction app_timer_irq = {
+	.name    = "APP3 Timer Tick",
+	.flags   = IRQF_DISABLED | IRQF_TIMER,
+	.handler = app_timer_interrupt
+};
+
+/*
+ * Set up a free-running clock source (using timer 6).
+ */
+static cycle_t app_get_cycles(void)
+{
+	return ~__raw_readl(TIMER6_BASE + TIMER_n_VALUE);
+}
+
+static struct clocksource clocksource_app = {
+	.name	 = "timer6",
+	.rating	 = 200,
+	.read	 = app_get_cycles,
+	.mask	 = CLOCKSOURCE_MASK(32),
+	.shift   = 20,
+	.flags	 = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init app_clocksource_init(void)
+{
+	unsigned long core_speed = get_core_speed() / 2;
+
+	/*setup timer 6 as free-running clocksource*/
+	__raw_writel(0, (TIMER6_BASE + TIMER_n_CONTROL));
+	__raw_writel(0xffffffff, (TIMER6_BASE + TIMER_n_LOAD));
+	__raw_writel((TIMER_n_CONTROL_ENABLE |
+		  TIMER_n_CONTROL_MODE |
+		  TIMER_n_CONTROL_SIZE),
+		(TIMER6_BASE + TIMER_n_CONTROL));
+	clocksource_app.mult = clocksource_khz2mult((core_speed / 1000),
+			clocksource_app.shift);
+	clocksource_register(&clocksource_app);
+}
+
+static inline void __cpuinit app_timer_init(void)
+{
+	__raw_writel(0, (TIMER0_BASE + TIMER_n_CONTROL));
+
+	setup_irq(INT_CT, &app_timer_irq);
+	app_clocksource_init();
+	app_clockevents_init(INT_CT);
+}
+
+struct sys_timer app_timer = {
+	.init = app_timer_init
+};
-- 
1.6.5.2

