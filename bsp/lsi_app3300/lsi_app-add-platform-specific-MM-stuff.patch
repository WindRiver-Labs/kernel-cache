From e6803cb1986037eed7c2f7481551edc7b818b5c1 Mon Sep 17 00:00:00 2001
From: Tony Liu <Bo.Liu@windriver.com>
Date: Tue, 30 Mar 2010 15:19:11 +0800
Subject: [PATCH 05/13] lsi_app: add platform specific MM stuff

Merge LSI APP3K platform common MM related definitions, iomap routine from
vendor drop -- Agere APP Linux Version 2.6.1.5.pre10 05/07/2009.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-app/include/mach/io.h      |   33 ++++
 arch/arm/mach-app/include/mach/memory.h  |   29 ++++
 arch/arm/mach-app/include/mach/vmalloc.h |   28 ++++
 arch/arm/mach-app/mm.c                   |  244 ++++++++++++++++++++++++++++++
 4 files changed, 334 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-app/include/mach/io.h
 create mode 100644 arch/arm/mach-app/include/mach/memory.h
 create mode 100644 arch/arm/mach-app/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-app/mm.c

diff --git a/arch/arm/mach-app/include/mach/io.h b/arch/arm/mach-app/include/mach/io.h
new file mode 100644
index 0000000..cdfeb42
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/io.h
@@ -0,0 +1,33 @@
+/*
+ * include/mach/io.h
+ *
+ * Copyright (C) 2007 Agere Systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#ifdef CONFIG_ARCH_APP3K
+#define IO_ADDRESS     0xe0000000
+#define IO_SPACE_LIMIT 0x10000000
+#endif
+
+#define __io(a)			(a)
+#define __mem_pci(a)	(a)
+#define __mem_isa(a)	(a)
+
+#endif /*__ASM_ARCH_IO_H*/
diff --git a/arch/arm/mach-app/include/mach/memory.h b/arch/arm/mach-app/include/mach/memory.h
new file mode 100644
index 0000000..82b323f
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/memory.h
@@ -0,0 +1,29 @@
+/*
+ *  include/mach/memory.h
+ *
+ *  Copyright (C) 2004 Agere Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#ifdef CONFIG_ARCH_APP3K
+#define PHYS_OFFSET UL(0x00000000) /*Physical start of SDRAM*/
+#define ISA_DMA_THRESHOLD  UL(0x00ffffff)
+#endif
+
+#endif /*__ASM_ARCH_MEMORY_H*/
diff --git a/arch/arm/mach-app/include/mach/vmalloc.h b/arch/arm/mach-app/include/mach/vmalloc.h
new file mode 100644
index 0000000..11b31b5
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/vmalloc.h
@@ -0,0 +1,28 @@
+/*
+ *  include/mach/vmalloc.h
+ *
+ *  Copyright (C) 2000 Russell King.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_VMALLOC_H
+#define __ASM_ARCH_VMALLOC_H
+
+#include <mach/io.h>
+
+#define VMALLOC_END       (IO_ADDRESS)
+
+#endif /*__ASM_ARCH_VMALLOC_H*/
diff --git a/arch/arm/mach-app/mm.c b/arch/arm/mach-app/mm.c
new file mode 100644
index 0000000..4e3b4a6
--- /dev/null
+++ b/arch/arm/mach-app/mm.c
@@ -0,0 +1,244 @@
+/*
+ * linux/arch/arm/mach-app/mm.c
+ *
+ * Copyright (C) 2004 Agere Systems Inc.
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+
+#include <asm/mach/map.h>
+#include <mach/common.h>
+#include <mach/hardware.h>
+
+#ifdef CONFIG_ARCH_APP3K
+extern void __init create_mapping(struct map_desc *);
+
+/*
+ * Only first 16MB of memory can be accessed via PCI.
+ * We use GFP_DMA to allocate safe buffers to do map/unmap.
+ * This is really ugly and we need a better way of specifying
+ * DMA-capable regions of memory.
+ */
+void __init app3k_adjust_zones(int node, unsigned long *zone_size,
+    unsigned long *zhole_size)
+{
+	unsigned int sz = SZ_16M >> PAGE_SHIFT;
+
+	/* only adjust if > 64M, ignore if not node zero (DMA ZONE) */
+	if ((node != 0) || (zone_size[0] <= sz))
+		return;
+
+	zone_size[1] = zone_size[0] - sz;
+	zone_size[0] = sz;
+	zhole_size[1] = zhole_size[0];
+	zhole_size[0] = 0;
+}
+
+static struct map_desc app_io_desc[] __initdata = {
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_ASI_BASE),
+	.virtual	= APP_ASI_BASE,
+	.length		= APP_ASI_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_DDR2_CONFIG_BASE),
+	.virtual	= APP_DDR2_CONFIG_BASE,
+	.length		= APP_DDR2_CONFIG_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_I2C_BASE),
+	.virtual	= APP_I2C_BASE,
+	.length		= APP_I2C_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_SPI_BASE),
+	.virtual	= APP_SPI_BASE,
+	.length		= APP_SPI_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_CT_BASE),
+	.virtual	= APP_CT_BASE,
+	.length		= APP_CT_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_PCI_CONFIG_BASE),
+	.virtual	= APP_PCI_CONFIG_BASE,
+	.length		= APP_PCI_CONFIG_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_REMAP_BASE),
+	.virtual	= APP_REMAP_BASE,
+	.length		= APP_REMAP_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_VIC_BASE),
+	.virtual	= APP_VIC_BASE,
+	.length		= APP_VIC_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_GPIO_0_BASE),
+	.virtual	= APP_GPIO_1_BASE,
+	.length		= APP_GPIO_1_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_GPIO_1_BASE),
+	.virtual	= APP_GPIO_2_BASE,
+	.length		= APP_GPIO_2_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_AEI_BASE),
+	.virtual	= APP_AEI_BASE,
+	.length		= APP_AEI_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_MAC_RX_BASE),
+	.virtual	= APP_MAC_RX_BASE,
+	.length		= APP_MAC_RX_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_MAC_TX_BASE),
+	.virtual	= APP_MAC_TX_BASE,
+	.length		= APP_MAC_TX_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_MAC_DMA_BASE),
+	.virtual	= APP_MAC_DMA_BASE,
+	.length		= APP_MAC_DMA_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_PMR_BASE),
+	.virtual	= APP_PMR_BASE,
+	.length		= APP_PMR_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_NAND_BASE),
+	.virtual	= APP_NAND_BASE,
+	.length		= APP_NAND_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_NOR_BASE),
+	.virtual	= APP_NOR_BASE,
+	.length		= APP_NOR_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_SHMEM_BASE),
+	.virtual	= APP_SHMEM_BASE,
+	.length		= APP_SHMEM_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_GP_DMA_BASE),
+	.virtual	= APP_GP_DMA_BASE,
+	.length		= APP_GP_DMA_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_TDM_BASE),
+	.virtual	= APP_TDM_CONFIG_BASE,
+	.length		= APP_TDM_CONFIG_SIZE,
+	.type		= MT_DEVICE
+ },
+
+ {
+	.pfn		= __phys_to_pfn(APP3K_PHYS_USB_BASE),
+	.virtual	= APP_USB_BASE,
+	.length		= APP_USB_SIZE,
+	.type		= MT_DEVICE
+ }
+
+};
+#endif
+
+/*
+ * Create the static mappings.
+ */
+
+#define MAPPING_CHUNK_SIZE 0x80000
+
+/*
+
+  Create the permanent IO mappings.
+*/
+
+void __init app_map_io(void)
+{
+	int index;
+	unsigned long offset;
+	struct map_desc map_desc;
+
+	for (index = 0; index < ARRAY_SIZE(app_io_desc); ++index) {
+		offset = 0;
+
+		while (0 < ((app_io_desc[index]).length - offset)) {
+			map_desc.virtual =
+				(app_io_desc[index]).virtual + offset;
+			map_desc.pfn =
+				(app_io_desc[index]).pfn + __phys_to_pfn(offset);
+
+			if (MAPPING_CHUNK_SIZE >
+					((app_io_desc[index]).length - offset))
+				map_desc.length =
+					((app_io_desc[index]).length - offset);
+			else
+				map_desc.length = MAPPING_CHUNK_SIZE;
+
+			map_desc.type = (app_io_desc[index]).type;
+			offset += map_desc.length;
+			create_mapping(&map_desc);
+		}
+	}
+
+	return;
+}
-- 
1.6.5.2

