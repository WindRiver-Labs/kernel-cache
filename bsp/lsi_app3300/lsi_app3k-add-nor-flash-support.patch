From f790b8d1f6cd621fcf204724b8bfb41f54592038 Mon Sep 17 00:00:00 2001
From: Tony Liu <Bo.Liu@windriver.com>
Date: Tue, 30 Mar 2010 15:40:15 +0800
Subject: [PATCH 10/13] lsi_app3k: add nor flash support

There is a 4M on-board NOR flash. Merge most flash manipulation codes
from vendor drop(Agere APP Linux Version 2.6.1.5.pre10 05/07/2009),
then rearrange to standard linux driver style.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/mtd/maps/Kconfig       |    8 +
 drivers/mtd/maps/Makefile      |    1 +
 drivers/mtd/maps/app3k-flash.c |  321 ++++++++++++++++++++++++++++++++++++++++
 drivers/mtd/maps/app3k-flash.h |   71 +++++++++
 4 files changed, 401 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/maps/app3k-flash.c
 create mode 100644 drivers/mtd/maps/app3k-flash.h

diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index aa2807d..b25ca4b 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -551,4 +551,12 @@ config MTD_PISMO
 
 	  When built as a module, it will be called pismo.ko
 
+config MTD_APP3K
+	tristate "CFI Flash device mapped on LSI APP3K"
+	depends on ARCH_APP3K
+	select MTD_COMPLEX_MAPPINGS
+	help
+	  This enables access routines for the flash chips on the LSI APP3K
+	  based MSBG boards. If you have one of these boards and would like
+	  to use the flash chips on it, say 'Y'.
 endmenu
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index bb035cd..dbf3062 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -59,3 +59,4 @@ obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
+obj-$(CONFIG_MTD_APP3K)		+= app3k-flash.o
diff --git a/drivers/mtd/maps/app3k-flash.c b/drivers/mtd/maps/app3k-flash.c
new file mode 100644
index 0000000..b47c5b2
--- /dev/null
+++ b/drivers/mtd/maps/app3k-flash.c
@@ -0,0 +1,321 @@
+/*
+ * app3k-flash.c
+ *
+ * Flash memory access on APP3xx based devices
+ *
+ * Copyright (C) 2004 Agere Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+
+#include <asm/mach/flash.h>
+#include <mach/hardware.h>
+#include <mach/ubootenv.h>
+#include "app3k-flash.h"
+
+extern unsigned long uboot_size;
+extern unsigned long ubootenv0_size;
+extern unsigned long ubootenv1_size;
+
+extern int ubootenv_get(const char *, char *);
+
+static int ready;
+static const char *probes[] = {"cmdlinepart", NULL};
+
+static int app3k_flash_read(void *address, unsigned long offset, int number)
+{
+	union ni_nor_ind_cmd_ad_t cmd_ad;
+	volatile unsigned long data[4];
+
+	while (0 < number) {
+		cmd_ad.raw = 0;
+		cmd_ad.bits.req_addr = offset;
+		cmd_ad.bits.req_size =
+			TO_REQ_SIZE((16 <= number) ? 16 : number);
+		number -= FROM_REQ_SIZE(cmd_ad.bits.req_size);
+		cmd_ad.bits.req_type = 0;
+		cmd_ad.bits.req_valid = 1;
+
+		__raw_writel(cmd_ad.raw, HI_NOR_IND_CMD_AD);
+
+		while (0 != (__raw_readl(HI_NOR_IND_CMD_AD) & 0x80000000));
+
+		data[0] = __raw_readl(HI_NOR_IND_DAT0);
+		data[1] = __raw_readl(HI_NOR_IND_DAT1);
+		data[2] = __raw_readl(HI_NOR_IND_DAT2);
+		data[3] = __raw_readl(HI_NOR_IND_DAT3);
+
+		memcpy(address, (void *)&(data[0]),
+				FROM_REQ_SIZE(cmd_ad.bits.req_size));
+
+		address += FROM_REQ_SIZE(cmd_ad.bits.req_size);
+		offset += FROM_REQ_SIZE(cmd_ad.bits.req_size);
+	}
+
+	return 0;
+}
+
+static int app3k_flash_write(const void *address,
+		unsigned long offset, int number)
+{
+	union ni_nor_ind_cmd_ad_t cmd_ad;
+	volatile unsigned long data[4];
+
+	while (0 < number) {
+		cmd_ad.raw = 0;
+		cmd_ad.bits.req_size =
+			TO_REQ_SIZE((16 <= number) ? 16 : number);
+		cmd_ad.bits.req_addr = offset;
+		cmd_ad.bits.req_type = 1;
+		cmd_ad.bits.req_valid = 1;
+		memset((void *)&(data[0]), 0, sizeof(data));
+		memcpy((void *)&(data[0]), address,
+				FROM_REQ_SIZE(cmd_ad.bits.req_size));
+		__raw_writel(data[0], HI_NOR_IND_DAT0);
+		__raw_writel(data[1], HI_NOR_IND_DAT1);
+		__raw_writel(data[2], HI_NOR_IND_DAT2);
+		__raw_writel(data[3], HI_NOR_IND_DAT3);
+
+		BARRIER();
+
+		__raw_writel(cmd_ad.raw, HI_NOR_IND_CMD_AD);
+
+		while (0 != (__raw_readl(HI_NOR_IND_CMD_AD) & 0x80000000));
+
+		number -= FROM_REQ_SIZE(cmd_ad.bits.req_size);
+		address += FROM_REQ_SIZE(cmd_ad.bits.req_size);
+		offset += FROM_REQ_SIZE(cmd_ad.bits.req_size);
+	}
+
+	return 0;
+}
+
+static map_word app3k_flash_read8(struct map_info *map,
+		unsigned long address)
+{
+	unsigned char temp;
+	map_word value;
+
+	app3k_flash_read((void *)&temp, address, 1);
+	value.x[0] = temp;
+
+	return value;
+}
+
+static void app3k_flash_copy_from(struct map_info *map, void *to,
+		unsigned long from, ssize_t len)
+{
+
+	app3k_flash_read(to, from, len);
+}
+
+static void app3k_flash_write8(struct map_info *map,
+		const map_word value, unsigned long address)
+{
+	app3k_flash_write((const void *)&(value.x[0]), address, 1);
+}
+
+void app3k_flash_cpy(void *destination, const void *source, size_t size)
+{
+	union flash_controller_configuration_t configuration;
+
+	if (ready) {
+		configuration.raw = 0;
+		configuration.bits.clock_wait = 0x14;
+		configuration.bits.write_protect = 1;
+		configuration.bits.reset = 1;
+		configuration.bits.web_late = 0;
+		configuration.bits.nand_flash_select = 1;
+		configuration.bits.nor_disable_direct = 1;
+		configuration.bits.nor_flash_respond = 1;
+		configuration.bits.nor_flash_interrupt = 0;
+
+		writel(configuration.raw, (APP_AEI_BASE + 0x10));
+		app3k_flash_read(destination, (unsigned long)source, size);
+	} else
+		printk(KERN_INFO "Not Ready!\n");
+}
+
+static int __init app3k_flash_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	union flash_controller_configuration_t configuration;
+	struct app3k_flash_info *info;
+	struct flash_platform_data *pdata = pdev->dev.platform_data;
+	struct resource *res = pdev->resource;
+	unsigned long size = res->end - res->start + 1;
+
+	info = (struct app3k_flash_info *)
+		kzalloc(sizeof(struct app3k_flash_info), GFP_KERNEL);
+	if (!info) {
+		printk(KERN_ERR "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	info->map.virt = ioremap(res->start, size);
+	if (!info->map.virt) {
+		printk(KERN_ERR "%s: map device address failed\n", __func__);
+		goto free;
+	}
+
+	/*flash characteristics*/
+	info->map.name = dev_name(&pdev->dev);
+	info->map.phys = res->start;
+	info->map.size = size;
+	info->map.bankwidth = pdata->width;
+
+	info->map.read		= app3k_flash_read8;
+	info->map.write		= app3k_flash_write8;
+	info->map.copy_from = app3k_flash_copy_from;
+
+	configuration.raw = 0;
+	configuration.bits.clock_wait = 0x14;
+	configuration.bits.write_protect = 1;
+	configuration.bits.reset = 1;
+	configuration.bits.web_late = 0;
+	configuration.bits.nand_flash_select = 1;
+	configuration.bits.nor_disable_direct = 1;
+	configuration.bits.nor_flash_respond = 1;
+	configuration.bits.nor_flash_interrupt = 0;
+
+	__raw_writel(configuration.raw, (APP_AEI_BASE + 0x10));
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+
+	printk(KERN_INFO "Probing FLASH\n");
+
+	info->mtd = do_map_probe("cfi_probe", &info->map);
+	ret = -ENXIO;
+
+	if (!info->mtd)
+		goto unmap;
+
+	info->mtd->owner = THIS_MODULE;
+
+	ret = parse_mtd_partitions(info->mtd, probes, &info->parts, 0);
+	if (0 < ret) {
+		ret = add_mtd_partitions(info->mtd, info->parts, ret);
+		if (ret) {
+			printk(KERN_ERR "add_mt_partitions() failed,"
+					"return code was %d\n", ret);
+			goto unmap;
+		}
+	} else if (ret <= 0 && pdata->parts) {
+		/*
+		 * Since no partitions were passed in on the command line, try
+		 * the previous method (flash_partitions etc.). At the least,
+		 * define the default partitions for the boot loader and
+		 * boot loader environments.
+		 */
+		ret = add_mtd_partitions(info->mtd,
+				pdata->parts, pdata->nr_parts);
+		if (ret) {
+			printk(KERN_ERR "add_mt_partitions() failed,"
+					"return code was %d\n", ret);
+			goto unmap;
+		}
+	} else {
+		printk(KERN_INFO "%s: no available partitions\n", __func__);
+		add_mtd_device(info->mtd);
+	}
+
+	platform_set_drvdata(pdev, info);
+
+	ready = 1;
+
+	/* notify platform uboot observer that flash container is ready */
+	raw_notifier_call_chain(&ubootenv_head, 0, NULL);
+
+	return 0;
+
+unmap:
+	iounmap(info->map.virt);
+free:
+	kfree(info);
+
+	return ret;
+}
+
+static int app3k_flash_remove(struct platform_device *pdev)
+{
+	struct app3k_flash_info *info = platform_get_drvdata(pdev);
+	struct flash_platform_data *pdata = pdev->dev.platform_data;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (info) {
+		if (info->parts) {
+			del_mtd_partitions(info->mtd);
+			kfree(info->parts);
+		} else if (pdata->parts)
+			del_mtd_partitions(info->mtd);
+		else
+			del_mtd_device(info->mtd);
+
+		map_destroy(info->mtd);
+		iounmap((void __iomem *)info->map.virt);
+		kfree(info);
+	}
+
+	return 0;
+}
+
+struct platform_driver app3k_flash_drv = {
+	.driver = {
+		.name = "app3k-flash-nor",
+	},
+	.probe = app3k_flash_probe,
+	.remove = app3k_flash_remove,
+};
+
+static int __init app3k_mtd_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&app3k_flash_drv);
+	if (ret)
+		printk(KERN_ERR "%s-%d: register platform driver failed\n",
+				__func__, ret);
+
+	return ret;
+}
+
+static void __exit app3k_mtd_exit(void)
+{
+	platform_driver_unregister(&app3k_flash_drv);
+}
+
+module_init(app3k_mtd_init);
+module_exit(app3k_mtd_exit);
+
+MODULE_AUTHOR("Michael W. Bringmann");
+MODULE_DESCRIPTION("APP3XX CFI map driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/maps/app3k-flash.h b/drivers/mtd/maps/app3k-flash.h
new file mode 100644
index 0000000..f31bc7b
--- /dev/null
+++ b/drivers/mtd/maps/app3k-flash.h
@@ -0,0 +1,71 @@
+/*
+ * app3k-flash.h
+ *
+ * Flash memory access on LSI APP3k based devices
+ *
+ * Copyright (C) 2004 Agere Systems Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __APP3K_FLASH_H
+#define __APP3K_FLASH_H
+
+#include <mach/hardware.h>
+
+#define BARRIER() __asm__ __volatile__("" : : : "memory")
+#define TO_REQ_SIZE(bytes) ((bytes == 16) ? 0 : bytes)
+#define FROM_REQ_SIZE(req_size) ((req_size == 0) ? 16 : req_size)
+
+#define HI_NOR_IND_CMD_AD	(APP_AEI_BASE + 0x6c)
+#define HI_NOR_IND_DAT0		(APP_AEI_BASE + 0x70)
+#define HI_NOR_IND_DAT1		(APP_AEI_BASE + 0x74)
+#define HI_NOR_IND_DAT2		(APP_AEI_BASE + 0x78)
+#define HI_NOR_IND_DAT3		(APP_AEI_BASE + 0x7c)
+
+union flash_controller_configuration_t {
+	unsigned long raw;
+	struct {
+		unsigned long clock_wait:8;
+		unsigned long write_protect:1;
+		unsigned long reset:1;
+		unsigned long web_late:1;
+		unsigned long nand_flash_select:1;
+		unsigned long nor_disable_direct:1;
+		unsigned long nor_flash_respond:1;
+		unsigned long nor_flash_interrupt:1;
+		unsigned long pad:17;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+union ni_nor_ind_cmd_ad_t {
+	unsigned long raw;
+	struct {
+		unsigned long req_addr:26;
+		unsigned long req_size:4; /* 0=16bytes, 1=1byte, ..., 15=15bytes */
+		unsigned long req_type:1; /* 0=read 1=write */
+		unsigned long req_valid:1; /* 1=start, cleared by hw when complete */
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+
+struct app3k_flash_info {
+	struct mtd_partition *parts;
+	struct mtd_info *mtd;
+	struct map_info map;
+};
+
+#endif /* __APP3K_FLASH_H */
-- 
1.6.5.2

