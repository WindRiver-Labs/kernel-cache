From 1be0ff36a7963c53180ed69caeee36dca9ea27d5 Mon Sep 17 00:00:00 2001
From: Tony Liu <Bo.Liu@windriver.com>
Date: Tue, 30 Mar 2010 14:40:39 +0800
Subject: [PATCH 03/13] lsi_app: implement platform common clock framework

Mainly based on TI OMAP2 clock mechanism, implement common clock framework
for LSI APP platform.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-app/clock.c               |  239 +++++++++++++++++++++++++++++++
 arch/arm/mach-app/include/mach/clkdev.h |   27 ++++
 arch/arm/mach-app/include/mach/clock.h  |   59 ++++++++
 3 files changed, 325 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-app/clock.c
 create mode 100644 arch/arm/mach-app/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-app/include/mach/clock.h

diff --git a/arch/arm/mach-app/clock.c b/arch/arm/mach-app/clock.c
new file mode 100644
index 0000000..745733c
--- /dev/null
+++ b/arch/arm/mach-app/clock.c
@@ -0,0 +1,239 @@
+/*
+ * arch/arm/mach-app/clock.c
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+
+#include <mach/clock.h>
+
+static LIST_HEAD(clocks);
+static LIST_HEAD(root_clks);
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clocks_lock);
+
+static struct clk_functions *platform_clk;
+
+void propagate_rate(struct clk *clk)
+{
+	struct clk *clkp;
+
+	list_for_each_entry(clkp, &clk->children, sibling) {
+		if (clkp->recalc)
+			clkp->rate = clkp->recalc(clkp);
+		propagate_rate(clkp);
+	}
+}
+
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (!clk->count++) {
+		if (clk->enable)
+			ret = clk->enable(clk);
+		else if (platform_clk->enable)
+			ret = platform_clk->enable(clk);
+		else
+			clk->count--;
+	}
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+			return;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (!(--clk->count)) {
+		if (clk->disable)
+			clk->disable(clk);
+		else if (platform_clk->disable)
+			platform_clk->disable(clk);
+	}
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return;
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	unsigned long flags;
+	unsigned long ret = 0;
+
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (clk->get_rate)
+		ret = clk->get_rate(clk);
+	else if (platform_clk->get_rate)
+		ret = platform_clk->get_rate(clk);
+	else
+		ret = clk->rate;
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	long ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (platform_clk->round_rate)
+		ret = platform_clk->round_rate(clk, rate);
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (clk->set_rate)
+		ret = clk->set_rate(clk, rate);
+	else if (platform_clk->set_rate)
+		ret = platform_clk->set_rate(clk, rate);
+
+	if (ret == 0) {
+		if (clk->recalc)
+			clk->rate = clk->recalc(clk);
+
+		propagate_rate(clk);
+	}
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || parent == NULL || IS_ERR(parent))
+		return ret;
+
+	spin_lock_irqsave(&clocks_lock, flags);
+	if (clk->count == 0) {
+		if (platform_clk->set_parent)
+			ret = platform_clk->set_parent(clk, parent);
+
+		if (ret == 0) {
+			if (clk->recalc)
+				clk->rate = clk->recalc(clk);
+			propagate_rate(clk);
+		}
+	} else
+		ret = -EBUSY;
+	spin_unlock_irqrestore(&clocks_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *clk)
+{
+	return clk->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+int clk_register(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	/*
+	 * trap out already registered clocks
+	 */
+	if (clk->node.next || clk->node.prev)
+		return 0;
+
+	mutex_lock(&clocks_mutex);
+	if (clk->parent)
+		list_add(&clk->sibling, &clk->parent->children);
+	else
+		list_add(&clk->sibling, &root_clks);
+
+	if (clk->init)
+		clk->init(clk);
+
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL(clk_register);
+
+void clk_unregister(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->sibling);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+EXPORT_SYMBOL(clk_unregister);
+
+int __init clk_platform_register(struct clk_functions *plat_func)
+{
+	if (!plat_func)
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	platform_clk = plat_func;
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
diff --git a/arch/arm/mach-app/include/mach/clkdev.h b/arch/arm/mach-app/include/mach/clkdev.h
new file mode 100644
index 0000000..a9c87d9
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/clkdev.h
@@ -0,0 +1,27 @@
+/*
+ * include/mach/clkdev.h
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_CLKDEV_H
+#define __ASM_ARCH_CLKDEV_H
+
+#define __clk_get(clk)	({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-app/include/mach/clock.h b/arch/arm/mach-app/include/mach/clock.h
new file mode 100644
index 0000000..6a4a99d
--- /dev/null
+++ b/arch/arm/mach-app/include/mach/clock.h
@@ -0,0 +1,59 @@
+/*
+ * include/mach/clock.h
+ *
+ * Copyright (c) 2010 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_CLK_H
+#define __ASM_ARCH_CLK_H
+#include <linux/list.h>
+
+#define INIT_CL(dev, con, ck) \
+{ .dev_id = dev, .con_id = con, .clk = ck }
+
+struct clk_functions {
+	int		(*enable)(struct clk *clk);
+	void	(*disable)(struct clk *clk);
+	long	(*round_rate)(struct clk *clk, unsigned long rate);
+	int		(*set_rate)(struct clk *clk, unsigned long rate);
+	unsigned long (*get_rate)(struct clk *clk);
+	int		(*set_parent)(struct clk *clk, struct clk *parent);
+};
+
+struct clk {
+	struct list_head	node;
+	const char			*name;
+	struct clk			*parent;
+	struct list_head	children;
+	struct list_head	sibling;
+	unsigned long		rate;
+	void __iomem		*enable_reg;
+	int					enable_bit;
+	int					count;
+	void	(*init)(struct clk *clk);
+	int		(*enable)(struct clk *clk);
+	void	(*disable)(struct clk *clk);
+	long	(*recalc)(struct clk *clk);
+	int		(*set_rate)(struct clk *clk, unsigned long rate);
+	unsigned long (*get_rate)(struct clk *clk);
+};
+
+int clk_platform_register(struct clk_functions *plat_func);
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
+
+#endif /*__ASM_ARCH_CLK_H*/
-- 
1.6.5.2

