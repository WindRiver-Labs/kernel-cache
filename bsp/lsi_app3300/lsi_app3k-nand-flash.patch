From 21d3392db88c27b932d91139607e9395dda62e7c Mon Sep 17 00:00:00 2001
From: Tony Liu <Bo.Liu@windriver.com>
Date: Thu, 13 May 2010 17:39:49 +0800
Subject: [PATCH] lsi_app3k: nand flash

Merge nand flash codes from vendor drop app_linux_2.6.1.5.tar.gz.
The nand flash controller has hardware quirks, so some specifical
handlings have to be added into common nand base layer.

Signed-off-by: Tony Liu <Bo.Liu@windriver.com>
---
 drivers/mtd/nand/Kconfig      |    6 +
 drivers/mtd/nand/Makefile     |    1 +
 drivers/mtd/nand/app3k_nand.c |  762 +++++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/nand_base.c  |   48 +++-
 4 files changed, 816 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mtd/nand/app3k_nand.c

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 42e5ea4..bc607a9 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -104,6 +104,12 @@ config MTD_NAND_TS7250
 config MTD_NAND_IDS
 	tristate
 
+config MTD_NAND_APP3K
+	tristate "NAND Flash device on APP3K board"
+	depends on MTD_NAND
+	help
+	  Support for NAND flash on LSI APP3K platform.
+
 config MTD_NAND_AU1550
 	tristate "Au1550/1200 NAND support"
 	depends on SOC_AU1200 || SOC_AU1550
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 1407bd1..3af5b43 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_MTD_NAND_AMS_DELTA)	+= ams-delta.o
 obj-$(CONFIG_MTD_NAND_AUTCPU12)		+= autcpu12.o
 obj-$(CONFIG_MTD_NAND_EDB7312)		+= edb7312.o
 obj-$(CONFIG_MTD_NAND_AU1550)		+= au1550nd.o
+obj-$(CONFIG_MTD_NAND_APP3K)		+= app3k_nand.o
 obj-$(CONFIG_MTD_NAND_BF5XX)		+= bf5xx_nand.o
 obj-$(CONFIG_MTD_NAND_PPCHAMELEONEVB)	+= ppchameleonevb.o
 obj-$(CONFIG_MTD_NAND_S3C2410)		+= s3c2410.o
diff --git a/drivers/mtd/nand/app3k_nand.c b/drivers/mtd/nand/app3k_nand.c
new file mode 100644
index 0000000..74ece6c
--- /dev/null
+++ b/drivers/mtd/nand/app3k_nand.c
@@ -0,0 +1,762 @@
+/*
+ * app3k_nand.c
+ *
+ * NAND Flash memory access on APP3K based devices
+ *
+ * Copyright (C) 2007 LSI Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+
+#include <asm/sizes.h>
+#include <asm/mach-types.h>
+#include <asm/mach/flash.h>
+#include <mach/hardware.h>
+
+struct app_nand_host {
+	struct nand_chip	chip;
+	struct mtd_info		mtd;
+	void __iomem		*io_base;
+};
+
+#define APP3K_NAND_CMD_START_ECC_READ   0x23
+#define APP3K_NAND_CMD_CE_OFF           0xEE
+
+#define APP3K_EP501_ECC_NUM_BYTES       12
+
+static struct nand_ecclayout app3k_nand_oob_layout = {
+	.eccbytes = APP3K_EP501_ECC_NUM_BYTES,
+	.eccpos = {
+		52, 53, 54, 55, 56, 57,
+		58, 59, 60, 61, 62, 63},
+	.oobfree = {
+		{.offset = 2,
+		.length = 50} }
+};
+
+
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition *partition_info;
+static const char *probes[] = { "cmdlinepart", NULL };
+#endif
+
+/*
+ * hardware specific access to control-lines
+ */
+static void app3k_nand_hwcontrol(struct mtd_info *mtd,
+		int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = NULL;
+
+	if (!mtd) {
+		printk(KERN_ERR
+			"app3k_nand_hwcontrol(): ERROR: NULL mtd passed.\n");
+		return;
+	}
+
+	chip = (struct nand_chip *)mtd->priv;
+
+	if (!chip) {
+		printk(KERN_ERR
+			"app3k_nand_hwcontrol(): ERROR: NULL chip passed.\n");
+		return;
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		__raw_writel(cmd, (chip->IO_ADDR_W + APP3K_NAND_CMD_REG));
+
+	return;
+}
+
+/*
+ * read device ready pin
+ */
+static int app3k_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	int ready = 0;
+
+	ready = __raw_readl(chip->IO_ADDR_R + APP3K_NAND_INTR_STATUS_REG);
+
+	return ready & NAND_STATUS_TRUE_READY;
+}
+
+/**
+ * app3k_nand_command - [DEFAULT] Send command to NAND large page device
+ * @mtd:	MTD device structure
+ * @command:	the command to be sent
+ * @column:	the column address for this command, -1 if none
+ * @page_addr:	the page address for this command, -1 if none
+ *
+ * Send command to NAND device. This is the version for the new large page
+ * devices We dont have the separate regions as we have in the small page
+ * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
+ */
+static void app3k_nand_command(struct mtd_info *mtd,
+		unsigned int command, int column, int page_addr)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	unsigned long index = 0;
+	unsigned int status = 0;
+
+	command &= 0xff;
+
+	/* Emulate NAND_CMD_READOOB */
+	if (command == NAND_CMD_READOOB) {
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+	}
+
+	/* return if unhandled command is issued */
+	if (command != NAND_CMD_READ0 &&
+		command != NAND_CMD_SEQIN && command != NAND_CMD_ERASE1 &&
+		command != NAND_CMD_STATUS && command != NAND_CMD_READID &&
+		command != NAND_CMD_RESET &&
+		command != APP3K_NAND_CMD_START_ECC_READ &&
+		command != NAND_CMD_PAGEPROG &&
+		command != NAND_CMD_ERASE2) {
+		printk(KERN_ERR "app3k_nand_command(): WARN: Unhandled"
+			"command 0x%x issued for page=0x%x, column=0x%x.\n",
+			command, page_addr, column);
+		return;
+	}
+
+	/* Command latch cycle */
+	chip->cmd_ctrl(mtd, command,
+			NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+
+	if (column != -1 || page_addr != -1) {
+		/* column number */
+		if (column != -1)
+			index = column & 0xfff;
+
+		/* page and block number */
+		if (page_addr != -1)
+			index += ((page_addr & 0x7ffff) << 12);
+
+		/* write index reg */
+		__raw_writel(index, chip->IO_ADDR_W + APP3K_NAND_INDEX_REG);
+
+		/* write ext index reg */
+		__raw_writel(0, chip->IO_ADDR_W + APP3K_NAND_EXT_INDEX_REG);
+	}
+
+	/* for read command, send 0xe0 so data is populated */
+	if (command == NAND_CMD_READ0) {
+		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
+				NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		/* wait until CHIP_BUSY goes low */
+		do {
+			udelay(chip->chip_delay);
+			status = chip->dev_ready(mtd);
+		} while (!status);
+	} else if (command == NAND_CMD_STATUS)
+		udelay(chip->chip_delay);
+
+	return;
+}
+
+/**
+ * app3k_nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void app3k_nand_read_buf(struct mtd_info *mtd,
+		uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++)
+		p[i] = __raw_readl(chip->IO_ADDR_R);
+
+	return;
+}
+
+/**
+ * app3k_nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void app3k_nand_write_buf(struct mtd_info *mtd,
+		const uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++)
+		__raw_writel(p[i], chip->IO_ADDR_W);
+
+	return;
+}
+
+/**
+ * app3k_nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int app3k_nand_verify_buf(struct mtd_info *mtd,
+		const uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++) {
+		udelay(chip->chip_delay);
+
+		if (p[i] != __raw_readl((uint32_t *)chip->IO_ADDR_R))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int app3k_nand_read_status(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_STATUS, 0);
+
+	return __raw_readl(chip->IO_ADDR_R + APP3K_NAND_STATUS1_REG) & 0xff;
+}
+
+
+/**
+ * app3k_nand_wait - [DEFAULT]  wait until the command is done
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip structure
+ *
+ * Wait for command done. This applies to erase and program only
+ * Erase can take up to 400ms and program up to 20ms according to
+ * general NAND and SmartMedia specs
+ */
+static int app3k_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	int status = 0;
+	loff_t offset = 0;
+
+	while (1) {
+		status = 0;
+		udelay(chip->chip_delay);
+		/* wait for PECC_BUSY to go down for reading or writing */
+		if (chip->state == FL_WRITING || chip->state == FL_READING) {
+			status = readl(APP_AEI_BASE + APP3K_AEI_LLP_CS_CTRL);
+
+			/* bit 22 is nand_ecc_busy */
+			if ((status & 0x400000) == 0)
+				break;
+		} else if (chip->state == FL_ERASING) {
+		 /* wait till PER/cache ready bit becomes ready */
+			status = chip->dev_ready(mtd);
+			if (status)
+				break;
+
+		} else {
+			printk(KERN_ERR
+				"WARN: NAND wait called in unknown state %d\n",
+				chip->state);
+			break;
+		}
+
+	}
+
+	status = app3k_nand_read_status(mtd);
+	if (status & NAND_STATUS_FAIL) {
+		offset = (readl(chip->IO_ADDR_R +
+				APP3K_NAND_INDEX_REG) >> 12) << 11;
+		printk(KERN_ERR
+			"app3k_nand_wait(): Action %d failed for "
+			"Offset: 0x%llx, status 0x%x\n\n",
+			chip->state, offset, status);
+	}
+
+	return status;
+}
+
+void app3k_nand_ecc_hwctl(struct mtd_info *mtd, int mode)
+{
+	/* nothing to do to enable ECC */
+	return;
+}
+
+int app3k_nand_ecc_calculate(struct mtd_info *mtd,
+		const uint8_t *dat, uint8_t *ecc_code)
+{
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+
+	/* start ECC calculation */
+	if (chip->state == FL_READING)
+		chip->cmdfunc(mtd, APP3K_NAND_CMD_START_ECC_READ, -1, -1);
+	else if (chip->state == FL_WRITING)
+		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/* wait for PECC_BUSY to go down */
+	udelay(5);
+
+	return chip->waitfunc(mtd, chip);
+}
+
+int app3k_nand_ecc_correct(struct mtd_info *mtd,
+		uint8_t *dat, uint8_t *read_ecc, uint8_t *calc_ecc)
+{
+	/* nothing to do to correct ECC */
+	return 0;
+}
+
+/**
+ * app3k_nand_read_page_hwecc - hardware ecc based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ *
+ * Not for syndrome calculating ecc controllers which need a special oob layout
+ */
+
+static int app3k_nand_read_page_hwecc(struct mtd_info *mtd,
+		struct nand_chip *chip, uint8_t *buf)
+{
+	int i;
+	unsigned long ecc_status = 0;
+	int page = 0;
+
+	/* Read the current page number and save it. */
+	page = readl(chip->IO_ADDR_R + APP3K_NAND_INDEX_REG) >> 12;
+
+	/* read the page */
+	chip->read_buf(mtd, buf, mtd->writesize);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	for (i = 0; i < (mtd->writesize >> 9); i++) {
+		ecc_status = readl(chip->IO_ADDR_R + APP3K_NAND_PECC_REG);
+		if ((ecc_status & 0x3000) == 1) {
+		  printk(KERN_ERR
+			"Single ECC Error at page 0x%x column 0x%lx\n",
+			page, ecc_status & 0xfff);
+			mtd->ecc_stats.corrected++;
+		} else if ((ecc_status & 0x3000) == 2) {
+		  printk(KERN_ERR
+			"Uncorrectable ECC Error at page 0x%x "
+			"column 0x%lx\n",
+			page, ecc_status & 0xfff);
+			mtd->ecc_stats.failed++;
+		}
+	}
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, APP3K_NAND_CMD_CE_OFF, 0);
+
+	return 0;
+}
+
+/**
+ * app3k_nand_write_page_hwecc - hardware ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ */
+static void app3k_nand_write_page_hwecc(struct mtd_info *mtd,
+		struct nand_chip *chip, const uint8_t *buf)
+{
+
+	/* write the page data */
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi,
+		mtd->oobsize - APP3K_EP501_ECC_NUM_BYTES);
+
+	return;
+}
+
+/**
+ * app3k_nand_write_page - [REPLACEABLE] write one page
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip descriptor
+ * @buf:	the data to write
+ * @page:	page number to write
+ * @cached:	cached programming
+ * @raw:	use _raw version of write_page
+ */
+static int app3k_nand_write_page(struct mtd_info *mtd,
+	struct nand_chip *chip, const uint8_t *buf, int page,
+	int cached, int raw)
+{
+	int status;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	if (unlikely(raw))
+		chip->ecc.write_page_raw(mtd, chip, buf);
+	else
+		chip->ecc.write_page(mtd, chip, buf);
+
+	/* calculate ECC */
+	status = chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, APP3K_NAND_CMD_CE_OFF, 0);
+
+	/*
+	 * See if operation failed and additional status checks are
+	 * available
+	 */
+	if (status & NAND_STATUS_FAIL) {
+		printk(KERN_ERR
+			"ERROR: Page write failed for page 0x%x\n", page);
+
+		if (chip->errstat)
+			status = chip->errstat(mtd, chip, FL_WRITING, status,
+					page);
+
+		return -EIO;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	if (chip->verify_buf(mtd, buf, mtd->writesize))
+		return -EIO;
+#endif
+
+	return 0;
+}
+
+
+/**
+ * app3k_nand_read_oob_std - [REPLACABLE] the most common OOB data
+ *					read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ */
+static int app3k_nand_read_oob(struct mtd_info *mtd,
+		struct nand_chip *chip, int page, int sndcmd)
+{
+	unsigned long ecc_status = 0;
+	int i = 0;
+
+	/* send command to read oob */
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	for (i = 0; i < (mtd->writesize >> 9); i++) {
+		ecc_status = __raw_readl(chip->IO_ADDR_R + APP3K_NAND_PECC_REG);
+		if ((ecc_status & 0x3000) == 1) {
+			printk(KERN_ERR
+				"Single ECC Error at page 0x%x column 0x%lx\n",
+				page, ecc_status & 0xfff);
+			mtd->ecc_stats.corrected++;
+		} else if ((ecc_status & 0x3000) == 2) {
+			printk(KERN_ERR
+				"Uncorrectable ECC Error at page 0x%x"
+				"column 0x%lx\n",
+				page, ecc_status & 0xfff);
+			mtd->ecc_stats.failed++;
+		}
+	}
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, APP3K_NAND_CMD_CE_OFF, 0);
+
+	return sndcmd;
+}
+
+/**
+ * app3k_nand_write_oob_std - [REPLACABLE] the most common OOB data write
+ *                            function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to write
+ */
+
+static int app3k_nand_write_oob(struct mtd_info *mtd,
+		struct nand_chip *chip, int page)
+{
+	/* start OOB write */
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi,
+			mtd->oobsize - APP3K_EP501_ECC_NUM_BYTES);
+
+	/* calculate ECC */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, APP3K_NAND_CMD_CE_OFF, 0);
+
+	return (chip->dev_ready(mtd) & NAND_STATUS_FAIL) ? -EIO : 0;
+}
+
+static void app3k_nand_hw_init(struct nand_chip *chip)
+{
+	unsigned long data = 0;
+
+	/* reset nand controller */
+	data = __raw_readl(APP_AEI_BASE + APP3K_AEI_LLP_CS_CTRL);
+	data |= 0x200000;
+	__raw_writel(data, APP_AEI_BASE + APP3K_AEI_LLP_CS_CTRL);
+	data &= ~(0x200000);
+	__raw_writel(data, APP_AEI_BASE + APP3K_AEI_LLP_CS_CTRL);
+
+	/* clear any existing ECC status */
+	__raw_writel(0x0, chip->IO_ADDR_W + APP3K_NAND_INTR_STATUS_REG);
+	/* enable ECC */
+	__raw_writel(0x0, chip->IO_ADDR_W + APP3K_NAND_INTR_EN_REG);
+
+	/* setup timing ctrl 0 reg */
+	/* setup time for CLE, CE# and ALE to command */
+	data = 0x05;
+	/* write pulse width */
+	data |= (0x0c << 8);
+	/* read pulse width */
+	data |= (0x0c << 16);
+	/* CLE, CE# and ALE hold time relative to WE# rising edge */
+	data |= (0x03 << 24);
+	__raw_writel(data, chip->IO_ADDR_W + APP3K_NAND_TIMING1_REG);
+
+	/* setup timing ctrl 1 reg */
+	/* setup time for CLE, CE# and ALE to command */
+	data = 0x3;
+	/* write pulse width */
+	data |= (0x03 << 8);
+	/* read pulse width */
+	data |= (0x07 << 16);
+	/* CLE, CE# and ALE hold time relative to WE# rising edge */
+	data |= (0x1e << 24);
+	__raw_writel(data, chip->IO_ADDR_W + APP3K_NAND_TIMING2_REG);
+
+}
+
+/*
+ * Main initialization routine
+ */
+static int __init app3k_nand_probe(struct platform_device *pdev)
+{
+	struct app_nand_host *host = NULL;
+	struct flash_platform_data *flash;
+	struct mtd_info *mtd;
+	struct nand_chip *nand_chip;
+	struct resource *res;
+	int ret;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		printk(KERN_ERR "app3k_nand: can't get I/O resource mem\n");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	host = kzalloc(sizeof(*host), GFP_KERNEL);
+	if (!host) {
+		printk(KERN_ERR "app3k_nand: out of memory\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (!res) {
+		printk(KERN_ERR "app3k_nand: failed to request I/O memory\n");
+		ret = -EBUSY;
+		goto free;
+	}
+
+	host->io_base = ioremap(res->start, resource_size(res));
+	if (!host->io_base) {
+		printk(KERN_ERR "app3k_nand: failed to map I/O memory");
+		ret = -EBUSY;
+		goto release;
+	}
+
+	mtd = &host->mtd;
+	nand_chip = &host->chip;
+
+	nand_chip->priv = host;
+	mtd->priv = nand_chip;
+	mtd->owner = THIS_MODULE;
+
+	/* init chip callbacks */
+	nand_chip->IO_ADDR_R = (void __iomem *)host->io_base;
+	nand_chip->IO_ADDR_W = (void __iomem *)host->io_base;
+	nand_chip->write_buf = app3k_nand_write_buf;
+	nand_chip->read_buf = app3k_nand_read_buf;
+	nand_chip->verify_buf = app3k_nand_verify_buf;
+	nand_chip->write_page = app3k_nand_write_page;
+	nand_chip->cmd_ctrl = app3k_nand_hwcontrol;
+	nand_chip->dev_ready = app3k_nand_device_ready;
+	nand_chip->cmdfunc = app3k_nand_command;
+	nand_chip->waitfunc = app3k_nand_wait;
+	nand_chip->chip_delay = 30;
+	nand_chip->options = NAND_USE_FLASH_BBT;
+
+	/* initialize ECC */
+	nand_chip->ecc.mode = NAND_ECC_HW;
+	nand_chip->ecc.steps = 1;
+	nand_chip->ecc.size = 2048;
+	nand_chip->ecc.bytes = 12;
+	nand_chip->ecc.total = 12;
+	nand_chip->ecc.hwctl = app3k_nand_ecc_hwctl;
+	nand_chip->ecc.calculate = app3k_nand_ecc_calculate;
+	nand_chip->ecc.correct = app3k_nand_ecc_correct;
+	nand_chip->ecc.read_page = app3k_nand_read_page_hwecc;
+	nand_chip->ecc.write_page = app3k_nand_write_page_hwecc;
+	nand_chip->ecc.read_page_raw = app3k_nand_read_page_hwecc;
+	nand_chip->ecc.write_page_raw = app3k_nand_write_page_hwecc;
+	nand_chip->ecc.read_oob = app3k_nand_read_oob;
+	nand_chip->ecc.write_oob = app3k_nand_write_oob;
+	nand_chip->ecc.layout = &app3k_nand_oob_layout;
+
+	app3k_nand_hw_init(nand_chip);
+
+	platform_set_drvdata(pdev, host);
+
+	/* Scan to find existence of the device */
+	ret = nand_scan(mtd, 1);
+	if (ret) {
+		printk(KERN_ERR "nand_scan failure...\n");
+		goto err;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	ret = 0;
+	flash = (struct flash_platform_data *)pdev->dev.platform_data;
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	mtd->name = "app3k-flash-nand";
+	ret = parse_mtd_partitions(mtd, probes,
+			&partition_info, 0);
+#endif
+
+	if (ret > 0)
+		ret = add_mtd_partitions(mtd, partition_info, ret);
+	else if (ret <= 0 && flash->parts)
+		ret = add_mtd_partitions(mtd, flash->parts, flash->nr_parts);
+
+	if (ret) {
+		printk(KERN_ERR
+				"mtd partition registration "
+				"failed: %d\n", ret);
+		goto err_no_partitions;
+	}
+#else
+	ret = add_mtd_device(&app3k_nand_mtd);
+#endif /* #ifdef CONFIG_MTD_PARTITIONS */
+
+	if (!ret)
+		return ret;
+#ifdef CONFIG_MTD_PARTITIONS
+err_no_partitions:
+#endif
+	nand_release(mtd);
+err:
+	platform_set_drvdata(pdev, NULL);
+	iounmap(host->io_base);
+release:
+	release_mem_region(res->start, resource_size(res));
+free:
+	kfree(host);
+out:
+	return ret;
+}
+
+static int __exit app3k_nand_remove(struct platform_device *pdev)
+{
+	struct app_nand_host *host =
+			(struct app_nand_host *)platform_get_drvdata(pdev);
+	struct mtd_info *mtd = &host->mtd;
+	struct resource *res;
+
+	/* Release resources, unregister device */
+	nand_release(mtd);
+
+	iounmap(host->io_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	platform_set_drvdata(pdev, NULL);
+
+	kfree(host);
+
+	return 0;
+}
+
+struct platform_driver app3k_nand_drv = {
+	.probe = app3k_nand_probe,
+	.remove = __exit_p(app3k_nand_remove),
+	.driver = {
+		.name = "app3k-flash-nand",
+		.owner  = THIS_MODULE,
+	},
+};
+
+static int __init app3k_nand_init(void)
+{
+	return platform_driver_register(&app3k_nand_drv);
+}
+
+static void __exit app3k_nand_exit(void)
+{
+	platform_driver_unregister(&app3k_nand_drv);
+}
+module_init(app3k_nand_init);
+module_exit(app3k_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jay Jayatheerthan <jay.jayatheerthan@lsi.com>");
+MODULE_DESCRIPTION("MTD map driver for APP3K board");
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 8f2958f..6ef3848 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -52,6 +52,10 @@
 #include <linux/mtd/partitions.h>
 #endif
 
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+#include <mach/hardware.h>
+#endif
+
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
@@ -403,7 +407,12 @@ static int nand_check_wp(struct mtd_info *mtd)
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+	return __raw_readl(chip->IO_ADDR_R + APP3K_NAND_STATUS1_REG)
+					& NAND_STATUS_WP ? 0 : 1;
+#else
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+#endif
 }
 
 /**
@@ -2429,6 +2438,11 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+	/* if erase failed for a block, mark it as bad block */
+	if (status & NAND_STATUS_FAIL)
+		mtd->block_markbad(mtd, page << chip->page_shift);
+#endif
 
 	/* Do call back function */
 	if (!ret)
@@ -2601,8 +2615,13 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+	*maf_id = __raw_readb(chip->IO_ADDR_R + APP3K_NAND_ID0_REG);
+	dev_id = __raw_readb(chip->IO_ADDR_R + APP3K_NAND_ID2_REG);
+#else
 	*maf_id = chip->read_byte(mtd);
 	dev_id = chip->read_byte(mtd);
+#endif
 
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
@@ -2613,9 +2632,13 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
-
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+	tmp_manf = __raw_readb(chip->IO_ADDR_R + APP3K_NAND_ID0_REG);
+	tmp_id = __raw_readb(chip->IO_ADDR_R + APP3K_NAND_ID2_REG);
+#else
 	tmp_manf = chip->read_byte(mtd);
 	tmp_id = chip->read_byte(mtd);
+#endif
 
 	if (tmp_manf != *maf_id || tmp_id != dev_id) {
 		printk(KERN_INFO "%s: second ID read did not match "
@@ -2643,10 +2666,16 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	/* Newer devices have all the information in additional id bytes */
 	if (!type->pagesize) {
 		int extid;
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+		chip->cellinfo = __raw_readb(chip->IO_ADDR_R +
+						APP3K_NAND_ID4_REG);
+		extid = __raw_readb(chip->IO_ADDR_R + APP3K_NAND_ID6_REG);
+#else
 		/* The 3rd id byte holds MLC / multichip data */
 		chip->cellinfo = chip->read_byte(mtd);
 		/* The 4th id byte is the important one */
 		extid = chip->read_byte(mtd);
+#endif
 		/* Calc pagesize */
 		mtd->writesize = 1024 << (extid & 0x3);
 		extid >>= 2;
@@ -2669,6 +2698,23 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		busw = type->options & NAND_BUSWIDTH_16;
 	}
 
+#if defined(CONFIG_MTD_NAND_APP3K) || defined(CONFIG_MTD_NAND_APP3K_MODULE)
+	/* configure EP501 config register */
+	/* set the size of the flash */
+	tmp_id = type->chipsize >> 4;
+	for (i = 0; tmp_id > 0; i++)
+		tmp_id >>= 1;
+	tmp_id = i;
+
+	/* large block flash */
+	if (mtd->writesize > 512)
+		tmp_id |= 0x100;
+
+	/* not write protected */
+	tmp_id |= 0x200;
+	__raw_writel(tmp_id, chip->IO_ADDR_W + APP3K_NAND_CONFIG_REG);
+#endif
+
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
-- 
1.6.5.2

