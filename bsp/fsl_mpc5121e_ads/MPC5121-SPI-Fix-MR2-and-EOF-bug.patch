From ea440dddf0e11b2f5b3003b3991b0cc499d655c0 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 18 Jun 2009 15:33:51 +0800
Subject: [PATCH 10/25] MPC5121 SPI: Fix MR2 and EOF bug

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

The MR2 register must be zero for spi mode
to work correctly, this fixed that.

The PSC EOF bit needs to be set before setting
the next to last byte, but there is a problem
when only sending 1 byte.  This patch sends an
extra zero byte for the 1 byte case.

Also set the default mclk divider to 6 in the
clock driver.

Signed-off-by: Shaohui Xie <B21989@freescale.com>
Signed-off-by: John Rigby <jrigby@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/clock.c |    6 +++---
 drivers/spi/mpc512x_psc_spi.c       |   25 +++++++++++++++++++------
 2 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/arch/powerpc/platforms/512x/clock.c b/arch/powerpc/platforms/512x/clock.c
index 95cc536..00e79ec 100644
--- a/arch/powerpc/platforms/512x/clock.c
+++ b/arch/powerpc/platforms/512x/clock.c
@@ -628,9 +628,9 @@ static void psc_calc_rate(struct clk *clk, int pscnum, struct device_node *np)
 	 *
 	 * disable/set divider/enable
 	 */
-	out_be32(&clockctl->pccr[pscnum], 0);
-	out_be32(&clockctl->pccr[pscnum], 0x00020000);
-	out_be32(&clockctl->pccr[pscnum], 0x00030000);
+	out_be32(&clockctl->pccr[pscnum], 0);		/* disable divider */
+	out_be32(&clockctl->pccr[pscnum], 0x000c0000);	/* set mclk_div = 6 */
+	out_be32(&clockctl->pccr[pscnum], 0x000d0000);	/* enable divider */
 
 	if (clockctl->pccr[pscnum] & 0x80) {
 		clk->rate = spdif_rxclk.rate;
diff --git a/drivers/spi/mpc512x_psc_spi.c b/drivers/spi/mpc512x_psc_spi.c
index 2136c7f..301947f 100644
--- a/drivers/spi/mpc512x_psc_spi.c
+++ b/drivers/spi/mpc512x_psc_spi.c
@@ -116,7 +116,7 @@ static void mpc512x_psc_spi_activate_cs(struct spi_device *spi)
 	if (cs->speed_hz)
 		bclkdiv = (mps->mclk / cs->speed_hz) - 1;
 	else
-		bclkdiv = (mps->mclk / 1000000) - 1;
+		bclkdiv = (mps->mclk / 1000000) - 1;	/* default 1MHz */
 
 	ccr |= (((bclkdiv & 0xff) << 16) | (((bclkdiv >> 8) & 0xff) << 8));
 	out_be32(&psc->ccr, ccr);
@@ -153,10 +153,22 @@ static int mpc512x_psc_spi_transfer_rxtx(struct spi_device *spi,
 	u8 *tx_buf = (u8 *)t->tx_buf;
 	u8 *rx_buf = (u8 *)t->rx_buf;
 
-
 	if (!tx_buf && !rx_buf && t->len)
 		return -EINVAL;
 
+	/*
+	 * zero out Mode register 2
+	 * From the ref man:
+	 *   MR2 can be read or written when the Mode register pointer points
+	 *   to it, which occurs after any access to MR1. An MR2 access does
+	 *   not update the mode register address.
+	 */
+	in_8(&psc->mode);
+	mdelay(1);
+	out_8(&psc->mode, 0x0);
+	mdelay(1);
+	out_8(&psc->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
+
 	while (len) {
 		int count;
 		int i;
@@ -172,14 +184,15 @@ static int mpc512x_psc_spi_transfer_rxtx(struct spi_device *spi,
 		count = min(fifosz, len);
 
 		for (i = count; i > 0; i--) {
-			data = tx_buf ? *tx_buf++ : 0;
-			if (len == EOFBYTE)
+			if (len == EOFBYTE || t->len == 1)
 				setbits32(&fifo->txcmd, MPC512x_PSC_FIFO_EOF);
+			data = tx_buf ? *tx_buf++ : 0;
 			out_8(&fifo->txdata_8, data);
+			if (t->len == 1)
+				out_8(&fifo->txdata_8, 0);
 			len--;
 		}
 
-
 		INIT_COMPLETION(mps->done);
 
 		/* interrupt on tx fifo empty */
@@ -200,7 +213,7 @@ static int mpc512x_psc_spi_transfer_rxtx(struct spi_device *spi,
 			 mdelay(1);
 
 		rxcount = in_be32(&fifo->rxcnt);
-		if (rxcount != count)
+		if (rxcount != count && t->len != 1)
 			printk(KERN_WARNING "expected %d bytes in rx fifo "
 				"but got %d\n", count, rxcount);
 
-- 
1.6.3.1

