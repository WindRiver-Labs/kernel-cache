From c0c48841c51c8262afec9ba5ee3b438ff5facc35 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:09 +0800
Subject: [PATCH] Add USB EHCI host support

USB host controllers implement their registers
in big endian.

In the meantime, DMA data structures (descriptors)
are also in big endian.

Refer to:
arch/powerpc/platforms/512x/mpc5121_usb.c
drivers/usb/host/ehci.h

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/Kconfig       |    1 +
 arch/powerpc/platforms/512x/Makefile      |    2 +-
 arch/powerpc/platforms/512x/mpc5121_usb.c |  107 ++++++++++++
 arch/powerpc/sysdev/fsl_soc.c             |   26 +++-
 arch/powerpc/sysdev/fsl_soc.h             |    8 +
 drivers/usb/host/Kconfig                  |    5 +-
 drivers/usb/host/ehci-fsl.c               |  251 ++++++++++++++++++++++++++++-
 drivers/usb/host/ehci-fsl.h               |    4 +
 drivers/usb/host/ehci-hcd.c               |    5 +-
 drivers/usb/host/ehci-hub.c               |   31 ++++
 drivers/usb/host/ehci-mem.c               |    5 +
 include/linux/fsl_devices.h               |   14 ++
 12 files changed, 445 insertions(+), 14 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/mpc5121_usb.c

diff --git a/arch/powerpc/platforms/512x/Kconfig b/arch/powerpc/platforms/512x/Kconfig
index e44c439..171bee9 100644
--- a/arch/powerpc/platforms/512x/Kconfig
+++ b/arch/powerpc/platforms/512x/Kconfig
@@ -10,6 +10,7 @@ config PPC_MPC5121
 	select PPC_INDIRECT_PCI
 	select PPC_PCI_CHOICE
 	select FSL_PCI if PCI
+	select USB_ARCH_HAS_EHCI
 
 config MPC5121_ADS
 	bool "Freescale MPC5121E ADS"
diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index f481716..3802fce 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -2,7 +2,7 @@
 # Makefile for the Freescale PowerPC 512x linux kernel.
 #
 obj-y				+= clock.o mpc512x_shared.o mpc5121_pscgpio.o \
-				   mpc5121_diu.o
+				   mpc5121_diu.o mpc5121_usb.o
 obj-$(CONFIG_MPC5121_ADS)	+= mpc5121_ads.o mpc5121_ads_cpld.o
 obj-$(CONFIG_MPC5121_GENERIC)	+= mpc5121_generic.o
 obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
diff --git a/arch/powerpc/platforms/512x/mpc5121_usb.c b/arch/powerpc/platforms/512x/mpc5121_usb.c
new file mode 100644
index 0000000..21c26fc
--- /dev/null
+++ b/arch/powerpc/platforms/512x/mpc5121_usb.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2007,2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Duck, <duck@freescale.com>, Tue Oct 2 2007
+ *
+ * Description:
+ * MPC5121 USB platform-specific routines
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fsl_devices.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/stddef.h>
+
+#define USBGENCTRL		0x200	/* NOTE: big endian */
+#define GC_WU_INT_CLR		(1 << 5)	/* Wakeup int clear */
+#define GC_ULPI_SEL		(1 << 4)	/* ULPI i/f select (usb0 only)*/
+#define GC_PPP			(1 << 3)	/* Port Power Polarity */
+#define GC_PFP			(1 << 2)	/* Power Fault Polarity */
+#define GC_WU_ULPI_EN		(1 << 1)	/* Wakeup on ULPI event */
+#define GC_WU_IE		(1 << 1)	/* Wakeup interrupt enable */
+
+#define ISIPHYCTRL		0x204	/* NOTE: big endian */
+#define PHYCTRL_PHYE		(1 << 4)	/* On-chip UTMI PHY enable */
+#define PHYCTRL_BSENH		(1 << 3)	/* Bit Stuff Enable High */
+#define PHYCTRL_BSEN		(1 << 2)	/* Bit Stuff Enable */
+#define PHYCTRL_LSFE		(1 << 1)	/* Line State Filter Enable */
+#define PHYCTRL_PXE		(1 << 0)	/* PHY oscillator enable */
+
+
+int usb_platform_mph_init(struct platform_device *pdev)
+{
+	return -ENODEV;		/* no MPH port on 5121 */
+}
+EXPORT_SYMBOL_GPL(usb_platform_mph_init);
+
+
+void usb_platform_mph_uninit(struct fsl_usb2_platform_data *pdata)
+{
+}
+EXPORT_SYMBOL_GPL(usb_platform_mph_uninit);
+
+static struct clk *dr_clk;
+static int dr_used;
+
+int usb_platform_dr_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	pr_debug("%s:  pdata %p\n\n", __func__, pdata);
+
+	/* enable the clock if we haven't already */
+	if (!dr_used) {
+		dr_clk = clk_get(&pdev->dev, "usb2_clk");
+		if (IS_ERR(dr_clk)) {
+			dev_err(&pdev->dev, "usb: clk_get failed\n");
+			return -ENODEV;
+		}
+		clk_enable(dr_clk);
+	}
+	dr_used++;
+
+	pdata->big_endian_desc = 1;
+	pdata->big_endian_mmio = 1;
+	pdata->le_setup_buf = 1;
+	pdata->es = 1;
+
+	if (pdata->phy_mode == FSL_USB2_PHY_UTMI_WIDE) {
+		void __iomem *base = pdata->regs;
+
+		out_be32(base + ISIPHYCTRL, PHYCTRL_PHYE | PHYCTRL_PXE);
+		out_be32(base + USBGENCTRL, GC_PPP | GC_PFP);
+	}
+	pr_debug("%s: success\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_platform_dr_init);
+
+void usb_platform_dr_uninit(struct fsl_usb2_platform_data *pdata)
+{
+	pr_debug("%s\n", __func__);
+
+	pdata->regs = NULL;
+	pdata->r_start = pdata->r_len = 0;
+
+	dr_used--;
+	if (!dr_used) {
+		clk_disable(dr_clk);
+		clk_put(dr_clk);
+		dr_clk = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(usb_platform_dr_uninit);
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 214388e..eda7662 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -43,6 +43,7 @@
 extern void init_fcc_ioports(struct fs_platform_info*);
 extern void init_fec_ioports(struct fs_platform_info*);
 extern void init_smc_ioports(struct fs_uart_platform_info*);
+
 static phys_addr_t immrbase = -1;
 
 phys_addr_t get_immrbase(void)
@@ -480,7 +481,7 @@ static int __init fsl_usb_of_init(void)
 	struct device_node *np;
 	unsigned int i = 0;
 	struct platform_device *usb_dev_mph = NULL, *usb_dev_dr_host = NULL,
-		*usb_dev_dr_client = NULL;
+		*usb_dev_dr_client = NULL, *usb_dev_dr_otg = NULL;
 	int ret;
 
 	for_each_compatible_node(np, NULL, "fsl-usb2-mph") {
@@ -563,6 +564,12 @@ static int __init fsl_usb_of_init(void)
 			}
 		} else if (prop && !strcmp(prop, "otg")) {
 			usb_data.operating_mode = FSL_USB2_DR_OTG;
+			usb_dev_dr_otg = platform_device_register_simple(
+					"fsl-usb2-otg", i, r, 2);
+			if (IS_ERR(usb_dev_dr_otg)) {
+				ret = PTR_ERR(usb_dev_dr_otg);
+				goto err;
+			}
 			usb_dev_dr_host = platform_device_register_simple(
 					"fsl-ehci", i, r, 2);
 			if (IS_ERR(usb_dev_dr_host)) {
@@ -582,7 +589,20 @@ static int __init fsl_usb_of_init(void)
 
 		prop = of_get_property(np, "phy_type", NULL);
 		usb_data.phy_mode = determine_usb_phy(prop);
-
+#ifdef CONFIG_PPC_MPC512x
+		usb_data.platform_init = usb_platform_dr_init;
+		usb_data.platform_uninit = usb_platform_dr_uninit;
+#endif
+		if (usb_dev_dr_otg) {
+			usb_dev_dr_otg->dev.coherent_dma_mask = 0xffffffffUL;
+			usb_dev_dr_otg->dev.dma_mask = &usb_dev_dr_otg->
+				dev.coherent_dma_mask;
+			ret = platform_device_add_data(usb_dev_dr_otg,
+						&usb_data, sizeof(struct
+						fsl_usb2_platform_data));
+			if (ret)
+				goto unreg_dr;
+		}
 		if (usb_dev_dr_host) {
 			usb_dev_dr_host->dev.coherent_dma_mask = 0xffffffffUL;
 			usb_dev_dr_host->dev.dma_mask = &usb_dev_dr_host->
@@ -610,6 +630,8 @@ unreg_dr:
 		platform_device_unregister(usb_dev_dr_host);
 	if (usb_dev_dr_client)
 		platform_device_unregister(usb_dev_dr_client);
+	if (usb_dev_dr_otg)
+		platform_device_unregister(usb_dev_dr_otg);
 unreg_mph:
 	if (usb_dev_mph)
 		platform_device_unregister(usb_dev_mph);
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index 0242998..83a0f06 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -41,5 +41,13 @@ extern struct platform_diu_data_ops diu_ops;
 int __init preallocate_diu_videomemory(void);
 #endif
 
+#ifdef CONFIG_PPC_MPC512x
+#include <linux/fsl_devices.h>
+extern int usb_platform_dr_init(struct platform_device *);
+extern void usb_platform_dr_uninit(struct fsl_usb2_platform_data *);
+extern int usb_platform_mph_init(struct platform_device *);
+extern void usb_platform_mph_uninit(struct fsl_usb2_platform_data *);
+#endif
+
 #endif
 #endif
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 9807d13..1890b1d 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -92,12 +92,13 @@ config USB_EHCI_TT_NEWSCHED
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (PPC_CELLEB || PPC_PS3 || 440EPX || ARCH_IXP4XX \
+		|| PPC_MPC512x)
 	default y
 
 config USB_EHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
+	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX || PPC_MPC512x)
 	default y
 
 config USB_EHCI_FSL
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 01c3da3..e56bc46 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -21,12 +21,71 @@
 
 #include <linux/platform_device.h>
 #include <linux/fsl_devices.h>
+#include <linux/usb/otg.h>
 
 #include "ehci-fsl.h"
 
+#ifndef CONFIG_PPC_MPC512x
 /* FIXME: Power Management is un-ported so temporarily disable it */
 #undef CONFIG_PM
+#endif
+
+#ifdef EHCI_PROC_PTC		/* /proc PORTSC:PTC support */
+#include <asm/uaccess.h>
+#define EFPSL 3			/* ehci fsl proc string length */
+
+static int ehci_fsl_proc_read(char *page, char **start, off_t off, int count,
+			      int *eof, void *data)
+{
+	return 0;
+}
+
+static int ehci_fsl_proc_write(struct file *file, const char __user *buffer,
+			       unsigned long count, void *data)
+{
+	int ptc;
+	u32 portsc;
+	struct ehci_hcd *ehci = (struct ehci_hcd *) data;
+	char str[EFPSL] = {0};
+
+	if (count > EFPSL-1)
+		return -EINVAL;
+
+	if (copy_from_user(str, buffer, count))
+		return -EFAULT;
+
+	str[count] = '\0';
+
+	ptc = simple_strtoul(str, NULL, 0);
 
+	portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	portsc &= ~(0xf << 16);
+	portsc |= (ptc << 16);
+	printk(KERN_INFO "PTC %x  portsc %08x\n", ptc, portsc);
+
+	ehci_writel(ehci, portsc, &ehci->regs->port_status[0]);
+
+	return count;
+}
+
+static int ehci_testmode_init(struct ehci_hcd *ehci)
+{
+	struct proc_dir_entry *entry;
+
+	entry = create_proc_read_entry("driver/ehci-ptc", 0644, NULL,
+				       ehci_fsl_proc_read, ehci);
+	if (!entry)
+		return -ENODEV;
+
+	entry->write_proc = ehci_fsl_proc_write;
+	return 0;
+}
+#else
+static int ehci_testmode_init(struct ehci_hcd *ehci)
+{
+	return 0;
+}
+#endif	/* /proc PORTSC:PTC support */
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -111,28 +170,56 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		retval = -EFAULT;
 		goto err3;
 	}
+#ifdef CONFIG_PPC_MPC512x
+	pdata->regs = hcd->regs;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	if (pdata->platform_init && pdata->platform_init(pdev)) {
+		retval = -ENODEV;
+		goto err3;
+	}
 
+	if (pdata->have_sysif_regs) {
+#endif
 	/* Enable USB controller */
 	temp = in_be32(hcd->regs + 0x500);
 	out_be32(hcd->regs + 0x500, temp | 0x4);
 
+#ifdef CONFIG_PPC_MPC512x
+	}
+	/* Set to Host mode */
+	temp = in_le32(hcd->regs + FSL_SOC_USB_USBMODE);
+	temp |= USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
+	out_le32(hcd->regs + FSL_SOC_USB_USBMODE, temp);
+#else
 	/* Set to Host mode */
 	temp = in_le32(hcd->regs + 0x1a8);
 	out_le32(hcd->regs + 0x1a8, temp | 0x3);
+#endif
 
 	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
+
+	ehci_testmode_init(hcd_to_ehci(hcd));
+
 	return retval;
 
       err4:
 	iounmap(hcd->regs);
       err3:
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	if (pdata->operating_mode != FSL_USB2_DR_OTG)
+		release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
       err2:
 	usb_put_hcd(hcd);
       err1:
 	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev), retval);
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+#endif
 	return retval;
 }
 
@@ -149,10 +236,22 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
  */
 void usb_hcd_fsl_remove(struct usb_hcd *hcd, struct platform_device *pdev)
 {
-	usb_remove_hcd(hcd);
-	iounmap(hcd->regs);
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
 	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
+
+#ifdef CONFIG_PPC_MPC512x
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+#endif
+	iounmap(hcd->regs);
+
 }
 
 static void mpc83xx_setup_phy(struct ehci_hcd *ehci,
@@ -190,9 +289,16 @@ static void mpc83xx_usb_setup(struct usb_hcd *hcd)
 	    (struct fsl_usb2_platform_data *)hcd->self.controller->
 	    platform_data;
 	/* Enable PHY interface in the control reg. */
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->have_sysif_regs) {
+		out_be32(non_ehci + FSL_SOC_USB_CTRL, 0x00000004);
+		out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0000001b);
+	}
+#else
 	temp = in_be32(non_ehci + FSL_SOC_USB_CTRL);
 	out_be32(non_ehci + FSL_SOC_USB_CTRL, temp | 0x00000004);
 	out_be32(non_ehci + FSL_SOC_USB_SNOOP1, 0x0000001b);
+#endif
 
 #if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
 	/*
@@ -228,8 +334,15 @@ static void mpc83xx_usb_setup(struct usb_hcd *hcd)
 			mpc83xx_setup_phy(ehci, pdata->phy_mode, 1);
 	}
 
+	temp = 0x00000003;
+#ifdef CONFIG_PPC_MPC512x
+	temp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
+#endif
 	/* put controller in host mode. */
-	ehci_writel(ehci, 0x00000003, non_ehci + FSL_SOC_USB_USBMODE);
+	ehci_writel(ehci, temp, non_ehci + FSL_SOC_USB_USBMODE);
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->have_sysif_regs) {
+#endif
 #ifdef CONFIG_PPC_85xx
 	out_be32(non_ehci + FSL_SOC_USB_PRICTRL, 0x00000008);
 	out_be32(non_ehci + FSL_SOC_USB_AGECNTTHRSH, 0x00000080);
@@ -238,6 +351,9 @@ static void mpc83xx_usb_setup(struct usb_hcd *hcd)
 	out_be32(non_ehci + FSL_SOC_USB_AGECNTTHRSH, 0x00000040);
 #endif
 	out_be32(non_ehci + FSL_SOC_USB_SICTRL, 0x00000001);
+#ifdef CONFIG_PPC_MPC512x
+	}
+#endif
 }
 
 /* called after powerup, by probe or system-pm "wakeup" */
@@ -254,7 +370,13 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	int retval;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata;
+	pdata = hcd->self.controller->platform_data;
 
+	ehci->big_endian_desc = pdata->big_endian_desc;
+	ehci->big_endian_mmio = pdata->big_endian_mmio;
+#endif
 	/* EHCI registers start at offset 0x100 */
 	ehci->caps = hcd->regs + 0x100;
 	ehci->regs = hcd->regs + 0x100 +
@@ -265,9 +387,7 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 	/* cache this readonly data; minimize chip reads */
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
-	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
+	ehci_halt(ehci);
 
 	/* data structure init */
 	retval = ehci_init(hcd);
@@ -293,8 +413,11 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	 * generic hardware linkage
 	 */
 	.irq = ehci_irq,
+#ifdef CONFIG_PPC_MPC512x
+	.flags = HCD_USB2 | HCD_MEMORY,
+#else
 	.flags = HCD_USB2,
-
+#endif
 	/*
 	 * basic lifecycle operations
 	 */
@@ -324,6 +447,9 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
 	.port_handed_over = ehci_port_handed_over,
+#ifdef CONFIG_PPC_MPC512x
+	.start_port_reset = ehci_start_port_reset,
+#endif
 };
 
 static int ehci_fsl_drv_probe(struct platform_device *pdev)
@@ -344,12 +470,121 @@ static int ehci_fsl_drv_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+/*
+ * Holding pen for all the EHCI registers except port_status,
+ * which is a zero element array and hence takes no space.
+ * The port_status register is saved in usb_ehci_portsc.
+ */
+volatile static struct ehci_regs usb_ehci_regs;
+static u32 usb_ehci_portsc;
+
+/* suspend/resume, section 4.3 */
+
+/* These routines rely on the bus (pci, platform, etc)
+ * to handle powerdown and wakeup, and currently also on
+ * transceivers that don't need any software attention to set up
+ * the right sort of wakeup.
+ *
+ * They're also used for turning on/off the port when doing OTG.
+ */
+static int ehci_fsl_drv_suspend(struct platform_device *pdev,
+				pm_message_t message)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+
+	/* DDD printk("%s()\n", __func__); */
+	printk(KERN_INFO "USB Host suspended\n");
+
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+	if (hcd->driver->suspend)
+		return hcd->driver->suspend(hcd, message);
+
+	/* ignore non-host interrupts */
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+
+	/* stop the controller */
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp &= ~CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	/* save EHCI registers */
+	usb_ehci_regs.command = ehci_readl(ehci, &ehci->regs->command);
+	usb_ehci_regs.command &= ~CMD_RUN;
+	usb_ehci_regs.status  = ehci_readl(ehci, &ehci->regs->status);
+	usb_ehci_regs.intr_enable  = ehci_readl(ehci, &ehci->regs->intr_enable);
+	usb_ehci_regs.frame_index  = ehci_readl(ehci, &ehci->regs->frame_index);
+	usb_ehci_regs.segment  = ehci_readl(ehci, &ehci->regs->segment);
+	usb_ehci_regs.frame_list  = ehci_readl(ehci, &ehci->regs->frame_list);
+	usb_ehci_regs.async_next  = ehci_readl(ehci, &ehci->regs->async_next);
+	usb_ehci_regs.configured_flag  = ehci_readl(ehci, \
+					&ehci->regs->configured_flag);
+	usb_ehci_portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);
+
+	/* clear the W1C bits */
+	usb_ehci_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);
+
+	/* clear PP to cut power to the port */
+	tmp = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	tmp &= ~PORT_POWER;
+	ehci_writel(ehci, tmp, &ehci->regs->port_status[0]);
+
+	return 0;
+}
+
+static int ehci_fsl_drv_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 tmp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+
+	printk(KERN_INFO "USB Host resumed\n");
+
+	/* set host mode */
+	tmp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
+	ehci_writel(ehci, tmp, hcd->regs + FSL_SOC_USB_USBMODE);
+
+	/* restore EHCI registers */
+	ehci_writel(ehci, usb_ehci_regs.command, &ehci->regs->command);
+	ehci_writel(ehci, usb_ehci_regs.status, &ehci->regs->status);
+	ehci_writel(ehci, usb_ehci_regs.intr_enable, &ehci->regs->intr_enable);
+	ehci_writel(ehci, usb_ehci_regs.frame_index, &ehci->regs->frame_index);
+	ehci_writel(ehci, usb_ehci_regs.segment, &ehci->regs->segment);
+	ehci_writel(ehci, usb_ehci_regs.frame_list, &ehci->regs->frame_list);
+	ehci_writel(ehci, usb_ehci_regs.async_next, &ehci->regs->async_next);
+	ehci_writel(ehci, usb_ehci_regs.configured_flag, \
+				&ehci->regs->configured_flag);
+	ehci_writel(ehci, usb_ehci_portsc, &ehci->regs->port_status[0]);
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
+	hcd->state = HC_STATE_RUNNING;
+	pdev->dev.power.power_state = PMSG_ON;
+
+	tmp = ehci_readl(ehci, &ehci->regs->command);
+	tmp |= CMD_RUN;
+	ehci_writel(ehci, tmp, &ehci->regs->command);
+
+	usb_hcd_resume_root_hub(hcd);
+
+	return 0;
+}
+#endif				/* CONFIG_USB_OTG */
+
 MODULE_ALIAS("platform:fsl-ehci");
 
 static struct platform_driver ehci_fsl_driver = {
 	.probe = ehci_fsl_drv_probe,
 	.remove = ehci_fsl_drv_remove,
 	.shutdown = usb_hcd_platform_shutdown,
+#ifdef CONFIG_PM
+	.suspend = ehci_fsl_drv_suspend,
+	.resume = ehci_fsl_drv_resume,
+#endif
 	.driver = {
 		   .name = "fsl-ehci",
 	},
diff --git a/drivers/usb/host/ehci-fsl.h b/drivers/usb/host/ehci-fsl.h
index b5e59db..7bee0af 100644
--- a/drivers/usb/host/ehci-fsl.h
+++ b/drivers/usb/host/ehci-fsl.h
@@ -19,6 +19,7 @@
 #define _EHCI_FSL_H
 
 /* offsets for the non-ehci registers in the FSL SOC USB controller */
+#define FSL_SOC_USB_BURSTSIZE	0x160
 #define FSL_SOC_USB_ULPIVP	0x170
 #define FSL_SOC_USB_PORTSC1	0x184
 #define PORT_PTS_MSK		(3<<30)
@@ -26,8 +27,11 @@
 #define PORT_PTS_ULPI		(2<<30)
 #define	PORT_PTS_SERIAL		(3<<30)
 #define PORT_PTS_PTW		(1<<28)
+#define PORT_PTS_PHCD		(1<<23)
 #define FSL_SOC_USB_PORTSC2	0x188
 #define FSL_SOC_USB_USBMODE	0x1a8
+#define USBMODE_CM_HOST		(3 << 0)	/* controller mode: host */
+#define USBMODE_ES		(1 << 2)	/* (Big) Endian Select */
 #define FSL_SOC_USB_SNOOP1	0x400	/* NOTE: big-endian */
 #define FSL_SOC_USB_SNOOP2	0x404	/* NOTE: big-endian */
 #define FSL_SOC_USB_AGECNTTHRSH	0x408	/* NOTE: big-endian */
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 0740359..3284e51 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -194,6 +194,9 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	 */
 	if (ehci_big_endian_mmio(ehci))
 		tmp |= USBMODE_BE;
+#ifdef CONFIG_PPC_MPC512x              /* must set USBMODE:ES for 5121 */
+	tmp |= USBMODE_BE;
+#endif
 	ehci_writel(ehci, tmp, reg_ptr);
 }
 
@@ -1074,7 +1077,7 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-	retval = platform_driver_register(&PLATFORM_DRIVER);
+	retval = platform_driver_probe(&PLATFORM_DRIVER, PLATFORM_DRIVER.probe);
 	if (retval < 0)
 		goto clean0;
 #endif
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 740835b..7cafb73 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -533,6 +533,37 @@ ehci_hub_descriptor (
 	desc->wHubCharacteristics = cpu_to_le16(temp);
 }
 
+#ifdef CONFIG_USB_OTG
+static int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 status;
+
+	if (!port)
+		return -EINVAL;
+	port--;
+
+	/* start port reset before HNP protocol time out */
+	status = readl(&ehci->regs->port_status[port]);
+	if (!(status & PORT_CONNECT))
+		return -ENODEV;
+
+	/* khubd will finish the reset later */
+	if (ehci_is_TDI(ehci))
+		writel(PORT_RESET | (status & ~(PORT_CSC | PORT_PEC
+				| PORT_OCC)), &ehci->regs->port_status[port]);
+	else
+		writel(PORT_RESET, &ehci->regs->port_status[port]);
+
+	return 0;
+}
+#else
+static int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)
+{
+	return 0;
+}
+#endif /* CONFIG_USB_OTG */
+
 /*-------------------------------------------------------------------------*/
 
 static int ehci_hub_control (
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 0431397..03ce06d 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -40,7 +40,12 @@ static inline void ehci_qtd_init(struct ehci_hcd *ehci, struct ehci_qtd *qtd,
 {
 	memset (qtd, 0, sizeof *qtd);
 	qtd->qtd_dma = dma;
+#ifdef CONFIG_PPC_MPC512x
+	/* DDD official patch: qtd->hw_token = cpu_to_le32 (QTD_STS_HALT); */
+	qtd->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);
+#else
 	qtd->hw_token = cpu_to_le32 (QTD_STS_HALT);
+#endif
 	qtd->hw_next = EHCI_LIST_END(ehci);
 	qtd->hw_alt_next = EHCI_LIST_END(ehci);
 	INIT_LIST_HEAD (&qtd->qtd_list);
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 4e625e0..87b1094 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -19,6 +19,7 @@
 
 #include <linux/types.h>
 #include <linux/phy.h>
+#include <linux/platform_device.h>
 
 /*
  * Some conventions on how we handle peripherals on Freescale chips
@@ -104,6 +105,19 @@ struct fsl_usb2_platform_data {
 	enum fsl_usb2_operating_modes	operating_mode;
 	enum fsl_usb2_phy_modes		phy_mode;
 	unsigned int			port_enables;
+
+#ifdef	CONFIG_PPC_MPC512x
+	int (*platform_init) (struct platform_device *);
+	void (*platform_uninit) (struct fsl_usb2_platform_data *);
+	u32				r_start; /* start of MEM resource */
+	u32				r_len;	/* length of MEM resource */
+	void __iomem			*regs;	/* ioremap'd register base */
+	unsigned			big_endian_mmio:1;
+	unsigned			big_endian_desc:1;
+	unsigned			es:1;	/* need USBMODE:ES */
+	unsigned			have_sysif_regs:1;
+	unsigned			le_setup_buf:1;
+#endif
 };
 
 /* Flags in fsl_usb2_mph_platform_data */
-- 
1.6.0.90.g436ed

