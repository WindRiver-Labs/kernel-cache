From 30bd04980feba5aaac8f155ed83c40367ac4290b Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 18 Jun 2009 15:33:49 +0800
Subject: [PATCH 08/25] MPC5121: fs_enet PM suspend/resume fix

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

Fix two problems:
    First, suspend/resume methods for the of_platform
    case (CONFIG_PPC_CPM_NEW_BINDING) were missing.

    This patch adds these routines.

    Second, the mii bus needs to be reinitialized on resume.

    This patch fleshes out the previously stubbed
    fs_enet_fec_mii_reset function in mii-fec.c and calls
    it from restart in mac-fec.c.  Also call it in
    fs_enet_fec_mii_read and ..._write in the case
    where MII_MODE has gone to 0.  That is the case where
    we are coming back up after hibernate.

This patch along with the previous labeled
MPC5121 FEC fix fec DMA_CONTROL field offset fix the FEC
hibernate problem.

Signed-off-by: John Rigby <jrigby@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/fs_enet/mac-fec.c |    5 +++++
 drivers/net/fs_enet/mii-fec.c |   20 ++++++++++++--------
 2 files changed, 17 insertions(+), 8 deletions(-)

diff --git a/drivers/net/fs_enet/mac-fec.c b/drivers/net/fs_enet/mac-fec.c
index 213247e..b0bbffb 100644
--- a/drivers/net/fs_enet/mac-fec.c
+++ b/drivers/net/fs_enet/mac-fec.c
@@ -267,6 +267,11 @@ static void restart(struct net_device *dev)
 		printk(KERN_ERR DRV_MODULE_NAME
 				": %s FEC Reset FAILED!\n", dev->name);
 	/*
+	 * Reset the mii bus
+	 */
+	mii->reset(mii);
+
+	/*
 	 * Set station address.
 	 */
 	addrhi = ((u32) dev->dev_addr[0] << 24) |
diff --git a/drivers/net/fs_enet/mii-fec.c b/drivers/net/fs_enet/mii-fec.c
index 75bccbf..86e2f89 100644
--- a/drivers/net/fs_enet/mii-fec.c
+++ b/drivers/net/fs_enet/mii-fec.c
@@ -48,6 +48,16 @@
 
 #define FEC_MII_LOOPS	10000
 
+static int fs_enet_fec_mii_reset(struct mii_bus *bus)
+{
+	struct fec_info *fec = bus->priv;
+
+	setbits32(&fec->fecp->fec_r_cntrl, FEC_RCNTRL_MII_MODE);
+	out_be32(&fec->fecp->fec_ievent, FEC_ENET_MII);
+	out_be32(&fec->fecp->fec_mii_speed, fec->mii_speed);
+	return 0;
+}
+
 static int fs_enet_fec_mii_read(struct mii_bus *bus , int phy_id, int location)
 {
 	struct fec_info* fec = bus->priv;
@@ -55,7 +65,7 @@ static int fs_enet_fec_mii_read(struct mii_bus *bus , int phy_id, int location)
 	int i, ret = -1;
 
 	if ((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0)
-		BUG();
+		fs_enet_fec_mii_reset(bus);
 
 	/* Add PHY address to register command.  */
 	out_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_read(location));
@@ -80,7 +90,7 @@ static int fs_enet_fec_mii_write(struct mii_bus *bus, int phy_id, int location,
 
 	/* this must never happen */
 	if ((in_be32(&fecp->fec_r_cntrl) & FEC_RCNTRL_MII_MODE) == 0)
-		BUG();
+		fs_enet_fec_mii_reset(bus);
 
 	/* Add PHY address to register command.  */
 	out_be32(&fecp->fec_mii_data, (phy_id << 23) | mk_mii_write(location, val));
@@ -96,12 +106,6 @@ static int fs_enet_fec_mii_write(struct mii_bus *bus, int phy_id, int location,
 
 }
 
-static int fs_enet_fec_mii_reset(struct mii_bus *bus)
-{
-	/* nothing here - for now */
-	return 0;
-}
-
 static void __devinit add_phy(struct mii_bus *bus, struct device_node *np)
 {
 	const u32 *data;
-- 
1.6.3.1

