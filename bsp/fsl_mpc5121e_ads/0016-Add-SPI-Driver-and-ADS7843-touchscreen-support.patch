From 48c38a5435c11350548611eddf65af3474fb2833 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:03 +0800
Subject: [PATCH] Add SPI Driver and ADS7843 touchscreen support

This patch will mainly do:

1. Add SPI driver.
2. Add support for the generic linux 7846 touchscreen driver
necessary for the MPC5121eADS platform.
3. Add two new command register bit definitions:
    MPC512x_PSC_FIFO_EOF
    MPC512x_PSC_FIFO_ENABLE_AXE

In the meanwhile, in device tree, need to uncomment
corresponding nodes to use it.

Spidev node in spi node is a dummy entry for testing
spidev user land api, ts node is an entry for 784x
touch screen controller, can uncomment one of them to
use SPI.

To test SPI you need a Media5200 LCD display unit to use as
a touch screen. Connect the multicolored ribbon cable that
comes with the Media5200 display unit from connector H12
on the display to P6 on the ADS512101.

Also need a cable to connect a second serial port to the
ADS512101. This cable needs to connect to P8 and have a DB9
on the other end. U-boot messages will come out on the first
serial port. Linux messages will come out on the the second.
Need a serial communication program that will let
you switch between two different port.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/include/asm/mpc52xx_psc.h         |   11 +-
 arch/powerpc/platforms/512x/Makefile           |    1 +
 arch/powerpc/platforms/512x/mpc5121_ads_cpld.c |    7 +-
 arch/powerpc/platforms/512x/mpc5121_spi.c      |  188 ++++++++
 arch/powerpc/platforms/512x/mpc512x.h          |    1 +
 drivers/spi/Kconfig                            |    7 +
 drivers/spi/Makefile                           |    1 +
 drivers/spi/mpc512x_psc_spi.c                  |  593 ++++++++++++++++++++++++
 8 files changed, 805 insertions(+), 4 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/mpc5121_spi.c
 create mode 100644 drivers/spi/mpc512x_psc_spi.c

diff --git a/arch/powerpc/include/asm/mpc52xx_psc.h b/arch/powerpc/include/asm/mpc52xx_psc.h
index 8917ed6..d05389f 100644
--- a/arch/powerpc/include/asm/mpc52xx_psc.h
+++ b/arch/powerpc/include/asm/mpc52xx_psc.h
@@ -224,9 +224,11 @@ struct mpc52xx_psc_fifo {
 	u16		tflwfptr;	/* PSC + 0x9e */
 };
 
-#define MPC512x_PSC_FIFO_RESET_SLICE	0x80
-#define MPC512x_PSC_FIFO_ENABLE_SLICE	0x01
-#define MPC512x_PSC_FIFO_ENABLE_DMA	0x04
+#define MPC512x_PSC_FIFO_EOF		0x100
+#define MPC512x_PSC_FIFO_RESET_SLICE	0x080
+#define MPC512x_PSC_FIFO_ENABLE_AXE	0x008
+#define MPC512x_PSC_FIFO_ENABLE_DMA	0x004
+#define MPC512x_PSC_FIFO_ENABLE_SLICE	0x001
 
 #define MPC512x_PSC_FIFO_EMPTY		0x1
 #define MPC512x_PSC_FIFO_FULL		0x2
@@ -273,4 +275,7 @@ struct mpc512x_psc_fifo {
 #define rxdata_32 rxdata.rxdata_32
 };
 
+/* extract and scale size field in txsz or rxsz */
+#define MPC512x_PSC_FIFO_SZ(sz)	((sz & 0x7ff) << 2)
+
 #endif  /* __ASM_MPC52xx_PSC_H__ */
diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index 1062e08..63e7ecb 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -5,3 +5,4 @@ obj-y				+= clock.o mpc512x_shared.o mpc5121_pscgpio.o
 obj-$(CONFIG_MPC5121_ADS)	+= mpc5121_ads.o mpc5121_ads_cpld.o
 obj-$(CONFIG_MPC5121_GENERIC)	+= mpc5121_generic.o
 obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
+obj-$(CONFIG_SPI)		+= mpc5121_spi.o
diff --git a/arch/powerpc/platforms/512x/mpc5121_ads_cpld.c b/arch/powerpc/platforms/512x/mpc5121_ads_cpld.c
index 8103827..6531820 100644
--- a/arch/powerpc/platforms/512x/mpc5121_ads_cpld.c
+++ b/arch/powerpc/platforms/512x/mpc5121_ads_cpld.c
@@ -235,8 +235,13 @@ void mpc5121ads_psc_disable_unused_serial(void)
 					mpc5121_ads_cpld_uart_foff(0);
 				else if (*cell_index == 4)
 					mpc5121_ads_cpld_uart_foff(1);
-
 			}
 		}
 	}
 }
+
+/* return 1 if pen is down */
+int mpc5121ads_get_pendown_state(void)
+{
+	return (cpld_regs->misc_status & 0x10) == 0;
+}
diff --git a/arch/powerpc/platforms/512x/mpc5121_spi.c b/arch/powerpc/platforms/512x/mpc5121_spi.c
new file mode 100644
index 0000000..eaee4ce
--- /dev/null
+++ b/arch/powerpc/platforms/512x/mpc5121_spi.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: John Rigby, <jrigby@freescale.com>, May 2008
+ *
+ * Description:
+ * MPC5121 spi setup
+ *
+ * This is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/of_platform.h>
+#include <linux/spi/spi.h>
+#include <linux/fsl_devices.h>
+
+#include <asm/io.h>
+
+#include "mpc512x.h"
+
+static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
+{
+	const u32 *prop;
+	int len;
+
+	prop = of_get_property(np, name, &len);
+	if (prop && len == 4)
+		return *prop;
+	return def;
+}
+
+#define GET_INT_PROP(pd, np, propname)	\
+	(pd->propname = get_int_prop(np, #propname, pd->propname))
+
+
+#if defined(CONFIG_TOUCHSCREEN_ADS7846) || \
+	defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
+#define CFG_ADS7846
+#include <linux/spi/ads7846.h>
+#endif
+
+#ifdef CFG_ADS7846
+
+static struct
+ads7846_platform_data mpc5121eads_ads7846_platform_data __initdata = {
+	.model			= 7843,
+	.vref_delay_usecs	= 100,
+	.x_plate_ohms		= 500,
+	.y_plate_ohms		= 500,
+	.get_pendown_state	= mpc5121ads_get_pendown_state,
+};
+
+static void __init *ads7846_get_pdata(struct device_node *np)
+{
+	struct ads7846_platform_data *pd = &mpc5121eads_ads7846_platform_data;
+	GET_INT_PROP(pd, np, model);
+	GET_INT_PROP(pd, np, vref_delay_usecs);
+	GET_INT_PROP(pd, np, x_plate_ohms);
+	GET_INT_PROP(pd, np, y_plate_ohms);
+
+	return pd;
+}
+#endif
+
+struct spi_driver_device {
+	char *of_device;
+	char *modalias;
+	int needirq;
+	void *(*get_platform_data)(struct device_node *);
+};
+
+static struct spi_driver_device spi_devices[] __initdata = {
+#ifdef CONFIG_SPI_SPIDEV
+	{
+		.of_device = "linux,spidev",
+		.modalias = "spidev",
+	},
+#endif
+#ifdef CFG_ADS7846
+	{
+		.of_device = "ti,ads7846",
+		.modalias = "ads7846",
+		.needirq = 1,
+		.get_platform_data = ads7846_get_pdata,
+	},
+#endif
+#ifdef CONFIG_SND_SOC_AD1939
+	{
+		.of_device = "ad,ad1938",
+		.modalias = "AD1939",
+	},
+	{
+		.of_device = "ad,ad1939",
+		.modalias = "AD1939",
+	},
+#endif
+};
+
+static int __init find_spi_driver(struct device_node *node,
+				     struct spi_board_info *info)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(spi_devices); i++) {
+		if (!of_device_is_compatible(node, spi_devices[i].of_device))
+			continue;
+		if (spi_devices[i].needirq && info->irq == NO_IRQ) {
+			printk(KERN_WARNING "mpc5121_spi.c %s needs valid irq\n",
+				spi_devices[i].modalias);
+			return -EINVAL;
+		}
+		if (strlcpy(info->modalias, spi_devices[i].modalias,
+			    sizeof(info->modalias)) >= sizeof(info->modalias))
+			return -ENOMEM;
+		if (spi_devices[i].get_platform_data)
+			info->platform_data = \
+			spi_devices[i].get_platform_data(node);
+		return 0;
+	}
+	return -ENODEV;
+}
+
+static int
+of_device_add_data(struct of_device *of_dev, const void *data, size_t size)
+{
+	void *d;
+
+	d = kmalloc(size, GFP_KERNEL);
+	if (d) {
+		memcpy(d, data, size);
+		of_dev->dev.platform_data = d;
+	}
+	return d ? 0 : -ENOMEM;
+}
+
+static void
+ __init register_spi_bus(struct device_node *spi_node, int bus_num)
+{
+	struct device_node *node = NULL;
+	struct of_device *of_dev;
+	struct fsl_spi_platform_data pdata = {
+		.bus_num = bus_num,
+		.max_chipselect = 255,
+	};
+
+	of_dev = of_find_device_by_node(spi_node);
+	if (of_dev)
+		of_device_add_data(of_dev, &pdata, sizeof(pdata));
+
+	while ((node = of_get_next_child(spi_node, node))) {
+		struct spi_board_info *bp, info = {};
+
+		bp = &info;
+
+		bp->bus_num = bus_num;
+		GET_INT_PROP(bp, node, chip_select);
+		GET_INT_PROP(bp, node, max_speed_hz);
+		info.irq = irq_of_parse_and_map(node, 0);
+
+		if (find_spi_driver(node, &info) < 0)
+			continue;
+
+		spi_register_board_info(&info, 1);
+	}
+}
+
+static int __init mpc5121_spi_init(void)
+{
+	struct device_node *np;
+	int bus_num;
+
+	for_each_compatible_node(np, NULL, "fsl,mpc5121-psc-spi") {
+		bus_num = get_int_prop(np, "cell-index", -1);
+		if (bus_num < 0 || bus_num > 11) {
+			printk(KERN_WARNING "mpc5121_spi.c no cell-index spi node, skipping\n");
+			continue;
+		}
+		register_spi_bus(np, bus_num);
+		of_node_put(np);
+	}
+
+	return 0;
+}
+
+arch_initcall(mpc5121_spi_init);
diff --git a/arch/powerpc/platforms/512x/mpc512x.h b/arch/powerpc/platforms/512x/mpc512x.h
index 3d2fe41..b0f1c20 100644
--- a/arch/powerpc/platforms/512x/mpc512x.h
+++ b/arch/powerpc/platforms/512x/mpc512x.h
@@ -20,5 +20,6 @@ extern void __init mpc5121_psc_iopad_init(void __iomem *ioctl);
 extern void __init mpc5121_can_iopad_init(void __iomem *ioctl);
 extern void __init mpc5121_psc_lowlevel_clock_init(void);
 extern void mpc5121ads_psc_disable_unused_serial(void);
+extern int mpc5121ads_get_pendown_state(void);
 
 #endif				/* __MPC512X_H__ */
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c04029a..6a23d16 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -123,6 +123,13 @@ config SPI_MPC52xx_PSC
 	  This enables using the Freescale MPC52xx Programmable Serial
 	  Controller in master SPI mode.
 
+config SPI_MPC512x_PSC
+	tristate "Freescale MPC512x PSC SPI controller"
+	depends on SPI_MASTER && PPC_MPC512x
+	help
+	  This enables using the Freescale MPC5121 Programmable Serial
+	  Controller in SPI mode.
+
 config SPI_MPC83xx
 	tristate "Freescale MPC83xx/QUICC Engine SPI controller"
 	depends on (PPC_83xx || QUICC_ENGINE) && EXPERIMENTAL
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 1c2e7fc..ff05d40 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_SPI_OMAP_UWIRE)		+= omap_uwire.o
 obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
+obj-$(CONFIG_SPI_MPC512x_PSC)		+= mpc512x_psc_spi.o
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
diff --git a/drivers/spi/mpc512x_psc_spi.c b/drivers/spi/mpc512x_psc_spi.c
new file mode 100644
index 0000000..2136c7f
--- /dev/null
+++ b/drivers/spi/mpc512x_psc_spi.c
@@ -0,0 +1,593 @@
+/*
+ * MPC512x SPC in SPI mode driver.
+ *
+ * Copyright (C) 2007,2008 Freescale Semiconductor Inc
+ * Original port from 52xx driver:
+ * 	Hongjun Chen <hong-jun.chen@freescale.com>
+ *
+ * Current maintainer:
+ * 	John Rigby <jrigby@freescale.com>
+ *
+ * Fork of mpc52xx_psc_spi.c:
+ *	Copyright (C) 2006 TOPTICA Photonics AG., Dragos Carp
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+
+#if defined(CONFIG_PPC_MERGE)
+#include <asm/of_platform.h>
+#else
+#include <linux/platform_device.h>
+#endif
+
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/fsl_devices.h>
+#include <asm/mpc52xx_psc.h>
+
+struct mpc512x_psc_spi {
+	/* fsl_spi_platform data */
+	void (*activate_cs) (u8, u8);
+	void (*deactivate_cs) (u8, u8);
+	u32 sysclk;
+
+	/* driver internal data */
+	struct mpc52xx_psc __iomem *psc;
+	struct mpc512x_psc_fifo __iomem *fifo;
+	unsigned int irq;
+	u8 bits_per_word;
+	u8 busy;
+	u32 mclk;
+	u8 eofbyte;
+
+	struct workqueue_struct *workqueue;
+	struct work_struct work;
+
+	struct list_head queue;
+	spinlock_t lock;	/* Message queue lock */
+
+	struct completion done;
+};
+
+/* controller state */
+struct mpc512x_psc_spi_cs {
+	int bits_per_word;
+	int speed_hz;
+};
+
+/* set clock freq, clock ramp, bits per work
+ * if t is NULL then reset the values to the default values
+ */
+static int mpc512x_psc_spi_transfer_setup(struct spi_device *spi,
+					  struct spi_transfer *t)
+{
+	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
+
+	cs->speed_hz = (t && t->speed_hz)
+	    ? t->speed_hz : spi->max_speed_hz;
+	cs->bits_per_word = (t && t->bits_per_word)
+	    ? t->bits_per_word : spi->bits_per_word;
+	cs->bits_per_word = ((cs->bits_per_word + 7) / 8) * 8;
+	return 0;
+}
+
+static void mpc512x_psc_spi_activate_cs(struct spi_device *spi)
+{
+	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
+	struct mpc52xx_psc __iomem *psc = mps->psc;
+	u32 sicr;
+	u32 ccr;
+	u16 bclkdiv;
+
+	sicr = in_be32(&psc->sicr);
+
+	/* Set clock phase and polarity */
+	if (spi->mode & SPI_CPHA)
+		sicr |= 0x00001000;
+	else
+		sicr &= ~0x00001000;
+	if (spi->mode & SPI_CPOL)
+		sicr |= 0x00002000;
+	else
+		sicr &= ~0x00002000;
+
+	if (spi->mode & SPI_LSB_FIRST)
+		sicr |= 0x10000000;
+	else
+		sicr &= ~0x10000000;
+	out_be32(&psc->sicr, sicr);
+
+	ccr = in_be32(&psc->ccr);
+	ccr &= 0xFF000000;
+	if (cs->speed_hz)
+		bclkdiv = (mps->mclk / cs->speed_hz) - 1;
+	else
+		bclkdiv = (mps->mclk / 1000000) - 1;
+
+	ccr |= (((bclkdiv & 0xff) << 16) | (((bclkdiv >> 8) & 0xff) << 8));
+	out_be32(&psc->ccr, ccr);
+	mps->bits_per_word = cs->bits_per_word;
+
+	if (mps->activate_cs)
+		mps->activate_cs(spi->chip_select,
+				 (spi->mode & SPI_CS_HIGH) ? 1 : 0);
+}
+
+static void mpc512x_psc_spi_deactivate_cs(struct spi_device *spi)
+{
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
+
+	if (mps->deactivate_cs)
+		mps->deactivate_cs(spi->chip_select,
+				   (spi->mode & SPI_CS_HIGH) ? 1 : 0);
+}
+
+/*
+ * Current MPC5121's have a bug in the SS logic that requires setting
+ * the EOF flag on the next to last byte instead of the last
+ */
+
+#define EOFBYTE 2
+
+static int mpc512x_psc_spi_transfer_rxtx(struct spi_device *spi,
+					 struct spi_transfer *t)
+{
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
+	struct mpc52xx_psc __iomem *psc = mps->psc;
+	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
+	size_t len = t->len;
+	u8 *tx_buf = (u8 *)t->tx_buf;
+	u8 *rx_buf = (u8 *)t->rx_buf;
+
+
+	if (!tx_buf && !rx_buf && t->len)
+		return -EINVAL;
+
+	while (len) {
+		int count;
+		int i;
+		u8 data;
+		size_t fifosz;
+		int rxcount;
+
+		/*
+		 * The number of bytes that can be sent at a time
+		 * depends on the fifo size.
+		 */
+		fifosz = MPC512x_PSC_FIFO_SZ(in_be32(&fifo->txsz));
+		count = min(fifosz, len);
+
+		for (i = count; i > 0; i--) {
+			data = tx_buf ? *tx_buf++ : 0;
+			if (len == EOFBYTE)
+				setbits32(&fifo->txcmd, MPC512x_PSC_FIFO_EOF);
+			out_8(&fifo->txdata_8, data);
+			len--;
+		}
+
+
+		INIT_COMPLETION(mps->done);
+
+		/* interrupt on tx fifo empty */
+		out_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);
+		out_be32(&fifo->tximr, MPC512x_PSC_FIFO_EMPTY);
+
+		/* enable transmiter/receiver */
+		out_8(&psc->command, MPC52xx_PSC_TX_ENABLE | \
+			MPC52xx_PSC_RX_ENABLE);
+
+		wait_for_completion(&mps->done);
+
+		mdelay(1);
+
+		/* rx fifo should have count bytes in it */
+		rxcount = in_be32(&fifo->rxcnt);
+		if (rxcount != count)
+			 mdelay(1);
+
+		rxcount = in_be32(&fifo->rxcnt);
+		if (rxcount != count)
+			printk(KERN_WARNING "expected %d bytes in rx fifo "
+				"but got %d\n", count, rxcount);
+
+		rxcount = min(rxcount, count);
+		{
+			for (i = rxcount; i > 0; i--) {
+				data = in_8(&fifo->rxdata_8);
+				if (rx_buf)
+					*rx_buf++ = data;
+			}
+			while (in_be32(&fifo->rxcnt))
+				(void)in_8(&fifo->rxdata_8);
+		}
+		out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | \
+			MPC52xx_PSC_RX_DISABLE);
+	}
+	/* disable transmiter/receiver and fifo interrupt */
+	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
+	out_be32(&fifo->tximr, 0);
+	return 0;
+}
+
+static void mpc512x_psc_spi_work(struct work_struct *work)
+{
+	struct mpc512x_psc_spi *mps = container_of(work,
+						   struct mpc512x_psc_spi,
+						   work);
+
+	spin_lock_irq(&mps->lock);
+	mps->busy = 1;
+	while (!list_empty(&mps->queue)) {
+		struct spi_message *m;
+		struct spi_device *spi;
+		struct spi_transfer *t = NULL;
+		unsigned cs_change;
+		int status;
+
+		m = container_of(mps->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock_irq(&mps->lock);
+
+		spi = m->spi;
+		cs_change = 1;
+		status = 0;
+		list_for_each_entry(t, &m->transfers, transfer_list) {
+			if (t->bits_per_word || t->speed_hz) {
+				status = mpc512x_psc_spi_transfer_setup(spi, t);
+				if (status < 0)
+					break;
+			}
+
+			if (cs_change)
+				mpc512x_psc_spi_activate_cs(spi);
+			cs_change = t->cs_change;
+
+			status = mpc512x_psc_spi_transfer_rxtx(spi, t);
+			if (status)
+				break;
+			m->actual_length += t->len;
+
+			if (t->delay_usecs)
+				udelay(t->delay_usecs);
+
+			if (cs_change)
+				mpc512x_psc_spi_deactivate_cs(spi);
+		}
+
+		m->status = status;
+		m->complete(m->context);
+
+		if (status || !cs_change)
+			mpc512x_psc_spi_deactivate_cs(spi);
+
+		mpc512x_psc_spi_transfer_setup(spi, NULL);
+
+		spin_lock_irq(&mps->lock);
+	}
+	mps->busy = 0;
+	spin_unlock_irq(&mps->lock);
+}
+
+static int mpc512x_psc_spi_setup(struct spi_device *spi)
+{
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
+	struct mpc512x_psc_spi_cs *cs = spi->controller_state;
+	unsigned long flags;
+
+	if (spi->bits_per_word % 8)
+		return -EINVAL;
+
+	if (!cs) {
+		cs = kzalloc(sizeof *cs, GFP_KERNEL);
+		if (!cs)
+			return -ENOMEM;
+		spi->controller_state = cs;
+	}
+
+	cs->bits_per_word = spi->bits_per_word;
+	cs->speed_hz = spi->max_speed_hz;
+
+	spin_lock_irqsave(&mps->lock, flags);
+	if (!mps->busy)
+		mpc512x_psc_spi_deactivate_cs(spi);
+	spin_unlock_irqrestore(&mps->lock, flags);
+
+	return 0;
+}
+
+static int mpc512x_psc_spi_transfer(struct spi_device *spi,
+				    struct spi_message *m)
+{
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	m->actual_length = 0;
+	m->status = -EINPROGRESS;
+
+	spin_lock_irqsave(&mps->lock, flags);
+	list_add_tail(&m->queue, &mps->queue);
+	queue_work(mps->workqueue, &mps->work);
+	spin_unlock_irqrestore(&mps->lock, flags);
+
+	return 0;
+}
+
+static void mpc512x_psc_spi_cleanup(struct spi_device *spi)
+{
+	kfree(spi->controller_state);
+}
+
+static int mpc512x_psc_spi_port_config(int psc_id, struct mpc512x_psc_spi *mps)
+{
+	struct mpc52xx_psc __iomem *psc = mps->psc;
+	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
+	struct clk *spiclk;
+	struct device_node *np;
+	struct resource r;
+	int ret = 0;
+	char name[32];
+	u32 sicr;
+	u32 ccr;
+	u16 bclkdiv;
+
+	sprintf(name, "psc%d_mclk", psc_id);
+	spiclk = clk_get(NULL, name);
+	clk_enable(spiclk);
+	mps->mclk = clk_get_rate(spiclk);
+	clk_put(spiclk);
+
+	np = of_find_node_by_type(NULL, "soc");
+	of_address_to_resource(np, 0, &r);
+	of_node_put(np);
+
+	/* Reset the PSC into a known state */
+	out_8(&psc->command, MPC52xx_PSC_RST_RX);
+	out_8(&psc->command, MPC52xx_PSC_RST_TX);
+	out_8(&psc->command, MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
+
+	/* Disable psc interrupts all useful interrupts are in fifo */
+	out_be16(&psc->isr_imr.imr, 0);
+
+	/* Disable fifo interrupts, will be enabled later */
+	out_be32(&fifo->tximr, 0);
+	out_be32(&fifo->rximr, 0);
+
+	sicr = 0
+	    | 0x01000000	/* SIM = 0001 -- 8 bit */
+	    | 0x00800000	/* GenClk = 1 -- internal clk */
+	    | 0x00008000	/* SPI = 1 */
+	    | 0x00004000	/* MSTR = 1   -- SPI master */
+	    | 0x00000800	/* UseEOF = 1 -- SS low until EOF */
+	    |0;
+	out_be32(&psc->sicr, sicr);
+
+	ccr = in_be32(&psc->ccr);
+	ccr &= 0xFF000000;
+	bclkdiv = (mps->mclk / 1000000) - 1;	/* default 1MHz */
+	ccr |= (((bclkdiv & 0xff) << 16) | (((bclkdiv >> 8) & 0xff) << 8));
+	out_be32(&psc->ccr, ccr);
+
+	/* Set 2ms DTL delay */
+	out_8(&psc->ctur, 0x00);
+	out_8(&psc->ctlr, 0x82);
+
+	/* we don't use the alarms */
+	out_be32(&fifo->rxalarm, 0xfff);
+	out_be32(&fifo->txalarm, 0);
+
+	/* Enable FIFO slices for Rx/Tx */
+	out_be32(&fifo->rxcmd,
+		 MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);
+	out_be32(&fifo->txcmd,
+		 MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);
+
+	mps->bits_per_word = 8;
+
+	return ret;
+}
+
+static irqreturn_t mpc512x_psc_spi_isr(int irq, void *dev_id)
+{
+	struct mpc512x_psc_spi *mps = (struct mpc512x_psc_spi *)dev_id;
+	struct mpc512x_psc_fifo __iomem *fifo = mps->fifo;
+
+	/* clear interrupt and wake up the work queue */
+	if (in_be32(&fifo->txisr)
+		& in_be32(&fifo->tximr) & MPC512x_PSC_FIFO_EMPTY) {
+		out_be32(&fifo->txisr, MPC512x_PSC_FIFO_EMPTY);
+		out_be32(&fifo->tximr, 0);
+		complete(&mps->done);
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
+
+/* bus_num is used only for the case dev->platform_data == NULL */
+static int __init mpc512x_psc_spi_do_probe(struct device *dev, u32 regaddr,
+					   u32 size, unsigned int irq,
+					   s16 bus_num)
+{
+	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct mpc512x_psc_spi *mps;
+	struct spi_master *master;
+	int ret;
+	void *tempp;
+
+	master = spi_alloc_master(dev, sizeof *mps);
+	if (master == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, master);
+	mps = spi_master_get_devdata(master);
+	mps->irq = irq;
+
+	if (pdata == NULL) {
+		dev_err(dev, "probe called without platform data, no "
+			 "(de)activate_cs functions will be called\n");
+		mps->activate_cs = NULL;
+		mps->deactivate_cs = NULL;
+		mps->sysclk = 0;
+		master->bus_num = bus_num;
+		master->num_chipselect = 255;
+	} else {
+		mps->activate_cs = pdata->activate_cs;
+		mps->deactivate_cs = pdata->deactivate_cs;
+		mps->sysclk = pdata->sysclk;
+		master->bus_num = pdata->bus_num;
+		master->num_chipselect = pdata->max_chipselect;
+	}
+
+	master->setup = mpc512x_psc_spi_setup;
+	master->transfer = mpc512x_psc_spi_transfer;
+	master->cleanup = mpc512x_psc_spi_cleanup;
+
+	tempp = ioremap(regaddr, size);
+	if (!tempp) {
+		dev_err(dev, "could not ioremap I/O port range\n");
+		ret = -EFAULT;
+		goto free_master;
+	}
+	mps->psc = tempp;
+	mps->fifo =
+	    (struct mpc512x_psc_fifo *)(tempp + sizeof(struct mpc52xx_psc));
+
+	ret = request_irq(mps->irq, mpc512x_psc_spi_isr, IRQF_SHARED,
+		"mpc512x-psc-spi", mps);
+	if (ret)
+		goto free_master;
+
+	ret = mpc512x_psc_spi_port_config(master->bus_num, mps);
+	if (ret < 0)
+		goto free_irq;
+
+	spin_lock_init(&mps->lock);
+	init_completion(&mps->done);
+	INIT_WORK(&mps->work, mpc512x_psc_spi_work);
+	INIT_LIST_HEAD(&mps->queue);
+
+	mps->workqueue =
+	    create_singlethread_workqueue(master->dev.parent->bus_id);
+	if (mps->workqueue == NULL) {
+		ret = -EBUSY;
+		goto free_irq;
+	}
+
+	ret = spi_register_master(master);
+	if (ret < 0)
+		goto unreg_master;
+
+	return ret;
+
+unreg_master:
+	destroy_workqueue(mps->workqueue);
+free_irq:
+	free_irq(mps->irq, mps);
+free_master:
+	if (mps->psc)
+		iounmap(mps->psc);
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int __exit mpc512x_psc_spi_do_remove(struct device *dev)
+{
+	struct spi_master *master = dev_get_drvdata(dev);
+	struct mpc512x_psc_spi *mps = spi_master_get_devdata(master);
+
+	flush_workqueue(mps->workqueue);
+	destroy_workqueue(mps->workqueue);
+	spi_unregister_master(master);
+	free_irq(mps->irq, mps);
+	if (mps->psc)
+		iounmap(mps->psc);
+
+	return 0;
+}
+
+static int __init mpc512x_psc_spi_of_probe(struct of_device *op,
+					   const struct of_device_id *match)
+{
+	const u32 *regaddr_p;
+	u64 regaddr64, size64;
+	s16 id = -1;
+
+	regaddr_p = of_get_address(op->node, 0, &size64, NULL);
+	if (!regaddr_p) {
+		printk(KERN_ERR "Invalid PSC address\n");
+		return -EINVAL;
+	}
+	regaddr64 = of_translate_address(op->node, regaddr_p);
+
+	/* get PSC id (0..11, used by port_config) */
+	if (op->dev.platform_data == NULL) {
+		const u32 *psc_nump;
+		psc_nump = of_get_property(op->node, "cell-index", NULL);
+		if (!psc_nump || *psc_nump > 11) {
+			printk(KERN_ERR
+			       "mpc512x_psc_spi: Device node %s has invalid "
+			       "cell-index property\n", op->node->full_name);
+			return -EINVAL;
+		}
+		id = *psc_nump;
+	}
+
+	return mpc512x_psc_spi_do_probe(&op->dev, (u32) regaddr64, (u32) size64,
+					irq_of_parse_and_map(op->node, 0), id);
+}
+
+static int __exit mpc512x_psc_spi_of_remove(struct of_device *op)
+{
+	return mpc512x_psc_spi_do_remove(&op->dev);
+}
+
+static struct of_device_id mpc512x_psc_spi_of_match[] = {
+	{.compatible = "fsl,mpc5121-psc-spi",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, mpc512x_psc_spi_of_match);
+
+static struct of_platform_driver mpc512x_psc_spi_of_driver = {
+	.owner = THIS_MODULE,
+	.name = "mpc512x-psc-spi",
+	.match_table = mpc512x_psc_spi_of_match,
+	.probe = mpc512x_psc_spi_of_probe,
+	.remove = __exit_p(mpc512x_psc_spi_of_remove),
+	.driver = {
+		   .name = "mpc512x-psc-spi",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init mpc512x_psc_spi_init(void)
+{
+	return of_register_platform_driver(&mpc512x_psc_spi_of_driver);
+}
+
+module_init(mpc512x_psc_spi_init);
+
+static void __exit mpc512x_psc_spi_exit(void)
+{
+	of_unregister_platform_driver(&mpc512x_psc_spi_of_driver);
+}
+
+module_exit(mpc512x_psc_spi_exit);
+
+MODULE_AUTHOR("John Rigby");
+MODULE_DESCRIPTION("MPC52xx PSC SPI Driver");
+MODULE_LICENSE("GPL");
-- 
1.6.0.90.g436ed

