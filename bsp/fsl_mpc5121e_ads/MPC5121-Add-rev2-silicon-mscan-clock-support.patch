From 63f090eecb2d99e64f949ef23b4ef78304a3c285 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 18 Jun 2009 15:33:45 +0800
Subject: [PATCH 04/25] MPC5121: Add rev2 silicon mscan clock support

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

For rev2 silicon, mscan has more clock source
options.  This patch adds support for this new
functionality.

Added fsl,mpc5121rev2-clock to compatible for the clock
node in the ADS rev4 device tree.

Add code in clk driver to support the new
mscan clock sources.  If the divisor is still
the reset default it sets the divisor to 1
and the source to sysclk.

If u-boot or board init wants something different
then the divisor will not be the reset default so
the code will leave it alone.

This updated patch fixes a cut-and-paste error that
had the mscan clock calculater using pccr instead of mccr.
It also changes the default clock to sysclk/4 instead of
sysclk/1.  It also rounds up mscan source clocks to the
next Mhz (400MHz for ADS5121).

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Chen Hongjun <hong-jun.chen@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/boot/dts/mpc5121ads.dts |    2 +-
 arch/powerpc/platforms/512x/clock.c  |   94 +++++++++++++++++++++++++++++++++-
 2 files changed, 94 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/boot/dts/mpc5121ads.dts b/arch/powerpc/boot/dts/mpc5121ads.dts
index fdbe99c..18d9da8 100644
--- a/arch/powerpc/boot/dts/mpc5121ads.dts
+++ b/arch/powerpc/boot/dts/mpc5121ads.dts
@@ -195,7 +195,7 @@
 		};
 
 		clock@f00 {	// Clock control
-			compatible = "fsl,mpc5121-clock";
+			compatible = "fsl,mpc5121rev2-clock", "fsl,mpc5121-clock";
 			reg = <0xf00 0x100>;
 		};
 
diff --git a/arch/powerpc/platforms/512x/clock.c b/arch/powerpc/platforms/512x/clock.c
index f416014..95cc536 100644
--- a/arch/powerpc/platforms/512x/clock.c
+++ b/arch/powerpc/platforms/512x/clock.c
@@ -30,9 +30,11 @@
 #undef CLK_DEBUG
 
 static int clocks_initialized;
+static int rev2_silicon;
 
 #define CLK_HAS_RATE	0x1	/* has rate in MHz */
 #define CLK_HAS_CTRL	0x2	/* has control reg and bit */
+#define ROUND_1MHZ	1000000	/* 1MHZ */
 
 struct clk {
 	struct list_head node;
@@ -117,6 +119,9 @@ struct mpc512x_clockctl {
 	u32 spccr;		/* SPDIF Clk Ctrl Reg */
 	u32 cccr;		/* CFM Clk Ctrl Reg */
 	u32 dccr;		/* DIU Clk Cnfg Reg */
+	/* rev2 only regs */
+	u32 mccr[4];		/* MSCAN Clk Ctrl Reg 1-3 */
+
 };
 
 struct mpc512x_clockctl __iomem *clockctl;
@@ -698,12 +703,96 @@ static struct clk_interface mpc5121_clk_functions = {
 	.clk_get_parent		= NULL,
 };
 
+unsigned long round_rate(unsigned long rate)
+{
+	unsigned long new_rate;
+	new_rate = (unsigned long)((rate + ROUND_1MHZ) / ROUND_1MHZ) *
+							ROUND_1MHZ;
+	return new_rate;
+}
+
+/*
+ * mscan clock rate calculation
+ */
+static void mscan_calc_rate(struct clk *clk, int mscannum,
+			struct device_node *np)
+{
+	unsigned long mscanclk_src = sys_clk.rate;
+	unsigned long mscanclk_div;
+
+	/*
+	 * If the divider is the reset default of all 1's then
+	 * we know u-boot and/or board setup has not
+	 * done anything so set up a sane default
+	 */
+	if (((clockctl->mccr[mscannum] >> 17) & 0x7fff) == 0x7fff) {
+		/* disable */
+		clockctl->mccr[mscannum] = 0x0;
+		/* src is sysclk, divider is 4 */
+		clockctl->mccr[mscannum] = 0x3 << 17;
+		/* enable */
+		clockctl->mccr[mscannum] |= 0x10000;
+	}
+
+	switch ((clockctl->mccr[mscannum] >> 14) & 0x3) {
+	case 0:
+		mscanclk_src = round_rate(sys_clk.rate);
+		break;
+	case 1:
+		mscanclk_src = round_rate(ref_clk.rate);
+		break;
+	case 2:
+		mscanclk_src = round_rate(psc_mclk_in.rate);
+		break;
+	case 3:
+		mscanclk_src = round_rate(spdif_txclk.rate);
+		break;
+	}
+
+	mscanclk_div = ((clockctl->mccr[mscannum] >> 17) & 0x7fff) + 1;
+	clk->rate = mscanclk_src / mscanclk_div;
+}
+
+struct clk mscan_clks[4];
+
+/*
+ * Find all silicon rev2 mscan nodes in device tree and assign a clock
+ * with name "mscan%d_clk" and dev pointing at the device
+ * returned from of_find_device_by_node
+ */
+static void mscan_clks_init(void)
+{
+	struct device_node *np;
+	const u32 *cell_index;
+	struct of_device *ofdev;
+
+	for_each_compatible_node(np, NULL, "fsl,mpc5121rev2-mscan") {
+		cell_index = of_get_property(np, "cell-index", NULL);
+		if (cell_index) {
+			int mscannum = *cell_index;
+			struct clk *clk = &mscan_clks[mscannum];
+
+			clk->flags = CLK_HAS_RATE;
+			ofdev = of_find_device_by_node(np);
+			clk->dev = &ofdev->dev;
+			mscan_calc_rate(clk, mscannum, np);
+			sprintf(clk->name, "mscan%d_clk", mscannum);
+			clk_register(clk);
+		}
+	}
+}
+
 static int
 mpc5121_clk_init(void)
 {
 	struct device_node *np;
 
-	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-clock");
+	/* look for rev2 first then rev1 */
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121rev2-clock");
+	if (np)
+		rev2_silicon++;
+	else
+		np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-clock");
 	if (np) {
 		clockctl = of_iomap(np, 0);
 		of_node_put(np);
@@ -717,6 +806,9 @@ mpc5121_clk_init(void)
 	rate_clks_init();
 	psc_clks_init();
 
+	if (rev2_silicon)
+		mscan_clks_init();
+
 	/* leave clockctl mapped forever */
 	/*iounmap(clockctl); */
 	DEBUG_CLK_DUMP();
-- 
1.6.3.1

