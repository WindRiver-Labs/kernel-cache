From 3e21e1f059dec183179131bd3aab01d82ad6a82b Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:29 +0800
Subject: [PATCH 13/25] MPC5121 DIU: implement double buffering

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

add two exported apis

    void fsl_diu_flip(unsigned long paddr)
    this one is for backwards compatibilty
    this will flip on VSYNC or immediately depending
    on CONFIG_FSL_DIU_FLIP_ON_VSYNC

    void fsl_diu_flipn(int fbnum, unsigned long paddr, int now)
    this is new, fbnum choose which fb to use and
    now chooses to flip now or on vsync

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/video/Kconfig      |    9 ++++++++
 drivers/video/fsl-diu-fb.c |   48 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 57 insertions(+), 0 deletions(-)

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index b1e6689..d5052bb 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1849,6 +1849,15 @@ config FB_FSL_DIU
 	---help---
 	  Framebuffer driver for the Freescale SoC DIU
 
+config FSL_DIU_FLIP_ON_VSYNC
+	bool "Flip buffers on VSYNC" if FB_FSL_DIU
+	default y
+       ---help---
+	  Enable this if you want the fsl_diu_flip api to flip on vsync instead of
+          immediately.
+
+	  If unsure, say Y.
+
 config FB_W100
 	tristate "W100 frame buffer support"
 	depends on FB && ARCH_PXA
diff --git a/drivers/video/fsl-diu-fb.c b/drivers/video/fsl-diu-fb.c
index 0d68951..cfe2547 100644
--- a/drivers/video/fsl-diu-fb.c
+++ b/drivers/video/fsl-diu-fb.c
@@ -206,6 +206,7 @@ struct fsl_diu_data {
 struct fsl_diu_vsync {
 	wait_queue_head_t wait;
 	volatile unsigned int count;
+	unsigned long addr;
 };
 
 struct mfb_info {
@@ -1025,6 +1026,52 @@ static int wait_for_vsync(struct fb_info *info)
 	return 0;
 }
 
+static void do_pending_buffer_flips(void)
+{
+	int i;
+	struct mfb_info *mfbi;
+	struct diu_ad *ad;
+
+	for (i = 0; i < ARRAY_SIZE(global_machine_data->fsl_diu_info); i++) {
+		mfbi = (struct mfb_info *)
+			global_machine_data->fsl_diu_info[i]->par;
+		ad = mfbi->ad;
+		if (ad && mfbi->vsync.addr) {
+			ad->addr = cpu_to_le32(mfbi->vsync.addr);
+			mfbi->vsync.addr = 0;
+		}
+	}
+}
+
+void fsl_diu_flip(unsigned long paddr)
+{
+	struct mfb_info *mfbi = (struct mfb_info *)
+			global_machine_data->fsl_diu_info[0]->par;
+	struct diu_ad *ad = mfbi->ad;
+	if (ad) {
+#ifdef CONFIG_FSL_DIU_FLIP_ON_VSYNC
+		mfbi->vsync.addr = paddr;
+#else
+		ad->addr = cpu_to_le32(paddr);
+#endif
+	}
+}
+EXPORT_SYMBOL(fsl_diu_flip);
+
+void fsl_diu_flipn(int fbnum, unsigned long paddr, int now)
+{
+	struct mfb_info *mfbi = (struct mfb_info *)
+			global_machine_data->fsl_diu_info[fbnum]->par;
+	struct diu_ad *ad = mfbi->ad;
+	if (ad) {
+		if (now)
+			ad->addr = cpu_to_le32(paddr);
+		else
+			mfbi->vsync.addr = paddr;
+	}
+}
+EXPORT_SYMBOL(fsl_diu_flipn);
+
 static int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,
 		       unsigned long arg)
 {
@@ -1368,6 +1415,7 @@ static irqreturn_t fsl_diu_isr(int irq, void *dev_id)
 #endif
 			((struct mfb_info *)global_machine_data->
 				fsl_diu_info[0]->par)->vsync.count++;
+			do_pending_buffer_flips();
 			wake_up_interruptible(&((struct mfb_info *)
 				global_machine_data->fsl_diu_info[0]->par)
 				->vsync.wait);
-- 
1.6.3.1

