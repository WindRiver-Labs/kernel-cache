From 1b07b02096667de068b9a6b2ad90fd915f6e969f Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 18 Jun 2009 15:33:41 +0800
Subject: [PATCH] MPC5121: Fix PATA driver issues introduce improvements

Inspired by patches from rev 4 board support ISO image:
   mpc5121ads-20081208_ltib-beta.iso
   http://www.freescale.com/webapp/sps/site/overview.jsp?
   nodeId=0127260061033202A5621E

   Patches:
   linux-2.6.24.6-mpc5121-96-PATA-use-mmio.patch
   linux-2.6.24.6-mpc5121-MPC5121e-PATA-driver.patch
   linux-2.6.24.6-mpc5121-116-PATA-limit-udma-to-udma4-and-lo.patch
   linux-2.6.24.6-mpc5121-128-PATA-better-error-recovery.patch

This removes the reset routine that does more
harm than good by calling dma routines in irq context.

Does a better job of limiting UDMA to UDMA4.

Use mmio instead of the default pio because pio
does not work right with pci turned on.

Pull in missed parts of port.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/ide/ppc/mpc512x.h     |    1 +
 drivers/ide/ppc/mpc512x_ide.c |  173 +++++++++++++++++++----------------------
 2 files changed, 80 insertions(+), 94 deletions(-)

diff --git a/drivers/ide/ppc/mpc512x.h b/drivers/ide/ppc/mpc512x.h
index 57f53e9..5465d5c 100644
--- a/drivers/ide/ppc/mpc512x.h
+++ b/drivers/ide/ppc/mpc512x.h
@@ -124,6 +124,7 @@ struct fsl_ata_priv {
 	int dma_stat;		/*!< the state of DMA request */
 	u8 enable;		/*!< Current hardware interrupt mask */
 	void *ata_regs;		/*!< Base of ata registers */
+	int regs_size;
 	dma_addr_t dma_addr;	/* physical address for dma rd/wr */
 
 	int ata_irq;		/*!< ATA irq number */
diff --git a/drivers/ide/ppc/mpc512x_ide.c b/drivers/ide/ppc/mpc512x_ide.c
index 092ffaa..49fbc78 100644
--- a/drivers/ide/ppc/mpc512x_ide.c
+++ b/drivers/ide/ppc/mpc512x_ide.c
@@ -53,9 +53,6 @@
 
 static void fsl_ata_dma_callback(void *arg, int error);
 
-/* List of registered interfaces */
-static ide_hwif_t *ifs[1];
-static struct fsl_ata_priv *gpriv;
 /*
  * This structure contains the timing parameters for
  * ATA bus timing in the 5 PIO modes.  The timings
@@ -321,12 +318,12 @@ static int fsl_ata_ack_intr(struct hwif_s *hw)
  */
 static void fsl_ata_set_speed(ide_drive_t *drive, const u8 speed)
 {
+	u8 safespeed = speed > XFER_UDMA_4 ? XFER_UDMA_4 : speed;
 	struct fsl_ata_priv *priv =
 	    (struct fsl_ata_priv *)HWIF(drive)->hwif_data;
-	switch (speed) {
-	case XFER_UDMA_7:
-	case XFER_UDMA_6:
-	case XFER_UDMA_5:
+
+	switch (safespeed) {
+	/* all into ... */
 	case XFER_UDMA_4:
 	case XFER_UDMA_3:
 	case XFER_UDMA_2:
@@ -346,48 +343,6 @@ static void fsl_ata_set_speed(ide_drive_t *drive, const u8 speed)
 	}
 }
 
-static void __fsl_ata_resetproc(struct fsl_ata_priv *priv)
-{
-	printk(KERN_INFO "%s: resetting ATA controller\n", __func__);
-
-	if (priv->dma_read_chan >= 0) {
-		fsl_dma_free_chan(priv->dma_read_chan);
-		priv->dma_read_chan = fsl_dma_chan_request(MPC512X_DMA_ATA_RX);
-		if (priv->dma_read_chan < 0) {
-			printk(KERN_ERR DRV_NAME ": "
-			       "%s: could not reallocate RX DMA channel\n",
-			       DRV_NAME);
-		}
-	}
-
-	if (priv->dma_write_chan >= 0) {
-		fsl_dma_free_chan(priv->dma_write_chan);
-		priv->dma_write_chan = fsl_dma_chan_request(MPC512X_DMA_ATA_TX);
-		if (priv->dma_write_chan < 0) {
-			printk(KERN_ERR DRV_NAME ": "
-			       "%s: could not reallocate TX DMA channel\n",
-			       DRV_NAME);
-		}
-	}
-	ATA_RAW_WRITE(0x00, FSL_ATA_CONTROL);
-	udelay(100);
-	ATA_RAW_WRITE(FSL_ATA_CTRL_ATA_RST_B, FSL_ATA_CONTROL);
-	udelay(100);
-}
-
-/*!
- * Called by the IDE layer when something goes wrong
- *
- * @param       drive       Specifies the drive
- *
- */
-static void fsl_ata_resetproc(ide_drive_t *drive)
-{
-	struct fsl_ata_priv *priv =
-	    (struct fsl_ata_priv *)HWIF(drive)->hwif_data;
-	__fsl_ata_resetproc(priv);
-}
-
 /*!
  * The DMA is done, and the drive is done.  We'll check the BD array for
  * errors, and unmap the scatter-gather list.
@@ -496,31 +451,13 @@ static void fsl_ata_dma_callback(void *arg, int error)
 	ide_hwif_t *hwif = HWIF((ide_drive_t *) arg);
 	struct fsl_ata_priv *priv = (struct fsl_ata_priv *)(hwif->hwif_data);
 	unsigned long fifo_fill;
-	int cnt = 0;
 
 	/*
 	 * clean the fifo if the fill register is non-zero.
 	 * If the fill register is non-zero, it is incorrect state.
 	 */
 	fifo_fill = ATA_RAW_READ(FSL_ATA_FIFO_FILL);
-	cnt = 0;
-	while (fifo_fill) {
-		printk(KERN_ERR DRV_NAME ": "
-			"waiting for fifo to drain %08lx\n", fifo_fill);
-		fifo_fill = ATA_RAW_READ(FSL_ATA_FIFO_FILL);
-		if (cnt++ > 100)
-			break;
-	}
-	cnt = 0;
-	while (fifo_fill) {
-		unsigned long d;
-		d = ATA_RAW_READ(FSL_ATA_FIFO_DATA_32);
-		printk(KERN_ERR DRV_NAME ": "
-			"draining fifo d/ff/c %08lx/%lx/%d\n",
-			d, fifo_fill, cnt);
-		fifo_fill = ATA_RAW_READ(FSL_ATA_FIFO_FILL);
-		cnt++;
-	}
+	BUG_ON(fifo_fill); 	/* TODO: need better recovery here */
 
 	priv->dma_stat = error;
 	/*
@@ -685,8 +622,6 @@ static int fsl_ata_dma_timer_expiry(ide_drive_t *drive)
 		"%s %s: fifo_fill=%d\n", __func__, drive->name,
 	       readb(FSL_ATA_FIFO_FILL));
 
-	fsl_ata_resetproc(drive);
-
 	if (drive->waiting_for_dma)
 		HWIF(drive)->dma_ops->dma_end(drive);
 
@@ -766,7 +701,7 @@ static int fsl_ata_dma_test_irq(ide_drive_t *drive)
  */
 int fsl_ata_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)
 {
-	struct fsl_ata_priv *priv = gpriv;
+	struct fsl_ata_priv *priv = (struct fsl_ata_priv *)hwif->hwif_data;
 
 	hwif->dmatable_cpu = NULL;
 	hwif->dmatable_dma = 0;
@@ -788,12 +723,10 @@ int fsl_ata_dma_init(ide_hwif_t *hwif, const struct ide_port_info *d)
 		goto err_out;
 	}
 
-	set_ata_bus_timing(priv, 0, UDMA);
-
 	/*
 	 * All ready now
 	 */
-	hwif->ultra_mask = 0x7f;
+	hwif->ultra_mask = 0x1f;
 	hwif->mwdma_mask = 0x07;
 	hwif->swdma_mask = 0x07;
 
@@ -813,16 +746,20 @@ err_out:
 	return  -1;
 }
 
+static void fsl_dma_host_set(ide_drive_t *drive, int on)
+{
+
+}
+
 static const struct ide_port_ops mpc512x_port_ops = {
 	.set_pio_mode		= fsl_ata_set_pio_mode,
 	.set_dma_mode		= fsl_ata_set_speed,
 	.selectproc		= fsl_ata_selectproc,
-	.resetproc		= fsl_ata_resetproc,
 	.maskproc		= fsl_ata_maskproc,
 };
 
 static const struct ide_dma_ops	mpc512x_dma_ops = {
-	.dma_host_set		= ide_dma_host_set,
+	.dma_host_set		= fsl_dma_host_set,
 	.dma_setup		= fsl_ata_dma_setup,
 	.dma_exec_cmd		= fsl_ata_dma_exec_cmd,
 	.dma_start		= fsl_ata_dma_start,
@@ -837,9 +774,25 @@ static const struct ide_port_info mpc512x_port_info = {
 	.init_dma		= fsl_ata_dma_init,
 	.port_ops		= &mpc512x_port_ops,
 	.dma_ops		= &mpc512x_dma_ops,
+	/*
+	 * Ensure we're using MMIO.
+	 * If you only want to use PIO mode, please add IDE_HFLAG_NO_DMA.
+	 * However, in whatever DMA mode or PIO mode, should not add
+	 * IDE_HFLAG_NO_SET_MODE, otherwise, in DMA mode, will obviously cause
+	 * "lost interrupt" (disable DMA mode) or "kenerl panic" because can't
+	 * invoke fsl_ata_set_speed in ide_port_tune_devices(ide_host_register)
+	 * to set it to DMA bus timing, although in PIO mode, it can work,
+	 * because by default in mpc512x_ata_probe has invoked
+	 * set_ata_bus_timing to set it to PIO0 bus timing, however, can't
+	 * invoke fsl_ata_set_pio_mode in ide_port_tune_devices, so can't use
+	 * the maximal PIO mode(depends on pio_mask value in ide_port_info)
+	 * after  setting IDE_HFLAG_NO_SET_MODE.
+	 *
+	 */
+	.host_flags		= IDE_HFLAG_MMIO,
 	.pio_mask		= ATA_PIO4,
 	.mwdma_mask		= ATA_MWDMA2,
-	.udma_mask		= ATA_UDMA3,
+	.udma_mask		= ATA_UDMA4,
 };
 
 /*!
@@ -855,7 +808,7 @@ static const struct ide_port_info mpc512x_port_info = {
  *
  * @param   irq    IRQ number for our hardware
  *
- * @param   hwifp  Pointer to hwif structure to be updated by the IDE layer
+ * @param   dev   Pointer to device structure
  *
  * @param   priv   Pointer to private structure
  *
@@ -863,7 +816,7 @@ static const struct ide_port_info mpc512x_port_info = {
  */
 static int __init
 fsl_ata_register(unsigned long base, unsigned long aux, int irq,
-		 ide_hwif_t **hwifp, struct fsl_ata_priv *priv)
+		 struct device *dev, struct fsl_ata_priv *priv)
 {
 	struct ide_host *host;
 	hw_regs_t hw, *hws[] = { &hw, NULL, NULL, NULL };
@@ -880,19 +833,30 @@ fsl_ata_register(unsigned long base, unsigned long aux, int irq,
 	hw.irq = irq;
 	hw.ack_intr = fsl_ata_ack_intr;
 
-	ret = ide_host_add(&mpc512x_port_info, hws, &host);
-	if (ret)
-		goto out;
+	/* fixme: in order to set hwif->hwif_data, must break apart
+	 * the function of ide_host_add:
+	 * " ret = ide_host_add(&mpc512x_port_info, hws, &host);
+	 *   if (ret)
+	 *  	return ret;
+	 * "
+	 */
+	host = ide_host_alloc(&mpc512x_port_info, hws);
+	if (host == NULL)
+		return -ENOMEM;
 
 	hwif = host->ports[0];
-	*hwifp = hwif;
 	hwif->hwif_data = (void *)priv;
+	dev_set_drvdata(dev, host);
+
+	ret = ide_host_register(host, &mpc512x_port_info, hws);
+	if (ret) {
+		ide_host_free(host);
+		return ret;
+	}
 
 	fsl_ata_enable_irq(hwif);
 
 	return  0;
-out:
-	return ret;
 }
 
 /*!
@@ -914,7 +878,6 @@ static int __init mpc512x_ata_probe(struct of_device *op,
 		       "Error while allocating private structure\n");
 		return ENOMEM;
 	}
-	gpriv = priv ;
 
 	priv->dev = NULL;
 	priv->dma_read_chan = -1;
@@ -945,6 +908,8 @@ static int __init mpc512x_ata_probe(struct of_device *op,
 		goto err;
 	}
 
+	priv->regs_size = 1 + res_mem.end - res_mem.start;
+
 	/* mapin regs */
 	priv->ata_regs = devm_ioremap(&op->dev, res_mem.start,
 				      1 + res_mem.end - res_mem.start);
@@ -962,16 +927,19 @@ static int __init mpc512x_ata_probe(struct of_device *op,
 	/* Deassert the reset bit to enable the interface */
 	ATA_RAW_WRITE(FSL_ATA_CTRL_ATA_RST_B, FSL_ATA_CONTROL);
 
-	/* Set initial timing and mode */
+	/*
+	 * Before registerring host(ide_host_register), MUST set initial
+	 * timings to PIO mode: PIO0-PIO4,can't set to UDMA or MDMA mode.
+	 * Generally, set it to PIO0 by default.
+	 *
+	 */
 	set_ata_bus_timing(priv, 0, PIO);
 
-	/* Reset the interface */
-	__fsl_ata_resetproc(priv);
-
 	/*
 	 * Enable hardware interrupts.
 	 * INTRQ2 goes to us, so we enable it here, but we'll need to ignore
 	 * it when DMA is doing the transfer.
+	 *
 	 */
 	ATA_RAW_WRITE(FSL_ATA_INTR_ATA_INTRQ2, FSL_ATA_INTR_ENABLE);
 
@@ -979,7 +947,7 @@ static int __init mpc512x_ata_probe(struct of_device *op,
 	 * Now register
 	 */
 	rv = fsl_ata_register((unsigned long)FSL_ATA_IO,
-			     (unsigned long)FSL_ATA_CTL, priv->ata_irq, &ifs[0],
+		(unsigned long)FSL_ATA_CTL, priv->ata_irq, &op->dev,
 				priv);
 	if (rv) {
 		printk(KERN_ERR DRV_NAME ": "
@@ -1001,7 +969,15 @@ static int __init mpc512x_ata_probe(struct of_device *op,
 
 	/* error exit */
 err:
-	irq_dispose_mapping(priv->ata_irq);
+	devm_release_mem_region(&op->dev, priv->dma_addr - 0x18,
+					priv->regs_size);
+	if (priv->ata_regs)
+		devm_iounmap(&op->dev, priv->ata_regs);
+	if (priv->ata_irq)
+		irq_dispose_mapping(priv->ata_irq);
+	if (priv)
+		devm_kfree(&op->dev, priv);
+
 	return rv;
 }
 
@@ -1010,7 +986,8 @@ err:
  */
 static int __exit mpc512x_ata_remove(struct of_device *op)
 {
-	ide_hwif_t *hwif = ifs[0];
+	struct ide_host	*host = dev_get_drvdata(&op->dev);
+	ide_hwif_t *hwif = host->ports[0];
 	struct fsl_ata_priv *priv;
 
 	BUG_ON(!hwif);
@@ -1028,19 +1005,27 @@ static int __exit mpc512x_ata_remove(struct of_device *op)
 	clk_disable(priv->ata_clk);
 	clk_put(priv->ata_clk);
 
+	ide_host_remove(hwif->host);
+
 	/*
 	 * Cleanup the irq_mapping
 	 */
 	irq_dispose_mapping(priv->ata_irq);
 
+	/* Clear up IO allocations */
+	devm_iounmap(&op->dev, priv->ata_regs);
+	devm_release_mem_region(&op->dev, priv->dma_addr - 0x18,
+				priv->regs_size);
+
 	if (priv->dma_read_chan >= 0)
 		fsl_dma_free_chan(priv->dma_read_chan);
 	if (priv->dma_write_chan >= 0)
 		fsl_dma_free_chan(priv->dma_write_chan);
+
 	/*
 	 * Free the private structure.
 	 */
-	kfree(priv);
+	devm_kfree(&op->dev, priv);
 	hwif->hwif_data = NULL;
 
 	return 0;
-- 
1.6.3.3

