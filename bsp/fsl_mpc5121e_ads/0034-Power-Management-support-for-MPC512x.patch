From 3546e314edfcce9a66a48bdd1c0953e2e3dade2c Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 27 Nov 2008 16:56:46 +0800
Subject: [PATCH] Power Management support for MPC512x.

Generic Power Management support for MPC512x processor
family and Power Management support for MPC5121 ADS board.

This PM supports two CPU modes: sleep and deep sleep.

Signed-off-by: Andrei Dolnikov <adolnikov@embeddedalley.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/Kconfig                      |    2 +-
 arch/powerpc/include/asm/mpc512x.h        |  100 ++++++
 arch/powerpc/kernel/irq.c                 |   12 +
 arch/powerpc/platforms/512x/mpc5121_ads.c |    5 +
 arch/powerpc/platforms/512x/mpc512x_pm.c  |  539 ++++++++++++++++++++++++++++-
 arch/powerpc/platforms/512x/mpc512x_pm.h  |  120 +++++++
 6 files changed, 775 insertions(+), 3 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/mpc512x_pm.h

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 21aa04a..84551c5 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -207,7 +207,7 @@ config ARCH_HIBERNATION_POSSIBLE
 
 config ARCH_SUSPEND_POSSIBLE
 	def_bool y
-	depends on ADB_PMU || PPC_EFIKA || PPC_LITE5200 || PPC_83xx
+	depends on ADB_PMU || PPC_EFIKA || PPC_LITE5200 || PPC_83xx || PPC_MPC512x
 
 config PPC_DCR_NATIVE
 	bool
diff --git a/arch/powerpc/include/asm/mpc512x.h b/arch/powerpc/include/asm/mpc512x.h
index 7b9cca1..0efc770 100644
--- a/arch/powerpc/include/asm/mpc512x.h
+++ b/arch/powerpc/include/asm/mpc512x.h
@@ -16,6 +16,92 @@
 #ifndef __ASM_POWERPC_MPC512x_H__
 #define __ASM_POWERPC_MPC512x_H__
 
+/*
+ * DDR Memory Controller Memory Map
+ */
+struct ddr512x {
+	u32 ddr_sys_config;	/* System Configuration Register */
+	u32 ddr_time_config0;	/* Timing Configuration Register */
+	u32 ddr_time_config1;	/* Timing Configuration Register */
+	u32 ddr_time_config2;	/* Timing Configuration Register */
+	u32 ddr_command;	/* Command Register */
+	u32 ddr_compact_command;	/* Compact Command Register */
+	u16 pad_0;		/* Padding for Self Refresh Command Register 0 */
+	u16 self_refresh_cmd_0;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_1;		/* Padding for Self Refresh Command Register 1 */
+	u16 self_refresh_cmd_1;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_2;		/* Padding for Self Refresh Command Register 2 */
+	u16 self_refresh_cmd_2;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_3;		/* Padding for Self Refresh Command Register 3 */
+	u16 self_refresh_cmd_3;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_4;		/* Padding for Self Refresh Command Register 4 */
+	u16 self_refresh_cmd_4;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_5;		/* Padding for Self Refresh Command Register 5 */
+	u16 self_refresh_cmd_5;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_6;		/* Padding for Self Refresh Command Register 6 */
+	u16 self_refresh_cmd_6;	/* Enter/Exit Self Refresh Registers */
+	u16 pad_7;		/* Padding for Self Refresh Command Register 7 */
+	u16 self_refresh_cmd_7;	/* Enter/Exit Self Refresh Registers */
+	u32 DQS_config_offset_count;	/* DQS Config Offset Count */
+	u32 DQS_config_offset_time;	/* DQS Config Offset Time */
+	u32 DQS_delay_status;	/* DQS Delay Status */
+	u32 res0[0xF];
+	u32 prioman_config1;	/* Priority Manager Configuration */
+	u32 prioman_config2;	/* Priority Manager Configuration */
+	u32 hiprio_config;	/* High Priority Configuration */
+	u32 lut_table0_main_upper;	/* LUT0 Main Upper */
+	u32 lut_table1_main_upper;	/* LUT1 Main Upper */
+	u32 lut_table2_main_upper;	/* LUT2 Main Upper */
+	u32 lut_table3_main_upper;	/* LUT3 Main Upper */
+	u32 lut_table4_main_upper;	/* LUT4 Main Upper */
+	u32 lut_table0_main_lower;	/* LUT0 Main Lower */
+	u32 lut_table1_main_lower;	/* LUT1 Main Lower */
+	u32 lut_table2_main_lower;	/* LUT2 Main Lower */
+	u32 lut_table3_main_lower;	/* LUT3 Main Lower */
+	u32 lut_table4_main_lower;	/* LUT4 Main Lower */
+	u32 lut_table0_alternate_upper;	/* LUT0 Alternate Upper */
+	u32 lut_table1_alternate_upper; /* LUT1 Alternate Upper */
+	u32 lut_table2_alternate_upper; /* LUT2 Alternate Upper */
+	u32 lut_table3_alternate_upper; /* LUT3 Alternate Upper */
+	u32 lut_table4_alternate_upper; /* LUT4 Alternate Upper */
+	u32 lut_table0_alternate_lower; /* LUT0 Alternate Lower */
+	u32 lut_table1_alternate_lower; /* LUT1 Alternate Lower */
+	u32 lut_table2_alternate_lower; /* LUT2 Alternate Lower */
+	u32 lut_table3_alternate_lower; /* LUT3 Alternate Lower */
+	u32 lut_table4_alternate_lower; /* LUT4 Alternate Lower */
+	u32 performance_monitor_config;
+	u32 event_time_counter;
+	u32 event_time_preset;
+	u32 performance_monitor1_address_low;
+	u32 performance_monitor2_address_low;
+	u32 performance_monitor1_address_hi;
+	u32 performance_monitor2_address_hi;
+	u32 res1[2];
+	u32 performance_monitor1_read_counter;
+	u32 performance_monitor2_read_counter;
+	u32 performance_monitor1_write_counter;
+	u32 performance_monitor2_write_counter;
+	u32 granted_ack_counter0;
+	u32 granted_ack_counter1;
+	u32 granted_ack_counter2;
+	u32 granted_ack_counter3;
+	u32 granted_ack_counter4;
+	u32 cumulative_wait_counter0;
+	u32 cumulative_wait_counter1;
+	u32 cumulative_wait_counter2;
+	u32 cumulative_wait_counter3;
+	u32 cumulative_wait_counter4;
+	u32 summed_priority_counter0;
+	u32 summed_priority_counter1;
+	u32 summed_priority_counter2;
+	u32 summed_priority_counter3;
+	u32 summed_priority_counter4;
+	u32 res2[0x3AD];
+};
+
+#define MPC512x_DDR_BASE	0x9000	/* Offset of DRAM controller */
+
+extern void __iomem *mpc512x_find_and_map(const char *compatible);
 extern unsigned long mpc512x_find_ips_freq(struct device_node *node);
 
 /*
@@ -27,5 +113,19 @@ extern void mpc5121_pscgpio_pin_high(int psc, int pin);
 extern void mpc5121_pscgpio_pin_low(int psc, int pin);
 extern void mpc5121_pscgpio_make_psc(int psc, int pin);
 
+extern struct clk *clk_get(struct device *dev, const char *id);
+extern int clk_enable(struct clk *clk);
+
+#ifdef CONFIG_PM
+extern int __init mpc512x_pm_init(void);
+extern void mpc512x_pmc_clrevent(void);
+extern int mpc512x_set_gpio_wakeup(unsigned int gpio_num,
+				   unsigned int detect_mode);
+#endif
+
+#ifdef CONFIG_MPC5121_PM_TEST
+extern void mpc512x_pm_test_setup(void);
+#endif
+
 #endif /* __ASM_POWERPC_MPC512x_H__ */
 
diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index a1928d6..03738d1 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -64,6 +64,7 @@
 #include <asm/ptrace.h>
 #include <asm/machdep.h>
 #include <asm/udbg.h>
+#include <asm/mpc512x.h>
 #ifdef CONFIG_PPC64
 #include <asm/paca.h>
 #include <asm/firmware.h>
@@ -280,6 +281,17 @@ void do_IRQ(struct pt_regs *regs)
 	 */
 	irq = ppc_md.get_irq();
 
+#if defined(CONFIG_PM) && defined(CONFIG_PPC_MPC512x)
+	if (irq == NO_IRQ) {
+		/*
+		 * Got a NO INTERRUPT case. This could be RTC>TTR wake up
+		 * Interrupt from Power down mode. In the case the
+		 * mpc512x_pmc_clrevent would clear the event register of PMC.
+		 */
+		mpc512x_pmc_clrevent();
+	}
+#endif
+
 	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
 #ifdef CONFIG_IRQSTACKS
 		/* Switch to the irq stack to handle this */
diff --git a/arch/powerpc/platforms/512x/mpc5121_ads.c b/arch/powerpc/platforms/512x/mpc5121_ads.c
index 05d0564..0c1886a 100644
--- a/arch/powerpc/platforms/512x/mpc5121_ads.c
+++ b/arch/powerpc/platforms/512x/mpc5121_ads.c
@@ -21,6 +21,7 @@
 #include <asm/ipic.h>
 #include <asm/prom.h>
 #include <asm/time.h>
+#include <asm/mpc512x.h>
 #include <sysdev/fsl_soc.h>
 
 #include <sysdev/fsl_pci.h>
@@ -89,6 +90,10 @@ static void __init mpc5121_ads_setup_arch(void)
 		}
 	}
 
+#ifdef CONFIG_PM
+	mpc512x_pm_init();
+#endif
+
 #ifdef CONFIG_PCI
 	for_each_compatible_node(np, "pci", "fsl,mpc5121-pci")
 		mpc83xx_add_bridge(np);
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.c b/arch/powerpc/platforms/512x/mpc512x_pm.c
index 64bc5a0..938c49f 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.c
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.c
@@ -1,5 +1,540 @@
-static int	deep_sleeping;
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Description:
+ * This file contains power management code for MPC5121eADS
+ *
+ * This file is part of the Linux kernel
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/of_platform.h>
+#include <asm/time.h>
+#include <asm/mpc512x.h>
+#include <asm/ipic.h>
+#include <asm/reg.h>
+#include <sysdev/fsl_soc.h>
+
+#include "mpc512x_pm.h"
+
+struct mpc512x_pm mpc512x_pm_data;
+
+static u32 mpc512x_targeted_state = MPC512x_PM_NONE;
+
+/*
+ * Name       : mpc512x_pm_setup
+ * Desc       : This function is called to setup and map the IO region.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static int mpc512x_pm_setup(void)
+{
+	memset(&mpc512x_pm_data, 0, sizeof(mpc512x_pm_data));
+
+	mpc512x_pm_data.mbar = ioremap(get_immrbase(),
+				MPC512x_IMMRBAR_MEM_MAPPED);
+	if (!mpc512x_pm_data.mbar) {
+		printk(KERN_ERR "Error mapping MBAR registers\n");
+		return -1;
+	}
+#ifdef CONFIG_MPC5121_PM_TEST
+	mpc512x_pm_test_setup();
+#endif
+	return 0;
+}
+
+/*
+ * Name       : mpc512x_pm_release
+ * Desc       : This function is called to unmap/release
+ * 		the allocated resources.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_pm_release(void)
+{
+	unsigned long flags;
+
+	if (!mpc512x_pm_data.mbar)
+		return;
+
+	local_irq_save(flags);
+	iounmap(mpc512x_pm_data.mbar);
+	memset(&mpc512x_pm_data, 0, sizeof(mpc512x_pm_data));
+	local_irq_restore(flags);
+}
+
+/*
+ * Name       : mpc512x_sleep
+ * Desc       : This function is called to enter the Sleep mode by setting the
+ *		[SLEEP] bit in HID0 and [POW] bit in MSR.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_sleep(void)
+{
+	u32 hid0, msr;
+
+	/* Enable SLEEP mode and disable the rest */
+	hid0 = mfspr(SPRN_HID0);
+	mtspr(SPRN_HID0, (hid0 & ~(HID0_DOZE | HID0_NAP
+			 | HID0_DPM)) | HID0_SLEEP);
+	asm volatile("isync" : : : "memory");
+	asm volatile("sync" : : : "memory");
+
+	msr = mfmsr();
+	mtmsr(msr | MSR_EE);
+	asm volatile("isync" : : : "memory");
+	asm volatile("sync" : : : "memory");
+
+	/* Enter Sleep mode*/
+	msr = mfmsr();
+	mtmsr(msr | MSR_POW);
+	asm volatile("isync" : : : "memory");
+	asm volatile("sync" : : : "memory");
+
+	msr = mfmsr();
+	mtmsr(msr & ~MSR_EE);
+	asm volatile("isync" : : : "memory");
+	asm volatile("sync" : : : "memory");
+
+	/* Disable sleep modes */
+	hid0 = mfspr(SPRN_HID0);
+	mtspr(SPRN_HID0, (hid0 & ~(HID0_DOZE | HID0_NAP | HID0_SLEEP)));
+	asm volatile("isync" : : : "memory");
+	asm volatile("sync" : : : "memory");
+}
+
+/*
+ * Name       : mpc512x_pmc_clrevent
+ * Desc       : This function needs to be called by the interrupt handlers of
+ * 		the wakeup sources. This is needed since a PMC interrupt is
+ *		not guaranteed on MPC5121 v1.0, while an interrupt from the
+ * 		wakeup source (GPIO / CAN) is.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+void mpc512x_pmc_clrevent(void)
+{
+	struct mpc512x_pmc *pmc;
+
+	if (mpc512x_pm_data.mbar) {
+		pmc = (struct mpc512x_pmc *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_PMC_OFFSET);
+		if (in_be32(&pmc->pmc_er) & 0x1)
+			out_be32(&pmc->pmc_er, 0x1);
+	}
+}
+EXPORT_SYMBOL_GPL(mpc512x_pmc_clrevent);
+
+/*
+ * Name       : mpc512x_set_gpio_wakeup
+ * Desc       : This function would initialise the gpio
+ * 		with the given detection mode and enable the interrupt.
+ *
+ * Parameters :
+ * Return     : int
+ */
+int mpc512x_set_gpio_wakeup(unsigned int gpio_num, unsigned int detect_mode)
+{
+	u32 reg;
+	u32 __iomem *gpio;
+
+	gpio = ioremap((u32)get_immrbase() + MPC512x_IMMRBAR_GPIO_OFFSET,
+			 MPC512x_GPIO_MEM_MAP);
+	if (!gpio) {
+		printk(KERN_ERR "GPIO memory could not be mapped.\n");
+		return -1;
+	}
+	gpio_num = 31 - gpio_num;
+	reg = in_be32(&gpio[MPC512x_GPIO_IMR >> 2]);
+	reg |= 1 << gpio_num;
+	out_be32(&gpio[MPC512x_GPIO_IMR >> 2], reg);
+
+	reg = in_be32(&gpio[MPC512x_GPIO_ICR2 >> 2]);
+	reg &= ~(0x3 << (gpio_num * 2));
+	reg |= ((detect_mode & 3) << (gpio_num * 2));
+	out_be32(&gpio[MPC512x_GPIO_ICR2 >> 2], reg);
+
+	iounmap(gpio);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mpc512x_set_gpio_wakeup);
+
+/*
+ * Name       : mpc512x_pm_valid
+ * Desc       : Checks whether the PM state is valid
+ *
+ * Parameters : void
+ * Return     : 1 - Valid , 0 - Invalid
+ */
+static int mpc512x_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * Name       : mpc512x_pm_settarget
+ * Desc       : Set the state to which the system is to enter.
+ *
+ * Parameters : void
+ * Return     : 0 - Success
+ */
+static int mpc512x_pm_settarget(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		mpc512x_targeted_state = MPC512x_PM_STANDBY;
+		break;
+	case PM_SUSPEND_MEM:
+		mpc512x_targeted_state = MPC512x_PM_SUSP_MEM;
+		break;
+	default:
+		mpc512x_targeted_state = MPC512x_PM_NONE;
+	}
+	return 0;
+}
+
+/*
+ * Name       : mpc512x_set_ipic_regs
+ * Desc       : Save the IPIC Mask registers and enable the wakeup interrupts
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_set_ipic_regs(void)
+{
+	u32 *ipic = (u32 *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_IPIC_OFFSET);
+
+	/* Save the current IPIC mask register values. */
+	mpc512x_pm_data.ipic_simsr_h = in_be32(&ipic[IPIC_SIMSR_H >> 2]);
+	mpc512x_pm_data.ipic_simsr_l = in_be32(&ipic[IPIC_SIMSR_L >> 2]);
+
+	/* Disable all the interrupts except the wakeup sources */
+	out_be32(&ipic[IPIC_SIMSR_H >> 2], MPC512x_IPIC_MSRH_MSCAN1
+					 | MPC512x_IPIC_MSRH_MSCAN2);
+	out_be32(&ipic[IPIC_SIMSR_L >> 2], MPC512x_IPIC_MSRL_RTCSEC |
+					 MPC512x_IPIC_MSRL_PMC |
+					 MPC512x_IPIC_MSRL_GPIO);
+}
+
+/*
+ * Name       : mpc512x_restore_ipic_regs
+ * Desc       : Restore the IPIC Mask registers to original values.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_restore_ipic_regs(void)
+{
+	u32 *ipic = (u32 *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_IPIC_OFFSET);
+
+	/* Restore the IPIC masks to saved values */
+	out_be32(&ipic[IPIC_SIMSR_L >> 2], mpc512x_pm_data.ipic_simsr_l);
+	out_be32(&ipic[IPIC_SIMSR_H >> 2], mpc512x_pm_data.ipic_simsr_h);
+}
+/*
+ * Name       : mpc512x_set_rtc_wakeup
+ * Desc       : This Function would set up the Wake-Up source configurations
+ * in the RTC registers. The RTC interrupts would be generated for GPIO[28-31]
+ * and CAN 1 & 2 receive Interrupts.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_set_rtc_wakeup(void)
+{
+	u32 rtc_reg;
+	u32 *rtc;
+	u32 alm_hr, alm_min, cur_hr, cur_min;
+	int offset_minutes;
+
+	if (!mpc512x_pm_data.mbar)
+		return;
+
+	rtc = (u32 *)((u32)mpc512x_pm_data.mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+
+	rtc_reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+	mpc512x_pm_data.rtc_keepalive = rtc_reg;
+
+	/* Set the Active LVL values for the Wake-up Sources[1-5] */
+	rtc_reg |= MPC512x_RTCKAR_WKUP_SRCLVL;
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], rtc_reg);
+
+	/* Enable the Wake-Up sources and disable Hibernate mode. */
+	rtc_reg |= (MPC512x_RTCKAR_WKUP_SRCEN | MPC512x_RTCKAR_DIS_HIBMODE);
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], rtc_reg);
+
+	/* Set the Target Time Register to a Future Value */
+	mpc512x_pm_data.rtc_targettime = in_be32(&rtc[MPC512x_RTC_TTR >> 2]);
+
+	rtc_reg = in_be32(&rtc[MPC512x_RTC_AIER >> 2]);
+
+	if (rtc_reg & MPC512x_RTCAIER_ALMEN_MASK) {
+		/*Alarm was set.. Let us wakeup in that time..*/
+		alm_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET) & MPC512x_RTC_HR_MASK;
+		alm_min = (rtc_reg >> MPC512x_RTC_MIN_OFFSET) & MPC512x_RTC_MIN_MASK;
+
+		rtc_reg = in_be32(&rtc[MPC512x_RTC_CTR >> 2]);
+		cur_min = (rtc_reg >> MPC512x_RTC_MIN_OFFSET) & MPC512x_RTC_MIN_MASK;
+
+		if (in_be32(&rtc[MPC512x_RTC_TSR >> 2]) & MPC512x_RTCTSR_SLCHR_MASK) {
+			/* 12 Hour Format*/
+			cur_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET) & 0xF;
+			if (rtc_reg & MPC512x_RTC_CTR_PM)
+				cur_hr += 12;
+		} else
+			cur_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET) & MPC512x_RTC_HR_MASK;
+
+		offset_minutes = (alm_hr * MPC512x_RTC_MINS_PER_HR + alm_min) -
+				(cur_hr * MPC512x_RTC_MINS_PER_HR + cur_min);
+
+		if (offset_minutes > 0) {
+			out_be32(&rtc[MPC512x_RTC_TTR >> 2],
+				in_be32(&rtc[MPC512x_RTC_ATR >> 2]) +
+				(offset_minutes * MPC512x_RTC_MINS_PER_HR));
+		} else
+			out_be32(&rtc[MPC512x_RTC_TTR >> 2], MPC512x_RTCTTR_MAXTIMEOUT);
+	} else
+		out_be32(&rtc[MPC512x_RTC_TTR >> 2], MPC512x_RTCTTR_MAXTIMEOUT);
+}
+
+static void mpc512x_restore_rtc_regs(void)
+{
+	u32 *rtc;
+
+	if (!mpc512x_pm_data.mbar)
+		return;
+
+	rtc = (u32 *)((u32)mpc512x_pm_data.mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+
+	/* Restore the RTC Registers */
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2],
+				 mpc512x_pm_data.rtc_keepalive);
+	out_be32(&rtc[MPC512x_RTC_TTR >> 2], mpc512x_pm_data.rtc_targettime);
+}
+
+/*
+ * Name       : mpc512x_set_ddr_selfrefresh
+ * Desc       : Set the DDRC SELFREFRESH registers, to enter and exit
+ *		DDR Self Refresh mode on entering Deep Sleep mode.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_set_ddr_selfrefresh(void)
+{
+	struct ddr512x *ddrc;
+
+	if (!mpc512x_pm_data.mbar)
+		return;
+
+	ddrc = (struct ddr512x *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_DDRC_OFFSET);
+
+	mpc512x_pm_data.ddrc_sysconfig = in_be32(&ddrc->ddr_sys_config);
+
+	/* Write the register contents with SELF-REFRESH EN bit set.*/
+	out_be32(&ddrc->ddr_sys_config,	mpc512x_pm_data.ddrc_sysconfig
+					 | MPC512x_DDRC_SELFREFEN);
+
+	/* Set the Self Refresh Entry Commands */
+	out_be16(&ddrc->self_refresh_cmd_0, MPC512x_DDRC_SELF_REF_CMD0);
+	out_be16(&ddrc->self_refresh_cmd_1, MPC512x_DDRC_SELF_REF_CMD1);
+	out_be16(&ddrc->self_refresh_cmd_2, MPC512x_DDRC_SELF_REF_CMD2);
+	out_be16(&ddrc->self_refresh_cmd_3, MPC512x_DDRC_SELF_REF_CMD3);
+
+	/* Set the Self Refresh Exit Commands */
+	out_be16(&ddrc->self_refresh_cmd_4, MPC512x_DDRC_SELF_REF_CMD4);
+	out_be16(&ddrc->self_refresh_cmd_5, MPC512x_DDRC_SELF_REF_CMD5);
+	out_be16(&ddrc->self_refresh_cmd_6, MPC512x_DDRC_SELF_REF_CMD6);
+	out_be16(&ddrc->self_refresh_cmd_7, MPC512x_DDRC_SELF_REF_CMD7);
+}
+
+static void mpc512x_restore_ddr_regs(void)
+{
+	struct ddr512x *ddrc;
+
+	if (!mpc512x_pm_data.mbar)
+		return;
+
+	ddrc = (struct ddr512x *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_DDRC_OFFSET);
+	out_be32(&ddrc->ddr_sys_config, mpc512x_pm_data.ddrc_sysconfig);
+}
+
+/*
+ * Name       : mpc512x_pm_prepare
+ * Desc       : This function would map the IO regions. Also sets the DDRC and
+ * 		RTC regs for Deep Sleep Mode.
+ *
+ * Parameters : void
+ * Return     : int
+ *		ENOSYS
+ *
+ */
+static int mpc512x_pm_prepare(void)
+{
+	mpc512x_pm_setup();
+
+	switch (mpc512x_targeted_state) {
+	case MPC512x_PM_STANDBY:
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		mpc512x_set_ddr_selfrefresh();
+
+		/*
+		 *  Enable the wakeup sources and set RTC Target Time
+		 *  to future
+		 */
+		mpc512x_set_rtc_wakeup();
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Name       : mpc512x_enter_deepsleep
+ * Desc       : This function puts the MPC5121e system to Deep-Sleep State. The
+ *		Core is first put to sleep. After this the H/W sequencers take
+ *		the system to Deep-Sleep. Before entering the Deep-
+ *		Sleep state the Wake-Up sources are set for GPIO[28-31] and CAN
+ *		1 & 2 receiver interrupts.
+ *
+ * Parameters : void
+ * Return     : int
+ *
+ */
+static int mpc512x_enter_deepsleep(void)
+{
+	struct mpc512x_pmc *pmc;
+
+	/* Enable the GPIO and CAN Interrupts */
+	mpc512x_set_ipic_regs();
+
+	/* Don't let DEC expire any time soon */
+	mtspr(SPRN_DEC, MPC512x_DEC_MAXTIMEOUT);
+
+	pmc = (struct mpc512x_pmc *)((u32)mpc512x_pm_data.mbar +
+					MPC512x_IMMRBAR_PMC_OFFSET);
+	/* Set the DSM, DDROFF & COREOFF bits in PMC CR register.*/
+	out_be32(&pmc->pmc_cr, MPC512x_PMCCR_DSMEN | MPC512x_PMCCR_DDROFF
+				 | MPC512x_PMCCR_COREOFF);
+	out_be32(&pmc->pmc_mr, MPC512x_PMCMR_PMCIE);
+
+	/* Put core to SLEEP so that MPC512x enters Deep-Sleep.*/
+	mpc512x_sleep();
+
+	/* We are out of Deep Sleep.. Lets restart jiffies */
+	wakeup_decrementer();
+
+	/* Reset the PMC CR register. */
+	out_be32(&pmc->pmc_cr, 0x0);
+	out_be32(&pmc->pmc_mr, 0x0);
+
+	/* Restore the IPIC regs to their original values */
+	mpc512x_restore_ipic_regs();
+	return 0;
+}
+
+/*
+ * Name       : mpc512x_pm_enter
+ * Desc       : This function is exported to the Power Management Core. This
+ *	`	function is called with the state which the system should enter.
+ *
+ * Parameters : state 	- PM_SUSPEND_STANDBY
+			- PM_SUSPEND_MEM
+ * Return     : int
+ * 		-1 : FAILED
+ *		0  : SUCCESS
+ */
+static int mpc512x_pm_enter(suspend_state_t state)
+{
+	if (!mpc512x_pm_data.mbar) {
+		printk(KERN_ERR "Failed to enter PM mode as IO not mapped.\n");
+		return -1;
+	}
+
+	switch (mpc512x_targeted_state) {
+	case MPC512x_PM_STANDBY:
+		mpc512x_sleep();
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		mpc512x_enter_deepsleep();
+	default:
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Name       : mpc512x_pm_finish
+ * Desc       : This routine is called by the kernel on exit from
+ * 		power down modes. Restores the DDRC and RTC regs
+ * 		suspend to memory. Also releases allocated resources.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void mpc512x_pm_finish(void)
+{
+	switch (mpc512x_targeted_state) {
+	case MPC512x_PM_STANDBY:
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		/* Restore the DDR and RTC registers on wake-up.*/
+		mpc512x_restore_ddr_regs();
+		mpc512x_restore_rtc_regs();
+		break;
+	}
+	mpc512x_targeted_state = MPC512x_PM_NONE;
+
+	mpc512x_pm_release();
+}
+
+static struct platform_suspend_ops mpc512x_pm_ops = {
+	.valid		= mpc512x_pm_valid,
+	.begin		= mpc512x_pm_settarget,
+	.prepare	= mpc512x_pm_prepare,
+	.enter		= mpc512x_pm_enter,
+	.finish		= mpc512x_pm_finish,
+};
+
+/*
+ * Name       : mpc512x_pm_init
+ * Desc       : This function registers the platform_suspend_ops
+ * 		structure with the kernel.
+ *
+ * Parameters : void
+ * Return     : int
+ */
+int __init mpc512x_pm_init(void)
+{
+	suspend_set_ops(&mpc512x_pm_ops);
+	return 0;
+}
+
 int fsl_deep_sleep(void)
 {
-	return deep_sleeping;
+	if (mpc512x_targeted_state == MPC512x_PM_SUSP_MEM)
+		return 1;
+	return 0;
 }
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.h b/arch/powerpc/platforms/512x/mpc512x_pm.h
new file mode 100644
index 0000000..2eaf4e5
--- /dev/null
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Description:
+ * This file power management code for MPC5121eADS
+ *
+ * This file is part of the Linux kernel
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#ifndef __MPC512x_PM_H__
+#define __MPC512x_PM_H__
+
+/* Peripheral address offsets from IMMRBAR */
+#define MPC512x_IMMRBAR_RTC_OFFSET		0xA00
+#define MPC512x_IMMRBAR_IPIC_OFFSET		0xC00
+#define MPC512x_IMMRBAR_PMC_OFFSET		0x1000
+#define MPC512x_IMMRBAR_GPIO_OFFSET		0x1100
+#define MPC512x_IMMRBAR_DDRC_OFFSET		0x9000
+
+/* Memory mapped by Power management module */
+#define MPC512x_IMMRBAR_MEM_MAPPED		0x10000
+#define MPC512x_GPIO_MEM_MAP			0x100
+
+/* Register offsets for RTC */
+#define MPC512x_RTC_TSR				0x00
+#define MPC512x_RTC_AIER			0x0C
+#define MPC512x_RTC_CTR				0x10
+#define MPC512x_RTC_TTR				0x20
+#define MPC512x_RTC_ATR				0x24
+#define MPC512x_RTC_KEEPALIVE			0x28
+
+/* RTC bit positions and masks*/
+#define MPC512x_RTCTSR_SLCHR_MASK		(1 << 21)
+#define MPC512x_RTCAIER_ALMEN_MASK		(1 << 24)
+#define MPC512x_RTC_CTR_PM			(1 << 20)
+#define MPC512x_RTC_HR_OFFSET			16
+#define MPC512x_RTC_HR_MASK			0x1F
+#define MPC512x_RTC_MIN_OFFSET			8
+#define MPC512x_RTC_MIN_MASK			0x3F
+#define MPC512x_RTC_MINS_PER_HR			60
+
+/* Register offsets for GPIO */
+#define MPC512x_GPIO_IMR			0x10
+#define MPC512x_GPIO_ICR2			0x18
+
+/* Bit positions in IPIC memory region */
+#define MPC512x_IPIC_MSRH_MSCAN1		(1 << 4)
+#define MPC512x_IPIC_MSRH_MSCAN2		(1 << 3)
+
+#define MPC512x_IPIC_MSRL_GPIO			(1 << 17)
+#define MPC512x_IPIC_MSRL_RTCSEC		(1 << 16)
+#define MPC512x_IPIC_MSRL_RTCALRM		(1 << 15)
+#define MPC512x_IPIC_MSRL_PMC			(1 << 12)
+
+/* Bit positions in PMC memory region */
+#define MPC512x_PMCCR_DSMEN			(1 << 2)
+#define MPC512x_PMCCR_DDROFF			(1 << 1)
+#define MPC512x_PMCCR_COREOFF			(1 << 0)
+#define MPC512x_PMCMR_PMCIE			(1 << 0)
+
+/* Bit positions in DDRC memory region */
+#define MPC512x_DDRC_SELFREFEN			(1 << 18)
+
+/* DDRC commands to set the DRAM in and out of Self Refresh */
+/* These commands have worked on the MPC5121ADS board */
+#define MPC512x_DDRC_SELF_REF_CMD0		0x3C00
+#define MPC512x_DDRC_SELF_REF_CMD1		0x4420
+#define MPC512x_DDRC_SELF_REF_CMD2		0x4210
+#define MPC512x_DDRC_SELF_REF_CMD3		0x1410
+
+#define MPC512x_DDRC_SELF_REF_CMD4		0x1C00
+#define MPC512x_DDRC_SELF_REF_CMD5		0x3C08
+#define MPC512x_DDRC_SELF_REF_CMD6		0x4200
+#define MPC512x_DDRC_SELF_REF_CMD7		0x3800
+
+/* RTC Keep alive register values*/
+#define MPC512x_RTCKAR_WKUP_SRCLVL		0x001F0000
+#define MPC512x_RTCKAR_WKUP_SRCEN		0x1F000000
+#define MPC512x_RTCKAR_DIS_HIBMODE		0x00000080
+
+/* RTC Target Time register Timeout*/
+#define MPC512x_RTCTTR_MAXTIMEOUT		0xFFFFFFFF
+
+/* Decrementer timeout */
+#define MPC512x_DEC_MAXTIMEOUT			0x7FFFFFFF
+
+/* Power Management states */
+#define MPC512x_PM_NONE				0
+#define MPC512x_PM_STANDBY			1
+#define MPC512x_PM_SUSP_MEM			2
+
+/* PMC registers*/
+struct mpc512x_pmc {
+	u32 pmc_cr;		/* Configuration register - 0x00 */
+	u32 pmc_er;		/* Event register	  - 0x04 */
+	u32 pmc_mr;		/* Mask register	  - 0x08 */
+	u32 pmc_sr;		/* Shadow register	  - 0x0C */
+};
+
+/* Data structure used by the Power management module */
+struct mpc512x_pm{
+
+	/* Pointer to IMMRBAR (ioremaped) */
+	void __iomem *mbar;
+
+	/* Registers saved/restored by PM module */
+	u32 ipic_simsr_l;
+	u32 ipic_simsr_h;
+	u32 rtc_keepalive;
+	u32 rtc_targettime;
+	u32 ddrc_sysconfig;
+};
+
+#endif /* __MPC512x_PM_H__ */
-- 
1.6.0.2.GIT

