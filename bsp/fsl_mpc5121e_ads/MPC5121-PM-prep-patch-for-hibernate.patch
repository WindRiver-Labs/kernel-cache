From f067a443be9dd3b49f07e5018e3f2a9c0b48d8e2 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:34 +0800
Subject: [PATCH 18/25] MPC5121 PM: prep patch for hibernate

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

This patch makes the changes to mpc512x_pm.c to make the Deep Sleep
code useable from ads5121_pm.c (for hibernate) as well.

Also cleanup some formatting issues.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/mpc512x_pm.c |  143 ++++++++++++++++--------------
 arch/powerpc/platforms/512x/mpc512x_pm.h |   10 ++
 2 files changed, 85 insertions(+), 68 deletions(-)

diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.c b/arch/powerpc/platforms/512x/mpc512x_pm.c
index 267d97f..7e05951 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.c
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.c
@@ -25,23 +25,21 @@
 #include "mpc512x_pm.h"
 
 struct mpc512x_pm mpc512x_pm_data;
-
 static u32 mpc512x_targeted_state = MPC512x_PM_NONE;
 
 /*
  * Name       : mpc512x_pm_setup
  * Desc       : This function is called to setup and map the IO region.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static int mpc512x_pm_setup(void)
+int mpc512x_pm_setup(struct mpc512x_pm *p_pmdata)
 {
-	memset(&mpc512x_pm_data, 0, sizeof(mpc512x_pm_data));
+	memset(p_pmdata, 0, sizeof(struct mpc512x_pm));
 
-	mpc512x_pm_data.mbar = ioremap(get_immrbase(),
-				MPC512x_IMMRBAR_MEM_MAPPED);
-	if (!mpc512x_pm_data.mbar) {
+	p_pmdata->mbar = ioremap(get_immrbase(), MPC512x_IMMRBAR_MEM_MAPPED);
+	if (!p_pmdata->mbar) {
 		printk(KERN_ERR "Error mapping MBAR registers\n");
 		return -1;
 	}
@@ -53,22 +51,21 @@ static int mpc512x_pm_setup(void)
 
 /*
  * Name       : mpc512x_pm_release
- * Desc       : This function is called to unmap/release
- * 		the allocated resources.
+ * Desc       : This is called to unmap/release the allocated resources.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static void mpc512x_pm_release(void)
+void mpc512x_pm_release(struct mpc512x_pm *p_pmdata)
 {
 	unsigned long flags;
 
-	if (!mpc512x_pm_data.mbar)
+	if (!p_pmdata->mbar)
 		return;
 
 	local_irq_save(flags);
-	iounmap(mpc512x_pm_data.mbar);
-	memset(&mpc512x_pm_data, 0, sizeof(mpc512x_pm_data));
+	iounmap(p_pmdata->mbar);
+	memset(p_pmdata, 0, sizeof(struct mpc512x_pm));
 	local_irq_restore(flags);
 }
 
@@ -192,17 +189,17 @@ static int mpc512x_pm_settarget(suspend_state_t state)
  * Name       : mpc512x_set_ipic_regs
  * Desc       : Save the IPIC Mask registers and enable the wakeup interrupts
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static void mpc512x_set_ipic_regs(void)
+static void mpc512x_set_ipic_regs(struct mpc512x_pm *p_pmdata)
 {
-	u32 *ipic = (u32 *)((u32)mpc512x_pm_data.mbar +
-					MPC512x_IMMRBAR_IPIC_OFFSET);
+	u32 *ipic = (u32 *)((u32)p_pmdata->mbar +
+			MPC512x_IMMRBAR_IPIC_OFFSET);
 
 	/* Save the current IPIC mask register values. */
-	mpc512x_pm_data.ipic_simsr_h = in_be32(&ipic[IPIC_SIMSR_H >> 2]);
-	mpc512x_pm_data.ipic_simsr_l = in_be32(&ipic[IPIC_SIMSR_L >> 2]);
+	p_pmdata->ipic_simsr_h = in_be32(&ipic[IPIC_SIMSR_H >> 2]);
+	p_pmdata->ipic_simsr_l = in_be32(&ipic[IPIC_SIMSR_L >> 2]);
 
 	/* Disable all the interrupts except the wakeup sources */
 	out_be32(&ipic[IPIC_SIMSR_H >> 2], MPC512x_IPIC_MSRH_MSCAN1
@@ -216,17 +213,17 @@ static void mpc512x_set_ipic_regs(void)
  * Name       : mpc512x_restore_ipic_regs
  * Desc       : Restore the IPIC Mask registers to original values.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static void mpc512x_restore_ipic_regs(void)
+static void mpc512x_restore_ipic_regs(struct mpc512x_pm *p_pmdata)
 {
-	u32 *ipic = (u32 *)((u32)mpc512x_pm_data.mbar +
-					MPC512x_IMMRBAR_IPIC_OFFSET);
+	u32 *ipic = (u32 *)((u32)p_pmdata->mbar +
+			MPC512x_IMMRBAR_IPIC_OFFSET);
 
 	/* Restore the IPIC masks to saved values */
-	out_be32(&ipic[IPIC_SIMSR_L >> 2], mpc512x_pm_data.ipic_simsr_l);
-	out_be32(&ipic[IPIC_SIMSR_H >> 2], mpc512x_pm_data.ipic_simsr_h);
+	out_be32(&ipic[IPIC_SIMSR_L >> 2], p_pmdata->ipic_simsr_l);
+	out_be32(&ipic[IPIC_SIMSR_H >> 2], p_pmdata->ipic_simsr_h);
 }
 /*
  * Name       : mpc512x_set_rtc_wakeup
@@ -234,23 +231,23 @@ static void mpc512x_restore_ipic_regs(void)
  * in the RTC registers. The RTC interrupts would be generated for GPIO[28-31]
  * and CAN 1 & 2 receive Interrupts.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static void mpc512x_set_rtc_wakeup(void)
+static void mpc512x_set_rtc_wakeup(struct mpc512x_pm *p_pmdata)
 {
 	u32 rtc_reg;
 	u32 *rtc;
 	u32 alm_hr, alm_min, cur_hr, cur_min;
 	int offset_minutes;
 
-	if (!mpc512x_pm_data.mbar)
+	if (!p_pmdata->mbar)
 		return;
 
-	rtc = (u32 *)((u32)mpc512x_pm_data.mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+	rtc = (u32 *)((u32)p_pmdata->mbar + MPC512x_IMMRBAR_RTC_OFFSET);
 
 	rtc_reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
-	mpc512x_pm_data.rtc_keepalive = rtc_reg;
+	p_pmdata->rtc_keepalive = rtc_reg;
 
 	/* Set the Active LVL values for the Wake-up Sources[1-5] */
 	rtc_reg |= MPC512x_RTCKAR_WKUP_SRCLVL;
@@ -261,7 +258,7 @@ static void mpc512x_set_rtc_wakeup(void)
 	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], rtc_reg);
 
 	/* Set the Target Time Register to a Future Value */
-	mpc512x_pm_data.rtc_targettime = in_be32(&rtc[MPC512x_RTC_TTR >> 2]);
+	p_pmdata->rtc_targettime = in_be32(&rtc[MPC512x_RTC_TTR >> 2]);
 
 	rtc_reg = in_be32(&rtc[MPC512x_RTC_AIER >> 2]);
 
@@ -294,19 +291,19 @@ static void mpc512x_set_rtc_wakeup(void)
 		out_be32(&rtc[MPC512x_RTC_TTR >> 2], MPC512x_RTCTTR_MAXTIMEOUT);
 }
 
-static void mpc512x_restore_rtc_regs(void)
+static void mpc512x_restore_rtc_regs(struct mpc512x_pm *p_pmdata)
 {
 	u32 *rtc;
 
-	if (!mpc512x_pm_data.mbar)
+	if (!p_pmdata->mbar)
 		return;
 
-	rtc = (u32 *)((u32)mpc512x_pm_data.mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+	rtc = (u32 *)((u32)p_pmdata->mbar + MPC512x_IMMRBAR_RTC_OFFSET);
 
 	/* Restore the RTC Registers */
 	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2],
-				 mpc512x_pm_data.rtc_keepalive);
-	out_be32(&rtc[MPC512x_RTC_TTR >> 2], mpc512x_pm_data.rtc_targettime);
+				 p_pmdata->rtc_keepalive);
+	out_be32(&rtc[MPC512x_RTC_TTR >> 2], p_pmdata->rtc_targettime);
 }
 
 /*
@@ -314,24 +311,24 @@ static void mpc512x_restore_rtc_regs(void)
  * Desc       : Set the DDRC SELFREFRESH registers, to enter and exit
  *		DDR Self Refresh mode on entering Deep Sleep mode.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : void
  */
-static void mpc512x_set_ddr_selfrefresh(void)
+static void mpc512x_set_ddr_selfrefresh(struct mpc512x_pm *p_pmdata)
 {
 	struct ddr512x *ddrc;
 
-	if (!mpc512x_pm_data.mbar)
+	if (!p_pmdata->mbar)
 		return;
 
-	ddrc = (struct ddr512x *)((u32)mpc512x_pm_data.mbar +
-					MPC512x_IMMRBAR_DDRC_OFFSET);
+	ddrc = (struct ddr512x *)((u32)p_pmdata->mbar +
+				MPC512x_IMMRBAR_DDRC_OFFSET);
 
-	mpc512x_pm_data.ddrc_sysconfig = in_be32(&ddrc->ddr_sys_config);
+	p_pmdata->ddrc_sysconfig = in_be32(&ddrc->ddr_sys_config);
 
 	/* Write the register contents with SELF-REFRESH EN bit set.*/
-	out_be32(&ddrc->ddr_sys_config,	mpc512x_pm_data.ddrc_sysconfig
-					 | MPC512x_DDRC_SELFREFEN);
+	out_be32(&ddrc->ddr_sys_config,	p_pmdata->ddrc_sysconfig
+			| MPC512x_DDRC_SELFREFEN);
 
 	/* Set the Self Refresh Entry Commands */
 	out_be16(&ddrc->self_refresh_cmd_0, MPC512x_DDRC_SELF_REF_CMD0);
@@ -346,16 +343,34 @@ static void mpc512x_set_ddr_selfrefresh(void)
 	out_be16(&ddrc->self_refresh_cmd_7, MPC512x_DDRC_SELF_REF_CMD7);
 }
 
-static void mpc512x_restore_ddr_regs(void)
+static void mpc512x_restore_ddr_regs(struct mpc512x_pm *p_pmdata)
+
 {
 	struct ddr512x *ddrc;
 
-	if (!mpc512x_pm_data.mbar)
+	if (!p_pmdata->mbar)
 		return;
+	ddrc = (struct ddr512x *)((u32)p_pmdata->mbar +
+				MPC512x_IMMRBAR_DDRC_OFFSET);
+	out_be32(&ddrc->ddr_sys_config, p_pmdata->ddrc_sysconfig);
+}
+
+void mpc512x_prepare_deepsleep(struct mpc512x_pm *p_pmdata)
+{
+	mpc512x_set_ddr_selfrefresh(p_pmdata);
 
-	ddrc = (struct ddr512x *)((u32)mpc512x_pm_data.mbar +
-					MPC512x_IMMRBAR_DDRC_OFFSET);
-	out_be32(&ddrc->ddr_sys_config, mpc512x_pm_data.ddrc_sysconfig);
+	/*
+	 *  Enable the wakeup sources and set RTC Target Time
+	 *  to future
+	 */
+	mpc512x_set_rtc_wakeup(p_pmdata);
+}
+
+void mpc512x_finish_deepsleep(struct mpc512x_pm *p_pmdata)
+{
+	/* Restore the DDR and RTC registers on wake-up.*/
+	mpc512x_restore_ddr_regs(p_pmdata);
+	mpc512x_restore_rtc_regs(p_pmdata);
 }
 
 /*
@@ -370,17 +385,11 @@ static void mpc512x_restore_ddr_regs(void)
  */
 static int mpc512x_pm_prepare(void)
 {
-	mpc512x_pm_setup();
+	mpc512x_pm_setup(&mpc512x_pm_data);
 
 	switch (mpc512x_targeted_state) {
 	case MPC512x_PM_STANDBY:
-		mpc512x_set_ddr_selfrefresh();
-
-		/*
-		 *  Enable the wakeup sources and set RTC Target Time
-		 *  to future
-		 */
-		mpc512x_set_rtc_wakeup();
+		mpc512x_prepare_deepsleep(&mpc512x_pm_data);
 		break;
 	case MPC512x_PM_SUSP_MEM:
 		break;
@@ -396,21 +405,21 @@ static int mpc512x_pm_prepare(void)
  *		Sleep state the Wake-Up sources are set for GPIO[28-31] and CAN
  *		1 & 2 receiver interrupts.
  *
- * Parameters : void
+ * Parameters : struct mpc512x_pm *p_pmdata
  * Return     : int
  *
  */
-static int mpc512x_enter_deepsleep(void)
+int mpc512x_enter_deepsleep(struct mpc512x_pm *p_pmdata)
 {
 	struct mpc512x_pmc *pmc;
 
 	/* Enable the GPIO and CAN Interrupts */
-	mpc512x_set_ipic_regs();
+	mpc512x_set_ipic_regs(p_pmdata);
 
 	/* Don't let DEC expire any time soon */
 	mtspr(SPRN_DEC, MPC512x_DEC_MAXTIMEOUT);
 
-	pmc = (struct mpc512x_pmc *)((u32)mpc512x_pm_data.mbar +
+	pmc = (struct mpc512x_pmc *)((u32)p_pmdata->mbar +
 					MPC512x_IMMRBAR_PMC_OFFSET);
 	/* Set the DSM, DDROFF & COREOFF bits in PMC CR register.*/
 	out_be32(&pmc->pmc_cr, MPC512x_PMCCR_DSMEN | MPC512x_PMCCR_DDROFF
@@ -436,7 +445,7 @@ static int mpc512x_enter_deepsleep(void)
 	out_be32(&pmc->pmc_mr, 0x0);
 
 	/* Restore the IPIC regs to their original values */
-	mpc512x_restore_ipic_regs();
+	mpc512x_restore_ipic_regs(p_pmdata);
 	return 0;
 }
 
@@ -460,7 +469,7 @@ static int mpc512x_pm_enter(suspend_state_t state)
 
 	switch (mpc512x_targeted_state) {
 	case MPC512x_PM_STANDBY:
-		mpc512x_enter_deepsleep();
+		mpc512x_enter_deepsleep(&mpc512x_pm_data);
 		break;
 	case MPC512x_PM_SUSP_MEM:
 		printk(KERN_ERR "Suspend to RAM not implemented\n");
@@ -484,16 +493,14 @@ static void mpc512x_pm_finish(void)
 {
 	switch (mpc512x_targeted_state) {
 	case MPC512x_PM_STANDBY:
-		/* Restore the DDR and RTC registers on wake-up.*/
-		mpc512x_restore_ddr_regs();
-		mpc512x_restore_rtc_regs();
+		mpc512x_finish_deepsleep(&mpc512x_pm_data);
 		break;
 	case MPC512x_PM_SUSP_MEM:
 		break;
 	}
 	mpc512x_targeted_state = MPC512x_PM_NONE;
 
-	mpc512x_pm_release();
+	mpc512x_pm_release(&mpc512x_pm_data);
 }
 
 static struct platform_suspend_ops mpc512x_pm_ops = {
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.h b/arch/powerpc/platforms/512x/mpc512x_pm.h
index 2ee1181..06867bf 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.h
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.h
@@ -117,7 +117,17 @@ struct mpc512x_pm{
 	u32 ddrc_sysconfig;
 };
 
+int mpc512x_pm_setup(struct mpc512x_pm *p_pmdata);
+void mpc512x_pm_release(struct mpc512x_pm *p_pmdata);
+void mpc512x_prepare_deepsleep(struct mpc512x_pm *p_pmdata);
+int mpc512x_enter_deepsleep(struct mpc512x_pm *p_pmdata);
+void mpc512x_finish_deepsleep(struct mpc512x_pm *p_pmdata);
+
 extern void mpc5121_copy_pmcclr(void);
 extern void mpc5121_reinstall_handler(void);
 
+#ifdef CONFIG_MPC5121_PM_TEST
+extern void mpc512x_pm_test_setup(void);
+#endif
+
 #endif /* __MPC512x_PM_H__ */
-- 
1.6.3.1

