From b3a8f69b8eee5821d68895da58d9f92d1b050010 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:45:59 +0800
Subject: [PATCH] ASoC sound driver for MPC5121ADS with an AC97 codec

New files:
sound/soc/fsl/mpc5121_ac97.c
    Platform dependent code for accessing ac97 registers.
sound/soc/fsl/mpc5121_ads.c
    MPC5121eADS fabric driver
sound/soc/fsl/mpc5121_pcm.c
    MPC5121eADS DMA driver
sound/soc/fsl/mpc5121_pcm.h
    Defines interface between fabric driver and pcm driver
sound/soc/fsl/mpc5121_psc.c
    MPC5121 SOC (PSC) driver
sound/soc/fsl/mpc5121_psc_info.h
    Defines interface between fabric driver and psc driver

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 sound/soc/fsl/Kconfig            |   32 ++
 sound/soc/fsl/Makefile           |    6 +
 sound/soc/fsl/mpc5121_ac97.c     |  171 +++++++++++
 sound/soc/fsl/mpc5121_ads.c      |  388 ++++++++++++++++++++++++
 sound/soc/fsl/mpc5121_pcm.c      |  435 ++++++++++++++++++++++++++
 sound/soc/fsl/mpc5121_pcm.h      |   32 ++
 sound/soc/fsl/mpc5121_psc.c      |  619 ++++++++++++++++++++++++++++++++++++++
 sound/soc/fsl/mpc5121_psc_info.h |   88 ++++++
 8 files changed, 1771 insertions(+), 0 deletions(-)
 create mode 100644 sound/soc/fsl/mpc5121_ac97.c
 create mode 100644 sound/soc/fsl/mpc5121_ads.c
 create mode 100644 sound/soc/fsl/mpc5121_pcm.c
 create mode 100644 sound/soc/fsl/mpc5121_pcm.h
 create mode 100644 sound/soc/fsl/mpc5121_psc.c
 create mode 100644 sound/soc/fsl/mpc5121_psc_info.h

diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index 3368ace..ffbe96f 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -14,3 +14,35 @@ config SND_SOC_MPC8610_HPCD
 	default y if MPC8610_HPCD
 	help
 	  Say Y if you want to enable audio on the Freescale MPC8610 HPCD.
+
+config SND_SOC_MPC5121
+	bool "ALSA SoC support for the MPC5121 SOC"
+	depends on SND_SOC && PPC_MPC512x
+	default y if PPC_MPC512x
+	help
+	  Say Y if you want to add support for codecs attached to a PSC running
+	  in I2S/AC97 mode on an MPC5121
+
+choice
+	prompt "ADS5121 Codec Type"
+	depends on SND_SOC_MPC5121
+	default SND_SOC_MPC5121_ADS
+
+config SND_SOC_MPC5121_ADS
+	bool "ADS5121 board with AC97 codec"
+	select SND_SOC_AC97_CODEC
+        select SND_AC97_CODEC
+	help
+	  Say Y if you want to enable audio using the LM4550B AC97 codec on a
+	  MPC5121ADS, please check your hardware to learn which type of codec
+	  is used, and describe it correctly in device tree.
+
+config SND_SOC_MPC5121_I2S
+	bool "ADS5121 board with AD1938 I2S codec"
+        select SND_SOC_AD1939
+	help
+	  Say Y if you want to enable audio using the AD1938 I2S codec on a
+	  modified MPC5121ADS board.
+
+endchoice
+
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index 62f680a..9210a53 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -4,3 +4,9 @@ obj-$(CONFIG_SND_SOC_MPC8610_HPCD) += mpc8610_hpcd.o
 # MPC8610 Platform Support
 obj-$(CONFIG_SND_SOC_MPC8610) += fsl_ssi.o fsl_dma.o
 
+# MPC5121 ADS Machine Support
+obj-$(CONFIG_SND_SOC_MPC5121_ADS) += mpc5121_ads.o mpc5121_ac97.o
+
+# MPC5121 Platform Support
+obj-$(CONFIG_SND_SOC_MPC5121) += mpc5121_psc.o mpc5121_pcm.o
+
diff --git a/sound/soc/fsl/mpc5121_ac97.c b/sound/soc/fsl/mpc5121_ac97.c
new file mode 100644
index 0000000..61dc3db
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_ac97.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2007,2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  Freescale AC97 SoC device driver for CPU MPC5121
+ *
+ *  Author: Hongjun Chen <hong-jun.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/delay.h>
+#include <linux/mutex.h>
+#include <sound/ac97_codec.h>
+#include <sound/soc.h>
+#include <asm/mpc52xx_psc.h>
+#include "mpc5121_psc_info.h"
+
+/* AC97CMD register bit definitions */
+#define	RD_FLG  		(1 << 31)
+#define	CTRL_REG_INDEX(reg) 	(reg << 24)
+#define	CMD_DATA(data)	 	(data << 8)
+#define RD_CMD(reg, data) 	(RD_FLG | CTRL_REG_INDEX(reg) | CMD_DATA(data))
+#define	WR_CMD(reg, data) 	(CTRL_REG_INDEX(reg) | CMD_DATA(data))
+
+/* SR(status register) bit definitions */
+enum {
+	UNEX_RX_SLOT = (1 << 0),
+	DATA_VALID = (1 << 1),
+	DATA_OVR = (1 << 2),
+	CMD_SEND = (1 << 3),
+	ERR_PSC = (1 << 6),
+	UNDER_RUN_ERR = (1 << 11),
+	OVER_RUN_ERR = (1 << 12),
+};
+
+static DEFINE_MUTEX(car_mutex);
+
+unsigned short mpc5121_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
+{
+	unsigned short val = 0;
+	struct mpc52xx_psc *psc_reg;
+	u32 temp, r, v;
+	int timeout = 5000;
+	int retries = 10;
+
+	/* For mysterious cause, this delay time is needed to right
+	 * access of codec's register
+	 */
+	udelay(40);
+	mutex_lock(&car_mutex);
+
+	psc_reg = psc_reg_priv;
+
+	/* Make sure status data register is empty */
+	while (in_be16(&psc_reg->sr_csr.status) & DATA_VALID)
+		temp = in_be32(&psc_reg->ac97_data);
+
+	/* Write READ register command in slot0 and 1 */
+	out_be32(&psc_reg->ac97_cmd, RD_CMD(reg, val));
+
+	/* Wait for the transmission to complete */
+	do {
+		temp = in_be16(&psc_reg->sr_csr.status);
+	} while ((temp & CMD_SEND) && timeout--);
+
+	if (timeout <= 0) {
+		printk(KERN_ERR "Err: timeout on slot 1 TX busy\n");
+		temp = ~0;
+		goto out;
+	}
+
+	/*
+	 * Give the AC'97 codec more than enough time
+	 * to respond. (42us = ~2 frames at 48kHz.)
+	 */
+	udelay(42);
+
+	/* Wait for data */
+	timeout = 80000;
+	do {
+		cond_resched();
+		temp = in_be16(&psc_reg->sr_csr.status);
+	} while (!(temp & DATA_VALID) && timeout--);
+
+	if (timeout <= 0 && !(temp & DATA_VALID)) {
+		printk(KERN_ERR "Err: timeout on RX valid\n");
+		temp = ~0;
+		goto out;
+	}
+
+	do {
+		temp = in_be32(&psc_reg->ac97_data);
+		r = (temp >> 24) & 0x7f;
+		v = (temp >> 8) & 0xffff;
+		if (r == reg) {
+			temp = v;
+			break;
+		} else if (--retries) {
+			printk(KERN_ERR "ac97 read back fail.  retry\n");
+			printk(KERN_ERR "%s, ac97_data = 0x%08x\n",
+				__func__, temp);
+			continue;
+		} else {
+			printk(KERN_ERR "wrong ac97 register read back "
+				"(%x != %x)\n",
+			       r, reg);
+			temp = ~0;
+		}
+	} while (retries);
+
+out:
+	mutex_unlock(&car_mutex);
+	return temp;
+}
+
+void mpc5121_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+			unsigned short val)
+{
+	struct mpc52xx_psc *psc_reg;
+	int timeout = 5000;
+	u32 temp;
+
+	/* For mysterious cause, this delay time is needed to right
+	 * access of codec's register
+	 */
+	udelay(40);
+	mutex_lock(&car_mutex);
+
+	psc_reg = psc_reg_priv;
+
+	/* Write READ register command in slot0 and 1 */
+	psc_reg->ac97_cmd = WR_CMD(reg, val);
+
+	/*
+	 * Wait for the transmission of both slots to complete.
+	 */
+	do {
+		temp = psc_reg->sr_csr.status;
+	} while ((temp & CMD_SEND) && timeout--);
+
+	if (!timeout)
+		printk(KERN_ERR "timeout waiting for write to complete\n");
+
+	mutex_unlock(&car_mutex);
+}
+
+void mpc5121_ac97_reset(struct snd_ac97 *ac97)
+{
+	/* Initialize necessary registers of codec */
+	mpc5121_ac97_write(ac97, 0, 0x0000);
+
+	/* master channels: No attenuation */
+	mpc5121_ac97_write(ac97, 2, 0x1f1f);
+	mpc5121_ac97_write(ac97, 0x18, 0x0000);
+	mpc5121_ac97_write(ac97, 0x2a, 0x01); /* unlock VAR */
+	mpc5121_ac97_write(ac97, 0x2c, 0xbb80); /* 48KH */
+
+	mpc5121_ac97_write(ac97, 0x1c, 0x0); /*R/L 22.5dB gain*/
+	mpc5121_ac97_write(ac97, 0x1e, 0x0); /*R/L 22.5dB gain2*/
+	mpc5121_ac97_write(ac97, 0x1a, 0x0); /* Capture MIC */
+}
+EXPORT_SYMBOL_GPL(mpc5121_ac97_reset);
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read = mpc5121_ac97_read,
+	.write = mpc5121_ac97_write,
+};
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
diff --git a/sound/soc/fsl/mpc5121_ads.c b/sound/soc/fsl/mpc5121_ads.c
new file mode 100644
index 0000000..a2c41d3
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_ads.c
@@ -0,0 +1,388 @@
+/*
+ * Freescale MPC5121ADS SoC Fabric driver
+ *
+ * Copyright 2008 Freescale Semiconductor Inc.
+ * Author: John Rigby jrigby@freescale.com
+ *
+ * Originally based on mpc8610_hpcd.c:
+ *    Freescale MPC8610HPCD ALSA SoC Fabric driver
+ *    Author: Timur Tabi <timur@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without
+ * any warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <sound/soc.h>
+
+#include <asm/of_device.h>
+#include <asm/of_platform.h>
+#include <asm/mpc52xx_psc.h>
+
+#include "../codecs/ac97.h"
+#include "mpc5121_psc_info.h"
+#include "mpc5121_pcm.h"
+
+struct mpc52xx_psc *psc_reg_priv;
+
+
+/**
+ * mpc5121_ads_startup: program the board with various hardware parameters
+ *
+ * This function takes board-specific information, like clock frequencies
+ * and serial data formats, and passes that information to the codec and
+ * transport drivers.
+ */
+static int mpc5121_ads_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	struct mpc5121_ads_data *machine_data = rtd->socdev->dev->platform_data;
+	int ret = 0;
+
+	/* Tell the CPU driver what the serial protocol is. */
+	if (cpu_dai->dai_ops.set_fmt) {
+		ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+					       machine_data->dai_format);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set CPU driver audio format\n");
+			return ret;
+		}
+	}
+
+	/* Tell the codec driver what the serial protocol is. */
+	if (codec_dai->dai_ops.set_fmt) {
+		ret = codec_dai->dai_ops.set_fmt(codec_dai,
+						 machine_data->dai_format);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set codec driver audio format\n");
+			return ret;
+		}
+	}
+
+	/*
+	 * Tell the CPU driver what the clock frequency is, and whether it's a
+	 * slave or master.
+	 */
+	if (cpu_dai->dai_ops.set_sysclk) {
+		ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, 0,
+						  machine_data->clk_frequency,
+						  machine_data->
+						  cpu_clk_direction);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set CPU driver clock parameters\n");
+			return ret;
+		}
+	}
+
+	/*
+	 * Tell the codec driver what the MCLK frequency is, and whether it's
+	 * a slave or master.
+	 */
+	if (codec_dai->dai_ops.set_sysclk) {
+		ret = codec_dai->dai_ops.set_sysclk(codec_dai, 0,
+						    machine_data->clk_frequency,
+						    machine_data->
+						    codec_clk_direction);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set codec driver clock params\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * mpc5121_ads_ops: ASoC fabric driver operations
+ */
+static struct snd_soc_ops mpc5121_ads_ops = {
+	.startup = mpc5121_ads_startup,
+};
+
+/**
+ * mpc5121_ads_machine: ASoC machine data
+ */
+static struct snd_soc_machine mpc5121_ads_machine = {
+	.name = "MPC5121 ADS",
+	.num_links = 1,
+};
+
+/**
+ * mpc5121_ads_probe: OF probe function for the fabric driver
+ *
+ * This function gets called when fsl,mpc5121-psc-ac97 node
+ * is found in the device tree.
+ */
+static int mpc5121_ads_probe(struct of_device *ofdev,
+			     const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node;
+	struct device_node *codec_np = NULL;
+	const char *sprop;
+	const u32 *iprop;
+	struct resource res;
+	struct platform_device *sound_device = NULL;
+	struct mpc5121_ads_data *machine_data;
+	struct mpc5121_psc_info *psc_info;
+	struct mpc512x_dma_config dma_config;
+	int ret = -ENODEV;
+
+	machine_data = kzalloc(sizeof(struct mpc5121_ads_data), GFP_KERNEL);
+	if (!machine_data)
+		return -ENOMEM;
+
+	psc_info = &machine_data->psc_info;
+	psc_info->dev = &ofdev->dev;
+
+	/*
+	 * Get the device ID
+	 */
+	iprop = of_get_property(np, "cell-index", NULL);
+	if (!iprop) {
+		dev_err(&ofdev->dev, "cell-index property not found\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	psc_info->id = *iprop;
+
+	/* Get the serial format and clock direction. */
+	sprop = of_get_property(np, "fsl,mode", NULL);
+	if (!sprop) {
+		dev_err(&ofdev->dev, "fsl,mode property not found\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* This driver is for ADS5121 which only has AC97 */
+	if (strcasecmp(sprop, "ac97-slave")) {
+		dev_err(&ofdev->dev,
+			"unrecognized fsl,mode property \"%s\"\n", sprop);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	machine_data->dai_format = SND_SOC_DAIFMT_AC97;
+	machine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;
+	machine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;
+	machine_data->clk_frequency = 24576000;
+
+	/* Read the PSC information from the device tree */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&ofdev->dev, "could not obtain PSC address\n");
+		goto error;
+	}
+
+	if (!res.start) {
+		dev_err(&ofdev->dev, "invalid PSC address\n");
+		goto error;
+	}
+	psc_info->phys = res.start;
+	psc_info->psc = ioremap(psc_info->phys, res.end - res.start + 1);
+	psc_reg_priv = psc_info->psc;
+	if (!psc_info->psc) {
+		dev_err(&ofdev->dev, "could not map PSC address %x\n",
+			psc_info->phys);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* Get the IRQ of the PSC */
+	psc_info->irq = irq_of_parse_and_map(np, 0);
+	if (!psc_info->irq) {
+		dev_err(&ofdev->dev, "could not get PSC IRQ\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+#define PSC_DMA_GRAN 64
+	/*
+	 * FIXME put this in the device tree
+	 *
+	 * DMA channels are dedicated:
+	 * 	rx = psc number
+	 * 	tx = psc number + 12.
+	 *
+	 * DMA granularity is PSC_DMA_GRAN bytes
+	 *
+	 * PSC FIFO data register are at
+	 * 	rx offset is 0xfc
+	 * 	tx offset is 0xbc
+	 */
+	dma_config.rx_dma_ch_nr = psc_info->id;
+	dma_config.tx_dma_ch_nr = psc_info->id + 12;
+	psc_info->rx_dma_gran = PSC_DMA_GRAN;
+	psc_info->tx_dma_gran = PSC_DMA_GRAN;
+	dma_config.rx_dma_gran = PSC_DMA_GRAN;
+	dma_config.tx_dma_gran = PSC_DMA_GRAN;
+	dma_config.rx_dev_addr = psc_info->phys + 0xfc;
+	dma_config.tx_dev_addr = psc_info->phys + 0xbc;
+	if (!mpc512x_dma_configure(&dma_config)) {
+		dev_err(&ofdev->dev, "could not configure DMA device\n");
+		ret = -EBUSY;
+		goto error;
+	}
+
+	/*
+	 * Initialize our DAI data structure.
+	 */
+	machine_data->dai.name = "AC97";
+	machine_data->dai.stream_name = "AC97";
+	/*
+	 * Because what bytes the psc driver
+	 * supports, force the ac97 driver to only
+	 * support 32 bit big endian data
+	 */
+	ac97_dai.playback.formats = SNDRV_PCM_FMTBIT_S32_BE;
+	ac97_dai.capture.formats = SNDRV_PCM_FMTBIT_S32_BE;
+	/*
+	 * Add 16KHz to ac97 rates
+	 */
+	ac97_dai.playback.rates |= SNDRV_PCM_RATE_16000;
+	ac97_dai.capture.rates |= SNDRV_PCM_RATE_16000;
+	machine_data->dai.codec_dai = &ac97_dai;
+
+	machine_data->dai.cpu_dai = mpc5121_psc_create_dai(psc_info);
+	machine_data->dai.ops = &mpc5121_ads_ops;
+
+	mpc5121_ads_machine.dai_link = &machine_data->dai;
+
+	/* Allocate a new audio platform device structure */
+	sound_device = platform_device_alloc("soc-audio", -1);
+	if (!sound_device) {
+		dev_err(&ofdev->dev, "platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	machine_data->sound_devdata.platform = &mpc512x_soc_platform;
+	machine_data->sound_devdata.machine = &mpc5121_ads_machine;
+	machine_data->sound_devdata.codec_dev = &soc_codec_dev_ac97;
+	machine_data->sound_devdata.codec_data = NULL;
+	sound_device->dev.platform_data = machine_data;
+
+	/* Set the platform device and ASoC device to point to each other */
+	platform_set_drvdata(sound_device, &machine_data->sound_devdata);
+	machine_data->sound_devdata.dev = &sound_device->dev;
+
+	/* Initialize PSC controller and codec */
+	mpc5121_psc_init(&ofdev->dev, machine_data->dai.cpu_dai);
+	ret = platform_device_add(sound_device);
+	if (ret) {
+		dev_err(&ofdev->dev, "platform device add failed\n");
+		goto error;
+	}
+
+	dev_set_drvdata(&ofdev->dev, sound_device);
+	if (machine_data->dai_format == SND_SOC_DAIFMT_AC97)
+		mpc5121_ac97_reset(NULL);
+	return 0;
+
+error:
+	of_node_put(codec_np);
+
+	if (sound_device)
+		platform_device_unregister(sound_device);
+
+	if (machine_data->dai.cpu_dai)
+		mpc5121_psc_destroy_dai(machine_data->dai.cpu_dai);
+
+	if (psc_info->psc)
+		iounmap(psc_info->psc);
+
+	if (psc_info->irq)
+		irq_dispose_mapping(psc_info->irq);
+
+	kfree(machine_data);
+
+	return ret;
+}
+
+/**
+ * mpc5121_ads_remove: remove the OF device
+ *
+ * This function is called when the OF device is removed.
+ */
+static int mpc5121_ads_remove(struct of_device *ofdev)
+{
+	struct platform_device *sound_device = dev_get_drvdata(&ofdev->dev);
+	struct mpc5121_ads_data *machine_data =
+					sound_device->dev.platform_data;
+
+	platform_device_unregister(sound_device);
+
+	if (machine_data->dai.cpu_dai)
+		mpc5121_psc_destroy_dai(machine_data->dai.cpu_dai);
+
+	if (machine_data->psc_info.psc)
+		iounmap(machine_data->psc_info.psc);
+
+	kfree(machine_data);
+	sound_device->dev.platform_data = NULL;
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	return 0;
+}
+
+static struct of_device_id mpc5121_ads_match[] = {
+	{
+	 .compatible = "fsl,mpc5121-psc-ac97",
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mpc5121_ads_match);
+
+static struct of_platform_driver mpc5121_ads_of_driver = {
+	.owner = THIS_MODULE,
+	.name = "mpc5121_ads",
+	.match_table = mpc5121_ads_match,
+	.probe = mpc5121_ads_probe,
+	.remove = mpc5121_ads_remove,
+};
+
+/**
+ * mpc5121_ads_init: fabric driver initialization.
+ *
+ * This function is called when this module is loaded.
+ */
+static int __init mpc5121_ads_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Freescale MPC5121 ADS ALSA SoC fabric driver\n");
+
+	ret = of_register_platform_driver(&mpc5121_ads_of_driver);
+
+	if (ret)
+		printk(KERN_ERR
+		       "mpc5121-ads: failed to register platform driver\n");
+
+	return ret;
+}
+
+/**
+ * mpc5121_ads_exit: fabric driver exit
+ *
+ * This function is called when this driver is unloaded.
+ */
+static void __exit mpc5121_ads_exit(void)
+{
+	of_unregister_platform_driver(&mpc5121_ads_of_driver);
+}
+
+module_init(mpc5121_ads_init);
+module_exit(mpc5121_ads_exit);
+
+MODULE_AUTHOR("John Rigby <jrigby@freescale.com>");
+MODULE_DESCRIPTION("Freescale MPC5121 ADS ALSA SoC fabric driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/mpc5121_pcm.c b/sound/soc/fsl/mpc5121_pcm.c
new file mode 100644
index 0000000..ad82084
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_pcm.c
@@ -0,0 +1,435 @@
+/*
+ * Freescale MPC5121 ALSA SoC PCM driver
+ * Copyright 2007,2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: John Rigby <jrigby@freescale.com>
+ *
+ *
+ *  Originally copied from sound/mpc5121/mpc5121-pcm.c
+ *  Freescale AC97 device driver for CPU MPC5121
+ *  Author: Hongjun Chen <hong-jun.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+#include <asm/fsldma.h>
+#include <asm/mpc52xx_psc.h>
+
+#include "mpc5121_pcm.h"
+#include "mpc5121_psc_info.h"
+
+#define BPF             4	/* bytes per frame */
+#define SLOTS           2
+#define SAMPLESIZE      (BPF*SLOTS)
+
+#define FPP             (4096 / 2)	/* frames per period */
+#define PERIODS_MAX     8
+#define PERIODSIZE      (SAMPLESIZE*FPP)
+#define BUFSIZE         (PERIODSIZE*PERIODS_MAX)
+
+struct mpc512x_dma_config pcm_config;
+
+/*
+ * Support all these formats, actual supported format will
+ * depend on what the soc and codec driver support.
+ */
+#define MPC5121_PCM_FORMATS (SNDRV_PCM_FMTBIT_S8 	| \
+			    SNDRV_PCM_FMTBIT_U8 	| \
+			    SNDRV_PCM_FMTBIT_S16_LE     | \
+			    SNDRV_PCM_FMTBIT_S16_BE     | \
+			    SNDRV_PCM_FMTBIT_U16_LE     | \
+			    SNDRV_PCM_FMTBIT_U16_BE     | \
+			    SNDRV_PCM_FMTBIT_S24_LE     | \
+			    SNDRV_PCM_FMTBIT_S24_BE     | \
+			    SNDRV_PCM_FMTBIT_U24_LE     | \
+			    SNDRV_PCM_FMTBIT_U24_BE     | \
+			    SNDRV_PCM_FMTBIT_S32_LE     | \
+			    SNDRV_PCM_FMTBIT_S32_BE     | \
+			    SNDRV_PCM_FMTBIT_U32_LE     | \
+			    SNDRV_PCM_FMTBIT_U32_BE)
+
+static const struct snd_pcm_hardware mpc512x_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED,
+	.formats = MPC5121_PCM_FORMATS,
+	.rates = SNDRV_PCM_RATE_8000_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.period_bytes_min = (FPP * SAMPLESIZE * 1),
+	.period_bytes_max = (FPP * SAMPLESIZE * PERIODS_MAX),
+	.periods_min = 1,
+	.periods_max = PERIODS_MAX,
+	.buffer_bytes_max = (FPP * SAMPLESIZE * PERIODS_MAX),
+	.fifo_size = 0,
+};
+
+struct mpc512x_runtime_data {
+	int dma_ch;
+	dma_addr_t dev_addr;
+	struct fsl_dma_requestbuf dma_desc_array[PERIODS_MAX];
+	dma_addr_t dma_desc_array_phys;
+	int current_period;
+	int stopping;
+};
+
+static int mpc512x_pcm_close(struct snd_pcm_substream *substream);
+static int period_len;
+static int mpc512x_pcm_hw_params(struct snd_pcm_substream *substream,
+				 struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mpc512x_runtime_data *rtd = runtime->private_data;
+	size_t totsize = params_buffer_bytes(params);
+	size_t period = params_period_bytes(params);
+	struct fsl_dma_requestbuf *dma_desc;
+	dma_addr_t dma_buff_phys;
+
+	period_len = period;
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = totsize;
+
+	dma_desc = rtd->dma_desc_array;
+	dma_buff_phys = runtime->dma_addr;
+
+	do {
+		if (period > totsize)
+			period = totsize;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			dma_desc->src = dma_buff_phys;
+			dma_desc->dest = rtd->dev_addr;
+			dma_desc->minor_loop = pcm_config.tx_dma_gran /
+			    sizeof(u32);
+			dma_desc->soff = sizeof(u32);
+			dma_desc->doff = 0;
+		} else {
+			dma_desc->src = rtd->dev_addr;
+			dma_desc->dest = dma_buff_phys;
+			dma_desc->minor_loop = pcm_config.rx_dma_gran /
+			    sizeof(u32);
+			dma_desc->soff = 0;
+			dma_desc->doff = sizeof(u32);
+		}
+		dma_desc->len = period;
+		dma_desc++;
+		dma_buff_phys += period;
+		memset(dma_desc, 0, sizeof(*dma_desc));
+	} while ((totsize -= period) > 0);
+
+	return 0;
+}
+
+static int mpc512x_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+}
+
+static int mpc512x_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct mpc512x_runtime_data *rtd = substream->runtime->private_data;
+	rtd->current_period = 0;
+	return 0;
+}
+
+static int mpc512x_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mpc512x_runtime_data *rtd = substream->runtime->private_data;
+	int ret = 0;
+	int dmaerr;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_STOP:
+		rtd->stopping++;
+		break;
+
+	case SNDRV_PCM_TRIGGER_START:
+		if (rtd->stopping) {
+			rtd->stopping = 0;
+		} else {
+			dmaerr = fsl_dma_config(rtd->dma_ch,
+				&rtd->dma_desc_array[rtd->current_period], 1);
+			if (dmaerr) {
+				printk(KERN_ERR "unexpected error in "
+					"mpc512x_pcm_trigger %d\n", -dmaerr);
+			} else {
+				fsl_dma_enable(rtd->dma_ch);
+			}
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	default:
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static void mpc512x_pcm_dma_callback(void *dev_id, int err_status)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct mpc512x_runtime_data *rtd = substream->runtime->private_data;
+	int dmaerr;
+
+	if (!err_status) {
+		if (rtd->stopping) {
+			rtd->stopping = 0;
+			return;
+		}
+
+		rtd->current_period++;
+		rtd->current_period %= substream->runtime->periods;
+
+		dmaerr = fsl_dma_config(rtd->dma_ch,
+				&rtd->dma_desc_array[rtd->current_period], 1);
+		if (dmaerr)
+			printk(KERN_ERR "unexpected error in "
+				"mpc512x_pcm_dma_callback %d\n", -dmaerr);
+		else
+			fsl_dma_enable(rtd->dma_ch);
+
+		snd_pcm_period_elapsed(substream);
+	} else {
+		printk(KERN_ERR
+		       "%s: DMA error on channel %d (Error Status=%#x)\n",
+		       __func__, rtd->dma_ch, err_status);
+		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+	}
+}
+
+static snd_pcm_uframes_t mpc512x_pcm_pointer(struct snd_pcm_substream
+					     *substream)
+{
+	struct mpc512x_runtime_data *rtd = substream->runtime->private_data;
+
+	return rtd->current_period * substream->runtime->period_size;
+}
+
+static int mpc512x_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mpc512x_runtime_data *rtd;
+	int dma_ch_nr;
+	int ret;
+
+	runtime->hw = mpc512x_pcm_hardware;
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	ret = -ENOMEM;
+
+	rtd = kzalloc(sizeof(*rtd), GFP_KERNEL);
+	if (!rtd)
+		goto err1;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		rtd->dev_addr = pcm_config.tx_dev_addr;
+		dma_ch_nr = pcm_config.tx_dma_ch_nr;
+	} else {
+		rtd->dev_addr = pcm_config.rx_dev_addr;
+		dma_ch_nr = pcm_config.rx_dma_ch_nr;
+	}
+
+	/* Allocate DMA channel for this substream */
+	ret = fsl_dma_chan_request(dma_ch_nr);
+	if (ret < 0) {
+		printk(KERN_ERR
+		       "Err: can't allocate DMA channel %d for PSC!\n",
+		       dma_ch_nr);
+		goto err2;
+	}
+	rtd->dma_ch = ret;
+	fsl_dma_callback_set(rtd->dma_ch,
+			     mpc512x_pcm_dma_callback, (void *)substream);
+
+	runtime->private_data = rtd;
+
+	return 0;
+
+err2:
+	kfree(rtd);
+err1:
+	return ret;
+}
+
+static int mpc512x_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct mpc512x_runtime_data *rtd = substream->runtime->private_data;
+
+	if (rtd && rtd->dma_ch >= 0)
+		fsl_dma_free_chan(rtd->dma_ch);
+
+	kfree(rtd);
+	return 0;
+}
+
+static struct snd_pcm_ops mpc512x_pcm_ops = {
+	.open = mpc512x_pcm_open,
+	.close = mpc512x_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = mpc512x_pcm_hw_params,
+	.hw_free = mpc512x_pcm_hw_free,
+	.prepare = mpc512x_pcm_prepare,
+	.trigger = mpc512x_pcm_trigger,
+	.pointer = mpc512x_pcm_pointer,
+};
+
+static int mpc512x_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size = mpc512x_pcm_hardware.buffer_bytes_max;
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = dma_alloc_coherent(pcm->card->dev, size,
+				       &buf->addr, GFP_KERNEL);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void mpc512x_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+		buf = &substream->dma_buffer;
+		if (!buf || !buf->area)
+			continue;
+		dma_free_coherent(pcm->card->dev, buf->bytes,
+				  buf->area, buf->addr);
+		buf->area = NULL;
+	}
+}
+
+static int mpc512x_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+			   struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (dai->playback.channels_min) {
+		ret =
+		    mpc512x_pcm_preallocate_dma_buffer(pcm,
+			       SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+	if (dai->capture.channels_min) {
+		ret =
+		    mpc512x_pcm_preallocate_dma_buffer(pcm,
+			       SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+unsigned short headphone;
+static int mpc512x_pcm_suspend(struct platform_device *pdev,
+			       struct snd_soc_dai *dai)
+{
+	struct mpc5121_psc_private *psc_private = dai->private_data;
+	struct mpc52xx_psc *psc = psc_private->psc;
+	struct mpc512x_psc_fifo *fifo;
+
+	fifo = (struct mpc512x_psc_fifo *)
+	    (psc_private->psc + sizeof(struct mpc52xx_psc));
+
+#ifdef CONFIG_SND_SOC_MPC5121_ADS
+	if (psc_private->format == SND_SOC_DAIFMT_AC97)
+		headphone = mpc5121_ac97_read(NULL, 4);
+#endif
+
+	/* Disable AC97 controller */
+	out_be32(&psc->sicr, 0);
+
+	/* Disable FIFO rx/tx slices,  */
+	out_be32(&fifo->rxcmd, MPC512x_PSC_FIFO_RESET_SLICE);
+	out_be32(&fifo->txcmd, MPC512x_PSC_FIFO_RESET_SLICE);
+
+	/* Disable clock */
+	mpc5121_psc_clkinit(psc_private, 0);
+
+	return 0;
+}
+
+static int mpc512x_pcm_resume(struct platform_device *pdev,
+			      struct snd_soc_dai *dai)
+{
+	struct mpc5121_psc_private *psc_private = dai->private_data;
+
+	mpc5121_psc_init(&pdev->dev, dai);
+#ifdef CONFIG_SND_SOC_MPC5121_ADS
+	if (psc_private->format == SND_SOC_DAIFMT_AC97)
+		mpc5121_ac97_reset(NULL);
+	mpc5121_ac97_write(NULL, 4, headphone);
+#else
+	(void)psc_private;
+#endif
+
+	return 0;
+}
+#else
+#define mpc512x_pcm_suspend	NULL
+#define mpc512x_pcm_resume	NULL
+#endif
+
+struct snd_soc_platform mpc512x_soc_platform = {
+	.name = "MPC5121-audio",
+	.pcm_ops = &mpc512x_pcm_ops,
+	.pcm_new = mpc512x_pcm_new,
+	.pcm_free = mpc512x_pcm_free_dma_buffers,
+	.suspend = mpc512x_pcm_suspend,
+	.resume = mpc512x_pcm_resume,
+};
+EXPORT_SYMBOL_GPL(mpc512x_soc_platform);
+
+/*
+ * pass config info about the PSC driver to the DMA driver
+ */
+int mpc512x_dma_configure(struct mpc512x_dma_config *config)
+{
+	static int initialized;
+
+	if (initialized)
+		return 0;
+
+	pcm_config = *config;
+	initialized = 1;
+
+	return 1;
+}
+EXPORT_SYMBOL_GPL(mpc512x_dma_configure);
+
+MODULE_AUTHOR("John Rigby <jrigby@freescale.com>");
+MODULE_DESCRIPTION("Freescale MPC512x ASoC PCM module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/mpc5121_pcm.h b/sound/soc/fsl/mpc5121_pcm.h
new file mode 100644
index 0000000..b45c58e
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_pcm.h
@@ -0,0 +1,32 @@
+/*
+ * Freescale MPC5121 ALSA SoC PCM driver
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: John Rigby <jrigby@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __MPC5121_PCM_H__
+#define __MPC5121_PCM_H__
+struct mpc512x_dma_config {
+	int rx_dma_ch_nr;
+	int tx_dma_ch_nr;
+	dma_addr_t rx_dev_addr;
+	dma_addr_t tx_dev_addr;
+	int rx_dma_gran;
+	int tx_dma_gran;
+};
+
+
+extern struct snd_soc_platform mpc512x_soc_platform;
+
+/*
+ * pass config info about the PSC driver to the DMA driver
+ */
+extern int mpc512x_dma_configure(struct mpc512x_dma_config *config);
+#endif /* __MPC5121_PCM_H__ */
diff --git a/sound/soc/fsl/mpc5121_psc.c b/sound/soc/fsl/mpc5121_psc.c
new file mode 100644
index 0000000..91cbcbc
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_psc.c
@@ -0,0 +1,619 @@
+/*
+ * Freescale MPC5121 PSC ALSA SoC Digital Audio Interface (DAI) driver
+ *
+ * Copyright 2008 Freescale Semiconductor, Inc.
+ * Author: John Rigby <jrigby@freescale.com>
+ *
+ * Based on
+ *     fsl_ssi.c -- Author: Timur Tabi <timur@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without
+ * any warranty of any kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <asm/mpc52xx_psc.h>
+#include <asm/mpc512x.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include "mpc5121_psc_info.h"
+
+/*
+ * Three scenarios:
+ * 	AC97: PSC is slave so claim support for all speeds and let codec
+ * 	determine the rate.
+ * 	ICS Slave: PSC is slave so identical above.
+ * 	ICS Master: PSC is master which can do any speed
+ *
+ * 	So for all three modes 8000-48000 continuous is ok
+ */
+#define PSC_SAMPLE_RATES SNDRV_PCM_RATE_8000_48000
+
+/*
+ * AC97 sample width is upto 20 bits, the next unpacked size if 32.
+ * I2S works for 8, 16 and 32
+ */
+#define PSC_AC97_FORMATS SNDRV_PCM_FMTBIT_S32_BE
+#define PSC_I2S_FORMATS ( 	\
+    SNDRV_PCM_FMTBIT_S32_BE |	\
+    SNDRV_PCM_FMTBIT_S16_BE | 	\
+    SNDRV_PCM_FMTBIT_S8 | 	\
+    0)
+
+struct {
+	int tot;
+	int al;
+	int em;
+	int ur;
+	int or;
+	int me;
+	int update;
+} pscstats;
+
+/**
+ * mpc5121_psc_isr: PSC interrupt handler
+ *
+ * All data transfer is done via dma.  This handler is just for errors.
+ *
+ * @irq: IRQ of the PSC device
+ * @dev_id: pointer to the psc_private structure for this PSC device
+ */
+static irqreturn_t mpc5121_psc_isr(int irq, void *dev_id)
+{
+	struct mpc5121_psc_private *psc_private = dev_id;
+	irqreturn_t ret = IRQ_NONE;
+	struct mpc512x_psc_fifo *fifo;
+	u32 isr;
+
+	fifo = (struct mpc512x_psc_fifo *)
+	    (psc_private->psc + sizeof(struct mpc52xx_psc));
+
+	isr = in_be32(&fifo->rxisr);
+	out_be32(&fifo->rxisr, isr);
+
+	isr = in_be32(&fifo->txisr);
+	out_be32(&fifo->txisr, isr);
+
+	if (isr & MPC512x_PSC_FIFO_ALARM)
+		pscstats.al++;
+	if (isr & MPC512x_PSC_FIFO_URERR)
+		pscstats.ur++;
+	if (isr & MPC512x_PSC_FIFO_ORERR)
+		pscstats.or++;
+	if (isr & MPC512x_PSC_FIFO_MEMERROR)
+		pscstats.me++;
+	if (isr & MPC512x_PSC_FIFO_EMPTY)
+		pscstats.em++;
+
+	if (isr) {
+		pscstats.tot++;
+		pscstats.update++;
+		ret = IRQ_HANDLED;
+	}
+
+#ifdef DEBUG
+	if (pscstats.update > 10000) {
+		pscstats.update = 0;
+		printk(KERN_ERR "al %d ur %d or %d me %d em %d tot %d\n",
+			pscstats.al,
+			pscstats.ur,
+			pscstats.or,
+			pscstats.me,
+			pscstats.em,
+			pscstats.tot);
+	}
+#endif
+
+	return ret;
+}
+
+int mpc5121_psc_clkinit(struct mpc5121_psc_private *psc_private, int on)
+{
+	/* when adding master this will need to do more */
+	char clockname[256];
+	struct clk *clk;
+
+	sprintf(clockname, "psc%d_mclk", psc_private->cpu_dai.id);
+
+	clk = psc_private->clk = clk_get(NULL, clockname);
+	if (IS_ERR(psc_private->clk)) {
+		printk(KERN_ERR "%s: can't probe clock"
+			" source for PSC SOC.\n", __func__);
+		psc_private->clk = NULL;
+		return PTR_ERR(clk);
+	}
+
+	if (on)
+		clk_enable(clk);
+	else
+		clk_disable(clk);
+
+	clk_put(clk);
+
+	return 0;
+}
+
+void mpc5121_psc_fifo_init(struct mpc5121_psc_private *psc_private)
+{
+	struct mpc512x_psc_fifo *fifo;
+	unsigned long size;
+
+	fifo = (struct mpc512x_psc_fifo *)
+	    (psc_private->psc + sizeof(struct mpc52xx_psc));
+
+	out_be32(&fifo->rxcmd, MPC512x_PSC_FIFO_RESET_SLICE);
+	out_be32(&fifo->txcmd, MPC512x_PSC_FIFO_RESET_SLICE);
+
+	/*
+	 * Make sure that dma granularity does not
+	 * exceed the fifo size.
+	 */
+	size = in_be32(&fifo->rxsz) * 4;
+	if (size < psc_private->rx_dma_gran)
+		printk(KERN_WARNING "rx dma granularity exceeds fifo size\n");
+	out_be32(&fifo->rxalarm, size - psc_private->rx_dma_gran);
+
+	size = in_be32(&fifo->txsz) * 4;
+	if (size < psc_private->tx_dma_gran)
+		printk(KERN_WARNING "tx dma granularity exceeds fifo size\n");
+	out_be32(&fifo->txalarm, size - psc_private->tx_dma_gran);
+}
+
+void mpc5121_psc_fifo_enable(struct mpc5121_psc_private *psc_private)
+{
+	struct mpc512x_psc_fifo *fifo;
+
+	fifo = (struct mpc512x_psc_fifo *)
+	    (psc_private->psc + sizeof(struct mpc52xx_psc));
+
+	out_be32(&fifo->rxcmd,
+		 MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);
+	out_be32(&fifo->txcmd,
+		 MPC512x_PSC_FIFO_ENABLE_SLICE | MPC512x_PSC_FIFO_ENABLE_DMA);
+}
+
+int mpc5121_psc_init(struct device *dev, struct snd_soc_dai *cpu_dai)
+{
+	struct mpc5121_psc_private *psc_private = cpu_dai->private_data;
+	int err;
+
+	/*
+	 * If this is the first stream opened, then request the IRQ
+	 * and initialize the PSC registers.
+	 */
+	if (!psc_private->playback && !psc_private->capture) {
+		struct mpc52xx_psc __iomem *psc = psc_private->psc;
+
+		err = mpc5121_psc_clkinit(psc_private, 1);
+		if (err < 0) {
+			dev_err(dev, "could not initialize psc clk\n");
+			goto noclock;
+		}
+
+		/* disable */
+		out_8(&psc->command,
+		      MPC52xx_PSC_TX_DISABLE | MPC52xx_PSC_RX_DISABLE);
+
+		mpc5121_psc_fifo_init(psc_private);
+
+		/* reset everything */
+		out_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);
+		out_8(&psc->command, MPC52xx_PSC_RST_RX);
+		out_8(&psc->command, MPC52xx_PSC_RST_TX);
+		out_8(&psc->command, MPC52xx_PSC_RST_ERR_STAT);
+		out_8(&psc->command, MPC52xx_PSC_RST_BRK_CHG_INT);
+		out_8(&psc->command, MPC52xx_PSC_STOP_BRK);
+
+		switch (psc_private->format) {
+		case SND_SOC_DAIFMT_AC97:
+			/*
+			 * set up the psc for AC97 mode
+			 */
+			out_be32(&psc->sicr,
+				0x03000000 | /* SIM = 0011   : AC97 mode */
+				0x00010000 | /* EnAC97 = 1   : Normal mode */
+				0x00000100 | /* Outputs always enabled */
+				0);
+
+			out_be32(&psc->ac97_slots,
+				0x300 << 16  | /* Enable tx timeslot 3,4 */
+				0x300	     | /* Enable rx timeslot 3,4 */
+				0);
+
+			/*
+			 * Reset external AC97 codec
+			 * Some codecs go into test mode if the data or sync
+			 * lines are high when the reset line goes high.
+			 * Avoid that by forcing them to GPIOs and driving them
+			 * low during reset.
+			 */
+			mpc5121_pscgpio_make_gpio(cpu_dai->id, 1);
+			mpc5121_pscgpio_pin_low(cpu_dai->id, 1);
+			mpc5121_pscgpio_make_gpio(cpu_dai->id, 2);
+			mpc5121_pscgpio_pin_low(cpu_dai->id, 2);
+
+			out_8(&psc->op1, 0x02); iosync();
+			udelay(1);
+			out_8(&psc->op0, 0x02); iosync();
+			udelay(1);
+
+			/*
+			 * Reset complete, change lines back to PSC signals.
+			 */
+			mpc5121_pscgpio_make_psc(cpu_dai->id, 1);
+			mpc5121_pscgpio_make_psc(cpu_dai->id, 2);
+			break;
+		case SND_SOC_DAIFMT_I2S:
+			out_be32(&psc->sicr,
+				0x20000000 |/* DTS = 1:Delay 1 bit time (I2S) */
+				0x0f000000 | /* SIM = 1111   : Codec 32 bit */
+				0x00400000 | /* I2S = 1      : I2S */
+				0x00200000 | /* CLKPOL = 1   : */
+				0x00000100 | /* Outputs always enabled */
+				0);
+			break;
+		}
+
+		/* enable the fifos */
+		mpc5121_psc_fifo_enable(psc_private);
+
+		/* enable rx and tx now */
+		out_8(&psc->command, MPC52xx_PSC_TX_ENABLE |
+			MPC52xx_PSC_RX_ENABLE);
+	}
+
+	return 0;
+noclock:
+	return err;
+}
+EXPORT_SYMBOL_GPL(mpc5121_psc_init);
+
+/**
+ * mpc5121_psc_startup: create a new substream
+ *
+ * This is the first function called when a stream is opened.
+ *
+ * If this is the first stream open, then grab the IRQ and program most of
+ * the PSC registers.
+ */
+static int mpc5121_psc_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mpc5121_psc_private *psc_private =
+	    rtd->dai->cpu_dai->private_data;
+
+	/*
+	 * If this is the first stream opened, then request the IRQ
+	 * and initialize the PSC registers.
+	 */
+	if (!psc_private->playback && !psc_private->capture) {
+		int ret;
+		ret = request_irq(psc_private->irq, mpc5121_psc_isr,
+				  IRQF_SHARED,
+				  psc_private->name, psc_private);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not claim irq %u\n", psc_private->irq);
+			return ret;
+		}
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		psc_private->playback++;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		psc_private->capture++;
+
+	return 0;
+}
+
+/**
+ * mpc5121_psc_prepare: prepare the PSC.
+ */
+static int mpc5121_psc_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mpc5121_psc_private *psc_private =
+	    rtd->dai->cpu_dai->private_data;
+	struct mpc52xx_psc __iomem *psc = psc_private->psc;
+	int width;
+	int sicr;
+	int bclkdiv;
+	int ccr;
+
+	switch (psc_private->format) {
+	case SND_SOC_DAIFMT_AC97:
+		/* nothing to do, original init is good */
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		/* reset everything */
+		out_8(&psc->command, MPC52xx_PSC_SEL_MODE_REG_1);
+		out_8(&psc->command, MPC52xx_PSC_RST_RX);
+		out_8(&psc->command, MPC52xx_PSC_RST_TX);
+		out_8(&psc->command, MPC52xx_PSC_RST_ERR_STAT);
+		out_8(&psc->command, MPC52xx_PSC_STOP_BRK);
+
+		/* format */
+		sicr = 0x20000000  | /* DTS = 1      : Delay 1 bit time (I2S) */
+			(psc_private->clk_dir == SND_SOC_CLOCK_OUT ?
+			0x00800000 : /* GenClk = 1   : master */
+			0x00000000) | /* GenClk = 0   : slave */
+			0x00400000 | /* I2S = 1      : I2S */
+			0x00200000 | /* CLKPOL = 1   : */
+			0x00000100 | /* Outputs always enabled */
+			0;
+
+		width = snd_pcm_format_width(runtime->format);
+		switch (width) {
+		case 8:
+			sicr |= 0x01000000;
+			break;
+		case 16:
+			sicr |= 0x02000000;
+			break;
+		case 32:
+			sicr |= 0x0f000000;
+			break;
+		}
+		out_be32(&psc->sicr, sicr);
+
+
+		/* rate based on 64 bit clks per frame */
+		bclkdiv = psc_private->clk_rate / (runtime->rate * 64) - 1;
+
+		ccr = ((64-1) << 24)
+		    | ((bclkdiv & 0xff) << 16)
+		    | (((bclkdiv >> 8) & 0xff) << 8);
+		out_be32(&psc->ccr, ccr);
+		out_8(&psc->ctur, (64/2)-1);
+
+		out_8(&psc->command, MPC52xx_PSC_TX_ENABLE |
+			MPC52xx_PSC_RX_ENABLE);
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * mpc5121_psc_trigger: start and stop the DMA transfer.
+ *
+ * This function is called by ALSA to start, stop, pause, and resume the DMA
+ * transfer of data.
+ *
+ * The DMA channel is in external master start and pause mode, which
+ * means the PSC completely controls the flow of data.
+ */
+static int mpc5121_psc_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mpc5121_psc_private *psc_private =
+					rtd->dai->cpu_dai->private_data;
+	struct mpc512x_psc_fifo *fifo;
+
+	fifo = (struct mpc512x_psc_fifo *)
+	    (psc_private->psc + sizeof(struct mpc52xx_psc));
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			out_be32(&fifo->tximr,
+				MPC512x_PSC_FIFO_MEMERROR |
+				MPC512x_PSC_FIFO_ORERR |
+				MPC512x_PSC_FIFO_URERR);
+		else
+			out_be32(&fifo->rximr,
+				MPC512x_PSC_FIFO_MEMERROR |
+				MPC512x_PSC_FIFO_ORERR |
+				MPC512x_PSC_FIFO_URERR);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			out_be32(&fifo->tximr, 0);
+		else
+			out_be32(&fifo->rximr, 0);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * mpc5121_psc_shutdown: shutdown the PSC
+ *
+ * Shutdown the PSC if there are no other substreams open.
+ */
+static void mpc5121_psc_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mpc5121_psc_private *psc_private =
+	    rtd->dai->cpu_dai->private_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		psc_private->playback--;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		psc_private->capture--;
+
+	/*
+	 * If this is the last active substream, disable the PSC and release
+	 * the IRQ.
+	 */
+	if (!psc_private->playback && !psc_private->capture) {
+		void __iomem *psc = psc_private->psc;
+
+		(void)psc;
+		printk(KERN_INFO "psc shutting down %p\n", psc);
+
+		free_irq(psc_private->irq, psc_private);
+	}
+}
+
+/**
+ * mpc5121_psc_set_sysclk: set the clock frequency and direction
+ *
+ * This function is called by the machine driver to tell us what the clock
+ * frequency and direction are.
+ *
+ * When runniing as a clock slave (SND_SOC_CLOCK_IN) then we don't care about
+ * the rate.
+ *
+ * When running as a clock master (SND_SOC_CLOCK_OUT) then we use the clock
+ * rate obtained from the clock driver via clk_get_rate.
+ *
+ * @clk_id: reserved, should be zero
+ * @freq: the frequency of the given clock ID, currently ignored
+ * @dir: SND_SOC_CLOCK_IN (clock slave) or SND_SOC_CLOCK_OUT (clock master)
+ */
+static int mpc5121_psc_set_sysclk(struct snd_soc_dai *mpc5121_psc_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	struct mpc5121_psc_private *psc_private =
+	    container_of(mpc5121_psc_dai, struct mpc5121_psc_private, cpu_dai);
+
+	psc_private->clk_dir = dir;
+	return 0;
+}
+
+/**
+ * mpc5121_psc_set_fmt: set the serial format.
+ *
+ * This function is called by the machine driver to tell us what serial
+ * format to use.
+ *
+ * Currently AC97 and I2S are supported
+ *
+ * @format: one of SND_SOC_DAIFMT_xxx
+ */
+static int mpc5121_psc_set_fmt(struct snd_soc_dai *mpc5121_psc_dai,
+			       unsigned int format)
+{
+	struct mpc5121_psc_private *psc_private =
+	    container_of(mpc5121_psc_dai, struct mpc5121_psc_private, cpu_dai);
+
+	switch (format & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_AC97:
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	default:
+		return -EINVAL;
+	}
+	psc_private->format = format;
+	return 0;
+}
+
+/**
+ * mpc5121_psc_dai_template: template CPU DAI for the PSC
+ */
+static struct snd_soc_dai mpc5121_psc_dai_template = {
+	.playback = {
+		     /* The PSC does not support monaural audio. */
+		     .channels_min = 2,
+		     .channels_max = 2,
+		     .rates = PSC_SAMPLE_RATES,
+		     .formats = PSC_AC97_FORMATS,
+		     },
+	.capture = {
+		    .channels_min = 2,
+		    .channels_max = 2,
+		    .rates = PSC_SAMPLE_RATES,
+		    .formats = PSC_AC97_FORMATS,
+		    },
+	.ops = {
+		.startup = mpc5121_psc_startup,
+		.prepare = mpc5121_psc_prepare,
+		.shutdown = mpc5121_psc_shutdown,
+		.trigger = mpc5121_psc_trigger,
+		},
+	.dai_ops = {
+		    .set_sysclk = mpc5121_psc_set_sysclk,
+		    .set_fmt = mpc5121_psc_set_fmt,
+		    },
+};
+
+/**
+ * mpc5121_psc_create_dai: create a snd_soc_dai structure
+ *
+ * This function is called by the machine driver to create a snd_soc_dai
+ * structure.  The function creates an psc_private object, which contains
+ * the snd_soc_dai.  It also creates the sysfs statistics device.
+ */
+struct snd_soc_dai *mpc5121_psc_create_dai(struct mpc5121_psc_info
+					       *psc_info)
+{
+	struct snd_soc_dai *mpc5121_psc_dai;
+	struct mpc5121_psc_private *psc_private;
+	struct mpc5121_ads_data *ads_data = container_of(psc_info,
+			struct mpc5121_ads_data, psc_info);
+
+	psc_private = kzalloc(sizeof(struct mpc5121_psc_private), GFP_KERNEL);
+	if (!psc_private) {
+		dev_err(psc_info->dev, "could not allocate DAI object\n");
+		return NULL;
+	}
+	memcpy(&psc_private->cpu_dai, &mpc5121_psc_dai_template,
+	       sizeof(struct snd_soc_dai));
+
+	if (ads_data->dai_format == SND_SOC_DAIFMT_I2S) {
+		psc_private->cpu_dai.playback.formats = PSC_I2S_FORMATS;
+		psc_private->cpu_dai.capture.formats = PSC_I2S_FORMATS;
+	}
+
+	mpc5121_psc_dai = &psc_private->cpu_dai;
+
+	sprintf(psc_private->name, "psc%u", (u8) psc_info->id);
+	psc_private->psc = psc_info->psc;
+	psc_private->phys = psc_info->phys;
+	psc_private->irq = psc_info->irq;
+	psc_private->dev = psc_info->dev;
+	psc_private->rx_dma_gran = psc_info->rx_dma_gran;
+	psc_private->tx_dma_gran = psc_info->tx_dma_gran;
+
+	psc_private->dev->driver_data = mpc5121_psc_dai;
+	psc_private->format = ads_data->dai_format;
+
+	mpc5121_psc_dai->private_data = psc_private;
+	mpc5121_psc_dai->name = psc_private->name;
+	mpc5121_psc_dai->id = psc_info->id;
+
+	return mpc5121_psc_dai;
+}
+EXPORT_SYMBOL_GPL(mpc5121_psc_create_dai);
+
+/**
+ * mpc5121_psc_destroy_dai: destroy the snd_soc_dai object
+ *
+ * This function undoes the operations of mpc5121_psc_create_dai()
+ */
+void mpc5121_psc_destroy_dai(struct snd_soc_dai *mpc5121_psc_dai)
+{
+	struct mpc5121_psc_private *psc_private =
+	    container_of(mpc5121_psc_dai, struct mpc5121_psc_private, cpu_dai);
+
+	kfree(psc_private);
+}
+EXPORT_SYMBOL_GPL(mpc5121_psc_destroy_dai);
+
+MODULE_AUTHOR("John Rigby <jrigby@freescale.com>");
+MODULE_DESCRIPTION("Freescale psc ASoC Driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/mpc5121_psc_info.h b/sound/soc/fsl/mpc5121_psc_info.h
new file mode 100644
index 0000000..68562d1
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_psc_info.h
@@ -0,0 +1,88 @@
+/*
+ * mpc5121_psc_info.h - ALSC PSC interface for Freescale MPC5121ADS SoC
+ *
+ * Copyright 2008 Freescale Semiconductor Inc.
+ * Author: John Rigby jrigby@freescale.com
+ *
+ * Based on fsl_ssi.h - Author Timur Tabi <timur@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without
+ * any warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MPC5121_PSC_INFO_H__
+#define __MPC5121_PSC_INFO_H__
+
+extern struct mpc52xx_psc *psc_reg_priv;
+
+struct mpc5121_psc_info {
+	unsigned int id;
+	void __iomem *psc;
+	dma_addr_t phys;
+	unsigned int irq;
+	struct device *dev;
+	int rx_dma_gran;
+	int tx_dma_gran;
+};
+
+/**
+ * mpc5121_psc_private: per-PSC private data
+ *
+ * @name: short name for this device ("PSC0", "PSC1", etc)
+ * @psc: pointer to the PSC's registers
+ * @phys: physical address of the PSC registers
+ * @irq: IRQ of this PSC
+ * @dev: struct device pointer
+ * @playback: the number of playback streams opened
+ * @capture: the number of capture streams opened
+ * @cpu_dai: the CPU DAI for this device
+ * @format: the format of link
+ * @clk_dir: clock direction
+ */
+struct mpc5121_psc_private {
+	char name[8];
+	void __iomem *psc;
+	dma_addr_t phys;
+	unsigned int irq;
+	struct device *dev;
+	unsigned int playback;
+	unsigned int capture;
+	struct snd_soc_dai cpu_dai;
+	struct device_attribute dev_attr;
+	struct clk *clk;
+	int rx_dma_gran;
+	int tx_dma_gran;
+	int format;
+	int clk_dir;
+	int clk_rate;
+};
+
+/**
+ * mpc5121_ads_data: fabric-specific ASoC device data
+ *
+ * This structure contains data for a single sound platform device on an
+ * MPC5121e ADS.  Some of the data is taken from the device tree.
+ */
+struct mpc5121_ads_data {
+	struct snd_soc_device sound_devdata;
+	struct snd_soc_dai_link dai;
+	struct snd_soc_machine machine;
+	unsigned int dai_format;
+	unsigned int codec_clk_direction;
+	unsigned int cpu_clk_direction;
+	unsigned int clk_frequency;
+	struct mpc5121_psc_info psc_info;
+};
+
+struct snd_soc_dai *mpc5121_psc_create_dai(struct mpc5121_psc_info *);
+void mpc5121_psc_destroy_dai(struct snd_soc_dai *);
+int mpc5121_psc_init(struct device *dev, struct snd_soc_dai *cpu_dai);
+int mpc5121_psc_clkinit(struct mpc5121_psc_private *psc_private, int on);
+void mpc5121_psc_fifo_init(struct mpc5121_psc_private *psc_private);
+
+void mpc5121_ac97_reset(struct snd_ac97 *ac97);
+void mpc5121_ac97_write(struct snd_ac97 *ac97, unsigned short reg,
+			unsigned short val);
+unsigned short mpc5121_ac97_read(struct snd_ac97 *ac97, unsigned short reg);
+#endif				/* __MPC5121_PSC_INFO_H__  */
-- 
1.6.0.90.g436ed

