From aff684bc69cc0be9b987523f7e5cba4e2e66fbe7 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:06 +0800
Subject: [PATCH] Add AXE MBX module

Add code to mpc512x_shared.c for mbx platform driver.
Add ability to reserve memory for AXE and MBX to
arch/powerpc/kernel/prom.c.
Hack ioremap for MBX so it can ioremap mem.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/Kconfig                         |   22 ++
 arch/powerpc/kernel/prom.c                   |    6 +
 arch/powerpc/mm/pgtable_32.c                 |    5 +
 arch/powerpc/platforms/512x/Makefile         |    1 +
 arch/powerpc/platforms/512x/axe_dev.c        |  426 ++++++++++++++++++++++++++
 arch/powerpc/platforms/512x/axe_dev.h        |   35 +++
 arch/powerpc/platforms/512x/mpc512x_shared.c |   62 ++++
 7 files changed, 557 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/axe_dev.c
 create mode 100644 arch/powerpc/platforms/512x/axe_dev.h

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 6f4c635..ac4c368 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -696,6 +696,28 @@ config LOWMEM_SIZE
 	hex "Maximum low memory size (in bytes)" if LOWMEM_SIZE_BOOL
 	default "0x30000000"
 
+config AXEMBX_RESERVE_BOOL
+	bool "Reserved memory for AXE and/or MBX driver"
+	depends on ADVANCED_OPTIONS
+	help
+	  This option allows you to reserve a range of memory for the AXE driver
+	  this is useful for guaranteeing that the AXE driver gets memory under 16M
+	  and for reserving a contiguous region for MBX frame buffers
+
+	  Say N here unless you know what you are doing.
+
+config AXEMBX_RESERVE_START
+	hex "Start of reserved AXE and MBX driver memory in bytes" if AXEMBX_RESERVE_BOOL
+	default "0x00400000"
+
+config AXE_RESERVE_SIZE
+	hex "Size of reserved AXE driver memory in bytes" if AXEMBX_RESERVE_BOOL
+	default "0x00100000"
+
+config MBX_RESERVE_SIZE
+	hex "Size of reserved MBX driver memory in bytes" if AXEMBX_RESERVE_BOOL
+	default "0x04000000"
+
 config RELOCATABLE
 	bool "Build a relocatable kernel (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && ADVANCED_OPTIONS && FLATMEM && FSL_BOOKE
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index 09455e1..01c3614 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -1033,6 +1033,12 @@ static void __init early_reserve_mem(void)
 	self_size = initial_boot_params->totalsize;
 	lmb_reserve(self_base, self_size);
 
+#ifdef CONFIG_AXEMBX_RESERVE_BOOL
+	lmb_reserve(CONFIG_AXEMBX_RESERVE_START,
+		CONFIG_AXE_RESERVE_SIZE +
+		CONFIG_MBX_RESERVE_SIZE);
+#endif
+
 #ifdef CONFIG_BLK_DEV_INITRD
 	/* then reserve the initrd, if any */
 	if (initrd_start && (initrd_end > initrd_start))
diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c
index 3e69b0d..745775b 100644
--- a/arch/powerpc/mm/pgtable_32.c
+++ b/arch/powerpc/mm/pgtable_32.c
@@ -193,8 +193,12 @@ __ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)
 	 */
 	if (p < 16*1024*1024)
 		p += _ISA_MEM_BASE;
+#ifdef CONFIG_PPC_MPC512x
+#define ALLOW_RAM_REMAP_FOR_MBX
+#endif
 
 #ifndef CONFIG_CRASH_DUMP
+#ifndef ALLOW_RAM_REMAP_FOR_MBX
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using.
 	 * mem_init() sets high_memory so only do the check after that.
@@ -205,6 +209,7 @@ __ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)
 		return NULL;
 	}
 #endif
+#endif
 
 	if (size == 0)
 		return NULL;
diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index 63e7ecb..4d55ca6 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_MPC5121_ADS)	+= mpc5121_ads.o mpc5121_ads_cpld.o
 obj-$(CONFIG_MPC5121_GENERIC)	+= mpc5121_generic.o
 obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
 obj-$(CONFIG_SPI)		+= mpc5121_spi.o
+obj-m				+= axe_dev.o
diff --git a/arch/powerpc/platforms/512x/axe_dev.c b/arch/powerpc/platforms/512x/axe_dev.c
new file mode 100644
index 0000000..9974e8b
--- /dev/null
+++ b/arch/powerpc/platforms/512x/axe_dev.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: John Rigby <jrigby@freescale.com>
+ *
+ * AXE Audio Processor driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/mm.h>
+
+#include <asm/of_device.h>
+#include <asm/of_platform.h>
+#include <asm/mpc512x.h>
+#include <asm/uaccess.h>
+#include <asm/cacheflush.h>
+
+#include "axe_dev.h"
+
+struct axe_priv {
+	void *kvirt_dram;
+	void *kvirt_regs;
+	void *kvirt_sram;
+	struct device *dev;
+	int irq;
+	struct clk *axe_clk;
+	struct mutex open_lock;
+	int master_opened;
+	int opened;
+	int major;
+	struct class *axe_class;
+};
+static struct axe_priv _priv;
+struct axe_priv *priv = &_priv;
+
+struct axe_dev_pub *pub;
+
+struct axe_master {
+	atomic_t irqcount;
+	atomic_t disable;
+	unsigned long lastirqcount;
+	wait_queue_head_t wait;
+};
+struct axe_master _master;
+static struct axe_master *master = &_master;
+
+#define DRV_NAME "axe"
+#define DRV_VERSION "0.2"
+
+static struct of_device_id axe_match[] = {
+	{
+		.compatible = "fsl,mpc5121-axe",
+	},
+	{},
+};
+
+static irqreturn_t axe_irq(int irq, void *dev_id)
+{
+	disable_irq_nosync(irq);
+	atomic_inc(&master->disable);
+	atomic_inc(&master->irqcount);
+	wake_up_interruptible(&master->wait);
+	return IRQ_HANDLED;
+}
+
+static ssize_t axe_read(struct file *file, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long irqcount;
+	ssize_t rv;
+
+
+	if (file->private_data != master)
+		return -EINVAL;
+
+	if (count != sizeof(master->lastirqcount))
+		return -EINVAL;
+
+	add_wait_queue(&master->wait, &wait);
+
+	do {
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		irqcount = atomic_read(&master->irqcount);
+		if (irqcount != master->lastirqcount) {
+			if (copy_to_user(buf, &irqcount, count))
+				rv = -EFAULT;
+			else {
+				master->lastirqcount = irqcount;
+				rv = count;
+			}
+			break;
+		}
+
+		if (file->f_flags & O_NONBLOCK) {
+			rv = -EAGAIN;
+			break;
+		}
+
+		if (signal_pending(current)) {
+			rv = -ERESTARTSYS;
+			break;
+		}
+		if (atomic_read(&master->disable)) {
+			atomic_dec(&master->disable);
+			enable_irq(priv->irq);
+		}
+		schedule();
+	} while (1);
+
+	__set_current_state(TASK_RUNNING);
+	remove_wait_queue(&master->wait, &wait);
+
+	return rv;
+
+}
+
+static int axe_master_open(struct file *file)
+{
+	if (priv->master_opened)
+		return -EINVAL;
+
+	priv->master_opened++;
+	priv->opened++;
+	file->private_data = master;
+
+	return 0;
+}
+
+static int axe_client_open(struct file *file)
+{
+	priv->opened++;
+	file->private_data = priv;
+	return 0;
+}
+
+static int axe_open(struct inode *inode, struct file *file)
+{
+	int rv;
+
+	if (mutex_lock_interruptible(&priv->open_lock))
+		return -ERESTARTSYS;
+
+	if (iminor(inode) == 0)
+		rv = axe_master_open(file);
+	else
+		rv = axe_client_open(file);
+
+	mutex_unlock(&priv->open_lock);
+	return rv;
+}
+
+static int axe_release(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&priv->open_lock))
+		return -ERESTARTSYS;
+
+	if (file->private_data == master)
+		priv->master_opened = 0;
+	priv->opened--;
+	mutex_unlock(&priv->open_lock);
+
+	return 0;
+}
+
+static int axe_mmap_phys(struct vm_area_struct *vma, unsigned size,
+			unsigned phys)
+{
+	unsigned long requested_pages, actual_pages;
+
+	requested_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	actual_pages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+	if (requested_pages > actual_pages)
+		return -EINVAL;
+
+	return remap_pfn_range(vma,
+			       vma->vm_start,
+			       phys >> PAGE_SHIFT,
+			       vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
+static int axe_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	if (vma->vm_end < vma->vm_start)
+		return -EINVAL;
+
+	vma->vm_flags |= VM_IO | VM_RESERVED;
+	pgprot_val(vma->vm_page_prot) |= _PAGE_NO_CACHE | _PAGE_GUARDED;
+
+	switch (vma->vm_pgoff) {
+	case PGOFF_REGS:
+		return axe_mmap_phys(vma, pub->size_regs, pub->phys_regs);
+	case PGOFF_SRAM:
+		return axe_mmap_phys(vma, pub->size_sram, pub->phys_sram);
+	case PGOFF_DRAM:
+		return axe_mmap_phys(vma, pub->size_dram, pub->phys_dram);
+	}
+	return -EINVAL;
+
+}
+
+
+struct file_operations axe_file_ops = {
+	.owner = THIS_MODULE,
+	.open = axe_open,
+	.release = axe_release,
+	.read = axe_read,
+	.mmap = axe_mmap,
+};
+
+static void axe_cleanup(void);
+
+#define RNDUP(x, s) ((x+s-1) & ~(s-1))
+
+static int axe_probe(struct of_device *op,
+		const struct of_device_id *match)
+{
+	struct device_node *dn = op->node;
+	struct device *dev = &op->dev;
+	int rv = 0;
+	struct resource res;
+	long *axememinfo;
+
+	axememinfo = get_axe_mem();
+	if (!axememinfo[0] || !axememinfo[1]) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error getting reserved AXE dram area\n");
+		goto err;
+	}
+
+	pub = __va(axememinfo[0]);
+	memset(pub, 0, axememinfo[1]);
+	pub->size_dram = axememinfo[1];
+	pub->phys_dram = __pa(pub);
+
+	init_waitqueue_head(&master->wait);
+
+	priv->irq = NO_IRQ;
+	priv->dev = dev;
+
+	rv = of_address_to_resource(dn, 0, &res);
+	if (rv) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error parsing axe memory resource\n");
+		return rv;
+	}
+
+	priv->irq = irq_of_parse_and_map(dn, 0);
+	if (priv->irq == NO_IRQ) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error mapping irq\n");
+		return -EINVAL;
+	}
+	pub->phys_regs = res.start;
+	pub->size_regs = res.end - res.start + 1;
+
+	if (!devm_request_mem_region(dev, pub->phys_regs,
+				pub->size_regs, DRV_NAME)) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error requesting register memory region\n");
+		rv = -EBUSY;
+		goto err;
+	}
+
+	priv->kvirt_regs = devm_ioremap(dev, pub->phys_regs,
+				pub->size_regs);
+	if (!priv->kvirt_regs) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error mapping axe registers\n");
+		rv = -ENOMEM;
+		goto err;
+	}
+
+
+	priv->axe_clk = clk_get(dev, "axe_clk");
+	clk_enable(priv->axe_clk);
+
+	if (devm_request_irq(dev, priv->irq, &axe_irq, 0, DRV_NAME, priv)) {
+		printk(KERN_ERR DRV_NAME ": Error requesting irq\n");
+		rv = -EINVAL;
+		goto err;
+	}
+
+	dn = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-sram");
+	if (!dn) {
+		printk(KERN_ERR DRV_NAME ": "
+			"Error finding mpc512x-sram node in device tree\n");
+		rv = -EINVAL;
+		goto err;
+	}
+
+	rv = of_address_to_resource(dn, 0, &res);
+	of_node_put(dn);
+	if (rv) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error parsing sram memory resource\n");
+		return rv;
+	}
+
+	pub->phys_sram = res.start;
+	pub->size_sram = res.end - res.start + 1;
+
+	if (!devm_request_mem_region(dev, pub->phys_sram,
+				pub->size_sram, DRV_NAME)) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error requesting sram memory region\n");
+		rv = -EBUSY;
+		goto err;
+	}
+
+
+	priv->kvirt_sram = devm_ioremap(dev, pub->phys_sram,
+				pub->size_sram);
+	if (!priv->kvirt_sram)
+		return -ENOMEM;
+
+	mutex_init(&priv->open_lock);
+
+	priv->major = register_chrdev(0, DRV_NAME, &axe_file_ops);
+	if (priv->major < 0) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error registering char dev\n");
+		rv = priv->major;
+		goto err;
+	}
+
+	priv->axe_class = class_create(THIS_MODULE, "axectl");
+	device_create_drvdata(priv->axe_class, NULL,
+		MKDEV(priv->major, 0),
+		NULL, "axe-ctl");
+	device_create_drvdata(priv->axe_class, NULL,
+		MKDEV(priv->major, 1),
+		NULL, "axe");
+
+	flush_dcache_range((unsigned long)pub, \
+		(unsigned long)pub+pub->size_dram);
+	return rv;
+
+err:
+	axe_cleanup();
+	return rv;
+}
+
+static void axe_cleanup(void)
+{
+	device_destroy(priv->axe_class, MKDEV(priv->major, 0));
+	device_destroy(priv->axe_class, MKDEV(priv->major, 1));
+	class_destroy(priv->axe_class);
+
+	if (priv->major > 0)
+		unregister_chrdev(priv->major, DRV_NAME);
+
+	if (priv->irq != NO_IRQ) {
+		devm_free_irq(priv->dev, priv->irq, priv);
+		priv->irq = NO_IRQ;
+	}
+	if (priv->axe_clk) {
+		clk_disable(priv->axe_clk);
+		clk_put(priv->axe_clk);
+		priv->axe_clk = NULL;
+	}
+/*	kfree(priv); */
+}
+
+static int axe_remove(struct of_device *op)
+{
+	axe_cleanup();
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int axe_suspend(struct of_device *op, pm_message_t state)
+{
+	return 0; /* FIXME */
+}
+
+	static int axe_resume(struct of_device *op)
+{
+	return 0; /* FIXME */
+}
+#else
+#define axe_suspend NULL
+#define axe_resume NULL
+#endif
+
+static struct of_platform_driver axe_driver = {
+	.owner		= THIS_MODULE,
+	.name		= DRV_NAME,
+	.match_table	= axe_match,
+	.probe		= axe_probe,
+	.remove		= axe_remove,
+	.suspend	= axe_suspend,
+	.resume		= axe_resume,
+	.driver		= {
+		.name	= DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init axe_init(void)
+{
+	return of_register_platform_driver(&axe_driver);
+}
+
+static void __exit axe_exit(void)
+{
+	of_unregister_platform_driver(&axe_driver);
+}
+
+module_init(axe_init);
+module_exit(axe_exit);
+
+MODULE_AUTHOR("John Rigby <jrigby@freescale.com>");
+MODULE_DESCRIPTION("MPC512X AXE driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/arch/powerpc/platforms/512x/axe_dev.h b/arch/powerpc/platforms/512x/axe_dev.h
new file mode 100644
index 0000000..d54b951
--- /dev/null
+++ b/arch/powerpc/platforms/512x/axe_dev.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2007 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: John Rigby <jrigby@freescale.com>
+ *
+ * AXE Audio Processor driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _AXE_DEV_H_
+#define _AXE_DEV_H_
+
+/*
+ * this information is found at the
+ * beginning of the dram mmaped area
+ */
+struct axe_dev_pub {
+	unsigned long size_dram;
+	unsigned long phys_dram;
+	unsigned long size_sram;
+	unsigned long phys_sram;
+	unsigned long size_regs;
+	unsigned long phys_regs;
+};
+
+#define PGOFF_REGS 0
+#define PGOFF_SRAM 1
+#define PGOFF_DRAM 2
+
+extern unsigned long *get_axe_mem(void);
+
+#endif	/* _AXE_DEV_H_ */
diff --git a/arch/powerpc/platforms/512x/mpc512x_shared.c b/arch/powerpc/platforms/512x/mpc512x_shared.c
index a41cc2f..bfb0235 100644
--- a/arch/powerpc/platforms/512x/mpc512x_shared.c
+++ b/arch/powerpc/platforms/512x/mpc512x_shared.c
@@ -78,6 +78,7 @@ void __init mpc512x_init_IRQ(void)
 static struct of_device_id __initdata of_bus_ids[] = {
 	{ .compatible = "fsl,mpc5121-immr", },
 	{ .compatible = "fsl,mpc5121-localbus", },
+	{ .compatible = "fsl,mpc5121-mbx", },
 	{},
 };
 
@@ -249,3 +250,64 @@ void __init mpc5121_psc_lowlevel_clock_init(void)
 		}
 	iounmap(clockctl);
 }
+
+#ifdef CONFIG_AXEMBX_RESERVE_BOOL
+unsigned long axemem[2] = {
+	CONFIG_AXEMBX_RESERVE_START,
+	CONFIG_AXE_RESERVE_SIZE
+};
+
+unsigned long *get_axe_mem(void)
+{
+	return axemem;
+}
+EXPORT_SYMBOL(get_axe_mem);
+
+unsigned long mbxmem[2] = {
+	CONFIG_AXEMBX_RESERVE_START+CONFIG_AXE_RESERVE_SIZE,
+	CONFIG_MBX_RESERVE_SIZE
+};
+
+unsigned long *get_mbx_mem(void)
+{
+	return mbxmem;
+}
+EXPORT_SYMBOL(get_mbx_mem);
+#endif
+
+static int __init mpc512x_mbx_of_init(void)
+{
+	struct device_node *np;
+	struct platform_device *mbx_dev;
+	int ret;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-mbx");
+	if (np) {
+		struct resource r[2];
+		int irq;
+
+		memset(&r, 0, sizeof(r));
+
+		ret = of_address_to_resource(np, 0, &r[0]);
+		if (ret)
+			goto err;
+
+		irq = of_irq_to_resource(np, 0, &r[1]);
+		if (irq == NO_IRQ)
+			goto err;
+
+		printk(KERN_INFO "Reserved irq %d(0x%x) for MBX\n", irq, irq);
+
+		mbx_dev = platform_device_register_simple("mpc5121-mbx",
+				0, r, 2);
+		if (IS_ERR(mbx_dev)) {
+			ret = PTR_ERR(mbx_dev);
+			goto err;
+		}
+	}
+	return 0;
+err:
+	return ret;
+}
+
+arch_initcall(mpc512x_mbx_of_init);
-- 
1.6.0.90.g436ed

