From 219328c58f8a4c1522bc17f0aa0f05147ddeeeb5 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:27 +0800
Subject: [PATCH 11/25] MPC5121 PSC-Serial: implement hw handshake

Original patch taken from rev 4 board support ISO image:
 mpc5121ads-20081208_ltib-beta.iso
 http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

This patch adds hardware handshake functionality
to the 5121 serial driver.  Currently it is
implemented for 5121 only though this driver is
shared with 5200.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/boot/dts/mpc5121ads.dts |    6 +-
 drivers/serial/mpc52xx_uart.c        |  105 +++++++++++++++++++++++++++++++++-
 2 files changed, 106 insertions(+), 5 deletions(-)

diff --git a/arch/powerpc/boot/dts/mpc5121ads.dts b/arch/powerpc/boot/dts/mpc5121ads.dts
index 18d9da8..ee2ba23 100644
--- a/arch/powerpc/boot/dts/mpc5121ads.dts
+++ b/arch/powerpc/boot/dts/mpc5121ads.dts
@@ -391,10 +391,11 @@
 			port-number = <0>;
 			cell-index = <3>;
 			reg = <0x11300 0x100>;
-			interrupts = <40 0x8>;
+			interrupts = <40 0x8 71 0x8>;
 			interrupt-parent = < &ipic >;
 			rx-fifo-size = <16>;
 			tx-fifo-size = <16>;
+			nodcd;
 		};
 
 		// PSC3 in spi mode for MPC5121eADS off board MEDIA touch screen
@@ -439,10 +440,11 @@
 			port-number = <1>;
 			cell-index = <4>;
 			reg = <0x11400 0x100>;
-			interrupts = <40 0x8>;
+			interrupts = <40 0x8 32 0x8>;
 			interrupt-parent = < &ipic >;
 			rx-fifo-size = <16>;
 			tx-fifo-size = <16>;
+			nodcd;
 		};
 
 		// PSC4 in spi mode (eg ad1938 codec control
diff --git a/drivers/serial/mpc52xx_uart.c b/drivers/serial/mpc52xx_uart.c
index 503d09c..0e05fd7 100644
--- a/drivers/serial/mpc52xx_uart.c
+++ b/drivers/serial/mpc52xx_uart.c
@@ -110,6 +110,9 @@ static struct uart_port mpc52xx_uart_ports[MPC52xx_PSC_MAXNUM];
 #if defined(CONFIG_PPC_MERGE)
 /* lookup table for matching device nodes to index numbers */
 static struct device_node *mpc52xx_uart_nodes[MPC52xx_PSC_MAXNUM];
+int controlirq[MPC52xx_PSC_MAXNUM];
+int nodcd[MPC52xx_PSC_MAXNUM];
+int nocts[MPC52xx_PSC_MAXNUM];
 
 static void mpc52xx_uart_of_enumerate(void);
 #endif
@@ -120,6 +123,7 @@ static void mpc52xx_uart_of_enumerate(void);
 
 /* Forward declaration of the interruption handling routine */
 static irqreturn_t mpc52xx_uart_int(int irq, void *dev_id);
+static irqreturn_t mpc52xx_uart_control_int(int irq, void *dev_id);
 
 
 /* Simple macro to test if a port is console or not. This one is taken
@@ -300,6 +304,8 @@ static void mpc512x_psc_fifo_init(struct uart_port *port)
 	out_be32(&FIFO_512x(port)->rxalarm, 1);
 	out_be32(&FIFO_512x(port)->rximr, 0);
 
+	out_be16(&PSC(port)->mpc52xx_psc_imr, 0);
+
 	out_be32(&FIFO_512x(port)->tximr, MPC512x_PSC_FIFO_ALARM);
 	out_be32(&FIFO_512x(port)->rximr, MPC512x_PSC_FIFO_ALARM);
 }
@@ -346,19 +352,40 @@ static void mpc512x_psc_stop_rx(struct uart_port *port)
 static void mpc512x_psc_start_tx(struct uart_port *port)
 {
 	unsigned long tx_fifo_imr;
+	int idx = port - mpc52xx_uart_ports;
+	int acr = 0;
 
 	tx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);
 	tx_fifo_imr |= MPC512x_PSC_FIFO_ALARM;
 	out_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);
+
+	(void) in_8(&PSC(port)->mpc52xx_psc_ipcr);
+	if (!nodcd[idx])
+		acr |= MPC52xx_PSC_DCD;
+	if (!nocts[idx])
+		acr |= MPC52xx_PSC_CTS;
+	out_8(&PSC(port)->mpc52xx_psc_acr, acr);
+	out_be16(&PSC(port)->mpc52xx_psc_imr, MPC52xx_PSC_IMR_IPC);
 }
 
 static void mpc512x_psc_stop_tx(struct uart_port *port)
 {
 	unsigned long tx_fifo_imr;
+	int idx = port - mpc52xx_uart_ports;
+	int acr = 0;
 
 	tx_fifo_imr = in_be32(&FIFO_512x(port)->tximr);
 	tx_fifo_imr &= ~MPC512x_PSC_FIFO_ALARM;
 	out_be32(&FIFO_512x(port)->tximr, tx_fifo_imr);
+
+	(void) in_8(&PSC(port)->mpc52xx_psc_ipcr);
+	if (!nodcd[idx])
+		acr |= MPC52xx_PSC_DCD;
+	if (!nocts[idx])
+		acr |= MPC52xx_PSC_CTS;
+	out_8(&PSC(port)->mpc52xx_psc_acr, acr);
+	out_be16(&PSC(port)->mpc52xx_psc_imr, MPC52xx_PSC_IMR_IPC);
+
 }
 
 static void mpc512x_psc_rx_clr_irq(struct uart_port *port)
@@ -437,14 +464,36 @@ mpc52xx_uart_tx_empty(struct uart_port *port)
 static void
 mpc52xx_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
-	/* Not implemented */
+	struct mpc52xx_psc __iomem *psc = PSC(port);
+
+	/* only rts is implemented */
+	if (mctrl & TIOCM_RTS)
+		setbits8(&psc->op1, 1);
+	else
+		setbits8(&psc->op0, 1);
 }
 
 static unsigned int
 mpc52xx_uart_get_mctrl(struct uart_port *port)
 {
-	/* Not implemented */
-	return TIOCM_CTS | TIOCM_DSR | TIOCM_CAR;
+	int ret;
+	struct mpc52xx_psc __iomem *psc = PSC(port);
+	int idx = port - mpc52xx_uart_ports;
+	u8 bits;
+
+	/* DSR not implemented */
+	ret = TIOCM_DSR;
+
+	bits = in_8(&psc->ip);
+
+	if (nocts[idx] || (bits & MPC52xx_PSC_CTS) == 0)
+		ret |= TIOCM_CTS;
+
+	if (nodcd[idx] || (bits & MPC52xx_PSC_DCD) == 0)
+		ret |= TIOCM_CD;
+
+	return ret;
+
 }
 
 static void
@@ -508,6 +557,7 @@ static int
 mpc52xx_uart_startup(struct uart_port *port)
 {
 	struct mpc52xx_psc __iomem *psc = PSC(port);
+	int idx = port - mpc52xx_uart_ports;
 	int ret;
 
 	/* Request IRQ */
@@ -528,6 +578,12 @@ mpc52xx_uart_startup(struct uart_port *port)
 
 	psc_ops->fifo_init(port);
 
+	if (controlirq[idx] != NO_IRQ) {
+		ret = request_irq(controlirq[idx], mpc52xx_uart_control_int,
+			IRQF_DISABLED | IRQF_SAMPLE_RANDOM | IRQF_SHARED,
+			"mpc52xx_psc_uart_control", port);
+	}
+
 	out_8(&psc->command, MPC52xx_PSC_TX_ENABLE);
 	out_8(&psc->command, MPC52xx_PSC_RX_ENABLE);
 
@@ -538,6 +594,7 @@ static void
 mpc52xx_uart_shutdown(struct uart_port *port)
 {
 	struct mpc52xx_psc __iomem *psc = PSC(port);
+	int idx = port - mpc52xx_uart_ports;
 
 	/* Shut down the port.  Leave TX active if on a console port */
 	out_8(&psc->command, MPC52xx_PSC_RST_RX);
@@ -549,6 +606,8 @@ mpc52xx_uart_shutdown(struct uart_port *port)
 
 	/* Release interrupt */
 	free_irq(port->irq, port);
+	if (controlirq[idx] != NO_IRQ)
+		free_irq(controlirq[idx], port);
 }
 
 static void
@@ -832,6 +891,37 @@ mpc52xx_uart_int_tx_chars(struct uart_port *port)
 }
 
 static irqreturn_t
+mpc52xx_uart_control_int(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	int bits;
+	int rv = IRQ_NONE;
+	int idx = port - mpc52xx_uart_ports;
+
+	spin_lock(&port->lock);
+
+	bits = in_8(&PSC(port)->mpc52xx_psc_ipcr);
+
+	if (nodcd[idx])
+		bits &= ~MPC52xx_PSC_D_DCD;
+	if (nocts[idx])
+		bits &= ~MPC52xx_PSC_D_CTS;
+	if (bits & (MPC52xx_PSC_D_DCD | MPC52xx_PSC_D_CTS)) {
+		if (bits & MPC52xx_PSC_D_DCD)
+			uart_handle_dcd_change(port, !(bits & MPC52xx_PSC_DCD));
+		if (bits & MPC52xx_PSC_D_CTS)
+			uart_handle_cts_change(port, !(bits & MPC52xx_PSC_CTS));
+
+		wake_up_interruptible(&port->info->delta_msr_wait);
+		rv = IRQ_HANDLED;
+	}
+
+	spin_unlock(&port->lock);
+
+	return rv;
+}
+
+static irqreturn_t
 mpc52xx_uart_int(int irq, void *dev_id)
 {
 	struct uart_port *port = dev_id;
@@ -1293,6 +1383,12 @@ mpc52xx_uart_of_probe(struct of_device *op, const struct of_device_id *match)
 	if (!ret)
 		dev_set_drvdata(&op->dev, (void *)port);
 
+	controlirq[idx] = irq_of_parse_and_map(op->node, 1);
+	if (of_get_property(op->node, "nodcd", NULL))
+		nodcd[idx]++;
+	if (of_get_property(op->node, "nocts", NULL))
+		nocts[idx]++;
+
 	return ret;
 }
 
@@ -1300,11 +1396,14 @@ static int
 mpc52xx_uart_of_remove(struct of_device *op)
 {
 	struct uart_port *port = dev_get_drvdata(&op->dev);
+	int idx = port - mpc52xx_uart_ports;
 	dev_set_drvdata(&op->dev, NULL);
 
 	if (port) {
 		uart_remove_one_port(&mpc52xx_uart_driver, port);
 		irq_dispose_mapping(port->irq);
+		if (controlirq[idx] != NO_IRQ)
+			irq_dispose_mapping(controlirq[idx]);
 	}
 
 	return 0;
-- 
1.6.3.1

