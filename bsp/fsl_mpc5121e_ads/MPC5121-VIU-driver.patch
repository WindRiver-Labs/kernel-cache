From c9a6baa28b7e8a9f9b6d2a18a8d0e1f6c605161a Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:30 +0800
Subject: [PATCH 14/25] MPC5121: VIU driver

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

This driver is for VIU on MPC5121ADS Rev4.0, it implements
capture and overlay modes.

Signed-off-by: Hongjun Chen <hong-jun.chen@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/include/asm/mpc512x.h           |    6 +
 arch/powerpc/platforms/512x/clock.c          |   18 +
 arch/powerpc/platforms/512x/mpc512x_shared.c |   49 +
 drivers/media/video/Kconfig                  |   14 +
 drivers/media/video/Makefile                 |    1 +
 drivers/media/video/fsl-viu.c                | 1609 ++++++++++++++++++++++++++
 drivers/video/fsl-diu-fb.c                   |   14 +
 drivers/video/fsl-diu-fb.h                   |    5 +-
 8 files changed, 1715 insertions(+), 1 deletions(-)
 create mode 100644 drivers/media/video/fsl-viu.c

diff --git a/arch/powerpc/include/asm/mpc512x.h b/arch/powerpc/include/asm/mpc512x.h
index 9602e4a..c1ca8aa 100644
--- a/arch/powerpc/include/asm/mpc512x.h
+++ b/arch/powerpc/include/asm/mpc512x.h
@@ -128,5 +128,11 @@ extern int mpc512x_set_gpio_wakeup(unsigned int gpio_num,
 extern void mpc512x_pm_test_setup(void);
 #endif
 
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+extern void *fsl_diu_alloc(unsigned long size, unsigned long *phys);
+extern void fsl_diu_free(void *p, unsigned long size);
+extern void fsl_viu_init_io(void);
+#endif
+
 #endif /* __ASM_POWERPC_MPC512x_H__ */
 
diff --git a/arch/powerpc/platforms/512x/clock.c b/arch/powerpc/platforms/512x/clock.c
index 00e79ec..b95993e 100644
--- a/arch/powerpc/platforms/512x/clock.c
+++ b/arch/powerpc/platforms/512x/clock.c
@@ -297,6 +297,15 @@ static void diu_clk_calc(struct clk *clk)
 	clk->rate = rate;
 }
 
+static void viu_clk_calc(struct clk *clk)
+{
+	unsigned long rate;
+
+	rate = sys_clk.rate;
+	rate /= 2;
+	clk->rate = rate;
+}
+
 static void half_clk_calc(struct clk *clk)
 {
 	clk->rate = clk->parent->rate / 2;
@@ -417,6 +426,14 @@ static struct clk diu_clk = {
 	.calc = diu_clk_calc,
 };
 
+static struct clk viu_clk = {
+	.name = "viu_clk",
+	.flags = CLK_HAS_CTRL,
+	.reg = 1,
+	.bit = 18,
+	.calc = viu_clk_calc,
+};
+
 static struct clk axe_clk = {
 	.name = "axe_clk",
 	.flags = CLK_HAS_CTRL,
@@ -540,6 +557,7 @@ struct clk *rate_clks[] = {
 	&ref_clk,
 	&sys_clk,
 	&diu_clk,
+	&viu_clk,
 	&csb_clk,
 	&e300_clk,
 	&ips_clk,
diff --git a/arch/powerpc/platforms/512x/mpc512x_shared.c b/arch/powerpc/platforms/512x/mpc512x_shared.c
index d78a706..8c32236 100644
--- a/arch/powerpc/platforms/512x/mpc512x_shared.c
+++ b/arch/powerpc/platforms/512x/mpc512x_shared.c
@@ -312,3 +312,52 @@ err:
 }
 
 arch_initcall(mpc512x_mbx_of_init);
+
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+enum viu_io {
+	VIU_DATA0   = 0x12c,
+	VIU_DATA1   = 0x130,
+	VIU_DATA2   = 0x134,
+	VIU_DATA3   = 0x13c,
+	VIU_DATA4   = 0x140,
+	VIU_DATA5   = 0x144,
+	VIU_DATA6   = 0x164,
+	VIU_DATA7   = 0x154,
+	VIU_DATA8   = 0x168,
+	VIU_DATA9   = 0x16c,
+	VIU_PIX_CLK = 0x160,
+};
+
+void fsl_viu_init_io(void)
+{
+	struct device_node *np;
+	struct resource r;
+	u8 __iomem *iobase;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-ioctl");
+	if (!np) {
+		printk(KERN_ERR "can't find device node 'mpc5121-ioctl'\n");
+		return;
+	}
+
+	of_address_to_resource(np, 0, &r);
+	of_node_put(np);
+
+	iobase = (u8 *)ioremap(r.start, r.end - r.start + 1);
+	out_be32((u32 *)(iobase + VIU_DATA0), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA1), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA2), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA3), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA4), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA5), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA6), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA7), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA8), 0x81);
+	out_be32((u32 *)(iobase + VIU_DATA9), 0x81);
+	out_be32((u32 *)(iobase + VIU_PIX_CLK), 0x81);
+
+	iounmap(iobase);
+}
+EXPORT_SYMBOL(fsl_viu_init_io);
+
+#endif
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index f914577..9922dec 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -460,6 +460,20 @@ config VIDEO_UPD64083
 
 endmenu # encoder / decoder chips
 
+config VIDEO_VIU
+	tristate "Freescale VIU Video Driver"
+	depends on VIDEO_V4L2 && (PPC_MPC5121)
+	select VIDEOBUF_VMALLOC
+	select VIDEOBUF_DMA_SG
+	select FB_FSL_DIU
+	default y
+	---help---
+	  Enables a Freescale VIU video driver. This device captures video
+	  data, or overlay video on frame buffer DIU.
+
+	  Say Y here if you want to enable VIU device on MPC5121e Rev2+.
+	  In doubt, say N.
+
 config VIDEO_VIVI
 	tristate "Virtual Video Driver"
 	depends on VIDEO_DEV && VIDEO_V4L2 && !SPARC32 && !SPARC64
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 3e580e8..6f8bbd4 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -130,6 +130,7 @@ obj-$(CONFIG_USB_VICAM)         += usbvideo/
 obj-$(CONFIG_USB_QUICKCAM_MESSENGER)	+= usbvideo/
 obj-$(CONFIG_USB_S2255)		+= s2255drv.o
 
+obj-$(CONFIG_VIDEO_VIU)	+= fsl-viu.o
 obj-$(CONFIG_VIDEO_IVTV) += ivtv/
 obj-$(CONFIG_VIDEO_CX18) += cx18/
 
diff --git a/drivers/media/video/fsl-viu.c b/drivers/media/video/fsl-viu.c
new file mode 100644
index 0000000..3ceea43
--- /dev/null
+++ b/drivers/media/video/fsl-viu.c
@@ -0,0 +1,1609 @@
+/*
+ * Copyright 2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  Freescale VIU video driver
+ *
+ *  Authors: Hongjun Chen <hong-jun.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <media/v4l2-common.h>
+#include <media/videobuf-dma-sg.h>
+#include <media/v4l2-ioctl.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/of_platform.h>
+#include <asm/mpc512x.h>
+
+#define BUFFER_TIMEOUT     msecs_to_jiffies(500)  /* 0.5 seconds */
+
+static struct viu_reg reg_val;
+static char first = 1, dma_done;
+
+#define DRV_NAME	  "fsl_viu"
+#define VIU_MAJOR_VERSION 0
+#define VIU_MINOR_VERSION 4
+#define VIU_RELEASE 0
+#define VIU_VERSION KERNEL_VERSION(VIU_MAJOR_VERSION, VIU_MINOR_VERSION, \
+							VIU_RELEASE)
+
+/* Declare static vars that will be used as parameters */
+static unsigned int vid_limit = 4;	/* Video memory limit, in Mb */
+static struct video_device viu;		/* Video device */
+static int video_nr = -1;		/* /dev/videoN, -1 for autodetect */
+
+/* supported controls */
+static struct v4l2_queryctrl viu_qctrl[] = {
+	{
+		.id            = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 127,
+		.flags         = 0,
+	}, {
+		.id            = V4L2_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Contrast",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 0x1,
+		.default_value = 0x10,
+		.flags         = 0,
+	}, {
+		.id            = V4L2_CID_SATURATION,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Saturation",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 0x1,
+		.default_value = 127,
+		.flags         = 0,
+	}, {
+		.id            = V4L2_CID_HUE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Hue",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = 0,
+	}
+};
+
+static int qctl_regs[ARRAY_SIZE(viu_qctrl)];
+static int info_level;
+static struct list_head viu_devlist;
+
+#define dprintk(level, fmt, arg...)					\
+	do {								\
+		if (level <= info_level)				\
+			printk(KERN_DEBUG "viu: " fmt , ## arg);	\
+	} while (0)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+struct viu_fmt {
+	char  name[32];
+	u32   fourcc;          /* v4l2 format id */
+	u32   pixelformat;
+	int   depth;
+};
+
+static struct viu_fmt formats[] = {
+	{
+		.name		= "RGB-16 (5/B-6/G-5/R)",
+		.pixelformat	= V4L2_PIX_FMT_RGB565,
+		.depth		= 16,
+	}, {
+		.name		= "RGB-32 (A-R-G-B)",
+		.pixelformat	= V4L2_PIX_FMT_RGB32,
+		.depth		= 32,
+	}
+};
+
+struct viu_dev;
+struct viu_buf;
+
+/* buffer for one video frame */
+struct viu_buf {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+	struct viu_fmt *fmt;
+};
+
+struct viu_dmaqueue {
+	struct viu_dev         *dev;
+	struct list_head       active;
+	struct list_head       queued;
+	struct timer_list      timeout;
+};
+
+struct viu_dev {
+	struct list_head           viu_devlist;
+	struct mutex               lock;
+	spinlock_t                 slock;
+	int                        users;
+
+	/* various device info */
+	struct video_device        vfd;
+	struct viu_dmaqueue        vidq;
+	enum v4l2_field            capfield;
+
+	/* Hardware register area */
+	struct viu_reg 		   *vr;
+
+	/* Interrupt vector */
+	int 			   irq;
+
+	/* video overlay */
+	struct v4l2_framebuffer    ovbuf;
+	struct viu_fmt             *ovfmt;
+	unsigned int               ovenable;
+	enum v4l2_field            ovfield;
+
+	/* crop */
+	struct v4l2_rect           crop_current;
+
+	/* clock pointer */
+	struct clk *clk;
+};
+
+struct viu_reg {
+	u32 status_cfg;
+	u32 luminance;
+	u32 chroma_r;
+	u32 chroma_g;
+	u32 chroma_b;
+	u32 field_base_addr;
+	u32 dma_inc;
+	u32 picture_count;
+	u32 req_alarm;
+	u32 alpha;
+} __attribute__ ((packed));
+
+struct viu_status {
+	u32 field_irq;
+	u32 vsync_irq;
+	u32 hsync_irq;
+	u32 vstart_irq;
+	u32 dma_end_irq;
+	u32 error_irq;
+};
+
+struct viu_fh {
+	struct viu_dev             *dev;
+
+	/* video capture */
+	struct videobuf_queue      vb_vidq;
+
+	/* video overlay */
+	struct v4l2_window         win;
+	struct v4l2_clip           clips[1];
+
+	/* video capture */
+	struct viu_fmt      	   *fmt;
+	int               	   width, height, sizeimage;
+	enum v4l2_buf_type         type;
+};
+
+/* ------------------------------------------------------------------
+	Macro definitions of VIU registers
+   ------------------------------------------------------------------*/
+
+/* STATUS_CONFIG register */
+enum status_config {
+	SOFT_RST		= 1 << 0,
+
+	ERR_MASK		= 0x0f << 4,	/* Error code mask */
+	ERR_NO			= 0x00,		/* No error */
+	ERR_DMA_V		= 0x01 << 4,	/* DMA in vertical active */
+	ERR_DMA_VB		= 0x02 << 4,	/* DMA in vertical blanking */
+	ERR_LINE_TOO_LONG 	= 0x04 << 4,	/* Line too long */
+	ERR_TOO_MANG_LINES	= 0x05 << 4,	/* Too many lines in field */
+	ERR_LINE_TOO_SHORT	= 0x06 << 4,	/* Line too short */
+	ERR_NOT_ENOUGH_LINE	= 0x07 << 4,	/* Not enough lines in field */
+	ERR_FIFO_OVERFLOW	= 0x08 << 4,	/* FIFO overflow */
+	ERR_FIFO_UNDERFLOW	= 0x09 << 4,	/* FIFO underflow */
+	ERR_1bit_ECC		= 0x0a << 4,	/* One bit ECC error */
+	ERR_MORE_ECC		= 0x0b << 4,	/* Two/more bits ECC error */
+
+	INT_FIELD_EN		= 0x01 << 8,	/* Enable field interrupt */
+	INT_VSYNC_EN		= 0x01 << 9,	/* Enable vsync interrupt */
+	INT_HSYNC_EN		= 0x01 << 10,	/* Enable hsync interrupt */
+	INT_VSTART_EN		= 0x01 << 11,	/* Enable vstart interrupt */
+	INT_DMA_END_EN		= 0x01 << 12,	/* Enable DMA end interrupt */
+	INT_ERROR_EN		= 0x01 << 13,	/* Enable error interrupt */
+	INT_ECC_EN		= 0x01 << 14,	/* Enable ECC interrupt */
+
+	INT_FIELD_STATUS	= 0x01 << 16,	/* field interrupt status */
+	INT_VSYNC_STATUS	= 0x01 << 17,	/* vsync interrupt status */
+	INT_HSYNC_STATUS	= 0x01 << 18,	/* hsync interrupt status */
+	INT_VSTART_STATUS	= 0x01 << 19,	/* vstart interrupt status */
+	INT_DMA_END_STATUS	= 0x01 << 20,	/* DMA end interrupt status */
+	INT_ERROR_STATUS	= 0x01 << 21,	/* error interrupt status */
+
+	DMA_ACT			= 0x01 << 27,	/* Enable DMA transfer */
+	FIELD_NO		= 0x01 << 28,	/* Field number */
+	DITHER_ON		= 0x01 << 29,	/* Dithering is on */
+	ROUND_ON		= 0x01 << 30,	/* Round is on */
+	MODE_32BIT		= 0x01 << 31,	/* Data in RGBa888,
+						 * 0 in RGB565
+						 */
+};
+
+
+#define norm_maxw()	1024
+#define norm_maxh()	768
+
+static int NUM_FORMATS = sizeof(formats)/sizeof(struct viu_fmt);
+static struct viu_status irqs;
+
+static irqreturn_t viu_irq(int irq, void *dev_id);
+inline void viu_default_settings(struct viu_reg *viu_reg, struct viu_reg *val);
+
+struct viu_fmt *format_by_fourcc(int fourcc)
+{
+	int i, j = NUM_FORMATS;
+
+	for (i = 0; i < j; i++) {
+		if (formats[i].pixelformat == fourcc)
+			return formats + i;
+	}
+
+	dprintk(0, "unknown pixelformat:'%4.4s'\n", (char *)&fourcc);
+	return NULL;
+}
+
+void start_dma(struct viu_dev *dev)
+{
+	struct viu_reg *vr = dev->vr;
+
+	/* Enable DMA operation */
+	vr->status_cfg = SOFT_RST; iosync();
+	vr->status_cfg = INT_FIELD_EN; iosync();
+	return;
+}
+
+void stop_dma(struct viu_dev *dev)
+{
+	struct viu_reg *vr = dev->vr;
+
+	vr->status_cfg = 0;
+	return;
+}
+
+static int restart_video_queue(struct viu_dmaqueue *vidq)
+{
+	struct viu_buf *buf, *prev;
+
+	dprintk(1, "%s vidq=0x%08lx\n", __func__, (unsigned long)vidq);
+	if (!list_empty(&vidq->active)) {
+		buf = list_entry(vidq->active.next, struct viu_buf, vb.queue);
+		dprintk(2, "restart_queue [%p/%d]: restart dma\n",
+			buf, buf->vb.i);
+
+		stop_dma(vidq->dev);
+
+		/* cancel all outstanding capture requests */
+		list_for_each_entry_safe(buf, prev, &vidq->active, vb.queue) {
+			list_del(&buf->vb.queue);
+			buf->vb.state = VIDEOBUF_ERROR;
+			wake_up(&buf->vb.done);
+		}
+		mod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);
+		return 0;
+	}
+
+	prev = NULL;
+	for (;;) {
+		if (list_empty(&vidq->queued))
+			return 0;
+		buf = list_entry(vidq->queued.next, struct viu_buf, vb.queue);
+		if (NULL == prev) {
+			list_del(&buf->vb.queue);
+			list_add_tail(&buf->vb.queue, &vidq->active);
+
+			dprintk(1, "Restarting video dma\n");
+			stop_dma(vidq->dev);
+			start_dma(vidq->dev);
+
+			buf->vb.state = VIDEOBUF_ACTIVE;
+			mod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);
+			dprintk(2, "[%p/%d] restart_queue - first active\n",
+				buf, buf->vb.i);
+
+		} else if (prev->vb.width  == buf->vb.width  &&
+			   prev->vb.height == buf->vb.height &&
+			   prev->fmt       == buf->fmt) {
+			list_del(&buf->vb.queue);
+			list_add_tail(&buf->vb.queue, &vidq->active);
+			buf->vb.state = VIDEOBUF_ACTIVE;
+			dprintk(2, "[%p/%d] restart_queue - move to active\n",
+				buf, buf->vb.i);
+		} else {
+			return 0;
+		}
+		prev = buf;
+	}
+}
+
+static void viu_vid_timeout(unsigned long data)
+{
+	struct viu_dev *dev = (struct viu_dev *)data;
+	struct viu_buf *buf;
+	struct viu_dmaqueue *vidq = &dev->vidq;
+
+	while (!list_empty(&vidq->active)) {
+		buf = list_entry(vidq->active.next, struct viu_buf, vb.queue);
+		list_del(&buf->vb.queue);
+		buf->vb.state = VIDEOBUF_ERROR;
+		wake_up(&buf->vb.done);
+		printk("viu/0: [%p/%d] timeout\n", buf, buf->vb.i);
+	}
+
+	restart_video_queue(vidq);
+}
+
+/* ------------------------------------------------------------------
+	Videobuf operations
+   ------------------------------------------------------------------*/
+static int buffer_setup(struct videobuf_queue *vq, unsigned int *count,
+			unsigned int *size)
+{
+	struct viu_fh *fh = vq->priv_data;
+
+	*size = fh->width * fh->height * fh->fmt->depth >> 3;
+	if (0 == *count)
+		*count = 32;
+
+	while (*size * *count > vid_limit * 1024 * 1024)
+		(*count)--;
+
+	dprintk(1, "%s, count=%d, size=%d\n", __func__, *count, *size);
+	return 0;
+}
+
+static void free_buffer(struct videobuf_queue *vq, struct viu_buf *buf)
+{
+	struct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);
+
+	if (in_interrupt())
+		BUG();
+
+	videobuf_waiton(&buf->vb, 0, 0);
+
+	/* free dma buffer */
+	if (dma->vmalloc) {
+		fsl_diu_free(dma->vmalloc, buf->vb.size);
+		dma->vmalloc = NULL;
+	}
+
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
+}
+
+inline int buffer_activate(struct viu_dev *dev, struct viu_buf *buf)
+{
+	struct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);
+	struct viu_reg *vr = dev->vr;
+	int bpp;
+	static int cfirst = 1;
+
+	/* setup the DMA base address */
+	reg_val.field_base_addr = dma->bus_addr;
+
+	if (cfirst) {
+		cfirst = 0;
+		dprintk(2, "buffer_activate buf=%p\n", buf);
+		buf->vb.state = VIDEOBUF_ACTIVE;
+
+		/* interlace is on in default, set horizontal DMA increment */
+		bpp = buf->fmt->depth >> 3;
+		reg_val.status_cfg = 0;
+		switch (bpp) {
+		case 2:
+			reg_val.status_cfg &= ~MODE_32BIT;
+			reg_val.dma_inc = buf->vb.width * 2;
+			break;
+		case 4:
+			reg_val.status_cfg |= MODE_32BIT;
+			reg_val.dma_inc = buf->vb.width * 4;
+			break;
+		default:
+			dprintk(0, "doesn't support color depth(%d)\n",
+				bpp * 8);
+			return -EINVAL;
+		}
+
+		dev->capfield = buf->vb.field;
+
+		/* setup dma interlace */
+		if (!V4L2_FIELD_HAS_BOTH(buf->vb.field))
+			reg_val.dma_inc = 0;
+
+		/* setup picture_count register */
+		reg_val.picture_count = (buf->vb.height / 2) << 16 |
+					buf->vb.width;
+
+		reg_val.status_cfg |= DMA_ACT | INT_DMA_END_EN | INT_FIELD_EN;
+
+		vr->field_base_addr = reg_val.field_base_addr;
+		vr->dma_inc = reg_val.dma_inc;
+		vr->picture_count = reg_val.picture_count;
+		viu_default_settings(vr, &reg_val);
+		iosync();
+		mod_timer(&dev->vidq.timeout, jiffies + BUFFER_TIMEOUT);
+		return 0;
+	}
+
+	vr->field_base_addr = reg_val.field_base_addr;
+	vr->picture_count = reg_val.picture_count;
+	vr->dma_inc = reg_val.dma_inc;
+	vr->status_cfg = (vr->status_cfg &
+			0xffc0ffff) |
+			INT_FIELD_STATUS |
+			INT_DMA_END_STATUS |
+			INT_VSYNC_STATUS |
+			reg_val.status_cfg;
+
+	iosync();
+	mod_timer(&dev->vidq.timeout, jiffies + BUFFER_TIMEOUT);
+
+	return 0;
+}
+
+static int buffer_prepare(struct videobuf_queue *vq,
+			  struct videobuf_buffer *vb,
+			  enum v4l2_field field)
+{
+	struct viu_fh  *fh  = vq->priv_data;
+	struct viu_buf *buf = container_of(vb, struct viu_buf, vb);
+	int rc;
+
+	BUG_ON(NULL == fh->fmt);
+	if (fh->width  < 48 || fh->width  > norm_maxw() ||
+	    fh->height < 32 || fh->height > norm_maxh())
+		return -EINVAL;
+	buf->vb.size = (fh->width * fh->height * fh->fmt->depth) >> 3;
+	if (0 != buf->vb.baddr  &&  buf->vb.bsize < buf->vb.size)
+		return -EINVAL;
+
+	if (buf->fmt       != fh->fmt	 ||
+	    buf->vb.width  != fh->width  ||
+	    buf->vb.height != fh->height ||
+	    buf->vb.field  != field) {
+		buf->fmt       = fh->fmt;
+		buf->vb.width  = fh->width;
+		buf->vb.height = fh->height;
+		buf->vb.field  = field;
+	}
+
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		/* ??? FIXME Need to make sure that pointer 'vb->priv' has
+		 * been allocated one memory for this dmabuffer
+		 */
+		struct videobuf_dmabuf *dma = videobuf_to_dma(&buf->vb);
+		unsigned long dma_addr;
+
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc != 0)
+			goto fail;
+
+		buf->vb.width  = fh->width;
+		buf->vb.height = fh->height;
+		buf->vb.field  = field;
+		buf->fmt       = fh->fmt;
+
+		dma->vmalloc = fsl_diu_alloc(buf->vb.size, &dma_addr);
+		if (!dma->vmalloc) {
+			dprintk(0, "failed to alloc dma buffer for video!\n");
+			rc = -ENOMEM;
+			goto fail;
+		}
+
+		dma->bus_addr = dma_addr;
+	}
+
+	buf->vb.state = VIDEOBUF_PREPARED;
+	return 0;
+
+fail:
+	free_buffer(vq, buf);
+	return rc;
+}
+
+static void buffer_queue(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+{
+	struct viu_buf       *buf     = container_of(vb, struct viu_buf, vb);
+	struct viu_fh        *fh      = vq->priv_data;
+	struct viu_dev       *dev     = fh->dev;
+	struct viu_dmaqueue  *vidq    = &dev->vidq;
+	struct viu_buf 	     *prev;
+
+	if (!list_empty(&vidq->queued)) {
+		dprintk(1, "adding vb queue=0x%08lx\n",
+				(unsigned long)&buf->vb.queue);
+		dprintk(1, "vidq pointer 0x%p, queued 0x%p\n",
+				vidq, &vidq->queued);
+		dprintk(1, "dev %p, queued: self %p, next %p, head %p\n",
+			dev, &vidq->queued, vidq->queued.next,
+			vidq->queued.prev);
+		list_add_tail(&buf->vb.queue, &vidq->queued);
+		buf->vb.state = VIDEOBUF_QUEUED;
+		dprintk(2, "[%p/%d] buffer_queue - append to queued\n",
+			buf, buf->vb.i);
+	} else if (list_empty(&vidq->active)) {
+		dprintk(1, "adding vb active=0x%08lx\n",
+				(unsigned long)&buf->vb.queue);
+		list_add_tail(&buf->vb.queue, &vidq->active);
+		buf->vb.state = VIDEOBUF_ACTIVE;
+		mod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);
+		dprintk(2, "[%p/%d] buffer_queue - first active\n",
+			buf, buf->vb.i);
+
+		buffer_activate(dev, buf);
+	} else {
+		dprintk(1, "adding vb queue2=0x%08lx\n",
+				(unsigned long)&buf->vb.queue);
+		prev = list_entry(vidq->active.prev, struct viu_buf, vb.queue);
+		if (prev->vb.width  == buf->vb.width  &&
+		    prev->vb.height == buf->vb.height &&
+		    prev->fmt       == buf->fmt) {
+			list_add_tail(&buf->vb.queue, &vidq->active);
+			buf->vb.state = VIDEOBUF_ACTIVE;
+			dprintk(2, "[%p/%d] buffer_queue - append to active\n",
+				buf, buf->vb.i);
+		} else {
+			list_add_tail(&buf->vb.queue, &vidq->queued);
+			buf->vb.state = VIDEOBUF_QUEUED;
+			dprintk(2, "[%p/%d] buffer_queue - first queued\n",
+				buf, buf->vb.i);
+		}
+	}
+}
+
+static void buffer_release(struct videobuf_queue *vq,
+				struct videobuf_buffer *vb)
+{
+	struct viu_buf *buf  = container_of(vb, struct viu_buf, vb);
+	struct viu_fh  *fh   = vq->priv_data;
+	struct viu_dev *dev  = (struct viu_dev *)fh->dev;
+
+	stop_dma(dev);
+	free_buffer(vq, buf);
+}
+
+static struct videobuf_queue_ops viu_video_qops = {
+	.buf_setup      = buffer_setup,
+	.buf_prepare    = buffer_prepare,
+	.buf_queue      = buffer_queue,
+	.buf_release    = buffer_release,
+};
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap(struct file *file, void *priv,
+					struct v4l2_capability *cap)
+{
+	strcpy(cap->driver, "viu");
+	strcpy(cap->card, "viu");
+	cap->version = VIU_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_STREAMING     |
+				V4L2_CAP_VIDEO_OVERLAY |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt(struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	int index = f->index;
+
+	if (f->index > NUM_FORMATS)
+		return -EINVAL;
+
+	strlcpy(f->description, formats[index].name, sizeof(f->description));
+	f->pixelformat = formats[index].fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct viu_fh *fh = priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->pixelformat;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage 	= fh->sizeimage;
+	return 0;
+}
+
+static int vidioc_try_fmt_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct viu_fmt *fmt;
+	enum v4l2_field field;
+	unsigned int maxw, maxh;
+
+	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+	if (!fmt) {
+		dprintk(1, "Fourcc format (0x%08x) invalid.",
+			f->fmt.pix.pixelformat);
+		return -EINVAL;
+	}
+
+	field = f->fmt.pix.field;
+
+	if (field == V4L2_FIELD_ANY) {
+		field = V4L2_FIELD_INTERLACED;
+	} else if (V4L2_FIELD_INTERLACED != field) {
+		dprintk(1, "Field type invalid.\n");
+		return -EINVAL;
+	}
+
+	maxw  = norm_maxw();
+	maxh  = norm_maxh();
+
+	f->fmt.pix.field = field;
+	if (f->fmt.pix.height < 32)
+		f->fmt.pix.height = 32;
+	if (f->fmt.pix.height > maxh)
+		f->fmt.pix.height = maxh;
+	if (f->fmt.pix.width < 48)
+		f->fmt.pix.width = 48;
+	if (f->fmt.pix.width > maxw)
+		f->fmt.pix.width = maxw;
+	f->fmt.pix.width &= ~0x03;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fmt->depth) >> 3;
+
+	return 0;
+}
+
+static int vidioc_s_fmt_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct viu_fh *fh = priv;
+	int ret;
+
+	ret = vidioc_try_fmt_cap(file, fh, f);
+	if (ret < 0)
+		return ret;
+
+	fh->fmt           = format_by_fourcc(f->fmt.pix.pixelformat);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->sizeimage     = f->fmt.pix.sizeimage;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+	dprintk(1, "set to pixelformat '%4.4s'\n", (char *)&fh->fmt->name);
+	return 0;
+}
+
+static int vidioc_g_fmt_overlay(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct viu_fh *fh = priv;
+	f->fmt.win = fh->win;
+	return 0;
+}
+
+static int verify_preview(struct viu_dev *dev, struct v4l2_window *win)
+{
+	enum v4l2_field field;
+	int maxw, maxh;
+
+	if (NULL == dev->ovbuf.base)
+		return -EINVAL;
+	if (NULL == dev->ovfmt)
+		return -EINVAL;
+	if (win->w.width < 48 || win->w.height < 32)
+		return -EINVAL;
+
+	field = win->field;
+	maxw  = dev->crop_current.width;
+	maxh  = dev->crop_current.height;
+
+	if (V4L2_FIELD_ANY == field) {
+		field = (win->w.height > maxh/2)
+			? V4L2_FIELD_INTERLACED
+			: V4L2_FIELD_TOP;
+	}
+	switch (field) {
+	case V4L2_FIELD_TOP:
+	case V4L2_FIELD_BOTTOM:
+		maxh = maxh / 2;
+		break;
+	case V4L2_FIELD_INTERLACED:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	win->field = field;
+	if (win->w.width > maxw)
+		win->w.width = maxw;
+	if (win->w.height > maxh)
+		win->w.height = maxh;
+	return 0;
+}
+
+static int start_preview(struct viu_dev *dev, struct viu_fh *fh)
+{
+	int bpp;
+
+	dprintk(0, "start_preview %dx%d %s\n",
+		fh->win.w.width, fh->win.w.height, dev->ovfmt->name);
+
+	reg_val.status_cfg = 0;
+
+	/* setup window */
+	reg_val.picture_count = (fh->win.w.height / 2) << 16 |
+				fh->win.w.width;
+
+	/* setup color depth and dma increment */
+	bpp = dev->ovfmt->depth / 8;
+	switch (bpp) {
+	case 2:
+		reg_val.status_cfg &= ~MODE_32BIT;
+		reg_val.dma_inc = fh->win.w.width * 2;
+		break;
+	case 4:
+		reg_val.status_cfg |= MODE_32BIT;
+		reg_val.dma_inc = fh->win.w.width * 4;
+		break;
+	default:
+		dprintk(0, "device doesn't support color depth(%d)\n",
+			bpp * 8);
+		return -EINVAL;
+	}
+
+	dev->ovfield = fh->win.field;
+	if (!V4L2_FIELD_HAS_BOTH(dev->ovfield))
+		reg_val.dma_inc = 0;
+
+	reg_val.status_cfg |= DMA_ACT | INT_DMA_END_EN | INT_FIELD_EN;
+
+	/* setup the base address of overlay buffer */
+	reg_val.field_base_addr = (u32)dev->ovbuf.base;
+
+	/* start dma */
+	dev->ovenable = 1;
+	start_dma(dev);
+	return 0;
+}
+
+static int stop_preview(struct viu_dev *dev, struct viu_fh *fh)
+{
+	stop_dma(dev);
+	return 0;
+}
+
+static int vidioc_s_fmt_overlay(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct viu_fh  *fh  = priv;
+	struct viu_dev *dev = (struct viu_dev *)fh->dev;
+	unsigned long  flags;
+	int err;
+
+	err = verify_preview(dev, &f->fmt.win);
+	if (0 != err)
+		return err;
+
+	mutex_lock(&dev->lock);
+	fh->win = f->fmt.win;
+
+	spin_lock_irqsave(&dev->slock, flags);
+	stop_preview(dev, fh);
+	start_preview(dev, fh);
+	spin_unlock_irqrestore(&dev->slock, flags);
+	mutex_unlock(&dev->lock);
+
+	return 0;
+}
+
+static int vidioc_try_fmt_overlay(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	return 0;
+}
+
+int vidioc_g_fbuf(struct file *file, void *priv, struct v4l2_framebuffer *arg)
+{
+	struct viu_fh  *fh = priv;
+	struct viu_dev *dev = fh->dev;
+	struct v4l2_framebuffer *fb = arg;
+
+	*fb = dev->ovbuf;
+	fb->capability = V4L2_FBUF_CAP_LIST_CLIPPING;
+	return 0;
+}
+
+int vidioc_s_fbuf(struct file *file, void *priv, struct v4l2_framebuffer *arg)
+{
+	struct viu_fh  *fh = priv;
+	struct viu_dev *dev = fh->dev;
+	struct v4l2_framebuffer *fb = arg;
+	struct viu_fmt *fmt;
+
+	if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	/* check args */
+	fmt = format_by_fourcc(fb->fmt.pixelformat);
+	if (NULL == fmt)
+		return -EINVAL;
+
+	/* ok, accept it */
+	dev->ovbuf = *fb;
+	dev->ovfmt = fmt;
+	if (0 == dev->ovbuf.fmt.bytesperline)
+		dev->ovbuf.fmt.bytesperline =
+			dev->ovbuf.fmt.width * fmt->depth / 8;
+	return 0;
+}
+
+static int vidioc_reqbufs(struct file *file, void *priv,
+				struct v4l2_requestbuffers *p)
+{
+	struct viu_fh *fh = priv;
+
+	return videobuf_reqbufs(&fh->vb_vidq, p);
+}
+
+static int vidioc_querybuf(struct file *file, void *priv,
+					struct v4l2_buffer *p)
+{
+	struct viu_fh *fh = priv;
+
+	return videobuf_querybuf(&fh->vb_vidq, p);
+}
+
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct viu_fh *fh = priv;
+
+	return videobuf_qbuf(&fh->vb_vidq, p);
+}
+
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct viu_fh *fh = priv;
+
+	return videobuf_dqbuf(&fh->vb_vidq, p,
+				file->f_flags & O_NONBLOCK);
+}
+
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct viu_fh *fh = priv;
+
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+
+	return videobuf_streamon(&fh->vb_vidq);
+}
+
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct viu_fh  *fh = priv;
+
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
+
+	return videobuf_streamoff(&fh->vb_vidq);
+}
+
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
+{
+	return 0;
+}
+
+/* only one input in this sample driver */
+static int vidioc_enum_input(struct file *file, void *priv,
+					struct v4l2_input *inp)
+{
+	if (inp->index != 0)
+		return -EINVAL;
+
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_NTSC_M;
+	strcpy(inp->name, "Camera");
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+{
+	*i = 0;
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
+	return 0;
+}
+
+/* --- controls ---------------------------------------------- */
+static int vidioc_queryctrl(struct file *file, void *priv,
+				struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(viu_qctrl); i++)
+		if (qc->id && qc->id == viu_qctrl[i].id) {
+			memcpy(qc, &(viu_qctrl[i]), sizeof(*qc));
+			return 0;
+		}
+
+	return -EINVAL;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(viu_qctrl); i++)
+		if (ctrl->id == viu_qctrl[i].id) {
+			ctrl->value = qctl_regs[i];
+			return 0;
+		}
+
+	return -EINVAL;
+}
+static int vidioc_s_ctrl(struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(viu_qctrl); i++)
+		if (ctrl->id == viu_qctrl[i].id) {
+			if (ctrl->value < viu_qctrl[i].minimum
+				|| ctrl->value > viu_qctrl[i].maximum)
+					return -ERANGE;
+			qctl_regs[i] = ctrl->value;
+			return 0;
+		}
+	return -EINVAL;
+}
+
+inline void viu_activate_next_buf(struct viu_dev *dev,
+				struct viu_dmaqueue *viuq)
+{
+	struct viu_dmaqueue *vidq = viuq;
+	struct viu_buf *buf;
+
+	/* launch another DMA operation for an active/queued buffer */
+	if (!list_empty(&vidq->active)) {
+		buf = list_entry(vidq->active.next, struct viu_buf,
+					vb.queue);
+		dprintk(1, "start another queued buffer.\n");
+		buffer_activate(dev, buf);
+	} else if (!list_empty(&vidq->queued)) {
+		buf = list_entry(vidq->queued.next, struct viu_buf,
+					vb.queue);
+		list_del(&buf->vb.queue);
+
+		dprintk(1, "start another queued buffer.\n");
+		list_add_tail(&buf->vb.queue, &vidq->active);
+		buf->vb.state = VIDEOBUF_ACTIVE;
+		buffer_activate(dev, buf);
+	}
+}
+
+inline void viu_default_settings(struct viu_reg *viu_reg, struct viu_reg *val)
+{
+	struct viu_reg *vr = viu_reg;
+
+	vr->status_cfg = 0;
+	iosync();
+	vr->luminance = 0x9512A254;
+	vr->chroma_r = 0x03310000;
+	vr->chroma_g = 0x06600F38;
+	vr->chroma_b = 0x00000409;
+	vr->alpha = 0x000000ff;
+	vr->req_alarm = 0x00000090;
+	vr->status_cfg = (vr->status_cfg & 0xffc0ffff) |
+			(INT_FIELD_STATUS | INT_VSYNC_STATUS |
+			INT_HSYNC_STATUS | INT_VSTART_STATUS |
+			INT_DMA_END_STATUS | INT_ERROR_STATUS |
+			val->status_cfg);
+	dprintk(1, "status reg: 0x%08x, fb base: 0x%08x\n",
+		vr->status_cfg, vr->field_base_addr);
+}
+
+inline void viu_activate_overlay(struct viu_reg *viu_reg)
+{
+	struct viu_reg *vr = viu_reg;
+
+	vr->field_base_addr = reg_val.field_base_addr;
+	vr->dma_inc = reg_val.dma_inc;
+	vr->picture_count = reg_val.picture_count;
+	viu_default_settings(vr, &reg_val);
+}
+
+/* process all VIU interrupt sources */
+static irqreturn_t viu_irq(int irq, void *dev_id)
+{
+	struct viu_dev *dev  = (struct viu_dev *)dev_id;
+	struct viu_reg *vr = dev->vr;
+	struct viu_dmaqueue *vidq = &dev->vidq;
+	struct viu_buf *buf;
+	u32 status = vr->status_cfg;
+	u32 error, field_num, need_two;
+
+	/* Clear interrupt bits and error flags */
+	if (status & INT_ERROR_STATUS) {
+		irqs.error_irq++;
+		error = status & ERR_MASK;
+		if (error)
+			dprintk(1, "Err: error(%d), times:%d!\n",
+				error >> 4, irqs.error_irq);
+		vr->status_cfg = (status & 0xFFC0FFFF) | 0x00200000;
+		iosync();
+	}
+
+	if (status & INT_DMA_END_STATUS) {
+		irqs.dma_end_irq++;
+		dma_done = 1;
+		dprintk(2, "VIU DMA end interrupt times: %d\n",
+						irqs.dma_end_irq);
+	}
+
+	if (status & INT_HSYNC_STATUS)
+		irqs.hsync_irq++;
+
+	if (status & INT_FIELD_STATUS) {
+		irqs.field_irq++;
+		dprintk(2, "VIU field interrupt times: %d\n", irqs.field_irq);
+	}
+
+	if (status & INT_VSTART_STATUS)
+		irqs.vstart_irq++;
+
+	if (status & INT_VSYNC_STATUS) {
+		irqs.vsync_irq++;
+		dprintk(2, "VIU vsync interrupt times: %d\n", irqs.vsync_irq);
+	}
+
+	/* complete one field */
+	field_num = status & FIELD_NO;
+	need_two = V4L2_FIELD_HAS_BOTH(dev->capfield);
+
+	vr->status_cfg = (vr->status_cfg & 0xffc0ffff) |
+			INT_FIELD_STATUS | INT_VSYNC_STATUS
+			| INT_HSYNC_STATUS | INT_VSTART_STATUS
+			| INT_DMA_END_STATUS | INT_ERROR_STATUS;
+	iosync();
+
+	dprintk(2, "irq status: 0x%08x\n", status);
+	if (status & INT_FIELD_STATUS) {
+		if (first) {
+			if (field_num == 0) {
+				first = 0;
+
+				if (dev->ovenable) /* overlay mode */
+					viu_activate_overlay(vr);
+				else /* capture mode */
+					viu_activate_next_buf(dev, vidq);
+
+				iosync();
+			}
+			return IRQ_HANDLED;
+		} else if (dev->ovenable) {
+			/* overlay mode */
+			if (!dma_done && (status & INT_VSYNC_STATUS)) {
+				vr->status_cfg = (vr->status_cfg &
+						0xffc0ffff) |
+						INT_FIELD_STATUS |
+						INT_VSYNC_STATUS |
+						INT_HSYNC_STATUS |
+						INT_VSTART_STATUS |
+						INT_DMA_END_STATUS |
+						INT_ERROR_STATUS |
+						reg_val.status_cfg;
+				return IRQ_HANDLED;
+			}
+
+			if (dma_done) {
+				dma_done = 0;
+				if (field_num == 0) {
+					vr->field_base_addr =
+						reg_val.field_base_addr;
+					vr->picture_count =
+						reg_val.picture_count;
+					iosync();
+				} else {
+					vr->field_base_addr =
+						reg_val.field_base_addr +
+						reg_val.dma_inc;
+					vr->picture_count =
+						reg_val.picture_count;
+					iosync();
+				}
+
+				vr->dma_inc = reg_val.dma_inc;
+				vr->status_cfg = (vr->status_cfg &
+						0xffc0ffff) |
+						INT_FIELD_STATUS |
+						INT_VSYNC_STATUS |
+						INT_HSYNC_STATUS |
+						INT_VSTART_STATUS |
+						INT_DMA_END_STATUS |
+						INT_ERROR_STATUS |
+						reg_val.status_cfg;
+				iosync();
+			}
+		} else {
+			/* Capture mode */
+			if (!dma_done) {
+				vr->status_cfg = (vr->status_cfg &
+						0xffc0ffff) |
+						INT_FIELD_STATUS |
+						INT_VSYNC_STATUS |
+						INT_HSYNC_STATUS |
+						INT_VSTART_STATUS |
+						INT_DMA_END_STATUS |
+						INT_ERROR_STATUS |
+						reg_val.status_cfg;
+				iosync();
+				return IRQ_HANDLED;
+			}
+
+			/* find one buffer for next dma operation */
+			dma_done = 0;
+			if (!list_empty(&vidq->active)) {
+				if (field_num == 0 && need_two) {
+					vr->field_base_addr =
+						reg_val.field_base_addr +
+						reg_val.dma_inc;
+					vr->status_cfg = (vr->status_cfg &
+						0xffc0ffff) |
+						INT_FIELD_STATUS |
+						INT_VSYNC_STATUS |
+						INT_HSYNC_STATUS |
+						INT_VSTART_STATUS |
+						INT_DMA_END_STATUS |
+						INT_ERROR_STATUS |
+						reg_val.status_cfg;
+					iosync();
+					return IRQ_HANDLED;
+				}
+
+				buf = list_entry(vidq->active.next,
+							struct viu_buf,
+							vb.queue);
+				list_del(&buf->vb.queue);
+				buf->vb.state = VIDEOBUF_DONE;
+				wake_up(&buf->vb.done);
+				dprintk(1, "viu/0: [%p/%d] dma complete\n",
+						buf, buf->vb.i);
+			}
+
+			/* activate next dma buffer */
+			viu_activate_next_buf(dev, vidq);
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* ------------------------------------------------------------------
+	File operations for the device
+   ------------------------------------------------------------------*/
+
+static int viu_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	struct viu_dev *dev;
+	struct viu_reg *vr;
+	struct viu_fh *fh;
+	int i;
+
+	dprintk(0, "viu: open called (minor=%d)\n", minor);
+
+	list_for_each_entry(dev, &viu_devlist, viu_devlist)
+		if (dev->vfd.minor == minor)
+			goto found;
+	return -ENODEV;
+found:
+
+	/* If more than one user, mutex should be added */
+	dev->users++;
+	vr = dev->vr;
+
+	dprintk(1, "open minor=%d type=%s users=%d\n", minor,
+		v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+	/* allocate + initialize per filehandle data */
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+	if (NULL == fh) {
+		dev->users--;
+		return -ENOMEM;
+	}
+
+	file->private_data = fh;
+	fh->dev      = dev;
+
+	fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	fh->fmt      = format_by_fourcc(V4L2_PIX_FMT_RGB32);
+	fh->width    = norm_maxw();
+	fh->height   = norm_maxh();
+	dev->crop_current.width  = fh->width;
+	dev->crop_current.height = fh->height;
+
+	/* Put all controls at a sane state */
+	for (i = 0; i < ARRAY_SIZE(viu_qctrl); i++)
+		qctl_regs[i] = viu_qctrl[i].default_value;
+
+	dprintk(1, "Open: fh=0x%08lx, dev=0x%08lx, dev->vidq=0x%08lx\n",
+		(unsigned long)fh, (unsigned long)dev,
+		(unsigned long)&dev->vidq);
+	dprintk(1, "Open: list_empty queued=%d\n",
+			list_empty(&dev->vidq.queued));
+	dprintk(1, "Open: list_empty active=%d\n",
+			list_empty(&dev->vidq.active));
+
+	vr->status_cfg &= ~(INT_VSYNC_EN | INT_HSYNC_EN |
+			INT_FIELD_EN | INT_VSTART_EN |
+			INT_DMA_END_EN | INT_ERROR_EN | INT_ECC_EN);
+	iosync();
+	vr->status_cfg &= INT_FIELD_STATUS | INT_VSYNC_STATUS |
+			INT_HSYNC_STATUS | INT_VSTART_STATUS |
+			INT_DMA_END_STATUS | INT_ERROR_STATUS;
+	iosync();
+
+	/* install interrupt handler */
+	if (request_irq(dev->irq, viu_irq, 0, "VIU", (void *)dev)) {
+		dprintk(0, "Request VIU IRQ failed.\n");
+		return -ENODEV;
+	}
+
+	videobuf_queue_sg_init(&fh->vb_vidq, &viu_video_qops,
+			NULL, &dev->slock,
+			fh->type,
+			V4L2_FIELD_INTERLACED,
+			sizeof(struct viu_buf), fh);
+	return 0;
+}
+
+static ssize_t viu_read(struct file *file, char __user *data, size_t count,
+			loff_t *ppos)
+{
+	struct viu_fh *fh = file->private_data;
+	struct viu_dev *dev = fh->dev;
+
+	dprintk(2, "entered %s\n", __func__);
+	/* FIXME Bug: if last working mode is overlay, now capture mode can't
+	 * work normally. This workaround is to re-initialize I/O pins of VIU
+	 * again before capture mode starts to work.
+	 */
+	if (dev->ovenable) {
+		fsl_viu_init_io();
+		dev->ovenable = 0;
+	}
+
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		start_dma(dev);
+		return videobuf_read_stream(&fh->vb_vidq, data, count,
+				ppos, 0, file->f_flags & O_NONBLOCK);
+	}
+	return 0;
+}
+
+static unsigned int viu_poll(struct file *file, struct poll_table_struct *wait)
+{
+	struct viu_fh        *fh = file->private_data;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fh->type)
+		return POLLERR;
+
+	return videobuf_poll_stream(file, q, wait);
+}
+
+static int viu_release(struct inode *inode, struct file *file)
+{
+	struct viu_fh       *fh   = file->private_data;
+	struct viu_dev      *dev  = fh->dev;
+	int minor = iminor(inode);
+
+	stop_dma(dev);
+	videobuf_stop(&fh->vb_vidq);
+	videobuf_mmap_free(&fh->vb_vidq);
+
+	kfree(fh);
+	free_irq(dev->irq, (void *)dev);
+
+	first = 1;
+	dev->users--;
+	dprintk(1, "close called (minor=%d, users=%d)\n",
+			minor, dev->users);
+	return 0;
+}
+
+void viu_reset(struct viu_reg *reg)
+{
+	reg->status_cfg = 0;
+	reg->luminance = 0x9512a254;
+	reg->chroma_r = 0x03310000;
+	reg->chroma_g = 0x06600f38;
+	reg->chroma_b = 0x00000409;
+	reg->field_base_addr = 0;
+	reg->dma_inc = 0;
+	reg->picture_count = 0x01e002d0;
+	reg->req_alarm = 0x00000090;
+	reg->alpha = 0x000000ff;
+}
+
+static int viu_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct viu_fh *fh = file->private_data;
+	int ret;
+
+	dprintk(1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
+
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
+
+	dprintk(1, "vma start=0x%08lx, size=%ld, ret=%d\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end-(unsigned long)vma->vm_start,
+		ret);
+
+	return ret;
+}
+
+static const struct file_operations viu_fops = {
+	.owner		= THIS_MODULE,
+	.open           = viu_open,
+	.release        = viu_release,
+	.read           = viu_read,
+	.poll		= viu_poll,
+	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+	.mmap           = viu_mmap,
+	.llseek         = no_llseek,
+};
+
+static const struct v4l2_ioctl_ops viu_ioctl_ops = {
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_cap,
+	.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt,
+	.vidioc_g_fmt_vid_overlay = vidioc_g_fmt_overlay,
+	.vidioc_try_fmt_vid_overlay = vidioc_try_fmt_overlay,
+	.vidioc_s_fmt_vid_overlay = vidioc_s_fmt_overlay,
+	.vidioc_g_fbuf	      = vidioc_g_fbuf,
+	.vidioc_s_fbuf	      = vidioc_s_fbuf,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+};
+
+static struct video_device viu = {
+	.name		= "FSL viu",
+	.fops           = &viu_fops,
+	.minor		= -1,
+	.tvnorms	= V4L2_STD_NTSC_M,
+	.current_norm	= V4L2_STD_NTSC_M,
+	.release	= video_device_release,
+	.ioctl_ops 	= &viu_ioctl_ops,
+};
+
+static int __devinit viu_of_probe(struct of_device *op,
+				const struct of_device_id *match)
+{
+	struct viu_dev *dev;
+	struct resource r;
+	struct viu_reg __iomem *viu_regs;
+	struct clk *viu_clk;
+	int ret, viu_irq = NO_IRQ;
+
+	ret = of_address_to_resource(op->node, 0, &r);
+	if (ret) {
+		dprintk(0, "Err: Error while parsing device node resource\n");
+		return -ENODEV;
+	}
+
+	viu_irq = irq_of_parse_and_map(op->node, 0);
+	if (viu_irq == NO_IRQ) {
+		dprintk(0, "Err: while mapping the irq\n");
+		return -EINVAL;
+	}
+
+	/* request mem region */
+	if (!devm_request_mem_region(&op->dev, r.start,
+				     sizeof(struct viu_reg), DRV_NAME)) {
+		dprintk(0, "Error while requesting mem region\n");
+		ret = -EBUSY;
+		goto err;
+	}
+
+	/* remap registers */
+	viu_regs = devm_ioremap(&op->dev, r.start,
+				sizeof(struct viu_reg));
+	if (!viu_regs) {
+		dprintk(0, "Error while mapping register set\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* Prepare our private structure */
+	dev = devm_kzalloc(&op->dev, sizeof(struct viu_dev), GFP_ATOMIC);
+	if (!dev) {
+		dprintk(0, "Error while allocating private structure\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev->vr = viu_regs;
+	dev->irq = viu_irq;
+
+	/* init device list */
+	INIT_LIST_HEAD(&viu_devlist);
+	list_add_tail(&dev->viu_devlist, &viu_devlist);
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	INIT_LIST_HEAD(&dev->vidq.queued);
+
+	/* initialize locks */
+	mutex_init(&dev->lock);
+
+	dev->vidq.timeout.function = viu_vid_timeout;
+	dev->vidq.timeout.data     = (unsigned long)dev;
+	init_timer(&dev->vidq.timeout);
+
+	ret = video_register_device(&viu, VFL_TYPE_GRABBER, video_nr);
+	printk(KERN_INFO "Freescale VIU Video Capture Board"
+			" (Load status: %d)\n", ret);
+
+	/* initialize I/O pins for VIU */
+	fsl_viu_init_io();
+
+	/* enable VIU clock */
+	viu_clk = clk_get(&op->dev, "viu_clk");
+	if (!viu_clk) {
+		dprintk(0, "err: failed to find the clock module for VIU!");
+		return -ENODEV;
+	}
+	clk_enable(viu_clk);
+
+	/* reset VIU module */
+	viu_reset(dev->vr);
+	return ret;
+err:
+	irq_dispose_mapping(viu_irq);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int viu_suspend(struct of_device *op, pm_message_t state)
+{
+	struct clk *viu_clk;
+	viu_clk = clk_get(&op->dev, "viu_clk");
+	clk_disable(viu_clk);
+	return 0;
+}
+
+static int viu_resume(struct of_device *op)
+{
+	struct clk *viu_clk;
+	viu_clk = clk_get(&op->dev, "viu_clk");
+	clk_enable(viu_clk);
+	return 0;
+}
+#endif
+
+static struct of_device_id mpc512x_viu_of_match[] = {
+	{
+		.compatible = "fsl,mpc5121-viu",
+	},
+	{},
+};
+
+/* -----------------------------------------------------------------
+	Initialization and module stuff
+   ------------------------------------------------------------------*/
+static struct of_platform_driver viu_of_platform_driver = {
+	.name = DRV_NAME,
+	.owner = THIS_MODULE,
+	.match_table = mpc512x_viu_of_match,
+	.driver = {
+		   .name = DRV_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = viu_of_probe,
+#ifdef CONFIG_PM
+	.suspend = viu_suspend,
+	.resume = viu_resume,
+#endif
+};
+
+static int __init viu_init(void)
+{
+	int ret;
+
+	ret = of_register_platform_driver(&viu_of_platform_driver);
+	dprintk(0, "FSL_VIU: registed VIU device driver!\n");
+	return ret;
+}
+
+static void __exit viu_exit(void)
+{
+	struct viu_dev *h;
+	struct list_head *list;
+
+	while (!list_empty(&viu_devlist)) {
+		list = viu_devlist.next;
+		list_del(list);
+		h = list_entry(list, struct viu_dev, viu_devlist);
+		kfree(h);
+	}
+
+	of_unregister_platform_driver(&viu_of_platform_driver);
+	video_unregister_device(&viu);
+}
+
+module_init(viu_init);
+module_exit(viu_exit);
+
+MODULE_DESCRIPTION("Freescale Video-In(VIU)");
+MODULE_AUTHOR("Hongjun Chen");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(of, mpc512x_viu_of_match);
diff --git a/drivers/video/fsl-diu-fb.c b/drivers/video/fsl-diu-fb.c
index cfe2547..7927e30 100644
--- a/drivers/video/fsl-diu-fb.c
+++ b/drivers/video/fsl-diu-fb.c
@@ -313,7 +313,11 @@ void write_reg_wa(u32 *reg, u32 val)
  *
  * This function allocates a physically-contiguous block of memory.
  */
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+void *fsl_diu_alloc(size_t size, phys_addr_t *phys)
+#else
 static void *fsl_diu_alloc(size_t size, phys_addr_t *phys)
+#endif
 {
 	void *virt;
 
@@ -328,6 +332,9 @@ static void *fsl_diu_alloc(size_t size, phys_addr_t *phys)
 
 	return virt;
 }
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+EXPORT_SYMBOL(fsl_diu_alloc);
+#endif
 
 /**
  * fsl_diu_free - release DIU memory
@@ -336,13 +343,20 @@ static void *fsl_diu_alloc(size_t size, phys_addr_t *phys)
  *
  * This function releases memory allocated by fsl_diu_alloc().
  */
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+void fsl_diu_free(void *virt, size_t size)
+#else
 static void fsl_diu_free(void *virt, size_t size)
+#endif
 {
 	pr_debug("virt=%p size=%zu\n", virt, size);
 
 	if (virt && size)
 		free_pages_exact(virt, size);
 }
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+EXPORT_SYMBOL(fsl_diu_free);
+#endif
 
 static int fsl_diu_enable_panel(struct fb_info *info)
 {
diff --git a/drivers/video/fsl-diu-fb.h b/drivers/video/fsl-diu-fb.h
index 0ba3fff..a4dc6ce 100644
--- a/drivers/video/fsl-diu-fb.h
+++ b/drivers/video/fsl-diu-fb.h
@@ -52,8 +52,11 @@ struct aoi_display_offset {
 	int x_aoi_d;
 	int y_aoi_d;
 };
-
+#if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
+#define MFB_SET_CHROMA_KEY	0x80024d00
+#else
 #define MFB_SET_CHROMA_KEY	_IOW('M', 1, struct mfb_chroma_key)
+#endif
 #define MFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
 #define MFB_SET_BRIGHTNESS	_IOW('M', 3, __u8)
 
-- 
1.6.3.1

