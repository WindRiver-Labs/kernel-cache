From 24c2b338b5e2a4e8da391e6caab59c8fa0058814 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:11 +0800
Subject: [PATCH] Add USB device controller support

Unlike mpc83xx board, mpc5121e
(1) has no sysif_regs.
(2) has big endian register
(3) has big endian DMA descriptor

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/mpc5121_usb.c |    1 +
 drivers/usb/gadget/fsl_usb2_udc.c         |  195 +++++++++++++++++++++--------
 drivers/usb/gadget/fsl_usb2_udc.h         |   10 ++
 3 files changed, 151 insertions(+), 55 deletions(-)

diff --git a/arch/powerpc/platforms/512x/mpc5121_usb.c b/arch/powerpc/platforms/512x/mpc5121_usb.c
index 21c26fc..ea6a404 100644
--- a/arch/powerpc/platforms/512x/mpc5121_usb.c
+++ b/arch/powerpc/platforms/512x/mpc5121_usb.c
@@ -76,6 +76,7 @@ int usb_platform_dr_init(struct platform_device *pdev)
 	pdata->big_endian_desc = 1;
 	pdata->big_endian_mmio = 1;
 	pdata->le_setup_buf = 1;
+	pdata->have_sysif_regs = 0;
 	pdata->es = 1;
 
 	if (pdata->phy_mode == FSL_USB2_PHY_UTMI_WIDE) {
diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 45ad556..2a8381e 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -80,13 +80,6 @@ static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
 static int fsl_udc_resume(struct platform_device *pdev);
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
 
-#ifdef CONFIG_PPC32
-#define fsl_readl(addr)		in_le32(addr)
-#define fsl_writel(addr, val32) out_le32(val32, addr)
-#else
-#define fsl_readl(addr)		readl(addr)
-#define fsl_writel(addr, val32) writel(addr, val32)
-#endif
 
 /********************************************************************
  *	Internal Used Function
@@ -183,11 +176,18 @@ static int dr_controller_setup(struct fsl_udc *udc)
 {
 	unsigned int tmp = 0, portctrl = 0, ctrl = 0;
 	unsigned long timeout;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata;
+#endif
+
 #define FSL_UDC_RESET_TIMEOUT 1000
 
 	/* before here, make sure dr_regs has been initialized */
 	if (!udc)
 		return -EINVAL;
+#ifdef CONFIG_PPC_MPC512x
+	 pdata = udc->pdata;
+#endif
 
 	/* Stop and reset the usb controller */
 	tmp = fsl_readl(&dr_regs->usbcmd);
@@ -210,9 +210,15 @@ static int dr_controller_setup(struct fsl_udc *udc)
 
 	/* Set the controller as device mode */
 	tmp = fsl_readl(&dr_regs->usbmode);
+	tmp &= ~USB_MODE_CTRL_MODE_MASK;        /* clear mode bits */
 	tmp |= USB_MODE_CTRL_MODE_DEVICE;
 	/* Disable Setup Lockout */
 	tmp |= USB_MODE_SETUP_LOCK_OFF;
+
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->es)
+		tmp |= USB_MODE_ES;
+#endif
 	fsl_writel(tmp, &dr_regs->usbmode);
 
 	/* Clear the setup status */
@@ -247,20 +253,32 @@ static int dr_controller_setup(struct fsl_udc *udc)
 	}
 	fsl_writel(portctrl, &dr_regs->portsc1);
 
-	/* Config control enable i/o output, cpu endian register */
-	ctrl = __raw_readl(&usb_sys_regs->control);
-	ctrl |= USB_CTRL_IOENB;
-	__raw_writel(ctrl, &usb_sys_regs->control);
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->have_sysif_regs) {
+#endif
+		/* Config control enable i/o output, cpu endian register */
+		ctrl = __raw_readl(&usb_sys_regs->control);
+		ctrl |= USB_CTRL_IOENB;
+		__raw_writel(ctrl, &usb_sys_regs->control);
+#ifdef CONFIG_PPC_MPC512x
+	}
+#endif
 
 #if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)
 	/* Turn on cache snooping hardware, since some PowerPC platforms
 	 * wholly rely on hardware to deal with cache coherent. */
 
-	/* Setup Snooping for all the 4GB space */
-	tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
-	__raw_writel(tmp, &usb_sys_regs->snoop1);
-	tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
-	__raw_writel(tmp, &usb_sys_regs->snoop2);
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->have_sysif_regs) {
+#endif
+		/* Setup Snooping for all the 4GB space */
+		tmp = SNOOP_SIZE_2GB;	/* starts from 0x0, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop1);
+		tmp |= 0x80000000;	/* starts from 0x8000000, size 2G */
+		__raw_writel(tmp, &usb_sys_regs->snoop2);
+#ifdef CONFIG_PPC_MPC512x
+	}
+#endif
 #endif
 
 	return 0;
@@ -283,6 +301,7 @@ static void dr_controller_run(struct fsl_udc *udc)
 
 	/* Set the controller as device mode */
 	temp = fsl_readl(&dr_regs->usbmode);
+	temp &= ~USB_MODE_CTRL_MODE_MASK;        /* clear mode bits */
 	temp |= USB_MODE_CTRL_MODE_DEVICE;
 	fsl_writel(temp, &dr_regs->usbmode);
 
@@ -414,7 +433,7 @@ static void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,
 	}
 	if (zlt)
 		tmp |= EP_QUEUE_HEAD_ZLT_SEL;
-	p_QH->max_pkt_length = cpu_to_le32(tmp);
+	p_QH->max_pkt_length = cpu_to_hc32(tmp);
 
 	return;
 }
@@ -621,7 +640,7 @@ static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 		struct fsl_req *lastreq;
 		lastreq = list_entry(ep->queue.prev, struct fsl_req, queue);
 		lastreq->tail->next_td_ptr =
-			cpu_to_le32(req->head->td_dma & DTD_ADDR_MASK);
+			cpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);
 		/* Read prime bit, if 1 goto done */
 		if (fsl_readl(&dr_regs->endpointprime) & bitmask)
 			goto out;
@@ -646,10 +665,10 @@ static int fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)
 
 	/* Write dQH next pointer and terminate bit to 0 */
 	temp = req->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;
-	dQH->next_dtd_ptr = cpu_to_le32(temp);
+	dQH->next_dtd_ptr = cpu_to_hc32(temp);
 
 	/* Clear active and halt bit */
-	temp = cpu_to_le32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
+	temp = cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE
 			| EP_QUEUE_HEAD_STATUS_HALT));
 	dQH->size_ioc_int_sts &= temp;
 
@@ -684,17 +703,17 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 
 	dtd->td_dma = *dma;
 	/* Clear reserved field */
-	swap_temp = cpu_to_le32(dtd->size_ioc_sts);
+	swap_temp = hc32_to_cpu(dtd->size_ioc_sts);
 	swap_temp &= ~DTD_RESERVED_FIELDS;
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
 
 	/* Init all of buffer page pointers */
 	swap_temp = (u32) (req->req.dma + req->req.actual);
-	dtd->buff_ptr0 = cpu_to_le32(swap_temp);
-	dtd->buff_ptr1 = cpu_to_le32(swap_temp + 0x1000);
-	dtd->buff_ptr2 = cpu_to_le32(swap_temp + 0x2000);
-	dtd->buff_ptr3 = cpu_to_le32(swap_temp + 0x3000);
-	dtd->buff_ptr4 = cpu_to_le32(swap_temp + 0x4000);
+	dtd->buff_ptr0 = cpu_to_hc32(swap_temp);
+	dtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);
+	dtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);
+	dtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);
+	dtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);
 
 	req->req.actual += *length;
 
@@ -718,7 +737,7 @@ static struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,
 	if (*is_last && !req->req.no_interrupt)
 		swap_temp |= DTD_IOC;
 
-	dtd->size_ioc_sts = cpu_to_le32(swap_temp);
+	dtd->size_ioc_sts = cpu_to_hc32(swap_temp);
 
 	mb();
 
@@ -732,7 +751,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 {
 	unsigned	count;
 	int		is_last;
-	int		is_first =1;
+	int		is_first = 1;
 	struct ep_td_struct	*last_dtd = NULL, *dtd;
 	dma_addr_t dma;
 
@@ -745,7 +764,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 			is_first = 0;
 			req->head = dtd;
 		} else {
-			last_dtd->next_td_ptr = cpu_to_le32(dma);
+			last_dtd->next_td_ptr = cpu_to_hc32(dma);
 			last_dtd->next_td_virt = dtd;
 		}
 		last_dtd = dtd;
@@ -753,7 +772,7 @@ static int fsl_req_to_dtd(struct fsl_req *req)
 		req->dtd_count++;
 	} while (!is_last);
 
-	dtd->next_td_ptr = cpu_to_le32(DTD_NEXT_TERMINATE);
+	dtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);
 
 	req->tail = dtd;
 
@@ -1411,6 +1430,9 @@ static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 {
 	u32 temp;
 	struct ep_queue_head *qh;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata = udc->pdata;
+#endif
 
 	qh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];
 
@@ -1425,7 +1447,17 @@ static void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)
 		fsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);
 
 		/* Copy the setup packet to local buffer */
-		memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
+#ifdef CONFIG_PPC_MPC512x
+		if (pdata->le_setup_buf) {
+			u32 *p = (u32 *)buffer_ptr;
+			u32 *s = (u32 *)qh->setup_buffer;
+
+			/* Convert little endian setup buffer to CPU endian */
+			*p++ = le32_to_cpu(*s++);
+			*p = le32_to_cpu(*s);
+		} else
+#endif
+			memcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);
 	} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));
 
 	/* Clear Setup Tripwire */
@@ -1449,19 +1481,19 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 	actual = curr_req->req.length;
 
 	for (j = 0; j < curr_req->dtd_count; j++) {
-		remaining_length = (le32_to_cpu(curr_td->size_ioc_sts)
+		remaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)
 					& DTD_PACKET_SIZE)
 				>> DTD_LENGTH_BIT_POS;
 		actual -= remaining_length;
 
-		if ((errors = le32_to_cpu(curr_td->size_ioc_sts) &
-						DTD_ERROR_MASK)) {
+		errors = hc32_to_cpu(curr_td->size_ioc_sts);
+		if (errors & DTD_ERROR_MASK) {
 			if (errors & DTD_STATUS_HALTED) {
 				ERR("dTD error %08x QH=%d\n", errors, pipe);
 				/* Clear the errors and Halt condition */
-				tmp = le32_to_cpu(curr_qh->size_ioc_int_sts);
+				tmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);
 				tmp &= ~errors;
-				curr_qh->size_ioc_int_sts = cpu_to_le32(tmp);
+				curr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);
 				status = -EPIPE;
 				/* FIXME: continue with next queued TD? */
 
@@ -1479,7 +1511,7 @@ static int process_ep_req(struct fsl_udc *udc, int pipe,
 				ERR("Unknown error has occured (0x%x)!\r\n",
 					errors);
 
-		} else if (le32_to_cpu(curr_td->size_ioc_sts)
+		} else if (hc32_to_cpu(curr_td->size_ioc_sts)
 				& DTD_STATUS_ACTIVE) {
 			VDBG("Request not complete");
 			status = REQ_UNCOMPLETE;
@@ -1893,6 +1925,9 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	struct fsl_req *req;
 
 	struct fsl_udc *udc = udc_controller;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata = udc->pdata;
+#endif
 	if (off != 0)
 		return 0;
 
@@ -2058,18 +2093,23 @@ static int fsl_proc_read(char *page, char **start, off_t off, int count,
 	t = scnprintf(next, size, "EP Prime Reg = [0x%x]\n", tmp_reg);
 	size -= t;
 	next += t;
+#ifdef CONFIG_PPC_MPC512x
+	if (pdata->have_sysif_regs) {
+#endif
+		tmp_reg = usb_sys_regs->snoop1;
+		t = scnprintf(next, size, "\nSnoop1 Reg: = [0x%x]\n\n",
+				tmp_reg);
+		size -= t;
+		next += t;
 
-	tmp_reg = usb_sys_regs->snoop1;
-	t = scnprintf(next, size, "\nSnoop1 Reg : = [0x%x]\n\n", tmp_reg);
-	size -= t;
-	next += t;
-
-	tmp_reg = usb_sys_regs->control;
-	t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
-			tmp_reg);
-	size -= t;
-	next += t;
-
+		tmp_reg = usb_sys_regs->control;
+		t = scnprintf(next, size, "General Control Reg : = [0x%x]\n\n",
+				tmp_reg);
+		size -= t;
+		next += t;
+#ifdef CONFIG_PPC_MPC512x
+	}
+#endif
 	/* ------fsl_udc, fsl_ep, fsl_request structure information ----- */
 	ep = &udc->eps[0];
 	t = scnprintf(next, size, "For %s Maxpkt is 0x%x index is 0x%x\n",
@@ -2249,6 +2289,9 @@ static int __init struct_ep_setup(struct fsl_udc *udc, unsigned char index,
 static int __init fsl_udc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+#endif
 	int ret = -ENODEV;
 	unsigned int i;
 	u32 dccparams;
@@ -2263,18 +2306,21 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ERR("malloc udc failed\n");
 		return -ENOMEM;
 	}
+#ifdef CONFIG_PPC_MPC512x
+	udc_controller->pdata = pdata;
+#endif
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
-		kfree(udc_controller);
-		return -ENXIO;
+		ret = -ENXIO;
+		goto err1a;
 	}
 
 	if (!request_mem_region(res->start, res->end - res->start + 1,
 				driver_name)) {
 		ERR("request mem region for %s failed \n", pdev->name);
-		kfree(udc_controller);
-		return -EBUSY;
+		ret = -EBUSY;
+		goto err1a;
 	}
 
 	dr_regs = ioremap(res->start, res->end - res->start + 1);
@@ -2282,8 +2328,22 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto err1;
 	}
+#ifdef CONFIG_PPC_MPC512x
+	pdata->regs = (void *)dr_regs;
+
+	/*
+	 * do platform specific init: check the clock, grab/config pins, etc.
+	 */
+	 if (pdata->platform_init && pdata->platform_init(pdev)) {
+		ret = -ENODEV;
+		goto err2a;
+	}
 
-	usb_sys_regs = (struct usb_sys_interface *)
+	fsl_set_usb_accessors(pdata);
+
+	if (pdata->have_sysif_regs)
+#endif
+		usb_sys_regs = (struct usb_sys_interface *)
 			((u32)dr_regs + USB_DR_SYS_OFFSET);
 
 	/* Read Device Controller Capability Parameters register */
@@ -2293,6 +2353,7 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto err2;
 	}
+
 	/* Get max device endpoints */
 	/* DEN is bidirectional ep number, max_ep doubles the number */
 	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
@@ -2376,10 +2437,16 @@ err4:
 err3:
 	free_irq(udc_controller->irq, udc_controller);
 err2:
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+err2a:
 	iounmap(dr_regs);
 err1:
-	release_mem_region(res->start, res->end - res->start + 1);
+	if (!udc_controller->transceiver)
+		release_mem_region(res->start, res->end - res->start + 1);
+err1a:
 	kfree(udc_controller);
+	udc_controller = NULL;
 	return ret;
 }
 
@@ -2388,7 +2455,13 @@ err1:
  */
 static int __exit fsl_udc_remove(struct platform_device *pdev)
 {
+#ifndef CONFIG_USB_OTG
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+#endif
+
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+#endif
 
 	DECLARE_COMPLETION(done);
 
@@ -2407,12 +2480,24 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
 	dma_pool_destroy(udc_controller->td_pool);
 	free_irq(udc_controller->irq, udc_controller);
 	iounmap(dr_regs);
+
+#ifndef CONFIG_USB_OTG
 	release_mem_region(res->start, res->end - res->start + 1);
+#endif
 
 	device_unregister(&udc_controller->gadget.dev);
 	/* free udc --wait for the release() finished */
 	wait_for_completion(&done);
 
+#ifdef CONFIG_PPC_MPC512x
+	/*
+	 * do platform specific un-initialization:
+	 * release iomux pins, etc.
+	 */
+	if (pdata->platform_uninit)
+		pdata->platform_uninit(pdata);
+#endif
+
 	return 0;
 }
 
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index 6131752..5d5a6ad 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -4,6 +4,10 @@
 #ifndef __FSL_USB2_UDC_H
 #define __FSL_USB2_UDC_H
 
+#ifdef CONFIG_PPC32
+#include <asm/fsl_usb_io.h>
+#endif
+
 /* ### define USB registers here
  */
 #define USB_MAX_CTRL_PAYLOAD		64
@@ -275,7 +279,10 @@ struct usb_sys_interface {
 #define  USB_MODE_CTRL_MODE_IDLE              0x00000000
 #define  USB_MODE_CTRL_MODE_DEVICE            0x00000002
 #define  USB_MODE_CTRL_MODE_HOST              0x00000003
+#define  USB_MODE_CTRL_MODE_MASK		0x00000003
 #define  USB_MODE_CTRL_MODE_RSV               0x00000001
+/* (big) Endian Select */
+#define  USB_MODE_ES				0x00000004
 #define  USB_MODE_SETUP_LOCK_OFF              0x00000008
 #define  USB_MODE_STREAM_DISABLE              0x00000010
 /* Endpoint Flush Register */
@@ -472,6 +479,9 @@ struct fsl_udc {
 
 	struct usb_gadget gadget;
 	struct usb_gadget_driver *driver;
+#ifdef CONFIG_PPC_MPC512x
+	struct fsl_usb2_platform_data *pdata;
+#endif
 	struct fsl_ep *eps;
 	unsigned int max_ep;
 	unsigned int irq;
-- 
1.6.0.90.g436ed

