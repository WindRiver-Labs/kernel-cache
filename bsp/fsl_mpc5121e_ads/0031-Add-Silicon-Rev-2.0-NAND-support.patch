From f66240c50fb336b2649f47f998c87c8bade83fe8 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 18 Nov 2008 17:11:02 +0800
Subject: [PATCH] Add Silicon Rev 2.0 NAND support

[MTD] [NAND] add a NAND flash driver

For the NAND flash controller on mpc5121e ADS
boards with silicon revision below 2.0 works
unstably, replace it with a new NAND flash module
on boards with silicon revision equal or greater
to 2.0.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/boot/dts/mpc5121ads.dts         |   33 +-
 arch/powerpc/platforms/512x/mpc512x_shared.c |    1 +
 drivers/mtd/nand/Kconfig                     |   27 +
 drivers/mtd/nand/Makefile                    |    1 +
 drivers/mtd/nand/mpc5121_nand2.c             | 1583 ++++++++++++++++++++++++++
 include/mtd/mtd-abi.h                        |    9 +
 6 files changed, 1644 insertions(+), 10 deletions(-)
 create mode 100644 drivers/mtd/nand/mpc5121_nand2.c

diff --git a/arch/powerpc/boot/dts/mpc5121ads.dts b/arch/powerpc/boot/dts/mpc5121ads.dts
index 24dc9f7..b81645d 100644
--- a/arch/powerpc/boot/dts/mpc5121ads.dts
+++ b/arch/powerpc/boot/dts/mpc5121ads.dts
@@ -56,25 +56,33 @@
 	};
 
 	nfc@40000000 {
-		compatible = "fsl,mpc5121-nfc";
+		compatible = "fsl,mpc5121rev2-nfc";
 		reg = <0x40000000 0x100000>;	// 1M at 0x40000000
 		interrupts = <6 8>;
 		interrupt-parent = < &ipic >;
 		#address-cells = <1>;
 		#size-cells = <1>;
 		bank-width = <1>;
+		write-size = <2048>;
+		spare-size = <64>;
 		// ADS has two Hynix 512MB Nand flash chips in a single
 		// stacked package .
 		chips = <2>;
-		nand0@0 {
-			label = "nand0";
-			reg = <0x00000000 0x02000000>; 	// first 32 MB of chip 0
+		// UBIFS works fine on large partitions so use all of it
+		nand@0 {
+			label = "nand";
+			reg = <0x00000000 0x40000000>;      // Entire 1G (512M + 512M)
 		};
-		nand1@20000000 {
-			label = "nand1";
-			reg = <0x20000000 0x02000000>; 	// first 32 MB of chip 1
-		};
-	};
+		// JFFS2 really doesn't do large partitions well use UBIFS instead
+		//nand0@0 {
+		//      label = "nand0";
+		//      reg = <0x00000000 0x02000000>;      // first 32 MB of chip 0
+		//};
+		//nand1@20000000 {
+		//      label = "nand1";
+		//      reg = <0x20000000 0x02000000>;      // first 32 MB of chip 1
+		//};
+        };
 
 	localbus@80000020 {
 		compatible = "fsl,mpc5121-localbus";
@@ -179,7 +187,12 @@
 			reg = <0xb00 0x10>;
 			interrupts = <15 0x8>;
 			interrupt-parent = < &ipic >;
-		 };
+		};
+
+		reset@e00 {	// Reset module
+			compatible = "fsl,mpc5121-reset";
+			reg = <0xe00 0x100>;
+		};
 
 		clock@f00 {	// Clock control
 			compatible = "fsl,mpc5121-clock";
diff --git a/arch/powerpc/platforms/512x/mpc512x_shared.c b/arch/powerpc/platforms/512x/mpc512x_shared.c
index bfb0235..d78a706 100644
--- a/arch/powerpc/platforms/512x/mpc512x_shared.c
+++ b/arch/powerpc/platforms/512x/mpc512x_shared.c
@@ -79,6 +79,7 @@ static struct of_device_id __initdata of_bus_ids[] = {
 	{ .compatible = "fsl,mpc5121-immr", },
 	{ .compatible = "fsl,mpc5121-localbus", },
 	{ .compatible = "fsl,mpc5121-mbx", },
+	{ .compatible = "fsl,mpc5121rev2-nfc", },
 	{},
 };
 
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 236fb65..f7b7881 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -425,4 +425,31 @@ config MTD_NAND_FSL_UPM
 	  Enables support for NAND Flash chips wired onto Freescale PowerPC
 	  processor localbus with User-Programmable Machine support.
 
+config MTD_NAND_MPC5121R2
+	tristate "NAND Flash controller for MPC5121 rev2 silicon"
+	depends on PPC_MPC512x
+	help
+	  This enables the NAND flash driver on the MPC512x SOC.
+
+config MTD_NAND_MPC5121R2_SWECC
+	bool "Software ECC support "
+	depends on MTD_NAND_MPC5121R2
+	help
+	   This enables the support for Software ECC handling. By
+	   default FSL NAND controller Hardware ECC is supported.
+
+config MTD_NAND_MPC5121R2_ECC_CORRECTION_OPTION2
+	bool "ECC correction in S/W"
+	depends on MTD_NAND_MPC5121R2
+	help
+	  This enables the Option2 NFC ECC correction in software. By
+	  default Option 1 is selected. Enable if you need option2 ECC correction.
+
+config	MPC5121_NAND_LOW_LEVEL_ERASE
+	bool "Low level NAND erase"
+	depends on MTD_NAND_MPC5121R2 
+	help
+	  This enables the erase of whole NAND flash. By
+	  default low level erase operation is disabled.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index ba42584..087572e 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -37,5 +37,6 @@ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
+obj-$(CONFIG_MTD_NAND_MPC5121R2)	+= mpc5121_nand2.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/mpc5121_nand2.c b/drivers/mtd/nand/mpc5121_nand2.c
new file mode 100644
index 0000000..bf37ad6
--- /dev/null
+++ b/drivers/mtd/nand/mpc5121_nand2.c
@@ -0,0 +1,1583 @@
+/*
+ * Copyright 2004-2008 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Forked from drivers/mtd/nand/mxc_nd.c
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/of_device.h>
+#include <asm/of_platform.h>
+#include <linux/io.h>
+
+#define DRV_NAME "mpc5121r2nfc"
+#define DVR_VER "0.2"
+
+static void mpc5121_nand_cleanup(void);
+
+static struct mpc5121_mtd_s {
+	struct device *dev;
+	struct mtd_info mtd;
+	struct nand_chip nand;
+	int irq;
+	int nr_chips;
+	struct clk *nfc_clk;
+	unsigned long phys_regs;
+	void __iomem *regs;
+	void __iomem *nandcsreg;
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+	int nr_parts;
+#endif
+	int sparesize;
+	int suspended;
+} *priv;
+
+#ifdef CONFIG_PM_DEBUG
+#define NFC_REG_BASE (({BUG_ON(priv->suspended); }), priv->regs)
+#else
+#define NFC_REG_BASE (priv->regs)
+#endif
+
+#define IS_2K_PAGE_NAND		(mtd->writesize == 2048)
+#define IS_4K_PAGE_NAND		(mtd->writesize == 4096)
+#define IS_LARGE_PAGE_NAND	(mtd->writesize > 512)
+
+/*
+ * MPC5121 Rev2 NFC registers Definition
+ */
+#define NFC_BUF_ADDR             (NFC_REG_BASE + 0x1E04)
+#define NFC_FLASH_ADDR           (NFC_REG_BASE + 0x1E06)
+#define NFC_FLASH_CMD            (NFC_REG_BASE + 0x1E08)
+#define NFC_CONFIG               (NFC_REG_BASE + 0x1E0A)
+#define NFC_ECC_STATUS1          (NFC_REG_BASE + 0x1E0C)
+#define NFC_ECC_STATUS2          (NFC_REG_BASE + 0x1E0E)
+#define NFC_SPAS                 (NFC_REG_BASE + 0x1E10)
+#define NFC_WRPROT               (NFC_REG_BASE + 0x1E12)
+#define NFC_NF_WRPRST            (NFC_REG_BASE + 0x1E18)
+#define NFC_CONFIG1              (NFC_REG_BASE + 0x1E1A)
+#define NFC_CONFIG2              (NFC_REG_BASE + 0x1E1C)
+#define NFC_UNLOCKSTART_BLKADDR0 (NFC_REG_BASE + 0x1E20)
+#define NFC_UNLOCKEND_BLKADDR0   (NFC_REG_BASE + 0x1E22)
+#define NFC_UNLOCKSTART_BLKADDR1 (NFC_REG_BASE + 0x1E24)
+#define NFC_UNLOCKEND_BLKADDR1   (NFC_REG_BASE + 0x1E26)
+#define NFC_UNLOCKSTART_BLKADDR2 (NFC_REG_BASE + 0x1E28)
+#define NFC_UNLOCKEND_BLKADDR2   (NFC_REG_BASE + 0x1E2A)
+#define NFC_UNLOCKSTART_BLKADDR3 (NFC_REG_BASE + 0x1E2C)
+#define NFC_UNLOCKEND_BLKADDR3   (NFC_REG_BASE + 0x1E2E)
+
+/*!
+ * Addresses for NFC MAIN RAM BUFFER areas
+ */
+#define MAIN_AREA(n)	         (NFC_REG_BASE + (n)*0x200)
+
+/*!
+ * Addresses for NFC SPARE BUFFER areas
+ */
+#define SPARE_LEN		 0x40
+#define SPARE_AREA(n)            (NFC_REG_BASE + 0x1000 + (n)*SPARE_LEN)
+
+#define NFC_CMD            		0x1
+#define NFC_ADDR           		0x2
+#define NFC_INPUT          		0x4
+#define NFC_OUTPUT         		0x8
+#define NFC_ID             		0x10
+#define NFC_STATUS         		0x20
+
+/* Bit Definitions */
+#define NFC_INT				(1 << 15)
+#define NFC_SP_EN           		(1 << 2)
+#define NFC_ECC_EN          		(1 << 3)
+#define NFC_INT_MSK         		(1 << 4)
+#define NFC_BIG             		(1 << 5)
+#define NFC_RST             		(1 << 6)
+#define NFC_CE              		(1 << 7)
+#define NFC_ONE_CYCLE       		(1 << 8)
+#define NFC_BLS_LOCKED			0
+#define NFC_BLS_LOCKED_DEFAULT		1
+#define NFC_BLS_UNLOCKED		2
+#define NFC_WPC_LOCK_TIGHT		1
+#define NFC_WPC_LOCK			(1 << 1)
+#define NFC_WPC_UNLOCK			(1 << 2)
+#define NFC_FLASH_ADDR_SHIFT 		0
+#define NFC_UNLOCK_END_ADDR_SHIFT	0
+
+#define NFC_ECC_MODE_4    		 1
+/*
+ * Define delays in microsec for NAND device operations
+ */
+#define TROP_US_DELAY   2000
+
+struct nand_info {
+	bool bSpareOnly;
+	bool bStatusRequest;
+	u16 colAddr;
+};
+
+static struct of_device_id nfc_match[] = {
+	{
+		.compatible = "fsl,mpc5121rev2-nfc",
+	},
+	{},
+};
+
+static struct nand_info g_nandfc_info;
+
+#ifdef CONFIG_MTD_NAND_MPC5121_SWECC
+static int hardware_ecc;
+#else
+static int hardware_ecc = 1;
+#endif
+
+/*
+ * OOB placement block for use with hardware ecc generation
+ */
+static struct nand_ecclayout nand_hw_eccoob_512 = {
+	.eccbytes = 9,
+	.eccpos = {
+		7, 8, 9, 10, 11, 12, 13, 14, 15,
+	},
+	.oobavail = 5,
+	.oobfree = {{0, 5} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_2k = {
+	.eccbytes = 36,
+	.eccpos = {
+		/* 9 bytes of ecc for each 512 bytes of data */
+		7, 8, 9, 10, 11, 12, 13, 14, 15,
+		23, 24, 25, 26, 27, 28, 29, 30, 31,
+		39, 40, 41, 42, 43, 44, 45, 46, 47,
+		55, 56, 57, 58, 59, 60, 61, 62, 63,
+	},
+	.oobavail = 26,
+	.oobfree = {{0, 5}, {16, 7}, {32, 7}, {48, 7} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_4k = {
+	.eccbytes = 64,	/* actually 72 but only room for 64 */
+	.eccpos = {
+		/* 9 bytes of ecc for each 512 bytes of data */
+		7, 8, 9, 10, 11, 12, 13, 14, 15,
+		23, 24, 25, 26, 27, 28, 29, 30, 31,
+		39, 40, 41, 42, 43, 44, 45, 46, 47,
+		55, 56, 57, 58, 59, 60, 61, 62, 63,
+		71, 72, 73, 74, 75, 76, 77, 78, 79,
+		87, 88, 89, 90, 91, 92, 93, 94, 95,
+		103, 104, 105, 106, 107, 108, 109, 110, 111,
+		119, /* 120, 121, 122, 123, 124, 125, 126, 127, */
+	},
+	.oobavail = 54,
+	.oobfree = {{0, 5}, {16, 7}, {32, 7}, {48, 7},
+		    {64, 7}, {80, 7}, {96, 7}, {112, 7} }
+};
+
+static struct nand_ecclayout nand_hw_eccoob_4k_218_spare = {
+	.eccbytes = 64,	/* actually 144 but only room for 64 */
+	.eccpos = {
+		/* 18 bytes of ecc for each 512 bytes of data */
+		7, 8, 9, 10, 11, 12, 13, 14, 15,
+		    16, 17, 18, 19, 20, 21, 22, 23, 24,
+		33, 34, 35, 36, 37, 38, 39, 40, 41,
+		    42, 43, 44, 45, 46, 47, 48, 49, 50,
+		59, 60, 61, 62, 63, 64, 65, 66, 67,
+		    68, 69, 70, 71, 72, 73, 74, 75, 76,
+		85, 86, 87, 88, 89, 90, 91, 92, 93,
+		    94, /* 95, 96, 97, 98, 99, 100, 101, 102,
+		111, 112, 113, 114, 115, 116, 117, 118, 119,
+		    120, 121, 122, 123, 124, 125, 126, 127, 128,
+		137, 138, 139, 140, 141, 142, 143, 144, 145,
+		    146, 147, 148, 149, 150, 151, 152, 153, 154,
+		163, 164, 165, 166, 167, 168, 169, 170, 171,
+		    172, 173, 174, 175, 176, 177, 178, 179, 180,
+		189, 190, 191, 192, 193, 194, 195, 196, 197,
+		    198, 199, 200, 201, 202, 203, 204, 205, 206, */
+	},
+	.oobavail = 4,
+	.oobfree = {{0, 5}, {26, 8}, {52, 8}, {78, 8},
+		    {104, 8}, {130, 8}, {156, 8}, {182, 8} }
+};
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+static wait_queue_head_t irq_waitq;
+
+static irqreturn_t mpc5121_nfc_irq(int irq, void *dev_id)
+{
+	/* Disable Interrupt */
+	out_be16(NFC_CONFIG1, in_be16(NFC_CONFIG1) | NFC_INT_MSK);
+	wake_up(&irq_waitq);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Functions to transfer data to/from spare erea.
+ */
+static void copy_from_spare(struct mtd_info *mtd, void *pbuf, int len)
+{
+	u16 ooblen = mtd->oobsize;
+	u8 i, count, size;
+
+	count = mtd->writesize >> 9;
+	size = (ooblen / count >> 1) << 1;
+
+	for (i = 0; i < count - 1; i++) {
+		memcpy(pbuf, SPARE_AREA(i), size);
+		pbuf += size;
+		len -= size;
+	}
+	memcpy(pbuf, SPARE_AREA(i), len);
+}
+
+static void copy_to_spare(struct mtd_info *mtd, void *pbuf, int len)
+{
+	u16 ooblen = mtd->oobsize;
+	u8 i, count, size;
+
+	count = mtd->writesize >> 9;
+	size = (ooblen / count >> 1) << 1;
+
+	for (i = 0; i < count - 1; i++) {
+		memcpy(SPARE_AREA(i), pbuf, size);
+		pbuf += size;
+		len -= size;
+	}
+	memcpy(SPARE_AREA(i), pbuf, len);
+}
+
+/*!
+ * This function polls the NFC to wait for the basic operation to complete by
+ * checking the INT bit of config2 register.
+ *
+ * @param       maxRetries     number of retry attempts (separated by 1 us)
+ * @param       useirq         True if IRQ should be used rather than polling
+ */
+static void wait_op_done(int maxRetries, bool useirq)
+{
+
+	if (useirq) {
+		if ((in_be16(NFC_CONFIG2) & NFC_INT) == 0) {
+			/* Enable Interrupt */
+			out_be16(NFC_CONFIG1,
+				in_be16(NFC_CONFIG1) & ~NFC_INT_MSK);
+			wait_event(irq_waitq,
+				   (in_be16(NFC_CONFIG2) & NFC_INT));
+		}
+	} else {
+		while (1) {
+			maxRetries--;
+			if (in_be16(NFC_CONFIG2) & NFC_INT)
+				break;
+			udelay(1);
+		}
+		if (maxRetries <= 0)
+			DEBUG(MTD_DEBUG_LEVEL0, "%s: INT not set\n",
+			      __func__);
+	}
+	/* Clear Interrupt */
+	out_be16(NFC_CONFIG2, (in_be16(NFC_CONFIG2) & ~NFC_INT));
+}
+
+/*!
+ * This function issues the specified command to the NAND device and
+ * waits for completion.
+ *
+ * @param       cmd     command for NAND Flash
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_cmd(u16 cmd, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_cmd(%#x, %d)\n", cmd, useirq);
+
+	out_be16(NFC_FLASH_CMD, cmd);
+	out_be16(NFC_CONFIG2, NFC_CMD);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+/*!
+ * This function sends an address (or partial address) to the
+ * NAND device.  The address is used to select the source/destination for
+ * a NAND command.
+ *
+ * @param       addr    address to be written to NFC.
+ * @param       useirq  True if IRQ should be used rather than polling
+ */
+static void send_addr(u16 addr, bool useirq)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "send_addr(%#x %d)\n", addr, useirq);
+	out_be16(NFC_FLASH_ADDR, (addr << NFC_FLASH_ADDR_SHIFT));
+
+	out_be16(NFC_CONFIG2, NFC_ADDR);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, useirq);
+}
+
+/*!
+ * This function requests the NFC to initate the transfer
+ * of data currently in the NFC RAM buffer to the NAND device.
+ *
+ * @param	buf_id	      Specify Internal RAM Buffer number (0-3)
+ */
+static void send_prog_page(u8 buf_id)
+{
+	u32 val = buf_id;
+	DEBUG(MTD_DEBUG_LEVEL3, "%s\n", __func__);
+
+	/* Set RBA bits for BUFFER val */
+	out_be16(NFC_BUF_ADDR, val);
+
+	out_be16(NFC_CONFIG2, NFC_INPUT);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+}
+
+/*!
+ * This function requests the NFC to initated the transfer
+ * of data from the NAND device into in the NFC ram buffer.
+ *
+ * @param  	buf_id		Specify Internal RAM Buffer number (0-3)
+ */
+static void send_read_page(u8 buf_id)
+{
+	u32 val = buf_id;
+	DEBUG(MTD_DEBUG_LEVEL3, "%s\n", __func__);
+
+	/* Set RBA bits for BUFFER val */
+	out_be16(NFC_BUF_ADDR, val);
+
+	out_be16(NFC_CONFIG2, NFC_OUTPUT);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+}
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device ID.
+ */
+static void send_read_id(void)
+{
+	u32 val = 0;
+
+	/* NFC buffer 0 is used for device ID output */
+	/* Set RBA bits for BUFFER0 */
+
+	out_be16(NFC_BUF_ADDR, val);
+
+	/* Read ID into main buffer */
+	out_be16(NFC_CONFIG2, NFC_ID);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+
+}
+
+/*!
+ * This function requests the NFC to perform a read of the
+ * NAND device status and returns the current status.
+ *
+ * @return  device status
+ */
+static u16 get_dev_status(void)
+{
+	volatile u8 *mainBuf = MAIN_AREA(1);
+	volatile u32 store;
+	u32 val = 1;
+	u16 ret;
+	/* Issue status request to NAND device */
+
+	/* store the main area1 first word, later do recovery */
+	store = *((u32 *) mainBuf);
+	*(u32 *) mainBuf = 0x0;
+
+	/*
+	 * NFC buffer 1 is used for device status to prevent
+	 * corruption of read/write buffer on status requests.
+	 */
+
+	/* Set RBA bits for BUFFER1 */
+	out_be16(NFC_BUF_ADDR, val);
+
+	/* Read status into main buffer */
+	out_be16(NFC_CONFIG2, NFC_STATUS);
+
+	/* Wait for operation to complete */
+	wait_op_done(TROP_US_DELAY, true);
+
+	/* Status is placed in first word of main buffer */
+	/* get status, then recovery area 1 data */
+	if (in_be16(NFC_CONFIG1) & NFC_BIG)
+		ret = mainBuf[0];
+	else
+		ret = mainBuf[3];
+	*((u32 *) mainBuf) = store;
+	return ret;
+}
+
+/*!
+ * This functions is used by upper layer to checks if device is ready
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ *
+ * @return  0 if device is busy else 1
+ */
+static int mpc5121_nand_dev_ready(struct mtd_info *mtd)
+{
+	return 1;
+}
+
+static void mpc5121_nand_enable_hwecc(struct mtd_info *mtd, int mode)
+{
+	out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_ECC_EN));
+	return;
+}
+
+/*
+ * Function to record the ECC corrected/uncorrected errors resulted
+ * after a page read. This NFC detects and corrects upto to 4 symbols
+ * of 9-bits each.
+ */
+static int mpc5121_check_ecc_status(struct mtd_info *mtd)
+{
+	u32 ecc_stat, err;
+	int no_subpages = 1;
+	int ret = 0;
+	u8 ecc_bit_mask, err_limit;
+	int is_4bit_ecc = in_be16(NFC_CONFIG1) & NFC_ECC_MODE_4;
+
+	ecc_bit_mask = (is_4bit_ecc ? 0x7 : 0xf);
+	err_limit = (is_4bit_ecc ? 0x4 : 0x8);
+
+	no_subpages = mtd->writesize >> 9;
+
+	ecc_stat = in_be16(NFC_ECC_STATUS1);
+	do {
+		err = ecc_stat & ecc_bit_mask;
+		if (err > err_limit)
+			return -1;
+		else
+			ret += err;
+		ecc_stat >>= 4;
+	} while (--no_subpages);
+
+	return ret;
+}
+
+/*
+ * Function to correct the detected errors. This NFC corrects all the errors
+ * detected. So this function is not required.
+ */
+static int mpc5121_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+				 u_char *read_ecc, u_char *calc_ecc)
+{
+	panic("Shouldn't be called here: %d\n", __LINE__);
+	return 0;		/* FIXME */
+}
+
+/*
+ * Function to calculate the ECC for the data to be stored in the Nand device.
+ * This NFC has a hardware RS(511,503) ECC engine together with the RS ECC
+ * CONTROL blocks are responsible for detection  and correction of up to
+ * 4 symbols of 9 bits each in 528 byte page.
+ * So this function is not required.
+ */
+
+static int mpc5121_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
+				  u_char *ecc_code)
+{
+	panic(KERN_ERR "Shouldn't be called here %d \n", __LINE__);
+	return 0;		/* FIXME */
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static u_char mpc5121_nand_read_byte(struct mtd_info *mtd)
+{
+	volatile u8 *mainBuf = MAIN_AREA(0);
+	volatile u8 *spareBuf = SPARE_AREA(0);
+	u16 col = g_nandfc_info.colAddr;
+	u_char rv;
+
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest) {
+		rv = get_dev_status() & 0xff;
+		return rv;
+	}
+
+	if (g_nandfc_info.bSpareOnly)
+		rv = spareBuf[col];
+	else
+		rv = mainBuf[col];
+
+	g_nandfc_info.colAddr++;
+	return rv;
+}
+
+/*!
+  * This function reads word from the NAND Flash
+  *
+  * @param     mtd     MTD structure for the NAND Flash
+  *
+  * @return    data read from the NAND Flash
+  */
+static u16 mpc5121_nand_read_word(struct mtd_info *mtd)
+{
+	u16 col, rdWord;
+	volatile u16 *mainBuf = MAIN_AREA(0);
+	volatile u16 *spareBuf = SPARE_AREA(0);
+
+	/* Get column for 16-bit access */
+	col = g_nandfc_info.colAddr >> 1;
+
+	/* If we are accessing the spare region */
+	if (g_nandfc_info.bSpareOnly)
+		rdWord = spareBuf[col];
+	else
+		rdWord = mainBuf[col];
+
+	/* Update saved column address */
+	g_nandfc_info.colAddr += 2;
+
+	return rdWord;
+}
+
+/*!
+ * This function reads byte from the NAND Flash
+ *
+ * @param     mtd     MTD structure for the NAND Flash
+ *
+ * @return    data read from the NAND Flash
+ */
+static u_char mpc5121_nand_read_byte16(struct mtd_info *mtd)
+{
+	/* Check for status request */
+	if (g_nandfc_info.bStatusRequest)
+		return (get_dev_status() & 0xff);
+
+	return mpc5121_nand_read_word(mtd) & 0xff;
+}
+
+/*!
+ * This function writes data of length \b len from buffer \b buf to the NAND
+ * internal RAM buffer's MAIN area 0.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be written to NAND Flash
+ * @param       len     number of bytes to be written
+ */
+static void mpc5121_nand_write_buf(struct mtd_info *mtd,
+			       const u_char *buf, int len)
+{
+	printk(KERN_INFO "re-work may be needed?\n");
+	if (g_nandfc_info.colAddr >= mtd->writesize || \
+					g_nandfc_info.bSpareOnly) {
+		copy_to_spare(mtd, (char *)buf, len);
+		return;
+	} else {
+		volatile uint32_t *base;
+
+		g_nandfc_info.colAddr += len;
+		base = (uint32_t *) MAIN_AREA(0);
+		memcpy((void *)base, (void *)buf, len);
+	}
+}
+
+/*!
+ * This function id is used to read the data buffer from the NAND Flash. To
+ * read the data from NAND Flash first the data output cycle is initiated by
+ * the NFC, which copies the data to RAMbuffer. This data of length \b len is
+ * then copied to buffer \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be read from NAND Flash
+ * @param       len     number of bytes to be read
+ */
+static void mpc5121_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+
+	if (g_nandfc_info.colAddr >= mtd->writesize || \
+				g_nandfc_info.bSpareOnly) {
+		copy_from_spare(mtd, buf, len);
+		return;
+	} else {
+		volatile uint32_t *base;
+
+		base = (uint32_t *) MAIN_AREA(0);
+		g_nandfc_info.colAddr += len;
+		memcpy((void *)buf, (void *)base, len);
+	}
+}
+
+/*!
+ * This function is used by the upper layer to verify the data in NAND Flash
+ * with the data in the \b buf.
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       buf     data to be verified
+ * @param       len     length of the data to be verified
+ *
+ * @return      -EFAULT if error else 0
+ *
+ */
+static int mpc5121_nand_verify_buf(struct mtd_info *mtd, const u_char *buf,
+			       int len)
+{
+	volatile u32 *mainBuf = (u32 *) MAIN_AREA(0);
+	/* check for 32-bit alignment? */
+	uint32_t *p = (uint32_t *) buf;
+
+	for (; len > 0; len -= 4)
+		if (*p++ != *mainBuf++)
+			return -EFAULT;
+	return 0;
+}
+
+static void mpc5121_chipselect_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121ads-cpld");
+	priv->nandcsreg = of_iomap(np, 0) + 9;
+	of_node_put(np);
+}
+
+static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
+{
+	const u32 *prop;
+	int len;
+
+	prop = of_get_property(np, name, &len);
+	if (prop && len == 4)
+		return *prop;
+	return def;
+}
+
+static int
+mpc5121_nand_check_hw_config(struct device_node *np, struct nand_chip *this)
+{
+	struct device_node *resetnode;
+	ulong *reset;
+	int rcw_romloc;
+	int rcw_ps;
+	int width;
+	int rcw_devicewidth;
+	int writesize;
+	int rcw_writesize = 0;
+	int sparesize;
+	int rcw_sparesize = 0;
+	int rv = 0;
+
+	resetnode = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-reset");
+	reset = of_iomap(resetnode, 0) + 4;
+
+	width = get_int_prop(np, "bank-width", 0);
+	if (!width)  {
+		printk(KERN_ERR DRV_NAME ": "
+			"No width property in device tree nfc device node, "
+			"unable to verify reset conf word\n");
+		rv = -EINVAL;
+		goto out;
+	}
+	writesize = get_int_prop(np, "write-size", 0);
+	if (!writesize)  {
+		printk(KERN_ERR DRV_NAME ": "
+			"No write-size property in device tree nfc device node,"
+			"unable to verify reset conf word\n");
+		rv = -EINVAL;
+		goto out;
+	}
+	sparesize = get_int_prop(np, "spare-size", 0);
+	if (!sparesize)  {
+		printk(KERN_ERR DRV_NAME ": "
+			"No spare-size property in device tree nfc device node,"
+			"unable to verify reset conf word\n");
+		rv = -EINVAL;
+		goto out;
+	}
+	if (!reset)  {
+		printk(KERN_ERR DRV_NAME ": "
+			"No fsl,mpc5121-reset node in device tree, "
+			"unable to verify reset conf word\n");
+		rv = -EINVAL;
+		goto out;
+	}
+
+	rcw_romloc = (*reset >> 21) & 0x3;
+	rcw_ps = (*reset >> 7) & 0x1;
+	rcw_devicewidth = ((*reset >> 6) & 0x1) ? 2 : 1;
+
+	if (rcw_devicewidth != width) {
+		printk(KERN_ERR DRV_NAME ": "
+			"Device width mismatch, device tree width is %d, "
+			"reset configuration word width is %d\n",
+			width, rcw_devicewidth);
+		rv = -EINVAL;
+		goto out;
+	}
+
+	if (width == 2) {
+		this->options |= NAND_BUSWIDTH_16;
+		this->read_byte = mpc5121_nand_read_byte16;
+	}
+
+	/*
+	 * Decode the rcw_ps and rcw_romloc
+	 * bits from reset config word
+	 * to determine write size
+	 */
+	switch (rcw_ps << 2 | rcw_romloc) {
+	case 0x0:
+	case 0x1:
+		rcw_writesize = 512;
+		rcw_sparesize = 16;
+		break;
+	case 0x2:
+	case 0x3:
+		rcw_writesize = 4096;
+		rcw_sparesize = 128;
+		break;
+	case 0x4:
+	case 0x5:
+		rcw_writesize = 2048;
+		rcw_sparesize = 64;
+		break;
+	case 0x6:
+	case 0x7:
+		rcw_writesize = 4096;
+		rcw_sparesize = 218;
+		break;
+	}
+	if (writesize != rcw_writesize) {
+		printk(KERN_ERR DRV_NAME ": "
+			"Device write size mismatch, "
+			"write-size from device tree node is %d, "
+			"size from reset configuration word is %d\n",
+			writesize, rcw_writesize);
+		rv = -EINVAL;
+		goto out;
+	}
+	if (sparesize != rcw_sparesize) {
+		printk(KERN_ERR DRV_NAME ": "
+			"Device spare size mismatch, "
+			"spare-size from device tree node is %d, "
+			"size from reset configuration word is %d\n",
+			sparesize, rcw_sparesize);
+		rv = -EINVAL;
+		goto out;
+	}
+	/*
+	 * Only support 2K for now.
+	 * Remove this when others are supported
+	 */
+	if (writesize != 2048) {
+		printk(KERN_ERR DRV_NAME ": "
+			"%d byte write size flash support is disabled/untested",
+			writesize);
+		rv = -EINVAL;
+		goto out;
+	}
+
+	priv->sparesize = sparesize;
+out:
+	iounmap(reset);
+	of_node_put(np);
+	return rv;
+}
+
+static void mpc5121_cs_enable(int chip)
+{
+	u8 v;
+
+	v = in_8(priv->nandcsreg);
+	v |= 0xf;
+	v &= ~(1<<chip);
+
+	out_8(priv->nandcsreg, v);
+}
+
+
+/*!
+ * This function is used by upper layer for select and deselect of the NAND
+ * chip
+ *
+ * @param       mtd     MTD structure for the NAND Flash
+ * @param       chip    val indicating select or deselect
+ */
+static void mpc5121_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	BUG_ON(priv->suspended);
+	if (chip >= priv->nr_chips) {
+		printk(KERN_ERR DRV_NAME ": "
+			"ERROR: Illegal chip select (chip = %d)\n", chip);
+		return;
+	}
+
+	if (chip < 0) {
+		out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) & ~NFC_CE));
+		iosync();
+		return;
+	}
+
+	out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_CE));
+	iosync();
+
+	/* Turn on appropriate chip */
+	mpc5121_cs_enable(chip);
+}
+
+/*
+ * Function to perform the address cycles.
+ */
+static void
+mpc5121_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)
+{
+	struct nand_chip *this = mtd->priv;
+	u32 page_mask = this->pagemask;
+
+	if (column != -1) {
+		send_addr(column & 0xff, false);
+		/* large page nand needs an extra column addr cycle */
+		if (IS_2K_PAGE_NAND)
+			send_addr((column >> 8) & 0xf, false);
+		else if (IS_4K_PAGE_NAND)
+			send_addr((column >> 8) & 0x1f, false);
+	}
+	if (page_addr != -1)
+		do {
+			send_addr((page_addr & 0xff), false);
+			page_mask >>= 8;
+			page_addr >>= 8;
+		} while (page_mask != 0);
+}
+
+/*
+ * Function to read a page from nand device.
+ */
+static void read_full_page(struct mtd_info *mtd, int page_addr)
+{
+	send_cmd(NAND_CMD_READ0, false);
+
+	mpc5121_do_addr_cycle(mtd, 0, page_addr);
+
+	if (IS_LARGE_PAGE_NAND) {
+		send_cmd(NAND_CMD_READSTART, false);
+		send_read_page(0);
+	} else
+		send_read_page(0);
+}
+
+/*!
+ * This function is used by the upper layer to write command to NAND Flash for
+ * different operations to be carried out on NAND Flash
+ *
+ * @param       mtd             MTD structure for the NAND Flash
+ * @param       command         command for NAND Flash
+ * @param       column          column offset for the page read
+ * @param       page_addr       page to be read from NAND Flash
+ */
+static void mpc5121_nand_command(struct mtd_info *mtd, unsigned command,
+			     int column, int page_addr)
+{
+	bool useirq = true;
+
+	DEBUG(MTD_DEBUG_LEVEL3,
+	      "mpc5121_nand_command (cmd = %#x, col = %#x, page = %#x)\n",
+	      command, column, page_addr);
+	/*
+	 * Reset command state information
+	 */
+	g_nandfc_info.bStatusRequest = false;
+
+	/* Reset column address to 0 */
+	g_nandfc_info.colAddr = 0;
+
+	/*
+	 * Command pre-processing step
+	 */
+	switch (command) {
+	case NAND_CMD_STATUS:
+		g_nandfc_info.bStatusRequest = true;
+		break;
+
+	case NAND_CMD_READ0:
+		g_nandfc_info.bSpareOnly = false;
+		useirq = false;
+		break;
+
+	case NAND_CMD_READOOB:
+		g_nandfc_info.colAddr = column;
+		g_nandfc_info.bSpareOnly = true;
+		useirq = false;
+		command = NAND_CMD_READ0;	/* only READ0 is valid */
+		break;
+
+	case NAND_CMD_SEQIN:
+		if (column >= mtd->writesize)
+			g_nandfc_info.bSpareOnly = true;
+		else
+			g_nandfc_info.bSpareOnly = false;
+		useirq = false;
+		break;
+
+	case NAND_CMD_PAGEPROG:
+		if (!g_nandfc_info.bSpareOnly)
+			send_prog_page(0);
+		else
+			return;
+		break;
+
+	case NAND_CMD_ERASE1:
+		useirq = false;
+		break;
+	case NAND_CMD_ERASE2:
+		useirq = false;
+		break;
+	}
+
+	/*
+	 * Write out the command to the device.
+	 */
+	send_cmd(command, useirq);
+
+	mpc5121_do_addr_cycle(mtd, column, page_addr);
+
+	/*
+	 * Command post-processing step
+	 */
+	switch (command) {
+
+	case NAND_CMD_READOOB:
+	case NAND_CMD_READ0:
+		if (IS_LARGE_PAGE_NAND) {
+			/* send read confirm command */
+			send_cmd(NAND_CMD_READSTART, true);
+			/* read for each AREA */
+			send_read_page(0);
+		} else
+			send_read_page(0);
+		break;
+
+	case NAND_CMD_READID:
+		send_read_id();
+		break;
+	}
+}
+
+#ifdef CONFIG_MPC5121_NAND_LOW_LEVEL_ERASE
+static void mpc5121_low_erase(struct mtd_info *mtd)
+{
+
+	struct nand_chip *this = mtd->priv;
+	unsigned int page_addr, addr;
+	u_char status;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MPC5121_ND: mpc5121_low_erase:Erasing NAND\n");
+	for (addr = 0; addr < this->chipsize; addr += mtd->erasesize) {
+		page_addr = addr / mtd->writesize;
+		mpc5121_nand_command(mtd, NAND_CMD_ERASE1, -1, page_addr);
+		mpc5121_nand_command(mtd, NAND_CMD_ERASE2, -1, -1);
+		mpc5121_nand_command(mtd, NAND_CMD_STATUS, -1, -1);
+		status = mpc5121_nand_read_byte(mtd);
+		if (status & NAND_STATUS_FAIL) {
+			printk(KERN_ERR
+			       "ERASE FAILED(block = %d,status = %#x)\n",
+			       addr / mtd->erasesize, status);
+		}
+	}
+
+}
+#else
+#define mpc5121_low_erase(x)
+#endif
+
+static int mpc5121_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long timeo = jiffies;
+	int status, state = chip->state;
+
+	if (state == FL_ERASING)
+		timeo += (HZ * 400) / 1000;
+	else
+		timeo += (HZ * 20) / 1000;
+
+	send_cmd(NAND_CMD_STATUS, 1);
+
+	while (time_before(jiffies, timeo)) {
+/* On board Rev 3 and Rev 4.0, there are different NFC modules, until now,
+ * this driver only supports Rev 4.0, in the future, it will possibly try
+ * to support both versions, so CONFIG_ARCH_MPC5121_HAS_NFC_V3 is used.
+ */
+#ifdef CONFIG_ARCH_MPC5121_HAS_NFC_V3
+		if (chip->dev_ready) {
+			if (chip->dev_ready(mtd))
+				break;
+		} else
+#endif
+		{
+			if (get_dev_status() & NAND_STATUS_READY)
+				break;
+		}
+		cond_resched();
+	}
+
+	status = (int)(get_dev_status());
+	return status;
+}
+
+static int mpc5121_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			     int page, int sndcmd)
+{
+	if (sndcmd) {
+		read_full_page(mtd, page);
+		sndcmd = 0;
+	}
+
+	copy_from_spare(mtd, chip->oob_poi, mtd->oobsize);
+	return sndcmd;
+}
+
+static int mpc5121_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			      int page)
+{
+	int status = 0;
+	int read_oob_col = 0;
+
+	send_cmd(NAND_CMD_READ0, false);
+	send_cmd(NAND_CMD_SEQIN, false);
+	mpc5121_do_addr_cycle(mtd, read_oob_col, page);
+
+	/* copy the oob data */
+	copy_to_spare(mtd, chip->oob_poi, mtd->oobsize);
+
+	send_prog_page(0);
+
+	send_cmd(NAND_CMD_PAGEPROG, true);
+
+	status = mpc5121_nand_wait(mtd, chip);
+	if (status & NAND_STATUS_FAIL)
+		return -EIO;
+	return 0;
+}
+
+static int mpc5121_nand_read_page(struct mtd_info *mtd, struct nand_chip *chip,
+			      uint8_t *buf)
+{
+	int stat;
+
+	stat = mpc5121_check_ecc_status(mtd);
+	if (stat == -1) {
+		mtd->ecc_stats.failed++;
+		printk(KERN_WARNING "UnCorrectable RS-ECC Error\n");
+	} else {
+		mtd->ecc_stats.corrected += stat;
+		if (stat)
+			pr_debug("%d Symbol Correctable RS-ECC Error\n", stat);
+	}
+
+	memcpy((void *)buf, (void *)MAIN_AREA(0), mtd->writesize);
+	copy_from_spare(mtd, chip->oob_poi, mtd->oobsize);
+	return 0;
+}
+
+static void
+mpc5121_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+				const uint8_t *buf)
+{
+	memcpy((void *)MAIN_AREA(0), buf, mtd->writesize);
+	copy_to_spare(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+/* Define some generic bad / good block scan pattern which are used
+ * while scanning a device for factory marked good / bad blocks. */
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
+
+static struct nand_bbt_descr smallpage_memorybased = {
+	.options = NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr largepage_memorybased = {
+	.options = 0,
+	.offs = 5,
+	.len = 2,
+	.pattern = scan_ff_pattern
+};
+
+/* Generic flash bbt decriptors
+*/
+static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 0,
+	.len = 4,
+	.veroffs = 4,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+static int mpc5121_nand_scan_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	if (IS_2K_PAGE_NAND)
+		this->ecc.layout = &nand_hw_eccoob_2k;
+	else if (IS_4K_PAGE_NAND)
+		if (priv->sparesize == 128)
+			this->ecc.layout = &nand_hw_eccoob_4k;
+		else
+			this->ecc.layout = &nand_hw_eccoob_4k_218_spare;
+	else
+		this->ecc.layout = &nand_hw_eccoob_512;
+
+	out_be16(NFC_SPAS, (in_be16(NFC_SPAS) & 0xff00) | (priv->sparesize/2));
+
+	/*
+	 * Only use 8bit ecc (aka not 4 bit) if large spare size
+	 */
+	if (priv->sparesize == 218)
+		out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) & ~NFC_ECC_MODE_4));
+	else
+		out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_ECC_MODE_4));
+
+	/* propagate ecc.layout to mtd_info */
+	mtd->ecclayout = this->ecc.layout;
+
+	/* jffs2 should not write oob */
+	mtd->flags &= ~MTD_OOB_WRITEABLE;
+
+	/* use flash based bbt */
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
+	/* update flash based bbt */
+	this->options |= NAND_USE_FLASH_BBT;
+
+	if (!this->badblock_pattern)
+		this->badblock_pattern = (mtd->writesize > 512) ?
+		    &largepage_memorybased : &smallpage_memorybased;
+
+	/* Build bad block table */
+	return nand_scan_bbt(mtd, this->badblock_pattern);
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+static int parse_flash_partitions(struct device_node *dp)
+{
+	int i;
+	const  char *name;
+	struct device_node *pp;
+	int nr_parts = 0;
+
+	for (pp = dp->child; pp; pp = pp->sibling)
+		nr_parts++;
+
+	if (!nr_parts)
+		return 0;
+
+	priv->parts = devm_kzalloc(priv->dev,
+			nr_parts * sizeof(struct mtd_partition),
+			GFP_KERNEL);
+	if (!priv->parts)
+		return -ENOMEM;
+	for (pp = dp->child, i = 0; pp; pp = pp->sibling, i++) {
+		const u32 *reg;
+		int len;
+
+		reg = of_get_property(pp, "reg", &len);
+		if (!reg || (len != 2*sizeof(u32))) {
+			printk(KERN_ERR DRV_NAME ": "
+				"Invalid 'reg' on %s\n", dp->full_name);
+			kfree(priv->parts);
+			priv->parts = NULL;
+			return -EINVAL;
+		}
+		priv->parts[i].offset = reg[0];
+		priv->parts[i].size = reg[1];
+
+		name = of_get_property(pp, "label", &len);
+		if (!name)
+			name = of_get_property(pp, "name", &len);
+		priv->parts[i].name = (char *)name;
+
+		if (of_get_property(pp, "read-only", &len))
+			priv->parts[i].mask_flags = MTD_WRITEABLE;
+	}
+	return nr_parts;
+}
+#endif
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and
+ *                remove functions
+ *
+ * @return  The function always returns 0.
+ */
+static int __init mpc5121_nand_probe(struct of_device *op,
+		    const struct of_device_id *match)
+{
+	struct device_node *np = op->node;
+	struct device *dev = &op->dev;
+	struct nand_chip *this;
+	struct mtd_info *mtd;
+	int rv = 0;
+	struct resource res;
+	size_t size_regs;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		printk(KERN_ERR DRV_NAME "%s: failed to allocate priv struct\n",
+		       __func__);
+		return -ENOMEM;
+	}
+
+	/* structures must be linked */
+	this = &priv->nand;
+	mtd = &priv->mtd;
+	mtd->priv = this;
+	mtd->name = "NAND";
+	mtd->owner = THIS_MODULE;
+
+	/* 5 us command delay time */
+	this->chip_delay = 5;
+
+	this->priv = priv;	/* NEVER USED? */
+
+	this->dev_ready = mpc5121_nand_dev_ready;
+	this->cmdfunc = mpc5121_nand_command;
+	this->waitfunc = mpc5121_nand_wait;
+	this->select_chip = mpc5121_nand_select_chip;
+	this->read_byte = mpc5121_nand_read_byte;
+	this->read_word = mpc5121_nand_read_word;
+	this->write_buf = mpc5121_nand_write_buf;
+	this->read_buf = mpc5121_nand_read_buf;
+	this->verify_buf = mpc5121_nand_verify_buf;
+	this->scan_bbt = mpc5121_nand_scan_bbt;
+
+	priv->irq = NO_IRQ;
+	priv->dev = dev;
+
+
+	/*
+	 * Get write size from device tree and do sanity check against
+	 * reset configuration word
+	 */
+	rv = mpc5121_nand_check_hw_config(np, this);
+	if (rv)
+		goto err;
+
+	priv->irq = irq_of_parse_and_map(np, 0);
+	if (priv->irq == NO_IRQ) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error mapping irq\n");
+		rv = -EINVAL;
+		goto err;
+	}
+
+	rv = of_address_to_resource(np, 0, &res);
+	if (rv) {
+		printk(KERN_ERR DRV_NAME ": "
+		       "Error parsing memory resource\n");
+		return rv;
+	}
+
+	priv->phys_regs = res.start;
+	size_regs = res.end - res.start + 1;
+
+	if (!devm_request_mem_region(dev, priv->phys_regs,
+				size_regs, DRV_NAME)) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error requesting register memory region\n");
+		rv = -EBUSY;
+		goto err;
+	}
+
+	priv->regs = devm_ioremap(dev, priv->phys_regs, size_regs);
+	if (!priv->regs) {
+		printk(KERN_ERR DRV_NAME ": "
+				"Error mapping registers\n");
+		rv = -ENOMEM;
+		goto err;
+	}
+
+	mpc5121_chipselect_init();
+
+	priv->nr_chips = get_int_prop(np, "chips", 1);
+
+	priv->nfc_clk = clk_get(dev, "nfc_clk");
+	clk_enable(priv->nfc_clk);	/* So reset will succeed */
+
+	out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_RST));
+
+	/* Disable interrupt */
+	out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_INT_MSK));
+
+	init_waitqueue_head(&irq_waitq);
+	rv = devm_request_irq(dev, priv->irq, &mpc5121_nfc_irq,
+						0, DRV_NAME, priv);
+	if (rv)
+		goto err;
+
+	if (hardware_ecc) {
+		this->ecc.read_page = mpc5121_nand_read_page;
+		this->ecc.write_page = mpc5121_nand_write_page;
+		this->ecc.read_oob = mpc5121_nand_read_oob;
+		this->ecc.write_oob = mpc5121_nand_write_oob;
+		this->ecc.layout = &nand_hw_eccoob_512;
+		this->ecc.calculate = mpc5121_nand_calculate_ecc;
+		this->ecc.hwctl = mpc5121_nand_enable_hwecc;
+		this->ecc.correct = mpc5121_nand_correct_data;
+		this->ecc.mode = NAND_ECC_HW;
+		/* RS-ECC is applied for both MAIN+SPARE not MAIN alone */
+		this->ecc.size = 512;
+		this->ecc.bytes = 9;	/* used for both main and spare area */
+		out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) | NFC_ECC_EN));
+	} else {
+		this->ecc.mode = NAND_ECC_SOFT;
+		out_be16(NFC_CONFIG1, (in_be16(NFC_CONFIG1) & ~NFC_ECC_EN));
+	}
+
+	out_be16(NFC_CONFIG1, in_be16(NFC_CONFIG1) & ~NFC_SP_EN);
+
+	/* Reset NAND */
+	this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* preset operation */
+	/* Unlock the internal RAM Buffer */
+	out_be16(NFC_CONFIG, NFC_BLS_UNLOCKED);
+
+	/* Blocks to be unlocked */
+	out_be16(NFC_UNLOCKSTART_BLKADDR0, 0x0);
+	out_be16(NFC_UNLOCKEND_BLKADDR0, 0xffff);
+
+	/* Unlock Block Command for given address range */
+	out_be16(NFC_WRPROT, NFC_WPC_UNLOCK);
+
+	/* Scan to find existence of the device */
+	if (nand_scan(mtd, priv->nr_chips)) {
+		DEBUG(MTD_DEBUG_LEVEL0,
+		      "MPC5121_ND: Unable to find any NAND device.\n");
+		rv = -ENXIO;
+		goto err;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	priv->nr_parts =
+	    parse_mtd_partitions(mtd, part_probes, &priv->parts, 0);
+	if (priv->nr_parts > 0)
+		add_mtd_partitions(mtd, priv->parts, priv->nr_parts);
+	else if ((priv->nr_parts = parse_flash_partitions(np)) > 0) {
+		dev_info(dev, "Using OF partition info\n");
+		add_mtd_partitions(mtd, priv->parts, priv->nr_parts);
+	} else
+#endif
+	{
+		printk(KERN_INFO "Registering %s as whole device\n", mtd->name);
+		add_mtd_device(mtd);
+	}
+
+	dev_set_drvdata(dev, mtd);
+
+	/* Erase all the blocks of a NAND -- depend on the config */
+	mpc5121_low_erase(mtd);
+
+	return 0;
+
+err:
+	mpc5121_nand_cleanup();
+	return rv;
+
+}
+
+static void mpc5121_nand_cleanup(void)
+{
+	if (!priv)
+		return;
+	if (priv->irq != NO_IRQ) {
+		devm_free_irq(priv->dev, priv->irq, priv);
+		priv->irq = NO_IRQ;
+	}
+	if (priv->nfc_clk) {
+		clk_disable(priv->nfc_clk);
+		clk_put(priv->nfc_clk);
+		priv->nfc_clk = NULL;
+	}
+	if (priv->nandcsreg)
+		iounmap(priv->nandcsreg);
+}
+
+ /*!
+  * Dissociates the driver from the device.
+  *
+  * @param   pdev  the device structure used to give information on which
+  *
+  * @return  The function always returns 0.
+  */
+
+static int __exit mpc5121_nand_remove(struct of_device *op)
+{
+	struct mtd_info *mtd = dev_get_drvdata(&op->dev);
+
+	nand_release(mtd);
+
+	mpc5121_nand_cleanup();
+
+	dev_set_drvdata(&op->dev, NULL);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * This function is called to put the NAND in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+
+static int mpc5121_nand_suspend(struct of_device *op, pm_message_t state)
+{
+	struct mtd_info *info = dev_get_drvdata(&op->dev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MPC5121_ND : NAND suspend\n");
+	if (info)
+		ret = info->suspend(info);
+
+	/* Disable the NFC clock */
+	clk_disable(priv->nfc_clk);
+
+	return ret;
+}
+
+/*!
+ * This function is called to bring the NAND back from a low power state. Refer
+ * to the document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device information structure
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mpc5121_nand_resume(struct of_device *op)
+{
+	struct mtd_info *info = dev_get_drvdata(&op->dev);
+	int ret = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL0, "MPC5121_ND : NAND resume\n");
+	/* Enable the NFC clock */
+	clk_enable(priv->nfc_clk);
+
+	if (info)
+		info->resume(info);
+
+	return ret;
+}
+
+#else
+#define mpc5121_nand_suspend   NULL
+#define mpc5121_nand_resume    NULL
+#endif				/* CONFIG_PM */
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct of_platform_driver mpc5121_nand_driver = {
+	.owner = THIS_MODULE,
+	.name = DRV_NAME,
+	.match_table = nfc_match,
+	.probe = mpc5121_nand_probe,
+	.remove = __exit_p(mpc5121_nand_remove),
+	.suspend = mpc5121_nand_suspend,
+	.resume = mpc5121_nand_resume,
+	.driver = {
+		   .name = DRV_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+/*!
+ * Main initialization routine
+ * @return  0 if successful; non-zero otherwise
+ */
+static int __init mpc5121_nd_init(void)
+{
+	/* Register the device driver structure. */
+	pr_info("MPC5121 MTD nand Driver %s\n", DVR_VER);
+	if (of_register_platform_driver(&mpc5121_nand_driver) != 0) {
+		printk(KERN_ERR "Driver register failed for mpc5121_nand_driver\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+/*!
+ * Clean up routine
+ */
+static void __exit mpc5121_nd_cleanup(void)
+{
+	/* Unregister the device structure */
+	of_unregister_platform_driver(&mpc5121_nand_driver);
+}
+
+module_init(mpc5121_nd_init);
+module_exit(mpc5121_nd_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MPC5121 Rev 2 NAND MTD driver");
+MODULE_LICENSE("GPL");
diff --git a/include/mtd/mtd-abi.h b/include/mtd/mtd-abi.h
index 6539b66..47ec136 100644
--- a/include/mtd/mtd-abi.h
+++ b/include/mtd/mtd-abi.h
@@ -30,11 +30,20 @@ struct mtd_oob_buf {
 #define MTD_POWERUP_LOCK	0x2000	/* Always locked after reset */
 #define MTD_OOB_WRITEABLE	0x4000	/* Use Out-Of-Band area */
 
+#ifdef CONFIG_PPC_MPC512x
+#define MTD_OOB_WRITEABLE	0x4000  /* Use Out-Of-Band area */
+#endif
+
 // Some common devices / combinations of capabilities
 #define MTD_CAP_ROM		0
 #define MTD_CAP_RAM		(MTD_WRITEABLE | MTD_BIT_WRITEABLE | MTD_NO_ERASE)
 #define MTD_CAP_NORFLASH	(MTD_WRITEABLE | MTD_BIT_WRITEABLE)
+#ifdef CONFIG_PPC_MPC512x
 #define MTD_CAP_NANDFLASH	(MTD_WRITEABLE | MTD_OOB_WRITEABLE)
+#define MTD_CAP_MLC_NANDFLASH	(MTD_WRITEABLE)
+#else
+#define MTD_CAP_NANDFLASH	(MTD_WRITEABLE)
+#endif
 
 /* ECC byte placement */
 #define MTD_NANDECC_OFF		0	// Switch off ECC (Not recommended)
-- 
1.6.0.3

