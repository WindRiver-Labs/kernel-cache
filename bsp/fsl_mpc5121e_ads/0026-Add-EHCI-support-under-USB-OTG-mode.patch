From dae7147fe65e8bcf35df3200749534f084bd5299 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:13 +0800
Subject: [PATCH] Add EHCI support under USB OTG mode

Add OTG macro process branch in EHCI driver,
mainly focus on platform resource allocation
and release, and OTG transceiver use as well.

Under OTG mode, USB otg driver must be loaded
before EHCI driver, what is more, platform
resource is managed by OTG driver which is
shared by EHCI and UDC driver.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/usb/host/ehci-fsl.c |  106 +++++++++++++++++++++++++++++++-----------
 drivers/usb/host/ehci.h     |    8 +++
 2 files changed, 86 insertions(+), 28 deletions(-)

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index e56bc46..cbbd546 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -30,6 +30,10 @@
 #undef CONFIG_PM
 #endif
 
+#ifdef CONFIG_USB_OTG
+extern struct resource *otg_get_resources(void);
+#endif
+
 #ifdef EHCI_PROC_PTC		/* /proc PORTSC:PTC support */
 #include <asm/uaccess.h>
 #define EFPSL 3			/* ehci fsl proc string length */
@@ -132,37 +136,53 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		return -ENODEV;
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!res) {
-		dev_err(&pdev->dev,
-			"Found HC with no IRQ. Check %s setup!\n",
-			dev_name(&pdev->dev));
-		return -ENODEV;
-	}
-	irq = res->start;
-
-	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	hcd = usb_create_hcd(driver, &pdev->dev, pdev->dev.bus_id);
 	if (!hcd) {
 		retval = -ENOMEM;
 		goto err1;
 	}
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev,
+#ifdef	CONFIG_USB_OTG
+	if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+		res = otg_get_resources();
+		if (!res) {
+			dev_err(&pdev->dev,
+				"Found HC with no IRQ. Check %s setup!\n",
+				pdev->dev.bus_id);
+			return -ENODEV;
+		}
+		irq = res[1].start;
+		hcd->rsrc_start = res[0].start;
+		hcd->rsrc_len = res[0].end - res[0].start + 1;
+	} else
+#endif
+	{
+		res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+		if (!res) {
+			dev_err(&pdev->dev,
+				"Found HC with no IRQ. Check %s setup!\n",
+				pdev->dev.bus_id);
+			return -ENODEV;
+		}
+		irq = res->start;
+
+		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+		if (!res) {
+			dev_err(&pdev->dev,
 			"Found HC with no register addr. Check %s setup!\n",
-			dev_name(&pdev->dev));
-		retval = -ENODEV;
-		goto err2;
-	}
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = res->end - res->start + 1;
-	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				pdev->dev.bus_id);
+			retval = -ENODEV;
+			goto err2;
+		}
+		hcd->rsrc_start = res->start;
+		hcd->rsrc_len = res->end - res->start + 1;
+		if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
 				driver->description)) {
-		dev_dbg(&pdev->dev, "controller already in use\n");
-		retval = -EBUSY;
-		goto err2;
+			dev_dbg(&pdev->dev, "controller already in use\n");
+			retval = -EBUSY;
+			goto err2;
+		}
 	}
+
 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 
 	if (hcd->regs == NULL) {
@@ -205,6 +225,31 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 
 	ehci_testmode_init(hcd_to_ehci(hcd));
 
+#ifdef CONFIG_USB_OTG
+	if (pdata->operating_mode == FSL_USB2_DR_OTG) {
+		struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+		dbg("pdev=0x%p  hcd=0x%p  ehci=0x%p\n", pdev, hcd, ehci);
+
+		ehci->transceiver = otg_get_transceiver();
+		dbg("ehci->transceiver=0x%p\n", ehci->transceiver);
+
+		if (ehci->transceiver) {
+			retval = otg_set_host(ehci->transceiver,
+					      &ehci_to_hcd(ehci)->self);
+			if (retval) {
+				if (ehci->transceiver)
+					put_device(ehci->transceiver->dev);
+				goto err4;
+			}
+		} else {
+			printk(KERN_ERR "can't find transceiver\n");
+			retval = -ENODEV;
+			goto err4;
+		}
+	}
+#endif
+
 	return retval;
 
       err4:
@@ -237,8 +282,16 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 void usb_hcd_fsl_remove(struct usb_hcd *hcd, struct platform_device *pdev)
 {
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
+#ifdef CONFIG_USB_OTG
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	if (ehci->transceiver) {
+		(void)otg_set_host(ehci->transceiver, 0);
+		put_device(ehci->transceiver->dev);
+	} else
+#endif
+		release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 
-	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
 	usb_remove_hcd(hcd);
 	usb_put_hcd(hcd);
 
@@ -501,9 +554,6 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	hcd->state = HC_STATE_SUSPENDED;
 	pdev->dev.power.power_state = PMSG_SUSPEND;
 
-	if (hcd->driver->suspend)
-		return hcd->driver->suspend(hcd, message);
-
 	/* ignore non-host interrupts */
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 5799298..2465f86 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -121,6 +121,14 @@ struct ehci_hcd {			/* one per controller */
 
 	u8			sbrn;		/* packed release number */
 
+#ifdef CONFIG_USB_OTG
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent
+	 */
+	struct otg_transceiver   *transceiver;
+#endif
+
 	/* irq statistics */
 #ifdef EHCI_STATS
 	struct ehci_stats	stats;
-- 
1.6.0.90.g436ed

