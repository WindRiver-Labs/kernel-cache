From cf882eee36e83b01bee2e477135665fca8d2a990 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:32 +0800
Subject: [PATCH 16/25] MPC5121 PM: alternate external int vector

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

Install a temporary handler at 0x500 (external interrupt
vector location) before entering Deep Sleep mode. This
handler clears the interrupt bit in PMC module. This patch
is required due to a hardware bug in MPC5121e where an interrupt is
raised, but a vector number is not returned on reading the IPIC.

Also remove the calls to mpc512x_clrevent from the gpio
and mscan interrupt handlers.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/kernel/irq.c                     |   11 ----
 arch/powerpc/platforms/512x/Makefile          |    2 +-
 arch/powerpc/platforms/512x/mpc512x.S         |   71 +++++++++++++++++++++++++
 arch/powerpc/platforms/512x/mpc512x_pm.c      |   31 +++--------
 arch/powerpc/platforms/512x/mpc512x_pm.h      |    3 +
 arch/powerpc/platforms/512x/mpc512x_pm_test.c |    6 --
 6 files changed, 83 insertions(+), 41 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/mpc512x.S

diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index 03738d1..b41234d 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -281,17 +281,6 @@ void do_IRQ(struct pt_regs *regs)
 	 */
 	irq = ppc_md.get_irq();
 
-#if defined(CONFIG_PM) && defined(CONFIG_PPC_MPC512x)
-	if (irq == NO_IRQ) {
-		/*
-		 * Got a NO INTERRUPT case. This could be RTC>TTR wake up
-		 * Interrupt from Power down mode. In the case the
-		 * mpc512x_pmc_clrevent would clear the event register of PMC.
-		 */
-		mpc512x_pmc_clrevent();
-	}
-#endif
-
 	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
 #ifdef CONFIG_IRQSTACKS
 		/* Switch to the irq stack to handle this */
diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index 22f02c2..9c8227f 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -8,5 +8,5 @@ obj-$(CONFIG_MPC5121_GENERIC)	+= mpc5121_generic.o
 obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
 obj-$(CONFIG_SPI)		+= mpc5121_spi.o
 obj-m				+= axe_dev.o
-obj-$(CONFIG_PM)		+= mpc512x_pm.o
+obj-$(CONFIG_PM)		+= mpc512x_pm.o mpc512x.o
 obj-$(CONFIG_MPC5121_PM_TEST)	+= mpc512x_pm_test.o
diff --git a/arch/powerpc/platforms/512x/mpc512x.S b/arch/powerpc/platforms/512x/mpc512x.S
new file mode 100644
index 0000000..6b3f8c1
--- /dev/null
+++ b/arch/powerpc/platforms/512x/mpc512x.S
@@ -0,0 +1,71 @@
+#include <asm/reg.h>
+#include <asm/ppc_asm.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/cache.h>
+
+#define NUM_CACHE_LINES (128*8)
+
+	.globl mpc5121_copy_pmcclr
+mpc5121_copy_pmcclr:
+
+	/* Coming here with interrupts disabled */
+	/* Copy code to Location 0x0 */
+	lis	r6, CONFIG_KERNEL_START@h
+	mr	r4, r6
+	li	r3, (code_atzero_end - code_atzero)/4
+	mtctr	r3
+	lis	r3, code_atzero@h
+	ori	r3, r3, code_atzero@l
+1:
+	lwz	r5, 0(r3)
+	stw	r5, 0(r4)
+	addi	r3, r3, 4
+	addi	r4, r4, 4
+	bdnz	1b
+
+	/* Copy the jump to 0x0 code at 0x500*/
+	lwz	r5, 0x500(r6)
+	stw	r5, 0(r6)
+	lwz	r5, 8(r6)
+	stw	r5, 0x500(r6)
+
+	/* Flush the cache */
+	lis	r3, CONFIG_KERNEL_START@h
+	ori	r3, r3, CONFIG_KERNEL_START@l
+
+	/* Let us load data starting from 0x600 loc */
+	addi	r3, r3, 0x600
+	li	r4, NUM_CACHE_LINES
+	mtctr	r4
+1:
+	lwz	r4, 0(r3)
+	addi	r3, r3, L1_CACHE_BYTES    /* Next line, please */
+	bdnz	1b
+	sync; isync
+	blr
+
+	.globl mpc5121_reinstall_handler
+mpc5121_reinstall_handler:
+
+	/* Rewrite original code at 0x500 */
+	lis	r6, CONFIG_KERNEL_START@h
+	lwz	r5, 0(r6)
+	stw	r5, 0x500(r6)
+	blr
+
+code_atzero:
+	.long 0x0  /*Space reserved for copying first word of code from 0x500 */
+	ba 0x504
+	ba 0xc  /* This code is not executed. This code is copied to 0x500 */
+	mtspr	SPRN_SPRG0, r3
+	mtspr	SPRN_SPRG1, r4
+	mfspr	r3, 311
+	addi	r3, r3, 0x1000  /* Assuming that MBAR is aligned to this size */
+	lwz	r4, 0x4(r3)
+	stw	r4, 0x4(r3)
+	mfspr	r3, SPRN_SPRG0
+	mfspr	r4, SPRN_SPRG1
+	ba	0x0
+code_atzero_end:
+	b 	code_atzero_end   /* Should never reach here*/
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.c b/arch/powerpc/platforms/512x/mpc512x_pm.c
index 938c49f..7be38a9 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.c
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.c
@@ -115,29 +115,6 @@ static void mpc512x_sleep(void)
 }
 
 /*
- * Name       : mpc512x_pmc_clrevent
- * Desc       : This function needs to be called by the interrupt handlers of
- * 		the wakeup sources. This is needed since a PMC interrupt is
- *		not guaranteed on MPC5121 v1.0, while an interrupt from the
- * 		wakeup source (GPIO / CAN) is.
- *
- * Parameters : void
- * Return     : void
- */
-void mpc512x_pmc_clrevent(void)
-{
-	struct mpc512x_pmc *pmc;
-
-	if (mpc512x_pm_data.mbar) {
-		pmc = (struct mpc512x_pmc *)((u32)mpc512x_pm_data.mbar +
-					MPC512x_IMMRBAR_PMC_OFFSET);
-		if (in_be32(&pmc->pmc_er) & 0x1)
-			out_be32(&pmc->pmc_er, 0x1);
-	}
-}
-EXPORT_SYMBOL_GPL(mpc512x_pmc_clrevent);
-
-/*
  * Name       : mpc512x_set_gpio_wakeup
  * Desc       : This function would initialise the gpio
  * 		with the given detection mode and enable the interrupt.
@@ -440,9 +417,17 @@ static int mpc512x_enter_deepsleep(void)
 				 | MPC512x_PMCCR_COREOFF);
 	out_be32(&pmc->pmc_mr, MPC512x_PMCMR_PMCIE);
 
+	/* Replace the Exception handler at 0x500 with our custom
+	 * handler to clear the PMC bit.
+	 */
+	mpc5121_copy_pmcclr();
+
 	/* Put core to SLEEP so that MPC512x enters Deep-Sleep.*/
 	mpc512x_sleep();
 
+	/* Restore the Original exception handler at 0x500 */
+	mpc5121_reinstall_handler();
+
 	/* We are out of Deep Sleep.. Lets restart jiffies */
 	wakeup_decrementer();
 
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.h b/arch/powerpc/platforms/512x/mpc512x_pm.h
index 2eaf4e5..2ee1181 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.h
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.h
@@ -117,4 +117,7 @@ struct mpc512x_pm{
 	u32 ddrc_sysconfig;
 };
 
+extern void mpc5121_copy_pmcclr(void);
+extern void mpc5121_reinstall_handler(void);
+
 #endif /* __MPC512x_PM_H__ */
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm_test.c b/arch/powerpc/platforms/512x/mpc512x_pm_test.c
index bda60f4..f5b93dc 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm_test.c
+++ b/arch/powerpc/platforms/512x/mpc512x_pm_test.c
@@ -29,8 +29,6 @@ u32 irq;
 
 static irqreturn_t mpc51xx_gpio_handler(int irq, void *dev_id)
 {
-	mpc512x_pmc_clrevent();
-
 	if (xgpio) {
 		out_be32((u32 *) ((u32) xgpio + 0x0C), 0xFF);
 #ifdef DEBUG
@@ -44,8 +42,6 @@ static irqreturn_t mpc51xx_can0_handler(int irq, void *dev_id)
 	u8 *mscan = xmscan;
 	if (mscan)
 		out_8(mscan + 8, in_8(mscan + 8));
-
-	mpc512x_pmc_clrevent();
 #ifdef DEBUG
 	printk(KERN_DEBUG "c0 \n");
 #endif
@@ -57,8 +53,6 @@ static irqreturn_t mpc51xx_can1_handler(int irq, void *dev_id)
 	u8 *mscan = xmscan + 0x80;
 	if (mscan)
 		out_8(mscan + 8, in_8(mscan + 8));
-
-	mpc512x_pmc_clrevent();
 #ifdef DEBUG
 	printk(KERN_DEBUG "c1 \n");
 #endif
-- 
1.6.3.1

