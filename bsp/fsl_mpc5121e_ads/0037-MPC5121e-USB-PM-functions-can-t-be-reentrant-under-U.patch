From 81e3956f48a8a9959a7557ad4145ca6db7791f06 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 15 Dec 2008 17:00:08 +0800
Subject: [PATCH] MPC5121e USB PM functions can't be reentrant under USB OTG mode

Allow USB Host and USB gadget to resume operation
after sleep or deep sleep in USB OTG mode.

Generally, OTG and UDC are in active status, USB host
is in suspend status. USB OTG driver enables Host or UDC
to be in active status according to vBus signal.

Before system enters into sleep or deep sleep, kernel
PM subsystem firstly needs to let all its devices enter
into suspend status, thus cause some drivers' suspend
function to be reentrant, that is to say, the kernel whole
PM mechanism is not consistent with USB OTG's, so needs
to synchronize them.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/usb/gadget/fsl_usb2_udc.c |   57 ++++++++++++++++++++++++++++++++++--
 drivers/usb/gadget/fsl_usb2_udc.h |    1 +
 drivers/usb/host/ehci-fsl.c       |   52 ++++++++++++++++++++++++++++++++-
 drivers/usb/host/ehci-hcd.c       |    2 +-
 include/linux/fsl_devices.h       |    1 +
 5 files changed, 106 insertions(+), 7 deletions(-)

diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index be61cc8..52af700 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -58,6 +58,13 @@
 
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
+#define PM_DEBUG	0
+#if PM_DEBUG
+#define DPRINTK(x...) printk(KERN_DEBUG x)
+#else
+#define DPRINTK(x...)
+#endif
+
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
@@ -1855,7 +1862,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 #ifdef CONFIG_USB_OTG
 	if (udc_controller->transceiver) {
 		/* Suspend the controller until OTG enable it */
-		dr_controller_stop(udc_controller);
+		udc_controller->stopped = 1;
 		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
 
 		/* export udc suspend/resume call to OTG */
@@ -2566,8 +2573,38 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
  -----------------------------------------------------------------*/
 static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	printk(KERN_INFO "USB Gadget suspended\r\n");
-	dr_controller_stop(udc_controller);
+	u32 mode, usbcmd;
+
+	DPRINTK("USB Gadget suspended\n");
+	mode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;
+	usbcmd = fsl_readl(&dr_regs->usbcmd);
+
+	DPRINTK("%s(): mode 0x%x stopped %d\n", __func__,
+			 mode, udc_controller->stopped);
+
+	/*
+	 * If the controller is already stopped, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller stopped at PM resume time.
+	 */
+	if (udc_controller->stopped) {
+		DPRINTK("gadget already stopped, leaving early\n");
+		udc_controller->already_stopped = 1;
+		return 0;
+	}
+
+	if (mode != USB_MODE_CTRL_MODE_DEVICE) {
+		DPRINTK("gadget not in device mode, leaving early\n");
+		return 0;
+	}
+
+	DPRINTK("%s gadget suspending...\n", __func__);
+
+	/* stop the controller */
+	usbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;
+	fsl_writel(usbcmd, &dr_regs->usbcmd);
+
+	udc_controller->stopped = 1;
 	return 0;
 }
 
@@ -2577,9 +2614,21 @@ static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
  *-----------------------------------------------------------------*/
 static int fsl_udc_resume(struct platform_device *pdev)
 {
-	printk(KERN_INFO "USB Gadget resumed\r\n");
+	DPRINTK("USB Gadget resumed\n");
+
+	/*
+	 * If the controller was stopped at suspend time, then
+	 * don't resume it now.
+	 */
+	if (udc_controller->already_stopped) {
+		udc_controller->already_stopped = 0;
+		DPRINTK("gadget was already stopped, leaving early \n");
+		return 0;
+	}
+
 	/* Enable DR irq reg and set controller Run */
 	if (udc_controller->stopped) {
+		DPRINTK("%s gadget resuming...\n", __func__);
 		dr_controller_setup(udc_controller);
 		dr_controller_run(udc_controller);
 	}
diff --git a/drivers/usb/gadget/fsl_usb2_udc.h b/drivers/usb/gadget/fsl_usb2_udc.h
index 5d5a6ad..435c3c3 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.h
+++ b/drivers/usb/gadget/fsl_usb2_udc.h
@@ -493,6 +493,7 @@ struct fsl_udc {
 	unsigned vbus_active:1;
 	unsigned stopped:1;
 	unsigned remote_wakeup:1;
+	unsigned already_stopped:1;
 
 	struct ep_queue_head *ep_qh;	/* Endpoints Queue-Head */
 	struct fsl_req *status_req;	/* ep0 status request */
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index cbbd546..040a2f1 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -34,6 +34,13 @@
 extern struct resource *otg_get_resources(void);
 #endif
 
+#define PM_DEBUG	0
+#if PM_DEBUG
+#define DPRINTK(x...) printk(KERN_DEBUG x)
+#else
+#define DPRINTK(x...)
+#endif
+
 #ifdef EHCI_PROC_PTC		/* /proc PORTSC:PTC support */
 #include <asm/uaccess.h>
 #define EFPSL 3			/* ehci fsl proc string length */
@@ -547,9 +554,28 @@ static int ehci_fsl_drv_suspend(struct platform_device *pdev,
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	u32 tmp;
+	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
 	/* DDD printk("%s()\n", __func__); */
-	printk(KERN_INFO "USB Host suspended\n");
+	DPRINTK("USB Host suspended\n");
+
+	if (pdata == NULL) {
+		printk(KERN_ERR "Invalide pdata (NULL)\n");
+		return 0;
+	}
+
+	/*
+	 * If the controller is already suspended, then this must be a
+	 * PM suspend.  Remember this fact, so that we will leave the
+	 * controller suspended at PM resume time.
+	 */
+	if (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {
+		DPRINTK("%s: already suspended, leaving early\n", __func__);
+		pdata->already_suspended = 1;
+		return 0;
+	}
+
+	DPRINTK("%s: Host suspending...\n", __func__);
 
 	hcd->state = HC_STATE_SUSPENDED;
 	pdev->dev.power.power_state = PMSG_SUSPEND;
@@ -593,7 +619,29 @@ static int ehci_fsl_drv_resume(struct platform_device *pdev)
 	u32 tmp;
 	struct fsl_usb2_platform_data *pdata = pdev->dev.platform_data;
 
-	printk(KERN_INFO "USB Host resumed\n");
+	DPRINTK("USB Host resumed\n");
+
+	if (pdata == NULL) {
+		printk(KERN_ERR "Invalide pdata (NULL)\n");
+		return 0;
+	}
+
+	/*
+	 * If the controller was already suspended at suspend time,
+	 * then don't resume it now.
+	 */
+	if (pdata->already_suspended) {
+		DPRINTK("already suspended, leaving early\n");
+		pdata->already_suspended = 0;
+		return 0;
+	}
+
+	if (pdev->dev.power.power_state.event != PM_EVENT_SUSPEND) {
+		printk(KERN_INFO "not suspended, leaving early\n");
+		return 0;
+	}
+
+	 DPRINTK("%s Host resuming...\n", __func__);
 
 	/* set host mode */
 	tmp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c2c469c..da85ad3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1076,7 +1076,7 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
-	retval = platform_driver_probe(&PLATFORM_DRIVER, PLATFORM_DRIVER.probe);
+	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
 		goto clean0;
 #endif
diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h
index 87b1094..a1e45b8 100644
--- a/include/linux/fsl_devices.h
+++ b/include/linux/fsl_devices.h
@@ -117,6 +117,7 @@ struct fsl_usb2_platform_data {
 	unsigned			es:1;	/* need USBMODE:ES */
 	unsigned			have_sysif_regs:1;
 	unsigned			le_setup_buf:1;
+	unsigned			already_suspended:1;
 #endif
 };
 
-- 
1.6.0.2.GIT

