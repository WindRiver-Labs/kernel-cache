From 3f420216d1d6cf8aae26c9c4ca185548aefb8977 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:45:56 +0800
Subject: [PATCH] Enable DMA facility

DMA is used by PATA and AC97 features.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/include/asm/fsldma.h     |  275 ++++++++++++
 arch/powerpc/include/asm/fsldma_reg.h |  172 ++++++++
 drivers/dma/Kconfig                   |    8 +
 drivers/dma/Makefile                  |    1 +
 drivers/dma/fsl_mpc5121_dma.c         |  760 +++++++++++++++++++++++++++++++++
 5 files changed, 1216 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/include/asm/fsldma.h
 create mode 100644 arch/powerpc/include/asm/fsldma_reg.h
 create mode 100644 drivers/dma/fsl_mpc5121_dma.c

diff --git a/arch/powerpc/include/asm/fsldma.h b/arch/powerpc/include/asm/fsldma.h
new file mode 100644
index 0000000..ba5ff47
--- /dev/null
+++ b/arch/powerpc/include/asm/fsldma.h
@@ -0,0 +1,275 @@
+/*
+ * Hongjun Chen <hong-jun.chen@freescale.com>
+ * Copyright (C) Freescale Semicondutor, Inc. 2007, 2008. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called COPYING.
+ */
+#ifndef _FSLDMA_H_
+#define _FSLDMA_H_
+
+#include <linux/dmaengine.h>
+#include "fsldma_reg.h"
+#include <linux/init.h>
+#include <linux/dmapool.h>
+#include <linux/cache.h>
+#include <linux/pci_ids.h>
+#include <linux/dmaengine.h>
+
+/* This setting can be changed by user */
+#define MAX_TCD_NUM_PER_CH	200
+
+#define FSL_LOW_COMPLETION_MASK	0xffffffc0
+#define DMA_NO_CHAN		-1;
+
+extern struct list_head dma_device_list;
+extern struct list_head dma_client_list;
+
+/* This defines the prototype of callback funtion registered by the drivers */
+typedef void (*fsl_dma_callback_t) (void *arg, int error_status);
+
+/*! This defines the list of device ID's for DMA */
+enum fsl_dma_device {
+	FSL_DMA_MDDRC = 32,
+	FSL_DMA_MBX = 31,
+	FSL_DMA_SDHC = 30,
+	FSL_DMA_NFC = 29,
+	FSL_DMA_PATA_TX = 28,
+	FSL_DMA_PATA_RX = 27,
+	FSL_DMA_LPC = 26,
+	FSL_DMA_SPDIF_RX = 25,
+	FSL_DMA_SPDIF_TX = 24,
+};
+
+struct ch_pri {
+	u8 g_pri;	/* The priority of group which this channel locates */
+	u8 ch_pri;	/* The priority of this channel */
+	u8 preempt;	/* Preemptable by other higher priority channel */
+};
+
+struct fsl_dma_mtcd_buf {
+	void *addr_v;
+	TCD *addr_va;		/* Aligned in 32 bytes */
+	dma_addr_t addr_p;
+	dma_addr_t addr_pa;	/* Aligned in 32 bytes */
+	size_t size;
+};
+
+/**
+ * struct fsl_device - internal representation of a FSL DMA device
+ * @reg: register space
+ * @tcd: transfer control descriptor space
+ * @common: embedded struct dma_device
+ * @ch_stat: the channel usage status
+ * @arbit_mode: the arbitration mode of group and channel
+ * @chpri: the channel priority, it is a tip for hack.
+ */
+struct fsl_device {
+	fsl_dma_reg *reg;
+	TCD *tcd;
+
+	/* TCDs in SDRAM memory */
+	struct fsl_dma_mtcd_buf mtcd;
+
+	struct dma_device common;
+
+	u32 irq;
+	spinlock_t ch_lock;	/* protect channel usage status */
+	u8 ch_stat[FSL_DMA_CH_NUM];	/* the channel usage status */
+
+	u8 arbit_mode;		/* the arbitration mode of group and channel,
+				   init once */
+};
+
+/**
+ * struct fsl_dma_chan - internal representation of a DMA channel
+ * @device:
+ * @sw_in_use:
+ * @completion:
+ * @completion_low:
+ * @completion_high:
+ * @completed_cookie: last cookie seen completed on cleanup
+ * @cookie: value of last cookie given to client
+ * @last_completion:
+ * @xfercap:
+ * @priority:  the
+ * @desc_lock:
+ * @free_desc:
+ * @used_desc:
+ * @resource:
+ * @device_node:
+ */
+
+struct fsl_dma_chan {
+	fsl_dma_callback_t cb_fn;	/* The callback function */
+	void *cb_args;		/* The argument of callback function */
+
+	int num_buf;
+	int pending;
+
+	struct fsl_device *device;
+	struct dma_chan common;
+
+	int ch_index;
+	struct ch_pri pri;
+
+	u32 status;
+	struct semaphore sem_lock;
+};
+
+/* Arbitration mode of group and channel */
+#define FSL_DMA_GROUP_FIX 	0x01
+#define	FSL_DMA_CH_FIX   	0x02
+
+/* This structure contains the information about a dma transfer */
+struct fsl_dma_requestbuf {
+	dma_addr_t src;		/* source address */
+	dma_addr_t dest;	/* destination address */
+	size_t soff;		/* Source address signed offset */
+	size_t doff;		/* Destination address signed offset */
+	size_t minor_loop;	/* Number of bytes for every minor loop */
+	size_t len;		/* the length of this transfer : bytes */
+};
+
+int fsl_dma_cfg_arbit_mode(int arbit_mode);
+
+/*!
+ * Before this function is called by the driver at open time, function
+ * fsl_dma_cfg_arbit_mode() should be called to configure the arbitration mode
+ * for dma engine. The DMA driver would do any initialization steps that is
+ * required to get the channel ready for data transfer.
+ *
+ * @param channel_id  a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @return returns a negative number on error if request for a DMA channel
+ *                     did not succeed, returns the channel number to be
+ *                     used on success.
+ */
+int fsl_dma_chan_request(int channel_id);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of fsl_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @return This function returns a negative number on error if buffer could not
+ *                     be added with DMA for transfer.
+ *                     On Success, it returns 0
+ */
+int fsl_dma_sg_config(int channel_num, struct scatterlist *sg,
+		      int num_buf, int num_of_bytes);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @return returns a negative number on error or 0 on success
+ */
+void fsl_dma_free_chan(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call fsl_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could
+ *                     not be added with DMA for transfer.
+ *                     On Success, it returns 0
+ */
+int fsl_dma_config(int channel_num,
+		   struct fsl_dma_requestbuf *dma_buf, int num_buf);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *                     could not be set for the channel or 0 on success
+ */
+int fsl_dma_callback_set(int channel_num,
+			 fsl_dma_callback_t callback, void *arg);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with fsl_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @return returns a negative number on error or 0 on success
+ */
+void fsl_dma_enable(int channel_num);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * fsl_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @return returns a negative number on error or 0 on success
+ */
+void fsl_dma_disable(int channel_num);
+
+/*!
+ * This indicates what status the channel is.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver.
+ * @return return a negative number on error or zero/positive number on success
+ */
+int fsl_dma_status(int channel_num);
+#endif				/* _FSLDMA_H_ */
diff --git a/arch/powerpc/include/asm/fsldma_reg.h b/arch/powerpc/include/asm/fsldma_reg.h
new file mode 100644
index 0000000..3a323b1
--- /dev/null
+++ b/arch/powerpc/include/asm/fsldma_reg.h
@@ -0,0 +1,172 @@
+/*
+ * Hongjun Chen <hong-jun.chen@freescale.com>
+ * Copyright (C) Freescale Semicondutor, Inc. 2007, 2008. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called COPYING.
+ */
+#ifndef _FSL_REGISTERS_H_
+#define _FSL_REGISTERS_H_
+
+/* Macro definitions */
+#define FSL_DMA_CH_NUM		64	/* Total channel number */
+#define FSL_DMA_DESC_NUM_PER_CH	64	/* Descriptors per channel */
+#define FSL_DMA_CH_NUM_IN_GROUP 16	/* Channel number in one group */
+#define FSL_DMA_GROUP_NUM 	(FSL_DMA_CH_NUM / FSL_DMA_CH_NUM_IN_GROUP)
+					/* Channel number in one group */
+
+#define FSL_DMA_TCD_OFFSET	0x1000	/* TCD(transfer control descriptor)
+					   area offset from IMMR
+					 */
+#define FSL_DMA_IRQ		65	/* DMA engine interrupt number */
+
+/* Arbitration mode of group and channel */
+#define FSL_DMA_GROUP_FIX	0x01	/* Fixed group arbitration, 0 for
+					   round robin mode
+					 */
+#define FSL_DMA_CH_FIX		0x02	/* Fixed channel arbitration, 0 for
+					   round robin mode
+					 */
+
+#define FSL_DMA_PRI_IN_USE	1	/* Hack: the global structure of
+					   priority is in use
+					 */
+#define FSL_DMA_PRI_NOT_USE	0	/* Hack: the global structure of
+					   priority is free
+					 */
+
+/* Register offset macro definitions */
+#define FSL_DMA_DMACR_ERGA_RR	(1<<3)	/* Enable Round Robin Group
+					   Arbitration */
+#define FSL_DMA_DMACR_ERCA_RR	(1<<2)	/* Enable Round Robin Channel
+					   Arbitration */
+
+#define FSL_DMA_GPR3PRI(pri)	(pri<<14)	/* Channel Group 3 Priority */
+#define FSL_DMA_GPR2PRI(pri)	(pri<<12)	/* Channel Group 2 Priority */
+#define FSL_DMA_GPR1PRI(pri)	(pri<<10)	/* Channel Group 1 Priority */
+#define FSL_DMA_GPR0PRI(pri)	(pri<<8)	/* Channel Group 0 Priority */
+
+#define FSL_DMA_CH_PREEMPT	(1<<7)	/* Enable channel preemption */
+
+#define FSL_DMA_DMAES_VLD	(1<<31)	/* At least one DMAERR bit is set */
+#define FSL_DMA_DMAES_GPE	(1<<15)	/* Group priority error */
+#define FSL_DMA_DMAES_CPE	(1<<14)	/* Channel priority error */
+#define FSL_DMA_DMAES_ERRCHN(err) \
+    ((err >> 8) & 0x3f)			/* Error channel number */
+#define FSL_DMA_DMAES_SAE	(1<<7)	/* Source address error */
+#define FSL_DMA_DMAES_SOE	(1<<6)	/* Source offset configuration */
+#define FSL_DMA_DMAES_DAE	(1<<5)	/* Destination address error */
+#define FSL_DMA_DMAES_DOE	(1<<4)	/* Destination offset error */
+#define FSL_DMA_DMAES_NCE	(1<<3)	/* Nbytes/citer config error */
+#define FSL_DMA_DMAES_SGE	(1<<2)	/* Scatter/gather config error */
+#define FSL_DMA_DMAES_SBE	(1<<1)	/* Source bus error */
+#define FSL_DMA_DMAES_DBE	(1<<0)	/* Destination bus error */
+
+/* MPC5121 DMA engine registers */
+typedef struct _fsl_dma_reg {
+	/* 0x00 */
+	u32 dmacr;		/* DMA control register */
+	u32 dmaes;		/* DMA error status */
+	/* 0x08 */
+	u32 dmaerqh;		/* DMA enable request high(channels 63~32) */
+	u32 dmaerql;		/* DMA enable request low(channels 31~0) */
+	u32 dmaeeih;		/* DMA enable error interrupt high(ch63~32) */
+	u32 dmaeeil;		/* DMA enable error interrupt low(ch31~0) */
+	/* 0x18 */
+	u8 dmaserq;		/* DMA set enable request */
+	u8 dmacerq;		/* DMA clear enable request */
+	u8 dmaseei;		/* DMA set enable error interrupt */
+	u8 dmaceei;		/* DMA clear enable error interrupt */
+	/* 0x1c */
+	u8 dmacint;		/* DMA clear interrupt request */
+	u8 dmacerr;		/* DMA clear error */
+	u8 dmassrt;		/* DMA set start bit */
+	u8 dmacdne;		/* DMA clear DONE status bit */
+	/* 0x20 */
+	u32 dmainth;		/* DMA interrupt request high(ch63~32) */
+	u32 dmaintl;		/* DMA interrupt request low(ch31~0) */
+	u32 dmaerrh;		/* DMA error high(ch63~32) */
+	u32 dmaerrl;		/* DMA error low(ch31~0) */
+	/* 0x30 */
+	u32 dmahrsh;		/* DMA hw request status high(ch63~32) */
+	u32 dmahrsl;		/* DMA hardware request status low(ch31~0) */
+	u32 dmaihsa;		/* DMA interrupt high select AXE(ch63~32) */
+	u32 dmailsa;		/* DMA interrupt low select AXE(ch31~0) */
+	/* 0x40 ~ 0xff */
+	u32 reserve0[48];	/* Reserved */
+	/* 0x100 */
+	u8 dchpri[FSL_DMA_CH_NUM];
+	/* DMA channels(0~63) priority */
+} __attribute__ ((packed)) fsl_dma_reg;
+
+typedef struct _tcd {
+	/* 0x00 */
+	u32 saddr;		/* Source address */
+
+	u32 smod:5;		/* Source address modulo */
+	u32 ssize:3;		/* Source data transfer size */
+	u32 dmod:5;		/* Destination address modulo */
+	u32 dsize:3;		/* Destination data transfer size */
+	u32 soff:16;		/* Signed source address offset */
+
+	/* 0x08 */
+	u32 nbytes;		/* Inner "minor" byte count */
+	u32 slast;		/* Last source address adjustment */
+	u32 daddr;		/* Destination address */
+
+	/* 0x14 */
+	u32 citer_elink:1;	/* Enable channel-to-channel linking on
+				 * minor loop complete
+				 */
+	u32 citer_linkch:6;	/* Link channel for minor loop complete */
+	u32 citer:9;		/* Current "major" iteration count */
+	u32 doff:16;		/* Signed destination address offset */
+
+	/* 0x18 */
+	u32 dlast_sga;		/* Last Destination address adjustment/scatter
+				 * gather address
+				 */
+
+	/* 0x1c */
+	u32 biter_elink:1;	/* Enable channel-to-channel linking on major
+				 * loop complete
+				 */
+	u32 biter_linkch:6;
+	u32 biter:9;		/* Beginning "major" iteration count */
+	u32 bwc:2;		/* Bandwidth control */
+	u32 major_linkch:6;	/* Link channel number */
+	u32 done:1;		/* Channel done */
+	u32 active:1;		/* Channel active */
+	u32 major_elink:1;	/* Enable channel-to-channel linking on major
+				 * loop complete
+				 */
+	u32 e_sg:1;		/* Enable scatter/gather processing */
+	u32 d_req:1;		/* Disable request */
+	u32 int_half:1;		/* Enable an interrupt when major counter is
+				 * half complete
+				 */
+	u32 int_maj:1;		/* Enable an interrupt when major iteration
+				 * count completes
+				 */
+	u32 start:1;		/* Channel start */
+} __attribute__ ((packed)) TCD;
+
+typedef struct _fsl_dma_tcd {
+	/* 0x1000 */
+	TCD tcd[FSL_DMA_CH_NUM];
+} fsl_dma_tcd;
+#endif				/* _FSL_REGISTERS_H_ */
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index cd30390..10139a7 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -64,6 +64,14 @@ config MV_XOR
 	---help---
 	  Enable support for the Marvell XOR engine.
 
+config FSL_MPC5121_DMA
+	tristate "Freescale MPC5121 DMA engine support"
+	depends on PPC_MPC512x
+	select DMA_ENGINE
+	default m
+	---help---
+	  Enable support for the Freescale(R) MPC5121 DMA engine.
+
 config DMA_ENGINE
 	bool
 
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index 14f5952..fc58d4d 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
 obj-$(CONFIG_FSL_DMA) += fsldma.o
 obj-$(CONFIG_MV_XOR) += mv_xor.o
 obj-$(CONFIG_DW_DMAC) += dw_dmac.o
+obj-$(CONFIG_FSL_MPC5121_DMA) += fsl_mpc5121_dma.o
diff --git a/drivers/dma/fsl_mpc5121_dma.c b/drivers/dma/fsl_mpc5121_dma.c
new file mode 100644
index 0000000..ea66bbb
--- /dev/null
+++ b/drivers/dma/fsl_mpc5121_dma.c
@@ -0,0 +1,760 @@
+/*
+ * Hongjun Chen <hong-jun.chen@freescale.com>
+ * Copyright (C) Freescale Semicondutor, Inc. 2007, 2008. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * The full GNU General Public License is included in this distribution in the
+ * file called COPYING.
+ */
+
+/*
+ * This driver supports an MPC5121 DMA engine, which does asynchronous
+ * copy operations.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <asm/fsldma.h>
+#include <asm/fsldma_reg.h>
+#include <linux/semaphore.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define DPRINTK(fmt, args...) \
+    printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+static struct fsl_device *g_device;
+static struct fsl_dma_chan *g_fchan;
+
+/* internal functions */
+static int __devinit fsl_init(void);
+static void __devexit fsl_remove(void);
+static void fsl_dma_memcpy_cleanup(struct fsl_dma_chan *fsl_chan);
+
+static int alloc_dma_channels(struct fsl_device *device)
+{
+	struct fsl_dma_chan *fsl_chan;
+
+	device->common.chancnt = FSL_DMA_CH_NUM;
+	fsl_chan = kzalloc(sizeof(*fsl_chan) * device->common.chancnt,
+			   GFP_KERNEL);
+	if (!fsl_chan) {
+		printk("Err: there is not enough memory"
+		       " for channel structures!");
+		return -ENOMEM;
+	}
+	g_fchan = fsl_chan;
+
+	return device->common.chancnt;
+}
+
+/* Called for DMA engine initialization */
+int fsl_dma_cfg_arbit_mode(int mode)
+{
+	fsl_dma_reg *reg;
+	int i;
+	u32 temp;
+
+	if (g_device) {
+		spin_lock_bh(&g_device->ch_lock);
+		for (i = 0; i < FSL_DMA_CH_NUM; i++) {
+			if (g_device->ch_stat[i]) {
+				spin_unlock_bh(&g_device->ch_lock);
+				return -EBUSY;
+			}
+		}
+		spin_unlock_bh(&g_device->ch_lock);
+
+		reg = g_device->reg;
+
+		g_device->arbit_mode = mode;
+
+		if (mode & FSL_DMA_GROUP_FIX) {	/* Group fixed arbitration */
+			out_be32(&reg->dmacr,
+				 FSL_DMA_GPR3PRI(3) | FSL_DMA_GPR2PRI(2)
+				 | FSL_DMA_GPR1PRI(1) | FSL_DMA_GPR0PRI(0));
+		} else {	/* Group round robin arbitration */
+			out_be32(&reg->dmacr, FSL_DMA_DMACR_ERGA_RR);
+		}
+
+		/* Channel round robin arbitration */
+		if (!(mode & FSL_DMA_CH_FIX)) {
+			temp = in_be32(&reg->dmacr);
+			out_be32(&reg->dmacr, temp | FSL_DMA_DMACR_ERCA_RR);
+		}
+
+		return 0;
+	} else
+		return -EFAULT;
+}
+
+static void free_chan(int channel_num)
+{
+	spin_lock_bh(&g_device->ch_lock);
+	g_device->ch_stat[channel_num] = 0;
+	spin_unlock_bh(&g_device->ch_lock);
+}
+
+int fsl_dma_status(int channel_num)
+{
+	fsl_dma_reg *reg;
+	u8 ch;
+	u32 status;
+
+	if (!g_device) {
+		printk("Err: DMA driver has not been initialized yet!\n");
+		return -1;
+	}
+
+	reg = g_device->reg;
+
+	status = in_be32(&reg->dmaes);
+	if (!(status & FSL_DMA_DMAES_VLD))
+		return 0;
+
+	ch = FSL_DMA_DMAES_ERRCHN(status);
+	printk(KERN_ERR "FSL channel config error: ch%d: ", ch);
+
+	if (status & FSL_DMA_DMAES_GPE)
+		printk(KERN_INFO "GPE\n");
+	if (status & FSL_DMA_DMAES_CPE)
+		printk(KERN_INFO "CPE\n");
+	if (status & FSL_DMA_DMAES_SAE)
+		printk(KERN_INFO "SAE\n");
+	if (status & FSL_DMA_DMAES_SOE)
+		printk(KERN_INFO "SOE\n");
+	if (status & FSL_DMA_DMAES_DAE)
+		printk(KERN_INFO "DAE\n");
+	if (status & FSL_DMA_DMAES_DOE)
+		printk(KERN_INFO "DOE\n");
+	if (status & FSL_DMA_DMAES_NCE)
+		printk(KERN_INFO "NCE\n");
+	if (status & FSL_DMA_DMAES_SGE)
+		printk(KERN_INFO "SGE\n");
+	if (status & FSL_DMA_DMAES_SBE)
+		printk(KERN_INFO "SBE\n");
+	if (status & FSL_DMA_DMAES_DBE)
+		printk(KERN_INFO "DBE\n");
+
+	if (ch == channel_num)
+		out_8(&reg->dmacerr, channel_num);
+
+	ch = ch + 1;
+	return ch;
+}
+
+/* This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @return returns a negative number on error if request for a DMA channel
+ *                     did not succeed, returns the channel number to be used
+ *                     on success.
+ */
+int fsl_dma_chan_request(int channel_id)
+{
+	struct fsl_device *device = g_device;
+	struct fsl_dma_chan *fsl_chan;
+
+	if (!device) {
+		fsl_init();
+		if (!g_device)
+			return -EINVAL;
+		device = g_device;
+	}
+
+	if (channel_id < 0 || channel_id >= FSL_DMA_CH_NUM)
+		return -EINVAL;
+
+	fsl_chan = g_fchan + channel_id;
+	spin_lock_bh(&device->ch_lock);
+	if (device->ch_stat[channel_id] == 0) {
+		device->ch_stat[channel_id] = 1;
+		spin_unlock_bh(&device->ch_lock);
+		sema_init(&fsl_chan->sem_lock, 1);
+		return channel_id;
+	}
+	spin_unlock_bh(&device->ch_lock);
+
+	return -EBUSY;
+}
+EXPORT_SYMBOL(fsl_dma_chan_request);
+
+void fsl_dma_free_chan(int channel_num)
+{
+	struct fsl_dma_chan *fsl_chan = g_fchan + channel_num;
+	fsl_dma_reg *reg = g_device->reg;
+
+	if (channel_num < 0 || channel_num >= FSL_DMA_CH_NUM)
+		return;
+
+	DPRINTK("free channel: %d\n", channel_num);
+
+	free_chan(channel_num);
+
+	fsl_dma_memcpy_cleanup(fsl_chan);
+
+	/* Clear enable request */
+	out_8(&reg->dmacerq, channel_num);
+
+	/* Clear interrupt, error interrupt and error etc. */
+	out_8(&reg->dmaceei, channel_num);
+	out_8(&reg->dmacerr, channel_num);
+	out_8(&reg->dmacint, channel_num);
+}
+EXPORT_SYMBOL(fsl_dma_free_chan);
+
+void fsl_dma_enable(int channel_num)
+{
+	fsl_dma_reg *reg = g_device->reg;
+	u32 *ltcd, *mtcd;
+	int j;
+
+	if (channel_num < 0 || channel_num >= FSL_DMA_CH_NUM)
+		return;
+
+	/* Get the address of TCD in local CPU memory space */
+	ltcd = (u32 *) (g_device->tcd + channel_num);
+	mtcd = (u32 *) (g_device->mtcd.addr_va
+			+ channel_num * MAX_TCD_NUM_PER_CH);
+
+	/* Clear the local TCD area */
+	memset(ltcd, 0, sizeof(TCD));
+
+	for (j = 0; j < (sizeof(TCD) / 4); j++) {
+		out_be32(ltcd, *mtcd);
+		ltcd++;
+		mtcd++;
+	}
+
+	/* Enable request */
+	out_8(&reg->dmaserq, channel_num);
+	return;
+}
+EXPORT_SYMBOL(fsl_dma_enable);
+
+void fsl_dma_disable(int channel_num)
+{
+	fsl_dma_reg *reg = g_device->reg;
+	if (channel_num < 0 || channel_num >= FSL_DMA_CH_NUM)
+		return;
+
+	/* Clear enable request */
+	out_8(&reg->dmacerq, channel_num);
+
+	return;
+}
+
+static int off_to_size(size_t off)
+{
+	int i, temp;
+
+	/* For PSC FIFO DMA operation
+	 * Destination/source address is fixed as the address
+	 * of FIFO data register, so no address offset is needed
+	 * for this operation, bus size is default 32bit.
+	 */
+	if (!off)
+		return 2;
+
+	temp = off;
+	for (i = 0; ; i++) {
+		temp = (int)(temp / 2);
+		if (!temp)
+			return i;
+	}
+}
+
+/**
+ * fsl_dma_config - function that initiates a FSL DMA transaction buffers
+ * @channel_num	FSL DMA channel number
+ * @dma_buf 	an array of physical addresses to the user defined
+ *              buffers. The caller must guarantee the dma_buf is
+ *              available until the transfer is completed.
+ * @num_buf     number of buffers in the array
+ * @mode        specifies whether this is READ or WRITE operation
+ * @return 	This function returns a negative number on error if buffer
+ *              could not be added with DMA for transfer. On Success, it
+ *              returns 0
+ */
+int fsl_dma_config(int channel_num, struct fsl_dma_requestbuf *dma_buf,
+		   int num_buf)
+{
+	struct fsl_dma_chan *fsl_chan = g_fchan + channel_num;
+	LIST_HEAD(new_chain);
+	fsl_dma_reg *reg = g_device->reg;
+	int ch = channel_num, i, nbytes, iter;
+	TCD *tcd;
+	dma_addr_t tcd_dma;
+
+	if (channel_num < 0 || channel_num >= FSL_DMA_CH_NUM
+	    || num_buf <= 0 || num_buf > MAX_TCD_NUM_PER_CH)
+		return -EINVAL;
+
+	if (fsl_dma_status(channel_num) != DMA_SUCCESS && fsl_chan->num_buf)
+		return -EBUSY;
+
+	if (down_trylock(&fsl_chan->sem_lock))
+		return -EBUSY;
+
+	tcd = (TCD *) (g_device->tcd + channel_num);
+
+	/* Use so much descriptor for this transmission */
+	fsl_chan->num_buf = num_buf;
+	fsl_chan->ch_index = channel_num;
+
+	/* Enable error interrupt */
+	out_8(&reg->dmaseei, ch);
+
+	tcd = g_device->mtcd.addr_va + ch * MAX_TCD_NUM_PER_CH;
+	tcd_dma = g_device->mtcd.addr_pa +
+	    ch * MAX_TCD_NUM_PER_CH * sizeof(TCD);
+
+	memset(tcd, 0, sizeof(TCD));
+
+	for (i = 0; i < num_buf; i++) {
+		tcd->saddr = dma_buf[i].src;
+		tcd->daddr = dma_buf[i].dest;
+		tcd->soff = dma_buf[i].soff;
+		tcd->doff = dma_buf[i].doff;
+		tcd->ssize = off_to_size(dma_buf[i].soff);
+		tcd->dsize = off_to_size(dma_buf[i].doff);
+		DPRINTK("doff: %d, soff: %d, dsize: %d, ssize: %d\n",
+			tcd->doff, tcd->soff, tcd->dsize, tcd->ssize);
+
+		if (dma_buf[i].soff >= dma_buf[i].doff)
+			nbytes = dma_buf[i].minor_loop * dma_buf[i].soff;
+		else
+			nbytes = dma_buf[i].minor_loop * dma_buf[i].doff;
+
+		tcd->nbytes = nbytes;
+		tcd->slast = 0;
+		tcd->dlast_sga = 0;
+
+		iter = dma_buf[i].len / nbytes;
+
+		if (tcd->soff && tcd->doff) {
+			tcd->citer_elink = 1;
+			tcd->biter_elink = 1;
+			tcd->citer_linkch = channel_num;
+			if (iter > 0x1ff)
+				panic("iterations won't fit in field");
+			tcd->citer = iter;
+			tcd->biter = iter;
+			tcd->start = 1;
+		} else {
+			/* citer_linkch contains the high bits of iter */
+			tcd->citer_linkch = iter >> 9;
+			tcd->biter_linkch = iter >> 9;
+			tcd->citer = iter & 0x1ff;
+			tcd->biter = iter & 0x1ff;
+			if (i == (num_buf - 1))
+				tcd->d_req = 1;
+		}
+
+		tcd->e_sg = 0;
+
+		/* For chain mode */
+		if (i != (num_buf - 1)) {
+			tcd->dlast_sga = tcd_dma + (i + 1) * sizeof(TCD);
+			tcd->e_sg = 1;
+		} else {
+			tcd->int_maj = 1;
+		}
+
+		DPRINTK("TCD dlast_sga: 0x%08x\n", tcd->dlast_sga);
+		tcd++;
+		memset(tcd, 0, sizeof(TCD));
+	}
+	return 0;
+}
+EXPORT_SYMBOL(fsl_dma_config);
+
+/* This function is called only when the channel occurs error
+ * or has completed transaction.
+ */
+static void fsl_dma_memcpy_cleanup(struct fsl_dma_chan *chan)
+{
+	int ch;
+
+	chan->status = g_device->reg->dmaes;
+
+	ch = fsl_dma_status(chan->ch_index);
+	if (ch)
+		ch = ch - 1;
+
+	if (ch == chan->ch_index)
+		DPRINTK("Channel %d halted, chanerr = %x\n", ch, chan->status);
+}
+
+static void fsl_dma_isr_bh(u32 intst, u32 err, u32 high)
+{
+	struct fsl_device *device = g_device;
+	struct fsl_dma_chan *fsl_chan;
+	fsl_dma_reg *reg;
+	u32 i, ch_base = 0, ch;
+	u32 error;
+
+	reg = device->reg;
+	if (high)
+		ch_base = 32;
+
+	for (i = 0; i < 32; i++) {
+		error = 0;
+		if (intst & (1 << i)) {
+			if (err & (1 << i))
+				error = in_be32(&reg->dmaes);
+			ch = i + ch_base;
+			fsl_chan = g_fchan + ch;
+			DPRINTK("channel %d occurs an interrupt\n", ch);
+
+			/* Clear interrupt request */
+			out_8(&reg->dmacint, ch);
+
+			/* Clear enable error interrupt */
+			out_8(&reg->dmaceei, ch);
+
+			up(&fsl_chan->sem_lock);
+			if (fsl_chan->cb_fn)
+				fsl_chan->cb_fn(fsl_chan->cb_args, error);
+		}
+	}
+	return;
+}
+
+static irqreturn_t fsl_do_interrupt(int irq, void *data)
+{
+	struct fsl_device *device = g_device;
+	fsl_dma_reg *reg;
+	u32 inth, intl, eeih, eeil;
+	u32 errh, errl;
+
+	DPRINTK("receive one interrupt!\n");
+	if (!device)
+		return NO_IRQ;
+	reg = device->reg;
+	inth = in_be32(&reg->dmainth);
+	intl = in_be32(&reg->dmaintl);
+	eeih = in_be32(&reg->dmaeeih);
+	eeil = in_be32(&reg->dmaeeil);
+
+	errh = in_be32(&reg->dmaerrh);
+	errl = in_be32(&reg->dmaerrl);
+
+	inth &= eeih;
+	intl &= eeil;
+
+	DPRINTK("es:0x%08x\n", in_be32(&reg->dmaes));
+
+	/* Clear all interrupt request */
+	out_8(&reg->dmacint, 0x7f);
+
+	if (!(inth & eeih) && !(intl & eeil))
+		return IRQ_NONE;
+
+	fsl_dma_isr_bh(inth, errh, 1);
+	fsl_dma_isr_bh(intl, errl, 0);
+
+	return IRQ_HANDLED;
+}
+
+int fsl_dma_callback_set(int channel_num, fsl_dma_callback_t callback,
+			 void *arg)
+{
+	struct fsl_dma_chan *fsl_chan = g_fchan + channel_num;
+
+	if (channel_num < 0 || channel_num >= FSL_DMA_CH_NUM)
+		return -EINVAL;
+
+	if (fsl_dma_status(channel_num) == DMA_IN_PROGRESS)
+		return -EBUSY;
+
+	fsl_chan->cb_fn = callback;
+	fsl_chan->cb_args = arg;
+
+	return 0;
+}
+EXPORT_SYMBOL(fsl_dma_callback_set);
+
+/*
+ * Perform a FSL transaction to verify the HW works.
+ */
+#define FSL_TEST_SIZE 0x200
+
+static int fsl_self_test(struct fsl_device *device)
+{
+	struct fsl_dma_requestbuf buf[3];
+	u8 *src0, *dest0;
+	u8 *src1, *dest1;
+	u8 *src2, *dest2;
+	dma_addr_t sphyaddr0, dphyaddr0;
+	dma_addr_t sphyaddr1, dphyaddr1;
+	dma_addr_t sphyaddr2, dphyaddr2;
+	int ch;
+	dma_cookie_t cookie;
+	int i, err = 0;
+
+	src0 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				  &sphyaddr0, GFP_KERNEL);
+	src1 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				  &sphyaddr1, GFP_KERNEL);
+	src2 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				  &sphyaddr2, GFP_KERNEL);
+	if (!src0 || !src1 || !src2)
+		return -ENOMEM;
+
+	dest0 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				   &dphyaddr0, GFP_KERNEL);
+	dest1 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				   &dphyaddr1, GFP_KERNEL);
+	dest2 = dma_alloc_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE,
+				   &dphyaddr2, GFP_KERNEL);
+	if (!dest0 || !dest1 || !dest2) {
+		dma_free_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE, src0,
+				  sphyaddr0);
+		dma_free_coherent(NULL, sizeof(u8) * FSL_TEST_SIZE, src1,
+				  sphyaddr1);
+		return -ENOMEM;
+	}
+
+	memset(dest0, 0, FSL_TEST_SIZE);
+	memset(dest1, 0, FSL_TEST_SIZE);
+	memset(dest2, 0, FSL_TEST_SIZE);
+
+	/* Fill in src buffer */
+	for (i = 0; i < FSL_TEST_SIZE; i++) {
+		src0[i] = (u8) i;
+		src1[i] = (u8) i;
+		src2[i] = (u8) i;
+	}
+
+	/* Set arbitration mode chj */
+	fsl_dma_cfg_arbit_mode(FSL_DMA_GROUP_FIX | FSL_DMA_CH_FIX);
+
+	/* Search for one available dma channel */
+	ch = fsl_dma_chan_request(32);
+	if (ch < 0) {
+		err = -ENODEV;
+		goto out;
+	}
+
+	/* Both source and destination port size: 32 bits */
+	buf[0].src = sphyaddr0;
+	buf[0].dest = dphyaddr0;
+	buf[0].soff = 4;
+	buf[0].doff = 1;
+	buf[0].len = FSL_TEST_SIZE;
+	buf[0].minor_loop = 8;	/* Minor bytes: 32 */
+
+	buf[1].src = sphyaddr1;
+	buf[1].dest = dphyaddr1;
+	buf[1].soff = 4;
+	buf[1].doff = 1;
+	buf[1].len = FSL_TEST_SIZE;
+	buf[1].minor_loop = 8;	/* Minor bytes: 32 */
+
+	buf[2].src = sphyaddr2;
+	buf[2].dest = dphyaddr2;
+	buf[2].soff = 4;
+	buf[2].doff = 1;
+	buf[2].len = FSL_TEST_SIZE;
+	buf[2].minor_loop = 8;	/* Minor bytes: 32 */
+
+	cookie = fsl_dma_config(ch, &buf[0], 3);
+	fsl_dma_enable(ch);
+	msleep(100);
+
+	if (fsl_dma_status(ch) != DMA_SUCCESS) {
+		printk(KERN_ERR
+		       "fsldma: Self-test copy timed out, disabling\n");
+		err = -ENODEV;
+		goto free_resources;
+	}
+	if (memcmp(src0, dest0, FSL_TEST_SIZE) ||
+	    memcmp(src1, dest1, FSL_TEST_SIZE) ||
+	    memcmp(src2, dest2, FSL_TEST_SIZE)) {
+		printk(KERN_ERR
+		       "fsldma: Self-test copy failed compare, disabling\n");
+		err = -ENODEV;
+		fsl_dma_status(ch);
+		goto free_resources;
+	} else {
+		printk("fsldma: Self-test copy successfully\n");
+	}
+
+free_resources:
+	fsl_dma_free_chan(ch);
+out:
+	dma_free_coherent(NULL, FSL_TEST_SIZE, src0, sphyaddr0);
+	dma_free_coherent(NULL, FSL_TEST_SIZE, dest0, dphyaddr0);
+	dma_free_coherent(NULL, FSL_TEST_SIZE, src1, sphyaddr1);
+	dma_free_coherent(NULL, FSL_TEST_SIZE, dest1, dphyaddr1);
+	return err;
+}
+
+static int __devinit fsl_init(void)
+{
+	int err;
+	unsigned long base_addr;
+	fsl_dma_reg *reg;
+	TCD *tcd;
+	struct fsl_device *device;
+	struct device_node *np;
+	struct resource r;
+	u32 mask, offset;
+
+	if (g_device)
+		return 0;
+
+	/* Map the virtual IRQ number from device tree */
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-dma2");
+	if (!np) {
+		printk(KERN_ERR "Err: no 'fsl,mpc5121-dma2' in device tree!\n");
+		return -EINVAL;
+	}
+
+	/* DMA register space */
+	of_address_to_resource(np, 0, &r);
+	of_node_put(np);
+	DPRINTK("DMA engine register address: 0x%08x\n", r.start);
+	reg = (fsl_dma_reg *) ioremap(r.start, sizeof(fsl_dma_reg));
+	if (!reg) {
+		err = -ENOMEM;
+		goto err_regioremap;
+	}
+
+	/* DMA transfer control desciptor area */
+	base_addr = r.start + FSL_DMA_TCD_OFFSET;
+	DPRINTK("Local TCD start address: 0x%08x\n", (u32) base_addr);
+	tcd = (TCD *) ioremap(base_addr, sizeof(TCD) * FSL_DMA_CH_NUM);
+	if (!tcd) {
+		err = -ENOMEM;
+		goto err_tcdioremap;
+	}
+
+	device = kzalloc(sizeof(*device), GFP_KERNEL);
+	if (!device) {
+		err = -ENOMEM;
+		goto err_kzalloc;
+	}
+
+	device->irq = irq_of_parse_and_map(np, 0);
+	of_node_put(np);
+
+	err = request_irq(device->irq, &fsl_do_interrupt,
+			  IRQF_SHARED, "mpc5121dma", device);
+	if (err)
+		goto err_irq;
+
+	spin_lock_init(&device->ch_lock);
+	device->reg = reg;
+	device->tcd = tcd;
+	g_device = device;
+
+	/* Allocate buffer for TCDs in memory */
+	device->mtcd.size = (MAX_TCD_NUM_PER_CH * FSL_DMA_CH_NUM + 1)
+	    * sizeof(TCD);
+	device->mtcd.addr_v =
+	    (TCD *) dma_alloc_coherent(NULL, device->mtcd.size,
+				       &device->mtcd.addr_p, GFP_KERNEL);
+	mask = sizeof(TCD) - 1;
+	offset = device->mtcd.addr_p & mask;
+	device->mtcd.addr_va = device->mtcd.addr_v;
+	device->mtcd.addr_pa = device->mtcd.addr_p;
+	if (offset) {
+		offset = sizeof(TCD) - offset;
+		device->mtcd.addr_pa = device->mtcd.addr_p + offset;
+		device->mtcd.addr_va = (TCD *) ((u32) device->mtcd.addr_v
+						+ offset);
+		DPRINTK("Note: TCD buffer address is re-aligned:"
+			" offset: 0x%x\n", offset);
+	}
+	DPRINTK("tcd buf phy addr: 0x%08x\n", device->mtcd.addr_pa);
+
+	alloc_dma_channels(device);
+	printk(KERN_INFO "Freescale(R) MPC5121 DMA Engine found, %d channels\n",
+	       FSL_DMA_CH_NUM);
+
+	err = fsl_self_test(device);
+	if (err)
+		goto err_self_test;
+
+	return 0;
+
+err_irq:
+err_kzalloc:
+err_self_test:
+	kfree(device);
+	dma_free_coherent(NULL, device->mtcd.size,
+			  device->mtcd.addr_v, device->mtcd.addr_p);
+err_tcdioremap:
+	iounmap(tcd);
+err_regioremap:
+	iounmap(reg);
+	return err;
+}
+
+static void __devexit fsl_remove(void)
+{
+	struct fsl_device *device;
+
+	if (!g_device)
+		return;
+	device = g_device;
+
+	free_irq(device->irq, device);
+	iounmap(device->reg);
+	iounmap(device->tcd);
+	dma_free_coherent(NULL, device->mtcd.size,
+			  device->mtcd.addr_v, device->mtcd.addr_p);
+	kfree(device);
+}
+
+static int __init fsl_init_module(void)
+{
+	return fsl_init();
+}
+
+module_init(fsl_init_module);
+
+static void __exit fsl_exit_module(void)
+{
+	fsl_remove();
+}
+
+module_exit(fsl_exit_module);
+
+/* MODULE API */
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
-- 
1.6.0.90.g436ed

