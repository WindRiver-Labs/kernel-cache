From 92ad5c21d2bc29977aa7550e7b51c68f9f026669 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:45:58 +0800
Subject: [PATCH] PSC iopad config and PSC fifo size init

Foreach fsl,mpc5121-psc node in tree, configure
its iopads in board setup.

Foreach fsl,mpc5121-mscan node in tree, configure
its iopads in board setup.

Foreach fsl,mpc5121-psc compatible node in device
tree, set up its tx and rx fifo's based on
tx-fifo-size and rx-fifo-size properties.
Default to 16 for nodes without these properties.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/mpc5121_ads.c    |   17 ++++
 arch/powerpc/platforms/512x/mpc512x.h        |    3 +
 arch/powerpc/platforms/512x/mpc512x_shared.c |  103 ++++++++++++++++++++++++++
 3 files changed, 123 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/512x/mpc5121_ads.c b/arch/powerpc/platforms/512x/mpc5121_ads.c
index 6588773..a6395b3 100644
--- a/arch/powerpc/platforms/512x/mpc5121_ads.c
+++ b/arch/powerpc/platforms/512x/mpc5121_ads.c
@@ -37,6 +37,23 @@ static void __init mpc5121_ads_setup_arch(void)
 	mpc5121_ads_cpld_map();
 
 	/*
+	 * io pad config
+	 */
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-ioctl");
+	if (np) {
+		void __iomem *ioctl = of_iomap(np, 0);
+
+		mpc5121_psc_iopad_init(ioctl);
+		mpc5121_can_iopad_init(ioctl);
+
+		of_node_put(np);
+		iounmap(ioctl);
+	}
+
+	/* Initialize PSC fifo size */
+	g_mpc5121_psc_fifo_init();
+
+	/*
 	 * turn on i2c interrupts
 	 */
 	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-i2c-ctrl");
diff --git a/arch/powerpc/platforms/512x/mpc512x.h b/arch/powerpc/platforms/512x/mpc512x.h
index 5409642..af003ff 100644
--- a/arch/powerpc/platforms/512x/mpc512x.h
+++ b/arch/powerpc/platforms/512x/mpc512x.h
@@ -15,4 +15,7 @@ extern unsigned long mpc512x_find_ips_freq(struct device_node *node);
 extern void __init mpc512x_init_IRQ(void);
 void __init mpc512x_declare_of_platform_devices(void);
 extern void mpc512x_restart(char *cmd);
+extern void __init g_mpc5121_psc_fifo_init(void);
+extern void __init mpc5121_psc_iopad_init(void __iomem *ioctl);
+extern void __init mpc5121_can_iopad_init(void __iomem *ioctl);
 #endif				/* __MPC512X_H__ */
diff --git a/arch/powerpc/platforms/512x/mpc512x_shared.c b/arch/powerpc/platforms/512x/mpc512x_shared.c
index f3d269d..fabeacd 100644
--- a/arch/powerpc/platforms/512x/mpc512x_shared.c
+++ b/arch/powerpc/platforms/512x/mpc512x_shared.c
@@ -120,3 +120,106 @@ void mpc512x_restart(char *cmd)
 	for ( ; ; )
 		;
 }
+
+#define DEFAULT_FIFO_SIZE 16
+
+static unsigned int get_fifo_size(struct device_node *np, int psc_num,
+				char *fifo_name)
+{
+	const unsigned int *fp;
+
+	fp = of_get_property(np, fifo_name, NULL);
+	if (fp)
+		return *fp;
+	printk(KERN_WARNING "no %s property for psc%d defaulting to %d\n",
+		fifo_name, psc_num, DEFAULT_FIFO_SIZE);
+	return DEFAULT_FIFO_SIZE;
+}
+
+void __init g_mpc5121_psc_fifo_init(void)
+{
+	struct device_node *np;
+	const u32 *cell_index;
+	int fifobase = 0; /* current fifo address in 32 bit words */
+
+	for_each_compatible_node(np, NULL, "fsl,mpc5121-psc") {
+		cell_index = of_get_property(np, "cell-index", NULL);
+		if (cell_index) {
+			int psc_num = *cell_index;
+			unsigned int tx_fifo_size;
+			unsigned int rx_fifo_size;
+			void __iomem *psc;
+
+			tx_fifo_size = get_fifo_size(np, psc_num,
+						"tx-fifo-size");
+			rx_fifo_size = get_fifo_size(np, psc_num,
+						"rx-fifo-size");
+
+			/* size in register is in 4 byte words */
+			tx_fifo_size /= 4;
+			rx_fifo_size /= 4;
+
+			psc = of_iomap(np, 0);
+
+			/* tx fifo size register is at 0x9c and rx at 0xdc */
+			out_be32(psc + 0x9c, (fifobase << 16) | tx_fifo_size);
+			fifobase += tx_fifo_size;
+			out_be32(psc + 0xdc, (fifobase << 16) | rx_fifo_size);
+			fifobase += rx_fifo_size;
+
+			/* reset and enable the slices */
+			out_be32(psc + 0x80, 0x80);
+			out_be32(psc + 0x80, 0x01);
+			out_be32(psc + 0xc0, 0x80);
+			out_be32(psc + 0xc0, 0x01);
+
+			iounmap(psc);
+		}
+	}
+}
+
+#define IO_PSC_0_0_ADDR_OFFSET	0x20c
+#define IO_PSC_PIN_SIZE		0x14
+#define IO_PSC_PIN_OFFSET(x)	(IO_PSC_0_0_ADDR_OFFSET + IO_PSC_PIN_SIZE * (x))
+
+void __init mpc5121_psc_iopad_init(void __iomem *ioctl)
+{
+	struct device_node *np;
+	const u32 *cell_index;
+
+	for_each_compatible_node(np, NULL, "fsl,mpc5121-psc") {
+		cell_index = of_get_property(np, "cell-index", NULL);
+		if (cell_index) {
+			u32 __iomem *pscioctl;
+			int psc_num = *cell_index;
+
+			pscioctl = ioctl + IO_PSC_PIN_OFFSET(psc_num);
+			out_be32(pscioctl++, 0x07);	/* PSCn_0, STD_ST */
+			out_be32(pscioctl++, 0x03);	/* PSCn_1, STD */
+			out_be32(pscioctl++, 0x03);	/* PSCn_2, STD */
+			out_be32(pscioctl++, 0x03);	/* PSCn_3, STD */
+			out_be32(pscioctl++, 0x03);	/* PSCn_4, STD */
+		}
+	}
+}
+
+void __init mpc5121_can_iopad_init(void __iomem *ioctl)
+{
+	struct device_node *np;
+	const u32 *cell_index;
+
+	for_each_compatible_node(np, NULL, "fsl,mpc5121-mscan") {
+		cell_index = of_get_property(np, "cell-index", NULL);
+		if (cell_index) {
+			u32 __iomem *canioctl;
+			int can_num = *cell_index;
+
+			/*
+			 * Config can Tx pin
+			 * 0x1f8 is offset to CAN0_Tx
+			 */
+			canioctl = ioctl + 0x1f8 + 4 * can_num;
+			out_be32(canioctl, 0x03);
+		}
+	}
+}
-- 
1.6.0.90.g436ed

