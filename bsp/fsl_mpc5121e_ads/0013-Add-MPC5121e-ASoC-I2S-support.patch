From 87e8f8e13b25878931c5d811516d195bfe4ddd4c Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:00 +0800
Subject: [PATCH] Add MPC5121e ASoC I2S support

This is for a modified ADS5121 board
with AD1938 I2S codec.

Running the I2S driver on the modified ADS512101 requires
a modified device tree. The PSC5 device that is normally
connected to the AC97 codec needs to be configured for I2S.

In addition, the PSC4 device that is normally configured
as a second serial port needs to be configured for SPI.

To use I2S, uncomment the corresponding node in the device
tree.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 sound/soc/codecs/Kconfig    |    4 +
 sound/soc/codecs/Makefile   |    2 +
 sound/soc/codecs/ad1939.c   |  882 +++++++++++++++++++++++++++++++++++++++++++
 sound/soc/codecs/ad1939.h   |  110 ++++++
 sound/soc/fsl/Makefile      |    4 +
 sound/soc/fsl/mpc5121_i2s.c |  452 ++++++++++++++++++++++
 6 files changed, 1454 insertions(+), 0 deletions(-)
 create mode 100644 sound/soc/codecs/ad1939.c
 create mode 100644 sound/soc/codecs/ad1939.h
 create mode 100644 sound/soc/fsl/mpc5121_i2s.c

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index b1a5eed..8f1f71c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -2,6 +2,10 @@ config SND_SOC_AC97_CODEC
 	tristate
 	select SND_AC97_CODEC
 
+config SND_SOC_AD1939
+	tristate
+	depends on SND_SOC
+
 config SND_SOC_AK4535
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a519ced..d37f19a 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -1,4 +1,5 @@
 snd-soc-ac97-objs := ac97.o
+snd-soc-ad1939-objs := ad1939.o
 snd-soc-ak4535-objs := ak4535.o
 snd-soc-uda1380-objs := uda1380.o
 snd-soc-wm8510-objs := wm8510.o
@@ -13,6 +14,7 @@ snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 snd-soc-twl4030-objs := twl4030.o
 
 obj-$(CONFIG_SND_SOC_AC97_CODEC)	+= snd-soc-ac97.o
+obj-$(CONFIG_SND_SOC_AD1939)	+= snd-soc-ad1939.o
 obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
 obj-$(CONFIG_SND_SOC_UDA1380)	+= snd-soc-uda1380.o
 obj-$(CONFIG_SND_SOC_WM8510)	+= snd-soc-wm8510.o
diff --git a/sound/soc/codecs/ad1939.c b/sound/soc/codecs/ad1939.c
new file mode 100644
index 0000000..a531a8b
--- /dev/null
+++ b/sound/soc/codecs/ad1939.c
@@ -0,0 +1,882 @@
+/*
+ * AD1935/AD1936/AD1937/AD1938/AD1939 I2S ASoC Codec driver
+ *
+ * Copyright (c) 2007-2008 MSC Vertriebsges.m.b.H,
+ *	Manuel Lauss <mlau@msc-ge.com> <mano@roarinelk.homelinux.net>
+ *
+ * licensed under the GPLv2
+ *
+ * Code for the AD193X family of I2S codecs with I2C and SPI control
+ * interface.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/workqueue.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "ad1939.h"
+
+#define AUDIO_NAME "AD1939"
+
+#define msg(x...) printk(KERN_INFO AUDIO_NAME ": " x)
+
+/* #define CODEC_DEBUG */
+
+#ifdef CODEC_DEBUG
+#define dbg(x...)	printk(KERN_INFO AUDIO_NAME ": " x)
+#else
+#define dbg(x...)	do {} while (0)
+#endif
+
+struct ad1939_private {
+	struct snd_soc_codec *codec;
+	unsigned char tdm_mode;
+	unsigned char dev_addr;
+	unsigned char drvflags;
+	unsigned char mixpairs;
+	void(*powerfunc)(int);
+	unsigned int powerdown;
+};
+
+/* default register contents after reset */
+static const u16 ad1939_regcache[AD1939_REGCOUNT] __devinitdata = {
+	0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0
+};
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static int ad1939_i2c_write(struct snd_soc_codec *codec, unsigned int r,
+			    unsigned int v)
+{
+	struct ad1939_private *ad = codec->private_data;
+	struct i2c_msg msg;
+	struct i2c_client *c;
+	u16 *cache = codec->reg_cache;
+	u8 data[2];
+	int ret;
+
+	c = (struct i2c_client *)codec->control_data;
+	data[0] = r & 0xff;
+	data[1] = v & 0xff;
+	msg.addr = c->addr;
+	msg.flags = 0;	/* write */
+	msg.buf = &data[0];
+	msg.len = 2;
+
+	/* if powered-down the chip can't be reached so just cache
+	 * the write value.
+	 */
+	if (ad->powerdown)
+		ret = 1;
+	else
+		ret = i2c_transfer(c->adapter, &msg, 1);
+	if (ret == 1)
+		cache[r] = v;
+	return (ret == 1) ? 0 : -EIO;
+}
+
+static unsigned int ad1939_i2c_read(struct snd_soc_codec *codec,
+				    unsigned int r)
+{
+	struct ad1939_private *ad = codec->private_data;
+	struct i2c_msg msg[2];
+	struct i2c_client *c;
+	u16 *cache = codec->reg_cache;
+	u8 data[2];
+	int ret;
+
+	/* the PLLCTL1 has one read-only bit: PLL lock indicator.
+	 * all other regs keep what was set.
+	 * If powered-down the chip can't be reached so just return
+	 * the cached value.
+	 */
+	if ((likely(r != AD1939_PLLCTL1)) || ad->powerdown)
+		return cache[r];
+
+	c = (struct i2c_client *)codec->control_data;
+	data[0] = r & 0xff;
+	msg[0].addr = c->addr;
+	msg[0].flags = 0;
+	msg[0].buf = &data[0];
+	msg[0].len = 1;
+
+	msg[1].addr = c->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = &data[1];
+	msg[1].len = 1;
+
+	ret = i2c_transfer(c->adapter, &msg[0], 2);
+	if (ret == 2)
+		cache[r] = data[1];
+
+	return (ret == 2) ? data[1] : -EIO;
+}
+#endif
+
+#if defined(CONFIG_SPI) || defined(CONFIG_SPI_MODULE)
+/* SPI communications for AD1938/AD1939;
+ * 24 bit data, LSB first; (I2C style, INCLUDING R/W bit!)
+ * <8bit global address><8bit register address><8bit reg data>
+ */
+static int ad1939_spi_write(struct snd_soc_codec *codec, unsigned int r,
+			    unsigned int v)
+{
+	struct spi_device *spi = codec->control_data;
+	struct ad1939_private *ad = codec->private_data;
+	u16 *cache = codec->reg_cache;
+	int ret;
+	u8 data[3];
+
+	data[0] = ad->dev_addr << 1;
+	data[1] = r;
+	data[2] = v;
+
+	/* if powered-down the chip can't be reached so just cache
+	 * the write value.
+	 */
+	if (ad->powerdown)
+		ret = 0;
+	else
+		ret = spi_write(spi, &data[0], 3);
+
+	if (ret == 0)
+		cache[r] = v;
+
+	return ret;
+}
+
+static unsigned int ad1939_spi_read(struct snd_soc_codec *codec,
+				    unsigned int r)
+{
+	struct spi_device *spi = codec->control_data;
+	struct ad1939_private *ad = codec->private_data;
+	u16 *cache = codec->reg_cache;
+	u8 data_w[3], data_r[3];
+	int ret;
+	struct spi_transfer t = {
+		.tx_buf = data_w,
+		.rx_buf	= data_r,
+		.len = 3,
+	};
+	struct spi_message m;
+
+	/* the PLLCTL1 has one read-only bit: PLL lock indicator.
+	 * all other regs keep what was set.
+	 * If powered-down the chip can't be reached so just return
+	 * the cached value.
+	 */
+	if ((likely(r != AD1939_PLLCTL1)) || ad->powerdown)
+		return cache[r];
+
+	data_r[0] = data_w[0] = (ad->dev_addr << 1) | 1;
+	data_r[1] = data_w[1] = r;
+	data_r[2] = data_w[2] = cache[r];
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	ret = spi_sync(spi, &m);
+	if (ret == 0)
+		cache[r] = data_r[2];
+	return (ret) ? ret : data_r[2];
+}
+#endif
+
+static inline unsigned int ad1939_read(struct snd_soc_codec *codec,
+				       unsigned int r)
+{
+	return codec->read(codec, r);
+}
+
+static inline int ad1939_write(struct snd_soc_codec *codec,
+			       unsigned int r, unsigned int v)
+{
+	u16 *cache = codec->reg_cache;
+	if (cache[r] == v)
+		return 0;
+	return codec->write(codec, r, v);
+}
+
+/***** controls ******/
+
+static const char *dac_deemph[] = {"Flat", "48kHz", "44.1kHz", "32kHz"};
+static const char *dac_outpol[] = {"Normal", "Inverted"};
+
+static const struct soc_enum ad1939_enum[] = {
+      /*SOC_ENUM_SINGLE(register, startbit, choices, choices-texts) */
+	SOC_ENUM_SINGLE(AD1939_DACCTL2, 1, 4, dac_deemph),
+	SOC_ENUM_SINGLE(AD1939_DACCTL2, 5, 2, dac_outpol),
+};
+
+/* Mixer controls. Keep the Playback Attenuation controls at the top,
+ * or the limiter breaks (see ad1939_add_controls())
+ */
+static const struct snd_kcontrol_new ad1939_snd_ctls[] = {
+SOC_DOUBLE_R("Master Playback", AD1939_VOL1L, AD1939_VOL1R, 0, 255, 1),
+SOC_DOUBLE_R("Channel 2 Playback", AD1939_VOL2L, AD1939_VOL2R, 0, 255, 1),
+SOC_DOUBLE_R("Channel 3 Playback", AD1939_VOL3L, AD1939_VOL3R, 0, 255, 1),
+SOC_DOUBLE_R("Channel 4 Playback", AD1939_VOL4L, AD1939_VOL4R, 0, 255, 1),
+SOC_ENUM("DAC Deemphasis", ad1939_enum[0]),
+SOC_ENUM("DAC output polarity", ad1939_enum[1]),
+};
+
+/* add non dapm controls */
+static int ad1939_add_controls(struct snd_soc_codec *codec)
+{
+	struct ad1939_private *ad = codec->private_data;
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(ad1939_snd_ctls); i++) {
+		if ((i <= 3) && (i >= ad->mixpairs))
+			continue;
+		err = snd_ctl_add(codec->card,
+			snd_soc_cnew(&ad1939_snd_ctls[i], codec, NULL));
+		if (err < 0)
+			return err;
+	}
+	return 0;
+}
+
+/***** chip interface config ******/
+
+static int ad1939_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct ad1939_private *ad = codec->private_data;
+	unsigned char dac0, dac1, dac2, adc0, adc1, adc2;
+	unsigned long rate;
+	unsigned int bits;
+
+	dbg("ad1939_hw_params\n");
+
+	dac0 = ad1939_read(codec, AD1939_DACCTL0);
+	dac1 = ad1939_read(codec, AD1939_DACCTL1);
+	dac2 = ad1939_read(codec, AD1939_DACCTL2);
+	adc0 = ad1939_read(codec, AD1939_ADCCTL0);
+	adc1 = ad1939_read(codec, AD1939_ADCCTL1);
+	adc2 = ad1939_read(codec, AD1939_ADCCTL2);
+
+	rate = params_rate(params);
+	bits = params->msbits;
+
+	dbg("bits %d srate %lu/%d chans %d\n", bits, rate,
+	     params->rate_den, params_channels(params));
+
+	/* sample rate */
+	dac0 &= ~(3<<1);	/* 48kHz */
+	adc0 &= ~(3<<6);	/* 48kHz */
+	switch (rate) {
+	case 32000 ... 48000:
+		break;
+	case 64000 ... 96000:
+		dac0 |= (1<<1);
+		adc0 |= (1<<6);
+		break;
+	case 128000 ... 192000:
+		dac0 |= (2<<1);
+		adc0 |= (2<<6);
+		break;
+	default:
+		dbg("rejecting srate %lu\n", rate);
+		return -EINVAL;
+	}
+
+	/* sample width (bits) */
+	dac2 &= ~(3<<3);	/* 24 bits */
+	adc1 &= ~(3<<0);	/* 24 bits */
+	switch (bits) {
+	case 16:
+		dac2 |= (3<<3);
+		adc1 |= (3<<0);
+		break;
+	case 20:
+		dac2 |= (1<<3);
+		adc1 |= (1<<0);
+		break;
+	case 24:
+		break;
+	default:
+		dbg("rejecting bits %d\n", bits);
+		return -EINVAL;
+	}
+
+	/* channels */
+	dac0 &= ~(3<<6);	/* DAC I2S stereo */
+	dac1 &= ~(3<<1);	/* 2 channels */
+	adc1 &= ~(3<<5);	/* ADC I2S stereo */
+	adc2 &= ~(3<<4);	/* 2 channels */
+	switch (params_channels(params)) {
+	case 2:	/* I2S stereo mode */
+		if (ad->drvflags & AD1939_DRV_TDM_STEREO) {
+			dac0 |= (ad->tdm_mode & 3) << 6;
+			adc1 |= (ad->tdm_mode & 3) << 5;
+		}
+		break;
+	case 4:	/* TDM mode */
+		dac0 |= (ad->tdm_mode & 3) << 6;
+		dac1 |= (1<<1);
+		adc1 |= (ad->tdm_mode & 3) << 5;
+		adc2 |= (1<<4);
+		break;
+	case 8:	/* TDM mode */
+		dac0 |= (ad->tdm_mode & 3) << 6;
+		dac1 |= (2<<1);
+		adc1 |= (ad->tdm_mode & 3) << 5;
+		adc2 |= (2<<4);
+		break;
+	case 16: /* TDM mode */
+		dac0 |= (ad->tdm_mode & 3) << 6;
+		dac1 |= (3<<1);
+		adc1 |= (ad->tdm_mode & 3) << 5;
+		adc2 |= (3<<4);
+		break;
+	default:
+		dbg("%d channels not supported\n",
+			params_channels(params));
+		return -EINVAL;
+	}
+
+	ad1939_write(codec, AD1939_DACCTL0, dac0);
+	ad1939_write(codec, AD1939_DACCTL1, dac1);
+	ad1939_write(codec, AD1939_DACCTL2, dac2);
+	ad1939_write(codec, AD1939_ADCCTL0, adc0);
+	ad1939_write(codec, AD1939_ADCCTL1, adc1);
+	ad1939_write(codec, AD1939_ADCCTL2, adc2);
+
+	return 0;
+}
+
+static int ad1939_set_dai_fmt(struct snd_soc_dai *codec_dai,
+			      unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct ad1939_private *ad = codec->private_data;
+	unsigned char dac0, dac1, adc1, adc2;
+
+	dbg("ad1939_set_dai_fmt(0x%08ulx)\n", fmt);
+
+	dac0 = ad1939_read(codec, AD1939_DACCTL0);
+	dac1 = ad1939_read(codec, AD1939_DACCTL1);
+	adc1 = ad1939_read(codec, AD1939_ADCCTL1);
+	adc2 = ad1939_read(codec, AD1939_ADCCTL2);
+
+	/* codec clocks master/slave setup */
+	dac1 &= ~((1<<4) | (1<<5)); /* LRCK BCK slave */
+	adc2 &= ~((1<<3) | (1<<6)); /* LRCK BCK slave */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:	/* BCK/LCK master */
+		dac1 |= (1<<4) | (1<<5); /* LRCK BCK master */
+		adc2 |= (1<<3) | (1<<6); /* LRCK BCK master */
+		if (ad->drvflags & AD1939_DRV_ADCDAC_COMMON_BCK) {
+			if (ad->drvflags & AD1939_DRV_ADC_BCK_MASTER)
+				dac1 &= ~(1<<5); /* DAC BCLK slave */
+			else
+				adc2 &= ~(1<<6); /* ADC BCLK slave */
+		}
+		if (ad->drvflags & AD1939_DRV_ADCDAC_COMMON_LRCK) {
+			if (ad->drvflags & AD1939_DRV_ADC_LRCK_MASTER)
+				dac1 &= ~(1<<4); /* DAC LRCK slave */
+			else
+				adc2 &= ~(1<<3); /* ADC LRCK slave */
+		}
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:	/* BCK/LCK slave */
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:	/* BCK master, LRCK slave */
+		dac1 &= ~(1<<4);	/* DAC LRCK slave */
+		adc2 &= ~(1<<3);	/* ADC LRCK slave */
+		dac1 |= (1<<5);		/* DAC BCK master */
+		adc2 |= (1<<6);		/* ADC BCK master */
+		if (ad->drvflags & AD1939_DRV_ADCDAC_COMMON_BCK) {
+			if (ad->drvflags & AD1939_DRV_ADC_BCK_MASTER)
+				dac1 &= ~(1<<5); /* DAC BCLK slave */
+			else
+				adc2 &= ~(1<<6); /* ADC BCLK slave */
+		}
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		dac1 &= ~(1<<5);	/* DAC BCK slave */
+		adc2 &= ~(1<<6);	/* ADC BCK slave */
+		dac1 |= (1<<4);		/* DAC LRCK master */
+		adc2 |= (1<<3);		/* ADC LRCK master */
+		if (ad->drvflags & AD1939_DRV_ADCDAC_COMMON_LRCK) {
+			if (ad->drvflags & AD1939_DRV_ADC_LRCK_MASTER)
+				dac1 &= ~(1<<4); /* DAC LRCK slave */
+			else
+				adc2 &= ~(1<<3); /* ADC LRCK slave */
+		}
+		break;
+	default:
+		dbg("invalid master/slave configuration\n");
+		return -EINVAL;
+	}
+
+	/* interface format */
+	dac0 &= ~(7<<3); /* DAC: SDATA delay 1 */
+	adc1 &= ~(7<<2); /* ADC: SDATA delay 1 */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		break;
+	case SND_SOC_DAIFMT_MSB: /* LEFT_J */
+		dac0 |= (1<<3);	/* no SDATA delay */
+		adc1 |= (1<<2); /* no SDATA delay */
+		break;
+#if 0
+	case SND_SOC_DAIFMT_LSB:
+		/* FIXME: need to know if in TDM/Master mode and sample
+		 * size, then program bitdelay accordingly
+		 */
+		break;
+#endif
+	default:
+		dbg("invalid I2S interface format\n");
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	dac1 &= ~((1<<7) | (1<<3)); /* norm BCK LRCK */
+	adc2 &= ~((1<<1) | (1<<2)); /* norm BCK LRCK */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		dac1 |= (1<<3);		/* inv LRCK */
+		adc2 |= (1<<2);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		dac1 |= (1<<7);		/* inv BCK */
+		adc2 |= (1<<1);
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		dac1 |= (1<<3) | (1<<7); /* inv LRCK BCK */
+		adc2 |= (1<<1) | (1<<2);
+		break;
+	default:
+		dbg("invalid clock inversion configuration\n");
+		return -EINVAL;
+	}
+
+	ad1939_write(codec, AD1939_DACCTL0, dac0);
+	ad1939_write(codec, AD1939_DACCTL1, dac1);
+	ad1939_write(codec, AD1939_ADCCTL1, adc1);
+	ad1939_write(codec, AD1939_ADCCTL2, adc2);
+
+	return 0;
+}
+
+static int ad1939_set_bias_level(struct snd_soc_codec *codec,
+				enum snd_soc_bias_level level)
+{
+	struct ad1939_private *ad = codec->private_data;
+	unsigned char pll0, adc0, dac0;
+	u16 *cache = codec->reg_cache;
+	int i;
+
+	pll0 = ad1939_read(codec, AD1939_PLLCTL0) & 0xfe;
+	dac0 = ad1939_read(codec, AD1939_DACCTL0) & 0xfe;
+	adc0 = ad1939_read(codec, AD1939_ADCCTL0) & 0xfe;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		if (ad->powerfunc) {
+			ad->powerfunc(1);
+			ad->powerdown = 0;
+		/* the chip lost all config during powerdown, reconfig */
+			for (i = 0; i < AD1939_REGCOUNT; i++)
+				codec->write(codec, i, cache[i]);
+		}
+		ad1939_write(codec, AD1939_PLLCTL0, pll0);
+		ad1939_write(codec, AD1939_DACCTL0, dac0);
+		ad1939_write(codec, AD1939_ADCCTL0, adc0);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+	case SND_SOC_BIAS_OFF:
+		/* turn off internal PLL and DAC/ADCs */
+		ad1939_write(codec, AD1939_PLLCTL0, pll0 | 1);
+		ad1939_write(codec, AD1939_DACCTL0, dac0 | 1);
+		ad1939_write(codec, AD1939_ADCCTL0, adc0 | 1);
+		if (ad->powerfunc) {
+			ad->powerfunc(0);
+			ad->powerdown = 1;
+		}
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+static int ad1939_digmute(struct snd_soc_dai *dai, int mute)
+{
+	ad1939_write(dai->codec, AD1939_DACMUTE, mute ? 0xff : 0);
+	return 0;
+}
+
+static int ad1939_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	dbg("sysck id %d f %d dir %d\n", clk_id, freq, dir);
+	/* FIXME: do something with sysclk if required. For now,
+	 * it works perfectly with 12.288MHz
+	 */
+	return 0;
+}
+
+#define AD1939_RATES	\
+	(SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_96000 | \
+	 SNDRV_PCM_RATE_192000)
+
+#define AD1939_FORMATS	\
+	(SNDRV_PCM_FMTBIT_S16_BE | SNDRV_PCM_FMTBIT_S24_BE | \
+	 SNDRV_PCM_FMTBIT_S32_BE)
+
+struct snd_soc_dai ad1939_dai = {
+	.name = AUDIO_NAME,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 4,	/* 4/8 in single/dualline TDM */
+		.rates = AD1939_RATES,
+		.formats = AD1939_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 4,	/* yes, 2 DACs! */
+		.rates = AD1939_RATES,
+		.formats = AD1939_FORMATS,
+	},
+	.ops = {
+		.hw_params = ad1939_hw_params,
+	},
+	.dai_ops = {
+		.digital_mute = ad1939_digmute,
+		.set_sysclk = ad1939_set_dai_sysclk,
+		.set_fmt = ad1939_set_dai_fmt,
+	}
+};
+EXPORT_SYMBOL_GPL(ad1939_dai);
+
+static int ad1939_init(struct snd_soc_device *socdev)
+{
+	struct snd_soc_codec *codec = socdev->codec;
+	struct ad1939_setup_data *setup = socdev->codec_data;
+	struct ad1939_private *ad = codec->private_data;
+	unsigned char r0, r1;
+	int ret;
+
+	codec->name = AUDIO_NAME;
+	codec->owner = THIS_MODULE;
+	codec->set_bias_level = ad1939_set_bias_level;
+	codec->dai = &ad1939_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = sizeof(ad1939_regcache);
+	codec->reg_cache = kmemdup(ad1939_regcache,
+				   sizeof(ad1939_regcache),
+				   GFP_KERNEL);
+	if (!codec->reg_cache)
+		return -ENOMEM;
+
+	ad->powerdown = 0;
+	ad->powerfunc = setup->powerfunc;
+
+	/* "initialize" the codec with default data */
+	for (r0 = 0; r0 < AD1939_REGCOUNT; r0++)
+		codec->write(codec, r0, ad1939_regcache[r0]);
+
+	/* remember TDM mode and set up internal clock routing */
+	ad->tdm_mode = setup->tdm_mode;
+	ad->drvflags = setup->drvflags;
+	ad->mixpairs = setup->mixpairs;
+	if ((ad->mixpairs < 1) || (ad->mixpairs > 4))
+		ad->mixpairs = 4;
+
+	/* use default TDM mode if noone wants one */
+	if ((ad->tdm_mode > AD1939_TDM_MODE_DUALLINE) || (ad->tdm_mode < 1))
+		ad->tdm_mode = AD1939_TDM_MODE_TDM;
+
+	r0 = ad1939_read(codec, AD1939_PLLCTL0) & ~(0xf << 3);
+	r1 = ad1939_read(codec, AD1939_PLLCTL1) & 3;
+
+	r0 |= (setup->pll_src & 3) << 5;
+	r0 |= (1<<7);	/* enable internal master clock (i.e. the DAC/ADCs) */
+	r0 |= (setup->mclk_xo & 3) << 3;
+	r1 |= setup->dac_adc_clksrc & 7; /* DAC clk/ADC clk/VREF */
+	r1 ^= AD1939_CLKSRC_ENABLE_ONCHIP_VREF;	/* this bis is inverted */
+
+	ad1939_write(codec, AD1939_PLLCTL0, r0);
+	ad1939_write(codec, AD1939_PLLCTL1, r1);
+
+	/* chip initializes itself after PLL is enabled. Maybe wait a
+	 * bit for it to finish?
+	 */
+
+	/* Bitclock sources for the ADC and DAC I2S interfaces */
+	r0 = ad1939_read(codec, AD1939_DACCTL1);
+	r1 = ad1939_read(codec, AD1939_ADCCTL2);
+	r0 &= ~AD1939_BCLKSRC_DAC_PLL;
+	r1 &= ~AD1939_BCLKSRC_ADC_PLL;
+	r0 |= setup->dac_adc_clksrc & AD1939_BCLKSRC_DAC_PLL;
+	r1 |= setup->dac_adc_clksrc & AD1939_BCLKSRC_ADC_PLL;
+	ad1939_write(codec, AD1939_DACCTL1, r0);
+	ad1939_write(codec, AD1939_ADCCTL2, r1);
+
+	printk(KERN_INFO "AD1935-AD1939 I2S Codec family driver\n");
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1,
+			       SNDRV_DEFAULT_STR1);
+	if (unlikely(ret < 0)) {
+		printk(KERN_ERR "failed to create pcms\n");
+		goto pcm_err;
+	}
+
+	ad1939_add_controls(codec);
+	ad1939_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		msg("failed to register card\n");
+		goto card_err;
+	}
+
+	return 0;
+
+card_err:
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+pcm_err:
+	kfree(codec->reg_cache);
+	return ret;
+}
+
+static void ad1939_deinit(struct snd_soc_device *socdev)
+{
+	if (socdev) {
+		ad1939_set_bias_level(socdev->codec, SND_SOC_BIAS_OFF);
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+		kfree(socdev->codec->private_data);
+		kfree(socdev->codec->reg_cache);
+		kfree(socdev->codec);
+	}
+}
+
+/* need to pass this around to i2c_attach()/spi_probe() */
+static struct snd_soc_device *ad1939_socdev;
+
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+static int ad1939_i2c_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct snd_soc_device *socdev = ad1939_socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret;
+
+	codec->control_data = client;
+	i2c_set_clientdata(client, socdev);
+	codec->read = ad1939_i2c_read;
+	codec->write = ad1939_i2c_write;
+
+	ret = ad1939_init(socdev);
+	if (unlikely(ret < 0)) {
+		msg("failed to initialise AD1937 I2C codec\n");
+		goto err;
+	}
+	return ret;
+
+err:
+	kfree(codec);
+	return ret;
+}
+
+static int ad1939_i2c_remove(struct i2c_client *client)
+{
+	struct snd_soc_device *socdev = i2c_get_clientdata(client);
+
+	ad1939_deinit(socdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ad1939_i2c_suspend(struct i2c_client *c, pm_message_t msg)
+{
+	return 0;
+}
+
+static int ad1939_i2c_resume(struct i2c_client *client)
+{
+	struct snd_soc_device *socdev = i2c_get_clientdata(client);
+	ad1939_resume(socdev);
+	return 0;
+}
+#else
+#define ad1939_i2c_suspend NULL
+#define ad1939_i2c_resume NULL
+#endif
+
+static const struct i2c_device_id ad1939_i2c_id[] = {
+	{ "ad1939", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ad1939_i2c_id);
+static struct i2c_driver ad1939_i2c_driver = {
+	.driver = {
+		.name = "ad1939",
+		.owner = THIS_MODULE,
+	},
+	.probe	= ad1939_i2c_probe,
+	.remove	= ad1939_i2c_remove,
+	.suspend	= ad1939_i2c_suspend,
+	.resume		= ad1939_i2c_resume,
+	.id_table	= ad1939_i2c_id,
+};
+#endif	/* I2C */
+
+#if defined(CONFIG_SPI) || defined(CONFIG_SPI_MODULE)
+static int __devinit ad1939_spi_probe(struct spi_device *spi)
+{
+	struct snd_soc_device *socdev = ad1939_socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret;
+
+	codec->control_data = spi;
+	codec->read = ad1939_spi_read;
+	codec->write = ad1939_spi_write;
+
+	spi_set_drvdata(spi, socdev);
+
+	ret = ad1939_init(socdev);
+	if (ret == 0)
+		return ret;
+
+	msg("failed to initialise AD1939 SPI codec\n");
+	kfree(codec);
+	return ret;
+}
+
+static int __devexit ad1939_spi_remove(struct spi_device *spi)
+{
+	struct snd_soc_device *socdev = spi_get_drvdata(spi);
+
+	ad1939_deinit(socdev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ad1939_spi_suspend(struct spi_device *spi, pm_message_t m)
+{
+	return 0;
+}
+
+static int ad1939_spi_resume(struct spi_device *spi)
+{
+	struct snd_soc_device *socdev = spi_get_drvdata(spi);
+	ad1939_resume(socdev);
+	return 0;
+}
+#else
+#define ad1939_spi_suspend NULL
+#define ad1939_spi_resume NULL
+#endif
+static struct spi_driver ad1939_spi_driver = {
+	.driver =	{
+		.name	= "ad1939",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ad1939_spi_probe,
+	.remove		= __devexit_p(ad1939_spi_remove),
+	.suspend	= ad1939_spi_suspend,
+	.resume		= ad1939_spi_resume,
+};
+#endif	/* SPI */
+
+static int ad1939_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct ad1939_setup_data *setup = socdev->codec_data;
+	struct snd_soc_codec *codec;
+	struct ad1939_private *ad;
+	int ret;
+
+	ret = -ENOMEM;
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		goto out;
+
+	ad = kzalloc(sizeof(struct ad1939_private), GFP_KERNEL);
+	if (ad == NULL) {
+		kfree(codec);
+		goto out;
+	}
+
+	ret = 0;
+
+	ad->codec = codec;
+	codec->private_data = ad;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	ad->dev_addr = setup->dev_address;	/* I2C/SPI device addr */
+
+	/* XXX: how can this value be passed to the spi_probe() callback
+	 * in a cleaner way? this seems a bit hackish to me...
+	 */
+	ad1939_socdev = socdev;
+
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	ret = i2c_add_driver(&ad1939_i2c_driver);
+	if (ret)
+		dev_err(&pdev->dev, "cannot register I2C driver\n");
+#endif
+#if defined(CONFIG_SPI) || defined(CONFIG_SPI_MODULE)
+	ret = spi_register_driver(&ad1939_spi_driver);
+	if (ret)
+		dev_err(&pdev->dev, "cannot register SPI driver\n");
+#endif
+
+out:
+	return ret;
+}
+
+static int ad1939_remove(struct platform_device *pdev)
+{
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
+	i2c_del_driver(&ad1939_i2c_driver);
+#endif
+#if defined(CONFIG_SPI) || defined(CONFIG_SPI_MODULE)
+	spi_unregister_driver(&ad1939_spi_driver);
+#endif
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_ad1939 = {
+	.probe = 	ad1939_probe,
+	.remove = 	ad1939_remove,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_ad1939);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("ASoC AD1935-AD1939 I2S Codec family driver");
+MODULE_AUTHOR("Manuel Lauss <mlau@msc-ge.com>");
diff --git a/sound/soc/codecs/ad1939.h b/sound/soc/codecs/ad1939.h
new file mode 100644
index 0000000..e25dcef
--- /dev/null
+++ b/sound/soc/codecs/ad1939.h
@@ -0,0 +1,110 @@
+/*
+ * AD1935/AD1936/AD1937/AD1938/AD1939 I2S ASoC Codec driver
+ *
+ * Copyright (c) 2007 MSC Vertriebsges.m.b.H,
+ *	Manuel Lauss <mlau@msc-ge.com> <mano@roarinelk.homelinux.net>
+ *
+ * licensed under the GPLv2
+ *
+ */
+
+#ifndef _AD1939_H_
+#define _AD1939_H_
+
+#define AD1939_PLLCTL0	0x00
+#define AD1939_PLLCTL1	0x01
+#define AD1939_DACCTL0	0x02
+#define AD1939_DACCTL1	0x03
+#define AD1939_DACCTL2	0x04
+#define AD1939_DACMUTE	0x05
+#define AD1939_VOL1L	0x06
+#define AD1939_VOL1R	0x07
+#define AD1939_VOL2L	0x08
+#define AD1939_VOL2R	0x09
+#define AD1939_VOL3L	0x0A
+#define AD1939_VOL3R	0x0B
+#define AD1939_VOL4L	0x0C
+#define AD1939_VOL4R	0x0D
+#define AD1939_ADCCTL0	0x0E
+#define AD1939_ADCCTL1	0x0F
+#define AD1939_ADCCTL2	0x10
+
+#define AD1939_REGCOUNT	0x11
+
+/*
+ * AD1939 setup data
+ */
+
+/* TDM modes. Have a look at the manual to understand what these do. */
+#define AD1939_TDM_MODE_TDM		1
+#define AD1939_TDM_MODE_AUX		2
+#define AD1939_TDM_MODE_DUALLINE	3
+
+/* Master PLL clock source, select one */
+#define AD1939_PLL_SRC_MCLK		0	/* external clock */
+#define AD1939_PLL_SRC_DACLRCK		1	/* get from DAC LRCLK */
+#define AD1939_PLL_SRC_ADCLRCK		2	/* get from ADC LRCLK */
+
+/* clock sources for ADC, DAC. Refer to the manual for more information
+ * (for 192000kHz modes, internal PLL _MUST_ be used). Select one for ADC
+ * and DAC.
+ */
+#define AD1939_CLKSRC_DAC_PLL		0	/* DAC clocked by int. PLL */
+#define AD1939_CLKSRC_DAC_MCLK		(1<<0)	/* DAC clocked by ext. MCK */
+#define AD1939_CLKSRC_ADC_PLL		0	/* ADC clocked by int. PLL */
+#define AD1939_CLKSRC_ADC_MCLK		(1<<1)	/* ADC clocked by ext. MCK */
+#define AD1939_CLKSRC_ENABLE_ONCHIP_VREF	(1<<2)
+
+/* I2S Bitclock sources for DAC and ADC I2S interfaces.
+ * OR it to ad1939_setup_data.dac_adc_clksrc. Select one for ADC and DAC.
+ */
+#define AD1939_BCLKSRC_DAC_EXT		0	/* DAC I2SCLK from DBCLK pin */
+#define AD1939_BCLKSRC_DAC_PLL		(1<<6)	/* DAC I2SCLK from int. PLL */
+#define AD1939_BCLKSRC_ADC_EXT		0	/* DAC I2SCLK from DBCLK pin */
+#define AD1939_BCLKSRC_ADC_PLL		(1<<7)	/* DAC I2SCLK from int. PLL */
+
+/* MCLK_XO pin configuration */
+#define AD1939_MCLKXO_MCLKXI		0	/* mirror MCLK_XI pin */
+#define AD1939_MCLKXO_256FS		1
+#define AD1939_MCLKXO_512FS		2
+#define AD1939_MCLKXO_OFF		3	/* disable MCLK_XO output */
+
+/* driver specific flags */
+/* specify these flags if the LRCK and/or BCK pins of the ADC and DAC
+ * parts are wired together on the PCB; to prevent both units from driving
+ * the pin and resulting bad signals.  You then have to specify WHICH
+ * unit gets to be the Master (clock generator) and which is slave.
+ * NOTE: this is only used if the CODEC is configured as either BCK or
+ * LRCK master; if the codec is BCK/LRCK slave (BCK and LRCK are driven
+ * by external components) these settings are ignored!
+ */
+#define AD1939_DRV_ADCDAC_COMMON_BCK	(1<<0)
+#define AD1939_DRV_ADCDAC_COMMON_LRCK	(1<<1)
+
+/* define which unit gets to drive the BCK/LRCK pins if the codec is
+ * required to be either BCK or LRCK master
+ */
+#define AD1939_DRV_DAC_LRCK_MASTER	0
+#define AD1939_DRV_ADC_LRCK_MASTER	(1<<2)
+#define AD1939_DRV_DAC_BCK_MASTER	0
+#define AD1939_DRV_ADC_BCK_MASTER	(1<<3)
+
+/* use TDM mode even for stereo (2-channel) signals */
+#define AD1939_DRV_TDM_STEREO		(1<<4)
+
+struct ad1939_setup_data {
+	/* device address, WITHOUT the R/W bit! (default 0x04) */
+	unsigned char dev_address;	/* I2C or SPI device address */
+	unsigned char tdm_mode;		/* one of AD1939_TDM_MODE_* */
+	unsigned char pll_src;		/* one of AD1939_PLL_SRC_* */
+	unsigned char dac_adc_clksrc;	/* AD1939_{B,}CLKSRC_* or'ed together */
+	unsigned char mclk_xo;		/* one of AD1939_MCLKXO_* */
+	unsigned char drvflags;		/* driver flags */
+	unsigned char mixpairs;	/* mixer chan pairs (L-R) to advertise */
+	void(*powerfunc)(int);		/* codec power supply function */
+};
+
+extern struct snd_soc_codec_device	soc_codec_dev_ad1939;
+extern struct snd_soc_dai		ad1939_dai;
+
+#endif
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index 9210a53..18dad4f 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -10,3 +10,7 @@ obj-$(CONFIG_SND_SOC_MPC5121_ADS) += mpc5121_ads.o mpc5121_ac97.o
 # MPC5121 Platform Support
 obj-$(CONFIG_SND_SOC_MPC5121) += mpc5121_psc.o mpc5121_pcm.o
 
+# Modified MPC5121 ADS I2S Machine Support
+obj-$(CONFIG_SND_SOC_MPC5121_I2S) += mpc5121_i2s.o
+
+
diff --git a/sound/soc/fsl/mpc5121_i2s.c b/sound/soc/fsl/mpc5121_i2s.c
new file mode 100644
index 0000000..72888e0
--- /dev/null
+++ b/sound/soc/fsl/mpc5121_i2s.c
@@ -0,0 +1,452 @@
+/*
+ * Freescale MPC5121ADS I2S SoC Fabric driver
+ *
+ * Copyright 2008 Freescale Semiconductor Inc.
+ * Author: John Rigby jrigby@freescale.com
+ *
+ * Based on mpc8610_hpcd.c:
+ *    Freescale MPC8610HPCD ALSA SoC Fabric driver
+ *    Author: Timur Tabi <timur@freescale.com>
+ *
+ * The ADS512101 board only has AC97, this driver is for a modified
+ * board that has an AD1938 I2S codec.  The AD1938 is the SPI
+ * version of the AD1939 I2C codec.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without
+ * any warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <sound/soc.h>
+
+#include <asm/of_device.h>
+#include <asm/of_platform.h>
+
+#include "../codecs/ad1939.h"
+#include "mpc5121_psc_info.h"
+#include "mpc5121_pcm.h"
+
+/* setup for AD1939 codec in master mode */
+struct ad1939_setup_data mpc5121_ads_ad1939_master_setup = {
+	.dev_address = 4,
+	.pll_src = AD1939_PLL_SRC_MCLK,
+	.dac_adc_clksrc =
+	    AD1939_CLKSRC_DAC_PLL |
+	    AD1939_CLKSRC_ADC_PLL |
+	    AD1939_CLKSRC_ENABLE_ONCHIP_VREF |
+	    AD1939_BCLKSRC_DAC_PLL |
+	    AD1939_BCLKSRC_ADC_EXT,
+	.mclk_xo = AD1939_MCLKXO_MCLKXI,
+	.drvflags =
+	    AD1939_DRV_ADCDAC_COMMON_BCK |
+	    AD1939_DRV_ADCDAC_COMMON_LRCK |
+	    AD1939_DRV_ADC_LRCK_MASTER |
+	    AD1939_DRV_ADC_BCK_MASTER,
+	.mixpairs = 0,
+};
+
+/* setup for AD1939 codec in slave mode */
+struct ad1939_setup_data mpc5121_ads_ad1939_slave_setup = {
+	.dev_address = 4,
+	.pll_src = AD1939_PLL_SRC_DACLRCK,
+	.dac_adc_clksrc =
+	    AD1939_CLKSRC_DAC_PLL |
+	    AD1939_CLKSRC_ADC_PLL |
+	    AD1939_CLKSRC_ENABLE_ONCHIP_VREF |
+	    AD1939_BCLKSRC_DAC_EXT |
+	    AD1939_BCLKSRC_ADC_EXT,
+	.mclk_xo = AD1939_MCLKXO_OFF,
+	.drvflags = 0,
+	.mixpairs = 0,
+};
+
+struct ad1939_setup_data *codec_data;
+
+/**
+ * mpc5121_ads_startup: program the board with various hardware parameters
+ *
+ * This function takes board-specific information, like clock frequencies
+ * and serial data formats, and passes that information to the codec and
+ * transport drivers.
+ */
+static int mpc5121_ads_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	struct mpc5121_ads_data *machine_data = rtd->socdev->dev->platform_data;
+	int ret = 0;
+
+	/* Tell the CPU driver what the serial protocol is. */
+	if (cpu_dai->dai_ops.set_fmt) {
+		ret = cpu_dai->dai_ops.set_fmt(cpu_dai,
+					       machine_data->dai_format);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set CPU driver audio format\n");
+			return ret;
+		}
+	}
+
+	/* Tell the codec driver what the serial protocol is. */
+	if (codec_dai->dai_ops.set_fmt) {
+		ret = codec_dai->dai_ops.set_fmt(codec_dai,
+						 machine_data->dai_format);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set codec driver audio format\n");
+			return ret;
+		}
+	}
+
+	/*
+	 * Tell the CPU driver what the clock frequency is, and whether it's a
+	 * slave or master.
+	 */
+	if (cpu_dai->dai_ops.set_sysclk) {
+		ret = cpu_dai->dai_ops.set_sysclk(cpu_dai, 0,
+						  machine_data->clk_frequency,
+						  machine_data->
+						  cpu_clk_direction);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set CPU driver clock parameters\n");
+			return ret;
+		}
+	}
+
+	/*
+	 * Tell the codec driver what the MCLK frequency is, and whether it's
+	 * a slave or master.
+	 */
+	if (codec_dai->dai_ops.set_sysclk) {
+		ret = codec_dai->dai_ops.set_sysclk(codec_dai, 0,
+						    machine_data->clk_frequency,
+						    machine_data->
+						    codec_clk_direction);
+		if (ret < 0) {
+			dev_err(substream->pcm->card->dev,
+				"could not set codec driver clock params\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * mpc5121_ads_ops: ASoC fabric driver operations
+ */
+static struct snd_soc_ops mpc5121_ads_ops = {
+	.startup = mpc5121_ads_startup,
+};
+
+/**
+ * mpc5121_ads_machine: ASoC machine data
+ */
+static struct snd_soc_machine mpc5121_ads_machine = {
+	.name = "MPC5121 ADS",
+	.num_links = 1,
+};
+
+/**
+ * mpc5121_ads_probe: OF probe function for the fabric driver
+ *
+ * This function gets called when fsl,mpc5121-psc-i2s node
+ * is found in the device tree.
+ */
+static int mpc5121_ads_probe(struct of_device *ofdev,
+			     const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node;
+	struct device_node *codec_np = NULL;
+	const phandle *codec_ph;
+	const char *sprop;
+	const u32 *iprop;
+	struct resource res;
+	struct platform_device *sound_device = NULL;
+	struct mpc5121_ads_data *machine_data;
+	struct mpc5121_psc_info *psc_info;
+	struct mpc512x_dma_config dma_config;
+	int ret = -ENODEV;
+
+	machine_data = kzalloc(sizeof(struct mpc5121_ads_data), GFP_KERNEL);
+	if (!machine_data)
+		return -ENOMEM;
+
+	psc_info = &machine_data->psc_info;
+	psc_info->dev = &ofdev->dev;
+
+	/*
+	 * We are only interested in PSCs with a codec phandle.
+	 */
+	codec_ph = of_get_property(np, "codec-handle", NULL);
+	if (!codec_ph)
+		goto error;
+
+	codec_np = of_find_node_by_phandle(*codec_ph);
+	if (!codec_np)
+		goto error;
+
+	/*
+	 * The MPC5121 ADS only knows about the AD1938 codec.
+	 */
+	if (!of_device_is_compatible(codec_np, "ad,ad1938"))
+		goto error;
+	/*
+	 * Get the device ID
+	 */
+	iprop = of_get_property(np, "cell-index", NULL);
+	if (!iprop) {
+		dev_err(&ofdev->dev, "cell-index property not found\n");
+		ret = -EINVAL;
+		goto error;
+	}
+	psc_info->id = *iprop;
+
+	/* Get the serial format and clock direction. */
+	sprop = of_get_property(np, "fsl,mode", NULL);
+	if (!sprop) {
+		dev_err(&ofdev->dev, "fsl,mode property not found\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+	if (strcasecmp(sprop, "i2s-slave") == 0) {
+		machine_data->dai_format
+		    = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM;
+		machine_data->codec_clk_direction = SND_SOC_CLOCK_OUT;
+		machine_data->cpu_clk_direction = SND_SOC_CLOCK_IN;
+		codec_data = &mpc5121_ads_ad1939_master_setup;
+
+		/*
+		 * In i2s-slave mode, the codec has its own clock source, so we
+		 * need to get the frequency from the device tree and pass it to
+		 * the codec driver.
+		 */
+		iprop = of_get_property(codec_np, "clock-frequency", NULL);
+		if (!iprop || !*iprop) {
+			dev_err(&ofdev->dev, "codec clock-frequency property "
+				"is missing or invalid\n");
+			ret = -EINVAL;
+			goto error;
+		}
+		machine_data->clk_frequency = *iprop;
+	} else if (strcasecmp(sprop, "i2s-master") == 0) {
+		machine_data->dai_format
+		    = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS;
+		machine_data->codec_clk_direction = SND_SOC_CLOCK_IN;
+		machine_data->cpu_clk_direction = SND_SOC_CLOCK_OUT;
+		codec_data = &mpc5121_ads_ad1939_slave_setup;
+		machine_data->clk_frequency = 1; /* hack */
+	} else {
+		dev_err(&ofdev->dev,
+			"unrecognized fsl,mode property \"%s\"\n", sprop);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* Read the PSC information from the device tree */
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret) {
+		dev_err(&ofdev->dev, "could not obtain PSC address\n");
+		goto error;
+	}
+	if (!res.start) {
+		dev_err(&ofdev->dev, "invalid PSC address\n");
+		goto error;
+	}
+
+	psc_info->phys = res.start;
+	psc_info->psc = ioremap(psc_info->phys, res.end - res.start + 1);
+	if (!psc_info->psc) {
+		dev_err(&ofdev->dev, "could not map PSC address %x\n",
+			psc_info->phys);
+		ret = -EINVAL;
+		goto error;
+	}
+
+	/* Get the IRQ of the PSC */
+	psc_info->irq = irq_of_parse_and_map(np, 0);
+	if (!psc_info->irq) {
+		dev_err(&ofdev->dev, "could not get PSC IRQ\n");
+		ret = -EINVAL;
+		goto error;
+	}
+
+#define PSC_DMA_GRAN 64
+	/*
+	 * FIXME put this in the device tree
+	 *
+	 * DMA channels are dedicated:
+	 * 	rx = psc number
+	 * 	tx = psc number + 12.
+	 *
+	 * DMA granularity is PSC_DMA_GRAN bytes
+	 *
+	 * PSC FIFO data register are at
+	 * 	rx offset is 0xfc
+	 * 	tx offset is 0xbc
+	 */
+	dma_config.rx_dma_ch_nr = psc_info->id;
+	dma_config.tx_dma_ch_nr = psc_info->id + 12;
+	psc_info->rx_dma_gran = PSC_DMA_GRAN;
+	psc_info->tx_dma_gran = PSC_DMA_GRAN;
+	dma_config.rx_dma_gran = PSC_DMA_GRAN;
+	dma_config.tx_dma_gran = PSC_DMA_GRAN;
+	dma_config.rx_dev_addr = psc_info->phys + 0xfc;
+	dma_config.tx_dev_addr = psc_info->phys + 0xbc;
+	if (!mpc512x_dma_configure(&dma_config)) {
+		dev_err(&ofdev->dev, "could not configure DMA device\n");
+		ret = -EBUSY;
+		goto error;
+	}
+
+	/*
+	 * Initialize our DAI data structure.  We should probably get this
+	 * information from the device tree.
+	 */
+	machine_data->dai.name = "AD1939";
+	machine_data->dai.stream_name = "AD1939";
+
+	machine_data->dai.cpu_dai = mpc5121_psc_create_dai(psc_info);
+	machine_data->dai.codec_dai = &ad1939_dai;
+	machine_data->dai.ops = &mpc5121_ads_ops;
+
+	mpc5121_ads_machine.dai_link = &machine_data->dai;
+
+	/* Allocate a new audio platform device structure */
+	sound_device = platform_device_alloc("soc-audio", -1);
+	if (!sound_device) {
+		dev_err(&ofdev->dev, "platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	machine_data->sound_devdata.platform = &mpc512x_soc_platform;
+	machine_data->sound_devdata.machine = &mpc5121_ads_machine;
+	machine_data->sound_devdata.codec_dev = &soc_codec_dev_ad1939;
+	machine_data->sound_devdata.codec_data = codec_data;
+
+	sound_device->dev.platform_data = machine_data;
+
+	/* Set the platform device and ASoC device to point to each other */
+	platform_set_drvdata(sound_device, &machine_data->sound_devdata);
+	machine_data->sound_devdata.dev = &sound_device->dev;
+
+	/* Initialize PSC controller and codec */
+	mpc5121_psc_init(&ofdev->dev, machine_data->dai.cpu_dai);
+	ret = platform_device_add(sound_device);
+	if (ret) {
+		dev_err(&ofdev->dev, "platform device add failed\n");
+		goto error;
+	}
+
+	dev_set_drvdata(&ofdev->dev, sound_device);
+	return 0;
+
+error:
+	of_node_put(codec_np);
+
+	if (sound_device)
+		platform_device_unregister(sound_device);
+
+	if (machine_data->dai.cpu_dai)
+		mpc5121_psc_destroy_dai(machine_data->dai.cpu_dai);
+
+	if (psc_info->psc)
+		iounmap(psc_info->psc);
+
+	if (psc_info->irq)
+		irq_dispose_mapping(psc_info->irq);
+
+	kfree(machine_data);
+
+	return ret;
+}
+
+/**
+ * mpc5121_ads_remove: remove the OF device
+ *
+ * This function is called when the OF device is removed.
+ */
+static int mpc5121_ads_remove(struct of_device *ofdev)
+{
+	struct platform_device *sound_device = dev_get_drvdata(&ofdev->dev);
+	struct mpc5121_ads_data *machine_data =
+					sound_device->dev.platform_data;
+
+	platform_device_unregister(sound_device);
+
+	if (machine_data->dai.cpu_dai)
+		mpc5121_psc_destroy_dai(machine_data->dai.cpu_dai);
+
+	if (machine_data->psc_info.psc)
+		iounmap(machine_data->psc_info.psc);
+
+	kfree(machine_data);
+	sound_device->dev.platform_data = NULL;
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+
+	return 0;
+}
+
+static struct of_device_id mpc5121_ads_match[] = {
+	{
+	 .compatible = "fsl,mpc5121-psc-i2s",
+	 },
+	{
+	 .compatible = "mpc512x-psc-i2s",
+	},
+	{}
+};
+
+MODULE_DEVICE_TABLE(of, mpc5121_ads_match);
+
+static struct of_platform_driver mpc5121_ads_of_driver = {
+	.owner = THIS_MODULE,
+	.name = "mpc5121_ads",
+	.match_table = mpc5121_ads_match,
+	.probe = mpc5121_ads_probe,
+	.remove = mpc5121_ads_remove,
+};
+
+/**
+ * mpc5121_ads_init: fabric driver initialization.
+ *
+ * This function is called when this module is loaded.
+ */
+static int __init mpc5121_ads_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "Freescale MPC5121 ADS ALSA SoC I2S fabric driver\n");
+
+	ret = of_register_platform_driver(&mpc5121_ads_of_driver);
+
+	if (ret)
+		printk(KERN_ERR
+		       "mpc5121-ads: failed to register platform driver\n");
+
+	return ret;
+}
+
+/**
+ * mpc5121_ads_exit: fabric driver exit
+ *
+ * This function is called when this driver is unloaded.
+ */
+static void __exit mpc5121_ads_exit(void)
+{
+	of_unregister_platform_driver(&mpc5121_ads_of_driver);
+}
+
+module_init(mpc5121_ads_init);
+module_exit(mpc5121_ads_exit);
+
+MODULE_AUTHOR("John Rigby <jrigby@freescale.com>");
+MODULE_DESCRIPTION("Freescale MPC5121 ADS ALSA SoC fabric driver");
+MODULE_LICENSE("GPL");
-- 
1.6.0.90.g436ed

