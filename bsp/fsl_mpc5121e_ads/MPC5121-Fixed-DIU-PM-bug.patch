From 8fb8032a8022c7b338af2dfa6e8eb462fd24fa51 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Wed, 8 Jul 2009 10:20:16 +0800
Subject: [PATCH 23/25] MPC5121: Fixed DIU PM bug

Original patch taken from Freescale BSP Global
Package Pool:
  http://www.bitshrine.org/gpp/

Bug description: VGA, LCD and DVI ports of DIU
failed to work after sleep in memory. One LTIB
package named dvi-enable is added to enable DVI
transmitter after awaking up from the memory mode.

Signed-off-by: Chen Hongjun <Hong-jun.chen@freecale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/platforms/512x/mpc5121_diu.c |   30 +++++++++++++++++++++++++++++
 drivers/video/fsl-diu-fb.c                |   25 +++++++++++++++++++++--
 2 files changed, 52 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/platforms/512x/mpc5121_diu.c b/arch/powerpc/platforms/512x/mpc5121_diu.c
index 8443384..62a74a4 100644
--- a/arch/powerpc/platforms/512x/mpc5121_diu.c
+++ b/arch/powerpc/platforms/512x/mpc5121_diu.c
@@ -166,4 +166,34 @@ int mpc5121ads_set_sysfs_monitor_port(int val)
 }
 EXPORT_SYMBOL(mpc5121ads_set_sysfs_monitor_port);
 
+void mpc5121ads_diu_io_pm_restore(void)
+{
+	struct device_node *np;
+
+#define DIU_CLK		0x284
+#define DIU_HSYN	0x288
+#define DIU_IO_OFFSET	0x294
+#define DIU_IO_SIZE	0x68
+	/*
+	 * io pad config
+	 */
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-ioctl");
+	if (np) {
+		void __iomem *ioctl = of_iomap(np, 0);
+		int i, count = DIU_IO_SIZE / 4;
+		u32 *reg;
+
+		reg = ioctl + DIU_CLK;
+		*reg = 0x107;
+		reg = ioctl + DIU_HSYN;
+		*reg = 0x103;
+		reg = ioctl + DIU_IO_OFFSET;
+		for (i = 0; i < count; i++)
+			*reg++ = 0x103;
+
+		of_node_put(np);
+		iounmap(ioctl);
+	}
+}
+EXPORT_SYMBOL(mpc5121ads_diu_io_pm_restore);
 #endif
diff --git a/drivers/video/fsl-diu-fb.c b/drivers/video/fsl-diu-fb.c
index 7927e30..0241e6c 100644
--- a/drivers/video/fsl-diu-fb.c
+++ b/drivers/video/fsl-diu-fb.c
@@ -1479,6 +1479,9 @@ static void free_irq_local(int irq)
 }
 
 #ifdef CONFIG_PM
+struct diu *reg;
+extern void mpc5121ads_diu_io_pm_restore(void);
+
 /*
  * Power management hooks. Note that we won't be called from IRQ context,
  * unlike the blank functions above, so we may sleep.
@@ -1486,8 +1489,16 @@ static void free_irq_local(int irq)
 static int fsl_diu_suspend(struct of_device *ofdev, pm_message_t state)
 {
 	struct fsl_diu_data *machine_data;
+	struct diu *hw = dr.diu_reg;
 
 	machine_data = dev_get_drvdata(&ofdev->dev);
+
+	reg = kmalloc(sizeof(struct diu), GFP_KERNEL);
+	if (!reg)
+		printk(KERN_ERR"No enough memory for storing DIU regs !\n");
+	else
+		memcpy(reg, hw, sizeof(struct diu));
+
 	disable_lcdc(machine_data->fsl_diu_info[0]);
 
 	return 0;
@@ -1495,10 +1506,18 @@ static int fsl_diu_suspend(struct of_device *ofdev, pm_message_t state)
 
 static int fsl_diu_resume(struct of_device *ofdev)
 {
-	struct fsl_diu_data *machine_data;
+	struct diu *hw = dr.diu_reg;
 
-	machine_data = dev_get_drvdata(&ofdev->dev);
-	enable_lcdc(machine_data->fsl_diu_info[0]);
+	u32 *i2c_intctrl_reg = ioremap(0x80001760, sizeof(u32));
+
+	/* Work around for I2C interrupt register lost after PM */
+	*i2c_intctrl_reg = 0x15000000;
+
+	mpc5121ads_diu_io_pm_restore();
+	if (reg) {
+		memcpy(hw, reg, sizeof(struct diu));
+		kfree(reg);
+	}
 
 	return 0;
 }
-- 
1.6.3.1

