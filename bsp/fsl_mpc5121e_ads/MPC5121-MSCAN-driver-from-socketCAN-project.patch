From 6343afb6df0042073462fe6ede37d2eead4d7ab4 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Thu, 18 Jun 2009 15:33:42 +0800
Subject: [PATCH 01/25] MPC5121: MSCAN driver from socketCAN project

Original patch taken from rev 4 board support ISO image:
   mpc5121ads-20081208_ltib-beta.iso
   http://www.freescale.com/webapp/sps/site/overview.jsp?
   nodeId=0127260061033202A5621E

   Patches:
   linux-2.6.24.6-mpc5121-MSCAN-driver-from-socketCAN-project.patch
   linux-2.6.24.6-mpc5121-MSCAN-for-MPC5121.patch

all these files come from the following URL(socketCAN):

http://svn.berlios.de/svnroot/repos/socketcan/trunk/kernel/2.6/

Signed-off-by: Hongjun, Chen <hong-jun.chen@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/include/asm/mpc512x.h  |    3 -
 drivers/net/can/Kconfig             |   20 +
 drivers/net/can/Makefile            |    1 +
 drivers/net/can/mscan/Makefile      |    2 +
 drivers/net/can/mscan/dev.c         |  289 ++++++++++++++
 drivers/net/can/mscan/mpc52xx_can.c |  287 ++++++++++++++
 drivers/net/can/mscan/mscan.c       |  704 +++++++++++++++++++++++++++++++++++
 drivers/net/can/mscan/mscan.h       |  253 +++++++++++++
 include/linux/can/dev.h             |   77 ++++
 include/linux/can/ioctl.h           |  159 ++++++++
 include/linux/can/version.h         |   30 ++
 11 files changed, 1822 insertions(+), 3 deletions(-)
 create mode 100644 drivers/net/can/mscan/Makefile
 create mode 100644 drivers/net/can/mscan/dev.c
 create mode 100644 drivers/net/can/mscan/mpc52xx_can.c
 create mode 100644 drivers/net/can/mscan/mscan.c
 create mode 100644 drivers/net/can/mscan/mscan.h
 create mode 100644 include/linux/can/dev.h
 create mode 100644 include/linux/can/ioctl.h
 create mode 100644 include/linux/can/version.h

diff --git a/arch/powerpc/include/asm/mpc512x.h b/arch/powerpc/include/asm/mpc512x.h
index 0efc770..b222dbd 100644
--- a/arch/powerpc/include/asm/mpc512x.h
+++ b/arch/powerpc/include/asm/mpc512x.h
@@ -113,9 +113,6 @@ extern void mpc5121_pscgpio_pin_high(int psc, int pin);
 extern void mpc5121_pscgpio_pin_low(int psc, int pin);
 extern void mpc5121_pscgpio_make_psc(int psc, int pin);
 
-extern struct clk *clk_get(struct device *dev, const char *id);
-extern int clk_enable(struct clk *clk);
-
 #ifdef CONFIG_PM
 extern int __init mpc512x_pm_init(void);
 extern void mpc512x_pmc_clrevent(void);
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index 57def0d..8b0a9c8 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -22,4 +22,24 @@ config CAN_DEBUG_DEVICES
 	  a problem with CAN support and want to see more of what is going
 	  on.
 
+config CAN_MSCAN
+	depends on CAN && (PPC || M68K || M68KNOMMU)
+	tristate "Support for a Freescale MSCAN based chips"
+	---help---
+	  The Motorola Scalable Controller Area Network (MSCAN) definition
+	  is based on the MSCAN12 definition which is the specific
+	  implementation of the Motorola Scalable CAN concept targeted for
+	  the Motorola MC68HC12 Microcontroller Family.
+
+config CAN_MPC52XX
+	tristate "Freescale MPC5200/MPC5121 onboard CAN controller"
+	depends on CAN_MSCAN && (PPC_MPC52xx || PPC_52xx)
+	default LITE5200
+	---help---
+	  If you say yes here you get support for Freescale MPC5200/MPC5121
+	  onboard dualCAN controller.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called mpc52xx_can.
+
 endmenu
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index c4bead7..20e5867 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_CAN_VCAN)		+= vcan.o
+obj-$(CONFIG_CAN_MSCAN)		+= mscan/
diff --git a/drivers/net/can/mscan/Makefile b/drivers/net/can/mscan/Makefile
new file mode 100644
index 0000000..a4bbf04
--- /dev/null
+++ b/drivers/net/can/mscan/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_CAN_MPC52XX)	+= mscan-mpc52xx.o
+mscan-mpc52xx-objs	:= mscan.o mpc52xx_can.o dev.o
diff --git a/drivers/net/can/mscan/dev.c b/drivers/net/can/mscan/dev.c
new file mode 100644
index 0000000..9fc0eaa
--- /dev/null
+++ b/drivers/net/can/mscan/dev.c
@@ -0,0 +1,289 @@
+/*
+ * $Id$
+ *
+ * Copyright (C) 2005 Marc Kleine-Budde, Pengutronix
+ * Copyright (C) 2006 Andrey Volkov, Varma Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the version 2 of the GNU General Public License
+ * as published by the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+
+MODULE_DESCRIPTION("CAN netdevice library");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutronix.de>, "
+	      "Andrey Volkov <avolkov@varma-el.com>");
+
+/*
+ Abstract:
+	Baud rate calculated with next formula:
+	baud = frq/(brp*(1 + prop_seg+ phase_seg1 + phase_seg2))
+
+	This calc function based on work of Florian Hartwich and Armin Bassemi
+	"The Configuration of the CAN Bit Timing"
+	(http://www.semiconductors.bosch.de/pdf/CiA99Paper.pdf)
+
+ Parameters:
+  [in]
+    bit_time_nsec - expected bit time in nanosecs
+
+  [out]
+	bit_time	- calculated time segments, for meaning of
+			  each field read CAN standard.
+*/
+
+#define DEFAULT_MAX_BRP			64U
+#define DEFAULT_MAX_SJW			4U
+
+/* All below values in tq units */
+#define MAX_BIT_TIME	25U
+#define MIN_BIT_TIME	8U
+#define MAX_PROP_SEG	8U
+#define MAX_PHASE_SEG1	8U
+#define MAX_PHASE_SEG2	8U
+
+int can_calc_bit_time(struct can_priv *can, u32 baudrate,
+		      struct can_bittime_std *bit_time)
+{
+	int best_error  = -1; /* Ariphmetic error */
+	int df, best_df = -1; /* oscillator's tolerance range, greater is better*/
+	u32 quanta;	      /*in tq units*/
+	u32 brp, phase_seg1, phase_seg2, sjw, prop_seg;
+	u32 brp_min, brp_max, brp_expected;
+	u64 tmp;
+
+	/* baudrate range [1baud,1Mbaud] */
+	if (baudrate == 0 || baudrate > 1000000UL)
+		return -EINVAL;
+
+	tmp = (u64)can->can_sys_clock*1000;
+	do_div(tmp, baudrate);
+	brp_expected = (u32)tmp;
+
+	brp_min = brp_expected / (1000 * MAX_BIT_TIME);
+	if (brp_min == 0)
+		brp_min = 1;
+	if (brp_min > can->max_brp)
+		return -ERANGE;
+
+	brp_max = (brp_expected + 500 * MIN_BIT_TIME) / (1000 * MIN_BIT_TIME);
+	if (brp_max == 0)
+		brp_max = 1;
+	if (brp_max > can->max_brp)
+		brp_max = can->max_brp;
+
+	for (brp = brp_min; brp <= brp_max; brp++) {
+		quanta = brp_expected / (brp * 1000);
+		if (quanta < MAX_BIT_TIME && quanta * brp * 1000 != brp_expected)
+			quanta++;
+		if (quanta < MIN_BIT_TIME || quanta > MAX_BIT_TIME)
+			continue;
+
+		phase_seg2 = min((quanta - 3) / 2, MAX_PHASE_SEG2);
+		for (sjw = can->max_sjw; sjw > 0; sjw--) {
+			for (; phase_seg2 > sjw; phase_seg2--) {
+				u32 err1, err2;
+				phase_seg1 = phase_seg2 % 2 ? phase_seg2-1 : phase_seg2;
+				prop_seg = quanta-1 - phase_seg2 - phase_seg1;
+				/*
+				 * FIXME: support of longer lines (i.e. bigger prop_seg)
+				 * is more prefered than support of cheap oscillators
+				 * (i.e. bigger df/phase_seg1/phase_seg2)
+				 */
+				if (prop_seg < phase_seg1)
+						continue;
+				if (prop_seg > MAX_PROP_SEG)
+						goto next_brp;
+
+				err1 = phase_seg1*brp*500*1000/
+					(13*brp_expected-phase_seg2*brp*1000);
+				err2 = sjw*brp*50*1000/brp_expected;
+
+				df = min(err1, err2);
+				if (df >= best_df) {
+					unsigned error = abs(brp_expected*10/
+							   (brp*(1+prop_seg+phase_seg1+phase_seg2))-10000);
+
+					if (error > 10 || error > best_error)
+						continue;
+
+					if (error == best_error && prop_seg < bit_time->prop_seg)
+						continue;
+
+					best_error = error;
+					best_df = df;
+					bit_time->brp = brp;
+					bit_time->prop_seg = prop_seg;
+					bit_time->phase_seg1 = phase_seg1;
+					bit_time->phase_seg2 = phase_seg2;
+					bit_time->sjw = sjw;
+					bit_time->sam = (bit_time->phase_seg1 > 3);
+				}
+			}
+		}
+next_brp:	;
+	}
+
+	if (best_error < 0)
+		return -EDOM;
+	return 0;
+}
+EXPORT_SYMBOL(can_calc_bit_time);
+
+static int can_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct can_priv *can = netdev_priv(dev);
+	struct can_bittime *bt = (struct can_bittime *)&ifr->ifr_ifru;
+	ulong *baudrate = (ulong *)&ifr->ifr_ifru;
+	int ret = -EOPNOTSUPP;
+
+	dev_dbg(ND2D(dev), "(%s) 0x%08x %p\n", __func__, cmd, &ifr->ifr_ifru);
+
+	switch (cmd) {
+	case SIOCSCANBAUDRATE:
+		if (can->do_set_bit_time) {
+			struct can_bittime bit_time;
+			ret = can_calc_bit_time(can, *baudrate, &bit_time.std);
+			if (ret != 0)
+				break;
+			bit_time.type = CAN_BITTIME_STD;
+			ret = can->do_set_bit_time(dev, &bit_time);
+			if (!ret) {
+				can->baudrate = *baudrate;
+				can->bit_time = bit_time;
+			}
+		}
+		break;
+	case SIOCGCANBAUDRATE:
+		*baudrate = can->baudrate;
+		ret = 0;
+		break;
+	case SIOCSCANCUSTOMBITTIME:
+		if (can->do_set_bit_time) {
+			ret = can->do_set_bit_time(dev, bt);
+			if (!ret) {
+				can->bit_time = *bt;
+				if (bt->type == CAN_BITTIME_STD && bt->std.brp) {
+					can->baudrate = can->can_sys_clock/(bt->std.brp*
+						(1+bt->std.prop_seg+bt->std.phase_seg1+bt->std.phase_seg2));
+				} else
+					can->baudrate = CAN_BAUDRATE_UNKNOWN;
+			}
+		}
+		break;
+	case SIOCGCANCUSTOMBITTIME:
+		*bt = can->bit_time;
+		ret = 0;
+		break;
+	case SIOCSCANMODE:
+		if (can->do_set_mode) {
+			can_mode_t mode = *((can_mode_t *)(&ifr->ifr_ifru));
+			if (mode == CAN_MODE_START &&
+			    can->baudrate == CAN_BAUDRATE_UNCONFIGURED) {
+				dev_info(ND2D(dev), "Impossible to start on UNKNOWN speed\n");
+				ret = EINVAL;
+			} else
+				return can->do_set_mode(dev, mode);
+		}
+		break;
+	case SIOCGCANMODE:
+		*((can_mode_t *)(&ifr->ifr_ifru)) = can->mode;
+		ret = 0;
+		break;
+	case SIOCSCANCTRLMODE:
+		if (can->do_set_ctrlmode) {
+			can_ctrlmode_t ctrlmode = *((can_ctrlmode_t *)(&ifr->ifr_ifru));
+			return can->do_set_ctrlmode(dev, ctrlmode);
+		}
+		break;
+	case SIOCGCANCTRLMODE:
+		*((can_ctrlmode_t *)(&ifr->ifr_ifru)) = can->ctrlmode;
+		ret = 0;
+		break;
+	case SIOCSCANFILTER:
+		break;
+	case SIOCGCANFILTER:
+		break;
+	case SIOCGCANSTATE:
+		if (can->do_get_state)
+			return can->do_get_state(dev, (can_state_t *)(&ifr->ifr_ifru));
+		break;
+	case SIOCGCANSTATS:
+		*((struct can_device_stats *)(&ifr->ifr_ifru)) = can->can_stats;
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+static struct net_device_stats *can_get_stats(struct net_device *dev)
+{
+	struct can_priv *priv = netdev_priv(dev);
+
+	return &priv->net_stats;
+}
+#endif
+
+static void can_setup(struct net_device *dev)
+{
+	dev->type            = ARPHRD_CAN;
+	dev->mtu             = sizeof(struct can_frame);
+	dev->do_ioctl        = can_ioctl;
+	dev->hard_header_len = 0;
+	dev->addr_len        = 0;
+	dev->tx_queue_len    = 10;
+
+	/* New-style flags. */
+	dev->flags           = IFF_NOARP;
+	dev->features        = NETIF_F_NO_CSUM;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	dev->get_stats       = can_get_stats;
+#endif
+}
+
+/*
+ * Function  alloc_candev
+ * 	Allocates and sets up an CAN device
+ */
+struct net_device *alloc_candev(int sizeof_priv)
+{
+	struct net_device *dev;
+	struct can_priv *priv;
+
+	dev = alloc_netdev(sizeof_priv, "can%d", can_setup);
+	if (!dev)
+		return NULL;
+
+	priv = netdev_priv(dev);
+
+	priv->baudrate = CAN_BAUDRATE_UNCONFIGURED;
+	priv->max_brp  = DEFAULT_MAX_BRP;
+	priv->max_sjw  = DEFAULT_MAX_SJW;
+	spin_lock_init(&priv->irq_lock);
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_candev);
+
+void free_candev(struct net_device *dev)
+{
+	free_netdev(dev);
+}
+EXPORT_SYMBOL(free_candev);
diff --git a/drivers/net/can/mscan/mpc52xx_can.c b/drivers/net/can/mscan/mpc52xx_can.c
new file mode 100644
index 0000000..0025f31
--- /dev/null
+++ b/drivers/net/can/mscan/mpc52xx_can.c
@@ -0,0 +1,287 @@
+/*
+ * DESCRIPTION:
+ *  CAN bus driver for the Freescale MPC52xx embedded CPU.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2005, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * HISTORY:
+ *	 2005-02-03 created
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+#include <linux/clk.h>
+#include <linux/can.h>
+#include <linux/can/dev.h>
+#include <asm/io.h>
+#include <asm/of_platform.h>
+#include <asm/mpc52xx.h>
+
+#include "mscan.h"
+
+#include <linux/can/version.h>	/* for RCSID. Removed by mkpatch script */
+
+RCSID("$Id$");
+
+#define PDEV_MAX 2
+
+struct platform_device *pdev[PDEV_MAX];
+
+static int __devinit mpc52xx_can_probe(struct platform_device *pdev)
+{
+	struct resource *mem;
+	struct net_device *dev;
+	struct mscan_platform_data *pdata = pdev->dev.platform_data;
+	struct can_priv *can;
+	u32 mem_size;
+	int ret = -ENODEV;
+
+	if (!pdata)
+		return ret;
+
+	dev = alloc_mscandev();
+	if (!dev)
+		return -ENOMEM;
+	can = netdev_priv(dev);
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->irq = platform_get_irq(pdev, 0);
+	if (!mem || !dev->irq)
+		goto req_error;
+
+	mem_size = mem->end - mem->start + 1;
+	if (!request_mem_region(mem->start, mem_size, pdev->dev.driver->name)) {
+		dev_err(&pdev->dev, "resource unavailable\n");
+		goto req_error;
+	}
+
+	SET_NETDEV_DEV(dev, &pdev->dev);
+
+	dev->base_addr = (unsigned long)ioremap_nocache(mem->start, mem_size);
+
+	if (!dev->base_addr) {
+		dev_err(&pdev->dev, "failed to map can port\n");
+		ret = -ENOMEM;
+		goto fail_map;
+	}
+
+	can->can_sys_clock = pdata->clock_frq;
+
+	platform_set_drvdata(pdev, dev);
+
+	ret = register_mscandev(dev, pdata->clock_src);
+	if (ret >= 0) {
+		dev_info(&pdev->dev, "probe for a port 0x%lX done\n",
+			 dev->base_addr);
+		return ret;
+	}
+
+	iounmap((unsigned long *)dev->base_addr);
+      fail_map:
+	release_mem_region(mem->start, mem_size);
+      req_error:
+	free_candev(dev);
+	dev_err(&pdev->dev, "probe failed\n");
+	return ret;
+}
+
+static int __devexit mpc52xx_can_remove(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
+
+	platform_set_drvdata(pdev, NULL);
+	unregister_mscandev(dev);
+
+	iounmap((volatile void __iomem *)dev->base_addr);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, mem->end - mem->start + 1);
+	free_candev(dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static struct mscan_regs saved_regs;
+static int mpc52xx_can_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	_memcpy_fromio(&saved_regs, regs, sizeof(*regs));
+
+	return 0;
+}
+
+static int mpc52xx_can_resume(struct platform_device *pdev)
+{
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	regs->canctl0 |= MSCAN_INITRQ;
+	while ((regs->canctl1 & MSCAN_INITAK) == 0)
+		udelay(10);
+
+	regs->canctl1 = saved_regs.canctl1;
+	regs->canbtr0 = saved_regs.canbtr0;
+	regs->canbtr1 = saved_regs.canbtr1;
+	regs->canidac = saved_regs.canidac;
+
+	/* restore masks, buffers etc. */
+	_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,
+		     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));
+
+	regs->canctl0 &= ~MSCAN_INITRQ;
+	regs->cantbsel = saved_regs.cantbsel;
+	regs->canrier = saved_regs.canrier;
+	regs->cantier = saved_regs.cantier;
+	regs->canctl0 = saved_regs.canctl0;
+
+	return 0;
+}
+#endif
+
+static struct platform_driver mpc52xx_can_driver = {
+	.driver = {
+		   .name = "fsl-mscan",
+		   },
+	.probe = mpc52xx_can_probe,
+	.remove = __devexit_p(mpc52xx_can_remove),
+#ifdef CONFIG_PM
+	.suspend = mpc52xx_can_suspend,
+	.resume = mpc52xx_can_resume,
+#endif
+};
+
+#ifdef CONFIG_PPC_MERGE
+unsigned int fsl_find_ipb_freq(struct device_node *node)
+{
+	struct device_node *np;
+	const unsigned int *p_ipb_freq = NULL;
+
+	of_node_get(node);
+	while (node) {
+		p_ipb_freq = of_get_property(node, "bus-frequency", NULL);
+		if (p_ipb_freq)
+			break;
+
+		np = of_get_parent(node);
+		of_node_put(node);
+		node = np;
+	}
+	if (node)
+		of_node_put(node);
+
+	return p_ipb_freq ? *p_ipb_freq : 0;
+}
+
+static int __init mpc52xx_of_to_pdev(void)
+{
+	struct device_node *np = NULL;
+	unsigned int i;
+	int ret, type = -1, index = 0;
+	char *mscan_comp_name[] = {"fsl,mpc5200-mscan", "fsl,mpc5121-mscan"};
+	int  cpu_type[] = {MPC52xx_MSCAN, MPC512x_MSCAN};
+
+	for (i = 0; i < 2; i++) {
+		np = of_find_compatible_node(np, NULL, mscan_comp_name[i]);
+		if (np) {
+			type = cpu_type[i];
+			index = i;
+			of_node_put(np);
+			np = NULL;
+			break;
+		}
+	}
+
+	if (type != cpu_type[0] && type != cpu_type[1]) {
+		printk(KERN_ERR "%s: can't find any CAN devices\n", __func__);
+		return -1;
+	}
+
+	for (i = 0;
+	     (np = of_find_compatible_node(np, NULL,
+					   mscan_comp_name[index]));
+	     i++) {
+		struct resource r[2] = { };
+		struct mscan_platform_data pdata;
+
+		if (i >= PDEV_MAX) {
+			printk(KERN_WARNING "%s: increase PDEV_MAX for more "
+			       "than %i devices\n", __func__, PDEV_MAX);
+			break;
+		}
+
+		ret = of_address_to_resource(np, 0, &r[0]);
+		if (ret)
+			goto err;
+
+		of_irq_to_resource(np, 0, &r[1]);
+
+		pdev[i] =
+		    platform_device_register_simple("fsl-mscan", i, r, 2);
+		if (IS_ERR(pdev[i])) {
+			ret = PTR_ERR(pdev[i]);
+			goto err;
+		}
+
+		pdata.clock_src = MSCAN_CLKSRC_BUS;
+		pdata.cpu_type = type;
+		pdata.clock_frq = fsl_find_ipb_freq(np);
+
+		ret = platform_device_add_data(pdev[i], &pdata, sizeof(pdata));
+		if (ret)
+			goto err;
+	}
+	return 0;
+      err:
+	return ret;
+}
+#else
+#define mscan_of_to_pdev()
+#endif
+
+int __init mpc52xx_can_init(void)
+{
+	mpc52xx_of_to_pdev();
+	printk(KERN_INFO "%s initializing\n", mpc52xx_can_driver.driver.name);
+	return platform_driver_register(&mpc52xx_can_driver);
+}
+
+void __exit mpc52xx_can_exit(void)
+{
+	int i;
+	platform_driver_unregister(&mpc52xx_can_driver);
+	for (i = 0; i < PDEV_MAX; i++)
+		platform_device_unregister(pdev[i]);
+	printk(KERN_INFO "%s unloaded\n", mpc52xx_can_driver.driver.name);
+}
+
+module_init(mpc52xx_can_init);
+module_exit(mpc52xx_can_exit);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_DESCRIPTION("Freescale MPC5200 CAN driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/mscan/mscan.c b/drivers/net/can/mscan/mscan.c
new file mode 100644
index 0000000..ce223db
--- /dev/null
+++ b/drivers/net/can/mscan/mscan.c
@@ -0,0 +1,704 @@
+/*
+ * mscan.c
+ *
+ * DESCRIPTION:
+ *  CAN bus driver for the alone generic (as possible as) MSCAN controller.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2005-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/can.h>
+#include <linux/list.h>
+#include <asm/io.h>
+#include <asm/of_platform.h>
+
+#include <linux/can/dev.h>
+#include <linux/can/error.h>
+#include "mscan.h"
+
+#include <linux/can/version.h>	/* for RCSID. Removed by mkpatch script */
+RCSID("$Id$");
+
+#define MSCAN_NORMAL_MODE	0
+#define MSCAN_SLEEP_MODE	MSCAN_SLPRQ
+#define MSCAN_INIT_MODE		(MSCAN_INITRQ | MSCAN_SLPRQ)
+#define MSCAN_POWEROFF_MODE	(MSCAN_CSWAI | MSCAN_SLPRQ)
+#define MSCAN_SET_MODE_RETRIES	255
+
+
+#define BTR0_BRP_MASK		0x3f
+#define BTR0_SJW_SHIFT		6
+#define BTR0_SJW_MASK		(0x3 << BTR0_SJW_SHIFT)
+
+#define BTR1_TSEG1_MASK 	0xf
+#define BTR1_TSEG2_SHIFT	4
+#define BTR1_TSEG2_MASK 	(0x7 << BTR1_TSEG2_SHIFT)
+#define BTR1_SAM_SHIFT  	7
+
+#define BTR0_SET_BRP(brp)	(((brp) - 1) & BTR0_BRP_MASK)
+#define BTR0_SET_SJW(sjw)	((((sjw) - 1) << BTR0_SJW_SHIFT) & \
+				 BTR0_SJW_MASK)
+
+#define BTR1_SET_TSEG1(tseg1)	(((tseg1) - 1) &  BTR1_TSEG1_MASK)
+#define BTR1_SET_TSEG2(tseg2)	((((tseg2) - 1) << BTR1_TSEG2_SHIFT) & \
+				 BTR1_TSEG2_MASK)
+#define BTR1_SET_SAM(sam)	(((sam) & 1) << BTR1_SAM_SHIFT)
+
+struct mscan_state {
+	u8 mode;
+	u8 canrier;
+	u8 cantier;
+};
+
+#define TX_QUEUE_SIZE	3
+
+typedef struct {
+	struct list_head list;
+	u8 mask;
+} tx_queue_entry_t;
+
+struct mscan_priv {
+	struct can_priv can;
+	struct napi_struct napi;
+	struct net_device *netdev;
+	volatile unsigned long flags;
+	u8 shadow_statflg;
+	u8 shadow_canrier;
+	u8 cur_pri;
+	u8 tx_active;
+
+	struct list_head tx_head;
+	tx_queue_entry_t tx_queue[TX_QUEUE_SIZE];
+};
+
+#define F_RX_PROGRESS	0
+#define F_TX_PROGRESS	1
+#define F_TX_WAIT_ALL	2
+
+static int mscan_set_mode(struct net_device *dev, u8 mode)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	int i;
+	u8 canctl1;
+
+	if (mode != MSCAN_NORMAL_MODE) {
+		canctl1 = in_8(&regs->canctl1);
+		if ((mode & MSCAN_SLPRQ) && (canctl1 & MSCAN_SLPAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_SLPRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_SLPAK)
+					break;
+				udelay(100);
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_INITRQ)
+		    && (canctl1 & MSCAN_INITAK) == 0) {
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_INITRQ);
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				if (in_8(&regs->canctl1) & MSCAN_INITAK)
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+
+		if (!ret && (mode & MSCAN_CSWAI))
+			out_8(&regs->canctl0,
+			      in_8(&regs->canctl0) | MSCAN_CSWAI);
+
+	} else {
+		canctl1 = in_8(&regs->canctl1);
+		if (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {
+			out_8(&regs->canctl0, in_8(&regs->canctl0) &
+			      ~(MSCAN_SLPRQ | MSCAN_INITRQ));
+			for (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {
+				canctl1 = in_8(&regs->canctl1);
+				if (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))
+					break;
+			}
+			if (i >= MSCAN_SET_MODE_RETRIES)
+				ret = -ENODEV;
+		}
+	}
+	return ret;
+}
+
+static void mscan_push_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	state->mode = in_8(&regs->canctl0) & (MSCAN_SLPRQ | MSCAN_INITRQ |
+					      MSCAN_CSWAI);
+	state->canrier = in_8(&regs->canrier);
+	state->cantier = in_8(&regs->cantier);
+}
+
+static int mscan_pop_state(struct net_device *dev, struct mscan_state *state)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	int ret;
+	ret = mscan_set_mode(dev, state->mode);
+	if (!ret) {
+		out_8(&regs->canrier, state->canrier);
+		out_8(&regs->cantier, state->cantier);
+	}
+	return ret;
+}
+
+static int mscan_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct can_frame *frame = (struct can_frame *)skb->data;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+
+	int i, rtr, buf_id;
+	u32 can_id;
+
+	if (frame->can_dlc > 8)
+		return -EINVAL;
+
+	dev_dbg(ND2D(dev), "%s\n", __func__);
+	out_8(&regs->cantier, 0);
+
+	i = ~priv->tx_active & MSCAN_TXE;
+	buf_id = ffs(i) - 1;
+	switch (hweight8(i)) {
+	case 0:
+		netif_stop_queue(dev);
+		dev_err(ND2D(dev), "BUG! Tx Ring full when queue awake!\n");
+		return NETDEV_TX_BUSY;
+	case 1:
+		/* if buf_id < 3, then current frame will be send out of order,
+		   since  buffer with lower id have higher priority (hell..) */
+		if (buf_id < 3)
+			priv->cur_pri++;
+		if (priv->cur_pri == 0xff)
+			set_bit(F_TX_WAIT_ALL, &priv->flags);
+		netif_stop_queue(dev);
+	case 2:
+		set_bit(F_TX_PROGRESS, &priv->flags);
+	}
+	out_8(&regs->cantbsel, i);
+
+	rtr = frame->can_id & CAN_RTR_FLAG;
+
+	if (frame->can_id & CAN_EFF_FLAG) {
+		dev_dbg(ND2D(dev), "sending extended frame\n");
+
+		can_id = (frame->can_id & CAN_EFF_MASK) << 1;
+		if (rtr)
+			can_id |= 1;
+		out_be16(&regs->tx.idr3_2, can_id);
+
+		can_id >>= 16;
+		can_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0) | (3 << 3);
+	} else {
+		dev_dbg(ND2D(dev), "sending standard frame\n");
+		can_id = (frame->can_id & CAN_SFF_MASK) << 5;
+		if (rtr)
+			can_id |= 1 << 4;
+	}
+	out_be16(&regs->tx.idr1_0, can_id);
+
+	if (!rtr) {
+		volatile void __iomem *data = &regs->tx.dsr1_0;
+		u16 *payload = (u16 *) frame->data;
+		/*Its safe to write into dsr[dlc+1] */
+		for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+			out_be16(data, *payload++);
+			data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+		}
+	}
+
+	out_8(&regs->tx.dlr, frame->can_dlc);
+	out_8(&regs->tx.tbpr, priv->cur_pri);
+
+	/* Start transmission. */
+	out_8(&regs->cantflg, 1 << buf_id);
+
+	if (!test_bit(F_TX_PROGRESS, &priv->flags))
+		dev->trans_start = jiffies;
+
+	list_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);
+
+	kfree_skb(skb);
+
+	/* Enable interrupt. */
+	priv->tx_active |= 1 << buf_id;
+	out_8(&regs->cantier, priv->tx_active);
+
+	return NETDEV_TX_OK;
+}
+
+static void mscan_tx_timeout(struct net_device *dev)
+{
+	struct sk_buff *skb;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct can_frame *frame;
+	u8 mask;
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	out_8(&regs->cantier, 0);
+
+	mask = list_entry(priv->tx_head.next, tx_queue_entry_t, list)->mask;
+	dev->trans_start = jiffies;
+	out_8(&regs->cantarq, mask);
+	out_8(&regs->cantier, priv->tx_active);
+
+	skb = dev_alloc_skb(sizeof(struct can_frame));
+	if (!skb) {
+		if (printk_ratelimit())
+			dev_notice(ND2D(dev), "TIMEOUT packet dropped\n");
+		return;
+	}
+	frame = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
+
+	frame->can_id = CAN_ERR_FLAG | CAN_ERR_TX_TIMEOUT;
+	frame->can_dlc = CAN_ERR_DLC;
+
+	skb->dev = dev;
+	skb->protocol = __constant_htons(ETH_P_CAN);
+	skb->pkt_type = PACKET_BROADCAST;
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+	netif_rx(skb);
+
+}
+
+static can_state_t state_map[] = {
+	CAN_STATE_ACTIVE,
+	CAN_STATE_BUS_WARNING,
+	CAN_STATE_BUS_PASSIVE,
+	CAN_STATE_BUS_OFF
+};
+
+static inline int check_set_state(struct net_device *dev, u8 canrflg)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	can_state_t state;
+	int ret = 0;
+
+	if (!(canrflg & MSCAN_CSCIF) || priv->can.state > CAN_STATE_BUS_OFF)
+		return 0;
+
+	state =
+	    state_map[max(MSCAN_STATE_RX(canrflg), MSCAN_STATE_TX(canrflg))];
+	if (priv->can.state < state)
+		ret = 1;
+	if (state == CAN_STATE_BUS_OFF)
+		netif_carrier_off(dev);
+	else if (priv->can.state == CAN_STATE_BUS_OFF
+		 && state != CAN_STATE_BUS_OFF)
+		netif_carrier_on(dev);
+	priv->can.state = state;
+	return ret;
+}
+
+int mscan_rx_poll(struct napi_struct *napi, int budget)
+{
+	struct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);
+	struct net_device *dev = priv->netdev;
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int npackets = 0, quota = budget;
+	int ret = 1;
+	struct sk_buff *skb;
+	struct can_frame *frame;
+	u32 can_id;
+	u8 canrflg;
+	int i;
+
+	while (npackets < quota && ((canrflg = in_8(&regs->canrflg)) &
+				    (MSCAN_RXF | MSCAN_ERR_IF))) {
+		skb = dev_alloc_skb(sizeof(struct can_frame));
+		if (!skb) {
+			if (printk_ratelimit())
+				dev_notice(ND2D(dev), "packet dropped\n");
+			out_8(&regs->canrflg, canrflg);
+			continue;
+		}
+
+		frame = (struct can_frame *)skb_put(skb,
+						    sizeof(struct can_frame));
+
+		if (canrflg & MSCAN_RXF) {
+			can_id = in_be16(&regs->rx.idr1_0);
+			if (can_id & (1 << 3)) {
+				frame->can_id = CAN_EFF_FLAG;
+				can_id = ((can_id << 16) |
+					  in_be16(&regs->rx.idr3_2));
+				can_id = ((can_id & 0xffe00000) |
+					  ((can_id & 0x7ffff) << 2)) >> 2;
+			} else {
+				can_id >>= 4;
+				frame->can_id = 0;
+			}
+
+			frame->can_id |= can_id >> 1;
+			if (can_id & 1)
+				frame->can_id |= CAN_RTR_FLAG;
+			frame->can_dlc = in_8(&regs->rx.dlr) & 0xf;
+
+			if (!(frame->can_id & CAN_RTR_FLAG)) {
+				volatile void __iomem *data = &regs->rx.dsr1_0;
+				u16 *payload = (u16 *) frame->data;
+				for (i = 0; i < (frame->can_dlc + 1) / 2; i++) {
+					*payload++ = in_be16(data);
+					data += 2 + _MSCAN_RESERVED_DSR_SIZE;
+				}
+			}
+
+			dev_dbg(ND2D(dev),
+				"received pkt: id: %u dlc: %u data: ",
+				frame->can_id, frame->can_dlc);
+#ifdef DEBUG
+			for (i = 0;
+			     i < frame->can_dlc; i++)
+				printk(KERN_INFO "%02x ", frame->data[i]);
+			printk("\n");
+#endif
+
+			out_8(&regs->canrflg, MSCAN_RXF);
+			dev->last_rx = jiffies;
+		} else if (canrflg & MSCAN_ERR_IF) {
+			frame->can_id = CAN_ERR_FLAG;
+
+			if (canrflg & MSCAN_OVRIF) {
+				frame->can_id |= CAN_ERR_CRTL;
+				frame->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+			} else
+				frame->data[1] = 0;
+
+			if (check_set_state(dev, canrflg)) {
+				frame->can_id |= CAN_ERR_CRTL;
+				switch (priv->can.state) {
+				case CAN_STATE_BUS_WARNING:
+					if ((priv->shadow_statflg &
+					     MSCAN_RSTAT_MSK) <
+					    (canrflg & MSCAN_RSTAT_MSK))
+						frame->data[1] |=
+						    CAN_ERR_CRTL_RX_WARNING;
+
+					if ((priv->shadow_statflg &
+					     MSCAN_TSTAT_MSK) <
+					    (canrflg & MSCAN_TSTAT_MSK))
+						frame->data[1] |=
+							CAN_ERR_CRTL_TX_WARNING;
+					break;
+				case CAN_STATE_BUS_PASSIVE:
+					frame->data[1] |=
+					    CAN_ERR_CRTL_RX_PASSIVE;
+					break;
+				case CAN_STATE_BUS_OFF:
+					frame->can_id |= CAN_ERR_BUSOFF;
+					frame->can_id &= ~CAN_ERR_CRTL;
+					break;
+				}
+			}
+			priv->shadow_statflg = canrflg & MSCAN_STAT_MSK;
+			frame->can_dlc = CAN_ERR_DLC;
+			out_8(&regs->canrflg, MSCAN_ERR_IF);
+		}
+
+		npackets++;
+		skb->dev = dev;
+		skb->protocol = __constant_htons(ETH_P_CAN);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(skb);
+	}
+
+	if (!(in_8(&regs->canrflg) & (MSCAN_RXF | MSCAN_ERR_IF))) {
+		netif_rx_complete(dev, napi);
+		clear_bit(F_RX_PROGRESS, &priv->flags);
+		out_8(&regs->canrier,
+		      in_8(&regs->canrier) | MSCAN_ERR_IF | MSCAN_RXFIE);
+		ret = 0;
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+static irqreturn_t mscan_isr(int irq, void *dev_id, struct pt_regs *r)
+#else
+static irqreturn_t mscan_isr(int irq, void *dev_id)
+#endif
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	u8 cantflg, canrflg;
+	irqreturn_t ret = IRQ_NONE;
+
+	if (in_8(&regs->cantier) & MSCAN_TXE) {
+		struct list_head *tmp, *pos;
+
+		cantflg = in_8(&regs->cantflg) & MSCAN_TXE;
+
+		list_for_each_safe(pos, tmp, &priv->tx_head) {
+			tx_queue_entry_t *entry =
+			    list_entry(pos, tx_queue_entry_t, list);
+			u8 mask = entry->mask;
+
+			if (!(cantflg & mask))
+				continue;
+
+			if (in_8(&regs->cantaak) & mask)
+				priv->can.can_stats.error_warning++;
+			else
+				out_8(&regs->cantbsel, mask);
+			priv->tx_active &= ~mask;
+			list_del(pos);
+		}
+
+		if (list_empty(&priv->tx_head)) {
+			clear_bit(F_TX_WAIT_ALL, &priv->flags);
+			clear_bit(F_TX_PROGRESS, &priv->flags);
+			priv->cur_pri = 0;
+		} else
+			dev->trans_start = jiffies;
+
+		if (!test_bit(F_TX_WAIT_ALL, &priv->flags))
+			netif_wake_queue(dev);
+
+		out_8(&regs->cantier, priv->tx_active);
+		ret = IRQ_HANDLED;
+	}
+
+	if ((((canrflg = in_8(&regs->canrflg)) & ~MSCAN_STAT_MSK)) &&
+	    !test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {
+		if (check_set_state(dev, canrflg)) {
+			out_8(&regs->canrflg, MSCAN_CSCIF);
+			ret = IRQ_HANDLED;
+		}
+
+		if (canrflg & ~MSCAN_STAT_MSK) {
+			priv->shadow_canrier = in_8(&regs->canrier);
+			out_8(&regs->canrier, 0);
+			clear_bit(NAPI_STATE_SCHED,
+					  &priv->napi.state);
+			netif_rx_schedule(dev, &priv->napi);
+			ret = IRQ_HANDLED;
+		} else
+			clear_bit(F_RX_PROGRESS, &priv->flags);
+	}
+
+	return ret;
+}
+
+static int mscan_do_set_mode(struct net_device *dev, can_mode_t mode)
+{
+	switch (mode) {
+	case CAN_MODE_SLEEP:
+	case CAN_MODE_STOP:
+		netif_stop_queue(dev);
+		mscan_set_mode(dev,
+			       (mode ==
+				CAN_MODE_STOP) ? MSCAN_INIT_MODE :
+			       MSCAN_SLEEP_MODE);
+		break;
+	case CAN_MODE_START:
+		printk(KERN_INFO "%s: CAN_MODE_START requested\n", __func__);
+		mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+		netif_wake_queue(dev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+static int mscan_do_set_bit_time(struct net_device *dev,
+				 struct can_bittime *bt)
+{
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	int ret = 0;
+	u8 reg;
+	struct mscan_state state;
+
+	if (bt->type != CAN_BITTIME_STD)
+		return -EINVAL;
+
+	spin_lock_irq(&priv->can.irq_lock);
+
+	mscan_push_state(dev, &state);
+	ret = mscan_set_mode(dev, MSCAN_INIT_MODE);
+	if (!ret) {
+		reg = BTR0_SET_BRP(bt->std.brp) | BTR0_SET_SJW(bt->std.sjw);
+		out_8(&regs->canbtr0, reg);
+
+		reg = (BTR1_SET_TSEG1(bt->std.prop_seg + bt->std.phase_seg1) |
+		       BTR1_SET_TSEG2(bt->std.phase_seg2) |
+		       BTR1_SET_SAM(bt->std.sam));
+		out_8(&regs->canbtr1, reg);
+
+		ret = mscan_pop_state(dev, &state);
+	}
+
+	spin_unlock_irq(&priv->can.irq_lock);
+	return ret;
+}
+
+static int mscan_open(struct net_device *dev)
+{
+	int ret;
+	struct mscan_priv *priv = netdev_priv(dev);
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+	ret = request_irq(dev->irq, mscan_isr, SA_SHIRQ, dev->name, dev);
+#else
+	ret = request_irq(dev->irq, mscan_isr, IRQF_SHARED, dev->name, dev);
+#endif
+
+	if (ret  < 0) {
+		printk(KERN_ERR "%s - failed to attach interrupt\n",
+		       dev->name);
+		return ret;
+	}
+
+	INIT_LIST_HEAD(&priv->tx_head);
+	/* acceptance mask/acceptance code (accept everything) */
+	out_be16(&regs->canidar1_0, 0);
+	out_be16(&regs->canidar3_2, 0);
+	out_be16(&regs->canidar5_4, 0);
+	out_be16(&regs->canidar7_6, 0);
+
+	out_be16(&regs->canidmr1_0, 0xffff);
+	out_be16(&regs->canidmr3_2, 0xffff);
+	out_be16(&regs->canidmr5_4, 0xffff);
+	out_be16(&regs->canidmr7_6, 0xffff);
+	/* Two 32 bit Acceptance Filters */
+	out_8(&regs->canidac, MSCAN_AF_32BIT);
+
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_LISTEN);
+	mscan_set_mode(dev, MSCAN_NORMAL_MODE);
+
+	priv->shadow_statflg = in_8(&regs->canrflg) & MSCAN_STAT_MSK;
+	priv->cur_pri = 0;
+	priv->tx_active = 0;
+
+	out_8(&regs->cantier, 0);
+	/* Enable receive interrupts. */
+	out_8(&regs->canrier, MSCAN_OVRIE | MSCAN_RXFIE | MSCAN_CSCIE |
+	      MSCAN_RSTATE1 | MSCAN_RSTATE0 | MSCAN_TSTATE1 | MSCAN_TSTATE0);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int mscan_close(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+
+	netif_stop_queue(dev);
+
+	/* disable interrupts */
+	out_8(&regs->cantier, 0);
+	out_8(&regs->canrier, 0);
+	free_irq(dev->irq, dev);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	return 0;
+}
+
+int register_mscandev(struct net_device *dev, int clock_src)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	u8 ctl1;
+
+	ctl1 = in_8(&regs->canctl1);
+	if (clock_src)
+		ctl1 |= MSCAN_CLKSRC;
+	else
+		ctl1 &= ~MSCAN_CLKSRC;
+
+	ctl1 |= MSCAN_CANE;
+	out_8(&regs->canctl1, ctl1);
+	udelay(100);
+
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+
+	return register_netdev(dev);
+}
+EXPORT_SYMBOL(register_mscandev);
+
+void unregister_mscandev(struct net_device *dev)
+{
+	struct mscan_regs *regs = (struct mscan_regs *)dev->base_addr;
+	mscan_set_mode(dev, MSCAN_INIT_MODE);
+	out_8(&regs->canctl1, in_8(&regs->canctl1) & ~MSCAN_CANE);
+	unregister_netdev(dev);
+}
+EXPORT_SYMBOL(unregister_mscandev);
+
+struct net_device *alloc_mscandev(void)
+{
+	struct net_device *dev;
+	struct mscan_priv *priv;
+	int i;
+
+	dev = alloc_candev(sizeof(struct mscan_priv));
+	if (!dev)
+		return NULL;
+	priv = netdev_priv(dev);
+
+	priv->netdev = dev;
+	dev->watchdog_timeo = MSCAN_WATCHDOG_TIMEOUT;
+	dev->open = mscan_open;
+	dev->stop = mscan_close;
+	dev->hard_start_xmit = mscan_hard_start_xmit;
+	dev->tx_timeout = mscan_tx_timeout;
+
+	netif_napi_add(dev, &priv->napi, mscan_rx_poll, 8);
+
+	priv->can.do_set_bit_time = mscan_do_set_bit_time;
+	priv->can.do_set_mode = mscan_do_set_mode;
+
+	for (i = 0; i < TX_QUEUE_SIZE; i++)
+		priv->tx_queue[i].mask = 1 << i;
+
+	return dev;
+}
+EXPORT_SYMBOL(alloc_mscandev);
+
+MODULE_AUTHOR("Andrey Volkov <avolkov@varma-el.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("CAN port driver for a mscan based chips");
diff --git a/drivers/net/can/mscan/mscan.h b/drivers/net/can/mscan/mscan.h
new file mode 100644
index 0000000..16165af
--- /dev/null
+++ b/drivers/net/can/mscan/mscan.h
@@ -0,0 +1,253 @@
+/*
+ * DESCRIPTION:
+ *  Definitions of consts/structs to drive the Freescale MSCAN.
+ *
+ * AUTHOR:
+ *  Andrey Volkov <avolkov@varma-el.com>
+ *
+ * COPYRIGHT:
+ *  2004-2006, Varma Electronics Oy
+ *
+ * LICENCE:
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __MSCAN_H__
+#define __MSCAN_H__
+
+#include <linux/autoconf.h>
+#include <asm/types.h>
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MSCAN_RXFRM		0x80
+#define MSCAN_RXACT		0x40
+#define MSCAN_CSWAI		0x20
+#define MSCAN_SYNCH		0x10
+#define MSCAN_TIME		0x08
+#define MSCAN_WUPE		0x04
+#define MSCAN_SLPRQ		0x02
+#define MSCAN_INITRQ		0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MSCAN_CANE		0x80
+#define MSCAN_CLKSRC		0x40
+#define MSCAN_LOOPB		0x20
+#define MSCAN_LISTEN		0x10
+#define MSCAN_WUPM		0x04
+#define MSCAN_SLPAK		0x02
+#define MSCAN_INITAK		0x01
+
+#ifdef	CONFIG_PPC_MPC52xx
+#define MSCAN_CLKSRC_BUS	0
+#define MSCAN_CLKSRC_XTAL	MSCAN_CLKSRC
+#else
+#define MSCAN_CLKSRC_BUS	MSCAN_CLKSRC
+#define MSCAN_CLKSRC_XTAL	0
+#endif
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MSCAN_WUPIF		0x80
+#define MSCAN_CSCIF		0x40
+#define MSCAN_RSTAT1		0x20
+#define MSCAN_RSTAT0		0x10
+#define MSCAN_TSTAT1		0x08
+#define MSCAN_TSTAT0		0x04
+#define MSCAN_OVRIF		0x02
+#define MSCAN_RXF		0x01
+#define MSCAN_ERR_IF 		(MSCAN_OVRIF | MSCAN_CSCIF)
+#define MSCAN_RSTAT_MSK		(MSCAN_RSTAT1 | MSCAN_RSTAT0)
+#define MSCAN_TSTAT_MSK		(MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STAT_MSK		(MSCAN_RSTAT_MSK | MSCAN_TSTAT_MSK)
+
+#define MSCAN_STATE_BUS_OFF	(MSCAN_RSTAT1 | MSCAN_RSTAT0 | \
+				 MSCAN_TSTAT1 | MSCAN_TSTAT0)
+#define MSCAN_STATE_TX(canrflg)	(((canrflg)&MSCAN_TSTAT_MSK)>>2)
+#define MSCAN_STATE_RX(canrflg)	(((canrflg)&MSCAN_RSTAT_MSK)>>4)
+#define MSCAN_STATE_ACTIVE	0
+#define MSCAN_STATE_WARNING	1
+#define MSCAN_STATE_PASSIVE	2
+#define MSCAN_STATE_BUSOFF	3
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MSCAN_WUPIE		0x80
+#define MSCAN_CSCIE		0x40
+#define MSCAN_RSTATE1		0x20
+#define MSCAN_RSTATE0		0x10
+#define MSCAN_TSTATE1		0x08
+#define MSCAN_TSTATE0		0x04
+#define MSCAN_OVRIE		0x02
+#define MSCAN_RXFIE		0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MSCAN_TXE2		0x04
+#define MSCAN_TXE1		0x02
+#define MSCAN_TXE0		0x01
+#define MSCAN_TXE		(MSCAN_TXE2 | MSCAN_TXE1 | MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MSCAN_TXIE2		0x04
+#define MSCAN_TXIE1		0x02
+#define MSCAN_TXIE0		0x01
+#define MSCAN_TXIE		(MSCAN_TXIE2 | MSCAN_TXIE1 | MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MSCAN_ABTRQ2		0x04
+#define MSCAN_ABTRQ1		0x02
+#define MSCAN_ABTRQ0		0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MSCAN_ABTAK2		0x04
+#define MSCAN_ABTAK1		0x02
+#define MSCAN_ABTAK0		0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MSCAN_TX2		0x04
+#define MSCAN_TX1		0x02
+#define MSCAN_TX0		0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MSCAN_IDAM1		0x20
+#define MSCAN_IDAM0		0x10
+#define MSCAN_IDHIT2		0x04
+#define MSCAN_IDHIT1		0x02
+#define MSCAN_IDHIT0		0x01
+
+#define MSCAN_AF_32BIT		0x00
+#define MSCAN_AF_16BIT		MSCAN_IDAM0
+#define MSCAN_AF_8BIT		MSCAN_IDAM1
+#define MSCAN_AF_CLOSED		(MSCAN_IDAM0|MSCAN_IDAM1)
+#define MSCAN_AF_MASK		(~(MSCAN_IDAM0|MSCAN_IDAM1))
+
+/* MSCAN Miscellaneous Register (CANMISC) bits */
+#define MSCAN_BOHOLD		0x01
+
+#if defined(CONFIG_PPC_MPC52xx) || defined(CONFIG_PPC_MPC5121)
+#define _MSCAN_RESERVED_(n, num)	u8	_res##n[num]
+#define _MSCAN_RESERVED_DSR_SIZE	2
+#else
+#define _MSCAN_RESERVED_(n, num)
+#define _MSCAN_RESERVED_DSR_SIZE	0
+#endif
+
+/* Structure of the hardware registers */
+struct mscan_regs {
+	/* (see doco S12MSCANV3/D)		MPC5200	     MSCAN */
+	u8 canctl0;				/* + 0x00     0x00 */
+	u8 canctl1;				/* + 0x01     0x01 */
+	_MSCAN_RESERVED_(1, 2);			/* + 0x02          */
+	u8 canbtr0;				/* + 0x04     0x02 */
+	u8 canbtr1;				/* + 0x05     0x03 */
+	_MSCAN_RESERVED_(2, 2);			/* + 0x06          */
+	u8 canrflg;				/* + 0x08     0x04 */
+	u8 canrier;				/* + 0x09     0x05 */
+	_MSCAN_RESERVED_(3, 2);			/* + 0x0a          */
+	u8 cantflg;				/* + 0x0c     0x06 */
+	u8 cantier;				/* + 0x0d     0x07 */
+	_MSCAN_RESERVED_(4, 2);			/* + 0x0e          */
+	u8 cantarq;				/* + 0x10     0x08 */
+	u8 cantaak;				/* + 0x11     0x09 */
+	_MSCAN_RESERVED_(5, 2);			/* + 0x12          */
+	u8 cantbsel;				/* + 0x14     0x0a */
+	u8 canidac;				/* + 0x15     0x0b */
+	u8 reserved;				/* + 0x16     0x0c */
+	_MSCAN_RESERVED_(6, 5);			/* + 0x17          */
+#ifndef CONFIG_PPC_MPC52xx
+	u8 canmisc;				/*            0x0d */
+#endif
+	u8 canrxerr;				/* + 0x1c     0x0e */
+	u8 cantxerr;				/* + 0x1d     0x0f */
+	_MSCAN_RESERVED_(7, 2);			/* + 0x1e          */
+	u16 canidar1_0;				/* + 0x20     0x10 */
+	_MSCAN_RESERVED_(8, 2);			/* + 0x22          */
+	u16 canidar3_2;				/* + 0x24     0x12 */
+	_MSCAN_RESERVED_(9, 2);			/* + 0x26          */
+	u16 canidmr1_0;				/* + 0x28     0x14 */
+	_MSCAN_RESERVED_(10, 2);		/* + 0x2a          */
+	u16 canidmr3_2;				/* + 0x2c     0x16 */
+	_MSCAN_RESERVED_(11, 2);		/* + 0x2e          */
+	u16 canidar5_4;				/* + 0x30     0x18 */
+	_MSCAN_RESERVED_(12, 2);		/* + 0x32          */
+	u16 canidar7_6;				/* + 0x34     0x1a */
+	_MSCAN_RESERVED_(13, 2);		/* + 0x36          */
+	u16 canidmr5_4;				/* + 0x38     0x1c */
+	_MSCAN_RESERVED_(14, 2);		/* + 0x3a          */
+	u16 canidmr7_6;				/* + 0x3c     0x1e */
+	_MSCAN_RESERVED_(15, 2);		/* + 0x3e          */
+	struct {
+		u16 idr1_0;			/* + 0x40     0x20 */
+		 _MSCAN_RESERVED_(16, 2);	/* + 0x42          */
+		u16 idr3_2;			/* + 0x44     0x22 */
+		 _MSCAN_RESERVED_(17, 2);	/* + 0x46          */
+		u16 dsr1_0;			/* + 0x48     0x24 */
+		 _MSCAN_RESERVED_(18, 2);	/* + 0x4a          */
+		u16 dsr3_2;			/* + 0x4c     0x26 */
+		 _MSCAN_RESERVED_(19, 2);	/* + 0x4e          */
+		u16 dsr5_4;			/* + 0x50     0x28 */
+		 _MSCAN_RESERVED_(20, 2);	/* + 0x52          */
+		u16 dsr7_6;			/* + 0x54     0x2a */
+		 _MSCAN_RESERVED_(21, 2);	/* + 0x56          */
+		u8 dlr;				/* + 0x58     0x2c */
+		 u8:8;				/* + 0x59     0x2d */
+		 _MSCAN_RESERVED_(22, 2);	/* + 0x5a          */
+		u16 time;			/* + 0x5c     0x2e */
+	} rx;
+	 _MSCAN_RESERVED_(23, 2);		/* + 0x5e          */
+	struct {
+		u16 idr1_0;			/* + 0x60     0x30 */
+		 _MSCAN_RESERVED_(24, 2);	/* + 0x62          */
+		u16 idr3_2;			/* + 0x64     0x32 */
+		 _MSCAN_RESERVED_(25, 2);	/* + 0x66          */
+		u16 dsr1_0;			/* + 0x68     0x34 */
+		 _MSCAN_RESERVED_(26, 2);	/* + 0x6a          */
+		u16 dsr3_2;			/* + 0x6c     0x36 */
+		 _MSCAN_RESERVED_(27, 2);	/* + 0x6e          */
+		u16 dsr5_4;			/* + 0x70     0x38 */
+		 _MSCAN_RESERVED_(28, 2);	/* + 0x72          */
+		u16 dsr7_6;			/* + 0x74     0x3a */
+		 _MSCAN_RESERVED_(29, 2);	/* + 0x76          */
+		u8 dlr;				/* + 0x78     0x3c */
+		u8 tbpr;			/* + 0x79     0x3d */
+		 _MSCAN_RESERVED_(30, 2);	/* + 0x7a          */
+		u16 time;			/* + 0x7c     0x3e */
+	} tx;
+	 _MSCAN_RESERVED_(31, 2);		/* + 0x7e          */
+} __attribute__ ((packed));
+
+#undef _MSCAN_RESERVED_
+#define MSCAN_REGION 	sizeof(struct mscan)
+
+#define MSCAN_WATCHDOG_TIMEOUT	((500*HZ)/1000)
+
+enum {
+	MPC52xx_MSCAN,
+	MPC512x_MSCAN,
+};
+
+struct mscan_platform_data {
+	u8 clock_src;		/* MSCAN_CLKSRC_BUS or MSCAN_CLKSRC_XTAL */
+	u32 clock_frq;		/* can ref. clock, in Hz */
+	u8 cpu_type;		/* MPC52xx_MSCAN or MPC512x_MSCAN */
+};
+
+struct net_device *alloc_mscandev(void);
+/* @clock_src:
+	1 = The MSCAN clock source is the onchip Bus Clock.
+	0 = The MSCAN clock source is the chip Oscillator Clock.
+*/
+extern int register_mscandev(struct net_device *dev, int clock_src);
+extern void unregister_mscandev(struct net_device *dev);
+
+#endif				/* __MSCAN_H__ */
diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h
new file mode 100644
index 0000000..b3aad47
--- /dev/null
+++ b/include/linux/can/dev.h
@@ -0,0 +1,77 @@
+/*
+ * linux/can/dev.h
+ *
+ * Definitions for CAN controller network devices lib (work in progress)
+ *
+ * Author: Andrey Volkov <avolkov@varma-el.com>
+ * Copyright (c) 2006 Varma Electronics Oy
+ * 
+ * This file was received from Freescale Semiconductor, Inc. as a
+ * distribution of reference source to enable the MPC5121e ADS board.
+ * Freescale did not apply a comment header to this file, so Wind River
+ * has provided one. The fact that Freescale distributed these sources
+ * in the manner they did accompanying code with proper copyright and
+ * explicit license assignment, implies that this code is very probably
+ * distributed under GNU General Public GPLv2 or later licensing. 
+ * Wind River honors theimplied attribution and licensing.
+ *
+ */
+
+#ifndef CAN_DEVICE_H
+#define CAN_DEVICE_H
+
+#include <linux/version.h>
+#include <linux/can/error.h>
+#include <linux/can/ioctl.h>
+
+struct can_priv {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	struct net_device_stats net_stats;
+#endif
+	struct can_device_stats can_stats;
+
+	/* can-bus oscillator frequency, in Hz,
+	   BE CAREFUL! SOME CONTROLLERS (LIKE SJA1000)
+	   FOOLISH ABOUT THIS FRQ (for sja1000 as ex. this
+	   clock must be xtal clock divided by 2). */
+	u32	can_sys_clock;
+
+	/* by default max_brp is equal 64,
+	   but for a Freescale TouCAN, as ex., it can be 255*/
+	u32	max_brp;
+	/* For the mostly all controllers, max_sjw is equal 4, but
+	   some, hmm, CAN implementations hardwared it to 1 */
+	u8	max_sjw;
+
+	u32	baudrate;	/* in bauds */
+	struct can_bittime	bit_time;
+
+	spinlock_t irq_lock;
+	/* Please hold this lock when touching net_stats/can_stats*/
+	spinlock_t stats_lock;
+
+	can_state_t state;
+	can_mode_t  mode;
+	can_ctrlmode_t ctrlmode;
+
+	int (*do_set_bit_time)(struct net_device *dev, struct can_bittime *br);
+	int (*do_get_state)   (struct net_device *dev, can_state_t *state);
+	int (*do_set_mode)    (struct net_device *dev, can_mode_t mode);
+	int (*do_set_ctrlmode)(struct net_device *dev, can_ctrlmode_t ctrlmode);
+	int (*do_get_ctrlmode)(struct net_device *dev,
+				can_ctrlmode_t *ctrlmode);
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 21)
+#define ND2D(_ndev)		(_ndev->class_dev.dev)
+#else
+#define ND2D(_ndev)		(_ndev->dev.parent)
+#endif
+
+struct net_device *alloc_candev(int sizeof_priv);
+void free_candev(struct net_device *dev);
+
+int can_calc_bit_time(struct can_priv *can, u32 baudrate,
+		      struct can_bittime_std *bit_time);
+
+#endif /* CAN_DEVICE_H */
diff --git a/include/linux/can/ioctl.h b/include/linux/can/ioctl.h
new file mode 100644
index 0000000..4325b8c
--- /dev/null
+++ b/include/linux/can/ioctl.h
@@ -0,0 +1,159 @@
+/*
+ * linux/can/ioctl.h
+ *
+ * Definitions for CAN controller setup (work in progress)
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ * 
+ * This file was received from Freescale Semiconductor, Inc. as a
+ * distribution of reference source to enable the MPC5121e ADS board.
+ * Freescale did not apply a comment header to this file, so Wind River
+ * has provided one. The fact that Freescale distributed these sources
+ * in the manner they did accompanying code with proper copyright and
+ * explicit license assignment, implies that this code is very probably
+ * copyright 2008 Freescale Semiconductor Inc, and distributed under GNU
+ * General Public GPLv2 or later licensing. Wind River honors the
+ * implied attribution and licensing.
+ *
+ */
+
+#ifndef CAN_IOCTL_H
+#define CAN_IOCTL_H
+
+#include <linux/sockios.h>
+
+
+/* max. 16 private ioctls */
+
+#define SIOCSCANBAUDRATE	(SIOCDEVPRIVATE+0)
+#define SIOCGCANBAUDRATE	(SIOCDEVPRIVATE+1)
+
+#define SIOCSCANCUSTOMBITTIME   (SIOCDEVPRIVATE+2)
+#define SIOCGCANCUSTOMBITTIME   (SIOCDEVPRIVATE+3)
+
+#define SIOCSCANMODE		(SIOCDEVPRIVATE+4)
+#define SIOCGCANMODE		(SIOCDEVPRIVATE+5)
+
+#define SIOCSCANCTRLMODE	(SIOCDEVPRIVATE+6)
+#define SIOCGCANCTRLMODE	(SIOCDEVPRIVATE+7)
+
+#define SIOCSCANFILTER		(SIOCDEVPRIVATE+8)
+#define SIOCGCANFILTER		(SIOCDEVPRIVATE+9)
+
+#define SIOCGCANSTATE		(SIOCDEVPRIVATE+10)
+#define SIOCGCANSTATS		(SIOCDEVPRIVATE+11)
+
+#define SIOCSCANERRORCONFIG	(SIOCDEVPRIVATE+12)
+#define SIOCGCANERRORCONFIG	(SIOCDEVPRIVATE+13)
+
+/* parameters for ioctls */
+
+/* SIOC[SG]CANBAUDRATE */
+/* baudrate for CAN-controller in bits per second. */
+/* 0 = Scan for baudrate (Autobaud) */
+
+typedef __u32 can_baudrate_t;
+
+
+/* SIOC[SG]CANCUSTOMBITTIME */
+
+typedef enum CAN_BITTIME_TYPE {
+	CAN_BITTIME_STD,
+	CAN_BITTIME_BTR
+} can_bittime_type_t;
+
+/* TSEG1 of controllers usually is a sum of synch_seg (always 1),
+ * prop_seg and phase_seg1, TSEG2 = phase_seg2 */
+
+struct can_bittime_std {
+	__u32 brp;        /* baud rate prescaler */
+	__u8  prop_seg;   /* from 1 to 8 */
+	__u8  phase_seg1; /* from 1 to 8 */
+	__u8  phase_seg2; /* from 1 to 8 */
+	__u8  sjw:7;      /* from 1 to 4 */
+	__u8  sam:1;      /* 1 - enable triple sampling */
+};
+
+struct can_bittime_btr {
+	__u8  btr0;
+	__u8  btr1;
+};
+
+struct can_bittime {
+	can_bittime_type_t type;
+	union {
+		struct can_bittime_std std;
+		struct can_bittime_btr btr;
+	};
+};
+
+#define CAN_BAUDRATE_UNCONFIGURED	((__u32) 0xFFFFFFFFU)
+#define CAN_BAUDRATE_UNKNOWN		0
+
+/* SIOC[SG]CANMODE */
+
+typedef __u32 can_mode_t;
+
+#define CAN_MODE_STOP	0
+#define CAN_MODE_START	1
+#define CAN_MODE_SLEEP	2
+
+
+/* SIOC[SG]CANCTRLMODE */
+
+typedef __u32 can_ctrlmode_t;
+
+#define CAN_CTRLMODE_LOOPBACK   0x1
+#define CAN_CTRLMODE_LISTENONLY 0x2
+
+
+/* SIOCGCANFILTER */
+
+typedef __u32 can_filter_t;
+
+/* filter modes (may vary due to controller specific capabilities) */
+#define CAN_FILTER_CAPAB       0  /* get filter type capabilities (32 Bit value) */
+#define CAN_FILTER_MASK_VALUE  1  /* easy bit filter (see struct can_filter) */
+#define CAN_FILTER_SFF_BITMASK 2  /* bitfield with 2048 bit SFF filter */
+				  /* filters 3 - 31 currently undefined */
+
+#define CAN_FILTER_MAX         31 /* max. filter type value */
+
+
+/* SIOCGCANSTATE */
+
+typedef __u32 can_state_t;
+
+#define CAN_STATE_ACTIVE		0
+#define CAN_STATE_BUS_WARNING		1
+#define CAN_STATE_BUS_PASSIVE		2
+#define CAN_STATE_BUS_OFF		3
+#define CAN_STATE_SCANNING_BAUDRATE	4
+#define CAN_STATE_STOPPED		5
+#define CAN_STATE_SLEEPING		6
+
+
+/* SIOCGCANSTATS */
+
+struct can_device_stats {
+	int error_warning;
+	int data_overrun;
+	int wakeup;
+	int bus_error;
+	int error_passive;
+	int arbitration_lost;
+	int restarts;
+	int bus_error_at_init;
+};
+
+/* SIOC[SG]CANERRORCONFIG */
+
+typedef enum CAN_ERRCFG_TYPE {
+	CAN_ERRCFG_MASK,
+	CAN_ERRCFG_BUSERR,
+	CAN_ERRCFG_BUSOFF
+} can_errcfg_type_t;
+
+/* tbd */
+
+#endif /* CAN_IOCTL_H */
diff --git a/include/linux/can/version.h b/include/linux/can/version.h
new file mode 100644
index 0000000..1fd685d
--- /dev/null
+++ b/include/linux/can/version.h
@@ -0,0 +1,30 @@
+/*
+ * linux/can/version.h
+ *
+ * Version information for the CAN network layer implementation
+
+ * Author: Urs Thuermann   <urs.thuermann@volkswagen.de>
+ * Copyright (c) 2002-2007 Volkswagen Group Electronic Research
+ * All rights reserved.
+ *
+ * Send feedback to <socketcan-users@lists.berlios.de>
+ *
+ * This file was received from Freescale Semiconductor, Inc. as a
+ * distribution of reference source to enable the MPC5121e ADS board.
+ * Freescale did not apply a comment header to this file, so Wind River
+ * has provided one. The fact that Freescale distributed these sources
+ * in the manner they did accompanying code with proper copyright and
+ * explicit license assignment, implies that this code is very probably
+ * distributed under GNU General Public GPLv2 or later licensing. 
+ * Wind River honors the implied attribution and licensing.
+ */
+
+#ifndef CAN_VERSION_H
+#define CAN_VERSION_H
+
+#define RCSID(s) asm(".section .rodata.str1.1,\"aMS\",@progbits,1\n\t" \
+		     ".string \"" s "\"\n\t.previous\n")
+
+RCSID("$Id$");
+
+#endif /* CAN_VERSION_H */
-- 
1.6.3.1

