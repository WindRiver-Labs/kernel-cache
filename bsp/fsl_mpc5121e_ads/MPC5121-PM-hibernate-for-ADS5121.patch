From f58171959b36120df321ab9cc6c300a569189560 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:35 +0800
Subject: [PATCH 19/25] MPC5121 PM: hibernate for ADS5121

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

  Patches:
  linux-2.6.24.6-mpc5121-102-PM-hibernate-for-ADS5121.patch
  linux-2.6.24.6-mpc5121-117-PM-hibernate-for-ADS5121-part-2.patch

Changes needed for entering and exiting Hibernate mode of
MPC5121e on ADS5121.

All the little details to actually make
hibernate work.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/include/asm/mpc512x.h          |    9 +-
 arch/powerpc/platforms/512x/Kconfig         |   12 +-
 arch/powerpc/platforms/512x/Makefile        |    3 +
 arch/powerpc/platforms/512x/ads5121_pm.c    |  426 +++++++++++++++++++++++++++
 arch/powerpc/platforms/512x/ads5121_sleep.S |  380 ++++++++++++++++++++++++
 arch/powerpc/platforms/512x/mpc5121_ads.c   |    6 +-
 arch/powerpc/platforms/512x/mpc512x_pm.c    |   26 ++-
 arch/powerpc/platforms/512x/mpc512x_pm.h    |   23 ++-
 8 files changed, 874 insertions(+), 11 deletions(-)
 create mode 100644 arch/powerpc/platforms/512x/ads5121_pm.c
 create mode 100644 arch/powerpc/platforms/512x/ads5121_sleep.S

diff --git a/arch/powerpc/include/asm/mpc512x.h b/arch/powerpc/include/asm/mpc512x.h
index c1ca8aa..3bef879 100644
--- a/arch/powerpc/include/asm/mpc512x.h
+++ b/arch/powerpc/include/asm/mpc512x.h
@@ -118,16 +118,15 @@ extern int clk_enable(struct clk *clk);
 extern unsigned long clk_get_rate(struct clk *clk);
 
 #ifdef CONFIG_PM
+#ifdef CONFIG_MPC5121_ADS_HIB
+extern int __init ads5121_pm_init(void);
+#else
 extern int __init mpc512x_pm_init(void);
-extern void mpc512x_pmc_clrevent(void);
+#endif  /* CONFIG_MPC5121_ADS_HIB */
 extern int mpc512x_set_gpio_wakeup(unsigned int gpio_num,
 				   unsigned int detect_mode);
 #endif
 
-#ifdef CONFIG_MPC5121_PM_TEST
-extern void mpc512x_pm_test_setup(void);
-#endif
-
 #if defined(CONFIG_VIDEO_VIU) || defined(CONFIG_VIDEO_VIU_MODULE)
 extern void *fsl_diu_alloc(unsigned long size, unsigned long *phys);
 extern void fsl_diu_free(void *p, unsigned long size);
diff --git a/arch/powerpc/platforms/512x/Kconfig b/arch/powerpc/platforms/512x/Kconfig
index b0fe271..0012b37 100644
--- a/arch/powerpc/platforms/512x/Kconfig
+++ b/arch/powerpc/platforms/512x/Kconfig
@@ -42,9 +42,19 @@ config MPC5121_GENERIC
 	  Compatible boards include:  Protonic LVT base boards (ZANMCU
 	  and VICVT2).
 
+config MPC5121_ADS_HIB
+        bool "Hibernate Support for ADS5121"
+        depends on PM
+        ---help---
+          This option enables support for Hibernate on ADS5121 board
+	  (based on MPC5121e). The Hibernate is entered by writing
+	  "mem" to /sys/power/state, while Deep-Sleep mode is
+	  supported by writing "standby" to /sys/power/state.
+        default n
+
 config MPC5121_PM_TEST
 	bool "Lowlevel test for Freescale MPC5121E Power Management"
-	depends on PM && !CAN_MPC52XX
+	depends on PM
 	default n
 	help
 	  Say yes here to enable low level powermanagement test code.
diff --git a/arch/powerpc/platforms/512x/Makefile b/arch/powerpc/platforms/512x/Makefile
index 9c8227f..bb5e28a 100644
--- a/arch/powerpc/platforms/512x/Makefile
+++ b/arch/powerpc/platforms/512x/Makefile
@@ -9,4 +9,7 @@ obj-$(CONFIG_HWTIMER_HOOKS)	+= mpc512x_hwtimer.o
 obj-$(CONFIG_SPI)		+= mpc5121_spi.o
 obj-m				+= axe_dev.o
 obj-$(CONFIG_PM)		+= mpc512x_pm.o mpc512x.o
+ifeq ($(CONFIG_MPC5121_ADS_HIB),y)
+	obj-$(CONFIG_PM)		+= ads5121_pm.o ads5121_sleep.o
+endif
 obj-$(CONFIG_MPC5121_PM_TEST)	+= mpc512x_pm_test.o
diff --git a/arch/powerpc/platforms/512x/ads5121_pm.c b/arch/powerpc/platforms/512x/ads5121_pm.c
new file mode 100644
index 0000000..6095848
--- /dev/null
+++ b/arch/powerpc/platforms/512x/ads5121_pm.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Description:
+ * This file implements power management for the ADS5121
+ *
+ * This file is part of the Linux kernel
+ *
+ * This is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/suspend.h>
+#include <linux/of_platform.h>
+#include <asm/time.h>
+#include <asm/mpc512x.h>
+#include <asm/ipic.h>
+#include <asm/reg.h>
+#include <sysdev/fsl_soc.h>
+#include "mpc512x_pm.h"
+
+static struct mpc512x_pm ads5121_pm_data;
+static struct ads5121_hib_regs *ads5121_save_ptr;
+
+/* Array to store the SRAM contents */
+static char saved_sram[256 * 1024];
+static u32 ads5121_targeted_state = MPC512x_PM_NONE;
+static u32 ads5121_set_rtc_alarm(void);
+
+/*
+ * Name       : ads5121_save_regs
+ * Desc       : This function is called to store the Peripheral registers
+ *		which dont have drivers associated with it to store it back.
+ *
+ * Parameters : sram - Pointer of a Mapped Memory Location.
+ * Return     : void
+ */
+static int ads5121_save_regs(u32 *sram)
+{
+	u32 *reg_ptr;
+	ads5121_save_ptr = kmalloc(sizeof(struct ads5121_hib_regs), GFP_KERNEL);
+
+	if (!ads5121_save_ptr)
+		return -1;
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_IPIC_OFFSET);
+	_memcpy_fromio(ads5121_save_ptr->ipic_regs, reg_ptr,
+					sizeof(ads5121_save_ptr->ipic_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_CLK_OFFSET);
+	_memcpy_fromio(ads5121_save_ptr->clk_regs, reg_ptr,
+					sizeof(ads5121_save_ptr->clk_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_GPT_OFFSET);
+	_memcpy_fromio(ads5121_save_ptr->gpt_regs, reg_ptr,
+					sizeof(ads5121_save_ptr->gpt_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_GPIO_OFFSET);
+	_memcpy_fromio(ads5121_save_ptr->gpio_regs, reg_ptr,
+					sizeof(ads5121_save_ptr->gpio_regs));
+
+	memcpy(saved_sram, sram, sizeof(saved_sram));
+	return 0;
+}
+
+/*
+ * Name       : ads5121_restore_regs
+ * Desc       : This function is called to restore the Peripheral registers
+ *		which dont have drivers associated with it to restore it back.
+ *
+ * Parameters : sram - Pointer of a Mapped Memory Location.
+ * Return     : void
+ */
+static void ads5121_restore_regs(u32 *sram)
+{
+	u32 *reg_ptr;
+
+	/* Disable here explicitly, needs not enable since the interrrups
+	 * would be enabled latter on the suspend_enter function
+	 * in the kernel/power/main.c
+	 */
+	local_irq_disable();
+
+	memcpy(sram, saved_sram, sizeof(saved_sram));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+					MPC512x_IMMRBAR_IPIC_OFFSET);
+	_memcpy_toio(reg_ptr, ads5121_save_ptr->ipic_regs,
+					sizeof(ads5121_save_ptr->ipic_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+					MPC512x_IMMRBAR_CLK_OFFSET);
+	_memcpy_toio(reg_ptr, ads5121_save_ptr->clk_regs,
+					sizeof(ads5121_save_ptr->clk_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+					MPC512x_IMMRBAR_GPT_OFFSET);
+	_memcpy_toio(reg_ptr, ads5121_save_ptr->gpt_regs,
+					sizeof(ads5121_save_ptr->gpt_regs));
+
+	reg_ptr = (u32 *)((u32)ads5121_pm_data.mbar +
+					MPC512x_IMMRBAR_GPIO_OFFSET);
+	_memcpy_toio(reg_ptr, ads5121_save_ptr->gpio_regs,
+					sizeof(ads5121_save_ptr->gpio_regs));
+
+	kfree(ads5121_save_ptr);
+}
+
+/*
+ * Name       : ads5121_hibernate
+ * Desc       : This function is called to hibernate.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+/* Set the Target Time Register to a Future Value */
+static int ads5121_hibernate(void)
+{
+	 void ads5121_low_power(u32 *, u32 *, u32);
+	/*
+	 * 1. Save SRAM data to DDR
+	 * 2. Copy code to SRAM
+	 * 3. Configure RTC to hibernate with specified timeout.
+	 * 3. Jump to SRAM and put DDR in self refresh.
+	 */
+	u32 reg, ret;
+	u32 offset_minutes;
+
+	u32 *rtc = (u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_RTC_OFFSET);
+	u32 *sram = (u32 *) in_be32((u32 *)((u32)ads5121_pm_data.mbar +
+						MPC512x_IMMRBAR_SRAM_OFFSET));
+
+	/* IOREMAP the SRAM address obtained from MBAR */
+	sram = ioremap((u32)sram, (256 * 1024));
+
+	if (!sram) {
+		printk(KERN_ERR "Error mapping SRAM\n");
+		return -1;
+	}
+
+	ret = ads5121_save_regs(sram);
+	if (ret < 0)
+		return -1;
+
+	/* Set the BC6 bit in the Keep Alive Register to indicate Hibernate.
+	 * The Bit Value would retained across the power cycles.
+	 */
+	reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+	reg |= (1 << 8);
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], reg);
+
+
+	/* Set the DIS_HIB_MODE to 0 to enable the Hibernate mode
+	   out of MPC5121e.
+	 */
+	reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+	reg &= ~(1 << 7);
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], reg);
+
+
+	/* Store the Value of the TTR Register in RTC so as to restore */
+	ads5121_pm_data.rtc_targettime = in_be32(&rtc[MPC512x_RTC_TTR >> 2]);
+
+	offset_minutes = ads5121_set_rtc_alarm();
+
+	ads5121_low_power(sram, ads5121_pm_data.mbar, offset_minutes);
+
+	/* We are out of hibernate.. Lets restart jiffies */
+	wakeup_decrementer();
+
+	out_be32(&rtc[MPC512x_RTC_TTR >> 2], ads5121_pm_data.rtc_targettime);
+
+	/* Reset the BC6 bit after coming out of Hibernate */
+	reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+	reg &= ~(1 << 8);
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], reg);
+
+	/* Restore the Registers */
+	ads5121_restore_regs(sram);
+
+	/* IOUMAP this location only after the restore funcion. The restore
+	 * function would copy data back and then only release this memory.
+	 */
+	iounmap(sram);
+	return 0;
+}
+
+/*
+ * Name       : ads5121_set_rtc_wakeup
+ * Desc       : This function is called to enable the wakeup sources.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void ads5121_set_rtc_wakeup(struct mpc512x_pm *p_pmdata)
+{
+	u32 rtc_reg;
+	u32 *rtc;
+
+	if (!p_pmdata->mbar)
+		return;
+
+	rtc = (u32 *)((u32)p_pmdata->mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+	rtc_reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+
+	/* Set the Active LVL values for the Wake-up Sources[1-5] */
+	rtc_reg |= MPC512x_RTCKAR_WKUP_SRCLVL;
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], rtc_reg);
+
+	rtc_reg = in_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2]);
+	/* Enable the Wake-Up sources */
+	rtc_reg |= (MPC512x_RTCKAR_WKUP_SRCEN);
+	out_be32(&rtc[MPC512x_RTC_KEEPALIVE >> 2], rtc_reg);
+}
+
+static void ads5121_prepare_hibernate(struct mpc512x_pm *p_pmdata)
+{
+	/*
+	*  Enable the wakeup sources
+	*/
+	ads5121_set_rtc_wakeup(p_pmdata);
+}
+/*
+ * Name       : ads5121_pm_valid
+ * Desc       : Checks whether the PM state is valid
+ *
+ * Parameters : void
+ * Return     : 1 - Valid , 0 - Invalid
+ */
+static int ads5121_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		return 1;
+	default:
+		return 0;
+	}
+}
+
+/*
+ * Name       : ads5121_pm_settarget
+ * Desc       : Set the state to which the system is to enter.
+ *
+ * Parameters : void
+ * Return     : 0 - Success
+ */
+static int ads5121_pm_settarget(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		ads5121_targeted_state = MPC512x_PM_STANDBY;
+		break;
+	case PM_SUSPEND_MEM:
+		ads5121_targeted_state = MPC512x_PM_SUSP_MEM;
+		break;
+	default:
+		ads5121_targeted_state = MPC512x_PM_NONE;
+	}
+	return 0;
+}
+/*
+ * Name       : ads5121_pm_prepare
+ * Desc       : This function would map the IO regions. Also sets the DDRC and
+ * 		RTC regs for Deep Sleep Mode.
+ *
+ * Parameters : void
+ * Return     : int
+ *		ENOSYS
+ *
+ */
+static int ads5121_pm_prepare(void)
+{
+	mpc512x_pm_setup(&ads5121_pm_data);
+
+	switch (ads5121_targeted_state) {
+	case MPC512x_PM_STANDBY:
+		mpc512x_prepare_deepsleep(&ads5121_pm_data);
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		ads5121_prepare_hibernate(&ads5121_pm_data);
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Name       : ads5121_pm_enter
+ * Desc       : This function is exported to the Power Management Core. This
+ *	`	function is called with the state which the system should enter.
+ *
+ * Parameters : state 	- PM_SUSPEND_STANDBY
+			- PM_SUSPEND_MEM
+ * Return     : int
+ * 		-1 : FAILED
+ *		0  : SUCCESS
+ */
+static int ads5121_pm_enter(suspend_state_t state)
+{
+	if (!ads5121_pm_data.mbar) {
+		printk(KERN_ERR "Failed to enter PM mode as IO not mapped.\n");
+		return -1;
+	}
+	switch (ads5121_targeted_state) {
+
+	case MPC512x_PM_STANDBY:
+		mpc512x_enter_deepsleep(&ads5121_pm_data);
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		ads5121_hibernate();
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Name       : ads5121_pm_finish
+ * Desc       : This routine is called by the kernel on exit from
+ * 		power down modes. Restores the DDRC and RTC regs
+ * 		suspend to memory. Also releases allocated resources.
+ *
+ * Parameters : void
+ * Return     : void
+ */
+static void ads5121_pm_finish(void)
+{
+	switch (ads5121_targeted_state) {
+
+	case MPC512x_PM_STANDBY:
+		mpc512x_finish_deepsleep(&ads5121_pm_data);
+		break;
+	case MPC512x_PM_SUSP_MEM:
+		break;
+	}
+	ads5121_targeted_state = MPC512x_PM_NONE;
+
+	mpc512x_pm_release(&ads5121_pm_data);
+}
+
+static struct platform_suspend_ops ads5121_pm_ops = {
+	.valid		= ads5121_pm_valid,
+	.begin		= ads5121_pm_settarget,
+	.prepare	= ads5121_pm_prepare,
+	.enter		= ads5121_pm_enter,
+	.finish		= ads5121_pm_finish,
+};
+
+/*
+ * Name       : ads5121_pm_init
+ * Desc       : This function registers the platform_suspend_ops
+ * 		structure with the kernel.
+ *
+ * Parameters : void
+ * Return     : int
+ */
+int __init ads5121_pm_init(void)
+{
+	suspend_set_ops(&ads5121_pm_ops);
+	return 0;
+}
+
+/*
+ * Name       : ads5121_set_rtc_alarm
+ * Desc       : This function woul dbe called from the ads5121_hibernate funct-
+ *		which return the alarm offset in case it is set. If not then
+ *		it would retun 0xFFFFFFFF, which would be the MAX value for TTR.
+ *
+ * Parameters :
+ * Return     : u32 - Offset of Alarm Value with the Current Time.
+ */
+static u32 ads5121_set_rtc_alarm()
+{
+	u32 rtc_reg;
+	u32 *rtc;
+	u32 alm_hr, alm_min, cur_hr, cur_min;
+	u32 offset_minutes;
+
+	rtc = (u32 *)((u32)ads5121_pm_data.mbar + MPC512x_IMMRBAR_RTC_OFFSET);
+
+	rtc_reg = in_be32(&rtc[MPC512x_RTC_AIER >> 2]);
+
+	if (rtc_reg & MPC512x_RTCAIER_ALMEN_MASK) {
+		/*Alarm was set.. Let us wakeup in that time..*/
+		alm_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET)
+				& MPC512x_RTC_HR_MASK;
+		alm_min = (rtc_reg >> MPC512x_RTC_MIN_OFFSET)
+				& MPC512x_RTC_MIN_MASK;
+		rtc_reg = in_be32(&rtc[MPC512x_RTC_CTR >> 2]);
+		cur_min = (rtc_reg >> MPC512x_RTC_MIN_OFFSET)
+				& MPC512x_RTC_MIN_MASK;
+
+		if (in_be32(&rtc[MPC512x_RTC_TSR >> 2])
+				& MPC512x_RTCTSR_SLCHR_MASK) {
+			/* 12 Hour Format*/
+			cur_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET) & 0xF;
+			if (rtc_reg & MPC512x_RTC_CTR_PM)
+				cur_hr += 12;
+		} else
+			cur_hr = (rtc_reg >> MPC512x_RTC_HR_OFFSET)
+					& MPC512x_RTC_HR_MASK;
+		offset_minutes = (alm_hr * MPC512x_RTC_MINS_PER_HR + alm_min) -
+				(cur_hr * MPC512x_RTC_MINS_PER_HR + cur_min);
+
+		if (offset_minutes > 0)
+			offset_minutes = offset_minutes *
+					MPC512x_RTC_MINS_PER_HR;
+		else
+			offset_minutes = MPC512x_RTCTTR_MAXTIMEOUT;
+	} else
+		offset_minutes = MPC512x_RTCTTR_MAXTIMEOUT;
+
+	return offset_minutes;
+}
+
+
diff --git a/arch/powerpc/platforms/512x/ads5121_sleep.S b/arch/powerpc/platforms/512x/ads5121_sleep.S
new file mode 100644
index 0000000..2d3a270
--- /dev/null
+++ b/arch/powerpc/platforms/512x/ads5121_sleep.S
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Harith George <harith.george@wipro.com>
+ *
+ * Implements the Power management code to enter Suspend to RAM.
+ *
+ *    Original based on arch/powerpc/platforms/52xx/mpc52xx_sleep.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/reg.h>
+#include <asm/ppc_asm.h>
+#include <asm/processor.h>
+#include <asm/cache.h>
+
+/* Helpers... beware: r10 and r4 are overwritten */
+#define SAVE_SPRN(reg, addr)		\
+	mfspr	r10, SPRN_##reg;	\
+	stw	r10, ((addr)*4)(r4);	\
+	sync;
+
+#define LOAD_SPRN(reg, addr)		\
+	lwz	r10, ((addr)*4)(r4);	\
+	mtspr	SPRN_##reg, r10;	\
+	sync;				\
+	isync;
+
+/* Helpers for saving registers */
+#define SAVE_BAT(n, addr)		\
+	SAVE_SPRN(DBAT##n##L, addr);	\
+	SAVE_SPRN(DBAT##n##U, addr+1);	\
+	SAVE_SPRN(IBAT##n##L, addr+2);	\
+	SAVE_SPRN(IBAT##n##U, addr+3);
+
+#define SAVE_SR(n, addr)		\
+	mfsr	r10, n;			\
+	stw	r10, ((addr)*4)(r4);
+
+#define SAVE_4SR(n, addr)	\
+	SAVE_SR(n, addr);	\
+	SAVE_SR(n+1, addr+1);	\
+	SAVE_SR(n+2, addr+2);	\
+	SAVE_SR(n+3, addr+3);
+
+/* Helpers for restoring registers */
+#define LOAD_BAT(n, addr)		\
+	LOAD_SPRN(DBAT##n##L, addr);	\
+	LOAD_SPRN(DBAT##n##U, addr+1);	\
+	LOAD_SPRN(IBAT##n##L, addr+2);	\
+	LOAD_SPRN(IBAT##n##U, addr+3);
+
+#define LOAD_SR(n, addr)		\
+	lwz	r10, ((addr)*4)(r4);	\
+	mtsr	n, r10;
+
+#define LOAD_4SR(n, addr)	\
+	LOAD_SR(n, addr);	\
+	LOAD_SR(n+1, addr+1);	\
+	LOAD_SR(n+2, addr+2);	\
+	LOAD_SR(n+3, addr+3);
+
+#define MPC5121_DDRC_OFFSET		0x9000
+#define MPC512x_IMMRBAR_RTC_OFFSET 	0xA00
+#define MPC512x_DDRC_CMD0		0x3C00
+#define MPC512x_DDRC_CMD1		0x4420
+#define MPC512x_DDRC_CMD2		0x4210
+#define MPC512x_DDRC_CMD3		0x1410
+#define DDRC_SYSCONFIG_CMD		(1 << 28)
+
+	.data
+registers:
+	.space 0x5d*4
+
+	.text
+	.globl ads5121_low_power
+ads5121_low_power:
+	/* Low-power mode with help of Power CPLD */
+	mr	r7, r3	/* save SRAM va */
+	mr 	r8, r4	/* MBAR*/
+	mr	r9, r5	/* Offset_minutes for setting the alarm */
+	mflr    r0      /* store lr into r0 */
+
+	/* setup wakeup address for u-boot at physical location 0x0 */
+	lis	r3, CONFIG_KERNEL_START@h
+	/* saving the contents of 0x00000000 at
+	 * location 0x5c offset in registers
+	 */
+	lis	r4, registers@h
+	ori	r4, r4, registers@l
+	lwz	r5, 0x0(r3)
+	stw     r5, (4*0x5c)(r4)
+
+	lis	r4, ads5121_wakeup@h
+	ori	r4, r4, ads5121_wakeup@l
+	sub	r4, r4, r3
+	stw	r4, 0(r3)
+	sync
+
+	lis	r4, registers@h
+	ori	r4, r4, registers@l
+
+	/* save registers to r4 [destroys r10] */
+	SAVE_SPRN(LR, 0x1c)
+	bl	save_regs
+
+	/* copy code to sram */
+	mr	r4, r7
+	li	r3, (sram_code_end - sram_code)/4
+	/* Added to fix the crash issue while executing from SRAM */
+	addi	r3, r3,0x3
+	mtctr	r3
+	lis	r3, sram_code@h
+	ori	r3, r3, sram_code@l
+1:
+	lwz	r5, 0(r3)
+	stw	r5, 0(r4)
+	addi	r3, r3, 4
+	addi	r4, r4, 4
+	bdnz	1b
+
+	/* flush caches [destroys r3, r4] */
+	bl	flush_data_cache
+
+	/* disable I and D caches */
+	mfspr	r3, SPRN_HID0
+	ori	r3, r3, HID0_ICE | HID0_DCE
+	xori	r3, r3, HID0_ICE | HID0_DCE
+	sync; isync;
+	mtspr	SPRN_HID0, r3
+	isync; isync;
+
+	/*
+	 * We will load the RTC ATR value here so that
+	 * we get the address in a TLB. We cannot get any
+	 * ea->pa conversions after DDR is turned off.
+	 */
+	ori	r6, r8, MPC512x_IMMRBAR_RTC_OFFSET@l
+	lwz	r5, 0x24(r6)
+
+	/* setting the alarm value */
+	lis	r4, 0xFFFF
+	ori	r4, r4,0xFFFF
+
+	/* check whether the TTR should be set
+	 * to 0xFFFFFFFF or not */
+
+	xor	r4, r4, r9
+	/* compare r4 with 0 and set the bit
+	 * in the condition register 0 */
+	cmpi	0, r4,0
+	/* branch to "alarm" until the CR0 second bit is
+	 * set i.e,equal to condition for the
+	 * above comparison */
+	bc	0xC, 2, alarm
+
+	add	r9, r5, r9
+alarm:
+	mr	r5, r9
+
+	/* jump to sram */
+	mtlr    r7
+	blrl
+	/* doesn't return */
+
+sram_code:
+	/* Put DDR in Self Refresh */
+	mr 	r3, r8
+	ori	r3, r3, MPC5121_DDRC_OFFSET@l
+	lwz	r4, 0(r3)
+	oris	r4, r4, DDRC_SYSCONFIG_CMD@h
+	stw	r4, 0(r3)
+	sync
+	li	r4, MPC512x_DDRC_CMD0@l
+	stw	r4, 0x14(r3)
+	sync
+	li	r4, MPC512x_DDRC_CMD1@l
+	stw	r4, 0x14(r3)
+	sync
+	li	r4, MPC512x_DDRC_CMD2@l
+	stw	r4, 0x14(r3)
+	sync
+	li	r4, MPC512x_DDRC_CMD3@l
+	stw	r4, 0x14(r3)
+	sync
+
+	/* Set TTR = ATR + 60 (0x3C)*/
+	stw	r5, 0x20(r6)
+	sync
+
+sram_code_end:
+	b	sram_code_end
+	sync
+	isync
+
+	/* Uboot jumps here on resume */
+ads5121_wakeup:
+	bl	restore_regs
+
+	/* HIDs, MSR */
+	LOAD_SPRN(HID1, 0x19)
+	LOAD_SPRN(HID2, 0x1a)
+
+	/* address translation is tricky (see turn_on_mmu) */
+	mfmsr	r10
+	ori	r10, r10, MSR_DR | MSR_IR
+
+	mtspr	SPRN_SRR1, r10
+	lis	r10, mmu_on@h
+	ori	r10, r10, mmu_on@l
+	mtspr	SPRN_SRR0, r10
+	sync
+	rfi
+
+mmu_on:
+	/* kernel offset (r4 is still set from restore_registers) */
+	/* Though r4, will contain, just restoring incase if its
+	 * corrupted
+	 */
+	addis	r4, r4, CONFIG_KERNEL_START@h
+
+	/* restore MSR */
+	lwz	r10, (4*0x1b)(r4)
+	mtmsr	r10
+	sync; isync;
+
+	/* invalidate caches */
+	mfspr	r10, SPRN_HID0
+	ori	r5, r10, HID0_ICFI | HID0_DCI
+	mtspr	SPRN_HID0, r5	/* invalidate caches */
+	sync; isync;
+	mtspr	SPRN_HID0, r10
+	sync; isync;
+
+	/* enable caches */
+	lwz	r10, (4*0x18)(r4)
+	mtspr	SPRN_HID0, r10	/* restore (enable caches, DPM) */
+	/* ^ this has to be after address translation set in MSR */
+	sync
+	isync
+
+	LOAD_SPRN(LR, 0x1c)
+	blr
+
+save_regs:
+	stw	r0, 0(r4)
+	stw	r1, 0x4(r4)
+	stw	r2, 0x8(r4)
+	stmw	r11, 0xc(r4) /* 0xc -> 0x5f, (0x18*4-1) */
+
+	SAVE_SPRN(HID0, 0x18)
+	SAVE_SPRN(HID1, 0x19)
+	SAVE_SPRN(HID2, 0x1a)
+	mfmsr	r10
+	stw	r10, (4*0x1b)(r4)
+	/*SAVE_SPRN(LR, 0x1c) have to save it before the call */
+	SAVE_SPRN(RPA,   0x1e)
+	SAVE_SPRN(SDR1,  0x1f)
+
+	/* save MMU regs */
+	SAVE_BAT(0, 0x20)
+	SAVE_BAT(1, 0x24)
+	SAVE_BAT(2, 0x28)
+	SAVE_BAT(3, 0x2c)
+	SAVE_BAT(4, 0x30)
+	SAVE_BAT(5, 0x34)
+	SAVE_BAT(6, 0x38)
+	SAVE_BAT(7, 0x3c)
+
+	SAVE_4SR(0, 0x40)
+	SAVE_4SR(4, 0x44)
+	SAVE_4SR(8, 0x48)
+	SAVE_4SR(12, 0x4c)
+
+	SAVE_SPRN(SPRG0, 0x50)
+	SAVE_SPRN(SPRG1, 0x51)
+	SAVE_SPRN(SPRG2, 0x52)
+	SAVE_SPRN(SPRG3, 0x53)
+	SAVE_SPRN(SPRG4, 0x54)
+	SAVE_SPRN(SPRG5, 0x55)
+	SAVE_SPRN(SPRG6, 0x56)
+	SAVE_SPRN(SPRG7, 0x57)
+
+	SAVE_SPRN(IABR,  0x58)
+	SAVE_SPRN(DABR,  0x59)
+	SAVE_SPRN(TBRL,  0x5a)
+	SAVE_SPRN(TBRU,  0x5b)
+
+	blr
+
+restore_regs:
+	lis	r4, registers@h
+	ori	r4, r4, registers@l
+
+	/* This only required in case when the register is
+	 * directly accessed in Virtual Mode
+	*/
+	/* MMU is not up yet */
+	subis	r4, r4, CONFIG_KERNEL_START@h
+
+	/* restoring the contents at 0x00000000 location
+	 * from the 0x5c offset in registers
+	 */
+	lis	r5, CONFIG_KERNEL_START@h
+	subis	r5, r5, CONFIG_KERNEL_START@h
+	lwz	r3, (0x5c*4)(r4)
+	stw	r3, 0x0(r5)
+
+	lwz	r0, 0(r4)
+	lwz	r1, 0x4(r4)
+	lwz	r2, 0x8(r4)
+	lmw	r11, 0xc(r4)
+
+	/*
+	 * these are a bit tricky
+	 * 0x18 - HID0
+	 * 0x19 - HID1
+	 * 0x1a - HID2
+	 * 0x1b - MSR
+	 * 0x1c - LR
+	 */
+	LOAD_SPRN(RPA,   0x1e);
+	LOAD_SPRN(SDR1,  0x1f);
+
+	/* restore MMU regs */
+	LOAD_BAT(0, 0x20)
+	LOAD_BAT(1, 0x24)
+	LOAD_BAT(2, 0x28)
+	LOAD_BAT(3, 0x2c)
+	LOAD_BAT(4, 0x30)
+	LOAD_BAT(5, 0x34)
+	LOAD_BAT(6, 0x38)
+	LOAD_BAT(7, 0x3c)
+
+	LOAD_4SR(0, 0x40)
+	LOAD_4SR(4, 0x44)
+	LOAD_4SR(8, 0x48)
+	LOAD_4SR(12, 0x4c)
+
+	/* rest of regs */
+	LOAD_SPRN(SPRG0, 0x50);
+	LOAD_SPRN(SPRG1, 0x51);
+	LOAD_SPRN(SPRG2, 0x52);
+	LOAD_SPRN(SPRG3, 0x53);
+	LOAD_SPRN(SPRG4, 0x54);
+	LOAD_SPRN(SPRG5, 0x55);
+	LOAD_SPRN(SPRG6, 0x56);
+	LOAD_SPRN(SPRG7, 0x57);
+
+	LOAD_SPRN(IABR,  0x58);
+	LOAD_SPRN(DABR,  0x59);
+	LOAD_SPRN(TBWL,  0x5a);	/* these two have separate R/W regs */
+	LOAD_SPRN(TBWU,  0x5b);
+
+	blr
+
+
+/* cache flushing code. copied from arch/ppc/boot/util.S */
+/*
+ * Flush data cache
+ * Do this by just reading lots of stuff into the cache.
+ * We copy twice the cache lines to make sure all cache
+ * is flushed..
+ */
+#define NUM_CACHE_LINES (128*8*2)
+
+flush_data_cache:
+	lis	r3, CONFIG_KERNEL_START@h
+	ori	r3, r3, CONFIG_KERNEL_START@l
+	li	r4, NUM_CACHE_LINES
+	mtctr	r4
+1:
+	lwz	r4, 0(r3)
+	addi	r3, r3, L1_CACHE_BYTES	/* Next line, please */
+	bdnz	1b
+	blr
+
diff --git a/arch/powerpc/platforms/512x/mpc5121_ads.c b/arch/powerpc/platforms/512x/mpc5121_ads.c
index 0c1886a..2ac3ab1 100644
--- a/arch/powerpc/platforms/512x/mpc5121_ads.c
+++ b/arch/powerpc/platforms/512x/mpc5121_ads.c
@@ -91,7 +91,11 @@ static void __init mpc5121_ads_setup_arch(void)
 	}
 
 #ifdef CONFIG_PM
-	mpc512x_pm_init();
+	#ifdef CONFIG_MPC5121_ADS_HIB
+		ads5121_pm_init();
+	#else
+		mpc512x_pm_init();
+	#endif
 #endif
 
 #ifdef CONFIG_PCI
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.c b/arch/powerpc/platforms/512x/mpc512x_pm.c
index 7e05951..c48ac14 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.c
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.c
@@ -28,6 +28,26 @@ struct mpc512x_pm mpc512x_pm_data;
 static u32 mpc512x_targeted_state = MPC512x_PM_NONE;
 
 /*
+ * + * Name       : mpc512x_clrevents
+ * + * Desc       : This function clears the GPIo events and the CAN events
+ * + *
+ * + * Parameters : void
+ * + * Return     : void
+ * + */
+void  mpc512x_clrevents(struct mpc512x_pm *p_pmdata)
+{
+
+	u32	*gpio, reg;
+	u8	*mscan = NULL;
+
+	gpio = (u32 *)((u32)p_pmdata->mbar + MPC512x_IMMRBAR_GPIO_OFFSET);
+	mscan = (u8 *)((u32)p_pmdata->mbar + MPC512x_IMMRBAR_MSCAN_OFFSET);
+
+	reg = in_be32(&gpio[MPC512x_GPIO_GPIER >> 2]);
+	out_be32(&gpio[MPC512x_GPIO_GPIER >> 2], reg);
+}
+
+/*
  * Name       : mpc512x_pm_setup
  * Desc       : This function is called to setup and map the IO region.
  *
@@ -58,15 +78,12 @@ int mpc512x_pm_setup(struct mpc512x_pm *p_pmdata)
  */
 void mpc512x_pm_release(struct mpc512x_pm *p_pmdata)
 {
-	unsigned long flags;
 
 	if (!p_pmdata->mbar)
 		return;
 
-	local_irq_save(flags);
 	iounmap(p_pmdata->mbar);
 	memset(p_pmdata, 0, sizeof(struct mpc512x_pm));
-	local_irq_restore(flags);
 }
 
 /*
@@ -440,6 +457,9 @@ int mpc512x_enter_deepsleep(struct mpc512x_pm *p_pmdata)
 	/* We are out of Deep Sleep.. Lets restart jiffies */
 	wakeup_decrementer();
 
+	/* clearing the events of wake-up for GPIO and CAN */
+	mpc512x_clrevents(p_pmdata);
+
 	/* Reset the PMC CR register. */
 	out_be32(&pmc->pmc_cr, 0x0);
 	out_be32(&pmc->pmc_mr, 0x0);
diff --git a/arch/powerpc/platforms/512x/mpc512x_pm.h b/arch/powerpc/platforms/512x/mpc512x_pm.h
index 06867bf..a661325 100644
--- a/arch/powerpc/platforms/512x/mpc512x_pm.h
+++ b/arch/powerpc/platforms/512x/mpc512x_pm.h
@@ -22,6 +22,11 @@
 #define MPC512x_IMMRBAR_PMC_OFFSET		0x1000
 #define MPC512x_IMMRBAR_GPIO_OFFSET		0x1100
 #define MPC512x_IMMRBAR_DDRC_OFFSET		0x9000
+#define MPC512x_IMMRBAR_CLK_OFFSET      	0x00F00
+#define MPC512x_IMMRBAR_GPT_OFFSET      	0x00B00
+#define MPC512x_IMMRBAR_FEC_OFFSET      	0x02800
+#define MPC512x_IMMRBAR_SRAM_OFFSET     	0x000C4
+#define MPC512x_IMMRBAR_MSCAN_OFFSET		0x01300
 
 /* Memory mapped by Power management module */
 #define MPC512x_IMMRBAR_MEM_MAPPED		0x10000
@@ -48,6 +53,11 @@
 /* Register offsets for GPIO */
 #define MPC512x_GPIO_IMR			0x10
 #define MPC512x_GPIO_ICR2			0x18
+#define MPC512x_GPIO_GPIER			0x0C
+
+/* Register offsets for MSCAN */
+#define MPC512x_MSCAN_CANRFLG			0x08
+#define MPC512x_MSCAN_CANRIER			0x09
 
 /* Bit positions in IPIC memory region */
 #define MPC512x_IPIC_MSRH_MSCAN1		(1 << 4)
@@ -80,7 +90,7 @@
 #define MPC512x_DDRC_SELF_REF_CMD7		0x3800
 
 /* RTC Keep alive register values*/
-#define MPC512x_RTCKAR_WKUP_SRCLVL		0x001F0000
+#define MPC512x_RTCKAR_WKUP_SRCLVL		0x001C0000
 #define MPC512x_RTCKAR_WKUP_SRCEN		0x1F000000
 #define MPC512x_RTCKAR_DIS_HIBMODE		0x00000080
 
@@ -117,6 +127,17 @@ struct mpc512x_pm{
 	u32 ddrc_sysconfig;
 };
 
+/* Structure members used to store the resister contents
+ * for peripherals which cdont have a driver to restore.
+ */
+struct ads5121_hib_regs{
+	u32 ipic_regs[30];
+	u32 clk_regs[22];
+	u32 gpt_regs[32];
+	u32 gpio_regs[7];
+	u32 fec_regs[512];
+};
+
 int mpc512x_pm_setup(struct mpc512x_pm *p_pmdata);
 void mpc512x_pm_release(struct mpc512x_pm *p_pmdata);
 void mpc512x_prepare_deepsleep(struct mpc512x_pm *p_pmdata);
-- 
1.6.3.1

