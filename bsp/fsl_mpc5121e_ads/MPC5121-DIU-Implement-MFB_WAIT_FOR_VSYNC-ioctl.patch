From 5ac41b44b8723e20f0447e2011125eb0430b359f Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 23 Jun 2009 17:00:28 +0800
Subject: [PATCH 12/25] MPC5121 DIU: Implement MFB_WAIT_FOR_VSYNC ioctl

Original patch taken from rev 4 board support ISO image:
  mpc5121ads-20081208_ltib-beta.iso
  http://www.freescale.com/webapp/sps/site/overview.jsp?
  nodeId=0127260061033202A5621E

Using old patch from York Sun.

Signed-off-by: John Rigby <jrigby@freescale.com>
Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/video/fsl-diu-fb.c |   51 ++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 49 insertions(+), 2 deletions(-)

diff --git a/drivers/video/fsl-diu-fb.c b/drivers/video/fsl-diu-fb.c
index 22d9b6a..0d68951 100644
--- a/drivers/video/fsl-diu-fb.c
+++ b/drivers/video/fsl-diu-fb.c
@@ -203,6 +203,11 @@ struct fsl_diu_data {
 	int monitor_port;
 };
 
+struct fsl_diu_vsync {
+	wait_queue_head_t wait;
+	volatile unsigned int count;
+};
+
 struct mfb_info {
 	int index;
 	int type;
@@ -217,6 +222,7 @@ struct mfb_info {
 	int x_aoi_d;		/* aoi display x offset to physical screen */
 	int y_aoi_d;		/* aoi display y offset to physical screen */
 	struct fsl_diu_data *parent;
+	struct fsl_diu_vsync vsync;
 };
 
 
@@ -279,6 +285,8 @@ static struct diu_hw dr = {
 
 static struct diu_pool pool;
 
+static struct fsl_diu_data *global_machine_data;
+
 static void write_reg(u32 *reg, u32 value)
 {
 	unsigned long flag;
@@ -998,6 +1006,25 @@ static int fsl_diu_blank(int blank_mode, struct fb_info *info)
 	return 0;
 }
 
+static int wait_for_vsync(struct fb_info *info)
+{
+	struct fsl_diu_vsync *vsync;
+	unsigned int count;
+	int ret;
+	struct mfb_info *mfbi = info->par;
+	struct fsl_diu_data *machine_data = mfbi->parent;
+
+	vsync = &((struct mfb_info *)machine_data->fsl_diu_info[0]->par)->vsync;
+	count = vsync->count;
+	ret = wait_event_interruptible_timeout(vsync->wait,
+				count != vsync->count, HZ/10);
+	if (ret < 0)
+		return ret;
+	if (ret == 0)
+		return -ETIMEDOUT;
+	return 0;
+}
+
 static int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,
 		       unsigned long arg)
 {
@@ -1011,6 +1038,8 @@ static int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,
 	void __user *buf = (void __user *)arg;
 	struct diu *hw = dr.diu_reg;
 	char byte_flip;
+	int ret;
+	struct fsl_diu_data *machine_data = mfbi->parent;
 
 	if (!arg)
 		return -EINVAL;
@@ -1113,6 +1142,14 @@ static int fsl_diu_ioctl(struct fb_info *info, unsigned int cmd,
 	case FBIOGET_DISPINFO:
 		pr_debug("FBIOGET_DISPINFO:0x%08x\n", FBIOGET_DISPINFO);
 		break;
+	case MFB_WAIT_FOR_VSYNC:
+		if (!arg)
+			return -EINVAL;
+		mfbi = (struct mfb_info *)machine_data->fsl_diu_info[0]->par;
+		ret = wait_for_vsync(info);
+		if (copy_to_user((void *)arg, (void *)&ret, sizeof(ret)))
+			return -EFAULT;
+		break;
 	case MFB_SET_GAMMA:
 		if (!arg)
 			return -EINVAL;
@@ -1320,16 +1357,21 @@ static irqreturn_t fsl_diu_isr(int irq, void *dev_id)
 			udelay(1);
 			out_be32(&hw->diu_mode, 1);
 		}
-#if defined(CONFIG_NOT_COHERENT_CACHE)
 		else if (status & INT_VSYNC) {
+#if defined(CONFIG_NOT_COHERENT_CACHE)
 			unsigned int i;
 			for (i = 0; i < coherence_data_size;
 				i += d_cache_line_size)
 				__asm__ __volatile__ (
 					"dcbz 0, %[input]"
 				::[input]"r"(&coherence_data[i]));
-		}
 #endif
+			((struct mfb_info *)global_machine_data->
+				fsl_diu_info[0]->par)->vsync.count++;
+			wake_up_interruptible(&((struct mfb_info *)
+				global_machine_data->fsl_diu_info[0]->par)
+				->vsync.wait);
+		}
 		return IRQ_HANDLED;
 	}
 	return IRQ_NONE;
@@ -1485,6 +1527,8 @@ static int __devinit fsl_diu_probe(struct of_device *ofdev,
 	if (!machine_data)
 		return -ENOMEM;
 
+	global_machine_data = machine_data;
+
 	for (i = 0; i < ARRAY_SIZE(machine_data->fsl_diu_info); i++) {
 		machine_data->fsl_diu_info[i] =
 			framebuffer_alloc(sizeof(struct mfb_info), &ofdev->dev);
@@ -1581,6 +1625,9 @@ static int __devinit fsl_diu_probe(struct of_device *ofdev,
 		}
 	}
 
+	init_waitqueue_head(&((struct mfb_info *)machine_data->
+			fsl_diu_info[0]->par)->vsync.wait);
+
 	if (request_irq_local(machine_data->irq)) {
 		dev_err(machine_data->fsl_diu_info[0]->dev,
 			"could not request irq for diu.");
-- 
1.6.3.1

