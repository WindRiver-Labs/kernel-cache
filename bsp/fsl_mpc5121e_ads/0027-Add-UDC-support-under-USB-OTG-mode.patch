From e6053cec40fceb3f5b3fd070dba0afcb99283845 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:14 +0800
Subject: [PATCH] Add UDC support under USB OTG mode

Add OTG macro process branch in UDC driver,
mainly focus on platform resource allocation
and release, and OTG transceiver use as well.

Under OTG mode, USB otg driver must be loaded
before UDC driver, what is more, platform
resource is managed by OTG driver which is
shared by UDC and EHCI driver.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/usb/gadget/fsl_usb2_udc.c |   87 +++++++++++++++++++++++++++++++------
 1 files changed, 74 insertions(+), 13 deletions(-)

diff --git a/drivers/usb/gadget/fsl_usb2_udc.c b/drivers/usb/gadget/fsl_usb2_udc.c
index 2a8381e..be61cc8 100644
--- a/drivers/usb/gadget/fsl_usb2_udc.c
+++ b/drivers/usb/gadget/fsl_usb2_udc.c
@@ -80,6 +80,12 @@ static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state);
 static int fsl_udc_resume(struct platform_device *pdev);
 static void fsl_ep_fifo_flush(struct usb_ep *_ep);
 
+#ifdef CONFIG_USB_OTG
+/* Get platform resource from OTG driver */
+extern struct resource *otg_get_resources(void);
+/* otg_get_transceiver - find the (single) OTG transceiver driver*/
+extern struct otg_transceiver *otg_get_transceiver(void);
+#endif
 
 /********************************************************************
  *	Internal Used Function
@@ -1846,11 +1852,38 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		goto out;
 	}
 
-	/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
-	dr_controller_run(udc_controller);
-	udc_controller->usb_state = USB_STATE_ATTACHED;
-	udc_controller->ep0_state = WAIT_FOR_SETUP;
-	udc_controller->ep0_dir = 0;
+#ifdef CONFIG_USB_OTG
+	if (udc_controller->transceiver) {
+		/* Suspend the controller until OTG enable it */
+		dr_controller_stop(udc_controller);
+		printk(KERN_INFO "Suspend udc for OTG auto detect\n");
+
+		/* export udc suspend/resume call to OTG */
+		udc_controller->gadget.dev.driver->suspend = fsl_udc_suspend;
+		udc_controller->gadget.dev.driver->resume = fsl_udc_resume;
+
+		/* connect to bus through transceiver */
+		if (udc_controller->transceiver) {
+			retval = otg_set_peripheral(udc_controller->transceiver,
+						    &udc_controller->gadget);
+			if (retval < 0) {
+				ERR("can't bind to transceiver\n");
+				driver->unbind(&udc_controller->gadget);
+				udc_controller->gadget.dev.driver = 0;
+				udc_controller->driver = 0;
+				return retval;
+			}
+		}
+	} else {
+#endif
+		/* Enable DR IRQ reg and Set usbcmd reg  Run bit */
+		dr_controller_run(udc_controller);
+		udc_controller->usb_state = USB_STATE_ATTACHED;
+		udc_controller->ep0_state = WAIT_FOR_SETUP;
+		udc_controller->ep0_dir = 0;
+#ifdef CONFIG_USB_OTG
+	}
+#endif
 	printk(KERN_INFO "%s: bind to driver %s \n",
 			udc_controller->gadget.name, driver->driver.name);
 
@@ -2310,6 +2343,21 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	udc_controller->pdata = pdata;
 #endif
 
+#ifdef CONFIG_USB_OTG
+	/* Memory and interrupt resources will be passed from OTG */
+	udc_controller->transceiver = otg_get_transceiver();
+	if (!udc_controller->transceiver) {
+		printk(KERN_ERR "Can't find OTG driver!\n");
+		ret = -ENXIO;
+		goto err1a;
+	}
+
+	res = otg_get_resources();
+	if (!res) {
+		DBG("resource not registered!\n");
+		return -ENODEV;
+	}
+#else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		ret = -ENXIO;
@@ -2322,7 +2370,7 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ret = -EBUSY;
 		goto err1a;
 	}
-
+#endif
 	dr_regs = ioremap(res->start, res->end - res->start + 1);
 	if (!dr_regs) {
 		ret = -ENOMEM;
@@ -2357,8 +2405,12 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	/* Get max device endpoints */
 	/* DEN is bidirectional ep number, max_ep doubles the number */
 	udc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;
-
+#ifdef CONFIG_USB_OTG
+	res++;
+	udc_controller->irq = res->start;
+#else
 	udc_controller->irq = platform_get_irq(pdev, 0);
+#endif
 	if (!udc_controller->irq) {
 		ret = -ENODEV;
 		goto err2;
@@ -2378,11 +2430,15 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 		ret = -ENOMEM;
 		goto err3;
 	}
-
-	/* initialize usb hw reg except for regs for EP,
-	 * leave usbintr reg untouched */
-	dr_controller_setup(udc_controller);
-
+#ifdef CONFIG_USB_OTG
+	if (!udc_controller->transceiver) {
+#endif
+		/* initialize usb hw reg except for regs for EP,
+		 * leave usbintr reg untouched */
+		dr_controller_setup(udc_controller);
+#ifdef CONFIG_USB_OTG
+	}
+#endif
 	/* Setup gadget structure */
 	udc_controller->gadget.ops = &fsl_gadget_ops;
 	udc_controller->gadget.is_dualspeed = 1;
@@ -2398,7 +2454,10 @@ static int __init fsl_udc_probe(struct platform_device *pdev)
 	ret = device_register(&udc_controller->gadget.dev);
 	if (ret < 0)
 		goto err3;
-
+#ifdef CONFIG_USB_OTG
+	if (udc_controller->transceiver)
+		udc_controller->gadget.is_otg = 1;
+#endif
 	/* setup QH and epctrl for ep0 */
 	ep0_setup(udc_controller);
 
@@ -2507,6 +2566,7 @@ static int __exit fsl_udc_remove(struct platform_device *pdev)
  -----------------------------------------------------------------*/
 static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	printk(KERN_INFO "USB Gadget suspended\r\n");
 	dr_controller_stop(udc_controller);
 	return 0;
 }
@@ -2517,6 +2577,7 @@ static int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)
  *-----------------------------------------------------------------*/
 static int fsl_udc_resume(struct platform_device *pdev)
 {
+	printk(KERN_INFO "USB Gadget resumed\r\n");
 	/* Enable DR irq reg and set controller Run */
 	if (udc_controller->stopped) {
 		dr_controller_setup(udc_controller);
-- 
1.6.0.90.g436ed

