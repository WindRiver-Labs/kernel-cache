From 83705381e9525148984a9c016a1e404dd47038a9 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Tue, 4 Nov 2008 14:46:05 +0800
Subject: [PATCH] Add ESDHC driver

Add dts node in device tree for ESDHC,
adds card io access file and basic card operatoin
file.

Signed-off-by: Andrew Liu <shengping.liu@windriver.com>
---
 arch/powerpc/boot/dts/mpc5121ads.dts |    7 +
 drivers/mmc/host/Kconfig             |   10 +
 drivers/mmc/host/Makefile            |    2 +
 drivers/mmc/host/esdhc.c             | 1082 ++++++++++++++++++++++++++++++++++
 drivers/mmc/host/esdhc.h             |  183 ++++++
 drivers/mmc/host/iocontrol.c         |  156 +++++
 6 files changed, 1440 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mmc/host/esdhc.c
 create mode 100644 drivers/mmc/host/esdhc.h
 create mode 100644 drivers/mmc/host/iocontrol.c

diff --git a/arch/powerpc/boot/dts/mpc5121ads.dts b/arch/powerpc/boot/dts/mpc5121ads.dts
index 72cd991..46e9f80 100644
--- a/arch/powerpc/boot/dts/mpc5121ads.dts
+++ b/arch/powerpc/boot/dts/mpc5121ads.dts
@@ -216,6 +216,13 @@
 			reg = <0x1380 0x80>;
 		};
 
+		sdhc@1500 {    //added for sdhc device driver, removed the clk part
+			compatible = "fsl,mpc5121-esdhc";
+			interrupts = <8 0x8>;
+			interrupt-parent = < &ipic >;
+			reg = <0x1500 0x100>;
+		};
+
 		i2c@1700 {
 			#address-cells = <1>;
 			#size-cells = <0>;
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index bf90350..67dc0ce 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -65,6 +65,16 @@ config MMC_RICOH_MMC
 
 	  If unsure, say Y.
 
+config MMC_ESDHC
+	tristate "Enhanced Secure Digital Host Controller Interface support"
+	depends on PPC
+	help
+	  This select Freescale Enhanced SD Host Controller Interface.
+	  The controller is used in MPC837x and so on.
+	  If you have a MPC Platform with SD slot, say Y or M here.
+
+	  If unsure, say N.
+
 config MMC_OMAP
 	tristate "TI OMAP Multimedia Card Interface support"
 	depends on ARCH_OMAP1 || (ARCH_OMAP2 && ARCH_OMAP2420)
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index ba477bc..64268da 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -22,5 +22,7 @@ obj-$(CONFIG_MMC_TIFM_SD)	+= tifm_sd.o
 obj-$(CONFIG_MMC_SPI)		+= mmc_spi.o
 obj-$(CONFIG_MMC_S3C)   	+= s3cmci.o
 obj-$(CONFIG_MMC_SDRICOH_CS)	+= sdricoh_cs.o
+obj-$(CONFIG_MMC_ESDHC)		+= esdhc.o
+obj-$(CONFIG_MMC_ESDHC)		+= iocontrol.o
 obj-$(CONFIG_MMC_TMIO)		+= tmio_mmc.o
 
diff --git a/drivers/mmc/host/esdhc.c b/drivers/mmc/host/esdhc.c
new file mode 100644
index 0000000..da851e9
--- /dev/null
+++ b/drivers/mmc/host/esdhc.c
@@ -0,0 +1,1082 @@
+/*
+ * drivers/mmc/host/esdhc.c
+ *
+ * Copyright (C) 2008 Freescale Semicondutor, Inc. All rights reserved.
+ *
+ * Author: <allgosystems.com>
+ *
+ * derived from sdhci.c by Pierre Ossman
+ *
+ * Description:
+ * Freescale Enhanced Secure Digital Host Controller driver.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sd.h>
+#include <linux/mmc/host.h>
+#include <linux/module.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/time.h>
+
+#include <asm/of_platform.h>
+#include <asm/dma.h>
+#include <asm/page.h>
+#include <asm/reg.h>
+#include <sysdev/fsl_soc.h>
+
+#include "esdhc.h"
+#include <asm/fsldma.h>
+
+#define H2_SDHC_D3_CD 0X00000080
+#define D3_CD_LINE 0X0D8
+#define PU_ENABLE 0x00000018
+#define DATA_SKEW_RATE_STD_4 0x00000003
+
+#define DRIVER_NAME "sdhc"
+/* #define  MXC_MMC_DMA_ENABLE */
+
+#define MPC512X_DMA_SDHC       30
+#define RSP_TYPE(x)     ((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))
+
+#ifdef DEBUG
+#define DBG(fmt, args...)       printk(KERN_DEBUG "[%s]  " fmt "\n", \
+					__func__, ## args)
+#else
+#define DBG(fmt, args...)       do {} while (0)
+#endif
+
+
+#define ESDHC_QUIRK_CLOCK_BEFORE_RESET                  (1<<0)
+#define ESDHC_QUIRK_FORCE_DMA                           (1<<1)
+#define ESDHC_QUIRK_NO_CARD_NO_RESET                    (1<<2)
+#define ESDHC_QUIRK_SINGLE_POWER_WRITE                  (1<<3)
+
+#ifdef CONFIG_MMC_DEBUG
+
+static void dump_cmd(struct mmc_command *cmd)
+{
+	printk(KERN_INFO "%s: CMD: opcode: %d ", DRIVER_NAME, cmd->opcode);
+	printk(KERN_INFO "arg: 0x%08x ", cmd->arg);
+	printk(KERN_INFO "flags: 0x%08x\n", cmd->flags);
+}
+
+static void dump_status(const char *func, int sts)
+{
+	unsigned int bitset;
+	printk(KERN_INFO "%s:status: ", func);
+	while (sts) {
+		/* Find the next bit set */
+		bitset = sts & ~(sts - 1);
+		switch (bitset) {
+		case STATUS_CARD_INSERTION:
+			printk(KERN_INFO "CARD_INSERTION|");
+			break;
+		case STATUS_CARD_REMOVAL:
+			printk(KERN_INFO "CARD_REMOVAL |");
+			break;
+		case STATUS_YBUF_EMPTY:
+			printk(KERN_INFO "YBUF_EMPTY |");
+			break;
+		case STATUS_XBUF_EMPTY:
+			printk(KERN_INFO "XBUF_EMPTY |");
+			break;
+		case STATUS_YBUF_FULL:
+			printk(KERN_INFO "YBUF_FULL |");
+			break;
+		case STATUS_XBUF_FULL:
+			printk(KERN_INFO "XBUF_FULL |");
+			break;
+		case STATUS_BUF_UND_RUN:
+			printk(KERN_INFO "BUF_UND_RUN |");
+			break;
+		case STATUS_BUF_OVFL:
+			printk(KERN_INFO "BUF_OVFL |");
+			break;
+		case STATUS_READ_OP_DONE:
+			printk(KERN_INFO "READ_OP_DONE |");
+			break;
+		case STATUS_WR_CRC_ERROR_CODE_MASK:
+			printk(KERN_INFO "WR_CRC_ERROR_CODE |");
+			break;
+		case STATUS_READ_CRC_ERR:
+			printk(KERN_INFO "READ_CRC_ERR |");
+			break;
+		case STATUS_WRITE_CRC_ERR:
+			printk(KERN_INFO "WRITE_CRC_ERR |");
+			break;
+		case STATUS_SDIO_INT_ACTIVE:
+			printk(KERN_INFO "SDIO_INT_ACTIVE |");
+			break;
+		case STATUS_END_CMD_RESP:
+			printk(KERN_INFO "END_CMD_RESP |");
+			break;
+		case STATUS_WRITE_OP_DONE:
+			printk(KERN_INFO "WRITE_OP_DONE |");
+			break;
+		case STATUS_CARD_BUS_CLK_RUN:
+			printk(KERN_INFO "CARD_BUS_CLK_RUN |");
+			break;
+		case STATUS_BUF_READ_RDY:
+			printk(KERN_INFO "BUF_READ_RDY |");
+			break;
+		case STATUS_BUF_WRITE_RDY:
+			printk(KERN_INFO "BUF_WRITE_RDY |");
+			break;
+		case STATUS_RESP_CRC_ERR:
+			printk(KERN_INFO "RESP_CRC_ERR |");
+			break;
+		case STATUS_TIME_OUT_RESP:
+			printk(KERN_INFO "TIME_OUT_RESP |");
+			break;
+		case STATUS_TIME_OUT_READ:
+			printk(KERN_INFO "TIME_OUT_READ |");
+			break;
+		default:
+			printk(KERN_INFO "Invalid Status Register value0x%x\n",
+				   bitset);
+			break;
+		}
+		sts &= ~bitset;
+	}
+	printk(KERN_INFO "\n");
+}
+
+static void esdhc_dumpregs(struct esdhc_host *host)
+{
+	printk(KERN_DEBUG DRIVER_NAME ": ========= REGISTER DUMP ==========\n");
+
+	printk(KERN_DEBUG DRIVER_NAME ": Clock Control Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_STR_STP_CLK));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Status Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_STATUS));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Clock Rate Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_CLK_RATE));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Command and data Control Register :"
+		" 0x%08x\n", fsl_readl(host->ioaddr + MMC_CMD_DAT_CONT));
+
+	printk(KERN_DEBUG DRIVER_NAME ":Response and Timeout Register:0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_RES_TO));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Read Timeout Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_READ_TO));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Block Length Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_BLK_LEN));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Number of Blocks Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_NOB));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Revision Number Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_REV_NO));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Interrupt Control Register :0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_INT_CNTR));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Command Number Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_CMD));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Command Argument Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_ARG));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Command Response Register : 0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_RES_FIFO));
+
+	printk(KERN_DEBUG DRIVER_NAME ": Data Buffer Access Register :0x%08x\n",
+		   fsl_readl(host->ioaddr + MMC_BUFFER_ACCESS));
+}
+
+#endif
+
+static int esdhc_data_done(struct esdhc_host *host, unsigned int stat);
+
+static void fsl_writel(u32 val, unsigned __iomem *addr)
+{
+	out_be32(addr, val);
+}
+
+static inline u32 fsl_readl(unsigned __iomem *addr)
+{
+	u32 val;
+	val = in_be32(addr);
+	return val;
+}
+
+/*!
+ *This function resets the SDHC host.
+ *
+ * @param host  Pointer to MMC/SD  host structure
+ */
+static void esdhc_softreset(struct esdhc_host *host)
+{
+	/* reset sequence */
+
+
+	fsl_writel(0x8, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x9, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x1, host->ioaddr + MMC_STR_STP_CLK);
+	fsl_writel(0x3f, host->ioaddr + MMC_CLK_RATE);
+
+	fsl_writel(0xff, host->ioaddr + MMC_RES_TO);
+	fsl_writel(512, host->ioaddr + MMC_BLK_LEN);
+	fsl_writel(1, host->ioaddr + MMC_NOB);
+	fsl_writel(H2_SDHC_D3_CD | DATA_SKEW_RATE_STD_4 | PU_ENABLE, \
+			port_ioaddr + D3_CD_LINE);
+
+
+}
+
+/* Wait count to start the clock */
+#define CMD_WAIT_CNT 1000
+
+/*!
+ * This function sets the SDHC register to stop the clock and waits for the
+ * clock stop indication.
+ */
+static void esdhc_stop_clock(struct esdhc_host *host, bool wait)
+{
+	int wait_cnt = 0;
+	while (1) {
+		fsl_writel(STR_STP_CLK_IPG_CLK_GATE_DIS |
+				   STR_STP_CLK_IPG_PERCLK_GATE_DIS |
+				   STR_STP_CLK_STOP_CLK,
+				   host->ioaddr + MMC_STR_STP_CLK);
+
+		if (!wait)
+			break;
+
+		wait_cnt = CMD_WAIT_CNT;
+
+		while (wait_cnt--) {
+			if (!(fsl_readl(host->ioaddr + MMC_STATUS)&
+				 STATUS_CARD_BUS_CLK_RUN))
+				break;
+
+		}
+
+		if (!(fsl_readl(host->ioaddr + MMC_STATUS) &
+			  STATUS_CARD_BUS_CLK_RUN))
+			break;
+	}
+}
+
+/*!
+ * This function sets the SDHC register to start the clock and waits for the
+ * clock start indication. When the clock starts SDHC module starts processing
+ * the command in CMD Register with arguments in ARG Register.
+ *
+ * @param host Pointer to MMC/SD host structure
+ * @param wait Boolean value to indicate whether to wait for the clock to start
+ *  or come out instantly
+ */
+
+static void esdhc_start_clock(struct esdhc_host *host, bool wait)
+{
+	int wait_cnt;
+
+	setbits32(host->ioaddr + MMC_STR_STP_CLK, \
+		STR_STP_CLK_IPG_CLK_GATE_DIS | STR_STP_CLK_IPG_PERCLK_GATE_DIS);
+
+	while (1) {
+		setbits32(host->ioaddr + MMC_STR_STP_CLK, \
+			STR_STP_CLK_START_CLK);
+		if (!wait)
+			break;
+
+		wait_cnt = CMD_WAIT_CNT;
+		while (wait_cnt--) {
+			if (!(fsl_readl(host->ioaddr + MMC_STATUS) &
+				  STATUS_CARD_BUS_CLK_RUN))
+				setbits32(host->ioaddr + MMC_STR_STP_CLK, \
+						STR_STP_CLK_START_CLK);
+		}
+
+		if (fsl_readl(host->ioaddr + MMC_STATUS) &
+			STATUS_CARD_BUS_CLK_RUN)
+			break;
+
+	}
+}
+
+
+/*!
+ * This function is called to setup SDHC register for data transfer.
+ * The function allocates DMA buffers, configures the DMA channel.
+ * Start the DMA channel to transfer data. When DMA is not enabled this
+ * function set ups only Number of Block and Block Length registers.
+ *
+ * @param host  Pointer to MMC/SD host structure
+ * @param data  Pointer to MMC/SD data structure
+ */
+static void esdhc_setup_data(struct esdhc_host *host, struct mmc_data *data)
+{
+	unsigned int nob = data->blocks;
+
+	if (data->flags & MMC_DATA_STREAM)
+		nob = 0xffff;
+
+
+	host->data = data;
+
+	fsl_writel(nob, host->ioaddr + MMC_NOB);
+	fsl_writel(data->blksz, host->ioaddr + MMC_BLK_LEN);
+
+	host->dma_size = data->blocks * data->blksz;
+	pr_debug("%s:Request bytes to transfer:%d\n", DRIVER_NAME,
+			 host->dma_size);
+
+}
+
+/*!
+ * This function is called by \b mxcmci_request() function to setup the SDHC
+ * register to issue command. This function disables the card insertion and
+ * removal detection interrupt.
+ *
+ * @param host  Pointer to MMC/SD host structure
+ * @param cmd   Pointer to MMC/SD command structure
+ * @param cmdat Value to store in Command and Data Control Register
+ */
+static void esdhc_start_cmd(struct esdhc_host *host, struct mmc_command *cmd,
+							unsigned int cmdat)
+{
+	WARN_ON(host->cmd != NULL);
+
+	host->cmd = cmd;
+	/* if(!(cmd->opcode==13)) */
+
+	/* printk("*cmd from esdhc_start_cmd is %d arg in hex is %x ** %d \n", \
+	cmd->opcode,cmd->arg,host->mmc->ios.bus_width ); */
+
+	switch (RSP_TYPE(mmc_resp_type(cmd))) {
+	case RSP_TYPE(MMC_RSP_R1):	/* r1, r1b, r6 */
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R1;
+		break;
+	case RSP_TYPE(MMC_RSP_R3):
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R3;
+		break;
+	case RSP_TYPE(MMC_RSP_R2):
+		cmdat |= CMD_DAT_CONT_RESPONSE_FORMAT_R2;
+		break;
+	default:
+		/* No Response required */
+		break;
+	}
+
+	if (cmd->opcode == MMC_GO_IDLE_STATE)
+		cmdat |= CMD_DAT_CONT_INIT;	/* This command needs init */
+
+	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
+		cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;
+
+	fsl_writel(cmd->opcode, host->ioaddr + MMC_CMD);
+	fsl_writel(cmd->arg, host->ioaddr + MMC_ARG);
+
+	fsl_writel(cmdat, host->ioaddr + MMC_CMD_DAT_CONT);
+	esdhc_start_clock(host, true);
+}
+
+/*!
+ * This function is called to complete the command request.
+ * This function enables insertion or removal interrupt.
+ *
+ * @param host Pointer to MMC/SD host structure
+ * @param req  Pointer to MMC/SD command request structure
+ */
+static void esdhc_finish_request(struct esdhc_host *host,
+				struct mmc_request *req)
+{
+
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	mmc_request_done(host->mmc, req);
+}
+
+/*!
+ * This function is called when the requested command is completed.
+ * This function reads the response from the card and data if the command is for
+ * data transfer. This function checks for CRC error in response FIFO or
+ * data FIFO.
+ *
+ * @param host  Pointer to MMC/SD host structure
+ * @param stat  Content of SDHC Status Register
+ *
+ * @return This function returns 0 if there is no pending command, otherwise 1
+ * always.
+ */
+static int esdhc_cmd_done(struct esdhc_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->cmd;
+	struct mmc_data *data = host->data;
+	struct scatterlist *sg;
+	int i;
+	u32 a, b, c;
+	u32 temp_data;
+	unsigned int status = 0;
+	unsigned long *buf;
+	int no_of_bytes;
+	int no_of_words;
+	int num_buf;
+	struct timeval tv1 ;
+	struct timeval *tv;
+	num_buf = 1;
+	tv = &tv1;
+
+	if (!cmd) {
+		/* There is no command for completion */
+		return 0;
+	}
+
+	/* As this function finishes the command, initialize cmd to NULL */
+	host->cmd = NULL;
+
+	/* check for Time out errors */
+	if (stat & STATUS_TIME_OUT_RESP) {
+		printk(KERN_INFO "\n\t The response timeout error\n");
+		fsl_writel(STATUS_TIME_OUT_RESP, host->ioaddr + MMC_STATUS);
+		pr_debug("%s: CMD TIMEOUT\n", DRIVER_NAME);
+		cmd->error = -ETIMEDOUT;
+	} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {
+		fsl_writel(STATUS_RESP_CRC_ERR, host->ioaddr + MMC_STATUS);
+		printk(KERN_ERR "%s: cmd crc error\n", DRIVER_NAME);
+		cmd->error = -EILSEQ;
+	}
+
+	/* Read response from the card */
+	switch (RSP_TYPE(mmc_resp_type(cmd))) {
+	case RSP_TYPE(MMC_RSP_R1):	/* r1, r1b, r6 */
+		a = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		b = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		c = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		cmd->resp[0] = a << 24 | b << 8 | c >> 8;
+		break;
+	case RSP_TYPE(MMC_RSP_R3):	/* r3, r4 */
+		a = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		b = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		c = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+		cmd->resp[0] = a << 24 | b << 8 | c >> 8;
+		break;
+	case RSP_TYPE(MMC_RSP_R2):
+		for (i = 0; i < 4; i++) {
+			a = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+			b = fsl_readl(host->ioaddr + MMC_RES_FIFO) & 0xffff;
+			cmd->resp[i] = a << 16 | b;
+		}
+		break;
+	default:
+		break;
+	}
+
+	pr_debug("%s: 0x%08x, 0x%08x, 0x%08x, 0x%08x\n", DRIVER_NAME,
+		cmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3]);
+
+	if (!host->data || cmd->error) {
+		/* complete the command */
+		esdhc_finish_request(host, host->mrq);
+		return 1;
+	}
+
+	/* The command has a data transfer */
+	no_of_bytes = data->blocks * data->blksz;
+#ifdef MEASURE_TIME
+	if (data->flags & MMC_DATA_WRITE) {
+		do_gettimeofday(tv);
+		int time_microsec = tv->tv_usec ;
+		printk(KERN_INFO "time_begin_write= %d bytes= %d\n",
+				time_microsec, no_of_bytes);
+	}
+#endif
+	host->dma_size = no_of_bytes ;
+	buf = (unsigned long *)(dma_addr_t)(page_address((struct page *) \
+				(data->sg->page_link)) + data->sg->offset);
+	sg = data->sg;
+
+	/* calculate the number of bytes requested for transfer */
+	no_of_words = (no_of_bytes + 3) / 4;
+	pr_debug("no_of_words=%d\n", no_of_words);
+
+	/* Use PIO tranfer of data */
+
+	if (data->flags & MMC_DATA_READ) {
+		for (i = 0; i < no_of_words; i++) {
+			/* wait for buffers to be ready for read */
+
+			while (!(fsl_readl(host->ioaddr + MMC_STATUS) \
+				& (STATUS_BUF_READ_RDY | STATUS_READ_OP_DONE)));
+
+			/* read 32 bit data */
+			temp_data = fsl_readl(host->ioaddr + MMC_BUFFER_ACCESS);
+			/* ALLGO BUGFIX: MMC data is LE */
+			temp_data = cpu_to_le32(temp_data);
+			if (no_of_bytes >= 4) {
+				*buf++ = temp_data;
+				no_of_bytes -= 4;
+			}
+		}
+
+
+		/* wait for read operation completion bit */
+		while (!(fsl_readl(host->ioaddr + MMC_STATUS) & \
+				 STATUS_READ_OP_DONE)) ;
+
+		/* check for time out and CRC errors */
+		status = fsl_readl(host->ioaddr + MMC_STATUS);
+		if (status & STATUS_TIME_OUT_READ) {
+			pr_debug("%s: Read time out occurred\n", DRIVER_NAME);
+			printk(KERN_INFO "read time out error\n");
+			data->error = -ETIMEDOUT;
+			fsl_writel(STATUS_TIME_OUT_READ,
+					   host->ioaddr + MMC_STATUS);
+		} else if (status & STATUS_READ_CRC_ERR) {
+			pr_debug("%s: Read CRC error occurred\n", DRIVER_NAME);
+			printk(KERN_INFO "CRC error\n");
+			data->error = -EILSEQ;
+			fsl_writel(STATUS_READ_CRC_ERR,
+					   host->ioaddr + MMC_STATUS);
+		}
+		fsl_writel(STATUS_READ_OP_DONE, host->ioaddr + MMC_STATUS);
+
+		pr_debug("%s: Read %u words\n", DRIVER_NAME, i);
+		esdhc_data_done(host, status);
+
+
+		return 1;
+
+
+	}
+	if (data->flags & MMC_DATA_WRITE) {
+		for (i = 0; i < no_of_words; i++) {
+
+			/* wait for buffers to be ready for write */
+			while (!(fsl_readl(host->ioaddr + MMC_STATUS) & \
+				STATUS_BUF_WRITE_RDY)) ;
+
+			/* write 32 bit data */
+			/* ALLGO BUGFIX: MMC data is LE */
+			fsl_writel(cpu_to_le32(*buf++), \
+					host->ioaddr + MMC_BUFFER_ACCESS);
+
+			if (fsl_readl(host->ioaddr + MMC_STATUS) & \
+					STATUS_WRITE_OP_DONE)
+				break;
+		}
+
+		/* wait for write operation completion bit */
+		while (!(fsl_readl(host->ioaddr + MMC_STATUS) & \
+				STATUS_WRITE_OP_DONE)) ;
+
+		/* check for CRC errors */
+		status = fsl_readl(host->ioaddr + MMC_STATUS);
+		if (status & STATUS_WRITE_CRC_ERR) {
+			pr_debug("%s: Write CRC error occurred\n", DRIVER_NAME);
+			data->error = -EILSEQ;
+			fsl_writel(STATUS_WRITE_CRC_ERR,
+					   host->ioaddr + MMC_STATUS);
+		}
+		fsl_writel(STATUS_WRITE_OP_DONE, host->ioaddr + MMC_STATUS);
+		pr_debug("%s: Written %u words\n", DRIVER_NAME, i);
+	}
+
+	/* complete the data transfer request */
+	esdhc_data_done(host, status);
+
+#ifdef MEASURE_TIME
+	{
+		do_gettimeofday(tv);
+		int time_microsec = tv->tv_usec	 ;
+		printk(KERN_INFO "returning after data done time "
+			"microsec= %d\n", time_microsec)
+	}
+#endif
+	return 1;
+}
+
+/*!
+ * This function is called when the data transfer is completed either by DMA
+ * or by core. This function is called to clean up the DMA buffer and to send
+ * STOP transmission command for commands to transfer data. This function
+ * completes request issued by the MMC/SD core driver.
+ *
+ * @param host   pointer to MMC/SD host structure.
+ * @param stat   content of SDHC Status Register
+ *
+ * @return This function returns 0 if no data transfer otherwise return 1
+ * always.
+ */
+static int esdhc_data_done(struct esdhc_host *host, unsigned int stat)
+{
+	struct mmc_data *data = host->data;
+
+	if (!data)
+		return 0;
+
+	if (fsl_readl(host->ioaddr + MMC_STATUS) & STATUS_ERR_MASK) {
+		pr_debug("%s: request failed. status: 0x%08x\n",
+			 DRIVER_NAME, fsl_readl(host->ioaddr + MMC_STATUS));
+	}
+
+	host->data = NULL;
+	data->bytes_xfered = host->dma_size;
+
+	if (host->mrq->stop && (data->error == 0))
+		esdhc_start_cmd(host, host->mrq->stop, 0);
+	else
+		esdhc_finish_request(host, host->mrq);
+
+	return 1;
+}
+
+
+static void esdhc_set_power(struct esdhc_host *host, unsigned short power)
+{
+
+	if (host->power == power)
+		return;
+
+	if (power == (unsigned short)-1)
+		host->power = power;
+}
+
+/*!
+ * This function is called by MMC/SD Bus Protocol driver to issue a MMC
+ * and SD commands to the SDHC.
+ *
+ * @param  mmc  Pointer to MMC/SD host structure
+ * @param  mrq  Pointer to MMC/SD command request structure
+ */
+static void esdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct esdhc_host *host = mmc_priv(mmc);
+	/* Holds the value of Command and Data Control Register */
+	unsigned long cmdat;
+
+
+	WARN_ON(host->mrq != NULL);
+
+	host->mrq = mrq;
+#ifdef CONFIG_MMC_DEBUG
+	dump_cmd(req->cmd);
+	dump_status(__func__, __raw_readl(host->base + MMC_STATUS));
+#endif
+
+	cmdat = 0;
+	if (mrq->data) {
+		esdhc_setup_data(host, mrq->data);
+
+		cmdat |= CMD_DAT_CONT_DATA_ENABLE;
+
+		if (mrq->data->flags & MMC_DATA_WRITE)
+			cmdat |= CMD_DAT_CONT_WRITE;
+
+		if (mrq->data->flags & MMC_DATA_STREAM) {
+			printk(KERN_ERR
+				   "MXC MMC does not support stream mode\n");
+		}
+	}
+	esdhc_start_cmd(host, mrq->cmd, cmdat);
+}
+
+/*!
+ * This function is called by MMC/SD Bus Protocol driver to change the clock
+ * speed of MMC or SD card
+ *
+ * @param mmc Pointer to MMC/SD host structure
+ * @param ios Pointer to MMC/SD I/O type structure
+ */
+static void esdhc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct esdhc_host *host = mmc_priv(mmc);
+	/*This variable holds the value of clock prescaler */
+	int prescaler;
+	int clk_rate = clk_get_rate(host->sdhc_clk);
+
+	if (ios->power_mode == MMC_POWER_OFF)
+		esdhc_set_power(host, -1);
+	else
+		esdhc_set_power(host, ios->vdd);
+
+	printk("\n\t%s: clock %u, bus %lu, power %u, vdd %u\n", DRIVER_NAME, \
+		ios->clock, 1UL << ios->bus_width, ios->power_mode, ios->vdd);
+
+	if (ios->clock) {
+		unsigned int clk_dev = 0;
+
+		if (ios->clock == mmc->f_min)
+			prescaler = 16;
+		else
+			prescaler = 0;
+
+		while (prescaler <= 0x800) {
+			for (clk_dev = 1; clk_dev <= 0xF; clk_dev++) {
+				int x;
+				if (prescaler != 0) {
+					x = (clk_rate / (clk_dev + 1)) /
+						(prescaler * 2);
+				} else {
+					x = clk_rate / (clk_dev + 1);
+				}
+
+				pr_debug("x=%d, clock=%d %d\n", x, ios->clock,
+						 clk_dev);
+				if (x <= ios->clock)
+					break;
+
+			}
+			if (clk_dev < 0x10)
+				break;
+
+			if (prescaler == 0)
+				prescaler = 1;
+			else
+				prescaler <<= 1;
+		}
+
+		pr_debug("prescaler = 0x%x, divider = 0x%x\n", prescaler,
+				 clk_dev);
+		esdhc_stop_clock(host, true);
+
+		fsl_writel((prescaler << 4) | clk_dev,
+				   host->ioaddr + MMC_CLK_RATE);
+
+		esdhc_start_clock(host, false);
+
+	} else {
+		esdhc_stop_clock(host, true);
+	}
+}
+
+/*!
+ * MMC/SD host operations structure.
+ * These functions are registered with MMC/SD Bus protocol driver.
+ */
+static const struct mmc_host_ops esdhc_ops = {
+	.request        = esdhc_request,
+	.set_ios        = esdhc_set_ios,
+};
+
+/*!
+ * Interrupt service routine registered to handle the SDHC interrupts.
+ * This interrupt routine handles end of command, card insertion and
+ * card removal interrupts. If the interrupt is card insertion or removal then
+ * inform the MMC/SD core driver to detect the change in physical connections.
+ * If the command is END_CMD_RESP read the Response FIFO.
+ *
+ * @param   irq    the interrupt number
+ * @param   devid  driver private data
+ * @param   regs   holds a snapshot of the processor's context before the
+ *                 processor entered the interrupt code
+ *
+ * @return  The function returns \b IRQ_RETVAL(1) if interrupt was handled,
+ *          returns \b IRQ_RETVAL(0) if the interrupt was not handled.
+ */
+
+
+static irqreturn_t esdhc_irq(int irq, void *dev_id)
+{
+	struct esdhc_host *host = dev_id;
+	irqreturn_t result = IRQ_HANDLED;
+	unsigned int status = 0;
+
+	status = fsl_readl(host->ioaddr + MMC_STATUS);
+
+	if (status & (STATUS_CARD_INSERTION | STATUS_CARD_REMOVAL)) {
+		if (status & STATUS_CARD_INSERTION)
+			setbits32(host->ioaddr + MMC_STATUS, \
+					STATUS_CARD_INSERTION);
+
+		if (status & STATUS_CARD_REMOVAL)
+			setbits32(host->ioaddr + MMC_STATUS, \
+					STATUS_CARD_REMOVAL);
+	}
+
+	if (status & STATUS_END_CMD_RESP) {
+		setbits32(host->ioaddr + MMC_STATUS, STATUS_END_CMD_RESP);
+		esdhc_cmd_done(host, status);
+	}
+
+	mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+	return result;
+}
+
+/*****************************************************************************\
+ *                                                                           *
+ * Device probing/removal                                                    *
+ *                                                                           *
+ \*****************************************************************************/
+
+static void esdhc_remove_slot(struct of_device *ofdev, int slot)
+{
+	struct esdhc_chip *chip;
+	struct mmc_host *mmc;
+	struct esdhc_host *host;
+
+	chip = dev_get_drvdata(&(ofdev->dev));
+	host = chip->hosts[slot];
+	mmc = host->mmc;
+
+	chip->hosts[slot] = NULL;
+
+	mmc_remove_host(mmc);
+
+	esdhc_softreset(host);
+
+	free_irq(host->irq, host);
+
+	iounmap(host->ioaddr);
+
+	release_mem_region(host->addr, host->size);
+
+	mmc_free_host(mmc);
+}
+
+static int __devinit esdhc_probe_slot(struct of_device *ofdev, int slot)
+{
+	struct device_node *np = ofdev->node;
+	struct device_node *cpu;
+	int ret;
+	struct esdhc_chip *chip;
+	struct mmc_host *mmc;
+	struct esdhc_host *host;
+	struct resource res;
+
+	chip = dev_get_drvdata(&(ofdev->dev));
+	BUG_ON(!chip);
+
+	mmc = mmc_alloc_host(sizeof(struct esdhc_host), &(ofdev->dev));
+	if (!mmc)
+		return -ENOMEM;
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+
+	host->chip = chip;
+	chip->hosts[slot] = host;
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		goto free;
+
+	host->addr = res.start;
+
+	host->size = res.end - res.start + 1;
+	host->irq = irq_of_parse_and_map(np, 0);
+
+	printk(KERN_DEBUG "slot %d at 0x%08lx, irq %d and size = %x\n",
+		   slot, host->addr, host->irq, host->size);
+
+	snprintf(host->slot_descr, 20, "esdhc:slot%d", slot);
+
+	if (!request_mem_region(host->addr, host->size, DRIVER_NAME)) {
+		ret = -EBUSY;
+		goto release;
+	}
+
+	host->ioaddr = ioremap(host->addr, host->size);
+	if (!host->ioaddr) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	host->sdhc_clk = clk_get(&ofdev->dev, "sdhc_clk");
+	clk_enable(host->sdhc_clk);
+
+	esdhc_softreset(host);
+
+	fsl_writel(READ_TO_VALUE, host->ioaddr + MMC_READ_TO);
+	fsl_writel(INT_CNTR_END_CMD_RES, host->ioaddr + MMC_INT_CNTR);
+
+	cpu = of_find_node_by_type(NULL, "cpu");
+	if (cpu) {
+		unsigned int size;
+		const u32 *prop = of_get_property(cpu, "bus-frequency", &size);
+		host->max_clk = *prop;
+		of_node_put(cpu);
+	} else
+		host->max_clk = 396000000;
+
+	mmc->ops = &esdhc_ops;
+	mmc->f_min = 300000;
+	mmc->f_max = min((int)host->max_clk, 25000000);
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+
+	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_29_30 | \
+			 MMC_VDD_30_31 |  MMC_VDD_165_195;
+
+	spin_lock_init(&host->lock);
+
+#ifdef CONFIG_MMC_DEBUG
+	esdhc_dumpregs(host);
+#endif
+
+	ret = request_irq(host->irq, esdhc_irq, IRQF_SHARED,
+					  host->slot_descr, host);
+
+	if (ret)
+		goto release;
+
+	mmiowb();
+
+	mmc_add_host(mmc);
+
+	printk(KERN_INFO "%s: ESDHC at 0x%08lx irq %d %s\n", mmc_hostname(mmc),
+		   host->addr, host->irq,
+		   (host->flags & ESDHC_USE_DMA) ? "DMA" : "PIO");
+
+	return 0;
+
+release:
+	release_mem_region(host->addr, host->size);
+free:
+	mmc_remove_host(mmc);
+	return ret;
+}
+
+static int __devinit
+esdhc_probe(struct of_device *ofdev, const struct of_device_id *match)
+{
+	int ret = 1, i;
+	u8 slots;
+	struct esdhc_chip *chip;
+	printk(KERN_INFO "calling from _devinit esdhc_probe \n");
+	BUG_ON(ofdev == NULL);
+	BUG_ON(match == NULL);
+
+	slots = ESDHC_SLOTS_NUMBER;
+	DBG("found %d slot(s)", slots);
+	if (slots == 0)
+		return -ENODEV;
+
+	chip = kmalloc(sizeof(struct esdhc_chip) +
+			sizeof(struct esdhc_host *) * slots, GFP_KERNEL);
+	if (!chip) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	chip->ofdev = ofdev;
+	chip->num_slots = slots;
+	dev_set_drvdata(&(ofdev->dev), chip);
+
+	for (i = 0; i < slots; i++) {
+		ret = 0;
+		ret = esdhc_probe_slot(ofdev, i);
+
+		if (ret) {
+			for (i--; i >= 0; i--)
+				esdhc_remove_slot(ofdev, i);
+
+			goto free;
+		}
+	}
+
+	return 0;
+
+free:
+	dev_set_drvdata(&(ofdev->dev), NULL);
+	kfree(chip);
+
+err:
+	return ret;
+}
+
+static int __devexit esdhc_remove(struct of_device *ofdev)
+{
+	int i;
+	struct esdhc_chip *chip;
+
+	chip = dev_get_drvdata(&(ofdev->dev));
+
+	if (chip) {
+		for (i = 0; i < chip->num_slots; i++)
+			esdhc_remove_slot(ofdev, i);
+
+
+		dev_set_drvdata(&(ofdev->dev), NULL);
+		kfree(chip);
+	}
+
+	return 0;
+}
+
+#define esdhc_suspend NULL
+#define esdhc_resume NULL
+
+/*-------------------------------------------------------------------------*/
+static struct of_device_id fsl_esdhc_match[] = {
+	{
+		.compatible = "fsl,mpc5121-esdhc",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, fsl_esdhc_match);
+
+static struct of_platform_driver esdhc_driver = {
+	.owner = 	THIS_MODULE,
+	.name =         DRIVER_NAME,
+	.match_table =  fsl_esdhc_match,
+	.probe =        esdhc_probe,
+	.remove =       __devexit_p(esdhc_remove),
+	.suspend =      esdhc_suspend,
+	.resume =       esdhc_resume,
+};
+
+/*****************************************************************************\
+ *                                                                           *
+ * Driver init/exit                                                          *
+ *                                                                           *
+ \*****************************************************************************/
+
+static int __init esdhc_drv_init(void)
+{
+	printk(KERN_INFO DRIVER_NAME
+	   ": Freescale Enhanced Secure Digital Host Controller driver\n");
+
+	return of_register_platform_driver(&esdhc_driver);
+}
+
+static void __exit esdhc_drv_exit(void)
+{
+	DBG("Exiting\n");
+
+	of_unregister_platform_driver(&esdhc_driver);
+}
+
+module_init(esdhc_drv_init);
+module_exit(esdhc_drv_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("Enhanced Secure Digital Host Controller driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/esdhc.h b/drivers/mmc/host/esdhc.h
new file mode 100644
index 0000000..9238d1d
--- /dev/null
+++ b/drivers/mmc/host/esdhc.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ESDHC_MMC_REG_H__
+#define __ESDHC_MMC_REG_H__
+
+/*!
+ * @file esdhc.h
+ *
+ * @brief Driver for the Freescale Semiconductor SDHC module.
+ *
+ * This file defines offsets and bits of SDHC registers.SDHC is also referred as
+ * MMC/SD controller
+ *
+ * @ingroup MMC_SD
+ */
+
+
+/* Address offsets of the SDHC registers */
+
+#define MMC_STR_STP_CLK                 0x00    /* Clock Control Reg */
+#define MMC_STATUS                      0x04    /* Status Reg */
+#define MMC_CLK_RATE                    0x08    /* Clock Rate Reg */
+#define MMC_CMD_DAT_CONT                0x0C    /* Command and Datacont reg */
+#define MMC_RES_TO                      0x10    /* Response Time-out Reg */
+#define MMC_READ_TO                     0x14    /* Read Time-out Reg */
+#define MMC_BLK_LEN                     0x18    /* Block Length Reg */
+#define MMC_NOB                         0x1C    /* Number of Blocks Reg */
+#define MMC_REV_NO                      0x20    /* Revision Number Reg */
+#define MMC_INT_CNTR                    0x24    /* Interrupt Control Reg */
+#define MMC_CMD                         0x28    /* Command Number Reg */
+#define MMC_ARG                         0x2C    /* Command Argument Reg */
+#define MMC_RES_FIFO                    0x34    /* Command Response Reg */
+#define MMC_BUFFER_ACCESS               0x38    /* Data Buffer Access Reg */
+
+/* Bit definitions for STR_STP_CLK */
+#define STR_STP_CLK_IPG_CLK_GATE_DIS    (1<<15)
+#define STR_STP_CLK_IPG_PERCLK_GATE_DIS (1<<14)
+#define STR_STP_CLK_RESET               (1<<3)
+#define STR_STP_CLK_START_CLK           (1<<1)
+#define STR_STP_CLK_STOP_CLK            (1<<0)
+
+/* Bit definitions for STATUS */
+#define STATUS_CARD_INSERTION           (1<<31)
+#define STATUS_CARD_REMOVAL             (1<<30)
+#define STATUS_YBUF_EMPTY               (1<<29)
+#define STATUS_XBUF_EMPTY               (1<<28)
+#define STATUS_YBUF_FULL                (1<<27)
+#define STATUS_XBUF_FULL                (1<<26)
+#define STATUS_BUF_UND_RUN              (1<<25)
+#define STATUS_BUF_OVFL                 (1<<24)
+#define STATUS_SDIO_INT_ACTIVE          (1<<14)
+#define STATUS_END_CMD_RESP             (1<<13)
+#define STATUS_WRITE_OP_DONE            (1<<12)
+#define STATUS_READ_OP_DONE             (1<<11)
+#define STATUS_WR_CRC_ERROR_CODE_MASK   (3<<10)
+#define STATUS_CARD_BUS_CLK_RUN         (1<<8)
+#define STATUS_BUF_READ_RDY             (1<<7)
+#define STATUS_BUF_WRITE_RDY            (1<<6)
+#define STATUS_RESP_CRC_ERR             (1<<5)
+#define STATUS_READ_CRC_ERR             (1<<3)
+#define STATUS_WRITE_CRC_ERR            (1<<2)
+#define STATUS_TIME_OUT_RESP            (1<<1)
+#define STATUS_TIME_OUT_READ            (1<<0)
+#define STATUS_ERR_MASK                 0x3f
+
+
+/* Clock rate definitions */
+#define CLK_RATE_PRESCALER(x)           ((x) & 0xF)
+#define CLK_RATE_CLK_DIVIDER(x)         (((x) & 0xF) << 4)
+
+/* Bit definitions for CMD_DAT_CONT */
+#define CMD_DAT_CONT_CMD_RESP_LONG_OFF  (1<<12)
+#define CMD_DAT_CONT_STOP_READWAIT      (1<<11)
+#define CMD_DAT_CONT_START_READWAIT     (1<<10)
+#define CMD_DAT_CONT_BUS_WIDTH_1        (0<<8)
+#define CMD_DAT_CONT_BUS_WIDTH_4        (2<<8)
+#define CMD_DAT_CONT_INIT               (1<<7)
+#define CMD_DAT_CONT_WRITE              (1<<4)
+#define CMD_DAT_CONT_DATA_ENABLE        (1<<3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R1 (1)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R2 (2)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R3 (3)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R4 (4)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R5 (5)
+#define CMD_DAT_CONT_RESPONSE_FORMAT_R6 (6)
+
+/* Bit definitions for INT_CNTR */
+#define INT_CNTR_SDIO_INT_WKP_EN        (1<<18)
+#define INT_CNTR_CARD_INSERTION_WKP_EN  (1<<17)
+#define INT_CNTR_CARD_REMOVAL_WKP_EN    (1<<16)
+#define INT_CNTR_CARD_INSERTION_EN      (1<<15)
+#define INT_CNTR_CARD_REMOVAL_EN        (1<<14)
+#define INT_CNTR_SDIO_IRQ_EN            (1<<13)
+#define INT_CNTR_DAT0_EN                (1<<12)
+#define INT_CNTR_BUF_READ_EN            (1<<4)
+#define INT_CNTR_BUF_WRITE_EN           (1<<3)
+#define INT_CNTR_END_CMD_RES            (1<<2)
+#define INT_CNTR_WRITE_OP_DONE          (1<<1)
+#define INT_CNTR_READ_OP_DONE		(1<<0)
+#define INT_CNTR_NO_INTR		(0)
+
+
+#define ESDHC_SLOTS_NUMBER		1
+#define READ_TO_VALUE                   0x2db4
+
+
+struct esdhc_chip;
+
+struct esdhc_host {
+	struct fsl_dma_requestbuf   *dma;
+
+	struct esdhc_chip	*chip;
+	struct mmc_host		*mmc;		/* MMC structure */
+
+	spinlock_t		lock;		/* Mutex */
+
+	int			flags;		/* Host attributes */
+#define ESDHC_USE_DMA		(1<<0)
+
+	unsigned int		max_clk;	/* Max possible freq (MHz) */
+	unsigned int		timeout_clk;	/* Timeout freq (KHz) */
+
+	unsigned int		clock;		/* Current clock (MHz) */
+	unsigned short		power;		/* Current voltage */
+	unsigned short		bus_width;	/* current bus width */
+
+	struct mmc_request	*mrq;		/* Current request */
+	struct mmc_command	*cmd;		/* Current command */
+	struct mmc_data		*data;		/* Current data request */
+
+	struct scatterlist	*cur_sg;	/* We're working on this */
+	int			num_sg;		/* Entries left */
+	int			offset;		/* Offset into current sg */
+	int			remain;		/* Bytes left in current */
+
+
+	int			card_insert;
+
+	int			irq;		/* Device IRQ */
+	unsigned long		addr;		/* Bus address */
+	unsigned int		size;		/* IO size */
+	void __iomem		*ioaddr;	/* Mapped address */
+
+	struct tasklet_struct	card_tasklet;	/* Tasklet structures */
+	struct tasklet_struct	finish_tasklet;
+
+	struct timer_list	timer;		/* Timer for timeouts */
+
+	struct clk *sdhc_clk;
+	unsigned int dma_size;
+	int   dma_len;
+	int    dma_available ;
+	enum dma_data_direction    dma_dir; /* added for dma ops*/
+
+	char			slot_descr[20];	/* Name for reservations */
+
+
+} __attribute__ ((aligned(4)));
+
+struct esdhc_chip {
+	struct of_device	*ofdev;
+
+	unsigned long		quirks;
+
+	int			num_slots;	/* Slots on controller */
+	struct esdhc_host	*hosts[0];	/* Pointers to hosts */
+};
+
+extern void do_gettimeofday(struct timeval *tv);
+extern void __iomem *port_ioaddr;
+
+#endif		 /* __ESDHC_MMC_REG_H__ */
diff --git a/drivers/mmc/host/iocontrol.c b/drivers/mmc/host/iocontrol.c
new file mode 100644
index 0000000..e4319da
--- /dev/null
+++ b/drivers/mmc/host/iocontrol.c
@@ -0,0 +1,156 @@
+/* This file was received from Freescale Semiconductor, Inc. as a
+ * distribution of reference source to enable the MPC5121e ADS board.
+ * Freescale did not apply a comment header to this file, so Wind River
+ * has provided one. The fact that Freescale distributed these sources
+ * in the manner they did accompanying code with proper copyright and
+ * explicit license assignment, implies that this code is very probably
+ * copyright 2008 Freescale Semiconductor Inc, and distributed under GNU
+ * General Public GPLv2 or later licensing. Wind River honors the
+ * implied attribution and licensing.
+ */
+
+/*******************************************************************************
+ *
+ * This file contains the function required for configuring the input/output
+ * pins of the processor required for SDHC module.
+ ******************************************************************************/
+
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <asm/of_platform.h>
+#include <asm/dma.h>
+#include <asm/page.h>
+#include <asm/reg.h>
+
+#define DRIVER_NAME "SDHC_IOMUX"
+
+#define J1_SDHC_CLK 0X00000080
+#define K5_SDHC_CMD 0X00000080
+#define J2_SDHC_D0 0X00000080
+#define J3_SDHC_D1_IRQ 0X00000080
+#define J4_SDHC_D2 0X00000080
+#define H2_SDHC_D3_CD 0X00000080
+#define CLK_LINE 0X0C4
+#define CMD_LINE 0X0C8
+#define D0_LINE 0X0CC
+#define D1_LINE 0X0D0
+#define D2_LINE 0X0D4
+#define D3_CD_LINE 0X0D8
+
+
+#define PU_ENABLE 0x00000018
+#define DATA_SKEW_RATE_STD_4 0x00000003
+#define PU_ENABLE_PULL_DOWN 0x00000008
+
+void __iomem *ioaddr;
+void __iomem *port_ioaddr ;
+unsigned long addr;
+unsigned int size;
+
+static inline void fsl_writel(unsigned __iomem *addr, u32 val)
+{
+	out_be32(addr, val);
+}
+
+static inline u32 fsl_readl(unsigned __iomem *addr)
+{
+	u32 val;
+	val = in_be32(addr);
+	return val;
+}
+
+static int __devexit iocontrol_remove(struct of_device *ofdev)
+{
+	iounmap(ioaddr);
+	release_mem_region(addr, size);
+	return 0;
+}
+
+/*******************************************************************************
+ *This function configures port pins for 4 data lines and 1 command line and 1
+ *clock signal required for SDHC module. Data lines D0,D1,D2 and Command line
+ *CMD are configured in pull up mode whereas Data line D3 is configured in pull
+ *down mode.
+ ******************************************************************************/
+static int __devinit
+iocontrol_probe(struct of_device *ofdev, const struct of_device_id *match)
+{
+	struct device_node *np = ofdev->node;
+	struct resource res;
+	int ret = -1;
+
+	ret = of_address_to_resource(np, 0, &res);
+	if (ret)
+		return -EBUSY;
+
+	addr = res.start;
+	size = res.end - res.start + 1;
+
+
+	if (!request_mem_region(addr, size, DRIVER_NAME)) {
+		ret = -EBUSY;
+		goto release;
+	}
+
+	ioaddr = ioremap_nocache(addr, size);
+	port_ioaddr = ioaddr ;
+	if (!ioaddr) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	fsl_writel(ioaddr + CLK_LINE, J1_SDHC_CLK | DATA_SKEW_RATE_STD_4);
+	fsl_writel(ioaddr + CMD_LINE, K5_SDHC_CMD | DATA_SKEW_RATE_STD_4 | \
+					PU_ENABLE);
+	fsl_writel(ioaddr + D0_LINE, J2_SDHC_D0 | DATA_SKEW_RATE_STD_4 | \
+					PU_ENABLE);
+	fsl_writel(ioaddr + D1_LINE, J3_SDHC_D1_IRQ | DATA_SKEW_RATE_STD_4 | \
+					PU_ENABLE);
+	fsl_writel(ioaddr + D2_LINE, J4_SDHC_D2 | DATA_SKEW_RATE_STD_4 | \
+					PU_ENABLE);
+	fsl_writel(ioaddr + D3_CD_LINE, H2_SDHC_D3_CD | DATA_SKEW_RATE_STD_4 | \
+					PU_ENABLE_PULL_DOWN);
+
+	return 0;
+
+release:
+	release_mem_region(addr, size);
+	return ret;
+}
+EXPORT_SYMBOL(port_ioaddr);
+
+static struct of_device_id iocontrol_match[] = {
+	{
+		.compatible =  "fsl,mpc5121-ioctl",
+	},
+	{},
+};
+
+static struct of_platform_driver iocontrol_driver = {
+	.owner =        THIS_MODULE,
+	.name =         DRIVER_NAME,
+	.match_table =  iocontrol_match,
+	.probe =        iocontrol_probe,
+	.remove =       __devexit_p(iocontrol_remove),
+};
+
+static int __init io_drv_init(void)
+{
+	printk(KERN_INFO DRIVER_NAME
+		   "IO Configuration for SDHC driver\n");
+
+	return of_register_platform_driver(&iocontrol_driver);
+}
+
+static void __exit io_drv_exit(void)
+{
+	of_unregister_platform_driver(&iocontrol_driver);
+}
+
+module_init(io_drv_init);
+module_exit(io_drv_exit);
+
+MODULE_AUTHOR("@allgosystems.com>");
+MODULE_DESCRIPTION("Configuration of SDHC Lines");
+MODULE_LICENSE("GPL");
-- 
1.6.0.90.g436ed

