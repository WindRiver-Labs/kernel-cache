From f3636be03776b3920bcd177ee46f3f1f931bd80a Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Fri, 7 Jan 2011 16:58:41 -0800
Subject: [PATCH 85/97] MIPS: Octeon: Interrupt handling re-write to support CN68XX

Source: Cavium SDK 2.1.0-407

General update of interrupt handling to support CN68XX.

Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c           | 1480 ++++++++++++++++--------
 arch/mips/cavium-octeon/setup.c                |   20 +-
 arch/mips/cavium-octeon/smp.c                  |   24 +-
 arch/mips/include/asm/mach-cavium-octeon/irq.h |  239 ++---
 arch/mips/include/asm/octeon/octeon.h          |    6 +
 arch/mips/pci/msi-octeon.c                     |  122 ++
 6 files changed, 1225 insertions(+), 666 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index 7e568ba..bed0039 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -3,18 +3,51 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004-2008 Cavium Networks
+ * Copyright (C) 2004-2010 Cavium Networks
  */
+
+#include <linux/bitops.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
+#include <linux/percpu.h>
 #include <linux/smp.h>
 
 #include <asm/octeon/octeon.h>
+#include <asm/octeon/cvmx-ciu2-defs.h>
 
 DEFINE_SPINLOCK(octeon_irq_ciu0_spinlock);
 DEFINE_SPINLOCK(octeon_irq_ciu1_spinlock);
 
-static int octeon_coreid_for_cpu(int cpu)
+static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu0_en_mirror);
+static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu1_en_mirror);
+
+static __read_mostly u8 octeon_irq_ciu_to_irq[8][64];
+
+union octeon_ciu_chip_data {
+	void *p;
+	unsigned long l;
+	struct {
+		unsigned int line:6;
+		unsigned int bit:6;
+	} s;
+};
+
+static void __init octeon_irq_set_ciu_mapping(int irq, int line, int bit,
+					      struct irq_chip *chip, irq_flow_handler_t handler)
+{
+	union octeon_ciu_chip_data cd;
+
+	set_irq_chip_and_handler(irq, chip, handler);
+
+	cd.l = 0;
+	cd.s.line = line;
+	cd.s.bit = bit;
+
+	set_irq_chip_data(irq, cd.p);
+	octeon_irq_ciu_to_irq[line][bit] = irq;
+}
+
+int octeon_coreid_for_cpu(int cpu)
 {
 #ifdef CONFIG_SMP
 	return cpu_logical_map(cpu);
@@ -23,6 +56,15 @@ static int octeon_coreid_for_cpu(int cpu)
 #endif
 }
 
+static int octeon_cpu_for_coreid(int coreid)
+{
+#ifdef CONFIG_SMP
+	return cpu_number_map(coreid);
+#else
+	return smp_processor_id();
+#endif
+}
+
 static void octeon_irq_core_ack(unsigned int irq)
 {
 	unsigned int bit = irq - OCTEON_IRQ_SW0;
@@ -101,65 +143,15 @@ static struct irq_chip octeon_irq_chip_core = {
 	.eoi = octeon_irq_core_eoi,
 };
 
-
-static void octeon_irq_ciu0_ack(unsigned int irq)
-{
-	switch (irq) {
-	case OCTEON_IRQ_GMX_DRP0:
-	case OCTEON_IRQ_GMX_DRP1:
-	case OCTEON_IRQ_IPD_DRP:
-	case OCTEON_IRQ_KEY_ZERO:
-	case OCTEON_IRQ_TIMER0:
-	case OCTEON_IRQ_TIMER1:
-	case OCTEON_IRQ_TIMER2:
-	case OCTEON_IRQ_TIMER3:
-	{
-		int index = cvmx_get_core_num() * 2;
-		u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
-		/*
-		 * CIU timer type interrupts must be acknoleged by
-		 * writing a '1' bit to their sum0 bit.
-		 */
-		cvmx_write_csr(CVMX_CIU_INTX_SUM0(index), mask);
-		break;
-	}
-	default:
-		break;
-	}
-
-	/*
-	 * In order to avoid any locking accessing the CIU, we
-	 * acknowledge CIU interrupts by disabling all of them.  This
-	 * way we can use a per core register and avoid any out of
-	 * core locking requirements.  This has the side affect that
-	 * CIU interrupts can't be processed recursively.
-	 *
-	 * We don't need to disable IRQs to make these atomic since
-	 * they are already disabled earlier in the low level
-	 * interrupt code.
-	 */
-	clear_c0_status(0x100 << 2);
-}
-
-static void octeon_irq_ciu0_eoi(unsigned int irq)
-{
-	/*
-	 * Enable all CIU interrupts again.  We don't need to disable
-	 * IRQs to make these atomic since they are already disabled
-	 * earlier in the low level interrupt code.
-	 */
-	set_c0_status(0x100 << 2);
-}
-
-static int next_coreid_for_irq(struct irq_desc *desc)
+static int next_cpu_for_irq(struct irq_desc *desc)
 {
 
 #ifdef CONFIG_SMP
-	int coreid;
+	int cpu;
 	int weight = cpumask_weight(desc->affinity);
 
 	if (weight > 1) {
-		int cpu = smp_processor_id();
+		cpu = smp_processor_id();
 		for (;;) {
 			cpu = cpumask_next(cpu, desc->affinity);
 			if (cpu >= nr_cpu_ids) {
@@ -169,83 +161,125 @@ static int next_coreid_for_irq(struct irq_desc *desc)
 				break;
 			}
 		}
-		coreid = octeon_coreid_for_cpu(cpu);
 	} else if (weight == 1) {
-		coreid = octeon_coreid_for_cpu(cpumask_first(desc->affinity));
+		cpu = cpumask_first(desc->affinity);
 	} else {
-		coreid = cvmx_get_core_num();
+		cpu = smp_processor_id();
 	}
-	return coreid;
+	return cpu;
 #else
-	return cvmx_get_core_num();
+	return smp_processor_id();
 #endif
 }
 
-static void octeon_irq_ciu0_enable(unsigned int irq)
+static void octeon_irq_ciu_enable(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
-	int coreid = next_coreid_for_irq(desc);
+	int cpu = next_cpu_for_irq(desc);
+	int coreid = octeon_coreid_for_cpu(cpu);
+	volatile unsigned long *pen;
 	unsigned long flags;
-	uint64_t en0;
-	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+	union octeon_ciu_chip_data cd;
 
-	spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-	en0 = cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-	en0 |= 1ull << bit;
-	cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
-	cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-	spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	cd.p = desc->chip_data;
+
+	if (cd.s.line == 0) {
+		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
+		pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+		set_bit(cd.s.bit, pen);
+		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	} else {
+		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
+		pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+		set_bit(cd.s.bit, pen);
+		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
+		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+	}
 }
 
-static void octeon_irq_ciu0_enable_mbox(unsigned int irq)
+static void octeon_irq_ciu_enable_local(unsigned int irq)
 {
+	struct irq_desc *desc = irq_to_desc(irq);
 	int coreid = cvmx_get_core_num();
+	volatile unsigned long *pen;
 	unsigned long flags;
-	uint64_t en0;
-	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
 
-	spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-	en0 = cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-	en0 |= 1ull << bit;
-	cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
-	cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-	spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	if (cd.s.line == 0) {
+		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
+		pen = &__get_cpu_var(octeon_irq_ciu0_en_mirror);
+		set_bit(cd.s.bit, pen);
+		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	} else {
+		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
+		pen = &__get_cpu_var(octeon_irq_ciu1_en_mirror);
+		set_bit(cd.s.bit, pen);
+		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
+		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+	}
 }
 
-static void octeon_irq_ciu0_disable(unsigned int irq)
+static void octeon_irq_ciu_disable(unsigned int irq)
 {
-	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+	struct irq_desc *desc = irq_to_desc(irq);
 	unsigned long flags;
-	uint64_t en0;
+	volatile unsigned long *pen;
 	int cpu;
-	spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-	for_each_online_cpu(cpu) {
-		int coreid = octeon_coreid_for_cpu(cpu);
-		en0 = cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-		en0 &= ~(1ull << bit);
-		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+
+	if (cd.s.line == 0) {
+		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
+		for_each_online_cpu(cpu) {
+			int coreid = octeon_coreid_for_cpu(cpu);
+			pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+			clear_bit(cd.s.bit, pen);
+			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		}
+		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	} else {
+		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
+		for_each_online_cpu(cpu) {
+			int coreid = octeon_coreid_for_cpu(cpu);
+			pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+			clear_bit(cd.s.bit, pen);
+			cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
+		}
+		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
 	}
-	/*
-	 * We need to do a read after the last update to make sure all
-	 * of them are done.
-	 */
-	cvmx_read_csr(CVMX_CIU_INTX_EN0(cvmx_get_core_num() * 2));
-	spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
 }
 
 /*
  * Enable the irq on the next core in the affinity set for chips that
  * have the EN*_W1{S,C} registers.
  */
-static void octeon_irq_ciu0_enable_v2(unsigned int irq)
+static void octeon_irq_ciu_enable_v2(unsigned int irq)
 {
-	int index;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
 	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	int cpu = next_cpu_for_irq(desc);
+	union octeon_ciu_chip_data cd;
 
-	if ((desc->status & IRQ_DISABLED) == 0) {
-		index = next_coreid_for_irq(desc) * 2;
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	/*
+	 * Called under the desc lock, so these should never get out
+	 * of sync.
+	 */
+	if (cd.s.line == 0) {
+		int index = octeon_coreid_for_cpu(cpu) * 2;
+		set_bit(cd.s.bit, &per_cpu(octeon_irq_ciu0_en_mirror, cpu));
 		cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
+	} else {
+		int index = octeon_coreid_for_cpu(cpu) * 2 + 1;
+		set_bit(cd.s.bit, &per_cpu(octeon_irq_ciu1_en_mirror, cpu));
+		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
 	}
 }
 
@@ -253,83 +287,119 @@ static void octeon_irq_ciu0_enable_v2(unsigned int irq)
  * Enable the irq on the current CPU for chips that
  * have the EN*_W1{S,C} registers.
  */
-static void octeon_irq_ciu0_enable_mbox_v2(unsigned int irq)
+static void octeon_irq_ciu_enable_local_v2(unsigned int irq)
 {
-	int index;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
 
-	index = cvmx_get_core_num() * 2;
-	cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
-}
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
 
-/*
- * Disable the irq on the current core for chips that have the EN*_W1{S,C}
- * registers.
- */
-static void octeon_irq_ciu0_ack_v2(unsigned int irq)
-{
-	int index = cvmx_get_core_num() * 2;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
-
-	switch (irq) {
-	case OCTEON_IRQ_GMX_DRP0:
-	case OCTEON_IRQ_GMX_DRP1:
-	case OCTEON_IRQ_IPD_DRP:
-	case OCTEON_IRQ_KEY_ZERO:
-	case OCTEON_IRQ_TIMER0:
-	case OCTEON_IRQ_TIMER1:
-	case OCTEON_IRQ_TIMER2:
-	case OCTEON_IRQ_TIMER3:
-		/*
-		 * CIU timer type interrupts must be acknoleged by
-		 * writing a '1' bit to their sum0 bit.
-		 */
-		cvmx_write_csr(CVMX_CIU_INTX_SUM0(index), mask);
-		break;
-	default:
-		break;
+	if (cd.s.line == 0) {
+		int index = cvmx_get_core_num() * 2;
+		set_bit(cd.s.bit, &__get_cpu_var(octeon_irq_ciu0_en_mirror));
+		cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
+	} else {
+		int index = cvmx_get_core_num() * 2 + 1;
+		set_bit(cd.s.bit, &__get_cpu_var(octeon_irq_ciu1_en_mirror));
+		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
 	}
+}
 
-	cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+static void octeon_irq_ciu_enable_check_v2(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu_enable_v2(irq);
+}
+
+static void octeon_irq_ciu_enable_local_check_v2(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu_enable_local_v2(irq);
+}
+
+static void octeon_irq_ciu_disable_local_v2(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	if (cd.s.line == 0) {
+		int index = cvmx_get_core_num() * 2;
+		clear_bit(cd.s.bit, &__get_cpu_var(octeon_irq_ciu0_en_mirror));
+		cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+	} else {
+		int index = cvmx_get_core_num() * 2 + 1;
+		clear_bit(cd.s.bit, &__get_cpu_var(octeon_irq_ciu1_en_mirror));
+		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
+	}
 }
 
 /*
- * Enable the irq on the current core for chips that have the EN*_W1{S,C}
- * registers.
+ * Write to the W1C bit in CVMX_CIU_INTX_SUM0 to clear the irq.
  */
-static void octeon_irq_ciu0_eoi_mbox_v2(unsigned int irq)
+static void octeon_irq_ciu_ack(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
-	int index = cvmx_get_core_num() * 2;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
 
-	if (likely((desc->status & IRQ_DISABLED) == 0))
-		cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	if (cd.s.line == 0) {
+		int index = cvmx_get_core_num() * 2;
+		cvmx_write_csr(CVMX_CIU_INTX_SUM0(index), mask);
+	} else {
+		cvmx_write_csr(CVMX_CIU_INT_SUM1, mask);
+	}
 }
 
 /*
  * Disable the irq on the all cores for chips that have the EN*_W1{S,C}
  * registers.
  */
-static void octeon_irq_ciu0_disable_all_v2(unsigned int irq)
+static void octeon_irq_ciu_disable_all_v2(unsigned int irq)
 {
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
-	int index;
 	int cpu;
-	for_each_online_cpu(cpu) {
-		index = octeon_coreid_for_cpu(cpu) * 2;
-		cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	if (cd.s.line == 0) {
+		for_each_online_cpu(cpu) {
+			int index = octeon_coreid_for_cpu(cpu) * 2;
+			clear_bit(cd.s.bit, &per_cpu(octeon_irq_ciu0_en_mirror, cpu));
+			cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+		}
+	} else {
+		for_each_online_cpu(cpu) {
+			int index = octeon_coreid_for_cpu(cpu) * 2 + 1;
+			clear_bit(cd.s.bit, &per_cpu(octeon_irq_ciu1_en_mirror, cpu));
+			cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
+		}
 	}
 }
 
 #ifdef CONFIG_SMP
-static int octeon_irq_ciu0_set_affinity(unsigned int irq, const struct cpumask *dest)
+static int octeon_irq_ciu_set_affinity(unsigned int irq, const struct cpumask *dest)
 {
 	int cpu;
 	struct irq_desc *desc = irq_to_desc(irq);
 	int enable_one = (desc->status & IRQ_DISABLED) == 0;
 	unsigned long flags;
-	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
 
 	/*
 	 * For non-v2 CIU, we will allow only single CPU affinity.
@@ -339,26 +409,40 @@ static int octeon_irq_ciu0_set_affinity(unsigned int irq, const struct cpumask *
 	if (cpumask_weight(dest) != 1)
 		return -EINVAL;
 
-	spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-	for_each_online_cpu(cpu) {
-		int coreid = octeon_coreid_for_cpu(cpu);
-		uint64_t en0 =
-			cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
-		if (cpumask_test_cpu(cpu, dest) && enable_one) {
-			enable_one = 0;
-			en0 |= 1ull << bit;
-		} else {
-			en0 &= ~(1ull << bit);
+	if (desc->status & IRQ_DISABLED)
+		return 0;
+
+	if (cd.s.line == 0) {
+		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
+		for_each_online_cpu(cpu) {
+			int coreid = octeon_coreid_for_cpu(cpu);
+			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+
+			if (cpumask_test_cpu(cpu, dest) && enable_one) {
+				enable_one = 0;
+				set_bit(cd.s.bit, pen);
+			} else {
+				clear_bit(cd.s.bit, pen);
+			}
+			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		}
+		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
+	} else {
+		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
+		for_each_online_cpu(cpu) {
+			int coreid = octeon_coreid_for_cpu(cpu);
+			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+
+			if (cpumask_test_cpu(cpu, dest) && enable_one) {
+				enable_one = 0;
+				set_bit(cd.s.bit, pen);
+			} else {
+				clear_bit(cd.s.bit, pen);
+			}
+			cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
 		}
-		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
+		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
 	}
-	/*
-	 * We need to do a read after the last update to make sure all
-	 * of them are done.
-	 */
-	cvmx_read_csr(CVMX_CIU_INTX_EN0(cvmx_get_core_num() * 2));
-	spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
-
 	return 0;
 }
 
@@ -366,22 +450,46 @@ static int octeon_irq_ciu0_set_affinity(unsigned int irq, const struct cpumask *
  * Set affinity for the irq for chips that have the EN*_W1{S,C}
  * registers.
  */
-static int octeon_irq_ciu0_set_affinity_v2(unsigned int irq,
+static int octeon_irq_ciu_set_affinity_v2(unsigned int irq,
 					   const struct cpumask *dest)
 {
 	int cpu;
-	int index;
 	struct irq_desc *desc = irq_to_desc(irq);
 	int enable_one = (desc->status & IRQ_DISABLED) == 0;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WORKQ0);
-
-	for_each_online_cpu(cpu) {
-		index = octeon_coreid_for_cpu(cpu) * 2;
-		if (cpumask_test_cpu(cpu, dest) && enable_one) {
-			enable_one = 0;
-			cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
-		} else {
-			cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
+
+	if (desc->status & IRQ_DISABLED)
+		return 0;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << cd.s.bit;
+
+	if (cd.s.line == 0) {
+		for_each_online_cpu(cpu) {
+			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+			int index = octeon_coreid_for_cpu(cpu) * 2;
+			if (cpumask_test_cpu(cpu, dest) && enable_one) {
+				enable_one = 0;
+				set_bit(cd.s.bit, pen);
+				cvmx_write_csr(CVMX_CIU_INTX_EN0_W1S(index), mask);
+			} else {
+				clear_bit(cd.s.bit, pen);
+				cvmx_write_csr(CVMX_CIU_INTX_EN0_W1C(index), mask);
+			}
+		}
+	} else {
+		for_each_online_cpu(cpu) {
+			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+			int index = octeon_coreid_for_cpu(cpu) * 2 + 1;
+			if (cpumask_test_cpu(cpu, dest) && enable_one) {
+				enable_one = 0;
+				set_bit(cd.s.bit, pen);
+				cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
+			} else {
+				clear_bit(cd.s.bit, pen);
+				cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
+			}
 		}
 	}
 	return 0;
@@ -389,80 +497,92 @@ static int octeon_irq_ciu0_set_affinity_v2(unsigned int irq,
 #endif
 
 /*
+ * The v1 CIU code already masks things, so supply a dummy version to
+ * the core chip code.
+ */
+static void octeon_irq_dummy_mask(unsigned int irq)
+{
+	return;
+}
+
+/*
  * Newer octeon chips have support for lockless CIU operation.
  */
-static struct irq_chip octeon_irq_chip_ciu0_v2 = {
-	.name = "CIU0",
-	.enable = octeon_irq_ciu0_enable_v2,
-	.disable = octeon_irq_ciu0_disable_all_v2,
-	.eoi = octeon_irq_ciu0_enable_v2,
+static struct irq_chip octeon_irq_chip_ciu_v2 = {
+	.name = "CIU",
+	.enable = octeon_irq_ciu_enable_v2,
+	.disable = octeon_irq_ciu_disable_all_v2,
+	.mask = octeon_irq_ciu_disable_local_v2,
+	.unmask = octeon_irq_ciu_enable_check_v2,
 #ifdef CONFIG_SMP
-	.set_affinity = octeon_irq_ciu0_set_affinity_v2,
+	.set_affinity = octeon_irq_ciu_set_affinity_v2,
 #endif
 };
 
-static struct irq_chip octeon_irq_chip_ciu0 = {
-	.name = "CIU0",
-	.enable = octeon_irq_ciu0_enable,
-	.disable = octeon_irq_ciu0_disable,
-	.eoi = octeon_irq_ciu0_eoi,
+static struct irq_chip octeon_irq_chip_ciu_edge_v2 = {
+	.name = "CIU-E",
+	.enable = octeon_irq_ciu_enable_v2,
+	.disable = octeon_irq_ciu_disable_all_v2,
+	.ack = octeon_irq_ciu_ack,
+	.mask = octeon_irq_ciu_disable_local_v2,
+	.unmask = octeon_irq_ciu_enable_check_v2,
 #ifdef CONFIG_SMP
-	.set_affinity = octeon_irq_ciu0_set_affinity,
+	.set_affinity = octeon_irq_ciu_set_affinity_v2,
 #endif
 };
 
-/* The mbox versions don't do any affinity or round-robin. */
-static struct irq_chip octeon_irq_chip_ciu0_mbox_v2 = {
-	.name = "CIU0-M",
-	.enable = octeon_irq_ciu0_enable_mbox_v2,
-	.disable = octeon_irq_ciu0_disable,
-	.eoi = octeon_irq_ciu0_eoi_mbox_v2,
+static struct irq_chip octeon_irq_chip_ciu = {
+	.name = "CIU",
+	.enable = octeon_irq_ciu_enable,
+	.disable = octeon_irq_ciu_disable,
+	.mask = octeon_irq_dummy_mask,
+#ifdef CONFIG_SMP
+	.set_affinity = octeon_irq_ciu_set_affinity,
+#endif
 };
 
-static struct irq_chip octeon_irq_chip_ciu0_mbox = {
-	.name = "CIU0-M",
-	.enable = octeon_irq_ciu0_enable_mbox,
-	.disable = octeon_irq_ciu0_disable,
-	.eoi = octeon_irq_ciu0_eoi,
+static struct irq_chip octeon_irq_chip_ciu_edge = {
+	.name = "CIU-E",
+	.enable = octeon_irq_ciu_enable,
+	.disable = octeon_irq_ciu_disable,
+	.mask = octeon_irq_dummy_mask,
+	.ack = octeon_irq_ciu_ack,
+#ifdef CONFIG_SMP
+	.set_affinity = octeon_irq_ciu_set_affinity,
+#endif
 };
 
-static void octeon_irq_ciu1_ack(unsigned int irq)
-{
-	/*
-	 * In order to avoid any locking accessing the CIU, we
-	 * acknowledge CIU interrupts by disabling all of them.  This
-	 * way we can use a per core register and avoid any out of
-	 * core locking requirements.  This has the side affect that
-	 * CIU interrupts can't be processed recursively.  We don't
-	 * need to disable IRQs to make these atomic since they are
-	 * already disabled earlier in the low level interrupt code.
-	 */
-	clear_c0_status(0x100 << 3);
-}
+/* The mbox versions don't do any affinity or round-robin. */
+static struct irq_chip octeon_irq_chip_ciu_mbox_v2 = {
+	.name = "CIU-M",
+	.enable = octeon_irq_ciu_enable_local_v2,
+	.disable = octeon_irq_ciu_disable_all_v2,
+	.ack = octeon_irq_ciu_disable_local_v2,
+	.eoi = octeon_irq_ciu_enable_local_check_v2,
+};
 
-static void octeon_irq_ciu1_eoi(unsigned int irq)
-{
-	/*
-	 * Enable all CIU interrupts again.  We don't need to disable
-	 * IRQs to make these atomic since they are already disabled
-	 * earlier in the low level interrupt code.
-	 */
-	set_c0_status(0x100 << 3);
-}
+static struct irq_chip octeon_irq_chip_ciu_mbox = {
+	.name = "CIU-M",
+	.enable = octeon_irq_ciu_enable_local,
+	.disable = octeon_irq_ciu_disable,
+};
 
-static void octeon_irq_ciu1_enable(unsigned int irq)
+/*
+ * Watchdog interrupts are special.  They are associated with a single
+ * core, so we hardwire the affinity to that core.
+ */
+static void octeon_irq_ciu_wd_enable(unsigned int irq)
 {
-	struct irq_desc *desc = irq_to_desc(irq);
-	int coreid = next_coreid_for_irq(desc);
 	unsigned long flags;
-	uint64_t en1;
-	int bit = irq - OCTEON_IRQ_WDOG0;	/* Bit 0-63 of EN1 */
+	int coreid = irq - OCTEON_IRQ_WDOG0;	/* Bit 0-63 of EN1 */
+
+	volatile unsigned long *pen;
+	int cpu = octeon_cpu_for_coreid(coreid);
 
 	spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
-	en1 = cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
-	en1 |= 1ull << bit;
-	cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), en1);
-	cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
+	pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+	set_bit(coreid, pen);
+	cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
 	spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
 }
 
@@ -470,281 +590,733 @@ static void octeon_irq_ciu1_enable(unsigned int irq)
  * Watchdog interrupts are special.  They are associated with a single
  * core, so we hardwire the affinity to that core.
  */
-static void octeon_irq_ciu1_wd_enable(unsigned int irq)
+static void octeon_irq_ciu1_wd_enable_v2(unsigned int irq)
 {
-	unsigned long flags;
-	uint64_t en1;
-	int bit = irq - OCTEON_IRQ_WDOG0;	/* Bit 0-63 of EN1 */
-	int coreid = bit;
+	int coreid = irq - OCTEON_IRQ_WDOG0;
+	int cpu = octeon_cpu_for_coreid(coreid);
 
-	spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
-	en1 = cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
-	en1 |= 1ull << bit;
-	cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), en1);
-	cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
-	spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+	set_bit(coreid, &per_cpu(octeon_irq_ciu1_en_mirror, cpu));
+	cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(coreid * 2 + 1), 1ull << coreid);
 }
 
-static void octeon_irq_ciu1_disable(unsigned int irq)
+
+static struct irq_chip octeon_irq_chip_ciu_wd_v2 = {
+	.name = "CIU-W",
+	.enable = octeon_irq_ciu1_wd_enable_v2,
+	.disable = octeon_irq_ciu_disable_all_v2,
+	.mask = octeon_irq_ciu_disable_local_v2,
+	.unmask = octeon_irq_ciu_enable_local_check_v2,
+};
+
+static struct irq_chip octeon_irq_chip_ciu_wd = {
+	.name = "CIU-W",
+	.enable = octeon_irq_ciu_wd_enable,
+	.disable = octeon_irq_ciu_disable,
+	.mask = octeon_irq_dummy_mask,
+};
+
+void paravirt_arch_init_irq(void)
+	__attribute__ ((weak, alias("native_arch_init_irq")));
+
+static void octeon_irq_ip2_v1(void)
 {
-	int bit = irq - OCTEON_IRQ_WDOG0;	/* Bit 0-63 of EN1 */
-	unsigned long flags;
-	uint64_t en1;
-	int cpu;
-	spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
-	for_each_online_cpu(cpu) {
-		int coreid = octeon_coreid_for_cpu(cpu);
-		en1 = cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
-		en1 &= ~(1ull << bit);
-		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), en1);
+	const unsigned long core_id = cvmx_get_core_num();
+	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INTX_SUM0(core_id * 2));
+
+	ciu_sum &= __get_cpu_var(octeon_irq_ciu0_en_mirror);
+	clear_c0_status(STATUSF_IP2);
+	if (likely(ciu_sum)) {
+		int bit = fls64(ciu_sum) - 1;
+		int irq = octeon_irq_ciu_to_irq[0][bit];
+		if (likely(irq))
+			do_IRQ(irq);
+		else
+			spurious_interrupt();
+	} else {
+		spurious_interrupt();
+	}
+	set_c0_status(STATUSF_IP2);
+}
+
+static void octeon_irq_ip2_v2(void)
+{
+	const unsigned long core_id = cvmx_get_core_num();
+	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INTX_SUM0(core_id * 2));
+
+	ciu_sum &= __get_cpu_var(octeon_irq_ciu0_en_mirror);
+	if (likely(ciu_sum)) {
+		int bit = fls64(ciu_sum) - 1;
+		int irq = octeon_irq_ciu_to_irq[0][bit];
+		if (likely(irq))
+			do_IRQ(irq);
+		else
+			spurious_interrupt();
+	} else {
+		spurious_interrupt();
+	}
+}
+static void octeon_irq_ip3_v1(void)
+{
+	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INT_SUM1);
+
+	ciu_sum &= __get_cpu_var(octeon_irq_ciu1_en_mirror);
+	clear_c0_status(STATUSF_IP3);
+	if (likely(ciu_sum)) {
+		int bit = fls64(ciu_sum) - 1;
+		int irq = octeon_irq_ciu_to_irq[1][bit];
+		if (likely(irq))
+			do_IRQ(irq);
+		else
+			spurious_interrupt();
+	} else {
+		spurious_interrupt();
+	}
+	set_c0_status(STATUSF_IP3);
+}
+
+static void octeon_irq_ip3_v2(void)
+{
+	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INT_SUM1);
+
+	ciu_sum &= __get_cpu_var(octeon_irq_ciu1_en_mirror);
+	if (likely(ciu_sum)) {
+		int bit = fls64(ciu_sum) - 1;
+		int irq = octeon_irq_ciu_to_irq[1][bit];
+		if (likely(irq))
+			do_IRQ(irq);
+		else
+			spurious_interrupt();
+	} else {
+		spurious_interrupt();
+	}
+}
+
+static bool octeon_irq_use_ip4;
+
+static void __cpuinit octeon_irq_local_enable_ip4(void *arg)
+{
+	set_c0_status(STATUSF_IP4);
+}
+
+static void octeon_irq_ip4_mask(void)
+{
+	clear_c0_status(STATUSF_IP4);
+	spurious_interrupt();
+}
+
+static void (*octeon_irq_ip2)(void);
+static void (*octeon_irq_ip3)(void);
+static void (*octeon_irq_ip4)(void);
+
+void (*octeon_irq_setup_secondary)(void);
+
+void __cpuinit octeon_irq_set_ip4_handler(octeon_irq_ip4_handler_t h)
+{
+	octeon_irq_ip4 = h;
+	octeon_irq_use_ip4 = true;
+	on_each_cpu(octeon_irq_local_enable_ip4, NULL, 1);
+}
+
+static void octeon_irq_percpu_enable(void)
+{
+	int i;
+
+	/* Enable the percpu interrupts on this core */
+	for (i = OCTEON_IRQ_SW0; i < OCTEON_IRQ_LAST; i++) {
+		struct irq_desc *desc = irq_to_desc(i);
+		if (desc && desc->handle_irq ==  handle_percpu_irq &&
+			desc->chip && desc->chip->enable) {
+			unsigned long flags;
+			raw_spin_lock_irqsave(&desc->lock, flags);
+			if ((desc->status & IRQ_DISABLED) == 0)
+				desc->chip->enable(i);
+			raw_spin_unlock_irqrestore(&desc->lock, flags);
+		}
 	}
+
+}
+
+static void octeon_irq_init_ciu_percpu(void)
+{
+	int coreid = cvmx_get_core_num();
 	/*
-	 * We need to do a read after the last update to make sure all
-	 * of them are done.
+	 * Disable All CIU Interrupts. The ones we need will be
+	 * enabled later.  Read the SUM register so we know the write
+	 * completed.
 	 */
-	cvmx_read_csr(CVMX_CIU_INTX_EN1(cvmx_get_core_num() * 2 + 1));
-	spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2)), 0);
+	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2 + 1)), 0);
+	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2)), 0);
+	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2 + 1)), 0);
+	cvmx_read_csr(CVMX_CIU_INTX_SUM0((coreid * 2)));
 }
 
-/*
- * Enable the irq on the current core for chips that have the EN*_W1{S,C}
- * registers.
- */
-static void octeon_irq_ciu1_enable_v2(unsigned int irq)
+static void octeon_irq_init_ciu2_percpu(void)
 {
-	int index;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WDOG0);
-	struct irq_desc *desc = irq_to_desc(irq);
+	u64 regx, ipx;
+	int coreid = cvmx_get_core_num();
+	u64 base = CVMX_CIU2_EN_PPX_IP2_WRKQ(coreid);
 
-	if ((desc->status & IRQ_DISABLED) == 0) {
-		index = next_coreid_for_irq(desc) * 2 + 1;
-		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
+	/*
+	 * Disable All CIU2 Interrupts. The ones we need will be
+	 * enabled later.  Read the SUM register so we know the write
+	 * completed.
+	 *
+	 * There are 9 registers and 3 IPX levels with strides 0x1000
+	 * and 0x200 respectivly.  Use loops to clear them.
+	 */
+	for (regx = 0; regx <= 0x8000; regx += 0x1000) {
+		for (ipx = 0; ipx <= 0x400; ipx += 0x200)
+			cvmx_write_csr(base + regx + ipx, 0);
 	}
+
+	cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP2(coreid));
+}
+
+static void octeon_irq_setup_secondary_ciu(void)
+{
+
+	__get_cpu_var(octeon_irq_ciu0_en_mirror) = 0;
+	__get_cpu_var(octeon_irq_ciu1_en_mirror) = 0;
+
+	octeon_irq_init_ciu_percpu();
+	octeon_irq_percpu_enable();
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP3 | STATUSF_IP2);
+	if (octeon_irq_use_ip4)
+		set_c0_status(STATUSF_IP4);
+	else
+		clear_c0_status(STATUSF_IP4);
+}
+
+static void octeon_irq_setup_secondary_ciu2(void)
+{
+	octeon_irq_init_ciu2_percpu();
+	octeon_irq_percpu_enable();
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP3 | STATUSF_IP2);
+	if (octeon_irq_use_ip4)
+		set_c0_status(STATUSF_IP4);
+	else
+		clear_c0_status(STATUSF_IP4);
+}
+
+static void __init octeon_irq_init_ciu(void)
+{
+	unsigned int i;
+	struct irq_chip *chip;
+	struct irq_chip *chip_edge;
+	struct irq_chip *chip_mbox;
+	struct irq_chip *chip_wd;
+
+	octeon_irq_init_ciu_percpu();
+	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu;
+
+	if (OCTEON_IS_MODEL(OCTEON_CN58XX_PASS2_X) ||
+	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS2_X) ||
+	    OCTEON_IS_MODEL(OCTEON_CN52XX_PASS2_X) ||
+	    OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
+		octeon_irq_ip2 = octeon_irq_ip2_v2;
+		octeon_irq_ip3 = octeon_irq_ip3_v2;
+		chip = &octeon_irq_chip_ciu_v2;
+		chip_edge = &octeon_irq_chip_ciu_edge_v2;
+		chip_mbox = &octeon_irq_chip_ciu_mbox_v2;
+		chip_wd = &octeon_irq_chip_ciu_wd_v2;
+	} else {
+		octeon_irq_ip2 = octeon_irq_ip2_v1;
+		octeon_irq_ip3 = octeon_irq_ip3_v1;
+		chip = &octeon_irq_chip_ciu;
+		chip_edge = &octeon_irq_chip_ciu_edge;
+		chip_mbox = &octeon_irq_chip_ciu_mbox;
+		chip_wd = &octeon_irq_chip_ciu_wd;
+	}
+	octeon_irq_ip4 = octeon_irq_ip4_mask;
+
+	/* Mips internal */
+	set_irq_chip_and_handler(OCTEON_IRQ_SW0, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_SW1, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_5, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_PERF, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_TIMER, &octeon_irq_chip_core, handle_percpu_irq);
+
+	/* CIU_0 */
+	for (i = 0; i < 16; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_WORKQ0, 0, i + 0, chip, handle_level_irq);
+	for (i = 0; i < 16; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_GPIO0, 0, i + 16, chip, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MBOX0, 0, 32, chip_mbox, handle_percpu_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MBOX1, 0, 33, chip_mbox, handle_percpu_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_UART0, 0, 34, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_UART1, 0, 35, chip, handle_level_irq);
+
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_PCI_INT0, 0, i + 36, chip, handle_level_irq);
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_PCI_MSI0, 0, i + 40, chip, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TWSI, 0, 45, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RML, 0, 46, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TRACE0, 0, 47, chip, handle_level_irq);
+
+	for (i = 0; i < 2; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_GMX_DRP0, 0, i + 48, chip_edge, handle_edge_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPD_DRP, 0, 50, chip_edge, handle_edge_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_KEY_ZERO, 0, 51, chip_edge, handle_edge_irq);
+
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_TIMER0, 0, i + 52, chip_edge, handle_edge_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_USB0, 0, 56, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PCM, 0, 57, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MPI, 0, 58, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TWSI2, 0, 59, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_POWIQ, 0, 60, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPDPPTHR, 0, 61, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MII0, 0, 62, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_BOOTDMA, 0, 63, chip, handle_level_irq);
+
+	/* CIU_1 */
+	for (i = 0; i < 16; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_WDOG0, 1, i + 0, chip_wd, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_UART2, 1, 16, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_USB1, 1, 17, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MII1, 1, 18, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_NAND, 1, 19, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MIO, 1, 20, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IOB, 1, 21, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_FPA, 1, 22, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_POW, 1, 23, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_L2C, 1, 24, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPD, 1, 25, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PIP, 1, 26, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PKO, 1, 27, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_ZIP, 1, 28, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TIM, 1, 29, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RAD, 1, 30, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_KEY, 1, 31, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_DFA, 1, 32, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_USBCTL, 1, 33, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_SLI, 1, 34, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_DPI, 1, 35, chip, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_AGX0, 1, 36, chip, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_AGL, 1, 46, chip, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PTP, 1, 47, chip_edge, handle_edge_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PEM0, 1, 48, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PEM1, 1, 49, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_SRIO0, 1, 50, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_SRIO1, 1, 51, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_LMC0, 1, 52, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_DFM, 1, 56, chip, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RST, 1, 63, chip, handle_level_irq);
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP3 | STATUSF_IP2);
+	clear_c0_status(STATUSF_IP4);
+}
+
+void __init arch_init_irq(void)
+{
+	paravirt_arch_init_irq();
 }
 
 /*
  * Watchdog interrupts are special.  They are associated with a single
  * core, so we hardwire the affinity to that core.
  */
-static void octeon_irq_ciu1_wd_enable_v2(unsigned int irq)
+static void octeon_irq_ciu2_wd_enable(unsigned int irq)
 {
-	int index;
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	u64 en_addr;
+
 	int coreid = irq - OCTEON_IRQ_WDOG0;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WDOG0);
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(coreid) + (0x1000ull * cd.s.line);
+	cvmx_write_csr(en_addr, mask);
+
+}
+
+static void octeon_irq_ciu2_enable(unsigned int irq)
+{
 	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	u64 en_addr;
+	int cpu = next_cpu_for_irq(desc);
+	int coreid = octeon_coreid_for_cpu(cpu);
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(coreid) + (0x1000ull * cd.s.line);
+	cvmx_write_csr(en_addr, mask);
 
-	if ((desc->status & IRQ_DISABLED) == 0) {
-		index = coreid * 2 + 1;
-		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
-	}
 }
 
-/*
- * Disable the irq on the current core for chips that have the EN*_W1{S,C}
- * registers.
- */
-static void octeon_irq_ciu1_ack_v2(unsigned int irq)
+static void octeon_irq_ciu2_enable_check(unsigned int irq)
 {
-	int index = cvmx_get_core_num() * 2 + 1;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WDOG0);
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu2_enable(irq);
+}
+
+static void octeon_irq_ciu2_enable_local(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	u64 en_addr;
+	int coreid = cvmx_get_core_num();
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(coreid) + (0x1000ull * cd.s.line);
+	cvmx_write_csr(en_addr, mask);
 
-	cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
 }
 
-/*
- * Disable the irq on the all cores for chips that have the EN*_W1{S,C}
- * registers.
- */
-static void octeon_irq_ciu1_disable_all_v2(unsigned int irq)
+static void octeon_irq_ciu2_enable_local_check(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu2_enable_local(irq);
+}
+
+static void octeon_irq_ciu2_disable_local(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	u64 en_addr;
+	int coreid = cvmx_get_core_num();
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(coreid) + (0x1000ull * cd.s.line);
+	cvmx_write_csr(en_addr, mask);
+
+}
+
+static void octeon_irq_ciu2_ack(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	u64 en_addr;
+	int coreid = cvmx_get_core_num();
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
+	en_addr = CVMX_CIU2_RAW_PPX_IP2_WRKQ(coreid) + (0x1000ull * cd.s.line);
+	cvmx_write_csr(en_addr, mask);
+
+}
+
+static void octeon_irq_ciu2_disable_all(unsigned int irq)
 {
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WDOG0);
-	int index;
 	int cpu;
+	struct irq_desc *desc = irq_to_desc(irq);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << (cd.s.bit);
+
 	for_each_online_cpu(cpu) {
-		index = octeon_coreid_for_cpu(cpu) * 2 + 1;
-		cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
+		u64 en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(octeon_coreid_for_cpu(cpu)) + (0x1000ull * cd.s.line);
+		cvmx_write_csr(en_addr, mask);
 	}
 }
 
-#ifdef CONFIG_SMP
-static int octeon_irq_ciu1_set_affinity(unsigned int irq,
-					const struct cpumask *dest)
+static void octeon_irq_ciu2_mbox_disable_all(unsigned int irq)
 {
 	int cpu;
-	struct irq_desc *desc = irq_to_desc(irq);
-	int enable_one = (desc->status & IRQ_DISABLED) == 0;
-	unsigned long flags;
-	int bit = irq - OCTEON_IRQ_WDOG0;	/* Bit 0-63 of EN1 */
+	u64 mask;
 
-	/*
-	 * For non-v2 CIU, we will allow only single CPU affinity.
-	 * This removes the need to do locking in the .ack/.eoi
-	 * functions.
-	 */
-	if (cpumask_weight(dest) != 1)
-		return -EINVAL;
+	mask = 1ull << (irq - OCTEON_IRQ_MBOX0);
 
-	spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
 	for_each_online_cpu(cpu) {
-		int coreid = octeon_coreid_for_cpu(cpu);
-		uint64_t en1 =
-			cvmx_read_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1));
-		if (cpumask_test_cpu(cpu, dest) && enable_one) {
-			enable_one = 0;
-			en1 |= 1ull << bit;
-		} else {
-			en1 &= ~(1ull << bit);
-		}
-		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), en1);
+		u64 en_addr = CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(octeon_coreid_for_cpu(cpu));
+		cvmx_write_csr(en_addr, mask);
 	}
-	/*
-	 * We need to do a read after the last update to make sure all
-	 * of them are done.
-	 */
-	cvmx_read_csr(CVMX_CIU_INTX_EN1(cvmx_get_core_num() * 2 + 1));
-	spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+}
 
-	return 0;
+static void octeon_irq_ciu2_mbox_enable_local(unsigned int irq)
+{
+	u64 mask;
+	u64 en_addr;
+	int coreid = cvmx_get_core_num();
+
+	mask = 1ull << (irq - OCTEON_IRQ_MBOX0);
+	en_addr = CVMX_CIU2_EN_PPX_IP3_MBOX_W1S(coreid);
+	cvmx_write_csr(en_addr, mask);
 }
 
-/*
- * Set affinity for the irq for chips that have the EN*_W1{S,C}
- * registers.
- */
-static int octeon_irq_ciu1_set_affinity_v2(unsigned int irq,
-					   const struct cpumask *dest)
+static void octeon_irq_ciu2_mbox_enable_local_check(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu2_mbox_enable_local(irq);
+}
+
+static void octeon_irq_ciu2_mbox_disable_local(unsigned int irq)
+{
+	u64 mask;
+	u64 en_addr;
+	int coreid = cvmx_get_core_num();
+
+	mask = 1ull << (irq - OCTEON_IRQ_MBOX0);
+	en_addr = CVMX_CIU2_EN_PPX_IP3_MBOX_W1C(coreid);
+	cvmx_write_csr(en_addr, mask);
+}
+
+#ifdef CONFIG_SMP
+static int octeon_irq_ciu2_set_affinity(unsigned int irq,
+					const struct cpumask *dest)
 {
 	int cpu;
-	int index;
 	struct irq_desc *desc = irq_to_desc(irq);
 	int enable_one = (desc->status & IRQ_DISABLED) == 0;
-	u64 mask = 1ull << (irq - OCTEON_IRQ_WDOG0);
+	u64 mask;
+	union octeon_ciu_chip_data cd;
+
+	if (desc->status & IRQ_DISABLED)
+		return 0;
+
+	cd.p = desc->chip_data;
+	mask = 1ull << cd.s.bit;
+
 	for_each_online_cpu(cpu) {
-		index = octeon_coreid_for_cpu(cpu) * 2 + 1;
+		u64 en_addr;
 		if (cpumask_test_cpu(cpu, dest) && enable_one) {
 			enable_one = 0;
-			cvmx_write_csr(CVMX_CIU_INTX_EN1_W1S(index), mask);
+			en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1S(octeon_coreid_for_cpu(cpu)) + (0x1000ull * cd.s.line);
 		} else {
-			cvmx_write_csr(CVMX_CIU_INTX_EN1_W1C(index), mask);
+			en_addr = CVMX_CIU2_EN_PPX_IP2_WRKQ_W1C(octeon_coreid_for_cpu(cpu)) + (0x1000ull * cd.s.line);
 		}
+		cvmx_write_csr(en_addr, mask);
 	}
+
 	return 0;
 }
 #endif
 
-/*
- * Newer octeon chips have support for lockless CIU operation.
- */
-static struct irq_chip octeon_irq_chip_ciu1_v2 = {
-	.name = "CIU1",
-	.enable = octeon_irq_ciu1_enable_v2,
-	.disable = octeon_irq_ciu1_disable_all_v2,
-	.eoi = octeon_irq_ciu1_enable_v2,
+static struct irq_chip octeon_irq_chip_ciu2 = {
+	.name = "CIU2",
+	.enable = octeon_irq_ciu2_enable,
+	.disable = octeon_irq_ciu2_disable_all,
+	.mask = octeon_irq_ciu2_disable_local,
+	.unmask = octeon_irq_ciu2_enable_check,
 #ifdef CONFIG_SMP
-	.set_affinity = octeon_irq_ciu1_set_affinity_v2,
+	.set_affinity = octeon_irq_ciu2_set_affinity,
 #endif
 };
 
-static struct irq_chip octeon_irq_chip_ciu1 = {
-	.name = "CIU1",
-	.enable = octeon_irq_ciu1_enable,
-	.disable = octeon_irq_ciu1_disable,
-	.eoi = octeon_irq_ciu1_eoi,
+static struct irq_chip octeon_irq_chip_ciu2_edge = {
+	.name = "CIU2-E",
+	.enable = octeon_irq_ciu2_enable,
+	.disable = octeon_irq_ciu2_disable_all,
+	.ack = octeon_irq_ciu2_ack,
+	.mask = octeon_irq_ciu2_disable_local,
+	.unmask = octeon_irq_ciu2_enable_check,
 #ifdef CONFIG_SMP
-	.set_affinity = octeon_irq_ciu1_set_affinity,
+	.set_affinity = octeon_irq_ciu2_set_affinity,
 #endif
 };
 
-static struct irq_chip octeon_irq_chip_ciu1_wd_v2 = {
-	.name = "CIU1-W",
-	.enable = octeon_irq_ciu1_wd_enable_v2,
-	.disable = octeon_irq_ciu1_disable_all_v2,
-	.eoi = octeon_irq_ciu1_wd_enable_v2,
+static struct irq_chip octeon_irq_chip_ciu2_mbox = {
+	.name = "CIU2-M",
+	.enable = octeon_irq_ciu2_mbox_enable_local,
+	.disable = octeon_irq_ciu2_mbox_disable_all,
+	.ack = octeon_irq_ciu2_mbox_disable_local,
+	.eoi = octeon_irq_ciu2_mbox_enable_local_check,
 };
 
-static struct irq_chip octeon_irq_chip_ciu1_wd = {
-	.name = "CIU1-W",
-	.enable = octeon_irq_ciu1_wd_enable,
-	.disable = octeon_irq_ciu1_disable,
-	.eoi = octeon_irq_ciu1_eoi,
+static struct irq_chip octeon_irq_chip_ciu2_wd = {
+	.name = "CIU2-W",
+	.enable = octeon_irq_ciu2_wd_enable,
+	.disable = octeon_irq_ciu2_disable_all,
+	.mask = octeon_irq_ciu2_disable_local,
+	.unmask = octeon_irq_ciu2_enable_local_check,
 };
 
-static void (*octeon_ciu0_ack)(unsigned int);
-static void (*octeon_ciu1_ack)(unsigned int);
+static void octeon_irq_ciu2(void)
+{
+	int line;
+	int bit;
+	int irq;
+	u64 src_reg, src, sum;
+	const unsigned long core_id = cvmx_get_core_num();
 
-void paravirt_arch_init_irq(void)
-	__attribute__ ((weak, alias("native_arch_init_irq")));
+	sum = cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP2(core_id)) & 0xfful;
 
-void __init native_arch_init_irq(void)
-{
-	unsigned int irq;
-	struct irq_chip *chip0;
-	struct irq_chip *chip0_mbox;
-	struct irq_chip *chip1;
-	struct irq_chip *chip1_wd;
+	if (unlikely(!sum))
+		goto spurious;
 
-#ifdef CONFIG_SMP
-	/* Set the default affinity to the boot cpu. */
-	cpumask_clear(irq_default_affinity);
-	cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
-#endif
+	line = fls64(sum) - 1;
+	src_reg = CVMX_CIU2_SRC_PPX_IP2_WRKQ(core_id) + (0x1000 * line);
+	src = cvmx_read_csr(src_reg);
 
-	if (NR_IRQS < OCTEON_IRQ_LAST)
-		pr_err("octeon_irq_init: NR_IRQS is set too low\n");
+	if (unlikely(!src))
+		goto spurious;
 
-	if (OCTEON_IS_MODEL(OCTEON_CN58XX_PASS2_X) ||
-	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS2_X) ||
-	    OCTEON_IS_MODEL(OCTEON_CN52XX_PASS2_X) ||
-	    OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
-		octeon_ciu0_ack = octeon_irq_ciu0_ack_v2;
-		octeon_ciu1_ack = octeon_irq_ciu1_ack_v2;
-		chip0 = &octeon_irq_chip_ciu0_v2;
-		chip0_mbox = &octeon_irq_chip_ciu0_mbox_v2;
-		chip1 = &octeon_irq_chip_ciu1_v2;
-		chip1_wd = &octeon_irq_chip_ciu1_wd_v2;
-	} else {
-		octeon_ciu0_ack = octeon_irq_ciu0_ack;
-		octeon_ciu1_ack = octeon_irq_ciu1_ack;
-		chip0 = &octeon_irq_chip_ciu0;
-		chip0_mbox = &octeon_irq_chip_ciu0_mbox;
-		chip1 = &octeon_irq_chip_ciu1;
-		chip1_wd = &octeon_irq_chip_ciu1_wd;
-	}
+	bit = fls64(src) - 1;
+	irq = octeon_irq_ciu_to_irq[line][bit];
+	if (unlikely(!irq))
+		goto spurious;
 
-	/* 0 - 15 reserved for i8259 master and slave controller. */
+	do_IRQ(irq);
+	goto out;
 
-	/* 17 - 23 Mips internal */
-	for (irq = OCTEON_IRQ_SW0; irq <= OCTEON_IRQ_TIMER; irq++) {
-		set_irq_chip_and_handler(irq, &octeon_irq_chip_core,
-					 handle_percpu_irq);
-	}
+spurious:
+	spurious_interrupt();
+out:
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP2(core_id));
+	return;
+}
 
-	/* 24 - 87 CIU_INT_SUM0 */
-	for (irq = OCTEON_IRQ_WORKQ0; irq <= OCTEON_IRQ_BOOTDMA; irq++) {
-		switch (irq) {
-		case OCTEON_IRQ_MBOX0:
-		case OCTEON_IRQ_MBOX1:
-			set_irq_chip_and_handler(irq, chip0_mbox, handle_percpu_irq);
-			break;
-		default:
-			set_irq_chip_and_handler(irq, chip0, handle_fasteoi_irq);
-			break;
-		}
-	}
+static void octeon_irq_ciu2_mbox(void)
+{
+	int line;
+
+	const unsigned long core_id = cvmx_get_core_num();
+	u64 sum = cvmx_read_csr(CVMX_CIU2_SUM_PPX_IP3(core_id)) >> 60;
+
+	if (unlikely(!sum))
+		goto spurious;
 
-	/* 88 - 151 CIU_INT_SUM1 */
-	for (irq = OCTEON_IRQ_WDOG0; irq <= OCTEON_IRQ_WDOG15; irq++)
-		set_irq_chip_and_handler(irq, chip1_wd, handle_fasteoi_irq);
+	line = fls64(sum) - 1;
 
-	for (irq = OCTEON_IRQ_UART2; irq <= OCTEON_IRQ_RST; irq++)
-		set_irq_chip_and_handler(irq, chip1, handle_fasteoi_irq);
+	do_IRQ(OCTEON_IRQ_MBOX0 + line);
+	goto out;
 
-	set_c0_status(0x300 << 2);
+spurious:
+	spurious_interrupt();
+out:
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP3(core_id));
+	return;
 }
 
-void __init arch_init_irq(void)
+static void __init octeon_irq_init_ciu2(void)
 {
-	paravirt_arch_init_irq();
+	unsigned int i;
+
+	octeon_irq_init_ciu2_percpu();
+	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu2;
+
+	octeon_irq_ip2 = octeon_irq_ciu2;
+	octeon_irq_ip3 = octeon_irq_ciu2_mbox;
+	octeon_irq_ip4 = octeon_irq_ip4_mask;
+
+	/* Mips internal */
+	set_irq_chip_and_handler(OCTEON_IRQ_SW0, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_SW1, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_5, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_PERF, &octeon_irq_chip_core, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_TIMER, &octeon_irq_chip_core, handle_percpu_irq);
+
+	/* CUI2 */
+	for (i = 0; i < 64; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_WORKQ0, 0, i, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	for (i = 0; i < 32; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_WDOG0, 1, i , &octeon_irq_chip_ciu2_wd, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IOB, 2, 0, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_FPA, 2, 4, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPD, 2, 5, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PIP, 2, 6, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PKO, 2, 7, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_POW, 2, 16, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_ZIP, 2, 24, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TIM, 2, 28, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RAD, 2, 29, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_KEY, 2, 30, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_SLI, 2, 32, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_DPI, 2, 33, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_DFA, 2, 40, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_L2C, 2, 48, &octeon_irq_chip_ciu2, handle_level_irq);
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(OCTEON_IRQ_TRACE0 + i, 2, i + 52, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPDPPTHR, 3, 0, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_IPD_DRP, 3, 2, &octeon_irq_chip_ciu2_edge, handle_edge_irq);
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_TIMER0, 3, i + 8, &octeon_irq_chip_ciu2_edge, handle_edge_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_NAND, 3, 16, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MIO, 3, 17, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_BOOTDMA, 3, 18, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TWSI, 3, 32, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_TWSI2, 3, 33, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_UART0, 3, 36, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_UART1, 3, 37, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_USBCTL, 3, 40, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_USB0, 3, 44, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PTP, 3, 48, &octeon_irq_chip_ciu2_edge, handle_edge_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_RST, 3, 63, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_PCI_INT0, 4, i, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+		for (i = 0; i < 4; i++)
+			octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_PCI_MSI0, 4, i + 8, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PEM0, 4, 32, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_PEM1, 4, 33, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	for (i = 0; i < 4; i++)
+		octeon_irq_set_ciu_mapping(OCTEON_IRQ_LMC0, 5, i, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	for (i = 0; i < 5; i++)
+		octeon_irq_set_ciu_mapping(OCTEON_IRQ_AGX0 + i, 6, i, &octeon_irq_chip_ciu2, handle_level_irq);
+	for (i = 0; i < 5; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_GMX_DRP0 + i, 6, i + 8, &octeon_irq_chip_ciu2_edge, handle_edge_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_AGL, 6, 32, &octeon_irq_chip_ciu2, handle_level_irq);
+	octeon_irq_set_ciu_mapping(OCTEON_IRQ_MII0, 6, 40, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	for (i = 0; i < 16; i++)
+		octeon_irq_set_ciu_mapping(i + OCTEON_IRQ_GPIO0, 7, i, &octeon_irq_chip_ciu2, handle_level_irq);
+
+	set_irq_chip_and_handler(OCTEON_IRQ_MBOX0, &octeon_irq_chip_ciu2_mbox, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_MBOX1, &octeon_irq_chip_ciu2_mbox, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_MBOX2, &octeon_irq_chip_ciu2_mbox, handle_percpu_irq);
+	set_irq_chip_and_handler(OCTEON_IRQ_MBOX3, &octeon_irq_chip_ciu2_mbox, handle_percpu_irq);
+
+	/* Enable the CIU lines */
+	set_c0_status(STATUSF_IP3 | STATUSF_IP2);
+	clear_c0_status(STATUSF_IP4);
+}
+
+void __init native_arch_init_irq(void)
+{
+#ifdef CONFIG_SMP
+	/* Set the default affinity to the boot cpu. */
+	cpumask_clear(irq_default_affinity);
+	cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
+#endif
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		octeon_irq_init_ciu2();
+	else
+		octeon_irq_init_ciu();
 }
 
 asmlinkage void paravirt_plat_irq_dispatch(void)
@@ -752,16 +1324,8 @@ asmlinkage void paravirt_plat_irq_dispatch(void)
 
 asmlinkage void native_plat_irq_dispatch(void)
 {
-	const unsigned long core_id = cvmx_get_core_num();
-	const uint64_t ciu_sum0_address = CVMX_CIU_INTX_SUM0(core_id * 2);
-	const uint64_t ciu_en0_address = CVMX_CIU_INTX_EN0(core_id * 2);
-	const uint64_t ciu_sum1_address = CVMX_CIU_INT_SUM1;
-	const uint64_t ciu_en1_address = CVMX_CIU_INTX_EN1(core_id * 2 + 1);
 	unsigned long cop0_cause;
 	unsigned long cop0_status;
-	uint64_t ciu_en;
-	uint64_t ciu_sum;
-	unsigned int irq;
 
 	while (1) {
 		cop0_cause = read_c0_cause();
@@ -769,33 +1333,16 @@ asmlinkage void native_plat_irq_dispatch(void)
 		cop0_cause &= cop0_status;
 		cop0_cause &= ST0_IM;
 
-		if (unlikely(cop0_cause & STATUSF_IP2)) {
-			ciu_sum = cvmx_read_csr(ciu_sum0_address);
-			ciu_en = cvmx_read_csr(ciu_en0_address);
-			ciu_sum &= ciu_en;
-			if (likely(ciu_sum)) {
-				irq = fls64(ciu_sum) + OCTEON_IRQ_WORKQ0 - 1;
-				octeon_ciu0_ack(irq);
-				do_IRQ(irq);
-			} else {
-				spurious_interrupt();
-			}
-		} else if (unlikely(cop0_cause & STATUSF_IP3)) {
-			ciu_sum = cvmx_read_csr(ciu_sum1_address);
-			ciu_en = cvmx_read_csr(ciu_en1_address);
-			ciu_sum &= ciu_en;
-			if (likely(ciu_sum)) {
-				irq = fls64(ciu_sum) + OCTEON_IRQ_WDOG0 - 1;
-				octeon_ciu1_ack(irq);
-				do_IRQ(irq);
-			} else {
-				spurious_interrupt();
-			}
-		} else if (likely(cop0_cause)) {
+		if (unlikely(cop0_cause & STATUSF_IP2))
+			octeon_irq_ip2();
+		else if (unlikely(cop0_cause & STATUSF_IP3))
+			octeon_irq_ip3();
+		else if (unlikely(cop0_cause & STATUSF_IP4))
+			octeon_irq_ip4();
+		else if (likely(cop0_cause))
 			do_IRQ(fls(cop0_cause) - 9 + MIPS_CPU_IRQ_BASE);
-		} else {
+		else
 			break;
-		}
 	}
 }
 
@@ -822,28 +1369,15 @@ void fixup_irqs(void)
 
 	for (irq = OCTEON_IRQ_WORKQ0; irq < OCTEON_IRQ_LAST; irq++) {
 		desc = irq_to_desc(irq);
+		if (desc->status & IRQ_DISABLED)
+			continue;
+
 		switch (irq) {
-		case OCTEON_IRQ_MBOX0:
-		case OCTEON_IRQ_MBOX1:
+		case OCTEON_IRQ_MBOX0...OCTEON_IRQ_MBOX3:
 			/* The eoi function will disable them on this CPU. */
 			desc->chip->eoi(irq);
 			break;
-		case OCTEON_IRQ_WDOG0:
-		case OCTEON_IRQ_WDOG1:
-		case OCTEON_IRQ_WDOG2:
-		case OCTEON_IRQ_WDOG3:
-		case OCTEON_IRQ_WDOG4:
-		case OCTEON_IRQ_WDOG5:
-		case OCTEON_IRQ_WDOG6:
-		case OCTEON_IRQ_WDOG7:
-		case OCTEON_IRQ_WDOG8:
-		case OCTEON_IRQ_WDOG9:
-		case OCTEON_IRQ_WDOG10:
-		case OCTEON_IRQ_WDOG11:
-		case OCTEON_IRQ_WDOG12:
-		case OCTEON_IRQ_WDOG13:
-		case OCTEON_IRQ_WDOG14:
-		case OCTEON_IRQ_WDOG15:
+		case OCTEON_IRQ_WDOG0...OCTEON_IRQ_WDOG31:
 			/*
 			 * These have special per CPU semantics and
 			 * are handled in the watchdog driver.
@@ -888,3 +1422,5 @@ void fixup_irqs(void)
 }
 
 #endif /* CONFIG_HOTPLUG_CPU */
+
+
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 5c33975..df723a0 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -656,7 +656,6 @@ void __init native_prom_init(void)
 {
 	struct cvmx_sysinfo *sysinfo;
 	struct linux_app_boot_info *labi;
-	const int coreid = cvmx_get_core_num();
 	int i;
 	int argc;
 #if CONFIG_CAVIUM_RESERVE32
@@ -745,17 +744,6 @@ void __init native_prom_init(void)
 
 	octeon_uart = octeon_get_boot_uart();
 
-	/*
-	 * Disable All CIU Interrupts. The ones we need will be
-	 * enabled later.  Read the SUM register so we know the write
-	 * completed.
-	 */
-	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2)), 0);
-	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2 + 1)), 0);
-	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2)), 0);
-	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2 + 1)), 0);
-	cvmx_read_csr(CVMX_CIU_INTX_SUM0((coreid * 2)));
-
 #ifdef CONFIG_SMP
 #ifdef CONFIG_CRASH_DUMP
 	octeon_write_lcd("CrashSMP");
@@ -1195,9 +1183,11 @@ void prom_free_prom_memory(void)
 #else
 	irq_flags = IRQF_SHARED;
 #endif
-	if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, irq_flags,
-                        "RML_RSL", octeon_rml_interrupt)) {	
- 		panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
+	if (!OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, irq_flags,
+					"RML/RSL", octeon_rml_interrupt)) {
+			panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
+		}
 	}
 #endif
 }
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 06b5d3d..5dc6d5c 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -235,27 +235,13 @@ static void octeon_init_secondary(void)
 	/* Enable IPIs to this core. */
 	wrhv_unmask_IPIs_for_vcore();
 #else
-	const int coreid = cvmx_get_core_num();
-	union cvmx_ciu_intx_sum0 interrupt_enable;
-
 	write_c0_ebase((u32)ebase);
 
 	octeon_check_cpu_bist();
 	octeon_init_cvmcount();
-	/*
-	pr_info("SMP: CPU%d (CoreId %lu) started\n", cpu, coreid);
-	*/
-	/* Enable Mailbox interrupts to this core. These are the only
-	   interrupts allowed on line 3 */
-	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(coreid), 0xffffffff);
-	interrupt_enable.u64 = 0;
-	interrupt_enable.s.mbox = 0x3;
-	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2)), interrupt_enable.u64);
-	cvmx_write_csr(CVMX_CIU_INTX_EN0((coreid * 2 + 1)), 0);
-	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2)), 0);
-	cvmx_write_csr(CVMX_CIU_INTX_EN1((coreid * 2 + 1)), 0);
-	/* Enable core interrupt processing for 2,3 and 7 */
-	set_c0_status(0x8c01);
+
+	octeon_irq_setup_secondary();
+	raw_local_irq_enable();
 #endif
 }
 
@@ -285,6 +271,7 @@ void octeon_prepare_cpus(unsigned int max_cpus)
 #ifdef CONFIG_WRHV
 	wrhv_request_ipis();
 #else
+
 	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(cvmx_get_core_num()), 0xffffffff);
 	if (request_irq(OCTEON_IRQ_MBOX0, mailbox_interrupt, IRQF_DISABLED,
 			"mailbox0", mailbox_interrupt)) {
@@ -357,10 +344,7 @@ static int octeon_cpu_disable(void)
 
 	cpu_clear(cpu, cpu_online_map);
 	cpu_clear(cpu, cpu_callin_map);
-	local_irq_disable();
 	fixup_irqs();
-	local_irq_enable();
-
 	flush_cache_all();
 	local_flush_tlb_all();
 
diff --git a/arch/mips/include/asm/mach-cavium-octeon/irq.h b/arch/mips/include/asm/mach-cavium-octeon/irq.h
index 01da16b..4c9fb30 100644
--- a/arch/mips/include/asm/mach-cavium-octeon/irq.h
+++ b/arch/mips/include/asm/mach-cavium-octeon/irq.h
@@ -11,172 +11,93 @@
 #define NR_IRQS OCTEON_IRQ_LAST
 #define MIPS_CPU_IRQ_BASE OCTEON_IRQ_SW0
 
-/* 0 - 7 represent the i8259 master */
-#define OCTEON_IRQ_I8259M0	0
-#define OCTEON_IRQ_I8259M1	1
-#define OCTEON_IRQ_I8259M2	2
-#define OCTEON_IRQ_I8259M3	3
-#define OCTEON_IRQ_I8259M4	4
-#define OCTEON_IRQ_I8259M5	5
-#define OCTEON_IRQ_I8259M6	6
-#define OCTEON_IRQ_I8259M7	7
-/* 8 - 15 represent the i8259 slave */
-#define OCTEON_IRQ_I8259S0	8
-#define OCTEON_IRQ_I8259S1	9
-#define OCTEON_IRQ_I8259S2	10
-#define OCTEON_IRQ_I8259S3	11
-#define OCTEON_IRQ_I8259S4	12
-#define OCTEON_IRQ_I8259S5	13
-#define OCTEON_IRQ_I8259S6	14
-#define OCTEON_IRQ_I8259S7	15
-/* 16 - 23 represent the 8 MIPS standard interrupt sources */
-#define OCTEON_IRQ_SW0		16
-#define OCTEON_IRQ_SW1		17
-#define OCTEON_IRQ_CIU0		18
-#define OCTEON_IRQ_CIU1		19
-#define OCTEON_IRQ_CIU4		20
-#define OCTEON_IRQ_5		21
-#define OCTEON_IRQ_PERF		22
-#define OCTEON_IRQ_TIMER	23
-/* 24 - 87 represent the sources in CIU_INTX_EN0 */
-#define OCTEON_IRQ_WORKQ0	24
-#define OCTEON_IRQ_WORKQ1	25
-#define OCTEON_IRQ_WORKQ2	26
-#define OCTEON_IRQ_WORKQ3	27
-#define OCTEON_IRQ_WORKQ4	28
-#define OCTEON_IRQ_WORKQ5	29
-#define OCTEON_IRQ_WORKQ6	30
-#define OCTEON_IRQ_WORKQ7	31
-#define OCTEON_IRQ_WORKQ8	32
-#define OCTEON_IRQ_WORKQ9	33
-#define OCTEON_IRQ_WORKQ10	34
-#define OCTEON_IRQ_WORKQ11	35
-#define OCTEON_IRQ_WORKQ12	36
-#define OCTEON_IRQ_WORKQ13	37
-#define OCTEON_IRQ_WORKQ14	38
-#define OCTEON_IRQ_WORKQ15	39
-#define OCTEON_IRQ_GPIO0	40
-#define OCTEON_IRQ_GPIO1	41
-#define OCTEON_IRQ_GPIO2	42
-#define OCTEON_IRQ_GPIO3	43
-#define OCTEON_IRQ_GPIO4	44
-#define OCTEON_IRQ_GPIO5	45
-#define OCTEON_IRQ_GPIO6	46
-#define OCTEON_IRQ_GPIO7	47
-#define OCTEON_IRQ_GPIO8	48
-#define OCTEON_IRQ_GPIO9	49
-#define OCTEON_IRQ_GPIO10	50
-#define OCTEON_IRQ_GPIO11	51
-#define OCTEON_IRQ_GPIO12	52
-#define OCTEON_IRQ_GPIO13	53
-#define OCTEON_IRQ_GPIO14	54
-#define OCTEON_IRQ_GPIO15	55
-#define OCTEON_IRQ_MBOX0	56
-#define OCTEON_IRQ_MBOX1	57
-#define OCTEON_IRQ_UART0	58
-#define OCTEON_IRQ_UART1	59
-#define OCTEON_IRQ_PCI_INT0	60
-#define OCTEON_IRQ_PCI_INT1	61
-#define OCTEON_IRQ_PCI_INT2	62
-#define OCTEON_IRQ_PCI_INT3	63
-#define OCTEON_IRQ_PCI_MSI0	64
-#define OCTEON_IRQ_PCI_MSI1	65
-#define OCTEON_IRQ_PCI_MSI2	66
-#define OCTEON_IRQ_PCI_MSI3	67
-#define OCTEON_IRQ_RESERVED68	68	/* Summary of CIU_INT_SUM1 */
-#define OCTEON_IRQ_TWSI		69
-#define OCTEON_IRQ_RML		70
-#define OCTEON_IRQ_TRACE	71
-#define OCTEON_IRQ_GMX_DRP0	72
-#define OCTEON_IRQ_GMX_DRP1	73
-#define OCTEON_IRQ_IPD_DRP	74
-#define OCTEON_IRQ_KEY_ZERO	75
-#define OCTEON_IRQ_TIMER0	76
-#define OCTEON_IRQ_TIMER1	77
-#define OCTEON_IRQ_TIMER2	78
-#define OCTEON_IRQ_TIMER3	79
-#define OCTEON_IRQ_USB0		80
-#define OCTEON_IRQ_PCM		81
-#define OCTEON_IRQ_MPI		82
-#define OCTEON_IRQ_TWSI2	83
-#define OCTEON_IRQ_POWIQ	84
-#define OCTEON_IRQ_IPDPPTHR	85
-#define OCTEON_IRQ_MII0		86
-#define OCTEON_IRQ_BOOTDMA	87
-/* 88 - 151 represent the sources in CIU_INTX_EN1 */
-#define OCTEON_IRQ_WDOG0	88
-#define OCTEON_IRQ_WDOG1	89
-#define OCTEON_IRQ_WDOG2	90
-#define OCTEON_IRQ_WDOG3	91
-#define OCTEON_IRQ_WDOG4	92
-#define OCTEON_IRQ_WDOG5	93
-#define OCTEON_IRQ_WDOG6	94
-#define OCTEON_IRQ_WDOG7	95
-#define OCTEON_IRQ_WDOG8	96
-#define OCTEON_IRQ_WDOG9	97
-#define OCTEON_IRQ_WDOG10	98
-#define OCTEON_IRQ_WDOG11	99
-#define OCTEON_IRQ_WDOG12	100
-#define OCTEON_IRQ_WDOG13	101
-#define OCTEON_IRQ_WDOG14	102
-#define OCTEON_IRQ_WDOG15	103
-#define OCTEON_IRQ_UART2	104
-#define OCTEON_IRQ_USB1		105
-#define OCTEON_IRQ_MII1		106
-#define OCTEON_IRQ_NAND		107
-#define OCTEON_IRQ_MIO		108	/* Summary of MIO_BOOT_ERR */
-#define OCTEON_IRQ_IOB		109	/* Summary of IOB_INT_SUM */
-#define OCTEON_IRQ_FPA		110	/* Summary of FPA_INT_SUM */
-#define OCTEON_IRQ_POW		111	/* Summary of POW_ECC_ERR */
-#define OCTEON_IRQ_L2C		112	/* Summary of L2C_INT_STAT */
-#define OCTEON_IRQ_IPD		113	/* Summary of IPD_INT_SUM */
-#define OCTEON_IRQ_PIP		114	/* Summary of PIP_INT_REG */
-#define OCTEON_IRQ_PKO		115	/* Summary of PKO_REG_ERROR */
-#define OCTEON_IRQ_ZIP		116	/* Summary of ZIP_ERROR */
-#define OCTEON_IRQ_TIM		117	/* Summary of TIM_REG_ERROR */
-#define OCTEON_IRQ_RAD		118	/* Summary of RAD_REG_ERROR */
-#define OCTEON_IRQ_KEY		119	/* Summary of KEY_INT_SUM */
-#define OCTEON_IRQ_DFA		120	/* Summary of DFA */
-#define OCTEON_IRQ_USB		121	/* Summary of USBN0_INT_SUM */
-#define OCTEON_IRQ_SLI		122	/* Summary of SLI_INT_SUM */
-#define OCTEON_IRQ_DPI		123	/* Summary of DPI_INT_SUM */
-#define OCTEON_IRQ_AGX0		124	/* Summary of GMX0*+PCS0_INT*_REG */
-#define OCTEON_IRQ_RESERVED125	125
-#define OCTEON_IRQ_RESERVED126	126
-#define OCTEON_IRQ_RESERVED127	127
-#define OCTEON_IRQ_RESERVED128	128
-#define OCTEON_IRQ_RESERVED129	129
-#define OCTEON_IRQ_RESERVED130	130
-#define OCTEON_IRQ_RESERVED131	131
-#define OCTEON_IRQ_RESERVED132	132
-#define OCTEON_IRQ_RESERVED133	133
-#define OCTEON_IRQ_AGL		134
-#define OCTEON_IRQ_PTP		135
-#define OCTEON_IRQ_PEM0		136
-#define OCTEON_IRQ_PEM1		137
-#define OCTEON_IRQ_SRIO0	138
-#define OCTEON_IRQ_SRIO1	139
-#define OCTEON_IRQ_LMC0		140
-#define OCTEON_IRQ_RESERVED141	141
-#define OCTEON_IRQ_RESERVED142	142
-#define OCTEON_IRQ_RESERVED143	143
-#define OCTEON_IRQ_DFM		144	/* Summary of DFM */
-#define OCTEON_IRQ_RESERVED145	145
-#define OCTEON_IRQ_RESERVED146	146
-#define OCTEON_IRQ_RESERVED147	147
-#define OCTEON_IRQ_RESERVED148	148
-#define OCTEON_IRQ_RESERVED149	149
-#define OCTEON_IRQ_RESERVED150	150
-#define OCTEON_IRQ_RST		151
+enum octeon_irq {
+/* 1 - 8 represent the 8 MIPS standard interrupt sources */
+	OCTEON_IRQ_SW0 = 1,
+	OCTEON_IRQ_SW1,
+/* CIU0, CUI2, CIU4 are 3, 4, 5 */
+	OCTEON_IRQ_5 = 6,
+	OCTEON_IRQ_PERF,
+	OCTEON_IRQ_TIMER,
+/* sources in CIU_INTX_EN0 */
+	OCTEON_IRQ_WORKQ0,
+	OCTEON_IRQ_GPIO0 = OCTEON_IRQ_WORKQ0 + 64,
+	OCTEON_IRQ_WDOG0 = OCTEON_IRQ_GPIO0 + 16,
+	OCTEON_IRQ_WDOG31 = OCTEON_IRQ_WDOG0 + 31,
+	OCTEON_IRQ_MBOX0 = OCTEON_IRQ_WDOG0 + 32,
+	OCTEON_IRQ_MBOX1,
+	OCTEON_IRQ_MBOX2,
+	OCTEON_IRQ_MBOX3,
+	OCTEON_IRQ_UART0,
+	OCTEON_IRQ_UART1,
+	OCTEON_IRQ_UART2,
+	OCTEON_IRQ_PCI_INT0,
+	OCTEON_IRQ_PCI_INT1,
+	OCTEON_IRQ_PCI_INT2,
+	OCTEON_IRQ_PCI_INT3,
+	OCTEON_IRQ_PCI_MSI0,
+	OCTEON_IRQ_PCI_MSI1,
+	OCTEON_IRQ_PCI_MSI2,
+	OCTEON_IRQ_PCI_MSI3,
+
+	OCTEON_IRQ_TWSI,
+	OCTEON_IRQ_TWSI2,
+	OCTEON_IRQ_RML,
+	OCTEON_IRQ_TRACE0,
+	OCTEON_IRQ_GMX_DRP0 = OCTEON_IRQ_TRACE0 + 4,
+	OCTEON_IRQ_IPD_DRP = OCTEON_IRQ_GMX_DRP0 + 5,
+	OCTEON_IRQ_KEY_ZERO,
+	OCTEON_IRQ_TIMER0,
+	OCTEON_IRQ_TIMER1,
+	OCTEON_IRQ_TIMER2,
+	OCTEON_IRQ_TIMER3,
+	OCTEON_IRQ_USB0,
+	OCTEON_IRQ_USB1,
+	OCTEON_IRQ_PCM,
+	OCTEON_IRQ_MPI,
+	OCTEON_IRQ_POWIQ,
+	OCTEON_IRQ_IPDPPTHR,
+	OCTEON_IRQ_MII0,
+	OCTEON_IRQ_MII1,
+	OCTEON_IRQ_BOOTDMA,
+
+	OCTEON_IRQ_NAND,
+	OCTEON_IRQ_MIO,		/* Summary of MIO_BOOT_ERR */
+	OCTEON_IRQ_IOB,		/* Summary of IOB_INT_SUM */
+	OCTEON_IRQ_FPA,		/* Summary of FPA_INT_SUM */
+	OCTEON_IRQ_POW,		/* Summary of POW_ECC_ERR */
+	OCTEON_IRQ_L2C,		/* Summary of L2C_INT_STAT */
+	OCTEON_IRQ_IPD,		/* Summary of IPD_INT_SUM */
+	OCTEON_IRQ_PIP,		/* Summary of PIP_INT_REG */
+	OCTEON_IRQ_PKO,		/* Summary of PKO_REG_ERROR */
+	OCTEON_IRQ_ZIP,		/* Summary of ZIP_ERROR */
+	OCTEON_IRQ_TIM,		/* Summary of TIM_REG_ERROR */
+	OCTEON_IRQ_RAD,		/* Summary of RAD_REG_ERROR */
+	OCTEON_IRQ_KEY,		/* Summary of KEY_INT_SUM */
+	OCTEON_IRQ_DFA,		/* Summary of DFA */
+	OCTEON_IRQ_USBCTL,	/* Summary of USBN0_INT_SUM */
+	OCTEON_IRQ_SLI,		/* Summary of SLI_INT_SUM */
+	OCTEON_IRQ_DPI,		/* Summary of DPI_INT_SUM */
+	OCTEON_IRQ_AGX0,	/* Summary of GMX0*+PCS0_INT*_REG */
+	OCTEON_IRQ_AGL  = OCTEON_IRQ_AGX0 + 5,
+	OCTEON_IRQ_PTP,
+	OCTEON_IRQ_PEM0,
+	OCTEON_IRQ_PEM1,
+	OCTEON_IRQ_SRIO0,
+	OCTEON_IRQ_SRIO1,
+	OCTEON_IRQ_LMC0,
+	OCTEON_IRQ_DFM = OCTEON_IRQ_LMC0 + 4,		/* Summary of DFM */
+	OCTEON_IRQ_RST,
+};
 
 #ifdef CONFIG_PCI_MSI
 /* 152 - 407 represent the MSI interrupts 0-255 */
-#define OCTEON_IRQ_MSI_BIT0	152
+#define OCTEON_IRQ_MSI_BIT0	(OCTEON_IRQ_RST + 1)
 
 #define OCTEON_IRQ_MSI_LAST      (OCTEON_IRQ_MSI_BIT0 + 255)
 #define OCTEON_IRQ_LAST          (OCTEON_IRQ_MSI_LAST + 1)
 #else
-#define OCTEON_IRQ_LAST         152
+#define OCTEON_IRQ_LAST         (OCTEON_IRQ_RST + 1)
 #endif
 
 #endif
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 37b5c5b..31e4c8e 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -293,4 +293,10 @@ static inline uint64_t octeon_read_ptp_csr(uint64_t csr)
 		return cvmx_read_csr(csr);
 }
 
+extern void (*octeon_irq_setup_secondary)(void);
+extern int octeon_coreid_for_cpu(int);
+
+typedef void (*octeon_irq_ip4_handler_t)(void);
+void octeon_irq_set_ip4_handler(octeon_irq_ip4_handler_t);
+
 #endif /* __ASM_OCTEON_OCTEON_H */
diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index 5911f9b..6bf3fdf 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -17,6 +17,7 @@
 #include <asm/octeon/cvmx-npei-defs.h>
 #include <asm/octeon/cvmx-pexp-defs.h>
 #include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-ciu2-defs.h>
 #include <asm/octeon/pci-octeon.h>
 #include <asm/mach-cavium-octeon/irq.h>
 
@@ -454,6 +455,124 @@ OCTEON_MSI_INT_HANDLER_X(1);
 OCTEON_MSI_INT_HANDLER_X(2);
 OCTEON_MSI_INT_HANDLER_X(3);
 
+
+static void octeon_msi_ciu2_enable_on_cpu(unsigned int irq, int cpu)
+{
+	int core;
+	int msi = irq - OCTEON_IRQ_MSI_BIT0;
+	union cvmx_ciu2_msi_selx sel;
+
+	core = octeon_coreid_for_cpu(cpu);
+
+	sel.u64 = 0;
+	sel.s.pp_num = core;
+	sel.s.ip_num = 2; /* IP4 */
+	sel.s.en = 1;
+	cvmx_write_csr(CVMX_CIU2_MSI_SELX(msi), sel.u64);
+}
+
+static void octeon_msi_ciu2_enable(unsigned int irq)
+{
+	int cpu;
+	struct irq_desc *desc = irq_to_desc(irq);
+
+#ifdef CONFIG_SMP
+	cpu = cpumask_first(desc->affinity);
+#else
+	cpu = 0;
+#endif
+	octeon_msi_ciu2_enable_on_cpu(irq, cpu);
+}
+
+static void octeon_msi_ciu2_disable(unsigned int irq)
+{
+	int msi = irq - OCTEON_IRQ_MSI_BIT0;
+	union cvmx_ciu2_msi_selx sel;
+
+	sel.u64 = cvmx_read_csr(CVMX_CIU2_MSI_SELX(msi));
+	cvmx_write_csr(CVMX_CIU2_MSI_SELX(msi), 0);
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP4(sel.s.pp_num));
+}
+
+static void octeon_msi_ciu2_ack(unsigned int irq)
+{
+	int msi = irq - OCTEON_IRQ_MSI_BIT0;
+	int core = cvmx_get_core_num();
+
+	cvmx_write_csr(CVMX_CIU2_MSI_RCVX(msi), 0);
+	cvmx_read_csr(CVMX_CIU2_ACK_PPX_IP4(core));
+}
+
+#ifdef CONFIG_SMP
+static int octeon_msi_ciu2_set_affinity(unsigned int irq,
+					const struct cpumask *dest)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	int cpu = cpumask_first(dest);
+
+	/*
+	 * For CIU2-MSI, we will allow only single CPU affinity.
+	 * This .
+	 */
+	if (cpumask_weight(dest) != 1)
+		return -EINVAL;
+
+	if (desc->status & IRQ_DISABLED)
+		return 0;
+
+	octeon_msi_ciu2_enable_on_cpu(irq, cpu);
+
+	return 0;
+}
+#endif
+
+static struct irq_chip octeon_msi_chip_ciu2 = {
+	.name = "CIU2-MSI",
+	.enable = octeon_msi_ciu2_enable,
+	.disable = octeon_msi_ciu2_disable,
+	.ack = octeon_msi_ciu2_ack,
+	.mask = octeon_msi_ciu2_disable,
+	.unmask = octeon_msi_ciu2_enable,
+#ifdef CONFIG_SMP
+	.set_affinity = octeon_msi_ciu2_set_affinity,
+#endif
+};
+
+static void octeon_msi_ip4(void)
+{
+	union cvmx_ciu2_msired_ppx_ip4 msired;
+	int core = cvmx_get_core_num();
+
+	msired.u64 = cvmx_read_csr(CVMX_CIU2_MSIRED_PPX_IP4(core));
+
+	if (msired.s.intr)
+		do_IRQ(msired.s.msi_num + OCTEON_IRQ_MSI_BIT0);
+	else
+		spurious_interrupt();
+}
+
+int __init octeon_msi_68XX_init(void)
+{
+	int i;
+
+	/* Disable legacy handling. */
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB0, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB1, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB2, 0);
+	cvmx_write_csr(CVMX_PEXP_SLI_MSI_ENB3, 0);
+
+	/* Disable CIU2_MSI */
+	for (i = 0; i < 256; i++)
+		cvmx_write_csr(CVMX_CIU2_MSI_SELX(i), 0);
+
+	for (i = OCTEON_IRQ_MSI_BIT0; i <= OCTEON_IRQ_MSI_LAST; i++)
+		set_irq_chip_and_handler(i, &octeon_msi_chip_ciu2, handle_edge_irq);
+
+	octeon_irq_set_ip4_handler(octeon_msi_ip4);
+
+	return 0;
+}
+
 /*
  * Initializes the MSI interrupt handling code
  */
@@ -463,6 +582,9 @@ int __init octeon_msi_initialize(void)
 	struct irq_chip *msi;
 	u64 msi_map_reg;
 
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX) && !OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_X))
+		return octeon_msi_68XX_init();
+
 	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE2) {
 		msi_rcv_reg[0] = CVMX_PEXP_SLI_MSI_RCV0;
 		msi_rcv_reg[1] = CVMX_PEXP_SLI_MSI_RCV1;
-- 
1.7.0

