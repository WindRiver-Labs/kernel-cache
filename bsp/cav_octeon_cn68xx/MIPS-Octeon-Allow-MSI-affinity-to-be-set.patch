From 46f94219d91e3ab31bc9a9b63c7947430f7f4036 Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Tue, 30 Nov 2010 16:11:09 -0800
Subject: [PATCH 34/97] MIPS: Octeon: Allow MSI affinity to be set.

Source: Cavium SDK 2.1.0-407

For PCIe, we distribute the MSI interrupts across all four underlying
interrupt lines using the PEXP_SLI_MSI_WR_MAP/PEXP_NPEI_MSI_WR_MAP
registers.  Then propagate the affinity from the MSI to the underlying
interrupt line and all other MSI that share said line.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/pci/msi-octeon.c |  116 ++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 113 insertions(+), 3 deletions(-)

diff --git a/arch/mips/pci/msi-octeon.c b/arch/mips/pci/msi-octeon.c
index 7bfb856..5911f9b 100644
--- a/arch/mips/pci/msi-octeon.c
+++ b/arch/mips/pci/msi-octeon.c
@@ -269,11 +269,93 @@ static DEFINE_SPINLOCK(octeon_irq_msi_lock);
 static u64 msi_rcv_reg[4];
 static u64 mis_ena_reg[4];
 
+static int (*octeon_irq_msi_to_irq)(int);
+static int (*octeon_irq_iqr_to_msi)(int);
+
+static int octeon_irq_msi_to_irq_linear(int msi)
+{
+	return msi + OCTEON_IRQ_MSI_BIT0;
+}
+
+static int octeon_irq_iqr_to_msi_linear(int irq)
+{
+	return irq - OCTEON_IRQ_MSI_BIT0;
+}
+
+static int octeon_irq_msi_to_irq_scatter(int msi)
+{
+	return (((msi >> 6) & 0x3) | ((msi << 2) & 0xfc)) + OCTEON_IRQ_MSI_BIT0;
+}
+
+static int octeon_irq_iqr_to_msi_scatter(int irq)
+{
+	int t = irq - OCTEON_IRQ_MSI_BIT0;
+	return ((t << 6) & 0xc0) | ((t >> 2) & 0x3f);
+}
+
+static atomic_t affinity_in_progress[4] = {
+	ATOMIC_INIT(1),
+	ATOMIC_INIT(1),
+	ATOMIC_INIT(1),
+	ATOMIC_INIT(1)};
+
+static int octeon_irq_msi_set_affinity_pcie(unsigned int irq,
+					    const struct cpumask *dest)
+{
+	int msi = octeon_irq_iqr_to_msi(irq);
+	int index = msi >> 6;
+	int bit;
+	int r;
+
+	/*
+	 * If we are in the middle of updating the set, the first call
+	 * takes care of everything, do nothing successfully.
+	 */
+	if (atomic_sub_if_positive(1, affinity_in_progress + index) < 0)
+		return 0;
+
+	r = irq_set_affinity(OCTEON_IRQ_PCI_MSI0 + index, dest);
+
+	for (bit = 0; bit < 64; bit++) {
+		int partner = octeon_irq_msi_to_irq(64 * index + bit);
+		if (partner != irq)
+			irq_set_affinity(partner, dest);
+	}
+	atomic_add(1, affinity_in_progress + index);
+	return r;
+}
+
+static int octeon_irq_msi_set_affinity_pci(unsigned int irq,
+					   const struct cpumask *dest)
+{
+	int msi = octeon_irq_iqr_to_msi(irq);
+	int index = msi >> 4;
+	int bit;
+	int r;
+
+	/*
+	 * If we are in the middle of updating the set, the first call
+	 * takes care of everything, do nothing successfully.
+	 */
+	if (atomic_sub_if_positive(1, affinity_in_progress + index) < 0)
+		return 0;
+
+	r = irq_set_affinity(OCTEON_IRQ_PCI_MSI0 + index, dest);
+
+	for (bit = 0; bit < 16; bit++) {
+		int partner = octeon_irq_msi_to_irq(16 * index + bit);
+		if (partner != irq)
+			irq_set_affinity(partner, dest);
+	}
+	atomic_add(1, affinity_in_progress + index);
+	return r;
+}
+
 static void octeon_irq_msi_enable_pcie(unsigned int irq)
 {
 	u64 en;
 	unsigned long flags;
-	int msi_number = irq - OCTEON_IRQ_MSI_BIT0;
+	int msi_number = octeon_irq_iqr_to_msi(irq);
 	int irq_index = msi_number >> 6;
 	int irq_bit = msi_number & 0x3f;
 
@@ -289,7 +371,7 @@ static void octeon_irq_msi_disable_pcie(unsigned int irq)
 {
 	u64 en;
 	unsigned long flags;
-	int msi_number = irq - OCTEON_IRQ_MSI_BIT0;
+	int msi_number = octeon_irq_iqr_to_msi(irq);
 	int irq_index = msi_number >> 6;
 	int irq_bit = msi_number & 0x3f;
 
@@ -305,6 +387,9 @@ static struct irq_chip octeon_irq_chip_msi_pcie = {
 	.name = "MSI",
 	.enable = octeon_irq_msi_enable_pcie,
 	.disable = octeon_irq_msi_disable_pcie,
+#ifdef CONFIG_SMP
+	.set_affinity = octeon_irq_msi_set_affinity_pcie,
+#endif
 };
 
 static void octeon_irq_msi_enable_pci(unsigned int irq)
@@ -327,6 +412,9 @@ static struct irq_chip octeon_irq_chip_msi_pci = {
 	.name = "MSI",
 	.enable = octeon_irq_msi_enable_pci,
 	.disable = octeon_irq_msi_disable_pci,
+#ifdef CONFIG_SMP
+	.set_affinity = octeon_irq_msi_set_affinity_pci,
+#endif
 };
 
 /*
@@ -344,7 +432,7 @@ static irqreturn_t __octeon_msi_do_interrupt(int index, uint64_t msi_bits)
 		/* Acknowledge it first. */
 		cvmx_write_csr(msi_rcv_reg[index], 1ull << bit);
 
-		irq = bit + OCTEON_IRQ_MSI_BIT0 + 64 * index;
+		irq = octeon_irq_msi_to_irq(bit + 64 * index);
 		do_IRQ(irq);
 		return IRQ_HANDLED;
 	}
@@ -373,6 +461,7 @@ int __init octeon_msi_initialize(void)
 {
 	int irq;
 	struct irq_chip *msi;
+	u64 msi_map_reg;
 
 	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE2) {
 		msi_rcv_reg[0] = CVMX_PEXP_SLI_MSI_RCV0;
@@ -384,6 +473,9 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[2] = CVMX_PEXP_SLI_MSI_ENB2;
 		mis_ena_reg[3] = CVMX_PEXP_SLI_MSI_ENB3;
 		msi = &octeon_irq_chip_msi_pcie;
+		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_scatter;
+		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_scatter;
+		msi_map_reg = CVMX_PEXP_SLI_MSI_WR_MAP;
 	} else if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE) {
 		msi_rcv_reg[0] = CVMX_PEXP_NPEI_MSI_RCV0;
 		msi_rcv_reg[1] = CVMX_PEXP_NPEI_MSI_RCV1;
@@ -394,6 +486,9 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[2] = CVMX_PEXP_NPEI_MSI_ENB2;
 		mis_ena_reg[3] = CVMX_PEXP_NPEI_MSI_ENB3;
 		msi = &octeon_irq_chip_msi_pcie;
+		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_scatter;
+		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_scatter;
+		msi_map_reg = CVMX_PEXP_NPEI_MSI_WR_MAP;
 	} else {
 		msi_rcv_reg[0] = CVMX_NPI_NPI_MSI_RCV;
 #define INVALID_GENERATE_ADE 0x8700000000000000ULL;
@@ -405,6 +500,21 @@ int __init octeon_msi_initialize(void)
 		mis_ena_reg[2] = INVALID_GENERATE_ADE;
 		mis_ena_reg[3] = INVALID_GENERATE_ADE;
 		msi = &octeon_irq_chip_msi_pci;
+		octeon_irq_msi_to_irq = octeon_irq_msi_to_irq_linear;
+		octeon_irq_iqr_to_msi = octeon_irq_iqr_to_msi_linear;
+		msi_map_reg = 0;
+	}
+
+	if (msi_map_reg) {
+		int msi;
+		int ciu;
+		u64 e;
+
+		for (msi = 0; msi < 256; msi++) {
+			ciu = (msi >> 2) | ((msi << 6) & 0xc0);
+			e = (ciu << 8) | msi;
+			cvmx_write_csr(msi_map_reg, e);
+		}
 	}
 
 	for (irq = OCTEON_IRQ_MSI_BIT0; irq <= OCTEON_IRQ_MSI_LAST; irq++)
-- 
1.7.0

