From 5b787cc3f97c4929c90da9bc4b6cf62369d1db3c Mon Sep 17 00:00:00 2001
From: Roy Franz <rfranz@rfranz-v430.caveonetworks.com>
Date: Tue, 8 Feb 2011 20:25:36 -0800
Subject: [PATCH 27/97] MIPS: Add reporting of Octeon write buffer parity errors.

Source: Cavium SDK 2.1.0-407

Write buffer parity errors are reported with bus error exceptions,
so a board_be_handler is added to check for this.

Signed-off-by: Roy Franz <roy.franz@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |   30 ++++++++++++++++++++++++++++++
 1 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index a9ff7f7..6c3f265 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -33,6 +33,7 @@
 #include <asm/bootinfo.h>
 #include <asm/sections.h>
 #include <asm/time.h>
+#include <asm/traps.h>
 
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/octeon-boot-info.h>
@@ -623,6 +624,31 @@ int xkphys_usermem_write(long pid, int value)
 void paravirt_prom_init(void)
 	__attribute__((weak, alias("native_prom_init")));
 
+/*
+ * Add Octeon specific bus error handler, as write buffer parity errors
+ * trigger bus errors.  These are fatal since the copy in the write buffer
+ * is the only copy of the data.
+ */
+static int octeon2_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	u64 dcache_err;
+	u64 wbfperr_mask = 1ULL << 1;
+	dcache_err = read_octeon_c0_dcacheerr();
+	if (dcache_err & wbfperr_mask) {
+		unsigned int coreid = cvmx_get_core_num();
+
+		pr_err("Core%u: Write buffer parity error:\n", coreid);
+		pr_err("CacheErr (Dcache) == %llx\n", dcache_err);
+
+		write_octeon_c0_dcacheerr(wbfperr_mask);
+		return MIPS_BE_FATAL;
+	}
+	if (is_fixup)
+		return MIPS_BE_FIXUP;
+	else
+		return MIPS_BE_FATAL;
+}
+
 /**
  * Early entry point for arch setup
  */
@@ -840,6 +866,10 @@ void __init native_prom_init(void)
 	octeon_user_io_init();
 	register_smp_ops(&octeon_smp_ops);
 
+	if (OCTEON_IS_MODEL(OCTEON_CN6XXX))
+		board_be_handler = octeon2_be_handler;
+
+
 	labi = (struct linux_app_boot_info *)PHYS_TO_XKSEG_CACHED(LABI_ADDR_IN_BOOTLOADER);
 	if (labi->labi_signature == LABI_SIGNATURE)
 		octeon_bootloader_entry_addr = labi->InitTLBStart_addr;
-- 
1.7.0

