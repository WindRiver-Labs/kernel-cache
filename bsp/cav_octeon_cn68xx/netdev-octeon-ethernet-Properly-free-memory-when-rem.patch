From f6ffeeee08d847c703554d7a1df47f77369532aa Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Wed, 13 Apr 2011 12:17:11 -0700
Subject: [PATCH 59/97] netdev: octeon-ethernet: Properly free memory when removing the module.

Source: Cavium SDK 2.1.0-407

* Fix SSO cleanup.

* Use free_netdev() instead of kfree().

* Don't get rid of global  kmem_caches.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 drivers/net/octeon/ethernet-rx.c |   44 +++++++++++++++++++++++++------------
 drivers/net/octeon/ethernet.c    |    9 +++++--
 2 files changed, 36 insertions(+), 17 deletions(-)

diff --git a/drivers/net/octeon/ethernet-rx.c b/drivers/net/octeon/ethernet-rx.c
index 93c32d3..d1ea7f0 100644
--- a/drivers/net/octeon/ethernet-rx.c
+++ b/drivers/net/octeon/ethernet-rx.c
@@ -303,6 +303,7 @@ void cvm_oct_poll_controller(struct net_device *dev)
 #endif
 
 static struct kmem_cache *cvm_oct_kmem_sso;
+static int cvm_oct_sso_fptr_count;
 
 void cvm_oct_rx_initialize(int num_wqe)
 {
@@ -361,7 +362,7 @@ void cvm_oct_rx_initialize(int num_wqe)
 		union cvmx_fpa_fpfx_marks fpa_marks;
 		int i;
 		int rwq_bufs = 48 + DIV_ROUND_UP(num_wqe, 26);
-
+		cvm_oct_sso_fptr_count = rwq_bufs;
 		cvm_oct_kmem_sso = kmem_cache_create("octeon_ethernet_sso", 256, 128, 0, NULL);
 		if (cvm_oct_kmem_sso == NULL) {
 			pr_err("cannot create kmem_cache for octeon_ethernet_sso\n");
@@ -488,11 +489,11 @@ void cvm_oct_rx_shutdown(int num_wqe)
 		sso_cfg.s.rwen = 0;
 		sso_cfg.s.rwq_byp_dis = 1;
 		cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
-
+		cvmx_read_csr(CVMX_SSO_CFG);
 		queue_available.u64 = cvmx_read_csr(CVMX_FPA_QUEX_AVAILABLE(8));
 
 		/* Make CVMX_FPA_QUEX_AVAILABLE(8) % 16 == 0*/
-		for (num_to_transfer = (16 - queue_available.s.que_siz) % 16;
+		for (num_to_transfer = 16 - (queue_available.s.que_siz % 16);
 		     num_to_transfer > 0; num_to_transfer--) {
 			do {
 				pop_fptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_POP_FPTR);
@@ -506,31 +507,46 @@ void cvm_oct_rx_shutdown(int num_wqe)
 			fptr.s.fptr = pop_fptr.s.fptr;
 			cvmx_write_csr(CVMX_SSO_RWQ_PSH_FPTR, fptr.u64);
 		}
+		cvmx_read_csr(CVMX_SSO_CFG);
+
+		do {
+			queue_available.u64 = cvmx_read_csr(CVMX_FPA_QUEX_AVAILABLE(8));
+		} while (queue_available.s.que_siz % 16);
 
 		sso_cfg.s.rwen = 1;
 		sso_cfg.s.rwq_byp_dis = 0;
 		cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
 
-		fpage_cnt.u64 = cvmx_read_csr(CVMX_SSO_FPAGE_CNT);
-		count = fpage_cnt.s.fpage_cnt;
-		while (count > 0) {
-			do {
-				pop_fptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_POP_FPTR);
-			} while (!pop_fptr.s.val);
-
-			mem = phys_to_virt(((u64)pop_fptr.s.fptr) << 7);
-			kmem_cache_free(cvm_oct_kmem_sso, mem);
-			count--;
-		}
 		for (i = 0; i < 8; i++) {
 			cvmx_sso_rwq_head_ptrx_t head_ptr;
+			cvmx_sso_rwq_tail_ptrx_t tail_ptr;
 
 			void *mem;
 
 			head_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_HEAD_PTRX(i));
+			tail_ptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_TAIL_PTRX(i));
+			WARN_ON(head_ptr.s.ptr != tail_ptr.s.ptr);
+
 			mem = phys_to_virt(((u64)head_ptr.s.ptr) << 7);
 			kmem_cache_free(cvm_oct_kmem_sso, mem);
 		}
+
+		count = 0;
+
+		do {
+			do {
+				pop_fptr.u64 = cvmx_read_csr(CVMX_SSO_RWQ_POP_FPTR);
+				if (pop_fptr.s.val) {
+					mem = phys_to_virt(((u64)pop_fptr.s.fptr) << 7);
+					kmem_cache_free(cvm_oct_kmem_sso, mem);
+					count++;
+				}
+			} while (pop_fptr.s.val);
+			fpage_cnt.u64 = cvmx_read_csr(CVMX_SSO_FPAGE_CNT);
+		} while (fpage_cnt.s.fpage_cnt);
+
+		WARN_ON(count != cvm_oct_sso_fptr_count);
+
 		sso_cfg.s.rwen = 0;
 		sso_cfg.s.rwq_byp_dis = 0;
 		cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
diff --git a/drivers/net/octeon/ethernet.c b/drivers/net/octeon/ethernet.c
index 6db2eef..34b867a 100644
--- a/drivers/net/octeon/ethernet.c
+++ b/drivers/net/octeon/ethernet.c
@@ -882,6 +882,9 @@ static int __init cvm_oct_init_module(void)
 		if (imode == CVMX_HELPER_INTERFACE_MODE_SRIO)
 			num_ports = 4;
 
+		if (imode == CVMX_HELPER_INTERFACE_MODE_ILK)
+			continue;
+
 		for (interface_port = 0; num_ports > 0;
 		     interface_port++, num_ports--) {
 			struct octeon_ethernet *priv;
@@ -1012,11 +1015,11 @@ static int __init cvm_oct_init_module(void)
 			}
 
 			if (!dev->netdev_ops) {
-				kfree(dev);
+				free_netdev(dev);
 			} else if (register_netdev(dev) < 0) {
 				pr_err("Failed to register ethernet device for interface %d, port %d\n",
 					 interface, priv->ipd_port);
-				kfree(dev);
+				free_netdev(dev);
 			} else {
 				list_add_tail(&priv->list, &cvm_oct_list);
 				if (cvm_oct_by_pkind[priv->ipd_pkind] == NULL)
@@ -1068,7 +1071,7 @@ static void __exit cvm_oct_cleanup_module(void)
 		cancel_delayed_work_sync(&priv->port_periodic_work);
 		unregister_netdev(priv->netdev);
 
-		kfree(priv->netdev);
+		free_netdev(priv->netdev);
 	}
 
 	destroy_workqueue(cvm_oct_poll_queue);
-- 
1.7.0

