From e1adf2eb26ec892c07d9c7605fead8d80945ff1c Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Mon, 4 Aug 2014 15:19:53 -0400
Subject: [PATCH 110/256] hwqueue: keystone: Allow multiple QoS trees per QMSS
 PDSP

This patch permits multiple QoS trees to co-exist within a single
QMSS PDSP. The only user-visible change is that the qos-tree property
of the qos-inputs section may now reference multiple QoS trees.

This patch does NOT extend the number of QoS ports supported per
PDSP (currently 20), and all trees are allocated from the same
range of queues (qos-inputs "values" parameter).

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 0f0004e810665253d545832d7db5cc09be1343ff)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c |  115 ++++++++++++++++++++------------
 drivers/hwqueue/keystone_qos.h         |    7 ++-
 2 files changed, 78 insertions(+), 44 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index 769c19b..e9fb2b65 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -1276,6 +1276,8 @@ static void khwq_qos_free_stats(struct khwq_qos_info *info)
 static void __khwq_free_qos_range(struct khwq_device *kdev,
 				  struct khwq_qos_info *info)
 {
+	int tree_index;
+
 	khwq_qos_free_shadow(info, QOS_SCHED_PORT_CFG);
 	khwq_qos_free_shadow(info, QOS_DROP_CFG_PROF);
 	khwq_qos_free_shadow(info, QOS_DROP_OUT_PROF);
@@ -1283,7 +1285,8 @@ static void __khwq_free_qos_range(struct khwq_device *kdev,
 	khwq_qos_free_stats(info);
 	khwq_qos_free_drop_policies(kdev, info);
 	khwq_qos_free_stats_classes(kdev, info);
-	ktree_remove_tree(&info->qos_tree);
+	for (tree_index = 0; tree_index < info->qos_tree_count; ++tree_index)
+		ktree_remove_tree(&info->qos_trees[tree_index]);
 	kobject_del(info->kobj);
 	kobject_put(info->kobj);
 	kobject_del(info->kobj_stats);
@@ -1844,8 +1847,9 @@ static int khwq_qos_check_overflow(struct khwq_qos_tree_node *qnode,
 }
 
 static int khwq_qos_tree_parse(struct khwq_qos_info *info,
-				    struct device_node *node,
-				    struct khwq_qos_tree_node *parent)
+				int tree_index,
+				struct device_node *node,
+				struct khwq_qos_tree_node *parent)
 {
 	struct khwq_qos_tree_node *qnode;
 	struct khwq_device *kdev = info->kdev;
@@ -1875,6 +1879,7 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	qnode->info = info;
 	qnode->parent = parent;
 	qnode->name = node->name;
+	qnode->tree_index = tree_index;
 
 	of_property_read_string(node, "label", &qnode->name);
 	dev_dbg(kdev->dev, "processing node %s, parent %s%s\n",
@@ -2198,14 +2203,14 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	}
 
 	if (!parent)
-		ktree_set_root(&info->qos_tree, &qnode->node);
+		ktree_set_root(&info->qos_trees[tree_index], &qnode->node);
 	else
 		ktree_add_child_last(&parent->node, &qnode->node);
 
 	num_children = 0;
 	for_each_child_of_node(node, child) {
 		++num_children;
-		error = khwq_qos_tree_parse(info, child, qnode);
+		error = khwq_qos_tree_parse(info, tree_index, child, qnode);
 		if (error)
 			goto error_destroy;
 	}
@@ -2731,54 +2736,64 @@ static int khwq_qos_tree_init(struct khwq_qos_info *info)
 {
 	struct ktree_node *root;
 	int error;
+	int tree_index;
 
-	root = ktree_get_root(&info->qos_tree);
-	if (WARN_ON(!root))
-		return -ENODEV;
+	for (tree_index = 0; tree_index < info->qos_tree_count; ++tree_index) {
+		root = ktree_get_root(&info->qos_trees[tree_index]);
+		if (WARN_ON(!root))
+			return -ENODEV;
 
-	error = khwq_qos_tree_map_nodes(root, info);
-	if (WARN_ON(error))
-		return error;
+		error = khwq_qos_tree_map_nodes(root, info);
+		if (WARN(error, "error %d\n", error)) {
+			ktree_put_node(root);
+			return error;
+		}
 
-	error = khwq_qos_tree_alloc_nodes(root, info);
-	if (error)
-		goto bail;
+		error = khwq_qos_tree_alloc_nodes(root, info);
+		if (error) {
+			ktree_put_node(root);
+			return error;
+		}
 
-	error = 0;
-bail:
-	ktree_put_node(root);
-	return error;
+		ktree_put_node(root);
+	}
+
+	return 0;
 }
 
 int khwq_qos_tree_start(struct khwq_qos_info *info)
 {
 	struct ktree_node *root;
 	int error;
+	int tree_index;
 
-	root = ktree_get_root(&info->qos_tree);
-	if (WARN_ON(!root))
-		return -ENODEV;
+	for (tree_index = 0; tree_index < info->qos_tree_count; ++tree_index) {
+		root = ktree_get_root(&info->qos_trees[tree_index]);
+		if (WARN_ON(!root))
+			return -ENODEV;
 
-	error = khwq_qos_tree_start_nodes(root, info);
-	if (WARN_ON(error))
-		goto bail;
+		error = khwq_qos_tree_start_nodes(root, info);
+		if (WARN(error, "error %d\n", error)) {
+			ktree_put_node(root);
+			return error;
+		}
+
+		ktree_put_node(root);
+	}
 
 	error = khwq_qos_sync_drop_queue(info, -1);
 	if (error) {
 		dev_err(info->kdev->dev, "error syncing drop queues\n");
-		goto bail;
+		return error;
 	}
 
 	error = khwq_qos_sync_drop_out(info, -1);
 	if (error) {
 		dev_err(info->kdev->dev, "error syncing drop outs\n");
-		goto bail;
+		return error;
 	}
-	error = 0;
 
-bail:
-	ktree_put_node(root);
-	return error;
+	return 0;
 }
 
 static int khwq_qos_stop_drop_queues(struct khwq_qos_info *info)
@@ -3789,6 +3804,7 @@ int khwq_init_qos_range(struct khwq_device *kdev, struct device_node *node,
 	struct device *dev = kdev->dev;
 	u32 temp[7];
 	int error;
+	int tree_index;
 
 	info = devm_kzalloc(kdev->dev, sizeof(*info), GFP_KERNEL);
 	if (!info) {
@@ -3848,8 +3864,10 @@ int khwq_init_qos_range(struct khwq_device *kdev, struct device_node *node,
 	INIT_LIST_HEAD(&info->stats_classes);
 	spin_lock_init(&info->lock);
 	/* TODO: add refcount handlers */
-	ktree_init(&info->qos_tree, khwq_qos_get_tree_node,
-		   khwq_qos_put_tree_node);
+	for (tree_index = 0; tree_index < QOS_MAX_TREES; ++tree_index)
+		ktree_init(&info->qos_trees[tree_index],
+			   khwq_qos_get_tree_node,
+			   khwq_qos_put_tree_node);
 
 	error = of_property_read_u32_array(node, "qos-cfg", temp, 7);
 	if (error < 0) {
@@ -3912,17 +3930,30 @@ int khwq_init_qos_range(struct khwq_device *kdev, struct device_node *node,
 		goto bail;
 	of_node_put(child);
 
-	child = of_parse_phandle(node, "qos-tree", 0);
-	if (!child)
-		child = of_get_child_by_name(node, "qos-tree");
-	if (!child) {
-		dev_err(kdev->dev, "could not find qos tree\n");
-		goto bail;
+	for (tree_index = 0;; ++tree_index) {
+		child = of_parse_phandle(node, "qos-tree", tree_index);
+		if (!child && (tree_index == 0))
+			child = of_get_child_by_name(node, "qos-tree");
+		if (!child) {
+			if (tree_index != 0)
+				break;
+			else {
+				dev_err(kdev->dev, "could not find qos tree\n");
+				goto bail;
+			}
+		}
+		if (tree_index >= QOS_MAX_TREES) {
+			of_node_put(child);
+			dev_err(kdev->dev, "too many qos trees\n");
+			break;
+		}
+
+		error = khwq_qos_tree_parse(info, tree_index, child, NULL);
+		of_node_put(child);
+		if (error)
+			goto bail;
 	}
-	error = khwq_qos_tree_parse(info, child, NULL);
-	if (error)
-		goto bail;
-	of_node_put(child);
+	info->qos_tree_count = tree_index;
 
 	error = khwq_qos_tree_init(info);
 	if (error)
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index 81fe08d..2ae52f3 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -25,6 +25,7 @@
 
 #define QOS_MAX_INPUTS			128
 #define	QOS_MAX_CHILDREN		8
+#define	QOS_MAX_TREES			8
 
 #define QOS_RETCODE_SUCCESS		1
 
@@ -155,7 +156,8 @@ struct khwq_qos_info {
 	u32				 refcount;
 	struct khwq_qos_shadow		 shadows[QOS_MAX_SHADOW];
 	struct khwq_qos_stats		 stats;
-	struct ktree			 qos_tree;
+	int				 qos_tree_count;
+	struct ktree			 qos_trees[QOS_MAX_TREES];
 	struct list_head		 drop_policies;
 	struct list_head		 stats_classes;
 	struct khwq_qos_drop_policy	*default_drop_policy;
@@ -231,8 +233,9 @@ struct khwq_qos_tree_node {
 	bool	 is_drop_input;		/* indicates that child's output
 					   feeds to the drop sched	*/
 	bool	 has_sched_port;	/* does this port need a sched?	*/
-	bool	 is_joint_port;		/* Even/odd joint pair*/
+	bool	 is_joint_port;		/* Even/odd joint pair		*/
 	int	 output_queue;		/* from DT or calculated	*/
+	int	 tree_index;		/* khwq_qos_info.qos_trees index */
 
 	/* allocated resources */
 	int	 sched_port_idx;	/* inherited by default nodes	*/
-- 
1.7.5.4

