From c7f3d9ae9e2ae888ff0120e1ef8a6830708f2086 Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Thu, 18 Apr 2013 15:25:45 -0400
Subject: [PATCH 021/256] pci: keystone: pcie: add support of legacy irq

This patch adds support of Keystone PCIe legacy irq by implementing an irq chip.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
(cherry picked from commit 320007d3e90711f83c3b8236de10517519790d93)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/pci/host/pcie-keystone.c |  115 +++++++++++++++++++++++++++++++++++++-
 1 files changed, 113 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/host/pcie-keystone.c b/drivers/pci/host/pcie-keystone.c
index cedb28e..10d8a8e 100644
--- a/drivers/pci/host/pcie-keystone.c
+++ b/drivers/pci/host/pcie-keystone.c
@@ -62,6 +62,7 @@
 #define MSI0_IRQ_STATUS			0x104
 #define MSI0_IRQ_ENABLE_SET		0x108
 #define MSI0_IRQ_ENABLE_CLR		0x10c
+#define IRQ_STATUS			0x184
 #define IRQ_ENABLE_SET			0x188
 #define IRQ_ENABLE_CLR			0x18c
 
@@ -116,6 +117,8 @@ struct keystone_pcie_info {
 	/* legacy Host irqs */
 	int num_legacy_irqs;
 	int legacy_irqs[MAX_LEGACY_HOST_IRQS];
+	struct irq_domain *legacy_irqd;
+	int virqs[MAX_LEGACY_HOST_IRQS];
 	/* MSI IRQs */
 	int num_msi_host_irqs;
 	int msi_host_irqs[MAX_MSI_HOST_IRQS];
@@ -610,6 +613,87 @@ static void unmask_legacy_irq(void __iomem *reg_virt, int i)
 	__raw_writel(0xf, reg_virt + IRQ_ENABLE_SET + (offset << 2));
 }
 
+/**
+ * keystone_legacy_irq_handler() - Handle legacy interrupt
+ * @irq: IRQ line for legacy interrupts
+ * @desc: Pointer to irq descriptor
+ *
+ * Traverse through pending legacy interrupts and invoke handler for each. Also
+ * takes care of interrupt controller level mask/ack operation.
+ */
+static void keystone_legacy_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct keystone_pcie_info *info = irq_desc_get_handler_data(desc);
+	u32 irq_offset = irq - info->legacy_irqs[0], pending;
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	int virq;
+
+	pr_debug(DRIVER_NAME ": Handling legacy irq %d\n", irq);
+
+	/*
+	 * The chained irq handler installation would have replaced normal
+	 * interrupt driver handler so we need to take care of mask/unmask and
+	 * ack operation.
+	 */
+	chip->irq_mask(&desc->irq_data);
+	if (chip->irq_ack)
+		chip->irq_ack(&desc->irq_data);
+	if (chip->irq_eoi)
+		chip->irq_eoi(&desc->irq_data);
+
+	pending = __raw_readl(info->reg_cfg_virt +
+			IRQ_STATUS + (irq_offset << 2));
+
+	if (BIT(0) & pending) {
+		irq_offset = irq_offset;
+		virq = irq_linear_revmap(info->legacy_irqd, irq_offset);
+		pr_debug("irq: irq_offset %d, virq %d\n",
+				 irq_offset, virq);
+		generic_handle_irq(virq);
+	}
+
+	chip->irq_unmask(&desc->irq_data);
+}
+
+static void ack_irq(struct irq_data *d)
+{
+	struct keystone_pcie_info *info = irq_data_get_irq_chip_data(d);
+	u32 offset;
+	unsigned int irq = d->irq;
+
+	offset = irq - irq_linear_revmap(info->legacy_irqd, 0);
+	__raw_writel(BIT(offset), info->reg_cfg_virt + IRQ_EOI);
+}
+
+static void mask_irq(struct irq_data *d)
+{
+	struct keystone_pcie_info *info = irq_data_get_irq_chip_data(d);
+	u32 offset;
+	unsigned int irq = d->irq;
+
+	offset = irq - irq_linear_revmap(info->legacy_irqd, 0);
+	__raw_writel(BIT(0),
+		info->reg_cfg_virt + IRQ_ENABLE_CLR + (offset << 2));
+}
+
+static void unmask_irq(struct irq_data *d)
+{
+	struct keystone_pcie_info *info = irq_data_get_irq_chip_data(d);
+	u32 offset;
+	unsigned int irq = d->irq;
+
+	offset = irq - irq_linear_revmap(info->msi_irqd, 0);
+	__raw_writel(BIT(0),
+		info->reg_cfg_virt + IRQ_ENABLE_SET + (offset << 2));
+}
+
+static struct irq_chip keystone_legacy_irq_chip = {
+	.name = "PCIe-LEGACY-IRQ",
+	.irq_ack = ack_irq,
+	.irq_mask = mask_irq,
+	.irq_unmask = unmask_irq,
+};
+
 #ifdef CONFIG_PCI_MSI
 static DECLARE_BITMAP(msi_irq_bits, MAX_MSI_IRQS);
 
@@ -922,9 +1006,8 @@ static int keystone_pcie_setup(int nr, struct pci_sys_data *sys)
 	 * each config write and restore 32-bit IO decode configuration.
 	 */
 
-	/* IRQ setup. TODO, do we need to set up irq_chip data as in c6x? */
 	for (i = 0; i < info->num_legacy_irqs; i++) {
-		if (info->legacy_irqs[0] >= 0)
+		if (info->legacy_irqs[i] >= 0)
 			unmask_legacy_irq(reg_virt, i);
 		else
 			mask_legacy_irq(reg_virt, i);
@@ -1305,6 +1388,34 @@ static int __init keystone_pcie_rc_init(void)
 		goto err1;
 	}
 
+	if (rc_info->num_legacy_irqs) {
+		/* need to set up legacy irq chip */
+		rc_info->legacy_irqd = irq_domain_add_linear(np,
+					rc_info->num_legacy_irqs,
+					&irq_domain_simple_ops, NULL);
+		if (!rc_info->legacy_irqd) {
+			pr_err(DRIVER_NAME
+				": failed to add irq domain for legacy irqs\n");
+			goto err1;
+		}
+
+		for (i = 0; i < rc_info->num_legacy_irqs; i++) {
+			rc_info->virqs[i] =
+				irq_create_mapping(rc_info->legacy_irqd, i);
+			irq_set_chip_and_handler(rc_info->virqs[i],
+				&keystone_legacy_irq_chip, handle_level_irq);
+			irq_set_chip_data(rc_info->virqs[i], rc_info);
+			set_irq_flags(rc_info->legacy_irqs[i], IRQF_VALID);
+
+			if (rc_info->legacy_irqs[i] >= 0) {
+				irq_set_handler_data(rc_info->legacy_irqs[i],
+					rc_info);
+				irq_set_chained_handler(rc_info->legacy_irqs[i],
+					keystone_legacy_irq_handler);
+			}
+		}
+	}
+
 	if (rc_info->num_msi_irqs) {
 		/* need to set up msi irq chip */
 		rc_info->msi_irqd = irq_domain_add_linear(np,
-- 
1.7.5.4

