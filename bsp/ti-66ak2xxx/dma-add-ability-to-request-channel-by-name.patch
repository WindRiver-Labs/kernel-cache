From b574f3f5cd0e0b85c2e8fa85fef55be72e2f3730 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 12 May 2015 23:40:41 +0800
Subject: [PATCH 036/256] dma: add ability to request channel by name

This commit f3418bcb comes from:
  git://git.ti.com/keystone-linux/linux.git

This patch adds a new dma_request_channel_by_name() interface that allows
drivers to use a simpler name match model.  This rides alongside the current
filter function model.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
-
---
 drivers/dma/dmaengine.c   |   35 +++++++++++++++++++++++++++++++++--
 include/linux/dmaengine.h |   29 ++++++++++++++++++++++++++++-
 2 files changed, 61 insertions(+), 3 deletions(-)

diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index a4068e2..46508c5 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -473,8 +473,13 @@ static void dma_channel_rebalance(void)
 }
 
 static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
-					  struct dma_device *dev,
-					  dma_filter_fn fn, void *fn_param)
+#ifdef CONFIG_TI_KEYSTONE
+				struct dma_device *dev, const char *name,
+				dma_filter_fn fn, void *fn_param)
+#else
+				struct dma_device *dev,
+				dma_filter_fn fn, void *fn_param)
+#endif
 {
 	struct dma_chan *chan;
 
@@ -498,6 +503,15 @@ static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
 				 __func__, dma_chan_name(chan));
 			continue;
 		}
+#ifdef CONFIG_TI_KEYSTONE
+		if (name) {
+			if (!chan->name || strcmp(name, chan->name)) {
+				pr_debug("%s: %s name mismatch\n",
+					 __func__, dma_chan_name(chan));
+				continue;
+			}
+		}
+#endif
 		if (fn && !fn(chan, fn_param)) {
 			pr_debug("%s: %s filter said false\n",
 				 __func__, dma_chan_name(chan));
@@ -535,7 +549,11 @@ struct dma_chan *dma_get_slave_channel(struct dma_chan *chan)
 }
 EXPORT_SYMBOL_GPL(dma_get_slave_channel);
 
+#ifdef CONFIG_TI_KEYSTONE
+struct dma_chan *dma_get_any_slave_channel(struct dma_device *device, const char *name)
+#else
 struct dma_chan *dma_get_any_slave_channel(struct dma_device *device)
+#endif
 {
 	dma_cap_mask_t mask;
 	struct dma_chan *chan;
@@ -547,7 +565,12 @@ struct dma_chan *dma_get_any_slave_channel(struct dma_device *device)
 	/* lock against __dma_request_channel */
 	mutex_lock(&dma_list_mutex);
 
+#ifdef CONFIG_TI_KEYSTONE
+	chan = private_candidate(&mask, device, name, NULL, NULL);
+#else
 	chan = private_candidate(&mask, device, NULL, NULL);
+#endif
+
 	if (chan) {
 		err = dma_chan_get(chan);
 		if (err) {
@@ -571,7 +594,11 @@ EXPORT_SYMBOL_GPL(dma_get_any_slave_channel);
  *
  * Returns pointer to appropriate DMA channel on success or NULL.
  */
+#ifdef CONFIG_TI_KEYSTONE
+struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask, const char *name,
+#else
 struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+#endif
 				       dma_filter_fn fn, void *fn_param)
 {
 	struct dma_device *device, *_d;
@@ -581,7 +608,11 @@ struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
 	/* Find a channel */
 	mutex_lock(&dma_list_mutex);
 	list_for_each_entry_safe(device, _d, &dma_device_list, global_node) {
+#ifdef CONFIG_TI_KEYSTONE
+		chan = private_candidate(mask, device, name, fn, fn_param);
+#else
 		chan = private_candidate(mask, device, fn, fn_param);
+#endif
 		if (chan) {
 			/* Found a suitable channel, try to grab, prep, and
 			 * return it.  We first set DMA_PRIVATE to disable
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 0a5f552..ed5f342 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -262,6 +262,9 @@ struct dma_chan_percpu {
  * @private: private data for certain client-channel associations
  */
 struct dma_chan {
+#ifdef CONFIG_TI_KEYSTONE
+	const char *name;
+#endif
 	struct dma_device *device;
 	dma_cookie_t cookie;
 	dma_cookie_t completed_cookie;
@@ -1067,8 +1070,13 @@ struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
 enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
 enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
 void dma_issue_pending_all(void);
+#ifdef CONFIG_TI_KEYSTONE
+struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask, const char *name,
+			       dma_filter_fn fn, void *fn_param);
+#else
 struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
 					dma_filter_fn fn, void *fn_param);
+#endif
 struct dma_chan *dma_request_slave_channel_reason(struct device *dev,
 						  const char *name);
 struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name);
@@ -1089,7 +1097,12 @@ static inline enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descript
 static inline void dma_issue_pending_all(void)
 {
 }
+#ifdef CONFIG_TI_KEYSTONE
+static inline struct dma_chan *
+__dma_request_channel(const dma_cap_mask_t *mask,  const char *name,
+#else
 static inline struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+#endif
 					      dma_filter_fn fn, void *fn_param)
 {
 	return NULL;
@@ -1115,12 +1128,22 @@ int dma_async_device_register(struct dma_device *device);
 void dma_async_device_unregister(struct dma_device *device);
 void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
 struct dma_chan *dma_get_slave_channel(struct dma_chan *chan);
+#ifdef CONFIG_TI_KEYSTONE
+struct dma_chan *dma_get_any_slave_channel(struct dma_device *device, const char *name);
+#else
 struct dma_chan *dma_get_any_slave_channel(struct dma_device *device);
+#endif
 struct dma_chan *net_dma_find_channel(void);
+#ifdef CONFIG_TI_KEYSTONE
+#define dma_request_channel(mask, x, y)			\
+	__dma_request_channel(&(mask), NULL, x, y)
+#define dma_request_channel_by_name(mask, name)			\
+	__dma_request_channel(&(mask), name, NULL, NULL)
+#else
 #define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
+#endif
 #define dma_request_slave_channel_compat(mask, x, y, dev, name) \
 	__dma_request_slave_channel_compat(&(mask), x, y, dev, name)
-
 static inline struct dma_chan
 *__dma_request_slave_channel_compat(const dma_cap_mask_t *mask,
 				  dma_filter_fn fn, void *fn_param,
@@ -1132,7 +1155,11 @@ static inline struct dma_chan
 	if (chan)
 		return chan;
 
+#ifdef CONFIG_TI_KEYSTONE
+	return __dma_request_channel(mask, name, fn, fn_param);
+#else
 	return __dma_request_channel(mask, fn, fn_param);
+#endif
 }
 
 /* --- Helper iov-locking functions --- */
-- 
1.7.5.4

