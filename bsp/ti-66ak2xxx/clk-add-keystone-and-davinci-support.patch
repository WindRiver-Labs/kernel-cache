From 4dc40554f77afc9c984a36c16db8d22a4ef8cc33 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 5 May 2015 15:47:18 +0800
Subject: [PATCH 010/256] clk: add keystone and davinci support

This patch comes from:
  git://git.ti.com/keystone-linux/linux.git

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/clk/Kconfig                            |    8 +-
 drivers/clk/Makefile                           |    2 +
 drivers/clk/davinci/Kconfig                    |   42 +++
 drivers/clk/davinci/Makefile                   |    3 +
 drivers/clk/davinci/clk-davinci-pll.c          |  128 ++++++++
 drivers/clk/davinci/clk-davinci-psc.c          |  323 ++++++++++++++++++++
 drivers/clk/davinci/davinci-clock.c            |  379 ++++++++++++++++++++++++
 drivers/clk/keystone/Kconfig                   |    6 +
 drivers/clk/keystone/Makefile                  |    2 +-
 drivers/clk/keystone/clk-keystone-pll.c        |  184 ++++++++++++
 drivers/clk/keystone/gate.c                    |  269 -----------------
 drivers/clk/keystone/pll.c                     |  321 --------------------
 include/linux/platform_data/clk-davinci-pll.h  |   54 ++++
 include/linux/platform_data/clk-davinci-psc.h  |   58 ++++
 include/linux/platform_data/clk-keystone-pll.h |   56 ++++
 include/linux/platform_data/davinci-clock.h    |  149 ++++++++++
 16 files changed, 1387 insertions(+), 597 deletions(-)
 create mode 100644 drivers/clk/davinci/Kconfig
 create mode 100644 drivers/clk/davinci/Makefile
 create mode 100644 drivers/clk/davinci/clk-davinci-pll.c
 create mode 100644 drivers/clk/davinci/clk-davinci-psc.c
 create mode 100644 drivers/clk/davinci/davinci-clock.c
 create mode 100644 drivers/clk/keystone/Kconfig
 create mode 100644 drivers/clk/keystone/clk-keystone-pll.c
 delete mode 100644 drivers/clk/keystone/gate.c
 delete mode 100644 drivers/clk/keystone/pll.c
 create mode 100644 include/linux/platform_data/clk-davinci-pll.h
 create mode 100644 include/linux/platform_data/clk-davinci-psc.h
 create mode 100644 include/linux/platform_data/clk-keystone-pll.h
 create mode 100644 include/linux/platform_data/davinci-clock.h

diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 7641965..f0c0cc5 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -100,14 +100,10 @@ config COMMON_CLK_XGENE
 	---help---
 	  Sypport for the APM X-Gene SoC reference, PLL, and device clocks.
 
-config COMMON_CLK_KEYSTONE
-	tristate "Clock drivers for Keystone based SOCs"
-	depends on ARCH_KEYSTONE && OF
-	---help---
-          Supports clock drivers for Keystone based SOCs. These SOCs have local
-	  a power sleep control module that gate the clock to the IPs and PLLs.
 
 source "drivers/clk/qcom/Kconfig"
+source "drivers/clk/davinci/Kconfig"
+source "drivers/clk/keystone/Kconfig"
 
 endmenu
 
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index a367a98..42f146e 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -50,3 +50,5 @@ obj-$(CONFIG_ARCH_U8500)		+= ux500/
 obj-$(CONFIG_COMMON_CLK_VERSATILE)	+= versatile/
 obj-$(CONFIG_X86)			+= x86/
 obj-$(CONFIG_ARCH_ZYNQ)			+= zynq/
+obj-$(CONFIG_DAVINCI_CLKS)		+= davinci/
+obj-$(CONFIG_CLK_KEYSTONE_PLL)		+= keystone/
diff --git a/drivers/clk/davinci/Kconfig b/drivers/clk/davinci/Kconfig
new file mode 100644
index 0000000..2202c25
--- /dev/null
+++ b/drivers/clk/davinci/Kconfig
@@ -0,0 +1,42 @@
+menu "TI DaVinci Clock Drivers"
+	depends on COMMON_CLK
+
+config  CLK_DAVINCI_PSC
+	bool "TI DaVici PSC Clock driver"
+	default n
+	---help---
+	  Selects clock driver for DaVinci PSC clocks. This clock
+	  hardware is found on TI DaVinci SoCs and other SoCs that
+	  uses this hardware IP. This hardware has a local power
+	  sleep control module that gate the clock to the IP.
+
+config  CLK_DAVINCI_PLL
+	bool "DaVici Main PLL clock"
+	---help---
+	  Selects clock driver for DaVinci Main PLL. This clock
+	  hardware is found on TI DaVinci SoCs. This typically has
+	  a multiplier, a pre divider and post driver. Some of the
+	  SoCs has the the dividers fixed, and others have it
+	  programmable
+
+config DAVINCI_CLKS
+	bool "TI DaVinci common clocks"
+	default n
+	select CLK_DAVINCI_PSC
+	select DAVINCI_CLKINIT
+	---help---
+	  Selects common clock drivers for DaVinci. These clocks
+	  are re-used across many TI SoCs that are based on DaVinci and
+	  Keystone (c6x) families. This config option is used to select
+	  the common clock driver for DaVinci based SoCs. SoCs specific
+	  Kconfig option needs to select the driver for clocks specific
+	  to the SoC.
+
+config	DAVINCI_CLKINIT
+	bool "TI DaVici Clock initialization"
+	default n
+	---help---
+	  Selects clock driver initialization for DaVinci and Keystone
+	  architectures.
+endmenu
+
diff --git a/drivers/clk/davinci/Makefile b/drivers/clk/davinci/Makefile
new file mode 100644
index 0000000..420e9c3
--- /dev/null
+++ b/drivers/clk/davinci/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_CLK_DAVINCI_PLL)	+= clk-davinci-pll.o
+obj-$(CONFIG_CLK_DAVINCI_PSC)	+= clk-davinci-psc.o
+obj-$(CONFIG_DAVINCI_CLKINIT)	+= davinci-clock.o
diff --git a/drivers/clk/davinci/clk-davinci-pll.c b/drivers/clk/davinci/clk-davinci-pll.c
new file mode 100644
index 0000000..13e1690
--- /dev/null
+++ b/drivers/clk/davinci/clk-davinci-pll.c
@@ -0,0 +1,128 @@
+/*
+ * PLL clk driver DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * TODO - Add set_parent_rate()
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/platform_data/clk-davinci-pll.h>
+
+#include <mach/cputype.h>
+
+#define PLLM		0x110
+#define PLLM_PLLM_MASK  0xff
+#define PREDIV          0x114
+#define POSTDIV         0x128
+#define PLLDIV_EN       BIT(15)
+
+/**
+ * struct clk_davinci_pll - DaVinci Main pll clock
+ * @hw: clk_hw for the pll
+ * @pll_data: PLL driver specific data
+ */
+struct clk_davinci_pll {
+	struct clk_hw hw;
+	struct clk_davinci_pll_data *pll_data;
+};
+
+#define to_clk_pll(_hw) container_of(_hw, struct clk_davinci_pll, hw)
+
+static unsigned long clk_pllclk_recalc(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct clk_davinci_pll *pll = to_clk_pll(hw);
+	struct clk_davinci_pll_data *pll_data = pll->pll_data;
+	u32 mult = 1, prediv = 1, postdiv = 1;
+	unsigned long rate = parent_rate;
+
+	/* If there is a device specific recalc defined invoke it. Otherwise
+	 * fallback to default one
+	 */
+	mult = __raw_readl(pll_data->pllm);
+	if (pll_data->pllm_multiplier)
+		mult =  pll_data->pllm_multiplier *
+				(mult & pll_data->pllm_mask);
+	else
+		mult = (mult & pll_data->pllm_mask) + 1;
+
+	if (pll_data->flags & CLK_DAVINCI_PLL_HAS_PREDIV) {
+		/* pre-divider is fixed, take prediv value from pll_data  */
+		if (pll_data->fixed_prediv)
+			prediv = pll_data->fixed_prediv;
+		else {
+			prediv = __raw_readl(pll_data->prediv);
+			if (prediv & PLLDIV_EN)
+				prediv = (prediv & pll_data->prediv_mask) + 1;
+			else
+				prediv = 1;
+		}
+	}
+
+	if (pll_data->flags & CLK_DAVINCI_PLL_HAS_POSTDIV) {
+		postdiv = __raw_readl(pll_data->postdiv);
+		if (postdiv & PLLDIV_EN)
+			postdiv = (postdiv & pll_data->postdiv_mask) + 1;
+		else
+			postdiv = 1;
+	}
+
+	rate /= prediv;
+	rate *= mult;
+	rate /= postdiv;
+
+	pr_debug("PLL%d: input = %lu MHz [ ",
+		 pll_data->num, parent_rate / 1000000);
+	if (prediv > 1)
+		pr_debug("/ %d ", prediv);
+	if (mult > 1)
+		pr_debug("* %d ", mult);
+	if (postdiv > 1)
+		pr_debug("/ %d ", postdiv);
+	pr_debug("] --> %lu MHz output.\n", rate / 1000000);
+	return rate;
+}
+
+static const struct clk_ops clk_pll_ops = {
+	.recalc_rate = clk_pllclk_recalc,
+};
+
+struct clk *clk_register_davinci_pll(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_davinci_pll_data *pll_data)
+{
+	struct clk_init_data init;
+	struct clk_davinci_pll *pll;
+	struct clk *clk;
+
+	if (!pll_data)
+		return ERR_PTR(-ENODEV);
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+	init.name = name;
+	init.ops = &clk_pll_ops;
+	init.flags = pll_data->flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	pll->pll_data	= pll_data;
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
diff --git a/drivers/clk/davinci/clk-davinci-psc.c b/drivers/clk/davinci/clk-davinci-psc.c
new file mode 100644
index 0000000..e57616d
--- /dev/null
+++ b/drivers/clk/davinci/clk-davinci-psc.c
@@ -0,0 +1,323 @@
+/*
+ * PSC clk driver for DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/platform_data/clk-davinci-psc.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/module.h>
+
+/* PSC register offsets */
+#define EPCPR		0x070
+#define PTCMD		0x120
+#define PTSTAT		0x128
+#define PDSTAT		0x200
+#define PDCTL		0x300
+#define MDSTAT		0x800
+#define MDCTL		0xA00
+
+/* PSC module states */
+#define PSC_STATE_SWRSTDISABLE	0
+#define PSC_STATE_SYNCRST	1
+#define PSC_STATE_DISABLE	2
+#define PSC_STATE_ENABLE	3
+
+#define MDSTAT_STATE_MASK	0x3f
+#define PDSTAT_STATE_MASK	0x1f
+#define MDCTL_FORCE		BIT(31)
+#define MDCTL_LRESET		BIT(8)
+#define PDCTL_NEXT		BIT(0)
+#define PDCTL_EPCGOOD		BIT(8)
+
+/* PSC flags */
+#define PSC_SWRSTDISABLE	BIT(0) /* Disable state is SwRstDisable */
+#define PSC_FORCE		BIT(1) /* Force module state transtition */
+#define PSC_HAS_EXT_POWER_CNTL	BIT(2) /* PSC has external power control
+					* available (for DM6446 SoC) */
+#define PSC_LRESET		BIT(3) /* Keep module in local reset */
+#define STATE_TRANS_MAX_COUNT	0xffff /* Maximum timeout to bail out state
+					* transition for module */
+/**
+ * struct clk_psc - DaVinci PSC clock
+ * @hw: clk_hw for the psc
+ * @psc_data: PSC driver specific data
+ * @lock: Spinlock used by the driver
+ */
+struct clk_psc {
+	struct clk_hw hw;
+	struct clk_davinci_psc_data *psc_data;
+	spinlock_t *lock;
+};
+
+#define to_clk_psc(_hw) container_of(_hw, struct clk_psc, hw)
+
+/* Enable or disable a PSC domain */
+static void clk_psc_config(void __iomem *base, unsigned int domain,
+		unsigned int id, bool enable, u32 flags)
+{
+	u32 epcpr, ptcmd, ptstat, pdstat, pdctl, mdstat, mdctl;
+	u32 next_state = PSC_STATE_ENABLE;
+	void __iomem *psc_base = base;
+	u32 count = STATE_TRANS_MAX_COUNT;
+
+	if (!enable) {
+		if (flags & PSC_SWRSTDISABLE)
+			next_state = PSC_STATE_SWRSTDISABLE;
+		else
+			next_state = PSC_STATE_DISABLE;
+	}
+
+	mdctl = __raw_readl(psc_base + MDCTL + 4 * id);
+	mdctl &= ~MDSTAT_STATE_MASK;
+	mdctl |= next_state;
+	if (flags & PSC_FORCE)
+		mdctl |= MDCTL_FORCE;
+
+	if (flags & PSC_LRESET)
+		mdctl &= ~MDCTL_LRESET;
+
+	/* For disable, we always put the module in local reset */
+	if (!enable)
+		mdctl &= ~MDCTL_LRESET;
+
+	__raw_writel(mdctl, psc_base + MDCTL + 4 * id);
+
+	pdstat = __raw_readl(psc_base + PDSTAT + 4 * domain);
+	if ((pdstat & PDSTAT_STATE_MASK) == 0) {
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= PDCTL_NEXT;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+
+		ptcmd = 1 << domain;
+		__raw_writel(ptcmd, psc_base + PTCMD);
+
+		if (flags & PSC_HAS_EXT_POWER_CNTL) {
+			do {
+				epcpr = __raw_readl(psc_base + EPCPR);
+			} while ((((epcpr >> domain) & 1) == 0));
+		}
+
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= 0x100;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= PDCTL_EPCGOOD;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+	} else {
+		ptcmd = 1 << domain;
+		__raw_writel(ptcmd, psc_base + PTCMD);
+	}
+
+	do {
+		ptstat = __raw_readl(psc_base + PTSTAT);
+	} while (!(((ptstat >> domain) & 1) == 0) && (count--));
+
+	if (!count)
+		goto err;
+
+	count = STATE_TRANS_MAX_COUNT;
+	do {
+		mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state) && (count--));
+err:
+	return;
+}
+
+static int clk_psc_is_enabled(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	u32 mdstat;
+
+	mdstat = __raw_readl(psc_data->base + MDSTAT + 4 * psc_data->lpsc);
+	/* if clocked, state can be "Enable" or "SyncReset" */
+	return (mdstat & BIT(12)) ? 1 : 0;
+}
+
+static int clk_psc_enable(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	unsigned long flags = 0;
+
+	if (psc->lock)
+		spin_lock_irqsave(psc->lock, flags);
+
+	clk_psc_config(psc_data->base, psc_data->domain, psc_data->lpsc,
+			1, psc_data->psc_flags);
+
+	if (psc->lock)
+		spin_unlock_irqrestore(psc->lock, flags);
+
+	return 0;
+}
+
+static void clk_psc_disable(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	unsigned long flags = 0;
+
+	if (psc->lock)
+		spin_lock_irqsave(psc->lock, flags);
+
+	clk_psc_config(psc_data->base, psc_data->domain, psc_data->lpsc,
+			0, psc_data->psc_flags);
+
+	if (psc->lock)
+		spin_unlock_irqrestore(psc->lock, flags);
+}
+
+static const struct clk_ops clk_psc_ops = {
+	.enable = clk_psc_enable,
+	.disable = clk_psc_disable,
+	.is_enabled = clk_psc_is_enabled,
+};
+
+/**
+ * clk_register_davinci_psc - register davinci psc clock
+ * @dev: device that is registering this clock
+ * @name: name of this clock
+ * @parent_name: name of clock's parent
+ * @psc_data: platform data to configure this clock
+ * @lock: spinlock used by this clock
+ */
+struct clk *clk_register_davinci_psc(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_davinci_psc_data *psc_data,
+			spinlock_t *lock)
+{
+	struct clk_init_data init;
+	struct clk_psc *psc;
+	struct clk *clk;
+
+	psc = kzalloc(sizeof(*psc), GFP_KERNEL);
+	if (!psc)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_psc_ops;
+	init.flags = psc_data->flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	psc->psc_data = psc_data;
+	psc->lock = lock;
+	psc->hw.init = &init;
+
+	clk = clk_register(NULL, &psc->hw);
+	if (IS_ERR(clk))
+		kfree(psc);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(clk_register_davinci_psc);
+
+#ifdef CONFIG_OF
+#define NUM_GPSC	2
+struct reg_psc {
+	u32 phy_base;
+	u32 size;
+	void __iomem *io_base;
+};
+
+static struct reg_psc psc_addr[NUM_GPSC];
+
+/**
+ * of_davinci_psc_clk_init - initialize davinci psc clock through DT
+ * @node: device tree node for this clock
+ * @lock: spinlock used by this clock
+ */
+void __init of_davinci_psc_clk_init(struct device_node *node, spinlock_t *lock)
+{
+	const char *parent_name, *status = NULL, *base_flags = NULL;
+	struct clk_davinci_psc_data *data;
+	const char *clk_name = node->name;
+	u32 gpsc = 0, lpsc = 0, pd = 0;
+	struct resource res;
+	struct clk *clk;
+	int rc;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	WARN_ON(!data);
+
+	if (of_address_to_resource(node, 0, &res)) {
+		pr_err("psc_clk_init - no reg property defined\n");
+		goto out;
+	}
+
+	of_property_read_u32(node, "gpsc", &gpsc);
+	of_property_read_u32(node, "lpsc", &lpsc);
+	of_property_read_u32(node, "pd", &pd);
+
+	if (gpsc >= NUM_GPSC) {
+		pr_err("psc_clk_init - no reg property defined\n");
+		goto out;
+	}
+
+	of_property_read_string(node,
+			"clock-output-names", &clk_name);
+	parent_name = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parent_name);
+
+	/* Expected that same phy_base is used for all psc clocks of
+	 * a give gpsc. So ioremap is done only once.
+	 */
+	if (psc_addr[gpsc].phy_base) {
+		if (psc_addr[gpsc].phy_base != res.start) {
+			pr_err("Different psc base for same GPSC\n");
+			goto out;
+		}
+	} else {
+		psc_addr[gpsc].phy_base = res.start;
+		psc_addr[gpsc].io_base =
+			ioremap(res.start, resource_size(&res));
+	}
+
+	WARN_ON(!psc_addr[gpsc].io_base);
+	data->base = psc_addr[gpsc].io_base;
+	data->lpsc = lpsc;
+	data->gpsc = gpsc;
+	data->domain = pd;
+
+	of_property_read_string_index(node, "base-flags", 0, &base_flags);
+	if (base_flags && !strcmp(base_flags, "ignore-unused"))
+		data->flags = CLK_IGNORE_UNUSED;
+
+	if (of_property_read_bool(node, "ti,psc-lreset"))
+		data->psc_flags |= PSC_LRESET;
+	if (of_property_read_bool(node, "ti,psc-force"))
+		data->psc_flags |= PSC_FORCE;
+
+	clk = clk_register_davinci_psc(NULL, clk_name, parent_name,
+				data, lock);
+
+	if (clk) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+
+		rc = of_property_read_string(node, "status", &status);
+		if (status && !strcmp(status, "enabled"))
+			clk_prepare_enable(clk);
+		return;
+	}
+	pr_err("psc_clk_init - error registering psc clk %s\n", node->name);
+out:
+	kfree(data);
+	return;
+}
+EXPORT_SYMBOL_GPL(of_davinci_psc_clk_init);
+#endif
diff --git a/drivers/clk/davinci/davinci-clock.c b/drivers/clk/davinci/davinci-clock.c
new file mode 100644
index 0000000..506aa8c
--- /dev/null
+++ b/drivers/clk/davinci/davinci-clock.c
@@ -0,0 +1,379 @@
+/*
+ * Clock initialization code for DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_data/clk-davinci-pll.h>
+#include <linux/platform_data/clk-keystone-pll.h>
+#include <linux/platform_data/clk-davinci-psc.h>
+#include <linux/platform_data/davinci-clock.h>
+#include <linux/of.h>
+
+static DEFINE_SPINLOCK(_lock);
+
+#ifndef CONFIG_OF
+struct clk *davinci_lookup_clk(struct davinci_clk_lookup *clocks,
+				const char *con_id)
+{
+	struct davinci_clk_lookup *c;
+
+	for (c = clocks; c->_clk; c++) {
+		if (c->con_id && !strcmp(c->con_id, con_id))
+			return c->clk;
+	}
+	return NULL;
+}
+
+#ifdef	CONFIG_CLK_DAVINCI_PLL
+static void register_davinci_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_davinci_pll_data *pll_data)
+{
+
+	WARN_ON(!pll_data->phy_pllm);
+	pll_data->pllm = ioremap(pll_data->phy_pllm, 4);
+	WARN_ON(!pll_data->pllm);
+	if (pll_data->phy_prediv) {
+		pll_data->prediv = ioremap(pll_data->phy_prediv, 4);
+		WARN_ON(!pll_data->prediv);
+	}
+	if (pll_data->phy_postdiv) {
+		pll_data->postdiv = ioremap(pll_data->phy_postdiv, 4);
+		WARN_ON(!pll_data->postdiv);
+	}
+	c->clk = clk_register_davinci_pll(NULL,
+			c->_clk->name, c->_clk->parent->name,
+			pll_data);
+}
+#else
+static void register_davinci_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_davinci_pll_data *pll_data)
+{
+	return;
+}
+#endif
+
+#ifdef	CONFIG_CLK_KEYSTONE_PLL
+static void register_keystone_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_keystone_pll_data *pll_data)
+{
+	WARN_ON(!pll_data->phy_pllm);
+	pll_data->pllm = ioremap(pll_data->phy_pllm, 4);
+	WARN_ON(!pll_data->pllm);
+	WARN_ON(!pll_data->phy_main_pll_ctl0);
+	pll_data->main_pll_ctl0 =
+		ioremap(pll_data->phy_main_pll_ctl0, 4);
+	WARN_ON(!pll_data->main_pll_ctl0);
+	c->clk = clk_register_keystone_pll(NULL,
+			c->_clk->name, c->_clk->parent->name,
+			 pll_data);
+}
+#else
+static void register_keystone_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_keystone_pll_data *pll_data)
+{
+	return;
+}
+#endif
+
+int __init davinci_common_clk_init(struct davinci_clk_lookup *clocks,
+				struct davinci_dev_lookup *dev_clk_lookups,
+				u8 num_gpscs, u32 *psc_bases)
+{
+	void __iomem **base = NULL, *reg;
+	struct davinci_clk_lookup *c;
+	struct davinci_clk *_clk;
+	unsigned long rate;
+	int i, skip;
+
+	WARN_ON(!num_gpscs);
+	WARN_ON(psc_bases == NULL);
+
+	base = kzalloc(sizeof(void __iomem *) * num_gpscs, GFP_KERNEL);
+	WARN_ON(!base);
+	for (i = 0; i < num_gpscs; i++) {
+		base[i] = ioremap(psc_bases[i], SZ_4K);
+		WARN_ON(!base[i]);
+	}
+
+	for (c = clocks; c->_clk; c++) {
+		skip = 0;
+		_clk = c->_clk;
+
+		WARN_ON(!_clk->clk_data.data);
+		switch (_clk->type) {
+		case DAVINCI_FIXED_RATE_CLK:
+		{
+			struct clk_fixed_rate_data *data = _clk->clk_data.fixed_rate;
+
+			if (data->recalc)
+				rate = data->recalc(0);
+			else
+				rate = data->rate;
+
+			c->clk = clk_register_fixed_rate(NULL, _clk->name,
+					NULL, data->flags, rate);
+			break;
+		}
+		case KEYSTONE_MAIN_PLL_CLK:
+		{
+			struct clk_keystone_pll_data *data =
+					_clk->clk_data.keystone_pll;
+
+			register_keystone_pll_clk(c, data);
+			break;
+		}
+		case DAVINCI_MAIN_PLL_CLK:
+		{
+			struct clk_davinci_pll_data *data =
+					_clk->clk_data.davinci_pll;
+
+			register_davinci_pll_clk(c, data);
+			break;
+		}
+		case DAVINCI_PRG_DIV_CLK:
+		{
+			struct clk_divider_data *data = _clk->clk_data.pll_div;
+
+			/* This is a PLL derived clock with divider specified by
+			 * div_reg in pll_div_data.
+			 */
+			reg = ioremap(data->div_reg, 4);
+			WARN_ON(!reg);
+			c->clk = clk_register_divider(NULL, _clk->name,
+					_clk->parent->name, data->flags,
+					reg, data->shift, data->width,
+					data->divider_flags, &_lock);
+			break;
+		}
+		case DAVINCI_PSC_CLK:
+		{
+			struct clk_davinci_psc_data *data = _clk->clk_data.psc;
+
+			WARN_ON(!base);
+			WARN_ON(data->gpsc >= num_gpscs);
+			data->base = base[data->gpsc];
+			c->clk = clk_register_davinci_psc(NULL, _clk->name,
+					_clk->parent->name, data, &_lock);
+			break;
+		}
+		case DAVINCI_MUX_CLK:
+		{
+			struct clk_mux_data *data = _clk->clk_data.mux;
+
+			WARN_ON(!data->phys_base);
+			reg = ioremap(data->phys_base, 4);
+			WARN_ON(!reg);
+			c->clk = clk_register_mux(NULL, _clk->name,
+					data->parents, data->num_parents,
+					data->flags, reg, data->shift,
+					data->width, data->mux_flags, &_lock);
+			break;
+		}
+		case DAVINCI_FIXED_FACTOR_CLK:
+		{
+			struct clk_fixed_factor_data *data
+						 = _clk->clk_data.fixed_factor;
+
+			WARN_ON(!data->mult);
+			WARN_ON(!data->div);
+			c->clk = clk_register_fixed_factor(NULL, _clk->name,
+					_clk->parent->name, data->flags,
+					data->mult, data->div);
+			break;
+		}
+		default:
+			skip = 1;
+			pr_warn("Unknown clock - %s\n", _clk->name);
+		}
+
+		if (!skip) {
+			WARN_ON(!c->clk);
+			if (clk_register_clkdev(c->clk,
+					c->con_id, c->dev_id) < 0) {
+				pr_err("Error in registering clkdev, %s\n",
+					_clk->name);
+			}
+			/* Enable ALWAYS_ENABLED clocks */
+			if (_clk->flags & ALWAYS_ENABLED)
+				clk_prepare_enable(c->clk);
+		}
+	}
+
+	if (dev_clk_lookups) {
+		struct davinci_dev_lookup *c;
+		struct clk *clk;
+
+		for (c = dev_clk_lookups; c->con_id; c++) {
+			/* register the clock lookup table */
+			clk = davinci_lookup_clk(clocks, c->con_id);
+			WARN_ON(!clk);
+
+			for (i = 0; i < c->num_devs; i++) {
+				if (clk_register_clkdev(clk,
+					c->lookups[i].con_id,
+					c->lookups[i].dev_id) < 0) {
+					pr_err("Error in registering clkdev" \
+						" for dev_id %s\n",
+						c->lookups[i].dev_id);
+				}
+			}
+		}
+	}
+	return 0;
+}
+#else
+
+static void __init pll_div_clk_init(struct device_node *node)
+{
+	const char *parent_name;
+	void __iomem *reg;
+	u32 shift, width;
+	struct clk *clk;
+
+	reg = of_iomap(node, 0);
+	WARN_ON(!reg);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parent_name);
+
+	if (of_property_read_u32(node, "shift", &shift)) {
+		pr_err("pll_div_clk_init - no shift value defined\n");
+		return;
+	}
+
+	if (of_property_read_u32(node, "width", &width)) {
+		pr_err("pll_div_clk_init - no width value defined\n");
+		return;
+	}
+
+	clk = clk_register_divider(NULL, node->name, parent_name, 0, reg, shift,
+				 width, 0, &_lock);
+
+	if (clk)
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		pr_err("pll_div_clk_init - error in registering mux clk %s\n",
+			node->name);
+}
+
+/* These will go away once there is support in clk-mux for DT */
+static void __init main_pll_mux_clk_init(struct device_node *node)
+{
+	const char *parents[2];
+	void __iomem *reg;
+	u32 shift, width;
+	struct clk *clk;
+
+	reg = of_iomap(node, 0);
+	WARN_ON(!reg);
+
+	parents[0] = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parents[0]);
+	parents[1] = of_clk_get_parent_name(node, 1);
+	WARN_ON(!parents[1]);
+
+	if (of_property_read_u32(node, "shift", &shift)) {
+		pr_err("main_pll_mux_clk_init - no shift value defined\n");
+		return;
+	}
+
+	if (of_property_read_u32(node, "width", &width)) {
+		pr_err("main_pll_mux_clk_init - no width value defined\n");
+		return;
+	}
+
+	clk = clk_register_mux(NULL, node->name, (const char **)&parents,
+				ARRAY_SIZE(parents) , 0, reg, shift, width,
+				0, &_lock);
+
+	if (clk)
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		pr_err("main_pll_mux_clk_init - error registe mux clk %s\n",
+			 node->name);
+}
+
+static void __init of_davinci_psc_clk_setup(struct device_node *node)
+{
+	of_davinci_psc_clk_init(node, &_lock);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "fixed-clock-factor", .data =
+					 of_fixed_factor_clk_setup, },
+	{ .compatible = "keystone,main-pll-clk", .data =
+					of_keystone_pll_clk_init, },
+	{ .compatible = "davinci,main-pll-mux-clk", .data =
+						main_pll_mux_clk_init, },
+	{ .compatible = "davinci,pll-divider-clk", .data = pll_div_clk_init, },
+	{ .compatible = "davinci,psc-clk", .data = of_davinci_psc_clk_setup, },
+	{ .compatible = "keystone,pll-clk", .data =
+					of_keystone_pll_clk_init, },
+	{}
+};
+
+static const __initconst struct of_device_id clk_psc_match[] = {
+	{ .compatible = "davinci,psc-clk", .data = of_davinci_psc_clk_setup, },
+	{}
+};
+
+void __init davinci_of_clk_init()
+{
+	/* initialize clk providers from device tree */
+	of_clk_init(clk_match);
+}
+
+void __init davinci_add_clkdev(struct davinci_clk_lookup *clocks)
+{
+	struct device_node *np;
+
+	/*
+	 * When drivers use device nodes for provider clock info, this will
+	 * become obsolete. Until then we need a way to register clk devices.
+	 * for dt incompatible device drivers.
+	 */
+	if (clocks == NULL)
+		return;
+
+	for_each_matching_node(np, clk_psc_match) {
+		struct davinci_clk_lookup *c;
+		struct davinci_clk *_clk;
+		const char *clk_name;
+		struct clk *clk;
+
+		clk_name = np->name;
+		of_property_read_string(np,
+			"clock-output-names", &clk_name);
+		/* get clk through provider */
+		clk = of_clk_get(np, 0);
+		if (clk) {
+			for (c = clocks; c->_clk; c++) {
+				_clk = c->_clk;
+				if (!strcmp(_clk->name, clk_name) &&
+					(clk_register_clkdev(clk, c->con_id,
+						 c->dev_id) < 0)) {
+					pr_err("Error register clkdev,%s\n",
+						clk_name);
+					break;
+				}
+			}
+		} else {
+			pr_err("Error getting clk provider info, %s\n",
+				clk_name);
+		}
+	}
+}
+#endif
diff --git a/drivers/clk/keystone/Kconfig b/drivers/clk/keystone/Kconfig
new file mode 100644
index 0000000..c0ea97a
--- /dev/null
+++ b/drivers/clk/keystone/Kconfig
@@ -0,0 +1,6 @@
+config  CLK_KEYSTONE_PLL
+	bool "Keystone Main PLL clock"
+	---help---
+	  Selects the clock driver for Keystone Main PLL. This clock
+	  hardware is found on TI c6x based SoCs
+
diff --git a/drivers/clk/keystone/Makefile b/drivers/clk/keystone/Makefile
index 0477cf6..6ae8ae9 100644
--- a/drivers/clk/keystone/Makefile
+++ b/drivers/clk/keystone/Makefile
@@ -1 +1 @@
-obj-y			+= pll.o gate.o
+obj-$(CONFIG_CLK_KEYSTONE_PLL)	+= clk-keystone-pll.o
diff --git a/drivers/clk/keystone/clk-keystone-pll.c b/drivers/clk/keystone/clk-keystone-pll.c
new file mode 100644
index 0000000..c55e69f
--- /dev/null
+++ b/drivers/clk/keystone/clk-keystone-pll.c
@@ -0,0 +1,184 @@
+/*
+ * Main PLL clk driver for Keystone devices
+ *
+ * Copyright (C) 2012 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_data/clk-keystone-pll.h>
+
+#define CLKOD_MASK		0x780000
+#define CLKOD_SHIFT		19
+
+/**
+ * struct clk_pll - DaVinci Main pll clock
+ * @hw: clk_hw for the pll
+ * @pll_data: PLL driver specific data
+ */
+struct clk_pll {
+	struct clk_hw hw;
+	struct clk_keystone_pll_data *pll_data;
+};
+
+#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)
+
+static unsigned long clk_pllclk_recalc(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct clk_pll *pll = to_clk_pll(hw);
+	struct clk_keystone_pll_data *pll_data = pll->pll_data;
+	unsigned long rate = parent_rate;
+	u32  mult = 0, prediv, postdiv, val;
+
+	/*
+	 * get bits 0-5 of multiplier from pllctrl PLLM register
+	 * if has_pllctrl is non zero */
+	if (pll_data->has_pllctrl) {
+		val = __raw_readl(pll_data->pllm);
+		mult = (val & pll_data->pllm_lower_mask);
+	}
+
+	/* bit6-12 of PLLM is in Main PLL control register */
+	val = __raw_readl(pll_data->pll_ctl0);
+	mult |= ((val & pll_data->pllm_upper_mask)
+			>> pll_data->pllm_upper_shift);
+	prediv = (val & pll_data->plld_mask);
+
+	if (!pll_data->has_pllctrl)
+		/* read post divider from od bits*/
+		postdiv = ((val & pll_data->clkod_mask) >>
+				 pll_data->clkod_shift) + 1;
+	else
+		postdiv = pll_data->postdiv;
+
+	rate /= (prediv + 1);
+	rate = (rate * (mult + 1));
+	rate /= postdiv;
+
+	if (parent_rate) {
+		if (pll_data->has_pllctrl && parent_rate)
+			pr_notice("Main PLL clk (%ld Hz), parent (%ld Hz)," \
+				  "postdiv = %d, mult = %d, prediv = %d\n",
+				  rate, parent_rate, postdiv, mult, prediv);
+
+		else
+			pr_notice("Generic PLL clk (%ld Hz), parent (%ld Hz)," \
+				  "postdiv = %d, mult = %d, prediv = %d\n",
+				  rate, parent_rate, postdiv, mult, prediv);
+	}
+	return rate;
+}
+
+static const struct clk_ops clk_pll_ops = {
+	.recalc_rate = clk_pllclk_recalc,
+};
+
+struct clk *clk_register_keystone_pll(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_keystone_pll_data *pll_data)
+{
+	struct clk_init_data init;
+	struct clk_pll *pll;
+	struct clk *clk;
+
+	if (!pll_data)
+		return ERR_PTR(-ENODEV);
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_pll_ops;
+	init.flags = 0;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	pll->pll_data	= pll_data;
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		goto out;
+
+	return clk;
+out:
+	kfree(pll);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(clk_register_keystone_pll);
+
+#ifdef CONFIG_OF
+void __init of_keystone_pll_clk_init(struct device_node *node)
+{
+	struct clk_keystone_pll_data *pll_data;
+	const char *parent_name;
+	struct clk *clk;
+	int temp;
+
+	pll_data = kzalloc(sizeof(*pll_data), GFP_KERNEL);
+	WARN_ON(!pll_data);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_find_property(node, "pll_has_pllctrl", &temp)) {
+		/* PLL is controlled by the pllctrl */
+		pll_data->has_pllctrl = 1;
+		pll_data->pllm = of_iomap(node, 0);
+		WARN_ON(!pll_data->pllm);
+
+		pll_data->pll_ctl0 = of_iomap(node, 1);
+		WARN_ON(!pll_data->pll_ctl0);
+
+		if (of_property_read_u32(node, "pllm_lower_mask",
+			&pll_data->pllm_lower_mask))
+			goto out;
+
+	} else {
+		/* PLL is controlled by the ctrl register */
+		pll_data->has_pllctrl = 0;
+		pll_data->pll_ctl0 = of_iomap(node, 0);
+	}
+
+	if (of_property_read_u32(node, "pllm_upper_mask",
+			&pll_data->pllm_upper_mask))
+		goto out;
+
+	if (of_property_read_u32(node, "pllm_upper_shift",
+			&pll_data->pllm_upper_shift))
+		goto out;
+
+	if (of_property_read_u32(node, "plld_mask", &pll_data->plld_mask))
+		goto out;
+
+	if (of_property_read_u32(node, "fixed_postdiv",
+					&pll_data->postdiv)) {
+		pll_data->clkod_mask = CLKOD_MASK;
+		pll_data->clkod_shift = CLKOD_SHIFT;
+	}
+
+	clk = clk_register_keystone_pll(NULL, node->name, parent_name,
+					 pll_data);
+	if (clk) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		return;
+	}
+out:
+	pr_err("of_keystone_pll_clk_init - error initializing clk %s\n",
+		 node->name);
+	kfree(pll_data);
+}
+EXPORT_SYMBOL_GPL(of_keystone_pll_clk_init);
+#endif
diff --git a/drivers/clk/keystone/gate.c b/drivers/clk/keystone/gate.c
deleted file mode 100644
index 86f1e36..0000000
--- a/drivers/clk/keystone/gate.c
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * Clock driver for Keystone 2 based devices
- *
- * Copyright (C) 2013 Texas Instruments.
- *	Murali Karicheri <m-karicheri2@ti.com>
- *	Santosh Shilimkar <santosh.shilimkar@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/of_address.h>
-#include <linux/of.h>
-#include <linux/module.h>
-
-/* PSC register offsets */
-#define PTCMD			0x120
-#define PTSTAT			0x128
-#define PDSTAT			0x200
-#define PDCTL			0x300
-#define MDSTAT			0x800
-#define MDCTL			0xa00
-
-/* PSC module states */
-#define PSC_STATE_SWRSTDISABLE	0
-#define PSC_STATE_SYNCRST	1
-#define PSC_STATE_DISABLE	2
-#define PSC_STATE_ENABLE	3
-
-#define MDSTAT_STATE_MASK	0x3f
-#define MDSTAT_MCKOUT		BIT(12)
-#define PDSTAT_STATE_MASK	0x1f
-#define MDCTL_FORCE		BIT(31)
-#define MDCTL_LRESET		BIT(8)
-#define PDCTL_NEXT		BIT(0)
-
-/* Maximum timeout to bail out state transition for module */
-#define STATE_TRANS_MAX_COUNT	0xffff
-
-static void __iomem *domain_transition_base;
-
-/**
- * struct clk_psc_data - PSC data
- * @control_base: Base address for a PSC control
- * @domain_base: Base address for a PSC domain
- * @domain_id: PSC domain id number
- */
-struct clk_psc_data {
-	void __iomem *control_base;
-	void __iomem *domain_base;
-	u32 domain_id;
-};
-
-/**
- * struct clk_psc - PSC clock structure
- * @hw: clk_hw for the psc
- * @psc_data: PSC driver specific data
- * @lock: Spinlock used by the driver
- */
-struct clk_psc {
-	struct clk_hw hw;
-	struct clk_psc_data *psc_data;
-	spinlock_t *lock;
-};
-
-static DEFINE_SPINLOCK(psc_lock);
-
-#define to_clk_psc(_hw) container_of(_hw, struct clk_psc, hw)
-
-static void psc_config(void __iomem *control_base, void __iomem *domain_base,
-						u32 next_state, u32 domain_id)
-{
-	u32 ptcmd, pdstat, pdctl, mdstat, mdctl, ptstat;
-	u32 count = STATE_TRANS_MAX_COUNT;
-
-	mdctl = readl(control_base + MDCTL);
-	mdctl &= ~MDSTAT_STATE_MASK;
-	mdctl |= next_state;
-	/* For disable, we always put the module in local reset */
-	if (next_state == PSC_STATE_DISABLE)
-		mdctl &= ~MDCTL_LRESET;
-	writel(mdctl, control_base + MDCTL);
-
-	pdstat = readl(domain_base + PDSTAT);
-	if (!(pdstat & PDSTAT_STATE_MASK)) {
-		pdctl = readl(domain_base + PDCTL);
-		pdctl |= PDCTL_NEXT;
-		writel(pdctl, domain_base + PDCTL);
-	}
-
-	ptcmd = 1 << domain_id;
-	writel(ptcmd, domain_transition_base + PTCMD);
-	do {
-		ptstat = readl(domain_transition_base + PTSTAT);
-	} while (((ptstat >> domain_id) & 1) && count--);
-
-	count = STATE_TRANS_MAX_COUNT;
-	do {
-		mdstat = readl(control_base + MDSTAT);
-	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state) && count--);
-}
-
-static int keystone_clk_is_enabled(struct clk_hw *hw)
-{
-	struct clk_psc *psc = to_clk_psc(hw);
-	struct clk_psc_data *data = psc->psc_data;
-	u32 mdstat = readl(data->control_base + MDSTAT);
-
-	return (mdstat & MDSTAT_MCKOUT) ? 1 : 0;
-}
-
-static int keystone_clk_enable(struct clk_hw *hw)
-{
-	struct clk_psc *psc = to_clk_psc(hw);
-	struct clk_psc_data *data = psc->psc_data;
-	unsigned long flags = 0;
-
-	if (psc->lock)
-		spin_lock_irqsave(psc->lock, flags);
-
-	psc_config(data->control_base, data->domain_base,
-				PSC_STATE_ENABLE, data->domain_id);
-
-	if (psc->lock)
-		spin_unlock_irqrestore(psc->lock, flags);
-
-	return 0;
-}
-
-static void keystone_clk_disable(struct clk_hw *hw)
-{
-	struct clk_psc *psc = to_clk_psc(hw);
-	struct clk_psc_data *data = psc->psc_data;
-	unsigned long flags = 0;
-
-	if (psc->lock)
-		spin_lock_irqsave(psc->lock, flags);
-
-	psc_config(data->control_base, data->domain_base,
-				PSC_STATE_DISABLE, data->domain_id);
-
-	if (psc->lock)
-		spin_unlock_irqrestore(psc->lock, flags);
-}
-
-static const struct clk_ops clk_psc_ops = {
-	.enable = keystone_clk_enable,
-	.disable = keystone_clk_disable,
-	.is_enabled = keystone_clk_is_enabled,
-};
-
-/**
- * clk_register_psc - register psc clock
- * @dev: device that is registering this clock
- * @name: name of this clock
- * @parent_name: name of clock's parent
- * @psc_data: platform data to configure this clock
- * @lock: spinlock used by this clock
- */
-static struct clk *clk_register_psc(struct device *dev,
-			const char *name,
-			const char *parent_name,
-			struct clk_psc_data *psc_data,
-			spinlock_t *lock)
-{
-	struct clk_init_data init;
-	struct clk_psc *psc;
-	struct clk *clk;
-
-	psc = kzalloc(sizeof(*psc), GFP_KERNEL);
-	if (!psc)
-		return ERR_PTR(-ENOMEM);
-
-	init.name = name;
-	init.ops = &clk_psc_ops;
-	init.flags = 0;
-	init.parent_names = (parent_name ? &parent_name : NULL);
-	init.num_parents = (parent_name ? 1 : 0);
-
-	psc->psc_data = psc_data;
-	psc->lock = lock;
-	psc->hw.init = &init;
-
-	clk = clk_register(NULL, &psc->hw);
-	if (IS_ERR(clk))
-		kfree(psc);
-
-	return clk;
-}
-
-/**
- * of_psc_clk_init - initialize psc clock through DT
- * @node: device tree node for this clock
- * @lock: spinlock used by this clock
- */
-static void __init of_psc_clk_init(struct device_node *node, spinlock_t *lock)
-{
-	const char *clk_name = node->name;
-	const char *parent_name;
-	struct clk_psc_data *data;
-	struct clk *clk;
-	int i;
-
-	data = kzalloc(sizeof(*data), GFP_KERNEL);
-	if (!data) {
-		pr_err("%s: Out of memory\n", __func__);
-		return;
-	}
-
-	i = of_property_match_string(node, "reg-names", "control");
-	data->control_base = of_iomap(node, i);
-	if (!data->control_base) {
-		pr_err("%s: control ioremap failed\n", __func__);
-		goto out;
-	}
-
-	i = of_property_match_string(node, "reg-names", "domain");
-	data->domain_base = of_iomap(node, i);
-	if (!data->domain_base) {
-		pr_err("%s: domain ioremap failed\n", __func__);
-		goto unmap_ctrl;
-	}
-
-	of_property_read_u32(node, "domain-id", &data->domain_id);
-
-	/* Domain transition registers at fixed address space of domain_id 0 */
-	if (!domain_transition_base && !data->domain_id)
-		domain_transition_base = data->domain_base;
-
-	of_property_read_string(node, "clock-output-names", &clk_name);
-	parent_name = of_clk_get_parent_name(node, 0);
-	if (!parent_name) {
-		pr_err("%s: Parent clock not found\n", __func__);
-		goto unmap_domain;
-	}
-
-	clk = clk_register_psc(NULL, clk_name, parent_name, data, lock);
-	if (!IS_ERR(clk)) {
-		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-		return;
-	}
-
-	pr_err("%s: error registering clk %s\n", __func__, node->name);
-
-unmap_domain:
-	iounmap(data->domain_base);
-unmap_ctrl:
-	iounmap(data->control_base);
-out:
-	kfree(data);
-	return;
-}
-
-/**
- * of_keystone_psc_clk_init - initialize psc clock through DT
- * @node: device tree node for this clock
- */
-static void __init of_keystone_psc_clk_init(struct device_node *node)
-{
-	of_psc_clk_init(node, &psc_lock);
-}
-CLK_OF_DECLARE(keystone_gate_clk, "ti,keystone,psc-clock",
-					of_keystone_psc_clk_init);
diff --git a/drivers/clk/keystone/pll.c b/drivers/clk/keystone/pll.c
deleted file mode 100644
index 0dd8a4b..0000000
--- a/drivers/clk/keystone/pll.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * PLL clock driver for Keystone devices
- *
- * Copyright (C) 2013 Texas Instruments Inc.
- *	Murali Karicheri <m-karicheri2@ti.com>
- *	Santosh Shilimkar <santosh.shilimkar@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/of_address.h>
-#include <linux/of.h>
-#include <linux/module.h>
-
-#define PLLM_LOW_MASK		0x3f
-#define PLLM_HIGH_MASK		0x7ffc0
-#define MAIN_PLLM_HIGH_MASK	0x7f000
-#define PLLM_HIGH_SHIFT		6
-#define PLLD_MASK		0x3f
-#define CLKOD_MASK		0x780000
-#define CLKOD_SHIFT		19
-
-/**
- * struct clk_pll_data - pll data structure
- * @has_pllctrl: If set to non zero, lower 6 bits of multiplier is in pllm
- *	register of pll controller, else it is in the pll_ctrl0((bit 11-6)
- * @phy_pllm: Physical address of PLLM in pll controller. Used when
- *	has_pllctrl is non zero.
- * @phy_pll_ctl0: Physical address of PLL ctrl0. This could be that of
- *	Main PLL or any other PLLs in the device such as ARM PLL, DDR PLL
- *	or PA PLL available on keystone2. These PLLs are controlled by
- *	this register. Main PLL is controlled by a PLL controller.
- * @pllm: PLL register map address
- * @pll_ctl0: PLL controller map address
- * @pllm_lower_mask: multiplier lower mask
- * @pllm_upper_mask: multiplier upper mask
- * @pllm_upper_shift: multiplier upper shift
- * @plld_mask: divider mask
- * @clkod_mask: output divider mask
- * @clkod_shift: output divider shift
- * @plld_mask: divider mask
- * @postdiv: Fixed post divider
- */
-struct clk_pll_data {
-	bool has_pllctrl;
-	u32 phy_pllm;
-	u32 phy_pll_ctl0;
-	void __iomem *pllm;
-	void __iomem *pll_ctl0;
-	u32 pllm_lower_mask;
-	u32 pllm_upper_mask;
-	u32 pllm_upper_shift;
-	u32 plld_mask;
-	u32 clkod_mask;
-	u32 clkod_shift;
-	u32 postdiv;
-};
-
-/**
- * struct clk_pll - Main pll clock
- * @hw: clk_hw for the pll
- * @pll_data: PLL driver specific data
- */
-struct clk_pll {
-	struct clk_hw hw;
-	struct clk_pll_data *pll_data;
-};
-
-#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)
-
-static unsigned long clk_pllclk_recalc(struct clk_hw *hw,
-					unsigned long parent_rate)
-{
-	struct clk_pll *pll = to_clk_pll(hw);
-	struct clk_pll_data *pll_data = pll->pll_data;
-	unsigned long rate = parent_rate;
-	u32  mult = 0, prediv, postdiv, val;
-
-	/*
-	 * get bits 0-5 of multiplier from pllctrl PLLM register
-	 * if has_pllctrl is non zero
-	 */
-	if (pll_data->has_pllctrl) {
-		val = readl(pll_data->pllm);
-		mult = (val & pll_data->pllm_lower_mask);
-	}
-
-	/* bit6-12 of PLLM is in Main PLL control register */
-	val = readl(pll_data->pll_ctl0);
-	mult |= ((val & pll_data->pllm_upper_mask)
-			>> pll_data->pllm_upper_shift);
-	prediv = (val & pll_data->plld_mask);
-
-	if (!pll_data->has_pllctrl)
-		/* read post divider from od bits*/
-		postdiv = ((val & pll_data->clkod_mask) >>
-				 pll_data->clkod_shift) + 1;
-	else
-		postdiv = pll_data->postdiv;
-
-	rate /= (prediv + 1);
-	rate = (rate * (mult + 1));
-	rate /= postdiv;
-
-	return rate;
-}
-
-static const struct clk_ops clk_pll_ops = {
-	.recalc_rate = clk_pllclk_recalc,
-};
-
-static struct clk *clk_register_pll(struct device *dev,
-			const char *name,
-			const char *parent_name,
-			struct clk_pll_data *pll_data)
-{
-	struct clk_init_data init;
-	struct clk_pll *pll;
-	struct clk *clk;
-
-	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
-	if (!pll)
-		return ERR_PTR(-ENOMEM);
-
-	init.name = name;
-	init.ops = &clk_pll_ops;
-	init.flags = 0;
-	init.parent_names = (parent_name ? &parent_name : NULL);
-	init.num_parents = (parent_name ? 1 : 0);
-
-	pll->pll_data	= pll_data;
-	pll->hw.init = &init;
-
-	clk = clk_register(NULL, &pll->hw);
-	if (IS_ERR(clk))
-		goto out;
-
-	return clk;
-out:
-	kfree(pll);
-	return NULL;
-}
-
-/**
- * _of_clk_init - PLL initialisation via DT
- * @node: device tree node for this clock
- * @pllctrl: If true, lower 6 bits of multiplier is in pllm register of
- *		pll controller, else it is in the control regsiter0(bit 11-6)
- */
-static void __init _of_pll_clk_init(struct device_node *node, bool pllctrl)
-{
-	struct clk_pll_data *pll_data;
-	const char *parent_name;
-	struct clk *clk;
-	int i;
-
-	pll_data = kzalloc(sizeof(*pll_data), GFP_KERNEL);
-	if (!pll_data) {
-		pr_err("%s: Out of memory\n", __func__);
-		return;
-	}
-
-	parent_name = of_clk_get_parent_name(node, 0);
-	if (of_property_read_u32(node, "fixed-postdiv",	&pll_data->postdiv)) {
-		/* assume the PLL has output divider register bits */
-		pll_data->clkod_mask = CLKOD_MASK;
-		pll_data->clkod_shift = CLKOD_SHIFT;
-	}
-
-	i = of_property_match_string(node, "reg-names", "control");
-	pll_data->pll_ctl0 = of_iomap(node, i);
-	if (!pll_data->pll_ctl0) {
-		pr_err("%s: ioremap failed\n", __func__);
-		goto out;
-	}
-
-	pll_data->pllm_lower_mask = PLLM_LOW_MASK;
-	pll_data->pllm_upper_shift = PLLM_HIGH_SHIFT;
-	pll_data->plld_mask = PLLD_MASK;
-	pll_data->has_pllctrl = pllctrl;
-	if (!pll_data->has_pllctrl) {
-		pll_data->pllm_upper_mask = PLLM_HIGH_MASK;
-	} else {
-		pll_data->pllm_upper_mask = MAIN_PLLM_HIGH_MASK;
-		i = of_property_match_string(node, "reg-names", "multiplier");
-		pll_data->pllm = of_iomap(node, i);
-		if (!pll_data->pllm) {
-			iounmap(pll_data->pll_ctl0);
-			goto out;
-		}
-	}
-
-	clk = clk_register_pll(NULL, node->name, parent_name, pll_data);
-	if (clk) {
-		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-		return;
-	}
-
-out:
-	pr_err("%s: error initializing pll %s\n", __func__, node->name);
-	kfree(pll_data);
-}
-
-/**
- * of_keystone_pll_clk_init - PLL initialisation DT wrapper
- * @node: device tree node for this clock
- */
-static void __init of_keystone_pll_clk_init(struct device_node *node)
-{
-	_of_pll_clk_init(node, false);
-}
-CLK_OF_DECLARE(keystone_pll_clock, "ti,keystone,pll-clock",
-					of_keystone_pll_clk_init);
-
-/**
- * of_keystone_pll_main_clk_init - Main PLL initialisation DT wrapper
- * @node: device tree node for this clock
- */
-static void __init of_keystone_main_pll_clk_init(struct device_node *node)
-{
-	_of_pll_clk_init(node, true);
-}
-CLK_OF_DECLARE(keystone_main_pll_clock, "ti,keystone,main-pll-clock",
-						of_keystone_main_pll_clk_init);
-
-/**
- * of_pll_div_clk_init - PLL divider setup function
- * @node: device tree node for this clock
- */
-static void __init of_pll_div_clk_init(struct device_node *node)
-{
-	const char *parent_name;
-	void __iomem *reg;
-	u32 shift, mask;
-	struct clk *clk;
-	const char *clk_name = node->name;
-
-	of_property_read_string(node, "clock-output-names", &clk_name);
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("%s: ioremap failed\n", __func__);
-		return;
-	}
-
-	parent_name = of_clk_get_parent_name(node, 0);
-	if (!parent_name) {
-		pr_err("%s: missing parent clock\n", __func__);
-		return;
-	}
-
-	if (of_property_read_u32(node, "bit-shift", &shift)) {
-		pr_err("%s: missing 'shift' property\n", __func__);
-		return;
-	}
-
-	if (of_property_read_u32(node, "bit-mask", &mask)) {
-		pr_err("%s: missing 'bit-mask' property\n", __func__);
-		return;
-	}
-
-	clk = clk_register_divider(NULL, clk_name, parent_name, 0, reg, shift,
-				 mask, 0, NULL);
-	if (clk)
-		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-	else
-		pr_err("%s: error registering divider %s\n", __func__, clk_name);
-}
-CLK_OF_DECLARE(pll_divider_clock, "ti,keystone,pll-divider-clock", of_pll_div_clk_init);
-
-/**
- * of_pll_mux_clk_init - PLL mux setup function
- * @node: device tree node for this clock
- */
-static void __init of_pll_mux_clk_init(struct device_node *node)
-{
-	void __iomem *reg;
-	u32 shift, mask;
-	struct clk *clk;
-	const char *parents[2];
-	const char *clk_name = node->name;
-
-	of_property_read_string(node, "clock-output-names", &clk_name);
-	reg = of_iomap(node, 0);
-	if (!reg) {
-		pr_err("%s: ioremap failed\n", __func__);
-		return;
-	}
-
-	parents[0] = of_clk_get_parent_name(node, 0);
-	parents[1] = of_clk_get_parent_name(node, 1);
-	if (!parents[0] || !parents[1]) {
-		pr_err("%s: missing parent clocks\n", __func__);
-		return;
-	}
-
-	if (of_property_read_u32(node, "bit-shift", &shift)) {
-		pr_err("%s: missing 'shift' property\n", __func__);
-		return;
-	}
-
-	if (of_property_read_u32(node, "bit-mask", &mask)) {
-		pr_err("%s: missing 'bit-mask' property\n", __func__);
-		return;
-	}
-
-	clk = clk_register_mux(NULL, clk_name, (const char **)&parents,
-				ARRAY_SIZE(parents) , 0, reg, shift, mask,
-				0, NULL);
-	if (clk)
-		of_clk_add_provider(node, of_clk_src_simple_get, clk);
-	else
-		pr_err("%s: error registering mux %s\n", __func__, clk_name);
-}
-CLK_OF_DECLARE(pll_mux_clock, "ti,keystone,pll-mux-clock", of_pll_mux_clk_init);
diff --git a/include/linux/platform_data/clk-davinci-pll.h b/include/linux/platform_data/clk-davinci-pll.h
new file mode 100644
index 0000000..4c2920b
--- /dev/null
+++ b/include/linux/platform_data/clk-davinci-pll.h
@@ -0,0 +1,54 @@
+/*
+ * TI DaVinci clk-pll driver platform data definitions
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __CLK_DAVINCI_PLL_H
+#define __CLK_DAVINCI_PLL_H
+
+/* PLL flags */
+#define CLK_DAVINCI_PLL_HAS_PREDIV			BIT(0)
+#define CLK_DAVINCI_PLL_HAS_POSTDIV			BIT(1)
+
+struct clk_davinci_pll_data {
+	/* physical addresses set by platform code */
+	u32 phy_pllm;
+	/* if PLL has a prediv register this should be non zero */
+	u32 phy_prediv;
+	/* if PLL has a postdiv register this should be non zero */
+	u32 phy_postdiv;
+	/* mapped addresses. should be initialized by  */
+	void __iomem *pllm;
+	void __iomem *prediv;
+	void __iomem *postdiv;
+	u32 pllm_mask;
+	u32 prediv_mask;
+	u32 postdiv_mask;
+	u32 num;
+	/* framework flags */
+	u32 flags;
+	/* pll flags */
+	u32 pll_flags;
+       /* use this value for prediv */
+	u32 fixed_prediv;
+	/* multiply PLLM by this factor. By default most SOC set this to zero
+	 * that translates to a multiplier of 1 and incrementer of 1.
+	 * To override default, set this factor
+	 */
+	u32 pllm_multiplier;
+};
+
+extern struct clk *clk_register_davinci_pll(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_davinci_pll_data *pll_data);
+#endif /* CLK_DAVINCI_PLL_H */
diff --git a/include/linux/platform_data/clk-davinci-psc.h b/include/linux/platform_data/clk-davinci-psc.h
new file mode 100644
index 0000000..1b17993
--- /dev/null
+++ b/include/linux/platform_data/clk-davinci-psc.h
@@ -0,0 +1,58 @@
+/*
+ *  DaVinci Power & Sleep Controller (PSC) clk driver platform data
+ *
+ *  Copyright (C) 2006-2012 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __CLK_DAVINCI_PSC_H
+#define __CLK_DAVINCI_PSC_H
+
+/* PSC flags */
+/* Disable state is SwRstDisable */
+#define CLK_DAVINCI_PSC_SWRSTDISABLE	BIT(0)
+/* Force module state transtition */
+#define CLK_DAVINCI_PSC_FORCE		BIT(1)
+/* PSC has external power control available (for DM6446 SoC) */
+#define CLK_DAVINCI_PSC_HAS_EXT_POWER_CNTL	BIT(2)
+struct clk_davinci_psc_data {
+	/* base address of the PSC */
+	void __iomem *base;
+	/* framework flags */
+	u32	flags;
+	/* psc specific flags */
+	u32	psc_flags;
+	u8	lpsc;
+	u8	gpsc;
+	u8	domain;
+};
+
+extern struct clk *clk_register_davinci_psc(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_davinci_psc_data *psc_data,
+			spinlock_t *lock);
+
+#ifdef CONFIG_OF
+extern void __init of_davinci_psc_clk_init(struct device_node *node,
+			 spinlock_t *lock);
+#endif
+#endif /* __CLK_DAVINCI_PSC_H */
diff --git a/include/linux/platform_data/clk-keystone-pll.h b/include/linux/platform_data/clk-keystone-pll.h
new file mode 100644
index 0000000..4c05d33
--- /dev/null
+++ b/include/linux/platform_data/clk-keystone-pll.h
@@ -0,0 +1,56 @@
+/*
+ * TI Keyston clk-pll driver platform data definitions
+ *
+ * Copyright (C) 2012 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __CLK_KEYSTONE_PLL_H
+#define __CLK_KEYSTONE_PLL_H
+
+struct clk_keystone_pll_data {
+	/*
+	 * Has pllctrl. If set to non zero, lower 6 bits of multiplier is in
+	 * pllm register of pll controller, else it is in the pll_ctrl0
+	 * (bit 11-6)
+	 */
+	unsigned char has_pllctrl;
+	/*
+	 * physical address of PLLM in pll controller. Used when has_pllctrl is
+	 * non zero
+	 */
+	u32 phy_pllm;
+	/*
+	 * Physical address of PLL ctrl0. This could be that of Main PLL or Any
+	 * other PLLs in the device such as ARM PLL, DDR PLL or PA PLL available
+	 * on keystone2. These PLLs are controlled by this register. Main PLL is
+	 * controlled by a PLL controller.
+	 */
+	u32 phy_pll_ctl0;
+	/* mapped addresses of the above registers. */
+	void __iomem *pllm;
+	void __iomem *pll_ctl0;
+	u32 pllm_lower_mask;
+	u32 pllm_upper_mask;
+	u32 pllm_upper_shift;
+	u32 plld_mask;
+	u32 clkod_mask;
+	u32 clkod_shift;
+	u32 postdiv;
+};
+
+extern struct clk *clk_register_keystone_pll(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_keystone_pll_data *pll_data);
+
+#ifdef CONFIG_OF
+extern void __init of_keystone_pll_clk_init(struct device_node *node);
+#endif
+#endif /* CLK_KEYSTONE_PLL_H */
diff --git a/include/linux/platform_data/davinci-clock.h b/include/linux/platform_data/davinci-clock.h
new file mode 100644
index 0000000..e940853
--- /dev/null
+++ b/include/linux/platform_data/davinci-clock.h
@@ -0,0 +1,149 @@
+/*
+ * TI DaVinci Clock definitions -  Contains Macros and Types used for
+ * defining various clocks on a DaVinci SoC
+ *
+ * Copyright (C) 2012 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DAVINCI_CLOCK_H
+#define __DAVINCI_CLOCK_H
+
+#include <linux/types.h>
+
+struct clk;
+
+#define CLK(dev, con, ck)	\
+	{			\
+		.dev_id = dev,	\
+		.con_id = con,	\
+		._clk = ck,	\
+	}			\
+
+/* general flags: */
+#define ALWAYS_ENABLED		BIT(0)
+
+/* configuration data for clk mux */
+struct clk_mux_data {
+	u32			flags;
+	u8			mux_flags;
+	u8			shift;
+	u8			width;
+	u8			num_parents;
+	const char		**parents;
+	u32			phys_base;
+};
+
+/* configuration data for PLL divider clock */
+struct clk_divider_data {
+	u32			flags;
+	u8			divider_flags;
+	u32                     div_reg;
+	/* H/W supported max rate */
+	unsigned long		maxrate;
+	/* Width and shift for divider clock register mask */
+	u8			shift;
+	u8			width;
+};
+
+/* configuration data for fixed factor clocks. Some clocks in DaVinci are just
+ * duplicate clock pins that can be represented by this using a factor of 1
+ * for multiplier and divider
+ */
+struct clk_fixed_factor_data {
+	u32			flags;
+	u32			mult;
+	u32			div;
+};
+
+/* configuration data for fixed ref clock */
+struct clk_fixed_rate_data {
+	u32			flags;
+	unsigned long		rate;
+	/* where a register has input clock rate settings this function
+	 * is used to read that value from SoC specific code
+	 */
+	unsigned long		(*recalc)(unsigned long parent_rate);
+};
+
+/* forward declaration for other clock drivers */
+struct clk_davinci_pll_data;
+struct clk_keystone_pll_data;
+struct clk_psc_data;
+
+enum davinci_clk_type {
+	DAVINCI_MAIN_PLL_CLK,
+	KEYSTONE_MAIN_PLL_CLK,
+	DAVINCI_FIXED_RATE_CLK,
+	/* Use programmable divider */
+	DAVINCI_PRG_DIV_CLK,
+	/* Use fixed divider and multiplier */
+	DAVINCI_FIXED_FACTOR_CLK,
+	DAVINCI_PSC_CLK,
+	DAVINCI_MUX_CLK,
+};
+
+/* struct for defining DaVinci clocks for a SoC. Only one of the data ptr
+ * to be valid (non NULL). davinci_clk_init() in drivers/clk/davinci/clock.c
+ * check these ptr values to determine what clock register function to call
+ * to register a particular clock.
+ */
+struct davinci_clk {
+	const char			*name;
+	/* General flag for all drivers */
+	u32				flags;
+	struct davinci_clk		*parent;
+	enum davinci_clk_type		type;
+	/* one of these will be present in each SoC */
+	union {
+		/* root ref clock data */
+		struct clk_fixed_rate_data	*fixed_rate;
+		struct clk_davinci_pll_data	*davinci_pll;
+		struct clk_keystone_pll_data	*keystone_pll;
+		struct clk_divider_data		*pll_div;
+		struct clk_davinci_psc_data	*psc;
+		struct clk_mux_data		*mux;
+		struct clk_fixed_factor_data	*fixed_factor;
+		void				*data;
+	} clk_data;
+};
+
+/* struct for the DaVinci clock tables. */
+struct davinci_clk_lookup {
+	const char		*dev_id;
+	const char		*con_id;
+	struct davinci_clk      *_clk;
+	/* This saves the opaque clk ptr returned by clk_register() and is
+	 * saved to use later to register clkdevs for a specific clk node.
+	 */
+	struct clk		*clk;
+};
+
+/* struct for the DaVinci clkdev lookups. When several drivers uses the same
+ * clock, this structure is used to define a dev look up table that maps
+ * clkdevs to a clks node.
+ */
+struct davinci_dev_lookup {
+	const char		*con_id;
+	unsigned short		num_devs;
+	struct clk_lookup	*lookups;
+};
+
+/* clock init function for a DaVinci SoC (defined in drivers/clk/clock.c).
+ * This can also be used on other TI SoCs that has similar clock hardware.
+ */
+extern int davinci_common_clk_init(struct davinci_clk_lookup *clocks,
+				struct davinci_dev_lookup *dev_lookups,
+				u8 num_gpscs, u32 *psc_bases);
+#ifdef CONFIG_OF
+extern void davinci_add_clkdev(struct davinci_clk_lookup *clocks);
+extern void davinci_of_clk_init(void);
+#endif
+#endif
-- 
1.7.5.4

