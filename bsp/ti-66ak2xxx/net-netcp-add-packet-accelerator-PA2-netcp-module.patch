From cbd6e4685fefc889bf50314b4bebc482a0b40850 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Fri, 11 Mar 2016 02:39:14 +0000
Subject: [PATCH 051/347] net: netcp: add packet accelerator (PA2) netcp
 module

This patch comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

PA2 hardware available on K2E/L SoCs does function similar to
PA on K2HK, but re-designed and requires a separate hw module
driver. This patch adds a pa2 netcp module to support this.
This has its own message formats to communicate with the PA
PDSP firmware. However there are common netcp module functions
that are re-used from the pa core module. Also common functions
are re-used through the pa_core_ops struct. This driver is also
responsible for loading and running PDSPs with required firmware.

The patch also updates the documentation to reflect the PA2
module support. This is a port of the driver from older kernel
baseline that only supports tx checksum hw acceleration. rx checksum
acceleration support will be added in the future as needed.
To know more about the driver, please check the documentation
netcp-pa.txt, updated as part of this patch

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Jack Manbeck <j-manbeck2@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
(cherry picked from commit e6b590a8f39b41b5bc1d145d0fdfe74dccae6e3f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 Documentation/arm/keystone/netcp-pa.txt  |  172 ++++-
 drivers/net/ethernet/ti/Kconfig          |   11 +
 drivers/net/ethernet/ti/Makefile         |    2 +
 drivers/net/ethernet/ti/netcp_pa2.c      | 1398 ++++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_pa2_fw.h   | 1341 ++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_pa2_host.h |   40 +
 6 files changed, 2962 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/ti/netcp_pa2.c
 create mode 100644 drivers/net/ethernet/ti/netcp_pa2_fw.h
 create mode 100644 drivers/net/ethernet/ti/netcp_pa2_host.h

diff --git a/Documentation/arm/keystone/netcp-pa.txt b/Documentation/arm/keystone/netcp-pa.txt
index 1feb562..68c89cd 100644
--- a/Documentation/arm/keystone/netcp-pa.txt
+++ b/Documentation/arm/keystone/netcp-pa.txt
@@ -1,5 +1,5 @@
-                   Keystone NETCP Packet Accelarator Device Driver
-                   -----------------------------------------------
+                   Keystone NETCP Packet Accelarator (PA and PA2) Device Driver
+                   ------------------------------------------------------------
 
 This document describes the Keystone NetCP PA device driver. To Know more
 details on the hardware, please refers to the following hardware documents:-
@@ -7,6 +7,10 @@ details on the hardware, please refers to the following hardware documents:-
 Packet Accelerator (PA) for KeyStone Devices User's Guide
 http://www.ti.com/lit/ug/sprugs4a/sprugs4a.pdf
 
+KeyStone Architecture II Packet Accelerator 2 (PA2) for K2E and K2L Devices
+User's Guide
+http://www.ti.com/lit/ug/spruhz2/spruhz2.pdf
+
 Here is a description of the PA hardware as given in the above UG.
 
 The packet accelerator (PA) is one of the main components of the network
@@ -158,6 +162,135 @@ Egress
                           Keystone NETCP PA Device for K2E/L
 			(resource map and packet flow diagram)
 
+===============================================================================
+                   Keystone NETCP PA Device Driver for K2E/L SoC
+                      (Resource map and Packet flow diagram)
+                   ---------------------------------------------
+
+	           Packet flow                    ---------------------------
+                                                  |  Linux NetCP PA device  |
+                    Ingress (CPSW port x)         ---------------------------
+                       |                                    |    |  |    |  |
+                       V                                    |    |  |    |  |
+                     CPSW                                   |    |  |    |  |
+                       |                   commands         |    |  |    ----
+                       |            Packet parse to LUT1    |    ----      ^
+                       V                                    |      ^       |
+        --------cluster 0 ---------------                   |      |     Queue
+        | Ingress 0                     |    |---------     |      |      for
+        |-------------------------------|    | Chan 8       |      |    flow 31
+        | PDSP0 | LUT1_0 (MAC classify) | <--| Queue 904<---|      |   (Command
+        | PDSP1 | LUT1_1 (Outer IP ACL) |    ---------      |      |   Response)
+        |       |                       |                   |      |
+        ---------------------------------                   |      |
+               Match   |   | fail route to flow( 22 to 29)  |      |
+                       |   ---->                            |      |
+                       |               commands             |      |
+                       |      exception route to cluster 5  |      |
+                       |         Packet Parse to L3 Ingress |      |
+                       V         1, LUT1_0                  |   Per port Queues
+        --------cluster 1 ---------------                   |   Mapped to flows
+        | Ingress 1                      |                  |    22..30
+        |--------------------------------|                  |        (data)
+        | PDSP0 | LUT1_0 (Outer IP       |    ------------  |
+        |       |         classify,      |    | Chan 9      |
+        | PDSP1 |         Custom header) |<---| Queue 905<--|
+        |       | LUT1_1 (IPSEC NAT-T)   |    ------------  |
+        |       |        (IPSEC classify |                  |
+        |       |          first pass)   |                  |
+        ---------------------------------                   |
+               Match   |                                    |
+                       V                                    |
+        --------Cluster 2 --------------|                   |
+        | Ingress 2                     |                   |
+        |-------------------------------|                   |
+        | PDSP0 | LUT1_0 (IPSEC classify|                   |
+        |       |         second pass)  |                   |
+        ---------------------------------                   |
+                       |                                    |
+                       V                                    |
+        --------Cluster 3----------------                   |
+        | Ingress 3                     |                   |
+        |--------------------------------                   |
+        | PDSP0 |  LUT1_0(Inner IP      |                   |
+        |       |       firewall (ACL)  |                   |
+        |       |       Reassembly Prep)|                   |
+        |       |       L3/L4 Header    |                   |
+        |       |       Parse           |                   |
+        ---------------------------------                   |
+                       |                                    |
+                       V                                    |
+        --------Cluster 4----------------                   |
+        | Ingress 4                     |                   |
+        |--------------------------------                   |
+        | PDSP0 |  LUT1_0(Inner IP      |                   |
+        |       |    classify,L4        |                   |
+        |       |    checksum)          |                   |
+        | PDSP1 |  LUT2                 |                   |
+        |       |    (TCP/UDP)          |                   |
+        ---------------------------------                   |
+                       |                                    |
+                       V                                    |
+        --------Cluster 5----------------                   |
+        | Post Classification           |                   |
+        |--------------------------------                   |
+        | PDSP0 |   Packet patch        |                   |
+        |       |                       |                   |
+        |       |                       |                   |
+        | PDSP1 |   Packet patch        |                   |
+        |       |                       |                   |
+        ---------------------------------                   |
+                                                            |
+                                             ------------   |
+                                             | Chan 14      |
+                       |---------------------| Queue 910<---|
+                       V                     -----------
+        ---------Cluster 6--------------|
+        | Egress 0                      |
+        |-------------------------------|
+        | PDSP0 |  Flow Cache lookup    |
+        |       |  using L3/L4 header   |
+        | PDSP1 |  Inner L3/L4 header   |
+        |       |  Update (Checksum)    |
+        |       |  Tx command processing|
+        | PDSP2 |  Outer IP update      |
+        |       |  IPSec pre-process    |
+        |       |  Inner IP Fragment    |
+        |       |  Tx command processing|
+        ---------------------------------
+                        |
+                        |
+                        V
+        ---------Cluster 7--------------|
+        | Egress 1                      |
+        |-------------------------------|
+        | PDSP0 |  NAT-T header insert  |
+        |       |  second IPSEC         |
+        |       |  pre-processing       |
+        ---------------------------------
+                        |
+                        |
+                        V
+        ---------Cluster 8--------------|
+        | Egress 2                      |
+        |-------------------------------|
+        | PDSP0 |  L2 header insertion  |
+        |       |  /update and Outer IP |
+        |       |  fragmentation        |
+        ---------------------------------
+                        |
+                        V
+                       CPSW
+                        |
+                        V
+                      Egress (CPSW port x)
+
+
+HW Queues 904-912 are for PA cluster 0-8
+Tx chan 8-16 are associated with the above queues
+Rx flows 31 for command response
+Rx flows 22-25, 27-30 for rx data from each ethernet port
+
 driver files and functional description
 ==========================================
 drivers/net/ethernet/ti/netcp_pa_core.{c|h}
@@ -186,6 +319,12 @@ drivers/net/ethernet/ti/netcp_pa_fw.h
 	- PA firmware interface definitions. All command message structures
 	  are defined in this file. These are to be kept in sync with
 	  TI's PA Low Level Design (LLD).
+drivers/net/ethernet/ti/netcp_pa2_host.h
+	- PA2 specific message header format definitions/macros
+drivers/net/ethernet/ti/netcp_pa2_fw.h
+	- PA2 firmware interface definitions
+drivers/net/ethernet/ti/netcp_pa2.c
+	- PA2 driver module
 
 Firmware required by the drivers
 ================================
@@ -200,6 +339,22 @@ PA firmwares:-
 	ks2_pa_pdsp3_classify2.bin
 	ks2_pa_pdsp4_pam.bin
 	ks2_pa_pdsp5_pam.bin
+PA2 firmwares:-
+	ks2_pa_in0_pdsp0.bin
+	ks2_pa_in0_pdsp1.bin
+	ks2_pa_in1_pdsp0.bin
+	ks2_pa_in1_pdsp1.bin
+	ks2_pa_in2_pdsp0.bin
+	ks2_pa_in3_pdsp0.bin
+	ks2_pa_in4_pdsp0.bin
+	ks2_pa_in4_pdsp1.bin
+	ks2_pa_post_pdsp0.bin
+	ks2_pa_post_pdsp1.bin
+	ks2_pa_eg0_pdsp0.bin
+	ks2_pa_eg0_pdsp1.bin
+	ks2_pa_eg0_pdsp2.bin
+	ks2_pa_eg1_pdsp0.bin
+	ks2_pa_eg2_pdsp0.bin
 
 Format:
 	The firmware image file contains firmware blob with a header.
@@ -208,9 +363,22 @@ Format:
 	|   16 chars of version string	   |
 	+----------------------------------+
 	|    4 Constants(32 bits) for PA   |
+	|		OR		   |
+	|   32 Constants(32 bits) for PA2  |
 	+----------------------------------+
 	|	Firmware blob		   |
 	+----------------------------------+
 
 DT Specifications at
 <file:Documentation/devicetree/bindings/net/keystone-netcp.txt>
+
+Limitations
+==========
+
+Currently when PA driver is built as a dynamically loadable module,
+autoprobe doesn't work correctly. A Work around is to blacklist the
+PA modules in the filesystem and then load them manually using
+the following steps:-
+ - Bring down the interface (if interface is already up)
+ - insmod PA module .ko file
+ - Bring up the interface.
diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig
index 8d1112a4..c8e828c 100644
--- a/drivers/net/ethernet/ti/Kconfig
+++ b/drivers/net/ethernet/ti/Kconfig
@@ -123,6 +123,17 @@ config TI_KEYSTONE_NETCP_PA
           <file:Documentation/arm/keystone/netcp-pa.txt> to know more details
 	  about the driver.
 
+config TI_KEYSTONE_NETCP_PA2
+	depends on TI_KEYSTONE_NETCP && TI_KEYSTONE_NETCP_PA_CORE
+	tristate "TI Keystone NETCP Packet Accelerator (PA2) Support"
+	---help---
+
+	  This driver supports the NETCP PA2 hardware found on K2E/L SoCs.
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_netcp_pa2. Please read the file
+          <file:Documentation/arm/keystone/netcp-pa.txt> to know more details
+	  about the driver.
+
 config TLAN
 	tristate "TI ThunderLAN support"
 	depends on (PCI || EISA)
diff --git a/drivers/net/ethernet/ti/Makefile b/drivers/net/ethernet/ti/Makefile
index 6581935..06d2e45 100644
--- a/drivers/net/ethernet/ti/Makefile
+++ b/drivers/net/ethernet/ti/Makefile
@@ -22,3 +22,5 @@ keystone_netcp_ethss-y := netcp_ethss.o netcp_sgmii.o
 obj-$(CONFIG_TI_KEYSTONE_NETCP_PA_CORE) += netcp_pa_core.o
 obj-$(CONFIG_TI_KEYSTONE_NETCP_PA) += keystone_netcp_pa.o
 keystone_netcp_pa-y := netcp_pa.o
+obj-$(CONFIG_TI_KEYSTONE_NETCP_PA2) += keystone_netcp_pa2.o
+keystone_netcp_pa2-y := netcp_pa2.o
diff --git a/drivers/net/ethernet/ti/netcp_pa2.c b/drivers/net/ethernet/ti/netcp_pa2.c
new file mode 100644
index 0000000..fa504d0
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa2.c
@@ -0,0 +1,1398 @@
+/*
+ * Keystone NetCP PA2 (Packet Accelerator 2) Driver
+ * PA2 is a newer version of the hardware available on K2E/L SoCs,
+ *
+ * Copyright (C) 2012-2015 Texas Instruments Incorporated
+ * Author: Murali Karicheri <m-karicheri2@ti.com>
+ *
+ * Other contributors:	Sandeep Paulraj (Initial version of the driver)
+ *			Reece Pollack (Maintenance)
+ *			Sandeep Nair (Maintenance)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/delay.h>
+#include <linux/errqueue.h>
+#include <linux/firmware.h>
+#include <linux/if_vlan.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/net_tstamp.h>
+#include <linux/platform_device.h>
+#include <linux/byteorder/generic.h>
+#include <linux/soc/ti/knav_dma.h>
+#include <linux/soc/ti/knav_qmss.h>
+#include <linux/spinlock.h>
+
+#include "netcp.h"
+#include "netcp_pa_core.h"
+#include "netcp_pa2_host.h"
+#include "netcp_pa2_fw.h"
+
+enum {
+	PA2_CLUSTER_0 = 0,
+	PA2_CLUSTER_1,
+	PA2_CLUSTER_2,
+	PA2_CLUSTER_3,
+	PA2_CLUSTER_4,
+	PA2_CLUSTER_5,
+	PA2_CLUSTER_6,
+	PA2_CLUSTER_7,
+	PA2_CLUSTER_8,
+	PA2_NUM_CLUSTERS
+};
+
+enum pa2_pdsp {
+	PA2_PDSP0 = 0,
+	PA2_PDSP1,
+	PA2_PDSP2,
+	PA2_PDSP3,
+	PA2_PDSP4,
+	PA2_PDSP5,
+	PA2_PDSP6,
+	PA2_PDSP7,
+	PA2_PDSP8,
+	PA2_PDSP9,
+	PA2_PDSP10,
+	PA2_PDSP11,
+	PA2_PDSP12,
+	PA2_PDSP13,
+	PA2_PDSP14,
+	PA2_NUM_PDSPS
+};
+
+/* PA Packet Processing Unit registers */
+struct pa2_mailbox_regs {
+	u32 pdsp_mailbox_slot0;
+	u32 pdsp_mailbox_slot1;
+	u32 pdsp_mailbox_slot2;
+	u32 pdsp_mailbox_slot3;
+};
+
+struct pa2_ra_bridge_regs {
+	u32 rsvd0;
+	u32 config;
+};
+
+struct pa2_thread_mapper_regs {
+	u32 map[16];
+};
+
+struct pa2_ra_heap_region_regs {
+	u32 low;
+	u32 high;
+};
+
+struct pa2_ra_flow_override_regs {
+	u32 timeout;
+	u32 critical_err;
+	u32 non_critical_err;
+	u32 rsvd0;
+};
+
+struct pa2_ra_stats_regs {
+	u32 pkts_reasm;
+	u32 total_frags;
+	u32 total_pkts;
+	u32 context_timeout_w_sop;
+	u32 context_timeout_w_sop_bytes;
+	u32 context_timeout_wo_sop;
+	u32 context_timeout_wo_sop_bytes;
+	u32 rsvd0[2];
+	u32 overlap_ipv6_discard;
+	u32 overlap_ipv6_discard_bytes;
+	u32 large_pkts;
+	u32 ipv4_tcp_err;
+	u32 frag_len_err;
+	u32 illegal_ipv4_ihl;
+	u32 illegal_small_pkt;
+	u32 illegal_frag_len;
+	u32 already_completed_discard;
+	u32 already_completed_discard_bytes;
+	u32 rsvd1[5];
+};
+
+struct pa2_ra_regs {
+	u32 revision;
+	u32 config;
+	u32 total_contexts;
+	u32 discard_thresh;
+	u32 timeout_val;
+	u32 tick_val;
+	u32 vbusm_config;
+	u32 heap_region_thresh;
+	struct pa2_ra_heap_region_regs heap_region[2];
+	u32 rsvd0[4];
+	struct pa2_ra_flow_override_regs flow_override[2];
+	u32 rsvd1[12];
+	u32 context_forced_timeout;
+	u32 rsvd2[3];
+	struct pa2_ra_stats_regs stats[2];
+};
+
+struct pa2_stats_ctl_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 enable_alloc;
+	u32 counter_update;
+	u32 timer_ctl;
+	u32 timer_load;
+	u32 timer_val;
+	u32 pkt_routing_info;
+};
+
+struct pa2_query_stats_regs {
+	u32 stats[0x1000];
+};
+
+struct pa2_collect_stats_regs {
+	u32 stats[0x1000];
+};
+
+struct pa2_cl_splitter_regs {
+	u32 revision;
+	u32 rsvd0[3];
+	u32 sop_ctl;
+	u32 eop_ctl;
+	u32 rsvd1[2];
+	u32 mop_buf_size;
+	u32 mop_buf_ptr;
+};
+
+struct pa2_cluster {
+	/* PA Cluster splitter regs, offset 0x9800 + cluster base */
+	struct pa2_cl_splitter_regs __iomem *splitter;
+	/* PA SRAM, offset 0x80000 + PPU base */
+	void __iomem *sram;
+};
+
+struct pa2_ppu_ctl_status_regs {
+	u32 control;
+	u32 status;
+	u32 wakeup_enable;
+	u32 cycle_count;
+	u32 stall_count;
+	u32 rsvd[3];
+	u32 const_tbl_blk_index0;
+	u32 const_tbl_blk_index1;
+	u32 const_tbl_prog_pointer0;
+	u32 const_tbl_prog_pointer1;
+};
+
+struct pa2_ppu_debug_regs {
+	u32 igp[32];	/* Internal General Purpose Register */
+	u32 icte[32];	/* Internal Contants Table Entry Register */
+};
+
+struct pa2_ppu_cp_timer_regs {
+	u32 timer_control;
+	u32 timer_load;
+	u32 timer_value;
+	u32 timer_interrupt;
+};
+
+struct pa2_ppu_lut1_regs {
+	u32 revision;
+	u32 control;
+	u32 config;
+};
+
+struct pa2_ppu_lut2_regs {
+	u32 revision;
+	u32 clr_table;
+	u32 rsvd0[2];
+	u32 max_entry_count;
+	u32 curr_entry_count;
+	u32 rsvd1[2];
+	u32 add_data[4];
+	u32 add_del_key[2];
+	u32 add_del_control;
+};
+
+struct pa2_pcheck_recipe_regs {
+	u32 control;
+	u32 table[15];
+};
+
+struct pa2_ppu_pcheck_regs {
+	u32 revision;
+	u32 rsvd0[15];
+	struct pa2_pcheck_recipe_regs recipe[4];
+};
+
+/* PA PPU registers, offset: 0x8000 + (pdsp num) * 0x10000 + cluster offset */
+struct pa2_ppu {
+	/* PPU PDSP control/status regs, offset 0x0000 + PPU base */
+	struct pa2_ppu_ctl_status_regs __iomem	*ctl_status;
+	/* PPU PDSP debug regs, offset 0x0400 + PPU base */
+	struct pa2_ppu_debug_regs __iomem	*debug;
+	/* PPU CP Timer regs, offset 0x0800 + PPU base */
+	struct pa2_ppu_cp_timer_regs __iomem	*cp_timer;
+	/* PPU LUT1 regs, offset 0x1000 + PPU base */
+	struct pa2_ppu_lut1_regs __iomem	*lut1;
+	/* PPU LUT2 regs, offset 0x1400 + PPU base */
+	struct pa2_ppu_lut2_regs __iomem	*lut2;
+	/* PPU pcheck regs, offset 0x1c00 + PPU base */
+	struct pa2_ppu_pcheck_regs __iomem	*pcheck;
+	void __iomem				*iram;
+};
+
+struct pa2_device {
+	struct pa_core_device			core_dev;
+	struct pa2_mailbox_regs __iomem		*reg_mailbox;
+	struct pa2_ra_bridge_regs __iomem	*reg_ra_bridge;
+	struct pa2_thread_mapper_regs __iomem	*reg_thread_mapper;
+	struct pa2_ra_regs __iomem		*reg_ra;
+	struct pa2_stats_ctl_regs   __iomem	*reg_stats_ctl;
+	struct pa2_query_stats_regs   __iomem	*reg_stats_block;
+	struct pa2_cluster	cluster[PA2_NUM_CLUSTERS];
+	struct pa2_ppu		ppu[PA2_NUM_PDSPS];
+};
+
+#define PA2_MB_REG_INDEX			0
+#define PA2_RA_BRIDGE_INDEX			1
+#define PA2_TMAPPER_INDEX			2
+#define PA2_RA_INDEX				3
+#define PA2_STATS_CTL_INDEX			4
+#define PA2_STATS_BLOCK_INDEX			5
+#define PA2_CLUSTER_INDEX			6
+#define PA2_STATS_CTL_ENABLE_ALLOC_MASK		BIT(31)
+
+/* PA cluster registers */
+#define PA2_CLUSTER_REGS_SIZE			0x00100000
+#define PA2_CLUSTER_REGS(x)			(PA2_CLUSTER_REGS_SIZE * x)
+#define PA2_CLUSTER_SPLITTER_REGS_OFFSET	0x09800
+#define PA2_CLUSTER_SPLITTER_REGS(x)	(PA2_CLUSTER_SPLITTER_REGS_OFFSET \
+					 + PA2_CLUSTER_REGS(x))
+#define PA2_CLUSTER_SRAM_OFFSET			0x80000
+#define PA2_CLUSTER_SRAM_SIZE			0x10000
+#define PA2_CLUSTER_SRAM_REGS(x)	(PA2_CLUSTER_SRAM_OFFSET \
+						 + PA2_CLUSTER_REGS(x))
+#define PA2_CLUSTER_INGRESS0			PA2_CLUSTER_0
+#define PA2_CLUSTER_INGRESS1			PA2_CLUSTER_1
+#define PA2_CLUSTER_INGRESS2			PA2_CLUSTER_2
+#define PA2_CLUSTER_INGRESS3			PA2_CLUSTER_3
+#define PA2_CLUSTER_INGRESS4			PA2_CLUSTER_4
+#define PA2_CLUSTER_POST			PA2_CLUSTER_5
+#define PA2_CLUSTER_EGRESS0			PA2_CLUSTER_6
+#define PA2_CLUSTER_EGRESS1			PA2_CLUSTER_7
+#define PA2_CLUSTER_EGRESS2			PA2_CLUSTER_8
+
+#define PA2_COMID_L2				(0 << 14)
+
+/* PA Cluster Splitter
+ * to avoid hardware bug: SOP + EOP + 32 + Control size <= 128
+ * Restrict control size to 96, the SOP should be 896 - 128
+ */
+#define PA2_SPLITTER_SOP_CTL_ENABLE_MASK	0x80000000
+
+#define PA2_CLUSTER_SPLITTER_EOP_CTL		128
+#define PA2_CLUSTER_SPLITTER_EOP_BUF_SIZE(x)	((x == 0) ? 0x4000 : 0x10000)
+#define PA2_CLUSTER_SPLITTER_MOP_BUF_PTR	0xFFFC0000
+#define PA2_CLUSTER_SPLITTER_SOP_CTL \
+	(PA2_SPLITTER_SOP_CTL_ENABLE_MASK | (896 - 128))
+#define PA2_PPU_REGS_OFFSET			0x08000
+#define PA2_PPU_REGS_SIZE			0x10000
+#define PA2_PPU_REGS(x, y)		(PA2_CLUSTER_REGS(x) + \
+					 (PA2_PPU_REGS_OFFSET + \
+					 (PA2_PPU_REGS_SIZE * y)))
+#define PA2_PPU_CTL_STATUS_REGS_OFFSET		0x0000
+#define PA2_PPU_DEBUG_REGS_OFFSET		0x0400
+#define PA2_PPU_CP_TIMER_REGS_OFFSET		0x0800
+#define PA2_PPU_LUT1_REGS_OFFSET		0x1000
+#define PA2_PPU_LUT2_REGS_OFFSET		0x1400
+#define PA2_PPU_PCHECK_REGS_OFFSET		0x1c00
+#define PA2_PPU_IRAM_OFFSET			0x4000
+#define PA2_PPU_IRAM_SIZE			0x3000
+#define PA2_INGRESS4_PDSP1			PA2_PDSP7
+#define PA2_EGRESS0_PDSP2			PA2_PDSP12
+
+struct pa2_cluster_pdsp_map {
+	u32 cluster;
+	u32 pdsp;
+	u32 ver_base_addr;
+};
+
+#define PA2_PDSP_VERSION_SIZE			0x20
+#define PA2_PDSP_VERSION_OFFSET(x, y)	(x + (y * PA2_PDSP_VERSION_SIZE))
+
+/* PDSP/Cluster Mapping */
+static const struct pa2_cluster_pdsp_map pa2_cluster_pdsp_map[PA2_NUM_PDSPS] = {
+	{PA2_CLUSTER_INGRESS0, 0, 0x3f04},
+	{PA2_CLUSTER_INGRESS0, 1, 0x3f04},
+	{PA2_CLUSTER_INGRESS1, 0, 0x3f04},
+	{PA2_CLUSTER_INGRESS1, 1, 0x3f04},
+	{PA2_CLUSTER_INGRESS2, 0, 0x1f04},
+	{PA2_CLUSTER_INGRESS3, 0, 0x1f04},
+	{PA2_CLUSTER_INGRESS4, 0, 0x3f04},
+	{PA2_CLUSTER_INGRESS4, 1, 0x3f04},
+	{PA2_CLUSTER_POST, 0, 0x3f04},
+	{PA2_CLUSTER_POST, 1, 0x3f04},
+	{PA2_CLUSTER_EGRESS0, 0, 0x1f04},
+	{PA2_CLUSTER_EGRESS0, 1, 0x1f04},
+	{PA2_CLUSTER_EGRESS0, 2, 0x1f04},
+	{PA2_CLUSTER_EGRESS1, 0, 0x0f04},
+	{PA2_CLUSTER_EGRESS2, 0, 0x0f04}
+};
+
+#define PSTREAM_ROUTE_INGRESS0				2
+#define PA2_PDSP_ALREADY_ACTIVE				0
+#define PA2_PDSP_RESET_RELEASED				1
+#define PA2_PDSP_NO_RESTART				2
+#define PA2_MAX_PDSP_ENABLE_LOOP_COUNT			50000
+#define PA2_INVALID_PORT				0xff
+#define PA2_STATE_RESET			0  /* Sub-system state reset */
+#define PA2_STATE_ENABLE		1  /* Sub-system state enable  */
+#define PA2_STATE_QUERY			2  /* Query the Sub-system state */
+#define PA2_STATE_INCONSISTENT		3  /* Sub-system is partially enabled */
+#define PA2_STATE_INVALID_REQUEST	4  /* Invalid state command to the
+					    * Sub-system
+					    */
+#define PA2_STATE_ENABLE_FAILED		5  /* The Sub-system did not respond
+					    * after restart
+					    */
+
+/* pdsp LUT2 register */
+#define PA2_REG_VAL_PDSP_LUT2_CLR_TABLE_GO		BIT(0)
+
+/* pdsp control status register */
+#define PA2_REG_VAL_PDSP_CTL_DISABLE_PDSP		1
+#define PA2_REG_VAL_PDSP_CTL_RESET_PDSP			0
+#define PA2_REG_VAL_PDSP_CTL_STATE			BIT(15)
+#define PA2_REG_VAL_PDSP_CTL_ENABLE			BIT(1)
+#define PA2_REG_VAL_PDSP_CTL_SOFT_RESET			BIT(0)
+#define PA2_REG_VAL_PDSP_CTL_ENABLE_PDSP(pcval)		\
+					(((pcval) << 16) | \
+					PA2_REG_VAL_PDSP_CTL_ENABLE | \
+					PA2_REG_VAL_PDSP_CTL_SOFT_RESET)
+#define PA2_PDSP_CONST_NUM_REG				32
+#define PA2_PCHECK_CONTROL_RSHIFT_MASK			(0x00000002u)
+#define PA2_PCHECK_CONTROL_FINAL_NOT_MASK		(0x00000001u)
+
+static const u32 pa2_ppu_regs_offset[PA2_NUM_PDSPS] = {
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS0, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS0, 1),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS1, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS1, 1),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS2, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS3, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS4, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_INGRESS4, 1),
+	PA2_PPU_REGS(PA2_CLUSTER_POST, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_POST, 1),
+	PA2_PPU_REGS(PA2_CLUSTER_EGRESS0, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_EGRESS0, 1),
+	PA2_PPU_REGS(PA2_CLUSTER_EGRESS0, 2),
+	PA2_PPU_REGS(PA2_CLUSTER_EGRESS1, 0),
+	PA2_PPU_REGS(PA2_CLUSTER_EGRESS2, 0)
+};
+
+static struct pa_core_ops *core_ops = &netcp_pa_core_ops;
+
+/* PA2 firmware files */
+static const char *pa2_pdsp_firmwares[PA2_NUM_PDSPS][PA_MAX_FIRMWARES] = {
+	{ "ks2_pa_in0_pdsp0.bin", },	/*  0 */
+	{ "ks2_pa_in0_pdsp1.bin", },	/*  1 */
+	{ "ks2_pa_in1_pdsp0.bin", },	/*  2 */
+	{ "ks2_pa_in1_pdsp1.bin", },	/*  3 */
+	{ "ks2_pa_in2_pdsp0.bin", },	/*  4 */
+	{ "ks2_pa_in3_pdsp0.bin", },	/*  5 */
+	{ "ks2_pa_in4_pdsp0.bin", },	/*  6 */
+	{ "ks2_pa_in4_pdsp1.bin", },	/*  7 */
+	{ "ks2_pa_post_pdsp0.bin", },	/*  8 */
+	{ "ks2_pa_post_pdsp1.bin", },	/*  9 */
+	{ "ks2_pa_eg0_pdsp0.bin", },	/* 10 */
+	{ "ks2_pa_eg0_pdsp1.bin", },	/* 11 */
+	{ "ks2_pa_eg0_pdsp2.bin", },	/* 12 */
+	{ "ks2_pa_eg1_pdsp0.bin", },	/* 13 */
+	{ "ks2_pa_eg2_pdsp0.bin", },	/* 14 */
+};
+
+#define to_pa(data)	container_of(data, struct pa2_device, core_dev)
+
+static int pa2_set_firmware(struct pa_core_device *core_dev,
+			    int pdsp, const unsigned int *buffer, int len)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	struct pa2_ppu_debug_regs __iomem *debug_reg = pa_dev->ppu[pdsp].debug;
+	char *version;
+	int size_header = PA2_PDSP_CONST_NUM_REG + (PA_SIZE_VERSION >> 2);
+	u32 i;
+
+	if ((pdsp < 0) || (pdsp >= PA2_NUM_PDSPS))
+		return -EINVAL;
+
+	version = core_dev->version + (pdsp * PA_SIZE_VERSION);
+	/* extract version from the start of the buffer */
+	memcpy(version, buffer, PA_SIZE_VERSION);
+	*(version + PA_SIZE_VERSION - 1) = '\0';
+
+	if (len > PA2_PPU_IRAM_SIZE)
+		return -ENODEV;
+
+	/* offset of constants */
+	buffer += (PA_SIZE_VERSION >> 2);
+
+	for (i = 0; i < PA2_PDSP_CONST_NUM_REG; i++)
+		writel(buffer[i], &debug_reg->icte[i]);
+
+	buffer += PA2_PDSP_CONST_NUM_REG;
+
+	core_ops->load_firmware((u32 *)(pa_dev->ppu[pdsp].iram), buffer,
+				(len >> 2) - size_header);
+
+	return 0;
+}
+
+static int pa2_pdsp_run(struct pa2_device *pa_dev, int pdsp)
+{
+	struct pa2_ppu_ctl_status_regs __iomem *ctrl_reg =
+						pa_dev->ppu[pdsp].ctl_status;
+	struct pa2_mailbox_regs __iomem *mailbox_reg =
+						&pa_dev->reg_mailbox[pdsp];
+	u32 i, v;
+
+	/* Check for enabled PDSP */
+	v = readl(&ctrl_reg->control);
+	if ((v & PA2_REG_VAL_PDSP_CTL_ENABLE) ==
+	    PA2_REG_VAL_PDSP_CTL_ENABLE) {
+		/* Already enabled */
+		return PA2_PDSP_ALREADY_ACTIVE;
+	}
+
+	/* Clear the mailbox */
+	writel(0, &mailbox_reg->pdsp_mailbox_slot0);
+
+	/* Set PDSP PC to 0, enable the PDSP */
+	writel(PA2_REG_VAL_PDSP_CTL_ENABLE | PA2_REG_VAL_PDSP_CTL_SOFT_RESET,
+	       &ctrl_reg->control);
+
+	/* Wait for the mailbox to become non-zero */
+	for (i = 0; i < PA2_MAX_PDSP_ENABLE_LOOP_COUNT; i++) {
+		v = readl(&mailbox_reg->pdsp_mailbox_slot0);
+		if (v != 0)
+			return PA2_PDSP_RESET_RELEASED;
+	}
+
+	return PA2_PDSP_NO_RESTART;
+}
+
+static void pa2_reset(struct pa2_device *pa_dev)
+{
+	int i;
+
+	/* Put each of the PDSPs into reset (PC = 0) and reset timers */
+	for (i = 0; i < PA2_NUM_PDSPS; i++)  {
+		writel(0, &pa_dev->ppu[i].ctl_status->control);
+		writel(0, &pa_dev->ppu[i].cp_timer->timer_control);
+	}
+
+	/* Reset LUT2 */
+	writel(PA2_REG_VAL_PDSP_LUT2_CLR_TABLE_GO,
+	       &pa_dev->ppu[PA2_INGRESS4_PDSP1].lut2->clr_table);
+}
+
+static int pa2_enable(struct pa2_device *pa_dev)
+{
+	int i, res, ret  = PA2_STATE_ENABLE;
+
+	/* Do nothing if a pdsp is already out of reset.
+	 * If any PDSPs are out of reset
+	 * a global init is not performed
+	 */
+	for (i = 0; i < PA2_NUM_PDSPS; i++) {
+		res = pa2_pdsp_run(pa_dev, i);
+
+		if (res == PA2_PDSP_NO_RESTART)
+			ret = PA2_STATE_ENABLE_FAILED;
+	}
+
+	for (i = 0; i < PA2_NUM_PDSPS; i++) {
+		struct pa2_mailbox_regs __iomem *mbox_reg =
+				&pa_dev->reg_mailbox[i];
+		writel(0, &mbox_reg->pdsp_mailbox_slot0);
+	}
+
+	return ret;
+}
+
+static int pa2_post_init(struct pa_core_device *core_dev)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	struct device *dev = core_dev->dev;
+	u32 version, i;
+	char *str;
+	int ret = pa2_enable(pa_dev);
+
+	if (ret != PA2_STATE_ENABLE) {
+		dev_err(dev, "enable failed, ret = %d\n", ret);
+		return -ENODEV;
+	}
+
+	for (i = 0; i < PA2_NUM_PDSPS; i++) {
+		u32 cluster = pa2_cluster_pdsp_map[i].cluster;
+		void __iomem *sram = pa_dev->cluster[cluster].sram;
+		u32 base = pa2_cluster_pdsp_map[i].ver_base_addr;
+		u32 pdsp = pa2_cluster_pdsp_map[i].pdsp;
+
+		version = readl(sram +
+				PA2_PDSP_VERSION_OFFSET(base, pdsp));
+		str =  pa_dev->core_dev.version + (i * PA_SIZE_VERSION);
+		dev_info(dev, "Using PA fw version %s:0x%08x for pdsp %d\n",
+			 str, version, i);
+	}
+
+	return 0;
+}
+
+static void pa2_pre_init(struct pa_core_device *core_dev)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	int i;
+
+	/* System Statistics initialization */
+	writel(PA2_STATS_CTL_ENABLE_ALLOC_MASK,
+	       &pa_dev->reg_stats_ctl->enable_alloc);
+	writel(1, &pa_dev->reg_stats_ctl->soft_reset);
+
+	/* Initialize all clusters */
+	for (i = 0; i < PA2_NUM_CLUSTERS; i++) {
+		writel(PA2_CLUSTER_SPLITTER_EOP_CTL,
+		       &pa_dev->cluster[i].splitter->eop_ctl);
+		writel(PA2_CLUSTER_SPLITTER_EOP_BUF_SIZE(i),
+		       &pa_dev->cluster[i].splitter->mop_buf_size);
+		writel(PA2_CLUSTER_SPLITTER_MOP_BUF_PTR,
+		       &pa_dev->cluster[i].splitter->mop_buf_ptr);
+		writel(PA2_CLUSTER_SPLITTER_SOP_CTL,
+		       &pa_dev->cluster[i].splitter->sop_ctl);
+	}
+	pa2_reset(pa_dev);
+}
+
+static inline void swizfwd(struct pa2_frm_forward *fwd)
+{
+	fwd->queue = cpu_to_be16(fwd->queue);
+	if (fwd->forward_type == PA2FRM_FORWARD_TYPE_HOST)
+		fwd->u.host.context = cpu_to_be32(fwd->u.host.context);
+}
+
+static inline int swizal1(struct pa2_frm_cmd_add_lut1 *al1)
+{
+	al1->index		=  cpu_to_be16(al1->index);
+	al1->vlink_num		=  cpu_to_be16(al1->vlink_num);
+	al1->stats_index	=  cpu_to_be16(al1->stats_index);
+
+	if (al1->type == PA2FRM_COM_ADD_LUT1_STANDARD) {
+		al1->u.mac.etype	= cpu_to_be16(al1->u.mac.etype);
+		al1->u.mac.session_id	= cpu_to_be16(al1->u.mac.session_id);
+		al1->u.mac.mpls		= cpu_to_be32(al1->u.mac.mpls);
+		al1->u.mac.vlan_id1	= cpu_to_be16(al1->u.mac.vlan_id1);
+		al1->u.mac.vlan_id2	= cpu_to_be16(al1->u.mac.vlan_id2);
+		al1->u.mac.vlan_pri1	= cpu_to_be16(al1->u.mac.vlan_pri1);
+		al1->u.mac.vlan_pri2	= cpu_to_be16(al1->u.mac.vlan_pri2);
+		al1->u.mac.src_vc	= cpu_to_be16(al1->u.mac.src_vc);
+	} else if (al1->type == PA2FRM_COM_ADD_LUT1_CUSTOM) {
+		al1->u.custom.src_vc	=  cpu_to_be16(al1->u.custom.src_vc);
+	} else {
+		return -EINVAL;
+	}
+
+	al1->range1_hi	=  cpu_to_be16(al1->range1_hi);
+	al1->range0_hi	=  cpu_to_be16(al1->range0_hi);
+	al1->cbwords0	=  cpu_to_be32(al1->cbwords0);
+	al1->cbwords1	=  cpu_to_be32(al1->cbwords1);
+	al1->bit_mask	=  cpu_to_be16(al1->bit_mask);
+	al1->priority	=  cpu_to_be16(al1->priority);
+
+	swizfwd(&al1->match);
+	swizfwd(&al1->next_fail);
+
+	return 0;
+}
+
+static inline void swizfcmd(struct pa2_frm_command *fcmd)
+{
+	fcmd->command_result	=  cpu_to_be16(fcmd->command_result);
+	fcmd->com_id		=  cpu_to_be16(fcmd->com_id);
+	fcmd->ret_context	=  cpu_to_be32(fcmd->ret_context);
+	fcmd->reply_queue	=  cpu_to_be16(fcmd->reply_queue);
+}
+
+#define	PA2_CONTEXT_MASK	0xffff0000
+#define	PA2_CONTEXT_CONFIG	0xdead0000
+
+static void pa2_rx_packet_handler(void *param)
+{
+	struct pa_packet *p_info = param;
+	struct pa_core_device *core_dev = p_info->core_dev;
+	struct pa2_frm_command *fcmd;
+
+	switch (p_info->epib[1] & PA2_CONTEXT_MASK) {
+	case PA2_CONTEXT_CONFIG:
+		fcmd = p_info->data;
+		swizfcmd(fcmd);
+
+		if (fcmd->command_result != PA2FRM_COMMAND_RESULT_SUCCESS) {
+			dev_dbg(core_dev->dev, "Command Result = 0x%x\n",
+				fcmd->command_result);
+			dev_dbg(core_dev->dev, "Command = 0x%x\n",
+				fcmd->command);
+			dev_dbg(core_dev->dev, "Magic = 0x%x\n", fcmd->magic);
+			dev_dbg(core_dev->dev, "Com ID = 0x%x\n", fcmd->com_id);
+			dev_dbg(core_dev->dev, "ret Context = 0x%x\n",
+				fcmd->ret_context);
+			dev_dbg(core_dev->dev, "Flow ID = 0x%x\n",
+				fcmd->flow_id);
+			dev_dbg(core_dev->dev, "reply Queue = 0x%x\n",
+				fcmd->reply_queue);
+			dev_dbg(core_dev->dev, "reply dest = 0x%x\n",
+				fcmd->reply_dest);
+		}
+		dev_dbg(core_dev->dev, "command response complete\n");
+		break;
+
+	default:
+		dev_warn(core_dev->dev, "bad response context, got 0x%08x\n",
+			 p_info->epib[1]);
+		break;
+	}
+}
+
+static struct
+pa2_frm_command *pa2_format_fcmd_hdr(void *p_cmd,
+				     struct pa_core_device *priv,
+				     u8 cmd, u16 com_id,
+				     u8 first_pdsp, u16 cmd_size)
+{
+	struct pa2_frm_command *fcmd;
+
+	memset(p_cmd, 0, cmd_size);
+	fcmd			= (struct pa2_frm_command *)p_cmd;
+	fcmd->status		= PA2FRM_CFG_CMD_STATUS_PROC;
+	fcmd->pdsp_index	= first_pdsp;
+	fcmd->command		= cmd;
+	fcmd->magic		= PA2FRM_CONFIG_COMMAND_SEC_BYTE;
+	fcmd->com_id		= com_id;
+	fcmd->ret_context	= PA2_CONTEXT_CONFIG;
+	fcmd->flow_id		= priv->cmd_flow_num;
+	fcmd->reply_queue	= priv->cmd_queue_num;
+	fcmd->reply_dest	= PA2FRM_DEST_PKTDMA;
+
+	return fcmd;
+}
+
+static int pa2_conv_fc_routing_info(struct pa2_frm_forward *fwd_info,
+				    struct pa2_ef_op_info *ef_info)
+{
+	if (!ef_info)
+		return PA2_ERR_CONFIG;
+
+	fwd_info->forward_type = PA2FRM_FORWARD_TYPE_EFLOW;
+
+	if (ef_info->ctrl_flags & PA2_EF_OP_CONTROL_FLAG_FC_LOOKUP)
+		/* Trigger Flow cache operation */
+		fwd_info->u.ef.ctrl_flags = PA2FRM_EF_CTRL_FC_LOOKUP;
+	else {
+		/* Use Egress Flow records directly */
+		fwd_info->u.ef.valid_bitmap  = (u8)ef_info->valid_bitmap;
+		fwd_info->u.ef.lvl1_rec_idx = (u8)ef_info->lvl1_index;
+		fwd_info->u.ef.lvl2_rec_idx = (u8)ef_info->lvl2_index;
+		fwd_info->u.ef.lvl3_rec_idx = (u8)ef_info->lvl3_index;
+		fwd_info->u.ef.lvl4_rec_idx = (u8)ef_info->lvl4_index;
+	}
+
+	return 0;
+}
+
+static int pa2_conv_routing_info(struct pa2_frm_forward *fwd_info,
+				 struct pa2_route_info2 *route_info,
+				 int cmd_dest, u16 fail_route,
+				 u16 dest_pdsp, u8 pa_flags)
+{
+	u8 *pcmd = fwd_info->u.host.cmd;
+	u8 ps_flags = 0;
+	u32 no_fcmd = 0;
+
+	fwd_info->flow_id = route_info->flow_id;
+	fwd_info->queue   = route_info->queue;
+
+	if ((route_info->dest == PA2_DEST_HOST) ||
+	    (route_info->dest == PA2_DEST_EMAC)) {
+		if (route_info->valid_bitmap &
+		    PA2_ROUTE_INFO_VALID_PKTTYPE_EMAC) {
+			ps_flags = (route_info->pkt_type_emac_ctrl &
+				    PA2_EMAC_CTRL_CRC_DISABLE) ?
+				    PA2FRM_ETH_PS_FLAGS_DISABLE_CRC : 0;
+			ps_flags |= ((route_info->pkt_type_emac_ctrl &
+				      PA2_EMAC_CTRL_PORT_MASK) <<
+				     PA2FRM_ETH_PS_FLAGS_PORT_SHIFT);
+		}
+	}
+
+	if (route_info->dest == PA2_DEST_HOST) {
+		fwd_info->forward_type   = PA2FRM_FORWARD_TYPE_HOST;
+		fwd_info->u.host.context = route_info->sw_info_0;
+		fwd_info->u.host.ps_flags = ps_flags;
+
+		if (route_info->valid_bitmap &
+		    PA2_ROUTE_INFO_VALID_PRIORITY_TYPE) {
+			if (route_info->priority_type ==
+				PA2_ROUTE_PRIORITY_VLAN)
+				fwd_info->u.host.ctrl_bitmap |=
+					PA2FRM_ROUTING_PRIORITY_VLAN_ENABLE;
+			else if (route_info->priority_type ==
+				PA2_ROUTE_PRIORITY_DSCP)
+				fwd_info->u.host.ctrl_bitmap |=
+					PA2FRM_ROUTING_PRIORITY_DSCP_ENABLE;
+			else if (route_info->priority_type == PA2_ROUTE_INTF)
+				fwd_info->u.host.ctrl_bitmap |=
+					PA2FRM_ROUTING_IF_DEST_SELECT_ENABLE;
+			else if (route_info->priority_type ==
+				 PA2_ROUTE_INTF_W_FLOW)
+				fwd_info->u.host.ctrl_bitmap |=
+					(PA2FRM_ROUTING_IF_DEST_SELECT_ENABLE |
+					 PA2FRM_ROUTING_FLOW_IF_BASE_ENABLE);
+			else
+				return PA2_ERR_CONFIG;
+		}
+
+		if (route_info->valid_bitmap &
+		    PA2_ROUTE_INFO_VALID_MROUTEINDEX) {
+			if (route_info->m_route_index >= 0) {
+				if (route_info->m_route_index >=
+					PA2_MAX_MULTI_ROUTE_SETS)
+					return PA2_ERR_CONFIG;
+				fwd_info->u.host.ctrl_bitmap |=
+					PA2FRM_MULTIROUTE_ENABLE;
+				fwd_info->u.host.multi_idx =
+					route_info->m_route_index;
+				fwd_info->u.host.pa_pdsp_router	=
+					PA2FRM_DEST_PA_M_0;
+			}
+		}
+	} else if (route_info->dest == PA2_DEST_DISCARD)	{
+		fwd_info->forward_type = PA2FRM_FORWARD_TYPE_DISCARD;
+	} else if (route_info->dest == PA2_DEST_EMAC) {
+		fwd_info->forward_type = PA2FRM_FORWARD_TYPE_ETH;
+		fwd_info->u.eth.ps_flags = ps_flags;
+	} else if (fail_route) {
+		return PA2_ERR_CONFIG;
+
+	} else if (((route_info->dest == PA2_DEST_CONTINUE_PARSE_LUT1) &&
+		    (route_info->custom_type != PA2_CUSTOM_TYPE_LUT2)) ||
+		   ((route_info->dest == PA2_DEST_CONTINUE_PARSE_LUT2) &&
+		    (route_info->custom_type != PA2_CUSTOM_TYPE_LUT1))) {
+		/* Custom Error check */
+		if (((route_info->custom_type == PA2_CUSTOM_TYPE_LUT1) &&
+		     (route_info->custom_index >= PA2_MAX_CUSTOM_TYPES_LUT1)) ||
+		    ((route_info->custom_type == PA2_CUSTOM_TYPE_LUT2) &&
+		     (route_info->custom_index >= PA2_MAX_CUSTOM_TYPES_LUT2)))
+			return PA2_ERR_CONFIG;
+
+		fwd_info->forward_type = PA2FRM_FORWARD_TYPE_PA;
+		fwd_info->u.pa.custom_type = (u8)route_info->custom_type;
+		fwd_info->u.pa.custom_idx  = route_info->custom_index;
+		fwd_info->u.pa.flags  = pa_flags;
+
+		if (route_info->dest == PA2_DEST_CONTINUE_PARSE_LUT2) {
+			fwd_info->u.pa.pa_dest = PA2FRM_DEST_INGRESS4;
+		} else {
+			/* cmd_dest is provided by calling function
+			 * There is no need to check error case
+			 */
+			if (cmd_dest == PA2_CMD_TX_DEST_0) {
+				/* Layer 2 entry */
+				fwd_info->u.pa.pa_dest = PA2FRM_DEST_INGRESS1;
+			} else if (cmd_dest == PA2_CMD_TX_DEST_1) {
+				fwd_info->u.pa.pa_dest = (dest_pdsp == 0) ?
+				  PA2FRM_DEST_INGRESS1 : PA2FRM_DEST_INGRESS3;
+				if (route_info->custom_type ==
+						PA2_CUSTOM_TYPE_LUT1)
+					fwd_info->u.pa.pa_dest =
+						PA2FRM_DEST_INGRESS3;
+			} else if (cmd_dest == PA2_CMD_TX_DEST_3) {
+				fwd_info->u.pa.pa_dest = PA2FRM_DEST_INGRESS4;
+			} else {
+				return PA2_ERR_CONFIG;
+			}
+		}
+		no_fcmd = 1;
+	} else if (route_info->dest == PA2_DEST_CASCADED_FORWARDING_LUT1) {
+		fwd_info->forward_type = PA2FRM_FORWARD_TYPE_PA;
+		fwd_info->u.pa.pa_dest = (cmd_dest == PA2_CMD_TX_DEST_0) ?
+				PA2FRM_DEST_INGRESS1 : PA2FRM_DEST_INGRESS4;
+		fwd_info->u.pa.flags   |= PA2FRM_CASCADED_FORWARDING;
+		no_fcmd = 1;
+	} else if (route_info->dest == PA2_DEST_EFLOW) {
+		return pa2_conv_fc_routing_info(fwd_info,
+						route_info->ef_op);
+	} else {
+		return PA2_ERR_CONFIG;
+	}
+
+	if (pcmd && (route_info->valid_bitmap & PA2_ROUTE_INFO_VALID_PCMD)) {
+		struct pa2_cmd_info *pacmd = route_info->pcmd;
+		struct pa2_patch_info *patch_info;
+		struct pa2_cmd_set *cmd_set;
+		struct pa2_cmd_usr_stats *usr_stats;
+		struct pa2_cmd_set_usr_stats *cmd_set_usr_stats;
+
+		switch (pacmd->cmd) {
+		case PA2_CMD_PATCH_DATA:
+			patch_info = &pacmd->params.patch;
+			if ((patch_info->n_patch_bytes > 2) ||
+			    (!(patch_info->ctrl_bit_field &
+			    PA2_PATCH_OP_INSERT)) ||
+				(!patch_info->patch_data))
+				return PA2_ERR_CONFIG;
+
+			pcmd[0] = PA2FRM_RX_CMD_PATCH_DATA;
+			pcmd[1] = patch_info->n_patch_bytes;
+			pcmd[2] = patch_info->patch_data[0];
+			pcmd[3] = patch_info->patch_data[1];
+			break;
+
+		case PA2_CMD_CMDSET:
+			cmd_set = &pacmd->params.cmd_set;
+			if (no_fcmd || (cmd_set->index >= PA2_MAX_CMD_SETS))
+				return PA2_ERR_CONFIG;
+
+			pcmd[0] = PA2FRM_RX_CMD_CMDSET;
+			pcmd[1] = (u8)cmd_set->index;
+			break;
+
+		case PA2_CMD_USR_STATS:
+			usr_stats = &pacmd->params.usr_stats;
+			if (usr_stats->index >= 512)
+				return PA2_ERR_CONFIG;
+
+			pcmd[0] = PA2FRM_RX_CMD_USR_STATS;
+			pcmd[1] = 4;
+			pcmd[2] = usr_stats->index >> 8;
+			pcmd[3] = usr_stats->index & 0xFF;
+			break;
+
+		case PA2_CMD_CMDSET_AND_USR_STATS:
+			cmd_set_usr_stats = &pacmd->params.cmd_set_usr_stats;
+			if ((no_fcmd) ||
+			    (cmd_set_usr_stats->set_index >=
+			    PA2_MAX_CMD_SETS) ||
+			    (cmd_set_usr_stats->stats_index >= 512))
+				return PA2_ERR_CONFIG;
+
+			pcmd[0] = PA2FRM_RX_CMD_CMDSET_USR_STATS;
+			pcmd[1] = (u8)cmd_set_usr_stats->set_index;
+			pcmd[2] = cmd_set_usr_stats->stats_index >> 8;
+			pcmd[3] = cmd_set_usr_stats->stats_index & 0xFF;
+			break;
+
+		default:
+			return PA2_ERR_CONFIG;
+		}
+	}
+	return PA2_OK;
+}
+
+static int pa2_add_mac_rule(struct pa_intf *pa_intf, int index,
+			    const u8 *smac, const u8 *dmac, int rule,
+			    unsigned etype, int port)
+{
+	struct pa_core_device *core_dev = pa_intf->core_dev;
+	struct pa2_route_info2 route_info, fail_info;
+	struct pa2_frm_command *fcmd;
+	struct pa2_frm_cmd_add_lut1 *al1;
+	u16 priority, bit_mask = 0;
+	struct pa_packet *tx;
+	u32 cbwords0, cbwords1;
+	int size, ret;
+
+	dev_dbg(core_dev->dev,
+		"add mac, index %d, smac %pM, dmac %pM, rule %d,",
+		index, smac, dmac, rule);
+	dev_dbg(core_dev->dev,
+		"type %04x, port %d\n", etype, port);
+
+	memset(&fail_info, 0, sizeof(fail_info));
+	memset(&route_info, 0, sizeof(route_info));
+
+	if (rule == PACKET_HST) {
+		route_info.dest			= PA2_DEST_HOST;
+		route_info.flow_id		= pa_intf->data_flow_num;
+		route_info.queue		= pa_intf->data_queue_num;
+		route_info.m_route_index	= PA2_NO_MULTI_ROUTE;
+		fail_info.dest			= PA2_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= PA2_NO_MULTI_ROUTE;
+	} else if (rule == PACKET_PARSE) {
+		route_info.dest			= PA2_DEST_CONTINUE_PARSE_LUT1;
+		route_info.m_route_index	= PA2_NO_MULTI_ROUTE;
+		fail_info.dest			= PA2_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= PA2_NO_MULTI_ROUTE;
+	} else if (rule == PACKET_DROP) {
+		route_info.dest			= PA2_DEST_DISCARD;
+		route_info.m_route_index	= PA2_NO_MULTI_ROUTE;
+		fail_info.dest			= PA2_DEST_DISCARD;
+		fail_info.m_route_index		= PA2_NO_MULTI_ROUTE;
+	}
+
+	if (route_info.m_route_index != PA2_NO_MULTI_ROUTE)
+		route_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_MROUTEINDEX;
+	if (route_info.pkt_type_emac_ctrl)
+		route_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_PKTTYPE_EMAC;
+	if (route_info.pcmd)
+		route_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_PCMD;
+	if (fail_info.m_route_index != PA2_NO_MULTI_ROUTE)
+		fail_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_MROUTEINDEX;
+	if (fail_info.pkt_type_emac_ctrl)
+		fail_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_PKTTYPE_EMAC;
+	if (fail_info.pcmd)
+		fail_info.valid_bitmap |= PA2_ROUTE_INFO_VALID_PCMD;
+
+	size = (sizeof(struct pa2_frm_command) +
+		sizeof(struct pa2_frm_cmd_add_lut1) - sizeof(u32));
+	tx = core_ops->alloc_packet(core_dev, size, PA2_CLUSTER_0);
+	if (!tx) {
+		dev_err(core_dev->dev, "could not allocate cmd tx packet\n");
+		return -ENOMEM;
+	}
+
+	fcmd = pa2_format_fcmd_hdr((void *)tx->data,
+				   core_dev,
+				   PA2FRM_CONFIG_COMMAND_ADDREP_LUT1,
+				   PA2_COMID_L2,
+				   0,
+				   size);
+
+	al1		= (struct pa2_frm_cmd_add_lut1 *)&fcmd->cmd;
+	al1->index	= index;
+	al1->type	= PA2FRM_COM_ADD_LUT1_STANDARD;
+
+	cbwords0	= PA2FRM_LUT1_CLASS_STANDARD << PA2FRM_LUT1_CLASS_SHIFT;
+	cbwords1	= PA2FRM_LUT1_VALID_PKTTYPE;
+	priority	= 0;
+
+	al1->u.mac.pkt_type = PA2FRM_L2_PKT_TYPE_MAC;
+
+	if (etype) {
+		al1->u.mac.etype = etype;
+		cbwords0 |=  PA2FRM_LUT1_VALID_ETHERTYPE;
+		priority += 10;
+	}
+
+	al1->u.mac.vlan_id1 = 0;
+	al1->u.mac.mpls	= 0;
+	if (port) {
+		al1->u.mac.in_port = port;
+		cbwords1 |=  PA2FRM_LUT1_VALID_INPORT;
+		priority += 10;
+	}
+
+	if (dmac) {
+		memcpy(al1->u.mac.dmac, dmac, 6);
+		cbwords0 |= PA2FRM_LUT1_VALID_DMAC_ALL;
+		priority += 10;
+	}
+	if (smac) {
+		memcpy(al1->u.mac.smac, smac, 6);
+		cbwords0 |= PA2FRM_LUT1_VALID_SMAC;
+		priority += 10;
+	}
+
+	al1->cbwords0 = cbwords0;
+	al1->cbwords1 = cbwords1;
+	al1->priority = priority;
+	al1->bit_mask = bit_mask;
+
+	ret = pa2_conv_routing_info(&al1->match, &route_info, 0, 0, 0, 0);
+	if (ret != 0)
+		dev_err(core_dev->dev, "route info config failed\n");
+
+	ret = pa2_conv_routing_info(&al1->next_fail, &fail_info, 0, 1, 0, 0);
+	if (ret != 0)
+		dev_err(core_dev->dev, "fail info config failed\n");
+
+	swizfcmd(fcmd);
+	ret = swizal1((struct pa2_frm_cmd_add_lut1 *)&fcmd->cmd);
+	if (ret < 0)
+		return ret;
+
+	tx->psdata[0] = PAHO2_PACFG_CMD;
+
+	tx->epib[1] = 0;
+	tx->epib[2] = 0;
+	tx->epib[3] = 0;
+
+	dev_dbg(core_dev->dev, "waiting for command transmit complete\n");
+
+	return core_ops->submit_packet(tx, PA2_CLUSTER_0);
+}
+
+static int pa2_fmtcmd_next_route(struct netcp_packet *p_info, int eth_port)
+{
+	u8 ps_flags = (eth_port & PA2_EMAC_CTRL_PORT_MASK) <<
+				PA2FRM_ETH_PS_FLAGS_PORT_SHIFT;
+	struct paho_next_route *nr;
+
+	nr = (struct paho_next_route *)netcp_push_psdata(p_info, sizeof(*nr));
+	if (!nr)
+		return -ENOMEM;
+
+	/* Construct word0 */
+	nr->word0 = 0;
+	PAHO_SET_CMDID(nr, PAHO_PAMOD_NROUTE);
+	PAHO_SET_E(nr, 1);
+	PAHO_SET_DEST(nr, PA2FRM_DEST_ETH);
+	PAHO_SET_FLOW(nr, 0);
+	PAHO_SET_QUEUE(nr, 0);
+
+	/* Construct sw_info0 and sw_info1 */
+	nr->sw_info0 = 0;
+	nr->sw_info1 = 0;
+
+	/* Construct word1 */
+	nr->word1 = 0;
+	PAHO_SET_PKTTYPE(nr, ps_flags);
+
+	return sizeof(*nr);
+}
+
+static int pa2_fmtcmd_tx_csum(struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct paho_com_chk_crc *ptx;
+	int start, len;
+	int size;
+
+	size = sizeof(*ptx);
+	ptx = (struct paho_com_chk_crc *)netcp_push_psdata(p_info, size);
+
+	start = skb_checksum_start_offset(skb);
+	len = skb->len - start;
+
+	ptx->word0 = 0;
+	ptx->word1 = 0;
+	ptx->word2 = 0;
+	PAHO_SET_CMDID(ptx, PAHO_PAMOD_CMPT_CHKSUM);
+	PAHO_CHKCRC_SET_START(ptx, start);
+	PAHO_CHKCRC_SET_LEN(ptx, len);
+	PAHO_CHKCRC_SET_RESULT_OFF(ptx, skb->csum_offset);
+	PAHO_CHKCRC_SET_INITVAL(ptx, 0);
+	PAHO_CHKCRC_SET_NEG0(ptx, 0);
+
+	return size;
+}
+
+static inline int pa2_fmtcmd_align(struct netcp_packet *p_info,
+				   const unsigned bytes)
+{
+	struct paho_cmd_info	*pa_cmd_info;
+	int i;
+
+	if ((bytes & 0x03) != 0)
+		return -EINVAL;
+
+	pa_cmd_info =
+		(struct paho_cmd_info *)netcp_push_psdata(p_info, bytes);
+
+	for (i = bytes / sizeof(u32); i > 0; --i) {
+		pa_cmd_info->word0 = 0;
+		PAHO_SET_CMDID(pa_cmd_info, PAHO_PAMOD_DUMMY);
+		++pa_cmd_info;
+	}
+
+	return bytes;
+}
+
+static u32 pa2_get_streaming_switch(struct pa_core_device *core_dev, int port)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	void __iomem *thread_map = pa_dev->reg_thread_mapper;
+	u32 reg, offset = 0;
+
+	/* each port has 8 priorities, which needs 8 bytes setting */
+	if (port > 0)
+		offset = (port - 1) * 8;
+
+	reg = readl(thread_map + offset) & 0xff;
+	return reg;
+}
+
+static u32 pa2_set_streaming_switch(struct pa_core_device *core_dev,
+				    int port, u32 new_value)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	void __iomem *thread_map = pa_dev->reg_thread_mapper;
+	u32 reg, offset, old_value;
+	int i;
+
+	reg = (new_value << 24) | (new_value << 16) |
+		(new_value << 8) | (new_value);
+
+	if (port == 0) {
+		/* return 1st port priority 0 setting for all the ports */
+		old_value = readl(thread_map);
+		old_value &= 0xff;
+		for (i = 0; i < 16; i++, thread_map += 4)
+			writel(reg, thread_map);
+	} else {
+		/* each port has 8 priorities, which needs 8 bytes setting */
+		offset = (port - 1) * 8;
+
+		/* return priority 0 setting for the port */
+		old_value = readl(thread_map + offset);
+		old_value &= 0xff;
+		writel(reg, thread_map + offset);
+		writel(reg, thread_map + offset + 4);
+	}
+
+	return old_value;
+}
+
+static void pa2_unmap_resources(struct pa_core_device *core_dev)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	int i;
+
+	if (pa_dev->reg_mailbox)
+		iounmap(pa_dev->reg_mailbox);
+	if (pa_dev->reg_ra_bridge)
+		iounmap(pa_dev->reg_ra_bridge);
+	if (pa_dev->reg_thread_mapper)
+		iounmap(pa_dev->reg_thread_mapper);
+	if (pa_dev->reg_ra)
+		iounmap(pa_dev->reg_ra);
+	if (pa_dev->reg_stats_ctl)
+		iounmap(pa_dev->reg_stats_ctl);
+	if (pa_dev->reg_stats_block)
+		iounmap(pa_dev->reg_stats_block);
+
+	for (i = 0; i < PA2_NUM_CLUSTERS; i++) {
+		if (pa_dev->cluster[i].splitter)
+			iounmap(pa_dev->cluster[i].splitter);
+		if (pa_dev->cluster[i].sram)
+			iounmap(pa_dev->cluster[i].sram);
+	}
+
+	for (i = 0; i < PA2_NUM_PDSPS; i++) {
+		if (pa_dev->ppu[i].ctl_status)
+			iounmap(pa_dev->ppu[i].ctl_status);
+		if (pa_dev->ppu[i].debug)
+			iounmap(pa_dev->ppu[i].debug);
+		if (pa_dev->ppu[i].cp_timer)
+			iounmap(pa_dev->ppu[i].cp_timer);
+		if (pa_dev->ppu[i].lut1)
+			iounmap(pa_dev->ppu[i].lut1);
+		if (pa_dev->ppu[i].lut2)
+			iounmap(pa_dev->ppu[i].lut2);
+		if (pa_dev->ppu[i].pcheck)
+			iounmap(pa_dev->ppu[i].pcheck);
+		if (pa_dev->ppu[i].iram)
+			iounmap(pa_dev->ppu[i].iram);
+	}
+}
+
+static int pa2_map_resources(struct pa_core_device *core_dev,
+			     struct device_node *node)
+{
+	struct pa2_device *pa_dev = to_pa(core_dev);
+	struct device *dev = core_dev->dev;
+	struct resource res;
+	int i, ret = -ENODEV;
+
+	pa_dev->reg_mailbox =
+		core_ops->map_resource(dev, node, PA2_MB_REG_INDEX);
+	if (!pa_dev->reg_mailbox)
+		return ret;
+
+	pa_dev->reg_ra_bridge =
+		core_ops->map_resource(dev, node, PA2_RA_BRIDGE_INDEX);
+	if (!pa_dev->reg_ra_bridge)
+		goto unmap;
+
+	pa_dev->reg_thread_mapper =
+		core_ops->map_resource(dev, node, PA2_TMAPPER_INDEX);
+	if (!pa_dev->reg_thread_mapper)
+		goto unmap;
+
+	pa_dev->reg_ra = core_ops->map_resource(dev, node, PA2_RA_INDEX);
+	if (!pa_dev->reg_ra)
+		goto unmap;
+
+	pa_dev->reg_stats_ctl =
+		core_ops->map_resource(dev, node, PA2_STATS_CTL_INDEX);
+	if (!pa_dev->reg_stats_ctl)
+		goto unmap;
+
+	pa_dev->reg_stats_block =
+		core_ops->map_resource(dev, node, PA2_STATS_BLOCK_INDEX);
+	if (!pa_dev->reg_stats_block)
+		goto unmap;
+
+	ret = of_address_to_resource(node, PA2_CLUSTER_INDEX, &res);
+	if (ret) {
+		dev_err(core_dev->dev,
+			"Can't xlate pa2 cluster node at %d\n",
+			PA2_CLUSTER_INDEX);
+		goto unmap;
+	}
+
+	for (i = 0; i < PA2_NUM_CLUSTERS; i++) {
+		pa_dev->cluster[i].splitter =
+			ioremap_nocache(res.start +
+					PA2_CLUSTER_SPLITTER_REGS(i),
+					sizeof(struct pa2_cl_splitter_regs));
+		if (!pa_dev->cluster[i].splitter)
+			goto unmap;
+
+		pa_dev->cluster[i].sram =
+			ioremap_nocache(res.start + PA2_CLUSTER_SRAM_REGS(i),
+					PA2_CLUSTER_SRAM_SIZE);
+		if (!pa_dev->cluster[i].sram)
+			goto unmap;
+	}
+
+	for (i = 0; i < PA2_NUM_PDSPS; i++) {
+		pa_dev->ppu[i].ctl_status =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_CTL_STATUS_REGS_OFFSET,
+					sizeof(struct pa2_ppu_ctl_status_regs));
+		if (!pa_dev->ppu[i].ctl_status)
+			goto unmap;
+
+		pa_dev->ppu[i].debug =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_DEBUG_REGS_OFFSET,
+					sizeof(struct pa2_ppu_debug_regs));
+		if (!pa_dev->ppu[i].debug)
+			goto unmap;
+
+		pa_dev->ppu[i].cp_timer =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_CP_TIMER_REGS_OFFSET,
+					sizeof(struct pa2_ppu_cp_timer_regs));
+		if (!pa_dev->ppu[i].cp_timer)
+			goto unmap;
+
+		pa_dev->ppu[i].lut1 =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_LUT1_REGS_OFFSET,
+					sizeof(struct pa2_ppu_lut1_regs));
+		if (!pa_dev->ppu[i].lut1)
+			goto unmap;
+
+		pa_dev->ppu[i].lut2 =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_LUT2_REGS_OFFSET,
+					sizeof(struct pa2_ppu_lut2_regs));
+		if (!pa_dev->ppu[i].lut2)
+			goto unmap;
+
+		pa_dev->ppu[i].pcheck =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_PCHECK_REGS_OFFSET,
+					sizeof(struct pa2_ppu_pcheck_regs));
+		if (!pa_dev->ppu[i].pcheck)
+			goto unmap;
+
+		pa_dev->ppu[i].iram =
+			ioremap_nocache(res.start + pa2_ppu_regs_offset[i] +
+					PA2_PPU_IRAM_OFFSET, PA2_PPU_IRAM_SIZE);
+		if (!pa_dev->ppu[i].iram)
+			goto unmap;
+	}
+
+	return 0;
+
+unmap:	pa2_unmap_resources(core_dev);
+	return ret;
+}
+
+static struct pa_hw netcp_pa2_hw = {
+	.fmtcmd_next_route = pa2_fmtcmd_next_route,
+	.fmtcmd_tx_csum = pa2_fmtcmd_tx_csum,
+	.fmtcmd_align = pa2_fmtcmd_align,
+	.num_clusters = PA2_NUM_CLUSTERS,
+	.num_pdsps = PA2_NUM_PDSPS,
+	.ingress_l2_cluster_id = PA2_CLUSTER_0,
+	.ingress_l3_cluster_id = PA2_CLUSTER_1,
+	.egress_cluster_id = PA2_CLUSTER_6,
+	.streaming_pdsp = PSTREAM_ROUTE_INGRESS0,
+	.map_resources	= pa2_map_resources,
+	.unmap_resources = pa2_unmap_resources,
+	.pre_init = pa2_pre_init,
+	.post_init = pa2_post_init,
+	.set_firmware = pa2_set_firmware,
+	.rx_packet_handler = pa2_rx_packet_handler,
+	.add_mac_rule = pa2_add_mac_rule,
+	.set_streaming_switch = pa2_set_streaming_switch,
+	.get_streaming_switch = pa2_get_streaming_switch,
+};
+
+static int pa2_probe(struct netcp_device *netcp_device,
+		     struct device *dev,
+		     struct device_node *node,
+		     void **inst_priv)
+{
+	int ret, size = sizeof(struct pa2_device);
+	struct pa2_device *pa_dev;
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		return -ENODEV;
+	}
+
+	pa_dev = (struct pa2_device *)core_ops->init(netcp_device, dev, node,
+						     size, &ret, &netcp_pa2_hw,
+						     pa2_pdsp_firmwares);
+	if (!pa_dev)
+		return ret;
+	*inst_priv = pa_dev;
+
+	return ret;
+}
+
+static int pa2_ioctl(void *intf_priv, struct ifreq *req, int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct netcp_module pa2_module = {
+	.name		= "netcp-pa2",
+	.owner		= THIS_MODULE,
+	.probe		= pa2_probe,
+	.close		= pa_core_close,
+	.open		= pa_core_open,
+	.remove		= pa_core_remove,
+	.attach		= pa_core_attach,
+	.release	= pa_core_release,
+	.add_addr	= pa_core_add_addr,
+	.del_addr	= pa_core_del_addr,
+	.ioctl		= pa2_ioctl,
+};
+
+static int __init netcp_pa2_init(void)
+{
+	return netcp_register_module(&pa2_module);
+}
+module_init(netcp_pa2_init);
+
+static void __exit netcp_pa2_exit(void)
+{
+	netcp_unregister_module(&pa2_module);
+}
+module_exit(netcp_pa2_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Murali Karicheri m-karicheri2@ti.com>");
+MODULE_DESCRIPTION("NetCP Packet Accelerator 2 driver for Keystone devices");
diff --git a/drivers/net/ethernet/ti/netcp_pa2_fw.h b/drivers/net/ethernet/ti/netcp_pa2_fw.h
new file mode 100644
index 0000000..cd03cdb
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa2_fw.h
@@ -0,0 +1,1341 @@
+/*
+ * Keystone NetCP PA2 (Packet Accelerator) firmware interface header file
+ *
+ * Copyright (C) 2013-2015 Texas Instruments Incorporated
+ * Author :	Murali Karicheri (ported to kernel 4.1.x)
+ *
+ * Other contributors:	Hao Zhang (Initial version of the driver)
+ *			Reece Pollack (Maintenance)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PA2_FW_H
+#define KEYSTONE_PA2_FW_H
+
+/* PA Timer */
+enum pa2_timerstamp_scaler_factor {
+	PA2_TIMESTAMP_SCALER_FACTOR_1 = -1,
+	PA2_TIMESTAMP_SCALER_FACTOR_2 = 0,
+	PA2_TIMESTAMP_SCALER_FACTOR_4,
+	PA2_TIMESTAMP_SCALER_FACTOR_8,
+	PA2_TIMESTAMP_SCALER_FACTOR_16,
+	PA2_TIMESTAMP_SCALER_FACTOR_32,
+	PA2_TIMESTAMP_SCALER_FACTOR_64,
+	PA2_TIMESTAMP_SCALER_FACTOR_128,
+	PA2_TIMESTAMP_SCALER_FACTOR_256,
+	PA2_TIMESTAMP_SCALER_FACTOR_512,
+	PA2_TIMESTAMP_SCALER_FACTOR_1024,
+	PA2_TIMESTAMP_SCALER_FACTOR_2048,
+	PA2_TIMESTAMP_SCALER_FACTOR_4096,
+	PA2_TIMESTAMP_SCALER_FACTOR_8192
+};
+
+#define PA2_SS_TIMER_CNTRL_REG_GO		0x1u
+#define PA2_SS_TIMER_CNTRL_REG_MODE		0x2u
+#define PA2_SS_TIMER_CNTRL_REG_PSE		0x8000u
+#define PA2_SS_TIMER_CNTRL_REG_PRESCALE_SHIFT	0x2u
+
+#define PA2_SYS_TIMESTAMP_ADDR_OFFSET		0xf0
+
+/* PA Commands */
+#define PA2FRM_MAX_CMD_SET_SIZE			124
+
+/* Routed Packet Destinations */
+
+/* Packet is discarded */
+#define PA2_DEST_DISCARD			3
+/* Packet remains in PA sub-system for more parsing and LUT1 classification */
+#define PA2_DEST_CONTINUE_PARSE_LUT1		4
+/* Packet remains in PA sub-system for more parsing and LUT2 classification */
+#define PA2_DEST_CONTINUE_PARSE_LUT2		5
+/* Packet is routed to host */
+#define PA2_DEST_HOST				6
+/* Packet is routed to  EMAC */
+#define PA2_DEST_EMAC				7
+/* Packet is routed to SA */
+#define PA2_DEST_SASS				8
+/* Packet is routed to SRIO */
+#define PA2_DEST_SRIO				9
+/* Cascaded forwarding packet remains in PA sub-system for next LUT1 (IP)
+ * parsing. Those packets are expected to be delivered to QoS queues based
+ * on the VLAN/DSCP priority at the next stage so that some PASS actions
+ * such as IP reassembly and IP fragment exception route will be disabled.
+ */
+#define PA2_DEST_CASCADED_FORWARDING_LUT1	10
+/* Packet is routed to SA through local DMA */
+#define PA2_DEST_SASS_LOC_DMA			11
+/* Packet is routed to Egress Flow Path */
+#define PA2_DEST_EFLOW				12
+/* Reseved destination for internal usage */
+#define PA2_DEST_RES_1				20
+/* Reseved destination for internal usage */
+#define PA2_DEST_RES_2				21
+
+/* Multi Route */
+#define PA2_NO_MULTI_ROUTE			-1
+#define PA2_MAX_MULTI_ROUTE_SETS		32
+#define PA2_MAX_MULTI_ROUTE_ENTRIES		8
+#define PA2_MULTI_ROUTE_DESCRIPTOR_ONLY		0x01
+#define PA2_MULTI_ROUTE_REPLACE_SWINFO		0x02
+
+/* Egress FLOW Operation */
+#define PA2_EF_OP_CONTROL_FLAG_FC_LOOKUP	0x0001
+
+#define PA2_EF_OP_INFO_VALID_LVL1		0x0001
+#define PA2_EF_OP_INFO_VALID_LVL2		0x0002
+#define PA2_EF_OP_INFO_VALID_LVL3		0x0004
+#define PA2_EF_OP_INFO_VALID_LVL4		0x0008
+
+struct pa2_ef_op_info {
+	/* Specify Egress flow control flags as defined at
+	 * paEfOpInfoCtrlFlags
+	 */
+	u16	ctrl_flags;
+	/* Specify valid parameters as defined at paEfOpInfoValidBit */
+	u16	valid_bitmap;
+	/* Specify egress flow level 1 record index */
+	u16	lvl1_index;
+	/* Specify egress flow level 2 record index */
+	u16	lvl2_index;
+	/* Specify egress flow level 3 record index */
+	u16	lvl3_index;
+	/* Specify egress flow level 4 record index */
+	u16	lvl4_index;
+};
+
+enum pa2_route_pri_info {
+	/* Route by using VLAN bits as pri */
+	PA2_ROUTE_PRIORITY_VLAN = 1,
+	/* Route by using DSCP bits as pri */
+	PA2_ROUTE_PRIORITY_DSCP,
+	/* Route by using EMAC port (interface) number as destination
+	 * queue offset
+	 */
+	PA2_ROUTE_INTF,
+	/* Route by using EMAC port (interface) number as both destination
+	 * queue and CPPI flow offset
+	 */
+	PA2_ROUTE_INTF_W_FLOW
+};
+
+/* EMAC Control */
+#define PA2_EMAC_CTRL_PORT_MASK			0x0F
+#define PA2_EMAC_CTRL_CRC_DISABLE		0x80
+
+/* Custom Classification Types */
+#define PA2_CUSTOM_TYPE_NONE			0
+#define PA2_CUSTOM_TYPE_LUT1			1
+#define PA2_CUSTOM_TYPE_LUT2			2
+#define PA2_MAX_CUSTOM_TYPES_LUT1		4
+#define PA2_MAX_CUSTOM_TYPES_LUT2		16
+
+/* Command Transmit Packet Destinations */
+
+/* Packet is sent to INGRESS0/PDSP0 */
+#define PA2_CMD_TX_DEST_0			0
+/* Packet is sent to INGRESS1/PDSP1 */
+#define PA2_CMD_TX_DEST_1			1
+/* Packet is sent to INGRESS2/PDSP2 */
+#define PA2_CMD_TX_DEST_2			2
+/* Packet is sent to INGRESS3/PDSP3 */
+#define PA2_CMD_TX_DEST_3			3
+/* Packet is sent to INGRESS4/PDSP4 */
+#define PA2_CMD_TX_DEST_4			4
+/* Packet is sent to POST/PDSP5 */
+#define PA2_CMD_TX_DEST_5			5
+/* Packet is sent to EGRESS0 */
+#define PA2_CMD_TX_DEST_6			6
+/* Packet is sent to EGRESS1 */
+#define PA2_CMD_TX_DEST_7			7
+/* Packet is sent to EGRESS2 */
+#define PA2_CMD_TX_DEST_8			8
+
+/* PA Command Codes */
+#define PA2_CMD_NONE				0
+#define PA2_CMD_NEXT_ROUTE			1
+#define PA2_CMD_CRC_OP				2
+#define PA2_CMD_COPY_DATA_TO_PSINFO		3
+#define PA2_CMD_PATCH_DATA			4
+#define PA2_CMD_TX_CHECKSUM			5
+#define PA2_CMD_MULTI_ROUTE			6
+#define PA2_CMD_REPORT_TX_TIMESTAMP		7
+#define PA2_CMD_REMOVE_HEADER			8
+#define PA2_CMD_REMOVE_TAIL			9
+#define PA2_CMD_CMDSET				10
+#define PA2_CMD_SA_PAYLOAD			11
+#define PA2_CMD_IP_FRAGMENT			12
+#define PA2_CMD_USR_STATS			13
+#define PA2_CMD_CMDSET_AND_USR_STATS		14
+
+#define PA2_CMD_PATCH_MSG_LEN			15
+#define PA2_CMD_VERIFY_PKT_ERROR		16
+#define PA2_CMD_SPLIT				17
+#define PA2_CMD_EF_OP				18
+
+struct pa2_frm_forward_host {
+	/* Context returned as swInfo0 for matched packet */
+	u32	context;
+	/* Control bitmap, 1 for enable, 0 for disable
+	 *  /------------------------------------------------------------------\
+	 *  | 7                 |    |       2     |      1      |     0       |
+	 *  | Selection         |    |DSCP priority|VLAN priority| multiRoute  |
+	 *  | 0: Priority Select|    |		   |	OR	 |             |
+	 *  | 1: IF Dest Select |    |             |Flow IF Dest |             |
+	 *  \------------------------------------------------------------------/
+	 */
+	/* True if multiple destination enabled */
+	u8	ctrl_bitmap;
+	/* Index of the multiple destination set */
+	u8	multi_idx;
+	 /* PA PDSP number used as multi-route router */
+	u8	pa_pdsp_router;
+	/* use the bit 7:4, bit 7: Disable CRC, bit 6:4 port number (0/1/2),
+	 * bit 3:0 errflags = 0
+	 */
+	u8	ps_flags;
+	/* optional simple command: 0 means no command */
+	u8	cmd[4];
+}; /* 12 bytes */
+
+#define PA2FRM_MULTIROUTE_ENABLE		0x1
+#define PA2FRM_ROUTING_PRIORITY_DSCP_ENABLE	0x2
+#define PA2FRM_ROUTING_PRIORITY_VLAN_ENABLE	0x4
+/* 0: queue-based only; 1: queue- and flow-based */
+#define PA2FRM_ROUTING_FLOW_IF_BASE_ENABLE	0x2
+#define PA2FRM_ROUTING_IF_DEST_SELECT_ENABLE	0x80
+
+/* Routing information used to forward packets to the Ethernet port */
+struct pa2_frm_forward_eth {
+	/* use the bit 7:4 bit 7: Disable CRC, bit 6:4 port number (0/1/2),
+	 * bit 3:0 errflags = 0
+	 */
+	u8	ps_flags;
+	u8	priority;
+	u16	rsvd2;
+	u32	rsvd3;
+	u8	cmd[4];
+};
+
+#define PA2FRM_ETH_PS_FLAGS_DISABLE_CRC		0x80
+#define PA2FRM_ETH_PS_FLAGS_PORT_MASK		PA2_EMAC_CTRL_PORT_MASK
+#define PA2FRM_ETH_PS_FLAGS_PORT_SHIFT		0
+
+/* Routing information used to forward packets within PA */
+struct pa2_frm_forward_pa {
+	/* PDSP destination */
+	u8	pa_dest;
+	/* None, LUT1, LUT2 */
+	u8	custom_type;
+	/* Index of the custom type if LUT1 or LUT2 custom */
+	u8	custom_idx;
+	u8	flags;
+	u32	rsvd1;
+	u8	cmd[4];
+};
+
+#define PA2FRM_CASCADED_FORWARDING		0x01
+/* Mark the entry per ACL rule */
+#define PA2FRM_PA_CTRL_PKT_MARK			0x02
+/* Indicate that the packet should be dropped after reassembly per ACL rule */
+#define PA2FRM_PA_CTRL_PKT_DROP			0x04
+
+/* Routing information used to forward packets in egress flow */
+struct pa2_frm_forward_ef {
+	/* various control flags */
+	u8	ctrl_flags;
+	/* Egress record valid bit map, if flow cache lookup is not enabled */
+	u8	valid_bitmap;
+	/* reserved for alignment */
+	u16	rsvd1;
+	/* Egress Flow level one record index */
+	u8	lvl1_rec_idx;
+	/* Egress Flow level two record index */
+	u8	lvl2_rec_idx;
+	/* Egress Flow level three record index */
+	u8	lvl3_rec_idx;
+	/* Egress Flow level four record index */
+	u8	lvl4_rec_idx;
+	u32	rsvd2;
+};
+
+#define PA2FRM_EF_CTRL_FC_LOOKUP		0x01	/* Flow Cache lookup */
+#define PA2FRM_EF_VALID_REC_LVL1		0x01
+#define PA2FRM_EF_VALID_REC_LVL2		0x02
+#define PA2FRM_EF_VALID_REC_LVL3		0x04
+#define PA2FRM_EF_VALID_REC_LVL4		0x08
+
+/* Routing information used to drop the packet */
+struct pa2_frm_discard {
+	u32	rsvd1;
+	u32	rsvd2;
+	u8	cmd[4];
+};
+
+#define PA2FRM_CUSTOM_TYPE_NONE		PA2_CUSTOM_TYPE_NONE
+#define PA2FRM_CUSTOM_TYPE_LUT1		PA2_CUSTOM_TYPE_LUT1
+#define PA2FRM_CUSTOM_TYPE_LUT2		PA2_CUSTOM_TYPE_LUT2
+
+/* Routing information used to forward packets fromm PA sub-system to various
+ * destinations
+ */
+struct pa2_frm_forward  {
+	u8 forward_type;	/* Forwarding type as defined below */
+	u8 flow_id;		/* PKTDMA flow Id, valid if forwarding via
+				 * PKTDMA
+				 */
+	u16 queue;		/* Destination queue number, valid if forwarding
+				 * via PKTDMA
+				 */
+	union {
+		struct pa2_frm_forward_host	host;    /* Host specific
+							  * routing
+							  * information
+							  */
+		struct pa2_frm_forward_eth	eth;     /* Ethernet specific
+							  * routing
+							  * information
+							  */
+		struct pa2_frm_forward_pa	pa;      /* PA internal routing
+							  * information
+							  */
+		struct pa2_frm_forward_ef	ef;      /* PA Egress Flow
+							  * information
+							  */
+		struct pa2_frm_discard		discard; /* Discard specific
+							  * routing
+							  * information
+							  */
+	} u;
+};
+
+enum {
+	/* use PA2FRM_DEST_CDMA */
+	PA2FRM_FORWARD_TYPE_HOST = 0,
+	/* use PA2FRM_DEST_CDMA */
+	PA2FRM_FORWARD_TYPE_SA,
+	/* use pa.paDest */
+	PA2FRM_FORWARD_TYPE_PA,
+	/* use PA2FRM_DEST_ETH */
+	PA2FRM_FORWARD_TYPE_ETH,
+	/* use PA2FRM_DEST_CDMA */
+	PA2FRM_FORWARD_TYPE_SRIO,
+	/* use flowId as stream ID  */
+	PA2FRM_FORWARD_TYPE_SA_DIRECT,
+	PA2FRM_FORWARD_TYPE_DISCARD,
+	PA2FRM_FORWARD_TYPE_EFLOW
+};
+
+/* LUT1 classification mode */
+#define PA2FRM_LUT1_CLASS_NONE			0
+#define PA2FRM_LUT1_CLASS_STANDARD		1
+#define PA2FRM_LUT1_CLASS_IPV4			2
+#define PA2FRM_LUT1_CLASS_IPV6			3
+#define PA2FRM_LUT1_CLASS_IPSEC		PA2FRM_LUT1_CLASS_IPV6
+
+/*  Care0 [31:30] */
+#define PA2FRM_LUT1_CLASS_SHIFT			30
+
+/* LUT1 Range mode for two range parameters */
+
+/* Normal comparsion */
+#define PA2FRM_LUT1_RANGE_MODE_NORMAL		0
+/* Use RangeLo and RangeHi for range compare */
+#define PA2FRM_LUT1_RANGE_MODE_RANGE		1
+/* NOT comparison */
+#define PA2FRM_LUT1_RANGE_MODE_NOT		2
+/* Care0 [29:28]: Byte 42-43*/
+#define PA2FRM_LUT1_CLASS_SHIFT0		28
+/* Care0 [27:26]: Byte 44-45*/
+#define PA2FRM_LUT1_CLASS_SHIFT1		26
+
+/* LUT1 NOT operation for byte 41 */
+
+/* Normal Comparsion */
+#define PA2FRM_LUT1_CMP_OP_NORMAL		0
+/* Not cpmpare (byte 41) */
+#define PA2FRM_LUT1_CMP_OP_NOT			1
+/* Care 0 [25]: Byte 41 */
+#define PA2FRM_LUT1_CMP_OP_SHIFT		25
+
+/* LUT1 Entries (MAC/SRIO/Custom) */
+/* Layer 2 packet Type */
+#define PA2FRM_L2_PKT_TYPE_MAC			0x80
+#define PA2FRM_L2_PKT_TYPE_SRIO			0x40
+#define PA2FRM_L2_PKT_TYPE_CUSTOM		0x20
+/* Care0: [20:15] byte 4-9 */
+#define PA2FRM_LUT1_VALID_DMAC_ALL		0x001F8000
+#define PA2FRM_LUT1_VALID_DMAC_MINUS_BYTE5	0x001F0000
+/* Care0: [14:9]  byte 10-15 */
+#define PA2FRM_LUT1_VALID_SMAC			0x00007E00
+/* Care0: [8:7]   byte 16-17 */
+#define PA2FRM_LUT1_VALID_ETHERTYPE		0x00000180
+/* Care0: [6:5]   byte 18-19 */
+#define PA2FRM_LUT1_VALID_SESSION_ID		0x00000060
+/* Care0: [4:1]   byte 20-23 */
+#define PA2FRM_LUT1_VALID_MPLS			0x0000001E
+/* Care0: [24:24] Byte 0 */
+#define PA2FRM_LUT1_VALID_PKTFLAGS		0x01000000
+/* Care0: [23:23] Byte 1 */
+#define PA2FRM_LUT1_VALID_DMAC5			0x00800000
+
+/* Care1: [20:19] Byte 36-37 */
+#define PA2FRM_LUT1_VALID_VLANID1		0x00180000
+/* Care1: [18:17] Byte 38-39 */
+#define PA2FRM_LUT1_VALID_VLANID2		0x00060000
+/* Care1: [16:16] Byte 40    */
+#define PA2FRM_LUT1_VALID_PKTTYPE		0x00010000
+/* Care1: [15:15] Byte 41    */
+#define PA2FRM_LUT1_VALID_INPORT		0x00008000
+/* Care1: [14:13] Byte 42-43 */
+#define PA2FRM_LUT1_VALID_VLAN_PRI1		0x00006000
+/* Care1: [12:11] Byte 44-45 */
+#define PA2FRM_LUT1_VALID_VLAN_PRI2		0x00001800
+/* Care1: [10: 9] Byte 46-47 */
+#define PA2FRM_LUT1_VALID_SRC_VC		0x00000600
+
+#define PA2FRM_MK_SRC_VC(pdsp, lut_index)	(((pdsp) << 10) + (lut_index))
+#define PA2FRM_GET_PDSPID_FROM_LINK(lnk)	((lnk) >> 10)
+#define PA2FRM_GET_LUTIDX_FROM_LINK(lnk)	((lnk) & 0x3FF)
+
+/* Add MAC entry to LUT1 */
+struct pa2_frm_com_l1_mac {
+	/* LUT1 view 1 */
+	/* Destination mac */
+	u8	dmac[6];
+	/* Source mac */
+	u8	smac[6];
+	/* Ethernrt type, the field is also used for the previous match
+	 * PDSP number
+	 */
+	u16	etype;
+	/* PPPoE session ID */
+	u16	session_id;
+
+	/* LUT1 view 2 */
+	/* MPLS label */
+	u32	mpls;
+	u32	rsvd2_2;
+	u32	rsvd2_3;
+	u32	rsvd2_4;
+
+	/* LUT1 view 3 */
+	/* Various packet flags */
+	u8	pkt_flags;
+#define PA2FRM_MAC_FLAG_VLAN1			0x01
+#define PA2FRM_MAC_FLAG_VLAN2			0x02
+#define PA2FRM_MAC_FLAG_MCAST			0x04
+#define PA2FRM_MAC_FLAG_BCAST			0x08
+#define PA2FRM_MAC_FLAG_PPPOE			0x10
+#define PA2FRM_MAC_FLAG_802p3			0x20
+#define PA2FRM_MAC_FLAG_MPLS			0x40
+
+	/* Destination MAC address if bitMask is required */
+	u8	dst_mac5;
+	u16	rsvd4;
+	/* 12-bit ID of inner VLAN (0x8100) */
+	u16	vlan_id1;
+	/* 12-bit ID of outer VLAN */
+	u16	vlan_id2;
+	/* Common filed to indicate packet type */
+	u8	pkt_type;
+	/* One-base input EMAC port number */
+	u8	in_port;
+	/* 3-bit priority of inner VLAN (0x8100) */
+	u16	vlan_pri1;
+	/* 3-bit priority of outer VLAN */
+	u16	vlan_pri2;
+	/* virtual or physical link */
+	u16	src_vc;
+};
+
+struct pa2_frm_com_l1_custom {
+	/* LUT1 view 1 & 2 */
+	u8	match[32];
+
+	/* LUT1 view 3 - offset from start */
+	u32	rsvd3_1;
+	u32	rsvd3_2;
+	/* Common filed to indicate packet type */
+	u8	pkt_type;
+	u8	rsvd3_3;
+	u16	rsvd3_4;
+	u16	rsvd3_5;
+	/* virtual or physical link */
+	u16	src_vc;
+};
+
+struct pa2_frm_com_l1_ipv4 {
+	/* LUT1 view 1 */
+	/* Destination IP address */
+	u32	dst_ip;
+	/* Source IP address */
+	u32	src_ip;
+	u32	rsvd1_3;
+	u32	rsvd1_4;
+
+	/* LUT1 view 2 */
+	u32	rsvd2_1;
+	u32	rsvd2_2;
+	u32	rsvd2_3;
+	u32	rsvd2_4;
+
+	/* LUT1 view 3 */
+	/* Various packet flags */
+	u16	pkt_flags;
+#define PA2FRM_IP_FLAG_IP_TYPE			0x8000
+#define PA2FRM_IP_FLAG_V4			0x8000
+#define PA2FRM_IP_FLAG_GRE			0x4000
+#define PA2FRM_IP_FLAG_SCTP			0x2000
+#define PA2FRM_IP_FLAG_TCP_DATA			0x1000
+#define PA2FRM_IP_FLAG_OPTIONS			0x0800
+#define PA2FRM_IP_FLAG_FRAG			0x0400
+#define PA2FRM_IP_FLAG_CONTAIN_L4		0x0200
+#define PA2FRM_IP_FLAG_HOP_LIMIT		0x0100
+#define PA2FRM_IP_FLAG_IPSEC			0x0080
+
+	u8	dscp;
+	u8	rsvd3_1;
+	u32	rsvd3_2;
+	/* Common filed to indicate packet type */
+	u8	pkt_type;
+	/* Next Layer protocol */
+	u8	protocol;
+	/* Layer 4 source port number */
+	u16	src_port;
+	/* Layer 4 destination port number */
+	u16	dst_port;
+	/* virtual or physical link */
+	u16	src_vc;
+};
+
+struct pa2_frm_com_l1_ipv6 {
+	/* LUT1 view 1 */
+	/* Source IP address */
+	u32	src_ip0;
+	u32	src_ip1;
+	u32	src_ip2;
+	u32	src_ip3;
+
+	/* LUT1 view 2 */
+	/* Destination IP address */
+	u32	dst_ip0;
+	u32	dst_ip1;
+	u32	dst_ip2;
+	u32	dst_ip3;
+
+	/* LUT1 view 3 */
+	/* Various packet flags */
+	u16	pkt_flags;
+#define PA2FRM_IP_FLAG_V6			0x4000
+	u8	dscp;
+	u8	rsvd8a;
+	/* 20-bit Flow Label in the header */
+	u32	flow_label;
+	/* Common filed to indicate packet type */
+	u8	pkt_type;
+	/* Next Layer protocol */
+	u8	protocol;
+	/* Layer 4 source port number */
+	u16	src_port;
+	/* Layer 4 destination port number */
+	u16	dst_port;
+	/* virtual or physical link */
+	u16	src_vc;
+};
+
+struct pa2_frm_com_l1_ipsec  {
+	/* LUT1 view 1 */
+	u32	rsvd1_1;
+	u32	rsvd1_2;
+	u32	rsvd1_3;
+	u32	rsvd1_4;
+
+	/* LUT1 view 2 */
+	u32	rsvd2_1;
+	u32	rsvd2_2;
+	u32	rsvd2_3;
+	u32	rsvd2_4;
+
+	/* LUT1 view 3 */
+	/* Various packet flags */
+	u16	pkt_flags;
+#define PA2FRM_IPSEC_FLAG_ESP			0x8000
+#define PA2FRM_IPSEC_FLAG_AH			0x4000
+	u16	rsvd3_1;
+	/* SPI value */
+	u32	spi;
+	/* Common filed to indicate packet type */
+	u8	pkt_type;
+	u8	rsvd3_2;
+	u16	rsvd3_3;
+	u16	rsvd3_4;
+	/* virtual or physical link */
+	u16	src_vc;
+};
+
+enum {
+	PA2FRM_CONFIG_COMMAND_RSVD	= 0,
+	PA2FRM_CONFIG_COMMAND_ADDREP_LUT1,
+	PA2FRM_CONFIG_COMMAND_DEL_LUT1,
+	PA2FRM_CONFIG_COMMAND_ADDREP_LUT2,
+	PA2FRM_CONFIG_COMMAND_DEL_LUT2,
+	PA2FRM_CONFIG_COMMAND_CONFIG_PA,
+	PA2FRM_CONFIG_COMMAND_REQ_STATS,
+	PA2FRM_CONFIG_COMMAND_REQ_VERSION,
+	PA2FRM_CONFIG_COMMAND_MULTI_ROUTE,
+	PA2FRM_CONFIG_COMMAND_CRC_ENGINE,
+	PA2FRM_CONFIG_COMMAND_CMD_SET,
+	PA2FRM_CONFIG_COMMAND_CMD_USR_STATS,
+	PA2FRM_CONFIG_COMMAND_CMD_SYS_CONFIG,
+	PA2FRM_CONFIG_COMMAND_CMD_MULTI_CMDS
+};
+
+/* Command magic value */
+#define PA2FRM_CONFIG_COMMAND_SEC_BYTE  0xce
+
+/* Command return values */
+enum {
+	/* Must be 0 */
+	PA2FRM_COMMAND_RESULT_SUCCESS = 0,
+	/* Command magic value not found */
+	PA2FRM_COMMAND_RESULT_NO_COMMAND_MAGIC,
+	/* Invalid command identifier */
+	PA2FRM_COMMAND_RESULT_INVALID_CMD,
+
+	/* Add entry to LUT1 fails codes */
+
+	/* Invalid type, custom or standard IP/ethernet */
+	PA2FRM_COMMAND_RESULT_LUT1_TYPE_INVALID,
+	/* Invalid LUT1 index (0-63) or no free indices available */
+	PA2FRM_COMMAND_RESULT_LUT1_INDEX_INVALID,
+	/* Sent a match packet to q0 on c1 or c2 - this is illegal. */
+	PA2FRM_COMMAND_RESULT_LUT1_MATCH_DEST_INVALID,
+	/* Previous match fwd info was somewhere in chunk domain */
+	PA2FRM_COMMAND_RESULT_LUT1_NMATCH_INVALID,
+	/* Invalid combination found in the key value */
+	PA2FRM_COMMAND_RESULT_LUT1_INVALID_KEYS,
+
+	/* Lut 2 entry warnings since the lut can be configured without pdsp */
+	PA2FRM_COMMAND_RESULT_WARN_OVER_MAX_ENTRIES,
+	PA2FRM_COMMAND_RESULT_WARN_NEGATIVE_ENTRY_COUNT,
+
+	/* Lut 2 entry failures */
+
+	/* LUT2 had a lookup and pending config */
+	PA2FRM_COMMAND_RESULT_LUT2_ADD_BUSY,
+	/* Not enough room in stats request packet for the reply */
+	PA2FRM_COMMAND_RESULT_WARN_STATS_REPLY_SIZE,
+	/* Command sent to PDSP which couldn't handle it */
+	PA2FRM_COMMAND_RESULT_INVALID_DESTINATION,
+
+	/* Add/Delete/Read entries to multi route table */
+
+	/* Asked to use a free entry, but none found */
+	PA2FRM_COMMAND_RESULT_MULTI_ROUTE_NO_FREE_ENTRIES,
+	/* Illegal index value used */
+	PA2FRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_IDX,
+	/* Illegal multi route mode used */
+	PA2FRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_MODE,
+
+	/* Packet size didn't match command */
+	PA2FRM_COMMAND_RESULT_INVALID_PKT_SIZE,
+
+	/* Coustom and Command set index */
+
+	/* Illegal Custom LUT1 index value used */
+	PA2FRM_COMMAND_RESULT_INVALID_C1_CUSTOM_IDX,
+	/* Illegal Custom LUT2 index value used */
+	PA2FRM_COMMAND_RESULT_INVALID_C2_CUSTOM_IDX,
+	/* Illegal Custom Cmd Set index value used */
+	PA2FRM_COMMAND_RESULT_INVALID_CMDSET_IDX,
+	/* Illegal User Stats Configuration */
+	PA2FRM_COMMAND_RESULT_USR_STATS_INVALID_CONFIG
+};
+
+/* Destination (route) values */
+/* Packets to Global CDMA */
+#define PA2FRM_DEST_CDMA0			0
+/* Packets to Local CDMA */
+#define PA2FRM_DEST_CDMA1			1
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET1			2
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET2			3
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET3			4
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET4			5
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET5			6
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET6			7
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET7			8
+/* Packets to Ethernet TX */
+#define PA2FRM_DEST_ETHERNET8			9
+/* Packets to Cluster Ingress 0 */
+#define PA2FRM_DEST_INGRESS0			10
+/* Packets to Cluster Ingress 1 */
+#define PA2FRM_DEST_INGRESS1			11
+/* Packets to Cluster Ingress 2 */
+#define PA2FRM_DEST_INGRESS2			12
+/* Packets to Cluster Ingress 3 */
+#define PA2FRM_DEST_INGRESS3			13
+/* Packets to Cluster Ingress 4 */
+#define PA2FRM_DEST_INGRESS4			14
+/* Packets to Cluster Post Processings */
+#define PA2FRM_DEST_POST			15
+/* Packets to Cluster Egress 0 */
+#define PA2FRM_DEST_EGRESS0			16
+/* Packets to Cluster Egress 1 */
+#define PA2FRM_DEST_EGRESS1			17
+/* Packets to Cluster Egress 2 */
+#define PA2FRM_DEST_EGRESS2			18
+/* Packets to Reasm Accelerator */
+#define PA2FRM_DEST_REASM			19
+/* Placeholder for model */
+#define PA2FRM_DEST_ACE0			20
+/* Placeholder for model */
+#define PA2FRM_DEST_ACE1			21
+/* Packets to Statsbloc */
+#define PA2FRM_DEST_STATSBLOC			22
+
+#define PA2FRM_DEST_PKTDMA			PA2FRM_DEST_CDMA0
+#define PA2FRM_DEST_PKTDMA_LOC			PA2FRM_DEST_CDMA1
+#define PA2FRM_DEST_ETH				PA2FRM_DEST_ETHERNET1
+
+#define PA2FRM_DEST_DISCARD			0xff
+
+/* Assigning names based on PDSP functions */
+#define PA2FRM_DEST_PA_C1_0			PA2FRM_DEST_INGRESS0
+#define PA2FRM_DEST_PA_C1_1			PA2FRM_DEST_INGRESS1
+#define PA2FRM_DEST_PA_C1_2			PA2FRM_DEST_INGRESS4
+#define PA2FRM_DEST_PA_C2			PA2FRM_DEST_INGRESS4
+#define PA2FRM_DEST_PA_M_0			PA2FRM_DEST_POST
+#define PA2FRM_DEST_PA_M_1			PA2FRM_DEST_EGRESS2
+
+/* The default queue for packets that arrive at the PA and don't match in
+ * classify1 (right at init time)
+ */
+#define PA2FRM_DEFAULT_INIT_Q			0x100
+
+/* Ethertypes recognized by the firmware. */
+#define PA2FRM_ETHERTYPE_IP			0x0800
+#define PA2FRM_ETHERTYPE_IPV6			0x86dd
+#define PA2FRM_ETHERTYPE_VLAN			0x8100
+#define PA2FRM_ETHERTYPE_SPVLAN			0x88a8
+#define PA2FRM_ETHERTYPE_MPLS			0x8847
+#define PA2FRM_ETHERTYPE_MPLS_MULTI		0x8848
+
+/* Next header type values  */
+#define PA2FRM_HDR_MAC				0
+#define PA2FRM_HDR_VLAN				1
+#define PA2FRM_HDR_MPLS				2
+#define PA2FRM_HDR_IPV4				3
+#define PA2FRM_HDR_IPV6				4
+#define PA2FRM_HDR_IPV6_EXT_HOP			5
+#define PA2FRM_HDR_IPV6_EXT_ROUTE		6
+#define PA2FRM_HDR_IPV6_EXT_FRAG		7
+#define PA2FRM_HDR_IPV6_EXT_DEST		8
+#define PA2FRM_HDR_GRE				9
+#define PA2FRM_HDR_ESP				10
+#define PA2FRM_HDR_ESP_DECODED			11
+#define PA2FRM_HDR_AUTH				12
+#define PA2FRM_HDR_CUSTOM_C1			13
+/* A contrived header type used with custom SRIO to force a parse after looking
+ * at only the RIO L0-L2
+ */
+#define PA2FRM_HDR_FORCE_LOOKUP			14
+#define PA2FRM_HDR_SCTP				15
+#define PA2FRM_HDR_UNKNOWN			16
+#define PA2FRM_HDR_UDP				17
+#define PA2FRM_HDR_UDP_LITE			18
+#define PA2FRM_HDR_TCP				19
+#define PA2FRM_HDR_GTPU				20
+#define PA2FRM_HDR_ESP_DECODED_C2		21
+#define PA2FRM_HDR_CUSTOM_C2			22
+
+/* Command related definitions */
+#define PA2FRM_CRC_FLAG_CRC_OFFSET_VALID	0x01
+#define PA2FRM_CRC_FLAG_CRC_OFFSET_FROM_DESC	0x02
+#define PA2FRM_CHKSUM_FALG_NEGATIVE		0x01
+
+#define PA2_NEXT_ROUTE_PARAM_PRESENT		0x0001
+#define PA2_NEXT_ROUTE_PROC_NEXT_CMD		0x0002
+#define PA2_NEXT_ROUTE_PROC_MULTI_ROUTE		0x0004
+
+/* PAFRM receive commands related definitions */
+
+/* There are the following two groups of PAFRM receive commands:
+ * PAFRM short commands which can be used as part of the routing info
+ * PAFRM commands which can be used within a command set
+ */
+/* Dummy command */
+#define PA2FRM_RX_CMD_NONE			0
+
+/* short commands */
+/* Execute a command set */
+#define PA2FRM_RX_CMD_CMDSET			1
+/* Insert up to two types at the current location */
+#define PA2FRM_RX_CMD_INSERT			2
+/* Increment the specific user-statistics chain */
+#define PA2FRM_RX_CMD_USR_STATS			3
+/* Increment User-defined Stats chain and  execute the command set */
+#define PA2FRM_RX_CMD_CMDSET_USR_STATS		4
+
+/* command set commands */
+/* Specify the next route */
+#define PA2FRM_RX_CMD_NEXT_ROUTE		11
+/* CRC generation or verification */
+#define PA2FRM_RX_CMD_CRC_OP			12
+/* Copy data to the PS Info section */
+#define PA2FRM_RX_CMD_COPY_DATA			13
+/* Insert or patch packet data at the specific location */
+#define PA2FRM_RX_CMD_PATCH_DATA		14
+/* Remove the parsed packet header */
+#define PA2FRM_RX_CMD_REMOVE_HDR		15
+/* Remove the parsed packet tail */
+#define PA2FRM_RX_CMD_REMOVE_TAIL		16
+/* Duplicate packet to multiple destinations */
+#define PA2FRM_RX_CMD_MULTI_ROUTE		17
+/* Verify packet error based on error flags */
+#define PA2FRM_RX_CMD_VERIFY_PKT_ERROR		18
+/* Payload splitting */
+#define PA2FRM_RX_CMD_SPLIT			19
+
+/* define LUT1 entry types */
+/* MAC/IP/IPSEC/ACL/FC */
+#define PA2FRM_COM_ADD_LUT1_STANDARD		0
+/* SRIO */
+#define PA2FRM_COM_ADD_LUT1_SRIO		1
+/* Custom LUT1 */
+#define PA2FRM_COM_ADD_LUT1_CUSTOM		2
+/* Standard entry with virtual Link */
+#define PA2FRM_COM_ADD_LUT1_VLINK		3
+
+/* LUT1 Entries */
+/* if PA2_LUT1_INDEX_LAST_FREE is used then when the command returns,
+ * the value of index will be replaced with the actual index used
+ */
+#define PA2FRM_HW_LUT1_ENTRIES			256
+#define PA2FRM_LUT1_INDEX_LAST_FREE		PA2FRM_HW_LUT1_ENTRIES
+
+struct pa2_frm_cmd_add_lut1 {
+	/* LUT1 index. */
+	u16	index;
+	/* Custom or standard */
+	u8	type;
+	/* Valid only if type is custom */
+	u8	cust_index;
+	/* Virtual Link number if used */
+	u16	vlink_num;
+	/* entry statistics index (Flow Cache only) */
+	u16	stats_index;
+
+	/* LUT1 views */
+	union {
+		/* matching information for MAC/IP entry */
+		struct pa2_frm_com_l1_mac	mac;
+		struct pa2_frm_com_l1_custom	custom;
+		/* matching information for IPv4 entry*/
+		struct pa2_frm_com_l1_ipv4	ipv4;
+		/* matching information for IPv6 entry */
+		struct pa2_frm_com_l1_ipv6	ipv6;
+		/* matching information for IPSEC entry */
+		struct pa2_frm_com_l1_ipsec	ipsec;
+	} u;
+
+	/* Command header */
+	/* Range High for bytes 44-45 */
+	u16	range1_hi;
+	/* Range High for bytes 42-43 */
+	u16	range0_hi;
+	/* Care Bits Word0 */
+	u32	cbwords0;
+	/* Care Bits Word1 */
+	u32	cbwords1;
+	/* BitMask for Bytes 0-1 */
+	u16	bit_mask;
+	/* Record priority "score", relative index */
+	u16	priority;
+	/* Routing information when a match is found */
+	struct pa2_frm_forward match;
+
+	/* Routing information when subsequent match fails - a fragmented
+	 * packet orinner route
+	 */
+	struct pa2_frm_forward next_fail;
+};
+
+/* PA CRC Engine Instance Destinations */
+enum pa2_crc_inst {
+	/* CRC Engine between Ingress0, CDE0 and CED1 */
+	PA2_CRC_INST_0_0 = 0,
+	/* CRC Engine between Ingress1, CDE0 and CED1 */
+	PA2_CRC_INST_1_0,
+	/* Engine between Ingress4, CDE0 and CED1 */
+	PA2_CRC_INST_4_0,
+	/* Engine between Post, CDE0 and CED1 */
+	PA2_CRC_INST_5_0,
+	/* Engine between Egress0, CDE0 and CED1 */
+	PA2_CRC_INST_6_0,
+	/* Engine between Egress0, CDE1 and CED2 */
+	PA2_CRC_INST_6_1,
+	PA2_CRC_INST_MAX
+};
+
+#define PARAM_CRC_TABLE_SIZE			16
+
+enum pa2_crc_size {
+	/* 8-bit CRC */
+	PA2_CRC_SIZE_8 = 0,
+	/* 16-bit CRC */
+	PA2_CRC_SIZE_16,
+	/* 24-bit CRC */
+	PA2_CRC_SIZE_24,
+	/* 32-bit CRC */
+	PA2_CRC_SIZE_32
+};
+
+struct pa2_crc_config {
+	/* CRC configuration control info as defined below */
+	u16			ctrl_bits;
+	/* Set: Right shift CRC (b0 to b7), Clear: Left shift CRC (b7 to b0) */
+#define PA2_CRC_CONFIG_RIGHT_SHIFT		0x0001
+	/* Set: a 'NOT' operation is applied to the final CRC result */
+#define PA2_CRC_CONFIG_INVERSE_RESULT		0x0002
+
+	enum pa2_crc_size	size;
+	/* CRC polynomial in the format
+	 *	   of 0xabcdefgh. For example,
+	 *	   x32+x28+x27+x26+x25+x23+x22+
+	 *	   x20+x19+x18+x14+x13+x11+x10+
+	 *	   x9+x8+x6+1 ==> 0x1EDC6F41
+	 *	   x16+x15+x2+1 ==>0x80050000
+	 */
+	u32			polynomial;
+	/* CRC initial value */
+	u32			init_value;
+};
+
+struct pa2_frm_config_crc {
+	/* Control bit maps as defined below */
+	u8	ctrl_bitmap;
+#define PARAM_CRC_CTRL_CRC_SIZE_MASK		0x3
+#define PARAM_CRC_CTRL_LEFT_SHIFT		0x0
+#define PARAM_CRC_CTRL_RIGHT_SHIFT		0x4
+#define PARAM_CRC_CTRL_INV_RESULT		0x8
+
+	/* reserved for alignment */
+	u8	rsvd1;
+	/* reserved for alignment */
+	u16	rsvd2;
+	/* Initial value to use in the CRC calcualtion */
+	u32	init_val;
+	/* CRC table */
+	u32	crc_tbl[PARAM_CRC_TABLE_SIZE];
+};
+
+#define PA2FRM_CFG_CMD_STATUS_PROC		0
+#define PA2FRM_CFG_CMD_STATUS_DONE		1
+
+struct pa2_frm_command_cmd_hdr {
+	/* Command Header of each command within the multiple command packet */
+	u8	command;
+	/* Offset to the next command, 0: Indicate the last command */
+	u8	offset;
+	/* general parameter used by host only */
+	u16	com_id;
+};
+
+/* Commands to PA */
+struct pa2_frm_command {
+	/* Command Status (used by firmware only) */
+	u8	status;
+	/* index of the first targeted PDSP in a cluster */
+	u8	pdsp_index;
+	/* Returned to the host, ignored on entry to the PASS */
+	u16	command_result;
+	/* Used by the host to identify command results */
+	u16	com_id;
+	/* Command value */
+	u8	command;
+	/* Magic value */
+	u8	magic;
+	/* Returned in swInfo to identify packet as a command */
+	u32	ret_context;
+	/* Specifies the queue number for the message reply. 0xffff
+	 * to toss the reply
+	 */
+	u16	reply_queue;
+	/* Reply destination (host0, host1, discard are the only valid values)
+	 */
+	u8	reply_dest;
+	/* Flow ID used to assign packet at reply */
+	u8	flow_id;
+	/* First word of the command */
+	u32	cmd;
+};
+
+struct pa2_cmd_next_route {
+	/* Routing control information as defined at routeCtrlInfo */
+	u16	ctrl_bit_field;
+	/* Packet destination as defined at pktDest */
+	int	dest;
+	/* For destination SRIO, specify the 5-bit packet type toward SRIO for
+	 * destination EMAC, specify the EMAC control @ref emcOutputCtrlBits to
+	 * the network
+	 */
+	u8	pkt_type_emac_ctrl;
+	/* For host, SA or SRIO destinations, specifies return free descriptor
+	 * setup
+	 */
+	u8	flow_id;
+	/* For host, SA or SRIO destinations, specifies the dest queue */
+	u16	queue;
+		/* Placed in SwInfo0 for packets to host or SA */
+	u32	sw_info_0;
+	/* Placed in SwInfo1 for packets to the SA */
+	u32	sw_info_1;
+	/* Multi-route index. It is valid in the from-network direction only */
+	u16	multi_route_index;
+	/* Index of the first user-defined statistics to be updated. This
+	 * optional parameter is valid in the to-network direction only
+	 */
+	u16	stats_index;
+};
+
+struct pa2_cmd_crc_op {
+	/* CRC operation control information as defined at @ref crcOpCtrlInfo */
+	u16	ctrl_bit_field;
+	/* Byte location, from SOP/Protocol Header, where the CRC computation
+	 * begins if frame type is not specified Byte location, from
+	 * SOP/Protocol header, where the specific frame header begins if frame
+	 * type is specified In to-network direction:
+	 *	offset from SOP In from-network direction: offset from the
+	 *	current parsed header
+	 */
+	u16	start_offset;
+	/* Number of bytes covered by the CRC computation valid only if
+	 * pa_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is clear
+	 */
+	u16	len;
+	/* Payload length field offset in the custom header */
+	u16	len_offset;
+	/* Payload length field mask */
+	u16	len_mask;
+	/* Payload length adjustment: valid only if
+	 * PA2_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is set
+	 */
+	u16	len_adjust;
+	/* Offset from SOP/Protocol Header to the CRC field In to-network
+	 * direction:
+	 *	offset from SOP In from-network direction: offset from
+	 *      the current parsed header
+	 */
+	u16	crc_offset;
+	/* Size of CRC in bytes */
+	u16	crc_size;
+	/* Frame type @ref crcFrameTypes, valid if PA2_CRC_OP_CRC_FRAME_TYPE
+	 * is set
+	 */
+	u16	frame_yype;
+	/* CRC initial value */
+	u32	init_value;
+};
+
+/* Transmit checksum configuration
+ * pa_tx_chksum is used in the call to @ref Pa_formatTxRoute or @ref
+ * Pa_formatTxCmd to create a tx command header that instructs the packet
+ * accelerator sub-system to generate ones' complement checksums into network
+ * packets. The checksums are typically used for TCP and UDP payload checksums
+ * as well as IPv4 header checksums. In the case of TCP and UDP payload
+ * checksums the pseudo header checksum must be pre-calculated and provided,
+ * the sub-system does not calculate it.
+ */
+struct pa2_tx_chksum {
+	/* Byte location, from SOP, where the checksum calculation begins */
+	u16	start_offset;
+	/* Number of bytes covered by the checksum. Must be even */
+	u16	length_bytes;
+	/* Byte offset, from startOffset, to place the resulting checksum */
+	u16	result_offset;
+	/* Initial value of the checksum */
+	u16	initial_sum;
+	/* If TRUE, a computed value of 0 is written as -0 */
+	u16	negative_0;
+};
+
+struct pa2_cmd_copy {
+	/* Copy operation control information as defined at @ref copyCtrlInfo */
+	u16	ctrl_bit_field;
+	/* Offset from the start of current protocol header for the data copy
+	 * to begin
+	 */
+	u16	src_offset;
+	/* Offset from the top of the PSInfo for the data to be copied to */
+	u16	dest_offset;
+	/* Number of bytes to be copied */
+	u16	num_bytes;
+};
+
+struct pa2_cmd_multi_route {
+	/*  Multi-route set Index */
+	u16	index;
+};
+
+/* PATCH Command in to-netweok direction */
+#define PA2_MAX_PATCH_BYTES			16
+/* PATCH Command within a command set */
+#define PA2_MAX_RX_PATCH_BYTES			32
+#define PA2_PATCH_OP_INSERT			0x0001
+#define PA2_PATCH_OP_MAC_HDR			0x0002
+#define PA2_PATCH_OP_DELETE			0x0004
+struct pa2_patch_info {
+	/* Patch operation control information as defined at @ref
+	 * patchCtrlInfo
+	 */
+	u16	ctrl_bit_field;
+	/* The number of bytes to be patched */
+	u16	n_patch_bytes;
+	/* The number of patch bytes in the patch cmd, must be >= to nPatchBytes
+	 * and a multiple of 4 bytes
+	 */
+	u16	total_patch_size;
+	/* Offset from the start of the packet for the patch to begin in the
+	 * to-network direction Offset from the start of the current header
+	 * for the patch to begin in the from-network direction
+	 */
+	u16	offset;
+	/* Pointer to the patch data */
+	u8	*patch_data;
+};
+
+/* pa_payload_info defines the packet payload information in the short format.
+ * It is required by the Security Accelerator sub-system (SASS)
+ *
+ * pa_payload_info defines the packet parsing information in terms of payload
+ * offset and payload length as described below
+ * SRTP:      offset to the RTP header; RTP payload length including ICV
+ * IPSEC AH:  offset to the Outer IP; IP payload length
+ * IPSEC ESP: offset to the ESP header; ESP papload length including ICV
+ */
+
+struct pa2_payload_info  {
+	/* The offset to where the SA packet parsing starts */
+	u16	offset;
+	/* The total length of the protocal payload to be processed by SA */
+	u16	len;
+	/* Optional supplement data such as the 32-bit CountC for some 3GPP
+	 * operation modes
+	 */
+	u32	sup_data;
+};
+
+/* The maximum number of command sets supported */
+#define PA2_MAX_CMD_SETS			64
+
+#define PA2_OK					0
+#define PA2_ERR_CONFIG				-10
+#define PA2_INSUFFICIENT_CMD_BUFFER_SIZE	-11
+#define PA2_INVALID_CMD_REPLY_DEST		-12
+
+/* Command Set Command
+ *
+ * pa_cmd_set is used to specify the desired PA command set. The command set
+ * command instructs the PASS to execute a list of commands after a LUT1 or
+ * LUT2 match occurs. It is one of the command which can be embedded within
+ * the @ref paRouteInfo_t.
+ */
+struct pa2_cmd_set {
+	/*Command Set Index */
+	u16	index;
+};
+
+struct pa2_cmd_tx_timestamp {
+	/* Host queue for the tx timestamp reporting packet */
+	u16	dest_queue;
+	/* CPPI flow */
+	u16	flow_id;
+	/* 32 bit value returned in the descriptor */
+	u32	sw_info0;
+};
+
+struct pa2_cmd_ip_frag {
+	/* Offset to the IP header. */
+	u16	ip_offset;
+	/* Size of the maximum transmission unit (>= 68) */
+	u16	mtu_size;
+};
+
+struct pa2_cmd_usr_stats {
+	/* User-defined statistics index */
+	u16	index;
+};
+
+struct pa2_cmd_set_usr_stats {
+	/* Commad Set Index */
+	u16	set_index;
+	/* User-defined statistics index */
+	u16	stats_index;
+};
+
+struct pa2_cmd_info {
+	/* Specify the PA command code as defined at paCmdCode */
+	u16	cmd;
+	union {
+		/* Specify nextRoute command specific parameters */
+		struct pa2_cmd_next_route route;
+		/* Specify Tx Checksum command specific parameters */
+		struct pa2_tx_chksum	chksum;
+		/* Specify CRC operation command specific parameters */
+		struct pa2_cmd_crc_op	crc_op;
+		/* Specify Copy command specific parameters */
+		struct pa2_cmd_copy	copy;
+		/* Specify Patch command specific parameters */
+		struct pa2_patch_info	patch;
+		/* Specify the payload info required by SA */
+		struct pa2_payload_info	payload;
+		/* Specify Command Set command specific parameters */
+		struct pa2_cmd_set	cmd_set;
+		/* Specify Multi-route cmd specific parameters */
+		struct pa2_cmd_multi_route m_route;
+		/* Report Tx Timestamp command specific parameters */
+		struct pa2_cmd_tx_timestamp tx_ts;
+		/* Specify IP fragmentation command specific parameters */
+		struct pa2_cmd_ip_frag	ip_frag;
+		/* User-defined stats command specific parameters */
+		struct pa2_cmd_usr_stats usr_stats;
+		struct pa2_cmd_set_usr_stats cmd_set_usr_stats;
+	} params;
+};
+
+struct pa2_route_info {
+	/* Packet destination as defined at pktDest */
+	int	dest;
+	/* For host, SA or SRIO destinations, specifies CPPI flow which defines
+	 * free queues are used for receiving packets
+	 */
+	u8	flow_id;
+	/* For host, SA or SRIO destinations, specifies the destination queue */
+	u16	queue;
+	int	m_route_index;
+	/* For host, Multi-queue routing index
+	 * (0 to (pa_MAX_MULTI_ROUTE_SETS - 1)) or pa_NO_MULTI_ROUTE if multi
+	 * routing not used
+	 */
+	/* Placed in SwInfo0 for packets to host or SA; Placed in the PS Info
+	 * for packets to SRIO
+	 */
+	u32	sw_info_0;
+	/* Placed in SwInfo1 for packets to the SA; Placed in the PS Info for
+	 * packets to SRIO
+	 */
+	u32	sw_info_1;
+	int	custom_type;
+	/* For CONTINUE_PARSE_LUT1/LUT2 only, specifies the custom type as
+	 * defined at @ref customType
+	 */
+	/* For CONTINUE_PARSE_LUT1/LUT2 only, specifies the custom
+	 * classification entry index
+	 */
+	u8	custom_index;
+	/* For destination SRIO, specify the 5-bit packet type toward SRIO
+	 * For destination HOST, EMAC, specify the EMAC control
+	 * emcOutputCtrlBits to the network
+	 */
+	u8	pkt_type_emac_ctrl;
+	/* Pointer to the Command info to be executed prior to the packet
+	 * forwarding. Note only the following commands are supported within
+	 * paRouteInfo_t - pa_CMD_PATCH_DATA (up to two bytes only) (LUT2 only)
+	 *	   - pa_CMD_CMDSET
+	 *	   - pa_CMD_USR_STATS
+	 *	   - pa_CMD_CMDSET_AND_USR_STATS
+	 */
+	struct pa2_cmd_info *pcmd;
+};
+
+/* PA Route Info Valid Bit Definitions */
+#define PA2_ROUTE_INFO_VALID_MROUTEINDEX	BIT(0)
+#define PA2_ROUTE_INFO_VALID_PKTTYPE_EMAC	BIT(1)
+#define PA2_ROUTE_INFO_VALID_PCMD		BIT(2)
+#define PA2_ROUTE_INFO_VALID_PRIORITY_TYPE	BIT(3)
+
+struct pa2_route_info2 {
+	/* 32-bit valid bitmap corresponding to each optional field as defined
+	 * at paRouteInfoValidBits
+	 */
+	u32	valid_bitmap;
+	/* Packet destination as defined at pktDest */
+	int	dest;
+	/* For host, SA or SRIO destinations, specifies CPPI flow which defines
+	 * free queues are used for receiving packets
+	 */
+	u8	flow_id;
+	/* For host, SA or SRIO destinations, specifies the destination queue */
+	u16	queue;
+	int	m_route_index;
+	/* For host, Multi-queue routing index
+	 * (0 to (pa_MAX_MULTI_ROUTE_SETS - 1)) or pa_NO_MULTI_ROUTE if multi
+	 * routing not used
+	 */
+	/* Placed in SwInfo0 for packets to host or SA; Placed in the PS Info
+	 * for packets to SRIO
+	 */
+	u32	sw_info_0;
+	/* Placed in SwInfo1 for packets to the SA; Placed in the PS Info for
+	 * packets to SRIO
+	 */
+	u32	sw_info_1;
+	/* For CONTINUE_PARSE_LUT1/LUT2 only, specifies the custom type as
+	 * defined at @ref custom_type
+	 */
+	int	custom_type;
+	/* For CONTINUE_PARSE_LUT1/LUT2 only, specifies the custom
+	 * classification entry index
+	 */
+	u8	custom_index;
+	/* For destination SRIO, specify the 5-bit packet type toward SRIO
+	 * For destination HOST, EMAC, specify the EMAC control
+	 * emcOutputCtrlBits to the network
+	 */
+	u8	pkt_type_emac_ctrl;
+	/* Pointer to the Command info to be executed prior to the packet
+	 * forwarding. Note only the following commands are
+	 * supported within paRouteInfo_t
+	 *   - pa_CMD_PATCH_DATA (up to two bytes only) (LUT2 only)
+	 *   - pa_CMD_CMDSET
+	 *   - pa_CMD_USR_STATS
+	 *   - pa_CMD_CMDSET_AND_USR_STATS
+	 */
+	struct pa2_cmd_info *pcmd;
+	/* validBitMap[t3]: For Host only, specify priority-based and/or
+	 * interfcae-based routing mode as defined at paRoutePriIntf_e
+	 */
+	u8	priority_type;
+	/* For EFLOW only, egress flow operation info (PAGG Gen2 only) */
+	struct pa2_ef_op_info *ef_op;
+};
+
+struct pa2_cmd_reply {
+	/* Packet destination, must be pa_DEST_HOST or PA2_DEST_DISCARD, see
+	 * @ref pktDest
+	 */
+	int	dest;
+	/*  Value placed in swinfo0 in reply packet */
+	u32	reply_id;
+	/*  Destination queue for destination PA2_DEST_HOST */
+	u16	queue;
+	u8	flow_id;
+	/*  Flow ID used on command reply from PASS */
+};
+
+#endif /* KEYSTONE_PA2_FW_H */
diff --git a/drivers/net/ethernet/ti/netcp_pa2_host.h b/drivers/net/ethernet/ti/netcp_pa2_host.h
new file mode 100644
index 0000000..c73b155
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa2_host.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2012-2015 Texas Instruments Incorporated
+ * Authors:	Murali Karicheri (Ported to v4.1.x kernel)
+ *		Hao Zhang (PA2 Initial version of the driver)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef NETCP_PA2_HOST_H
+#define NETCP_PA2_HOST_H
+
+#include "netcp_pa_host.h"
+
+#define PAHO2_CONFIGURE		4
+
+#define PAHO2_PACFG_CMD	(((u32)PAHO2_CONFIGURE << 5) << 24)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PAHO2_CHKCRC_SET_CTRL(x, v) \
+	PAHO_SET_BITFIELD((x)->word0, (v), 16, 4)
+
+/* Sets the size of the crc in bytes */
+#define PAHO2_CHKCRC_SET_CRCSIZE(x, v) \
+	PAHO_SET_BITFIELD((x)->word0, (v), 8,  8)
+
+/* Sets the start offset of the checksum/crc */
+#define PAHO2_CHKCRC_SET_START(x, v) \
+	PAHO_SET_BITFIELD((x)->word0, (v), 0,  8)
+
+/* Sets the initial value of the 32-bit crc */
+#define PAHO2_CHKCRC_SET_INITVAL32(x, v)	(((x)->word2) = (v))
+
+#endif /* NETCP_PA2_HOST_H */
-- 
1.7.5.4

