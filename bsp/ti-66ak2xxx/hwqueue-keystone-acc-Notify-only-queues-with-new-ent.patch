From b2dfc339cfe5b5299337612d369549c5ef9e84f7 Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Tue, 17 Dec 2013 16:19:57 -0500
Subject: [PATCH 098/256] hwqueue: keystone: acc: Notify only queues with new
 entries

Prior to this patch, if any queue in a multi-queue accumulator range
received new entries ALL queues in the range were notified of new
data. This is horribly inefficient.

This patch keeps track of which queues received new entries and
notifies only these queues.

Also added a console notification if the circular buffer used by
accumulator queues fills and entries are discarded.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit e08fc39e63c6144689b748fd8c52e4dc56a8908c)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.h     |    1 +
 drivers/hwqueue/keystone_hwqueue_acc.c |   14 +++++++++++---
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.h b/drivers/hwqueue/keystone_hwqueue.h
index 413c48b..7e2650a 100644
--- a/drivers/hwqueue/keystone_hwqueue.h
+++ b/drivers/hwqueue/keystone_hwqueue.h
@@ -246,6 +246,7 @@ struct khwq_instance {
 	struct khwq_acc_channel	*acc;
 	struct khwq_region	*last; /* cache last region used */
 	struct khwq_qmgr_info	*qmgr; /* cache qmgr for the instance */
+	int			 notify_needed;
 	int			 irq_num; /*irq num -ve for non-irq queues */
 	char			 irq_name[32];
 };
diff --git a/drivers/hwqueue/keystone_hwqueue_acc.c b/drivers/hwqueue/keystone_hwqueue_acc.c
index bf7d963..4ebcee7 100644
--- a/drivers/hwqueue/keystone_hwqueue_acc.c
+++ b/drivers/hwqueue/keystone_hwqueue_acc.c
@@ -40,6 +40,7 @@ static void __khwq_acc_notify(struct khwq_range_info *range,
 	struct khwq_device *kdev = range->kdev;
 	struct hwqueue_device *hdev = to_hdev(kdev);
 	struct hwqueue_instance *inst;
+	struct khwq_instance *kq;
 	int range_base, queue;
 
 	range_base = kdev->base_id + range->queue_base;
@@ -47,9 +48,13 @@ static void __khwq_acc_notify(struct khwq_range_info *range,
 	if (range->flags & RANGE_MULTI_QUEUE) {
 		for (queue = 0; queue < range->num_queues; queue++) {
 			inst = hwqueue_id_to_inst(hdev, range_base + queue);
-			dev_dbg(kdev->dev, "acc-irq: notifying %d\n",
-				range_base + queue);
-			hwqueue_notify(inst);
+			kq = hwqueue_inst_to_priv(inst);
+			if (kq->notify_needed) {
+				kq->notify_needed = 0;
+				dev_dbg(kdev->dev, "acc-irq: notifying %d\n",
+					range_base + queue);
+				hwqueue_notify(inst);
+			}
 		}
 	} else {
 		queue = acc->channel - range->acc_info.start_channel;
@@ -183,12 +188,15 @@ static irqreturn_t khwq_acc_int_handler(int irq, void *_instdata)
 
 		if (atomic_inc_return(&kq->desc_count) >= ACC_DESCS_MAX) {
 			atomic_dec(&kq->desc_count);
+			dev_err(kdev->dev, "acc-irq: queue %d full"
+				", entry dropped\n", queue + range_base);
 			/* TODO: need a statistics counter for such drops */
 			continue;
 		}
 
 		idx = atomic_inc_return(&kq->desc_tail) & ACC_DESCS_MASK;
 		kq->descs[idx] = val;
+		kq->notify_needed = 1;
 		dev_dbg(kdev->dev, "acc-irq: enqueue %08x at %d, queue %d\n",
 			val, idx, queue + range_base);
 	}
-- 
1.7.5.4

