From 0653badb9e9226bac8b1d0c7161fe48e993e240e Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Mon, 9 Jun 2014 12:18:42 -0400
Subject: [PATCH 151/256] spi: davinci: add support to configure GPIO CS
 through DT

Currently driver supports only configuration of GPIO CS through
platform data. This patch enhances the driver to configure GPIO
CS through DT. Also update the DT binding documentation to
reflect the availability of cs-gpios.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit e883a261695d5fcb6c30b3368ea2ffd0c7d954ca)

Conflicts:
	Documentation/devicetree/bindings/spi/spi-davinci.txt
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/spi/spi-davinci.txt        |    9 +++-
 drivers/spi/spi-davinci.c                          |   66 ++++++++++++++------
 2 files changed, 55 insertions(+), 20 deletions(-)

diff --git a/Documentation/devicetree/bindings/spi/spi-davinci.txt b/Documentation/devicetree/bindings/spi/spi-davinci.txt
index f00d841..f6ce221 100644
--- a/Documentation/devicetree/bindings/spi/spi-davinci.txt
+++ b/Documentation/devicetree/bindings/spi/spi-davinci.txt
@@ -8,7 +8,8 @@ Required properties:
 	- "ti,davinci-spi-v1" for SPI version 1.0
 	- "ti,davinci-spi-v2" for SPI version 2.0
 - reg: Offset and length of SPI controller register space
-- num-cs: Number of chip selects
+- ti,davinci-spi-num-cs: Number of chip selects. This includes
+	internal as well as GPIO chip selects.
 - ti,davinci-spi-intr-line: interrupt line used to connect the SPI
 	IP to the interrupt controller within the SoC. Possible values
 	are 0 and 1. Manual says one of the two possible interrupt
@@ -17,6 +18,12 @@ Required properties:
 - interrupts: interrupt number offset at the irq parent
 - clocks: spi clk phandle
 
+Optional:
+- cs-gpios: gpio chip selects
+	For example to have 3 internal CS and 2 GPIO CS, user could define
+	cs-gpios = <0>, <0>, <0>, <&gpio1 30 0>, <&gpio1 31 0>;
+	where first three are internal CS and last two are GPIO CS.
+
 Example of a NOR flash slave device (n25q032) connected to DaVinci
 SPI controller device over the SPI bus.
 
diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c
index 96a7a93..8e1f4dd 100644
--- a/drivers/spi/spi-davinci.c
+++ b/drivers/spi/spi-davinci.c
@@ -31,6 +31,7 @@
 #include <linux/of.h>
 #include <linux/of_irq.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
 #include <linux/slab.h>
@@ -209,18 +210,33 @@ static inline void clear_io_bits(void __iomem *addr, u32 bits)
 static void davinci_spi_chipselect(struct spi_device *spi, int value)
 {
 	struct davinci_spi_config *spicfg = spi->controller_data;
+	struct device_node *np = spi->dev.of_node;
 	struct davinci_spi_platform_data *pdata;
+	struct spi_master *master = spi->master;
 	u8 chip_sel = spi->chip_select;
 	bool gpio_chipsel = false;
 	struct davinci_spi *dspi;
 	u16 spidat1 = CS_DEFAULT;
+	int gpio;
 
 	dspi = spi_master_get_devdata(spi->master);
 	pdata = &dspi->pdata;
 
-	if (pdata->chip_sel && chip_sel < pdata->num_chipselect &&
-				pdata->chip_sel[chip_sel] != SPI_INTERN_CS)
+	if (np && master->cs_gpios != NULL && spi->cs_gpio >= 0) {
+		/* SPI core parse and update master->cs_gpio */
+		gpio_chipsel = true;
+		gpio = spi->cs_gpio;
+	} else if (pdata->chip_sel &&
+		   chip_sel < pdata->num_chipselect &&
+		   pdata->chip_sel[chip_sel] != SPI_INTERN_CS) {
+		/* platform data defines chip_sel */
 		gpio_chipsel = true;
+		gpio = pdata->chip_sel[chip_sel];
+	}
+
+	/* program delay tansfers if tx_delay is non zero */
+	if (spicfg->wdelay)
+		spidat1 |= SPIDAT1_WDEL;
 
 	/*
 	 * Board specific chip select logic decides the polarity and cs
@@ -228,22 +244,16 @@ static void davinci_spi_chipselect(struct spi_device *spi, int value)
 	 */
 	if (gpio_chipsel) {
 		if (value == BITBANG_CS_ACTIVE)
-			gpio_set_value(pdata->chip_sel[chip_sel], 0);
+			gpio_set_value(gpio, 0);
 		else
-			gpio_set_value(pdata->chip_sel[chip_sel], 1);
+			gpio_set_value(gpio, 1);
 	} else {
-
-		/* program delay tansfers if tx_delay is non zero */
-		if (spicfg->wdelay)
-			spidat1 |= SPIDAT1_WDEL;
-
 		if (value == BITBANG_CS_ACTIVE) {
 			spidat1 |= SPIDAT1_CSHOLD_MASK;
 			spidat1 &= ~(0x1 << chip_sel);
 		}
-
-		iowrite16(spidat1, dspi->base + SPIDAT1 + 2);
 	}
+	iowrite16(spidat1, dspi->base + SPIDAT1 + 2);
 }
 
 /**
@@ -419,20 +429,37 @@ static int davinci_spi_setup(struct spi_device *spi)
 	struct davinci_spi_config *spicfg = spi->controller_data;
 	struct device_node *np = spi->dev.of_node;
 	struct davinci_spi_platform_data *pdata;
-	struct davinci_spi *dspi;
+	struct spi_master *master = spi->master;
 	int retval = 0, len;
+	struct davinci_spi *dspi;
+	bool internal_cs = true;
 	u32 prop;
 
 	dspi = spi_master_get_devdata(spi->master);
 	pdata = &dspi->pdata;
 
 	if (!(spi->mode & SPI_NO_CS)) {
-		if ((pdata->chip_sel == NULL) ||
-		    (pdata->chip_sel[spi->chip_select] == SPI_INTERN_CS))
-			set_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);
-
+		if (np && (master->cs_gpios != NULL) &&
+		    (spi->cs_gpio >= 0)) {
+			retval = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
+			if (retval) {
+				dev_err(&spi->dev,
+					"GPIO %d request failed\n", spi->cs_gpio);
+				return -ENODEV;
+			}
+			gpio_direction_output(spi->cs_gpio,
+					      !(spi->mode & SPI_CS_HIGH));
+			internal_cs = false;
+		} else if (pdata->chip_sel &&
+			   spi->chip_select < pdata->num_chipselect &&
+			   pdata->chip_sel[spi->chip_select] != SPI_INTERN_CS) {
+			internal_cs = false;
+		}
 	}
 
+	if (internal_cs)
+		set_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);
+
 	if (spi->mode & SPI_READY)
 		set_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);
 
@@ -871,8 +898,8 @@ static int spi_davinci_get_pdata(struct platform_device *pdev,
 {
 	struct device_node *node = pdev->dev.of_node;
 	struct davinci_spi_platform_data *pdata;
-	unsigned int num_cs, intr_line = 0;
 	const struct of_device_id *match;
+	unsigned int num_cs, intr_line = 0;
 
 	pdata = &dspi->pdata;
 
@@ -888,8 +915,9 @@ static int spi_davinci_get_pdata(struct platform_device *pdev,
 
 	/*
 	 * default num_cs is 1 and all chipsel are internal to the chip
-	 * indicated by chip_sel being NULL. GPIO based CS is not
-	 * supported yet in DT bindings.
+	 * indicated by chip_sel being NULL or cs_gpios being NULL or
+	 * set to -ENOENT. davinci-spi-num-cs includes internal as well
+	 * as gpios.
 	 */
 	num_cs = 1;
 	of_property_read_u32(node, "ti,davinci-spi-num-cs", &num_cs);
-- 
1.7.5.4

