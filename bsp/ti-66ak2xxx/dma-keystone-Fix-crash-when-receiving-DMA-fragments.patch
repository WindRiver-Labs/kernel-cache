From 0cfe556255dbaee052a0b3fc857ffa0adebc574d Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Thu, 25 Apr 2013 16:24:44 -0400
Subject: [PATCH 050/256] dma: keystone: Fix crash when receiving DMA
 fragments

The underlying bug is an incomplete replacement of virtual/dma address
conversions in drivers/dma/keystone-pktdma.c:chan_complete()

The Appleton kernel (3.3) used phys_to_page() while filling in the scatterlist
entries. This doesn't work on the Keystone due to the weird address mappings.
There isn't a direct replacement for phys_to_page(), so this patch creates a
macro called dma_to_page(), which invokes the proper series of lesser functions.

Unfortunately, the dma_to_pfn() function wants a pointer to a "struct device",
probably so it can apply the proper address translation, but the struct device
used for the page_to_phys() mapping used a higher layer's struct that we don't
have access to. Currently this parameter isn't used, so we can get away with
providing a bogus address. NULL is specifically chosen here so that if this
parameter starts to be used we'll get an immediate crash, rather than some non-
obvious behavior.

Yes, it's a hack. Yes, it should be done a different way. If you have a
constructive suggestion, make it known.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 9768446cfe1225e8356dc09e7fc258758d3d6ffb)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/keystone-pktdma.c |   15 ++++++++++++++-
 1 files changed, 14 insertions(+), 1 deletions(-)

diff --git a/drivers/dma/keystone-pktdma.c b/drivers/dma/keystone-pktdma.c
index 804f77b..492c5b2 100644
--- a/drivers/dma/keystone-pktdma.c
+++ b/drivers/dma/keystone-pktdma.c
@@ -543,6 +543,19 @@ static bool chan_should_process(struct keystone_dma_chan *chan, bool in_poll)
 	return (state == CHAN_STATE_OPENED || state == CHAN_STATE_CLOSING);
 }
 
+/*
+ *  FIXME: This is a nasty hack to work around a layering problem:
+ *  dma_to_pfn() needs a pointer to the struct device, but as currently
+ *  implemented that's an upper layer's device, not the dma device. We
+ *  don't have access to that data. This hack works because dma_to_pfn()
+ *  doesn't currently use the device pointer. I've deliberately used NULL
+ *  here to cause an immediate exception if/when that changes, at which
+ *  point someone will have to come up with a proper fix. One option is
+ *  to just set the sg_dma_address and let the upper layer fill in the
+ *  rest of the scatterlist fields. -rrp
+ */
+#define dma_to_page(dma) (pfn_to_page(dma_to_pfn(NULL,(dma))))
+
 static int chan_complete(struct keystone_dma_chan *chan, struct hwqueue *queue,
 			 enum dma_status status, int budget, bool in_poll)
 {
@@ -624,7 +637,7 @@ static int chan_complete(struct keystone_dma_chan *chan, struct hwqueue *queue,
 				atomic_inc(&chan->rxpools[q_num].deficit);
 
 				if (sg_retlen < chan->scatterlist_size) {
-					sg_set_page(sg, phys_to_page(bufaddr), buflen,
+					sg_set_page(sg, dma_to_page(bufaddr), buflen,
 							offset_in_page(bufaddr));
 					sg_dma_address(sg) = bufaddr;
 					accum_size += buflen;
-- 
1.7.5.4

