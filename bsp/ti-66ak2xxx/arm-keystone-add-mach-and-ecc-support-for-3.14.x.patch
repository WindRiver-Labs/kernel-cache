From 9b91f5806119e640f6ab1b7c152e3002584e9fb8 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 5 May 2015 21:53:41 +0800
Subject: [PATCH 007/256] arm: keystone: add mach and ecc support for 3.14.x

This patch comes from:
  git://git.ti.com/keystone-linux/linux.git

Signed-off-by:Zumeng Chen <zumeng.chen@windriver.com>

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-keystone/keystone.c     |  294 ++++++++++++++++++++++++++++++---
 arch/arm/mach-keystone/keystone.h     |   21 ++-
 arch/arm/mach-keystone/keystone_ecc.c |   85 ++++++++++
 3 files changed, 369 insertions(+), 31 deletions(-)
 create mode 100644 arch/arm/mach-keystone/keystone_ecc.c

diff --git a/arch/arm/mach-keystone/keystone.c b/arch/arm/mach-keystone/keystone.c
index 6e6bb7d..4581dce 100644
--- a/arch/arm/mach-keystone/keystone.c
+++ b/arch/arm/mach-keystone/keystone.c
@@ -1,19 +1,34 @@
 /*
- * Keystone2 based boards and SOC related code.
- *
- * Copyright 2013 Texas Instruments, Inc.
- *	Cyril Chemparathy <cyril@ti.com>
- *	Santosh Shilimkar <santosh.shillimkar@ti.com>
+ * Copyright 2010-2014 Texas Instruments, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
  */
 #include <linux/io.h>
 #include <linux/of.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/clocksource.h>
+#include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/of_address.h>
+#include <linux/irqchip/arm-gic.h>
+#include <linux/dma-mapping.h>
+#include <linux/irqchip/keystone-ipc.h>
+#include <linux/irqchip.h>
+#include <linux/platform_data/davinci-clock.h>
+#include <linux/reboot.h>
+#include <linux/signal.h>
 
 #include <asm/setup.h>
 #include <asm/mach/map.h>
@@ -26,46 +41,269 @@
 #define PLL_RESET_WRITE_KEY_MASK		0xffff0000
 #define PLL_RESET_WRITE_KEY			0x5a69
 #define PLL_RESET				BIT(16)
+#define RSTMUX8_OMODE_DEVICE_RESET		5
+#define RSTMUX8_OMODE_DEVICE_RESET_SHIFT	1
+#define RSTMUX8_OMODE_DEVICE_RESET_MASK		(BIT(1) | BIT(2) | BIT(3))
+#define RSTMUX8_LOCK_MASK			BIT(0)
 
-static void __iomem *keystone_rstctrl;
+
+unsigned long __arch_dma_pfn_offset;
+
+#ifdef CONFIG_ZONE_DMA
+extern phys_addr_t arm_dma_limit;
+extern unsigned long arm_dma_zone_size;
+#endif
+
+static struct map_desc io_desc[] = {
+	{
+		.virtual        = 0xfe600000UL,
+		.pfn            = __phys_to_pfn(0x02000000UL),
+		.length         = 0x800000UL,
+		.type           = MT_DEVICE
+	},
+};
+
+static void __init keystone_map_io(void)
+{
+	iotable_init(io_desc, ARRAY_SIZE(io_desc));
+}
+
+static void __init keystone_timer_init(void)
+{
+	davinci_of_clk_init();
+	clocksource_of_init();
+}
+
+static bool is_coherent(struct device *dev)
+{
+	struct device_node *node = of_node_get(dev->of_node);
+
+	while (node) {
+		if (of_property_read_bool(node, "dma-coherent")) {
+			of_node_put(node);
+			return true;
+		}
+		node = of_get_next_parent(node);
+	}
+	return false;
+}
+
+static bool ignore_first = true;
+static int keystone_async_ext_abort_fault(unsigned long addr, unsigned int fsr,
+					  struct pt_regs *regs)
+{
+	/*
+	 * if first time, ignore this as this seems to be a spurious one
+	 * happening on some devices and we add this work around to handle
+	 * this first time when kernel switch to handle user space
+	 */
+	if (ignore_first) {
+		ignore_first = false;
+		return 0;
+	}
+
+	/* Subsequent ones should be handled as fault */
+	return 1;
+}
+
+static int keystone_platform_notifier(struct notifier_block *nb,
+				      unsigned long event, void *_dev)
+{
+	struct device *dev = _dev;
+
+	if (event == BUS_NOTIFY_ADD_DEVICE) {
+		dev->dma_mask = kmalloc(sizeof(*dev->dma_mask), GFP_KERNEL);
+		dev->coherent_dma_mask = arm_dma_limit;
+		if (dev->dma_mask)
+			*dev->dma_mask = arm_dma_limit;
+		if (is_coherent(dev))
+			set_dma_ops(dev, &arm_coherent_dma_ops);
+		return NOTIFY_OK;
+	} else if (event == BUS_NOTIFY_DEL_DEVICE) {
+		kfree(dev->dma_mask);
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block keystone_platform_nb;
+
+static struct of_device_id keystone_dt_match_table[] __initdata = {
+	{ .compatible = "simple-bus",},
+	{ .compatible = "ti,davinci-aemif", },
+	{}
+};
 
 static void __init keystone_init(void)
 {
-	struct device_node *node;
+	if (keystone_platform_nb.notifier_call)
+		bus_register_notifier(&platform_bus_type, &keystone_platform_nb);
+
+	keystone_pm_runtime_init();
+	of_platform_populate(NULL, keystone_dt_match_table, NULL, NULL);
+
+	/*
+	 * Add a one time exception handler to catch asynchronous external
+	 * abort when transitioning to use space
+	 */
+	hook_fault_code(17, keystone_async_ext_abort_fault, SIGBUS, 0,
+			"async external abort handler");
+}
+
+#define L2_INTERN_ASYNC_ERROR	BIT(30)
+
+static irqreturn_t arm_l1l2_ecc_err_irq_handler(int irq, void *reg_virt)
+{
+	int ret = IRQ_NONE;
+	u32 status, fault;
+
+	/* read and clear L2ECTLR CP15 register for L2 ECC error */
+	asm("mrc p15, 1, %0, c9, c0, 3" : "=r"(status));
 
+	if (status & L2_INTERN_ASYNC_ERROR) {
+		status &= ~L2_INTERN_ASYNC_ERROR;
+		asm("mcr p15, 1, %0, c9, c0, 3" : : "r" (status));
+		asm("mcr p15, 0, %0, c5, c1, 0" : "=r" (fault));
+		/*
+		 * Do a machine restart as this is double bit ECC error
+		 * that can't be corrected
+		 */
+		pr_err("ARM Cortex A15 L1/L2 ECC error, CP15 ADFSR 0x%x\n",
+			fault);
+		machine_restart(NULL);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+static int __init keystone_init_misc(void)
+{
+	struct device_node *node = NULL;
+	void __iomem *rstmux8;
+	int error_irq = 0;
+	u32 val;
+	int ret;
+
+	/*
+	 * For WD reset to function, rstmux8 should be configured
+	 * so that this will trigger a device reset.
+	 */
 	node = of_find_compatible_node(NULL, NULL, "ti,keystone-reset");
-	if (WARN_ON(!node))
-		pr_warn("ti,keystone-reset node undefined\n");
+	if (!node) {
+		pr_warn("ti, keystone-reset node undefined\n");
+		return -EINVAL;
+	}
 
-	keystone_rstctrl = of_iomap(node, 0);
-	if (WARN_ON(!keystone_rstctrl))
-		pr_warn("ti,keystone-reset iomap error\n");
+	/* rstmux8 address is configured in the rstctrl node at index 1 */
+	rstmux8 = of_iomap(node, 1);
+	if (WARN_ON(!rstmux8)) {
+		pr_warn("rstmux8 iomap error\n");
+		return -ENODEV;
+	}
 
-	keystone_pm_runtime_init();
-	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+	val = __raw_readl(rstmux8) & ~RSTMUX8_OMODE_DEVICE_RESET_MASK;
+	if (!(val & RSTMUX8_LOCK_MASK)) {
+		val |= (RSTMUX8_OMODE_DEVICE_RESET <<
+				RSTMUX8_OMODE_DEVICE_RESET_SHIFT);
+		__raw_writel(val, rstmux8);
+	}
+	iounmap(rstmux8);
+
+	/* add ARM ECC L1/L2 cache error handler */
+	node = of_find_compatible_node(NULL, NULL, "ti,keystone-sys");
+	if (node)
+		error_irq = irq_of_parse_and_map(node, 0);
+	if (!error_irq) {
+		pr_warn("Warning!! arm L1/L2 ECC irq number not defined\n");
+		return 0;
+	}
+	if (request_irq(error_irq, arm_l1l2_ecc_err_irq_handler, 0,
+		"a15-l1l2-ecc-err-irq", 0) < 0) {
+		WARN_ON("request_irq fail for arm L1/L2 ECC error irq\n");
+	}
+
+	ret = keystone_init_ddr3_ecc(node);
+	return ret;
 }
+postcore_initcall(keystone_init_misc);
 
-static const char *keystone_match[] __initconst = {
+static const char *keystone2_match[] __initconst = {
 	"ti,keystone-evm",
+	"ti,keystone",
+	"ti,k2e-evm",
 	NULL,
 };
 
+static void __init keystone_init_meminfo(void)
+{
+	bool lpae = IS_ENABLED(CONFIG_ARM_LPAE);
+	bool pvpatch = IS_ENABLED(CONFIG_ARM_PATCH_PHYS_VIRT);
+	phys_addr_t offset = PHYS_OFFSET - KEYSTONE_LOW_PHYS_START;
+	phys_addr_t mem_start, mem_end;
+
+	BUG_ON(meminfo.nr_banks < 1);
+	mem_start = meminfo.bank[0].start;
+	mem_end = mem_start + meminfo.bank[0].size - 1;
+
+	/* nothing to do if we are running out of the <32-bit space */
+	if (mem_start >= KEYSTONE_LOW_PHYS_START &&
+	    mem_end   <= KEYSTONE_LOW_PHYS_END)
+		return;
+
+	if (!lpae || !pvpatch) {
+		panic("Enable %s%s%s to run outside 32-bit space\n",
+		      !lpae ? __stringify(CONFIG_ARM_LPAE) : "",
+		      (!lpae && !pvpatch) ? " and " : "",
+		      !pvpatch ? __stringify(CONFIG_ARM_PATCH_PHYS_VIRT) : "");
+	}
+
+	if (mem_start < KEYSTONE_HIGH_PHYS_START ||
+	    mem_end   > KEYSTONE_HIGH_PHYS_END) {
+		panic("Invalid address space for memory (%08llx-%08llx)\n",
+		      (u64)mem_start, (u64)mem_end);
+	}
+
+	offset += KEYSTONE_HIGH_PHYS_START;
+	pr_info("switching to high address space at 0x%llx\n", (u64)offset);
+	__pv_phys_offset = offset;
+	__pv_offset      = offset - PAGE_OFFSET;
+
+	__arch_dma_pfn_offset = PFN_DOWN(KEYSTONE_HIGH_PHYS_START -
+					 KEYSTONE_LOW_PHYS_START);
+#ifdef CONFIG_ZONE_DMA
+	arm_dma_limit = __pv_phys_offset + arm_dma_zone_size - 1;
+	keystone_platform_nb.notifier_call = keystone_platform_notifier;
+#endif
+}
+
 void keystone_restart(enum reboot_mode mode, const char *cmd)
 {
+	struct device_node *node;
+	void __iomem *rstctrl;
 	u32 val;
 
-	BUG_ON(!keystone_rstctrl);
+	node = of_find_compatible_node(NULL, NULL, "ti,keystone-reset");
+	if (WARN_ON(!node)) {
+		pr_warn("ti, keystone-reset node undefined\n");
+		return;
+	}
+
+	rstctrl = of_iomap(node, 0);
+	if (WARN_ON(!rstctrl)) {
+		pr_warn("ti, pllctrl-reset iomap error\n");
+		return;
+	}
 
 	/* Enable write access to RSTCTRL */
-	val = readl(keystone_rstctrl);
+	val = __raw_readl(rstctrl);
 	val &= PLL_RESET_WRITE_KEY_MASK;
 	val |= PLL_RESET_WRITE_KEY;
-	writel(val, keystone_rstctrl);
+	writel(val, rstctrl);
 
 	/* Reset the SOC */
-	val = readl(keystone_rstctrl);
+	val = readl(rstctrl);
 	val &= ~PLL_RESET;
-	writel(val, keystone_rstctrl);
+	writel(val, rstctrl);
 }
 
 DT_MACHINE_START(KEYSTONE, "Keystone")
@@ -74,6 +312,20 @@ DT_MACHINE_START(KEYSTONE, "Keystone")
 #endif
 	.smp		= smp_ops(keystone_smp_ops),
 	.init_machine	= keystone_init,
-	.dt_compat	= keystone_match,
+	.dt_compat	= keystone2_match,
+	.restart	= keystone_restart,
+MACHINE_END
+
+DT_MACHINE_START(KEYSTONE2, "KeyStone2")
+	.map_io		= keystone_map_io,
+	.init_irq	= irqchip_init,
+	.init_time	= keystone_timer_init,
+	.init_machine	= keystone_init,
+	.init_meminfo	= keystone_init_meminfo,
 	.restart	= keystone_restart,
+	.smp		= smp_ops(keystone_smp_ops),
+	.dt_compat	= keystone2_match,
+#ifdef CONFIG_ZONE_DMA
+	.dma_zone_size	= SZ_2G,
+#endif
 MACHINE_END
diff --git a/arch/arm/mach-keystone/keystone.h b/arch/arm/mach-keystone/keystone.h
index cd04a1c..0aa8c89 100644
--- a/arch/arm/mach-keystone/keystone.h
+++ b/arch/arm/mach-keystone/keystone.h
@@ -1,24 +1,25 @@
 /*
- * Copyright 2013 Texas Instruments, Inc.
- *	Cyril Chemparathy <cyril@ti.com>
- *	Santosh Shilimkar <santosh.shillimkar@ti.com>
+ * Copyright 2010-2012 Texas Instruments, Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms and conditions of the GNU General Public License,
  * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef __KEYSTONE_H__
 #define __KEYSTONE_H__
 
-#define KEYSTONE_MON_CPU_UP_IDX		0x00
-
-#ifndef __ASSEMBLER__
-
 extern struct smp_operations keystone_smp_ops;
 extern void secondary_startup(void);
-extern u32 keystone_cpu_smc(u32 command, u32 cpu, u32 addr);
-extern int keystone_pm_runtime_init(void);
+extern int __init keystone_pm_runtime_init(void);
+extern int keystone_init_ddr3_ecc(struct device_node *node);
 
-#endif /* __ASSEMBLER__ */
 #endif /* __KEYSTONE_H__ */
diff --git a/arch/arm/mach-keystone/keystone_ecc.c b/arch/arm/mach-keystone/keystone_ecc.c
new file mode 100644
index 0000000..0243ba0
--- /dev/null
+++ b/arch/arm/mach-keystone/keystone_ecc.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2014 Texas Instruments, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/reboot.h>
+#include "keystone.h"
+
+/* DDR3 controller registers */
+#define DDR3_EOI			0x0A0
+#define DDR3_IRQ_STATUS_RAW_SYS		0x0A4
+#define DDR3_IRQ_STATUS_SYS		0x0AC
+#define DDR3_IRQ_ENABLE_SET_SYS		0x0B4
+#define DDR3_IRQ_ENABLE_CLR_SYS		0x0BC
+#define DDR3_ECC_CTRL			0x110
+#define DDR3_ONE_BIT_ECC_ERR_CNT	0x130
+
+#define DDR3_1B_ECC_ERR			BIT(5)
+#define DDR3_2B_ECC_ERR			BIT(4)
+#define DDR3_WR_ECC_ERR			BIT(3)
+
+static irqreturn_t ddr3_ecc_err_irq_handler(int irq, void *reg_virt)
+{
+	int ret = IRQ_NONE;
+	u32 irq_status;
+	void __iomem *ddr_reg = (void __iomem *)reg_virt;
+
+	irq_status = readl(ddr_reg + DDR3_IRQ_STATUS_SYS);
+	if ((irq_status & DDR3_2B_ECC_ERR) ||
+	    (irq_status & DDR3_WR_ECC_ERR)) {
+		pr_err("Unrecoverable DDR3 ECC error, irq status 0x%x, "
+		       "rebooting kernel ..\n", irq_status);
+		machine_restart(NULL);
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
+int keystone_init_ddr3_ecc(struct device_node *node)
+{
+	void __iomem *ddr_reg;
+	int error_irq = 0;
+	int ret;
+
+	/* ddr3 controller reg is configured in the sysctrl node at index 0 */
+	ddr_reg = of_iomap(node, 0);
+	if (!ddr_reg) {
+		pr_warn("Warning!! DDR3 controller regs not defined\n");
+		return -ENODEV;
+	}
+
+	/* add DDR3 ECC error handler */
+	error_irq = irq_of_parse_and_map(node, 1);
+	if (!error_irq) {
+		/* No GIC interrupt, need to map CIC2 interupt to GIC */
+		pr_warn("Warning!! DDR3 ECC irq number not defined\n");
+		return -ENODEV;
+	}
+
+	ret = request_irq(error_irq, ddr3_ecc_err_irq_handler, 0,
+		"ddr3-ecc-err-irq", (void *)ddr_reg);
+	if (ret) {
+		WARN_ON("request_irq fail for DDR3 ECC error irq\n");
+		return ret;
+	}
+
+	return 0;
+}
-- 
1.7.5.4

