From 5830fb2ed7ae923ceb927a6a25e2f58c463d480e Mon Sep 17 00:00:00 2001
From: Sandeep Paulraj <s-paulraj@ti.com>
Date: Thu, 14 Feb 2013 15:59:29 -0500
Subject: [PATCH 087/256] hwqueue: keystone: fix queue id calculation

Each queue has an id associated with it. However, we need
to have the ability to index into a queue manager.
This commit appropriately calculates the id.

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
(cherry picked from commit 6600e8613100f41af00002b1668374cd653331e6)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.c |   20 ++++++++++++--------
 1 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.c b/drivers/hwqueue/keystone_hwqueue.c
index 3227255..167729a 100644
--- a/drivers/hwqueue/keystone_hwqueue.c
+++ b/drivers/hwqueue/keystone_hwqueue.c
@@ -219,15 +219,17 @@ static int khwq_push(struct hwqueue_instance *inst, dma_addr_t dma,
 		     unsigned size, unsigned flags)
 {
 	struct khwq_device *kdev = from_hdev(inst->hdev);
-	unsigned id = hwqueue_inst_to_id(inst);
 	struct khwq_qmgr_info *qmgr;
 	unsigned long irq_flags;
+	unsigned id;
 	u32 val;
 
 	qmgr = khwq_find_qmgr(inst);
 	if (!qmgr)
 		return -ENODEV;
 
+	id = hwqueue_inst_to_id(inst) - qmgr->start_queue;
+
 	spin_lock_irqsave(&kdev->lock, irq_flags);
 
 	if (flags & HWQUEUE_HAS_PACKET_SIZE)
@@ -248,20 +250,21 @@ static dma_addr_t khwq_pop(struct hwqueue_instance *inst, unsigned *size,
 {
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
 	struct khwq_device *kdev = from_hdev(inst->hdev);
-	unsigned id = hwqueue_inst_to_id(inst);
 	struct khwq_qmgr_info *qmgr;
 	u32 val, desc_size, idx;
 	dma_addr_t dma;
+	unsigned id;
 
 	qmgr = khwq_find_qmgr(inst);
 	if (unlikely(!qmgr))
 		return -ENODEV;
 
+	id = hwqueue_inst_to_id(inst) - qmgr->start_queue;
+
 	/* are we accumulated? */
 	if (kq->descs) {
 		if (unlikely(atomic_dec_return(&kq->desc_count) < 0)) {
 			atomic_inc(&kq->desc_count);
-			dev_dbg(kdev->dev, "acc-pop empty queue %d\n", id);
 			return 0;
 		}
 
@@ -269,9 +272,6 @@ static dma_addr_t khwq_pop(struct hwqueue_instance *inst, unsigned *size,
 		idx &= ACC_DESCS_MASK;
 
 		val = kq->descs[idx];
-
-		dev_dbg(kdev->dev, "acc-pop %08x (at %d) from queue %d\n",
-			val, idx, id);
 	} else {
 		val = __raw_readl(&qmgr->reg_pop[id].ptr_size_thresh);
 		if (unlikely(!val))
@@ -290,13 +290,15 @@ static dma_addr_t khwq_pop(struct hwqueue_instance *inst, unsigned *size,
 static int khwq_get_count(struct hwqueue_instance *inst)
 {
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
-	unsigned id = hwqueue_inst_to_id(inst);
 	struct khwq_qmgr_info *qmgr;
+	unsigned id;
 
 	qmgr = khwq_find_qmgr(inst);
 	if (unlikely(!qmgr))
 		return -EINVAL;
 
+	id = hwqueue_inst_to_id(inst) - qmgr->start_queue;
+
 	return (__raw_readl(&qmgr->reg_peek[id].entry_count) +
 		atomic_read(&kq->desc_count));
 }
@@ -304,13 +306,15 @@ static int khwq_get_count(struct hwqueue_instance *inst)
 static int khwq_flush(struct hwqueue_instance *inst)
 {
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
-	unsigned id = hwqueue_inst_to_id(inst);
 	struct khwq_qmgr_info *qmgr;
+	unsigned id;
 
 	qmgr = khwq_find_qmgr(inst);
 	if (!qmgr)
 		return -ENODEV;
 
+	id = hwqueue_inst_to_id(inst) - qmgr->start_queue;
+
 	atomic_set(&kq->desc_count, 0);
 	__raw_writel(0, &qmgr->reg_push[id].ptr_size_thresh);
 	return 0;
-- 
1.7.5.4

