From 39bafbafa0a6e4be34e7a767a4dd2a2b744d32eb Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Fri, 24 Jan 2014 16:49:43 -0500
Subject: [PATCH 054/256] dma: keystone: Optimize copying and scatterlist
 updates

This patch changes the chan_prep() and chan_complete() functions
to minimize the copying of descriptor fields. Previously, the
PSINFO and EPIB buffers, if present, were copied to the descriptor
in chan_prep(), and copied back in chan_complete(). Now they're
copied in chan_prep() only for MEM-to-DEV channels, and in
chan_complete() only for DEV-to-MEM channels. Also, chan_complete()
touches the scatterlist only for DEV-to-MEM channels, and never
for MEM-to-DEV channels.

The effect of these changes is to allow DEV-to-MEM channels to
use non-persistent scatterlists and EPIB and PSINFO buffers, as
these are never referenced after chan_prep_slave_sg() returns.
This simplifies the design of the completion routine.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 58212d02025443f843319b27e2f67558ac91b3e1)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/keystone-pktdma.c |   61 ++++++++++++++++++++++++-----------------
 1 files changed, 36 insertions(+), 25 deletions(-)

diff --git a/drivers/dma/keystone-pktdma.c b/drivers/dma/keystone-pktdma.c
index 79a756b..ba63020 100644
--- a/drivers/dma/keystone-pktdma.c
+++ b/drivers/dma/keystone-pktdma.c
@@ -571,8 +571,9 @@ static int chan_complete(struct keystone_dma_chan *chan, struct hwqueue *queue,
 	int packets = 0;
 	dma_addr_t dma;
 	unsigned size;
-	unsigned sg_retlen;
-	unsigned packet_size, accum_size;
+	unsigned sg_retlen = 0;
+	unsigned packet_size = 0;
+	unsigned accum_size = 0;
 	u32 *data;
 	int len;
 
@@ -608,35 +609,42 @@ static int chan_complete(struct keystone_dma_chan *chan, struct hwqueue *queue,
 			  desc, hwdesc, hwqueue_get_id(queue));
 		hwdesc_dump(chan, hwdesc, "complete");
 
-		sg = desc->sg;
+		sg = NULL;
 		sg_retlen = 0;
+		packet_size = 0;
 		accum_size = 0;
-		packet_size = hwval_to_host(chan, hwdesc->desc_info) & BITS(22);
-
-		if (unlikely(desc->options & DMA_HAS_EPIB)) {
-			len  = sg_dma_len(sg) / sizeof(u32);
-			data = sg_virt(sg);
-			sg++;
-			sg_retlen++;
-			desc_copy(chan, data, hwdesc->epib, len);
-		}
 
-		if (unlikely(desc->options & DMA_HAS_PSINFO)) {
-			len  = sg_dma_len(sg) / sizeof(u32);
-			data = sg_virt(sg);
-			sg++;
-			sg_retlen++;
-			desc_copy(chan, data, hwdesc->psdata, len);
+		if (chan->direction == DMA_DEV_TO_MEM) {
+			sg = desc->sg;
+			packet_size = hwval_to_host(chan, hwdesc->desc_info) & BITS(22);
+
+			if (likely(desc->options & DMA_HAS_EPIB)) {
+				len  = sg_dma_len(sg) / sizeof(u32);
+				data = sg_virt(sg);
+				sg++;
+				sg_retlen++;
+				desc_copy(chan, data, hwdesc->epib, len);
+			}
+
+			if (likely(desc->options & DMA_HAS_PSINFO)) {
+				len  = sg_dma_len(sg) / sizeof(u32);
+				data = sg_virt(sg);
+				sg++;
+				sg_retlen++;
+				desc_copy(chan, data, hwdesc->psdata, len);
+			}
 		}
 
-		/* Populate the the scatterlist from the descriptors */
+		/* Process the completed descriptor chain */
 		for (;;) {
 			struct keystone_dma_desc *this_desc = desc_from_hwdesc(hwdesc);
-			unsigned buflen = hwval_to_host(chan, hwdesc->buff_len) & BITS(22);
-			dma_addr_t bufaddr = hwval_to_host(chan, hwdesc->buff);
-			unsigned q_num = hwval_to_host(chan, hwdesc->orig_len) >> 28;
 
+			/* Populate the the scatterlist from the descriptors */
 			if (chan->direction == DMA_DEV_TO_MEM) {
+				dma_addr_t bufaddr = hwval_to_host(chan, hwdesc->buff);
+				unsigned buflen = hwval_to_host(chan, hwdesc->buff_len) & BITS(22);
+				unsigned q_num = hwval_to_host(chan, hwdesc->orig_len) >> 28;
+
 				WARN((q_num >= chan->rxpool_count),
 						"Invalid q_num %d\n", q_num);
 				atomic_inc(&chan->rxpools[q_num].deficit);
@@ -652,8 +660,9 @@ static int chan_complete(struct keystone_dma_chan *chan, struct hwqueue *queue,
 						q_num, chan->rxpools[q_num].buffer_size,
 						desc_to_adesc(this_desc));
 				}
+
+				sg_retlen++;
 			}
-			sg_retlen++;
 
 			dma = hwval_to_host(chan, hwdesc->next_desc);
 
@@ -1625,8 +1634,10 @@ chan_prep_slave_sg(struct dma_chan *achan, struct scatterlist *_sg,
 		 * a Host Packet Descriptor. It has extra content.
 		 */
 		if (nsg == 1) {
-			desc_copy(chan, hwdesc->epib, epib, epiblen);
-			desc_copy(chan, hwdesc->psdata, psdata, pslen);
+			if (chan->direction == DMA_MEM_TO_DEV) {
+				desc_copy(chan, hwdesc->epib, epib, epiblen);
+				desc_copy(chan, hwdesc->psdata, psdata, pslen);
+			}
 			desc->size += (epiblen + pslen) * 4;
 		}
 
-- 
1.7.5.4

