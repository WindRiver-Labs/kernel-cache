From 3dc24b99d00ac7525af4494f5e4316ef3d703f74 Mon Sep 17 00:00:00 2001
From: Sandeep Paulraj <s-paulraj@ti.com>
Date: Tue, 20 Nov 2012 09:35:29 -0500
Subject: [PATCH 077/256] hwqueue: keystone: sysfs imlpementation for qos tree

This commit adds sysfs support for the qos tree

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
(cherry picked from commit 7445ffc568e8919418cd6e2d337f929eed33c9d2)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c |  344 +++++++++++++++++++++++++-------
 drivers/hwqueue/keystone_qos.h         |   12 +
 2 files changed, 283 insertions(+), 73 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index f550cd7..9662992 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -484,7 +484,7 @@ static int khwq_program_drop_policies(struct khwq_qos_info *info)
 {
 	struct khwq_device *kdev = info->kdev;
 	struct khwq_qos_drop_policy *policy;
-	int error;
+	int error = 0;
 
 	for_each_policy(info, policy) {
 		if (!policy->usecount && policy != info->default_drop_policy)
@@ -1369,6 +1369,25 @@ static ssize_t qnode_output_rate_show(struct khwq_qos_tree_node *qnode,
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->output_rate);
 }
 
+static ssize_t qnode_output_rate_store(struct khwq_qos_tree_node *qnode,
+				       const char *buf, size_t size)
+{
+	struct khwq_qos_info *info = qnode->info;
+	int error, field;
+
+	error = kstrtouint(buf, 0, &field);
+	if (error)
+		return error;
+	
+	qnode->output_rate = field;
+
+	khwq_qos_stop(info);
+
+	khwq_qos_start(info);
+
+	return size;
+}
+
 static ssize_t qnode_burst_size_show(struct khwq_qos_tree_node *qnode,
 					     char *buf)
 {
@@ -1378,12 +1397,50 @@ static ssize_t qnode_burst_size_show(struct khwq_qos_tree_node *qnode,
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->burst_size);
 }
 
+static ssize_t qnode_burst_size_store(struct khwq_qos_tree_node *qnode,
+				      const char *buf, size_t size)
+{
+	struct khwq_qos_info *info = qnode->info;
+	int error, field;
+
+	error = kstrtouint(buf, 0, &field);
+	if (error)
+		return error;
+	
+	qnode->burst_size = field;
+
+	khwq_qos_stop(info);
+
+	khwq_qos_start(info);
+
+	return size;
+}
+
 static ssize_t qnode_overhead_bytes_show(struct khwq_qos_tree_node *qnode,
 					     char *buf)
 {
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->overhead_bytes);
 }
 
+static ssize_t qnode_overhead_bytes_store(struct khwq_qos_tree_node *qnode,
+					  const char *buf, size_t size)
+{
+	struct khwq_qos_info *info = qnode->info;
+	int error, field;
+
+	error = kstrtouint(buf, 0, &field);
+	if (error)
+		return error;
+	
+	qnode->overhead_bytes = field;
+
+	khwq_qos_stop(info);
+
+	khwq_qos_start(info);
+
+	return size;
+}
+
 static ssize_t qnode_output_queue_show(struct khwq_qos_tree_node *qnode,
 					     char *buf)
 {
@@ -1393,6 +1450,66 @@ static ssize_t qnode_output_queue_show(struct khwq_qos_tree_node *qnode,
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->output_queue);
 }
 
+static ssize_t qnode_input_queues_show(struct khwq_qos_tree_node *qnode,
+					     char *buf)
+{
+	ssize_t l = 0;
+	int i;
+
+	for (i = 0; i < qnode->num_input_queues; i++)
+		if (qnode->input_queue[i].valid == true)
+			l += snprintf(buf + l, PAGE_SIZE - l, "%d ",
+					qnode->input_queue[i].queue);
+
+	l += snprintf(buf + l, PAGE_SIZE - l, "\n");
+
+	return l;
+}
+
+static ssize_t qnode_input_queues_store(struct khwq_qos_tree_node *qnode,
+					  const char *buf, size_t size)
+{
+	struct khwq_qos_info *info = qnode->info;
+	struct khwq_device *kdev = info->kdev;
+	int error, field, i;
+
+	error = kstrtoint(buf, 0, &field);
+	if (error)
+		return error;
+
+	if (field < 0) {
+		for (i = 0; i < QOS_MAX_INPUTS; i++) {
+			if (qnode->input_queue[i].queue == -field) {
+				qnode->input_queue[i].valid = false;
+				khwq_qos_free_drop_queue(kdev,
+					qnode->input_queue[i].drop_queue_idx);
+			}
+		}
+	} else {
+		error = khwq_qos_alloc_drop_queue(kdev, field);
+		if (error < 0) {
+		dev_err(kdev->dev,
+			"failed to alloc input queue %d on node %s\n",
+			field, qnode->name);
+			return error;
+		}
+		for (i = 0; i < QOS_MAX_INPUTS; i++) {
+			if (qnode->input_queue[i].valid == false) {
+				qnode->input_queue[i].drop_queue_idx = error;
+				qnode->input_queue[i].valid = true;
+				qnode->input_queue[i].queue = field;
+			}
+		}
+		qnode->num_input_queues++;
+	}
+
+	khwq_qos_stop(info);
+
+	khwq_qos_start(info);
+
+	return size;
+}
+
 struct khwq_qos_qnode_attribute {
 	struct attribute attr;
 	ssize_t (*show)(struct khwq_qos_tree_node *qnode, char *);
@@ -1410,27 +1527,50 @@ static KHWQ_QOS_QNODE_ATTR(drop_policy, S_IRUGO, qnode_drop_policy_show,
 			   NULL);
 static KHWQ_QOS_QNODE_ATTR(priority, S_IRUGO,
 			   qnode_priority_show, NULL);
-static KHWQ_QOS_QNODE_ATTR(output_queue, S_IRUGO, qnode_output_queue_show,
+static KHWQ_QOS_QNODE_ATTR(output_queue, S_IRUGO,
+			   qnode_output_queue_show,
 			   NULL);
-static KHWQ_QOS_QNODE_ATTR(weight, S_IRUGO|S_IWUSR,
+static KHWQ_QOS_QNODE_ATTR(weight, S_IRUGO,
 			   qnode_weight_show, NULL);
 static KHWQ_QOS_QNODE_ATTR(output_rate, S_IRUGO|S_IWUSR,
-			   qnode_output_rate_show, NULL);
+			   qnode_output_rate_show, qnode_output_rate_store);
 static KHWQ_QOS_QNODE_ATTR(burst_size, S_IRUGO|S_IWUSR,
-			   qnode_burst_size_show, NULL);
+			   qnode_burst_size_show, qnode_burst_size_store);
 static KHWQ_QOS_QNODE_ATTR(overhead_bytes, S_IRUGO|S_IWUSR,
 			   qnode_overhead_bytes_show,
-			   NULL);
+			   qnode_overhead_bytes_store);
+static KHWQ_QOS_QNODE_ATTR(input_queues, S_IRUGO|S_IWUSR,
+			   qnode_input_queues_show,
+			   qnode_input_queues_store);
 
-static struct attribute *khwq_qos_qnode_sysfs_attrs[] = {
+static struct attribute *khwq_qos_qnode_sysfs_default_attrs[] = {
+	&attr_qnode_output_rate.attr,
+	&attr_qnode_burst_size.attr,
+	&attr_qnode_overhead_bytes.attr,
+	&attr_qnode_output_queue.attr,
+	&attr_qnode_input_queues.attr,
+	NULL
+};
+
+static struct attribute *khwq_qos_qnode_sysfs_priority_attrs[] = {
 	&attr_qnode_stats_class.attr,
 	&attr_qnode_drop_policy.attr,
-	&attr_qnode_weight.attr,
 	&attr_qnode_priority.attr,
 	&attr_qnode_output_rate.attr,
 	&attr_qnode_burst_size.attr,
 	&attr_qnode_overhead_bytes.attr,
-	&attr_qnode_output_queue.attr,
+	&attr_qnode_input_queues.attr,
+	NULL
+};
+
+static struct attribute *khwq_qos_qnode_sysfs_wrr_attrs[] = {
+	&attr_qnode_stats_class.attr,
+	&attr_qnode_drop_policy.attr,
+	&attr_qnode_weight.attr,
+	&attr_qnode_output_rate.attr,
+	&attr_qnode_burst_size.attr,
+	&attr_qnode_overhead_bytes.attr,
+	&attr_qnode_input_queues.attr,
 	NULL
 };
 
@@ -1450,7 +1590,6 @@ static ssize_t khwq_qos_qnode_attr_show(struct kobject *kobj,
 	return qnode_attr->show(qnode, buf);
 }
 
-
 static ssize_t khwq_qos_qnode_attr_store(struct kobject *kobj,
 					  struct attribute *attr,
 					  const char *buf, size_t size)
@@ -1468,14 +1607,25 @@ static ssize_t khwq_qos_qnode_attr_store(struct kobject *kobj,
 	return qnode_attr->store(qnode, buf, size);
 }
 
-static const struct sysfs_ops khwq_qos_qnode_sysfs_ops = {
-	.show = khwq_qos_qnode_attr_show,
-	.store = khwq_qos_qnode_attr_store,
+static struct kobj_type khwq_qos_qnode_default_ktype = {
+	.sysfs_ops = &(struct sysfs_ops) {
+		.show = khwq_qos_qnode_attr_show,
+		.store = khwq_qos_qnode_attr_store},
+	.default_attrs = khwq_qos_qnode_sysfs_default_attrs,
+};
+
+static struct kobj_type khwq_qos_qnode_priority_ktype = {
+	.sysfs_ops = &(struct sysfs_ops) {
+		.show = khwq_qos_qnode_attr_show,
+		.store = khwq_qos_qnode_attr_store},
+	.default_attrs = khwq_qos_qnode_sysfs_priority_attrs,
 };
 
-static struct kobj_type khwq_qos_qnode_ktype = {
-	.sysfs_ops = &khwq_qos_qnode_sysfs_ops,
-	.default_attrs = khwq_qos_qnode_sysfs_attrs,
+static struct kobj_type khwq_qos_qnode_wrr_ktype = {
+	.sysfs_ops = &(struct sysfs_ops) {
+		.show = khwq_qos_qnode_attr_show,
+		.store = khwq_qos_qnode_attr_store},
+	.default_attrs = khwq_qos_qnode_sysfs_wrr_attrs,
 };
 
 static int khwq_qos_cmp(struct ktree_node *_a, struct ktree_node *_b,
@@ -1513,7 +1663,7 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	bool has_children;
 	const char *name;
 	struct kobject *parent_kobj;
-	u32 temp[2];
+	u32 temp[QOS_MAX_INPUTS];
 
 	/* first find out if we are a leaf node */
 	child = of_get_next_child(node, NULL);
@@ -1535,9 +1685,24 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	qnode->parent = parent;
 	qnode->name = node->name;
 
-	error = kobject_init_and_add(&qnode->kobj,
-				     &khwq_qos_qnode_ktype,
-				     parent_kobj, qnode->name);
+	if (!parent)
+		error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_default_ktype,
+					     parent_kobj, qnode->name);
+	else {
+		if (parent->type == QOS_NODE_PRIO)
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_priority_ktype,
+					     parent_kobj, qnode->name);
+		else if (parent->type == QOS_NODE_WRR)
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_wrr_ktype,
+					     parent_kobj, qnode->name);
+		else
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_default_ktype,
+					     parent_kobj, qnode->name);
+	}
 	if (error) {
 		dev_err(kdev->dev, "failed to create sysfs "
 			"entries for qnode %s\n", qnode->name);
@@ -1650,9 +1815,11 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 		qnode->output_queue);
 
 	qnode->overhead_bytes = parent ? parent->overhead_bytes : 24;
-	of_property_read_u32(node, "overhead-bytes", &qnode->overhead_bytes);
-	dev_dbg(kdev->dev, "node %s: overhead bytes %d\n", qnode->name,
-		qnode->overhead_bytes);
+	error = of_property_read_u32(node, "overhead-bytes",
+				     &qnode->overhead_bytes);
+	if (!error)
+		dev_dbg(kdev->dev, "node %s: overhead bytes %d\n", qnode->name,
+			qnode->overhead_bytes);
 
 	error = of_property_read_string(node, "drop-policy", &name);
 	if (!error) {
@@ -1728,14 +1895,14 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 
 	if (of_find_property(node, "input-queues", &length)) {
 		qnode->num_input_queues = length / sizeof(u32);
-		if (qnode->num_input_queues >= ARRAY_SIZE(qnode->input_queues)) {
+		if (qnode->num_input_queues >= QOS_MAX_INPUTS) {
 			dev_err(kdev->dev, "too many input_queues to node %s\n",
 				qnode->name);
 			error = -EOVERFLOW;
 			goto error_free;
 		}
 		error = of_property_read_u32_array(node, "input-queues",
-						   qnode->input_queues,
+						   temp,
 						   qnode->num_input_queues);
 		if (error) {
 			dev_err(kdev->dev, "error getting input_queues on node %s\n",
@@ -1756,11 +1923,10 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 		goto error_free;
 	}
 	for (i = 0; i < qnode->num_input_queues; i++) {
-		dev_dbg(kdev->dev, "node %s: input queue %d\n", qnode->name,
-			qnode->input_queues[i]);
+		qnode->input_queue[i].queue = temp[i];
+		qnode->input_queue[i].valid = false;
 	}
 
-
 	if (!parent)
 		ktree_set_root(&info->qos_tree, &qnode->node);
 	else
@@ -1911,16 +2077,17 @@ static int khwq_qos_tree_alloc_nodes(struct ktree_node *node, void *arg)
 
 		for (i = 0; i < qnode->num_input_queues; i++) {
 			error = khwq_qos_alloc_drop_queue(kdev,
-							  qnode->input_queues[i]);
+							  qnode->input_queue[i].queue);
 			if (error < 0) {
 				dev_err(kdev->dev,
 					"failed to alloc input queue %d on node %s\n",
-					qnode->input_queues[i], qnode->name);
+					qnode->input_queue[i].queue, qnode->name);
 				return error;
 			}
-			qnode->drop_queue_idx[i] = error;
+			qnode->input_queue[i].drop_queue_idx = error;
+			qnode->input_queue[i].valid = true;
 			dev_dbg(kdev->dev, "allocated drop queue %d for node %s\n",
-				qnode->input_queues[i], qnode->name);
+				qnode->input_queue[i].queue, qnode->name);
 		}
 	}
 
@@ -2108,7 +2275,10 @@ static int khwq_qos_tree_start_drop_queue(struct khwq_qos_info *info,
 		return 0;
 
 	for (i = 0; i < qnode->num_input_queues; i++) {
-		idx = qnode->drop_queue_idx[i];
+		if (qnode->input_queue[i].valid == false)
+			continue;
+
+		idx = qnode->input_queue[i].drop_queue_idx;
 
 		dev_dbg(kdev->dev, "programming drop queue %d for node %s\n",
 			khwq_qos_id_to_idx(idx), qnode->name);
@@ -2182,7 +2352,7 @@ bail:
 	return error;
 }
 
-static int khwq_qos_tree_start(struct khwq_qos_info *info)
+int khwq_qos_tree_start(struct khwq_qos_info *info)
 {
 	struct ktree_node *root;
 	int error;
@@ -2398,7 +2568,7 @@ static int khwq_qos_stop_sched_port_queues(struct khwq_qos_info *info)
 	return 0;
 }
 
-static int khwq_qos_tree_stop(struct khwq_qos_info *info)
+int khwq_qos_tree_stop(struct khwq_qos_info *info)
 {
 	int error;
 
@@ -2452,41 +2622,82 @@ static int khwq_qos_init_queue(struct khwq_range_info *range,
 	return 0;
 }
 
+int khwq_qos_start(struct khwq_qos_info *info)
+{
+	struct khwq_device *kdev;
+	u32 command;
+	int error = 0;
+
+	kdev = info->kdev;
+
+	error = khwq_qos_tree_start(info);
+	if (error) {
+		dev_err(kdev->dev, "failed to program qos tree\n");
+		return error;
+	}
+
+	/* Enable the drop scheduler */
+	command = (QOS_CMD_ENABLE_PORT |
+		   QOS_DROP_SCHED_ENABLE | QOS_ENABLE);
+	error = khwq_qos_write_cmd(info, command);
+	if (error)
+		dev_err(kdev->dev, "failed to enable drop scheduler\n");
+
+	init_timer(&info->timer);
+	info->timer.data		= (unsigned long)info;
+	info->timer.function		= khwq_qos_timer;
+	info->timer.expires		= jiffies +
+						KHWQ_QOS_TIMER_INTERVAL;
+	add_timer(&info->timer);
+
+	return error;
+}
+
 static int khwq_qos_open_queue(struct khwq_range_info *range,
 			       struct hwqueue_instance *inst, unsigned flags)
 {
 	struct khwq_qos_info *info;
 	struct khwq_device *kdev;
-	u32 command;
-	int error;
+	int error = 0;
 
 	info = range->qos_info;
 	kdev = info->kdev;
 
 	info->refcount++;
 	if (info->refcount == 1) {
-		error = khwq_qos_tree_start(info);
-		if (error) {
-			dev_err(kdev->dev, "failed to program qos tree\n");
-			return error;
-		}
-
-		/* Enable the drop scheduler */
-		command = (QOS_CMD_ENABLE_PORT |
-			   QOS_DROP_SCHED_ENABLE | QOS_ENABLE);
-		error = khwq_qos_write_cmd(info, command);
+		error = khwq_qos_start(info);
 		if (error)
-			dev_err(kdev->dev, "failed to enable drop scheduler\n");
+			dev_err(kdev->dev, "failed to start qos\n");
+	}
+
+	return error;
+}
+
+int khwq_qos_stop(struct khwq_qos_info *info)
+{
+	struct khwq_device *kdev;
+	u32 command;
+	int error = 0;
+
+	kdev = info->kdev;
 
-		init_timer(&info->timer);
-		info->timer.data		= (unsigned long)info;
-		info->timer.function		= khwq_qos_timer;
-		info->timer.expires		= jiffies +
-							KHWQ_QOS_TIMER_INTERVAL;
-		add_timer(&info->timer);
+	/* Disable the drop scheduler */
+	command = (QOS_CMD_ENABLE_PORT |
+		   QOS_DROP_SCHED_ENABLE | QOS_DISABLE);
+	error = khwq_qos_write_cmd(info, command);
+	if (error)
+		dev_err(kdev->dev, "failed to disable "
+			"drop scheduler\n");
+
+	error = khwq_qos_tree_stop(info);
+	if (error) {
+		dev_err(kdev->dev, "failed to close qos tree\n");
+		return error;
 	}
 
-	return 0;
+	del_timer_sync(&info->timer);
+
+	return error;
 }
 
 static int khwq_qos_close_queue(struct khwq_range_info *range,
@@ -2494,32 +2705,19 @@ static int khwq_qos_close_queue(struct khwq_range_info *range,
 {
 	struct khwq_qos_info *info;
 	struct khwq_device *kdev;
-	u32 command;
-	int error;
+	int error = 0;
 
 	info = range->qos_info;
 	kdev = info->kdev;
 
 	info->refcount--;
-	if (!info->refcount) {	
-		/* Disable the drop scheduler */
-		command = (QOS_CMD_ENABLE_PORT |
-			   QOS_DROP_SCHED_ENABLE | QOS_DISABLE);
-		error = khwq_qos_write_cmd(info, command);
+	if (!info->refcount) {
+		error = khwq_qos_stop(info);
 		if (error)
-			dev_err(kdev->dev, "failed to disable "
-				"drop scheduler\n");
-
-		error = khwq_qos_tree_stop(info);
-		if (error) {
-			dev_err(kdev->dev, "failed to close qos tree\n");
-			return error;
-		}
-	
-		del_timer_sync(&info->timer);	
+			dev_err(kdev->dev, "failed to stop qos\n");
 	}
 
-	return 0;
+	return error;
 }
 
 static int khwq_qos_free_range(struct khwq_range_info *range)
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index 996789a..acc3489 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -177,6 +177,12 @@ struct khwq_qos_stats_class {
 	struct kobject			 kobj;
 };
 
+struct khwq_qos_input_queue {
+	bool				 valid;
+	u32				 queue;
+	int				 drop_queue_idx;
+};
+
 struct khwq_qos_tree_node {
 	struct khwq_qos_tree_node	*parent;
 	struct khwq_qos_info		*info;
@@ -191,6 +197,7 @@ struct khwq_qos_tree_node {
 	int				 burst_size;
 	int				 num_input_queues;
 	u32				 input_queues[QOS_MAX_INPUTS];
+	struct khwq_qos_input_queue	 input_queue[QOS_MAX_INPUTS];
 	struct khwq_qos_drop_policy	*drop_policy;
 	struct khwq_qos_stats_class	*stats_class;
 
@@ -371,5 +378,10 @@ DEFINE_FIELD_U32(QOS_SCHED_PORT_CFG, sched_wrr_q_count,    0x24, 16,  8)
 DEFINE_FIELD_U32_ARRAY(QOS_SCHED_PORT_CFG, sched_wrr_credit,  0x28, 0x8)
 DEFINE_FIELD_U32_ARRAY(QOS_SCHED_PORT_CFG, sched_cong_thresh, 0x2c, 0x8)
 
+int khwq_qos_start(struct khwq_qos_info *info);
+int khwq_qos_stop(struct khwq_qos_info *info);
+int khwq_qos_tree_start(struct khwq_qos_info *info);
+int khwq_qos_tree_stop(struct khwq_qos_info *info);
+
 #endif
 
-- 
1.7.5.4

