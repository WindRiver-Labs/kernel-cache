From 2476b77a6a226e7210485f0417b3188c5ae75803 Mon Sep 17 00:00:00 2001
From: WingMan Kwok <w-kwok2@ti.com>
Date: Mon, 22 Aug 2016 07:36:38 -0400
Subject: [PATCH 205/347] phy: keystone: updates to 10gbe gbe pcie serdes
 configurations

This patch comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

The updates in this patch mainly concerns improving the serdes
lane stability in the SerDes used by 10gbe, gbe and PCIe. In
order to work with these updates, there is also a corresponding
binary firmware update needed.

After these updates, the configurations are now divided mainly
in two parts, namely, a common configuration which is done
regardless a SerDes lane is actually used or not, and a lane
specific configuration which is done when a lane is actually
used by, for example, a network interface.

The common configuration is performed by the SerDes provider
driver, ie., phy-keystone-serdes.c, at driver probe. The lane
specific configuration is invoked by the corresponding peripheral
driver, for example network switch driver, through the PHY API.

The updates have been approved for release by 3rd party under
BSD license.

Signed-off-by: WingMan Kwok <w-kwok2@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
(cherry picked from commit 6d85dc375571ce8d6b228e1f0dc5da1aff88a339)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 Documentation/devicetree/bindings/phy/ti-phy.txt |  206 ++-
 drivers/phy/phy-keystone-serdes.c                | 1938 ++++++++++++++--------
 2 files changed, 1340 insertions(+), 804 deletions(-)

diff --git a/Documentation/devicetree/bindings/phy/ti-phy.txt b/Documentation/devicetree/bindings/phy/ti-phy.txt
index 864701c..9b992f6 100644
--- a/Documentation/devicetree/bindings/phy/ti-phy.txt
+++ b/Documentation/devicetree/bindings/phy/ti-phy.txt
@@ -140,8 +140,6 @@ Required properties:
 	* "ti,keystone-serdes-pcie"
  - reg:
 	* base address and length of the SerDes register set
- - #phy-cells:
-	* From the generic phy bindings, must be 0;
  - num-lanes:
 	* Number of lanes in SerDes.
 
@@ -166,6 +164,8 @@ the "status" property.  If a lane is not represented by a node, the
 lane is disabled.
 
 Required properties (lane sub-node):
+ - #phy-cells:
+	* From the generic phy bindings, must be 0;
  - reg:
 	* lane number
 
@@ -193,62 +193,102 @@ Example for Keystone K2E GBE:
 -----------------------------
 
 gbe_serdes0: phy@232a000 {
-	#phy-cells		= <0>;
 	compatible		= "ti,keystone-serdes-gbe";
 	reg			= <0x0232a000 0x2000>;
 	link-rate-kbps		= <1250000>;
 	num-lanes		= <4>;
-	lanes {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		lane@0 {
-			/*loopback;*/
-			reg		= <0>;
-			control-rate	= <2>; /* quart */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <0 0 0 12 4>;
-			       /* c1 c2 cm att vreg */
-		};
-		lane@1 {
-			/*loopback;*/
-			reg		= <1>;
-			control-rate	= <2>; /* quart */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <0 0 0 12 4>;
-			       /* c1 c2 cm att vreg */
-		};
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	serdes0_lane0: lane@0 {
+		status		= "ok";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <0>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes0_lane1: lane@1 {
+		status		= "ok";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <1>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes0_lane2: lane@2 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <2>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes0_lane3: lane@3 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <3>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
 	};
 };
 
 gbe_serdes1: phy@2324000 {
-	#phy-cells		= <0>;
 	compatible		= "ti,keystone-serdes-gbe";
 	reg			= <0x02324000 0x2000>;
 	link-rate-kbps		= <1250000>;
 	num-lanes		= <4>;
-	lanes {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		lane@0 {
-			/*loopback;*/
-			reg		= <0>;
-			control-rate	= <2>; /* quart */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <0 0 0 12 4>;
-			       /* c1 c2 cm att vreg */
-		};
-		lane@1 {
-			/*loopback;*/
-			reg		= <1>;
-			control-rate	= <2>; /* quart */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <0 0 0 12 4>;
-			       /* c1 c2 cm att vreg */
-		};
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	serdes1_lane0: lane@0 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <0>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes1_lane1: lane@1 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <1>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes1_lane2: lane@2 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <2>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	serdes1_lane3: lane@3 {
+		status		= "disabled";
+		/*loopback;*/
+		#phy-cells	= <0>;
+		reg		= <3>;
+		control-rate	= <2>; /* quart */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <0 0 0 12 4>; /* c1 c2 cm att vreg */
 	};
 };
 
@@ -261,7 +301,14 @@ netcp: netcp@24000000 {
 		gbe@200000 { /* ETHSS */
 			...
 
-			phys = <&gbe_serdes0>, <&gbe_serdes1>;
+			gbe0: interface-0 {
+				phys = <&serdes0_lane0>;
+				...
+			};
+			gbe1: interface-1 {
+				phys = <&serdes0_lane1>;
+				...
+			};
 
 			...
 		};
@@ -274,21 +321,15 @@ Example for Keystone PCIE:
 --------------------------
 
 	pcie0_phy: phy@2320000 {
-		#phy-cells = <0>;
 		compatible = "ti,keystone-serdes-pcie";
 		reg = <0x02320000 0x4000>;
 		link-rate-kbps = <5000000>;
 		num-lanes = <2>;
 	};
 
-
-Then the PHY can be used in PCIe controller node as
-
-	pcie0: pcie@21800000 {
-		...
-
-		phys = <&pcie0_phy>;
-	}
+No SerDes phy handle needed in PCIe controller node
+since the SerDes PHY provider driver performs all
+the configurations needed for PCIe.
 
 Example for K2E 10GBE:
 ----------------------
@@ -313,34 +354,32 @@ Define the 10gbe SerDes node:
 
 xgbe_serdes: phy@231e000 {
 	status			= "ok";
-	#phy-cells		= <0>;
 	compatible		= "ti,keystone-serdes-xgbe";
 	reg			= <0x0231e000 0x2000>;
 	link-rate-kbps		= <10312500>;
 	num-lanes		= <2>;
 	syscon-peripheral	= <&xgbe_subsys>;
 	syscon-link		= <&xgbe_pcsr>;
-	lanes {
-		#address-cells = <1>;
-		#size-cells = <0>;
-		lane@0 {
-			/*loopback;*/
-			reg		= <0>;
-			control-rate	= <0>; /* full */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <2 0 0 12 4>;
-				/* c1 c2 cm att vreg */
-		};
-		lane@1 {
-			/*loopback;*/
-			reg		= <1>;
-			control-rate	= <0>; /* full */
-			rx-start	= <7 5>;
-			rx-force	= <1 1>;
-			tx-coeff	= <2 0 0 12 4>;
-				/* c1 c2 cm att vreg */
-		};
+	#address-cells  = <1>;
+	#size-cells     = <0>;
+
+	xserdes_lane0: lane@0 {
+		status		= "ok";
+		#phy-cells	= <0>;
+		reg		= <0>;
+		control-rate	= <0>; /* full */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <2 0 0 12 4>; /* c1 c2 cm att vreg */
+	};
+	xserdes_lane1: lane@1 {
+		status		= "ok";
+		#phy-cells	= <0>;
+		reg		= <1>;
+		control-rate	= <0>; /* full */
+		rx-start	= <7 5>;
+		rx-force	= <1 1>;
+		tx-coeff	= <2 0 0 12 4>; /* c1 c2 cm att vreg */
 	};
 };
 
@@ -358,9 +397,14 @@ netcpx: netcpx@2f00000 {
 
 			...
 
-			syscon-subsys = <&xgbe_subsys>;
-			syscon-pcsr = <&xgbe_pcsr>;
-			phys = <&xgbe_serdes>;
+			xgbe0: interface-0 {
+				phys = <&xserdes_lane0>;
+				...
+			};
+			xgbe1: interface-1 {
+				phys = <&xserdes_lane1>;
+				...
+			};
 
 			...
 		};
diff --git a/drivers/phy/phy-keystone-serdes.c b/drivers/phy/phy-keystone-serdes.c
index 33212d5..092f3c5 100644
--- a/drivers/phy/phy-keystone-serdes.c
+++ b/drivers/phy/phy-keystone-serdes.c
@@ -6,6 +6,16 @@
  * required to support PCIe RC functionality based on designware
  * PCIe hardware, gbe and 10gbe found on these devices.
  *
+ * Revision History:
+ *    3.3.0.2c
+ *	- Full update based on CSL version 3.3.0.2c
+ *	- This update requires the remodelling of each SerDes lane
+ *	  as a separate PHY device, as opposed to each SerDes as a
+ *	  separate PHY device prior to this patch.
+ *
+ *    1.0.0
+ *	- Initial revision.
+ *
  * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/
  *
  * Redistribution and use in source and binary forms, with or without
@@ -99,11 +109,13 @@
 #define FOUR_LANE(serdes) \
 	((MOD_VER(serdes) == 0x4eb9) || (MOD_VER(serdes) == 0x4ebd))
 
-#define MAX_COMPARATORS			5
+#define KSERDES_MAX_LANES	4
+#define MAX_COEFS		5
+#define MAX_CMP			5
 #define OFFSET_SAMPLES		100
 
-#define for_each_comparator(i)	\
-	for (i = 1; i < MAX_COMPARATORS; i++)
+#define for_each_cmp(i)	\
+	for (i = 1; i < MAX_CMP; i++)
 
 #define CPU_EN			BIT(31)
 #define CPU_GO			BIT(30)
@@ -136,14 +148,7 @@
 #define KSERDES_XFW_PARAM_START_ADDR \
 	(KSERDES_XFW_MEM_SIZE - (KSERDES_XFW_NUM_PARAMS * 4))
 
-/*
- * All firmware file names end up here. List the firmware file names below.
- * Newest first. Search starts from the 0-th array entry until a firmware
- * file is found.
- */
-static const char * const ks2_gbe_serdes_firmwares[] = {"ks2_gbe_serdes.bin"};
-static const char * const ks2_xgbe_serdes_firmwares[] = {"ks2_xgbe_serdes.bin"};
-static const char * const ks2_pcie_serdes_firmwares[] = {"ks2_pcie_serdes.bin"};
+#define LANE_ENABLE(sc, n) ((sc)->lane[n].enable)
 
 enum kserdes_link_rate {
 	KSERDES_LINK_RATE_1P25G		=  1250000,
@@ -194,8 +199,6 @@ struct kserdes_lane_config {
 	bool				loopback;
 };
 
-#define KSERDES_MAX_LANES		4
-
 struct kserdes_fw_config {
 	bool				on;
 	u32				rate;
@@ -207,6 +210,63 @@ struct kserdes_fw_config {
 	u32				lane_config[KSERDES_MAX_LANES];
 };
 
+struct kserdes_lane_dlev_out {
+	u32 delay;
+	int coef_vals[MAX_COEFS];
+};
+
+struct kserdes_dlev_out {
+	struct kserdes_lane_dlev_out lane_dlev_out[KSERDES_MAX_LANES];
+};
+
+struct kserdes_cmp_coef_ofs {
+	u32 cmp;
+	u32 coef1;
+	u32 coef2;
+	u32 coef3;
+	u32 coef4;
+	u32 coef5;
+};
+
+struct kserdes_lane_ofs {
+	struct kserdes_cmp_coef_ofs ct_ofs[MAX_CMP];
+};
+
+struct kserdes_ofs {
+	struct kserdes_lane_ofs lane_ofs[KSERDES_MAX_LANES];
+};
+
+/*
+ * All firmware file names end up here. List the firmware file names below.
+ * Newest first. Search starts from the 0-th array entry until a firmware
+ * file is found.
+ */
+static const char * const ks2_gbe_serdes_firmwares[] = {"ks2_gbe_serdes.bin"};
+static const char * const ks2_xgbe_serdes_firmwares[] = {"ks2_xgbe_serdes.bin"};
+static const char * const ks2_pcie_serdes_firmwares[] = {"ks2_pcie_serdes.bin"};
+
+#define MAX_VERSION		64
+#define INIT_FW_MAGIC_1		0xfaceface
+#define INIT_FW_MAGIC_2		0xcafecafe
+
+static char *compatible_init_fw_version[] = {
+	"3.3.0.2c",
+	NULL,
+};
+
+struct serdes_cfg_header {
+	u32 magic_1;
+	char version[MAX_VERSION];
+	u32 magic_2;
+};
+
+struct serdes_cfg {
+	u32 ofs;
+	u32 msb;
+	u32 lsb;
+	u32 val;
+};
+
 struct kserdes_config {
 	struct device			*dev;
 	enum kserdes_phy_type		phy_type;
@@ -220,38 +280,21 @@ struct kserdes_config {
 	enum kserdes_link_rate		link_rate;
 	bool				rx_force_enable;
 	struct kserdes_lane_config	lane[KSERDES_MAX_LANES];
+	struct kserdes_ofs		sofs;
 	bool				firmware;
 	struct kserdes_fw_config	fw;
 };
 
-struct kserdes_dev {
-	struct device *dev;
+struct kserdes_phy {
+	u32 lane;
 	struct phy *phy;
-	struct kserdes_config sc;
-};
-
-struct kserdes_cmp_tap_ofs {
-	u32 cmp;
-	u32 tap1;
-	u32 tap2;
-	u32 tap3;
-	u32 tap4;
-	u32 tap5;
-};
-
-struct kserdes_lane_offsets {
-	struct kserdes_cmp_tap_ofs ct_ofs[MAX_COMPARATORS];
-};
-
-struct kserdes_offsets {
-	struct kserdes_lane_offsets lane_ofs[KSERDES_MAX_LANES];
 };
 
-struct serdes_cfg {
-	u32 ofs;
-	u32 msb;
-	u32 lsb;
-	u32 val;
+struct kserdes_dev {
+	struct device *dev;
+	u32 nphys;
+	struct kserdes_phy *phys[KSERDES_MAX_LANES];
+	struct kserdes_config sc;
 };
 
 static struct platform_device_id kserdes_devtype[] = {
@@ -303,6 +346,32 @@ static void kserdes_do_config(void __iomem *base,
 		FINSR(base, cfg[i].ofs, cfg[i].msb, cfg[i].lsb, cfg[i].val);
 }
 
+static bool is_init_fw_compatible(struct kserdes_config *sc,
+				  struct serdes_cfg_header *hdr)
+{
+	int i = 0;
+
+	if ((hdr->magic_1 != INIT_FW_MAGIC_1) ||
+	    (hdr->magic_2 != INIT_FW_MAGIC_2)) {
+		dev_err(sc->dev, "incompatible fw %s\n", sc->init_fw);
+		return false;
+	}
+
+	while (compatible_init_fw_version[i]) {
+		if (!strcmp(compatible_init_fw_version[i], hdr->version)) {
+			dev_info(sc->dev, "init fw %s: version %s\n",
+				 sc->init_fw, hdr->version);
+			return true;
+		}
+
+		++i;
+	}
+
+	dev_err(sc->dev, "incompatible fw %s: version %s\n",
+		sc->init_fw, hdr->version);
+	return false;
+}
+
 static int kserdes_load_init_fw(struct kserdes_config *sc,
 				const char * const *a_firmwares,
 				int n_firmwares)
@@ -310,6 +379,8 @@ static int kserdes_load_init_fw(struct kserdes_config *sc,
 	const struct firmware *fw;
 	bool found = false;
 	int ret, i;
+	struct serdes_cfg_header hdr;
+	int hdr_sz;
 
 	for (i = 0; i < n_firmwares; i++) {
 		if (a_firmwares[i]) {
@@ -327,9 +398,16 @@ static int kserdes_load_init_fw(struct kserdes_config *sc,
 	}
 
 	sc->init_fw = a_firmwares[i];
-	sc->init_cfg = devm_kzalloc(sc->dev, fw->size, GFP_KERNEL);
-	memcpy((void *)sc->init_cfg, fw->data,  fw->size);
-	sc->init_cfg_len = fw->size;
+
+	memcpy((void *)&hdr, fw->data, sizeof(hdr));
+	hdr_sz = sizeof(hdr);
+	hdr.version[MAX_VERSION - 1] = 0;
+	if (!is_init_fw_compatible(sc, &hdr))
+		return -EINVAL;
+
+	sc->init_cfg = devm_kzalloc(sc->dev, fw->size - hdr_sz, GFP_KERNEL);
+	memcpy((void *)sc->init_cfg, fw->data + hdr_sz, fw->size - hdr_sz);
+	sc->init_cfg_len = fw->size - hdr_sz;
 	release_firmware(fw);
 
 	kserdes_do_config(sc->regs, sc->init_cfg,
@@ -369,11 +447,6 @@ static u32 _kserdes_read_select_tbus(void __iomem *sregs, int select, int ofs)
 	return _kserdes_read_tbus_val(sregs);
 }
 
-static inline void kserdes_highspeed_cfg1(struct kserdes_config *sc)
-{
-	FINSR(sc->regs, CML_REG(0xbc), 28, 24, 0x1e);
-}
-
 static inline void kserdes_set_tx_idle(struct kserdes_config *sc, u32 lane)
 {
 	if (sc->phy_type != KSERDES_PHY_XGE)
@@ -392,58 +465,11 @@ static inline void kserdes_clr_tx_idle(struct kserdes_config *sc, u32 lane)
 	FINSR(sc->regs, LANEX_REG(lane, 0x28), 21, 20, 0);
 }
 
-static inline void kserdes_cdfe_enable(struct kserdes_config *sc, u32 lane)
-{
-	FINSR(sc->regs, LANEX_REG(lane, 0x94), 24, 24, 0x1);
-}
-
-static inline void kserdes_cdfe_force_calibration_enable(
-			struct kserdes_config *sc, u32 lane)
-{
-	FINSR(sc->regs, LANEX_REG(lane, 0x98), 0, 0, 0x1);
-}
-
-static void kserdes_phyb_cfg(struct kserdes_config *sc)
-{
-	int lane;
-
-	for_each_enable_lane(sc, lane)
-		kserdes_cdfe_enable(sc, lane);
-
-	FINSR(sc->regs, CML_REG(0x108), 23, 16, 0x04);
-
-	FINSR(sc->regs, CML_REG(0xbc), 28, 24, 0x0);
-
-	for_each_lane(sc, lane)
-		kserdes_cdfe_force_calibration_enable(sc, lane);
-}
-
-static inline void kserdes_set_lane_starts(struct kserdes_config *sc, u32 lane)
-{
-	FINSR(sc->regs, LANEX_REG(lane, 0x8c), 11, 8,
-	      sc->lane[lane].rx_start.att);
-	FINSR(sc->regs, LANEX_REG(lane, 0x8c), 15, 12,
-	      sc->lane[lane].rx_start.boost);
-}
-
-static void kserdes_highspeed_cfg(struct kserdes_config *sc)
-{
-	int lane;
-
-	if (sc->phy_type == KSERDES_PHY_XGE) {
-		kserdes_phyb_cfg(sc);
-	}
-
-	for_each_enable_lane(sc, lane)
-		kserdes_set_lane_starts(sc, lane);
-}
-
-static void kserdes_set_lane_overrides(struct kserdes_config *sc, u32 lane)
+static void kserdes_set_lane_ov(struct kserdes_config *sc, u32 lane)
 {
 	u32 val_0, val_1, val;
 
 	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1, 0);
-
 	val_1 = _kserdes_read_select_tbus(sc->regs, lane + 1, 1);
 
 	val = 0;
@@ -461,7 +487,7 @@ static inline void kserdes_assert_reset(struct kserdes_config *sc)
 	int lane;
 
 	for_each_enable_lane(sc, lane)
-		kserdes_set_lane_overrides(sc, lane);
+		kserdes_set_lane_ov(sc, lane);
 }
 
 static inline void kserdes_config_c1_c2_cm(struct kserdes_config *sc, u32 lane)
@@ -497,12 +523,12 @@ static inline void kserdes_config_att_boost(struct kserdes_config *sc, u32 lane)
 		FINSR(sc->regs, LANEX_REG(lane, 0x8c), 15, 12, boost);
 		FINSR(sc->regs, LANEX_REG(lane, 0x8c), 11, 8, att);
 	} else {
-		if (att != 1) {
+		if (att != -1) {
 			FINSR(sc->regs, CML_REG(0x84), 0, 0, 0);
 			FINSR(sc->regs, CML_REG(0x8c), 24, 24, 0);
 			FINSR(sc->regs, LANEX_REG(lane, 0x8c), 11, 8, att);
 		}
-		if (boost != 1) {
+		if (boost != -1) {
 			FINSR(sc->regs, CML_REG(0x84), 1, 1, 0);
 			FINSR(sc->regs, CML_REG(0x8c), 25, 25, 0);
 			FINSR(sc->regs, LANEX_REG(lane, 0x8c), 15, 12, boost);
@@ -528,26 +554,26 @@ static void kserdes_set_tx_rx_fir_coeff(struct kserdes_config *sc, u32 lane)
 		kserdes_config_att_boost(sc, lane);
 }
 
-static inline void _kserdes_force_signal_detect_low(
-				void __iomem *sregs, u32 lane)
+static inline void
+_kserdes_force_signal_detect_low(void __iomem *sregs, u32 lane)
 {
 	FINSR(sregs, LANEX_REG(lane, 0x004), 2, 1, 0x2);
 }
 
-static inline void kserdes_force_signal_detect_low(
-			struct kserdes_config *sc, u32 lane)
+static inline void
+kserdes_force_signal_detect_low(struct kserdes_config *sc, u32 lane)
 {
 	_kserdes_force_signal_detect_low(sc->regs, lane);
 }
 
-static inline void _kserdes_force_signal_detect_high(
-				void __iomem *sregs, u32 lane)
+static inline void
+_kserdes_force_signal_detect_high(void __iomem *sregs, u32 lane)
 {
 	FINSR(sregs, LANEX_REG(lane, 0x004), 2, 1, 0x0);
 }
 
-static inline void kserdes_force_signal_detect_high(
-			struct kserdes_config *sc, u32 lane)
+static inline void
+kserdes_force_signal_detect_high(struct kserdes_config *sc, u32 lane)
 {
 	_kserdes_force_signal_detect_high(sc->regs, lane);
 }
@@ -561,7 +587,7 @@ static int kserdes_deassert_reset_poll_others(struct kserdes_config *sc)
 	u32 ret, i;
 
 	for_each_enable_lane(sc, i)
-		lanes_not_ok |= (1 << i);
+		lanes_not_ok |= BIT(i);
 
 	if (!FOUR_LANE(sc->regs))
 		ofs = 29;
@@ -575,7 +601,7 @@ static int kserdes_deassert_reset_poll_others(struct kserdes_config *sc)
 			ret = kserdes_readl(sc->regs, CML_REG(0x1f8));
 
 			if (ret & BIT(ofs + i))
-				lanes_not_ok &= ~(1 << i);
+				lanes_not_ok &= ~BIT(i);
 		}
 
 		if (!lanes_not_ok)
@@ -601,13 +627,13 @@ static int kserdes_deassert_reset_poll_pcie(struct kserdes_config *sc)
 	do {
 		time_check = jiffies;
 		for_each_enable_lane(sc, i) {
-			if (!(lanes_not_ok & (1 << i)))
+			if (!(lanes_not_ok & BIT(i)))
 				continue;
 
 			ret = _kserdes_read_select_tbus(sc->regs, i + 1, 0x02);
 
 			if (!(ret & BIT(4)))
-				lanes_not_ok &= ~(1 << i);
+				lanes_not_ok &= ~BIT(i);
 		}
 
 		if (!lanes_not_ok)
@@ -653,12 +679,6 @@ done:
 	return ret;
 }
 
-static inline void kserdes_lane_disable(struct kserdes_config *sc, u32 lane)
-{
-	FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 31, 29, 0x4);
-	FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 15, 13, 0x4);
-}
-
 static inline void _kserdes_lane_enable(void __iomem *sregs, u32 lane)
 {
 	FINSR(sregs, LANE_CTRL_STS_REG(lane), 31, 29, 0x7);
@@ -690,9 +710,9 @@ static inline int _kserdes_set_lane_ctrl_rate(void __iomem *sregs, u32 lane,
 }
 
 static inline void _kserdes_set_lane_loopback(void __iomem *sregs, u32 lane,
-					      enum kserdes_link_rate link_rate)
+					      enum kserdes_phy_type phy_type)
 {
-	if (link_rate == KSERDES_LINK_RATE_10P3125G) {
+	if (phy_type == KSERDES_PHY_XGE) {
 		FINSR(sregs, LANEX_REG(lane, 0x0), 7, 0, 0x4);
 		FINSR(sregs, LANEX_REG(lane, 0x4), 2, 1, 0x3);
 	} else {
@@ -700,35 +720,15 @@ static inline void _kserdes_set_lane_loopback(void __iomem *sregs, u32 lane,
 	}
 }
 
-static void kserdes_set_lane_rate(struct kserdes_config *sc, u32 lane)
-{
-	int ret;
-
-	ret = _kserdes_set_lane_ctrl_rate(sc->regs, lane,
-					  sc->lane[lane].ctrl_rate);
-	if (ret) {
-		dev_err(sc->dev, "set_lane_rate FAILED: lane = %d err = %d\n",
-			lane, ret);
-		return;
-	}
-
-	FINSR(sc->regs, LANEX_REG(lane, 0x30), 11, 11, 0x1);
-	FINSR(sc->regs, LANEX_REG(lane, 0x30), 13, 12, 0x0);
-
-	if (sc->lane[lane].loopback)
-		_kserdes_set_lane_loopback(sc->regs, lane, sc->link_rate);
-
-	_kserdes_lane_enable(sc->regs, lane);
-}
-
-static inline void _kserdes_set_wait_after(void __iomem *sregs)
+static inline void _kserdes_clear_wait_after(void __iomem *sregs)
 {
-	FINSR(sregs, PLL_CTRL_REG, 17, 16, 0x3);
+	FINSR(sregs, PLL_CTRL_REG, 17, 16, 0);
 }
 
-static inline void _kserdes_clear_wait_after(void __iomem *sregs)
+static inline void _kserdes_clear_lane_wait_after(void __iomem *sregs, u32 lane)
 {
-	FINSR(sregs, PLL_CTRL_REG, 17, 16, 0);
+	FINSR(sregs, PLL_CTRL_REG, lane + 12, lane + 12, 1);
+	FINSR(sregs, PLL_CTRL_REG, lane + 4, lane + 4, 1);
 }
 
 static inline void _kserdes_pll_enable(void __iomem *sregs)
@@ -769,16 +769,9 @@ static inline void kserdes_lane_enable_loopback(void __iomem *serdes, u32 lane)
 static inline u32 _kserdes_get_lane_status(void __iomem *sregs, u32 lane,
 					   enum kserdes_phy_type phy_type)
 {
-	switch (phy_type) {
-	case KSERDES_PHY_PCIE:
-		return FEXTR(kserdes_readl(sregs, PLL_CTRL_REG), lane, lane);
-	case KSERDES_PHY_XGE:
-		return FEXTR(kserdes_readl(sregs, CML_REG(0x1f8)),
-			     (29 + lane), (29 + lane));
-	default:
-		return FEXTR(kserdes_readl(sregs, PLL_CTRL_REG),
-			     (8 + lane), (8 + lane));
-	}
+	int d = ((phy_type == KSERDES_PHY_PCIE) ? 0 : 8);
+
+	return FEXTR(kserdes_readl(sregs, PLL_CTRL_REG), lane + d, lane + d);
 }
 
 static u32 kserdes_get_pll_lanes_status(struct kserdes_config *sc)
@@ -822,17 +815,17 @@ static int kserdes_get_status(struct kserdes_config *sc)
 	return 0;
 }
 
-static inline u32 _kserdes_get_tx_termination(void __iomem *sregs, u32 lane,
+static inline u32 _kserdes_get_tx_termination(void __iomem *sregs,
 					      enum kserdes_phy_type phy_type)
 {
-	return (_kserdes_read_select_tbus(sregs, lane + 1,
+	return (_kserdes_read_select_tbus(sregs, 1,
 					  ((phy_type == KSERDES_PHY_XGE) ?
 					  0x1a : 0x1b)) & 0xff);
 }
 
 static void kserdes_set_tx_terminations(struct kserdes_config *sc, u32 term)
 {
-	u32 i;
+	int i;
 
 	for_each_lane(sc, i) {
 		FINSR(sc->regs, LANEX_REG(i, 0x7c), 31, 24, term);
@@ -841,8 +834,8 @@ static void kserdes_set_tx_terminations(struct kserdes_config *sc, u32 term)
 }
 
 static void
-_kserdes_write_offsets_xge(void __iomem *sregs, u32 lane, u32 cmp,
-				 struct kserdes_cmp_tap_ofs *ofs)
+_kserdes_write_ofs_xge(void __iomem *sregs, u32 lane, u32 cmp,
+		       struct kserdes_cmp_coef_ofs *ofs)
 {
 	FINSR(sregs, CML_REG(0x8c), 23, 21, cmp);
 
@@ -850,83 +843,82 @@ _kserdes_write_offsets_xge(void __iomem *sregs, u32 lane, u32 cmp,
 	ofs->cmp = (_kserdes_read_tbus_val(sregs) & 0x0ff0) >> 4;
 
 	FINSR(sregs, CMU0_REG(0xfc), 26, 16, ((lane + 2) << 8) + 0x11);
-	ofs->tap1 = (_kserdes_read_tbus_val(sregs) & 0x000f) << 3;
+	ofs->coef1 = (_kserdes_read_tbus_val(sregs) & 0x000f) << 3;
 
 	FINSR(sregs, CMU0_REG(0xfc), 26, 16, ((lane + 2) << 8) + 0x12);
-	ofs->tap1 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
-	ofs->tap2  = (_kserdes_read_tbus_val(sregs) & 0x01f8) >> 3;
-	ofs->tap3  = (_kserdes_read_tbus_val(sregs) & 0x0007) << 3;
+	ofs->coef1 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
+	ofs->coef2  = (_kserdes_read_tbus_val(sregs) & 0x01f8) >> 3;
+	ofs->coef3  = (_kserdes_read_tbus_val(sregs) & 0x0007) << 3;
 
 	FINSR(sregs, CMU0_REG(0xfc), 26, 16, ((lane + 2) << 8) + 0x13);
-	ofs->tap3 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
-	ofs->tap4  = (_kserdes_read_tbus_val(sregs) & 0x01f8) >> 3;
-	ofs->tap5  = (_kserdes_read_tbus_val(sregs) & 0x0007) << 3;
+	ofs->coef3 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
+	ofs->coef4  = (_kserdes_read_tbus_val(sregs) & 0x01f8) >> 3;
+	ofs->coef5  = (_kserdes_read_tbus_val(sregs) & 0x0007) << 3;
 
 	FINSR(sregs, CMU0_REG(0xfc), 26, 16, ((lane + 2) << 8) + 0x14);
-	ofs->tap5 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
+	ofs->coef5 |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
 }
 
-static void kserdes_add_offsets_xge(struct kserdes_config *sc,
-				    struct kserdes_offsets *sofs)
+static void kserdes_add_ofs_xge(struct kserdes_config *sc,
+				struct kserdes_ofs *sofs)
 {
-	struct kserdes_cmp_tap_ofs *ctofs;
-	struct kserdes_cmp_tap_ofs sample;
-	struct kserdes_lane_offsets *lofs;
+	struct kserdes_cmp_coef_ofs *ctofs;
+	struct kserdes_cmp_coef_ofs sample;
+	struct kserdes_lane_ofs *lofs;
 	u32 lane, cmp;
 
-	for_each_lane(sc, lane) {
+	for_each_enable_lane(sc, lane) {
 		lofs = &sofs->lane_ofs[lane];
-		for_each_comparator(cmp) {
+		for_each_cmp(cmp) {
 			ctofs = &lofs->ct_ofs[cmp];
 
-			_kserdes_write_offsets_xge(sc->regs, lane,
-							 cmp, &sample);
+			_kserdes_write_ofs_xge(sc->regs, lane, cmp, &sample);
 
 			ctofs->cmp  += sample.cmp;
-			ctofs->tap1 += sample.tap1;
-			ctofs->tap2 += sample.tap2;
-			ctofs->tap3 += sample.tap3;
-			ctofs->tap4 += sample.tap4;
-			ctofs->tap5 += sample.tap5;
+			ctofs->coef1 += sample.coef1;
+			ctofs->coef2 += sample.coef2;
+			ctofs->coef3 += sample.coef3;
+			ctofs->coef4 += sample.coef4;
+			ctofs->coef5 += sample.coef5;
 		}
 	}
 }
 
 static void
-kserdes_get_cmp_tap_offsets_non_xge(void __iomem *sregs, u32 lane, u32 cmp,
-				    struct kserdes_cmp_tap_ofs *ofs)
+kserdes_get_cmp_coef_ofs_non_xge(void __iomem *sregs, u32 lane, u32 cmp,
+				 struct kserdes_cmp_coef_ofs *ofs)
 {
 	FINSR(sregs, CML_REG(0x8c), 23, 21, cmp);
 	FINSR(sregs, CMU0_REG(0x8), 31, 24, ((lane + 1) << 5) + 0x12);
 	ofs->cmp = (_kserdes_read_tbus_val(sregs) & 0x0ff0) >> 4;
 }
 
-static void kserdes_add_offsets_non_xge(struct kserdes_config *sc,
-					struct kserdes_offsets *sofs)
+static void kserdes_add_ofs_non_xge(struct kserdes_config *sc,
+				    struct kserdes_ofs *sofs)
 {
-	struct kserdes_cmp_tap_ofs *ctofs;
-	struct kserdes_cmp_tap_ofs sample;
-	struct kserdes_lane_offsets *lofs;
+	struct kserdes_cmp_coef_ofs *ctofs;
+	struct kserdes_cmp_coef_ofs sample;
+	struct kserdes_lane_ofs *lofs;
 	u32 lane, cmp;
 
-	for_each_lane(sc, lane) {
+	for_each_enable_lane(sc, lane) {
 		lofs = &sofs->lane_ofs[lane];
-		for_each_comparator(cmp) {
+		for_each_cmp(cmp) {
 			ctofs = &lofs->ct_ofs[cmp];
 
-			kserdes_get_cmp_tap_offsets_non_xge(sc->regs, lane,
-							    cmp, &sample);
+			kserdes_get_cmp_coef_ofs_non_xge(sc->regs, lane,
+							 cmp, &sample);
 
 			ctofs->cmp  += sample.cmp;
 		}
 	}
 }
 
-static void kserdes_get_average_offsets(struct kserdes_config *sc, u32 samples,
-					struct kserdes_offsets *sofs)
+static void kserdes_get_average_ofs(struct kserdes_config *sc, u32 samples,
+				    struct kserdes_ofs *sofs)
 {
-	struct kserdes_cmp_tap_ofs *ctofs;
-	struct kserdes_lane_offsets *lofs;
+	struct kserdes_cmp_coef_ofs *ctofs;
+	struct kserdes_lane_ofs *lofs;
 	u32 i, lane, cmp;
 	int ret;
 
@@ -937,28 +929,28 @@ static void kserdes_get_average_offsets(struct kserdes_config *sc, u32 samples,
 		ret = kserdes_deassert_reset(sc, 1);
 		if (ret) {
 			dev_err(sc->dev,
-				"kserdes_get_average_offsets: reset failed %d\n",
+				"kserdes_get_average_ofs: reset failed %d\n",
 				ret);
 			return;
 		}
 
 		if (sc->phy_type == KSERDES_PHY_XGE)
-			kserdes_add_offsets_xge(sc, sofs);
+			kserdes_add_ofs_xge(sc, sofs);
 		else
-			kserdes_add_offsets_non_xge(sc, sofs);
+			kserdes_add_ofs_non_xge(sc, sofs);
 	}
 
-	for_each_lane(sc, lane) {
+	for_each_enable_lane(sc, lane) {
 		lofs = &sofs->lane_ofs[lane];
-		for_each_comparator(cmp) {
+		for_each_cmp(cmp) {
 			ctofs = &lofs->ct_ofs[cmp];
 			if (sc->phy_type == KSERDES_PHY_XGE) {
 				ctofs->cmp  /= samples;
-				ctofs->tap1 /= samples;
-				ctofs->tap2 /= samples;
-				ctofs->tap3 /= samples;
-				ctofs->tap4 /= samples;
-				ctofs->tap5 /= samples;
+				ctofs->coef1 /= samples;
+				ctofs->coef2 /= samples;
+				ctofs->coef3 /= samples;
+				ctofs->coef4 /= samples;
+				ctofs->coef5 /= samples;
 			} else {
 				ctofs->cmp  /= samples;
 			}
@@ -966,26 +958,20 @@ static void kserdes_get_average_offsets(struct kserdes_config *sc, u32 samples,
 	}
 }
 
-static void
-_kserdes_override_cmp_tap_offsets(void __iomem *sregs, u32 lane, u32 cmp,
-				  struct kserdes_cmp_tap_ofs *ofs)
+static void _kserdes_set_ofs(void __iomem *sregs, u32 lane, u32 cmp,
+			     struct kserdes_cmp_coef_ofs *ofs)
 {
 	FINSR(sregs, CML_REG(0xf0), 27, 26, (lane + 1));
-
 	FINSR(sregs, CML_REG(0x98), 24, 24, 0x1);
-
 	FINSR(sregs, LANEX_REG(lane, 0x2c), 2, 2, 0x1);
-
 	FINSR(sregs, LANEX_REG(lane, 0x30), 7, 5, cmp);
-
 	FINSR(sregs, LANEX_REG(lane, 0x5c), 31, 31, 0x1);
-
 	FINSR(sregs, CML_REG(0x9c), 7, 0, ofs->cmp);
-	FINSR(sregs, LANEX_REG(lane, 0x58), 30, 24, ofs->tap1);
-	FINSR(sregs, LANEX_REG(lane, 0x5c),  5,  0, ofs->tap2);
-	FINSR(sregs, LANEX_REG(lane, 0x5c), 13,  8, ofs->tap3);
-	FINSR(sregs, LANEX_REG(lane, 0x5c), 21, 16, ofs->tap4);
-	FINSR(sregs, LANEX_REG(lane, 0x5c), 29, 24, ofs->tap5);
+	FINSR(sregs, LANEX_REG(lane, 0x58), 30, 24, ofs->coef1);
+	FINSR(sregs, LANEX_REG(lane, 0x5c),  5,  0, ofs->coef2);
+	FINSR(sregs, LANEX_REG(lane, 0x5c), 13,  8, ofs->coef3);
+	FINSR(sregs, LANEX_REG(lane, 0x5c), 21, 16, ofs->coef4);
+	FINSR(sregs, LANEX_REG(lane, 0x5c), 29, 24, ofs->coef5);
 
 	FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x1);
 	FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x0);
@@ -995,46 +981,41 @@ _kserdes_override_cmp_tap_offsets(void __iomem *sregs, u32 lane, u32 cmp,
 	FINSR(sregs, LANEX_REG(lane, 0x5c), 31, 31, 0x0);
 }
 
-static inline void
-_kserdes_override_cmp_offset_cdfe(void __iomem *sregs, u32 lane,
-				  u32 cmp, u32 cmp_offset)
+static inline void _kserdes_set_cmp_ofs_phyb(void __iomem *sregs, u32 lane,
+					     u32 cmp, u32 cmp_ofs)
 {
 	FINSR(sregs, LANEX_REG(lane, 0x58), 18, 18, 0x1);
-
 	FINSR(sregs, LANEX_REG(lane, 0x4c), 5, 2, (0x1 << (cmp - 1)));
-	FINSR(sregs, LANEX_REG(lane, 0x48), 24, 17, cmp_offset);
+	FINSR(sregs, LANEX_REG(lane, 0x48), 24, 17, cmp_ofs);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 29, 29, 0x1);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 29, 29, 0x0);
-
 	FINSR(sregs, LANEX_REG(lane, 0x58), 18, 18, 0x0);
 }
 
-static inline void
-_kserdes_override_tap_offset_cdfe(void __iomem *sregs, u32 lane,
-				  u32 tap, u32 width, u32 tap_offset)
+static inline void _kserdes_set_coef_ofs(void __iomem *sregs, u32 lane,
+					 u32 coef, u32 width, u32 coef_ofs)
 {
-	FINSR(sregs, LANEX_REG(lane, 0x58), 23, 19, BIT(tap - 1));
-	FINSR(sregs, LANEX_REG(lane, 0x48), 17 + (width - 1), 17, tap_offset);
+	FINSR(sregs, LANEX_REG(lane, 0x58), 23, 19, (0x1 << (coef - 1)));
+	FINSR(sregs, LANEX_REG(lane, 0x48), 17 + (width - 1), 17, coef_ofs);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 29, 29, 0x1);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 29, 29, 0x0);
 }
 
-static void
-_kserdes_override_cmp_tap_offsets_cdfe(void __iomem *sregs, u32 lane, u32 cmp,
-				       struct kserdes_cmp_tap_ofs *ofs)
+static void _kserdes_set_ofs_phyb(void __iomem *sregs, u32 lane, u32 cmp,
+				  struct kserdes_cmp_coef_ofs *ofs)
 {
 	FINSR(sregs, LANEX_REG(lane, 0x58), 16, 16, 0x1);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 16, 16, 0x1);
 
-	_kserdes_override_cmp_offset_cdfe(sregs, lane, cmp, ofs->cmp);
+	_kserdes_set_cmp_ofs_phyb(sregs, lane, cmp, ofs->cmp);
 
 	FINSR(sregs, LANEX_REG(lane, 0x58), 17, 17, 0x1);
 
-	_kserdes_override_tap_offset_cdfe(sregs, lane, 1, 7, ofs->tap1);
-	_kserdes_override_tap_offset_cdfe(sregs, lane, 2, 6, ofs->tap2);
-	_kserdes_override_tap_offset_cdfe(sregs, lane, 3, 6, ofs->tap3);
-	_kserdes_override_tap_offset_cdfe(sregs, lane, 4, 6, ofs->tap4);
-	_kserdes_override_tap_offset_cdfe(sregs, lane, 5, 6, ofs->tap5);
+	_kserdes_set_coef_ofs(sregs, lane, 1, 7, ofs->coef1);
+	_kserdes_set_coef_ofs(sregs, lane, 2, 6, ofs->coef2);
+	_kserdes_set_coef_ofs(sregs, lane, 3, 6, ofs->coef3);
+	_kserdes_set_coef_ofs(sregs, lane, 4, 6, ofs->coef4);
+	_kserdes_set_coef_ofs(sregs, lane, 5, 6, ofs->coef5);
 
 	FINSR(sregs, LANEX_REG(lane, 0x58), 16, 16, 0x0);
 	FINSR(sregs, LANEX_REG(lane, 0x48), 16, 16, 0x0);
@@ -1042,71 +1023,65 @@ _kserdes_override_cmp_tap_offsets_cdfe(void __iomem *sregs, u32 lane, u32 cmp,
 	FINSR(sregs, LANEX_REG(lane, 0x58), 17, 17, 0x0);
 }
 
-static void kserdes_set_offsets_xge(struct kserdes_config *sc,
-				    struct kserdes_offsets *sofs)
+static void kserdes_set_ofs_xge(struct kserdes_config *sc,
+				struct kserdes_ofs *sofs)
 {
-	struct kserdes_cmp_tap_ofs *ctofs;
-	struct kserdes_lane_offsets *lofs;
-	u32 lane, cmp;
+	struct kserdes_cmp_coef_ofs *ctofs;
+	struct kserdes_lane_ofs *lofs;
+	int lane, cmp;
 
-	for_each_lane(sc, lane) {
+	for_each_enable_lane(sc, lane) {
 		lofs = &sofs->lane_ofs[lane];
-		for_each_comparator(cmp) {
+		for_each_cmp(cmp) {
 			ctofs = &lofs->ct_ofs[cmp];
-			_kserdes_override_cmp_tap_offsets(sc->regs, lane,
-							  cmp, ctofs);
-			_kserdes_override_cmp_tap_offsets_cdfe(sc->regs, lane,
-							       cmp, ctofs);
+			_kserdes_set_ofs(sc->regs, lane, cmp, ctofs);
+			_kserdes_set_ofs_phyb(sc->regs, lane, cmp, ctofs);
 		}
 	}
 }
 
-static void kserdes_set_offsets_non_xge(struct kserdes_config *sc,
-					struct kserdes_offsets *sofs)
+static void kserdes_set_ofs_non_xge(struct kserdes_config *sc,
+				    struct kserdes_ofs *sofs)
 {
-	struct kserdes_cmp_tap_ofs *ctofs;
-	struct kserdes_lane_offsets *lofs;
+	struct kserdes_cmp_coef_ofs *ctofs;
+	struct kserdes_lane_ofs *lofs;
 	u32 lane, cmp;
 
-	for_each_lane(sc, lane) {
+	for_each_enable_lane(sc, lane) {
 		lofs = &sofs->lane_ofs[lane];
-		for_each_comparator(cmp) {
+		for_each_cmp(cmp) {
 			ctofs = &lofs->ct_ofs[cmp];
-			_kserdes_override_cmp_tap_offsets(sc->regs, lane,
-							  cmp, ctofs);
+			_kserdes_set_ofs(sc->regs, lane, cmp, ctofs);
 		}
 	}
 }
 
-static void kserdes_set_offsets(struct kserdes_config *sc,
-				struct kserdes_offsets *sofs)
+static void kserdes_set_average_ofs(struct kserdes_config *sc,
+				    struct kserdes_ofs *sofs)
 {
 	if (sc->phy_type == KSERDES_PHY_XGE)
-		kserdes_set_offsets_xge(sc, sofs);
+		kserdes_set_ofs_xge(sc, sofs);
 	else
-		kserdes_set_offsets_non_xge(sc, sofs);
+		kserdes_set_ofs_non_xge(sc, sofs);
 }
 
-static void kserdes_phyb_init_cfg(struct kserdes_config *sc,
-					   struct kserdes_offsets *sofs)
+static void kserdes_phyb_init_config(struct kserdes_config *sc,
+				     struct kserdes_ofs *sofs)
 {
 	int lane;
 
 	for_each_enable_lane(sc, lane)
 		kserdes_force_signal_detect_low(sc, lane);
 
-	/* amount of time to sleep is by experiment */
 	usleep_range(10, 20);
 
-	kserdes_get_average_offsets(sc, OFFSET_SAMPLES, sofs);
-	kserdes_set_offsets(sc, sofs);
-	/* amount of time to sleep is by experiment */
+	kserdes_get_average_ofs(sc, OFFSET_SAMPLES, sofs);
+	kserdes_set_average_ofs(sc, sofs);
 	usleep_range(10, 20);
 
-	for_each_lane(sc, lane)
+	for_each_enable_lane(sc, lane)
 		kserdes_force_signal_detect_high(sc, lane);
 
-	/* amount of time to sleep is by experiment */
 	usleep_range(10, 20);
 }
 
@@ -1130,181 +1105,476 @@ static int kserdes_wait_lane_rx_valid(struct kserdes_config *sc, u32 lane)
 	} while (true);
 }
 
-static int kserdes_att_phya_cfg(struct kserdes_config *sc)
+static inline void _kserdes_reset(void __iomem *sregs)
 {
-	u32 i, att_read[KSERDES_MAX_LANES], att_start[KSERDES_MAX_LANES];
-	int ret;
+	FINSR(sregs, CPU_CTRL_REG, 29, 29, 0x1);
+	usleep_range(10, 20);
+	FINSR(sregs, CPU_CTRL_REG, 29, 29, 0x0);
+	usleep_range(10, 20);
+}
 
-	for_each_lane(sc, i) {
-		att_start[i] = kserdes_readl(sc->regs, LANEX_REG(i, 0x8c));
-		att_start[i] = (att_start[i] >> 8) & 0xf;
-	}
+static inline void kserdes_xge_pll_enable(struct kserdes_config *sc)
+{
+	if (!sc->firmware)
+		FINSR(sc->regs, CML_REG(0), 7, 0, 0x1f);
 
-	for_each_lane(sc, i) {
-		att_read[i] = _kserdes_read_select_tbus(
-					sc->regs, i + 1,
-					(sc->phy_type == KSERDES_PHY_XGE) ?
-					0x10 : 0x11);
-		att_read[i] = (att_read[i] >> 4) & 0xf;
+	if (sc->link_rate == KSERDES_LINK_RATE_10P3125G) {
+		_kserdes_pll_enable(sc->regs);
+		_kserdes_pll2_enable(sc->regs);
+	} else if (sc->link_rate == KSERDES_LINK_RATE_1P25G) {
+		kserdes_writel(sc->regs, PLL_CTRL_REG, PLL_ENABLE_1P25G);
 	}
+}
 
-	for_each_lane(sc, i) {
-		FINSR(sc->regs, LANEX_REG(i, 0x8c), 11, 8, att_read[i]);
-	}
+static inline void _kserdes_enable_xgmii_port(struct regmap *peripheral_regmap,
+					      u32 port)
+{
+	regmap_update_bits(peripheral_regmap, XGE_CTRL_OFFSET,
+			   GENMASK(port, port), BIT(port));
+}
+
+static inline void _kserdes_reset_rx(void __iomem *sregs, int lane)
+{
+	_kserdes_force_signal_detect_low(sregs, lane);
+	usleep_range(1000, 2000);
+	_kserdes_force_signal_detect_high(sregs, lane);
+}
+
+static int kserdes_check_link_status(struct kserdes_config *sc,
+				     u32 *current_lane_state,
+				     u32 lanes_chk_mask,
+				     u32 *lanes_up_mask)
+{
+	struct device *dev = sc->dev;
+	u32 pcsr_rx_stat, blk_lock, blk_errs;
+	int loss, i, link_up = 1;
+	int ret;
+	unsigned long lmask = (unsigned long)lanes_chk_mask;
 
-	FINSR(sc->regs, CML_REG(0x84), 0, 0, 0x0);
-	FINSR(sc->regs, CML_REG(0x8c), 24, 24, 0x0);
+	for_each_set_bit(i, &lmask, 8) {
+		loss = (kserdes_readl(sc->regs, LANE_CTRL_STS_REG(i))) & 0x01;
 
-	FINSR(sc->regs, CML_REG(0x98), 7, 7, 0x1);
-	FINSR(sc->regs, CML_REG(0x98), 7, 7, 0x0);
-	usleep_range(300, 400);
+		ret = regmap_read(sc->pcsr_regmap, PCSR_RX_STATUS(i),
+				  &pcsr_rx_stat);
 
-	for_each_enable_lane(sc, i) {
-		ret = kserdes_wait_lane_rx_valid(sc, i);
-		if (ret) {
-			dev_err(sc->dev, "lane %d wait rx valid failed: %d\n",
-				i, ret);
+		if (ret)
 			return ret;
+
+		blk_lock = (pcsr_rx_stat >> 30) & 0x1;
+		blk_errs = (pcsr_rx_stat >> 16) & 0x0ff;
+
+		if (blk_errs)
+			blk_lock = 0;
+
+		switch (current_lane_state[i]) {
+		case 0:
+			if (!loss && blk_lock) {
+				dev_dbg(dev, "XGE PCSR Linked Lane: %d\n", i);
+				FINSR(sc->regs, LANEX_REG(i, 0x04), 2, 1, 0);
+				current_lane_state[i] = 1;
+			} else if (!blk_lock) {
+				dev_dbg(dev,
+					"XGE PCSR Recover Lane: %d\n", i);
+				_kserdes_reset_rx(sc->regs, i);
+			}
+			break;
+		case 1:
+			if (!blk_lock)
+				current_lane_state[i] = 2;
+
+			break;
+		case 2:
+			if (blk_lock) {
+				current_lane_state[i] = 1;
+			} else {
+				_kserdes_reset_rx(sc->regs, i);
+				current_lane_state[i] = 0;
+			}
+			break;
+		default:
+			dev_info(dev,
+				 "XGE: unknown current_lane_state[%d] %d\n",
+				 i, current_lane_state[i]);
+			break;
 		}
-	}
 
-	for_each_lane(sc, i)
-		FINSR(sc->regs, LANEX_REG(i, 0x8c), 11, 8, att_start[i]);
+		if (blk_errs) {
+			regmap_update_bits(sc->pcsr_regmap, PCSR_RX_CTL(i),
+					   GENMASK(7, 0), 0x19);
+			regmap_update_bits(sc->pcsr_regmap, PCSR_RX_CTL(i),
+					   GENMASK(7, 0), 0x00);
+		}
 
-	FINSR(sc->regs, CML_REG(0x84),  0,  0, 0x1);
-	FINSR(sc->regs, CML_REG(0x8c), 24, 24, 0x1);
+		if (current_lane_state[i] == 1) {
+			*lanes_up_mask |= BIT(i);
+		} else {
+			*lanes_up_mask &= ~BIT(i);
+			link_up = 0;
+		}
+	}
 
-	return 0;
+	return link_up;
 }
 
-static int kserdes_boost_phya_cfg(struct kserdes_config *sc,
-					     u32 lane)
+static int kserdes_wait_link_up(struct kserdes_config *sc,
+				u32 lanes_chk_mask,
+				u32 *lanes_up_mask)
 {
-	u32 boost_read;
-	int ret;
-
-	ret = kserdes_wait_lane_rx_valid(sc, lane);
-	if (ret) {
-		dev_err(sc->dev, "lane %d wait rx valid failed: %d\n",
-			lane, ret);
-		return ret;
-	}
+	u32 current_state[KSERDES_MAX_LANES];
+	unsigned long time_check = 0;
+	int i, link_up, ret = 0;
 
-	boost_read = _kserdes_read_select_tbus(
-				sc->regs, lane + 1,
-				(sc->phy_type == KSERDES_PHY_XGE) ?
-				0x10 : 0x11);
-	boost_read = (boost_read >> 8) & 0xf;
+	memset(current_state, 0, sizeof(current_state));
 
-	if (!boost_read) {
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  2,  2, 0x1);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 18, 12, 0x2);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  9,  3, 0x1);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 10, 10, 0x1);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 10, 10, 0x0);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  2,  2, 0x0);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 18, 12, 0x0);
-		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  9,  3, 0x0);
+	do {
+		usleep_range(10000, 20000);
+		link_up = kserdes_check_link_status(sc, current_state,
+						    lanes_chk_mask,
+						    lanes_up_mask);
+
+		if (link_up)
+			break;
+
+		for_each_enable_lane(sc, i) {
+			if (!(*lanes_up_mask & BIT(i))) {
+				dev_dbg(sc->dev,
+					"XGE: detected lane %d down\n", i);
+			}
+		}
+
+		if (++time_check >= 200) {
+			ret = -ETIMEDOUT;
+			break;
+		}
+
+	} while (1);
+
+	return ret;
+}
+
+static inline void kserdes_xfw_get_lane_params(struct kserdes_config *sc,
+					       int lane)
+{
+	struct kserdes_fw_config *fw = &sc->fw;
+	u32 tx_ctrl, val_0, val_1;
+	u32 phy_a = PHY_A(sc->regs);
+
+	val_0 = kserdes_readl(sc->regs, LANEX_REG(lane, 0x04));
+	val_1 = kserdes_readl(sc->regs, LANEX_REG(lane, 0x08));
+
+	tx_ctrl = ((((val_0 >> 18) & 0x1)    << 24) |
+		   (((val_1 >> 0)  & 0xffff) <<  8) |
+		   (((val_0 >> 24) & 0xff)   <<  0));
+
+	if (phy_a) {
+		fw->cm = (val_1 >> 12) & 0xf;
+		fw->c1 = (val_1 >> 0) & 0x1f;
+		fw->c2 = (val_1 >> 8) & 0xf;
+	} else {
+		fw->cm = (tx_ctrl >> 16) & 0xf;
+		fw->c1 = (tx_ctrl >> 8) & 0x1f;
+		fw->c2 = (tx_ctrl >> 13) & 0x7;
+		fw->c2 = fw->c2 | (((tx_ctrl >> 24) & 0x1) << 3);
 	}
-	return 0;
+
+	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1,
+					  (phy_a ? 0x11 : 0x10));
+	fw->attn = (val_0 >> 4) & 0xf;
+	fw->boost = (val_0 >> 8) & 0xf;
+
+	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1, 0x5);
+	fw->dlpf = (val_0 >> 2) & 0x3ff;
+
+	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1, 0x6);
+	fw->rxcal = (val_0 >> 3) & 0xff;
 }
 
-static inline void kserdes_rx_att_boost_phya_cfg(struct kserdes_config *sc)
+static inline void kserdes_xfw_mem_init(struct kserdes_config *sc)
 {
-	int lane;
+	struct kserdes_fw_config *fw = &sc->fw;
+	u32 i, lane_config = 0;
 
-	kserdes_att_phya_cfg(sc);
+	for_each_lane(sc, i)
+		lane_config = (lane_config << 8) | (fw->lane_config[i] & 0xff);
 
-	for_each_enable_lane(sc, lane)
-		kserdes_boost_phya_cfg(sc, lane);
+	lane_config <<= 8;
+
+	kserdes_writel(sc->regs, MEM_ADR_REG, KSERDES_XFW_CONFIG_START_ADDR);
+
+	for (i = KSERDES_XFW_CONFIG_START_ADDR;
+	     i < KSERDES_XFW_PARAM_START_ADDR; i += 4)
+		kserdes_writel(sc->regs, MEM_DATINC_REG, 0x00000000);
+
+	kserdes_writel(sc->regs, MEM_DATINC_REG, XFM_FLUSH_CMD);
+	kserdes_writel(sc->regs, MEM_DATINC_REG, fw->fast_train);
+	kserdes_writel(sc->regs, MEM_DATINC_REG, 0x00000000);
+	kserdes_writel(sc->regs, MEM_DATINC_REG, fw->lane_seeds);
+	kserdes_writel(sc->regs, MEM_DATINC_REG, lane_config);
 }
 
-static void kserdes_rx_att_boost_phyb_cfg(struct kserdes_config *sc,
-					      u32 lane)
+static int kserdes_pcie_lanes_enable(struct kserdes_config *sc)
 {
-	u32 tbus_ofs, rxeq_init_reg_ofs, rxeq_ln_reg_ofs, rxeq_ln_force_bit;
-	void __iomem *sregs = sc->regs;
-	u32 att_start, att_read, boost_read;
-	int ret;
+	int ret, i;
+	u32 lanes_enable = 0;
 
-	if (sc->phy_type == KSERDES_PHY_XGE) {
-		tbus_ofs = 0x10;
-		rxeq_init_reg_ofs = 0x9c;
-		rxeq_ln_reg_ofs = 0x98;
-		rxeq_ln_force_bit = 14;
-	} else {
-		tbus_ofs = 0x11;
-		rxeq_init_reg_ofs = 0x84;
-		rxeq_ln_reg_ofs = 0xac;
-		rxeq_ln_force_bit = 11;
+	for_each_enable_lane(sc, i)
+		lanes_enable |= BIT(i);
+
+	for_each_lane(sc, i) {
+		kserdes_release_reset(sc, i);
+
+		if (sc->lane[i].loopback)
+			_kserdes_set_lane_loopback(sc->regs, i, sc->phy_type);
 	}
 
-	att_start = kserdes_readl(sregs, LANEX_REG(lane, 0x8c));
-	att_start = (att_start >> 8) & 0xf;
+	ret = kserdes_get_status(sc);
+	if (ret)
+		return ret;
 
-	att_read = _kserdes_read_select_tbus(sregs, lane + 1, tbus_ofs);
-	att_read = (att_read >> 4) & 0xf;
+	return lanes_enable;
+}
 
-	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att_read);
-	FINSR(sregs, LANEX_REG(lane, rxeq_init_reg_ofs), 0, 0, 0x0);
-	FINSR(sregs, CML_REG(0x8c), 24, 24, 0x0);
+static void kserdes_clear_wait_after(struct kserdes_config *sc,
+				     unsigned long lanes_mask)
+{
+	u32 lane;
 
-	FINSR(sregs, LANEX_REG(lane, rxeq_ln_reg_ofs),
-	      rxeq_ln_force_bit, rxeq_ln_force_bit, 0x1);
-	FINSR(sregs, LANEX_REG(lane, rxeq_ln_reg_ofs),
-	      rxeq_ln_force_bit, rxeq_ln_force_bit, 0x0);
+	if (!sc->rx_force_enable) {
+		for_each_set_bit(lane, &lanes_mask, 8) {
+			if (!LANE_ENABLE(sc, lane))
+				continue;
 
-	ret = kserdes_wait_lane_rx_valid(sc, lane);
-	if (ret) {
-		dev_err(sc->dev, "lane %d wait rx valid failed: %d\n",
-			lane, ret);
+			_kserdes_clear_lane_wait_after(sc->regs, lane);
+		}
+	} else {
+		_kserdes_clear_wait_after(sc->regs);
 	}
-	/* amount of time to sleep is by experiment */
-	usleep_range(300, 400);
+}
 
-	boost_read = _kserdes_read_select_tbus(sregs, lane + 1, tbus_ofs);
-	boost_read = (boost_read >> 8) & 0xf;
+static int kserdes_check_lanes_status(struct kserdes_config *sc)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long time_check;
+	u32 val, i;
+
+	do {
+		time_check = jiffies;
+		val = 1;
+
+		for_each_enable_lane(sc, i)
+			val &= _kserdes_get_lane_status(sc->regs, i,
+							sc->phy_type);
+
+		if (val)
+			break;
+
+		if (time_after(time_check, timeout))
+			return -ETIMEDOUT;
+
+		cpu_relax();
+	} while (true);
+
+	return 0;
+}
+
+static void kserdes_phya_init_config(struct kserdes_config *sc, u32 lane)
+{
+	u32 coef1val, coef2val, coef3val, coef4val, coef5val;
+	void __iomem *sregs = sc->regs;
+	u32 cmp, coef1_ofs;
+
+	for_each_cmp(cmp) {
+		if (!(cmp & 0x1))
+			continue;
+
+		FINSR(sregs, CML_REG(0x8c), 23, 21, cmp);
+
+		FINSR(sregs, CMU0_REG(0x8), 31, 24, ((lane + 1) << 5) + 0x12);
+		coef1_ofs = (_kserdes_read_tbus_val(sregs) & 0x000f) << 3;
+
+		FINSR(sregs, CMU0_REG(0x8), 31, 24, ((lane + 1) << 5) + 0x13);
+		coef1_ofs |= (_kserdes_read_tbus_val(sregs) & 0x0e00) >> 9;
+
+		coef1val = coef1_ofs - 14;
+		coef2val = 31;
+		coef3val = 31;
+		coef4val = 31;
+		coef5val = 31;
+
+		FINSR(sregs, CML_REG(0xf0), 27, 26, lane + 1);
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 2, 2, 0x1);
+		FINSR(sregs, LANEX_REG(lane, 0x30), 7, 5, cmp);
+		FINSR(sregs, LANEX_REG(lane, 0x5c), 31, 31, 0x1);
+
+		FINSR(sregs, LANEX_REG(lane, 0x58), 30, 24, coef1val);
+		FINSR(sregs, LANEX_REG(lane, 0x5c),  6,  0, coef2val);
+		FINSR(sregs, LANEX_REG(lane, 0x5c), 13,  8, coef3val);
+		FINSR(sregs, LANEX_REG(lane, 0x5c), 21, 16, coef4val);
+		FINSR(sregs, LANEX_REG(lane, 0x5c), 29, 24, coef5val);
 
-	if (!boost_read) {
-		FINSR(sregs, LANEX_REG(lane, 0x2c),  2,  2, 0x1);
-		FINSR(sregs, LANEX_REG(lane, 0x2c), 18, 12, 0x2);
-		FINSR(sregs, LANEX_REG(lane, 0x2c),  9,  3, 0x1);
 		FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x1);
 		FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x0);
-		FINSR(sregs, LANEX_REG(lane, 0x2c),  2,  2, 0x0);
-		FINSR(sregs, LANEX_REG(lane, 0x2c), 18, 12, 0x0);
-		FINSR(sregs, LANEX_REG(lane, 0x2c),  9,  3, 0x0);
+
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 2, 2, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x5c), 31, 31, 0x0);
+
+		FINSR(sregs, LANEX_REG(lane, 0x58), 16, 16, 0x1);
+		FINSR(sregs, LANEX_REG(lane, 0x48), 16, 16, 0x1);
+
+		FINSR(sregs, LANEX_REG(lane, 0x4c), 5, 2, (0x1 << (cmp - 1)));
+		FINSR(sregs, LANEX_REG(lane, 0x58), 17, 17, 0x1);
+
+		_kserdes_set_coef_ofs(sregs, lane, 1, 7, coef1val);
+		_kserdes_set_coef_ofs(sregs, lane, 2, 6, coef2val);
+		_kserdes_set_coef_ofs(sregs, lane, 3, 6, coef3val);
+		_kserdes_set_coef_ofs(sregs, lane, 4, 6, coef4val);
+		_kserdes_set_coef_ofs(sregs, lane, 5, 6, coef5val);
+
+		FINSR(sregs, LANEX_REG(lane, 0x58), 16, 16, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x48), 16, 16, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x58), 17, 17, 0x0);
 	}
+}
 
-	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att_start);
-	FINSR(sregs, LANEX_REG(lane, rxeq_init_reg_ofs), 0, 0, 0x1);
-	FINSR(sregs, CML_REG(0x8c), 24, 24, 0x1);
+static int kserdes_check_pll_status(struct kserdes_config *sc)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long time_check;
+	u32 val;
+
+	do {
+		time_check = jiffies;
+		val = _kserdes_get_pll_status(sc->regs);
+
+		if (sc->phy_type == KSERDES_PHY_XGE)
+			val &= _kserdes_get_pll2_status(sc->regs);
+
+		if (val)
+			break;
+
+		if (time_after(time_check, timeout))
+			return -ETIMEDOUT;
+
+		cpu_relax();
+	} while (true);
+
+	return 0;
 }
 
-static void kserdes_rx_att_boost_cfg(struct kserdes_config *sc)
+static void kserdes_enable_common_set_lane_rate(struct kserdes_config *sc,
+						u32 lane)
 {
-	int lane;
+	int ret;
+
+	ret = _kserdes_set_lane_ctrl_rate(sc->regs, lane,
+					  sc->lane[lane].ctrl_rate);
+	if (ret) {
+		dev_err(sc->dev, "set_lane_rate FAILED: lane = %d err = %d\n",
+			lane, ret);
+		return;
+	}
+
+	switch (sc->phy_type) {
+	case KSERDES_PHY_SGMII:
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane),  7,  6, 0x3);
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 23, 21, 0x4);
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane),  5,  3, 0x4);
+		break;
+
+	case KSERDES_PHY_XGE:
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 23, 21, 0x7);
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane),  5,  3, 0x7);
+		if (sc->link_rate == KSERDES_LINK_RATE_10P3125G) {
+			FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 16, 16, 0x1);
+			FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 19, 19, 0x1);
+		}
+		break;
+
+	case KSERDES_PHY_PCIE:
+		break;
+
+	default:
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane), 23, 21, 0x6);
+		FINSR(sc->regs, LANE_CTRL_STS_REG(lane),  5,  3, 0x6);
+		break;
+	}
+
+	if (sc->lane[lane].loopback)
+		_kserdes_set_lane_loopback(sc->regs, lane, sc->phy_type);
 
 	if (sc->phy_type != KSERDES_PHY_XGE) {
-		kserdes_rx_att_boost_phya_cfg(sc);
-	} else {
-		for_each_lane(sc, lane)
-			kserdes_rx_att_boost_phyb_cfg(sc, lane);
+		FINSR(sc->regs, LANEX_REG(lane, 0x30), 11, 11, 0x1);
+		FINSR(sc->regs, LANEX_REG(lane, 0x30), 13, 12, 0x0);
 	}
 }
 
-static int kserdes_sgmii_lanes_enable(struct kserdes_config *sc)
+static inline void kserdes_set_lane_rx_starts(struct kserdes_config *sc,
+					      u32 lane)
 {
-	int ret, i;
-	u32 val, lanes_enable = 0;
+	FINSR(sc->regs, LANEX_REG(lane, 0x8c), 11, 8,
+	      sc->lane[lane].rx_start.att);
+	FINSR(sc->regs, LANEX_REG(lane, 0x8c), 15, 12,
+	      sc->lane[lane].rx_start.boost);
 
-	for_each_enable_lane(sc, i)
-		lanes_enable |= (1 << i);
+	FINSR(sc->regs, LANEX_REG(lane, 0x84), 27, 24,
+	      sc->lane[lane].rx_start.att);
+	FINSR(sc->regs, LANEX_REG(lane, 0x84), 31, 28,
+	      sc->lane[lane].rx_start.boost);
 
-	for_each_lane(sc, i)
+	FINSR(sc->regs, LANEX_REG(lane, 0x84), 19, 16,
+	      sc->lane[lane].rx_start.att);
+	FINSR(sc->regs, LANEX_REG(lane, 0x84), 23, 20,
+	      sc->lane[lane].rx_start.boost);
+}
+
+static void kserdes_hs_init_config(struct kserdes_config *sc)
+{
+	int i;
+
+	if (sc->phy_type != KSERDES_PHY_XGE) {
+		if (sc->link_rate >= KSERDES_LINK_RATE_9P8304G)
+			FINSR(sc->regs, CML_REG(0xbc), 28, 24, 0x1e);
+	}
+
+	for_each_enable_lane(sc, i)
 		kserdes_set_tx_idle(sc, i);
 
-	kserdes_highspeed_cfg(sc);
+	if (sc->link_rate >= KSERDES_LINK_RATE_9P8304G) {
+		if (sc->phy_type != KSERDES_PHY_XGE) {
+			for_each_enable_lane(sc, i)
+				kserdes_force_signal_detect_low(sc, i);
+
+			for_each_enable_lane(sc, i)
+				FINSR(sc->regs, LANEX_REG(i, 0x78),
+				      30, 24, 0x7f);
+		} else {
+			FINSR(sc->regs, CML_REG(0x10c), 7, 0, 0xff);
+		}
+	}
+}
+
+static int kserdes_lanes_enable_common(struct kserdes_config *sc,
+				       struct kserdes_ofs *sofs)
+{
+	u32 val, lane_mask = 0;
+	int i, ret;
+
+	for_each_lane(sc, i) {
+		if (sc->lane[i].enable)
+			lane_mask |= BIT(i);
+		else
+			sc->lane[i].enable = 1;
+	}
+
+	if (sc->phy_type == KSERDES_PHY_PCIE) {
+		dev_err(sc->dev, "kserdes_lanes_enable_common: pcie TBD.\n");
+		return -EINVAL;
+	}
+
+	kserdes_hs_init_config(sc);
+
+	for_each_enable_lane(sc, i)
+		kserdes_set_lane_rx_starts(sc, i);
 
 	kserdes_assert_reset(sc);
 
@@ -1321,356 +1591,482 @@ static int kserdes_sgmii_lanes_enable(struct kserdes_config *sc)
 	}
 
 	for_each_enable_lane(sc, i)
-		kserdes_set_lane_rate(sc, i);
+		kserdes_enable_common_set_lane_rate(sc, i);
 
-	_kserdes_pll_enable(sc->regs);
+	if (sc->phy_type == KSERDES_PHY_XGE)
+		kserdes_xge_pll_enable(sc);
+	else
+		_kserdes_pll_enable(sc->regs);
 
-	ret = kserdes_get_status(sc);
+	ret = kserdes_check_pll_status(sc);
 	if (ret) {
-		dev_err(sc->dev, "kserdes_get_status FAILED %d\n", ret);
+		dev_err(sc->dev,
+			"common init: check pll status FAILED %d\n", ret);
 		return ret;
 	}
 
-	val = _kserdes_get_tx_termination(sc->regs, 0, sc->phy_type);
+	for_each_enable_lane(sc, i)
+		_kserdes_lane_enable(sc->regs, i);
 
-	kserdes_set_tx_terminations(sc, val);
+	ret = kserdes_check_lanes_status(sc);
+	if (ret) {
+		dev_err(sc->dev,
+			"common init: check lanes status FAILED %d\n", ret);
+		return ret;
+	}
 
-	for_each_enable_lane(sc, i)
-		kserdes_clr_tx_idle(sc, i);
+	usleep_range(5, 10);
 
-	for_each_enable_lane(sc, i)
-		kserdes_force_signal_detect_high(sc, i);
+	val = _kserdes_get_tx_termination(sc->regs, sc->phy_type);
 
-	for_each_enable_lane(sc, i) {
-		ret = kserdes_wait_lane_rx_valid(sc, i);
-		if (ret) {
-			dev_err(sc->dev, "lane %d wait rx valid failed: %d\n",
-				i, ret);
-			return ret;
-		}
-	}
+	kserdes_set_tx_terminations(sc, val);
 
-	if (!sc->rx_force_enable)
-		kserdes_rx_att_boost_cfg(sc);
+	if (sc->phy_type == KSERDES_PHY_XGE)
+		kserdes_phyb_init_config(sc, sofs);
+	else if (sc->link_rate >= KSERDES_LINK_RATE_9P8304G)
+		for_each_enable_lane(sc, i)
+			kserdes_phya_init_config(sc, i);
 
-	_kserdes_clear_wait_after(sc->regs);
+	for_each_enable_lane(sc, i)
+		kserdes_clr_tx_idle(sc, i);
 
-	return lanes_enable;
-}
+	for_each_lane(sc, i)
+		sc->lane[i].enable = (lane_mask & BIT(i)) >> i;
 
-static int kserdes_sgmii_init(struct kserdes_config *sc)
-{
-	return kserdes_load_init_fw(sc, ks2_gbe_serdes_firmwares,
-				    ARRAY_SIZE(ks2_gbe_serdes_firmwares));
+	return 0;
 }
 
-static inline void _kserdes_set_link_loss_wait(void __iomem *sregs,
-					       u32 link_loss_wait)
+static inline u32 _kserdes_get_lane_sd(void __iomem *sregs, u32 lane)
 {
-	kserdes_writel(sregs, LINK_LOSS_WAIT_REG, link_loss_wait);
+	return FEXTR(kserdes_readl(sregs, PLL_CTRL_REG), lane, lane);
 }
 
-static inline void _kserdes_reset(void __iomem *sregs)
+static int _kserdes_wait_lane_sd(void __iomem *sregs, u32 lane)
 {
-	FINSR(sregs, CPU_CTRL_REG, 29, 29, 0x1);
-	/* amount of time to sleep is by experiment */
-	usleep_range(10, 20);
-	FINSR(sregs, CPU_CTRL_REG, 29, 29, 0x0);
-	/* amount of time to sleep is by experiment */
-	usleep_range(10, 20);
-}
+	unsigned long timeout = jiffies + msecs_to_jiffies(500);
+	unsigned long time_check;
 
-static inline void kserdes_xge_pll_enable(struct kserdes_config *sc)
-{
-	if (!sc->firmware)
-		FINSR(sc->regs, CML_REG(0), 7, 0, 0x1f);
+	do {
+		time_check = jiffies;
 
-	if (sc->link_rate == KSERDES_LINK_RATE_10P3125G) {
-		_kserdes_pll_enable(sc->regs);
-		_kserdes_pll2_enable(sc->regs);
-	} else if (sc->link_rate == KSERDES_LINK_RATE_1P25G) {
-		kserdes_writel(sc->regs, PLL_CTRL_REG, PLL_ENABLE_1P25G);
-	}
-}
+		if (_kserdes_get_lane_sd(sregs, lane))
+			break;
 
-static inline void _kserdes_xge_enable_pcs(void __iomem *sregs, u32 lane)
-{
-	FINSR(sregs, LANE_CTRL_STS_REG(lane), 23, 21, 0x7);
-	FINSR(sregs, LANE_CTRL_STS_REG(lane),  5,  3, 0x7);
+		if (time_after(time_check, timeout))
+			return -ETIMEDOUT;
 
-	FINSR(sregs, LANE_CTRL_STS_REG(lane), 16, 16, 0x1);
-	FINSR(sregs, LANE_CTRL_STS_REG(lane), 19, 19, 0x1);
+		cpu_relax();
+	} while (true);
+
+	return 0;
 }
 
-static inline void kserdes_xge_lane_enable(struct kserdes_config *sc, u32 lane)
+static void kserdes_rx_att_boost_config_phyb(struct kserdes_config *sc,
+					     u32 lane)
 {
-	u32 lane_ctrl_rate = sc->lane[lane].ctrl_rate;
+	u32 tbus_ofs, rxeq_init_reg_ofs, rxeq_ln_reg_ofs, rxeq_ln_force_bit;
+	void __iomem *sregs = sc->regs;
+	u32 att_start, att_read, boost_read;
+	int ret;
 
-	if (sc->link_rate == KSERDES_LINK_RATE_10P3125G)
-		_kserdes_set_lane_ctrl_rate(sc->regs, lane, lane_ctrl_rate);
-	else if (sc->link_rate == KSERDES_LINK_RATE_1P25G)
-		kserdes_writel(sc->regs, LANE_CTRL_STS_REG(lane),
-			       LANE_CTRL_1P25G);
+	if (sc->phy_type == KSERDES_PHY_XGE) {
+		tbus_ofs = 0x10;
+		rxeq_init_reg_ofs = 0x9c;
+		rxeq_ln_reg_ofs = 0x98;
+		rxeq_ln_force_bit = 14;
+	} else {
+		tbus_ofs = 0x11;
+		rxeq_init_reg_ofs = 0x84;
+		rxeq_ln_reg_ofs = 0xac;
+		rxeq_ln_force_bit = 11;
+	}
 
-	_kserdes_xge_enable_pcs(sc->regs, lane);
+	att_start = kserdes_readl(sregs, LANEX_REG(lane, 0x8c));
+	att_start = (att_start >> 8) & 0xf;
 
-	_kserdes_lane_enable(sc->regs, lane);
+	att_read = _kserdes_read_select_tbus(sregs, lane + 1, tbus_ofs);
+	att_read = (att_read >> 4) & 0xf;
 
-	if (sc->lane[lane].loopback)
-		_kserdes_set_lane_loopback(sc->regs, lane, sc->link_rate);
-}
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att_read);
+	FINSR(sregs, LANEX_REG(lane, rxeq_init_reg_ofs), 0, 0, 0x0);
+	FINSR(sregs, CML_REG(0x8c), 24, 24, 0x0);
 
-static inline void _kserdes_enable_xgmii_port(struct regmap *peripheral_regmap,
-					      u32 port)
-{
-	regmap_update_bits(peripheral_regmap, XGE_CTRL_OFFSET,
-			   GENMASK(port, port), BIT(port));
-}
+	FINSR(sregs, LANEX_REG(lane, rxeq_ln_reg_ofs),
+	      rxeq_ln_force_bit, rxeq_ln_force_bit, 0x1);
+	FINSR(sregs, LANEX_REG(lane, rxeq_ln_reg_ofs),
+	      rxeq_ln_force_bit, rxeq_ln_force_bit, 0x0);
 
-static inline void _kserdes_reset_rx(void __iomem *sregs, int lane)
-{
-	_kserdes_force_signal_detect_low(sregs, lane);
-	/* amount of time to sleep is by experiment */
-	usleep_range(1000, 2000);
-	_kserdes_force_signal_detect_high(sregs, lane);
+	ret = kserdes_wait_lane_rx_valid(sc, lane);
+	if (ret) {
+		dev_dbg(sc->dev, "kserdes_wait_lane_rx_valid %d FAILED: %d\n",
+			lane, ret);
+	}
+	usleep_range(300, 600);
+
+	boost_read = _kserdes_read_select_tbus(sregs, lane + 1, tbus_ofs);
+	boost_read = (boost_read >> 8) & 0xf;
+
+	if (!boost_read) {
+		FINSR(sregs, LANEX_REG(lane, 0x2c),  2,  2, 0x1);
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 18, 12, 0x2);
+		FINSR(sregs, LANEX_REG(lane, 0x2c),  9,  3, 0x1);
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x1);
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 10, 10, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x2c),  2,  2, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x2c), 18, 12, 0x0);
+		FINSR(sregs, LANEX_REG(lane, 0x2c),  9,  3, 0x0);
+	}
+
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att_start);
+	FINSR(sregs, LANEX_REG(lane, rxeq_init_reg_ofs), 0, 0, 0x1);
+	FINSR(sregs, CML_REG(0x8c), 24, 24, 0x1);
 }
 
-/* Call every 10 ms */
-static int kserdes_check_link_status(struct kserdes_config *sc,
-				     u32 *current_state, u32 *lanes_up_map)
+static int kserdes_set_dlev_patt_adapt(struct kserdes_config *sc,
+				       u32 lane, u32 pattern,
+				       struct kserdes_lane_ofs *lofs)
 {
-	u32 pcsr_rx_stat, blk_lock, blk_errs;
-	int loss, i, status = 1;
+	struct kserdes_cmp_coef_ofs *ctofs = &lofs->ct_ofs[4];
+	void __iomem *sregs = sc->regs;
+	u32 dlevp, dlevn, dlevavg;
 	int ret;
 
-	for_each_enable_lane(sc, i) {
-		loss = (kserdes_readl(sc->regs, LANE_CTRL_STS_REG(i))) & 0x01;
+	FINSR(sregs, CML_REG(0x158), 14, 8, pattern);
+	FINSR(sregs, LANEX_REG(lane, 0x98), 14, 14, 1);
+	FINSR(sregs, LANEX_REG(lane, 0x98), 14, 14, 0);
 
-		ret = regmap_read(sc->pcsr_regmap, PCSR_RX_STATUS(i),
-				  &pcsr_rx_stat);
+	ret = kserdes_wait_lane_rx_valid(sc, lane);
+	if (ret) {
+		dev_dbg(sc->dev,
+			"set dlev patt: wait_lane_rx_valid FAILED %d\n", ret);
+		return ret;
+	}
 
-		if (ret)
-			return ret;
+	dlevp = _kserdes_read_select_tbus(sregs, lane + 1, 0x44);
+	dlevp = (dlevp >> 4) & 0xff;
 
-		blk_lock = (pcsr_rx_stat >> 30) & 0x1;
-		blk_errs = (pcsr_rx_stat >> 16) & 0x0ff;
+	dlevn = _kserdes_read_select_tbus(sregs, lane + 1, 0x45);
+	dlevn &= 0xff;
 
-		if (blk_errs)
-			blk_lock = 0;
+	if (ctofs->cmp <= 120)
+		dlevavg = ctofs->cmp - dlevn;
+	else if (ctofs->cmp >= 134)
+		dlevavg = dlevp - ctofs->cmp;
+	else
+		dlevavg = (dlevp - dlevn) / 2;
 
-		switch (current_state[i]) {
-		case 0:
-			if (!loss && blk_lock) {
-				dev_dbg(sc->dev, "XGE PCSR Linked Lane: %d\n",
-					i);
-				FINSR(sc->regs, LANEX_REG(i, 0x04), 2, 1, 0x3);
-				current_state[i] = 1;
-			} else {
-				if (!blk_lock) {
-					dev_dbg(sc->dev,
-						"XGE PCSR Recover Lane: %d\n",
-						i);
+	return dlevavg;
+}
 
-					_kserdes_reset_rx(sc->regs, i);
-				}
-			}
-			break;
-		case 1:
-			if (!blk_lock) {
-				current_state[i] = 2;
-			}
-			break;
-		case 2:
-			if (blk_lock) {
-				current_state[i] = 1;
-			} else {
-				_kserdes_reset_rx(sc->regs, i);
-				current_state[i] = 0;
-			}
-			break;
-		default:
-			dev_info(sc->dev, "XGE: unknown current_state[%d] %d\n",
-				 i, current_state[i]);
-			break;
-		}
+static u32 kserdes_eye_monitor_dll_ovr(struct kserdes_config *sc,
+				       u32 lane, u32 phase_num, u32 t_offset,
+				       u32 phase_shift)
+{
+	void __iomem *sregs = sc->regs;
+	u32 tbus_data, delay, partial_eye, i;
+	u32 start_bin = 0, end_bin = 0;
+	u32 eye_scan_errors_array[128];
+	u32 error_free = 0, val_0, val_1;
+	u32 max_dly = 128;
+	bool not_phy_xge = (sc->phy_type != KSERDES_PHY_XGE);
+
+	if (t_offset == 0)
+		t_offset++;
+
+	if (phase_num == 1) {
+		val_0 = 0x00400000;
+		val_1 = 0x00000011;
+	} else {
+		val_0 = 0x00800000;
+		val_1 = 0x00000009;
+	}
+	reg_rmw(sregs + LANEX_REG(lane, 0x2c), val_0, GENMASK(23, 22));
+	reg_rmw(sregs + LANEX_REG(lane, 0x30), val_1, GENMASK(4, 0));
 
-		if (blk_errs) {
-			regmap_update_bits(sc->pcsr_regmap, PCSR_RX_CTL(i),
-					   GENMASK(7, 0), 0x19);
-			regmap_update_bits(sc->pcsr_regmap, PCSR_RX_CTL(i),
-					   GENMASK(7, 0), 0x00);
-		}
+	reg_rmw(sregs + CML_REG(0xb8), 0x00004000, GENMASK(15, 8));
 
-		if (current_state[i] == 1) {
-			*lanes_up_map |= BIT(i);
-		} else {
-			*lanes_up_map &= ~BIT(i);
-			status = 0;
-		}
-	}
+	if (phase_num == 1)
+		val_0 = 0xffef0000;
+	else
+		val_0 = 0xfff60000;
 
-	return status;
-}
+	reg_rmw(sregs + CML_REG(0xb8), val_0, GENMASK(31, 16));
 
-static int kserdes_wait_link_up(struct kserdes_config *sc, u32 *lanes_up_map)
-{
-	u32 current_state[KSERDES_MAX_LANES];
-	unsigned long timeout, time_check;
-	int i, link_up, ret = 0;
+	reg_rmw(sregs + CML_REG(0xbc), 0x000fffff, GENMASK(19, 0));
+	tbus_data = _kserdes_read_select_tbus(sregs, lane + 1, 0x02);
+	tbus_data = tbus_data;
+	usleep_range(250, 500);
 
-	memset(current_state, 0, sizeof(current_state));
-	timeout = jiffies + 2 * HZ;
+	for (i = 0; i < max_dly; i = i + t_offset) {
+		reg_rmw(sregs + LANEX_REG(lane, 0x2c),
+			(i & 0xff) << 24, GENMASK(31, 24));
 
-	do {
-		time_check = jiffies;
-		/* amount of time to sleep is by experiment */
-		usleep_range(10000, 20000);
-		link_up = kserdes_check_link_status(sc, current_state,
-						    lanes_up_map);
+		reg_rmw(sregs + LANEX_REG(lane, 0x30),
+			phase_shift, GENMASK(1, 0));
+		usleep_range(5, 10);
+		reg_rmw(sregs + CML_REG(0xb8), 0x0000c000, GENMASK(15, 8));
+		usleep_range(500, 1000);
 
-		/*
-		 * if we did not get link up then wait 100ms
-		 * before calling it again
-		 */
-		if (link_up)
-			break;
+		val_0 = _kserdes_read_select_tbus(sregs, lane + 1,
+						  not_phy_xge ?  0x1a : 0x19);
+		val_0 <<= 4;
 
-		for_each_enable_lane(sc, i) {
-			if (!(*lanes_up_map & BIT(i))) {
-				dev_dbg(sc->dev,
-					"XGE: detected lane %d down\n", i);
-			}
-		}
+		val_1 = _kserdes_read_select_tbus(sregs, lane + 1,
+						  not_phy_xge ?  0x1b : 0x1a);
+		val_1 = (val_1 >> 8) & 0xf;
 
-		if (time_after(time_check, timeout)) {
-			ret = -ETIMEDOUT;
-			break;
+		eye_scan_errors_array[i] = (val_0 | val_1);
+
+		reg_rmw(sregs + CML_REG(0xb8), 0x00004000, GENMASK(15, 8));
+	}
+
+	partial_eye = 0;
+	error_free = 0;
+
+	for (i = 0; i < max_dly; i = i + t_offset) {
+		if (i == 0) {
+			if (eye_scan_errors_array[i] < 16384)
+				partial_eye = 1;
+		} else {
+			if (eye_scan_errors_array[i] > 16384 + 3000)
+				partial_eye = 0;
 		}
 
-	} while (1);
+		if ((eye_scan_errors_array[i] < 16384) &&
+		    (partial_eye == 0) &&
+		    (error_free  == 0)) {
+			if (!((eye_scan_errors_array[i - 1] > 16384) &&
+			      (eye_scan_errors_array[i + 1] > 16384))) {
+				error_free = 1;
+				start_bin = i;
+			}
+		} else if ((eye_scan_errors_array[i] > 16384) &&
+			   (partial_eye == 0) &&
+			   (error_free  == 1)) {
+			if (!((eye_scan_errors_array[i - 1] < 16384) &&
+			      (eye_scan_errors_array[i + 1] < 16384))) {
+				end_bin = i;
+				break;
+			}
+		}
+	}
 
-	return ret;
+	delay = (end_bin - start_bin) / 4 + start_bin;
+	reg_rmw(sregs + LANEX_REG(lane, 0x30), 0x00000000, GENMASK(7, 0));
+	reg_rmw(sregs + LANEX_REG(lane, 0x2c), 0x00000003, GENMASK(7, 0));
+	reg_rmw(sregs + CML_REG(0x98), 0x00000000, GENMASK(31, 0));
+	reg_rmw(sregs + CML_REG(0xb8), 0x00000000, GENMASK(15, 14));
+	reg_rmw(sregs + LANEX_REG(lane, 0x2c), 0x00000000, GENMASK(23, 22));
+	return delay;
 }
 
-static int kserdes_xge_lanes_enable(struct kserdes_config *sc)
+static void kserdes_rx_calibration_phyb(struct kserdes_config *sc, u32 lane,
+					struct kserdes_lane_ofs *lofs,
+					struct kserdes_lane_dlev_out *ldlevo)
 {
-	struct kserdes_offsets sofs;
-	int ret, i;
-	int lanes_up_map = 0;
+	struct kserdes_cmp_coef_ofs *ctofs, *ctofs_temp;
+	struct kserdes_lane_ofs lofs_temp;
+	void __iomem *sregs = sc->regs;
+	u32 att, boost, comp_no, att_start, boost_start;
+	u32 delay_ovr = 0;
+	int dlevavg_temp[6];
+
+	delay_ovr = kserdes_eye_monitor_dll_ovr(sc, lane, 0, 1, 0);
+	ldlevo->delay = delay_ovr;
+
+	FINSR(sregs, CML_REG(0x164), 15, 15, 1);
+
+	FINSR(sregs, CML_REG(0x164), 16, 16, 1);
+	FINSR(sregs, CML_REG(0x164), 31, 26, (128 + delay_ovr) & 0x3f);
+	FINSR(sregs, CML_REG(0x168),  2,  0, (128 + delay_ovr) >> 6);
+	FINSR(sregs, LANEX_REG(lane, 0x9c), 1, 1, 0);
+	FINSR(sregs, LANEX_REG(lane, 0x9c), 0, 0, 0);
+
+	att_start = (kserdes_readl(sregs, LANEX_REG(lane, 0x8c)) >> 8) & 0xf;
+	boost_start = (kserdes_readl(sregs, LANEX_REG(lane, 0x8c)) >> 12) & 0xf;
+
+	att = _kserdes_read_select_tbus(sregs, lane + 1, 0x10);
+	boost = (att >> 8) & 0xf;
+	att = (att >> 4) & 0xf;
+
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att);
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 15, 12, boost);
+
+	dlevavg_temp[0] = kserdes_set_dlev_patt_adapt(sc, lane, 0x71, lofs);
+	dlevavg_temp[1] = kserdes_set_dlev_patt_adapt(sc, lane, 0x61, lofs);
+	dlevavg_temp[2] = kserdes_set_dlev_patt_adapt(sc, lane, 0x79, lofs);
+	dlevavg_temp[3] = kserdes_set_dlev_patt_adapt(sc, lane, 0x75, lofs);
+	dlevavg_temp[4] = kserdes_set_dlev_patt_adapt(sc, lane, 0x73, lofs);
+	dlevavg_temp[5] = kserdes_set_dlev_patt_adapt(sc, lane, 0x70, lofs);
+
+	ldlevo->coef_vals[0] = (dlevavg_temp[0] - dlevavg_temp[1]) /  2;
+	ldlevo->coef_vals[1] = (dlevavg_temp[0] - dlevavg_temp[2]) / -2;
+	ldlevo->coef_vals[2] = (dlevavg_temp[0] - dlevavg_temp[3]) / -2;
+	ldlevo->coef_vals[3] = (dlevavg_temp[0] - dlevavg_temp[4]) / -2;
+	ldlevo->coef_vals[4] = (dlevavg_temp[0] - dlevavg_temp[5]) /  2;
+
+	ldlevo->coef_vals[0] = ldlevo->coef_vals[0] -
+					ldlevo->coef_vals[0] / 3;
+
+	for (comp_no = 1; comp_no < 5; comp_no++) {
+		ctofs = &lofs->ct_ofs[comp_no];
+		ctofs_temp = &lofs_temp.ct_ofs[comp_no];
+
+		ctofs_temp->cmp = ctofs->cmp;
+
+		if ((comp_no == 1) || (comp_no == 3)) {
+			ctofs_temp->coef1 = ldlevo->coef_vals[0] + ctofs->coef1;
+			ctofs_temp->coef2 = ldlevo->coef_vals[1] + ctofs->coef2;
+			ctofs_temp->coef3 = ldlevo->coef_vals[2] + ctofs->coef3;
+			ctofs_temp->coef4 = ldlevo->coef_vals[3] + ctofs->coef4;
+			ctofs_temp->coef5 = ldlevo->coef_vals[4] + ctofs->coef5;
+		} else {
+			ctofs_temp->coef1 = ctofs->coef1;
+			ctofs_temp->coef2 = ctofs->coef2;
+			ctofs_temp->coef3 = ctofs->coef3;
+			ctofs_temp->coef4 = ctofs->coef4;
+			ctofs_temp->coef5 = ctofs->coef5;
+		}
 
-	if (sc->firmware) {
-		return 0;
+		_kserdes_set_ofs(sregs, lane, comp_no, ctofs_temp);
 	}
 
-	kserdes_highspeed_cfg(sc);
-	kserdes_xge_pll_enable(sc);
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 11, 8, att_start);
+	FINSR(sregs, LANEX_REG(lane, 0x8c), 15, 12, boost_start);
+	FINSR(sregs, LANEX_REG(lane, 0x9c), 1, 1, 1);
+	FINSR(sregs, LANEX_REG(lane, 0x9c), 0, 0, 1);
+}
 
-	for_each_lane(sc, i)
-		kserdes_xge_lane_enable(sc, i);
+static int kserdes_rx_boost_config_phya(struct kserdes_config *sc, u32 lane)
+{
+	u32 boost_read;
+	int ret;
+	bool phy_xge = (sc->phy_type == KSERDES_PHY_XGE);
 
-	ret = kserdes_get_status(sc);
+	ret = kserdes_wait_lane_rx_valid(sc, lane);
 	if (ret) {
 		dev_err(sc->dev,
-			"kserdes_xge_lanes_enable get status FAILED %d\n", ret);
+			"config_phya: wait_lane_rx_valid FAILED %d\n", ret);
 		return ret;
 	}
 
-	kserdes_phyb_init_cfg(sc, &sofs);
-
-	for_each_lane(sc, i)
-		_kserdes_enable_xgmii_port(sc->peripheral_regmap, i);
+	boost_read = _kserdes_read_select_tbus(sc->regs, lane + 1,
+					       phy_xge ?  0x10 : 0x11);
 
-	kserdes_wait_link_up(sc, &lanes_up_map);
+	boost_read = (boost_read >> 8) & 0xf;
 
-	return lanes_up_map;
+	if (!boost_read) {
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  2,  2, 0x1);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 18, 12, 0x2);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  9,  3, 0x1);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 10, 10, 0x1);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 10, 10, 0x0);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  2,  2, 0x0);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c), 18, 12, 0x0);
+		FINSR(sc->regs, LANEX_REG(lane, 0x2c),  9,  3, 0x0);
+	}
+	return 0;
 }
 
-static inline void kserdes_xfw_get_lane_params(struct kserdes_config *sc,
-					       int lane)
+static int kserdes_enable_lane_rx(struct kserdes_config *sc, u32 lane,
+				  struct kserdes_lane_ofs *lofs,
+				  struct kserdes_lane_dlev_out *ldlevo)
 {
-	struct kserdes_fw_config *fw = &sc->fw;
-	u32 tx_ctrl, val_0, val_1;
-	u32 phy_a = PHY_A(sc->regs);
+	int ret = 0;
 
-	val_0 = kserdes_readl(sc->regs, LANEX_REG(lane, 0x04));
-	val_1 = kserdes_readl(sc->regs, LANEX_REG(lane, 0x08));
+	_kserdes_force_signal_detect_high(sc->regs, lane);
 
-	tx_ctrl = ((((val_0 >> 18) & 0x1)    << 24) |
-		   (((val_1 >> 0)  & 0xffff) <<  8) |
-		   (((val_0 >> 24) & 0xff)   <<  0));
+	if (!sc->rx_force_enable) {
+		ret = _kserdes_wait_lane_sd(sc->regs, lane);
+		if (ret) {
+			dev_err(sc->dev,
+				"init_lane_rx wait sd valid FAILED %d\n", ret);
+			return ret;
+		}
 
-	if (phy_a) {
-		fw->cm = (val_1 >> 12) & 0xf;
-		fw->c1 = (val_1 >> 0) & 0x1f;
-		fw->c2 = (val_1 >> 8) & 0xf;
-	} else {
-		fw->cm = (tx_ctrl >> 16) & 0xf;
-		fw->c1 = (tx_ctrl >> 8) & 0x1f;
-		fw->c2 = (tx_ctrl >> 13) & 0x7;
-		fw->c2 = fw->c2 | (((tx_ctrl >> 24) & 0x1) << 3);
-	}
+		if ((sc->phy_type == KSERDES_PHY_XGE) ||
+		    (sc->link_rate >= KSERDES_LINK_RATE_5G)) {
+			if (sc->lane[lane].ctrl_rate == KSERDES_FULL_RATE) {
+				ret = kserdes_wait_lane_rx_valid(sc, lane);
+				if (ret) {
+					dev_err(sc->dev,
+						"init_lane_rx wait rx valid FAILED %d\n",
+					       ret);
+					return ret;
+				}
+			}
+		}
 
-	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1,
-					  (phy_a ? 0x11 : 0x10));
-	fw->attn = (val_0 >> 4) & 0xf;
-	fw->boost = (val_0 >> 8) & 0xf;
+		if (sc->phy_type == KSERDES_PHY_XGE) {
+			kserdes_rx_att_boost_config_phyb(sc, lane);
+		} else if ((sc->link_rate >= KSERDES_LINK_RATE_5G) &&
+			   (sc->lane[lane].ctrl_rate == KSERDES_FULL_RATE)) {
+			kserdes_rx_boost_config_phya(sc, lane);
+		}
+	}
 
-	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1, 0x5);
-	fw->dlpf = (val_0 >> 2) & 0x3ff;
+	if (sc->phy_type == KSERDES_PHY_XGE)
+		kserdes_rx_calibration_phyb(sc, lane, lofs, ldlevo);
 
-	val_0 = _kserdes_read_select_tbus(sc->regs, lane + 1, 0x6);
-	fw->rxcal = (val_0 >> 3) & 0xff;
+	return ret;
 }
 
-static inline void kserdes_xfw_mem_init(struct kserdes_config *sc)
+static int kserdes_recover_lane_rx(struct kserdes_config *sc, u32 lane,
+				   struct kserdes_lane_ofs *lofs,
+				   struct kserdes_lane_dlev_out *ldlevo)
 {
-	struct kserdes_fw_config *fw = &sc->fw;
-	u32 i, lane_config = 0;
+	int ret;
 
-	for_each_lane(sc, i)
-		lane_config = (lane_config << 8) | (fw->lane_config[i] & 0xff);
+	_kserdes_force_signal_detect_high(sc->regs, lane);
 
-	lane_config <<= 8;
+	if (!sc->rx_force_enable) {
+		ret = _kserdes_wait_lane_sd(sc->regs, lane);
+		if (ret) {
+			dev_dbg(sc->dev,
+				"init_lane_rx wait sd valid FAILED %d\n", ret);
+			return ret;
+		}
+		dev_dbg(sc->dev, "recover_lane_rx sig detcected\n");
+
+		if ((sc->phy_type == KSERDES_PHY_XGE) ||
+		    (sc->link_rate >= KSERDES_LINK_RATE_5G)) {
+			if (sc->lane[lane].ctrl_rate == KSERDES_FULL_RATE) {
+				ret = kserdes_wait_lane_rx_valid(sc, lane);
+				if (ret) {
+					dev_err(sc->dev,
+						"init_lane_rx wait rx valid FAILED %d\n",
+					       ret);
+					return ret;
+				}
+				dev_dbg(sc->dev, "recover_lane_rx rx valid\n");
+			}
+		}
 
-	kserdes_writel(sc->regs, MEM_ADR_REG, KSERDES_XFW_CONFIG_START_ADDR);
+		if (sc->phy_type == KSERDES_PHY_XGE) {
+			kserdes_rx_att_boost_config_phyb(sc, lane);
+		} else if ((sc->link_rate >= KSERDES_LINK_RATE_5G) &&
+			   (sc->lane[lane].ctrl_rate == KSERDES_FULL_RATE)) {
+			kserdes_rx_boost_config_phya(sc, lane);
+		}
+	}
 
-	for (i = KSERDES_XFW_CONFIG_START_ADDR;
-	     i < KSERDES_XFW_PARAM_START_ADDR; i += 4)
-		kserdes_writel(sc->regs, MEM_DATINC_REG, 0x00000000);
+	if (sc->phy_type == KSERDES_PHY_XGE)
+		kserdes_rx_calibration_phyb(sc, lane, lofs, ldlevo);
 
-	kserdes_writel(sc->regs, MEM_DATINC_REG, XFM_FLUSH_CMD);
-	kserdes_writel(sc->regs, MEM_DATINC_REG, fw->fast_train);
-	kserdes_writel(sc->regs, MEM_DATINC_REG, 0x00000000);
-	kserdes_writel(sc->regs, MEM_DATINC_REG, fw->lane_seeds);
-	kserdes_writel(sc->regs, MEM_DATINC_REG, lane_config);
+	return 0;
 }
 
-static int kserdes_xge_init(struct kserdes_config *sc)
+static int kserdes_sgmii_init(struct kserdes_config *sc)
 {
-	return kserdes_load_init_fw(sc, ks2_xgbe_serdes_firmwares,
-				    ARRAY_SIZE(ks2_xgbe_serdes_firmwares));
+	return kserdes_load_init_fw(sc, ks2_gbe_serdes_firmwares,
+				    ARRAY_SIZE(ks2_gbe_serdes_firmwares));
 }
 
-static int kserdes_pcie_lanes_enable(struct kserdes_config *sc)
+static int kserdes_xge_init(struct kserdes_config *sc)
 {
-	int ret, i;
-	u32 lanes_enable = 0;
-
-	for_each_enable_lane(sc, i)
-		lanes_enable |= (1 << i);
-
-	for_each_lane(sc, i) {
-		kserdes_release_reset(sc, i);
-
-		if (sc->lane[i].loopback)
-			_kserdes_set_lane_loopback(sc->regs, i, sc->link_rate);
-	}
-
-	ret = kserdes_get_status(sc);
-	if (ret)
-		return ret;
-
-	return lanes_enable;
+	_kserdes_reset(sc->regs);
+	return kserdes_load_init_fw(sc, ks2_xgbe_serdes_firmwares,
+				    ARRAY_SIZE(ks2_xgbe_serdes_firmwares));
 }
 
 static int kserdes_pcie_init(struct kserdes_config *sc)
@@ -1679,57 +2075,6 @@ static int kserdes_pcie_init(struct kserdes_config *sc)
 				    ARRAY_SIZE(ks2_pcie_serdes_firmwares));
 }
 
-static int kserdes_lanes_enable(struct kserdes_config *sc)
-{
-	switch (sc->phy_type) {
-	case KSERDES_PHY_SGMII:
-		return kserdes_sgmii_lanes_enable(sc);
-	case KSERDES_PHY_XGE:
-		return kserdes_xge_lanes_enable(sc);
-	case KSERDES_PHY_PCIE:
-		return kserdes_pcie_lanes_enable(sc);
-	default:
-		return -EINVAL;
-	}
-}
-
-static int kserdes_init(struct phy *phy)
-{
-	struct kserdes_dev *sd = phy_get_drvdata(phy);
-	struct kserdes_config *sc = &sd->sc;
-	int ret;
-
-	switch (sc->phy_type) {
-	case KSERDES_PHY_SGMII:
-		ret = kserdes_sgmii_init(sc);
-		break;
-	case KSERDES_PHY_XGE:
-		ret = kserdes_xge_init(sc);
-		break;
-	case KSERDES_PHY_PCIE:
-		ret = kserdes_pcie_init(sc);
-		break;
-	default:
-		ret = -EINVAL;
-	}
-
-	if (ret < 0) {
-		dev_err(sd->dev, "serdes initialization failed %d\n", ret);
-		goto done;
-	}
-
-	ret = kserdes_lanes_enable(sc);
-	if (ret < 0) {
-		dev_err(sd->dev, "serdes lanes enable failed: %d\n", ret);
-		goto done;
-	}
-
-	dev_dbg(sd->dev, "serdes config done lanes(mask) 0x%x\n", ret);
-
-done:
-	return ret;
-}
-
 static int kserdes_of_parse_lane(struct device *dev,
 				 struct device_node *np,
 				 struct kserdes_config *sc)
@@ -1751,7 +2096,8 @@ static int kserdes_of_parse_lane(struct device *dev,
 	}
 
 	lc = &sc->lane[lane_num];
-	lc->enable = true;
+
+	lc->enable = of_device_is_available(np);
 	dev_dbg(dev, "lane %d enabled\n", lane_num);
 
 	if (of_property_read_u32(np, "control-rate", &lc->ctrl_rate)) {
@@ -1791,7 +2137,7 @@ static int kserdes_of_parse_lane(struct device *dev,
 	dev_dbg(dev, "tx-coeff: %d %d %d %d %d\n",
 		tc->c1, tc->c2, tc->cm, tc->att, tc->vreg);
 
-	return 0;
+	return lane_num;
 }
 
 static void kserdes_set_sgmii_defaults(struct kserdes_config *sc)
@@ -1866,17 +2212,72 @@ static const struct of_device_id kserdes_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, kserdes_of_match);
 
+static int kserdes_phy_enable_rx(struct phy *phy)
+{
+	struct kserdes_phy *ks_phy = phy_get_drvdata(phy);
+	struct kserdes_dev *sd = dev_get_drvdata(phy->dev.parent);
+	struct kserdes_config *sc = &sd->sc;
+	struct kserdes_ofs *sofs = &sc->sofs;
+	struct kserdes_dlev_out dlevo;
+	u32 lanes_up_map = 0;
+	u32 i = ks_phy->lane;
+	int ret;
+
+	ret = kserdes_enable_lane_rx(sc, i, &sofs->lane_ofs[i],
+				     &dlevo.lane_dlev_out[i]);
+
+	kserdes_clear_wait_after(sc, BIT(i));
+
+	if (sc->phy_type == KSERDES_PHY_XGE) {
+		_kserdes_enable_xgmii_port(sc->peripheral_regmap, i);
+		kserdes_wait_link_up(sc, BIT(i), &lanes_up_map);
+	}
+
+	return 0;
+}
+
+static int kserdes_phy_reset(struct phy *phy)
+{
+	struct kserdes_phy *ks_phy = phy_get_drvdata(phy);
+	struct kserdes_dev *sd = dev_get_drvdata(phy->dev.parent);
+	struct kserdes_config *sc = &sd->sc;
+	struct kserdes_ofs *sofs = &sc->sofs;
+	struct kserdes_dlev_out dlevo;
+	u32 i = ks_phy->lane;
+	u32 lanes_up_map = 0;
+	int ret;
+
+	ret = kserdes_recover_lane_rx(sc, i, &sofs->lane_ofs[i],
+				      &dlevo.lane_dlev_out[i]);
+
+	kserdes_clear_wait_after(sc, BIT(i));
+
+	_kserdes_enable_xgmii_port(sc->peripheral_regmap, i);
+
+	kserdes_wait_link_up(sc, BIT(i), &lanes_up_map);
+
+	dev_dbg(sd->dev, "phy reset: recover lane %u rx\n", i);
+
+	return ret;
+}
+
+static struct phy_ops kserdes_phy_ops = {
+	.init		= kserdes_phy_enable_rx,
+	.reset		= kserdes_phy_reset,
+	.owner		= THIS_MODULE,
+};
+
 static int kserdes_of_parse(struct platform_device *pdev,
 			    struct kserdes_dev *sd,
 			    struct device_node *np)
 {
 	const struct of_device_id *of_id;
 	struct kserdes_config *sc = &sd->sc;
-	struct device_node *lanes_np, *child;
+	struct device_node *child;
 	struct device *dev = sd->dev;
 	struct resource res;
 	void __iomem *regs;
-	int ret;
+	int ret, lane = 0;
 
 	ret = of_address_to_resource(np, SERDES_REG_INDEX, &res);
 	if (ret) {
@@ -1944,26 +2345,122 @@ static int kserdes_of_parse(struct platform_device *pdev,
 	else
 		sc->rx_force_enable = false;
 
-	lanes_np = of_get_child_by_name(np, "lanes");
-	if (lanes_np) {
-		for_each_available_child_of_node(lanes_np, child) {
-			ret = kserdes_of_parse_lane(dev, child, sc);
-			if (ret) {
-				of_node_put(child);
-				of_node_put(lanes_np);
-				return ret;
-			}
+	sd->nphys = sc->lanes;
+
+	for_each_child_of_node(np, child) {
+		struct kserdes_phy *ks_phy;
+		struct phy *phy;
+
+		lane = kserdes_of_parse_lane(dev, child, sc);
+		if (lane < 0) {
+			ret = lane;
+			goto err_child;
 		}
-		of_node_put(lanes_np);
+
+		if (!sc->lane[lane].enable)
+			continue;
+
+		ks_phy = devm_kzalloc(dev, sizeof(*ks_phy), GFP_KERNEL);
+		if (!ks_phy) {
+			ret = -ENOMEM;
+			goto err_child;
+		}
+
+		sd->phys[lane] = ks_phy;
+
+		phy = devm_phy_create(dev, child, &kserdes_phy_ops);
+		if (IS_ERR(phy)) {
+			dev_err(dev, "falied to create PHY\n");
+			ret = PTR_ERR(phy);
+			goto err_child;
+		}
+
+		sd->phys[lane]->phy = phy;
+		sd->phys[lane]->lane = lane;
+		phy_set_drvdata(phy, sd->phys[lane]);
 	}
 
 	return 0;
+err_child:
+	of_node_put(child);
+	return ret;
 }
 
-static struct phy_ops kserdes_ops = {
-	.init		= kserdes_init,
-	.owner		= THIS_MODULE,
-};
+static int kserdes_provider_lanes_enable_common(struct kserdes_config *sc)
+{
+	struct kserdes_ofs *sofs = &sc->sofs;
+	unsigned long lanes_needed = 0;
+	int ret, i;
+
+	if (sc->firmware)
+		return 0;
+
+	for_each_enable_lane(sc, i)
+		lanes_needed |= BIT(i);
+
+	if (sc->phy_type == KSERDES_PHY_PCIE) {
+		kserdes_pcie_lanes_enable(sc);
+		return lanes_needed;
+	}
+
+	ret = kserdes_lanes_enable_common(sc, sofs);
+	if (ret)
+		dev_err(sc->dev, "provider lanes enable: FAILED %d\n", ret);
+
+	return ret;
+}
+
+static int kserdes_provider_init(struct kserdes_dev *sd)
+{
+	struct kserdes_config *sc = &sd->sc;
+	struct device *dev = sd->dev;
+	int ret;
+
+	switch (sc->phy_type) {
+	case KSERDES_PHY_SGMII:
+		ret = kserdes_sgmii_init(sc);
+		break;
+	case KSERDES_PHY_XGE:
+		ret = kserdes_xge_init(sc);
+		break;
+	case KSERDES_PHY_PCIE:
+		ret = kserdes_pcie_init(sc);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "serdes procider init failed %d\n", ret);
+		return ret;
+	}
+
+	return kserdes_provider_lanes_enable_common(sc);
+}
+
+static struct phy *kserdes_xlate(struct device *dev,
+				 struct of_phandle_args *args)
+{
+	struct kserdes_dev *sd = dev_get_drvdata(dev);
+	struct phy *phy = NULL;
+	struct device_node *phynode = args->np;
+	int i;
+
+	if (args->args_count) {
+		dev_err(dev, "invalid #cell in PHY property\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	for (i = 0; i < sd->nphys; i++) {
+		if (sd->phys[i] &&
+		    (phynode == sd->phys[i]->phy->dev.of_node)) {
+			phy = sd->phys[i]->phy;
+			break;
+		}
+	}
+
+	return phy;
+}
 
 static int kserdes_probe(struct platform_device *pdev)
 {
@@ -1978,23 +2475,18 @@ static int kserdes_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	sd->dev = dev;
+	dev_set_drvdata(dev, sd);
 
 	ret = kserdes_of_parse(pdev, sd, np);
 	if (ret)
 		return ret;
 
-	dev_set_drvdata(dev, sd);
-	sd->phy = devm_phy_create(dev, NULL, &kserdes_ops);
-	if (IS_ERR(sd->phy))
-		return PTR_ERR(sd->phy);
-
-	phy_set_drvdata(sd->phy, sd);
-	phy_provider = devm_of_phy_provider_register(sd->dev,
-						     of_phy_simple_xlate);
-
+	phy_provider = devm_of_phy_provider_register(sd->dev, kserdes_xlate);
 	if (IS_ERR(phy_provider))
 		return PTR_ERR_OR_ZERO(phy_provider);
 
+	kserdes_provider_init(sd);
+
 	dev_vdbg(&pdev->dev, "probed");
 	return 0;
 }
-- 
1.7.5.4

