From 164a2bccd96295e7dda1b1098132fec3a1d21861 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 13 Apr 2015 16:12:11 +0800
Subject: [PATCH 061/256] phylib: add context argument to adjust link callback

This patch comes from TI
  git://git.ti.com/keystone-linux/linux.git

And changes to cater for 3.14.x kernel, need to be re-considerated.

This patch introduces a context argument for the adjust link callback.  This
context information is set at phy_connect() (and its variants), and is passed
back into the adjust_link callbacks on link state change events.

Such context information is necessary when a network device has multiple
underlying ports.  Specifically, this comes into play when the netdev is
really one of the ports going into an on-chip switch of some sort.

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/phy/phy.c        |   25 ++++++++++++++++---------
 drivers/net/phy/phy_device.c |   30 ++++++++++++++++++++++++++++++
 include/linux/phy.h          |   14 ++++++++++++++
 3 files changed, 60 insertions(+), 9 deletions(-)

diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index e387fda..7e9c16b 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -38,6 +38,14 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_TI_KEYSTONE
+#define	phydev_adjust_link(phydev)  \
+	phydev->adjust_link(phydev->attached_dev, phydev->context);
+#else
+#define	phydev_adjust_link(phydev)  \
+	phydev->adjust_link(phydev->attached_dev);
+#endif
+
 /**
  * phy_print_status - Convenience function to print out the current phy status
  * @phydev: the phy_device struct
@@ -720,7 +728,7 @@ void phy_state_machine(struct work_struct *work)
 		if (!phydev->link) {
 			phydev->state = PHY_NOLINK;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			break;
 		}
 
@@ -733,8 +741,7 @@ void phy_state_machine(struct work_struct *work)
 		if (err > 0) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
-
+			phydev_adjust_link(phydev);
 		} else if (0 == phydev->link_timeout--) {
 			needs_aneg = 1;
 			/* If we have the magic_aneg bit, we try again */
@@ -750,7 +757,7 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	case PHY_FORCING:
@@ -766,7 +773,7 @@ void phy_state_machine(struct work_struct *work)
 				needs_aneg = 1;
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 		break;
 	case PHY_RUNNING:
 		/* Only register a CHANGE if we are
@@ -788,7 +795,7 @@ void phy_state_machine(struct work_struct *work)
 			netif_carrier_off(phydev->attached_dev);
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 
 		if (phy_interrupt_is_valid(phydev))
 			err = phy_config_interrupt(phydev,
@@ -798,7 +805,7 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->link = 0;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			do_suspend = 1;
 		}
 		break;
@@ -830,7 +837,7 @@ void phy_state_machine(struct work_struct *work)
 				} else	{
 					phydev->state = PHY_NOLINK;
 				}
-				phydev->adjust_link(phydev->attached_dev);
+				phydev_adjust_link(phydev);
 			} else {
 				phydev->state = PHY_AN;
 				phydev->link_timeout = PHY_AN_TIMEOUT;
@@ -846,7 +853,7 @@ void phy_state_machine(struct work_struct *work)
 			} else	{
 				phydev->state = PHY_NOLINK;
 			}
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	}
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index fec2828..cd39bb0 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -394,6 +394,7 @@ EXPORT_SYMBOL(phy_find_first);
  * phy_prepare_link - prepares the PHY layer to monitor link status
  * @phydev: target phy_device struct
  * @handler: callback function for link status change notifications
+ * @context: context information for callback handler
  *
  * Description: Tells the PHY infrastructure to handle the
  *   gory details on monitoring link status (whether through
@@ -403,9 +404,17 @@ EXPORT_SYMBOL(phy_find_first);
  *   this function.
  */
 static void phy_prepare_link(struct phy_device *phydev,
+#ifdef CONFIG_TI_KEYSTONE
+		void (*handler)(struct net_device *, void *context),
+		void *context)
+#else
 			     void (*handler)(struct net_device *))
+#endif
 {
 	phydev->adjust_link = handler;
+#ifdef CONFIG_TI_KEYSTONE
+	phydev->context = context;
+#endif
 }
 
 /**
@@ -414,10 +423,16 @@ static void phy_prepare_link(struct phy_device *phydev,
  * @phydev: the pointer to the phy device
  * @handler: callback function for state change notifications
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  */
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+#ifdef CONFIG_TI_KEYSTONE
+		       void (*handler)(struct net_device *, void *context),
+		       phy_interface_t interface, void *context)
+#else
 		       void (*handler)(struct net_device *),
 		       phy_interface_t interface)
+#endif
 {
 	int rc;
 
@@ -425,7 +440,11 @@ int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 	if (rc)
 		return rc;
 
+#ifdef CONFIG_TI_KEYSTONE
+	phy_prepare_link(phydev, handler, context);
+#else
 	phy_prepare_link(phydev, handler);
+#endif
 	phy_start_machine(phydev);
 	if (phydev->irq > 0)
 		phy_start_interrupts(phydev);
@@ -440,6 +459,7 @@ EXPORT_SYMBOL(phy_connect_direct);
  * @bus_id: the id string of the PHY device to connect
  * @handler: callback function for state change notifications
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  *
  * Description: Convenience function for connecting ethernet
  *   devices to PHY devices.  The default behavior is for
@@ -450,8 +470,13 @@ EXPORT_SYMBOL(phy_connect_direct);
  *   the desired functionality.
  */
 struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
+#ifdef CONFIG_TI_KEYSTONE
+	    void (*handler)(struct net_device *, void *context),
+	    phy_interface_t interface, void *context)
+#else
 			       void (*handler)(struct net_device *),
 			       phy_interface_t interface)
+#endif
 {
 	struct phy_device *phydev;
 	struct device *d;
@@ -467,7 +492,12 @@ struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
 	}
 	phydev = to_phy_device(d);
 
+#ifdef CONFIG_TI_KEYSTONE
+	rc = phy_connect_direct(dev, phydev, handler, interface, context);
+#else
 	rc = phy_connect_direct(dev, phydev, handler, interface);
+#endif
+
 	if (rc)
 		return ERR_PTR(rc);
 
diff --git a/include/linux/phy.h b/include/linux/phy.h
index d48f2c7..797b1ed 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -415,7 +415,12 @@ struct phy_device {
 
 	struct net_device *attached_dev;
 
+#ifdef CONFIG_TI_KEYSTONE
+	void (*adjust_link)(struct net_device *dev, void *context);
+	void *context;
+#else
 	void (*adjust_link)(struct net_device *dev);
+#endif
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -678,12 +683,21 @@ struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
 		      u32 flags, phy_interface_t interface);
+#ifdef CONFIG_TI_KEYSTONE
+int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+		       void (*handler)(struct net_device *, void *context),
+		       phy_interface_t interface, void *context);
+struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
+	    void (*handler)(struct net_device *, void *context),
+	    phy_interface_t interface, void *context);
+#else
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 		       void (*handler)(struct net_device *),
 		       phy_interface_t interface);
 struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
 			       void (*handler)(struct net_device *),
 			       phy_interface_t interface);
+#endif
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
-- 
1.7.5.4

