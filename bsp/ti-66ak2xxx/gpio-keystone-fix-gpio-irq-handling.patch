From efc6533c2d4aa9c61490a10d5e889c1185bdbea0 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Thu, 23 May 2013 15:43:29 -0400
Subject: [PATCH 196/256] gpio: keystone: fix gpio irq handling

Currently if there are multiple GPIO interrupts asserted simultaneously,
the gpio irq handler routs interrupt event only to current interrupt
handler, however acks other pending interrupts without calling their
handlers. The fix is to ack only current interrupt.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit 8b425cfa68cc985b039be66a14f5039d78724212)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/gpio/gpio-keystone.c |    6 ++----
 1 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/drivers/gpio/gpio-keystone.c b/drivers/gpio/gpio-keystone.c
index 191dee0..d7609a0 100644
--- a/drivers/gpio/gpio-keystone.c
+++ b/drivers/gpio/gpio-keystone.c
@@ -164,16 +164,14 @@ static void keystone_irq_handler(unsigned int irq, struct irq_desc *desc)
 	struct gpio_bank *bank = irq_desc_get_handler_data(desc);
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	struct gpio_regs *regs = bank->regs;
-	u32 mask = 0xffff, status;
+	u32 mask = 1, status;
 	int gpio, virq;
 
 	gpio = keystone_hwirq_to_gpio(bank, irq);
 	if (gpio < 0)
 		return;
 
-	if (gpio >= GPIOS_PER_HW_BANK)
-		mask <<= 16;
-
+	mask <<= gpio;
 	/* temporarily mask (level sensitive) parent IRQ */
 	chip->irq_mask(&desc->irq_data);
 	if (chip->irq_ack)
-- 
1.7.5.4

