From 3bd7ca1c1fcae04c20f863b7abb8e79a4ef7f9cb Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Fri, 11 Mar 2016 02:39:12 +0000
Subject: [PATCH 049/347] net: netcp: add packet accelerator (PA) netcp module

This patch comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

This patch adds the PA netcp module to support PA hardware
available on K2HK SoCs. PA module adds hw acceleration capabilities
such as tx/rx checksum on IP/UDP/TCP packets, do timestamp on
Tx/Rx packets. This patch add checksum capabilities. The driver is also
responsible for loading and running firmwares on various PDSPs available
in the PA hardware.

To know more about the driver, please refers to the Documentation
provided as part of this patch.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Jack Manbeck <j-manbeck2@ti.com>
[nsekhar@ti.com: fix some tabs after #define]
Signed-off-by: Sekhar Nori <nsekhar@ti.com>

(cherry picked from commit e1c4d9fb6f23006542c6848baf9911456474bc39)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 Documentation/arm/keystone/netcp-pa.txt            |  216 ++++
 .../devicetree/bindings/net/keystone-netcp.txt     |  145 +++
 drivers/net/ethernet/ti/Kconfig                    |   11 +
 drivers/net/ethernet/ti/Makefile                   |    2 +
 drivers/net/ethernet/ti/netcp_pa.c                 | 1149 ++++++++++++++++++++
 drivers/net/ethernet/ti/netcp_pa_fw.h              |  837 ++++++++++++++
 drivers/net/ethernet/ti/netcp_pa_host.h            |  138 +++
 7 files changed, 2498 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/arm/keystone/netcp-pa.txt
 create mode 100644 drivers/net/ethernet/ti/netcp_pa.c
 create mode 100644 drivers/net/ethernet/ti/netcp_pa_fw.h
 create mode 100644 drivers/net/ethernet/ti/netcp_pa_host.h

diff --git a/Documentation/arm/keystone/netcp-pa.txt b/Documentation/arm/keystone/netcp-pa.txt
new file mode 100644
index 0000000..1feb562
--- /dev/null
+++ b/Documentation/arm/keystone/netcp-pa.txt
@@ -0,0 +1,216 @@
+                   Keystone NETCP Packet Accelarator Device Driver
+                   -----------------------------------------------
+
+This document describes the Keystone NetCP PA device driver. To Know more
+details on the hardware, please refers to the following hardware documents:-
+
+Packet Accelerator (PA) for KeyStone Devices User's Guide
+http://www.ti.com/lit/ug/sprugs4a/sprugs4a.pdf
+
+Here is a description of the PA hardware as given in the above UG.
+
+The packet accelerator (PA) is one of the main components of the network
+coprocessor (NETCP) peripheral. The PA works together with the security
+accelerator (SA) and the gigabit Ethernet switch subsystem to form a
+network processing solution. The purpose of PA in the NETCP is to perform
+packet processing operations such as packet header classification, checksum
+generation, and multi-queue routing.
+
+The below section shows the packet flow in the hardware and the hardware
+resources associated with the same.
+
+                      (Resource map and Packet flow diagram)
+                      --------------------------------------
+
+	           Packet flow                    ---------------------------
+                                                  |  Linux NetCP PA device  |
+                    Ingress (CPSW port x)         ---------------------------
+                       |                                    |    |  |    |  |
+                       V                                    |    |  |    |  |
+                     CPSW                                   |    |  |    |  |
+                       |                   commands         |    |  |    ----
+                       |            Packet Parse to LUT1    |    ----      ^
+                       V                       --------     |      ^       |
+        ----------Cluster 0--------------      | Chan 0     |      |   queue
+        | PDSP0 |  L2 Classify Engine   | <----| 640    <---|      |     for
+        |       |       Pass 1 LUT 0    |      ---------    |      |  flow 31
+        ---------------------------------                   |      |  (Command
+               Match   |   | fail route to flow (22 to 25)  |      |  Response)
+                       |   ----> xxxx                       |      |
+                       |                                    |      |
+                       |                  commands          |   Per port Queue
+                       |           exception route to PDSP5 |   Mapped to flows
+                       V            Packet Parse to L3 LUT2 |   (22 to 25)
+        ----------Cluster 1--------------      ---------    |   for data packets
+        |       |                       |      |            |
+        |       |                       |      | Chan 1     |
+        | PDSP1 |  L3 Classify Engine 0 | <----| 641    <---|
+        |       |       Pass 1 LUT 1    |      ---------    |
+        |       |     classifcation of  |                   |
+        |       | packet using IP/L3 hdr|                   |
+        ---------------------------------                   |
+               Match   |    | fail route to flow            |
+                       V    -----> (22 to 25)----> xxxx     |
+        ----------Cluster 2--------------                   |
+        | PDSP2 |  L3 Classify Engine 1 |                   |
+        |       |       Pass 1 LUT 2    | (not used by      |
+        |       | classification of     |  Linux driver)    |
+        |       | IPSec packet using    |                   |
+        |       | inner IP header       |                   |
+        ---------------------------------                   |
+               Match   |    | fail route to flow            |
+                       V    ------>  (22 to 25)----> xxxx   |
+        ----------Cluster 3--------------                   |
+        | PDSP3 |  L4 Classify Engine   | (not used by      |
+        |       |       Pass 2 LUT 2    |  Linux driver)    |
+        |       | classification of IP  |                   |
+        |       | packet using L4 hdr   |                   |
+        |       | TCP/UDP/Custom        |                   |
+        ---------------------------------                   |
+                                                            |
+                                                            |
+        ----------Cluster 4--------------                   |
+        | PDSP4 |  Modify/Multi route   |                   |
+        |       |      Engine 0         | (not used by      |
+        |       |                       |  Linux driver)    |
+        ---------------------------------                   |
+                                                            |
+        ----------Cluster 5--------------  flows            |
+        | PDSP5 |  Modify/Multi route   | 22 to 25          |
+        |       |      Engine 1         |---> xxxx          |
+        |       |                       |                   |
+        ---------------------------------  (Not used by     |
+                                           Linux driver)    |
+                                               ----------   |
+                                               | Chan 4     |
+                       |-----------------------| Queue 644  |
+                       V                       -----------  |
+        ----------Cluster 4-------------                    |
+        | PDSP4 |  Modify/Multi route   |                   |
+     ---|       |      Engine           |                   |
+     |  |       |  (Generate L4         |      commands     |
+     |  |       |   checksum - UDP/TCP/ |   tx checksum/crc |
+     |  |       |   SCTP)               |                   |
+     |  ---------------------------------   Data packets    |
+     |                                         ----------   |
+     |                                         | Chan 5     |
+     |                 |-----------------------| Queue 645<-|
+     |                 V                       -----------
+     |  ----------Cluster 5-------------
+     |  | PDSP5 |  Modify/Multi route   |
+     |  |       |      Engine           |
+     |  |       |   (Generate L4        |
+     |  |       |      checksum - UDP/  |
+     |  |       |    TCP/SCTP)          |
+     |  ---------------------------------
+     |                 |
+     |---------------->|
+                       |
+                       V
+                      CPSW
+                       |
+                       V
+              Egress (CPSW port x)
+                       |
+                       V
+
+HW Queues 640-645 are for PA cluster 0-5
+Tx chan 0-5 are associated with the above queues
+Rx flows 31 for command response
+Rx flows 22-25 for rx data from each ethernet port
+
+Design Notes
+------------
+
+PA driver PA PDSP interface code re-uses code from PA LLD and it is
+necessary to keep this code as close to PA LLD as possible for ease
+of maintenance.
+
+The driver sends commands to L2 (cluster 0) and L3 engines (cluster 1)
+to add MAC address and IP address in the respective LUTs. In the Egress
+path, it receives packet from NetCP core driver through tx_hook and format
+the commands to do tx checksums and add the command to PS Data field of
+the hw descriptor that is then queued to the Modify/Multi route Engine
+1 for PA on K2HK SoC (cluster 6 on PA on K2E/L SoC). On the Ingress path,
+PA driver configures the streaming switch to route the packets to cluster
+0 for processng which then travels through other clusters based on rules
+setup in the LUT.
+
+PA resources such as LUT tables are shared resources across ARM and DSP
+applications. It is expected that Linux PA driver adds entries to pre
+defined indices in the table and others are used by other applications.
+Generally packets are matched and routed to specific applicaitions and
+rest of the packets fail back to Linux netcp PA device for handling.
+
+Other notes:-
+
+Cluster 5 (Modify/Multi route Engine)
+	  - Configuration command for exception processing in all stages
+	  - PDSP5 is the least busy PDSP and chosen for this
+
+Ingress
+	  - Added entries in IP LUT to match UDP/TCP and forward the same
+	    to L4 LUT2
+	  - IP checksum & SCTP crc verified at L3 Engine 0
+          - UDP/TCP checksum verified at L4 Engine
+Egress
+          - IP/UDP/TCP/SCTP checksum calculated in Modify or Multi route
+                          Keystone NETCP PA Device for K2E/L
+			(resource map and packet flow diagram)
+
+driver files and functional description
+==========================================
+drivers/net/ethernet/ti/netcp_pa_core.{c|h}
+	- file used by both PA and PA2 drivers to implement netcp
+	  core module functions and common functions
+	- pa_core_ops - provide misc functions that are common across
+	  both PA modules.
+	- hw ops - PA and PA2 module register hw functions as callbacks
+	  to the core module during init. Core module invoke these functions
+	  to pass control to the hw module (PA and PA2)
+drivers/net/ethernet/ti/netcp_pa_host.h
+	- common host specific message header format definitions/macros
+	  across PA and PA2 drivers
+drivers/net/ethernet/ti/netcp_pa.c
+	- PA driver module. PA has multiple clusters (1 PDSP per cluster).
+	- PA driver configures L2 (cluster 0) and L3 engines for MAC and IP
+	  rules in the Ingress paths. IP packets are forwarded to Modify/
+	  Multi route Engine 1 for Tx checksum calculation. The commands
+	  to PA for doing this are added to data packets send to PA PDSP
+	  associated with Modify/Multi route Engine 1. These gets added
+	  to data packets as part of tx hooks. Rx hook checks the checksum
+	  status and report the same to the stack.
+	- Provide Timestamps to tx and rx packets.
+
+drivers/net/ethernet/ti/netcp_pa_fw.h
+	- PA firmware interface definitions. All command message structures
+	  are defined in this file. These are to be kept in sync with
+	  TI's PA Low Level Design (LLD).
+
+Firmware required by the drivers
+================================
+
+PA driver is responsible for loading and running the PA PDSP available in
+each cluster. Following firmwares are required
+
+PA firmwares:-
+	ks2_pa_pdsp0_classify1.bin
+	ks2_pa_pdsp1_classify1.bin
+	ks2_pa_pdsp2_classify1.bin
+	ks2_pa_pdsp3_classify2.bin
+	ks2_pa_pdsp4_pam.bin
+	ks2_pa_pdsp5_pam.bin
+
+Format:
+	The firmware image file contains firmware blob with a header.
+	The format of the image is as follows:-
+	+----------------------------------+
+	|   16 chars of version string	   |
+	+----------------------------------+
+	|    4 Constants(32 bits) for PA   |
+	+----------------------------------+
+	|	Firmware blob		   |
+	+----------------------------------+
+
+DT Specifications at
+<file:Documentation/devicetree/bindings/net/keystone-netcp.txt>
diff --git a/Documentation/devicetree/bindings/net/keystone-netcp.txt b/Documentation/devicetree/bindings/net/keystone-netcp.txt
index 96b7925..ce9f53c 100644
--- a/Documentation/devicetree/bindings/net/keystone-netcp.txt
+++ b/Documentation/devicetree/bindings/net/keystone-netcp.txt
@@ -62,7 +62,9 @@ Optional properties:
 		big endian mode with the DSP in little endian.
 
 NetCP device properties: Device specification for NetCP sub-modules.
+
 1Gb/10Gb (gbe/xgbe) ethernet switch sub-module specifications.
+===================================================================
 Required properties:
 - label:	Must be "netcp-gbe" for 1Gb & "netcp-xgbe" for 10Gb.
 - compatible:	Must be one of below:-
@@ -387,3 +389,146 @@ netcpx: netcpx@2f00000 {
 		};
 	};
 };
+
+Packet Accelarator sub-module specifications.
+=============================================
+
+Note: The bindings are experimental and may change while feature development
+is in progress. However attempt will be made to make changes backward
+compatible if possible.
+
+Required properties:
+- label:	Must be "netcp-pa" for PA on K2H/K SoC
+		Must be "netcp-pa2" for PA2 on K2L/E SoCs
+
+- compatible:	Must be one of below:-
+		"ti,netcp-pa" for PA
+		"ti,netcp-pa2" for PA2
+
+- reg:		register location and the size for the following register
+		regions in the specified order.
+
+		Packet Accelarator (PA)
+		- Mailbox
+		- Packet ID
+		- LUT2
+		- streaming switch
+		- Control
+		- Timers
+		- Statistics
+		- IRAM
+		- SRAM
+
+		Packet Accelarator 2 (PA2)
+		- Mailbox
+		- RA bridge
+		- Thread mapper
+		- RA
+		- Statistics regs
+		- Statistics block
+		- cluster memory
+
+- clusters:	Contain cluster specific configuration
+		reg:		 cluster ID
+		tx-queue:	 Queue for sending commands/data to a cluster
+		tx-channel:	 knav Tx channel associated with the queue
+
+- tx-cmd-pool:	specifies the number of descriptors to be used & the region-id
+		for creating the tx descriptor pool for tx channnels.
+- rx-cmd-rsp-chan:		rx channel name for receiving responses from
+				PDSPs
+- rx-cmd-rsp-pool:		specifies the number of descriptors to be used
+				& the region-id for creating the rx descriptor
+				pool for rx rsp channel.
+- rx-cmd-rsp-queue-depth:	number of descriptors in each of the free
+				descriptor queue (FDQ) for the pktdma Rx flow.
+				There can be at present a maximum of 4 queues
+				per Rx flow.
+- rx-cmd-rsp-buffer-size:	Size of the buffers allocated for the desc
+				in each rx response FDQs.
+- mac-lut-ranges:		LUT range of index used by PA device for MAC
+				rules. LUT is shared across different software
+				components in the system and this range is
+				reserved for PA device.
+- rx-route:			Rx Queue / Flow base used by PA. They should
+				match with rx-channel queue / flow for netcp
+				ethernet interface when PA is in the rx path.
+- netcp-interfaces:		interface specific configuration for PA.
+	slave-port		cpsw slave port number for the interface
+Optional properties:-
+
+- ip-lut-ranges:		LUT range of index reserved for PA device.
+				Used for rx checksum handling.
+- netcp-interfaces:		interface specific configuration for PA.
+		rx-channel:	rx channel name for ethernet interface when PA
+				is in the rx path for data. Uses a different
+				flow id when PA is added to the rx path.
+- disable-hw-timestamp:	Disable hw timestamp feature.
+
+Example:
+
+PA is a netcp device and appears under netcp-devices node. Example bindings for
+PA device is provided below.
+
+	netcp-devices {
+
+		<other netcp devices>
+
+		pa@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			label = "netcp-pa";
+			compatible = "ti,netcp-pa";
+
+			reg = <0 0x60>,			/* Mailbox */
+				<0x400 0x10>,		/* Packet ID */
+				<0x500 0x40>,		/* LUT2 */
+				<0x604 0x4>,		/* streaming switch */
+				<0x1000 0x600>,		/* Control */
+				<0x3000 0x600>,		/* Timers */
+				<0x6000 0x100>,		/* Statistics */
+				<0x10000 0x30000>,	/* Iram */
+				<0x40000 0x8000>;	/* Sram */
+
+			mac-lut-ranges		= <0 43 56 63>;
+			/* Static reservation in LUT-1 (outer IP)
+			 * used by driver to add IP rules for Rx checksum
+			 * offload.
+			 */
+			ip-lut-ranges		= <61 63>;
+			/* base queue, base flow. Should match with that
+			 * for netrx0
+			 */
+			rx-route		= <8704 22>;
+			tx-cmd-pool		= <256 12>;
+			/* rx command pool */
+			rx-cmd-rsp-pool		= <256 12>;
+			/* rx channel name for command response */
+			rx-cmd-rsp-chan		= "pa-cmd-rsp";
+			rx-cmd-rsp-queue-depth	= <128 32 0 0>;
+			rx-cmd-rsp-buffer-size	= <128 512 0 0>;
+
+			/* PA clusters that does packet processing */
+			clusters {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				cluster@0 {
+					reg = <0>;
+					tx-queue = <640>;
+					tx-channel = "pa-cl0";
+				};
+
+				cluster@1 {
+					reg = <1>;
+					tx-queue = <641>;
+					tx-channel = "pa-cl1";
+				};
+
+				cluster@5 {
+					reg = <5>;
+					tx-queue = <645>;
+					tx-channel = "pa-cl5";
+				};
+			};
+		};
+	};
diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig
index e3cbe78..8d1112a4 100644
--- a/drivers/net/ethernet/ti/Kconfig
+++ b/drivers/net/ethernet/ti/Kconfig
@@ -112,6 +112,17 @@ config TI_KEYSTONE_NETCP_PA_CORE
 	  To compile this driver as a module, choose M here: the module
 	  will be called netcp_pa_core.
 
+config TI_KEYSTONE_NETCP_PA
+	depends on TI_KEYSTONE_NETCP && TI_KEYSTONE_NETCP_PA_CORE
+	tristate "TI Keystone NETCP Packet Accelerator (PA) Support"
+	---help---
+
+	  This driver supports the NETCP PA hardware found on K2HK
+	  SoC. To compile this driver as a module, choose M here: the module
+	  will be called keystone_netcp_pa. Please read the file
+          <file:Documentation/arm/keystone/netcp-pa.txt> to know more details
+	  about the driver.
+
 config TLAN
 	tristate "TI ThunderLAN support"
 	depends on (PCI || EISA)
diff --git a/drivers/net/ethernet/ti/Makefile b/drivers/net/ethernet/ti/Makefile
index 415f41d..6581935 100644
--- a/drivers/net/ethernet/ti/Makefile
+++ b/drivers/net/ethernet/ti/Makefile
@@ -20,3 +20,5 @@ keystone_netcp-y := netcp_core.o
 obj-$(CONFIG_TI_KEYSTONE_NETCP_ETHSS) += keystone_netcp_ethss.o
 keystone_netcp_ethss-y := netcp_ethss.o netcp_sgmii.o
 obj-$(CONFIG_TI_KEYSTONE_NETCP_PA_CORE) += netcp_pa_core.o
+obj-$(CONFIG_TI_KEYSTONE_NETCP_PA) += keystone_netcp_pa.o
+keystone_netcp_pa-y := netcp_pa.o
diff --git a/drivers/net/ethernet/ti/netcp_pa.c b/drivers/net/ethernet/ti/netcp_pa.c
new file mode 100644
index 0000000..b3c71f4
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa.c
@@ -0,0 +1,1149 @@
+/*
+ * Keystone NetCP PA (Packet Accelerator) Driver
+ *
+ * Copyright (C) 2012-2015 Texas Instruments Incorporated
+ * Author: Murali Karicheri <m-karicheri2@ti.com>
+ *
+ * Other contributors:	Sandeep Paulraj (Initial version of the driver)
+ *			Reece Pollack (Maintenance)
+ *			Sandeep Nair (Maintenance)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/errqueue.h>
+#include <linux/firmware.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/byteorder/generic.h>
+#include <linux/soc/ti/knav_dma.h>
+#include <linux/soc/ti/knav_qmss.h>
+
+#include "netcp.h"
+#include "netcp_pa_core.h"
+#include "netcp_pa_host.h"
+#include "netcp_pa_fw.h"
+
+#define PSTREAM_ROUTE_PDSP0			0
+#define PA_PDSP_ALREADY_ACTIVE			0
+#define PA_PDSP_RESET_RELEASED			1
+#define PA_PDSP_NO_RESTART			2
+#define PA_MAX_PDSP_ENABLE_LOOP_COUNT	100000
+/* Sub-system state enable  */
+#define PA_STATE_ENABLE				1
+/*  The Sub-system did not respond after restart */
+#define PA_STATE_ENABLE_FAILED			3
+#define PAFRM_SRAM_SIZE				0x2000
+/* PDSP Versions */
+#define PAFRM_PDSP_VERSION_BASE			0x7F04
+#define DEVICE_PA_REGION_SIZE			0x48000
+#define PA_MEM_PDSP_IRAM(pdsp)			((pdsp) * 0x8000)
+#define PA_MEM_PDSP_SRAM(num)			((num) * 0x2000)
+#define PA_PDSP_CONST_REG_INDEX_C25_C24		0
+#define PA_PDSP_CONST_REG_INDEX_C27_C26		1
+#define PA_PDSP_CONST_REG_INDEX_C29_C28		2
+#define PA_PDSP_CONST_REG_INDEX_C31_C30		3
+
+/* The pdsp control register bits */
+#define PA_REG_VAL_PDSP_CTL_RESET_PDSP	        0
+#define PA_REG_VAL_PDSP_CTL_STATE		BIT(15)
+#define PA_REG_VAL_PDSP_CTL_ENABLE		BIT(1)
+#define PA_REG_VAL_PDSP_CTL_SOFT_RESET		BIT(0)
+
+/* register indices in DT bindings */
+#define PA_MB_REG_INDEX				0
+#define PA_PACKET_ID_REG_INDEX			1
+#define PA_LUT2_REG_INDEX			2
+#define PA_SS_INDEX				3
+#define PA_CONTROL_REG_INDEX			4
+#define PA_TIMER_REG_INDEX			5
+#define PA_STATS_REG_INDEX			6
+#define PA_IRAM_INDEX				7
+#define PA_SRAM_INDEX				8
+
+#define PA_CONTEXT_MASK				0xffff0000
+#define PA_CONTEXT_CONFIG			0xdead0000
+
+static struct pa_core_ops *core_ops = &netcp_pa_core_ops;
+
+enum clusters {
+	PA_CLUSTER_0,
+	PA_CLUSTER_1,
+	PA_CLUSTER_2,
+	PA_CLUSTER_3,
+	PA_CLUSTER_4,
+	PA_CLUSTER_5,
+	PA_NUM_CLUSTERS
+};
+
+#define PA_NUM_CONSTANTS			4
+#define PA_NUM_PDSPS				6
+/* firmwares used for various PDSPs. This list is to be kept
+ * with latest firmware first followed by older firmares
+ */
+static const char *pa_pdsp_firmwares[PA_NUM_PDSPS][PA_MAX_FIRMWARES] = {
+	{ "ks2_pa_pdsp0_classify1.bin", },
+	{ "ks2_pa_pdsp1_classify1.bin", },
+	{ "ks2_pa_pdsp2_classify1.bin", },
+	{ "ks2_pa_pdsp3_classify2.bin", },
+	{ "ks2_pa_pdsp4_pam.bin", },
+	{ "ks2_pa_pdsp5_pam.bin", },
+};
+
+struct pa_mailbox_regs {
+	u32 pdsp_mailbox_slot0;
+	u32 pdsp_mailbox_slot1;
+	u32 pdsp_mailbox_slot2;
+	u32 pdsp_mailbox_slot3;
+};
+
+struct pa_packet_id_alloc_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 range_limit;
+	u32 idvalue;
+};
+
+struct pa_lut2_control_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 rsvd[6];
+	u32 add_data0;
+	u32 add_data1;
+	u32 add_data2;
+	u32 add_data3;
+	u32 add_del_key;
+	u32 add_del_control;
+};
+
+struct pa_pdsp_control_regs {
+	u32 control;
+	u32 status;
+	u32 wakeup_enable;
+	u32 cycle_count;
+	u32 stall_count;
+	u32 rsvd[3];
+	u32 const_tbl_blk_index0;
+	u32 const_tbl_blk_index1;
+	u32 const_tbl_prog_pointer0;
+	u32 const_tbl_prog_pointer1;
+	u32 rsvd1[52];
+};
+
+struct pa_pdsp_timer_regs {
+	u32 timer_control;
+	u32 timer_load;
+	u32 timer_value;
+	u32 timer_interrupt;
+	u32 rsvd[60];
+};
+
+struct pa_statistics_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 incr_flags;
+	u32 stats_capture;
+	u32 rsvd[4];
+	u32 stats_red[32];
+};
+
+struct pa_device {
+	struct pa_core_device	core_dev;
+	struct pa_mailbox_regs __iomem		*reg_mailbox;
+	struct pa_packet_id_alloc_regs __iomem	*reg_packet_id;
+	struct pa_lut2_control_regs __iomem	*reg_lut2;
+	struct pa_pdsp_control_regs __iomem	*reg_control;
+	struct pa_pdsp_timer_regs   __iomem	*reg_timer;
+	struct pa_statistics_regs   __iomem	*reg_stats;
+	void __iomem	*pa_sram;
+	void __iomem	*pa_iram;
+	void __iomem	*streaming_switch;
+};
+
+#define to_pa(data)	container_of(data, struct pa_device, core_dev)
+
+static inline void swiz_fwd(struct pa_frm_forward *fwd)
+{
+	fwd->queue = cpu_to_be16(fwd->queue);
+	if (fwd->forward_type == PAFRM_FORWARD_TYPE_HOST)
+		fwd->u.host.context = cpu_to_be32(fwd->u.host.context);
+}
+
+static inline void swizfcmd(struct pa_frm_command *fcmd)
+{
+	fcmd->command_result = cpu_to_be32(fcmd->command_result);
+	fcmd->com_id = cpu_to_be16(fcmd->com_id);
+	fcmd->ret_context = cpu_to_be32(fcmd->ret_context);
+	fcmd->reply_queue = cpu_to_be16(fcmd->reply_queue);
+}
+
+static inline void swizal1(struct pa_frm_cmd_add_lut1 *al1)
+{
+	if (al1->type == PAFRM_COM_ADD_LUT1_STANDARD) {
+		al1->u.eth_ip.etype = cpu_to_be16(al1->u.eth_ip.etype);
+		al1->u.eth_ip.vlan = cpu_to_be16(al1->u.eth_ip.vlan);
+		al1->u.eth_ip.spi = cpu_to_be32(al1->u.eth_ip.spi);
+		al1->u.eth_ip.flow = cpu_to_be32(al1->u.eth_ip.flow);
+
+		if (al1->u.eth_ip.key & PAFRM_LUT1_KEY_MPLS) {
+			al1->u.eth_ip.pm.mpls =
+				cpu_to_be32(al1->u.eth_ip.pm.mpls);
+		} else {
+			al1->u.eth_ip.pm.ports[0] =
+				cpu_to_be16(al1->u.eth_ip.pm.ports[0]);
+			al1->u.eth_ip.pm.ports[1] =
+				cpu_to_be16(al1->u.eth_ip.pm.ports[1]);
+		}
+		al1->u.eth_ip.match_flags =
+				cpu_to_be16(al1->u.eth_ip.match_flags);
+	} else {
+		al1->u.custom.etype = cpu_to_be16(al1->u.custom.etype);
+		al1->u.custom.vlan = cpu_to_be16(al1->u.custom.vlan);
+		al1->u.custom.match_flags =
+				cpu_to_be16(al1->u.custom.match_flags);
+	}
+
+	swiz_fwd(&al1->match);
+	swiz_fwd(&al1->next_fail);
+}
+
+static int pa_conv_routing_info(struct pa_frm_forward *fwd_info,
+				struct pa_route_info *route_info,
+				int cmd_dest, u16 fail_route)
+{
+	u8 *pcmd = NULL;
+
+	fwd_info->flow_id = route_info->flow_id;
+	fwd_info->queue = route_info->queue;
+
+	if (route_info->dest == PA_DEST_HOST) {
+		fwd_info->forward_type   = PAFRM_FORWARD_TYPE_HOST;
+		fwd_info->u.host.context = route_info->sw_info_0;
+
+		if (route_info->route_type)
+			fwd_info->u.host.ctrl_bm |=
+				PAFRM_ROUTING_IF_DEST_SELECT_ENABLE;
+
+		if (route_info->route_type == PA_ROUTE_INTF_FLOW)
+			fwd_info->u.host.ctrl_bm |=
+				PAFRM_ROUTING_FLOW_IF_BASE_ENABLE;
+
+		if (route_info->m_route_index >= 0) {
+			if (route_info->m_route_index >=
+			    PA_MAX_MULTI_ROUTE_SETS)
+				return PA_ERR_CONFIG;
+
+			fwd_info->u.host.ctrl_bm |= PAFRM_MULTIROUTE_ENABLE;
+			fwd_info->u.host.multi_idx = route_info->m_route_index;
+			fwd_info->u.host.pa_pdsp_router	= PAFRM_DEST_PA_M_0;
+		}
+		pcmd = fwd_info->u.host.cmd;
+	} else if (route_info->dest == PA_DEST_DISCARD)	{
+		fwd_info->forward_type = PAFRM_FORWARD_TYPE_DISCARD;
+	} else if (fail_route) {
+		return PA_ERR_CONFIG;
+
+	} else if (((route_info->dest == PA_DEST_CONTINUE_PARSE_LUT1) &&
+		    (route_info->custom_type != PA_CUSTOM_TYPE_LUT2)) ||
+		   ((route_info->dest == PA_DEST_CONTINUE_PARSE_LUT2) &&
+		    (route_info->custom_type != PA_CUSTOM_TYPE_LUT1))) {
+		/* Custom Error check */
+		if (((route_info->custom_type == PA_CUSTOM_TYPE_LUT1) &&
+		     (route_info->custom_index >= PA_MAX_CUSTOM_TYPES_LUT1)) ||
+		    ((route_info->custom_type == PA_CUSTOM_TYPE_LUT2) &&
+		     (route_info->custom_index >= PA_MAX_CUSTOM_TYPES_LUT2)))
+			return PA_ERR_CONFIG;
+
+		fwd_info->forward_type = PAFRM_FORWARD_TYPE_PA;
+		fwd_info->u.pa.custom_type = (u8)route_info->custom_type;
+		fwd_info->u.pa.custom_idx  = route_info->custom_index;
+
+		if (route_info->dest == PA_DEST_CONTINUE_PARSE_LUT2) {
+			fwd_info->u.pa.pa_dest = PAFRM_DEST_PA_C2;
+		} else {
+			/* cmd_dest is provided by calling function
+			 * There is no need to check error case
+			 */
+			fwd_info->u.pa.pa_dest =
+				(cmd_dest == PA_CMD_TX_DEST_0) ?
+				PAFRM_DEST_PA_C1_1 : PAFRM_DEST_PA_C1_2;
+		}
+	} else {
+		return PA_ERR_CONFIG;
+	}
+
+	if (pcmd && route_info->pcmd) {
+		struct pa_cmd_info *pacmd = route_info->pcmd;
+		struct pa_patch_info *patch_info;
+		struct pa_cmd_set *cmd_set;
+
+		switch (pacmd->cmd) {
+		case PA_CMD_PATCH_DATA:
+			patch_info = &pacmd->params.patch;
+			if ((patch_info->n_patch_bytes > 2) ||
+			    (patch_info->overwrite) ||
+			    (!patch_info->patch_data))
+				return PA_ERR_CONFIG;
+
+			pcmd[0] = PAFRM_RX_CMD_CMDSET;
+			pcmd[1] = patch_info->n_patch_bytes;
+			pcmd[2] = patch_info->patch_data[0];
+			pcmd[3] = patch_info->patch_data[1];
+			break;
+
+		case PA_CMD_CMDSET:
+			cmd_set = &pacmd->params.cmd_set;
+			if (cmd_set->index >= PA_MAX_CMD_SETS)
+				return PA_ERR_CONFIG;
+
+			pcmd[0] = PAFRM_RX_CMD_CMDSET;
+			pcmd[1] = (u8)cmd_set->index;
+			break;
+		default:
+			return PA_ERR_CONFIG;
+		}
+	}
+	return PA_OK;
+}
+
+static void pa_reset(struct pa_core_device *core_dev)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct pa_packet_id_alloc_regs
+		__iomem *packet_id_regs = pa_dev->reg_packet_id;
+	struct pa_lut2_control_regs
+		__iomem	*lut2_regs = pa_dev->reg_lut2;
+	struct pa_statistics_regs
+		__iomem	*stats_regs = pa_dev->reg_stats;
+	/* per experiment it takes about 6 msec to reset PDSPS  */
+	int count = 10;
+	u32 i, val;
+
+	/* Reset and disable all PDSPs */
+	for (i = 0; i < PA_NUM_PDSPS; i++) {
+		struct pa_pdsp_control_regs __iomem *ctrl_reg =
+					&pa_dev->reg_control[i];
+
+		writel(PA_REG_VAL_PDSP_CTL_RESET_PDSP,
+		       &ctrl_reg->control);
+
+		while (count--) {
+			val = readl(&ctrl_reg->control) &
+				    PA_REG_VAL_PDSP_CTL_STATE;
+			if (val)
+				usleep_range(100, 1000);
+			else
+				break;
+		}
+	}
+	WARN((count == 0), "PA reset failure\n");
+
+	/* Reset packet Id */
+	writel(1, &packet_id_regs->soft_reset);
+
+	/* Reset LUT2 */
+	writel(1, &lut2_regs->soft_reset);
+
+	/* Reset statistic */
+	writel(1, &stats_regs->soft_reset);
+
+	/* Reset timers */
+	for (i = 0; i < PA_NUM_PDSPS; i++) {
+		struct pa_pdsp_timer_regs __iomem *timer_reg =
+					&pa_dev->reg_timer[i];
+
+		writel(0, &timer_reg->timer_control);
+	}
+}
+
+static int pa_pdsp_run(struct pa_device *pa_dev, int pdsp)
+{
+	struct pa_pdsp_control_regs __iomem *ctrl_reg =
+				&pa_dev->reg_control[pdsp];
+	struct pa_mailbox_regs __iomem *mailbox_reg =
+				&pa_dev->reg_mailbox[pdsp];
+	u32 i, v;
+
+	/* Check for enabled PDSP */
+	v = readl(&ctrl_reg->control);
+	if ((v & PA_REG_VAL_PDSP_CTL_ENABLE) == PA_REG_VAL_PDSP_CTL_ENABLE) {
+		/* Already enabled */
+		return PA_PDSP_ALREADY_ACTIVE;
+	}
+
+	/* Clear the mailbox */
+	writel(0, &mailbox_reg->pdsp_mailbox_slot0);
+
+	/* Set PDSP PC to 0, enable the PDSP */
+	writel(PA_REG_VAL_PDSP_CTL_ENABLE | PA_REG_VAL_PDSP_CTL_SOFT_RESET,
+	       &ctrl_reg->control);
+
+	/* Wait for the mailbox to become non-zero */
+	for (i = 0; i < PA_MAX_PDSP_ENABLE_LOOP_COUNT; i++) {
+		v = readl(&mailbox_reg->pdsp_mailbox_slot0);
+		if (v != 0)
+			return PA_PDSP_RESET_RELEASED;
+	}
+
+	return PA_PDSP_NO_RESTART;
+}
+
+static int pa_enable(struct pa_device *pa_dev)
+{
+	struct pa_mailbox_regs __iomem *mailbox_reg = &pa_dev->reg_mailbox[0];
+	int do_global_reset = 1, i, res, ret =  PA_STATE_ENABLE;
+
+	/* Do nothing if a pdsp is already out of reset.
+	 * If any PDSPs are out of reset
+	 * a global init is not performed
+	 */
+	for (i = 0; i < PA_NUM_PDSPS; i++) {
+		res = pa_pdsp_run(pa_dev, i);
+
+		if (res == PA_PDSP_ALREADY_ACTIVE)
+			do_global_reset = 0;
+
+		if (res == PA_PDSP_NO_RESTART) {
+			ret = PA_STATE_ENABLE_FAILED;
+			do_global_reset = 0;
+		}
+	}
+
+	/* If global reset is required any PDSP can do it */
+	if (do_global_reset) {
+		int count = 5; /* found by experiment */
+
+		writel(1, &mailbox_reg->pdsp_mailbox_slot1);
+		writel(0, &mailbox_reg->pdsp_mailbox_slot0);
+
+		while (count-- &&
+		       (readl(&mailbox_reg->pdsp_mailbox_slot1) != 0))
+			usleep_range(100, 1000);
+
+		WARN((count == 0), "PA reset failure\n");
+
+		for (i = 1; i < PA_NUM_PDSPS; i++) {
+			struct pa_mailbox_regs __iomem *mbox_reg =
+				&pa_dev->reg_mailbox[i];
+
+			writel(0, &mbox_reg->pdsp_mailbox_slot0);
+		}
+	} else {
+		for (i = 0; i < PA_NUM_PDSPS; i++) {
+			struct pa_mailbox_regs __iomem *mbox_reg =
+				&pa_dev->reg_mailbox[i];
+
+			writel(0, &mbox_reg->pdsp_mailbox_slot0);
+		}
+	}
+
+	return ret;
+}
+
+static int pa_post_init(struct pa_core_device *core_dev)
+{
+	struct pa_pdsp_timer_regs __iomem *timer_reg;
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct device *dev = pa_dev->core_dev.dev;
+	int i, version, ret;
+	char *str;
+
+	ret = pa_enable(pa_dev);
+	if (ret != PA_STATE_ENABLE) {
+		dev_err(dev, "%s: enable failed, ret = %d\n", __func__, ret);
+		return -ENODEV;
+	}
+
+	version = readl(pa_dev->pa_sram + PAFRM_PDSP_VERSION_BASE);
+	for (i = 0; i < core_dev->hw->num_pdsps; i++) {
+		str = core_dev->version + (i * PA_SIZE_VERSION);
+		dev_info(dev, "Using PA fw version %s:0x%08x on pdsp %d\n",
+			 str, version, i);
+	}
+
+	timer_reg = &pa_dev->reg_timer[0];
+	/* Start PDSP timer at a prescaler of divide by 2 */
+	writel(0xffff, &timer_reg->timer_load);
+	writel((PA_SS_TIMER_CNTRL_REG_GO | PA_SS_TIMER_CNTRL_REG_MODE |
+	       PA_SS_TIMER_CNTRL_REG_PSE |
+	       (0 << PA_SS_TIMER_CNTRL_REG_PRESCALE_SHIFT)),
+	       &timer_reg->timer_control);
+
+	return 0;
+}
+
+static int pa_set_firmware(struct pa_core_device *core_dev,
+			   int pdsp, const unsigned int *buffer,
+			   int len)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct pa_pdsp_control_regs __iomem *ctrl_reg =
+						&pa_dev->reg_control[pdsp];
+	int size_header = PA_NUM_CONSTANTS + (PA_SIZE_VERSION >> 2);
+	char *version;
+
+	if ((pdsp < 0) || (pdsp >= PA_NUM_PDSPS))
+		return -EINVAL;
+
+	version = core_dev->version + (pdsp * PA_SIZE_VERSION);
+	/* extract version from the top of the buffer */
+	memcpy(version, buffer, PA_SIZE_VERSION);
+	*(version + PA_SIZE_VERSION - 1) = '\0';
+
+	/* offset of constants */
+	buffer += (PA_SIZE_VERSION >> 2);
+
+	writel(buffer[PA_PDSP_CONST_REG_INDEX_C25_C24],
+	       &ctrl_reg->const_tbl_blk_index0);
+
+	writel(buffer[PA_PDSP_CONST_REG_INDEX_C27_C26],
+	       &ctrl_reg->const_tbl_blk_index1);
+
+	writel(buffer[PA_PDSP_CONST_REG_INDEX_C29_C28],
+	       &ctrl_reg->const_tbl_prog_pointer0);
+
+	writel(buffer[PA_PDSP_CONST_REG_INDEX_C31_C30],
+	       &ctrl_reg->const_tbl_prog_pointer1);
+
+	buffer += PA_NUM_CONSTANTS;
+	core_ops->load_firmware((pa_dev->pa_iram + PA_MEM_PDSP_IRAM(pdsp)),
+				buffer, (len >> 2) - size_header);
+	return 0;
+}
+
+static void pa_rx_packet_handler(void *param)
+{
+	struct pa_packet *p_info = param;
+	struct pa_core_device *core_dev = p_info->core_dev;
+	struct pa_frm_command *fcmd;
+
+	switch (p_info->hwdesc->epib[1] & PA_CONTEXT_MASK) {
+	case PA_CONTEXT_CONFIG:
+		fcmd = p_info->data;
+		swizfcmd(fcmd);
+
+		if (fcmd->command_result != PAFRM_COMMAND_RESULT_SUCCESS) {
+			dev_dbg(core_dev->dev, "Command Result = 0x%x\n",
+				fcmd->command_result);
+			dev_dbg(core_dev->dev, "Command = 0x%x\n",
+				fcmd->command);
+			dev_dbg(core_dev->dev, "Magic = 0x%x\n", fcmd->magic);
+			dev_dbg(core_dev->dev, "Com ID = 0x%x\n", fcmd->com_id);
+			dev_dbg(core_dev->dev, "ret Context = 0x%x\n",
+				fcmd->ret_context);
+			dev_dbg(core_dev->dev, "Flow ID = 0x%x\n",
+				fcmd->flow_id);
+			dev_dbg(core_dev->dev, "reply Queue = 0x%x\n",
+				fcmd->reply_queue);
+			dev_dbg(core_dev->dev, "reply dest = 0x%x\n",
+				fcmd->reply_dest);
+		}
+		dev_dbg(core_dev->dev, "command response complete\n");
+		break;
+
+	default:
+		dev_warn(core_dev->dev,
+			 "%s: bad response context, got 0x%08x\n",
+			 __func__, p_info->epib[1]);
+		break;
+	}
+}
+
+static void
+pa_format_cmd_hdr(struct pa_device *pa_dev,
+		  struct pa_frm_command *fcmd, u8 cmd, u16 cmd_id, u32 ctx)
+{
+	struct pa_core_device *core_dev = &pa_dev->core_dev;
+
+	memset(fcmd, 0, sizeof(*fcmd));
+	fcmd->command = cmd;
+	fcmd->magic = PAFRM_CONFIG_COMMAND_SEC_BYTE;
+	fcmd->com_id = cpu_to_be16(cmd_id);
+	fcmd->ret_context = cpu_to_be32(ctx);
+	fcmd->flow_id = core_dev->cmd_flow_num;
+	fcmd->reply_queue = cpu_to_be16(core_dev->cmd_queue_num);
+	fcmd->reply_dest = PAFRM_DEST_PKTDMA;
+}
+
+static int pa_add_ip_proto(struct pa_core_device *core_dev, int index,
+			   u8 proto, int rule)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct pa_route_info route_info, fail_info;
+	struct pa_frm_cmd_add_lut1 *al1;
+	u32 context = PA_CONTEXT_CONFIG;
+	struct pa_frm_command *fcmd;
+	unsigned flow_num, q_num;
+	struct pa_packet *tx;
+	int size, ret;
+
+	dev_dbg(core_dev->dev, "index %d, rule %d, proto %d\n",
+		index, rule, proto);
+
+	memset(&fail_info, 0, sizeof(fail_info));
+	memset(&route_info, 0, sizeof(route_info));
+
+	q_num = core_dev->rx_queue_base;
+	flow_num = core_dev->rx_flow_base;
+
+	if (rule == PACKET_HST) {
+		route_info.dest			= PA_DEST_HOST;
+		route_info.flow_id		= flow_num;
+		route_info.queue		= q_num;
+		route_info.m_route_index	= -1;
+		route_info.route_type		= PA_ROUTE_INTF_FLOW;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= flow_num;
+		fail_info.queue			= q_num;
+		fail_info.m_route_index		= -1;
+		fail_info.route_type		= PA_ROUTE_INTF_FLOW;
+	} else if (rule == PACKET_PARSE) {
+		route_info.dest			= PA_DEST_CONTINUE_PARSE_LUT2;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= flow_num;
+		fail_info.queue			= q_num;
+		fail_info.m_route_index		= -1;
+		fail_info.route_type		= PA_ROUTE_INTF_FLOW;
+	} else if (rule == PACKET_DROP) {
+		route_info.dest			= PA_DEST_DISCARD;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_DISCARD;
+		fail_info.m_route_index		= -1;
+	}
+
+	size = (sizeof(struct pa_frm_command) +
+		sizeof(struct pa_frm_cmd_add_lut1) + 4);
+
+	tx = core_ops->alloc_packet(core_dev, size, PA_CLUSTER_1);
+	if (!tx) {
+		dev_err(core_dev->dev,
+			"%s: could not allocate cmd tx packet\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	fcmd = tx->data;
+	al1 = (struct pa_frm_cmd_add_lut1 *)&fcmd->cmd;
+	memset(al1, 0, sizeof(*al1));
+	pa_format_cmd_hdr(pa_dev, fcmd, PAFRM_CONFIG_COMMAND_ADDREP_LUT1,
+			  PA_COMID_L3, context);
+
+	al1->index = index;
+	al1->type = PAFRM_COM_ADD_LUT1_STANDARD;
+	al1->u.eth_ip.proto_next = proto;
+	al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_PROTO;
+	al1->u.eth_ip.match_flags = cpu_to_be16(al1->u.eth_ip.match_flags);
+	ret = pa_conv_routing_info(&al1->match, &route_info, 0, 0);
+	if (ret != 0) {
+		dev_err(core_dev->dev, "%s:route info config failed\n",
+			__func__);
+		goto fail;
+	}
+	ret = pa_conv_routing_info(&al1->next_fail, &fail_info, 0, 1);
+	if (ret != 0) {
+		dev_err(core_dev->dev, "%s:fail info config failed\n",
+			__func__);
+		goto fail;
+	}
+
+	swiz_fwd(&al1->match);
+	swiz_fwd(&al1->next_fail);
+
+	/* Indicate that it is a configuration command */
+	tx->psdata[0] = BIT(31);
+	return core_ops->submit_packet(tx, PA_CLUSTER_1);
+
+fail:
+	core_ops->free_packet(core_dev, tx);
+	return ret;
+}
+
+/* Configure route for exception packets in PA
+ * All exceptions will be routed to Linux
+ */
+static int pa_config_exception_route(struct pa_core_device *core_dev)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct pa_route_info eroutes[EROUTE_N_MAX];
+	struct pa_frm_command_sys_config_pa *cpa;
+	u32 context = PA_CONTEXT_CONFIG;
+	struct pa_frm_command *fcmd;
+	struct pa_packet *tx;
+	int i, size, ret;
+
+	memset(eroutes, 0, sizeof(eroutes));
+	size = (sizeof(struct pa_frm_command) +
+		sizeof(struct pa_frm_command_sys_config_pa) + 4);
+
+	tx = core_ops->alloc_packet(core_dev, size, PA_CLUSTER_1);
+	if (!tx) {
+		dev_err(core_dev->dev,
+			"%s: could not allocate cmd tx packet\n",
+			__func__);
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	fcmd = tx->data;
+	cpa = (struct pa_frm_command_sys_config_pa *)&fcmd->cmd;
+	memset(cpa, 0, sizeof(*cpa));
+	pa_format_cmd_hdr(pa_dev, fcmd, PAFRM_CONFIG_COMMAND_SYS_CONFIG,
+			  0, context);
+	cpa->cfg_code = PAFRM_SYSTEM_CONFIG_CODE_EROUTE;
+
+	for (i = 0; i < EROUTE_N_MAX; i++) {
+		eroutes[i].dest			= PA_DEST_HOST;
+		eroutes[i].flow_id		= core_dev->rx_flow_base;
+		eroutes[i].queue		= core_dev->rx_queue_base;
+		eroutes[i].m_route_index	= -1;
+		eroutes[i].route_type		= PA_ROUTE_INTF_FLOW;
+		cpa->u.eroute.route_bitmap |= (1 << i);
+
+		ret =  pa_conv_routing_info(&cpa->u.eroute.eroute[i],
+					    &eroutes[i], PA_CMD_TX_DEST_5, 0);
+		if (ret != 0) {
+			dev_err(core_dev->dev,
+				"%s: route info config failed\n",
+				__func__);
+			goto fail;
+		}
+		swiz_fwd(&cpa->u.eroute.eroute[i]);
+	}
+	cpa->u.eroute.route_bitmap = cpu_to_be32(cpa->u.eroute.route_bitmap);
+
+	/* Indicate that it is a configuration command */
+	tx->psdata[0] = BIT(31);
+	return core_ops->submit_packet(tx, PA_CLUSTER_1);
+
+fail:
+	core_ops->free_packet(core_dev, tx);
+	return ret;
+}
+
+static int pa_add_mac_rule(struct pa_intf *pa_intf, int index,
+			   const u8 *smac, const u8 *dmac, int rule,
+			   unsigned etype, int port)
+{
+	struct pa_core_device *core_dev = pa_intf->core_dev;
+	struct pa_route_info route_info, fail_info;
+	struct pa_frm_command *fcmd;
+	struct pa_frm_cmd_add_lut1 *al1;
+	u32 context = PA_CONTEXT_CONFIG;
+	struct pa_packet *tx;
+	int size, ret;
+
+	dev_dbg(core_dev->dev,
+		"add mac, index %d, smac %pM, dmac %pM, rule %d,",
+		index, smac, dmac, rule);
+	dev_dbg(core_dev->dev,
+		"type %04x, port %d\n", etype, port);
+
+	memset(&fail_info, 0, sizeof(fail_info));
+	memset(&route_info, 0, sizeof(route_info));
+
+	if (rule == PACKET_HST) {
+		route_info.dest			= PA_DEST_HOST;
+		route_info.flow_id		= pa_intf->data_flow_num;
+		route_info.queue		= pa_intf->data_queue_num;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= -1;
+	} else if (rule == PACKET_PARSE) {
+		route_info.dest			= PA_DEST_CONTINUE_PARSE_LUT1;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= -1;
+	} else if (rule == PACKET_DROP) {
+		route_info.dest			= PA_DEST_DISCARD;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_DISCARD;
+		fail_info.m_route_index		= -1;
+	}
+
+	size = (sizeof(struct pa_frm_command) +
+		sizeof(struct pa_frm_cmd_add_lut1) + 4);
+	tx = core_ops->alloc_packet(core_dev, size, PA_CLUSTER_0);
+	if (!tx) {
+		dev_err(core_dev->dev,
+			"%s: could not allocate cmd tx packet\n",
+			__func__);
+		return -ENOMEM;
+	}
+
+	fcmd = tx->data;
+	al1 = (struct pa_frm_cmd_add_lut1 *)&fcmd->cmd;
+
+	fcmd->command_result	= 0;
+	fcmd->command		= PAFRM_CONFIG_COMMAND_ADDREP_LUT1;
+	fcmd->magic		= PAFRM_CONFIG_COMMAND_SEC_BYTE;
+	fcmd->com_id		= PA_COMID_L2;
+	fcmd->ret_context	= context;
+	fcmd->flow_id		= core_dev->cmd_flow_num;
+	fcmd->reply_queue	= core_dev->cmd_queue_num;
+	fcmd->reply_dest	= PAFRM_DEST_PKTDMA;
+
+	al1->index		= index;
+	al1->type		= PAFRM_COM_ADD_LUT1_STANDARD;
+	if (etype) {
+		al1->u.eth_ip.etype	= etype;
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_ETYPE;
+	}
+	al1->u.eth_ip.vlan	= 0;
+	al1->u.eth_ip.pm.mpls	= 0;
+	if (port) {
+		al1->u.eth_ip.inport    = port;
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_PORT;
+	}
+	if (dmac) {
+		al1->u.eth_ip.dmac[0] = dmac[0];
+		al1->u.eth_ip.dmac[1] = dmac[1];
+		al1->u.eth_ip.dmac[2] = dmac[2];
+		al1->u.eth_ip.dmac[3] = dmac[3];
+		al1->u.eth_ip.dmac[4] = dmac[4];
+		al1->u.eth_ip.dmac[5] = dmac[5];
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_DMAC;
+	}
+	if (smac) {
+		al1->u.eth_ip.smac[0] = smac[0];
+		al1->u.eth_ip.smac[1] = smac[1];
+		al1->u.eth_ip.smac[2] = smac[2];
+		al1->u.eth_ip.smac[3] = smac[3];
+		al1->u.eth_ip.smac[4] = smac[4];
+		al1->u.eth_ip.smac[5] = smac[5];
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_SMAC;
+	}
+	al1->u.eth_ip.key |= PAFRM_LUT1_KEY_MAC;
+	al1->u.eth_ip.match_flags |= PAFRM_LUT1_CUSTOM_MATCH_KEY;
+
+	ret = pa_conv_routing_info(&al1->match, &route_info, 0, 0);
+	if (ret) {
+		dev_err(core_dev->dev, "%s: route info config failed\n",
+			__func__);
+		goto fail;
+	}
+
+	ret = pa_conv_routing_info(&al1->next_fail, &fail_info, 0, 1);
+	if (ret) {
+		dev_err(core_dev->dev, "%s:fail info config failed\n",
+			__func__);
+		goto fail;
+	}
+
+	swizfcmd(fcmd);
+	swizal1((struct pa_frm_cmd_add_lut1 *)&fcmd->cmd);
+
+	tx->psdata[0] = BIT(31);
+	return core_ops->submit_packet(tx, PA_CLUSTER_0);
+
+fail:
+	core_ops->free_packet(core_dev, tx);
+	return ret;
+}
+
+static int pa_fmtcmd_tx_csum(struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct paho_com_chk_crc *ptx;
+	int start, len;
+	int size;
+
+	size = sizeof(*ptx);
+	ptx = (struct paho_com_chk_crc *)netcp_push_psdata(p_info, size);
+
+	start = skb_checksum_start_offset(skb);
+	len = skb->len - start;
+
+	ptx->word0 = 0;
+	ptx->word1 = 0;
+	ptx->word2 = 0;
+	PAHO_SET_CMDID(ptx, PAHO_PAMOD_CMPT_CHKSUM);
+	PAHO_CHKCRC_SET_START(ptx, start);
+	PAHO_CHKCRC_SET_LEN(ptx, len);
+	PAHO_CHKCRC_SET_RESULT_OFF(ptx, skb->csum_offset);
+	PAHO_CHKCRC_SET_INITVAL(ptx, 0);
+	PAHO_CHKCRC_SET_NEG0(ptx, 0);
+
+	return size;
+}
+
+static int pa_fmtcmd_next_route(struct netcp_packet *p_info, int eth_port)
+{
+	u8 ps_flags = (eth_port & GENMASK(2, 0))
+				<< PAFRM_ETH_PS_FLAGS_PORT_SHIFT;
+	struct paho_next_route *nr;
+
+	nr = (struct paho_next_route *)netcp_push_psdata(p_info, sizeof(*nr));
+	if (!nr)
+		return -ENOMEM;
+
+	/* Construct word0 */
+	nr->word0 = 0;
+	PAHO_SET_CMDID(nr, PAHO_PAMOD_NROUTE);
+	PAHO_SET_E(nr, 1);
+	PAHO_SET_DEST(nr, PAFRM_DEST_ETH);
+	PAHO_SET_FLOW(nr, 0);
+	PAHO_SET_QUEUE(nr, 0);
+
+	/* Construct sw_info0 and sw_info1 */
+	nr->sw_info0 = 0;
+	nr->sw_info1 = 0;
+
+	/* Construct word1 */
+	nr->word1 = 0;
+	PAHO_SET_PKTTYPE(nr, ps_flags);
+
+	return sizeof(*nr);
+}
+
+static int pa_fmtcmd_align(struct netcp_packet *p_info,
+			   const unsigned bytes)
+{
+	struct paho_cmd_info	*pa_cmd_info;
+	int i;
+
+	if ((bytes & 0x03) != 0)
+		return -EINVAL;
+
+	pa_cmd_info =
+	(struct paho_cmd_info *)netcp_push_psdata(p_info, bytes);
+
+	for (i = bytes / sizeof(u32); i > 0; --i) {
+		pa_cmd_info->word0 = 0;
+		PAHO_SET_CMDID(pa_cmd_info, PAHO_PAMOD_DUMMY);
+		++pa_cmd_info;
+	}
+
+	return bytes;
+}
+
+/*  The NETCP sub-system performs IPv4 header checksum, UDP/TCP checksum and
+ *  SCTP CRC-32c checksum autonomously.
+ *  The checksum and CRC verification results are recorded at the 4-bit error
+ *  flags in the CPPI packet descriptor as described below:
+ *  bit 3: IPv4 header checksum error
+ *  bit 2: UDP/TCP or SCTP CRC-32c checksum error
+ *  bit 1: Custom CRC checksum error
+ *  bit 0: reserved
+ */
+static void pa_rx_checksum_hook(struct netcp_packet *p_info)
+{
+	struct paho_long_info *linfo =
+		(struct paho_long_info *)p_info->psdata;
+
+	if (likely(PAHO_LINFO_READ_L5_OFFSET(linfo))) {
+		/* check for L3 & L4 checksum error */
+		if (likely(!((p_info->eflags >> 2) & GENMASK(1, 0))))
+			p_info->skb->ip_summed = CHECKSUM_UNNECESSARY;
+	}
+}
+
+static u32 pa_get_streaming_switch(struct pa_core_device *core_dev, int port)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	u32 reg;
+
+	reg = readl(pa_dev->streaming_switch);
+	return (port == 0) ? reg : (reg >> ((port - 1) * 8)) & 0xff;
+}
+
+static u32 pa_set_streaming_switch(struct pa_core_device *core_dev,
+				   int port, u32 new_value)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	u32 reg, old_value;
+
+	reg = readl(pa_dev->streaming_switch);
+
+	if (port == 0) {
+		old_value = reg;
+		reg = (new_value << 24) | (new_value << 16) |
+			(new_value << 8) | new_value;
+	} else {
+		int shift = (port - 1) * 8;
+
+		old_value = (reg >> shift) & 0xff;
+		reg &= ~(0xff << shift);
+		reg |= (new_value & 0xff) << shift;
+	}
+	writel(reg, pa_dev->streaming_switch);
+
+	return old_value;
+}
+
+static void pa_unmap_resources(struct pa_core_device *core_dev)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+
+	if (pa_dev->reg_mailbox)
+		iounmap(pa_dev->reg_mailbox);
+	if (pa_dev->reg_packet_id)
+		iounmap(pa_dev->reg_packet_id);
+	if (pa_dev->reg_lut2)
+		iounmap(pa_dev->reg_lut2);
+	if (pa_dev->streaming_switch)
+		iounmap(pa_dev->streaming_switch);
+	if (pa_dev->reg_control)
+		iounmap(pa_dev->reg_control);
+	if (pa_dev->reg_timer)
+		iounmap(pa_dev->reg_timer);
+	if (pa_dev->reg_stats)
+		iounmap(pa_dev->reg_stats);
+	if (pa_dev->pa_iram)
+		iounmap(pa_dev->pa_iram);
+	if (pa_dev->pa_sram)
+		iounmap(pa_dev->pa_sram);
+}
+
+static int pa_map_resources(struct pa_core_device *core_dev,
+			    struct device_node *node)
+{
+	struct pa_device *pa_dev = to_pa(core_dev);
+	struct device *dev = core_dev->dev;
+	int ret = -ENODEV;
+
+	pa_dev->reg_mailbox =
+		core_ops->map_resource(dev, node, PA_MB_REG_INDEX);
+	if (!pa_dev->reg_mailbox)
+		return ret;
+
+	pa_dev->reg_packet_id =
+		core_ops->map_resource(dev, node, PA_PACKET_ID_REG_INDEX);
+	if (!pa_dev->reg_packet_id)
+		goto unmap;
+
+	pa_dev->reg_lut2 = core_ops->map_resource(dev, node, PA_LUT2_REG_INDEX);
+	if (!pa_dev->reg_lut2)
+		goto unmap;
+
+	pa_dev->streaming_switch =
+		core_ops->map_resource(dev, node, PA_SS_INDEX);
+	if (!pa_dev->streaming_switch)
+		goto unmap;
+
+	pa_dev->reg_control =
+		core_ops->map_resource(dev, node, PA_CONTROL_REG_INDEX);
+	if (!pa_dev->reg_control)
+		goto unmap;
+
+	pa_dev->reg_timer =
+		core_ops->map_resource(dev, node, PA_TIMER_REG_INDEX);
+	if (!pa_dev->reg_timer)
+		goto unmap;
+
+	pa_dev->reg_stats =
+		core_ops->map_resource(dev, node, PA_STATS_REG_INDEX);
+	if (!pa_dev->reg_stats)
+		goto unmap;
+
+	pa_dev->pa_iram = core_ops->map_resource(dev, node, PA_IRAM_INDEX);
+	if (!pa_dev->pa_iram)
+		goto unmap;
+
+	pa_dev->pa_sram = core_ops->map_resource(dev, node, PA_SRAM_INDEX);
+	if (!pa_dev->pa_sram)
+		goto unmap;
+
+	return 0;
+
+unmap:	pa_unmap_resources(core_dev);
+	return ret;
+}
+
+static struct pa_hw netcp_pa_hw = {
+	.features = PA_RX_CHECKSUM,
+	.fmtcmd_next_route = pa_fmtcmd_next_route,
+	.fmtcmd_tx_csum = pa_fmtcmd_tx_csum,
+	.fmtcmd_align = pa_fmtcmd_align,
+	.rx_checksum_hook = pa_rx_checksum_hook,
+	.num_clusters = PA_NUM_CLUSTERS,
+	.num_pdsps = PA_NUM_PDSPS,
+	.ingress_l2_cluster_id = PA_CLUSTER_0,
+	.ingress_l3_cluster_id = PA_CLUSTER_1,
+	.egress_cluster_id = PA_CLUSTER_5,
+	.streaming_pdsp = PSTREAM_ROUTE_PDSP0,
+	.map_resources	= pa_map_resources,
+	.unmap_resources = pa_unmap_resources,
+	.pre_init = pa_reset,
+	.post_init = pa_post_init,
+	.set_firmware = pa_set_firmware,
+	.rx_packet_handler = pa_rx_packet_handler,
+	.add_mac_rule = pa_add_mac_rule,
+	.config_exception_route = pa_config_exception_route,
+	.set_streaming_switch = pa_set_streaming_switch,
+	.get_streaming_switch = pa_get_streaming_switch,
+	.add_ip_proto = pa_add_ip_proto,
+};
+
+static int pa_probe(struct netcp_device *netcp_device,
+		    struct device *dev,
+		    struct device_node *node,
+		    void **inst_priv)
+{
+	int ret, size = sizeof(struct pa_device);
+	struct pa_device *pa_dev;
+
+	if (!node) {
+		dev_err(dev, "%s: device tree info unavailable\n",
+			__func__);
+		return -ENODEV;
+	}
+
+	pa_dev = (struct pa_device *)core_ops->init(netcp_device, dev, node,
+						     size, &ret, &netcp_pa_hw,
+						     pa_pdsp_firmwares);
+	if (!pa_dev)
+		return ret;
+	*inst_priv = pa_dev;
+
+	return ret;
+}
+
+static int pa_ioctl(void *intf_priv, struct ifreq *req, int cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct netcp_module pa_module = {
+	.name		= "netcp-pa",
+	.owner		= THIS_MODULE,
+	.probe		= pa_probe,
+	.close		= pa_core_close,
+	.open		= pa_core_open,
+	.remove		= pa_core_remove,
+	.attach		= pa_core_attach,
+	.release	= pa_core_release,
+	.add_addr	= pa_core_add_addr,
+	.del_addr	= pa_core_del_addr,
+	.ioctl		= pa_ioctl,
+};
+
+static int __init netcp_pa_init(void)
+{
+	return netcp_register_module(&pa_module);
+}
+module_init(netcp_pa_init);
+
+static void __exit netcp_pa_exit(void)
+{
+	netcp_unregister_module(&pa_module);
+}
+module_exit(netcp_pa_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Murali Karicheri m-karicheri2@ti.com>");
+MODULE_DESCRIPTION("TI NetCP Packet Accelerator driver for Keystone devices");
diff --git a/drivers/net/ethernet/ti/netcp_pa_fw.h b/drivers/net/ethernet/ti/netcp_pa_fw.h
new file mode 100644
index 0000000..fc9b7c9
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa_fw.h
@@ -0,0 +1,837 @@
+/*
+ * Keystone NetCP PA (Packet Accelerator) firmware interface header file
+ *
+ * Copyright (C) 2012-2015 Texas Instruments Incorporated
+ * Author: Murali Karicheri (ported to 4.1.x)
+ *
+ * Other contributors:	Sandeep Paulraj (Initial version of the driver)
+ *			Reece Pollack (Maintenance)
+ *			Sandeep Nair (Maintenance)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef NETCP_PA_FW_H
+#define NETCP_PA_FW_H
+
+/* Routed Packet Destinations */
+
+/* Packet is discarded */
+#define PA_DEST_DISCARD				3
+/* packet remains in PA sub-system for more parsing and LUT1 classification */
+#define PA_DEST_CONTINUE_PARSE_LUT1		4
+/* packet remains in PA sub-system for more parsing and LUT2 classification */
+#define PA_DEST_CONTINUE_PARSE_LUT2		5
+/* host thread, Packet is routed to host */
+#define PA_DEST_HOST				6
+/* ethernet mac port (of the switch). Packet is routed to  EMAC */
+#define PA_DEST_EMAC				7
+
+#define PA_MAX_MULTI_ROUTE_SETS			32
+
+#define PA_EMAC_CTRL_PORT_MASK			0x0F
+#define PA_EMAC_CTRL_CRC_DISABLE		0x80
+#define PA_CUSTOM_TYPE_LUT1			1
+#define PA_CUSTOM_TYPE_LUT2			2
+#define PA_MAX_CUSTOM_TYPES_LUT1		4
+#define PA_MAX_CUSTOM_TYPES_LUT2		4
+/* Packet is sent to PDSP0 */
+#define PA_CMD_TX_DEST_0			0
+/* Packet is sent to PDSP1 */
+#define PA_CMD_TX_DEST_1			1
+/* Packet is sent to PDSP2 */
+#define PA_CMD_TX_DEST_2			2
+/* Packet is sent to PDSP3 */
+#define PA_CMD_TX_DEST_3			3
+/* Packet is sent to PDSP4 */
+#define PA_CMD_TX_DEST_4			4
+/* Packet is sent to PDSP5 */
+#define PA_CMD_TX_DEST_5			5
+
+/* PA Command Codes */
+#define PA_CMD_NONE				0
+#define PA_CMD_NEXT_ROUTE			1
+#define PA_CMD_CRC_OP				2
+#define PA_CMD_COPY_DATA_TO_PSINFO		3
+#define PA_CMD_PATCH_DATA			4
+#define PA_CMD_TX_CHECKSUM			5
+#define PA_CMD_MULTI_ROUTE			6
+#define PA_CMD_REPORT_TX_TIMESTAMP		7
+#define PA_CMD_REMOVE_HEADER			8
+#define PA_CMD_REMOVE_TAIL			9
+#define PA_CMD_CMDSET				10
+#define PA_CMD_SA_PAYLOAD			11
+#define PA_CMD_IP_FRAGMENT			12
+#define PA_CMD_USR_STATS			13
+#define PA_CMD_CMDSET_AND_USR_STATS		14
+
+/* Interface based routing modes */
+
+/* No interface based routing */
+#define PA_ROUTE_INTF_NONE			0
+/* Route by interface number as dest queue offset */
+#define PA_ROUTE_INTF_QUEUE			1
+/* Route by interface number as both dest queue & CPPI flow offset */
+#define PA_ROUTE_INTF_FLOW			2
+
+struct pa_frm_forward_host {
+	/* Context returned as swInfo0 for matched packet */
+	u32	context;
+	/*  Control bitmap, 1 for enable, 0 for disable
+	 *  /-----------------------------------------------------\
+	 *  | 7           |       2     |      1      |     0     |
+	 *  | Selection   |             |Flow IF Dest |           |
+	 *  | 0: Priority |             |    OR       |           |
+	 *  | 1: IF dest  |DSCP priority|VLAN priority| multiRoute|
+	 *  \-----------------------------------------------------/
+	 */
+	u8	ctrl_bm;
+	/* Index of the multiple destination set */
+	u8	multi_idx;
+	/* PA PDSP number used as multi-route router */
+	u8	pa_pdsp_router;
+	/* use the bits 7:4.
+	 * bit 7: Disable CRC,
+	 * bit 6:4 port number (0/1/2),
+	 * bit 3:0 errflags = 0
+	 * psFlags may be required when the packet is
+	 * forwarded through QoS queue
+	 */
+	u8	ps_flags;
+	/* optional simple command:0 means no command */
+	u8	cmd[4];
+}; /* 12 bytes */
+
+#define PAFRM_MULTIROUTE_ENABLE			0x1
+#define PAFRM_ROUTING_PRIORITY_DSCP_ENABLE	0x2
+#define PAFRM_ROUTING_PRIORITY_VLAN_ENABLE	0x4
+/* 0: queue-based only 1: queue & flow-based */
+#define PAFRM_ROUTING_FLOW_IF_BASE_ENABLE	0x2
+#define PAFRM_ROUTING_IF_DEST_SELECT_ENABLE	0x80
+
+#define PAFRM_ETH_PS_FLAGS_DISABLE_CRC		0x80
+#define PAFRM_ETH_PS_FLAGS_PORT_MASK		0x70
+#define PAFRM_ETH_PS_FLAGS_PORT_SHIFT		4
+
+/* Routing information used to forward packets within PA */
+struct pa_frm_forward_pa {
+	/* PDSP destination */
+	u8	pa_dest;
+	/* None, LUT1, LUT2 */
+	u8	custom_type;
+	/* Index of the custom type if LUT1 or LUT2 custom */
+	u8	custom_idx;
+	u8	rsvd2;
+	u32	rsvd3;
+	u32	rsvd4;
+};
+
+enum {
+	/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_HOST,
+	/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_SA,
+	/* use pa.paDest */
+	PAFRM_FORWARD_TYPE_PA,
+	/* use PAFRM_DEST_ETH */
+	PAFRM_FORWARD_TYPE_ETH,
+	/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_SRIO,
+	PAFRM_FORWARD_TYPE_DISCARD
+};
+
+/* Routing information used to forward packets from PA sub-system to various
+ * destinations
+ */
+struct pa_frm_forward  {
+	/* Forwarding type as defined below */
+	u8 forward_type;
+	/* PKTDMA flow Id, valid if forwarding via PKTDMA */
+	u8 flow_id;
+	/* Destination queue number, valid if forwarding via PKTDMA */
+	u16 queue;
+
+	union {
+		/* Host specific routing information */
+		struct pa_frm_forward_host	host;
+		/* PA internal routing information */
+		struct pa_frm_forward_pa	pa;
+	} u;
+};
+
+/* Custom match flag bits */
+#define PAFRM_LUT1_CUSTOM_MATCH_ETYPE			BIT(2)
+#define PAFRM_LUT1_CUSTOM_MATCH_VLAN			BIT(3)
+/* Ipv6 source and dest entries */
+#define PAFRM_LUT1_CUSTOM_MATCH_MATCH			(3 << 4)
+#define PAFRM_LUT1_CUSTOM_MATCH_KEY			BIT(13)
+#define PAFRM_LUT1_CUSTOM_MATCH_VALID			BIT(15)
+
+/* To add entry to LUT1 */
+#define PAFRM_HW_LUT1_ENTRIES				64
+/* if PA_LUT1_INDEX_LAST_FREE is used then when the command returns,
+ * the value of index will be replaced with the actual index used
+ */
+#define PAFRM_LUT1_INDEX_LAST_FREE	PAFRM_HW_LUT1_ENTRIES
+
+/* Standard match flag bits */
+#define PAFRM_LUT1_MATCH_DMAC				BIT(0)
+#define PAFRM_LUT1_MATCH_SMAC				BIT(1)
+#define PAFRM_LUT1_MATCH_ETYPE				BIT(2)
+#define PAFRM_LUT1_MATCH_VLAN				BIT(3)
+#define PAFRM_LUT1_MATCH_SIP				BIT(4)
+#define PAFRM_LUT1_MATCH_DIP				BIT(5)
+#define PAFRM_LUT1_MATCH_SPI_GRE_SCTP			BIT(6)
+#define PAFRM_LUT1_MATCH_FLOW				BIT(7)
+#define PAFRM_LUT1_MATCH_SPORT				BIT(8)
+#define PAFRM_LUT1_MATCH_DPORT				BIT(9)
+#define PAFRM_LUT1_MATCH_PROTO				BIT(10)
+#define PAFRM_LUT1_MATCH_TOS				BIT(11)
+#define PAFRM_LUT1_MATCH_PORT				BIT(12)
+#define PAFRM_LUT1_MATCH_KEY				BIT(13)
+#define PAFRM_LUT1_MATCH_VALID				BIT(15)
+#define PAFRM_LUT1_MATCH_MPLS		(PAFRM_LUT1_MATCH_SPORT | \
+					PAFRM_LUT1_MATCH_DPORT)
+
+/* Key values. The PDSP will set these bits as it parses the headers.
+ * LUT1_1 and LUT1_2 (L3): The following bit fields are used
+ */
+#define PAFRM_LUT1_KEY_SPI				BIT(0)
+#define PAFRM_LUT1_KEY_GRE				BIT(1)
+#define PAFRM_LUT1_KEY_MPLS				BIT(2)
+#define PAFRM_LUT1_KEY_IPV4				BIT(3)
+#define PAFRM_LUT1_KEY_IPV6				BIT(4)
+#define PAFRM_LUT1_KEY_SCTP				BIT(5)
+
+/* LUT1: Custom  (L3) */
+#define PAFRM_LUT1_KEY_CUSTOM				BIT(7)
+#define PAFRM_LUT1_KEY_MAC				BIT(0)
+
+struct pa_frm_com_l1_standard {
+	/* LUT1 view 1 */
+	/* Destination mac */
+	u8	dmac[6];
+	/* Source mac */
+	u8	smac[6];
+	/* Ethernrt type, Also used for the previous match PDSP number */
+	u16	etype;
+	/* VLAN tag, the field is also used for the previous match LUT1 index */
+	u16	vlan;
+
+	/* LUT1 view 2 */
+	/* Source IP address */
+	u8	src_ip[16];
+	/* Destination IP address */
+	u8	dst_ip[16];
+
+	/* LUT1 view 3 */
+	/* ESP or AH header Security Parameters Index. The field is also used
+	 * for GRE protocol or SCTP destination port
+	 */
+	u32	spi;
+	/* IPv6 flow label in 20 lsbs */
+	u32	flow;
+
+	union {
+		/* UDP/TCP Source port (0), destination port (1) */
+		u16	ports[2];
+		/* mpls label in 20 Lsbs */
+		u32	mpls;
+	} pm;
+	/* Ipv4 Protocol fields, IPv6 next */
+	u8	proto_next;
+	/* Ipv4 TOS, Ipv6 traffic class */
+	u8	tos_tclass;
+	/* reserved field: not used */
+	u8	inport;
+	u8	key;
+	/* IP: Distinguishs spi/gre and mpls and ports
+	 *  LUT1_0: MAC/SRIO,
+	 *  LUT1_1/LUT1_2: custom or standard
+	 */
+	/* end LUT1 view 3 */
+	/* lookup matching valid flags as defined below */
+	u16	match_flags;
+	/* reserved for alignment */
+	u16	rsvd;
+};
+
+struct pa_frm_com_l1_custom {
+	/* LUT1 view 1 */
+	/* unused field: All zero's */
+	u8	dmac[6];
+	/* unused field: All zero's */
+	u8	smac[6];
+	/* upper link (previous match PDSP number) */
+	u16	etype;
+	/* upper link (previous match LUT1 index) */
+	u16	vlan;
+
+	/* LUT1 view 2 */
+	/* 32 bytes to match   */
+	u8	match_values[32];
+
+	/* LUT1 view 3 - offset from start */
+	/* unused field: All zero's */
+	u32	rsvd0;
+	/* unused field: All zero's */
+	u32	rsvd1;
+	/* unused field: All zero's */
+	u32	rsvd2;
+	/* unused field: All zero's */
+	u8	rsvd3;
+	/* unused field: All zero's */
+	u8	rsvd4;
+	/* unused field: All zero's */
+	u8	inport;
+	/* IP: Distinguishs spi/gre and mpls and ports
+	 * LUT1_0: MAC/SRIO,
+	 * LUT1_1/LUT1_2: custom or standard
+	 */
+	u8	key;
+	/* lookup matching valid flags as defined below */
+	u16	match_flags;
+	/* reserved for alignment */
+	u16	rsvd5;
+};
+
+enum {
+	PAFRM_CONFIG_COMMAND_RSVD,
+	PAFRM_CONFIG_COMMAND_ADDREP_LUT1,
+	PAFRM_CONFIG_COMMAND_DEL_LUT1,
+	PAFRM_CONFIG_COMMAND_ADDREP_LUT2,
+	PAFRM_CONFIG_COMMAND_DEL_LUT2,
+	PAFRM_CONFIG_COMMAND_CONFIG_PA,
+	PAFRM_CONFIG_COMMAND_REQ_STATS,
+	PAFRM_CONFIG_COMMAND_REQ_VERSION,
+	PAFRM_CONFIG_COMMAND_MULTI_ROUTE,
+	PAFRM_CONFIG_COMMAND_CRC_ENGINE,
+	PAFRM_CONFIG_COMMAND_CMD_SET,
+	PAFRM_CONFIG_COMMAND_USR_STATS,
+	PAFRM_CONFIG_COMMAND_SYS_CONFIG
+};
+
+/* Command magic value */
+#define PAFRM_CONFIG_COMMAND_SEC_BYTE			0xce
+
+/* Command return values */
+enum {
+	PAFRM_COMMAND_RESULT_SUCCESS,
+	/* Command magic value not found */
+	PAFRM_COMMAND_RESULT_NO_COMMAND_MAGIC,
+	/* Invalid command identifier */
+	PAFRM_COMMAND_RESULT_INVALID_CMD,
+	/* Add entry to LUT1 fails */
+	/* Invalid type, custom or standard IP/ethernet */
+	PAFRM_COMMAND_RESULT_LUT1_TYPE_INVALID,
+	/* Invalid LUT1 index (0-63) or no free indices available */
+	PAFRM_COMMAND_RESULT_LUT1_INDEX_INVALID,
+	/* Sent a match packet to q0 on c1 or c2 - this is illegal. */
+	PAFRM_COMMAND_RESULT_LUT1_MATCH_DEST_INVALID,
+	/* Previous match forward info was somewhere in chunk domain */
+	PAFRM_COMMAND_RESULT_LUT1_NMATCH_INVALID,
+	/* Invalid combination found in the key value */
+	PAFRM_COMMAND_RESULT_LUT1_INVALID_KEYS,
+	/* Lut 2 entry warnings since the lut can be configured without pdsp */
+	PAFRM_COMMAND_RESULT_WARN_OVER_MAX_ENTRIES,
+	PAFRM_COMMAND_RESULT_WARN_NEGATIVE_ENTRY_COUNT,
+	/* Lut 2 entry failures */
+	/* LUT2 had a lookup and pending config */
+	PAFRM_COMMAND_RESULT_LUT2_ADD_BUSY,
+	/* Not enough room in stats request packet for the reply */
+	PAFRM_COMMAND_RESULT_WARN_STATS_REPLY_SIZE,
+	/* Command sent to PDSP which couldn't handle it */
+	PAFRM_COMMAND_RESULT_INVALID_DESTINATION,
+	/* Add/Delete/Read entries to multi route table */
+	/* Asked to use a free entry, but none found */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_NO_FREE_ENTRIES,
+	/* Illegal index value used */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_IDX,
+	/* Illegal multi route mode used */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_MODE,
+
+	/* Packet size didn't match command */
+	PAFRM_COMMAND_RESULT_INVALID_PKT_SIZE,
+
+	/* Coustom and Command set index */
+	/* Illegal Custom LUT1 index value used */
+	PAFRM_COMMAND_RESULT_INVALID_C1_CUSTOM_IDX,
+	/* Illegal Custom LUT2 index value used */
+	PAFRM_COMMAND_RESULT_INVALID_C2_CUSTOM_IDX,
+	/* Illegal Custom Command Set index value used */
+	PAFRM_COMMAND_RESULT_INVALID_CMDSET_IDX
+};
+
+#define PA_SS_TIMER_CNTRL_REG_GO		0x00000001u
+#define PA_SS_TIMER_CNTRL_REG_MODE		0x00000002u
+#define PA_SS_TIMER_CNTRL_REG_PSE		0x00008000u
+#define PA_SS_TIMER_CNTRL_REG_PRESCALE_SHIFT	0x00000002u
+
+/* Destination (route) values */
+#define PAFRM_DEST_PDSP0			0
+#define PAFRM_DEST_PDSP1			1
+#define PAFRM_DEST_PDSP2			2
+#define PAFRM_DEST_PDSP3			3
+#define PAFRM_DEST_PDSP4			4
+#define PAFRM_DEST_PDSP5			5
+#define PAFRM_DEST_PKTDMA			6
+#define PAFRM_DEST_ETH				7
+#define PAFRM_DEST_DISCARD			10
+
+/* Assigning names based on PDSP functions */
+#define PAFRM_DEST_PA_C1_0	PAFRM_DEST_PDSP0
+#define PAFRM_DEST_PA_C1_1	PAFRM_DEST_PDSP1
+#define PAFRM_DEST_PA_C1_2	PAFRM_DEST_PDSP2
+#define PAFRM_DEST_PA_C2	PAFRM_DEST_PDSP3
+#define PAFRM_DEST_PA_M_0	PAFRM_DEST_PDSP4
+#define PAFRM_DEST_PA_M_1	PAFRM_DEST_PDSP5
+
+/* The default queue for packets that arrive at the PA and don't match in
+ * classify1 (right at init time)
+ */
+#define PAFRM_DEFAULT_INIT_Q			0x100
+
+/* Ethertypes recognized by the firmware. */
+#define PAFRM_ETHERTYPE_IP			0x0800
+#define PAFRM_ETHERTYPE_IPV6			0x86dd
+#define PAFRM_ETHERTYPE_VLAN			0x8100
+#define PAFRM_ETHERTYPE_SPVLAN			0x88a8
+#define PAFRM_ETHERTYPE_MPLS			0x8847
+#define PAFRM_ETHERTYPE_MPLS_MULTI		0x8848
+
+/* Next header type values  */
+#define PAFRM_HDR_MAC				0
+#define PAFRM_HDR_VLAN				1
+#define PAFRM_HDR_MPLS				2
+#define PAFRM_HDR_IPV4				3
+#define PAFRM_HDR_IPV6				4
+#define PAFRM_HDR_IPV6_EXT_HOP			5
+#define PAFRM_HDR_IPV6_EXT_ROUTE		6
+#define PAFRM_HDR_IPV6_EXT_FRAG			7
+#define PAFRM_HDR_IPV6_EXT_DEST			8
+#define PAFRM_HDR_GRE				9
+#define PAFRM_HDR_ESP				10
+#define PAFRM_HDR_ESP_DECODED			11
+#define PAFRM_HDR_AUTH				12
+#define PAFRM_HDR_CUSTOM_C1			13
+#define PAFRM_HDR_FORCE_LOOKUP			14
+#define PAFRM_HDR_SCTP				15
+#define PAFRM_HDR_UNKNOWN			16
+#define PAFRM_HDR_UDP				17
+#define PAFRM_HDR_UDP_LITE			18
+#define PAFRM_HDR_TCP				19
+#define PAFRM_HDR_GTPU				20
+#define PAFRM_HDR_ESP_DECODED_C2		21
+#define PAFRM_HDR_CUSTOM_C2			22
+
+/* Command related definitions */
+#define PAFRM_CRC_FLAG_CRC_OFFSET_VALID		0x01
+#define PAFRM_CRC_FLAG_CRC_OFFSET_FROM_DESC	0x02
+#define PAFRM_CHKSUM_FALG_NEGATIVE		0x01
+
+#define PA_NEXT_ROUTE_PARAM_PRESENT		0x0001
+#define PA_NEXT_ROUTE_PROC_NEXT_CMD		0x0002
+#define PA_NEXT_ROUTE_PROC_MULTI_ROUTE		0x0004
+
+/* PAFRM receive commands related definitions */
+
+/* There are the following two groups of PAFRM receive commands:
+ * PAFRM short commands which can be used as part of the routing info
+ * PAFRM commands which can be used within a command set
+ */
+
+/* Dummy command */
+#define PAFRM_RX_CMD_NONE			0
+
+/* short commands */
+/* Execute a command set */
+#define PAFRM_RX_CMD_CMDSET			1
+/* Insert up to two types at the current location */
+#define PAFRM_RX_CMD_INSERT			2
+
+/* command set commands */
+/* Specify the next route */
+#define PAFRM_RX_CMD_NEXT_ROUTE			3
+/* CRC generation or verification */
+#define PAFRM_RX_CMD_CRC_OP			4
+/* Copy data to the PS Info section */
+#define PAFRM_RX_CMD_COPY_DATA			5
+/* Insert or pacth packet data at the specific location */
+#define PAFRM_RX_CMD_PATCH_DATA			6
+/* Remove the parsed packet header */
+#define PAFRM_RX_CMD_REMOVE_HDR			7
+/* Remove the parsed packet tail */
+#define PAFRM_RX_CMD_REMOVE_TAIL		8
+/* Duplicate packet to multiple destinations */
+#define PAFRM_RX_CMD_MULTI_ROUTE		9
+
+/* PASS command ID formatting
+ * Bit 15 is used to distinguish the L2 table from
+ * the L3 table in the command comId field
+ */
+#define PA_COMID_L2				0
+#define PA_COMID_L3				BIT(15)
+#define PA_COMID_L_MASK				BIT(15)
+#define PA_COMID_IDX_MASK			(~(PA_COMID_L_MASK))
+
+/* define LUT1 entry types */
+/* MAC/IP */
+#define PAFRM_COM_ADD_LUT1_STANDARD		0
+/* Custom LUT1 */
+#define PAFRM_COM_ADD_LUT1_CUSTOM		2
+
+struct pa_frm_cmd_add_lut1 {
+	/* LUT1 index. */
+	u8	index;
+	/* Custom or standard */
+	u8	type;
+	/* reserved for alignment */
+	u8	rsvd;
+	/* Valid only if type is custom */
+	u8	cust_index;
+
+	union {
+		/* matching information for MAC/IP entry */
+		struct	pa_frm_com_l1_standard	eth_ip;
+		struct	pa_frm_com_l1_custom	custom;
+	} u;
+
+	/* Routing information when a match is found */
+	struct	pa_frm_forward match;
+
+	/* Routing information when subsequent match fails - a fragmented
+	 * packet orinner route
+	 */
+	struct	pa_frm_forward next_fail;
+};
+
+/* CRC Engine Configuration */
+#define PARAM_CRC_TABLE_SIZE			16
+
+struct pa_frm_config_crc {
+	/* Control bit maps as defined below */
+	u8	ctrl_bitmap;
+#define PARAM_CRC_SIZE_8			0
+#define PARAM_CRC_SIZE_16			1
+#define PARAM_CRC_SIZE_24			2
+#define PARAM_CRC_SIZE_32			3
+#define PARAM_CRC_CTRL_CRC_SIZE_MASK		0x3
+#define PARAM_CRC_CTRL_LEFT_SHIFT		0x0
+#define PARAM_CRC_CTRL_RIGHT_SHIFT		0x4
+#define PARAM_CRC_CTRL_INV_RESULT		0x8
+	/* reserved for alignment */
+	u8	rsvd1;
+	/* reserved for alignment */
+	u16	rsvd2;
+	/* Initial value to use in the CRC calcualtion */
+	u32	init_val;
+	/* CRC table */
+	u32	crc_tbl[PARAM_CRC_TABLE_SIZE];
+};
+
+/* Commands to PA */
+struct pa_frm_command {
+	/* Returned to the host, ignored on entry to the PASS */
+	u32	command_result;
+	/* Command value */
+	u8	command;
+	/* Magic value */
+	u8	magic;
+	/* Used by the host to identify command results */
+	u16	com_id;
+	/* Returned in swInfo to identify packet as a command */
+	u32	ret_context;
+	/* Specifies the queue number for the message reply. 0xffff to toss the
+	 * reply
+	 */
+	u16	reply_queue;
+	/* Reply destination:- host0, host1, discard are only valid values */
+	u8	reply_dest;
+	/* Flow ID used to assign packet at reply */
+	u8	flow_id;
+	/* First word of the command */
+	u32	cmd;
+};
+
+struct pa_cmd_next_route {
+	/* Routing control information as defined at @ref routeCtrlInfo */
+	u16	ctrl_bit_field;
+	/* Packet destination as defined at @ref pktDest */
+	int	dest;
+	/* For destination EMAC, specify the EMAC control to the network */
+	u8	pkt_type_emac_ctrl;
+	/* For host, SA or SRIO destinations, specifies return free
+	 * descriptor setup
+	 */
+	u8	flow_id;
+	/*For host, SA or SRIO destinations, specifies the dest queue */
+	u16	queue;
+	/* Placed in SwInfo0 for packets to host or SA */
+	u32	sw_info_0;
+	/* Placed in SwInfo1 for packets to the SA */
+	u32	sw_info_1;
+	/* Multi-route index. It is valid in the from-network direction only */
+	u16	multi_route_index;
+};
+
+struct pa_cmd_crc_op {
+	/* CRC operation control information */
+	u16	ctrl_bit_field;
+	/* Byte location, from SOP/Protocol Header, where the CRC
+	 * computation begins if frame type is not specified Byte location,
+	 * from SOP/Protocol header, where the specific frame header begins
+	 * if frame type is specified In to-network direction: offset from SOP
+	 * In from-network direction: offset from the current parsed header
+	 */
+	u16	start_offset;
+	/* Number of bytes covered by the CRC computation
+	 * valid only if pa_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is clear
+	 */
+	u16	len;
+	/* Payload length field offset in the custom header */
+	u16	len_offset;
+	/* Payload length field mask */
+	u16	len_mask;
+	/* Payload length adjustment: valid only if
+	 * PA_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is set
+	 */
+	u16	len_adjust;
+	/* Offset from SOP/Protocol Header to the CRC field In to-network
+	 * direction: offset from SOP In from-network direction: offset
+	 * from the current parsed header
+	 */
+	u16	crc_offset;
+	/* Frame type valid if PA_CRC_OP_CRC_FRAME_TYPE is set */
+	u16	frame_yype;
+};
+
+struct pa_tx_chksum {
+	/* Byte location, from SOP, where the checksum calculation begins */
+	u16	start_offset;
+	/* Number of bytes covered by the checksum. Must be even */
+	u16	length_bytes;
+	/* Byte offset, from startOffset, to place the resulting checksum */
+	u16	result_offset;
+	/* Initial value of the checksum */
+	u16	initial_sum;
+	/* If TRUE, a computed value of 0 is written as -0 */
+	u16	negative_0;
+};
+
+struct pa_cmd_copy {
+	u16	ctrl_bitfield;
+	u16	src_offset;
+	u16	dest_offset;
+	u16	num_bytes;
+};
+
+struct pa_patch_info {
+	unsigned int	n_patch_bytes;
+	unsigned int	total_patch_size;
+	unsigned int	offset;
+	u16		overwrite;
+	u8		*patch_data;
+};
+
+struct pa_payload_info  {
+	u16	offset;
+	u16	len;
+};
+
+struct pa_cmd_multi_route {
+	u16	index;
+};
+
+#define PA_MAX_CMD_SETS				8
+#define PA_OK					0
+#define PA_ERR_CONFIG				-10
+#define PA_INSUFFICIENT_CMD_BUFFER_SIZE		-11
+#define PA_INVALID_CMD_REPLY_DEST		-12
+
+struct pa_cmd_set {
+	u16	index;
+	/* Command Set Index */
+};
+
+struct pa_cmd_tx_timestamp {
+	/* Host queue for the tx timestamp reporting packet */
+	u16	dest_queue;
+	/* CPPI flow */
+	u16	flow_id;
+	/* 32 bit value returned in the descriptor */
+	u32	sw_info0;
+};
+
+struct pa_cmd_ip_frag {
+	/* Offset to the IP header. */
+	u16	ip_offset;
+	/* Size of the maximum transmission unit (>= 68) */
+	u16	mtu_size;
+};
+
+struct pa_cmd_usr_stats {
+	/* User-defined statistics index */
+	u16	index;
+};
+
+struct pa_cmd_set_usr_stats {
+	/* Commad Set Index */
+	u16	set_index;
+	/* User-defined statistics index */
+	u16	stats_index;
+};
+
+struct pa_cmd_info {
+	/* Specify the PA command code */
+	u16	cmd;
+	union {
+		/* Specify nextRoute command specific parameters */
+		struct pa_cmd_next_route route;
+		/* Specify Tx Checksum command specific parameters */
+		struct pa_tx_chksum	chksum;
+		/* Specify CRC operation command specific parameters */
+		struct pa_cmd_crc_op     crc_op;
+		/* Specify Copy command specific parameters */
+		struct pa_cmd_copy	copy;
+		/* Specify Patch command specific parameters */
+		struct pa_patch_info	patch;
+		/* Specify the payload information required by SA */
+		struct pa_payload_info	payload;
+		/* Specify Command Set command specific parameters */
+		struct pa_cmd_set	cmd_set;
+		/* Specify Multi-route command specific parameters */
+		struct pa_cmd_multi_route m_route;
+		/*Specify Report Tx Timestamp command specific parameters */
+		struct pa_cmd_tx_timestamp tx_ts;
+		/* Specify IP fragmentation command specific parameters */
+		struct pa_cmd_ip_frag	ip_frag;
+		/* Specify User-defined Stats command specific parameters */
+		struct pa_cmd_usr_stats usr_stats;
+		struct pa_cmd_set_usr_stats cmd_set_usr_stats;
+	} params;
+};
+
+struct pa_route_info {
+	int	dest;
+	u8	flow_id;
+	u16	queue;
+	int	m_route_index;
+	u32	sw_info_0;
+	u32	sw_info_1;
+	int	custom_type;
+	u8	custom_index;
+	u8	pkt_type_emac_ctrl;
+	u8	route_type;
+	struct pa_cmd_info *pcmd;
+};
+
+/* Exception routing enumeration */
+enum pa_eroutes {
+	/* packet failed to match in LUT1 table */
+	EROUTE_LUT1_FAIL = 0,
+	/* packet exceeded maximum number of VLAN tags */
+	EROUTE_VLAN_MAX_DEPTH,
+	/* packet exceeded maximum number of IP headers */
+	EROUTE_IP_MAX_DEPTH,
+	/* packet exceeded maximum number of MPLS headers */
+	EROUTE_MPLS_MAX_DEPTH,
+	/* packet exceeded maximum number of GRE headers */
+	EROUTE_GRE_MAX_DEPTH,
+	/* packet failed to parse */
+	EROUTE_PARSE_FAIL,
+	/* packet failed to match in LUT2 table */
+	EROUTE_LUT2_FAIL,
+	/* IP fragmented packet found in classify2 lookup */
+	EROUTE_IP_FRAG,
+	/* Packet failed due to unsupported IPV6 option header */
+	EROUTE_IPV6_OPT_FAIL,
+	/* Udp lite checksum coverage invalid */
+	EROUTE_UDP_LITE_FAIL,
+	/* IPv4 strict source route or IPv6 routing extension header */
+	EROUTE_ROUTE_OPTION,
+	/* Unknown system failure - should never happen */
+	EROUTE_SYSTEM_FAIL,
+	/* MAC broadcast packet */
+	EROUTE_MAC_BROADCAST,
+	/* MAC multicast packet */
+	EROUTE_MAC_MULTICAST,
+	/* IP broadcast packet */
+	EROUTE_IP_BROADCAST,
+	/* IP multicast packet */
+	EROUTE_IP_MULTICAST,
+	/* GTP-U PING Request packet */
+	EROUTE_GTPU_MESSAGE_TYPE_1,
+	/* GTP-U PING Response packet */
+	EROUTE_GTPU_MESSAGE_TYPE_2,
+	/* GTP-U Error Indication packet */
+	EROUTE_GTPU_MESSAGE_TYPE_26,
+	/* GTP-U Supported Header Notification packet */
+	EROUTE_GTPU_MESSAGE_TYPE_31,
+	/* GTP-U End Markr packet */
+	EROUTE_GTPU_MESSAGE_TYPE_254,
+	/*failed due to GTPU parsing error or unsupported dmessage types */
+	EROUTE_GTPU_FAIL,
+	/* Packet failed due to PPPoE session packet parsing error */
+	EROUTE_PPPOE_FAIL,
+	/* PPPoE session stage non-IP packets */
+	EROUTE_PPPOE_CTRL,
+	/* 802.1ag Packet*/
+	EROUTE_802_1ag,
+	/* Packet failed due to invalid IP header */
+	EROUTE_IP_FAIL,
+	/* NAT-T Keep Alive packet where UDP Length = 9, data = 0xFF */
+	EROUTE_NAT_T_KEEPALIVE,
+	/* NAT-T control packet where UDP Length > 12 and the first 4 payload
+	 * bytes are equal to 0
+	 */
+	EROUTE_NAT_T_CTRL,
+	/* NAT-T IPSEC ESP data packet where UDP Length > 12 and the first 4
+	 * payload bytes are not equal to 0
+	 */
+	EROUTE_NAT_T_DATA,
+	/* Invalid NAT-T packet */
+	EROUTE_NAT_T_FAIL,
+	/* Packet failed to match GTPU */
+	EROUTE_GTPU_MATCH_FAIL,
+	/* Number of error routes */
+	EROUTE_N_MAX
+};
+
+/* exception route configuration */
+struct pa_frm_com_eroute {
+	/* Exception route valid bitmap */
+	u32			route_bitmap;
+	/* Array of exception routing information */
+	struct pa_frm_forward	eroute[EROUTE_N_MAX];
+};
+
+/* PA system configuration command */
+struct pa_frm_command_sys_config_pa {
+	/* system configuration code as defined below */
+	u8	cfg_code;
+	u8	rsvd1;
+	/* reserved for alignment */
+	u16	rsvd2;
+
+	union {
+		/* Exception routes configuration */
+		struct pa_frm_com_eroute eroute;
+	} u;
+};
+
+/* PA system configuration codes */
+#define PAFRM_SYSTEM_CONFIG_CODE_EROUTE         0
+#define PAFRM_SYSTEM_CONFIG_CODE_CUSTOM_LUT1    1
+#define PAFRM_SYSTEM_CONFIG_CODE_CUSTOM_LUT2    2
+#define PAFRM_SYSTEM_CONFIG_CODE_802_1AG        3
+#define PAFRM_SYSTEM_CONFIG_CODE_IPSEC_NAT_T    4
+#define PAFRM_SYSTEM_CONFIG_CODE_GTPU           5
+
+#endif /* NETCP_PA_FW_H */
diff --git a/drivers/net/ethernet/ti/netcp_pa_host.h b/drivers/net/ethernet/ti/netcp_pa_host.h
new file mode 100644
index 0000000..0216a38
--- /dev/null
+++ b/drivers/net/ethernet/ti/netcp_pa_host.h
@@ -0,0 +1,138 @@
+/*
+ * Keystone NetCP PA (Packet Accelerator)/ Security Accelerator PDSP
+ * Host packet handler/formatter definitions
+ *
+ * Copyright (C) 2012-2015 Texas Instruments Incorporated
+ * Authors:	Murali Karicheri (Ported to v4.1.x kernel)
+ *		Sandeep Paulraj (Initial version of the driver)
+ *
+ * Other contributors:	Reece Pollack (Maintenance)
+ *			Sandeep Nair (Maintenance)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef NETCP_PA_HOST_H
+#define NETCP_PA_HOST_H
+
+#define PAHO_PAMOD_CMPT_CHKSUM	0
+#define PAHO_PAMOD_CMPT_CRC		1
+#define PAHO_PAMOD_NROUTE		3
+#define PAHO_PAMOD_REPORT_TIMESTAMP	6
+#define PAHO_PAMOD_GROUP_7		7
+#define PAHO_PAMOD_DUMMY		PAHO_PAMOD_GROUP_7
+#define PAHO_SA_SHORT_INFO		1
+
+#define PAHO_READ_BITFIELD(a, b, c)	(((a) >> (b)) & ((1UL << (c)) - 1))
+
+#define PAHO_SET_BITFIELD(a, x, b, c)	((a) &= ~(((1UL << (c)) - 1) << (b)), \
+				(a) |= (((x) & ((1UL << (c)) - 1)) << (b)))
+
+#define PAHO_SET_CMDID(x, v) \
+		PAHO_SET_BITFIELD((x)->word0, (v), 29, 3)
+
+/**
+ *  @ingroup paho_if_structures
+ *  @brief  pahoCmdInfo_t defines the general short command information
+ *
+ */
+struct paho_cmd_info {
+	/* Control block word 0 */
+	u32	word0;
+};
+
+struct paho_long_info {
+	/* Control block word 0 */
+	u32   word0;
+	/* Control block word 1 */
+	u32   word1;
+	/* Control block word 2 */
+	u32   word2;
+	/* Control block word 3 */
+	u32   word3;
+	/* Control block word 4 */
+	u32   word4;
+};
+
+/* Extract the offset to the level 5 header */
+#define PAHO_LINFO_READ_L5_OFFSET(x) \
+		PAHO_READ_BITFIELD((x)->word2, 8, 8)
+
+struct paho_next_route {
+	u32  word0;
+	u32  sw_info0;
+	u32  sw_info1;
+	u32  word1;
+};
+
+/* Sets the E bit which indicates the extended
+ * parameters (packet type) are present for SRIO
+ */
+#define PAHO_SET_E(x, v)	PAHO_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/* Sets the destination of the route defined */
+#define PAHO_SET_DEST(x, v)	PAHO_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PAHO_SET_FLOW(x, v)	PAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PAHO_SET_QUEUE(x, v)   PAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PAHO_SET_PKTTYPE(x, v) PAHO_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct paho_com_chk_crc {
+	/* PAHO_chksum_command_macros */
+	u32	word0;
+	/* PAHO_chksum_command_macros */
+	u32	word1;
+	/* PAHO_chksum_command_macros */
+	u32	word2;
+};
+
+/* Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PAHO_CHKCRC_SET_NEG0(x, v) \
+				PAHO_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PAHO_CHKCRC_SET_CTRL(x, v) \
+				PAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Sets the start offset of the checksum/crc */
+#define PAHO_CHKCRC_SET_START(x, v) \
+				PAHO_SET_BITFIELD((x)->word0, (v), 0, 16)
+
+/* Sets the length of the checksum/crc */
+#define PAHO_CHKCRC_SET_LEN(x, v) \
+				PAHO_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PAHO_CHKCRC_SET_RESULT_OFF(x, v) \
+				PAHO_SET_BITFIELD((x)->word1, (v), 0, 16)
+
+/* Sets the initial value of the checksum/crc */
+#define PAHO_CHKCRC_SET_INITVAL(x, v) \
+				PAHO_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+struct paho_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+#define PAHO_SET_REPORT_FLOW(x, v) PAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PAHO_SET_REPORT_QUEUE(x, v)	\
+				PAHO_SET_BITFIELD((x)->word0, (v), 0, 16)
+#endif /* NETCP_PAHOST_H */
-- 
1.7.5.4

