From 973750df22fe90070f3a8fc195d1a5a762ad9914 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 6 Feb 2013 16:03:17 -0500
Subject: [PATCH 207/256] remoteproc: avoid lock up when rproc_boot is called
 recursively

In the case of uproc control of remote core start up, the rproc_boot
is getting called twice recursively causing a deadlock. This patch
add a state of RPROC_LOADED to differentiate uproc use case to handle
the above gracefully.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Sam Nelson <sam.nelson@ti.com>
(cherry picked from commit fa2a7a019a6c4653acb6d258a36ae8de148c19dd)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/remoteproc/remoteproc_core.c |   26 ++++++++++++++++----------
 include/linux/remoteproc.h           |    7 ++++---
 2 files changed, 20 insertions(+), 13 deletions(-)

diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index b6fae8c..ab32590 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -839,15 +839,6 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 		goto clean_up;
 	}
 
-	if (!fw) {
-		/* handle vdev resources */
-		ret = rproc_handle_virtio_rsc(rproc, table, tablesz);
-		if (ret) {
-			dev_err(dev, "Failed to process resources: %d\n", ret);
-			goto clean_up;
-		}
-	}
-
 	/* handle fw resources which are required to boot rproc */
 	ret = rproc_handle_resources(rproc, tablesz, rproc_loading_handlers);
 	if (ret) {
@@ -883,6 +874,17 @@ static int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)
 		dev_err(dev, "can't start rproc %s: %d\n", rproc->name, ret);
 		goto clean_up;
 	}
+	/* Set state to indicate RPROC is loaded */
+	rproc->state = RPROC_LOADED;
+
+	if (!fw) {
+		/* handle vdev resources */
+		ret = rproc_handle_virtio_rsc(rproc, table, tablesz);
+		if (ret) {
+			dev_err(dev, "Failed to process resources: %d\n", ret);
+			goto clean_up;
+		}
+	}
 
 	/*
 	 * Update table_ptr so that all subsequent vring allocations and
@@ -1069,7 +1071,11 @@ int rproc_boot(struct rproc *rproc)
 		pr_err("invalid rproc handle\n");
 		return -EINVAL;
 	}
-
+	/* Return out if loaded or running */
+	if((rproc->state == RPROC_LOADED) || (rproc->state == RPROC_RUNNING)) {
+		/* rproc is already loaded return */
+		return 0;
+	}
 	dev = &rproc->dev;
 
 	ret = mutex_lock_interruptible(&rproc->lock);
diff --git a/include/linux/remoteproc.h b/include/linux/remoteproc.h
index c060c34..9f07b1e 100644
--- a/include/linux/remoteproc.h
+++ b/include/linux/remoteproc.h
@@ -359,9 +359,10 @@ struct rproc_ops {
 enum rproc_state {
 	RPROC_OFFLINE	= 0,
 	RPROC_SUSPENDED	= 1,
-	RPROC_RUNNING	= 2,
-	RPROC_CRASHED	= 3,
-	RPROC_LAST	= 4,
+	RPROC_LOADED    = 2,
+	RPROC_RUNNING	= 3,
+	RPROC_CRASHED	= 4,
+	RPROC_LAST	= 5,
 };
 
 /**
-- 
1.7.5.4

