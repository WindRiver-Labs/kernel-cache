From b04e3788298132e17edc1247ee8d1ae51167b8ce Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 18 Dec 2013 16:31:02 -0500
Subject: [PATCH 032/256] pci: keystone: update to fix up irq for AER

keystone PCIE Sub system uses platform IRQ for AER. This requires
an irq fix up to update root port dev for AER error irq #12. Also
register a shared irq handler to ack the interrupt.

When Error gets enabled in the EP device (SERR_EN in STATUS_COMMAND
register and and AER fatal, non fatal, correctable and unsupported
request errors in DEV_STAT_CTRL), EP sends an error message to RC
RC port. AER error handler is attached to the error irq line.
Upon receiving the error, and if the error mask is cleared for the
error, RC port trigger an IRQ event to CPU. AER driver has a work
thread that handles the error and initiate reporting and recovery.
See Documentation/PCI/pcieaer-howto.txt for more details on AER
driver.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>

Conflicts:

	drivers/pci/host/pcie-keystone.c
(cherry picked from commit 4b432df62401488ad9014fde6fbfb890a48d413f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/pci/host/pcie-keystone.c |   34 ++++++++++++++++++++++++++++------
 1 files changed, 28 insertions(+), 6 deletions(-)

diff --git a/drivers/pci/host/pcie-keystone.c b/drivers/pci/host/pcie-keystone.c
index 7de1f26..dfb57eb 100644
--- a/drivers/pci/host/pcie-keystone.c
+++ b/drivers/pci/host/pcie-keystone.c
@@ -109,8 +109,14 @@
 #define MAX_MSI_IRQS			32
 #define MAX_MSI_HOST_IRQS		8
 
-/* error IRQ bits */
-#define ENABLE_ERR_FATAL_IRQ		BIT(1)
+/* error IRQ bits. Enable following error IRQs
+ *  - ERR_AER  - ECRC error - BIT(5)
+ *  - ERR_AXI  - AXI tag lookup fatal error BIT(4)
+ *  - ERR_CORR - Correctable error BIT(3)
+ *  - ERR_NONFATAL - Non fatal error BIT(2)
+ *  - ERR_FATAL - Fatal error BIT(1)
+ */
+#define ERR_IRQ_ALL		(BIT(1) | BIT(2) | BIT(3) | BIT(4) | BIT(5))
 #define ERR_FATAL_IRQ			BIT(1)
 
 static struct keystone_pcie_pdata keystone2_data = {
@@ -915,11 +921,14 @@ static irqreturn_t pcie_err_irq_handler(int irq, void *reg_virt)
 {
 	int ret = IRQ_NONE, status;
 
-	status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW) & ERR_FATAL_IRQ;
+	status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW) & ERR_IRQ_ALL;
 	if (status) {
 		/* The PCIESS interrupt status buts are "write 1 to clear" */
+		if (status & ERR_FATAL_IRQ)
+			pr_err(DRIVER_NAME ": PCIE fatal error detected\n");
+
+		/* AER driver will handle the error. Just ack the irq event */
 		__raw_writel(status, reg_virt + ERR_IRQ_STATUS);
-		pr_err(DRIVER_NAME ": PCIE Fatal error detected\n");
 		ret = IRQ_HANDLED;
 	}
 	return ret;
@@ -1065,13 +1074,13 @@ static __init int keystone_pcie_setup(int nr, struct pci_sys_data *sys)
 	hook_fault_code(17, keystone_pcie_fault, SIGBUS, 0,
 			"external abort on linefetch");
 
-	if (request_irq(info->error_irq, pcie_err_irq_handler, 0,
+	if (request_irq(info->error_irq, pcie_err_irq_handler, IRQF_SHARED,
 			"pcie-error-irq", reg_virt) < 0) {
 		pr_err(DRIVER_NAME ": Failed to request error irq\n");
 		goto free_resource_0;
 	}
 	/* enable the fatal error irq */
-	__raw_writel(ENABLE_ERR_FATAL_IRQ, reg_virt + ERR_IRQ_ENABLE_SET);
+	__raw_writel(ERR_IRQ_ALL, reg_virt + ERR_IRQ_ENABLE_SET);
 
 	pr_info(DRIVER_NAME ": Doing PCI Setup...Done\n");
 	return 1;
@@ -1381,6 +1390,19 @@ static __init int keystone_pcie_map_irq(const struct pci_dev *dev, u8 slot,
 		info->virqs[pin - 1] : -1;
 }
 
+#define PCIE_VENDOR_TI	0x104c
+static void aer_use_platirq(struct pci_dev *dev)
+{
+	struct keystone_pcie_info *info = pbus_to_kspci(dev->bus);
+
+	/* use platform IRQ for AER */
+	if (PCI_FUNC(dev->devfn == 0) && PCI_SLOT(dev->devfn) == 0) {
+		if (info)
+			dev->irq = info->error_irq;
+	}
+}
+DECLARE_PCI_FIXUP_FINAL(PCIE_VENDOR_TI, PCI_ANY_ID, aer_use_platirq);
+
 static struct hw_pci __initdata keystone_pcie_hw = {
 	.nr_controllers	= 1,
 	.setup		= keystone_pcie_setup,
-- 
1.7.5.4

