From c022efa29c445a3eb6df81a6f5e97d09c2cf239b Mon Sep 17 00:00:00 2001
From: Jens Wiklander <jens.wiklander@linaro.org>
Date: Tue, 23 Aug 2016 10:23:07 +0200
Subject: [PATCH 335/347] tee: apply v11 delta

This patch comes from:
  git://git.ti.com/processor-sdk/processor-sdk-linux.git

Applies the v11 of the generic TEE subsystem patch set.

Signed-off-by: Jens Wiklander <jens.wiklander@linaro.org>
(cherry picked from commit 37c074daddb08b2336d6071440995fa3f0bf491f)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/tee/Kconfig               |    3 +-
 drivers/tee/Makefile              |    7 +-
 drivers/tee/optee/Kconfig         |    1 -
 drivers/tee/optee/call.c          |    2 +-
 drivers/tee/optee/core.c          |   34 +-
 drivers/tee/optee/optee_private.h |   10 +-
 drivers/tee/optee/rpc.c           |   11 +-
 drivers/tee/optee/supp.c          |   48 ++-
 drivers/tee/tee.c                 |  877 ------------------------------------
 drivers/tee/tee_core.c            |  901 +++++++++++++++++++++++++++++++++++++
 drivers/tee/tee_private.h         |    4 +
 drivers/tee/tee_shm.c             |   22 +-
 drivers/tee/tee_shm_pool.c        |    9 +-
 include/linux/tee_drv.h           |   33 +-
 include/uapi/linux/tee.h          |    3 +-
 15 files changed, 1031 insertions(+), 934 deletions(-)
 delete mode 100644 drivers/tee/tee.c
 create mode 100644 drivers/tee/tee_core.c

diff --git a/drivers/tee/Kconfig b/drivers/tee/Kconfig
index 7228045..2330a4e 100644
--- a/drivers/tee/Kconfig
+++ b/drivers/tee/Kconfig
@@ -1,7 +1,6 @@
 # Generic Trusted Execution Environment Configuration
 config TEE
-	bool "Trusted Execution Environment support"
-	default n
+	tristate "Trusted Execution Environment support"
 	select DMA_SHARED_BUFFER
 	select GENERIC_ALLOCATOR
 	help
diff --git a/drivers/tee/Makefile b/drivers/tee/Makefile
index 53f3c76..7a4e4a1 100644
--- a/drivers/tee/Makefile
+++ b/drivers/tee/Makefile
@@ -1,4 +1,5 @@
-obj-y += tee.o
-obj-y += tee_shm.o
-obj-y += tee_shm_pool.o
+obj-$(CONFIG_TEE) += tee.o
+tee-objs += tee_core.o
+tee-objs += tee_shm.o
+tee-objs += tee_shm_pool.o
 obj-$(CONFIG_OPTEE) += optee/
diff --git a/drivers/tee/optee/Kconfig b/drivers/tee/optee/Kconfig
index a7a8b71..0126de8 100644
--- a/drivers/tee/optee/Kconfig
+++ b/drivers/tee/optee/Kconfig
@@ -1,7 +1,6 @@
 # OP-TEE Trusted Execution Environment Configuration
 config OPTEE
 	tristate "OP-TEE"
-	default n
 	depends on HAVE_ARM_SMCCC
 	help
 	  This implements the OP-TEE Trusted Execution Environment (TEE)
diff --git a/drivers/tee/optee/call.c b/drivers/tee/optee/call.c
index 8f9b12e..040c2a7 100644
--- a/drivers/tee/optee/call.c
+++ b/drivers/tee/optee/call.c
@@ -165,7 +165,7 @@ static struct tee_shm *get_msg_arg(struct tee_context *ctx, size_t num_params,
 	struct tee_shm *shm;
 	struct optee_msg_arg *ma;
 
-	shm = tee_shm_alloc(ctx->teedev, OPTEE_MSG_GET_ARG_SIZE(num_params),
+	shm = tee_shm_alloc(ctx, OPTEE_MSG_GET_ARG_SIZE(num_params),
 			    TEE_SHM_MAPPED);
 	if (IS_ERR(shm))
 		return shm;
diff --git a/drivers/tee/optee/core.c b/drivers/tee/optee/core.c
index dba3bfa..b61eb1d 100644
--- a/drivers/tee/optee/core.c
+++ b/drivers/tee/optee/core.c
@@ -181,9 +181,15 @@ static int optee_open(struct tee_context *ctx)
 		return -ENOMEM;
 
 	if (teedev == optee->supp_teedev) {
-		if (!atomic_dec_and_test(&optee->supp.available)) {
-			/* Supplicant device is already open */
-			atomic_inc(&optee->supp.available);
+		bool busy = true;
+
+		mutex_lock(&optee->supp.ctx_mutex);
+		if (!optee->supp.ctx) {
+			busy = false;
+			optee->supp.ctx = ctx;
+		}
+		mutex_unlock(&optee->supp.ctx_mutex);
+		if (busy) {
 			kfree(ctxdata);
 			return -EBUSY;
 		}
@@ -208,8 +214,7 @@ static void optee_release(struct tee_context *ctx)
 	if (!ctxdata)
 		return;
 
-	shm = tee_shm_alloc(ctx->teedev, sizeof(struct optee_msg_arg),
-			    TEE_SHM_MAPPED);
+	shm = tee_shm_alloc(ctx, sizeof(struct optee_msg_arg), TEE_SHM_MAPPED);
 	if (!IS_ERR(shm)) {
 		arg = tee_shm_get_va(shm, 0);
 		/*
@@ -246,8 +251,11 @@ static void optee_release(struct tee_context *ctx)
 
 	ctx->data = NULL;
 
-	if (teedev == optee->supp_teedev)
-		atomic_inc(&optee->supp.available);
+	if (teedev == optee->supp_teedev) {
+		mutex_lock(&optee->supp.ctx_mutex);
+		optee->supp.ctx = NULL;
+		mutex_unlock(&optee->supp.ctx_mutex);
+	}
 }
 
 static struct tee_driver_ops optee_ops = {
@@ -329,9 +337,9 @@ static bool optee_msg_exchange_capabilities(optee_invoke_fn *invoke_fn,
 	return true;
 }
 
-static struct tee_shm_pool *optee_config_shm_ioremap(struct device *dev,
-			optee_invoke_fn *invoke_fn,
-			void __iomem **ioremaped_shm)
+static struct tee_shm_pool *
+optee_config_shm_ioremap(struct device *dev, optee_invoke_fn *invoke_fn,
+			 void __iomem **ioremaped_shm)
 {
 	struct arm_smccc_res res;
 	struct tee_shm_pool *pool;
@@ -485,8 +493,10 @@ static int optee_probe(struct platform_device *pdev)
 	dev_info(&pdev->dev, "initialized driver\n");
 	return 0;
 err:
-	tee_device_unregister(optee->teedev);
-	tee_device_unregister(optee->supp_teedev);
+	if (optee) {
+		tee_device_unregister(optee->teedev);
+		tee_device_unregister(optee->supp_teedev);
+	}
 	if (pool)
 		tee_shm_pool_free(pool);
 	if (ioremaped_shm)
diff --git a/drivers/tee/optee/optee_private.h b/drivers/tee/optee/optee_private.h
index 2bd7dd8..807f74c 100644
--- a/drivers/tee/optee/optee_private.h
+++ b/drivers/tee/optee/optee_private.h
@@ -50,8 +50,10 @@ struct optee_wait_queue {
 
 /**
  * struct optee_supp - supplicant synchronization struct
- * @available:		if 1 the supplicant device is available for use, else
- *			busy
+ * @ctx			the context of current connected supplicant.
+ *			if !NULL the supplicant device is available for use,
+ *			else busy
+ * @ctx_mutex:		held while accessing @ctx
  * @func:		supplicant function id to call
  * @ret:		call return value
  * @num_params:		number of elements in @param
@@ -64,7 +66,9 @@ struct optee_wait_queue {
  * @data_from_supp:	requesting thread is waiting on this to get the result
  */
 struct optee_supp {
-	atomic_t available;
+	struct tee_context *ctx;
+	/* Serializes access of ctx */
+	struct mutex ctx_mutex;
 
 	u32 func;
 	u32 ret;
diff --git a/drivers/tee/optee/rpc.c b/drivers/tee/optee/rpc.c
index ba8b5bb..3e6fca1 100644
--- a/drivers/tee/optee/rpc.c
+++ b/drivers/tee/optee/rpc.c
@@ -189,6 +189,7 @@ static struct tee_shm *cmd_alloc_suppl(struct tee_context *ctx, size_t sz)
 	u32 ret;
 	struct tee_param param;
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
+	struct tee_shm *shm;
 
 	param.attr = TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT;
 	param.u.value.a = OPTEE_MSG_RPC_SHM_TYPE_APPL;
@@ -199,14 +200,16 @@ static struct tee_shm *cmd_alloc_suppl(struct tee_context *ctx, size_t sz)
 	if (ret)
 		return ERR_PTR(-ENOMEM);
 
+	mutex_lock(&optee->supp.ctx_mutex);
 	/* Increases count as secure world doesn't have a reference */
-	return tee_shm_get_from_id(optee->supp_teedev, param.u.value.c);
+	shm = tee_shm_get_from_id(optee->supp.ctx, param.u.value.c);
+	mutex_unlock(&optee->supp.ctx_mutex);
+	return shm;
 }
 
 static void handle_rpc_func_cmd_shm_alloc(struct tee_context *ctx,
 					  struct optee_msg_arg *arg)
 {
-	struct tee_device *teedev = ctx->teedev;
 	struct optee_msg_param *params = OPTEE_MSG_GET_PARAMS(arg);
 	phys_addr_t pa;
 	struct tee_shm *shm;
@@ -234,7 +237,7 @@ static void handle_rpc_func_cmd_shm_alloc(struct tee_context *ctx,
 		shm = cmd_alloc_suppl(ctx, sz);
 		break;
 	case OPTEE_MSG_RPC_SHM_TYPE_KERNEL:
-		shm = tee_shm_alloc(teedev, sz, TEE_SHM_MAPPED);
+		shm = tee_shm_alloc(ctx, sz, TEE_SHM_MAPPED);
 		break;
 	default:
 		arg->ret = TEEC_ERROR_BAD_PARAMETERS;
@@ -363,7 +366,7 @@ void optee_handle_rpc(struct tee_context *ctx, struct optee_rpc_param *param)
 
 	switch (OPTEE_SMC_RETURN_GET_RPC_FUNC(param->a0)) {
 	case OPTEE_SMC_RPC_FUNC_ALLOC:
-		shm = tee_shm_alloc(teedev, param->a1, TEE_SHM_MAPPED);
+		shm = tee_shm_alloc(ctx, param->a1, TEE_SHM_MAPPED);
 		if (!IS_ERR(shm) && !tee_shm_get_pa(shm, 0, &pa)) {
 			reg_pair_from_64(&param->a1, &param->a2, pa);
 			reg_pair_from_64(&param->a4, &param->a5,
diff --git a/drivers/tee/optee/supp.c b/drivers/tee/optee/supp.c
index c64650a..b4ea067 100644
--- a/drivers/tee/optee/supp.c
+++ b/drivers/tee/optee/supp.c
@@ -19,15 +19,16 @@
 void optee_supp_init(struct optee_supp *supp)
 {
 	memset(supp, 0, sizeof(*supp));
+	mutex_init(&supp->ctx_mutex);
 	mutex_init(&supp->thrd_mutex);
 	mutex_init(&supp->supp_mutex);
 	init_completion(&supp->data_to_supp);
 	init_completion(&supp->data_from_supp);
-	atomic_set(&supp->available, 1);
 }
 
 void optee_supp_uninit(struct optee_supp *supp)
 {
+	mutex_destroy(&supp->ctx_mutex);
 	mutex_destroy(&supp->thrd_mutex);
 	mutex_destroy(&supp->supp_mutex);
 }
@@ -44,6 +45,7 @@ void optee_supp_uninit(struct optee_supp *supp)
 u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,
 			struct tee_param *param)
 {
+	bool interruptable;
 	struct optee *optee = tee_get_drvdata(ctx->teedev);
 	struct optee_supp *supp = &optee->supp;
 	u32 ret;
@@ -52,14 +54,21 @@ u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,
 	 * Other threads blocks here until we've copied our answer from
 	 * supplicant.
 	 */
-	mutex_lock(&supp->thrd_mutex);
+	while (mutex_lock_interruptible(&supp->thrd_mutex)) {
+		/* See comment below on when the RPC can be interrupted. */
+		mutex_lock(&supp->ctx_mutex);
+		interruptable = !supp->ctx;
+		mutex_unlock(&supp->ctx_mutex);
+		if (interruptable)
+			return TEEC_ERROR_COMMUNICATION;
+	}
 
 	/*
 	 * We have exclusive access now since the supplicant at this
 	 * point is either doing a
-	 * wait_for_completion_interruptible(data_to_supp) or is in
+	 * wait_for_completion_interruptible(&supp->data_to_supp) or is in
 	 * userspace still about to do the ioctl() to enter
-	 * optee_supp_read() below.
+	 * optee_supp_recv() below.
 	 */
 
 	supp->func = func;
@@ -75,7 +84,30 @@ u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params,
 	 * returned from wait_for_completion(data_from_supp) we have
 	 * exclusive access again.
 	 */
-	wait_for_completion(&supp->data_from_supp);
+	while (wait_for_completion_interruptible(&supp->data_from_supp)) {
+		mutex_lock(&supp->ctx_mutex);
+		interruptable = !supp->ctx;
+		if (interruptable) {
+			/*
+			 * There's no supplicant available and since the
+			 * supp->ctx_mutex currently is held none can
+			 * become available until the mutex released
+			 * again.
+			 *
+			 * Interrupting an RPC to supplicant is only
+			 * allowed as a way of slightly improving the user
+			 * experience in case the supplicant hasn't been
+			 * started yet. During normal operation the supplicant
+			 * will serve all requests in a timely manner and
+			 * interrupting then wouldn't make sense.
+			 */
+			supp->ret = TEEC_ERROR_COMMUNICATION;
+			init_completion(&supp->data_to_supp);
+		}
+		mutex_unlock(&supp->ctx_mutex);
+		if (interruptable)
+			break;
+	}
 
 	ret = supp->ret;
 	supp->param = NULL;
@@ -106,9 +138,9 @@ int optee_supp_recv(struct tee_context *ctx, u32 *func, u32 *num_params,
 	int rc;
 
 	/*
-	 * In case two supplicants or two threads in one supplicant is
-	 * calling this function simultaneously we need to protect the
-	 * data with a mutex which we'll release before returning.
+	 * In case two threads in one supplicant is calling this function
+	 * simultaneously we need to protect the data with a mutex which
+	 * we'll release before returning.
 	 */
 	mutex_lock(&supp->supp_mutex);
 
diff --git a/drivers/tee/tee.c b/drivers/tee/tee.c
deleted file mode 100644
index 119e18e..0000000
--- a/drivers/tee/tee.c
+++ /dev/null
@@ -1,877 +0,0 @@
-/*
- * Copyright (c) 2015-2016, Linaro Limited
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/cdev.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/idr.h>
-#include <linux/slab.h>
-#include <linux/tee_drv.h>
-#include <linux/uaccess.h>
-#include "tee_private.h"
-
-#define TEE_NUM_DEVICES	32
-
-#define TEE_IOCTL_PARAM_SIZE(x) (sizeof(struct tee_param) * (x))
-
-/*
- * Unprivileged devices in the in the lower half range and privileged
- * devices in the upper half range.
- */
-static DECLARE_BITMAP(dev_mask, TEE_NUM_DEVICES);
-static DEFINE_SPINLOCK(driver_lock);
-
-static struct class *tee_class;
-static dev_t tee_devt;
-
-static int tee_open(struct inode *inode, struct file *filp)
-{
-	int rc;
-	struct tee_device *teedev;
-	struct tee_context *ctx;
-
-	teedev = container_of(inode->i_cdev, struct tee_device, cdev);
-	if (!tee_device_get(teedev))
-		return -EINVAL;
-
-	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
-	if (!ctx) {
-		rc = -ENOMEM;
-		goto err;
-	}
-
-	ctx->teedev = teedev;
-	filp->private_data = ctx;
-	rc = teedev->desc->ops->open(ctx);
-	if (rc)
-		goto err;
-
-	return 0;
-err:
-	kfree(ctx);
-	tee_device_put(teedev);
-	return rc;
-}
-
-static int tee_release(struct inode *inode, struct file *filp)
-{
-	struct tee_context *ctx = filp->private_data;
-	struct tee_device *teedev = ctx->teedev;
-
-	ctx->teedev->desc->ops->release(ctx);
-	kfree(ctx);
-	tee_device_put(teedev);
-	return 0;
-}
-
-static int tee_ioctl_version(struct tee_context *ctx,
-			     struct tee_ioctl_version_data __user *uvers)
-{
-	struct tee_ioctl_version_data vers;
-
-	ctx->teedev->desc->ops->get_version(ctx->teedev, &vers);
-	if (copy_to_user(uvers, &vers, sizeof(vers)))
-		return -EFAULT;
-	return 0;
-}
-
-static int tee_ioctl_shm_alloc(struct tee_context *ctx,
-			       struct tee_ioctl_shm_alloc_data __user *udata)
-{
-	long ret;
-	struct tee_ioctl_shm_alloc_data data;
-	struct tee_shm *shm;
-
-	if (copy_from_user(&data, udata, sizeof(data)))
-		return -EFAULT;
-
-	/* Currently no input flags are supported */
-	if (data.flags)
-		return -EINVAL;
-
-	data.id = -1;
-
-	shm = tee_shm_alloc(ctx->teedev, data.size,
-			    TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
-	if (IS_ERR(shm))
-		return PTR_ERR(shm);
-
-	data.id = shm->id;
-	data.flags = shm->flags;
-	data.size = shm->size;
-
-	if (copy_to_user(udata, &data, sizeof(data)))
-		ret = -EFAULT;
-	else
-		ret = tee_shm_get_fd(shm);
-
-	/*
-	 * When user space closes the file descriptor the shared memory
-	 * should be freed or if tee_shm_get_fd() failed then it will
-	 * be freed immediately.
-	 */
-	tee_shm_put(shm);
-	return ret;
-}
-
-static int params_from_user(struct tee_context *ctx, struct tee_param *params,
-			    size_t num_params,
-			    struct tee_ioctl_param __user *uparams)
-{
-	size_t n;
-
-	for (n = 0; n < num_params; n++) {
-		struct tee_shm *shm;
-		struct tee_ioctl_param ip;
-
-		if (copy_from_user(&ip, uparams + n, sizeof(ip)))
-			return -EFAULT;
-
-		/* All unused attribute bits has to be zero */
-		if (ip.attr & ~TEE_IOCTL_PARAM_ATTR_TYPE_MASK)
-			return -EINVAL;
-
-		params[n].attr = ip.attr;
-		switch (ip.attr) {
-		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
-			break;
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
-			params[n].u.value.a = ip.u.value.a;
-			params[n].u.value.b = ip.u.value.b;
-			params[n].u.value.c = ip.u.value.c;
-			break;
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
-			/*
-			 * If we fail to get a pointer to a shared memory
-			 * object (and increase the ref count) from an
-			 * identifier we return an error. All pointers that
-			 * has been added in params have an increased ref
-			 * count. It's the callers responibility to do
-			 * tee_shm_put() on all resolved pointers.
-			 */
-			shm = tee_shm_get_from_id(ctx->teedev,
-						  ip.u.memref.shm_id);
-			if (IS_ERR(shm))
-				return PTR_ERR(shm);
-
-			params[n].u.memref.shm_offs = ip.u.memref.shm_offs;
-			params[n].u.memref.size = ip.u.memref.size;
-			params[n].u.memref.shm = shm;
-			break;
-		default:
-			/* Unknown attribute */
-			return -EINVAL;
-		}
-	}
-	return 0;
-}
-
-static int params_to_user(struct tee_ioctl_param __user *uparams,
-			  size_t num_params, struct tee_param *params)
-{
-	size_t n;
-
-	for (n = 0; n < num_params; n++) {
-		struct tee_ioctl_param __user *up = uparams + n;
-		struct tee_param *p = params + n;
-
-		switch (p->attr) {
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
-			if (put_user(p->u.value.a, &up->u.value.a) ||
-			    put_user(p->u.value.b, &up->u.value.b) ||
-			    put_user(p->u.value.c, &up->u.value.c))
-				return -EFAULT;
-			break;
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
-			if (put_user((u64)p->u.memref.size, &up->u.memref.size))
-				return -EFAULT;
-		default:
-			break;
-		}
-	}
-	return 0;
-}
-
-static bool param_is_memref(struct tee_param *param)
-{
-	switch (param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {
-	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
-	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
-	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static int tee_ioctl_open_session(struct tee_context *ctx,
-				  struct tee_ioctl_buf_data __user *ubuf)
-{
-	int rc;
-	size_t n;
-	struct tee_ioctl_buf_data buf;
-	struct tee_ioctl_open_session_arg __user *uarg;
-	struct tee_ioctl_open_session_arg arg;
-	struct tee_ioctl_param __user *uparams = NULL;
-	struct tee_param *params = NULL;
-	bool have_session = false;
-
-	if (!ctx->teedev->desc->ops->open_session)
-		return -EINVAL;
-
-	if (copy_from_user(&buf, ubuf, sizeof(buf)))
-		return -EFAULT;
-
-	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
-	    buf.buf_len < sizeof(struct tee_ioctl_open_session_arg))
-		return -EINVAL;
-
-	uarg = (struct tee_ioctl_open_session_arg __user *)(unsigned long)
-		buf.buf_ptr;
-	rc = copy_from_user(&arg, uarg, sizeof(arg));
-	if (rc)
-		return rc;
-
-	if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)
-		return -EINVAL;
-
-	if (arg.num_params) {
-		params = kcalloc(arg.num_params, sizeof(struct tee_param),
-				 GFP_KERNEL);
-		if (!params)
-			return -ENOMEM;
-		uparams = (struct tee_ioctl_param __user *)(uarg + 1);
-		rc = params_from_user(ctx, params, arg.num_params, uparams);
-		if (rc)
-			goto out;
-	}
-
-	rc = ctx->teedev->desc->ops->open_session(ctx, &arg, params);
-	if (rc)
-		goto out;
-	have_session = true;
-
-	if (put_user(arg.session, &uarg->session) ||
-	    put_user(arg.ret, &uarg->ret) ||
-	    put_user(arg.ret_origin, &uarg->ret_origin)) {
-		rc = -EFAULT;
-		goto out;
-	}
-	rc = params_to_user(uparams, arg.num_params, params);
-out:
-	/*
-	 * If we've succeeded to open the session but failed to communicate
-	 * it back to user space, close the session again to avoid leakage.
-	 */
-	if (rc && have_session && ctx->teedev->desc->ops->close_session)
-		ctx->teedev->desc->ops->close_session(ctx, arg.session);
-
-	if (params) {
-		/* Decrease ref count for all valid shared memory pointers */
-		for (n = 0; n < arg.num_params; n++)
-			if (param_is_memref(params + n) &&
-			    params[n].u.memref.shm)
-				tee_shm_put(params[n].u.memref.shm);
-		kfree(params);
-	}
-
-	return rc;
-}
-
-static int tee_ioctl_invoke(struct tee_context *ctx,
-			    struct tee_ioctl_buf_data __user *ubuf)
-{
-	int rc;
-	size_t n;
-	struct tee_ioctl_buf_data buf;
-	struct tee_ioctl_invoke_arg __user *uarg;
-	struct tee_ioctl_invoke_arg arg;
-	struct tee_ioctl_param __user *uparams = NULL;
-	struct tee_param *params = NULL;
-
-	if (!ctx->teedev->desc->ops->invoke_func)
-		return -EINVAL;
-
-	rc = copy_from_user(&buf, ubuf, sizeof(buf));
-	if (rc)
-		return rc;
-
-	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
-	    buf.buf_len < sizeof(struct tee_ioctl_invoke_arg))
-		return -EINVAL;
-
-	uarg = (struct tee_ioctl_invoke_arg __user *)(unsigned long)buf.buf_ptr;
-	if (copy_from_user(&arg, uarg, sizeof(arg)))
-		return -EFAULT;
-
-	if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)
-		return -EINVAL;
-
-	if (arg.num_params) {
-		params = kcalloc(arg.num_params, sizeof(struct tee_param),
-				 GFP_KERNEL);
-		if (!params)
-			return -ENOMEM;
-		uparams = (struct tee_ioctl_param __user *)(uarg + 1);
-		rc = params_from_user(ctx, params, arg.num_params, uparams);
-		if (rc)
-			goto out;
-	}
-
-	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
-	if (rc)
-		goto out;
-
-	if (put_user(arg.ret, &uarg->ret) ||
-	    put_user(arg.ret_origin, &uarg->ret_origin)) {
-		rc = -EFAULT;
-		goto out;
-	}
-	rc = params_to_user(uparams, arg.num_params, params);
-out:
-	if (params) {
-		/* Decrease ref count for all valid shared memory pointers */
-		for (n = 0; n < arg.num_params; n++)
-			if (param_is_memref(params + n) &&
-			    params[n].u.memref.shm)
-				tee_shm_put(params[n].u.memref.shm);
-		kfree(params);
-	}
-	return rc;
-}
-
-static int tee_ioctl_cancel(struct tee_context *ctx,
-			    struct tee_ioctl_cancel_arg __user *uarg)
-{
-	struct tee_ioctl_cancel_arg arg;
-
-	if (!ctx->teedev->desc->ops->cancel_req)
-		return -EINVAL;
-
-	if (copy_from_user(&arg, uarg, sizeof(arg)))
-		return -EFAULT;
-
-	return ctx->teedev->desc->ops->cancel_req(ctx, arg.cancel_id,
-						  arg.session);
-}
-
-static int tee_ioctl_close_session(struct tee_context *ctx,
-		struct tee_ioctl_close_session_arg __user *uarg)
-{
-	struct tee_ioctl_close_session_arg arg;
-
-	if (!ctx->teedev->desc->ops->close_session)
-		return -EINVAL;
-
-	if (copy_from_user(&arg, uarg, sizeof(arg)))
-		return -EFAULT;
-
-	return ctx->teedev->desc->ops->close_session(ctx, arg.session);
-}
-
-static int params_to_supp(struct tee_context *ctx,
-			  struct tee_ioctl_param __user *uparams,
-			  size_t num_params, struct tee_param *params)
-{
-	size_t n;
-
-	for (n = 0; n < num_params; n++) {
-		struct tee_ioctl_param ip;
-		struct tee_param *p = params + n;
-
-		ip.attr = p->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK;
-		switch (p->attr) {
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
-			ip.u.value.a = p->u.value.a;
-			ip.u.value.b = p->u.value.b;
-			ip.u.value.c = p->u.value.c;
-			break;
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
-			ip.u.memref.size = p->u.memref.size;
-			if (!p->u.memref.shm) {
-				ip.u.memref.shm_offs = 0;
-				ip.u.memref.shm_id = -1;
-				break;
-			}
-			ip.u.memref.shm_offs = p->u.memref.shm_offs;
-			ip.u.memref.shm_id = p->u.memref.shm->id;
-			break;
-		default:
-			memset(&ip.u, 0, sizeof(ip.u));
-			break;
-		}
-
-		if (copy_to_user(uparams + n, &ip, sizeof(ip)))
-			return -EFAULT;
-	}
-
-	return 0;
-}
-
-static int tee_ioctl_supp_recv(struct tee_context *ctx,
-			       struct tee_ioctl_buf_data __user *ubuf)
-{
-	int rc;
-	struct tee_ioctl_buf_data buf;
-	struct tee_iocl_supp_recv_arg __user *uarg;
-	struct tee_param *params;
-	struct tee_ioctl_param __user *uparams;
-	u32 num_params;
-	u32 func;
-
-	if (!ctx->teedev->desc->ops->supp_recv)
-		return -EINVAL;
-
-	if (copy_from_user(&buf, ubuf, sizeof(buf)))
-		return -EFAULT;
-
-	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
-	    buf.buf_len < sizeof(struct tee_iocl_supp_recv_arg))
-		return -EINVAL;
-
-	uarg = (struct tee_iocl_supp_recv_arg __user *)(unsigned long)
-		buf.buf_ptr;
-	if (get_user(num_params, &uarg->num_params))
-		return -EFAULT;
-
-	if (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) != buf.buf_len)
-		return -EINVAL;
-
-	params = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);
-	if (!params)
-		return -ENOMEM;
-
-	rc = ctx->teedev->desc->ops->supp_recv(ctx, &func, &num_params, params);
-	if (rc)
-		goto out;
-
-	if (put_user(func, &uarg->func) ||
-	    put_user(num_params, &uarg->num_params)) {
-		rc = -EFAULT;
-		goto out;
-	}
-
-	uparams = (struct tee_ioctl_param __user *)(uarg + 1);
-	rc = params_to_supp(ctx, uparams, num_params, params);
-out:
-	kfree(params);
-	return rc;
-}
-
-static int params_from_supp(struct tee_param *params, size_t num_params,
-			    struct tee_ioctl_param __user *uparams)
-{
-	size_t n;
-
-	for (n = 0; n < num_params; n++) {
-		struct tee_param *p = params + n;
-		struct tee_ioctl_param ip;
-
-		if (copy_from_user(&ip, uparams + n, sizeof(ip)))
-			return -EFAULT;
-
-		/* All unused attribute bits has to be zero */
-		if (ip.attr & ~TEE_IOCTL_PARAM_ATTR_TYPE_MASK)
-			return -EINVAL;
-
-		p->attr = ip.attr;
-		switch (ip.attr) {
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
-			/* Only out and in/out values can be updated */
-			p->u.value.a = ip.u.value.a;
-			p->u.value.b = ip.u.value.b;
-			p->u.value.c = ip.u.value.c;
-			break;
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
-		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
-			/*
-			 * Only the size of the memref can be updated.
-			 * Since we don't have access to the original
-			 * parameters here, only store the supplied size.
-			 * The driver will copy the updated size into the
-			 * original parameters.
-			 */
-			p->u.memref.shm = NULL;
-			p->u.memref.shm_offs = 0;
-			p->u.memref.size = ip.u.memref.size;
-			break;
-		default:
-			memset(&p->u, 0, sizeof(p->u));
-			break;
-		}
-	}
-	return 0;
-}
-
-static int tee_ioctl_supp_send(struct tee_context *ctx,
-			       struct tee_ioctl_buf_data __user *ubuf)
-{
-	long rc;
-	struct tee_ioctl_buf_data buf;
-	struct tee_iocl_supp_send_arg __user *uarg;
-	struct tee_param *params;
-	struct tee_ioctl_param __user *uparams;
-	u32 num_params;
-	u32 ret;
-
-	/* Not valid for this driver */
-	if (!ctx->teedev->desc->ops->supp_send)
-		return -EINVAL;
-
-	if (copy_from_user(&buf, ubuf, sizeof(buf)))
-		return -EFAULT;
-
-	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
-	    buf.buf_len < sizeof(struct tee_iocl_supp_send_arg))
-		return -EINVAL;
-
-	uarg = (struct tee_iocl_supp_send_arg __user *)(unsigned long)
-		buf.buf_ptr;
-	if (get_user(ret, &uarg->ret) ||
-	    get_user(num_params, &uarg->num_params))
-		return -EFAULT;
-
-	if (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) > buf.buf_len)
-		return -EINVAL;
-
-	params = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);
-	if (!params)
-		return -ENOMEM;
-
-	uparams = (struct tee_ioctl_param __user *)(uarg + 1);
-	rc = params_from_supp(params, num_params, uparams);
-	if (rc)
-		goto out;
-
-	rc = ctx->teedev->desc->ops->supp_send(ctx, ret, num_params, params);
-out:
-	kfree(params);
-	return rc;
-}
-
-static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
-{
-	struct tee_context *ctx = filp->private_data;
-	void __user *uarg = (void __user *)arg;
-
-	switch (cmd) {
-	case TEE_IOC_VERSION:
-		return tee_ioctl_version(ctx, uarg);
-	case TEE_IOC_SHM_ALLOC:
-		return tee_ioctl_shm_alloc(ctx, uarg);
-	case TEE_IOC_OPEN_SESSION:
-		return tee_ioctl_open_session(ctx, uarg);
-	case TEE_IOC_INVOKE:
-		return tee_ioctl_invoke(ctx, uarg);
-	case TEE_IOC_CANCEL:
-		return tee_ioctl_cancel(ctx, uarg);
-	case TEE_IOC_CLOSE_SESSION:
-		return tee_ioctl_close_session(ctx, uarg);
-	case TEE_IOC_SUPPL_RECV:
-		return tee_ioctl_supp_recv(ctx, uarg);
-	case TEE_IOC_SUPPL_SEND:
-		return tee_ioctl_supp_send(ctx, uarg);
-	default:
-		return -EINVAL;
-	}
-}
-
-static const struct file_operations tee_fops = {
-	.open = tee_open,
-	.release = tee_release,
-	.unlocked_ioctl = tee_ioctl,
-	.compat_ioctl = tee_ioctl,
-};
-
-static void tee_release_device(struct device *dev)
-{
-	struct tee_device *teedev = container_of(dev, struct tee_device, dev);
-
-	spin_lock(&driver_lock);
-	clear_bit(teedev->id, dev_mask);
-	spin_unlock(&driver_lock);
-	mutex_destroy(&teedev->mutex);
-	kfree(teedev);
-}
-
-/**
- * tee_device_alloc() - Allocate a new struct tee_device instance
- * @teedesc:	Descriptor for this driver
- * @dev:	Parent device for this device
- * @pool:	Shared memory pool, NULL if not used
- * @driver_data: Private driver data for this device
- *
- * Allocates a new struct tee_device instance. The device is
- * removed by tee_device_unregister().
- *
- * @returns a pointer to a 'struct tee_device' or an ERR_PTR on failure
- */
-struct tee_device *tee_device_alloc(const struct tee_desc *teedesc,
-				    struct device *dev,
-				    struct tee_shm_pool *pool,
-				    void *driver_data)
-{
-	struct tee_device *teedev;
-	void *ret;
-	int rc;
-	int offs = 0;
-
-	if (!teedesc || !teedesc->name || !teedesc->ops ||
-	    !teedesc->ops->get_version || !teedesc->ops->open ||
-	    !teedesc->ops->release || !dev || !pool)
-		return ERR_PTR(-EINVAL);
-
-	teedev = kzalloc(sizeof(*teedev), GFP_KERNEL);
-	if (!teedev) {
-		ret = ERR_PTR(-ENOMEM);
-		goto err;
-	}
-
-	if (teedesc->flags & TEE_DESC_PRIVILEGED)
-		offs = TEE_NUM_DEVICES / 2;
-
-	spin_lock(&driver_lock);
-	teedev->id = find_next_zero_bit(dev_mask, TEE_NUM_DEVICES, offs);
-	if (teedev->id < TEE_NUM_DEVICES)
-		set_bit(teedev->id, dev_mask);
-	spin_unlock(&driver_lock);
-
-	if (teedev->id >= TEE_NUM_DEVICES) {
-		ret = ERR_PTR(-ENOMEM);
-		goto err;
-	}
-
-	snprintf(teedev->name, sizeof(teedev->name), "tee%s%d",
-		 teedesc->flags & TEE_DESC_PRIVILEGED ? "priv" : "",
-		 teedev->id - offs);
-
-	teedev->dev.class = tee_class;
-	teedev->dev.release = tee_release_device;
-	teedev->dev.parent = dev;
-	teedev->dev.devt = MKDEV(MAJOR(tee_devt), teedev->id);
-
-	rc = dev_set_name(&teedev->dev, "%s", teedev->name);
-	if (rc) {
-		ret = ERR_PTR(rc);
-		goto err;
-	}
-
-	cdev_init(&teedev->cdev, &tee_fops);
-	teedev->cdev.owner = teedesc->owner;
-	teedev->cdev.kobj.parent = &teedev->dev.kobj;
-
-	dev_set_drvdata(&teedev->dev, driver_data);
-	device_initialize(&teedev->dev);
-
-	/* 1 as tee_device_unregister() does one final tee_device_put() */
-	teedev->num_users = 1;
-	init_completion(&teedev->c_no_users);
-	mutex_init(&teedev->mutex);
-
-	teedev->desc = teedesc;
-	teedev->pool = pool;
-
-	return teedev;
-err:
-	dev_err(dev, "could not register %s driver\n",
-		teedesc->flags & TEE_DESC_PRIVILEGED ? "privileged" : "client");
-	if (teedev && teedev->id < TEE_NUM_DEVICES) {
-		spin_lock(&driver_lock);
-		clear_bit(teedev->id, dev_mask);
-		spin_unlock(&driver_lock);
-	}
-	kfree(teedev);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(tee_device_alloc);
-
-static ssize_t implementation_id_show(struct device *dev,
-				      struct device_attribute *attr, char *buf)
-{
-	struct tee_device *teedev = container_of(dev, struct tee_device, dev);
-	struct tee_ioctl_version_data vers;
-
-	teedev->desc->ops->get_version(teedev, &vers);
-	return scnprintf(buf, PAGE_SIZE, "%d\n", vers.impl_id);
-}
-static DEVICE_ATTR_RO(implementation_id);
-
-static struct attribute *tee_dev_attrs[] = {
-	&dev_attr_implementation_id.attr,
-	NULL
-};
-
-static const struct attribute_group tee_dev_group = {
-	.attrs = tee_dev_attrs,
-};
-
-/**
- * tee_device_register() - Registers a TEE device
- * @teedev:	Device to register
- *
- * tee_device_unregister() need to be called to remove the @teedev if
- * this function fails.
- *
- * @returns < 0 on failure
- */
-int tee_device_register(struct tee_device *teedev)
-{
-	int rc;
-
-	/*
-	 * If the teedev already is registered, don't do it again. It's
-	 * obviously an error to try to register twice, but if we return
-	 * an error we'll force the driver to remove the teedev.
-	 */
-	if (teedev->flags & TEE_DEVICE_FLAG_REGISTERED) {
-		dev_err(&teedev->dev, "attempt to register twice\n");
-		return 0;
-	}
-
-	rc = cdev_add(&teedev->cdev, teedev->dev.devt, 1);
-	if (rc) {
-		dev_err(&teedev->dev,
-			"unable to cdev_add() %s, major %d, minor %d, err=%d\n",
-			teedev->name, MAJOR(teedev->dev.devt),
-			MINOR(teedev->dev.devt), rc);
-		return rc;
-	}
-
-	rc = device_add(&teedev->dev);
-	if (rc) {
-		dev_err(&teedev->dev,
-			"unable to device_add() %s, major %d, minor %d, err=%d\n",
-			teedev->name, MAJOR(teedev->dev.devt),
-			MINOR(teedev->dev.devt), rc);
-		goto err_device_add;
-	}
-
-	rc = sysfs_create_group(&teedev->dev.kobj, &tee_dev_group);
-	if (rc) {
-		dev_err(&teedev->dev,
-			"failed to create sysfs attributes, err=%d\n", rc);
-		goto err_sysfs_create_group;
-	}
-
-	teedev->flags |= TEE_DEVICE_FLAG_REGISTERED;
-	return 0;
-
-err_sysfs_create_group:
-	device_del(&teedev->dev);
-err_device_add:
-	cdev_del(&teedev->cdev);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(tee_device_register);
-
-void tee_device_put(struct tee_device *teedev)
-{
-	mutex_lock(&teedev->mutex);
-	/* Shouldn't put in this state */
-	if (!WARN_ON(!teedev->desc)) {
-		teedev->num_users--;
-		if (!teedev->num_users) {
-			teedev->desc = NULL;
-			complete(&teedev->c_no_users);
-		}
-	}
-	mutex_unlock(&teedev->mutex);
-}
-
-bool tee_device_get(struct tee_device *teedev)
-{
-	mutex_lock(&teedev->mutex);
-	if (!teedev->desc) {
-		mutex_unlock(&teedev->mutex);
-		return false;
-	}
-	teedev->num_users++;
-	mutex_unlock(&teedev->mutex);
-	return true;
-}
-
-/**
- * tee_device_unregister() - Removes a TEE device
- * @teedev:	Device to unregister
- *
- * This function should be called to remove the @teedev even if
- * tee_device_register() hasn't been called yet. Does nothing if
- * @teedev is NULL.
- */
-void tee_device_unregister(struct tee_device *teedev)
-{
-	if (!teedev)
-		return;
-
-	if (teedev->flags & TEE_DEVICE_FLAG_REGISTERED) {
-		sysfs_remove_group(&teedev->dev.kobj, &tee_dev_group);
-		cdev_del(&teedev->cdev);
-		device_del(&teedev->dev);
-	}
-
-	tee_device_put(teedev);
-	wait_for_completion(&teedev->c_no_users);
-
-	/*
-	 * No need to take a mutex any longer now since teedev->desc was
-	 * set to NULL before teedev->c_no_users was completed.
-	 */
-
-	teedev->pool = NULL;
-
-	put_device(&teedev->dev);
-}
-EXPORT_SYMBOL_GPL(tee_device_unregister);
-
-/**
- * tee_get_drvdata() - Return driver_data pointer
- * @teedev:	Device containing the driver_data pointer
- * @returns the driver_data pointer supplied to tee_register().
- */
-void *tee_get_drvdata(struct tee_device *teedev)
-{
-	return dev_get_drvdata(&teedev->dev);
-}
-EXPORT_SYMBOL_GPL(tee_get_drvdata);
-
-static int __init tee_init(void)
-{
-	int rc;
-
-	tee_class = class_create(THIS_MODULE, "tee");
-	if (IS_ERR(tee_class)) {
-		pr_err("couldn't create class\n");
-		return PTR_ERR(tee_class);
-	}
-
-	rc = alloc_chrdev_region(&tee_devt, 0, TEE_NUM_DEVICES, "tee");
-	if (rc < 0) {
-		pr_err("failed to allocate char dev region\n");
-		class_destroy(tee_class);
-		tee_class = NULL;
-	}
-
-	return rc;
-}
-
-subsys_initcall(tee_init);
diff --git a/drivers/tee/tee_core.c b/drivers/tee/tee_core.c
new file mode 100644
index 0000000..d30d934
--- /dev/null
+++ b/drivers/tee/tee_core.c
@@ -0,0 +1,901 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/tee_drv.h>
+#include <linux/uaccess.h>
+#include "tee_private.h"
+
+#define TEE_NUM_DEVICES	32
+
+#define TEE_IOCTL_PARAM_SIZE(x) (sizeof(struct tee_param) * (x))
+
+/*
+ * Unprivileged devices in the in the lower half range and privileged
+ * devices in the upper half range.
+ */
+static DECLARE_BITMAP(dev_mask, TEE_NUM_DEVICES);
+static DEFINE_SPINLOCK(driver_lock);
+
+static struct class *tee_class;
+static dev_t tee_devt;
+
+static int tee_open(struct inode *inode, struct file *filp)
+{
+	int rc;
+	struct tee_device *teedev;
+	struct tee_context *ctx;
+
+	teedev = container_of(inode->i_cdev, struct tee_device, cdev);
+	if (!tee_device_get(teedev))
+		return -EINVAL;
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	ctx->teedev = teedev;
+	INIT_LIST_HEAD(&ctx->list_shm);
+	filp->private_data = ctx;
+	rc = teedev->desc->ops->open(ctx);
+	if (rc)
+		goto err;
+
+	return 0;
+err:
+	kfree(ctx);
+	tee_device_put(teedev);
+	return rc;
+}
+
+static int tee_release(struct inode *inode, struct file *filp)
+{
+	struct tee_context *ctx = filp->private_data;
+	struct tee_device *teedev = ctx->teedev;
+	struct tee_shm *shm;
+
+	ctx->teedev->desc->ops->release(ctx);
+	mutex_lock(&ctx->teedev->mutex);
+	list_for_each_entry(shm, &ctx->list_shm, link)
+		shm->ctx = NULL;
+	mutex_unlock(&ctx->teedev->mutex);
+	kfree(ctx);
+	tee_device_put(teedev);
+	return 0;
+}
+
+static int tee_ioctl_version(struct tee_context *ctx,
+			     struct tee_ioctl_version_data __user *uvers)
+{
+	struct tee_ioctl_version_data vers;
+
+	ctx->teedev->desc->ops->get_version(ctx->teedev, &vers);
+	if (copy_to_user(uvers, &vers, sizeof(vers)))
+		return -EFAULT;
+	return 0;
+}
+
+static int tee_ioctl_shm_alloc(struct tee_context *ctx,
+			       struct tee_ioctl_shm_alloc_data __user *udata)
+{
+	long ret;
+	struct tee_ioctl_shm_alloc_data data;
+	struct tee_shm *shm;
+
+	if (copy_from_user(&data, udata, sizeof(data)))
+		return -EFAULT;
+
+	/* Currently no input flags are supported */
+	if (data.flags)
+		return -EINVAL;
+
+	data.id = -1;
+
+	shm = tee_shm_alloc(ctx, data.size, TEE_SHM_MAPPED | TEE_SHM_DMA_BUF);
+	if (IS_ERR(shm))
+		return PTR_ERR(shm);
+
+	data.id = shm->id;
+	data.flags = shm->flags;
+	data.size = shm->size;
+
+	if (copy_to_user(udata, &data, sizeof(data)))
+		ret = -EFAULT;
+	else
+		ret = tee_shm_get_fd(shm);
+
+	/*
+	 * When user space closes the file descriptor the shared memory
+	 * should be freed or if tee_shm_get_fd() failed then it will
+	 * be freed immediately.
+	 */
+	tee_shm_put(shm);
+	return ret;
+}
+
+static int params_from_user(struct tee_context *ctx, struct tee_param *params,
+			    size_t num_params,
+			    struct tee_ioctl_param __user *uparams)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		struct tee_shm *shm;
+		struct tee_ioctl_param ip;
+
+		if (copy_from_user(&ip, uparams + n, sizeof(ip)))
+			return -EFAULT;
+
+		/* All unused attribute bits has to be zero */
+		if (ip.attr & ~TEE_IOCTL_PARAM_ATTR_TYPE_MASK)
+			return -EINVAL;
+
+		params[n].attr = ip.attr;
+		switch (ip.attr) {
+		case TEE_IOCTL_PARAM_ATTR_TYPE_NONE:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
+			break;
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
+			params[n].u.value.a = ip.u.value.a;
+			params[n].u.value.b = ip.u.value.b;
+			params[n].u.value.c = ip.u.value.c;
+			break;
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+			/*
+			 * If we fail to get a pointer to a shared memory
+			 * object (and increase the ref count) from an
+			 * identifier we return an error. All pointers that
+			 * has been added in params have an increased ref
+			 * count. It's the callers responibility to do
+			 * tee_shm_put() on all resolved pointers.
+			 */
+			shm = tee_shm_get_from_id(ctx, ip.u.memref.shm_id);
+			if (IS_ERR(shm))
+				return PTR_ERR(shm);
+
+			params[n].u.memref.shm_offs = ip.u.memref.shm_offs;
+			params[n].u.memref.size = ip.u.memref.size;
+			params[n].u.memref.shm = shm;
+			break;
+		default:
+			/* Unknown attribute */
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+static int params_to_user(struct tee_ioctl_param __user *uparams,
+			  size_t num_params, struct tee_param *params)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		struct tee_ioctl_param __user *up = uparams + n;
+		struct tee_param *p = params + n;
+
+		switch (p->attr) {
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
+			if (put_user(p->u.value.a, &up->u.value.a) ||
+			    put_user(p->u.value.b, &up->u.value.b) ||
+			    put_user(p->u.value.c, &up->u.value.c))
+				return -EFAULT;
+			break;
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+			if (put_user((u64)p->u.memref.size, &up->u.memref.size))
+				return -EFAULT;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+
+static bool param_is_memref(struct tee_param *param)
+{
+	switch (param->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK) {
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+	case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int tee_ioctl_open_session(struct tee_context *ctx,
+				  struct tee_ioctl_buf_data __user *ubuf)
+{
+	int rc;
+	size_t n;
+	struct tee_ioctl_buf_data buf;
+	struct tee_ioctl_open_session_arg __user *uarg;
+	struct tee_ioctl_open_session_arg arg;
+	struct tee_ioctl_param __user *uparams = NULL;
+	struct tee_param *params = NULL;
+	bool have_session = false;
+
+	if (!ctx->teedev->desc->ops->open_session)
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, sizeof(buf)))
+		return -EFAULT;
+
+	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
+	    buf.buf_len < sizeof(struct tee_ioctl_open_session_arg))
+		return -EINVAL;
+
+	uarg = (struct tee_ioctl_open_session_arg __user *)(unsigned long)
+		buf.buf_ptr;
+	if (copy_from_user(&arg, uarg, sizeof(arg)))
+		return -EFAULT;
+
+	if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)
+		return -EINVAL;
+
+	if (arg.num_params) {
+		params = kcalloc(arg.num_params, sizeof(struct tee_param),
+				 GFP_KERNEL);
+		if (!params)
+			return -ENOMEM;
+		uparams = (struct tee_ioctl_param __user *)(uarg + 1);
+		rc = params_from_user(ctx, params, arg.num_params, uparams);
+		if (rc)
+			goto out;
+	}
+
+	rc = ctx->teedev->desc->ops->open_session(ctx, &arg, params);
+	if (rc)
+		goto out;
+	have_session = true;
+
+	if (put_user(arg.session, &uarg->session) ||
+	    put_user(arg.ret, &uarg->ret) ||
+	    put_user(arg.ret_origin, &uarg->ret_origin)) {
+		rc = -EFAULT;
+		goto out;
+	}
+	rc = params_to_user(uparams, arg.num_params, params);
+out:
+	/*
+	 * If we've succeeded to open the session but failed to communicate
+	 * it back to user space, close the session again to avoid leakage.
+	 */
+	if (rc && have_session && ctx->teedev->desc->ops->close_session)
+		ctx->teedev->desc->ops->close_session(ctx, arg.session);
+
+	if (params) {
+		/* Decrease ref count for all valid shared memory pointers */
+		for (n = 0; n < arg.num_params; n++)
+			if (param_is_memref(params + n) &&
+			    params[n].u.memref.shm)
+				tee_shm_put(params[n].u.memref.shm);
+		kfree(params);
+	}
+
+	return rc;
+}
+
+static int tee_ioctl_invoke(struct tee_context *ctx,
+			    struct tee_ioctl_buf_data __user *ubuf)
+{
+	int rc;
+	size_t n;
+	struct tee_ioctl_buf_data buf;
+	struct tee_ioctl_invoke_arg __user *uarg;
+	struct tee_ioctl_invoke_arg arg;
+	struct tee_ioctl_param __user *uparams = NULL;
+	struct tee_param *params = NULL;
+
+	if (!ctx->teedev->desc->ops->invoke_func)
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, sizeof(buf)))
+		return -EFAULT;
+
+	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
+	    buf.buf_len < sizeof(struct tee_ioctl_invoke_arg))
+		return -EINVAL;
+
+	uarg = (struct tee_ioctl_invoke_arg __user *)(unsigned long)buf.buf_ptr;
+	if (copy_from_user(&arg, uarg, sizeof(arg)))
+		return -EFAULT;
+
+	if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len)
+		return -EINVAL;
+
+	if (arg.num_params) {
+		params = kcalloc(arg.num_params, sizeof(struct tee_param),
+				 GFP_KERNEL);
+		if (!params)
+			return -ENOMEM;
+		uparams = (struct tee_ioctl_param __user *)(uarg + 1);
+		rc = params_from_user(ctx, params, arg.num_params, uparams);
+		if (rc)
+			goto out;
+	}
+
+	rc = ctx->teedev->desc->ops->invoke_func(ctx, &arg, params);
+	if (rc)
+		goto out;
+
+	if (put_user(arg.ret, &uarg->ret) ||
+	    put_user(arg.ret_origin, &uarg->ret_origin)) {
+		rc = -EFAULT;
+		goto out;
+	}
+	rc = params_to_user(uparams, arg.num_params, params);
+out:
+	if (params) {
+		/* Decrease ref count for all valid shared memory pointers */
+		for (n = 0; n < arg.num_params; n++)
+			if (param_is_memref(params + n) &&
+			    params[n].u.memref.shm)
+				tee_shm_put(params[n].u.memref.shm);
+		kfree(params);
+	}
+	return rc;
+}
+
+static int tee_ioctl_cancel(struct tee_context *ctx,
+			    struct tee_ioctl_cancel_arg __user *uarg)
+{
+	struct tee_ioctl_cancel_arg arg;
+
+	if (!ctx->teedev->desc->ops->cancel_req)
+		return -EINVAL;
+
+	if (copy_from_user(&arg, uarg, sizeof(arg)))
+		return -EFAULT;
+
+	return ctx->teedev->desc->ops->cancel_req(ctx, arg.cancel_id,
+						  arg.session);
+}
+
+static int
+tee_ioctl_close_session(struct tee_context *ctx,
+			struct tee_ioctl_close_session_arg __user *uarg)
+{
+	struct tee_ioctl_close_session_arg arg;
+
+	if (!ctx->teedev->desc->ops->close_session)
+		return -EINVAL;
+
+	if (copy_from_user(&arg, uarg, sizeof(arg)))
+		return -EFAULT;
+
+	return ctx->teedev->desc->ops->close_session(ctx, arg.session);
+}
+
+static int params_to_supp(struct tee_context *ctx,
+			  struct tee_ioctl_param __user *uparams,
+			  size_t num_params, struct tee_param *params)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		struct tee_ioctl_param ip;
+		struct tee_param *p = params + n;
+
+		ip.attr = p->attr & TEE_IOCTL_PARAM_ATTR_TYPE_MASK;
+		switch (p->attr) {
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
+			ip.u.value.a = p->u.value.a;
+			ip.u.value.b = p->u.value.b;
+			ip.u.value.c = p->u.value.c;
+			break;
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+			ip.u.memref.size = p->u.memref.size;
+			if (!p->u.memref.shm) {
+				ip.u.memref.shm_offs = 0;
+				ip.u.memref.shm_id = -1;
+				break;
+			}
+			ip.u.memref.shm_offs = p->u.memref.shm_offs;
+			ip.u.memref.shm_id = p->u.memref.shm->id;
+			break;
+		default:
+			memset(&ip.u, 0, sizeof(ip.u));
+			break;
+		}
+
+		if (copy_to_user(uparams + n, &ip, sizeof(ip)))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int tee_ioctl_supp_recv(struct tee_context *ctx,
+			       struct tee_ioctl_buf_data __user *ubuf)
+{
+	int rc;
+	struct tee_ioctl_buf_data buf;
+	struct tee_iocl_supp_recv_arg __user *uarg;
+	struct tee_param *params;
+	struct tee_ioctl_param __user *uparams;
+	u32 num_params;
+	u32 func;
+
+	if (!ctx->teedev->desc->ops->supp_recv)
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, sizeof(buf)))
+		return -EFAULT;
+
+	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
+	    buf.buf_len < sizeof(struct tee_iocl_supp_recv_arg))
+		return -EINVAL;
+
+	uarg = (struct tee_iocl_supp_recv_arg __user *)(unsigned long)
+		buf.buf_ptr;
+	if (get_user(num_params, &uarg->num_params))
+		return -EFAULT;
+
+	if (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) != buf.buf_len)
+		return -EINVAL;
+
+	params = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	rc = ctx->teedev->desc->ops->supp_recv(ctx, &func, &num_params, params);
+	if (rc)
+		goto out;
+
+	if (put_user(func, &uarg->func) ||
+	    put_user(num_params, &uarg->num_params)) {
+		rc = -EFAULT;
+		goto out;
+	}
+
+	uparams = (struct tee_ioctl_param __user *)(uarg + 1);
+	rc = params_to_supp(ctx, uparams, num_params, params);
+out:
+	kfree(params);
+	return rc;
+}
+
+static int params_from_supp(struct tee_param *params, size_t num_params,
+			    struct tee_ioctl_param __user *uparams)
+{
+	size_t n;
+
+	for (n = 0; n < num_params; n++) {
+		struct tee_param *p = params + n;
+		struct tee_ioctl_param ip;
+
+		if (copy_from_user(&ip, uparams + n, sizeof(ip)))
+			return -EFAULT;
+
+		/* All unused attribute bits has to be zero */
+		if (ip.attr & ~TEE_IOCTL_PARAM_ATTR_TYPE_MASK)
+			return -EINVAL;
+
+		p->attr = ip.attr;
+		switch (ip.attr) {
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT:
+			/* Only out and in/out values can be updated */
+			p->u.value.a = ip.u.value.a;
+			p->u.value.b = ip.u.value.b;
+			p->u.value.c = ip.u.value.c;
+			break;
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT:
+		case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT:
+			/*
+			 * Only the size of the memref can be updated.
+			 * Since we don't have access to the original
+			 * parameters here, only store the supplied size.
+			 * The driver will copy the updated size into the
+			 * original parameters.
+			 */
+			p->u.memref.shm = NULL;
+			p->u.memref.shm_offs = 0;
+			p->u.memref.size = ip.u.memref.size;
+			break;
+		default:
+			memset(&p->u, 0, sizeof(p->u));
+			break;
+		}
+	}
+	return 0;
+}
+
+static int tee_ioctl_supp_send(struct tee_context *ctx,
+			       struct tee_ioctl_buf_data __user *ubuf)
+{
+	long rc;
+	struct tee_ioctl_buf_data buf;
+	struct tee_iocl_supp_send_arg __user *uarg;
+	struct tee_param *params;
+	struct tee_ioctl_param __user *uparams;
+	u32 num_params;
+	u32 ret;
+
+	/* Not valid for this driver */
+	if (!ctx->teedev->desc->ops->supp_send)
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, sizeof(buf)))
+		return -EFAULT;
+
+	if (buf.buf_len > TEE_MAX_ARG_SIZE ||
+	    buf.buf_len < sizeof(struct tee_iocl_supp_send_arg))
+		return -EINVAL;
+
+	uarg = (struct tee_iocl_supp_send_arg __user *)(unsigned long)
+		buf.buf_ptr;
+	if (get_user(ret, &uarg->ret) ||
+	    get_user(num_params, &uarg->num_params))
+		return -EFAULT;
+
+	if (sizeof(*uarg) + TEE_IOCTL_PARAM_SIZE(num_params) > buf.buf_len)
+		return -EINVAL;
+
+	params = kcalloc(num_params, sizeof(struct tee_param), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	uparams = (struct tee_ioctl_param __user *)(uarg + 1);
+	rc = params_from_supp(params, num_params, uparams);
+	if (rc)
+		goto out;
+
+	rc = ctx->teedev->desc->ops->supp_send(ctx, ret, num_params, params);
+out:
+	kfree(params);
+	return rc;
+}
+
+static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct tee_context *ctx = filp->private_data;
+	void __user *uarg = (void __user *)arg;
+
+	switch (cmd) {
+	case TEE_IOC_VERSION:
+		return tee_ioctl_version(ctx, uarg);
+	case TEE_IOC_SHM_ALLOC:
+		return tee_ioctl_shm_alloc(ctx, uarg);
+	case TEE_IOC_OPEN_SESSION:
+		return tee_ioctl_open_session(ctx, uarg);
+	case TEE_IOC_INVOKE:
+		return tee_ioctl_invoke(ctx, uarg);
+	case TEE_IOC_CANCEL:
+		return tee_ioctl_cancel(ctx, uarg);
+	case TEE_IOC_CLOSE_SESSION:
+		return tee_ioctl_close_session(ctx, uarg);
+	case TEE_IOC_SUPPL_RECV:
+		return tee_ioctl_supp_recv(ctx, uarg);
+	case TEE_IOC_SUPPL_SEND:
+		return tee_ioctl_supp_send(ctx, uarg);
+	default:
+		return -EINVAL;
+	}
+}
+
+static const struct file_operations tee_fops = {
+	.owner = THIS_MODULE,
+	.open = tee_open,
+	.release = tee_release,
+	.unlocked_ioctl = tee_ioctl,
+	.compat_ioctl = tee_ioctl,
+};
+
+static void tee_release_device(struct device *dev)
+{
+	struct tee_device *teedev = container_of(dev, struct tee_device, dev);
+
+	spin_lock(&driver_lock);
+	clear_bit(teedev->id, dev_mask);
+	spin_unlock(&driver_lock);
+	mutex_destroy(&teedev->mutex);
+	kfree(teedev);
+}
+
+/**
+ * tee_device_alloc() - Allocate a new struct tee_device instance
+ * @teedesc:	Descriptor for this driver
+ * @dev:	Parent device for this device
+ * @pool:	Shared memory pool, NULL if not used
+ * @driver_data: Private driver data for this device
+ *
+ * Allocates a new struct tee_device instance. The device is
+ * removed by tee_device_unregister().
+ *
+ * @returns a pointer to a 'struct tee_device' or an ERR_PTR on failure
+ */
+struct tee_device *tee_device_alloc(const struct tee_desc *teedesc,
+				    struct device *dev,
+				    struct tee_shm_pool *pool,
+				    void *driver_data)
+{
+	struct tee_device *teedev;
+	void *ret;
+	int rc;
+	int offs = 0;
+
+	if (!teedesc || !teedesc->name || !teedesc->ops ||
+	    !teedesc->ops->get_version || !teedesc->ops->open ||
+	    !teedesc->ops->release || !dev || !pool)
+		return ERR_PTR(-EINVAL);
+
+	teedev = kzalloc(sizeof(*teedev), GFP_KERNEL);
+	if (!teedev) {
+		ret = ERR_PTR(-ENOMEM);
+		goto err;
+	}
+
+	if (teedesc->flags & TEE_DESC_PRIVILEGED)
+		offs = TEE_NUM_DEVICES / 2;
+
+	spin_lock(&driver_lock);
+	teedev->id = find_next_zero_bit(dev_mask, TEE_NUM_DEVICES, offs);
+	if (teedev->id < TEE_NUM_DEVICES)
+		set_bit(teedev->id, dev_mask);
+	spin_unlock(&driver_lock);
+
+	if (teedev->id >= TEE_NUM_DEVICES) {
+		ret = ERR_PTR(-ENOMEM);
+		goto err;
+	}
+
+	snprintf(teedev->name, sizeof(teedev->name), "tee%s%d",
+		 teedesc->flags & TEE_DESC_PRIVILEGED ? "priv" : "",
+		 teedev->id - offs);
+
+	teedev->dev.class = tee_class;
+	teedev->dev.release = tee_release_device;
+	teedev->dev.parent = dev;
+
+	teedev->dev.devt = MKDEV(MAJOR(tee_devt), teedev->id);
+
+	rc = dev_set_name(&teedev->dev, "%s", teedev->name);
+	if (rc) {
+		ret = ERR_PTR(rc);
+		goto err_devt;
+	}
+
+	cdev_init(&teedev->cdev, &tee_fops);
+	teedev->cdev.owner = teedesc->owner;
+	teedev->cdev.kobj.parent = &teedev->dev.kobj;
+
+	dev_set_drvdata(&teedev->dev, driver_data);
+	device_initialize(&teedev->dev);
+
+	/* 1 as tee_device_unregister() does one final tee_device_put() */
+	teedev->num_users = 1;
+	init_completion(&teedev->c_no_users);
+	mutex_init(&teedev->mutex);
+
+	teedev->desc = teedesc;
+	teedev->pool = pool;
+
+	return teedev;
+err_devt:
+	unregister_chrdev_region(teedev->dev.devt, 1);
+err:
+	dev_err(dev, "could not register %s driver\n",
+		teedesc->flags & TEE_DESC_PRIVILEGED ? "privileged" : "client");
+	if (teedev && teedev->id < TEE_NUM_DEVICES) {
+		spin_lock(&driver_lock);
+		clear_bit(teedev->id, dev_mask);
+		spin_unlock(&driver_lock);
+	}
+	kfree(teedev);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(tee_device_alloc);
+
+static ssize_t implementation_id_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct tee_device *teedev = container_of(dev, struct tee_device, dev);
+	struct tee_ioctl_version_data vers;
+
+	teedev->desc->ops->get_version(teedev, &vers);
+	return scnprintf(buf, PAGE_SIZE, "%d\n", vers.impl_id);
+}
+static DEVICE_ATTR_RO(implementation_id);
+
+static struct attribute *tee_dev_attrs[] = {
+	&dev_attr_implementation_id.attr,
+	NULL
+};
+
+static const struct attribute_group tee_dev_group = {
+	.attrs = tee_dev_attrs,
+};
+
+/**
+ * tee_device_register() - Registers a TEE device
+ * @teedev:	Device to register
+ *
+ * tee_device_unregister() need to be called to remove the @teedev if
+ * this function fails.
+ *
+ * @returns < 0 on failure
+ */
+int tee_device_register(struct tee_device *teedev)
+{
+	int rc;
+
+	/*
+	 * If the teedev already is registered, don't do it again. It's
+	 * obviously an error to try to register twice, but if we return
+	 * an error we'll force the driver to remove the teedev.
+	 */
+	if (teedev->flags & TEE_DEVICE_FLAG_REGISTERED) {
+		dev_err(&teedev->dev, "attempt to register twice\n");
+		return 0;
+	}
+
+	rc = cdev_add(&teedev->cdev, teedev->dev.devt, 1);
+	if (rc) {
+		dev_err(&teedev->dev,
+			"unable to cdev_add() %s, major %d, minor %d, err=%d\n",
+			teedev->name, MAJOR(teedev->dev.devt),
+			MINOR(teedev->dev.devt), rc);
+		return rc;
+	}
+
+	rc = device_add(&teedev->dev);
+	if (rc) {
+		dev_err(&teedev->dev,
+			"unable to device_add() %s, major %d, minor %d, err=%d\n",
+			teedev->name, MAJOR(teedev->dev.devt),
+			MINOR(teedev->dev.devt), rc);
+		goto err_device_add;
+	}
+
+	rc = sysfs_create_group(&teedev->dev.kobj, &tee_dev_group);
+	if (rc) {
+		dev_err(&teedev->dev,
+			"failed to create sysfs attributes, err=%d\n", rc);
+		goto err_sysfs_create_group;
+	}
+
+	teedev->flags |= TEE_DEVICE_FLAG_REGISTERED;
+	return 0;
+
+err_sysfs_create_group:
+	device_del(&teedev->dev);
+err_device_add:
+	cdev_del(&teedev->cdev);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(tee_device_register);
+
+void tee_device_put(struct tee_device *teedev)
+{
+	mutex_lock(&teedev->mutex);
+	/* Shouldn't put in this state */
+	if (!WARN_ON(!teedev->desc)) {
+		teedev->num_users--;
+		if (!teedev->num_users) {
+			teedev->desc = NULL;
+			complete(&teedev->c_no_users);
+		}
+	}
+	mutex_unlock(&teedev->mutex);
+}
+
+bool tee_device_get(struct tee_device *teedev)
+{
+	mutex_lock(&teedev->mutex);
+	if (!teedev->desc) {
+		mutex_unlock(&teedev->mutex);
+		return false;
+	}
+	teedev->num_users++;
+	mutex_unlock(&teedev->mutex);
+	return true;
+}
+
+/**
+ * tee_device_unregister() - Removes a TEE device
+ * @teedev:	Device to unregister
+ *
+ * This function should be called to remove the @teedev even if
+ * tee_device_register() hasn't been called yet. Does nothing if
+ * @teedev is NULL.
+ */
+void tee_device_unregister(struct tee_device *teedev)
+{
+	if (!teedev)
+		return;
+
+	if (teedev->flags & TEE_DEVICE_FLAG_REGISTERED) {
+		sysfs_remove_group(&teedev->dev.kobj, &tee_dev_group);
+		cdev_del(&teedev->cdev);
+		device_del(&teedev->dev);
+	}
+
+	tee_device_put(teedev);
+	wait_for_completion(&teedev->c_no_users);
+
+	/*
+	 * No need to take a mutex any longer now since teedev->desc was
+	 * set to NULL before teedev->c_no_users was completed.
+	 */
+
+	teedev->pool = NULL;
+
+	put_device(&teedev->dev);
+}
+EXPORT_SYMBOL_GPL(tee_device_unregister);
+
+/**
+ * tee_get_drvdata() - Return driver_data pointer
+ * @teedev:	Device containing the driver_data pointer
+ * @returns the driver_data pointer supplied to tee_register().
+ */
+void *tee_get_drvdata(struct tee_device *teedev)
+{
+	return dev_get_drvdata(&teedev->dev);
+}
+EXPORT_SYMBOL_GPL(tee_get_drvdata);
+
+static int __init tee_init(void)
+{
+	int rc;
+
+	tee_class = class_create(THIS_MODULE, "tee");
+	if (IS_ERR(tee_class)) {
+		pr_err("couldn't create class\n");
+		return PTR_ERR(tee_class);
+	}
+
+	rc = alloc_chrdev_region(&tee_devt, 0, TEE_NUM_DEVICES, "tee");
+	if (rc < 0) {
+		pr_err("failed to allocate char dev region\n");
+		class_destroy(tee_class);
+		tee_class = NULL;
+	}
+
+	return rc;
+}
+
+static void __exit tee_exit(void)
+{
+	class_destroy(tee_class);
+	tee_class = NULL;
+	unregister_chrdev_region(tee_devt, TEE_NUM_DEVICES);
+}
+
+subsys_initcall(tee_init);
+module_exit(tee_exit);
+
+MODULE_AUTHOR("Linaro");
+MODULE_DESCRIPTION("TEE Driver");
+MODULE_VERSION("1.0");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/tee/tee_private.h b/drivers/tee/tee_private.h
index 549945a..21cb6be 100644
--- a/drivers/tee/tee_private.h
+++ b/drivers/tee/tee_private.h
@@ -26,6 +26,8 @@ struct tee_device;
 /**
  * struct tee_shm - shared memory object
  * @teedev:	device used to allocate the object
+ * @ctx:	context using the object, if NULL the context is gone
+ * @link	link element
  * @paddr:	physical address of the shared memory
  * @kaddr:	virtual address of the shared memory
  * @size:	size of shared memory
@@ -35,6 +37,8 @@ struct tee_device;
  */
 struct tee_shm {
 	struct tee_device *teedev;
+	struct tee_context *ctx;
+	struct list_head link;
 	phys_addr_t paddr;
 	void *kaddr;
 	size_t size;
diff --git a/drivers/tee/tee_shm.c b/drivers/tee/tee_shm.c
index db911d0..40076af 100644
--- a/drivers/tee/tee_shm.c
+++ b/drivers/tee/tee_shm.c
@@ -27,6 +27,8 @@ static void tee_shm_release(struct tee_shm *shm)
 
 	mutex_lock(&teedev->mutex);
 	idr_remove(&teedev->idr, shm->id);
+	if (shm->ctx)
+		list_del(&shm->link);
 	mutex_unlock(&teedev->mutex);
 
 	if (shm->flags & TEE_SHM_DMA_BUF)
@@ -89,7 +91,7 @@ static struct dma_buf_ops tee_shm_dma_buf_ops = {
 
 /**
  * tee_shm_alloc() - Allocate shared memory
- * @teedev:	Driver that allocates the shared memory
+ * @ctx:	Context that allocates the shared memory
  * @size:	Requested size of shared memory
  * @flags:	Flags setting properties for the requested shared memory.
  *
@@ -101,8 +103,9 @@ static struct dma_buf_ops tee_shm_dma_buf_ops = {
  *
  * @returns a pointer to 'struct tee_shm'
  */
-struct tee_shm *tee_shm_alloc(struct tee_device *teedev, size_t size, u32 flags)
+struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags)
 {
+	struct tee_device *teedev = ctx->teedev;
 	struct tee_shm_pool_mgr *poolm = NULL;
 	struct tee_shm *shm;
 	void *ret;
@@ -136,6 +139,7 @@ struct tee_shm *tee_shm_alloc(struct tee_device *teedev, size_t size, u32 flags)
 
 	shm->flags = flags;
 	shm->teedev = teedev;
+	shm->ctx = ctx;
 	if (flags & TEE_SHM_DMA_BUF)
 		poolm = &teedev->pool->dma_buf_mgr;
 	else
@@ -169,6 +173,9 @@ struct tee_shm *tee_shm_alloc(struct tee_device *teedev, size_t size, u32 flags)
 			goto err_rem;
 		}
 	}
+	mutex_lock(&teedev->mutex);
+	list_add_tail(&shm->link, &ctx->list_shm);
+	mutex_unlock(&teedev->mutex);
 
 	return shm;
 err_rem:
@@ -305,17 +312,22 @@ EXPORT_SYMBOL_GPL(tee_shm_get_pa);
 
 /**
  * tee_shm_get_from_id() - Find shared memory object and increase referece count
- * @teedev:	Driver owning the shared mmemory
+ * @ctx:	Context owning the shared memory
  * @id:		Id of shared memory object
  * @returns a pointer to 'struct tee_shm' on success or an ERR_PTR on failure
  */
-struct tee_shm *tee_shm_get_from_id(struct tee_device *teedev, int id)
+struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id)
 {
+	struct tee_device *teedev;
 	struct tee_shm *shm;
 
+	if (!ctx)
+		return ERR_PTR(-EINVAL);
+
+	teedev = ctx->teedev;
 	mutex_lock(&teedev->mutex);
 	shm = idr_find(&teedev->idr, id);
-	if (!shm)
+	if (!shm || shm->ctx != ctx)
 		shm = ERR_PTR(-EINVAL);
 	else if (shm->flags & TEE_SHM_DMA_BUF)
 		get_dma_buf(shm->dmabuf);
diff --git a/drivers/tee/tee_shm_pool.c b/drivers/tee/tee_shm_pool.c
index ce5162b..3cb0ad0 100644
--- a/drivers/tee/tee_shm_pool.c
+++ b/drivers/tee/tee_shm_pool.c
@@ -28,6 +28,8 @@ static int pool_op_gen_alloc(struct tee_shm_pool_mgr *poolm,
 	va = gen_pool_alloc(genpool, s);
 	if (!va)
 		return -ENOMEM;
+
+	memset((void *)va, 0, s);
 	shm->kaddr = (void *)va;
 	shm->paddr = gen_pool_virt_to_phys(genpool, va);
 	shm->size = s;
@@ -99,9 +101,10 @@ static int pool_res_mem_mgr_init(struct tee_shm_pool_mgr *mgr,
  *
  * @returns pointer to a 'struct tee_shm_pool' or an ERR_PTR on failure.
  */
-struct tee_shm_pool *tee_shm_pool_alloc_res_mem(struct device *dev,
-			struct tee_shm_pool_mem_info *priv_info,
-			struct tee_shm_pool_mem_info *dmabuf_info)
+struct tee_shm_pool *
+tee_shm_pool_alloc_res_mem(struct device *dev,
+			   struct tee_shm_pool_mem_info *priv_info,
+			   struct tee_shm_pool_mem_info *dmabuf_info)
 {
 	struct tee_shm_pool *pool = NULL;
 	int ret;
diff --git a/include/linux/tee_drv.h b/include/linux/tee_drv.h
index b1d8227..9641878 100644
--- a/include/linux/tee_drv.h
+++ b/include/linux/tee_drv.h
@@ -35,10 +35,12 @@ struct tee_shm_pool;
 /**
  * struct tee_context - driver specific context on file pointer data
  * @teedev:	pointer to this drivers struct tee_device
+ * @list_shm:	List of shared memory object owned by this context
  * @data:	driver specific context data, managed by the driver
  */
 struct tee_context {
 	struct tee_device *teedev;
+	struct list_head list_shm;
 	void *data;
 };
 
@@ -121,8 +123,9 @@ struct tee_desc {
  * @returns a pointer to a 'struct tee_device' or an ERR_PTR on failure
  */
 struct tee_device *tee_device_alloc(const struct tee_desc *teedesc,
-			struct device *dev, struct tee_shm_pool *pool,
-			void *driver_data);
+				    struct device *dev,
+				    struct tee_shm_pool *pool,
+				    void *driver_data);
 
 /**
  * tee_device_register() - Registers a TEE device
@@ -146,7 +149,8 @@ int tee_device_register(struct tee_device *teedev);
 void tee_device_unregister(struct tee_device *teedev);
 
 /**
- * struct tee_shm_pool_mem_info - holds information needed to create a shared memory pool
+ * struct tee_shm_pool_mem_info - holds information needed to create a shared
+ * memory pool
  * @vaddr:	Virtual address of start of pool
  * @paddr:	Physical address of start of pool
  * @size:	Size in bytes of the pool
@@ -158,9 +162,10 @@ struct tee_shm_pool_mem_info {
 };
 
 /**
- * tee_shm_pool_alloc_res_mem() - Create a shared memory pool from reserved memory range
- * @dev:	Device allocating the pool
- * @priv_info:	Information for driver private shared memory pool
+ * tee_shm_pool_alloc_res_mem() - Create a shared memory pool from reserved
+ * memory range
+ * @dev:	 Device allocating the pool
+ * @priv_info:	 Information for driver private shared memory pool
  * @dmabuf_info: Information for dma-buf shared memory pool
  *
  * Start and end of pools will must be page aligned.
@@ -170,9 +175,10 @@ struct tee_shm_pool_mem_info {
  *
  * @returns pointer to a 'struct tee_shm_pool' or an ERR_PTR on failure.
  */
-struct tee_shm_pool *tee_shm_pool_alloc_res_mem(struct device *dev,
-			struct tee_shm_pool_mem_info *priv_info,
-			struct tee_shm_pool_mem_info *dmabuf_info);
+struct tee_shm_pool *
+tee_shm_pool_alloc_res_mem(struct device *dev,
+			   struct tee_shm_pool_mem_info *priv_info,
+			   struct tee_shm_pool_mem_info *dmabuf_info);
 
 /**
  * tee_shm_pool_free() - Free a shared memory pool
@@ -191,7 +197,7 @@ void *tee_get_drvdata(struct tee_device *teedev);
 
 /**
  * tee_shm_alloc() - Allocate shared memory
- * @teedev:	Driver that allocates the shared memory
+ * @ctx:	Context that allocates the shared memory
  * @size:	Requested size of shared memory
  * @flags:	Flags setting properties for the requested shared memory.
  *
@@ -203,8 +209,7 @@ void *tee_get_drvdata(struct tee_device *teedev);
  *
  * @returns a pointer to 'struct tee_shm'
  */
-struct tee_shm *tee_shm_alloc(struct tee_device *teedev, size_t size,
-			      u32 flags);
+struct tee_shm *tee_shm_alloc(struct tee_context *ctx, size_t size, u32 flags);
 
 /**
  * tee_shm_free() - Free shared memory
@@ -264,10 +269,10 @@ int tee_shm_get_id(struct tee_shm *shm);
 
 /**
  * tee_shm_get_from_id() - Find shared memory object and increase referece count
- * @teedev:	Driver owning the shared mmemory
+ * @ctx:	Context owning the shared memory
  * @id:		Id of shared memory object
  * @returns a pointer to 'struct tee_shm' on success or an ERR_PTR on failure
  */
-struct tee_shm *tee_shm_get_from_id(struct tee_device *teedev, int id);
+struct tee_shm *tee_shm_get_from_id(struct tee_context *ctx, int id);
 
 #endif /*__TEE_DRV_H*/
diff --git a/include/uapi/linux/tee.h b/include/uapi/linux/tee.h
index b2bcb23..3d1ed51 100644
--- a/include/uapi/linux/tee.h
+++ b/include/uapi/linux/tee.h
@@ -258,7 +258,8 @@ struct tee_ioctl_open_session_arg {
 				     struct tee_ioctl_buf_data)
 
 /**
- * struct tee_ioctl_invoke_func_arg - Invokes a function in a Trusted Application
+ * struct tee_ioctl_invoke_func_arg - Invokes a function in a Trusted
+ * Application
  * @func:	[in] Trusted Application function, specific to the TA
  * @session:	[in] Session id
  * @cancel_id:	[in] Cancellation id, a unique value to identify this request
-- 
1.7.5.4

