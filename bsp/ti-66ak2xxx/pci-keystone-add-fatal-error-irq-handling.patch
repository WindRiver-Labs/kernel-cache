From 38471ad90e32012dbb0cc6eeaf3a5dda038ac650 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Fri, 13 Sep 2013 12:15:01 -0400
Subject: [PATCH 027/256] pci: keystone: add fatal error irq handling

Currently add a error print message for fatal irq error.
Also fix a bug in clearing existing error irqs and make
the pr_xx statements consistent across the file

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit bc454df4684c1b3b5f604b52f0731e7375d0050c)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/pci/host/pcie-keystone.c |  130 +++++++++++++++++++++++++-------------
 1 files changed, 87 insertions(+), 43 deletions(-)

diff --git a/drivers/pci/host/pcie-keystone.c b/drivers/pci/host/pcie-keystone.c
index 82c3a10..91dc65c 100644
--- a/drivers/pci/host/pcie-keystone.c
+++ b/drivers/pci/host/pcie-keystone.c
@@ -59,6 +59,7 @@
 #define IB_OFFSET0			0x30c
 #define ERR_IRQ_STATUS_RAW		0x1c0
 #define ERR_IRQ_STATUS			0x1c4
+#define ERR_IRQ_ENABLE_SET		0x1c8
 #define MSI0_IRQ_STATUS			0x104
 #define MSI0_IRQ_ENABLE_SET		0x108
 #define MSI0_IRQ_ENABLE_CLR		0x10c
@@ -106,6 +107,10 @@
 #define MAX_MSI_IRQS			32
 #define MAX_MSI_HOST_IRQS		8
 
+/* error IRQ bits */
+#define ENABLE_ERR_FATAL_IRQ		BIT(1)
+#define ERR_FATAL_IRQ			BIT(1)
+
 struct keystone_pcie_info {
 	void __iomem *reg_cfg_virt;
 	/* PCIE resources */
@@ -125,6 +130,7 @@ struct keystone_pcie_info {
 	int num_msi_irqs;
 	int msi_virq_base;
 	struct irq_domain *msi_irqd;
+	int error_irq;
 };
 
 /* abort reg reference */
@@ -247,20 +253,20 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 
 	err = of_address_to_resource(node, 0, &info->cfg_resource);
 	if (err < 0) {
-		pr_err("Not found reg property\n");
+		pr_err(DRIVER_NAME ": Not found reg property\n");
 		return -EINVAL;
 	}
 
 	info->reg_cfg_virt = ioremap_nocache(info->cfg_resource.start,
 					 resource_size(&info->cfg_resource));
 	if (info->reg_cfg_virt == 0) {
-		pr_err("Couldn't map reg cfg address\n");
+		pr_err(DRIVER_NAME ": Couldn't map reg cfg address\n");
 		return -ENOMEM;
 	}
 
 	ranges = of_get_property(node, "ranges", &rlen);
 	if (ranges == NULL) {
-		pr_err("no range property\n");
+		pr_err(DRIVER_NAME ": no range property\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -281,12 +287,14 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 		res = NULL;
 		switch ((pci_space >> 24) & 0x3) {
 		case 1:         /* PCI IO space */
-			pr_info("IO 0x%016llx..0x%016llx -> 0x%016llx\n",
+			pr_info(DRIVER_NAME
+				": IO 0x%016llx..0x%016llx -> 0x%016llx\n",
 				cpu_addr, cpu_addr + size - 1, pci_addr);
 
 			/* We support only one IO range */
 			if (iono >= 1) {
-				pr_info("--> Skipped (too many) IO res!\n");
+				pr_info(DRIVER_NAME
+					":--> Skipped (too many) IO res!\n");
 				continue;
 			}
 			res = &info->io_resource;
@@ -297,20 +305,21 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 			break;
 		case 2:         /* PCI Memory space */
 		case 3:         /* PCI 64 bits Memory space */
-			pr_info("MEM 0x%016llx..0x%016llx -> 0x%016llx %s\n",
+			pr_info(DRIVER_NAME
+				": MEM 0x%016llx..0x%016llx -> 0x%016llx %s\n",
 				cpu_addr, cpu_addr + size - 1, pci_addr,
 				(pci_space & 0x40000000) ? "Prefetch" : "");
 
 			/* We support only 2 memory ranges */
 			if (memno >= 1) {
-				pr_info("--> Skipped (too many) !\n");
+				pr_info(DRIVER_NAME ":--> Skipped (too many)!\n");
 				continue;
 			}
 			res = &info->mem_resource;
 			res->flags = IORESOURCE_MEM;
 			if (pci_space & 0x40000000) {
-				pr_info("Skipped,"\
-					" don't support prefetch memory !\n");
+				pr_info(DRIVER_NAME
+				": Skipped, don't support prefetch memory!\n");
 				continue;
 			}
 
@@ -319,7 +328,7 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 			memno++;
 			break;
 		default:
-			pr_warn("Unknown resource\n");
+			pr_warn(DRIVER_NAME ": Unknown resource\n");
 			break;
 		}
 		info->num_mem_resources = memno;
@@ -333,7 +342,7 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	}
 
 	if ((memno == 0) || iono == 0) {
-		pr_err("No Mem/IO resources defined for PCIE\n");
+		pr_err(DRIVER_NAME ": No Mem/IO resources defined for PCIE\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -349,7 +358,7 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	/* Get dma-ranges property */
 	ranges = of_get_property(node, "dma-ranges", &rlen);
 	if (ranges == NULL) {
-		pr_err("no dma range property\n");
+		pr_err(DRIVER_NAME ": no dma range property\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -360,7 +369,7 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	cpu_addr = of_translate_address(node, ranges + 3);
 	size = of_read_number(ranges + pna + 3, 2);
 	if (cpu_addr == OF_BAD_ADDR || size == 0) {
-		pr_err("Invalid cpu address in dma range\n");
+		pr_err(DRIVER_NAME ": Invalid cpu address in dma range\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -368,13 +377,13 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	temp = (pci_space >> 24) & 3;
 	/* We only care about memory */
 	if (temp != 2 && temp != 3) {
-		pr_err("Invalid memory in dma range\n");
+		pr_err(DRIVER_NAME ": Invalid memory in dma range\n");
 		err = -EINVAL;
 		goto err;
 	}
 
 	if (size > MAX_DMA_RANGE) {
-		pr_err("Invalid dma range size\n");
+		pr_err(DRIVER_NAME ": Invalid dma range size\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -395,11 +404,12 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	} while (info->num_legacy_irqs < MAX_LEGACY_HOST_IRQS);
 
 	if (!info->num_legacy_irqs) {
-		pr_err("No host legacy irqs defined\n");
+		pr_err(DRIVER_NAME ": No host legacy irqs defined\n");
 		err = -EINVAL;
 		goto err;
 	}
-	pr_info("pcie - number of legacy irqs = %d\n", info->num_legacy_irqs);
+	pr_info(DRIVER_NAME
+		": pcie - number of legacy irqs = %d\n", info->num_legacy_irqs);
 
 #ifdef CONFIG_PCI_MSI
 	/*
@@ -416,7 +426,7 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	} while (info->num_msi_host_irqs < MAX_MSI_HOST_IRQS);
 
 	if (!info->num_msi_host_irqs) {
-		pr_err("No MSI host irqs defined\n");
+		pr_err(DRIVER_NAME ": No MSI host irqs defined\n");
 		err = -EINVAL;
 		goto err;
 	}
@@ -424,12 +434,21 @@ static int __init keystone_pcie_get_resources(struct device_node *node,
 	info->num_msi_irqs = info->num_msi_host_irqs * 4;
 	if (info->num_msi_irqs > MAX_MSI_IRQS) {
 		info->num_msi_irqs = MAX_MSI_IRQS;
-		pr_warn("MSI irqs exceeds maximum capacity. Set to max.\n");
+		pr_warn(DRIVER_NAME
+			": MSI irqs exceeds maximum capacity. Set to max.\n");
 	}
 
-	pr_info("pcie - number of MSI host irqs = %d, msi_irqs = %d\n",
+	pr_info(DRIVER_NAME
+		": pcie - number of MSI host irqs = %d, msi_irqs = %d\n",
 		 info->num_msi_host_irqs, info->num_msi_irqs);
 #endif
+	info->error_irq = irq_of_parse_and_map(node, info->num_legacy_irqs +
+						info->num_msi_host_irqs);
+	if (info->error_irq < 0) {
+		pr_err(DRIVER_NAME ": No error irq defined\n");
+		goto err;
+	}
+
 	return 0;
 err:
 	iounmap((void __iomem *)info->reg_cfg_virt);
@@ -441,8 +460,8 @@ static int get_and_clear_err(void __iomem *reg_virt)
 	int status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW);
 
 	if (status) {
-		/* The PCIESS interrupt status buts are "write 0 to clear" */
-		__raw_writel(~status, reg_virt + ERR_IRQ_STATUS);
+		/* The PCIESS interrupt status buts are "write 1 to clear" */
+		__raw_writel(status, reg_virt + ERR_IRQ_STATUS);
 
 		/*
 		 * Clear all errors. We are not worried here about individual
@@ -601,7 +620,7 @@ keystone_pcie_fault(unsigned long addr, unsigned int fsr,
 		regs->ARM_pc += 4;
 	}
 
-	pr_info(": Handled PCIe abort\n");
+	pr_info(DRIVER_NAME ": Handled PCIe abort\n");
 
 	return 0;
 }
@@ -647,7 +666,8 @@ static void keystone_legacy_irq_handler(unsigned int irq, struct irq_desc *desc)
 
 	if (BIT(0) & pending) {
 		virq = irq_linear_revmap(info->legacy_irqd, irq_offset);
-		pr_debug("irq: irq_offset %d, virq %d\n", irq_offset, virq);
+		pr_debug(DRIVER_NAME
+			": irq: irq_offset %d, virq %d\n", irq_offset, virq);
 		generic_handle_irq(virq);
 	}
 
@@ -717,8 +737,9 @@ static void keystone_msi_handler(unsigned int irq, struct irq_desc *desc)
 		if (BIT(src) & pending) {
 			vector = offset + (src << 3);
 			virq = irq_linear_revmap(info->msi_irqd, vector);
-			pr_debug("irq: bit %d, vector %d, virq %d\n",
-					 src, vector, virq);
+			pr_debug(DRIVER_NAME
+				": irq: bit %d, vector %d, virq %d\n",
+				 src, vector, virq);
 			generic_handle_irq(virq);
 		}
 	}
@@ -878,10 +899,25 @@ void arch_teardown_msi_irq(unsigned int irq)
 		clear_bit(pos, msi_irq_bits);
 		return;
 	}
-	pr_err("arch_teardown_msi_irq, can't find driver data\n");
+	pr_err(DRIVER_NAME
+		": arch_teardown_msi_irq, can't find driver data\n");
 }
 #endif
 
+static irqreturn_t pcie_err_irq_handler(int irq, void *reg_virt)
+{
+	int ret = IRQ_NONE, status;
+
+	status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW) & ERR_FATAL_IRQ;
+	if (status) {
+		/* The PCIESS interrupt status buts are "write 1 to clear" */
+		__raw_writel(status, reg_virt + ERR_IRQ_STATUS);
+		pr_err(DRIVER_NAME ": PCIE Fatal error detected\n");
+		ret = IRQ_HANDLED;
+	}
+	return ret;
+}
+
 /**
  * keystone_pcie_setup() - Perform PCIe system setup.
  * @nr: PCI controller index
@@ -1018,6 +1054,14 @@ static int keystone_pcie_setup(int nr, struct pci_sys_data *sys)
 	hook_fault_code(17, keystone_pcie_fault, SIGBUS, 0,
 			"external abort on linefetch");
 
+	if (request_irq(info->error_irq, pcie_err_irq_handler, 0,
+			"pcie-error-irq", reg_virt) < 0) {
+		pr_err(DRIVER_NAME ": Failed to request error irq\n");
+		goto free_resource_0;
+	}
+	/* enable the fatal error irq */
+	__raw_writel(ENABLE_ERR_FATAL_IRQ, reg_virt + ERR_IRQ_ENABLE_SET);
+
 	pr_info(DRIVER_NAME ": Doing PCI Setup...Done\n");
 	return 1;
 free_resource_0:
@@ -1202,7 +1246,7 @@ static int keystone_pci_read_config(struct pci_bus *bus, unsigned int devfn,
 	void __iomem *addr;
 
 	if (!info) {
-		pr_err("Can't get driver data\n");
+		pr_err(DRIVER_NAME ": Can't get driver data\n");
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	}
 
@@ -1241,7 +1285,7 @@ static int keystone_pci_write_config(struct pci_bus *bus, unsigned int devfn,
 	void __iomem *addr;
 
 	if (!info) {
-		pr_err("Can't get driver data\n");
+		pr_err(DRIVER_NAME ": Can't get driver data\n");
 		return PCIBIOS_DEVICE_NOT_FOUND;
 	}
 
@@ -1305,16 +1349,18 @@ static int keystone_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	struct keystone_pcie_info *info = pbus_to_kspci(dev->bus);
 
 	if (!info) {
-		pr_err("can get pci bus info\n");
+		pr_err(DRIVER_NAME ": can get pci bus info\n");
 		return -1;
 	}
 
-	pr_info("keystone_pcie_map_irq: slot %d, pin %d\n", slot, pin);
+	pr_info(DRIVER_NAME
+		": keystone_pcie_map_irq: slot %d, pin %d\n", slot, pin);
 	if (!pin || pin > info->num_legacy_irqs) {
-		pr_err("pci irq pin out of range\n");
+		pr_err(DRIVER_NAME ": pci irq pin out of range\n");
 		return -1;
 	}
-	pr_info("keystone_pcie_map_irq: legacy_irq %d\n",
+	pr_info(DRIVER_NAME
+		": keystone_pcie_map_irq: legacy_irq %d\n",
 		info->virqs[pin - 1]);
 
 	/* pin has values from 1-4 */
@@ -1344,36 +1390,35 @@ static int __init keystone_pcie_rc_init(void)
 	int err = -EINVAL, i;
 	struct clk *pcie_clk;
 
-	pr_info(DRIVER_NAME
-		": keystone_pcie_rc_init - start\n");
+	pr_info(DRIVER_NAME ": keystone_pcie_rc_init - start\n");
 
 	rc_info = kzalloc(sizeof(*rc_info), GFP_KERNEL);
 	if (!rc_info) {
-		pr_err("Memory alloc failure\n");
+		pr_err(DRIVER_NAME ": Memory alloc failure\n");
 		return -ENOMEM;
 	}
 
 	np = of_find_matching_node(NULL, keystone_pci_ids);
 	if (!np) {
-		pr_err("Unable to find pcie device node\n");
+		pr_err(DRIVER_NAME ": Unable to find pcie device node\n");
 		goto err;
 	}
 
 	/* Enable controller Power and Clock domains */
 	pcie_clk = of_clk_get(np, 0);
 	if (IS_ERR(pcie_clk)) {
-		pr_err("Failed to get PCIESS clock\n");
+		pr_err(DRIVER_NAME ": Failed to get PCIESS clock\n");
 		goto err;
 	}
 
 	if (clk_prepare_enable(pcie_clk)) {
-		pr_err("Failed to get enable clock\n");
+		pr_err(DRIVER_NAME ": Failed to get enable clock\n");
 		goto err1;
 	}
 
 	err = keystone_pcie_get_resources(np, rc_info);
 	if (err < 0) {
-		pr_err("Unable to get resources\n");
+		pr_err(DRIVER_NAME ": Unable to get resources\n");
 		goto err1;
 	}
 
@@ -1412,7 +1457,7 @@ static int __init keystone_pcie_rc_init(void)
 					rc_info->num_msi_irqs,
 					&irq_domain_simple_ops, NULL);
 		if (!rc_info->msi_irqd) {
-			pr_err(DRIVER_NAME \
+			pr_err(DRIVER_NAME
 				": failed to add irq domain for msi irqs\n");
 			goto err1;
 		}
@@ -1425,8 +1470,7 @@ static int __init keystone_pcie_rc_init(void)
 	pcibios_min_mem = 0;
 	pci_common_init(&keystone_pcie_hw);
 	abort_check_base = 0;
-	pr_info(DRIVER_NAME
-		": keystone_pcie_rc_init - end\n");
+	pr_info(DRIVER_NAME ": keystone_pcie_rc_init - end\n");
 
 	return 0;
 err1:
-- 
1.7.5.4

