From 1e73a26710ea04d12eed5caf0d1a25bed241cf28 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 20 Mar 2017 11:29:33 +0800
Subject: [PATCH] net: keystone: silence lockdep warning

netcp_priv->lock (get|free) is called by some users with interrupts enabled
and by others with interrupts disabled which leads to the following lockdep
warning:

[ INFO: possible irq lock inversion dependency detected ]
3.14.37-grsec-WR7.0.0.0_secure+ #3 Not tainted
---------------------------------------------------------
swapper/1/0 just changed the state of lock:
 (&(&mc->mca_lock)->rlock){+.-...}, at: [<c06b6dc0>] mld_ifc_timer_expire+0x1a8/0x2cc
but this lock took another, SOFTIRQ-unsafe lock in the past:
 (&(&netcp->lock)->rlock){+.+...}

and interrupts could create inverse lock ordering between them.

other info that might help us debug this:
Chain exists of:
  &(&mc->mca_lock)->rlock --> _xmit_ETHER --> &(&netcp->lock)->rlock

 Possible interrupt unsafe locking scenario:

       CPU0                    CPU1
       ----                    ----
  lock(&(&netcp->lock)->rlock);
                               local_irq_disable();
                               lock(&(&mc->mca_lock)->rlock);
                               lock(_xmit_ETHER);
  <Interrupt>
    lock(&(&mc->mca_lock)->rlock);

 *** DEADLOCK ***

So fix it by saving there flags respectively to avoid these kind calltrace.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/ti/keystone_net_core.c |   36 +++++++++++++++------------
 1 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/ti/keystone_net_core.c b/drivers/net/ethernet/ti/keystone_net_core.c
index 3ba1cb8..710610b 100644
--- a/drivers/net/ethernet/ti/keystone_net_core.c
+++ b/drivers/net/ethernet/ti/keystone_net_core.c
@@ -335,8 +335,9 @@ int netcp_register_txhook(struct netcp_priv *netcp_priv, int order,
 	struct netcp_hook_list *new_entry;
 	int before = 0;
 	int after = 0;
+	unsigned long flags;
 
-	spin_lock(&netcp_priv->lock);
+	spin_lock_irqsave(&netcp_priv->lock, flags);
 
 	old_array = netcp_priv->txhook_list_array;
 	if (old_array != NULL) {
@@ -353,7 +354,7 @@ int netcp_register_txhook(struct netcp_priv *netcp_priv, int order,
 	new_array = kmalloc((sizeof(*new_entry) * (before + after + 1)) +
 			    sizeof(void *), GFP_ATOMIC);
 	if (new_array == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOMEM;
 	}
 
@@ -373,7 +374,7 @@ int netcp_register_txhook(struct netcp_priv *netcp_priv, int order,
 	new_entry->hook_rtn = NULL;
 
 	rcu_assign_pointer(netcp_priv->txhook_list_array, new_array);
-	spin_unlock(&netcp_priv->lock);
+	spin_unlock_irqrestore(&netcp_priv->lock, flags);
 	synchronize_rcu();
 
 	if (old_array != NULL)
@@ -392,12 +393,13 @@ int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
 	struct netcp_hook_list *new_entry;
 	int before = 0;
 	int after = 0;
+	unsigned long flags;
 
-	spin_lock(&netcp_priv->lock);
+	spin_lock_irqsave(&netcp_priv->lock, flags);
 
 	old_array = netcp_priv->txhook_list_array;
 	if (old_array == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOENT;
 	}
 		
@@ -410,7 +412,7 @@ int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
 	}
 	
 	if (old_entry->hook_rtn == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOENT;
 	}
 	old_entry++;
@@ -424,7 +426,7 @@ int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
 		new_array = kmalloc((sizeof(*new_entry) * (before + after)) +
 				    sizeof(void *), GFP_ATOMIC);
 		if (new_array == NULL) {
-			spin_unlock(&netcp_priv->lock);
+			spin_unlock_irqrestore(&netcp_priv->lock, flags);
 			return -ENOMEM;
 		}
 
@@ -442,7 +444,7 @@ int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
 	}
 
 	rcu_assign_pointer(netcp_priv->txhook_list_array, new_array);
-	spin_unlock(&netcp_priv->lock);
+	spin_unlock_irqrestore(&netcp_priv->lock, flags);
 	synchronize_rcu();
 
 	kfree(old_array);
@@ -459,8 +461,9 @@ int netcp_register_rxhook(struct netcp_priv *netcp_priv, int order,
 	struct netcp_hook_list *new_entry;
 	int before = 0;
 	int after = 0;
+	unsigned long flags;
 
-	spin_lock(&netcp_priv->lock);
+	spin_lock_irqsave(&netcp_priv->lock, flags);
 
 	old_array = netcp_priv->rxhook_list_array;
 	if (old_array != NULL) {
@@ -477,7 +480,7 @@ int netcp_register_rxhook(struct netcp_priv *netcp_priv, int order,
 	new_array = kmalloc((sizeof(*new_entry) * (before + after + 1)) +
 			    sizeof(void *), GFP_ATOMIC);
 	if (new_array == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOMEM;
 	}
 
@@ -497,7 +500,7 @@ int netcp_register_rxhook(struct netcp_priv *netcp_priv, int order,
 	new_entry->hook_rtn = NULL;
 
 	rcu_assign_pointer(netcp_priv->rxhook_list_array, new_array);
-	spin_unlock(&netcp_priv->lock);
+	spin_unlock_irqrestore(&netcp_priv->lock, flags);
 	synchronize_rcu();
 
 	if (old_array != NULL)
@@ -516,12 +519,13 @@ int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
 	struct netcp_hook_list *new_entry;
 	int before = 0;
 	int after = 0;
+	unsigned long flags;
 
-	spin_lock(&netcp_priv->lock);
+	spin_lock_irqsave(&netcp_priv->lock, flags);
 
 	old_array = netcp_priv->rxhook_list_array;
 	if (old_array == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOENT;
 	}
 		
@@ -534,7 +538,7 @@ int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
 	}
 	
 	if (old_entry->hook_rtn == NULL) {
-		spin_unlock(&netcp_priv->lock);
+		spin_unlock_irqrestore(&netcp_priv->lock, flags);
 		return -ENOENT;
 	}
 	old_entry++;
@@ -548,7 +552,7 @@ int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
 		new_array = kmalloc((sizeof(*new_entry) * (before + after)) +
 				    sizeof(void *), GFP_ATOMIC);
 		if (new_array == NULL) {
-			spin_unlock(&netcp_priv->lock);
+			spin_unlock_irqrestore(&netcp_priv->lock, flags);
 			return -ENOMEM;
 		}
 
@@ -566,7 +570,7 @@ int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
 	}
 
 	rcu_assign_pointer(netcp_priv->rxhook_list_array, new_array);
-	spin_unlock(&netcp_priv->lock);
+	spin_unlock_irqrestore(&netcp_priv->lock, flags);
 	synchronize_rcu();
 
 	kfree(old_array);
-- 
1.7.5.4

