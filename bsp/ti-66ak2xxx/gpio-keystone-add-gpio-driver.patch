From 1c08b789519d7a5035af9f5a4b44ba6b98531d18 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 30 Apr 2015 13:57:38 +0800
Subject: [PATCH 193/256] gpio: keystone: add gpio driver

This patch adds GPIO driver for keystone devices. These devices
have a simple GPIO module that can have upto 4 pair of banks. Each
bank supports upto 16 pins.  Also adds irq controller support. This
registers a irq domain for the gpios and maps the same to the
host side irqs. Users of gpio will be able to set irq parent to the
gpio irq controller in the device bindings and set the interrupts
property to configure the GPIO interrupt line for use.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit efd5057b37532d8e589add1d9b09566a0313e413)

Conflicts:
	drivers/gpio/Makefile
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/gpio/gpio-keystone.txt     |   70 +++
 drivers/gpio/Kconfig                               |    7 +
 drivers/gpio/Makefile                              |    1 +
 drivers/gpio/gpio-keystone.c                       |  444 ++++++++++++++++++++
 4 files changed, 522 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/gpio/gpio-keystone.txt
 create mode 100644 drivers/gpio/gpio-keystone.c

diff --git a/Documentation/devicetree/bindings/gpio/gpio-keystone.txt b/Documentation/devicetree/bindings/gpio/gpio-keystone.txt
new file mode 100644
index 0000000..601570a
--- /dev/null
+++ b/Documentation/devicetree/bindings/gpio/gpio-keystone.txt
@@ -0,0 +1,70 @@
+Keystone GPIO controller bindings
+
+Required properties:
+- compatible : Should be "ti,keystone-gpio"
+- reg : Address and length of the register set for the device. For
+	first bank, 2 reg entries required. At index 0 specify base
+	of common registers at the beginning of gpio address space that
+	includes BINTEN. This should have a size 0x10. At second index
+	specify base address of bank0 & 1. For subsequent bank, only
+	one reg entry should be specified and should be poiting to
+	base of the bank.
+- gpio-controller : Marks the device node as a gpio controller.
+- #gpio-cells : Should be 2.  First cell specify the pin number and
+	second is optional parameter (unused).
+- clocks: phandle to clock node
+- clock-names: name of the input clock
+- interrupt-controller: Marks the device node as an interrupt controller.
+- #interrupt-cells: Should be 2. The first cell is the GPIO number.
+  The second cell bits[3:0] is used to specify trigger type:
+	1 = low-to-high edge triggered.
+	2 = high-to-low edge triggered.
+
+Note: Each GPIO port should have an alias correctly numbered in "aliases"
+node.
+
+Examples:
+
+aliases {
+        gpio0 = &gpio0;
+        gpio1 = &gpio1;
+        gpio2 = &gpio2;
+        gpio3 = &gpio3;
+        gpio4 = &gpio4;
+};
+
+gpio0: gpio@2320000 {
+	compatible = "ti,keystone-gpio";
+	reg = <0x02320000 0x10
+		0x02320010 0x28>;
+	gpio-controller;
+	#gpio-cells = <2>;
+	interrupt-controller;
+	#interrupt-cells = <2>;
+	clocks = <&clkgpio>;
+	clock-names = "gpio";
+};
+
+To use gpio pins in the driver, include the phandle to the gpio device bindings
+in the specific driver device bindings.
+
+Example:
+
+following commands in the DT bindings of the device refers to gpio0, pin 20:-
+
+	test-gpios = <&gpio0 20 0x2>;
+
+Third argument (0x2) is the flag and is currently not used. Driver typically use
+the API of_get_named_gpio_flags() to refers to the specific gpio pin and use GPIO
+libraries to configure the pin.
+
+To use the gpio pin as an interrupt line, set the interrupt-parent to
+gpio driver device node that is associated with the gpio pin and include a
+interrupts property in the driver's device bindings to specify the irq number and
+flag as
+
+	interrupts = <20 0x2>
+	interrupt-parent = <&gpio0>;
+
+where gpio pin 20 is configured as interrupt line and flag is set to high to low
+edge triggered. gpio0 node is the interrupt-parent.
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 3e72875..6d15a89 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -109,6 +109,13 @@ config GPIO_DA9055
 config GPIO_MAX730X
 	tristate
 
+config GPIO_KEYSTONE
+	bool "Keystone GPIO support"
+	default y if ARCH_KEYSTONE
+	help
+	  Say yes here to support the GPIO interface available on
+	  Keystone devices.
+
 comment "Memory mapped GPIO drivers:"
 
 config GPIO_CLPS711X
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index f1d4b83..15955c6 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_GPIO_IOP)		+= gpio-iop.o
 obj-$(CONFIG_GPIO_IT8761E)	+= gpio-it8761e.o
 obj-$(CONFIG_GPIO_JANZ_TTL)	+= gpio-janz-ttl.o
 obj-$(CONFIG_GPIO_KEMPLD)	+= gpio-kempld.o
+obj-$(CONFIG_GPIO_KEYSTONE)	+= gpio-keystone.o
 obj-$(CONFIG_ARCH_KS8695)	+= gpio-ks8695.o
 obj-$(CONFIG_GPIO_INTEL_MID)	+= gpio-intel-mid.o
 obj-$(CONFIG_GPIO_LP3943)	+= gpio-lp3943.o
diff --git a/drivers/gpio/gpio-keystone.c b/drivers/gpio/gpio-keystone.c
new file mode 100644
index 0000000..6bba4f3
--- /dev/null
+++ b/drivers/gpio/gpio-keystone.c
@@ -0,0 +1,444 @@
+/*
+ * Keystone GPIO support.
+ *
+ * Copyright (C) 2012 Texas Instruments, Inc.
+ * Written by Murali Karicheri <m-karicheri2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/clk.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <asm-generic/bug.h>
+
+#define	GPIO_MAX_BANKS		4
+#define GPIOS_PER_HW_BANK	16
+#define GPIOS_PER_BANK		(GPIOS_PER_HW_BANK * 2)
+#define GPIO_NAME		"gpio-keystone"
+#define GPIO_IRQ_EN		(BIT(1) | BIT(0))
+
+struct gpio_regs {
+	u32	dir;
+	u32	out_data;
+	u32	set_data;
+	u32	clr_data;
+	u32	in_data;
+	u32	set_rise_trig;
+	u32	clr_rise_trig;
+	u32	set_fal_trig;
+	u32	clr_fal_trig;
+	u32	intstat;
+};
+
+static struct gpio_regs gpio_bank_hw_reg = {
+	.dir		= 0x00,
+	.out_data	= 0x04,
+	.set_data	= 0x08,
+	.clr_data	= 0x0c,
+	.in_data	= 0x10,
+	.set_rise_trig	= 0x14,
+	.clr_rise_trig	= 0x18,
+	.set_fal_trig	= 0x1c,
+	.clr_fal_trig	= 0x20,
+	.intstat	= 0x24,
+};
+
+struct gpio_bank {
+	void __iomem *reg_base;
+	spinlock_t lock;
+	struct gpio_chip chip;
+	struct device *dev;
+	struct clk *clk;
+	struct gpio_regs *regs;
+	int id;
+	/* GPIO base */
+	int base;
+	/* IRQ related */
+	struct irq_domain *irqdomain;
+	/* Host side hw irq array for each of gpio line */
+	int hw_irqs[GPIOS_PER_BANK];
+};
+
+/* BINTEN is common to all banks */
+#define BINTEN_OFFSET		0x8
+
+static void __iomem *gpio_base;
+
+static const struct of_device_id keystone_gpio_dt_ids[] = {
+	{ .compatible = "ti,keystone-gpio", },
+	{ },
+};
+
+static int keystone_direction(struct gpio_bank *bank,
+			unsigned offset, bool out, int value)
+{
+	struct gpio_regs *regs = bank->regs;
+	u32 temp, mask = 1 << offset;
+	unsigned long flags;
+
+	spin_lock_irqsave(&bank->lock, flags);
+	temp = __raw_readl(bank->reg_base + regs->dir);
+	if (out) {
+		temp &= ~mask;
+		__raw_writel(mask, value ? (bank->reg_base + regs->set_data) :
+					(bank->reg_base + regs->clr_data));
+	} else {
+		temp |= mask;
+	}
+	__raw_writel(temp, bank->reg_base + regs->dir);
+	spin_unlock_irqrestore(&bank->lock, flags);
+
+	return 0;
+}
+
+static int keystone_direction_in(struct gpio_chip *chip, unsigned offset)
+{
+	struct gpio_bank *bank;
+
+	bank = container_of(chip, struct gpio_bank, chip);
+	return keystone_direction(bank, offset, false, 0);
+}
+
+static int
+keystone_direction_out(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct gpio_bank *bank;
+
+	bank = container_of(chip, struct gpio_bank, chip);
+	return keystone_direction(bank, offset, true, value);
+}
+
+static int keystone_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct gpio_bank *bank;
+	struct gpio_regs *regs;
+
+	bank = container_of(chip, struct gpio_bank, chip);
+	regs = bank->regs;
+
+	return (1 << offset) & __raw_readl(bank->reg_base + regs->in_data);
+}
+
+static void
+keystone_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct gpio_bank *bank;
+	struct gpio_regs *regs;
+
+	bank = container_of(chip, struct gpio_bank, chip);
+	regs = bank->regs;
+	__raw_writel((1 << offset), value ? (bank->reg_base + regs->set_data) :
+				(bank->reg_base + regs->clr_data));
+};
+
+static inline int keystone_hwirq_to_gpio(struct gpio_bank *bank, int hwirq)
+{
+	int gpio;
+
+	/* This may need change if Host side IRQs are not contiguous */
+	if (hwirq < bank->hw_irqs[0])
+		return -EINVAL;
+
+	gpio = hwirq - bank->hw_irqs[0];
+	if (gpio >= GPIOS_PER_BANK)
+		return -EINVAL;
+
+	return gpio;
+}
+
+static void keystone_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct gpio_bank *bank = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct gpio_regs *regs = bank->regs;
+	u32 mask = 0xffff, status;
+	int gpio, virq;
+
+	gpio = keystone_hwirq_to_gpio(bank, irq);
+	if (gpio < 0)
+		return;
+
+	if (gpio >= GPIOS_PER_HW_BANK)
+		mask <<= 16;
+
+	/* temporarily mask (level sensitive) parent IRQ */
+	chip->irq_mask(&desc->irq_data);
+	chip->irq_ack(&desc->irq_data);
+
+	status = __raw_readl(bank->reg_base + regs->intstat) & mask;
+	if (status) {
+		__raw_writel(status, bank->reg_base + regs->intstat);
+		virq = irq_linear_revmap(bank->irqdomain, gpio);
+		generic_handle_irq(virq);
+	}
+	chip->irq_unmask(&desc->irq_data);
+}
+
+static int keystone_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
+
+	if (bank->irqdomain && offset < GPIOS_PER_BANK)
+		return irq_linear_revmap(bank->irqdomain, offset);
+	else
+		return -ENXIO;
+}
+
+static void keystone_setup_irq(struct gpio_bank *bank)
+{
+	u32 val = 3 << bank->id;
+	int hw_irq;
+
+	for (hw_irq = 0; hw_irq < GPIOS_PER_BANK; hw_irq++) {
+		irq_set_handler_data(bank->hw_irqs[hw_irq], bank);
+		irq_set_chained_handler(bank->hw_irqs[hw_irq],
+					keystone_irq_handler);
+	}
+	__raw_writel(val, gpio_base + BINTEN_OFFSET);
+
+}
+
+static void gpio_irq_disable(struct irq_data *d)
+{
+	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
+	struct gpio_regs *regs = bank->regs;
+	u32 mask;
+	int gpio;
+
+	gpio = d->hwirq - bank->base;
+	mask = 1 << gpio;
+	__raw_writel(mask, bank->reg_base + regs->clr_fal_trig);
+	__raw_writel(mask, bank->reg_base + regs->clr_rise_trig);
+}
+
+static void gpio_irq_enable(struct irq_data *d)
+{
+	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
+	u32 mask, status = irqd_get_trigger_type(d);
+	struct gpio_regs *regs = bank->regs;
+	int gpio;
+
+	gpio = d->hwirq - bank->base;
+	mask = 1 << gpio;
+
+	if (status & IRQ_TYPE_EDGE_FALLING)
+		__raw_writel(mask, bank->reg_base + regs->set_fal_trig);
+	if (status & IRQ_TYPE_EDGE_RISING)
+		__raw_writel(mask, bank->reg_base + regs->set_rise_trig);
+}
+
+static int gpio_irq_type(struct irq_data *d, unsigned trigger)
+{
+	if (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct irq_chip keystone_gpio_irqchip = {
+	.name		= GPIO_NAME,
+	.irq_enable	= gpio_irq_enable,
+	.irq_disable	= gpio_irq_disable,
+	.irq_set_type	= gpio_irq_type,
+	.flags		= IRQCHIP_SET_TYPE_MASKED,
+};
+
+static int keystone_gpio_irq_map(struct irq_domain *h, unsigned int virq,
+				irq_hw_number_t hw)
+{
+	struct gpio_bank *bank = h->host_data;
+
+	irq_set_chip_data(virq, bank);
+	irq_set_chip_and_handler(virq, &keystone_gpio_irqchip,
+				handle_simple_irq);
+	set_irq_flags(virq, IRQF_VALID | IRQF_PROBE);
+	irq_set_irq_type(virq, IRQ_TYPE_NONE);
+
+	return 0;
+}
+
+static struct irq_domain_ops keystone_gpio_irq_ops = {
+	.map	= keystone_gpio_irq_map,
+	.xlate	= irq_domain_xlate_twocell,
+};
+
+static void keystone_gpio_setup(struct gpio_bank *bank)
+{
+	int i;
+
+	bank->chip.label = GPIO_NAME;
+	bank->chip.direction_input = keystone_direction_in;
+	bank->chip.get = keystone_gpio_get;
+	bank->chip.direction_output = keystone_direction_out;
+	bank->chip.set = keystone_gpio_set;
+	bank->chip.base = bank->base;
+	bank->chip.ngpio = GPIOS_PER_BANK;
+	spin_lock_init(&bank->lock);
+	bank->chip.to_irq = keystone_gpio_to_irq;
+	gpiochip_add(&bank->chip);
+
+	/* Set up all GPIO lines to be input */
+	for (i = 0; i < GPIOS_PER_BANK; i++)
+		keystone_direction_in(&bank->chip, i);
+
+	/* setup IRQ chip controller */
+	keystone_setup_irq(bank);
+}
+
+static void __iomem *keystone_gpio_iomap(struct platform_device *pdev,
+			unsigned int type, unsigned int index, int *ret)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+
+	*ret = 0;
+	/* Static mapping, never released */
+	res = platform_get_resource(pdev, type, index);
+	if (unlikely(!res)) {
+		dev_err(dev, "Invalid mem resource\n");
+		*ret = -ENODEV;
+		return NULL;
+	}
+
+	if (!devm_request_mem_region(dev, res->start, resource_size(res),
+				     pdev->name)) {
+		dev_err(dev, "Region already claimed\n");
+		*ret = -EBUSY;
+		return NULL;
+	}
+
+	return devm_ioremap(dev, res->start, resource_size(res));
+}
+
+static int keystone_gpio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct gpio_bank *bank;
+	int ret = 0, id, irq;
+
+	bank = devm_kzalloc(&pdev->dev, sizeof(struct gpio_bank), GFP_KERNEL);
+	if (!bank) {
+		dev_err(dev, "Memory alloc failed\n");
+		return -ENOMEM;
+	}
+
+	bank->clk = devm_clk_get(dev, "gpio");
+	if (IS_ERR(bank->clk)) {
+		dev_err(dev, "Error %ld getting gpio clock?\n",
+		       PTR_ERR(bank->clk));
+		return PTR_ERR(bank->clk);
+	}
+	clk_prepare_enable(bank->clk);
+
+	/* bank id */
+	id = of_alias_get_id(node, "gpio");
+	if (id < 0) {
+		ret = -EINVAL;
+		goto err_enable;
+	}
+
+	if (id == 0) {
+		/*
+		 * gpio base address is mapped for BINTEN register address
+		 * that is common across all banks
+		 */
+		gpio_base = keystone_gpio_iomap(pdev, IORESOURCE_MEM, 0, &ret);
+		if (!gpio_base) {
+			ret = -EINVAL;
+			goto err_enable;
+		}
+
+		/* map the bank base */
+		bank->reg_base = keystone_gpio_iomap(pdev, IORESOURCE_MEM, 1,
+							 &ret);
+		if (!bank->reg_base) {
+			ret = -EINVAL;
+			goto err_enable;
+		}
+	} else {
+		/*
+		 * bank0 should have been setup already and gpio_base to be
+		 * iomapped. For subsequent banks, just iomap the bank base
+		 */
+		bank->reg_base = keystone_gpio_iomap(pdev, IORESOURCE_MEM, 0,
+							&ret);
+		if (!bank->reg_base) {
+			ret = -EINVAL;
+			goto err_enable;
+		}
+	}
+	bank->id = id;
+	bank->base = id * GPIOS_PER_BANK;
+	bank->dev = dev;
+#ifdef CONFIG_OF_GPIO
+	bank->chip.of_node = of_node_get(node);
+#endif
+	platform_set_drvdata(pdev, bank);
+	bank->regs = &gpio_bank_hw_reg;
+
+	/* parse and map parent irqs directly mapped to gpio irqs */
+	for (irq = 0; irq < GPIOS_PER_BANK; irq++) {
+		bank->hw_irqs[irq] =  irq_of_parse_and_map(node, irq);
+		if (bank->hw_irqs[irq] < 0) {
+			ret = -EINVAL;
+			dev_err(dev,
+				"interrupt not defined for the irq index %d\n",
+				irq);
+			goto err_enable;
+		}
+	}
+
+	bank->irqdomain = irq_domain_add_linear(node, GPIOS_PER_BANK,
+					&keystone_gpio_irq_ops, bank);
+	if (!bank->irqdomain) {
+		dev_err(dev, "IRQ domain registration failed\n");
+		ret = -ENODEV;
+		goto err_enable;
+	}
+
+	/* Map the gpio hw irqs */
+	for (irq = 0; irq < GPIOS_PER_BANK; irq++)
+		irq_create_mapping(bank->irqdomain, irq);
+
+	keystone_gpio_setup(bank);
+
+	return ret;
+
+err_enable:
+	clk_disable_unprepare(bank->clk);
+
+	return ret;
+}
+
+static struct platform_driver keystone_gpio_driver = {
+	.driver		= {
+		.name	= GPIO_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = keystone_gpio_dt_ids,
+	},
+	.probe		= keystone_gpio_probe,
+};
+
+static int __init gpio_keystone_init(void)
+{
+	return platform_driver_register(&keystone_gpio_driver);
+}
+postcore_initcall(gpio_keystone_init);
+
+MODULE_AUTHOR("Murali Karicheri <m-karicheri2@ti.com>");
+MODULE_DESCRIPTION("Texas Instruments Keystone GPIO");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

