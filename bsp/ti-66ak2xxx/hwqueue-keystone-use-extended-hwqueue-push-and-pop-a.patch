From 87aaef75fa02d3a865d95a156dcd5267804c1c5b Mon Sep 17 00:00:00 2001
From: Sandeep Paulraj <s-paulraj@ti.com>
Date: Wed, 31 Oct 2012 13:23:47 -0400
Subject: [PATCH 071/256] hwqueue: keystone: use extended hwqueue push and pop
 api's

The keystone hardware queue push api is being updated to use the
new generic hardware queue push api. In this an argument called flags
is passed into the push api. If bit 31 is set, the lower 17 bits will
have the packet size. This packet size is then written to the
packet size register.
An extra flags argument is also passed into the keystone hardware
queue push api though at present this has no use as of now.

Also writes to the packet size and ptr_size_thresh registers are now
protected with a lock.

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
(cherry picked from commit c5295e37444eff07eac5c00e282f70b461d041e7)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.c |   18 +++++++++++++++---
 drivers/hwqueue/keystone_hwqueue.h |    6 ++++++
 2 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.c b/drivers/hwqueue/keystone_hwqueue.c
index 6b62908..cb7ed1a 100644
--- a/drivers/hwqueue/keystone_hwqueue.c
+++ b/drivers/hwqueue/keystone_hwqueue.c
@@ -215,24 +215,35 @@ khwq_find_region_by_dma(struct khwq_device *kdev, struct khwq_instance *kq,
 }
 
 static int khwq_push(struct hwqueue_instance *inst, dma_addr_t dma,
-		     unsigned size)
+		     unsigned size, unsigned flags)
 {
+	struct khwq_device *kdev = from_hdev(inst->hdev);
 	unsigned id = hwqueue_inst_to_id(inst);
 	struct khwq_qmgr_info *qmgr;
+	unsigned long irq_flags;
 	u32 val;
 
 	qmgr = khwq_find_qmgr(inst);
 	if (!qmgr)
 		return -ENODEV;
 
+	spin_lock_irqsave(&kdev->lock, irq_flags);
+
+	if (flags & HWQUEUE_HAS_PACKET_SIZE)
+		__raw_writel((flags & BITS(17)),
+			     &qmgr->reg_push[id].packet_size);
+
 	val = (u32)dma | ((size / 16) - 1);
 
 	__raw_writel(val, &qmgr->reg_push[id].ptr_size_thresh);
 
+	spin_unlock_irqrestore(&kdev->lock, irq_flags);
+
 	return 0;
 }
 
-static dma_addr_t khwq_pop(struct hwqueue_instance *inst, unsigned *size)
+static dma_addr_t khwq_pop(struct hwqueue_instance *inst, unsigned *size,
+			   unsigned flags)
 {
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
 	struct khwq_device *kdev = from_hdev(inst->hdev);
@@ -577,7 +588,7 @@ static void khwq_fill_pools(struct khwq_device *kdev)
 					  pool->name);
 				continue;
 			}
-			ret = hwqueue_push(pool->queue, dma_addr, dma_size);
+			ret = hwqueue_push(pool->queue, dma_addr, dma_size, 0);
 			WARN_ONCE(ret, "failed push to pool queue %s\n",
 				  pool->name);
 		}
@@ -1147,6 +1158,7 @@ static int khwq_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&kdev->pools);
 	INIT_LIST_HEAD(&kdev->regions);
 	INIT_LIST_HEAD(&kdev->pdsps);
+	spin_lock_init(&kdev->lock);
 
 	if (of_property_read_u32_array(node, "range", temp, 2)) {
 		dev_err(dev, "hardware queue range not specified\n");
diff --git a/drivers/hwqueue/keystone_hwqueue.h b/drivers/hwqueue/keystone_hwqueue.h
index 36fb5a7..c8903a8 100644
--- a/drivers/hwqueue/keystone_hwqueue.h
+++ b/drivers/hwqueue/keystone_hwqueue.h
@@ -21,6 +21,10 @@
 #define DESC_SIZE_MASK	0xful
 #define DESC_PTR_MASK	(~DESC_SIZE_MASK)
 
+#define HWQUEUE_HAS_PACKET_SIZE	BIT(31)
+
+#define BITS(x)		(BIT(x) - 1)
+
 #define THRESH_GTE	BIT(7)
 #define THRESH_LT	0
 
@@ -220,6 +224,8 @@ struct khwq_device {
 	struct list_head		 pools;
 	struct list_head		 pdsps;
 	struct list_head		 qmgrs;
+
+	spinlock_t			 lock;
 };
 
 struct khwq_desc {
-- 
1.7.5.4

