From 8d3c952bdfa02596dae4b1a9da3d076a30c0580e Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Thu, 15 May 2014 19:14:29 -0400
Subject: [PATCH 104/256] hwqueue: keystone: Bounds-check the output-rate
 burst size

If the second parameter of the output-rate parameter (or the sysfs
burst_size attribute) is set too large, the firmware's calculation
of the circuit credit will roll negative. This causes unwanted
packet drops.

This patch applies bounds-checking to these parameters. If the
device tree contains a bad value we cap it at the calculated
maximum value and output a warning. If a bad value is written to
sysfs, we reject it by returning an error.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit ef8faab25d31828f912db23659e3d9d166cdda54)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c |   35 ++++++++++++++++++++++---------
 drivers/hwqueue/keystone_qos.h         |    6 +++++
 2 files changed, 31 insertions(+), 10 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index d5812d0..c9e70d2 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -1508,7 +1508,9 @@ static ssize_t qnode_burst_size_store(struct khwq_qos_tree_node *qnode,
 {
 	struct khwq_qos_info *info = qnode->info;
 	int idx = qnode->sched_port_idx;
-	int error, val, field;
+	int error, field;
+	u64 cir_max;
+	u32 cir_credit;
 
 	error = kstrtouint(buf, 0, &field);
 	if (error)
@@ -1516,10 +1518,17 @@ static ssize_t qnode_burst_size_store(struct khwq_qos_tree_node *qnode,
 	
 	qnode->burst_size = field;
 
-	val = (qnode->acct == QOS_BYTE_ACCT) ?
+	error = khwq_qos_get_sched_cir_credit(info, idx, &cir_credit);
+	if (error)
+		return error;
+
+	cir_max = (qnode->acct == QOS_BYTE_ACCT) ?
 		(field << QOS_CREDITS_BYTE_SHIFT) :
 		(field << QOS_CREDITS_PACKET_SHIFT);
-	khwq_qos_set_sched_cir_max(info, idx, val, true);
+	if (cir_max > (S32_MAX - cir_credit))
+		return -EINVAL;
+
+	khwq_qos_set_sched_cir_max(info, idx, (u32)cir_max, true);
 
 	return size;
 }
@@ -2249,8 +2258,9 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 	int error, val, idx = qnode->sched_port_idx;
 	struct khwq_device *kdev = info->kdev;
 	bool sync = false;
-	int inputs, i;
+	int inputs, i, cir_credit;
 	u64 scale = 0ULL, tmp;
+	u64 cir_max;
 
 	if (!qnode->has_sched_port)
 		return 0;
@@ -2295,19 +2305,24 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 	if (WARN_ON(error))
 		return error;
 
-	val = qnode->output_rate / info->ticks_per_sec;
-	val <<= (qnode->acct == QOS_BYTE_ACCT) ?
+	cir_credit = qnode->output_rate / info->ticks_per_sec;
+	cir_credit <<= (qnode->acct == QOS_BYTE_ACCT) ?
 			QOS_CREDITS_BYTE_SHIFT :
 			QOS_CREDITS_PACKET_SHIFT;
-	error = khwq_qos_set_sched_cir_credit(info, idx, val, sync);
+	error = khwq_qos_set_sched_cir_credit(info, idx, cir_credit, sync);
 	if (WARN_ON(error))
 		return error;
 
-	val = qnode->burst_size;
-	val <<= (qnode->acct == QOS_BYTE_ACCT) ?
+	cir_max = qnode->burst_size;
+	cir_max <<= (qnode->acct == QOS_BYTE_ACCT) ?
 			QOS_CREDITS_BYTE_SHIFT :
 			QOS_CREDITS_PACKET_SHIFT;
-	error = khwq_qos_set_sched_cir_max(info, idx, val, sync);
+	if (cir_max > (S32_MAX - cir_credit)) {
+		dev_warn(kdev->dev, "node %s burst-size is too large.\n",
+				qnode->name);
+		cir_max = S32_MAX - cir_credit;
+	}
+	error = khwq_qos_set_sched_cir_max(info, idx, (u32)cir_max, sync);
 	if (WARN_ON(error))
 		return error;
 
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index 19f9b41..c8c5263 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -17,6 +17,12 @@
 #ifndef __KEYSTONE_QOS_FW_H
 #define __KEYSTONE_QOS_FW_H
 
+/* These should be kernel-wide definitions, but they're not */
+#ifndef U32_MAX
+#define	U32_MAX	((u32)(~0U))
+#define	S32_MAX	((s32)(U32_MAX >> 1))
+#endif
+
 #define QOS_MAX_INPUTS			128
 #define	QOS_MAX_CHILDREN		8
 
-- 
1.7.5.4

