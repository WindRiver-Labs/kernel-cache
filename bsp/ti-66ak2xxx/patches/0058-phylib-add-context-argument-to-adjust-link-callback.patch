From d6b4b72b4ac094fef17ec98555b4fc61e9dd8f02 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 13 Apr 2015 16:12:11 +0800
Subject: [PATCH 058/257] phylib: add context argument to adjust link callback

This patch comes from TI
  git://git.ti.com/keystone-linux/linux.git

And changes to cater for 3.14.x kernel, need to be re-considerated.

This patch introduces a context argument for the adjust link callback.  This
context information is set at phy_connect() (and its variants), and is passed
back into the adjust_link callbacks on link state change events.

Such context information is necessary when a network device has multiple
underlying ports.  Specifically, this comes into play when the netdev is
really one of the ports going into an on-chip switch of some sort.

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/phy/phy.c        | 25 ++++++++++++++++---------
 drivers/net/phy/phy_device.c | 30 ++++++++++++++++++++++++++++++
 include/linux/phy.h          | 14 ++++++++++++++
 3 files changed, 60 insertions(+), 9 deletions(-)

diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 1d56878..82301bc 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -38,6 +38,14 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_TI_KEYSTONE
+#define	phydev_adjust_link(phydev)  \
+	phydev->adjust_link(phydev->attached_dev, phydev->context);
+#else
+#define	phydev_adjust_link(phydev)  \
+	phydev->adjust_link(phydev->attached_dev);
+#endif
+
 /**
  * phy_print_status - Convenience function to print out the current phy status
  * @phydev: the phy_device struct
@@ -735,7 +743,7 @@ void phy_state_machine(struct work_struct *work)
 		if (!phydev->link) {
 			phydev->state = PHY_NOLINK;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			break;
 		}
 
@@ -748,8 +756,7 @@ void phy_state_machine(struct work_struct *work)
 		if (err > 0) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
-
+			phydev_adjust_link(phydev);
 		} else if (0 == phydev->link_timeout--) {
 			needs_aneg = 1;
 			/* If we have the magic_aneg bit, we try again */
@@ -765,7 +772,7 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->state = PHY_RUNNING;
 			netif_carrier_on(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	case PHY_FORCING:
@@ -781,7 +788,7 @@ void phy_state_machine(struct work_struct *work)
 				needs_aneg = 1;
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 		break;
 	case PHY_RUNNING:
 		/* Only register a CHANGE if we are
@@ -803,7 +810,7 @@ void phy_state_machine(struct work_struct *work)
 			netif_carrier_off(phydev->attached_dev);
 		}
 
-		phydev->adjust_link(phydev->attached_dev);
+		phydev_adjust_link(phydev);
 
 		if (phy_interrupt_is_valid(phydev))
 			err = phy_config_interrupt(phydev,
@@ -813,7 +820,7 @@ void phy_state_machine(struct work_struct *work)
 		if (phydev->link) {
 			phydev->link = 0;
 			netif_carrier_off(phydev->attached_dev);
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 			do_suspend = 1;
 		}
 		break;
@@ -845,7 +852,7 @@ void phy_state_machine(struct work_struct *work)
 				} else	{
 					phydev->state = PHY_NOLINK;
 				}
-				phydev->adjust_link(phydev->attached_dev);
+				phydev_adjust_link(phydev);
 			} else {
 				phydev->state = PHY_AN;
 				phydev->link_timeout = PHY_AN_TIMEOUT;
@@ -861,7 +868,7 @@ void phy_state_machine(struct work_struct *work)
 			} else	{
 				phydev->state = PHY_NOLINK;
 			}
-			phydev->adjust_link(phydev->attached_dev);
+			phydev_adjust_link(phydev);
 		}
 		break;
 	}
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 62ed80a7..7f734df 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -393,6 +393,7 @@ EXPORT_SYMBOL(phy_find_first);
  * phy_prepare_link - prepares the PHY layer to monitor link status
  * @phydev: target phy_device struct
  * @handler: callback function for link status change notifications
+ * @context: context information for callback handler
  *
  * Description: Tells the PHY infrastructure to handle the
  *   gory details on monitoring link status (whether through
@@ -402,9 +403,17 @@ EXPORT_SYMBOL(phy_find_first);
  *   this function.
  */
 static void phy_prepare_link(struct phy_device *phydev,
+#ifdef CONFIG_TI_KEYSTONE
+		void (*handler)(struct net_device *, void *context),
+		void *context)
+#else
 			     void (*handler)(struct net_device *))
+#endif
 {
 	phydev->adjust_link = handler;
+#ifdef CONFIG_TI_KEYSTONE
+	phydev->context = context;
+#endif
 }
 
 /**
@@ -413,10 +422,16 @@ static void phy_prepare_link(struct phy_device *phydev,
  * @phydev: the pointer to the phy device
  * @handler: callback function for state change notifications
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  */
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+#ifdef CONFIG_TI_KEYSTONE
+		       void (*handler)(struct net_device *, void *context),
+		       phy_interface_t interface, void *context)
+#else
 		       void (*handler)(struct net_device *),
 		       phy_interface_t interface)
+#endif
 {
 	int rc;
 
@@ -424,7 +439,11 @@ int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 	if (rc)
 		return rc;
 
+#ifdef CONFIG_TI_KEYSTONE
+	phy_prepare_link(phydev, handler, context);
+#else
 	phy_prepare_link(phydev, handler);
+#endif
 	phy_start_machine(phydev);
 	if (phydev->irq > 0)
 		phy_start_interrupts(phydev);
@@ -439,6 +458,7 @@ EXPORT_SYMBOL(phy_connect_direct);
  * @bus_id: the id string of the PHY device to connect
  * @handler: callback function for state change notifications
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  *
  * Description: Convenience function for connecting ethernet
  *   devices to PHY devices.  The default behavior is for
@@ -449,8 +469,13 @@ EXPORT_SYMBOL(phy_connect_direct);
  *   the desired functionality.
  */
 struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
+#ifdef CONFIG_TI_KEYSTONE
+	    void (*handler)(struct net_device *, void *context),
+	    phy_interface_t interface, void *context)
+#else
 			       void (*handler)(struct net_device *),
 			       phy_interface_t interface)
+#endif
 {
 	struct phy_device *phydev;
 	struct device *d;
@@ -466,7 +491,12 @@ struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
 	}
 	phydev = to_phy_device(d);
 
+#ifdef CONFIG_TI_KEYSTONE
+	rc = phy_connect_direct(dev, phydev, handler, interface, context);
+#else
 	rc = phy_connect_direct(dev, phydev, handler, interface);
+#endif
+
 	if (rc)
 		return ERR_PTR(rc);
 
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 565188c..7a3e414 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -362,7 +362,12 @@ struct phy_device {
 
 	struct net_device *attached_dev;
 
+#ifdef CONFIG_TI_KEYSTONE
+	void (*adjust_link)(struct net_device *dev, void *context);
+	void *context;
+#else
 	void (*adjust_link)(struct net_device *dev);
+#endif
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -590,12 +595,21 @@ struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,
 		      u32 flags, phy_interface_t interface);
+#ifdef CONFIG_TI_KEYSTONE
+int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
+		       void (*handler)(struct net_device *, void *context),
+		       phy_interface_t interface, void *context);
+struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
+	    void (*handler)(struct net_device *, void *context),
+	    phy_interface_t interface, void *context);
+#else
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
 		       void (*handler)(struct net_device *),
 		       phy_interface_t interface);
 struct phy_device *phy_connect(struct net_device *dev, const char *bus_id,
 			       void (*handler)(struct net_device *),
 			       phy_interface_t interface);
+#endif
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
-- 
2.7.4

