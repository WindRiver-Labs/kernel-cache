From 11838a74c755f8d49c639c7025b174cdb8213789 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 3 Sep 2014 12:54:18 -0400
Subject: [PATCH 151/257] spi: davinci: fix spidev ioctl failure

user space application uses spidev device (/dev/spidev.xxx) to
communicate with slave devices, for example FPGA and every time it
calls setup() API, gpio_request() call is made to setup GPIO CS if in
use. This fails for the second time and subsequent calls if GPIO is
not freed. Add a gpio_free() call to free the GPIO if already in use
to fix this. Also add a check for return value gpio_direction_output()
call and take action. In addition, call gpio_free() in
davinci_spi_cleanup() to free up the GPIO pin in use.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit 1093af2e070cf1cfeb1480b1e2b3747476f159fc)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/spi/spi-davinci.c | 27 +++++++++++++++++++++++----
 1 file changed, 23 insertions(+), 4 deletions(-)

diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c
index 8e1f4dd..0e1a883 100644
--- a/drivers/spi/spi-davinci.c
+++ b/drivers/spi/spi-davinci.c
@@ -414,8 +414,11 @@ static void davinci_spi_cleanup(struct spi_device *spi)
 	struct davinci_spi_config *spicfg = spi->controller_data;
 
 	spi->controller_data = NULL;
-	if (spi->dev.of_node)
+	if (spi->dev.of_node) {
+		if (gpio_is_valid(spi->cs_gpio))
+			gpio_free(spi->cs_gpio);
 		kfree(spicfg);
+	}
 }
 
 /**
@@ -441,14 +444,30 @@ static int davinci_spi_setup(struct spi_device *spi)
 	if (!(spi->mode & SPI_NO_CS)) {
 		if (np && (master->cs_gpios != NULL) &&
 		    (spi->cs_gpio >= 0)) {
+			/*
+			 * If we get here from spidev, setup() is called
+			 * multiple times as part of IOCTL call. So release
+			 * GPIO if we requested before
+			 */
+			gpio_free(spi->cs_gpio);
+
 			retval = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
 			if (retval) {
 				dev_err(&spi->dev,
-					"GPIO %d request failed\n", spi->cs_gpio);
-				return -ENODEV;
+					"GPIO %d request failed as CS\n",
+					spi->cs_gpio);
+				return retval;
 			}
-			gpio_direction_output(spi->cs_gpio,
+			retval = gpio_direction_output(spi->cs_gpio,
 					      !(spi->mode & SPI_CS_HIGH));
+			if (retval) {
+				dev_err(&spi->dev,
+					"GPIO %d failed to setup as CS",
+					spi->cs_gpio);
+				gpio_free(spi->cs_gpio);
+				return retval;
+			}
+
 			internal_cs = false;
 		} else if (pdata->chip_sel &&
 			   spi->chip_select < pdata->num_chipselect &&
-- 
2.7.4

