From eda385294dd8a3a1bdde009150bcbeaf760bf662 Mon Sep 17 00:00:00 2001
From: Vitaly Andrianov <vitalya@ti.com>
Date: Fri, 15 Jun 2012 13:37:32 -0400
Subject: [PATCH 153/257] mm: bootmem: use phys_addr_t for physical addresses

On a physical address extended (PAE) systems physical memory may be located
outside the first 4GB address range.  In particular, on TI Keystone devices,
all memory (including lowmem) is located outside the 4G address space. Many
functions in the bootmem.c use unsigned long as a type for physical addresses,
and this breaks badly on such PAE systems.

Even if the ARM architecture moves away from its current bootmem allocator
usage, we'd still need these changes because core parts of the kernel rely on
the bootmem APIs, even if the underlying implementation is nobootmem.

Signed-off-by: Vitaly Andrianov <vitalya@ti.com>
Signed-off-by: Cyril Chemparathy <cyril@ti.com>

 Please enter the commit message for your changes. Lines starting
(cherry picked from commit ce1fa236e1dfd3eac3c7e0cf3ce4be0b34bb3923)

Conflicts:
	include/linux/bootmem.h
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 include/linux/bootmem.h | 31 ++++++++++++++-------------
 mm/bootmem.c            | 57 +++++++++++++++++++++++++------------------------
 mm/nobootmem.c          | 32 +++++++++++++--------------
 3 files changed, 61 insertions(+), 59 deletions(-)

diff --git a/include/linux/bootmem.h b/include/linux/bootmem.h
index db51fe4..2c43eef 100644
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@ -49,10 +49,11 @@ extern unsigned long free_all_bootmem(void);
 extern void reset_all_zones_managed_pages(void);
 
 extern void free_bootmem_node(pg_data_t *pgdat,
-			      unsigned long addr,
+			      phys_addr_t addr,
 			      unsigned long size);
-extern void free_bootmem(unsigned long physaddr, unsigned long size);
-extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
+extern void __free_pages_bootmem(struct page *page, unsigned int order);
+extern void free_bootmem(phys_addr_t physaddr, unsigned long size);
+extern void free_bootmem_late(phys_addr_t physaddr, unsigned long size);
 
 /*
  * Flags for reserve_bootmem (also if CONFIG_HAVE_ARCH_BOOTMEM_NODE,
@@ -65,47 +66,47 @@ extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
 #define BOOTMEM_DEFAULT		0
 #define BOOTMEM_EXCLUSIVE	(1<<0)
 
-extern int reserve_bootmem(unsigned long addr,
+extern int reserve_bootmem(phys_addr_t addr,
 			   unsigned long size,
 			   int flags);
 extern int reserve_bootmem_node(pg_data_t *pgdat,
-				unsigned long physaddr,
+				phys_addr_t physaddr,
 				unsigned long size,
 				int flags);
 
 extern void *__alloc_bootmem(unsigned long size,
 			     unsigned long align,
-			     unsigned long goal);
+			     phys_addr_t goal);
 extern void *__alloc_bootmem_nopanic(unsigned long size,
 				     unsigned long align,
-				     unsigned long goal);
+				     phys_addr_t goal);
 extern void *__alloc_bootmem_node(pg_data_t *pgdat,
 				  unsigned long size,
 				  unsigned long align,
-				  unsigned long goal);
+				  phys_addr_t goal);
 void *__alloc_bootmem_node_high(pg_data_t *pgdat,
 				  unsigned long size,
 				  unsigned long align,
-				  unsigned long goal);
+				  phys_addr_t goal);
 extern void *__alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 				  unsigned long size,
 				  unsigned long align,
-				  unsigned long goal);
+				  phys_addr_t goal);
 void *___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 				  unsigned long size,
 				  unsigned long align,
-				  unsigned long goal,
-				  unsigned long limit);
+				  phys_addr_t goal,
+				  phys_addr_t limit);
 extern void *__alloc_bootmem_low(unsigned long size,
 				 unsigned long align,
-				 unsigned long goal);
+				 phys_addr_t goal);
 void *__alloc_bootmem_low_nopanic(unsigned long size,
 				 unsigned long align,
-				 unsigned long goal);
+				 phys_addr_t goal);
 extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
 				      unsigned long size,
 				      unsigned long align,
-				      unsigned long goal);
+				      phys_addr_t goal);
 
 #ifdef CONFIG_NO_BOOTMEM
 /* We are using top down, so it is safe to use 0 here */
diff --git a/mm/bootmem.c b/mm/bootmem.c
index 90bd350..cd7cc9a 100644
--- a/mm/bootmem.c
+++ b/mm/bootmem.c
@@ -154,7 +154,7 @@ unsigned long __init init_bootmem(unsigned long start, unsigned long pages)
  * down, but we are still initializing the system.  Pages are given directly
  * to the page allocator, no bootmem metadata is updated because it is gone.
  */
-void __init free_bootmem_late(unsigned long physaddr, unsigned long size)
+void __init free_bootmem_late(phys_addr_t physaddr, unsigned long size)
 {
 	unsigned long cursor, end;
 
@@ -388,7 +388,7 @@ static int __init mark_bootmem(unsigned long start, unsigned long end,
  *
  * The range must reside completely on the specified node.
  */
-void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
+void __init free_bootmem_node(pg_data_t *pgdat, phys_addr_t physaddr,
 			      unsigned long size)
 {
 	unsigned long start, end;
@@ -410,7 +410,7 @@ void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
  *
  * The range must be contiguous but may span node boundaries.
  */
-void __init free_bootmem(unsigned long physaddr, unsigned long size)
+void __init free_bootmem(phys_addr_t physaddr, unsigned long size)
 {
 	unsigned long start, end;
 
@@ -433,7 +433,7 @@ void __init free_bootmem(unsigned long physaddr, unsigned long size)
  *
  * The range must reside completely on the specified node.
  */
-int __init reserve_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
+int __init reserve_bootmem_node(pg_data_t *pgdat, phys_addr_t physaddr,
 				 unsigned long size, int flags)
 {
 	unsigned long start, end;
@@ -454,7 +454,7 @@ int __init reserve_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
  *
  * The range must be contiguous but may span node boundaries.
  */
-int __init reserve_bootmem(unsigned long addr, unsigned long size,
+int __init reserve_bootmem(phys_addr_t addr, unsigned long size,
 			    int flags)
 {
 	unsigned long start, end;
@@ -481,7 +481,7 @@ static unsigned long __init align_idx(struct bootmem_data *bdata,
 static unsigned long __init align_off(struct bootmem_data *bdata,
 				      unsigned long off, unsigned long align)
 {
-	unsigned long base = PFN_PHYS(bdata->node_min_pfn);
+	phys_addr_t base = PFN_PHYS(bdata->node_min_pfn);
 
 	/* Same as align_idx for byte offsets */
 
@@ -490,14 +490,14 @@ static unsigned long __init align_off(struct bootmem_data *bdata,
 
 static void * __init alloc_bootmem_bdata(struct bootmem_data *bdata,
 					unsigned long size, unsigned long align,
-					unsigned long goal, unsigned long limit)
+					phys_addr_t goal, phys_addr_t limit)
 {
 	unsigned long fallback = 0;
 	unsigned long min, max, start, sidx, midx, step;
 
-	bdebug("nid=%td size=%lx [%lu pages] align=%lx goal=%lx limit=%lx\n",
+	bdebug("nid=%td size=%lx [%lu pages] align=%lx goal=%llx limit=%llx\n",
 		bdata - bootmem_node_data, size, PAGE_ALIGN(size) >> PAGE_SHIFT,
-		align, goal, limit);
+		align, (u64)goal, (u64)limit);
 
 	BUG_ON(!size);
 	BUG_ON(align & (align - 1));
@@ -539,7 +539,8 @@ static void * __init alloc_bootmem_bdata(struct bootmem_data *bdata,
 	while (1) {
 		int merge;
 		void *region;
-		unsigned long eidx, i, start_off, end_off;
+		unsigned long eidx, i;
+		phys_addr_t   start_off, end_off;
 find_block:
 		sidx = find_next_zero_bit(bdata->node_bootmem_map, midx, sidx);
 		sidx = align_idx(bdata, sidx, step);
@@ -597,8 +598,8 @@ find_block:
 
 static void * __init alloc_bootmem_core(unsigned long size,
 					unsigned long align,
-					unsigned long goal,
-					unsigned long limit)
+					phys_addr_t goal,
+					phys_addr_t limit)
 {
 	bootmem_data_t *bdata;
 	void *region;
@@ -622,8 +623,8 @@ static void * __init alloc_bootmem_core(unsigned long size,
 
 static void * __init ___alloc_bootmem_nopanic(unsigned long size,
 					      unsigned long align,
-					      unsigned long goal,
-					      unsigned long limit)
+					      phys_addr_t goal,
+					      phys_addr_t limit)
 {
 	void *ptr;
 
@@ -653,15 +654,15 @@ restart:
  * Returns NULL on failure.
  */
 void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,
-					unsigned long goal)
+					phys_addr_t goal)
 {
-	unsigned long limit = 0;
+	phys_addr_t limit = 0;
 
 	return ___alloc_bootmem_nopanic(size, align, goal, limit);
 }
 
 static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
-					unsigned long goal, unsigned long limit)
+					phys_addr_t goal, phys_addr_t limit)
 {
 	void *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);
 
@@ -689,16 +690,16 @@ static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem(unsigned long size, unsigned long align,
-			      unsigned long goal)
+			      phys_addr_t goal)
 {
-	unsigned long limit = 0;
+	phys_addr_t limit = 0;
 
 	return ___alloc_bootmem(size, align, goal, limit);
 }
 
 void * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 				unsigned long size, unsigned long align,
-				unsigned long goal, unsigned long limit)
+				phys_addr_t goal, phys_addr_t limit)
 {
 	void *ptr;
 
@@ -727,7 +728,7 @@ again:
 }
 
 void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+				   unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
@@ -736,8 +737,8 @@ void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
 }
 
 void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
-				    unsigned long align, unsigned long goal,
-				    unsigned long limit)
+				    unsigned long align, phys_addr_t goal,
+				    phys_addr_t limit)
 {
 	void *ptr;
 
@@ -766,7 +767,7 @@ void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+				   unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
@@ -775,7 +776,7 @@ void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
 }
 
 void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+				   unsigned long align, phys_addr_t goal)
 {
 #ifdef MAX_DMA32_PFN
 	unsigned long end_pfn;
@@ -821,14 +822,14 @@ void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
-				  unsigned long goal)
+				  phys_addr_t goal)
 {
 	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
 }
 
 void * __init __alloc_bootmem_low_nopanic(unsigned long size,
 					  unsigned long align,
-					  unsigned long goal)
+					  phys_addr_t goal)
 {
 	return ___alloc_bootmem_nopanic(size, align, goal,
 					ARCH_LOW_ADDRESS_LIMIT);
@@ -850,7 +851,7 @@ void * __init __alloc_bootmem_low_nopanic(unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,
-				       unsigned long align, unsigned long goal)
+				       unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
diff --git a/mm/nobootmem.c b/mm/nobootmem.c
index f73f298..0d31b7f 100644
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@ -67,7 +67,7 @@ static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,
  * down, but we are still initializing the system.  Pages are given directly
  * to the page allocator, no bootmem metadata is updated because it is gone.
  */
-void __init free_bootmem_late(unsigned long addr, unsigned long size)
+void __init free_bootmem_late(phys_addr_t addr, unsigned long size)
 {
 	unsigned long cursor, end;
 
@@ -194,7 +194,7 @@ unsigned long __init free_all_bootmem(void)
  *
  * The range must reside completely on the specified node.
  */
-void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
+void __init free_bootmem_node(pg_data_t *pgdat, phys_addr_t physaddr,
 			      unsigned long size)
 {
 	kmemleak_free_part(__va(physaddr), size);
@@ -210,7 +210,7 @@ void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
  *
  * The range must be contiguous but may span node boundaries.
  */
-void __init free_bootmem(unsigned long addr, unsigned long size)
+void __init free_bootmem(phys_addr_t addr, unsigned long size)
 {
 	kmemleak_free_part(__va(addr), size);
 	memblock_free(addr, size);
@@ -255,7 +255,7 @@ restart:
  * Returns NULL on failure.
  */
 void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,
-					unsigned long goal)
+				      phys_addr_t goal)
 {
 	unsigned long limit = -1UL;
 
@@ -263,7 +263,7 @@ void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,
 }
 
 static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
-					unsigned long goal, unsigned long limit)
+				      phys_addr_t goal, phys_addr_t limit)
 {
 	void *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);
 
@@ -291,7 +291,7 @@ static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem(unsigned long size, unsigned long align,
-			      unsigned long goal)
+			      phys_addr_t goal)
 {
 	unsigned long limit = -1UL;
 
@@ -299,10 +299,10 @@ void * __init __alloc_bootmem(unsigned long size, unsigned long align,
 }
 
 void * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
-						   unsigned long size,
-						   unsigned long align,
-						   unsigned long goal,
-						   unsigned long limit)
+					    unsigned long size,
+					    unsigned long align,
+					    phys_addr_t goal,
+					    phys_addr_t limit)
 {
 	void *ptr;
 
@@ -326,7 +326,7 @@ again:
 }
 
 void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+					   unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
@@ -365,7 +365,7 @@ void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+				   unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
@@ -374,7 +374,7 @@ void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
 }
 
 void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,
-				   unsigned long align, unsigned long goal)
+				   unsigned long align, phys_addr_t goal)
 {
 	return __alloc_bootmem_node(pgdat, size, align, goal);
 }
@@ -397,14 +397,14 @@ void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
-				  unsigned long goal)
+				  phys_addr_t goal)
 {
 	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
 }
 
 void * __init __alloc_bootmem_low_nopanic(unsigned long size,
 					  unsigned long align,
-					  unsigned long goal)
+					  phys_addr_t goal)
 {
 	return ___alloc_bootmem_nopanic(size, align, goal,
 					ARCH_LOW_ADDRESS_LIMIT);
@@ -426,7 +426,7 @@ void * __init __alloc_bootmem_low_nopanic(unsigned long size,
  * The function panics if the request can not be satisfied.
  */
 void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,
-				       unsigned long align, unsigned long goal)
+				       unsigned long align, phys_addr_t goal)
 {
 	if (WARN_ON_ONCE(slab_is_available()))
 		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
-- 
2.7.4

