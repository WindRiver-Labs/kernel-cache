From 1b326eeb57be4a7d65faf7669b09f108c54a1465 Mon Sep 17 00:00:00 2001
From: Cyril Chemparathy <cyril@ti.com>
Date: Fri, 26 Oct 2012 23:01:36 -0400
Subject: [PATCH 115/257] lib/ktree: added tree delete and remove operations
 (cherry picked from commit ca98da0df726e2cb3618738f77b9fe283440cb10)

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 include/linux/ktree.h | 16 ++++++++++++++--
 lib/ktree.c           | 22 +++++++++++-----------
 2 files changed, 25 insertions(+), 13 deletions(-)

diff --git a/include/linux/ktree.h b/include/linux/ktree.h
index f0278bd..229674a 100644
--- a/include/linux/ktree.h
+++ b/include/linux/ktree.h
@@ -95,8 +95,20 @@ static inline void ktree_add_sibling_before(struct ktree_node *child,
 	ktree_add_child_before(pos->parent, child, pos);
 }
 
-extern void ktree_del(struct ktree_node *node);
-extern void ktree_remove(struct ktree_node *node);
+extern void ktree_del_node(struct ktree_node *node);
+extern void ktree_remove_node(struct ktree_node *node);
+
+static inline void ktree_del_tree(struct ktree *ktree)
+{
+	if (ktree->root)
+		ktree_del_node(ktree->root);
+}
+
+static inline void ktree_remove_tree(struct ktree *ktree)
+{
+	if (ktree->root)
+		ktree_remove_node(ktree->root);
+}
 
 static inline bool ktree_is_leaf(struct ktree_node *node)
 {
diff --git a/lib/ktree.c b/lib/ktree.c
index af55656..46a54c2 100644
--- a/lib/ktree.c
+++ b/lib/ktree.c
@@ -26,9 +26,9 @@
  * the next ktree_node. It then drops the lock and returns.
  *
  * There are primitives for adding and removing nodes to/from a ktree.
- * When deleting, ktree_del() will simply decrement the reference count.
+ * When deleting, ktree_del_node() will simply decrement the reference count.
  * Only when the count goes to 0 is the node removed from the list.
- * ktree_remove() will try to delete the node from the list and block until
+ * ktree_remove_node() will try to delete the node from the list and block until
  * it is actually removed. This is useful for objects (like devices) that
  * have been removed from the system and must be freed (but must wait until
  * all accessors have finished).
@@ -83,7 +83,7 @@ static void ktree_node_init(struct ktree *ktree, struct ktree_node *parent,
 void ktree_set_root(struct ktree *ktree, struct ktree_node *root)
 {
 	ktree_node_init(ktree, NULL, root);
-	ktree_del(ktree->root);
+	ktree_del_node(ktree->root);
 	ktree->root = root;
 }
 EXPORT_SYMBOL_GPL(ktree_set_root);
@@ -202,22 +202,22 @@ static void __ktree_put_node(struct ktree_node *node, bool kill)
 		ktree_node_destroy(node);
 }
 
-int __ktree_del(struct ktree_node *child, void *arg)
+int __ktree_del_node(struct ktree_node *child, void *arg)
 {
-	ktree_del(child);
+	ktree_del_node(child);
 	return 0;
 }
 
-void ktree_del(struct ktree_node *node)
+void ktree_del_node(struct ktree_node *node)
 {
 	if (node) {
-		ktree_for_each_child(node, __ktree_del, NULL);
+		ktree_for_each_child(node, __ktree_del_node, NULL);
 		__ktree_put_node(node, true);
 	}
 }
-EXPORT_SYMBOL_GPL(ktree_del);
+EXPORT_SYMBOL_GPL(ktree_del_node);
 
-void ktree_remove(struct ktree_node *node)
+void ktree_remove_node(struct ktree_node *node)
 {
 	struct ktree_waiter waiter;
 
@@ -229,7 +229,7 @@ void ktree_remove(struct ktree_node *node)
 	list_add(&waiter.list, &ktree_remove_waiters);
 	spin_unlock(&ktree_remove_lock);
 
-	ktree_del(node);
+	ktree_del_node(node);
 
 	for (;;) {
 		set_current_state(TASK_UNINTERRUPTIBLE);
@@ -239,7 +239,7 @@ void ktree_remove(struct ktree_node *node)
 	}
 	__set_current_state(TASK_RUNNING);
 }
-EXPORT_SYMBOL_GPL(ktree_remove);
+EXPORT_SYMBOL_GPL(ktree_remove_node);
 
 static struct ktree_node *ktree_get_pos(struct ktree_node *parent,
 					struct list_head *pos)
-- 
2.7.4

