From 9c7a025bafd7b4587a052558c9457ac68321121d Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Thu, 10 Jul 2014 10:33:12 -0400
Subject: [PATCH 053/257] dma: keystone: Clean up close handling, add
 dma_rxfree_flush()

This patch cleans up the handling of channel close when packets
may be still in-flight. It also resolves a possible deadlock
if chan_destroy() is called while the channel is in OPENING
state.

It also adds a new control function, dma_rxfree_flush(), to allow
higher level drivers to request the flushing of the RX Free pool
on a channel. While this is still done automatically during channel
close, there are occasions when it's desirable to do this BEFORE
closing the channel.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 3088db2a13388781b2e71371f47ef6581a30b326)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/keystone-pktdma.c | 79 +++++++++++++++++++++----------------------
 include/linux/keystone-dma.h  |  6 ++++
 2 files changed, 45 insertions(+), 40 deletions(-)

diff --git a/drivers/dma/keystone-pktdma.c b/drivers/dma/keystone-pktdma.c
index 09ea740..3b56275 100644
--- a/drivers/dma/keystone-pktdma.c
+++ b/drivers/dma/keystone-pktdma.c
@@ -211,7 +211,6 @@ struct keystone_dma_chan {
 	int				 qnum_complete;
 	int				 dest_queue_manager;
 	struct dma_notify_info		 notify_info;
-	wait_queue_head_t		 state_wait_queue;
 
 	/* registers */
 	struct reg_chan __iomem		*reg_chan;
@@ -454,7 +453,6 @@ static int chan_set_state(struct keystone_dma_chan *chan,
 
 	cur = atomic_cmpxchg(&chan->state, old, new);
 	if (likely(cur == old)) {
-		wake_up_all(&chan->state_wait_queue);
 		chan_vdbg(chan, "channel state change from %s to %s\n",
 			  chan_state_str(old), chan_state_str(new));
 		return 0;
@@ -465,27 +463,6 @@ static int chan_set_state(struct keystone_dma_chan *chan,
 	return -EINVAL;
 }
 
-static void chan_wait_state_change(struct keystone_dma_chan *chan,
-				   enum keystone_chan_state old)
-{
-	wait_event(chan->state_wait_queue, (chan_get_state(chan) != old));
-}
-
-static enum keystone_chan_state
-chan_wait_stable_state(struct keystone_dma_chan *chan)
-{
-	enum keystone_chan_state state;
-
-retry:
-	state = chan_get_state(chan);
-	if (chan_state_is_transient(state)) {
-		chan_wait_state_change(chan, state);
-		goto retry;
-	}
-
-	return state;
-}
-
 static inline bool __chan_is_alive(enum keystone_chan_state state)
 {
 	return (state == CHAN_STATE_PAUSED || state == CHAN_STATE_OPENED);
@@ -1043,14 +1020,12 @@ static void chan_purge_rxfree(struct keystone_dma_chan *chan, int index,
 
 		desc_put(chan, desc);
 	}
-
-	WARN_ON(chan->rxpools[index].pool_depth !=
-		atomic_read(&chan->rxpools[index].deficit));
 }
 
 static void chan_stop(struct keystone_dma_chan *chan)
 {
 	unsigned long end;
+	int i, deficit;
 
 	if (chan->reg_rx_flow) {
 		/* first detach fdqs, starve out the flow */
@@ -1066,7 +1041,6 @@ static void chan_stop(struct keystone_dma_chan *chan)
 
 	/* drain submitted buffers */
 	if (chan->direction == DMA_DEV_TO_MEM) {
-		int i;
 		for (i = 0; i < chan->rxpool_count; ++i)
 			chan_purge_rxfree(chan, i, chan->q_submit[i]);
 	} else
@@ -1076,10 +1050,9 @@ static void chan_stop(struct keystone_dma_chan *chan)
 	end = jiffies + msecs_to_jiffies(DMA_TIMEOUT);
 	do {
 		chan_complete(chan, chan->q_complete, DMA_SUCCESS, -1, false);
-		if (!atomic_read(&chan->n_used_descs) ||
-		    signal_pending(current))
+		if (!atomic_read(&chan->n_used_descs))
 			break;
-		schedule_timeout_interruptible(DMA_TIMEOUT / 10);
+		schedule_timeout(DMA_TIMEOUT / 10);
 	} while (time_after(end, jiffies));
 
 	/* Forget the notifier info */
@@ -1092,6 +1065,17 @@ static void chan_stop(struct keystone_dma_chan *chan)
 		__raw_writel(0, &chan->reg_rx_flow->tags);
 		__raw_writel(0, &chan->reg_rx_flow->tag_sel);
 	}
+
+	/* Check for a possible memory leak */
+	if (chan->direction == DMA_DEV_TO_MEM) {
+		for (i = 0; i < chan->rxpool_count; ++i) {
+			deficit = atomic_read(&chan->rxpools[i].deficit);
+			WARN_ONCE((chan->rxpools[i].pool_depth != deficit),
+				"chan_stop: pool %d deficit %d != depth %u\n",
+				i, deficit, chan->rxpools[i].pool_depth);
+		}
+	}
+
 	chan_vdbg(chan, "channel stopped\n");
 }
 
@@ -1261,14 +1245,11 @@ static void chan_destroy(struct dma_chan *achan)
 	struct keystone_dma_device *dma = chan->dma;
 	enum keystone_chan_state state;
 
-retry:
-	state = chan_wait_stable_state(chan);
-
-	if (state == CHAN_STATE_CLOSED)
-		return;
-
-	if (chan_set_state(chan, state, CHAN_STATE_CLOSING))
-		goto retry;
+	do {
+		state = chan_get_state(chan);
+		if (state == CHAN_STATE_CLOSED)
+			return;
+	} while (chan_set_state(chan, state, CHAN_STATE_CLOSING));
 
 	chan_vdbg(chan, "destroying channel\n");
 
@@ -1329,6 +1310,9 @@ static int chan_rxfree_refill(struct keystone_dma_chan *chan)
 {
 	int i;
 
+	if (chan->direction != DMA_DEV_TO_MEM)
+		return -EINVAL;
+
 	for (i = 0; i < chan->rxpool_count; ++i) {
 		while (atomic_dec_return(&chan->rxpools[i].deficit) >= 0) {
 			struct dma_async_tx_descriptor *adesc;
@@ -1367,6 +1351,19 @@ static int chan_rxfree_refill(struct keystone_dma_chan *chan)
 	return 0;
 }
 
+static int chan_rxfree_flush(struct keystone_dma_chan *chan)
+{
+	int i;
+
+	if (chan->direction != DMA_DEV_TO_MEM)
+		return -EINVAL;
+
+	for (i = 0; i < chan->rxpool_count; ++i)
+		chan_purge_rxfree(chan, i, chan->q_submit[i]);
+
+	return 0;
+}
+
 static int chan_keystone_config(struct keystone_dma_chan *chan,
 		struct dma_keystone_info *config)
 {
@@ -1496,6 +1493,10 @@ static int chan_control(struct dma_chan *achan, enum dma_ctrl_cmd cmd,
 		ret = chan_rxfree_refill(chan);
 		break;
 
+	case DMA_RXFREE_FLUSH:
+		ret = chan_rxfree_flush(chan);
+		break;
+
 	case DMA_GET_TX_QUEUE:
 		if (chan->direction == DMA_MEM_TO_DEV)
 			ret = chan->qnum_submit[0];
@@ -1849,8 +1850,6 @@ static int dma_init_chan(struct keystone_dma_device *dma,
 	if (!chan)
 		return -ENOMEM;
 
-	init_waitqueue_head(&chan->state_wait_queue);
-
 	chan->dma	= dma;
 	chan->direction	= DMA_NONE;
 	atomic_set(&chan->state, CHAN_STATE_CLOSED);
diff --git a/include/linux/keystone-dma.h b/include/linux/keystone-dma.h
index 66c9bd5..e117fb9 100644
--- a/include/linux/keystone-dma.h
+++ b/include/linux/keystone-dma.h
@@ -36,6 +36,7 @@ typedef void (*dma_notify_fn)(struct dma_chan *chan, void *arg);
 #define DMA_KEYSTONE_CONFIG	1004
 #define DMA_RXFREE_REFILL	1005
 #define DMA_GET_TX_QUEUE	1006
+#define DMA_RXFREE_FLUSH	1007
 
 struct dma_notify_info {
 	dma_notify_fn		 fn;
@@ -114,5 +115,10 @@ static inline int dma_rxfree_refill(struct dma_chan *chan)
 	return dmaengine_device_control(chan, DMA_RXFREE_REFILL, 0);
 }
 
+static inline int dma_rxfree_flush(struct dma_chan *chan)
+{
+	return dmaengine_device_control(chan, DMA_RXFREE_FLUSH, 0);
+}
+
 #endif /* __MACH_KEYSTONE_DMA_H__ */
 
-- 
2.7.4

