From 2c28028e96918c3c2a3f7033a5610e13ef49571b Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Mon, 2 Feb 2015 12:38:59 -0500
Subject: [PATCH 111/257] hwqueue: Fix race in disabling interrupt
 notifications

Prior to this patch, there existed a race condition between
disabling of notifications in hwqueue_disable_notifier() and
hwqueue_notify(). In this race, the delivery of an interrupt
after the notifier was marked disabled but before disabling
the interrupt would result in the interrupt service routine
not calling the notifier function. Thus the interrupt persists
which prevents or severely delays the disabling of the interrupt.

This patch synchronizes the entire notifier disable sequence
against the delivery of an interrupt notification by the use
of a spinlock. Synchronization is also provided against the
enable sequence. Note that the use of atomic operations does
not suffice in this situation.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit acd51e14f5268d363db29a450b285629fa14f75a)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/hwqueue_core.c     | 26 +++++++++++++++++++++++---
 drivers/hwqueue/hwqueue_internal.h |  3 ++-
 2 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/drivers/hwqueue/hwqueue_core.c b/drivers/hwqueue/hwqueue_core.c
index c6d3d54..204c839 100644
--- a/drivers/hwqueue/hwqueue_core.c
+++ b/drivers/hwqueue/hwqueue_core.c
@@ -134,6 +134,7 @@ int hwqueue_device_register(struct hwqueue_device *hdev)
 		setup_timer(&inst->poll_timer, __hwqueue_poll,
 			    (unsigned long)inst);
 		init_waitqueue_head(&inst->wait);
+		spin_lock_init(&inst->lock);
 	}
 
 	list_add(&hdev->list, &hwqueue_devices);
@@ -492,6 +493,7 @@ int hwqueue_enable_notifier(struct hwqueue *qh)
 	struct hwqueue_instance *inst = qh->inst;
 	struct hwqueue_device *hdev = inst->hdev;
 	bool first;
+	unsigned long flags;
 
 	if (!hwqueue_is_readable(qh))
 		return -EINVAL;
@@ -499,16 +501,21 @@ int hwqueue_enable_notifier(struct hwqueue *qh)
 	if (WARN_ON(!qh->notifier_fn))
 		return -EINVAL;
 
+	/* Protect against interrupt delivery */
+	spin_lock_irqsave(&inst->lock, flags);
+
 	/* Adjust the per handle notifier count */
 	first = (atomic_inc_return(&qh->notifier_enabled) == 1);
 	if (!first)
-		return 0; /* nothing to do */
+		goto unlock; /* nothing to do */
 
 	/* Now adjust the per instance notifier count */
 	first = (atomic_inc_return(&inst->num_notifiers) == 1);
 	if (first)
 		hdev->ops->set_notify(inst, true);
 
+unlock:
+	spin_unlock_irqrestore(&inst->lock, flags);
 	return 0;
 }
 EXPORT_SYMBOL(hwqueue_enable_notifier);
@@ -524,18 +531,24 @@ int hwqueue_disable_notifier(struct hwqueue *qh)
 	struct hwqueue_instance *inst = qh->inst;
 	struct hwqueue_device *hdev = inst->hdev;
 	bool last;
+	unsigned long flags;
 
 	if (!hwqueue_is_readable(qh))
 		return -EINVAL;
 
+	/* Protect against interrupt delivery */
+	spin_lock_irqsave(&inst->lock, flags);
+
 	last = (atomic_dec_return(&qh->notifier_enabled) == 0);
 	if (!last)
-		return 0; /* nothing to do */
+		goto unlock; /* nothing to do */
 
 	last = (atomic_dec_return(&inst->num_notifiers) == 0);
 	if (last)
 		hdev->ops->set_notify(inst, false);
 
+unlock:
+	spin_unlock_irqrestore(&inst->lock, flags);
 	return 0;
 }
 EXPORT_SYMBOL(hwqueue_disable_notifier);
@@ -619,11 +632,18 @@ EXPORT_SYMBOL(__hwqueue_pop_slow);
 void hwqueue_notify(struct hwqueue_instance *inst)
 {
 	struct hwqueue *qh;
+	unsigned long flags;
+	bool enabled;
 
 	rcu_read_lock();
 
 	for_each_handle_rcu(qh, inst) {
-		if (atomic_read(&qh->notifier_enabled) <= 0)
+		/* Synchronize against enable/disable notifier */
+		spin_lock_irqsave(&inst->lock, flags);
+		enabled = atomic_read(&qh->notifier_enabled) > 0;
+		spin_unlock_irqrestore(&inst->lock, flags);
+
+		if (!enabled)
 			continue;
 		if (WARN_ON(!qh->notifier_fn))
 			continue;
diff --git a/drivers/hwqueue/hwqueue_internal.h b/drivers/hwqueue/hwqueue_internal.h
index ce99b54..35d4f46 100644
--- a/drivers/hwqueue/hwqueue_internal.h
+++ b/drivers/hwqueue/hwqueue_internal.h
@@ -27,12 +27,13 @@
 struct hwqueue_instance {
 	struct list_head	 handles;
 	struct hwqueue_device	*hdev;
+	spinlock_t		 lock;
 	struct timer_list	 poll_timer;
 	wait_queue_head_t	 wait;
 	void			*priv;
-	char			 name[32];
 	atomic_t		 num_notifiers;
 	struct hwqueue_inst_ops	*ops;
+	char			 name[32];
 };
 
 struct hwqueue_device_ops {
-- 
2.7.4

