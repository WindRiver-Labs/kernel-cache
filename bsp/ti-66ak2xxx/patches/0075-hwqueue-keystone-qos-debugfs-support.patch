From 21141735e9110cafb35f4cb3e06bd89d231b369e Mon Sep 17 00:00:00 2001
From: Sandeep Paulraj <s-paulraj@ti.com>
Date: Wed, 28 Nov 2012 09:26:47 -0500
Subject: [PATCH 075/257] hwqueue: keystone: qos debugfs support

This commit adds debugfs support for qos

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
(cherry picked from commit b2657216ec75562662018804f5db10d15ce51e9a)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c | 479 ++++++++++++++++++++++++++++++++-
 drivers/hwqueue/keystone_qos.h         |   8 +-
 2 files changed, 485 insertions(+), 2 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index 9662992..5cb55c8 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -22,6 +22,7 @@
 #include <linux/bitops.h>
 #include <linux/slab.h>
 #include <linux/delay.h>
+#include <linux/debugfs.h>
 #include <linux/spinlock.h>
 #include <linux/hwqueue.h>
 #include <linux/ktree.h>
@@ -2294,6 +2295,12 @@ static int khwq_qos_tree_start_drop_queue(struct khwq_qos_info *info,
 		if (WARN_ON(error))
 			return error;
 
+		error = khwq_qos_set_drop_q_stat_irq_pair_idx(kdev, idx,
+							      1, sync);
+		if (WARN_ON(error))
+			return error;
+
+
 		error = khwq_qos_set_drop_q_valid(kdev, idx, 1, sync);
 		if (WARN_ON(error))
 			return error;
@@ -2404,6 +2411,11 @@ static int khwq_qos_stop_drop_queues(struct khwq_qos_info *info)
 			if (WARN_ON(error))
 				return error;
 
+			error = khwq_qos_set_drop_q_stat_irq_pair_idx(kdev, idx,
+								      0, false);
+			if (WARN_ON(error))
+			return error;
+
 			error = khwq_qos_set_drop_q_out_prof_idx(kdev, idx, 0,
 								 false);
 			if (WARN_ON(error))
@@ -2653,6 +2665,440 @@ int khwq_qos_start(struct khwq_qos_info *info)
 	return error;
 }
 
+static ssize_t khwq_qos_out_prof_read(struct file *filp, char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct khwq_qos_info *info = filp->private_data;
+	struct khwq_device *kdev = info->kdev;
+	struct khwq_qos_shadow *shadow = &info->shadows[QOS_DROP_OUT_PROF];
+	struct khwq_pdsp_info *pdsp;
+	int i, buf_len = 8192, idx, error;
+	unsigned long flags;
+	size_t len = 0;
+	ssize_t ret;
+	char *buf;
+	u32 temp;
+
+	if (*ppos != 0)
+		return 0;
+	if (count < sizeof(buf))
+		return -ENOSPC;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	pdsp = info->pdsp;
+
+	for (i = shadow->start; i < (shadow->start + shadow->count); i++) {
+		if (!test_bit(i, shadow->avail)) {
+			idx = khwq_qos_make_id(pdsp->id, i);
+
+			spin_lock_irqsave(&info->lock, flags);
+
+			len += snprintf(buf + len, buf_len - len,
+					"output profile %d ", i);
+
+			error = khwq_qos_get_drop_out_queue_number(kdev, idx,
+								   &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"output q # %d ", temp);
+
+			error = khwq_qos_get_drop_out_red_prob(kdev, idx,
+							       &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"red prob %d ", temp);
+
+			error = khwq_qos_get_drop_out_enable(kdev, idx, &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"enable %d ", temp);
+
+			error = khwq_qos_get_drop_out_cfg_prof_idx(kdev, idx,
+								   &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"config profile %d ", temp);
+
+			error = khwq_qos_get_drop_out_avg_depth(kdev, idx,
+								   &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"average q depth %d\n", temp);
+
+			spin_unlock_irqrestore(&info->lock, flags);
+		}
+	}
+
+free:
+	ret = simple_read_from_buffer(buffer, len, ppos, buf, buf_len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t khwq_qos_q_cfg_read(struct file *filp, char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct khwq_qos_info *info = filp->private_data;
+	struct khwq_device *kdev = info->kdev;
+	struct khwq_qos_shadow *shadow = &info->shadows[QOS_DROP_QUEUE_CFG];
+	struct khwq_pdsp_info *pdsp;
+	int i, buf_len = 4096, idx, error;
+	unsigned long flags;
+	size_t len = 0;
+	ssize_t ret;
+	char *buf;
+	u32 temp;
+
+	if (*ppos != 0)
+		return 0;
+	if (count < sizeof(buf))
+		return -ENOSPC;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	pdsp = info->pdsp;
+
+	for (i = shadow->start; i < (shadow->start + shadow->count); i++) {
+		if (!test_bit(i, shadow->avail)) {
+			idx = khwq_qos_make_id(pdsp->id, i);
+
+			spin_lock_irqsave(&info->lock, flags);
+
+			len += snprintf(buf + len, buf_len - len,
+					"q cfg %d ", i);
+
+			error = khwq_qos_get_drop_q_stat_irq_pair_idx(kdev, idx,
+								      &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"stats q pair # %d ", temp);
+
+			error = khwq_qos_get_drop_q_stat_blk_idx(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"block %d ", temp);
+
+			error = khwq_qos_get_drop_q_out_prof_idx(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"out prof %d\n", temp);
+
+			spin_unlock_irqrestore(&info->lock, flags);
+		}
+	}
+
+free:
+	ret = simple_read_from_buffer(buffer, len, ppos, buf, buf_len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t khwq_qos_drop_prof_read(struct file *filp, char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct khwq_qos_info *info = filp->private_data;
+	struct khwq_device *kdev = info->kdev;
+	struct khwq_qos_shadow *shadow = &info->shadows[QOS_DROP_CFG_PROF];
+	struct khwq_pdsp_info *pdsp;
+	int i, buf_len = 4096, idx, error;
+	unsigned long flags;
+	size_t len = 0;
+	ssize_t ret;
+	char *buf;
+	u32 temp;
+
+	if (*ppos != 0)
+		return 0;
+	if (count < sizeof(buf))
+		return -ENOSPC;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	pdsp = info->pdsp;
+
+	for (i = shadow->start; i < (shadow->start + shadow->count); i++) {
+		if (!test_bit(i, shadow->avail)) {
+			idx = khwq_qos_make_id(pdsp->id, i);
+
+			spin_lock_irqsave(&info->lock, flags);
+
+			len += snprintf(buf + len, buf_len - len,
+					"drop cfg prof %d ", i);
+
+			error = khwq_qos_get_drop_cfg_unit_flags(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"unit flags %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_mode(kdev, idx, &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"mode %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_time_const(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"time const %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_tail_thresh(kdev, idx,
+								  &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"tail thresh %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_red_low(kdev, idx, &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"red low %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_red_high(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"red high %d ", temp);
+
+			error = khwq_qos_get_drop_cfg_thresh_recip(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"thresh recip %d\n", temp);
+
+			spin_unlock_irqrestore(&info->lock, flags);
+		}
+	}
+
+free:
+	ret = simple_read_from_buffer(buffer, len, ppos, buf, buf_len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t khwq_qos_sched_port_read(struct file *filp, char __user *buffer,
+				   size_t count, loff_t *ppos)
+{
+	struct khwq_qos_info *info = filp->private_data;
+	struct khwq_device *kdev = info->kdev;
+	struct khwq_qos_shadow *shadow = &info->shadows[QOS_SCHED_PORT_CFG];
+	struct khwq_pdsp_info *pdsp;
+	int i, j, buf_len = 4096, idx, error;
+	unsigned long flags;
+	size_t len = 0;
+	ssize_t ret;
+	char *buf;
+	u32 temp, queues;
+
+	if (*ppos != 0)
+		return 0;
+	if (count < sizeof(buf))
+		return -ENOSPC;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	pdsp = info->pdsp;
+
+	for (i = shadow->start; i < (shadow->start + shadow->count); i++) {
+		if (!test_bit(i, shadow->avail)) {
+			idx = khwq_qos_make_id(pdsp->id, i);
+
+			spin_lock_irqsave(&info->lock, flags);
+
+			len += snprintf(buf + len, buf_len - len,
+					"port %d\n", i);
+
+			error = khwq_qos_get_sched_unit_flags(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"unit flags %d ", temp);
+
+			error = khwq_qos_get_sched_group_count(kdev, idx,
+							       &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"group # %d ", temp);
+
+			error = khwq_qos_get_sched_out_queue(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"out q %d ", temp);
+
+			error = khwq_qos_get_sched_overhead_bytes(kdev, idx,
+								  &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"overhead bytes %d ", temp);
+
+			error = khwq_qos_get_sched_out_throttle(kdev, idx,
+								&temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"throttle thresh %d ", temp);
+
+			error = khwq_qos_get_sched_cir_credit(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"cir credit %d ", temp);
+
+			error = khwq_qos_get_sched_cir_max(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"cir max %d\n", temp);
+
+			error = khwq_qos_get_sched_total_q_count(kdev, idx,
+								 &queues);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"total q's %d ", queues);
+
+			error = khwq_qos_get_sched_sp_q_count(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"sp q's %d ", temp);
+
+			error = khwq_qos_get_sched_wrr_q_count(kdev, idx,
+								 &temp);
+			if (WARN_ON(error))
+				goto free;
+
+			len += snprintf(buf + len, buf_len - len,
+					"wrr q's %d\n", temp);
+
+			for (j = 0; j < queues; j++) {
+				len += snprintf(buf + len, buf_len - len,
+					"queue %d ", j);
+
+				error = khwq_qos_get_sched_cong_thresh(kdev,
+								       idx, j,
+								       &temp);
+				if (WARN_ON(error))
+					return error;
+
+				len += snprintf(buf + len, buf_len - len,
+					"cong thresh %d ", temp);
+
+				error = khwq_qos_get_sched_wrr_credit(kdev, idx,
+								      j, &temp);
+				if (WARN_ON(error))
+					return error;
+
+				len += snprintf(buf + len, buf_len - len,
+					"wrr credit %d\n", temp);
+			}
+
+			len += snprintf(buf + len, buf_len - len, "\n");
+
+			spin_unlock_irqrestore(&info->lock, flags);
+		}
+	}
+free:
+	ret = simple_read_from_buffer(buffer, len, ppos, buf, buf_len);
+	kfree(buf);
+
+	return ret;
+}
+
+static int khwq_qos_debufs_generic_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static const struct file_operations khwq_qos_out_profs_fops = {
+	.owner	= THIS_MODULE,
+	.open	= khwq_qos_debufs_generic_open,
+	.read	= khwq_qos_out_prof_read,
+	.llseek	= default_llseek,
+};
+
+static const struct file_operations khwq_qos_q_cfg_fops = {
+	.owner	= THIS_MODULE,
+	.open	= khwq_qos_debufs_generic_open,
+	.read	= khwq_qos_q_cfg_read,
+	.llseek	= default_llseek,
+};
+
+static const struct file_operations khwq_qos_drop_prof_fops = {
+	.owner	= THIS_MODULE,
+	.open	= khwq_qos_debufs_generic_open,
+	.read	= khwq_qos_drop_prof_read,
+	.llseek	= default_llseek,
+};
+
+static const struct file_operations khwq_qos_sched_port_fops = {
+	.owner	= THIS_MODULE,
+	.open	= khwq_qos_debufs_generic_open,
+	.read	= khwq_qos_sched_port_read,
+	.llseek	= default_llseek,
+};
+
 static int khwq_qos_open_queue(struct khwq_range_info *range,
 			       struct hwqueue_instance *inst, unsigned flags)
 {
@@ -2668,6 +3114,27 @@ static int khwq_qos_open_queue(struct khwq_range_info *range,
 		error = khwq_qos_start(info);
 		if (error)
 			dev_err(kdev->dev, "failed to start qos\n");
+
+		info->port_configs = debugfs_create_file("sched_ports", S_IRUSR,
+							 info->root_dir, info,
+							 &khwq_qos_sched_port_fops);
+
+		info->out_profiles = debugfs_create_file("out_profiles",
+							 S_IRUSR,
+							 info->root_dir, info,
+							 &khwq_qos_out_profs_fops);
+	
+		info->queue_configs = debugfs_create_file("queue_configs",
+							  S_IRUSR,
+							  info->root_dir, info,
+							  &khwq_qos_q_cfg_fops);
+
+		info->config_profiles = debugfs_create_file("config_profiles",
+							    S_IRUSR,
+							    info->root_dir,
+							    info,
+							    &khwq_qos_drop_prof_fops);
+
 	}
 
 	return error;
@@ -2715,6 +3182,11 @@ static int khwq_qos_close_queue(struct khwq_range_info *range,
 		error = khwq_qos_stop(info);
 		if (error)
 			dev_err(kdev->dev, "failed to stop qos\n");
+
+		debugfs_remove(info->port_configs);
+		debugfs_remove(info->queue_configs);
+		debugfs_remove(info->out_profiles);
+		debugfs_remove(info->config_profiles);
 	}
 
 	return error;
@@ -2732,6 +3204,8 @@ static int khwq_qos_free_range(struct khwq_range_info *range)
 	pdsp = info->pdsp;
 	kdev = info->kdev;
 
+	debugfs_remove_recursive(info->root_dir);
+
 	shadow = &info->shadows[QOS_SCHED_PORT_CFG];
 	for (i = shadow->start; i < (shadow->start + shadow->count); i++)
 		if (!test_bit(i, shadow->avail)) {
@@ -2849,8 +3323,11 @@ static int khwq_qos_init_range(struct khwq_range_info *range)
 		goto fail;
 	}
 
-	return 0;
+	info->root_dir = debugfs_create_dir("qos", NULL);
+	if (!info->root_dir)
+		goto fail;
 
+	return 0;
 fail:
 	spin_unlock_bh(&info->lock);
 	return error;
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index acc3489..d44ea48 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -147,6 +147,12 @@ struct khwq_qos_info {
 	struct list_head		 drop_policies;
 	struct list_head		 stats_classes;
 	struct khwq_qos_drop_policy	*default_drop_policy;
+	
+	struct dentry			*root_dir;
+	struct dentry			*config_profiles;
+	struct dentry			*out_profiles;
+	struct dentry			*queue_configs;
+	struct dentry			*port_configs;
 
 	int	 sched_port_queue_base,
 		 drop_sched_queue_base,
@@ -361,7 +367,7 @@ DEFINE_FIELD_U32(QOS_DROP_OUT_PROF, drop_out_avg_depth,    0x08,  0, 32)
 
 DEFINE_FIELD_U32(QOS_DROP_QUEUE_CFG, drop_q_out_prof_idx,  0x00,  0,  8)
 DEFINE_FIELD_U32(QOS_DROP_QUEUE_CFG, drop_q_stat_blk_idx,  0x00,  8,  8)
-DEFINE_FIELD_U32(QOS_DROP_QUEUE_CFG, drop_q_stat_irq,      0x00, 16,  8)
+DEFINE_FIELD_U32(QOS_DROP_QUEUE_CFG, drop_q_stat_irq_pair_idx, 0x00, 16,  8)
 DEFINE_FIELD_U32(QOS_DROP_QUEUE_CFG, drop_q_valid,         0x00, 24,  8)
 
 DEFINE_FIELD_U32(QOS_SCHED_PORT_CFG, sched_unit_flags,     0x00,  0,  8)
-- 
2.7.4

