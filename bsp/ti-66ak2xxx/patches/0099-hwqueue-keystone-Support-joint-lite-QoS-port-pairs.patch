From 270a2d895b886ca2ac464243127e3006c6db1aa5 Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Wed, 14 May 2014 17:55:42 -0400
Subject: [PATCH 099/257] hwqueue: keystone: Support joint-lite QoS port pairs

QoS firmware 2.0.1.7 supports the concept of "joint" ports, where
an even/odd pair of lite ports work as if they are a single double-
wide port, managing 8 instead of 4 input queues.

This patch adds configuration support for this to the Hardware
Queue QoS module.

No new configuration keywords are necessary to take advantage of
this feature. Configuring a WRR or SP port with more than 4 inputs
will automatically result in the allocation of a joint port pair.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit dc99a6229849356d6fdd7e2ef7ba4496a0bf34cf)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c | 173 ++++++++++++++++++++++++++++++---
 drivers/hwqueue/keystone_qos.h         |   9 +-
 2 files changed, 166 insertions(+), 16 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index 8e54cf8..5436ae0 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -938,6 +938,49 @@ static int khwq_qos_free_drop_queue(struct khwq_qos_info *info, int idx)
 	return khwq_qos_free(info, QOS_DROP_QUEUE_CFG, idx);
 }
 
+#define	is_even(x)	(((x) & 1) == 0)
+
+static inline int khwq_qos_alloc_sched_port(struct khwq_qos_info *info,
+			  int parent_port_idx, bool port_pair)
+{
+	struct khwq_pdsp_info *pdsp = info->pdsp;
+	struct khwq_qos_shadow *shadow = &info->shadows[QOS_SCHED_PORT_CFG];
+	int parent_idx, idx, idx_odd;
+
+	parent_idx = (parent_port_idx < 0) ? shadow->count :
+			khwq_qos_id_to_idx(parent_port_idx);
+
+	spin_lock_bh(&info->lock);
+
+	idx = find_last_bit(shadow->avail, parent_idx);
+	if (idx >= parent_idx)
+		goto fail;
+
+	if (port_pair) {
+		do {
+			idx_odd = idx;
+			idx = find_last_bit(shadow->avail, idx_odd);
+			if (idx >= idx_odd)
+				goto fail;
+		} while (!is_even(idx) || (idx_odd != (idx + 1)));
+		clear_bit(idx_odd, shadow->avail);
+	}
+
+	clear_bit(idx, shadow->avail);
+	spin_unlock_bh(&info->lock);
+	return khwq_qos_make_id(pdsp->id, idx);
+
+fail:
+	spin_unlock_bh(&info->lock);
+	dev_err(info->kdev->dev, "QoS port allocation failure\n");
+	return -ENOSPC;
+}
+
+static int khwq_qos_free_sched_port(struct khwq_qos_info *info, int idx)
+{
+	return khwq_qos_free(info, QOS_SCHED_PORT_CFG, idx);
+}
+
 static int khwq_qos_sched_port_enable(struct khwq_qos_shadow *shadow, int idx,
 				       bool enable)
 {
@@ -966,7 +1009,7 @@ static int khwq_qos_sched_port_enable(struct khwq_qos_shadow *shadow, int idx,
 				 shadow->name, idx);
 		}
 		if (!enable && !test_bit(idx, shadow->running)) {
-			dev_warn(kdev->dev, "forced disable on halted %s %d\n",
+			dev_dbg(kdev->dev, "forced disable on halted %s %d\n",
 				 shadow->name, idx);
 		}
 		command = (QOS_CMD_ENABLE_PORT			|
@@ -1715,7 +1758,7 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 {
 	struct khwq_qos_tree_node *qnode;
 	struct khwq_device *kdev = info->kdev;
-	int length, i, error = 0, elements;
+	int length, i, error = 0, elements, num_children;
 	struct device_node *child;
 	bool has_children;
 	const char *name;
@@ -1990,7 +2033,9 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	else
 		ktree_add_child_last(&parent->node, &qnode->node);
 
+	num_children = 0;
 	for_each_child_of_node(node, child) {
+		++num_children;
 		error = khwq_qos_tree_parse(info, child, qnode);
 		if (error)
 			goto error_destroy;
@@ -2004,6 +2049,27 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 			goto error_destroy;
 	}
 
+	if (num_children <= info->inputs_per_port)
+		qnode->is_joint_port = false;
+	else {
+		if (num_children <= (info->inputs_per_port * 2)) {
+			qnode->is_joint_port = true;
+			dev_dbg(kdev->dev, "node %s needs a joint port\n",
+				 qnode->name);
+		} else {
+			dev_err(kdev->dev, "node %s has too many children\n",
+				qnode->name);
+			error = -EINVAL;
+			goto error_destroy;
+		}
+	}
+	if (qnode->is_joint_port && qnode->type == QOS_NODE_DEFAULT) {
+		dev_err(kdev->dev, "joint port node %s must be wrr/prio\n",
+			qnode->name);
+		error = -EINVAL;
+		goto error_destroy;
+	}
+
 	if (qnode->type == QOS_NODE_PRIO) {
 		int o = offsetof(struct khwq_qos_tree_node, priority);
 		ktree_sort_children(&qnode->node, khwq_qos_cmp, (void *)o);
@@ -2028,6 +2094,7 @@ static int khwq_qos_tree_map_nodes(struct ktree_node *node, void *arg)
 	struct khwq_qos_tree_node *parent = qnode->parent;
 	struct khwq_qos_info *info = arg;
 	struct khwq_device *kdev = info->kdev;
+	int max_inputs;
 
 	qnode->child_port_count	=  0;
 	qnode->child_count	=  0;
@@ -2061,7 +2128,11 @@ static int khwq_qos_tree_map_nodes(struct ktree_node *node, void *arg)
 	if (qnode->has_sched_port && parent)
 		parent->child_port_count ++;
 
-	if (qnode->child_count > info->inputs_per_port) {
+	max_inputs = (qnode->is_joint_port) ?
+			info->inputs_per_port * 2 :
+			info->inputs_per_port;
+
+	if (qnode->child_count > max_inputs) {
 		dev_err(kdev->dev, "too many input_queues (%d) to node %s\n",
 			qnode->child_count, qnode->name);
 		return -EOVERFLOW;
@@ -2078,7 +2149,16 @@ static int khwq_qos_tree_alloc_nodes(struct ktree_node *node, void *arg)
 	int error, i;
 
 	if (qnode->has_sched_port) {
-		error = khwq_qos_alloc_sched_port(info);
+		error = khwq_qos_alloc_sched_port(info, 
+				parent ? parent->sched_port_idx : -1,
+				qnode->is_joint_port);
+		if (error < 0) {
+			error = khwq_qos_alloc_sched_port(info, -1,
+					qnode->is_joint_port);
+			if (error >= 0)
+				dev_warn(kdev->dev, "node %s: non-optimal port"
+					 " allocation\n", qnode->name);
+		}
 		if (error < 0) {
 			dev_err(kdev->dev, "node %s: failed to alloc sched port [%d]\n",
 				qnode->name, error);
@@ -2086,17 +2166,24 @@ static int khwq_qos_tree_alloc_nodes(struct ktree_node *node, void *arg)
 		}
 		qnode->sched_port_idx = error;
 	} else
-		qnode->sched_port_idx = qnode->parent->sched_port_idx;
+		qnode->sched_port_idx = parent->sched_port_idx;
 
 
 	if (parent) {
 		if (WARN_ON(qnode->output_queue != -1))
 			return -EINVAL;
 		if (parent->type == QOS_NODE_DEFAULT)
-			qnode->parent_input = qnode->parent->parent_input;
-		error = khwq_qos_control_sched_port(info, QOS_CONTROL_GET_INPUT,
-						    parent->sched_port_idx,
-						    qnode->parent_input);
+			qnode->parent_input = parent->parent_input;
+		if (parent->is_joint_port && (qnode->parent_input >= info->inputs_per_port))
+			error = khwq_qos_control_sched_port(info,
+					QOS_CONTROL_GET_INPUT,
+					khwq_qos_id_odd(parent->sched_port_idx),
+					qnode->parent_input - info->inputs_per_port);
+		else
+			error = khwq_qos_control_sched_port(info,
+					QOS_CONTROL_GET_INPUT,
+					parent->sched_port_idx,
+					qnode->parent_input);
 		if (WARN_ON(error < 0))
 			return error;
 		qnode->output_queue = error;
@@ -2167,6 +2254,8 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 			 QOS_SCHED_FLAG_CONG_BYTES) : 0;
 	if (parent && (parent->acct == QOS_BYTE_ACCT))
 		val |= QOS_SCHED_FLAG_THROTL_BYTES;
+	if (qnode->is_joint_port)
+		val |= QOS_SCHED_FLAG_IS_JOINT;
 	error = khwq_qos_set_sched_unit_flags(info, idx, val, sync);
 	if (WARN_ON(error))
 		return error;
@@ -2213,7 +2302,7 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 		return error;
 
 	inputs = (qnode->type == QOS_NODE_DEFAULT) ? 1 : qnode->child_count;
-
+	
 	error = khwq_qos_set_sched_total_q_count(info, idx, inputs, sync);
 	if (WARN_ON(error))
 		return error;
@@ -2237,8 +2326,18 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 	}
 
 	for (i = 0; i < inputs; i++) {
+		int port, queue;
+
+		if (qnode->is_joint_port && (i >= info->inputs_per_port)) {
+			port = khwq_qos_id_odd(idx);
+			queue = i - info->inputs_per_port;
+		} else {
+			port = idx;
+			queue = i;
+		}
+
 		val = 0;
-		error = khwq_qos_set_sched_cong_thresh(info, idx, i, val, sync);
+		error = khwq_qos_set_sched_cong_thresh(info, port, queue, val, sync);
 		if (WARN_ON(error))
 			return error;
 
@@ -2256,11 +2355,12 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 			}
 			val = (u32)(tmp);
 
-			dev_dbg(kdev->dev, "node %d weight = %d, credits = %d\n",
-					i, qnode->child_weight[i], val);
+			dev_dbg(kdev->dev, "node %s input %d "
+				"weight = %d, credits = %d\n",
+				qnode->name, i, qnode->child_weight[i], val);
 		}
 
-		error = khwq_qos_set_sched_wrr_credit(info, idx, i, val, sync);
+		error = khwq_qos_set_sched_wrr_credit(info, port, queue, val, sync);
 		if (WARN_ON(error))
 			return error;
 	}
@@ -2279,6 +2379,49 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 			qnode->name);
 		return error;
 	}
+
+	/* If this is a Lite-Joint port pair, configure the Odd port here */
+	if (qnode->is_joint_port) {
+		int odd_idx = khwq_qos_id_odd(idx);
+		int odd_inputs = (inputs <= info->inputs_per_port) ? 0 :
+					(inputs - info->inputs_per_port);
+
+		error = khwq_qos_set_sched_unit_flags(info, odd_idx,
+					QOS_SCHED_FLAG_IS_JOINT, sync);
+		if (WARN_ON(error))
+			return error;
+
+		error = khwq_qos_set_sched_total_q_count(info, odd_idx,
+							 odd_inputs, sync);
+		if (WARN_ON(error))
+			return error;
+
+		val = (qnode->type == QOS_NODE_PRIO) ? odd_inputs : 0;
+		error = khwq_qos_set_sched_sp_q_count(info, odd_idx, val, sync);
+		if (WARN_ON(error))
+			return error;
+
+		val = (qnode->type == QOS_NODE_WRR) ? odd_inputs : 0;
+		error = khwq_qos_set_sched_wrr_q_count(info, odd_idx, val, sync);
+		if (WARN_ON(error))
+			return error;
+
+		error = khwq_qos_sync_sched_port(info, odd_idx);
+		if (error) {
+			dev_err(kdev->dev, "error writing sched config for %s\n",
+				qnode->name);
+			return error;
+		}
+
+		error = khwq_qos_control_sched_port(info, QOS_CONTROL_ENABLE,
+						    odd_idx, false);
+		if (error) {
+			dev_err(kdev->dev, "error disabling sched port for %s\n",
+				qnode->name);
+			return error;
+		}
+	}
+
 	return 0;
 }
 
@@ -2561,6 +2704,8 @@ static int khwq_qos_stop_sched_port_queues(struct khwq_qos_info *info)
 								&queues);
 			if (WARN_ON(error))
 				return error;
+			if (queues > info->inputs_per_port)
+				queues = info->inputs_per_port;
 
 			for (j = 0; j < queues; j++) {
 				error = khwq_qos_set_sched_cong_thresh(info,
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index c878d06..19f9b41 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -18,6 +18,7 @@
 #define __KEYSTONE_QOS_FW_H
 
 #define QOS_MAX_INPUTS			128
+#define	QOS_MAX_CHILDREN		8
 
 #define QOS_RETCODE_SUCCESS		1
 
@@ -49,6 +50,7 @@
 #define	QOS_SCHED_FLAG_CIR_BYTES	BIT(1)
 #define	QOS_SCHED_FLAG_CONG_BYTES	BIT(2)
 #define	QOS_SCHED_FLAG_THROTL_BYTES	BIT(3)
+#define	QOS_SCHED_FLAG_IS_JOINT		BIT(4)
 
 #define QOS_DEFAULT_OVERHEAD_BYTES	24
 
@@ -213,11 +215,12 @@ struct khwq_qos_tree_node {
 	int	 child_port_count;	/* children that need ports	*/
 	int	 child_count;		/* number of children		*/
 	int	 parent_input;		/* input number of parent	*/
-	u32	 child_weight[4];
+	u32	 child_weight[QOS_MAX_CHILDREN];
 	u32	 child_weight_sum;	/* sum of child weights		*/
 	bool	 is_drop_input;		/* indicates that child's output
 					   feeds to the drop sched	*/
 	bool	 has_sched_port;	/* does this port need a sched?	*/
+	bool	 is_joint_port;		/* Even/odd joint pair*/
 	int	 output_queue;		/* from DT or calculated	*/
 
 	/* allocated resources */
@@ -261,6 +264,9 @@ struct khwq_query_stats_regs {
 #define khwq_qos_id_to_queue(info, idx)		\
 	((info)->drop_sched_queue_base + khwq_qos_id_to_idx(idx))
 
+#define	khwq_qos_id_even(idx)	((idx) & ~0x0001)
+#define	khwq_qos_id_odd(idx)	((idx) |  0x0001)
+
 int khwq_qos_alloc(struct khwq_qos_info *info, enum khwq_qos_shadow_type type);
 int khwq_qos_free(struct khwq_qos_info *info, enum khwq_qos_shadow_type type,
 		    int idx);
@@ -307,7 +313,6 @@ static inline int khwq_qos_free_##_field(struct khwq_qos_info *info,	       \
 
 DEFINE_ALLOC(QOS_DROP_CFG_PROF,	 drop_cfg);
 DEFINE_ALLOC(QOS_DROP_OUT_PROF,	 drop_out);
-DEFINE_ALLOC(QOS_SCHED_PORT_CFG, sched_port);
 
 #define DEFINE_FIELD_U32(_type, _field, _offset, _startbit, _nbits)	 \
 static inline int khwq_qos_get_##_field(struct khwq_qos_info *info,	 \
-- 
2.7.4

