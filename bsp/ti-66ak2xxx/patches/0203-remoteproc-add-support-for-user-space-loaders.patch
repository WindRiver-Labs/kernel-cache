From ee51c982cdfde955918193d7ce49d132acd4da70 Mon Sep 17 00:00:00 2001
From: Cyril Chemparathy <cyril@ti.com>
Date: Mon, 10 Dec 2012 11:20:50 -0500
Subject: [PATCH 203/257] remoteproc: add support for user-space loaders

Initial commit - more details to follow soon

remoteproc: rproc-user: honor names
(cherry picked from commit d059e46ecf61c30e9bb630f9f0ffd5087681489f)

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/remoteproc/Kconfig           |  13 ++
 drivers/remoteproc/Makefile          |   1 +
 drivers/remoteproc/remoteproc_user.c | 368 +++++++++++++++++++++++++++++++++++
 include/linux/remoteproc_user.h      |  32 +++
 4 files changed, 414 insertions(+)
 create mode 100644 drivers/remoteproc/remoteproc_user.c
 create mode 100644 include/linux/remoteproc_user.h

diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig
index ce1743d..9fdc0f8 100644
--- a/drivers/remoteproc/Kconfig
+++ b/drivers/remoteproc/Kconfig
@@ -64,4 +64,17 @@ config DA8XX_REMOTEPROC
 	  It's safe to say n here if you're not interested in multimedia
 	  offloading.
 
+config REMOTEPROC_USER
+	tristate "OMAP remoteproc support"
+	depends on EXPERIMENTAL && UIO
+	select REMOTEPROC
+	select RPMSG
+	help
+	  Say y here to support a user-land driven interface to the remoteproc
+	  framework.  This allows for more complex application scenarios where
+	  a simple in-kernel loaders/driver doesn't fit.
+
+	  It's safe to say n here if you're not interested in multimedia
+	  offloading or just want a bare minimum kernel.
+
 endmenu
diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile
index ac2ff75..fa908ae 100644
--- a/drivers/remoteproc/Makefile
+++ b/drivers/remoteproc/Makefile
@@ -10,3 +10,4 @@ remoteproc-y				+= remoteproc_elf_loader.o
 obj-$(CONFIG_OMAP_REMOTEPROC)		+= omap_remoteproc.o
 obj-$(CONFIG_STE_MODEM_RPROC)	 	+= ste_modem_rproc.o
 obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o
+obj-$(CONFIG_REMOTEPROC_USER)		+= remoteproc_user.o
diff --git a/drivers/remoteproc/remoteproc_user.c b/drivers/remoteproc/remoteproc_user.c
new file mode 100644
index 0000000..6cd452f
--- /dev/null
+++ b/drivers/remoteproc/remoteproc_user.c
@@ -0,0 +1,368 @@
+/*
+ * User-space remoteproc loader interface
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com
+ * Contact: Cyril Chemparathy <cyril@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/of_gpio.h>
+#include <linux/remoteproc.h>
+#include <linux/uio_driver.h>
+#include <linux/remoteproc_user.h>
+#include <linux/platform_device.h>
+
+#include "remoteproc_internal.h"
+
+#define DRIVER_NAME		"rproc-user"
+#define DRIVER_VERSION		"0.1"
+
+#define UPROC_MAX_NOTIFIES	8
+#define UPROC_MAX_RSC_TABLE	SZ_64K
+
+struct uproc_info {
+	struct uio_info		 uio;
+	struct rproc		*rproc;
+	struct device		*dev;
+	struct clk		*clk;
+	unsigned long		 flags;
+	spinlock_t		 lock;
+	int			 irq_ctl, irq_ring;
+	int			 kick_gpio;
+	struct resource_table	*rsc_table;
+	int			 rsc_table_size;
+};
+
+static int uproc_set_rsc_table(struct uproc_info *uproc,
+			       void __user *data)
+{
+	unsigned long len = 0;
+	void *rsc_table = NULL;
+
+	if (data) {
+		if (copy_from_user(&len, data, sizeof(len)))
+			return -EFAULT;
+		data += sizeof(len);
+
+		if (len >= UPROC_MAX_RSC_TABLE)
+			return -EOVERFLOW;
+
+		rsc_table = kmalloc(len, GFP_KERNEL);
+		if (!rsc_table)
+			return -ENOMEM;
+
+		if (copy_from_user(rsc_table, data, len))
+			return -EFAULT;
+	}
+
+	spin_lock(&uproc->lock);
+
+	if (uproc->rsc_table) {
+		kfree(uproc->rsc_table);
+		uproc->rsc_table_size = 0;
+		uproc->rsc_table = NULL;
+	}
+
+	uproc->rsc_table = rsc_table;
+	uproc->rsc_table_size = len;
+
+	spin_unlock(&uproc->lock);
+
+	return 0;
+}
+
+static int uproc_open(struct uio_info *uio, struct inode *inode)
+{
+	struct uproc_info *uproc = uio->priv;
+	return clk_prepare_enable(uproc->clk);
+}
+
+static int uproc_release(struct uio_info *uio, struct inode *inode)
+{
+	struct uproc_info *uproc = uio->priv;
+	struct rproc *rproc = uproc->rproc;
+
+	if (rproc->state != RPROC_OFFLINE) {
+		rproc_shutdown(rproc);
+		WARN_ON(rproc->state != RPROC_OFFLINE);
+	}
+
+	clk_disable_unprepare(uproc->clk);
+	return 0;
+}
+
+static irqreturn_t uproc_handler(int irq, struct uio_info *uio)
+{
+	struct uproc_info *uproc = uio->priv;
+
+	if (!test_and_set_bit(0, &uproc->flags))
+		disable_irq_nosync(irq);
+
+	return IRQ_HANDLED;
+}
+
+static int uproc_irqcontrol(struct uio_info *uio, s32 irq_on)
+{
+	struct uproc_info *uproc = uio->priv;
+	unsigned long flags;
+
+	spin_lock_irqsave(&uproc->lock, flags);
+	if (irq_on) {
+		if (test_and_clear_bit(0, &uproc->flags))
+			enable_irq(uio->irq);
+	} else {
+		if (!test_and_set_bit(0, &uproc->flags))
+			disable_irq(uio->irq);
+	}
+	spin_unlock_irqrestore(&uproc->lock, flags);
+
+	return 0;
+}
+
+static int uproc_set_state(struct uproc_info *uproc,
+			   enum rproc_user_state state)
+{
+	struct rproc *rproc = uproc->rproc;
+	int error = 0;
+
+	if (state == RPROC_USER_RUNNING)
+		error = rproc_boot(rproc);
+	else if (state == RPROC_USER_OFFLINE)
+		rproc_shutdown(rproc);
+	else
+		error = -ENOTSUPP;
+
+	return error;
+}
+
+static long uproc_ioctl(struct uio_info *uio, unsigned cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct uproc_info *uproc = uio->priv;
+
+	switch (cmd) {
+	case RPROC_USER_IOC_SET_RSC:
+		return uproc_set_rsc_table(uproc, argp);
+	case RPROC_USER_IOC_SET_STATE:
+		return uproc_set_state(uproc, arg);
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static void uproc_kick(struct rproc *rproc, int vqid)
+{
+	struct uproc_info *uproc = rproc->priv;
+
+	dev_dbg(uproc->dev, "kick vqid: %d\n", vqid);
+	if (uproc->kick_gpio < 0)
+		return;
+
+	gpio_set_value(uproc->kick_gpio, 1);
+	gpio_set_value(uproc->kick_gpio, 0);
+}
+
+static irqreturn_t uproc_interrupt(int irq, void *dev_id)
+{
+	struct uproc_info *uproc = dev_id;
+	return rproc_vq_interrupt(uproc->rproc, -1);
+}
+
+static int uproc_start(struct rproc *rproc)
+{
+	struct uproc_info *uproc = rproc->priv;
+	int error;
+
+	dev_dbg(uproc->dev, "start\n");
+	error = request_irq(uproc->irq_ring, uproc_interrupt, 0,
+			    dev_name(uproc->dev), uproc);
+	if (error)
+		dev_err(uproc->dev, "failed to grab ring irq\n");
+
+	return error;
+}
+
+static int uproc_stop(struct rproc *rproc)
+{
+	struct uproc_info *uproc = rproc->priv;
+	dev_dbg(uproc->dev, "stop\n");
+	free_irq(uproc->irq_ring, uproc);
+	return 0;
+}
+
+static struct rproc_ops uproc_ops = {
+	.start		= uproc_start,
+	.stop		= uproc_stop,
+	.kick		= uproc_kick,
+};
+
+
+static struct resource_table *
+uproc_find_rsc_table(struct rproc *rproc, const struct firmware *fw,
+		     int *tablesz)
+{
+	struct uproc_info *uproc = rproc->priv;
+
+	if (tablesz)
+		*tablesz = uproc->rsc_table_size;
+	return uproc->rsc_table;
+}
+
+static int uproc_load_segments(struct rproc *rproc, const struct firmware *fw)
+{
+	/* nothing to do */
+	return 0;
+}
+
+static struct rproc_fw_ops uproc_fw_ops = {
+	.find_rsc_table		= uproc_find_rsc_table,
+	.load			= uproc_load_segments,
+};
+
+static int uproc_driver_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	int *pdata = dev->platform_data;
+	struct device_node *np = dev->of_node;
+	struct uproc_info *uproc;
+	struct uio_info *uio;
+	struct rproc *rproc;
+	struct resource *r;
+	int i, error;
+
+	rproc = rproc_alloc(dev, dev_name(dev), &uproc_ops, NULL,
+			    sizeof(*uproc));
+	if (!rproc)
+		return -ENOMEM;
+
+	rproc->fw_ops	= &uproc_fw_ops;
+
+	uproc		= rproc->priv;
+	uproc->rproc	= rproc;
+	uproc->dev	= dev;
+	spin_lock_init(&uproc->lock);
+
+	uio		= &uproc->uio;
+	uio->name	= dev_name(dev);
+	uio->version	= DRIVER_VERSION;
+	uio->priv	= uproc;
+	uio->handler	= uproc_handler;
+	uio->irqcontrol	= uproc_irqcontrol;
+	uio->open	= uproc_open;
+	uio->release	= uproc_release;
+	uio->ioctl	= uproc_ioctl;
+
+	uproc->irq_ctl	= platform_get_irq(pdev, 0);
+	uproc->irq_ring	= platform_get_irq(pdev, 1);
+	if (uproc->irq_ctl < 0 || uproc->irq_ring < 0) {
+		dev_err(dev, "failed to get irqs\n");
+		rproc_put(rproc);
+		return -ENXIO;
+	}
+
+	/* pass up control irq to user-space */
+	uio->irq	= uproc->irq_ctl;
+
+	uproc->kick_gpio = -1;
+	if (pdata)
+		uproc->kick_gpio = *pdata;
+#ifdef CONFIG_OF
+	if (dev->of_node) {
+		error = of_get_named_gpio_flags(np, "kick-gpio", 0, NULL);
+		if (error >= 0)
+			uproc->kick_gpio = error;
+	}
+#endif
+	if (uproc->kick_gpio < 0)
+		dev_warn(dev, "failed to get kick gpio\n");
+
+	for (i = 0; i < MAX_UIO_MAPS; ++i) {
+		r = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!r)
+			break;
+
+		uio->mem[i].memtype = UIO_MEM_PHYS;
+		uio->mem[i].addr    = r->start;
+		uio->mem[i].size    = resource_size(r);
+		uio->mem[i].name    = r->name;
+	}
+
+	uproc->clk = clk_get(dev, NULL);
+	if (!uproc->clk) {
+		dev_err(dev, "failed to get clock\n");
+		error = -ENODEV;
+		goto fail_clk;
+	}
+
+	error = uio_register_device(dev, uio);
+	if (error) {
+		dev_err(dev, "failed to register uio device\n");
+		goto fail_uio;
+	}
+
+	error = rproc_add(rproc);
+	if (error) {
+		dev_err(dev, "error adding remoteproc device\n");
+		goto fail_rproc;
+	}
+
+	platform_set_drvdata(pdev, uproc);
+
+	return 0;
+
+fail_rproc:
+	uio_unregister_device(uio);
+fail_uio:
+	clk_put(uproc->clk);
+fail_clk:
+	rproc_put(rproc);
+	devm_kfree(dev, uproc);
+	return error;
+}
+
+static int uproc_driver_remove(struct platform_device *pdev)
+{
+	struct uproc_info *uproc = platform_get_drvdata(pdev);
+
+	if (uproc) {
+		uio_unregister_device(&uproc->uio);
+		rproc_put(uproc->rproc);
+		clk_put(uproc->clk);
+	}
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct of_device_id uproc_of_match[] = {
+	{ .compatible = "linux,rproc-user", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, uproc_of_match);
+
+static struct platform_driver uproc_driver = {
+	.driver	= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+		.of_match_table = uproc_of_match,
+	},
+	.probe	= uproc_driver_probe,
+	.remove	= uproc_driver_remove,
+};
+
+module_platform_driver(uproc_driver);
+MODULE_AUTHOR("Cyril Chemparathy");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("User-space driver for the Remote Processor Framework");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/include/linux/remoteproc_user.h b/include/linux/remoteproc_user.h
new file mode 100644
index 0000000..9cfda8f
--- /dev/null
+++ b/include/linux/remoteproc_user.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: Cyril Chemparathy <cyril@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _LINUX_REMOTEPROC_USER_H
+#define _LINUX_REMOTEPROC_USER_H
+
+#include <linux/types.h>
+
+enum rproc_user_state {
+	RPROC_USER_OFFLINE,
+	RPROC_USER_RUNNING,
+};
+
+#define RPROC_USER_IOC_MAGIC	 'I'
+
+#define RPROC_USER_IOC_SET_RSC	 _IOW(RPROC_USER_IOC_MAGIC, 0,	\
+				      void *)
+#define RPROC_USER_IOC_SET_STATE _IOW(RPROC_USER_IOC_MAGIC, 1,	\
+				      enum rproc_user_state)
+
+#endif /* _LINUX_REMOTEPROC_USER_H */
-- 
2.7.4

