From 15df04578b67c992212fc44c1ea67229894055a7 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Fri, 8 Nov 2013 15:32:49 -0500
Subject: [PATCH 146/257] spi: davinci: support adding delay between
 transmission

This patch fixes the following:-

 1. Some of the SPI peripherals from TI such as keystone
    SPI support adding delay between transmission. Add this
    capability to the driver.
 2. Add bindings for other fields in controller_data for the
    driver and a DT documentation for the bindings.
 3. Compiler warning.

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>

Conflicts:

	drivers/spi/spi-davinci.c
(cherry picked from commit bd023564dd4a393222e551b7c69529e103e8ceda)

Conflicts:
	drivers/spi/spi-davinci.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/spi/spi-davinci.txt        |  16 ++++
 drivers/spi/spi-davinci.c                          | 103 ++++++++++++++++++---
 2 files changed, 106 insertions(+), 13 deletions(-)

diff --git a/Documentation/devicetree/bindings/spi/spi-davinci.txt b/Documentation/devicetree/bindings/spi/spi-davinci.txt
index b0a2516..f00d841 100644
--- a/Documentation/devicetree/bindings/spi/spi-davinci.txt
+++ b/Documentation/devicetree/bindings/spi/spi-davinci.txt
@@ -49,3 +49,19 @@ spi0:spi@20BF0000 {
 		};
 	};
 };
+
+SPI slave nodes must be children of the SPI master node and can
+contain the following properties. Not all SPI Peripherals from
+Texas Instruments support this. Please check SPI peripheral UG
+for a device before using these.
+
+- ti,davinci-spi-wdelay : delay between transmissions.
+- ti,davinci-spi-odd-parity : odd partity enabled
+   OR
+- ti,davinci-spi-even-parity : even parity enabled
+- ti,davinci-spi-io-type: io type (check platform_data/spi-davinci.h)
+- ti,davinci-spi-disable-timer: disable CS timer (SPIFMTn)
+- ti,davinci-spi-c2t-delay: c2t delay
+- ti,davinci-spi-t2c-delay: t2c delay
+- ti,davinci-spi-t2e-delay: t2e delay
+- ti,davinci-spi-c2e-delay: c2e delay
diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c
index a0946d0..992b8b1 100644
--- a/drivers/spi/spi-davinci.c
+++ b/drivers/spi/spi-davinci.c
@@ -67,6 +67,7 @@
 
 /* SPIDAT1 (upper 16 bit defines) */
 #define SPIDAT1_CSHOLD_MASK	BIT(12)
+#define SPIDAT1_WDEL		BIT(10)
 
 /* SPIGCR1 */
 #define SPIGCR1_CLKMOD_MASK	BIT(1)
@@ -209,11 +210,12 @@ static inline void clear_io_bits(void __iomem *addr, u32 bits)
  */
 static void davinci_spi_chipselect(struct spi_device *spi, int value)
 {
-	struct davinci_spi *dspi;
+	struct davinci_spi_config *spicfg = spi->controller_data;
 	struct davinci_spi_platform_data *pdata;
 	u8 chip_sel = spi->chip_select;
-	u16 spidat1 = CS_DEFAULT;
 	bool gpio_chipsel = false;
+	struct davinci_spi *dspi;
+	u16 spidat1 = CS_DEFAULT;
 
 	dspi = spi_master_get_devdata(spi->master);
 	pdata = &dspi->pdata;
@@ -232,6 +234,11 @@ static void davinci_spi_chipselect(struct spi_device *spi, int value)
 		else
 			gpio_set_value(pdata->chip_sel[chip_sel], 1);
 	} else {
+
+		/* program delay tansfers if tx_delay is non zero */
+		if (spicfg->wdelay)
+			spidat1 |= SPIDAT1_WDEL;
+
 		if (value == BITBANG_CS_ACTIVE) {
 			spidat1 |= SPIDAT1_CSHOLD_MASK;
 			spidat1 &= ~(0x1 << chip_sel);
@@ -276,15 +283,13 @@ static inline int davinci_spi_get_prescale(struct davinci_spi *dspi,
 static int davinci_spi_setup_transfer(struct spi_device *spi,
 		struct spi_transfer *t)
 {
-
+	struct davinci_spi_config *spicfg =
+			(struct davinci_spi_config *)spi->controller_data;
+	u32 hz = 0, spifmt = 0, prescale = 0;
 	struct davinci_spi *dspi;
-	struct davinci_spi_config *spicfg;
 	u8 bits_per_word = 0;
-	u32 hz = 0, spifmt = 0;
-	int prescale;
 
 	dspi = spi_master_get_devdata(spi->master);
-	spicfg = (struct davinci_spi_config *)spi->controller_data;
 	if (!spicfg)
 		spicfg = &davinci_spi_default_cfg;
 
@@ -332,6 +337,17 @@ static int davinci_spi_setup_transfer(struct spi_device *spi,
 		spifmt |= SPIFMT_PHASE_MASK;
 
 	/*
+	 * Assume wdelay is used only on SPI peripherals that has this field
+	 * in SPIFMTn register. This is not true for SPI peripherals found
+	 * on older versions as that found on DM6446 for example.
+	 * Need to re-visit the handling different versions of IP. Currently
+	 * it is based on version. SPI mode may be extended to support
+	 * various flavors of the IP.
+	 */
+	spifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)
+						& SPIFMT_WDELAY_MASK);
+
+	/*
 	 * Version 1 hardware supports two basic SPI modes:
 	 *  - Standard SPI mode uses 4 pins, with chipselect
 	 *  - 3 pin SPI is a 4 pin variant without CS (SPI_NO_CS)
@@ -348,9 +364,6 @@ static int davinci_spi_setup_transfer(struct spi_device *spi,
 
 		u32 delay = 0;
 
-		spifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)
-							& SPIFMT_WDELAY_MASK);
-
 		if (spicfg->odd_parity)
 			spifmt |= SPIFMT_ODD_PARITY_MASK;
 
@@ -376,13 +389,28 @@ static int davinci_spi_setup_transfer(struct spi_device *spi,
 
 		iowrite32(delay, dspi->base + SPIDELAY);
 	}
-
 	iowrite32(spifmt, dspi->base + SPIFMT0);
 
 	return 0;
 }
 
 /**
+ * davinci_spi_cleanup - cleanup function registered to SPI master framework
+ * @spi: spi device which is requesting cleanup
+ *
+ * This function is registered to the SPI framework for this SPI master
+ * controller. It will free the runtime state of chip.
+ */
+static void davinci_spi_cleanup(struct spi_device *spi)
+{
+	struct davinci_spi_config *spicfg = spi->controller_data;
+
+	spi->controller_data = NULL;
+	if (spi->dev.of_node)
+		kfree(spicfg);
+}
+
+/**
  * davinci_spi_setup - This functions will set default transfer method
  * @spi: spi device on which data transfer to be done
  *
@@ -390,9 +418,12 @@ static int davinci_spi_setup_transfer(struct spi_device *spi,
  */
 static int davinci_spi_setup(struct spi_device *spi)
 {
-	int retval = 0;
-	struct davinci_spi *dspi;
+	struct davinci_spi_config *spicfg = spi->controller_data;
+	struct device_node *np = spi->dev.of_node;
 	struct davinci_spi_platform_data *pdata;
+	struct davinci_spi *dspi;
+	int retval = 0, len;
+	u32 prop;
 
 	dspi = spi_master_get_devdata(spi->master);
 	pdata = &dspi->pdata;
@@ -412,6 +443,51 @@ static int davinci_spi_setup(struct spi_device *spi)
 	else
 		clear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);
 
+	if (spicfg == NULL) {
+		if (np) {
+			spicfg = kzalloc(sizeof(*spicfg), GFP_KERNEL);
+			if (!spicfg) {
+				dev_err(&spi->dev,
+				"cannot allocate controller data\n");
+				return -ENOMEM;
+			}
+
+			*spicfg = davinci_spi_default_cfg;
+			/* override with dt configured values */
+			if (!of_property_read_u32(np,
+					"ti,davinci-spi-wdelay", &prop))
+				spicfg->wdelay = (u8)prop;
+			if (of_find_property(np,
+					"ti,davinci-spi-odd-parity", &len)) {
+				spicfg->parity_enable = 1;
+				spicfg->odd_parity = 1;
+			} else if (of_find_property(np,
+					"ti,davinci-spi-even-parity", &len)) {
+				spicfg->parity_enable = 1;
+				spicfg->odd_parity = 0;
+			}
+			if (!of_property_read_u32(np, "ti,davinci-spi-io-type",
+						 &prop))
+				spicfg->io_type = (u8)prop;
+			if (of_find_property(np,
+					"ti,davinci-spi-disable-timer", &len))
+				spicfg->timer_disable = 1;
+			if (!of_property_read_u32(np,
+					"ti,davinci-spi-c2t-delay", &prop))
+				spicfg->c2tdelay = (u8)prop;
+			if (!of_property_read_u32(np,
+					"ti,davinci-spi-t2c-delay", &prop))
+				spicfg->t2cdelay = (u8)prop;
+			if (!of_property_read_u32(np,
+					"ti,davinci-spi-t2e-delay", &prop))
+				spicfg->t2edelay = (u8)prop;
+			if (!of_property_read_u32(np,
+					"ti,davinci-spi-c2e-delay", &prop))
+				spicfg->c2edelay = (u8)prop;
+			spi->controller_data = spicfg;
+		}
+	}
+
 	return retval;
 }
 
@@ -931,6 +1007,7 @@ static int davinci_spi_probe(struct platform_device *pdev)
 	master->num_chipselect = pdata->num_chipselect;
 	master->bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 16);
 	master->setup = davinci_spi_setup;
+	master->cleanup = davinci_spi_cleanup;
 
 	dspi->bitbang.chipselect = davinci_spi_chipselect;
 	dspi->bitbang.setup_transfer = davinci_spi_setup_transfer;
-- 
2.7.4

