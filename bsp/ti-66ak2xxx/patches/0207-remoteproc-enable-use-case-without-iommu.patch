From 290e3e42fb59e04c2eafe529a0a943a790f8c043 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Wed, 6 Feb 2013 15:41:45 -0500
Subject: [PATCH 207/257] remoteproc: enable use case without iommu

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Sam Nelson <sam.nelson@ti.com>
(cherry picked from commit c35cd810904de6c2ca92a1c61e19caed72d6c3a4)

Conflicts:
	drivers/remoteproc/remoteproc_core.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/remoteproc/remoteproc_core.c | 38 ++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c
index ab32590..000f17d 100644
--- a/drivers/remoteproc/remoteproc_core.c
+++ b/drivers/remoteproc/remoteproc_core.c
@@ -40,6 +40,8 @@
 #include <linux/crc32.h>
 #include <linux/virtio_ids.h>
 #include <linux/virtio_ring.h>
+#include <linux/io.h>
+
 #include <asm/byteorder.h>
 
 #include "remoteproc_internal.h"
@@ -587,12 +589,25 @@ static int rproc_handle_carveout(struct rproc *rproc,
 		dev_err(dev, "kzalloc carveout failed\n");
 		return -ENOMEM;
 	}
-
-	va = dma_alloc_coherent(dev->parent, rsc->len, &dma, GFP_KERNEL);
-	if (!va) {
-		dev_err(dev->parent, "dma_alloc_coherent err: %d\n", rsc->len);
-		ret = -ENOMEM;
-		goto free_carv;
+	if (rproc->domain) {
+		va = dma_alloc_coherent(dev->parent, rsc->len, &dma,
+						GFP_KERNEL);
+		if (!va) {
+			dev_err(dev->parent,
+				"dma_alloc_coherent err: %d\n", rsc->len);
+			ret = -ENOMEM;
+			goto free_carv;
+		}
+	} else {
+		dma = rsc->pa;
+		/* Convert to virtual address */
+		va  = devm_ioremap_nocache(&rproc->dev, dma, rsc->len);
+		if (!va) {
+			dev_err(dev->parent, "devm_ioremap_nocache err: %d\n",
+				rsc->len);
+			ret = -ENOMEM;
+			goto free_carv;
+		}
 	}
 
 	dev_dbg(dev, "carveout va %p, dma %llx, len 0x%x\n", va,
@@ -769,6 +784,17 @@ static void rproc_resource_cleanup(struct rproc *rproc)
 		kfree(entry);
 	}
 
+	/* clean up carveout allocations */
+	list_for_each_entry_safe(entry, tmp, &rproc->carveouts, node) {
+		if (rproc->domain)
+			dma_free_coherent(dev->parent, entry->len, entry->va,
+					 entry->dma);
+		else
+			devm_iounmap(&rproc->dev, entry->va);
+		list_del(&entry->node);
+		kfree(entry);
+	}
+
 	/* clean up iommu mapping entries */
 	list_for_each_entry_safe(entry, tmp, &rproc->mappings, node) {
 		size_t unmapped;
-- 
2.7.4

