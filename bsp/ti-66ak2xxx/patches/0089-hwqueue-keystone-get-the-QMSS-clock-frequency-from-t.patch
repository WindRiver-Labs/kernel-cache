From 1eabcf067b317ffc413ae363bd88aa43c9c072e6 Mon Sep 17 00:00:00 2001
From: Murali Karicheri <m-karicheri2@ti.com>
Date: Fri, 7 Jun 2013 20:43:54 -0400
Subject: [PATCH 089/257] hwqueue: keystone: get the QMSS clock frequency from
 the clock tree

This patch changes the Keystone H/W Queue subsystem to get/prepare/enable
the clock used to drive the QMSS PDSPs from the clock tree. This allows
QoS to determine the timer input frequency instead of hard-coding it.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
(cherry picked from commit ccd0b3a4de8d0fb001535b4a313e8cea7b8d3ceb)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.c     | 18 ++++++++++++++++++
 drivers/hwqueue/keystone_hwqueue.h     |  1 +
 drivers/hwqueue/keystone_hwqueue_qos.c |  3 ++-
 drivers/hwqueue/keystone_qos.h         |  2 --
 4 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.c b/drivers/hwqueue/keystone_hwqueue.c
index b779d10..c86e8a6 100644
--- a/drivers/hwqueue/keystone_hwqueue.c
+++ b/drivers/hwqueue/keystone_hwqueue.c
@@ -18,6 +18,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/bitops.h>
 #include <linux/slab.h>
@@ -1158,6 +1159,17 @@ static int khwq_probe(struct platform_device *pdev)
 	kdev->base_id    = temp[0];
 	kdev->num_queues = temp[1];
 
+	kdev->clk = clk_get(dev, "clk_hwqueue");
+	if (IS_ERR_OR_NULL(kdev->clk)) {
+		dev_err(dev, "unable to get hardware queue clock\n");
+		return -ENODEV;
+	}
+	if (clk_prepare_enable(kdev->clk)) {
+		dev_err(dev, "unable to enable hardware queue clock\n");
+		clk_put(kdev->clk);
+		return -ENODEV;
+	}
+
 	qmgrs =  of_get_child_by_name(node, "qmgrs");
 	if (!qmgrs) {
 		dev_err(dev, "queue manager info not specified\n");
@@ -1272,6 +1284,12 @@ static int khwq_remove(struct platform_device *pdev)
 	struct hwqueue_device *hdev = to_hdev(kdev);
 	int ret;
 
+	if (kdev->clk) {
+		clk_disable_unprepare(kdev->clk);
+		clk_put(kdev->clk);
+	}
+	kdev->clk = NULL;
+
 	ret = hwqueue_device_unregister(hdev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "hwqueue unregistration failed\n");
diff --git a/drivers/hwqueue/keystone_hwqueue.h b/drivers/hwqueue/keystone_hwqueue.h
index 82d5314..413c48b 100644
--- a/drivers/hwqueue/keystone_hwqueue.h
+++ b/drivers/hwqueue/keystone_hwqueue.h
@@ -220,6 +220,7 @@ struct khwq_qmgr_info {
 
 struct khwq_device {
 	struct device			*dev;
+	struct clk			*clk;
 	struct hwqueue_device		 hdev;
 	struct list_head		 regions;
 	struct khwq_link_ram_block	 link_rams[2];
diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index 4ddbf10..c39ecdb 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -18,6 +18,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/bitops.h>
 #include <linux/slab.h>
@@ -3311,7 +3312,7 @@ static int khwq_qos_init_range(struct khwq_range_info *range)
 	}
 
 	/* calculate the timer config from the pdsp tick */
-	timer_config = (QMSS_CLK_RATE / info->ticks_per_sec);
+	timer_config = (clk_get_rate(kdev->clk) / info->ticks_per_sec);
 	timer_config /= 2;
 	command = (QOS_CMD_SET_TIMER_CONFIG | ((timer_config & 0xffff) << 16));
 	error = khwq_qos_write_cmd(info, command);
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index 251673e..8c46f0e 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -19,8 +19,6 @@
 
 #define QOS_MAX_INPUTS			128
 
-#define QMSS_CLK_RATE			327680000
-
 #define QOS_RETCODE_SUCCESS		1
 
 #define QOS_COMMAND_TIMEOUT		20	/* msecs */
-- 
2.7.4

