From 0dbc7f7ed622564ef465ec114e145d6a781447e1 Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Thu, 31 Oct 2013 17:27:47 -0400
Subject: [PATCH 093/257] hwqueue: keystone: Make writable QoS attributes truly
 dynamic

Prior to this patch, writing any qos-tree attribute through sysfs caused
the entire QoS configuration to be cleared and restarted. This could cause
undesirable effects on queued traffic. This patch makes all writable
QoS parameters changable without restarting the configuration.

Also corrected in this patch are bugs in how the output-rate parameter
is transformed into sched_cir_credit and sched_out_throttle. The value
of output-rate for a node (port) should affect the sched_cir_credit
of the given node, and the sched_out_throttle of all its children.
Prior to this patch, it set the sched_out_throttle of the given node.

Finally, write permissions for the input-queues parameter have been
removed. Changing this also changes the structure of the QoS tree,
which is not intended to be supported. The "store" method remains
in the code in case this functionality needs to be restored, but it
should not be accessible without also changing the permissions.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 2c6fbb282b11f56faae4edb481a48a776957bbba)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c | 116 +++++++++++++++++++++++----------
 drivers/hwqueue/keystone_qos.h         |   5 ++
 2 files changed, 88 insertions(+), 33 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index 54364c4..8e54cf8 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -1337,7 +1337,8 @@ static ssize_t qnode_weight_store(struct khwq_qos_tree_node *qnode,
 	struct khwq_qos_tree_node *parent = qnode->parent;
 	struct khwq_qos_info *info = qnode->info;
 	unsigned int weight;
-	int error;
+	int inputs, i, error, val, idx;
+	u64 scale, tmp;
 
 	if (!parent || parent->type != QOS_NODE_WRR)
 		return -EINVAL;
@@ -1355,9 +1356,29 @@ static ssize_t qnode_weight_store(struct khwq_qos_tree_node *qnode,
 	parent->child_weight_sum += weight;
 	parent->child_weight[qnode->parent_input] = weight;
 
-	khwq_qos_stop(info);
+	inputs = parent->child_count;
+	scale = inputs * ((parent->acct == QOS_BYTE_ACCT) ?
+				QOS_BYTE_NORMALIZATION_FACTOR :
+				QOS_PACKET_NORMALIZATION_FACTOR);
+	scale <<= 48;
+	do_div(scale, parent->child_weight_sum);
+
+	idx = parent->sched_port_idx;
+	for (i = inputs - 1; i >= 0; --i) {
+		tmp = parent->child_weight[i];
+		tmp *= scale;
+
+		if (parent->acct == QOS_BYTE_ACCT) {
+			tmp += 1ULL << (47 - QOS_CREDITS_BYTE_SHIFT);
+			tmp >>= (48 - QOS_CREDITS_BYTE_SHIFT);
+		} else {
+			tmp += 1ULL << (47 - QOS_CREDITS_PACKET_SHIFT);
+			tmp >>= (48 - QOS_CREDITS_PACKET_SHIFT);
+		}
+		val = (u32)(tmp);
 
-	khwq_qos_start(info);
+		khwq_qos_set_sched_wrr_credit(info, idx, i, val, (i == 0));
+	}
 
 	return size;
 }
@@ -1380,21 +1401,42 @@ static ssize_t qnode_output_rate_show(struct khwq_qos_tree_node *qnode,
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->output_rate);
 }
 
+static int qnode_output_rate_store_child(struct ktree_node *child, void *arg)
+{
+	struct khwq_qos_tree_node *qnode = to_qnode(child);
+	struct khwq_qos_info *info = qnode->info;
+	struct khwq_qos_tree_node *parent = arg;
+	int idx = qnode->sched_port_idx;
+	int val;
+
+	val = parent->output_rate;
+	val = (val + info->ticks_per_sec - 1) / info->ticks_per_sec;
+	khwq_qos_set_sched_out_throttle(info, idx, val, true);
+
+	return 0;
+}
+
 static ssize_t qnode_output_rate_store(struct khwq_qos_tree_node *qnode,
 				       const char *buf, size_t size)
 {
 	struct khwq_qos_info *info = qnode->info;
-	int error, field;
+	int idx = qnode->sched_port_idx;
+	int error, val;
 
-	error = kstrtouint(buf, 0, &field);
+	error = kstrtouint(buf, 0, &val);
 	if (error)
 		return error;
 	
-	qnode->output_rate = field;
+	qnode->output_rate = val;
 
-	khwq_qos_stop(info);
+	val = qnode->output_rate / info->ticks_per_sec;
+	val <<= (qnode->acct == QOS_BYTE_ACCT) ?
+			QOS_CREDITS_BYTE_SHIFT :
+			QOS_CREDITS_PACKET_SHIFT;
+	khwq_qos_set_sched_cir_credit(info, idx, val, true);
 
-	khwq_qos_start(info);
+	ktree_for_each_child(&qnode->node,
+			     qnode_output_rate_store_child, qnode);
 
 	return size;
 }
@@ -1412,7 +1454,8 @@ static ssize_t qnode_burst_size_store(struct khwq_qos_tree_node *qnode,
 				      const char *buf, size_t size)
 {
 	struct khwq_qos_info *info = qnode->info;
-	int error, field;
+	int idx = qnode->sched_port_idx;
+	int error, val, field;
 
 	error = kstrtouint(buf, 0, &field);
 	if (error)
@@ -1420,9 +1463,10 @@ static ssize_t qnode_burst_size_store(struct khwq_qos_tree_node *qnode,
 	
 	qnode->burst_size = field;
 
-	khwq_qos_stop(info);
-
-	khwq_qos_start(info);
+	val = (qnode->acct == QOS_BYTE_ACCT) ?
+		(field << QOS_CREDITS_BYTE_SHIFT) :
+		(field << QOS_CREDITS_PACKET_SHIFT);
+	khwq_qos_set_sched_cir_max(info, idx, val, true);
 
 	return size;
 }
@@ -1437,17 +1481,19 @@ static ssize_t qnode_overhead_bytes_store(struct khwq_qos_tree_node *qnode,
 					  const char *buf, size_t size)
 {
 	struct khwq_qos_info *info = qnode->info;
-	int error, field;
+	int idx = qnode->sched_port_idx;
+	int error, val;
 
-	error = kstrtoint(buf, 0, &field);
+	error = kstrtoint(buf, 0, &val);
 	if (error)
 		return error;
 	
-	qnode->overhead_bytes = field;
+	qnode->overhead_bytes = val;
 
-	khwq_qos_stop(info);
-
-	khwq_qos_start(info);
+	khwq_qos_set_sched_overhead_bytes(info, idx,
+			(val < 0) ? 0 : val, false);
+	khwq_qos_set_sched_remove_bytes(info, idx,
+			(val < 0) ? (-val) : 0, true);
 
 	return size;
 }
@@ -1550,7 +1596,7 @@ static KHWQ_QOS_QNODE_ATTR(burst_size, S_IRUGO|S_IWUSR,
 static KHWQ_QOS_QNODE_ATTR(overhead_bytes, S_IRUGO|S_IWUSR,
 			   qnode_overhead_bytes_show,
 			   qnode_overhead_bytes_store);
-static KHWQ_QOS_QNODE_ATTR(input_queues, S_IRUGO|S_IWUSR,
+static KHWQ_QOS_QNODE_ATTR(input_queues, S_IRUGO,
 			   qnode_input_queues_show,
 			   qnode_input_queues_store);
 
@@ -2102,7 +2148,8 @@ static int khwq_qos_tree_alloc_nodes(struct ktree_node *node, void *arg)
 static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 				      struct khwq_qos_tree_node *qnode)
 {
-	int error, val, idx = qnode->sched_port_idx, temp;
+	struct khwq_qos_tree_node *parent = qnode->parent;
+	int error, val, idx = qnode->sched_port_idx;
 	struct khwq_device *kdev = info->kdev;
 	bool sync = false;
 	int inputs, i;
@@ -2114,7 +2161,12 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 	dev_dbg(kdev->dev, "programming sched port index %d for node %s\n",
 		khwq_qos_id_to_idx(idx), qnode->name);
 
-	val = (qnode->acct == QOS_BYTE_ACCT) ? 0xf : 0;
+	val = (qnode->acct == QOS_BYTE_ACCT) ?
+			(QOS_SCHED_FLAG_WRR_BYTES |
+			 QOS_SCHED_FLAG_CIR_BYTES |
+			 QOS_SCHED_FLAG_CONG_BYTES) : 0;
+	if (parent && (parent->acct == QOS_BYTE_ACCT))
+		val |= QOS_SCHED_FLAG_THROTL_BYTES;
 	error = khwq_qos_set_sched_unit_flags(info, idx, val, sync);
 	if (WARN_ON(error))
 		return error;
@@ -2137,27 +2189,25 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 			(val < 0) ? (-val) : 0, sync);
 	if (WARN_ON(error))
 		return error;
-	dev_dbg(kdev->dev, "%s overhead_bytes %d: %d/%d\n", qnode->name, val,
-			(val < 0) ? 0 : val,
-			(val < 0) ? (-val) : 0);
 
-	val = qnode->output_rate / info->ticks_per_sec;
+	val = parent ? parent->output_rate : 0;
+	val = (val + info->ticks_per_sec - 1) / info->ticks_per_sec;
 	error = khwq_qos_set_sched_out_throttle(info, idx, val, sync);
 	if (WARN_ON(error))
 		return error;
 
-	temp = qnode->output_rate / info->ticks_per_sec;
-	val = (qnode->acct == QOS_BYTE_ACCT) ?
-		(temp << QOS_CREDITS_BYTE_SHIFT) :
-		(temp << QOS_CREDITS_PACKET_SHIFT);
+	val = qnode->output_rate / info->ticks_per_sec;
+	val <<= (qnode->acct == QOS_BYTE_ACCT) ?
+			QOS_CREDITS_BYTE_SHIFT :
+			QOS_CREDITS_PACKET_SHIFT;
 	error = khwq_qos_set_sched_cir_credit(info, idx, val, sync);
 	if (WARN_ON(error))
 		return error;
 
-	temp = qnode->burst_size;
-	val = (qnode->acct == QOS_BYTE_ACCT) ?
-		(temp << QOS_CREDITS_BYTE_SHIFT) :
-		(temp << QOS_CREDITS_PACKET_SHIFT);
+	val = qnode->burst_size;
+	val <<= (qnode->acct == QOS_BYTE_ACCT) ?
+			QOS_CREDITS_BYTE_SHIFT :
+			QOS_CREDITS_PACKET_SHIFT;
 	error = khwq_qos_set_sched_cir_max(info, idx, val, sync);
 	if (WARN_ON(error))
 		return error;
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index 7fde627..c878d06 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -45,6 +45,11 @@
 #define QOS_DROP_SCHED_CFG		4
 #define QOS_DROP_SCHED_ENABLE		BIT(24)
 
+#define	QOS_SCHED_FLAG_WRR_BYTES	BIT(0)
+#define	QOS_SCHED_FLAG_CIR_BYTES	BIT(1)
+#define	QOS_SCHED_FLAG_CONG_BYTES	BIT(2)
+#define	QOS_SCHED_FLAG_THROTL_BYTES	BIT(3)
+
 #define QOS_DEFAULT_OVERHEAD_BYTES	24
 
 #define QOS_CREDITS_PACKET_SHIFT	20
-- 
2.7.4

