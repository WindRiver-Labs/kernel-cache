From 8dc30d033e0c879bc36f7241ea7129c5b83078be Mon Sep 17 00:00:00 2001
From: Garrett Ding <g-ding@ti.com>
Date: Fri, 20 Jun 2014 10:20:20 -0400
Subject: [PATCH 152/257] i2c: davinci: Add block read for IPMI integration

Intelligent Plaform Management Interface (IPMI) requires I2C driver
to support block read, where the first byte received from slave is
the size of followed data. Typically the data size is pre-set by master in
normal I2C read mode.

- Added length check if the read type is block read (I2C_M_RECV_LEN)
- Send NACK/STOP bits BEFORE last byte is received. The NACK/STOP bits
  are sent only when dev->stop flag is set so that "Repeated Start" condition
  doesn't get broken. 'Repeated Start" condition receives any number of
  data words before driving a STOP condition.

Signed-off-by: Garrett Ding <g-ding@ti.com>
(cherry picked from commit 579f5a90edb6a600de31d1edfe59a7c3bac8f548)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/i2c/busses/i2c-davinci.c | 31 +++++++++++++++++++++++++++++--
 1 file changed, 29 insertions(+), 2 deletions(-)

diff --git a/drivers/i2c/busses/i2c-davinci.c b/drivers/i2c/busses/i2c-davinci.c
index e3c6a96..5b36741 100644
--- a/drivers/i2c/busses/i2c-davinci.c
+++ b/drivers/i2c/busses/i2c-davinci.c
@@ -45,6 +45,7 @@
 
 #define DAVINCI_I2C_TIMEOUT	(1*HZ)
 #define DAVINCI_I2C_MAX_TRIES	2
+#define DAVINCI_I2C_BLOCK_LEN   0x10000
 #define I2C_DAVINCI_INTR_ALL    (DAVINCI_I2C_IMR_AAS | \
 				 DAVINCI_I2C_IMR_SCD | \
 				 DAVINCI_I2C_IMR_ARDY | \
@@ -318,7 +319,12 @@ i2c_davinci_xfer_msg(struct i2c_adapter *adap, struct i2c_msg *msg, int stop)
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_SAR_REG, msg->addr);
 
 	dev->buf = msg->buf;
-	dev->buf_len = msg->len;
+	 /* if first received byte is length, set buf_len = 0xffff as flag */
+        if(msg->flags & I2C_M_RECV_LEN)
+                dev->buf_len = DAVINCI_I2C_BLOCK_LEN;
+        else
+                dev->buf_len = msg->len;
+
 	dev->stop = stop;
 
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);
@@ -454,7 +460,7 @@ i2c_davinci_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 
 static u32 i2c_davinci_func(struct i2c_adapter *adap)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA;
 }
 
 static void terminate_read(struct davinci_i2c_dev *dev)
@@ -488,6 +494,7 @@ static irqreturn_t i2c_davinci_isr(int this_irq, void *dev_id)
 	u32 stat;
 	int count = 0;
 	u16 w;
+	u8 *addr;
 
 	while ((stat = davinci_i2c_read_reg(dev, DAVINCI_I2C_IVR_REG))) {
 		dev_dbg(dev->dev, "%s: stat=0x%x\n", __func__, stat);
@@ -529,7 +536,27 @@ static irqreturn_t i2c_davinci_isr(int this_irq, void *dev_id)
 				*dev->buf++ =
 				    davinci_i2c_read_reg(dev,
 							 DAVINCI_I2C_DRR_REG);
+				/* check if the first received byte is message length, i.e, I2C_M_RECV_LEN */
+                                if (dev->buf_len == DAVINCI_I2C_BLOCK_LEN)
+				{
+					addr = dev->buf - 1;
+					dev->buf_len = *addr + 1;
+					davinci_i2c_write_reg(dev, DAVINCI_I2C_CNT_REG, dev->buf_len);
+				}
+
 				dev->buf_len--;
+
+				if(dev->stop) {
+					/* send NACK/STOP bits BEFORE last byte is received */
+					if (dev->buf_len == 1) {
+						w = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);
+						w |= DAVINCI_I2C_MDR_NACK;
+					        davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);
+						w |= DAVINCI_I2C_MDR_STP;
+						davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, w);
+					}
+				}
+
 				if (dev->buf_len)
 					continue;
 
-- 
2.7.4

