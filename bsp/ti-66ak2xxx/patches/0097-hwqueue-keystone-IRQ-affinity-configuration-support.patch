From 74ccd053bc8ebfae70289390e3a0d445ed0a43d3 Mon Sep 17 00:00:00 2001
From: Sandeep Nair <sandeep_n@ti.com>
Date: Wed, 22 Jan 2014 12:11:01 -0500
Subject: [PATCH 097/257] hwqueue: keystone: IRQ affinity configuration support

This patch adds the support to specify CPU affinity for hwqueue IRQs
via the interrupt-cell encoding used by ARM GIC. Bits[15:8] of the 3rd
cell is used to specify the PPI interrupt cpu mask. This patch overloads
these bits to specify the cpu mask for hwqueue SPI interrupts.

This patch is needed to statically map hwqueue IRQs to different CPUs
for the pktdma channels used by keystone ethernet driver.

Signed-off-by: Sandeep Nair <sandeep_n@ti.com>
(cherry picked from commit 9257d958023638091847a0406b86a6f4fe462b77)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.c     | 42 +++++++++++++++++++++++++++++-----
 drivers/hwqueue/keystone_hwqueue.h     |  7 +++++-
 drivers/hwqueue/keystone_hwqueue_acc.c | 13 ++++++++---
 3 files changed, 52 insertions(+), 10 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.c b/drivers/hwqueue/keystone_hwqueue.c
index cdc98f5..1f72ddc 100644
--- a/drivers/hwqueue/keystone_hwqueue.c
+++ b/drivers/hwqueue/keystone_hwqueue.c
@@ -114,9 +114,9 @@ static void khwq_set_notify(struct hwqueue_instance *inst, bool enabled)
 	} else if (range->flags & RANGE_HAS_IRQ) {
 		queue = hwqueue_inst_to_id(inst) - range->queue_base;
 		if (enabled)
-			enable_irq(range->irqs[queue]);
+			enable_irq(range->irqs[queue].irq);
 		else
-			disable_irq_nosync(range->irqs[queue]);
+			disable_irq_nosync(range->irqs[queue].irq);
 	} else
 		hwqueue_set_poll(inst, enabled);
 }
@@ -127,13 +127,20 @@ static int khwq_setup_irq(struct khwq_range_info *range,
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
 	unsigned queue = hwqueue_inst_to_id(inst) - range->queue_base;
 	int ret = 0, irq;
+	unsigned long cpu_map;
 
 	if (range->flags & RANGE_HAS_IRQ) {
-		irq = range->irqs[queue];
+		irq = range->irqs[queue].irq;
+		cpu_map = range->irqs[queue].cpu_map;
 
 		ret = request_irq(irq, khwq_int_handler, 0, kq->irq_name, inst);
 		if (ret >= 0)
 			disable_irq(irq);
+
+		if (cpu_map)
+			if (irq_set_affinity(irq, to_cpumask(&cpu_map)))
+				dev_warn(range->kdev->dev,
+						"Failed to set IRQ affinity\n");
 	}
 
 	return ret;
@@ -147,7 +154,7 @@ static void khwq_free_irq(struct hwqueue_instance *inst)
 	int irq;
 
 	if (range->flags & RANGE_HAS_IRQ) {
-		irq = range->irqs[id];
+		irq = range->irqs[id].irq;
 		free_irq(irq, inst);
 	}
 }
@@ -699,11 +706,34 @@ static int khwq_setup_queue_range(struct khwq_device *kdev,
 	}
 
 	for (i = 0; i < RANGE_MAX_IRQS; i++) {
-		range->irqs[i] = irq_of_parse_and_map(node, i);
-		if (range->irqs[i] == IRQ_NONE)
+		struct of_irq oirq;
+
+		if (of_irq_map_one(node, i, &oirq))
+			break;
+
+		range->irqs[i].irq = irq_create_of_mapping(oirq.controller,
+					oirq.specifier, oirq.size);
+
+		/* Check for a valid IRQ */
+		if (range->irqs[i].irq == IRQ_NONE)
 			break;
+
 		range->num_irqs++;
+
+		/* If it is an SPI interrupt then extract the interrupt
+		 * cpu mask. This mask will be used later to set the
+		 * CPU affinity for the IRQ.
+		 * For details on encoding of interrupt-cells for ARM GIC,
+		 * refer to Documentation/devicetree/bindings/arm/gic.txt.
+		 */
+		if (oirq.specifier[0])
+			continue;
+
+		if (oirq.size >= 3)
+			range->irqs[i].cpu_map =
+				(oirq.specifier[2] & 0x0000ff00) >> 8;
 	}
+
 	range->num_irqs = min(range->num_irqs, range->num_queues);
 	if (range->num_irqs)
 		range->flags |= RANGE_HAS_IRQ;
diff --git a/drivers/hwqueue/keystone_hwqueue.h b/drivers/hwqueue/keystone_hwqueue.h
index 7e2650a..d8bd74d 100644
--- a/drivers/hwqueue/keystone_hwqueue.h
+++ b/drivers/hwqueue/keystone_hwqueue.h
@@ -174,6 +174,11 @@ struct khwq_pdsp_info {
 
 struct khwq_range_ops;
 
+struct khwq_irq_info {
+	int	irq;
+	u32	cpu_map;
+};
+
 struct khwq_range_info {
 	const char		*name;
 	struct khwq_device	*kdev;
@@ -187,7 +192,7 @@ struct khwq_range_info {
 	struct khwq_acc_channel	*acc;
 	struct khwq_qos_info	*qos_info;
 	unsigned		 num_irqs;
-	int			 irqs[RANGE_MAX_IRQS];
+	struct khwq_irq_info	 irqs[RANGE_MAX_IRQS];
 };
 
 struct khwq_range_ops {
diff --git a/drivers/hwqueue/keystone_hwqueue_acc.c b/drivers/hwqueue/keystone_hwqueue_acc.c
index 0764780..42626fe 100644
--- a/drivers/hwqueue/keystone_hwqueue_acc.c
+++ b/drivers/hwqueue/keystone_hwqueue_acc.c
@@ -120,7 +120,7 @@ static irqreturn_t khwq_acc_int_handler(int irq, void *_instdata)
 	if ((range->flags & RANGE_MULTI_QUEUE) == 0) {
 		/* TODO: this needs extent checks */
 		for (queue = 0; queue < range->num_irqs; queue++)
-			if (range->irqs[queue] == irq)
+			if (range->irqs[queue].irq == irq)
 				break;
 		inst	 = hwqueue_id_to_inst(hdev, range_base + queue);
 		kq	 = hwqueue_inst_to_priv(inst);
@@ -226,15 +226,18 @@ int khwq_range_setup_acc_irq(struct khwq_range_info *range, int queue,
 {
 	struct khwq_device *kdev = range->kdev;
 	struct khwq_acc_channel *acc;
+	unsigned long cpu_map;
 	int ret = 0, irq;
 	u32 old, new;
 
 	if (range->flags & RANGE_MULTI_QUEUE) {
 		acc = range->acc;
-		irq = range->irqs[0];
+		irq = range->irqs[0].irq;
+		cpu_map = range->irqs[0].cpu_map;
 	} else {
 		acc = range->acc + queue;
-		irq = range->irqs[queue];
+		irq = range->irqs[queue].irq;
+		cpu_map = range->irqs[queue].cpu_map;
 	}
 
 	old = acc->open_mask;
@@ -255,6 +258,10 @@ int khwq_range_setup_acc_irq(struct khwq_range_info *range, int queue,
 			acc->name, acc->name);
 		ret = request_irq(irq, khwq_acc_int_handler, 0, acc->name,
 				  range);
+		if (cpu_map)
+			if (irq_set_affinity(irq, to_cpumask(&cpu_map)))
+				dev_warn(range->kdev->dev,
+						"Failed to set IRQ affinity\n");
 	}
 
 	if (old && !new) {
-- 
2.7.4

