From 63a5fe72c79a9f8366b7170913620c165104e79f Mon Sep 17 00:00:00 2001
From: "Reece R. Pollack" <x0183204@ti.com>
Date: Tue, 20 May 2014 16:28:09 -0400
Subject: [PATCH 104/257] hwqueue: keystone: Support "blended-scheduler" QoS
 node type

This patch adds support for the "blended-scheduler" QoS node type,
which allows a mix of "strict-priority" and "weighted-round-robin"
functionality in a single port. Child nodes containing a "priority"
attribute are treated as SP inputs, while child nodes with a
"weight" attribute are treated as WRR inputs. SP inputs are given
priority above WRR inputs.

Children with a new attribute, "low-priority", are treated as SP
inputs, except they are processed only when all SP and WRR input
queues are empty.

This exposes the full functionality of the underlying firmware and
can permit significant reduction in port usage.

Signed-off-by: Reece R. Pollack <x0183204@ti.com>
(cherry picked from commit 4a50250ecbafc422779f063050a60ebf16718bd8)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue_qos.c | 304 ++++++++++++++++++++++++---------
 drivers/hwqueue/keystone_qos.h         |   7 +-
 2 files changed, 231 insertions(+), 80 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue_qos.c b/drivers/hwqueue/keystone_hwqueue_qos.c
index b2bc8a4..6db6052 100644
--- a/drivers/hwqueue/keystone_hwqueue_qos.c
+++ b/drivers/hwqueue/keystone_hwqueue_qos.c
@@ -1305,7 +1305,17 @@ static int khwq_qos_prio_check(struct ktree_node *child, void *arg)
 	struct khwq_qos_tree_node *node = arg;
 	struct khwq_qos_tree_node *sibling = to_qnode(child);
 
-	return (sibling->priority == node->priority) ? -EINVAL : 0;
+	return ((sibling->priority != -1) &&
+		(sibling->priority == node->priority)) ? -EINVAL : 0;
+}
+
+static int khwq_qos_lowprio_check(struct ktree_node *child, void *arg)
+{
+	struct khwq_qos_tree_node *node = arg;
+	struct khwq_qos_tree_node *sibling = to_qnode(child);
+
+	return ((sibling->low_priority != -1) &&
+		(sibling->low_priority == node->low_priority)) ? -EINVAL : 0;
 }
 
 struct khwq_qos_drop_policy *
@@ -1383,7 +1393,7 @@ static ssize_t qnode_weight_store(struct khwq_qos_tree_node *qnode,
 	int inputs, i, error, val, idx;
 	u64 scale, tmp;
 
-	if (!parent || parent->type != QOS_NODE_WRR)
+	if (!parent || (parent->wrr_children == 0))
 		return -EINVAL;
 
 	error = kstrtouint(buf, 0, &weight);
@@ -1400,7 +1410,7 @@ static ssize_t qnode_weight_store(struct khwq_qos_tree_node *qnode,
 	parent->child_weight[qnode->parent_input] = weight;
 
 	inputs = parent->child_count;
-	scale = inputs * ((parent->acct == QOS_BYTE_ACCT) ?
+	scale = parent->wrr_children * ((parent->acct == QOS_BYTE_ACCT) ?
 				QOS_BYTE_NORMALIZATION_FACTOR :
 				QOS_PACKET_NORMALIZATION_FACTOR);
 	scale <<= 48;
@@ -1418,17 +1428,21 @@ static ssize_t qnode_weight_store(struct khwq_qos_tree_node *qnode,
 			queue = i;
 		}
 
-		tmp = parent->child_weight[i];
-		tmp *= scale;
+		val = 0;
+		if ((i >= parent->prio_children) &&
+		    (i < (parent->prio_children + parent->wrr_children))) {
+			tmp = parent->child_weight[i];
+			tmp *= scale;
 
-		if (parent->acct == QOS_BYTE_ACCT) {
-			tmp += 1ULL << (47 - QOS_CREDITS_BYTE_SHIFT);
-			tmp >>= (48 - QOS_CREDITS_BYTE_SHIFT);
-		} else {
-			tmp += 1ULL << (47 - QOS_CREDITS_PACKET_SHIFT);
-			tmp >>= (48 - QOS_CREDITS_PACKET_SHIFT);
+			if (parent->acct == QOS_BYTE_ACCT) {
+				tmp += 1ULL << (47 - QOS_CREDITS_BYTE_SHIFT);
+				tmp >>= (48 - QOS_CREDITS_BYTE_SHIFT);
+			} else {
+				tmp += 1ULL << (47 - QOS_CREDITS_PACKET_SHIFT);
+				tmp >>= (48 - QOS_CREDITS_PACKET_SHIFT);
+			}
+			val = (u32)(tmp);
 		}
-		val = (u32)(tmp);
 
 		khwq_qos_set_sched_wrr_credit(info, port, queue, val, (queue == 0));
 	}
@@ -1445,6 +1459,15 @@ static ssize_t qnode_priority_show(struct khwq_qos_tree_node *qnode,
 	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->priority);
 }
 
+static ssize_t qnode_lowprio_show(struct khwq_qos_tree_node *qnode,
+					     char *buf)
+{
+	if (qnode->low_priority == -1)
+		return -EINVAL;
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", qnode->low_priority);
+}
+
 static ssize_t qnode_output_rate_show(struct khwq_qos_tree_node *qnode,
 					     char *buf)
 {
@@ -1648,6 +1671,8 @@ static KHWQ_QOS_QNODE_ATTR(drop_policy, S_IRUGO, qnode_drop_policy_show,
 			   NULL);
 static KHWQ_QOS_QNODE_ATTR(priority, S_IRUGO,
 			   qnode_priority_show, NULL);
+static KHWQ_QOS_QNODE_ATTR(low_priority, S_IRUGO,
+			   qnode_lowprio_show, NULL);
 static KHWQ_QOS_QNODE_ATTR(output_queue, S_IRUGO,
 			   qnode_output_queue_show,
 			   NULL);
@@ -1695,6 +1720,17 @@ static struct attribute *khwq_qos_qnode_sysfs_wrr_attrs[] = {
 	NULL
 };
 
+static struct attribute *khwq_qos_qnode_sysfs_lowprio_attrs[] = {
+	&attr_qnode_stats_class.attr,
+	&attr_qnode_drop_policy.attr,
+	&attr_qnode_low_priority.attr,
+	&attr_qnode_output_rate.attr,
+	&attr_qnode_burst_size.attr,
+	&attr_qnode_overhead_bytes.attr,
+	&attr_qnode_input_queues.attr,
+	NULL
+};
+
 static ssize_t khwq_qos_qnode_attr_show(struct kobject *kobj,
 				 struct attribute *attr, char *buf)
 {
@@ -1742,6 +1778,13 @@ static struct kobj_type khwq_qos_qnode_priority_ktype = {
 	.default_attrs = khwq_qos_qnode_sysfs_priority_attrs,
 };
 
+static struct kobj_type khwq_qos_qnode_lowprio_ktype = {
+	.sysfs_ops = &(struct sysfs_ops) {
+		.show = khwq_qos_qnode_attr_show,
+		.store = khwq_qos_qnode_attr_store},
+	.default_attrs = khwq_qos_qnode_sysfs_lowprio_attrs,
+};
+
 static struct kobj_type khwq_qos_qnode_wrr_ktype = {
 	.sysfs_ops = &(struct sysfs_ops) {
 		.show = khwq_qos_qnode_attr_show,
@@ -1752,10 +1795,31 @@ static struct kobj_type khwq_qos_qnode_wrr_ktype = {
 static int khwq_qos_cmp(struct ktree_node *_a, struct ktree_node *_b,
 			void *arg)
 {
-	void *a = to_qnode(_a);
-	void *b = to_qnode(_b);
-	int offset = (int)arg;
-	return *((u32 *)(a + offset)) - *((u32 *)(b + offset));
+	struct khwq_qos_tree_node *a = to_qnode(_a);
+	struct khwq_qos_tree_node *b = to_qnode(_b);
+
+	if ((a->priority != -1) && (b->priority != -1))
+		return a->priority - b->priority;
+	if (a->priority != -1)
+		return -1;
+	if (b->priority != -1)
+		return 1;
+
+	if ((a->weight != -1) && (b->weight != -1))
+		return 0;
+	if (a->weight != -1)
+		return -1;
+	if (b->weight != -1)
+		return 1;
+
+	if ((a->low_priority != -1) && (b->low_priority != -1))
+		return a->low_priority - b->low_priority;
+	if (a->low_priority != -1)
+		return -1;
+	if (b->low_priority != -1)
+		return 1;
+
+	return 0;
 }
 
 static int khwq_qos_check_overflow(struct khwq_qos_tree_node *qnode,
@@ -1806,30 +1870,6 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	qnode->parent = parent;
 	qnode->name = node->name;
 
-	if (!parent)
-		error = kobject_init_and_add(&qnode->kobj,
-					     &khwq_qos_qnode_default_ktype,
-					     parent_kobj, qnode->name);
-	else {
-		if (parent->type == QOS_NODE_PRIO)
-			error = kobject_init_and_add(&qnode->kobj,
-					     &khwq_qos_qnode_priority_ktype,
-					     parent_kobj, qnode->name);
-		else if (parent->type == QOS_NODE_WRR)
-			error = kobject_init_and_add(&qnode->kobj,
-					     &khwq_qos_qnode_wrr_ktype,
-					     parent_kobj, qnode->name);
-		else
-			error = kobject_init_and_add(&qnode->kobj,
-					     &khwq_qos_qnode_default_ktype,
-					     parent_kobj, qnode->name);
-	}
-	if (error) {
-		dev_err(kdev->dev, "failed to create sysfs "
-			"entries for qnode %s\n", qnode->name);
-		goto error_destroy;
-	}
-
 	of_property_read_string(node, "label", &qnode->name);
 	dev_dbg(kdev->dev, "processing node %s, parent %s%s\n",
 		qnode->name, parent ? parent->name : "(none)",
@@ -1847,14 +1887,23 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 		}
 		qnode->type = QOS_NODE_WRR;
 	}
+	if (of_find_property(node, "blended-scheduler", NULL)) {
+		if (qnode->type != QOS_NODE_DEFAULT) {
+			dev_err(kdev->dev, "multiple node types in %s\n",
+				qnode->name);
+			error = -EINVAL;
+			goto error_free;
+		}
+		qnode->type = QOS_NODE_BLENDED;
+	}
 	if (!parent && qnode->type == QOS_NODE_DEFAULT) {
-		dev_err(kdev->dev, "root node %s must be wrr/prio\n",
+		dev_err(kdev->dev, "root node %s must be wrr/prio/blended\n",
 			qnode->name);
 		error = -EINVAL;
 		goto error_free;
 	}
 	if (!has_children && qnode->type != QOS_NODE_DEFAULT) {
-		dev_err(kdev->dev, "leaf node %s must not be wrr/prio\n",
+		dev_err(kdev->dev, "leaf node %s must not be wrr/prio/blended\n",
 			qnode->name);
 		error = -EINVAL;
 		goto error_free;
@@ -1863,53 +1912,113 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	dev_dbg(kdev->dev, "node %s: type %d\n", qnode->name, qnode->type);
 
 	qnode->weight = -1;
-	of_property_read_u32(node, "weight", &qnode->weight);
-	if (qnode->weight != -1) {
+	if (!of_property_read_u32(node, "weight", &qnode->weight)) {
+		dev_dbg(kdev->dev, "node %s: weight %d\n",
+			qnode->name, qnode->weight);
 		if (qnode->weight == 0 || qnode->weight > QOS_MAX_WEIGHT) {
-			dev_err(kdev->dev, "weight must be between 1 and %d\n",
-				QOS_MAX_WEIGHT);
+			dev_err(kdev->dev,
+				"node %s: weight must be between 1 and %u\n",
+				qnode->name, QOS_MAX_WEIGHT);
 			error = -EINVAL;
 			goto error_free;
 		}
-		if (!parent || parent->type != QOS_NODE_WRR) {
-			dev_err(kdev->dev, "unexpected weight on node %s\n",
+		if (!parent ||
+		    ((parent->type != QOS_NODE_WRR) &&
+		     (parent->type != QOS_NODE_BLENDED))) {
+			dev_err(kdev->dev, "node %s: unexpected weight\n",
 				qnode->name);
 			error = -EINVAL;
 			goto error_free;
 		}
+		++parent->wrr_children;
 	} else if (parent && parent->type == QOS_NODE_WRR) {
-		dev_err(kdev->dev, "expected weight on wrr child node %s\n",
+		dev_err(kdev->dev, "node %s: missing weight on wrr child\n",
 			qnode->name);
 		error = -EINVAL;
 		goto error_free;
 	}
-	dev_dbg(kdev->dev, "node %s: weight %d\n", qnode->name, qnode->weight);
 
 	qnode->priority = -1;
-	of_property_read_u32(node, "priority", &qnode->priority);
-	if (qnode->priority != -1) {
-		if (!parent || parent->type != QOS_NODE_PRIO) {
-			dev_err(kdev->dev, "unexpected priority on node %s\n",
+	if (!of_property_read_u32(node, "priority", &qnode->priority)) {
+		dev_dbg(kdev->dev, "node %s: priority %d\n",
+			qnode->name, qnode->priority);
+		if (qnode->priority == -1) {
+			dev_err(kdev->dev,
+				"node %s: priority must be between 0 and %u\n",
+				qnode->name, U32_MAX - 1);
+			error = -EINVAL;
+			goto error_free;
+		}
+		if (!parent ||
+		    ((parent->type != QOS_NODE_PRIO) &&
+		     (parent->type != QOS_NODE_BLENDED))) {
+			dev_err(kdev->dev, "node %s: unexpected priority\n",
 				qnode->name);
 			error = -EINVAL;
 			goto error_free;
 		}
+		++parent->prio_children;
 		error = ktree_for_each_child(&parent->node,
-					     khwq_qos_prio_check, qnode);
+					     khwq_qos_prio_check,
+					     qnode);
 		if (error) {
-			dev_err(kdev->dev, "duplicate priority %d on node %s\n",
-				qnode->priority, qnode->name);
+			dev_err(kdev->dev, "node %s: duplicate priority %d\n",
+				qnode->name, qnode->priority);
 			error = -EINVAL;
 			goto error_free;
 		}
 	} else if (parent && parent->type == QOS_NODE_PRIO) {
-		dev_err(kdev->dev, "expected prio on strict prio child %s\n",
+		dev_err(kdev->dev,
+			"node %s: missing priority on strict-priority child\n",
 			qnode->name);
 		error = -EINVAL;
 		goto error_free;
 	}
-	dev_dbg(kdev->dev, "node %s: priority %d\n", qnode->name,
-		qnode->priority);
+
+	qnode->low_priority = -1;
+	if (!of_property_read_u32(node, "low-priority", &qnode->low_priority)) {
+		dev_dbg(kdev->dev, "node %s: low-priority %d\n",
+			qnode->name, qnode->low_priority);
+		if (qnode->low_priority == -1) {
+			dev_err(kdev->dev,
+				"node %s: low-priority must be between 0 and %u\n",
+				qnode->name, U32_MAX - 1);
+			error = -EINVAL;
+			goto error_free;
+		}
+		if (!parent ||
+		    (parent->type != QOS_NODE_BLENDED)) {
+			dev_err(kdev->dev,
+				"node %s: unexpected low-priority\n",
+				qnode->name);
+			error = -EINVAL;
+			goto error_free;
+		}
+		++parent->lowprio_children;
+		error = ktree_for_each_child(&parent->node,
+					     khwq_qos_lowprio_check,
+					     qnode);
+		if (error) {
+			dev_err(kdev->dev,
+				"node %s: duplicate low-priority %d\n",
+				qnode->name, qnode->low_priority);
+			error = -EINVAL;
+			goto error_free;
+		}
+	}
+
+	if (parent && (parent->type == QOS_NODE_BLENDED)) {
+		if ((qnode->weight == -1) &&
+		    (qnode->priority == -1) &&
+		    (qnode->low_priority == -1)) {
+			dev_err(kdev->dev,
+				"node %s: missing weight or priority on "
+				"blended-scheduler child\n",
+				qnode->name);
+			error = -EINVAL;
+			goto error_free;
+		}
+	}
 
 	qnode->acct = QOS_BYTE_ACCT;
 	if (of_find_property(node, "byte-units", NULL))
@@ -2050,6 +2159,39 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 	}
 
 	if (!parent)
+		error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_default_ktype,
+					     parent_kobj, qnode->name);
+	else {
+		if ((parent->type == QOS_NODE_PRIO) ||
+		    ((parent->type == QOS_NODE_BLENDED) &&
+		     (qnode->priority != -1)))
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_priority_ktype,
+					     parent_kobj, qnode->name);
+		else if ((parent->type == QOS_NODE_WRR) ||
+			 ((parent->type == QOS_NODE_BLENDED) &&
+			  (qnode->weight != -1)))
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_wrr_ktype,
+					     parent_kobj, qnode->name);
+		else if ((parent->type == QOS_NODE_BLENDED) &&
+			 (qnode->low_priority != -1))
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_lowprio_ktype,
+					     parent_kobj, qnode->name);
+		else
+			error = kobject_init_and_add(&qnode->kobj,
+					     &khwq_qos_qnode_default_ktype,
+					     parent_kobj, qnode->name);
+	}
+	if (error) {
+		dev_err(kdev->dev, "failed to create sysfs "
+			"entries for qnode %s\n", qnode->name);
+		goto error_destroy;
+	}
+
+	if (!parent)
 		ktree_set_root(&info->qos_tree, &qnode->node);
 	else
 		ktree_add_child_last(&parent->node, &qnode->node);
@@ -2091,10 +2233,8 @@ static int khwq_qos_tree_parse(struct khwq_qos_info *info,
 		goto error_destroy;
 	}
 
-	if (qnode->type == QOS_NODE_PRIO) {
-		int o = offsetof(struct khwq_qos_tree_node, priority);
-		ktree_sort_children(&qnode->node, khwq_qos_cmp, (void *)o);
-	}
+	if (num_children > 1)
+		ktree_sort_children(&qnode->node, khwq_qos_cmp, NULL);
 
 	return 0;
 
@@ -2142,8 +2282,9 @@ static int khwq_qos_tree_map_nodes(struct ktree_node *node, void *arg)
 
 	ktree_for_each_child(&qnode->node, khwq_qos_tree_map_nodes, info);
 
-	qnode->has_sched_port = (qnode->type == QOS_NODE_PRIO	||
-				 qnode->type == QOS_NODE_WRR	||
+	qnode->has_sched_port = (qnode->type == QOS_NODE_PRIO	 ||
+				 qnode->type == QOS_NODE_WRR	 ||
+				 qnode->type == QOS_NODE_BLENDED ||
 				 qnode->child_port_count);
 
 	if (qnode->has_sched_port && parent)
@@ -2331,23 +2472,23 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 		return error;
 
 	inputs = (qnode->type == QOS_NODE_DEFAULT) ? 1 : qnode->child_count;
-	
+
 	error = khwq_qos_set_sched_total_q_count(info, idx, inputs, sync);
 	if (WARN_ON(error))
 		return error;
 
-	val = (qnode->type == QOS_NODE_PRIO) ? inputs : 0;
-	error = khwq_qos_set_sched_sp_q_count(info, idx, val, sync);
+	error = khwq_qos_set_sched_sp_q_count(info, idx, qnode->prio_children,
+						sync);
 	if (WARN_ON(error))
 		return error;
 
-	val = (qnode->type == QOS_NODE_WRR) ? inputs : 0;
-	error = khwq_qos_set_sched_wrr_q_count(info, idx, val, sync);
+	error = khwq_qos_set_sched_wrr_q_count(info, idx, qnode->wrr_children,
+						sync);
 	if (WARN_ON(error))
 		return error;
 
-	if (qnode->type == QOS_NODE_WRR) {
-		scale = inputs * ((qnode->acct == QOS_BYTE_ACCT) ?
+	if (qnode->wrr_children > 0) {
+		scale = qnode->wrr_children * ((qnode->acct == QOS_BYTE_ACCT) ?
 					QOS_BYTE_NORMALIZATION_FACTOR :
 					QOS_PACKET_NORMALIZATION_FACTOR);
 		scale <<= 48;
@@ -2371,7 +2512,8 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 			return error;
 
 		val = 0;
-		if (qnode->type == QOS_NODE_WRR) {
+		if ((i >= qnode->prio_children) &&
+		    (i < (qnode->prio_children + qnode->wrr_children))) {
 			tmp = qnode->child_weight[i];
 			tmp *= scale;
 
@@ -2412,25 +2554,29 @@ static int khwq_qos_tree_start_port(struct khwq_qos_info *info,
 	/* If this is a Lite-Joint port pair, configure the Odd port here */
 	if (qnode->is_joint_port) {
 		int odd_idx = khwq_qos_id_odd(idx);
-		int odd_inputs = (inputs <= info->inputs_per_port) ? 0 :
-					(inputs - info->inputs_per_port);
 
 		error = khwq_qos_set_sched_unit_flags(info, odd_idx,
 					QOS_SCHED_FLAG_IS_JOINT, sync);
 		if (WARN_ON(error))
 			return error;
 
+		val = (inputs <= info->inputs_per_port) ? 0 :
+				inputs - info->inputs_per_port;
 		error = khwq_qos_set_sched_total_q_count(info, odd_idx,
-							 odd_inputs, sync);
+							 val, sync);
 		if (WARN_ON(error))
 			return error;
 
-		val = (qnode->type == QOS_NODE_PRIO) ? odd_inputs : 0;
+		val = (qnode->prio_children <= info->inputs_per_port) ? 0 :
+				qnode->prio_children - info->inputs_per_port;
 		error = khwq_qos_set_sched_sp_q_count(info, odd_idx, val, sync);
 		if (WARN_ON(error))
 			return error;
 
-		val = (qnode->type == QOS_NODE_WRR) ? odd_inputs : 0;
+		val = ((qnode->prio_children + qnode->wrr_children)
+					<= info->inputs_per_port) ? 0 :
+			qnode->wrr_children -
+				(info->inputs_per_port - qnode->prio_children);
 		error = khwq_qos_set_sched_wrr_q_count(info, odd_idx, val, sync);
 		if (WARN_ON(error))
 			return error;
diff --git a/drivers/hwqueue/keystone_qos.h b/drivers/hwqueue/keystone_qos.h
index c8c5263..81fe08d 100644
--- a/drivers/hwqueue/keystone_qos.h
+++ b/drivers/hwqueue/keystone_qos.h
@@ -86,9 +86,10 @@ enum khwq_qos_drop_mode {
 };
 
 enum khwq_qos_tree_node_type {
+	QOS_NODE_DEFAULT,
 	QOS_NODE_PRIO,
 	QOS_NODE_WRR,
-	QOS_NODE_DEFAULT,
+	QOS_NODE_BLENDED,
 };
 
 enum khwq_qos_shadow_type {
@@ -207,6 +208,10 @@ struct khwq_qos_tree_node {
 	enum khwq_qos_tree_node_type	 type;
 	u32				 weight;
 	u32				 priority;
+	u32				 low_priority;
+	int				 prio_children;
+	int				 wrr_children;
+	int				 lowprio_children;
 	enum khwq_qos_accounting_type	 acct;
 	const char			*name;
 	int				 overhead_bytes;
-- 
2.7.4

