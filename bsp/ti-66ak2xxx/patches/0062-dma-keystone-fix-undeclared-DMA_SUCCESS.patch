From 59b53d91892be514124c02b3b38d33b3c3b468f4 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 13 Apr 2015 16:04:23 +0800
Subject: [PATCH 062/257] dma: keystone: fix undeclared DMA_SUCCESS

Because DMA_SUCCESS has been replaced by DMA_COMPLETE, so we fix
them as well.

drivers/dma/keystone-udma.c: In function 'udma_chan_complete_rx':
drivers/dma/keystone-udma.c:267:16: error: 'DMA_SUCCESS' undeclared (first use in this function)
  if (status == DMA_SUCCESS)

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/dma/keystone-pktdma.c               |  6 +++---
 drivers/dma/keystone-udma.c                 | 11 ++++++-----
 drivers/net/ethernet/ti/keystone_net_core.c |  4 ++--
 drivers/net/ethernet/ti/keystone_pa.c       |  2 +-
 drivers/net/ethernet/ti/keystone_pa2.c      |  2 +-
 5 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/drivers/dma/keystone-pktdma.c b/drivers/dma/keystone-pktdma.c
index b44b5fb..716e58f 100644
--- a/drivers/dma/keystone-pktdma.c
+++ b/drivers/dma/keystone-pktdma.c
@@ -716,7 +716,7 @@ static void chan_complete_callback(void *arg)
 		chan->notify_info.fn(to_achan(chan), chan->notify_info.fn_arg);
 	} else {
 		chan_dbg(chan, "notify - processing packets\n");
-		chan_complete(chan, chan->q_complete, DMA_SUCCESS, -1, false);
+		chan_complete(chan, chan->q_complete, DMA_COMPLETE, -1, false);
 		chan_dbg(chan, "notify - processing complete\n");
 	}
 }
@@ -1049,7 +1049,7 @@ static void chan_stop(struct keystone_dma_chan *chan)
 	/* wait for active transfers to complete */
 	end = jiffies + msecs_to_jiffies(DMA_TIMEOUT);
 	do {
-		chan_complete(chan, chan->q_complete, DMA_SUCCESS, -1, false);
+		chan_complete(chan, chan->q_complete, DMA_COMPLETE, -1, false);
 		if (!atomic_read(&chan->n_used_descs))
 			break;
 		schedule_timeout(DMA_TIMEOUT / 10);
@@ -1435,7 +1435,7 @@ static int chan_poll(struct keystone_dma_chan *chan, int budget)
 	int packets;
 
 	chan_dbg(chan, "channel poll beginning, budget %d\n", budget);
-	packets = chan_complete(chan, chan->q_complete, DMA_SUCCESS, budget,
+	packets = chan_complete(chan, chan->q_complete, DMA_COMPLETE, budget,
 				true);
 	chan_dbg(chan, "channel poll complete, processed %d\n", packets);
 
diff --git a/drivers/dma/keystone-udma.c b/drivers/dma/keystone-udma.c
index 2136621..5fe04f2 100644
--- a/drivers/dma/keystone-udma.c
+++ b/drivers/dma/keystone-udma.c
@@ -28,6 +28,7 @@
 #include <linux/dma-contiguous.h>
 #include <linux/anon_inodes.h>
 #include <linux/poll.h>
+#include <linux/file.h>
 #include <linux/workqueue.h>
 #include <linux/keystone-dma.h>
 
@@ -264,7 +265,7 @@ static void udma_chan_complete_rx(struct udma_chan *chan,
 	/* return desc to the used list */
 	used_idx = vring->used->idx & (vring->num - 1);
 	vring->used->ring[used_idx].id = id;
-	if (status == DMA_SUCCESS)
+	if (status == DMA_COMPLETE)
 		vring->used->ring[used_idx].len = req->sg[0].length;
 	else
 		vring->used->ring[used_idx].len = -1;
@@ -273,7 +274,7 @@ static void udma_chan_complete_rx(struct udma_chan *chan,
 
 	dev_vdbg(udma_user_dev(user), "(%s) used %d, status %s\n",
 		 udma_chan_name(chan), vring->used->idx,
-		 (status == DMA_SUCCESS) ? "success" : "error");
+		 (status == DMA_COMPLETE) ? "success" : "error");
 }
 
 static void udma_chan_complete_rx_cb(void *data)
@@ -281,7 +282,7 @@ static void udma_chan_complete_rx_cb(void *data)
 	struct udma_request *req = data;
 	struct udma_chan *chan = req->chan;
 
-	udma_chan_complete_rx(chan, req, DMA_SUCCESS);
+	udma_chan_complete_rx(chan, req, DMA_COMPLETE);
 }
 
 static struct dma_async_tx_descriptor *udma_rxpool_alloc(void *arg,
@@ -460,7 +461,7 @@ static void udma_chan_complete_tx(struct udma_chan *chan,
 	/* return desc to the used list */
 	used_idx = vring->used->idx & (vring->num - 1);
 	vring->used->ring[used_idx].id = id;
-	if (status == DMA_SUCCESS)
+	if (status == DMA_COMPLETE)
 		vring->used->ring[used_idx].len = req->sg[0].length;
 	else
 		vring->used->ring[used_idx].len = -1;
@@ -469,7 +470,7 @@ static void udma_chan_complete_tx(struct udma_chan *chan,
 
 	dev_vdbg(udma_user_dev(user), "(%s) used %d, status %s\n",
 		 udma_chan_name(chan), vring->used->idx,
-		 (status == DMA_SUCCESS) ? "success" : "error");
+		 (status == DMA_COMPLETE) ? "success" : "error");
 }
 
 static void udma_chan_complete_tx_cb(void *data)
diff --git a/drivers/net/ethernet/ti/keystone_net_core.c b/drivers/net/ethernet/ti/keystone_net_core.c
index 56c3493..4d16cb5 100644
--- a/drivers/net/ethernet/ti/keystone_net_core.c
+++ b/drivers/net/ethernet/ti/keystone_net_core.c
@@ -673,7 +673,7 @@ static void netcp_rx_complete(void *data)
 
 	status = dma_async_is_tx_complete(netcp->rx_channel,
 					  p_info->cookie, NULL, NULL);
-	WARN_ONCE((status != DMA_SUCCESS && status != DMA_ERROR),
+	WARN_ONCE((status != DMA_COMPLETE && status != DMA_ERROR),
 		"in netcp_rx_complete dma status: %d\n", status);
 	WARN_ONCE((netcp->rx_state != RX_STATE_POLL	 &&
 		   netcp->rx_state != RX_STATE_TEARDOWN),
@@ -733,7 +733,7 @@ static void netcp_rx_complete(void *data)
 		return;
 	}
 
-	if (unlikely(status != DMA_SUCCESS)) {
+	if (unlikely(status != DMA_COMPLETE)) {
 		dev_warn(netcp->dev,
 			 "receive: reclaimed packet %p, status %d, state %s\n",
 			 p_info, status, netcp_rx_state_str(netcp));
diff --git a/drivers/net/ethernet/ti/keystone_pa.c b/drivers/net/ethernet/ti/keystone_pa.c
index f37f7ef..fe353ba 100644
--- a/drivers/net/ethernet/ti/keystone_pa.c
+++ b/drivers/net/ethernet/ti/keystone_pa.c
@@ -817,7 +817,7 @@ static void pa_tx_dma_callback(void *data)
 	else {
 		status = dma_async_is_tx_complete(p_info->chan,
 						  cookie, NULL, NULL);
-		WARN((status != DMA_SUCCESS),
+		WARN((status != DMA_COMPLETE),
 				"dma completion failure, status == %d", status);
 	}
 
diff --git a/drivers/net/ethernet/ti/keystone_pa2.c b/drivers/net/ethernet/ti/keystone_pa2.c
index 4cf4228..4bf048d 100644
--- a/drivers/net/ethernet/ti/keystone_pa2.c
+++ b/drivers/net/ethernet/ti/keystone_pa2.c
@@ -1578,7 +1578,7 @@ static void pa2_tx_dma_callback(void *data)
 	else {
 		status = dma_async_is_tx_complete(p_info->chan,
 						  cookie, NULL, NULL);
-		WARN((status != DMA_SUCCESS),
+		WARN((status != DMA_COMPLETE),
 				"dma completion failure, status == %d", status);
 	}
 
-- 
2.7.4

