From e74a900746e3ade4a013afd6f1fa3ce18872290b Mon Sep 17 00:00:00 2001
From: Cyril Chemparathy <cyril@ti.com>
Date: Tue, 23 Oct 2012 11:59:20 -0400
Subject: [PATCH 068/256] hwqueue: keystone: add support for pdsps

hwqueue: write firmware in big endian format

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
(cherry picked from commit ef0c20740a56e711e1c5f01fdf5ef3f52cb1cae7)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/hwqueue/keystone_hwqueue.c |  209 +++++++++++++++++++++++++++++++++++-
 drivers/hwqueue/keystone_hwqueue.h |   40 +++++++
 2 files changed, 247 insertions(+), 2 deletions(-)

diff --git a/drivers/hwqueue/keystone_hwqueue.c b/drivers/hwqueue/keystone_hwqueue.c
index 300b77d..8470652 100644
--- a/drivers/hwqueue/keystone_hwqueue.c
+++ b/drivers/hwqueue/keystone_hwqueue.c
@@ -34,6 +34,27 @@
 #include "hwqueue_internal.h"
 #include "keystone_hwqueue.h"
 
+static inline int khwq_pdsp_wait(u32 * __iomem addr, unsigned timeout,
+				 u32 flags)
+{
+	unsigned long end_time;
+	u32 val = 0;
+	int ret;
+
+	end_time = jiffies + msecs_to_jiffies(timeout);
+	while (jiffies < end_time) {
+		val = __raw_readl(addr);
+		if (flags)
+			val &= flags;
+		if (!val)
+			break;
+		cpu_relax();
+	}
+	ret = val ? -ETIMEDOUT : 0;
+
+	return ret;
+}
+
 static int khwq_match(struct hwqueue_instance *inst, unsigned flags)
 {
 	struct khwq_instance *kq = hwqueue_inst_to_priv(inst);
@@ -827,6 +848,172 @@ static int khwq_init_qmgrs(struct khwq_device *kdev, struct device_node *qmgrs)
 	return 0;
 }
 
+static int khwq_init_pdsps(struct khwq_device *kdev, struct device_node *pdsps)
+{
+	struct device *dev = kdev->dev;
+	struct khwq_pdsp_info *pdsp;
+	struct device_node *child;
+	int ret;
+
+	for_each_child_of_node(pdsps, child) {
+
+		pdsp = devm_kzalloc(dev, sizeof(*pdsp), GFP_KERNEL);
+		if (!pdsp) {
+			dev_err(dev, "out of memory allocating pdsp\n");
+			return -ENOMEM;
+		}
+
+		pdsp->name = khwq_find_name(child);
+
+		ret = of_property_read_string(child, "firmware",
+					      &pdsp->firmware);
+		if (ret < 0 || !pdsp->firmware) {
+			dev_err(dev, "unknown firmware for pdsp %s\n",
+				pdsp->name);
+			kfree(pdsp);
+			continue;
+		}
+		dev_dbg(dev, "pdsp name %s fw name :%s\n",
+			pdsp->name, pdsp->firmware);
+
+		pdsp->iram	= of_iomap(child, 0);
+		pdsp->regs	= of_iomap(child, 1);
+		pdsp->intd	= of_iomap(child, 2);
+		pdsp->command	= of_iomap(child, 3);
+		if (!pdsp->command || !pdsp->iram || !pdsp->regs || !pdsp->intd) {
+			dev_err(dev, "failed to map pdsp %s regs\n",
+				pdsp->name);
+			if (pdsp->command)
+				devm_iounmap(dev, pdsp->command);
+			if (pdsp->iram)
+				devm_iounmap(dev, pdsp->iram);
+			if (pdsp->regs)
+				devm_iounmap(dev, pdsp->regs);
+			if (pdsp->intd)
+				devm_iounmap(dev, pdsp->intd);
+			kfree(pdsp);
+			continue;
+		}
+		of_property_read_u32(child, "id", &pdsp->id);
+
+		list_add_tail(&pdsp->list, &kdev->pdsps);
+
+		dev_dbg(dev, "added pdsp %s: command %p, iram %p, "
+			"regs %p, intd %p, firmware %s\n",
+			pdsp->name, pdsp->command, pdsp->iram, pdsp->regs,
+			pdsp->intd, pdsp->firmware);
+	}
+
+	return 0;
+}
+
+
+static int khwq_stop_pdsp(struct khwq_device *kdev,
+			  struct khwq_pdsp_info *pdsp)
+{
+	u32 val, timeout = 1000;
+	int ret;
+
+	val = __raw_readl(&pdsp->regs->control) & ~PDSP_CTRL_ENABLE;
+	__raw_writel(val, &pdsp->regs->control);
+
+	ret = khwq_pdsp_wait(&pdsp->regs->control, timeout, PDSP_CTRL_RUNNING);
+
+	if (ret < 0) {
+		dev_err(kdev->dev, "timed out on pdsp %s stop\n", pdsp->name);
+		return ret;
+	}
+	return 0;
+}
+
+static int khwq_load_pdsp(struct khwq_device *kdev,
+			  struct khwq_pdsp_info *pdsp)
+{
+	int i, ret, fwlen;
+	const struct firmware *fw;
+	u32 *fwdata;
+
+	ret = request_firmware(&fw, pdsp->firmware, kdev->dev);
+	if (ret) {
+		dev_err(kdev->dev, "failed to get firmware %s for pdsp %s\n",
+			pdsp->firmware, pdsp->name);
+		return ret;
+	}
+
+	/* download the firmware */
+	fwdata = (u32 *)fw->data;
+	fwlen = (fw->size + sizeof(u32) - 1) / sizeof(u32);
+
+	for (i = 0; i < fwlen; i++)
+		__raw_writel(be32_to_cpu(fwdata[i]), pdsp->iram + i);
+
+	release_firmware(fw);
+
+	return 0;
+}
+
+static int khwq_start_pdsp(struct khwq_device *kdev,
+			   struct khwq_pdsp_info *pdsp)
+{
+	u32 val, timeout = 1000;
+	int ret;
+
+	/* write a command for sync */
+	__raw_writel(0xffffffff, pdsp->command);
+	while (__raw_readl(pdsp->command) != 0xffffffff)
+		cpu_relax();
+
+	/* soft reset the PDSP */
+	val  = __raw_readl(&pdsp->regs->control);
+	val &= ~(PDSP_CTRL_PC_MASK | PDSP_CTRL_SOFT_RESET);
+	__raw_writel(val, &pdsp->regs->control);
+
+	/* enable pdsp */
+	val = __raw_readl(&pdsp->regs->control) | PDSP_CTRL_ENABLE;
+	__raw_writel(val, &pdsp->regs->control);
+
+	/* wait for command register to clear */
+	ret = khwq_pdsp_wait(pdsp->command, timeout, 0);
+
+	if (ret < 0) {
+		dev_err(kdev->dev, "timed out on pdsp %s command register wait\n",
+			pdsp->name);
+		return ret;
+	}
+	return 0;
+}
+
+static void khwq_stop_pdsps(struct khwq_device *kdev)
+{
+	struct khwq_pdsp_info *pdsp;
+
+	/* disable all pdsps */
+	for_each_pdsp(kdev, pdsp)
+		khwq_stop_pdsp(kdev, pdsp);
+}
+
+static int khwq_start_pdsps(struct khwq_device *kdev)
+{
+	struct khwq_pdsp_info *pdsp;
+	int ret;
+
+	khwq_stop_pdsps(kdev);
+
+	/* now load them all */
+	for_each_pdsp(kdev, pdsp) {
+		ret = khwq_load_pdsp(kdev, pdsp);
+		if (ret < 0)
+			return ret;
+	}
+
+	for_each_pdsp(kdev, pdsp) {
+		ret = khwq_start_pdsp(kdev, pdsp);
+		WARN_ON(ret);
+	}
+
+	return 0;
+}
+
 static int khwq_init_queue(struct khwq_device *kdev,
 			   struct khwq_range_info *range,
 			   struct hwqueue_instance *inst)
@@ -870,7 +1057,7 @@ static int khwq_init_queues(struct khwq_device *kdev)
 static int khwq_probe(struct platform_device *pdev)
 {
 	struct device_node *node = pdev->dev.of_node;
-	struct device_node *qmgrs, *descs, *queues, *regions;
+	struct device_node *qmgrs, *descs, *queues, *regions, *pdsps;
 	struct device *dev = &pdev->dev;
 	struct hwqueue_device *hdev;
 	struct khwq_device *kdev;
@@ -894,7 +1081,12 @@ static int khwq_probe(struct platform_device *pdev)
 		dev_err(dev, "queues not specified\n");
 		return -ENODEV;
 	}
-
+	pdsps =  of_find_child_by_name(node, "pdsps");
+	BUG_ON(!pdsps);
+	if (!pdsps) {
+		dev_err(dev, "pdsp info not specified\n");
+		return -ENODEV;
+	}
 	descs =  of_find_child_by_name(node, "descriptors");
 	if (!descs) {
 		dev_err(dev, "descriptor pools not specified\n");
@@ -919,6 +1111,7 @@ static int khwq_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&kdev->qmgrs);
 	INIT_LIST_HEAD(&kdev->pools);
 	INIT_LIST_HEAD(&kdev->regions);
+	INIT_LIST_HEAD(&kdev->pdsps);
 
 	if (of_property_read_u32_array(node, "range", temp, 2)) {
 		dev_err(dev, "hardware queue range not specified\n");
@@ -937,6 +1130,17 @@ static int khwq_probe(struct platform_device *pdev)
 	 * and non-existant - needs to be fixed
 	 */
 
+	/* get pdsp configuration values from device tree */
+	if (pdsps) {
+		ret = khwq_init_pdsps(kdev, pdsps);
+		if (ret)
+			return ret;
+
+		ret = khwq_start_pdsps(kdev);
+		if (ret)
+			return ret;
+	}
+
 	/* get usable queue range values from device tree */
 	ret = khwq_setup_queue_ranges(kdev, queues);
 	if (ret)
@@ -946,6 +1150,7 @@ static int khwq_probe(struct platform_device *pdev)
 	ret = khwq_setup_pools(kdev, descs);
 	if (ret) {
 		khwq_free_queue_ranges(kdev);
+		khwq_stop_pdsps(kdev);
 		return ret;
 	}
 
diff --git a/drivers/hwqueue/keystone_hwqueue.h b/drivers/hwqueue/keystone_hwqueue.h
index fb28b9d..9f3c4a0 100644
--- a/drivers/hwqueue/keystone_hwqueue.h
+++ b/drivers/hwqueue/keystone_hwqueue.h
@@ -24,6 +24,11 @@
 #define THRESH_GTE	BIT(7)
 #define THRESH_LT	0
 
+#define PDSP_CTRL_PC_MASK	0xffff0000
+#define PDSP_CTRL_SOFT_RESET	BIT(0)
+#define PDSP_CTRL_ENABLE	BIT(1)
+#define PDSP_CTRL_RUNNING	BIT(15)
+
 struct khwq_reg_config {
 	u32		revision;
 	u32		__pad1;
@@ -49,6 +54,13 @@ struct khwq_reg_queue {
 	u32		ptr_size_thresh;
 };
 
+struct khwq_reg_pdsp_regs {
+	u32		control;
+	u32		status;
+	u32		cycle_count;
+	u32		stall_count;
+};
+
 struct khwq_region {
 	const char	*name;
 	unsigned	 used_desc;
@@ -80,6 +92,19 @@ struct khwq_link_ram_block {
 	size_t		 size;
 };
 
+struct khwq_pdsp_info {
+	const char				*name;
+	struct khwq_reg_pdsp_regs  __iomem	*regs;
+	union {
+		void __iomem				*command;
+	};
+	void __iomem				*intd;
+	u32 __iomem				*iram;
+	const char				*firmware;
+	u32					 id;
+	struct list_head			 list;
+};
+
 struct khwq_range_ops;
 
 struct khwq_range_info {
@@ -128,6 +153,7 @@ struct khwq_device {
 	unsigned			 base_id;
 	struct list_head		 queue_ranges;
 	struct list_head		 pools;
+	struct list_head		 pdsps;
 	struct list_head		 qmgrs;
 };
 
@@ -155,9 +181,23 @@ struct khwq_instance {
 #define for_each_pool(kdev, pool)				\
 	list_for_each_entry(pool, &kdev->pools, list)
 
+#define for_each_pdsp(kdev, pdsp)				\
+	list_for_each_entry(pdsp, &kdev->pdsps, list)
+
 #define for_each_qmgr(kdev, qmgr)				\
 	list_for_each_entry(qmgr, &kdev->qmgrs, list)
 
+static inline struct khwq_pdsp_info *
+khwq_find_pdsp(struct khwq_device *kdev, unsigned pdsp_id)
+{
+	struct khwq_pdsp_info *pdsp;
+
+	for_each_pdsp(kdev, pdsp)
+		if (pdsp_id == pdsp->id)
+			return pdsp;
+	return NULL;
+}
+
 static inline struct khwq_qmgr_info *
 khwq_find_qmgr(struct hwqueue_instance *inst)
 {
-- 
1.7.5.4

