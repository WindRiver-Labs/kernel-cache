From 42a7b1a5cfb47e3f59297f685b8ff02a4bbbcf67 Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Thu, 13 Mar 2008 21:56:44 -0700
Subject: [PATCH] cavium: Implement REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER

Enable options to change how to handle the thead pointer access,
either normal, direct, debug-PC, or debug-break.

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 arch/mips/kernel/traps.c |   39 +++++++++++++++++++++++++++++++++++++++
 1 files changed, 39 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 50ff35f..4ae80af 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -74,6 +74,18 @@ extern asmlinkage void handle_reserved(void);
 extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 	struct mips_fpu_struct *ctx, int has_fpu);
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+/* 	0 - Use the normal kernel emulation without any changes.
+	1 - Replace emulated instructions with direct accesses to the thread
+		register.
+	2 - Replace emulated instructions and log the replacement PC.
+	3 - Replace emulated instructions with break instructions. This will
+		cause programs to fail, but makes it easy to stop gdb on the
+		instruction. */
+static int thread_pointer_mode = 0;
+module_param(thread_pointer_mode, int, 0644);
+#endif
+
 void (*board_watchpoint_handler)(struct pt_regs *regs);
 void (*board_be_init)(void);
 int (*board_be_handler)(struct pt_regs *regs, int is_fixup);
@@ -543,6 +555,9 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 {
 	struct thread_info *ti = task_thread_info(current);
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	unsigned int __user *epc = (unsigned int __user *)regs->cp0_epc + ((regs->cp0_cause & CAUSEF_BD) != 0);
+#endif
 
 	if ((opcode & OPCODE) == SPEC3 && (opcode & FUNC) == RDHWR) {
 		int rd = (opcode & RD) >> 11;
@@ -570,12 +585,36 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+			if (thread_pointer_mode) {
+				unsigned int new_instruction = 0x00000025 | (26 << 21) | (rt << 11); /* move [rt], k0 */
+				if (thread_pointer_mode == 3)
+					new_instruction = 0x0000000d; /* break */
+				if (access_process_vm(current, (unsigned long)epc, &new_instruction, sizeof(new_instruction), 1) != sizeof(new_instruction))
+					printk(KERN_ERR "Failed to replaced emulated RDHWR at PC=%p\n", epc);
+				if (thread_pointer_mode == 2)
+					printk(KERN_INFO "Replaced emulated RDHWR at PC=%p with \"move $%d, k0\"\n", epc, rt);
+				else if (thread_pointer_mode == 3)
+					printk(KERN_INFO "Replaced emulated RDHWR at PC=%p with \"break\"\n", epc);
+			}
+#endif
 			return 0;
 		default:
 			return -1;
 		}
 	}
 
+#ifdef CONFIG_REPLACE_EMULATED_ACCESS_TO_THREAD_POINTER
+	else if (opcode == (0x00000025 | (26 << 21) | (3 << 11)) /* move v1, k0 */)
+	{
+		/* We need to flush the icache, not emulate an instruction. The EPC is wrong,
+			so we need to put it back to the old instruction */
+		//printk(KERN_INFO "Already replaced emulated RDHWR at PC=%p\n", epc);
+		regs->cp0_epc = (unsigned long)epc;
+		flush_cache_sigtramp((unsigned long)epc);
+		return 0;
+	}
+#endif
 	/* Not ours.  */
 	return -1;
 }
-- 
1.5.5.1

