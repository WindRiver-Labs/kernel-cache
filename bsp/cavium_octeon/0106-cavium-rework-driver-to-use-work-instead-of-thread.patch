From fa3948aba1c599be3e688b20c08236111a1a7eee Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:04 -0700
Subject: [PATCH] cavium: rework driver to use work instead of thread

Make driver use a work struct instead of a kernel thread.
The way the thread was written was causing a kernel dump
every two minutes, and it was eating 100% CPU.

Signed-off-by: Paul Gortmaker <Paul.Gortmaker@windriver.com>
---
 arch/mips/cavium-octeon/ebt3000_cf.c |   77 +++++++++++++---------------------
 1 files changed, 29 insertions(+), 48 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index 0a03d1e..fc14567 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -8,6 +8,7 @@
  * for more details.
  *
  * Copyright (C) 2005-2007 Cavium Networks
+ * Copyright (C) 2008 Wind River Systems
  */
 
 #include <linux/module.h>
@@ -24,7 +25,6 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <asm/delay.h>
-#include <linux/completion.h>
 
 #include "cvmx-app-init.h"
 #include "cvmx-sysinfo.h"
@@ -60,7 +60,7 @@ typedef struct {
 	struct hd_geometry geo;
 	spinlock_t lock;
 	struct request_queue *queue;
-	struct completion comp;
+	struct work_struct cf_work;
 	int is16bit;
 	int is_true_ide;	/* is16bit must also be set */
         int use_dma;      
@@ -753,7 +753,7 @@ static void ebt3000_cf_request(struct request_queue * q)
 	struct request *req = elv_next_request(q);
 	if (req) {
 		cf_device_t *cf = req->rq_disk->private_data;
-		complete(&cf->comp);
+		schedule_work(&cf->cf_work);
 	}
 }
 
@@ -795,52 +795,36 @@ int ebt3000_cf_ioctl(struct inode *inode, struct file *filp,
  * @param cf_obj The compact flash device
  * @return Never returns
  */
-int ebt3000_cf_work(void *cf_obj)
+static void ebt3000_cf_work(struct work_struct *work)
 {
-	cf_device_t *cf = cf_obj;
-	struct request *req;
+	cf_device_t *cf = container_of(work, cf_device_t, cf_work);
+	struct request *req = NULL;
 	unsigned long flags;
 
-	/* Give ourself a nice name and become a daemon */
-	daemonize("octeon_%s", cf->gd->disk_name);
-
-
-	/* Loop forever waiting for IO requests */
-	while (1) {
-		/* Wait for the queue request handler to signal us there are
-		   requests available */
-		wait_for_completion(&cf->comp);
-
-		/* We need the queue lock */
-		spin_lock_irqsave(&cf->lock, flags);
-
-		/* Loop through all the pending requests */
-		while ((req = elv_next_request(cf->queue)) != NULL) {
-			if (!blk_fs_request(req)) {
-				printk("%s: Skip non-CMD request\n",
-				       req->rq_disk->disk_name);
-				end_request(req, 0);
-			} else {
-				int count;
-				/* Give away the lock while we're doing the
-				   slow IOs */
-				spin_unlock_irqrestore(&cf->lock, flags);
-				count = ebt3000_cf_transfer(cf, req->sector,
-							    req->
-							    current_nr_sectors,
-							    req->buffer,
-							    rq_data_dir(req));
-				/* We need the lock again to signal completion */
-				spin_lock_irqsave(&cf->lock, flags);
-				if (count == req->current_nr_sectors)
-					end_request(req, 1);
-				else
-					end_request(req, -EIO);
-			}
+	/* We need the queue lock */
+	spin_lock_irqsave(&cf->lock, flags);
+
+	/* Loop through all the pending requests */
+	while ((req = elv_next_request(cf->queue)) != NULL) {
+		if (!blk_fs_request(req)) {
+			printk("%s: Skip non-CMD request\n",
+			       req->rq_disk->disk_name);
+			end_request(req, 0);
+		} else {
+			int count;
+			/* Give away the lock while we're doing the
+			   slow IOs */
+			count = ebt3000_cf_transfer(cf, req->sector,
+					req-> current_nr_sectors,
+					req->buffer, rq_data_dir(req));
+			/* We need the lock again to signal completion */
+			if (count == req->current_nr_sectors)
+				end_request(req, 1);
+			else
+				end_request(req, -EIO);
 		}
-		spin_unlock_irqrestore(&cf->lock, flags);
 	}
-	return 0;
+	spin_unlock_irqrestore(&cf->lock, flags);
 }
 
 
@@ -896,7 +880,7 @@ static int __init ebt3000_cf_init(void)
 		cf->is_true_ide = 1;
 
 	spin_lock_init(&cf->lock);
-	init_completion(&cf->comp);
+	INIT_WORK(&cf->cf_work, ebt3000_cf_work);
 
 	/* Get a request queue. */
 	cf->queue = blk_init_queue(ebt3000_cf_request, &cf->lock);
@@ -958,9 +942,6 @@ static int __init ebt3000_cf_init(void)
 	set_capacity(cf->gd,
 		     cf->num_sectors * (cf->sector_size / KERNEL_SECTOR_SIZE));
 
-	/* Create a kernel thread for doing the real IO operations */
-	kernel_thread(ebt3000_cf_work, cf, 0);
-
 	add_disk(cf->gd);
 
 	return 0;
-- 
1.5.5.1

