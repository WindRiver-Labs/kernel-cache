From e31aa994823d3bdfb3f1c549ae0b3b0cbb1313d0 Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Tue, 25 Mar 2008 16:21:46 -0700
Subject: [PATCH] cavium: rework driver to use work instead of thread

Make driver use a work struct instead of a kernel thread.
The way the thread was written was causing a kernel dump
every two minutes, and it was eating 100% CPU.

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 arch/mips/cavium-octeon/ebt3000_cf.c |   89 +++++++++++++---------------------
 1 files changed, 33 insertions(+), 56 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index f4af553..dae2474 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -8,6 +8,7 @@
  * for more details.
  *
  * Copyright (C) 2005-2007 Cavium Networks
+ * Copyright (C) 2008 Wind River Systems
  */
 
 #include <linux/module.h>
@@ -24,7 +25,6 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <asm/delay.h>
-#include <linux/completion.h>
 
 #include "cvmx-app-init.h"
 #include "hal.h"
@@ -51,7 +51,7 @@ typedef struct {
 	struct hd_geometry geo;
 	spinlock_t lock;
 	request_queue_t *queue;
-	struct completion comp;
+	struct work_struct cf_work;
 	int is16bit;
 	int is_true_ide;	/* is16bit must also be set */
 } cf_device_t;
@@ -439,7 +439,7 @@ static void ebt3000_cf_request(request_queue_t * q)
 	struct request *req = elv_next_request(q);
 	if (req) {
 		cf_device_t *cf = req->rq_disk->private_data;
-		complete(&cf->comp);
+		schedule_work(&cf->cf_work);
 	}
 }
 
@@ -481,60 +481,39 @@ int ebt3000_cf_ioctl(struct inode *inode, struct file *filp,
  * @param cf_obj The compact flash device
  * @return Never returns
  */
-int ebt3000_cf_work(void *cf_obj)
+static void ebt3000_cf_work(struct work_struct *work)
 {
-	cf_device_t *cf = cf_obj;
-	struct request *req;
+	cf_device_t *cf = container_of(work, cf_device_t, cf_work);
+	struct request *req = NULL;
 	unsigned long flags;
 
-	/* Give ourself a nice name and become a daemon */
-	daemonize("octeon_%s", cf->gd->disk_name);
-
-	/* Identify the compact flash. We need its size */
-	ebt3000cf_identify(cf);
-	set_capacity(cf->gd,
-		     cf->num_sectors * (cf->sector_size / KERNEL_SECTOR_SIZE));
-
-	/* Loop forever waiting for IO requests */
-	while (1) {
-		/* Wait for the queue request handler to signal us there are
-		   requests available */
-		wait_for_completion(&cf->comp);
-
-		/* We need the queue lock */
-		spin_lock_irqsave(&cf->lock, flags);
-
-		/* Loop through all the pending requests */
-		while ((req = elv_next_request(cf->queue)) != NULL) {
-			if (!blk_fs_request(req)) {
-				printk("%s: Skip non-CMD request\n",
-				       req->rq_disk->disk_name);
-				end_request(req, 0);
-			} else {
-				int count;
-				/* Give away the lock while we're doing the
-				   slow IOs */
-				spin_unlock_irqrestore(&cf->lock, flags);
-				count = ebt3000_cf_transfer(cf, req->sector,
-							    req->
-							    current_nr_sectors,
-							    req->buffer,
-							    rq_data_dir(req));
-				/* We need the lock again to signal completion */
-				spin_lock_irqsave(&cf->lock, flags);
-				if (count == req->current_nr_sectors)
-					end_request(req, 1);
-				else
-					end_request(req, -EIO);
-			}
+	/* We need the queue lock */
+	spin_lock_irqsave(&cf->lock, flags);
+
+	/* Loop through all the pending requests */
+	while ((req = elv_next_request(cf->queue)) != NULL) {
+		if (!blk_fs_request(req)) {
+			printk("%s: Skip non-CMD request\n",
+			       req->rq_disk->disk_name);
+			end_request(req, 0);
+		} else {
+			int count;
+			/* Give away the lock while we're doing the
+			   slow IOs */
+			count = ebt3000_cf_transfer(cf, req->sector,
+					req-> current_nr_sectors,
+					req->buffer, rq_data_dir(req));
+			/* We need the lock again to signal completion */
+			if (count == req->current_nr_sectors)
+				end_request(req, 1);
+			else
+				end_request(req, -EIO);
 		}
-		spin_unlock_irqrestore(&cf->lock, flags);
 	}
-	return 0;
+	spin_unlock_irqrestore(&cf->lock, flags);
 }
 
 
-
 /*
  * The device operations structure.
  */
@@ -586,7 +565,7 @@ static int __init ebt3000_cf_init(void)
 		cf->is_true_ide = 1;
 
 	spin_lock_init(&cf->lock);
-	init_completion(&cf->comp);
+	INIT_WORK(&cf->cf_work, ebt3000_cf_work);
 
 	/* Get a request queue. */
 	cf->queue = blk_init_queue(ebt3000_cf_request, &cf->lock);
@@ -633,12 +612,10 @@ static int __init ebt3000_cf_init(void)
 	cf->gd->queue = cf->queue;
 	strcpy(cf->gd->disk_name, DEVICE_NAME "a");
 
-	/* Set a size to make sure the kernel trys to find partitions. The real
-	   size will be set when the thread starts processing */
-	set_capacity(cf->gd, 16);
-
-	/* Create a kernel thread for doing the real IO operations */
-	kernel_thread(ebt3000_cf_work, cf, 0);
+	/* Identify the compact flash. We need its size */
+	ebt3000cf_identify(cf);
+	set_capacity(cf->gd,
+		     cf->num_sectors * (cf->sector_size / KERNEL_SECTOR_SIZE));
 
 	add_disk(cf->gd);
 
-- 
1.5.5.1

