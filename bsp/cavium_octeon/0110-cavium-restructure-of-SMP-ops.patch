From 39990521659a5910289526d283e9069da7af22fb Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Thu, 13 Mar 2008 23:09:22 -0700
Subject: [PATCH] cavium: restructure of SMP ops

In the development of 2.6.25, the handling of the SMP platform
specific functions and the hook to register the SMP ops was
restructured to be more like the other architectures.

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |    3 +++
 arch/mips/cavium-octeon/smp.c   |   36 ++++++++++++++++++++++++++++--------
 2 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 39adb27..c101503 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -25,6 +25,7 @@
 #include <asm/io.h>
 #include <asm/time.h>
 #include <asm/processor.h>
+#include <asm/smp-ops.h>
 #include <asm/reboot.h>
 #include <asm/system.h>
 #include <asm/irq_cpu.h>
@@ -35,6 +36,7 @@
 #include "cvmx-l2c.h"
 #include "cvmx-bootmem.h"
 
+extern struct plat_smp_ops cav_smp_ops;
 extern void octeon_user_io_init(void);
 extern void pci_console_init(const char *arg);
 static int ECC_REPORT_SINGLE_BIT_ERRORS = 0;
@@ -863,6 +865,7 @@ void __init prom_init(void)
 	early_serial_setup(&octeon_port);
 
 	octeon_user_io_init();
+	register_smp_ops(&cav_smp_ops);
 
 #ifdef CONFIG_KGDB
 	{
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index cc9cefd..023ffb7 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 2004-2007 Cavium Networks
+ * Copyright (C) 2008 Wind River Systems
  */
 #include <linux/init.h>
 #include <linux/delay.h>
@@ -33,7 +34,7 @@ volatile unsigned long octeon_processor_gp;
  * @param cpu
  * @param action
  */
-void core_send_ipi(int cpu, unsigned int action)
+static void cavium_send_ipi_single(int cpu, unsigned int action)
 {
 	int coreid = cpu_logical_map(cpu);
 	// printk("SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n", cpu,
@@ -41,11 +42,18 @@ void core_send_ipi(int cpu, unsigned int action)
 	cvmx_write_csr(CVMX_CIU_MBOX_SETX(coreid), action);
 }
 
+static inline void cavium_send_ipi_mask(cpumask_t mask, unsigned int action)
+{
+	unsigned int i;
+
+	for_each_cpu_mask(i, mask)
+		cavium_send_ipi_single(i, action);
+}
 
 /**
  * Detect available CPUs, populate phys_cpu_present_map
  */
-void plat_smp_setup(void)
+static void cavium_smp_setup(void)
 {
 	const int coreid = cvmx_get_core_num();
 	int cpus;
@@ -76,7 +84,7 @@ void plat_smp_setup(void)
  * @param cpu
  * @param idle
  */
-void prom_boot_secondary(int cpu, struct task_struct *idle)
+static void cavium_boot_secondary(int cpu, struct task_struct *idle)
 {
 	int count;
 
@@ -107,7 +115,7 @@ void prom_boot_secondary(int cpu, struct task_struct *idle)
  * After we've done initial boot, this function is called to allow the
  * board code to clean up state, if needed
  */
-void prom_init_secondary(void)
+static void cavium_init_secondary(void)
 {
 	const int coreid = cvmx_get_core_num();
 	cvmx_ciu_intx0_t interrupt_enable;
@@ -136,16 +144,17 @@ void prom_init_secondary(void)
  *
  * @param max_cpus
  */
-void plat_prepare_cpus(unsigned int max_cpus)
+static void cavium_prepare_cpus(unsigned int max_cpus)
 {
 	extern void plat_irq_dispatch(void);
 	const int coreid = cvmx_get_core_num();
 	cvmx_ciu_intx0_t interrupt_enable;
+	int r;
 
 	/* This irq register is just a placeholder. For speed, the low level
 	   interrupt handler calls mailbox_interrupt directly. This just lets
 	   the normal interrupt handling stuff know */
-	request_irq(3, (irq_handler_t) plat_irq_dispatch, IRQF_SHARED, "IPC",
+	r = request_irq(3, (irq_handler_t) plat_irq_dispatch, IRQF_SHARED, "IPC",
 		    plat_irq_dispatch);
 
 	/* Enable Mailbox interrupts to this core. These are the only
@@ -162,7 +171,7 @@ void plat_prepare_cpus(unsigned int max_cpus)
  * Last chance for the board code to finish SMP initialization before
  * the CPU is "online".
  */
-void prom_smp_finish(void)
+static void cavium_smp_finish(void)
 {
 #ifdef CONFIG_CAVIUM_GDB
 	unsigned long tmp;
@@ -185,7 +194,7 @@ void prom_smp_finish(void)
 /**
  * Hook for after all CPUs are online
  */
-void prom_cpus_done(void)
+static void cavium_cpus_done(void)
 {
 #ifdef CONFIG_CAVIUM_GDB
 	unsigned long tmp;
@@ -197,4 +206,15 @@ void prom_cpus_done(void)
 #endif
 }
 
+struct plat_smp_ops cav_smp_ops = {
+	.send_ipi_single	= cavium_send_ipi_single,
+	.send_ipi_mask		= cavium_send_ipi_mask,
+	.init_secondary		= cavium_init_secondary,
+	.smp_finish		= cavium_smp_finish,
+	.cpus_done		= cavium_cpus_done,
+	.boot_secondary		= cavium_boot_secondary,
+	.smp_setup		= cavium_smp_setup,
+	.prepare_cpus		= cavium_prepare_cpus,
+};
+
 EXPORT_SYMBOL(__cpu_logical_map);
-- 
1.5.5.1

