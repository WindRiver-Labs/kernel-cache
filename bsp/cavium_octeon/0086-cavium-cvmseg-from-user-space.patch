From f31e15b17b0d6278e434643796e4c475e11f5e4d Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Thu, 13 Mar 2008 22:03:27 -0700
Subject: [PATCH] cavium: cvmseg from user space.

Special Cavium specific optimization used by certain apps for which they
have shared access to a certain region of L1 cache.  Use with care and
understand the ramifications...

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 arch/mips/kernel/unaligned.c |   37 +++++++++++++++++++++++++++++++++++++
 1 files changed, 37 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index c327b21..e9c0b95 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -512,6 +512,43 @@ asmlinkage void do_ade(struct pt_regs *regs)
 	if (do_dsemulret(regs))
 		return;
 
+#if defined(CONFIG_CPU_CAVIUM_OCTEON) && (CONFIG_CAVIUM_OCTEON_CVMSEG_SIZE > 0)
+{
+    /* This section of code allows tasks to access CVMSEG addresses. These are
+        special addresses into the Octeon L1 Cache that can be used as fast
+        scratch memory. By default access to this memory is disabled so we
+        don't have to save it on context switch. When a userspace task
+        references one of these addresses, we enable the region and size it
+        to match the app */
+    const unsigned long CVMSEG_BASE  = (short)0x8000;
+    const unsigned long CVMSEG_IO    = (short)0xa200;
+    uint64_t cvmmemctl               = __read_64bit_c0_register($11, 7);
+    unsigned long cvmseg_size        = (cvmmemctl&0x3f) * 128;
+
+    if ((regs->cp0_badvaddr==CVMSEG_IO) ||
+        ((regs->cp0_badvaddr>=CVMSEG_BASE) && (regs->cp0_badvaddr<CVMSEG_BASE + cvmseg_size)))
+    {
+        /* Make sure all async operations are done */
+        asm volatile ("synciobdma" ::: "memory");
+        /* Enable userspace access to CVMSEG */
+        cvmmemctl |= 1<<6;
+        __write_64bit_c0_register($11, 7, cvmmemctl);
+
+        //printk("Enabling CVMSEG access for task %p (%lu lines)\n", current, cvmmemctl&0x3f);
+
+#ifdef CONFIG_FAST_ACCESS_TO_THREAD_POINTER
+        /* Restore the processes CVMSEG data. Leave off the last 8 bytes since
+            the kernel stores the thread pointer there */
+        memcpy((void*)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size-8);
+#else
+        /* Restore the processes CVMSEG data */
+        memcpy((void*)CVMSEG_BASE, current->thread.cvmseg.cvmseg, cvmseg_size);
+#endif
+        return;
+    }
+}
+#endif
+
 	/* Otherwise handle as normal */
 
 	/*
-- 
1.5.5.1

