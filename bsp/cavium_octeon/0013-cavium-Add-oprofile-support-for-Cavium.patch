From 1fbf319d8d855ddfad4c39873c1cd4f0c2784be3 Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Thu, 13 Mar 2008 12:08:59 -0700
Subject: [PATCH] cavium: Add oprofile support for Cavium

Add in the Cavium specific hooks and support for oprofile.

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 arch/mips/oprofile/Makefile                 |    2 +
 arch/mips/oprofile/common.c                 |    4 +
 arch/mips/oprofile/op_model_cavium_octeon.c |  143 +++++++++++++++++++++++++++
 3 files changed, 149 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/oprofile/op_model_cavium_octeon.c

diff --git a/arch/mips/oprofile/Makefile b/arch/mips/oprofile/Makefile
index bf3be6f..f4cc1d0 100644
--- a/arch/mips/oprofile/Makefile
+++ b/arch/mips/oprofile/Makefile
@@ -15,3 +15,5 @@ oprofile-$(CONFIG_CPU_MIPS64)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_R10000)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_SB1)		+= op_model_mipsxx.o
 oprofile-$(CONFIG_CPU_RM9000)		+= op_model_rm9000.o
+oprofile-$(CONFIG_CPU_CAVIUM_OCTEON)	+= op_model_cavium_octeon.o
+
diff --git a/arch/mips/oprofile/common.c b/arch/mips/oprofile/common.c
index aa52aa1..fd307ae 100644
--- a/arch/mips/oprofile/common.c
+++ b/arch/mips/oprofile/common.c
@@ -16,6 +16,7 @@
 
 extern struct op_mips_model op_model_mipsxx_ops __attribute__((weak));
 extern struct op_mips_model op_model_rm9000_ops __attribute__((weak));
+extern struct op_mips_model op_model_octeon __attribute__((weak));
 
 static struct op_mips_model *model;
 
@@ -92,6 +93,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	case CPU_RM9000:
 		lmodel = &op_model_rm9000_ops;
 		break;
+	case CPU_CAVIUM_OCTEON:
+		lmodel = &op_model_octeon;
+		break;
 	};
 
 	if (!lmodel)
diff --git a/arch/mips/oprofile/op_model_cavium_octeon.c b/arch/mips/oprofile/op_model_cavium_octeon.c
new file mode 100644
index 0000000..5ab89f0
--- /dev/null
+++ b/arch/mips/oprofile/op_model_cavium_octeon.c
@@ -0,0 +1,143 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ */
+#include <linux/oprofile.h>
+#include <linux/interrupt.h>
+#include <linux/smp.h>
+
+#include "op_impl.h"
+
+/**
+ * Bit description of the core counters control register
+ */
+typedef union {
+	uint32_t u32;
+	struct {
+		uint32_t M:1;
+		uint32_t W:1;
+		uint32_t reserved:19;
+		uint32_t event:6;
+		uint32_t IE:1;
+		uint32_t U:1;
+		uint32_t S:1;
+		uint32_t K:1;
+		uint32_t EX:1;
+	} s;
+} core_control_t;
+
+static struct {
+	core_control_t control[2];
+	uint64_t reset_value[2];
+} octeon_config;
+
+/* Compute all of the registers in preparation for enabling profiling.  */
+
+static void octeon_reg_setup(struct op_counter_config *ctr)
+{
+	int i;
+	for (i = 0; i < 2; i++) {
+		octeon_config.control[i].u32 = 0;
+		if (ctr[i].enabled) {
+			octeon_config.control[i].s.event = ctr[i].event;
+			octeon_config.control[i].s.IE = 1;
+			octeon_config.control[i].s.U = ctr[i].user;
+			octeon_config.control[i].s.S = 1;
+			octeon_config.control[i].s.K = ctr[i].kernel;
+			octeon_config.control[i].s.EX = ctr[i].exl;
+			octeon_config.reset_value[i] =
+				(1ull << 63) - ctr[i].count;
+		}
+	}
+}
+
+/* Program all of the registers in preparation for enabling profiling.  */
+
+static void octeon_cpu_setup(void *args)
+{
+	__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
+	__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
+}
+
+static void octeon_cpu_start(void *args)
+{
+	uint64_t cvmctl;
+
+	/* Disable the issue and exec conditional clock support so we get
+		better results */
+	cvmctl = __read_64bit_c0_register($9, 7);
+	cvmctl |= 3 << 16;
+	__write_64bit_c0_register($9, 7, cvmctl);
+
+	/* Start all counters on current CPU */
+	__write_32bit_c0_register($25, 0, octeon_config.control[0].u32);
+	__write_32bit_c0_register($25, 2, octeon_config.control[1].u32);
+}
+
+static void octeon_cpu_stop(void *args)
+{
+	uint64_t cvmctl;
+
+	/* Stop all counters on current CPU */
+	__write_32bit_c0_register($25, 0, 0);
+	__write_32bit_c0_register($25, 2, 0);
+
+	/* Enable the issue and exec conditional clock support so we use
+		less power */
+	cvmctl = __read_64bit_c0_register($9, 7);
+	cvmctl &= ~(3 << 16);
+	__write_64bit_c0_register($9, 7, cvmctl);
+}
+
+static irqreturn_t octeon_perfcount_handler(int irq, void *dev_id)
+{
+	uint64_t counter;
+
+	counter = __read_64bit_c0_register($25, 1);
+	if (counter & (1ull << 63)) {
+		oprofile_add_sample(get_irq_regs(), 0);
+		__write_64bit_c0_register($25, 1, octeon_config.reset_value[0]);
+	}
+
+	counter = __read_64bit_c0_register($25, 3);
+	if (counter & (1ull << 63)) {
+		oprofile_add_sample(get_irq_regs(), 1);
+		__write_64bit_c0_register($25, 3, octeon_config.reset_value[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int octeon_init(void)
+{
+	int result =
+		request_irq(6, octeon_perfcount_handler, SA_SHIRQ,
+			    "Perfcounter", octeon_perfcount_handler);
+#ifdef CONFIG_SMP
+	if (result == 0) {
+		irq_desc_t *desc = irq_desc + 6;
+		smp_call_function((void (*)(void *)) desc->chip->enable,
+				  (void *) (long) 6, 0, 1);
+	}
+#endif
+	return result;
+}
+
+static void octeon_exit(void)
+{
+	free_irq(6, octeon_perfcount_handler);
+}
+
+struct op_mips_model op_model_octeon = {
+	.reg_setup = octeon_reg_setup,
+	.cpu_setup = octeon_cpu_setup,
+	.init = octeon_init,
+	.exit = octeon_exit,
+	.cpu_start = octeon_cpu_start,
+	.cpu_stop = octeon_cpu_stop,
+	.cpu_type = "mips/octeon",
+	.num_counters = 2
+};
-- 
1.5.5.1

