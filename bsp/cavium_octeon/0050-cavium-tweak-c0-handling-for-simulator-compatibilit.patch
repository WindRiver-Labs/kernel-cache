From bb424587d25a5e334a92ad5b001db3bbd5d13068 Mon Sep 17 00:00:00 2001
From: Wally Gleemer <Wally.Gleemer@windriver.com>
Date: Thu, 13 Mar 2008 20:41:11 -0700
Subject: [PATCH] cavium: tweak c0 handling for simulator compatibility

The simulator makes some assumptions that certain hardware bits will
always be zero -- however in practice this doesn't turn out to be,
esp. if there is an overflow condition.

Signed-off-by: Wally Gleemer <Wally.Gleemer@windriver.com>
---
 include/asm-mips/mipsregs.h |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/include/asm-mips/mipsregs.h b/include/asm-mips/mipsregs.h
index 4b20d1d..5821b1a 100644
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -838,7 +838,14 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+/* The Cavium Octeon simulator validates that unused hardware bits are zero.
+    The kernel by default allows the ASID to overflow the actual hardware
+    space. Most mips hardware doesn't care, but the simulator does. */
+#define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, (val) & ~0x1f00ul)
+#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
+#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
-- 
1.5.5.1

