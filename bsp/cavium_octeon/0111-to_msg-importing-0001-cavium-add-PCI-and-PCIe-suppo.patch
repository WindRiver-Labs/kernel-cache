From 9224efd581626449ada6da1a7665d45408fb513e Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:05 -0700
Subject: [PATCH] to_msg: importing 0001-cavium-add-PCI-and-PCIe-support.patch

This is an automatic import of patch 0001-cavium-add-PCI-and-PCIe-support.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/msi.c        |  252 +++++++++++++++++
 arch/mips/cavium-octeon/pci-common.c |  134 +++++++++
 arch/mips/cavium-octeon/pci-common.h |   39 +++
 arch/mips/cavium-octeon/pci.c        |  513 ++++++++++++++++++++++++++++++++++
 arch/mips/cavium-octeon/pci_chips.c  |  480 +++++++++++++++++++++++++++++++
 arch/mips/cavium-octeon/pcie.c       |  401 ++++++++++++++++++++++++++
 6 files changed, 1819 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/msi.c
 create mode 100644 arch/mips/cavium-octeon/pci-common.c
 create mode 100644 arch/mips/cavium-octeon/pci-common.h
 create mode 100644 arch/mips/cavium-octeon/pci.c
 create mode 100644 arch/mips/cavium-octeon/pci_chips.c
 create mode 100644 arch/mips/cavium-octeon/pcie.c

diff --git a/arch/mips/cavium-octeon/msi.c b/arch/mips/cavium-octeon/msi.c
new file mode 100644
index 0000000..b09f065
--- /dev/null
+++ b/arch/mips/cavium-octeon/msi.c
@@ -0,0 +1,252 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005-2007 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/msi.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include "hal.h"
+#include "pci-common.h"
+
+/* Each bit in msi_free_irq_bitmask represents a MSI interrupt that is in use */
+static uint64_t msi_free_irq_bitmask = 0;
+
+/* Each bit in msi_multiple_irq_bitmask tells that the device using this bit in
+   msi_free_irq_bitmask is also using the next bit. This is used so we can
+   disable all of the MSI interrupts when a device uses multiple */
+static uint64_t msi_multiple_irq_bitmask = 0;
+
+/* This lock controls updates to msi_free_irq_bitmask and
+   msi_multiple_irq_bitmask */
+static DEFINE_SPINLOCK(msi_free_irq_bitmask_lock);
+
+
+/**
+ * Called when a driver request MSI interrupts instead of the
+ * legacy INT A-D. This routine will allocate multiple interrupts
+ * for MSI devices that support them. A device can override this by
+ * programming the MSI control bits [6:4] before calling
+ * pci_enable_msi().
+ *
+ * @param dev    Device requesting MSI interrupts
+ * @param desc   MSI descriptor
+ *
+ * @return IRQ number of the MSI interrupt
+ */
+int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
+{
+	struct msi_msg msg;
+	uint16_t control;
+	int configured_private_bits;
+	int request_private_bits;
+	int irq;
+	int irq_step;
+	uint64_t search_mask;
+
+	/* Read the MSI config to figure out how many IRQs this device wants.
+	   Most devices only want 1, which will give configured_private_bits
+	   and request_private_bits equal 0 */
+	pci_read_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
+			     &control);
+
+	/* If the number of private bits has been configured then use that
+	   value instead of the requested number. This gives the driver the
+	   chance to override the number of interrupts before calling
+	   pci_enable_msi() */
+	configured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4;
+	if (configured_private_bits == 0) {
+		/* Nothing is configured, so use the hardware requested size */
+		request_private_bits = (control & PCI_MSI_FLAGS_QMASK) >> 1;
+	} else {
+		/* Use the number of configured bits, assuming the driver
+		   wanted to override the hardware request value */
+		request_private_bits = configured_private_bits;
+	}
+
+	/* The PCI 2.3 spec mandates that there are at most 32 interrupts. If
+	   this device asks for more, only give it one */
+	if (request_private_bits > 5)
+		request_private_bits = 0;
+
+      try_only_one:
+	/* The IRQs have to be aligned on a power of two based on the number
+	   being requested */
+	irq_step = 1 << request_private_bits;
+
+	/* Mask with one bit for each IRQ */
+	search_mask = (1 << irq_step) - 1;
+
+	/* We're going to search msi_free_irq_bitmask_lock for zero bits. This
+	   represents an MSI interrupt number that isn't in use */
+	spin_lock(&msi_free_irq_bitmask_lock);
+	for (irq = 0; irq < 64; irq += irq_step) {
+		if ((msi_free_irq_bitmask & (search_mask << irq)) == 0) {
+			msi_free_irq_bitmask |= search_mask << irq;
+			msi_multiple_irq_bitmask |= (search_mask >> 1) << irq;
+			break;
+		}
+	}
+	spin_unlock(&msi_free_irq_bitmask_lock);
+
+	/* Make sure the search for available interrupts didn't fail */
+	if (irq >= 64) {
+		if (request_private_bits) {
+			printk("arch_setup_msi_irq: Unable to find %d free "
+			       "interrupts, trying just one",
+			       1 << request_private_bits);
+			request_private_bits = 0;
+			goto try_only_one;
+		} else
+			panic("arch_setup_msi_irq: Unable to find a free MSI "
+			      "interrupt");
+	}
+
+	/* MSI interrupts start at logical IRQ OCTEON_IRQ_MSI_BIT0 */
+	irq += OCTEON_IRQ_MSI_BIT0;
+
+	switch (octeon_dma_bar_type) {
+	case OCTEON_DMA_BAR_TYPE_SMALL:
+		/* When not using big bar, Bar 0 is based at 128MB */
+		msg.address_lo =
+			((128ul << 20) + CVMX_PCI_MSI_RCV) & 0xffffffff;
+		msg.address_hi = ((128ul << 20) + CVMX_PCI_MSI_RCV) >> 32;
+	case OCTEON_DMA_BAR_TYPE_BIG:
+		/* When using big bar, Bar 0 is based at 0 */
+		msg.address_lo = (0 + CVMX_PCI_MSI_RCV) & 0xffffffff;
+		msg.address_hi = (0 + CVMX_PCI_MSI_RCV) >> 32;
+		break;
+	case OCTEON_DMA_BAR_TYPE_PCIE:
+		/* When using PCIe, Bar 0 is based at 0 */
+		// FIXME CVMX_NPEI_MSI_RCV* other than 0?
+		msg.address_lo = (0 + CVMX_NPEI_PCIE_MSI_RCV) & 0xffffffff;
+		msg.address_hi = (0 + CVMX_NPEI_PCIE_MSI_RCV) >> 32;
+		break;
+	default:
+		panic("arch_setup_msi_irq: Invalid octeon_dma_bar_type\n");
+	}
+	msg.data = irq - OCTEON_IRQ_MSI_BIT0;
+
+	/* Update the number of IRQs the device has available to it */
+	control &= ~PCI_MSI_FLAGS_QSIZE;
+	control |= request_private_bits << 4;
+	pci_write_config_word(dev, desc->msi_attrib.pos + PCI_MSI_FLAGS,
+			      control);
+
+	set_irq_msi(irq, desc);
+	write_msi_msg(irq, &msg);
+	return irq;
+}
+
+
+/**
+ * Called when a device no longer needs its MSI interrupts. All
+ * MSI interrupts for the device are freed.
+ *
+ * @param irq    The devices first irq number. There may be multple in sequence.
+ */
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	int number_irqs;
+	uint64_t bitmask;
+
+	if ((irq < OCTEON_IRQ_MSI_BIT0) || (irq > OCTEON_IRQ_MSI_BIT63))
+		panic("arch_teardown_msi_irq: Attempted to teardown illegal "
+		      "MSI interrupt (%d)", irq);
+	irq -= OCTEON_IRQ_MSI_BIT0;
+
+	/* Count the number of IRQs we need to free by looking at the
+	   msi_multiple_irq_bitmask. Each bit set means that the next IRQ is
+	   also owned by this device */
+	number_irqs = 0;
+	while ((irq+number_irqs < 64) &&
+	       (msi_multiple_irq_bitmask & (1ull << (irq + number_irqs))))
+		number_irqs++;
+	number_irqs++;
+
+	bitmask = (1 << number_irqs) - 1;	/* Mask with one bit for each
+						   IRQ */
+	bitmask <<= irq;	/* Shift the mask to the correct bit location */
+	if ((msi_free_irq_bitmask & bitmask) != bitmask)
+		panic("arch_teardown_msi_irq: Attempted to teardown MSI "
+		      "interrupt (%d) not in use", irq);
+
+	/* Checks are done, update the in use bitmask */
+	spin_lock(&msi_free_irq_bitmask_lock);
+	msi_free_irq_bitmask &= ~bitmask;
+	msi_multiple_irq_bitmask &= ~bitmask;
+	spin_unlock(&msi_free_irq_bitmask_lock);
+}
+
+
+/**
+ * Called by the interrupt handling code when an MSI interrupt
+ * occurs.
+ *
+ * @param cpl
+ * @param dev_id
+ *
+ * @return
+ */
+static irqreturn_t octeon_msi_interrupt(int cpl, void *dev_id)
+{
+	uint64_t msi_bits;
+	int irq;
+
+	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_PCIE)
+		msi_bits = cvmx_read_csr(CVMX_PEXP_NPEI_MSI_RCV0);
+	else
+		msi_bits = cvmx_read_csr(CVMX_NPI_NPI_MSI_RCV);
+	irq = fls64(msi_bits);
+	if (irq) {
+		irq += OCTEON_IRQ_MSI_BIT0 - 1;
+		if (irq_desc[irq].action) {
+			do_IRQ(irq);
+			return IRQ_HANDLED;
+		} else {
+			printk("Spurious MSI interrupt %d\n", irq);
+			if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
+				/* These chips have PCIe */
+				cvmx_write_csr(CVMX_PEXP_NPEI_MSI_RCV0,
+					       1ull << (irq -
+							OCTEON_IRQ_MSI_BIT0));
+			} else {
+				/* These chips have PCI */
+				cvmx_write_csr(CVMX_NPI_NPI_MSI_RCV,
+					       1ull << (irq -
+							OCTEON_IRQ_MSI_BIT0));
+			}
+		}
+	}
+	return IRQ_NONE;
+}
+
+
+/**
+ * Initializes the MSI interrupt handling code
+ *
+ * @return
+ */
+int octeon_msi_initialize(void)
+{
+	if (octeon_has_feature(OCTEON_FEATURE_PCIE)) {
+		request_irq(OCTEON_IRQ_PCI_MSI0, octeon_msi_interrupt, SA_SHIRQ,
+			    "MSI[0:63]", octeon_msi_interrupt);
+	} else if (octeon_is_pci_host()) {
+		request_irq(OCTEON_IRQ_PCI_MSI0, octeon_msi_interrupt, SA_SHIRQ,
+			    "MSI[0:15]", octeon_msi_interrupt);
+		request_irq(OCTEON_IRQ_PCI_MSI1, octeon_msi_interrupt, SA_SHIRQ,
+			    "MSI[16:31]", octeon_msi_interrupt);
+		request_irq(OCTEON_IRQ_PCI_MSI2, octeon_msi_interrupt, SA_SHIRQ,
+			    "MSI[32:47]", octeon_msi_interrupt);
+		request_irq(OCTEON_IRQ_PCI_MSI3, octeon_msi_interrupt, SA_SHIRQ,
+			    "MSI[48:63]", octeon_msi_interrupt);
+	}
+	return 0;
+}
+
+subsys_initcall(octeon_msi_initialize);
diff --git a/arch/mips/cavium-octeon/pci-common.c b/arch/mips/cavium-octeon/pci-common.c
new file mode 100644
index 0000000..8706d45
--- /dev/null
+++ b/arch/mips/cavium-octeon/pci-common.c
@@ -0,0 +1,134 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005-2007 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include "pci-common.h"
+#include "hal.h"
+
+typeof(pcibios_map_irq) * octeon_pcibios_map_irq = NULL;
+octeon_dma_bar_type_t octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_INVALID;
+
+/**
+ * Map a PCI device to the appropriate interrupt line
+ *
+ * @param dev    The Linux PCI device structure for the device to map
+ * @param slot   The slot number for this device on __BUS 0__. Linux
+ *               enumerates through all the bridges and figures out the
+ *               slot on Bus 0 where this device eventually hooks to.
+ * @param pin    The PCI interrupt pin read from the device, then swizzled
+ *               as it goes through each bridge.
+ * @return Interrupt number for the device
+ */
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (octeon_pcibios_map_irq)
+		return octeon_pcibios_map_irq(dev, slot, pin);
+	else
+		panic("octeon_pcibios_map_irq doesn't point to a pcibios_map_irq() function");
+}
+
+
+/**
+ * Called to perform platform specific PCI setup
+ *
+ * @param dev
+ * @return
+ */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	int pos;
+	/* Force the Cache line setting to 64 bytes. The standard Linux bus
+	   scan doesn't seem to set it. Octeon really has 128 byte lines, but
+	   Intel bridges get really upset if you try and set values above 64
+	   bytes. Value is specified in 32bit words */
+	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 64 / 4);
+	/* Set latency timers for all devices */
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, 48);
+
+        /* Enable reporting System errors and parity errors on all devices */
+        {
+            uint16_t config;
+            /* Enable parity checking and error reporting */
+            pci_read_config_word(dev, PCI_COMMAND, &config);
+            config |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+            pci_write_config_word(dev, PCI_COMMAND, config);
+        }
+
+	if (dev->subordinate) {
+		uint16_t config;
+
+		/* Set latency timers on sub bridges */
+		pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER, 48);
+		/* More bridge error detection */
+		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &config);
+		config |= PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR;
+		/* Reporting master aborts also causes SERR. Normally it
+		   creates too much noise, but it might be useful in the future */
+		// config |= PCI_BRIDGE_CTL_MASTER_ABORT;
+		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, config);
+	}
+
+	/* Enable the PCIe normal error reporting */
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (pos) {
+		uint16_t config;
+		/* Update Device Control */
+		pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &config);
+		config |= PCI_EXP_DEVCTL_CERE;	/* Correctable Error Reporting */
+		config |= PCI_EXP_DEVCTL_NFERE;	/* Non-Fatal Error Reporting */
+		config |= PCI_EXP_DEVCTL_FERE;	/* Fatal Error Reporting */
+		config |= PCI_EXP_DEVCTL_URRE;	/* Unsupported Request */
+		pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, config);
+	}
+
+	/* Find the Advanced Error Reporting capability */
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
+	if (pos) {
+		uint32_t config;
+		/* Clear Uncorrectable Error Status */
+		pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &config);
+		pci_write_config_word(dev, pos + PCI_ERR_UNCOR_STATUS, config);
+		/* Enable reporting of all uncorrectable errors */
+		/* Uncorrectable Error Mask - turned on bits disable errors */
+		pci_write_config_word(dev, pos + PCI_ERR_UNCOR_MASK, 0);
+		/* Leave severity at HW default. This only controls if errors
+		   are reported as uncorrectable or correctable, not if the
+		   error is reported */
+		/* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */
+		/* Clear Correctable Error Status */
+		pci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &config);
+		pci_write_config_word(dev, pos + PCI_ERR_COR_STATUS, config);
+		/* Enable reporting of all correctable errors */
+		/* Correctable Error Mask - turned on bits disable errors */
+		pci_write_config_word(dev, pos + PCI_ERR_COR_MASK, 0);
+		/* Advanced Error Capabilities */
+		pci_read_config_dword(dev, pos + PCI_ERR_CAP, &config);
+		/* ECRC Generation Enable */
+		if (config & PCI_ERR_CAP_ECRC_GENC)
+			config |= PCI_ERR_CAP_ECRC_GENE;
+		/* ECRC Check Enable */
+		if (config & PCI_ERR_CAP_ECRC_CHKC)
+			config |= PCI_ERR_CAP_ECRC_CHKE;
+		pci_write_config_word(dev, pos + PCI_ERR_CAP, config);
+		/* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */
+		/* Report all errors to the root complex */
+		pci_write_config_word(dev, pos + PCI_ERR_ROOT_COMMAND,
+				      PCI_ERR_ROOT_CMD_COR_EN |
+				      PCI_ERR_ROOT_CMD_NONFATAL_EN |
+				      PCI_ERR_ROOT_CMD_FATAL_EN);
+		/* Clear the Root status register */
+		pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &config);
+		pci_write_config_word(dev, pos + PCI_ERR_ROOT_STATUS, config);
+	}
+
+	return 0;
+}
diff --git a/arch/mips/cavium-octeon/pci-common.h b/arch/mips/cavium-octeon/pci-common.h
new file mode 100644
index 0000000..5256bca
--- /dev/null
+++ b/arch/mips/cavium-octeon/pci-common.h
@@ -0,0 +1,39 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005-2007 Cavium Networks
+ */
+#ifndef __OCTEON_PCI_COMMON_H__
+#define __OCTEON_PCI_COMMON_H__
+
+#include <linux/pci.h>
+
+/* Some PCI cards require delays when accessing config space. */
+#define PCI_CONFIG_SPACE_DELAY 10000
+
+/* pcibios_map_irq() is defined inside pci-common.c. All it does is call the
+   Octeon specific version pointed to by this variable. This function needs to
+   change for PCI or PCIe based hosts */
+extern typeof(pcibios_map_irq) * octeon_pcibios_map_irq;
+
+/* The following defines are only used when octeon_dma_bar_type =
+   OCTEON_DMA_BAR_TYPE_BIG */
+#define OCTEON_PCI_BAR1_HOLE_BITS 5
+#define OCTEON_PCI_BAR1_HOLE_SIZE (1ul<<(OCTEON_PCI_BAR1_HOLE_BITS+3))
+
+typedef enum {
+	OCTEON_DMA_BAR_TYPE_INVALID,
+	OCTEON_DMA_BAR_TYPE_SMALL,
+	OCTEON_DMA_BAR_TYPE_BIG,
+	OCTEON_DMA_BAR_TYPE_PCIE
+} octeon_dma_bar_type_t;
+
+/**
+ * This is a variable to tell the DMA mapping system in dma-octeon.c
+ * how to map PCI DMA addresses.
+ */
+extern octeon_dma_bar_type_t octeon_dma_bar_type;
+
+#endif
diff --git a/arch/mips/cavium-octeon/pci.c b/arch/mips/cavium-octeon/pci.c
new file mode 100644
index 0000000..b3e66a5
--- /dev/null
+++ b/arch/mips/cavium-octeon/pci.c
@@ -0,0 +1,513 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005-2007 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include "hal.h"
+#include "pci-common.h"
+
+#define USE_OCTEON_INTERNAL_ARBITER
+
+/* Octeon's PCI controller uses did=3, subdid=2 for PCI IO addresses. Use PCI
+   endian swapping 1 so no address swapping is necessary. The Linux io routines
+   will endian swap the data */
+#define OCTEON_PCI_IOSPACE_BASE     0x80011a0400000000ull
+#define OCTEON_PCI_IOSPACE_SIZE     (1ull<<32)
+
+/* Octeon't PCI controller uses did=3, subdid=3 for PCI memory. */
+#define OCTEON_PCI_MEMSPACE_OFFSET  (0x00011b0000000000ull)
+
+/**
+ * This is the bit decoding used for the Octeon PCI controller addresses
+ */
+typedef union {
+	uint64_t u64;
+	struct {
+		uint64_t upper:2;
+		uint64_t reserved:13;
+		uint64_t io:1;
+		uint64_t did:5;
+		uint64_t subdid:3;
+		uint64_t reserved2:4;
+		uint64_t endian_swap:2;
+		uint64_t reserved3:10;
+		uint64_t bus:8;
+		uint64_t dev:5;
+		uint64_t func:3;
+		uint64_t reg:8;
+	} s;
+} octeon_pci_address_t;
+
+
+/**
+ * Map a PCI device to the appropriate interrupt line
+ *
+ * @param dev    The Linux PCI device structure for the device to map
+ * @param slot   The slot number for this device on __BUS 0__. Linux
+ *               enumerates through all the bridges and figures out the
+ *               slot on Bus 0 where this device eventually hooks to.
+ * @param pin    The PCI interrupt pin read from the device, then swizzled
+ *               as it goes through each bridge.
+ * @return Interrupt number for the device
+ */
+int __init octeon_pci_pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq_num;
+	const char *interrupts;
+	int dev_num;
+
+	/* Get the board specific interrupt mapping */
+	interrupts = octeon_get_pci_interrupts();
+
+	dev_num = dev->devfn >> 3;
+	if (dev_num < strlen(interrupts))
+		irq_num = ((interrupts[dev_num] - 'A' + pin - 1) & 3) + 44;	/* 44
+										   is
+										   the
+										   irq
+										   number
+										   of PCI
+										   INT-A */
+	else
+		irq_num = ((slot + pin - 3) & 3) + 44;	/* 44 is the irq number
+							   of PCI INT-A */
+	return irq_num;
+}
+
+
+/**
+ * Read a value from configuration space
+ *
+ * @param bus
+ * @param devfn
+ * @param reg
+ * @param size
+ * @param val
+ * @return
+ */
+static int octeon_read_config(struct pci_bus *bus, unsigned int devfn, int reg,
+			      int size, u32 * val)
+{
+	octeon_pci_address_t pci_addr;
+
+	pci_addr.u64 = 0;
+	pci_addr.s.upper = 2;
+	pci_addr.s.io = 1;
+	pci_addr.s.did = 3;
+	pci_addr.s.subdid = 1;
+	pci_addr.s.endian_swap = 1;
+	pci_addr.s.bus = bus->number;
+	pci_addr.s.dev = devfn >> 3;
+	pci_addr.s.func = devfn & 0x7;
+	pci_addr.s.reg = reg;
+
+#if PCI_CONFIG_SPACE_DELAY
+	udelay(PCI_CONFIG_SPACE_DELAY);
+#endif
+	switch (size) {
+	case 4:
+		*val = le32_to_cpu(cvmx_read64_uint32(pci_addr.u64));
+		return PCIBIOS_SUCCESSFUL;
+	case 2:
+		*val = le16_to_cpu(cvmx_read64_uint16(pci_addr.u64));
+		return PCIBIOS_SUCCESSFUL;
+	case 1:
+		*val = cvmx_read64_uint8(pci_addr.u64);
+		return PCIBIOS_SUCCESSFUL;
+	}
+	return PCIBIOS_FUNC_NOT_SUPPORTED;
+}
+
+
+/**
+ * Write a value to PCI configuration space
+ *
+ * @param bus
+ * @param devfn
+ * @param reg
+ * @param size
+ * @param val
+ * @return
+ */
+static int octeon_write_config(struct pci_bus *bus, unsigned int devfn, int reg,
+			       int size, u32 val)
+{
+	octeon_pci_address_t pci_addr;
+
+	pci_addr.u64 = 0;
+	pci_addr.s.upper = 2;
+	pci_addr.s.io = 1;
+	pci_addr.s.did = 3;
+	pci_addr.s.subdid = 1;
+	pci_addr.s.endian_swap = 1;
+	pci_addr.s.bus = bus->number;
+	pci_addr.s.dev = devfn >> 3;
+	pci_addr.s.func = devfn & 0x7;
+	pci_addr.s.reg = reg;
+
+#if PCI_CONFIG_SPACE_DELAY
+	udelay(PCI_CONFIG_SPACE_DELAY);
+#endif
+	switch (size) {
+	case 4:
+		cvmx_write64_uint32(pci_addr.u64, cpu_to_le32(val));
+		return PCIBIOS_SUCCESSFUL;
+	case 2:
+		cvmx_write64_uint16(pci_addr.u64, cpu_to_le16(val));
+		return PCIBIOS_SUCCESSFUL;
+	case 1:
+		cvmx_write64_uint8(pci_addr.u64, val);
+		return PCIBIOS_SUCCESSFUL;
+	}
+	return PCIBIOS_FUNC_NOT_SUPPORTED;
+}
+
+
+static struct pci_ops octeon_pci_ops = {
+	octeon_read_config,
+	octeon_write_config,
+};
+
+static struct resource octeon_pci_mem_resource = {
+	.start = 0,
+	.end = 0,
+	.name = "Octeon PCI MEM",
+	.flags = IORESOURCE_MEM,
+};
+
+/* PCI ports must be above 16KB so the ISA bus filtering in the PCI-X to PCI
+   bridge */
+static struct resource octeon_pci_io_resource = {
+	.start = 0x4000,
+	.end = OCTEON_PCI_IOSPACE_SIZE - 1,
+	.name = "Octeon PCI IO",
+	.flags = IORESOURCE_IO,
+};
+
+static struct pci_controller octeon_pci_controller = {
+	.pci_ops = &octeon_pci_ops,
+	.mem_resource = &octeon_pci_mem_resource,
+	.mem_offset = OCTEON_PCI_MEMSPACE_OFFSET,
+	.io_resource = &octeon_pci_io_resource,
+	.io_offset = 0,
+	.io_map_base = OCTEON_PCI_IOSPACE_BASE,
+};
+
+
+/**
+ * Low level initialize the Octeon PCI controller
+ *
+ * @return
+ */
+static void octeon_pci_initialize(void)
+{
+	cvmx_pci_cfg01_t cfg01;
+	cvmx_npi_ctl_status_t ctl_status;
+	cvmx_pci_ctl_status_2_t ctl_status_2;
+	cvmx_pci_cfg19_t cfg19;
+	cvmx_pci_cfg16_t cfg16;
+	cvmx_pci_cfg22_t cfg22;
+	cvmx_pci_cfg56_t cfg56;
+
+	/* Reset the PCI Bus */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x1);
+	cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+
+	udelay(2000);		/* Hold PCI reset for 2 ms */
+
+	ctl_status.u64 = 0;	// cvmx_read_csr(CVMX_NPI_CTL_STATUS);
+	ctl_status.s.max_word = 1;
+	ctl_status.s.timer = 1;
+	cvmx_write_csr(CVMX_NPI_CTL_STATUS, ctl_status.u64);
+
+	/* Deassert PCI reset and advertize PCX Host Mode Device Capability
+	   (64b) */
+	cvmx_write_csr(CVMX_CIU_SOFT_PRST, 0x4);
+	cvmx_read_csr(CVMX_CIU_SOFT_PRST);
+
+	udelay(2000);		/* Wait 2 ms after deasserting PCI reset */
+
+	ctl_status_2.u32 = 0;
+	ctl_status_2.s.tsr_hwm = 1;	/* Initializes to 0.  Must be set
+					   before any PCI reads. */
+	ctl_status_2.s.bar2pres = 1;	/* Enable BAR2 */
+	ctl_status_2.s.bar2_enb = 1;
+	ctl_status_2.s.bar2_cax = 1;	/* Don't use L2 */
+	ctl_status_2.s.bar2_esx = 1;
+	ctl_status_2.s.pmo_amod = 1;	/* Round robin priority */
+	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_BIG) {
+		ctl_status_2.s.bb1_hole = OCTEON_PCI_BAR1_HOLE_BITS;	/* BAR1
+									   hole */
+		ctl_status_2.s.bb1_siz = 1;	/* BAR1 is 2GB */
+		ctl_status_2.s.bb_ca = 1;	/* Don't use L2 with big bars */
+		ctl_status_2.s.bb_es = 1;	/* Big bar in byte swap mode */
+		ctl_status_2.s.bb1 = 1;	/* BAR1 is big */
+		ctl_status_2.s.bb0 = 1;	/* BAR0 is big */
+	}
+
+	octeon_npi_write32(CVMX_NPI_PCI_CTL_STATUS_2, ctl_status_2.u32);
+	udelay(2000);		/* Wait 2 ms before doing PCI reads */
+
+	ctl_status_2.u32 = octeon_npi_read32(CVMX_NPI_PCI_CTL_STATUS_2);
+	printk("PCI Status: %s %s-bit\n",
+	       ctl_status_2.s.ap_pcix ? "PCI-X" : "PCI",
+	       ctl_status_2.s.ap_64ad ? "64" : "32");
+
+	if (OCTEON_IS_MODEL(OCTEON_CN58XX) || OCTEON_IS_MODEL(OCTEON_CN50XX)) {
+		cvmx_pci_cnt_reg_t pci_cnt_reg_start;
+		cvmx_pci_cnt_reg_t pci_cnt_reg_end;
+		cycles_t cycles;
+		pci_cnt_reg_start.u64 = cvmx_read_csr(CVMX_NPI_PCI_CNT_REG);
+		cycles = get_cycles();
+		udelay(1000);
+		pci_cnt_reg_end.u64 = cvmx_read_csr(CVMX_NPI_PCI_CNT_REG);
+		cycles = get_cycles() - cycles;
+		printk("PCI Clock: %lu MHz\n",
+		       (pci_cnt_reg_end.s.pcicnt -
+			pci_cnt_reg_start.s.pcicnt) / (cycles /
+						       (mips_hpt_frequency /
+							1000000)));
+	}
+
+	/*
+	 ** TDOMC must be set to one in PCI mode. TDOMC should be set to 4
+	 ** in PCI-X mode to allow four oustanding splits. Otherwise,
+	 ** should not change from its reset value. Don't write PCI_CFG19
+	 ** in PCI mode (0x82000001 reset value), write it to 0x82000004
+	 ** after PCI-X mode is known. MRBCI,MDWE,MDRE -> must be zero.
+	 ** MRBCM -> must be one.
+	 */
+	if (ctl_status_2.s.ap_pcix) {
+		cfg19.u32 = 0;
+		cfg19.s.tdomc = 4;	/* Target Delayed/Split request
+					   outstanding maximum count. [1..31]
+					   and 0=32.  NOTE: If the user
+					   programs these bits beyond the
+					   Designed Maximum outstanding count,
+					   then the designed maximum table
+					   depth will be used instead.  No
+					   additional Deferred/Split
+					   transactions will be accepted if
+					   this outstanding maximum count is
+					   reached. Furthermore, no additional
+					   deferred/split transactions will be
+					   accepted if the I/O delay/ I/O Split
+					   Request outstanding maximum is
+					   reached. */
+		cfg19.s.mdrrmc = 2;	/* Master Deferred Read Request
+					   Outstanding Max Count (PCI only).
+					   CR4C[26:24] Max SAC cycles MAX DAC
+					   cycles 000 8 4 001 1 0 010 2 1 011 3
+					   1 100 4 2 101 5 2 110 6 3 111 7 3 For
+					   example, if these bits are programmed
+					   to 100, the core can support 2 DAC
+					   cycles, 4 SAC cycles or a combination
+					   of 1 DAC and 2 SAC cycles. NOTE: For
+					   the PCI-X maximum outstanding split
+					   transactions, refer to CRE0[22:20] */
+
+		cfg19.s.mrbcm = 1;	/* Master Request (Memory Read) Byte
+					   Count/Byte Enable select. 0 = Byte
+					   Enables valid. In PCI mode, a burst
+					   transaction cannot be performed
+					   using Memory Read command=4?h6. 1 =
+					   DWORD Byte Count valid (default). In
+					   PCI Mode, the memory read byte
+					   enables are automatically generated
+					   by the core. Note: N3 Master Request
+					   transaction sizes are always
+					   determined through the
+					   am_attr[<35:32>|<7:0>] field.  */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG19, cfg19.u32);
+	}
+
+
+	cfg01.u32 = 0;
+	cfg01.s.msae = 1;	/* Memory Space Access Enable */
+	cfg01.s.me = 1;		/* Master Enable */
+	cfg01.s.pee = 1;	/* PERR# Enable */
+	cfg01.s.see = 1;	/* System Error Enable */
+	cfg01.s.fbbe = 1;	/* Fast Back to Back Transaction Enable */
+
+	octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+
+#ifdef USE_OCTEON_INTERNAL_ARBITER
+	/*
+	 ** When OCTEON is a PCI host, most systems will use OCTEON's
+	 ** internal arbiter, so must enable it before any PCI/PCI-X
+	 ** traffic can occur.
+	 */
+	{
+		cvmx_npi_pci_int_arb_cfg_t pci_int_arb_cfg;
+
+		pci_int_arb_cfg.u64 = 0;
+		pci_int_arb_cfg.s.en = 1;	/* Internal arbiter enable */
+		cvmx_write_csr(CVMX_NPI_PCI_INT_ARB_CFG, pci_int_arb_cfg.u64);
+	}
+#endif				/* USE_OCTEON_INTERNAL_ARBITER */
+
+	/*
+	 ** Preferrably written to 1 to set MLTD. [RDSATI,TRTAE,
+	 ** TWTAE,TMAE,DPPMR -> must be zero. TILT -> must not be set to
+	 ** 1..7.
+	 */
+	cfg16.u32 = 0;
+	cfg16.s.mltd = 1;	/* Master Latency Timer Disable */
+	octeon_npi_write32(CVMX_NPI_PCI_CFG16, cfg16.u32);
+
+	/*
+	 ** Should be written to 0x4ff00. MTTV -> must be zero.
+	 ** FLUSH -> must be 1. MRV -> should be 0xFF.
+	 */
+	cfg22.u32 = 0;
+	cfg22.s.mrv = 0xff;	/* Master Retry Value [1..255] and 0=infinite */
+	cfg22.s.flush = 1;	/* AM_DO_FLUSH_I control NOTE: This bit MUST BE
+				   ONE for proper N3K operation */
+	octeon_npi_write32(CVMX_NPI_PCI_CFG22, cfg22.u32);
+
+	/*
+	 ** MOST Indicates the maximum number of outstanding splits (in -1
+	 ** notation) when OCTEON is in PCI-X mode.  PCI-X performance is
+	 ** affected by the MOST selection.  Should generally be written
+	 ** with one of 0x3be807, 0x2be807, 0x1be807, or 0x0be807,
+	 ** depending on the desired MOST of 3, 2, 1, or 0, respectively.
+	 */
+	cfg56.u32 = 0;
+	cfg56.s.pxcid = 7;	/* RO - PCI-X Capability ID */
+	cfg56.s.ncp = 0xe8;	/* RO - Next Capability Pointer */
+	cfg56.s.dpere = 1;	/* Data Parity Error Recovery Enable */
+	cfg56.s.roe = 1;	/* Relaxed Ordering Enable */
+	cfg56.s.mmbc = 1;	/* Maximum Memory Byte Count
+				   [0=512B,1=1024B,2=2048B,3=4096B] */
+	cfg56.s.most = 3;	/* Maximum outstanding Split transactions [0=1
+				   .. 7=32] */
+
+	octeon_npi_write32(CVMX_NPI_PCI_CFG56, cfg56.u32);
+
+	/*
+	 ** Affects PCI performance when OCTEON services reads to its
+	 ** BAR1/BAR2. Refer to Section 10.6.1.  The recommended values are
+	 ** 0x22, 0x33, and 0x33 for PCI_READ_CMD_6, PCI_READ_CMD_C, and
+	 ** PCI_READ_CMD_E, respectively. Unfortunately due to errata DDR-700,
+	 ** these values need to be changed so they won't possibly prefetch off
+	 ** of the end of memory if PCI is DMAing a buffer at the end of
+	 ** memory. Note that these values differ from their reset values.
+	 */
+	octeon_npi_write32(CVMX_NPI_PCI_READ_CMD_6, 0x21);
+	octeon_npi_write32(CVMX_NPI_PCI_READ_CMD_C, 0x31);
+	octeon_npi_write32(CVMX_NPI_PCI_READ_CMD_E, 0x31);
+}
+
+
+/**
+ * Initialize the Octeon PCI controller
+ *
+ * @return
+ */
+static int __init octeon_pci_setup(void)
+{
+	cvmx_npi_mem_access_subid_t mem_access;
+	int index;
+
+	/* Only these chips have PCI */
+	if (octeon_has_feature(OCTEON_FEATURE_PCIE))
+		return 0;
+
+	/* Point pcibios_map_irq() to the PCI version of it */
+	octeon_pcibios_map_irq = octeon_pci_pcibios_map_irq;
+
+	/* Only use the big bars on chips that support it */
+	if (OCTEON_IS_MODEL(OCTEON_CN31XX) ||
+	    OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2) ||
+	    OCTEON_IS_MODEL(OCTEON_CN38XX_PASS1))
+		octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_SMALL;
+	else
+		octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_BIG;
+
+	/* PCI I/O and PCI MEM values */
+	set_io_port_base(OCTEON_PCI_IOSPACE_BASE);
+	ioport_resource.start = 0;
+	ioport_resource.end = OCTEON_PCI_IOSPACE_SIZE - 1;
+	iomem_resource.start = (1ull << 48);
+	iomem_resource.end = (2ull << 48) - 1;
+
+	if (!octeon_is_pci_host()) {
+		printk("Not in host mode, PCI Controller not initialized\n");
+		return 0;
+	}
+
+	printk("%s Octeon big bar support\n",
+	       (octeon_dma_bar_type ==
+		OCTEON_DMA_BAR_TYPE_BIG) ? "Enabling" : "Disabling");
+
+	octeon_pci_initialize();
+
+	mem_access.u64 = 0;
+	mem_access.s.esr = 1;	/* Endian-Swap on read. */
+	mem_access.s.esw = 1;	/* Endian-Swap on write. */
+	mem_access.s.nsr = 0;	/* No-Snoop on read. */
+	mem_access.s.nsw = 0;	/* No-Snoop on write. */
+	mem_access.s.ror = 0;	/* Relax Read on read. */
+	mem_access.s.row = 0;	/* Relax Order on write. */
+	mem_access.s.ba = 0;	/* PCI Address bits [63:36]. */
+	cvmx_write_csr(CVMX_NPI_MEM_ACCESS_SUBID3, mem_access.u64);
+
+	/* Remap the Octeon BAR 2 above all 32 bit devices (0x8000000000ul).
+	   This is done here so it is remapped before the readl()'s below. We
+	   don't want BAR2 overlapping with BAR0/BAR1 during these reads */
+	octeon_npi_write32(CVMX_NPI_PCI_CFG08, 0);
+	octeon_npi_write32(CVMX_NPI_PCI_CFG09, 0x80);
+
+	/* Disable the BAR1 movable mappings */
+	for (index = 0; index < 32; index++)
+		octeon_npi_write32(CVMX_NPI_PCI_BAR1_INDEXX(index), 0);
+
+	if (octeon_dma_bar_type == OCTEON_DMA_BAR_TYPE_BIG) {
+		/* Remap the Octeon BAR 0 to 0-2GB */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG04, 0);
+		octeon_npi_write32(CVMX_NPI_PCI_CFG05, 0);
+
+		/* Remap the Octeon BAR 1 to map 2GB-4GB (minus the BAR 1 hole) */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG06, 2ul << 30);
+		octeon_npi_write32(CVMX_NPI_PCI_CFG07, 0);
+
+		/* Devices go after BAR1 */
+		octeon_pci_mem_resource.start =
+			OCTEON_PCI_MEMSPACE_OFFSET + (4ul << 30) -
+			(OCTEON_PCI_BAR1_HOLE_SIZE << 20);
+		octeon_pci_mem_resource.end =
+			octeon_pci_mem_resource.start + (1ul << 30);
+	} else {
+		/* Remap the Octeon BAR 0 to map 128MB-(128MB+4KB) */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG04, 128ul << 20);
+		octeon_npi_write32(CVMX_NPI_PCI_CFG05, 0);
+
+		/* Remap the Octeon BAR 1 to map 0-128MB */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG06, 0);
+		octeon_npi_write32(CVMX_NPI_PCI_CFG07, 0);
+
+		/* Devices go after BAR0 */
+		octeon_pci_mem_resource.start =
+			OCTEON_PCI_MEMSPACE_OFFSET + (128ul << 20) +
+			(4ul << 10);
+		octeon_pci_mem_resource.end =
+			octeon_pci_mem_resource.start + (1ul << 30);
+	}
+
+	register_pci_controller(&octeon_pci_controller);
+
+	/* Clear any errors that might be pending from before the bus was setup
+	   properly */
+	cvmx_write_csr(CVMX_NPI_PCI_INT_SUM2, -1);
+	return 0;
+}
+
+arch_initcall(octeon_pci_setup);
diff --git a/arch/mips/cavium-octeon/pci_chips.c b/arch/mips/cavium-octeon/pci_chips.c
new file mode 100644
index 0000000..b7e113b
--- /dev/null
+++ b/arch/mips/cavium-octeon/pci_chips.c
@@ -0,0 +1,480 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2005-2007 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/delay.h>
+#include "hal.h"
+
+
+/**
+ * Fixup the Via southbridge to enable the IDE. By default
+ * it is disabled and doesn't show up in a bus scan.
+ *
+ * @param dev
+ */
+static void chip_vt82c686b_force_enable_ide(struct pci_dev *dev)
+{
+	uint8_t value;
+	pci_read_config_byte(dev, 0x48, &value);
+	/* Enable the IDE interface if it is disabled */
+	if (value & 2) {
+		value ^= 2;
+		pci_write_config_byte(dev, 0x48, value);
+	}
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686,
+			chip_vt82c686b_force_enable_ide);
+
+
+/**
+ * The Via southbridge requires ISA resources that are
+ * normally not forwarded through bridges. Modify the Via's
+ * parent bridge to forward these resource. We assume the Via
+ * is behind exactly one bridge.
+ *
+ * @param via_dev
+ */
+static void chip_vt82c686b_fix_parent_bridge(struct pci_dev *via_dev)
+{
+	extern void octeon_i8259_setup(int irq_line);
+	struct pci_dev *dev = via_dev->bus->self;
+	uint16_t val;
+	pci_write_config_word(dev, 0x04, 0x0026);
+	pci_read_config_word(dev, 0x3e, &val);
+	val &= ~(1 << 2);	/* Disable the ISA port filtering */
+	val |= 1 << 3;		/* Enable VGA */
+	val |= 1 << 4;		/* Enable VGA Alias Filter */
+	pci_write_config_word(dev, 0x3e, val);
+	pci_write_config_byte(dev, 0x1c, 0x0);	/* Force IO port range to start
+						   at 0 for Via 686 ISA devices
+						 */
+	pci_write_config_byte(dev, 0x30, 0x0);
+	pci_write_config_word(dev, 0x04, 0x0027);
+	octeon_i8259_setup(octeon_get_southbridge_interrupt());
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686,
+			chip_vt82c686b_fix_parent_bridge);
+
+
+/**
+ * Perform the convoluted setup needed for the Via southbridge
+ *
+ * @param dev
+ */
+static void chip_vt82c686b_setup(struct pci_dev *dev)
+{
+	uint8_t bvalue;
+	pci_write_config_byte(dev, 0x40, 0x08);	// I/O Recovery Time Enable
+	pci_write_config_byte(dev, 0x41, 0x41);	// I/O Recovery Time=8BCLKs,
+						// ISA Refresh
+	pci_write_config_byte(dev, 0x45, 0x80);	// ISA Master /DMA to PCI Line
+						// Buffer Enable
+	pci_write_config_byte(dev, 0x46, 0x60);	// GATE INTR Enable, Flush Line
+						// Buffer for Int or DMA IOR
+						// Cycle Enable
+	pci_write_config_byte(dev, 0x47, 0xa0);	// CPU Reset source: INIT, EISA
+						// 4d0 /4d1 port enable
+	/*
+	   Offset 48 - Miscellaneous Control 3 ................................
+	   RW 7-4 Reserved ........................................ always
+	   reads 0 3 Extra RTC Port 74/75 Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2 Integrated USB Controller Disable 0 Enable
+	   ....................................................default 1
+	   Disable 1 Integrated IDE Controller Disable 0 Enable
+	   ....................................................default 1
+	   Disable 0 512K PCI Memory Decode 0 Use Rx4E[15-12] to select top of
+	   PCI memory 1 Use contents of Rx4E[15-12] plus 512K as top of PCI
+	   memory.......................................default */
+	pci_write_config_byte(dev, 0x48, 0x09);
+
+	/*
+	   Offset 4A - IDE Interrupt
+	   Routing..................................RW 7 Wait for PGNT Before
+	   Grant to ISA Master / DMA 0 Disable
+	   ...................................................default 1 Enable
+	   6 Bus Select for Access to I/O Devices Below 100h 0 Access ports
+	   00-FFh via XD bus ...........default 1 Access ports 00-FFh via SD
+	   bus (applies to external devices only; internal devices such as the
+	   mouse controller are not effected) 5-4 Reserved (do not
+	   program)..................... default = 0 3-2 IDE Second Channel IRQ
+	   Routing 00 IRQ14 01
+	   IRQ15.....................................................default 10
+	   IRQ10 11 IRQ11 1-0 IDE Primary Channel IRQ Routing 00
+	   IRQ14.....................................................default 01
+	   IRQ15 10 IRQ10 11 IRQ11 */
+	pci_write_config_byte(dev, 0x4a, 0x04);
+
+	/*
+	   Offset 4F-4E - ISA DMA/Master Mem Access Ctrl 3 ... RW 15-12 Top of
+	   PCI Memory for ISA DMA/Master accesses 0000 1M
+	   .................................................... default 0001 2M
+	   ... ... 1111 16M Note: All ISA DMA / Masters that access addresses
+	   higher than the top of PCI memory will not be directed to the PCI
+	   bus. 11 Forward E0000-EFFFF Accesses to PCI ....... def=0 10 Forward
+	   A0000-BFFFF Accesses to PCI ....... def=0 9 Forward 80000-9FFFF
+	   Accesses to PCI ........def=1 8 Forward 00000-7FFFF Accesses to PCI
+	   ........def=1 7 Forward DC000-DFFFF Accesses to PCI ...... def=0 6
+	   Forward D8000-DBFFF Accesses to PCI ......def=0 5 Forward D4000-D7FFF
+	   Accesses to PCI ......def=0 4 Forward D0000-D3FFF Accesses to PCI
+	   ......def=0 3 Forward CC000-CFFFF Accesses to PCI .....def=0 2
+	   Forward C8000-CBFFF Accesses to PCI ......def=0 1 Forward C4000-C7FFF
+	   Accesses to PCI ......def=0 0 Forward C0000-C3FFF Accesses to PCI
+	   ......def=0 */
+	pci_write_config_word(dev, 0x4e, 0xf000);
+
+	/*
+	   Offset 51 - PNP IRQ Routing
+	   1........................................RW 7-4 PnP Routing for
+	   Parallel Port IRQ (see PnP IRQ routing table) 3-0 PnP Routing for
+	   Floppy IRQ (see PnP IRQ routing table) */
+	pci_write_config_byte(dev, 0x51, 0x76);
+
+	/*
+	   Offset 52 - PNP IRQ Routing
+	   2........................................RW 7-4 PnP Routing for
+	   Serial Port 2 IRQ (see PnP IRQ routing table) 3-0 PnP Routing for
+	   Serial Port 1 IRQ (see PnP IRQ routing table) */
+	pci_write_config_byte(dev, 0x52, 0x34);
+
+	/*
+	   Offset 5A � KBC / RTC
+	   Control......................................RW Bits 7-4 of this
+	   register are latched from pins SD7-4 at power- up but are read/write
+	   accessible so may be changed after power-up to change the default
+	   strap setting: 7 Keyboard RP16........................... latched
+	   from SD7 6 Keyboard RP15 .......................... latched from SD6
+	   5 Keyboard RP14 .......................... latched from SD5 4
+	   Keyboard RP13 .......................... latched from SD4 3 Reserved
+	   ........................................ always reads 0 2 Internal
+	   RTC Enable 0 Disable 1 Enable
+	   ...................................................default 1 Internal
+	   PS2 Mouse Enable 0 Disable
+	   ..................................................default 1 Enable 0
+	   Internal KBC Enable 0 Disable
+	   ..................................................default 1 Enable */
+	pci_read_config_byte(dev, 0x5a, &bvalue);
+	pci_write_config_byte(dev, 0x5a, bvalue | 0x7);
+
+	/*
+	   Offset 61-60 - Distributed DMA Ch 0 Base / Enable ..... RW 15-4
+	   Channel 0 Base Address Bits 15-4.......... default = 0 3 Channel 0
+	   Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2-0 Reserved ........................................ always reads 0 */
+	pci_write_config_word(dev, 0x60, 0x4);
+
+	/*
+	   Offset 63-62 - Distributed DMA Ch 1 Base / Enable ..... RW 15-4
+	   Channel 1 Base Address Bits 15-4.......... default = 0 3 Channel 1
+	   Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2-0 Reserved ........................................ always reads 0 */
+	pci_write_config_word(dev, 0x62, 0x4);
+
+	/*
+	   Offset 65-64 - Distributed DMA Ch 2 Base / Enable ..... RW 15-4
+	   Channel 2 Base Address Bits 15-4.......... default = 0 3 Channel 2
+	   Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2-0 Reserved ........................................ always reads 0 */
+	pci_write_config_word(dev, 0x64, 0x4);
+
+	/*
+	   Offset 67-66 - Distributed DMA Ch 3 Base / Enable ..... RW 15-4
+	   Channel 3 Base Address Bits 15-4.......... default = 0 3 Channel 3
+	   Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2-0 Reserved ........................................ always reads 0 */
+	pci_write_config_word(dev, 0x66, 0x4);
+
+	/*
+	   Offset 77 � GPIO Control 4 Control (10h)..................... RW 7
+	   DRQ / DACK# Pins are GPI / GPO 0
+	   Disable................................................... default 1
+	   Enable 6 Game Port XY Pins are GPI / GPO 0
+	   Disable................................................... default 1
+	   Enable 5 Reserved ........................................always
+	   reads 0 4 Internal APIC Enable 0 Disable 1 Enable (U10 = WSC#, V9 =
+	   APICD0, T10 =
+	   APICD1)................................................ default 3
+	   IRQ0 Output 0
+	   Disable................................................... default 1
+	   Enable IRQ0 output to GPIOC 2 RTC Rx32 Write Protect 0
+	   Disable................................................... default 1
+	   Enable 1 RTC Rx0D Write Protect 0
+	   Disable................................................... default 1
+	   Enable 0 GPO13 Enable (Pin U5) 0 Pin defined as
+	   SOE#.............................. default 1 Pin defined as GPO13 */
+	pci_write_config_byte(dev, 0x77, 0x40);	// Enable GPI22
+
+	/*
+	   Offset 81 � ISA Positive Decoding Control 1..................RW 7
+	   On-Board I/O Port Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   6 Microsoft-Sound System I/O Port Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   5-4 Microsoft-Sound System I/O Decode Range 00 0530h-0537h
+	   ..........................................default 01 0604h-060Bh 10
+	   0E80-0E87h 11 0F40h-0F47h 3 APIC Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   2 BIOS ROM Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   1 Reserved ........................................ always reads 0 0
+	   PCS0 Positive Decoding 0 Disable
+	   ...................................................default 1 Enable */
+	pci_write_config_byte(dev, 0x81, 0xc0);
+
+	/*
+	   Offset 82 � ISA Positive Decoding Control 2..................RW 7
+	   FDC Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   6 LPT Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   5-4 LPT Decode Range 00 3BCh-3BFh, 7BCh-7BEh
+	   ......................default 01 378h-37Fh, 778h-77Ah 10 278h-27Fh,
+	   678h-67Ah 11 -reserved- 3 Game Port Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   2 MIDI Positive Decoding 0 Disable
+	   ...................................................default 1 Enable
+	   1-0 MIDI Decode Range 00 300h-303h
+	   ..............................................default 01 310h-313h
+	   10 320h-323h 11 330h-333h */
+	pci_write_config_byte(dev, 0x82, 0xdc);
+
+	/*
+	   Offset 83 � ISA Positive Decoding Control 3 ................. RW 7
+	   COM Port B Positive Decoding 0
+	   Disable................................................... default 1
+	   Enable 6-4 COM-Port B Decode Range 000 3F8h-3FFh
+	   (COM1)............................ default 001 2F8h-2FFh (COM2) 010
+	   220h-227h 011 228h-22Fh 100 238h-23Fh 101 2E8h-2EFh (COM4) 110
+	   338h-33Fh 111 3E8h-3EFh (COM3) 3 COM Port A Positive Decoding 0
+	   Disable................................................... default 1
+	   Enable 2-0 COM-Port A Decode Range 000 3F8h-3FFh
+	   (COM1)............................ default 001 2F8h-2FFh (COM2) 010
+	   220h-227h 011 228h-22Fh 100 238h-23Fh 101 2E8h-2EFh (COM4) 110
+	   338h-33Fh 111 3E8h-3EFh (COM3) */
+	pci_write_config_byte(dev, 0x83, 0x98);
+
+	/*
+	   Offset 84 � ISA Positive Decoding Control 4 ................. RW 7-5
+	   Reserved ........................................always reads 0 4
+	   CD: Reserved.....................................always reads 0 CE:
+	   Port CF9 Positive Decoding 0 Disable 1
+	   Enable................................................... default 3
+	   FDC Decoding Range 0 Primary
+	   .................................................. default 1
+	   Secondary 2 Sound Blaster Positive Decoding 0
+	   Disable................................................... default 1
+	   Enable 1-0 Sound Blaster Decode Range 00 220h-22Fh, 230h-233h
+	   .......................... default 01 240h-24Fh, 250h-253h 10
+	   260h-26Fh, 270h-273h 11 280h-28Fh, 290h-293h */
+	pci_write_config_byte(dev, 0x84, 0x04);
+
+	/*
+	   Offset 85 � Extended Function Enable............................RW
+	   7-6 PCI Master Grant Timeout Select 00 Disable
+	   ...................................................default 01 32 PCI
+	   Clocks 10 64 PCI Clocks 11 96 PCI Clocks 5 Keyboard Controller
+	   Configuration 0 Disable
+	   ...................................................default 1 Enable
+	   4 Function 3 USB Ports 2-3 0 Enable
+	   ....................................................default 1
+	   Disable 3 Function 6 Modem / Audio 0 Enable
+	   ....................................................default 1
+	   Disable 2 Function 5 Audio 0 Enable
+	   ....................................................default 1
+	   Disable 1 Super-I/O Configuration 0 Disable
+	   ...................................................default 1 Enable
+	   0 Super-I/O 0 Disable
+	   ...................................................default 1 Enable */
+	pci_write_config_byte(dev, 0x85, 0x23);
+
+	/*
+	   Index E0 � Super-I/O Device ID (3Ch) ............................ RO
+	   7-0 Super-I/O ID ........................................ default =
+	   3Ch */
+	outb(0xe0, 0x3f0);
+	if (inb(0x3f1) != 0x3c)
+		printk("    ERROR: Super-I/O Device ID not found (read 0x%x, expected 0x3c)\n", inb(0x3f1));
+
+	/*
+	   Index E2 � Super-I/O Function Select (03h)...................RW 7-5
+	   Reserved ........................................ always reads 0 4
+	   Floppy Controller Enable 0 Disable
+	   ...................................................default 1 Enable
+	   3 Serial Port 2 Enable 0 Disable
+	   ...................................................default 1 Enable
+	   2 Serial Port 1 Enable 0 Disable
+	   ...................................................default 1 Enable
+	   1-0 Parallel Port Mode / Enable 00 Unidirectional mode 01 ECP 10 EPP
+	   11 Parallel Port Disable ..............................default */
+	outb(0xe2, 0x3f0);
+	outb(0x1d, 0x3f1);
+
+	/* Set the floppy controller address */
+	outb(0xe3, 0x3f0);
+	outb(0x3f0 >> 2, 0x3f1);	/* PC Legacy default is 0x3f0 */
+
+	/* Set the LTP port address */
+	outb(0xe6, 0x3f0);
+	outb(0x378 >> 2, 0x3f1);	/* PC Legacy default is 0x378 */
+
+	/* Set the Serail Port 1 port address */
+	outb(0xe7, 0x3f0);
+	outb(0x3f8 >> 2, 0x3f1);	/* PC Legacy default is 0x3f8 */
+
+	/* Set the Serail Port 2 port address */
+	outb(0xe8, 0x3f0);
+	outb(0x2f8 >> 2, 0x3f1);	/* PC Legacy default is 0x2f8 */
+
+	/*
+	   Index F6 � Floppy Controller Configuration................. RW 7-6
+	   Reserved ........................................always reads 0 5
+	   Floppy Drive On Parallel Port 0 Parallel Port (SPP) Mode
+	   ...................... default 1 FDC Mode 4 3-Mode FDD 0
+	   Disable................................................... default 1
+	   Enable 3 Reserved ........................................always
+	   reads 0 2 Four Floppy Drive Option 0 Internal 2-Drive
+	   Decoder....................... default 1 External 4-Drive Decoder 1
+	   FDC DMA Non-Burst 0 Burst
+	   .................................................... default 1
+	   Non-Burst 0 FDC Swap 0
+	   Disable................................................... default 1
+	   Enable */
+	outb(0xf6, 0x3f0);
+	outb(0x20, 0x3f1);
+
+	pci_write_config_byte(dev, 0x85, 0x21);
+	dev->irq = OCTEON_IRQ_I8259S2;
+}
+
+DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686,
+			 chip_vt82c686b_setup);
+
+
+/**
+ * Perform the setup for the Via IDE
+ *
+ * @param dev
+ */
+static void chip_vt82c686b_ide_setup(struct pci_dev *dev)
+{
+	uint8_t bvalue;
+	pci_read_config_byte(dev, 0x40, &bvalue);
+	pci_write_config_byte(dev, 0x40, bvalue | 3);
+	pci_write_config_byte(dev, 0x04, 0x87);	// Enable Bus Master I/O
+						// space,Memory space
+	pci_write_config_byte(dev, 0x0d, 0x40);	// Latency Timer
+	pci_write_config_byte(dev, 0x3c, 0x0e);	// Interrupt Line
+	pci_read_config_byte(dev, 0x41, &bvalue);
+	pci_write_config_byte(dev, 0x41, bvalue | 0xc0);	// enable read
+								// prefectch/post
+								// write buffer
+	pci_write_config_byte(dev, 0x43, 0x05);	// FIFO configuration 1/2
+	pci_write_config_byte(dev, 0x44, 0x1c);	// Miscellaneous Control
+	pci_write_config_byte(dev, 0x45, 0x00);	// Miscellaneous Control
+
+	pci_write_config_byte(dev, 0x46, 0xc0);	// Disable DMA FIFO flush
+	pci_write_config_dword(dev, 0x48, 0xa8a8a8a8);	// Drive Timing Control
+	pci_write_config_byte(dev, 0x4c, 0xff);	// Address Setup Time
+
+	pci_write_config_dword(dev, 0x50, 0x07070707);	// UltraDMA Extended
+							// Timing Control
+	pci_write_config_byte(dev, 0x54, 0x04);	// UltraDMA FIFO control
+
+	pci_write_config_word(dev, 0x04, 0x87);	// Eanable I/O space, Bus
+						// Master
+
+	pci_write_config_byte(dev, 0x3c, OCTEON_IRQ_I8259S6);
+	dev->irq = OCTEON_IRQ_I8259S6;
+}
+
+DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1,
+			 chip_vt82c686b_ide_setup);
+
+
+/**
+ * We need to change the Via USB to use the 8259 interrupt
+ * instead of the normal PCI interrrupts.
+ *
+ * @param dev
+ */
+static void chip_vt82c686b_usb_setup(struct pci_dev *dev)
+{
+	pci_write_config_byte(dev, 0x3c, OCTEON_IRQ_I8259S5);
+	dev->irq = OCTEON_IRQ_I8259S5;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_2,
+			chip_vt82c686b_usb_setup);
+
+
+/**
+ * Perform the Via IDE setup for DMA modes.
+ *
+ * @param dev
+ */
+static void chip_vt82c686b_pmio_setup(struct pci_dev *dev)
+{
+	uint32_t base;
+	u8 val;
+
+	pci_write_config_word(dev, 0x041, 0x80);	// Eanble PM/IO base
+	pci_write_config_word(dev, 0x048, 0x500);	// Set PM/IO base to
+							// 0x500
+
+	pci_read_config_dword(dev, 0x48, &base);	// read PM/IO base
+	base = base & 0xff00;
+	val = inb(base + 0x4a);	// bit 6 is IDE cable type 0:80w, 1:40w
+	outb(0x10, 0x70);	// write to CMOS offset=0x10
+	outb(val, 0x71);
+	outb(0x10, 0x70);
+	val = inb(0x71);
+}
+
+DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686_4,
+			 chip_vt82c686b_pmio_setup);
+
+
+/**
+ * Optimize the PLX6540 bridges to take advantage of their
+ * internal buffering.
+ *
+ * @param dev
+ */
+static void chip_plx6540_optimize(struct pci_dev *dev)
+{
+	uint8_t buffer_control;
+	pci_write_config_byte(dev, 0x48, (2 << 1) /* PCIX 4 cache lines */ |(5 << 3)	/* PCI
+											   20
+											   dwords
+					 */ );
+					/* Primary bus prefetch */
+	pci_write_config_byte(dev, 0x4a, (8 << 2) /* 32 dwords */ );	/* Primary
+									   Incremental
+									   Prefetch
+									   Count
+									 */
+	pci_write_config_byte(dev, 0x4c, 96 /* max dwords prefetch */ );	/* Primary
+										   Maximum
+										   Prefetch
+										   Count
+										 */
+	pci_read_config_byte(dev, 0x4f, &buffer_control);
+	buffer_control |= 1 << 1;	/* Enable smart prefetch */
+	buffer_control |= 1 << 2;	/* Divide fifos into four */
+	pci_write_config_byte(dev, 0x4f, buffer_control);
+}
+
+DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_PLX, 0x6540, chip_plx6540_optimize);
diff --git a/arch/mips/cavium-octeon/pcie.c b/arch/mips/cavium-octeon/pcie.c
new file mode 100644
index 0000000..90f2c0f
--- /dev/null
+++ b/arch/mips/cavium-octeon/pcie.c
@@ -0,0 +1,401 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2007 Cavium Networks
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <asm/time.h>
+#include <asm/delay.h>
+#include "hal.h"
+#include "cvmx-pcie.h"
+#include "pci-common.h"
+
+
+/**
+ * Map a PCI device to the appropriate interrupt line
+ *
+ * @param dev    The Linux PCI device structure for the device to map
+ * @param slot   The slot number for this device on __BUS 0__. Linux
+ *               enumerates through all the bridges and figures out the
+ *               slot on Bus 0 where this device eventually hooks to.
+ * @param pin    The PCI interrupt pin read from the device, then swizzled
+ *               as it goes through each bridge.
+ * @return Interrupt number for the device
+ */
+int __init octeon_pcie_pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/* The EBH5600 board with the PCI to PCIe bridge mistakenly wires the
+	   first slot for both device id 2 and interrupt A. According to the
+	   PCI spec, device id 2 should be C. The following kludge attempts to
+	   fix this */
+	if (strstr(octeon_board_type_string(), "EBH5600") &&
+	    dev->bus && dev->bus->parent) {
+		/* Iterate all the way up the device chain and find the root
+		   bus */
+		while (dev->bus && dev->bus->parent)
+			dev = to_pci_dev(dev->bus->bridge);
+		/* If the root bus is number 0 and the PEX 8114 is the root,
+		   assume we are behind the miswired bus. We need to correct
+		   the swizzle level by two. Yuck */
+		if ((dev->bus->number == 0) &&
+		    (dev->vendor == 0x10b5) && (dev->device == 0x8114)) {
+			/* The pin field is one based, not zero. We need to
+			   swizzle it by minus two */
+			pin = ((pin - 3) & 3) + 1;
+		}
+	}
+	/* The -1 is because pin starts with one, not zero. It might be that
+	   this equation needs to include the slot number, but I don't have
+	   hardware to check that against */
+	return pin - 1 + OCTEON_IRQ_PCI_INT0;
+}
+
+/**
+ * Read a value from configuration space
+ *
+ * @param bus
+ * @param devfn
+ * @param reg
+ * @param size
+ * @param val
+ * @return
+ */
+static inline int octeon_pcie_read_config(int pcie_port, struct pci_bus *bus,
+					  unsigned int devfn, int reg, int size,
+					  u32 * val)
+{
+	octeon_cvmemctl_t cvmmemctl;
+	octeon_cvmemctl_t cvmmemctl_save;
+	int bus_number = bus->number;
+
+	/* We need to force the bus number to be zero on the root bus. Linux
+	   numbers the 2nd root bus to start after all busses on root 0 */
+	if (bus->parent == NULL)
+		bus_number = 0;
+
+	/* PCIe only has a single device connected to Octeon. It is always
+	   device ID 0. Don't bother doing reads for other device IDs on the
+	   first segment */
+	if ((bus_number == 0) && (devfn >> 3 != 0))
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+
+	/* The following is a workaround for the CN57XX, CN56XX, CN55XX, and
+	   CN54XX errata with PCIe config reads from non existent devices.
+	   These chips will hang the PCIe link if a config read is performed
+	   that causes a UR response */
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1) ||
+	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_1)) {
+		/* For our EBH5600 board, port 0 has a bridge with two PCI-X
+		   slots. We need a new special checks to make sure we only
+		   probe valid stuff */
+		/* The PCIe->PCI-X bridge only respondes to device ID 0,
+		   function 0-1 */
+		if ((bus_number == 0) && (devfn >= 2))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		/* The PCI-X slots are device ID 2,3. Choose one of the below
+		   "if" blocks based on what is plugged into the board */
+#if 1
+		/* Use this option if you aren't using either slot */
+		if (bus_number == 1)
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+#elif 0
+		/* Use this option if you are using the first slot but not the
+		   second */
+		if ((bus_number == 1) && (devfn >> 3 != 2))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+#elif 0
+		/* Use this option if you are using the second slot but not the
+		   first */
+		if ((bus_number == 1) && (devfn >> 3 != 3))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+#elif 0
+		/* Use this opion if you are using both slots */
+		if ((bus_number == 1) &&
+		    !((devfn == (2 << 3)) || (devfn == (3 << 3))))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+#endif
+
+		/* The following #if gives a more complicated example. This is
+		   the required checks for running a Nitrox CN16XX-NHBX in the
+		   slot of the EBH5600. This card has a PLX PCIe bridge with
+		   four Nitrox PLX parts behind it */
+#if 0
+		/* PLX bridge with 4 ports */
+		if ((bus_number == 3) &&
+		    !((devfn >> 3 >= 1) && (devfn >> 3 <= 4)))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		/* Nitrox behind PLX 1 */
+		if ((bus_number == 4) && (devfn >> 3 != 0))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		/* Nitrox behind PLX 2 */
+		if ((bus_number == 5) && (devfn >> 3 != 0))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		/* Nitrox behind PLX 3 */
+		if ((bus_number == 6) && (devfn >> 3 != 0))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		/* Nitrox behind PLX 4 */
+		if ((bus_number == 7) && (devfn >> 3 != 0))
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+#endif
+		/* Shorten the DID timeout so bus errors for PCIe config reads
+		   from non existent devices happen faster. This allows us to
+		   continue booting even if the above "if" checks are wrong.
+		   Once one of these errors happens, the PCIe port is dead */
+		cvmmemctl_save.u64 = __read_64bit_c0_register($11, 7);
+		cvmmemctl.u64 = cvmmemctl_save.u64;
+		cvmmemctl.s.didtto = 2;
+		__write_64bit_c0_register($11, 7, cvmmemctl.u64);
+	}
+
+	// printk("octeon_pcie_read_config(pcie_port=%d, bus=%d, devfn=0x%x,
+	// reg=0x%x, size=%d, val=%p)\n",
+	// pcie_port, bus_number, devfn, reg, size, val);
+
+	switch (size) {
+	case 4:
+		*val = cvmx_pcie_config_read32(pcie_port, bus_number,
+					       devfn >> 3, devfn & 0x7, reg);
+		break;
+	case 2:
+		*val = cvmx_pcie_config_read16(pcie_port, bus_number,
+					       devfn >> 3, devfn & 0x7, reg);
+		break;
+	case 1:
+		*val = cvmx_pcie_config_read8(pcie_port, bus_number, devfn >> 3,
+					      devfn & 0x7, reg);
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+	// printk("octeon_pcie_read_config val=0x%x\n", *val);
+	if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1) ||
+	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_1))
+		__write_64bit_c0_register($11, 7, cvmmemctl_save.u64);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int octeon_pcie0_read_config(struct pci_bus *bus, unsigned int devfn,
+				    int reg, int size, u32 * val)
+{
+	return octeon_pcie_read_config(0, bus, devfn, reg, size, val);
+}
+
+static int octeon_pcie1_read_config(struct pci_bus *bus, unsigned int devfn,
+				    int reg, int size, u32 * val)
+{
+	return octeon_pcie_read_config(1, bus, devfn, reg, size, val);
+}
+
+
+
+/**
+ * Write a value to PCI configuration space
+ *
+ * @param bus
+ * @param devfn
+ * @param reg
+ * @param size
+ * @param val
+ * @return
+ */
+static inline int octeon_pcie_write_config(int pcie_port, struct pci_bus *bus,
+					   unsigned int devfn, int reg,
+					   int size, u32 val)
+{
+	int bus_number = bus->number;
+	/* We need to force the bus number to be zero on the root bus. Linux
+	   numbers the 2nd root bus to start after all busses on root 0 */
+	if (bus->parent == NULL)
+		bus_number = 0;
+
+	// printk("octeon_pcie_write_config(pcie_port=%d, bus=%d, devfn=0x%x,
+	// reg=0x%x, size=%d, val=0x%x)\n",
+	// pcie_port, bus_number, devfn, reg, size, val);
+	switch (size) {
+	case 4:
+		cvmx_pcie_config_write32(pcie_port, bus_number, devfn >> 3,
+					 devfn & 0x7, reg, val);
+		return PCIBIOS_SUCCESSFUL;
+	case 2:
+		cvmx_pcie_config_write16(pcie_port, bus_number, devfn >> 3,
+					 devfn & 0x7, reg, val);
+		return PCIBIOS_SUCCESSFUL;
+	case 1:
+		cvmx_pcie_config_write8(pcie_port, bus_number, devfn >> 3,
+					devfn & 0x7, reg, val);
+		return PCIBIOS_SUCCESSFUL;
+	}
+#if PCI_CONFIG_SPACE_DELAY
+	udelay(PCI_CONFIG_SPACE_DELAY);
+#endif
+	return PCIBIOS_FUNC_NOT_SUPPORTED;
+}
+
+static int octeon_pcie0_write_config(struct pci_bus *bus, unsigned int devfn,
+				     int reg, int size, u32 val)
+{
+	return octeon_pcie_write_config(0, bus, devfn, reg, size, val);
+}
+
+static int octeon_pcie1_write_config(struct pci_bus *bus, unsigned int devfn,
+				     int reg, int size, u32 val)
+{
+	return octeon_pcie_write_config(1, bus, devfn, reg, size, val);
+}
+
+static struct pci_ops octeon_pcie0_ops = {
+	octeon_pcie0_read_config,
+	octeon_pcie0_write_config,
+};
+
+static struct resource octeon_pcie0_mem_resource = {
+	.name = "Octeon PCIe0 MEM",
+	.flags = IORESOURCE_MEM,
+};
+
+static struct resource octeon_pcie0_io_resource = {
+	.name = "Octeon PCIe0 IO",
+	.flags = IORESOURCE_IO,
+};
+
+static struct pci_controller octeon_pcie0_controller = {
+	.pci_ops = &octeon_pcie0_ops,
+	.mem_resource = &octeon_pcie0_mem_resource,
+	.io_resource = &octeon_pcie0_io_resource,
+};
+
+static struct pci_ops octeon_pcie1_ops = {
+	octeon_pcie1_read_config,
+	octeon_pcie1_write_config,
+};
+
+static struct resource octeon_pcie1_mem_resource = {
+	.name = "Octeon PCIe1 MEM",
+	.flags = IORESOURCE_MEM,
+};
+
+static struct resource octeon_pcie1_io_resource = {
+	.name = "Octeon PCIe1 IO",
+	.flags = IORESOURCE_IO,
+};
+
+static struct pci_controller octeon_pcie1_controller = {
+	.pci_ops = &octeon_pcie1_ops,
+	.mem_resource = &octeon_pcie1_mem_resource,
+	.io_resource = &octeon_pcie1_io_resource,
+};
+
+
+/**
+ * Initialize the Octeon PCIe controllers
+ *
+ * @return
+ */
+static int __init octeon_pcie_setup(void)
+{
+	cvmx_npei_ctl_status_t npei_ctl_status;
+	int result;
+
+	/* These chips don't have PCIe */
+	if (!octeon_has_feature(OCTEON_FEATURE_PCIE))
+		return 0;
+
+	/* Point pcibios_map_irq() to the PCIe version of it */
+	octeon_pcibios_map_irq = octeon_pcie_pcibios_map_irq;
+
+	/* Use the PCIe based DMA mappings */
+	octeon_dma_bar_type = OCTEON_DMA_BAR_TYPE_PCIE;
+
+	/* Mark the Octeon CSR region as IO */
+	iomem_resource.start = (1ull << 48);
+	iomem_resource.end = (2ull << 48) - 1;
+
+	/* PCIe I/O range. It is based on port 0 but includes up until port 1's
+	   end */
+	set_io_port_base(CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0)));
+	ioport_resource.start = 0;
+	ioport_resource.end =
+		cvmx_pcie_get_io_base_address(1) -
+		cvmx_pcie_get_io_base_address(0) + cvmx_pcie_get_io_size(1) - 1;
+
+	npei_ctl_status.u64 = cvmx_read_csr(CVMX_PEXP_NPEI_CTL_STATUS);
+	if (npei_ctl_status.s.host_mode) {
+		printk("PCIe: Initializing port 0\n");
+		result = cvmx_pcie_rc_initialize(0);
+		if (result == 0) {
+			/* Memory offsets are physical addresses */
+			octeon_pcie0_controller.mem_offset =
+				cvmx_pcie_get_mem_base_address(0);
+			/* IO offsets are Mips virtual addresses */
+			octeon_pcie0_controller.io_map_base =
+				CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address
+						(0));
+			octeon_pcie0_controller.io_offset = 0;
+			/* To keep things similar to PCI, we start device
+			   addresses at the same place as PCI uisng big bar
+			   support. This normally translates to 4GB-256MB,
+			   which is the same as most x86 PCs */
+			octeon_pcie0_controller.mem_resource->start =
+				cvmx_pcie_get_mem_base_address(0) +
+				(4ul << 30) - (OCTEON_PCI_BAR1_HOLE_SIZE << 20);
+			octeon_pcie0_controller.mem_resource->end =
+				cvmx_pcie_get_mem_base_address(0) +
+				cvmx_pcie_get_mem_size(0) - 1;
+			/* Ports must be above 16KB for the ISA bus filtering
+			   in the PCI-X to PCI bridge */
+			octeon_pcie0_controller.io_resource->start = 4 << 10;
+			octeon_pcie0_controller.io_resource->end =
+				cvmx_pcie_get_io_size(0) - 1;
+			register_pci_controller(&octeon_pcie0_controller);
+		}
+	} else
+		printk("PCIe: Port 0 in endpoint mode, skipping.\n");
+
+	/* Skip the 2nd port on CN52XX if port 0 is in 4 lane mode */
+	if (OCTEON_IS_MODEL(OCTEON_CN52XX)) {
+		cvmx_npei_dbg_data_t npei_dbg_data;
+		npei_dbg_data.u64 = cvmx_read_csr(CVMX_PEXP_NPEI_DBG_DATA);
+		if (npei_dbg_data.cn52xx.qlm0_link_width)
+			return 0;
+	}
+
+	printk("PCIe: Initializing port 1\n");
+	result = cvmx_pcie_rc_initialize(1);
+	if (result == 0) {
+		/* Memory offsets are physical addresses */
+		octeon_pcie1_controller.mem_offset =
+			cvmx_pcie_get_mem_base_address(1);
+		/* IO offsets are Mips virtual addresses */
+		octeon_pcie1_controller.io_map_base =
+			CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(1));
+		octeon_pcie1_controller.io_offset =
+			cvmx_pcie_get_io_base_address(1) -
+			cvmx_pcie_get_io_base_address(0);
+		/* To keep things similar to PCI, we start device addresses at
+		   the same place as PCI uisng big bar support. This normally
+		   translates to 4GB-256MB, which is the same as most x86 PCs */
+		octeon_pcie1_controller.mem_resource->start =
+			cvmx_pcie_get_mem_base_address(1) + (4ul << 30) -
+			(OCTEON_PCI_BAR1_HOLE_SIZE << 20);
+		octeon_pcie1_controller.mem_resource->end =
+			cvmx_pcie_get_mem_base_address(1) +
+			cvmx_pcie_get_mem_size(1) - 1;
+		/* Ports must be above 16KB for the ISA bus filtering in the
+		   PCI-X to PCI bridge */
+		octeon_pcie1_controller.io_resource->start =
+			cvmx_pcie_get_io_base_address(1) -
+			cvmx_pcie_get_io_base_address(0);
+		octeon_pcie1_controller.io_resource->end =
+			octeon_pcie1_controller.io_resource->start +
+			cvmx_pcie_get_io_size(1) - 1;
+		register_pci_controller(&octeon_pcie1_controller);
+	}
+	return 0;
+}
+
+arch_initcall(octeon_pcie_setup);
-- 
1.5.5.1

