From eb400d0a4f8ff60b784079e6afe5164078fd6888 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 20 May 2010 14:28:54 +0800
Subject: [PATCH 07/23] CPPI 4.1 support.

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.12.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add Communications Port Programming Interface(CPPI) 4.1 DMA module support.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/usb/musb/Kconfig       |   10 +-
 drivers/usb/musb/Makefile      |    5 +-
 drivers/usb/musb/cppi41.c      |  970 +++++++++++++++++++++++++++++
 drivers/usb/musb/cppi41.h      |  788 ++++++++++++++++++++++++
 drivers/usb/musb/cppi41_dma.c  | 1325 ++++++++++++++++++++++++++++++++++++++++
 drivers/usb/musb/cppi41_dma.h  |   68 ++
 drivers/usb/musb/musb_core.c   |    4 +-
 drivers/usb/musb/musb_dma.h    |    6 +
 drivers/usb/musb/musb_gadget.c |    4 +-
 drivers/usb/musb/musb_host.c   |   45 +-
 10 files changed, 3207 insertions(+), 18 deletions(-)
 create mode 100644 drivers/usb/musb/cppi41.c
 create mode 100644 drivers/usb/musb/cppi41.h
 create mode 100644 drivers/usb/musb/cppi41_dma.c
 create mode 100644 drivers/usb/musb/cppi41_dma.h

diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 07fe490..8a6c781 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -160,10 +160,18 @@ config USB_INVENTRA_DMA
 config USB_TI_CPPI_DMA
 	bool
 	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
-	default ARCH_DAVINCI
+	default ARCH_DAVINCI_DMx
 	help
 	  Enable DMA transfers when TI CPPI DMA is available.
 
+config USB_TI_CPPI41_DMA
+	bool
+	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
+	default ARCH_DAVINCI_DA8XX || MACH_OMAP3517EVM
+	select CPPI41
+	help
+	 Enable DMA transfers when TI CPPI 4.1 DMA is available.
+
 config USB_TUSB_OMAP_DMA
 	bool
 	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 3a485da..a330ae4 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -55,7 +55,10 @@ ifneq ($(CONFIG_MUSB_PIO_ONLY),y)
     else
       ifeq ($(CONFIG_USB_TUSB_OMAP_DMA),y)
         musb_hdrc-objs		+= tusb6010_omap.o
-
+      else
+        ifeq ($(CONFIG_USB_TI_CPPI41_DMA),y)
+          musb_hdrc-objs          += cppi41_dma.o cppi41.o
+        endif
       endif
     endif
   endif
diff --git a/drivers/usb/musb/cppi41.c b/drivers/usb/musb/cppi41.c
new file mode 100644
index 0000000..771d7ac
--- /dev/null
+++ b/drivers/usb/musb/cppi41.c
@@ -0,0 +1,970 @@
+/*
+ * CPPI 4.1 support
+ *
+ * Copyright (C) 2008-2009 MontaVista Software, Inc. <source@mvista.com>
+ *
+ * Based on the PAL CPPI 4.1 implementation
+ * Copyright (C) 1998-2006 Texas Instruments Incorporated
+ *
+ * This file contains the main implementation for CPPI 4.1 common peripherals,
+ * including the DMA Controllers and the Queue Managers.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+
+#include "cppi41.h"
+
+#undef	CPPI41_DEBUG
+
+#ifdef	CPPI41_DEBUG
+#define DBG(format, args...) printk(format, ##args)
+#else
+#define DBG(format, args...)
+#endif
+
+static struct {
+	void *virt_addr;
+	dma_addr_t phys_addr;
+	u32 size;
+} linking_ram[CPPI41_NUM_QUEUE_MGR];
+
+static u32 *allocated_queues[CPPI41_NUM_QUEUE_MGR];
+
+/* First 32 packet descriptors are reserved for unallocated memory regions. */
+static u32 next_desc_index[CPPI41_NUM_QUEUE_MGR] = { 1 << 5 };
+static u8  next_mem_rgn[CPPI41_NUM_QUEUE_MGR];
+
+static struct {
+	size_t rgn_size;
+	void *virt_addr;
+	dma_addr_t phys_addr;
+	struct cppi41_queue_obj queue_obj;
+	u8 mem_rgn;
+} dma_teardown[CPPI41_NUM_DMA_BLOCK];
+
+struct cppi41_dma_sched_tbl_t {
+	u8      pos;
+	u8      dma_ch;
+	u8      is_tx;
+	u8      enb;
+};
+
+#define MAX_SCHED_TBL_ENTRY     8
+struct cppi41_dma_sched_tbl_t dma_sched_tbl[MAX_SCHED_TBL_ENTRY] = {
+	/*pos  dma_ch#  is_tx  enb/dis*/
+	{ 0,    0,      0,      1},
+	{ 1,    0,      1,      1},
+	{ 2,    1,      0,      1},
+	{ 3,    1,      1,      1},
+	{ 4,    2,      0,      1},
+	{ 5,    2,      1,      1},
+	{ 6,    3,      0,      1},
+	{ 7,    3,      1,      1}
+};
+
+/******************** CPPI 4.1 Functions (External Interface) *****************/
+
+int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size)
+{
+	void __iomem *q_mgr_regs;
+	void *ptr;
+
+	if (q_mgr >= cppi41_num_queue_mgr)
+		return -EINVAL;
+
+	q_mgr_regs = cppi41_queue_mgr[q_mgr].q_mgr_rgn_base;
+	ptr = dma_alloc_coherent(NULL, rgn0_size * 4,
+				 &linking_ram[q_mgr].phys_addr,
+				 GFP_KERNEL | GFP_DMA);
+	if (ptr == NULL) {
+		printk(KERN_ERR "ERROR: %s: Unable to allocate "
+		       "linking RAM.\n", __func__);
+		return -ENOMEM;
+	}
+	linking_ram[q_mgr].virt_addr = ptr;
+
+	__raw_writel(linking_ram[q_mgr].phys_addr,
+			q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
+	DBG("Linking RAM region 0 base @ %p, value: %x\n",
+	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG,
+	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG));
+
+	__raw_writel(rgn0_size, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
+	DBG("Linking RAM region 0 size @ %p, value: %x\n",
+	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG,
+	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG));
+
+	ptr = kzalloc(BITS_TO_LONGS(cppi41_queue_mgr[q_mgr].num_queue),
+		      GFP_KERNEL);
+	if (ptr == NULL) {
+		printk(KERN_ERR "ERROR: %s: Unable to allocate queue bitmap.\n",
+		       __func__);
+		dma_free_coherent(NULL, rgn0_size * 4,
+				  linking_ram[q_mgr].virt_addr,
+				  linking_ram[q_mgr].phys_addr);
+		return -ENOMEM;
+	}
+	allocated_queues[q_mgr] = ptr;
+
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_queue_mgr_init);
+
+void cppi41_queue_mgr_deinit(u8 q_mgr)
+{
+	/* free the allocated linking ram memory */
+	dma_free_coherent(NULL, linking_ram[q_mgr].size,
+		linking_ram[q_mgr].virt_addr, linking_ram[q_mgr].phys_addr);
+
+	linking_ram[q_mgr].virt_addr = 0;
+	linking_ram[q_mgr].phys_addr = 0;
+	linking_ram[q_mgr].size = 0;
+
+	/* free the queue bit map memory */
+	kzfree(allocated_queues[q_mgr]);
+	allocated_queues[q_mgr] = 0;
+}
+EXPORT_SYMBOL(cppi41_queue_mgr_deinit);
+
+int cppi41_dma_sched_tbl_init(u8 dma_num, u8 q_mgr,
+			u32 *sched_tbl, u8 tbl_size)
+{
+	struct cppi41_dma_block *dma_block;
+	int num_reg, k, i, val = 0;
+
+	dma_block = (struct cppi41_dma_block *)&cppi41_dma_block[dma_num];
+
+	num_reg = (tbl_size + 3) / 4;
+	for (k = i = 0; i < num_reg; i++) {
+#if 0
+		for (val = j = 0; j < 4; j++, k++) {
+			val >>= 8;
+			if (k < tbl_size)
+				val |= sched_tbl[k] << 24;
+		}
+#endif
+		val = sched_tbl[i];
+		__raw_writel(val, dma_block->sched_table_base +
+			DMA_SCHED_TABLE_WORD_REG(i));
+		DBG("DMA scheduler table @ %p, value written: %x\n",
+		dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
+			val);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_dma_sched_tbl_init);
+
+int cppi41_schedtbl_add_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx)
+{
+	struct cppi41_dma_block *dma_block;
+	int num_ch, i, tbl_index = 0, j = 0, found = 0;
+	u32 val;
+
+	dma_block = (struct cppi41_dma_block *)&cppi41_dma_block[dmanum];
+
+	val = 0;
+	for (num_ch = 0, i = 0; i < MAX_SCHED_TBL_ENTRY; i++) {
+		if (!found && dma_sched_tbl[i].dma_ch == dma_ch &&
+			dma_sched_tbl[i].is_tx == is_tx &&
+			dma_sched_tbl[i].enb == 0) {
+			dma_sched_tbl[i].enb = 1;
+			found = 1;
+		}
+
+		if (dma_sched_tbl[i].enb) {
+			val |= ((dma_sched_tbl[i].dma_ch |
+				(dma_sched_tbl[i].is_tx ? 0 : (1<<7))) << j*8);
+			num_ch++;
+			j++;
+		}
+		if (num_ch % 4 == 0) {
+			__raw_writel(val, dma_block->sched_table_base +
+				DMA_SCHED_TABLE_WORD_REG(tbl_index));
+			tbl_index++;
+			val = j = 0;
+		}
+	}
+
+	if (num_ch % 4) {
+		__raw_writel(val, dma_block->sched_table_base +
+			DMA_SCHED_TABLE_WORD_REG(tbl_index));
+	}
+	return num_ch;
+}
+EXPORT_SYMBOL(cppi41_schedtbl_add_dma_ch);
+
+int cppi41_schedtbl_remove_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx)
+{
+	struct cppi41_dma_block *dma_block;
+	int num_ch, i, tbl_index = 0, j = 0, found = 0;
+	u32 val;
+
+	dma_block = (struct cppi41_dma_block *)&cppi41_dma_block[dmanum];
+
+	val = 0;
+	for (num_ch = 0, i = 0; i < MAX_SCHED_TBL_ENTRY; i++) {
+		if (!found && dma_sched_tbl[i].dma_ch == dma_ch &&
+			dma_sched_tbl[i].is_tx == is_tx &&
+			dma_sched_tbl[i].enb == 1) {
+			dma_sched_tbl[i].enb = 0;
+		}
+
+		if (dma_sched_tbl[i].enb) {
+			val |= ((dma_sched_tbl[i].dma_ch |
+				(dma_sched_tbl[i].is_tx ? 0 : (1<<7))) << j*8);
+			num_ch++;
+			j++;
+		}
+		if (num_ch % 4 == 0) {
+			__raw_writel(val, dma_block->sched_table_base +
+				DMA_SCHED_TABLE_WORD_REG(tbl_index));
+			tbl_index++;
+			val = j = 0;
+		}
+	}
+
+	if (num_ch % 4) {
+		__raw_writel(val, dma_block->sched_table_base +
+			DMA_SCHED_TABLE_WORD_REG(tbl_index));
+	}
+	return num_ch;
+}
+EXPORT_SYMBOL(cppi41_schedtbl_remove_dma_ch);
+
+int cppi41_dma_block_init(u8 dma_num, u8 q_mgr, u8 num_order,
+				 u32 *sched_tbl, u8 tbl_size)
+{
+	const struct cppi41_dma_block *dma_block;
+	struct cppi41_teardown_desc *curr_td;
+	dma_addr_t td_addr;
+	unsigned num_desc, num_reg;
+	void *ptr;
+	int error, i;
+	u16 q_num;
+	u32 val;
+
+	if (dma_num >= cppi41_num_dma_block ||
+	    q_mgr >= cppi41_num_queue_mgr ||
+	    !tbl_size || sched_tbl == NULL)
+		return -EINVAL;
+
+	error = cppi41_queue_alloc(CPPI41_FREE_DESC_QUEUE |
+				   CPPI41_UNASSIGNED_QUEUE, q_mgr, &q_num);
+	if (error) {
+		printk(KERN_ERR "ERROR: %s: Unable to allocate teardown "
+		       "descriptor queue.\n", __func__);
+		return error;
+	}
+	DBG("Teardown descriptor queue %d in queue manager 0 "
+	    "allocated\n", q_num);
+
+	/*
+	 * Tell the hardware about the Teardown descriptor
+	 * queue manager and queue number.
+	 */
+	dma_block = &cppi41_dma_block[dma_num];
+	__raw_writel((q_mgr << DMA_TD_DESC_QMGR_SHIFT) |
+		     (q_num << DMA_TD_DESC_QNUM_SHIFT),
+		     dma_block->global_ctrl_base +
+		     DMA_TEARDOWN_FREE_DESC_CTRL_REG);
+	DBG("Teardown free descriptor control @ %p, value: %x\n",
+	    dma_block->global_ctrl_base + DMA_TEARDOWN_FREE_DESC_CTRL_REG,
+	    __raw_readl(dma_block->global_ctrl_base +
+			DMA_TEARDOWN_FREE_DESC_CTRL_REG));
+
+	num_desc = 1 << num_order;
+	dma_teardown[dma_num].rgn_size = num_desc *
+					 sizeof(struct cppi41_teardown_desc);
+
+	/* Pre-allocate teardown descriptors. */
+	ptr = dma_alloc_coherent(NULL, dma_teardown[dma_num].rgn_size,
+				 &dma_teardown[dma_num].phys_addr,
+				 GFP_KERNEL | GFP_DMA);
+	if (ptr == NULL) {
+		printk(KERN_ERR "ERROR: %s: Unable to allocate teardown "
+		       "descriptors.\n", __func__);
+		error = -ENOMEM;
+		goto free_queue;
+	}
+	dma_teardown[dma_num].virt_addr = ptr;
+
+	error = cppi41_mem_rgn_alloc(q_mgr, dma_teardown[dma_num].phys_addr, 5,
+				     num_order, &dma_teardown[dma_num].mem_rgn);
+	if (error) {
+		printk(KERN_ERR "ERROR: %s: Unable to allocate queue manager "
+		       "memory region for teardown descriptors.\n", __func__);
+		goto free_mem;
+	}
+
+	error = cppi41_queue_init(&dma_teardown[dma_num].queue_obj, 0, q_num);
+	if (error) {
+		printk(KERN_ERR "ERROR: %s: Unable to initialize teardown "
+		       "free descriptor queue.\n", __func__);
+		goto free_rgn;
+	}
+
+	/*
+	 * Push all teardown descriptors to the free teardown queue
+	 * for the CPPI 4.1 system.
+	 */
+	curr_td = dma_teardown[dma_num].virt_addr;
+	td_addr = dma_teardown[dma_num].phys_addr;
+
+	for (i = 0; i < num_desc; i++) {
+		cppi41_queue_push(&dma_teardown[dma_num].queue_obj, td_addr,
+				  sizeof(*curr_td), 0);
+		td_addr += sizeof(*curr_td);
+	}
+
+	/* Initialize the DMA scheduler. */
+	num_reg = (tbl_size + 3) / 4;
+	for (i = 0; i < num_reg; i++) {
+		val = sched_tbl[i];
+		__raw_writel(val, dma_block->sched_table_base +
+			     DMA_SCHED_TABLE_WORD_REG(i));
+		DBG("DMA scheduler table @ %p, value written: %x\n",
+		    dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
+		    val);
+	}
+
+	__raw_writel((tbl_size - 1) << DMA_SCHED_LAST_ENTRY_SHIFT |
+		     DMA_SCHED_ENABLE_MASK,
+		     dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG);
+	DBG("DMA scheduler control @ %p, value: %x\n",
+	    dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG,
+	    __raw_readl(dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG));
+
+	return 0;
+
+free_rgn:
+	cppi41_mem_rgn_free(q_mgr, dma_teardown[dma_num].mem_rgn);
+free_mem:
+	dma_free_coherent(NULL, dma_teardown[dma_num].rgn_size,
+			  dma_teardown[dma_num].virt_addr,
+			  dma_teardown[dma_num].phys_addr);
+free_queue:
+	cppi41_queue_free(q_mgr, q_num);
+	return error;
+}
+EXPORT_SYMBOL(cppi41_dma_block_init);
+
+void cppi41_dma_block_deinit(u8 dma_num, u8 q_mgr)
+{
+	/* pop all the teardown descriptors from teardown queue */
+	cppi41_free_teardown_queue(dma_num);
+	dma_teardown[dma_num].queue_obj.base_addr = NULL;
+
+	/* free the teardown descripotr memory */
+	dma_free_coherent(NULL, dma_teardown[dma_num].rgn_size,
+		dma_teardown[dma_num].virt_addr,
+		dma_teardown[dma_num].phys_addr);
+
+	dma_teardown[dma_num].virt_addr = 0;
+	dma_teardown[dma_num].phys_addr = 0;
+}
+EXPORT_SYMBOL(cppi41_dma_block_deinit);
+
+/*
+ * cppi41_mem_rgn_alloc - allocate a memory region within the queue manager
+ */
+int cppi41_mem_rgn_alloc(u8 q_mgr, dma_addr_t rgn_addr, u8 size_order,
+			 u8 num_order, u8 *mem_rgn)
+{
+	void __iomem *desc_mem_regs;
+	u32 num_desc = 1 << num_order, index, ctrl;
+	int rgn;
+
+	DBG("%s called with rgn_addr = %08x, size_order = %d, num_order = %d\n",
+	    __func__, rgn_addr, size_order, num_order);
+
+	if (q_mgr >= cppi41_num_queue_mgr ||
+	    size_order < 5 || size_order > 13 ||
+	    num_order  < 5 || num_order  > 12 ||
+	    (rgn_addr & ((1 << size_order) - 1)))
+		return -EINVAL;
+
+	rgn = next_mem_rgn[q_mgr];
+	index = next_desc_index[q_mgr];
+	if (rgn >= CPPI41_MAX_MEM_RGN || index + num_desc > 0x4000)
+		return -ENOSPC;
+
+	next_mem_rgn[q_mgr] = rgn + 1;
+	next_desc_index[q_mgr] = index + num_desc;
+
+	desc_mem_regs = cppi41_queue_mgr[q_mgr].desc_mem_rgn_base;
+
+	/* Write the base register */
+	__raw_writel(rgn_addr, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn));
+	DBG("Descriptor region base @ %p, value: %x\n",
+	    desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn),
+	    __raw_readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(rgn)));
+
+	/* Write the control register */
+	ctrl = ((index << QMGR_MEM_RGN_INDEX_SHIFT) &
+		QMGR_MEM_RGN_INDEX_MASK) |
+	       (((size_order - 5) << QMGR_MEM_RGN_DESC_SIZE_SHIFT) &
+		QMGR_MEM_RGN_DESC_SIZE_MASK) |
+	       (((num_order - 5) << QMGR_MEM_RGN_SIZE_SHIFT) &
+		QMGR_MEM_RGN_SIZE_MASK);
+	__raw_writel(ctrl, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn));
+	DBG("Descriptor region control @ %p, value: %x\n",
+	    desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn),
+	    __raw_readl(desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(rgn)));
+
+	*mem_rgn = rgn;
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_mem_rgn_alloc);
+
+/*
+ * cppi41_mem_rgn_free - free the memory region within the queue manager
+ */
+int cppi41_mem_rgn_free(u8 q_mgr, u8 mem_rgn)
+{
+	void __iomem *desc_mem_regs;
+
+	DBG("%s called.\n", __func__);
+
+	if (q_mgr >= cppi41_num_queue_mgr || mem_rgn >= next_mem_rgn[q_mgr])
+		return -EINVAL;
+
+	desc_mem_regs = cppi41_queue_mgr[q_mgr].desc_mem_rgn_base;
+
+	if (__raw_readl(desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn)) == 0)
+		return -ENOENT;
+
+	__raw_writel(0, desc_mem_regs + QMGR_MEM_RGN_BASE_REG(mem_rgn));
+	__raw_writel(0, desc_mem_regs + QMGR_MEM_RGN_CTRL_REG(mem_rgn));
+
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_mem_rgn_free);
+
+/*
+ * cppi41_tx_ch_init - initialize a CPPI 4.1 Tx channel object
+ *
+ * Verify the channel info (range checking, etc.) and store the channel
+ * information within the object structure.
+ */
+int cppi41_tx_ch_init(struct cppi41_dma_ch_obj *tx_ch_obj,
+		      u8 dma_num, u8 ch_num)
+{
+	if (dma_num >= cppi41_num_dma_block ||
+	    ch_num  >= cppi41_dma_block[dma_num].num_tx_ch)
+		return -EINVAL;
+
+	/* Populate the channel object structure */
+	tx_ch_obj->base_addr  = cppi41_dma_block[dma_num].ch_ctrl_stat_base +
+				DMA_CH_TX_GLOBAL_CFG_REG(ch_num);
+	tx_ch_obj->global_cfg = __raw_readl(tx_ch_obj->base_addr);
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_tx_ch_init);
+
+/*
+ * cppi41_rx_ch_init - initialize a CPPI 4.1 Rx channel object
+ *
+ * Verify the channel info (range checking, etc.) and store the channel
+ * information within the object structure.
+ */
+int cppi41_rx_ch_init(struct cppi41_dma_ch_obj *rx_ch_obj,
+		      u8 dma_num, u8 ch_num)
+{
+	if (dma_num >= cppi41_num_dma_block ||
+	    ch_num  >= cppi41_dma_block[dma_num].num_rx_ch)
+		return -EINVAL;
+
+	/* Populate the channel object structure */
+	rx_ch_obj->base_addr  = cppi41_dma_block[dma_num].ch_ctrl_stat_base +
+				DMA_CH_RX_GLOBAL_CFG_REG(ch_num);
+	rx_ch_obj->global_cfg = __raw_readl(rx_ch_obj->base_addr);
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_rx_ch_init);
+
+/*
+ * We have to cache the last written Rx/Tx channel global configration register
+ * value due to its bits other than enable/teardown being write-only. Yet there
+ * is a caveat related to caching the enable bit: this bit may be automatically
+ * cleared as a result of teardown, so we can't trust its cached value!
+ * When modifying the write only register fields, we're making use of the fact
+ * that they read back as zeros, and not clearing them explicitly...
+ */
+
+/*
+ * cppi41_dma_ch_default_queue - set CPPI 4.1 channel default completion queue
+ */
+void cppi41_dma_ch_default_queue(struct cppi41_dma_ch_obj *dma_ch_obj,
+				 u8 q_mgr, u16 q_num)
+{
+	u32 val = dma_ch_obj->global_cfg;
+
+	/* Clear the fields to be modified. */
+	val &= ~(DMA_CH_TX_DEFAULT_QMGR_MASK | DMA_CH_TX_DEFAULT_QNUM_MASK |
+		 DMA_CH_TX_ENABLE_MASK);
+
+	/* Set the default completion queue. */
+	val |= ((q_mgr << DMA_CH_TX_DEFAULT_QMGR_SHIFT) &
+		DMA_CH_TX_DEFAULT_QMGR_MASK) |
+	       ((q_num << DMA_CH_TX_DEFAULT_QNUM_SHIFT) &
+		DMA_CH_TX_DEFAULT_QNUM_MASK);
+
+	/* Get the current state of the enable bit. */
+	dma_ch_obj->global_cfg = val |= __raw_readl(dma_ch_obj->base_addr);
+	__raw_writel(val, dma_ch_obj->base_addr);
+	DBG("Channel global configuration @ %p, value written: %x, "
+	    "value read: %x\n", dma_ch_obj->base_addr, val,
+	    __raw_readl(dma_ch_obj->base_addr));
+
+}
+EXPORT_SYMBOL(cppi41_dma_ch_default_queue);
+
+/*
+ * cppi41_rx_ch_configure - configure CPPI 4.1 Rx channel
+ */
+void cppi41_rx_ch_configure(struct cppi41_dma_ch_obj *rx_ch_obj,
+			    struct cppi41_rx_ch_cfg  *cfg)
+{
+	void __iomem *base = rx_ch_obj->base_addr;
+	u32 val = __raw_readl(rx_ch_obj->base_addr);
+
+	val |= ((cfg->sop_offset << DMA_CH_RX_SOP_OFFSET_SHIFT) &
+		DMA_CH_RX_SOP_OFFSET_MASK) |
+	       ((cfg->default_desc_type << DMA_CH_RX_DEFAULT_DESC_TYPE_SHIFT) &
+		DMA_CH_RX_DEFAULT_DESC_TYPE_MASK) |
+	       ((cfg->retry_starved << DMA_CH_RX_ERROR_HANDLING_SHIFT) &
+		DMA_CH_RX_ERROR_HANDLING_MASK) |
+	       ((cfg->rx_queue.q_mgr << DMA_CH_RX_DEFAULT_RQ_QMGR_SHIFT) &
+		DMA_CH_RX_DEFAULT_RQ_QMGR_MASK) |
+	       ((cfg->rx_queue.q_num << DMA_CH_RX_DEFAULT_RQ_QNUM_SHIFT) &
+		DMA_CH_RX_DEFAULT_RQ_QNUM_MASK);
+
+	rx_ch_obj->global_cfg = val;
+	__raw_writel(val, base);
+	DBG("Rx channel global configuration @ %p, value written: %x, "
+	    "value read: %x\n", base, val, __raw_readl(base));
+
+	base -= DMA_CH_RX_GLOBAL_CFG_REG(0);
+
+	/*
+	 * Set up the packet configuration register
+	 * based on the descriptor type...
+	 */
+	switch (cfg->default_desc_type) {
+	case DMA_CH_RX_DEFAULT_DESC_EMBED:
+		val = ((cfg->cfg.embed_pkt.fd_queue.q_mgr <<
+			DMA_CH_RX_EMBED_FDQ_QMGR_SHIFT) &
+		       DMA_CH_RX_EMBED_FDQ_QMGR_MASK) |
+		      ((cfg->cfg.embed_pkt.fd_queue.q_num <<
+			DMA_CH_RX_EMBED_FDQ_QNUM_SHIFT) &
+		       DMA_CH_RX_EMBED_FDQ_QNUM_MASK) |
+		      ((cfg->cfg.embed_pkt.num_buf_slot <<
+			DMA_CH_RX_EMBED_NUM_SLOT_SHIFT) &
+		       DMA_CH_RX_EMBED_NUM_SLOT_MASK) |
+		      ((cfg->cfg.embed_pkt.sop_slot_num <<
+			DMA_CH_RX_EMBED_SOP_SLOT_SHIFT) &
+		       DMA_CH_RX_EMBED_SOP_SLOT_MASK);
+
+		__raw_writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_B(0));
+		DBG("Rx channel embedded packet configuration B @ %p, "
+		    "value written: %x\n",
+		    base + DMA_CH_RX_EMBED_PKT_CFG_REG_B(0), val);
+
+		val = ((cfg->cfg.embed_pkt.free_buf_pool[0].b_pool <<
+			DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(0)) &
+		       DMA_CH_RX_EMBED_FBP_PNUM_MASK(0)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[0].b_mgr <<
+			DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(0)) &
+		       DMA_CH_RX_EMBED_FBP_BMGR_MASK(0)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[1].b_pool <<
+			DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(1)) &
+		       DMA_CH_RX_EMBED_FBP_PNUM_MASK(1)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[1].b_mgr <<
+			DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(1)) &
+		       DMA_CH_RX_EMBED_FBP_BMGR_MASK(1)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[2].b_pool <<
+			DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(2)) &
+		       DMA_CH_RX_EMBED_FBP_PNUM_MASK(2)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[2].b_mgr <<
+			DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(2)) &
+		       DMA_CH_RX_EMBED_FBP_BMGR_MASK(2)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[3].b_pool <<
+			DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(3)) &
+		       DMA_CH_RX_EMBED_FBP_PNUM_MASK(3)) |
+		      ((cfg->cfg.embed_pkt.free_buf_pool[3].b_mgr <<
+			DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(3)) &
+		       DMA_CH_RX_EMBED_FBP_BMGR_MASK(3));
+
+		__raw_writel(val, base + DMA_CH_RX_EMBED_PKT_CFG_REG_A(0));
+		DBG("Rx channel embedded packet configuration A @ %p, "
+		    "value written: %x\n",
+		    base + DMA_CH_RX_EMBED_PKT_CFG_REG_A(0), val);
+		break;
+	case DMA_CH_RX_DEFAULT_DESC_HOST:
+		val = ((cfg->cfg.host_pkt.fdb_queue[0].q_num <<
+			DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(0)) &
+		       DMA_CH_RX_HOST_FDQ_QNUM_MASK(0)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[0].q_mgr <<
+			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(0)) &
+		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(0)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[1].q_num <<
+			DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(1)) &
+		       DMA_CH_RX_HOST_FDQ_QNUM_MASK(1)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[1].q_mgr <<
+			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(1)) &
+		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(1));
+
+		__raw_writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_A(0));
+		DBG("Rx channel host packet configuration A @ %p, "
+		    "value written: %x\n",
+		    base + DMA_CH_RX_HOST_PKT_CFG_REG_A(0), val);
+
+		val = ((cfg->cfg.host_pkt.fdb_queue[2].q_num <<
+			DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(2)) &
+		       DMA_CH_RX_HOST_FDQ_QNUM_MASK(2)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[2].q_mgr <<
+			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(2)) &
+		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(2)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[3].q_num <<
+		       DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(3)) &
+		       DMA_CH_RX_HOST_FDQ_QNUM_MASK(3)) |
+		      ((cfg->cfg.host_pkt.fdb_queue[3].q_mgr <<
+			DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(3)) &
+		       DMA_CH_RX_HOST_FDQ_QMGR_MASK(3));
+
+		__raw_writel(val, base + DMA_CH_RX_HOST_PKT_CFG_REG_B(0));
+		DBG("Rx channel host packet configuration B @ %p, "
+		    "value written: %x\n",
+		    base + DMA_CH_RX_HOST_PKT_CFG_REG_B(0), val);
+		break;
+	case DMA_CH_RX_DEFAULT_DESC_MONO:
+		val = ((cfg->cfg.mono_pkt.fd_queue.q_num <<
+			DMA_CH_RX_MONO_FDQ_QNUM_SHIFT) &
+		       DMA_CH_RX_MONO_FDQ_QNUM_MASK) |
+		      ((cfg->cfg.mono_pkt.fd_queue.q_mgr <<
+			DMA_CH_RX_MONO_FDQ_QMGR_SHIFT) &
+		       DMA_CH_RX_MONO_FDQ_QMGR_MASK) |
+		      ((cfg->cfg.mono_pkt.sop_offset <<
+			DMA_CH_RX_MONO_SOP_OFFSET_SHIFT) &
+		       DMA_CH_RX_MONO_SOP_OFFSET_MASK);
+
+		__raw_writel(val, base + DMA_CH_RX_MONO_PKT_CFG_REG(0));
+		DBG("Rx channel monolithic packet configuration @ %p, "
+		    "value written: %x\n",
+		    base + DMA_CH_RX_MONO_PKT_CFG_REG(0), val);
+		break;
+	}
+}
+EXPORT_SYMBOL(cppi41_rx_ch_configure);
+
+/*
+ * cppi41_dma_ch_teardown - teardown a given Tx/Rx channel
+ */
+void cppi41_dma_ch_teardown(struct cppi41_dma_ch_obj *dma_ch_obj)
+{
+	u32 val = __raw_readl(dma_ch_obj->base_addr);
+
+	/* Initiate channel teardown. */
+	val |= dma_ch_obj->global_cfg & ~DMA_CH_TX_ENABLE_MASK;
+	dma_ch_obj->global_cfg = val |= DMA_CH_TX_TEARDOWN_MASK;
+	__raw_writel(val, dma_ch_obj->base_addr);
+	DBG("Tear down channel @ %p, value written: %x, value read: %x\n",
+	    dma_ch_obj->base_addr, val, __raw_readl(dma_ch_obj->base_addr));
+}
+EXPORT_SYMBOL(cppi41_dma_ch_teardown);
+
+/*
+ * cppi41_dma_ch_enable - enable Tx/Rx DMA channel in hardware
+ *
+ * Makes the channel ready for data transmission/reception.
+ */
+void cppi41_dma_ch_enable(struct cppi41_dma_ch_obj *dma_ch_obj)
+{
+	u32 val = dma_ch_obj->global_cfg | DMA_CH_TX_ENABLE_MASK;
+
+	/* Teardown bit remains set after completion, so clear it now... */
+	dma_ch_obj->global_cfg = val &= ~DMA_CH_TX_TEARDOWN_MASK;
+	__raw_writel(val, dma_ch_obj->base_addr);
+	DBG("Enable channel @ %p, value written: %x, value read: %x\n",
+	    dma_ch_obj->base_addr, val, __raw_readl(dma_ch_obj->base_addr));
+}
+EXPORT_SYMBOL(cppi41_dma_ch_enable);
+
+/*
+ * cppi41_dma_ch_disable - disable Tx/Rx DMA channel in hardware
+ */
+void cppi41_dma_ch_disable(struct cppi41_dma_ch_obj *dma_ch_obj)
+{
+	dma_ch_obj->global_cfg &= ~DMA_CH_TX_ENABLE_MASK;
+	__raw_writel(dma_ch_obj->global_cfg, dma_ch_obj->base_addr);
+	DBG("Disable channel @ %p, value written: %x, value read: %x\n",
+	    dma_ch_obj->base_addr, dma_ch_obj->global_cfg,
+	    __raw_readl(dma_ch_obj->base_addr));
+}
+EXPORT_SYMBOL(cppi41_dma_ch_disable);
+
+void cppi41_free_teardown_queue(int dma_num)
+{
+	unsigned long td_addr;
+
+	while ((td_addr =
+		cppi41_queue_pop(&dma_teardown[dma_num].queue_obj)) != 0)
+		DBG("pop tdDesc(%p) from tdQueue\n", td_addr);
+}
+EXPORT_SYMBOL(cppi41_free_teardown_queue);
+
+void cppi41_exit(void)
+{
+	int i;
+	for (i = 0; i < CPPI41_NUM_QUEUE_MGR; i++) {
+		if (linking_ram[i].virt_addr != NULL)
+			dma_free_coherent(NULL, 0x10000,
+				linking_ram[i].virt_addr,
+				linking_ram[i].phys_addr);
+		if (allocated_queues[i] != NULL)
+			kfree(allocated_queues[i]);
+	}
+	for (i = 0; i < CPPI41_NUM_DMA_BLOCK; i++)
+		if (dma_teardown[i].virt_addr != NULL) {
+
+			cppi41_mem_rgn_free(0,  dma_teardown[i].mem_rgn);
+			dma_free_coherent(NULL, dma_teardown[i].rgn_size,
+					dma_teardown[i].virt_addr,
+					dma_teardown[i].phys_addr);
+		}
+}
+EXPORT_SYMBOL(cppi41_exit);
+
+/**
+ * alloc_queue - allocate a queue in the given range
+ * @allocated:	pointer to the bitmap of the allocated queues
+ * @excluded:	pointer to the bitmap of the queues excluded from allocation
+ *		(optional)
+ * @start:	starting queue number
+ * @count:	number of queues available
+ *
+ * Returns queue number on success, -ENOSPC otherwise.
+ */
+static int alloc_queue(u32 *allocated, const u32 *excluded, unsigned start,
+		       unsigned count)
+{
+	u32 bit, mask = 0;
+	int index = -1;
+
+	/*
+	 * We're starting the loop as if we've just wrapped around 32 bits
+	 * in order to save on preloading the bitmasks.
+	 */
+	for (bit = 0; count--; start++, bit <<= 1) {
+		/* Have we just wrapped around 32 bits? */
+		if (!bit) {
+			/* Start over with the next bitmask word */
+			bit = 1;
+			index++;
+			/* Have we just entered the loop? */
+			if (!index) {
+				/* Calculate the starting values */
+				bit <<= start & 0x1f;
+				index = start >> 5;
+			}
+			/*
+			 * Load the next word of the allocated bitmask OR'ing
+			 * it with the excluded bitmask if it's been passed.
+			 */
+			mask = allocated[index];
+			if (excluded != NULL)
+				mask |= excluded[index];
+		}
+		/*
+		 * If the bit in the combined bitmask is zero,
+		 * we've just found a free queue.
+		 */
+		if (!(mask & bit)) {
+			allocated[index] |= bit;
+			return start;
+		}
+	}
+	return -ENOSPC;
+}
+
+/*
+ * cppi41_queue_alloc - allocate a queue of a given type in the queue manager
+ */
+int cppi41_queue_alloc(u8 type, u8 q_mgr, u16 *q_num)
+{
+	int res = -ENOSPC;
+
+	if (q_mgr >= cppi41_num_queue_mgr)
+		return -EINVAL;
+
+	/* Mask out the unsupported queue types */
+	type &= cppi41_queue_mgr[q_mgr].queue_types;
+	/* First see if a free descriptor queue was requested... */
+	if (type & CPPI41_FREE_DESC_QUEUE)
+		res = alloc_queue(allocated_queues[q_mgr], NULL,
+				  cppi41_queue_mgr[q_mgr].base_fdq_num,  16);
+
+	/* Then see if a free descriptor/buffer queue was requested... */
+	if (res < 0 && (type & CPPI41_FREE_DESC_BUF_QUEUE))
+		res = alloc_queue(allocated_queues[q_mgr], NULL,
+				  cppi41_queue_mgr[q_mgr].base_fdbq_num, 16);
+
+	/* Last see if an unassigned queue was requested... */
+	if (res < 0 && (type & CPPI41_UNASSIGNED_QUEUE))
+		res = alloc_queue(allocated_queues[q_mgr],
+				  cppi41_queue_mgr[q_mgr].assigned, 0,
+				  cppi41_queue_mgr[q_mgr].num_queue);
+
+	/* See if any queue was allocated... */
+	if (res < 0)
+		return res;
+
+	/* Return the queue allocated */
+	*q_num = res;
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_queue_alloc);
+
+/*
+ * cppi41_queue_free - free the given queue in the queue manager
+ */
+int cppi41_queue_free(u8 q_mgr, u16 q_num)
+{
+	int index = q_num >> 5, bit = 1 << (q_num & 0x1f);
+
+	if (q_mgr >= cppi41_num_queue_mgr ||
+	    q_num >= cppi41_queue_mgr[q_mgr].num_queue ||
+	    !(allocated_queues[q_mgr][index] & bit))
+		return -EINVAL;
+
+	allocated_queues[q_mgr][index] &= ~bit;
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_queue_free);
+
+/*
+ * cppi41_queue_init - initialize a CPPI 4.1 queue object
+ */
+int cppi41_queue_init(struct cppi41_queue_obj *queue_obj, u8 q_mgr, u16 q_num)
+{
+	if (q_mgr >= cppi41_num_queue_mgr ||
+	    q_num >= cppi41_queue_mgr[q_mgr].num_queue)
+		return -EINVAL;
+
+	queue_obj->base_addr = cppi41_queue_mgr[q_mgr].q_mgmt_rgn_base +
+			       QMGR_QUEUE_STATUS_REG_A(q_num);
+
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_queue_init);
+
+/*
+ * cppi41_queue_push - push a descriptor into the given queue
+ */
+void cppi41_queue_push(const struct cppi41_queue_obj *queue_obj, u32 desc_addr,
+		       u32 desc_size, u32 pkt_size)
+{
+	u32 val;
+
+	/*
+	 * Write to the tail of the queue.
+	 * TODO: Can't think of a reason why a queue to head may be required.
+	 * If it is, the API may have to be extended.
+	 */
+#if 0
+	/*
+	 * Also, can't understand why packet size is required to queue up a
+	 * descriptor. The spec says packet size *must* be written prior to
+	 * the packet write operation.
+	 */
+	if (pkt_size)
+		val = (pkt_size << QMGR_QUEUE_PKT_SIZE_SHIFT) &
+		      QMGR_QUEUE_PKT_SIZE_MASK;
+	__raw_writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_C(0));
+#endif
+
+	val = (((desc_size - 24) >> (2 - QMGR_QUEUE_DESC_SIZE_SHIFT)) &
+	       QMGR_QUEUE_DESC_SIZE_MASK) |
+	      (desc_addr & QMGR_QUEUE_DESC_PTR_MASK);
+
+	DBG("Pushing value %x to queue @ %p\n", val, queue_obj->base_addr);
+
+	__raw_writel(val, queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
+}
+EXPORT_SYMBOL(cppi41_queue_push);
+
+/*
+ * cppi41_queue_pop - pop a descriptor from a given queue
+ */
+unsigned long cppi41_queue_pop(const struct cppi41_queue_obj *queue_obj)
+{
+	u32 val = __raw_readl(queue_obj->base_addr + QMGR_QUEUE_REG_D(0));
+
+	DBG("Popping value %x from queue @ %p\n", val, queue_obj->base_addr);
+
+	return val & QMGR_QUEUE_DESC_PTR_MASK;
+}
+EXPORT_SYMBOL(cppi41_queue_pop);
+
+/*
+ * cppi41_get_teardown_info - extract information from a teardown descriptor
+ */
+int cppi41_get_teardown_info(unsigned long addr, u32 *info)
+{
+	struct cppi41_teardown_desc *desc;
+	int dma_num;
+
+	for (dma_num = 0; dma_num < cppi41_num_dma_block; dma_num++)
+		if (addr >= dma_teardown[dma_num].phys_addr &&
+		    addr <  dma_teardown[dma_num].phys_addr +
+			    dma_teardown[dma_num].rgn_size)
+			break;
+
+	if (dma_num == cppi41_num_dma_block)
+		return -EINVAL;
+
+	desc = addr - dma_teardown[dma_num].phys_addr +
+	       dma_teardown[dma_num].virt_addr;
+
+	if ((desc->teardown_info & CPPI41_DESC_TYPE_MASK) !=
+	    (CPPI41_DESC_TYPE_TEARDOWN << CPPI41_DESC_TYPE_SHIFT))
+		return -EINVAL;
+
+	*info = desc->teardown_info;
+#if 1
+	/* Hardware is not giving the current DMA number as of now. :-/ */
+	*info |= (dma_num << CPPI41_TEARDOWN_DMA_NUM_SHIFT) &
+		 CPPI41_TEARDOWN_DMA_NUM_MASK;
+#else
+	dma_num = (desc->teardown_info & CPPI41_TEARDOWN_DMA_NUM_MASK) >>
+		 CPPI41_TEARDOWN_DMA_NUM_SHIFT;
+#endif
+
+	cppi41_queue_push(&dma_teardown[dma_num].queue_obj, addr,
+			  sizeof(struct cppi41_teardown_desc), 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_get_teardown_info);
+
+MODULE_DESCRIPTION("TI CPPI 4.1 support");
+MODULE_AUTHOR("MontaVista Software");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/musb/cppi41.h b/drivers/usb/musb/cppi41.h
new file mode 100644
index 0000000..6ca4978
--- /dev/null
+++ b/drivers/usb/musb/cppi41.h
@@ -0,0 +1,788 @@
+/*
+ * CPPI 4.1 definitions
+ *
+ * Copyright (c) 2008-2009, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/types.h>
+
+/*
+ * Queue Manager - Control Registers Region
+ */
+#define QMGR_REVISION_REG		0x00	/* Major and minor versions */
+						/* of the module */
+#define QMGR_QUEUE_DIVERSION_REG	0x08	/* Queue Diversion register */
+#define QMGR_FREE_DESC_BUF_STARVED_REG(n) (0x20 + ((n) << 2)) /* Free Desc./ */
+						/* Buffer Starvation Count */
+#define QMGR_FREE_DESC_STARVED_REG(n)	(0x30 + ((n) << 2)) /* Free Desc. */
+						/* Starvation Count */
+#define QMGR_LINKING_RAM_RGN0_BASE_REG	0x80	/* Linking RAM Region 0 Base */
+						/* Address */
+#define QMGR_LINKING_RAM_RGN0_SIZE_REG	0x84	/* Linking RAM Region 0 Size */
+#define QMGR_LINKING_RAM_RGN1_BASE_REG	0x88	/* Linking RAM Region 1 Base */
+						/* Address */
+#define QMGR_QUEUE_PENDING_REG(n)	(0x90 + ((n) << 2)) /* Pending status */
+						/* for all queues */
+
+/*
+ * Queue Manager - Memory Region Registers
+ */
+#define QMGR_MEM_RGN_BASE_REG(r)	(0x00 + ((r) << 4))
+#define QMGR_MEM_RGN_CTRL_REG(r)	(0x04 + ((r) << 4))
+
+/* Memory Region R Control Register bits */
+#define QMGR_MEM_RGN_INDEX_SHIFT	16
+#define QMGR_MEM_RGN_INDEX_MASK	(0x3fff << QMGR_MEM_RGN_INDEX_SHIFT)
+#define QMGR_MEM_RGN_DESC_SIZE_SHIFT	8
+#define QMGR_MEM_RGN_DESC_SIZE_MASK	(0xf << QMGR_MEM_RGN_DESC_SIZE_SHIFT)
+#define QMGR_MEM_RGN_SIZE_SHIFT	0
+#define QMGR_MEM_RGN_SIZE_MASK		(7 << QMGR_MEM_RGN_SIZE_SHIFT)
+
+/*
+ * Queue Manager - Queues Region
+ */
+#define QMGR_QUEUE_REG_A(n)		(0x00 + ((n) << 4))
+#define QMGR_QUEUE_REG_B(n)		(0x04 + ((n) << 4))
+#define QMGR_QUEUE_REG_C(n)		(0x08 + ((n) << 4))
+#define QMGR_QUEUE_REG_D(n)		(0x0C + ((n) << 4))
+
+/* Queue N Register C bits */
+#define QMGR_QUEUE_HEAD_TAIL_SHIFT	31
+#define QMGR_QUEUE_HEAD_TAIL_MASK	(1 << QMGR_QUEUE_HEAD_TAIL_SHIFT)
+#define QMGR_QUEUE_PKT_SIZE_SHIFT	0
+#define QMGR_QUEUE_PKT_SIZE_MASK	(0x3fff << QMGR_QUEUE_PKT_SIZE_SHIFT)
+/* Queue N Register D bits */
+#define QMGR_QUEUE_DESC_PTR_SHIFT	5
+#define QMGR_QUEUE_DESC_PTR_MASK	(0x7ffffff << QMGR_QUEUE_DESC_PTR_SHIFT)
+#define QMGR_QUEUE_DESC_SIZE_SHIFT	0
+#define QMGR_QUEUE_DESC_SIZE_MASK	(0x1f << QMGR_QUEUE_DESC_SIZE_SHIFT)
+
+/*
+ * Queue Manager - Queue Status Region
+ */
+#define QMGR_QUEUE_STATUS_REG_A(n)	(0x00 + ((n) << 4))
+#define QMGR_QUEUE_STATUS_REG_B(n)	(0x04 + ((n) << 4))
+#define QMGR_QUEUE_STATUS_REG_C(n)	(0x08 + ((n) << 4))
+
+/*
+ * DMA Controller - Global Control Registers Region
+ */
+#define DMA_REVISION_REG		0x00	/* Major and minor versions */
+						/* of the module */
+#define DMA_TEARDOWN_FREE_DESC_CTRL_REG 0x04	/* Queue  manager and queue */
+						/* number for Teardown free */
+						/* descriptor queue */
+#define DMA_EMULATION_CTRL_REG		0x08	/* Emulation control register */
+
+/* Teardown Free Descriptor Queue Control Register bits */
+#define DMA_TD_DESC_QMGR_SHIFT		12
+#define DMA_TD_DESC_QMGR_MASK		(3 << DMA_TD_DESC_QMGR_SHIFT)
+#define DMA_TD_DESC_QNUM_SHIFT		0
+#define DMA_TD_DESC_QNUM_MASK		(0xfff << DMA_TD_DESC_QNUM_SHIFT)
+
+/*
+ * DMA Controller - Channel Control / Status Registers Region
+ */
+#define DMA_CH_TX_GLOBAL_CFG_REG(n)	 (0x00 + ((n) << 5))
+#define DMA_CH_RX_GLOBAL_CFG_REG(n)	 (0x08 + ((n) << 5))
+#define DMA_CH_RX_HOST_PKT_CFG_REG_A(n)  (0x0C + ((n) << 5))
+#define DMA_CH_RX_HOST_PKT_CFG_REG_B(n)  (0x10 + ((n) << 5))
+#define DMA_CH_RX_EMBED_PKT_CFG_REG_A(n) (0x14 + ((n) << 5))
+#define DMA_CH_RX_EMBED_PKT_CFG_REG_B(n) (0x18 + ((n) << 5))
+#define DMA_CH_RX_MONO_PKT_CFG_REG(n)	 (0x1C + ((n) << 5))
+
+/* Tx Channel N Global Configuration Register bits */
+#define DMA_CH_TX_ENABLE_SHIFT		31
+#define DMA_CH_TX_ENABLE_MASK		(1 << DMA_CH_TX_ENABLE_SHIFT)
+#define DMA_CH_TX_TEARDOWN_SHIFT	30
+#define DMA_CH_TX_TEARDOWN_MASK		(1 << DMA_CH_TX_TEARDOWN_SHIFT)
+#define DMA_CH_TX_DEFAULT_QMGR_SHIFT	12
+#define DMA_CH_TX_DEFAULT_QMGR_MASK	(3 << DMA_CH_TX_DEFAULT_QMGR_SHIFT)
+#define DMA_CH_TX_DEFAULT_QNUM_SHIFT	0
+#define DMA_CH_TX_DEFAULT_QNUM_MASK	(0xfff << DMA_CH_TX_DEFAULT_QNUM_SHIFT)
+
+/* Rx Channel N Global Configuration Register bits */
+#define DMA_CH_RX_ENABLE_SHIFT		31
+#define DMA_CH_RX_ENABLE_MASK		(1 << DMA_CH_RX_ENABLE_SHIFT)
+#define DMA_CH_RX_TEARDOWN_SHIFT	30
+#define DMA_CH_RX_TEARDOWN_MASK		(1 << DMA_CH_RX_TEARDOWN_SHIFT)
+#define DMA_CH_RX_ERROR_HANDLING_SHIFT	24
+#define DMA_CH_RX_ERROR_HANDLING_MASK	(1 << DMA_CH_RX_ERROR_HANDLING_SHIFT)
+#define DMA_CH_RX_SOP_OFFSET_SHIFT	16
+#define DMA_CH_RX_SOP_OFFSET_MASK	(0xff << DMA_CH_RX_SOP_OFFSET_SHIFT)
+#define DMA_CH_RX_DEFAULT_DESC_TYPE_SHIFT 14
+#define DMA_CH_RX_DEFAULT_DESC_TYPE_MASK  (3 << \
+					   DMA_CH_RX_DEFAULT_DESC_TYPE_SHIFT)
+#define DMA_CH_RX_DEFAULT_DESC_EMBED	0
+#define DMA_CH_RX_DEFAULT_DESC_HOST	1
+#define DMA_CH_RX_DEFAULT_DESC_MONO	2
+#define DMA_CH_RX_DEFAULT_RQ_QMGR_SHIFT 12
+#define DMA_CH_RX_DEFAULT_RQ_QMGR_MASK	(3 << DMA_CH_RX_DEFAULT_RQ_QMGR_SHIFT)
+#define DMA_CH_RX_DEFAULT_RQ_QNUM_SHIFT 0
+#define DMA_CH_RX_DEFAULT_RQ_QNUM_MASK	(0xfff << \
+					 DMA_CH_RX_DEFAULT_RQ_QNUM_SHIFT)
+
+/* Rx Channel N Host Packet Configuration Register A/B bits */
+#define DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(n) (12 + 16 * ((n) & 1))
+#define DMA_CH_RX_HOST_FDQ_QMGR_MASK(n)  (3 << DMA_CH_RX_HOST_FDQ_QMGR_SHIFT(n))
+#define DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(n) (0 + 16 * ((n) & 1))
+#define DMA_CH_RX_HOST_FDQ_QNUM_MASK(n)  (0xfff << \
+					  DMA_CH_RX_HOST_FDQ_QNUM_SHIFT(n))
+
+/* Rx Channel N Embedded Packet Configuration Register A bits */
+#define DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(n) (6 + 8 * (n))
+#define DMA_CH_RX_EMBED_FBP_BMGR_MASK(n)  (3 << \
+					   DMA_CH_RX_EMBED_FBP_BMGR_SHIFT(n))
+#define DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(n) (0 + 8 * (n))
+#define DMA_CH_RX_EMBED_FBP_PNUM_MASK(n)  (0x1f << \
+					   DMA_CH_RX_EMBED_FBP_PNUM_SHIFT(n))
+
+/* Rx Channel N Embedded Packet Configuration Register B bits */
+#define DMA_CH_RX_EMBED_NUM_SLOT_SHIFT	24
+#define DMA_CH_RX_EMBED_NUM_SLOT_MASK	(7 << DMA_CH_RX_EMBED_NUM_SLOT_SHIFT)
+#define DMA_CH_RX_EMBED_SOP_SLOT_SHIFT	16
+#define DMA_CH_RX_EMBED_SOP_SLOT_MASK	(7 << DMA_CH_RX_EMBED_SOP_SLOT_SHIFT)
+#define DMA_CH_RX_EMBED_FDQ_QMGR_SHIFT	12
+#define DMA_CH_RX_EMBED_FDQ_QMGR_MASK	(3 << DMA_CH_RX_EMBED_FDQ_QMGR_SHIFT)
+#define DMA_CH_RX_EMBED_FDQ_QNUM_SHIFT	0
+#define DMA_CH_RX_EMBED_FDQ_QNUM_MASK	(0xfff << \
+					 DMA_CH_RX_EMBED_FDQ_QNUM_SHIFT)
+
+/* Rx Channel N Monolithic Packet Configuration Register bits */
+#define DMA_CH_RX_MONO_SOP_OFFSET_SHIFT 16
+#define DMA_CH_RX_MONO_SOP_OFFSET_MASK	(0xff << \
+					 DMA_CH_RX_MONO_SOP_OFFSET_SHIFT)
+#define DMA_CH_RX_MONO_FDQ_QMGR_SHIFT	12
+#define DMA_CH_RX_MONO_FDQ_QMGR_MASK	(3 << DMA_CH_RX_MONO_FDQ_QMGR_SHIFT)
+#define DMA_CH_RX_MONO_FDQ_QNUM_SHIFT	0
+#define DMA_CH_RX_MONO_FDQ_QNUM_MASK	(0xfff << DMA_CH_RX_MONO_FDQ_QNUM_SHIFT)
+
+/*
+ * DMA Scheduler - Control Region
+ */
+#define DMA_SCHED_CTRL_REG		0x00
+
+/*
+ * CPPI 4.1 configuration data
+ */
+#define USB_CPPI41_QMGR_REG0_MAX_SIZE           0x10000
+#define USB_CPPI41_QMGR_REG0_ALLOC_SIZE         0x3fff
+
+/* DMA Scheduler Control Register bits */
+#define DMA_SCHED_ENABLE_SHIFT		31
+#define DMA_SCHED_ENABLE_MASK		(1 << DMA_SCHED_ENABLE_SHIFT)
+#define DMA_SCHED_LAST_ENTRY_SHIFT	0
+#define DMA_SCHED_LAST_ENTRY_MASK	(0xff << DMA_SCHED_LAST_ENTRY_SHIFT)
+
+/*
+ * DMA Scheduler - Table Region
+ */
+#define DMA_SCHED_TABLE_WORD_REG(n)	((n) << 2)
+
+/*
+ * CPPI 4.1 Host Packet Descriptor
+ */
+struct cppi41_host_pkt_desc {
+	u32 desc_info;		/* Descriptor type, protocol specific word */
+				/* count, packet length */
+	u32 tag_info;		/* Source tag (31:16), destination tag (15:0) */
+	u32 pkt_info;		/* Packet error state, type, protocol flags, */
+				/* return info, descriptor location */
+	u32 buf_len;		/* Number of valid data bytes in the buffer */
+	u32 buf_ptr;		/* Pointer to the buffer associated with */
+				/* this descriptor */
+	u32 next_desc_ptr;	/* Pointer to the next buffer descriptor */
+	u32 orig_buf_len;	/* Original buffer length */
+	u32 orig_buf_ptr;	/* Original buffer pointer */
+	u32 stk_comms_info[2];	/* Network stack private communications info */
+};
+
+/*
+ * CPPI 4.1 Host Buffer Descriptor
+ */
+struct cppi41_host_buf_desc {
+	u32 reserved[2];
+	u32 buf_recl_info;	/* Return info, descriptor location */
+	u32 buf_len;		/* Number of valid data bytes in the buffer */
+	u32 buf_ptr;		/* Pointer to the buffer associated with */
+				/* this descriptor */
+	u32 next_desc_ptr;	/* Pointer to the next buffer descriptor */
+	u32 orig_buf_len;	/* Original buffer length */
+	u32 orig_buf_ptr;	/* Original buffer pointer */
+};
+
+#define CPPI41_DESC_TYPE_SHIFT		27
+#define CPPI41_DESC_TYPE_MASK		(0x1f << CPPI41_DESC_TYPE_SHIFT)
+#define CPPI41_DESC_TYPE_HOST		16
+#define CPPI41_DESC_TYPE_MONOLITHIC	18
+#define CPPI41_DESC_TYPE_TEARDOWN	19
+#define CPPI41_PROT_VALID_WORD_CNT_SHIFT 22
+#define CPPI41_PROT_VALID_WORD_CNT_MASK	(0x1f << CPPI41_PROT_WORD_CNT_SHIFT)
+#define CPPI41_PKT_LEN_SHIFT		0
+#define CPPI41_PKT_LEN_MASK		(0x1fffff << CPPI41_PKT_LEN_SHIFT)
+
+#define CPPI41_PKT_ERROR_SHIFT		31
+#define CPPI41_PKT_ERROR_MASK		(1 << CPPI41_PKT_ERROR_SHIFT)
+#define CPPI41_PKT_TYPE_SHIFT		26
+#define CPPI41_PKT_TYPE_MASK		(0x1f << CPPI41_PKT_TYPE_SHIFT)
+#define CPPI41_PKT_TYPE_ATM_AAL5	0
+#define CPPI41_PKT_TYPE_ATM_NULL_AAL	1
+#define CPPI41_PKT_TYPE_ATM_OAM		2
+#define CPPI41_PKT_TYPE_ATM_TRANSPARENT	3
+#define CPPI41_PKT_TYPE_EFM		4
+#define CPPI41_PKT_TYPE_USB		5
+#define CPPI41_PKT_TYPE_GENERIC	6
+#define CPPI41_PKT_TYPE_ETHERNET	7
+#define CPPI41_RETURN_POLICY_SHIFT	15
+#define CPPI41_RETURN_POLICY_MASK	(1 << CPPI41_RETURN_POLICY_SHIFT)
+#define CPPI41_RETURN_LINKED		0
+#define CPPI41_RETURN_UNLINKED		1
+#define CPPI41_ONCHIP_SHIFT		14
+#define CPPI41_ONCHIP_MASK		(1 << CPPI41_ONCHIP_SHIFT)
+#define CPPI41_RETURN_QMGR_SHIFT	12
+#define CPPI41_RETURN_QMGR_MASK	(3 << CPPI41_RETURN_QMGR_SHIFT)
+#define CPPI41_RETURN_QNUM_SHIFT	0
+#define CPPI41_RETURN_QNUM_MASK	(0xfff << CPPI41_RETURN_QNUM_SHIFT)
+
+#define CPPI41_SRC_TAG_PORT_NUM_SHIFT	27
+#define CPPI41_SRC_TAG_PORT_NUM_MASK	(0x1f << CPPI41_SRC_TAG_PORT_NUM_SHIFT)
+#define CPPI41_SRC_TAG_CH_NUM_SHIFT	21
+#define CPPI41_SRC_TAG_CH_NUM_MASK	(0x3f << CPPI41_SRC_TAG_CH_NUM_SHIFT)
+#define CPPI41_SRC_TAG_SUB_CH_NUM_SHIFT 16
+#define CPPI41_SRC_TAG_SUB_CH_NUM_MASK	(0x1f << \
+					CPPI41_SRC_TAG_SUB_CH_NUM_SHIFT)
+#define CPPI41_DEST_TAG_SHIFT		0
+#define CPPI41_DEST_TAG_MASK		(0xffff << CPPI41_DEST_TAG_SHIFT)
+
+/*
+ * CPPI 4.1 Teardown Descriptor
+ */
+struct cppi41_teardown_desc {
+	u32 teardown_info;	/* Teardown information */
+	u32 reserved[7];	/* 28 byte padding */
+};
+
+#define CPPI41_TEARDOWN_TX_RX_SHIFT	16
+#define CPPI41_TEARDOWN_TX_RX_MASK	(1 << CPPI41_TEARDOWN_TX_RX_SHIFT)
+#define CPPI41_TEARDOWN_DMA_NUM_SHIFT	10
+#define CPPI41_TEARDOWN_DMA_NUM_MASK	(0x3f << CPPI41_TEARDOWN_DMA_NUM_SHIFT)
+#define CPPI41_TEARDOWN_CHAN_NUM_SHIFT	0
+#define CPPI41_TEARDOWN_CHAN_NUM_MASK	(0x3f << CPPI41_TEARDOWN_CHAN_NUM_SHIFT)
+
+#define CPPI41_MAX_MEM_RGN		16
+
+#if 0
+/* CPPI 4.1 configuration for AM3517 */
+#define CPPI41_NUM_QUEUE_MGR		1	/* 4  max */
+#define CPPI41_NUM_DMA_BLOCK		1	/* 64 max */
+#define cppi41_num_queue_mgr	CPPI41_NUM_QUEUE_MGR
+#define cppi41_num_dma_block	CPPI41_NUM_DMA_BLOCK
+#endif
+/* CPPI 4.1 configuration for DA8xx */
+#define CPPI41_NUM_QUEUE_MGR            1       /* 4  max */
+#define CPPI41_NUM_DMA_BLOCK            1       /* 64 max */
+#define CPPI41_DMACH_TX_DIR             1
+#define CPPI41_DMACH_RX_DIR             0
+#define cppi41_num_queue_mgr	CPPI41_NUM_QUEUE_MGR
+#define cppi41_num_dma_block	CPPI41_NUM_DMA_BLOCK
+
+/**
+ * struct cppi41_queue - Queue Tuple
+ *
+ * The basic queue tuple in CPPI 4.1 used across all data structures
+ * where a definition of a queue is required.
+ */
+struct cppi41_queue {
+	u8  q_mgr;		/* The queue manager number */
+	u16 q_num;		/* The queue number */
+};
+
+/**
+ * struct cppi41_buf_pool - Buffer Pool Tuple
+ *
+ * The basic buffer pool tuple in CPPI 4.1 used across all data structures
+ * where a definition of a buffer pool is required.
+ */
+struct cppi41_buf_pool {
+	u8  b_mgr;		/* The buffer manager number */
+	u16 b_pool;		/* The buffer pool number */
+};
+
+/**
+ * struct cppi41_queue_mgr - Queue Manager information
+ *
+ * Contains the information about the queue manager which should be copied from
+ * the hardware spec as is.
+ */
+struct cppi41_queue_mgr {
+	void __iomem *q_mgr_rgn_base; /* Base address of the Control region. */
+	void __iomem *desc_mem_rgn_base; /* Base address of the descriptor */
+				/* memory region. */
+	void __iomem *q_mgmt_rgn_base; /* Base address of the queues region. */
+	void __iomem *q_stat_rgn_base; /* Base address of the queue status */
+				/* region. */
+	u16 num_queue;		/* Number of the queues supported. */
+	u8  queue_types;	/* Bitmask of the supported queue types. */
+	u16 base_fdq_num;	/* The base free descriptor queue number. */
+				/* If present, there's always 16 such queues. */
+	u16 base_fdbq_num;	/* The base free descriptor/buffer queue */
+				/* number.  If present, there's always 16 */
+				/* such queues. */
+	const u32 *assigned;	/* Pointer to the bitmask of the pre-assigned */
+				/* queues. */
+	void  *ptr_rgn0;        /* Pointer to region 0 memory */
+	dma_addr_t phys_ptr_rgn0; /* Phs pointer to region0 memory */
+};
+
+/* Queue type flags */
+#define CPPI41_FREE_DESC_QUEUE		0x01
+#define CPPI41_FREE_DESC_BUF_QUEUE	0x02
+#define CPPI41_UNASSIGNED_QUEUE	0x04
+
+/**
+ * struct cppi41_embed_pkt_cfg - Rx Channel Embedded packet configuration
+ *
+ * An instance of this structure forms part of the Rx channel information
+ * structure.
+ */
+struct cppi41_embed_pkt_cfg {
+	struct cppi41_queue fd_queue; /* Free Descriptor queue.*/
+	u8 num_buf_slot;	/* Number of buffer slots in the descriptor */
+	u8 sop_slot_num;	/* SOP buffer slot number. */
+	struct cppi41_buf_pool free_buf_pool[4]; /* Free Buffer pool. Element */
+				/* 0 used for the 1st Rx buffer, etc. */
+};
+
+/**
+ * struct cppi41_host_pkt_cfg - Rx Channel Host Packet Configuration
+ *
+ * An instance of this structure forms part of the Rx channel information
+ * structure.
+ */
+struct cppi41_host_pkt_cfg {
+	struct cppi41_queue fdb_queue[4]; /* Free Desc/Buffer queue. Element */
+				/* 0 used for 1st Rx buffer, etc. */
+};
+
+/**
+ * struct cppi41_mono_pkt_cfg - Rx Channel Monolithic Packet Configuration
+ *
+ * An instance of this structure forms part of the Rx channel information
+ * structure.
+ */
+struct cppi41_mono_pkt_cfg {
+	struct cppi41_queue fd_queue; /* Free descriptor queue */
+	u8 sop_offset;		/* Number of bytes to skip before writing */
+				/* payload */
+};
+
+enum cppi41_rx_desc_type {
+	cppi41_rx_embed_desc,
+	cppi41_rx_host_desc,
+	cppi41_rx_mono_desc,
+};
+
+/**
+ * struct cppi41_rx_ch_cfg - Rx Channel Configuration
+ *
+ * Must be allocated and filled by the caller of cppi41_rx_ch_configure().
+ *
+ * The same channel can be configured to receive different descripor type
+ * packets (not simaltaneously). When the Rx packets on a port need to be sent
+ * to the SR, the channels default descriptor type is set to Embedded and the
+ * Rx completion queue is set to the queue which CPU polls for input packets.
+ * When in SR bypass mode, the same channel's default descriptor type will be
+ * set to Host and the Rx completion queue set to one of the queues which host
+ * can get interrupted on (via the Queuing proxy/accumulator). In this example,
+ * the embedded mode configuration fetches free descriptor from the Free
+ * descriptor queue (as defined by struct cppi41_embed_pkt_cfg) and host
+ * mode configuration fetches free descriptors/buffers from the free descriptor/
+ * buffer queue (as defined by struct cppi41_host_pkt_cfg).
+ *
+ * NOTE: There seems to be no separate configuration for teardown completion
+ * descriptor. The assumption is rxQueue tuple is used for this purpose as well.
+ */
+struct cppi41_rx_ch_cfg {
+	enum cppi41_rx_desc_type default_desc_type; /* Describes which queue */
+				/* configuration is used for the free */
+				/* descriptors and/or buffers */
+	u8 sop_offset;		/* Number of bytes to skip in SOP buffer */
+				/* before writing payload */
+	u8 retry_starved;	/* 0 = Drop packet on descriptor/buffer */
+				/* starvartion, 1 = DMA retries FIFO block */
+				/* transfer at a later time */
+	struct cppi41_queue rx_queue; /* Rx complete packets queue */
+	union {
+		struct cppi41_host_pkt_cfg host_pkt; /* Host packet */
+				/* configuration. This defines where channel */
+				/* picks free descriptors from. */
+		struct cppi41_embed_pkt_cfg embed_pkt; /* Embedded packet */
+				/* configuration. This defines where channel */
+				/* picks free descriptors/buffers from. */
+				/* from. */
+		struct cppi41_mono_pkt_cfg mono_pkt; /* Monolithic packet */
+				/* configuration. This defines where channel */
+				/* picks free descriptors from. */
+	} cfg;			/* Union of packet configuration structures */
+				/* to be filled in depending on the */
+				/* defDescType field. */
+};
+
+/**
+ * struct cppi41_tx_ch - Tx channel information
+ *
+ * NOTE: The queues that feed into the Tx channel are fixed at SoC design time.
+ */
+struct cppi41_tx_ch {
+	u8 port_num;		/* Port number. */
+	u8 ch_num;		/* Channel number within port. */
+	u8 sub_ch_num;		/* Sub-channel number within channel. */
+	u8 num_tx_queue;	/* Number of queues from which the channel */
+				/* can feed. */
+	struct cppi41_queue tx_queue[4]; /* List of queues from which the */
+				/* channel can feed. */
+};
+
+/**
+ * struct cppi41_dma_block - CPPI 4.1 DMA configuration
+ *
+ * Configuration information for CPPI DMA functionality. Includes the Global
+ * configuration, Channel configuration, and the Scheduler configuration.
+ */
+struct cppi41_dma_block {
+	void __iomem *global_ctrl_base; /* Base address of the Global Control */
+				/* registers. */
+	void __iomem *ch_ctrl_stat_base; /* Base address of the Channel */
+				/* Control/Status registers. */
+	void __iomem *sched_ctrl_base; /* Base address of the Scheduler */
+				/* Control register. */
+	void __iomem *sched_table_base; /* Base address of the Scheduler */
+				/* Table registers. */
+	u8 num_tx_ch;		/* Number of the Tx channels. */
+	u8 num_rx_ch;		/* Number of the Rx channels. */
+	const struct cppi41_tx_ch *tx_ch_info;
+};
+
+extern struct cppi41_queue_mgr cppi41_queue_mgr[];
+extern struct cppi41_dma_block cppi41_dma_block[];
+
+/**
+ * struct cppi41_dma_ch_obj - CPPI 4.1 DMA Channel object
+ */
+struct cppi41_dma_ch_obj {
+	void __iomem *base_addr; /* The address of the channel global */
+				/* configuration register */
+	u32 global_cfg;		/* Tx/Rx global configuration backed-up value */
+};
+
+/**
+ * struct cppi41_queue_obj - CPPI 4.1 queue object
+ */
+struct cppi41_queue_obj {
+	void __iomem *base_addr; /* The base address of the queue management */
+				/* registers */
+};
+
+/**
+ * cppi41_queue_mgr_init - CPPI 4.1 queue manager initialization.
+ * @q_mgr:	the queue manager to initialize
+ * @rgn0_base:	linking RAM region 0 physical address
+ * @rgn0_size:	linking RAM region 0 size in 32-bit words (0 to 0x3fff)
+ *
+ * Returns 0 on success, error otherwise.
+ */
+int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size);
+
+void cppi41_queue_mgr_deinit(u8 q_mgr);
+/*
+ * CPPI 4.1 Queue Manager Memory Region Allocation and De-allocation APIs.
+ */
+
+/**
+ * cppi41_mem_rgn_alloc - CPPI 4.1 queue manager memory region allocation.
+ * @q_mgr:	the queue manager whose memory region to allocate
+ * @rgn_addr:	physical address of the memory region
+ * @size_order:	descriptor size as a power of two (between 5 and 13)
+ * @num_order:	number of descriptors as a power of two (between 5 and 12)
+ * @mem_rgn:	pointer to the index of the memory region allocated
+ *
+ * This function allocates a memory region within the queue manager
+ * consisiting of the descriptors of paricular size and number.
+ *
+ * Returns 0 on success, error otherwise.
+ */
+int cppi41_mem_rgn_alloc(u8 q_mgr, dma_addr_t rgn_addr, u8 size_order,
+			 u8 num_order, u8 *mem_rgn);
+
+/**
+ * cppi41_mem_rgn_free - CPPI 4.1 queue manager memory region de-allocation.
+ * @q_mgr:	the queue manager whose memory region was allocated
+ * @mem_rgn:	index of the memory region
+ *
+ * This function frees the memory region allocated by cppi41_mem_rgn_alloc().
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ */
+int cppi41_mem_rgn_free(u8 q_mgr, u8 mem_rgn);
+
+/**
+ * cppi41_dma_block_init - CPPI 4.1 DMA block initialization.
+ * @dma_num:	number of the DMA block
+ * @q_mgr:	the queue manager in which to allocate the free teardown
+ *		descriptor queue
+ * @num_order:	number of teardown descriptors as a power of two (at least 5)
+ * @sched_tbl:	the DMA scheduler table
+ * @tbl_size:	number of entries in the DMA scheduler table
+ *
+ * This function frees the memory region allocated by cppi41_mem_rgn_alloc().
+ *
+ * Returns 0 on success, error otherwise.
+ */
+int cppi41_dma_block_init(u8 dma_num, u8 q_mgr, u8 num_order,
+				 u32 *sched_tbl, u8 tbl_size);
+
+/**
+ * cppi41_dma_block_deinit - CPPI 4.1 DMA block de-initialization.
+ * @dma_num:    number of the DMA block
+ * @q_mgr:      the queue manager in which to allocate the free teardown
+ *              descriptor queue
+ *
+ * Returns none.
+ */
+void cppi41_dma_block_deinit(u8 dma_num, u8 q_mgr);
+
+/*
+ * CPPI 4.1 DMA Channel Management APIs
+ */
+
+/**
+ * cppi41_tx_ch_init - initialize CPPI 4.1 transmit channel object
+ * @tx_ch_obj:	pointer to Tx channel object
+ * @dma_num:	DMA block to which this channel belongs
+ * @ch_num:	DMA channel number
+ *
+ * Returns 0 if valid Tx channel, -EINVAL otherwise.
+ */
+int cppi41_tx_ch_init(struct cppi41_dma_ch_obj *tx_ch_obj,
+		      u8 dma_num, u8 ch_num);
+
+/**
+ * cppi41_rx_ch_init - initialize CPPI 4.1 receive channel object
+ * @rx_ch_obj:	pointer to Rx channel object
+ * @dma_num:	DMA block to which this channel belongs
+ * @ch_num:	DMA channel number
+ *
+ * Returns 0 if valid Rx channel, -EINVAL otherwise.
+ */
+int cppi41_rx_ch_init(struct cppi41_dma_ch_obj *rx_ch_obj,
+		      u8 dma_num, u8 ch_num);
+
+/**
+ * cppi41_dma_ch_default_queue - set CPPI 4.1 channel default completion queue
+ * @dma_ch_obj: pointer to DMA channel object
+ * @q_mgr:	default queue manager
+ * @q_num:	default queue number
+ *
+ * This function configures the specified channel.  The caller is required to
+ * provide the default queue onto which the teardown descriptors will be queued.
+ */
+void cppi41_dma_ch_default_queue(struct cppi41_dma_ch_obj *dma_ch_obj,
+				 u8 q_mgr, u16 q_num);
+
+/**
+ * cppi41_rx_ch_configure - configure CPPI 4.1 receive channel
+ * @rx_ch_obj:	pointer to Rx channel object
+ * @cfg:	pointer to Rx channel configuration
+ *
+ * This function configures and opens the specified Rx channel.  The caller
+ * is required to provide channel configuration information by initializing
+ * a struct cppi41_rx_ch_cfg.
+ */
+void cppi41_rx_ch_configure(struct cppi41_dma_ch_obj *rx_ch_obj,
+			    struct cppi41_rx_ch_cfg  *cfg);
+
+/**
+ * cppi41_dma_ch_enable - enable CPPI 4.1 Tx/Rx DMA channel
+ * @dma_ch_obj:	pointer to DMA channel object
+ *
+ * This function enables  a specified Tx channel.  The caller is required to
+ * provide a reference to a channel object initialized by an earlier call of
+ * the cppi41_dma_ch_init() function.  After the successful completion of this
+ * function, the Tx DMA channel will be active and ready for data transmission.
+ */
+void cppi41_dma_ch_enable(struct cppi41_dma_ch_obj *dma_ch_obj);
+
+/**
+ * cppi41_dma_ch_disable - disable CPPI 4.1 Tx/Rx DMA channel
+ * @dma_ch_obj:	pointer to DMA channel object
+ *
+ * This function disables a specific Tx channel.  The caller is required to
+ * provide a reference to a channel object initialized by an earlier call of
+ * the cppi41_dma_ch_init() function.  After the successful completion of this
+ * function, the Tx DMA channel will be deactived.
+ */
+void cppi41_dma_ch_disable(struct cppi41_dma_ch_obj *dma_ch_obj);
+
+/**
+ * cppi41_dma_ch_teardown - tear down CPPI 4.1 transmit channel
+ * @dma_ch_obj:	pointer DMA channel object
+ *
+ * This function triggers the teardown of the given DMA channel.
+ *
+ * ATTENTION: Channel disable should not be called before the teardown is
+ * completed as a disable will stop the DMA scheduling on the channel resulting
+ * in the teardown complete event not being registered at all.
+ *
+ * NOTE: A successful channel teardown event is reported via queueing of a
+ * teardown descriptor.
+ *
+ * This function just sets up for the teardown of the channel and returns. The
+ * caller must detect the channel teardown event to assume that the channel is
+ * disabled.
+ *
+ * See cppi41_get_teardown_info() for the teardown completion processing.
+ */
+void cppi41_dma_ch_teardown(struct cppi41_dma_ch_obj *dma_ch_obj);
+
+/*
+ * CPPI 4.1 Queue Allocation and De-allocation APIs.
+ */
+
+/**
+ * cppi41_queue_alloc - allocate CPPI 4.1 queue
+ * @type:	queue type bitmask
+ * @q_mgr:	queue manager
+ * @q_num:	pointer to the queue number
+ *
+ * Returns 0 if queue allocated, error otherwise.
+ */
+int cppi41_queue_alloc(u8 type, u8 q_mgr, u16 *q_num);
+
+/**
+ * cppi41_queue_free - de-allocate CPPI 4.1 queue
+ * @q_mgr:	queue manager
+ * @q_num:	queue number
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ */
+int cppi41_queue_free(u8 q_mgr, u16 q_num);
+
+/*
+ *  CPPI 4.1 Queue Management APIs
+ */
+
+/**
+ * cppi41_queue_init - initialize CPPI 4.1 queue object
+ * @queue_obj:	pointer to the queue object
+ * @q_mgr:	queue manager
+ * @q_num:	queue number
+ *
+ * Returns 0 if valid queue, -EINVAL otherwise.
+ */
+int cppi41_queue_init(struct cppi41_queue_obj *queue_obj, u8 q_mgr, u16 q_num);
+
+/**
+ * cppi41_queue_push - push to CPPI 4.1 queue
+ * @queue_obj:	pointer to the queue object
+ * @desc_addr:	descriptor physical address
+ * @desc_size:	descriptor size
+ * @pkt_size:	packet size
+ *
+ * This function is called to queue a descriptor onto a queue.
+ * NOTE: pSize parameter is optional. Pass 0 in case not required.
+ */
+void cppi41_queue_push(const struct cppi41_queue_obj *queue_obj, u32 desc_addr,
+		       u32 desc_size, u32 pkt_size);
+
+/**
+ * cppi41_queue_pop - pop from CPPI 4.1 queue
+ * @queue_obj:	pointer to the queue object
+ *
+ * This function is called to pop a single descriptor from the queue.
+ *
+ * Returns a packet descriptor's physical address.
+ */
+unsigned long cppi41_queue_pop(const struct cppi41_queue_obj *queue_obj);
+
+/*
+ * CPPI 4.1 Miscellaneous APIs
+ */
+
+/**
+ * cppi41_get_teardown_info - CPPI 4.1 teardown completion processing function
+ *
+ * @addr:	physical address of teardown descriptor
+ * @info:	pointer to the teardown information word
+ *
+ * This function is called to complete the teardown processing on a channel
+ * and provides teardown information from the teardown descriptor passed to it.
+ * It also recycles the teardown descriptor back to the teardown descriptor
+ * queue.
+ *
+ * Returns 0 if valid descriptor, -EINVAL otherwise.
+ */
+int cppi41_get_teardown_info(unsigned long addr, u32 *info);
+
+/**
+ * cppi41_free_teardown_queue - Pop all teardown descriptors of a given dma
+ *                              blocka
+ * @dma_num     Number of the DMA block
+ *
+ * This functions frees all the tear down descriptors in the given dma block.
+ */
+void cppi41_free_teardown_queue(int dma_num);
+
+/**
+ * cppi41_exit - delete the instance created via cppi41_init()
+ */
+void cppi41_exit(void);
+
+/**
+ * cppi41_dma_sched_tbl_init - Update the Schedular table with the given data
+ *
+ * @dmanum      Number of DMa block
+ * @qmgr        Queue Manager Number
+ * @sch_tbl     Scheduler Table adderss
+ * @tblsz       Size of Scheduler table
+ *
+ */
+int cppi41_dma_sched_tbl_init(u8 dma_num, u8 q_mgr,
+				u32 *sched_tbl, u8 tbl_size);
+
+/**
+ * cppi41_schedtbl_add_dma_ch - add a dma channel to schedular table
+ *
+ * @dmanum      Number of DMa block
+ * @qmgr        Queue Manager Number
+ * @dma_ch      dma channel number
+ * @is_tx       transmit (is_tx=1) or recieve(is_tx=0)
+ *
+ * returns      number of channel in schedular table
+ */
+int cppi41_schedtbl_add_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx);
+
+/**
+ * cppi41_schedtbl_remove_dma_ch - remove a dma channel from schedular table
+ *
+ * @dmanum      Number of DMa block
+ * @qmgr        Queue Manager Number
+ * @dma_ch      dma channel number
+ * @is_tx       transmit (is_tx=1) or recieve(is_tx=0)
+ *
+ * returns      number of channel in schedular table
+ */
+int cppi41_schedtbl_remove_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx);
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
new file mode 100644
index 0000000..845f518
--- /dev/null
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -0,0 +1,1325 @@
+/*
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (c) 2008, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This file implements a DMA interface using TI's CPPI 4.1 DMA.
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+
+#include "cppi41.h"
+
+#include "musb_core.h"
+#include "musb_dma.h"
+#include "cppi41_dma.h"
+
+/* Configuration */
+#define USB_CPPI41_DESC_SIZE_SHIFT 6
+#define USB_CPPI41_DESC_ALIGN	(1 << USB_CPPI41_DESC_SIZE_SHIFT)
+#define USB_CPPI41_CH_NUM_PD	64	/* 4K bulk data at full speed */
+#define USB_CPPI41_MAX_PD	(USB_CPPI41_CH_NUM_PD * USB_CPPI41_NUM_CH)
+
+#undef DEBUG_CPPI_TD
+#undef USBDRV_DEBUG
+
+#ifdef USBDRV_DEBUG
+#define dprintk(x, ...) printk(x, ## __VA_ARGS__)
+#else
+#define dprintk(x, ...)
+#endif
+
+/*
+ * Data structure definitions
+ */
+
+/*
+ * USB Packet Descriptor
+ */
+struct usb_pkt_desc;
+
+struct usb_pkt_desc {
+	/* Hardware descriptor fields from this point */
+	struct cppi41_host_pkt_desc hw_desc;
+	/* Protocol specific data */
+	dma_addr_t dma_addr;
+	struct usb_pkt_desc *next_pd_ptr;
+	u8 ch_num;
+	u8 ep_num;
+	u8 eop;
+};
+
+/**
+ * struct cppi41_channel - DMA Channel Control Structure
+ *
+ * Using the same for Tx/Rx.
+ */
+struct cppi41_channel {
+	struct dma_channel channel;
+
+	struct cppi41_dma_ch_obj dma_ch_obj; /* DMA channel object */
+	struct cppi41_queue src_queue;	/* Tx queue or Rx free descriptor/ */
+					/* buffer queue */
+	struct cppi41_queue_obj queue_obj; /* Tx queue object or Rx free */
+					/* descriptor/buffer queue object */
+
+	u32 tag_info;			/* Tx PD Tag Information field */
+
+	/* Which direction of which endpoint? */
+	struct musb_hw_ep *end_pt;
+	u8 transmit;
+	u8 ch_num;			/* Channel number of Tx/Rx 0..3 */
+
+	/* DMA mode: "transparent", RNDIS, CDC, or Generic RNDIS */
+	u8 dma_mode;
+	u8 autoreq;
+
+	/* Book keeping for the current transfer request */
+	dma_addr_t start_addr;
+	u32 length;
+	u32 curr_offset;
+	u16 pkt_size;
+	u8  transfer_mode;
+	u8  zlp_queued;
+};
+
+/**
+ * struct cppi41 - CPPI 4.1 DMA Controller Object
+ *
+ * Encapsulates all book keeping and data structures pertaining to
+ * the CPPI 1.4 DMA controller.
+ */
+struct cppi41 {
+	struct dma_controller controller;
+	struct musb *musb;
+
+	struct cppi41_channel tx_cppi_ch[USB_CPPI41_NUM_CH];
+	struct cppi41_channel rx_cppi_ch[USB_CPPI41_NUM_CH];
+
+	struct usb_pkt_desc *pd_pool_head; /* Free PD pool head */
+	dma_addr_t pd_mem_phys;		/* PD memory physical address */
+	void *pd_mem;			/* PD memory pointer */
+	u8 pd_mem_rgn;			/* PD memory region number */
+
+	u16 teardownQNum;		/* Teardown completion queue number */
+	struct cppi41_queue_obj queue_obj; /* Teardown completion queue */
+					/* object */
+	u32 pkt_info;			/* Tx PD Packet Information field */
+};
+
+#ifdef DEBUG_CPPI_TD
+static void print_pd_list(struct usb_pkt_desc *pd_pool_head)
+{
+	struct usb_pkt_desc *curr_pd = pd_pool_head;
+	int cnt = 0;
+
+	while (curr_pd != NULL) {
+		if (cnt % 8 == 0)
+			dprintk("\n%02x ", cnt);
+		cnt++;
+		dprintk(" %p", curr_pd);
+		curr_pd = curr_pd->next_pd_ptr;
+	}
+	dprintk("\n");
+}
+#endif
+
+static struct usb_pkt_desc *usb_get_free_pd(struct cppi41 *cppi)
+{
+	struct usb_pkt_desc *free_pd = cppi->pd_pool_head;
+
+	if (free_pd != NULL) {
+		cppi->pd_pool_head = free_pd->next_pd_ptr;
+		free_pd->next_pd_ptr = NULL;
+	}
+	return free_pd;
+}
+
+static void usb_put_free_pd(struct cppi41 *cppi, struct usb_pkt_desc *free_pd)
+{
+	free_pd->next_pd_ptr = cppi->pd_pool_head;
+	cppi->pd_pool_head = free_pd;
+}
+
+/**
+ * cppi41_controller_start - start DMA controller
+ * @controller: the controller
+ *
+ * This function initializes the CPPI 4.1 Tx/Rx channels.
+ */
+static int __init cppi41_controller_start(struct dma_controller *controller)
+{
+	struct cppi41 *cppi;
+	struct cppi41_channel *cppi_ch;
+	void __iomem *reg_base;
+	struct usb_pkt_desc *curr_pd;
+	unsigned long pd_addr;
+	int i;
+
+	cppi = container_of(controller, struct cppi41, controller);
+
+	/*
+	 * TODO: We may need to check USB_CPPI41_MAX_PD here since CPPI 4.1
+	 * requires the descriptor count to be a multiple of 2 ^ 5 (i.e. 32).
+	 * Similarly, the descriptor size should also be a multiple of 32.
+	 */
+
+	/*
+	 * Allocate free packet descriptor pool for all Tx/Rx endpoints --
+	 * dma_alloc_coherent()  will return a page aligned address, so our
+	 * alignment requirement will be honored.
+	 */
+	cppi->pd_mem = dma_alloc_coherent(cppi->musb->controller,
+					  USB_CPPI41_MAX_PD *
+					  USB_CPPI41_DESC_ALIGN,
+					  &cppi->pd_mem_phys,
+					  GFP_KERNEL | GFP_DMA);
+	if (cppi->pd_mem == NULL) {
+		DBG(1, "ERROR: packet descriptor memory allocation failed\n");
+		return 0;
+	}
+	if (cppi41_mem_rgn_alloc(usb_cppi41_info.q_mgr, cppi->pd_mem_phys,
+				 USB_CPPI41_DESC_SIZE_SHIFT,
+				 get_count_order(USB_CPPI41_MAX_PD),
+				 &cppi->pd_mem_rgn)) {
+		DBG(1, "ERROR: queue manager memory region allocation "
+		    "failed\n");
+		goto free_pds;
+	}
+
+	/* Allocate the teardown completion queue */
+	if (cppi41_queue_alloc(CPPI41_UNASSIGNED_QUEUE,
+			       0, &cppi->teardownQNum)) {
+		DBG(1, "ERROR: teardown completion queue allocation failed\n");
+		goto free_mem_rgn;
+	}
+	DBG(4, "Allocated teardown completion queue %d in queue manager 0\n",
+	    cppi->teardownQNum);
+
+	if (cppi41_queue_init(&cppi->queue_obj, 0, cppi->teardownQNum)) {
+		DBG(1, "ERROR: teardown completion queue initialization "
+		    "failed\n");
+		goto free_queue;
+	}
+
+	/*
+	 * "Slice" PDs one-by-one from the big chunk and
+	 * add them to the free pool.
+	 */
+	curr_pd = (struct usb_pkt_desc *)cppi->pd_mem;
+	pd_addr = cppi->pd_mem_phys;
+	for (i = 0; i < USB_CPPI41_MAX_PD; i++) {
+		curr_pd->dma_addr = pd_addr;
+
+		usb_put_free_pd(cppi, curr_pd);
+		curr_pd = (struct usb_pkt_desc *)((char *)curr_pd +
+						  USB_CPPI41_DESC_ALIGN);
+		pd_addr += USB_CPPI41_DESC_ALIGN;
+	}
+
+	/* Configure the Tx channels */
+	for (i = 0, cppi_ch = cppi->tx_cppi_ch;
+	     i < ARRAY_SIZE(cppi->tx_cppi_ch); ++i, ++cppi_ch) {
+		const struct cppi41_tx_ch *tx_info;
+
+		memset(cppi_ch, 0, sizeof(struct cppi41_channel));
+		cppi_ch->transmit = 1;
+		cppi_ch->ch_num = i;
+		cppi_ch->channel.private_data = cppi;
+
+		/*
+		 * Extract the CPPI 4.1 DMA Tx channel configuration and
+		 * construct/store the Tx PD tag info field for later use...
+		 */
+		tx_info = cppi41_dma_block[usb_cppi41_info.dma_block].tx_ch_info
+			  + usb_cppi41_info.ep_dma_ch[i];
+		cppi_ch->src_queue = tx_info->tx_queue[0];
+		cppi_ch->tag_info = (tx_info->port_num <<
+				     CPPI41_SRC_TAG_PORT_NUM_SHIFT) |
+				    (tx_info->ch_num <<
+				     CPPI41_SRC_TAG_CH_NUM_SHIFT) |
+				    (tx_info->sub_ch_num <<
+				     CPPI41_SRC_TAG_SUB_CH_NUM_SHIFT);
+	}
+
+	/* Configure the Rx channels */
+	for (i = 0, cppi_ch = cppi->rx_cppi_ch;
+	     i < ARRAY_SIZE(cppi->rx_cppi_ch); ++i, ++cppi_ch) {
+		memset(cppi_ch, 0, sizeof(struct cppi41_channel));
+		cppi_ch->ch_num = i;
+		cppi_ch->channel.private_data = cppi;
+	}
+
+	/* Construct/store Tx PD packet info field for later use */
+	cppi->pkt_info = (CPPI41_PKT_TYPE_USB << CPPI41_PKT_TYPE_SHIFT) |
+			 (CPPI41_RETURN_LINKED << CPPI41_RETURN_POLICY_SHIFT) |
+			 (usb_cppi41_info.q_mgr << CPPI41_RETURN_QMGR_SHIFT) |
+			 (usb_cppi41_info.tx_comp_q[0] <<
+			  CPPI41_RETURN_QNUM_SHIFT);
+
+	/* Do necessary configuartion in hardware to get started */
+	reg_base = cppi->musb->ctrl_base;
+
+	/* Disable auto request mode */
+	musb_writel(reg_base, USB_AUTOREQ_REG, 0);
+
+	/* Disable the CDC/RNDIS modes */
+	musb_writel(reg_base, USB_TX_MODE_REG, 0);
+	musb_writel(reg_base, USB_RX_MODE_REG, 0);
+
+	return 1;
+
+ free_queue:
+	if (cppi41_queue_free(0, cppi->teardownQNum))
+		DBG(1, "ERROR: failed to free teardown completion queue\n");
+
+ free_mem_rgn:
+	if (cppi41_mem_rgn_free(usb_cppi41_info.q_mgr, cppi->pd_mem_rgn))
+		DBG(1, "ERROR: failed to free queue manager memory region\n");
+
+ free_pds:
+	dma_free_coherent(cppi->musb->controller,
+			  USB_CPPI41_MAX_PD * USB_CPPI41_DESC_ALIGN,
+			  cppi->pd_mem, cppi->pd_mem_phys);
+
+	return 0;
+}
+
+/**
+ * cppi41_controller_stop - stop DMA controller
+ * @controller: the controller
+ *
+ * De-initialize the DMA Controller as necessary.
+ */
+static int cppi41_controller_stop(struct dma_controller *controller)
+{
+	struct cppi41 *cppi;
+	void __iomem *reg_base;
+
+	cppi = container_of(controller, struct cppi41, controller);
+
+	/*
+	 * pop all the teardwon descriptor queued to tdQueue
+	 */
+	cppi41_free_teardown_queue(0);
+
+	/* Free the teardown completion queue */
+	if (cppi41_queue_free(usb_cppi41_info.q_mgr, cppi->teardownQNum))
+		DBG(1, "ERROR: failed to free teardown completion queue\n");
+
+	/*
+	 * Free the packet descriptor region allocated
+	 * for all Tx/Rx channels.
+	 */
+	if (cppi41_mem_rgn_free(usb_cppi41_info.q_mgr, cppi->pd_mem_rgn))
+		DBG(1, "ERROR: failed to free queue manager memory region\n");
+
+	dma_free_coherent(cppi->musb->controller,
+			  USB_CPPI41_MAX_PD * USB_CPPI41_DESC_ALIGN,
+			  cppi->pd_mem, cppi->pd_mem_phys);
+
+	reg_base = cppi->musb->ctrl_base;
+
+	/* Disable auto request mode */
+	musb_writel(reg_base, USB_AUTOREQ_REG, 0);
+
+	/* Disable the CDC/RNDIS modes */
+	musb_writel(reg_base, USB_TX_MODE_REG, 0);
+	musb_writel(reg_base, USB_RX_MODE_REG, 0);
+
+	return 1;
+}
+
+/**
+ * cppi41_channel_alloc - allocate a CPPI channel for DMA.
+ * @controller: the controller
+ * @ep:	the endpoint
+ * @is_tx:	1 for Tx channel, 0 for Rx channel
+ *
+ * With CPPI, channels are bound to each transfer direction of a non-control
+ * endpoint, so allocating (and deallocating) is mostly a way to notice bad
+ * housekeeping on the software side.  We assume the IRQs are always active.
+ */
+static struct dma_channel *cppi41_channel_alloc(struct dma_controller
+						*controller,
+						struct musb_hw_ep *ep, u8 is_tx)
+{
+	struct cppi41 *cppi;
+	struct cppi41_channel  *cppi_ch;
+	u32 ch_num, ep_num = ep->epnum;
+
+	cppi = container_of(controller, struct cppi41, controller);
+
+	/* Remember, ep_num: 1 .. Max_EP, and CPPI ch_num: 0 .. Max_EP - 1 */
+	ch_num = ep_num - 1;
+
+	if (ep_num > USB_CPPI41_NUM_CH) {
+		DBG(1, "No %cx DMA channel for EP%d\n",
+		    is_tx ? 'T' : 'R', ep_num);
+		return NULL;
+	}
+
+	cppi_ch = (is_tx ? cppi->tx_cppi_ch : cppi->rx_cppi_ch) + ch_num;
+
+	/* As of now, just return the corresponding CPPI 4.1 channel handle */
+	if (is_tx) {
+		/* Initialize the CPPI 4.1 Tx DMA channel */
+		if (cppi41_tx_ch_init(&cppi_ch->dma_ch_obj,
+				      usb_cppi41_info.dma_block,
+				      usb_cppi41_info.ep_dma_ch[ch_num])) {
+			DBG(1, "ERROR: cppi41_tx_ch_init failed for "
+			    "channel %d\n", ch_num);
+			return NULL;
+		}
+		/*
+		 * Teardown descriptors will be pushed to the dedicated
+		 * completion queue.
+		 */
+		cppi41_dma_ch_default_queue(&cppi_ch->dma_ch_obj,
+					    0, cppi->teardownQNum);
+	} else {
+		struct cppi41_rx_ch_cfg rx_cfg;
+		u8 q_mgr = usb_cppi41_info.q_mgr;
+		int i;
+
+		/* Initialize the CPPI 4.1 Rx DMA channel */
+		if (cppi41_rx_ch_init(&cppi_ch->dma_ch_obj,
+				      usb_cppi41_info.dma_block,
+				      usb_cppi41_info.ep_dma_ch[ch_num])) {
+			DBG(1, "ERROR: cppi41_rx_ch_init failed\n");
+			return NULL;
+		}
+
+		if (cppi41_queue_alloc(CPPI41_FREE_DESC_BUF_QUEUE |
+				       CPPI41_UNASSIGNED_QUEUE,
+				       q_mgr, &cppi_ch->src_queue.q_num)) {
+			DBG(1, "ERROR: cppi41_queue_alloc failed for "
+			    "free descriptor/buffer queue\n");
+			return NULL;
+		}
+		DBG(4, "Allocated free descriptor/buffer queue %d in "
+		    "queue manager %d\n", cppi_ch->src_queue.q_num, q_mgr);
+
+		rx_cfg.default_desc_type = cppi41_rx_host_desc;
+		rx_cfg.sop_offset = 0;
+		rx_cfg.retry_starved = 1;
+		rx_cfg.rx_queue.q_mgr = cppi_ch->src_queue.q_mgr = q_mgr;
+		rx_cfg.rx_queue.q_num = usb_cppi41_info.rx_comp_q[0];
+		for (i = 0; i < 4; i++)
+			rx_cfg.cfg.host_pkt.fdb_queue[i] = cppi_ch->src_queue;
+		cppi41_rx_ch_configure(&cppi_ch->dma_ch_obj, &rx_cfg);
+	}
+
+	/* Initialize the CPPI 4.1 DMA source queue */
+	if (cppi41_queue_init(&cppi_ch->queue_obj, cppi_ch->src_queue.q_mgr,
+			       cppi_ch->src_queue.q_num)) {
+		DBG(1, "ERROR: cppi41_queue_init failed for %s queue",
+		    is_tx ? "Tx" : "Rx free descriptor/buffer");
+		if (is_tx == 0 &&
+		    cppi41_queue_free(cppi_ch->src_queue.q_mgr,
+				      cppi_ch->src_queue.q_num))
+			DBG(1, "ERROR: failed to free Rx descriptor/buffer "
+			    "queue\n");
+		 return NULL;
+	}
+
+	/* Enable the DMA channel */
+	cppi41_dma_ch_enable(&cppi_ch->dma_ch_obj);
+
+	if (cppi_ch->end_pt)
+		DBG(1, "Re-allocating DMA %cx channel %d (%p)\n",
+		    is_tx ? 'T' : 'R', ch_num, cppi_ch);
+
+	cppi_ch->end_pt = ep;
+	cppi_ch->ch_num = ch_num;
+	cppi_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+	DBG(4, "Allocated DMA %cx channel %d for EP%d\n", is_tx ? 'T' : 'R',
+	    ch_num, ep_num);
+
+	return &cppi_ch->channel;
+}
+
+/**
+ * cppi41_channel_release - release a CPPI DMA channel
+ * @channel: the channel
+ */
+static void cppi41_channel_release(struct dma_channel *channel)
+{
+	struct cppi41_channel *cppi_ch;
+
+	/* REVISIT: for paranoia, check state and abort if needed... */
+	cppi_ch = container_of(channel, struct cppi41_channel, channel);
+	if (cppi_ch->end_pt == NULL)
+		DBG(1, "Releasing idle DMA channel %p\n", cppi_ch);
+
+	/* But for now, not its IRQ */
+	cppi_ch->end_pt = NULL;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
+
+	cppi41_dma_ch_disable(&cppi_ch->dma_ch_obj);
+
+	/* De-allocate Rx free descriptior/buffer queue */
+	if (cppi_ch->transmit == 0 &&
+	    cppi41_queue_free(cppi_ch->src_queue.q_mgr,
+			      cppi_ch->src_queue.q_num))
+		DBG(1, "ERROR: failed to free Rx descriptor/buffer queue\n");
+}
+
+static void cppi41_mode_update(struct cppi41_channel *cppi_ch, u8 mode)
+{
+	if (mode != cppi_ch->dma_mode) {
+		struct cppi41 *cppi = cppi_ch->channel.private_data;
+		void *__iomem reg_base = cppi->musb->ctrl_base;
+		u32 reg_val;
+		u8 ep_num = cppi_ch->ch_num + 1;
+
+		if (cppi_ch->transmit) {
+			reg_val = musb_readl(reg_base, USB_TX_MODE_REG);
+			reg_val &= ~USB_TX_MODE_MASK(ep_num);
+			reg_val |= mode << USB_TX_MODE_SHIFT(ep_num);
+			musb_writel(reg_base, USB_TX_MODE_REG, reg_val);
+		} else {
+			reg_val = musb_readl(reg_base, USB_RX_MODE_REG);
+			reg_val &= ~USB_RX_MODE_MASK(ep_num);
+			reg_val |= mode << USB_RX_MODE_SHIFT(ep_num);
+			musb_writel(reg_base, USB_RX_MODE_REG, reg_val);
+		}
+		cppi_ch->dma_mode = mode;
+	}
+}
+
+/*
+ * CPPI 4.1 Tx:
+ * ============
+ * Tx is a lot more reasonable than Rx: RNDIS mode seems to behave well except
+ * how it handles the exactly-N-packets case. It appears that there's a hiccup
+ * in that case (maybe the DMA completes before a ZLP gets written?) boiling
+ * down to not being able to rely on the XFER DMA writing any terminating zero
+ * length packet before the next transfer is started...
+ *
+ * The generic RNDIS mode does not have this misfeature, so we prefer using it
+ * instead.  We then send the terminating ZLP *explictly* using DMA instead of
+ * doing it by PIO after an IRQ.
+ *
+ */
+
+/**
+ * cppi41_next_tx_segment - DMA write for the next chunk of a buffer
+ * @tx_ch:	Tx channel
+ *
+ * Context: controller IRQ-locked
+ */
+static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
+{
+	struct cppi41 *cppi = tx_ch->channel.private_data;
+	struct usb_pkt_desc *curr_pd;
+	u32 length = tx_ch->length - tx_ch->curr_offset;
+	u32 pkt_size = tx_ch->pkt_size;
+	unsigned num_pds, n;
+
+	/*
+	 * Tx can use the generic RNDIS mode where we can probably fit this
+	 * transfer in one PD and one IRQ.  The only time we would NOT want
+	 * to use it is when the hardware constraints prevent it...
+	 */
+	if ((pkt_size & 0x3f) == 0 && length > pkt_size) {
+		num_pds  = 1;
+		pkt_size = length;
+		cppi41_mode_update(tx_ch, USB_GENERIC_RNDIS_MODE);
+	} else {
+		num_pds  = (length + pkt_size - 1) / pkt_size;
+		cppi41_mode_update(tx_ch, USB_TRANSPARENT_MODE);
+	}
+
+	/*
+	 * If length of transmit buffer is 0 or a multiple of the endpoint size,
+	 * then send the zero length packet.
+	 */
+	if (!length || (tx_ch->transfer_mode && length % pkt_size == 0))
+		num_pds++;
+
+	DBG(4, "TX DMA%u, %s, maxpkt %u, %u PDs, addr %#x, len %u\n",
+	    tx_ch->ch_num, tx_ch->dma_mode ? "accelerated" : "transparent",
+	    pkt_size, num_pds, tx_ch->start_addr + tx_ch->curr_offset, length);
+
+	for (n = 0; n < num_pds; n++) {
+		struct cppi41_host_pkt_desc *hw_desc;
+
+		/* Get Tx host packet descriptor from the free pool */
+		curr_pd = usb_get_free_pd(cppi);
+		if (curr_pd == NULL) {
+			DBG(1, "No Tx PDs\n");
+			break;
+		}
+
+		if (length < pkt_size)
+			pkt_size = length;
+
+		hw_desc = &curr_pd->hw_desc;
+		hw_desc->desc_info = (CPPI41_DESC_TYPE_HOST <<
+				      CPPI41_DESC_TYPE_SHIFT) | pkt_size;
+		hw_desc->tag_info = tx_ch->tag_info;
+		hw_desc->pkt_info = cppi->pkt_info;
+
+		hw_desc->buf_ptr = tx_ch->start_addr + tx_ch->curr_offset;
+		hw_desc->buf_len = pkt_size;
+		hw_desc->next_desc_ptr = 0;
+
+		curr_pd->ch_num = tx_ch->ch_num;
+		curr_pd->ep_num = tx_ch->end_pt->epnum;
+
+		tx_ch->curr_offset += pkt_size;
+		length -= pkt_size;
+
+		if (pkt_size == 0)
+			tx_ch->zlp_queued = 1;
+
+		DBG(5, "TX PD %p: buf %08x, len %08x, pkt info %08x\n", curr_pd,
+		    hw_desc->buf_ptr, hw_desc->buf_len, hw_desc->pkt_info);
+
+		cppi41_queue_push(&tx_ch->queue_obj, curr_pd->dma_addr,
+				  USB_CPPI41_DESC_ALIGN, pkt_size);
+	}
+
+	return n;
+}
+
+static void cppi41_autoreq_update(struct cppi41_channel *rx_ch, u8 autoreq)
+{
+	struct cppi41 *cppi = rx_ch->channel.private_data;
+
+	if (is_host_active(cppi->musb) &&
+	    autoreq != rx_ch->autoreq) {
+		void *__iomem reg_base = cppi->musb->ctrl_base;
+		u32 reg_val = musb_readl(reg_base, USB_AUTOREQ_REG);
+		u8 ep_num = rx_ch->ch_num + 1;
+
+		reg_val &= ~USB_RX_AUTOREQ_MASK(ep_num);
+		reg_val |= autoreq << USB_RX_AUTOREQ_SHIFT(ep_num);
+
+		musb_writel(reg_base, USB_AUTOREQ_REG, reg_val);
+		rx_ch->autoreq = autoreq;
+	}
+}
+
+static void cppi41_set_ep_size(struct cppi41_channel *rx_ch, u32 pkt_size)
+{
+	struct cppi41 *cppi = rx_ch->channel.private_data;
+	void *__iomem reg_base = cppi->musb->ctrl_base;
+	u8 ep_num = rx_ch->ch_num + 1;
+
+	musb_writel(reg_base, USB_GENERIC_RNDIS_EP_SIZE_REG(ep_num), pkt_size);
+}
+
+/*
+ * CPPI 4.1 Rx:
+ * ============
+ * Consider a 1KB bulk Rx buffer in two scenarios: (a) it's fed two 300 byte
+ * packets back-to-back, and (b) it's fed two 512 byte packets back-to-back.
+ * (Full speed transfers have similar scenarios.)
+ *
+ * The correct behavior for Linux is that (a) fills the buffer with 300 bytes,
+ * and the next packet goes into a buffer that's queued later; while (b) fills
+ * the buffer with 1024 bytes.  How to do that with accelerated DMA modes?
+ *
+ * Rx queues in RNDIS mode (one single BD) handle (a) correctly but (b) loses
+ * BADLY because nothing (!) happens when that second packet fills the buffer,
+ * much less when a third one arrives -- which makes it not a "true" RNDIS mode.
+ * In the RNDIS protocol short-packet termination is optional, and it's fine if
+ * the peripherals (not hosts!) pad the messages out to end of buffer. Standard
+ * PCI host controller DMA descriptors implement that mode by default... which
+ * is no accident.
+ *
+ * Generic RNDIS mode is the only way to reliably make both cases work.  This
+ * mode is identical to the "normal" RNDIS mode except for the case where the
+ * last packet of the segment matches the max USB packet size -- in this case,
+ * the packet will be closed when a value (0x10000 max) in the Generic RNDIS
+ * EP Size register is reached.  This mode will work for the network drivers
+ * (CDC/RNDIS) as well as for the mass storage drivers where there is no short
+ * packet.
+ *
+ * BUT we can only use non-transparent modes when USB packet size is a multiple
+ * of 64 bytes. Let's see what happens when  this is not the case...
+ *
+ * Rx queues (2 BDs with 512 bytes each) have converse problems to RNDIS mode:
+ * (b) is handled right but (a) loses badly.  DMA doesn't stop after receiving
+ * a short packet and processes both of those PDs; so both packets are loaded
+ * into the buffer (with 212 byte gap between them), and the next buffer queued
+ * will NOT get its 300 bytes of data.  Even in the case when there should be
+ * no short packets (URB_SHORT_NOT_OK is set), queueing several packets in the
+ * host mode doesn't win us anything since we have to manually "prod" the Rx
+ * process after each packet is received by setting ReqPkt bit in endpoint's
+ * RXCSR; in the peripheral mode without short packets, queueing could be used
+ * BUT we'll have to *teardown* the channel if a short packet still arrives in
+ * the peripheral mode, and to "collect" the left-over packet descriptors from
+ * the free descriptor/buffer queue in both cases...
+ *
+ * One BD at a time is the only way to make make both cases work reliably, with
+ * software handling both cases correctly, at the significant penalty of needing
+ * an IRQ per packet.  (The lack of I/O overlap can be slightly ameliorated by
+ * enabling double buffering.)
+ *
+ * There seems to be no way to identify for sure the cases where the CDC mode
+ * is appropriate...
+ *
+ */
+
+/**
+ * cppi41_next_rx_segment - DMA read for the next chunk of a buffer
+ * @rx_ch:	Rx channel
+ *
+ * Context: controller IRQ-locked
+ *
+ * NOTE: In the transparent mode, we have to queue one packet at a time since:
+ *	 - we must avoid starting reception of another packet after receiving
+ *	   a short packet;
+ *	 - in host mode we have to set ReqPkt bit in the endpoint's RXCSR after
+ *	   receiving each packet but the last one... ugly!
+ */
+static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
+{
+	struct cppi41 *cppi = rx_ch->channel.private_data;
+	struct usb_pkt_desc *curr_pd;
+	struct cppi41_host_pkt_desc *hw_desc;
+	u32 length = rx_ch->length - rx_ch->curr_offset;
+	u32 pkt_size = rx_ch->pkt_size;
+	u32 max_rx_transfer_size = 128 * 1024;
+	u32 i, n_bd , pkt_len;
+	struct usb_gadget_driver *gadget_driver;
+
+	if (is_peripheral_active(cppi->musb)) {
+		/* TODO: temporary fix for CDC/RNDIS which needs to be in
+		 * GENERIC_RNDIS mode. Without this RNDIS gadget taking
+		 * more then 2K ms for a 64 byte pings.
+		 */
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+		gadget_driver = cppi->musb->gadget_driver;
+#endif
+		if (!strcmp(gadget_driver->driver.name, "g_ether")) {
+			cppi41_mode_update(rx_ch, USB_GENERIC_RNDIS_MODE);
+		} else {
+			max_rx_transfer_size = 512;
+			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
+		}
+		pkt_len = 0;
+		if (rx_ch->length < max_rx_transfer_size)
+			pkt_len = rx_ch->length;
+		cppi41_set_ep_size(rx_ch, pkt_len);
+	} else {
+		/*
+		 * Rx can use the generic RNDIS mode where we can
+		 * probably fit this transfer in one PD and one IRQ
+		 * (or two with a short packet).
+		 */
+		if ((pkt_size & 0x3f) == 0 && length >= 2 * pkt_size) {
+			cppi41_mode_update(rx_ch, USB_GENERIC_RNDIS_MODE);
+			cppi41_autoreq_update(rx_ch, USB_AUTOREQ_ALL_BUT_EOP);
+
+			if (likely(length < 0x10000))
+				pkt_size = length - length % pkt_size;
+			else
+				pkt_size = 0x10000;
+			cppi41_set_ep_size(rx_ch, pkt_size);
+		} else {
+			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
+			cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
+		}
+	}
+
+	DBG(4, "RX DMA%u, %s, maxpkt %u, addr %#x, rec'd %u/%u\n",
+	    rx_ch->ch_num, rx_ch->dma_mode ? "accelerated" : "transparent",
+	    pkt_size, rx_ch->start_addr + rx_ch->curr_offset,
+	    rx_ch->curr_offset, rx_ch->length);
+
+	/* calculate number of bd required */
+	n_bd = (length + max_rx_transfer_size - 1)/max_rx_transfer_size;
+
+	for (i = 0; i < n_bd ; ++i) {
+		/* Get Rx packet descriptor from the free pool */
+		curr_pd = usb_get_free_pd(cppi);
+		if (curr_pd == NULL) {
+			/* Shouldn't ever happen! */
+			DBG(4, "No Rx PDs\n");
+			goto sched;
+		}
+
+		pkt_len =
+		(length > max_rx_transfer_size) ? max_rx_transfer_size : length;
+
+		hw_desc = &curr_pd->hw_desc;
+		hw_desc->orig_buf_ptr = rx_ch->start_addr + rx_ch->curr_offset;
+		hw_desc->orig_buf_len = pkt_len;
+
+		curr_pd->ch_num = rx_ch->ch_num;
+		curr_pd->ep_num = rx_ch->end_pt->epnum;
+
+		curr_pd->eop = (length -= pkt_len) ? 0 : 1;
+		rx_ch->curr_offset += pkt_len;
+
+		/*
+		 * Push the free Rx packet descriptor
+		 * to the free descriptor/buffer queue.
+		 */
+		cppi41_queue_push(&rx_ch->queue_obj, curr_pd->dma_addr,
+			USB_CPPI41_DESC_ALIGN, 0);
+	}
+
+sched:
+	/*
+	 * HCD arranged ReqPkt for the first packet.
+	 * We arrange it for all but the last one.
+	 */
+	if (is_host_active(cppi->musb) && rx_ch->channel.actual_len) {
+		void __iomem *epio = rx_ch->end_pt->regs;
+		u16 csr = musb_readw(epio, MUSB_RXCSR);
+
+		csr |= MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_H_WZC_BITS;
+		musb_writew(epio, MUSB_RXCSR, csr);
+	}
+
+	/* enable schedular if not enabled */
+	if (is_peripheral_active(cppi->musb) && (n_bd > 0))
+		cppi41_schedtbl_add_dma_ch(0, 0, rx_ch->ch_num,
+			CPPI41_DMACH_RX_DIR);
+	return 1;
+}
+
+/**
+ * cppi41_channel_program - program channel for data transfer
+ * @channel:	the channel
+ * @maxpacket:	max packet size
+ * @mode:	for Rx, 1 unless the USB protocol driver promised to treat
+ *		all short reads as errors and kick in high level fault recovery;
+ *		for Tx, 0 unless the protocol driver _requires_ short-packet
+ *		termination mode
+ * @dma_addr:	DMA address of buffer
+ * @length:	length of buffer
+ *
+ * Context: controller IRQ-locked
+ */
+static int cppi41_channel_program(struct dma_channel *channel,	u16 maxpacket,
+				  u8 mode, dma_addr_t dma_addr, u32 length)
+{
+	struct cppi41_channel *cppi_ch;
+	unsigned queued;
+
+	cppi_ch = container_of(channel, struct cppi41_channel, channel);
+
+	switch (channel->status) {
+	case MUSB_DMA_STATUS_BUS_ABORT:
+	case MUSB_DMA_STATUS_CORE_ABORT:
+		/* Fault IRQ handler should have handled cleanup */
+		WARNING("%cx DMA%d not cleaned up after abort!\n",
+			cppi_ch->transmit ? 'T' : 'R', cppi_ch->ch_num);
+		break;
+	case MUSB_DMA_STATUS_BUSY:
+		WARNING("Program active channel? %cx DMA%d\n",
+			cppi_ch->transmit ? 'T' : 'R', cppi_ch->ch_num);
+		break;
+	case MUSB_DMA_STATUS_UNKNOWN:
+		DBG(1, "%cx DMA%d not allocated!\n",
+		    cppi_ch->transmit ? 'T' : 'R', cppi_ch->ch_num);
+		return 0;
+	case MUSB_DMA_STATUS_FREE:
+		break;
+	}
+
+	channel->status = MUSB_DMA_STATUS_BUSY;
+
+	/* Set the transfer parameters, then queue up the first segment */
+	cppi_ch->start_addr = dma_addr;
+	cppi_ch->curr_offset = 0;
+	cppi_ch->pkt_size = maxpacket;
+	cppi_ch->length = length;
+	cppi_ch->transfer_mode = mode;
+	cppi_ch->zlp_queued = 0;
+	cppi_ch->channel.actual_len = 0;
+
+	/* Tx or Rx channel? */
+	if (cppi_ch->transmit)
+		queued = cppi41_next_tx_segment(cppi_ch);
+	else
+		queued = cppi41_next_rx_segment(cppi_ch);
+
+	return	queued > 0;
+}
+
+static struct usb_pkt_desc *usb_get_pd_ptr(struct cppi41 *cppi,
+					   unsigned long pd_addr)
+{
+	if (pd_addr >= cppi->pd_mem_phys && pd_addr < cppi->pd_mem_phys +
+	    USB_CPPI41_MAX_PD * USB_CPPI41_DESC_ALIGN)
+		return pd_addr - cppi->pd_mem_phys + cppi->pd_mem;
+	else
+		return NULL;
+}
+
+static int usb_check_teardown(struct cppi41_channel *cppi_ch,
+			      unsigned long pd_addr)
+{
+	u32 info;
+
+	if (cppi41_get_teardown_info(pd_addr, &info)) {
+		DBG(1, "ERROR: not a teardown descriptor\n");
+		return 0;
+	}
+
+	if ((info & CPPI41_TEARDOWN_TX_RX_MASK) ==
+	    (!cppi_ch->transmit << CPPI41_TEARDOWN_TX_RX_SHIFT) &&
+	    (info & CPPI41_TEARDOWN_DMA_NUM_MASK) ==
+	    (usb_cppi41_info.dma_block << CPPI41_TEARDOWN_DMA_NUM_SHIFT) &&
+	    (info & CPPI41_TEARDOWN_CHAN_NUM_MASK) ==
+	    (usb_cppi41_info.ep_dma_ch[cppi_ch->ch_num] <<
+	     CPPI41_TEARDOWN_CHAN_NUM_SHIFT))
+		return 1;
+
+	DBG(1, "ERROR: unexpected values in teardown descriptor\n");
+	return 0;
+}
+
+/*
+ * We can't handle the channel teardown via the default completion queue in
+ * context of the controller IRQ-locked, so we use the dedicated teardown
+ * completion queue which we can just poll for a teardown descriptor, not
+ * interfering with the Tx completion queue processing.
+ */
+static void usb_tx_ch_teardown(struct cppi41_channel *tx_ch)
+{
+	struct cppi41 *cppi = tx_ch->channel.private_data;
+	struct musb *musb = cppi->musb;
+	void __iomem *reg_base = musb->ctrl_base;
+	u32 td_reg, timeout = 0xfffff;
+	u8 ep_num = tx_ch->ch_num + 1;
+	unsigned long pd_addr;
+
+	/* Initiate teardown for Tx DMA channel */
+	cppi41_dma_ch_teardown(&tx_ch->dma_ch_obj);
+
+	/* Wait for a descriptor to be queued and pop it... */
+	do {
+		td_reg  = musb_readl(reg_base, USB_TEARDOWN_REG);
+		td_reg |= USB_TX_TDOWN_MASK(ep_num);
+		musb_writel(reg_base, USB_TEARDOWN_REG, td_reg);
+
+		pd_addr = cppi41_queue_pop(&cppi->queue_obj);
+	} while (!pd_addr && timeout--);
+
+	if (pd_addr) {
+
+		dprintk("Descriptor (%08lx) popped from teardown completion "
+			"queue\n", pd_addr);
+
+		if (usb_check_teardown(tx_ch, pd_addr)) {
+			dprintk("Teardown Desc (%p) rcvd\n", pd_addr);
+		} else
+			ERR("Invalid PD(%08lx)popped from TearDn completion"
+				"queue\n", pd_addr);
+	} else {
+		if (timeout <= 0)
+			ERR("Teardown Desc not rcvd\n");
+	}
+}
+
+/*
+ * For Rx DMA channels, the situation is more complex: there's only a single
+ * completion queue for all our needs, so we have to temporarily redirect the
+ * completed descriptors to our teardown completion queue, with a possibility
+ * of a completed packet landing there as well...
+ */
+static void usb_rx_ch_teardown(struct cppi41_channel *rx_ch)
+{
+	struct cppi41 *cppi = rx_ch->channel.private_data;
+	u32 timeout = 0xfffff;
+
+	cppi41_dma_ch_default_queue(&rx_ch->dma_ch_obj, 0, cppi->teardownQNum);
+
+	/* Initiate teardown for Rx DMA channel */
+	cppi41_dma_ch_teardown(&rx_ch->dma_ch_obj);
+
+	do {
+		struct usb_pkt_desc *curr_pd;
+		unsigned long pd_addr;
+
+		/* Wait for a descriptor to be queued and pop it... */
+		do {
+			pd_addr = cppi41_queue_pop(&cppi->queue_obj);
+		} while (!pd_addr && timeout--);
+
+		if (timeout <= 0) {
+			ERR("teardown Desc not found\n");
+			break;
+		}
+
+		dprintk("Descriptor (%08lx) popped from teardown completion "
+			"queue\n", pd_addr);
+
+		/*
+		 * We might have popped a completed Rx PD, so check if the
+		 * physical address is within the PD region first.  If it's
+		 * not the case, it must be a teardown descriptor...
+		 * */
+		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
+		if (curr_pd == NULL) {
+			if (usb_check_teardown(rx_ch, pd_addr))
+				break;
+			continue;
+		}
+
+		/* Paranoia: check if PD is from the right channel... */
+		if (curr_pd->ch_num != rx_ch->ch_num) {
+			ERR("Unexpected channel %d in Rx PD\n",
+			    curr_pd->ch_num);
+			continue;
+		}
+
+		/* Extract the buffer length from the completed PD */
+		rx_ch->channel.actual_len += curr_pd->hw_desc.buf_len;
+
+		/*
+		 * Return Rx PDs to the software list --
+		 * this is protected by critical section.
+		 */
+		usb_put_free_pd(cppi, curr_pd);
+	} while (0);
+
+	/* Now restore the default Rx completion queue... */
+	cppi41_dma_ch_default_queue(&rx_ch->dma_ch_obj, usb_cppi41_info.q_mgr,
+				    usb_cppi41_info.rx_comp_q[0]);
+}
+
+/*
+ * cppi41_channel_abort
+ *
+ * Context: controller IRQ-locked, endpoint selected.
+ */
+static int cppi41_channel_abort(struct dma_channel *channel)
+{
+	struct cppi41 *cppi;
+	struct cppi41_channel *cppi_ch;
+	struct musb  *musb;
+	void __iomem *reg_base, *epio;
+	unsigned long pd_addr;
+	u32 csr, td_reg;
+	u8 ch_num, ep_num;
+
+	cppi_ch = container_of(channel, struct cppi41_channel, channel);
+	ch_num = cppi_ch->ch_num;
+
+	switch (channel->status) {
+	case MUSB_DMA_STATUS_BUS_ABORT:
+	case MUSB_DMA_STATUS_CORE_ABORT:
+		/* From Rx or Tx fault IRQ handler */
+	case MUSB_DMA_STATUS_BUSY:
+		/* The hardware needs shutting down... */
+		dprintk("%s: DMA busy, status = %x\n",
+			__func__, channel->status);
+		break;
+	case MUSB_DMA_STATUS_UNKNOWN:
+		DBG(1, "%cx DMA%d not allocated\n",
+		    cppi_ch->transmit ? 'T' : 'R', ch_num);
+		/* FALLTHROUGH */
+	case MUSB_DMA_STATUS_FREE:
+		return 0;
+	}
+
+	cppi = cppi_ch->channel.private_data;
+	musb = cppi->musb;
+	reg_base = musb->ctrl_base;
+	epio = cppi_ch->end_pt->regs;
+	ep_num = ch_num + 1;
+
+#ifdef DEBUG_CPPI_TD
+	printk("Before teardown:");
+	print_pd_list(cppi->pd_pool_head);
+#endif
+
+	if (cppi_ch->transmit) {
+		dprintk("Tx channel teardown, cppi_ch = %p\n", cppi_ch);
+
+		/* Tear down Tx DMA channel */
+		usb_tx_ch_teardown(cppi_ch);
+
+		/* Issue CPPI FIFO teardown for Tx channel */
+		td_reg  = musb_readl(reg_base, USB_TEARDOWN_REG);
+		td_reg |= USB_TX_TDOWN_MASK(ep_num);
+		musb_writel(reg_base, USB_TEARDOWN_REG, td_reg);
+
+		/* Flush FIFO of the endpoint */
+		csr  = musb_readw(epio, MUSB_TXCSR);
+		csr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_H_WZC_BITS;
+		musb_writew(epio, MUSB_TXCSR, csr);
+		musb_writew(epio, MUSB_TXCSR, csr);
+	} else { /* Rx */
+		dprintk("Rx channel teardown, cppi_ch = %p\n", cppi_ch);
+
+		/* Flush FIFO of the endpoint */
+		csr  = musb_readw(epio, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_H_WZC_BITS;
+		musb_writew(epio, MUSB_RXCSR, csr);
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		/* Issue CPPI FIFO teardown for Rx channel */
+		td_reg  = musb_readl(reg_base, USB_TEARDOWN_REG);
+		td_reg |= USB_RX_TDOWN_MASK(ep_num);
+		musb_writel(reg_base, USB_TEARDOWN_REG, td_reg);
+
+		/* Tear down Rx DMA channel */
+		usb_rx_ch_teardown(cppi_ch);
+
+		/*
+		 * NOTE: docs don't guarantee any of this works...  we expect
+		 * that if the USB core stops telling the CPPI core to pull
+		 * more data from it, then it'll be safe to flush current Rx
+		 * DMA state iff any pending FIFO transfer is done.
+		 */
+
+		/* For host, ensure ReqPkt is never set again */
+		cppi41_autoreq_update(cppi_ch, USB_NO_AUTOREQ);
+
+		/* For host, clear (just) ReqPkt at end of current packet(s) */
+		if (is_host_active(cppi->musb))
+			csr &= ~MUSB_RXCSR_H_REQPKT;
+		csr |= MUSB_RXCSR_H_WZC_BITS;
+
+		/* Clear DMA enable */
+		csr &= ~MUSB_RXCSR_DMAENAB;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		/* Flush the FIFO of endpoint once again */
+		csr  = musb_readw(epio, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_H_WZC_BITS;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		udelay(50);
+	}
+
+	/*
+	 * There might be PDs in the Rx/Tx source queue that were not consumed
+	 * by the DMA controller -- they need to be recycled properly.
+	 */
+	while ((pd_addr = cppi41_queue_pop(&cppi_ch->queue_obj)) != 0) {
+		struct usb_pkt_desc *curr_pd;
+
+		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
+		if (curr_pd == NULL) {
+			ERR("Invalid PD popped from source queue\n");
+			continue;
+		}
+
+		/*
+		 * Return Rx/Tx PDs to the software list --
+		 * this is protected by critical section.
+		 */
+		dprintk("Returning PD %p to the free PD list\n", curr_pd);
+		usb_put_free_pd(cppi, curr_pd);
+	}
+
+#ifdef DEBUG_CPPI_TD
+	printk("After teardown:");
+	print_pd_list(cppi->pd_pool_head);
+#endif
+
+	/* Re-enable the DMA channel */
+	cppi41_dma_ch_enable(&cppi_ch->dma_ch_obj);
+
+	channel->status = MUSB_DMA_STATUS_FREE;
+
+	return 0;
+}
+
+/**
+ * dma_controller_create - instantiate an object representing DMA controller.
+ */
+struct dma_controller * __init dma_controller_create(struct musb  *musb,
+						     void __iomem *mregs)
+{
+	struct cppi41 *cppi;
+
+	cppi = kzalloc(sizeof *cppi, GFP_KERNEL);
+	if (!cppi)
+		return NULL;
+
+	/* Initialize the CPPI 4.1 DMA controller structure */
+	cppi->musb  = musb;
+	cppi->controller.start = cppi41_controller_start;
+	cppi->controller.stop  = cppi41_controller_stop;
+	cppi->controller.channel_alloc = cppi41_channel_alloc;
+	cppi->controller.channel_release = cppi41_channel_release;
+	cppi->controller.channel_program = cppi41_channel_program;
+	cppi->controller.channel_abort = cppi41_channel_abort;
+
+	return &cppi->controller;
+}
+
+/**
+ * dma_controller_destroy - destroy a previously instantiated DMA controller
+ * @controller: the controller
+ */
+void dma_controller_destroy(struct dma_controller *controller)
+{
+	struct cppi41 *cppi;
+
+	cppi = container_of(controller, struct cppi41, controller);
+
+	/* Free the CPPI object */
+	kfree(cppi);
+}
+
+static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index)
+{
+	struct cppi41_queue_obj tx_queue_obj;
+	unsigned long pd_addr;
+
+	if (cppi41_queue_init(&tx_queue_obj, usb_cppi41_info.q_mgr,
+			      usb_cppi41_info.tx_comp_q[index])) {
+		DBG(1, "ERROR: cppi41_queue_init failed for "
+		    "Tx completion queue");
+		return;
+	}
+
+	while ((pd_addr = cppi41_queue_pop(&tx_queue_obj)) != 0) {
+		struct usb_pkt_desc *curr_pd;
+		struct cppi41_channel *tx_ch;
+		u8 ch_num, ep_num;
+		u32 length;
+
+		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
+		if (curr_pd == NULL) {
+			ERR("Invalid PD popped from Tx completion queue\n");
+			continue;
+		}
+
+		/* Extract the data from received packet descriptor */
+		ch_num = curr_pd->ch_num;
+		ep_num = curr_pd->ep_num;
+		length = curr_pd->hw_desc.buf_len;
+
+		tx_ch = &cppi->tx_cppi_ch[ch_num];
+		tx_ch->channel.actual_len += length;
+
+		/*
+		 * Return Tx PD to the software list --
+		 * this is protected by critical section
+		 */
+		usb_put_free_pd(cppi, curr_pd);
+
+		if ((tx_ch->curr_offset < tx_ch->length) ||
+		    (tx_ch->transfer_mode && !tx_ch->zlp_queued))
+			cppi41_next_tx_segment(tx_ch);
+		else if (tx_ch->channel.actual_len >= tx_ch->length) {
+			tx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+			/*
+			 * We get Tx DMA completion interrupt even when
+			 * data is still in FIFO and not moved out to
+			 * USB bus. As we program the next request we
+			 * flush out and old data in FIFO which affects
+			 * USB functionality. So far, we have obsered
+			 * failure with iperf.
+			 */
+			/* Tx completion routine callback */
+			musb_dma_completion(cppi->musb, ep_num, 1);
+		}
+	}
+}
+
+static void usb_process_rx_queue(struct cppi41 *cppi, unsigned index)
+{
+	struct cppi41_queue_obj rx_queue_obj;
+	unsigned long pd_addr;
+
+	if (cppi41_queue_init(&rx_queue_obj, usb_cppi41_info.q_mgr,
+			      usb_cppi41_info.rx_comp_q[index])) {
+		DBG(1, "ERROR: cppi41_queue_init failed for Rx queue\n");
+		return;
+	}
+
+	while ((pd_addr = cppi41_queue_pop(&rx_queue_obj)) != 0) {
+		struct usb_pkt_desc *curr_pd;
+		struct cppi41_channel *rx_ch;
+		u8 ch_num, ep_num;
+		u32 length;
+
+		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
+		if (curr_pd == NULL) {
+			ERR("Invalid PD popped from Rx completion queue\n");
+			continue;
+		}
+
+		/* Extract the data from received packet descriptor */
+		ch_num = curr_pd->ch_num;
+		ep_num = curr_pd->ep_num;
+		length = curr_pd->hw_desc.buf_len;
+
+		rx_ch = &cppi->rx_cppi_ch[ch_num];
+		rx_ch->channel.actual_len += length;
+
+		if (curr_pd->eop) {
+			curr_pd->eop = 0;
+			/* disable the rx dma schedular */
+			if (is_peripheral_active(cppi->musb)) {
+				/* disable the rx dma schedular  */
+				cppi41_schedtbl_remove_dma_ch(0, 0, ch_num,
+					CPPI41_DMACH_RX_DIR);
+				musb_dma_completion(cppi->musb, ep_num, 0);
+			}
+		}
+
+		/*
+		 * Return Rx PD to the software list --
+		 * this is protected by critical section
+		 */
+		usb_put_free_pd(cppi, curr_pd);
+
+		if (unlikely(rx_ch->channel.actual_len >= rx_ch->length ||
+			     length < curr_pd->hw_desc.orig_buf_len)) {
+			rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+			/* Rx completion routine callback */
+			musb_dma_completion(cppi->musb, ep_num, 0);
+		} else {
+			if (is_peripheral_active(cppi->musb) &&
+				((rx_ch->length - rx_ch->curr_offset) > 0))
+				cppi41_next_rx_segment(rx_ch);
+		}
+	}
+}
+
+/*
+ * cppi41_completion - handle interrupts from the Tx/Rx completion queues
+ *
+ * NOTE: since we have to manually prod the Rx process in the transparent mode,
+ *	 we certainly want to handle the Rx queues first.
+ */
+void cppi41_completion(struct musb *musb, u32 rx, u32 tx)
+{
+	struct cppi41 *cppi;
+	unsigned index;
+
+	cppi = container_of(musb->dma_controller, struct cppi41, controller);
+
+	/* Process packet descriptors from the Rx queues */
+	for (index = 0; rx != 0; rx >>= 1, index++)
+		if (rx & 1)
+			usb_process_rx_queue(cppi, index);
+
+	/* Process packet descriptors from the Tx completion queues */
+	for (index = 0; tx != 0; tx >>= 1, index++)
+		if (tx & 1)
+			usb_process_tx_queue(cppi, index);
+}
diff --git a/drivers/usb/musb/cppi41_dma.h b/drivers/usb/musb/cppi41_dma.h
new file mode 100644
index 0000000..f20e195
--- /dev/null
+++ b/drivers/usb/musb/cppi41_dma.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (c) 2008, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This program is free software; you can distribute it and/or modify it
+ * under the terms of the GNU General Public License (Version 2) as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _CPPI41_DMA_H_
+#define _CPPI41_DMA_H_
+
+#define USB_CPPI41_NUM_CH 4
+
+#ifdef CONFIG_ARCH_DAVINCI_DA8XX
+#include "da8xx.h"
+#endif
+
+/**
+ * struct usb_cppi41_info - CPPI 4.1 USB implementation details
+ * @dma_block:	DMA block number
+ * @ep_dma_ch:	DMA channel numbers used for EPs 1 .. Max_EP
+ * @q_mgr:	queue manager number
+ * @num_tx_comp_q: number of the Tx completion queues
+ * @num_rx_comp_q: number of the Rx queues
+ * @tx_comp_q:	pointer to the list of the Tx completion queue numbers
+ * @rx_comp_q:	pointer to the list of the Rx queue numbers
+ */
+struct usb_cppi41_info {
+	u8 dma_block;
+	u8 ep_dma_ch[USB_CPPI41_NUM_CH];
+	u8 q_mgr;
+	u8 num_tx_comp_q;
+	u8 num_rx_comp_q;
+	const u16 *tx_comp_q;
+	const u16 *rx_comp_q;
+};
+
+extern const struct usb_cppi41_info usb_cppi41_info;
+
+/**
+ * cppi41_completion - Tx/Rx completion queue interrupt handling hook
+ * @musb:	the controller
+ * @rx:	bitmask having bit N set if Rx queue N is not empty
+ * @tx:	bitmask having bit N set if Tx completion queue N is not empty
+ */
+void cppi41_completion(struct musb *musb, u32 rx, u32 tx);
+
+/**
+ * cppi41_disable_sched_rx
+ */
+int cppi41_disable_sched_rx(void);
+
+/**
+ * cppi41_enable_sched_rx
+ */
+int cppi41_enable_sched_rx(void);
+#endif	/* _CPPI41_DMA_H_ */
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index cd6bae0..829815c 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1596,7 +1596,7 @@ void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit)
 
 	if (!epnum) {
 #ifndef CONFIG_USB_TUSB_OMAP_DMA
-		if (!is_cppi_enabled()) {
+		if (!is_cppi_enabled() && !is_cppi41_enabled()) {
 			/* endpoint 0 */
 			if (devctl & MUSB_DEVCTL_HM)
 				musb_h_ep0_irq(musb);
@@ -2408,6 +2408,8 @@ static int __init musb_init(void)
 		"pio"
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 		"cppi-dma"
+#elif defined(CONFIG_USB_TI_CPPI41_DMA)
+		"cppi4.1-dma"
 #elif defined(CONFIG_USB_INVENTRA_DMA)
 		"musb-dma"
 #elif defined(CONFIG_USB_TUSB_OMAP_DMA)
diff --git a/drivers/usb/musb/musb_dma.h b/drivers/usb/musb/musb_dma.h
index 916065b..6d40dee 100644
--- a/drivers/usb/musb/musb_dma.h
+++ b/drivers/usb/musb/musb_dma.h
@@ -74,6 +74,12 @@ struct musb_hw_ep;
 #define	is_cppi_enabled()	0
 #endif
 
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+#define is_cppi41_enabled()     1
+#else
+#define is_cppi41_enabled()     0
+#endif
+
 #ifdef CONFIG_USB_TUSB_OMAP_DMA
 #define tusb_dma_omap()			1
 #else
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 6fca870..029199c 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -348,7 +348,7 @@ static void txstate(struct musb *musb, struct musb_request *req)
 			}
 		}
 
-#elif defined(CONFIG_USB_TI_CPPI_DMA)
+#elif defined(CONFIG_USB_TI_CPPI_DMA) || defined(CONFIG_USB_TI_CPPI41_DMA)
 		/* program endpoint CSR first, then setup DMA */
 		csr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);
 		csr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE |
@@ -586,7 +586,7 @@ static void rxstate(struct musb *musb, struct musb_request *req)
 		return;
 	}
 
-	if (is_cppi_enabled() && musb_ep->dma) {
+	if ((is_cppi_enabled() || is_cppi41_enabled()) && musb_ep->dma) {
 		struct dma_controller	*c = musb->dma_controller;
 		struct dma_channel	*channel = musb_ep->dma;
 
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 877d20b..44c70e4 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -176,7 +176,7 @@ static inline void musb_h_tx_dma_start(struct musb_hw_ep *ep)
 	/* NOTE: no locks here; caller should lock and select EP */
 	txcsr = musb_readw(ep->regs, MUSB_TXCSR);
 	txcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;
-	if (is_cppi_enabled())
+	if (is_cppi_enabled() || is_cppi41_enabled())
 		txcsr |= MUSB_TXCSR_DMAMODE;
 	musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 }
@@ -290,7 +290,8 @@ start:
 
 		if (!hw_ep->tx_channel)
 			musb_h_tx_start(hw_ep);
-		else if (is_cppi_enabled() || tusb_dma_omap())
+		else if (is_cppi_enabled() ||
+				tusb_dma_omap() || is_cppi41_enabled())
 			musb_h_tx_dma_start(hw_ep);
 	}
 }
@@ -646,7 +647,7 @@ static bool musb_tx_dma_program(struct dma_controller *dma,
 	channel->desired_mode = mode;
 	musb_writew(epio, MUSB_TXCSR, csr);
 #else
-	if (!is_cppi_enabled() && !tusb_dma_omap())
+	if (!is_cppi_enabled() && !tusb_dma_omap() && !is_cppi41_enabled())
 		return false;
 
 	channel->actual_len = 0;
@@ -832,7 +833,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 			csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 
 			if (csr & (MUSB_RXCSR_RXPKTRDY
-					| MUSB_RXCSR_DMAENAB
+				| (is_cppi_enabled() || is_cppi41_enabled())
+					? 0 : MUSB_RXCSR_DMAENAB
 					| MUSB_RXCSR_H_REQPKT))
 				ERR("broken !rx_reinit, ep%d csr %04x\n",
 						hw_ep->epnum, csr);
@@ -843,7 +845,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 
 		/* kick things off */
 
-		if ((is_cppi_enabled() || tusb_dma_omap()) && dma_channel) {
+		if ((is_cppi_enabled() || is_cppi41_enabled() ||
+				tusb_dma_omap()) && dma_channel) {
 			/* candidate for DMA */
 			if (dma_channel) {
 				dma_channel->actual_len = 0L;
@@ -1308,7 +1311,8 @@ void musb_host_tx(struct musb *musb, u8 epnum)
 	} else	if (usb_pipeisoc(pipe) && dma) {
 		if (musb_tx_dma_program(musb->dma_controller, hw_ep, qh, urb,
 				offset, length)) {
-			if (is_cppi_enabled() || tusb_dma_omap())
+			if (is_cppi_enabled() || tusb_dma_omap() ||
+					is_cppi41_enabled())
 				musb_h_tx_dma_start(hw_ep);
 			return;
 		}
@@ -1571,9 +1575,12 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			| MUSB_RXCSR_H_AUTOREQ
 			| MUSB_RXCSR_AUTOCLEAR
 			| MUSB_RXCSR_RXPKTRDY);
+
+		if (is_cppi_enabled() || is_cppi41_enabled())
+			val |= MUSB_RXCSR_DMAENAB;
+
 		musb_writew(hw_ep->regs, MUSB_RXCSR, val);
 
-#ifdef CONFIG_USB_INVENTRA_DMA
 		if (usb_pipeisoc(pipe)) {
 			struct usb_iso_packet_descriptor *d;
 
@@ -1588,8 +1595,25 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 
 			if (++qh->iso_idx >= urb->number_of_packets)
 				done = true;
-			else
+			else if (is_cppi_enabled() || is_cppi41_enabled()) {
+				struct dma_controller	*c;
+				void *buf;
+				u32 length, ret;
+
+				c = musb->dma_controller;
+				buf = (void *)
+					urb->iso_frame_desc[qh->iso_idx].offset
+					+ (u32)urb->transfer_dma;
+
+				length =
+					urb->iso_frame_desc[qh->iso_idx].length;
+
+				ret = c->channel_program(dma, qh->maxpacket,
+						0, (u32) buf, length);
 				done = false;
+			} else {
+				done = false;
+			}
 
 		} else  {
 		/* done if urb buffer is full or short packet is recd */
@@ -1609,9 +1633,6 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			done ? "off" : "reset",
 			musb_readw(epio, MUSB_RXCSR),
 			musb_readw(epio, MUSB_RXCOUNT));
-#else
-		done = true;
-#endif
 	} else if (urb->status == -EINPROGRESS) {
 		/* if no errors, be sure a packet is ready for unloading */
 		if (unlikely(!(rx_csr & MUSB_RXCSR_RXPKTRDY))) {
@@ -1629,7 +1650,6 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 		}
 
 		/* we are expecting IN packets */
-#ifdef CONFIG_USB_INVENTRA_DMA
 		if (dma) {
 			struct dma_controller	*c;
 			u16			rx_count;
@@ -1743,7 +1763,6 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 				/* REVISIT reset CSR */
 			}
 		}
-#endif	/* Mentor DMA */
 
 		if (!dma) {
 			done = musb_host_packet_rx(musb, urb,
-- 
1.6.5.2

