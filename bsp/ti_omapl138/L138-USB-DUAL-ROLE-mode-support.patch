From b9da10c0feca21736ecfc6e331b90363c806de16 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Fri, 13 Nov 2009 17:49:18 +0800
Subject: [PATCH 34/43] L138 USB DUAL ROLE mode support.

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.06.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

This is a workaround for USB OTG mode on L138, in which host mode and gadget mode are
enabled at the same time. Now there is still a bug in this solution. If the
L138 board booted without a usb disk plugged, it can't work in host mode at
first.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c |    2 +
 arch/arm/mach-davinci/devices.c         |    1 +
 drivers/usb/gadget/Kconfig              |    2 +-
 drivers/usb/musb/Kconfig                |   19 +++++++++++++--
 drivers/usb/musb/musb_core.c            |   36 +++++++++++++++++++++++++++---
 drivers/usb/musb/musb_core.h            |    4 +-
 drivers/usb/musb/musb_gadget.c          |    2 +-
 drivers/usb/musb/musb_virthub.c         |    3 +-
 include/linux/usb/musb.h                |    3 ++
 9 files changed, 60 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index 4c482c7..510e5b5 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -249,6 +249,8 @@ static struct musb_hdrc_platform_data usb_evm_data[] = {
        {
 #ifdef CONFIG_USB_MUSB_OTG
                .mode = MUSB_OTG,
+#elif defined(CONFIG_USB_MUSB_DUAL_ROLE)
+		.mode = MUSB_DUAL_ROLE,
 #elif defined(CONFIG_USB_MUSB_PERIPHERAL)
                .mode =  MUSB_PERIPHERAL,
 #elif defined(CONFIG_USB_MUSB_HOST)
diff --git a/arch/arm/mach-davinci/devices.c b/arch/arm/mach-davinci/devices.c
index 046ee67..32cb5d5 100644
--- a/arch/arm/mach-davinci/devices.c
+++ b/arch/arm/mach-davinci/devices.c
@@ -599,6 +599,7 @@ static int da8xx_usb_phy_config(struct device *dev, u8 mode, int is_on)
 				CFGCHIP2_PHY_PLLON | CFGCHIP2_REFFREQ_24MHZ;
 		switch (mode) {
 		case MUSB_OTG:
+		case MUSB_DUAL_ROLE:
 			cfgchip2 |= CFGCHIP2_NO_OVERRIDE;
 			break;
 		case MUSB_HOST:
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 222edf1..592981b 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -287,7 +287,7 @@ config USB_LH7A40X
 # built in ../musb along with host support
 config USB_GADGET_MUSB_HDRC
 	boolean "Inventra HDRC USB Peripheral (TI, ...)"
-	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG)
+	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
 	select USB_GADGET_DUALSPEED
 	select USB_GADGET_SELECTED
 	help
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 0e63059..1ecbf9e 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -86,6 +86,18 @@ config USB_MUSB_PERIPHERAL
 	  connector, it supports the peripheral role.
 	  (With a "Mini-AB" connector, you should enable USB OTG.)
 
+config USB_MUSB_DUAL_ROLE
+	depends on USB && USB_GADGET
+	bool "Both Host and Peripheral: Non-OTG Device"
+	help
+	   This config is for enabling support for Host, Device modes on
+	   single kernel image.  This differs from OTG config in not
+	   supporting HNP, SRP.  VBUS status is sensed perodically to switch
+	   to Host mode on reception of connect interrupt.  Products typically
+	   need this functionality were in the boards do not have the related
+	   OTG compliant circutry but rather support either Host or Device
+	   modes on the same Mini/Micro -AB port or on seperate A and B ports.
+
 config USB_MUSB_OTG
 	depends on USB && USB_GADGET && PM && EXPERIMENTAL
 	bool "Both host and peripheral:  USB OTG (On The Go) Device"
@@ -115,16 +127,17 @@ endchoice
 # enable peripheral support (including with OTG)
 config USB_GADGET_MUSB_HDRC
 	bool
-	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG)
+	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
 #	default y
 #	select USB_GADGET_DUALSPEED
 #	select USB_GADGET_SELECTED
+	default y if USB_MUSB_DUAL_ROLE
 
 # enables host support (including with OTG)
 config USB_MUSB_HDRC_HCD
 	bool
-	depends on USB_MUSB_HDRC && (USB_MUSB_HOST || USB_MUSB_OTG)
-	select USB_OTG if USB_GADGET_MUSB_HDRC
+	depends on USB_MUSB_HDRC && (USB_MUSB_HOST || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
+	select USB_OTG if (USB_GADGET_MUSB_HDRC && USB_MUSB_OTG)
 	default y
 
 
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 6ad7949..acd0de7 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -770,9 +770,19 @@ static irqreturn_t musb_stage2_irq(struct musb *musb, u8 int_usb,
 		case OTG_STATE_A_HOST:
 		case OTG_STATE_A_SUSPEND:
 			musb_root_disconnect(musb);
-			if (musb->a_wait_bcon != 0)
+			if (musb->a_wait_bcon != 0 && is_otg_enabled(musb))
 				musb_platform_try_idle(musb, jiffies
 					+ msecs_to_jiffies(musb->a_wait_bcon));
+
+			if (is_dr_enabled(musb)) {
+				void __iomem *mbase = musb->mregs;
+
+				devctl = musb_readb(mbase, MUSB_DEVCTL);
+				devctl &= ~MUSB_DEVCTL_SESSION;
+				musb_writeb(mbase, MUSB_DEVCTL, devctl);
+				musb->xceiv->state = OTG_STATE_B_IDLE;
+				musb_platform_try_idle(musb, 0);
+			}
 			break;
 #endif	/* HOST */
 #ifdef CONFIG_USB_MUSB_OTG
@@ -790,6 +800,8 @@ static irqreturn_t musb_stage2_irq(struct musb *musb, u8 int_usb,
 		case OTG_STATE_B_PERIPHERAL:
 		case OTG_STATE_B_IDLE:
 			musb_g_disconnect(musb);
+			if (is_dr_enabled(musb))
+				musb_platform_try_idle(musb, 0);
 			break;
 #endif	/* GADGET */
 		default:
@@ -886,7 +898,7 @@ void musb_start(struct musb *musb)
 	devctl = musb_readb(regs, MUSB_DEVCTL);
 	devctl &= ~MUSB_DEVCTL_SESSION;
 
-	if (is_otg_enabled(musb)) {
+	if (is_otg_enabled(musb) || is_dr_enabled(musb)) {
 		/* session started after:
 		 * (a) ID-grounded irq, host mode;
 		 * (b) vbus present/connect IRQ, peripheral mode;
@@ -1906,6 +1918,12 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 #else
 		goto bad_config;
 #endif
+	case MUSB_DUAL_ROLE:
+#ifdef CONFIG_USB_MUSB_DUAL_ROLE
+		break;
+#else
+		goto bad_config;
+#endif
 	case MUSB_OTG:
 #ifdef CONFIG_USB_MUSB_OTG
 		break;
@@ -2029,11 +2047,13 @@ bad_config:
 		hcd->power_budget = 2 * (plat->power ? : 250);
 	}
 
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* For the host-only role, we can activate right away.
 	 * (We expect the ID pin to be forcibly grounded!!)
 	 * Otherwise, wait till the gadget driver hooks up.
 	 */
-	if (!is_otg_enabled(musb) && is_host_enabled(musb)) {
+	if (is_otg_enabled(musb) || is_dr_enabled(musb) ||
+		is_host_enabled(musb)) {
 		MUSB_HST_MODE(musb);
 		musb->xceiv->default_a = 1;
 		musb->xceiv->state = OTG_STATE_A_IDLE;
@@ -2049,7 +2069,12 @@ bad_config:
 					& MUSB_DEVCTL_BDEVICE
 				? 'B' : 'A'));
 
-	} else /* peripheral is enabled */ {
+	}
+#endif
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* peripheral is enabled */
+	if (is_otg_enabled(musb) || is_dr_enabled(musb) ||
+		is_peripheral_enabled(musb)) {
 		MUSB_DEV_MODE(musb);
 		musb->xceiv->default_a = 0;
 		musb->xceiv->state = OTG_STATE_B_IDLE;
@@ -2064,6 +2089,7 @@ bad_config:
 			musb_readb(musb->mregs, MUSB_DEVCTL));
 
 	}
+#endif
 
 #ifdef CONFIG_SYSFS
 	status = device_create_file(dev, &dev_attr_mode);
@@ -2254,6 +2280,8 @@ static int __init musb_init(void)
 		", "
 #ifdef CONFIG_USB_MUSB_OTG
 		"otg (peripheral+host)"
+#elif defined(CONFIG_USB_MUSB_DUAL_ROLE)
+		"(host+peripheral)"
 #elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
 		"peripheral"
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 26179af..44575d3 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -64,9 +64,9 @@ struct musb_ep;
 #include "musb_host.h"
 
 
-#define is_dr_enabled(musb)		0
+#define	is_dr_enabled(musb)		((musb)->board_mode == MUSB_DUAL_ROLE)
 
-#ifdef CONFIG_USB_MUSB_OTG
+#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_DUAL_ROLE)
 
 #define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
 #define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 42f1eea..e217e5e 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -1730,7 +1730,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		 * hosts only see fully functional devices.
 		 */
 
-		if (!is_otg_enabled(musb))
+		if (!(is_otg_enabled(musb) || is_dr_enabled(musb)))
 			musb_start(musb);
 
 		otg_set_peripheral(musb->xceiv, &musb->g);
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 7e7900f..ed913cd 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -359,7 +359,8 @@ int musb_hub_control(
 			 * initialization logic, e.g. for OTG, or change any
 			 * logic relating to VBUS power-up.
 			 */
-			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
+			if (!((is_otg_enabled(musb) || is_dr_enabled(musb))
+				&& hcd->self.is_b_host))
 				musb_start(musb);
 			break;
 		case USB_PORT_FEAT_RESET:
diff --git a/include/linux/usb/musb.h b/include/linux/usb/musb.h
index 2da8219..ac3ebac 100644
--- a/include/linux/usb/musb.h
+++ b/include/linux/usb/musb.h
@@ -17,6 +17,9 @@ enum musb_mode {
 	MUSB_UNDEFINED = 0,
 	MUSB_HOST,		/* A or Mini-A connector */
 	MUSB_PERIPHERAL,	/* B or Mini-B connector */
+	MUSB_DUAL_ROLE,		/* Either A, B connector or Mini-AB connector.
+				 * Does not support OTG.
+				 */
 	MUSB_OTG		/* Mini-AB connector */
 };
 
-- 
1.6.5.2

