From f6578ff4b99c6ec4f772e041b9abc68bb537254e Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Fri, 13 Nov 2009 17:49:19 +0800
Subject: [PATCH 35/43] Add the support for SATA on L138

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.06.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

TI OMAP L138 has a built-in SATA controller with a single HBA port operating
in Advanced Host Controller Interface (AHCI) mode and is used to interface
to data storage devices at both 1.5 Gbits/second and 3.0 Gbits/second line
speeds.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c    |    6 +
 arch/arm/mach-davinci/devices.c            |   31 ++++
 arch/arm/mach-davinci/include/mach/da8xx.h |    1 +
 drivers/ata/Kconfig                        |    2 +-
 drivers/ata/Makefile                       |    3 +-
 drivers/ata/ahci.c                         |  210 +++++++++++++++++++++++++---
 include/linux/libata.h                     |    6 +
 7 files changed, 238 insertions(+), 21 deletions(-)

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index 510e5b5..364b0a3 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -354,6 +354,7 @@ EXPORT_SYMBOL(da850_lcd_hw_init);
 static __init void da850_evm_init(void)
 {
 	unsigned int *addr = IO_ADDRESS(DA8XX_CFGCHIP3);
+	int ret;
 
 	davinci_cfg_reg(DA850_UART2_RXD);
 	davinci_cfg_reg(DA850_UART2_TXD);
@@ -473,6 +474,11 @@ static __init void da850_evm_init(void)
 
 	da850_init_emac(&da850_evm_emac_pdata);
 	da8xx_usb_configure(usb_evm_data, ARRAY_SIZE(usb_evm_data));
+
+	ret = da8xx_register_sata();
+	if (ret)
+		pr_warning("da850_evm_init: sata registration failed: %d\n",
+				ret);
 }
 
 static __init void da850_evm_irq_init(void)
diff --git a/arch/arm/mach-davinci/devices.c b/arch/arm/mach-davinci/devices.c
index 32cb5d5..e10923b 100644
--- a/arch/arm/mach-davinci/devices.c
+++ b/arch/arm/mach-davinci/devices.c
@@ -440,6 +440,37 @@ void da8xx_init_rtc(void)
 
 /*-------------------------------------------------------------------------*/
 
+static struct resource da850_ahci_resources[] = {
+	{
+		.start  =       DA850_SATA_BASE,
+		.end    =       DA850_SATA_BASE + 0x1fff,
+		.flags  =       IORESOURCE_MEM,
+	},
+	{
+		.start  =       IRQ_DA850_SATAINT,
+		.flags  =       IORESOURCE_IRQ,
+	}
+};
+
+static int da850_ahci_data = 8;
+static struct platform_device da850_ahci_device = {
+	.name   =       "ahci",
+	.id     =       -1,
+	.dev    =       {
+		.platform_data = &da850_ahci_data,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.num_resources  =       ARRAY_SIZE(da850_ahci_resources),
+	.resource       =       da850_ahci_resources,
+};
+
+int __init da8xx_register_sata(void)
+{
+	return platform_device_register(&da850_ahci_device);
+}
+
+/*-------------------------------------------------------------------------*/
+
 static struct resource wdt_resources[] = {
 	{
 		.start	= 0x01c21c00,
diff --git a/arch/arm/mach-davinci/include/mach/da8xx.h b/arch/arm/mach-davinci/include/mach/da8xx.h
index 3be0c47..fb3d9fa 100644
--- a/arch/arm/mach-davinci/include/mach/da8xx.h
+++ b/arch/arm/mach-davinci/include/mach/da8xx.h
@@ -40,6 +40,7 @@ int get_async3_src(void);
 #ifdef CONFIG_USB_TI_CPPI41_DMA
 int cppi41_init(void);
 #endif
+int da8xx_register_sata(void);
 extern void da8xx_usb_configure(struct musb_hdrc_platform_data *pdata,
 					u8 num_inst);
 #endif
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 11c8c19..388449d 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -50,7 +50,7 @@ config SATA_PMP
 
 config SATA_AHCI
 	tristate "AHCI SATA support"
-	depends on PCI
+	depends on PCI || ARCH_DA850
 	help
 	  This option enables support for AHCI Serial ATA.
 
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index 674965f..a102d4a 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -79,7 +79,8 @@ obj-$(CONFIG_ATA_GENERIC)	+= ata_generic.o
 # Should be last libata driver
 obj-$(CONFIG_PATA_LEGACY)	+= pata_legacy.o
 
-libata-objs	:= libata-core.o libata-scsi.o libata-eh.o
+libata-objs	:= libata-core.o libata-scsi.o libata-eh.o ahci-platform.o
+
 libata-$(CONFIG_ATA_SFF)	+= libata-sff.o
 libata-$(CONFIG_SATA_PMP)	+= libata-pmp.o
 libata-$(CONFIG_ATA_ACPI)	+= libata-acpi.o
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 2e1a7cb..4fcc9db 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -34,7 +34,9 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#ifdef CONFIG_PCI
 #include <linux/pci.h>
+#endif
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
@@ -45,6 +47,11 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
 #include <linux/libata.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/cpu.h>
+#include <mach/da8xx.h>
 
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
@@ -97,7 +104,7 @@ enum {
 	board_ahci_sb700	= 5,
 	board_ahci_mcp65	= 6,
 	board_ahci_nopmp	= 7,
-
+	board_ahci_da850	= 9,
 	/* global controller registers */
 	HOST_CAP		= 0x00, /* host capabilities */
 	HOST_CTL		= 0x04, /* global host control */
@@ -248,6 +255,8 @@ struct ahci_host_priv {
 	u32			saved_cap;	/* saved initial cap */
 	u32			saved_port_map;	/* saved initial port_map */
 	u32 			em_loc; /* enclosure management location */
+	void			*base;
+	u32			irq;
 };
 
 struct ahci_port_priv {
@@ -269,7 +278,11 @@ struct ahci_port_priv {
 
 static int ahci_scr_read(struct ata_port *ap, unsigned int sc_reg, u32 *val);
 static int ahci_scr_write(struct ata_port *ap, unsigned int sc_reg, u32 val);
+#ifdef CONFIG_PCI
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
+#else
+static int ahci_init_one(struct platform_device *pdev);
+#endif
 static unsigned int ahci_qc_issue(struct ata_queued_cmd *qc);
 static bool ahci_qc_fill_rtf(struct ata_queued_cmd *qc);
 static int ahci_port_start(struct ata_port *ap);
@@ -287,8 +300,10 @@ static int ahci_hardreset(struct ata_link *link, unsigned int *class,
 			  unsigned long deadline);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
+#ifdef CONFIG_PCI
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline);
+#endif
 static void ahci_postreset(struct ata_link *link, unsigned int *class);
 static void ahci_error_handler(struct ata_port *ap);
 static void ahci_post_internal_cmd(struct ata_queued_cmd *qc);
@@ -297,7 +312,7 @@ static void ahci_dev_config(struct ata_device *dev);
 static unsigned int ahci_fill_sg(struct ata_queued_cmd *qc, void *cmd_tbl);
 static void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			       u32 opts);
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && defined(CONFIG_PCI)
 static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
 static int ahci_pci_device_resume(struct pci_dev *pdev);
@@ -357,7 +372,7 @@ static struct ata_port_operations ahci_ops = {
 	.em_store		= ahci_led_store,
 	.sw_activity_show	= ahci_activity_show,
 	.sw_activity_store	= ahci_activity_store,
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && defined(CONFIG_PCI)
 	.port_suspend		= ahci_port_suspend,
 	.port_resume		= ahci_port_resume,
 #endif
@@ -370,10 +385,12 @@ static struct ata_port_operations ahci_vt8251_ops = {
 	.hardreset		= ahci_vt8251_hardreset,
 };
 
+#ifdef CONFIG_PCI
 static struct ata_port_operations ahci_p5wdh_ops = {
 	.inherits		= &ahci_ops,
 	.hardreset		= ahci_p5wdh_hardreset,
 };
+#endif
 
 static struct ata_port_operations ahci_sb600_ops = {
 	.inherits		= &ahci_ops,
@@ -451,8 +468,17 @@ static const struct ata_port_info ahci_port_info[] = {
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_ops,
 	},
+	/* board_ahci_yesncq */
+	{
+		AHCI_HFLAGS	(AHCI_HFLAG_YES_NCQ),
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= 0x1f, /* pio0-4 */
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
 };
 
+#ifdef CONFIG_PCI
 static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Intel */
 	{ PCI_VDEVICE(INTEL, 0x2652), board_ahci }, /* ICH6 */
@@ -605,6 +631,7 @@ static struct pci_driver ahci_pci_driver = {
 	.resume			= ahci_pci_device_resume,
 #endif
 };
+#endif
 
 static int ahci_em_messages = 1;
 module_param(ahci_em_messages, int, 0444);
@@ -629,8 +656,11 @@ static inline int ahci_nr_ports(u32 cap)
 static inline void __iomem *__ahci_port_base(struct ata_host *host,
 					     unsigned int port_no)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
-
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	return mmio + 0x100 + (port_no * 0x80);
 }
 
@@ -679,13 +709,21 @@ static void ahci_enable_ahci(void __iomem *mmio)
  *	LOCKING:
  *	None.
  */
+#ifdef CONFIG_PCI
 static void ahci_save_initial_config(struct pci_dev *pdev,
+#else
+static void ahci_save_initial_config(struct platform_device *pdev,
+#endif
 				     struct ahci_host_priv *hpriv)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+	int mv;
+#else
+	void __iomem *mmio = hpriv->base;
+#endif
 	u32 cap, port_map;
 	int i;
-	int mv;
 
 	/* make sure AHCI mode is enabled before accessing CAP */
 	ahci_enable_ahci(mmio);
@@ -720,7 +758,7 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 			   "controller can't do PMP, turning off CAP_PMP\n");
 		cap &= ~HOST_CAP_PMP;
 	}
-
+#ifdef CONFIG_PCI
 	if (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361 &&
 	    port_map != 1) {
 		dev_printk(KERN_INFO, &pdev->dev,
@@ -748,6 +786,7 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 
 		port_map &= mv;
 	}
+#endif
 
 	/* cross check port_map and cap.n_ports */
 	if (port_map) {
@@ -796,8 +835,11 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 static void ahci_restore_initial_config(struct ata_host *host)
 {
 	struct ahci_host_priv *hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
-
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	writel(hpriv->saved_cap, mmio + HOST_CAP);
 	writel(hpriv->saved_port_map, mmio + HOST_PORTS_IMPL);
 	(void) readl(mmio + HOST_PORTS_IMPL);	/* flush */
@@ -1068,7 +1110,7 @@ static int ahci_enable_alpm(struct ata_port *ap,
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && defined(CONFIG_PCI)
 static void ahci_power_down(struct ata_port *ap)
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
@@ -1139,9 +1181,13 @@ static int ahci_deinit_port(struct ata_port *ap, const char **emsg)
 
 static int ahci_reset_controller(struct ata_host *host)
 {
-	struct pci_dev *pdev = to_pci_dev(host->dev);
+#ifdef CONFIG_PCI
 	struct ahci_host_priv *hpriv = host->private_data;
+	struct pci_dev *pdev = to_pci_dev(host->dev);
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 tmp;
 
 	/* we must be in AHCI mode, before using anything
@@ -1182,7 +1228,7 @@ static int ahci_reset_controller(struct ata_host *host)
 	} else
 		dev_printk(KERN_INFO, host->dev,
 			   "skipping global host reset\n");
-
+#ifdef CONFIG_PCI
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		u16 tmp16;
 
@@ -1193,7 +1239,7 @@ static int ahci_reset_controller(struct ata_host *host)
 			pci_write_config_word(pdev, 0x92, tmp16);
 		}
 	}
-
+#endif
 	return 0;
 }
 
@@ -1269,7 +1315,11 @@ static void ahci_init_sw_activity(struct ata_link *link)
 
 static int ahci_reset_em(struct ata_host *host)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 em_ctl;
 
 	em_ctl = readl(mmio + HOST_EM_CTL);
@@ -1285,7 +1335,11 @@ static ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
 	struct ahci_port_priv *pp = ap->private_data;
+#ifdef CONFIG_PCI
 	void __iomem *mmio = ap->host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)ap->host->iomap;
+#endif
 	u32 em_ctl;
 	u32 message[] = {0, 0};
 	unsigned long flags;
@@ -1420,8 +1474,11 @@ static ssize_t ahci_activity_show(struct ata_device *dev, char *buf)
 	 */
 	return sprintf(buf, "%d\n", emp->blink_policy);
 }
-
+#ifdef CONFIG_PCI
 static void ahci_port_init(struct pci_dev *pdev, struct ata_port *ap,
+#else
+static void ahci_port_init(struct platform_device *pdev, struct ata_port *ap,
+#endif
 			   int port_no, void __iomem *mmio,
 			   void __iomem *port_mmio)
 {
@@ -1451,12 +1508,18 @@ static void ahci_port_init(struct pci_dev *pdev, struct ata_port *ap,
 
 static void ahci_init_controller(struct ata_host *host)
 {
+#ifdef CONFIG_PCI
 	struct ahci_host_priv *hpriv = host->private_data;
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	struct platform_device *pdev = to_platform_device(host->dev);
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	int i;
 	void __iomem *port_mmio;
 	u32 tmp;
+#ifdef CONFIG_PCI
 	int mv;
 
 	if (hpriv->flags & AHCI_HFLAG_MV_PATA) {
@@ -1474,7 +1537,7 @@ static void ahci_init_controller(struct ata_host *host)
 		if (tmp)
 			writel(tmp, port_mmio + PORT_IRQ_STAT);
 	}
-
+#endif
 	for (i = 0; i < host->n_ports; i++) {
 		struct ata_port *ap = host->ports[i];
 
@@ -1787,6 +1850,7 @@ static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 	return online ? -EAGAIN : rc;
 }
 
+#ifdef CONFIG_PCI
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline)
 {
@@ -1830,6 +1894,7 @@ static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 	}
 	return rc;
 }
+#endif
 
 static void ahci_postreset(struct ata_link *link, unsigned int *class)
 {
@@ -2087,7 +2152,11 @@ static irqreturn_t ahci_interrupt(int irq, void *dev_instance)
 	VPRINTK("ENTER\n");
 
 	hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	mmio = (void __iomem *)host->iomap;
+#endif
 
 	/* sigh.  0xffffffff is a valid return from h/w */
 	irq_stat = readl(mmio + HOST_IRQ_STAT);
@@ -2176,7 +2245,11 @@ static void ahci_freeze(struct ata_port *ap)
 
 static void ahci_thaw(struct ata_port *ap)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = ap->host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)ap->host->iomap;
+#endif
 	void __iomem *port_mmio = ahci_port_base(ap);
 	u32 tmp;
 	struct ahci_port_priv *pp = ap->private_data;
@@ -2251,7 +2324,7 @@ static int ahci_port_resume(struct ata_port *ap)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && defined(COFNIG_PCI)
 static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 {
 	const char *emsg = NULL;
@@ -2271,7 +2344,11 @@ static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
 	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = host->iomap;
+#endif
 	u32 ctl;
 
 	if (mesg.event & PM_EVENT_SLEEP) {
@@ -2377,6 +2454,7 @@ static void ahci_port_stop(struct ata_port *ap)
 		ata_port_printk(ap, KERN_WARNING, "%s (%d)\n", emsg, rc);
 }
 
+#ifdef CONFIG_PCI
 static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 {
 	int rc;
@@ -2408,15 +2486,21 @@ static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 	}
 	return 0;
 }
+#endif
 
 static void ahci_print_info(struct ata_host *host)
 {
 	struct ahci_host_priv *hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+	u16 cc;
+#else
+	struct platform_device *pdev = to_platform_device(host->dev);
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 vers, cap, impl, speed;
 	const char *speed_s;
-	u16 cc;
 	const char *scc_s;
 
 	vers = readl(mmio + HOST_VERSION);
@@ -2431,6 +2515,7 @@ static void ahci_print_info(struct ata_host *host)
 	else
 		speed_s = "?";
 
+#ifdef CONFIG_PCI
 	pci_read_config_word(pdev, 0x0a, &cc);
 	if (cc == PCI_CLASS_STORAGE_IDE)
 		scc_s = "IDE";
@@ -2440,6 +2525,10 @@ static void ahci_print_info(struct ata_host *host)
 		scc_s = "RAID";
 	else
 		scc_s = "unknown";
+#else
+	if (cpu_is_da850())
+		scc_s = "SATA";
+#endif
 
 	dev_printk(KERN_INFO, &pdev->dev,
 		"AHCI %02x%02x.%02x%02x "
@@ -2483,6 +2572,7 @@ static void ahci_print_info(struct ata_host *host)
 		);
 }
 
+#ifdef CONFIG_PCI
 /* On ASUS P5W DH Deluxe, the second port of PCI device 00:1f.2 is
  * hardwired to on-board SIMG 4726.  The chipset is ICH8 and doesn't
  * support PMP and the 4726 either directly exports the device
@@ -2527,17 +2617,26 @@ static void ahci_p5wdh_workaround(struct ata_host *host)
 		ap->link.flags |= ATA_LFLAG_NO_SRST | ATA_LFLAG_ASSUME_ATA;
 	}
 }
-
+#endif
+#ifdef CONFIG_PCI
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	static int printed_version;
 	unsigned int board_id = ent->driver_data;
 	struct ata_port_info pi = ahci_port_info[board_id];
+#else
+static int ahci_init_one(struct platform_device *pdev)
+{
+	unsigned int board_id = *(int *)pdev->dev.platform_data;
+	struct ata_port_info pi = ahci_port_info[board_id];
+	struct resource *res;
+#endif
+	static int printed_version;
 	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct device *dev = &pdev->dev;
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
 	int n_ports, i, rc;
+	struct clk    *clock;
 
 	VPRINTK("ENTER\n");
 
@@ -2546,6 +2645,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
 
+#ifdef CONFIG_PCI
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
 	   can drive them all so if both drivers are selected make sure
 	   AHCI stays out of the way */
@@ -2581,12 +2681,14 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			return -ENODEV;
 		}
 	}
+#endif
 
 	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
 	if (!hpriv)
 		return -ENOMEM;
 	hpriv->flags |= (unsigned long)pi.private_data;
 
+#ifdef CONFIG_PCI
 	/* MCP65 revision A1 and A2 can't do MSI */
 	if (board_id == board_ahci_mcp65 &&
 	    (pdev->revision == 0xa1 || pdev->revision == 0xa2))
@@ -2594,6 +2696,34 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	if ((hpriv->flags & AHCI_HFLAG_NO_MSI) || pci_enable_msi(pdev))
 		pci_intx(pdev, 1);
+#else
+	/*
+	 * Get the register base first
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	hpriv->base = devm_ioremap(&pdev->dev, res->start,
+				   res->end - res->start + 1);
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_printk(KERN_INFO, &pdev->dev, ": no irq\n");
+		return -ENODEV;
+	}
+
+	hpriv->irq = res->start;
+	clock =	clk_get(NULL, DRV_NAME);
+	if (IS_ERR(clock))
+		return PTR_ERR(clock);
+
+	if (clk_enable(clock) < 0)
+		return -ENODEV;
+
+	/* Call platform specific init*/
+	ata_plat_init(hpriv->base);
+
+#endif
 
 	/* save initial config */
 	ahci_save_initial_config(pdev, hpriv);
@@ -2607,7 +2737,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	if (ahci_em_messages && (hpriv->cap & HOST_CAP_EMS)) {
 		u8 messages;
+#ifdef CONFIG_PCI
 		void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+#else
+		void __iomem *mmio = hpriv->base;
+#endif
 		u32 em_loc = readl(mmio + HOST_EM_LOC);
 		u32 em_ctl = readl(mmio + HOST_EM_CTL);
 
@@ -2633,7 +2767,12 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
 	if (!host)
 		return -ENOMEM;
+#ifdef CONFIG_PCI
 	host->iomap = pcim_iomap_table(pdev);
+#else
+	host->iomap = hpriv->base;
+	host->clock = clock;
+#endif
 	host->private_data = hpriv;
 
 	if (pi.flags & ATA_FLAG_EM)
@@ -2641,11 +2780,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	for (i = 0; i < host->n_ports; i++) {
 		struct ata_port *ap = host->ports[i];
-
+#ifdef CONFIG_PCI
 		ata_port_pbar_desc(ap, AHCI_PCI_BAR, -1, "abar");
 		ata_port_pbar_desc(ap, AHCI_PCI_BAR,
 				   0x100 + ap->port_no * 0x80, "port");
-
+#endif
 		/* set initial link pm policy */
 		ap->pm_policy = NOT_AVAILABLE;
 
@@ -2659,6 +2798,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			ap->ops = &ata_dummy_port_ops;
 	}
 
+#ifdef CONFIG_PCI
 	/* apply workaround for ASUS P5W DH Deluxe mainboard */
 	ahci_p5wdh_workaround(host);
 
@@ -2666,6 +2806,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	rc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);
 	if (rc)
 		return rc;
+#endif
 
 	rc = ahci_reset_controller(host);
 	if (rc)
@@ -2673,27 +2814,58 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	ahci_init_controller(host);
 	ahci_print_info(host);
+	host->ops = pi.port_ops;
+	if (readl(hpriv->base + PORT_SCR_CTL) & 0x1)
+		writel(0, hpriv->base + PORT_SCR_CTL);
 
+#ifdef CONFIG_PCI
 	pci_set_master(pdev);
 	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
 				 &ahci_sht);
+#else
+	return ata_host_activate(host, hpriv->irq, ahci_interrupt, IRQF_SHARED,
+				 &ahci_sht);
+#endif
 }
 
+
+
+static struct platform_driver ahci_platform_driver = {
+	.probe			= ahci_init_one,
+	.driver			= {
+					.name = DRV_NAME,
+					.owner = THIS_MODULE,
+				}
+};
+
 static int __init ahci_init(void)
 {
+	int rc = -ENODEV;
+
+#ifdef CONFIG_PCI
 	return pci_register_driver(&ahci_pci_driver);
+#else
+	rc = platform_driver_register(&ahci_platform_driver);
+	return rc;
+#endif
 }
 
 static void __exit ahci_exit(void)
 {
+#ifdef CONFIG_PCI
 	pci_unregister_driver(&ahci_pci_driver);
+#else
+	platform_driver_unregister(&ahci_platform_driver);
+#endif
 }
 
 
 MODULE_AUTHOR("Jeff Garzik");
 MODULE_DESCRIPTION("AHCI SATA low-level driver");
 MODULE_LICENSE("GPL");
+#ifdef CONFIG_PCI
 MODULE_DEVICE_TABLE(pci, ahci_pci_tbl);
+#endif
 MODULE_VERSION(DRV_VERSION);
 
 module_init(ahci_init);
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 25062ac..7d63402 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -495,6 +495,7 @@ struct ata_host {
 	acpi_handle		acpi_handle;
 #endif
 	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
+	struct clk		*clock;
 	struct ata_port		*ports[0];
 };
 
@@ -987,6 +988,11 @@ extern void ata_timing_merge(const struct ata_timing *,
 			     unsigned int);
 extern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);
 
+#ifndef CONFIG_PCI
+void ata_plat_init(void __iomem *base);
+void ata_plat_remove(struct ata_host *host);
+#endif
+
 /* PCI */
 #ifdef CONFIG_PCI
 struct pci_dev;
-- 
1.6.5.2

