From cf4c0b6d0d318441b5d5bb24c1265c23013ee2f5 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 5 Nov 2009 17:53:25 +0800
Subject: [PATCH 17/43] Frame Buffer driver for TI DA8xx/OMAP-L1xx

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.05.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add LCD controller (LCDC) driver for TI's DA8xx/OMAP-L1xx architecture.
LCDC specifications can be found at http://www.ti.com/litv/pdf/sprufm0a.

LCDC on DA8xx consists of two independent controllers, the Raster
Controller and the LCD Interface Display Driver (LIDD) controller.  LIDD
further supports character and graphic displays.

This patch adds support for the graphic display found on the DA850 based EVM.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c         |   56 ++
 arch/arm/mach-davinci/devices.c                 |   90 +++-
 arch/arm/mach-davinci/include/mach/da8xx_lcdc.h |   24 +
 drivers/video/Kconfig                           |   16 +
 drivers/video/Makefile                          |    1 +
 drivers/video/da8xx/Makefile                    |    2 +
 drivers/video/da8xx/da8xx_fb.c                  |  959 +++++++++++++++++++++++
 drivers/video/da8xx/da8xx_fb.h                  |  116 +++
 drivers/video/da8xx/da8xx_lcdc.h                |  111 +++
 drivers/video/da8xx/sharp_color.h               |   79 ++
 10 files changed, 1453 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-davinci/include/mach/da8xx_lcdc.h
 create mode 100644 drivers/video/da8xx/Makefile
 create mode 100644 drivers/video/da8xx/da8xx_fb.c
 create mode 100644 drivers/video/da8xx/da8xx_fb.h
 create mode 100644 drivers/video/da8xx/da8xx_lcdc.h
 create mode 100644 drivers/video/da8xx/sharp_color.h

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index fecf578..51eda99 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -52,6 +52,7 @@
 #include <mach/mmc.h>
 #include <mach/cp_intc.h>
 #include <mach/asp.h>
+#include <mach/da8xx_lcdc.h>
 
 #include "clock.h"
 
@@ -276,6 +277,61 @@ static void __init da850_map_io(void)
 	da850_init();
 }
 
+int da850_lcd_hw_init(void)
+{
+	int bl_gpio_num = DA850_LCD_BL_GPIO;
+	int pwr_gpio_num = DA850_LCD_POWER_GPIO;
+	int status;
+
+	status = gpio_request(bl_gpio_num, "lcd bl\n");
+	if (status < 0) {
+		printk(KERN_WARNING "ERROR can not open GPIO %d\n", bl_gpio_num);
+		return status;
+	}
+
+	status = gpio_request(pwr_gpio_num, "lcd pwr\n");
+	if (status < 0) {
+		printk(KERN_WARNING "ERROR can not open GPIO %d\n", pwr_gpio_num);
+		return status;
+	}
+
+	gpio_direction_output(bl_gpio_num, 0);
+	gpio_direction_output(pwr_gpio_num, 0);
+
+	/* disable lcd backlight */
+	gpio_set_value(bl_gpio_num, 0);
+
+	/* disable lcd power */
+	gpio_set_value(pwr_gpio_num, 0);
+
+	/* wait for sometime */
+	mdelay(3);
+
+	/* disable lcdc */
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DA8XX_LPSC_LCDCNTL, 0);
+
+	/* wait for sometime */
+	mdelay(1);
+
+	/* enable lcd power */
+	gpio_set_value(pwr_gpio_num, 1);
+
+	/* enable lcdc */
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DA8XX_LPSC_LCDCNTL, 1);
+
+	/* wait for sometime */
+	mdelay(3);
+
+	/* enable lcd backlight */
+	gpio_set_value(bl_gpio_num, 1);
+
+	gpio_free(bl_gpio_num);
+	gpio_free(pwr_gpio_num);
+
+	return 0;
+}
+EXPORT_SYMBOL(da850_lcd_hw_init);
+
 static __init void da850_evm_init(void)
 {
 	unsigned int *addr = IO_ADDRESS(DA8XX_CFGCHIP3);
diff --git a/arch/arm/mach-davinci/devices.c b/arch/arm/mach-davinci/devices.c
index d0906e3..7903808 100644
--- a/arch/arm/mach-davinci/devices.c
+++ b/arch/arm/mach-davinci/devices.c
@@ -28,6 +28,7 @@
 #include <mach/cpu.h>
 #include <mach/mux.h>
 #include <mach/mmc.h>
+#include <mach/da8xx_lcdc.h>
 #include <mach/da8xx.h>
 
 #include "clock.h"
@@ -351,10 +352,97 @@ static void davinci_init_wdt(void)
 		platform_device_register(&davinci_wdt_device);
 }
 
+/*-------------------------------------------------------------------------*/
+static struct da8xx_lcdc_platform_data da8xx_evm_lcdc_pdata = {
+	.lcdc_clk_name  = "lcdc",
+};
+static struct resource da8xx_lcdc_resources[] = {
+	[0] = {	/* registers */
+		.start	= DA8XX_LCD_CNTRL_BASE,
+		.end	= DA8XX_LCD_CNTRL_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+/* XXX Next resource seems wrong.  Should use dma_* calls? -- Remove */
+	[1] = {	/* frame buffer and palette */
+		.start	= DA8XX_EMIF30_ASYNC_DATA_CE5_BASE,
+		.end	= DA8XX_EMIF30_ASYNC_DATA_CE5_BASE + SZ_512M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+/* END Remove */
+	[2] = {	/* interrupt */
+		.start	= IRQ_DA8XX_LCDINT,
+		.end	= IRQ_DA8XX_LCDINT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_lcdc_device = {
+	.name		= "da8xx_lcdc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(da8xx_lcdc_resources),
+	.resource	= da8xx_lcdc_resources,
+	.dev = {
+		.platform_data = &da8xx_evm_lcdc_pdata,
+	}
+};
+
 static int __init davinci_init_devices(void)
 {
-	davinci_init_wdt();
+	int ret;
 
+	davinci_init_wdt();
+	if (cpu_is_da8xx()) {
+		ret = platform_device_register(&da8xx_lcdc_device);
+
+		if (ret)
+			return ret;
+		else if (cpu_is_da830()) {
+			davinci_cfg_reg(DA830_LCD_D_0);
+			davinci_cfg_reg(DA830_LCD_D_1);
+			davinci_cfg_reg(DA830_LCD_D_2);
+			davinci_cfg_reg(DA830_LCD_D_3);
+			davinci_cfg_reg(DA830_LCD_D_4);
+			davinci_cfg_reg(DA830_LCD_D_5);
+			davinci_cfg_reg(DA830_LCD_D_6);
+			davinci_cfg_reg(DA830_LCD_D_7);
+			davinci_cfg_reg(DA830_LCD_D_8);
+			davinci_cfg_reg(DA830_LCD_D_9);
+			davinci_cfg_reg(DA830_LCD_D_10);
+			davinci_cfg_reg(DA830_LCD_D_11);
+			davinci_cfg_reg(DA830_LCD_D_12);
+			davinci_cfg_reg(DA830_LCD_D_13);
+			davinci_cfg_reg(DA830_LCD_D_14);
+			davinci_cfg_reg(DA830_LCD_D_15);
+			davinci_cfg_reg(DA830_LCD_PCLK);
+			davinci_cfg_reg(DA830_LCD_HSYNC);
+			davinci_cfg_reg(DA830_LCD_VSYNC);
+			davinci_cfg_reg(DA830_NLCD_AC_ENB_CS);
+			davinci_cfg_reg(DA830_LCD_MCLK);
+		} else if (cpu_is_da850()) {
+			davinci_cfg_reg(DA850_LCD_D_0);
+			davinci_cfg_reg(DA850_LCD_D_1);
+			davinci_cfg_reg(DA850_LCD_D_2);
+			davinci_cfg_reg(DA850_LCD_D_3);
+			davinci_cfg_reg(DA850_LCD_D_4);
+			davinci_cfg_reg(DA850_LCD_D_5);
+			davinci_cfg_reg(DA850_LCD_D_6);
+			davinci_cfg_reg(DA850_LCD_D_7);
+			davinci_cfg_reg(DA850_LCD_D_8);
+			davinci_cfg_reg(DA850_LCD_D_9);
+			davinci_cfg_reg(DA850_LCD_D_10);
+			davinci_cfg_reg(DA850_LCD_D_11);
+			davinci_cfg_reg(DA850_LCD_D_12);
+			davinci_cfg_reg(DA850_LCD_D_13);
+			davinci_cfg_reg(DA850_LCD_D_14);
+			davinci_cfg_reg(DA850_LCD_D_15);
+			davinci_cfg_reg(DA850_LCD_PCLK);
+			davinci_cfg_reg(DA850_LCD_HSYNC);
+			davinci_cfg_reg(DA850_LCD_VSYNC);
+			davinci_cfg_reg(DA850_NLCD_AC_ENB_CS);
+			davinci_cfg_reg(DA850_GPIO2_15);
+			davinci_cfg_reg(DA850_GPIO8_10);
+		}
+	}
 
 	return 0;
 }
diff --git a/arch/arm/mach-davinci/include/mach/da8xx_lcdc.h b/arch/arm/mach-davinci/include/mach/da8xx_lcdc.h
new file mode 100644
index 0000000..7f65332
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/da8xx_lcdc.h
@@ -0,0 +1,24 @@
+/*
+ * Header file for TI DA830 LCD controller platform data.
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef DA8XX_LCDC_PLAT_H
+#define DA8XX_LCDC_PLAT_H
+
+/* GPIO 2[15] is used for LCD backlight - 16 * 2 + 15 = 47 */
+#define DA850_LCD_BL_GPIO	47
+/* GPIO 8[10] is used for LCD POWER - 16 * 8 + 10 = 138 */
+#define DA850_LCD_POWER_GPIO	138
+
+struct da8xx_lcdc_platform_data {
+	const char *lcdc_clk_name;
+};
+int da830_lcd_hw_init(void);
+int da850_lcd_hw_init(void);
+#endif  /* ifndef DA830_LCDC_PLAT_H */
+
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index b1e6689..6de975a 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1942,6 +1942,22 @@ config FB_IBM_GXT4500
 	  Say Y here to enable support for the IBM GXT4500P display
 	  adaptor, found on some IBM System P (pSeries) machines.
 
+config FB_DA8XX
+        tristate "DA8XX/OMAP-L1XX Framebuffer support"
+        depends on FB && ARCH_DA8XX
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	---help---
+          This is the frame buffer device driver for the TI LCD controller
+	  found on DA8XX/OMAP-L1XX EVM board.
+          If unsure, say N.
+
+config GLCD_SHARP_COLOR
+	bool "Use SHARP LQ035Q3DG01 LCD Display"
+	depends on FB_DA8XX
+	default y
+
 config FB_PS3
 	tristate "PS3 GPU framebuffer driver"
 	depends on FB && PS3_PS3AV
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index a6b5529..0629b54 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -131,6 +131,7 @@ obj-$(CONFIG_FB_VGA16)            += vga16fb.o
 obj-$(CONFIG_FB_OF)               += offb.o
 obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
 obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
+obj-$(CONFIG_FB_DA8XX)	  += da8xx/
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
diff --git a/drivers/video/da8xx/Makefile b/drivers/video/da8xx/Makefile
new file mode 100644
index 0000000..066b8ef
--- /dev/null
+++ b/drivers/video/da8xx/Makefile
@@ -0,0 +1,2 @@
+# Makefile for Texas Instruments DA830 framebuffer driver.
+obj-$(CONFIG_FB_DA8XX) += da8xx_fb.o
diff --git a/drivers/video/da8xx/da8xx_fb.c b/drivers/video/da8xx/da8xx_fb.c
new file mode 100644
index 0000000..d4c5b21
--- /dev/null
+++ b/drivers/video/da8xx/da8xx_fb.c
@@ -0,0 +1,959 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <mach/cpu.h>
+#include <mach/io.h>
+#include <mach/hardware.h>
+#include <mach/da8xx_lcdc.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include "da8xx_fb.h"
+#include "da8xx_lcdc.h"
+#ifdef CONFIG_GLCD_SHARP_COLOR
+#include "sharp_color.h"
+#endif
+
+#define DRIVER_NAME "da8xx_lcdc"
+
+#define da830_fb_read(addr)	__raw_readl(da830_fb_reg_base + (addr))
+#define da830_fb_write(val, addr)	__raw_writel(val, \
+						da830_fb_reg_base + (addr))
+
+#define WSI_TIMEOUT 50
+
+static resource_size_t da830_fb_reg_base;
+static wait_queue_head_t da830_wq;
+
+struct da830fb_par {
+	resource_size_t p_regs_base;
+	resource_size_t p_frame_buffer_mem_base;
+	resource_size_t p_screen_base;
+	resource_size_t p_palette_base;
+	unsigned char *v_frame_buffer_mem_base;
+	unsigned char *v_screen_base;
+	unsigned char *v_palette_base;
+	unsigned long screen_size;
+	unsigned int palette_size;
+	unsigned int bpp;
+	struct clk *lcdc_clk;
+	unsigned int irq;
+	u16 pseudo_palette[16];
+};
+
+/* Variable Screen Information */
+static struct fb_var_screeninfo da830fb_var __devinitdata = {
+	.xoffset = 0,
+	.yoffset = 0,
+	.transp = {0, 0, 0},
+	.nonstd = 0,
+	.activate = 0,
+	.height = -1,
+	.width = -1,
+	.pixclock = 46666,	/* 46us - AUO display */
+	.accel_flags = 0,
+	.left_margin = LEFT_MARGIN,
+	.right_margin = RIGHT_MARGIN,
+	.upper_margin = UPPER_MARGIN,
+	.lower_margin = LOWER_MARGIN,
+	.sync = 0,
+	.vmode = FB_VMODE_NONINTERLACED
+};
+
+static struct fb_fix_screeninfo da830fb_fix __devinitdata = {
+	.id = "DA830 FB Drv",
+	.type = FB_TYPE_PACKED_PIXELS,
+	.type_aux = 0,
+	.visual = FB_VISUAL_PSEUDOCOLOR,
+	.xpanstep = 1,
+	.ypanstep = 1,
+	.ywrapstep = 1,
+	.accel = FB_ACCEL_NONE
+};
+
+static u32 g_databuf_sz;
+static u32 g_palette_sz;
+static struct fb_ops da830_fb_ops;
+static int lcd_wait_status_int(struct device*, int int_status_mask);
+
+static void lcd_show_raster_status(struct device *dev)
+{
+	u32 value = da830_fb_read(LCD_STAT_REG);
+	if (value & LCD_FIFO_UNDERFLOW)
+		dev_dbg(dev, "DA830 LCD: FIFO Underflow!\n");
+	if (value & LCD_AC_BIAS_COUNT_STATUS)
+		dev_dbg(dev, "DA830 LCD: AC Bias Count Reached\n");
+	if (value & LCD_PALETTE_LOADED)
+		dev_dbg(dev, "DA830 LCD: Palette is Loaded\n");
+	else
+		dev_dbg(dev, "DA830 LCD: Palette is not Loaded!\n");
+	if (value & LCD_SYNC_LOST) {
+		dev_dbg(dev, "DA830 LCD: Frame Synchronization Error!\n");
+		da830_fb_write(da830_fb_read(LCD_STAT_REG) |
+				LCD_SYNC_LOST, LCD_STAT_REG);
+	}
+	value = da830_fb_read(0x00);
+	dev_dbg(dev, "DA830 LCD: Revision id is %x\n", value);
+}
+
+static void lcd_show_raster_interface(struct device *dev)
+{
+	dev_dbg(dev, "\n");
+	dev_dbg(dev, "LCD Raster Interface Configuration\n");
+	dev_dbg(dev, "----------------------------------\n");
+	dev_dbg(dev, "LCD Control Register:    0x%x\n",
+		da830_fb_read(LCD_CTRL_REG));
+	dev_dbg(dev, "Raster Control:          0x%x\n",
+	       da830_fb_read(LCD_RASTER_CTRL_REG));
+	dev_dbg(dev, "Timing Register 0:       0x%x\n",
+	       da830_fb_read(LCD_RASTER_TIMING_0_REG));
+	dev_dbg(dev, "Timing Register 1:       0x%x\n",
+	       da830_fb_read(LCD_RASTER_TIMING_1_REG));
+	dev_dbg(dev, "Timing Register 2:       0x%x\n",
+	       da830_fb_read(LCD_RASTER_TIMING_2_REG));
+	dev_dbg(dev, "Subpanel Register:       0x%x\n",
+	       da830_fb_read(LCD_RASTER_SUBPANEL_DISP_REG));
+	dev_dbg(dev, "DMA Control Register:    0x%x\n",
+	       da830_fb_read(LCD_DMA_CTRL_REG));
+	dev_dbg(dev, "DMA 0 Start Address:     0x%x\n",
+	       da830_fb_read(LCD_DMA_FRM_BUF_BASE_ADDR_0_REG));
+	dev_dbg(dev, "DMA 0 End Address:       0x%x\n",
+	       da830_fb_read(LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG));
+	dev_dbg(dev, "DMA 1 Start Address:     0x%x\n",
+	       da830_fb_read(LCD_DMA_FRM_BUF_BASE_ADDR_1_REG));
+	dev_dbg(dev, "DMA 1 End Address:       0x%x\n",
+	       da830_fb_read(LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG));
+	dev_dbg(dev, "\n");
+	lcd_show_raster_status(dev);
+	dev_dbg(dev, "\n");
+}
+
+/* Disable the Raster Engine of the LCD Controller */
+static int lcd_disable_raster(struct device *dev)
+{
+	u32 reg;
+	int ret = 0;
+
+	reg = da830_fb_read(LCD_RASTER_CTRL_REG);
+	if (reg & LCD_RASTER_ENABLE) {
+		da830_fb_write(reg & ~LCD_RASTER_ENABLE,
+						LCD_RASTER_CTRL_REG);
+		ret = lcd_wait_status_int(dev, LCD_END_OF_FRAME0);
+	}
+	return ret;
+}
+
+static int lcd_blit(int load_mode, u32 p_buf)
+{
+	u32 reg;
+	int ret = 0;
+	u32 tmp = p_buf + g_databuf_sz - 4;
+
+	/* Update the databuf in the hw. */
+	da830_fb_write(p_buf, LCD_DMA_FRM_BUF_BASE_ADDR_0_REG);
+	da830_fb_write(tmp, LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG);
+
+	/* Start the DMA. */
+	reg = da830_fb_read(LCD_RASTER_CTRL_REG);
+	reg &= ~(3 << 20);
+	if (load_mode == LOAD_DATA) {
+		reg |= LCD_PALETTE_LOAD_MODE(PALETTE_AND_DATA);
+		da830_fb_write(reg, LCD_RASTER_CTRL_REG);
+	} else if (LOAD_PALETTE == load_mode) {
+		reg |= LCD_PALETTE_LOAD_MODE(PALETTE_ONLY);
+		da830_fb_write(reg, LCD_RASTER_CTRL_REG);
+	}
+	return ret;
+}
+
+/* Configure the Burst Size of DMA */
+static int lcd_cfg_dma(struct device *dev, int burst_size)
+{
+	u32 reg;
+	reg = da830_fb_read(LCD_DMA_CTRL_REG) & 0x00000001;
+	switch (burst_size) {
+	case 1:
+		reg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_1);
+		break;
+	case 2:
+		reg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_2);
+		break;
+	case 4:
+		reg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_4);
+		break;
+	case 8:
+		reg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_8);
+		break;
+	case 16:
+		reg |= LCD_DMA_BURST_SIZE(LCD_DMA_BURST_16);
+		break;
+	default:
+		return -EINVAL;
+	}
+	dev_dbg(dev, "DA830 LCD: Configured LCD DMA Burst Size...\n");
+	da830_fb_write(reg | LCD_END_OF_FRAME_INT_ENA, LCD_DMA_CTRL_REG);
+
+	return 0;
+}
+
+static void lcd_cfg_ac_bias(struct device *dev, int period,
+				int transitions_per_int)
+{
+	u32 reg;
+	/* Set the AC Bias Period and Number of Transisitons per Interrupt */
+	reg = da830_fb_read(LCD_RASTER_TIMING_2_REG) & 0xFFF00000;
+	reg |= LCD_AC_BIAS_FREQUENCY(period) |
+	    LCD_AC_BIAS_TRANSITIONS_PER_INT(transitions_per_int);
+	da830_fb_write(reg, LCD_RASTER_TIMING_2_REG);
+	dev_dbg(dev, "DA830 LCD: Configured AC Bias...\n");
+}
+
+static void lcd_cfg_horizontal_sync(struct device *dev, int back_porch, int pulse_width,
+					int front_porch)
+{
+	u32 reg;
+	reg = da830_fb_read(LCD_RASTER_TIMING_0_REG) & 0xf;
+	reg |= ((back_porch & 0xff) << 24)
+	    | ((front_porch & 0xff) << 16)
+	    | ((pulse_width & 0x3f) << 10);
+	da830_fb_write(reg, LCD_RASTER_TIMING_0_REG);
+	dev_dbg(dev, "DA830 LCD: Configured Horizontal Sync Properties...\n");
+}
+
+static void lcd_cfg_vertical_sync(struct device *dev, int back_porch,
+					int pulse_width, int front_porch)
+{
+	u32 reg;
+	reg = da830_fb_read(LCD_RASTER_TIMING_1_REG) & 0x3ff;
+	reg |= ((back_porch & 0xff) << 24)
+	    | ((front_porch & 0xff) << 16)
+	    | ((pulse_width & 0x3f) << 10);
+	da830_fb_write(reg, LCD_RASTER_TIMING_1_REG);
+	dev_dbg(dev, "DA830 LCD: Configured Vertical Sync Properties...\n");
+}
+
+static void lcd_cfg_display(struct device *dev, const struct lcd_ctrl_config *cfg)
+{
+	u32 reg;
+
+	reg =
+	    da830_fb_read(LCD_RASTER_CTRL_REG) & ~(LCD_TFT_MODE |
+						   LCD_MONO_8BIT_MODE |
+						   LCD_MONOCHROME_MODE);
+
+	switch (cfg->p_disp_panel->panel_shade) {
+	case MONOCROME:
+		reg |= LCD_MONOCHROME_MODE;
+		if (cfg->mono_8bit_mode)
+			reg |= LCD_MONO_8BIT_MODE;
+		break;
+	case COLOR_ACTIVE:
+		reg |= LCD_TFT_MODE;
+		if (cfg->tft_alt_mode)
+			reg |= LCD_TFT_ALT_ENABLE;
+		break;
+
+	case COLOR_PASSIVE:
+		if (cfg->stn_565_mode)
+			reg |= LCD_STN_565_ENABLE;
+		break;
+
+	default:
+		 dev_err(dev, "Undefined LCD type\n");
+		break;
+	}
+
+	reg |= LCD_UNDERFLOW_INT_ENA;
+
+	da830_fb_write(reg, LCD_RASTER_CTRL_REG);
+
+	reg = da830_fb_read(LCD_RASTER_TIMING_2_REG);
+
+	if (cfg->sync_ctrl)
+		reg |= LCD_SYNC_CTRL;
+	else
+		reg &= ~LCD_SYNC_CTRL;
+
+	if (cfg->sync_edge)
+		reg |= LCD_SYNC_EDGE;
+	else
+		reg &= ~LCD_SYNC_EDGE;
+
+	if (cfg->invert_pxl_clock)
+		reg |= LCD_INVERT_PIXEL_CLOCK;
+	else
+		reg &= ~LCD_INVERT_PIXEL_CLOCK;
+
+	if (cfg->invert_line_clock)
+		reg |= LCD_INVERT_LINE_CLOCK;
+	else
+		reg &= ~LCD_INVERT_LINE_CLOCK;
+
+	if (cfg->invert_frm_clock)
+		reg |= LCD_INVERT_FRAME_CLOCK;
+	else
+		reg &= ~LCD_INVERT_FRAME_CLOCK;
+
+	da830_fb_write(reg, LCD_RASTER_TIMING_2_REG);
+
+	dev_dbg(dev, "GLCD: Configured to Active Color...\n");
+
+}
+
+static int lcd_cfg_frame_buffer(struct device *dev, u32 width, u32 height,
+					u32 bpp, u32 raster_order)
+{
+	u32 reg;
+	u32 g_bpl;
+	u32 g_bpp = bpp;
+
+	/* Disable Dual Frame Buffer. */
+	reg = da830_fb_read(LCD_DMA_CTRL_REG);
+	da830_fb_write(reg & ~LCD_DUAL_FRAME_BUFFER_ENABLE,
+						LCD_DMA_CTRL_REG);
+	/* Set the Panel Width */
+	/* Pixels per line = (PPL + 1)*16 */
+	/*0x3F in bits 4..9 gives max horisontal resolution = 1024 pixels*/
+	width &= 0x3f0;
+	reg = da830_fb_read(LCD_RASTER_TIMING_0_REG);
+	reg = (((width >> 4) - 1) << 4) | (reg & 0xfffffc00);
+	da830_fb_write(reg, LCD_RASTER_TIMING_0_REG);
+
+	/* Set the Panel Height */
+	reg = da830_fb_read(LCD_RASTER_TIMING_1_REG);
+	reg = ((height - 1) & 0x3ff) | (reg & 0xfffffc00);
+	da830_fb_write(reg, LCD_RASTER_TIMING_1_REG);
+
+	/* Set the Raster Order of the Frame Buffer */
+	reg = da830_fb_read(LCD_RASTER_CTRL_REG) & ~(1 << 8);
+	if (raster_order)
+		reg |= LCD_RASTER_ORDER;
+	da830_fb_write(reg, LCD_RASTER_CTRL_REG);
+
+	switch (g_bpp) {
+	case 1:
+	case 2:
+	case 4:
+	case 16:
+		g_palette_sz = 16 * 2;
+		g_bpl = width * g_bpp / 8;
+		g_databuf_sz = height * g_bpl + g_palette_sz;
+		break;
+
+	case 8:
+		g_palette_sz = 256 * 2;
+		g_bpl = width * g_bpp / 8;
+		g_databuf_sz = height * g_bpl + g_palette_sz;
+		break;
+
+	default:
+		dev_dbg(dev, "DA830 LCD: Unsupported BPP!\n");
+		break;
+	}
+	dev_dbg(dev, "DA830 LCD: Configured Frame Buffer...\n");
+
+	return 0;
+}
+
+/* Wait for Interrupt Status to appear. */
+static int lcd_wait_status_int(struct device *dev, int int_status_mask)
+{
+	int ret;
+
+	if (int_status_mask == LCD_SYNC_LOST)
+		ret = wait_event_interruptible_timeout(da830_wq,
+						       da830_fb_read
+						       (LCD_STAT_REG) &
+						       int_status_mask,
+						       WSI_TIMEOUT);
+	else
+		ret = wait_event_interruptible_timeout(da830_wq,
+						       !da830_fb_read
+						       (LCD_STAT_REG) &
+						       int_status_mask,
+						       WSI_TIMEOUT);
+	if (ret <= 0) {
+		dev_dbg(dev, "DA830 LCD: status wait returned %d, mask %d\n",
+		       ret, int_status_mask);
+		lcd_show_raster_status(dev);
+	}
+	if (ret < 0)
+		return ret;
+
+	if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+/* Palette Initialization */
+static void da830fb_init_palette(struct device *dev, struct fb_info *info)
+{
+	unsigned short i, size;
+	struct da830fb_par *par = info->par;
+	unsigned short *palette = (unsigned short *)par->p_palette_base;
+
+	/* Palette Size */
+	size = (par->palette_size / sizeof(*palette));
+
+	/* Clear the Palette */
+	memset(palette, 0, par->palette_size);
+
+	/* Initialization of Palette for Default values */
+	for (i = 0; i < size; i++)
+		*(unsigned short *)(palette + i) = i;
+
+	/* Setup the BPP */
+	switch (par->bpp) {
+	case 1:
+		palette[0] |= (1 << 11);
+		break;
+	case 2:
+		palette[0] |= (1 << 12);
+		break;
+	case 4:
+		palette[0] |= (2 << 12);
+		break;
+	case 8:
+		palette[0] |= (3 << 12);
+		break;
+	case 16:
+		palette[0] |= (4 << 12);
+		break;
+	default:
+		dev_dbg(dev, "DA830 LCD: Unsupported Video BPP %d!\n", par->bpp);
+		break;
+	}
+
+	for (i = 0; i < size; i++)
+		par->pseudo_palette[i] = i;
+
+	dev_dbg(dev, "GLCD: Palette initialization done successfully\n");
+}
+
+static int da830_fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			      unsigned blue, unsigned transp,
+			      struct fb_info *info)
+{
+	u_short pal;
+	struct da830fb_par *par = info->par;
+	unsigned short *palette = (unsigned short *)par->v_palette_base;
+
+	if (regno > 255)
+		return 1;
+
+	if (info->fix.visual == FB_VISUAL_DIRECTCOLOR ||
+	    info->fix.visual == FB_VISUAL_TRUECOLOR)
+		return 1;
+
+	switch (par->bpp) {
+	case 8:
+		red >>= 8;
+		green >>= 8;
+		blue >>= 8;
+		break;
+	}
+
+	pal = (red & 0x0f00);
+	pal |= (green & 0x00f0);
+	pal |= (blue & 0x000f);
+
+	palette[regno] = pal;
+
+	return 0;
+}
+
+static void lcd_reset(struct device *dev)
+{
+	/* Disable the Raster if previously Enabled */
+	if (da830_fb_read(LCD_RASTER_CTRL_REG) & LCD_RASTER_ENABLE) {
+		dev_dbg(dev, "DA830 LCD: Waiting for Raster Frame Done...\n");
+		lcd_disable_raster(dev);
+	}
+	/* DMA has to be disabled */
+	da830_fb_write(0, LCD_DMA_CTRL_REG);
+	dev_dbg(dev, "DA830 LCD: Raster is going for Reset now...\n");
+	lcd_show_raster_interface(dev);
+	da830_fb_write(0, LCD_RASTER_CTRL_REG);
+	/* TODO: Place the LCD block in reset */
+	/* TODO: Release it from Reset */
+	dev_dbg(dev, "GLCD: LCD Controller Reset...\n");
+	lcd_show_raster_interface(dev);
+}
+
+static int lcd_init(struct device *dev, const struct lcd_ctrl_config *cfg)
+{
+	u32 bpp;
+
+	if (cpu_is_da830()) {
+		if (da830_lcd_hw_init()) {
+			dev_err(dev, "GLCD: Error in Initialising\n");
+			return -ENODEV;
+		}
+	} else if (cpu_is_da850()) {
+		if (da850_lcd_hw_init()) {
+			dev_err(dev, "GLCD: Error in Initialising\n");
+			return -ENODEV;
+		}
+	}
+
+	lcd_reset(dev);
+	/* Configure the LCD clock divisor. */
+	da830_fb_write(LCD_CLK_DIVISOR(cfg->pxl_clk) |
+					(LCD_RASTER_MODE & 0x1), LCD_CTRL_REG);
+	/* Configure the DMA burst size. */
+	lcd_cfg_dma(dev, cfg->dma_burst_sz);
+	/* Configure the AC bias properties. */
+	lcd_cfg_ac_bias(dev, cfg->ac_bias, cfg->ac_bias_intrpt);
+	/* Configure the vertical and horizontal sync properties. */
+	lcd_cfg_vertical_sync(dev, cfg->vbp, cfg->vsw, cfg->vfp);
+	lcd_cfg_horizontal_sync(dev, cfg->hbp, cfg->hsw, cfg->hfp);
+	/* Configure for disply */
+	lcd_cfg_display(dev, cfg);
+	if (QVGA != cfg->p_disp_panel->panel_type) {
+		dev_err(dev, "\nError: Only QVGA panel is currently supported !");
+		return -EINVAL;
+	}
+	if (cfg->bpp <= cfg->p_disp_panel->max_bpp &&
+	    cfg->bpp >= cfg->p_disp_panel->min_bpp)
+		bpp = cfg->bpp;
+	else
+		bpp = cfg->p_disp_panel->max_bpp;
+	if (bpp == 12)
+		bpp = 16;
+	lcd_cfg_frame_buffer(dev, (unsigned int)cfg->p_disp_panel->width,
+			     (unsigned int)cfg->p_disp_panel->height, bpp,
+			     cfg->raster_order);
+	/* Configure FDD */
+	da830_fb_write((da830_fb_read(LCD_RASTER_CTRL_REG) & 0xfff00fff) |
+		       (cfg->fdd << 12), LCD_RASTER_CTRL_REG);
+
+	return 0;
+}
+
+static irqreturn_t da830_lcdc_irq_handler(int irq, void *arg)
+{
+
+	u32 stat = da830_fb_read(LCD_STAT_REG);
+	u32 reg;
+
+	if ((stat & LCD_SYNC_LOST) && (stat & LCD_FIFO_UNDERFLOW)) {
+		reg = da830_fb_read(LCD_RASTER_CTRL_REG);
+		da830_fb_write(reg & ~LCD_RASTER_ENABLE,
+							LCD_RASTER_CTRL_REG);
+		da830_fb_write(stat, LCD_STAT_REG);
+		da830_fb_write(reg | LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);
+	} else
+		da830_fb_write(stat, LCD_STAT_REG);
+
+	/*TODO: m.b. use lcd_clear_status_int((u32)int_status_mask) here*/
+	wake_up_interruptible(&da830_wq);
+	return IRQ_HANDLED;
+}
+
+static int da830_fb_check_var(struct fb_var_screeninfo *var,
+			      struct fb_info *info)
+{
+	int err = 0;
+	switch (var->bits_per_pixel) {
+	case 1:
+	case 8:
+		var->red.offset = 0;
+		var->red.length = 8;
+		var->green.offset = 0;
+		var->green.length = 8;
+		var->blue.offset = 0;
+		var->blue.length = 8;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 4:
+		var->red.offset = 0;
+		var->red.length = 4;
+		var->green.offset = 0;
+		var->green.length = 4;
+		var->blue.offset = 0;
+		var->blue.length = 4;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	case 16:		/* RGB 565 */
+		var->red.offset = 0;
+		var->red.length = 5;
+		var->green.offset = 5;
+		var->green.length = 6;
+		var->blue.offset = 11;
+		var->blue.length = 5;
+		var->transp.offset = 0;
+		var->transp.length = 0;
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	var->red.msb_right = 0;
+	var->green.msb_right = 0;
+	var->blue.msb_right = 0;
+	var->transp.msb_right = 0;
+	return err;
+}
+
+static int da830_fb_set_par(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+
+	switch (var->bits_per_pixel) {
+	case 1:
+		fix->visual = FB_VISUAL_MONO01;
+		break;
+
+	case 2:
+	case 4:
+	case 8:
+		fix->visual = FB_VISUAL_PSEUDOCOLOR;
+		break;
+
+	case 16:
+		fix->visual = FB_VISUAL_TRUECOLOR;
+		break;
+	}
+
+	fix->line_length = (var->xres_virtual * var->bits_per_pixel) / 8;
+	return 0;
+}
+
+static int __devexit da830_fb_remove(struct platform_device *dev)
+{
+	struct fb_info *info = dev_get_drvdata(&dev->dev);
+	if (info) {
+		struct da830fb_par *par = info->par;
+		/*TODO: do we need this along with line below? */
+		if (da830_fb_read(LCD_RASTER_CTRL_REG) & LCD_RASTER_ENABLE)
+			lcd_disable_raster(&dev->dev);
+		da830_fb_write(0, LCD_RASTER_CTRL_REG);
+		/* disable DMA  */
+		da830_fb_write(0, LCD_DMA_CTRL_REG);
+
+		unregister_framebuffer(info);
+
+		fb_dealloc_cmap(&info->cmap);
+
+		dma_free_coherent(NULL, g_databuf_sz + PAGE_SIZE,
+				par->v_frame_buffer_mem_base,
+				par->p_frame_buffer_mem_base);
+
+		free_irq(par->irq, NULL);
+
+		clk_disable(par->lcdc_clk);
+
+		clk_put(par->lcdc_clk);
+
+		framebuffer_release(info);
+
+	}
+	return 0;
+}
+static int __init da830_fb_probe(struct platform_device *device)
+{
+	struct fb_info *da830fb_info;
+	struct da830fb_par *par;
+	int ret;
+	struct resource *lcdc_regs;
+	struct da8xx_lcdc_platform_data *fb_pdata =
+						device->dev.platform_data;
+	struct clk *fb_clk = NULL;
+	if (fb_pdata == NULL) {
+		dev_err(&device->dev, "Can not get platform data\n");
+		return -ENOENT;
+	}
+
+	lcdc_regs = platform_get_resource(device, IORESOURCE_MEM, 0);
+	if (!lcdc_regs) {
+		dev_err(&device->dev,
+			"Can not get memory resource for LCD controller\n");
+		return -ENOENT;
+	}
+
+	da830_fb_reg_base = (resource_size_t) IO_ADDRESS(lcdc_regs->start);
+
+	fb_clk = clk_get(&device->dev, fb_pdata->lcdc_clk_name);
+	if (IS_ERR(fb_clk)) {
+		dev_err(&device->dev, "Can not get device clock\n");
+		return -ENODEV;
+	}
+	ret = clk_enable(fb_clk);
+	if (ret)
+		goto err_clk_put;
+
+	if (lcd_init(&device->dev, &lcd_cfg)) {
+		dev_err(&device->dev, "lcd_init failed\n");
+		ret = -EFAULT;
+		goto err_clk_disable;
+	}
+	da830fb_info = framebuffer_alloc(sizeof(struct fb_info),
+							&device->dev);
+	if (!da830fb_info) {
+		dev_dbg(&device->dev, "Memory allocation failed for fb_info\n");
+		ret = -ENOMEM;
+		goto err_clk_disable;
+	}
+
+	par = da830fb_info->par;
+	/* allocate frame buffer memory */
+	par->v_frame_buffer_mem_base = dma_alloc_coherent(NULL,
+						g_databuf_sz + PAGE_SIZE,
+						&par->p_frame_buffer_mem_base,
+						GFP_KERNEL | GFP_DMA);
+
+	if (!par->v_frame_buffer_mem_base) {
+		dev_err(&device->dev,
+			"GLCD: kmalloc for frame buffer failed\n");
+		ret = -EINVAL;
+		goto err_release_fb;
+	}
+
+	/* move palette base pointer by ( PAGE_SIZE - g_palette_sz ) bytes */
+	par->v_palette_base = par->v_frame_buffer_mem_base +
+				(PAGE_SIZE - g_palette_sz);
+	par->p_palette_base = par->p_frame_buffer_mem_base +
+				(PAGE_SIZE - g_palette_sz);
+
+	/* First g_palette_sz byte of the frame buffer is the palett */
+	par->palette_size = g_palette_sz;
+
+	/* the rest of the frame buffer is pixel data */
+	par->v_screen_base = par->v_palette_base + g_palette_sz;
+	par->p_screen_base = par->p_palette_base + g_palette_sz;
+	par->screen_size = g_databuf_sz - g_palette_sz;
+
+	par->lcdc_clk = fb_clk;
+
+	da830fb_fix.smem_start = (unsigned long)par->p_screen_base;
+	da830fb_fix.smem_len = par->screen_size;
+
+	dev_dbg(&device->dev, "GLCD: Frame Buffer Memory allocation successful\n");
+	dev_dbg(&device->dev, "GLCD: Palette Memory allocation successful\n");
+
+	init_waitqueue_head(&da830_wq);
+
+	par->irq = platform_get_irq(device, 0);
+	if (par->irq < 0) {
+		ret = -ENOENT;
+		goto err_release_fb_mem;
+	}
+
+	ret = request_irq(par->irq, da830_lcdc_irq_handler, 0,
+			  DRIVER_NAME, NULL);
+	if (ret)
+		goto err_free_irq;
+
+	/* Initialize par */
+	par->bpp = lcd_cfg.bpp;
+
+	da830fb_var.xres = lcd_cfg.p_disp_panel->width;
+	da830fb_var.xres_virtual = lcd_cfg.p_disp_panel->width;
+
+	da830fb_var.yres = lcd_cfg.p_disp_panel->height;
+	da830fb_var.yres_virtual = lcd_cfg.p_disp_panel->height;
+
+	da830fb_var.grayscale =
+	    lcd_cfg.p_disp_panel->panel_shade == MONOCROME ? 1 : 0;
+	da830fb_var.bits_per_pixel = lcd_cfg.bpp;
+
+	da830fb_var.hsync_len = lcd_cfg.hsw;
+	da830fb_var.vsync_len = lcd_cfg.vsw;
+
+	/* Initialize fbinfo */
+	da830fb_info->flags = FBINFO_FLAG_DEFAULT;
+	da830fb_info->screen_base = par->v_screen_base;
+	da830fb_info->device = &device->dev;
+	da830fb_info->fix = da830fb_fix;
+	da830fb_info->var = da830fb_var;
+	da830fb_info->fbops = &da830_fb_ops;
+	da830fb_info->pseudo_palette = par->pseudo_palette;
+
+	/* Initialize the Palette */
+	dev_dbg(&device->dev, "GLCD: Initializing the Palette...\n");
+	da830fb_init_palette(&device->dev, da830fb_info);
+
+	ret = fb_alloc_cmap(&da830fb_info->cmap, PALETTE_SIZE, 0);
+	if (ret)
+		goto err_free_irq;
+
+	/* Map Video Memory */
+	dev_dbg(&device->dev, "GLCD: Mapping the Video Memory...\n");
+
+	/* Flush the buffer to the screen. */
+	lcd_blit(LOAD_DATA, (u32) par->p_palette_base);
+
+	/* initialize var_screeninfo */
+	da830fb_var.activate = FB_ACTIVATE_FORCE;
+	fb_set_var(da830fb_info, &da830fb_var);
+
+	dev_set_drvdata(&device->dev, da830fb_info);
+	/* Register the Frame Buffer  */
+	if (register_framebuffer(da830fb_info) < 0) {
+		dev_err(&device->dev, "GLCD: Frame Buffer Registration Failed!\n");
+		ret = -EINVAL;
+		goto err_dealloc_cmap;
+	}
+
+	/* enable raster engine */
+	da830_fb_write(da830_fb_read(LCD_RASTER_CTRL_REG) |
+					LCD_RASTER_ENABLE, LCD_RASTER_CTRL_REG);
+
+	return 0;
+
+err_dealloc_cmap:
+	fb_dealloc_cmap(&da830fb_info->cmap);
+
+err_free_irq:
+	free_irq(par->irq, NULL);
+
+err_release_fb_mem:
+	dma_free_coherent(NULL, g_databuf_sz + PAGE_SIZE,
+			par->v_frame_buffer_mem_base,
+			par->p_frame_buffer_mem_base);
+
+err_release_fb:
+	framebuffer_release(da830fb_info);
+
+err_clk_disable:
+	clk_disable(fb_clk);
+
+err_clk_put:
+	clk_put(fb_clk);
+
+	return ret;
+}
+
+static int da830_fb_ioctl(struct fb_info *info, unsigned int cmd,
+			  unsigned long arg)
+{
+	int val;
+	struct lcd_sync_arg sync_arg;
+#ifdef CONFIG_GLCD_SHARP_COLOR
+	struct lcd_contrast_arg contrast_arg;
+	unsigned long hal_arg = arg;
+#endif
+
+	switch (cmd) {
+	case FBIOPUT_CONTRAST:
+		val = (int)arg;
+#ifdef CONFIG_GLCD_SHARP_COLOR
+
+		if (copy_from_user
+		    (&contrast_arg, (char *)arg,
+		     sizeof(struct lcd_contrast_arg)))
+			return -EINVAL;
+		hal_arg = contrast_arg.cnt;
+		if (hal_arg < TI_GLCD_SHARP_COLOR_MIN_CONTRAST
+		    || hal_arg > TI_GLCD_SHARP_COLOR_MAX_CONTRAST)
+			return -EINVAL;
+		hal_arg = contrast_arg.cnt | (contrast_arg.is_up << 8);
+		/*TODO : implement contrast setting here */
+		return -EINVAL;
+#endif
+		break;
+	case FBIGET_BRIGHTNESS:
+	case FBIPUT_BRIGHTNESS:
+	case FBIGET_COLOR:
+	case FBIPUT_COLOR:
+		return -EINVAL;
+	case FBIPUT_HSYNC:
+		if (copy_from_user(&sync_arg, (char *)arg,
+				sizeof(struct lcd_sync_arg)))
+			return -EINVAL;
+		lcd_cfg_horizontal_sync(info->dev, sync_arg.back_porch,
+					sync_arg.pulse_width,
+					sync_arg.front_porch);
+		break;
+	case FBIPUT_VSYNC:
+		if (copy_from_user(&sync_arg, (char *)arg,
+				sizeof(struct lcd_sync_arg)))
+			return -EINVAL;
+		lcd_cfg_vertical_sync(info->dev, sync_arg.back_porch,
+					sync_arg.pulse_width,
+					sync_arg.front_porch);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static struct fb_ops da830_fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = da830_fb_check_var,
+	.fb_set_par = da830_fb_set_par,
+	.fb_setcolreg = da830_fb_setcolreg,
+	.fb_ioctl = da830_fb_ioctl,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+};
+
+#ifdef CONFIG_PM
+static int da830_fb_suspend(struct platform_device *dev, pm_message_t state)
+{
+	 /*TODO*/ return -EBUSY;
+}
+static int da830_fb_resume(struct platform_device *dev)
+{
+	 /*TODO*/ return -EBUSY;
+}
+#else
+#define da830_fb_suspend NULL
+#define da830_fb_resume NULL
+#endif
+
+static struct platform_driver da830_fb_driver = {
+	.probe = da830_fb_probe,
+	.remove = da830_fb_remove,
+	.suspend = da830_fb_suspend,
+	.resume = da830_fb_resume,
+	.driver = {
+		   .name = DRIVER_NAME,
+		   .owner = THIS_MODULE,
+		   },
+};
+
+static int __init da830fb_init(void)
+{
+	return platform_driver_register(&da830_fb_driver);
+}
+
+static void __exit da830fb_cleanup(void)
+{
+	platform_driver_unregister(&da830_fb_driver);
+}
+
+module_init(da830fb_init);
+module_exit(da830fb_cleanup);
+
+MODULE_DESCRIPTION("Framebuffer driver for TI da830");
+MODULE_AUTHOR("MontaVista Software");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/da8xx/da8xx_fb.h b/drivers/video/da8xx/da8xx_fb.h
new file mode 100644
index 0000000..ed4a995
--- /dev/null
+++ b/drivers/video/da8xx/da8xx_fb.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __DA830_FB_H__
+#define __DA830_FB_H__
+
+#ifdef CONFIG_ARCH_DA850
+#define QVGA_HEIGHT    272
+#define QVGA_WIDTH     480
+#elif CONFIG_ARCH_DA830
+#define QVGA_HEIGHT    240
+#define QVGA_WIDTH     320
+#endif
+
+#define PALETTE_SIZE 256
+#define LEFT_MARGIN   64
+#define RIGHT_MARGIN  64
+#define UPPER_MARGIN  32
+#define LOWER_MARGIN  32
+
+/* ioctls */
+#define FBIOGET_CONTRAST        _IOR('F', 1, int)
+#define FBIOPUT_CONTRAST        _IOW('F', 2, int)
+#define FBIGET_BRIGHTNESS       _IOR('F', 3, int)
+#define FBIPUT_BRIGHTNESS       _IOW('F', 3, int)
+#define FBIGET_COLOR       _IOR('F', 5, int)
+#define FBIPUT_COLOR       _IOW('F', 6, int)
+#define FBIOPUT_SINGLE_BUFFER	_IO('F', 7)
+#define FBIOPUT_DUAL_BUFFER     _IO('F', 8)
+#define FBIPUT_HSYNC       _IOW('F', 9, int)
+#define FBIPUT_VSYNC       _IOW('F', 10, int)
+
+enum panel_type {
+	QVGA = 0
+};
+
+enum panel_shade {
+	MONOCROME = 0,
+	COLOR_ACTIVE,
+	COLOR_PASSIVE,
+};
+
+enum raster_load_mode {
+	LOAD_DATA = 1,
+	LOAD_PALETTE,
+};
+
+struct display_panel {
+	enum panel_type panel_type; /* QVGA */
+	int         max_bpp;
+	int         min_bpp;
+	unsigned short        width;
+	unsigned short        height;
+	enum panel_shade panel_shade;
+};
+
+struct lcd_ctrl_config {
+	const struct display_panel  *p_disp_panel;
+	int             hfp;              /* Horizontal front porch */
+	int             hbp;              /* Horizontal back porch */
+	int             hsw;              /* Horizontal Sync Pulse Width */
+	int             vfp;              /* Vertical front porch */
+	int             vbp;              /* Vertical back porch */
+	int             vsw;              /* Vertical Sync Pulse Width */
+	int             ac_bias;          /* AC Bias Pin Frequency */
+	int             ac_bias_intrpt;   /* AC Bias Pin Transitions
+					     per Interrupt */
+	int             dma_burst_sz;     /* DMA burst size */
+	int             bpp;              /* Bits per pixel */
+	int             fdd;              /* FIFO DMA Request Delay */
+	int             pxl_clk;          /* Pixel clock */
+	unsigned char   tft_alt_mode;     /* TFT Alternative Signal Mapping
+					     (Only for active) */
+	unsigned char   stn_565_mode;     /* 12 Bit Per Pixel (5-6-5) Mode
+					     (Only for passive) */
+	unsigned char   mono_8bit_mode;   /* Mono 8-bit Mode: 1=D0-D7
+					     or 0=D0-D3 */
+	unsigned char   invert_pxl_clock; /* Invert pixel clock */
+	unsigned char   invert_line_clock;/* Invert line clock */
+	unsigned char   invert_frm_clock; /* Invert frame clock  */
+	unsigned char   sync_edge;        /* Horizontal and Vertical Sync Edge:
+					     0=rising 1=falling */
+	unsigned char   sync_ctrl;        /* Horizontal and Vertical Sync
+					     Control: 0=ignore */
+	unsigned char   raster_order;     /* Raster Data Order Select:
+					     1=Most-to-least 0=Least-to-most */
+};
+
+struct lcd_contrast_arg {
+	unsigned char is_up;
+	unsigned char cnt;
+};
+struct lcd_sync_arg {
+	int back_porch;
+	int front_porch;
+	int pulse_width;
+};
+
+
+#endif
diff --git a/drivers/video/da8xx/da8xx_lcdc.h b/drivers/video/da8xx/da8xx_lcdc.h
new file mode 100644
index 0000000..4e6e5a7
--- /dev/null
+++ b/drivers/video/da8xx/da8xx_lcdc.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2008 MontaVista Software Inc.
+ * Copyright (C) 2008 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __DA830_LCDC_H__
+#define __DA830_LCDC_H__
+
+#define DA830_LCDC_REVISION	  0x4C100100
+
+/* LCD Status Register */
+#define LCD_END_OF_FRAME1           (1 << 9)
+#define LCD_END_OF_FRAME0           (1 << 8)
+#define LCD_PALETTE_LOADED          (1 << 6)
+#define LCD_FIFO_UNDERFLOW          (1 << 5)
+#define LCD_AC_BIAS_COUNT_STATUS    (1 << 3)
+#define LCD_SYNC_LOST               (1 << 2)
+#define LCD_FRAME_DONE              (1 << 0)
+
+/* LCD DMA Control Register */
+#define LCD_DMA_BURST_SIZE(x)       ((x) << 4)
+#define LCD_DMA_BURST_1             0x0
+#define LCD_DMA_BURST_2             0x1
+#define LCD_DMA_BURST_4             0x2
+#define LCD_DMA_BURST_8             0x3
+#define LCD_DMA_BURST_16            0x4
+#define LCD_DMA_BIG_ENDIAN          (1 << 1)
+#define LCD_END_OF_FRAME_INT_ENA    (1 << 2)
+#define LCD_DUAL_FRAME_BUFFER_ENABLE  (1 << 0)
+
+/* LCD Control Register */
+#define LCD_CLK_DIVISOR(x)          ((x) << 8)
+#define LCD_RASTER_MODE             0x01
+
+/* LCD Raster Control Register */
+#define LCD_PALETTE_LOAD_MODE(x)    ((x) << 20)
+#define PALETTE_AND_DATA	    0x00
+#define PALETTE_ONLY                0x01
+#define DATA_ONLY                   0x02
+
+#define LCD_MONO_8BIT_MODE          (1 << 9)
+#define LCD_RASTER_ORDER            (1 << 8)
+#define LCD_TFT_MODE                (1 << 7)
+#define LCD_UNDERFLOW_INT_ENA       (1 << 6)
+#define LCD_SYNC_LOST_INT_ENA       (1 << 5)
+#define LCD_LOAD_DONE_INT_ENA       (1 << 4)
+#define LCD_FRAME_DONE_INT_ENA      (1 << 3)
+#define LCD_AC_BIAS_INT_ENA         (1 << 2)
+#define LCD_MONOCHROME_MODE         (1 << 1)
+#define LCD_RASTER_ENABLE           (1 << 0)
+#define LCD_NIBBLE_MODE_ENABLE      (1 << 22)
+#define LCD_TFT_ALT_ENABLE	    (1 << 23)
+#define LCD_STN_565_ENABLE	    (1 << 24)
+
+/* LCD Interrupt Status */
+#define LCD_ALL_STATUS_INTS         (LCD_END_OF_FRAME1 | LCD_END_OF_FRAME0 | \
+				     LCD_PALETTE_LOADED | LCD_FIFO_UNDERFLOW | \
+				     LCD_AC_BIAS_COUNT_STATUS | LCD_SYNC_LOST |\
+				     LCD_FRAME_DONE)
+
+/* LCD Raster Timing 2 Register */
+#define LCD_AC_BIAS_TRANSITIONS_PER_INT(x)      ((x) << 16)
+#define LCD_AC_BIAS_FREQUENCY(x)    ((x) << 8)
+#define LCD_SYNC_CTRL               (1 << 25)
+#define LCD_SYNC_EDGE               (1 << 24)
+#define LCD_INVERT_PIXEL_CLOCK      (1 << 22)
+#define LCD_INVERT_LINE_CLOCK       (1 << 21)
+#define LCD_INVERT_FRAME_CLOCK      (1 << 20)
+
+/* System Reset Disable Control Register */
+#define LCD_RASTER_ENABLE           (1 << 0)
+#define RST_LCD                     (1 << 24)
+
+/* System Clock Disable Control Register */
+#define LCD_CLK_DSBL                (1 << 25)
+/* LCD Block */
+#define  LCD_BLK_REV_REG                      0x0
+#define  LCD_CTRL_REG                         0x4
+#define  LCD_STAT_REG                         0x8
+#define  LCD_LIDD_CTRL_REG                     0xC
+#define  LCD_LIDD_CS0_CONFIG_REG                0x10
+#define  LCD_LIDD_CS0_ADDR_REG                  0x14
+#define  LCD_LIDD_CS0_DATA_REG                  0x18
+#define  LCD_LIDD_CS1_CONFIG_REG                0x1C
+#define  LCD_LIDD_CS1_ADDR_REG                  0x20
+#define  LCD_LIDD_CS1_DATA_REG                  0x24
+#define  LCD_RASTER_CTRL_REG                    0x28
+#define  LCD_RASTER_TIMING_0_REG                0x2C
+#define  LCD_RASTER_TIMING_1_REG                0x30
+#define  LCD_RASTER_TIMING_2_REG                0x34
+#define  LCD_RASTER_SUBPANEL_DISP_REG           0x38
+#define  LCD_DMA_CTRL_REG                       0x40
+#define  LCD_DMA_FRM_BUF_BASE_ADDR_0_REG        0x44
+#define  LCD_DMA_FRM_BUF_CEILING_ADDR_0_REG     0x48
+#define  LCD_DMA_FRM_BUF_BASE_ADDR_1_REG        0x4C
+#define  LCD_DMA_FRM_BUF_CEILING_ADDR_1_REG     0x50
+#endif /*__DA830_LCDC_H__*/
diff --git a/drivers/video/da8xx/sharp_color.h b/drivers/video/da8xx/sharp_color.h
new file mode 100644
index 0000000..b4cd348
--- /dev/null
+++ b/drivers/video/da8xx/sharp_color.h
@@ -0,0 +1,79 @@
+/*
+ *  Copyright (C) 2005 Texas Instruments, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+/*******************************************************************************
+ * FILE PURPOSE:    Graphical LCD Configuration file
+ *******************************************************************************
+ * FILE NAME:       sharp_color.h
+ *
+ * DESCRIPTION:     Configuration file for Sharp LQ057Q3DC02 Color GLCD
+ *
+ * AUTHOR:			hai@ti.com
+ *
+ * (C) Copyright 2005, Texas Instruments, Inc
+ ******************************************************************************/
+
+#define TI_GLCD_SHARP_COLOR_MIN_CONTRAST     0
+#define TI_GLCD_SHARP_COLOR_MAX_CONTRAST    31
+
+static const struct display_panel disp_panel = {
+	QVGA,
+	16,
+	16,
+    QVGA_WIDTH,  /* width          */
+    QVGA_HEIGHT, /* height         */
+    COLOR_ACTIVE,
+};
+
+static const struct lcd_ctrl_config lcd_cfg = {
+	&disp_panel, /* p_disp_panel   */
+#ifdef CONFIG_ARCH_DA850
+	.hfp			= 2,   /* hfp            */
+	.hbp			= 2,   /* hbp            */
+	.hsw			= 41,  /* hsw            */
+	.vfp			= 2,    /* vfp            */
+	.vbp			= 2,    /* vbp            */
+	.vsw			= 10,   /* vsw            */
+	.invert_pxl_clock	= 0,    /* invert_pxl_clock  */
+#elif CONFIG_ARCH_DA830
+	.hfp			= 8,   /* hfp            */
+	.hbp			= 6,   /* hbp            */
+	.hsw			= 0,   /* hsw            */
+	.vfp			= 2,    /* vfp            */
+	.vbp			= 2,    /* vbp            */
+	.vsw			= 0,    /* vsw            */
+	.invert_pxl_clock	= 1,    /* invert_pxl_clock  */
+#endif
+	.ac_bias		= 255,  /* ac bias        */
+	.ac_bias_intrpt		= 0,    /* ac bias intrpt */
+	.dma_burst_sz		= 16,   /* dma_burst_sz   */
+	.bpp			= 16,   /* bpp            */
+	.fdd			= 255,  /* fdd            */
+#ifdef CONFIG_ARCH_DA850
+	.pxl_clk		= 0x12,    /* pxl_clk        */
+#elif CONFIG_ARCH_DA830
+	.pxl_clk		= 0x1e,    /* pxl_clk        */
+#endif
+	.tft_alt_mode		= 0,    /* tft_alt_mode   */
+	.stn_565_mode		= 0,    /* stn_565_mode   */
+	.mono_8bit_mode		= 0,    /* mono_8bit_mode    */
+	.invert_line_clock	= 1,    /* invert_line_clock */
+	.invert_frm_clock	= 1,    /* invert_frm_clock  */
+	.sync_edge		= 0,    /* sync_edge         */
+	.sync_ctrl		= 1,    /* sync_ctrl         */
+	.raster_order		= 0,    /* raster_order      */
+};
-- 
1.6.5.2

