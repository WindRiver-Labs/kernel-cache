From 03cee4ac940063b44ce9c6e353e43af86bc80740 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 5 Nov 2009 17:53:07 +0800
Subject: [PATCH 05/43] Add the serial initialization for the L138 board

Original codes from TI Linux Platform Support Package
 DaVinci-PSP-SDK-03.20.00.05.tgz http://software-dl.ti.com/dsps/
 dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

 Initialize the UART port of the L138 board.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/Makefile              |    2 +-
 arch/arm/mach-davinci/board-da850-evm.c     |   22 +++++
 arch/arm/mach-davinci/include/mach/serial.h |    7 ++
 arch/arm/mach-davinci/serial.c              |  118 +++++++++++++++++++++++----
 4 files changed, 130 insertions(+), 19 deletions(-)

diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 1715acb..0604278 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -4,7 +4,7 @@
 #
 
 # Common objects
-obj-y 			:= time.o clock.o io.o id.o psc.o \
+obj-y 			:= time.o clock.o serial.o io.o id.o psc.o \
 			   gpio.o
 
 obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index 4e79bb0..2e9aeb2 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -21,6 +21,7 @@
 #include <linux/init.h>
 #include <linux/major.h>
 #include <linux/dma-mapping.h>
+#include <linux/serial.h>
 #include <linux/io.h>
 #include <linux/console.h>
 
@@ -34,17 +35,37 @@
 #include <mach/clock.h>
 #include <mach/psc.h>
 #include <mach/da8xx.h>
+#include <mach/serial.h>
+#include <mach/mux.h>
 #include <linux/platform_device.h>
 #include <mach/cp_intc.h>
 
 #include "clock.h"
 
+static struct davinci_uart_config uart_config __initdata = {
+	.enabled_uarts = ((1 << 0) | (1 << 1) | (1 << 2)),
+};
+
 static void __init da850_map_io(void)
 {
 	davinci_map_common_io();
 	da850_init();
 }
 
+static __init void da850_evm_init(void)
+{
+	davinci_cfg_reg(DA850_UART2_RXD);
+	davinci_cfg_reg(DA850_UART2_TXD);
+	davinci_serial_init(&uart_config);
+	/*
+	 * shut down uart 0 and 1; they are not used on the board and
+	 * accessing them causes endless "too much work in irq53" messages
+	 * with arago fs
+	 */
+	__raw_writel(0, IO_ADDRESS(DA8XX_UART1_BASE) + 0x30);
+	__raw_writel(0, IO_ADDRESS(DA8XX_UART0_BASE) + 0x30);
+}
+
 static __init void da850_evm_irq_init(void)
 {
 	cp_intc_init((void __iomem *)IO_Dx_INTC_VIRT,
@@ -58,4 +79,5 @@ MACHINE_START(DAVINCI_DA850_EVM, "DaVinci DA850 EVM")
 	.map_io		= da850_map_io,
 	.init_irq	= da850_evm_irq_init,
 	.timer		= &davinci_timer,
+	.init_machine	= da850_evm_init,
 MACHINE_END
diff --git a/arch/arm/mach-davinci/include/mach/serial.h b/arch/arm/mach-davinci/include/mach/serial.h
index 9fb1fcd..8b5b029 100644
--- a/arch/arm/mach-davinci/include/mach/serial.h
+++ b/arch/arm/mach-davinci/include/mach/serial.h
@@ -29,4 +29,11 @@
 #define UART_DM646X_SCR			0x10
 #define UART_DM646X_SCR_TX_WATERMARK	0x08
 
+struct davinci_uart_config {
+	/* Bit field of UARTs present; bit 0 --> UART1 */
+	unsigned int enabled_uarts;
+};
+
+extern void davinci_serial_init(struct davinci_uart_config *);
+
 #endif /* __ASM_ARCH_SERIAL_H */
diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index caf101e..5fa54d2 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -26,38 +26,53 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <mach/serial.h>
 #include <mach/irqs.h>
+#include <mach/cpu.h>
+#include "clock.h"
 
-#define UART_DAVINCI_PWREMU 0x0c
-
-static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
-					  int offset)
+static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
+					   int offset)
 {
 	offset <<= up->regshift;
-	return (unsigned int)__raw_readb(up->membase + offset);
+	return (unsigned int)__raw_readl(IO_ADDRESS(up->mapbase) + offset);
 }
 
-static inline void davinci_serial_outp(struct plat_serial8250_port *p,
-				       int offset, int value)
+static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
+				    int value)
 {
 	offset <<= p->regshift;
-	__raw_writeb(value, p->membase + offset);
+	__raw_writel(value, IO_ADDRESS(p->mapbase) + offset);
 }
 
 static struct plat_serial8250_port serial_platform_data[] = {
 	{
-		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
-		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.mapbase	= DAVINCI_UART0_BASE,
 		.irq		= IRQ_UARTINT0,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DAVINCI_UART1_BASE,
+		.irq		= IRQ_UARTINT1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DAVINCI_UART2_BASE,
+		.irq		= IRQ_UARTINT2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+				  UPF_IOREMAP,
 		.iotype		= UPIO_MEM,
 		.regshift	= 2,
-		.uartclk	= 27000000,
 	},
 	{
 		.flags		= 0
@@ -74,22 +89,89 @@ static struct platform_device serial_device = {
 
 static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 {
-	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
 	unsigned int pwremu = 0;
 
-	davinci_serial_outp(p, UART_IER, 0);  /* disable all interrupts */
+	serial_write_reg(p, UART_IER, 0);  /* disable all interrupts */
 
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
 	mdelay(10);
 
 	pwremu |= (0x3 << 13);
 	pwremu |= 0x1;
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
+
+	if (cpu_is_davinci_dm646x())
+		serial_write_reg(p, UART_DM646X_SCR,
+				 UART_DM646X_SCR_TX_WATERMARK);
+}
+
+void __init davinci_serial_init(struct davinci_uart_config *info)
+{
+	int i;
+	char name[16];
+	struct clk *uart_clk;
+	struct device *dev = &serial_device.dev;
+
+	/*
+	 * Make sure the serial ports are muxed on at this point.
+	 * You have to mux them off in device drivers later on
+	 * if not needed.
+	 */
+	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++) {
+		struct plat_serial8250_port *p = serial_platform_data + i;
+
+		if (!(info->enabled_uarts & (1 << i))) {
+			p->flags = 0;
+			continue;
+		}
+
+		if (cpu_is_davinci_dm646x())
+			p->iotype = UPIO_MEM32;
+
+		if (cpu_is_davinci_dm355()) {
+			if (i == 2) {
+				p->mapbase = (unsigned long)DM355_UART2_BASE;
+				p->irq = IRQ_DM355_UARTINT2;
+			}
+		}
+
+		if (cpu_is_da8xx()) {
+			if (i == 0) {
+				p->membase = (char *)
+					IO_ADDRESS(DA8XX_UART0_BASE);
+				p->mapbase = (unsigned long)DA8XX_UART0_BASE;
+				p->irq = IRQ_DA8XX_UARTINT0;
+			}
+			if (i == 1) {
+				p->membase = (char *)
+					IO_ADDRESS(DA8XX_UART1_BASE);
+				p->mapbase = (unsigned long)DA8XX_UART1_BASE;
+				p->irq = IRQ_DA8XX_UARTINT1;
+			}
+			if (i == 2) {
+				p->membase = (char *)
+					IO_ADDRESS(DA8XX_UART2_BASE);
+				p->mapbase = (unsigned long)DA8XX_UART2_BASE;
+				p->irq = IRQ_DA8XX_UARTINT2;
+			}
+		}
+
+		sprintf(name, "uart%d", i);
+		uart_clk = clk_get(dev, name);
+		p->uartclk = clk_get_rate(uart_clk);
+		if (IS_ERR(uart_clk))
+			printk(KERN_ERR "%s:%d: failed to get UART%d clock\n",
+					__func__, __LINE__, i);
+		else {
+			clk_enable(uart_clk);
+			davinci_serial_reset(p);
+		}
+	}
 }
 
 static int __init davinci_init(void)
 {
-	davinci_serial_reset(&serial_platform_data[0]);
 	return platform_device_register(&serial_device);
 }
 
-- 
1.6.5.2

