From 4195dedc22db1367514fc0db0c7b7e54d3180e4a Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 5 Nov 2009 17:53:05 +0800
Subject: [PATCH 03/43] Davinci: update pin-multiplexing support

commit 5526b3f7e3317bdd0dcc0483214935ae64236efb in mainline.

Update MUX support to be more general and useful across multiple
SoCs in the DaVinci family.

Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/Kconfig            |   25 ++
 arch/arm/mach-davinci/Makefile           |    1 +
 arch/arm/mach-davinci/da850.c            |  272 ++++++++++++++
 arch/arm/mach-davinci/include/mach/mux.h |  596 +++++++++++++++++++++++++++---
 arch/arm/mach-davinci/mux.c              |  141 ++++++-
 arch/arm/mach-davinci/mux.h              |   64 ++++
 6 files changed, 1034 insertions(+), 65 deletions(-)
 create mode 100644 arch/arm/mach-davinci/mux.h

diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index efccceb..00b0737 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -58,6 +58,31 @@ config MACH_DA850_EVM
 	  Configure this option to specify the whether the board used
 	  for development is a DA850/OMAP-L138 EVM
 
+config DAVINCI_MUX
+	bool "DAVINCI multiplexing support"
+	depends on ARCH_DAVINCI
+	default y
+	help
+	  Pin multiplexing support for DAVINCI boards. If your bootloader
+	  sets the multiplexing correctly, say N. Otherwise, or if unsure,
+	  say Y.
+
+config DAVINCI_MUX_DEBUG
+        bool "Multiplexing debug output"
+        depends on DAVINCI_MUX
+        help
+          Makes the multiplexing functions print out a lot of debug info.
+          This is useful if you want to find out the correct values of the
+          multiplexing registers.
+
+config DAVINCI_MUX_WARNINGS
+        bool "Warn about pins the bootloader didn't set up"
+        depends on DAVINCI_MUX
+        help
+          Choose Y here to warn whenever driver initialization logic needs
+          to change the pin multiplexing setup.  When there are no warnings
+          printed, it's safe to deselect DAVINCI_MUX for your product.
+
 config DAVINCI_RESET_CLOCKS
 	bool "Reset unused clocks during boot"
 	depends on ARCH_DAVINCI
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index f3f9c71..2dee021 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -6,6 +6,7 @@
 # Common objects
 obj-y 			:= time.o clock.o io.o id.o psc.o
 
+obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
 
 obj-$(CONFIG_ARCH_DA830)		+= da830.o
 obj-$(CONFIG_ARCH_DA850)		+= da850.o
diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index b0af6f4..b4d5a47 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -19,9 +19,11 @@
 #include <mach/cpu.h>
 #include <mach/irqs.h>
 #include <mach/psc.h>
+#include <mach/mux.h>
 #include <mach/io.h>
 
 #include "clock.h"
+#include "mux.h"
 
 /*
  * Device specific clocks
@@ -357,6 +359,274 @@ static struct clk *da850_clks[] = {
 	&sata_clk,
 };
 
+static unsigned long pinmux_in_use[20];
+
+/*
+ *		soc	description	mux  mode   mode  mux	 dbg
+ *					reg  offset mask  mode
+ */
+static const struct mux_config davinci_da850_pins[] = {
+	/* UART0 function */
+	DA8XX_MUX_CFG(DA850,	NUART0_CTS,	3,   24,    15,	  2,	 false)
+	DA8XX_MUX_CFG(DA850,	NUART0_RTS,	3,   28,    15,	  2,	 false)
+	DA8XX_MUX_CFG(DA850,	UART0_RXD,	3,   16,    15,	  2,	 false)
+	DA8XX_MUX_CFG(DA850,	UART0_TXD,	3,   20,    15,	  2,	 false)
+	/* UART1 function */
+	DA8XX_MUX_CFG(DA850,	NUART1_CTS,	0,   20,    15,	  4,	 false)
+	DA8XX_MUX_CFG(DA850,	NUART1_RTS,	0,   16,    15,	  4,	 false)
+	DA8XX_MUX_CFG(DA850,	UART1_RXD,	4,   24,    15,	  2,	 false)
+	DA8XX_MUX_CFG(DA850,	UART1_TXD,	4,   28,    15,	  2,	 false)
+	/* UART2 function */
+	DA8XX_MUX_CFG(DA850,	NUART2_CTS,	0,   28,    15,	  4,	 false)
+	DA8XX_MUX_CFG(DA850,	NUART2_RTS,	0,   24,    15,	  4,	 false)
+	DA8XX_MUX_CFG(DA850,	UART2_RXD,	4,   16,    15,	  2,	 false)
+	DA8XX_MUX_CFG(DA850,	UART2_TXD,	4,   20,    15,	  2,	 false)
+	/* EMAC function */
+	DA8XX_MUX_CFG(DA850,	RMII_TXD_0,	14,  12,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_TXD_1,	14,  8,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_TXEN,	14,  16,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_CRS_DV,	15,  4,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_RXD_0,	14,  24,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_RXD_1,	14,  20,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_RXER,	14,  28,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	RMII_MHZ_50_CLK, 15,  0,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MDIO_CLK,	4,   0,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MDIO_D,		4,   4,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXEN,	2,   4,     15,	  8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXCLK,	2,   8,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_COL,	2,   12,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXD_3,	2,   16,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXD_2,	2,   20,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXD_1,	2,   24,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_TXD_0,	2,   28,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXCLK,	3,   0,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXDV,	3,   4,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXER,	3,   8,     15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_CRS,	3,   12,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXD_3,	3,   16,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXD_2,	3,   20,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXD_1,	3,   24,    15,   8,     false)
+	DA8XX_MUX_CFG(DA850,	MII_RXD_0,	3,   28,    15,   8,     false)
+	/* I2C1 function */
+	DA8XX_MUX_CFG(DA850,	I2C1_SCL,	4,   16,    15,   4,     false)
+	DA8XX_MUX_CFG(DA850,	I2C1_SDA,	4,   20,    15,   4,     false)
+	/* I2C0 function */
+	DA8XX_MUX_CFG(DA850,	I2C0_SDA,	4,   12,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	I2C0_SCL,	4,   8,     15,   2,     false)
+	/* MMC/SD0 function */
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_0,	10,  8,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_1,	10,  12,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_2,	10,  16,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_3,	10,  20,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_4,	10,  24,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_5,	10,  28,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_6,	11,  0,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_DAT_7,	11,  4,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_CLK,	10,  0,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD0_CMD,	10,  4,     15,   2,     false)
+	/* MMC/SD1 function */
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_0,	18,  8,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_1,	19,  16,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_2,	19,  12,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_3,	19,  8,     15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_4,	19,  4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_5,	19,  0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_6,	18,  28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_DAT_7,	18,  24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_CLK,	18,  12,    15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	MMCSD1_CMD,	18,  16,    15,   2,     false)
+	/* EMIF2.5/EMIFA function */
+	DA8XX_MUX_CFG(DA850,	EMA_D_7,	9,   0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_6,	9,   4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_5,	9,   8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_4,	9,   12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_3,	9,   16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_2,	9,   20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_1,	9,   24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_0,	9,   28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_8,	8,   28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_9,	8,   24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_10,	8,   20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_11,	8,   16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_12,	8,   12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_13,	8,   8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_14,	8,   4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_D_15,	8,   0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_0,	12,  28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_1,	12,  24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_2,	12,  20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_3,	12,  16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_4,	12,  12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_5,	12,  8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_6,	12,  4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_7,	12,  0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_8,	11,  28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_9,	11,  24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_10,	11,  20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_11,	11,  16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_12,	11,  12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_13,	11,  8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_14,	11,  4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_15,	11,  0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_16,	10,  28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_17,	10,  24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_18,	10,  20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_19,	10,  16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_20,	10,  12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_21,	10,  8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_22,	10,  4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_A_23,	10,  0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_BA_1,	5,   24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_BA_0,	5,   28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_CLK,	6,   0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_SDCKE,	6,   4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_RAS,	6,   8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CAS,	6,   12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_WE_DQM_0,	6,   16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_WE_DQM_1,	6,   20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_WAIT_1,	6,   24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CS_0,	6,   28,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CS_2,	7,   0,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CS_3,	7,   4,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CS_4,	7,   8,     15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_CS_5,	7,   12,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_WE,	7,   16,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	NEMA_OE,	7,   20,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_RNW,	7,   24,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	EMA_WAIT_0,	7,   28,    15,   1,     false)
+	/* EMIF3a/EMIFB function - pins are not muxed */
+	/* SPI0 function */
+	DA8XX_MUX_CFG(DA850,	SPI0_CLK,	3,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_ENA,	3,   4,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_SOMI,	3,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_SIMO,	3,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_5,	3,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_4,	3,   20,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_3,	3,   24,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_2,	3,   28,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_1,	4,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI0_CS_0,	4,   4,    15,   1,     false)
+	/* SPI1 function */
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_7,	4,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_6,	4,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_5,	4,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_4,	4,   20,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_3,	4,   24,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_2,	4,   28,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_1,	5,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CS_0,	5,   4,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_CLK,	5,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_ENA,	5,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_SOMI,	5,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	SPI1_SIMO,	5,   20,   15,   1,     false)
+	/* McASP function */
+	DA8XX_MUX_CFG(DA850,	MCASP_ACLKR,	0,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_ACLKX,	0,   4,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AFSR,	0,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AFSX,	0,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AHCLKR,	0,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AHCLKX,	0,   20,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AMUTE,	0,   24,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_15,	1,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_14,	1,   4,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_13,	1,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_12,	1,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_11,	1,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_10,	1,   20,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_9,	1,   24,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_8,	1,   28,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_7,	2,   0,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_6,	2,   4,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_5,	2,   8,    15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_4,	2,   12,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_3,	2,   16,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_2,	2,   20,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_1,	2,   24,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	MCASP_AXR_0,	2,   28,   15,   1,     false)
+	/* LCD function */
+	DA8XX_MUX_CFG(DA850,	LCD_D_7,	16,   8,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_6,	16,   12,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_5,	16,   16,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_4,	16,   20,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_3,	16,   24,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_2,	16,   28,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_1,	17,   0,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_0,	17,   4,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_15,	17,   8,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_14,	17,   12,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_13,	17,   16,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_12,	17,   20,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_11,	17,   24,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_10,	17,   28,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_9,	18,   0,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_D_8,	18,   4,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_PCLK,	18,   24,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_MCLK,	18,   28,  15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_HSYNC,	19,   0,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	LCD_VSYNC,	19,   4,   15,   2,     false)
+	DA8XX_MUX_CFG(DA850,	NLCD_AC_ENB_CS,	19,   24,  15,   2,     false)
+	/* VPIF function */
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKIN0,	14,   0,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKIN1,	14,   4,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_7,	14,   8,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_6,	14,   12,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_5,	14,   16,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_4,	14,   20,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_3,	14,   24,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_2,	14,   28,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_1,	15,   0,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_0,	15,   4,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_15_V,	15,   8,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_14_H,	15,   12,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_13_FLD, 15,   16,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_12,	15,   20,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_11,	15,   24,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_10,	15,   28,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_9,	16,   0,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DIN_8,	16,   4,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_7,	16,   8,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_6,	16,   12,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_5,	16,   16,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_4,	16,   20,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_3,	16,   24,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_2,	16,   28,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_1,	17,   0,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_0,	17,   4,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_15,	17,   8,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_14,	17,   12,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_13,	17,   16,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_12,	17,   20,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_11,	17,   24,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_10,	17,   28,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_9,	18,   0,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_DOUT_8,	18,   4,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKIN_2,	19,   8,   15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKO_2,	19,   12,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKIN_3,	19,   16,  15,   1,     false)
+	DA8XX_MUX_CFG(DA850,	VPIF_CLKO_3,	19,   20,  15,   1,     false)
+	/* Timer0 function */
+	DA8XX_MUX_CFG(DA850,	TM64P0_IN12,	4,    0,   15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	TM64P0_OUT12,	4,    0,   15,   2,     false)
+	/* Timer1 function */
+	DA8XX_MUX_CFG(DA850,	TM64P1_IN12,	4,    4,   15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	TM64P1_OUT12,	4,    4,   15,   2,     false)
+	/* Timer2 function */
+	DA8XX_MUX_CFG(DA850,	TM64P2_IN12,	5,    0,   15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	TM64P2_OUT12,	4,    8,   15,   4,     false)
+	/* Timer3 function */
+	DA8XX_MUX_CFG(DA850,	TM64P3_IN12,	5,    4,   15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	TM64P3_OUT12,	4,    12,  15,   4,     false)
+	/* SATA function */
+	DA8XX_MUX_CFG(DA850,	SATA_MP_SWITCH,	3,    24,  15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	SATA_CP_DET,	3,    28,  15,   0,     false)
+	DA8XX_MUX_CFG(DA850,	SATA_LED,	4,    24,  15,   4,     false)
+	DA8XX_MUX_CFG(DA850,	SATA_CP_POD,	4,    28,  15,   4,     false)
+	/* GPIO function */
+	DA8XX_MUX_CFG(DA850,	GPIO4_0,	10,   28,  15,   8,	false)
+	DA8XX_MUX_CFG(DA850,	GPIO4_1,	10,   24,  15,   8,	false)
+	DA8XX_MUX_CFG(DA850,	GPIO2_15,	5,    0,   15,   8,	false)
+	DA8XX_MUX_CFG(DA850,	GPIO8_10,	18,   28,  15,   8,	false)
+};
 
 int get_async3_src(void)
 {
@@ -368,5 +638,7 @@ int get_async3_src(void)
 void __init da850_init(void)
 {
 	davinci_clk_init(da850_clks, ARRAY_SIZE(da850_clks));
+	davinci_mux_register(davinci_da850_pins, ARRAY_SIZE(davinci_da850_pins),
+				pinmux_in_use);
 }
 
diff --git a/arch/arm/mach-davinci/include/mach/mux.h b/arch/arm/mach-davinci/include/mach/mux.h
index c24b678..d8d80f9 100644
--- a/arch/arm/mach-davinci/include/mach/mux.h
+++ b/arch/arm/mach-davinci/include/mach/mux.h
@@ -1,55 +1,559 @@
 /*
- * DaVinci pin multiplexing defines
+ * Table of the DAVINCI register configurations for the PINMUX combinations
  *
  * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
  *
+ * Based on linux/include/asm-arm/arch-omap/mux.h:
+ * Copyright (C) 2003 - 2005 Nokia Corporation
+ *
+ * Written by Tony Lindgren
+ *
  * 2007 (c) MontaVista Software, Inc. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
  */
-#ifndef __ASM_ARCH_MUX_H
-#define __ASM_ARCH_MUX_H
-
-#define DAVINCI_MUX_AEAW0	0
-#define DAVINCI_MUX_AEAW1	1
-#define DAVINCI_MUX_AEAW2	2
-#define DAVINCI_MUX_AEAW3	3
-#define DAVINCI_MUX_AEAW4	4
-#define DAVINCI_MUX_AECS4	10
-#define DAVINCI_MUX_AECS5	11
-#define DAVINCI_MUX_VLYNQWD0	12
-#define DAVINCI_MUX_VLYNQWD1	13
-#define DAVINCI_MUX_VLSCREN	14
-#define DAVINCI_MUX_VLYNQEN	15
-#define DAVINCI_MUX_HDIREN	16
-#define DAVINCI_MUX_ATAEN	17
-#define DAVINCI_MUX_RGB666	22
-#define DAVINCI_MUX_RGB888	23
-#define DAVINCI_MUX_LOEEN	24
-#define DAVINCI_MUX_LFLDEN	25
-#define DAVINCI_MUX_CWEN	26
-#define DAVINCI_MUX_CFLDEN	27
-#define DAVINCI_MUX_HPIEN	29
-#define DAVINCI_MUX_1394EN	30
-#define DAVINCI_MUX_EMACEN	31
-
-#define DAVINCI_MUX_LEVEL2	32
-#define DAVINCI_MUX_UART0	(DAVINCI_MUX_LEVEL2 + 0)
-#define DAVINCI_MUX_UART1	(DAVINCI_MUX_LEVEL2 + 1)
-#define DAVINCI_MUX_UART2	(DAVINCI_MUX_LEVEL2 + 2)
-#define DAVINCI_MUX_U2FLO	(DAVINCI_MUX_LEVEL2 + 3)
-#define DAVINCI_MUX_PWM0	(DAVINCI_MUX_LEVEL2 + 4)
-#define DAVINCI_MUX_PWM1	(DAVINCI_MUX_LEVEL2 + 5)
-#define DAVINCI_MUX_PWM2	(DAVINCI_MUX_LEVEL2 + 6)
-#define DAVINCI_MUX_I2C		(DAVINCI_MUX_LEVEL2 + 7)
-#define DAVINCI_MUX_SPI		(DAVINCI_MUX_LEVEL2 + 8)
-#define DAVINCI_MUX_MSTK	(DAVINCI_MUX_LEVEL2 + 9)
-#define DAVINCI_MUX_ASP		(DAVINCI_MUX_LEVEL2 + 10)
-#define DAVINCI_MUX_CLK0	(DAVINCI_MUX_LEVEL2 + 16)
-#define DAVINCI_MUX_CLK1	(DAVINCI_MUX_LEVEL2 + 17)
-#define DAVINCI_MUX_TIMIN	(DAVINCI_MUX_LEVEL2 + 18)
-
-extern void davinci_mux_peripheral(unsigned int mux, unsigned int enable);
-
-#endif /* __ASM_ARCH_MUX_H */
+
+#ifndef __INC_MACH_MUX_H
+#define __INC_MACH_MUX_H
+
+/* System module registers */
+#define PINMUX0			0x00
+#define PINMUX1			0x04
+/* dm355 only */
+#define PINMUX2			0x08
+#define PINMUX3			0x0c
+#define PINMUX4			0x10
+#define INTMUX			0x18
+#define EVTMUX			0x1c
+
+struct mux_config {
+	char *name;
+	const char *mux_reg_name;
+	const unsigned int mux_reg;
+	const unsigned char reg_index;
+	const unsigned char mask_offset;
+	const unsigned char mask;
+	const unsigned char mode;
+	bool debug;
+};
+
+enum davinci_da830_index {
+	/* UART0 function */
+	DA830_NUART0_CTS,
+	DA830_NUART0_RTS,
+	DA830_UART0_RXD,
+	DA830_UART0_TXD,
+
+	/* UART1 function */
+	DA830_UART1_RXD,
+	DA830_UART1_TXD,
+
+	/* UART2 function */
+	DA830_UART2_RXD,
+	DA830_UART2_TXD,
+
+	/* I2C function */
+	DA830_I2C1_SCL,
+	DA830_I2C1_SDA,
+	DA830_I2C0_SDA,
+	DA830_I2C0_SCL,
+
+	/* EMAC function */
+	DA830_RMII_TXD_0,
+	DA830_RMII_TXD_1,
+	DA830_RMII_TXEN,
+	DA830_RMII_CRS_DV,
+	DA830_RMII_RXD_0,
+	DA830_RMII_RXD_1,
+	DA830_RMII_RXER,
+	DA830_MDIO_CLK,
+	DA830_MDIO_D,
+
+	/* MMC/SD function */
+	DA830_MMCSD_DAT_0,
+	DA830_MMCSD_DAT_1,
+	DA830_MMCSD_DAT_2,
+	DA830_MMCSD_DAT_3,
+	DA830_MMCSD_DAT_4,
+	DA830_MMCSD_DAT_5,
+	DA830_MMCSD_DAT_6,
+	DA830_MMCSD_DAT_7,
+	DA830_MMCSD_CLK,
+	DA830_MMCSD_CMD,
+
+	/* EMIFA function */
+	DA830_EMA_D_0,
+	DA830_EMA_D_1,
+	DA830_EMA_D_2,
+	DA830_EMA_D_3,
+	DA830_EMA_D_4,
+	DA830_EMA_D_5,
+	DA830_EMA_D_6,
+	DA830_EMA_D_7,
+	DA830_EMA_D_8,
+	DA830_EMA_D_9,
+	DA830_EMA_D_10,
+	DA830_EMA_D_11,
+	DA830_EMA_D_12,
+	DA830_EMA_D_13,
+	DA830_EMA_D_14,
+	DA830_EMA_D_15,
+	DA830_EMA_A_0,
+	DA830_EMA_A_1,
+	DA830_EMA_A_2,
+	DA830_EMA_A_3,
+	DA830_EMA_A_4,
+	DA830_EMA_A_5,
+	DA830_EMA_A_6,
+	DA830_EMA_A_7,
+	DA830_EMA_A_8,
+	DA830_EMA_A_9,
+	DA830_EMA_A_10,
+	DA830_EMA_A_11,
+	DA830_EMA_A_12,
+	DA830_EMA_BA_1,
+	DA830_EMA_BA_0,
+	DA830_EMA_CLK,
+	DA830_EMA_SDCKE,
+	DA830_NEMA_CAS,
+	DA830_NEMA_CS_4,
+	DA830_NEMA_RAS,
+	DA830_NEMA_WE,
+	DA830_NEMA_CS_0,
+	DA830_NEMA_CS_2,
+	DA830_NEMA_CS_3,
+	DA830_NEMA_OE,
+	DA830_NEMA_WE_DQM_1,
+	DA830_NEMA_WE_DQM_0,
+	DA830_NEMA_CS_5,
+	DA830_EMA_WAIT_0,
+
+	/* EMIFB function */
+	DA830_EMB_SDCKE,
+	DA830_EMB_CLK_GLUE,
+	DA830_EMB_CLK,
+	DA830_NEMB_CS_0,
+	DA830_NEMB_CAS,
+	DA830_NEMB_RAS,
+	DA830_NEMB_WE,
+	DA830_EMB_BA_1,
+	DA830_EMB_BA_0,
+	DA830_EMB_A_0,
+	DA830_EMB_A_1,
+	DA830_EMB_A_2,
+	DA830_EMB_A_3,
+	DA830_EMB_A_4,
+	DA830_EMB_A_5,
+	DA830_EMB_A_6,
+	DA830_EMB_A_7,
+	DA830_EMB_A_8,
+	DA830_EMB_A_9,
+	DA830_EMB_A_10,
+	DA830_EMB_A_11,
+	DA830_EMB_A_12,
+	DA830_EMB_D_31,
+	DA830_EMB_D_30,
+	DA830_EMB_D_29,
+	DA830_EMB_D_28,
+	DA830_EMB_D_27,
+	DA830_EMB_D_26,
+	DA830_EMB_D_25,
+	DA830_EMB_D_24,
+	DA830_EMB_D_23,
+	DA830_EMB_D_22,
+	DA830_EMB_D_21,
+	DA830_EMB_D_20,
+	DA830_EMB_D_19,
+	DA830_EMB_D_18,
+	DA830_EMB_D_17,
+	DA830_EMB_D_16,
+	DA830_NEMB_WE_DQM_3,
+	DA830_NEMB_WE_DQM_2,
+	DA830_EMB_D_0,
+	DA830_EMB_D_1,
+	DA830_EMB_D_2,
+	DA830_EMB_D_3,
+	DA830_EMB_D_4,
+	DA830_EMB_D_5,
+	DA830_EMB_D_6,
+	DA830_EMB_D_7,
+	DA830_EMB_D_8,
+	DA830_EMB_D_9,
+	DA830_EMB_D_10,
+	DA830_EMB_D_11,
+	DA830_EMB_D_12,
+	DA830_EMB_D_13,
+	DA830_EMB_D_14,
+	DA830_EMB_D_15,
+	DA830_NEMB_WE_DQM_1,
+	DA830_NEMB_WE_DQM_0,
+
+	/* SPI0 function */
+	DA830_SPI0_SOMI_0,
+	DA830_SPI0_SIMO_0,
+	DA830_SPI0_CLK,
+	DA830_NSPI0_ENA,
+	DA830_NSPI0_SCS_0,
+
+	/* SPI1 function */
+	DA830_SPI1_SOMI_0,
+	DA830_SPI1_SIMO_0,
+	DA830_SPI1_CLK,
+	DA830_NSPI1_ENA,
+	DA830_NSPI1_SCS_0,
+	DA830_GPIO3_10,
+
+	/* LCD function */
+	DA830_LCD_D_8,
+	DA830_LCD_D_9,
+	DA830_LCD_D_7,
+	DA830_LCD_D_10,
+	DA830_LCD_D_11,
+	DA830_LCD_D_12,
+	DA830_LCD_D_13,
+	DA830_LCD_D_14,
+	DA830_LCD_D_15,
+	DA830_LCD_D_6,
+	DA830_LCD_D_3,
+	DA830_LCD_D_2,
+	DA830_LCD_D_1,
+	DA830_LCD_D_0,
+	DA830_LCD_PCLK,
+	DA830_LCD_HSYNC,
+	DA830_LCD_VSYNC,
+	DA830_NLCD_AC_ENB_CS,
+	DA830_LCD_MCLK,
+	DA830_LCD_D_5,
+	DA830_LCD_D_4,
+
+	/* McASP */
+
+	DA830_AXR1_10,
+	DA830_AXR1_11,
+	DA830_AHCLKX1,
+	DA830_ACLKX1,
+	DA830_AFSX1,
+	DA830_AHCLKR1,
+	DA830_ACLKR1,
+	DA830_AFSR1,
+	DA830_AMUTE1,
+	DA830_AXR1_0,
+	DA830_AXR1_1,
+	DA830_AXR1_2,
+	DA830_AXR1_3,
+	DA830_AXR1_4,
+	DA830_AXR1_5,
+	DA830_AXR1_6,
+	DA830_AXR1_7,
+	DA830_AXR1_8,
+	DA830_AXR1_9,
+
+	/* USB0 DRVVBUS index */
+	DA830_USB0_DRVVBUS,
+};
+
+enum davinci_da850_index {
+
+	/* UART0 function */
+	DA850_NUART0_CTS,
+	DA850_NUART0_RTS,
+	DA850_UART0_RXD,
+	DA850_UART0_TXD,
+
+	/* UART1 function */
+	DA850_NUART1_CTS,
+	DA850_NUART1_RTS,
+	DA850_UART1_RXD,
+	DA850_UART1_TXD,
+
+	/* UART2 function */
+	DA850_NUART2_CTS,
+	DA850_NUART2_RTS,
+	DA850_UART2_RXD,
+	DA850_UART2_TXD,
+
+	/* EMAC function */
+	DA850_RMII_TXD_0,
+	DA850_RMII_TXD_1,
+	DA850_RMII_TXEN,
+	DA850_RMII_CRS_DV,
+	DA850_RMII_RXD_0,
+	DA850_RMII_RXD_1,
+	DA850_RMII_RXER,
+	DA850_RMII_MHZ_50_CLK,
+	DA850_MDIO_CLK,
+	DA850_MDIO_D,
+	DA850_MII_TXEN,
+	DA850_MII_TXCLK,
+	DA850_MII_COL,
+	DA850_MII_TXD_3,
+	DA850_MII_TXD_2,
+	DA850_MII_TXD_1,
+	DA850_MII_TXD_0,
+	DA850_MII_RXER,
+	DA850_MII_CRS,
+	DA850_MII_RXCLK,
+	DA850_MII_RXDV,
+	DA850_MII_RXD_3,
+	DA850_MII_RXD_2,
+	DA850_MII_RXD_1,
+	DA850_MII_RXD_0,
+
+	/* I2C1 function */
+	DA850_I2C1_SCL,
+	DA850_I2C1_SDA,
+
+	/* I2C0 function */
+	DA850_I2C0_SDA,
+	DA850_I2C0_SCL,
+
+	/* MMC/SD0 function */
+	DA850_MMCSD0_DAT_0,
+	DA850_MMCSD0_DAT_1,
+	DA850_MMCSD0_DAT_2,
+	DA850_MMCSD0_DAT_3,
+	DA850_MMCSD0_DAT_4,
+	DA850_MMCSD0_DAT_5,
+	DA850_MMCSD0_DAT_6,
+	DA850_MMCSD0_DAT_7,
+	DA850_MMCSD0_CLK,
+	DA850_MMCSD0_CMD,
+
+	/* MMC/SD1 function */
+	DA850_MMCSD1_DAT_0,
+	DA850_MMCSD1_DAT_1,
+	DA850_MMCSD1_DAT_2,
+	DA850_MMCSD1_DAT_3,
+	DA850_MMCSD1_DAT_4,
+	DA850_MMCSD1_DAT_5,
+	DA850_MMCSD1_DAT_6,
+	DA850_MMCSD1_DAT_7,
+	DA850_MMCSD1_CLK,
+	DA850_MMCSD1_CMD,
+
+	/* EMIF2.5/EMIFA function */
+	DA850_EMA_D_7,
+	DA850_EMA_D_6,
+	DA850_EMA_D_5,
+	DA850_EMA_D_4,
+	DA850_EMA_D_3,
+	DA850_EMA_D_2,
+	DA850_EMA_D_1,
+	DA850_EMA_D_0,
+	DA850_EMA_D_8,
+	DA850_EMA_D_9,
+	DA850_EMA_D_10,
+	DA850_EMA_D_11,
+	DA850_EMA_D_12,
+	DA850_EMA_D_13,
+	DA850_EMA_D_14,
+	DA850_EMA_D_15,
+	DA850_EMA_A_0,
+	DA850_EMA_A_1,
+	DA850_EMA_A_2,
+	DA850_EMA_A_3,
+	DA850_EMA_A_4,
+	DA850_EMA_A_5,
+	DA850_EMA_A_6,
+	DA850_EMA_A_7,
+	DA850_EMA_A_8,
+	DA850_EMA_A_9,
+	DA850_EMA_A_10,
+	DA850_EMA_A_11,
+	DA850_EMA_A_12,
+	DA850_EMA_A_13,
+	DA850_EMA_A_14,
+	DA850_EMA_A_15,
+	DA850_EMA_A_16,
+	DA850_EMA_A_17,
+	DA850_EMA_A_18,
+	DA850_EMA_A_19,
+	DA850_EMA_A_20,
+	DA850_EMA_A_21,
+	DA850_EMA_A_22,
+	DA850_EMA_A_23,
+	DA850_EMA_BA_1,
+	DA850_EMA_BA_0,
+	DA850_EMA_CLK,
+	DA850_EMA_SDCKE,
+	DA850_NEMA_RAS,
+	DA850_NEMA_CAS,
+	DA850_NEMA_WE_DQM_0,
+	DA850_NEMA_WE_DQM_1,
+	DA850_EMA_WAIT_1,
+	DA850_NEMA_CS_0,
+	DA850_NEMA_CS_2,
+	DA850_NEMA_CS_3,
+	DA850_NEMA_CS_4,
+	DA850_NEMA_CS_5,
+	DA850_NEMA_WE,
+	DA850_NEMA_OE,
+	DA850_EMA_RNW,
+	DA850_EMA_WAIT_0,
+
+	/* EMIF3a/EMIFB function - pins are not muxed */
+
+	/* SPI0 function */
+	DA850_SPI0_CLK,
+	DA850_SPI0_ENA,
+	DA850_SPI0_SOMI,
+	DA850_SPI0_SIMO,
+	DA850_SPI0_CS_5,
+	DA850_SPI0_CS_4,
+	DA850_SPI0_CS_3,
+	DA850_SPI0_CS_2,
+	DA850_SPI0_CS_1,
+	DA850_SPI0_CS_0,
+
+	/* SPI1 function */
+	DA850_SPI1_CS_7,
+	DA850_SPI1_CS_6,
+	DA850_SPI1_CS_5,
+	DA850_SPI1_CS_4,
+	DA850_SPI1_CS_3,
+	DA850_SPI1_CS_2,
+	DA850_SPI1_CS_1,
+	DA850_SPI1_CS_0,
+	DA850_SPI1_CLK,
+	DA850_SPI1_ENA,
+	DA850_SPI1_SOMI,
+	DA850_SPI1_SIMO,
+
+	/* McASP function */
+	DA850_MCASP_ACLKR,
+	DA850_MCASP_ACLKX,
+	DA850_MCASP_AFSR,
+	DA850_MCASP_AFSX,
+	DA850_MCASP_AHCLKR,
+	DA850_MCASP_AHCLKX,
+	DA850_MCASP_AMUTE,
+	DA850_MCASP_AXR_15,
+	DA850_MCASP_AXR_14,
+	DA850_MCASP_AXR_13,
+	DA850_MCASP_AXR_12,
+	DA850_MCASP_AXR_11,
+	DA850_MCASP_AXR_10,
+	DA850_MCASP_AXR_9,
+	DA850_MCASP_AXR_8,
+	DA850_MCASP_AXR_7,
+	DA850_MCASP_AXR_6,
+	DA850_MCASP_AXR_5,
+	DA850_MCASP_AXR_4,
+	DA850_MCASP_AXR_3,
+	DA850_MCASP_AXR_2,
+	DA850_MCASP_AXR_1,
+	DA850_MCASP_AXR_0,
+
+	/* LCD function */
+	DA850_LCD_D_7,
+	DA850_LCD_D_6,
+	DA850_LCD_D_5,
+	DA850_LCD_D_4,
+	DA850_LCD_D_3,
+	DA850_LCD_D_2,
+	DA850_LCD_D_1,
+	DA850_LCD_D_0,
+	DA850_LCD_D_15,
+	DA850_LCD_D_14,
+	DA850_LCD_D_13,
+	DA850_LCD_D_12,
+	DA850_LCD_D_11,
+	DA850_LCD_D_10,
+	DA850_LCD_D_9,
+	DA850_LCD_D_8,
+	DA850_LCD_PCLK,
+	DA850_LCD_MCLK,
+	DA850_LCD_HSYNC,
+	DA850_LCD_VSYNC,
+	DA850_NLCD_AC_ENB_CS,
+
+	/* VPIF function */
+	DA850_VPIF_CLKIN0,
+	DA850_VPIF_CLKIN1,
+	DA850_VPIF_DIN_7,
+	DA850_VPIF_DIN_6,
+	DA850_VPIF_DIN_5,
+	DA850_VPIF_DIN_4,
+	DA850_VPIF_DIN_3,
+	DA850_VPIF_DIN_2,
+	DA850_VPIF_DIN_1,
+	DA850_VPIF_DIN_0,
+	DA850_VPIF_DIN_15_V,
+	DA850_VPIF_DIN_14_H,
+	DA850_VPIF_DIN_13_FLD,
+	DA850_VPIF_DIN_12,
+	DA850_VPIF_DIN_11,
+	DA850_VPIF_DIN_10,
+	DA850_VPIF_DIN_9,
+	DA850_VPIF_DIN_8,
+	DA850_VPIF_DOUT_7,
+	DA850_VPIF_DOUT_6,
+	DA850_VPIF_DOUT_5,
+	DA850_VPIF_DOUT_4,
+	DA850_VPIF_DOUT_3,
+	DA850_VPIF_DOUT_2,
+	DA850_VPIF_DOUT_1,
+	DA850_VPIF_DOUT_0,
+	DA850_VPIF_DOUT_15,
+	DA850_VPIF_DOUT_14,
+	DA850_VPIF_DOUT_13,
+	DA850_VPIF_DOUT_12,
+	DA850_VPIF_DOUT_11,
+	DA850_VPIF_DOUT_10,
+	DA850_VPIF_DOUT_9,
+	DA850_VPIF_DOUT_8,
+	DA850_VPIF_CLKIN_2,
+	DA850_VPIF_CLKO_2,
+	DA850_VPIF_CLKIN_3,
+	DA850_VPIF_CLKO_3,
+
+	/* Timer0 function */
+	DA850_TM64P0_IN12,
+	DA850_TM64P0_OUT12,
+
+	/* Timer1 function */
+	DA850_TM64P1_IN12,
+	DA850_TM64P1_OUT12,
+
+	/* Timer2 function */
+	DA850_TM64P2_IN12,
+	DA850_TM64P2_OUT12,
+
+	/* Timer3 function */
+	DA850_TM64P3_IN12,
+	DA850_TM64P3_OUT12,
+
+	/* SATA function */
+	DA850_SATA_MP_SWITCH,
+	DA850_SATA_CP_DET,
+	DA850_SATA_LED,
+	DA850_SATA_CP_POD,
+
+	/* GPIO function */
+	DA850_GPIO4_0,
+	DA850_GPIO4_1,
+	DA850_GPIO2_15,
+	DA850_GPIO8_10,
+
+	/* USB0 DRVVBUS index */
+	DA850_USB0_DRVVBUS,
+};
+
+#ifdef CONFIG_DAVINCI_MUX
+/* setup pin muxing */
+extern void davinci_mux_init(void);
+extern int davinci_mux_register(const struct mux_config *pins,
+				unsigned long size, unsigned long *in_use);
+extern int davinci_cfg_reg(unsigned long reg_cfg);
+#else
+/* boot loader does it all (no warnings from CONFIG_DAVINCI_MUX_WARNINGS) */
+static inline void davinci_mux_init(void) {}
+static inline int davinci_mux_register(const struct mux_config *pins,
+		unsigned long size, unsigned long *in_use) { return 0; }
+static inline int davinci_cfg_reg(unsigned long reg_cfg) { return 0; }
+#endif
+
+#endif /* __INC_MACH_MUX_H */
diff --git a/arch/arm/mach-davinci/mux.c b/arch/arm/mach-davinci/mux.c
index 8ff9d8a..6510881 100644
--- a/arch/arm/mach-davinci/mux.c
+++ b/arch/arm/mach-davinci/mux.c
@@ -1,41 +1,144 @@
 /*
- * DaVinci pin multiplexing configurations
+ * Utility to set the DAVINCI MUX register from a table in mux.h
  *
  * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
  *
+ * Based on linux/arch/arm/plat-omap/mux.c:
+ * Copyright (C) 2003 - 2005 Nokia Corporation
+ *
+ * Written by Tony Lindgren
+ *
  * 2007 (c) MontaVista Software, Inc. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
  */
 #include <linux/io.h>
+#include <linux/module.h>
 #include <linux/spinlock.h>
 
 #include <mach/hardware.h>
-
+#include <mach/da8xx.h>
+#include <mach/cpu.h>
 #include <mach/mux.h>
 
-/* System control register offsets */
-#define PINMUX0         0x00
-#define PINMUX1         0x04
+static unsigned long *pinmux_in_use;
+static const struct mux_config *mux_table;
+static unsigned long pin_table_sz;
 
-static DEFINE_SPINLOCK(mux_lock);
+int __init davinci_mux_register(const struct mux_config *pins,
+				unsigned long size, unsigned long *in_use)
+{
+	mux_table = pins;
+	pin_table_sz = size;
+	pinmux_in_use = in_use;
 
-void davinci_mux_peripheral(unsigned int mux, unsigned int enable)
+	return 0;
+}
+
+static int davinci_find_index(unsigned int mux_reg, unsigned long mask)
 {
-	u32 pinmux, muxreg = PINMUX0;
+	unsigned long cur_mask;
+	int i;
+
+	for (i = 0; i < pin_table_sz; i++) {
+		cur_mask = mux_table[i].mode << mux_table[i].mask_offset;
+		if (mux_table[i].mux_reg == mux_reg && cur_mask == mask)
+			return i;
+	}
+	return -1;
+}
+
+/*
+ * Sets the DAVINCI MUX register based on the table
+ */
+int __init_or_module davinci_cfg_reg(const unsigned long index)
+{
+	static DEFINE_SPINLOCK(mux_spin_lock);
+	void __iomem *base = IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE);
+	unsigned long flags;
+	const struct mux_config *cfg;
+	unsigned int reg_orig = 0, reg = 0;
+	unsigned int mask, warn = 0;
+	int cft;
+	const char *cft_name;
+
+	if (!mux_table)
+		BUG();
+
+	if (cpu_is_da8xx()) {
+		base = IO_ADDRESS(DA8XX_BOOT_CFG_BASE);
+
+		/* Unlock the SYSCFG registers */
+		__raw_writel(DA8XX_KICK0_MAGIC, IO_ADDRESS(DA8XX_KICK0));
+		__raw_writel(DA8XX_KICK1_MAGIC, IO_ADDRESS(DA8XX_KICK1));
+	}
+
+	if (index >= pin_table_sz) {
+		printk(KERN_ERR "Invalid pin mux index: %lu (%lu)\n",
+		       index, pin_table_sz);
+		dump_stack();
+		return -ENODEV;
+	}
+
+	cfg = &mux_table[index];
+
+	if (cfg->name == NULL) {
+		printk(KERN_ERR "No entry for the specified index\n");
+		return -ENODEV;
+	}
+
+	/* Update the mux register in question */
+	if (cfg->mask) {
+		unsigned	tmp1, tmp2;
+
+		spin_lock_irqsave(&mux_spin_lock, flags);
+		reg_orig = __raw_readl(base + cfg->mux_reg);
+
+		mask = (cfg->mask << cfg->mask_offset);
+		tmp1 = reg_orig & mask;
+		reg = reg_orig & ~mask;
+
+		tmp2 = (cfg->mode << cfg->mask_offset);
+		reg |= tmp2;
+
+		if (tmp1 != tmp2)
+			warn = 1;
+
+		if (pinmux_in_use[cfg->reg_index] & mask) {
+			cft = davinci_find_index(cfg->mux_reg, reg_orig & mask);
+			cft_name = cft < 0 ? "???" : mux_table[cft].name;
+
+			if (warn) {
+				printk(KERN_ERR "Pin %s already used for %s.\n",
+					cfg->name, cft_name);
+				spin_unlock_irqrestore(&mux_spin_lock, flags);
+				return -EBUSY;
+			}
+		} else {
+			pinmux_in_use[cfg->reg_index] |= mask;
+		}
+
+		__raw_writel(reg, base + cfg->mux_reg);
+		spin_unlock_irqrestore(&mux_spin_lock, flags);
+	}
+
+	if (warn) {
+#ifdef CONFIG_DAVINCI_MUX_WARNINGS
+		printk(KERN_WARNING "MUX: initialized %s\n", cfg->name);
+#endif
+	}
 
-	if (mux >= DAVINCI_MUX_LEVEL2) {
-		muxreg = PINMUX1;
-		mux -= DAVINCI_MUX_LEVEL2;
+#ifdef CONFIG_DAVINCI_MUX_DEBUG
+	if (cfg->debug || warn) {
+		printk(KERN_WARNING "MUX: Setting register %s\n", cfg->name);
+		printk(KERN_WARNING "	   %s (0x%08x) = 0x%08x -> 0x%08x\n",
+		       cfg->mux_reg_name, cfg->mux_reg, reg_orig, reg);
 	}
+#endif
 
-	spin_lock(&mux_lock);
-	pinmux = davinci_readl(DAVINCI_SYSTEM_MODULE_BASE + muxreg);
-	if (enable)
-		pinmux |= (1 << mux);
-	else
-		pinmux &= ~(1 << mux);
-	davinci_writel(pinmux, DAVINCI_SYSTEM_MODULE_BASE + muxreg);
-	spin_unlock(&mux_lock);
+	return 0;
 }
+EXPORT_SYMBOL(davinci_cfg_reg);
diff --git a/arch/arm/mach-davinci/mux.h b/arch/arm/mach-davinci/mux.h
new file mode 100644
index 0000000..f40208a
--- /dev/null
+++ b/arch/arm/mach-davinci/mux.h
@@ -0,0 +1,64 @@
+/*
+ * Pin-multiplex helper macros for TI DaVinci family devices
+ *
+ * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ */
+#ifndef _MACH_DAVINCI_MUX_H_
+#define _MACH_DAVINCI_MUX_H_
+
+#include <mach/mux.h>
+
+#define MUX_CFG(soc, desc, muxreg, mode_offset, mode_mask, mux_mode, dbg)\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "PINMUX"#muxreg,		\
+			.mux_reg = PINMUX##muxreg,			\
+			.reg_index = muxreg,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#define INT_CFG(soc, desc, mode_offset, mode_mask, mux_mode, dbg)	\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "INTMUX",			\
+			.mux_reg = INTMUX,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#define EVT_CFG(soc, desc, mode_offset, mode_mask, mux_mode, dbg)	\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "EVTMUX",			\
+			.mux_reg = EVTMUX,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#define DA8XX_MUX_CFG(soc, desc, muxreg, mode_offset, mode_mask, mux_mode, dbg)\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "DA8XX_PINMUX"#muxreg,	\
+			.mux_reg = DA8XX_PINMUX##muxreg,		\
+			.reg_index = muxreg,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#endif /* _MACH_DAVINCI_MUX_H */
-- 
1.6.5.2

