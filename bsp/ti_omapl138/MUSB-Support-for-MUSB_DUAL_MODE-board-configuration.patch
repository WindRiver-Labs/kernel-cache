From 61411c96ac145e47284278a0c1cb4714469f56f2 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Fri, 21 May 2010 12:44:49 +0800
Subject: [PATCH 09/23] MUSB: Support for MUSB_DUAL_MODE board configuration.

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.12.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

This patch adds support for DUAL_MODE configuration to MUSB module.
This enables products that need to support host and Device functionality
without the need for OTG feature.

Signed-off-by: Swaminathan S <swami.iyer@ti.com>
Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/usb.c     |    3 +++
 drivers/usb/gadget/Kconfig      |    2 +-
 drivers/usb/musb/Kconfig        |   19 ++++++++++++++++---
 drivers/usb/musb/musb_core.c    |   34 +++++++++++++++++++++++++++++++---
 drivers/usb/musb/musb_core.h    |    3 ++-
 drivers/usb/musb/musb_gadget.c  |    4 ++--
 drivers/usb/musb/musb_virthub.c |    3 ++-
 include/linux/usb/musb.h        |    5 ++++-
 8 files changed, 61 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-davinci/usb.c b/arch/arm/mach-davinci/usb.c
index a5d8377..c729ee1 100644
--- a/arch/arm/mach-davinci/usb.c
+++ b/arch/arm/mach-davinci/usb.c
@@ -46,6 +46,8 @@ static struct musb_hdrc_platform_data usb_data = {
 #if defined(CONFIG_USB_MUSB_OTG)
 	/* OTG requires a Mini-AB connector */
 	.mode           = MUSB_OTG,
+#elif defined(CONFIG_USB_MUSB_DUAL_ROLE)
+	.mode           = MUSB_DUAL_ROLE,
 #elif defined(CONFIG_USB_MUSB_PERIPHERAL)
 	.mode           = MUSB_PERIPHERAL,
 #elif defined(CONFIG_USB_MUSB_HOST)
@@ -111,6 +113,7 @@ static int da8xx_usb_phy_config(struct device *dev, u8 mode, int is_on)
 				CFGCHIP2_PHY_PLLON | CFGCHIP2_REFFREQ_24MHZ;
 		switch (mode) {
 		case MUSB_OTG:
+		case MUSB_DUAL_ROLE:
 			cfgchip2 |= CFGCHIP2_NO_OVERRIDE;
 			break;
 		case MUSB_HOST:
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 11a3e0f..608f208 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -354,7 +354,7 @@ config USB_S3C2410_DEBUG
 # musb builds in ../musb along with host support
 config USB_GADGET_MUSB_HDRC
 	boolean "Inventra HDRC USB Peripheral (TI, ADI, ...)"
-	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG)
+	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
 	select USB_GADGET_DUALSPEED
 	select USB_GADGET_SELECTED
 	help
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 8a6c781..eb58603 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -95,6 +95,18 @@ config USB_MUSB_PERIPHERAL
 	  connector, it supports the peripheral role.
 	  (With a "Mini-AB" connector, you should enable USB OTG.)
 
+config USB_MUSB_DUAL_ROLE
+	depends on USB && USB_GADGET
+	bool "Both Host and Peripheral: Non-OTG Device"
+	help
+	   This config is for enabling support for Host, Device modes on
+	   single kernel image.  This differs from OTG config in not
+	   supporting HNP, SRP.  VBUS status is sensed perodically to switch
+	   to Host mode on reception of connect interrupt.  Products typically
+	   need this functionality were in the boards do not have the related
+	   OTG compliant circutry but rather support either Host or Device
+	   modes on the same Mini/Micro -AB port or on seperate A and B ports.
+
 config USB_MUSB_OTG
 	depends on USB && USB_GADGET && PM && EXPERIMENTAL
 	bool "Both host and peripheral:  USB OTG (On The Go) Device"
@@ -124,16 +136,17 @@ endchoice
 # enable peripheral support (including with OTG)
 config USB_GADGET_MUSB_HDRC
 	bool
-	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG)
+	depends on USB_MUSB_HDRC && (USB_MUSB_PERIPHERAL || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
 #	default y
 #	select USB_GADGET_DUALSPEED
 #	select USB_GADGET_SELECTED
+	default y if USB_MUSB_DUAL_ROLE
 
 # enables host support (including with OTG)
 config USB_MUSB_HDRC_HCD
 	bool
-	depends on USB_MUSB_HDRC && (USB_MUSB_HOST || USB_MUSB_OTG)
-	select USB_OTG if USB_GADGET_MUSB_HDRC
+	depends on USB_MUSB_HDRC && (USB_MUSB_HOST || USB_MUSB_OTG || USB_MUSB_DUAL_ROLE)
+	select USB_OTG if (USB_GADGET_MUSB_HDRC && USB_MUSB_OTG)
 	default y
 
 
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 829815c..bfa6c1a 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -712,6 +712,16 @@ b_host:
 			if (musb->a_wait_bcon != 0 && is_otg_enabled(musb))
 				musb_platform_try_idle(musb, jiffies
 					+ msecs_to_jiffies(musb->a_wait_bcon));
+
+			if (is_dr_enabled(musb)) {
+				void __iomem *mbase = musb->mregs;
+
+				devctl = musb_readb(mbase, MUSB_DEVCTL);
+				devctl &= ~MUSB_DEVCTL_SESSION;
+				musb_writeb(mbase, MUSB_DEVCTL, devctl);
+				musb->xceiv->state = OTG_STATE_B_IDLE;
+				musb_platform_try_idle(musb, 0);
+			}
 			break;
 #endif	/* HOST */
 #ifdef CONFIG_USB_MUSB_OTG
@@ -738,6 +748,8 @@ b_host:
 		case OTG_STATE_B_PERIPHERAL:
 		case OTG_STATE_B_IDLE:
 			musb_g_disconnect(musb);
+			if (is_dr_enabled(musb))
+				musb_platform_try_idle(musb, 0);
 			break;
 #endif	/* GADGET */
 		default:
@@ -892,7 +904,7 @@ void musb_start(struct musb *musb)
 	devctl = musb_readb(regs, MUSB_DEVCTL);
 	devctl &= ~MUSB_DEVCTL_SESSION;
 
-	if (is_otg_enabled(musb)) {
+	if (is_otg_enabled(musb) || is_dr_enabled(musb)) {
 		/* session started after:
 		 * (a) ID-grounded irq, host mode;
 		 * (b) vbus present/connect IRQ, peripheral mode;
@@ -1898,6 +1910,12 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 #else
 		goto bad_config;
 #endif
+	case MUSB_DUAL_ROLE:
+#ifdef CONFIG_USB_MUSB_DUAL_ROLE
+		break;
+#else
+		goto bad_config;
+#endif
 	case MUSB_OTG:
 #ifdef CONFIG_USB_MUSB_OTG
 		break;
@@ -2026,11 +2044,13 @@ bad_config:
 		}
 	}
 
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* For the host-only role, we can activate right away.
 	 * (We expect the ID pin to be forcibly grounded!!)
 	 * Otherwise, wait till the gadget driver hooks up.
 	 */
-	if (!is_otg_enabled(musb) && is_host_enabled(musb)) {
+	if (is_otg_enabled(musb) || is_dr_enabled(musb) ||
+		is_host_enabled(musb)) {
 		MUSB_HST_MODE(musb);
 		musb->xceiv->default_a = 1;
 		musb->xceiv->state = OTG_STATE_A_IDLE;
@@ -2044,7 +2064,12 @@ bad_config:
 					& MUSB_DEVCTL_BDEVICE
 				? 'B' : 'A'));
 
-	} else /* peripheral is enabled */ {
+	}
+#endif
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* peripheral is enabled */
+	if (is_otg_enabled(musb) || is_dr_enabled(musb) ||
+		is_peripheral_enabled(musb)) {
 		MUSB_DEV_MODE(musb);
 		musb->xceiv->default_a = 0;
 		musb->xceiv->state = OTG_STATE_B_IDLE;
@@ -2057,6 +2082,7 @@ bad_config:
 			musb_readb(musb->mregs, MUSB_DEVCTL));
 
 	}
+#endif
 	if (status < 0)
 		goto fail3;
 
@@ -2420,6 +2446,8 @@ static int __init musb_init(void)
 		", "
 #ifdef CONFIG_USB_MUSB_OTG
 		"otg (peripheral+host)"
+#elif defined(CONFIG_USB_MUSB_DUAL_ROLE)
+		"(host+peripheral)"
 #elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
 		"peripheral"
 #elif defined(CONFIG_USB_MUSB_HDRC_HCD)
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index ac17b00..d327b76 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -74,7 +74,8 @@ struct musb_ep;
 
 
 
-#ifdef CONFIG_USB_MUSB_OTG
+#define	is_dr_enabled(musb)		((musb)->board_mode == MUSB_DUAL_ROLE)
+#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_DUAL_ROLE)
 
 #define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
 #define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 029199c..5f31615 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -1747,7 +1747,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 
 		otg_set_peripheral(musb->xceiv, &musb->g);
 		musb->xceiv->state = OTG_STATE_B_IDLE;
-		musb->is_active = 1;
+		/* musb->is_active = 1; */
 
 		/* FIXME this ignores the softconnect flag.  Drivers are
 		 * allowed hold the peripheral inactive until for example
@@ -1755,7 +1755,7 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 		 * hosts only see fully functional devices.
 		 */
 
-		if (!is_otg_enabled(musb))
+		if (!(is_otg_enabled(musb) || is_dr_enabled(musb)))
 			musb_start(musb);
 
 		otg_set_peripheral(musb->xceiv, &musb->g);
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 7775e1c..a548f6e 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -371,7 +371,8 @@ int musb_hub_control(
 			 * initialization logic, e.g. for OTG, or change any
 			 * logic relating to VBUS power-up.
 			 */
-			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
+			if (!((is_otg_enabled(musb) || is_dr_enabled(musb))
+				&& hcd->self.is_b_host))
 				musb_start(musb);
 			break;
 		case USB_PORT_FEAT_RESET:
diff --git a/include/linux/usb/musb.h b/include/linux/usb/musb.h
index 0608a93..6d553c3 100644
--- a/include/linux/usb/musb.h
+++ b/include/linux/usb/musb.h
@@ -17,7 +17,10 @@ enum musb_mode {
 	MUSB_UNDEFINED = 0,
 	MUSB_HOST,		/* A or Mini-A connector */
 	MUSB_PERIPHERAL,	/* B or Mini-B connector */
-	MUSB_OTG		/* Mini-AB connector */
+	MUSB_OTG,		/* Mini-AB connector */
+	MUSB_DUAL_ROLE,         /* Either A, B connector or Mini-AB connector.
+				 * Does not support OTG.
+				 */
 };
 
 struct clk;
-- 
1.6.5.2

