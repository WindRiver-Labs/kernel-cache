From 06772c56fd34a9c9c4a6bdda492f3941348c8190 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Mon, 7 Dec 2009 22:24:53 +0800
Subject: [PATCH 38/43] mtd: Davinci: modify the ecc_mode from NAND_ECC_HW_SYNDROME to NAND_ECC_HW

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.06.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

The old nand driver use NAND_ECC_HW_SYNDROME ecc_mode, it implies the
prepad bytes between ecc code. The layout of oob area is:
prepad - ecc - prepad - ecc - prepad - ecc - prepad - ecc.
The prepad and ecc in it is 6 bytes and 10 bytes respectively.

This layout is different with the standard NAND_ECC_HW_SYNDROME ecc_mode.
So the old davinci nand driver re-writed the read_page/write_page and
read_oob/write API.

This limitation on oob data layout might causes some problems.

The new implementation use NAND_ECC_HW ecc_mode. Exactly speaking, it is
NAND_ECC_HW_OOB_FIRST ecc_mode. The only difference between them in on
read_page API implementation. It have to read OOB data first.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c   |    3 +-
 arch/arm/mach-davinci/include/mach/nand.h |   18 +-
 drivers/mtd/nand/davinci_nand.c           |  758 +++++++++++++----------------
 3 files changed, 358 insertions(+), 421 deletions(-)

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index 364b0a3..0e4b314 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -155,7 +155,8 @@ struct mtd_partition da850_evm_nandflash_partition[] = {
 static struct davinci_nand_pdata da850_evm_nandflash_data = {
 	.parts		= da850_evm_nandflash_partition,
 	.nr_parts	= ARRAY_SIZE(da850_evm_nandflash_partition),
-	.ecc_mode	= NAND_ECC_HW_SYNDROME,
+	.ecc_mode	= NAND_ECC_HW,
+	.ecc_bits	= 4,
 	.options	= NAND_USE_FLASH_BBT,
 };
 
diff --git a/arch/arm/mach-davinci/include/mach/nand.h b/arch/arm/mach-davinci/include/mach/nand.h
index 7dafe9f..3af8b82 100644
--- a/arch/arm/mach-davinci/include/mach/nand.h
+++ b/arch/arm/mach-davinci/include/mach/nand.h
@@ -67,11 +67,11 @@
 #define ECC_MAX_CORRECTABLE_ERRORS	0x4
 
 struct davinci_nand_pdata {		/* platform_data */
-	u32			mask_ale;
-	u32			mask_cle;
+	uint32_t		mask_ale;
+	uint32_t		mask_cle;
 
 	/* for packages using two chipselects */
-	u32			mask_chipsel;
+	uint32_t		mask_chipsel;
 
 	/* board's default static partition info */
 	struct mtd_partition	*parts;
@@ -79,13 +79,21 @@ struct davinci_nand_pdata {		/* platform_data */
 
 	/* none  == NAND_ECC_NONE (strongly *not* advised!!)
 	 * soft  == NAND_ECC_SOFT
-	 * 1-bit == NAND_ECC_HW
-	 * 4-bit == NAND_ECC_HW_SYNDROME (not on all chips)
+	 * else  == NAND_ECC_HW, according to ecc_bits
+	 *
+	 * All DaVinci-family chips support 1-bit hardware ECC.
+	 * Newer ones also support 4-bit ECC, but are awkward
+	 * using it with large page chips.
 	 */
 	nand_ecc_modes_t	ecc_mode;
+	u8			ecc_bits;
 
 	/* e.g. NAND_BUSWIDTH_16 or NAND_USE_FLASH_BBT */
 	unsigned		options;
+
+	/* Main and mirror bbt descriptor overrides */
+	struct nand_bbt_descr	*bbt_td;
+	struct nand_bbt_descr	*bbt_md;
 };
 
 #endif	/* __ARCH_ARM_DAVINCI_NAND_H */
diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c
index b37578d..02a45da 100644
--- a/drivers/mtd/nand/davinci_nand.c
+++ b/drivers/mtd/nand/davinci_nand.c
@@ -26,7 +26,6 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/err.h>
 #include <linux/clk.h>
@@ -58,7 +57,7 @@ static inline int mtd_has_cmdlinepart(void) { return 0; }
  * and some flavors of secondary chipselect (e.g. based on A12) as used
  * with multichip packages.
  *
- * The 1-bit ECC hardware is supported, but not yet the newer 4-bit ECC
+ * The 1-bit ECC hardware is supported, as well as the newer 4-bit ECC
  * available on chips like the DM355 and OMAP-L137 and needed with the
  * more error-prone MLC NAND chips.
  *
@@ -68,27 +67,29 @@ static inline int mtd_has_cmdlinepart(void) { return 0; }
 struct davinci_nand_info {
 	struct mtd_info		mtd;
 	struct nand_chip	chip;
+	struct nand_ecclayout	ecclayout;
 
 	struct device		*dev;
 	struct clk		*clk;
 	bool			partitioned;
 
+	bool			is_readmode;
+
 	void __iomem		*base;
 	void __iomem		*vaddr;
 
-	u32			ioaddr;
-	u32			current_cs;
+	uint32_t		ioaddr;
+	uint32_t		current_cs;
 
-	u32			mask_chipsel;
-	u32			mask_ale;
-	u32			mask_cle;
+	uint32_t		mask_chipsel;
+	uint32_t		mask_ale;
+	uint32_t		mask_cle;
 
-	u32			core_chipsel;
+	uint32_t		core_chipsel;
 };
 
 static DEFINE_SPINLOCK(davinci_nand_lock);
-
-static u_char davinci_ecc_buf[NAND_MAX_OOBSIZE];
+static bool ecc4_busy;
 
 #define to_davinci_nand(m) container_of(m, struct davinci_nand_info, mtd)
 
@@ -115,7 +116,7 @@ static void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd,
 				   unsigned int ctrl)
 {
 	struct davinci_nand_info	*info = to_davinci_nand(mtd);
-	u32				addr = info->current_cs;
+	uint32_t			addr = info->current_cs;
 	struct nand_chip		*nand = mtd->priv;
 
 	/* Did the control lines change? */
@@ -135,7 +136,7 @@ static void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd,
 static void nand_davinci_select_chip(struct mtd_info *mtd, int chip)
 {
 	struct davinci_nand_info	*info = to_davinci_nand(mtd);
-	u32				addr = info->ioaddr;
+	uint32_t			addr = info->ioaddr;
 
 	/* maybe kick in a second chipselect */
 	if (chip > 0)
@@ -152,7 +153,7 @@ static void nand_davinci_select_chip(struct mtd_info *mtd, int chip)
  * 1-bit hardware ECC ... context maintained for each core chipselect
  */
 
-static inline u32 nand_davinci_readecc_1bit(struct mtd_info *mtd)
+static inline uint32_t nand_davinci_readecc_1bit(struct mtd_info *mtd)
 {
 	struct davinci_nand_info *info = to_davinci_nand(mtd);
 
@@ -163,7 +164,7 @@ static inline u32 nand_davinci_readecc_1bit(struct mtd_info *mtd)
 static void nand_davinci_hwctl_1bit(struct mtd_info *mtd, int mode)
 {
 	struct davinci_nand_info *info;
-	u32 nandcfr;
+	uint32_t nandcfr;
 	unsigned long flags;
 
 	info = to_davinci_nand(mtd);
@@ -203,11 +204,11 @@ static int nand_davinci_correct_1bit(struct mtd_info *mtd, u_char *dat,
 				     u_char *read_ecc, u_char *calc_ecc)
 {
 	struct nand_chip *chip = mtd->priv;
-	u_int32_t eccNand = read_ecc[0] | (read_ecc[1] << 8) |
+	uint32_t eccNand = read_ecc[0] | (read_ecc[1] << 8) |
 					  (read_ecc[2] << 16);
-	u_int32_t eccCalc = calc_ecc[0] | (calc_ecc[1] << 8) |
+	uint32_t eccCalc = calc_ecc[0] | (calc_ecc[1] << 8) |
 					  (calc_ecc[2] << 16);
-	u_int32_t diff = eccCalc ^ eccNand;
+	uint32_t diff = eccCalc ^ eccNand;
 
 	if (diff) {
 		if ((((diff >> 12) ^ diff) & 0xfff) == 0xfff) {
@@ -234,244 +235,131 @@ static int nand_davinci_correct_1bit(struct mtd_info *mtd, u_char *dat,
 /*----------------------------------------------------------------------*/
 
 /*
- * NOTE:  NAND boot requires ALE == EM_A[1], CLE == EM_A[2], so that's
- * how these chips are normally wired.  This translates to both 8 and 16
- * bit busses using ALE == BIT(3) in byte addresses, and CLE == BIT(4).
+ * 4-bit hardware ECC ... context maintained over entire AEMIF
  *
- * For now we assume that configuration, or any other one which ignores
- * the two LSBs for NAND access ... so we can issue 32-bit reads/writes
- * and have that transparently morphed into multiple NAND operations.
+ * This is a syndrome engine, but we avoid NAND_ECC_HW_SYNDROME
+ * since that forces use of a problematic "infix OOB" layout.
+ * Among other things, it trashes manufacturer bad block markers.
+ * Also, and specific to this hardware, it ECC-protects the "prepad"
+ * in the OOB ... while having ECC protection for parts of OOB would
+ * seem useful, the current MTD stack sometimes wants to update the
+ * OOB without recomputing ECC.
  */
-static void nand_davinci_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	if ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)
-		ioread32_rep(chip->IO_ADDR_R, buf, len >> 2);
-	else if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)
-		ioread16_rep(chip->IO_ADDR_R, buf, len >> 1);
-	else
-		ioread8_rep(chip->IO_ADDR_R, buf, len);
-}
-
-static void nand_davinci_write_buf(struct mtd_info *mtd,
-		const uint8_t *buf, int len)
-{
-	struct nand_chip *chip = mtd->priv;
-
-	if ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)
-		iowrite32_rep(chip->IO_ADDR_R, buf, len >> 2);
-	else if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)
-		iowrite16_rep(chip->IO_ADDR_R, buf, len >> 1);
-	else
-		iowrite8_rep(chip->IO_ADDR_R, buf, len);
-}
 
-/*
- * Check hardware register for wait status. Returns 1 if device is ready,
- * 0 if it is still busy.
- */
-static int nand_davinci_dev_ready(struct mtd_info *mtd)
+static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)
 {
 	struct davinci_nand_info *info = to_davinci_nand(mtd);
+	unsigned long flags;
+	u32 val;
 
-	return davinci_nand_readl(info, NANDFSR_OFFSET) & BIT(0);
-}
-
-/* DaVinci specific flash bbt decriptors */
-static uint8_t nand_davinci_bbt_pattern[] = {'B', 'b', 't', '0' };
-static uint8_t nand_davinci_mirror_pattern[] = {'1', 't', 'b', 'B' };
-
-static struct nand_bbt_descr nand_davinci_bbt_main_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs =	2,
-	.len = 4,
-	.veroffs = 16,
-	.maxblocks = 4,
-	.pattern = nand_davinci_bbt_pattern
-};
+	spin_lock_irqsave(&davinci_nand_lock, flags);
 
-static struct nand_bbt_descr nand_davinci_bbt_mirror_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs =	2,
-	.len = 4,
-	.veroffs = 16,
-	.maxblocks = 4,
-	.pattern = nand_davinci_mirror_pattern
-};
+	/* Start 4-bit ECC calculation for read/write */
+	val = davinci_nand_readl(info, NANDFCR_OFFSET);
+	val &= ~(0x03 << 4);
+	val |= (info->core_chipsel << 4) | BIT(12);
+	davinci_nand_writel(info, NANDFCR_OFFSET, val);
 
-static struct nand_ecclayout nand_davinci_layout_4bit = {
-	.eccbytes = 10,
-	.eccpos = {
-		   6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-		   22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-		   38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-		   54, 55, 56, 57, 58, 59, 60, 61, 62, 63},
-	.oobfree = {
-		{16, 6}, {32, 6}, {48, 6}, {2, 4}
-	}
-};
+	info->is_readmode = (mode == NAND_ECC_READ);
 
-static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)
-{
-	struct davinci_nand_info *info = to_davinci_nand(mtd);
-	u32 nandfcr;
-
-	switch (mode) {
-	case NAND_ECC_WRITE:
-	case NAND_ECC_READ:
-		/* Start a new ECC calculation for reading or writing 512 bytes
-		 * of data.*/
-		nandfcr = (davinci_nand_readl(info, NANDFCR_OFFSET) &
-				~(3 << 4)) | (info->core_chipsel << 4) |
-				BIT(12);
-		davinci_nand_writel(info, NANDFCR_OFFSET, nandfcr);
-		break;
-	case NAND_ECC_READSYN:
-		davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);
-		break;
-	default:
-		break;
-	}
+	spin_unlock_irqrestore(&davinci_nand_lock, flags);
 }
 
-static u32 nand_davinci_readecc_4bit(struct mtd_info *mtd, unsigned int ecc[4])
+/* Read raw ECC code after writing to NAND. */
+static void
+nand_davinci_readecc_4bit(struct davinci_nand_info *info, u32 code[4])
 {
-	struct davinci_nand_info *info = to_davinci_nand(mtd);
-
-	ecc[0] = davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET) &
-			NAND_4BIT_ECC_MASK;
-	ecc[1] = davinci_nand_readl(info, NAND_4BIT_ECC2_OFFSET) &
-			NAND_4BIT_ECC_MASK;
-	ecc[2] = davinci_nand_readl(info, NAND_4BIT_ECC3_OFFSET) &
-			NAND_4BIT_ECC_MASK;
-	ecc[3] = davinci_nand_readl(info, NAND_4BIT_ECC4_OFFSET) &
-			NAND_4BIT_ECC_MASK;
+	const u32 mask = 0x03ff03ff;
 
-	return 0;
+	code[0] = davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET) & mask;
+	code[1] = davinci_nand_readl(info, NAND_4BIT_ECC2_OFFSET) & mask;
+	code[2] = davinci_nand_readl(info, NAND_4BIT_ECC3_OFFSET) & mask;
+	code[3] = davinci_nand_readl(info, NAND_4BIT_ECC4_OFFSET) & mask;
 }
 
+/* Terminate read ECC; or return ECC (as bytes) of data written to NAND. */
 static int nand_davinci_calculate_4bit(struct mtd_info *mtd,
-					   const uint8_t *dat,
-					   uint8_t *ecc_code)
+		const u_char *dat, u_char *ecc_code)
 {
-	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 };
-	unsigned int const1 = 0, const2 = 0;
-	unsigned int i;
-
-	nand_davinci_readecc_4bit(mtd, hw_4ecc);
-
-	/* Convert 10 bit ecc value to 8 bit */
-	for (i = 0; i < 2; i++) {
-		const2 = i * 5;
-		const1 = i * 2;
-
-		/* Take first 8 bits from val1 (i=0) or val5 (i=1) */
-		ecc_code[const2] = hw_4ecc[const1] & 0xFF;
-
-		/*
-		 * Take 2 bits as LSB bits from val1 (i=0) or val5 (i=1) and
-		 * 6 bits from val2 (i=0) or val5 (i=1)
-		 */
-		ecc_code[const2 + 1] =
-		    ((hw_4ecc[const1] >> 8) & 0x3) | ((hw_4ecc[const1] >> 14) &
-						      0xFC);
-
-		/*
-		 * Take 4 bits from val2 (i=0) or val5 (i=1) and 4 bits from
-		 * val3 (i=0) or val6 (i=1)
-		 */
-		ecc_code[const2 + 2] =
-		    ((hw_4ecc[const1] >> 22) & 0xF) |
-		    ((hw_4ecc[const1 + 1] << 4) & 0xF0);
+	struct davinci_nand_info *info = to_davinci_nand(mtd);
+	u32 raw_ecc[4], *p;
+	unsigned i;
 
-		/*
-		 * Take 6 bits from val3(i=0) or val6 (i=1) and 2 bits from
-		 * val4 (i=0) or  val7 (i=1)
-		 */
-		ecc_code[const2 + 3] =
-		    ((hw_4ecc[const1 + 1] >> 4) & 0x3F) |
-		    ((hw_4ecc[const1 + 1] >> 10) & 0xC0);
+	/* After a read, terminate ECC calculation by a dummy read
+	 * of some 4-bit ECC register.  ECC covers everything that
+	 * was read; correct() just uses the hardware state, so
+	 * ecc_code is not needed.
+	 */
+	if (info->is_readmode) {
+		davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);
+		return 0;
+	}
 
-		/* Take 8 bits from val4 (i=0) or val7 (i=1) */
-		ecc_code[const2 + 4] = (hw_4ecc[const1 + 1] >> 18) & 0xFF;
+	/* Pack eight raw 10-bit ecc values into ten bytes, making
+	 * two passes which each convert four values (in upper and
+	 * lower halves of two 32-bit words) into five bytes.  The
+	 * ROM boot loader uses this same packing scheme.
+	 */
+	nand_davinci_readecc_4bit(info, raw_ecc);
+	for (i = 0, p = raw_ecc; i < 2; i++, p += 2) {
+		*ecc_code++ =   p[0]        & 0xff;
+		*ecc_code++ = ((p[0] >>  8) & 0x03) | ((p[0] >> 14) & 0xfc);
+		*ecc_code++ = ((p[0] >> 22) & 0x0f) | ((p[1] <<  4) & 0xf0);
+		*ecc_code++ = ((p[1] >>  4) & 0x3f) | ((p[1] >> 10) & 0xc0);
+		*ecc_code++ =  (p[1] >> 18) & 0xff;
 	}
+
 	return 0;
 }
 
-static int nand_davinci_correct_4bit(struct mtd_info *mtd, uint8_t *page_data,
-					  uint8_t *read_ecc, uint8_t *calc_ecc)
+/* Correct up to 4 bits in data we just read, using state left in the
+ * hardware plus the ecc_code computed when it was first written.
+ */
+static int nand_davinci_correct_4bit(struct mtd_info *mtd,
+		u_char *data, u_char *ecc_code, u_char *null)
 {
-	struct davinci_nand_info *info = to_davinci_nand(mtd);
-	unsigned short ecc_10bit[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 	int i;
-	unsigned int hw_4ecc[4] = { 0, 0, 0, 0 }, iserror = 0;
-	unsigned short *pspare = NULL, *pspare1 = NULL;
-	unsigned int numErrors, errorAddress, errorValue;
+	struct davinci_nand_info *info = to_davinci_nand(mtd);
+	unsigned short ecc10[8];
+	unsigned short *ecc16;
+	u32 syndrome[4];
+	u32 ecc_state;
+	unsigned num_errors, corrected;
 
-	/*
-	 * Check for an ECC where all bytes are 0xFF.  If this is the case, we
-	 * will assume we are looking at an erased page and we should ignore the
-	 * ECC.
-	 */
+	/* All bytes 0xff?  It's an erased page; ignore its ECC. */
 	for (i = 0; i < 10; i++) {
-		if (read_ecc[i] != 0xFF)
-			break;
+		if (ecc_code[i] != 0xff)
+			goto compare;
 	}
-	if (i == 10)
-		return 0;
-
-	/* Convert 8 bit in to 10 bit */
-	pspare = (unsigned short *)&read_ecc[2];
-	pspare1 = (unsigned short *)&read_ecc[0];
-	/* Take 10 bits from 0th and 1st bytes */
-	ecc_10bit[0] = (*pspare1) & 0x3FF;	/* 10 */
-	/* Take 6 bits from 1st byte and 4 bits from 2nd byte */
-	ecc_10bit[1] = (((*pspare1) >> 10) & 0x3F)
-	    | (((pspare[0]) << 6) & 0x3C0);	/* 6 + 4 */
-	/* Take 4 bits form 2nd bytes and 6 bits from 3rd bytes */
-	ecc_10bit[2] = ((pspare[0]) >> 4) & 0x3FF;	/* 10 */
-	/*Take 2 bits from 3rd byte and 8 bits from 4th byte */
-	ecc_10bit[3] = (((pspare[0]) >> 14) & 0x3)
-	    | ((((pspare[1])) << 2) & 0x3FC);	/* 2 + 8 */
-	/* Take 8 bits from 5th byte and 2 bits from 6th byte */
-	ecc_10bit[4] = ((pspare[1]) >> 8)
-	    | ((((pspare[2])) << 8) & 0x300);	/* 8 + 2 */
-	/* Take 6 bits from 6th byte and 4 bits from 7th byte */
-	ecc_10bit[5] = (pspare[2] >> 2) & 0x3FF;	/* 10 */
-	/* Take 4 bits from 7th byte and 6 bits from 8th byte */
-	ecc_10bit[6] = (((pspare[2]) >> 12) & 0xF)
-	    | ((((pspare[3])) << 4) & 0x3F0);	/* 4 + 6 */
-	/*Take 2 bits from 8th byte and 8 bits from 9th byte */
-	ecc_10bit[7] = ((pspare[3]) >> 6) & 0x3FF;	/* 10 */
+	return 0;
 
-	/*
-	 * Write the parity values in the NAND Flash 4-bit ECC Load register.
-	 * Write each parity value one at a time starting from 4bit_ecc_val8
-	 * to 4bit_ecc_val1.
+compare:
+	/* Unpack ten bytes into eight 10 bit values.  We know we're
+	 * little-endian, and use type punning for less shifting/masking.
 	 */
+	if (WARN_ON(0x01 & (unsigned) ecc_code))
+		return -EINVAL;
+	ecc16 = (unsigned short *)ecc_code;
+
+	ecc10[0] =  (ecc16[0] >>  0) & 0x3ff;
+	ecc10[1] = ((ecc16[0] >> 10) & 0x3f) | ((ecc16[1] << 6) & 0x3c0);
+	ecc10[2] =  (ecc16[1] >>  4) & 0x3ff;
+	ecc10[3] = ((ecc16[1] >> 14) & 0x3)  | ((ecc16[2] << 2) & 0x3fc);
+	ecc10[4] =  (ecc16[2] >>  8)         | ((ecc16[3] << 8) & 0x300);
+	ecc10[5] =  (ecc16[3] >>  2) & 0x3ff;
+	ecc10[6] = ((ecc16[3] >> 12) & 0xf)  | ((ecc16[4] << 4) & 0x3f0);
+	ecc10[7] =  (ecc16[4] >>  6) & 0x3ff;
+
+	/* Tell ECC controller about the expected ECC codes. */
 	for (i = 7; i >= 0; i--)
-		davinci_nand_writel(info, NAND_4BIT_ECC_LOAD_OFFSET,
-				    ecc_10bit[i]);
+		davinci_nand_writel(info, NAND_4BIT_ECC_LOAD_OFFSET, ecc10[i]);
 
-	/*
-	 * Perform a dummy read to the EMIF Revision Code and Status register.
-	 * This is required to ensure time for syndrome calculation after
-	 * writing the ECC values in previous step.
+	/* Allow time for syndrome calculation ... then read it.
+	 * A syndrome of all zeroes 0 means no detected errors.
 	 */
 	davinci_nand_readl(info, NANDFSR_OFFSET);
-
-	/*
-	 * Read the syndrome from the NAND Flash 4-Bit ECC 1-4 registers.
-	 * A syndrome value of 0 means no bit errors. If the syndrome is
-	 * non-zero then go further otherwise return.
-	 */
-	nand_davinci_readecc_4bit(mtd, hw_4ecc);
-
-	if (hw_4ecc[0] == ECC_STATE_NO_ERR && hw_4ecc[1] == ECC_STATE_NO_ERR &&
-	    hw_4ecc[2] == ECC_STATE_NO_ERR && hw_4ecc[3] == ECC_STATE_NO_ERR)
+	nand_davinci_readecc_4bit(info, syndrome);
+	if (!(syndrome[0] | syndrome[1] | syndrome[2] | syndrome[3]))
 		return 0;
 
 	/*
@@ -480,179 +368,130 @@ static int nand_davinci_correct_4bit(struct mtd_info *mtd, uint8_t *page_data,
 	 */
 	davinci_nand_readl(info, NAND_ERR_ADD1_OFFSET);
 
-	/*
-	 * Set the addr_calc_st bit(bit no 13) in the NAND Flash Control
-	 * register to 1.
+	/* Start address calculation, and wait for it to complete.
+	 * We _could_ start reading more data while this is working,
+	 * to speed up the overall page read.
 	 */
 	davinci_nand_writel(info, NANDFCR_OFFSET,
-		davinci_nand_readl(info, NANDFCR_OFFSET) | BIT(13));
+			davinci_nand_readl(info, NANDFCR_OFFSET) | BIT(13));
 
 	/*
-	 * Wait for the corr_state field (bits 8 to 11)in the
-	 * NAND Flash Status register to be equal to 0x0, 0x1, 0x2, or 0x3.
+	 * ECC_STATE field reads 0x3 (Error correction complete) immediately
+	 * after setting the 4BITECC_ADD_CALC_START bit. So if you immediately
+	 * begin trying to poll for the state, you may fall right out of your
+	 * loop without any of the correction calculations having taken place.
+	 * The recommendation from the hardware team is to wait till ECC_STATE
+	 * reads less than 4, which means ECC HW has entered correction state.
 	 */
 	do {
-		iserror = davinci_nand_readl(info, NANDFSR_OFFSET);
-		iserror &= NANDFSR_ECC_STATE_MASK;
-		iserror = iserror >> 8;
-	} while ((ECC_STATE_NO_ERR != iserror) &&
-		 (ECC_STATE_TOO_MANY_ERRS != iserror) &&
-		 (ECC_STATE_ERR_CORR_COMP_P != iserror) &&
-		 (ECC_STATE_ERR_CORR_COMP_N != iserror));
-
-	/*
-	 * ECC_STATE_TOO_MANY_ERRS (0x1) means errors cannot be
-	 * corrected (five or more errors).  The number of errors
-	 * calculated (err_num field) differs from the number of errors
-	 * searched.  ECC_STATE_ERR_CORR_COMP_P (0x2) means error
-	 * correction complete (errors on bit 8 or 9).
-	 * ECC_STATE_ERR_CORR_COMP_N (0x3) means error correction
-	 * complete (error exists).
-	 */
-	udelay(info->chip.chip_delay);
-	if (iserror == ECC_STATE_NO_ERR)
-		return 0;
-	else if (iserror == ECC_STATE_TOO_MANY_ERRS) {
-		printk(KERN_DEBUG "Too many errors to be corrected!\n");
-		return -1;
+		ecc_state = (davinci_nand_readl(info,
+				NANDFSR_OFFSET) >> 8) & 0x0f;
+		cpu_relax();
+	} while (ecc_state < 4);
+
+	for (;;) {
+		u32	fsr = davinci_nand_readl(info, NANDFSR_OFFSET);
+
+		switch ((fsr >> 8) & 0x0f) {
+		case 0:		/* no error, should not happen */
+			davinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);
+			return 0;
+		case 1:		/* five or more errors detected */
+			davinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);
+			return -EIO;
+		case 2:		/* error addresses computed */
+		case 3:
+			num_errors = 1 + ((fsr >> 16) & 0x03);
+			goto correct;
+		default:	/* still working on it */
+			cpu_relax();
+			continue;
+		}
 	}
 
-	numErrors = 1 + ((davinci_nand_readl(info, NANDFSR_OFFSET) >> 16) &
-			  0x3);
-
-	/* Read the error address, error value and correct */
-	for (i = 0; i < numErrors; i++) {
-		int addr_offset, val_offset;
+correct:
+	/* correct each error */
+	for (i = 0, corrected = 0; i < num_errors; i++) {
+		int error_address, error_value;
 
 		if (i > 1) {
-			addr_offset = NAND_ERR_ADD2_OFFSET;
-			val_offset = NAND_ERR_ERRVAL2_OFFSET;
+			error_address = davinci_nand_readl(info,
+						NAND_ERR_ADD2_OFFSET);
+			error_value = davinci_nand_readl(info,
+						NAND_ERR_ERRVAL2_OFFSET);
 		} else {
-			addr_offset = NAND_ERR_ADD1_OFFSET;
-			val_offset = NAND_ERR_ERRVAL1_OFFSET;
+			error_address = davinci_nand_readl(info,
+						NAND_ERR_ADD1_OFFSET);
+			error_value = davinci_nand_readl(info,
+						NAND_ERR_ERRVAL1_OFFSET);
 		}
-		errorAddress = ((davinci_nand_readl(info, addr_offset) >>
-				(16 * (i & 1))) & 0x3FF);
-		errorAddress = ((512 + 7) - errorAddress);
-		errorValue = ((davinci_nand_readl(info, val_offset) >>
-				(16 * (i & 1))) & 0xFF);
-		/* xor the corrupt data with error value */
-		if (errorAddress < 512)
-			page_data[errorAddress] ^= errorValue;
-	}
 
-	return numErrors;
-}
-
-static int davinci_nand_read_page_syndrome(struct mtd_info *mtd,
-				struct nand_chip *chip, uint8_t *buf, int page)
-{
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	uint8_t *p = buf;
-	uint8_t *oob = chip->oob_poi;
-
-	/* Read the OOB area first */
-	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-	chip->read_buf(mtd, oob, mtd->oobsize);
-	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
-
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		int stat;
-
-		chip->ecc.hwctl(mtd, NAND_ECC_READ);
-		chip->read_buf(mtd, p, eccsize);
-		chip->ecc.hwctl(mtd, NAND_ECC_READSYN);
-
-		if (chip->ecc.prepad)
-			oob += chip->ecc.prepad;
-
-		stat = chip->ecc.correct(mtd, p, oob, NULL);
-
-		if (stat < 0)
-			mtd->ecc_stats.failed++;
-		else
-			mtd->ecc_stats.corrected += stat;
-
-		oob += eccbytes;
-
-		if (chip->ecc.postpad)
-			oob += chip->ecc.postpad;
-	}
-	return 0;
-}
-
-static void davinci_nand_write_page_syndrome(struct mtd_info *mtd,
-				    struct nand_chip *chip, const uint8_t *buf)
-{
-	int i, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	int offset = 0;
-	const uint8_t *p = buf;
-	uint8_t *oob = chip->oob_poi;
-
-	/* Write in chunks of eccsize=512, calculate ECC for eccsize=512, save
-	 * OOB in the temporary buffer and once all eccsteps are covered, write
-	 * OOB from temporary buffer to the NAND page sparebytes region.
-	 */
-	for (i = 0; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-		chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-		chip->write_buf(mtd, p, eccsize);
-		chip->ecc.calculate(mtd, p, oob + chip->ecc.prepad);
-
-		if (chip->ecc.prepad) {
-			memcpy(&davinci_ecc_buf[offset], oob, chip->ecc.prepad);
-			oob += chip->ecc.prepad;
-			offset += chip->ecc.prepad;
+		if (i & 1) {
+			error_address >>= 16;
+			error_value >>= 16;
 		}
-		memcpy(&davinci_ecc_buf[offset], oob, eccbytes);
-		oob += eccbytes;
-		offset += eccbytes;
-
-		if (chip->ecc.postpad) {
-			memcpy(&davinci_ecc_buf[offset], oob,
-				chip->ecc.postpad);
-			oob += chip->ecc.postpad;
-			offset += chip->ecc.postpad;
+		error_address &= 0x3ff;
+		error_address = (512 + 7) - error_address;
+
+		if (error_address < 512) {
+			data[error_address] ^= error_value;
+			corrected++;
 		}
 	}
 
-	chip->write_buf(mtd, davinci_ecc_buf, mtd->oobsize);
+	return corrected;
 }
 
-static int davinci_nand_read_oob_std(struct mtd_info *mtd,
-				struct nand_chip *chip, int page, int sndcmd)
+/*----------------------------------------------------------------------*/
+
+/*
+ * NOTE:  NAND boot requires ALE == EM_A[1], CLE == EM_A[2], so that's
+ * how these chips are normally wired.  This translates to both 8 and 16
+ * bit busses using ALE == BIT(3) in byte addresses, and CLE == BIT(4).
+ *
+ * For now we assume that configuration, or any other one which ignores
+ * the two LSBs for NAND access ... so we can issue 32-bit reads/writes
+ * and have that transparently morphed into multiple NAND operations.
+ */
+static void nand_davinci_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
-	if (sndcmd) {
-		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
-		sndcmd = 0;
-	}
-	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-	return sndcmd;
+	struct nand_chip *chip = mtd->priv;
+
+	if ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)
+		ioread32_rep(chip->IO_ADDR_R, buf, len >> 2);
+	else if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)
+		ioread16_rep(chip->IO_ADDR_R, buf, len >> 1);
+	else
+		ioread8_rep(chip->IO_ADDR_R, buf, len);
 }
 
-static int davinci_nand_write_oob_std(struct mtd_info *mtd,
-				      struct nand_chip *chip, int page)
+static void nand_davinci_write_buf(struct mtd_info *mtd,
+		const uint8_t *buf, int len)
 {
-	int status = 0;
-	const uint8_t *buf = chip->oob_poi;
-	int length = mtd->oobsize;
+	struct nand_chip *chip = mtd->priv;
 
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
-	chip->write_buf(mtd, buf, length);
-	/* Send command to program the OOB data */
-	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+	if ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)
+		iowrite32_rep(chip->IO_ADDR_R, buf, len >> 2);
+	else if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)
+		iowrite16_rep(chip->IO_ADDR_R, buf, len >> 1);
+	else
+		iowrite8_rep(chip->IO_ADDR_R, buf, len);
+}
 
-	status = chip->waitfunc(mtd, chip);
+/*
+ * Check hardware register for wait status. Returns 1 if device is ready,
+ * 0 if it is still busy.
+ */
+static int nand_davinci_dev_ready(struct mtd_info *mtd)
+{
+	struct davinci_nand_info *info = to_davinci_nand(mtd);
 
-	return status & NAND_STATUS_FAIL ? -EIO : 0;
+	return davinci_nand_readl(info, NANDFSR_OFFSET) & BIT(0);
 }
 
 static void __init nand_dm6446evm_flash_init(struct davinci_nand_info *info)
 {
-	u32 regval, a1cr;
+	uint32_t regval, a1cr;
 
 	/*
 	 * NAND FLASH timings @ PLL1 == 459 MHz
@@ -682,6 +521,43 @@ static void __init nand_dm6446evm_flash_init(struct davinci_nand_info *info)
 
 /*----------------------------------------------------------------------*/
 
+/* An ECC layout for using 4-bit ECC with small-page flash, storing
+ * ten ECC bytes plus the manufacturer's bad block marker byte, and
+ * and not overlapping the default BBT markers.
+ */
+static struct nand_ecclayout hwecc4_small __initconst = {
+	.eccbytes = 10,
+	.eccpos = { 0, 1, 2, 3, 4,
+		/* offset 5 holds the badblock marker */
+		6, 7,
+		13, 14, 15, },
+	.oobfree = {
+		{.offset = 8, .length = 5, },
+		{.offset = 16, },
+	},
+};
+
+/* An ECC layout for using 4-bit ECC with large-page (2048bytes) flash,
+ * storing ten ECC bytes plus the manufacturer's bad block marker byte,
+ * and not overlapping the default BBT markers.
+ */
+static struct nand_ecclayout hwecc4_2048 __initconst = {
+	.eccbytes = 40,
+	.eccpos = {
+		/* at the end of spare sector */
+		24, 25, 26, 27, 28, 29,	30, 31, 32, 33,
+		34, 35, 36, 37, 38, 39,	40, 41, 42, 43,
+		44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
+		54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+		},
+	.oobfree = {
+		/* 2 bytes at offset 0 hold manufacturer badblock markers */
+		{.offset = 2, .length = 22, },
+		/* 5 bytes at offset 8 hold BBT markers */
+		/* 8 bytes at offset 16 hold JFFS2 clean markers */
+	},
+};
+
 static int __init nand_davinci_probe(struct platform_device *pdev)
 {
 	struct davinci_nand_pdata	*pdata = pdev->dev.platform_data;
@@ -691,9 +567,13 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	void __iomem			*vaddr;
 	void __iomem			*base;
 	int				ret;
-	u32				val;
+	uint32_t			val;
 	nand_ecc_modes_t		ecc_mode;
 
+	/* insist on board-specific configuration */
+	if (!pdata)
+		return -ENODEV;
+
 	/* which external chipselect will we be managing? */
 	if (pdev->id < 0 || pdev->id > 3)
 		return -ENODEV;
@@ -737,23 +617,19 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	info->chip.select_chip	= nand_davinci_select_chip;
 
 	/* options such as NAND_USE_FLASH_BBT or 16-bit widths */
-	info->chip.options	= pdata ? pdata->options : 0;
+	info->chip.options	= pdata->options;
+	info->chip.bbt_td	= pdata->bbt_td;
+	info->chip.bbt_md	= pdata->bbt_md;
 
-	info->ioaddr		= (u32 __force) vaddr;
+	info->ioaddr		= (uint32_t __force) vaddr;
 
 	info->current_cs	= info->ioaddr;
 	info->core_chipsel	= pdev->id;
 	info->mask_chipsel	= pdata->mask_chipsel;
 
 	/* use nandboot-capable ALE/CLE masks by default */
-	if (pdata && pdata->mask_ale)
-		info->mask_ale	= pdata->mask_cle;
-	else
-		info->mask_ale	= MASK_ALE;
-	if (pdata && pdata->mask_cle)
-		info->mask_cle	= pdata->mask_cle;
-	else
-		info->mask_cle	= MASK_CLE;
+	info->mask_ale		= pdata->mask_ale ? : MASK_ALE;
+	info->mask_cle		= pdata->mask_cle ? : MASK_CLE;
 
 	/* Set address of hardware control function */
 	info->chip.cmd_ctrl	= nand_davinci_hwcontrol;
@@ -763,39 +639,43 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	info->chip.read_buf     = nand_davinci_read_buf;
 	info->chip.write_buf    = nand_davinci_write_buf;
 
-	/* use board-specific ECC config; else, the best available */
-	if (pdata)
-		ecc_mode = pdata->ecc_mode;
-	else
-		ecc_mode = NAND_ECC_HW;
+	/* Use board-specific ECC config */
+	ecc_mode		= pdata->ecc_mode;
 
+	ret = -EINVAL;
 	switch (ecc_mode) {
 	case NAND_ECC_NONE:
 	case NAND_ECC_SOFT:
+		pdata->ecc_bits = 0;
 		break;
 	case NAND_ECC_HW:
-		info->chip.ecc.calculate = nand_davinci_calculate_1bit;
-		info->chip.ecc.correct = nand_davinci_correct_1bit;
-		info->chip.ecc.hwctl = nand_davinci_hwctl_1bit;
-		info->chip.ecc.size = 512;
-		info->chip.ecc.bytes = 3;
-		break;
-	case NAND_ECC_HW_SYNDROME:
-		dev_info(&pdev->dev, "Using 4-bit hardware ECC - Syndrome\n");
-		info->chip.ecc.layout = &nand_davinci_layout_4bit;
-		info->chip.ecc.calculate = nand_davinci_calculate_4bit;
-		info->chip.ecc.correct = nand_davinci_correct_4bit;
-		info->chip.ecc.hwctl = nand_davinci_hwctl_4bit;
-		/* Override read_page/write_page and read_oob/write_oob APIs */
-		info->chip.ecc.read_page = davinci_nand_read_page_syndrome;
-		info->chip.ecc.write_page = davinci_nand_write_page_syndrome;
-		info->chip.ecc.read_oob = davinci_nand_read_oob_std;
-		info->chip.ecc.write_oob = davinci_nand_write_oob_std;
+		if (pdata->ecc_bits == 4) {
+			/* No sanity checks:  CPUs must support this,
+			 * and the chips may not use NAND_BUSWIDTH_16.
+			 */
+
+			/* No sharing 4-bit hardware between chipselects yet */
+			spin_lock_irq(&davinci_nand_lock);
+			if (ecc4_busy)
+				ret = -EBUSY;
+			else
+				ecc4_busy = true;
+			spin_unlock_irq(&davinci_nand_lock);
+
+			if (ret == -EBUSY)
+				goto err_ecc;
+
+			info->chip.ecc.calculate = nand_davinci_calculate_4bit;
+			info->chip.ecc.correct = nand_davinci_correct_4bit;
+			info->chip.ecc.hwctl = nand_davinci_hwctl_4bit;
+			info->chip.ecc.bytes = 10;
+		} else {
+			info->chip.ecc.calculate = nand_davinci_calculate_1bit;
+			info->chip.ecc.correct = nand_davinci_correct_1bit;
+			info->chip.ecc.hwctl = nand_davinci_hwctl_1bit;
+			info->chip.ecc.bytes = 3;
+		}
 		info->chip.ecc.size = 512;
-		info->chip.ecc.bytes = 10;
-		info->chip.ecc.prepad = 6;
-		info->chip.bbt_td = &nand_davinci_bbt_main_descr;
-		info->chip.bbt_md = &nand_davinci_bbt_mirror_descr;
 		break;
 	default:
 		ret = -EINVAL;
@@ -837,12 +717,61 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	spin_unlock_irq(&davinci_nand_lock);
 
 	/* Scan to find existence of the device(s) */
-	ret = nand_scan(&info->mtd, pdata->mask_chipsel ? 2 : 1);
+	ret = nand_scan_ident(&info->mtd, pdata->mask_chipsel ? 2 : 1);
 	if (ret < 0) {
 		dev_dbg(&pdev->dev, "no NAND chip(s) found\n");
 		goto err_scan;
 	}
 
+	/* Update ECC layout if needed ... for 1-bit HW ECC, the default
+	 * is OK, but it allocates 6 bytes when only 3 are needed (for
+	 * each 512 bytes).  For the 4-bit HW ECC, that default is not
+	 * usable:  10 bytes are needed, not 6.
+	 */
+	if (pdata->ecc_bits == 4) {
+		int	chunks = info->mtd.writesize / 512;
+
+		if (!chunks || info->mtd.oobsize < 16) {
+			dev_dbg(&pdev->dev, "too small\n");
+			ret = -EINVAL;
+			goto err_scan;
+		}
+
+		/* For small page chips, preserve the manufacturer's
+		 * badblock marking data ... and make sure a flash BBT
+		 * table marker fits in the free bytes.
+		 */
+		if (chunks == 1) {
+			info->ecclayout = hwecc4_small;
+			info->ecclayout.oobfree[1].length =
+				info->mtd.oobsize - 16;
+			goto syndrome_done;
+		}
+		if (chunks == 4) {
+			info->ecclayout = hwecc4_2048;
+			info->chip.ecc.mode = NAND_ECC_HW_OOB_FIRST;
+			goto syndrome_done;
+		}
+
+		/* 4KiB page chips are not yet supported. The eccpos from
+		 * nand_ecclayout cannot hold 80 bytes and change to eccpos[]
+		 * breaks userspace ioctl interface with mtd-utils. Once we
+		 * resolve this issue, NAND_ECC_HW_OOB_FIRST mode can be used
+		 * for the 4KiB page chips.
+		 */
+		dev_warn(&pdev->dev, "no 4-bit ECC support yet "
+				"for 4KiB-page NAND\n");
+		ret = -EIO;
+		goto err_scan;
+
+syndrome_done:
+		info->chip.ecc.layout = &info->ecclayout;
+	}
+
+	ret = nand_scan_tail(&info->mtd);
+	if (ret < 0)
+		goto err_scan;
+
 	if (mtd_has_partitions()) {
 		struct mtd_partition	*mtd_parts = NULL;
 		int			mtd_parts_nb = 0;
@@ -851,22 +780,11 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 			static const char *probes[] __initconst =
 				{ "cmdlinepart", NULL };
 
-			const char		*master_name;
-
-			/* Set info->mtd.name = 0 temporarily */
-			master_name		= info->mtd.name;
-			info->mtd.name		= (char *)0;
-
-			/* info->mtd.name == 0, means: don't bother checking
-			   <mtd-id> */
 			mtd_parts_nb = parse_mtd_partitions(&info->mtd, probes,
 							    &mtd_parts, 0);
-
-			/* Restore info->mtd.name */
-			info->mtd.name = master_name;
 		}
 
-		if (mtd_parts_nb <= 0 && pdata) {
+		if (mtd_parts_nb <= 0) {
 			mtd_parts = pdata->parts;
 			mtd_parts_nb = pdata->nr_parts;
 		}
@@ -879,7 +797,7 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 				info->partitioned = true;
 		}
 
-	} else if (pdata && pdata->nr_parts) {
+	} else if (pdata->nr_parts) {
 		dev_warn(&pdev->dev, "ignoring %d default partitions on %s\n",
 				pdata->nr_parts, info->mtd.name);
 	}
@@ -905,6 +823,11 @@ err_scan:
 err_clk_enable:
 	clk_put(info->clk);
 
+	spin_lock_irq(&davinci_nand_lock);
+	if (ecc_mode == NAND_ECC_HW_SYNDROME)
+		ecc4_busy = false;
+	spin_unlock_irq(&davinci_nand_lock);
+
 err_ecc:
 err_clk:
 err_ioremap:
@@ -928,6 +851,11 @@ static int __exit nand_davinci_remove(struct platform_device *pdev)
 	else
 		status = del_mtd_device(&info->mtd);
 
+	spin_lock_irq(&davinci_nand_lock);
+	if (info->chip.ecc.mode == NAND_ECC_HW_SYNDROME)
+		ecc4_busy = false;
+	spin_unlock_irq(&davinci_nand_lock);
+
 	iounmap(info->base);
 	iounmap(info->vaddr);
 
-- 
1.6.5.2

