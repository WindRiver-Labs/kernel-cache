From ea7c957199209f1948c6da11516c10ef9833d417 Mon Sep 17 00:00:00 2001
From: Sekhar Nori <nsekhar@ti.com>
Date: Fri, 1 Jan 2010 13:32:33 +0530
Subject: [PATCH 04/23] davinci: add support for aemif timing configuration

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.12.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

This patch adds support to configure the AEMIF interface
for user supplied timing values.

Since this capability is useful both from NOR and NAND
flashes, it is provided as a new interface in a file of
its own.

Signed-off-by: Sekhar Nori <nsekhar@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/Makefile             |    2 +-
 arch/arm/mach-davinci/aemif.c              |  100 ++++++++++++++++++++++++++++
 arch/arm/mach-davinci/include/mach/aemif.h |   63 +++++++++++++++++
 arch/arm/mach-davinci/include/mach/nand.h  |    4 +-
 4 files changed, 165 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm/mach-davinci/aemif.c
 create mode 100644 arch/arm/mach-davinci/include/mach/aemif.h

diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 6aac880..c3ce72a 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -5,7 +5,7 @@
 
 # Common objects
 obj-y 			:= time.o clock.o serial.o io.o psc.o \
-			   gpio.o dma.o usb.o common.o sram.o
+			   gpio.o dma.o usb.o common.o sram.o aemif.o
 
 obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
 
diff --git a/arch/arm/mach-davinci/aemif.c b/arch/arm/mach-davinci/aemif.c
new file mode 100644
index 0000000..0102c34
--- /dev/null
+++ b/arch/arm/mach-davinci/aemif.c
@@ -0,0 +1,100 @@
+/*
+ * AEMIF support for DaVinci SoCs
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated. http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/module.h>
+
+#include <mach/aemif.h>
+
+/* timing calculations */
+
+#define NS_IN_KHZ 1000000
+
+/*
+ * aemif_calc_rate - calculate timing data.
+ * @wanted: The cycle time in nanoseconds.
+ * @clk: The clock rate in kHz.
+ * @max: The maximum divider value.
+ *
+ * Calculate the timing value from the given parameters.
+ */
+static int aemif_calc_rate(int wanted, unsigned long clk, int max)
+{
+	int result;
+
+	result = DIV_ROUND_UP((wanted * clk), NS_IN_KHZ);
+
+	pr_debug("%s: result %d from %ld, %d\n", __func__, result, clk, wanted);
+
+	if (result > max) {
+		pr_err("%s: %d ns is too big for current clock rate %ld\n",
+							__func__, wanted, clk);
+		return -EINVAL;
+	}
+
+	if (result < 1)
+		result = 1;
+
+	return result;
+}
+
+int davinci_aemif_setup_timing(struct davinci_aemif_timing *t,
+					void __iomem *base, unsigned cs)
+{
+	unsigned set, val;
+	unsigned ta, rhold, rstrobe, rsetup, whold, wstrobe, wsetup;
+	unsigned offset = A1CR_OFFSET + cs * 4;
+	struct clk *aemif_clk;
+	unsigned long clkrate;
+
+	if (!t)
+		return 0;	/* Nothing to do */
+
+	aemif_clk = clk_get(NULL, "aemif");
+	if (IS_ERR(aemif_clk))
+		return PTR_ERR(aemif_clk);
+
+	clkrate = clk_get_rate(aemif_clk);
+
+	clkrate /= 1000;	/* turn clock into kHz for ease of use */
+
+	ta	= aemif_calc_rate(t->ta, clkrate, TA_MAX);
+	rhold	= aemif_calc_rate(t->rhold, clkrate, RHOLD_MAX);
+	rstrobe	= aemif_calc_rate(t->rstrobe, clkrate, RSTROBE_MAX);
+	rsetup	= aemif_calc_rate(t->rsetup, clkrate, RSETUP_MAX);
+	whold	= aemif_calc_rate(t->whold, clkrate, WHOLD_MAX);
+	wstrobe	= aemif_calc_rate(t->wstrobe, clkrate, WSTROBE_MAX);
+	wsetup	= aemif_calc_rate(t->wsetup, clkrate, WSETUP_MAX);
+
+	if (ta < 0 || rhold < 0 || rstrobe < 0 || rsetup < 0 ||
+			whold < 0 || wstrobe < 0 || wsetup < 0) {
+		pr_err("%s: cannot get suitable timings\n", __func__);
+		return -EINVAL;
+	}
+
+	set = TA(ta - 1) |
+		RHOLD(rhold - 1) |
+		RSTROBE(rstrobe - 1) |
+		RSETUP(rsetup - 1) |
+		WHOLD(whold - 1) |
+		WSTROBE(wstrobe - 1) |
+		WSETUP(wsetup - 1);
+
+	val = __raw_readl(base + offset);
+	val &= ~TIMING_MASK;
+	val |= set;
+	__raw_writel(val, base + offset);
+
+	return 0;
+}
+EXPORT_SYMBOL(davinci_aemif_setup_timing);
diff --git a/arch/arm/mach-davinci/include/mach/aemif.h b/arch/arm/mach-davinci/include/mach/aemif.h
new file mode 100644
index 0000000..a524cd2
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/aemif.h
@@ -0,0 +1,63 @@
+/*
+ * TI DaVinci AEMIF support
+ *
+ * 2009 (C) Texas Instruments, Inc. http://www.ti.com/
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifndef _MACH_DAVINCI_AEMIF_H
+#define _MACH_DAVINCI_AEMIF_H
+
+#define NRCSR_OFFSET		0x00
+#define AWCCR_OFFSET		0x04
+#define A1CR_OFFSET		0x10
+
+#define ACR_ASIZE_MASK		0x3
+#define ACR_EW_MASK		BIT(30)
+#define ACR_SS_MASK		BIT(31)
+
+/* Timing value configuration */
+#define TA(x)			((x) << 2)
+#define RHOLD(x)		((x) << 4)
+#define RSTROBE(x)		((x) << 7)
+#define RSETUP(x)		((x) << 13)
+#define WHOLD(x)		((x) << 17)
+#define WSTROBE(x)		((x) << 20)
+#define WSETUP(x)		((x) << 26)
+
+#define TA_MAX			0x3
+#define RHOLD_MAX		0x7
+#define RSTROBE_MAX		0x3f
+#define RSETUP_MAX		0xf
+#define WHOLD_MAX		0x7
+#define WSTROBE_MAX		0x3f
+#define WSETUP_MAX		0xf
+
+#define TIMING_MASK		(TA(TA_MAX) | \
+					RHOLD(RHOLD_MAX) | \
+					RSTROBE(RSTROBE_MAX) |	\
+					RSETUP(RSETUP_MAX) | \
+					WHOLD(WHOLD_MAX) | \
+					WSTROBE(WSTROBE_MAX) | \
+					WSETUP(WSETUP_MAX))
+
+
+/* All timings in nanoseconds */
+struct davinci_aemif_timing {
+	u8	wsetup;
+	u8	wstrobe;
+	u8	whold;
+
+	u8	rsetup;
+	u8	rstrobe;
+	u8	rhold;
+
+	u8	ta;
+};
+
+int davinci_aemif_setup_timing(struct davinci_aemif_timing *t,
+					void __iomem *base, unsigned cs);
+
+#endif
diff --git a/arch/arm/mach-davinci/include/mach/nand.h b/arch/arm/mach-davinci/include/mach/nand.h
index b2ad809..2b4657b 100644
--- a/arch/arm/mach-davinci/include/mach/nand.h
+++ b/arch/arm/mach-davinci/include/mach/nand.h
@@ -28,11 +28,9 @@
 #ifndef __ARCH_ARM_DAVINCI_NAND_H
 #define __ARCH_ARM_DAVINCI_NAND_H
 
+#include <mach/aemif.h>
 #include <linux/mtd/nand.h>
 
-#define NRCSR_OFFSET		0x00
-#define AWCCR_OFFSET		0x04
-#define A1CR_OFFSET		0x10
 #define NANDFCR_OFFSET		0x60
 #define NANDFSR_OFFSET		0x64
 #define NANDF1ECC_OFFSET	0x70
-- 
1.6.5.2

