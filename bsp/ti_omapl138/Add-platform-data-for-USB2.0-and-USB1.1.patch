From 48a7c5bd772b8cbf64270f8b132b10c55809acaf Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 20 May 2010 22:25:11 +0800
Subject: [PATCH 08/23] Add platform data for USB2.0 and USB1.1

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.12.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add platform data for USB2.0 and USB1.1

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c    |  108 ++++++++++++++++++++++++++++
 arch/arm/mach-davinci/da850.c              |   22 ++++++
 arch/arm/mach-davinci/include/mach/da8xx.h |    2 +
 arch/arm/mach-davinci/include/mach/mux.h   |    2 +
 arch/arm/mach-davinci/usb.c                |   65 +++++++++++++++++
 include/linux/usb/musb.h                   |    3 +
 6 files changed, 202 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index b3deb46..304d355 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -25,6 +25,7 @@
 #include <linux/regulator/machine.h>
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
+#include <linux/usb/musb.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -45,6 +46,8 @@
 #define DA850_MMCSD_WP_PIN		GPIO_TO_PIN(4, 1)
 
 #define DA850_MII_MDIO_CLKEN_PIN	GPIO_TO_PIN(2, 6)
+#define DA850_USB1_VBUS_PIN             GPIO_TO_PIN(2, 4)
+#define DA850_USB1_OC_PIN               GPIO_TO_PIN(6, 13)
 
 static struct mtd_partition da850_evm_norflash_partition[] = {
 	{
@@ -659,6 +662,109 @@ static int __init da850_evm_config_emac(void)
 }
 device_initcall(da850_evm_config_emac);
 
+static da8xx_ocic_handler_t da850_evm_usb_ocic_handler;
+
+static int da850_evm_usb_set_power(unsigned port, int on)
+{
+	gpio_set_value(DA850_USB1_VBUS_PIN, on);
+	return 0;
+}
+
+static int da850_evm_usb_get_power(unsigned port)
+{
+	return gpio_get_value(DA850_USB1_VBUS_PIN);
+}
+
+static int da850_evm_usb_get_oci(unsigned port)
+{
+	return !gpio_get_value(DA850_USB1_OC_PIN);
+}
+
+static irqreturn_t da850_evm_usb_ocic_irq(int, void *);
+
+static int da850_evm_usb_ocic_notify(da8xx_ocic_handler_t handler)
+{
+	int irq		= gpio_to_irq(DA850_USB1_OC_PIN);
+	int error	= 0;
+
+	if (handler != NULL) {
+		da850_evm_usb_ocic_handler = handler;
+
+		error = request_irq(irq, da850_evm_usb_ocic_irq, IRQF_DISABLED |
+				    IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				    "OHCI over-current indicator", NULL);
+		if (error)
+			printk(KERN_ERR "%s: could not request IRQ to watch "
+			       "over-current indicator changes\n", __func__);
+	} else
+		free_irq(irq, NULL);
+
+	return error;
+}
+
+static struct da8xx_ohci_root_hub da850_evm_usb11_pdata = {
+	.set_power	= da850_evm_usb_set_power,
+	.get_power	= da850_evm_usb_get_power,
+	.get_oci	= da850_evm_usb_get_oci,
+	.ocic_notify	= da850_evm_usb_ocic_notify,
+
+	/* TPS2065 switch @ 5V */
+	.potpgt		= (3 + 1) / 2,	/* 3 ms max */
+};
+
+static irqreturn_t da850_evm_usb_ocic_irq(int irq, void *dev_id)
+{
+	da850_evm_usb_ocic_handler(&da850_evm_usb11_pdata, 1);
+	return IRQ_HANDLED;
+}
+
+static __init void da850_evm_usb_init(void)
+{
+	int ret;
+	u32 cfgchip2;
+
+	/*
+	 * Setup the Ref. clock frequency for the EVM at 24 MHz.
+	 */
+	cfgchip2 = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));
+	cfgchip2 &= ~CFGCHIP2_REFFREQ;
+	cfgchip2 |=  CFGCHIP2_REFFREQ_24MHZ;
+	__raw_writel(cfgchip2, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));
+
+	ret = da8xx_register_usb20(1000, 3);
+	if (ret)
+		pr_warning("%s: USB 2.0 registration failed: %d\n",
+				__func__, ret);
+
+	ret = da8xx_pinmux_setup(da850_evm_usb11_pins);
+	if (ret) {
+		pr_warning("%s: USB 1.1 PinMux setup failed: %d\n",
+			   __func__, ret);
+		return;
+	}
+
+	ret = gpio_request(DA850_USB1_VBUS_PIN, "USB1 VBUS\n");
+	if (ret) {
+		printk(KERN_ERR "%s: failed to request GPIO for USB 1.1 port "
+		       "power control: %d\n", __func__, ret);
+		return;
+	}
+	gpio_direction_output(DA850_USB1_VBUS_PIN, 0);
+
+	ret = gpio_request(DA850_USB1_OC_PIN, "USB1 OC");
+	if (ret) {
+		printk(KERN_ERR "%s: failed to request GPIO for USB 1.1 port "
+		       "over-current indicator: %d\n", __func__, ret);
+		return;
+	}
+	gpio_direction_input(DA850_USB1_OC_PIN);
+
+	ret = da8xx_register_usb11(&da850_evm_usb11_pdata);
+	if (ret)
+		pr_warning("%s: USB 1.1 registration failed: %d\n",
+			   __func__, ret);
+}
+
 static __init void da850_evm_init(void)
 {
 	int ret;
@@ -781,6 +887,8 @@ static __init void da850_evm_init(void)
 
 	da850_init_spi1(BIT(0), da850_spi_board_info,
 			ARRAY_SIZE(da850_spi_board_info));
+
+	da850_evm_usb_init();
 }
 
 #ifdef CONFIG_SERIAL_8250_CONSOLE
diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
index a4eafa6..e592268 100644
--- a/arch/arm/mach-davinci/da850.c
+++ b/arch/arm/mach-davinci/da850.c
@@ -349,6 +349,21 @@ static struct clk spi1_clk = {
 	.flags		= DA850_CLK_ASYNC3,
 };
 
+static struct clk usb11_clk = {
+	.name		= "usb11",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC1_USB11,
+	.gpsc		= 1,
+};
+
+static struct clk usb20_clk = {
+	.name		= "usb20",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC1_USB20,
+	.gpsc		= 1,
+};
+
+
 static struct clk_lookup da850_clks[] = {
 	CLK(NULL,		"ref",		&ref_clk),
 	CLK(NULL,		"pll0",		&pll0_clk),
@@ -392,6 +407,8 @@ static struct clk_lookup da850_clks[] = {
 	CLK("davinci_mmc.1",	NULL,		&mmcsd1_clk),
 	CLK(NULL,		"aemif",	&aemif_clk),
 	CLK("spi_davinci.1",	NULL,		&spi1_clk),
+	CLK(NULL,		"usb11",	&usb11_clk),
+	CLK(NULL,		"usb20",	&usb20_clk),
 	CLK(NULL,		NULL,		NULL),
 };
 
@@ -559,6 +576,8 @@ static const struct mux_config da850_pins[] = {
 	MUX_CFG(DA850, GPIO4_0,		10,	28,	15,	8,	false)
 	MUX_CFG(DA850, GPIO4_1,		10,	24,	15,	8,	false)
 	MUX_CFG(DA850, RTC_ALARM,	0,	28,	15,	2,	false)
+	MUX_CFG(DA850, GPIO2_4,		6,	12,	15,	8,	false)
+	MUX_CFG(DA850, GPIO6_13,	13,	8,	15,	8,	false)
 #endif
 };
 
@@ -656,6 +675,9 @@ const short da850_spi1_pins[] __initdata = {
 	-1
 };
 
+const short da850_evm_usb11_pins[] __initdata = {
+	DA850_GPIO2_4, DA850_GPIO6_13, -1
+};
 /* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
 static u8 da850_default_priorities[DA850_N_CP_INTC_IRQ] = {
 	[IRQ_DA8XX_COMMTX]		= 7,
diff --git a/arch/arm/mach-davinci/include/mach/da8xx.h b/arch/arm/mach-davinci/include/mach/da8xx.h
index 06b47fc..50836af 100644
--- a/arch/arm/mach-davinci/include/mach/da8xx.h
+++ b/arch/arm/mach-davinci/include/mach/da8xx.h
@@ -64,6 +64,7 @@ extern void __iomem *da8xx_syscfg1_base;
 #define DA8XX_AEMIF_CTL_BASE	0x68000000
 #define DA8XX_DDR2_CTL_BASE	0xb0000000
 #define DA8XX_ARM_RAM_BASE	0xffff0000
+#define DA8XX_USB0_BASE		0x01e00000
 
 #define PINMUX0			0x00
 #define PINMUX1			0x04
@@ -150,6 +151,7 @@ extern const short da850_mmcsd0_pins[];
 extern const short da850_nand_pins[];
 extern const short da850_nor_pins[];
 extern const short da850_spi1_pins[];
+extern const short da850_evm_usb11_pins[];
 
 #ifdef CONFIG_DAVINCI_MUX
 int da8xx_pinmux_setup(const short pins[]);
diff --git a/arch/arm/mach-davinci/include/mach/mux.h b/arch/arm/mach-davinci/include/mach/mux.h
index 78be721..4289a71 100644
--- a/arch/arm/mach-davinci/include/mach/mux.h
+++ b/arch/arm/mach-davinci/include/mach/mux.h
@@ -908,6 +908,8 @@ enum davinci_da850_index {
 	DA850_GPIO4_0,
 	DA850_GPIO4_1,
 	DA850_RTC_ALARM,
+	DA850_GPIO2_4,
+	DA850_GPIO6_13,
 };
 
 #ifdef CONFIG_DAVINCI_MUX
diff --git a/arch/arm/mach-davinci/usb.c b/arch/arm/mach-davinci/usb.c
index 31f0cbe..a5d8377 100644
--- a/arch/arm/mach-davinci/usb.c
+++ b/arch/arm/mach-davinci/usb.c
@@ -11,6 +11,7 @@
 #include <mach/irqs.h>
 #include <mach/cputype.h>
 #include <mach/usb.h>
+#include <mach/da8xx.h>
 
 #define DAVINCI_USB_OTG_BASE	0x01c64000
 
@@ -85,6 +86,69 @@ static struct platform_device usb_dev = {
 	.num_resources  = ARRAY_SIZE(usb_resources),
 };
 
+#define CFGCHIP2        DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG)
+/*
+ * Configure the USB PHY for DA8xx platforms.
+ */
+static int da8xx_usb_phy_config(struct device *dev, u8 mode, int is_on)
+{
+	u32 cfgchip2;
+
+	/*
+	 * Start the on-chip PHY and its PLL.
+	 */
+	cfgchip2 = __raw_readl(CFGCHIP2);
+
+	if (is_on) {
+		/* Check whether USB0 PHY is already powered on */
+		if (cfgchip2 & CFGCHIP2_PHY_PLLON)
+			return 0;
+
+		cfgchip2 &= ~(CFGCHIP2_RESET | CFGCHIP2_PHYPWRDN |
+				CFGCHIP2_OTGPWRDN | CFGCHIP2_OTGMODE |
+				CFGCHIP2_REFFREQ);
+		cfgchip2 |= CFGCHIP2_SESENDEN | CFGCHIP2_VBDTCTEN |
+				CFGCHIP2_PHY_PLLON | CFGCHIP2_REFFREQ_24MHZ;
+		switch (mode) {
+		case MUSB_OTG:
+			cfgchip2 |= CFGCHIP2_NO_OVERRIDE;
+			break;
+		case MUSB_HOST:
+			cfgchip2 |= CFGCHIP2_FORCE_HOST;
+			break;
+		case MUSB_PERIPHERAL:
+			cfgchip2 |= CFGCHIP2_FORCE_DEVICE;
+			break;
+		default:
+			pr_err("Trying to set unsupported mode");
+			break;
+		}
+	} else {
+		/* Ensure that usb1.1 interface clk is not being sourced from
+		 * usb0 interface.  If so do not power down usb0 PHY
+		 */
+		if ((cfgchip2 & CFGCHIP2_USB1SUSPENDM) &&
+			!(cfgchip2 & CFGCHIP2_USB1PHYCLKMUX)) {
+			printk(KERN_WARNING "USB1 interface active -\
+				Cannot Power down USB0 PHY\n");
+			return 0;
+		}
+
+		cfgchip2 &= ~CFGCHIP2_PHY_PLLON;
+		cfgchip2 |= CFGCHIP2_PHYPWRDN | CFGCHIP2_OTGPWRDN;
+	}
+
+	__raw_writel(cfgchip2, CFGCHIP2);
+
+	if (is_on) {
+		while (!(__raw_readl(CFGCHIP2) & CFGCHIP2_PHYCLKGD))
+			cpu_relax();
+		pr_info("Waiting for USB PHY clock good...\n");
+	}
+
+	return 0;
+}
+
 void __init davinci_setup_usb(unsigned mA, unsigned potpgt_ms)
 {
 	usb_data.power = mA > 510 ? 255 : mA / 2;
@@ -118,6 +182,7 @@ int __init da8xx_register_usb20(unsigned mA, unsigned potpgt)
 	usb_data.clock  = "usb20";
 	usb_data.power	= mA > 510 ? 255 : mA / 2;
 	usb_data.potpgt = (potpgt + 1) / 2;
+	usb_data.phy_config = da8xx_usb_phy_config;
 
 	usb_dev.resource = da8xx_usb20_resources;
 	usb_dev.num_resources = ARRAY_SIZE(da8xx_usb20_resources);
diff --git a/include/linux/usb/musb.h b/include/linux/usb/musb.h
index 7acef02..0608a93 100644
--- a/include/linux/usb/musb.h
+++ b/include/linux/usb/musb.h
@@ -85,6 +85,9 @@ struct musb_hdrc_platform_data {
 	/* Turn device clock on or off */
 	int		(*set_clock)(struct clk *clock, int is_on);
 
+	/* Configure the USB Phy */
+	int		(*phy_config)(struct device *dev, u8 mode, int is_on);
+
 	/* MUSB configuration-specific details */
 	struct musb_hdrc_config	*config;
 
-- 
1.7.0.4

