From f604e81c1d4c9996c29036e2821afa2204f7888d Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 25 May 2010 14:22:04 +0800
Subject: [PATCH 16/23] Add DA850 platform support to AHCI module

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.12.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add DA850 platform support to AHCI module

Signed-off-by: Swaminathan S <swami.iyer@ti.com>
Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/ata/Kconfig         |    2 +-
 drivers/ata/Makefile        |    2 +-
 drivers/ata/ahci-platform.c |   30 +++++
 drivers/ata/ahci-ti.c       |  122 +++++++++++++++++++
 drivers/ata/ahci.c          |  280 +++++++++++++++++++++++++++++++++++++++----
 include/linux/libata.h      |    6 +
 6 files changed, 419 insertions(+), 23 deletions(-)
 create mode 100644 drivers/ata/ahci-platform.c
 create mode 100644 drivers/ata/ahci-ti.c

diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 01c52c4..40591c9 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -59,7 +59,7 @@ config SATA_PMP
 
 config SATA_AHCI
 	tristate "AHCI SATA support"
-	depends on PCI
+	depends on PCI || ARCH_DAVINCI_DA850
 	help
 	  This option enables support for AHCI Serial ATA.
 
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index fc936d4..19c7847 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -86,7 +86,7 @@ obj-$(CONFIG_ATA_GENERIC)	+= ata_generic.o
 # Should be last libata driver
 obj-$(CONFIG_PATA_LEGACY)	+= pata_legacy.o
 
-libata-objs	:= libata-core.o libata-scsi.o libata-eh.o
+libata-objs	:= libata-core.o libata-scsi.o libata-eh.o ahci-platform.o
 libata-$(CONFIG_ATA_SFF)	+= libata-sff.o
 libata-$(CONFIG_SATA_PMP)	+= libata-pmp.o
 libata-$(CONFIG_ATA_ACPI)	+= libata-acpi.o
diff --git a/drivers/ata/ahci-platform.c b/drivers/ata/ahci-platform.c
new file mode 100644
index 0000000..dc02199
--- /dev/null
+++ b/drivers/ata/ahci-platform.c
@@ -0,0 +1,30 @@
+/*
+ * TI AHCI SATA controler
+ *
+ * TI SATA controller on OMAPL138 platform.  AHCI compliant controller.
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * ---------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ---------------------------------------------------------------------------
+ * History:
+ * 0-1 Swaminathan Subbarathnam : Initial creation of AHCI platform specific
+ *     interface for non-PCI based SATA AHCI implementation.
+ */
+#ifdef CONFIG_ARCH_DAVINCI_DA850
+#include "ahci-ti.c"
+#endif
diff --git a/drivers/ata/ahci-ti.c b/drivers/ata/ahci-ti.c
new file mode 100644
index 0000000..d526644
--- /dev/null
+++ b/drivers/ata/ahci-ti.c
@@ -0,0 +1,122 @@
+/*
+ * TI AHCI SATA controler
+ *
+ * TI SATA controller on OMAPL138 platform.  AHCI compliant controller.
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * ---------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ---------------------------------------------------------------------------
+ * History:
+ * 0-1 Swaminathan Subbarathnam : Initial creation of AHCI platform specific
+ *     interface for non-PCI based SATA AHCI implementation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/dmi.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_cmnd.h>
+#include <linux/libata.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/cputype.h>
+#include <mach/da8xx.h>
+
+#define P0PHYCR	0x178  /* SATA PHY Control Register offset
+			* from AHCI base
+			*/
+
+#define PHY_MPY		8 /* bits3:0     4 Clock Sources at 100MHz */
+#define PHY_LB		0 /* bits5:4     2 */
+#define PHY_LOS		1 /* bit6        1 */
+#define PHY_RXINVPAIR	0 /* bit7        1 */
+#define PHY_RXTERM	0 /* bits9:8     2 */
+#define PHY_RXCDR	0 /* bits12:10   3 */
+#define PHY_RXEQ	1 /* bits16:13   4 */
+#define PHY_TXINVPAIR	0 /* bit17       1 */
+#define PHY_TXCM	0 /* bit18       1 */
+#define PHY_TXSWING	3 /* bits21:19   3 */
+#define PHY_TXDE	0 /* bits25:22   4 */
+#define PHY_OVERRIDE	0 /* bit30       1 */
+#define PHY_ENPLL	1 /* bit31       1 */
+
+
+
+/* ata_plat_init - Do platform specific init of the AHCI SATA controller.
+ * @base - Base address of the AHCI SATA controller
+ */
+void ata_plat_init(void __iomem *base)
+{
+	u32	phy_val = 0;
+
+	/* Power up the PHY clock source */
+	if (cpu_is_davinci_da850())
+		__raw_writel(0, IO_ADDRESS(DA850_SATA_CLK_PWRDN));
+
+	phy_val = PHY_MPY << 0 | PHY_LB << 4 | PHY_LOS << 6 |
+			PHY_RXINVPAIR << 7 | PHY_RXTERM << 8 |
+			PHY_RXCDR  << 10 | PHY_RXEQ << 13 |
+			PHY_RXINVPAIR << 17 | PHY_TXCM << 18 |
+			PHY_TXSWING << 19 | PHY_TXDE << 22 |
+			PHY_OVERRIDE << 30 | PHY_ENPLL	<< 31;
+
+	/* Initialize the SATA PHY */
+	writel(phy_val, base + P0PHYCR);
+}
+EXPORT_SYMBOL_GPL(ata_plat_init);
+
+/* ata_plat_remove - Do platform specific de-init of the AHCI SATA controller.
+ * @host - ATA Host pointer of the controller.
+ */
+void ata_plat_remove(struct ata_host *host)
+{
+	/* Power down the PHY clock source */
+	if (cpu_is_davinci_da850())
+		__raw_writel(1, IO_ADDRESS(DA850_SATA_CLK_PWRDN));
+}
+EXPORT_SYMBOL_GPL(ata_plat_remove);
+
+void ahci_platform_suspend(struct platform_device *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	u32	phy_val = 0;
+
+	phy_val = readl(host->iomap + P0PHYCR);
+
+	phy_val &= ~(PHY_ENPLL << 31);
+	writel(phy_val, host->iomap + P0PHYCR);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_suspend);
+
+void ahci_platform_resume(struct platform_device *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	u32	phy_val = 0;
+
+	phy_val = readl(host->iomap + P0PHYCR);
+
+	phy_val |= PHY_ENPLL << 31;
+	writel(phy_val, host->iomap + P0PHYCR);
+}
+EXPORT_SYMBOL_GPL(ahci_platform_resume);
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 5326af2..90f3ab2 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -34,7 +34,9 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#ifdef CONFIG_PCI
 #include <linux/pci.h>
+#endif
 #include <linux/init.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
@@ -46,6 +48,11 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_cmnd.h>
 #include <linux/libata.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <mach/cputype.h>
+#include <mach/da8xx.h>
 
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
@@ -118,6 +125,7 @@ enum {
 	board_ahci_nopmp	= 7,
 	board_ahci_yesncq	= 8,
 	board_ahci_nosntf	= 9,
+	board_ahci_da850	= 10,
 
 	/* global controller registers */
 	HOST_CAP		= 0x00, /* host capabilities */
@@ -303,6 +311,8 @@ struct ahci_host_priv {
 	u32			saved_cap2;	/* saved initial cap2 */
 	u32			saved_port_map;	/* saved initial port_map */
 	u32 			em_loc; /* enclosure management location */
+	void			*base;
+	u32			irq;
 };
 
 struct ahci_port_priv {
@@ -327,7 +337,11 @@ struct ahci_port_priv {
 
 static int ahci_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);
 static int ahci_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);
+#ifdef CONFIG_PCI
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
+#else
+static int ahci_init_one(struct platform_device *pdev);
+#endif
 static unsigned int ahci_qc_issue(struct ata_queued_cmd *qc);
 static bool ahci_qc_fill_rtf(struct ata_queued_cmd *qc);
 static int ahci_port_start(struct ata_port *ap);
@@ -348,8 +362,10 @@ static int ahci_hardreset(struct ata_link *link, unsigned int *class,
 			  unsigned long deadline);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
+#ifdef CONFIG_PCI
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline);
+#endif
 static void ahci_postreset(struct ata_link *link, unsigned int *class);
 static void ahci_error_handler(struct ata_port *ap);
 static void ahci_post_internal_cmd(struct ata_queued_cmd *qc);
@@ -359,9 +375,11 @@ static void ahci_fill_cmd_slot(struct ahci_port_priv *pp, unsigned int tag,
 			       u32 opts);
 #ifdef CONFIG_PM
 static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg);
+#ifdef CONFIG_PCI
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg);
 static int ahci_pci_device_resume(struct pci_dev *pdev);
-#endif
+#endif /* CONFIG_PCI */
+#endif /* CONFIG_PM */
 static ssize_t ahci_activity_show(struct ata_device *dev, char *buf);
 static ssize_t ahci_activity_store(struct ata_device *dev,
 				   enum sw_activity val);
@@ -449,10 +467,12 @@ static struct ata_port_operations ahci_vt8251_ops = {
 	.hardreset		= ahci_vt8251_hardreset,
 };
 
+#ifdef CONFIG_PCI
 static struct ata_port_operations ahci_p5wdh_ops = {
 	.inherits		= &ahci_ops,
 	.hardreset		= ahci_p5wdh_hardreset,
 };
+#endif
 
 static struct ata_port_operations ahci_sb600_ops = {
 	.inherits		= &ahci_ops,
@@ -546,8 +566,16 @@ static const struct ata_port_info ahci_port_info[] = {
 		.udma_mask	= ATA_UDMA6,
 		.port_ops	= &ahci_ops,
 	},
+	[board_ahci_da850] =
+	{
+		.flags		= AHCI_FLAG_COMMON,
+		.pio_mask	= ATA_PIO4,
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &ahci_ops,
+	},
 };
 
+#ifdef CONFIG_PCI
 static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Intel */
 	{ PCI_VDEVICE(INTEL, 0x2652), board_ahci }, /* ICH6 */
@@ -736,6 +764,7 @@ static struct pci_driver ahci_pci_driver = {
 	.resume			= ahci_pci_device_resume,
 #endif
 };
+#endif /* CONFIG_PCI */
 
 static int ahci_em_messages = 1;
 module_param(ahci_em_messages, int, 0444);
@@ -760,8 +789,11 @@ static inline int ahci_nr_ports(u32 cap)
 static inline void __iomem *__ahci_port_base(struct ata_host *host,
 					     unsigned int port_no)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
-
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	return mmio + 0x100 + (port_no * 0x80);
 }
 
@@ -850,13 +882,22 @@ static ssize_t ahci_show_port_cmd(struct device *dev,
  *	LOCKING:
  *	None.
  */
+#ifdef CONFIG_PCI
 static void ahci_save_initial_config(struct pci_dev *pdev,
 				     struct ahci_host_priv *hpriv)
+#else
+static void ahci_save_initial_config(struct platform_device *pdev,
+				     struct ahci_host_priv *hpriv)
+#endif
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+	int mv;
+#else
+	void __iomem *mmio = hpriv->base;
+#endif
 	u32 cap, cap2, vers, port_map;
 	int i;
-	int mv;
 
 	/* make sure AHCI mode is enabled before accessing CAP */
 	ahci_enable_ahci(mmio);
@@ -905,7 +946,7 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 			   "controller can't do SNTF, turning off CAP_SNTF\n");
 		cap &= ~HOST_CAP_SNTF;
 	}
-
+#ifdef CONFIG_PCI
 	if (pdev->vendor == PCI_VENDOR_ID_JMICRON && pdev->device == 0x2361 &&
 	    port_map != 1) {
 		dev_printk(KERN_INFO, &pdev->dev,
@@ -933,6 +974,7 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 
 		port_map &= mv;
 	}
+#endif
 
 	/* cross check port_map and cap.n_ports */
 	if (port_map) {
@@ -982,8 +1024,11 @@ static void ahci_save_initial_config(struct pci_dev *pdev,
 static void ahci_restore_initial_config(struct ata_host *host)
 {
 	struct ahci_host_priv *hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
-
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	writel(hpriv->saved_cap, mmio + HOST_CAP);
 	if (hpriv->saved_cap2)
 		writel(hpriv->saved_cap2, mmio + HOST_CAP2);
@@ -1189,6 +1234,8 @@ static int ahci_enable_alpm(struct ata_port *ap,
 	u32 cmd;
 	struct ahci_port_priv *pp = ap->private_data;
 	u32 asp;
+	struct platform_device *pdev = to_platform_device(ap->host->dev);
+	unsigned int board_id = *(int *)pdev->dev.platform_data;
 
 	/* Make sure the host is capable of link power management */
 	if (!(hpriv->cap & HOST_CAP_ALPM))
@@ -1246,7 +1293,8 @@ static int ahci_enable_alpm(struct ata_port *ap,
  	 * enter a lower power link state when it's appropriate and
  	 * based on the value set above for ASP
  	 */
-	cmd |= PORT_CMD_ALPE;
+	if (board_id != board_ahci_da850)
+		cmd |= PORT_CMD_ALPE;
 
 	/* write out new cmd value */
 	writel(cmd, port_mmio + PORT_CMD);
@@ -1339,9 +1387,13 @@ static int ahci_deinit_port(struct ata_port *ap, const char **emsg)
 
 static int ahci_reset_controller(struct ata_host *host)
 {
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	struct ahci_host_priv *hpriv = host->private_data;
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 tmp;
 
 	/* we must be in AHCI mode, before using anything
@@ -1382,7 +1434,7 @@ static int ahci_reset_controller(struct ata_host *host)
 	} else
 		dev_printk(KERN_INFO, host->dev,
 			   "skipping global host reset\n");
-
+#ifdef CONFIG_PCI
 	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
 		u16 tmp16;
 
@@ -1393,7 +1445,7 @@ static int ahci_reset_controller(struct ata_host *host)
 			pci_write_config_word(pdev, 0x92, tmp16);
 		}
 	}
-
+#endif
 	return 0;
 }
 
@@ -1472,7 +1524,11 @@ static void ahci_init_sw_activity(struct ata_link *link)
 
 static int ahci_reset_em(struct ata_host *host)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 em_ctl;
 
 	em_ctl = readl(mmio + HOST_EM_CTL);
@@ -1488,7 +1544,11 @@ static ssize_t ahci_transmit_led_message(struct ata_port *ap, u32 state,
 {
 	struct ahci_host_priv *hpriv = ap->host->private_data;
 	struct ahci_port_priv *pp = ap->private_data;
+#ifdef CONFIG_PCI
 	void __iomem *mmio = ap->host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)ap->host->iomap;
+#endif
 	u32 em_ctl;
 	u32 message[] = {0, 0};
 	unsigned long flags;
@@ -1623,8 +1683,11 @@ static ssize_t ahci_activity_show(struct ata_device *dev, char *buf)
 	 */
 	return sprintf(buf, "%d\n", emp->blink_policy);
 }
-
+#ifdef CONFIG_PCI
 static void ahci_port_init(struct pci_dev *pdev, struct ata_port *ap,
+#else
+static void ahci_port_init(struct platform_device *pdev, struct ata_port *ap,
+#endif
 			   int port_no, void __iomem *mmio,
 			   void __iomem *port_mmio)
 {
@@ -1654,12 +1717,18 @@ static void ahci_port_init(struct pci_dev *pdev, struct ata_port *ap,
 
 static void ahci_init_controller(struct ata_host *host)
 {
+#ifdef CONFIG_PCI
 	struct ahci_host_priv *hpriv = host->private_data;
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	struct platform_device *pdev = to_platform_device(host->dev);
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	int i;
 	void __iomem *port_mmio;
 	u32 tmp;
+#ifdef CONFIG_PCI
 	int mv;
 
 	if (hpriv->flags & AHCI_HFLAG_MV_PATA) {
@@ -1677,7 +1746,7 @@ static void ahci_init_controller(struct ata_host *host)
 		if (tmp)
 			writel(tmp, port_mmio + PORT_IRQ_STAT);
 	}
-
+#endif
 	for (i = 0; i < host->n_ports; i++) {
 		struct ata_port *ap = host->ports[i];
 
@@ -1999,6 +2068,7 @@ static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 	return online ? -EAGAIN : rc;
 }
 
+#ifdef CONFIG_PCI
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 				unsigned long deadline)
 {
@@ -2042,6 +2112,7 @@ static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
 	}
 	return rc;
 }
+#endif
 
 static void ahci_postreset(struct ata_link *link, unsigned int *class)
 {
@@ -2375,7 +2446,11 @@ static irqreturn_t ahci_interrupt(int irq, void *dev_instance)
 	VPRINTK("ENTER\n");
 
 	hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	mmio = (void __iomem *)host->iomap;
+#endif
 
 	/* sigh.  0xffffffff is a valid return from h/w */
 	irq_stat = readl(mmio + HOST_IRQ_STAT);
@@ -2476,7 +2551,11 @@ static void ahci_freeze(struct ata_port *ap)
 
 static void ahci_thaw(struct ata_port *ap)
 {
+#ifdef CONFIG_PCI
 	void __iomem *mmio = ap->host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = (void __iomem *)ap->host->iomap;
+#endif
 	void __iomem *port_mmio = ahci_port_base(ap);
 	u32 tmp;
 	struct ahci_port_priv *pp = ap->private_data;
@@ -2607,6 +2686,7 @@ static void ahci_pmp_detach(struct ata_port *ap)
 	writel(pp->intr_mask, port_mmio + PORT_IRQ_MASK);
 }
 
+#ifdef CONFIG_PM
 static int ahci_port_resume(struct ata_port *ap)
 {
 	ahci_power_up(ap);
@@ -2620,7 +2700,6 @@ static int ahci_port_resume(struct ata_port *ap)
 	return 0;
 }
 
-#ifdef CONFIG_PM
 static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 {
 	const char *emsg = NULL;
@@ -2637,11 +2716,16 @@ static int ahci_port_suspend(struct ata_port *ap, pm_message_t mesg)
 	return rc;
 }
 
+#ifdef COFNIG_PCI
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
 	struct ata_host *host = dev_get_drvdata(&pdev->dev);
 	struct ahci_host_priv *hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+#else
+	void __iomem *mmio = host->iomap;
+#endif
 	u32 ctl;
 
 	if (mesg.event & PM_EVENT_SUSPEND &&
@@ -2686,7 +2770,8 @@ static int ahci_pci_device_resume(struct pci_dev *pdev)
 
 	return 0;
 }
-#endif
+#endif /* CONFIG_PCI */
+#endif /* CONFIG_PM */
 
 static int ahci_port_start(struct ata_port *ap)
 {
@@ -2774,6 +2859,7 @@ static void ahci_port_stop(struct ata_port *ap)
 		ata_port_printk(ap, KERN_WARNING, "%s (%d)\n", emsg, rc);
 }
 
+#ifdef CONFIG_PCI
 static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 {
 	int rc;
@@ -2805,15 +2891,21 @@ static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 	}
 	return 0;
 }
+#endif /* CONFIG_PCI */
 
 static void ahci_print_info(struct ata_host *host)
 {
 	struct ahci_host_priv *hpriv = host->private_data;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = to_pci_dev(host->dev);
 	void __iomem *mmio = host->iomap[AHCI_PCI_BAR];
+	u16 cc;
+#else
+	struct platform_device *pdev = to_platform_device(host->dev);
+	void __iomem *mmio = (void __iomem *)host->iomap;
+#endif
 	u32 vers, cap, cap2, impl, speed;
 	const char *speed_s;
-	u16 cc;
 	const char *scc_s;
 
 	vers = readl(mmio + HOST_VERSION);
@@ -2831,6 +2923,7 @@ static void ahci_print_info(struct ata_host *host)
 	else
 		speed_s = "?";
 
+#ifdef CONFIG_PCI
 	pci_read_config_word(pdev, 0x0a, &cc);
 	if (cc == PCI_CLASS_STORAGE_IDE)
 		scc_s = "IDE";
@@ -2840,6 +2933,10 @@ static void ahci_print_info(struct ata_host *host)
 		scc_s = "RAID";
 	else
 		scc_s = "unknown";
+#else
+	if (cpu_is_davinci_da850())
+		scc_s = "SATA";
+#endif
 
 	dev_printk(KERN_INFO, &pdev->dev,
 		"AHCI %02x%02x.%02x%02x "
@@ -2887,6 +2984,7 @@ static void ahci_print_info(struct ata_host *host)
 		);
 }
 
+#ifdef CONFIG_PCI
 /* On ASUS P5W DH Deluxe, the second port of PCI device 00:1f.2 is
  * hardwired to on-board SIMG 4726.  The chipset is ICH8 and doesn't
  * support PMP and the 4726 either directly exports the device
@@ -3224,17 +3322,27 @@ static void ahci_gtf_filter_workaround(struct ata_host *host)
 static inline void ahci_gtf_filter_workaround(struct ata_host *host)
 {}
 #endif
-
+#endif /* CONFIG_PCI */
+#ifdef CONFIG_PCI
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	static int printed_version;
 	unsigned int board_id = ent->driver_data;
 	struct ata_port_info pi = ahci_port_info[board_id];
+#else
+static int ahci_init_one(struct platform_device *pdev)
+{
+	unsigned int board_id = *(int *)pdev->dev.platform_data;
+	struct ata_port_info pi = ahci_port_info[board_id];
+	struct resource *res;
+#endif
+	static int printed_version;
 	const struct ata_port_info *ppi[] = { &pi, NULL };
 	struct device *dev = &pdev->dev;
 	struct ahci_host_priv *hpriv;
 	struct ata_host *host;
 	int n_ports, i, rc;
+	struct clk	*clock;
 
 	VPRINTK("ENTER\n");
 
@@ -3243,6 +3351,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (!printed_version++)
 		dev_printk(KERN_DEBUG, &pdev->dev, "version " DRV_VERSION "\n");
 
+#ifdef CONFIG_PCI
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
 	   can drive them all so if both drivers are selected make sure
 	   AHCI stays out of the way */
@@ -3286,12 +3395,14 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			return -ENODEV;
 		}
 	}
+#endif
 
 	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
 	if (!hpriv)
 		return -ENOMEM;
 	hpriv->flags |= (unsigned long)pi.private_data;
 
+#ifdef CONFIG_PCI
 	/* MCP65 revision A1 and A2 can't do MSI */
 	if (board_id == board_ahci_mcp65 &&
 	    (pdev->revision == 0xa1 || pdev->revision == 0xa2))
@@ -3307,6 +3418,41 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	if ((hpriv->flags & AHCI_HFLAG_NO_MSI) || pci_enable_msi(pdev))
 		pci_intx(pdev, 1);
+#else
+	/*
+	 * Get the register base first
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		rc = -EINVAL;
+		goto fail1;
+	}
+
+	hpriv->base = devm_ioremap(&pdev->dev, res->start,
+					res->end - res->start + 1);
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_printk(KERN_INFO, &pdev->dev, ": no irq\n");
+		rc = -ENODEV;
+		goto fail2;
+	}
+
+	hpriv->irq = res->start;
+	clock = clk_get(NULL, DRV_NAME);
+	if (IS_ERR(clock)) {
+		rc = PTR_ERR(clock);
+		goto fail2;
+	}
+
+	if (clk_enable(clock) < 0) {
+		rc = -ENODEV;
+		goto fail3;
+	}
+
+	/* Call platform specific init*/
+	ata_plat_init(hpriv->base);
+#endif
+
 
 	/* save initial config */
 	ahci_save_initial_config(pdev, hpriv);
@@ -3319,7 +3465,9 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		   to be broken at least on some NVIDIA MCP79 chipsets.
 		   Until we get info on which NVIDIA chipsets don't have this
 		   issue, if any, disable AA on all NVIDIA AHCIs. */
+#ifdef CONFIG_PCI
 		if (pdev->vendor != PCI_VENDOR_ID_NVIDIA)
+#endif
 			pi.flags |= ATA_FLAG_FPDMA_AA;
 	}
 
@@ -3328,7 +3476,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	if (ahci_em_messages && (hpriv->cap & HOST_CAP_EMS)) {
 		u8 messages;
+#ifdef CONFIG_PCI
 		void __iomem *mmio = pcim_iomap_table(pdev)[AHCI_PCI_BAR];
+#else
+		void __iomem *mmio = hpriv->base;
+#endif
 		u32 em_loc = readl(mmio + HOST_EM_LOC);
 		u32 em_ctl = readl(mmio + HOST_EM_CTL);
 
@@ -3344,6 +3496,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 	}
 
+#ifdef CONFIG_PCI
 	if (ahci_broken_system_poweroff(pdev)) {
 		pi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN;
 		dev_info(&pdev->dev,
@@ -3361,7 +3514,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		dev_info(&pdev->dev,
 			 "online status unreliable, applying workaround\n");
 	}
-
+#endif
 	/* CAP.NP sometimes indicate the index of the last enabled
 	 * port, at other times, that of the last possible port, so
 	 * determining the maximum port number requires looking at
@@ -3370,9 +3523,16 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	n_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));
 
 	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
-	if (!host)
-		return -ENOMEM;
+	if (!host) {
+		rc = -ENOMEM;
+		goto fail4;
+	}
+#ifdef CONFIG_PCI
 	host->iomap = pcim_iomap_table(pdev);
+#else
+	host->iomap = hpriv->base;
+	host->clock = clock;
+#endif
 	host->private_data = hpriv;
 
 	if (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)
@@ -3385,11 +3545,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	for (i = 0; i < host->n_ports; i++) {
 		struct ata_port *ap = host->ports[i];
-
+#ifdef CONFIG_PCI
 		ata_port_pbar_desc(ap, AHCI_PCI_BAR, -1, "abar");
 		ata_port_pbar_desc(ap, AHCI_PCI_BAR,
 				   0x100 + ap->port_no * 0x80, "port");
-
+#endif
 		/* set initial link pm policy */
 		ap->pm_policy = NOT_AVAILABLE;
 
@@ -3403,6 +3563,7 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			ap->ops = &ata_dummy_port_ops;
 	}
 
+#ifdef CONFIG_PCI
 	/* apply workaround for ASUS P5W DH Deluxe mainboard */
 	ahci_p5wdh_workaround(host);
 
@@ -3412,35 +3573,112 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	/* initialize adapter */
 	rc = ahci_configure_dma_masks(pdev, hpriv->cap & HOST_CAP_64);
 	if (rc)
-		return rc;
+		goto fail4;
+#endif
 
 	rc = ahci_reset_controller(host);
 	if (rc)
-		return rc;
+		goto fail4;
 
 	ahci_init_controller(host);
 	ahci_print_info(host);
 
+#ifdef CONFIG_PCI
 	pci_set_master(pdev);
 	return ata_host_activate(host, pdev->irq, ahci_interrupt, IRQF_SHARED,
 				 &ahci_sht);
+#else
+	return ata_host_activate(host, hpriv->irq, ahci_interrupt, IRQF_SHARED,
+				 &ahci_sht);
+#endif
+
+fail4:
+	if (clock)
+		clk_disable(clock);
+fail3:
+	if (clock)
+		clk_put(clock);
+fail2:
+	if (hpriv->base)
+		devm_iounmap(dev, hpriv->base);
+fail1:
+	if (hpriv)
+		devm_kfree(dev, hpriv);
+
+	return rc;
 }
 
+#ifdef CONFIG_PM
+extern void ahci_platform_suspend(struct platform_device *pdev);
+extern void ahci_platform_resume(struct platform_device *pdev);
+
+static int ahci_ctlr_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+	int rc = 0;
+
+	rc = ata_host_suspend(host, message);
+	if (rc)
+		return rc;
+
+	clk_disable(host->clock);
+	ahci_platform_suspend(pdev);
+
+	return 0;
+}
+
+static int ahci_ctlr_resume(struct platform_device *pdev)
+{
+	struct ata_host *host = dev_get_drvdata(&pdev->dev);
+
+	clk_enable(host->clock);
+	ahci_platform_resume(pdev);
+	ata_host_resume(host);
+
+	return 0;
+}
+#endif
+
+static struct platform_driver ahci_platform_driver = {
+	.probe			= ahci_init_one,
+#ifdef CONFIG_PM
+	.suspend		= ahci_ctlr_suspend,
+	.resume			= ahci_ctlr_resume,
+#endif
+	.driver			= {
+					.name = DRV_NAME,
+					.owner = THIS_MODULE,
+				},
+};
+
 static int __init ahci_init(void)
 {
+	int rc = -ENODEV;
+
+#ifdef CONFIG_PCI
 	return pci_register_driver(&ahci_pci_driver);
+#else
+	rc = platform_driver_register(&ahci_platform_driver);
+	return rc;
+#endif
 }
 
 static void __exit ahci_exit(void)
 {
+#ifdef CONFIG_PCI
 	pci_unregister_driver(&ahci_pci_driver);
+#else
+	platform_driver_unregister(&ahci_platform_driver);
+#endif
 }
 
 
 MODULE_AUTHOR("Jeff Garzik");
 MODULE_DESCRIPTION("AHCI SATA low-level driver");
 MODULE_LICENSE("GPL");
+#ifdef CONFIG_PCI
 MODULE_DEVICE_TABLE(pci, ahci_pci_tbl);
+#endif
 MODULE_VERSION(DRV_VERSION);
 
 module_init(ahci_init);
diff --git a/include/linux/libata.h b/include/linux/libata.h
index b2f2003..59af21e 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -535,6 +535,7 @@ struct ata_host {
 	acpi_handle		acpi_handle;
 #endif
 	struct ata_port		*simplex_claimed;	/* channel owning the DMA */
+	struct clk		*clock;
 	struct ata_port		*ports[0];
 };
 
@@ -1052,6 +1053,11 @@ extern void ata_timing_merge(const struct ata_timing *,
 			     unsigned int);
 extern u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle);
 
+#ifndef CONFIG_PCI
+void ata_plat_init(void __iomem *base);
+void ata_plat_remove(struct ata_host *host);
+#endif
+
 /* PCI */
 #ifdef CONFIG_PCI
 struct pci_dev;
-- 
1.6.5.2

