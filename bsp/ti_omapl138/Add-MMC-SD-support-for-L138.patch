From 1ec8b526f440231308834637b5d3b2fa5a3f3179 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 5 Nov 2009 17:53:24 +0800
Subject: [PATCH 16/43] Add MMC/SD support for L138

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.05.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add the initialization for the MMC/SD on L138.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/mach-davinci/board-da850-evm.c |   52 ++++++++++
 arch/arm/mach-davinci/devices.c         |  165 +++++++++++++++++++++++++++++++
 drivers/mmc/host/davinci_mmc.c          |    2 +-
 3 files changed, 218 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
index 12d226b..fecf578 100644
--- a/arch/arm/mach-davinci/board-da850-evm.c
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -41,6 +41,7 @@
 #include <mach/serial.h>
 #include <mach/mux.h>
 #include <mach/i2c.h>
+#include <linux/gpio.h>
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
 #include <linux/mtd/mtd.h>
@@ -48,6 +49,7 @@
 #include <linux/mtd/partitions.h>
 #include <mach/emac.h>
 #include <mach/nand.h>
+#include <mach/mmc.h>
 #include <mach/cp_intc.h>
 #include <mach/asp.h>
 
@@ -198,6 +200,49 @@ static int eth_addr_setup(char *str)
 /* Get MAC address from kernel boot parameter eth=AA:BB:CC:DD:EE:FF */
 __setup("eth=", eth_addr_setup);
 
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+static int da850_evm_mmc_get_ro(int index)
+{
+	/* GPIO 4[1] is used for MMC/SD WP - 16 * 4 + 1 = 65 */
+	int val, status, gpio_num = 65;
+
+	status = gpio_request(gpio_num, "MMC WP\n");
+	if (status < 0) {
+		printk(KERN_WARNING "%s can not open GPIO %d\n", __func__,
+				gpio_num);
+		return 0;
+	}
+	gpio_direction_input(gpio_num);
+	val = gpio_get_value(gpio_num);
+	gpio_free(gpio_num);
+	return val;
+}
+
+static int da850_evm_mmc_get_cd(int index)
+{
+	/* GPIO 4[0] is used for MMC/SD WP - 16 * 4 + 0 = 64 */
+	int val, status, gpio_num = 64;
+
+	status = gpio_request(gpio_num, "MMC CD\n");
+	if (status < 0) {
+		printk(KERN_WARNING "%s can not open GPIO %d\n", __func__,
+				gpio_num);
+		return 0;
+	}
+	gpio_direction_input(gpio_num);
+	val = gpio_get_value(gpio_num);
+	gpio_free(gpio_num);
+	return !val;
+}
+
+static struct davinci_mmc_config da850_mmc_config = {
+	.get_ro         = da850_evm_mmc_get_ro,
+	.get_cd		= da850_evm_mmc_get_cd,
+	.wires          = 4,
+	.version	= MMC_CTLR_VERSION_2,
+};
+#endif
+
 static struct i2c_board_info __initdata i2c_info[] =  {
 	{
 		I2C_BOARD_INFO("pcf8575", 0x20),
@@ -302,6 +347,13 @@ static __init void da850_evm_init(void)
 
 	da850_evm_init_i2c();
 
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+	/* Mux the GPIO required for WP feature */
+	davinci_cfg_reg(DA850_GPIO4_0);
+	davinci_cfg_reg(DA850_GPIO4_1);
+	davinci_setup_mmc(0, &da850_mmc_config);
+#endif
+
 	da850_init_spi1(NULL, 1, da850_spi_board_info0,
 			ARRAY_SIZE(da850_spi_board_info0));
 
diff --git a/arch/arm/mach-davinci/devices.c b/arch/arm/mach-davinci/devices.c
index 72fd97e..d0906e3 100644
--- a/arch/arm/mach-davinci/devices.c
+++ b/arch/arm/mach-davinci/devices.c
@@ -23,15 +23,21 @@
 
 #include <mach/hardware.h>
 #include <mach/da8xx.h>
+#include <mach/edma.h>
 #include <mach/i2c.h>
 #include <mach/cpu.h>
 #include <mach/mux.h>
+#include <mach/mmc.h>
 #include <mach/da8xx.h>
 
 #include "clock.h"
 
 
 #define DAVINCI_I2C_BASE		0x01C21000
+#define DAVINCI_MMCSD0_BASE		0x01E10000
+#define DM355_MMCSD0_BASE		0x01E11000
+#define DM355_MMCSD1_BASE		0x01E00000
+#define DA830_MMC_SD0_BASE		0x01C40000
 #define DA830_RTC_BASE			0x01C23000
 
 static struct resource i2c_resources[] = {
@@ -121,6 +127,165 @@ void __init davinci_init_i2c(struct davinci_i2c_platform_data *pdata)
 	}
 }
 
+#if	defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+
+static u64 mmcsd0_dma_mask = DMA_32BIT_MASK;
+
+static struct resource mmcsd0_resources[] = {
+	{
+		/* different on dm355 */
+		.start = DAVINCI_MMCSD0_BASE,
+		.end   = DAVINCI_MMCSD0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	/* IRQs:  MMC/SD, then SDIO */
+	{
+		.start = IRQ_MMCINT,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		/* different on dm355 */
+		.start = IRQ_SDIOINT,
+		.flags = IORESOURCE_IRQ,
+	},
+	/* DMA channels: RX, then TX */
+	{
+		.start = EDMA_CTLR_CHAN(0, DAVINCI_DMA_MMCRXEVT),
+		.flags = IORESOURCE_DMA,
+	}, {
+		.start = EDMA_CTLR_CHAN(0, DAVINCI_DMA_MMCTXEVT),
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device davinci_mmcsd0_device = {
+	.name = "davinci_mmc",
+	.id = 0,
+	.dev = {
+		.dma_mask = &mmcsd0_dma_mask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+	},
+	.num_resources = ARRAY_SIZE(mmcsd0_resources),
+	.resource = mmcsd0_resources,
+};
+
+static struct resource da830_mmc_resources[] = {
+	{		 /* registers */
+		.start	= DA830_MMC_SD0_BASE,
+		.end	= DA830_MMC_SD0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{		 /* interrupt */
+		.start	= IRQ_DA8XX_MMCSDINT0,
+		.end	= IRQ_DA8XX_MMCSDINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{		 /* DMA RX */
+		.start	= EDMA_CTLR_CHAN(0, 16),
+		.end	= EDMA_CTLR_CHAN(0, 16),
+		.flags	= IORESOURCE_DMA,
+	},
+	{		 /* DMA TX */
+		.start	= EDMA_CTLR_CHAN(0, 17),
+		.end	= EDMA_CTLR_CHAN(0, 17),
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device da830_mmc_device = {
+	.name		= "davinci_mmc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(da830_mmc_resources),
+	.resource	= da830_mmc_resources,
+};
+
+static struct resource da850_mmc_resources[] = {
+	{		 /* registers */
+		.start	= 0x01c40000,
+		.end	= 0x01c40000 + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{		 /* interrupt */
+		.start	= 16,
+		.end	= 16,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{		 /* DMA RX */
+		.start	= EDMA_CTLR_CHAN(0, 16),
+		.end	= EDMA_CTLR_CHAN(0, 16),
+		.flags	= IORESOURCE_DMA,
+	},
+	{		 /* DMA TX */
+		.start	= EDMA_CTLR_CHAN(0, 17),
+		.end	= EDMA_CTLR_CHAN(0, 17),
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device da850_mmc_device = {
+	.name		= "davinci_mmc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(da850_mmc_resources),
+	.resource	= da850_mmc_resources,
+};
+
+void __init davinci_setup_mmc(int module, struct davinci_mmc_config *config)
+{
+	struct platform_device	*pdev = NULL;
+
+	if (WARN_ON(cpu_is_davinci_dm646x()))
+		return;
+
+	/* REVISIT: update PINMUX, ARM_IRQMUX, and EDMA_EVTMUX here too;
+	 * for example if MMCSD1 is used for SDIO, maybe DAT2 is unused.
+	 *
+	 * FIXME dm6441 (no MMC/SD), dm357 (one), and dm335 (two) are
+	 * not handled right here ...
+	 */
+	switch (module) {
+	case 1:
+		break;
+	case 0:
+		if (cpu_is_da830()) {
+			pdev = &da830_mmc_device;
+			davinci_cfg_reg(DA830_MMCSD_DAT_0);
+			davinci_cfg_reg(DA830_MMCSD_DAT_1);
+			davinci_cfg_reg(DA830_MMCSD_DAT_2);
+			davinci_cfg_reg(DA830_MMCSD_DAT_3);
+			davinci_cfg_reg(DA830_MMCSD_DAT_4);
+			davinci_cfg_reg(DA830_MMCSD_DAT_5);
+			davinci_cfg_reg(DA830_MMCSD_DAT_6);
+			davinci_cfg_reg(DA830_MMCSD_DAT_7);
+			davinci_cfg_reg(DA830_MMCSD_CLK);
+			davinci_cfg_reg(DA830_MMCSD_CMD);
+		} else if (cpu_is_da850()) {
+			pdev = &da850_mmc_device;
+			davinci_cfg_reg(DA850_MMCSD0_DAT_0);
+			davinci_cfg_reg(DA850_MMCSD0_DAT_1);
+			davinci_cfg_reg(DA850_MMCSD0_DAT_2);
+			davinci_cfg_reg(DA850_MMCSD0_DAT_3);
+			davinci_cfg_reg(DA850_MMCSD0_CLK);
+			davinci_cfg_reg(DA850_MMCSD0_CMD);
+		} else
+			pdev = &davinci_mmcsd0_device;
+
+		break;
+	}
+
+	if (WARN_ON(!pdev))
+		return;
+
+	pdev->dev.platform_data = config;
+	platform_device_register(pdev);
+}
+
+#else
+
+void __init davinci_setup_mmc(int module, struct davinci_mmc_config *config)
+{
+}
+
+#endif
+
 static struct resource da8xx_rtc_resources[] = {
 	[0] = {		/* registers */
 		.start  = DA830_RTC_BASE,
diff --git a/drivers/mmc/host/davinci_mmc.c b/drivers/mmc/host/davinci_mmc.c
index 0d4d7e1..f321295 100644
--- a/drivers/mmc/host/davinci_mmc.c
+++ b/drivers/mmc/host/davinci_mmc.c
@@ -1113,7 +1113,7 @@ static int __init davinci_mmcsd_probe(struct platform_device *pdev)
 		goto out;
 
 	ret = -ENXIO;
-	host->clk = clk_get(&pdev->dev, "MMCSDCLK");
+	host->clk = clk_get(&pdev->dev, "mmcsd");
 	if (IS_ERR(host->clk)) {
 		ret = PTR_ERR(host->clk);
 		goto out;
-- 
1.6.5.2

