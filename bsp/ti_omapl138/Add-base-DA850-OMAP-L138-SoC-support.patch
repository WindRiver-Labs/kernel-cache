From 493f5ef63063ec339a1c4b51d4dd956bbb3b2a7b Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 5 Nov 2009 17:53:04 +0800
Subject: [PATCH 02/43] Add base DA850/OMAP-L138 SoC support

Original codes from TI Linux Platform Support Package
DaVinci-PSP-SDK-03.20.00.05.tgz http://software-dl.ti.com/dsps/
dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

The da850/omap l138 is a new SoC from TI that is similar
to the davinci line.  Since its so similar to davinci,
put the support for the da830 in the same directory as
the davinci code.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 arch/arm/Kconfig                                 |    2 +
 arch/arm/mach-davinci/Kconfig                    |   58 ++++-
 arch/arm/mach-davinci/Makefile                   |   15 +-
 arch/arm/mach-davinci/Makefile.boot              |    8 +
 arch/arm/mach-davinci/board-da850-evm.c          |   61 ++++
 arch/arm/mach-davinci/clock.c                    |  283 +++++++++++------
 arch/arm/mach-davinci/clock.h                    |   74 ++++-
 arch/arm/mach-davinci/cp_intc.c                  |  161 ++++++++++
 arch/arm/mach-davinci/da850.c                    |  372 ++++++++++++++++++++++
 arch/arm/mach-davinci/id.c                       |   59 +++-
 arch/arm/mach-davinci/include/mach/clock.h       |    1 -
 arch/arm/mach-davinci/include/mach/common.h      |    3 +
 arch/arm/mach-davinci/include/mach/cp_intc.h     |   57 ++++
 arch/arm/mach-davinci/include/mach/cpu.h         |   68 ++++
 arch/arm/mach-davinci/include/mach/da8xx.h       |   84 +++++
 arch/arm/mach-davinci/include/mach/debug-macro.S |   36 ++-
 arch/arm/mach-davinci/include/mach/dma.h         |    2 +-
 arch/arm/mach-davinci/include/mach/entry-macro.S |   18 +-
 arch/arm/mach-davinci/include/mach/hardware.h    |   51 +---
 arch/arm/mach-davinci/include/mach/io.h          |   64 ++---
 arch/arm/mach-davinci/include/mach/irqs.h        |  265 +++++++++++++++-
 arch/arm/mach-davinci/include/mach/memory.h      |    6 +
 arch/arm/mach-davinci/include/mach/psc.h         |  103 ++++++-
 arch/arm/mach-davinci/include/mach/serial.h      |   18 +-
 arch/arm/mach-davinci/include/mach/system.h      |    1 -
 arch/arm/mach-davinci/include/mach/uncompress.h  |   24 ++-
 arch/arm/mach-davinci/io.c                       |   46 +++-
 arch/arm/mach-davinci/psc.c                      |  137 ++++-----
 arch/arm/mach-davinci/time.c                     |  321 +++++++++++++++-----
 29 files changed, 2029 insertions(+), 369 deletions(-)
 create mode 100644 arch/arm/mach-davinci/board-da850-evm.c
 create mode 100644 arch/arm/mach-davinci/cp_intc.c
 create mode 100644 arch/arm/mach-davinci/da850.c
 create mode 100644 arch/arm/mach-davinci/include/mach/cp_intc.h
 create mode 100644 arch/arm/mach-davinci/include/mach/cpu.h
 create mode 100644 arch/arm/mach-davinci/include/mach/da8xx.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 93602d9..b65bf91 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -517,6 +517,8 @@ config ARCH_DAVINCI
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_GPIO
 	select HAVE_CLK
+	select ZONE_DMA
+	select HAVE_IDE
 	help
 	  Support for TI's DaVinci platform.
 
diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index bac988e..efccceb 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -1,23 +1,75 @@
 if ARCH_DAVINCI
 
+config CP_INTC
+	bool
+
 menu "TI DaVinci Implementations"
 
 comment "DaVinci Core Type"
 
-config ARCH_DAVINCI644x
-	default y
+config ARCH_DAVINCI_DM644x
 	bool "DaVinci 644x based system"
+	select CPU_V5
+	select DAVINCI_SOC_USING_AINTC
+
+
+config ARCH_DA830
+	bool "DA830/OMAP-L137 based system"
+	select CPU_V5
+	select CP_INTC
+	select ARCH_DA8XX
+
+config ARCH_DA850
+	bool "DA850/OMAP-L138 based system"
+	select CPU_V5
+	select CP_INTC
+	select ARCH_DA8XX
+
+config DAVINCI_SOC_USING_AINTC
+	bool
+
+config ARCH_DA8XX
+	bool
 
 comment "DaVinci Board Type"
 
 config MACH_DAVINCI_EVM
 	bool "TI DaVinci EVM"
 	default y
-	depends on ARCH_DAVINCI644x
+	depends on ARCH_DAVINCI_DM644x
 	help
 	  Configure this option to specify the whether the board used
 	  for development is a DaVinci EVM
 
+
+config MACH_DA830_EVM
+	bool "TI DA830/OMAP-L137 EVM"
+	default n
+	depends on ARCH_DA830
+	help
+	  Configure this option to specify the whether the board used
+	  for development is a DA830/OMAP-L137 EVM
+
+config MACH_DA850_EVM
+	bool "TI DA850/OMAP-L138 EVM"
+	default n
+	depends on ARCH_DA850
+	help
+	  Configure this option to specify the whether the board used
+	  for development is a DA850/OMAP-L138 EVM
+
+config DAVINCI_RESET_CLOCKS
+	bool "Reset unused clocks during boot"
+	depends on ARCH_DAVINCI
+	help
+	  Say Y if you want to reset unused clocks during boot.
+	  This option saves power, but assumes all drivers are
+	  using the clock framework. Broken drivers that do not
+	  yet use clock framework may not work with this option.
+	  If you are booting from another operating system, you
+	  probably do not want this option enabled until your
+	  device drivers work properly.
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 99ac2e5..f3f9c71 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -4,8 +4,17 @@
 #
 
 # Common objects
-obj-y 			:= time.o irq.o clock.o serial.o io.o id.o psc.o \
-			   gpio.o mux.o
+obj-y 			:= time.o clock.o io.o id.o psc.o
+
+
+obj-$(CONFIG_ARCH_DA830)		+= da830.o
+obj-$(CONFIG_ARCH_DA850)		+= da850.o
+
+obj-$(CONFIG_DAVINCI_SOC_USING_AINTC)	+= irq.o
+obj-$(CONFIG_CP_INTC)			+= cp_intc.o
+
 
 # Board specific
-obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o
+obj-$(CONFIG_MACH_DAVINCI_EVM)        += board-evm.o
+obj-$(CONFIG_MACH_DA830_EVM)		+= board-da830-evm.o
+obj-$(CONFIG_MACH_DA850_EVM)		+= board-da850-evm.o
diff --git a/arch/arm/mach-davinci/Makefile.boot b/arch/arm/mach-davinci/Makefile.boot
index e1dd366..c53b74f 100644
--- a/arch/arm/mach-davinci/Makefile.boot
+++ b/arch/arm/mach-davinci/Makefile.boot
@@ -1,3 +1,11 @@
+ifdef CONFIG_ARCH_DAVINCI
    zreladdr-y	:= 0x80008000
 params_phys-y	:= 0x80000100
 initrd_phys-y	:= 0x80800000
+endif
+
+ifdef CONFIG_ARCH_DA8XX
+   zreladdr-y	:= 0xC0008000
+params_phys-y	:= 0xC0000100
+initrd_phys-y	:= 0xC0800000
+endif
diff --git a/arch/arm/mach-davinci/board-da850-evm.c b/arch/arm/mach-davinci/board-da850-evm.c
new file mode 100644
index 0000000..4e79bb0
--- /dev/null
+++ b/arch/arm/mach-davinci/board-da850-evm.c
@@ -0,0 +1,61 @@
+/*
+ * TI DaVinci DA850 EVM board
+ *
+ * Derived from: arch/arm/mach-davinci/board-evm.c
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * (C) 2007-2008, MontaVista Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/major.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/console.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/irqs.h>
+#include <mach/common.h>
+#include <mach/cpu.h>
+#include <mach/clock.h>
+#include <mach/psc.h>
+#include <mach/da8xx.h>
+#include <linux/platform_device.h>
+#include <mach/cp_intc.h>
+
+#include "clock.h"
+
+static void __init da850_map_io(void)
+{
+	davinci_map_common_io();
+	da850_init();
+}
+
+static __init void da850_evm_irq_init(void)
+{
+	cp_intc_init((void __iomem *)IO_Dx_INTC_VIRT,
+			IRQ_DA850_MCBSP1XINT + 1, NULL);
+}
+
+MACHINE_START(DAVINCI_DA850_EVM, "DaVinci DA850 EVM")
+	.phys_io	= IO_PHYS,
+	.io_pg_offst	= (__IO_ADDRESS(IO_PHYS) >> 18) & 0xfffc,
+	.boot_params	= (0xC0000100),
+	.map_io		= da850_map_io,
+	.init_irq	= da850_evm_irq_init,
+	.timer		= &davinci_timer,
+MACHINE_END
diff --git a/arch/arm/mach-davinci/clock.c b/arch/arm/mach-davinci/clock.c
index d46c69b..3d95517 100644
--- a/arch/arm/mach-davinci/clock.c
+++ b/arch/arm/mach-davinci/clock.c
@@ -13,29 +13,22 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/errno.h>
+#include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
+#include <linux/io.h>
 
-#include <mach/hardware.h>
-#include <asm/io.h>
+#include <mach/da8xx.h>
 
 #include <mach/psc.h>
+#include <mach/cpu.h>
 #include "clock.h"
 
-/* PLL/Reset register offsets */
-#define PLLM		0x110
-
 static LIST_HEAD(clocks);
 static DEFINE_MUTEX(clocks_mutex);
 static DEFINE_SPINLOCK(clockfw_lock);
 
-static unsigned int commonrate;
-static unsigned int armrate;
-static unsigned int fixedrate = 27000000;	/* 27 MHZ */
-
-extern void davinci_psc_config(unsigned int domain, unsigned int id, char enable);
-
 /*
  * Returns a clock. Note that we first try to use device id on the bus
  * and clock name. If this fails, we try to use clock name only.
@@ -81,38 +74,43 @@ void clk_put(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_put);
 
-static int __clk_enable(struct clk *clk)
+static unsigned psc_domain(struct clk *clk)
 {
-	if (clk->flags & ALWAYS_ENABLED)
-		return 0;
+	return (clk->flags & PSC_DSP)
+		? DAVINCI_GPSC_DSPDOMAIN
+		: DAVINCI_GPSC_ARMDOMAIN;
+}
 
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, clk->lpsc, 1);
-	return 0;
+static void __clk_enable(struct clk *clk)
+{
+	if (clk->parent)
+		__clk_enable(clk->parent);
+	if (clk->usecount++ == 0 && (clk->flags & CLK_PSC))
+		davinci_psc_config(psc_domain(clk), clk->lpsc, 1);
 }
 
 static void __clk_disable(struct clk *clk)
 {
-	if (clk->usecount)
+	if (WARN_ON(clk->usecount == 0))
 		return;
-
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, clk->lpsc, 0);
+	if (--clk->usecount == 0 && (clk->flags & CLK_PSC))
+		davinci_psc_config(psc_domain(clk), clk->lpsc, 0);
+	if (clk->parent)
+		__clk_disable(clk->parent);
 }
 
 int clk_enable(struct clk *clk)
 {
 	unsigned long flags;
-	int ret = 0;
 
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
-	if (clk->usecount++ == 0) {
-		spin_lock_irqsave(&clockfw_lock, flags);
-		ret = __clk_enable(clk);
-		spin_unlock_irqrestore(&clockfw_lock, flags);
-	}
+	spin_lock_irqsave(&clockfw_lock, flags);
+	__clk_enable(clk);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
 
-	return ret;
+	return 0;
 }
 EXPORT_SYMBOL(clk_enable);
 
@@ -123,11 +121,9 @@ void clk_disable(struct clk *clk)
 	if (clk == NULL || IS_ERR(clk))
 		return;
 
-	if (clk->usecount > 0 && !(--clk->usecount)) {
-		spin_lock_irqsave(&clockfw_lock, flags);
-		__clk_disable(clk);
-		spin_unlock_irqrestore(&clockfw_lock, flags);
-	}
+	spin_lock_irqsave(&clockfw_lock, flags);
+	__clk_disable(clk);
+	spin_unlock_irqrestore(&clockfw_lock, flags);
 }
 EXPORT_SYMBOL(clk_disable);
 
@@ -136,7 +132,7 @@ unsigned long clk_get_rate(struct clk *clk)
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
-	return *(clk->rate);
+	return clk->rate;
 }
 EXPORT_SYMBOL(clk_get_rate);
 
@@ -145,7 +141,7 @@ long clk_round_rate(struct clk *clk, unsigned long rate)
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
-	return *(clk->rate);
+	return clk->rate;
 }
 EXPORT_SYMBOL(clk_round_rate);
 
@@ -164,10 +160,27 @@ int clk_register(struct clk *clk)
 	if (clk == NULL || IS_ERR(clk))
 		return -EINVAL;
 
+	if (cpu_is_da850() && clk->dup_parent)
+		if (get_async3_src())
+			clk->parent = clk->dup_parent;
+
+	if (WARN(clk->parent && !clk->parent->rate,
+			"CLK: %s parent %s has no rate!\n",
+			clk->name, clk->parent->name))
+		return -EINVAL;
+
 	mutex_lock(&clocks_mutex);
-	list_add(&clk->node, &clocks);
+	list_add_tail(&clk->node, &clocks);
 	mutex_unlock(&clocks_mutex);
 
+	/* If rate is already set, use it */
+	if (clk->rate)
+		return 0;
+
+	/* Otherwise, default to parent rate */
+	if (clk->parent)
+		clk->rate = clk->parent->rate;
+
 	return 0;
 }
 EXPORT_SYMBOL(clk_register);
@@ -183,79 +196,147 @@ void clk_unregister(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_unregister);
 
-static struct clk davinci_clks[] = {
-	{
-		.name = "ARMCLK",
-		.rate = &armrate,
-		.lpsc = -1,
-		.flags = ALWAYS_ENABLED,
-	},
-	{
-		.name = "UART",
-		.rate = &fixedrate,
-		.lpsc = DAVINCI_LPSC_UART0,
-	},
-	{
-		.name = "EMACCLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_EMAC_WRAPPER,
-	},
-	{
-		.name = "I2CCLK",
-		.rate = &fixedrate,
-		.lpsc = DAVINCI_LPSC_I2C,
-	},
-	{
-		.name = "IDECLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_ATA,
-	},
-	{
-		.name = "McBSPCLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_McBSP,
-	},
-	{
-		.name = "MMCSDCLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_MMC_SD,
-	},
-	{
-		.name = "SPICLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_SPI,
-	},
-	{
-		.name = "gpio",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_GPIO,
-	},
-	{
-		.name = "AEMIFCLK",
-		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_AEMIF,
-		.usecount = 1,
+#ifdef CONFIG_DAVINCI_RESET_CLOCKS
+/*
+ * Disable any unused clocks left on by the bootloader
+ */
+static int __init clk_disable_unused(void)
+{
+	struct clk *ck;
+
+	spin_lock_irq(&clockfw_lock);
+	list_for_each_entry(ck, &clocks, node) {
+		if (ck->usecount > 0)
+			continue;
+		if (!(ck->flags & CLK_PSC))
+			continue;
+
+		/* ignore if in Disabled or SwRstDisable states */
+		if (!davinci_psc_is_clk_active(ck->lpsc))
+			continue;
+
+		pr_info("Clocks: disable unused %s\n", ck->name);
+		davinci_psc_config(psc_domain(ck), ck->lpsc, 0);
 	}
-};
+	spin_unlock_irq(&clockfw_lock);
+
+	return 0;
+}
+late_initcall(clk_disable_unused);
+#endif
 
-int __init davinci_clk_init(void)
+static void clk_sysclk_recalc(struct clk *clk)
 {
-	struct clk *clkp;
+	u32 v, plldiv;
+	struct pll_data *pll;
+
+	/* If this is the PLL base clock, no more calculations needed */
+	if (clk->pll_data)
+		return;
+
+	if (WARN_ON(!clk->parent))
+		return;
+
+	clk->rate = clk->parent->rate;
+
+	/* Otherwise, the parent must be a PLL */
+	if (WARN_ON(!clk->parent->pll_data))
+		return;
+
+	pll = clk->parent->pll_data;
+
+	/* If pre-PLL, source clock is before the multiplier and divider(s) */
+	if (clk->flags & PRE_PLL)
+		clk->rate = pll->input_rate;
+
+	if (!clk->div_reg)
+		return;
+
+	v = __raw_readl(pll->base + clk->div_reg);
+	if (v & PLLDIV_EN) {
+		plldiv = (v & PLLDIV_RATIO_MASK) + 1;
+		if (plldiv)
+			clk->rate /= plldiv;
+	}
+}
+
+static void __init clk_pll_init(struct clk *clk)
+{
+	u32 ctrl, mult = 1, prediv = 1, postdiv = 1;
+	u8 bypass;
+	struct pll_data *pll = clk->pll_data;
+
+	pll->base = IO_ADDRESS(pll->phys_base);
+	ctrl = __raw_readl(pll->base + PLLCTL);
+	clk->rate = pll->input_rate = clk->parent->rate;
+
+	if (ctrl & PLLCTL_PLLEN) {
+		bypass = 0;
+		mult = __raw_readl(pll->base + PLLM);
+		mult = (mult & PLLM_PLLM_MASK) + 1;
+	} else
+		bypass = 1;
+
+	if (pll->flags & PLL_HAS_PREDIV) {
+		prediv = __raw_readl(pll->base + PREDIV);
+		if (prediv & PLLDIV_EN)
+			prediv = (prediv & PLLDIV_RATIO_MASK) + 1;
+		else
+			prediv = 1;
+	}
+
+	/* pre-divider is fixed, but (some?) chips won't report that */
+	if (cpu_is_davinci_dm355() && pll->num == 1)
+		prediv = 8;
+
+	if (pll->flags & PLL_HAS_POSTDIV) {
+		postdiv = __raw_readl(pll->base + POSTDIV);
+		if (postdiv & PLLDIV_EN)
+			postdiv = (postdiv & PLLDIV_RATIO_MASK) + 1;
+		else
+			postdiv = 1;
+	}
+
+	if (!bypass) {
+		clk->rate /= prediv;
+		clk->rate *= mult;
+		clk->rate /= postdiv;
+	}
+
+	pr_debug("PLL%d: input = %lu MHz [ ",
+		 pll->num, clk->parent->rate / 1000000);
+	if (bypass)
+		pr_debug("bypass ");
+	if (prediv > 1)
+		pr_debug("/ %d ", prediv);
+	if (mult > 1)
+		pr_debug("* %d ", mult);
+	if (postdiv > 1)
+		pr_debug("/ %d ", postdiv);
+	pr_debug("] --> %lu MHz output.\n", clk->rate / 1000000);
+}
+
+int __init davinci_clk_init(struct clk **davinci_clks, int num_clks)
+  {
+	struct clk **clkp;
 	int count = 0;
-	u32 pll_mult;
 
-	pll_mult = davinci_readl(DAVINCI_PLL_CNTRL0_BASE + PLLM);
-	commonrate = ((pll_mult + 1) * 27000000) / 6;
-	armrate = ((pll_mult + 1) * 27000000) / 2;
+	for (clkp = davinci_clks; count < num_clks; count++, clkp++) {
+		if ((*clkp)->pll_data)
+			clk_pll_init(*clkp);
+
+		/* Calculate rates for PLL-derived clocks */
+		else if ((*clkp)->flags & CLK_PLL)
+			clk_sysclk_recalc(*clkp);
+
+		if ((*clkp)->lpsc)
+			(*clkp)->flags |= CLK_PSC;
 
-	for (clkp = davinci_clks; count < ARRAY_SIZE(davinci_clks);
-	     count++, clkp++) {
-		clk_register(clkp);
+		clk_register(*clkp);
 
-		/* Turn on clocks that have been enabled in the
-		 * table above */
-		if (clkp->usecount)
-			clk_enable(clkp);
+		/* Turn on clocks that Linux doesn't otherwise manage */
+		if ((*clkp)->flags & ALWAYS_ENABLED)
+			clk_enable(*clkp);
 	}
 
 	return 0;
@@ -285,7 +366,7 @@ static int davinci_ck_show(struct seq_file *m, void *v)
 	struct clk *cp;
 
 	list_for_each_entry(cp, &clocks, node)
-		seq_printf(m,"%s %d %d\n", cp->name, *(cp->rate), cp->usecount);
+		seq_printf(m, "%s %ld %d\n", cp->name, cp->rate, cp->usecount);
 
 	return 0;
 }
diff --git a/arch/arm/mach-davinci/clock.h b/arch/arm/mach-davinci/clock.h
index ed47079..64e4a41 100644
--- a/arch/arm/mach-davinci/clock.h
+++ b/arch/arm/mach-davinci/clock.h
@@ -1,7 +1,7 @@
 /*
  * TI DaVinci clock definitions
  *
- * Copyright (C) 2006 Texas Instruments.
+ *  Copyright (C) 2006 Texas Instruments.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -11,23 +11,75 @@
 #ifndef __ARCH_ARM_DAVINCI_CLOCK_H
 #define __ARCH_ARM_DAVINCI_CLOCK_H
 
+#include <linux/list.h>
+
+#define DAVINCI_PLL1_BASE 0x01c40800
+#define DAVINCI_PLL2_BASE 0x01c40c00
+#define DA8XX_PLL_CNTRL0_BASE 0x01C11000
+#define DA8XX_PLL_CNTRL1_BASE 0x01E1A000
+#define MAX_PLL 2
+
+/* PLL/Reset register offsets */
+#define PLLCTL          0x100
+#define PLLCTL_PLLEN    BIT(0)
+#define PLLCTL_CLKMODE  BIT(8)
+
+#define PLLM		0x110
+#define PLLM_PLLM_MASK  0xff
+
+#define PREDIV          0x114
+#define PLLDIV1         0x118
+#define PLLDIV2         0x11c
+#define PLLDIV3         0x120
+#define POSTDIV         0x128
+#define BPDIV           0x12c
+#define PLLCMD		0x138
+#define PLLSTAT		0x13c
+#define PLLALNCTL	0x140
+#define PLLDCHANGE	0x144
+#define PLLCKEN		0x148
+#define PLLCKSTAT	0x14c
+#define PLLSYSTAT	0x150
+#define PLLDIV4         0x160
+#define PLLDIV5         0x164
+#define PLLDIV6         0x168
+#define PLLDIV7         0x16c
+#define PLLDIV8         0x170
+#define PLLDIV9         0x174
+#define PLLDIV_EN       BIT(15)
+#define PLLDIV_RATIO_MASK 0x1f
+
+struct pll_data {
+	u32 phys_base;
+	void __iomem *base;
+	u32 num;
+	u32 flags;
+	u32 input_rate;
+};
+#define PLL_HAS_PREDIV          0x01
+#define PLL_HAS_POSTDIV         0x02
+
 struct clk {
 	struct list_head	node;
 	struct module		*owner;
 	const char		*name;
-	unsigned int		*rate;
+	unsigned long		rate;
 	int			id;
-	__s8			usecount;
-	__u8			flags;
-	__u8			lpsc;
+	u8			usecount;
+	u8			flags;
+	u8			lpsc;
+	struct clk              *parent;
+	struct pll_data         *pll_data;
+	u32                     div_reg;
+	struct clk		*dup_parent;
 };
 
 /* Clock flags */
-#define RATE_CKCTL		1
-#define RATE_FIXED		2
-#define RATE_PROPAGATES		4
-#define VIRTUAL_CLOCK		8
-#define ALWAYS_ENABLED		16
-#define ENABLE_REG_32BIT	32
+#define ALWAYS_ENABLED		BIT(1)
+#define CLK_PSC                 BIT(2)
+#define PSC_DSP                 BIT(3) /* PSC uses DSP domain, not ARM */
+#define CLK_PLL			BIT(4) /* PLL-derived clock */
+#define PRE_PLL                 BIT(5) /* source is before PLL mult/div */
 
+int davinci_clk_init(struct clk **davinci_clks, int num_clks);
 #endif
diff --git a/arch/arm/mach-davinci/cp_intc.c b/arch/arm/mach-davinci/cp_intc.c
new file mode 100644
index 0000000..96c8e97
--- /dev/null
+++ b/arch/arm/mach-davinci/cp_intc.c
@@ -0,0 +1,161 @@
+/*
+ * TI Common Platform Interrupt Controller (cp_intc) driver
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ * Copyright (C) 2008-2009, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <mach/cp_intc.h>
+
+static void __iomem *cp_intc_base;
+
+static inline unsigned int cp_intc_read(unsigned offset)
+{
+	return __raw_readl(cp_intc_base + offset);
+}
+
+static inline void cp_intc_write(unsigned long value, unsigned offset)
+{
+	__raw_writel(value, cp_intc_base + offset);
+}
+
+static void cp_intc_ack_irq(unsigned int irq)
+{
+	cp_intc_write(irq, CP_INTC_SYS_STAT_IDX_CLR);
+}
+
+/* Disable interrupt */
+static void cp_intc_mask_irq(unsigned int irq)
+{
+	/* XXX don't know why we need to disable nIRQ here... */
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_CLR);
+	cp_intc_write(irq, CP_INTC_SYS_ENABLE_IDX_CLR);
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_SET);
+}
+
+/* Enable interrupt */
+static void cp_intc_unmask_irq(unsigned int irq)
+{
+	cp_intc_write(irq, CP_INTC_SYS_ENABLE_IDX_SET);
+}
+
+static int cp_intc_set_irq_type(unsigned int irq, unsigned int flow_type)
+{
+	unsigned reg		= BIT_WORD(irq);
+	unsigned mask		= BIT_MASK(irq);
+	unsigned polarity	= cp_intc_read(CP_INTC_SYS_POLARITY(reg));
+	unsigned type		= cp_intc_read(CP_INTC_SYS_TYPE(reg));
+
+	switch (flow_type) {
+	case IRQ_TYPE_EDGE_RISING:
+		polarity |= mask;
+		type |= mask;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		polarity &= ~mask;
+		type |= mask;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		polarity |= mask;
+		type &= ~mask;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		polarity &= ~mask;
+		type &= ~mask;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cp_intc_write(polarity, CP_INTC_SYS_POLARITY(reg));
+	cp_intc_write(type, CP_INTC_SYS_TYPE(reg));
+
+	return 0;
+}
+
+static struct irq_chip cp_intc_irq_chip = {
+	.name		= "cp_intc",
+	.ack		= cp_intc_ack_irq,
+	.mask		= cp_intc_mask_irq,
+	.unmask		= cp_intc_unmask_irq,
+	.set_type	= cp_intc_set_irq_type,
+};
+
+void __init cp_intc_init(void __iomem *base, unsigned short num_irq,
+			 u8 *irq_prio)
+{
+	unsigned num_reg	= BITS_TO_LONGS(num_irq);
+	int i;
+
+	cp_intc_base = base;
+
+	cp_intc_write(0, CP_INTC_GLOBAL_ENABLE);
+
+	/* Disable all host interrupts */
+	cp_intc_write(0, CP_INTC_HOST_ENABLE(0));
+
+	/* Disable system interrupts */
+	for (i = 0; i < num_reg; i++)
+		cp_intc_write(~0, CP_INTC_SYS_ENABLE_CLR(i));
+
+	/* Set to normal mode, no nesting, no priority hold */
+	cp_intc_write(0, CP_INTC_CTRL);
+	cp_intc_write(0, CP_INTC_HOST_CTRL);
+
+	/* Clear system interrupt status */
+	for (i = 0; i < num_reg; i++)
+		cp_intc_write(~0, CP_INTC_SYS_STAT_CLR(i));
+
+	/* Enable nIRQ (what about nFIQ?) */
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_SET);
+
+	/*
+	 * Priority is determined by host channel: lower channel number has
+	 * higher priority i.e. channel 0 has highest priority and channel 31
+	 * had the lowest priority.
+	 */
+	num_reg = (num_irq + 3) >> 2;	/* 4 channels per register */
+	if (irq_prio) {
+		unsigned j, k;
+		u32 val;
+
+		for (k = i = 0; i < num_reg; i++) {
+			for (val = j = 0; j < 4; j++, k++) {
+				val >>= 8;
+				if (k < num_irq)
+					val |= irq_prio[k] << 24;
+			}
+
+			cp_intc_write(val, CP_INTC_CHAN_MAP(i));
+		}
+	} else	{
+		/*
+		 * Default everything to channel 15 if priority not specified.
+		 * Note that channel 0-1 are mapped to nFIQ and channels 2-31
+		 * are mapped to nIRQ.
+		 */
+		for (i = 0; i < num_reg; i++)
+			cp_intc_write(0x0f0f0f0f, CP_INTC_CHAN_MAP(i));
+	}
+
+	/* Set up genirq dispatching for cp_intc */
+	for (i = 0; i < num_irq; i++) {
+		set_irq_chip(i, &cp_intc_irq_chip);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+		set_irq_handler(i, handle_edge_irq);
+	}
+
+	/* Enable global interrupt */
+	cp_intc_write(1, CP_INTC_GLOBAL_ENABLE);
+}
diff --git a/arch/arm/mach-davinci/da850.c b/arch/arm/mach-davinci/da850.c
new file mode 100644
index 0000000..b0af6f4
--- /dev/null
+++ b/arch/arm/mach-davinci/da850.c
@@ -0,0 +1,372 @@
+/*
+ * TI DaVinci DM850 chip specific setup
+ *
+ * Author: Sudhakar Rajashekhara
+ *
+ * 2009 (c) Texas Instruments. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <mach/da8xx.h>
+#include <mach/clock.h>
+#include <mach/cpu.h>
+#include <mach/irqs.h>
+#include <mach/psc.h>
+#include <mach/io.h>
+
+#include "clock.h"
+
+/*
+ * Device specific clocks
+ */
+#define DA850_AUX_FREQ	24000000
+
+static struct pll_data pll0_data = {
+	.num		= 1,
+	.phys_base	= DA8XX_PLL_CNTRL0_BASE,
+	.flags		= PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
+};
+
+static struct clk ref_clk = {
+	.name		= "ref_clk",
+	.rate		= DA850_AUX_FREQ,
+};
+
+static struct clk pll0_clk = {
+	.name		= "pll0",
+	.parent		= &ref_clk,
+	.pll_data	= &pll0_data,
+	.flags		= CLK_PLL,
+};
+
+static struct clk pll0_aux_clk = {
+	.name		= "pll0_aux_clk",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL | PRE_PLL,
+};
+
+static struct clk pll0_sysclk2 = {
+	.name		= "pll0_sysclk2",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV2,
+};
+
+static struct clk pll0_sysclk3 = {
+	.name		= "pll0_sysclk3",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV3,
+};
+
+static struct clk pll0_sysclk4 = {
+	.name		= "pll0_sysclk4",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV4,
+};
+
+static struct clk pll0_sysclk5 = {
+	.name		= "pll0_sysclk5",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV5,
+};
+
+static struct clk pll0_sysclk6 = {
+	.name		= "pll0_sysclk6",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV6,
+};
+
+static struct clk pll0_sysclk7 = {
+	.name		= "pll0_sysclk7",
+	.parent		= &pll0_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV7,
+};
+
+static struct pll_data pll1_data = {
+	.num		= 2,
+	.phys_base	= DA8XX_PLL_CNTRL1_BASE,
+	.flags		= PLL_HAS_PREDIV | PLL_HAS_POSTDIV,
+};
+
+static struct clk pll1_clk = {
+	.name		= "pll1",
+	.parent		= &ref_clk,
+	.pll_data	= &pll1_data,
+	.flags		= CLK_PLL,
+};
+
+static struct clk pll1_aux_clk = {
+	.name		= "pll1_aux_clk",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL | PRE_PLL,
+};
+
+static struct clk pll1_sysclk2 = {
+	.name		= "pll1_sysclk2",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV2,
+};
+
+static struct clk pll1_sysclk3 = {
+	.name		= "pll1_sysclk3",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV3,
+};
+
+static struct clk pll1_sysclk4 = {
+	.name		= "pll1_sysclk4",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV4,
+};
+
+static struct clk pll1_sysclk5 = {
+	.name		= "pll1_sysclk5",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV5,
+};
+
+static struct clk pll1_sysclk6 = {
+	.name		= "pll1_sysclk6",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV6,
+};
+
+static struct clk pll1_sysclk7 = {
+	.name		= "pll1_sysclk7",
+	.parent		= &pll1_clk,
+	.flags		= CLK_PLL,
+	.div_reg	= PLLDIV7,
+};
+
+static struct clk i2c0_clk = {
+	.name		= "i2c0",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk timerp64_0_clk = {
+	.name		= "timer0",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk timerp64_1_clk = {
+	.name		= "timer1",
+	.parent		= &pll0_aux_clk,
+};
+
+static struct clk tpcc0_clk = {
+	.name		= "tpcc0",
+	.id		= 0,
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_TPCC,
+	.flags		= CLK_PSC | ALWAYS_ENABLED,
+};
+
+static struct clk tptc0_clk = {
+	.name		= "tptc0",
+	.id		= 0,
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_TPTC0,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk tptc1_clk = {
+	.name		= "tptc1",
+	.id		= 0,
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_TPTC1,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk tpcc1_clk = {
+	.name		= "tpcc0",
+	.id		= 1,
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC_TPCC1,
+	.flags		= CLK_PSC | ALWAYS_ENABLED,
+};
+
+static struct clk tptc2_clk = {
+	.name		= "tptc0",
+	.id		= 1,
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC_TPTC2,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk mmcsd_clk = {
+	.name		= "mmcsd",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_MMC_SD,
+};
+
+static struct clk uart0_clk = {
+	.name		= "uart0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_UART0,
+};
+
+static struct clk uart1_clk = {
+	.name		= "uart1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_UART1,
+	.dup_parent	= &pll1_sysclk2,
+};
+
+static struct clk uart2_clk = {
+	.name		= "uart2",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_UART2,
+	.dup_parent	= &pll1_sysclk2,
+};
+
+static struct clk spi0_clk = {
+	.name		= "spi0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_SPI0,
+};
+
+static struct clk spi1_clk = {
+	.name		= "spi1",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_SPI1,
+	.dup_parent	= &pll1_sysclk2,
+};
+
+static struct clk lcdc_clk = {
+	.name		= "lcdc",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_LCDCNTL,
+};
+
+static struct clk aemif_clk = {
+	.name		= "aemif",
+	.parent		= &pll0_sysclk3,
+	.lpsc		= DA8XX_LPSC_EMIF25,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk emac_clk = {
+	.name		= "emac",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC_CPGMAC,
+};
+
+static struct clk gpio_clk = {
+	.name		= "gpio",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC_GPIO,
+};
+
+static struct clk emif3_clk = {
+	.name		= "emif3",
+	.parent		= &pll0_sysclk5,
+	.lpsc		= DA8XX_LPSC_EMIF3C,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk arm_clk = {
+	.name		= "arm",
+	.parent		= &pll0_sysclk6,
+	.lpsc		= DA8XX_LPSC_ARM,
+	.flags		= ALWAYS_ENABLED,
+};
+
+static struct clk mcasp_clk = {
+	.name		= "mcasp",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_McASP0,
+	.dup_parent	= &pll1_sysclk2,
+};
+
+static struct clk usb0_clk = {
+	.name		= "usb0",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA8XX_LPSC_USB20,
+};
+
+static struct clk usb1_clk = {
+	.name		= "usb1",
+	.parent		= &pll0_sysclk4,
+	.lpsc		= DA8XX_LPSC_USB11,
+};
+
+static struct clk sata_clk = {
+	.name		= "ahci",
+	.parent		= &pll0_sysclk2,
+	.lpsc		= DA850_LPSC_SATA,
+};
+
+static struct clk *da850_clks[] = {
+	&ref_clk,
+	&pll0_clk,
+	&pll0_aux_clk,
+	&pll0_sysclk2,
+	&pll0_sysclk3,
+	&pll0_sysclk4,
+	&pll0_sysclk5,
+	&pll0_sysclk6,
+	&pll0_sysclk7,
+	&pll1_clk,
+	&pll1_aux_clk,
+	&pll1_sysclk2,
+	&pll1_sysclk3,
+	&pll1_sysclk4,
+	&pll1_sysclk5,
+	&pll1_sysclk6,
+	&pll1_sysclk7,
+	&i2c0_clk,
+	&timerp64_0_clk,
+	&timerp64_1_clk,
+	&tpcc0_clk,
+	&tptc0_clk,
+	&tptc1_clk,
+	&tpcc1_clk,
+	&tptc2_clk,
+	&mmcsd_clk,
+	&uart0_clk,
+	&uart1_clk,
+	&uart2_clk,
+	&spi0_clk,
+	&spi1_clk,
+	&lcdc_clk,
+	&aemif_clk,
+	&emac_clk,
+	&gpio_clk,
+	&emif3_clk,
+	&arm_clk,
+	&mcasp_clk,
+	&usb0_clk,
+	&usb1_clk,
+	&sata_clk,
+};
+
+
+int get_async3_src(void)
+{
+	unsigned int *addr = IO_ADDRESS(DA8XX_CFGCHIP3);
+
+	return (__raw_readl(addr) & 0x10) ? 1 : 0;
+}
+
+void __init da850_init(void)
+{
+	davinci_clk_init(da850_clks, ARRAY_SIZE(da850_clks));
+}
+
diff --git a/arch/arm/mach-davinci/id.c b/arch/arm/mach-davinci/id.c
index 70608f7..25628b4 100644
--- a/arch/arm/mach-davinci/id.c
+++ b/arch/arm/mach-davinci/id.c
@@ -13,10 +13,15 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
+#ifdef CONFIG_ARCH_DA8XX
+#define JTAG_ID_BASE		IO_ADDRESS(0x01c14018)
+#else
+#define JTAG_ID_BASE		IO_ADDRESS(0x01c40028)
+#endif
 
-#define JTAG_ID_BASE		0x01c40028
+static unsigned int davinci_revision;
 
 struct davinci_id {
 	u8	variant;	/* JTAG ID bits 31:28 */
@@ -34,6 +39,34 @@ static struct davinci_id davinci_ids[] __initdata = {
 		.manufacturer = 0x017,
 		.type	      = 0x64460000,
 	},
+	{
+		/* DM646X */
+		.part_no      = 0xb770,
+		.variant      = 0x0,
+		.manufacturer = 0x017,
+		.type         = 0x64670000,
+	},
+	{
+		/* DM355 */
+		.part_no	= 0xb73b,
+		.variant	= 0x0,
+		.manufacturer	= 0x00f,
+		.type		= 0x03550000,
+	},
+	{
+		/* DA830 */
+		.part_no	= 0xb7df,
+		.variant	= 0x0,
+		.manufacturer	= 0x017,
+		.type		= 0x08300000,
+	},
+	{
+		/* DA850 */
+		.part_no	= 0xb7d1,
+		.variant	= 0x0,
+		.manufacturer	= 0x017,
+		.type		= 0x08500000,
+	},
 };
 
 /*
@@ -43,7 +76,7 @@ static u16 __init davinci_get_part_no(void)
 {
 	u32 dev_id, part_no;
 
-	dev_id = davinci_readl(JTAG_ID_BASE);
+	dev_id = __raw_readl(JTAG_ID_BASE);
 
 	part_no = ((dev_id >> 12) & 0xffff);
 
@@ -57,13 +90,19 @@ static u8 __init davinci_get_variant(void)
 {
 	u32 variant;
 
-	variant = davinci_readl(JTAG_ID_BASE);
+	variant = __raw_readl(JTAG_ID_BASE);
 
 	variant = (variant >> 28) & 0xf;
 
 	return variant;
 }
 
+unsigned int davinci_rev(void)
+{
+	return davinci_revision >> 16;
+}
+EXPORT_SYMBOL(davinci_rev);
+
 void __init davinci_check_revision(void)
 {
 	int i;
@@ -76,7 +115,7 @@ void __init davinci_check_revision(void)
 	/* First check only the major version in a safe way */
 	for (i = 0; i < ARRAY_SIZE(davinci_ids); i++) {
 		if (part_no == (davinci_ids[i].part_no)) {
-			system_rev = davinci_ids[i].type;
+			davinci_revision = davinci_ids[i].type;
 			break;
 		}
 	}
@@ -85,10 +124,16 @@ void __init davinci_check_revision(void)
 	for (i = 0; i < ARRAY_SIZE(davinci_ids); i++) {
 		if (part_no == davinci_ids[i].part_no &&
 		    variant == davinci_ids[i].variant) {
-			system_rev = davinci_ids[i].type;
+			davinci_revision = davinci_ids[i].type;
 			break;
 		}
 	}
 
-	printk("DaVinci DM%04x variant 0x%x\n", system_rev >> 16, variant);
+#ifdef CONFIG_ARCH_DA8XX
+	printk(KERN_INFO "DA%04x variant 0x%x\n",
+	       davinci_rev(), variant);
+#else
+	printk(KERN_INFO "DaVinci DM%04x variant 0x%x\n",
+	       davinci_rev(), variant);
+#endif
 }
diff --git a/arch/arm/mach-davinci/include/mach/clock.h b/arch/arm/mach-davinci/include/mach/clock.h
index 38bdd49..a3b0402 100644
--- a/arch/arm/mach-davinci/include/mach/clock.h
+++ b/arch/arm/mach-davinci/include/mach/clock.h
@@ -17,6 +17,5 @@ struct clk;
 
 extern int clk_register(struct clk *clk);
 extern void clk_unregister(struct clk *clk);
-extern int davinci_clk_init(void);
 
 #endif
diff --git a/arch/arm/mach-davinci/include/mach/common.h b/arch/arm/mach-davinci/include/mach/common.h
index a97dfbb..d091419 100644
--- a/arch/arm/mach-davinci/include/mach/common.h
+++ b/arch/arm/mach-davinci/include/mach/common.h
@@ -16,4 +16,7 @@ struct sys_timer;
 
 extern struct sys_timer davinci_timer;
 
+extern void davinci_irq_init(void);
+extern void davinci_map_common_io(void);
+
 #endif /* __ARCH_ARM_MACH_DAVINCI_COMMON_H */
diff --git a/arch/arm/mach-davinci/include/mach/cp_intc.h b/arch/arm/mach-davinci/include/mach/cp_intc.h
new file mode 100644
index 0000000..c4d27ee
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/cp_intc.h
@@ -0,0 +1,57 @@
+/*
+ * TI Common Platform Interrupt Controller (cp_intc) definitions
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ * Copyright (C) 2008-2009, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+#ifndef __ASM_HARDWARE_CP_INTC_H
+#define __ASM_HARDWARE_CP_INTC_H
+
+#define CP_INTC_REV			0x00
+#define CP_INTC_CTRL			0x04
+#define CP_INTC_HOST_CTRL		0x0C
+#define CP_INTC_GLOBAL_ENABLE		0x10
+#define CP_INTC_GLOBAL_NESTING_LEVEL	0x1C
+#define CP_INTC_SYS_STAT_IDX_SET	0x20
+#define CP_INTC_SYS_STAT_IDX_CLR	0x24
+#define CP_INTC_SYS_ENABLE_IDX_SET	0x28
+#define CP_INTC_SYS_ENABLE_IDX_CLR	0x2C
+#define CP_INTC_GLOBAL_WAKEUP_ENABLE	0x30
+#define CP_INTC_HOST_ENABLE_IDX_SET	0x34
+#define CP_INTC_HOST_ENABLE_IDX_CLR	0x38
+#define CP_INTC_PACING_PRESCALE 	0x40
+#define CP_INTC_VECTOR_BASE		0x50
+#define CP_INTC_VECTOR_SIZE		0x54
+#define CP_INTC_VECTOR_NULL		0x58
+#define CP_INTC_PRIO_IDX		0x80
+#define CP_INTC_PRIO_VECTOR		0x84
+#define CP_INTC_SECURE_ENABLE		0x90
+#define CP_INTC_SECURE_PRIO_IDX 	0x94
+#define CP_INTC_PACING_PARAM(n) 	(0x0100 + (n << 4))
+#define CP_INTC_PACING_DEC(n)		(0x0104 + (n << 4))
+#define CP_INTC_PACING_MAP(n)		(0x0108 + (n << 4))
+#define CP_INTC_SYS_RAW_STAT(n) 	(0x0200 + (n << 2))
+#define CP_INTC_SYS_STAT_CLR(n) 	(0x0280 + (n << 2))
+#define CP_INTC_SYS_ENABLE_SET(n)	(0x0300 + (n << 2))
+#define CP_INTC_SYS_ENABLE_CLR(n)	(0x0380 + (n << 2))
+#define CP_INTC_CHAN_MAP(n)		(0x0400 + (n << 2))
+#define CP_INTC_HOST_MAP(n)		(0x0800 + (n << 2))
+#define CP_INTC_HOST_PRIO_IDX(n)	(0x0900 + (n << 2))
+#define CP_INTC_SYS_POLARITY(n) 	(0x0D00 + (n << 2))
+#define CP_INTC_SYS_TYPE(n)		(0x0D80 + (n << 2))
+#define CP_INTC_WAKEUP_ENABLE(n)	(0x0E00 + (n << 2))
+#define CP_INTC_DEBUG_SELECT(n) 	(0x0F00 + (n << 2))
+#define CP_INTC_SYS_SECURE_ENABLE(n)	(0x1000 + (n << 2))
+#define CP_INTC_HOST_NESTING_LEVEL(n)	(0x1100 + (n << 2))
+#define CP_INTC_HOST_ENABLE(n)		(0x1500 + (n << 2))
+#define CP_INTC_HOST_PRIO_VECTOR(n)	(0x1600 + (n << 2))
+#define CP_INTC_VECTOR_ADDR(n)		(0x2000 + (n << 2))
+
+void __init cp_intc_init(void __iomem *base, unsigned short num_irq,
+			 u8 *irq_prio);
+
+#endif	/* __ASM_HARDWARE_CP_INTC_H */
diff --git a/arch/arm/mach-davinci/include/mach/cpu.h b/arch/arm/mach-davinci/include/mach/cpu.h
new file mode 100644
index 0000000..5da52bc
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/cpu.h
@@ -0,0 +1,68 @@
+/*
+ * DaVinci CPU type detection
+ *
+ * Author: Kevin Hilman, Deep Root Systems, LLC
+ *
+ * Defines the cpu_is_*() macros for runtime detection of DaVinci
+ * device type.  In addtion, if support for a given device is not
+ * compiled in to the kernel, the macros return 0 so that
+ * resulting code can be optimized out.
+ *
+ * 2007 (c) Deep Root Systems, LLC. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef _ASM_ARCH_CPU_H
+#define _ASM_ARCH_CPU_H
+
+extern unsigned int davinci_rev(void);
+
+#define IS_DAVINCI_CPU(type, id)			\
+static inline int is_davinci_ ##type(void)	        \
+{							\
+	return (davinci_rev() == (id)) ? 1 : 0;	        \
+}
+
+IS_DAVINCI_CPU(dm644x, 0x6446)
+IS_DAVINCI_CPU(dm646x, 0x6467)
+IS_DAVINCI_CPU(dm355, 0x355)
+IS_DAVINCI_CPU(da830, 0x830)
+IS_DAVINCI_CPU(da850, 0x850)
+
+#ifdef CONFIG_ARCH_DAVINCI_DM644x
+#define cpu_is_davinci_dm644x() is_davinci_dm644x()
+#else
+#define cpu_is_davinci_dm644x() 0
+#endif
+
+#ifdef CONFIG_ARCH_DAVINCI_DM646x
+#define cpu_is_davinci_dm646x() is_davinci_dm646x()
+#else
+#define cpu_is_davinci_dm646x() 0
+#endif
+
+#ifdef CONFIG_ARCH_DAVINCI_DM355
+#define cpu_is_davinci_dm355() is_davinci_dm355()
+#else
+#define cpu_is_davinci_dm355() 0
+#endif
+
+#ifdef CONFIG_ARCH_DA830
+#define cpu_is_da830() is_davinci_da830()
+#else
+#define cpu_is_da830() 0
+#endif
+
+#ifdef CONFIG_ARCH_DA850
+#define cpu_is_da850() is_davinci_da850()
+#else
+#define cpu_is_da850() 0
+#endif
+#endif
+
+#ifdef CONFIG_ARCH_DA8XX
+#define cpu_is_da8xx()	(cpu_is_da830() || cpu_is_da850())
+#else
+#define cpu_is_da8xx()	0
+#endif
diff --git a/arch/arm/mach-davinci/include/mach/da8xx.h b/arch/arm/mach-davinci/include/mach/da8xx.h
new file mode 100644
index 0000000..4d526f4
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/da8xx.h
@@ -0,0 +1,84 @@
+/*
+ * This file contains the processor specific definitions
+ * of the TI DA830/DA850
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_DA8XX_H
+#define __ASM_ARCH_DA8XX_H
+
+#include <mach/hardware.h>
+
+void __init da850_init(void);
+
+int get_async3_src(void);
+
+#define DA8XX_BOOT_CFG_BASE		0x01C14000
+
+#define DA8XX_KICK0             (DA8XX_BOOT_CFG_BASE + 0x38)
+#define DA8XX_KICK0_MAGIC       0x83e70b13
+#define DA8XX_KICK1             (DA8XX_BOOT_CFG_BASE + 0x3c)
+#define DA8XX_KICK1_MAGIC       0x95a4f1e0
+
+#define DA8XX_PINMUX0   (0x120)
+#define DA8XX_PINMUX1   (0x124)
+#define DA8XX_PINMUX2   (0x128)
+#define DA8XX_PINMUX3   (0x12C)
+#define DA8XX_PINMUX4   (0x130)
+#define DA8XX_PINMUX5   (0x134)
+#define DA8XX_PINMUX6   (0x138)
+#define DA8XX_PINMUX7   (0x13C)
+#define DA8XX_PINMUX8   (0x140)
+#define DA8XX_PINMUX9   (0x144)
+#define DA8XX_PINMUX10  (0x148)
+#define DA8XX_PINMUX11  (0x14C)
+#define DA8XX_PINMUX12  (0x150)
+#define DA8XX_PINMUX13  (0x154)
+#define DA8XX_PINMUX14  (0x158)
+#define DA8XX_PINMUX15  (0x15C)
+#define DA8XX_PINMUX16  (0x160)
+#define DA8XX_PINMUX17  (0x164)
+#define DA8XX_PINMUX18  (0x168)
+#define DA8XX_PINMUX19  (0x16C)
+
+#define DA8XX_CFGCHIP0  (DA8XX_BOOT_CFG_BASE + 0x17c)
+#define DA8XX_CFGCHIP1  (DA8XX_BOOT_CFG_BASE + 0x180)
+#define DA8XX_CFGCHIP2  (DA8XX_BOOT_CFG_BASE + 0x184)
+#define DA8XX_CFGCHIP3  (DA8XX_BOOT_CFG_BASE + 0x188)
+#define DA8XX_CFGCHIP4  (DA8XX_BOOT_CFG_BASE + 0x18c)
+
+#define DA8XX_I2C0_BASE		0x01C22000
+#define DA8XX_I2C1_BASE		0x01E28000
+
+#define DA8XX_EMAC_CPPI_PORT_BASE	0x01E20000
+#define DA8XX_EMAC_CTRL_REG_OFFSET     0x3000
+#define DA8XX_EMAC_MOD_REG_OFFSET      0x2000
+#define DA8XX_EMAC_RAM_OFFSET          0x0000
+#define DA8XX_MDIO_REG_OFFSET          0x4000
+#define DA8XX_EMAC_CTRL_RAM_SIZE       SZ_8K
+
+#define DA8XX_LCD_CNTRL_BASE			0x01E13000
+#define DA8XX_EMIF30_ASYNC_DATA_CE5_BASE	0xC0000000
+
+#define DA8XX_USB0_BASE				0x01E00000
+#define DA8XX_USB1_BASE				0x01E25000
+
+#define DA850_SATA_BASE				0x01E18000
+#define DA850_SATA_CLK_PWRDN			0x01E2C018
+
+#endif /* __ASM_ARCH_DA8XX_H */
diff --git a/arch/arm/mach-davinci/include/mach/debug-macro.S b/arch/arm/mach-davinci/include/mach/debug-macro.S
index e6c0f0d..b411bc3 100644
--- a/arch/arm/mach-davinci/include/mach/debug-macro.S
+++ b/arch/arm/mach-davinci/include/mach/debug-macro.S
@@ -9,13 +9,45 @@
  * or implied.
  */
 
+/* Modifications
+ * Jan 2009	Chaithrika U S	Added senduart, busyuart, waituart
+ *				macros, based on debug-8250.S file
+ *				but using 32-bit accesses required for
+ *                              some davinci devices.
+ */
+
+#include <linux/serial_reg.h>
+#define UART_SHIFT	2
+
 		.macro addruart, rx
 		mrc	p15, 0, \rx, c1, c0
 		tst	\rx, #1			@ MMU enabled?
 		moveq	\rx, #0x01000000	@ physical base address
 		movne	\rx, #0xfe000000	@ virtual base
+#if defined (CONFIG_ARCH_DA8XX)
+		orr	\rx, \rx, #0x00d00000   @ UART 2
+		orr	\rx, \rx, #0x0000d000   @ UART 2
+#else
 		orr	\rx, \rx, #0x00c20000   @ UART 0
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #UART_TX << UART_SHIFT]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #UART_LSR << UART_SHIFT]
+		and	\rd, \rd, #UART_LSR_TEMT | UART_LSR_THRE
+		teq	\rd, #UART_LSR_TEMT | UART_LSR_THRE
+		bne	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+#ifdef FLOW_CONTROL
+1001:		ldr	\rd, [\rx, #UART_MSR << UART_SHIFT]
+		tst	\rd, #UART_MSR_CTS
+		beq	1001b
+#endif
 		.endm
 
-#define UART_SHIFT	2
-#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-davinci/include/mach/dma.h b/arch/arm/mach-davinci/include/mach/dma.h
index 8e2f2d0..942dda2 100644
--- a/arch/arm/mach-davinci/include/mach/dma.h
+++ b/arch/arm/mach-davinci/include/mach/dma.h
@@ -11,6 +11,6 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H
 
-#define MAX_DMA_ADDRESS			0xffffffff
+#define MAX_DMA_ADDRESS			(PAGE_OFFSET + (128<<20))
 
 #endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-davinci/include/mach/entry-macro.S b/arch/arm/mach-davinci/include/mach/entry-macro.S
index 039b84f..292114d 100644
--- a/arch/arm/mach-davinci/include/mach/entry-macro.S
+++ b/arch/arm/mach-davinci/include/mach/entry-macro.S
@@ -13,19 +13,31 @@
 
 		.macro	disable_fiq
 		.endm
-
 		.macro  get_irqnr_preamble, base, tmp
+#ifdef CONFIG_ARCH_DA8XX
+		ldr \base, =IO_Dx_INTC_VIRT
+#else
 		ldr \base, =IO_ADDRESS(DAVINCI_ARM_INTC_BASE)
+#endif
 		.endm
 
 		.macro  arch_ret_to_user, tmp1, tmp2
 		.endm
 
 		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#ifdef CONFIG_ARCH_DA8XX
+		ldr \irqnr, [\base, #0x80] /* get irq number */
+		and \irqnr, \irqnr, #0xff  /* irq is in bits 0-9 */
+		mov \tmp, \irqnr, lsr #3
+		and \tmp, \tmp, #0xfc
+		add \tmp, \tmp, #0x280 /* get the register offset */
+		ldr \irqstat, [\base, \tmp] /* get the intc status */
+		cmp \irqstat, #0x0
+#else
 		ldr \tmp, [\base, #0x14]
-		mov \tmp, \tmp, lsr #2
+		movs \tmp, \tmp, lsr #2
 		sub \irqnr, \tmp, #1
-		cmp \tmp, #0
+#endif
 		.endm
 
 		.macro	irq_prio_table
diff --git a/arch/arm/mach-davinci/include/mach/hardware.h b/arch/arm/mach-davinci/include/mach/hardware.h
index a2e8969..48c7793 100644
--- a/arch/arm/mach-davinci/include/mach/hardware.h
+++ b/arch/arm/mach-davinci/include/mach/hardware.h
@@ -1,9 +1,9 @@
 /*
- * Common hardware definitions
+ * Hardware definitions common to all DaVinci family processors
  *
- * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ * Author: Kevin Hilman, Deep Root Systems, LLC
  *
- * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * 2007 (c) Deep Root Systems, LLC. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -12,41 +12,16 @@
 #define __ASM_ARCH_HARDWARE_H
 
 /*
- * Base register addresses
+ * Before you add anything to ths file:
+ *
+ * This header is for defines common to ALL DaVinci family chips.
+ * Anything that is chip specific should go in <chipname>.h,
+ * and the chip/board init code should then explicitly include
+ * <chipname>.h
  */
-#define DAVINCI_DMA_3PCC_BASE			(0x01C00000)
-#define DAVINCI_DMA_3PTC0_BASE			(0x01C10000)
-#define DAVINCI_DMA_3PTC1_BASE			(0x01C10400)
-#define DAVINCI_I2C_BASE			(0x01C21000)
-#define DAVINCI_PWM0_BASE			(0x01C22000)
-#define DAVINCI_PWM1_BASE			(0x01C22400)
-#define DAVINCI_PWM2_BASE			(0x01C22800)
-#define DAVINCI_SYSTEM_MODULE_BASE		(0x01C40000)
-#define DAVINCI_PLL_CNTRL0_BASE			(0x01C40800)
-#define DAVINCI_PLL_CNTRL1_BASE			(0x01C40C00)
-#define DAVINCI_PWR_SLEEP_CNTRL_BASE		(0x01C41000)
-#define DAVINCI_SYSTEM_DFT_BASE			(0x01C42000)
-#define DAVINCI_IEEE1394_BASE			(0x01C60000)
-#define DAVINCI_USB_OTG_BASE			(0x01C64000)
-#define DAVINCI_CFC_ATA_BASE			(0x01C66000)
-#define DAVINCI_SPI_BASE			(0x01C66800)
-#define DAVINCI_GPIO_BASE			(0x01C67000)
-#define DAVINCI_UHPI_BASE			(0x01C67800)
-#define DAVINCI_VPSS_REGS_BASE			(0x01C70000)
-#define DAVINCI_EMAC_CNTRL_REGS_BASE		(0x01C80000)
-#define DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE	(0x01C81000)
-#define DAVINCI_EMAC_WRAPPER_RAM_BASE		(0x01C82000)
-#define DAVINCI_MDIO_CNTRL_REGS_BASE		(0x01C84000)
-#define DAVINCI_IMCOP_BASE			(0x01CC0000)
-#define DAVINCI_ASYNC_EMIF_CNTRL_BASE		(0x01E00000)
-#define DAVINCI_VLYNQ_BASE			(0x01E01000)
-#define DAVINCI_MCBSP_BASE			(0x01E02000)
-#define DAVINCI_MMC_SD_BASE			(0x01E10000)
-#define DAVINCI_MS_BASE				(0x01E20000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE	(0x02000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE	(0x04000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE	(0x06000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE	(0x08000000)
-#define DAVINCI_VLYNQ_REMOTE_BASE		(0x0C000000)
+#define DAVINCI_SYSTEM_MODULE_BASE        0x01C40000
+
+/* System control register offsets */
+#define DM64XX_VDD3P3V_PWDN	0x48
 
 #endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/mach-davinci/include/mach/io.h b/arch/arm/mach-davinci/include/mach/io.h
index e7accb9..39641e7 100644
--- a/arch/arm/mach-davinci/include/mach/io.h
+++ b/arch/arm/mach-davinci/include/mach/io.h
@@ -22,58 +22,42 @@
 #define IO_OFFSET	0xfd000000 /* Virtual IO = 0xfec00000 */
 #define IO_SIZE		0x00400000
 #define IO_VIRT		(IO_PHYS + IO_OFFSET)
-#define io_p2v(pa)	((pa) + IO_OFFSET)
 #define io_v2p(va)	((va) - IO_OFFSET)
-#define IO_ADDRESS(x)	io_p2v(x)
+#define __IO_ADDRESS(x)	((x) + IO_OFFSET)
+
+/*
+ * Some platforms have the interrupt controller mapped at a different physical
+ * address.  This I/O map creates a virtual mapping of the interrupt controller
+ * that is common across platforms; it needs to apply to all platform variants.
+ * The interrupt controller address mapped in the IO_VIRT range should not be
+ * used.  The address is determined by the size of CP INTC address space (which
+ * is 4KB or 1 page) and a single page hole to reduce the chance for invalid
+ * memory access.
+ */
+#define IO_Dx_INTC_SIZE SZ_64K
+#define IO_Dx_INTC_VIRT 0xfebd0000
 
 /*
  * We don't actually have real ISA nor PCI buses, but there is so many
  * drivers out there that might just work if we fake them...
  */
-#define PCIO_BASE               0
-#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#define __io(a)			((void __iomem *)(a))
 #define __mem_pci(a)		(a)
 #define __mem_isa(a)		(a)
 
-#ifndef __ASSEMBLER__
-
-/*
- * Functions to access the DaVinci IO region
- *
- * NOTE: - Use davinci_read/write[bwl] for physical register addresses
- *	 - Use __raw_read/write[bwl]() for virtual register addresses
- *	 - Use IO_ADDRESS(phys_addr) to convert registers to virtual addresses
- *	 - DO NOT use hardcoded virtual addresses to allow changing the
- *	   IO address space again if needed
- */
-#define davinci_readb(a)	(*(volatile unsigned char  *)IO_ADDRESS(a))
-#define davinci_readw(a)	(*(volatile unsigned short *)IO_ADDRESS(a))
-#define davinci_readl(a)	(*(volatile unsigned int   *)IO_ADDRESS(a))
-
-#define davinci_writeb(v,a)	(*(volatile unsigned char  *)IO_ADDRESS(a) = (v))
-#define davinci_writew(v,a)	(*(volatile unsigned short *)IO_ADDRESS(a) = (v))
-#define davinci_writel(v,a)	(*(volatile unsigned int   *)IO_ADDRESS(a) = (v))
-
-/* 16 bit uses LDRH/STRH, base +/- offset_8 */
-typedef struct { volatile u16 offset[256]; } __regbase16;
-#define __REGV16(vaddr)		((__regbase16 *)((vaddr)&~0xff)) \
-					->offset[((vaddr)&0xff)>>1]
-#define __REG16(paddr)          __REGV16(io_p2v(paddr))
+#define IO_ADDRESS(pa)          IOMEM(__IO_ADDRESS(pa))
 
-/* 8/32 bit uses LDR/STR, base +/- offset_12 */
-typedef struct { volatile u8 offset[4096]; } __regbase8;
-#define __REGV8(vaddr)		((__regbase8  *)((vaddr)&~4095)) \
-					->offset[((vaddr)&4095)>>0]
-#define __REG8(paddr)		__REGV8(io_p2v(paddr))
-
-typedef struct { volatile u32 offset[4096]; } __regbase32;
-#define __REGV32(vaddr)		((__regbase32 *)((vaddr)&~4095)) \
-					->offset[((vaddr)&4095)>>2]
-
-#define __REG(paddr)		__REGV32(io_p2v(paddr))
+#ifdef __ASSEMBLER__
+#define IOMEM(x)                x
 #else
+#define IOMEM(x)                ((void __force __iomem *)(x))
+
+#define __arch_ioremap(p, s, t)	davinci_ioremap(p, s, t)
+#define __arch_iounmap(v)	davinci_iounmap(v)
 
-#define __REG(x)	(*((volatile unsigned long *)io_p2v(x)))
+void __iomem *davinci_ioremap(unsigned long phys, size_t size,
+			      unsigned int type);
+void davinci_iounmap(volatile void __iomem *addr);
 
 #endif /* __ASSEMBLER__ */
 #endif /* __ASM_ARCH_IO_H */
diff --git a/arch/arm/mach-davinci/include/mach/irqs.h b/arch/arm/mach-davinci/include/mach/irqs.h
index f4c5ca6..b9c84da 100644
--- a/arch/arm/mach-davinci/include/mach/irqs.h
+++ b/arch/arm/mach-davinci/include/mach/irqs.h
@@ -95,11 +95,274 @@
 #define IRQ_COMMRX       62
 #define IRQ_EMUINT       63
 
+#ifdef CONFIG_ARCH_DA8XX
+#define DAVINCI_N_AINTC_IRQ	100
+#else
 #define DAVINCI_N_AINTC_IRQ	64
-#define DAVINCI_N_GPIO		71
+#endif
+#ifdef CONFIG_ARCH_DA8XX
+#define DAVINCI_N_GPIO		128
+#else
+#define DAVINCI_N_GPIO		104
+#endif
 
 #define NR_IRQS			(DAVINCI_N_AINTC_IRQ + DAVINCI_N_GPIO)
 
 #define ARCH_TIMER_IRQ IRQ_TINT1_TINT34
 
+/* DaVinci DM6467-specific Interrupts */
+#define IRQ_DM646X_VP_VERTINT0  0
+#define IRQ_DM646X_VP_VERTINT1  1
+#define IRQ_DM646X_VP_VERTINT2  2
+#define IRQ_DM646X_VP_VERTINT3  3
+#define IRQ_DM646X_VP_ERRINT    4
+#define IRQ_DM646X_RESERVED_1   5
+#define IRQ_DM646X_RESERVED_2   6
+#define IRQ_DM646X_WDINT        7
+#define IRQ_DM646X_CRGENINT0    8
+#define IRQ_DM646X_CRGENINT1    9
+#define IRQ_DM646X_TSIFINT0     10
+#define IRQ_DM646X_TSIFINT1     11
+#define IRQ_DM646X_VDCEINT      12
+#define IRQ_DM646X_USBINT       13
+#define IRQ_DM646X_USBDMAINT    14
+#define IRQ_DM646X_PCIINT       15
+#define IRQ_DM646X_TCERRINT2    20
+#define IRQ_DM646X_TCERRINT3    21
+#define IRQ_DM646X_IDE          22
+#define IRQ_DM646X_HPIINT       23
+#define IRQ_DM646X_EMACRXTHINT  24
+#define IRQ_DM646X_EMACRXINT    25
+#define IRQ_DM646X_EMACTXINT    26
+#define IRQ_DM646X_EMACMISCINT  27
+#define IRQ_DM646X_MCASP0TXINT  28
+#define IRQ_DM646X_MCASP0RXINT  29
+#define IRQ_DM646X_RESERVED_3   31
+#define IRQ_DM646X_MCASP1TXINT  32
+#define IRQ_DM646X_VLQINT       38
+#define IRQ_DM646X_UARTINT2     42
+#define IRQ_DM646X_SPINT0       43
+#define IRQ_DM646X_SPINT1       44
+#define IRQ_DM646X_DSP2ARMINT   45
+#define IRQ_DM646X_RESERVED_4   46
+#define IRQ_DM646X_PSCINT       47
+#define IRQ_DM646X_GPIO0        48
+#define IRQ_DM646X_GPIO1        49
+#define IRQ_DM646X_GPIO2        50
+#define IRQ_DM646X_GPIO3        51
+#define IRQ_DM646X_GPIO4        52
+#define IRQ_DM646X_GPIO5        53
+#define IRQ_DM646X_GPIO6        54
+#define IRQ_DM646X_GPIO7        55
+#define IRQ_DM646X_GPIOBNK0     56
+#define IRQ_DM646X_GPIOBNK1     57
+#define IRQ_DM646X_GPIOBNK2     58
+#define IRQ_DM646X_DDRINT       59
+#define IRQ_DM646X_AEMIFINT     60
+
+/* DaVinci DM355-specific Interrupts */
+#define IRQ_DM355_CCDC_VDINT0	0
+#define IRQ_DM355_CCDC_VDINT1	1
+#define IRQ_DM355_CCDC_VDINT2	2
+#define IRQ_DM355_IPIPE_HST	3
+#define IRQ_DM355_H3AINT	4
+#define IRQ_DM355_IPIPE_SDR	5
+#define IRQ_DM355_IPIPEIFINT	6
+#define IRQ_DM355_OSDINT	7
+#define IRQ_DM355_VENCINT	8
+#define IRQ_DM355_IMCOPINT	11
+#define IRQ_DM355_RTOINT	13
+#define IRQ_DM355_TINT4		13
+#define IRQ_DM355_TINT2_TINT12	13
+#define IRQ_DM355_UARTINT2	14
+#define IRQ_DM355_TINT5		14
+#define IRQ_DM355_TINT2_TINT34	14
+#define IRQ_DM355_TINT6		15
+#define IRQ_DM355_TINT3_TINT12	15
+#define IRQ_DM355_SPINT1_0	17
+#define IRQ_DM355_SPINT1_1	18
+#define IRQ_DM355_SPINT2_0	19
+#define IRQ_DM355_SPINT2_1	21
+#define IRQ_DM355_TINT7		22
+#define IRQ_DM355_TINT3_TINT34	22
+#define IRQ_DM355_SDIOINT0	23
+#define IRQ_DM355_MMCINT0	26
+#define IRQ_DM355_MSINT		26
+#define IRQ_DM355_MMCINT1	27
+#define IRQ_DM355_PWMINT3	28
+#define IRQ_DM355_SDIOINT1	31
+#define IRQ_DM355_SPINT0_0	42
+#define IRQ_DM355_SPINT0_1	43
+#define IRQ_DM355_GPIO0		44
+#define IRQ_DM355_GPIO1		45
+#define IRQ_DM355_GPIO2		46
+#define IRQ_DM355_GPIO3		47
+#define IRQ_DM355_GPIO4		48
+#define IRQ_DM355_GPIO5		49
+#define IRQ_DM355_GPIO6		50
+#define IRQ_DM355_GPIO7		51
+#define IRQ_DM355_GPIO8		52
+#define IRQ_DM355_GPIO9		53
+#define IRQ_DM355_GPIOBNK0	54
+#define IRQ_DM355_GPIOBNK1	55
+#define IRQ_DM355_GPIOBNK2	56
+#define IRQ_DM355_GPIOBNK3	57
+#define IRQ_DM355_GPIOBNK4	58
+#define IRQ_DM355_GPIOBNK5	59
+#define IRQ_DM355_GPIOBNK6	60
+
+/* Interrupts common to DA830 and DA850*/
+#define IRQ_DA8XX_COMMTX                0
+#define IRQ_DA8XX_COMMRX                1
+#define IRQ_DA8XX_NINT                  2
+#define IRQ_DA8XX_EVTOUT0               3
+#define IRQ_DA8XX_EVTOUT1               4
+#define IRQ_DA8XX_EVTOUT2               5
+#define IRQ_DA8XX_EVTOUT3               6
+#define IRQ_DA8XX_EVTOUT4               7
+#define IRQ_DA8XX_EVTOUT5               8
+#define IRQ_DA8XX_EVTOUT6               9
+#define IRQ_DA8XX_EVTOUT7               10
+#define IRQ_DA8XX_CCINT0                11
+#define IRQ_DA8XX_CCERRINT              12
+#define IRQ_DA8XX_TCERRINT0             13
+#define IRQ_DA8XX_AEMIFINT              14
+#define IRQ_DA8XX_I2CINT0               15
+#define IRQ_DA8XX_MMCSDINT0             16
+#define IRQ_DA8XX_MMCSDINT1             17
+#define IRQ_DA8XX_ALLINT0               18
+#define IRQ_DA8XX_RTC                   19
+#define IRQ_DA8XX_SPINT0                20
+#define IRQ_DA8XX_TINT12_0              21
+#define IRQ_DA8XX_TINT34_0              22
+#define IRQ_DA8XX_TINT12_1              23
+#define IRQ_DA8XX_TINT34_1              24
+#define IRQ_DA8XX_UARTINT0              25
+#define IRQ_DA8XX_KEYMGRINT             26
+#define IRQ_DA8XX_SECINT                26
+#define IRQ_DA8XX_SECKEYERR             26
+#define IRQ_DA8XX_CHIPINT0              28
+#define IRQ_DA8XX_CHIPINT1              29
+#define IRQ_DA8XX_CHIPINT2              30
+#define IRQ_DA8XX_CHIPINT3              31
+#define IRQ_DA8XX_TCERRINT1             32
+#define IRQ_DA8XX_C0_RX_THRESH_PULSE    33
+#define IRQ_DA8XX_C0_RX_PULSE           34
+#define IRQ_DA8XX_C0_TX_PULSE           35
+#define IRQ_DA8XX_C0_MISC_PULSE         36
+#define IRQ_DA8XX_C1_RX_THRESH_PULSE    37
+#define IRQ_DA8XX_C1_RX_PULSE           38
+#define IRQ_DA8XX_C1_TX_PULSE           39
+#define IRQ_DA8XX_C1_MISC_PULSE         40
+#define IRQ_DA8XX_MEMERR                41
+#define IRQ_DA8XX_GPIO0                 42
+#define IRQ_DA8XX_GPIO1                 43
+#define IRQ_DA8XX_GPIO2                 44
+#define IRQ_DA8XX_GPIO3                 45
+#define IRQ_DA8XX_GPIO4                 46
+#define IRQ_DA8XX_GPIO5                 47
+#define IRQ_DA8XX_GPIO6                 48
+#define IRQ_DA8XX_GPIO7                 49
+#define IRQ_DA8XX_GPIO8                 50
+#define IRQ_DA8XX_I2CINT1               51
+#define IRQ_DA8XX_LCDINT                52
+#define IRQ_DA8XX_UARTINT1              53
+#define IRQ_DA8XX_MCASPINT              54
+#define IRQ_DA8XX_ALLINT1               55
+#define IRQ_DA8XX_SPINT1                56
+#define IRQ_DA8XX_UHPI_INT1             57
+#define IRQ_DA8XX_USB_INT               58
+#define IRQ_DA8XX_IRQN                  59
+#define IRQ_DA8XX_RWAKEUP               60
+#define IRQ_DA8XX_UARTINT2              61
+#define IRQ_DA8XX_DFTSSINT              62
+#define IRQ_DA8XX_EHRPWM0               63
+#define IRQ_DA8XX_EHRPWM0TZ             64
+#define IRQ_DA8XX_EHRPWM1               65
+#define IRQ_DA8XX_EHRPWM1TZ             66
+#define IRQ_DA8XX_ECAP0                 69
+#define IRQ_DA8XX_ECAP1                 70
+#define IRQ_DA8XX_ECAP2                 71
+#define IRQ_DA8XX_ARMCLKSTOPREQ         90
+
+/* DA830 specific interrupts */
+#define IRQ_DA830_MPUERR                27
+#define IRQ_DA830_IOPUERR               27
+#define IRQ_DA830_BOOTCFGERR            27
+#define IRQ_DA830_EHRPWM2               67
+#define IRQ_DA830_EHRPWM2TZ             68
+#define IRQ_DA830_EQEP0                 72
+#define IRQ_DA830_EQEP1                 73
+#define IRQ_DA830_T12CMPINT0_0          74
+#define IRQ_DA830_T12CMPINT1_0          75
+#define IRQ_DA830_T12CMPINT2_0          76
+#define IRQ_DA830_T12CMPINT3_0          77
+#define IRQ_DA830_T12CMPINT4_0          78
+#define IRQ_DA830_T12CMPINT5_0          79
+#define IRQ_DA830_T12CMPINT6_0          80
+#define IRQ_DA830_T12CMPINT7_0          81
+#define IRQ_DA830_T12CMPINT0_1          82
+#define IRQ_DA830_T12CMPINT1_1          83
+#define IRQ_DA830_T12CMPINT2_1          84
+#define IRQ_DA830_T12CMPINT3_1          85
+#define IRQ_DA830_T12CMPINT4_1          86
+#define IRQ_DA830_T12CMPINT5_1          87
+#define IRQ_DA830_T12CMPINT6_1          88
+#define IRQ_DA830_T12CMPINT7_1          89
+
+/* DA850 speicific interrupts */
+#define IRQ_DA850_MPUADDRERR0		27
+#define IRQ_DA850_MPUPROTERR0		27
+#define IRQ_DA850_IOPUADDRERR0		27
+#define IRQ_DA850_IOPUPROTERR0		27
+#define IRQ_DA850_IOPUADDRERR1		27
+#define IRQ_DA850_IOPUPROTERR1		27
+#define IRQ_DA850_IOPUADDRERR2		27
+#define IRQ_DA850_IOPUPROTERR2		27
+#define IRQ_DA850_BOOTCFG_ADDR_ERR	27
+#define IRQ_DA850_BOOTCFG_PROT_ERR	27
+#define IRQ_DA850_MPUADDRERR1		27
+#define IRQ_DA850_MPUPROTERR1		27
+#define IRQ_DA850_IOPUADDRERR3		27
+#define IRQ_DA850_IOPUPROTERR3		27
+#define IRQ_DA850_IOPUADDRERR4		27
+#define IRQ_DA850_IOPUPROTERR4		27
+#define IRQ_DA850_IOPUADDRERR5		27
+#define IRQ_DA850_IOPUPROTERR5		27
+#define IRQ_DA850_MIOPU_BOOTCFG_ERR	27
+#define IRQ_DA850_SATAINT		67
+#define IRQ_DA850_TINT12_2		68
+#define IRQ_DA850_TINT34_2		68
+#define IRQ_DA850_TINTALL_2		68
+#define IRQ_DA850_MMCSDINT0_1		72
+#define IRQ_DA850_MMCSDINT1_1		73
+#define IRQ_DA850_T12CMPINT0_2		74
+#define IRQ_DA850_T12CMPINT1_2		75
+#define IRQ_DA850_T12CMPINT2_2		76
+#define IRQ_DA850_T12CMPINT3_2		77
+#define IRQ_DA850_T12CMPINT4_2		78
+#define IRQ_DA850_T12CMPINT5_2		79
+#define IRQ_DA850_T12CMPINT6_2		80
+#define IRQ_DA850_T12CMPINT7_2		81
+#define IRQ_DA850_T12CMPINT0_3		82
+#define IRQ_DA850_T12CMPINT1_3		83
+#define IRQ_DA850_T12CMPINT2_3		84
+#define IRQ_DA850_T12CMPINT3_3		85
+#define IRQ_DA850_T12CMPINT4_3		86
+#define IRQ_DA850_T12CMPINT5_3		87
+#define IRQ_DA850_T12CMPINT6_3		88
+#define IRQ_DA850_T12CMPINT7_3		89
+#define IRQ_DA850_RPIINT		91
+#define IRQ_DA850_VPIFINT		92
+#define IRQ_DA850_CCINT1		93
+#define IRQ_DA850_CCERRINT1		94
+#define IRQ_DA850_TCERRINT2		95
+#define IRQ_DA850_TINT12_3		96
+#define IRQ_DA850_TINT34_3		96
+#define IRQ_DA850_TINTALL_3		96
+#define IRQ_DA850_MCBSP0RINT		97
+#define IRQ_DA850_MCBSP0XINT		98
+#define IRQ_DA850_MCBSP1RINT		99
+#define IRQ_DA850_MCBSP1XINT		100
+
 #endif /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-davinci/include/mach/memory.h b/arch/arm/mach-davinci/include/mach/memory.h
index dd1625c..82c8be3 100644
--- a/arch/arm/mach-davinci/include/mach/memory.h
+++ b/arch/arm/mach-davinci/include/mach/memory.h
@@ -20,8 +20,13 @@
 /**************************************************************************
  * Definitions
  **************************************************************************/
+#ifdef CONFIG_ARCH_DA8XX
+#define DAVINCI_DDR_BASE    0xc0000000
+#define DAVINCI_IRAM_BASE   0x80000000 /* ARM Internal RAM */
+#else
 #define DAVINCI_DDR_BASE    0x80000000
 #define DAVINCI_IRAM_BASE   0x00008000 /* ARM Internal RAM */
+#endif
 
 #define PHYS_OFFSET DAVINCI_DDR_BASE
 
@@ -53,6 +58,7 @@ __arch_adjust_zones(int node, unsigned long *size, unsigned long *holes)
 
 #define ISA_DMA_THRESHOLD	(PHYS_OFFSET + (128<<20) - 1)
 
+
 #endif
 
 /*
diff --git a/arch/arm/mach-davinci/include/mach/psc.h b/arch/arm/mach-davinci/include/mach/psc.h
index 4977aa0..64eb404 100644
--- a/arch/arm/mach-davinci/include/mach/psc.h
+++ b/arch/arm/mach-davinci/include/mach/psc.h
@@ -30,6 +30,10 @@
 /* Power and Sleep Controller (PSC) Domains */
 #define DAVINCI_GPSC_ARMDOMAIN      0
 #define DAVINCI_GPSC_DSPDOMAIN      1
+#define DAVINCI_GPSC0_ARMDOMAIN     DAVINCI_GPSC_ARMDOMAIN
+#define DAVINCI_GPSC0_DSPDOMAIN     DAVINCI_GPSC_DSPDOMAIN
+#define DAVINCI_GPSC1_ARMDOMAIN     2
+#define DAVINCI_GPSC1_DSPDOMAIN     3
 
 #define DAVINCI_LPSC_VPSSMSTR       0
 #define DAVINCI_LPSC_VPSSSLV        1
@@ -38,8 +42,6 @@
 #define DAVINCI_LPSC_TPTC1          4
 #define DAVINCI_LPSC_EMAC           5
 #define DAVINCI_LPSC_EMAC_WRAPPER   6
-#define DAVINCI_LPSC_MDIO           7
-#define DAVINCI_LPSC_IEEE1394       8
 #define DAVINCI_LPSC_USB            9
 #define DAVINCI_LPSC_ATA            10
 #define DAVINCI_LPSC_VLYNQ          11
@@ -47,7 +49,6 @@
 #define DAVINCI_LPSC_DDR_EMIF       13
 #define DAVINCI_LPSC_AEMIF          14
 #define DAVINCI_LPSC_MMC_SD         15
-#define DAVINCI_LPSC_MEMSTICK       16
 #define DAVINCI_LPSC_McBSP          17
 #define DAVINCI_LPSC_I2C            18
 #define DAVINCI_LPSC_UART0          19
@@ -73,4 +74,100 @@
 #define DAVINCI_LPSC_GEM            39
 #define DAVINCI_LPSC_IMCOP          40
 
+#define DM355_LPSC_TIMER3		5
+#define DM355_LPSC_SPI1			6
+#define DM355_LPSC_MMC_SD1		7
+#define DM355_LPSC_McBSP1		8
+#define DM355_LPSC_PWM3			10
+#define DM355_LPSC_SPI2			11
+#define DM355_LPSC_RTO			12
+#define DM355_LPSC_VPSS_DAC		41
+
+/*
+ * LPSC Assignments
+ */
+#define DM646X_LPSC_ARM            0
+#define DM646X_LPSC_C64X_CPU       1
+#define DM646X_LPSC_HDVICP0        2
+#define DM646X_LPSC_HDVICP1        3
+#define DM646X_LPSC_TPCC           4
+#define DM646X_LPSC_TPTC0          5
+#define DM646X_LPSC_TPTC1          6
+#define DM646X_LPSC_TPTC2          7
+#define DM646X_LPSC_TPTC3          8
+#define DM646X_LPSC_PCI            13
+#define DM646X_LPSC_EMAC           14
+#define DM646X_LPSC_VDCE           15
+#define DM646X_LPSC_VPSSMSTR       16
+#define DM646X_LPSC_VPSSSLV        17
+#define DM646X_LPSC_TSIF0          18
+#define DM646X_LPSC_TSIF1          19
+#define DM646X_LPSC_DDR_EMIF       20
+#define DM646X_LPSC_AEMIF          21
+#define DM646X_LPSC_McASP0         22
+#define DM646X_LPSC_McASP1         23
+#define DM646X_LPSC_CRGEN0         24
+#define DM646X_LPSC_CRGEN1         25
+#define DM646X_LPSC_UART0          26
+#define DM646X_LPSC_UART1          27
+#define DM646X_LPSC_UART2          28
+#define DM646X_LPSC_PWM0           29
+#define DM646X_LPSC_PWM1           30
+#define DM646X_LPSC_I2C            31
+#define DM646X_LPSC_SPI            32
+#define DM646X_LPSC_GPIO           33
+#define DM646X_LPSC_TIMER0         34
+#define DM646X_LPSC_TIMER1         35
+#define DM646X_LPSC_ARM_INTC       45
+
+/* DA830 LPSC defines */
+/* PSC0 defines */
+#define DA8XX_LPSC_TPCC         0
+#define DA8XX_LPSC_TPTC0        1
+#define DA8XX_LPSC_TPTC1        2
+#define DA8XX_LPSC_EMIF25       3
+#define DA8XX_LPSC_SPI0         4
+#define DA8XX_LPSC_MMC_SD       5
+#define DA8XX_LPSC_AINTC        6
+#define DA8XX_LPSC_ARM_RAM_ROM  7
+#define DA8XX_LPSC_SECU_MGR     8
+#define DA8XX_LPSC_UART0        9
+#define DA8XX_LPSC_SCR0_SS      10
+#define DA8XX_LPSC_SCR1_SS      11
+#define DA8XX_LPSC_SCR2_SS      12
+#define DA8XX_LPSC_DMAX         13
+#define DA8XX_LPSC_ARM          14
+#define DA8XX_LPSC_GEM          15
+
+/* PSC1 defines */
+#define DA8XX_LPSC_USB20        (32 + 1)
+#define DA8XX_LPSC_USB11        (32 + 2)
+#define DA8XX_LPSC_GPIO         (32 + 3)
+#define DA8XX_LPSC_UHPI         (32 + 4)
+#define DA8XX_LPSC_CPGMAC       (32 + 5)
+#define DA8XX_LPSC_EMIF3C       (32 + 6)
+#define DA8XX_LPSC_McASP0       (32 + 7)
+#define DA830_LPSC_McASP1       (32 + 8)
+#define DA830_LPSC_McASP2       (32 + 9)
+#define DA8XX_LPSC_SPI1         (32 + 10)
+#define DA8XX_LPSC_I2C          (32 + 11)
+#define DA8XX_LPSC_UART1        (32 + 12)
+#define DA8XX_LPSC_UART2        (32 + 13)
+#define DA8XX_LPSC_LCDCNTL      (32 + 16)
+#define DA8XX_LPSC_PWM          (32 + 17)
+#define DA8XX_LPSC_ECAP         (32 + 20)
+#define DA830_LPSC_EQEP         (32 + 21)
+#define DA8XX_LPSC_SCR_P0_SS    (32 + 24)
+#define DA8XX_LPSC_SCR_P1_SS    (32 + 25)
+#define DA8XX_LPSC_SCR_P3_SS     (32 + 26)
+#define DA8XX_LPSC_L3_CBA_RAM   (32 + 31)
+
+#define DA850_LPSC_TPCC1	(32 + 0)
+#define DA850_LPSC_TPTC2	(32 + 21)
+
+#define DA850_LPSC_SATA		(32 + 8)
+extern int davinci_psc_is_clk_active(unsigned int id);
+extern void davinci_psc_config(unsigned int domain, unsigned int id,
+			       char enable);
+
 #endif /* __ASM_ARCH_PSC_H */
diff --git a/arch/arm/mach-davinci/include/mach/serial.h b/arch/arm/mach-davinci/include/mach/serial.h
index fb8cb22..9fb1fcd 100644
--- a/arch/arm/mach-davinci/include/mach/serial.h
+++ b/arch/arm/mach-davinci/include/mach/serial.h
@@ -13,8 +13,20 @@
 
 #include <mach/io.h>
 
-#define DAVINCI_UART0_BASE   (IO_PHYS + 0x20000)
-#define DAVINCI_UART1_BASE   (IO_PHYS + 0x20400)
-#define DAVINCI_UART2_BASE   (IO_PHYS + 0x20800)
+#define DAVINCI_MAX_NR_UARTS	3
+#define DAVINCI_UART0_BASE	(IO_PHYS + 0x20000)
+#define DAVINCI_UART1_BASE	(IO_PHYS + 0x20400)
+#define DAVINCI_UART2_BASE	(IO_PHYS + 0x20800)
+
+#define DM355_UART2_BASE	(IO_PHYS + 0x206000)
+
+#define DA8XX_UART0_BASE     (IO_PHYS + 0x42000)
+#define DA8XX_UART1_BASE     (IO_PHYS + 0x10C000)
+#define DA8XX_UART2_BASE     (IO_PHYS + 0x10D000)
+
+/* DaVinci UART register offsets */
+#define UART_DAVINCI_PWREMU		0x0c
+#define UART_DM646X_SCR			0x10
+#define UART_DM646X_SCR_TX_WATERMARK	0x08
 
 #endif /* __ASM_ARCH_SERIAL_H */
diff --git a/arch/arm/mach-davinci/include/mach/system.h b/arch/arm/mach-davinci/include/mach/system.h
index 84ff77a..77661e0 100644
--- a/arch/arm/mach-davinci/include/mach/system.h
+++ b/arch/arm/mach-davinci/include/mach/system.h
@@ -12,7 +12,6 @@
 #define __ASM_ARCH_SYSTEM_H
 
 #include <asm/io.h>
-#include <mach/hardware.h>
 
 extern void davinci_watchdog_reset(void);
 
diff --git a/arch/arm/mach-davinci/include/mach/uncompress.h b/arch/arm/mach-davinci/include/mach/uncompress.h
index 8c165de..dc148c6 100644
--- a/arch/arm/mach-davinci/include/mach/uncompress.h
+++ b/arch/arm/mach-davinci/include/mach/uncompress.h
@@ -13,11 +13,27 @@
 #include <linux/serial_reg.h>
 #include <mach/serial.h>
 
+static u8 first_time = 1;
+static u32 *uart;
+
+static u32 *get_uart_base(void)
+{
+	/* Add logic here for new platforms */
+#ifdef CONFIG_ARCH_DA8XX
+	return (u32 *)DA8XX_UART2_BASE;
+#else
+	return (u32 *)DAVINCI_UART0_BASE;
+#endif
+}
+
 /* PORT_16C550A, in polled non-fifo mode */
 
 static void putc(char c)
 {
-	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+	if (first_time) {
+		uart = get_uart_base();
+		first_time = 0;
+	}
 
 	while (!(uart[UART_LSR] & UART_LSR_THRE))
 		barrier();
@@ -26,7 +42,11 @@ static void putc(char c)
 
 static inline void flush(void)
 {
-	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+	if (first_time) {
+		uart = get_uart_base();
+		first_time = 0;
+	}
+
 	while (!(uart[UART_LSR] & UART_LSR_THRE))
 		barrier();
 }
diff --git a/arch/arm/mach-davinci/io.c b/arch/arm/mach-davinci/io.c
index 5bb66b6..4be54cd 100644
--- a/arch/arm/mach-davinci/io.c
+++ b/arch/arm/mach-davinci/io.c
@@ -11,13 +11,17 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/io.h>
 
 #include <asm/tlb.h>
-#include <asm/io.h>
 #include <asm/memory.h>
 
 #include <asm/mach/map.h>
 #include <mach/clock.h>
+#include <mach/cpu.h>
+#include <mach/da8xx.h>
+
+#define DA8XX_ARM_INTC_BASE	0xFFFEE000
 
 extern void davinci_check_revision(void);
 
@@ -34,6 +38,15 @@ static struct map_desc davinci_io_desc[] __initdata = {
 	},
 };
 
+static struct map_desc da8xx_intc_desc[] __initdata = {
+	{
+		.virtual	= IO_Dx_INTC_VIRT,
+		.pfn		= __phys_to_pfn(DA8XX_ARM_INTC_BASE),
+		.length		= IO_Dx_INTC_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
 void __init davinci_map_common_io(void)
 {
 	iotable_init(davinci_io_desc, ARRAY_SIZE(davinci_io_desc));
@@ -49,9 +62,36 @@ void __init davinci_map_common_io(void)
 	 * IO space mapping must be initialized before we can do that.
 	 */
 	davinci_check_revision();
+
+	/*
+	 * Map the interrupt controller to a common address across all
+	 * SoCs.  Other SoC specific mapping can go here as well.
+	 */
+	if (cpu_is_da8xx())
+		iotable_init(da8xx_intc_desc,
+				ARRAY_SIZE(da8xx_intc_desc));
 }
 
-void __init davinci_init_common_hw(void)
+#define BETWEEN(p, st, sz)	((p) >= (st) && (p) < ((st) + (sz)))
+#define XLATE(p, pst, vst)	((void __iomem *)((p) - (pst) + (vst)))
+
+/*
+ * Intercept ioremap() requests for addresses in our fixed mapping regions.
+ */
+void __iomem *davinci_ioremap(unsigned long p, size_t size, unsigned int type)
+{
+	if (BETWEEN(p, IO_PHYS, IO_SIZE))
+		return XLATE(p, IO_PHYS, IO_VIRT);
+
+	return __arm_ioremap(p, size, type);
+}
+EXPORT_SYMBOL(davinci_ioremap);
+
+void davinci_iounmap(volatile void __iomem *addr)
 {
-	davinci_clk_init();
+	unsigned long virt = (unsigned long)addr;
+
+	if (virt >= VMALLOC_START && virt < VMALLOC_END)
+		__iounmap(addr);
 }
+EXPORT_SYMBOL(davinci_iounmap);
diff --git a/arch/arm/mach-davinci/psc.c b/arch/arm/mach-davinci/psc.c
index aa2fc37..1c9e353 100644
--- a/arch/arm/mach-davinci/psc.c
+++ b/arch/arm/mach-davinci/psc.c
@@ -21,12 +21,17 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
-#include <mach/hardware.h>
+#include <mach/cpu.h>
+#include <mach/da8xx.h>
 #include <mach/psc.h>
 #include <mach/mux.h>
 
+#define DAVINCI_PWR_SLEEP_CNTRL_BASE	0x01C41000
+#define DA8XX_PSC0_BASE		0x01C10000
+#define DA8XX_PSC1_BASE		0x01E27000
+
 /* PSC register offsets */
 #define EPCPR		0x070
 #define PTCMD		0x120
@@ -35,103 +40,87 @@
 #define PDCTL1		0x304
 #define MDSTAT		0x800
 #define MDCTL		0xA00
+#define MDSTAT_STATE_MASK 0x1f
 
-/* System control register offsets */
-#define VDD3P3V_PWDN	0x48
+static u32 davinci_psc_base[] = { (u32)IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE) };
+static u32 da8xx_psc_base[] = { (u32)IO_ADDRESS(DA8XX_PSC0_BASE),
+				   (u32)IO_ADDRESS(DA8XX_PSC1_BASE) };
+static u32 *psc_base_array;
 
-static void davinci_psc_mux(unsigned int id)
+/* Return nonzero iff the domain's clock is active */
+int __init davinci_psc_is_clk_active(unsigned int id)
 {
-	switch (id) {
-	case DAVINCI_LPSC_ATA:
-		davinci_mux_peripheral(DAVINCI_MUX_HDIREN, 1);
-		davinci_mux_peripheral(DAVINCI_MUX_ATAEN, 1);
-		break;
-	case DAVINCI_LPSC_MMC_SD:
-		/* VDD power manupulations are done in U-Boot for CPMAC
-		 * so applies to MMC as well
-		 */
-		/*Set up the pull regiter for MMC */
-		davinci_writel(0, DAVINCI_SYSTEM_MODULE_BASE + VDD3P3V_PWDN);
-		davinci_mux_peripheral(DAVINCI_MUX_MSTK, 0);
-		break;
-	case DAVINCI_LPSC_I2C:
-		davinci_mux_peripheral(DAVINCI_MUX_I2C, 1);
-		break;
-	case DAVINCI_LPSC_McBSP:
-		davinci_mux_peripheral(DAVINCI_MUX_ASP, 1);
-		break;
-	default:
-		break;
-	}
+	void __iomem *psc_base = IO_ADDRESS(DAVINCI_PWR_SLEEP_CNTRL_BASE);
+	u32 mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+
+	/* if clocked, state can be "Enable" or "SyncReset" */
+	return mdstat & BIT(12);
 }
 
 /* Enable or disable a PSC domain */
 void davinci_psc_config(unsigned int domain, unsigned int id, char enable)
 {
-	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl, mdstat_mask;
+	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl;
+	u32 next_state = enable ? 0x3 : 0x2; /* 0x3 enables, 0x2 disables */
+	void __iomem *psc_base;
+	u32 domain_shift;
+
+	if (id > 64)
+		return;
 
-	mdctl = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + MDCTL + 4 * id);
-	if (enable)
-		mdctl |= 0x00000003;	/* Enable Module */
+	if (cpu_is_da8xx())
+		psc_base_array = da8xx_psc_base;
 	else
-		mdctl &= 0xFFFFFFF2;	/* Disable Module */
-	davinci_writel(mdctl, DAVINCI_PWR_SLEEP_CNTRL_BASE + MDCTL + 4 * id);
+		psc_base_array = davinci_psc_base;
+
+	if (cpu_is_da8xx() && id >= 32) {
+		id -= 32;
+		domain = 1;
+	}
+
+	psc_base = (void __iomem *)(psc_base_array[domain]);
+	/* XXX domain != which psc reg to use--we always use domain 0 */
+	domain_shift = 0;
+
+	mdctl = __raw_readl(psc_base + MDCTL + 4 * id);
+	mdctl &= ~MDSTAT_STATE_MASK;
+	mdctl |= next_state;
+	/* For SATA force the domain turn on */
+	if (cpu_is_da850() && (id == 8) && (domain == 1))
+		mdctl |= 0x80000000;
+	__raw_writel(mdctl, psc_base + MDCTL + 4 * id);
 
-	pdstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDSTAT);
+	pdstat = __raw_readl(psc_base + PDSTAT);
 	if ((pdstat & 0x00000001) == 0) {
-		pdctl1 = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		pdctl1 = __raw_readl(psc_base + PDCTL1);
 		pdctl1 |= 0x1;
-		davinci_writel(pdctl1, DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		__raw_writel(pdctl1, psc_base + PDCTL1);
 
-		ptcmd = 1 << domain;
-		davinci_writel(ptcmd, DAVINCI_PWR_SLEEP_CNTRL_BASE + PTCMD);
+		ptcmd = 1 << domain_shift;
+		__raw_writel(ptcmd, psc_base + PTCMD);
 
 		do {
-			epcpr = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-					      EPCPR);
-		} while ((((epcpr >> domain) & 1) == 0));
+			epcpr = __raw_readl(psc_base + EPCPR);
+		} while ((((epcpr >> domain_shift) & 1) == 0));
 
-		pdctl1 = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		pdctl1 = __raw_readl(psc_base + PDCTL1);
 		pdctl1 |= 0x100;
-		davinci_writel(pdctl1, DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		__raw_writel(pdctl1, psc_base + PDCTL1);
 
 		do {
-			ptstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
+			ptstat = __raw_readl(psc_base +
 					       PTSTAT);
-		} while (!(((ptstat >> domain) & 1) == 0));
+		} while (!(((ptstat >> domain_shift) & 1) == 0));
 	} else {
-		ptcmd = 1 << domain;
-		davinci_writel(ptcmd, DAVINCI_PWR_SLEEP_CNTRL_BASE + PTCMD);
+		ptcmd = 1 << domain_shift;
+		__raw_writel(ptcmd, psc_base + PTCMD);
 
 		do {
-			ptstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-					       PTSTAT);
-		} while (!(((ptstat >> domain) & 1) == 0));
+			ptstat = __raw_readl(psc_base + PTSTAT);
+		} while (!(((ptstat >> domain_shift) & 1) == 0));
 	}
 
-	if (enable)
-		mdstat_mask = 0x3;
-	else
-		mdstat_mask = 0x2;
-
 	do {
-		mdstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-				       MDSTAT + 4 * id);
-	} while (!((mdstat & 0x0000001F) == mdstat_mask));
-
-	if (enable)
-		davinci_psc_mux(id);
-}
-
-void __init davinci_psc_init(void)
-{
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSMSTR, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSSLV, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPCC, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC0, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC1, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_GPIO, 1);
-
-	/* Turn on WatchDog timer LPSC.	 Needed for RESET to work */
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
+		mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state));
 }
diff --git a/arch/arm/mach-davinci/time.c b/arch/arm/mach-davinci/time.c
index 206e80d..752293b 100644
--- a/arch/arm/mach-davinci/time.c
+++ b/arch/arm/mach-davinci/time.c
@@ -15,21 +15,29 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/device.h>
 
-#include <asm/io.h>
-#include <mach/hardware.h>
+#include <mach/da8xx.h>
 #include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 #include <asm/errno.h>
 #include <mach/io.h>
+#include <mach/cpu.h>
+#include "clock.h"
 
 static struct clock_event_device clockevent_davinci;
+static unsigned int davinci_clock_tick_rate;
 
 #define DAVINCI_TIMER0_BASE (IO_PHYS + 0x21400)
 #define DAVINCI_TIMER1_BASE (IO_PHYS + 0x21800)
 #define DAVINCI_WDOG_BASE   (IO_PHYS + 0x21C00)
+#define DA8XX_TIMER64P0_BASE		0x01C20000
+#define DA8XX_TIMER64P1_BASE		0x01C21000
 
 enum {
 	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, NUM_TIMERS,
@@ -40,13 +48,28 @@ enum {
 #define IS_TIMER_TOP(id) ((id & 0x1))
 #define IS_TIMER_BOT(id) (!IS_TIMER_TOP(id))
 
-static int timer_irqs[NUM_TIMERS] = {
+static int default_timer_irqs[NUM_TIMERS] = {
 	IRQ_TINT0_TINT12,
 	IRQ_TINT0_TINT34,
 	IRQ_TINT1_TINT12,
 	IRQ_TINT1_TINT34,
 };
 
+static int da8xx_timer_irqs[NUM_TIMERS] = {
+	IRQ_DA8XX_TINT12_0,
+	IRQ_DA8XX_TINT34_0,
+	IRQ_DA8XX_TINT12_1,
+	IRQ_DA8XX_TINT34_1
+};
+
+/* Compare registers are only available to the bottom timer 0 */
+static  int da830_cmp_irqs[NUM_TIMERS] = {
+	IRQ_DA830_T12CMPINT0_0,
+};
+
+static int tid_system;
+static int tid_freerun;
+
 /*
  * This driver configures the 2 64-bit count-up timers as 4 independent
  * 32-bit count-up timers used as follows:
@@ -68,6 +91,7 @@ static int timer_irqs[NUM_TIMERS] = {
 #define TCR                          0x20
 #define TGCR                         0x24
 #define WDTCR                        0x28
+#define CMP12(n)		     (0x60 + ((n) << 2))
 
 /* Timer register bitfields */
 #define TCR_ENAMODE_DISABLE          0x0
@@ -99,13 +123,14 @@ struct timer_s {
 	unsigned int id;
 	unsigned long period;
 	unsigned long opts;
-	unsigned long reg_base;
-	unsigned long tim_reg;
-	unsigned long prd_reg;
+	void __iomem *base;
+	unsigned long tim_off;
+	unsigned long prd_off;
+	unsigned long cmp_off;
 	unsigned long enamode_shift;
 	struct irqaction irqaction;
+	struct irqaction cmpaction;
 };
-static struct timer_s timers[];
 
 /* values for 'opts' field of struct timer_s */
 #define TIMER_OPTS_DISABLED   0x00
@@ -114,15 +139,17 @@ static struct timer_s timers[];
 
 static int timer32_config(struct timer_s *t)
 {
-	u32 tcr = davinci_readl(t->reg_base + TCR);
+	u32 tcr = __raw_readl(t->base + TCR);
 
 	/* disable timer */
 	tcr &= ~(TCR_ENAMODE_MASK << t->enamode_shift);
-	davinci_writel(tcr, t->reg_base + TCR);
+	__raw_writel(tcr, t->base + TCR);
 
 	/* reset counter to zero, set new period */
-	davinci_writel(0, t->tim_reg);
-	davinci_writel(t->period, t->prd_reg);
+	__raw_writel(0, t->base + t->tim_off);
+	__raw_writel(t->period, t->base + t->prd_off);
+	if (t->cmp_off)
+		__raw_writel(t->period, t->base + t->cmp_off);
 
 	/* Set enable mode */
 	if (t->opts & TIMER_OPTS_ONESHOT) {
@@ -131,13 +158,13 @@ static int timer32_config(struct timer_s *t)
 		tcr |= TCR_ENAMODE_PERIODIC << t->enamode_shift;
 	}
 
-	davinci_writel(tcr, t->reg_base + TCR);
+	__raw_writel(tcr, t->base + TCR);
 	return 0;
 }
 
 static inline u32 timer32_read(struct timer_s *t)
 {
-	return davinci_readl(t->tim_reg);
+	return __raw_readl(t->base + t->tim_off);
 }
 
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
@@ -154,73 +181,115 @@ static irqreturn_t freerun_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static struct timer_s timers[] = {
-	[TID_CLOCKEVENT] = {
-		.name      = "clockevent",
-		.opts      = TIMER_OPTS_DISABLED,
-		.irqaction = {
-			.flags   = IRQF_DISABLED | IRQF_TIMER,
-			.handler = timer_interrupt,
-		}
-	},
-	[TID_CLOCKSOURCE] = {
-		.name       = "free-run counter",
-		.period     = ~0,
-		.opts       = TIMER_OPTS_PERIODIC,
-		.irqaction = {
-			.flags   = IRQF_DISABLED | IRQF_TIMER,
-			.handler = freerun_interrupt,
-		}
+static irqreturn_t cmp_interrupt(int irq, void *dev_id)
+{
+	struct timer_s *t = dev_id;
+	struct clock_event_device *evt = &clockevent_davinci;
+
+	/* We have to emulate the periodic mode for the clockevents layer */
+	if (t->opts & TIMER_OPTS_PERIODIC) {
+		unsigned long tim, cmp = __raw_readl(t->base + t->cmp_off);
+
+		cmp += t->period;
+		__raw_writel(cmp, t->base + t->cmp_off);
+
+		/*
+		 * The interrupts do happen  to be disabled by the kernel for
+		 * a long periods of time, thus the timer can go far ahead of
+		 * the last set compare value...
+		 */
+		tim = __raw_readl(t->base + t->tim_off);
+		if (time_after(tim, cmp))
+			__raw_writel(tim + t->period, t->base + t->cmp_off);
+	}
+
+	clockevent_davinci.event_handler(evt);
+	return IRQ_HANDLED;
+}
+
+static struct timer_s davinci_system_timer = {
+	.name      = "clockevent",
+	.opts      = TIMER_OPTS_DISABLED,
+	.irqaction = {
+		.flags   = IRQF_DISABLED | IRQF_TIMER,
+		.handler = timer_interrupt,
+	}
+};
+
+static struct timer_s davinci_freerun_timer = {
+	.name       = "free-run counter",
+	.period     = ~0,
+	.opts       = TIMER_OPTS_PERIODIC,
+	.irqaction = {
+		.flags   = IRQF_DISABLED | IRQF_TIMER,
+		.handler = freerun_interrupt,
 	},
+	.cmpaction = {
+		.name		= "timer compare reg 0",
+		.flags		= IRQF_DISABLED | IRQF_TIMER,
+		.handler	= cmp_interrupt,
+	}
 };
 
-static void __init timer_init(void)
+static struct timer_s *timers[NUM_TIMERS];
+
+static void __init timer_init(int num_timers, u32 *phys_bases,
+			      int *timer_irqs, int *cmp_irqs)
 {
-	u32 bases[] = {DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE};
 	int i;
 
 	/* Global init of each 64-bit timer as a whole */
-	for(i=0; i<2; i++) {
-		u32 tgcr, base = bases[i];
+	for (i = 0; i < num_timers; i++) {
+		u32 tgcr;
+		void __iomem *base = IO_ADDRESS(phys_bases[i]);
 
 		/* Disabled, Internal clock source */
-		davinci_writel(0, base + TCR);
+		__raw_writel(0, base + TCR);
 
 		/* reset both timers, no pre-scaler for timer34 */
 		tgcr = 0;
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Set both timers to unchained 32-bit */
 		tgcr = TGCR_TIMMODE_32BIT_UNCHAINED << TGCR_TIMMODE_SHIFT;
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Unreset timers */
 		tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
 			(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Init both counters to zero */
-		davinci_writel(0, base + TIM12);
-		davinci_writel(0, base + TIM34);
+		__raw_writel(0, base + TIM12);
+		__raw_writel(0, base + TIM34);
 	}
 
 	/* Init of each timer as a 32-bit timer */
-	for (i=0; i< ARRAY_SIZE(timers); i++) {
-		struct timer_s *t = &timers[i];
+	for (i = 0; i < NUM_TIMERS; i++) {
+		struct timer_s *t = timers[i];
+		u32 phys_base;
 
-		if (t->name) {
+		if (t && t->name) {
 			t->id = i;
-			t->reg_base = (IS_TIMER1(t->id) ?
-			       DAVINCI_TIMER1_BASE : DAVINCI_TIMER0_BASE);
+			phys_base = phys_bases[i >> 1];
+			t->base = IO_ADDRESS(phys_base);
 
 			if (IS_TIMER_BOT(t->id)) {
 				t->enamode_shift = 6;
-				t->tim_reg = t->reg_base + TIM12;
-				t->prd_reg = t->reg_base + PRD12;
+				t->tim_off = TIM12;
+				t->prd_off = PRD12;
+				/* Check the compare register IRQ */
+				if (t->cmpaction.handler != NULL &&
+				    cmp_irqs != NULL && cmp_irqs[t->id]) {
+					t->cmp_off = CMP12(0);
+					t->cmpaction.dev_id = (void *)t;
+					setup_irq(cmp_irqs[t->id],
+						  &t->cmpaction);
+				}
 			} else {
 				t->enamode_shift = 22;
-				t->tim_reg = t->reg_base + TIM34;
-				t->prd_reg = t->reg_base + PRD34;
+				t->tim_off = TIM34;
+				t->prd_off = PRD34;
 			}
 
 			/* Register interrupt */
@@ -230,7 +299,7 @@ static void __init timer_init(void)
 				setup_irq(timer_irqs[t->id], &t->irqaction);
 			}
 
-			timer32_config(&timers[i]);
+			timer32_config(timers[i]);
 		}
 	}
 }
@@ -240,7 +309,12 @@ static void __init timer_init(void)
  */
 static cycle_t read_cycles(void)
 {
-	struct timer_s *t = &timers[TID_CLOCKSOURCE];
+	struct timer_s *t;
+
+	if (tid_freerun == -1)
+		t = timers[tid_system];
+	else
+		t = timers[tid_freerun];
 
 	return (cycles_t)timer32_read(t);
 }
@@ -260,23 +334,37 @@ static struct clocksource clocksource_davinci = {
 static int davinci_set_next_event(unsigned long cycles,
 				  struct clock_event_device *evt)
 {
-	struct timer_s *t = &timers[TID_CLOCKEVENT];
+	struct timer_s *t = timers[tid_system];
 
 	t->period = cycles;
-	timer32_config(t);
+
+	/*
+	 * We need not (and must not) disable the timer and reprogram
+	 * its mode/period when using the compare register...
+	 */
+	if (t->cmp_off)
+		__raw_writel(__raw_readl(t->base + t->tim_off) + cycles,
+			     t->base + t->cmp_off);
+	else
+		timer32_config(t);
 	return 0;
 }
 
 static void davinci_set_mode(enum clock_event_mode mode,
 			     struct clock_event_device *evt)
 {
-	struct timer_s *t = &timers[TID_CLOCKEVENT];
+	struct timer_s *t = timers[tid_system];
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		t->period = CLOCK_TICK_RATE / (HZ);
+		t->period = davinci_clock_tick_rate / (HZ);
 		t->opts = TIMER_OPTS_PERIODIC;
-		timer32_config(t);
+
+		if (t->cmp_off)
+			davinci_set_next_event(davinci_clock_tick_rate / HZ,
+						evt);
+		else
+			timer32_config(t);
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
 		t->opts = TIMER_OPTS_ONESHOT;
@@ -298,24 +386,101 @@ static struct clock_event_device clockevent_davinci = {
 	.set_mode	= davinci_set_mode,
 };
 
+static u32 davinci_bases[] = { DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE };
+static u32 da8xx_bases[] = { DA8XX_TIMER64P0_BASE, DA8XX_TIMER64P1_BASE };
 
 static void __init davinci_timer_init(void)
 {
+	int num_timers;
+	int *timer_irqs = NULL, *cmp_irqs = NULL;
+	u32 *bases;
+	struct clk *timer_clk;
+
 	static char err[] __initdata = KERN_ERR
 		"%s: can't register clocksource!\n";
 
+	timer_clk = clk_get(NULL, "timer0");
+	BUG_ON(IS_ERR(timer_clk));
+	clk_enable(timer_clk);
+
+	num_timers = 2;
+	bases = davinci_bases;
+	timer_irqs = default_timer_irqs;
+	/*
+	 * DA850 does not support compare IRQs for bottom two timers.
+	 * It has 4 timers, so assume using compare registers is not
+	 * really a necessity.
+	 */
+	if (cpu_is_da830())
+		cmp_irqs = da830_cmp_irqs;
+
+	if (cpu_is_da8xx()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom: free run counter and system clock.
+		 * T0_TOP: Timer 0, top:  Reserve for DSP
+		 * T1_BOT: Timer 1, watch dog timer.
+		 */
+		tid_system = T0_BOT;
+		bases = da8xx_bases;
+		timer_irqs = da8xx_timer_irqs;
+
+		/* timer interrupt using compare reg so free-run not needed */
+		if (cmp_irqs != NULL)
+			tid_freerun = T0_BOT;
+		else
+			tid_freerun = T0_TOP;
+
+	} else if (cpu_is_davinci_dm646x()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom:  AV Sync
+		 * T0_TOP: Timer 0, top:  free-running counter,
+		 *                        used for cycle counter
+		 * T1_BOT: Timer 1, bottom:  reserved for DSP
+		 * T1_TOP: Timer 1, top   :  Linux system tick
+		 */
+		tid_system = T1_TOP;
+		tid_freerun = T0_TOP;
+	} else if (cpu_is_davinci_dm644x()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
+		 * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
+		 * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
+		 * T1_TOP: Timer 1, top   :  <unused>
+		 */
+		tid_system = T0_BOT;
+		tid_freerun = T0_TOP;
+	}
+
+	if (tid_system != -1)
+		timers[tid_system] = &davinci_system_timer;
+
+	if (tid_freerun != -1)
+		timers[tid_freerun] = &davinci_freerun_timer;
+
 	/* init timer hw */
-	timer_init();
+	timer_init(num_timers, bases, timer_irqs, cmp_irqs);
+
+	davinci_clock_tick_rate = clk_get_rate(timer_clk);
+	clk_put(timer_clk);
 
 	/* setup clocksource */
 	clocksource_davinci.mult =
-		clocksource_khz2mult(CLOCK_TICK_RATE/1000,
+		clocksource_khz2mult(davinci_clock_tick_rate/1000,
 				     clocksource_davinci.shift);
 	if (clocksource_register(&clocksource_davinci))
 		printk(err, clocksource_davinci.name);
 
 	/* setup clockevent */
-	clockevent_davinci.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC,
+	clockevent_davinci.mult = div_sc(davinci_clock_tick_rate, NSEC_PER_SEC,
 					 clockevent_davinci.shift);
 	clockevent_davinci.max_delta_ns =
 		clockevent_delta2ns(0xfffffffe, &clockevent_davinci);
@@ -333,42 +498,54 @@ struct sys_timer davinci_timer = {
 
 /* reset board using watchdog timer */
 void davinci_watchdog_reset(void) {
-	u32 tgcr, wdtcr, base = DAVINCI_WDOG_BASE;
+	u32 tgcr, wdtcr;
+	void __iomem *base = IO_ADDRESS(DAVINCI_WDOG_BASE);
+	struct device dev;
+	struct clk *wd_clk;
+
+	dev_set_name(&dev, "watchdog");
+	wd_clk = clk_get(&dev, NULL);
+	if (WARN_ON(IS_ERR(wd_clk)))
+		return;
+	clk_enable(wd_clk);
+
+	if (cpu_is_da8xx())
+		base = IO_ADDRESS(DA8XX_TIMER64P1_BASE);
 
 	/* disable, internal clock source */
-	davinci_writel(0, base + TCR);
+	__raw_writel(0, base + TCR);
 
 	/* reset timer, set mode to 64-bit watchdog, and unreset */
 	tgcr = 0;
-	davinci_writel(tgcr, base + TCR);
+	__raw_writel(tgcr, base + TGCR);
 	tgcr = TGCR_TIMMODE_64BIT_WDOG << TGCR_TIMMODE_SHIFT;
 	tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
 		(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
-	davinci_writel(tgcr, base + TCR);
+	__raw_writel(tgcr, base + TGCR);
 
 	/* clear counter and period regs */
-	davinci_writel(0, base + TIM12);
-	davinci_writel(0, base + TIM34);
-	davinci_writel(0, base + PRD12);
-	davinci_writel(0, base + PRD34);
+	__raw_writel(0, base + TIM12);
+	__raw_writel(0, base + TIM34);
+	__raw_writel(0, base + PRD12);
+	__raw_writel(0, base + PRD34);
 
 	/* enable */
-	wdtcr = davinci_readl(base + WDTCR);
+	wdtcr = __raw_readl(base + WDTCR);
 	wdtcr |= WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT;
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 
 	/* put watchdog in pre-active state */
 	wdtcr = (WDTCR_WDKEY_SEQ0 << WDTCR_WDKEY_SHIFT) |
 		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 
 	/* put watchdog in active state */
 	wdtcr = (WDTCR_WDKEY_SEQ1 << WDTCR_WDKEY_SHIFT) |
 		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 
 	/* write an invalid value to the WDKEY field to trigger
 	 * a watchdog reset */
 	wdtcr = 0x00004000;
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 }
-- 
1.6.5.2

