From c1dbfedca3b5cdd60ebd555ef591063899faaa99 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 8 Sep 2010 08:24:58 -0700
Subject: [PATCH] nlm_xls_atx_64_be: Fix the atomic operations

Based on the ldaddw instruction, xls has added its own specific
atomic_add/sub* operations, but the exact implementations of them are
not atomic, which may be interrupted and introduces weird problems. one
of such problems have been found is that: the lttng testcase may fail
with the following errors:

lttctl: Creating trace
INFO: RCU detected CPU stalls: 11 (detected by 4, t=2503 jiffies)
INFO: RCU detected CPU stalls: 11 (detected by 4, t=10005 jiffies)
INFO: RCU detected CPU stalls: 11 (detected by 4, t=17507 jiffies)
BUG: soft lockup - CPU#8 stuck for 61s! [init:1]
Modules linked in: x_tables ip_tables libcrc32c crc32c ipv6 sctp binfmt_misc ltt_statedump pm_trace block_trace net_extended_trace fs_trace kernel_trace lockdep_trace net_trace ltt_filter jbd2_trace rcu_
Cpu 8
$ 0   : 0000000000000000 000000001000dce0 0000000000010000 000000000000e27b
$ 4   : 0000000000000054 0000000000000101 0000000000000040 0000000000000000
$ 8   : a800000081fdae70 ffffffff83bae6f8 000000000000000e 0000000000000000
$12   : 0000000000000018 ffffffff83405210 ffffffff83587308 0000000000420000
$16   : a80000008dafbcc0 a80000008dbdb560 a80000008dafb800 a80000008dafbcc0
$20   : fffffffffffffe00 0000000000010000 ffffffff839e9ae0 ffffffff839e9b08
$24   : 0000000000418278 000000002ac21d50
$28   : a80000008e848000 a80000008e84b920 ffffffff838cdff0 ffffffff8340e984
Hi    : 0000000001ccb06e
Lo    : 147ae147b0378c64
epc   : ffffffff8340ecf0 _raw_spin_trylock+0x158/0x1f0
Tainted: G        W
ra    : ffffffff8340e984 _raw_spin_lock_bh+0x1c/0x58
Status: 1000dce3    KX SX UX KERNEL EXL IE
Cause : 00808000
PrId  : 000c4402 (XLS416 Rev B0)
INFO: RCU detected CPU stalls: 11 (detected by 4, t=25009 jiffies)
BUG: soft lockup - CPU#13 stuck for 61s! [sendmail:639]

We may possibly protect the operations with irq disabled, but after a
few of tests, it is also not stable. so, at last, this patch fixes it
via falling back to the stable ll/sc implementation.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/atomic.h |   22 ----------------------
 1 files changed, 0 insertions(+), 22 deletions(-)

diff --git a/arch/mips/include/asm/atomic.h b/arch/mips/include/asm/atomic.h
index 18b1739..850a65d 100644
--- a/arch/mips/include/asm/atomic.h
+++ b/arch/mips/include/asm/atomic.h
@@ -21,10 +21,6 @@
 #include <asm/war.h>
 #include <asm/system.h>
 
-#ifdef CONFIG_RMI_PHOENIX
-#include <asm/rmi/mips-exts.h>
-#endif
-
 #define ATOMIC_INIT(i)    { (i) }
 
 /*
@@ -66,9 +62,6 @@
  */
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
-#ifdef CONFIG_RMI_PHOENIX
-	ldadd_w_no_read(i, &v->counter);
-#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -103,7 +96,6 @@ static __inline__ void atomic_add(int i, atomic_t * v)
 		v->counter += i;
 		raw_local_irq_restore(flags);
 	}
-#endif
 }
 
 /*
@@ -115,9 +107,6 @@ static __inline__ void atomic_add(int i, atomic_t * v)
  */
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
-#ifdef CONFIG_RMI_PHOENIX
-	ldadd_w_no_read(-i,&v->counter);
-#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -152,7 +141,6 @@ static __inline__ void atomic_sub(int i, atomic_t * v)
 		v->counter -= i;
 		raw_local_irq_restore(flags);
 	}
-#endif
 }
 
 /*
@@ -164,10 +152,6 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
-#ifdef CONFIG_RMI_PHOENIX
-	result = ldadd_w(i, &v->counter);
-	result += i;
-#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -208,7 +192,6 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 		v->counter = result;
 		raw_local_irq_restore(flags);
 	}
-#endif
 
 	smp_llsc_mb();
 
@@ -221,10 +204,6 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
-#ifdef CONFIG_RMI_PHOENIX
-	result = ldadd_w(-i, &v->counter);
-	result -= i;
-#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -265,7 +244,6 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 		v->counter = result;
 		raw_local_irq_restore(flags);
 	}
-#endif
 
 	smp_llsc_mb();
 
-- 
1.6.5.2

