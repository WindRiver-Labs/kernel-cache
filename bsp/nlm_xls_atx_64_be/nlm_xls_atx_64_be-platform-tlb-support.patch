From 50ff7f0bce63679ef33a8e6c2432c0e2276a36b3 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 19 May 2010 23:57:28 +0800
Subject: [PATCH] nlm_xls_atx_64_be: platform tlb support

Add XLS's TLB refill, TLB load, TLB store and TLB modify handler support.

XLS TLB's coherency attribute bit has a little diffrence so add its private
defination.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/pgtable-bits.h |    6 ++++++
 arch/mips/lib/Makefile               |    1 +
 arch/mips/mm/tlb-r4k.c               |   25 +++++++++++++++++++++++++
 arch/mips/mm/tlbex.c                 |   24 ++++++++++++++++++++++++
 4 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/arch/mips/include/asm/pgtable-bits.h b/arch/mips/include/asm/pgtable-bits.h
index e9fe7e9..cccecd0 100644
--- a/arch/mips/include/asm/pgtable-bits.h
+++ b/arch/mips/include/asm/pgtable-bits.h
@@ -192,6 +192,12 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 #define _CACHE_CACHABLE_NONCOHERENT (5<<_CACHE_SHIFT)
 #define _CACHE_UNCACHED_ACCELERATED (7<<_CACHE_SHIFT)
 
+#elif defined(CONFIG_CPU_PHOENIX)
+
+#define _CACHE_UNCACHED             (2<<9)
+#define _CACHE_CACHABLE_COW         (3<<9)
+#define _CACHE_CACHABLE_NONCOHERENT (3<<9)
+
 #elif defined(CONFIG_CPU_RM9000)
 
 #define _CACHE_WT		    (0<<_CACHE_SHIFT)
diff --git a/arch/mips/lib/Makefile b/arch/mips/lib/Makefile
index 2adead5..1f980ed 100644
--- a/arch/mips/lib/Makefile
+++ b/arch/mips/lib/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
 obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= dump_tlb.o
+obj-$(CONFIG_CPU_PHOENIX)	+= dump_tlb.o
 
 # libgcc-style stuff needed in the kernel
 obj-y += ashldi3.o ashrdi3.o cmpdi2.o lshrdi3.o ucmpdi2.o
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 78a76c1..c2db877 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -22,6 +22,9 @@
 #ifdef CONFIG_WRHV
 #include <vbi/vbi.h>
 #endif
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/mips-exts.h>
+#endif
 
 extern void build_tlb_refill_handler(void);
 
@@ -442,6 +445,24 @@ __setup("ntlb=", set_ntlb);
 void paravirt_tlb_init(void)
 	__attribute__((weak, alias("native_tlb_init")));
 
+#ifdef CONFIG_RMI_PHOENIX
+extern void phoenix_tlb_init(void);
+
+void rmi_tlb_stats_init(void)
+{
+	rmi_write_os_scratch_2(0ULL);
+}
+
+/* This is called from smp_call_function (IPI) context */
+extern unsigned long long phnx_tlb_stats[];
+void rmi_update_tlb_stats(void *ignored)
+{
+	int cpu = smp_processor_id();
+
+	phnx_tlb_stats[cpu] = rmi_read_os_scratch_2();
+}
+#endif
+
 void __cpuinit native_tlb_init(void)
 {
 	/*
@@ -487,9 +508,13 @@ void __cpuinit native_tlb_init(void)
 			printk("Ignoring invalid argument ntlb=%d\n", ntlb);
 	}
 
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_tlb_stats_init();
+#endif
 	build_tlb_refill_handler();
 }
 
+
 void __cpuinit tlb_init(void)
 {
 	paravirt_tlb_init();
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 93355b3..a9d3707 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -33,6 +33,9 @@
 #ifdef CONFIG_WRHV
 #include <asm/mmu_context.h>
 #endif
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/mips-exts.h>
+#endif
 
 /*
  * TLB load/store/modify handlers.
@@ -66,6 +69,10 @@ static inline int __maybe_unused r10000_llsc_war(void)
 	return R10000_LLSC_WAR;
 }
 
+static inline int __maybe_unused rmi_xls_war(void)
+{
+	return RMI_XLS_WAR;
+}
 /*
  * Found by experiment: At least some revisions of the 4kc throw under
  * some circumstances a machine check exception, triggered by invalid
@@ -360,6 +367,7 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 		tlbw(p);
 		break;
 
+	case CPU_PHOENIX:
 	case CPU_NEVADA:
 		uasm_i_nop(p); /* QED specifies 2 nops hazard */
 		/*
@@ -876,6 +884,12 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 		/* No need for uasm_i_nop */
 	}
 
+	if (rmi_xls_war()){
+		uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
+		uasm_i_daddiu(&p, K0, K0, 1);
+		uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
+	}
+
 #ifdef CONFIG_64BIT
 	build_get_pmde64(&p, &l, &r, K0, K1); /* get pmd in K1 */
 #else
@@ -890,6 +904,16 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	build_update_entries(&p, K0, K1);
 	build_tlb_write_entry(&p, &l, &r, tlb_random);
 	uasm_l_leave(&l, p);
+
+	if (rmi_xls_war()){
+	/* this is to avoid split of the table at eret instruction
+	   The code below does a split at 30th instruction.
+	   */
+		if ((p - tlb_handler) == 30){
+			uasm_i_nop(&p);
+		}
+	}
+
 	uasm_i_eret(&p); /* return from trap */
 
 #ifdef CONFIG_HUGETLB_PAGE
-- 
1.6.5.2

