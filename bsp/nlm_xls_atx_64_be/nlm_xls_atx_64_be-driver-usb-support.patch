From fa6b4f880469713749a09b162c8449c46b564dc5 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 27/38] nlm_xls_atx_64_be: driver usb support

USB 2.0 host support which is specific to rmi's on-chip usb host.

This patch is from RMI SDK 1.7.0

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/usb/core/usb.c      |   21 +++++
 drivers/usb/host/ehci-hcd.c |   28 +++++++
 drivers/usb/host/ehci-xls.c |  187 +++++++++++++++++++++++++++++++++++++++++++
 drivers/usb/host/ohci-hcd.c |   16 ++++
 drivers/usb/host/ohci-xls.c |  185 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 437 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/host/ehci-xls.c
 create mode 100644 drivers/usb/host/ohci-xls.c

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0561430..99d39d0 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -44,6 +44,10 @@
 #include "hcd.h"
 #include "usb.h"
 
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+extern int avail_mem_above_4G;
+#endif
+
 
 const char *usbcore_name = "usbcore";
 
@@ -1074,12 +1078,29 @@ static void usb_debugfs_cleanup(void)
 	debugfs_remove(usb_debug_root);
 }
 
+#ifdef CONFIG_RMI_PHOENIX
+extern int force_usb;
+#endif
+
 /*
  * Init
  */
 static int __init usb_init(void)
 {
 	int retval;
+
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+	if (avail_mem_above_4G && !force_usb) {
+		printk("------------------------------------------------\n");
+		printk("[USB]: Running 64-bit Linux with DRAM above 4G. \n");
+		printk("     : HW Support for DMA >32-bit Un-available. \n");
+		printk("     : Disabling USB, to force enable, use      \n");
+		printk("     : cmdline option 'forceusb'\n");
+		printk("------------------------------------------------\n");
+		nousb=1;
+	}
+#endif
+
 	if (nousb) {
 		pr_info("%s: USB support disabled\n", usbcore_name);
 		return 0;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 13ead00..af6d7a9 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,3 +1,14 @@
+/************************************************************************
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: Added support hooks for RMI XLS USB Controller
+
+ *****************************#RMI_1#************************************/
+
 /*
  * Copyright (c) 2000-2004 by David Brownell
  *
@@ -44,6 +55,10 @@
 #include <asm/system.h>
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/sim.h>
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -1159,6 +1174,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_atmel_driver
 #endif
 
+#ifdef CONFIG_RMI_PHOENIX
+#include "ehci-xls.c"
+#define  PLATFORM_DRIVER      ehci_xls_driver
+#endif
+
 #if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
     !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
@@ -1192,6 +1212,10 @@ static int __init ehci_hcd_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
+#ifdef CONFIG_RMI_PHOENIX
+	/* On the XLS, use the internal USB Controller */
+	if (is_xls())
+#endif
 	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
 		goto clean0;
@@ -1248,6 +1272,10 @@ static void __exit ehci_hcd_cleanup(void)
 	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
+#ifdef CONFIG_RMI_PHOENIX
+	/* On the XLS, use the internal USB Controller */
+	if (is_xls())
+#endif 
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef PCI_DRIVER
diff --git a/drivers/usb/host/ehci-xls.c b/drivers/usb/host/ehci-xls.c
new file mode 100644
index 0000000..554c1f5
--- /dev/null
+++ b/drivers/usb/host/ehci-xls.c
@@ -0,0 +1,187 @@
+/************************************************************************
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: Adapted for the RMI XLS EHCI Controller
+
+ *****************************#RMI_1#************************************/
+
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ *
+ * Bus Glue for AMD Alchemy Au1xxx
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Rusell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ * Modified for AMD Alchemy Au1xxx
+ *  by Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+
+#undef CONFIG_PM
+
+/*-------------------------------------------------------------------------*/
+static int ehci_xls_setup(struct usb_hcd *hcd)
+{
+	int retval;
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	ehci->caps = hcd->regs;
+	ehci->regs = hcd->regs + HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	dbg_hcs_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+int ehci_xls_probe_internal(const struct hc_driver *driver,
+			    struct platform_device *pdev)
+{
+
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int retval;
+	int irq;
+
+	/* Get our IRQ from an earlier registered Platform Resource */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	/* Get our Memory Handle */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Error: MMIO Handle %s setup!\n",
+			dev_name(&pdev->dev));
+		retval = -ENODEV;
+		goto err2;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&pdev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto err2;
+	}
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+
+	if (hcd->regs == NULL) {
+		dev_dbg(&pdev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err3;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval != 0)
+		goto err4;
+	return retval;
+
+      err4:
+	iounmap(hcd->regs);
+      err3:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+      err2:
+	usb_put_hcd(hcd);
+      err1:
+	dev_err(&pdev->dev, "init %s fail, %d\n", dev_name(&pdev->dev),
+		retval);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+static struct hc_driver ehci_xls_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "XLS EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+	.reset = ehci_xls_setup,
+	.start = ehci_run,
+#ifdef  CONFIG_PM
+	.suspend = ehci_bus_suspend,
+	.resume = ehci_bus_resume,
+#endif
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.get_frame_number = ehci_get_frame,
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+static int ehci_xls_probe(struct platform_device *pdev)
+{
+	if (usb_disabled())
+		return -ENODEV;
+	return ehci_xls_probe_internal(&ehci_xls_hc_driver, pdev);
+}
+
+/*-------------------------------------------------------------------------*/
+static int ehci_xls_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+MODULE_ALIAS("ehci-xls");
+
+static struct platform_driver ehci_xls_driver = {
+	.probe = ehci_xls_probe,
+	.remove = ehci_xls_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		   .name = "ehci-xls",
+		   },
+};
+
+/*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index afe59be..c9ec24d 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -45,6 +45,10 @@
 
 #include "../core/hcd.h"
 
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/sim.h>
+#endif
+
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
 #define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
 
@@ -996,6 +1000,11 @@ MODULE_LICENSE ("GPL");
 #define PCI_DRIVER		ohci_pci_driver
 #endif
 
+#ifdef CONFIG_RMI_PHOENIX
+#include "ohci-xls.c"
+#define PLATFORM_DRIVER     ohci_xls_driver
+#endif
+
 #if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)
 #include "ohci-sa1111.c"
 #define SA1111_DRIVER		ohci_hcd_sa1111_driver
@@ -1128,6 +1137,10 @@ static int __init ohci_hcd_mod_init(void)
 #endif
 
 #ifdef PLATFORM_DRIVER
+#ifdef CONFIG_RMI_PHOENIX
+	/* On the XLS, use the internal USB Controller */
+	if (is_xls())
+#endif
 	retval = platform_driver_register(&PLATFORM_DRIVER);
 	if (retval < 0)
 		goto error_platform;
@@ -1236,6 +1249,9 @@ static void __exit ohci_hcd_mod_exit(void)
 	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
 #endif
 #ifdef PLATFORM_DRIVER
+#ifdef CONFIG_RMI_PHOENIX
+	if (is_xls())
+#endif
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
diff --git a/drivers/usb/host/ohci-xls.c b/drivers/usb/host/ohci-xls.c
new file mode 100644
index 0000000..483749c
--- /dev/null
+++ b/drivers/usb/host/ohci-xls.c
@@ -0,0 +1,185 @@
+/************************************************************************
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: Adapted for the RMI XLS OHCI Controller
+
+ *****************************#RMI_1#************************************/
+
+/*
+ * OHCI HCD (Host Controller Driver) for USB.
+ *
+ * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
+ * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
+ * (C) Copyright 2002 Hewlett-Packard Company
+ *
+ * Bus Glue for AMD Alchemy Au1xxx
+ *
+ * Written by Christopher Hoover <ch@hpl.hp.com>
+ * Based on fragments of previous driver by Rusell King et al.
+ *
+ * Modified for LH7A404 from ohci-sa1111.c
+ *  by Durgesh Pattamatta <pattamattad@sharpsec.com>
+ * Modified for AMD Alchemy Au1xxx
+ *  by Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licenced under the GPL.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/signal.h>
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+static int ohci_xls_probe_internal(const struct hc_driver *driver,
+				   struct platform_device *dev)
+{
+	int retval;
+	struct resource *res;
+	struct usb_hcd *hcd;
+	int irq;
+
+	/* Get our IRQ from an earlier registered Platform Resource */
+	res = platform_get_resource(dev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&dev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&dev->dev));
+		return -ENODEV;
+	}
+	irq = res->start;
+
+	hcd = usb_create_hcd(driver, &dev->dev, dev_name(&dev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	/* Get our Memory Handle */
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&dev->dev, "Error: MMIO Handle %s setup!\n",
+			dev_name(&dev->dev));
+		retval = -ENODEV;
+		goto err2;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+				driver->description)) {
+		dev_dbg(&dev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto err2;
+	}
+
+	hcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);
+	if (hcd->regs == NULL) {
+		dev_dbg(&dev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto err3;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
+	if (retval != 0)
+		goto err4;
+	return retval;
+
+      err4:
+	iounmap(hcd->regs);
+      err3:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+      err2:
+	usb_put_hcd(hcd);
+      err1:
+	dev_err(&dev->dev, "init %s fail, %d\n", dev_name(&dev->dev), retval);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+static int ohci_xls_reset(struct usb_hcd *hcd)
+{
+
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	ohci_hcd_init(ohci);
+	return ohci_init(ohci);
+}
+
+/*-------------------------------------------------------------------------*/
+static int __devinit ohci_xls_start(struct usb_hcd *hcd)
+{
+	struct ohci_hcd *ohci = hcd_to_ohci(hcd);
+	int ret;
+	if ((ret = ohci_run(ohci)) < 0) {
+		err("can't start %s", hcd->self.bus_name);
+		ohci_stop(hcd);
+		return ret;
+	}
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static struct hc_driver ohci_xls_hc_driver = {
+
+	.description = hcd_name,
+	.product_desc = "XLS OHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ohci_hcd),
+	.irq = ohci_irq,
+	.flags = HCD_MEMORY | HCD_USB11,
+	.reset = ohci_xls_reset,
+	.start = ohci_xls_start,
+	.stop = ohci_stop,
+	.shutdown = ohci_shutdown,
+	.urb_enqueue = ohci_urb_enqueue,
+	.urb_dequeue = ohci_urb_dequeue,
+	.endpoint_disable = ohci_endpoint_disable,
+	.get_frame_number = ohci_get_frame,
+	.hub_status_data = ohci_hub_status_data,
+	.hub_control = ohci_hub_control,
+#ifdef CONFIG_PM
+	.bus_suspend = ohci_bus_suspend,
+	.bus_resume = ohci_bus_resume,
+#endif
+	.start_port_reset = ohci_start_port_reset,
+};
+
+/*-------------------------------------------------------------------------*/
+static int ohci_xls_probe(struct platform_device *dev)
+{
+	int ret;
+	pr_debug("In ohci_xls_probe");
+	if (usb_disabled())
+		return -ENODEV;
+	ret = ohci_xls_probe_internal(&ohci_xls_hc_driver, dev);
+	return ret;
+}
+
+/*-------------------------------------------------------------------------*/
+static int ohci_xls_remove(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+static struct platform_driver ohci_xls_driver = {
+	.probe = ohci_xls_probe,
+	.remove = ohci_xls_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+	.driver = {
+		   .name = "ohci-xls-0",
+		   .owner = THIS_MODULE,
+		   },
+};
+
+/*-------------------------------------------------------------------------*/
-- 
1.6.5.2

