From 642ab75bc7c261af893ad55ec92e0259659b2e35 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 31/38] nlm_xls_atx_64_be: driver pcmcia ide

PCMCIA CF card driver

This patch is written by Jack

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/ide/Kconfig       |    4 +
 drivers/ide/Makefile      |    2 +
 drivers/ide/phoenix-ide.c |  149 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 155 insertions(+), 0 deletions(-)
 create mode 100644 drivers/ide/phoenix-ide.c

diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 98ccfeb..48df12c 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -692,6 +692,10 @@ config BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
        depends on SOC_AU1200 && BLK_DEV_IDE_AU1XXX
 endchoice
 
+config BLK_DEV_IDE_PHOENIX
+	bool "PCMCIA IDE for RMI XLR eval boards"
+	depends on RMI_PHOENIX
+
 config BLK_DEV_IDE_TX4938
 	tristate "TX4938 internal IDE support"
 	depends on SOC_TX4938
diff --git a/drivers/ide/Makefile b/drivers/ide/Makefile
index 81df925..0ebfaf6 100644
--- a/drivers/ide/Makefile
+++ b/drivers/ide/Makefile
@@ -117,3 +117,5 @@ obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4938)	+= tx4938ide.o
 obj-$(CONFIG_BLK_DEV_IDE_TX4939)	+= tx4939ide.o
 obj-$(CONFIG_BLK_DEV_IDE_AT91)		+= at91_ide.o
+
+obj-$(CONFIG_BLK_DEV_IDE_PHOENIX)	+= phoenix-ide.o
diff --git a/drivers/ide/phoenix-ide.c b/drivers/ide/phoenix-ide.c
new file mode 100644
index 0000000..21ab521
--- /dev/null
+++ b/drivers/ide/phoenix-ide.c
@@ -0,0 +1,149 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc.
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/ide.h>
+#include <linux/platform_device.h>
+
+#include <asm/rmi/phoenix_ide.h>
+#include <asm/rmi/64bit.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+#define DRV_NAME "ide-phoenix"
+
+static struct platform_device *phoenix_ide_dev;
+
+static const struct ide_port_info phoenix_port_info = {
+	.name = DRV_NAME,
+	.host_flags = IDE_HFLAG_MMIO | IDE_HFLAG_NO_DMA,
+	.chipset = ide_generic
+};
+
+int __devinit phoenix_ide_probe(struct device *dev)
+{	
+#if defined(PHOENIX_HAVE_IDE) && defined(IDE_PHYS)
+	unsigned int i = 0, rc;
+	struct ide_host *host;
+	unsigned long base;
+	struct ide_hw hw, *hws[] = {&hw, NULL, NULL, NULL};
+
+	if (xlr_board_atx_iii() || xlr_board_atx_v()) {
+		printk("Skipping PCMCIA Interface Probe.\n");
+		return 0;
+	}
+
+	printk ("Initializing Phoenix PCMCIA IDE...\n");
+
+	base = CKSEG1ADDR(IDE_PHYS);
+
+	memset(&hw, 0, sizeof(hw));
+	for (i = 0; i <= 7; i++)
+		hw.io_ports_array[i] =
+			(unsigned long)(base + (0x1f0 + i));
+	hw.io_ports.ctl_addr =
+		(unsigned long)(base + 0x3f6);
+	hw.io_ports.irq_addr =
+		(unsigned long)(base + 0x3f7);
+	hw.irq = PIC_PCMCIA_IRQ;
+
+	rc = ide_host_add(&phoenix_port_info, hws, 1, &host);
+	if (rc)
+		return rc;
+
+	dev_set_drvdata(dev, host);
+
+	return 0;
+#endif
+}
+
+static int phoenix_ide_remove (struct device *dev)
+{
+	return 0;
+}
+
+static struct device_driver phoenix_ide_driver = {
+	.name	= DRV_NAME,
+	.bus	= &platform_bus_type,
+	.probe	= phoenix_ide_probe,
+	.remove = phoenix_ide_remove
+};
+
+static void phoenix_ide_platform_release(struct device *device)
+{
+	struct platform_device *pldev;
+
+	/* free device */
+	pldev = to_platform_device(device);
+	kfree(pldev);
+}
+
+static int __devinit phoenix_ide_init_module(void)
+{
+	struct platform_device *pldev;
+	int err;
+
+	printk(KERN_INFO "Phoenix IDE driver\n");
+
+	if (driver_register(&phoenix_ide_driver)) {
+		printk(KERN_ERR "Driver registration failed\n");
+		err = -ENODEV;
+		goto out;
+	}
+
+	if (!(pldev = kzalloc(sizeof (*pldev), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto out_unregister_driver;
+	}
+
+	pldev->name		= DRV_NAME;
+	pldev->id		= 0;
+	pldev->dev.release	= phoenix_ide_platform_release;
+
+	if (platform_device_register(pldev)) {
+		err = -ENODEV;
+		goto out_free_pldev;
+	}
+
+	if (!pldev->dev.driver) {
+		/*
+		 * The driver was not bound to this device, there was
+		 * no hardware at this address. Unregister it, as the
+		 * release fuction will take care of freeing the
+		 * allocated structure
+		 */
+		platform_device_unregister (pldev);
+	}
+
+	phoenix_ide_dev = pldev;
+
+	return 0;
+
+out_free_pldev:
+	kfree(pldev);
+
+out_unregister_driver:
+	driver_unregister(&phoenix_ide_driver);
+out:
+	return err;
+}
+
+module_init(phoenix_ide_init_module);
-- 
1.6.5.2

