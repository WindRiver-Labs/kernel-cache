From f6316cf0d2cd6525c81ac1b39c91be144fcc6544 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 29/38] nlm_xls_atx_64_be: driver nor

NOR flash driver

This patch is from RMI SDK 1.7.0

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/mtd/maps/Kconfig     |    6 ++
 drivers/mtd/maps/Makefile    |    1 +
 drivers/mtd/maps/xlr-flash.c |  129 ++++++++++++++++++++++++++++++++++++++++++
 include/linux/mtd/map.h      |   37 ++++++++++++
 4 files changed, 173 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/maps/xlr-flash.c

diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index aa2807d..e1909ae 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -251,6 +251,12 @@ config MTD_NETtel
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
+config MTD_SPS
+	tristate "SPS Flash MTD support"
+	depends on RMI_PHOENIX
+	help
+	  Flash memory access on SPS Reference Boards
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT && BROKEN
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index bb035cd..7b2343b 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -56,6 +56,7 @@ obj-$(CONFIG_MTD_DMV182)	+= dmv182.o
 obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+obj-$(CONFIG_MTD_SPS)		+= xlr-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
diff --git a/drivers/mtd/maps/xlr-flash.c b/drivers/mtd/maps/xlr-flash.c
new file mode 100644
index 0000000..f489d01
--- /dev/null
+++ b/drivers/mtd/maps/xlr-flash.c
@@ -0,0 +1,129 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ * Flash memory access on XLR evaluation boards
+ *
+ * (C) 2008, 2009  RMI Corp <sandip@rmicorp.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/rmi/sim.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)
+#endif
+
+#define BOARD_MAP_NAME "SPS Flash"
+#define BOARD_FLASH_SIZE 0x01000000 /* 16MB */
+#define BOARD_FLASH_BASE 0x1c000000
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+
+static struct map_info sps_map = {
+	.name =	BOARD_MAP_NAME,
+};
+
+static struct mtd_partition sps_partitions[] = {
+ 	{
+		.name = "User FS",
+		.offset = 0x800000, /* Upto 8 MB is used by bootloader */
+		.size = MTDPART_SIZ_FULL ,
+	}
+};
+
+static struct mtd_info *mymtd;
+
+int __init sps_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	unsigned long window_addr;
+	unsigned long window_size;
+
+	if (xlr_board_atx_viii()){
+		return -ENODEV;
+	}
+	/* Default flash buswidth */
+	sps_map.bankwidth = BOARD_FLASH_WIDTH;
+
+	window_addr = BOARD_FLASH_BASE;
+	window_size = BOARD_FLASH_SIZE;
+
+	/*
+	 * Static partition definition selection
+	 */
+	parts = sps_partitions;
+	nb_parts = ARRAY_SIZE(sps_partitions);
+	sps_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash. Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE BOARD_MAP_NAME ": probing %d-bit flash bus\n",
+			sps_map.bankwidth*8);
+	sps_map.virt = ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &sps_map);
+	if (!mymtd) {
+		iounmap(sps_map.virt);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit sps_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		iounmap(sps_map.virt);
+	}
+}
+
+module_init(sps_mtd_init);
+module_exit(sps_mtd_cleanup);
+
+MODULE_AUTHOR("Sandip Matte, RMI Corporation");
+MODULE_DESCRIPTION(BOARD_MAP_NAME " MTD driver");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index b981b87..a67c949 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -13,6 +13,9 @@
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/iomap.h>
+#endif
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
 #define map_bankwidth(map) 1
@@ -373,6 +376,12 @@ static inline map_word map_word_ff(struct map_info *map)
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
 	map_word r;
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_read_lock();
+
+#endif
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = __raw_readb(map->virt + ofs);
@@ -387,11 +396,20 @@ static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 	else if (map_bankwidth_is_large(map))
 		memcpy_fromio(r.x, map->virt+ofs, map->bankwidth);
 
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_read_unlock(flags);
+#endif
 	return r;
 }
 
 static inline void inline_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+
+#endif
 	if (map_bankwidth_is_1(map))
 		__raw_writeb(datum.x[0], map->virt + ofs);
 	else if (map_bankwidth_is_2(map))
@@ -405,19 +423,38 @@ static inline void inline_map_write(struct map_info *map, const map_word datum,
 	else if (map_bankwidth_is_large(map))
 		memcpy_toio(map->virt+ofs, datum.x, map->bankwidth);
 	mb();
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+#endif
 	if (map->cached)
 		memcpy(to, (char *)map->cached + from, len);
 	else
 		memcpy_fromio(to, map->virt + from, len);
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+#endif
 	memcpy_toio(map->virt + to, from, len);
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 #ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-- 
1.6.5.2

