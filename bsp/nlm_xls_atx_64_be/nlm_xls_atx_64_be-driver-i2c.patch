From 9cea53ce11a73b4da2d0b5e3ca1ee8ee20e66e09 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 26/38] nlm_xls_atx_64_be: driver i2c

I2C driver

This patch is from RMI SDK 1.7.0

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/i2c/algos/Kconfig         |    9 +
 drivers/i2c/algos/Makefile        |    1 +
 drivers/i2c/algos/i2c-algo-palm.c |  315 +++++++++++++++++++++++++++++++++++++
 drivers/i2c/algos/i2c-algo-palm.h |   70 ++++++++
 drivers/i2c/busses/Kconfig        |   11 ++
 drivers/i2c/busses/Makefile       |    1 +
 drivers/i2c/busses/i2c-bk3220.c   |  136 ++++++++++++++++
 drivers/i2c/i2c-core.c            |    7 +
 include/linux/i2c-id.h            |   55 +++++++
 include/linux/i2c.h               |    3 +
 10 files changed, 608 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/algos/i2c-algo-palm.c
 create mode 100644 drivers/i2c/algos/i2c-algo-palm.h
 create mode 100644 drivers/i2c/busses/i2c-bk3220.c

diff --git a/drivers/i2c/algos/Kconfig b/drivers/i2c/algos/Kconfig
index 7b2ce4a..fe8d326 100644
--- a/drivers/i2c/algos/Kconfig
+++ b/drivers/i2c/algos/Kconfig
@@ -11,6 +11,15 @@ config I2C_ALGOBIT
 config I2C_ALGOPCF
 	tristate "I2C PCF 8584 interfaces"
 
+config I2C_ALGOPALM
+	tristate "PalmChip's I2C interfaces"
+	depends on I2C && RMI_PHOENIX
+	help
+	  This allows you to use the BK3220 I2C Host Adapter on the RMI Phoenix.
+
+	  This support is also available as a module.  If so, the module
+	  will be called i2c-algo-palm.
+
 config I2C_ALGOPCA
 	tristate "I2C PCA 9564 interfaces"
 
diff --git a/drivers/i2c/algos/Makefile b/drivers/i2c/algos/Makefile
index 18b3e96..815f8e0 100644
--- a/drivers/i2c/algos/Makefile
+++ b/drivers/i2c/algos/Makefile
@@ -5,6 +5,7 @@
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
+obj-$(CONFIG_I2C_ALGOPALM)	+= i2c-algo-palm.o
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/algos/i2c-algo-palm.c b/drivers/i2c/algos/i2c-algo-palm.c
new file mode 100644
index 0000000..07e8d48
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-palm.c
@@ -0,0 +1,315 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host
+ *  adapter on the RMI Phoenix System.
+ *  Derived from the PCA-ISA I2C-Algo/Bus files.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/i2c.h>
+#include "i2c-algo-palm.h"
+
+#define DRIVER "i2c-algo-palm"
+
+#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
+#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
+#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
+
+static int i2c_debug=0;
+spinlock_t palm_lock;
+					
+#define palm_write(algo_data, reg, val) 	algo_data->write(reg, val)
+#define palm_read(algo_data, reg) 		algo_data->read(reg)
+
+#define palm_clock(adap) 		adap->get_clock(adap)
+#define palm_status(adap) 		palm_inw(adap, I2C_PCA_STA)
+#define palm_set_con(adap, val) 	palm_outw(adap, I2C_PCA_CON, val)
+#define palm_get_con(adap) 		palm_inw(adap, I2C_PCA_CON)
+
+/*
+ * Check if the I2C Bus is idle or busy
+ */
+static int wait_for_idle(struct i2c_algo_palm_data *algo_data)
+{
+	int timeOut=0x1000;
+	volatile __u32 regVal=0x00;
+	regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
+	while (regVal && timeOut--) {
+		regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
+	}
+	if (timeOut == 0x00)
+		return -1;	/* Timed Out */
+	else
+		return 0;
+}
+
+/*
+ * Transmit Routine
+ */
+static int palm_tx(struct i2c_algo_palm_data *algo_data,  __u16 len,
+		__u8 *buf, __u16 addr, __u8 offset)
+{
+	volatile __u32 regVal=0x00;
+	int timeOut, ctr=0x00, numBytes=len;
+
+	for (ctr=0x00; ctr<len; ctr++) {
+		if (wait_for_idle(algo_data) < 0) {
+			printk("TimedOut on Waiting for I2C Bus Idle.\n");
+			return -EIO;
+		}
+		palm_write(algo_data, I2C_PALM_CFG, 0xF8);			
+		palm_write(algo_data, I2C_PALM_BYTECNT, 0x00);
+		palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+		palm_write(algo_data, I2C_PALM_ADDR, offset+numBytes-1);
+		palm_write(algo_data, I2C_PALM_DATAOUT, buf[ctr]);
+		palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR );
+		spin_lock_irq(&palm_lock);
+		mdelay(0x1);
+		spin_unlock_irq(&palm_lock);
+		
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (regVal & 0x0008) {
+			printk("palm_tx: ACKERR. Aborting...\n");
+			return -1;
+		}
+		timeOut= 0x1000;
+		while (!(regVal & 0x0002) && timeOut) {
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+			timeOut--;
+		}
+		if (timeOut==0x00) {
+			printk("palm_tx: [TimeOut] SDOEMPTY Not Set\n");
+			return -1;
+		}
+		timeOut=1000;
+		while ((regVal & 0x0030) && timeOut) {
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR);
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+			timeOut--;
+		}
+		if (timeOut==0x00) {
+			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
+			return -1;
+		}
+		numBytes--;
+	}
+	return 0;
+}
+static int palm_addr_only(struct i2c_algo_palm_data *algo_data, __u8 *buf,
+		__u16 addr, __u8 offset)
+{
+	volatile __u32 regVal=0x00;
+
+	palm_write(algo_data, I2C_PALM_ADDR, offset);
+	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+	palm_write(algo_data, I2C_PALM_CFG, 0xfa);
+	palm_write(algo_data, I2C_PALM_STARTXFR,0x02);
+	regVal = palm_read(algo_data, I2C_PALM_STATUS);
+	if (regVal & 0x0008) {
+		printk("palm_addr_only: ACKERR. Aborting...\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ * Receive Routine
+ * Read 'len' bytes from device @ 'addr'
+ */
+static int palm_rx(struct i2c_algo_palm_data *algo_data, __u16 len,
+		__u8 *buf, __u16 addr, __u8 offset)
+{	
+	volatile __u32 regVal=0x00, ctr=0x00;
+	int timeOut, numBytes=0x00;
+
+	palm_write(algo_data, I2C_PALM_CFG, 0xfa);
+	palm_write(algo_data, I2C_PALM_BYTECNT, len);
+	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+	spin_lock_irq(&palm_lock);
+	mdelay(0x01);
+	spin_unlock_irq(&palm_lock);
+
+	for (numBytes=0x00; numBytes < len; numBytes++) {
+		palm_write(algo_data, I2C_PALM_ADDR,  offset+numBytes);	
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (!ctr) {
+			/* Trigger a READ Transaction */
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
+			ctr++;
+		}
+
+		/* Error Conditions [Begin] */
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (regVal & 0x0008) {
+			printk("palm_rx: ACKERR. Aborting...\n");
+			return -1;
+		}
+		timeOut=10;
+		while ((regVal & 0x0030) && timeOut--) {
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		}
+		if (timeOut==0x00) {
+			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
+			return -1;
+		}
+		timeOut=10;
+		/* Do we have valid data from the device yet..? */
+		regVal &= 0x0004;
+		while (!regVal && timeOut--) {
+			regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0004;
+		}
+		if (timeOut==0x00) {
+			printk("palm_rx: TimedOut Waiting for Valid Data\n");
+			return -1;
+		}
+		/* Error Conditions [End] */
+		/* Read the data */
+		buf[numBytes] = (__u8)palm_read(algo_data, I2C_PALM_DATAIN);
+	}
+	return 0;
+}
+
+static int palm_xfer(struct i2c_adapter *i2c_adap,
+		struct i2c_msg msgs[],
+		int num)
+{
+	struct 	i2c_algo_palm_data *algo_data = i2c_adap->algo_data;
+	struct 	i2c_msg *msg = NULL;
+	int 	curmsg;
+
+	for (curmsg = 0; curmsg < num; curmsg++) {
+
+		int addr;
+		msg = &msgs[curmsg];
+
+		addr = (0x7f & msg->addr);
+
+		/*
+		 * Check if I2C State Machine is idle
+		 * 'wait_for_idle' returns 0 => timedOut
+		 * 'BUSY' bit cleared => BUS is IDLE
+		 */
+		if (wait_for_idle(algo_data) < 0) {
+			printk("TimedOut on Waiting for I2C Bus Idle.\n");
+			return -EIO;
+		}
+		if (msg->flags & I2C_M_RD ) {
+			if (palm_addr_only(algo_data, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C ADDRONLY Phase Fail.\n");
+				return -EIO;
+			}
+			if (palm_rx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C Read Fail.\n");
+				return -EIO;
+			}
+		}
+		else {
+			if (palm_tx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C Write Fail.\n");
+				return -EIO;
+			}
+		}
+	}
+	return num;
+}
+
+static u32 palm_func(struct i2c_adapter *adap)
+{
+	/* We emulate SMBUS over I2C */
+	return I2C_FUNC_SMBUS_EMUL;
+}
+
+static int palm_init(struct i2c_algo_palm_data *algo_data)
+{
+	printk("Intializing BK-3220 I2C Host Adapter...");
+	spin_lock_init(&palm_lock);
+	printk("done.\n");
+	return 0;
+}
+
+static struct i2c_algorithm palm_algo = {
+	.master_xfer	= palm_xfer,
+	.functionality	= palm_func,
+};
+
+/*
+ * registering functions to load algorithms at runtime
+ */
+int i2c_palm_add_bus(struct i2c_adapter *adap)
+{
+	struct i2c_algo_palm_data *palm_adap = adap->algo_data;
+	int rval;
+
+	adap->algo = &palm_algo;
+
+	adap->timeout = 100;		
+	adap->retries = 3;		
+
+	rval = palm_init(palm_adap);
+
+	/* register new adapter to i2c module... */
+	if (!rval)
+		i2c_add_adapter(adap);
+
+	return rval;
+}
+
+int i2c_palm_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_palm_add_bus);
+EXPORT_SYMBOL(i2c_palm_del_bus);
+
+MODULE_AUTHOR("RMI");
+MODULE_DESCRIPTION("I2C-Bus PalmChip's Host Adapter algorithm");
+MODULE_LICENSE("GPL");
+
+module_param(i2c_debug, int, 0);
diff --git a/drivers/i2c/algos/i2c-algo-palm.h b/drivers/i2c/algos/i2c-algo-palm.h
new file mode 100644
index 0000000..96b29a3
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-palm.h
@@ -0,0 +1,70 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host
+ *  adapter on the RMI Phoenix System.
+ *  Derived from the PCA-ISA I2C-Algo/Bus files.
+ */
+
+#ifndef I2C_PALM_H
+#define I2C_PALM_H
+
+#define I2C_PALM_CFG			0x00
+#define I2C_PALM_CLKDIV			0x01
+#define I2C_PALM_DEVADDR		0x02
+#define I2C_PALM_ADDR			0x03
+#define I2C_PALM_DATAOUT		0x04
+#define I2C_PALM_DATAIN			0x05
+#define I2C_PALM_STATUS			0x06
+#define I2C_PALM_STARTXFR		0x07
+#define I2C_PALM_BYTECNT		0x08
+#define I2C_PALM_HDSTATIM		0x09
+
+/* TEST Values!! Change as required */
+#define I2C_PALM_CFG_DEF		0x000000F8	/* 8-Bit Addr + POR Values */
+#define I2C_PALM_CLKDIV_DEF		0x14A //0x00000052	
+#define I2C_PALM_HDSTATIM_DEF		0x107 //0x00000000
+
+#define I2C_PALM_STARTXFR_RD		0x00000001
+#define I2C_PALM_STARTXFR_WR		0x00000000
+
+#define WORD	1
+
+struct i2c_algo_palm_data {
+	void (*write)(int ctl, int val);
+	int  (*read) (int ctl);
+};
+
+#define I2C_PCA_ADAP_MAX	16
+
+int i2c_palm_add_bus(struct i2c_adapter *);
+int i2c_palm_del_bus(struct i2c_adapter *);
+
+#endif /* I2C_PALM_H */
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 9c6170c..6948fcd 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -295,6 +295,17 @@ config I2C_AT91
 	  to support combined I2C messages.  Use the i2c-gpio driver
 	  unless your system can cope with those limitations.
 
+config I2C_BK3220
+	tristate "PalmChip BK-3220"
+	depends on I2C && EXPERIMENTAL
+	select I2C_ALGOPALM
+	help
+	  This supports the BK-3220 I2C adapter.  Say Y if you own
+	  such an adapter.
+
+	  This support is also available as a module.  If so, the module
+	  will be called i2c-bk3220.
+
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on SOC_AU1550 || SOC_AU1200
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 097236f..0b5c4c9 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_I2C_ALI15X3)	+= i2c-ali15x3.o
 obj-$(CONFIG_I2C_AMD756)	+= i2c-amd756.o
 obj-$(CONFIG_I2C_AMD756_S4882)	+= i2c-amd756-s4882.o
 obj-$(CONFIG_I2C_AMD8111)	+= i2c-amd8111.o
+obj-$(CONFIG_I2C_BK3220)	+= i2c-bk3220.o
 obj-$(CONFIG_I2C_I801)		+= i2c-i801.o
 obj-$(CONFIG_I2C_ISCH)		+= i2c-isch.o
 obj-$(CONFIG_I2C_NFORCE2)	+= i2c-nforce2.o
diff --git a/drivers/i2c/busses/i2c-bk3220.c b/drivers/i2c/busses/i2c-bk3220.c
new file mode 100644
index 0000000..fcc21d5
--- /dev/null
+++ b/drivers/i2c/busses/i2c-bk3220.c
@@ -0,0 +1,136 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ *  i2c-palm-bk3220.c driver for the BK-3220 Host Adapter on the
+ *  RMI Phoenix System.
+ */
+
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/wait.h>
+#include <linux/i2c.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+#include "../algos/i2c-algo-palm.h"
+
+#undef 	DEBUG
+
+#define ARIZONA_RTC_BUS 1
+#define PHOENIX_CPLD_PHYS_ADDR	0xbd850000
+
+static wait_queue_head_t palm_wait;
+__u32 * iobase_i2c_regs = 0;
+
+__u32 * get_i2c_base(unsigned short bus)
+{
+	phoenix_reg_t *mmio = 0;
+
+	if (bus == 0)
+		mmio = phoenix_io_mmio(PHOENIX_IO_I2C_0_OFFSET);
+	else
+		mmio = phoenix_io_mmio(PHOENIX_IO_I2C_1_OFFSET);
+
+	return (__u32 *)mmio;
+}
+
+static void	
+palm_bk3220_write(int reg, int val)
+{
+	/*
+	 * Code to access the low-level
+	 * I2C Block on the RMI Phoenix
+	 */		
+	phoenix_write_reg(iobase_i2c_regs, reg, val);
+}
+
+static int
+palm_bk3220_read(int reg)
+{
+  /*
+   * Code to access the low-level
+   * I2C Block on the RMI Phoenix
+   */		
+  __u32 retVal = phoenix_read_reg(iobase_i2c_regs, reg);
+  return (int)retVal;
+}
+
+static struct i2c_algo_palm_data palm_bk3220_data = {
+	.write		= palm_bk3220_write,
+	.read		= palm_bk3220_read,
+};
+
+/* This is our i2c_adapter structure */
+static struct i2c_adapter palm_bk3220_ops = {
+	.owner	= THIS_MODULE,
+	.id		= I2C_HW_PALM_BK3220,			
+	.algo_data	= &palm_bk3220_data,
+	.name		= "Palm Chip BK3220 Adapter",
+};
+
+static int __init palm_bk3220_init(void)
+{
+	iobase_i2c_regs = get_i2c_base(ARIZONA_RTC_BUS);
+
+	init_waitqueue_head(&palm_wait);
+
+	if (i2c_palm_add_bus(&palm_bk3220_ops) < 0) {
+		printk(KERN_ERR "i2c-palm-bk3220: Failed to add i2c bus\n");
+		goto out;
+	}
+	else {
+		printk("i2c-palm-bk3220: Added I2C Bus.\n");
+	}
+
+	return 0;
+out:
+	return -ENODEV;
+}
+
+static void palm_bk3220_exit(void)
+{
+	i2c_palm_del_bus(&palm_bk3220_ops);
+}
+
+MODULE_AUTHOR("RMI Inc.");
+MODULE_DESCRIPTION("BK3220 I2C Host adapter driver");
+MODULE_LICENSE("GPL");
+
+module_init(palm_bk3220_init);
+module_exit(palm_bk3220_exit);
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index c2258a5..f5b5417 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -1746,9 +1746,16 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];
 	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];
 	int num = read_write == I2C_SMBUS_READ?2:1;
+#ifndef CONFIG_RMI_PHOENIX
 	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },
 	                          { addr, flags | I2C_M_RD, 0, msgbuf1 }
 	                        };
+#else
+	struct i2c_msg msg[2] = { { addr, flags, 1, 1, msgbuf0 },
+							 { addr, flags | I2C_M_RD, 1, 0, msgbuf1 }
+							};
+#endif
+
 	int i;
 	u8 partial_pec = 0;
 	int status;
diff --git a/include/linux/i2c-id.h b/include/linux/i2c-id.h
index e844a0b..f4e19f9 100644
--- a/include/linux/i2c-id.h
+++ b/include/linux/i2c-id.h
@@ -1,3 +1,15 @@
+/************************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI:
+
+  *****************************#RMI_1#************************************/
+
 /* ------------------------------------------------------------------------- */
 /*									     */
 /* i2c-id.h - identifier values for i2c drivers and adapters		     */
@@ -29,6 +41,46 @@
 
 /*
  * ---- Adapter types ----------------------------------------------------
+ *
+ * First, we distinguish between several algorithms to access the hardware
+ * interface types, as a PCF 8584 needs other care than a bit adapter.
+ */
+
+#define I2C_ALGO_NONE		0x000000
+#define I2C_ALGO_BIT		0x010000	/* bit style adapters		*/
+#define I2C_ALGO_PCF		0x020000	/* PCF 8584 style adapters	*/
+#define I2C_ALGO_ATI		0x030000	/* ATI video card		*/
+#define I2C_ALGO_SMBUS		0x040000
+#define I2C_ALGO_ISA		0x050000	/* lm_sensors ISA pseudo-adapter */
+#define I2C_ALGO_SAA7146	0x060000	/* SAA 7146 video decoder bus	*/
+#define I2C_ALGO_ACB		0x070000	/* ACCESS.bus algorithm */
+#define I2C_ALGO_IIC		0x080000 	/* ITE IIC bus */
+#define I2C_ALGO_SAA7134	0x090000
+#define I2C_ALGO_MPC824X	0x0a0000	/* Motorola 8240 / 8245 */
+#define I2C_ALGO_IPMI		0x0b0000	/* IPMI dummy adapter */
+#define I2C_ALGO_IPMB		0x0c0000	/* IPMB adapter */
+#define I2C_ALGO_MPC107	0x0d0000
+#define I2C_ALGO_EC		0x100000	/* ACPI embedded controller */
+
+#define I2C_ALGO_MPC8XX		0x110000	/* MPC8xx PowerPC I2C algorithm */
+#define I2C_ALGO_OCP			0x120000	/* IBM or otherwise On-chip I2C algorithm */
+#define I2C_ALGO_BITHS			0x130000	/* enhanced bit style adapters	*/
+#define I2C_ALGO_OCP_IOP3XX	0x140000	/* XSCALE IOP3XX On-chip I2C alg */
+
+#define I2C_ALGO_SIBYTE		0x150000	/* Broadcom SiByte SOCs		*/
+#define I2C_ALGO_SGI			0x160000	/* SGI algorithm */
+#define I2C_ALGO_PALM			0x170000	/* PalmChip algorithm */
+
+#define I2C_ALGO_EXP	0x800000	/* experimental			*/
+
+#define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
+#define I2C_ALGO_SHIFT	0x10	/* right shift to get index values 	*/
+
+#define I2C_HW_ADAPS	0x10000		/* # adapter types		*/
+#define I2C_HW_MASK	0xffff		
+
+
+/* hw specific modules that are defined per algorithm layer
  */
 
 /* --- Bit algorithm adapters						*/
@@ -56,4 +108,7 @@
 #define I2C_HW_SAA7146		0x060000 /* SAA7146 video decoder bus */
 #define I2C_HW_SAA7134		0x090000 /* SAA7134 video decoder bus */
 
+/* --- Palm Chip adapter */
+#define I2C_HW_PALM_BK3220 	0x00
+
 #endif /* LINUX_I2C_ID_H */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 6ed1d59..e94abe7 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -507,6 +507,9 @@ struct i2c_msg {
 #define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+#ifdef CONFIG_RMI_PHOENIX
+	__u16 offset;
+#endif
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
 };
-- 
1.6.5.2

