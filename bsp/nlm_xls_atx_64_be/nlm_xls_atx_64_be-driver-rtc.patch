From 07b1a51732a5df4b40ca3e8e911682b2cf7375cc Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 20 Jul 2010 18:51:32 +0800
Subject: [PATCH] nlm_xls_atx_64_be: driver rtc

Introduce rtc support to the RMI (CPU_PHOENIX) class of boards.

RMI has its own i2c driver algorithm. We need add the i2c_board_info for the
rtc of RMI to make the i2c subsystem find the RTC device.

This patch is based on SDK 1.7.0 and the mainline kernel.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/rmi/phoenix/platform.c  |    9 +
 drivers/i2c/algos/i2c-algo-palm.c |    2 +-
 drivers/i2c/busses/i2c-bk3220.c   |    1 +
 drivers/rtc/Kconfig               |    6 +
 drivers/rtc/Makefile              |    1 +
 drivers/rtc/rtc-rmi-ds1374.c      |  363 +++++++++++++++++++++++++++++++++++++
 6 files changed, 381 insertions(+), 1 deletions(-)
 create mode 100644 drivers/rtc/rtc-rmi-ds1374.c

diff --git a/arch/mips/rmi/phoenix/platform.c b/arch/mips/rmi/phoenix/platform.c
index 48a764a..b62619f 100644
--- a/arch/mips/rmi/phoenix/platform.c
+++ b/arch/mips/rmi/phoenix/platform.c
@@ -24,6 +24,7 @@
 #include <linux/serial.h>
 #include <linux/serial_8250.h>
 #include <linux/serial_core.h>
+#include <linux/i2c.h>
 
 #ifdef CONFIG_RAPIDIO
 #include <asm/rmi/rmi_srio.h>
@@ -108,8 +109,16 @@ static struct platform_device *xls_platform_devices[] __initdata = {
 	&xls_usb_ohci_device_1,
 };
 
+static struct i2c_board_info rmi_i2c_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("ds1374", 0x68),
+	},
+};
+
 int xls_platform_init(void)
 {
+	i2c_register_board_info(0, rmi_i2c_info,
+					  ARRAY_SIZE(rmi_i2c_info));
 	return platform_add_devices(xls_platform_devices,
 				    ARRAY_SIZE(xls_platform_devices));
 }
diff --git a/drivers/i2c/algos/i2c-algo-palm.c b/drivers/i2c/algos/i2c-algo-palm.c
index 07e8d48..1a5af93 100644
--- a/drivers/i2c/algos/i2c-algo-palm.c
+++ b/drivers/i2c/algos/i2c-algo-palm.c
@@ -295,7 +295,7 @@ int i2c_palm_add_bus(struct i2c_adapter *adap)
 
 	/* register new adapter to i2c module... */
 	if (!rval)
-		i2c_add_adapter(adap);
+		i2c_add_numbered_adapter(adap);
 
 	return rval;
 }
diff --git a/drivers/i2c/busses/i2c-bk3220.c b/drivers/i2c/busses/i2c-bk3220.c
index fcc21d5..b9df745 100644
--- a/drivers/i2c/busses/i2c-bk3220.c
+++ b/drivers/i2c/busses/i2c-bk3220.c
@@ -101,6 +101,7 @@ static struct i2c_adapter palm_bk3220_ops = {
 	.owner	= THIS_MODULE,
 	.id		= I2C_HW_PALM_BK3220,			
 	.algo_data	= &palm_bk3220_data,
+	.nr		= 0,
 	.name		= "Palm Chip BK3220 Adapter",
 };
 
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 7f914b1..fec60f2 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -925,4 +925,10 @@ config RTC_DRV_CNS3XXX
 	  To compile this driver as a module, choose M here: the
 	  module will be called rtc-cns3xxx.
 
+config RTC_RMI_DS1374
+	tristate "Dallas/Maxim DS1374 Real Time Clock"
+	depends on RMI_PHOENIX && I2C && RTC!=y && GEN_RTC!=y && EXPERIMENTAL
+	help
+	  Driver for the I2C-based DS1374 RTC Chip on the RMI Phoenix
+
 endif # RTC_CLASS
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 2bea92d..e055678 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -96,3 +96,4 @@ obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
 obj-$(CONFIG_RTC_DRV_CNS3XXX)	+= rtc-cns3xxx.o
+obj-$(CONFIG_RTC_RMI_DS1374) += rtc-rmi-ds1374.o
diff --git a/drivers/rtc/rtc-rmi-ds1374.c b/drivers/rtc/rtc-rmi-ds1374.c
new file mode 100644
index 0000000..e2e731d
--- /dev/null
+++ b/drivers/rtc/rtc-rmi-ds1374.c
@@ -0,0 +1,363 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <asm/rmi/sim.h>
+
+#ifdef DEBUG_DS1374
+#define dbg(fmt, args...) 	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define dbg(fmt, args...)
+#endif
+
+#define err(format, arg...) 	printk(KERN_ERR ": " format , ## arg)
+
+#define DS1374_RTC_BASE		0x00
+
+static const struct i2c_device_id ds1374_id[] = {
+	{"ds1374", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ds1374_id);
+
+struct ds1374
+{
+	struct i2c_client *client;
+	struct rtc_device *rtc;
+};
+
+static struct i2c_driver ds1374_driver;
+static void ds1374_BinaryToDate(unsigned long binary,
+								struct rtc_time *datetime);
+
+/* This is an image of the RTC registers starting at offset 0x00 */
+struct rtc_registers
+{
+	unsigned char todc_byte0;	/* 0x00 */
+	unsigned char todc_byte1;	/* 0x01 */
+	unsigned char todc_byte2;	/* 0x02 */
+	unsigned char todc_byte3;	/* 0x03 */
+};
+
+/*
+ * Array representing the number of days in one non-leap year at
+ * the beginning of each month
+*/
+unsigned long DaysToMonth[13] = {
+	0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
+};
+
+static int
+ds1374_read(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg todc_read[1] = {
+		{
+		 client->addr,			/* 0x68 */
+		 client->flags | I2C_M_RD,	/* I2C Read Command */
+		 offset,
+		 4,						/* Need 4 Bytes */
+		 buf					/* Store the result here */
+		 }
+	};
+
+	if ((ret = i2c_transfer(client->adapter, todc_read, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+static int
+ds1374_write(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg todc_write = {
+		client->addr,			/* 0x68 */
+		client->flags,			/* I2C Write Command */
+		offset,					/* register offset which to write */
+		4,						/* Write 4 Bytes */
+		buf						/* Data to be written */
+	};
+
+	if ((ret = i2c_transfer(client->adapter, &todc_write, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+
+/*
+ * The DS1374 gives a 32-bit up-counter counting in seconds.
+ * We rely on a Maxim Algorithm to convert this 32-bit binary
+ * to a user-friendly time/date format
+*/
+static void ds1374_BinaryToDate(unsigned long binary,
+								struct rtc_time *datetime)
+{
+
+	unsigned long hour;
+	unsigned long day;
+	unsigned long minute;
+	unsigned long second;
+	unsigned long month;
+	unsigned long year;
+
+	unsigned long whole_minutes;
+	unsigned long whole_hours;
+	unsigned long whole_days;
+	unsigned long whole_days_since_1968;
+	unsigned long leap_year_periods;
+	unsigned long days_since_current_lyear;
+	unsigned long whole_years;
+	unsigned long days_since_first_of_year;
+	unsigned long days_to_month;
+	unsigned long day_of_week;
+
+	whole_minutes = binary / 60;
+	second = binary - (60 * whole_minutes);	/* leftover seconds */
+
+	whole_hours = whole_minutes / 60;
+	minute = whole_minutes - (60 * whole_hours);	/* leftover minutes */
+
+	whole_days = whole_hours / 24;
+	hour = whole_hours - (24 * whole_days);	/* leftover hours */
+
+	whole_days_since_1968 = whole_days + 365 + 366;
+	leap_year_periods = whole_days_since_1968 / ((4 * 365) + 1);
+
+	days_since_current_lyear = whole_days_since_1968 % ((4 * 365) + 1);
+
+	/* if days are after a current leap year then add a leap year period */
+	if ((days_since_current_lyear >= (31 + 29))) {
+		leap_year_periods++;
+	}
+	whole_years = (whole_days_since_1968 - leap_year_periods) / 365;
+	days_since_first_of_year = whole_days_since_1968 -
+		(whole_years * 365) - leap_year_periods;
+
+	if ((days_since_current_lyear <= 365) && (days_since_current_lyear >= 60)) {
+		days_since_first_of_year++;
+	}
+	year = whole_years + 68;
+
+	/*
+	 * setup for a search for what month it is based on how many days have past
+	 * within the current year
+	 */
+	month = 13;
+	days_to_month = 366;
+	while (days_since_first_of_year < days_to_month) {
+		month--;
+		days_to_month = DaysToMonth[month];
+		if ((month >= 2) && ((year % 4) == 0)) {
+			days_to_month++;
+		}
+	}
+	day = days_since_first_of_year - days_to_month + 1;
+
+	day_of_week = (whole_days + 4) % 7;
+
+	datetime->tm_yday = days_since_first_of_year;	/* days since Jan 1 - [0,365] */
+	datetime->tm_sec = second;	/* seconds after the minute - [0,59] */
+	datetime->tm_min = minute;	/* minutes after the hour - [0,59] */
+	datetime->tm_hour = hour;	/* hours since midnight - [0,23] */
+	datetime->tm_mday = day;	/* day of the month - [1,31] */
+	datetime->tm_wday = day_of_week;	/* days since Sunday - [0,6] */
+	datetime->tm_mon = month;	/* months since January - [0,11] */
+	datetime->tm_year = year;	/* years since 1900 */
+}
+
+/* Converting DateTime format to the 32-bit Binary */
+unsigned long ds1374_DateToBinary(struct rtc_time *datetime)
+{
+
+	unsigned long iday;
+	unsigned long val;
+
+	iday = (365 * (datetime->tm_year - 70)) + DaysToMonth[datetime->tm_mon] +
+			(datetime->tm_mday - 1);
+	iday = iday + ((datetime->tm_year - 69) / 4);
+	if ((datetime->tm_mon > 1) && ((datetime->tm_year % 4) == 0)) {
+		iday++;
+	}
+	val = datetime->tm_sec + (60 * datetime->tm_min) +
+			(3600 * (datetime->tm_hour + (24 * iday)));
+
+	dbg("ds1374_DateToBinary: 0x%lx [%d]\n", val, val);
+
+	return val;
+}
+
+static int ds1374_get_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rtc_registers rtc;
+	int ret;
+	unsigned int binary = 0x00, binary1;
+	int limit = 10;
+
+	if (!client)
+		return -ENXIO;
+
+retry:
+	/* read RTC registers */
+	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
+						   sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+
+	dbg("IN: todc_B0=%02d, todc_B1=%02d, todc_B2=%02d, todc_B3=%02d\n",
+		rtc.todc_byte0, rtc.todc_byte1, rtc.todc_byte2, rtc.todc_byte3);
+
+	binary = (rtc.todc_byte0) + (rtc.todc_byte1 << 8) +
+		(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
+
+	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
+						   sizeof(struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+
+	binary1 = (rtc.todc_byte0) + (rtc.todc_byte1 << 8) +
+		(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
+
+	if ((binary1 != binary) && limit) {
+		limit--;
+		goto retry;
+	}
+
+	if (binary1 != binary)
+		printk(KERN_DEBUG "ds1374_read: Unable to read consistent date value\n");
+
+	ds1374_BinaryToDate(binary, tm);
+
+	dbg("Date [%02d:%02d:%04d] Time [%02d:%02d:%02d]\n",
+		tm->tm_mon + 1, tm->tm_mday, (1900 + tm->tm_year),
+		tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	return 0;
+}
+
+static int ds1374_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct rtc_registers rtc, rtc1;
+	unsigned int binary = 0x00, binary1;
+	int limit;
+
+	if (!client)
+		return -ENXIO;
+
+	dbg("IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+		tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+		tm->tm_min, tm->tm_sec);
+
+	binary = ds1374_DateToBinary(tm);
+
+	rtc.todc_byte0 = (unsigned char) (binary >> 24);
+	rtc.todc_byte1 = (unsigned char) (binary >> 16);
+	rtc.todc_byte2 = (unsigned char) (binary >> 8);
+	rtc.todc_byte3 = (unsigned char) (binary & 0xFF);
+
+	/* write RTC registers */
+	limit = 10;
+	do {
+		ds1374_write(client, DS1374_RTC_BASE, (u8 *) & rtc,
+					 sizeof(struct rtc_registers));
+		ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc1,
+					sizeof(struct rtc_registers));
+		binary1 = (rtc1.todc_byte0) + (rtc1.todc_byte1 << 8) +
+			(rtc1.todc_byte2 << 16) + (rtc1.todc_byte3 << 24);
+	} while ((binary1 != binary) && limit--);
+
+	if (binary1 != binary)
+		printk(KERN_DEBUG "ds1374_set_time: cannot set date on rtc\n");
+
+	return 0;
+}
+
+static const struct rtc_class_ops ds1374_rtc_ops = {
+	.read_time = ds1374_get_time,
+	.set_time = ds1374_set_time,
+};
+
+static int ds1374_probe(struct i2c_client *client,
+						const struct i2c_device_id *id)
+{
+	int ret;
+	struct ds1374 *ds1374;
+
+	ds1374 = kzalloc(sizeof(struct ds1374), GFP_KERNEL);
+	if (!ds1374)
+		return -ENOMEM;
+
+	ds1374->client = client;
+	i2c_set_clientdata(client, ds1374);
+
+	ds1374->rtc = rtc_device_register(ds1374_driver.driver.name, &client->dev,
+									  &ds1374_rtc_ops, THIS_MODULE);
+
+	if (IS_ERR(ds1374->rtc)) {
+		ret = PTR_ERR(ds1374->rtc);
+		dev_err(&client->dev, "unable to register the class device\n");
+		goto out_free;
+	}
+
+	return 0;
+
+out_free:
+	i2c_set_clientdata(client, NULL);
+	kfree(ds1374);
+	return ret;
+}
+
+static int ds1374_remove(struct i2c_client *client)
+{
+	struct ds1374 *ds1374 = i2c_get_clientdata(client);
+
+	rtc_device_unregister(ds1374->rtc);
+	i2c_set_clientdata(client, NULL);
+	kfree(ds1374);
+	return 0;
+}
+
+static struct i2c_driver ds1374_driver = {
+	.driver = {
+			   .name = "ds1374",
+			   },
+	.probe = ds1374_probe,
+	.remove = ds1374_remove,
+	.id_table = ds1374_id,
+};
+
+static int __init ds1374_init(void)
+{
+	printk("Registering Phoenix I2C based RTC driver...\n");
+	return i2c_add_driver(&ds1374_driver);
+}
+
+static void __exit ds1374_exit(void)
+{
+	i2c_del_driver(&ds1374_driver);
+}
+
+module_init(ds1374_init);
+module_exit(ds1374_exit);
+
+MODULE_AUTHOR("Jack Tan <jack.tan@windriver.com");
+MODULE_DESCRIPTION("Maxim DS1374 RTC Driver");
+MODULE_LICENSE("GPL");
-- 
1.7.0.4

