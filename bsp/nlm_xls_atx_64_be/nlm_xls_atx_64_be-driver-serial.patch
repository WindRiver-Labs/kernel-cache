From 21fbc970a54b9a556a864db81939cfc4035c3fcd Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 21 May 2010 13:07:28 +0800
Subject: [PATCH 21/38] nlm_xls_atx_64_be: driver serial

Introduce the serial driver which is specific to the rmi's implementation.

This patch is from RMI SDK 1.7.0

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/include/asm/serial.h   |   21 +++++++++++++
 arch/mips/rmi/phoenix/platform.c |    9 +++++-
 drivers/serial/8250.c            |   60 +++++++++++++++++++++++++++++++------
 drivers/serial/8250.h            |    1 +
 4 files changed, 80 insertions(+), 11 deletions(-)

diff --git a/arch/mips/include/asm/serial.h b/arch/mips/include/asm/serial.h
index a0cb0ca..46eeaff 100644
--- a/arch/mips/include/asm/serial.h
+++ b/arch/mips/include/asm/serial.h
@@ -1 +1,22 @@
 #include <asm-generic/serial.h>
+
+#ifdef CONFIG_RMI_PHOENIX
+#define STD_COM_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST)
+#include <asm/rmi/pic.h>
+#define RMI_PHOENIX_BASE_BAUD (66000000 / 16)
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS                                       \
+        { .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_0_IRQ,        \
+      .flags = STD_COM_FLAGS,\
+      .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_0_OFFSET), \
+      .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},  \
+        { .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_1_IRQ,         \
+      .flags = STD_COM_FLAGS, \
+      .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_1_OFFSET), \
+      .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},
+#else
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS
+#endif /* CONFIG_RMI_PHOENIX */
+
+
+#define SERIAL_PORT_DFNS                \
+    RMI_PHOENIX_SERIAL_PORT_DEFNS
diff --git a/arch/mips/rmi/phoenix/platform.c b/arch/mips/rmi/phoenix/platform.c
index 16780ef..48a764a 100644
--- a/arch/mips/rmi/phoenix/platform.c
+++ b/arch/mips/rmi/phoenix/platform.c
@@ -21,9 +21,16 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/resource.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+
 #ifdef CONFIG_RAPIDIO
 #include <asm/rmi/rmi_srio.h>
-#endif				/* CONFIG_RAPIDIO */
+#endif /* CONFIG_RAPIDIO */
+
+#include <asm/rmi/pic.h>
+
 static u64 xls_usb_dmamask = ~(u32) 0;
 
 static struct platform_device xls_usb_ehci_device = {
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 5b63294..dec17be 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -42,6 +42,7 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/rmi/iomap.h>
 
 #include "8250.h"
 
@@ -405,13 +406,21 @@ static void hub6_serial_out(struct uart_port *p, int offset, int value)
 static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
-	return readb(p->membase + offset);
+	struct uart_8250_port *up = (struct uart_8250_port *)p;
+	if (up->bugs & UART_BUG_RMI)
+		return phoenix_read_reg((phoenix_reg_t *)(p->membase + offset), 0);
+	else
+		return readb(p->membase + offset);
 }
 
 static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = map_8250_out_reg(p, offset) << p->regshift;
-	writeb(value, p->membase + offset);
+	struct uart_8250_port *up = (struct uart_8250_port *)p;
+	if (up->bugs & UART_BUG_RMI)
+		phoenix_write_reg((phoenix_reg_t *)(p->membase + offset), 0, value);
+	else
+		writeb(value, p->membase + offset);
 }
 
 static void mem32_serial_out(struct uart_port *p, int offset, int value)
@@ -1109,6 +1118,10 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	up->capabilities = 0;
 	up->bugs = 0;
 
+#ifdef CONFIG_RMI_PHOENIX
+	up->bugs |= UART_BUG_RMI;
+#endif
+
 	if (!(up->port.flags & UPF_BUGGY_UART)) {
 		/*
 		 * Do a simple existence test first; if we fail this,
@@ -1163,7 +1176,10 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	 */
 	if (!(up->port.flags & UPF_SKIP_TEST)) {
 		serial_outp(up, UART_MCR, UART_MCR_LOOP | 0x0A);
-		status1 = serial_inp(up, UART_MSR) & 0xF0;
+		if (up->bugs & UART_BUG_RMI)
+			status1 = (serial_inp(up, UART_MSR) ^ 0xF0) & 0xF0;
+		else
+			status1 = serial_inp(up, UART_MSR) & 0xF0;
 		serial_outp(up, UART_MCR, save_mcr);
 		if (status1 != 0x90) {
 			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
@@ -1283,11 +1299,20 @@ static void autoconfig_irq(struct uart_8250_port *up)
 	serial_outp(up, UART_MCR, 0);
 	udelay(10);
 	if (up->port.flags & UPF_FOURPORT) {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS);
+		if (up->bugs & UART_BUG_RMI)
+		        serial_outp(up, UART_MCR,
+				    (UART_MCR_DTR^0x1) | (UART_MCR_RTS^0x1));
+		else
+			serial_outp(up, UART_MCR,
+				    UART_MCR_DTR | UART_MCR_RTS);
+		
 	} else {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
+		if (up->bugs & UART_BUG_RMI)
+			serial_outp(up, UART_MCR,
+				(UART_MCR_DTR^0x1) | (UART_MCR_RTS^0x1)|UART_MCR_OUT2);
+		else
+			serial_outp(up, UART_MCR,
+				    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
 	}
 	serial_outp(up, UART_IER, 0x0f);	/* enable all intrs */
 	(void)serial_inp(up, UART_LSR);
@@ -1501,7 +1526,11 @@ static void transmit_chars(struct uart_8250_port *up)
 
 static unsigned int check_modem_status(struct uart_8250_port *up)
 {
-	unsigned int status = serial_in(up, UART_MSR);
+	unsigned int status;
+	if (up->bugs & UART_BUG_RMI)
+		status = serial_in(up, UART_MSR)^0xF0;
+	else
+		status = serial_in(up, UART_MSR);
 
 	status |= up->msr_saved_flags;
 	up->msr_saved_flags = 0;
@@ -1844,7 +1873,10 @@ static void serial8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	if (mctrl & TIOCM_LOOP)
 		mcr |= UART_MCR_LOOP;
 
-	mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
+	if (up->bugs & UART_BUG_RMI)
+		mcr = ((mcr & up->mcr_mask) | up->mcr_force | up->mcr)^0x3;
+	else
+		mcr = (mcr & up->mcr_mask) | up->mcr_force | up->mcr;
 
 	serial_out(up, UART_MCR, mcr);
 }
@@ -1885,7 +1917,11 @@ static void wait_for_xmitr(struct uart_8250_port *up, int bits)
 	if (up->port.flags & UPF_CONS_FLOW) {
 		unsigned int tmout;
 		for (tmout = 1000000; tmout; tmout--) {
-			unsigned int msr = serial_in(up, UART_MSR);
+			unsigned int msr;
+			if (up->bugs & UART_BUG_RMI)
+				msr = serial_in(up, UART_MSR)^0xF0;
+			else
+				msr = serial_in(up, UART_MSR);
 			up->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
 			if (msr & UART_MSR_CTS)
 				break;
@@ -2704,6 +2740,10 @@ static void __init serial8250_isa_init_ports(void)
 		up->mcr_force = ALPHA_KLUDGE_MCR;
 
 		up->port.ops = &serial8250_pops;
+
+#ifdef CONFIG_RMI_PHOENIX
+		up->bugs |= UART_BUG_RMI;
+#endif
 	}
 
 	if (share_irqs)
diff --git a/drivers/serial/8250.h b/drivers/serial/8250.h
index 2074ce1..d74366b 100644
--- a/drivers/serial/8250.h
+++ b/drivers/serial/8250.h
@@ -50,6 +50,7 @@ struct serial8250_config {
 #define UART_BUG_NOMSR	(1 << 2)	/* UART has buggy MSR status bits (Au1x00) */
 #define UART_BUG_THRE	(1 << 3)	/* UART has buggy THRE reassertion */
 #define UART_BUG_PPC	(1 << 4)	/* UART has buggy PPC break IRQ storm */
+#define UART_BUG_RMI	(1 << 5)	/* UART has buggy RMI */
 
 #define PROBE_RSA	(1 << 0)
 #define PROBE_ANY	(~0)
-- 
1.6.5.2

