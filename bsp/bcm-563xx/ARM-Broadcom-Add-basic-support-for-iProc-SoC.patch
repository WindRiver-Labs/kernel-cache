From 9d3ea5620ca09aaaa4518626c1f1440a04d43f61 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Thu, 15 May 2014 16:50:05 +0800
Subject: [PATCH 02/13] ARM: Broadcom: Add basic support for iProc SoC

Supoort iProc SoC based board.

[Original changes taken from iProcLDK_3.4.6.package.tgz]
[Just a minor modification in order to port to 3.10 kernel.]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/arm/Kconfig                                   |   26 +
 arch/arm/Makefile                                  |    2 +
 arch/arm/mach-iproc/Kconfig                        |   40 +
 arch/arm/mach-iproc/Makefile                       |    4 +
 arch/arm/mach-iproc/Makefile.boot                  |    2 +
 arch/arm/mach-iproc/board_bu.c                     |  725 +++++++++++++++++++
 arch/arm/mach-iproc/common.c                       |  204 ++++++
 arch/arm/mach-iproc/common.h                       |   29 +
 arch/arm/mach-iproc/flash.c                        |  272 +++++++
 arch/arm/mach-iproc/idm.c                          |  696 ++++++++++++++++++
 arch/arm/mach-iproc/include/mach/io_map.h          |   81 ++
 arch/arm/mach-iproc/include/mach/iproc_regs.h      |  633 ++++++++++++++++
 arch/arm/mach-iproc/include/mach/nand_iproc.h      |   37 +
 arch/arm/mach-iproc/include/mach/qspi_iproc.h      |   27 +
 arch/arm/mach-iproc/include/mach/reg_utils.h       |  160 ++++
 .../arm/mach-iproc/include/mach/socregs_ing_open.h |  762 ++++++++++++++++++++
 arch/arm/mach-iproc/include/mach/socregs_ns_open.h |   78 ++
 .../arm/mach-iproc/include/mach/socregs_nsp_open.h |  396 ++++++++++
 arch/arm/mach-iproc/io_map.c                       |   54 ++
 arch/arm/mach-iproc/northstar.c                    |  171 +++++
 arch/arm/mach-iproc/northstar.h                    |   27 +
 arch/arm/mach-iproc/northstar_dmu.c                |  719 ++++++++++++++++++
 arch/arm/mach-iproc/pm.c                           |   74 ++
 arch/arm/tools/mach-types                          |    1 +
 24 files changed, 5220 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-iproc/Kconfig
 create mode 100644 arch/arm/mach-iproc/Makefile
 create mode 100644 arch/arm/mach-iproc/Makefile.boot
 create mode 100644 arch/arm/mach-iproc/board_bu.c
 create mode 100644 arch/arm/mach-iproc/common.c
 create mode 100644 arch/arm/mach-iproc/common.h
 create mode 100644 arch/arm/mach-iproc/flash.c
 create mode 100644 arch/arm/mach-iproc/idm.c
 create mode 100644 arch/arm/mach-iproc/include/mach/io_map.h
 create mode 100644 arch/arm/mach-iproc/include/mach/iproc_regs.h
 create mode 100644 arch/arm/mach-iproc/include/mach/nand_iproc.h
 create mode 100644 arch/arm/mach-iproc/include/mach/qspi_iproc.h
 create mode 100644 arch/arm/mach-iproc/include/mach/reg_utils.h
 create mode 100644 arch/arm/mach-iproc/include/mach/socregs_ing_open.h
 create mode 100644 arch/arm/mach-iproc/include/mach/socregs_ns_open.h
 create mode 100644 arch/arm/mach-iproc/include/mach/socregs_nsp_open.h
 create mode 100644 arch/arm/mach-iproc/io_map.c
 create mode 100644 arch/arm/mach-iproc/northstar.c
 create mode 100644 arch/arm/mach-iproc/northstar.h
 create mode 100644 arch/arm/mach-iproc/northstar_dmu.c
 create mode 100644 arch/arm/mach-iproc/pm.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 831d50a..0e1e4c8 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -894,6 +894,28 @@ config ARCH_OMAP1
 	help
 	  Support for older TI OMAP1 (omap7xx, omap15xx or omap16xx)
 
+config ARCH_IPROC
+	bool "Broadcom ARMv7 iProc boards"
+	depends on MMU
+	select CPU_V7
+	select HAVE_CLK
+	select HAVE_SMP
+	select HAVE_MACH_CLKDEV
+	select COMMON_CLKDEV
+	select CLKDEV_LOOKUP
+	select ARM_GIC
+	select HAVE_ARM_TWD
+	select HAVE_ARM_SCU
+	select GENERIC_CLOCKEVENTS_BUILD
+	select GENERIC_CLOCKEVENTS
+	select LOCAL_TIMERS
+	select PCI
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	select CACHE_L2X0
+	select ARM_AMBA
+	help
+	 This is a common family of Broadcom Cortex A9 based boards
 endchoice
 
 menu "Multiple platform selection"
@@ -976,6 +998,10 @@ source "arch/arm/mach-iop33x/Kconfig"
 
 source "arch/arm/mach-iop13xx/Kconfig"
 
+source "arch/arm/plat-iproc/Kconfig"
+
+source "arch/arm/mach-iproc/Kconfig"
+
 source "arch/arm/mach-ixp4xx/Kconfig"
 
 source "arch/arm/mach-keystone/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 270b619..d0c8fb3 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -195,6 +195,7 @@ machine-$(CONFIG_PLAT_SPEAR)		+= spear
 machine-$(CONFIG_ARCH_VIRT)		+= virt
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_ARCH_SUNXI)		+= sunxi
+machine-$(CONFIG_MACH_IPROC)		+= iproc
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
@@ -206,6 +207,7 @@ plat-$(CONFIG_PLAT_PXA)		+= pxa
 plat-$(CONFIG_PLAT_S3C24XX)	+= samsung
 plat-$(CONFIG_PLAT_S5P)		+= samsung
 plat-$(CONFIG_PLAT_VERSATILE)	+= versatile
+plat-$(CONFIG_ARCH_IPROC)	+= iproc
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
diff --git a/arch/arm/mach-iproc/Kconfig b/arch/arm/mach-iproc/Kconfig
new file mode 100644
index 0000000..450b1ce
--- /dev/null
+++ b/arch/arm/mach-iproc/Kconfig
@@ -0,0 +1,40 @@
+menu	"iProc SoC based Machine types"
+	depends on MACH_IPROC
+
+choice
+	prompt "iProc SoC based board type"
+	default MACH_IPROC_NS	
+
+config MACH_NS
+	bool "Support Broadcom Northstar bring-up board"
+	help
+	  Support for the Broadcom Northstar bring-up board.
+
+config MACH_HX4
+	bool "Support Broadcom Helix4 bring-up board"
+	help
+	  Support for the Broadcom Helix4 bring-up board.
+
+config MACH_HR2
+	bool "Support Broadcom Hurricane2 bring-up board"
+	help
+	  Support for the Broadcom Hurricane2 bring-up board.
+
+config MACH_NSP
+	bool "Support Broadcom Northstar Plus bring-up board"
+	help
+	  Support for the Broadcom Northstar Plus bring-up board.
+
+config MACH_KT2
+	bool "Support Broadcom Katana2 bring-up board"
+	help
+	  Support for the Broadcom Katana2 bring-up board.
+
+endchoice
+
+config MACH_IPROC_EMULATION
+	bool "Support  iProc emulation"
+	help
+	  Support for the iProc emulation.
+
+endmenu
diff --git a/arch/arm/mach-iproc/Makefile b/arch/arm/mach-iproc/Makefile
new file mode 100644
index 0000000..18210b6
--- /dev/null
+++ b/arch/arm/mach-iproc/Makefile
@@ -0,0 +1,4 @@
+obj-y := io_map.o northstar.o common.o northstar_dmu.o board_bu.o idm.o
+
+obj-$(CONFIG_PM) += pm.o
+obj-$(CONFIG_MTD) += flash.o
diff --git a/arch/arm/mach-iproc/Makefile.boot b/arch/arm/mach-iproc/Makefile.boot
new file mode 100644
index 0000000..2de985c
--- /dev/null
+++ b/arch/arm/mach-iproc/Makefile.boot
@@ -0,0 +1,2 @@
+zreladdr-y      := $(CONFIG_BCM_ZRELADDR)
+params_phys-y   := $(CONFIG_BCM_PARAMS_PHYS)
diff --git a/arch/arm/mach-iproc/board_bu.c b/arch/arm/mach-iproc/board_bu.c
new file mode 100644
index 0000000..2f91cdc
--- /dev/null
+++ b/arch/arm/mach-iproc/board_bu.c
@@ -0,0 +1,725 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/clkdev.h>
+
+
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+#include <linux/i2c/tsc2007.h>
+#include <linux/spi/spi.h>
+#include <mach/hardware.h>
+#include <asm/mach/arch.h>
+#include <asm/mach-types.h>
+#include <mach/sdio_platform.h>
+#include <mach/iproc.h>
+#include <asm/io.h>
+#include <mach/io_map.h>
+#include <mach/reg_utils.h>
+#include <linux/pwm.h>
+#include <linux/amba/bus.h>
+
+
+#include "northstar.h"
+#include "common.h"
+
+#if defined(CONFIG_IPROC_SD) || defined(CONFIG_IPROC_SD_MODULE)
+#define IPROC_SDIO_PA   	IPROC_SDIO3_REG_BASE
+#define SDIO_CORE_REG_SIZE	0x10000
+#define BSC_CORE_REG_SIZE	0x1000
+#define SDIO_IDM_IDM_RESET_CONTROL  (0x16800)
+#define IPROC_SDIO_IRQ		(177)
+#endif
+
+#if defined(CONFIG_MACH_NSP)
+#define SATA_M0_IDM_IO_CONTROL_DIRECT_VA   HW_IO_PHYS_TO_VIRT(SATA_M0_IDM_IO_CONTROL_DIRECT)
+#define SATA_M0_IDM_IDM_RESET_CONTROL_VA   HW_IO_PHYS_TO_VIRT(SATA_M0_IDM_IDM_RESET_CONTROL)
+#define SATA_TOP_CTRL_BUS_CTRL_VA   HW_IO_PHYS_TO_VIRT(SATA_TOP_CTRL_BUS_CTRL)
+#define SATA3_PCB_UPPER_REG15_VA   HW_IO_PHYS_TO_VIRT(SATA3_PCB_UPPER_REG15)
+#define SATA3_PCB_UPPER_REG0_VA   HW_IO_PHYS_TO_VIRT(SATA3_PCB_UPPER_REG0)
+#define SATA3_PCB_UPPER_REG1_VA   HW_IO_PHYS_TO_VIRT(SATA3_PCB_UPPER_REG1)
+#define SATA3_PCB_UPPER_REG11_VA   HW_IO_PHYS_TO_VIRT(SATA3_PCB_UPPER_REG11)
+#define SATA3_PCB_UPPER_REG5_VA   HW_IO_PHYS_TO_VIRT(SATA3_PCB_UPPER_REG5)
+#define BCM_INT_SATA 190
+#endif
+
+extern void request_idm_timeout_interrupts(void);
+extern irqreturn_t idm_timeout_handler(int val, void *ptr);
+extern void*	bcm5301x_otp_init(void);
+extern int	bcm5301x_otp_exit(void);
+extern int	bcm5301x_otp_read_dword(void *oh, uint wn, u32 *data);
+
+
+/* This is the main reference clock 25MHz from external crystal */
+static struct clk clk_ref = {
+	.name = "Refclk",
+	.rate = 25 * 1000000,   /* run-time override */
+	.fixed = 1,
+	.type  = 0,
+};
+
+
+static struct clk_lookup board_clk_lookups[] = {
+	{
+	.con_id         = "refclk",
+	.clk            = &clk_ref,
+	}
+};
+
+extern void __init northstar_timer_init(struct clk *clk_ref);
+
+#if defined(CONFIG_IPROC_SD) || defined(CONFIG_IPROC_SD_MODULE)
+/* sdio */
+static struct sdio_platform_cfg sdio_platform_data = {
+	.devtype = SDIO_DEV_TYPE_SDMMC,
+};
+static struct resource sdio_resources[] = {
+	[0] = {
+		.start	= IPROC_SDIO_PA,
+		.end	= IPROC_SDIO_PA + BSC_CORE_REG_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IPROC_SDIO_IRQ,
+		.end	= IPROC_SDIO_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device board_sdio_device = {
+	.name		=	"iproc-sdio",
+	.id		=	0,
+	.dev		=	{
+		.platform_data	= &sdio_platform_data,
+	},
+	.num_resources  = ARRAY_SIZE(sdio_resources),
+  	.resource	= sdio_resources,
+};
+
+static void setup_sdio(void)
+{
+    void __iomem *idm_base;
+    struct platform_device *sdio_plat_dev[1];    
+    idm_base = (void __iomem *)IPROC_IDM_REGISTER_VA;
+	printk("%s: %d %08x\n", __FUNCTION__, __LINE__, idm_base + SDIO_IDM_IDM_RESET_CONTROL);
+    __raw_writel(0, idm_base + SDIO_IDM_IDM_RESET_CONTROL);
+    sdio_plat_dev[0] = &board_sdio_device;
+    platform_add_devices(sdio_plat_dev, 1);
+
+}
+#endif /* CONFIG_IPROC_SD || CONFIG_IPROC_SD_MODULE */
+
+#if defined(CONFIG_IPROC_PWM) || defined(CONFIG_IPROC_PWM_MODULE)
+static struct resource iproc_pwm_resources = {
+	.start	= IPROC_CCB_PWM_CTL,
+	.end	= IPROC_CCB_PWM_CTL + SZ_4K - 1,
+	.flags	= IORESOURCE_MEM,
+};
+
+static struct platform_device board_pwm_device = {
+	.name		= "iproc_pwmc",
+	.id	        = -1,
+  	.resource	= &iproc_pwm_resources,
+  	.num_resources  = 1,
+};
+static struct pwm_lookup board_pwm_lookup[] = {
+    PWM_LOOKUP("iproc_pwmc", 0,"iproc_pwmc","pwm-0"),
+    PWM_LOOKUP("iproc_pwmc", 1,"iproc_pwmc","pwm-1"),        
+    PWM_LOOKUP("iproc_pwmc", 2,"iproc_pwmc","pwm-2"),
+    PWM_LOOKUP("iproc_pwmc", 3,"iproc_pwmc","pwm-3"),
+
+};
+
+#endif /* CONFIG_IPROC_PWM || CONFIG_IPROC_PWM_MODULE */
+
+#if defined(CONFIG_IPROC_WDT) || defined(CONFIG_IPROC_WDT_MODULE)
+/* watchdog */
+static struct resource wdt_resources[] = {
+	[0] = {
+		.start	= IPROC_CCA_REG_BASE,
+		.end	= IPROC_CCA_REG_BASE + 0x1000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device board_wdt_device = {
+	.name		=	"iproc_wdt",
+	.id		    =	-1,
+	.num_resources  = ARRAY_SIZE(wdt_resources),
+  	.resource	= wdt_resources,
+};
+#endif /* CONFIG_IPROC_WDT || CONFIG_IPROC_WDT_MODULE */
+
+#if defined(CONFIG_IPROC_CCB_WDT) || defined(CONFIG_IPROC_CCB_WDT_MODULE)
+static AMBA_APB_DEVICE(sp805_wdt, "sp805-wdt", 0x00141805, 
+								IPROC_CCB_WDT_REG_BASE, { }, NULL);
+#endif
+
+#if defined(CONFIG_IPROC_CCB_TIMER) || defined(CONFIG_IPROC_CCB_TIMER_MODULE)
+static struct resource ccb_timer_resources[] = {
+	[0] = {
+		.start	= IPROC_CCB_TIM0_REG_VA,
+		.end	= IPROC_CCB_TIM0_REG_VA + 0x1000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= IPROC_CCB_TIM1_REG_VA,
+		.end	= IPROC_CCB_TIM1_REG_VA + 0x1000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= IPROC_CCB_TIMER_INT_START,
+		.end	= IPROC_CCB_TIMER_INT_START + IPROC_CCB_TIMER_INT_COUNT - 1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device board_timer_device = {
+	.name		=	"iproc_ccb_timer",
+	.id		    =	-1,
+	.num_resources  = ARRAY_SIZE(ccb_timer_resources),
+  	.resource	= ccb_timer_resources,
+};
+#endif /* CONFIG_IPROC_CCB_TIMER || CONFIG_IPROC_CCB_TIMER_MODULE */
+
+#if defined(CONFIG_IPROC_FA2)
+#if defined(CONFIG_MACH_NSP)
+static struct resource fa2_resources[] = {
+    [0] = {
+        .start  = CTF_CONTROL_REG, /* Macro is in socregs_nsp.h */
+        .end    = CTF_CONTROL_REG + SZ_1K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = 178, 
+        .end    = 178,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+#endif
+#endif /* CONFIG_IPROC_FA2 */
+
+#ifdef CONFIG_IPROC_I2C
+/* SMBus (I2C/BSC) block */
+
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+/* Helix4 */
+static struct resource smbus_resources[] = {
+    [0] = {
+        .start  = ChipcommonB_SMBus_Config, /* Macro is in socregs_hx4.h */
+        .end    = ChipcommonB_SMBus_Config + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = 127, 
+        .end    = 127,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+
+static struct resource smbus_resources1[] = {
+    [0] = {
+        .start  = ChipcommonB_SMBus1_SMBus_Config, /* Macro is in socregs_hx4.h */
+        .end    = ChipcommonB_SMBus1_SMBus_Config + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM
+    },
+    [1] = {
+        .start  = 128, /* macro in irqs.h (plat-iproc) */
+        .end    = 128,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+#elif defined(CONFIG_MACH_NSP)
+/* Northstar plus */
+static struct resource smbus_resources[] = {
+    [0] = {
+        .start  = ChipcommonB_SMBus_Config, /* Macro is in socregs_hx4.h */
+        .end    = ChipcommonB_SMBus_Config + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = 121, 
+        .end    = 121,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+#else
+/* Northstar */
+static struct resource smbus_resources[] = {
+    [0] = {
+        .start  = CCB_SMBUS_START, /* Define this macro is socregs.h, or
+                                    in iproc_regs.h */
+        .end    = CCB_SMBUS_START + SZ_4K - 1,
+        .flags  = IORESOURCE_MEM,
+    },
+    [1] = {
+        .start  = BCM_INT_ID_CCB_SMBUS, /* macro in irqs.h (plat-iproc) */
+        .end    = BCM_INT_ID_CCB_SMBUS,
+        .flags  = IORESOURCE_IRQ,
+    }
+};
+#endif
+
+/* Common to Northstar, Helix4 */
+static struct platform_device board_smbus_device = {
+    .name= "iproc-smb",
+    .id = 0,
+    .dev= {
+        .platform_data  = NULL, /* Can be defined, if reqd */
+    },
+    .num_resources = ARRAY_SIZE(smbus_resources),
+    .resource = smbus_resources,
+};
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+static struct platform_device board_smbus_device1 = {
+    .name= "iproc-smb",
+    .id = 1,
+    .dev= {
+        .platform_data  = NULL, /* Can be defined, if reqd */
+    },
+    .num_resources = ARRAY_SIZE(smbus_resources1),
+    .resource = smbus_resources1,
+};
+
+#endif /* CONFIG_MACH_HX4 */
+
+#endif /* CONFIG_IPROC_I2C */
+
+#if defined(CONFIG_IPROC_FA2)
+#if defined(CONFIG_MACH_NSP)
+static struct platform_device board_fa2_device = {
+    .name= "fa2",
+    .id = 0,
+    .dev= {
+        .platform_data  = NULL, /* Can be defined, if reqd */
+    },
+    .num_resources = ARRAY_SIZE(fa2_resources),
+    .resource = fa2_resources,
+};
+#endif
+#endif /* CONFIG_IPROC_FA2 */
+
+#ifdef CONFIG_IPROC_USB3H
+static struct resource bcm_xhci_resources[] = {
+        [0] = {
+                .start  = USB30_BASE,
+                .end    = USB30_BASE + SZ_4K - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = BCM_INT_ID_USB3H2CORE_USB2_INT0,
+                .end    = BCM_INT_ID_USB3H2CORE_USB2_INT0,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+
+static u64 xhci_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device bcm_xhci_device = {
+	.name		=	"bcm-xhci",
+	.id		=	0,
+	.dev		=	{
+//		 .platform_data	= &xhci_platform_data,
+		 .dma_mask       = &xhci_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+  	.resource	= bcm_xhci_resources,
+	.num_resources  = ARRAY_SIZE(bcm_xhci_resources),
+};
+#endif /* CONFIG_IPROC_USB3 */
+
+#ifdef CONFIG_USB_EHCI_BCM
+
+static u64 ehci_dmamask = DMA_BIT_MASK(32);
+
+static struct resource usbh_ehci_resource[] = {
+	[0] = {
+		.start = IPROC_USB20_REG_BASE,
+		.end = IPROC_USB20_REG_BASE + 0x0FFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = BCM_INT_ID_USB2H2CORE_USB2_INT,
+		.end = BCM_INT_ID_USB2H2CORE_USB2_INT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usbh_ehci_device =
+{
+	.name = "bcm-ehci",
+	.id = 0,
+	.resource = usbh_ehci_resource,
+	.num_resources = ARRAY_SIZE(usbh_ehci_resource),
+	.dev = {
+		.dma_mask = &ehci_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+#endif
+
+#ifdef CONFIG_USB_OHCI_BCM
+
+static u64 ohci_dmamask = DMA_BIT_MASK(32);
+
+static struct resource usbh_ohci_resource[] = {
+	[0] = {
+		.start = IPROC_USB20_REG_BASE + 0x1000,
+		.end = IPROC_USB20_REG_BASE + 0x1000 + 0x0FFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = BCM_INT_ID_USB2H2CORE_USB2_INT,
+		.end = BCM_INT_ID_USB2H2CORE_USB2_INT,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device usbh_ohci_device =
+{
+	.name = "bcm-ohci",
+	.id = 0,
+	.resource = usbh_ohci_resource,
+	.num_resources = ARRAY_SIZE(usbh_ohci_resource),
+	.dev = {
+		.dma_mask = &ohci_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+#endif
+
+#ifdef CONFIG_SATA_AHCI_PLATFORM
+static struct resource bcm_sata_resources[] = {
+        [0] = {
+                .start  = SATA_AHCI_GHC_HBA_CAP,
+                .end    = SATA_AHCI_GHC_HBA_CAP + SZ_4K - 1,
+                .flags  = IORESOURCE_MEM,
+        },
+        [1] = {
+                .start  = BCM_INT_SATA,
+                .end    = BCM_INT_SATA,
+                .flags  = IORESOURCE_IRQ,
+        },
+};
+static u64 sata_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device bcm_sata_device = {
+	.name		=	"strict-ahci",
+	.id		=	0,
+	.dev		=	{
+		 .dma_mask       = &sata_dmamask,
+		 .coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+  	.resource	= bcm_sata_resources,
+	.num_resources  = ARRAY_SIZE(bcm_sata_resources),
+};
+#endif
+
+#ifdef CONFIG_DMAC_PL330
+#include "pl330-pdata.h"
+static struct iproc_pl330_data iproc_pl330_pdata =	{
+	/* Non Secure DMAC virtual base address */
+	.dmac_ns_base = IPROC_DMAC_REG_VA,
+	/* Secure DMAC virtual base address */
+	.dmac_s_base = IPROC_DMAC_REG_VA,
+	/* # of PL330 dmac channels 'configurable' */
+	.num_pl330_chans = 8,
+	/* irq number to use */
+	.irq_base = BCM_INT_ID_DMAC,
+	/* # of PL330 Interrupt lines connected to GIC */
+	.irq_line_count = 16,
+};
+
+static struct platform_device pl330_dmac_device = {
+	.name = "iproc-dmac-pl330",
+	.id = 0,
+	.dev = {
+		.platform_data = &iproc_pl330_pdata,
+		.coherent_dma_mask  = DMA_BIT_MASK(64),
+	},
+};
+#endif
+
+
+#if defined(CONFIG_MACH_NSP)
+void config_AHCI( void )
+{
+	volatile unsigned int sata_clk_enable;
+	volatile unsigned int bustopcfg;
+
+	printk("\nConfigure AHCI ...\n");
+	sata_clk_enable = __raw_readl(SATA_M0_IDM_IO_CONTROL_DIRECT_VA);
+    sata_clk_enable |= 0x1;
+    __raw_writel( sata_clk_enable, SATA_M0_IDM_IO_CONTROL_DIRECT_VA);
+    sata_clk_enable = __raw_readl(SATA_M0_IDM_IO_CONTROL_DIRECT_VA);
+    udelay(1000);
+
+
+    /* Reset core */
+    __raw_writel(0x0, SATA_M0_IDM_IDM_RESET_CONTROL_VA);
+    udelay(1000);
+    sata_clk_enable = __raw_readl(SATA_M0_IDM_IDM_RESET_CONTROL_VA);
+    bustopcfg = __raw_readl(SATA_TOP_CTRL_BUS_CTRL_VA);
+    bustopcfg &= ~ (( 3 << 2) | ( 3 << 4 ));
+    bustopcfg |= (( 2 << 2) | ( 2 << 4 ));//| ( 2<< 6 ));
+    //bustopcfg |= ( ( 0x2 << 8 ) | ( 0x2 << 17 ) );
+    __raw_writel(bustopcfg, SATA_TOP_CTRL_BUS_CTRL_VA);
+}
+void configure_SATA_PHY ( void )
+{
+	unsigned int i;
+	printk("\nConfigure PHY ...\n");
+
+	__raw_writel(0x0150,SATA3_PCB_UPPER_REG15_VA);
+	__raw_writel( 0xF6F6, SATA3_PCB_UPPER_REG0_VA);
+	__raw_writel( 0x2e96, SATA3_PCB_UPPER_REG1_VA);
+
+	__raw_writel(0x0160,SATA3_PCB_UPPER_REG15_VA);
+	__raw_writel( 0xF6F6, SATA3_PCB_UPPER_REG0_VA);
+	__raw_writel( 0x2e96, SATA3_PCB_UPPER_REG1_VA);
+
+	//access SATA PLL
+	__raw_writel(0x0050,SATA3_PCB_UPPER_REG15_VA);
+	//Audio PLL 0x8B
+	i = __raw_readl(SATA3_PCB_UPPER_REG11_VA);
+	i &= ~ (( 0x1f) << 9 );
+	i |= ( 0xC << 9);
+	__raw_writel( i, SATA3_PCB_UPPER_REG11_VA);
+
+	//Sequence for restarting PLL. Please try after changing the divider.
+	//'PLL_CapCtrl[10] = 1, PLL_CapCtrl[7:0] = F0h
+	//SATA3_PLL: PLL Register Bank address 0x50
+
+	//set register SATA3_PLL_capControl ( 0x85 )
+	i = __raw_readl(SATA3_PCB_UPPER_REG5_VA);
+	i =  ( i | 0x4f0 ) & 0xFF0;
+	__raw_writel( i, SATA3_PCB_UPPER_REG5_VA);
+
+	//'PLL_Ctrl[13:12] = 11
+	//Set register SATA3_PLL_CONTROL ( 0x81 )
+	i = __raw_readl(SATA3_PCB_UPPER_REG1_VA);
+	i |= 0x3000;
+	__raw_writel( i, SATA3_PCB_UPPER_REG1_VA);
+
+	//'PLL_ReStart
+	i = __raw_readl(SATA3_PCB_UPPER_REG1_VA);
+	i &= 0x7FFF;
+	__raw_writel( i, SATA3_PCB_UPPER_REG1_VA);
+	mdelay(100);
+	i = __raw_readl(SATA3_PCB_UPPER_REG1_VA);
+	i |= 0x8000;
+	__raw_writel( i, SATA3_PCB_UPPER_REG1_VA);
+	mdelay(1000);
+	__raw_writel(0x0000,SATA3_PCB_UPPER_REG15_VA);
+	i = __raw_readl(SATA3_PCB_UPPER_REG1_VA);
+}
+#endif
+
+
+void __init board_map_io(void)
+{
+
+	/*
+	 * Install clock sources in the lookup table.
+	 */
+	clkdev_add_table(board_clk_lookups,
+			ARRAY_SIZE(board_clk_lookups));
+
+	/* Map machine specific iodesc here */
+	northstar_map_io();
+}
+
+void __init iproc_init_early(void)
+{
+
+	/*
+	 * SDK allocates coherent buffers from atomic
+	 * context. Increase size of atomic coherent pool to make sure such
+	 * the allocations won't fail.
+	 */
+#ifdef CONFIG_CMA 
+	init_dma_coherent_pool_size(SZ_1M * 16);
+#endif
+}
+
+static struct platform_device *board_sata_device[] __initdata = {
+#ifdef CONFIG_SATA_AHCI_PLATFORM
+	&bcm_sata_device,
+#endif
+};
+
+static struct platform_device *board_devices[] __initdata = {
+#ifdef CONFIG_IPROC_I2C
+    &board_smbus_device,
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+    &board_smbus_device1,
+#endif
+#endif /* CONFIG_IPROC_I2C */
+
+#if defined(CONFIG_IPROC_FA2)
+#if defined(CONFIG_MACH_NSP)
+    &board_fa2_device,
+#endif
+#endif /* FA+ */
+
+#if defined(CONFIG_IPROC_CCB_TIMER) || defined(CONFIG_IPROC_CCB_TIMER_MODULE)
+    &board_timer_device,
+#endif /* CONFIG_IPROC_CCB_TIMER || CONFIG_IPROC_CCB_TIMER_MODULE */
+#if defined(CONFIG_IPROC_WDT) || defined(CONFIG_IPROC_WDT_MODULE)
+    &board_wdt_device,
+#endif /* CONFIG_IPROC_WDT || CONFIG_IPROC_WDT_MODULE */
+#if defined(CONFIG_IPROC_PWM) || defined(CONFIG_IPROC_PWM_MODULE)
+	&board_pwm_device,
+#endif /* CONFIG_IPROC_PWM || CONFIG_IPROC_PWM_MODULE */
+#ifdef CONFIG_IPROC_USB3H
+	&bcm_xhci_device,
+#endif
+#ifdef CONFIG_USB_EHCI_BCM
+	&usbh_ehci_device,
+#endif
+#ifdef CONFIG_USB_OHCI_BCM
+	&usbh_ohci_device,
+#endif
+#ifdef CONFIG_DMAC_PL330
+	&pl330_dmac_device,
+#endif
+};
+
+static struct amba_device *amba_devs[] __initdata = {
+#if defined(CONFIG_IPROC_CCB_WDT) || defined(CONFIG_IPROC_CCB_WDT_MODULE)
+	&sp805_wdt_device,
+#endif
+};
+
+static void __init board_add_devices(void)
+{
+	int i;
+
+	platform_add_devices(board_devices, ARRAY_SIZE(board_devices));
+//    if (iproc_get_chipid() == 53010) {
+//    }
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		amba_device_register(amba_devs[i], &iomem_resource);
+	}
+}
+
+static void __init board_add_sata_device(void)
+{
+	platform_add_devices(board_sata_device, 1);
+}
+
+
+/* SPI device info of GSIO(SPI) interface */
+static struct spi_board_info bcm5301x_spi_device[] = {
+	{
+		.modalias = "spidev",
+		.platform_data = NULL,
+		.controller_data = NULL,
+		.max_speed_hz = 2 * 1000 * 1000,
+		.bus_num = 0,
+		.chip_select = 0,
+		.mode = SPI_MODE_0,
+	},
+};
+
+void __init board_timer_init(void)
+{
+	northstar_timer_init(&clk_ref);
+}
+
+void __init board_init(void)
+{
+	printk(KERN_DEBUG "board_init: Enter\n");
+
+	/*
+	 * Add common platform devices that do not have board dependent HW
+	 * configurations
+	 */
+	uint32_t	sata_enable=0;
+	board_add_common_devices(&clk_ref);
+#ifndef CONFIG_MACH_NS
+	/* register IDM timeout interrupt handler */
+	request_idm_timeout_interrupts();
+#endif
+
+#if defined(CONFIG_MACH_NSP)
+	/* read otp row 0xd to figure if sata is enabled */
+
+	void		*oh;
+	
+	oh = bcm5301x_otp_init();
+	if (oh != NULL)
+	{
+		bcm5301x_otp_read_dword(oh, 0xd, &sata_enable);
+		printk(KERN_DEBUG "%s: %d %08x\n", __FUNCTION__, __LINE__, sata_enable);
+		if ((sata_enable & 0x40000000) == 0x40000000)
+		{
+			config_AHCI();
+			configure_SATA_PHY();
+		}
+		bcm5301x_otp_exit();
+	}
+	else
+		printk(KERN_DEBUG "%s: %d bcm5301x_otp_init failed\n", __FUNCTION__, __LINE__);
+
+#endif
+
+	board_add_devices();
+	if ((sata_enable & 0x40000000) == 0x40000000)
+		board_add_sata_device();
+
+
+#if defined(CONFIG_IPROC_SD) || defined(CONFIG_IPROC_SD_MODULE)   
+	/* only bcm53012 support sdio */
+	if ((__REG32(IPROC_IDM_REGISTER_VA + 0xd500) & 0xc) == 0x0) {
+		setup_sdio();
+	}
+#endif
+
+#if defined(CONFIG_IPROC_PWM) || defined(CONFIG_IPROC_PWM_MODULE)
+        __raw_writel(0xf, IPROC_CCB_GPIO_REG_VA + IPROC_GPIO_CCB_AUX_SEL);
+    	pwm_add_table(board_pwm_lookup, ARRAY_SIZE(board_pwm_lookup));
+#endif  
+
+	/* Register SPI device info */
+	spi_register_board_info(bcm5301x_spi_device, 
+	ARRAY_SIZE(bcm5301x_spi_device));
+
+
+	printk(KERN_DEBUG "board_init: Leave\n");
+}
+
+MACHINE_START(IPROC, "Broadcom iProc")
+
+// 	Used micro9 as a reference.  Micro9 removed these two fields,
+//	and replaced them with a call to ep93xx_map_io(), which in turn
+// 	calls iotable_init().  Northstar appears to have an equivalent
+//	init (refer to northstar_io_desc[] array, in io_map.c
+	.smp = smp_ops(iproc_smp_ops),
+	.map_io = board_map_io,
+	.init_early	= iproc_init_early,
+	.init_irq = iproc_init_irq,
+	.init_time  = board_timer_init,
+	.init_machine = board_init,
+MACHINE_END
diff --git a/arch/arm/mach-iproc/common.c b/arch/arm/mach-iproc/common.c
new file mode 100644
index 0000000..a3291bf
--- /dev/null
+++ b/arch/arm/mach-iproc/common.c
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/serial_8250.h>
+#include <linux/io.h>
+#include <asm/mach-types.h>
+#include <asm/pgtable.h>
+#include <asm/clkdev.h>
+//#include <mach/clkdev.h>
+#include <mach/hardware.h>
+#include <mach/iproc.h>
+#include <mach/irqs.h>
+
+#define IPROC_UART0_PA		IPROC_CCA_UART0_REG_BASE
+#define IPROC_UART1_PA		IPROC_CCA_UART1_REG_BASE
+#define IPROC_CCA_UART_CLK_PA	IPROC_CCA_UART_CLK_REG_BASE
+#define IPROC_CCA_CCAP_PA	IPROC_CCA_CORE_CAP_REG_BASE
+#define IPROC_CCA_CCTL_PA	IPROC_CCA_CORE_CTL_REG_BASE
+#define IPROC_CCA_INTMASK_PA	IPROC_CCA_INTMASK_REG_BASE
+
+#define IPROC_UART0_VA		HW_IO_PHYS_TO_VIRT(IPROC_UART0_PA)
+#define IPROC_UART1_VA		HW_IO_PHYS_TO_VIRT(IPROC_UART1_PA)
+#define IPROC_CCA_UART_CLK_VA	HW_IO_PHYS_TO_VIRT(IPROC_CCA_UART_CLK_PA)
+#define IPROC_CCA_CCAP_VA	HW_IO_PHYS_TO_VIRT(IPROC_CCA_CCAP_PA)
+#define IPROC_CCA_CCTL_VA	HW_IO_PHYS_TO_VIRT(IPROC_CCA_CCTL_PA)
+#define IPROC_CCA_INTMASK_VA	HW_IO_PHYS_TO_VIRT(IPROC_CCA_INTMASK_PA)
+
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+#define IRQ_IPROC_UART0  117
+#elif (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2))
+#define IRQ_IPROC_UART0  123
+#elif defined(CONFIG_MACH_HR2)
+#define IRQ_IPROC_UART0  123
+#else
+#error "No valid UART IRQ selected"
+#endif
+
+#if defined(CONFIG_MACH_HR2) && defined(CONFIG_MACH_IPROC_EMULATION)
+#define IPROC_UART_CLK (76800)
+#elif defined(CONFIG_MACH_KT2) && defined(CONFIG_MACH_IPROC_EMULATION)
+#define IPROC_UART_CLK (76800)
+#else
+#define IPROC_UART_CLK (62500000)
+#endif
+
+#define IPROC_8250PORT(name)						\
+{									\
+	.membase    = (void __iomem *)(IPROC_##name##_VA),		\
+	.mapbase    = (resource_size_t)(IPROC_##name##_PA),		\
+	.irq        = IRQ_IPROC_UART0,					\
+	.uartclk    = IPROC_UART_CLK,						\
+	.regshift   = 0,						\
+	.iotype     = UPIO_MEM,						\
+	.type       = PORT_16550A,					\
+	.flags      = UPF_FIXED_TYPE | UPF_SHARE_IRQ,			\
+	.private_data = (void __iomem *)((IPROC_##name##_VA) + 0x00),	\
+}
+
+static struct plat_serial8250_port uart_data[] = {
+#if (defined(CONFIG_MACH_HR2) && !defined(CONFIG_MACH_IPROC_EMULATION))
+	IPROC_8250PORT(UART1), /* Use UART2 as ttys0 */
+	IPROC_8250PORT(UART0),
+#else
+	IPROC_8250PORT(UART0),
+	IPROC_8250PORT(UART1),
+#endif
+	{ .flags = 0, },
+};
+
+static struct platform_device board_serial_device = {
+	.name = "serial8250",
+	.id = PLAT8250_DEV_PLATFORM,
+	.dev = {
+	.platform_data = uart_data,
+	},
+};
+
+#if defined(CONFIG_MPCORE_WATCHDOG)
+static struct resource wdt_device_resource[] = {
+	[0] = {
+	.start = IPROC_PERIPH_PVT_TIM_REG_BASE,
+	.end   = IPROC_PERIPH_PVT_TIM_REG_BASE + 0x34,
+	.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+	.start = BCM_INT_ID_CCB_TIM1_INT2,
+	.end   = BCM_INT_ID_CCB_TIM1_INT2,
+	.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device wdt_device =
+{
+	.name          = "mpcore_wdt",
+	.id            = -1,
+	.resource      = wdt_device_resource,
+	.num_resources = ARRAY_SIZE(wdt_device_resource),
+};
+#endif
+
+/* Common devices among all Northstar boards */
+//static struct platform_device *board_common_plat_devices[] __initdata = {
+//	&board_serial_device,
+//#if defined(CONFIG_MPCORE_WATCHDOG)
+//	&wdt_device,
+//#endif
+//};
+
+void __init iproc_config_boot_console(struct clk *ref_clk)
+{
+	u32 i;
+	u32 clk_rate = 0;
+	u8 uart_clk_sel;
+	u8 uart_clk_ovr;
+	u16 uart_clk_div;
+	struct clk * clk = NULL ;
+
+	/* Get Core Capabilities Register, and extract
+	   UART Clock Select from bits 4..3 which show
+	   the clock source.  Values are:
+	    	0 = 25Mhz clock input
+	    	1 = Internal clock
+	    	2 = reserved
+	    	3 = reserved
+	*/
+	uart_clk_sel = (readl(IPROC_CCA_CCAP_VA) >> 3) & 0x3;
+
+	/* Get UARTClkOvr from bit 0 of the Core Control Register
+	   If set, this bit indicates that the UART clock is supplied
+	   from the internal ALP (APB) clock.  If clear then it indicates
+	   that APBX_IDM_IO_CONTROL_DIRECT register bit UARTClkSel controls
+	   the clock source
+	*/
+	uart_clk_ovr = readl(IPROC_CCA_CCTL_VA) & 0x01;
+
+	/* uart_clk_div: ChipcommonA_ClkDiv bits 0..7 */
+	uart_clk_div =  0xff & readl(IPROC_CCA_UART_CLK_VA);
+	if( uart_clk_div == 0 )
+		uart_clk_div = 0x100 ;
+
+	if( uart_clk_sel == 0 ) {
+		/* uart_clk_sel = 0 -> external reference clock source */
+		clk = ref_clk ;
+		BUG_ON( !clk );
+		clk_rate = clk_get_rate(clk);
+	} else if( uart_clk_sel == 1 ) {
+		/* uart_clk_sel = 1 -> Internal clock optionally divided */
+		clk = clk_get_sys( "iproc_slow", "c_clk125" );
+		BUG_ON( !clk );
+#if defined(CONFIG_MACH_IPROC_EMULATION)
+		clk_rate = IPROC_UART_CLK ;
+#else
+		clk_rate = clk_get_rate(clk) ;
+#endif
+
+		if( ! uart_clk_ovr )
+			clk_rate /= uart_clk_div;
+	}
+
+	printk( KERN_INFO "Sel=%d Ovr=%d Div=%d\n", uart_clk_sel, uart_clk_ovr, uart_clk_div );
+	printk( KERN_INFO "UART clock rate %u\n", clk_rate );
+
+	/* fixup UART port structure */
+	for(i = 0; i < ARRAY_SIZE(uart_data); i++ ) {
+		if( uart_data[i].flags == 0 )
+			break;
+		if( uart_data[i].irq == 0 )
+			uart_data[i].flags |= UPF_AUTO_IRQ;
+
+		uart_data[i].uartclk = clk_rate ;
+	}
+
+	/* Install SoC devices in the system: uarts */
+	platform_device_register(&board_serial_device);
+
+	/* Enable UART interrupt in ChipcommonA */
+	i = readl(IPROC_CCA_INTMASK_VA);
+	i |= 1 << 6;
+	writel(i, IPROC_CCA_INTMASK_VA);
+}
+
+void __init board_add_common_devices(struct clk *ref_clk)
+{
+	/*
+	 * Configure boot console
+	 */
+	iproc_config_boot_console(ref_clk);
+}
diff --git a/arch/arm/mach-iproc/common.h b/arch/arm/mach-iproc/common.h
new file mode 100644
index 0000000..af60799
--- /dev/null
+++ b/arch/arm/mach-iproc/common.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __MACH_NORTHSTAR_COMMON_H
+#define __MACH_NORTHSTAR_COMMON_H
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <asm/clkdev.h>
+
+#include <mach/clkdev.h>
+
+void __init board_add_common_devices(struct clk *ref_clk);
+
+extern struct smp_operations iproc_smp_ops;
+#endif /* __MACH_NORTHSTAR_COMMON_H */
diff --git a/arch/arm/mach-iproc/flash.c b/arch/arm/mach-iproc/flash.c
new file mode 100644
index 0000000..3563e02
--- /dev/null
+++ b/arch/arm/mach-iproc/flash.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+#include <mach/io_map.h>
+#include <mach/reg_utils.h>
+#include <mach/qspi_iproc.h>
+#include <mach/nand_iproc.h>
+#include <mach/memory.h>
+
+#include <asm/pgtable.h>
+
+#ifdef CONFIG_MTD
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/map.h>
+
+/* Since GSIO uses bus number 0, QSPI uses bus number 1 */
+#define IPROC_QSPI_BUS_NUMBER       (1)
+
+/* Currently NAND controller only supports 2 LUNs */
+#define IPROC_NAND_MAX_LUNS         (2)
+
+#if defined(CONFIG_IPROC_QSPI) || defined(CONFIG_IPROC_QSPI_MODULE)
+static struct mtd_partition sflash_partition_map[] = {
+    {
+        .name = "boot",
+        .offset = 0x00000000,
+        .size = 640 * 1024,
+    },
+    {
+        .name = "env",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 384 * 1024,
+    },
+    {
+        .name = "system",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 15 * 1024 * 1024,
+    },
+    {
+        .name = "rootfs",
+        .offset = MTDPART_OFS_APPEND,
+        .size = MTDPART_SIZ_FULL,
+    },
+};
+#endif /* CONFIG_IPROC_QSPI || CONFIG_IPROC_QSPI_MODULE */
+
+#if defined(CONFIG_IPROC_MTD_NAND) || defined(CONFIG_IPROC_MTD_NAND_MODULE)
+static struct mtd_partition nand_partition_map[] = {
+    {
+        .name = "nboot",
+        .offset = 0x00000000,
+        .size = 2 * 1024 * 1024,
+    },
+    {
+        .name = "nenv",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 4 * 1024 * 1024,
+    },
+    {
+        .name = "nsystem",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 10 * 1024 * 1024,
+    },
+    {
+        .name = "nrootfs",
+        .offset = MTDPART_OFS_APPEND,
+        .size = 48 * 1024 * 1024,
+    },
+    {
+        .name = "ncustfs",
+        .offset = MTDPART_OFS_APPEND,
+        .size = MTDPART_SIZ_FULL,
+    },
+};
+#endif /* CONFIG_IPROC_MTD_NAND || CONFIG_IPROC_MTD_NAND_MODULE */
+
+#if defined(CONFIG_IPROC_QSPI) || defined(CONFIG_IPROC_QSPI_MODULE)
+static int __init 
+brcm_setup_spi_master(int cs, int bus_id)
+{
+	struct brcmspi_platform_data pdata;
+	struct platform_device *pdev;
+	const struct resource res[] = {
+        {
+            .start = IPROC_QSPI_IRQ_START,
+            .end = IPROC_QSPI_IRQ_END,
+            .flags = IORESOURCE_IRQ
+        },
+        {
+            .start = QSPI_MSPI_SPCR0_LSB,
+            .end = QSPI_MSPI_DISABLE_FLUSH_GEN + 3,
+            .flags = IORESOURCE_MEM
+        },
+        {
+            .start = QSPI_BSPI_REGS_REV_ID,
+            .end = QSPI_BSPI_REGS_BSPI_PIO_DATA + 3,
+            .flags = IORESOURCE_MEM
+        },
+        {
+            .start = QSPI_RAF_START_ADDR,
+            .end = QSPI_RAF_CURR_ADDR + 3,
+            .flags = IORESOURCE_MEM
+        },
+        {
+            .start = QSPI_RAF_INTERRUPT_LR_FULLNESS_REACHED,
+            .end = QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONE + 3,
+            .flags = IORESOURCE_MEM
+        },
+        {
+            .start = IPROC_IDM_QSPI_REG_BASE,
+            .end = IPROC_IDM_QSPI_REG_BASE + 3,
+            .flags = IORESOURCE_MEM
+        },
+        {
+            .start = IPROC_CRU_REG_BASE,
+            .end = IPROC_CRU_REG_BASE + 3,
+            .flags = IORESOURCE_MEM
+        },
+    };
+    
+	memset(&pdata, 0, sizeof(pdata));
+	pdata.flash_cs = cs;
+	pdev = platform_device_alloc("qspi_iproc", bus_id);
+	if (!pdev ||
+	    platform_device_add_resources(pdev, res, sizeof(res)/sizeof(res[0])) ||
+	    platform_device_add_data(pdev, &pdata, sizeof(pdata)) ||
+	    platform_device_add(pdev)) {
+		platform_device_put(pdev);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int __init 
+brcm_setup_spi_flash(int cs, int bus_num, int nr_parts,	struct mtd_partition *parts)
+{
+	struct spi_board_info board_info;
+	struct flash_platform_data *pdata;
+	struct spi_master *master;
+    
+	pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pdata->nr_parts = nr_parts;
+	pdata->parts = parts;
+
+	memset(&board_info, 0, sizeof(board_info));
+
+	strcpy(board_info.modalias, "m25p80");
+	board_info.bus_num = bus_num;
+	board_info.chip_select = cs;
+	board_info.max_speed_hz = CONFIG_IPROC_QSPI_MAX_HZ;
+	board_info.mode = SPI_MODE_3;
+	board_info.platform_data = pdata;
+    
+	master = spi_busnum_to_master(bus_num);
+	if (master) {
+		/* Master driver already loaded */
+		if (spi_new_device(master, &board_info) == NULL) {
+			printk(KERN_WARNING "%s: can't add SPI device\n", __func__);
+			kfree(pdata);
+			return -ENODEV;
+		}
+	} else {
+		/* Master driver not yet loaded, register the board first. */
+		if (spi_register_board_info(&board_info, 1) != 0) {
+			printk(KERN_WARNING "%s: can't register SPI device\n", __func__);
+			kfree(pdata);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_IPROC_QSPI || CONFIG_IPROC_QSPI_MODULE */
+
+#if defined(CONFIG_IPROC_MTD_NAND) || defined(CONFIG_IPROC_MTD_NAND_MODULE)
+static void __init 
+northstar_setup_nand_flash(void)
+{
+	u32 straps;
+    struct platform_device *pdev;
+    struct brcmnand_platform_data pdata;
+    int i;
+    
+	straps = __REG32(IPROC_DMU_BASE_VA + IPROC_DMU_STRAPS_OFFSET);
+    pdata.strap_boot = ((straps >> IPROC_STRAP_BOOT_DEV_SHIFT) & 3) == 1;
+    pdata.strap_type = (straps >> IPROC_STRAP_NAND_TYPE_SHIFT) & 0xf;
+    pdata.strap_page_size = (straps >> IPROC_STRAP_NAND_PAGE_SHIFT) & 0x3;
+    if (!pdata.strap_boot) {
+        pdata.strap_type &= 0x7;
+    }
+    pdata.nr_parts = ARRAY_SIZE(nand_partition_map);
+    pdata.parts = nand_partition_map;
+    
+    for(i=0; i<IPROC_NAND_MAX_LUNS; i++) {
+        
+        /* Use the full device if it's not the first LUN */
+        if (i > 0) {
+            pdata.nr_parts = 0;
+            pdata.parts = NULL;
+        }
+        
+        pdata.chip_select = i;
+        pdev = platform_device_alloc("nand_iproc", i);
+        if (!pdev ||
+            platform_device_add_data(pdev, &pdata, sizeof(pdata)) ||
+            platform_device_add(pdev)) {
+            platform_device_put(pdev);
+        }
+    }
+}
+#endif /* CONFIG_IPROC_MTD_NAND || CONFIG_IPROC_MTD_NAND_MODULE */
+
+static int __init 
+northstar_mtd_setup(void)
+{
+#if defined(CONFIG_IPROC_QSPI) || defined(CONFIG_IPROC_QSPI_MODULE)
+    /* SPI flash (currently used for primary) */
+    brcm_setup_spi_master(
+        0, 
+        IPROC_QSPI_BUS_NUMBER
+        );
+    brcm_setup_spi_flash(
+        0, 
+        IPROC_QSPI_BUS_NUMBER,
+        ARRAY_SIZE(sflash_partition_map),
+        sflash_partition_map
+        );
+#endif /* CONFIG_IPROC_QSPI || CONFIG_IPROC_QSPI_MODULE */
+        
+#if defined(CONFIG_IPROC_MTD_NAND) || defined(CONFIG_IPROC_MTD_NAND_MODULE)
+#ifdef CONFIG_MACH_NS
+    /* Don't bring up NAND driver if it's BCM53010 */
+    if ((__REG32(IPROC_IDM_REGISTER_VA + 0xd500) & 0xc) != 0x4)
+#endif /* CONFIG_MACH_NS */
+        northstar_setup_nand_flash();
+#endif /* CONFIG_IPROC_MTD_NAND || CONFIG_IPROC_MTD_NAND_MODULE */
+
+    return 0;
+}
+
+/*
+ * late_initcall means the flash drivers are already loaded, so we control
+ * the order in which the /dev/mtd* devices get created.
+ */
+late_initcall(northstar_mtd_setup);
+
+#endif /* CONFIG_MTD */
diff --git a/arch/arm/mach-iproc/idm.c b/arch/arm/mach-iproc/idm.c
new file mode 100644
index 0000000..65ef99b
--- /dev/null
+++ b/arch/arm/mach-iproc/idm.c
@@ -0,0 +1,696 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/interrupt.h>
+
+#include <linux/irq.h>
+#include <mach/iproc.h>
+#include <asm/io.h>
+#include <mach/io_map.h>
+
+#ifdef CONFIG_MACH_NSP
+/* this is actually AXI_PCIE_S2 but for HX4, HR2, and KT2 it has been hijacked by CMICD */
+
+#define CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL AXI_PCIE_S2_IDM_IDM_ERROR_LOG_CONTROL
+#define CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE AXI_PCIE_S2_IDM_IDM_ERROR_LOG_COMPLETE
+#define CMICD_S0_IDM_IDM_ERROR_LOG_STATUS AXI_PCIE_S2_IDM_IDM_ERROR_LOG_STATUS
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB AXI_PCIE_S2_IDM_IDM_ERROR_LOG_ADDR_LSB
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ID AXI_PCIE_S2_IDM_IDM_ERROR_LOG_ID
+#define CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS AXI_PCIE_S2_IDM_IDM_ERROR_LOG_FLAGS
+#define CMICD_S0_IDM_IDM_INTERRUPT_STATUS AXI_PCIE_S2_IDM_IDM_INTERRUPT_STATUS
+
+#endif
+
+#ifdef CONFIG_MACH_NS
+
+#define IHOST_S1_IDM_ERROR_LOG_CONTROL 0x18106900
+#define IHOST_S1_IDM_ERROR_LOG_COMPLETE 0x18106904
+#define IHOST_S1_IDM_ERROR_LOG_STATUS 0x18106908
+#define IHOST_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810690C
+#define IHOST_S1_IDM_ERROR_LOG_ID 0x18106914
+#define IHOST_S1_IDM_ERROR_LOG_FLAGS 0x1810691C
+#define IHOST_S1_IDM_INTERRUPT_STATUS 0x18106A00
+
+#define IHOST_S0_IDM_ERROR_LOG_CONTROL 0x18107900
+#define IHOST_S0_IDM_ERROR_LOG_COMPLETE 0x18107904
+#define IHOST_S0_IDM_ERROR_LOG_STATUS 0x18107908
+#define IHOST_S0_IDM_ERROR_LOG_ADDR_LSB 0x1810790C
+#define IHOST_S0_IDM_ERROR_LOG_ID 0x18107914
+#define IHOST_S0_IDM_ERROR_LOG_FLAGS 0x1810791C
+#define IHOST_S0_IDM_INTERRUPT_STATUS 0x18107A00
+
+#define DDR_S1_IDM_ERROR_LOG_CONTROL 0x18108900
+#define DDR_S1_IDM_ERROR_LOG_COMPLETE 0x18108904
+#define DDR_S1_IDM_ERROR_LOG_STATUS 0x18108908
+#define DDR_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810890C
+#define DDR_S1_IDM_ERROR_LOG_ID 0x18108914
+#define DDR_S1_IDM_ERROR_LOG_FLAGS 0x1810891C
+#define DDR_S1_IDM_INTERRUPT_STATUS 0x18108A00
+
+#define DDR_S2_IDM_ERROR_LOG_CONTROL 0x18109900
+#define DDR_S2_IDM_ERROR_LOG_COMPLETE 0x18109904
+#define DDR_S2_IDM_ERROR_LOG_STATUS 0x18109908
+#define DDR_S2_IDM_ERROR_LOG_ADDR_LSB 0x1810990C
+#define DDR_S2_IDM_ERROR_LOG_ID 0x18109914
+#define DDR_S2_IDM_ERROR_LOG_FLAGS 0x1810991C
+#define DDR_S2_IDM_INTERRUPT_STATUS 0x18109A00
+
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810A900
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810A904
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810A908
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810A90C
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID 0x1810A914
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810A91C
+#define AXI_PCIE_S0_IDM_IDM_INTERRUPT_STATUS 0x1810AA00
+
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_CONTROL 0x1810B900
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_COMPLETE 0x1810B904
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_STATUS 0x1810B908
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810B90C
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ID 0x1810B914
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_FLAGS 0x1810B91C
+#define AXI_PCIE_S1_IDM_IDM_INTERRUPT_STATUS 0x1810BA00
+
+/* this is actually AXI_PCIE_S2 but for HX4, HR2, and KT2 it has been hijacked by CMICD */
+
+#define CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810C900
+#define CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810C904
+#define CMICD_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810C908
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810C90C
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ID 0x1810C914
+#define CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810C91C
+#define CMICD_S0_IDM_IDM_INTERRUPT_STATUS 0x1810CA00
+
+#define ROM_S0_IDM_ERROR_LOG_CONTROL 0x1810D900
+#define ROM_S0_IDM_ERROR_LOG_COMPLETE 0x1810D904
+#define ROM_S0_IDM_ERROR_LOG_STATUS 0x1810D908
+#define ROM_S0_IDM_ERROR_LOG_ADDR_LSB 0x1810D90C
+#define ROM_S0_IDM_ERROR_LOG_ID 0x1810D914
+#define ROM_S0_IDM_ERROR_LOG_FLAGS 0x1810D91C
+#define ROM_S0_IDM_INTERRUPT_STATUS 0x1810DA00
+
+#define NAND_IDM_IDM_ERROR_LOG_CONTROL 0x1811A900
+#define NAND_IDM_IDM_ERROR_LOG_COMPLETE 0x1811A904
+#define NAND_IDM_IDM_ERROR_LOG_STATUS 0x1811A908
+#define NAND_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811A90C
+#define NAND_IDM_IDM_ERROR_LOG_ID 0x1811A914
+#define NAND_IDM_IDM_ERROR_LOG_FLAGS 0x1811A91C
+#define NAND_IDM_IDM_INTERRUPT_STATUS 0x1811AA00
+
+#define QSPI_IDM_IDM_ERROR_LOG_CONTROL 0x1811B900
+#define QSPI_IDM_IDM_ERROR_LOG_COMPLETE 0x1811B904
+#define QSPI_IDM_IDM_ERROR_LOG_STATUS 0x1811B908
+#define QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811B90C
+#define QSPI_IDM_IDM_ERROR_LOG_ID 0x1811B914
+#define QSPI_IDM_IDM_ERROR_LOG_FLAGS 0x1811B91C
+#define QSPI_IDM_IDM_INTERRUPT_STATUS 0x1811BA00
+
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1811C900
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1811C904
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS 0x1811C908
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811C90C
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ID 0x1811C914
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1811C91C
+#define A9JTAG_S0_IDM_IDM_INTERRUPT_STATUS 0x1811CA00
+
+#define APBX_IDM_IDM_ERROR_LOG_CONTROL 0x18121900
+#define APBX_IDM_IDM_ERROR_LOG_COMPLETE 0x18121904
+#define APBX_IDM_IDM_ERROR_LOG_STATUS 0x18121908
+#define APBX_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1812190C
+#define APBX_IDM_IDM_ERROR_LOG_ID 0x18121914
+#define APBX_IDM_IDM_ERROR_LOG_FLAGS 0x1812191C
+#define APBX_IDM_IDM_INTERRUPT_STATUS 0x1812A900
+
+#define AXIIC_DS_0_IDM_ERROR_LOG_CONTROL 0x18132900
+#define AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE 0x18132904
+#define AXIIC_DS_0_IDM_ERROR_LOG_STATUS 0x181312908
+#define AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB 0x1813290c
+#define AXIIC_DS_0_IDM_ERROR_LOG_ID 0x18132910
+#define AXIIC_DS_0_IDM_ERROR_LOG_FLAGS 0x18132904
+#define AXIIC_DS_0_IDM_INTERRUPT_STATUS 0x18132A00
+
+#define AXIIC_DS_1_IDM_ERROR_LOG_CONTROL 0x18133900
+#define AXIIC_DS_1_IDM_ERROR_LOG_COMPLETE 0x18133904
+#define AXIIC_DS_1_IDM_ERROR_LOG_STATUS 0x181313908
+#define AXIIC_DS_1_IDM_ERROR_LOG_ADDR_LSB 0x1813390c
+#define AXIIC_DS_1_IDM_ERROR_LOG_ID 0x18133910
+#define AXIIC_DS_1_IDM_ERROR_LOG_FLAGS 0x18133904
+#define AXIIC_DS_1_IDM_INTERRUPT_STATUS 0x18133A00
+
+#define AXIIC_DS_2_IDM_ERROR_LOG_CONTROL 0x18134900
+#define AXIIC_DS_2_IDM_ERROR_LOG_COMPLETE 0x18134904
+#define AXIIC_DS_2_IDM_ERROR_LOG_STATUS 0x181314908
+#define AXIIC_DS_2_IDM_ERROR_LOG_ADDR_LSB 0x1813490c
+#define AXIIC_DS_2_IDM_ERROR_LOG_ID 0x18134910
+#define AXIIC_DS_2_IDM_ERROR_LOG_FLAGS 0x18134904
+#define AXIIC_DS_2_IDM_INTERRUPT_STATUS 0x18134A00
+
+#define AXIIC_DS_3_IDM_ERROR_LOG_CONTROL 0x18135900
+#define AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE 0x18135904
+#define AXIIC_DS_3_IDM_ERROR_LOG_STATUS 0x181315908
+#define AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB 0x1813590c
+#define AXIIC_DS_3_IDM_ERROR_LOG_ID 0x18135910
+#define AXIIC_DS_3_IDM_ERROR_LOG_FLAGS 0x18135904
+#define AXIIC_DS_3_IDM_INTERRUPT_STATUS 0x18135A00
+
+#define AXIIC_DS_4_IDM_ERROR_LOG_CONTROL 0x18136900
+#define AXIIC_DS_4_IDM_ERROR_LOG_COMPLETE 0x18136904
+#define AXIIC_DS_4_IDM_ERROR_LOG_STATUS 0x181316908
+#define AXIIC_DS_4_IDM_ERROR_LOG_ADDR_LSB 0x1813690c
+#define AXIIC_DS_4_IDM_ERROR_LOG_ID 0x18136910
+#define AXIIC_DS_4_IDM_ERROR_LOG_FLAGS 0x18136904
+#define AXIIC_DS_4_IDM_INTERRUPT_STATUS 0x18136A00
+
+#define IHOST_L2C_INT_MASK 0x19022214
+#define IHOST_GICDIST_enable_set2 0x19021108
+
+#endif
+
+#define IHOST_L2C_INT_MASK_VA HW_IO_PHYS_TO_VIRT(IHOST_L2C_INT_MASK)
+#define IHOST_GICDIST_enable_set2_VA HW_IO_PHYS_TO_VIRT(IHOST_GICDIST_enable_set2)
+
+#define IHOST_S1_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_CONTROL)
+#define IHOST_S1_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_COMPLETE)
+#define IHOST_S1_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_STATUS)
+#define IHOST_S1_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_ADDR_LSB)
+#define IHOST_S1_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_ID)
+#define IHOST_S1_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(IHOST_S1_IDM_ERROR_LOG_FLAGS)
+#define IHOST_S1_IDM_IRQ 62
+
+#define IHOST_S0_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_CONTROL)
+#define IHOST_S0_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_COMPLETE)
+#define IHOST_S0_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_STATUS)
+#define IHOST_S0_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_ADDR_LSB)
+#define IHOST_S0_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_ID)
+#define IHOST_S0_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(IHOST_S0_IDM_ERROR_LOG_FLAGS)
+#define IHOST_S0_IDM_IRQ 63
+
+
+#define DDR_S1_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_CONTROL)
+#define DDR_S1_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_COMPLETE)
+#define DDR_S1_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_STATUS)
+#define DDR_S1_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_ADDR_LSB)
+#define DDR_S1_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_ID)
+#define DDR_S1_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(DDR_S1_IDM_ERROR_LOG_FLAGS)
+#define DDR_S1_IDM_IRQ 64
+
+#define DDR_S2_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_CONTROL)
+#define DDR_S2_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_COMPLETE)
+#define DDR_S2_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_STATUS)
+#define DDR_S2_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_ADDR_LSB)
+#define DDR_S2_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_ID)
+#define DDR_S2_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(DDR_S2_IDM_ERROR_LOG_FLAGS)
+#define DDR_S2_IDM_IRQ 65
+
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL)
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE)
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS)
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID)
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS)
+#define AXI_PCIE_S0_IDM_IRQ 66
+#define AXI_PCIE_S1_IDM_IRQ 67
+
+#define CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL)
+#define CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE)
+#define CMICD_S0_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_STATUS)
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_ID)
+#define CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS)
+#define CMICD_S0_IDM_IRQ 68
+
+#define APBY_S0_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_CONTROL)
+#define APBY_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_COMPLETE)
+#define APBY_S0_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_STATUS)
+#define APBY_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define APBY_S0_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_ID)
+#define APBY_S0_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(APBY_S0_IDM_IDM_ERROR_LOG_FLAGS)
+#define APBY_S0_IDM_IRQ 77
+
+#define ROM_S0_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_CONTROL)
+#define ROM_S0_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_COMPLETE)
+#define ROM_S0_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_STATUS)
+#define ROM_S0_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_ADDR_LSB)
+#define ROM_S0_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_ID)
+#define ROM_S0_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(ROM_S0_IDM_ERROR_LOG_FLAGS)
+#define ROM_S0_IDM_IRQ 69
+
+#define NAND_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_CONTROL)
+#define NAND_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_COMPLETE)
+#define NAND_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_STATUS)
+#define NAND_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define NAND_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_ID)
+#define NAND_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(NAND_IDM_IDM_ERROR_LOG_FLAGS)
+#define NAND_IDM_IRQ 70
+
+
+#define QSPI_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_CONTROL)
+#define QSPI_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_COMPLETE)
+#define QSPI_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_STATUS)
+#define QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define QSPI_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_ID)
+#define QSPI_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(QSPI_IDM_IDM_ERROR_LOG_FLAGS)
+#define QSPI_IDM_IRQ 71
+#define SATA_IDM_IRQ 72
+
+
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL)
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE)
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS)
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_ID)
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS)
+#define A9JTAG_S0_IDM_IRQ 73
+
+#define SRAM_S0_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_CONTROL)
+#define SRAM_S0_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_COMPLETE)
+#define SRAM_S0_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_STATUS)
+#define SRAM_S0_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_ADDR_LSB)
+#define SRAM_S0_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_ID)
+#define SRAM_S0_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(SRAM_S0_IDM_ERROR_LOG_FLAGS)
+#define SRAM_S0_IDM_IRQ 74
+
+#define APBZ_S0_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_CONTROL)
+#define APBZ_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_COMPLETE)
+#define APBZ_S0_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_STATUS)
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_ID)
+#define APBZ_S0_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(APBZ_S0_IDM_IDM_ERROR_LOG_FLAGS)
+#define APBZ_S0_IDM_IRQ 78
+
+
+#define AXIIC_DS_3_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_CONTROL)
+#define AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE)
+#define AXIIC_DS_3_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_STATUS)
+#define AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB)
+#define AXIIC_DS_3_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_ID)
+#define AXIIC_DS_3_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_3_IDM_ERROR_LOG_FLAGS)
+#define AXIIC_DS_3_IDM_IRQ 82
+
+
+#define APBW_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_CONTROL)
+#define APBW_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_COMPLETE)
+#define APBW_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_STATUS)
+#define APBW_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define APBW_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_ID)
+#define APBW_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(APBW_IDM_IDM_ERROR_LOG_FLAGS)
+#define APW_IDM_IRQ 75
+
+
+#define APBX_IDM_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_CONTROL)
+#define APBX_IDM_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_COMPLETE)
+#define APBX_IDM_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_STATUS)
+#define APBX_IDM_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_ADDR_LSB)
+#define APBX_IDM_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_ID)
+#define APBX_IDM_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(APBX_IDM_IDM_ERROR_LOG_FLAGS)
+#define APX_IDM_IRQ 76
+
+#define AXIIC_DS_0_IDM_ERROR_LOG_CONTROL_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_CONTROL)
+#define AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE)
+#define AXIIC_DS_0_IDM_ERROR_LOG_STATUS_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_STATUS)
+#define AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB)
+#define AXIIC_DS_0_IDM_ERROR_LOG_ID_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_ID)
+#define AXIIC_DS_0_IDM_ERROR_LOG_FLAGS_VA HW_IO_PHYS_TO_VIRT(AXIIC_DS_0_IDM_ERROR_LOG_FLAGS)
+#define AXIIC_DS_0_IDM_IRQ 79
+#define AXIIC_DS_1_IDM_IRQ 80
+#define AXIIC_DS_2_IDM_IRQ 81
+#define AXIIC_DS_4_IDM_IRQ 83
+
+#define IDM_ERROR_LOG_ENABLE 0x33A
+#define IDM_ERROR_LOG_CLEAR 0x3
+
+
+static irqreturn_t idm_timeout_handler(int val, void *ptr)
+{
+	u32 errStat;
+	printk(KERN_DEBUG "%s: %d, %d entry\n", __FUNCTION__, __LINE__, val);
+	errStat = __raw_readl(IHOST_S1_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S1_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S1_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S1_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, IHOST_S1_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(IHOST_S1_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(IHOST_S0_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S0_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S0_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(IHOST_S0_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, IHOST_S0_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(IHOST_S0_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(DDR_S1_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S1_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S1_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S1_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, DDR_S1_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(DDR_S1_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(DDR_S2_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S2_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S2_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(DDR_S2_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, DDR_S2_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(DDR_S2_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(CMICD_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(CMICD_S0_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(CMICD_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#ifndef CONFIG_MACH_NS
+	errStat = __raw_readl(APBY_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBY_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBY_S0_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBY_S0_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, APBY_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(APBY_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#endif
+	errStat = __raw_readl(ROM_S0_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(ROM_S0_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(ROM_S0_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(ROM_S0_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, ROM_S0_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(ROM_S0_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(NAND_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(NAND_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(NAND_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(NAND_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, NAND_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(NAND_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(QSPI_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(QSPI_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(QSPI_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, QSPI_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(QSPI_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(A9JTAG_S0_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#ifndef CONFIG_MACH_NS
+	errStat = __raw_readl(SRAM_S0_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(SRAM_S0_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(SRAM_S0_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(SRAM_S0_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, SRAM_S0_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(SRAM_S0_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(APBZ_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBZ_S0_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBZ_S0_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBZ_S0_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, APBZ_S0_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(APBZ_S0_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#endif
+	errStat = __raw_readl(AXIIC_DS_3_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_3_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_3_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(AXIIC_DS_3_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#ifndef CONFIG_MACH_NS
+	errStat = __raw_readl(APBW_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBW_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBW_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBW_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, APBW_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(APBW_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+#endif
+	errStat = __raw_readl(APBX_IDM_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBX_IDM_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBX_IDM_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(APBX_IDM_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, APBX_IDM_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(APBX_IDM_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	errStat = __raw_readl(AXIIC_DS_0_IDM_ERROR_LOG_STATUS_VA);
+	if (errStat > 0)
+	{
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_0_IDM_ERROR_LOG_ID_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		errStat = __raw_readl(AXIIC_DS_0_IDM_ERROR_LOG_FLAGS_VA);
+		printk("%s: %d, %08x\n", __FUNCTION__, __LINE__, errStat);
+		__raw_writel(IDM_ERROR_LOG_CLEAR, AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE_VA);
+		errStat = __raw_readl(AXIIC_DS_0_IDM_ERROR_LOG_STATUS_VA);
+		printk("%s: %d, %d\n", __FUNCTION__, __LINE__, errStat);
+	}
+	printk(KERN_DEBUG "%s: %d exit\n", __FUNCTION__, __LINE__);
+	return IRQ_HANDLED;
+}
+
+int l2cc_interrupt_error_handler(int val, void *ptr)
+{
+	printk(KERN_DEBUG "%s: %d, %d entry\n", __FUNCTION__, __LINE__, val);
+	printk(KERN_DEBUG "%s: %d exit\n", __FUNCTION__, __LINE__);
+	return 0;
+}
+
+void request_idm_timeout_interrupts(void)
+{
+	u32 l2cc_mask;
+	int ret = 0;
+	printk(KERN_DEBUG "%s: %d entry\n", __FUNCTION__, __LINE__);
+	/* clear all pending idm interrupts */
+	idm_timeout_handler(0, NULL);
+
+	/* enable idm error log for all slaves */
+
+	__raw_writel(IDM_ERROR_LOG_ENABLE, IHOST_S1_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, IHOST_S0_IDM_ERROR_LOG_COMPLETE_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, DDR_S1_IDM_ERROR_LOG_COMPLETE_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, DDR_S2_IDM_ERROR_LOG_COMPLETE_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL_VA);
+
+#ifndef CONFIG_MACH_NS
+	__raw_writel(IDM_ERROR_LOG_ENABLE, APBY_S0_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, SRAM_S0_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, APBZ_S0_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, APBW_IDM_IDM_ERROR_LOG_CONTROL_VA);
+#endif
+
+	__raw_writel(IDM_ERROR_LOG_ENABLE, ROM_S0_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, NAND_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, QSPI_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, APBX_IDM_IDM_ERROR_LOG_CONTROL_VA);
+	__raw_writel(IDM_ERROR_LOG_ENABLE, AXIIC_DS_0_IDM_ERROR_LOG_CONTROL_VA);
+
+	/* now enable the idm interrupts */
+
+	ret = request_irq(IHOST_S1_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(IHOST_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(DDR_S1_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(DDR_S2_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXI_PCIE_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXI_PCIE_S1_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(CMICD_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(ROM_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(NAND_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(QSPI_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(SATA_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(A9JTAG_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(SRAM_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(APW_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(APX_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(APBY_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(APBZ_S0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXIIC_DS_0_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXIIC_DS_1_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXIIC_DS_2_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXIIC_DS_3_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	ret = request_irq(AXIIC_DS_4_IDM_IRQ, (irq_handler_t)idm_timeout_handler, IRQF_DISABLED | IRQF_PERCPU, "IDM", NULL);
+	if (ret != 0)
+		printk("%s: %d request_irq return = %d\n", __FUNCTION__, __LINE__, ret);
+	printk("KERN_DEBUG %s: %d exit\n", __FUNCTION__, __LINE__);
+}
diff --git a/arch/arm/mach-iproc/include/mach/io_map.h b/arch/arm/mach-iproc/include/mach/io_map.h
new file mode 100644
index 0000000..1465358
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/io_map.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __NORTHSTAR_IO_MAP_H
+#define __NORTHSTAR_IO_MAP_H
+
+#include <mach/memory.h>
+#include <asm/memory.h>
+#include <mach/iproc_regs.h>
+
+#define IPROC_CCA_CORE_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCA_REG_BASE)
+#define IPROC_CCA_UART0_REG_VA    HW_IO_PHYS_TO_VIRT(IPROC_CCA_UART0_REG_BASE)
+#define IPROC_CCB_GPIO_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCB_GPIO_REG_BASE)
+#define IPROC_CCB_PWM_REG_VA      HW_IO_PHYS_TO_VIRT(IPROC_CCB_PWM_REG_BASE)
+#define IPROC_CCB_MDIO_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCB_MDIO_REG_BASE)
+#define IPROC_CCB_RNG_REG_VA      HW_IO_PHYS_TO_VIRT(IPROC_CCB_RNG_REG_BASE)
+#define IPROC_CCB_TIM0_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCB_TIM0_REG_BASE)
+#define IPROC_CCB_TIM1_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCB_TIM1_REG_BASE)
+#define IPROC_CCB_SRAU_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_CCB_SRAU_REG_BASE)
+#define IPROC_CCB_UART0_REG_VA    HW_IO_PHYS_TO_VIRT(IPROC_CCB_UART0_REG_BASE)
+
+#define IPROC_DDRC_REG_VA         HW_IO_PHYS_TO_VIRT(IPROC_DDRC_REG_BASE)
+#define IPROC_DMAC_REG_VA         HW_IO_PHYS_TO_VIRT(IPROC_DMAC_REG_BASE)
+#define IPROC_PCIE_AXIB0_REG_VA   HW_IO_PHYS_TO_VIRT(IPROC_PCIE_AXIB0_REG_BASE)
+#define IPROC_PCIE_AXIB1_REG_VA   HW_IO_PHYS_TO_VIRT(IPROC_PCIE_AXIB1_REG_BASE)
+#define IPROC_PCIE_AXIB2_REG_VA   HW_IO_PHYS_TO_VIRT(IPROC_PCIE_AXIB2_REG_BASE)
+
+#define IPROC_SDIO3_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_SDIO3_REG_BASE)
+#define IPROC_USB20_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_USB20_REG_BASE)
+#define IPROC_USB30_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_USB30_REG_BASE)
+#define IPROC_USB20_PHY_REG_VA    HW_IO_PHYS_TO_VIRT(IPROC_USB20_PHY_REG_BASE)
+#define IPROC_GMAC0_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_GMAC0_REG_BASE)
+#define IPROC_GMAC1_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_GMAC1_REG_BASE)
+#define IPROC_GMAC2_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_GMAC2_REG_BASE)
+#define IPROC_GMAC3_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_GMAC3_REG_BASE)
+#define IPROC_DMU_BASE_VA         HW_IO_PHYS_TO_VIRT(IPROC_DMU_REG_BASE)
+#define IPROC_CRU_BASE_VA         HW_IO_PHYS_TO_VIRT(IPROC_CRU_REG_BASE)
+#define IPROC_IDM_REGISTER_VA     HW_IO_PHYS_TO_VIRT(IPROC_IDM_REG_BASE)
+#define IPROC_USB2D_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_USB2D_REG_BASE)
+
+#define IPROC_CTF_BASE_VA       HW_IO_PHYS_TO_VIRT(IPROC_CTF_REG_BASE)
+
+/* ARM9 Private memory region */
+#define PERIPH_BASE                    IPROC_PERIPH_BASE
+#define IPROC_PERIPH_VA                HW_IO_PHYS_TO_VIRT(IPROC_PERIPH_BASE)
+#define IPROC_PERIPH_SCU_REG_VA        HW_IO_PHYS_TO_VIRT(IPROC_PERIPH_BASE)
+#define IPROC_PERIPH_INT_CTRL_REG_VA   HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x100)
+#define IPROC_PERIPH_GLB_TIM_REG_VA    HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x200)
+#define IPROC_PERIPH_PVT_TIM_REG_VA    HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x600)
+#define IPROC_PERIPH_PVT_WDT_REG_VA    HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x620)
+#define IPROC_PERIPH_INT_DISTR_REG_VA  HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x1000)
+#define IPROC_L2CC_REG_VA              HW_IO_PHYS_TO_VIRT(PERIPH_BASE + 0x2000)
+
+#define IPROC_ROOT_CLK_VA  HW_IO_PHYS_TO_VIRT(IPROC_CLK_WR_ACC_REG_BASE)
+#define IPROC_GICCPU_VA    HW_IO_PHYS_TO_VIRT(IPROC_GICCPU_CTL_REG_BASE)
+
+#define CCU_PROF_REG_BASE              IPROC_CCU_PROF_CTL_REG_BASE
+#define IPROC_CCU_PROF_CTL_REG_VA HW_IO_PHYS_TO_VIRT(CCU_PROF_REG_BASE)
+#define IPROC_CCU_PROF_SEL_REG_VA HW_IO_PHYS_TO_VIRT(CCU_PROF_REG_BASE + 0x004)
+#define IPROC_CCU_PROF_CNT_REG_VA HW_IO_PHYS_TO_VIRT(CCU_PROF_REG_BASE + 0x008)
+#define IPROC_CCU_PROF_DBG_REG_VA HW_IO_PHYS_TO_VIRT(CCU_PROF_REG_BASE + 0x00C)
+
+#define IPROC_UART_LLDEBUG_PA		IPROC_CCA_UART0_REG_BASE
+#define IPROC_UART_LLDEBUG_VA		IPROC_CCA_UART0_REG_VA
+
+#define IPROC_I2S_REG_VA     HW_IO_PHYS_TO_VIRT(IPROC_I2S_REG_BASE)
+
+#endif /*__NORTHSTAR_IO_MAP_H */
diff --git a/arch/arm/mach-iproc/include/mach/iproc_regs.h b/arch/arm/mach-iproc/include/mach/iproc_regs.h
new file mode 100644
index 0000000..27bc485
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/iproc_regs.h
@@ -0,0 +1,633 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __IPROC_REGS_H
+#define __IPROC_REGS_H __FILE__
+#include <linux/types.h>
+
+
+#ifdef  CONFIG_MACH_NS
+#include "socregs_ns_open.h"
+#elif (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2) || \
+	defined(CONFIG_MACH_HR2))
+#include "socregs_ing_open.h"
+#elif defined(CONFIG_MACH_NSP)
+#include "socregs_nsp_open.h"
+#else
+#error "No valid iProc Machine type selected"
+#endif
+
+
+#ifdef CONFIG_MACH_HR2
+#define IPROC_NUM_CPUS			               (1)
+#else
+#define IPROC_NUM_CPUS			               (2)
+#endif
+
+#define IPROC_NUM_IRQS	                               (256)
+#define IPROC_CPU0_MIN_INT_PRIORITY	               (0)
+#define IPROC_CPU1_MIN_INT_PRIORITY	               (0)
+
+#define IPROC_DDR_MEM_BASE1		               (0x0)
+
+#ifdef CONFIG_MACH_HR2
+#define IPROC_DDR_MEM_BASE2		               (0x60000000)
+#else
+#define IPROC_DDR_MEM_BASE2		               (0x80000000)
+#endif
+
+
+/* remap to newer reg file defs */
+#ifndef CONFIG_MACH_NS
+#define CCA_CHIPID				ChipcommonA_ChipID
+#define NAND_NAND_FLASH_REV			NAND_nand_flash_REVISION
+#define NAND_DIRECT_READ_RD_MISS		NAND_direct_read_rd_miss
+#define NAND_ECC_MIPS_CORR			NAND_ecc_mips_corr
+#define NAND_NAND_FLASH_FLASH_CACHE127		NAND_nand_flash_FLASH_CACHE127
+#define QSPI_MSPI_SPCR0_LSB			QSPI_mspi_SPCR0_LSB
+#define QSPI_MSPI_DISABLE_FLUSH_GEN 		QSPI_mspi_DISABLE_FLUSH_GEN
+#define QSPI_BSPI_REGS_REV_ID			QSPI_bspi_registers_REVISION_ID
+#define QSPI_BSPI_REGS_BSPI_PIO_DATA  		QSPI_bspi_registers_BSPI_PIO_DATA
+#define QSPI_RAF_START_ADDR 			QSPI_raf_START_ADDR
+#define QSPI_RAF_CURR_ADDR 			QSPI_raf_CURR_ADDR
+#define QSPI_RAF_INTERRUPT_LR_FULLNESS_REACHED	QSPI_raf_interrupt_LR_fullness_reached
+#define QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONE QSPI_mspi_interrupt_MSPI_halt_set_transaction_done
+
+#define CCB_TIM0_TIM_TMR1_LOAD			ChipcommonB_tim0_TIM_TIMER1Load
+#define CCB_TIM1_TIM_TMR1_LOAD			ChipcommonB_tim1_TIM_TIMER1Load
+
+#define GMAC0_DEVCT	GMAC0_DEVCONTROL
+
+#define PAXB_0_PCIE_CTL     (PAXB_0_CLK_CONTROL)
+
+#define CCB_MII_MGMT_CTL 	ChipcommonB_MII_Management_Control
+
+#endif
+
+#ifdef CONFIG_MACH_NSP
+#define CCB_RNG_CTRL    ChipcommonB_rng_CTRL
+#endif
+
+
+/* the below might be NS specific */
+
+#define IPROC_CCA_REG_BASE		               CCA_CHIPID
+#define IPROC_CCB_GPIO_REG_BASE		               (IPROC_GPIO_CCB_BASE)
+#define IPROC_CCB_PWM_REG_BASE		               (CCB_PWMCTL)
+#define IPROC_CCB_MDIO_REG_BASE		               (CCB_MII_MGMT_CTL)
+#define IPROC_CCB_RNG_REG_BASE		               (CCB_RNG_CTRL)
+#define IPROC_CCB_TIM0_REG_BASE		               (CCB_TIM0_TIM_TMR1_LOAD)
+#define IPROC_CCB_TIM1_REG_BASE		               (CCB_TIM1_TIM_TMR1_LOAD)
+#define IPROC_CCB_SRAU_REG_BASE		               (CCB_SRAB_CMDSTAT)
+#define IPROC_CCB_UART0_REG_BASE	               (CCB_UART0_RBR_THR_DLL)
+
+#define IPROC_CCA_BASE				       IPROC_CCA_REG_BASE
+#define IPROC_CCA_CORE_CAP_REG_BASE		       (IPROC_CCA_BASE + 0x04)
+#define IPROC_CCA_CORE_CTL_REG_BASE		       (IPROC_CCA_BASE + 0x08)
+#define IPROC_CCA_UART0_REG_BASE		       (IPROC_CCA_BASE + 0x300)
+#define IPROC_CCA_UART1_REG_BASE		       (IPROC_CCA_BASE + 0x400)
+#define IPROC_CCA_INTMASK_REG_BASE	               (IPROC_CCA_BASE + 0x24)
+#define IPROC_CCA_UART_CLK_REG_BASE	               (IPROC_CCA_BASE + 0xa4)
+
+#define IPROC_CLK_WR_ACC_REG_BASE                      (0x19000000)
+#define IPROC_CLK_WR_ACC_REG_OFFSET                    (0x000)
+#define IPROC_CLK_POLICY_FREQ_REG                      (0x19000008)
+#define IPROC_CLK_POLICY_FREQ_OFFSET                   (0x008)
+#define IPROC_CLK_POLICY_CTL_REG                       (0x1900000C)
+#define IPROC_CLK_POLICY_CTL_OFFSET                    (0x00C)
+#define IPROC_CLK_POLICY0_MSK_REG                      (0x19000010)
+#define IPROC_CLK_POLICY0_MSK_OFFSET                   (0x010)
+#define IPROC_CLK_POLICY1_MSK_REG                      (0x19000014)
+#define IPROC_CLK_POLICY1_MSK_OFFSET                   (0x014)
+#define IPROC_CLK_POLICY2_MSK_REG                      (0x19000018)
+#define IPROC_CLK_POLICY2_MSK_OFFSET                   (0x018)
+#define IPROC_CLK_POLICY3_MSK_REG                      (0x1900001C)
+#define IPROC_CLK_POLICY3_MSK_OFFSET                   (0x01C)
+#define IPROC_CLK_INT_EN_REG                           (0x19000020)
+#define IPROC_CLK_INT_EN_OFFSET                        (0x020)
+#define IPROC_CLK_INT_STAT_REG                         (0x19000024)
+#define IPROC_CLK_INT_STAT_OFFSET                      (0x024)
+#define IPROC_CLK_LVM_EN_REG                           (0x19000034)
+#define IPROC_CLK_LVM_EN_OFFSET                        (0x034)
+#define IPROC_CLK_LVM0_3_REG                           (0x19000038)
+#define IPROC_CLK_LVM0_3_OFFSET                        (0x038)
+#define IPROC_CLK_LVM4_7_REG                           (0x1900003C)
+#define IPROC_CLK_LVM4_7_OFFSET                        (0x03C)
+#define IPROC_CLK_VLT0_3_REG                           (0x19000040)
+#define IPROC_CLK_VLT0_3_OFFSET                        (0x040)
+#define IPROC_CLK_VLT4_7_REG                           (0x19000044)
+#define IPROC_CLK_VLT4_7_OFFSET                        (0x044)
+#define IPROC_CLK_BUS_QUIESC_REG                       (0x19000100)
+#define IPROC_CLK_BUS_QUIESC_OFFSET                    (0x100)
+#define IPROC_CLK_CORE0_GATE_REG                       (0x19000200)
+#define IPROC_CLK_CORE0_GATE_OFFSET                    (0x200)
+#define IPROC_CLK_CORE1_GATE_REG                       (0x19000204)
+#define IPROC_CLK_CORE1_GATE_OFFSET                    (0x204)
+#define IPROC_CLK_ARM_SW_GATE_REG                      (0x19000210)
+#define IPROC_CLK_ARM_SW_GATE_OFFSET                   (0x210)
+#define IPROC_CLK_ARM_PERIPH_GATE_REG                  (0x19000300)
+#define IPROC_CLK_ARM_PERIPH_GATE_OFFSET               (0x300)
+#define IPROC_CLK_APB0_CLKGATE_REG                     (0x19000400)
+#define IPROC_CLK_APB0_CLKGATE_OFFSET                  (0x400)
+#define IPROC_CLK_PL310_DIV_REG                        (0x19000A00)
+#define IPROC_CLK_PL310_DIV_OFFSET                     (0xA00)
+#define IPROC_CLK_PL310_TRG_REG                        (0x19000A04)
+#define IPROC_CLK_PL310_TRG_OFFSET                     (0xA04)
+#define IPROC_CLK_ARM_SW_DIV_REG                       (0x19000A08)
+#define IPROC_CLK_ARM_SW_DIV_OFFSET                    (0xA08)
+#define IPROC_CLK_ARM_SW_TRG_REG                       (0x19000A0C)
+#define IPROC_CLK_ARM_SW_TRG_OFFSET                    (0xA0C)
+#define IPROC_CLK_APB_SW_DIV_REG                       (0x19000A10)
+#define IPROC_CLK_APB_SW_DIV_OFFSET                    (0xA10)
+#define IPROC_CLK_APB_SW_TRG_REG                       (0x19000A14)
+#define IPROC_CLK_APB_SW_TRG_OFFSET                    (0xA14)
+#define IPROC_CLK_PLL_ARMA_REG                         (0x19000C00)
+#define IPROC_CLK_PLL_ARMA_OFFSET                      (0xC00)
+#define IPROC_CLK_PLL_ARMB_REG                         (0x19000C04)
+#define IPROC_CLK_PLL_ARMB_OFFSET                      (0xC04)
+#define IPROC_CLK_PLL_ARMC_REG                         (0x19000C08)
+#define IPROC_CLK_PLL_ARMC_OFFSET                      (0xC08)
+#define IPROC_CLK_PLL_ARMCTL0_REG                      (0x19000C0C)
+#define IPROC_CLK_PLL_ARMCTL0_OFFSET                   (0xC0C)
+#define IPROC_CLK_PLL_ARMCTL1_REG                      (0x19000C10)
+#define IPROC_CLK_PLL_ARMCTL1_OFFSET                   (0xC10)
+#define IPROC_CLK_PLL_ARMCTL2_REG                      (0x19000C14)
+#define IPROC_CLK_PLL_ARMCTL2_OFFSET                   (0xC14)
+#define IPROC_CLK_PLL_ARMCTL3_REG                      (0x19000C18)
+#define IPROC_CLK_PLL_ARMCTL3_OFFSET                   (0xC18)
+#define IPROC_CLK_PLL_ARMCTL4_REG                      (0x19000C1C)
+#define IPROC_CLK_PLL_ARMCTL4_OFFSET                   (0xC1C)
+#define IPROC_CLK_PLL_ARMCTL5_REG                      (0x19000C20)
+#define IPROC_CLK_PLL_ARMCTL5_OFFSET                   (0xC20)
+#define IPROC_CLK_PLL_ARM_OFFSET_REG                   (0x19000C24)
+#define IPROC_CLK_PLL_ARM_OFFSET_OFFSET                (0xC24)
+#define IPROC_CLK_ARM_DIV_REG                          (0x19000E00)
+#define IPROC_CLK_ARM_DIV_OFFSET                       (0xE00)
+#define IPROC_CLK_ARM_SEG_TRG_REG                      (0x19000E04)
+#define IPROC_CLK_ARM_SEG_TRG_OFFSET                   (0xE04)
+#define IPROC_CLK_ARM_SEG_TRG_OVRD_REG                 (0x19000E08)
+#define IPROC_CLK_ARM_SEG_TRG_OVRD_OFFSET              (0xE08)
+#define IPROC_CLK_PLL_DEBUG_REG                        (0x19000E10)
+#define IPROC_CLK_PLL_DEBUG_OFFSET                     (0xE10)
+#define IPROC_CLK_ACTIVITY_MON1_REG                    (0x19000E20)
+#define IPROC_CLK_ACTIVITY_MON1_OFFSET                 (0xE20)
+#define IPROC_CLK_ACTIVITY_MON2_REG                    (0x19000E24)
+#define IPROC_CLK_ACTIVITY_MON2_OFFSET                 (0xE24)
+#define IPROC_CLK_GATE_DBG_REG                         (0x19000E40)
+#define IPROC_CLK_GATE_DBG_OFFSET                      (0xE40)
+#define IPROC_CLK_APB_CLKGATE_DBG1_REG                 (0x19000E48)
+#define IPROC_CLK_APB_CLKGATE_DBG1_OFFSET              (0xE48)
+#define IPROC_CLK_CLKMON_REG                           (0x19000E64)
+#define IPROC_CLK_CLKMON_OFFSET                        (0xE64)
+#define IPROC_CLK_KPROC_CCU_PROF_CTL_REG               (0x19000E90)
+#define IPROC_CLK_KPROC_CCU_PROF_CTL_OFFSET            (0xE90)
+#define IPROC_CLK_KPROC_CCU_PROF_SEL_REG               (0x19000E94)
+#define IPROC_CLK_KPROC_CCU_PROF_SEL_OFFSET            (0xE94)
+#define IPROC_CLK_KPROC_CCU_PROF_CNT_REG               (0x19000E98)
+#define IPROC_CLK_KPROC_CCU_PROF_CNT_OFFSET            (0xE98)
+#define IPROC_CLK_KPROC_CCU_PROF_DBG_REG               (0x19000E9C)
+#define IPROC_CLK_KPROC_CCU_PROF_DBG_OFFSET            (0xE9C)
+#define IPROC_CLK_POLICY_DBG_REG                       (0x19000EC0)
+#define IPROC_CLK_POLICY_DBG_OFFSET                    (0xEC0)
+#define IPROC_CLK_TGTMASK_DBG1_REG                     (0x19000EC4)
+#define IPROC_CLK_TGTMASK_DBG1_OFFSET                  (0xEC4)
+#define IPROC_RST_WR_ACCESS_REG                        (0x19000F00)
+#define IPROC_RST_WR_ACCESS_OFFSET                     (0xF00)
+#define IPROC_RST_SOFT_RSTN_REG                        (0x19000F04)
+#define IPROC_RST_SOFT_RSTN_OFFSET                     (0xF04)
+#define IPROC_RST_A9C_SOFT_RSTN_REG                    (0x19000F08)
+#define IPROC_RST_A9C_SOFT_RSTN_OFFSET                 (0xF08)
+#define IPROC_RST_A9CORE_SOFT_RSTN_REG                 (0x19000F08)
+#define IPROC_RST_A9CORE_SOFT_RSTN_OFFSET              (0xF08)
+
+#define PLLARMC_PLLARM_MDIV_SHIFT                      0
+#define PLLARMC_PLLARM_LOAD_EN_MASK                    (0x00000800)
+#define PLLARMA_PLLARM_NDIV_INT_MASK                   (0x0003FF00)
+#define PLLARMA_PLLARM_NDIV_INT_SHIFT                  8
+#define PLLARMB_PLLARM_NDIV_FRAC_MASK                  (0x000FFFFF)
+#define PLLARMB_PLLARM_NDIV_FRAC_SHIFT                 0
+#define ARMCTL5_PLLARM_H_MDIV_MASK                     (0x000000FF)
+#define ARMCTL5_PLLARM_H_MDIV_SHIFT                    0
+
+#define IPROC_CLK_CTL_REG                 (IPROC_CCA_CLK_CTL_REG_BASE + 0x000)
+#define IPROC_CCA_CLK_HW_REQ_OFF          0x00000020
+
+#define IPROC_DDRC_REG_BASE		  (DDR_DENALI_CTL_00) //(0x18010000)
+#define IPROC_DMAC_REG_BASE		  (DMAC_P1330_NON_DS) //(0x1802C000)
+#define IPROC_PCIE_AXIB0_REG_BASE	  (PAXB_0_PCIE_CTL) //(0x18012000)
+#define IPROC_PCIE_AXIB1_REG_BASE	  (PAXB_1_PCIE_CTL) //(0x18013000)
+#define IPROC_PCIE_AXIB2_REG_BASE	  (PAXB_2_PCIE_CTL) //(0x18014000)
+
+#if defined(CONFIG_MACH_NS)
+#define IPROC_SDIO3_REG_BASE		    (SDIO_EMMC_SDXC_SYSADDR) //(0x18020000)
+#define IPROC_SDIO_IDM_RESET_CONTROL    (0x16800)
+#define IPROC_SDIO_IRQ		            (177)
+#define IPROC_SDIO_IDM_IO_CONTROL_DIRECT        (0x18116408)
+#define IPROC_SDIO_IDM_IO_CONTROL_DIRECT__CMD_COMFLICT_DISABLE (22)
+#elif defined(CONFIG_MACH_NSP)
+#define IPROC_SDIO3_REG_BASE		    (SDIO_eMMCSDXC_SYSADDR) 
+#define IPROC_SDIO_IDM_RESET_CONTROL    (0x17800)
+#define IPROC_SDIO_IRQ		            (177)
+#define IPROC_SDIO_IDM_IO_CONTROL_DIRECT        (SDIO_IDM_IO_CONTROL_DIRECT)
+#define IPROC_SDIO_IDM_IO_CONTROL_DIRECT__CMD_COMFLICT_DISABLE  (SDIO_IDM_IO_CONTROL_DIRECT__CMD_COMFLICT_DISABLE)
+
+#endif
+
+#if defined(CONFIG_MACH_NS)
+#define IPROC_USB20_REG_BASE		  (0x18021000)
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_NSP) || defined(CONFIG_MACH_KT2)
+#define IPROC_USB20_REG_BASE		  (0x1802A000)
+#define IPROC_UDC_IRQ				  (238)
+#endif
+#define IPROC_USB30_REG_BASE		  (0x18023000)
+//#define IPROC_USB30_REG_BASE		  (0x18022000)
+#define IPROC_USB20_PHY_REG_BASE	  (0x18023000) /* ??*/
+
+#if (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2))
+#define IPROC_USB2D_REG_BASE	USB2D_ENDPNT_IN_CTRL_0
+#define IPROC_USB2D_REG_SIZE	(0x2000) /* 8KB */
+#endif
+
+#if defined(CONFIG_MACH_NS)
+#define IPROC_NUM_GMACS				4
+#define IPROC_GMAC0_REG_BASE		  (GMAC0_DEVCTL) //(0x18024000)
+#define IPROC_GMAC1_REG_BASE		  (GMAC1_DEVCTL) //(0x18025000)
+#define IPROC_GMAC2_REG_BASE		  (GMAC2_DEVCTL) //(0x18026000)
+#define IPROC_GMAC3_REG_BASE		  (GMAC3_DEVCTL) //(0x18027000)
+#define IPROC_GMAC0_INT				179
+#define IPROC_GMAC1_INT				180
+#define IPROC_GMAC2_INT				181
+#define IPROC_GMAC3_INT				182
+#elif (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2))
+#define IPROC_NUM_GMACS				2
+#define IPROC_GMAC0_REG_BASE		  (GMAC0_DEVCONTROL) //(0x18022000)
+#define IPROC_GMAC1_REG_BASE		  (GMAC1_DEVCONTROL) //(0x18023000)
+#define IPROC_GMAC2_REG_BASE		  (0) // n/a
+#define IPROC_GMAC3_REG_BASE		  (0) // n/a
+#define IPROC_GMAC0_INT				234
+#define IPROC_GMAC1_INT				235
+#define IPROC_GMAC2_INT				0	// n/a
+#define IPROC_GMAC3_INT				0	// n/a
+#elif defined(CONFIG_MACH_HR2)
+#define IPROC_NUM_GMACS				1
+#define IPROC_GMAC0_REG_BASE		  (GMAC0_DEVCONTROL) //(0x18022000)
+#define IPROC_GMAC1_REG_BASE		  (0) // n/a
+#define IPROC_GMAC2_REG_BASE		  (0) // n/a
+#define IPROC_GMAC3_REG_BASE		  (0) // n/a
+#define IPROC_GMAC0_INT				234
+#define IPROC_GMAC1_INT				0	// n/a
+#define IPROC_GMAC2_INT				0	// n/a
+#define IPROC_GMAC3_INT				0	// n/a
+#elif defined(CONFIG_MACH_NSP)
+#define IPROC_NUM_GMACS				4
+#define IPROC_GMAC0_REG_BASE		(GMAC0_DEVCONTROL)    //(0x18022000)
+#define IPROC_GMAC1_REG_BASE		(GMAC1_DEVCONTROL)    //(0x18023000)
+#define IPROC_GMAC2_REG_BASE		(FA_GMAC0_DEVCONTROL) //(0x18024000)
+#define IPROC_GMAC3_REG_BASE		(FA_GMAC1_DEVCONTROL) //(0x18025000)
+#define IPROC_GMAC0_INT				179
+#define IPROC_GMAC1_INT				180
+#define IPROC_GMAC2_INT				181
+#define IPROC_GMAC3_INT				182
+#endif
+
+#define IPROC_CTF_REG_BASE		  (0x18027C00)
+
+#define IPROC_I2S_REG_BASE		  (0x1802A000)
+#define IPROC_CCU_PROF_CTL_REG_BASE       (0x19000E90)
+
+/* IDM / CRU / DMU */
+#if defined(CONFIG_MACH_NS)
+#define IPROC_CRU_REG_BASE				(0x1800b000)
+#define IPROC_DMU_REG_BASE				(0x1800c000)
+#define IPROC_IDM_REG_BASE				(0x18100000)
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2) || defined(CONFIG_MACH_KT2)
+#define IPROC_CRU_REG_BASE				CRU_control
+#define IPROC_DMU_REG_BASE				DMU_PCU_IPROC_CONTROL
+#define IPROC_IDM_REG_BASE				(IHOST_M0_IO_CONTROL_DIRECT - 0x408)
+#elif defined(CONFIG_MACH_NSP)
+#define IPROC_CRU_REG_BASE				CRU_control
+#define IPROC_DMU_REG_BASE				PCU_MDIO_MGT
+#define IPROC_IDM_REG_BASE				(IHOST_M0_IO_CONTROL_DIRECT - 0x408)
+#endif
+#define DMU_PCU_IPROC_CONTROL 0x1803f000
+
+/* Straps */
+#if defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+#define IPROC_DMU_STRAPS_OFFSET			(0x2a0)
+#define IPROC_STRAP_BOOT_DEV_SHIFT		(16)
+#define IPROC_STRAP_NAND_TYPE_SHIFT		(12)
+#define IPROC_STRAP_NAND_PAGE_SHIFT		(10)
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2) || defined(CONFIG_MACH_KT2)
+#define IPROC_DMU_STRAPS_OFFSET			DMU_PCU_IPROC_STRAPS_CAPTURED_BASE
+#define IPROC_STRAP_BOOT_DEV_SHIFT		DMU_PCU_IPROC_STRAPS_CAPTURED__strap_boot_dev_R
+#define IPROC_STRAP_NAND_TYPE_SHIFT		DMU_PCU_IPROC_STRAPS_CAPTURED__strap_nand_type_R
+#define IPROC_STRAP_NAND_PAGE_SHIFT		DMU_PCU_IPROC_STRAPS_CAPTURED__strap_nand_page_R
+#endif
+
+/* NAND and QSPI */
+#if defined(CONFIG_MACH_NS)
+#define IPROC_IDM_NAND_REG_BASE		  (0x1811a408)
+#define IPROC_NAND_IRQ_START		  (100)
+#define IPROC_IDM_QSPI_REG_BASE		  (0x1811b408)
+#define IPROC_QSPI_IRQ_START		  (104)
+#define IPROC_QSPI_IRQ_END		  (109)
+#elif defined(CONFIG_MACH_NSP)
+#define IPROC_IDM_NAND_REG_BASE		  NAND_IDM_IDM_IO_CONTROL_DIRECT
+#define IPROC_NAND_IRQ_START		  (100)
+#define IPROC_IDM_QSPI_REG_BASE		  QSPI_IDM_IDM_IO_CONTROL_DIRECT
+#define IPROC_QSPI_IRQ_START		  (104)
+#define IPROC_QSPI_IRQ_END		  (109)
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2) || defined(CONFIG_MACH_KT2)
+#define IPROC_IDM_NAND_REG_BASE		  NAND_IDM_IDM_IO_CONTROL_DIRECT
+#define IPROC_NAND_IRQ_START		  (106)
+#define IPROC_IDM_QSPI_REG_BASE		  QSPI_IDM_IDM_IO_CONTROL_DIRECT
+#define IPROC_QSPI_IRQ_START		  (110)
+#define IPROC_QSPI_IRQ_END		  (116)
+#endif
+
+/* ARM9 Private memory region */
+#define IPROC_PERIPH_BASE		  (0x19020000) //(IHOST_A9MP_scu_CONTROL)
+#define IPROC_PERIPH_SCU_REG_BASE	  (IPROC_PERIPH_BASE)
+#define IPROC_PERIPH_INT_CTRL_REG_BASE	  (IPROC_PERIPH_BASE + 0x100)
+#define IPROC_PERIPH_GLB_TIM_REG_BASE	  (IPROC_PERIPH_BASE + 0x200)
+#define IPROC_PERIPH_PVT_TIM_REG_BASE	  (IPROC_PERIPH_BASE + 0x600)
+#define IPROC_PERIPH_PVT_WDT_REG_BASE	  (IPROC_PERIPH_BASE + 0x620)
+#define IPROC_PERIPH_INT_DISTR_REG_BASE   (IPROC_PERIPH_BASE + 0x1000)
+#define IPROC_L2CC_REG_BASE		  (IPROC_PERIPH_BASE + 0x2000)
+#define IPROC_GTIM_GLB_LO                               (0x00000000)
+#define IPROC_GTIM_GLB_HI                               (0x00000004)
+#define IPROC_GTIM_GLB_CTL                              (0x00000008)
+#define IPROC_GTIM_GLB_STS                              (0x0000000C)
+#define IPROC_GTIM_GLB_CMP_LO                           (0x00000010)
+#define IPROC_GTIM_GLB_CMP_HI                           (0x00000014)
+#define IPROC_GTIM_GLB_INCR                             (0x00000018)
+
+/* Structures and bit definitions */
+/* SCU Control register */
+#define IPROC_SCU_CTRL_SCU_EN		                (0x00000001)
+#define IPROC_SCU_CTRL_ADRFLT_EN	                (0x00000002)
+#define IPROC_SCU_CTRL_PARITY_EN	                (0x00000004)
+#define IPROC_SCU_CTRL_SPEC_LNFL_EN	                (0x00000008)
+#define IPROC_SCU_CTRL_FRC2P0_EN	                (0x00000010)
+#define IPROC_SCU_CTRL_SCU_STNDBY_EN	                (0x00000020)
+#define IPROC_SCU_CTRL_IC_STNDBY_EN	                (0x00000040)
+
+/* ARM A9 Private Timer */
+#define IPROC_PVT_TIM_CTRL_TIM_EN	                (0x00000001)
+#define IPROC_PVT_TIM_CTRL_AUTO_RELD	                (0x00000002)
+#define IPROC_PVT_TIM_CTRL_INT_EN	                (0x00000004)
+#define IPROC_PVT_TIM_CTRL_PRESC_MASK	                (0x0000FF00)
+#define IPROC_PVT_TIM_INT_STATUS_SET	                (0x00000001)
+
+/* Global timer */
+#define IPROC_GLB_TIM_CTRL_STCS_EN	                (0x00000000)
+#define IPROC_GLB_TIM_CTRL_TIM_EN	                (0x00000001)
+#define IPROC_GLB_TIM_CTRL_COMP_EN	                (0x00000002)
+#define IPROC_GLB_TIM_CTRL_INT_EN	                (0x00000004)
+#define IPROC_GLB_TIM_CTRL_AUTO_INC	                (0x00000008)
+#define IPROC_GLB_TIM_CTRL_STCM_SET	                (0x0000000C)
+#define IPROC_GLB_TIM_CTRL_PRESC_MASK	                (0x0000FF00)
+#define IPROC_GLB_TIM_INT_STATUS_SET	                (0x00000001)
+
+#define GLBTMR_GLOB_STATUS_EVENT_G_SHIFT                (0x00000000)
+#define GLBTMR_GLOB_CTRL_TIMER_EN_G_SHIFT               (0x00000000)
+
+/* GIC(Generic Interrupt controller) CPU interface registers */
+#define IPROC_GICCPU_CTL_REG_BASE                       (0x19020100)
+#define IPROC_GICCPU_PRI_MASK_OFFSET                    (0x04)
+#define IPROC_GICCPU_BIN_PT_OFFSET                      (0x08)
+#define IPROC_GICCPU_INT_ACK_OFFSET                     (0x0C)
+#define IPROC_GICCPU_EOI_OFFSET                         (0x10)
+#define IPROC_GICCPU_RUN_PRI_OFFSET                     (0x14)
+#define IPROC_GICCPU_HI_PEND_OFFSET                     (0x18)
+#define IPROC_GICCPU_ALIAS_BIN_PT_NS_OFFSET             (0x1C)
+#define IPROC_GICCPU_INT_GFC_OFFSET                     (0x40)
+#define IPROC_GICCPU_INT_FIQ_SET_OFFSET                 (0x44)
+#define IPROC_GICCPU_INTEG_MATCH_OFFSET                 (0x50)
+#define IPROC_GICCPU_INTEG_ENABLE_OFFSET                (0x54)
+#define IPROC_GICCPU_CPU_IDENT_OFFSET                   (0xFC)
+
+#define IPROC_GIC_CI_CTRL_EN		                (0x00000001)
+#define IPROC_GIC_CI_PMR_PRIO_MASK	                (0x000000FF)
+#define IPROC_GIC_CI_BPR_BP_MASK	                (0x00000003)
+#define IPROC_GIC_CI_IAR_INTID_MASK	                (0x000003FF)
+#define IPROC_GIC_CI_IAR_CPUID_MASK	                (0x00001C00)
+#define IPROC_GIC_CI_IAR_CPUID_OFFSET	                (10)
+#define IPROC_GIC_CI_EOIR_INTID_MASK	                (0x000003FF)
+#define IPROC_GIC_CI_EOIR_CPUID_MASK	                (0x00001C00)
+#define IPROC_GIC_CI_EOIR_CPUID_OFFSET	                (10)
+#define IPROC_GIC_CI_RPR_PRIO_MASK	                (0x000000FF)
+#define IPROC_GIC_CI_HPIR_PENDID_MASK	                (0x000003FF)
+#define IPROC_GIC_CI_HPIR_CPUID_MASK	                (0x00001C00)
+#define IPROC_GIC_CI_HPIR_CPUID_OFFSET	                (10)
+#define IPROC_GIC_CI_ABPR_BP_MASK	                (0x00000003)
+
+#define IPROC_GIC_DIST_CTRL_S_EN_S			(0x00000001)
+#define IPROC_GIC_DIST_CTRL_S_EN_NS			(0x00000002)
+#define IPROC_GIC_DIST_CTRL_NS_EN_NS			(0x00000001)
+
+#define IPROC_GIC_DIST_ISR_BIT_SIZE			(1)
+#define IPROC_GIC_DIST_ISER_BIT_SIZE			(1)
+#define IPROC_GIC_DIST_ICER_BIT_SIZE			(1)
+#define IPROC_GIC_DIST_ISPR_BIT_SIZE			(1)
+#define IPROC_GIC_DIST_ISPR_SECURE			(1)
+#define IPROC_GIC_DIST_ISPR_NON_SECURE			(0)
+#define IPROC_GIC_DIST_ICPR_BIT_SIZE			(1)
+#define IPROC_GIC_DIST_IPR_BIT_SIZE			(8)
+#define IPROC_GIC_DIST_IPTR_BIT_SIZE			(8)
+#define IPROC_GIC_DIST_IPTR_CPU0			(0x01)
+#define IPROC_GIC_DIST_IPTR_CPU1			(0x02)
+#define IPROC_GIC_DIST_SGIR_ID_MASK			(0xF)
+#define IPROC_GIC_DIST_SGIR_TR_LIST_MASK		(0x00FF0000)
+#define IPROC_GIC_DIST_SGIR_TR_LIST_BOFFSET		(16)
+#define IPROC_GIC_DIST_SGIR_TR_FILT_MASK		(0x03000000)
+#define IPROC_GIC_DIST_SGIR_TR_FILT_BOFFSET		(24)
+#define IPROC_GIC_DIST_SGIR_TR_FILT_FW_LIST		(0)
+#define IPROC_GIC_DIST_SGIR_TR_FILT_FW_ALL_EX_ME	(0x01)
+#define IPROC_GIC_DIST_SGIR_TR_FILT_FW_ME_ONLY		(0x02)
+
+#define IPROC_INTR_LEVEL_SENSITIVE			(1)
+#define IPROC_INTR_EDGE_TRIGGERED			(2)
+
+/* GPIO Driver */
+#if defined(CONFIG_IPROC_GPIO) || defined(CONFIG_IPROC_GPIO_MODULE) || \
+	defined(CONFIG_IPROC_PWM) || defined(CONFIG_IPROC_PWM_MODULE)
+
+/* Chipcommon A GPIO */
+#if defined(CONFIG_MACH_NS)
+#define IPROC_CCA_INT_STS               (CCA_INT_STS_BASE)
+#define IPROC_CCA_INT_MASK              (CCA_INT_MASK_BASE)
+#define IPROC_GPIO_CCA_BASE             (CCA_GPIO_INPUT)
+#define IPROC_GPIO_CCA_DIN              (CCA_GPIO_INPUT_BASE -  CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_DOUT             (CCA_GPIO_OUT_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_EN               (CCA_GPIO_OUT_EN_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_INT_LEVEL        (CCA_GPIO_INT_POLARITY_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_INT_LEVEL_MASK   (CCA_GPIOINT_MASK_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_INT_EVENT        (CCA_GPIO_EVT_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_INT_EVENT_MASK   (CCA_GPIO_EVTINT_MASK_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_WATCHDOG_COUNTER (CCA_WDOG_CTR_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_INT_EDGE         (CCA_GPIO_EVT_INT_POLARITY_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_TIMER_VAL        (CCA_GPIO_TMR_VAL_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_TIMEOUT_MASK     (CCA_GPIO_TMR_OUT_MASK_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_CLK_DIV          (CCA_CLK_DIV_BASE - CCA_GPIO_INPUT_BASE)
+#define IPROC_GPIO_CCA_DEBUG            (CCA_GPIODBG_SEL_BASE - CCA_GPIO_INPUT_BASE)
+
+#define IPROC_DMU_BASE              (0x1800c000)
+
+#define IPROC_GPIO_CCA_PULL_UP          (0x01dc)
+#define IPROC_GPIO_CCA_PULL_DOWN        (0x01e0)
+#define IPROC_GPIO_CCA_CTRL0            (0x01c0)
+
+#else
+/* CONFIG_MACH_HX4, CONFIG_MACH_HR2, CONFIG_MACH_NSP, CONFIG_MACH_KT2 */
+#define IPROC_CCA_INT_STS               (ChipcommonA_IntStatus_BASE)
+#define IPROC_CCA_INT_MASK              (ChipcommonA_IntMask_BASE)
+#define IPROC_GPIO_CCA_BASE             (ChipcommonA_GPIOInput)
+#define IPROC_GPIO_CCA_DIN              (ChipcommonA_GPIOInput_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_DOUT             (ChipcommonA_GPIOOut_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_EN               (ChipcommonA_GPIOOutEn_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_INT_LEVEL        (ChipcommonA_GPIOIntPolarity_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_INT_LEVEL_MASK   (ChipcommonA_GPIOIntMask_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_INT_EVENT        (ChipcommonA_GPIOEvent_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_INT_EVENT_MASK   (ChipcommonA_GPIOEventIntMask_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_WATCHDOG_COUNTER (ChipcommonA_WatchdogCounter_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_INT_EDGE         (ChipcommonA_GPIOEventIntPolarity_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_TIMER_VAL        (ChipcommonA_GPIOTimerVal_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_TIMEOUT_MASK     (ChipcommonA_GPIOTimerOutMask_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_CLK_DIV          (ChipcommonA_ClkDiv_BASE - ChipcommonA_GPIOInput_BASE)
+#define IPROC_GPIO_CCA_DEBUG            (ChipcommonA_GPIODebugSel_BASE - ChipcommonA_GPIOInput_BASE)
+#endif
+
+#if defined(CONFIG_MACH_NSP)
+#define IPROC_DMU_BASE                  (DMAC_pl330_DS)
+#define IPROC_GPIO_CCA_PULL_UP          (CRU_GPIO_CONTROL7_BASE)
+#define IPROC_GPIO_CCA_PULL_DOWN        (CRU_GPIO_CONTROL8_BASE)
+#define IPROC_GPIO_CCA_CTRL0            (CRU_GPIO_CONTROL0_BASE)
+#endif
+
+/* Chipcommon B GPIO */
+#if defined(CONFIG_MACH_NS)
+#define IPROC_GPIO_CCB_BASE         (CCB_GP_DATA_IN)
+#define IPROC_GPIO_CCB_DIN          (CCB_GP_DATA_IN_BASE)
+#define IPROC_GPIO_CCB_DOUT         (CCB_GP_DATA_OUT_BASE)
+#define IPROC_GPIO_CCB_EN           (CCB_GP_OUT_EN_BASE)
+#define IPROC_GPIO_CCB_INT_TYPE     (CCB_GP_INT_TYPE_BASE)
+#define IPROC_GPIO_CCB_INT_DE       (CCB_GP_INT_DE_BASE)
+#define IPROC_GPIO_CCB_INT_EDGE     (CCB_GP_INT_EDGE_BASE)
+#define IPROC_GPIO_CCB_INT_MASK     (CCB_GP_INT_MSK_BASE)
+#define IPROC_GPIO_CCB_INT_STAT     (CCB_GP_INT_STAT_BASE)
+#define IPROC_GPIO_CCB_INT_MSTAT    (CCB_GP_INT_MSTAT_BASE)
+#define IPROC_GPIO_CCB_INT_CLR      (CCB_GP_INT_CLR_BASE)
+#define IPROC_GPIO_CCB_AUX_SEL      (CCB_GP_AUX_SEL_BASE)
+#define IPROC_GPIO_CCB_INIT_VAL     (CCB_GP_INIT_VAL_BASE)
+#define IPROC_GPIO_CCB_PAD_RES      (CCB_GP_PAD_RES_BASE)
+#define IPROC_GPIO_CCB_RES_EN       (CCB_GP_RES_EN_BASE)
+#define IPROC_GPIO_CCB_TST_IN       (CCB_GP_TEST_INPUT_BASE)
+#define IPROC_GPIO_CCB_TST_OUT      (CCB_GP_TEST_OUTPUT_BASE)
+#define IPROC_GPIO_CCB_TST_EN       (CCB_GP_TEST_ENABLE_BASE)
+#define IPROC_GPIO_CCB_PRB_EN       (CCB_GP_PRB_ENABLE_BASE)
+#define IPROC_GPIO_CCB_PRB_OE       (CCB_GP_PRB_OE_BASE)
+#else
+/* CONFIG_MACH_HX4, CONFIG_MACH_HR2, CONFIG_MACH_NSP, CONFIG_MACH_KT2 */
+#define IPROC_GPIO_CCB_BASE         (ChipcommonB_GP_DATA_IN)
+#define IPROC_GPIO_CCB_DIN          (ChipcommonB_GP_DATA_IN_BASE)
+#define IPROC_GPIO_CCB_DOUT         (ChipcommonB_GP_DATA_OUT_BASE)
+#define IPROC_GPIO_CCB_EN           (ChipcommonB_GP_OUT_EN_BASE)
+#define IPROC_GPIO_CCB_INT_TYPE     (ChipcommonB_GP_INT_TYPE_BASE)
+#define IPROC_GPIO_CCB_INT_DE       (ChipcommonB_GP_INT_DE_BASE)
+#define IPROC_GPIO_CCB_INT_EDGE     (ChipcommonB_GP_INT_EDGE_BASE)
+#define IPROC_GPIO_CCB_INT_MASK     (ChipcommonB_GP_INT_MSK_BASE)
+#define IPROC_GPIO_CCB_INT_STAT     (ChipcommonB_GP_INT_STAT_BASE)
+#define IPROC_GPIO_CCB_INT_MSTAT    (ChipcommonB_GP_INT_MSTAT_BASE)
+#define IPROC_GPIO_CCB_INT_CLR      (ChipcommonB_GP_INT_CLR_BASE)
+#define IPROC_GPIO_CCB_AUX_SEL      (ChipcommonB_GP_AUX_SEL_BASE)
+#define IPROC_GPIO_CCB_INIT_VAL     (ChipcommonB_GP_INIT_VAL_BASE)
+#define IPROC_GPIO_CCB_PAD_RES      (ChipcommonB_GP_PAD_RES_BASE)
+#define IPROC_GPIO_CCB_RES_EN       (ChipcommonB_GP_RES_EN_BASE)
+#define IPROC_GPIO_CCB_TST_IN       (ChipcommonB_GP_TEST_INPUT_BASE)
+#define IPROC_GPIO_CCB_TST_OUT      (ChipcommonB_GP_TEST_OUTPUT_BASE)
+#define IPROC_GPIO_CCB_TST_EN       (ChipcommonB_GP_TEST_ENABLE_BASE)
+#define IPROC_GPIO_CCB_PRB_EN       (ChipcommonB_GP_PRB_ENABLE_BASE)
+#define IPROC_GPIO_CCB_PRB_OE       (ChipcommonB_GP_PRB_OE_BASE)
+#endif
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+#define IPROC_GPIO_CCA_INT          (117)
+#define IPROC_GPIO_CCB_INT          (119)
+#else
+/* CONFIG_MACH_HX4, CONFIG_MACH_HR2, CONFIG_MACH_KT2 */
+#define IPROC_GPIO_CCA_INT          (123)
+#define IPROC_GPIO_CCB_INT          (125)
+#endif
+#endif /* CONFIG_IPROC_GPIO || CONFIG_IPROC_GPIO_MODULE */
+
+/* PWM Driver */
+#if defined(CONFIG_IPROC_PWM) || defined(CONFIG_IPROC_PWM_MODULE)
+#if defined(CONFIG_MACH_NS)
+#define IPROC_CCB_PWM_CTL                   (CCB_PWM_CTL)
+#define IPROC_CCB_PWM_CTL_BASE              (CCB_PWM_CTL_BASE)
+#define IPROC_CCB_PWM_PRESCALE_BASE         (CCB_PWM_PRESCALE_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT0_BASE    (CCB_PWM_PERIOD_COUNT0_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT1_BASE    (CCB_PWM_PERIOD_COUNT1_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT2_BASE    (CCB_PWM_PERIOD_COUNT2_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT3_BASE    (CCB_PWM_PERIOD_COUNT3_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT0_BASE   (CCB_PWM_DUTY_HI_COUNT0_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT1_BASE   (CCB_PWM_DUTY_HI_COUNT1_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT2_BASE   (CCB_PWM_DUTY_HI_COUNT2_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT3_BASE   (CCB_PWM_DUTY_HI_COUNT3_BASE)   
+#endif /* CONFIG_MACH_NS */
+
+#if defined(CONFIG_MACH_NSP)
+#define IPROC_CCB_PWM_CTL                   (ChipcommonB_PWMCTL)
+#define IPROC_CCB_PWM_CTL_BASE              (ChipcommonB_PWMCTL_BASE)
+#define IPROC_CCB_PWM_PRESCALE_BASE         (ChipcommonB_PWM_PRESCALE_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT0_BASE    (ChipcommonB_PWM_PERIOD_COUNT0_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT1_BASE    (ChipcommonB_PWM_PERIOD_COUNT1_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT2_BASE    (ChipcommonB_PWM_PERIOD_COUNT2_BASE)
+#define IPROC_CCB_PWM_PERIOD_COUNT3_BASE    (ChipcommonB_PWM_PERIOD_COUNT3_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT0_BASE   (ChipcommonB_PWM_DUTYHI_COUNT0_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT1_BASE   (ChipcommonB_PWM_DUTYHI_COUNT1_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT2_BASE   (ChipcommonB_PWM_DUTYHI_COUNT2_BASE)
+#define IPROC_CCB_PWM_DUTY_HI_COUNT3_BASE   (ChipcommonB_PWM_DUTYHI_COUNT3_BASE)
+#endif /* CONFIG_MACH_NSP */
+
+#endif /* CONFIG_IPROC_PWM */
+
+/* ChipCommonB Timer */
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+#define IPROC_CCB_TIMER_INT_START   (122)
+#define IPROC_CCB_TIMER_INT_COUNT   (4)
+#else
+/* CONFIG_MACH_HX4, CONFIG_MACH_HR2, CONFIG_MACH_KT2 */
+#define IPROC_CCB_TIMER_INT_START   (129)
+#define IPROC_CCB_TIMER_INT_COUNT   (4)
+#endif
+
+/* ChipCommonB Watchdog */
+#if defined(CONFIG_IPROC_CCB_WDT) || defined(CONFIG_IPROC_CCB_WDT_MODULE)
+/* CCB WDT could be set only when CONFIG_MACH_HR2, CONFIG_MACH_HX4, or CONFIG_MACH_NSP is set */
+#define IPROC_CCB_WDT_WDOGLOAD	ChipcommonB_WDT_WDOGLOAD
+#define IPROC_CCB_WDT_REG_BASE	IPROC_CCB_WDT_WDOGLOAD
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2) || defined(CONFIG_MACH_KT2)
+#define IPROC_CCB_WDT_BOOTSTATUS		DMU_PCU_CRU_RESET_REASON
+#define IPROC_CCB_WDT_BOOTSTATUS_BIT	DMU_PCU_CRU_RESET_REASON__watchdog_reset
+#elif defined(CONFIG_MACH_NSP)
+#define IPROC_CCB_WDT_BOOTSTATUS		CRU_WATCHDOG_PCIE_RESET_STATUS
+#define IPROC_CCB_WDT_BOOTSTATUS_BIT	CRU_WATCHDOG_PCIE_RESET_STATUS__CCB_WATCHDOG_RESET_EVENT
+#endif
+#endif /* CONFIG_IPROC_CCB_WDT || CONFIG_IPROC_CCB_WDT_MODULE */
+
+#endif /*__IPROC_REGS_H */
diff --git a/arch/arm/mach-iproc/include/mach/nand_iproc.h b/arch/arm/mach-iproc/include/mach/nand_iproc.h
new file mode 100644
index 0000000..532148a
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/nand_iproc.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _NAND_IPROC_H_
+#define _NAND_IPROC_H_
+
+/*
+ * Registers used directly in driver
+ */
+
+/*
+ * Shared Structure
+ */
+struct mtd_partition;
+struct brcmnand_platform_data {
+	int			chip_select;
+	int			strap_boot;
+	int			strap_type;
+	int			strap_page_size;
+	int			nr_parts;
+	struct mtd_partition	*parts;
+};
+ 
+#endif /* _NAND_IPROC_H_ */
diff --git a/arch/arm/mach-iproc/include/mach/qspi_iproc.h b/arch/arm/mach-iproc/include/mach/qspi_iproc.h
new file mode 100644
index 0000000..87d49bb
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/qspi_iproc.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _QSPI_IPROC_H_
+#define _QSPI_IPROC_H_
+
+/*
+ * Shared Structure
+ */
+struct brcmspi_platform_data {
+	int			flash_cs;
+};
+ 
+#endif /* _SPI_IPROC_H_ */
diff --git a/arch/arm/mach-iproc/include/mach/reg_utils.h b/arch/arm/mach-iproc/include/mach/reg_utils.h
new file mode 100644
index 0000000..0b3519b
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/reg_utils.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef REG_UTILS
+#define REG_UTILS
+
+/* ---- Include Files ---------------------------------------------------- */
+
+#include <linux/types.h>
+
+/* ---- Public Constants and Types --------------------------------------- */
+
+#define __REG32(x)      (*((volatile uint32_t *)(x)))
+#define __REG16(x)      (*((volatile uint16_t *)(x)))
+#define __REG8(x)       (*((volatile uint8_t *) (x)))
+
+/* ---- Public Variable Externs ------------------------------------------ */
+/* ---- Public Function Prototypes --------------------------------------- */
+
+/****************************************************************************/
+/*
+ *   32-bit register access functions
+ */
+/****************************************************************************/
+
+static inline void 
+reg32_clear_bits(volatile uint32_t *reg, uint32_t value)
+{
+    *reg &= ~(value);
+}
+
+static inline void 
+reg32_set_bits(volatile uint32_t *reg, uint32_t value)
+{
+    *reg |= value;
+}
+
+static inline void 
+reg32_toggle_bits(volatile uint32_t *reg, uint32_t value)
+{
+    *reg ^= value;
+}
+
+static inline void 
+reg32_write_masked(volatile uint32_t *reg, uint32_t mask, 
+                                      uint32_t value)
+{
+    *reg = (*reg & (~mask)) | (value & mask);
+}
+
+static inline void 
+reg32_write(volatile uint32_t *reg, uint32_t value)
+{
+    *reg = value;
+}
+
+static inline uint32_t 
+reg32_read(volatile uint32_t *reg)
+{
+    return *reg;
+}
+
+/****************************************************************************/
+/*
+ *   16-bit register access functions
+ */
+/****************************************************************************/
+
+static inline void 
+reg16_clear_bits(volatile uint16_t *reg, uint16_t value)
+{
+    *reg &= ~(value);
+}
+
+static inline void 
+reg16_set_bits(volatile uint16_t *reg, uint16_t value)
+{
+    *reg |= value;
+}
+
+static inline void 
+reg16_toggle_bits(volatile uint16_t *reg, uint16_t value)
+{
+    *reg ^= value;
+}
+
+static inline void 
+reg16_write_masked(volatile uint16_t *reg, uint16_t mask, uint16_t value)
+{
+    *reg = (*reg & (~mask)) | (value & mask);
+}
+
+static inline void 
+reg16_write(volatile uint16_t *reg, uint16_t value)
+{
+    *reg = value;
+}
+
+static inline uint16_t 
+reg16_read(volatile uint16_t *reg)
+{
+    return *reg;
+}
+
+/****************************************************************************/
+/*
+ *   8-bit register access functions
+ */
+/****************************************************************************/
+
+static inline void 
+reg8_clear_bits(volatile uint8_t *reg, uint8_t value)
+{
+    *reg &= ~(value);
+}
+
+static inline void 
+reg8_set_bits(volatile uint8_t *reg, uint8_t value)
+{
+    *reg |= value;
+}
+
+static inline void 
+reg8_toggle_bits(volatile uint8_t *reg, uint8_t value)
+{
+    *reg ^= value;
+}
+
+static inline void 
+reg8_write_masked(volatile uint8_t *reg, uint8_t mask, uint8_t value)
+{
+    *reg = (*reg & (~mask)) | (value & mask);
+}
+
+static inline void 
+reg8_write(volatile uint8_t *reg, uint8_t value)
+{
+    *reg = value;
+}
+
+static inline uint8_t 
+reg8_read(volatile uint8_t *reg)
+{
+    return *reg;
+}
+#endif /* REG_UTILS */
diff --git a/arch/arm/mach-iproc/include/mach/socregs_ing_open.h b/arch/arm/mach-iproc/include/mach/socregs_ing_open.h
new file mode 100644
index 0000000..d211e3a
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/socregs_ing_open.h
@@ -0,0 +1,762 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __SOCREGS_ING_OPEN_H
+#define __SOCREGS_ING_OPEN_H
+
+#define ChipcommonA_ChipID 0x18000000
+#define ChipcommonB_PWMCTL 0x18031000
+#define ChipcommonB_WDT_WDOGLOAD 0x18039000
+#define ChipcommonB_GP_DATA_IN 0x18030000
+#define ChipcommonB_GP_AUX_SEL_BASE 0x028
+#define ChipcommonB_SMBus_Config 0x18038000
+#define QSPI_mspi_SPCR0_LSB 0x18027200
+#define QSPI_mspi_DISABLE_FLUSH_GEN 0x18027384
+#define QSPI_bspi_registers_REVISION_ID 0x18027000
+#define QSPI_bspi_registers_BSPI_PIO_DATA 0x1802704c
+#define QSPI_raf_START_ADDR 0x18027100
+#define QSPI_raf_interrupt_LR_fullness_reached 0x180273a0
+#define QSPI_mspi_interrupt_MSPI_halt_set_transaction_done 0x180273b8
+#define QSPI_IDM_IDM_IO_CONTROL_DIRECT 0x1811c408
+#define QSPI_raf_CURR_ADDR 0x18027120
+#define CRU_control 0x1803e000
+#define GMAC0_DEVCONTROL 0x18022000
+#define GMAC1_DEVCONTROL 0x18023000
+#define ChipcommonA_GPIOEvent_BASE 0x078
+#define ChipcommonA_GPIOInput_BASE 0x060
+#define ChipcommonB_GP_INT_CLR_BASE 0x024
+#define ChipcommonA_GPIOEventIntMask_BASE 0x07c
+#define ChipcommonA_GPIOInput_BASE 0x060
+#define ChipcommonB_GP_INT_MSK_BASE 0x018
+#define ChipcommonA_GPIOIntMask_BASE 0x074
+#define ChipcommonB_GP_INT_MSK_BASE 0x018
+#define ChipcommonA_GPIOEventIntMask_BASE 0x07c
+#define ChipcommonB_GP_INT_MSTAT_BASE 0x020
+#define ChipcommonA_GPIOEventIntPolarity_BASE 0x084
+#define ChipcommonA_IntStatus_BASE 0x020
+#define ChipcommonA_GPIOIntPolarity_BASE 0x070
+#define ChipcommonA_IntStatus_BASE 0x020
+#define ChipcommonB_GP_INT_DE_BASE 0x010
+#define ChipcommonB_GP_INT_EDGE_BASE 0x014
+#define ChipcommonB_GP_INT_TYPE_BASE 0x00c
+#define ChipcommonA_GPIOIntPolarity_BASE 0x070
+#define ChipcommonB_GP_AUX_SEL_BASE 0x028
+#define ChipcommonB_GP_PAD_RES_BASE 0x034
+#define ChipcommonB_GP_RES_EN_BASE 0x038
+#define ChipcommonA_ChipID 0x18000000
+#define DMAC_pl330_DS 0x18020000
+#define ChipcommonA_GPIOInput 0x18000060
+#define ChipcommonB_GP_DATA_IN 0x18030000
+#define PAXB_0_CLK_CONTROL 0x18012000
+#define PAXB_0_CONFIG_IND_ADDR_BASE 0x120
+#define ChipcommonB_MII_Management_Control 0x18032000
+#define ChipcommonB_MII_Management_Command_Data 0x18032004
+#define NAND_nand_flash_REVISION 0x18026000
+#define NAND_direct_read_rd_miss 0x18026f00
+#define NAND_IDM_IDM_IO_CONTROL_DIRECT 0x1811b408
+#define ChipcommonB_PWM_PERIOD_COUNT0_BASE 0x004
+#define ChipcommonB_PWM_PRESCALE_BASE 0x024
+#define ChipcommonB_PWM_PERIOD_COUNT1_BASE 0x00c
+#define ChipcommonB_PWM_PERIOD_COUNT2_BASE 0x014
+#define ChipcommonB_PWM_PERIOD_COUNT3_BASE 0x01c
+#define ChipcommonB_PWM_DUTYHI_COUNT0_BASE 0x008
+#define ChipcommonB_PWM_DUTYHI_COUNT1_BASE 0x010
+#define ChipcommonB_PWM_DUTYHI_COUNT2_BASE 0x018
+#define ChipcommonB_PWM_DUTYHI_COUNT3_BASE 0x020
+#define ChipcommonB_PWMCTL_BASE 0x000
+#define ChipcommonB_rng_CTRL 0x18033000
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define USB2_IDM_IDM_IO_CONTROL_DIRECT 0x18115408
+#define USB2D_IDM_IDM_IO_CONTROL_DIRECT 0x18116408
+#define USB2D_IDM_IDM_IO_CONTROL_DIRECT__clk_enable 0
+#define USB2D_IDM_IDM_RESET_CONTROL 0x18116800
+#define USB2D_IDM_IDM_RESET_CONTROL__RESET 0
+#endif
+#define DMU_CRU_RESET_BASE 0x200
+#define ChipcommonB_SMBus1_SMBus_Config 0x1803b000
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define USB2D_ENDPNT_IN_CTRL_0 0x18042000
+#endif
+#define IHOST_S1_IDM_ERROR_LOG_CONTROL 0x18107900
+#define IHOST_S1_IDM_ERROR_LOG_COMPLETE 0x18107904
+#define IHOST_S1_IDM_ERROR_LOG_STATUS 0x18107908
+#define IHOST_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810790c
+#define IHOST_S1_IDM_ERROR_LOG_ID 0x18107914
+#define IHOST_S1_IDM_ERROR_LOG_FLAGS 0x1810791c
+#define IHOST_S1_IDM_INTERRUPT_STATUS 0x18107a00
+#define IHOST_S0_IDM_ERROR_LOG_CONTROL 0x18108900
+#define IHOST_S0_IDM_ERROR_LOG_COMPLETE 0x18108904
+#define IHOST_S0_IDM_ERROR_LOG_STATUS 0x18108908
+#define IHOST_S0_IDM_ERROR_LOG_ADDR_LSB 0x1810890c
+#define IHOST_S0_IDM_ERROR_LOG_ID 0x18108914
+#define IHOST_S0_IDM_ERROR_LOG_FLAGS 0x1810891c
+#define IHOST_S0_IDM_INTERRUPT_STATUS 0x18108a00
+#define DDR_S1_IDM_ERROR_LOG_CONTROL 0x18109900
+#define DDR_S1_IDM_ERROR_LOG_COMPLETE 0x18109904
+#define DDR_S1_IDM_ERROR_LOG_STATUS 0x18109908
+#define DDR_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810990c
+#define DDR_S1_IDM_ERROR_LOG_ID 0x18109914
+#define DDR_S1_IDM_ERROR_LOG_FLAGS 0x1810991c
+#define DDR_S1_IDM_INTERRUPT_STATUS 0x18109a00
+#define DDR_S2_IDM_ERROR_LOG_CONTROL 0x1810a900
+#define DDR_S2_IDM_ERROR_LOG_COMPLETE 0x1810a904
+#define DDR_S2_IDM_ERROR_LOG_STATUS 0x1810a908
+#define DDR_S2_IDM_ERROR_LOG_ADDR_LSB 0x1810a90c
+#define DDR_S2_IDM_ERROR_LOG_ID 0x1810a914
+#define DDR_S2_IDM_ERROR_LOG_FLAGS 0x1810a91c
+#define DDR_S2_IDM_INTERRUPT_STATUS 0x1810aa00
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810b900
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810b904
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810b908
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810b90c
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID 0x1810b914
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810b91c
+#define AXI_PCIE_S0_IDM_IDM_INTERRUPT_STATUS 0x1810ba00
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_CONTROL 0x1810c900
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_COMPLETE 0x1810c904
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_STATUS 0x1810c908
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810c90c
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ID 0x1810c914
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_FLAGS 0x1810c91c
+#define AXI_PCIE_S1_IDM_IDM_INTERRUPT_STATUS 0x1810ca00
+#endif
+#define CMICD_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810d900
+#define CMICD_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810d904
+#define CMICD_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810d908
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810d90c
+#define CMICD_S0_IDM_IDM_ERROR_LOG_ID 0x1810d914
+#define CMICD_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810d91c
+#define CMICD_S0_IDM_IDM_INTERRUPT_STATUS 0x1810da00
+#define APBY_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810f900
+#define APBY_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810f904
+#define APBY_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810f908
+#define APBY_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810f90c
+#define APBY_S0_IDM_IDM_ERROR_LOG_ID 0x1810f914
+#define APBY_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810f91c
+#define APBY_S0_IDM_IDM_INTERRUPT_STATUS 0x1810fa00
+#define ROM_S0_IDM_ERROR_LOG_CONTROL 0x1811a900
+#define ROM_S0_IDM_ERROR_LOG_COMPLETE 0x1811a904
+#define ROM_S0_IDM_ERROR_LOG_STATUS 0x1811a908
+#define ROM_S0_IDM_ERROR_LOG_ADDR_LSB 0x1811a90c
+#define ROM_S0_IDM_ERROR_LOG_ID 0x1811a914
+#define ROM_S0_IDM_ERROR_LOG_FLAGS 0x1811a91c
+#define ROM_S0_IDM_INTERRUPT_STATUS 0x1811aa00
+#define NAND_IDM_IDM_ERROR_LOG_CONTROL 0x1811b900
+#define NAND_IDM_IDM_ERROR_LOG_COMPLETE 0x1811b904
+#define NAND_IDM_IDM_ERROR_LOG_STATUS 0x1811b908
+#define NAND_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811b90c
+#define NAND_IDM_IDM_ERROR_LOG_ID 0x1811b914
+#define NAND_IDM_IDM_ERROR_LOG_FLAGS 0x1811b91c
+#define NAND_IDM_IDM_INTERRUPT_STATUS 0x1811ba00
+#define QSPI_IDM_IDM_ERROR_LOG_CONTROL 0x1811c900
+#define QSPI_IDM_IDM_ERROR_LOG_COMPLETE 0x1811c904
+#define QSPI_IDM_IDM_ERROR_LOG_STATUS 0x1811c908
+#define QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811c90c
+#define QSPI_IDM_IDM_ERROR_LOG_ID 0x1811c914
+#define QSPI_IDM_IDM_ERROR_LOG_FLAGS 0x1811c91c
+#define QSPI_IDM_IDM_INTERRUPT_STATUS 0x1811ca00
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1811d900
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1811d904
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS 0x1811d908
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811d90c
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ID 0x1811d914
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1811d91c
+#define A9JTAG_S0_IDM_IDM_INTERRUPT_STATUS 0x1811da00
+#define SRAM_S0_IDM_ERROR_LOG_CONTROL 0x18120900
+#define SRAM_S0_IDM_ERROR_LOG_COMPLETE 0x18120904
+#define SRAM_S0_IDM_ERROR_LOG_STATUS 0x18120908
+#define SRAM_S0_IDM_ERROR_LOG_ADDR_LSB 0x1812090c
+#define SRAM_S0_IDM_ERROR_LOG_ID 0x18120914
+#define SRAM_S0_IDM_ERROR_LOG_FLAGS 0x1812091c
+#define SRAM_S0_IDM_INTERRUPT_STATUS 0x18120a00
+#define APBZ_S0_IDM_IDM_ERROR_LOG_CONTROL 0x18121900
+#define APBZ_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x18121904
+#define APBZ_S0_IDM_IDM_ERROR_LOG_STATUS 0x18121908
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1812190c
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ID 0x18121914
+#define APBZ_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1812191c
+#define APBZ_S0_IDM_IDM_INTERRUPT_STATUS 0x18121a00
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define APBV_S0_IDM_IDM_ERROR_LOG_CONTROL 0x18122900
+#define APBV_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x18122904
+#define APBV_S0_IDM_IDM_ERROR_LOG_STATUS 0x18122908
+#define APBV_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1812290c
+#define APBV_S0_IDM_IDM_ERROR_LOG_ID 0x18122914
+#define APBV_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1812291c
+#define APBV_S0_IDM_IDM_INTERRUPT_STATUS 0x18122a00
+#endif
+#define AXIIC_DS_3_IDM_ERROR_LOG_CONTROL 0x18123900
+#define AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE 0x18123904
+#define AXIIC_DS_3_IDM_ERROR_LOG_STATUS 0x18123908
+#define AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB 0x1812390c
+#define AXIIC_DS_3_IDM_ERROR_LOG_ID 0x18123914
+#define AXIIC_DS_3_IDM_ERROR_LOG_FLAGS 0x1812391c
+#define AXIIC_DS_3_IDM_INTERRUPT_STATUS 0x18123a00
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define AXIIC_DS_4_IDM_ERROR_LOG_CONTROL 0x18124900
+#define AXIIC_DS_4_IDM_ERROR_LOG_COMPLETE 0x18124904
+#define AXIIC_DS_4_IDM_ERROR_LOG_STATUS 0x18124908
+#define AXIIC_DS_4_IDM_ERROR_LOG_ADDR_LSB 0x1812490c
+#define AXIIC_DS_4_IDM_ERROR_LOG_ID 0x18124914
+#define AXIIC_DS_4_IDM_ERROR_LOG_FLAGS 0x1812491c
+#define AXIIC_DS_4_IDM_INTERRUPT_STATUS 0x18124a00
+#endif
+#define APBW_IDM_IDM_ERROR_LOG_CONTROL 0x18131900
+#define APBW_IDM_IDM_ERROR_LOG_COMPLETE 0x18131904
+#define APBW_IDM_IDM_ERROR_LOG_STATUS 0x18131908
+#define APBW_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1813190c
+#define APBW_IDM_IDM_ERROR_LOG_ID 0x18131914
+#define APBW_IDM_IDM_ERROR_LOG_FLAGS 0x1813191c
+#define APBW_IDM_IDM_INTERRUPT_STATUS 0x18131a00
+#define APBX_IDM_IDM_ERROR_LOG_CONTROL 0x18132900
+#define APBX_IDM_IDM_ERROR_LOG_COMPLETE 0x18132904
+#define APBX_IDM_IDM_ERROR_LOG_STATUS 0x18132908
+#define APBX_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1813290c
+#define APBX_IDM_IDM_ERROR_LOG_ID 0x18132914
+#define APBX_IDM_IDM_ERROR_LOG_FLAGS 0x1813291c
+#define APBX_IDM_IDM_INTERRUPT_STATUS 0x18132a00
+#define AXIIC_DS_0_IDM_ERROR_LOG_CONTROL 0x18141900
+#define AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE 0x18141904
+#define AXIIC_DS_0_IDM_ERROR_LOG_STATUS 0x18141908
+#define AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB 0x1814190c
+#define AXIIC_DS_0_IDM_ERROR_LOG_ID 0x18141914
+#define AXIIC_DS_0_IDM_ERROR_LOG_FLAGS 0x1814191c
+#define AXIIC_DS_0_IDM_INTERRUPT_STATUS 0x18141a00
+#if (defined(CONFIG_MACH_KT2) || defined(CONFIG_MACH_HX4))
+#define AXIIC_DS_1_IDM_ERROR_LOG_CONTROL 0x18142900
+#define AXIIC_DS_1_IDM_ERROR_LOG_COMPLETE 0x18142904
+#define AXIIC_DS_1_IDM_ERROR_LOG_STATUS 0x18142908
+#define AXIIC_DS_1_IDM_ERROR_LOG_ADDR_LSB 0x1814290c
+#define AXIIC_DS_1_IDM_ERROR_LOG_ID 0x18142914
+#define AXIIC_DS_1_IDM_ERROR_LOG_FLAGS 0x1814291c
+#define AXIIC_DS_1_IDM_INTERRUPT_STATUS 0x18142a00
+#endif
+#define DMU_PCU_IPROC_STRAPS_CAPTURED_BASE 0x028
+#define DMU_PCU_IPROC_STRAPS_CAPTURED__strap_boot_dev_R 9
+#define DMU_PCU_IPROC_STRAPS_CAPTURED__strap_nand_type_R 5
+#define DMU_PCU_IPROC_STRAPS_CAPTURED__strap_nand_page_R 3
+#define ChipcommonA_IntMask_BASE 0x024
+#define DMU_PCU_CRU_RESET_REASON 0x1803f014
+#define DMU_PCU_CRU_RESET_REASON__watchdog_reset 0
+#define ChipcommonA_GPIOInput 0x18000060
+#define ChipcommonA_GPIOOut 0x18000064
+#define ChipcommonA_GPIOOutEn 0x18000068
+#define AMAC_IDM0_IO_CONTROL_DIRECT 0x18110408
+#define AMAC_IDM0_IO_CONTROL_DIRECT__CLK_250_SEL 6
+#define AMAC_IDM0_IO_CONTROL_DIRECT__DIRECT_GMII_MODE 5
+#define AMAC_IDM0_IO_CONTROL_DIRECT__DEST_SYNC_MODE_EN 3
+#define AMAC_IDM1_IO_CONTROL_DIRECT 0x18111408
+#define AMAC_IDM1_IO_CONTROL_DIRECT__CLK_250_SEL 6
+#define AMAC_IDM1_IO_CONTROL_DIRECT__DIRECT_GMII_MODE 5
+#define AMAC_IDM1_IO_CONTROL_DIRECT__DEST_SYNC_MODE_EN 3
+#if defined(CONFIG_MACH_KT2)
+#define IPROC_WRAP_USBPHY_CTRL 0x1803fc20
+#define IPROC_WRAP_MISC_CONTROL__UNICORE_SERDES_CTRL_SEL 1
+#define IPROC_WRAP_MISC_CONTROL__IPROC_MDIO_SEL 3
+#define IPROC_WRAP_MISC_CONTROL 0x1803fc24
+#define IPROC_WRAP_MISC_CONTROL__UNICORE_SERDES_MDIO_SEL 2
+#define IPROC_DDR_PLL_CTRL_REGISTER_0 0x1803fc00
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_BASE 0xc00
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__CH0_MDEL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__CH0_MDEL_R 29
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__CH0_MDEL_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__CH0_MDEL_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__NDIV_RELOCK 28
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__NDIV_RELOCK_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__NDIV_RELOCK_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__FAST_LOCK 27
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__FAST_LOCK_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__FAST_LOCK_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DIV2 26
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DIV2_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DIV2_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DLY_L 25
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DLY_R 24
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DLY_WIDTH 2
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__VCO_DLY_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__PWM_RATE_L 23
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__PWM_RATE_R 22
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__PWM_RATE_WIDTH 2
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__PWM_RATE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_MODE_L 21
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_MODE_R 20
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_MODE_WIDTH 2
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_MODE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__AUX_CTRL 19
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__AUX_CTRL_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__AUX_CTRL_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__TESTCLKOUT 18
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__TESTCLKOUT_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__TESTCLKOUT_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_UPDATE 17
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_UPDATE_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_UPDATE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_SELECT_L 16
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_SELECT_R 14
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_SELECT_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_SELECT_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_RESET 13
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_RESET_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__STAT_RESET_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_ENABLE 12
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_ENABLE_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_ENABLE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_L 11
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_WIDTH 12
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__DCO_CTRL_BYPASS_RESETVALUE 0x000
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_0__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_0_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_1 0x1803fc04
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_BASE 0xc04
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KA_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KA_R 29
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KA_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KA_RESETVALUE 0x2
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KI_L 28
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KI_R 26
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KI_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KI_RESETVALUE 0x3
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KP_L 25
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KP_R 22
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KP_WIDTH 4
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__KP_RESETVALUE 0x7
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__SSC_LIMIT_L 21
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__SSC_LIMIT_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__SSC_LIMIT_WIDTH 22
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__SSC_LIMIT_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_1__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_1_RESETVALUE 0x4dc00000
+#define IPROC_DDR_PLL_CTRL_REGISTER_2 0x1803fc08
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_BASE 0xc08
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__PDIV_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__PDIV_R 29
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__PDIV_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__PDIV_RESETVALUE 0x1
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_PHASE_EN 28
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_PHASE_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_PHASE_EN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_OFFSET_L 27
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_OFFSET_R 16
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_OFFSET_WIDTH 12
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__FB_OFFSET_RESETVALUE 0x000
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__SSC_STEP_L 15
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__SSC_STEP_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__SSC_STEP_WIDTH 16
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__SSC_STEP_RESETVALUE 0x0000
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_2__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_2_RESETVALUE 0x20000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_3 0x1803fc0c
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_BASE 0xc0c
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__SSC_MODE 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__SSC_MODE_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__SSC_MODE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__PHASE8_EN 30
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__PHASE8_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__PHASE8_EN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_FRAC_L 29
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_FRAC_R 10
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_FRAC_WIDTH 20
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_FRAC_RESETVALUE 0x00000
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_INT_L 9
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_INT_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_INT_WIDTH 10
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__NDIV_INT_RESETVALUE 0x80
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_3__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_3_RESETVALUE 0x80
+#define IPROC_DDR_PLL_CTRL_REGISTER_4 0x1803fc10
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_BASE 0xc10
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__RESERVED_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__RESERVED_R 29
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__RESERVED_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__RESERVED_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__PWRDWN 28
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__PWRDWN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__PWRDWN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__SPARE_L 27
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__SPARE_R 24
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__SPARE_WIDTH 4
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__SPARE_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_EN 23
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_EN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_SEL 22
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_SEL_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__TEST_SEL_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__D2C_HYST_EN 21
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__D2C_HYST_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__D2C_HYST_EN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__BYPASS_POR 20
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__BYPASS_POR_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__BYPASS_POR_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__LOAD_EN_L 19
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__LOAD_EN_R 14
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__LOAD_EN_WIDTH 6
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__LOAD_EN_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__HOLD_L 13
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__HOLD_R 8
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__HOLD_WIDTH 6
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__HOLD_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__CH0_MDIV_L 7
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__CH0_MDIV_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__CH0_MDIV_WIDTH 8
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__CH0_MDIV_RESETVALUE 0x08
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_4__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_4_RESETVALUE 0x8
+#define IPROC_DDR_PLL_CTRL_REGISTER_5 0x1803fc14
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_BASE 0xc14
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__RESERVED_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__RESERVED_R 17
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__RESERVED_WIDTH 15
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__RESERVED_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_SW_OVWR 16
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_SW_OVWR_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_SW_OVWR_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT1_EN 15
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT1_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT1_EN_RESETVALUE 0x1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT0_EN 14
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT0_EN_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_OUT0_EN_RESETVALUE 0x1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_IN_SEL 13
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_IN_SEL_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_CLK_IN_SEL_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_POST_RESETB 12
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_POST_RESETB_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_POST_RESETB_RESETVALUE 0x1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_RESETB 11
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_RESETB_WIDTH 1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__IPROC_DDR_PLL_RESETB_RESETVALUE 0x1
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDEL_L 10
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDEL_R 8
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDEL_WIDTH 3
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDEL_RESETVALUE 0x0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDIV_L 7
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDIV_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDIV_WIDTH 8
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__CH1_MDIV_RESETVALUE 0x64
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__WIDTH 32
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__ALL_L 31
+#define IPROC_DDR_PLL_CTRL_REGISTER_5__ALL_R 0
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_CTRL_REGISTER_5_RESETVALUE 0xd864
+#define IPROC_DDR_PLL_STATUS 0x1803fc18
+#define IPROC_DDR_PLL_STATUS_BASE 0xc18
+#define IPROC_DDR_PLL_STATUS__RESERVED_L 31
+#define IPROC_DDR_PLL_STATUS__RESERVED_R 14
+#define IPROC_DDR_PLL_STATUS__RESERVED_WIDTH 18
+#define IPROC_DDR_PLL_STATUS__RESERVED_RESETVALUE 0x0
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK_LOST 13
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK_LOST_WIDTH 1
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK_LOST_RESETVALUE 0x0
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK 12
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK_WIDTH 1
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_LOCK_RESETVALUE 0x0
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_STAT_OUT_L 11
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_STAT_OUT_R 0
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_STAT_OUT_WIDTH 12
+#define IPROC_DDR_PLL_STATUS__IPROC_DDR_PLL_STAT_OUT_RESETVALUE 0x000
+#define IPROC_DDR_PLL_STATUS_WIDTH 32
+#define IPROC_DDR_PLL_STATUS__WIDTH 32
+#define IPROC_DDR_PLL_STATUS_ALL_L 31
+#define IPROC_DDR_PLL_STATUS_ALL_R 0
+#define IPROC_DDR_PLL_STATUS__ALL_L 31
+#define IPROC_DDR_PLL_STATUS__ALL_R 0
+#define IPROC_DDR_PLL_STATUS_DATAMASK 0xffffffff
+#define IPROC_DDR_PLL_STATUS_RDWRMASK 0x00000000
+#define IPROC_DDR_PLL_STATUS_RESETVALUE 0x0
+#endif
+#if (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2))
+#define IPROC_WRAP_USBPHY_CTRL 0x1803fc34
+#define IPROC_WRAP_GEN_PLL_STATUS__GEN_PLL_LOCK 0
+#define IPROC_WRAP_GEN_PLL_CTRL1__NDIV_INT_R 0
+#define IPROC_WRAP_GEN_PLL_CTRL1__NDIV_INT_WIDTH 10
+#define IPROC_WRAP_GEN_PLL_CTRL1__PDIV_R 10
+#define IPROC_WRAP_GEN_PLL_CTRL1__PDIV_WIDTH 3
+#define IPROC_WRAP_GEN_PLL_CTRL1__CH0_MDIV_R 13
+#define IPROC_WRAP_GEN_PLL_CTRL1__CH1_MDIV_R 21
+#define IPROC_WRAP_GEN_PLL_CTRL2__CH2_MDIV_R 0
+#define IPROC_WRAP_GEN_PLL_CTRL2__CH3_MDIV_R 8
+#define IPROC_WRAP_GEN_PLL_CTRL2__CH4_MDIV_R 16
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0 0x1803fc1c
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_BASE 0xc1c
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH5_MDIV_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH5_MDIV_R 24
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH5_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH5_MDIV_RESETVALUE 0x18
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH4_MDIV_L 23
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH4_MDIV_R 16
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH4_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH4_MDIV_RESETVALUE 0x0f
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH3_MDIV_L 15
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH3_MDIV_R 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH3_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH3_MDIV_RESETVALUE 0x64
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH0_MDIV_L 7
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH0_MDIV_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH0_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__CH0_MDIV_RESETVALUE 0x1e
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_0_RESETVALUE 0x180f641e
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1 0x1803fc20
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_BASE 0xc20
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__Reserved_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__Reserved_R 28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__Reserved_WIDTH 4
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__Reserved_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__SW_OVWR 27
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__SW_OVWR_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__SW_OVWR_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__POST_RESETB 26
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__POST_RESETB_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__POST_RESETB_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__RESETB 25
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__RESETB_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__RESETB_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__PDIV_L 24
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__PDIV_R 22
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__PDIV_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__PDIV_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KP_L 21
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KP_R 18
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KP_WIDTH 4
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KP_RESETVALUE 0x8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KI_L 17
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KI_R 15
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KI_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KI_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KA_L 14
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KA_R 12
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KA_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__KA_RESETVALUE 0x4
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__LOAD_EN_CH_L 11
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__LOAD_EN_CH_R 6
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__LOAD_EN_CH_WIDTH 6
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__LOAD_EN_CH_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__HOLD_CH_L 5
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__HOLD_CH_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__HOLD_CH_WIDTH 6
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__HOLD_CH_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_1_RESETVALUE 0x660c000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2 0x1803fc24
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_BASE 0xc24
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__RSVD_0_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__RSVD_0_R 28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__RSVD_0_WIDTH 4
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__RSVD_0_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH2_MDIV_L 27
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH2_MDIV_R 20
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH2_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH2_MDIV_RESETVALUE 0x00
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH5_MDEL_L 19
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH5_MDEL_R 17
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH5_MDEL_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH5_MDEL_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH4_MDEL_L 16
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH4_MDEL_R 14
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH4_MDEL_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH4_MDEL_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH3_MDEL_L 13
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH3_MDEL_R 11
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH3_MDEL_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH3_MDEL_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH0_MDEL_L 10
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH0_MDEL_R 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH0_MDEL_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH0_MDEL_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH1_MDIV_L 7
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH1_MDIV_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH1_MDIV_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__CH1_MDIV_RESETVALUE 0x0f
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_2_RESETVALUE 0xf
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3 0x1803fc28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_BASE 0xc28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__RSVD_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__RSVD_R 30
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__RSVD_WIDTH 2
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__RSVD_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT2_EN 29
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT2_EN_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT2_EN_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_2ED_OUT_EN 28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_2ED_OUT_EN_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_2ED_OUT_EN_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DIG_LDO_CTRL_L 27
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DIG_LDO_CTRL_R 26
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DIG_LDO_CTRL_WIDTH 2
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DIG_LDO_CTRL_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ANA_LDO_CTRL_L 25
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ANA_LDO_CTRL_R 24
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ANA_LDO_CTRL_WIDTH 2
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ANA_LDO_CTRL_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT_EN 23
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT_EN_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__TESTOUT_EN_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_OUTPUT_EN 22
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_OUTPUT_EN_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_OUTPUT_EN_RESETVALUE 0x1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_BYP_EN 21
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_BYP_EN_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__CML_BYP_EN_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__VCOdiv2 20
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__VCOdiv2_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__VCOdiv2_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__AUX_CTRL 19
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__AUX_CTRL_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__AUX_CTRL_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__REFCLKOUT 18
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__REFCLKOUT_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__REFCLKOUT_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_UPDATE 17
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_UPDATE_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_UPDATE_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_SELECT_L 16
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_SELECT_R 14
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_SELECT_WIDTH 3
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_SELECT_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_RESET 13
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_RESET_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__STAT_RESET_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_ENABLE 12
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_ENABLE_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_ENABLE_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_L 11
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_WIDTH 12
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__DCO_CTRL_BYPASS_RESETVALUE 0x000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_3_RESETVALUE 0x15400000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4 0x1803fc2c
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_BASE 0xc2c
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__RSVD_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__RSVD_R 28
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__RSVD_WIDTH 4
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__RSVD_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_FRAC_L 27
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_FRAC_R 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_FRAC_WIDTH 20
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_FRAC_RESETVALUE 0x00000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_INT_L 7
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_INT_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_INT_WIDTH 8
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__NDIV_INT_RESETVALUE 0x78
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_CTRL_4_RESETVALUE 0x78
+#define IPROC_WRAP_IPROC_XGPLL_STATUS 0x1803fc30
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_BASE 0xc30
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__IPROC_WRAP_XGPLL_LOCK 31
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__IPROC_WRAP_XGPLL_LOCK_WIDTH 1
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__IPROC_WRAP_XGPLL_LOCK_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__XGPLL_STATUS_L 30
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__XGPLL_STATUS_R 0
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__XGPLL_STATUS_WIDTH 31
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__XGPLL_STATUS_RESETVALUE 0x0
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__WIDTH 32
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__ALL_L 31
+#define IPROC_WRAP_IPROC_XGPLL_STATUS__ALL_R 0
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_DATAMASK 0xffffffff
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_RDWRMASK 0x00000000
+#define IPROC_WRAP_IPROC_XGPLL_STATUS_RESETVALUE 0x0
+#if defined(CONFIG_MACH_HX4)
+#define IPROC_WRAP_MISC_CONTROL__QUAD_SERDES_MDIO_SEL 3
+#define IPROC_WRAP_MISC_CONTROL__QUAD_SERDES_CTRL_SEL 2
+#define IPROC_WRAP_MISC_CONTROL__IPROC_MDIO_SEL 4
+#endif
+#define IPROC_WRAP_MISC_CONTROL 0x1803fc3c
+#endif
+
+#endif /* __SOCREGS_ING_OPEN_H */
diff --git a/arch/arm/mach-iproc/include/mach/socregs_ns_open.h b/arch/arm/mach-iproc/include/mach/socregs_ns_open.h
new file mode 100644
index 0000000..6c13c80
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/socregs_ns_open.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __SOCREGS_NS_OPEN_H
+#define __SOCREGS_NS_OPEN_H
+
+
+#define  CCA_CHIPID											0x18000000
+#define  CCA_CHIPID_BASE                                    0x000
+#define  CCB_GP_DATA_IN										0x18001000
+#define  USB30_BASE											0x18023000	
+#define  SDIO_EMMC_SDXC_SYSADDR								0x18020000
+#define  CCB_PWM_CTL										0x18002000
+#define  CCB_TIM0_TIM_TMR1_LOAD								0x18005000
+#define  CCB_TIM1_TIM_TMR1_LOAD								0x18006000
+#define  CCB_SMBUS_START									0x18009000
+#define  CCB_GP_AUX_SEL_BASE								0x028
+#define  QSPI_MSPI_SPCR0_LSB								0x18029200
+#define  QSPI_MSPI_DISABLE_FLUSH_GEN						0x18029384
+#define  QSPI_BSPI_REGS_REV_ID								0x18029000
+#define  QSPI_BSPI_REGS_BSPI_PIO_DATA						0x1802904c
+#define  QSPI_RAF_START_ADDR								0x18029100
+#define  QSPI_RAF_CURR_ADDR									0x18029120
+#define  QSPI_RAF_INTERRUPT_LR_FULLNESS_REACHED				0x180293a0
+#define  QSPI_MSPI_INTERRUPT_MSPI_HALT_SET_TRANSACTION_DONE	0x180293b8
+#define  GMAC0_DEVCTL										0x18024000
+#define  GMAC1_DEVCTL										0x18025000
+#define  GMAC2_DEVCTL										0x18026000
+#define  GMAC3_DEVCTL										0x18027000
+#define  CCA_GPIO_EVT_BASE									0x078
+#define  CCA_GPIO_INPUT										0x18000060
+#define  CCA_GPIO_INPUT_BASE								0x060
+#define  CCB_GP_INT_CLR_BASE								0x024
+#define  CCA_GPIO_EVTINT_MASK_BASE							0x07c
+#define  CCB_GP_INT_MSK_BASE								0x018
+#define  CCA_GPIOINT_MASK_BASE								0x074
+#define  CCA_GPIO_EVT_INT_POLARITY_BASE						0x084
+#define  CCA_GPIO_INT_POLARITY_BASE							0x070
+#define  CCA_INT_MASK_BASE									0x024
+#define  CCB_GP_INT_TYPE_BASE								0x00c
+#define  CCB_GP_INT_DE_BASE									0x010
+#define  CCB_GP_INT_EDGE_BASE								0x014
+#define  CCA_INT_STS_BASE									0x020
+#define  CCB_GP_INT_MSTAT_BASE								0x020
+#define  CCB_GP_PAD_RES_BASE								0x034
+#define  CCB_GP_RES_EN_BASE									0x038
+#define  CCB_MII_MGMT_CTL									0x18003000
+#define  NAND_NAND_FLASH_REV								0x18028000
+#define  NAND_DIRECT_READ_RD_MISS							0x18028f00
+#define  CCB_PWM_PRESCALE_BASE								0x024
+#define  CCB_PWM_PERIOD_COUNT0_BASE							0x004
+#define  CCB_PWM_PERIOD_COUNT1_BASE							0x00c
+#define  CCB_PWM_DUTY_HI_COUNT2_BASE						0x018
+#define  CCB_PWM_PERIOD_COUNT3_BASE							0x01c
+#define  CCB_PWM_DUTY_HI_COUNT0_BASE						0x008
+#define  CCB_PWM_DUTY_HI_COUNT1_BASE						0x010
+#define  CCB_PWM_DUTY_HI_COUNT2_BASE						0x018
+#define  CCB_PWM_DUTY_HI_COUNT3_BASE						0x020
+#define  CCB_PWM_CTL_BASE									0x000
+#define  CCB_PWM_PERIOD_COUNT2_BASE							0x014
+#define  CCB_RNG_CTRL										0x18004000
+
+
+#endif /* __SOCREGS_NS_OPEN_H */
diff --git a/arch/arm/mach-iproc/include/mach/socregs_nsp_open.h b/arch/arm/mach-iproc/include/mach/socregs_nsp_open.h
new file mode 100644
index 0000000..5db1953
--- /dev/null
+++ b/arch/arm/mach-iproc/include/mach/socregs_nsp_open.h
@@ -0,0 +1,396 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef __SOCREGS_NSP_OPEN_H
+#define __SOCREGS_NSP_OPEN_H
+
+#define ChipcommonA_ChipID 0x18000000
+#define PCU_MDIO_MGT 0x1803f000
+#define ChipcommonB_PWMCTL 0x18031000
+#define ChipcommonB_WDT_WDOGLOAD 0x18039000
+#define USB3_CAPLENGTH 0x18029000
+#define USB30_BASE USB3_CAPLENGTH	
+#define SATA_AHCI_GHC_HBA_CAP 0x18041000
+#define SATA_M0_IDM_IO_CONTROL_DIRECT 0x1811e408
+#define SATA_M0_IDM_IDM_RESET_CONTROL 0x1811e800
+#define SATA3_PCB_UPPER_REG1 0x18040304
+#define SATA3_PCB_UPPER_REG0 0x18040300
+#define SATA3_PCB_UPPER_REG1 0x18040304
+#define SATA3_PCB_UPPER_REG11 0x1804032c
+#define SATA3_PCB_UPPER_REG5 0x18040314
+#define SATA3_PCB_UPPER_REG15 0x1804033c
+#define SATA_TOP_CTRL_BUS_CTRL 0x18040024
+#define ChipcommonB_GP_DATA_IN 0x18030000
+#define ChipcommonB_GP_AUX_SEL_BASE 0x028
+#define ChipcommonB_SMBus_Config 0x18038000
+#define ChipcommonB_tim0_TIM_TIMER1Load 0x18034000
+#define ChipcommonB_tim1_TIM_TIMER1Load 0x18035000
+#define QSPI_mspi_SPCR0_LSB 0x18027200
+#define QSPI_mspi_DISABLE_FLUSH_GEN 0x18027384
+#define QSPI_bspi_registers_REVISION_ID 0x18027000
+#define QSPI_bspi_registers_BSPI_PIO_DATA 0x1802704c
+#define QSPI_raf_START_ADDR 0x18027100
+#define QSPI_raf_interrupt_LR_fullness_reached 0x180273a0
+#define QSPI_mspi_interrupt_MSPI_halt_set_transaction_done 0x180273b8
+#define QSPI_IDM_IDM_IO_CONTROL_DIRECT 0x1811c408
+#define QSPI_raf_CURR_ADDR 0x18027120
+#define CRU_control 0x1803e000
+#define GMAC0_DEVCONTROL 0x18022000
+#define GMAC1_DEVCONTROL 0x18023000
+#define FA_GMAC0_DEVCONTROL 0x18024000
+#define FA_GMAC1_DEVCONTROL 0x18025000
+#define CRU_CLKSET_KEY_OFFSET 0x1803f180
+#define CRU_LCPLL2_CONTROL0 0x1803f548
+#define CRU_LCPLL2_CONTROL0__PWRDWN 12
+#define CRU_LCPLL2_CONTROL0__RESETB 11
+#define CRU_LCPLL2_STATUS__LOCK 12
+#define CRU_LCPLL2_CONTROL0__PWRDWN 12
+#define CRU_LCPLL2_CONTROL0__RESETB 11
+#define CRU_RESET__SGMII_RESET_N 8
+#define CRU_RESET 0x1803f184
+#define SGMII_CONFIG 0x1803f410
+#define SGMII_CONFIG__RSTB_PLL 17
+#define SGMII_CONFIG__RSTB_MDIOREGS 16
+#define SGMII_CONFIG__TXD1G_FIFO_RSTB_WIDTH 4
+#define SGMII_CONFIG__TXD1G_FIFO_RSTB_R 11
+#define P5_MUX_CONFIG__P5_MODE_WIDTH 3
+#define CRU_LCPLL2_CONTROL0__POST_RESETB 10
+#define P5_MUX_CONFIG 0x1803f308
+#define P5_MUX_CONFIG__P5_MODE_R 0
+#define P5_MUX_CONFIG__P5_MODE_SGMII 0x0
+#define P5_MUX_CONFIG__P5_MODE_GPHY3 0x4
+#define P4_MUX_CONFIG 0x1803f30c
+#define P4_MUX_CONFIG__P4_MODE_R 0
+#define P4_MUX_CONFIG__P4_MODE_WIDTH 3
+#define P4_MUX_CONFIG__P4_MODE_SGMII 0x0
+#define ChipcommonA_GPIOEvent_BASE 0x078
+#define ChipcommonA_GPIOInput_BASE 0x060
+#define ChipcommonB_GP_INT_CLR_BASE 0x024
+#define ChipcommonA_GPIOEventIntMask_BASE 0x07c
+#define ChipcommonA_GPIOInput_BASE 0x060
+#define ChipcommonB_GP_INT_MSK_BASE 0x018
+#define ChipcommonA_GPIOIntMask_BASE 0x074
+#define ChipcommonB_GP_INT_MSK_BASE 0x018
+#define ChipcommonA_GPIOEventIntMask_BASE 0x07c
+#define ChipcommonB_GP_INT_MSTAT_BASE 0x020
+#define ChipcommonA_GPIOEventIntPolarity_BASE 0x084
+#define ChipcommonA_IntStatus_BASE 0x020
+#define ChipcommonA_GPIOIntPolarity_BASE 0x070
+#define ChipcommonA_IntStatus_BASE 0x020
+#define ChipcommonB_GP_INT_DE_BASE 0x010
+#define ChipcommonB_GP_INT_EDGE_BASE 0x014
+#define ChipcommonB_GP_INT_TYPE_BASE 0x00c
+#define ChipcommonA_GPIOIntPolarity_BASE 0x070
+#define CRU_GPIO_CONTROL0_BASE 0x1f1c0
+#define ChipcommonB_GP_AUX_SEL_BASE 0x028
+#define CRU_GPIO_CONTROL7_BASE 0x1f1dc
+#define CRU_GPIO_CONTROL8_BASE 0x1f1e0
+#define ChipcommonB_GP_PAD_RES_BASE 0x034
+#define ChipcommonB_GP_RES_EN_BASE 0x038
+#define ChipcommonA_ChipID 0x18000000
+#define DMAC_pl330_DS 0x18020000
+#define ChipcommonA_GPIOInput 0x18000060
+#define ChipcommonB_GP_DATA_IN 0x18030000
+#define PAXB_0_CLK_CONTROL 0x18012000
+#define PAXB_0_CONFIG_IND_ADDR_BASE 0x120
+#define ChipcommonB_MII_Management_Control 0x18032000
+#define NAND_nand_flash_REVISION 0x18026000
+#define NAND_direct_read_rd_miss 0x18026f00
+#define NAND_IDM_IDM_IO_CONTROL_DIRECT 0x1811b408
+#define ChipcommonB_PWM_PERIOD_COUNT0_BASE 0x004
+#define ChipcommonB_PWM_PRESCALE_BASE 0x024
+#define ChipcommonB_PWM_PERIOD_COUNT1_BASE 0x00c
+#define ChipcommonB_PWM_PERIOD_COUNT2_BASE 0x014
+#define ChipcommonB_PWM_PERIOD_COUNT3_BASE 0x01c
+#define ChipcommonB_PWM_DUTYHI_COUNT0_BASE 0x008
+#define ChipcommonB_PWM_DUTYHI_COUNT1_BASE 0x010
+#define ChipcommonB_PWM_DUTYHI_COUNT2_BASE 0x018
+#define ChipcommonB_PWM_DUTYHI_COUNT3_BASE 0x020
+#define ChipcommonB_PWMCTL_BASE 0x000
+#define ChipcommonB_rng_CTRL 0x18033000
+#define USB2_IDM_IDM_IO_CONTROL_DIRECT 0x18115408
+#define USB3_IDM_IDM_RESET_CONTROL 0x18104800
+#define CRU_WATCHDOG_PCIE_RESET_STATUS 0x1803f564
+#define CRU_WATCHDOG_PCIE_RESET_STATUS__CCB_WATCHDOG_RESET_EVENT 0
+#define SDIO_eMMCSDXC_SYSADDR 0x18021000
+#define IHOST_M0_IO_CONTROL_DIRECT 0x18100408
+#define ChipcommonA_IntMask_BASE 0x024
+#define ChipcommonA_OTPProg 0x18000018
+#define ChipcommonA_OTPLayout 0x1800001c
+#define ChipcommonA_CoreCapabilities 0x18000004
+#define ChipcommonA_OTPStatus 0x18000010
+#define SDIO_IDM_IO_CONTROL_DIRECT 0x18117408
+#define SDIO_IDM_IO_CONTROL_DIRECT__CMD_COMFLICT_DISABLE 22
+
+
+/* IDM registers */
+
+#define IHOST_S1_IDM_ERROR_LOG_CONTROL 0x18107900
+#define IHOST_S1_IDM_ERROR_LOG_COMPLETE 0x18107904
+#define IHOST_S1_IDM_ERROR_LOG_STATUS 0x18107908
+#define IHOST_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810790c
+#define IHOST_S1_IDM_ERROR_LOG_ID 0x18107914
+#define IHOST_S1_IDM_ERROR_LOG_FLAGS 0x1810791c
+#define IHOST_S1_IDM_INTERRUPT_STATUS 0x18107a00
+#define IHOST_S0_IDM_ERROR_LOG_CONTROL 0x18108900
+#define IHOST_S0_IDM_ERROR_LOG_COMPLETE 0x18108904
+#define IHOST_S0_IDM_ERROR_LOG_STATUS 0x18108908
+#define IHOST_S0_IDM_ERROR_LOG_ADDR_LSB 0x1810890c
+#define IHOST_S0_IDM_ERROR_LOG_ID 0x18108914
+#define IHOST_S0_IDM_ERROR_LOG_FLAGS 0x1810891c
+#define IHOST_S0_IDM_INTERRUPT_STATUS 0x18108a00
+#define DDR_S1_IDM_ERROR_LOG_CONTROL 0x18109900
+#define DDR_S1_IDM_ERROR_LOG_COMPLETE 0x18109904
+#define DDR_S1_IDM_ERROR_LOG_STATUS 0x18109908
+#define DDR_S1_IDM_ERROR_LOG_ADDR_LSB 0x1810990c
+#define DDR_S1_IDM_ERROR_LOG_ID 0x18109914
+#define DDR_S1_IDM_ERROR_LOG_FLAGS 0x1810991c
+#define DDR_S1_IDM_INTERRUPT_STATUS 0x18109a00
+#define DDR_S2_IDM_ERROR_LOG_CONTROL 0x1810a900
+#define DDR_S2_IDM_ERROR_LOG_COMPLETE 0x1810a904
+#define DDR_S2_IDM_ERROR_LOG_STATUS 0x1810a908
+#define DDR_S2_IDM_ERROR_LOG_ADDR_LSB 0x1810a90c
+#define DDR_S2_IDM_ERROR_LOG_ID 0x1810a914
+#define DDR_S2_IDM_ERROR_LOG_FLAGS 0x1810a91c
+#define DDR_S2_IDM_INTERRUPT_STATUS 0x1810aa00
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810b900
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810b904
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810b908
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810b90c
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_ID 0x1810b914
+#define AXI_PCIE_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810b91c
+#define AXI_PCIE_S0_IDM_IDM_INTERRUPT_STATUS 0x1810ba00
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_CONTROL 0x1810c900
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_COMPLETE 0x1810c904
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_STATUS 0x1810c908
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810c90c
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_ID 0x1810c914
+#define AXI_PCIE_S1_IDM_IDM_ERROR_LOG_FLAGS 0x1810c91c
+#define AXI_PCIE_S1_IDM_IDM_INTERRUPT_STATUS 0x1810ca00
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_CONTROL 0x1810d900
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_COMPLETE 0x1810d904
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_STATUS 0x1810d908
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810d90c
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_ID 0x1810d914
+#define AXI_PCIE_S2_IDM_IDM_ERROR_LOG_FLAGS 0x1810d91c
+#define AXI_PCIE_S2_IDM_IDM_INTERRUPT_STATUS 0x1810da00
+#define APBY_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1810f900
+#define APBY_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1810f904
+#define APBY_S0_IDM_IDM_ERROR_LOG_STATUS 0x1810f908
+#define APBY_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1810f90c
+#define APBY_S0_IDM_IDM_ERROR_LOG_ID 0x1810f914
+#define APBY_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1810f91c
+#define APBY_S0_IDM_IDM_INTERRUPT_STATUS 0x1810fa00
+#define ROM_S0_IDM_ERROR_LOG_CONTROL 0x1811a900
+#define ROM_S0_IDM_ERROR_LOG_COMPLETE 0x1811a904
+#define ROM_S0_IDM_ERROR_LOG_STATUS 0x1811a908
+#define ROM_S0_IDM_ERROR_LOG_ADDR_LSB 0x1811a90c
+#define ROM_S0_IDM_ERROR_LOG_ID 0x1811a914
+#define ROM_S0_IDM_ERROR_LOG_FLAGS 0x1811a91c
+#define ROM_S0_IDM_INTERRUPT_STATUS 0x1811aa00
+#define NAND_IDM_IDM_ERROR_LOG_CONTROL 0x1811b900
+#define NAND_IDM_IDM_ERROR_LOG_COMPLETE 0x1811b904
+#define NAND_IDM_IDM_ERROR_LOG_STATUS 0x1811b908
+#define NAND_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811b90c
+#define NAND_IDM_IDM_ERROR_LOG_ID 0x1811b914
+#define NAND_IDM_IDM_ERROR_LOG_FLAGS 0x1811b91c
+#define NAND_IDM_IDM_INTERRUPT_STATUS 0x1811ba00
+#define QSPI_IDM_IDM_ERROR_LOG_CONTROL 0x1811c900
+#define QSPI_IDM_IDM_ERROR_LOG_COMPLETE 0x1811c904
+#define QSPI_IDM_IDM_ERROR_LOG_STATUS 0x1811c908
+#define QSPI_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811c90c
+#define QSPI_IDM_IDM_ERROR_LOG_ID 0x1811c914
+#define QSPI_IDM_IDM_ERROR_LOG_FLAGS 0x1811c91c
+#define QSPI_IDM_IDM_INTERRUPT_STATUS 0x1811ca00
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_CONTROL 0x1811d900
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x1811d904
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_STATUS 0x1811d908
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1811d90c
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_ID 0x1811d914
+#define A9JTAG_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1811d91c
+#define A9JTAG_S0_IDM_IDM_INTERRUPT_STATUS 0x1811da00
+#define SRAM_S0_IDM_ERROR_LOG_CONTROL 0x18120900
+#define SRAM_S0_IDM_ERROR_LOG_COMPLETE 0x18120904
+#define SRAM_S0_IDM_ERROR_LOG_STATUS 0x18120908
+#define SRAM_S0_IDM_ERROR_LOG_ADDR_LSB 0x1812090c
+#define SRAM_S0_IDM_ERROR_LOG_ID 0x18120914
+#define SRAM_S0_IDM_ERROR_LOG_FLAGS 0x1812091c
+#define SRAM_S0_IDM_INTERRUPT_STATUS 0x18120a00
+#define APBZ_S0_IDM_IDM_ERROR_LOG_CONTROL 0x18121900
+#define APBZ_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x18121904
+#define APBZ_S0_IDM_IDM_ERROR_LOG_STATUS 0x18121908
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1812190c
+#define APBZ_S0_IDM_IDM_ERROR_LOG_ID 0x18121914
+#define APBZ_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1812191c
+#define APBZ_S0_IDM_IDM_INTERRUPT_STATUS 0x18121a00
+#define APBV_S0_IDM_IDM_ERROR_LOG_CONTROL 0x18122900
+#define APBV_S0_IDM_IDM_ERROR_LOG_COMPLETE 0x18122904
+#define APBV_S0_IDM_IDM_ERROR_LOG_STATUS 0x18122908
+#define APBV_S0_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1812290c
+#define APBV_S0_IDM_IDM_ERROR_LOG_ID 0x18122914
+#define APBV_S0_IDM_IDM_ERROR_LOG_FLAGS 0x1812291c
+#define APBV_S0_IDM_IDM_INTERRUPT_STATUS 0x18122a00
+#define AXIIC_DS_3_IDM_ERROR_LOG_CONTROL 0x18123900
+#define AXIIC_DS_3_IDM_ERROR_LOG_COMPLETE 0x18123904
+#define AXIIC_DS_3_IDM_ERROR_LOG_STATUS 0x18123908
+#define AXIIC_DS_3_IDM_ERROR_LOG_ADDR_LSB 0x1812390c
+#define AXIIC_DS_3_IDM_ERROR_LOG_ID 0x18123914
+#define AXIIC_DS_3_IDM_ERROR_LOG_FLAGS 0x1812391c
+#define AXIIC_DS_3_IDM_INTERRUPT_STATUS 0x18123a00
+#define AXIIC_DS_4_IDM_ERROR_LOG_CONTROL 0x18124900
+#define AXIIC_DS_4_IDM_ERROR_LOG_COMPLETE 0x18124904
+#define AXIIC_DS_4_IDM_ERROR_LOG_STATUS 0x18124908
+#define AXIIC_DS_4_IDM_ERROR_LOG_ADDR_LSB 0x1812490c
+#define AXIIC_DS_4_IDM_ERROR_LOG_ID 0x18124914
+#define AXIIC_DS_4_IDM_ERROR_LOG_FLAGS 0x1812491c
+#define AXIIC_DS_4_IDM_INTERRUPT_STATUS 0x18124a00
+#define APBW_IDM_IDM_ERROR_LOG_CONTROL 0x18131900
+#define APBW_IDM_IDM_ERROR_LOG_COMPLETE 0x18131904
+#define APBW_IDM_IDM_ERROR_LOG_STATUS 0x18131908
+#define APBW_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1813190c
+#define APBW_IDM_IDM_ERROR_LOG_ID 0x18131914
+#define APBW_IDM_IDM_ERROR_LOG_FLAGS 0x1813191c
+#define APBW_IDM_IDM_INTERRUPT_STATUS 0x18131a00
+#define APBX_IDM_IDM_ERROR_LOG_CONTROL 0x18132900
+#define APBX_IDM_IDM_ERROR_LOG_COMPLETE 0x18132904
+#define APBX_IDM_IDM_ERROR_LOG_STATUS 0x18132908
+#define APBX_IDM_IDM_ERROR_LOG_ADDR_LSB 0x1813290c
+#define APBX_IDM_IDM_ERROR_LOG_ID 0x18132914
+#define APBX_IDM_IDM_ERROR_LOG_FLAGS 0x1813291c
+#define APBX_IDM_IDM_INTERRUPT_STATUS 0x18132a00
+#define AXIIC_DS_0_IDM_ERROR_LOG_CONTROL 0x18141900
+#define AXIIC_DS_0_IDM_ERROR_LOG_COMPLETE 0x18141904
+#define AXIIC_DS_0_IDM_ERROR_LOG_STATUS 0x18141908
+#define AXIIC_DS_0_IDM_ERROR_LOG_ADDR_LSB 0x1814190c
+#define AXIIC_DS_0_IDM_ERROR_LOG_ID 0x18141914
+#define AXIIC_DS_0_IDM_ERROR_LOG_FLAGS 0x1814191c
+#define AXIIC_DS_0_IDM_INTERRUPT_STATUS 0x18141a00
+#define AXIIC_DS_1_IDM_ERROR_LOG_CONTROL 0x18142900
+#define AXIIC_DS_1_IDM_ERROR_LOG_COMPLETE 0x18142904
+#define AXIIC_DS_1_IDM_ERROR_LOG_STATUS 0x18142908
+#define AXIIC_DS_1_IDM_ERROR_LOG_ADDR_LSB 0x1814290c
+#define AXIIC_DS_1_IDM_ERROR_LOG_ID 0x18142914
+#define AXIIC_DS_1_IDM_ERROR_LOG_FLAGS 0x1814291c
+#define AXIIC_DS_1_IDM_INTERRUPT_STATUS 0x18142a00
+#define CTF_CONTROL_REG 0x18025c00
+#define CTF_CONTROL_BASE 0x5c00
+#define CTF_FLOW_TIMER_CONFIG0__TCP_FINISHED_TIMEBASE_TWO_EXP37 0x0
+#define CTF_FLOW_TIMER_CONFIG0__TCP_FINISHED_TIMEBASE_TWO_EXP31 0x1
+#define CTF_FLOW_TIMER_CONFIG0__TCP_FINISHED_TIMEBASE_TWO_EXP26 0x2
+#define CTF_FLOW_TIMER_CONFIG0__TCP_ESTABLISHED_TIMEBASE_R 2
+#define CTF_FLOW_TIMER_CONFIG0__TCP_FINISHED_TIMEBASE_R 0
+#define CTF_FLOW_TIMER_CONFIG1__TCP_ESTABLISHED_TIMEOUT_R 8
+#define CTF_FLOW_TIMER_CONFIG1__UDP_ESTABLISHED_TIMEOUT_R 16
+#define CTF_FLOW_TIMER_CONFIG1__TCP_FINISHED_TIMEOUT_R 0
+#define CTF_FLOW_TIMER_CONFIG0__UDP_ESTABLISHED_TIMEBASE_R 4
+#define CTF_FLOW_TIMER_CONFIG0__UDP_ESTABLISHED_TIMEBASE_R 4
+#define CTF_FLOW_TIMER_CONFIG0__UDP_ESTABLISHED_TIMEBASE_TWO_EXP31 0x1
+#define CTF_FLOW_TIMER_CONFIG0__TCP_ESTABLISHED_TIMEBASE_TWO_EXP31 0x1
+#define CTF_FLOW_TIMEOUT_CONTROL__FLOW_ENTRY_POINTER_R 5
+
+#define CTF_DRR_CONFIG__MAC_WEIGHT_R 7
+#define CTF_MEM_ACC_CONTROL__RD_WR_N 15
+#define CTF_MEM_ACC_CONTROL__TABLE_SELECT_R 12
+#define CTF_MEM_ACC_CONTROL__ALL_R 0
+
+#define PAE_M0_IDM_IDM_RESET_CONTROL 0x1811f800
+#define PAE_S0_IDM_IDM_RESET_CONTROL 0x18125800
+#define CTF_CONTROL__MEM_INIT 1
+#define AMAC_IDM0_IO_CONTROL_DIRECT 0x18110408
+#define AMAC_IDM0_IO_CONTROL_DIRECT__CLK_250_SEL 6
+#define AMAC_IDM1_IO_CONTROL_DIRECT 0x18111408
+#define AMAC_IDM1_IO_CONTROL_DIRECT__CLK_250_SEL 6
+#define CTF_CONTROL__CTF_MODE 0
+#define CTF_CONTROL__FRAGMENTATION_ENABLE 2
+#define CTF_CONTROL__DISABLE_MAC_DA_CHECK 3
+#define CTF_CONTROL__PAE_ENABLED 5
+#define CTF_CONTROL__SPU_ENABLE 6
+#define CTF_BRCM_HDR_CONTROL 0x18025c08
+#define CTF_BRCM_HDR_CONTROL__BRCM_HDR_REASON_CODE_MASK_WIDTH 8
+#define CTF_BRCM_HDR_CONTROL__BRCM_HDR_REASON_CODE_MASK_R 0
+#define SPU_CONTROL 0x1802f000
+#define SPU_CONTROL__OUT_ENDIAN 12
+#define SPU_CONTROL__IN_ENDIAN 11
+#define SPU_CONTROL__SOFT_RST 1
+#define R5_CONFIG0 0x180490d8
+#define R5_CONFIG0__TE_INIT 31
+#define R5_CONFIG0__SYS_PORESET 30
+#define R5_CONFIG0__RESET_N 29
+#define R5_CONFIG0__PARITY_ODD 28
+#define R5_CONFIG0__PADDR_DEBUG31 27
+#define R5_CONFIG0__LOC_ZERO_RAMA 26
+#define R5_CONFIG0__INTERRUPT_ASYNC 25
+#define R5_CONFIG0__INITRAMB 24
+#define R5_CONFIG0__INITRAMA 23
+#define R5_CONFIG0__DEBUG_RESTART 22
+#define R5_CONFIG0__DEBUG_RESET_N 21
+#define R5_CONFIG0__DEBUG_RESET 20
+#define R5_CONFIG0__DEBUG_RESET 20
+#define R5_CONFIG0__DEBUG_NO_CLK_STOP 19
+#define R5_CONFIG0__DEBUG_NIDEN 18
+#define R5_CONFIG0__DEBUG_ENTCM1IF 17
+#define R5_CONFIG0__DEBUG_EN 16
+#define R5_CONFIG0__DEBUG_EDBGRQ 15
+#define R5_CONFIG0__DAP_DAP_TO_DEBUG_APB_EN 14
+#define R5_CONFIG0__CPU_HALT 13
+#define R5_CONFIG0__CFG_ENDIAN 12
+#define R5_CONFIG0__CFG_EE 11
+#define R5_CONFIG0__BTCM_SPLIT 10
+#define R5_CONFIG0__BTCM_SIZE_R 6
+#define R5_CONFIG0__BTCM_SIZE_WIDTH 4
+#define R5_CONFIG0__ATCM_SIZE_R 2
+#define R5_CONFIG0__ATCM_SIZE_WIDTH 4
+#define R5_CONFIG0__RMW_RAM_R 0
+#define R5_CONFIG0__RMW_RAM_WIDTH 2
+
+#define PAE_ECC_DEBUG 0x180490cc
+#define PAE_ECC_DEBUG__ECC_DISABLE 10
+#define PAE_BUFFER_CONFIG 0x18049010
+#define PAE_BUFFER_CONFIG__PAE_MEM_INIT 1
+#define PAE_BUFFER_CONFIG__PAE_SYS_INIT 0
+#define PAE_BUFFER_CONFIG__PAE_MEM_INIT_DONE 2
+#define PAE_BUFFER_ALLOCATION0 0x18049018
+#define PAE_BUFFER_ALLOCATION0 0x18049018
+#define PAE_BUFFER_ALLOCATION__INTERCEPT_PT_END_ADDR_R 16
+#define PAE_BUFFER_ALLOCATION__INTERCEPT_PT_END_ADDR_WIDTH 12
+#define PAE_BUFFER_ALLOCATION__INTERCEPT_PT_START_ADDR_R 0
+#define PAE_BUFFER_ALLOCATION__INTERCEPT_PT_START_ADDR_WIDTH 12
+
+#define PAE_BUFFER_ALLOCATION1 0x1804901c
+#define PAE_BUFFER_BACKPRESSURE_CONFIG0 0x18049020
+#define PAE_BUFFER_BACKPRESSURE_CONFIG__WATERMARK_DEPTH_XOFF_R 16
+#define PAE_BUFFER_BACKPRESSURE_CONFIG__WATERMARK_DEPTH_XOFF_WIDTH 12
+#define PAE_BUFFER_BACKPRESSURE_CONFIG__WATERMARK_DEPTH_XON_R 0
+#define PAE_BUFFER_BACKPRESSURE_CONFIG__WATERMARK_DEPTH_XON_WIDTH 12
+#define PAE_BUFFER_BACKPRESSURE_CONFIG1 0x18049024
+#define PAE_BUFFER_CONGESTION_CONFIG 0x18049028
+#define PAE_BUFFER_CONGESTION_CONFIG__ENQ0_STOP_LEVEL_R 0
+#define PAE_BUFFER_CONGESTION_CONFIG__ENQ0_STOP_LEVEL_WIDTH 12
+#define PAE_BUFFER_BACKPRESSURE_MAP0 0x1804902c
+#define PAE_BUFFER_BACKPRESSURE_MAP__INTERCEPT_PT_BACKPRESSURE_CONTRIBUTOR_MASK_R 0
+#define PAE_BUFFER_BACKPRESSURE_MAP__INTERCEPT_PT_BACKPRESSURE_CONTRIBUTOR_MASK_WIDTH 2
+#define PAE_BUFFER_BACKPRESSURE_MAP1 0x18049030
+#define PAE_SCRATCHPAD_ALLOCATION 0x18049014
+#define PAE_SCRATCHPAD_ALLOCATION__SCRATCHPAD_END_ADDR_R 16
+#define PAE_SCRATCHPAD_ALLOCATION__SCRATCHPAD_END_ADDR_WIDTH 12
+#define PAE_SCRATCHPAD_ALLOCATION__SCRATCHPAD_START_ADDR_R 0
+#define PAE_SCRATCHPAD_ALLOCATION__SCRATCHPAD_START_ADDR_WIDTH 12
+#define CTF_DEBUG_CONTROL 0x18025ca0
+#define CTF_DEBUG_CONTROL__DM_FIFO_BP_LEVEL_R 10
+#define CTF_DEBUG_CONTROL__DM_FIFO_BP_LEVEL_WIDTH 8
+
+#endif /* __SOCREGS_NSP_OPEN_H */
diff --git a/arch/arm/mach-iproc/io_map.c b/arch/arm/mach-iproc/io_map.c
new file mode 100644
index 0000000..47d89c1
--- /dev/null
+++ b/arch/arm/mach-iproc/io_map.c
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
+#include <asm/mach/map.h>
+#include <asm/pgalloc.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <mach/io_map.h>
+
+#define IO_DESC(va, sz) { .virtual = va,		\
+	.pfn = __phys_to_pfn(HW_IO_VIRT_TO_PHYS(va)), 	\
+	.length = sz,					\
+	.type = MT_DEVICE }
+
+
+static struct map_desc northstar_io_desc[] __initdata =
+{
+	IO_DESC(IO_CORE_IDM_VA,IO_CORE_IDM_SIZE),
+	IO_DESC(IO_ARMCORE_VA, IO_ARMCORE_SIZE),
+};
+
+extern void __init iproc_map_io(void);
+
+void __init northstar_map_io(void)
+{
+	iotable_init(northstar_io_desc, ARRAY_SIZE(northstar_io_desc));
+}
diff --git a/arch/arm/mach-iproc/northstar.c b/arch/arm/mach-iproc/northstar.c
new file mode 100644
index 0000000..9de9bb3
--- /dev/null
+++ b/arch/arm/mach-iproc/northstar.c
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/cpumask.h>
+#include <linux/reboot.h>
+#include <linux/pm.h>
+
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/system_misc.h>
+#include <asm/pgtable.h>
+#include <asm/localtimer.h>
+#include <asm/smp_twd.h>
+
+#include <mach/clkdev.h>
+#include <mach/timer.h>
+#include <mach/iproc.h>
+#include <mach/io_map.h>
+#include <mach/irqs.h>
+#include <mach/memory.h>
+
+
+
+
+
+#define TIMER_LOAD      	0x00
+#define TIMER_VALUE     	0x04
+#define TIMER_CTRL      	0x08
+#define TIMER_CTRL_PRESC_SHFT   (8)
+#define TIMER_CTRL_IE           (1 << 2)
+#define TIMER_CTRL_PERIODIC     (1 << 1)
+#define TIMER_CTRL_ENABLE       (1 << 0)
+
+#define TIMER_INTCLR    	0x0c
+#define IPROC_L2CC_REG_BASE_VA  HW_IO_PHYS_TO_VIRT(IPROC_L2CC_REG_BASE)
+
+extern void __iomem *twd_base;
+extern void iproc_clocksource_init(void __iomem *);
+extern void iproc_clockevents_init(void __iomem *, unsigned int);
+extern void __init northstar_dmu_init(struct clk *clk_ref);
+extern void __init iproc_cru_init(struct clk *clk_ref);
+extern void iproc_enable_data_prefetch_aborts(void);
+extern void northstar_restart(char mode, const char *cmd);
+
+static void
+northstar_poweroff(void)
+{
+	while(1)
+	;
+}
+
+
+#ifdef CONFIG_CACHE_L2X0
+static void __init northstar_l2x0_init(void)
+{
+	void __iomem *l2cache_base = IOMEM(IPROC_L2CC_REG_VA);
+
+	void __iomem *cca = IOMEM(IPROC_CCA_CORE_REG_VA);
+
+	unsigned int chipid = (readl(cca) & 0x0000ffff);
+	
+
+	/*
+	 * 16KB way size, 16-way associativity
+	 */
+#if defined(CONFIG_MACH_NS)	
+	if (chipid >= 0xcf19 /* costar */) {
+#ifdef CONFIG_BCM_IPROC_CA9_PREFETCH 
+    /* inst/data prefetch & Early BRESP & Fill line zero (also need A9) */
+		l2x0_init(l2cache_base, (0x0A150000 | 0x3 << 28 | 0x1 << 30 | 0x1 << 0), ~(0x000F0000));
+#else
+		l2x0_init(l2cache_base, 0x0A150000, ~(0x000F0000));
+#endif /* CONFIG_BCM_IPROC_CA9_PREFETCH */
+	} else {	/* northstar */
+		l2x0_init(l2cache_base, 0x0A130000, ~(0x000F0000));
+	}
+#elif (defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2))
+		l2x0_init(l2cache_base, 0x0A150000, ~(0x000F0000));
+#elif defined(CONFIG_MACH_HR2)
+		l2x0_init(l2cache_base, 0x0A120000, ~(0x000F0000));
+#elif defined(CONFIG_MACH_NSP)
+#ifdef CONFIG_BCM_IPROC_CA9_PREFETCH 
+    /* inst/data prefetch & Early BRESP & Fill line zero (also need A9) */
+		l2x0_init(l2cache_base, (0x0A150000 | 0x3 << 28 | 0x1 << 30 | 0x1 << 0), ~(0x000F0000));
+#else
+		l2x0_init(l2cache_base, 0x0A150000, ~(0x000F0000));
+#endif /* CONFIG_BCM_IPROC_CA9_PREFETCH */
+#endif
+}
+#endif
+
+static int __init northstar_init(void)
+{
+#ifdef CONFIG_PM
+	pm_power_off = northstar_poweroff;
+	arm_pm_restart = northstar_restart;
+#endif
+    
+#ifdef CONFIG_CACHE_L2X0
+	northstar_l2x0_init();
+#endif
+
+	return 0;
+}
+early_initcall(northstar_init);
+
+/*
+ * CPU global and MPCORE Per CPU local timer
+ */
+#define GLB_TIMER IOMEM(IPROC_PERIPH_GLB_TIM_REG_VA);
+#define PVT_TIMER IOMEM(IPROC_PERIPH_PVT_TIM_REG_VA);
+
+void __iomem *gtimer_va_base    = GLB_TIMER;
+void __iomem *ptimer_va_base    = PVT_TIMER;
+
+#define IRQ_LOCALTIMER BCM_INT_ID_PPI13
+/*
+ * Setup the local clock events for a CPU.
+ */
+
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      HW_IO_VIRT_TO_PHYS(IPROC_PERIPH_PVT_TIM_REG_VA),
+			      IRQ_LOCALTIMER);
+
+
+/*
+ * Set up the clock source and clock events devices
+ */
+void __init northstar_timer_init(struct clk *clk_ref)
+{
+	int err;
+
+	/*
+	 * Setup DMU and CRU early
+	 */
+	northstar_dmu_init(clk_ref);
+	iproc_cru_init(clk_ref);
+
+	/*
+	 * Initialise to a known state (all timers off)
+	 */
+	writel(0, ptimer_va_base + TIMER_CTRL);
+	writel(0, gtimer_va_base + TIMER_CTRL);
+
+#ifdef CONFIG_LOCAL_TIMERS
+	err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("iproc: twd_local_timer_register failed %d\n", err);
+#endif
+
+	iproc_clocksource_init(gtimer_va_base);
+	iproc_clockevents_init(gtimer_va_base, BCM_INT_ID_PPI11);
+
+	iproc_enable_data_prefetch_aborts();
+}
diff --git a/arch/arm/mach-iproc/northstar.h b/arch/arm/mach-iproc/northstar.h
new file mode 100644
index 0000000..ed5ede7
--- /dev/null
+++ b/arch/arm/mach-iproc/northstar.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __NORTHSTAR_H
+#define __NORTHSTAR_H
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+extern struct platform_device northstar_ipc_device;
+
+void __init northstar_map_io(void);
+
+#endif /* __NORTHSTAR_H */
diff --git a/arch/arm/mach-iproc/northstar_dmu.c b/arch/arm/mach-iproc/northstar_dmu.c
new file mode 100644
index 0000000..f49e236
--- /dev/null
+++ b/arch/arm/mach-iproc/northstar_dmu.c
@@ -0,0 +1,719 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/clkdev.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+
+#include <mach/clkdev.h>
+#include <mach/io_map.h>
+#include <mach/iproc_regs.h>
+#include <mach/hardware.h>
+
+#define IPROC_DMU_BASE_PA	IPROC_DMU_BASE_REG
+//#define IPROC_DMU_BASE_VA	HW_IO_PHYS_TO_VIRT(IPROC_DMU_BASE_PA)
+
+static struct resource dmu_regs = {
+	.name = "dmu_regs",
+	.start = (resource_size_t) IOMEM(IPROC_DMU_BASE_VA),
+	.end = (resource_size_t) (IOMEM(IPROC_DMU_BASE_VA) + SZ_4K - 1),
+    .flags = IORESOURCE_MEM,
+};
+
+/*
+ * Clock management scheme is a provisional implementation
+ * only intended to retreive the pre-set frequencies for each
+ * of the clocks.
+ * Better handling of post-dividers and fractional part of
+ * feedbeck dividers need to be added.
+ * Need to understand what diagnostics from CRU registers could
+ * be handy, and export that via a sysfs interface.
+ */
+
+/* 
+ * The CRU contains two similar PLLs: LCPLL and GENPLL,
+ * both with several output channels divided from the PLL
+ * output
+ */
+
+/*
+ * Get PLL running status and update output frequency
+ */
+static int lcpll_status(struct clk * clk)
+{
+	u32 reg;
+	u64 x;
+	unsigned pdiv, ndiv_int, ndiv_frac;
+
+	if (clk->type != CLK_PLL)
+		return -EINVAL;
+
+	/* read status register */
+	reg = readl(clk->regs_base + 0x10);
+
+	/* bit 12 is "lock" signal, has to be "1" for proper PLL operation */
+	if ((reg & (1 << 12)) == 0) {
+		clk->rate = 0;
+	}
+
+	/* Update PLL frequency */
+
+	/* control1 register */
+	reg = readl(clk->regs_base + 0x04);
+
+	/* feedback divider integer and fraction parts */
+	pdiv = (reg >> 28) & 7 ;
+	ndiv_int = (reg >> 20) & 0xff;
+	ndiv_frac = reg & ((1<<20)-1);
+
+	if (pdiv == 0)
+		return -EIO;
+
+	x = clk->parent->rate / pdiv ;
+
+	x = x * ((u64) ndiv_int << 20 | ndiv_frac) ;
+
+	clk->rate = x >> 20 ;
+
+	return 0;
+}
+
+static const struct clk_ops lcpll_ops = {
+	.status = lcpll_status,
+};
+
+static int lcpll_chan_status(struct clk * clk)
+{
+	void * __iomem base;
+	u32 reg;
+	unsigned enable;
+	unsigned mdiv;
+
+	if (clk->parent == NULL || clk->type != CLK_DIV)
+		return -EINVAL;
+
+	/* Register address is only stored in PLL structure */
+	base = clk->parent->regs_base;
+	BUG_ON(base == NULL);
+
+	/* enable bit is in enableb_ch[] inversed */
+	enable = ((readl(base + 0) >> 6) & 7) ^ 7;
+
+	if (0 == (enable & (1 << clk->chan))) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* get divider */
+	reg = readl(base + 0x08);
+
+	mdiv = 0xff & (reg >> ((0x3^clk->chan) << 3));
+
+	/* when divisor is 0, it behaves as max+1 */
+	if (mdiv == 0)
+		mdiv = 1 << 8;
+
+	printk("LCPLL[%d] mdiv=%u rate=%lu\n", clk->chan, mdiv, clk->parent->rate);
+
+	clk->rate = (clk->parent->rate / mdiv);
+	return 0;
+}
+
+
+static const struct clk_ops lcpll_chan_ops = {
+	.status = lcpll_chan_status,
+};
+
+/*
+ * LCPLL has 4 output channels
+ */
+static struct clk clk_lcpll = {
+	.ops 	= &lcpll_ops,
+	.name 	= "LCPLL",
+	.type	= CLK_PLL,
+	.chan	=	4,
+};
+
+/*
+ * LCPLL output clocks -
+ * chan 0 - PCIe ref clock, should be 1 GHz,
+ * chan 1 - SDIO clock, e.g. 200 MHz,
+ * chan 2 - DDR clock, typical 166.667 MHz for DDR667,
+ * chan 3 - Unknown
+ */
+
+static struct clk clk_lcpll_ch[4] = {
+	{
+		.ops	= &lcpll_chan_ops,
+		.parent = &clk_lcpll,
+		.type = CLK_DIV,
+	  	.name	= "lcpll_ch0",
+		.chan	= 0,
+	},
+	{
+		.ops	= &lcpll_chan_ops,
+		.parent = &clk_lcpll,
+		.type = CLK_DIV,
+	  	.name	= "lcpll_ch1",
+		.chan	= 1,
+	},
+	{
+		.ops	= &lcpll_chan_ops,
+		.parent = &clk_lcpll,
+		.type = CLK_DIV,
+	  	.name	= "lcpll_ch2",
+		.chan	= 2,
+	},
+	{
+		.ops	= &lcpll_chan_ops,
+		.parent = &clk_lcpll,
+		.type = CLK_DIV,
+	  	.name	= "lcpll_ch3",
+		.chan	= 3,
+	},
+};
+
+/*
+ * Get PLL running status and update output frequency
+ */
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+static int genpll_status(struct clk * clk)
+{
+	u32 reg;
+	u64 x;
+	unsigned pdiv;
+	unsigned ndiv_int;
+	unsigned ndiv_frac;
+
+	if (clk->type != CLK_PLL)
+		return -EINVAL;
+
+	/* Offset of the PLL status register */
+	reg = readl(clk->regs_base + 0x20);
+
+	/* bit 12 is "lock" signal, has to be "1" for proper PLL operation */
+	if((reg & (1 << 12)) == 0) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* Update PLL frequency */
+
+	/* get PLL feedback divider values from control5 */
+	reg = readl(clk->regs_base + 0x14);
+
+	/* feedback divider integer and fraction parts */
+	ndiv_int = reg >> 20;
+	ndiv_frac = reg & ((1 << 20) - 1);
+
+	/* get pdiv */
+	reg = readl(clk->regs_base + 0x18);
+	pdiv = (reg >> 24) & 7;
+
+	if (pdiv == 0)
+		return -EIO;
+
+	x = clk->parent->rate / pdiv;
+
+	x = x * ((u64) ndiv_int << 20 | ndiv_frac);
+
+	clk->rate = x >> 20;
+
+	return 0;
+}
+#endif
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2)
+static int genpll_status(struct clk * clk)
+{
+	u32 reg;
+	u64 x;
+	unsigned pdiv;
+	unsigned ndiv_int;
+
+	if (clk->type != CLK_PLL)
+		return -EINVAL;
+
+	/* Offset of the PLL status register */
+	reg = readl(clk->regs_base + 0x18);
+
+	/* bit 12 is "lock" signal, has to be "1" for proper PLL operation */
+	if((reg & (1 << IPROC_WRAP_GEN_PLL_STATUS__GEN_PLL_LOCK)) == 0) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* Update PLL frequency */
+
+	/* get PLL feedback divider values from control5 */
+	reg = readl(clk->regs_base + 0x04);
+
+	/* feedback divider integer and fraction parts */
+	ndiv_int = (reg >> IPROC_WRAP_GEN_PLL_CTRL1__NDIV_INT_R) & ((1 << IPROC_WRAP_GEN_PLL_CTRL1__NDIV_INT_WIDTH) -1);
+
+	/* get pdiv */
+	pdiv = (reg >> IPROC_WRAP_GEN_PLL_CTRL1__PDIV_R) & ((1 << IPROC_WRAP_GEN_PLL_CTRL1__PDIV_WIDTH) -1);
+
+	if (pdiv == 0)
+		return -EIO;
+
+	x = clk->parent->rate / pdiv;
+
+	x = x * ((u64) ndiv_int);
+
+	clk->rate = x;
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MACH_KT2)
+static int genpll_status(struct clk * clk)
+{
+	clk->rate = 2475000000;
+
+	return 0;
+}
+#endif
+
+static const struct clk_ops genpll_ops = {
+	.status = genpll_status,
+};
+
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+static int genpll_chan_status(struct clk * clk)
+{
+	void * __iomem base;
+	u32 reg;
+	unsigned enable;
+	unsigned mdiv;
+	unsigned off, shift;
+
+	if (clk->parent == NULL || clk->type != CLK_DIV)
+		return -EINVAL;
+
+	/* Register address is only stored in PLL structure */
+	base = clk->parent->regs_base;
+
+	BUG_ON (base == NULL);
+
+	/* enable bit is in enableb_ch[0..5] inversed */
+	enable = ((readl(base + 0x04) >> 12) & 0x3f) ^ 0x3f ;
+
+	if (0 == (enable & (1 << clk->chan))) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* GENPLL has the 6 channels spread over two regs */
+	switch (clk->chan) {
+		case 0:
+			off = 0x18; shift = 16;
+			break;
+
+		case 1:
+			off = 0x18; shift = 8;
+			break;
+
+		case 2:
+			off = 0x18; shift = 0;
+			break;
+
+		case 3:
+			off = 0x1c; shift = 16;
+			break;
+
+		case 4:
+			off = 0x1c; shift = 8;
+			break;
+
+		case 5:
+			off = 0x1c; shift = 16; /* Set to AXI clock */
+			break;
+
+		default:
+			BUG_ON(clk->chan);
+			off = shift = 0;	/* fend off warnings */
+	}
+
+	reg = readl(base + off);
+
+	mdiv = 0xff & (reg >> shift);
+	/* APB clock is always AXIclock/4 */
+	if(clk->chan == 5)
+		mdiv = mdiv * 4;
+
+	/* when divisor is 0, it behaves as max+1 */
+	if (mdiv == 0)
+		mdiv = 1 << 8;
+
+	printk("GENPLL[%d] mdiv=%u rate=%lu\n",
+		clk->chan, mdiv, clk->parent->rate);
+
+	clk->rate = clk->parent->rate / mdiv;
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2)
+static int genpll_chan_status(struct clk * clk)
+{
+	void * __iomem base;
+	u32 reg;
+	unsigned enable;
+	unsigned mdiv = 0;
+	unsigned off, shift;
+
+	if (clk->parent == NULL || clk->type != CLK_DIV)
+		return -EINVAL;
+
+	/* Register address is only stored in PLL structure */
+	base = clk->parent->regs_base;
+
+	BUG_ON (base == NULL);
+	/* GENPLL has the 6 channels spread over two regs */
+	switch (clk->chan) {
+		case 0:
+			off = 0x04; shift = IPROC_WRAP_GEN_PLL_CTRL1__CH0_MDIV_R;
+			break;
+
+		case 1:
+			off = 0x04; shift = IPROC_WRAP_GEN_PLL_CTRL1__CH1_MDIV_R;
+			break;
+
+		case 2:
+			off = 0x08; shift = IPROC_WRAP_GEN_PLL_CTRL2__CH2_MDIV_R;
+			break;
+
+		case 3:
+			off = 0x08; shift = IPROC_WRAP_GEN_PLL_CTRL2__CH3_MDIV_R;
+			break;
+
+		case 4:
+			off = 0x08; shift = IPROC_WRAP_GEN_PLL_CTRL2__CH4_MDIV_R;
+			break;
+
+		case 5:
+			off = 0x08; shift = IPROC_WRAP_GEN_PLL_CTRL2__CH3_MDIV_R;
+			break;
+
+		default:
+			BUG_ON(clk->chan);
+			off = shift = 0;	/* fend off warnings */
+	}
+
+	reg = readl(base + off);
+
+	mdiv = 0xff & (reg >> shift);
+	if(clk->chan == 5)
+		mdiv *= 4;
+
+	/* when divisor is 0, it behaves as max+1 */
+	if (mdiv == 0)
+		mdiv = 1 << 8;
+
+	printk("GENPLL[%d] mdiv=%u rate=%lu\n",
+		clk->chan, mdiv, clk->parent->rate);
+
+	clk->rate = clk->parent->rate / mdiv;
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MACH_KT2)
+static int genpll_chan_status(struct clk * clk)
+{
+	unsigned mdiv = 0;
+
+
+	if (clk->parent == NULL || clk->type != CLK_DIV)
+		return -EINVAL;
+
+	/* GENPLL has the 6 channels spread over two regs */
+	switch (clk->chan) {
+		case 0:
+			mdiv = 10;
+			break;
+
+		case 3:
+			mdiv = 5;
+			break;
+
+		case 4:
+			mdiv = 10;
+			break;
+
+		case 5:
+			mdiv = 5;
+			break;
+
+		default:
+			BUG_ON(clk->chan);
+	}
+
+	if(clk->chan == 5)
+		mdiv *= 4;
+
+	/* when divisor is 0, it behaves as max+1 */
+	if (mdiv == 0)
+		mdiv = 1 << 8;
+
+	printk("GENPLL[%d] mdiv=%u rate=%lu\n",
+		clk->chan, mdiv, clk->parent->rate);
+
+	clk->rate = clk->parent->rate / mdiv;
+	return 0;
+}
+#endif
+
+static const struct clk_ops genpll_chan_ops = {
+	.status = genpll_chan_status,
+};
+
+
+/*
+ * GENPLL has 6 output channels
+ */
+static struct clk clk_genpll = {
+	.ops 	= &genpll_ops,
+	.name 	= "GENPLL",
+	.type	= CLK_PLL,
+	.chan	=	6,
+};
+
+/*
+ * chan 0 - Ethernet switch and MAC, RGMII, need 250 MHz
+ * chan 1 - Ethernet switch slow clock, 150 Mhz
+ * chan 2 - USB PHY clock, need 30 MHz
+ * chan 3 - iProc N MHz clock, set from OTP
+ * chan 4 - iProc N/2 MHz clock, set from OTP
+ * chan 5 - iProc N/4 MHz clock, set from OTP
+ *
+ * To Do: which clock goes to MPCORE PERIPHCLOCK?
+ */
+
+static struct clk clk_genpll_ch[6] = {
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch0",
+		.chan	= 0,
+	},
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch1",
+		.chan	= 1,
+	},
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch2",
+		.chan	= 2,
+	},
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch3",
+		.chan	= 3,
+	},
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch4",
+		.chan	= 4,
+	},
+	{
+		.ops	= &genpll_chan_ops,
+		.parent = &clk_genpll,
+		.type = CLK_DIV,
+	  	.name	= "genpll_ch5",
+		.chan	= 5,
+	},
+};
+
+/*
+ * This table is used to locate clock sources
+ * from device drivers
+ */
+
+static struct clk_lookup ns_clk_lookups[] = {
+	{
+	.dev_id         = "pcie",
+	.con_id         = "c_clk100",
+	.clk            = &clk_lcpll_ch[0],
+	},{
+	.dev_id         = "sdio",
+	.con_id         = "c_clk200",
+	.clk            = &clk_lcpll_ch[1],
+	},{
+	.dev_id         = "ddr",
+	.con_id         = "c_clk400",
+	.clk            = &clk_lcpll_ch[2],
+	},{
+	.dev_id         = "tbd",
+	.con_id         = "c_clk120",
+	.clk            = &clk_lcpll_ch[3],
+	},{
+	.dev_id		= "en_phy",
+	.con_id         = "c_clk250",
+	.clk            = &clk_genpll_ch[0],
+	},{
+	.dev_id		= "en",
+	.con_id         = "c_clk150",
+	.clk            = &clk_genpll_ch[1],
+	},{
+	.dev_id         = "usb_phy",
+	.con_id         = "c_clk30",
+	.clk            = &clk_genpll_ch[2],
+	},{
+	.dev_id         = "iproc_fast",
+	.con_id         = "c_clk500",
+	.clk            = &clk_genpll_ch[3],
+	},{
+	.dev_id         = "iproc_med",
+	.con_id         = "c_clk250",
+	.clk            = &clk_genpll_ch[4],
+	},{
+	.dev_id         = "iproc_slow",
+	.con_id         = "c_clk125",
+	.clk            = &clk_genpll_ch[5],
+	}
+#ifdef CONFIG_ARM_AMBA
+	,{
+	.con_id		= "apb_pclk",
+	.clk		= &clk_genpll_ch[5],
+	}
+#ifdef CONFIG_IPROC_CCB_WDT
+	,{
+	.dev_id		= "sp805-wdt",
+	.clk		= &clk_genpll_ch[5],
+	}
+#endif
+#endif
+};
+
+/* 
+ * Install above clocks into clock lookup table 
+ * and initialize the register base address for each
+*/
+static void __init northstar_clocks_init(void *__iomem cru_regs_base,
+				struct clk * clk_ref)
+{
+	/*
+	 * Registers are already mapped with the rest of DMU block
+	 * Update register base address
+	 */
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+	clk_lcpll.regs_base =	cru_regs_base + 0x00 ;
+	clk_genpll.regs_base =	cru_regs_base + 0x40 ;
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2)
+	clk_lcpll.regs_base =	cru_regs_base + 0x1c ;
+	clk_genpll.regs_base =	cru_regs_base + 0x00 ;
+#endif
+
+	/* Set parent as reference ckock */
+	clk_lcpll.parent	= clk_ref;
+	clk_genpll.parent	= clk_ref;
+
+	/* Install clock sources into the lookup table */
+	clkdev_add_table(ns_clk_lookups, 
+			ARRAY_SIZE(ns_clk_lookups));
+}
+
+void __init northstar_dmu_init(struct clk *clk_ref)
+{
+	void * __iomem 	reg_base;
+
+	if (IS_ERR_OR_NULL(clk_ref )) {
+		printk(KERN_ERR "CRU no clock source - skip init\n");
+		return;
+	}
+
+	BUG_ON (request_resource(&iomem_resource, &dmu_regs));
+
+	/* DMU regs are mapped as part of the fixed mapping with CCA+CCB */
+	reg_base = (void * __iomem) dmu_regs.start;
+
+	BUG_ON (IS_ERR_OR_NULL(reg_base));
+
+	/* Initialize clocks */
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+	northstar_clocks_init(reg_base + 0x100, clk_ref); /* CRU LCPLL control0 */
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2)
+	northstar_clocks_init(reg_base + 0xc00, clk_ref); /* IPROC_WRAP_GEN_PLL_CTRL0 */
+#elif defined(CONFIG_MACH_KT2)
+	northstar_clocks_init(NULL, clk_ref); /* IPROC_WRAP_GEN_PLL_CTRL0 */
+#endif
+}
+
+/*
+ * Reset the system
+ */
+void northstar_restart(char mode, const char *cmd)
+{
+	void * __iomem reg_addr;
+	u32 reg;
+
+	/* CRU_RESET register */
+#if (defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP))
+	reg_addr = (void * __iomem) dmu_regs.start + 0x184 ;
+#elif defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_HR2) || defined(CONFIG_MACH_KT2)
+	reg_addr = (void * __iomem) dmu_regs.start + DMU_CRU_RESET_BASE ;
+#endif
+
+	/* set iproc_reset_n to 0, it may come back or not ... TBD */
+	reg = __raw_readl(reg_addr);
+	reg &= ~((u32) 1 << 1);
+	__raw_writel(reg, reg_addr);
+}
+
+
+
+
+
+
+
+void northstar_clocks_show( void )
+{
+	unsigned i;
+//	struct clk * clk ;
+
+	printk("=========== CLOCKS =================\n");
+
+	printk( "DMU Clocks:\n" );
+	for (i = 0; i < ARRAY_SIZE( ns_clk_lookups); i++) {
+		printk("%s, %s: (%s) %lu\n",
+			ns_clk_lookups[i].con_id,
+			ns_clk_lookups[i].dev_id,
+			ns_clk_lookups[i].clk->name,
+			clk_get_rate( ns_clk_lookups[i].clk));
+	}
+	printk( "DMU Clocks# %u\n", i );
+}
diff --git a/arch/arm/mach-iproc/pm.c b/arch/arm/mach-iproc/pm.c
new file mode 100644
index 0000000..1305311
--- /dev/null
+++ b/arch/arm/mach-iproc/pm.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/suspend.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+
+/*
+ * Prepare suspend
+ */
+static int suspend_prepare(void)
+{
+	return 0;
+}
+
+/*
+ * Enter the system sleep state
+ */
+static int suspend_enter(suspend_state_t state)
+{
+	int ret = 0;
+	switch (state) {
+		case PM_SUSPEND_STANDBY:
+			printk("%s: Entering SUSPEND_STANDBY mode\n", __func__);
+			/* Flow through to suspend to memory */
+		case PM_SUSPEND_MEM:
+			printk("%s: Entering SUSPEND_MEM mode\n", __func__);
+			printk(KERN_INFO "%s: Entering run_from_ARAM()\n", __func__);
+
+			printk("%s: Leaving SUSPEND_STANDBY mode\n", __func__);
+			break;
+	}
+	return ret;
+}
+
+/*
+ * Called when the system has just left a sleep state
+ */
+static void suspend_finish(void)
+{
+	return;
+}
+
+static struct platform_suspend_ops suspend_ops ={
+	.valid = suspend_valid_only_mem,
+	.prepare = suspend_prepare,
+	.enter = suspend_enter,
+	.finish = suspend_finish,
+};
+
+int __init pm_init(void)
+{
+	printk("%s: Initializing Power Management ....\n", __func__);
+	suspend_set_ops(&suspend_ops);
+
+	return 0;
+}
+__initcall(pm_init);
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index a10297d..e60e4ab 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1007,3 +1007,4 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+iproc			MACH_IPROC              IPROC                   4576
-- 
1.7.5.4

