From e779261261fe81cb26caf9786866fa3fa98bd075 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Thu, 15 May 2014 15:10:37 +0800
Subject: [PATCH 01/13] ARM: Broadcom: Add plat-iproc platform

Introduce the arch/arm/plat-iproc directory, for code shared of
Broadcom iProc chip.

[Original changes taken from iProcLDK_3.4.6.package.tgz]
[Just a minor modification in order to port to 3.10 kernel.
 Remove v7_invalidate_l1 and pen_release, since they are
 already defined. Add iproc_smp_ops smp operation.]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/arm/plat-iproc/Kconfig                      |   64 ++
 arch/arm/plat-iproc/Makefile                     |    9 +
 arch/arm/plat-iproc/bcm5301x.c                   |   84 ++
 arch/arm/plat-iproc/clock.c                      |  155 +++
 arch/arm/plat-iproc/headsmp.S                    |  102 ++
 arch/arm/plat-iproc/hotplug.c                    |  147 +++
 arch/arm/plat-iproc/include/mach/brcm_rdb_rng.h  |   64 ++
 arch/arm/plat-iproc/include/mach/bridge-regs.h   |   68 ++
 arch/arm/plat-iproc/include/mach/clkdev.h        |   43 +
 arch/arm/plat-iproc/include/mach/clock.h         |   35 +
 arch/arm/plat-iproc/include/mach/common.h        |   51 +
 arch/arm/plat-iproc/include/mach/debug-macro.S   |   30 +
 arch/arm/plat-iproc/include/mach/entry-macro.S   |   98 ++
 arch/arm/plat-iproc/include/mach/gpio.h          |   30 +
 arch/arm/plat-iproc/include/mach/hardware.h      |   40 +
 arch/arm/plat-iproc/include/mach/io.h            |   35 +
 arch/arm/plat-iproc/include/mach/iproc.h         |   26 +
 arch/arm/plat-iproc/include/mach/iproc_timer.h   |  148 +++
 arch/arm/plat-iproc/include/mach/irqs.h          |  238 +++++
 arch/arm/plat-iproc/include/mach/lm.h            |   48 +
 arch/arm/plat-iproc/include/mach/memory.h        |   64 ++
 arch/arm/plat-iproc/include/mach/sdio_platform.h |   67 ++
 arch/arm/plat-iproc/include/mach/smp.h           |   41 +
 arch/arm/plat-iproc/include/mach/system.h        |   34 +
 arch/arm/plat-iproc/include/mach/timer.h         |   49 +
 arch/arm/plat-iproc/include/mach/timex.h         |   25 +
 arch/arm/plat-iproc/include/mach/uncompress.h    |   54 +
 arch/arm/plat-iproc/include/plat/dma-pl330.h     |  103 ++
 arch/arm/plat-iproc/include/plat/dma_drv.h       |  603 +++++++++++
 arch/arm/plat-iproc/include/plat/dmux.h          |   76 ++
 arch/arm/plat-iproc/include/plat/osdal_os.h      |   60 ++
 arch/arm/plat-iproc/include/plat/shm.h           |   34 +
 arch/arm/plat-iproc/include/plat/spi_iproc.h     |   27 +
 arch/arm/plat-iproc/include/plat/swreset_rec.h   |   40 +
 arch/arm/plat-iproc/include/plat/timer-sp.h      |   18 +
 arch/arm/plat-iproc/include/plat/types.h         |   20 +
 arch/arm/plat-iproc/iproc-cache.S                |   77 ++
 arch/arm/plat-iproc/iproc_cru.c                  |  507 ++++++++++
 arch/arm/plat-iproc/irq.c                        |   50 +
 arch/arm/plat-iproc/localtimer.c                 |   43 +
 arch/arm/plat-iproc/pcie_iproc.c                 | 1160 ++++++++++++++++++++++
 arch/arm/plat-iproc/platsmp.c                    |  252 +++++
 arch/arm/plat-iproc/shm.c                        |   82 ++
 arch/arm/plat-iproc/swreset_rec.c                |  175 ++++
 arch/arm/plat-iproc/sysfs.c                      |  216 ++++
 arch/arm/plat-iproc/timer-sp.c                   |  254 +++++
 arch/arm/plat-iproc/timer.c                      |  280 ++++++
 47 files changed, 5926 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-iproc/Kconfig
 create mode 100644 arch/arm/plat-iproc/Makefile
 create mode 100644 arch/arm/plat-iproc/bcm5301x.c
 create mode 100644 arch/arm/plat-iproc/clock.c
 create mode 100644 arch/arm/plat-iproc/headsmp.S
 create mode 100644 arch/arm/plat-iproc/hotplug.c
 create mode 100644 arch/arm/plat-iproc/include/mach/brcm_rdb_rng.h
 create mode 100644 arch/arm/plat-iproc/include/mach/bridge-regs.h
 create mode 100644 arch/arm/plat-iproc/include/mach/clkdev.h
 create mode 100644 arch/arm/plat-iproc/include/mach/clock.h
 create mode 100644 arch/arm/plat-iproc/include/mach/common.h
 create mode 100644 arch/arm/plat-iproc/include/mach/debug-macro.S
 create mode 100644 arch/arm/plat-iproc/include/mach/entry-macro.S
 create mode 100644 arch/arm/plat-iproc/include/mach/gpio.h
 create mode 100644 arch/arm/plat-iproc/include/mach/hardware.h
 create mode 100644 arch/arm/plat-iproc/include/mach/io.h
 create mode 100644 arch/arm/plat-iproc/include/mach/iproc.h
 create mode 100644 arch/arm/plat-iproc/include/mach/iproc_timer.h
 create mode 100644 arch/arm/plat-iproc/include/mach/irqs.h
 create mode 100644 arch/arm/plat-iproc/include/mach/lm.h
 create mode 100644 arch/arm/plat-iproc/include/mach/memory.h
 create mode 100644 arch/arm/plat-iproc/include/mach/sdio_platform.h
 create mode 100644 arch/arm/plat-iproc/include/mach/smp.h
 create mode 100644 arch/arm/plat-iproc/include/mach/system.h
 create mode 100644 arch/arm/plat-iproc/include/mach/timer.h
 create mode 100644 arch/arm/plat-iproc/include/mach/timex.h
 create mode 100644 arch/arm/plat-iproc/include/mach/uncompress.h
 create mode 100644 arch/arm/plat-iproc/include/plat/dma-pl330.h
 create mode 100644 arch/arm/plat-iproc/include/plat/dma_drv.h
 create mode 100644 arch/arm/plat-iproc/include/plat/dmux.h
 create mode 100644 arch/arm/plat-iproc/include/plat/osdal_os.h
 create mode 100644 arch/arm/plat-iproc/include/plat/shm.h
 create mode 100644 arch/arm/plat-iproc/include/plat/spi_iproc.h
 create mode 100644 arch/arm/plat-iproc/include/plat/swreset_rec.h
 create mode 100644 arch/arm/plat-iproc/include/plat/timer-sp.h
 create mode 100644 arch/arm/plat-iproc/include/plat/types.h
 create mode 100644 arch/arm/plat-iproc/iproc-cache.S
 create mode 100644 arch/arm/plat-iproc/iproc_cru.c
 create mode 100644 arch/arm/plat-iproc/irq.c
 create mode 100644 arch/arm/plat-iproc/localtimer.c
 create mode 100644 arch/arm/plat-iproc/pcie_iproc.c
 create mode 100644 arch/arm/plat-iproc/platsmp.c
 create mode 100644 arch/arm/plat-iproc/shm.c
 create mode 100644 arch/arm/plat-iproc/swreset_rec.c
 create mode 100644 arch/arm/plat-iproc/sysfs.c
 create mode 100644 arch/arm/plat-iproc/timer-sp.c
 create mode 100644 arch/arm/plat-iproc/timer.c

diff --git a/arch/arm/plat-iproc/Kconfig b/arch/arm/plat-iproc/Kconfig
new file mode 100644
index 0000000..526e927
--- /dev/null
+++ b/arch/arm/plat-iproc/Kconfig
@@ -0,0 +1,64 @@
+# Kernel configuration for Broadcom iProc based boards
+
+menu	"Broadcom IPROC architecture based implementations"
+	depends on ARCH_IPROC
+	
+choice
+	prompt "Broadcom iProc SoC Type"
+	default ARCH_NORTHSTAR	
+
+config ARCH_NORTHSTAR
+	bool "BROADCOM Northstar SoC"
+	help
+	  Support for the Broadcom Northstar SoC platform.
+
+config MACH_IPROC
+	bool "BROADCOM Generic IPROC SoC"
+	help
+	  Support for the Broadcom IPROC SoC platform.
+
+endchoice
+
+
+config IPROC_TIMER_UNIT_TESTS
+	bool "Include iProc Timer unit test code"
+	help
+	  Say Y if you want to test the AON,Peripheral Timer modules using the sysfs interface
+
+config IPROC_SW_RESET_RECORD
+	bool "Include Software Reset Records"
+	help
+	  Say Y if you want to enable interface to access Software Reset Record.
+	  Software Reset Record is a set of variables whose value could be retained
+	  after reset (but will be cleared if powered off).
+
+config DMAC_PL330
+	bool "PL330 DMAC driver support for Kona architecture"
+	depends on ARCH_RHEA
+	select PL330
+	help
+	 Support for PL330 DMA Controller driver for Rhea SOC/KONA architecture
+
+config BCM_ZRELADDR
+	hex "Compressed ZREL address"
+
+config BCM_PARAMS_PHYS
+	hex "Address where tagged parameters are to be found"
+
+config BCM_RAM_BASE
+	hex "RAM base address"
+	help
+	 Set the physical base address of RAM
+
+config IPROC_PCIE
+	tristate "PCIE support"
+	select PCI
+	select PCI_DOMAINS
+	depends on ARCH_IPROC
+	default n
+	help
+	  Add PCIe support
+	
+	  If unsure, say N.
+
+endmenu
diff --git a/arch/arm/plat-iproc/Makefile b/arch/arm/plat-iproc/Makefile
new file mode 100644
index 0000000..e82b550
--- /dev/null
+++ b/arch/arm/plat-iproc/Makefile
@@ -0,0 +1,9 @@
+obj-y := irq.o timer-sp.o sysfs.o bcm5301x.o iproc-cache.o headsmp.o shm.o
+
+obj-$(CONFIG_SMP) += platsmp.o
+obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
+obj-$(CONFIG_HOTPLUG_CPU)  += hotplug.o
+obj-$(CONFIG_HAVE_CLK) += clock.o
+obj-$(CONFIG_ARCH_IPROC) += iproc_cru.o
+obj-$(CONFIG_IPROC_SW_RESET_RECORD) += swreset_rec.o
+obj-$(CONFIG_IPROC_PCIE) += pcie_iproc.o
diff --git a/arch/arm/plat-iproc/bcm5301x.c b/arch/arm/plat-iproc/bcm5301x.c
new file mode 100644
index 0000000..e7e0f4e
--- /dev/null
+++ b/arch/arm/plat-iproc/bcm5301x.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <asm/signal.h>
+#include <asm/mach/map.h>
+#include <asm/pgtable.h>
+#include <asm/bug.h>
+#include <mach/iproc_regs.h>
+#include <mach/io_map.h>
+#include <mach/memory.h>
+
+void __init iproc_map_io(void)
+{
+	struct map_desc desc ;
+	phys_addr_t base_addr;
+
+	/*
+	 * Cortex A9 Architecture Manual specifies this as a way to get
+	 * MPCORE PERHIPHBASE address at run-time
+	 */
+	asm( "mrc p15,4,%0,c15,c0,0 @ Read Configuration Base Address Register"
+		: "=&r" (base_addr) : : "cc" );
+
+	printk(KERN_INFO "MPCORE found at %p\n", (void *)base_addr);
+
+	/* Fix-map the entire PERIPHBASE 2*4K register block */
+	desc.virtual = IPROC_PERIPH_VA;
+	desc.pfn = __phys_to_pfn(base_addr);
+	desc.length = SZ_8K;
+	desc.type = MT_DEVICE ;
+
+	iotable_init(&desc, 1);
+}
+
+static int iproc_data_abort_handler(unsigned long addr,	unsigned int fsr,
+				struct pt_regs *regs)
+{
+	/*
+	 * These happen for no good reason
+	 */
+	printk(KERN_WARNING
+		"Data abort at addr=%#lx, fsr=%#x ignored.\n", addr, fsr);
+	return 0;
+}
+
+void iproc_enable_data_prefetch_aborts(void)
+{
+	u32 x;
+
+	/* Install our hook */
+	hook_fault_code(16 + 6, iproc_data_abort_handler, SIGBUS, 0,
+			"imprecise external data abort");
+
+	/* Enable external aborts - clear "A" bit in CPSR */
+
+	/* Read CPSR */
+	asm("mrs       %0,cpsr": "=&r" (x) : : );
+
+	x &= ~ PSR_A_BIT;
+
+	/* Update CPSR, affect bits 8-15 */
+	asm("msr       cpsr_x,%0; nop; nop": : "r" (x) : "cc");
+
+}
diff --git a/arch/arm/plat-iproc/clock.c b/arch/arm/plat-iproc/clock.c
new file mode 100644
index 0000000..2dee131
--- /dev/null
+++ b/arch/arm/plat-iproc/clock.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+
+#include <mach/clkdev.h>
+
+int clk_enable(struct clk *clk)
+{
+	int ret ;
+
+	ret = atomic_inc_return(&clk->ena_cnt);
+	if (ret > 1)
+		return 0;
+	/* Continue of count was moved from 0 to 1 - reentrant */
+    if (clk->parent)
+		ret = clk_enable( clk->parent );
+	else
+		ret = 0;
+
+	if (ret == 0) {
+		if (!clk->ops || !clk->ops->enable) {
+			if (clk->rate)
+				ret = 0 ;
+			else
+				ret = -EIO;
+		} else {
+			ret =  clk->ops->enable(clk);
+		}
+	}
+
+	if (ret != 0)
+		atomic_dec(&clk->ena_cnt);
+
+	return ret ;
+}
+
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+	int ret ;
+
+	ret = atomic_dec_return(&clk->ena_cnt);
+
+	/* Continue if this is the last client to disable - reentrant */
+	if (ret > 0)
+		return ;
+	BUG_ON(ret < 0);
+
+	if (!clk->ops || !clk->ops->disable)
+        return;
+
+	clk->ops->disable(clk);
+
+	if (clk->parent)
+		clk_disable(clk->parent);
+
+	return ;
+}
+
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	/* Recurse to update parent's frequency */
+	if (clk->parent)
+		clk_get_rate(clk->parent);
+
+	/* Read hardware registers if needed */
+	if (clk->ops && clk->ops->status)
+		clk->ops->status(clk);
+
+	return clk->rate;
+}
+
+EXPORT_SYMBOL(clk_get_rate);
+
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	long ret = -EIO;
+
+	if (clk->ops && clk->ops->round)
+		ret = clk->ops->round(clk, rate);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(clk_round_rate);
+
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EIO;
+
+	if (rate == clk->rate)
+		return 0;
+
+	if (clk->ops && clk->ops->setrate)
+		ret = clk->ops->setrate(clk, rate);
+
+    return ret;
+}
+
+EXPORT_SYMBOL(clk_set_rate);
+
+/*
+ * clk_get(), clk_put() are implemented in arch/arm/common/clock.c
+ * but it needs these two stub functions for platform-specific operations.
+ * Reeturn 1 on success 0 on failure.
+ */
+
+int __clk_get(struct clk *clk)
+{
+	int ret ;
+
+	ret = atomic_inc_return( &clk->use_cnt );
+	if (ret > 1)
+		return 1;
+
+	if (clk->parent)
+		return __clk_get( clk->parent );
+
+	return 1;
+}
+
+void __clk_put(struct clk *clk)
+{
+    int ret;
+
+	ret = atomic_dec_return( &clk->use_cnt);
+	if (ret > 0)
+		return;
+
+	BUG_ON(ret < 0);
+
+	if (clk->parent)
+		__clk_put(clk->parent);
+}
diff --git a/arch/arm/plat-iproc/headsmp.S b/arch/arm/plat-iproc/headsmp.S
new file mode 100644
index 0000000..fbe5b51
--- /dev/null
+++ b/arch/arm/plat-iproc/headsmp.S
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/* Based on arch/arm/mach-realview/headsmp.S */
+/*
+ *  linux/arch/arm/mach-realview/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <mach/iproc_regs.h>
+#include <asm/cp15.h>
+
+/*
+ * This is called from head.S to fix the u-boot not initializing
+ * MMU and cache the way Linux likes it to be. I have talked to
+ * u-boot developer to fix it in u-boot. This will remain as a
+ * safety. Don't use r1 and r2 as u-boot/CFE may pass some parameters
+ * for the kernel.
+ * When this code completes execution, we expect the following:
+ * MMU = OFF
+ * D-Cache = OFF
+ * I-Cache = Don't Care
+ * regs r0 = 0 r1 = machine id and r2 = atags pointer or 0
+ */
+	__HEAD
+ENTRY(__iproc_head_fixup)
+	mov	r12, lr			@ Save the return address
+	mrc	p15, 0, r8,  c1, c0, 0	@ Read SCTLR
+	mrc	p15, 0, r9,  c1, c0, 1	@ Read ACTLR
+	mrc	p15, 0, r10, c2, c0, 0	@ Read TTBR0
+	mrc	p15, 0, r11, c2, c0, 1	@ Read TTBR1
+	mrc	p15, 0, r7,  c2, c0, 2	@ Read TTBCR
+	mov	r0, r8
+	bic	r0, #CR_C||CR_M
+	mcr	p15, 0, r0, c1, c0, 0	@ Write the control register
+	nop
+	mrc	p15, 0, r0, c1, c0, 0	@ Read the control register
+	bic	r0, #CR_C|CR_A|CR_M|CR_W
+	bic	r0, #CR_I|CR_Z
+	mcr	p15, 0, r0, c1, c0, 0	@ Write the control register
+	nop
+	mov	r0, #0
+	@ L2 cache controller control register
+	ldr	r3, =IPROC_L2CC_REG_BASE
+	str	r0, [r3, #0x100]	@ Disable L2 cache
+	bl	__v7_invalidate_dcache_all
+
+	mov	r0, #0
+	mov	pc, r12			@ Return for regular boot
+	nop
+ENDPROC(__iproc_head_fixup)
+
+/*
+ * iProc specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+#ifdef CONFIG_SMP
+ENTRY(iproc_secondary_startup)
+	bl	v7_invalidate_l1
+	bl	v7_flush_dcache_all
+	mrc     p15, 0, r0, c0, c0, 5
+	and     r0, r0, #15
+	adr     r4, 1f
+	ldmia   r4, {r5, r6}
+	sub     r4, r4, r5
+        add     r6, r6, r4
+pen:	ldr     r7, [r6]
+	cmp     r7, r0
+	bne     pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b    secondary_startup
+
+1:	.long   .
+	.long   pen_release
+
+ENDPROC(iproc_secondary_startup)
+#endif
diff --git a/arch/arm/plat-iproc/hotplug.c b/arch/arm/plat-iproc/hotplug.c
new file mode 100644
index 0000000..b47c7cb
--- /dev/null
+++ b/arch/arm/plat-iproc/hotplug.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+
+#include <asm/cacheflush.h>
+
+extern volatile int pen_release;
+
+static DECLARE_COMPLETION(cpu_killed);
+
+static inline void cpu_enter_lowpower(void)
+{
+    unsigned int v;
+
+    flush_cache_all();
+    asm volatile(
+    "    mcr    p15, 0, %1, c7, c5, 0\n"
+    "    mcr    p15, 0, %1, c7, c10, 4\n"
+    /*
+     * Turn off coherency
+     */
+    "    mrc    p15, 0, %0, c1, c0, 1\n"
+    "    bic    %0, %0, #0x20\n"
+    "    mcr    p15, 0, %0, c1, c0, 1\n"
+    "    mrc    p15, 0, %0, c1, c0, 0\n"
+    "    bic    %0, %0, #0x04\n"
+    "    mcr    p15, 0, %0, c1, c0, 0\n"
+      : "=&r" (v)
+      : "r" (0)
+      : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+    unsigned int v;
+
+    asm volatile(    "mrc    p15, 0, %0, c1, c0, 0\n"
+    "    orr    %0, %0, #0x04\n"
+    "    mcr    p15, 0, %0, c1, c0, 0\n"
+    "    mrc    p15, 0, %0, c1, c0, 1\n"
+    "    orr    %0, %0, #0x20\n"
+    "    mcr    p15, 0, %0, c1, c0, 1\n"
+      : "=&r" (v)
+      :
+      : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu)
+{
+    /*
+     * there is no power-control hardware on this platform, so all
+     * we can do is put the core into WFI; this is safe as the calling
+     * code will have already disabled interrupts
+     */
+    for (;;) {
+        /*
+         * here's the WFI
+         */
+        asm(".word    0xe320f003\n"
+            :
+            :
+            : "memory", "cc");
+
+        if (pen_release == cpu) {
+            /*
+             * OK, proper wakeup, we're done
+             */
+            break;
+        }
+
+        /*
+         * getting here, means that we have come out of WFI without
+         * having been woken up - this shouldn't happen
+         *
+         * The trouble is, letting people know about this is not really
+         * possible, since we are currently running incoherently, and
+         * therefore cannot safely call printk() or anything else
+         */
+#ifdef DEBUG
+        printk("CPU%u: spurious wakeup call\n", cpu);
+#endif
+    }
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+    return wait_for_completion_timeout(&cpu_killed, 5000);
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+#ifdef DEBUG
+    unsigned int this_cpu = hard_smp_processor_id();
+
+    if (cpu != this_cpu) {
+        printk(KERN_CRIT "Eek! platform_cpu_die running on %u, should be %u\n",
+               this_cpu, cpu);
+        BUG();
+    }
+#endif
+
+    printk(KERN_NOTICE "CPU%u: shutdown\n", cpu);
+    complete(&cpu_killed);
+
+    /*
+     * we're ready for shutdown now, so do it
+     */
+    cpu_enter_lowpower();
+    platform_do_lowpower(cpu);
+
+    /*
+     * bring this CPU back into the world of cache
+     * coherency, and then restore interrupts
+     */
+    cpu_leave_lowpower();
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+    /*
+     * we don't allow CPU 0 to be shutdown (it is still too special
+     * e.g. clock tick interrupts)
+     */
+    return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/plat-iproc/include/mach/brcm_rdb_rng.h b/arch/arm/plat-iproc/include/mach/brcm_rdb_rng.h
new file mode 100644
index 0000000..40d008d
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/brcm_rdb_rng.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __BRCM_RDB_RNG_H__
+#define __BRCM_RDB_RNG_H__
+
+#define RNG_CTRL_OFFSET                                                   0x00000000
+#define RNG_CTRL_TYPE                                                     UInt32
+#define RNG_CTRL_RESERVED_MASK                                            0xF00000CC
+#define    RNG_CTRL_RNG_COMBLK2_OSC_DIS_SHIFT                             22
+#define    RNG_CTRL_RNG_COMBLK2_OSC_DIS_MASK                              0x0FC00000
+#define    RNG_CTRL_RNG_COMBLK1_OSC_DIS_SHIFT                             16
+#define    RNG_CTRL_RNG_COMBLK1_OSC_DIS_MASK                              0x003F0000
+#define    RNG_CTRL_RNG_JCLK_BYP_DIV_CNT_SHIFT                            8
+#define    RNG_CTRL_RNG_JCLK_BYP_DIV_CNT_MASK                             0x0000FF00
+#define    RNG_CTRL_RNG_JCLK_BYP_SRC_SHIFT                                5
+#define    RNG_CTRL_RNG_JCLK_BYP_SRC_MASK                                 0x00000020
+#define    RNG_CTRL_RNG_JCLK_BYP_SEL_SHIFT                                4
+#define    RNG_CTRL_RNG_JCLK_BYP_SEL_MASK                                 0x00000010
+#define    RNG_CTRL_RNG_RBG2X_SHIFT                                       1
+#define    RNG_CTRL_RNG_RBG2X_MASK                                        0x00000002
+#define    RNG_CTRL_RNG_RBGEN_SHIFT                                       0
+#define    RNG_CTRL_RNG_RBGEN_MASK                                        0x00000001
+
+#define RNG_STATUS_OFFSET                                                 0x00000004
+#define RNG_STATUS_TYPE                                                   UInt32
+#define RNG_STATUS_RESERVED_MASK                                          0x00F00000
+#define    RNG_STATUS_RND_VAL_SHIFT                                       24
+#define    RNG_STATUS_RND_VAL_MASK                                        0xFF000000
+#define    RNG_STATUS_RNG_WARM_CNT_SHIFT                                  0
+#define    RNG_STATUS_RNG_WARM_CNT_MASK                                   0x000FFFFF
+
+#define RNG_DATA_OFFSET                                                   0x00000008
+#define RNG_DATA_TYPE                                                     UInt32
+#define RNG_DATA_RESERVED_MASK                                            0x00000000
+#define    RNG_DATA_RNG_NUM_SHIFT                                         0
+#define    RNG_DATA_RNG_NUM_MASK                                          0xFFFFFFFF
+
+#define RNG_FF_THRES_OFFSET                                               0x0000000C
+#define RNG_FF_THRES_TYPE                                                 UInt32
+#define RNG_FF_THRES_RESERVED_MASK                                        0xFFFFFFE0
+#define    RNG_FF_THRES_RNG_FF_THRESH_SHIFT                               0
+#define    RNG_FF_THRES_RNG_FF_THRESH_MASK                                0x0000001F
+
+#define RNG_INT_MASK_OFFSET                                               0x00000010
+#define RNG_INT_MASK_TYPE                                                 UInt32
+#define RNG_INT_MASK_RESERVED_MASK                                        0xFFFFFFFE
+#define    RNG_INT_MASK_RNG_INT_OFF_SHIFT                                 0
+#define    RNG_INT_MASK_RNG_INT_OFF_MASK                                  0x00000001
+
+#endif /* __BRCM_RDB_RNG_H__ */
diff --git a/arch/arm/plat-iproc/include/mach/bridge-regs.h b/arch/arm/plat-iproc/include/mach/bridge-regs.h
new file mode 100644
index 0000000..a781a05
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/bridge-regs.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Mbus-L to Mbus Bridge Registers
+ *
+ */
+
+#ifndef __ASM_ARCH_BRIDGE_REGS_H
+#define __ASM_ARCH_BRIDGE_REGS_H
+
+#include <mach/iproc.h>
+
+#define CPU_CONFIG		(BRIDGE_VIRT_BASE | 0x0000)
+
+#define CPU_CONTROL		(BRIDGE_VIRT_BASE | 0x0104)
+#define  CPU_CTRL_PCIE0_LINK	0x00000001
+#define  CPU_RESET		0x00000002
+#define  CPU_CTRL_PCIE1_LINK	0x00000008
+
+#define RSTOUTn_MASK		(BRIDGE_VIRT_BASE | 0x0108)
+#define  SOFT_RESET_OUT_EN	0x00000004
+
+#define SYSTEM_SOFT_RESET	(BRIDGE_VIRT_BASE | 0x010c)
+#define  SOFT_RESET		0x00000001
+
+#define BRIDGE_CAUSE		(BRIDGE_VIRT_BASE | 0x0110)
+#define BRIDGE_MASK		(BRIDGE_VIRT_BASE | 0x0114)
+#define  BRIDGE_INT_TIMER0	0x0002
+#define  BRIDGE_INT_TIMER1	0x0004
+#define  BRIDGE_INT_TIMER1_CLR	(~0x0004)
+
+#define IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0200)
+#define IRQ_CAUSE_LOW_OFF	0x0000
+#define IRQ_MASK_LOW_OFF	0x0004
+#define FIQ_MASK_LOW_OFF	0x0008
+#define ENDPOINT_MASK_LOW_OFF	0x000c
+#define IRQ_CAUSE_HIGH_OFF	0x0010
+#define IRQ_MASK_HIGH_OFF	0x0014
+#define FIQ_MASK_HIGH_OFF	0x0018
+#define ENDPOINT_MASK_HIGH_OFF	0x001c
+#define PCIE_INTERRUPT_MASK_OFF	0x0020
+
+#define IRQ_MASK_LOW		(IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF)
+#define FIQ_MASK_LOW		(IRQ_VIRT_BASE + FIQ_MASK_LOW_OFF)
+#define ENDPOINT_MASK_LOW	(IRQ_VIRT_BASE + ENDPOINT_MASK_LOW_OFF)
+#define IRQ_MASK_HIGH		(IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF)
+#define FIQ_MASK_HIGH		(IRQ_VIRT_BASE + FIQ_MASK_HIGH_OFF)
+#define ENDPOINT_MASK_HIGH	(IRQ_VIRT_BASE + ENDPOINT_MASK_HIGH_OFF)
+#define PCIE_INTERRUPT_MASK	(IRQ_VIRT_BASE + PCIE_INTERRUPT_MASK_OFF)
+
+#define POWER_MANAGEMENT	(BRIDGE_VIRT_BASE | 0x011c)
+
+#define TIMER_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0300)
+
+#endif
diff --git a/arch/arm/plat-iproc/include/mach/clkdev.h b/arch/arm/plat-iproc/include/mach/clkdev.h
new file mode 100644
index 0000000..988cfb8
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/clkdev.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __MACH_CLKDEV_H
+#define __MACH_CLKDEV_H
+
+#include <asm/atomic.h>
+#include <mach/clock.h>
+
+struct clk {
+	const struct clk_ops 	*ops;
+	const char 		*name;
+	atomic_t		ena_cnt;
+	atomic_t		use_cnt;
+	unsigned long		rate;
+	unsigned		gated :1;
+	unsigned		fixed :1;
+	unsigned		chan  :6;
+	void __iomem 		*regs_base;
+	struct clk 		*parent;
+	/* TBD: could it have multiple parents to select from ? */
+	enum {
+		CLK_XTAL, CLK_GATE, CLK_PLL, CLK_DIV, CLK_PHA
+	} type;
+};
+
+extern int __clk_get(struct clk *);
+extern void __clk_put(struct clk *);
+
+#endif
diff --git a/arch/arm/plat-iproc/include/mach/clock.h b/arch/arm/plat-iproc/include/mach/clock.h
new file mode 100644
index 0000000..7c896c5
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/clock.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef CLOCK_H
+#define CLOCK_H
+
+#include <linux/clk.h>
+
+/*
+ * Operations on clocks -
+ * See <linux/clk.h> for description
+ */
+struct clk_ops {
+	int	(* enable)(struct clk *);
+	void	(* disable)(struct clk *);
+	long	(* round)(struct clk *, unsigned long);
+	int	(* setrate)(struct clk *, unsigned long);
+	/* Update current rate and return running status */
+	int	(* status)(struct clk *);
+};
+
+#endif
diff --git a/arch/arm/plat-iproc/include/mach/common.h b/arch/arm/plat-iproc/include/mach/common.h
new file mode 100644
index 0000000..2cd0a65
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/common.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ *
+ * Core functions for Broadcom Northstar SoC Chip
+ */
+
+#ifndef __ARCH_IPROC_COMMON_H
+#define __ARCH_IPROC_COMMON_H
+
+struct mv643xx_eth_platform_data;
+struct mv_sata_platform_data;
+
+extern struct sys_timer IPROC_timer;
+extern struct mbus_dram_target_info iproc_mbus_dram_info;
+
+/*
+ * Basic IPROC init functions used early by machine-setup.
+ */
+void IPROC_map_io(void);
+void IPROC_init(void);
+void IPROC_init_irq(void);
+void IPROC_setup_cpu_mbus(void);
+void IPROC_ge00_init(struct mv643xx_eth_platform_data *eth_data);
+void IPROC_sata_init(struct mv_sata_platform_data *sata_data);
+void IPROC_pcie_init(int init_port0, int init_port1);
+void IPROC_ehci0_init(void);
+void IPROC_ehci1_init(void);
+void IPROC_uart0_init(void);
+void IPROC_uart1_init(void);
+void IPROC_uart2_init(void);
+void IPROC_uart3_init(void);
+void IPROC_spi0_init(void);
+void IPROC_spi1_init(void);
+void IPROC_i2c_init(void);
+
+#endif
diff --git a/arch/arm/plat-iproc/include/mach/debug-macro.S b/arch/arm/plat-iproc/include/mach/debug-macro.S
new file mode 100644
index 0000000..36d5f66
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/debug-macro.S
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Debugging macro include header
+ */
+#include <mach/io_map.h>
+#include <mach/memory.h>
+#include <asm/pgtable.h>
+
+	.macro addruart,  tmp, tmp2, rx
+	ldr	\tmp, =IPROC_UART_LLDEBUG_PA 		@ MMU off, Physical
+	ldr	\tmp2, =IPROC_UART_LLDEBUG_VA		@ MMU on, Virtual
+	.endm
+
+#define UART_SHIFT      0       //for CCA_UART has byte offset
+
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/plat-iproc/include/mach/entry-macro.S b/arch/arm/plat-iproc/include/mach/entry-macro.S
new file mode 100644
index 0000000..7b567df
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/entry-macro.S
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <mach/io_map.h>
+
+	.macro	disable_fiq
+	.endm
+
+	/*
+	 * This is the interrupt handling part of the GIC code -
+	 * the base_va exists in a variable, but here is defined
+	 * at compile time for effeciency (?)
+	 */
+
+	.macro  get_irqnr_preamble, base, tmp
+	ldr	\base, =IPROC_GICCPU_VA
+	.endm
+
+	/*
+	 * Interrupts 0-15 are IPI
+	 * 16-31 are local
+	 * 32-1020 are global
+	 * 1021-1022 are reserved
+	 * 1023 is "spurious" (no interrupt)
+	 *
+	 * Spurious interrupt must be ignored in all events.
+	 * When in SMP mode, then IPI interrupts must be ignored here,
+	 * amd picked up later with the test_for_ipi macro.
+	 * When in SMP mode and local timers are enabled,
+	 * the private timer/watchdog interrupt must be ignored here
+	 * so it can be handled later in test_for_ltirq routine.
+	 *
+	 * A simple read from the controller will tell us the number of the
+	 * highest priority enabled interrupt.  We then just need to check
+	 * whether it is in the range that must be handled.
+	 *
+	 * Upon return, Z=1 tells to ignore this interrupt
+	 */
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+
+	/* bits 12-10 = src CPU, 9-0 = int # */
+	ldr     \irqstat, [\base, #GIC_CPU_INTACK]
+	ldr	\tmp, =1021
+
+	bic     \irqnr, \irqstat, #0x1c00
+
+	/* Private timers to call do_local_timer() */
+	cmp	\irqnr, #29
+	beq	29f
+    
+	/* SPI to call asm_do_IRQ(); IPI to call do_IPI() */
+	cmp	\irqnr, #15
+	cmpcc	\irqnr, \irqnr
+	cmpne	\irqnr, \tmp
+	cmpcs	\irqnr, \irqnr
+
+	/* SPI if NE; IPI (0-15) or private timer (29) if EQ */
+29:
+	.endm
+
+	@code taken from realview/entry-macro.S
+	/* We assume that irqstat (the raw value of the IRQ acknowledge
+	 * register) is preserved from the macro above.
+	 * If there is an IPI, we immediately signal end of interrupt on the
+	 * controller, since this requires the original irqstat value which
+	 * we won't easily be able to recreate later.
+	 */
+	.macro	test_for_ipi, irqnr, irqstat, base, tmp
+	bic	\irqnr, \irqstat, #0x1c00
+	cmp	\irqnr, #16
+	strcc	\irqstat, [\base, #GIC_CPU_EOI]
+	cmpcs	\irqnr, \irqnr
+	.endm
+
+	.macro	test_for_ltirq, irqnr, irqstat, base,tmp
+	bic	\irqnr, \irqstat, #0x1c00
+	mov	\tmp, #0
+	cmp	\irqnr, #29
+	moveq	\tmp, #1
+	streq	\irqstat, [\base, #GIC_CPU_EOI]
+	cmp	\tmp, #0
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
diff --git a/arch/arm/plat-iproc/include/mach/gpio.h b/arch/arm/plat-iproc/include/mach/gpio.h
new file mode 100644
index 0000000..da7f79e
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/gpio.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_GPIO_H
+#define __PLAT_GPIO_H
+
+#include <mach/iproc_regs.h>
+#include <mach/irqs.h>
+
+#include <asm-generic/gpio.h>
+
+
+#define gpio_to_irq(gpio)           __gpio_to_irq(gpio)
+//#define gpio_get_value(gpio)		__gpio_get_value(gpio)
+//#define gpio_set_value(gpio,value)  __gpio_set_value(gpio,value)
+//#define gpio_cansleep(gpio)		   __gpio_cansleep(gpio)
+
+#endif
diff --git a/arch/arm/plat-iproc/include/mach/hardware.h b/arch/arm/plat-iproc/include/mach/hardware.h
new file mode 100644
index 0000000..5a89db0
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/hardware.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_HARDWARE_H
+#define __PLAT_IPROC_HARDWARE_H
+
+#include <asm/sizes.h>
+#include <mach/memory.h>
+#include <mach/io_map.h>
+
+/* Hardware addresses of major areas.
+ *  *_START is the physical address
+ *  *_SIZE  is the size of the region
+ *  *_BASE  is the virtual address
+ */
+#define RAM_START		PHYS_OFFSET
+
+#define RAM_BASE		PAGE_OFFSET
+
+#define IO_START IO_START_PA
+#define IO_BASE  IO_START_VA
+
+#define pcibios_assign_all_busses() 1
+
+#define PCIBIOS_MIN_IO			0x1000
+#define PCIBIOS_MIN_MEM			0x01000000
+
+#endif /* __PLAT_IPROC_HARDWARE_H */
diff --git a/arch/arm/plat-iproc/include/mach/io.h b/arch/arm/plat-iproc/include/mach/io.h
new file mode 100644
index 0000000..59a1ad4
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/io.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_IO_H
+#define __PLAT_IPROC_IO_H
+
+//#define IO_SPACE_LIMIT		(0xffffffff)
+
+//#define __io(a)			__typesafe_io(a)
+#define __mem_pci(a)		(a)
+
+//#ifdef __ASSEMBLER__
+//#define IOMEM(x)		(x)
+//#else
+//#define IOMEM(x)		((void __force __iomem *)(x))
+//#endif
+
+#define VC_DIRECT_ACCESS_BASE		0xC0000000UL
+#define ARM_VC_PHYS_ADDR_BASE		0x40000000UL
+#define __VC_BUS_TO_ARM_PHYS_ADDR(x)	((x) - (VC_DIRECT_ACCESS_BASE) + \
+                                        (ARM_VC_PHYS_ADDR_BASE))
+
+#endif /*__PLAT_IPROC_IO_H */
diff --git a/arch/arm/plat-iproc/include/mach/iproc.h b/arch/arm/plat-iproc/include/mach/iproc.h
new file mode 100644
index 0000000..01cd7be
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/iproc.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_H
+#define __PLAT_IPROC_H
+
+#include <asm/mach/time.h>
+
+extern struct sys_timer iproc_timer;
+
+extern void __init iproc_init_irq(void);
+//static void __init gic_dist_init(struct gic_chip_data *gic);
+
+#endif /* __PLAT_IPROC_H */
diff --git a/arch/arm/plat-iproc/include/mach/iproc_timer.h b/arch/arm/plat-iproc/include/mach/iproc_timer.h
new file mode 100644
index 0000000..ab40994
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/iproc_timer.h
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_TIMER_H
+#define __PLAT_IPROC_TIMER_H
+
+/* Timer module specific data structures */
+enum timer_rate {
+    KHZ_32 = 0,
+    MHZ_1,
+    MHZ_19_5,
+};
+
+struct iproc_timer;
+
+/* Channel specific data structures */
+typedef int (*intr_callback)(void *data);
+
+enum timer_mode {
+    MODE_PERIODIC=0,
+    MODE_ONESHOT,
+};
+
+struct timer_ch_cfg {
+    void *arg;
+    enum timer_mode mode;
+    intr_callback cb;
+    unsigned long reload;    /* Holds the reload value in 
+                 * case of periodic timers 
+                 */
+};
+
+/* Timer Module related APIs */
+
+/*
+ * USAGE OF THIS APIs
+ * ------------------
+ * From the board specific file, the iproc_timer_modules_init will be called 
+ * After that it will call the init function of timer.c and will pass the
+ * following information in a platform structure
+ * 1) Timer name to be used as system timer
+ * 2) Frequency to be configured for system timer
+ * 3) The channel of the timer to use as clock source (optional)
+ * 4) The channel of the timer to use as clock event (optional)
+ *
+ * from the init function of timer.c iproc_timer_modules_set_rate will be called
+ * to set the system timer frequency. 
+ * Then the appropriate channels would be setup for clock source/event by 
+ * calling iproc_timer_request()
+ */
+
+/*
+ *  iproc_timer_modules_init - Initialize the data structures
+ *  that depcits the iProc timer modules
+ */
+void iproc_timer_modules_init (void);
+
+/*
+ * iproc_timer_module_set_rate - Set the speed in which a timer module should count
+ * name - Name of the Timer to configure
+ * rate - Speed 
+ */
+int iproc_timer_module_set_rate(char* name, enum timer_rate);
+
+/* 
+ * iproc_timer_module_get_rate - Get the speed in which a timer module is running
+ * name - Name of the Timer module 
+ */
+int iproc_timer_module_get_rate (char* name);
+
+
+/* Channel/Timer related APIs */
+/*
+ *  iproc_timer_request - Get access to a channel in the given timer
+ *  name - Name of the Timer module
+ *  channel - Channel number requested. If this is -1 then by default
+ *            the next available channel will be returned
+ */
+struct iproc_timer* iproc_timer_request(char* name, int channel);
+
+/*
+ *  iproc_timer_config - Configure the following parameters of the timer
+ *  1) mode of the timer - periodic/one shot
+ *  2) call back function that will be called from the ISR context
+ *  3) context to be passed back in the call back function
+ *
+ *  pit - iProc timer context (returned by iproc_timer_request())
+ *  pcfg - pointer to the configuration structure
+ */
+int iproc_timer_config (struct iproc_timer *pit, struct timer_ch_cfg *pcfg);  
+
+/*
+ * iproc_timer_set_match_start - Set the match register for the timer and start
+ * counting
+ *
+ *  pit - iProc timer context (returned by iproc_timer_request())
+ *  load - The load value to be programmed. This function will internally
+ *         add this value to the current counter and program the resultant in the
+ *         match register. Once the timer is started when the counter 
+ *         reaches this value an interrupt will be raised
+ */
+int iproc_timer_set_match_start (struct iproc_timer* pit, unsigned int load);
+
+/*
+ * iproc_timer_free - Read the counter register of the timer 
+ *
+ * pit - Timer context to be freed.
+ * msw - pointer to the Most Significant Word (32 bits) 
+ * lsw - pointer to the Leas Significant Word (32 bits) 
+ */
+int iproc_timer_get_counter(struct iproc_timer* pit, 
+                            unsigned long *msw, unsigned long *lsw);
+/*
+ * iproc_timer_disable_and_clear - Disable the timer and clear the 
+ * interrupt
+ *
+ * pit - Timer context to be freed.
+ */
+int iproc_timer_disable_and_clear(struct iproc_timer *pit);
+
+/*
+ * iproc_timer_stop  - Stop the timer.
+ *
+ * pit - The timer context to be stopped.
+ */
+int iproc_timer_stop (struct iproc_timer* pit);
+
+/*
+ * iproc_timer_free - Release the timer, after this call the timer can be used
+ * again by others.
+ *
+ * pit - Timer context to be freed.
+ */
+int iproc_timer_free (struct iproc_timer* pit);
+
+#endif /* __PLAT_IPROC_TIMER_H */
diff --git a/arch/arm/plat-iproc/include/mach/irqs.h b/arch/arm/plat-iproc/include/mach/irqs.h
new file mode 100644
index 0000000..82aacd5
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/irqs.h
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_IRQS_H
+#define __PLAT_IPROC_IRQS_H
+
+#define BCM_INT_PRIORITY_MAX  32  /* there are only 32 priority are supported */
+#define BCM_INT_SPI_MAX       128 /* there are 128 shared peripheral interrupt*/
+/*=====================================================================*/
+/* Software Trigger Interrupt IDs                                      */
+/*=====================================================================*/
+#define BCM_INT_ID_STI0                 0
+#define BCM_INT_ID_STI1                 1
+#define BCM_INT_ID_STI2                 2
+#define BCM_INT_ID_STI3                 3
+#define BCM_INT_ID_STI4                 4
+#define BCM_INT_ID_STI5                 5
+#define BCM_INT_ID_STI6                 6
+#define BCM_INT_ID_STI7                 7
+#define BCM_INT_ID_STI8                 8
+#define BCM_INT_ID_STI9                 9
+#define BCM_INT_ID_STI10                10
+#define BCM_INT_ID_STI11                11
+#define BCM_INT_ID_STI12                12
+#define BCM_INT_ID_STI13                13
+#define BCM_INT_ID_STI14                14
+#define BCM_INT_ID_STI15                15
+#define BCM_INT_ID_STI_MAX              16 /* terminating ID */
+
+/*=====================================================================*/
+/* Private Peripheral Interrupt IDs                                    */
+/*=====================================================================*/
+#define BCM_INT_ID_PPI0                 ( 0 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI1                 ( 1 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI2                 ( 2 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI3                 ( 3 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI4                 ( 4 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI5                 ( 5 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI6                 ( 6 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI7                 ( 7 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI8                 ( 8 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI9                 ( 9 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI10                (10 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI11                (11 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI12                (12 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI13                (13 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI14                (14 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI15                (15 + BCM_INT_ID_STI_MAX)
+#define BCM_INT_ID_PPI_MAX              (16 + BCM_INT_ID_STI_MAX) /* terminating ID */
+
+/*=====================================================================*/
+/* iHost Interrupt IDs                                                 */
+/*=====================================================================*/
+#define BCM_INT_ID_IHOST_L2CC           32
+#define BCM_INT_ID_IHOST_PWRWDOG        33
+#define BCM_INT_ID_IHOST_TRAP8          34
+#define BCM_INT_ID_IHOST_TRAP1          35
+#define BCM_INT_ID_IHOST_COMMTX         36
+#define BCM_INT_ID_IHOST_COMMRX         38
+#define BCM_INT_ID_IHOST_PMU            40
+#define BCM_INT_ID_IHOST_CT             42
+#define BCM_INT_ID_IHOST_DEFFLG_CPU0    44
+#define BCM_INT_ID_IHOST_DEFFLG_CPU1    45
+#define BCM_INT_ID_IHOST_MAX            46 /* terminating ID */
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+#define BCM_INT_ID_IHOST_CPU0_PAR		46
+#define BCM_INT_ID_IHOST_CPU1_PAR	    47
+#define BCM_INT_ID_IHOST_SCU0_PAR		48
+#define BCM_INT_ID_IHOST_SCU1_PAR	    49
+#define BCM_INT_ID_IHOST_I2_SEC			50
+#endif
+
+/*=====================================================================*/
+/* IDM Interrupt IDs                                                   */
+/*=====================================================================*/
+#define BCM_INT_ID_IHOST_M1             ( 0 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE0_M0             ( 1 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE1_M0             ( 2 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE2_M0             ( 3 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DMA_M0               ( 4 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_AMAC_M0              ( 5 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_AMAC_M1              ( 6 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_AMAC_M2              ( 7 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_AMAC_M3              ( 8 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_USBH_M0              ( 9 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_USBH_M1              (10 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_SDIO_M0              (11 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_I2S_M0               (12 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_A9JTAG_M0            (13 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_INIT_SEQ_M0          (14 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_JTAG_M0              (15 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_IHOST_ACP            (16 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_IHOST_S0             (17 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DDR_S1               (18 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DDR_S2               (19 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE0_S0             (20 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE1_S0             (21 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_PCIE2_S0             (22 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_ROM_S0               (23 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_NAND_S0              (24 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_QPSI_S0              (25 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_A9JTAG_S0            (26 + BCM_INT_ID_IHOST_MAX)
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+#define BCM_INT_ID_SATA_S0				(27 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_SRAM_S0              (28+ BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_APBW					(29 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_APBX					(30 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_APBY					(31 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_APBZ					(32 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_0                 (33 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_1                 (34 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_2                 (35 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_3                 (36 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_4                 (37 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_IDM_MAX              (38 + BCM_INT_ID_IHOST_MAX)
+#elif defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+#define BCM_INT_ID_APBX                 (27 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_0                 (28 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_1                 (29 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_2                 (30 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_3                 (31 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_DS_4                 (32 + BCM_INT_ID_IHOST_MAX)
+#define BCM_INT_ID_IDM_MAX              (33 + BCM_INT_ID_IHOST_MAX)
+#endif
+
+/*=====================================================================*/
+/* DDR Interrupt IDs                                                   */
+/*=====================================================================*/
+#define BCM_INT_ID_DDR_CONT             (0 + BCM_INT_ID_IDM_MAX)
+#define BCM_INT_ID_DDR_MAX              (1 + BCM_INT_ID_IDM_MAX)
+
+/*=====================================================================*/
+/* DMAC Interrupt IDs                                                  */
+/*=====================================================================*/
+#define BCM_INT_ID_DMAC                 (0 + BCM_INT_ID_DDR_MAX)
+#if defined(CONFIG_MACH_HX4) || defined(CONFIG_MACH_KT2)
+#define BCM_INT_ID_DMAC_ABORT           (16 + BCM_INT_ID_DDR_MAX)
+#define BCM_INT_ID_DMAC_MAX             (17 + BCM_INT_ID_DDR_MAX)
+#elif defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+#define BCM_INT_ID_DMAC_MAX             (16 + BCM_INT_ID_DDR_MAX)
+#endif
+
+/*=====================================================================*/
+/* NAND Interrupt IDs                                                  */
+/*=====================================================================*/
+#define BCM_INT_ID_NAND2CORE_RD_MISS         ( 0 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_ER_COMP         ( 1 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_CB_COMP         ( 2 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_PP_COMP         ( 3 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_ROCTL_RDY       ( 4 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_NAND_RBB        ( 5 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_ECC_MIPS_UNCOR  ( 6 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_ECC_MIPS_COR    ( 7 + BCM_INT_ID_DMAC_MAX)
+#define BCM_INT_ID_NAND2CORE_MAX             ( 8 + BCM_INT_ID_DMAC_MAX)
+
+/*=====================================================================*/
+/* QPSI Interrupt IDs                                                  */
+/*=====================================================================*/
+#define BCM_INT_ID_QPSI2CORE_FULL_RCHD        ( 0 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_TRUNCATED        ( 1 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_IMAPTIENT        ( 2 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_SES_DONE         ( 3 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_OVERREAD         ( 4 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_MPSI_DONE        ( 5 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_MPSI_HLT_SET     ( 6 + BCM_INT_ID_NAND2CORE_MAX)
+#define BCM_INT_ID_QPSI2CORE_MAX              ( 7 + BCM_INT_ID_NAND2CORE_MAX)
+
+/*=====================================================================*/
+/* USB2 Host Interrupt IDs                                             */
+/*=====================================================================*/
+#define BCM_INT_ID_USB2H2CORE_USB2_INT  (0 + BCM_INT_ID_QPSI2CORE_MAX)
+#define BCM_INT_ID_USB2H2CORE_MAX       (1 + BCM_INT_ID_QPSI2CORE_MAX)
+
+/*=====================================================================*/
+/* USB3 Host Interrupt IDs                                             */
+/*=====================================================================*/
+#define BCM_INT_ID_USB3H2CORE_USB2_INT0  (0 + BCM_INT_ID_USB2H2CORE_MAX)
+#define BCM_INT_ID_USB3H2CORE_USB2_INT1  (1 + BCM_INT_ID_USB2H2CORE_MAX)
+#define BCM_INT_ID_USB3H2CORE_USB2_INT2  (2 + BCM_INT_ID_USB2H2CORE_MAX)
+#define BCM_INT_ID_USB3H2CORE_USB2_INT3  (3 + BCM_INT_ID_USB2H2CORE_MAX)
+#define BCM_INT_ID_USB3H2CORE_USB2_HSE   (4 + BCM_INT_ID_USB2H2CORE_MAX)
+#define BCM_INT_ID_USB3H2CORE_MAX        (5 + BCM_INT_ID_USB2H2CORE_MAX)
+
+/*=====================================================================*/
+/* CCA Interrupt IDs                                                   */
+/*=====================================================================*/
+#define BCM_INT_ID_CCA_INT   (0 + BCM_INT_ID_USB3H2CORE_MAX)
+#define BCM_INT_ID_CCA_MAX   (1 + BCM_INT_ID_USB3H2CORE_MAX)
+
+/*=====================================================================*/
+/* CCB Interrupt IDs                                                   */
+/*=====================================================================*/
+#define BCM_INT_ID_CCB_UART0       (0 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_GPIO        (1 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_I2S         (2 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_SMBUS       (3 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_TIM0_INT1   (4 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_TIM0_INT2   (5 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_TIM1_INT1   (6 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_TIM1_INT2   (7 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_RNG         (8 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_SW_SOC      (9 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_PCIE_INT0   (10 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_PCIE_INT1   (11 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_PCIE_INT2   (12 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_SDIO2CORE   (13 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_CTF         (14 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_GMAC_INT0   (15 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_GMAC_INT1   (16 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_GMAC_INT2   (17 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_GMAC_INT3   (18 + BCM_INT_ID_CCA_MAX)
+#define BCM_INT_ID_CCB_MAX         (19 + BCM_INT_ID_CCA_MAX)
+
+#define BCM_INT_ID_FA		   178
+
+
+#ifdef CONFIG_ARCH_REQUIRE_GPIOLIB
+#define IPROC_NR_IRQS           (256)
+#define IPROC_IRQ_GPIO_0        (IPROC_NR_IRQS)
+#define IPROC_NR_GPIO_IRQS      (32 + 4)
+#define NR_IRQS                 (IPROC_NR_IRQS + IPROC_NR_GPIO_IRQS)
+#else 
+#define NR_IRQS               256
+#endif
+
+#endif /* __PLAT_IPROC_IRQS_H */
diff --git a/arch/arm/plat-iproc/include/mach/lm.h b/arch/arm/plat-iproc/include/mach/lm.h
new file mode 100644
index 0000000..452b4ab
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/lm.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LM_DEVICE_H_
+#define _LM_DEVICE_H_
+
+#include <linux/device.h>
+#include <linux/ioport.h>
+
+
+struct lm_device {
+	struct device dev;
+	struct resource resource;
+	unsigned int irq;
+	unsigned int id;
+};
+
+struct lm_driver {
+	struct device_driver drv;
+	int (*probe) (struct lm_device *);
+	void (*remove) (struct lm_device *);
+	int (*suspend) (struct lm_device *, pm_message_t);
+	int (*resume) (struct lm_device *);
+};
+
+int lm_driver_register(struct lm_driver *drv);
+void lm_driver_unregister(struct lm_driver *drv);
+
+int lm_device_register(struct lm_device *dev);
+void lm_device_unregister(struct lm_device *dev);
+
+#define lm_get_drvdata(lm)	dev_get_drvdata(&(lm)->dev)
+#define lm_set_drvdata(lm,d)	dev_set_drvdata(&(lm)->dev, d)
+
+#endif /* _LM_DEVICE_H_ */
diff --git a/arch/arm/plat-iproc/include/mach/memory.h b/arch/arm/plat-iproc/include/mach/memory.h
new file mode 100644
index 0000000..a6c7240
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/memory.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __PLAT_IPROC_MEMORY_H
+#define __PLAT_IPROC_MEMORY_H
+
+#include <asm/pgtable.h>
+
+/* BCM5301x Reference Guide (Section 3) defines three regions of IO  memory, 
+ * CORE, IDM, and ARMCORE. The CORE and IDM regions are contiguous, so they 
+ * are combined into a single region for mapping and translation purposes
+ */
+
+#define IO_CORE_IDM_PA		0x18000000
+#define IO_CORE_IDM_SIZE	  0x200000
+#define IO_ARMCORE_PA		0x19000000
+#define IO_ARMCORE_SIZE		  0x100000
+
+#define IO_CORE_IDM_VA		VMALLOC_END
+#define IO_ARMCORE_VA		(IO_CORE_IDM_VA + IO_CORE_IDM_SIZE)
+
+#define IO_CORE_IDM_PV_DELTA	(IO_CORE_IDM_VA - IO_CORE_IDM_PA)
+#define IO_ARMCORE_PV_DELTA	(IO_ARMCORE_VA  - IO_ARMCORE_PA)
+
+#define HW_IO_VIRT_TO_PHYS(virt)			\
+	(((virt) < IO_ARMCORE_VA) ?			\
+	 ((virt) - IO_CORE_IDM_PV_DELTA) :		\
+	 ((virt) - IO_ARMCORE_PV_DELTA))
+
+/* 
+ * HW_IO_PHYS_TO_VIRT used in asm, so the macro that performs this conversion
+ * is written using only simple math so that the assembler's constant folding
+ * can produce the correct result.
+
+	#define HW_IO_PHYS_TO_VIRT(phys)		\
+	    (((phys) < IO_ARMCORE_PA) ?			\
+	     ((phys) + IO_CORE_IDM_PV_DELTA) :		\
+	     ((phys) + IO_ARMCORE_PV_DELTA))
+ */
+
+#define HW_IO_PHYS_TO_VIRT(phys) 			\
+	(((phys) + IO_CORE_IDM_PV_DELTA) + 		\
+	 ((((phys)/IO_ARMCORE_PA)) * (IO_ARMCORE_PV_DELTA - IO_CORE_IDM_PV_DELTA)))
+
+#define CONSISTENT_DMA_SIZE SZ_128M
+
+#ifndef PHYS_RAM_SIZE
+#define PHYS_RAM_SIZE	0x08000000
+#endif
+
+#endif /* __PLAT_IPROC_MEMORY_H */ 
diff --git a/arch/arm/plat-iproc/include/mach/sdio_platform.h b/arch/arm/plat-iproc/include/mach/sdio_platform.h
new file mode 100644
index 0000000..f9af294
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/sdio_platform.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _SDIO_PLATFORM_H
+#define _SDIO_PLATFORM_H
+
+/*
+ * SDIO device type
+ */
+enum sdio_devtype {
+	SDIO_DEV_TYPE_SDMMC = 0,
+	SDIO_DEV_TYPE_WIFI,
+	SDIO_DEV_TYPE_EMMC,
+
+	/* used for internal array indexing, DO NOT modify */
+	SDIO_DEV_TYPE_MAX,
+};
+
+/*
+ * SDIO WiFi GPIO configuration
+ */
+struct sdio_wifi_gpio_cfg {
+	int reset;
+	int shutdown;
+	int reg;
+	int host_wake;
+};
+
+struct sdio_platform_cfg {
+	/* specify which SDIO device */
+	unsigned id;
+
+	/*
+	* For boards without the SDIO pullup registers, data_pullup needs to set
+	* to 1
+	*/
+	unsigned int data_pullup;
+
+	/* for devices with 8-bit lines */
+	int is_8bit;
+
+	/* card detection GPIO, required for SD/MMC */
+	int cd_gpio;
+	enum sdio_devtype devtype;
+
+	/* clocks */
+	char *peri_clk_name;
+	char *ahb_clk_name;
+	char *sleep_clk_name;
+	unsigned long peri_clk_rate;
+
+	struct sdio_wifi_gpio_cfg wifi_gpio;
+};
+
+#endif  /* SDIO_PLATFORM_H */
diff --git a/arch/arm/plat-iproc/include/mach/smp.h b/arch/arm/plat-iproc/include/mach/smp.h
new file mode 100644
index 0000000..0a70b2a
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/smp.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * derived from arch/arm/mach-realview/include/mach/smp.h
+ */
+
+#ifndef __ASM_ARCH_SMP_H
+#define __ASM_ARCH_SMP_H __FILE__
+
+
+/*
+ * set_event() is used to wake up secondary core from wfe using sev. ROM
+ * code puts the second core into wfe(standby).
+ *
+ */
+#define set_event()	__asm__ __volatile__ ("sev" : : : "memory")
+
+extern void iproc_secondary_startup(void);
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#endif /* __ASM_ARCH_SMP_H */
diff --git a/arch/arm/plat-iproc/include/mach/system.h b/arch/arm/plat-iproc/include/mach/system.h
new file mode 100644
index 0000000..1692c88
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/system.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_IPROC_SYSTEM_H
+#define __PLAT_IPROC_SYSTEM_H
+
+#include <linux/io.h>
+#include <mach/io_map.h>
+
+
+static void arch_idle(void)
+{
+    /*
+     * This should do all the clock switching
+     * and wait for interrupt tricks
+     */
+    cpu_do_idle();
+}
+
+extern  void arch_reset(char mode, const char *cmd);
+
+#endif /*__PLAT_IPROC_SYSTEM_H */
diff --git a/arch/arm/plat-iproc/include/mach/timer.h b/arch/arm/plat-iproc/include/mach/timer.h
new file mode 100644
index 0000000..6ea72da
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/timer.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_TIMER_H
+#define __PLAT_TIMER_H
+
+#ifdef __KERNEL__
+
+typedef unsigned int timer_tick_count_t;
+typedef unsigned int timer_tick_rate_t;
+typedef unsigned int timer_msec_t;
+
+
+enum gp_timer_rate {
+    GPT_KHZ_32 = 0,
+    GPT_MHZ_1,
+};
+
+/**
+ * timer configuration identifying the timer to use
+ * as system timer (GP Timer)
+ */
+ struct gp_timer_setup {
+    char *name;
+    int ch_num;
+    enum gp_timer_rate rate;
+ };
+
+void iproc_timer_init (struct gp_timer_setup *gpt);
+
+timer_tick_count_t timer_get_tick_count(void);
+timer_tick_rate_t timer_get_tick_rate(void);
+timer_msec_t timer_get_msec(void);
+timer_msec_t timer_ticks_to_msec(timer_tick_count_t ticks);
+
+#endif /* __KERNEL__ */
+#endif /* __PLAT_TIMER_H */
diff --git a/arch/arm/plat-iproc/include/mach/timex.h b/arch/arm/plat-iproc/include/mach/timex.h
new file mode 100644
index 0000000..d8c5c51
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/timex.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef __PLAT_IPROC_TIMEX_H
+#define __PLAT_IPROC_TIMEX_H
+
+/*
+ * Not very sure what the clock rate is. Revisit later 
+*/
+#define CLOCK_TICK_RATE     (351875)
+
+#endif /* __PLAT_IPROC_TIMEX_H */
diff --git a/arch/arm/plat-iproc/include/mach/uncompress.h b/arch/arm/plat-iproc/include/mach/uncompress.h
new file mode 100644
index 0000000..c2c5be2
--- /dev/null
+++ b/arch/arm/plat-iproc/include/mach/uncompress.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef    __ASM_ARCH_UNCOMPRESS_H
+#define __ASM_ARCH_UNCOMPRESS_H
+
+#include <linux/io.h>
+#include <mach/io_map.h>
+
+#define IPROC_UART0_PA           IPROC_CCA_UART0_REG_BASE
+#define UART0_LSR_OFFSET         0x14
+#define UART0_RBR_THR_DLL_OFFSET 0x00
+#define UART0_LSR_THRE_MASK      0x60
+#define UART0_LSR_TEMT_MASK      0x40
+
+static inline void putc(int c)
+{
+    /*
+     * data should be written to THR register only 
+     * if THRE (LSR bit5) is set)
+     */
+    while (0 == (__raw_readl(IPROC_UART0_PA + 
+                             UART0_LSR_OFFSET) & UART0_LSR_THRE_MASK ))
+    {
+    }
+
+    __raw_writel((unsigned long)c, IPROC_UART0_PA + UART0_RBR_THR_DLL_OFFSET);
+}
+
+static inline void flush(void)
+{
+    /* Wait for the tx fifo to be empty and last char to be sent */
+    while (0 == (__raw_readl(IPROC_UART0_PA + 
+                             UART0_LSR_OFFSET) & UART0_LSR_TEMT_MASK ))
+    {
+    }
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#endif /* __ASM_ARCH_UNCOMPRESS_H */
diff --git a/arch/arm/plat-iproc/include/plat/dma-pl330.h b/arch/arm/plat-iproc/include/plat/dma-pl330.h
new file mode 100644
index 0000000..fdac2ea
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/dma-pl330.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __PLAT_DMA_H
+#define __PLAT_DMA_H
+
+#include <asm/scatterlist.h>
+
+#define MAX_CHAN_NAME_LENGTH	32
+
+/* DMA direction control */
+enum dma_direction {
+	DMA_DIRECTION_MEM_TO_MEM = 0,
+	DMA_DIRECTION_MEM_TO_DEV_FLOW_CTRL_DMAC = 1,
+	DMA_DIRECTION_MEM_TO_DEV_FLOW_CTRL_PERI = 2,
+	DMA_DIRECTION_DEV_TO_MEM_FLOW_CTRL_DMAC = 3,
+	DMA_DIRECTION_DEV_TO_MEM_FLOW_CTRL_PERI = 4,
+	DMA_DIRECTION_DEV_TO_DEV = 5	/* Invalid, unsupported */
+};
+#define DMA_DIRECTION_MASK	0x7
+
+/* Channel configurations definition */
+#define DMA_CFG_SRC_ADDR_FIXED				(0x0 << 0)
+#define DMA_CFG_SRC_ADDR_INCREMENT			(0x1 << 0)
+#define DMA_CFG_DST_ADDR_FIXED				(0x0 << 14)
+#define DMA_CFG_DST_ADDR_INCREMENT			(0x1 << 14)
+
+#define DMA_CFG_BURST_SIZE_MASK         (0x7 << 1)
+#define DMA_CFG_BURST_SIZE_1            (0x0 << 1)
+#define DMA_CFG_BURST_SIZE_2            (0x1 << 1)
+#define DMA_CFG_BURST_SIZE_4            (0x2 << 1)
+#define DMA_CFG_BURST_SIZE_8            (0x3 << 1)
+#define DMA_CFG_BURST_SIZE_16           (0x4 << 1)
+#define DMA_CFG_BURST_SIZE_32           (0x5 << 1)
+#define DMA_CFG_BURST_SIZE_64           (0x6 << 1)
+#define DMA_CFG_BURST_SIZE_128          (0x7 << 1)
+
+#define DMA_CFG_BURST_LENGTH_MASK       (0xF << 4)
+#define DMA_CFG_BURST_LENGTH_1           (0x0 << 4)
+#define DMA_CFG_BURST_LENGTH_2           (0x1 << 4)
+#define DMA_CFG_BURST_LENGTH_3           (0x2 << 4)
+#define DMA_CFG_BURST_LENGTH_4           (0x3 << 4)
+#define DMA_CFG_BURST_LENGTH_5           (0x4 << 4)
+#define DMA_CFG_BURST_LENGTH_6           (0x5 << 4)
+#define DMA_CFG_BURST_LENGTH_7           (0x6 << 4)
+#define DMA_CFG_BURST_LENGTH_8           (0x7 << 4)
+#define DMA_CFG_BURST_LENGTH_9           (0x8 << 4)
+#define DMA_CFG_BURST_LENGTH_10          (0x9 << 4)
+#define DMA_CFG_BURST_LENGTH_11          (0xA << 4)
+#define DMA_CFG_BURST_LENGTH_12          (0xB << 4)
+#define DMA_CFG_BURST_LENGTH_13          (0xC << 4)
+#define DMA_CFG_BURST_LENGTH_14          (0xD << 4)
+#define DMA_CFG_BURST_LENGTH_15          (0xE << 4)
+#define DMA_CFG_BURST_LENGTH_16          (0xF << 4)
+
+#define DMA_CFG_BURST_LEN(x)			(((x - 1) & 0xF) << 4)
+
+/* src and dest burst size and burst length are assumed to be same */
+
+enum pl330_xfer_status {
+	DMA_PL330_XFER_OK,
+	DMA_PL330_XFER_ERR,
+	DMA_PL330_XFER_ABORT,
+};
+
+struct dma_transfer_list {
+	dma_addr_t srcaddr;	/* src address */
+	dma_addr_t dstaddr;	/* dst address */
+	unsigned int xfer_size;	/* In bytes */
+	struct list_head next;	/* Next item */
+};
+
+typedef void (*pl330_xfer_callback_t) (void *private_data,
+				       enum pl330_xfer_status status);
+
+int dma_request_chan(unsigned int *chan, const char *name);
+int dma_free_chan(unsigned int chan);
+int dma_map_peripheral(unsigned int chan, const char *peri_name);
+int dma_unmap_peripheral(unsigned int chan);
+int dma_setup_transfer(unsigned int chan, dma_addr_t s, dma_addr_t d,
+		       unsigned int xfer_size, int ctrl, int cfg);
+int dma_setup_transfer_list(unsigned int chan, struct list_head *head,
+			    int ctrl, int cfg);
+int dma_start_transfer(unsigned int chan);
+int dma_stop_transfer(unsigned int chan);
+int dma_shutdown_all_chan(void);
+int dma_register_callback(unsigned int chan,
+			  pl330_xfer_callback_t cb, void *pri);
+int dma_free_callback(unsigned int chan);
+
+#endif /* __PLAT_DMA_H */
diff --git a/arch/arm/plat-iproc/include/plat/dma_drv.h b/arch/arm/plat-iproc/include/plat/dma_drv.h
new file mode 100644
index 0000000..8e50d26
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/dma_drv.h
@@ -0,0 +1,603 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/**
+*
+*   @file   dma_drv.h
+*
+*   @brief  DMA device driver defines and prototypes.
+*
+****************************************************************************/
+/**
+*
+* @defgroup DMAGroup Direct Memory Access
+* @ingroup CSLGroup
+* @brief This group defines the APIs for DMA driver
+
+Click here to navigate back to the Chip Support Library Overview page: \ref CSLOverview. \n
+*****************************************************************************/
+#ifndef _DMA_DRV_H_
+#define _DMA_DRV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** 
+ * @addtogroup DMAGroup 
+ * @{
+ */
+
+/**
+*
+*  DMA driver status definition
+*
+*****************************************************************************/
+#define   DMADRV_STATUS_t              DMADRV_STATUS
+typedef enum
+{
+	DMADRV_STATUS_CLOSED,
+	DMADRV_STATUS_OPEN,
+	DMADRV_STATUS_OK,
+	DMADRV_STATUS_FAIL
+}DMADRV_STATUS_t;
+
+/**
+*
+*  DMA driver callback status definition
+*
+*****************************************************************************/
+#define   DMADRV_CALLBACK_STATUS_t     DMADRV_CALLBACK_STATUS
+typedef enum
+{
+    DMADRV_CALLBACK_OK = 0,
+    DMADRV_CALLBACK_FAIL
+} DMADRV_CALLBACK_STATUS_t;
+
+/**
+*
+*  DMA driver channel descriptor definition
+*
+*****************************************************************************/
+typedef struct
+{
+	UInt32  src;
+	UInt32  dest;
+	UInt32  next;
+	UInt32  control;
+	UInt32  size;
+    UInt32  owner;
+} Dma_Chan_Desc;
+
+/**
+*
+*  DMA driver data buffer feature definition
+*
+*****************************************************************************/
+typedef struct 
+{
+    UInt32 srcAddr;
+    UInt32 destAddr;
+    UInt32 length;
+    UInt32 bRepeat;
+    UInt32 interrupt;
+} Dma_Buffer;
+
+/**
+*
+*  DMA driver data buffer definition
+*
+*****************************************************************************/
+typedef struct
+{
+    Dma_Buffer       buffers[1];
+} Dma_Buffer_List;
+
+/**
+*
+*  DMA driver data buffer list definition
+*
+*****************************************************************************/
+typedef struct
+{
+    UInt32           numBuffer;
+    Dma_Buffer_List *pBufList;
+}   Dma_Data;
+
+
+/**
+*
+*  DMA data transfer width definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_DATA_SIZE_8BIT  = 0x00,
+    DMA_DATA_SIZE_16BIT = 0x01,
+    DMA_DATA_SIZE_32BIT = 0x02
+} DMA_DWIDTH;
+
+/**
+*
+*  DMA data transfer type definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_FCTRL_MEM_TO_MEM                         = 0,
+    DMA_FCTRL_MEM_TO_PERI                        = 1,
+    DMA_FCTRL_PERI_TO_MEM                        = 2,
+    DMA_FCTRL_SRCPERI_TO_DESTPERI                = 3,
+    DMA_FCTRL_SRCPERI_TO_DESTPERI_CTRL_DESTPERI  = 4,
+    DMA_FCTRL_MEM_TO_PERI_CTRL_PERI              = 5,
+    DMA_FCTRL_PERI_TO_MEM_CTRL_PERI              = 6,
+    DMA_FCTRL_SRCPERI_TO_DESTPERI_CTRL_SRCPERI   = 7
+} DMA_CHAN_TYPE;
+
+/**
+*
+*  DMA burst length definition
+*
+*****************************************************************************/
+#if (defined(_HERA_) || defined(_RHEA_) || defined(_SAMOA_))
+typedef enum {
+    DMA_BURST_LEN_1  = 0x00,             ///<
+    DMA_BURST_LEN_2  = 0x01,             ///<
+    DMA_BURST_LEN_3  = 0x02,             ///<
+    DMA_BURST_LEN_4  = 0x03,             ///<
+    DMA_BURST_LEN_5  = 0x04,             ///<
+    DMA_BURST_LEN_6  = 0x05,             ///<
+    DMA_BURST_LEN_7  = 0x06,             ///<
+    DMA_BURST_LEN_8  = 0x07,             ///<
+    DMA_BURST_LEN_9  = 0x08,             ///<
+    DMA_BURST_LEN_10 = 0x09,             ///<
+    DMA_BURST_LEN_11 = 0x0A,             ///<
+    DMA_BURST_LEN_12 = 0x0B,             ///<
+    DMA_BURST_LEN_13 = 0x0C,             ///<
+    DMA_BURST_LEN_14 = 0x0D,             ///<
+    DMA_BURST_LEN_15 = 0x0E,             ///<
+    DMA_BURST_LEN_16 = 0x0F              ///<
+} DMADRV_BLENGTH;
+
+typedef enum
+{
+    DMA_BURST_SIZE_1    = 0x00,
+    DMA_BURST_SIZE_2    = 0x01,
+    DMA_BURST_SIZE_4    = 0x02,
+    DMA_BURST_SIZE_8    = 0x03,
+    DMA_BURST_SIZE_16   = 0x04,
+    DMA_BURST_SIZE_32   = 0x05,
+    DMA_BURST_SIZE_64  = 0x06,
+    DMA_BURST_SIZE_128  = 0x07
+} DMA_BSIZE;
+
+#else
+/**
+*
+*  DMA burst size definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_BURST_SIZE_1    = 0x00,
+    DMA_BURST_SIZE_4    = 0x01,
+    DMA_BURST_SIZE_8    = 0x02,
+    DMA_BURST_SIZE_16   = 0x03,
+    DMA_BURST_SIZE_32   = 0x04,
+    DMA_BURST_SIZE_64   = 0x05,
+    DMA_BURST_SIZE_128  = 0x06,
+    DMA_BURST_SIZE_256  = 0x07
+} DMA_BSIZE;
+#endif
+
+/**
+*
+*  DMA alignment definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_ALIGNMENT_8	    = 8,
+    DMA_ALIGNMENT_16	= 16,
+    DMA_ALIGNMENT_32	= 32
+} DMA_ALIGN;
+
+/**
+*
+*  DMA data transfer incremnet definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_INC_MODE_NONE = 0,
+    DMA_INC_MODE_SRC,
+    DMA_INC_MODE_DST,
+    DMA_INC_MODE_BOTH,
+} DMA_INC_MODE;
+
+/**
+*
+*  DMA driver client type definition
+*
+*****************************************************************************/
+#if (defined(_HERA_) || defined(_RHEA_) || defined(_SAMOA_))
+typedef enum {
+    DMA_CLIENT_EP_INVALID      = 0xff,
+    DMA_CLIENT_EP_UARTB_A      = 8,
+    DMA_CLIENT_EP_UARTB_B      = 9,
+    DMA_CLIENT_EP_UARTB2_A     = 10,
+    DMA_CLIENT_EP_UARTB2_B     = 11,
+    DMA_CLIENT_EP_UARTB3_A     = 12,
+    DMA_CLIENT_EP_UARTB3_B     = 13,
+    DMA_CLIENT_EP_SSP_0A_RX0   = 16,
+    DMA_CLIENT_EP_SSP_0B_TX0   = 17,
+    DMA_CLIENT_EP_SSP_0C_RX1   = 18,
+    DMA_CLIENT_EP_SSP_0D_TX1   = 19,
+    DMA_CLIENT_EP_SSP_1A_RX0   = 20,
+    DMA_CLIENT_EP_SSP_1B_TX0   = 21,
+    DMA_CLIENT_EP_SSP_1C_RX1   = 22,
+    DMA_CLIENT_EP_SSP_1D_TX1   = 23,
+    DMA_CLIENT_EP_HSIA         = 32,
+    DMA_CLIENT_EP_HSIB         = 33,
+    DMA_CLIENT_EP_HSIC         = 34,
+    DMA_CLIENT_EP_HSID         = 35,
+    DMA_CLIENT_EP_EANC         = 40,
+    DMA_CLIENT_EP_STEREO       = 41,
+    DMA_CLIENT_EP_NVIN         = 42,
+    DMA_CLIENT_EP_VIN          = 43,
+    DMA_CLIENT_EP_VIBRA        = 44,
+    DMA_CLIENT_EP_IHF_0        = 45,
+    DMA_CLIENT_EP_VOUT         = 46,
+    DMA_CLIENT_EP_SLIMA        = 47,
+    DMA_CLIENT_EP_SLIMB        = 48,
+    DMA_CLIENT_EP_SLIMC        = 49,
+    DMA_CLIENT_EP_SLIMD        = 50,
+    DMA_CLIENT_EP_SIM_A        = 51,
+    DMA_CLIENT_EP_SIM_B        = 52,
+    DMA_CLIENT_EP_SIM2_A       = 53,
+    DMA_CLIENT_EP_SIM2_B       = 54,
+    DMA_CLIENT_EP_IHF_1        = 55,
+#if defined(_RHEA_)
+    DMA_CLIENT_EP_SSP_3A_RX0   = 56,
+    DMA_CLIENT_EP_SSP_3B_TX0   = 57,
+    DMA_CLIENT_EP_SSP_3C_RX1   = 58,
+    DMA_CLIENT_EP_SSP_3D_TX1   = 59,
+#else
+    DMA_CLIENT_EP_SSP_2A_RX0   = 56,
+    DMA_CLIENT_EP_SSP_2B_TX0   = 57,
+    DMA_CLIENT_EP_SSP_2C_RX1   = 58,
+    DMA_CLIENT_EP_SSP_2D_TX1   = 59,
+#endif
+    DMA_CLIENT_EP_SPUM_SecureA = 65,
+    DMA_CLIENT_EP_SPUM_SecureB = 66,
+    DMA_CLIENT_EP_SPUM_OpenA   = 67,
+    DMA_CLIENT_EP_SPUM_OpenB   = 68,
+    DMA_CLIENT_MEMORY          = 69,
+#if defined(_RHEA_)
+    DMA_CLIENT_EP_SSP_4A_RX0   = 76,
+    DMA_CLIENT_EP_SSP_4B_TX0   = 77,
+    DMA_CLIENT_EP_SSP_4C_RX1   = 78,
+    DMA_CLIENT_EP_SSP_4D_TX1   = 79,
+#endif
+    DMA_CLIENT_TOTAL
+} DMA_CLIENT;
+#else
+typedef enum
+{
+    DMA_CLIENT_BULK_CRYPT_OUT             = 0,
+    DMA_CLIENT_CAM                        = 1,
+    DMA_CLIENT_I2S_TX                     = 2,
+    DMA_CLIENT_I2S_RX                     = 3,
+    DMA_CLIENT_SIM_RX                     = 4,
+    DMA_CLIENT_SIM_TX                     = 4,
+    DMA_CLIENT_CRC                        = 5,
+    DMA_CLIENT_SPI_RX                     = 6,
+    DMA_CLIENT_SPI_TX                     = 7,
+    DMA_CLIENT_UARTA_RX                   = 8,
+    DMA_CLIENT_UARTA_TX                   = 9,
+    DMA_CLIENT_UARTB_RX                   = 10,
+    DMA_CLIENT_UARTB_TX                   = 11,
+    DMA_CLIENT_DES_IN                     = 12, 
+    DMA_CLIENT_DES_OUT                    = 13, 
+    DMA_CLIENT_USB_RX                     = 14,
+    DMA_CLIENT_USB_TX                     = 15,
+    DMA_CLIENT_UARTC_RX                   = 16,
+    DMA_CLIENT_UARTC_TX                   = 17,
+    DMA_CLIENT_BULK_CRYPT_IN              = 18,
+    DMA_CLIENT_LCD                        = 19,
+    DMA_CLIENT_MSPRO                      = 20,
+    DMA_CLIENT_DSI_CM                     = 21,
+    DMA_CLIENT_DSI_VM                     = 22,
+    DMA_CLIENT_TVENC1                     = 23,
+    DMA_CLIENT_TVENC2                     = 24,
+#if defined(_ATHENA_)
+    DMA_CLIENT_AUDIO_IN_FIFO              = 25,
+    DMA_CLIENT_AUDIO_OUT_FIFO             = 26,
+    DMA_CLIENT_POLYRING_OUT_FIFO          = 27,
+    DMA_CLIENT_AUDIO_WB_MIXERTAP          = 28,
+    DMA_CLIENT_MEMORY                     = 29,
+#else
+    DMA_CLIENT_MEMORY                     = 25,
+#endif
+    DMA_CLIENT_TOTAL
+} DMA_CLIENT;
+#endif
+
+/**
+*
+*  DMA driver channel definition
+*
+*****************************************************************************/
+typedef enum
+{
+    DMA_CHANNEL_INVALID = 0xFF, 
+    DMA_CHANNEL_0 = 0,
+    DMA_CHANNEL_1 = 1,
+    DMA_CHANNEL_2 = 2,
+    DMA_CHANNEL_3 = 3,
+#if !defined(_SAMOA_)
+    DMA_CHANNEL_4 = 4,
+    DMA_CHANNEL_5 = 5,
+    DMA_CHANNEL_6 = 6,
+    DMA_CHANNEL_7 = 7,
+#if defined(_ATHENA_)
+    DMA_CHANNEL_8 = 8,     //used for DMA_CLIENT_AUDIO_OUT_FIFO
+    DMA_CHANNEL_9 = 9,     //used for DMA_CLIENT_POLYRING_OUT_FIFO
+    DMA_CHANNEL_10 = 10,   //used for DMA_CLIENT_AUDIO_WB_MIXERTAP
+    DMA_CHANNEL_11 = 11,   //used for DMA_CLIENT_AUDIO_IN_FIFO
+#endif
+#endif
+    TOTAL_DMA_CHANNELS
+} DMA_CHANNEL;
+
+/**
+*
+*  DMA driver callback function definition
+*
+*****************************************************************************/
+#define   DMADRV_CALLBACK_t            DmaDrv_Callback
+typedef void (*DMADRV_CALLBACK_t)(DMADRV_CALLBACK_STATUS_t Err);
+
+/**
+*
+*  DMA driver channel info structure definition
+*
+*****************************************************************************/
+typedef struct 
+{
+    DMA_CLIENT        srcID;
+    DMA_CLIENT        dstID;
+    DMA_CHAN_TYPE     type;
+    DMA_ALIGN         alignment;
+    DMA_BSIZE         srcBstSize;
+    DMA_BSIZE         dstBstSize;
+    DMA_DWIDTH        srcDataWidth;
+    DMA_DWIDTH        dstDataWidth;
+    UInt32            priority;
+    UInt32            chanNumber;
+    UInt32            dmaCfgReg;
+    UInt32            incMode;
+    DmaDrv_Callback   xferCompleteCb;
+    UInt32            prot;
+    UInt32            dstMaster;
+    UInt32            srcMaster;
+    UInt32            dstIncrement;
+    UInt32            srcIncrement;    
+#if (defined(_HERA_) || defined(_RHEA_) || defined(_SAMOA_))
+    DMADRV_BLENGTH    srcBstLength;
+    DMADRV_BLENGTH    dstBstLength;
+#endif
+    Boolean           freeChan;
+    Boolean           bCircular;
+} Dma_Chan_Info,      *pChanInfo;
+
+/**
+*
+*  DMA driver LLI structure definition
+*
+*****************************************************************************/
+typedef void *DMADRV_LLI_T;
+
+/**
+*
+*  This function initialize dma driver
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Init(void);
+
+/**
+*
+*  This function deinitialize dma driver
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_DeInit(void);
+
+/**
+*
+*  This function allocates dma channel
+*
+*  @param		srcID (in) source identification
+*  @param       dstID (in) destination identification
+*  @param       chanID (in) buffer to store channel number
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Obtain_Channel(
+    DMA_CLIENT srcID, 
+    DMA_CLIENT dstID, 
+    DMA_CHANNEL *chanID
+);
+
+/**
+*
+*  This function release dma channel
+*
+*  @param		chanID (in) channel identification
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Release_Channel(DMA_CHANNEL chanID);
+
+/**
+*
+*  This function configure dma channel
+*
+*  @param       chanID       (in) channel number
+*  @param       pChanInfo    (in) pointer to dma channe info structure
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Config_Channel(
+    DMA_CHANNEL chanID, 
+    Dma_Chan_Info *pChanInfo
+);
+
+/**
+*
+*  This function bind data buffer for the DMA channel
+*
+*  @param		chanID    (in) channel to bind data 
+*  @param       pData     (in) pointer to dma channel data buffer 
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Bind_Data(DMA_CHANNEL chanID, Dma_Data *pData);
+
+/**
+*
+*  This function start dma channel transfer
+*
+*  @param		chanID (in) channel identification
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Start_Transfer(DMA_CHANNEL chanID);
+
+/**
+*
+*  This function bind data buffer for the DMA channel
+*
+*  @param		chanID    (in) channel to bind data 
+*  @param       pData     (in) pointer to dma channel data buffer 
+*  @param       pLLI      (in) buffer to store returned LLI table 
+*                              identification info
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Bind_Data_Ex(
+    DMA_CHANNEL chanID, 
+    Dma_Data *pData,
+    DMADRV_LLI_T *pLLI
+);
+
+/**
+*
+*  This function start dma channel transfer
+*
+*  @param		chanID (in) channel identification
+*  @param       pLLI   (in) one of the LLI tables needs to be used for DMA 
+*                           transfer 
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Start_Transfer_Ex(
+    DMA_CHANNEL chanID, 
+    DMADRV_LLI_T pLLI
+);
+
+/**
+*
+*  This function stop dma channel trnasfer
+*
+*  @param		chanID (in) channel identification
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Stop_Transfer(DMA_CHANNEL chanID);
+
+/**
+*
+*  This function stop dma channel trnasfer and lose all data in FIFO
+*
+*  @param		chanID (in) channel identification
+*
+*  @return	    DMA driver return status
+*
+*****************************************************************************/
+DMADRV_STATUS DMADRV_Force_Shutdown_Channel(DMA_CHANNEL chanID);
+
+/**
+*
+*  This function register hisr for client usage
+*
+*  @param		client (in) client identification
+*  @param       hisr   (in) registered hisr
+*
+*  @return	    void
+*
+*****************************************************************************/                           
+void DMADRV_Register_HISR(DMA_CLIENT client, void *hisr);
+
+/**
+*
+*  This function unregister hisr from client usage
+*
+*  @param		client (in) client identification
+*
+*  @return	    void
+*
+*****************************************************************************/                           
+void DMADRV_UnRegister_HISR(DMA_CLIENT client);
+
+/**
+*
+*  This function get hisr for client usage
+*
+*  @param		client (in) client identification
+*
+*  @return	    hisr   (out) return registered client's hisr
+*
+*****************************************************************************/                           
+void *DMADRV_Get_HISR(DMA_CLIENT client);
+
+/**
+*
+*  This function get DMA driver version number
+*
+*  @return	    driver version number
+*
+*****************************************************************************/                           
+UInt32 DMADRV_Get_Version(void);
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _DMA_DRV_H_ */
diff --git a/arch/arm/plat-iproc/include/plat/dmux.h b/arch/arm/plat-iproc/include/plat/dmux.h
new file mode 100644
index 0000000..b8bdac5
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/dmux.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef __MACH_DMUX_H
+#define __MACH_DMUX_H
+
+enum dmac_mux {
+	KONA_DMUX_UARTB_A = 8,
+	KONA_DMUX_UARTB_B = 9,
+	KONA_DMUX_UARTB2_A = 10,
+	KONA_DMUX_UARTB2_B = 11,
+	KONA_DMUX_UARTB3_A = 12,
+	KONA_DMUX_UARTB3_B = 13,
+	KONA_DMUX_SSP_0A_RX0 = 16,
+	KONA_DMUX_SSP_0B_TX0 = 17,
+	KONA_DMUX_SSP_0C_RX1 = 18,
+	KONA_DMUX_SSP_0D_TX1 = 19,
+	KONA_DMUX_SSP_1A_RX0 = 20,
+	KONA_DMUX_SSP_1B_TX0 = 21,
+	KONA_DMUX_SSP_1C_RX1 = 22,
+	KONA_DMUX_SSP_1D_TX1 = 23,
+	KONA_DMUX_HSIA = 32,
+	KONA_DMUX_HSIB = 33,
+	KONA_DMUX_HSIC = 34,
+	KONA_DMUX_HSID = 35,
+	KONA_DMUX_EANC = 40,
+	KONA_DMUX_STEREO = 41,
+	KONA_DMUX_NVIN = 42,
+	KONA_DMUX_VIN = 43,
+	KONA_DMUX_VIBRA = 44,
+	KONA_DMUX_IHF_0 = 45,
+	KONA_DMUX_VOUT = 46,
+	KONA_DMUX_SLIMA = 47,
+	KONA_DMUX_SLIMB = 48,
+	KONA_DMUX_SLIMC = 49,
+	KONA_DMUX_SLIMD = 50,
+	KONA_DMUX_SIM_A = 51,
+	KONA_DMUX_SIM_B = 52,
+	KONA_DMUX_SIM2_A = 53,
+	KONA_DMUX_SIM2_B = 54,
+	KONA_DMUX_IHF_1 = 55,
+	KONA_DMUX_SSP_2A_RX0 = 56,
+	KONA_DMUX_SSP_2B_TX0 = 57,
+	KONA_DMUX_SSP_2C_RX1 = 58,
+	KONA_DMUX_SSP_2D_TX1 = 59,
+	KONA_DMUX_SPUM_SecureA = 65,
+	KONA_DMUX_SPUM_SecureB = 66,
+	KONA_DMUX_SPUM_OpenA = 67,
+	KONA_DMUX_SPUM_OpenB = 68,
+	KONA_DMUX_INVALID = 0x7f,
+};
+
+enum dma_peri dmux_name_to_id(const char *name);
+int dmux_id_to_name(enum dma_peri peri, char *pname);
+int dmux_sema_protect(void);
+int dmux_sema_unprotect(void);
+int dmux_alloc_channel(u32 * pchan);
+int dmux_release_channel(u32 channel);
+int dmux_alloc_peripheral(u32 channel, enum dma_peri peri, u8 * peri_req_id);
+int dmux_alloc_multi_peripheral(u32 channel, enum dma_peri a, enum dma_peri b,
+				u8 * src_id, u8 * dst_id);
+int dmux_dealloc_peripheral(u32 channel);
+
+#endif /* __MACH_DMUX_H */
diff --git a/arch/arm/plat-iproc/include/plat/osdal_os.h b/arch/arm/plat-iproc/include/plat/osdal_os.h
new file mode 100644
index 0000000..36003fb
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/osdal_os.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _OSDAL_OS_H_
+#define _OSDAL_OS_H_
+
+#include <linux/kernel.h>
+#include "asm/posix_types.h"
+#include "asm/string.h"
+/* Heap memory */
+#define OSDAL_ALLOCHEAPMEM(s)	kzalloc((s), GFP_KERNEL)
+
+#define OSDAL_FREEHEAPMEM(a)	kfree((a))
+
+
+/* IRQ */
+#define OSDAL_IRQ_Enable(irq)    enable_irq((irq))
+#define OSDAL_IRQ_Disable(irq)   disable_irq((irq))
+#define OSDAL_IRQ_Clear(irq)
+#define OSDAL_IRQ_IsEnabled(irq)
+
+
+/*  Synchronization */
+#define OSDAL_SENDEVENT(e) complete((struct completion *)&(e))
+
+#define OSDAL_WAITEVENT(e)	\
+wait_for_completion((struct completion *)&(e))
+
+#define OSDAL_WAITEVENT_TIMEOUT(e, t) \
+wait_for_completion_timeout((struct completion *)&(e), (t))
+
+#define OSDAL_CLEAREVENT(e)
+
+
+/* Time stamp in ms */
+#define  OSDAL_TIMEVAL()
+
+
+/* Delays */
+#define OSDAL_MDELAY(x)	mdelay(x)
+
+#define OSDAL_UDELAY(x)	udelay(x)
+
+/* Debug Print */
+//#define dprintf(prio, format, args...)	pr_info("%s:%s"" format", __FILE__, __FUNCTION__)
+#define dprintf(prio, fmt, ...) printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
+
+#endif /*_OSDAL_OS_H_*/
diff --git a/arch/arm/plat-iproc/include/plat/shm.h b/arch/arm/plat-iproc/include/plat/shm.h
new file mode 100644
index 0000000..fe09834
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/shm.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Header for declaring shim layer exports.
+ */
+
+#ifndef __SHM_DOT_H_INCLUDED__
+#define __SHM_DOT_H_INCLUDED__
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+extern struct resource *
+iproc_platform_get_resource(struct platform_device *dev, unsigned int type,
+		      unsigned int num);
+extern int iproc_platform_device_register(struct platform_device * pdev);
+extern void iproc_platform_device_unregister(struct platform_device * pdev);
+extern int iproc_platform_driver_register(struct platform_driver *drv);
+extern void iproc_platform_driver_unregister(struct platform_driver *drv);
+
+#endif /*#ifndef __SHM_DOT_H_INCLUDED__*/
diff --git a/arch/arm/plat-iproc/include/plat/spi_iproc.h b/arch/arm/plat-iproc/include/plat/spi_iproc.h
new file mode 100644
index 0000000..dab92cc
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/spi_iproc.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Broadcom IPROC SSPI based SPI master controller
+ */
+#ifndef __ARCH_PLAT_SPI_IPROC_H__
+#define __ARCH_PLAT_SPI_IPROC_H__
+
+struct spi_iproc_platform_data {
+	u8 enable_dma;
+	u8 cs_line;
+	u8 mode;
+};
+#endif /* __ARCH_PLAT_SPI_IPROC_H__ */
diff --git a/arch/arm/plat-iproc/include/plat/swreset_rec.h b/arch/arm/plat-iproc/include/plat/swreset_rec.h
new file mode 100644
index 0000000..bace020
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/swreset_rec.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _SWRESET_REC_H_
+#define _SWRESET_REC_H_
+
+/* Handle to access Software Record Record */
+typedef void *SWRR_HANDLE;
+
+/* Get number of software reset records for the SoC; 0 if not suppprted */
+extern unsigned int swreset_record_get_record_count(void);
+
+/* Get number of bits per software reset record for the SoC */
+extern unsigned int swreset_record_get_record_width(void);
+
+/* Register to use one software reset record; return NULL if used out */
+extern SWRR_HANDLE swreset_record_register(const char *name);
+
+/* Unregister to return the record */
+extern void swreset_record_unregister(SWRR_HANDLE handle);
+
+/* Set value of the software reset record */
+extern int swreset_record_set(SWRR_HANDLE handle, int value);
+
+/* Get value of the software reset record */
+extern int swreset_record_get(SWRR_HANDLE handle, int *value);
+ 
+#endif /* _SWRESET_REC_H_ */
diff --git a/arch/arm/plat-iproc/include/plat/timer-sp.h b/arch/arm/plat-iproc/include/plat/timer-sp.h
new file mode 100644
index 0000000..5cbd54d
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/timer-sp.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+void iproc_clocksource_init(void __iomem *);
+void iproc_clockevents_init(void __iomem *, unsigned int);
diff --git a/arch/arm/plat-iproc/include/plat/types.h b/arch/arm/plat-iproc/include/plat/types.h
new file mode 100644
index 0000000..80a958a
--- /dev/null
+++ b/arch/arm/plat-iproc/include/plat/types.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#ifndef _TYPES_H_
+#define _TYPES_H_
+
+#include <linux/types.h>
+#endif
diff --git a/arch/arm/plat-iproc/iproc-cache.S b/arch/arm/plat-iproc/iproc-cache.S
new file mode 100644
index 0000000..aec8fd8
--- /dev/null
+++ b/arch/arm/plat-iproc/iproc-cache.S
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * Invalidate the cache without flushing the contents of all
+ * cache levels. This code is copied from v7_flush_dcache_all
+ * from cache-v7.S
+ */
+ENTRY(__v7_invalidate_dcache_all)
+	dmb					@ ensure ordering with previous memory accesses
+	mov	r8, r1				@ Save machine ID
+	mov	r13, r2				@ Save atags pointer
+	mrc     p15, 1, r0, c0, c0, 1		@ read clidr
+	ands    r3, r0, #0x7000000		@ extract loc from clidr
+	mov     r3, r3, lsr #23			@ left align loc bit field
+	beq     finished			@ if loc is 0, then no need to clean
+	mov     r10, #0				@ start clean at cache level 0
+	loop1:
+	add     r2, r10, r10, lsr #1		@ work out 3x current cache level
+	mov     r1, r0, lsr r2			@ extract cache type bits from clidr
+	and     r1, r1, #7			@ mask of the bits for current cache only
+	cmp     r1, #2				@ see what cache we have at this level
+	blt     skip				@ skip if no cache, or just i-cache
+	mcr     p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	isb					@ isb to sych the new cssr&csidr
+	mrc     p15, 1, r1, c0, c0, 0		@ read the new csidr
+	and     r2, r1, #7			@ extract the length of the cache lines
+	add     r2, r2, #4			@ add 4 (line length offset)
+	ldr     r4, =0x3ff
+	ands    r4, r4, r1, lsr #3		@ find maximum number on the way size
+	clz     r5, r4				@ find bit position of way size increment
+	ldr     r7, =0x7fff
+	ands    r7, r7, r1, lsr #13		@ extract max number of the index size
+loop2:
+	mov     r9, r4				@ create working copy of max way size
+loop3:
+ ARM(   orr     r11, r10, r9, lsl r5    )	@ factor way and cache number into r11
+ THUMB( lsl     r6, r9, r5              )
+ THUMB( orr     r11, r10, r6            )	@ factor way and cache number into r11
+ ARM(   orr     r11, r11, r7, lsl r2    )	@ factor index number into r11
+ THUMB( lsl     r6, r7, r2              )
+ THUMB( orr     r11, r11, r6            )	@ factor index number into r11
+	mcr     p15, 0, r11, c7, c6, 2		@ invalidate line
+	subs    r9, r9, #1			@ decrement the way
+	bge     loop3
+	subs    r7, r7, #1			@ decrement the index
+	bge     loop2
+skip:
+	add     r10, r10, #2			@ increment cache number
+	cmp     r3, r10
+	bgt     loop1
+finished:
+	mov     r10, #0				@ swith back to cache level 0
+	mcr     p15, 2, r10, c0, c0, 0		@ select current cache level in cssr
+	dsb
+	isb
+	mov	r1, r8				@ restore machine ID
+	mov	r2, r13				@ restore atags pointer
+	mov     pc, lr				@ return
+ENDPROC(__v7_invalidate_dcache_all)
diff --git a/arch/arm/plat-iproc/iproc_cru.c b/arch/arm/plat-iproc/iproc_cru.c
new file mode 100644
index 0000000..a9733cd
--- /dev/null
+++ b/arch/arm/plat-iproc/iproc_cru.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * iProc Clock Control Unit
+ * The software model repsresents the hardware clock hierarchy
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/clkdev.h>
+
+#include <mach/clkdev.h>
+#include <mach/iproc_regs.h>
+#include <mach/io_map.h>
+#include <mach/memory.h>
+
+#include <asm/clkdev.h>
+#include <asm/pgtable.h>
+
+static struct resource ccu_regs = {
+	.name  = "cru_regs",
+	.start = IPROC_ROOT_CLK_VA,
+	.end   = ((IPROC_ROOT_CLK_VA) + 0x0fff),
+        .flags = IORESOURCE_MEM,
+};
+
+/*
+ * Clock management scheme is a provisional implementation
+ * only intended to retreive the pre-set frequencies for each
+ * of the clocks.
+ */
+
+/*
+ * Get PLL running status and update output frequency
+ * for ARMPLL channel 0
+ */
+static int a9pll0_status (struct clk * clk)
+{
+	u32 regA;
+	u32 regB;
+	u32 regC;
+	u32 pdiv;
+	u32 ndiv_int;
+	u32 ndiv_frac;
+	u32 mdiv;
+	u64 x;
+
+	printk(KERN_DEBUG "a9pll0_status: clk 0x%x\n", (unsigned int)clk);
+	if (clk->type != CLK_PLL)
+		return -EINVAL;
+
+	BUG_ON (!clk->regs_base);
+	BUG_ON (!clk->parent);
+
+	/* read status register */
+	regA = readl(clk->regs_base + 0x0c00);/* IHOST_PROC_CLK_PLLARMA */
+	regB = readl(clk->regs_base + 0x0c04);/* IHOST_PROC_CLK_PLLARMB */
+	regC = readl(clk->regs_base + 0x0c08);/* IHOST_PROC_CLK_PLLARMB */
+
+	/* reg C bit 8 is bypass mode - input frequency to output */
+	if ((regC & (1 << 8)) == 1) {
+		clk->rate = clk->parent->rate;
+		return 0;
+	}
+
+	/* reg A bit 28 is "lock" signal, has to be "1" for proper operation */
+	if ((regA & (1 << 28)) == 0 ) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* Update PLL frequency */
+
+
+	/* pdiv in bits 24..27 (4 bits) */
+	// pdiv = (regA >> 24 ) & 0xf; pavan 05092012
+	pdiv = (regA >> 24 ) & 0x7;
+	if (pdiv == 0)
+		pdiv = 0x10;
+
+	/* feedback divider (int)  in bits 8..17 (10 bits) */
+	ndiv_int = (regA >> 8) & ((1<<10) - 1);
+	if (ndiv_int == 0)
+		ndiv_int = 1 << 10;
+
+	/* feedback divider fraction in reg B, bits 0..19 */
+	ndiv_frac = regB & ((1<<20) - 1);
+
+	x = ((u64) ndiv_int << 20) | ndiv_frac;
+	printk(KERN_DEBUG "parent rate %lu\n", clk->parent->rate);
+	x = (x * clk->parent->rate) >> 20;
+	(void) do_div(x, pdiv);
+
+	/* post-divider is in reg C bits 0..7 */
+	mdiv = regC & 0xff ;
+	if (mdiv == 0)
+		mdiv = 0x100;
+
+	/*
+	 * Here we need to divide the resulting clock by mdiv which we
+	 * are not doing now?
+	 */
+	clk->rate = (u32)(x);
+
+	return 0;
+}
+
+
+/*
+ * Get PLL running status and update output frequency
+ * for ARMPLL channel 1
+ */
+static int a9pll1_status(struct clk * clk)
+{
+	u32 regA;
+	u32 regB;
+	u32 regC;
+	u32 regD;
+	unsigned pdiv;
+	unsigned ndiv_int;
+	unsigned ndiv_frac;
+	unsigned mdiv;
+	u64 x;
+
+	if (clk->type != CLK_PLL)
+		return -EINVAL;
+
+	BUG_ON(!clk->regs_base);
+	BUG_ON(!clk->parent);
+
+	/* read status register */
+	regA = readl(clk->regs_base+0xc00);/* IHOST_PROC_CLK_PLLARMB */
+	regB = readl(clk->regs_base+0xc04);/* IHOST_PROC_CLK_PLLARMB */
+	regC = readl(clk->regs_base+0xc20);/* IHOST_PROC_CLK_PLLARMCTRL5 */
+	regD = readl(clk->regs_base+0xc24);/* IHOST_PROC_CLK_PLLARM_OFFSET*/
+	
+	/* reg C bit 8 is bypass mode - input frequency to output */
+	if ((regC & (1 << 8)) == 1) {
+		clk->rate = clk->parent->rate;
+		return 0;
+	}
+
+	/* reg A bit 28 is "lock" signal, has to be "1" for proper operation */
+	if ((regA & (1 << 28)) == 0) {
+		clk->rate = 0;
+		return -EIO;
+	}
+
+	/* Update PLL frequency */
+
+
+	/* pdiv in bits 24..27 (4 bits) */
+	pdiv = (regA >> 24 ) & 0xf;
+	if (pdiv == 0)
+		pdiv = 0x10;
+
+	/* Check if offset mode is active */
+	if (regD & (1 << 29)) {
+		/* pllarm_ndiv_int_offset bits 27:20 */
+		ndiv_int = (regD >> 20 ) & 0xff;
+		if (ndiv_int == 0)
+			ndiv_int = 1 << 8;
+
+		/* pllarm_ndiv_frac_offset bits 19:0 */
+		ndiv_frac = regD & ((1 << 20) - 1);
+	} else {
+		/* If offset not active, channel 0 parameters are used */
+		/* feedback divider (int)  in bits 8..17 (10 bits) */
+		ndiv_int = (regA >> 8) & ((1 << 10) - 1);
+		if (ndiv_int == 0)
+			ndiv_int = 1 << 10;
+
+		/* feedback divider fraction in reg B, bits 0..19 */
+		ndiv_frac = regB & ((1 << 20) - 1);
+	}
+
+	x = ((u64) ndiv_int << 20) | ndiv_frac;
+	x = (x * clk->parent->rate) >> 20;
+	(void) do_div(x, pdiv);
+
+	/* post-divider is in reg C bits 0..7 */
+	mdiv = regC & 0xff ;
+	if (mdiv == 0)
+		mdiv = 0x100;
+
+	(void) do_div(x, mdiv);
+	clk->rate = (u32)(x);
+
+	return 0;
+}
+
+
+static const struct clk_ops a9pll0_ops = {
+	.status = a9pll0_status,
+};
+
+static const struct clk_ops a9pll1_ops = {
+	.status = a9pll1_status,
+};
+
+
+/*
+ * iProc A9 PLL
+ * could be used as source for generated clocks
+ */
+static struct clk clk_a9pll[2] = {
+	{
+		.ops 	= &a9pll0_ops,
+		.name 	= "A9_PLL",
+		.type	= CLK_PLL,
+		.chan	= 0xa,
+	},
+	{
+		.ops 	= &a9pll1_ops,
+		.name 	= "A9_PLL",
+		.type	= CLK_PLL,
+		.chan	= 0xb,
+	},
+};
+
+/*
+ * Decode the Frequency ID setting for arm_clk
+ */
+static int iproc_cru_arm_freq_id(void * __iomem regs_base)
+{
+	u32 reg_f, reg;
+	unsigned policy;
+	unsigned fid;
+	unsigned i;
+	u8 arm_clk_policy_mask = 0;
+	u8 apb0_clk_policy_mask = 0;
+
+	/*
+	 * bits 0..2 freq# for policy0, 8..10 for policy1,
+	 * 16..18 policy2, 24..26 policy 3
+	 */
+	reg_f = readl(regs_base + 0x008);/*IHOST_PROC_CLK_POLICY_FREQ*/
+
+	for(i = 0; i < 4; i++) {
+		/*
+		 * Reg IHOST_PROC_CLK_POLICY<i>_MASK
+		 * bit 20 arm policy mask, bit 21 apb0 policy mask
+		 */
+		reg = readl(regs_base + 0x010 + i*4);
+		arm_clk_policy_mask |= (1 & ( reg >> 20)) << i;
+		apb0_clk_policy_mask |=  (1 & ( reg >> 21)) << i;
+	}
+
+	/* How to obtain hardware policy setting ? */
+	policy = 0;
+
+	/* Check for PLL policy software override */
+	reg = readl(regs_base + 0xe00);/* IHOST_PROC_CLK_ARM_DIV */
+	if (reg & (1 << 4 ))
+		policy = reg & 0xf;
+
+	fid = (reg_f >> (8 * policy)) & 0xf;
+
+	/* Verify freq_id from debug register */
+	reg = readl( regs_base+0xec0 );/* IHOST_PROC_CLK_POLICY_DBG */
+	/* Bits 12..14 contain active frequency_id */
+	i = 0x7 & (reg >> 12);
+
+	if (fid != i) {
+		printk(KERN_WARNING
+			"IPROC CRU clock frequency id override %d->%d\n",
+			fid, i);
+		fid = i;
+	}
+
+	printk(KERN_DEBUG "Active frequency ID %d\n", fid);
+
+	return fid;
+}
+
+/*
+ * Get status of any of the ARMPLL output channels
+ */
+static int a9pll_chan_status(struct clk * clk)
+{
+	u32 reg;
+	unsigned div;
+	unsigned freq_id;
+
+	if(clk->type != CLK_DIV)
+		return -EINVAL;
+
+	BUG_ON(!clk->regs_base);
+
+	reg = readl(clk->regs_base + 0xe00); /* IHOST_PROC_CLK_ARM_DIV */
+
+	/* arm_pll_select 3:0 */
+	printk(KERN_DEBUG "Clock Div = %#x\n", reg);
+
+	freq_id = iproc_cru_arm_freq_id(clk->regs_base);
+
+	/* clk->parent = & clk_a9pll[0]; */
+
+	switch (clk->chan) {
+		case 0x0a:
+			/* apb0_free_div bits 10:8 */
+			div = (reg >> 8) & 0x7;
+			if (div == 0)
+				div = 8;
+			break;
+
+		case 0x0b:
+			/* arm_switch_div bits 6:5 */
+			div = (reg >> 5) & 0x3;
+			if (div == 0)
+				div = 4;
+			break;
+
+		case 0x1a:
+			/* IHOST_PROC_CLK_APB_DIV apb_clk_div bits 1:0 */
+			reg = readl(clk->regs_base + 0xa10);
+			div = reg & 0x3;
+			if(div == 0)
+				div = 4;
+			break;
+
+		case 0x3a:      /* arm_clk */
+			if( freq_id == 7 ) {
+				//clk->parent = &clk_a9pll[1]; /* arm_clk_h */
+				clk->parent = &clk_a9pll[0]; /* arm_clk_h */
+				div = 2;
+			} else if( freq_id == 6 ) {
+				clk->parent = &clk_a9pll[0]; /* arm_clk */
+				div = 4;
+			} else if( freq_id == 2 ) {
+				clk->parent = &clk_a9pll[0]; /* arm_clk */
+				div = 4;
+			} else if (freq_id == 0) {
+				clk->parent = &clk_a9pll[0];
+				div = 1;
+			} else if (freq_id == 1) {
+				struct clk * clk_lcpll_200;
+				clk_lcpll_200 =
+				clk_get_sys( NULL, "sdio_clk");
+				BUG_ON( ! clk_lcpll_200 );
+				clk->parent = clk_lcpll_200;
+				div = 1;
+			} else {
+				clk->parent = &clk_a9pll[0];
+				div = 2;
+			}
+			/* Parent may have changed, refresh it */
+			if(clk->parent->ops && clk->parent->ops->status)
+				clk->parent->ops->status( clk->parent);
+			break;
+
+                case 0x0f:      /* periph_clk */
+                        div = 2;
+                        break;
+
+		default:
+			return -EINVAL;
+
+	}
+
+	BUG_ON(!clk->parent);
+	printk(KERN_DEBUG "Clock divisor %d\n", div);
+	// clk->rate = clk->parent->rate / div ;
+	clk->rate = clk->parent->rate / div ;
+	printk(KERN_DEBUG "Clock rate %lu\n", clk->rate);
+ 
+	return 0;
+}
+
+
+static const struct clk_ops a9pll_chan_ops = {
+	.status = a9pll_chan_status,
+};
+
+/*
+ * iProc A9 PLL output clocks
+ */
+static struct clk clk_a9chan[] = {
+	{
+		.ops = &a9pll_chan_ops,
+		.type = CLK_DIV,
+		.parent = &clk_a9chan[0],
+		.name = "arm_clk",
+		.chan = 0x3a
+	},
+	{
+		.ops = &a9pll_chan_ops,
+		.type = CLK_DIV,
+		.parent = &clk_a9chan[0],
+		.name = "periph_clk",
+		.chan = 0x0f
+	},
+	{
+		.ops = &a9pll_chan_ops,
+		.type = CLK_DIV,
+		.parent = &clk_a9chan[0],
+		.name = "apb0_free",
+		.chan = 0x0a
+	},
+	{
+		.ops = &a9pll_chan_ops,
+		.type = CLK_DIV,
+		.parent = &clk_a9chan[0],
+		.name = "arm_switch",
+		.chan = 0x0b
+	},
+	{
+		.ops = &a9pll_chan_ops,
+		.type = CLK_DIV,
+		.parent = &clk_a9chan[0],
+		.name = "apb_clk",
+		.chan = 0x1a
+	},
+};
+
+static struct clk_lookup cru_clk_lookups[] = {
+	{
+		.con_id= "a9pll0",
+		.clk= &clk_a9pll[0],
+	},
+	{
+		.con_id= "a9pll1",
+		.clk= &clk_a9pll[1],
+	},
+	{
+		.con_id= "arm_clk",
+		.clk= &clk_a9chan[0],
+	},
+	{
+		.con_id= "periph_clk",
+		.clk= &clk_a9chan[1],
+	},
+	{
+		.con_id= "apb0_free",
+		.clk= &clk_a9chan[2],
+	},
+	{
+		.con_id= "axi_clk",
+		.clk= &clk_a9chan[3],
+	},
+	{
+		.con_id= "apb_clk",
+		.clk= &clk_a9chan[4],
+	},
+};
+
+void __init iproc_cru_init(struct clk * src_clk)
+{
+	void * __iomem reg_base;
+	unsigned i;
+
+	BUG_ON(request_resource( &iomem_resource, &ccu_regs));
+
+	reg_base = IOMEM(ccu_regs.start);
+
+	BUG_ON(IS_ERR_OR_NULL(reg_base));
+
+	/* Initialize clocks */
+
+	for (i = 0; i < ARRAY_SIZE(clk_a9pll); i++) {
+		clk_a9pll[i].regs_base = reg_base ;
+		clk_a9pll[i].parent = src_clk ;
+	}
+
+	clk_a9chan[0].parent = src_clk ;	/* tentative */
+	for (i = 0; i < ARRAY_SIZE(clk_a9chan); i++) {
+		clk_a9chan[i].regs_base = reg_base ;
+	}
+
+	/* Install clock sources into the lookup table */
+	clkdev_add_table(cru_clk_lookups, 
+			ARRAY_SIZE(cru_clk_lookups));
+}
+
+void cru_clocks_show(void)
+{
+	unsigned i;
+
+	printk( "CRU Clocks:\n" );
+	for (i = 0; i < ARRAY_SIZE( cru_clk_lookups); i++) {
+		printk( "%s: (%s) %lu\n",
+			cru_clk_lookups[i].con_id,
+			cru_clk_lookups[i].clk->name,
+			clk_get_rate( cru_clk_lookups[i].clk));
+	}
+	printk( "CRU Clocks# %u\n", i );
+
+}
diff --git a/arch/arm/plat-iproc/irq.c b/arch/arm/plat-iproc/irq.c
new file mode 100644
index 0000000..7f32f01
--- /dev/null
+++ b/arch/arm/plat-iproc/irq.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/cpumask.h>
+#include <linux/irqchip/arm-gic.h>
+
+#include <asm/io.h>
+#include <asm/mach/map.h>
+#include <asm/system.h>
+#include <asm/cp15.h>
+#include <asm/pgtable.h>
+
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/io_map.h>
+#include <mach/iproc.h>
+
+
+void __init iproc_init_irq(void)
+{
+	unsigned int cr;
+
+	cr = get_cr();
+	cr |= CR_VE;
+	set_cr(cr);
+
+    /* start with GLBTIMER */ 
+
+	// rewrote based upon before/after comparision of implementation
+	// of omap4-common.c:gic_init_irq().
+
+#warning "DCP TODO: fix interrupt initialization"
+	gic_init(0, BCM_INT_ID_PPI0, 
+		 IOMEM(IPROC_PERIPH_INT_DISTR_REG_VA),
+		 IOMEM(IPROC_GICCPU_VA));
+}
diff --git a/arch/arm/plat-iproc/localtimer.c b/arch/arm/plat-iproc/localtimer.c
new file mode 100644
index 0000000..6300b34
--- /dev/null
+++ b/arch/arm/plat-iproc/localtimer.c
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/irq.h>
+#include <asm/smp_twd.h>
+#include <asm/pgtable.h>
+#include <asm/localtimer.h>
+
+#include <mach/io_map.h>
+
+#define IRQ_LOCALTIMER BCM_INT_ID_PPI13
+/*
+ * Setup the local clock events for a CPU.
+ */
+
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      HW_IO_VIRT_TO_PHYS(IPROC_PERIPH_PVT_TIM_REG_VA),
+			      IRQ_LOCALTIMER);
+
+void iproc_local_timer_init(void)
+{
+	int err;
+
+	err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		printk(KERN_WARNING "iproc: twd_local_timer_register failed %d\n", err);
+}
diff --git a/arch/arm/plat-iproc/pcie_iproc.c b/arch/arm/plat-iproc/pcie_iproc.c
new file mode 100644
index 0000000..a7d6e48
--- /dev/null
+++ b/arch/arm/plat-iproc/pcie_iproc.c
@@ -0,0 +1,1160 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+* Northstar PCI-Express driver
+* Only supports Root-Complex (RC) mode
+*
+* Notes:
+* PCI Domains are being used to identify the PCIe port 1:1.
+*
+* Only MEM access is supported, PAX does not support IO.
+*
+* TODO:
+*	MSI interrupts,
+*	DRAM > 128 MBytes (e.g. DMA zones)
+*/
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/msi.h>
+
+#include <mach/memory.h>
+#include <mach/io_map.h>
+
+#include <asm/mach/pci.h>
+#include <asm/sizes.h>
+
+#include <linux/version.h>
+#include <asm/mach/irq.h>
+
+#define pci_std_swizzle pci_common_swizzle
+#define SZ_32M 0x02000000
+#define SZ_48M 0x03000000
+
+/*
+ * Register offset definitions
+ */
+
+#define NS_PCI_DEBUG		0
+#define	SOC_PCIE_CONTROL	0x000	/* a.k.a. CLK_CONTROL reg */
+#define	SOC_PCIE_PM_STATUS	0x008
+#define	SOC_PCIE_PM_CONTROL	0x00c	/* in EP mode only ! */
+
+#define	SOC_PCIE_EXT_CFG_ADDR	0x120
+#define	SOC_PCIE_EXT_CFG_DATA	0x124
+#define	SOC_PCIE_CFG_ADDR	0x1f8
+#define	SOC_PCIE_CFG_DATA	0x1fc
+
+#define	SOC_PCIE_SYS_RC_INTX_EN		0x330
+#define	SOC_PCIE_SYS_RC_INTX_CSR	0x334
+#define	SOC_PCIE_SYS_HOST_INTR_EN	0x344
+#define	SOC_PCIE_SYS_HOST_INTR_CSR	0x348
+
+#define	SOC_PCIE_HDR_OFF	0x400	/* 256 bytes per function */
+
+/* 32-bit 4KB in-bound mapping windows for Function 0..3, n=0..7 */
+#define	SOC_PCIE_SYS_IMAP0(f,n)		(0xc00+((f)<<9)((n)<<2)) 
+/* 64-bit in-bound mapping windows for func 0..3 */
+#define	SOC_PCIE_SYS_IMAP1(f)		(0xc80+((f)<<3))
+#define	SOC_PCIE_SYS_IMAP2(f)		(0xcc0+((f)<<3))
+/* 64-bit in-bound address range n=0..2 */
+#define	SOC_PCIE_SYS_IARR(n)		(0xd00+((n)<<3))
+/* 64-bit out-bound address filter n=0..2 */
+#define	SOC_PCIE_SYS_OARR(n)		(0xd20+((n)<<3))
+/* 64-bit out-bound mapping windows n=0..2 */
+#define	SOC_PCIE_SYS_OMAP(n)		(0xd40+((n)<<3))
+
+#ifdef	__nonexistent_regs_
+#define	SOC_PCIE_MDIO_CONTROL	0x128
+#define	SOC_PCIE_MDIO_RD_DATA	0x12c
+#define	SOC_PCIE_MDIO_WR_DATA	0x130
+#define	SOC_PCIE_CLK_STAT	0x1e0 
+#endif
+
+#define PCI_MAX_BUS		4
+#define pcieHostPrimSecBusNum		(0x00000100 | (PCI_MAX_BUS<<16))
+#define pcieSwitchPrimSecBusNum		(0x00000201 | (PCI_MAX_BUS<<16))
+
+#ifndef CONFIG_PCI_MSI
+void write_msi_msg(unsigned int irq, struct msi_msg *msg) {}
+#endif
+
+#ifdef	CONFIG_PCI
+
+/*
+ * Forward declarations
+ */
+static int soc_pci_setup(int nr, struct pci_sys_data *sys);
+static struct pci_bus * soc_pci_scan_bus(int nr, struct pci_sys_data *sys);
+static int soc_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+static int soc_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+                                   int where, int size, u32 *val);
+static int soc_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+                                    int where, int size, u32 val);
+
+#ifndef	CONFIG_PCI_DOMAINS
+#error	CONFIG_PCI_DOMAINS is required
+#endif
+
+
+/*
+ * PCIe host controller registers
+ * one entry per port
+ */
+#if defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+#define MAX_PCI_INTFS 3
+#else
+#define MAX_PCI_INTFS 2
+#endif
+/* this is for northstar, co-star and northstar+ */
+static struct resource soc_pcie_regs[MAX_PCI_INTFS] = {
+	{
+	.name = "pcie0",
+	.start = 0x18012000,
+	.end   = 0x18012fff,
+	.flags = IORESOURCE_MEM,
+	},
+	{
+	.name = "pcie1",
+	.start = 0x18013000,
+	.end   = 0x18013fff,
+	.flags = IORESOURCE_MEM,
+	},
+#if defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+	{
+	.name = "pcie2",
+	.start = 0x18014000,
+	.end   = 0x18014fff,
+	.flags = IORESOURCE_MEM,
+	},
+#endif
+};
+
+static struct resource soc_pcie_owin[MAX_PCI_INTFS] = {
+	{
+	.name = "PCIe Outbound Window, Port 0",
+	.start = 0x08000000,
+	.end =   0x08000000 + SZ_128M - 1,
+	.flags = IORESOURCE_MEM,
+	},
+	{
+	.name = "PCIe Outbound Window, Port 1",
+	.start = 0x40000000,
+	.end =   0x40000000 + SZ_128M - 1,
+	.flags = IORESOURCE_MEM,
+	},
+#if defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+	{
+	.name = "PCIe Outbound Window, Port 2",
+	.start = 0x48000000,
+	.end =   0x48000000 + SZ_128M - 1,
+	.flags = IORESOURCE_MEM,
+	},
+#endif
+};
+
+/*
+ * Per port control structure
+ */
+static struct soc_pcie_port {
+	struct resource * regs_res ;
+	struct resource * owin_res ;
+	void * __iomem reg_base;
+	unsigned short irqs[6];
+	struct hw_pci hw_pci ;
+
+	bool	enable;
+	bool	link;
+	bool	isSwitch;
+	bool	port1Active;
+	bool	port2Active;
+	int		lastAssignedMSI;
+	unsigned int msiAddress;
+} soc_pcie_ports[MAX_PCI_INTFS] = {
+	{
+	.regs_res = & soc_pcie_regs[0],
+	.owin_res = & soc_pcie_owin[0],
+#if defined(CONFIG_MACH_HX4)
+	.irqs = {214, 215, 216, 217, 218, 219},
+#elif defined(CONFIG_MACH_HR2)
+	.irqs = {214, 215, 216, 217, 218, 219},
+#elif defined(CONFIG_MACH_KT2)
+	.irqs = {214, 215, 216, 217, 218, 219},
+#elif defined(CONFIG_MACH_NS)
+	.irqs = {159, 160, 161, 162, 163, 164},
+#elif defined(CONFIG_MACH_NSP)
+	.irqs = {159, 160, 161, 162, 163, 164},
+#endif
+	.hw_pci = {
+		.domain 	= 0,
+		.swizzle 	= pci_std_swizzle,
+		.nr_controllers = 1,
+		.setup 		= soc_pci_setup,
+		.scan 		= soc_pci_scan_bus,
+		.map_irq 	= (void *) soc_pcie_map_irq,
+		},
+	.enable = 1,
+	.isSwitch = 0,
+	.port1Active = 0,
+	.port2Active = 0,
+#if defined(CONFIG_MACH_HX4)
+	.lastAssignedMSI = 214,
+#elif defined(CONFIG_MACH_HR2)
+	.lastAssignedMSI = 214,
+#elif defined(CONFIG_MACH_KT2)
+	.lastAssignedMSI = 214,
+#elif defined(CONFIG_MACH_NS)
+	.lastAssignedMSI = 159,
+#elif defined(CONFIG_MACH_NSP)
+	.lastAssignedMSI = 159,
+#endif
+	},
+	{
+	.regs_res = & soc_pcie_regs[1],
+	.owin_res = & soc_pcie_owin[1],
+#if defined(CONFIG_MACH_HX4)
+	.irqs = {220, 221, 222, 222, 224, 225},
+#elif defined(CONFIG_MACH_HR2)
+	.irqs = {220, 221, 222, 222, 224, 225},
+#elif defined(CONFIG_MACH_KT2)
+	.irqs = {220, 221, 222, 222, 224, 225},
+#elif defined(CONFIG_MACH_NS)
+	.irqs = {165, 166, 167, 168, 169, 170},
+#elif defined(CONFIG_MACH_NSP)
+	.irqs = {165, 166, 167, 168, 169, 170},
+#endif
+	.hw_pci = {
+		.domain 	= 1,
+		.swizzle 	= pci_std_swizzle,
+		.nr_controllers = 1,
+		.setup 		= soc_pci_setup,
+		.scan 		= soc_pci_scan_bus,
+		.map_irq 	= (void *) soc_pcie_map_irq,
+		},
+	.enable = 1,
+	.isSwitch = 0,
+	.port1Active = 0,
+	.port2Active = 0,
+#if defined(CONFIG_MACH_HX4)
+	.lastAssignedMSI = 220,
+#elif defined(CONFIG_MACH_HR2)
+	.lastAssignedMSI = 220,
+#elif defined(CONFIG_MACH_KT2)
+	.lastAssignedMSI = 220,
+#elif defined(CONFIG_MACH_NS)
+	.lastAssignedMSI = 165,
+#elif defined(CONFIG_MACH_NSP)
+	.lastAssignedMSI = 165,
+#endif
+	},
+#if defined(CONFIG_MACH_NS) || defined(CONFIG_MACH_NSP)
+	{
+	.regs_res = & soc_pcie_regs[2],
+	.owin_res = & soc_pcie_owin[2],
+	.irqs = {171, 172, 173, 174, 175, 176},
+	.hw_pci = {
+		.domain 	= 2,
+		.swizzle 	= pci_std_swizzle,
+		.nr_controllers = 1,
+		.setup 		= soc_pci_setup,
+		.scan 		= soc_pci_scan_bus,
+		.map_irq 	= (void *) soc_pcie_map_irq,
+		},
+	.enable = 1,
+	.isSwitch = 0,
+	.port1Active = 0,
+	.port2Active = 0,
+	.lastAssignedMSI = 171,
+	}
+#endif
+	};
+
+
+
+/*
+ * Methods for accessing configuration registers
+ */
+static struct pci_ops soc_pcie_ops = {
+        .read = soc_pci_read_config,
+        .write = soc_pci_write_config,
+};
+
+static struct soc_pcie_port * 
+	soc_pcie_sysdata2port( struct pci_sys_data * sysdata )
+{
+	unsigned port;
+
+	port = sysdata->domain;
+	BUG_ON( port >= ARRAY_SIZE( soc_pcie_ports ));
+	return & soc_pcie_ports[ port ];
+}
+
+static struct soc_pcie_port * soc_pcie_pdev2port( struct pci_dev *pdev )
+{
+	return soc_pcie_sysdata2port( pdev->sysdata );
+}
+
+static struct soc_pcie_port * soc_pcie_bus2port( struct pci_bus * bus )
+{
+	return soc_pcie_sysdata2port( bus->sysdata );
+}
+
+static struct pci_bus *soc_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+        return pci_scan_bus(sys->busnr, &soc_pcie_ops, sys);
+#else
+		return pci_scan_root_bus(NULL, sys->busnr, &soc_pcie_ops, sys,
+					&sys->resources);
+#endif
+}
+
+static int soc_pcie_map_irq(struct pci_dev *pdev, u8 slot, u8 pin)
+{
+        struct soc_pcie_port *port = soc_pcie_pdev2port(pdev);
+//	u32 reg;
+        int irq;
+
+        irq = port->irqs[4];	/* All INTx share int src 5, last per port */
+
+        printk("PCIe map irq: %04d:%02x:%02x.%02x slot %d, pin %d, irq: %d\n",
+                pci_domain_nr(pdev->bus), 
+		pdev->bus->number, 
+		PCI_SLOT(pdev->devfn),
+                PCI_FUNC(pdev->devfn), 
+		slot, pin, irq);
+
+        return irq;
+}
+
+static void __iomem * soc_pci_cfg_base(struct pci_bus *bus,
+                                  unsigned int devfn, int where)
+{
+    struct soc_pcie_port *port = soc_pcie_bus2port(bus);
+    int busno = bus->number;
+    int slot = PCI_SLOT(devfn);
+    int fn  = PCI_FUNC(devfn);
+    void __iomem *base;
+    int offset;
+    int type;
+	u32 addr_reg ;
+
+	base = port->reg_base ;
+
+        /* If there is no link, just show the PCI bridge. */
+        if (!port->link && (busno > 0 || slot > 0))
+                return NULL;
+        /*
+         */
+	if (busno == 0) {
+                if (slot >= 1)
+                        return NULL;
+                type = slot;
+		__raw_writel( where & 0xffc, base + SOC_PCIE_EXT_CFG_ADDR );
+		offset = SOC_PCIE_EXT_CFG_DATA;
+	} else {
+        type = 1;
+		if (fn > 1)
+			return NULL;
+		addr_reg = 	(busno & 0xff) << 20 |
+				(slot << 15) |
+				(fn << 12)   |
+				(where & 0xffc) |
+				(type & 0x3);
+ 
+		__raw_writel( addr_reg, base + SOC_PCIE_CFG_ADDR );
+		offset =  SOC_PCIE_CFG_DATA ;
+    }
+
+    return base + offset;
+}
+
+void pcieSwitchInit( struct pci_bus *bus, unsigned int devfn)
+{
+    struct soc_pcie_port *port = soc_pcie_bus2port(bus);
+	u32 	dRead = 0;
+	u32		bm = 0;
+
+    soc_pci_read_config(bus, devfn, 0x100, 4, &dRead);
+
+	printk("PCIE: Doing PLX switch Init...Test Read = %08x\n",(unsigned int)dRead);
+
+	//Debug control register.
+    soc_pci_read_config(bus, devfn, 0x1dc, 4, &dRead);
+
+	dRead &= ~(1<<22);
+
+    soc_pci_write_config(bus, devfn, 0x1dc, 4, dRead);
+
+	//Set GPIO enables.
+    soc_pci_read_config(bus, devfn, 0x62c, 4, &dRead);
+
+	printk("PCIE: Doing PLX switch Init...GPIO Read = %08x\n",(unsigned int)dRead);
+
+	dRead &= ~((1<<0)|(1<<1)|(1<<3));
+	dRead |= ((1<<4)|(1<<5)|(1<<7));
+
+    soc_pci_write_config(bus, devfn, 0x62c, 4, dRead);
+
+	mdelay(50);
+	dRead |= ((1<<0)|(1<<1));
+
+    soc_pci_write_config(bus, devfn, 0x62c, 4, dRead);
+
+    soc_pci_read_config(bus, devfn, 0x4, 2, &bm);
+#if NS_PCI_DEBUG
+	printk("bus master: %08x\n", bm);
+#endif
+	bm |= 0x06;
+	soc_pci_write_config(bus, devfn, 0x4,2, bm);
+	bm = 0;
+    soc_pci_read_config(bus, devfn, 0x4, 2, &bm);
+	printk("bus master after: %08x\n", bm);
+	bm =0;
+	//Bus 1 if the upstream port of the switch. Bus 2 has the two downstream ports, one on each device number.
+	if(bus->number == 1)
+	{
+		soc_pci_write_config(bus, devfn, 0x18, 4, pcieSwitchPrimSecBusNum);
+
+		//TODO: We need to scan all outgoing windows, to look for a base limit pair for this register.
+		//npciConfigOutLong(instance, busNo, deviceNo, 0, 0x20,0xcff0c000);
+		/* MEM_BASE, MEM_LIM require 1MB alignment */
+		BUG_ON( (port->owin_res->start   >> 16) & 0xf );
+		soc_pci_write_config(bus, devfn, PCI_MEMORY_BASE, 2,  
+		port->owin_res->start   >> 16 );
+		BUG_ON(((port->owin_res->start + SZ_32M) >> 16 ) & 0xf );
+		soc_pci_write_config(bus, devfn, PCI_MEMORY_LIMIT, 2, 
+		(port->owin_res->start + SZ_32M) >> 16 );
+
+	}
+	else if(bus->number == 2)
+	{
+		//TODO: I need to fix these hard coded addresses.
+		if(devfn == 0x8)
+		{
+			soc_pci_write_config(bus, devfn, 0x18, 4, (0x00000000 | ((bus->number+1)<<16) | ((bus->number+1)<<8) | bus->number));
+			BUG_ON( ((port->owin_res->start + SZ_48M)   >> 16) & 0xf );
+			soc_pci_write_config(bus, devfn, PCI_MEMORY_BASE, 2, 
+			(port->owin_res->start + SZ_48M)   >> 16 );
+			BUG_ON(((port->owin_res->start + SZ_48M + SZ_32M) >> 16 ) & 0xf );
+			soc_pci_write_config(bus, devfn, PCI_MEMORY_LIMIT, 2, 
+			(port->owin_res->start + SZ_48M + SZ_32M) >> 16 );
+			soc_pci_read_config(bus, devfn, 0x7A, 2, &bm);
+			if (bm & PCI_EXP_LNKSTA_DLLLA)
+				port->port1Active = 1;
+			printk("bm = %04x\n devfn = = %08x, bus = %08x\n", bm, devfn, bus->number); 
+		}
+		else if(devfn == 0x10)
+		{
+			soc_pci_write_config(bus, devfn, 0x18, 4, (0x00000000 | ((bus->number+2)<<16) | ((bus->number+2)<<8) | bus->number));
+			BUG_ON( ((port->owin_res->start + (SZ_48M * 2 ))  >> 16) & 0xf );
+			soc_pci_write_config(bus, devfn, PCI_MEMORY_BASE, 2,  
+			(port->owin_res->start  + (SZ_48M * 2 ))   >> 16 );
+			BUG_ON(((port->owin_res->start + (SZ_48M * 2 ) + SZ_32M) >> 16 ) & 0xf );
+			soc_pci_write_config(bus, devfn, PCI_MEMORY_LIMIT, 2,  
+			(port->owin_res->start + (SZ_48M * 2 ) + SZ_32M) >> 16 );
+			soc_pci_read_config(bus, devfn, 0x7A, 2, &bm);
+			if (bm & PCI_EXP_LNKSTA_DLLLA)
+				port->port2Active = 1;
+			printk("bm = %04x\n devfn = = %08x, bus = %08x\n", bm, devfn, bus->number); 
+		}
+	}
+}
+
+static int soc_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+                                   int where, int size, u32 *val)
+{
+    void __iomem *base;
+	u32 data_reg;
+//	u16 tmp16;
+    struct soc_pcie_port *port = soc_pcie_bus2port(bus);
+
+	if ((bus->number > 4))
+	{
+		*val = ~0UL;
+		return PCIBIOS_SUCCESSFUL;
+	}
+	if (port->isSwitch == 1)
+	{
+		if (bus->number == 2)
+		{
+			if (!((devfn == 0x8) || (devfn == 0x10)))
+			{
+				*val = ~0UL;
+				return PCIBIOS_SUCCESSFUL;
+			}
+		}
+		else if ((bus->number == 3) || (bus->number == 4))
+		{
+			if (devfn != 0)
+			{
+				*val = ~0UL;
+				return PCIBIOS_SUCCESSFUL;
+			}
+			else if ((bus->number == 3) && (port->port1Active == 0))
+			{
+				*val = ~0UL;
+				return PCIBIOS_SUCCESSFUL;
+			}
+			else if ((bus->number == 4) && (port->port2Active == 0))
+			{
+				*val = ~0UL;
+				return PCIBIOS_SUCCESSFUL;
+			}
+		}
+	}
+	base = soc_pci_cfg_base(bus, devfn, where);
+
+    if (base == NULL )
+	{
+            *val = ~0UL;
+            return PCIBIOS_SUCCESSFUL;
+	}
+
+#if NS_PCI_DEBUG
+	printk("PCI-E: R: bus %08x, where %08x, devfn %08x\n", bus->number, where, devfn);
+#endif
+	data_reg = __raw_readl( base );
+#if NS_PCI_DEBUG
+	printk("PCI-E: R: data_reg %08x\n", data_reg);
+#endif
+
+
+	if ((bus->number == 1) && (port->isSwitch == 0) && (where == 0) && (((data_reg >> 16) & 0x0000FFFF) == 0x00008603))
+	{
+		pcieSwitchInit( bus, devfn);
+		port->isSwitch = 1;
+	}
+	else if ((bus->number == 1) && (port->isSwitch == 0) && (where == 0) && (((data_reg >> 16) & 0x0000FFFF) == 0x00008617))
+	{
+		pcieSwitchInit( bus, devfn);
+		port->isSwitch = 1;
+	}
+
+	if ((bus->number == 2) && (port->isSwitch == 1) && (where == 0) &&(((data_reg >> 16) & 0x0000FFFF) == 0x00008603))
+		pcieSwitchInit(bus, devfn);
+	else if ((bus->number == 2) && (port->isSwitch == 1) && (where == 0) &&(((data_reg >> 16) & 0x0000FFFF) == 0x00008617))
+		pcieSwitchInit(bus, devfn);
+
+	/* HEADER_TYPE=00 indicates the port in EP mode */
+
+	data_reg = (data_reg) >> ((where & 3) * 8);
+	*val = data_reg;
+    return PCIBIOS_SUCCESSFUL;
+}
+
+static int soc_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+                                    int where, int size, u32 val)
+{
+    void __iomem *base;
+	u32  data_reg ;
+	int saveWhere;
+    struct soc_pcie_port *port = soc_pcie_bus2port(bus);
+
+	saveWhere = where;
+	if ((bus->number > 4))
+	{
+		return PCIBIOS_SUCCESSFUL;
+	}
+	if ((bus->number == 2) && (port->isSwitch == 1 ))
+	{
+		if (!((devfn == 0x8) || (devfn == 0x10)))
+		{
+			return PCIBIOS_SUCCESSFUL;
+		}
+	}
+	else if ((bus->number == 3) && (port->isSwitch == 1))
+	{
+		if (devfn != 0)
+			return PCIBIOS_SUCCESSFUL;
+	}
+	else if ((bus->number == 4) && (port->isSwitch == 1))
+	{
+		if (devfn != 0)
+		{
+			return PCIBIOS_SUCCESSFUL;
+		}
+	}
+	base = soc_pci_cfg_base(bus, devfn, where);
+
+    if (base == NULL)
+	{
+            return PCIBIOS_SUCCESSFUL;
+	}
+
+	if( size < 4 ){
+		where = (where & 3) * 8;
+
+#if NS_PCI_DEBUG
+		printk("PCI-E: WR: bus %08x, where %08x, devfn %08x, size: %08x\n", bus->number, saveWhere, devfn, size);
+#endif
+		data_reg = __raw_readl( base );
+#if NS_PCI_DEBUG
+		printk("PCI-E: WR: after data_reg %08x\n", data_reg);
+#endif
+
+		if (size == 1)
+			data_reg &= ~(0xff << where);
+		else
+			data_reg &= ~(0xffff << where);
+		data_reg |= (val << where);
+	}
+	else{
+		data_reg = val;
+	}
+
+#if NS_PCI_DEBUG
+	printk("PCI-E: W: bus %08x, where %08x, devfn %08x, data_reg %08x, size: %08x\n", bus->number, saveWhere, devfn, data_reg, size);
+#endif
+	__raw_writel( data_reg, base );
+#if NS_PCI_DEBUG
+	printk("PCI-E: W: after\n");
+#endif
+
+    return PCIBIOS_SUCCESSFUL;
+}
+
+static int soc_pci_setup(int nr, struct pci_sys_data *sys)
+{
+        struct soc_pcie_port *port = soc_pcie_sysdata2port(sys);
+
+	BUG_ON( request_resource( &iomem_resource, port->owin_res ));
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)
+	sys->resource[0] = port->owin_res ;
+	//sys->private_data = port;
+#else
+	pci_add_resource(&sys->resources, port->owin_res);
+#endif
+
+        return 1;
+}
+
+/*
+ * Check link status, return 0 if link is up in RC mode,
+ * otherwise return non-zero
+ */
+static int __init noinline soc_pcie_check_link(struct soc_pcie_port * port)
+{
+        u32 devfn = 0;
+	u16 pos, tmp16;
+	u8 nlw, tmp8;
+	u32 tmp32;
+
+        struct pci_sys_data sd = {
+                .domain = port->hw_pci.domain,
+        };
+        struct pci_bus bus = {
+                .number = 0,
+                .ops = &soc_pcie_ops,
+                .sysdata = &sd,
+        };
+
+	if( ! port->enable )
+		return -EINVAL;
+
+	/* See if the port is in EP mode, indicated by header type 00 */
+        pci_bus_read_config_byte(&bus, devfn, PCI_HEADER_TYPE, &tmp8);
+	if( tmp8 != PCI_HEADER_TYPE_BRIDGE ) {
+		pr_info("PCIe port %d in End-Point mode - ignored\n",
+			port->hw_pci.domain );
+		return -ENODEV;
+	}
+
+	/* 
+	* Under RC mode, write to function specific register 0x43c, to change
+	* the CLASS code in configuration space 
+	*/
+	pci_bus_read_config_dword(&bus, devfn, 0x43c, &tmp32);
+	tmp32 = (tmp32 & 0xff0000ff) | (PCI_CLASS_BRIDGE_PCI << 8);
+	pci_bus_write_config_dword(&bus, devfn, 0x43c, tmp32);
+	/* 
+	* After this modification, the CLASS code in configuration space would be
+	* read as PCI_CLASS_BRIDGE_PCI(0x0604) instead of network interface(0x0200) 
+	*/
+
+
+	/* NS PAX only changes NLW field when card is present */
+        pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
+        pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_LNKSTA, &tmp16);
+
+	printk("PCIE%d: LINKSTA reg %#x val %#x\n", port->hw_pci.domain,
+		pos+PCI_EXP_LNKSTA, tmp16 );
+
+	nlw = (tmp16 & PCI_EXP_LNKSTA_NLW) >> PCI_EXP_LNKSTA_NLW_SHIFT ;
+	port->link = tmp16 & PCI_EXP_LNKSTA_DLLLA ;
+
+	if( nlw != 0 ) port->link = 1;
+
+	for( ; pos < 0x100; pos += 2 )
+		{
+        	pci_bus_read_config_word(&bus, devfn, pos , &tmp16);
+			if( tmp16 ) printk(KERN_DEBUG "reg[%#x]=%#x, ", pos , tmp16 );
+		}
+	if (nlw == 0)
+	{
+		/* try gen 1 */
+		pci_bus_read_config_dword(&bus, devfn, 0xdc, &tmp32);
+#if NS_PCI_DEBUG
+		printk("\nLink status control 2 register 0xdc: %08x\n", tmp32);
+#endif
+		if ((tmp32 & 0xf) == 2)
+		{
+			tmp32 &= 0xfffffff0;
+			tmp32 |= 0x1;
+			pci_bus_write_config_dword(&bus, devfn, 0xdc, tmp32);
+			pci_bus_read_config_dword(&bus, devfn, 0xdc, &tmp32);
+			mdelay(100);
+		/* NS PAX only changes NLW field when card is present */
+			pos = pci_bus_find_capability(&bus, devfn, PCI_CAP_ID_EXP);
+			pci_bus_read_config_word(&bus, devfn, pos + PCI_EXP_LNKSTA, &tmp16);
+			nlw = (tmp16 & PCI_EXP_LNKSTA_NLW) >> PCI_EXP_LNKSTA_NLW_SHIFT ;
+			port->link = tmp16 & PCI_EXP_LNKSTA_DLLLA ;
+#if NS_PCI_DEBUG
+			printk("Link status control 2 register 0xdc: %08x, nlw: %08x, port->link: %08x\n", tmp32, nlw, port->link);
+#endif
+			if( nlw != 0 ) port->link = 1;
+		}
+	}
+	printk("PCIE%d link=%d\n", port->hw_pci.domain,  port->link );
+
+	return( (port->link)? 0: -ENOSYS );
+}
+
+/*
+ * Initializte the PCIe controller
+ */
+static void __init soc_pcie_hw_init(struct soc_pcie_port * port)
+{
+	/* Turn-on Root-Complex (RC) mode, from reset defailt of EP */
+
+	/* The mode is set by straps, can be overwritten via DMU
+	   register <cru_straps_control> bit 5, "1" means RC
+	 */
+
+	/* Send a downstream reset */
+	__raw_writel( 0x3, port->reg_base + SOC_PCIE_CONTROL);
+	udelay(250);
+	__raw_writel( 0x1, port->reg_base + SOC_PCIE_CONTROL);
+	mdelay(250);
+
+	/* TBD: take care of PM, check we're on */
+}
+
+/*
+ * Setup the address translation
+ */
+static void __init soc_pcie_map_init(struct soc_pcie_port * port)
+{
+/*
+* Disabling the address translation won't disable PCI memory read/write function,
+* it just won't do address translation before or after PCIE memory transaction.
+*
+* As a PCIE RC driver, the OMAP/OARR could be disabled since we set OMAP/OARR
+* the same value of PCIE window range. This takes the same effect as no address 
+* translation.
+*
+* As a PCIE RC drive, the IMAP/IARR could be disabled and let the device decide which
+* address to write to. After all we have no idea about the device's intention.
+*
+* It seems only PCIE EP mode is required to set the OMAP/OARR/IMAP/IARR function.
+*
+* @ Setting of IMAP/IARR
+* 1. The setting of IMAP/IARR below is reversed, so the IMAP function is disabled 
+* actually(the valid bit is set to size and becomes 0). 
+* 2. We should take notice that the address shall be set to size-aligned, or the address
+* translation might not be what we expect. For example, if the size is set to 128M, 
+* the address should be set to 128M aligned.
+*/
+
+}
+
+/*
+ * Setup PCIE Host bridge
+ */
+static void __maybe_unused __init noinline soc_pcie_bridge_init(struct soc_pcie_port * port)
+{
+        u32 devfn = 0;
+        u8 tmp8;
+	u16 tmp16;
+
+	/* Fake <bus> object */
+        struct pci_sys_data sd = {
+                .domain = port->hw_pci.domain,
+        };
+        struct pci_bus bus = {
+                .number = 0,
+                .ops = &soc_pcie_ops,
+                .sysdata = &sd,
+        };
+
+
+	/*
+	* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, and PCI_SUBORDINATE_BUS would be
+	* set in ARM PCI enumeration process(pci_common_init). If connected to one 
+	* PCIe device only, the PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, and
+	* PCI_SUBORDINATE_BUS would be set to 0, 1, 1 respectively.
+	*/
+        pci_bus_write_config_byte(&bus, devfn, PCI_PRIMARY_BUS, 0);
+        pci_bus_write_config_byte(&bus, devfn, PCI_SECONDARY_BUS, 1);
+        pci_bus_write_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, 4);
+
+        pci_bus_read_config_byte(&bus, devfn, PCI_PRIMARY_BUS, &tmp8);
+        pci_bus_read_config_byte(&bus, devfn, PCI_SECONDARY_BUS, &tmp8);
+        pci_bus_read_config_byte(&bus, devfn, PCI_SUBORDINATE_BUS, &tmp8);
+
+	/* MEM_BASE, MEM_LIM require 1MB alignment */
+	BUG_ON( (port->owin_res->start   >> 16) & 0xf );
+	printk("%s: membase %#x memlimit %#x\n", __FUNCTION__,
+		port->owin_res->start, port->owin_res->end+1);
+        pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_BASE, 
+		port->owin_res->start   >> 16 );
+	BUG_ON(((port->owin_res->end+1) >> 16 ) & 0xf );
+        pci_bus_write_config_word(&bus, devfn, PCI_MEMORY_LIMIT, 
+		(port->owin_res->end) >> 16 );
+	/*
+	* Set resource->end to MEMORY_LIMIT instead of resource->end+1, 
+	* PCI bridge spec depicted that the upper 12 bits of both MEMORY_BASE and 
+	* MEMORY_LIMIT would be take as 0x###00000 and 0x###FFFFF respectively.
+	* ARM PCI enumeration process(pci_common_init) would set MEMORY_BASE and
+	* MEMORY_LIMIT(or PREF_MEMORY_BASE and PREF_MEMORY_LIMIT) to the total
+	* window size that's assigned to the devices.
+	*/
+
+
+	/* These registers are not supported on the NS */
+        pci_bus_write_config_word(&bus, devfn, PCI_IO_BASE_UPPER16, 0);
+        pci_bus_write_config_word(&bus, devfn, PCI_IO_LIMIT_UPPER16, 0);
+
+	/* Force class to that of a Bridge */
+        pci_bus_write_config_word(&bus, devfn, PCI_CLASS_DEVICE,
+		PCI_CLASS_BRIDGE_PCI);
+
+        pci_bus_read_config_word(&bus, devfn, PCI_CLASS_DEVICE, &tmp16);
+        pci_bus_read_config_word(&bus, devfn, PCI_MEMORY_BASE, &tmp16);
+        pci_bus_read_config_word(&bus, devfn, PCI_MEMORY_LIMIT, &tmp16);
+	
+}
+
+
+static int __init soc_pcie_init(void)
+{
+        unsigned i, j, k=0x210;;
+
+        for (i = 0; i < ARRAY_SIZE(soc_pcie_ports); i++)
+		{
+		struct soc_pcie_port * port = &soc_pcie_ports[i];
+		
+		/* Check if this port needs to be enabled */
+		if( ! port->enable )
+			continue;
+		/* Setup PCIe controller registers */
+		BUG_ON( request_resource( &iomem_resource, port->regs_res ));
+		port->reg_base =
+			ioremap( port->regs_res->start, 
+			resource_size(port->regs_res) );
+		BUG_ON( IS_ERR_OR_NULL(port->reg_base ));
+
+                soc_pcie_hw_init( port );
+		
+		/* 
+		* move soc_pcie_map_init after soc_pci_check_link function, 
+		* since soc_pci_check_link function would have a check on 
+		* RC or EP mode. And the soc_pcie_map_init function is trying
+		* to set the mapping address under RC mode.
+		*/
+		/* soc_pcie_map_init( port ); */
+
+		/*
+		* Skip inactive ports -
+		* will need to change this for hot-plugging
+		*/
+                if( soc_pcie_check_link( port ) != 0 )
+				{
+					continue;
+				}
+
+		port->msiAddress = kzalloc(4*1024, GFP_KERNEL);
+		if (port->msiAddress == NULL)
+		{
+			printk("%s: %d: Could not allocate 4k page for MSI\n", __FUNCTION__, __LINE__);
+			continue;
+		}
+		/* write the SYS_EQ_PAGE with 4k page */
+		__raw_writel(port->msiAddress, port->reg_base+0x200);
+
+		/* write the SYS_MSI_PAGE with msi address and enable it */
+		__raw_writel((port->msiAddress << 12), port->reg_base+0x204);
+
+		/* write the imap0_4 with msi address and enable it */
+
+		__raw_writel((port->msiAddress << 12) | 1, port->reg_base+0xC10);
+
+		/* write IARR_0 with this msi address for address translation */
+		__raw_writel((port->msiAddress << 15) | 1, port->reg_base+0xD00);
+
+		/* enable event queue for MSI */
+
+		for (j = 0; j < 6; j++)
+		{
+			printk("%s: %d k= %08x, port->regbase+k = %08x\n", __FUNCTION__, __LINE__, k, port->reg_base+k);
+			__raw_writel(1, port->reg_base+k);
+			k += 4;
+		}
+		/* set the offset back to beginning for the next pci-e controller port */
+
+		k = 0x210;
+
+		soc_pcie_map_init( port );
+
+		/*
+		* What's set in soc_pcie_bridge_init function are overwritten in pci 
+		* enumeration, and the value might be different to what's done in 
+		* this function. 
+		*/
+                /* soc_pcie_bridge_init( port ); */
+
+		/* Announce this port to ARM/PCI common code */
+                pci_common_init( & port->hw_pci );
+
+		/* Setup virtual-wire interrupts */
+		__raw_writel(0xf, port->reg_base + SOC_PCIE_SYS_RC_INTX_EN );
+        	}
+
+        pci_assign_unassigned_resources();
+
+        return 0;
+}
+
+static void soc_pcie_msi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned int i, j, k;
+    struct soc_pcie_port *port = NULL;
+	unsigned int headPtr, tailPtr;
+	
+	printk("%s: %d entry\n", __FUNCTION__, __LINE__);
+	for (i = 0; i <  ARRAY_SIZE(soc_pcie_ports); i++)
+	{
+		port = &soc_pcie_ports[i];
+		if ((irq >= port->irqs[0]) && (irq <= port->irqs[5]))
+			break;
+	}
+	if (port == NULL)
+	{
+		printk("%s: %d irq %d can not be seviced by any pci-e controller available\n", __FUNCTION__, __LINE__, irq);
+		return;
+	}
+	if (irq == port->irqs[0])
+	{
+		j = 0x250;
+		k = 0x254;
+	}
+	else if (irq == port->irqs[1])
+	{
+		j = 0x258;
+		k = 0x25C;
+	}
+	else if (irq == port->irqs[2])
+	{
+		j = 0x260;
+		k = 0x264;
+	}
+	else if (irq == port->irqs[3])
+	{
+		j = 0x268;
+		k = 0x26C;
+	}
+	else if (irq == port->irqs[4])
+	{
+		j = 0x270;
+		k = 0x274;
+	}
+	else if (irq == port->irqs[5])
+	{
+		j = 0x278;
+		k = 0x27C;
+	}
+	headPtr = __raw_readl(port->reg_base+j);
+	tailPtr = __raw_readl(port->reg_base+k);
+	if (headPtr != tailPtr)
+	{
+		__raw_writel(tailPtr, port->reg_base+j);
+		generic_handle_irq(irq);
+	}
+	printk("%s: %d exit\n", __FUNCTION__, __LINE__);
+}
+
+void destroy_irq(unsigned int irq)
+{
+	dynamic_irq_cleanup(irq);
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+static void soc_msi_nop(struct irq_data *d)
+{
+	return;
+}
+
+static struct irq_chip soc_iproc_msi_chip = {
+	.name = "PCI-MSI",
+	.irq_ack = soc_msi_nop,
+#ifdef CONFIG_PCI_MSI
+	.irq_enable = unmask_msi_irq,
+	.irq_disable = mask_msi_irq,
+	.irq_mask = mask_msi_irq,
+	.irq_unmask = unmask_msi_irq,
+# endif
+};
+
+
+
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int id, irq, ret;
+	unsigned int intVal, k=0x208;
+	struct msi_msg msg;
+    struct soc_pcie_port *port = soc_pcie_pdev2port(pdev);
+
+
+	printk("%s: %d irq: %d entry\n", __FUNCTION__, __LINE__, irq);
+	if (port == NULL)
+	{
+		printk("%s: %d Bad port\n", __FUNCTION__, __LINE__);
+		printk("%s: %d exit\n", __FUNCTION__, __LINE__);
+		return -ENODEV;
+	}
+	if (port->lastAssignedMSI > port->irqs[5])
+	{
+		printk("%s: %d no irq to assign\n", __FUNCTION__, __LINE__);
+		printk("%s: %d exit\n", __FUNCTION__, __LINE__);
+		return -ENODEV;
+	}
+	printk("%s: %d\n", __FUNCTION__, __LINE__);
+	irq = port->lastAssignedMSI;
+	if (irq < 0)
+		return irq;
+	printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+	dynamic_irq_init(irq);
+	printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+	port->lastAssignedMSI++;
+	printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+
+	ret = irq_set_msi_desc(irq, desc);
+	//ret = set_irq_msi(irq, desc);
+	printk("%s: %d irq: %d, ret: %08x \n", __FUNCTION__, __LINE__, irq, ret);
+
+	if (!ret)
+	{
+		msg.address_hi = 0x0;
+		printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+		msg.address_lo = port->msiAddress+(64 * 8 * (irq - port->irqs[0]));
+		printk("%s: %d irq: %d msg.address_lo: %08x\n", __FUNCTION__, __LINE__, irq, msg.address_lo);
+
+	#if 0
+		id = iop13xx_cpu_id();
+		msg.data = (id << IOP13XX_MU_MIMR_CORE_SELECT) | (irq & 0x7f);
+	#endif
+
+		msg.data = irq;
+
+		write_msi_msg(irq, &msg);
+		printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+
+		/*enable event queue interrupt for this interrupt */
+	#if 1
+		intVal = __raw_readl(port->reg_base+k);
+		printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+		if (irq == port->irqs[0])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 1;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		else if (irq == port->irqs[1])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 2;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		else if (irq == port->irqs[2])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 4;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		else if (irq == port->irqs[3])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 8;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		else if (irq == port->irqs[4])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 0x10;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		else if (irq == port->irqs[5])
+		{
+			printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+			intVal |= 0x20;
+			printk("%s: %d irq: %d intVal: %08x \n", __FUNCTION__, __LINE__, irq, intVal);
+			__raw_writel(intVal, port->reg_base+k);
+			intVal = __raw_readl(port->reg_base+k);
+			printk("%s: %d irq: %d intVal: %08x\n", __FUNCTION__, __LINE__, irq, intVal);
+		}
+		printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+		irq_set_chip_and_handler(irq, &soc_iproc_msi_chip, handle_simple_irq);
+		printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+		irq_set_chained_handler(irq, soc_pcie_msi_handler);
+		printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+		set_irq_flags(irq, IRQF_VALID);
+	}
+
+	printk("%s: %d irq: %d\n", __FUNCTION__, __LINE__, irq);
+	return 0;
+}
+#endif
+
+device_initcall(soc_pcie_init);
+
+#endif	/* CONFIG_PCI */
diff --git a/arch/arm/plat-iproc/platsmp.c b/arch/arm/plat-iproc/platsmp.c
new file mode 100644
index 0000000..47d7441
--- /dev/null
+++ b/arch/arm/plat-iproc/platsmp.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/cpumask.h>
+#include <linux/smp.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+
+#include <mach/io_map.h>
+#include <mach/memory.h>
+#include <mach/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/smp_scu.h>
+#include <asm/localtimer.h>
+#include <asm/io.h>
+
+/* Lookup table phys addr and offset */
+#define SOC_ROM_BASE_PA    0xFFFF0000
+#ifdef CONFIG_MACH_NS
+#define SOC_ROM_LUT_OFF    0x400
+#elif defined(CONFIG_MACH_HX4)
+#define SOC_ROM_LUT_OFF    0x42c
+#elif defined(CONFIG_MACH_HR2)
+#define SOC_ROM_LUT_OFF    0x400
+#elif defined(CONFIG_MACH_NSP)
+#define SOC_ROM_LUT_OFF    0x42c
+#elif defined(CONFIG_MACH_KT2)
+#define SOC_ROM_LUT_OFF    0x42c
+#else
+#error "SOC_ROM_LUT_OFF is not defined"
+#endif
+
+/* SCU base address */
+static void __iomem *scu_base = (void __iomem *)(IPROC_PERIPH_SCU_REG_VA);
+
+/*
+ * Use SCU config register to count number of cores
+ */
+static inline unsigned int get_core_count(void)
+{
+	if (scu_base)
+		return scu_get_core_count(scu_base);
+	return 1;
+}
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+static void __init iproc_smp_init_cpus(void)
+{
+unsigned int i, ncores = get_core_count();
+
+	printk(KERN_DEBUG "smp_init_cpus: Enter ncores %d\n", ncores);
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+	printk(KERN_DEBUG "smp_init_cpus: Leave ncores %d\n", ncores);
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+
+
+#ifdef CONFIG_BCM_IPROC_CA9_PREFETCH
+
+static void enable_a9_features(void) {
+    unsigned int a9_aux=0, a9_aux_m=0, a9_sys=0;
+    
+    // Read a9_aux Register
+    asm volatile ("MRC p15, 0, %0, c1, c0, 1\t\n": "=r"(a9_aux));
+
+    // Write a9_aux Register; L1/L2 prefetch enable & Fill line zero
+    asm volatile ("mcr p15, 0, %0, c1, c0, 1\t\n" : : "r"(a9_aux | (0x7 << 1)));
+
+    // Read a9_aux Register again
+    asm volatile ("MRC p15, 0, %0, c1, c0, 1\t\n": "=r"(a9_aux_m));
+
+    //System Control Register
+    asm volatile ("MRC p15, 0, %0, c1, c0, 0\t\n": "=r"(a9_sys));
+
+    printk(KERN_INFO "\n<%s> CUP_ID %d a9_aux = 0x%x; a9_aux_m = 0x%x; a9_sys = 0x%x\n", \ 
+            __FUNCTION__,  smp_processor_id(), a9_aux, a9_aux_m, a9_sys);
+}
+
+#endif
+
+
+static void __cpuinit iproc_secondary_init(unsigned int cpu)
+{
+	printk(KERN_DEBUG "platform_secondary_init: Enter cpu %d\n", cpu);
+
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	pen_release = -1;
+
+
+#ifdef CONFIG_BCM_IPROC_CA9_PREFETCH
+    enable_a9_features();
+    smp_call_function((void (*)(void))enable_a9_features, NULL, 0);
+#endif
+
+
+	smp_wmb();
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+
+	printk(KERN_DEBUG "platform_secondary_init: Leave pen_release %d\n", pen_release);
+}
+
+static int __cpuinit iproc_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	printk(KERN_DEBUG "boot_secondary: Enter CPU%d\n", cpu);
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	pen_release = cpu;
+	clean_dcache_area( (void *) &pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release),
+			  __pa(&pen_release + sizeof(pen_release)));
+	// flush_cache_all();
+
+	/*
+	 * Now the secondary CPU must start marching on its
+	 * own.
+	 */
+	dsb_sev();
+
+	/* wait at most 1 second for the secondary to wake up */
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+        	udelay(10);
+		clean_dcache_area( (void *) &pen_release, sizeof(pen_release));
+	}
+
+	/*
+	 * Now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	printk(KERN_DEBUG "boot_secondary: Leave pen-release %d\n", pen_release);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+
+static void __init wakeup_secondary(unsigned cpu, void (* _sec_entry_va)(void))
+{
+	void __iomem * rombase = NULL;
+	phys_addr_t lut_pa;
+	u32 offset;
+	u32 mask;
+	u32 val;
+
+	printk(KERN_DEBUG "wakeup_secondary: Enter cpu %d\n", cpu);
+
+	mask = (1UL << PAGE_SHIFT) -1;
+
+	lut_pa = SOC_ROM_BASE_PA & ~mask;
+	offset = SOC_ROM_BASE_PA &  mask;
+	offset += SOC_ROM_LUT_OFF;
+
+	rombase = ioremap(lut_pa, PAGE_SIZE);
+	if(rombase == NULL)
+		return;
+	val = virt_to_phys(_sec_entry_va);
+
+	writel(val, rombase + offset);
+
+        smp_wmb();      /* probably not needed - io regs are not cached */
+
+#ifdef  CONFIG_SMP
+        dsb_sev();      /* Exit WFI */
+#endif
+	mb();
+
+	iounmap(rombase);
+
+	printk(KERN_DEBUG "wakeup_secondary: Leave cpu %d\n", cpu);
+}
+
+
+static void __init iproc_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	/*
+	 * Initialise the SCU and wake up the secondary core using
+	 * wakeup_secondary().
+	 */
+	scu_enable(scu_base);
+	wakeup_secondary(max_cpus, iproc_secondary_startup);
+}
+
+struct smp_operations iproc_smp_ops __initdata = {
+	.smp_init_cpus		= iproc_smp_init_cpus,
+	.smp_prepare_cpus	= iproc_smp_prepare_cpus,
+	.smp_secondary_init	= iproc_secondary_init,
+	.smp_boot_secondary	= iproc_boot_secondary,
+};
+
diff --git a/arch/arm/plat-iproc/shm.c b/arch/arm/plat-iproc/shm.c
new file mode 100644
index 0000000..af80ed0
--- /dev/null
+++ b/arch/arm/plat-iproc/shm.c
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "include/plat/shm.h"
+
+
+/**
+ *	iproc_platform_get_resource -
+ *           wrapper function for platform_get_resource
+ *	@dev: platform device
+ *	@type: resource type
+ *	@num: resource index
+ */
+struct resource *
+iproc_platform_get_resource(struct platform_device *dev, unsigned int type,
+		      unsigned int num)
+{
+	return platform_get_resource(dev, type, num);
+}
+EXPORT_SYMBOL(iproc_platform_get_resource);
+
+
+/**
+ *	iproc_platform_driver_register -
+ *           wrapper function for platform_driver_register
+ *	@drv: platform driver structure
+ */
+int iproc_platform_driver_register(struct platform_driver *drv)
+{
+	return platform_driver_register(drv);
+}
+EXPORT_SYMBOL(iproc_platform_driver_register);
+
+
+/**
+ *	iproc_platform_driver_unregister
+ *           wrapper function for platform_driver_unregister
+ *	@drv: platform driver structure
+ */
+void iproc_platform_driver_unregister(struct platform_driver *drv)
+{
+	return platform_driver_unregister(drv);
+}
+EXPORT_SYMBOL(iproc_platform_driver_unregister);
+
+
+/**
+ *      iproc_platform_device_register - add a platform-level device
+ *          wrapper function for platform_device_register
+ *      @pdev:  platform device we're adding
+ *
+ */
+int iproc_platform_device_register(struct platform_device * pdev)
+{
+        return platform_device_register(pdev);
+}
+EXPORT_SYMBOL(iproc_platform_device_register);
+
+
+/**
+ *	iproc_platform_device_unregister -
+ *          wrapper function for platform_device_unregister
+ *	@pdev:	platform device we're unregistering
+ */
+void iproc_platform_device_unregister(struct platform_device * pdev)
+{
+	return platform_device_unregister(pdev);
+}
+EXPORT_SYMBOL(iproc_platform_device_unregister);
diff --git a/arch/arm/plat-iproc/swreset_rec.c b/arch/arm/plat-iproc/swreset_rec.c
new file mode 100644
index 0000000..c4cb090
--- /dev/null
+++ b/arch/arm/plat-iproc/swreset_rec.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <asm/io.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <mach/io_map.h>
+#include <mach/reg_utils.h>
+#include <plat/swreset_rec.h>
+
+#define MAX_SWRESET_RECORD_COUNT        (4)
+
+struct swreset_record {
+    int position;
+};
+
+struct swreset_record records[MAX_SWRESET_RECORD_COUNT];
+static unsigned int record_count;
+static unsigned int record_width;
+static DEFINE_SPINLOCK(swrr_lock); 
+
+unsigned int
+swreset_record_get_record_width(void)
+{
+    return record_width;
+}
+
+unsigned int
+swreset_record_get_record_count(void)
+{
+    return record_count;
+}
+
+SWRR_HANDLE
+swreset_record_register(const char *name)
+{
+    int i;
+    int j;
+    
+    if (record_count == 0) {
+        return NULL;
+    }
+    
+    /* Use the name as a hash value to try to avoid race condition */
+    j = 0;
+    while(*name != 0) {
+        j += *name;
+        if (j > 0xff)
+            j = (j & 0xff) + 1;
+        name++;
+    }
+
+    for(i=0; i<record_count; i++, j++) {
+        j = j % record_count;
+        if (records[j].position == -1) {
+            records[j].position = j;
+            return (SWRR_HANDLE)&records[j];
+        }
+    }
+
+    return NULL;
+}
+
+void
+swreset_record_unregister(SWRR_HANDLE handle)
+{
+    struct swreset_record *swrr = (struct swreset_record *)handle;
+    if (handle == NULL)
+        return;
+    if (swrr->position < 0 || swrr->position >= record_count)
+        return;
+    swrr->position = -1;
+}
+
+int
+swreset_record_set(SWRR_HANDLE handle, int value)
+{
+    struct swreset_record *swrr = (struct swreset_record *)handle;
+    void __iomem *reg;
+    unsigned long rval;
+    unsigned long flags;
+    
+    if (handle == NULL)
+        return -1;
+    if (swrr->position < 0 || swrr->position >= record_count)
+        return -1;
+    if (value & ~((1 << record_width) - 1))
+        return -1;
+        
+    /* This requires atomic operation */
+    spin_lock_irqsave(&swrr_lock, flags);
+    
+    /* CoStar specific; could require modification for newer chips */
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_CLKSET_KEY_OFFSET);
+    writel(0xea68, reg); /* magic number */
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_GENPLL_CONTROL5_OFFSET);
+    writel(readl(reg) | (1 << IPROC_DMU_GENPLL_CONTROL5__SEL_SW_SETTING), reg);
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_GENPLL_CONTROL7_OFFSET);
+    rval = readl(reg) & ~(1 << (IPROC_DMU_GENPLL_CONTROL7__SW_RESET_REC + swrr->position));
+    rval |= value << (IPROC_DMU_GENPLL_CONTROL7__SW_RESET_REC + swrr->position);
+    writel(rval, reg);
+    
+    spin_unlock_irqrestore(&swrr_lock, flags);
+    return 0;
+}
+
+int
+swreset_record_get(SWRR_HANDLE handle, int *value)
+{
+    struct swreset_record *swrr = (struct swreset_record *)handle;
+    void __iomem *reg;
+    unsigned long flags;
+    
+    if (handle == NULL)
+        return -1;
+    if (swrr->position < 0 || swrr->position >= record_count)
+        return -1;
+    if (value == NULL)
+        return 0;
+
+    /* This requires atomic operation */
+    spin_lock_irqsave(&swrr_lock, flags);
+    
+    /* CoStar specific; could require modification for newer chips */
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_CLKSET_KEY_OFFSET);
+    writel(0xea68, reg); /* magic number */
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_GENPLL_CONTROL5_OFFSET);
+    writel(readl(reg) | (1 << IPROC_DMU_GENPLL_CONTROL5__SEL_SW_SETTING), reg);
+    reg = IOMEM(IPROC_DMU_BASE_VA + IPROC_DMU_GENPLL_CONTROL7_OFFSET);
+    *value = readl(reg) >> IPROC_DMU_GENPLL_CONTROL7__SW_RESET_REC;
+    *value = (*value >> swrr->position) & 1;
+    
+    spin_unlock_irqrestore(&swrr_lock, flags);
+    return 0;
+}
+
+int __init
+init_swreset_records(void)
+{
+    int i;
+    for(i=0; i<MAX_SWRESET_RECORD_COUNT; i++) {
+        records[i].position = -1;
+    }
+
+    /* Currently it's only supported on CoStar */
+    if ((readl(IOMEM(IPROC_CCA_CORE_REG_VA)) & 0xffff) == 0xcf1a) {
+        record_count = IPROC_DMU_GENPLL_CONTROL7__SW_RESET_REC_WIDTH;
+        record_width = 1;   /* 1 bit per record */
+    } else {
+        record_count = 0;
+        record_width = 0;
+    }
+    return 0;
+}
+
+early_initcall(init_swreset_records);
+EXPORT_SYMBOL(swreset_record_get_record_count);
+EXPORT_SYMBOL(swreset_record_get_record_width);
+EXPORT_SYMBOL(swreset_record_register);
+EXPORT_SYMBOL(swreset_record_unregister);
+EXPORT_SYMBOL(swreset_record_set);
+EXPORT_SYMBOL(swreset_record_get);
diff --git a/arch/arm/plat-iproc/sysfs.c b/arch/arm/plat-iproc/sysfs.c
new file mode 100644
index 0000000..3b1635e
--- /dev/null
+++ b/arch/arm/plat-iproc/sysfs.c
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * SYSFS infrastructure specific Broadcom SoCs
+ */
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/sysfs.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+
+struct kobject *bcm_kobj;
+
+static ssize_t
+mem_store(struct device *dev, struct device_attribute *attr,
+      const char *buf, size_t n)
+{
+    uint32_t addr, val, count = 0, loop = 0;
+    void __iomem *vaddr;
+    char rw;
+
+    if (sscanf(buf, "%c %x %x", &rw, &addr, &val) == 3) {
+        pr_info("\n");
+        vaddr = ioremap(addr, PAGE_SIZE);
+        if (rw == 'W' || rw == 'w') {
+            writel(val, vaddr);
+            count = 4;
+        } else if (rw == 'R' || rw == 'r') {
+            count = val;    /* count read in val for simplicity */
+            if (count & 0x3)    /* Align to 4 */
+                count += (4 - (count & 0x3));
+        }
+        for (; loop < count; loop += 4) {
+            val = readl(vaddr + loop);
+            pr_info("[0x%08x] = 0x%08x\n", addr + loop, val);
+        }
+        iounmap(vaddr);
+        return n;
+    }
+    pr_info("\nUsage: echo <R - Read/W - write> <Physical Address>"
+        "<Value(Write)/Count(Read) > /sys/bcm/mem\n"
+        "E.g. echo R 0x88CE000 0x40 > /sys/bcm/mem\n"
+        "     echo w 0x88CE000 0xDEADBEAF > /sys/bcm/mem\n");
+    return -EINVAL;
+}
+
+#ifdef CONFIG_IPROC_TIMER_UNIT_TESTS
+static ssize_t
+iproc_timer_module_cfg(struct device *dev, struct device_attribute *attr,
+      const char *buf, size_t n)
+{
+    char         name[255];
+    unsigned int rate; 
+
+    if (sscanf(buf, "%s %d", name, &rate) == 2) {
+
+        pr_info("timer name:%s rate(0-32KHz, 1-1MHz, 2-19.5MHz):%d \r\n",
+                name, rate);
+
+        /* 
+         * Assuming that iproc_timer_modules_init has happend already (this is
+         * safe because this function is called during system timer init
+         * itself
+         */
+        if ( iproc_timer_module_set_rate(name,rate) < 0) {
+            pr_err("iproc_timer_module_cfg: Unable to set the said rate \r\n");
+            return n;
+        }
+
+        pr_info("iproc_timer_module_cfg: Configured the module with"
+        "rate %d \r\n", rate);
+
+        return n;
+    }        
+
+    pr_info("\r\nusage: echo [timer_name(aon-timer/slave-timer)]"
+    "[rate (0-32KHz, 1-1MHz, 2-19.5MHz)] > /sys/bcm/timer_module_cfg \r\n");
+
+    return -EINVAL;
+}
+
+struct iproc_timer *kt;
+struct timer_ch_cfg cfg;
+int timer_callback (void *p);
+
+/* Note that this is called back from ISR context */
+int timer_callback (void *p)
+{
+    pr_info("timer callback \r\n");
+    return 0;
+}
+
+static ssize_t
+iproc_timer_start_test(struct device *dev, struct device_attribute *attr,
+      const char *buf, size_t n)
+{
+    unsigned int ch_num, mode, count; 
+    char name[255];
+
+    if (sscanf(buf, "%s %d %d %d", name, &ch_num, &mode, &count) == 4) {
+
+        pr_info("channel_num:%d mode(0-periodic 1-oneshot):%d count:%d \r\n",
+                ch_num, mode, count);
+
+        if ( (kt=iproc_timer_request (name, ch_num)) < 0) {
+            pr_err("iproc_timer_request returned error \r\n");
+            goto out;
+        }
+
+        cfg.mode = mode;
+        cfg.arg  = kt;
+        cfg.cb     = timer_callback;
+        cfg.reload = count;
+
+        if ( iproc_timer_config(kt,&cfg) < 0) {
+            pr_err("iproc_timer_config returned error \r\n");
+            goto out;
+        }
+
+        if (iproc_timer_set_match_start(kt,count) < 0) {
+            pr_err("iproc_timer_set_match_start returned error \r\n");
+            goto out;
+        }
+        pr_info("Timer test started \r\n");
+out:
+        return n;
+    }
+
+    pr_info("\r\nusage: echo [name (aon-timer/slave-timer)] "
+            "[channel num (0-3)] [mode(0-periodic"
+            "1-oneshot)] [count value] > /sys/bcm/timer_start_test\r\n");
+    return -EINVAL;
+}
+
+static ssize_t
+iproc_timer_stop_test(struct device *dev, struct device_attribute *attr,
+      const char *buf, size_t n)
+{
+    unsigned int ch_num; 
+
+    if (sscanf(buf, "%d", &ch_num) == 1) {
+        pr_info("channel_num:%d    \r\n", ch_num);
+        if (iproc_timer_stop(kt) < 0) {
+            pr_err("Unable to stop the timer iproc_timer_stop "
+                   "returned error \r\n");
+            goto out;
+        }
+
+        if (iproc_timer_free(kt) < 0) {
+            pr_err("Unable to free the timer \r\n");
+            goto out;
+        }
+        pr_info("Stopped and freed the timer \r\n");
+out:
+        return n;
+    } 
+
+    pr_info("\r\nusage: echo [channel num (0-3)] > "
+            "/sys/bcm/timer_stop_test\r\n");
+    return -EINVAL;
+}
+#endif
+
+static DEVICE_ATTR(mem, 0644, NULL, mem_store);
+
+#ifdef CONFIG_IPROC_TIMER_UNIT_TESTS
+static DEVICE_ATTR(timer_module_cfg, 0666, NULL, iproc_timer_module_cfg);
+static DEVICE_ATTR(timer_start_test, 0666, NULL, iproc_timer_start_test);
+static DEVICE_ATTR(timer_stop_test, 0666, NULL, iproc);
+#endif
+
+static struct attribute *bcm_attrs[] = {
+    &dev_attr_mem.attr,
+#ifdef CONFIG_IPROC_TIMER_UNIT_TESTS
+    &dev_attr_timer_module_cfg.attr,
+    &dev_attr_timer_start_test.attr,
+    &dev_attr_timer_stop_test.attr,
+#endif
+    NULL,
+};
+
+static struct attribute_group bcm_attr_group = {
+    .attrs = bcm_attrs,
+};
+
+static int __init bcm_sysfs_init(void)
+{
+    bcm_kobj = kobject_create_and_add("bcm", NULL);
+    if (!bcm_kobj)
+        return -ENOMEM;
+    return sysfs_create_group(bcm_kobj, &bcm_attr_group);
+}
+
+static void __exit bcm_sysfs_exit(void)
+{
+    sysfs_remove_group(bcm_kobj, &bcm_attr_group);
+}
+
+module_init(bcm_sysfs_init);
+module_exit(bcm_sysfs_exit);
diff --git a/arch/arm/plat-iproc/timer-sp.c b/arch/arm/plat-iproc/timer-sp.c
new file mode 100644
index 0000000..e364815a
--- /dev/null
+++ b/arch/arm/plat-iproc/timer-sp.c
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <mach/io_map.h>
+
+#include <asm/clkdev.h>
+//#include <mach/clkdev.h>
+#include <asm/hardware/arm_timer.h>
+
+#include <plat/timer-sp.h>
+
+/*
+ * These timers are currently setup to be clocked at 50MHz.
+ */
+#define ONE_MHZ			(1000000)
+#define TIMER_FREQ_HZ		(ONE_MHZ * 500)
+#define TIMER_FREQ_KHZ		(TIMER_FREQ_HZ/1000)
+#define TIMER_MIN_RANGE		4
+
+#define TIM_COUNT_LO		0x00            /* ACVR rw */
+#define TIM_COUNT_HI		0x04            /* ACVR ro */
+#define TIMER_CTRL		0x08            /* ACVR rw */
+#define TIMER_INT_STAT		0x0C
+#define TIMER_COMP_LO		0x10
+#define TIMER_COMP_HI		0x14
+#define TIMER_RELOAD		0x18
+#define TIMER_CTRL_PRESC_SHFT   (8)             /* ACVR */
+
+#define TIMER_ENABLE		(1 << 0)        /* ACVR */
+#define TIMER_CMP		(1 << 1)
+#define TIMER_IRQ		(1 << 2)
+#define TIMER_AUTO		(1 << 3)
+
+extern unsigned long clk_get_rate(struct clk *clk);
+
+static void __iomem *clksrc_base;
+static u32 ticks_per_jiffy;
+static u32 timer_ints = 0;
+static unsigned long cpu_clk_freq = 0;
+
+static cycle_t iproc_read(struct clocksource *cs)
+{
+	u32 hi;
+	u32 lo;
+	u32 ho;
+	u64 count;
+
+	/*
+	 * Read the upper half to detect a roll-over count
+	 */
+	do {
+		hi = readl(clksrc_base + TIM_COUNT_HI);
+		lo = readl(clksrc_base + TIM_COUNT_LO);
+		ho = readl(clksrc_base + TIM_COUNT_HI);
+	} while(hi != ho);
+
+	count = (u64) hi << 32 | lo;
+	return count;
+
+}
+static void iproc_set_mode(enum clock_event_mode mode,
+        struct clock_event_device *evt);
+
+static int iproc_set_next_event(unsigned long next,
+        struct clock_event_device *evt);
+static struct clock_event_device iproc_clockevent = {
+        .name           = "iproc_gtimer",
+        .shift          = 20,
+        .features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+        .set_mode       = iproc_set_mode,
+        .set_next_event = iproc_set_next_event,
+        .rating         = 300,
+        .cpumask        = cpu_all_mask,
+};
+
+
+static struct clocksource clocksource_iproc = {
+	.name		= "iproc_gtimer",
+	.rating		= 300,
+	.read		= iproc_read,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.shift		= 20,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+extern void setup_sched_clock(u32 (*read)(void), int bits, unsigned long rate);
+static u32 notrace read_sched_clock(void)
+{
+        return iproc_read(&clocksource_iproc);
+}
+void __init iproc_clocksource_init(void __iomem *base)
+{
+	struct clocksource *cs = &clocksource_iproc;
+	struct clk *clk;
+        int ret;
+
+	clksrc_base = base;
+
+        /*
+	 * setup global CPU timer as free-running clocksource
+	 * obtain CPU clock frequency from clock module configuration
+	 */
+	clk = clk_get_sys(NULL, "periph_clk");
+	BUG_ON(IS_ERR_OR_NULL(clk));
+        clk_prepare_enable(clk);
+	cpu_clk_freq = clk_get_rate(clk);
+	BUG_ON(!cpu_clk_freq);
+
+
+	printk(KERN_DEBUG
+		"iproc_clocksource_init: CPU global timer freq %d\n",
+		cpu_clk_freq);
+
+	// ref - arch/arcm/mach-u300/timer.c (2.6.37 vs 2.6.38)
+	clocksource_register_hz(cs, cpu_clk_freq);
+
+}
+
+
+static void __iomem *clkevt_base;
+
+/*
+ * IRQ handler for the timer
+ */
+ irqreturn_t iproc_timer_interrupt(int irq, void *dev_id)
+{
+       struct clock_event_device *evt = &iproc_clockevent;
+#warning "iproc_timer_interrupt: Fix this code to receive clock_event handler correctly"
+
+	/* clear the interrupt */
+	writel(1, clkevt_base + TIMER_INT_STAT);
+
+	timer_ints++;
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static void iproc_set_mode(enum clock_event_mode mode,
+	struct clock_event_device *evt)
+{
+	u32 ctrl;
+	u32 period;
+	u64 count;
+
+	ctrl = readl(clkevt_base + TIMER_CTRL);
+
+	/* Clear mode bits */
+	ctrl &= ~(TIMER_CMP | TIMER_IRQ | TIMER_AUTO);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		writel(ctrl, clkevt_base + TIMER_CTRL);
+		period = ticks_per_jiffy;
+		count = iproc_read(NULL);
+		count += period;
+		writel(ctrl, clkevt_base + TIMER_CTRL);
+		writel(period, clkevt_base + TIMER_RELOAD);
+		ctrl =  (TIMER_CMP  |
+			 TIMER_IRQ  |
+			 TIMER_AUTO |
+			 TIMER_ENABLE);
+		break;
+
+	case CLOCK_EVT_MODE_ONESHOT:
+		/* period set, and timer enabled in 'next_event' hook */
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		break;
+	default:
+		break;
+	}
+
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+}
+
+static int iproc_set_next_event(unsigned long next,
+	struct clock_event_device *evt)
+{
+	u64 count = iproc_read(NULL);
+	u32 ctrl  = readl(clkevt_base + TIMER_CTRL);
+
+	ctrl &= ~TIMER_CMP;
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+
+	count += next;
+	writel(count & 0xffffffffUL,    clkevt_base + TIMER_COMP_LO);
+	//writel(count, clkevt_base + TIM_COUNT_LO);
+	writel(count >> 32, clkevt_base + TIMER_COMP_HI);
+
+	ctrl |= (TIMER_CMP | TIMER_IRQ);
+	writel(ctrl, clkevt_base + TIMER_CTRL);
+
+	return 0;
+}
+
+static struct irqaction iproc_timer_irq = {
+	.name		= "iproc_gtimer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_PERCPU,
+	.handler	= iproc_timer_interrupt,
+	.dev_id		= &iproc_clockevent,
+        .irq = BCM_INT_ID_PPI11,
+};
+
+void __init iproc_clockevents_init(void __iomem *base, unsigned int timer_irq)
+{
+        int ret;
+	clkevt_base = base;
+	ticks_per_jiffy = (cpu_clk_freq/HZ);
+
+        clockevents_calc_mult_shift(&iproc_clockevent, cpu_clk_freq, TIMER_MIN_RANGE);
+        iproc_clockevent.max_delta_ns =
+                clockevent_delta2ns(0x1fffffff, &iproc_clockevent);
+        iproc_clockevent.min_delta_ns =
+                clockevent_delta2ns(0xf, &iproc_clockevent);
+        iproc_clockevent.cpumask = cpumask_of(0);
+        iproc_clockevent.irq = timer_irq;
+        clockevents_register_device(&iproc_clockevent);
+#warning "iproc_clockevents_init: Fix this code to enable timer irq and pass clock_event handler correctly"
+        ret = setup_percpu_irq(timer_irq, &iproc_timer_irq);
+        if (ret) {
+                printk(KERN_ERR "Failed to register timer IRQ: %d\n", ret);
+                BUG();
+        }
+
+        printk(KERN_DEBUG "cpu_clk_freq: %d\n", cpu_clk_freq);
+        printk(KERN_DEBUG "HZ: %d, ticks_per_jiffy: %d\n", HZ, ticks_per_jiffy);
+
+        enable_percpu_irq(timer_irq, 0);
+
+}
diff --git a/arch/arm/plat-iproc/timer.c b/arch/arm/plat-iproc/timer.c
new file mode 100644
index 0000000..636e0b3
--- /dev/null
+++ b/arch/arm/plat-iproc/timer.c
@@ -0,0 +1,280 @@
+/*
+ * Copyright (C) 2013, Broadcom Corporation. All Rights Reserved.
+ * 
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/clockchips.h>
+#include <linux/types.h>
+
+#include <asm/smp_twd.h>
+#include <asm/mach/time.h>
+#include <mach/io.h>
+#include <mach/io_map.h>
+#include <mach/iproc_timer.h>
+#include <mach/timer.h>
+#include <mach/iproc_regs.h>
+
+#ifdef CONFIG_LOCAL_TIMERS
+#include <asm/smp_twd.h>
+#endif
+
+static struct iproc_timer *gpt_evt = NULL;
+static struct iproc_timer *gpt_src = NULL;
+static void __iomem*    proftmr_regbase = IOMEM(IPROC_CCU_PROF_CTL_REG_VA);
+
+static int gptimer_set_next_event(unsigned long clc,
+        struct clock_event_device *unused)
+{
+    /* gptimer (0) is disabled by the timer interrupt already
+     * so, here we reload the next event value and re-enable
+     * the timer
+     *
+     * This way, we are potentially losing the time between
+     * timer-interrupt->set_next_event. CPU local timers, when
+     * they come in should get rid of skew 
+     */
+    iproc_timer_set_match_start(gpt_evt,clc);
+    return 0;
+}
+
+static void gptimer_set_mode(enum clock_event_mode mode,
+                   struct clock_event_device *unused)
+{
+    switch (mode) {
+    case CLOCK_EVT_MODE_ONESHOT:
+        /* by default mode is one shot don't do any thing */
+        break;
+    case CLOCK_EVT_MODE_UNUSED:
+    case CLOCK_EVT_MODE_SHUTDOWN:
+    default:
+        iproc_timer_disable_and_clear(gpt_evt);
+    }
+}
+
+static cycle_t gptimer_clksrc_read (struct clocksource *cs)
+{
+    unsigned long msw, lsw;
+    cycle_t    count = 0;
+
+    iproc_timer_get_counter (gpt_src, &msw, &lsw);
+    count = ((cycle_t)msw << 32) | (cycle_t)lsw;
+    return count;
+}
+
+static struct clock_event_device clockevent_gptimer = {
+    .name            = "gpt_event_1",
+    .features        = CLOCK_EVT_FEAT_ONESHOT,
+    .shift           = 32,
+    .set_next_event  = gptimer_set_next_event,
+    .set_mode        = gptimer_set_mode
+};
+
+static struct clocksource clksrc_gptimer = {
+    .name    = "gpt_source_2",
+    .rating  = 200,
+    .read    = gptimer_clksrc_read,
+    .mask    = CLOCKSOURCE_MASK(64),
+    .shift   = 16,
+    .flags   = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init gptimer_clockevents_init(void)
+{
+    clockevent_gptimer.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC,
+                        clockevent_gptimer.shift);
+
+    clockevent_gptimer.max_delta_ns =
+        clockevent_delta2ns(0xffffffff, &clockevent_gptimer);
+
+    clockevent_gptimer.min_delta_ns =
+        clockevent_delta2ns(6, &clockevent_gptimer);
+
+    clockevent_gptimer.cpumask = cpumask_of(0);
+    clockevents_register_device(&clockevent_gptimer);
+}
+
+static void __init gptimer_clocksource_init(void)
+{
+    clksrc_gptimer.mult = clocksource_hz2mult(CLOCK_TICK_RATE, 
+        clksrc_gptimer.shift);
+    clocksource_register(&clksrc_gptimer);
+    return;
+}
+
+static int gptimer_interrupt_cb(void *dev)
+{
+    struct clock_event_device *evt = (struct clock_event_device *)dev;
+    evt->event_handler(evt);
+    return 0;
+}
+
+static void profile_timer_init(void __iomem *base)
+{
+    uint32_t reg;
+
+    /* Reset profile/global timer */
+    writel(0, base + IPROC_GTIM_GLB_CTL);
+
+    /* Clear pending interrupts */
+    reg = readl(base + IPROC_GTIM_GLB_STS);
+    reg &= ~(IPROC_GLB_TIM_CTRL_PRESC_MASK);
+    reg |= (1 << GLBTMR_GLOB_STATUS_EVENT_G_SHIFT);
+    writel(reg, base + IPROC_GTIM_GLB_STS);
+
+    /* Enable profile timer now with
+     * prescaler = 0, so timer freq = A9 PERIPHCLK 
+     * IRQ disabled
+     * Comapre disabled
+     */
+
+    reg = readl(base + IPROC_GTIM_GLB_CTL);
+    reg &= ~(IPROC_GLB_TIM_CTRL_PRESC_MASK);
+    reg |= (1 << GLBTMR_GLOB_CTRL_TIMER_EN_G_SHIFT);
+    writel(reg, base + IPROC_GTIM_GLB_CTL);
+}
+
+static void
+profile_timer_get_counter(void __iomem *base, uint32_t *msw, uint32_t *lsw)
+{
+    /* Read 64-bit free running counter
+     * 1. Read hi-word
+     * 2. Read low-word
+     * 3. Read hi-word again
+     * 4.1 
+     *     if new hi-word is not equal to previously read hi-word, then
+     *     start from #1
+     * 4.2
+     *     if new hi-word is equal to previously read hi-word then stop.
+     */
+
+    while (1) {
+        *msw = readl(base + IPROC_GTIM_GLB_HI);
+        *lsw = readl(base + IPROC_GTIM_GLB_LO);
+        if (*msw == readl(base + IPROC_GTIM_GLB_HI))
+            break;
+    }
+
+    return;
+}
+
+static void __init timers_init(struct gp_timer_setup *gpt_setup)
+{
+    struct timer_ch_cfg evt_tm_cfg;
+
+    iproc_timer_modules_init ();
+    iproc_timer_module_set_rate(gpt_setup->name, gpt_setup->rate);
+    
+    /* Initialize Event timer */
+    gpt_evt = iproc_timer_request(gpt_setup->name, gpt_setup->ch_num);
+    if (gpt_evt == NULL) {
+        pr_err("timers_init: Unable to get GPT timer for event\r\n");
+    }
+
+    pr_info("timers_init: === SYSTEM TIMER NAME: %s CHANNEL NUMBER %d \
+    RATE (0-32KHz, 1-1MHz) %d \r\n",gpt_setup->name, 
+    gpt_setup->ch_num, gpt_setup->rate);
+
+    evt_tm_cfg.mode =  MODE_PERIODIC;
+    evt_tm_cfg.arg = &clockevent_gptimer;
+    evt_tm_cfg.cb = gptimer_interrupt_cb;
+
+    iproc_timer_config(gpt_evt, &evt_tm_cfg);
+
+    gptimer_set_next_event((CLOCK_TICK_RATE / HZ), NULL);
+
+    /* 
+     * IMPORTANT
+     * Note that we don't want to waste a channel for clock source. In iProc
+     * timer module by default there is a counter that keeps counting
+     * irrespective of the channels. So instead of implementing a periodic
+     * timer using a channel (which in the HW is not peridoic) we can
+     * simply read the counters of the timer that is used for event and
+     * send it for source. The only catch is that this timer should not be
+     * stopped by PM or any other sub-systems.
+     */
+     gpt_src = gpt_evt;
+
+    /* Initialize the profile timer */
+
+    return ;
+}
+
+void __init iproc_timer_init(struct gp_timer_setup *gpt_setup)
+{
+    timers_init(gpt_setup);
+    gptimer_clocksource_init();
+    gptimer_clockevents_init();
+    gptimer_set_next_event((CLOCK_TICK_RATE / HZ), NULL);
+#ifdef CONFIG_LOCAL_TIMERS
+        twd_base = IOMEM(IPROC_PERIPH_PVT_TIM_REG_VA);
+#endif
+
+}
+
+
+/* Profile timer implementations */
+
+/* 
+ * TODO: The below profile timer code is retained as it is.
+ * The clock manager is not up yet, once its ready read the 
+ * correct frequency from it.  
+ *
+ * Right now Global timer runs at 5000000 on FPGA (A9 PERIPHCLK)
+ * Ideally, this should be derived by timer.prof_clk and
+ * prescaler.
+ */
+
+#define GLOBAL_TIMER_FREQ_HZ    (351875) /* For FPGA only, (temp)*/
+//#define GLOBAL_TIMER_FREQ_HZ    (500000) /* For FPGA only, (temp)*/
+timer_tick_rate_t timer_get_tick_rate(void)
+{
+    uint32_t prescaler;
+
+    prescaler = readl(IPROC_PERIPH_GLB_TIM_REG_BASE);
+    prescaler &= IPROC_GLB_TIM_CTRL_PRESC_MASK;
+    //prescaler >>= IPROC_GLB_TIM_CTRL_PRESC_SHIFT;
+
+    return (GLOBAL_TIMER_FREQ_HZ / (1 + prescaler)); 
+}
+
+timer_tick_count_t timer_get_tick_count(void)
+{
+    uint32_t msw, lsw;
+    uint64_t tick;
+
+    profile_timer_get_counter(proftmr_regbase, &msw, &lsw);
+
+    tick = (((uint64_t)msw << 32) | ((uint64_t)lsw));
+
+    return (*(uint32_t *)(&tick));
+}
+
+timer_msec_t timer_ticks_to_msec(timer_tick_count_t ticks)
+{
+    return (ticks / (timer_get_tick_rate() / 1000));
+}
+
+timer_msec_t timer_get_msec(void)
+{
+    return timer_ticks_to_msec(timer_get_tick_count());
+}
+
+EXPORT_SYMBOL(timer_get_tick_count);
+EXPORT_SYMBOL(timer_ticks_to_msec);
+EXPORT_SYMBOL(timer_get_tick_rate);
+EXPORT_SYMBOL(timer_get_msec);
-- 
1.7.5.4

