From 6e54d6544d468432e18fc509829d44b1804376a9 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 7 Dec 2012 15:51:55 +0800
Subject: [PATCH 2/2] wireless: wl12xx: update wl_lock with raw_spin_lock

wl12xx_hardirq shares wl_clock with thread handler and
other wl12xx utils, this is an ugly design, so we have
to change wl_lock from spin_lock to raw_spin_lock since
spin_lock should not be used in hardware irq handler.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/wireless/wl12xx/cmd.c    |    8 ++++----
 drivers/net/wireless/wl12xx/main.c   |   32 ++++++++++++++++----------------
 drivers/net/wireless/wl12xx/ps.c     |   12 ++++++------
 drivers/net/wireless/wl12xx/tx.c     |   20 ++++++++++----------
 drivers/net/wireless/wl12xx/wl12xx.h |    2 +-
 5 files changed, 37 insertions(+), 37 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/cmd.c b/drivers/net/wireless/wl12xx/cmd.c
index 3414fc1..a674239 100644
--- a/drivers/net/wireless/wl12xx/cmd.c
+++ b/drivers/net/wireless/wl12xx/cmd.c
@@ -465,10 +465,10 @@ int wl12xx_allocate_link(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 *hlid)
 		return -EBUSY;
 
 	/* these bits are used by op_tx */
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	__set_bit(link, wl->links_map);
 	__set_bit(link, wlvif->links_map);
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 	*hlid = link;
 	return 0;
 }
@@ -481,10 +481,10 @@ void wl12xx_free_link(struct wl1271 *wl, struct wl12xx_vif *wlvif, u8 *hlid)
 		return;
 
 	/* these bits are used by op_tx */
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	__clear_bit(*hlid, wl->links_map);
 	__clear_bit(*hlid, wlvif->links_map);
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	/*
 	 * At this point op_tx() will not add more packets to the queues. We
diff --git a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
index bea5e23..268f551 100644
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -949,17 +949,17 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 			wl12xx_rx(wl, wl->fw_status);
 
 			/* Check if any tx blocks were freed */
-			spin_lock_irqsave(&wl->wl_lock, flags);
+			raw_spin_lock_irqsave(&wl->wl_lock, flags);
 			if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
 			    wl1271_tx_total_queue_count(wl) > 0) {
-				spin_unlock_irqrestore(&wl->wl_lock, flags);
+				raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 				/*
 				 * In order to avoid starvation of the TX path,
 				 * call the work function directly.
 				 */
 				wl1271_tx_work_locked(wl);
 			} else {
-				spin_unlock_irqrestore(&wl->wl_lock, flags);
+				raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 			}
 
 			/* check for tx results */
@@ -995,15 +995,15 @@ static irqreturn_t wl1271_irq(int irq, void *cookie)
 	wl1271_ps_elp_sleep(wl);
 
 out:
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	/* In case TX was not handled here, queue TX work */
 	clear_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
 	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
 	    wl1271_tx_total_queue_count(wl) > 0) {
-		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
 	} else
-		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	mutex_unlock(&wl->mutex);
 
@@ -1550,7 +1550,7 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 	wl1271_debug(DEBUG_TX, "queue skb hlid %d q %d len %d",
 		     hlid, q, skb->len);
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	skb_queue_tail(&wl->links[hlid].tx_queue[q], skb);
 
 	wl->tx_queue_count[q]++;
@@ -1565,7 +1565,7 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 		set_bit(q, &wl->stopped_queues_map);
 	}
 
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 	/*
 	 * The chip specific setup must run before the first TX packet -
 	 * before that, the tx_work will not be initialized!
@@ -1587,10 +1587,10 @@ int wl1271_tx_dummy_packet(struct wl1271 *wl)
 
 	q = wl1271_tx_get_queue(skb_get_queue_mapping(wl->dummy_packet));
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	set_bit(WL1271_FLAG_DUMMY_PACKET_PENDING, &wl->flags);
 	wl->tx_queue_count[q]++;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	/* The FW is low on RX memory blocks, so send the dummy packet asap */
 	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags))
@@ -1800,11 +1800,11 @@ static int wl1271_op_resume(struct ieee80211_hw *hw)
 	 * re-enable irq_work enqueuing, and call irq_work directly if
 	 * there is a pending work.
 	 */
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	clear_bit(WL1271_FLAG_SUSPENDED, &wl->flags);
 	if (test_and_clear_bit(WL1271_FLAG_PENDING_WORK, &wl->flags))
 		run_irq_work = true;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	if (run_irq_work) {
 		wl1271_debug(DEBUG_MAC80211,
@@ -5351,7 +5351,7 @@ static struct ieee80211_hw *wl1271_alloc_hw(void)
 	for (i = 0; i < ACX_TX_DESCRIPTORS; i++)
 		wl->tx_frames[i] = NULL;
 
-	spin_lock_init(&wl->wl_lock);
+	raw_spin_lock_init(&wl->wl_lock);
 
 	wl->state = WL1271_STATE_OFF;
 	wl->fw_type = WL12XX_FW_TYPE_NONE;
@@ -5443,7 +5443,7 @@ static irqreturn_t wl12xx_hardirq(int irq, void *cookie)
 	wl1271_debug(DEBUG_IRQ, "IRQ");
 
 	/* complete the ELP completion */
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	set_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags);
 	if (wl->elp_compl) {
 		complete(wl->elp_compl);
@@ -5456,10 +5456,10 @@ static irqreturn_t wl12xx_hardirq(int irq, void *cookie)
 		wl1271_debug(DEBUG_IRQ, "should not enqueue work");
 		disable_irq_nosync(wl->irq);
 		pm_wakeup_event(wl->dev, 0);
-		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 		return IRQ_HANDLED;
 	}
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	return IRQ_WAKE_THREAD;
 }
diff --git a/drivers/net/wireless/wl12xx/ps.c b/drivers/net/wireless/wl12xx/ps.c
index 78f598b..a625c94 100644
--- a/drivers/net/wireless/wl12xx/ps.c
+++ b/drivers/net/wireless/wl12xx/ps.c
@@ -118,12 +118,12 @@ int wl1271_ps_elp_wakeup(struct wl1271 *wl)
 	 * The spinlock is required here to synchronize both the work and
 	 * the completion variable in one entity.
 	 */
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	if (test_bit(WL1271_FLAG_IRQ_RUNNING, &wl->flags))
 		pending = true;
 	else
 		wl->elp_compl = &compl;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	wl1271_raw_write32(wl, HW_ACCESS_ELP_CTRL_REG_ADDR, ELPCTRL_WAKE_UP);
 
@@ -148,9 +148,9 @@ int wl1271_ps_elp_wakeup(struct wl1271 *wl)
 	goto out;
 
 err:
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	wl->elp_compl = NULL;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 	return ret;
 
 out:
@@ -238,10 +238,10 @@ static void wl1271_ps_filter_frames(struct wl1271 *wl, u8 hlid)
 		}
 	}
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	for (i = 0; i < NUM_TX_QUEUES; i++)
 		wl->tx_queue_count[i] -= filtered[i];
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	wl1271_handle_tx_low_watermark(wl);
 }
diff --git a/drivers/net/wireless/wl12xx/tx.c b/drivers/net/wireless/wl12xx/tx.c
index 43ae491..a8d0dbd 100644
--- a/drivers/net/wireless/wl12xx/tx.c
+++ b/drivers/net/wireless/wl12xx/tx.c
@@ -479,11 +479,11 @@ void wl1271_handle_tx_low_watermark(struct wl1271 *wl)
 		if (test_bit(i, &wl->stopped_queues_map) &&
 		    wl->tx_queue_count[i] <= WL1271_TX_QUEUE_LOW_WATERMARK) {
 			/* firmware buffer has space, restart queues */
-			spin_lock_irqsave(&wl->wl_lock, flags);
+			raw_spin_lock_irqsave(&wl->wl_lock, flags);
 			ieee80211_wake_queue(wl->hw,
 					     wl1271_tx_get_mac80211_queue(i));
 			clear_bit(i, &wl->stopped_queues_map);
-			spin_unlock_irqrestore(&wl->wl_lock, flags);
+			raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 		}
 	}
 }
@@ -530,10 +530,10 @@ static struct sk_buff *wl12xx_lnk_skb_dequeue(struct wl1271 *wl,
 	skb = skb_dequeue(queue);
 	if (skb) {
 		int q = wl1271_tx_get_queue(skb_get_queue_mapping(skb));
-		spin_lock_irqsave(&wl->wl_lock, flags);
+		raw_spin_lock_irqsave(&wl->wl_lock, flags);
 		WARN_ON_ONCE(wl->tx_queue_count[q] <= 0);
 		wl->tx_queue_count[q]--;
-		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 	}
 
 	return skb;
@@ -615,10 +615,10 @@ static struct sk_buff *wl1271_skb_dequeue(struct wl1271 *wl)
 
 		skb = wl->dummy_packet;
 		q = wl1271_tx_get_queue(skb_get_queue_mapping(skb));
-		spin_lock_irqsave(&wl->wl_lock, flags);
+		raw_spin_lock_irqsave(&wl->wl_lock, flags);
 		WARN_ON_ONCE(wl->tx_queue_count[q] <= 0);
 		wl->tx_queue_count[q]--;
-		spin_unlock_irqrestore(&wl->wl_lock, flags);
+		raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 	}
 
 	return skb;
@@ -641,9 +641,9 @@ static void wl1271_skb_queue_head(struct wl1271 *wl, struct wl12xx_vif *wlvif,
 				      WL12XX_MAX_LINKS;
 	}
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	wl->tx_queue_count[q]++;
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 }
 
 static bool wl1271_tx_is_data_present(struct sk_buff *skb)
@@ -954,10 +954,10 @@ void wl1271_tx_reset_link_queues(struct wl1271 *wl, u8 hlid)
 		}
 	}
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
+	raw_spin_lock_irqsave(&wl->wl_lock, flags);
 	for (i = 0; i < NUM_TX_QUEUES; i++)
 		wl->tx_queue_count[i] -= total[i];
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	raw_spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	wl1271_handle_tx_low_watermark(wl);
 }
diff --git a/drivers/net/wireless/wl12xx/wl12xx.h b/drivers/net/wireless/wl12xx/wl12xx.h
index 749a15a..c5e1fe3 100644
--- a/drivers/net/wireless/wl12xx/wl12xx.h
+++ b/drivers/net/wireless/wl12xx/wl12xx.h
@@ -306,7 +306,7 @@ struct wl1271 {
 	int irq;
 	int ref_clock;
 
-	spinlock_t wl_lock;
+	raw_spinlock_t wl_lock;
 
 	enum wl1271_state state;
 	enum wl12xx_fw_type fw_type;
-- 
1.7.9.7

