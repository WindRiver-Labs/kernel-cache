From 063b812acbd790a973d251e417199515cf861aa4 Mon Sep 17 00:00:00 2001
From: "Hebbar, Gururaja" <gururaja.hebbar@ti.com>
Date: Thu, 9 Feb 2012 17:45:08 +0530
Subject: [PATCH 529/609] ARM: edma: clear interrupt status for interrupt
 enabled channels only

Original commit: d999eb230e9e339d8802bf4cdbfd30c35bbb27d8

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Currently, the ISR in the EDMA driver clears the pending interrupt for all
channels without regard to whether that channel has a registered callback
or not.

This patch fixes the issue by making the ISR clear the interrupts only for
those channels which have interrupt enabled. The channels which are allocated
for the purpose of being polled on by the accelerator will not have a callback
function provided and so will not have IER (interrupt enable register) bits set.

Signed-off-by: Anuj Aggarwal <anuj.aggarwal@ti.com>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
CC: Archith John Bency <archith@ti.com>
Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
---
 arch/arm/common/edma.c |   11 +++++++----
 1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 7bd8c87..7d19ba9 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -335,9 +335,11 @@ static irqreturn_t dma_irq_handler(int irq, void *data)
 
 	while (1) {
 		int j;
-		if (edma_shadow0_read_array(ctlr, SH_IPR, 0))
+		if (edma_shadow0_read_array(ctlr, SH_IPR, 0) &
+				edma_shadow0_read_array(ctlr, SH_IER, 0))
 			j = 0;
-		else if (edma_shadow0_read_array(ctlr, SH_IPR, 1))
+		else if (edma_shadow0_read_array(ctlr, SH_IPR, 1) &
+				edma_shadow0_read_array(ctlr, SH_IER, 1))
 			j = 1;
 		else
 			break;
@@ -345,8 +347,9 @@ static irqreturn_t dma_irq_handler(int irq, void *data)
 				edma_shadow0_read_array(ctlr, SH_IPR, j));
 		for (i = 0; i < 32; i++) {
 			int k = (j << 5) + i;
-			if (edma_shadow0_read_array(ctlr, SH_IPR, j) &
-							(1 << i)) {
+			if ((edma_shadow0_read_array(ctlr, SH_IPR, j) & BIT(i))
+					&& (edma_shadow0_read_array(ctlr,
+							SH_IER, j) & BIT(i))) {
 				/* Clear the corresponding IPR bits */
 				edma_shadow0_write_array(ctlr, SH_ICR, j,
 							BIT(i));
-- 
1.7.5.4

