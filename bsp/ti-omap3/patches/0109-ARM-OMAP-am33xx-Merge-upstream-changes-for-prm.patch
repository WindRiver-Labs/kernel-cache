From 5bbe1d09506b83a21b5f21babcad3557a71c9410 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Fri, 24 Feb 2012 16:40:11 +0530
Subject: [PATCH 109/609] ARM: OMAP: am33xx: Merge upstream changes for prm

Original commit: 408ca73ae84c53008125814c93eae250c5894b6f

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Based on community feedback/developement,
      - Consolidate AM33xx and OMAP4 prminst code
      - Remove prminst33xx.c & powerdomain33xx.c

Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/powerdomain33xx.c       |  155 ---------------------
 arch/arm/mach-omap2/powerdomains33xx_data.c |   37 ++++--
 arch/arm/mach-omap2/prm33xx.h               |    7 -
 arch/arm/mach-omap2/prminst33xx.c           |  201 ---------------------------
 4 files changed, 28 insertions(+), 372 deletions(-)
 delete mode 100644 arch/arm/mach-omap2/powerdomain33xx.c
 delete mode 100644 arch/arm/mach-omap2/prminst33xx.c

diff --git a/arch/arm/mach-omap2/powerdomain33xx.c b/arch/arm/mach-omap2/powerdomain33xx.c
deleted file mode 100644
index 80bfd42f..0000000
--- a/arch/arm/mach-omap2/powerdomain33xx.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * AM33XX Powerdomain control
- *
- * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/io.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
-
-#include <plat/prcm.h>
-
-#include "powerdomain.h"
-#include "prm33xx.h"
-#include "prm-regbits-33xx.h"
-#include "prminst33xx.h"
-
-
-static int am33xx_pwrdm_set_next_pwrst(struct powerdomain *pwrdm, u8 pwrst)
-{
-	am33xx_prminst_rmw_inst_reg_bits(OMAP_POWERSTATE_MASK,
-					(pwrst << OMAP_POWERSTATE_SHIFT),
-					pwrdm->prcm_offs, AM33XX_PM_PWSTCTRL);
-	return 0;
-}
-
-static int am33xx_pwrdm_read_next_pwrst(struct powerdomain *pwrdm)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTCTRL);
-	v &= OMAP_POWERSTATE_MASK;
-	v >>= OMAP_POWERSTATE_SHIFT;
-
-	return v;
-}
-
-static int am33xx_pwrdm_read_pwrst(struct powerdomain *pwrdm)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTST);
-	v &= OMAP_POWERSTATEST_MASK;
-	v >>= OMAP_POWERSTATEST_SHIFT;
-
-	return v;
-}
-
-static int am33xx_pwrdm_read_prev_pwrst(struct powerdomain *pwrdm)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTST);
-	v &= AM33XX_LASTPOWERSTATEENTERED_MASK;
-	v >>= AM33XX_LASTPOWERSTATEENTERED_SHIFT;
-
-	return v;
-}
-
-static int am33xx_pwrdm_set_lowpwrstchange(struct powerdomain *pwrdm)
-{
-	am33xx_prminst_rmw_inst_reg_bits(AM33XX_LOWPOWERSTATECHANGE_MASK,
-			(1 << AM33XX_LOWPOWERSTATECHANGE_SHIFT),
-			pwrdm->prcm_offs, AM33XX_PM_PWSTCTRL);
-	return 0;
-}
-
-static int am33xx_pwrdm_clear_all_prev_pwrst(struct powerdomain *pwrdm)
-{
-	am33xx_prminst_rmw_inst_reg_bits(AM33XX_LASTPOWERSTATEENTERED_MASK,
-			AM33XX_LASTPOWERSTATEENTERED_MASK,
-			pwrdm->prcm_offs, AM33XX_PM_PWSTST);
-	return 0;
-}
-
-static int am33xx_pwrdm_set_logic_retst(struct powerdomain *pwrdm, u8 pwrst)
-{
-	u32 v;
-
-	v = pwrst << __ffs(AM33XX_LOGICRETSTATE_MASK);
-	am33xx_prminst_rmw_inst_reg_bits(AM33XX_LOGICRETSTATE_MASK, v,
-			pwrdm->prcm_offs, AM33XX_PM_PWSTCTRL);
-
-	return 0;
-}
-
-static int am33xx_pwrdm_read_logic_pwrst(struct powerdomain *pwrdm)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTST);
-	v &= AM33XX_LOGICSTATEST_MASK;
-	v >>= AM33XX_LOGICSTATEST_SHIFT;
-
-	return v;
-}
-
-static int am33xx_pwrdm_read_logic_retst(struct powerdomain *pwrdm)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTCTRL);
-	v &= AM33XX_LOGICRETSTATE_MASK;
-	v >>= AM33XX_LOGICRETSTATE_SHIFT;
-
-	return v;
-}
-
-static int am33xx_pwrdm_wait_transition(struct powerdomain *pwrdm)
-{
-	u32 c = 0;
-
-	/*
-	 * REVISIT: pwrdm_wait_transition() may be better implemented
-	 * via a callback and a periodic timer check -- how long do we expect
-	 * powerdomain transitions to take?
-	 */
-
-	/* XXX Is this udelay() value meaningful? */
-	while ((am33xx_prminst_read_inst_reg(pwrdm->prcm_offs, AM33XX_PM_PWSTST)
-		& OMAP_INTRANSITION_MASK) && (c++ < PWRDM_TRANSITION_BAILOUT))
-		udelay(1);
-
-	if (c > PWRDM_TRANSITION_BAILOUT) {
-		printk(KERN_ERR "powerdomain: waited too long for "
-			"powerdomain %s to complete transition\n", pwrdm->name);
-		return -EAGAIN;
-	}
-
-	pr_debug("powerdomain: completed transition in %d loops\n", c);
-
-	return 0;
-}
-
-struct pwrdm_ops am33xx_pwrdm_operations = {
-	.pwrdm_set_next_pwrst		= am33xx_pwrdm_set_next_pwrst,
-	.pwrdm_read_next_pwrst		= am33xx_pwrdm_read_next_pwrst,
-	.pwrdm_read_pwrst		= am33xx_pwrdm_read_pwrst,
-	.pwrdm_read_prev_pwrst		= am33xx_pwrdm_read_prev_pwrst,
-	.pwrdm_set_logic_retst		= am33xx_pwrdm_set_logic_retst,
-	.pwrdm_read_logic_pwrst		= am33xx_pwrdm_read_logic_pwrst,
-	.pwrdm_read_logic_retst		= am33xx_pwrdm_read_logic_retst,
-	.pwrdm_clear_all_prev_pwrst	= am33xx_pwrdm_clear_all_prev_pwrst,
-	.pwrdm_set_lowpwrstchange	= am33xx_pwrdm_set_lowpwrstchange,
-	.pwrdm_wait_transition		= am33xx_pwrdm_wait_transition,
-};
diff --git a/arch/arm/mach-omap2/powerdomains33xx_data.c b/arch/arm/mach-omap2/powerdomains33xx_data.c
index e69e62a..3ceef60 100644
--- a/arch/arm/mach-omap2/powerdomains33xx_data.c
+++ b/arch/arm/mach-omap2/powerdomains33xx_data.c
@@ -1,5 +1,5 @@
 /*
- * AM33Xx Power domains framework
+ * AM33XX Power domains framework
  *
  * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
  *
@@ -19,17 +19,21 @@
 #include "powerdomain.h"
 #include "prcm-common.h"
 #include "prm33xx.h"
+#include "prcm44xx.h"
 
 static struct powerdomain gfx_33xx_pwrdm = {
 	.name			= "gfx_pwrdm",
 	.voltdm			= { .name = "core" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
 	.prcm_offs		= AM33XX_PRM_GFX_MOD,
 	.pwrsts			= PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret	= PWRSTS_OFF_RET,
+	.pwrstctrl_offs		= AM33XX_PM_GFX_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_GFX_PWRSTST_OFFSET,
 	.flags			= PWRDM_HAS_LOWPOWERSTATECHANGE,
 	.banks			= 1,
 	.pwrsts_mem_ret		= {
-		[0] 	= PWRSTS_OFF_RET,		/* gfx_mem */
+		[0]	= PWRSTS_OFF_RET,	/* gfx_mem */
 	},
 	.pwrsts_mem_on		= {
 		[0]	= PWRSTS_ON,		/* gfx_mem */
@@ -39,32 +43,41 @@ static struct powerdomain gfx_33xx_pwrdm = {
 static struct powerdomain rtc_33xx_pwrdm = {
 	.name			= "rtc_pwrdm",
 	.voltdm			= { .name = "rtc" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
 	.prcm_offs		= AM33XX_PRM_RTC_MOD,
 	.pwrsts			= PWRSTS_ON,
+	.pwrstctrl_offs		= AM33XX_PM_RTC_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_RTC_PWRSTST_OFFSET,
 };
 
 static struct powerdomain wkup_33xx_pwrdm = {
 	.name			= "wkup_pwrdm",
 	.voltdm			= { .name = "core" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
 	.prcm_offs		= AM33XX_PRM_WKUP_MOD,
 	.pwrsts			= PWRSTS_ON,
+	.pwrstctrl_offs		= AM33XX_PM_WKUP_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_WKUP_PWRSTST_OFFSET,
 };
 
 static struct powerdomain per_33xx_pwrdm = {
 	.name			= "per_pwrdm",
 	.voltdm			= { .name = "core" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
 	.prcm_offs		= AM33XX_PRM_PER_MOD,
 	.pwrsts			= PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret	= PWRSTS_OFF_RET,
+	.pwrstctrl_offs		= AM33XX_PM_PER_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_PER_PWRSTST_OFFSET,
 	.flags			= PWRDM_HAS_LOWPOWERSTATECHANGE,
 	.banks			= 3,
 	.pwrsts_mem_ret		= {
-		[0]	= PWRSTS_OFF_RET,	/* icss_mem */
+		[0]	= PWRSTS_OFF_RET,	/* pruss_mem */
 		[1]	= PWRSTS_OFF_RET,	/* per_mem */
 		[2]	= PWRSTS_OFF_RET,	/* ram_mem */
 	},
 	.pwrsts_mem_on		= {
-		[0]	= PWRSTS_ON,		/* icss_mem */
+		[0]	= PWRSTS_ON,		/* pruss_mem */
 		[1]	= PWRSTS_ON,		/* per_mem */
 		[2]	= PWRSTS_ON,		/* ram_mem */
 	},
@@ -73,9 +86,12 @@ static struct powerdomain per_33xx_pwrdm = {
 static struct powerdomain mpu_33xx_pwrdm = {
 	.name			= "mpu_pwrdm",
 	.voltdm			= { .name = "mpu" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
 	.prcm_offs		= AM33XX_PRM_MPU_MOD,
 	.pwrsts			= PWRSTS_OFF_RET_ON,
 	.pwrsts_logic_ret	= PWRSTS_OFF_RET,
+	.pwrstctrl_offs		= AM33XX_PM_MPU_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_MPU_PWRSTST_OFFSET,
 	.flags			= PWRDM_HAS_LOWPOWERSTATECHANGE,
 	.banks			= 3,
 	.pwrsts_mem_ret		= {
@@ -91,10 +107,13 @@ static struct powerdomain mpu_33xx_pwrdm = {
 };
 
 static struct powerdomain cefuse_33xx_pwrdm = {
-	.name		= "cefuse_pwrdm",
-	.voltdm		= { .name = "core" },
-	.prcm_offs	= AM33XX_PRM_CEFUSE_MOD,
-	.pwrsts		= PWRSTS_OFF_ON,
+	.name			= "cefuse_pwrdm",
+	.voltdm			= { .name = "core" },
+	.prcm_partition		= AM33XX_PRM_PARTITION,
+	.prcm_offs		= AM33XX_PRM_CEFUSE_MOD,
+	.pwrsts			= PWRSTS_OFF_ON,
+	.pwrstctrl_offs		= AM33XX_PM_CEFUSE_PWRSTCTRL_OFFSET,
+	.pwrstst_offs		= AM33XX_PM_CEFUSE_PWRSTST_OFFSET,
 };
 
 static struct powerdomain *powerdomains_am33xx[] __initdata = {
@@ -109,7 +128,7 @@ static struct powerdomain *powerdomains_am33xx[] __initdata = {
 
 void __init am33xx_powerdomains_init(void)
 {
-	pwrdm_register_platform_funcs(&am33xx_pwrdm_operations);
+	pwrdm_register_platform_funcs(&omap4_pwrdm_operations);
 	pwrdm_register_pwrdms(powerdomains_am33xx);
 	pwrdm_complete_init();
 }
diff --git a/arch/arm/mach-omap2/prm33xx.h b/arch/arm/mach-omap2/prm33xx.h
index 4be8f91..aa1e8c7 100644
--- a/arch/arm/mach-omap2/prm33xx.h
+++ b/arch/arm/mach-omap2/prm33xx.h
@@ -24,7 +24,6 @@
 #define AM33XX_PRM_REGADDR(inst, reg)                         \
 	AM33XX_L4_WK_IO_ADDRESS(AM33XX_PRM_BASE + (inst) + (reg))
 
-
 /* PRM instances */
 #define AM33XX_PRM_OCP_SOCKET_MOD	0x0B00
 #define AM33XX_PRM_PER_MOD		0x0C00
@@ -35,12 +34,6 @@
 #define AM33XX_PRM_GFX_MOD		0x1100
 #define AM33XX_PRM_CEFUSE_MOD		0x1200
 
-/* Register offsets (used to calculate correct offset) */
-#define AM33XX_PM_PWSTCTRL		0x0000
-#define AM33XX_PM_PWSTST		0x0004
-#define AM33XX_PM_RSTCTRL		0x0008
-#define AM33XX_PM_RSTST			0x000C
-
 /* PRM */
 
 /* PRM.OCP_SOCKET_PRM register offsets */
diff --git a/arch/arm/mach-omap2/prminst33xx.c b/arch/arm/mach-omap2/prminst33xx.c
deleted file mode 100644
index ab51570..0000000
--- a/arch/arm/mach-omap2/prminst33xx.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * AM33XX PRM instance functions
- *
- * Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation version 2.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/err.h>
-#include <linux/io.h>
-
-#include "common.h"
-
-#include "prm33xx.h"
-#include "prminst33xx.h"
-#include "prm-regbits-33xx.h"
-
-#define AM33XX_PRM_MOD_SIZE	0x100
-#define AM33XX_PRM_MOD_START	AM33XX_PRM_PER_MOD
-#define PRM_REG_SZ		0x4
-
-/*
- * PRM Offsets are screwed up, and they are not consistent across modules.
- * Below are the offsets for PWRSTCTRL and PWRSTST for respective modules.
- */
-static u16 off_fixup[][4] = {
-	/* PRM_PER_MOD: 0x0C, 0x08, 0x00, 0x04 */
-	{
-		AM33XX_PM_PER_PWRSTCTRL_OFFSET,
-		AM33XX_PM_PER_PWRSTST_OFFSET,
-		AM33XX_RM_PER_RSTCTRL_OFFSET,
-		AM33XX_RM_PER_RSTST_OFFSET,
-	},
-	/* PRM_WKUP_MOD: 0x04, 0x08, 0x00, 0x0C */
-	{
-		AM33XX_PM_WKUP_PWRSTCTRL_OFFSET,
-		AM33XX_PM_WKUP_PWRSTST_OFFSET,
-		AM33XX_RM_WKUP_RSTCTRL_OFFSET,
-		AM33XX_RM_WKUP_RSTST_OFFSET,
-	},
-	/* AM33XX_PRM_MPU_MOD: 0x00, 0x04, 0x08, NA */
-	{
-		AM33XX_PM_MPU_PWRSTCTRL_OFFSET,
-		AM33XX_PM_MPU_PWRSTST_OFFSET,
-		AM33XX_RM_MPU_RSTST_OFFSET,
-		AM33XX_RM_MPU_RSTST_OFFSET,
-	},
-	/* PRM_DEVICE_MOD: NA, NA, 0x00, 0x08 */
-	{
-		0x0,
-		0x0,
-		AM33XX_PRM_RSTCTRL_OFFSET,
-		AM33XX_PRM_RSTST_OFFSET,
-	},
-	/* PRM_RTC_MOD: 0x00, 0x04, NA, NA */
-	{
-		AM33XX_PM_RTC_PWRSTCTRL_OFFSET,
-		AM33XX_PM_RTC_PWRSTST_OFFSET,
-		0x0,
-		0x0,
-	},
-	/* PRM_GFX_MOD: 0x00, 0x10, 0x04, 0x14 */
-	{
-		AM33XX_PM_GFX_PWRSTCTRL_OFFSET,
-		AM33XX_PM_GFX_PWRSTST_OFFSET,
-		AM33XX_RM_GFX_RSTCTRL_OFFSET,
-		AM33XX_RM_GFX_RSTST_OFFSET,
-	},
-	/* PRM_CEFUSE_MOD: 0x00, 0x04, NA, NA */
-	{
-		AM33XX_PM_CEFUSE_PWRSTCTRL_OFFSET,
-		AM33XX_PM_CEFUSE_PWRSTST_OFFSET,
-		0x0,
-		0x0,
-	},
-};
-
-/* Read a register in a PRM instance */
-u32 am33xx_prminst_read_inst_reg(s16 inst, u16 idx)
-{
-	int i = (inst - AM33XX_PRM_MOD_START) / AM33XX_PRM_MOD_SIZE;
-
-	return __raw_readl(prm_base + inst + off_fixup[i][idx / PRM_REG_SZ]);
-}
-
-/* Write into a register in a PRM instance */
-void am33xx_prminst_write_inst_reg(u32 val, s16 inst, u16 idx)
-{
-	int i = (inst - AM33XX_PRM_MOD_START) / AM33XX_PRM_MOD_SIZE;
-
-	__raw_writel(val, prm_base + inst + off_fixup[i][idx / PRM_REG_SZ]);
-}
-
-/* Read-modify-write a register in PRM. Caller must lock */
-u32 am33xx_prminst_rmw_inst_reg_bits(u32 mask, u32 bits, s16 inst, s16 idx)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(inst, idx);
-	v &= ~mask;
-	v |= bits;
-	am33xx_prminst_write_inst_reg(v, inst, idx);
-
-	return v;
-}
-
-/**
- * am33xx_prminst_is_hardreset_asserted - read the HW reset line state of
- * submodules contained in the hwmod module
- * @prm_mod: PRM submodule base (e.g. CORE_MOD)
- * @idx: register bit offset for calculating correct offset
- * @mask: register bit mask
- *
- * Returns 1 if the (sub)module hardreset line is currently asserted,
- * 0 if the (sub)module hardreset line is not currently asserted, or
- * -EINVAL if called while running on a non-OMAP2/3 chip.
- */
-
-u32 am33xx_prminst_is_hardreset_asserted(s16 prm_mod, s16 idx, u32 mask)
-{
-	u32 v;
-
-	v = am33xx_prminst_read_inst_reg(prm_mod, idx);
-	v &= mask;
-	v >>= __ffs(mask);
-
-	return v;
-}
-
-/**
- * am33xx_prminst_assert_hardreset - assert the HW reset line of a submodule
- * @prm_mod: PRM submodule base (e.g. GFX_MOD)
- * @shift: register bit shift corresponding to the reset line to assert
- *
- * Some IPs like iva or PRUSS contain processors that require an HW
- * reset line to be asserted / deasserted in order to fully enable the
- * IP.  These modules may have multiple hard-reset lines that reset
- * different 'submodules' inside the IP block.  This function will
- * place the submodule into reset.  Returns 0 upon success or -EINVAL
- * upon an argument error.
- */
-
-int am33xx_prminst_assert_hardreset(s16 prm_mod, u8 shift)
-{
-	u32 mask;
-
-	if (!cpu_is_am33xx())
-		return -EINVAL;
-
-	mask = 1 << shift;
-	/* assert the reset control line */
-	am33xx_prminst_rmw_inst_reg_bits(mask, mask, prm_mod, AM33XX_PM_RSTCTRL);
-
-	return 0;
-}
-
-/**
- * am33xx_prminst_deassert_hardreset - deassert a submodule hardreset line and
- * wait
- * @prm_mod: PRM submodule base (e.g. CORE_MOD)
- * @rst_shift: register bit shift corresponding to the reset line to deassert
- * @st_shift: register bit shift for the status of the deasserted submodule
- *
- * Some IPs like SGX, PRUSS and M3 contain processors that require an HW
- * reset line to be asserted / deasserted in order to fully enable the
- * IP.
- * This function will take the submodule out of reset and wait until the
- * PRCM indicates that the reset has completed before returning.
- * Returns 0 upon success or -EINVAL upon an argument error,
- * -EEXIST if the submodule was already out of reset, or -EBUSY if the
- * submodule did not exit reset promptly.
- */
-int am33xx_prminst_deassert_hardreset(s16 prm_mod, u8 rst_shift, u8 st_shift)
-{
-	u32 rst, st;
-
-	if (!cpu_is_am33xx())
-		return -EINVAL;
-
-	rst = 1 << rst_shift;
-	st = 1 << st_shift;
-
-	/* Clear the reset status by writing 1 to the status bit */
-	am33xx_prminst_rmw_inst_reg_bits(0xffffffff, st, prm_mod,
-							AM33XX_PM_RSTST);
-	/* de-assert the reset control line */
-	am33xx_prminst_rmw_inst_reg_bits(rst, 0, prm_mod, AM33XX_PM_RSTCTRL);
-	/* TODO: wait the status to be set */
-
-	return 0;
-}
-- 
1.7.5.4

