From 6710f4818b1357d79943b9d63fbacc5acaf291b9 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 4 Sep 2012 10:52:11 +0800
Subject: [PATCH 589/609] ethernet: ti: leftovers fixes for ALE

A reference ommit: d1ca3fee5e3b805fc079b1feab6cec5f7b03c4f1
  From git://arago-project.org/git/projects/linux-am33x.git
  ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

These leftovers come from the differences of CPSW codes among
mainline, arago, SDK, so we integrate them in.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/ti/cpsw_ale.c |  107 +++++++++++++++++++++++++++++++++++-
 1 files changed, 104 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index c62691e..aaa1b31 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -518,9 +518,9 @@ int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask)
 	cpsw_ale_read(ale, idx, ale_entry);
 
 	if (port_mask)
-		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
-	else
 		cpsw_ale_set_port_mask(ale_entry, port_mask);
+	else
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
 
 	cpsw_ale_write(ale, idx, ale_entry);
 	return 0;
@@ -876,7 +876,11 @@ int cpsw_ale_control_set(struct cpsw_ale *ale, int port, int control,
 	tmp = __raw_readl(ale->params.ale_regs + offset);
 	tmp = (tmp & ~(mask << shift)) | (value << shift);
 	__raw_writel(tmp, ale->params.ale_regs + offset);
-
+	{
+		volatile u32 dly = 10000;
+		while (dly--)
+			;
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cpsw_ale_control_set);
@@ -905,6 +909,92 @@ int cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control)
 }
 EXPORT_SYMBOL_GPL(cpsw_ale_control_get);
 
+static ssize_t cpsw_ale_control_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int i, port, len = 0;
+	struct ale_control_info *info;
+	struct cpsw_ale *ale = control_attr_to_ale(attr);
+
+	for (i = 0, info = ale_controls; i < ALE_NUM_CONTROLS; i++, info++) {
+		/* global controls */
+		if (info->port_shift == 0 &&  info->port_offset == 0) {
+			len += snprintf(buf + len, SZ_4K - len,
+					"%s=%d\n", info->name,
+					cpsw_ale_control_get(ale, 0, i));
+			continue;
+		}
+		/* port specific controls */
+		for (port = 0; port < ale->params.ale_ports; port++) {
+			len += snprintf(buf + len, SZ_4K - len,
+					"%s.%d=%d\n", info->name, port,
+					cpsw_ale_control_get(ale, port, i));
+		}
+	}
+	return len;
+}
+
+static ssize_t cpsw_ale_control_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char ctrl_str[33], *end;
+	int port = 0, value, len, ret, control;
+	struct cpsw_ale *ale = control_attr_to_ale(attr);
+
+	len = strcspn(buf, ".=");
+	if (len >= 32)
+		return -ENOMEM;
+	strncpy(ctrl_str, buf, len);
+	ctrl_str[len] = '\0';
+	buf += len;
+
+	if (*buf == '.') {
+		port = simple_strtoul(buf + 1, &end, 0);
+		buf = end;
+	}
+
+	if (*buf != '=')
+		return -EINVAL;
+
+	value = simple_strtoul(buf + 1, NULL, 0);
+
+	for (control = 0; control < ALE_NUM_CONTROLS; control++)
+		if (strcmp(ctrl_str, ale_controls[control].name) == 0)
+			break;
+
+	if (control >= ALE_NUM_CONTROLS)
+		return -ENOENT;
+
+	dev_dbg(ale->params.dev, "processing command %s.%d=%d\n",
+		ale_controls[control].name, port, value);
+
+	ret = cpsw_ale_control_set(ale, port, control, value);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+DEVICE_ATTR(ale_control, S_IRUGO | S_IWUSR, cpsw_ale_control_show,
+	    cpsw_ale_control_store);
+static ssize_t cpsw_ale_table_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int len = SZ_4K, outlen = 0, idx;
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	struct cpsw_ale *ale = table_attr_to_ale(attr);
+
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		outlen += cpsw_ale_dump_entry(idx, ale_entry, buf + outlen,
+					      len - outlen);
+	}
+	return outlen;
+}
+DEVICE_ATTR(ale_table, S_IRUGO, cpsw_ale_table_show, NULL);
+
 static void cpsw_ale_timer(unsigned long arg)
 {
 	struct cpsw_ale *ale = (struct cpsw_ale *)arg;
@@ -931,6 +1021,7 @@ int cpsw_ale_set_ageout(struct cpsw_ale *ale, int ageout)
 void cpsw_ale_start(struct cpsw_ale *ale)
 {
 	u32 rev;
+	int ret;
 
 	rev = __raw_readl(ale->params.ale_regs + ALE_IDVER);
 	dev_dbg(ale->params.dev, "initialized cpsw ale revision %d.%d\n",
@@ -938,6 +1029,16 @@ void cpsw_ale_start(struct cpsw_ale *ale)
 	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 1);
 	cpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);
 
+	ale->ale_control_attr = dev_attr_ale_control;
+	sysfs_attr_init(&ale->ale_control_attr.attr);
+	ret = device_create_file(ale->params.dev, &ale->ale_control_attr);
+	WARN_ON(ret < 0);
+
+	ale->ale_table_attr = dev_attr_ale_table;
+	sysfs_attr_init(&ale->ale_table_attr.attr);
+	ret = device_create_file(ale->params.dev, &ale->ale_table_attr);
+	WARN_ON(ret < 0);
+
 	init_timer(&ale->timer);
 	ale->timer.data	    = (unsigned long)ale;
 	ale->timer.function = cpsw_ale_timer;
-- 
1.7.5.4

