From 53eaead81d9394ea471befdeea434356ea91f08d Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Thu, 9 Dec 2010 11:32:09 +0530
Subject: [PATCH 386/609] musb: cppi41: Update usb_cppi41_info to support
 multi-ctrl

Original commit: 82eb39ee828b36d8db6908561de9c67aa4ba5ec4

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Changed usb_cppi41_info to an array of two such element to support
multi-controller scenarios.

Also updated the required changed in am35x.c

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/am35x.c      |   27 +++++++++++++++------------
 drivers/usb/musb/cppi41_dma.c |   19 +++++++++++--------
 drivers/usb/musb/cppi41_dma.h |    2 +-
 3 files changed, 27 insertions(+), 21 deletions(-)

diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index ed70788..bcac4f8 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -104,8 +104,10 @@
  * ---------------------------------
  */
 
-static const u16 tx_comp_q[] = { 63, 64 };
-static const u16 rx_comp_q[] = { 65, 66 };
+static const u16 tx_comp_q[] = {63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63,
+				63, 63};
+static const u16 rx_comp_q[] = {65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
+				65, 65};
 
 /* Fair scheduling */
 u32 dma_sched_table[] = {
@@ -197,20 +199,21 @@ static const u32 assigned_queues[] = { 0xffffffff, 0xffffffff, 0x7 };
 
 int __devinit cppi41_init(struct musb *musb)
 {
+	struct usb_cppi41_info *cppi_info = &usb_cppi41_info[musb->id];
 	u16 numch, blknum, order, i;
 
 	/* init cppi info structure  */
-	usb_cppi41_info.dma_block = 0;
+	cppi_info->dma_block = 0;
 	for (i = 0 ; i < USB_CPPI41_NUM_CH ; i++)
-		usb_cppi41_info.ep_dma_ch[i] = i;
+		cppi_info->ep_dma_ch[i] = i;
 
-	usb_cppi41_info.q_mgr = 0;
-	usb_cppi41_info.num_tx_comp_q = 4;
-	usb_cppi41_info.num_rx_comp_q = 4;
-	usb_cppi41_info.tx_comp_q = tx_comp_q;
-	usb_cppi41_info.rx_comp_q = rx_comp_q;
+	cppi_info->q_mgr = 0;
+	cppi_info->num_tx_comp_q = 15;
+	cppi_info->num_rx_comp_q = 15;
+	cppi_info->tx_comp_q = tx_comp_q;
+	cppi_info->rx_comp_q = rx_comp_q;
 
-	blknum = usb_cppi41_info.dma_block;
+	blknum = cppi_info->dma_block;
 
 	/* Queue manager information */
 	cppi41_queue_mgr[0].num_queue = 96;
@@ -236,7 +239,7 @@ int __devinit cppi41_init(struct musb *musb)
 	cppi41_dma_block[0].sched_table_base = musb->ctrl_base + 0x2800;
 
 	/* Initialize for Linking RAM region 0 alone */
-	cppi41_queue_mgr_init(usb_cppi41_info.q_mgr, 0, 0x3fff);
+	cppi41_queue_mgr_init(cppi_info->q_mgr, 0, 0x3fff);
 
 	numch =  USB_CPPI41_NUM_CH * 2;
 	order = get_count_order(numch);
@@ -245,7 +248,7 @@ int __devinit cppi41_init(struct musb *musb)
 	if (order < 5)
 		order = 5;
 
-	cppi41_dma_block_init(blknum, usb_cppi41_info.q_mgr, order,
+	cppi41_dma_block_init(blknum, cppi_info->q_mgr, order,
 			dma_sched_table, numch);
 	return 0;
 }
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 91ed31d..de28c7b 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -123,7 +123,7 @@ struct cppi41 {
 	struct usb_cppi41_info *cppi_info; /* cppi channel information */
 };
 
-struct usb_cppi41_info usb_cppi41_info;
+struct usb_cppi41_info usb_cppi41_info[2];
 EXPORT_SYMBOL(usb_cppi41_info);
 
 #ifdef DEBUG_CPPI_TD
@@ -273,10 +273,7 @@ static int __devinit cppi41_controller_start(struct dma_controller *controller)
 
 	/* Construct/store Tx PD packet info field for later use */
 	cppi->pkt_info = (CPPI41_PKT_TYPE_USB << CPPI41_PKT_TYPE_SHIFT) |
-			 (CPPI41_RETURN_LINKED << CPPI41_RETURN_POLICY_SHIFT) |
-			 (cppi_info->q_mgr << CPPI41_RETURN_QMGR_SHIFT) |
-			 (cppi_info->tx_comp_q[0] <<
-			  CPPI41_RETURN_QNUM_SHIFT);
+			 (CPPI41_RETURN_LINKED << CPPI41_RETURN_POLICY_SHIFT);
 
 	/* Do necessary configuartion in hardware to get started */
 	reg_base = cppi->musb->ctrl_base;
@@ -429,7 +426,7 @@ static struct dma_channel *cppi41_channel_alloc(struct dma_controller
 		rx_cfg.sop_offset = 0;
 		rx_cfg.retry_starved = 1;
 		rx_cfg.rx_queue.q_mgr = cppi_ch->src_queue.q_mgr = q_mgr;
-		rx_cfg.rx_queue.q_num = cppi_info->rx_comp_q[0];
+		rx_cfg.rx_queue.q_num = cppi_info->rx_comp_q[ch_num];
 		for (i = 0; i < 4; i++)
 			rx_cfg.cfg.host_pkt.fdb_queue[i] = cppi_ch->src_queue;
 		cppi41_rx_ch_configure(&cppi_ch->dma_ch_obj, &rx_cfg);
@@ -544,6 +541,9 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 	u32 length = tx_ch->length - tx_ch->curr_offset;
 	u32 pkt_size = tx_ch->pkt_size;
 	unsigned num_pds, n;
+	struct usb_cppi41_info *cppi_info = cppi->cppi_info;
+	u16 q_mgr = cppi_info->q_mgr;
+	u16 tx_comp_q = cppi_info->tx_comp_q[tx_ch->ch_num];
 
 	/*
 	 * Tx can use the generic RNDIS mode where we can probably fit this
@@ -588,10 +588,13 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 				      CPPI41_DESC_TYPE_SHIFT) | pkt_size;
 		hw_desc->tag_info = tx_ch->tag_info;
 		hw_desc->pkt_info = cppi->pkt_info;
+		hw_desc->pkt_info |= ((q_mgr << CPPI41_RETURN_QMGR_SHIFT) |
+				(tx_comp_q << CPPI41_RETURN_QNUM_SHIFT));
 
 		hw_desc->buf_ptr = tx_ch->start_addr + tx_ch->curr_offset;
 		hw_desc->buf_len = pkt_size;
 		hw_desc->next_desc_ptr = 0;
+		hw_desc->orig_buf_len = pkt_size;
 
 		curr_pd->ch_num = tx_ch->ch_num;
 		curr_pd->ep_num = tx_ch->end_pt->epnum;
@@ -1014,7 +1017,7 @@ static void usb_rx_ch_teardown(struct cppi41_channel *rx_ch)
 
 	/* Now restore the default Rx completion queue... */
 	cppi41_dma_ch_default_queue(&rx_ch->dma_ch_obj, cppi_info->q_mgr,
-				    cppi_info->rx_comp_q[0]);
+				    cppi_info->rx_comp_q[rx_ch->ch_num]);
 }
 
 /*
@@ -1178,7 +1181,7 @@ cppi41_dma_controller_create(struct musb  *musb, void __iomem *mregs)
 	cppi->controller.channel_release = cppi41_channel_release;
 	cppi->controller.channel_program = cppi41_channel_program;
 	cppi->controller.channel_abort = cppi41_channel_abort;
-	cppi->cppi_info = &usb_cppi41_info;
+	cppi->cppi_info = (struct usb_cppi41_info *)&usb_cppi41_info[musb->id];;
 
 	return &cppi->controller;
 }
diff --git a/drivers/usb/musb/cppi41_dma.h b/drivers/usb/musb/cppi41_dma.h
index 908e8b7..b99de78 100644
--- a/drivers/usb/musb/cppi41_dma.h
+++ b/drivers/usb/musb/cppi41_dma.h
@@ -41,7 +41,7 @@ struct usb_cppi41_info {
 	const u16 *rx_comp_q;
 };
 
-extern struct usb_cppi41_info usb_cppi41_info;
+extern struct usb_cppi41_info usb_cppi41_info[];
 
 /**
  * cppi41_completion - Tx/Rx completion queue interrupt handling hook
-- 
1.7.5.4

