From 055995f96e082853c5f1f5a0454b646d35e99621 Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Tue, 14 Jun 2011 14:27:52 +0530
Subject: [PATCH 341/609] usb: musb: support each dma controller driver built
 as module

Original commit: 1ce78b389cecbf27ade44d8c9e1a98b68246660d

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch provides support for building each dma controller driver
as standalone module, and this modules can be built into one same
image and can be used by each hw glue driver.

HW glue driver has the knowledge of which type of dma controller will
be used, and can pass the knowledge into musb core driver via glue ops,
so we can take runtime method to support all hw controller and its dma
controller in one binary musb driver.

Signed-off-by: Ming Lei <tom.leiming@gmail.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/Kconfig         |   44 ++++++++++++++++++++++++---------
 drivers/usb/musb/Makefile        |    8 +++---
 drivers/usb/musb/blackfin.c      |    6 ++++-
 drivers/usb/musb/cppi_dma.c      |   21 +++++++++++++--
 drivers/usb/musb/davinci.c       |    5 +++-
 drivers/usb/musb/musb_core.c     |    9 +++++-
 drivers/usb/musb/musb_dma.h      |   50 ++++++++++++++++++++++++++++++++++++-
 drivers/usb/musb/musbhsdma.c     |   23 +++++++++++++++--
 drivers/usb/musb/omap2430.c      |    6 ++++-
 drivers/usb/musb/tusb6010.c      |    3 ++
 drivers/usb/musb/tusb6010_omap.c |   22 ++++++++++++++--
 11 files changed, 165 insertions(+), 32 deletions(-)

diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 7724c6b..27cd35c 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -93,36 +93,40 @@ config USB_MUSB_UX500
 
 choice
 	prompt 'MUSB DMA mode'
-	default USB_UX500_DMA if USB_MUSB_UX500
-	default USB_INVENTRA_DMA if USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
-	default USB_TI_CPPI_DMA if USB_MUSB_DAVINCI
-	default USB_TUSB_OMAP_DMA if USB_MUSB_TUSB6010
+	default USB_UX500_DMA_HW if USB_MUSB_UX500
+	default USB_INVENTRA_DMA_HW if USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
+	default USB_TI_CPPI_DMA_HW if USB_MUSB_DAVINCI
+	default USB_TUSB_OMAP_DMA_HW if USB_MUSB_TUSB6010
 	default MUSB_PIO_ONLY if USB_MUSB_TUSB6010 || USB_MUSB_DA8XX || USB_MUSB_AM35X
 	help
 	  Unfortunately, only one option can be enabled here. Ideally one
 	  should be able to build all these drivers into one kernel to
 	  allow using DMA on multiplatform kernels.
 
-config USB_UX500_DMA
-	bool 'ST Ericsson U8500 and U5500'
+config USB_UX500_DMA_HW
+	tristate 'ST Ericsson U8500 and U5500'
+	select USB_UX500_DMA
 	depends on USB_MUSB_UX500
 	help
 	  Enable DMA transfers on UX500 platforms.
 
-config USB_INVENTRA_DMA
-	bool 'Inventra'
+config USB_INVENTRA_DMA_HW
+	tristate 'Inventra'
+	select USB_INVENTRA_DMA
 	depends on USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
 	help
 	  Enable DMA transfers using Mentor's engine.
 
-config USB_TI_CPPI_DMA
-	bool 'TI CPPI (Davinci)'
+config USB_TI_CPPI_DMA_HW
+	tristate 'TI CPPI (Davinci)'
+	select USB_TI_CPPI_DMA
 	depends on USB_MUSB_DAVINCI
 	help
 	  Enable DMA transfers when TI CPPI DMA is available.
 
-config USB_TUSB_OMAP_DMA
-	bool 'TUSB 6010'
+config USB_TUSB_OMAP_DMA_HW
+	tristate 'TUSB 6010'
+	select USB_TUSB_OMAP_DMA
 	depends on USB_MUSB_TUSB6010
 	depends on ARCH_OMAP
 	help
@@ -141,4 +145,20 @@ config MUSB_PIO_ONLY
 
 endchoice
 
+config USB_INVENTRA_DMA
+	bool
+	default n
+
+config USB_TI_CPPI_DMA
+	bool
+	default n
+
+config USB_TUSB_OMAP_DMA
+	bool
+	default n
+
+config USB_UX500_DMA
+	bool
+	default n
+
 endif # USB_MUSB_HDRC
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index faf6a81..70d1929 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -24,7 +24,7 @@ obj-$(CONFIG_USB_MUSB_UX500_GLUE)			+= ux500.o
 # PIO only, or DMA (several potential schemes).
 # though PIO is always there to back up DMA, and for ep0
 
-musb_hdrc-$(CONFIG_USB_INVENTRA_DMA)		+= musbhsdma.o
-musb_hdrc-$(CONFIG_USB_TI_CPPI_DMA)		+= cppi_dma.o
-musb_hdrc-$(CONFIG_USB_TUSB_OMAP_DMA)		+= tusb6010_omap.o
-musb_hdrc-$(CONFIG_USB_UX500_DMA)		+= ux500_dma.o
+obj-$(CONFIG_USB_INVENTRA_DMA_HW)		+= musbhsdma.o
+obj-$(CONFIG_USB_TI_CPPI_DMA_HW)		+= cppi_dma.o
+obj-$(CONFIG_USB_TUSB_OMAP_DMA_HW)		+= tusb6010_omap.o
+obj-$(CONFIG_USB_UX500_DMA_HW)			+= ux500_dma.o
diff --git a/drivers/usb/musb/blackfin.c b/drivers/usb/musb/blackfin.c
index e882f9f..395b554a 100644
--- a/drivers/usb/musb/blackfin.c
+++ b/drivers/usb/musb/blackfin.c
@@ -448,7 +448,8 @@ static int bfin_musb_exit(struct musb *musb)
 
 static const struct musb_platform_ops bfin_ops = {
 	.fifo_mode	= 2,
-	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING,
+	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING |
+				MUSB_GLUE_DMA_INVENTRA,
 	.init		= bfin_musb_init,
 	.exit		= bfin_musb_exit,
 
@@ -465,6 +466,9 @@ static const struct musb_platform_ops bfin_ops = {
 	.set_vbus	= bfin_musb_set_vbus,
 
 	.adjust_channel_params = bfin_musb_adjust_channel_params,
+
+	.dma_controller_create = inventra_dma_controller_create,
+	.dma_controller_destroy = inventra_dma_controller_destroy,
 };
 
 static u64 bfin_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/cppi_dma.c b/drivers/usb/musb/cppi_dma.c
index 6d6378b..d4e182c 100644
--- a/drivers/usb/musb/cppi_dma.c
+++ b/drivers/usb/musb/cppi_dma.c
@@ -1318,7 +1318,7 @@ irqreturn_t cppi_interrupt(int irq, void *dev_id)
 
 /* Instantiate a software object representing a DMA controller. */
 struct dma_controller *__devinit
-dma_controller_create(struct musb *musb, void __iomem *mregs)
+cppi_dma_controller_create(struct musb *musb, void __iomem *mregs)
 {
 	struct cppi		*controller;
 	struct device		*dev = musb->controller;
@@ -1357,7 +1357,7 @@ dma_controller_create(struct musb *musb, void __iomem *mregs)
 	if (irq > 0) {
 		if (request_irq(irq, cppi_interrupt, 0, "cppi-dma", musb)) {
 			dev_err(dev, "request_irq %d failed!\n", irq);
-			dma_controller_destroy(&controller->controller);
+			cppi_dma_controller_destroy(&controller->controller);
 			return NULL;
 		}
 		controller->irq = irq;
@@ -1365,11 +1365,12 @@ dma_controller_create(struct musb *musb, void __iomem *mregs)
 
 	return &controller->controller;
 }
+EXPORT_SYMBOL(cppi_dma_controller_create);
 
 /*
  *  Destroy a previously-instantiated DMA controller.
  */
-void dma_controller_destroy(struct dma_controller *c)
+void cppi_dma_controller_destroy(struct dma_controller *c)
 {
 	struct cppi	*cppi;
 
@@ -1383,6 +1384,7 @@ void dma_controller_destroy(struct dma_controller *c)
 
 	kfree(cppi);
 }
+EXPORT_SYMBOL(cppi_dma_controller_destroy);
 
 /*
  * Context: controller irqlocked, endpoint selected
@@ -1563,3 +1565,16 @@ static int cppi_channel_abort(struct dma_channel *channel)
  * Power Management ... probably turn off cppi during suspend, restart;
  * check state ram?  Clocking is presumably shared with usb core.
  */
+MODULE_DESCRIPTION("CPPI dma controller driver for musb");
+MODULE_LICENSE("GPL v2");
+
+static int __init cppi_dma_init(void)
+{
+	return 0;
+}
+module_init(cppi_dma_init);
+
+static void __exit cppi_dma__exit(void)
+{
+}
+module_exit(cppi_dma__exit);
diff --git a/drivers/usb/musb/davinci.c b/drivers/usb/musb/davinci.c
index 28cc7a9..3be3d34 100644
--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -502,7 +502,7 @@ static int davinci_musb_exit(struct musb *musb)
 
 static const struct musb_platform_ops davinci_ops = {
 	.fifo_mode	= 2,
-	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING,
+	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING | MUSB_GLUE_DMA_CPPI,
 	.init		= davinci_musb_init,
 	.exit		= davinci_musb_exit,
 
@@ -515,6 +515,9 @@ static const struct musb_platform_ops davinci_ops = {
 
 	.read_fifo	= musb_read_fifo,
 	.write_fifo	= musb_write_fifo,
+
+	.dma_controller_create = cppi_dma_controller_create,
+	.dma_controller_destroy = cppi_dma_controller_destroy,
 };
 
 static u64 davinci_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 09bdc72..14e0aba 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1894,7 +1894,7 @@ static void musb_free(struct musb *musb)
 		struct dma_controller	*c = musb->dma_controller;
 
 		(void) c->stop(c);
-		dma_controller_destroy(c);
+		musb->ops->dma_controller_destroy(c);
 	}
 
 	kfree(musb);
@@ -1984,7 +1984,12 @@ musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 	if (use_dma && dev->dma_mask) {
 		struct dma_controller	*c;
 
-		c = dma_controller_create(musb, musb->mregs);
+		if (!musb->ops->dma_controller_create) {
+			dev_err(dev, "no dma_controller_create for non-PIO mode!\n");
+			status = -ENODEV;
+			goto fail3;
+		}
+		c = musb->ops->dma_controller_create(musb, musb->mregs);
 		musb->dma_controller = c;
 		if (c)
 			(void) c->start(c);
diff --git a/drivers/usb/musb/musb_dma.h b/drivers/usb/musb/musb_dma.h
index 24d3921..a6d9613 100644
--- a/drivers/usb/musb/musb_dma.h
+++ b/drivers/usb/musb/musb_dma.h
@@ -178,9 +178,55 @@ struct dma_controller {
 extern void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit);
 
 
+#ifdef CONFIG_USB_TI_CPPI_DMA
 extern struct dma_controller *__devinit
-dma_controller_create(struct musb *, void __iomem *);
+cppi_dma_controller_create(struct musb *, void __iomem *);
+
+extern void cppi_dma_controller_destroy(struct dma_controller *);
+#else
+static inline struct dma_controller *__devinit
+cppi_dma_controller_create(struct musb *musb, void __iomem *mregs)
+{
+	return NULL;
+}
+
+static inline void cppi_dma_controller_destroy(struct dma_controller *c)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_INVENTRA_DMA
+extern struct dma_controller *__devinit
+inventra_dma_controller_create(struct musb *, void __iomem *);
+
+extern void inventra_dma_controller_destroy(struct dma_controller *);
+#else
+static inline struct dma_controller *__devinit
+inventra_dma_controller_create(struct musb *musb, void __iomem *mregs)
+{
+	return NULL;
+}
 
-extern void dma_controller_destroy(struct dma_controller *);
+static inline void inventra_dma_controller_destroy(struct dma_controller *c)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_TUSB_OMAP_DMA
+extern struct dma_controller *__devinit
+tusb_dma_controller_create(struct musb *, void __iomem *);
+
+extern void tusb_dma_controller_destroy(struct dma_controller *);
+#else
+static inline struct dma_controller *__devinit
+tusb_dma_controller_create(struct musb *musb, void __iomem *mregs)
+{
+	return NULL;
+}
+
+static inline void tusb_dma_controller_destroy(struct dma_controller *c)
+{
+}
+#endif
 
 #endif	/* __MUSB_DMA_H__ */
diff --git a/drivers/usb/musb/musbhsdma.c b/drivers/usb/musb/musbhsdma.c
index 4d7d83b..9ba7a30 100644
--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -30,6 +30,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  */
+#include <linux/module.h>
 #include <linux/device.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
@@ -366,7 +367,7 @@ done:
 	return retval;
 }
 
-void dma_controller_destroy(struct dma_controller *c)
+void inventra_dma_controller_destroy(struct dma_controller *c)
 {
 	struct musb_dma_controller *controller = container_of(c,
 			struct musb_dma_controller, controller);
@@ -379,9 +380,10 @@ void dma_controller_destroy(struct dma_controller *c)
 
 	kfree(controller);
 }
+EXPORT_SYMBOL(inventra_dma_controller_destroy);
 
 struct dma_controller *__devinit
-dma_controller_create(struct musb *musb, void __iomem *base)
+inventra_dma_controller_create(struct musb *musb, void __iomem *base)
 {
 	struct musb_dma_controller *controller;
 	struct device *dev = musb->controller;
@@ -411,7 +413,7 @@ dma_controller_create(struct musb *musb, void __iomem *base)
 	if (request_irq(irq, dma_controller_irq, 0,
 			dev_name(musb->controller), &controller->controller)) {
 		dev_err(dev, "request_irq %d failed!\n", irq);
-		dma_controller_destroy(&controller->controller);
+		inventra_dma_controller_destroy(&controller->controller);
 
 		return NULL;
 	}
@@ -420,3 +422,18 @@ dma_controller_create(struct musb *musb, void __iomem *base)
 
 	return &controller->controller;
 }
+EXPORT_SYMBOL(inventra_dma_controller_create);
+
+MODULE_DESCRIPTION("MUSB Inventra dma controller driver");
+MODULE_LICENSE("GPL v2");
+
+static int __init inventra_dma_init(void)
+{
+	return 0;
+}
+module_init(inventra_dma_init);
+
+static void __exit inventra_dma__exit(void)
+{
+}
+module_exit(inventra_dma__exit);
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index fd0f798..2daaebf 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -398,7 +398,8 @@ static int omap2430_musb_exit(struct musb *musb)
 
 static const struct musb_platform_ops omap2430_ops = {
 	.fifo_mode	= 4,
-	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING,
+	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING |
+				MUSB_GLUE_DMA_INVENTRA,
 	.init		= omap2430_musb_init,
 	.exit		= omap2430_musb_exit,
 
@@ -412,6 +413,9 @@ static const struct musb_platform_ops omap2430_ops = {
 
 	.enable		= omap2430_musb_enable,
 	.disable	= omap2430_musb_disable,
+
+	.dma_controller_create = inventra_dma_controller_create,
+	.dma_controller_destroy = inventra_dma_controller_destroy,
 };
 
 static u64 omap2430_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index 87125a4..b67a92e 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -1171,6 +1171,9 @@ static const struct musb_platform_ops tusb_ops = {
 	.set_vbus	= tusb_musb_set_vbus,
 	.read_fifo	= tusb_musb_read_fifo,
 	.write_fifo	= tusb_musb_write_fifo,
+
+	.dma_controller_create = tusb_dma_controller_create,
+	.dma_controller_destroy = tusb_dma_controller_destroy,
 };
 
 static u64 tusb_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/tusb6010_omap.c b/drivers/usb/musb/tusb6010_omap.c
index 74fa695..4af0c2d 100644
--- a/drivers/usb/musb/tusb6010_omap.c
+++ b/drivers/usb/musb/tusb6010_omap.c
@@ -642,7 +642,7 @@ static void tusb_omap_dma_release(struct dma_channel *channel)
 	channel = NULL;
 }
 
-void dma_controller_destroy(struct dma_controller *c)
+void tusb_dma_controller_destroy(struct dma_controller *c)
 {
 	struct tusb_omap_dma	*tusb_dma;
 	int			i;
@@ -661,9 +661,10 @@ void dma_controller_destroy(struct dma_controller *c)
 
 	kfree(tusb_dma);
 }
+EXPORT_SYMBOL(tusb_dma_controller_destroy);
 
 struct dma_controller *__devinit
-dma_controller_create(struct musb *musb, void __iomem *base)
+tusb_dma_controller_create(struct musb *musb, void __iomem *base)
 {
 	void __iomem		*tbase = musb->ctrl_base;
 	struct tusb_omap_dma	*tusb_dma;
@@ -721,7 +722,22 @@ dma_controller_create(struct musb *musb, void __iomem *base)
 	return &tusb_dma->controller;
 
 cleanup:
-	dma_controller_destroy(&tusb_dma->controller);
+	tusb_dma_controller_destroy(&tusb_dma->controller);
 out:
 	return NULL;
 }
+EXPORT_SYMBOL(tusb_dma_controller_create);
+
+MODULE_DESCRIPTION("TUSB dma controller driver for musb");
+MODULE_LICENSE("GPL v2");
+
+static int __init tusb_dma_init(void)
+{
+	return 0;
+}
+module_init(tusb_dma_init);
+
+static void __exit tusb_dma__exit(void)
+{
+}
+module_exit(tusb_dma__exit);
-- 
1.7.5.4

