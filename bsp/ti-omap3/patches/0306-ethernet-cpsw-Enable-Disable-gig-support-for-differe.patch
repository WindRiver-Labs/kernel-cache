From b1ffb13727b698e27999d57c7f77eb4f1dd419d2 Mon Sep 17 00:00:00 2001
From: Chandan Nath <chandan.nath@ti.com>
Date: Thu, 12 Jul 2012 06:08:56 +0800
Subject: [PATCH 306/609] ethernet: cpsw: Enable/Disable gig support for
 different evm rev

Original commit: 86deec46e0d6d23797cc4f0dc8f1619264558e93

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch is added to enable cpsw gigabit mode support for beta
evm and disable gigabit support for alpha EVMs. Please note that
phy_register_fixup_for_uid() function cannot be used to configure
phydev->supported as it is not register configuration and that needs
to be configured after phy->connect.

Signed-off-by: Chandan Nath <chandan.nath@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c          |  164 +++++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/davinci_cpdma.c |    2 +
 2 files changed, 166 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 4c67697..9cc1284 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -96,6 +96,7 @@ do {								\
 #define CPSW_POLL_WEIGHT	64
 #define CPSW_MIN_PACKET_SIZE	60
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
+#define CPSW_PHY_SPEED		1000
 
 #define RX_PRIORITY_MAPPING	0x76543210
 #define TX_PRIORITY_MAPPING	0x33221100
@@ -190,6 +191,44 @@ struct cpsw_slave {
 	struct phy_device		*phy;
 };
 
+struct cpsw_hw_stats {
+	u32	rxgoodframes;
+	u32	rxbroadcastframes;
+	u32	rxmulticastframes;
+	u32	rxpauseframes;
+	u32	rxcrcerrors;
+	u32	rxaligncodeerrors;
+	u32	rxoversizedframes;
+	u32	rxjabberframes;
+	u32	rxundersizedframes;
+	u32	rxfragments;
+	u32	__pad_0[2];
+	u32	rxoctets;
+	u32	txgoodframes;
+	u32	txbroadcastframes;
+	u32	txmulticastframes;
+	u32	txpauseframes;
+	u32	txdeferredframes;
+	u32	txcollisionframes;
+	u32	txsinglecollframes;
+	u32	txmultcollframes;
+	u32	txexcessivecollisions;
+	u32	txlatecollisions;
+	u32	txunderrun;
+	u32	txcarriersenseerrors;
+	u32	txoctets;
+	u32	octetframes64;
+	u32	octetframes65t127;
+	u32	octetframes128t255;
+	u32	octetframes256t511;
+	u32	octetframes512t1023;
+	u32	octetframes1024tup;
+	u32	netoctets;
+	u32	rxsofoverruns;
+	u32	rxmofoverruns;
+	u32	rxdmaoverruns;
+};
+
 struct cpsw_priv {
 	spinlock_t			lock;
 	struct platform_device		*pdev;
@@ -201,6 +240,7 @@ struct cpsw_priv {
 	struct cpsw_platform_data	data;
 	struct cpsw_regs __iomem	*regs;
 	struct cpsw_ss_regs __iomem	*ss_regs;
+	struct cpsw_hw_stats __iomem	*hw_stats;
 	struct cpsw_host_regs __iomem	*host_port_regs;
 	u32				msg_enable;
 	struct net_device_stats		stats;
@@ -431,6 +471,129 @@ static inline int __show_stat(char *buf, int maxlen, const char *name, u32 val)
 				leader + strlen(name), val);
 }
 
+static ssize_t cpsw_hw_stats_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct net_device	*ndev = to_net_dev(dev);
+	struct cpsw_priv	*priv = netdev_priv(ndev);
+	int			len = 0;
+	struct cpdma_chan_stats	dma_stats;
+
+#define show_stat(x) do {						\
+	len += __show_stat(buf + len, SZ_4K - len, #x,			\
+			   __raw_readl(&priv->hw_stats->x));		\
+} while (0)
+
+#define show_dma_stat(x) do {						\
+	len += __show_stat(buf + len, SZ_4K - len, #x, dma_stats.x);	\
+} while (0)
+
+	len += snprintf(buf + len, SZ_4K - len, "CPSW Statistics:\n");
+	show_stat(rxgoodframes);	show_stat(rxbroadcastframes);
+	show_stat(rxmulticastframes);	show_stat(rxpauseframes);
+	show_stat(rxcrcerrors);		show_stat(rxaligncodeerrors);
+	show_stat(rxoversizedframes);	show_stat(rxjabberframes);
+	show_stat(rxundersizedframes);	show_stat(rxfragments);
+	show_stat(rxoctets);		show_stat(txgoodframes);
+	show_stat(txbroadcastframes);	show_stat(txmulticastframes);
+	show_stat(txpauseframes);	show_stat(txdeferredframes);
+	show_stat(txcollisionframes);	show_stat(txsinglecollframes);
+	show_stat(txmultcollframes);	show_stat(txexcessivecollisions);
+	show_stat(txlatecollisions);	show_stat(txunderrun);
+	show_stat(txcarriersenseerrors); show_stat(txoctets);
+	show_stat(octetframes64);	show_stat(octetframes65t127);
+	show_stat(octetframes128t255);	show_stat(octetframes256t511);
+	show_stat(octetframes512t1023);	show_stat(octetframes1024tup);
+	show_stat(netoctets);		show_stat(rxsofoverruns);
+	show_stat(rxmofoverruns);	show_stat(rxdmaoverruns);
+
+	cpdma_chan_get_stats(priv->rxch, &dma_stats);
+	len += snprintf(buf + len, SZ_4K - len, "\nRX DMA Statistics:\n");
+	show_dma_stat(head_enqueue);	show_dma_stat(tail_enqueue);
+	show_dma_stat(pad_enqueue);	show_dma_stat(misqueued);
+	show_dma_stat(desc_alloc_fail);	show_dma_stat(pad_alloc_fail);
+	show_dma_stat(runt_receive_buff); show_dma_stat(runt_transmit_buff);
+	show_dma_stat(empty_dequeue);	show_dma_stat(busy_dequeue);
+	show_dma_stat(good_dequeue);	show_dma_stat(teardown_dequeue);
+
+	cpdma_chan_get_stats(priv->txch, &dma_stats);
+	len += snprintf(buf + len, SZ_4K - len, "\nTX DMA Statistics:\n");
+	show_dma_stat(head_enqueue);	show_dma_stat(tail_enqueue);
+	show_dma_stat(pad_enqueue);	show_dma_stat(misqueued);
+	show_dma_stat(desc_alloc_fail);	show_dma_stat(pad_alloc_fail);
+	show_dma_stat(runt_receive_buff); show_dma_stat(runt_transmit_buff);
+	show_dma_stat(empty_dequeue);	show_dma_stat(busy_dequeue);
+	show_dma_stat(good_dequeue);	show_dma_stat(teardown_dequeue);
+
+	return len;
+}
+
+DEVICE_ATTR(hw_stats, S_IRUGO, cpsw_hw_stats_show, NULL);
+
+#define PHY_CONFIG_REG	22
+static void cpsw_set_phy_config(struct cpsw_priv *priv, struct phy_device *phy)
+{
+	struct cpsw_platform_data *pdata = priv->pdev->dev.platform_data;
+	struct mii_bus *miibus;
+	int phy_addr = 0;
+	u16 val = 0;
+	u16 tmp = 0;
+
+	if (!phy)
+		return;
+
+	miibus = phy->bus;
+
+	if (!miibus)
+		return;
+
+	phy_addr = phy->addr;
+
+	/* Disable 1 Gig mode support if it is not supported */
+	if (!pdata->gigabit_en)
+		phy->supported &= ~(SUPPORTED_1000baseT_Half |
+					SUPPORTED_1000baseT_Full);
+
+	/* Following lines enable gigbit advertisement capability even in case
+	 * the advertisement is not enabled by default
+	 */
+	val = miibus->read(miibus, phy_addr, MII_BMCR);
+	val |= (BMCR_SPEED100 | BMCR_ANENABLE | BMCR_FULLDPLX);
+	miibus->write(miibus, phy_addr, MII_BMCR, val);
+	tmp = miibus->read(miibus, phy_addr, MII_BMCR);
+
+	/* Enable gigabit support only if the speed is 1000Mbps */
+	if (phy->speed == CPSW_PHY_SPEED) {
+		tmp = miibus->read(miibus, phy_addr, MII_BMSR);
+		if (tmp & 0x1) {
+			val = miibus->read(miibus, phy_addr, MII_CTRL1000);
+			val |= BIT(9);
+			miibus->write(miibus, phy_addr, MII_CTRL1000, val);
+			tmp = miibus->read(miibus, phy_addr, MII_CTRL1000);
+		}
+	}
+
+	val = miibus->read(miibus, phy_addr, MII_ADVERTISE);
+	val |= (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+		ADVERTISE_100HALF | ADVERTISE_100FULL);
+	miibus->write(miibus, phy_addr, MII_ADVERTISE, val);
+	tmp = miibus->read(miibus, phy_addr, MII_ADVERTISE);
+
+	/* TODO : This check is required. This should be
+	 * moved to a board init section as its specific
+	 * to a phy.*/
+	if (phy->phy_id == 0x0282F014) {
+		/* This enables TX_CLK-ing in case of 10/100MBps operation */
+		val = miibus->read(miibus, phy_addr, PHY_CONFIG_REG);
+		val |= BIT(5);
+		miibus->write(miibus, phy_addr, PHY_CONFIG_REG, val);
+		tmp = miibus->read(miibus, phy_addr, PHY_CONFIG_REG);
+	}
+
+	return;
+}
+
 static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 {
 	char name[32];
@@ -464,6 +627,7 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 	} else {
 		dev_info(priv->dev, "phy found : id is : 0x%x\n",
 			 slave->phy->phy_id);
+		cpsw_set_phy_config(priv, slave->phy);
 		phy_start(slave->phy);
 	}
 }
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 5391e5a..93d12f9 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -477,6 +477,8 @@ EXPORT_SYMBOL_GPL(cpdma_ctlr_int_ctrl);
 void cpdma_ctlr_eoi(struct cpdma_ctlr *ctlr)
 {
 	dma_reg_write(ctlr, CPDMA_MACEOIVECTOR, 0);
+	dma_reg_write(ctlr, CPDMA_MACEOIVECTOR, 1);
+	dma_reg_write(ctlr, CPDMA_MACEOIVECTOR, 2);
 }
 EXPORT_SYMBOL_GPL(cpdma_ctlr_eoi);
 
-- 
1.7.5.4

