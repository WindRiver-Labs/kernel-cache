From c99b6283e29125a2eeec5152ecd915ca0e05a218 Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Tue, 14 Jun 2011 23:50:57 +0530
Subject: [PATCH 373/609] musb: cppi: ISO IN fixes for CPPI DMA

Original commit: b6fe8b80d61ac93a3b583f8900f2b107487dd29e

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

ISO doesn't work without this patch as CPPI DMA is not even
programmed for ISO IN transfer.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/musb_host.c |   86 +++++++++++++++++++++++++-----------------
 1 files changed, 51 insertions(+), 35 deletions(-)

diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 644d103..af98e18 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -871,9 +871,9 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 		} else {
 			csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 
-			if (csr & (MUSB_RXCSR_RXPKTRDY
-					| MUSB_RXCSR_DMAENAB
-					| MUSB_RXCSR_H_REQPKT))
+			if (csr & (MUSB_RXCSR_RXPKTRDY | (is_cppi_enabled(musb)
+			|| is_cppi41_enabled(musb)) ? 0 : MUSB_RXCSR_DMAENAB
+			| MUSB_RXCSR_H_REQPKT))
 				ERR("broken !rx_reinit, ep%d csr %04x\n",
 						hw_ep->epnum, csr);
 
@@ -1634,49 +1634,65 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			| MUSB_RXCSR_H_AUTOREQ
 			| MUSB_RXCSR_AUTOCLEAR
 			| MUSB_RXCSR_RXPKTRDY);
-		musb_writew(hw_ep->regs, MUSB_RXCSR, val);
 
-		if (is_inventra_dma(musb)) {
-			if (usb_pipeisoc(pipe)) {
-				struct usb_iso_packet_descriptor *d;
+		if (is_cppi_enabled(musb) || is_cppi41_enabled(musb))
+			val |= MUSB_RXCSR_DMAENAB;
 
-				d = urb->iso_frame_desc + qh->iso_idx;
-				d->actual_length = xfer_len;
+		musb_writew(hw_ep->regs, MUSB_RXCSR, val);
 
-				/* even if there was an error, we did the dma
-				 * for iso_frame_desc->length
-				 */
-				if (d->status != -EILSEQ
-					&& d->status != -EOVERFLOW)
-					d->status = 0;
+		if (usb_pipeisoc(pipe)) {
+			struct usb_iso_packet_descriptor *d;
 
-				if (++qh->iso_idx >= urb->number_of_packets)
-					done = true;
-				else
-					done = false;
+			d = urb->iso_frame_desc + qh->iso_idx;
+			d->actual_length = xfer_len;
+
+			/* even if there was an error, we did the dma
+			 * for iso_frame_desc->length
+			 */
+			if (d->status != -EILSEQ && d->status != -EOVERFLOW)
+				d->status = 0;
 
-			} else  {
+			if (++qh->iso_idx >= urb->number_of_packets)
+				done = true;
+			else if (is_cppi_enabled(musb) ||
+					is_cppi41_enabled(musb)) {
+				struct dma_controller   *c;
+				void *buf;
+				u32 length, ret;
+
+				c = musb->dma_controller;
+				buf = (void *)
+					urb->iso_frame_desc[qh->iso_idx].offset
+					+ (u32)urb->transfer_dma;
+
+				length =
+					urb->iso_frame_desc[qh->iso_idx].length;
+
+				ret = c->channel_program(dma, qh->maxpacket,
+						0, (u32) buf, length);
+				done = false;
+			} else {
+				done = false;
+			}
+		} else  {
 			/* done if urb buffer is full or short packet is recd */
 			done = (urb->actual_length + xfer_len >=
 					urb->transfer_buffer_length
 				|| dma->actual_len < qh->maxpacket);
-			}
+		}
 
-			/* send IN token for next packet, without AUTOREQ */
-			if (!done) {
-				val |= MUSB_RXCSR_H_REQPKT;
-				musb_writew(epio, MUSB_RXCSR,
-					MUSB_RXCSR_H_WZC_BITS | val);
-			}
+		/* send IN token for next packet, without AUTOREQ */
+		if (!done) {
+			val |= MUSB_RXCSR_H_REQPKT;
+			musb_writew(epio, MUSB_RXCSR,
+				MUSB_RXCSR_H_WZC_BITS | val);
+		}
 
-			dev_dbg(musb->controller,
+		dev_dbg(musb->controller,
 			"ep %d dma %s, rxcsr %04x, rxcount %d\n", epnum,
-				done ? "off" : "reset",
-				musb_readw(epio, MUSB_RXCSR),
-				musb_readw(epio, MUSB_RXCOUNT));
-		} else {
-			done = true;
-		}
+			done ? "off" : "reset",
+			musb_readw(epio, MUSB_RXCSR),
+			musb_readw(epio, MUSB_RXCOUNT));
 	} else if (urb->status == -EINPROGRESS) {
 		/* if no errors, be sure a packet is ready for unloading */
 		if (unlikely(!(rx_csr & MUSB_RXCSR_RXPKTRDY))) {
@@ -1694,7 +1710,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 		}
 
 		/* we are expecting IN packets */
-		if (is_inventra_dma(musb) && dma) {
+		if (dma) {
 			struct dma_controller	*c;
 			u16			rx_count;
 			int			ret, length;
-- 
1.7.5.4

