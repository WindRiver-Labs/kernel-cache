From 90294740ba75413950ee6468c4be2828d8de1d71 Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Fri, 29 Jun 2012 14:49:38 +0800
Subject: [PATCH 376/609] musb: AM35x: Add CPPI4.1 DMA support

Original commit: 3a275eca6fa09af28073ba64ea3dc37fec04f8f6

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Adding CPPI4.1 DMA support for musb driver.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/plat-omap/include/plat/usb.h |   43 +++++++
 drivers/usb/musb/Kconfig              |    8 +-
 drivers/usb/musb/am35x.c              |  224 ++++++++++++++++++++++++++++++++-
 drivers/usb/musb/musb_dma.h           |   17 +++
 4 files changed, 285 insertions(+), 7 deletions(-)

diff --git a/arch/arm/plat-omap/include/plat/usb.h b/arch/arm/plat-omap/include/plat/usb.h
index 762eeb0..ec08698 100644
--- a/arch/arm/plat-omap/include/plat/usb.h
+++ b/arch/arm/plat-omap/include/plat/usb.h
@@ -362,4 +362,47 @@ static inline u32 omap1_usb2_init(unsigned nwires, unsigned alt_pingroup)
 }
 #endif
 
+/* DMA registers */
+#define USB_AUTOREQ_REG		0x14
+#define USB_TEARDOWN_REG	0x1c
+#define MOP_SOP_INTR_ENABLE	0x64
+/* 0x68-0x6c Reserved */
+#define USB_TX_MODE_REG		0x70	/* Transparent, CDC, [Generic] RNDIS */
+#define USB_RX_MODE_REG		0x74	/* Transparent, CDC, [Generic] RNDIS */
+#define EP_COUNT_MODE_REG	0x78
+#define USB_GENERIC_RNDIS_EP_SIZE_REG(n) (0x80 + (((n) - 1) << 2))
+
+#define QUEUE_THRESHOLD_INTR_ENABLE_REG	0xc0
+#define	QUEUE_63_THRESHOLD_REG	0xc4
+#define QUEUE_63_THRESHOLD_INTR_CLEAR_REG 0xc8
+#define	QUEUE_65_THRESHOLD_REG	0xd4
+#define QUEUE_65_THRESHOLD_INTR_CLEAR_REG 0xd8
+
+/* Mode register bits */
+#define USB_MODE_SHIFT(n)	((((n) - 1) << 1))
+#define USB_MODE_MASK(n)	(3 << USB_MODE_SHIFT(n))
+#define USB_RX_MODE_SHIFT(n)	USB_MODE_SHIFT(n)
+#define USB_TX_MODE_SHIFT(n)	USB_MODE_SHIFT(n)
+#define USB_RX_MODE_MASK(n)	USB_MODE_MASK(n)
+#define USB_TX_MODE_MASK(n)	USB_MODE_MASK(n)
+#define USB_TRANSPARENT_MODE	0
+#define USB_RNDIS_MODE		1
+#define USB_CDC_MODE		2
+#define USB_GENERIC_RNDIS_MODE	3
+
+/* AutoReq register bits */
+#define USB_RX_AUTOREQ_SHIFT(n) (((n) - 1) << 1)
+#define USB_RX_AUTOREQ_MASK(n)	(3 << USB_RX_AUTOREQ_SHIFT(n))
+#define USB_NO_AUTOREQ		0
+#define USB_AUTOREQ_ALL_BUT_EOP 1
+#define USB_AUTOREQ_ALWAYS	3
+
+/* Teardown register bits */
+#define USB_TX_TDOWN_SHIFT(n)	(16 + (n))
+#define USB_TX_TDOWN_MASK(n)	(1 << USB_TX_TDOWN_SHIFT(n))
+#define USB_RX_TDOWN_SHIFT(n)	(n)
+#define USB_RX_TDOWN_MASK(n)	(1 << USB_RX_TDOWN_SHIFT(n))
+
+#define USB_CPPI41_NUM_CH	15
+
 #endif	/* __ASM_ARCH_OMAP_USB_H */
diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index 4755d5e..c3f5eeb 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -97,8 +97,8 @@ choice
 	default USB_INVENTRA_DMA_HW if USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
 	default USB_TI_CPPI_DMA_HW if USB_MUSB_DAVINCI
 	default USB_TUSB_OMAP_DMA_HW if USB_MUSB_TUSB6010
-	default USB_TI_CPPI41_DMA_HW if USB_MUSB_DA8XX
-	default MUSB_PIO_ONLY if USB_MUSB_TUSB6010 || USB_MUSB_DA8XX || USB_MUSB_AM35X
+	default USB_TI_CPPI41_DMA_HW if USB_MUSB_DA8XX || USB_MUSB_AM35X
+	default MUSB_PIO_ONLY if USB_MUSB_TUSB6010 || USB_MUSB_DA8XX
 	help
 	  Unfortunately, only one option can be enabled here. Ideally one
 	  should be able to build all these drivers into one kernel to
@@ -114,7 +114,7 @@ config USB_UX500_DMA_HW
 config USB_INVENTRA_DMA_HW
 	tristate 'Inventra'
 	select USB_INVENTRA_DMA
-	depends on USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN
+	depends on (USB_MUSB_OMAP2PLUS || USB_MUSB_BLACKFIN) && !USB_MUSB_AM35X
 	help
 	  Enable DMA transfers using Mentor's engine.
 
@@ -128,7 +128,7 @@ config USB_TI_CPPI_DMA_HW
 config USB_TI_CPPI41_DMA_HW
 	tristate 'TI CPPI4.1'
 	select USB_TI_CPPI41_DMA
-	depends on USB_MUSB_DA8XX
+	depends on USB_MUSB_DA8XX || USB_MUSB_AM35X
 	select CPPI41
 	help
 	 Configure this option to include the CPPI 4.1 support,
diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index 6d7d5a3..0b2b633 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -36,6 +36,8 @@
 #include <plat/usb.h>
 
 #include "musb_core.h"
+#include "cppi41.h"
+#include "cppi41_dma.h"
 
 /*
  * AM35x specific definitions
@@ -46,9 +48,7 @@
 #define USB_STAT_REG		0x08
 #define USB_EMULATION_REG	0x0c
 /* 0x10 Reserved */
-#define USB_AUTOREQ_REG		0x14
 #define USB_SRP_FIX_TIME_REG	0x18
-#define USB_TEARDOWN_REG	0x1c
 #define EP_INTR_SRC_REG		0x20
 #define EP_INTR_SRC_SET_REG	0x24
 #define EP_INTR_SRC_CLEAR_REG	0x28
@@ -80,8 +80,189 @@
 #define AM35X_TX_INTR_MASK	(AM35X_TX_EP_MASK << AM35X_INTR_TX_SHIFT)
 #define AM35X_RX_INTR_MASK	(AM35X_RX_EP_MASK << AM35X_INTR_RX_SHIFT)
 
+/* CPPI 4.1 queue manager registers */
+#define QMGR_PEND0_REG		0x4090
+#define QMGR_PEND1_REG		0x4094
+#define QMGR_PEND2_REG		0x4098
+
 #define USB_MENTOR_CORE_OFFSET	0x400
 
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+/*
+ * CPPI 4.1 resources used for USB OTG controller module:
+ *
+ * USB   DMA  DMA  QMgr  Tx     Src
+ *       Tx   Rx         QNum   Port
+ * ---------------------------------
+ * EP0   0    0    0     16,17  1
+ * ---------------------------------
+ * EP1   1    1    0     18,19  2
+ * ---------------------------------
+ * EP2   2    2    0     20,21  3
+ * ---------------------------------
+ * EP3   3    3    0     22,23  4
+ * ---------------------------------
+ */
+
+static const u16 tx_comp_q[] = { 63, 64 };
+static const u16 rx_comp_q[] = { 65, 66 };
+
+const struct usb_cppi41_info usb_cppi41_info = {
+	.dma_block	= 0,
+	.ep_dma_ch	= { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 },
+	.q_mgr		= 0,
+	.num_tx_comp_q	= 2,
+	.num_rx_comp_q	= 2,
+	.tx_comp_q	= tx_comp_q,
+	.rx_comp_q	= rx_comp_q
+};
+
+/* Fair scheduling */
+u32 dma_sched_table[] = {
+	0x81018000, 0x83038202, 0x85058404, 0x87078606,
+	0x89098808, 0x8b0b8a0a, 0x8d0d8c0c, 0x00008e0e
+};
+
+/* DMA block configuration */
+static const struct cppi41_tx_ch tx_ch_info[] = {
+	[0] = {
+		.port_num	= 1,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 32} , {0, 33} }
+	},
+	[1] = {
+		.port_num	= 2,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 34} , {0, 35} }
+	},
+	[2] = {
+		.port_num	= 3,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 36} , {0, 37} }
+	},
+	[3] = {
+		.port_num	= 4,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 38} , {0, 39} }
+	},
+	[4] = {
+		.port_num	= 5,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 40} , {0, 41} }
+	},
+	[5] = {
+		.port_num	= 6,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 42} , {0, 43} }
+	},
+	[6] = {
+		.port_num	= 7,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 44} , {0, 45} }
+	},
+	[7] = {
+		.port_num	= 8,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 46} , {0, 47} }
+	},
+	[8] = {
+		.port_num	= 9,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 48} , {0, 49} }
+	},
+	[9] = {
+		.port_num	= 10,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 50} , {0, 51} }
+	},
+	[10] = {
+		.port_num	= 11,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 52} , {0, 53} }
+	},
+	[11] = {
+		.port_num	= 12,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 54} , {0, 55} }
+	},
+	[12] = {
+		.port_num	= 13,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 56} , {0, 57} }
+	},
+	[13] = {
+		.port_num	= 14,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 58} , {0, 59} }
+	},
+	[14] = {
+		.port_num	= 15,
+		.num_tx_queue	= 2,
+		.tx_queue	= { {0, 60} , {0, 61} }
+	}
+};
+
+struct cppi41_dma_block cppi41_dma_block[CPPI41_NUM_DMA_BLOCK] = {
+	[0] = {
+		.global_ctrl_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x1000,
+		.ch_ctrl_stat_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x1800,
+		.sched_ctrl_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x2000,
+		.sched_table_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x2800,
+		.num_tx_ch	= 15,
+		.num_rx_ch	= 15,
+		.tx_ch_info	= tx_ch_info
+	}
+};
+EXPORT_SYMBOL(cppi41_dma_block);
+
+/* Queues 0 to 66 are pre-assigned, others are spare */
+static const u32 assigned_queues[] = { 0xffffffff, 0xffffffff, 0x7 };
+
+/* Queue manager information */
+struct cppi41_queue_mgr cppi41_queue_mgr[CPPI41_NUM_QUEUE_MGR] = {
+	[0] = {
+		.q_mgr_rgn_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x4000,
+		.desc_mem_rgn_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x5000,
+		.q_mgmt_rgn_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x6000,
+		.q_stat_rgn_base =
+			IO_ADDRESS(OMAP34XX_HSUSB_OTG_BASE) + 0x6800,
+
+		.num_queue	= 96,
+		.queue_types	= CPPI41_FREE_DESC_BUF_QUEUE |
+					CPPI41_UNASSIGNED_QUEUE,
+		.base_fdbq_num	= 0,
+		.assigned	= assigned_queues
+	}
+};
+EXPORT_SYMBOL(cppi41_queue_mgr);
+
+int __init cppi41_init(struct musb *musb)
+{
+	u16 numch, blknum = usb_cppi41_info.dma_block, order;
+
+	/* Initialize for Linking RAM region 0 alone */
+	cppi41_queue_mgr_init(usb_cppi41_info.q_mgr, 0, 0x3fff);
+
+	numch =  USB_CPPI41_NUM_CH * 2;
+	order = get_count_order(numch);
+
+	/* TODO: check two teardown desc per channel (5 or 7 ?)*/
+	if (order < 5)
+		order = 5;
+
+	cppi41_dma_block_init(blknum, usb_cppi41_info.q_mgr, order,
+			dma_sched_table, numch);
+	return 0;
+}
+#endif /* CONFIG_USB_TI_CPPI41_DMA */
+
 struct am35x_glue {
 	struct device		*dev;
 	struct platform_device	*musb;
@@ -229,10 +410,36 @@ static irqreturn_t am35x_musb_interrupt(int irq, void *hci)
 	struct usb_otg *otg = musb->xceiv->otg;
 	unsigned long flags;
 	irqreturn_t ret = IRQ_NONE;
+	u32 pend1 = 0, pend2 = 0, tx, rx;
 	u32 epintr, usbintr;
 
 	spin_lock_irqsave(&musb->lock, flags);
 
+	/*
+	 * CPPI 4.1 interrupts share the same IRQ and the EOI register but
+	 * don't get reflected in the interrupt source/mask registers.
+	 */
+	if (is_cppi41_enabled(musb)) {
+		/*
+		 * Check for the interrupts from Tx/Rx completion queues; they
+		 * are level-triggered and will stay asserted until the queues
+		 * are emptied.  We're using the queue pending register 0 as a
+		 * substitute for the interrupt status register and reading it
+		 * directly for speed.
+		 */
+		pend1 = musb_readl(reg_base, QMGR_PEND1_REG);
+		pend2 = musb_readl(reg_base, QMGR_PEND2_REG);
+
+		/* AM3517 uses 63,64,65 and 66 queues as completion queue */
+		if ((pend1 & (1 << 31)) || (pend2 & (7 << 0))) {
+			tx = (pend1 >> 31)  | ((pend2 & 1) ? (1 << 1) : 0);
+			rx = (pend2 >> 1) & 0x3;
+
+			DBG(4, "CPPI 4.1 IRQ: Tx %x, Rx %x\n", tx, rx);
+			cppi41_completion(musb, rx, tx);
+			ret = IRQ_HANDLED;
+		}
+	}
 	/* Get endpoint interrupts */
 	epintr = musb_readl(reg_base, EP_INTR_SRC_MASKED_REG);
 
@@ -384,6 +591,10 @@ static int am35x_musb_init(struct musb *musb)
 
 	msleep(5);
 
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+	cppi41_init();
+#endif
+
 	musb->isr = am35x_musb_interrupt;
 
 	/* clear level interrupt */
@@ -409,6 +620,10 @@ static int am35x_musb_exit(struct musb *musb)
 	usb_put_transceiver(musb->xceiv);
 	usb_nop_xceiv_unregister();
 
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+	cppi41_exit();
+#endif
+
 	return 0;
 }
 
@@ -444,7 +659,7 @@ static void am35x_musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)
 
 static const struct musb_platform_ops am35x_ops = {
 	.fifo_mode	= 4,
-	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING,
+	.flags		= MUSB_GLUE_EP_ADDR_FLAT_MAPPING | MUSB_GLUE_DMA_CPPI41,
 	.init		= am35x_musb_init,
 	.exit		= am35x_musb_exit,
 
@@ -458,6 +673,9 @@ static const struct musb_platform_ops am35x_ops = {
 
 	.read_fifo  = am35x_musb_read_fifo,
 	.write_fifo = musb_write_fifo,
+
+	.dma_controller_create = cppi41_dma_controller_create,
+	.dma_controller_destroy = cppi41_dma_controller_destroy,
 };
 
 static u64 am35x_dmamask = DMA_BIT_MASK(32);
diff --git a/drivers/usb/musb/musb_dma.h b/drivers/usb/musb/musb_dma.h
index 1723e88..06e857e 100644
--- a/drivers/usb/musb/musb_dma.h
+++ b/drivers/usb/musb/musb_dma.h
@@ -214,6 +214,23 @@ static inline void cppi_dma_controller_destroy(struct dma_controller *c)
 }
 #endif
 
+#ifdef CONFIG_USB_TI_CPPI41_DMA
+extern struct dma_controller *__devinit
+cppi41_dma_controller_create(struct musb *, void __iomem *);
+
+extern void cppi41_dma_controller_destroy(struct dma_controller *);
+#else
+static inline struct dma_controller *__devinit
+cppi41_dma_controller_create(struct musb *musb, void __iomem *mregs)
+{
+	return NULL;
+}
+
+static inline void cppi41_dma_controller_destroy(struct dma_controller *c)
+{
+}
+#endif
+
 #ifdef CONFIG_USB_INVENTRA_DMA
 extern struct dma_controller *__devinit
 inventra_dma_controller_create(struct musb *, void __iomem *);
-- 
1.7.5.4

