From 80c67a88b660a5bfdfa15636d7444edccf95bd83 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Sun, 27 Nov 2011 02:18:24 +0530
Subject: [PATCH 053/609] ARM:omap:am33xx: routing CPSW interrupts via Timer

Original commit: 8c32c4f2798e652d51920bfdd9d5ad32be68f565

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch is added to route CPSW interrupts through ICSS module.
CPSW CPSW_RX and CPSW_TX interrupts are not directly used from CPSW
and instead they are routed through Timer module. This is done as an
software workaround for enabling interrupt pacing feature. As interrupt
Pacing works on C0_RX_PULSE interrupt connection to A8 INTC, which is
not connected to Cortex A8 interrupt controller directly due to hw issue,
it prevents interrupt pacing to work in AM33xx EVM. Therefore, Timer
capture module is used to pickup these interrupts and routed to A8 INTC.

Signed-off-by: Chandan Nath <chandan.nath@ti.com>
Signed-off-by: Afzal Mohammed <afzal@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/devices.c             |   11 +++-----
 arch/arm/plat-omap/dmtimer.c              |   39 ++++++++++++++++++++++++++---
 arch/arm/plat-omap/include/plat/am33xx.h  |    4 +++
 arch/arm/plat-omap/include/plat/dmtimer.h |    3 ++
 4 files changed, 46 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index c6d59b7..175a991 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1140,9 +1140,6 @@ static int __init omap2_init_devices(void)
 }
 arch_initcall(omap2_init_devices);
 
-#define AM33XX_CPSW_BASE		(0x4A100000)
-#define AM33XX_CPSW_MDIO_BASE		(0x4A101000)
-#define AM33XX_CPSW_SS_BASE		(0x4A101200)
 #define AM33XX_EMAC_MDIO_FREQ		(1000000)
 
 static u64 am33xx_cpsw_dmamask = DMA_BIT_MASK(32);
@@ -1217,13 +1214,13 @@ static struct resource am33xx_cpsw_resources[] = {
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= AM33XX_IRQ_CPSW_RX,
-		.end	= AM33XX_IRQ_CPSW_RX,
+		.start	= AM33XX_IRQ_DMTIMER5,
+		.end	= AM33XX_IRQ_DMTIMER5,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
-		.start	= AM33XX_IRQ_CPSW_TX,
-		.end	= AM33XX_IRQ_CPSW_TX,
+		.start	= AM33XX_IRQ_DMTIMER6,
+		.end	= AM33XX_IRQ_DMTIMER6,
 		.flags	= IORESOURCE_IRQ,
 	},
 	{
diff --git a/arch/arm/plat-omap/dmtimer.c b/arch/arm/plat-omap/dmtimer.c
index 7ac301e..de3747c 100644
--- a/arch/arm/plat-omap/dmtimer.c
+++ b/arch/arm/plat-omap/dmtimer.c
@@ -136,7 +136,6 @@ static void omap_dm_timer_reset(struct omap_dm_timer *timer)
 int omap_dm_timer_prepare(struct omap_dm_timer *timer)
 {
 	struct dmtimer_platform_data *pdata = timer->pdev->dev.platform_data;
-	int ret;
 
 	timer->fclk = clk_get(&timer->pdev->dev, "fck");
 	if (WARN_ON_ONCE(IS_ERR_OR_NULL(timer->fclk))) {
@@ -148,10 +147,8 @@ int omap_dm_timer_prepare(struct omap_dm_timer *timer)
 	if (pdata->needs_manual_reset)
 		omap_dm_timer_reset(timer);
 
-	ret = omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);
-
 	timer->posted = 1;
-	return ret;
+	return 0;
 }
 
 struct omap_dm_timer *omap_dm_timer_request(void)
@@ -509,6 +506,40 @@ int omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on,
 }
 EXPORT_SYMBOL_GPL(omap_dm_timer_set_pwm);
 
+int omap_dm_timer_set_capture(struct omap_dm_timer *timer, bool lht,
+				bool hlt, bool cm)
+{
+	u32 l;
+
+	if (unlikely(!timer))
+		return -EINVAL;
+
+	omap_dm_timer_enable(timer);
+	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_CTRL_REG);
+
+	if (lht && hlt)
+		l |= OMAP_TIMER_CTRL_TCM_BOTHEDGES;
+	else if (lht)
+		l |= OMAP_TIMER_CTRL_TCM_LOWTOHIGH;
+	else if (hlt)
+		l |= OMAP_TIMER_CTRL_TCM_HIGHTOLOW;
+	else
+		l &= ~OMAP_TIMER_CTRL_TCM_BOTHEDGES;
+
+	if (cm)
+		l |= OMAP_TIMER_CTRL_CAPTMODE;
+	else
+		l &= ~OMAP_TIMER_CTRL_CAPTMODE;
+
+	omap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);
+
+	/* Save the context */
+	timer->context.tclr = l;
+	omap_dm_timer_disable(timer);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(omap_dm_timer_set_capture);
+
 int omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler)
 {
 	u32 l;
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index b3eb727..2126965 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -68,6 +68,10 @@
 #define AM33XX_ASP0_BASE	0x48038000
 #define AM33XX_ASP1_BASE	0x4803C000
 
+#define AM33XX_CPSW_BASE       0x4A100000
+#define AM33XX_CPSW_MDIO_BASE  0x4A101000
+#define AM33XX_CPSW_SS_BASE    0x4A101200
+
 #define AM33XX_ICSS_BASE	0x4A300000
 #define AM33XX_ICSS_LEN		0x3FFFF
 
diff --git a/arch/arm/plat-omap/include/plat/dmtimer.h b/arch/arm/plat-omap/include/plat/dmtimer.h
index 9418f00..d9432b0 100644
--- a/arch/arm/plat-omap/include/plat/dmtimer.h
+++ b/arch/arm/plat-omap/include/plat/dmtimer.h
@@ -47,6 +47,7 @@
 
 /* timer interrupt enable bits */
 #define OMAP_TIMER_INT_CAPTURE			(1 << 2)
+#define OMAP_TIMER_INT_CAPTURE_RESET		(0 << 2)
 #define OMAP_TIMER_INT_OVERFLOW			(1 << 1)
 #define OMAP_TIMER_INT_MATCH			(1 << 0)
 
@@ -127,6 +128,8 @@ int omap_dm_timer_set_load(struct omap_dm_timer *timer, int autoreload, unsigned
 int omap_dm_timer_set_load_start(struct omap_dm_timer *timer, int autoreload, unsigned int value);
 int omap_dm_timer_set_match(struct omap_dm_timer *timer, int enable, unsigned int match);
 int omap_dm_timer_set_pwm(struct omap_dm_timer *timer, int def_on, int toggle, int trigger);
+int omap_dm_timer_set_capture(struct omap_dm_timer *timer,
+				bool lht, bool hlt, bool cm);
 int omap_dm_timer_set_prescaler(struct omap_dm_timer *timer, int prescaler);
 
 int omap_dm_timer_set_int_enable(struct omap_dm_timer *timer, unsigned int value);
-- 
1.7.5.4

