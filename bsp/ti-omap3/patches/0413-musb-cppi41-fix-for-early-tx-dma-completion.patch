From bb39c5da1bebedb33378017efaf88651f1be10af Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Thu, 15 Sep 2011 17:00:46 +0530
Subject: [PATCH 413/609] musb:cppi41: fix for early tx-dma completion

Original commit: 7f2319d99ec288e8b2cbd2de19945e8083d1109d

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

The tx-dma completion occurs early, while endpoint fifo
is nonempty and transmit is still in progress.
The patch workaround this issue by polling for tx endpoint
fifo in worker thread till last byte from fifo is
transmitted out.

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41_dma.c |   68 ++++++++++++++++++++++++++++++++++++++---
 1 files changed, 63 insertions(+), 5 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 1061453..d3acc67 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -99,6 +99,7 @@ struct cppi41_channel {
 	u8  transfer_mode;
 	u8  zlp_queued;
 	u8  inf_mode;
+	u8  tx_complete;
 };
 
 /**
@@ -113,6 +114,7 @@ struct cppi41 {
 
 	struct cppi41_channel tx_cppi_ch[USB_CPPI41_NUM_CH];
 	struct cppi41_channel rx_cppi_ch[USB_CPPI41_NUM_CH];
+	struct work_struct      txdma_work;
 
 	struct usb_pkt_desc *pd_pool_head; /* Free PD pool head */
 	dma_addr_t pd_mem_phys;		/* PD memory physical address */
@@ -1192,6 +1194,7 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 		csr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_H_WZC_BITS;
 		musb_writew(epio, MUSB_TXCSR, csr);
 		musb_writew(epio, MUSB_TXCSR, csr);
+		cppi_ch->tx_complete = 0;
 	} else { /* Rx */
 		dprintk("Rx channel teardown, cppi_ch = %p\n", cppi_ch);
 
@@ -1270,6 +1273,63 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 	return 0;
 }
 
+void txdma_completion_work(struct work_struct *data)
+{
+	struct cppi41 *cppi = container_of(data, struct cppi41, txdma_work);
+	struct cppi41_channel *tx_ch;
+	struct musb *musb = cppi->musb;
+	unsigned index;
+	u8 resched = 0;
+	unsigned long flags;
+
+	while (1) {
+		for (index = 0; index < USB_CPPI41_NUM_CH; index++) {
+			void __iomem *epio;
+			u16 csr;
+
+			tx_ch = &cppi->tx_cppi_ch[index];
+			spin_lock_irqsave(&musb->lock, flags);
+			if (tx_ch->tx_complete) {
+				/* Sometimes a EP can unregister from a DMA
+				 * channel while the data is still in the FIFO.
+				 * Probable reason a proper abort was not
+				 * called before taking such a step.
+				 * Protect against such cases.
+				 */
+				if (!tx_ch->end_pt) {
+					tx_ch->tx_complete = 0;
+					continue;
+				}
+
+				epio = tx_ch->end_pt->regs;
+				csr = musb_readw(epio, MUSB_TXCSR);
+
+				if (csr & (MUSB_TXCSR_TXPKTRDY |
+					MUSB_TXCSR_FIFONOTEMPTY)) {
+					resched = 1;
+				} else {
+					tx_ch->channel.status =
+						MUSB_DMA_STATUS_FREE;
+					tx_ch->tx_complete = 0;
+					musb_dma_completion(musb, index+1, 1);
+				}
+			}
+			spin_unlock_irqrestore(&musb->lock, flags);
+
+			if (!resched)
+				cond_resched();
+		}
+
+		if (resched) {
+			resched = 0;
+			cond_resched();
+		} else {
+			return ;
+		}
+	}
+
+}
+
 /**
  * cppi41_dma_controller_create -
  * instantiate an object representing DMA controller.
@@ -1293,6 +1353,7 @@ cppi41_dma_controller_create(struct musb  *musb, void __iomem *mregs)
 	cppi->controller.channel_abort = cppi41_channel_abort;
 	cppi->cppi_info = (struct usb_cppi41_info *)&usb_cppi41_info[musb->id];;
 	cppi->en_bd_intr = cppi->cppi_info->bd_intr_ctrl;
+	INIT_WORK(&cppi->txdma_work, txdma_completion_work);
 
 	/* enable infinite mode only for ti81xx silicon rev2 */
 	if (cpu_is_am33xx() || cpu_is_ti816x()) {
@@ -1364,8 +1425,6 @@ static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index)
 		    (tx_ch->transfer_mode && !tx_ch->zlp_queued))
 			cppi41_next_tx_segment(tx_ch);
 		else if (tx_ch->channel.actual_len >= tx_ch->length) {
-			tx_ch->channel.status = MUSB_DMA_STATUS_FREE;
-
 			/*
 			 * We get Tx DMA completion interrupt even when
 			 * data is still in FIFO and not moved out to
@@ -1374,9 +1433,8 @@ static void usb_process_tx_queue(struct cppi41 *cppi, unsigned index)
 			 * USB functionality. So far, we have obsered
 			 * failure with iperf.
 			 */
-			udelay(20);
-			/* Tx completion routine callback */
-			musb_dma_completion(cppi->musb, ep_num, 1);
+			tx_ch->tx_complete = 1;
+			schedule_work(&cppi->txdma_work);
 		}
 	}
 }
-- 
1.7.5.4

