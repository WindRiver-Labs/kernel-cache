From 458efef3cecc503eddb275561b0ea422237a8fcc Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Tue, 28 Jul 2009 17:35:59 +0530
Subject: [PATCH 366/609] cppi41: fix RGN0 memory alloc in queue_mgr_init()

Original commit: 1d2fe133519f63c7009ddab9daf3775db81e70e2

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

queue_mgr_init() is currently allocating memory only for RGN1 and
expecting RGN0 memory to be allocated in platform files.

Normally RGN0 is only used so updating queue_mgr_init() to allocate
RGN0 memory.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41.c |   28 +++++++++++-----------------
 1 files changed, 11 insertions(+), 17 deletions(-)

diff --git a/drivers/usb/musb/cppi41.c b/drivers/usb/musb/cppi41.c
index eb7ecea..d98d62f 100644
--- a/drivers/usb/musb/cppi41.c
+++ b/drivers/usb/musb/cppi41.c
@@ -70,18 +70,7 @@ int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size)
 		return -EINVAL;
 
 	q_mgr_regs = cppi41_queue_mgr[q_mgr].q_mgr_rgn_base;
-
-	__raw_writel(rgn0_base, q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
-	DBG("Linking RAM region 0 base @ %p, value: %x\n",
-	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG,
-	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG));
-
-	__raw_writel(rgn0_size, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
-	DBG("Linking RAM region 0 size @ %p, value: %x\n",
-	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG,
-	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG));
-
-	ptr = dma_alloc_coherent(NULL, 0x10000 - rgn0_size * 4,
+	ptr = dma_alloc_coherent(NULL, rgn0_size * 4,
 				 &linking_ram[q_mgr].phys_addr,
 				 GFP_KERNEL | GFP_DMA);
 	if (ptr == NULL) {
@@ -92,17 +81,22 @@ int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size)
 	linking_ram[q_mgr].virt_addr = ptr;
 
 	__raw_writel(linking_ram[q_mgr].phys_addr,
-		     q_mgr_regs + QMGR_LINKING_RAM_RGN1_BASE_REG);
-	DBG("Linking RAM region 1 base @ %p, value: %x\n",
-	    q_mgr_regs + QMGR_LINKING_RAM_RGN1_BASE_REG,
-	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN1_BASE_REG));
+			q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
+	DBG("Linking RAM region 0 base @ %p, value: %x\n",
+	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG,
+	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG));
+
+	__raw_writel(rgn0_size, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
+	DBG("Linking RAM region 0 size @ %p, value: %x\n",
+	    q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG,
+	    __raw_readl(q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG));
 
 	ptr = kzalloc(BITS_TO_LONGS(cppi41_queue_mgr[q_mgr].num_queue),
 		      GFP_KERNEL);
 	if (ptr == NULL) {
 		printk(KERN_ERR "ERROR: %s: Unable to allocate queue bitmap.\n",
 		       __func__);
-		dma_free_coherent(NULL, 0x10000 - rgn0_size * 4,
+		dma_free_coherent(NULL, rgn0_size * 4,
 				  linking_ram[q_mgr].virt_addr,
 				  linking_ram[q_mgr].phys_addr);
 		return -ENOMEM;
-- 
1.7.5.4

