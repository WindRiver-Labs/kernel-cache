From d0cb6261a3376495a1034715f75c26d633addadc Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Thu, 30 Aug 2012 14:02:58 +0800
Subject: [PATCH 584/609] usb: nop: support for multi-nop tranceiver

Original commit: e3df8a36661c1d821bf84ef2e75d7300b32b7f36

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Modified the nop driver to support multi nop transceiver.
Changes:
    - Global xceiv to xceiv[2]
    - nop transceiver regiser/deregiser based on musb->id
    - Changes to other glue layers

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/board-omap3evm.c |    2 +-
 drivers/usb/gadget/omap_udc.c        |    2 +-
 drivers/usb/musb/am35x.c             |    6 +++---
 drivers/usb/musb/blackfin.c          |    6 +++---
 drivers/usb/musb/da8xx.c             |    6 +++---
 drivers/usb/musb/davinci.c           |    8 ++++----
 drivers/usb/musb/omap2430.c          |    2 +-
 drivers/usb/musb/ti81xx.c            |    8 ++++----
 drivers/usb/musb/tusb6010.c          |    8 ++++----
 drivers/usb/otg/nop-usb-xceiv.c      |   20 +++++++++++---------
 drivers/usb/otg/otg.c                |   27 ++++++++++++++++++++-------
 include/linux/usb/otg.h              |   14 ++++++++------
 12 files changed, 63 insertions(+), 46 deletions(-)

diff --git a/arch/arm/mach-omap2/board-omap3evm.c b/arch/arm/mach-omap2/board-omap3evm.c
index 84d94c3..d9cacd9 100644
--- a/arch/arm/mach-omap2/board-omap3evm.c
+++ b/arch/arm/mach-omap2/board-omap3evm.c
@@ -724,7 +724,7 @@ static void __init omap3_evm_init(void)
 	omap_sdrc_init(mt46h32m32lf6_sdrc_params, NULL);
 
 	/* OMAP3EVM uses ISP1504 phy and so register nop transceiver */
-	usb_nop_xceiv_register();
+	usb_nop_xceiv_register(0);
 
 	if (get_omap3_evm_rev() >= OMAP3EVM_BOARD_GEN_2) {
 		/* enable EHCI VBUS using GPIO22 */
diff --git a/drivers/usb/gadget/omap_udc.c b/drivers/usb/gadget/omap_udc.c
index e4fe171..afdae26 100644
--- a/drivers/usb/gadget/omap_udc.c
+++ b/drivers/usb/gadget/omap_udc.c
@@ -2867,7 +2867,7 @@ static int __init omap_udc_probe(struct platform_device *pdev)
 		 * use it.  Except for OTG, we don't _need_ to talk to one;
 		 * but not having one probably means no VBUS detection.
 		 */
-		xceiv = usb_get_transceiver();
+		xceiv = usb_get_transceiver(0);
 		if (xceiv)
 			type = xceiv->label;
 		else if (config->otg) {
diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index 8f1f13a..407060e 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -577,8 +577,8 @@ static int am35x_musb_init(struct musb *musb)
 	if (!rev)
 		return -ENODEV;
 
-	usb_nop_xceiv_register();
-	musb->xceiv = usb_get_transceiver();
+	usb_nop_xceiv_register(musb->id);
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv)
 		return -ENODEV;
 
@@ -625,7 +625,7 @@ static int am35x_musb_exit(struct musb *musb)
 		data->set_phy_power(0, 0);
 
 	usb_put_transceiver(musb->xceiv);
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 
 	return 0;
 }
diff --git a/drivers/usb/musb/blackfin.c b/drivers/usb/musb/blackfin.c
index 395b554a..dc7f6ea 100644
--- a/drivers/usb/musb/blackfin.c
+++ b/drivers/usb/musb/blackfin.c
@@ -415,8 +415,8 @@ static int bfin_musb_init(struct musb *musb)
 	}
 	gpio_direction_output(musb->config->gpio_vrsel, 0);
 
-	usb_nop_xceiv_register();
-	musb->xceiv = usb_get_transceiver();
+	usb_nop_xceiv_register(musb->id);
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv) {
 		gpio_free(musb->config->gpio_vrsel);
 		return -ENODEV;
@@ -442,7 +442,7 @@ static int bfin_musb_exit(struct musb *musb)
 	gpio_free(musb->config->gpio_vrsel);
 
 	usb_put_transceiver(musb->xceiv);
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 	return 0;
 }
 
diff --git a/drivers/usb/musb/da8xx.c b/drivers/usb/musb/da8xx.c
index 3b2996c..21e0a45 100644
--- a/drivers/usb/musb/da8xx.c
+++ b/drivers/usb/musb/da8xx.c
@@ -424,8 +424,8 @@ static int da8xx_musb_init(struct musb *musb)
 	if (!rev)
 		goto fail;
 
-	usb_nop_xceiv_register();
-	musb->xceiv = usb_get_transceiver();
+	usb_nop_xceiv_register(musb->id);
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv)
 		goto fail;
 
@@ -459,7 +459,7 @@ static int da8xx_musb_exit(struct musb *musb)
 	phy_off();
 
 	usb_put_transceiver(musb->xceiv);
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 
 	return 0;
 }
diff --git a/drivers/usb/musb/davinci.c b/drivers/usb/musb/davinci.c
index e1f88a3..f556171 100644
--- a/drivers/usb/musb/davinci.c
+++ b/drivers/usb/musb/davinci.c
@@ -384,8 +384,8 @@ static int davinci_musb_init(struct musb *musb)
 	void __iomem	*tibase = musb->ctrl_base;
 	u32		revision;
 
-	usb_nop_xceiv_register();
-	musb->xceiv = usb_get_transceiver();
+	usb_nop_xceiv_register(musb->id);
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv)
 		goto unregister;
 
@@ -446,7 +446,7 @@ static int davinci_musb_init(struct musb *musb)
 fail:
 	usb_put_transceiver(musb->xceiv);
 unregister:
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 	return -ENODEV;
 }
 
@@ -495,7 +495,7 @@ static int davinci_musb_exit(struct musb *musb)
 	phy_off();
 
 	usb_put_transceiver(musb->xceiv);
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 
 	return 0;
 }
diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c
index 44cb3fd..65adafc 100644
--- a/drivers/usb/musb/omap2430.c
+++ b/drivers/usb/musb/omap2430.c
@@ -293,7 +293,7 @@ static int omap2430_musb_init(struct musb *musb)
 	 * up through ULPI.  TWL4030-family PMICs include one,
 	 * which needs a driver, drivers aren't always needed.
 	 */
-	musb->xceiv = usb_get_transceiver();
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv) {
 		pr_err("HS USB OTG: no transceiver configured\n");
 		return -ENODEV;
diff --git a/drivers/usb/musb/ti81xx.c b/drivers/usb/musb/ti81xx.c
index d0e7202..ec9fbe9 100644
--- a/drivers/usb/musb/ti81xx.c
+++ b/drivers/usb/musb/ti81xx.c
@@ -994,13 +994,13 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 					musb->is_active = 1;
 
 				MUSB_HST_MODE(musb);
-				musb->xceiv->default_a = 1;
+				musb->xceiv->otg->default_a = 1;
 				musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
 			}
 		} else {
 			musb->is_active = 0;
 			MUSB_DEV_MODE(musb);
-			musb->xceiv->default_a = 0;
+			musb->xceiv->otg->default_a = 0;
 			musb->xceiv->state = OTG_STATE_B_IDLE;
 		}
 
@@ -1111,7 +1111,7 @@ int ti81xx_musb_init(struct musb *musb)
 
 	usb_nop_xceiv_register(musb->id);
 
-	musb->xceiv = otg_get_transceiver(musb->id);
+	musb->xceiv = usb_get_transceiver(musb->id);
 	if (!musb->xceiv)
 		return -ENODEV;
 
@@ -1221,7 +1221,7 @@ int ti81xx_musb_exit(struct musb *musb)
 	if (data->set_phy_power)
 		data->set_phy_power(musb->id, 0);
 
-	otg_put_transceiver(musb->xceiv);
+	usb_put_transceiver(musb->xceiv);
 	usb_nop_xceiv_unregister(musb->id);
 
 	return 0;
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index f8d27ce..dbbb002 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -1078,8 +1078,8 @@ static int tusb_musb_init(struct musb *musb)
 	void __iomem		*sync = NULL;
 	int			ret;
 
-	usb_nop_xceiv_register();
-	musb->xceiv = usb_get_transceiver();
+	usb_nop_xceiv_register(musb->id);
+	musb->xceiv = otg_get_transceiver(musb->id);
 	if (!musb->xceiv)
 		return -ENODEV;
 
@@ -1132,7 +1132,7 @@ done:
 			iounmap(sync);
 
 		usb_put_transceiver(musb->xceiv);
-		usb_nop_xceiv_unregister();
+		usb_nop_xceiv_unregister(musb->id);
 	}
 	return ret;
 }
@@ -1148,7 +1148,7 @@ static int tusb_musb_exit(struct musb *musb)
 	iounmap(musb->sync_va);
 
 	usb_put_transceiver(musb->xceiv);
-	usb_nop_xceiv_unregister();
+	usb_nop_xceiv_unregister(musb->id);
 	return 0;
 }
 
diff --git a/drivers/usb/otg/nop-usb-xceiv.c b/drivers/usb/otg/nop-usb-xceiv.c
index 58b26df..c4dfa11 100644
--- a/drivers/usb/otg/nop-usb-xceiv.c
+++ b/drivers/usb/otg/nop-usb-xceiv.c
@@ -37,24 +37,24 @@ struct nop_usb_xceiv {
 	struct device		*dev;
 };
 
-static struct platform_device *pd;
+static struct platform_device *pd[2] = {NULL, NULL};
 
-void usb_nop_xceiv_register(void)
+void usb_nop_xceiv_register(int id)
 {
-	if (pd)
+	if (pd[id])
 		return;
-	pd = platform_device_register_simple("nop_usb_xceiv", -1, NULL, 0);
-	if (!pd) {
+	pd[id] = platform_device_register_simple("nop_usb_xceiv", id, NULL, 0);
+	if (!pd[id]) {
 		printk(KERN_ERR "Unable to register usb nop transceiver\n");
 		return;
 	}
 }
 EXPORT_SYMBOL(usb_nop_xceiv_register);
 
-void usb_nop_xceiv_unregister(void)
+void usb_nop_xceiv_unregister(int id)
 {
-	platform_device_unregister(pd);
-	pd = NULL;
+	platform_device_unregister(pd[id]);
+	pd[id] = NULL;
 }
 EXPORT_SYMBOL(usb_nop_xceiv_unregister);
 
@@ -116,6 +116,7 @@ static int __devinit nop_usb_xceiv_probe(struct platform_device *pdev)
 	nop->phy.otg->phy		= &nop->phy;
 	nop->phy.otg->set_host		= nop_set_host;
 	nop->phy.otg->set_peripheral	= nop_set_peripheral;
+	nop->phy.id		= pdev->id;
 
 	err = usb_set_transceiver(&nop->phy);
 	if (err) {
@@ -139,7 +140,8 @@ static int __devexit nop_usb_xceiv_remove(struct platform_device *pdev)
 {
 	struct nop_usb_xceiv *nop = platform_get_drvdata(pdev);
 
-	usb_set_transceiver(NULL);
+	/*TI introduces this multi-id, but it's safe for this operation */
+	otg_reset_transceiver(&nop->phy.otg);
 
 	platform_set_drvdata(pdev, NULL);
 	kfree(nop->phy.otg);
diff --git a/drivers/usb/otg/otg.c b/drivers/usb/otg/otg.c
index 801e597..7ef40c8 100644
--- a/drivers/usb/otg/otg.c
+++ b/drivers/usb/otg/otg.c
@@ -15,7 +15,7 @@
 
 #include <linux/usb/otg.h>
 
-static struct usb_phy *phy;
+static struct usb_phy *phy[2];
 
 /**
  * usb_get_transceiver - find the (single) USB transceiver
@@ -26,11 +26,11 @@ static struct usb_phy *phy;
  *
  * For use by USB host and peripheral drivers.
  */
-struct usb_phy *usb_get_transceiver(void)
+struct usb_phy *usb_get_transceiver(int id)
 {
-	if (phy)
-		get_device(phy->dev);
-	return phy;
+	if (phy[id])
+		get_device(phy[id]->dev);
+	return phy[id];
 }
 EXPORT_SYMBOL(usb_get_transceiver);
 
@@ -59,13 +59,26 @@ EXPORT_SYMBOL(usb_put_transceiver);
  */
 int usb_set_transceiver(struct usb_phy *x)
 {
-	if (phy && x)
+	if ( x && phy[x->id])
 		return -EBUSY;
-	phy = x;
+	phy[x->id] = x;
 	return 0;
 }
 EXPORT_SYMBOL(usb_set_transceiver);
 
+
+/**
+ * otg_reset_transceiver
+ * introduced by TI for muilt-id
+ */
+int otg_reset_transceiver(struct usb_phy *x)
+{
+	if (x && phy[x->id])
+		phy[x->id] = NULL;
+	return 0;
+}
+EXPORT_SYMBOL(otg_reset_transceiver);
+
 const char *otg_state_string(enum usb_otg_state state)
 {
 	switch (state) {
diff --git a/include/linux/usb/otg.h b/include/linux/usb/otg.h
index 38ab3f4..439fad3 100644
--- a/include/linux/usb/otg.h
+++ b/include/linux/usb/otg.h
@@ -88,6 +88,7 @@ struct usb_phy {
 	struct device		*dev;
 	const char		*label;
 	unsigned int		 flags;
+	u8			id;
 
 	enum usb_otg_state	state;
 	enum usb_phy_events	last_event;
@@ -122,17 +123,18 @@ struct usb_phy {
 
 /* for board-specific init logic */
 extern int usb_set_transceiver(struct usb_phy *);
+extern int otg_reset_transceiver(struct usb_phy *);
 
 #if defined(CONFIG_NOP_USB_XCEIV) || (defined(CONFIG_NOP_USB_XCEIV_MODULE) && defined(MODULE))
 /* sometimes transceivers are accessed only through e.g. ULPI */
-extern void usb_nop_xceiv_register(void);
-extern void usb_nop_xceiv_unregister(void);
+extern void usb_nop_xceiv_register(int id);
+extern void usb_nop_xceiv_unregister(int id);
 #else
-static inline void usb_nop_xceiv_register(void)
+static inline void usb_nop_xceiv_register(int id)
 {
 }
 
-static inline void usb_nop_xceiv_unregister(void)
+static inline void usb_nop_xceiv_unregister(int id)
 {
 }
 #endif
@@ -172,11 +174,11 @@ usb_phy_shutdown(struct usb_phy *x)
 
 /* for usb host and peripheral controller drivers */
 #ifdef CONFIG_USB_OTG_UTILS
-extern struct usb_phy *usb_get_transceiver(void);
+extern struct usb_phy *usb_get_transceiver(int id);
 extern void usb_put_transceiver(struct usb_phy *);
 extern const char *otg_state_string(enum usb_otg_state state);
 #else
-static inline struct usb_phy *usb_get_transceiver(void)
+static inline struct usb_phy *usb_get_transceiver(int id)
 {
 	return NULL;
 }
-- 
1.7.5.4

