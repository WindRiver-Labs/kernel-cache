From d6e5a813cabf6bc95b4c9d285203307bca17fa93 Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 11 Jul 2012 17:17:49 +0800
Subject: [PATCH 307/609] ethernet: cpsw: Set SYSC for NO_IDLE and NO_STDBY

Original commit: 22a284d098501bf49aca4e6f824212035cf4d276

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

In a successful suspend-resume cycle the register context is
lost and hence SYSC will go back to its default value of
NO_IDLE and NO_STDBY. However, in a suspend failure/abort due
to some or the other reason, the register is set to
FORCE_IDLE and FORCE_STDBY but never cleared.

If the driver had been fully converted to HWMOD this would have
been taken care of in the generic code. For now, after enabling the
CPSW clock explicitly set the SYSC of CPSW to NO_IDLE and NO_STDBY.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c          |   36 +++++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/cpsw_ale.c      |    3 ++
 drivers/net/ethernet/ti/cpsw_ale.h      |    6 +++++
 drivers/net/ethernet/ti/davinci_cpdma.c |   12 ++++++++++
 drivers/net/ethernet/ti/davinci_mdio.c  |   34 +++++++++++++++++++++++++++++
 5 files changed, 91 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 9cc1284..9245492 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -144,6 +144,7 @@ struct cpsw_regs {
 	u32	soft_reset;
 	u32	stat_port_en;
 	u32	ptype;
+	u32	soft_idle;
 };
 
 struct cpsw_slave_regs {
@@ -732,6 +733,10 @@ static int cpsw_ndo_stop(struct net_device *ndev)
 	cpsw_info(priv, ifdown, "shutting down cpsw device\n");
 	cpsw_intr_disable(priv);
 	cpdma_ctlr_int_ctrl(priv->dma, false);
+
+	omap_dm_timer_set_int_enable(dmtimer_rx, 0);
+	omap_dm_timer_set_int_enable(dmtimer_tx, 0);
+
 	netif_stop_queue(priv->ndev);
 	napi_disable(&priv->napi);
 	netif_carrier_off(priv->ndev);
@@ -793,6 +798,26 @@ static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
 		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
 }
 
+static int cpsw_ndo_set_mac_address(struct net_device *ndev, void *p)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct sockaddr *addr = (struct sockaddr *)p;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	cpsw_ale_del_ucast(priv->ale, priv->mac_addr, priv->host_port);
+
+	memcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);
+	memcpy(ndev->dev_addr, priv->mac_addr, ETH_ALEN);
+
+	cpsw_ale_add_ucast(priv->ale, priv->mac_addr, priv->host_port,
+			   0);
+	/* ALE_SECURE); */
+	for_each_slave(priv, cpsw_set_slave_mac, priv);
+	return 0;
+}
+
 static void cpsw_ndo_tx_timeout(struct net_device *ndev)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
@@ -833,6 +858,7 @@ static const struct net_device_ops cpsw_netdev_ops = {
 	.ndo_stop		= cpsw_ndo_stop,
 	.ndo_start_xmit		= cpsw_ndo_start_xmit,
 	.ndo_change_rx_flags	= cpsw_ndo_change_rx_flags,
+	.ndo_set_mac_address	= cpsw_ndo_set_mac_address,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_tx_timeout		= cpsw_ndo_tx_timeout,
@@ -1118,6 +1144,9 @@ static int __devexit cpsw_remove(struct platform_device *pdev)
 	pr_info("removing device");
 	platform_set_drvdata(pdev, NULL);
 
+	omap_dm_timer_free(dmtimer_rx);
+	omap_dm_timer_free(dmtimer_tx);
+
 	free_irq(ndev->irq, priv);
 	cpsw_ale_destroy(priv->ale);
 	cpdma_chan_destroy(priv->txch);
@@ -1139,9 +1168,16 @@ static int cpsw_suspend(struct device *dev)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct net_device	*ndev = platform_get_drvdata(pdev);
+	struct cpsw_priv *priv = netdev_priv(ndev);
 
 	if (netif_running(ndev))
 		cpsw_ndo_stop(ndev);
+
+	soft_reset("cpsw", &priv->regs->soft_reset);
+	soft_reset("sliver 0", &priv->slaves[0].sliver->soft_reset);
+	soft_reset("sliver 1", &priv->slaves[1].sliver->soft_reset);
+	soft_reset("cpsw_ss", &priv->ss_regs->soft_reset);
+
 	return 0;
 }
 
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index 6a81966..286a2dc 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -622,7 +622,10 @@ EXPORT_SYMBOL_GPL(cpsw_ale_start);
 
 void cpsw_ale_stop(struct cpsw_ale *ale)
 {
+	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 0);
 	del_timer_sync(&ale->timer);
+	device_remove_file(ale->params.dev, &ale->ale_table_attr);
+	device_remove_file(ale->params.dev, &ale->ale_control_attr);
 }
 EXPORT_SYMBOL_GPL(cpsw_ale_stop);
 
diff --git a/drivers/net/ethernet/ti/cpsw_ale.h b/drivers/net/ethernet/ti/cpsw_ale.h
index a95b37b..f4bd214 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.h
+++ b/drivers/net/ethernet/ti/cpsw_ale.h
@@ -27,6 +27,12 @@ struct cpsw_ale {
 	struct cpsw_ale_params	params;
 	struct timer_list	timer;
 	unsigned long		ageout;
+	struct device_attribute ale_control_attr;
+#define control_attr_to_ale(attr)       \
+	container_of(attr, struct cpsw_ale, ale_control_attr);
+	struct device_attribute ale_table_attr;
+#define table_attr_to_ale(attr)         \
+	container_of(attr, struct cpsw_ale, ale_table_attr);
 };
 
 enum cpsw_ale_control {
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 93d12f9..73ec747 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -351,7 +351,19 @@ int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr)
 
 	ctlr->state = CPDMA_STATE_IDLE;
 
+	if (ctlr->params.has_soft_reset) {
+		unsigned long timeout = jiffies + HZ/10;
+
+		dma_reg_write(ctlr, CPDMA_SOFTRESET, 1);
+		while (time_before(jiffies, timeout)) {
+			if (dma_reg_read(ctlr, CPDMA_SOFTRESET) == 0)
+				break;
+		}
+		WARN_ON(!time_before(jiffies, timeout));
+	}
+
 	spin_unlock_irqrestore(&ctlr->lock, flags);
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(cpdma_ctlr_stop);
diff --git a/drivers/net/ethernet/ti/davinci_mdio.c b/drivers/net/ethernet/ti/davinci_mdio.c
index e4e4708..d3bad97 100644
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@ -48,6 +48,10 @@
 
 #define DEF_OUT_FREQ		2200000		/* 2.2 MHz */
 
+#define CPGMAC_CLK_CTRL_REG	0x44E00014
+#define CPGMAC_CLK_SYSC         0x4A101208
+#define CPSW_NO_IDLE_NO_STDBY   0xA
+
 struct davinci_mdio_regs {
 	u32	version;
 	u32	control;
@@ -430,6 +434,33 @@ static int davinci_mdio_suspend(struct device *dev)
 	return 0;
 }
 
+static inline int wait_for_clock_enable(struct davinci_mdio_data *data)
+{
+	unsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);
+	u32 __iomem *cpgmac_clk = ioremap(CPGMAC_CLK_CTRL_REG, 4);
+	u32 __iomem *cpgmac_sysc = ioremap(CPGMAC_CLK_SYSC, 4);
+	u32 reg = 0;
+
+	while (time_after(timeout, jiffies)) {
+		reg = readl(cpgmac_clk);
+		if ((reg & 0x30000) == 0) {
+			writel(CPSW_NO_IDLE_NO_STDBY, cpgmac_sysc);
+			goto iounmap_ret;
+                }
+	}
+	dev_err(data->dev,
+		"timed out waiting for CPGMAC clock enable, value = 0x%x\n",
+		reg);
+	iounmap(cpgmac_sysc);
+	iounmap(cpgmac_clk);
+	return -ETIMEDOUT;
+
+iounmap_ret:
+	iounmap(cpgmac_sysc);
+	iounmap(cpgmac_clk);
+	return 0;
+}
+
 static int davinci_mdio_resume(struct device *dev)
 {
 	struct davinci_mdio_data *data = dev_get_drvdata(dev);
@@ -439,6 +470,9 @@ static int davinci_mdio_resume(struct device *dev)
 	if (data->clk)
 		clk_enable(data->clk);
 
+	/* Need to wait till Module is enabled */
+	wait_for_clock_enable(data);
+
 	/* restart the scan state machine */
 	ctrl = __raw_readl(&data->regs->control);
 	ctrl |= CONTROL_ENABLE;
-- 
1.7.5.4

