From e8b003af39ab31ba97d43d02066971009064f0a5 Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Mon, 28 May 2012 14:39:05 +0530
Subject: [PATCH 241/609] ARM: OMAP2+: AM33XX: PM: Update the PER domain
 context loss counters when appropriate

Original commit: 73baadbeb8ca4b53e65ce508e8c29dc0a6936ee8

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

In the current OMAP PM framework, device drivers depend on the
powerdomain context loss counters to save and restore the required
register context. In OMAP3 the counters associated with the context
loss are updated based on the LASTPOWERSTATEENTERED field and
PM_PREPWRSTST_<XYZ> registers. In OMAP4, the PRCM was updated
to provide context loss indication at a module level and this
has been handled appropriately.

AM335x devices neither have the PM_PREPWRSTST_<> registers nor do
they have module level context loss indicators. To woraround this
limitation, the context loss counters need to be updated in custom
code based on the knowledge of successful transition to a low power
state wherein the register context is lost. The current workaround
checks whether the peripheral powerdomain (PD_PER) successfully
transitioned to a state which leads to register context being lost
and updates the context loss counters appropriately.

While here, also replace the printks in the file with the appropriate
pr_*() versions.

Note: Due to the non-standard approach for updating the context loss
counters, this approach will most likely have to be revisited. Since
the powerdomain code has changed considerably in the mainline code,
reworking the current patch is being avoided for now.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/pm33xx.c |   27 ++++++++++++++-------------
 1 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index cba5d8d..d432dfd 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -60,14 +60,13 @@ static suspend_state_t suspend_state = PM_SUSPEND_ON;
 
 static struct device *mpu_dev;
 static struct omap_mbox *m3_mbox;
-static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm;
+static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm, *per_pwrdm;
 static struct clockdomain *gfx_l3_clkdm, *gfx_l4ls_clkdm;
 
-static int core_suspend_stat = -1;
 static int m3_state = M3_STATE_UNKNOWN;
 
 static int am33xx_ipc_cmd(struct a8_wkup_m3_ipc_data *);
-static int am33xx_verify_lp_state(void);
+static int am33xx_verify_lp_state(int);
 static void am33xx_m3_state_machine_reset(void);
 
 static DECLARE_COMPLETION(a8_m3_sync);
@@ -159,7 +158,7 @@ static int am33xx_pm_suspend(void)
 		clkdm_wakeup(gfx_l4ls_clkdm);
 	}
 
-	core_suspend_stat = ret;
+	ret = am33xx_verify_lp_state(ret);
 
 	return ret;
 }
@@ -250,12 +249,8 @@ static void am33xx_m3_state_machine_reset(void)
 
 static void am33xx_pm_end(void)
 {
-	int ret;
-
 	suspend_state = PM_SUSPEND_ON;
 
-	ret = am33xx_verify_lp_state();
-
 	omap_mbox_enable_irq(m3_mbox, IRQ_RX);
 
 	am33xx_m3_state_machine_reset();
@@ -285,7 +280,7 @@ int am33xx_ipc_cmd(struct a8_wkup_m3_ipc_data *data)
 }
 
 /* return 0 if no reset M3 needed, 1 otherwise */
-static int am33xx_verify_lp_state(void)
+static int am33xx_verify_lp_state(int core_suspend_stat)
 {
 	int status, ret = 0;
 
@@ -300,6 +295,8 @@ static int am33xx_verify_lp_state(void)
 
 	if (status == 0x0) {
 		pr_info("Successfully transitioned all domains to low power state\n");
+		if (am33xx_lp_ipc.sleep_mode == DS0_ID)
+			per_pwrdm->ret_logic_off_counter++;
 		goto clear_old_status;
 	} else if (status == 0x10000) {
 		pr_err("Could not enter low power state\n"
@@ -504,21 +501,25 @@ static int __init am33xx_pm_init(void)
 	/* CEFUSE domain should be turned off post bootup */
 	cefuse_pwrdm = pwrdm_lookup("cefuse_pwrdm");
 	if (cefuse_pwrdm == NULL)
-		printk(KERN_ERR "Failed to get cefuse_pwrdm\n");
+		pr_err("Failed to get cefuse_pwrdm\n");
 	else
 		pwrdm_set_next_pwrst(cefuse_pwrdm, PWRDM_POWER_OFF);
 
 	gfx_pwrdm = pwrdm_lookup("gfx_pwrdm");
 	if (gfx_pwrdm == NULL)
-		printk(KERN_ERR "Failed to get gfx_pwrdm\n");
+		pr_err("Failed to get gfx_pwrdm\n");
+
+	per_pwrdm = pwrdm_lookup("per_pwrdm");
+	if (per_pwrdm == NULL)
+		pr_err("Failed to get per_pwrdm\n");
 
 	gfx_l3_clkdm = clkdm_lookup("gfx_l3_clkdm");
 	if (gfx_l3_clkdm == NULL)
-		printk(KERN_ERR "Failed to get gfx_l3_clkdm\n");
+		pr_err("Failed to get gfx_l3_clkdm\n");
 
 	gfx_l4ls_clkdm = clkdm_lookup("gfx_l4ls_gfx_clkdm");
 	if (gfx_l4ls_clkdm == NULL)
-		printk(KERN_ERR "Failed to get gfx_l4ls_gfx_clkdm\n");
+		pr_err("Failed to get gfx_l4ls_gfx_clkdm\n");
 
 	mpu_dev = omap_device_get_by_hwmod_name("mpu");
 
-- 
1.7.5.4

