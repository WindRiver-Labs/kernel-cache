From eb20de62816b0634ecd35049f18eadb522485c18 Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Mon, 22 Nov 2010 17:52:38 +0530
Subject: [PATCH 379/609] cppi41: teardown fix from Ravi

Original commit: a5eb5f12d82c4edcc0229ad4877bac5fa79f3af1

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41.c     |   14 ++++++++++-
 drivers/usb/musb/cppi41.h     |    5 ++++
 drivers/usb/musb/cppi41_dma.c |   47 ++++++++++++++++++++++++++++++++++-------
 3 files changed, 56 insertions(+), 10 deletions(-)

diff --git a/drivers/usb/musb/cppi41.c b/drivers/usb/musb/cppi41.c
index 7499743..78d2bb8 100644
--- a/drivers/usb/musb/cppi41.c
+++ b/drivers/usb/musb/cppi41.c
@@ -131,7 +131,7 @@ int cppi41_dma_sched_tbl_init(u8 dma_num, u8 q_mgr,
 	struct cppi41_dma_block *dma_block;
 	int num_reg, k, i, val = 0;
 
-	dma_block = &cppi41_dma_block[dma_num];
+	dma_block = (struct cppi41_dma_block *)&cppi41_dma_block[dma_num];
 
 	num_reg = (tbl_size + 3) / 4;
 	for (k = i = 0; i < num_reg; i++) {
@@ -149,7 +149,7 @@ int cppi41_dma_sched_tbl_init(u8 dma_num, u8 q_mgr,
 		dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
 			val);
 	}
-
+	return 0;
 }
 EXPORT_SYMBOL(cppi41_dma_sched_tbl_init);
 
@@ -685,6 +685,16 @@ void cppi41_dma_ch_disable(struct cppi41_dma_ch_obj *dma_ch_obj)
 }
 EXPORT_SYMBOL(cppi41_dma_ch_disable);
 
+void cppi41_free_teardown_queue(int dma_num)
+{
+	unsigned long td_addr;
+
+	while ((td_addr =
+		cppi41_queue_pop(&dma_teardown[dma_num].queue_obj)) != 0)
+		DBG("pop tdDesc(%p) from tdQueue\n", td_addr);
+}
+EXPORT_SYMBOL(cppi41_free_teardown_queue);
+
 void cppi41_exit(void)
 {
 	int i;
diff --git a/drivers/usb/musb/cppi41.h b/drivers/usb/musb/cppi41.h
index c19d49b..1e539b2 100644
--- a/drivers/usb/musb/cppi41.h
+++ b/drivers/usb/musb/cppi41.h
@@ -746,3 +746,8 @@ int cppi41_schedtbl_add_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx);
  * returns      number of channel in schedular table
  */
 int cppi41_schedtbl_remove_dma_ch(u8 dmanum, u8 qmgr, u8 dma_ch, u8 is_tx);
+
+/**
+ * cppi41_free_teardown_queue
+ */
+void cppi41_free_teardown_queue(int dma_num);
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 0f0b268..e7f7597 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -313,6 +313,11 @@ static int cppi41_controller_stop(struct dma_controller *controller)
 
 	cppi = container_of(controller, struct cppi41, controller);
 
+	/*
+	 * pop all the teardwon descriptor queued to tdQueue
+	 */
+	cppi41_free_teardown_queue(0);
+
 	/* Free the teardown completion queue */
 	if (cppi41_queue_free(usb_cppi41_info.q_mgr, cppi->teardownQNum))
 		DBG(1, "ERROR: failed to free teardown completion queue\n");
@@ -898,20 +903,38 @@ static int usb_check_teardown(struct cppi41_channel *cppi_ch,
 static void usb_tx_ch_teardown(struct cppi41_channel *tx_ch)
 {
 	struct cppi41 *cppi = tx_ch->channel.private_data;
+	struct musb *musb = cppi->musb;
+	void __iomem *reg_base = musb->ctrl_base;
+	u32 td_reg, timeout = 0xfffff;
+	u8 ep_num = tx_ch->ch_num + 1;
 	unsigned long pd_addr;
 
 	/* Initiate teardown for Tx DMA channel */
 	cppi41_dma_ch_teardown(&tx_ch->dma_ch_obj);
 
+	/* Wait for a descriptor to be queued and pop it... */
 	do {
-		/* Wait for a descriptor to be queued and pop it... */
-		do {
-			pd_addr = cppi41_queue_pop(&cppi->queue_obj);
-		} while (!pd_addr);
+		td_reg  = musb_readl(reg_base, USB_TEARDOWN_REG);
+		td_reg |= USB_TX_TDOWN_MASK(ep_num);
+		musb_writel(reg_base, USB_TEARDOWN_REG, td_reg);
+
+		pd_addr = cppi41_queue_pop(&cppi->queue_obj);
+	} while (!pd_addr && timeout--);
+
+	if (pd_addr) {
 
 		dprintk("Descriptor (%08lx) popped from teardown completion "
 			"queue\n", pd_addr);
-	} while (!usb_check_teardown(tx_ch, pd_addr));
+
+		if (usb_check_teardown(tx_ch, pd_addr)) {
+			dprintk("Teardown Desc (%p) rcvd\n", pd_addr);
+		} else
+			ERR("Invalid PD(%08lx)popped from TearDn completion"
+				"queue\n", pd_addr);
+	} else {
+		if (timeout <= 0)
+			ERR("Teardown Desc not rcvd\n");
+	}
 }
 
 /*
@@ -923,20 +946,26 @@ static void usb_tx_ch_teardown(struct cppi41_channel *tx_ch)
 static void usb_rx_ch_teardown(struct cppi41_channel *rx_ch)
 {
 	struct cppi41 *cppi = rx_ch->channel.private_data;
+	u32 timeout = 0xfffff;
 
 	cppi41_dma_ch_default_queue(&rx_ch->dma_ch_obj, 0, cppi->teardownQNum);
 
 	/* Initiate teardown for Rx DMA channel */
 	cppi41_dma_ch_teardown(&rx_ch->dma_ch_obj);
 
-	while (1) {
+	do {
 		struct usb_pkt_desc *curr_pd;
 		unsigned long pd_addr;
 
 		/* Wait for a descriptor to be queued and pop it... */
 		do {
 			pd_addr = cppi41_queue_pop(&cppi->queue_obj);
-		} while (!pd_addr);
+		} while (!pd_addr && timeout--);
+
+		if (timeout <= 0) {
+			ERR("teardown Desc not found\n");
+			break;
+		}
 
 		dprintk("Descriptor (%08lx) popped from teardown completion "
 			"queue\n", pd_addr);
@@ -968,7 +997,7 @@ static void usb_rx_ch_teardown(struct cppi41_channel *rx_ch)
 		 * this is protected by critical section.
 		 */
 		usb_put_free_pd(cppi, curr_pd);
-	}
+	} while (0);
 
 	/* Now restore the default Rx completion queue... */
 	cppi41_dma_ch_default_queue(&rx_ch->dma_ch_obj, usb_cppi41_info.q_mgr,
@@ -1036,6 +1065,7 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 		csr  = musb_readw(epio, MUSB_TXCSR);
 		csr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_H_WZC_BITS;
 		musb_writew(epio, MUSB_TXCSR, csr);
+		musb_writew(epio, MUSB_TXCSR, csr);
 	} else { /* Rx */
 		dprintk("Rx channel teardown, cppi_ch = %p\n", cppi_ch);
 
@@ -1043,6 +1073,7 @@ static int cppi41_channel_abort(struct dma_channel *channel)
 		csr  = musb_readw(epio, MUSB_RXCSR);
 		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_H_WZC_BITS;
 		musb_writew(epio, MUSB_RXCSR, csr);
+		musb_writew(epio, MUSB_RXCSR, csr);
 
 		/* Issue CPPI FIFO teardown for Rx channel */
 		td_reg  = musb_readl(reg_base, USB_TEARDOWN_REG);
-- 
1.7.5.4

