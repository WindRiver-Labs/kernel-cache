From 13af0ed4f90f72fd6c5140904db317b063f11d8a Mon Sep 17 00:00:00 2001
From: AnilKumar Ch <anilkumar@ti.com>
Date: Fri, 16 Mar 2012 17:38:27 +0530
Subject: [PATCH 504/609] net can: d_can: fix the rx problem

Original commit: b8ecb7b5d17a684cc58c863013eab917f3b503bf

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch fixes the d_can receiver problem after suspend/resume cycle.

Details:
After resuming from deepsleep Zero DCAN receiver is not exporting
packets to userspace. This issue mainly because of RAMINIT sequence
is not correct in suspend resume cycle.

This patch replace the tristate open_status flag with two state opened
flag, which is required with the current implementation. Here we end up
with two states one is DCAN is opened or not. If it is opened then we
have to do d_can_stop() and d_can_start() otherwise not required. If
this flag is not there then some unknow bittimming value is programed
to DCAN BTR register which is not expected.

This patch also moves the runtime PM calls from open/close APIs to
DCAN suspend/resume APIs, required along with DCAN RAMINIT and DEINIT

Signed-off-by: AnilKumar Ch <anilkumar@ti.com>
---
 drivers/net/can/d_can/d_can.c          |   84 ++++++++++++--------------------
 drivers/net/can/d_can/d_can.h          |   10 +---
 drivers/net/can/d_can/d_can_platform.c |   32 ++++++++++--
 3 files changed, 61 insertions(+), 65 deletions(-)

diff --git a/drivers/net/can/d_can/d_can.c b/drivers/net/can/d_can/d_can.c
index 262bc44..18a9e10 100644
--- a/drivers/net/can/d_can/d_can.c
+++ b/drivers/net/can/d_can/d_can.c
@@ -38,7 +38,6 @@
 #include <linux/io.h>
 
 #include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
 #include <linux/can.h>
 #include <linux/can/dev.h>
 #include <linux/can/error.h>
@@ -257,7 +256,7 @@
 #define MIN_TIMEOUT_VALUE		6
 
 /* Wait for ~1 sec for INIT bit */
-#define D_CAN_WAIT_COUNT		100
+#define D_CAN_WAIT_COUNT		1000
 
 #define D_CAN_IF_RX_NUM			0
 #define D_CAN_IF_TX_NUM			1
@@ -1234,21 +1233,11 @@ static int d_can_open(struct net_device *ndev)
 	int err;
 	struct d_can_priv *priv = netdev_priv(ndev);
 
-	if (priv->open_status == D_CAN_OPENED)
-		return 0;
-
-	/* If enabled, tell runtime PM not to power off */
-	if (pm_runtime_enabled(&priv->pdev->dev)) {
-		err = pm_runtime_get_sync(&priv->pdev->dev);
-		if (err < 0)
-			return err;
-	}
-
 	/* Open common can device */
 	err = open_candev(ndev);
 	if (err) {
 		netdev_err(ndev, "open_candev() failed %d\n", err);
-		goto exit_put_sync;
+		return err;
 	}
 
 	/* register interrupt handler for Message Object (MO)
@@ -1274,42 +1263,28 @@ static int d_can_open(struct net_device *ndev)
 	napi_enable(&priv->napi);
 	netif_start_queue(ndev);
 
-	priv->open_status = D_CAN_OPENED;
+	priv->opened = true;
 	return 0;
 exit_free_irq:
 	free_irq(ndev->irq, ndev);
 exit_close_candev:
 	close_candev(ndev);
-exit_put_sync:
-	if (pm_runtime_enabled(&priv->pdev->dev))
-		pm_runtime_put_sync(&priv->pdev->dev);
 
 	return err;
 }
 
 static int d_can_close(struct net_device *ndev)
 {
-	int ret;
 	struct d_can_priv *priv = netdev_priv(ndev);
 
-	if (priv->open_status == D_CAN_CLOSED)
-		return 0;
-
 	netif_stop_queue(ndev);
 	napi_disable(&priv->napi);
 	d_can_stop(ndev);
 	free_irq(ndev->irq, ndev);
 	free_irq(priv->irq_obj, ndev);
 	close_candev(ndev);
+	priv->opened = false;
 
-	/* If enabled, let runtime PM know the d_can is closed */
-	if (pm_runtime_enabled(&priv->pdev->dev)) {
-		ret = pm_runtime_put_sync(&priv->pdev->dev);
-		if (ret < 0)
-			return ret;
-	}
-
-	priv->open_status = D_CAN_CLOSED;
 	return 0;
 }
 
@@ -1350,45 +1325,50 @@ struct net_device *alloc_d_can_dev(int num_objs)
 EXPORT_SYMBOL_GPL(alloc_d_can_dev);
 
 #ifdef CONFIG_PM
-void d_can_power_down(struct d_can_priv *d_can)
+int d_can_power_down(struct d_can_priv *d_can)
 {
-	unsigned int cnt;
+	unsigned long time_out;
 	struct net_device *ndev = platform_get_drvdata(d_can->pdev);
 
 	d_can_set_bit(d_can, D_CAN_CTL, D_CAN_CTL_PDR);
 
-	/* Wait for the Init bit to get set */
-	cnt = D_CAN_WAIT_COUNT;
-	while (!d_can_get_bit(d_can, D_CAN_CTL, D_CAN_CTL_INIT) && cnt != 0) {
-		--cnt;
-		udelay(10);
-	}
+	/* Wait for the PDA bit to get set */
+	time_out = jiffies + msecs_to_jiffies(D_CAN_WAIT_COUNT);
+	while (!d_can_get_bit(d_can, D_CAN_ES, D_CAN_ES_PDA) &&
+				time_after(time_out, jiffies))
+		cpu_relax();
 
-	if ((d_can->open_status != D_CAN_INITED) &&
-			(d_can->open_status == D_CAN_OPENED))
-		d_can_close(ndev);
+	if (time_after(jiffies, time_out))
+		return -ETIMEDOUT;
 
+	if (d_can->opened)
+		d_can_stop(ndev);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(d_can_power_down);
 
-void d_can_power_up(struct d_can_priv *d_can)
+int d_can_power_up(struct d_can_priv *d_can)
 {
-	unsigned int cnt;
+	unsigned long time_out;
 	struct net_device *ndev = platform_get_drvdata(d_can->pdev);
 
-	if ((d_can->open_status != D_CAN_INITED) &&
-			(d_can->open_status == D_CAN_CLOSED))
-		d_can_open(ndev);
-
 	d_can_clear_bit(d_can, D_CAN_CTL, D_CAN_CTL_PDR);
 	d_can_clear_bit(d_can, D_CAN_CTL, D_CAN_CTL_INIT);
 
-	/* Wait for the Init bit to get clear */
-	cnt = D_CAN_WAIT_COUNT;
-	while (d_can_get_bit(d_can, D_CAN_CTL, D_CAN_CTL_INIT) && cnt != 0) {
-		--cnt;
-		udelay(10);
-	}
+	/* Wait for the PDA bit to get clear */
+	time_out = jiffies + msecs_to_jiffies(D_CAN_WAIT_COUNT);
+	while (d_can_get_bit(d_can, D_CAN_ES, D_CAN_ES_PDA) &&
+				time_after(time_out, jiffies))
+		cpu_relax();
+
+	if (time_after(jiffies, time_out))
+		return -ETIMEDOUT;
+
+	if (d_can->opened)
+		d_can_start(ndev);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(d_can_power_up);
 #else
diff --git a/drivers/net/can/d_can/d_can.h b/drivers/net/can/d_can/d_can.h
index c64f712..5013421 100644
--- a/drivers/net/can/d_can/d_can.h
+++ b/drivers/net/can/d_can/d_can.h
@@ -35,10 +35,6 @@
 #define D_CAN_DRV_DESC	"CAN bus driver for Bosch D_CAN controller " \
 			D_CAN_VERSION
 
-#define D_CAN_CLOSED		0 /* Module in power down mode or disabled */
-#define D_CAN_OPENED		1 /* Module in active mode */
-#define D_CAN_INITED		2 /* Module is inited but not opened */
-
 /* d_can private data structure */
 struct d_can_priv {
 	struct can_priv can;	/* must be the first member */
@@ -59,15 +55,15 @@ struct d_can_priv {
 	unsigned int tx_next;
 	unsigned int tx_echo;
 	unsigned int rx_next;
-	unsigned int open_status;
+	bool opened;
 	void *priv;		/* for board-specific data */
 	void (*ram_init) (unsigned int, unsigned int);
 };
 
 struct net_device *alloc_d_can_dev(int);
 void free_d_can_dev(struct net_device *dev);
-void d_can_power_up(struct d_can_priv *d_can);
-void d_can_power_down(struct d_can_priv *d_can);
+int d_can_power_up(struct d_can_priv *d_can);
+int d_can_power_down(struct d_can_priv *d_can);
 int register_d_can_dev(struct net_device *dev);
 void unregister_d_can_dev(struct net_device *dev);
 void d_can_reset_ram(struct d_can_priv *d_can, unsigned int instance,
diff --git a/drivers/net/can/d_can/d_can_platform.c b/drivers/net/can/d_can/d_can_platform.c
index ace9bd8..7b8a62c 100644
--- a/drivers/net/can/d_can/d_can_platform.c
+++ b/drivers/net/can/d_can/d_can_platform.c
@@ -134,7 +134,7 @@ static int __devinit d_can_plat_probe(struct platform_device *pdev)
 	priv->base = addr;
 	priv->can.clock.freq = clk_get_rate(fck);
 	priv->ram_init = pdata->ram_init;
-	priv->open_status = D_CAN_INITED;
+	priv->opened = false;
 
 	platform_set_drvdata(pdev, ndev);
 	SET_NETDEV_DEV(ndev, &pdev->dev);
@@ -198,33 +198,53 @@ static int __devexit d_can_plat_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int d_can_suspend(struct platform_device *pdev, pm_message_t state)
 {
+	int ret;
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct d_can_priv *priv = netdev_priv(ndev);
 
-	/* De-initialize DCAN RAM */
-	d_can_reset_ram(priv, pdev->id, 0);
-
 	if (netif_running(ndev)) {
 		netif_stop_queue(ndev);
 		netif_device_detach(ndev);
 	}
 
-	d_can_power_down(priv);
+	ret = d_can_power_down(priv);
+	if (ret) {
+		dev_err(&pdev->dev, "Not entered power down mode\n");
+		return ret;
+	}
+
 	priv->can.state = CAN_STATE_SLEEPING;
+
+	/* De-initialize DCAN RAM */
+	d_can_reset_ram(priv, pdev->id, 0);
+
+	/* Disable the module */
+	pm_runtime_put_sync(&pdev->dev);
+
 	return 0;
 }
 
 static int d_can_resume(struct platform_device *pdev)
 {
+	int ret;
+
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct d_can_priv *priv = netdev_priv(ndev);
 
-	d_can_power_up(priv);
+	/* Enable the module */
+	pm_runtime_get_sync(&pdev->dev);
 
 	/* Initialize DCAN RAM */
 	d_can_reset_ram(priv, pdev->id, 1);
 
+	ret = d_can_power_up(priv);
+	if (ret) {
+		dev_err(&pdev->dev, "Not came out from power down mode\n");
+		return ret;
+	}
+
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
 	if (netif_running(ndev)) {
 		netif_device_attach(ndev);
 		netif_start_queue(ndev);
-- 
1.7.5.4

