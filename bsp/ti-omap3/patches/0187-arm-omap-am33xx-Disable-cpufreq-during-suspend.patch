From 3435083f0d4b4989548168230d1e2cb539ab3b5f Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Sun, 1 Jul 2012 01:06:48 +0800
Subject: [PATCH 187/609] arm: omap: am33xx: Disable cpufreq during suspend

Original commit: 3491cfa6f7f4ae06efaa8e3bc3b5d9063bf4b56c

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

On AM335x, we need to reconfigure the PLLs and voltage
during suspend. With regulator calls in the suspend code
errors were reported by the cpufreq driver in the resume
path. This is probably because cpufreq is suspended
very late in the overall suspend process.

For now, we make use of SUSPEND_PREPARE notification
to block any further OPP changes from the driver.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/pm33xx.c   |    1 +
 drivers/cpufreq/omap-cpufreq.c |   26 ++++++++++++++++++++++++++
 2 files changed, 27 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 1649b5f..ee56a0f 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -24,6 +24,7 @@
 #include <linux/sched.h>
 #include <linux/suspend.h>
 #include <linux/completion.h>
+#include <linux/regulator/consumer.h>
 
 #include <plat/prcm.h>
 #include <plat/mailbox.h>
diff --git a/drivers/cpufreq/omap-cpufreq.c b/drivers/cpufreq/omap-cpufreq.c
index 17fa04d..6d04f31 100644
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@ -26,6 +26,7 @@
 #include <linux/cpu.h>
 #include <linux/module.h>
 #include <linux/regulator/consumer.h>
+#include <linux/suspend.h>
 
 #include <asm/smp_plat.h>
 #include <asm/cpu.h>
@@ -56,6 +57,8 @@ static struct clk *mpu_clk;
 static char *mpu_clk_name;
 static struct device *mpu_dev;
 static struct regulator *mpu_reg;
+static DEFINE_MUTEX(omap_cpu_lock);
+static bool is_suspended;
 
 static int omap_verify_speed(struct cpufreq_policy *policy)
 {
@@ -85,6 +88,9 @@ static int omap_target(struct cpufreq_policy *policy,
 	struct opp *opp;
 	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
 
+	if (is_suspended)
+		return -EBUSY;
+
 	if (!freq_table) {
 		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
 				policy->cpu);
@@ -203,6 +209,24 @@ static inline void freq_table_free(void)
 		opp_free_cpufreq_table(mpu_dev, &freq_table);
 }
 
+static int omap_pm_notify(struct notifier_block *nb, unsigned long event,
+	void *dummy)
+{
+	mutex_lock(&omap_cpu_lock);
+	if (event == PM_SUSPEND_PREPARE) {
+		is_suspended = true;
+	} else if (event == PM_POST_SUSPEND) {
+		is_suspended = false;
+	}
+	mutex_unlock(&omap_cpu_lock);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block omap_cpu_pm_notifier = {
+	.notifier_call = omap_pm_notify,
+};
+
 static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 {
 	int result = 0;
@@ -252,6 +276,8 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	/* FIXME: what's the actual transition time? */
 	policy->cpuinfo.transition_latency = 300 * 1000;
 
+	register_pm_notifier(&omap_cpu_pm_notifier);
+
 	return 0;
 
 fail_table:
-- 
1.7.5.4

