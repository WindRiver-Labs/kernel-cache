From 5669a3c36622808e55e30a629370b233ec064852 Mon Sep 17 00:00:00 2001
From: Natarajan Sugumar <sugumar@ti.com>
Date: Wed, 2 Mar 2011 13:54:50 +0530
Subject: [PATCH 537/609] PWM: Add helper APIs and sysfs entries to the PWM
 Frame Work

Original commit: e064fb1d2f392b1109aaca224b3fe0d65a55c5f8

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

1. Add pwm_duty_percent and pwm_frequency attributes to the SYSFS interface
of the PWM Framework. Since, PWM waveform is characterized mainly by
percent duty and the frequency, it is pretty much useful to have these
attributes.
2. Also, period_ns and duty_ns variables have been added to
the pwm_device structure as it might be needed by the PWM driver
functions.

Signed-off-by: Natarajan Sugumar <sugumar@ti.com>
Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 drivers/pwm/pwm.c       |  132 +++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/pwm/pwm.h |   11 +++-
 2 files changed, 141 insertions(+), 2 deletions(-)

diff --git a/drivers/pwm/pwm.c b/drivers/pwm/pwm.c
index ec4f4ed..43ce81a 100644
--- a/drivers/pwm/pwm.c
+++ b/drivers/pwm/pwm.c
@@ -262,6 +262,9 @@ int pwm_set_period_ns(struct pwm_device *p, unsigned long period_ns)
 		.period_ticks = pwm_ns_to_ticks(p, period_ns),
 	};
 
+	spin_lock(&p->pwm_lock);
+	p->period_ns = period_ns;
+	spin_unlock(&p->pwm_lock);
 	return pwm_config(p, &c);
 }
 EXPORT_SYMBOL(pwm_set_period_ns);
@@ -272,12 +275,60 @@ unsigned long pwm_get_period_ns(struct pwm_device *p)
 }
 EXPORT_SYMBOL(pwm_get_period_ns);
 
+int pwm_set_frequency(struct pwm_device *p, unsigned long freq)
+{
+	struct pwm_config c = {
+		.config_mask = BIT(PWM_CONFIG_PERIOD_TICKS),
+		.period_ticks = pwm_ns_to_ticks(p, (NSEC_PER_SEC / freq)),
+	};
+
+	if (!freq)
+		return -EINVAL;
+
+	spin_lock(&p->pwm_lock);
+	p->period_ns = NSEC_PER_SEC / freq;
+	spin_unlock(&p->pwm_lock);
+	return pwm_config(p, &c);
+}
+EXPORT_SYMBOL(pwm_set_frequency);
+
+unsigned long pwm_get_frequency(struct pwm_device *p)
+{
+	unsigned long period_ns;
+
+	 period_ns = pwm_ticks_to_ns(p, p->period_ticks);
+
+	if (!period_ns)
+		return 0;
+
+	return	NSEC_PER_SEC / period_ns;
+}
+EXPORT_SYMBOL(pwm_get_frequency);
+
+int pwm_set_period_ticks(struct pwm_device *p,
+					unsigned long ticks)
+{
+	struct pwm_config c = {
+		.config_mask = BIT(PWM_CONFIG_PERIOD_TICKS),
+		.period_ticks = ticks,
+	};
+
+	spin_lock(&p->pwm_lock);
+	p->period_ns = pwm_ticks_to_ns(p, ticks);
+	spin_unlock(&p->pwm_lock);
+	return pwm_config(p, &c);
+}
+EXPORT_SYMBOL(pwm_set_period_ticks);
+
 int pwm_set_duty_ns(struct pwm_device *p, unsigned long duty_ns)
 {
 	struct pwm_config c = {
 		.config_mask = BIT(PWM_CONFIG_DUTY_TICKS),
 		.duty_ticks = pwm_ns_to_ticks(p, duty_ns),
 	};
+	spin_lock(&p->pwm_lock);
+	p->duty_ns = duty_ns;
+	spin_unlock(&p->pwm_lock);
 	return pwm_config(p, &c);
 }
 EXPORT_SYMBOL(pwm_set_duty_ns);
@@ -294,10 +345,41 @@ int pwm_set_duty_percent(struct pwm_device *p, int percent)
 		.config_mask = BIT(PWM_CONFIG_DUTY_PERCENT),
 		.duty_percent = percent,
 	};
+
+	spin_lock(&p->pwm_lock);
+	p->duty_ns = p->period_ns * percent;
+	p->duty_ns /= 100;
+	spin_unlock(&p->pwm_lock);
 	return pwm_config(p, &c);
 }
 EXPORT_SYMBOL(pwm_set_duty_percent);
 
+unsigned long pwm_get_duty_percent(struct pwm_device *p)
+{
+	unsigned long long duty_percent;
+
+	duty_percent = pwm_ticks_to_ns(p, p->duty_ticks);
+	duty_percent *= 100;
+	do_div(duty_percent, p->period_ns);
+	return duty_percent;
+}
+EXPORT_SYMBOL(pwm_get_duty_percent);
+
+int pwm_set_duty_ticks(struct pwm_device *p,
+					unsigned long ticks)
+{
+	struct pwm_config c = {
+		.config_mask = BIT(PWM_CONFIG_DUTY_TICKS),
+		.duty_ticks = ticks,
+	};
+
+	spin_lock(&p->pwm_lock);
+	p->duty_ns = pwm_ticks_to_ns(p, ticks);
+	spin_unlock(&p->pwm_lock);
+	return pwm_config(p, &c);
+}
+EXPORT_SYMBOL(pwm_set_duty_ticks);
+
 int pwm_set_polarity(struct pwm_device *p, int active_high)
 {
 	struct pwm_config c = {
@@ -421,6 +503,30 @@ static ssize_t pwm_duty_ns_store(struct device *dev,
 static DEVICE_ATTR(duty_ns, S_IRUGO | S_IWUSR, pwm_duty_ns_show,
 	       pwm_duty_ns_store);
 
+static ssize_t pwm_duty_percent_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct pwm_device *p = dev_get_drvdata(dev);
+	return sprintf(buf, "%lu\n", pwm_get_duty_percent(p));
+}
+
+static ssize_t pwm_duty_percent_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf,
+				 size_t len)
+{
+	unsigned long duty_ns;
+	struct pwm_device *p = dev_get_drvdata(dev);
+
+	if (!kstrtoul(buf, 10, &duty_ns))
+		pwm_set_duty_percent(p, duty_ns);
+	return len;
+}
+
+static DEVICE_ATTR(duty_percent, S_IRUGO | S_IWUSR, pwm_duty_percent_show,
+	       pwm_duty_percent_store);
+
 static ssize_t pwm_period_ns_show(struct device *dev,
 				  struct device_attribute *attr,
 				  char *buf)
@@ -443,6 +549,30 @@ static ssize_t pwm_period_ns_store(struct device *dev,
 static DEVICE_ATTR(period_ns, S_IRUGO | S_IWUSR, pwm_period_ns_show,
 	       pwm_period_ns_store);
 
+static ssize_t pwm_period_freq_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct pwm_device *p = dev_get_drvdata(dev);
+	return sprintf(buf, "%lu\n", pwm_get_frequency(p));
+}
+
+static ssize_t pwm_period_freq_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf,
+				   size_t len)
+{
+	unsigned long freq_hz;
+
+	struct pwm_device *p = dev_get_drvdata(dev);
+	if (!kstrtoul(buf, 10, &freq_hz))
+		pwm_set_frequency(p, freq_hz);
+	return len;
+}
+
+static DEVICE_ATTR(period_freq, S_IRUGO | S_IWUSR, pwm_period_freq_show,
+	       pwm_period_freq_store);
+
 static ssize_t pwm_polarity_show(struct device *dev,
 				 struct device_attribute *attr,
 				 char *buf)
@@ -502,6 +632,8 @@ static const struct attribute *pwm_attrs[] = {
 	&dev_attr_duty_ns.attr,
 	&dev_attr_period_ns.attr,
 	&dev_attr_request.attr,
+	&dev_attr_duty_percent.attr,
+	&dev_attr_period_freq.attr,
 	NULL,
 };
 
diff --git a/include/linux/pwm/pwm.h b/include/linux/pwm/pwm.h
index 4ebb855..fcfd519 100644
--- a/include/linux/pwm/pwm.h
+++ b/include/linux/pwm/pwm.h
@@ -98,6 +98,8 @@ struct pwm_device {
 	int active_high;
 	unsigned long period_ticks;
 	unsigned long duty_ticks;
+	unsigned long period_ns;
+	unsigned long duty_ns;
 	spinlock_t pwm_lock;
 };
 
@@ -159,6 +161,11 @@ int pwm_unregister(struct pwm_device *p);
 struct pwm_device *gpio_pwm_create(int gpio);
 int gpio_pwm_destroy(struct pwm_device *p);
 #endif
-
-
+int pwm_set_frequency(struct pwm_device *p, unsigned long freq);
+unsigned long pwm_get_frequency(struct pwm_device *p);
+int pwm_set_period_ticks(struct pwm_device *p,
+					unsigned long ticks);
+unsigned long pwm_get_duty_percent(struct pwm_device *p);
+int pwm_set_duty_ticks(struct pwm_device *p,
+					unsigned long ticks);
 #endif
-- 
1.7.5.4

