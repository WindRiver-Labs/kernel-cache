From c5f7e29259afbc7680d881589dcfffde9d5418c6 Mon Sep 17 00:00:00 2001
From: "Satyanarayana, Sandhya" <sandhya.satyanarayana@ti.com>
Date: Mon, 13 Aug 2012 12:30:03 +0800
Subject: [PATCH 270/609] ARM: OMAP: AM33XX: Add ddr_vtt_enable support for
 EVM-SK1.2

Original commit: e5fc4ccd43a92adec637beef8d2b03908cef7946

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

EVM-SK Rev1.2 has gpio control(gpio0_7) for VTT
regulator control pin through which VTT regulator
can be disabled (drive gpio LOW) during suspend
and enabled (drive gpio HIGH) during resume.
This will aid in achieving lower power during DS0.

This patch does the pin-muxing for gpio0_7 and toggles
it during suspend-resume.

Gpio0_7 was driven High in u-boot before configuring DDR.

This has been tested on EVM-SK and EVM.

Signed-off-by: Satyanarayana, Sandhya <sandhya.satyanarayana@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c              |   26 ++++++++
 arch/arm/mach-omap2/include/mach/board-am335xevm.h |    2 +
 arch/arm/mach-omap2/pm33xx.c                       |   10 +++
 arch/arm/mach-omap2/pm33xx.h                       |    1 +
 arch/arm/mach-omap2/sleep33xx.S                    |   64 ++++++++++++++++++--
 arch/arm/plat-omap/include/plat/gpio.h             |    5 ++
 6 files changed, 102 insertions(+), 6 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 86d2388..c56fd14 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -696,6 +696,11 @@ static struct pinmux_config gpio_led_mux[] = {
 	{NULL, 0},
 };
 
+static struct pinmux_config gpio_ddr_vtt_enb_pin_mux[] = {
+	{"ecap0_in_pwm0_out.gpio0_7", OMAP_MUX_MODE7 | AM33XX_PIN_OUTPUT},
+	{NULL, 0},
+};
+
 /*
 * @pin_mux - single module pin-mux structure which defines pin-mux
 *			details for all its pins.
@@ -1121,6 +1126,17 @@ static void uart2_init(int evm_id, int profile)
 	return;
 }
 
+/*
+ * gpio0_7 was driven HIGH in u-boot before DDR configuration
+ *
+ * setup gpio0_7 for EVM-SK 1.2
+ */
+static void gpio_ddr_vtt_enb_init(int evm_id, int profile)
+{
+	setup_pin_mux(gpio_ddr_vtt_enb_pin_mux);
+	return;
+}
+
 /* setup haptics */
 #define HAPTICS_MAX_FREQ 250
 static void haptics_init(int evm_id, int profile)
@@ -2024,6 +2040,7 @@ static struct evm_dev_cfg evm_sk_dev_cfg[] = {
 	{mcasp1_init,   DEV_ON_BASEBOARD, PROFILE_ALL},
 	{uart1_wl12xx_init, DEV_ON_BASEBOARD, PROFILE_ALL},
 	{wl12xx_init,       DEV_ON_BASEBOARD, PROFILE_ALL},
+	{gpio_ddr_vtt_enb_init,	DEV_ON_BASEBOARD, PROFILE_ALL},
 	{NULL, 0, 0},
 };
 
@@ -2487,6 +2504,15 @@ void __iomem *am33xx_get_ram_base(void)
 	return am33xx_emif_base;
 }
 
+void __iomem *am33xx_gpio0_base;
+
+void __iomem *am33xx_get_gpio0_base(void)
+{
+	am33xx_gpio0_base = ioremap(AM33XX_GPIO0_BASE, SZ_4K);
+
+	return am33xx_gpio0_base;
+}
+
 static struct resource am33xx_cpuidle_resources[] = {
 	{
 		.start		= AM33XX_EMIF0_BASE,
diff --git a/arch/arm/mach-omap2/include/mach/board-am335xevm.h b/arch/arm/mach-omap2/include/mach/board-am335xevm.h
index 1f011c8..691ec96 100644
--- a/arch/arm/mach-omap2/include/mach/board-am335xevm.h
+++ b/arch/arm/mach-omap2/include/mach/board-am335xevm.h
@@ -38,9 +38,11 @@
 #define PROFILE_7		(0x1 << 7)
 #define PROFILE_ALL		0xFF
 
+#ifndef __ASSEMBLER__
 void am335x_evm_set_id(unsigned int evmid);
 int am335x_evm_get_id(void);
 void am335x_cpsw_macidfillup(char *eeprommacid0, char *eeprommacid1);
 void am33xx_d_can_init(unsigned int instance);
 
 #endif
+#endif
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index fc3f2b8..d2edba0 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -26,6 +26,7 @@
 #include <linux/completion.h>
 #include <linux/pm_runtime.h>
 
+#include <mach/board-am335xevm.h>
 #include <plat/prcm.h>
 #include <plat/mailbox.h>
 #include <plat/sram.h>
@@ -491,6 +492,7 @@ static int __init am33xx_pm_init(void)
 	int ret;
 	void __iomem *base;
 	u32 reg;
+	u32 evm_id;
 
 	if (!cpu_is_am33xx())
 		return -ENODEV;
@@ -512,6 +514,14 @@ static int __init am33xx_pm_init(void)
 	else
 		suspend_cfg_param_list[SUSP_VTP_CTRL_VAL] = SUSP_VTP_CTRL_DDR3;
 
+
+	/* Get Board Id */
+	evm_id = am335x_evm_get_id();
+	if (evm_id != -EINVAL)
+		suspend_cfg_param_list[EVM_ID] = evm_id;
+	else
+		suspend_cfg_param_list[EVM_ID] = 0xff;
+
 #ifdef CONFIG_SUSPEND
 	(void) clkdm_for_each(clkdms_setup, NULL);
 
diff --git a/arch/arm/mach-omap2/pm33xx.h b/arch/arm/mach-omap2/pm33xx.h
index e4f1469..5fcb0f5 100644
--- a/arch/arm/mach-omap2/pm33xx.h
+++ b/arch/arm/mach-omap2/pm33xx.h
@@ -29,6 +29,7 @@ extern void __iomem *am33xx_get_ram_base(void);
 enum suspend_cfg_params {
 	MEMORY_TYPE = 0,
 	SUSP_VTP_CTRL_VAL,
+	EVM_ID,
 	SUSPEND_CFG_PARAMS_END /* Must be the last entry */
 };
 
diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
index 527fd66..4f25904 100644
--- a/arch/arm/mach-omap2/sleep33xx.S
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -18,11 +18,11 @@
 #include <asm/memory.h>
 #include <asm/assembler.h>
 #include <mach/io.h>
-#include <plat/emif.h>
-#include "cm33xx.h"
+#include <mach/board-am335xevm.h>
 
 #include <plat/emif.h>
 #include <plat/sram.h>
+#include <plat/gpio.h>
 
 #include "cm33xx.h"
 #include "pm33xx.h"
@@ -39,12 +39,13 @@
  * types to be passed in r0 _strictly_ in following order:
  * 1) memory_type [r0]
  * 2) susp_vtp_ctrl_val [r1]
+ * 3) evm_id [r2]
  *
  * The code loads these values taking r0 value as reference to the array in
  * registers starting from r0, i,e memory_type goes to r0 and susp_vtp_ctrl_val
- * goes to r1. These are then saved into memory locations before proceeding
- * with the sleep sequence and hence registers r0,r1 can still be used in the
- * rest of the sleep code.
+ * goes to r1 and so on. These are then saved into memory locations before
+ * proceeding with the sleep sequence and hence registers r0,r1 can still be
+ * used in the rest of the sleep code.
  *
  * mem_type is used to decide different suspend-resume sequences for DDR2
  * and DDR3.
@@ -121,6 +122,11 @@ wait_sc_\num:
 
 	str	r0, emif_addr_virt
 
+	ldr	r0, gpio0_addr_func
+	blx	r0
+
+	str	r0, gpio0_addr_virt
+
 	/* This ensures isb */
 	ldr	r0, dcache_flush
 	blx	r0
@@ -129,11 +135,12 @@ wait_sc_\num:
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c5, 0	@ I+BTB cache invalidate
 
-	ldm	r8, {r0-r1}		@ gather values passed
+	ldm	r8, {r0-r2}		@ gather values passed
 
 	/* Save the values passed */
 	str	r0, mem_type
 	str	r1, susp_vtp_ctrl_val
+	str	r2, evm_id
 
 	ldr	r0, emif_addr_virt
 
@@ -179,6 +186,18 @@ wait_sc_\num:
 
 	ddr_self_refresh	1
 
+	/* Disable VTT_Regulator on EVM-SK*/
+	ldr	r6, evm_id
+	cmp	r6, #EVM_SK
+	bne	no_gpio_toggle
+
+	/* Drive GPIO0_7 LOW */
+	ldr	r0, gpio0_addr_virt
+	ldr	r1, [r0, #OMAP4_GPIO_CLEARDATAOUT]
+	mov	r2, #(1 << 7)
+	str	r2, [r0, #OMAP4_GPIO_CLEARDATAOUT]
+
+no_gpio_toggle:
 	/* Weak pull down for macro DATA0 */
 	ldr	r1, virt_ddr_data0_ioctrl
 	ldr	r2, susp_io_pull_data
@@ -394,6 +413,18 @@ poll_vtp_ready_abt3:
 
 	wait_sdram_config	1
 
+	/* Enable VTT_Regulator on EVM-SK */
+	ldr	r6, evm_id
+	cmp	r6, #EVM_SK
+	bne	no_gpio_toggle2
+
+	/* Drive GPIO0_7 HIGH */
+	ldr	r0, gpio0_addr_virt
+	ldr	r1, [r0, #OMAP4_GPIO_SETDATAOUT]
+	mov	r2, #(1 << 7)
+	str	r2, [r0, #OMAP4_GPIO_SETDATAOUT]
+
+no_gpio_toggle2:
 	b	emif_self_refresh_dis
 
 	/* DDR2 resume path */
@@ -545,6 +576,18 @@ poll_vtp_ready3:
 
 	wait_sdram_config	2
 
+	/* Enable VTT_Regulator	on EVM-SK */
+	ldr	r6, evm_id
+	cmp	r6, #EVM_SK
+	bne	no_gpio_toggle3
+
+	/* Drive GPIO0_7 HIGH */
+	ldr	r0, gpio0_phys_addr
+	ldr	r1, [r0, #OMAP4_GPIO_SETDATAOUT]
+	mov	r2, #(1 << 7)
+	str	r2, [r0, #OMAP4_GPIO_SETDATAOUT]
+
+no_gpio_toggle3:
 	b	config_emif_timings
 
 	/* DDR2 resume path */
@@ -667,6 +710,11 @@ emif_addr_func:
 emif_phys_addr:
 	.word	AM33XX_EMIF0_BASE
 
+gpio0_addr_func:
+	.word	am33xx_get_gpio0_base
+gpio0_phys_addr:
+	.word	AM33XX_GPIO0_BASE
+
 ddr_start:
 	.word	PAGE_OFFSET
 
@@ -791,8 +839,12 @@ susp_vtp_ctrl_val:
 	.word	0xDEADBEEF
 mem_type:
 	.word	0xDEADBEEF
+evm_id:
+	.word	0xDEADBEEF
 emif_addr_virt:
 	.word	0xDEADBEEF
+gpio0_addr_virt:
+	.word	0xDEADBEEF
 emif_rd_lat_val:
 	.word	0xDEADBEEF
 emif_timing1_val:
diff --git a/arch/arm/plat-omap/include/plat/gpio.h b/arch/arm/plat-omap/include/plat/gpio.h
index 2f6e992..9775c6d 100644
--- a/arch/arm/plat-omap/include/plat/gpio.h
+++ b/arch/arm/plat-omap/include/plat/gpio.h
@@ -26,10 +26,12 @@
 #ifndef __ASM_ARCH_OMAP_GPIO_H
 #define __ASM_ARCH_OMAP_GPIO_H
 
+#ifndef __ASSEMBLER__
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <mach/irqs.h>
 
+#endif
 #define OMAP1_MPUIO_BASE			0xfffb5000
 
 /*
@@ -158,6 +160,7 @@
 #define OMAP_MPUIO(nr)		(OMAP_MAX_GPIO_LINES + (nr))
 #define OMAP_GPIO_IS_MPUIO(nr)	((nr) >= OMAP_MAX_GPIO_LINES)
 
+#ifndef __ASSEMBLER__
 struct omap_gpio_dev_attr {
 	int bank_width;		/* GPIO bank width */
 	bool dbck_flag;		/* dbck required or not - True for OMAP3&4 */
@@ -225,3 +228,5 @@ extern void omap_set_gpio_debounce_time(int gpio, int enable);
 #include <asm-generic/gpio.h>
 
 #endif
+
+#endif
-- 
1.7.5.4

