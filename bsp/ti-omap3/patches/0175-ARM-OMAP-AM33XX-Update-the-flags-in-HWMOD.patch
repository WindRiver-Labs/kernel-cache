From e23af9ce329d1e954e3feccfed55f1413c856f6f Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Thu, 9 Feb 2012 23:04:02 +0530
Subject: [PATCH 175/609] ARM: OMAP: AM33XX: Update the flags in HWMOD

Original commit: 453879c97d4e56a33d8e8f87b0dbc979c45b7c5f

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

For the modules which require special handling, update
the flags in the hwmod data. WIth this done, the PM
framework takes care of the special handling for the
modules.

Note: With HWMOD_SWSUP_MSTANDBY set, the module goes
to standby during boot. Unless the driver makes use
of runtime PM APIs the module will stay in standby
which is not desired. For now we disable idling
this modules during the boot. When the drivers start
making use of runtime PM this workaround must be
removed.

All this should eventually make its way into the
appropriate drivers.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index 26c0c6c..755e1c0 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -500,6 +500,8 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod = {
 	},
 	.slaves		= am33xx_cpgmac0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_cpgmac0_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* 'dcan' class */
@@ -1022,6 +1024,8 @@ static struct omap_hwmod am33xx_gpmc_hwmod = {
 	},
 	.slaves		= am33xx_gpmc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_gpmc_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
+				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* 'i2c' class */
@@ -1344,6 +1348,7 @@ static struct omap_hwmod am33xx_lcdc_hwmod = {
 	},
 	.slaves		= am33xx_lcdc_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_lcdc_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /*
@@ -2037,6 +2042,7 @@ static struct omap_hwmod am33xx_timer0_hwmod = {
 	},
 	.slaves		= am33xx_timer0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_timer0_slaves),
+	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
 /* timer1 1ms */
@@ -2474,6 +2480,7 @@ static struct omap_hwmod am33xx_tptc0_hwmod = {
 	},
 	.slaves		= am33xx_tptc0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc0_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* tptc1 */
@@ -2517,6 +2524,7 @@ static struct omap_hwmod am33xx_tptc1_hwmod = {
 	},
 	.slaves		= am33xx_tptc1_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc1_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* tptc2 */
@@ -2560,6 +2568,7 @@ static struct omap_hwmod am33xx_tptc2_hwmod = {
 	},
 	.slaves		= am33xx_tptc2_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_tptc2_slaves),
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* 'uart' class */
@@ -2994,6 +3003,8 @@ static struct omap_hwmod am33xx_usbss_hwmod = {
 	},
 	.slaves		= am33xx_usbss_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_usbss_slaves),
+	.class		= &am33xx_usbotg_class,
+	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY),
 };
 
 /* gfx */
-- 
1.7.5.4

