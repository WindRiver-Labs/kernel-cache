From ef52fe49c317e9ad3fe1bcc60b391f7d6e5ce0c8 Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 4 Jan 2012 14:49:03 +0530
Subject: [PATCH 067/609] ARM: OMAP: AM33XX: Basic suspend resume support

Original commit: fd44b0b9942098860f77b6611969064a6083fa34

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Add support for basic suspend-resume.
Currently DeepSlee1 mode of the processor is used
as the suspend state.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/Makefile           |    4 +-
 arch/arm/mach-omap2/pm.h               |    9 +
 arch/arm/mach-omap2/pm33xx.c           |  340 ++++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/sleep33xx.S        |   48 +++++
 arch/arm/plat-omap/include/plat/sram.h |    2 +
 arch/arm/plat-omap/sram.c              |    1 +
 6 files changed, 403 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-omap2/pm33xx.c
 create mode 100644 arch/arm/mach-omap2/sleep33xx.S

diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index e00967d..b17d639 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -69,13 +69,15 @@ obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o \
 					   cpuidle34xx.o
 obj-$(CONFIG_ARCH_OMAP4)		+= pm44xx.o omap-mpuss-lowpower.o \
 					   cpuidle44xx.o
-obj-$(CONFIG_SOC_OMAPAM33XX)		+= cpuidle33xx.o
+obj-$(CONFIG_SOC_OMAPAM33XX)		+= cpuidle33xx.o pm33xx.o \
+					   sleep33xx.o
 obj-$(CONFIG_PM_DEBUG)			+= pm-debug.o
 obj-$(CONFIG_OMAP_SMARTREFLEX)          += sr_device.o smartreflex.o
 obj-$(CONFIG_OMAP_SMARTREFLEX_CLASS3)	+= smartreflex-class3.o
 
 AFLAGS_sleep24xx.o			:=-Wa,-march=armv6
 AFLAGS_sleep34xx.o			:=-Wa,-march=armv7-a$(plus_sec)
+AFLAGS_sleep33xx.o			:=-Wa,-march=armv7-a$(plus_sec)
 
 ifeq ($(CONFIG_PM_VERBOSE),y)
 CFLAGS_pm_bus.o				+= -DDEBUG
diff --git a/arch/arm/mach-omap2/pm.h b/arch/arm/mach-omap2/pm.h
index 36fa90b..a8408fc 100644
--- a/arch/arm/mach-omap2/pm.h
+++ b/arch/arm/mach-omap2/pm.h
@@ -97,6 +97,15 @@ extern unsigned int save_secure_ram_context_sz;
 
 extern void omap3_save_scratchpad_contents(void);
 
+/* 33xx */
+/* am33xx_do_wfi function pointer and size, for copy to SRAM */
+extern void am33xx_do_wfi(void);
+extern unsigned int am33xx_do_wfi_sz;
+/* ... and its pointer from SRAM after copy */
+extern void (*am33xx_do_wfi_sram)(void);
+/* The resume location */
+extern void am33xx_resume_vector(void);
+
 #define PM_RTA_ERRATUM_i608		(1 << 0)
 #define PM_SDRC_WAKEUP_ERRATUM_i583	(1 << 1)
 
diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
new file mode 100644
index 0000000..27bf641
--- /dev/null
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -0,0 +1,340 @@
+/*
+ * AM33XX Power Management Routines
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/console.h>
+#include <linux/err.h>
+#include <linux/firmware.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+
+#include <plat/prcm.h>
+#include <plat/mailbox.h>
+#include <plat/sram.h>
+#include <plat/omap_hwmod.h>
+#include <plat/omap_device.h>
+
+#include <asm/suspend.h>
+#include <asm/proc-fns.h>
+#include <asm/sizes.h>
+
+#include "pm.h"
+
+static int m3_state;
+static struct device *mpu_dev;
+struct omap_mbox *m3_mbox;
+void __iomem *ipc_regs;
+void __iomem *m3_eoi;
+void __iomem *m3_code;
+
+bool enable_deep_sleep = true;
+
+struct a8_wkup_m3_ipc_data {
+	int resume_addr;
+	int sleep_mode;
+	int ipc_data1;
+	int ipc_data2;
+} am33xx_lp_ipc;
+
+static int am33xx_set_low_power_state(struct a8_wkup_m3_ipc_data *);
+void (*am33xx_do_wfi_sram)(void);
+
+#define DS_RESUME_ADDR	0x40300010
+#define DS_MODE		0x5
+#define DS_IPC_DEFAULT	0xffffffff
+
+#define A8_M3_IPC_REGS	0x44E11328
+#define M3_TXEV_EOI	0x44E11324
+
+#ifdef CONFIG_SUSPEND
+static suspend_state_t suspend_state = PM_SUSPEND_ON;
+
+static int am33xx_do_sram_idle(long unsigned int state)
+{
+	am33xx_do_wfi_sram();
+	return 0;
+}
+
+static inline bool is_suspending(void)
+{
+	return (suspend_state != PM_SUSPEND_ON) && console_suspend_enabled;
+}
+
+static int am33xx_pm_suspend(void)
+{
+	int ret = 0;
+
+	/* Block console output in case it is on one of the OMAP UARTs */
+	if (!is_suspending()) {
+		if (!console_trylock()) {
+			ret = -EAGAIN;
+			goto err;
+		}
+	}
+
+	ret = cpu_suspend(0, am33xx_do_sram_idle);
+	if (ret)
+		pr_err("Could not suspend\n");
+	else
+		goto done;
+
+err:
+	pr_err("Console still active\n");
+done:
+	return ret;
+}
+
+static int am33xx_pm_enter(suspend_state_t unused)
+{
+	int ret = 0;
+
+	switch (suspend_state) {
+	case PM_SUSPEND_STANDBY:
+	case PM_SUSPEND_MEM:
+		ret = am33xx_pm_suspend();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int am33xx_pm_begin(suspend_state_t state)
+{
+	int ret = 0;
+
+	am33xx_lp_ipc.resume_addr = DS_RESUME_ADDR;
+	am33xx_lp_ipc.sleep_mode  = DS_MODE;
+	am33xx_lp_ipc.ipc_data1	  = DS_IPC_DEFAULT;
+	am33xx_lp_ipc.ipc_data2   = DS_IPC_DEFAULT;
+
+	am33xx_set_low_power_state(&am33xx_lp_ipc);
+
+	ret = omap_mbox_msg_send(m3_mbox, 0xABCDABCD);
+	if (!ret) {
+		pr_info("Message sent\n");
+		omap_mbox_msg_rx_flush(m3_mbox);
+	}
+
+	omap_mbox_disable_irq(m3_mbox, IRQ_RX);
+
+	disable_hlt();
+	suspend_state = state;
+
+	return ret;
+}
+
+static void am33xx_pm_end(void)
+{
+	suspend_state = PM_SUSPEND_ON;
+
+	if (!is_suspending())
+		console_unlock();
+
+	omap_mbox_enable_irq(m3_mbox, IRQ_RX);
+	return;
+}
+
+static const struct platform_suspend_ops am33xx_pm_ops = {
+	.begin		= am33xx_pm_begin,
+	.end		= am33xx_pm_end,
+	.enter		= am33xx_pm_enter,
+	.valid		= suspend_valid_only_mem,
+};
+#endif /* CONFIG_SUSPEND */
+
+/*
+ * Push the minimal suspend-resume code to SRAM
+ */
+void am33xx_push_sram_idle(void)
+{
+	am33xx_do_wfi_sram = omap_sram_push(am33xx_do_wfi, am33xx_do_wfi_sz);
+}
+
+int am33xx_set_low_power_state(struct a8_wkup_m3_ipc_data *data)
+{
+	__raw_writel(data->resume_addr, ipc_regs);
+	__raw_writel(data->sleep_mode, ipc_regs + 0x4);
+	__raw_writel(data->ipc_data1, ipc_regs + 0x8);
+	__raw_writel(data->ipc_data2, ipc_regs + 0xc);
+
+	return 0;
+}
+
+/*
+ * Dummy notifier for the mailbox
+ * TODO: Can this be completely removed?
+ */
+int wkup_m3_mbox_msg(struct notifier_block *self, unsigned long len, void *msg)
+{
+	return 0;
+}
+
+static struct notifier_block wkup_m3_mbox_notifier = {
+	.notifier_call = wkup_m3_mbox_msg,
+};
+
+/* Interrupt from M3 to A8 */
+static irqreturn_t wkup_m3_txev_handler(int irq, void *unused)
+{
+	m3_state++;
+
+	if (m3_eoi) {
+		__raw_writel(0x1, m3_eoi);
+		__raw_writel(0x0, m3_eoi);
+		return IRQ_HANDLED;
+	} else {
+		pr_err("%s unexpected interrupt. "
+		"Something is seriously wrong\n", __func__);
+		return IRQ_NONE;
+	}
+}
+
+/* Initiliaze WKUP_M3, load the binary blob and let it run */
+static int wkup_m3_init(void)
+{
+	struct clk *m3_clk;
+	struct omap_hwmod *wkup_m3_oh;
+	const struct firmware *firmware;
+	int ret = 0;
+
+	wkup_m3_oh = omap_hwmod_lookup("wkup_m3");
+
+	if (!wkup_m3_oh) {
+		pr_err("%s: could not find omap_hwmod\n", __func__);
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	ipc_regs = ioremap(A8_M3_IPC_REGS, 0x4*8);
+	if (!ipc_regs) {
+		pr_err("Could not ioremap the IPC area\b");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	m3_eoi = ioremap(M3_TXEV_EOI, 0x4);
+	if (!m3_eoi) {
+		pr_err("Could not ioremap the EOI register\n");
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	/* Reserve the MBOX for sending messages to M3 */
+	m3_mbox = omap_mbox_get("wkup_m3", &wkup_m3_mbox_notifier);
+	if (IS_ERR(m3_mbox)) {
+		pr_err("Could not reserve mailbox for A8->M3 IPC\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	/* Enable access to the M3 code and data area from A8 */
+	m3_clk = clk_get(NULL, "wkup_m3_fck");
+	if (IS_ERR(m3_clk)) {
+		pr_err("%s failed to enable WKUP_M3 clock\n", __func__);
+		goto err3;
+	}
+
+	if (clk_enable(m3_clk)) {
+		pr_err("%s WKUP_M3: clock enable Failed\n", __func__);
+		goto err4;
+	}
+
+	m3_code = ioremap(0x44D00000, SZ_16K);
+	if (!m3_code) {
+		pr_err("%s Could not ioremap M3 code space\n", __func__);
+		ret = -ENOMEM;
+		goto err5;
+	}
+
+	/* Now try to load the firware */
+	ret = request_firmware(&firmware, "cm3-firmware.bin", mpu_dev);
+	if (ret < 0) {
+		dev_err(mpu_dev, "request_firmware failed\n");
+		goto err6;
+	} else {
+		memcpy(m3_code, firmware->data, firmware->size);
+		pr_info("Copied the M3 firmware to UMEM\n");
+	}
+
+	ret = omap_hwmod_deassert_hardreset(wkup_m3_oh, "wkup_m3");
+	if (ret) {
+		pr_err("Could not deassert the reset for WKUP_M3\n");
+		goto err6;
+	}
+
+	ret = request_irq(AM33XX_IRQ_M3_M3SP_TXEV, wkup_m3_txev_handler,
+			  IRQF_DISABLED, "wkup_m3_txev", NULL);
+	if (ret)
+		pr_err("%s request_irq failed for 0x%x\n", __func__,
+			AM33XX_IRQ_M3_M3SP_TXEV);
+	else
+		return 0;
+
+err6:
+	release_firmware(firmware);
+	iounmap(m3_code);
+err5:
+	clk_disable(m3_clk);
+err4:
+	clk_put(m3_clk);
+err3:
+	omap_mbox_put(m3_mbox, &wkup_m3_mbox_notifier);
+err2:
+	iounmap(m3_eoi);
+err1:
+	iounmap(ipc_regs);
+exit:
+	return ret;
+}
+
+
+static int __init am33xx_pm_init(void)
+{
+	int ret;
+
+	if (!cpu_is_am33xx())
+		return -ENODEV;
+
+	pr_info("Power Management for AM33XX family\n");
+
+	mpu_dev = omap_device_get_by_hwmod_name("mpu");
+
+	if (!mpu_dev) {
+		pr_warning("%s: unable to get the mpu device\n", __func__);
+		return -EINVAL;
+	}
+
+	ret = wkup_m3_init();
+
+	if (ret) {
+		pr_err("Could not initialise WKUP_M3."
+			"Power management will be compromised\n");
+		enable_deep_sleep = false;
+	}
+
+#ifdef CONFIG_SUSPEND
+	if (enable_deep_sleep)
+		suspend_set_ops(&am33xx_pm_ops);
+#endif /* CONFIG_SUSPEND */
+
+	return ret;
+}
+late_initcall(am33xx_pm_init);
diff --git a/arch/arm/mach-omap2/sleep33xx.S b/arch/arm/mach-omap2/sleep33xx.S
new file mode 100644
index 0000000..1457c3a
--- /dev/null
+++ b/arch/arm/mach-omap2/sleep33xx.S
@@ -0,0 +1,48 @@
+/*
+ * Low level suspend code for AM33XX SoCs
+ *
+ * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/memory.h>
+#include <asm/assembler.h>
+#include <plat/sram.h>
+#include <mach/io.h>
+
+	.align 3
+ENTRY(am33xx_do_wfi)
+	wfi
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* We are back. Branch to the common CPU resume routine */
+ENTRY(am33xx_resume_vector)
+	ldr	pc, resume_addr
+
+resume_addr:
+	.word	cpu_resume - PAGE_OFFSET + 0x80000000
+
+ENTRY(am33xx_do_wfi_sz)
+	.word	. - am33xx_do_wfi
diff --git a/arch/arm/plat-omap/include/plat/sram.h b/arch/arm/plat-omap/include/plat/sram.h
index f7d0818..24d2435 100644
--- a/arch/arm/plat-omap/include/plat/sram.h
+++ b/arch/arm/plat-omap/include/plat/sram.h
@@ -89,8 +89,10 @@ extern u32 omap3_sram_configure_core_dpll(
 extern unsigned long omap3_sram_configure_core_dpll_sz;
 
 #ifdef CONFIG_PM
+extern void am33xx_push_sram_idle(void);
 extern void omap_push_sram_idle(void);
 #else
+static inline void am33xx_push_sram_idle(void) {}
 static inline void omap_push_sram_idle(void) {}
 #endif /* CONFIG_PM */
 
diff --git a/arch/arm/plat-omap/sram.c b/arch/arm/plat-omap/sram.c
index 43b5d01..4976758 100644
--- a/arch/arm/plat-omap/sram.c
+++ b/arch/arm/plat-omap/sram.c
@@ -357,6 +357,7 @@ static inline int omap34xx_sram_init(void)
 
 static inline int am33xx_sram_init(void)
 {
+	am33xx_push_sram_idle();
 	return 0;
 }
 
-- 
1.7.5.4

