From 2f9a81691e48b6c0c699225df0dfc49dca63c731 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Wed, 1 Aug 2012 17:00:57 +0800
Subject: [PATCH 251/609] ARM: AM33XX: hwmod: Implement cpsw ocp

Original commit: a28da2ac98f173f97dbbb46be1ce0a3879f21a11

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

level reset before disabling it

As per the observation (not yet confirmed from IP team), SW must assert
the Module level reset signal to all 4 submodules of the CPSW before
disabling the clock/module; without this module doesn't enter into idle
state and this eventually leads to failure in entering into low-power state.

So in order to handle this from standard runtime-pm and hwmod framework,
so that driver doesn't need to do any custom handling due to this IP
integration (not sure though) issues, this patch implements new approach,
  - Introduce new flag to indicate that this module requires special
    attention before disabling it.
  - Add cpsw specific reset function in am33xx hwmod data file, since
    This issue is specific to am33xx.
  - Add rst_offs field to omap_hwmod_class structure, required for
    accessing reset register (if different than sysc)

Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 arch/arm/mach-omap2/omap_hwmod.c             |    7 ++
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c   |  130 +++++++++++++++++++++++++-
 arch/arm/plat-omap/include/plat/omap_hwmod.h |    5 +
 3 files changed, 138 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index 38d5925..383cf71 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -1641,6 +1641,13 @@ static int _idle(struct omap_hwmod *oh)
 		return -EINVAL;
 	}
 
+	/*
+	 * FIXME: Due to AM33XX CPSW IP integration bug, it is required
+	 * to assert ocp reset signal to the module before disabling it.
+	 */
+	if (oh->flags & HWMOD_SWSUP_RESET_BEFORE_IDLE)
+		_reset(oh);
+
 	if (oh->class->sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index 2edeb04..7b15985 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -14,6 +14,11 @@
  * GNU General Public License for more details.
  */
 
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+
 #include <plat/omap_hwmod.h>
 #include <plat/cpu.h>
 #include <plat/gpio.h>
@@ -21,11 +26,14 @@
 #include <plat/mmc.h>
 #include <plat/mcspi.h>
 #include <plat/i2c.h>
+#include <plat/clock.h>
+#include <plat/prcm.h>
 
 #include "omap_hwmod_common_data.h"
 #include "control.h"
 #include "cm33xx.h"
 #include "prm33xx.h"
+#include "common.h"
 
 /* Backward references (IPs with Bus Master capability) */
 static struct omap_hwmod am33xx_mpu_hwmod;
@@ -84,6 +92,62 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod;
 static struct omap_hwmod am33xx_mdio_hwmod;
 
 /*
+ * ERRATA: (Yet to conform from IP team)
+ * As per the observation, in order to disable the cpsw clock/module
+ * from already enabled state, module level reset assertion is
+ * required; without reset the clock/module won't enter into
+ * idle state at all.
+ * Also, as per observation (have not conformed yet), we have to
+ * assert reset signal for all cpsw (4) submodules.
+ */
+
+/* OCP SYSSTATUS bit shifts/masks */
+#define SOFT_RESETDONE_SHIFT		0
+#define SOFT_RESETDONE_MASK		(1 << SOFT_RESETDONE_SHIFT)
+
+#define MAX_MODULE_SOFTRESET_WAIT	10000
+
+static int am33xx_cpgmac_reset(struct omap_hwmod *oh)
+{
+	int i;
+	int ret = 0;
+
+	pr_debug("%s: resetting via Module SOFTRESET bit\n", oh->name);
+
+	for (i = 0; i < oh->slaves_cnt; i++) {
+		int c = 0;
+		void __iomem *va_start;
+		struct omap_hwmod_ocp_if *os;
+		struct omap_hwmod_addr_space *mem;
+
+		os = oh->slaves[i];
+		/* FIXME: Only first instance's OCP_RST is asserted */
+		mem = &os->addr[0];
+
+		va_start = ioremap(mem->pa_start, mem->pa_end - mem->pa_start);
+		if (!va_start) {
+			pr_err("%s: Could not ioremap (%x)\n",
+					oh->name, mem->pa_start);
+			ret = -ENOMEM;
+			break;
+		}
+		/* Assert reset signal */
+		writel(1, va_start + oh->class->sysc->rst_offs);
+		omap_test_timeout(((readl(va_start + oh->class->sysc->rst_offs)
+					& SOFT_RESETDONE_MASK) == 0),
+				MAX_MODULE_SOFTRESET_WAIT, c);
+
+		if (c == MAX_MODULE_SOFTRESET_WAIT) {
+			pr_warning("%s: softreset failed (waited %d usec)\n",
+					oh->name, MAX_MODULE_SOFTRESET_WAIT);
+			ret = -ETIMEDOUT;
+		}
+	}
+
+	return ret;
+}
+
+/*
  * Interconnects hwmod structures
  * hwmods that compose the global AM33XX OCP interconnect
  */
@@ -450,8 +514,8 @@ static struct omap_hwmod_class_sysconfig am33xx_cpgmac_sysc = {
 	.rev_offs	= 0x0,
 	.sysc_offs	= 0x8,
 	.syss_offs	= 0x4,
-	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
-			SYSS_HAS_RESET_STATUS),
+	.rst_offs	= 0x8,
+	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE),
 	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | MSTANDBY_FORCE |
 			MSTANDBY_NO),
 	.sysc_fields	= &omap_hwmod_sysc_type3,
@@ -460,18 +524,22 @@ static struct omap_hwmod_class_sysconfig am33xx_cpgmac_sysc = {
 static struct omap_hwmod_class am33xx_cpgmac0_hwmod_class = {
 	.name		= "cpsw",
 	.sysc		= &am33xx_cpgmac_sysc,
+	.reset		= am33xx_cpgmac_reset,
 };
 
+/* Used by driver */
 struct omap_hwmod_addr_space am33xx_cpgmac0_addr_space[] = {
+	/* cpsw ss */
 	{
 		.pa_start	= 0x4A100000,
 		.pa_end		= 0x4A100000 + SZ_2K - 1,
 		.flags		= ADDR_MAP_ON_INIT,
 	},
+	/* cpsw wr */
 	{
 		.pa_start	= 0x4A101200,
 		.pa_end		= 0x4A101200 + SZ_256 - 1,
-		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
+		.flags		= ADDR_TYPE_RT,
 	},
 	{ }
 };
@@ -483,8 +551,62 @@ struct omap_hwmod_ocp_if am33xx_l3_main__cpgmac0 = {
 	.user		= OCP_USER_MPU,
 };
 
+struct omap_hwmod_addr_space am33xx_cpsw_sl1_addr_space[] = {
+	/* cpsw sl1 */
+	{
+		.pa_start	= 0x4A100D84,
+		.pa_end		= 0x4A100D84 + SZ_32 - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+	{ }
+};
+
+struct omap_hwmod_ocp_if am33xx_l3_main__cpsw_sl1 = {
+	.master		= &am33xx_l3_main_hwmod,
+	.slave		= &am33xx_cpgmac0_hwmod,
+	.addr		= am33xx_cpsw_sl1_addr_space,
+	.user		= OCP_USER_MPU,
+};
+
+struct omap_hwmod_addr_space am33xx_cpsw_sl2_addr_space[] = {
+	/* cpsw sl2 */
+	{
+		.pa_start	= 0x4A100DC4,
+		.pa_end		= 0x4A100DC4 + SZ_32 - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+	{ }
+};
+
+struct omap_hwmod_ocp_if am33xx_l3_main__cpsw_sl2 = {
+	.master		= &am33xx_l3_main_hwmod,
+	.slave		= &am33xx_cpgmac0_hwmod,
+	.addr		= am33xx_cpsw_sl2_addr_space,
+	.user		= OCP_USER_MPU,
+};
+
+struct omap_hwmod_addr_space am33xx_cpsw_cpdma_addr_space[] = {
+	/* cpsw cpdma */
+	{
+		.pa_start	= 0x4A100814,
+		.pa_end		= 0x4A100814 + SZ_32 - 1,
+		.flags		= ADDR_TYPE_RT,
+	},
+	{ }
+};
+
+struct omap_hwmod_ocp_if am33xx_l3_main__cpsw_cpdma = {
+	.master		= &am33xx_l3_main_hwmod,
+	.slave		= &am33xx_cpgmac0_hwmod,
+	.addr		= am33xx_cpsw_cpdma_addr_space,
+	.user		= OCP_USER_MPU,
+};
+
 static struct omap_hwmod_ocp_if *am33xx_cpgmac0_slaves[] = {
 	&am33xx_l3_main__cpgmac0,
+	&am33xx_l3_main__cpsw_sl1,
+	&am33xx_l3_main__cpsw_sl2,
+	&am33xx_l3_main__cpsw_cpdma,
 };
 
 static struct omap_hwmod_irq_info am33xx_cpgmac0_irqs[] = {
@@ -510,7 +632,7 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod = {
 	.slaves		= am33xx_cpgmac0_slaves,
 	.slaves_cnt	= ARRAY_SIZE(am33xx_cpgmac0_slaves),
 	.flags		= (HWMOD_SWSUP_SIDLE | HWMOD_SWSUP_MSTANDBY |
-				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
+				HWMOD_SWSUP_RESET_BEFORE_IDLE),
 };
 
 /* mdio class */
diff --git a/arch/arm/plat-omap/include/plat/omap_hwmod.h b/arch/arm/plat-omap/include/plat/omap_hwmod.h
index b210f8c..424d085 100644
--- a/arch/arm/plat-omap/include/plat/omap_hwmod.h
+++ b/arch/arm/plat-omap/include/plat/omap_hwmod.h
@@ -333,6 +333,7 @@ struct omap_hwmod_sysc_fields {
  * @rev_offs: IP block revision register offset (from module base addr)
  * @sysc_offs: OCP_SYSCONFIG register offset (from module base addr)
  * @syss_offs: OCP_SYSSTATUS register offset (from module base addr)
+ * @rst_offs: OCP_SOFTRST register offset (from module base addr)
  * @srst_udelay: Delay needed after doing a softreset in usecs
  * @idlemodes: One or more of {SIDLE,MSTANDBY}_{OFF,FORCE,SMART}
  * @sysc_flags: SYS{C,S}_HAS* flags indicating SYSCONFIG bits supported
@@ -358,6 +359,7 @@ struct omap_hwmod_class_sysconfig {
 	u16 rev_offs;
 	u16 sysc_offs;
 	u16 syss_offs;
+	u16 rst_offs;
 	u16 sysc_flags;
 	struct omap_hwmod_sysc_fields *sysc_fields;
 	u8 srst_udelay;
@@ -429,6 +431,8 @@ struct omap_hwmod_omap4_prcm {
  *     in order to complete the reset. Optional clocks will be disabled
  *     again after the reset.
  * HWMOD_16BIT_REG: Module has 16bit registers
+ * HWMOD_SWSUP_RESET_BEFORE_IDLE: omap_hwmod code should assert the ocp_reset before
+ *     idling/disabling the module.
  */
 #define HWMOD_SWSUP_SIDLE			(1 << 0)
 #define HWMOD_SWSUP_MSTANDBY			(1 << 1)
@@ -439,6 +443,7 @@ struct omap_hwmod_omap4_prcm {
 #define HWMOD_NO_IDLEST				(1 << 6)
 #define HWMOD_CONTROL_OPT_CLKS_IN_RESET		(1 << 7)
 #define HWMOD_16BIT_REG				(1 << 8)
+#define HWMOD_SWSUP_RESET_BEFORE_IDLE		(1 << 9)
 
 /*
  * omap_hwmod._int_flags definitions
-- 
1.7.5.4

