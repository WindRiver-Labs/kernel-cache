From 44a12cf79a8a80826d0fe70f9b75135ef7ad2da8 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 16 Aug 2012 10:43:06 +0800
Subject: [PATCH 325/609] ethernet: cpsw: fix some cosmetic errors

This patch fixes some compiling errors to cater for the changes
of 3.4 kernel.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/ti/cpsw.c     |   12 +++---------
 drivers/net/ethernet/ti/cpsw_ale.c |   15 ++++++++-------
 include/linux/platform_data/cpsw.h |    9 +++++++++
 3 files changed, 20 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 57945c7..965a07f 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -731,7 +731,6 @@ DEVICE_ATTR(hw_stats, S_IRUGO, cpsw_hw_stats_show, NULL);
 #define PHY_CONFIG_REG	22
 static void cpsw_set_phy_config(struct cpsw_priv *priv, struct phy_device *phy)
 {
-	struct cpsw_platform_data *pdata = priv->pdev->dev.platform_data;
 	struct mii_bus *miibus;
 	int phy_addr = 0;
 	u16 val = 0;
@@ -747,11 +746,6 @@ static void cpsw_set_phy_config(struct cpsw_priv *priv, struct phy_device *phy)
 
 	phy_addr = phy->addr;
 
-	/* Disable 1 Gig mode support if it is not supported */
-	if (!pdata->gigabit_en)
-		phy->supported &= ~(SUPPORTED_1000baseT_Half |
-					SUPPORTED_1000baseT_Full);
-
 	/* Following lines enable gigbit advertisement capability even in case
 	 * the advertisement is not enabled by default
 	 */
@@ -887,7 +881,7 @@ static int cpsw_ndo_open(struct net_device *ndev)
 
 	reg = __raw_readl(&priv->regs->id_ver);
 
-	msg(info, ifup, "initializing cpsw version %d.%d (%d)\n",
+	cpsw_info(priv, ifup, "initializing cpsw version %d.%d (%d)\n",
 	    (reg >> 8 & 0x7), reg & 0xff, (reg >> 11) & 0x1f);
 
 	/* initialize host and slave ports */
@@ -936,7 +930,7 @@ static int cpsw_ndo_open(struct net_device *ndev)
 		 * continue even if we didn't manage to submit all
 		 * receive descs
 		 */
-		msg(info, ifup, "submitted %d rx descriptors\n", i);
+		cpsw_info(priv, ifup, "submitted %d rx descriptors\n", i);
 	}
 
 	/* Enable Interrupt pacing if configured */
@@ -980,7 +974,7 @@ static int cpsw_ndo_stop(struct net_device *ndev)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
 
-	msg(info, ifdown, "shutting down cpsw device\n");
+	cpsw_info(priv, ifdown, "shutting down cpsw device\n");
 
 	netif_stop_queue(priv->ndev);
 	napi_disable(&priv->napi);
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index a06a6c6..c62691e 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -27,6 +27,9 @@
 #include "cpsw_ale.h"
 
 #define BITMASK(bits)		(BIT(bits) - 1)
+#define ADDR_FMT_STR		"%02x:%02x:%02x:%02x:%02x:%02x"
+#define ADDR_FMT_ARGS(addr)	(addr)[0], (addr)[1], (addr)[2], \
+				(addr)[3], (addr)[4], (addr)[5]
 #define ALE_ENTRY_BITS		68
 #define ALE_ENTRY_WORDS	DIV_ROUND_UP(ALE_ENTRY_BITS, 32)
 
@@ -176,7 +179,7 @@ int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid)
 	u32 ale_entry[ALE_ENTRY_WORDS];
 	int type, idx;
 
-	for (idx = 0; idx < ale->ale_entries; idx++) {
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
 		cpsw_ale_read(ale, idx, ale_entry);
 		type = cpsw_ale_get_entry_type(ale_entry);
 		if (type != ALE_TYPE_VLAN)
@@ -243,7 +246,7 @@ int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask)
 	u32 ale_entry[ALE_ENTRY_WORDS];
 	int ret, idx;
 
-	for (idx = 0; idx < ale->ale_entries; idx++) {
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
 		cpsw_ale_read(ale, idx, ale_entry);
 		ret = cpsw_ale_get_entry_type(ale_entry);
 		if (ret != ALE_TYPE_ADDR && ret != ALE_TYPE_VLAN_ADDR)
@@ -402,7 +405,7 @@ int cpsw_ale_dump(struct cpsw_ale *ale, int index, char *buf, int len)
 		outlen += cpsw_ale_dump_entry(index, ale_entry,
 				buf + outlen, len - outlen);
 	} else {
-		for (idx = 0; idx < ale->ale_entries; idx++) {
+		for (idx = 0; idx < ale->params.ale_entries; idx++) {
 			cpsw_ale_read(ale, idx, ale_entry);
 			outlen += cpsw_ale_dump_entry(idx, ale_entry,
 					buf + outlen, len - outlen);
@@ -513,10 +516,8 @@ int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask)
 		return -EINVAL;
 
 	cpsw_ale_read(ale, idx, ale_entry);
-	mask = cpsw_ale_get_port_mask(ale_entry);
-	port_mask = mask & ~port_mask;
 
-	if (port_mask == BIT(ale->ale_ports))
+	if (port_mask)
 		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
 	else
 		cpsw_ale_set_port_mask(ale_entry, port_mask);
@@ -652,7 +653,7 @@ int cpsw_ale_vlan_del_mcast(struct cpsw_ale *ale, u8 *addr,
 				int port_mask, u16 vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
-	int idx, mask;
+	int idx;
 
 	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx < 0)
diff --git a/include/linux/platform_data/cpsw.h b/include/linux/platform_data/cpsw.h
index 16a0150..011b2eb 100644
--- a/include/linux/platform_data/cpsw.h
+++ b/include/linux/platform_data/cpsw.h
@@ -17,6 +17,11 @@
 
 #include <linux/if_ether.h>
 
+enum {
+	CPSW_VERSION_1 = 0,    /* TI8148 */
+	CPSW_VERSION_2,        /* AM33XX */
+};
+
 struct cpsw_slave_data {
 	u32		slave_reg_ofs;
 	u32		sliver_reg_ofs;
@@ -51,6 +56,10 @@ struct cpsw_platform_data {
 	u8	version;
 	u32	default_vlan; /* Default VLAN for Untagged packet handling*/
 
+	u8      mac_addr[ETH_ALEN];
+	void    (*phy_control)(bool enabled);
+	u32	rmii_en; /* Is RMII mode capable AND enabled */
+
 	u32	rx_descs;	/* Number of Rx Descriptios */
 
 	u32	mac_control;	/* Mac control register */
-- 
1.7.5.4

