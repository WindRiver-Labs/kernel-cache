From 9a5c9ea505fb328b56e71b904bddbd528a9466f3 Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Wed, 29 Feb 2012 18:11:56 +0530
Subject: [PATCH 166/609] ARM: OMAP2+: nand: Acquire CS in gpmc_nand_init

Original commit: 44b0b076aaf275482a6ad1a53c5ad3cf18739c23

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Prerequisite to merging different board nand functions to one

Signed-off-by: Afzal Mohammed <afzal@ti.com>
---
 arch/arm/mach-omap2/common-board-devices.c |   37 ++++-----------------------
 arch/arm/mach-omap2/gpmc-nand.c            |   23 +++++++++++++++++
 2 files changed, 29 insertions(+), 31 deletions(-)

diff --git a/arch/arm/mach-omap2/common-board-devices.c b/arch/arm/mach-omap2/common-board-devices.c
index 719f62e..fff18ef 100644
--- a/arch/arm/mach-omap2/common-board-devices.c
+++ b/arch/arm/mach-omap2/common-board-devices.c
@@ -100,38 +100,13 @@ static struct omap_nand_platform_data nand_data;
 void __init omap_nand_flash_init(int options, struct mtd_partition *parts,
 				 int nr_parts)
 {
-	u8 cs = 0;
-	u8 nandcs = GPMC_CS_NUM + 1;
+	nand_data.cs = GPMC_CS_NUM + 1;
+	nand_data.parts = parts;
+	nand_data.nr_parts = nr_parts;
+	nand_data.devsize = options;
 
-	/* find out the chip-select on which NAND exists */
-	while (cs < GPMC_CS_NUM) {
-		u32 ret = 0;
-		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
-
-		if ((ret & 0xC00) == 0x800) {
-			printk(KERN_INFO "Found NAND on CS%d\n", cs);
-			if (nandcs > GPMC_CS_NUM)
-				nandcs = cs;
-		}
-		cs++;
-	}
-
-	if (nandcs > GPMC_CS_NUM) {
-		printk(KERN_INFO "NAND: Unable to find configuration "
-				 "in GPMC\n ");
-		return;
-	}
-
-	if (nandcs < GPMC_CS_NUM) {
-		nand_data.cs = nandcs;
-		nand_data.parts = parts;
-		nand_data.nr_parts = nr_parts;
-		nand_data.devsize = options;
-
-		printk(KERN_INFO "Registering NAND on CS%d\n", nandcs);
-		if (gpmc_nand_init(&nand_data) < 0)
-			printk(KERN_ERR "Unable to register NAND device\n");
-	}
+	if (gpmc_nand_init(&nand_data) < 0)
+		printk(KERN_ERR "Unable to register NAND device\n");
 }
 #else
 void __init omap_nand_flash_init(int options, struct mtd_partition *parts,
diff --git a/arch/arm/mach-omap2/gpmc-nand.c b/arch/arm/mach-omap2/gpmc-nand.c
index 386dec8..955e264 100644
--- a/arch/arm/mach-omap2/gpmc-nand.c
+++ b/arch/arm/mach-omap2/gpmc-nand.c
@@ -85,10 +85,33 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 int __init gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data)
 {
 	int err	= 0;
+	u8 cs = 0;
 	struct device *dev = &gpmc_nand_device.dev;
 
+	/* if cs not provided, find out the chip-select on which NAND exist */
+	if (gpmc_nand_data->cs > GPMC_CS_NUM)
+		while (cs < GPMC_CS_NUM) {
+			u32 ret = 0;
+			ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+			if ((ret & 0xC00) == 0x800) {
+				printk(KERN_INFO "Found NAND on CS%d\n", cs);
+				gpmc_nand_data->cs = cs;
+				break;
+			}
+			cs++;
+		}
+
+	if (gpmc_nand_data->cs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				 "in GPMC\n ");
+		return -ENODEV;
+	}
+
 	gpmc_nand_device.dev.platform_data = gpmc_nand_data;
 
+	printk(KERN_INFO "Registering NAND on CS%d\n", gpmc_nand_data->cs);
+
 	err = gpmc_cs_request(gpmc_nand_data->cs, NAND_IO_SIZE,
 				&gpmc_nand_data->phys_base);
 	if (err < 0) {
-- 
1.7.5.4

