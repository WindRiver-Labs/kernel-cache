From cc954efd5ec7b645082593323d292f684309f7af Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Thu, 15 Mar 2012 17:41:01 +0530
Subject: [PATCH 558/609] PWM: ehrpwm: Fix polarity polarity of PWM signal.

Original commit: e799249d2a9a52015f70e6437b29aecd10c53b84

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

While configuring duty percentage for eHRPWM, polarity is also
configured. On reset, counter value is zero. So, on configuring
polarity, eHRPWM line goes high as counter is zero. This results in 100%
duty cycle and starts eHRPWM even before calling pwm_start.

This patch fixes the same.

Also this patch moves ehrpwm_pwm_set_pol function definition to starting of the
file to avoid prototype declaration.

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 drivers/pwm/ehrpwm.c |   68 +++++++++++++++++++++++++-------------------------
 1 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/drivers/pwm/ehrpwm.c b/drivers/pwm/ehrpwm.c
index d37db52..8bbed87 100644
--- a/drivers/pwm/ehrpwm.c
+++ b/drivers/pwm/ehrpwm.c
@@ -897,6 +897,39 @@ inline int ehrpwm_reg_write(struct pwm_device *p, unsigned int reg,
 }
 EXPORT_SYMBOL(ehrpwm_reg_write);
 
+static int ehrpwm_pwm_set_pol(struct pwm_device *p)
+{
+	unsigned int act_ctrl_reg;
+	unsigned int cmp_reg;
+	unsigned int ctreqcmp_mask;
+	unsigned int ctreqcmp;
+	unsigned short val;
+	struct ehrpwm_pwm *ehrpwm = to_ehrpwm_pwm(p);
+	int chan;
+
+	chan = p - &ehrpwm->pwm[0];
+	if (!chan) {
+		act_ctrl_reg = AQCTLA;
+		cmp_reg = CMPA;
+		ctreqcmp_mask = ACTCTL_CAU_MASK;
+		ctreqcmp = 4;
+	} else {
+		act_ctrl_reg = AQCTLB;
+		cmp_reg = CMPB;
+		ctreqcmp_mask = ACTCTL_CBU_MASK;
+		ctreqcmp = 8;
+	}
+
+
+	pm_runtime_get_sync(ehrpwm->dev);
+	val = ((p->active_high ? ACTCTL_CTREQCMP_HIGH : ACTCTL_CTREQCMP_LOW)
+		 << ctreqcmp) | (p->active_high ? ACTCTL_CTREQZRO_LOW :
+			ACTCTL_CTREQZRO_HIGH);
+	ehrpwm_write(ehrpwm, act_ctrl_reg, val);
+	pm_runtime_put_sync(ehrpwm->dev);
+	return 0;
+}
+
 static int ehrpwm_pwm_start(struct pwm_device *p)
 {
 	struct ehrpwm_pwm *ehrpwm = to_ehrpwm_pwm(p);
@@ -913,6 +946,7 @@ static int ehrpwm_pwm_start(struct pwm_device *p)
 	/* For PWM clock should be enabled on start */
 	pm_runtime_get_sync(ehrpwm->dev);
 
+	ehrpwm_pwm_set_pol(p);
 	chan = p - &ehrpwm->pwm[0];
 	val = ehrpwm_read(ehrpwm, TBCTL);
 	val = (val & ~TBCTL_CTRMODE_MASK) | (TBCTL_CTRMOD_CTRUP |
@@ -970,39 +1004,6 @@ static int ehrpwm_pwm_stop(struct pwm_device *p)
 	return 0;
 }
 
-static int ehrpwm_pwm_set_pol(struct pwm_device *p)
-{
-	unsigned int act_ctrl_reg;
-	unsigned int cmp_reg;
-	unsigned int ctreqcmp_mask;
-	unsigned int ctreqcmp;
-	unsigned short val;
-	struct ehrpwm_pwm *ehrpwm = to_ehrpwm_pwm(p);
-	int chan;
-
-	chan = p - &ehrpwm->pwm[0];
-	if (!chan) {
-		act_ctrl_reg = AQCTLA;
-		cmp_reg = CMPA;
-		ctreqcmp_mask = ACTCTL_CAU_MASK;
-		ctreqcmp = 4;
-	} else {
-		act_ctrl_reg = AQCTLB;
-		cmp_reg = CMPB;
-		ctreqcmp_mask = ACTCTL_CBU_MASK;
-		ctreqcmp = 8;
-	}
-
-
-	pm_runtime_get_sync(ehrpwm->dev);
-	val = ((p->active_high ? ACTCTL_CTREQCMP_HIGH : ACTCTL_CTREQCMP_LOW)
-		 << ctreqcmp) | (p->active_high ? ACTCTL_CTREQZRO_LOW :
-			ACTCTL_CTREQZRO_HIGH);
-	ehrpwm_write(ehrpwm, act_ctrl_reg, val);
-	pm_runtime_put_sync(ehrpwm->dev);
-	return 0;
-}
-
 /*
  * Prescalar is used when the period value exceeds the maximum value
  * of the 16 bit period register. We always look for the minimum prescalar
@@ -1142,7 +1143,6 @@ static int ehrpwm_pwm_set_dty(struct pwm_device *p)
 			ehrpwm_write(ehrpwm, HRCNFG, 0x2);
 	}
 
-	ehrpwm_pwm_set_pol(p);
 	ehrpwm_write(ehrpwm, (chan ? CMPB : CMPA), duty_ticks);
 	pm_runtime_put_sync(ehrpwm->dev);
 	return ret;
-- 
1.7.5.4

