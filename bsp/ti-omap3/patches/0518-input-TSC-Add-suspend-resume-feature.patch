From 7511f8593d803248307875109e787c1a71aa62a5 Mon Sep 17 00:00:00 2001
From: "Patil, Rachna" <rachna@ti.com>
Date: Wed, 8 Aug 2012 14:35:49 +0800
Subject: [PATCH 518/609] input: TSC: Add suspend/resume feature

Original commit: 4afde49920efad6454f4c1b34c090330c4b8c7f6

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch adds support for suspend/resume feature in touchscreen.
Since touchscreen is in wakeup domain, it can be used to resume the
system.

Signed-off-by: Patil, Rachna <rachna@ti.com>
---
 drivers/input/touchscreen/ti_tscadc.c |   71 ++++++++++++++++++++------------
 1 files changed, 44 insertions(+), 27 deletions(-)

diff --git a/drivers/input/touchscreen/ti_tscadc.c b/drivers/input/touchscreen/ti_tscadc.c
index 2b49b80..6689892 100644
--- a/drivers/input/touchscreen/ti_tscadc.c
+++ b/drivers/input/touchscreen/ti_tscadc.c
@@ -26,11 +26,13 @@
 #include <linux/io.h>
 #include <linux/input/ti_tscadc.h>
 #include <linux/delay.h>
+#include <linux/pm_runtime.h>
 
 #define REG_IRQEOI		0x020
 #define REG_RAWIRQSTATUS	0x024
 #define REG_IRQSTATUS		0x028
 #define REG_IRQENABLE		0x02C
+#define REG_IRQCLR		0x030
 #define REG_IRQWAKEUP		0x034
 #define REG_CTRL		0x040
 #define REG_ADCFSM		0x044
@@ -52,9 +54,11 @@
 
 /*	Register Bitfields	*/
 #define IRQWKUP_ENB		BIT(0)
+#define IRQWKUP_DISABLE	0x00
 #define STPENB_STEPENB		0x7FFF
 #define IRQENB_FIFO1THRES	BIT(5)
 #define IRQENB_PENUP		BIT(9)
+#define IRQENB_HW_PEN	BIT(0)
 #define STEPCONFIG_MODE_HWSYNC	0x2
 #define STEPCONFIG_SAMPLES_AVG	(1 << 4)
 #define STEPCONFIG_XPP		(1 << 5)
@@ -92,12 +96,12 @@
 
 struct tscadc {
 	struct input_dev	*input;
-	struct clk		*tsc_ick;
-	void __iomem		*tsc_base;
-	unsigned int		irq;
 	unsigned int		wires;
 	unsigned int		x_plate_resistance;
 	bool			pen_down;
+	unsigned int		irq;
+	void __iomem		*tsc_base;
+	unsigned int		ctrl;
 };
 
 static unsigned int tscadc_readl(struct tscadc *ts, unsigned int reg)
@@ -357,6 +361,7 @@ static int __devinit tscadc_probe(struct platform_device *pdev)
 		err = -ENOMEM;
 		goto err_release_mem_region;
 	}
+	irqclr |= IRQENB_HW_PEN;
 
 	err = request_irq(ts_dev->irq, tscadc_irq,
 			  0, pdev->dev.driver->name, ts_dev);
@@ -365,12 +370,8 @@ static int __devinit tscadc_probe(struct platform_device *pdev)
 		goto err_unmap_regs;
 	}
 
-	ts_dev->tsc_ick = clk_get(&pdev->dev, "adc_tsc_ick");
-	if (IS_ERR(ts_dev->tsc_ick)) {
-		dev_err(&pdev->dev, "failed to get TSC ick\n");
-		goto err_free_irq;
-	}
-	clk_enable(ts_dev->tsc_ick);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
 
 	clk = clk_get(&pdev->dev, "adc_tsc_fck");
 	if (IS_ERR(clk)) {
@@ -390,9 +391,6 @@ static int __devinit tscadc_probe(struct platform_device *pdev)
 	/* CLKDIV needs to be configured to the value minus 1 */
 	tscadc_writel(ts_dev, REG_CLKDIV, clk_value - 1);
 
-	 /* Enable wake-up of the SoC using touchscreen */
-	tscadc_writel(ts_dev, REG_IRQWAKEUP, IRQWKUP_ENB);
-
 	ctrl = CNTRLREG_STEPCONFIGWRT |
 			CNTRLREG_TSCENB |
 			CNTRLREG_STEPID;
@@ -408,6 +406,7 @@ static int __devinit tscadc_probe(struct platform_device *pdev)
 		break;
 	}
 	tscadc_writel(ts_dev, REG_CTRL, ctrl);
+	ts_dev->ctrl = ctrl;
 
 	tscadc_idle_config(ts_dev);
 	tscadc_writel(ts_dev, REG_IRQENABLE, IRQENB_FIFO1THRES);
@@ -432,12 +431,12 @@ static int __devinit tscadc_probe(struct platform_device *pdev)
 	if (err)
 		goto err_disable_clk;
 
+	device_init_wakeup(&pdev->dev, true);
 	platform_set_drvdata(pdev, ts_dev);
 	return 0;
 
 err_disable_clk:
-	clk_disable(ts_dev->tsc_ick);
-	clk_put(ts_dev->tsc_ick);
+	pm_runtime_disable(&pdev->dev);
 err_free_irq:
 	free_irq(ts_dev->irq, ts_dev);
 err_unmap_regs:
@@ -463,11 +462,11 @@ static int __devexit tscadc_remove(struct platform_device *pdev)
 	iounmap(ts_dev->tsc_base);
 	release_mem_region(res->start, resource_size(res));
 
-	clk_disable(ts_dev->tsc_ick);
-	clk_put(ts_dev->tsc_ick);
+	pm_runtime_disable(&pdev->dev);
 
 	kfree(ts_dev);
 
+	device_init_wakeup(&pdev->dev, 0);
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
@@ -475,29 +474,47 @@ static int __devexit tscadc_remove(struct platform_device *pdev)
 static int tscadc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct tscadc *ts_dev = platform_get_drvdata(pdev);
-	unsigned int  status;
+	unsigned int idle;
 
-	status = tscadc_readl(ts_dev, REG_CTRL);
-	status &= ~(CNTRLREG_TSCSSENB);
-	tscadc_writel(ts_dev, REG_CTRL, status);
+	if (device_may_wakeup(&pdev->dev)) {
+		idle = tscadc_readl(ts_dev, REG_IRQENABLE);
+		tscadc_writel(ts_dev, REG_IRQENABLE,
+				(idle | IRQENB_HW_PEN));
+		tscadc_writel(ts_dev, REG_IRQWAKEUP, IRQWKUP_ENB);
+	}
 
-	clk_disable(ts_dev->tsc_ick);
-	clk_put(ts_dev->tsc_ick);
+	/* module disable */
+	idle = 0;
+	idle = tscadc_readl(ts_dev, REG_CTRL);
+	idle &= ~(CNTRLREG_TSCSSENB);
+	tscadc_writel(ts_dev, REG_CTRL, idle);
 
-	return 0;
+	pm_runtime_put_sync(&pdev->dev);
 
+	return 0;
 }
 
 static int tscadc_resume(struct platform_device *pdev)
 {
 	struct tscadc *ts_dev = platform_get_drvdata(pdev);
-	unsigned int  status;
+	unsigned int restore;
 
-	clk_enable(ts_dev->tsc_ick);
+	pm_runtime_get_sync(&pdev->dev);
 
-	status = tscadc_readl(ts_dev, REG_CTRL);
+	if (device_may_wakeup(&pdev->dev)) {
+		tscadc_writel(ts_dev, REG_IRQWAKEUP,
+				IRQWKUP_DISABLE);
+		tscadc_writel(ts_dev, REG_IRQCLR, IRQENB_HW_PEN);
+	}
+
+	/* context restore */
+	tscadc_writel(ts_dev, REG_CTRL, ts_dev->ctrl);
+	tsc_idle_config(ts_dev);
+	tsc_step_config(ts_dev);
+	tscadc_writel(ts_dev, REG_FIFO1THR, 6);
+	restore = tscadc_readl(ts_dev, REG_CTRL);
 	tscadc_writel(ts_dev, REG_CTRL,
-			(status | CNTRLREG_TSCSSENB));
+			(restore | CNTRLREG_TSCSSENB));
 
 	return 0;
 }
-- 
1.7.5.4

