From ff4da85321aea25892ed6220ed6220c4554bb89a Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Tue, 7 Aug 2012 14:26:01 +0800
Subject: [PATCH 319/609] ethernet: cpsw: Adding switch configuration via
 ioctl

Original commit: 854b1a866c643eb6e5ad9c59801aebc6b09b4d59

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

CPSW as a switch can be configured in various combination of ALE entry/packet
limit for controling packet flow between the ports
There is no standard interface for switch configuration in Linux, so it is
done via ioctl with SIOCSWITCHCONFIG command

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c    |  747 ++++++++++++++++++++++++++++++++++++-
 include/linux/Kbuild              |    1 +
 include/linux/net_switch_config.h |  120 ++++++
 include/linux/sockios.h           |    3 +
 net/core/dev.c                    |   10 +
 5 files changed, 879 insertions(+), 2 deletions(-)
 create mode 100644 include/linux/net_switch_config.h

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index e4ee227..69a11cd 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -30,6 +30,7 @@
 #include <linux/delay.h>
 #include <linux/pm_runtime.h>
 #include <linux/if_vlan.h>
+#include <linux/net_switch_config.h>
 
 #include <linux/platform_data/cpsw.h>
 
@@ -90,6 +91,13 @@ do {								\
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
 #define CPSW_PHY_SPEED		1000
 
+#define CPSW_PRIMAP(shift, priority)	(priority << (shift * 4))
+
+#define slave(priv, idx)	((priv)->slaves + idx)
+#define switchcmd(__cmd__)	((__cmd__)->cmd_data.switchcmd)
+#define portcmd(__cmd__)	((__cmd__)->cmd_data.portcmd)
+#define priocmd(__cmd__)	((__cmd__)->cmd_data.priocmd)
+
 /* CPSW control module masks */
 #define CPSW_INTPACEEN		(0x3 << 16)
 #define CPSW_INTPRESCALE_MASK	(0x7FF << 0)
@@ -228,6 +236,10 @@ struct cpsw_regs {
 	u32	stat_port_en;
 	u32	ptype;
 	u32	soft_idle;
+	u32	thru_rate;
+	u32	gap_thresh;
+	u32	tx_start_wds;
+	u32	flow_control;
 };
 
 struct cpsw_slave_regs {
@@ -344,6 +356,7 @@ struct cpsw_priv {
 	struct cpdma_chan		*txch, *rxch;
 	struct cpsw_ale			*ale;
 	u32				emac_port;
+	u8				port_state[3];
 	/* snapshot of IRQ numbers */
 	u32 irqs_table[4];
 	u32 num_irqs;
@@ -597,7 +610,7 @@ static void _cpsw_adjust_link(struct cpsw_slave *slave,
 
 		/* enable forwarding */
 		cpsw_ale_control_set(priv->ale, slave_port,
-				     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+			ALE_PORT_STATE, priv->port_state[slave_port]);
 
 		if (phy->speed == 1000)
 			mac_control |= BIT(7);	/* GIGABITEN	*/
@@ -797,6 +810,7 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 
 	cpsw_add_dual_emac_mode_default_ale_entries(priv, slave, slave_port);
 	cpsw_add_switch_mode_bcast_ale_entries(priv, slave_port);
+	priv->port_state[slave_port] = ALE_PORT_STATE_FORWARD;
 
 	slave->phy = phy_connect(priv->ndev, slave->data->phy_id,
 				 &cpsw_adjust_link, 0, slave->data->phy_if);
@@ -805,7 +819,7 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 			slave->data->phy_id, slave->slave_num);
 		slave->phy = NULL;
 	} else {
-		dev_info(priv->dev, "phy found : id is : 0x%x\n",
+		dev_info(priv->dev, "CPSW phy found : id is : 0x%x\n",
 			 slave->phy->phy_id);
 		cpsw_set_phy_config(priv, slave->phy);
 		phy_start(slave->phy);
@@ -1016,6 +1030,734 @@ fail:
 	return NETDEV_TX_BUSY;
 }
 
+#ifndef CONFIG_TI_CPSW_DUAL_EMAC
+/*
+ *  cpsw_set_priority_mapping
+ *    This function configures the packet priority handling on each port.
+ */
+static int cpsw_set_priority_mapping(struct cpsw_priv *priv, int port,
+	int rxpriority, int txpriority, int switchpriority)
+{
+	if (port == 0) {
+		writel(CPSW_PRIMAP(rxpriority, txpriority),
+			&priv->host_port_regs->cpdma_tx_pri_map);
+		writel(CPSW_PRIMAP(txpriority, switchpriority),
+			&priv->host_port_regs->cpdma_tx_pri_map);
+	} else {
+		/* Configure sliver priority mapping registers */
+		writel(CPSW_PRIMAP(rxpriority, txpriority),
+			&slave(priv, port-1)->sliver->rx_pri_map);
+		writel(CPSW_PRIMAP(txpriority, switchpriority),
+			&slave(priv, port-1)->sliver->rx_pri_map);
+	}
+	return 0;
+}
+
+/*
+ * cpsw_rate_limit_tx
+ * Limits the number of Tx packets on a port for a 100ms time period.
+ * Rate limit can be done either on Tx or Rx for all the ports due to
+ * hardware limitation
+ */
+static int cpsw_rate_limit_tx(struct cpsw_ale *ale, u32 enable, u32 port,
+				u32 addr_type, u32 limit)
+{
+	u32 type;
+
+	if (!enable) {
+		cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT, 0);
+		return 0;
+	}
+
+	/* ALE prescale is set for 100 ms time */
+	if (addr_type == ADDR_TYPE_BROADCAST)
+		type = ALE_PORT_BCAST_LIMIT;
+	else if (addr_type == ADDR_TYPE_MULTICAST)
+		type = ALE_PORT_MCAST_LIMIT;
+	else
+		return -EFAULT;
+
+	cpsw_ale_control_set(ale, port, type, limit);
+	/* Enable the bit for rate limiting transmission */
+	cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT_TX, 1);
+	cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT, 1);
+
+	return 0;
+}
+
+/*
+ * cpsw_rate_limit_rx
+ * Limits the number of Rx packets on a port for a 100ms time period.
+ * Rate limit can be done either on Tx or Rx for all the ports due to
+ * hardware limitation
+ */
+static int cpsw_rate_limit_rx(struct cpsw_ale *ale, u32 enable, u32 port,
+				u32 addr_type, u32 limit)
+{
+	u32 type;
+
+	if (!enable) {
+		cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT, 0);
+		return 0;
+	}
+
+	/* ALE prescale is set for 100 ms time */
+	if (addr_type == ADDR_TYPE_BROADCAST)
+		type = ALE_PORT_BCAST_LIMIT;
+	else if (addr_type == ADDR_TYPE_MULTICAST)
+		type = ALE_PORT_MCAST_LIMIT;
+	else
+		return -EFAULT;
+
+	cpsw_ale_control_set(ale, port, type, limit);
+	/* Disable the bit for rate limiting reception */
+	cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT_TX, 0);
+	cpsw_ale_control_set(ale, port, ALE_RATE_LIMIT, 1);
+
+	return 0;
+}
+
+int cpsw_rate_limit(struct cpsw_ale *ale, u32 enable, u32 direction, u32 port,
+			u32 packet_type, u32 limit)
+{
+
+	if (port == 0) {
+		/*
+		 * For host port transmit/receive terminlogy is inverse
+		 * of cpgmac port
+		 */
+		if (direction)
+			cpsw_rate_limit_rx(ale, enable, port,
+					packet_type, limit);
+		else
+			cpsw_rate_limit_tx(ale, enable, port,
+					packet_type, limit);
+	} else {
+		if (direction)
+			cpsw_rate_limit_tx(ale, enable, port,
+					packet_type, limit);
+		else
+			cpsw_rate_limit_rx(ale, enable, port,
+					packet_type, limit);
+	}
+	return 0;
+}
+
+static int cpsw_config_dump(struct cpsw_priv *priv, u8 *buf, u32 size)
+{
+	int vlan_aware = 0;
+	int out_len = 0;
+	u32 port_state;
+	char *port_state_str[] = {"disabled", "blocked", "learn", "forward"};
+
+	out_len += snprintf(buf, size, "Switch Configuarion\n");
+
+	vlan_aware = readl(&priv->regs->control) & CPSW_VLAN_AWARE;
+
+	out_len += snprintf(buf + out_len, size - out_len, "VLAN Aware Mode"
+			"                              :  %s\n",
+			(vlan_aware ? "Yes" : "No"));
+	out_len += snprintf(buf + out_len, size - out_len, "ALE VLAN Aware "
+			"Mode                          :  %s\n",
+			(cpsw_ale_control_get(priv->ale, priv->host_port,
+				ALE_VLAN_AWARE) ? "Yes" : "No"));
+	out_len += snprintf(buf + out_len, size - out_len, "Unknown VLAN "
+			"Members                         :  %u\n",
+			cpsw_ale_control_get(priv->ale, 0,
+				ALE_PORT_UNKNOWN_VLAN_MEMBER));
+	out_len += snprintf(buf + out_len, size - out_len, "Unknown Multicast"
+			" Flood Mask                 :  %u\n",
+			cpsw_ale_control_get(priv->ale, 0,
+				ALE_PORT_UNKNOWN_MCAST_FLOOD));
+	out_len += snprintf(buf + out_len, size - out_len, "Unknown Registered"
+			" Multicast Flood Mask      :  %u\n",
+			cpsw_ale_control_get(priv->ale, 0,
+				ALE_PORT_UNKNOWN_REG_MCAST_FLOOD));
+	out_len += snprintf(buf + out_len, size - out_len, "Unknown VLAN Force"
+			" Untagged Egress           :  %u\n",
+			cpsw_ale_control_get(priv->ale, 0,
+				ALE_PORT_UNTAGGED_EGRESS));
+
+	out_len += snprintf(buf + out_len, size - out_len,
+			"\nPort Configuration\n");
+	out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8s %-8s %-8s %s\n", "PORT", "PVID", "PRIORITY",
+			"STATE");
+	out_len += snprintf(buf + out_len, size - out_len,
+			"\t---------------------------------\n");
+
+	if (vlan_aware) {
+		int port_vlan;
+
+		port_state = cpsw_ale_control_get(priv->ale, 0, ALE_PORT_STATE);
+		port_vlan = readl(&priv->host_port_regs->port_vlan);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8u %-8u %s\n", 0,
+			port_vlan & 0xfff, (port_vlan > 13) & 0x7,
+			port_state_str[port_state]);
+
+		port_state = cpsw_ale_control_get(priv->ale, 1, ALE_PORT_STATE);
+		port_vlan = readl(&priv->slaves[0].regs->port_vlan);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8u %-8u %s\n", 1,
+			port_vlan & 0xfff, (port_vlan > 13) & 0x7,
+			port_state_str[port_state]);
+
+		port_state = cpsw_ale_control_get(priv->ale, 2, ALE_PORT_STATE);
+		port_vlan = readl(&priv->slaves[1].regs->port_vlan);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8u %-8u %s\n", 2,
+			port_vlan & 0xfff, (port_vlan > 13) & 0x7,
+			port_state_str[port_state]);
+	} else {
+		port_state = cpsw_ale_control_get(priv->ale, 0, ALE_PORT_STATE);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8s %-8s %s\n", 0,
+			"-", "-", port_state_str[port_state]);
+
+		port_state = cpsw_ale_control_get(priv->ale, 1, ALE_PORT_STATE);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8s %-8s %s\n", 1,
+			"-", "-", port_state_str[port_state]);
+
+		port_state = cpsw_ale_control_get(priv->ale, 2, ALE_PORT_STATE);
+		out_len += snprintf(buf + out_len, size - out_len,
+			"\t%-8u %-8s %-8s %s\n", 2,
+			"-", "-", port_state_str[port_state]);
+	}
+
+	return out_len;
+}
+
+static int cpsw_set_port_state(struct cpsw_priv *priv, int port,
+			int port_state)
+{
+	int ret = -EFAULT;
+	switch (port_state) {
+	case PORT_STATE_DISABLED:
+		priv->port_state[port] = ALE_PORT_STATE_DISABLE;
+		break;
+	case PORT_STATE_BLOCKED:
+		priv->port_state[port] = ALE_PORT_STATE_BLOCK;
+		break;
+	case PORT_STATE_LEARN:
+		priv->port_state[port] = ALE_PORT_STATE_LEARN;
+		break;
+	case PORT_STATE_FORWARD:
+		priv->port_state[port] = ALE_PORT_STATE_FORWARD;
+		break;
+	}
+	ret = cpsw_ale_control_set(priv->ale, port, ALE_PORT_STATE,
+			priv->port_state[port]);
+
+	return ret;
+}
+
+static int cpsw_switch_config_ioctl(struct net_device *ndev,
+		struct ifreq *ifrq, int cmd)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct net_switch_config *switch_config;
+	int ret = -EFAULT;
+
+	/*
+	* Only SIOCSWITCHCONFIG is used as cmd argument and hence, there is no
+	* switch statement required.
+	* Function calls are based on switch_config.cmd
+	*/
+	if (cmd != SIOCSWITCHCONFIG)
+		return ret;
+
+	switch_config = kzalloc(sizeof(struct net_switch_config), GFP_KERNEL);
+	if (copy_from_user(switch_config, (ifrq->ifr_data),
+			sizeof(struct net_switch_config)))
+		return ret;
+
+	switch (switch_config->cmd) {
+	case CONFIG_SWITCH_ADD_MULTICAST:
+		if ((switchcmd(switch_config).untag_port <= 3) &&
+				(switchcmd(switch_config).vid <= 4095) &&
+				(switchcmd(switch_config).mem_port > 0) &&
+				(switchcmd(switch_config).mem_port <= 7) &&
+				is_multicast_ether_addr(
+				switchcmd(switch_config).addr)) {
+			if (switchcmd(switch_config).vid == 0)
+				ret = cpsw_ale_add_mcast(priv->ale,
+					switchcmd(switch_config).addr,
+					switchcmd(switch_config).mem_port
+						<< priv->host_port,
+					switchcmd(switch_config).flag,
+					switchcmd(switch_config).untag_port);
+			else
+				ret = cpsw_ale_vlan_add_mcast(priv->ale,
+					switchcmd(switch_config).addr,
+					switchcmd(switch_config).mem_port
+						<< priv->host_port,
+					switchcmd(switch_config).vid,
+					switchcmd(switch_config).flag,
+					switchcmd(switch_config).untag_port);
+		} else {
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_ADD_UNICAST:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+				(switchcmd(switch_config).mem_port <= 2) &&
+				is_valid_ether_addr(
+					switchcmd(switch_config).addr)) {
+			if (switchcmd(switch_config).vid == 0)
+				ret = cpsw_ale_add_ucast(priv->ale,
+					switchcmd(switch_config).addr,
+					priv->host_port, 0);
+			else
+				ret = cpsw_ale_vlan_add_ucast(priv->ale,
+					switchcmd(switch_config).addr,
+					priv->host_port, 0,
+					switchcmd(switch_config).vid);
+		} else {
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_ADD_OUI:
+		if (!is_zero_ether_addr(switchcmd(switch_config).addr)) {
+			ret = cpsw_ale_add_oui(priv->ale,
+				switchcmd(switch_config).addr);
+		} else {
+			dev_err(priv->dev, "Invalid Switch config arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_FIND_ADDR:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+			!is_zero_ether_addr(switchcmd(switch_config).addr)) {
+			ret = cpsw_ale_match_addr(priv->ale,
+				switchcmd(switch_config).addr,
+				switchcmd(switch_config).vid);
+			if (ret >= 0) {
+				switch_config->ret_type = ret;
+				ret = copy_to_user(ifrq->ifr_data,
+					switch_config,
+					sizeof(struct net_switch_config)) ?
+					-EFAULT : 0;
+			}
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_DEL_MULTICAST:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+				is_multicast_ether_addr(
+				switchcmd(switch_config).addr)) {
+			if (switchcmd(switch_config).vid == 0)
+				ret = cpsw_ale_del_mcast(priv->ale,
+					switchcmd(switch_config).addr,
+					switchcmd(switch_config).mem_port
+						<< priv->host_port);
+			else
+				ret = cpsw_ale_vlan_del_mcast(priv->ale,
+					switchcmd(switch_config).addr,
+					switchcmd(switch_config).mem_port
+						<< priv->host_port,
+					switchcmd(switch_config).vid);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_DEL_UNICAST:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+			is_valid_ether_addr(switchcmd(switch_config).addr)) {
+			if (switchcmd(switch_config).vid == 0) {
+				if (!memcmp(switchcmd(switch_config).addr,
+						priv->mac_addr, 6)) {
+					ret = -EPERM;
+					break;
+				}
+				ret = cpsw_ale_del_ucast(priv->ale,
+					switchcmd(switch_config).addr, 0);
+			} else
+				ret = cpsw_ale_del_ucast(priv->ale,
+					switchcmd(switch_config).addr,
+					switchcmd(switch_config).vid);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_ADD_VLAN:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+				(switchcmd(switch_config).mem_port > 0) &&
+				(switchcmd(switch_config).mem_port <= 7)) {
+			ret = cpsw_ale_add_vlan(priv->ale,
+				switchcmd(switch_config).vid,
+				switchcmd(switch_config).mem_port
+					<< priv->host_port,
+				switchcmd(switch_config).untag_port,
+				switchcmd(switch_config).reg_multi,
+				switchcmd(switch_config).unreg_multi);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_FIND_VLAN:
+		if (switchcmd(switch_config).vid <= 4095) {
+			switch_config->ret_type = cpsw_ale_match_vlan(priv->ale,
+				switchcmd(switch_config).vid);
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_DEL_VLAN:
+		if ((switchcmd(switch_config).vid <= 4095) &&
+				(switchcmd(switch_config).mem_port <= 7)) {
+			ret = cpsw_ale_del_vlan(priv->ale,
+				switchcmd(switch_config).vid,
+				switchcmd(switch_config).mem_port
+				<< priv->host_port);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_SET_PORT_VLAN_CONFIG:
+	{
+		int port_vlan = switchcmd(switch_config).vid |
+				switchcmd(switch_config).prio_port << 13;
+
+		if ((switchcmd(switch_config).vid <= 4095) &&
+				(switchcmd(switch_config).port <= 2) &&
+				(switchcmd(switch_config).prio_port <= 7)) {
+			if (switchcmd(switch_config).CFI_port)
+				port_vlan |= (1 << 12);
+
+			if (switchcmd(switch_config).port == 0)
+				writel(port_vlan,
+					&priv->host_port_regs->port_vlan);
+			else if (switchcmd(switch_config).port == 1)
+				writel(port_vlan,
+					&(priv->slaves[0].regs->port_vlan));
+			else
+				writel(port_vlan,
+					&(priv->slaves[1].regs->port_vlan));
+			ret = 0;
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+	}
+
+	case CONFIG_SWITCH_TIMEOUT:
+		ret = cpsw_ale_set_ageout(priv->ale,
+			switchcmd(switch_config).ale_timeout);
+		break;
+
+	case CONFIG_SWITCH_DUMP:
+		ret = cpsw_ale_dump(priv->ale,
+			switchcmd(switch_config).aledump,
+			switch_config->cmd_data.buf, 4095);
+		if (ret)
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
+		break;
+
+	case CONFIG_SWITCH_SET_FLOW_CONTROL:
+		if (portcmd(switch_config).port <= 7) {
+			writel(portcmd(switch_config).port,
+				&priv->regs->flow_control);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_SET_PRIORITY_MAPPING:
+		if ((priocmd(switch_config).port <= 2) &&
+			(priocmd(switch_config).prio_rx <= 7) &&
+			(priocmd(switch_config).prio_tx <= 7) &&
+			(priocmd(switch_config).prio_switch <= 3)) {
+			ret = cpsw_set_priority_mapping(priv,
+				priocmd(switch_config).port,
+				priocmd(switch_config).prio_rx,
+				priocmd(switch_config).prio_tx,
+				priocmd(switch_config).prio_switch);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_PORT_STATISTICS_ENABLE:
+		if (portcmd(switch_config).port <= 7) {
+			writel(portcmd(switch_config).port,
+				&priv->regs->stat_port_en);
+			ret = 0;
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_CONFIG_DUMP:
+		cpsw_config_dump(priv, switch_config->cmd_data.buf, 4096);
+		ret = copy_to_user(ifrq->ifr_data, switch_config,
+			sizeof(struct net_switch_config)) ?
+			-EFAULT : 0;
+		break;
+
+	case CONFIG_SWITCH_RATELIMIT:
+		if ((portcmd(switch_config).port <= 2) &&
+				(portcmd(switch_config).enable == 0))
+			ret = cpsw_ale_control_set(priv->ale,
+				portcmd(switch_config).port,
+				ALE_RATE_LIMIT, 0);
+		else if ((portcmd(switch_config).port <= 2) &&
+				((portcmd(switch_config).addr_type
+					== ADDR_TYPE_BROADCAST) ||
+				(portcmd(switch_config).addr_type
+					== ADDR_TYPE_MULTICAST)) &&
+				(portcmd(switch_config).limit <= 255)) {
+			ret = cpsw_rate_limit(priv->ale,
+				portcmd(switch_config).enable,
+				portcmd(switch_config).direction,
+				portcmd(switch_config).port,
+				portcmd(switch_config).addr_type,
+				portcmd(switch_config).limit);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_VID_INGRESS_CHECK:
+		if (portcmd(switch_config).port <= 2) {
+			cpsw_ale_control_set(priv->ale,
+				portcmd(switch_config).port,
+				ALE_PORT_DROP_UNTAGGED, 1);
+			cpsw_ale_control_set(priv->ale,
+				portcmd(switch_config).port,
+				ALE_PORT_DROP_UNKNOWN_VLAN, 1);
+			ret = 0;
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_ADD_UNKNOWN_VLAN_INFO:
+		if ((portcmd(switch_config).port <= 7) &&
+				(portcmd(switch_config).
+					reg_multi_port_mask <= 7) &&
+				(portcmd(switch_config).
+					unknown_reg_multi_port_mask <= 7) &&
+				(portcmd(switch_config).
+					unknown_vlan_member <= 7)) {
+			cpsw_ale_control_set(priv->ale, 0,
+				ALE_PORT_UNTAGGED_EGRESS,
+				portcmd(switch_config).port);
+			cpsw_ale_control_set(priv->ale, 0,
+				ALE_PORT_UNKNOWN_REG_MCAST_FLOOD,
+				portcmd(switch_config).reg_multi_port_mask);
+			cpsw_ale_control_set(priv->ale, 0,
+				ALE_PORT_UNKNOWN_MCAST_FLOOD,
+				portcmd(switch_config).
+					unknown_reg_multi_port_mask);
+			cpsw_ale_control_set(priv->ale, 0,
+				ALE_PORT_UNKNOWN_VLAN_MEMBER,
+				portcmd(switch_config).unknown_vlan_member);
+			ret = 0;
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_802_1:
+	{
+		char addr_802_1[6] = {0x01, 0x80, 0xc2, 0x0, 0x0, 0x03};
+		if (portcmd(switch_config).enable)
+			ret = cpsw_ale_add_mcast(priv->ale,
+					addr_802_1, 0x7, 0, 0);
+		else
+			ret = cpsw_ale_add_mcast(priv->ale,
+					addr_802_1, 0x3, 0, 0);
+		break;
+	}
+
+	case CONFIG_SWITCH_MACAUTH:
+		ret = cpsw_ale_control_set(priv->ale, priv->host_port,
+			ALE_AUTH_ENABLE, 1);
+		break;
+
+	case CONFIG_SWITCH_SET_PORT_CONFIG:
+	{
+		struct ethtool_cmd ecmd;
+
+		if (portcmd(switch_config).port == 1)
+			if (priv->slaves[0].phy) {
+				ecmd.phy_address = priv->slaves[0].phy->addr;
+				ret = phy_ethtool_gset(priv->slaves[0].phy,
+						&ecmd);
+			} else {
+				dev_err(priv->dev, "Phy not Found\n");
+				ret = -EFAULT;
+				break;
+			}
+		else if (portcmd(switch_config).port == 2)
+			if (priv->slaves[1].phy) {
+				ecmd.phy_address = priv->slaves[1].phy->addr;
+				ret = phy_ethtool_gset(priv->slaves[1].phy,
+						&ecmd);
+			} else {
+				dev_err(priv->dev, "Phy not Found\n");
+				ret = -EFAULT;
+				break;
+			}
+		else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+			break;
+		}
+
+		if (((portcmd(switch_config).limit == 0) ||
+			(portcmd(switch_config).limit == 10) ||
+			(portcmd(switch_config).limit == 100) ||
+			(portcmd(switch_config).limit == 1000))) {
+
+			if (portcmd(switch_config).limit == 0)
+				ecmd.autoneg = AUTONEG_ENABLE;
+			else {
+				ecmd.autoneg = AUTONEG_DISABLE;
+				ecmd.speed =
+					portcmd(switch_config).limit;
+				if (portcmd(switch_config).direction
+						== 1)
+					ecmd.duplex = DUPLEX_FULL;
+				else
+					ecmd.duplex = DUPLEX_HALF;
+			}
+
+			if (portcmd(switch_config).port == 1)
+				ret = phy_ethtool_sset(priv->slaves[0].phy,
+					&ecmd);
+			else
+				ret = phy_ethtool_sset(priv->slaves[1].phy,
+					&ecmd);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+	}
+
+	case CONFIG_SWITCH_GET_PORT_CONFIG:
+	{
+		struct ethtool_cmd ecmd;
+
+		if (portcmd(switch_config).port == 1)
+			if (priv->slaves[0].phy) {
+				ecmd.phy_address = priv->slaves[0].phy->addr;
+				ret = phy_ethtool_gset(priv->slaves[0].phy,
+						&ecmd);
+			} else {
+				dev_err(priv->dev, "Phy not Found\n");
+				ret = -EFAULT;
+				break;
+			}
+		else if (portcmd(switch_config).port == 2)
+			if (priv->slaves[1].phy) {
+				ecmd.phy_address = priv->slaves[1].phy->addr;
+				ret = phy_ethtool_gset(priv->slaves[1].phy,
+						&ecmd);
+			} else {
+				dev_err(priv->dev, "Phy not Found\n");
+				ret = -EFAULT;
+				break;
+			}
+		else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+			break;
+		}
+
+		if (!ret) {
+			portcmd(switch_config).limit = ecmd.speed;
+			if (ecmd.duplex == DUPLEX_FULL)
+				portcmd(switch_config).direction = 1;
+			else
+				portcmd(switch_config).direction = 0;
+			ret = copy_to_user(ifrq->ifr_data, switch_config,
+				sizeof(struct net_switch_config)) ?
+				-EFAULT : 0;
+		}
+
+		break;
+	}
+
+	case CONFIG_SWITCH_PORT_STATE:
+		if (portcmd(switch_config).port <= 2) {
+			ret = cpsw_set_port_state(priv,
+				portcmd(switch_config).port,
+				portcmd(switch_config).port_state);
+		} else {
+			dev_err(priv->dev, "Invalid Arguments\n");
+			ret = -EFAULT;
+		}
+		break;
+
+	case CONFIG_SWITCH_RESET:
+		ret = cpsw_ndo_stop(ndev);
+		if (!ret)
+			ret = cpsw_ndo_open(ndev);
+		break;
+
+	default:
+		ret = -EOPNOTSUPP;
+	}
+
+	kfree(switch_config);
+	return ret;
+}
+
+#else
+#define cpsw_switch_config_ioctl(ndev, ifrq, cmd) (-EOPNOTSUPP)
+#endif /* CONFIG_TI_CPSW_DUAL_EMAC */
+
+static int cpsw_ndo_do_ioctl(struct net_device *ndev, struct ifreq *ifrq,
+		int cmd)
+{
+	if (!(netif_running(ndev)))
+		return -EINVAL;
+
+	switch (cmd) {
+
+	case SIOCSWITCHCONFIG:
+		return cpsw_switch_config_ioctl(ndev, ifrq, cmd);
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
 static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
 {
 	/*
@@ -1171,6 +1913,7 @@ static const struct net_device_ops cpsw_netdev_ops = {
 	.ndo_start_xmit		= cpsw_ndo_start_xmit,
 	.ndo_change_rx_flags	= cpsw_ndo_change_rx_flags,
 	.ndo_set_mac_address	= cpsw_ndo_set_mac_address,
+	.ndo_do_ioctl		= cpsw_ndo_do_ioctl,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_tx_timeout		= cpsw_ndo_tx_timeout,
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index 4a0796a..fbf25b7 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -264,6 +264,7 @@ header-y += neighbour.h
 header-y += net.h
 header-y += net_dropmon.h
 header-y += net_tstamp.h
+header-y += net_switch_config.h
 header-y += netdevice.h
 header-y += netfilter.h
 header-y += netfilter_arp.h
diff --git a/include/linux/net_switch_config.h b/include/linux/net_switch_config.h
new file mode 100644
index 0000000..6e4b8d7
--- /dev/null
+++ b/include/linux/net_switch_config.h
@@ -0,0 +1,120 @@
+/*
+ * Texas Instruments Ethernet Switch Driver
+ *
+ * Copyright (C) 2012 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * Userspace API for Switch Configuration
+ */
+
+#ifndef __NET_CONFIG_SWITCH_H__
+#define __NET_CONFIG_SWITCH_H__
+
+enum {
+	CONFIG_SWITCH_INVALID,
+	CONFIG_SWITCH_ADD_MULTICAST,
+	CONFIG_SWITCH_ADD_UNICAST,
+	CONFIG_SWITCH_ADD_OUI,
+	CONFIG_SWITCH_FIND_ADDR,
+	CONFIG_SWITCH_DEL_MULTICAST,
+	CONFIG_SWITCH_DEL_UNICAST,
+	CONFIG_SWITCH_ADD_VLAN,
+	CONFIG_SWITCH_FIND_VLAN,
+	CONFIG_SWITCH_DEL_VLAN,
+	CONFIG_SWITCH_SET_PORT_VLAN_CONFIG,
+	CONFIG_SWITCH_TIMEOUT,
+	CONFIG_SWITCH_DUMP,
+	CONFIG_SWITCH_SET_FLOW_CONTROL,
+	CONFIG_SWITCH_SET_PRIORITY_MAPPING,
+	CONFIG_SWITCH_PORT_STATISTICS_ENABLE,
+	CONFIG_SWITCH_CONFIG_DUMP,
+	CONFIG_SWITCH_RATELIMIT,
+	CONFIG_SWITCH_VID_INGRESS_CHECK,
+	CONFIG_SWITCH_ADD_UNKNOWN_VLAN_INFO,
+	CONFIG_SWITCH_802_1,
+	CONFIG_SWITCH_MACAUTH,
+	CONFIG_SWITCH_SET_PORT_CONFIG,
+	CONFIG_SWITCH_GET_PORT_CONFIG,
+	CONFIG_SWITCH_PORT_STATE,
+	CONFIG_SWITCH_RESET,
+};
+
+enum {
+	ADDR_TYPE_BROADCAST = 1,
+	ADDR_TYPE_MULTICAST,
+	ADDR_TYPE_UNICAST,
+};
+
+enum {
+	PORT_STATE_DISABLED = 0,
+	PORT_STATE_BLOCKED,
+	PORT_STATE_LEARN,
+	PORT_STATE_FORWARD,
+};
+
+struct net_switch_cmd {
+	unsigned int	port;
+	unsigned int	vid;		/* VLAN identifier */
+	unsigned int	prio_port;	/* port priority 0 -7 */
+	unsigned int	CFI_port;	/* port CFI  0 /1 */
+	unsigned int	mem_port;	/* port number 0 - 2 */
+	unsigned char	unreg_multi;	/* unreg multicast Egress Ports */
+	unsigned char	reg_multi;	/* register multicast Egress ports */
+	unsigned char	untag_port;	/* Untag ports */
+	unsigned char	addr[6];
+	unsigned int	flag;
+	unsigned int	blocked;
+	unsigned int	secure;
+	unsigned int	ageable;
+	unsigned int	ale_timeout;
+	unsigned char	aledump;	/* if 1 print ale table */
+};
+
+struct net_switch_port_cmd {
+	unsigned int	port;		/* Port number */
+	unsigned int	direction;	/* Tx -1 / Rx - 0 */
+	unsigned int	addr_type;	/* Address type BroadMulti/Uni cast */
+	unsigned int	limit;		/* multicast/broadcast limit */
+	unsigned int	vlan_ingress_check;
+	unsigned int	port_state;
+	unsigned int	vlan_port_mask;
+	unsigned char	drop_untagged;
+	unsigned char	enable;		/* 1-enable/0-Disable */
+	unsigned int	reg_multi_port_mask;
+	unsigned int	unknown_reg_multi_port_mask;
+	unsigned char	unknown_vlan_member;
+};
+
+struct net_switch_prio_cmd {
+	unsigned char port;
+	unsigned char prio_rx;
+	unsigned char prio_tx;
+	unsigned char prio_switch;
+	unsigned char hostRxCh;		/* packet with switch priority receive
+						on this channel */
+	unsigned char hostRxChSuper;	/* supervisory packet receive on
+						this channel */
+};
+
+struct net_switch_config {
+	unsigned int cmd;	/* API to be invoked by the kernel driver */
+	union {
+		struct net_switch_cmd switchcmd;
+		struct net_switch_port_cmd portcmd;
+		struct net_switch_prio_cmd priocmd;
+		char buf[4096];		/* Buffer for Ale Dump */
+	} cmd_data;
+	unsigned int ret_type;   /* Return  Success/Failure */
+};
+
+#endif /* __NET_CONFIG_SWITCH_H__*/
diff --git a/include/linux/sockios.h b/include/linux/sockios.h
index 7997a50..2e01634 100644
--- a/include/linux/sockios.h
+++ b/include/linux/sockios.h
@@ -127,6 +127,9 @@
 /* hardware time stamping: parameters in linux/net_tstamp.h */
 #define SIOCSHWTSTAMP   0x89b0
 
+/* Switch config calls: parameters in linux/net_switch_config.h */
+#define SIOCSWITCHCONFIG    0x89c0
+
 /* Device private ioctl calls */
 
 /*
diff --git a/net/core/dev.c b/net/core/dev.c
index 7b6fe70..915d3d0 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -5020,6 +5020,7 @@ static int dev_ifsioc(struct net *net, struct ifreq *ifr, unsigned int cmd)
 		    cmd == SIOCBRADDIF ||
 		    cmd == SIOCBRDELIF ||
 		    cmd == SIOCSHWTSTAMP ||
+		    cmd == SIOCSWITCHCONFIG ||
 		    cmd == SIOCWANDEV) {
 			err = -EOPNOTSUPP;
 			if (ops->ndo_do_ioctl) {
@@ -5195,6 +5196,15 @@ int dev_ioctl(struct net *net, unsigned int cmd, void __user *arg)
 	case SIOCSIFLINK:
 		return -ENOTTY;
 
+	case SIOCSWITCHCONFIG:
+		dev_load(net, ifr.ifr_name);
+		rtnl_lock();
+		ret = dev_ifsioc(net, &ifr, cmd);
+		rtnl_unlock();
+		if (!ret && copy_to_user(arg, &ifr, sizeof(struct ifreq)))
+			ret = -EFAULT;
+		return ret;
+
 	/*
 	 *	Unknown or private ioctl.
 	 */
-- 
1.7.5.4

