From 774a3550b523e4c9a66d0cd647925c21f7d7cfe8 Mon Sep 17 00:00:00 2001
From: Chandan Nath <chandan.nath@ti.com>
Date: Thu, 12 Jul 2012 05:31:52 +0800
Subject: [PATCH 308/609] ethernet: Implement CPSW interrupt pacing
 functionality

Original commit: 7124162daf8e74713193d9669dd59ae9c50b47f6

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

CPSW module includes an interrupt pacing block that can
be programmed to throttle the rate at which interrupts are
generated. This patch implements interrupt pacing logic that can
be controlled through the ethtool interface(only rx_coalesce_usecs
param is honored)

Signed-off-by: Chandan Nath <chandan.nath@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c |  234 ++++++++++++++++++++++++++++++++++------
 1 files changed, 200 insertions(+), 34 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 9245492..f7a0a73 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -31,6 +31,7 @@
 
 #include <linux/platform_data/cpsw.h>
 
+#include <plat/dmtimer.h>
 #include "cpsw_ale.h"
 #include "davinci_cpdma.h"
 
@@ -73,31 +74,28 @@ do {								\
 
 #define CPDMA_RXTHRESH		0x0c0
 #define CPDMA_RXFREE		0x0e0
-#define CPDMA_TXHDP		0x00
-#define CPDMA_RXHDP		0x20
-#define CPDMA_TXCP		0x40
-#define CPDMA_RXCP		0x60
-
-#define cpsw_dma_regs(base, offset)		\
-	(void __iomem *)((base) + (offset))
-#define cpsw_dma_rxthresh(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXTHRESH)
-#define cpsw_dma_rxfree(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXFREE)
-#define cpsw_dma_txhdp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_TXHDP)
-#define cpsw_dma_rxhdp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXHDP)
-#define cpsw_dma_txcp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_TXCP)
-#define cpsw_dma_rxcp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXCP)
+#define CPDMA_TXHDP_VER1	0x100
+#define CPDMA_TXHDP_VER2	0x200
+#define CPDMA_RXHDP_VER1	0x120
+#define CPDMA_RXHDP_VER2	0x220
+#define CPDMA_TXCP_VER1		0x140
+#define CPDMA_TXCP_VER2		0x240
+#define CPDMA_RXCP_VER1		0x160
+#define CPDMA_RXCP_VER2		0x260
 
 #define CPSW_POLL_WEIGHT	64
 #define CPSW_MIN_PACKET_SIZE	60
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
 #define CPSW_PHY_SPEED		1000
 
+/* CPSW control module masks */
+#define CPSW_INTPACEEN		(0x3 << 16)
+#define CPSW_INTPRESCALE_MASK	(0x7FF << 0)
+#define CPSW_CMINTMAX_CNT	63
+#define CPSW_CMINTMIN_CNT	2
+#define CPSW_CMINTMAX_INTVL	(1000 / CPSW_CMINTMIN_CNT)
+#define CPSW_CMINTMIN_INTVL	((1000 / CPSW_CMINTMAX_CNT) + 1)
+
 #define RX_PRIORITY_MAPPING	0x76543210
 #define TX_PRIORITY_MAPPING	0x33221100
 #define CPDMA_TX_PRIORITY_MAP	0x76543210
@@ -115,6 +113,19 @@ do {								\
 			disable_irq_nosync(priv->irqs_table[i]); \
 	} while (0);
 
+#define CPSW_CPDMA_EOI_REG	0x894
+#define CPSW_TIMER_MASK		0xA0908
+#define CPSW_TIMER_CAP_REG	0xFD0
+#define CPSW_RX_TIMER_REQ	5
+#define CPSW_TX_TIMER_REQ	6
+
+struct omap_dm_timer *dmtimer_rx;
+struct omap_dm_timer *dmtimer_tx;
+
+extern u32 omap_ctrl_readl(u16 offset);
+extern void omap_ctrl_writel(u32 val, u16 offset);
+
+
 static int debug_level;
 module_param(debug_level, int, 0);
 MODULE_PARM_DESC(debug_level, "cpsw debug level (NETIF_MSG bits)");
@@ -136,6 +147,14 @@ struct cpsw_ss_regs {
 	u32	rx_en;
 	u32	tx_en;
 	u32	misc_en;
+	u32	mem_allign1[8];
+	u32	rx_thresh_stat;
+	u32	rx_stat;
+	u32	tx_stat;
+	u32	misc_stat;
+	u32	mem_allign2[8];
+	u32	rx_imax;
+	u32	tx_imax;
 };
 
 struct cpsw_regs {
@@ -244,6 +263,8 @@ struct cpsw_priv {
 	struct cpsw_hw_stats __iomem	*hw_stats;
 	struct cpsw_host_regs __iomem	*host_port_regs;
 	u32				msg_enable;
+	u32				coal_intvl;
+	u32				bus_freq_mhz;
 	struct net_device_stats		stats;
 	int				rx_packet_max;
 	int				host_port;
@@ -266,6 +287,9 @@ struct cpsw_priv {
 			(func)((priv)->slaves + idx, ##arg);	\
 	} while (0)
 
+static int cpsw_set_coalesce(struct net_device *ndev,
+			struct ethtool_coalesce *coal);
+
 static void cpsw_intr_enable(struct cpsw_priv *priv)
 {
 	__raw_writel(0xFF, &priv->ss_regs->tx_en);
@@ -336,6 +360,13 @@ void cpsw_rx_handler(void *token, int len, int status)
 	WARN_ON(ret < 0);
 }
 
+static void set_cpsw_dmtimer_clear(void)
+{
+	omap_dm_timer_write_status(dmtimer_rx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_write_status(dmtimer_tx, OMAP_TIMER_INT_CAPTURE);
+	return;
+}
+
 static irqreturn_t cpsw_interrupt(int irq, void *dev_id)
 {
 	struct cpsw_priv *priv = dev_id;
@@ -370,8 +401,9 @@ static int cpsw_poll(struct napi_struct *napi, int budget)
 
 	if (num_rx < budget) {
 		napi_complete(napi);
-		cpsw_intr_enable(priv);
 		cpdma_ctlr_eoi(priv->dma);
+		set_cpsw_dmtimer_clear();
+		cpsw_intr_enable(priv);
 		cpsw_enable_irq(priv);
 	}
 
@@ -709,6 +741,24 @@ static int cpsw_ndo_open(struct net_device *ndev)
 	/* continue even if we didn't manage to submit all receive descs */
 	cpsw_info(priv, ifup, "submitted %d rx descriptors\n", i);
 
+	/* Enable Interrupt pacing if configured */
+	if (priv->coal_intvl != 0) {
+		struct ethtool_coalesce coal;
+
+		coal.rx_coalesce_usecs = (priv->coal_intvl << 4);
+		cpsw_set_coalesce(ndev, &coal);
+	}
+
+	/* Enable Timer for capturing cpsw rx interrupts */
+	omap_dm_timer_set_int_enable(dmtimer_rx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(dmtimer_rx, 1, 0, 0);
+	omap_dm_timer_enable(dmtimer_rx);
+
+	/* Enable Timer for capturing cpsw tx interrupts */
+	omap_dm_timer_set_int_enable(dmtimer_tx, OMAP_TIMER_INT_CAPTURE);
+	omap_dm_timer_set_capture(dmtimer_tx, 1, 0, 0);
+	omap_dm_timer_enable(dmtimer_tx);
+
 	cpdma_ctlr_start(priv->dma);
 	cpsw_intr_enable(priv);
 	napi_enable(&priv->napi);
@@ -889,11 +939,93 @@ static void cpsw_set_msglevel(struct net_device *ndev, u32 value)
 	priv->msg_enable = value;
 }
 
+/**
+ * cpsw_get_coalesce : Get interrupt coalesce settings for this device
+ * @ndev : CPSW network adapter
+ * @coal : ethtool coalesce settings structure
+ *
+ * Fetch the current interrupt coalesce settings
+ *
+ */
+static int cpsw_get_coalesce(struct net_device *ndev,
+				struct ethtool_coalesce *coal)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+
+	coal->rx_coalesce_usecs = priv->coal_intvl;
+	return 0;
+}
+
+/**
+ * cpsw_set_coalesce : Set interrupt coalesce settings for this device
+ * @ndev : CPSW network adapter
+ * @coal : ethtool coalesce settings structure
+ *
+ * Set interrupt coalesce parameters
+ *
+ */
+static int cpsw_set_coalesce(struct net_device *ndev,
+				struct ethtool_coalesce *coal)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	u32 int_ctrl;
+	u32 num_interrupts = 0;
+	u32 prescale = 0;
+	u32 addnl_dvdr = 1;
+	u32 coal_intvl = 0;
+
+	if (!coal->rx_coalesce_usecs)
+		return -EINVAL;
+
+	coal_intvl = coal->rx_coalesce_usecs;
+
+	int_ctrl =  __raw_readl(&priv->ss_regs->int_control);
+	prescale = priv->bus_freq_mhz * 4;
+
+	if (coal_intvl < CPSW_CMINTMIN_INTVL)
+		coal_intvl = CPSW_CMINTMIN_INTVL;
+
+	if (coal_intvl > CPSW_CMINTMAX_INTVL) {
+		/*
+		 * Interrupt pacer works with 4us Pulse, we can
+		 * throttle further by dilating the 4us pulse.
+		 */
+		addnl_dvdr = CPSW_INTPRESCALE_MASK / prescale;
+
+		if (addnl_dvdr > 1) {
+			prescale *= addnl_dvdr;
+			if (coal_intvl > (CPSW_CMINTMAX_INTVL * addnl_dvdr))
+				coal_intvl = (CPSW_CMINTMAX_INTVL
+						* addnl_dvdr);
+		} else {
+			addnl_dvdr = 1;
+			coal_intvl = CPSW_CMINTMAX_INTVL;
+		}
+	}
+
+	num_interrupts = (1000 * addnl_dvdr) / coal_intvl;
+
+	int_ctrl |= CPSW_INTPACEEN;
+	int_ctrl &= (~CPSW_INTPRESCALE_MASK);
+	int_ctrl |= (prescale & CPSW_INTPRESCALE_MASK);
+	__raw_writel(int_ctrl, &priv->ss_regs->int_control);
+
+	__raw_writel(num_interrupts, &priv->ss_regs->rx_imax);
+	__raw_writel(num_interrupts, &priv->ss_regs->tx_imax);
+
+	printk(KERN_INFO"Set coalesce to %d usecs.\n", coal_intvl);
+	priv->coal_intvl = coal_intvl;
+
+	return 0;
+}
+
 static const struct ethtool_ops cpsw_ethtool_ops = {
 	.get_drvinfo	= cpsw_get_drvinfo,
 	.get_msglevel	= cpsw_get_msglevel,
 	.set_msglevel	= cpsw_set_msglevel,
 	.get_link	= ethtool_op_get_link,
+	.get_coalesce	= cpsw_get_coalesce,
+	.set_coalesce	= cpsw_set_coalesce,
 };
 
 static void cpsw_slave_init(struct cpsw_slave *slave, struct cpsw_priv *priv)
@@ -964,6 +1096,9 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 		ret = -EBUSY;
 	}
 
+	priv->coal_intvl = 0;
+	priv->bus_freq_mhz = clk_get_rate(priv->clk) / 1000000;
+
 	priv->cpsw_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!priv->cpsw_res) {
 		dev_err(priv->dev, "error getting i/o resource\n");
@@ -1010,23 +1145,50 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	priv->ss_regs = regs;
 
 	for_each_slave(priv, cpsw_slave_init, priv);
+	omap_ctrl_writel(CPSW_TIMER_MASK, CPSW_TIMER_CAP_REG);
+
+	dmtimer_rx = omap_dm_timer_request_specific(CPSW_RX_TIMER_REQ);
+	if (!dmtimer_rx) {
+		dev_err(priv->dev, "Error getting Rx Timer resource\n");
+		ret = -ENODEV;
+		goto clean_iomap_ret;
+	}
+
+	dmtimer_tx = omap_dm_timer_request_specific(CPSW_TX_TIMER_REQ);
+	if (!dmtimer_tx) {
+		dev_err(priv->dev, "Error getting Tx Timer resource\n");
+		ret = -ENODEV;
+		goto clean_timer_rx_ret;
+	}
 
 	memset(&dma_params, 0, sizeof(dma_params));
 	dma_params.dev		= &pdev->dev;
-	dma_params.dmaregs	= cpsw_dma_regs((u32)priv->regs,
+	dma_params.dmaregs		= (void __iomem *)(((u32)priv->regs) +
 						data->cpdma_reg_ofs);
-	dma_params.rxthresh	= cpsw_dma_rxthresh((u32)priv->regs,
-						    data->cpdma_reg_ofs);
-	dma_params.rxfree	= cpsw_dma_rxfree((u32)priv->regs,
-						  data->cpdma_reg_ofs);
-	dma_params.txhdp	= cpsw_dma_txhdp((u32)priv->regs,
-						 data->cpdma_sram_ofs);
-	dma_params.rxhdp	= cpsw_dma_rxhdp((u32)priv->regs,
-						 data->cpdma_sram_ofs);
-	dma_params.txcp		= cpsw_dma_txcp((u32)priv->regs,
-						data->cpdma_sram_ofs);
-	dma_params.rxcp		= cpsw_dma_rxcp((u32)priv->regs,
-						data->cpdma_sram_ofs);
+	dma_params.rxthresh		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXTHRESH);
+	dma_params.rxfree		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXFREE);
+
+	if (data->version == CPSW_VERSION_2) {
+		dma_params.txhdp	= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_TXHDP_VER2);
+		dma_params.rxhdp	= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXHDP_VER2);
+		dma_params.txcp		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_TXCP_VER2);
+		dma_params.rxcp		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXCP_VER2);
+	} else {
+		dma_params.txhdp	= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_TXHDP_VER1);
+		dma_params.rxhdp	= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXHDP_VER1);
+		dma_params.txcp		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_TXCP_VER1);
+		dma_params.rxcp		= (void __iomem *)(((u32)priv->regs) +
+					data->cpdma_reg_ofs + CPDMA_RXCP_VER1);
+	}
 
 	dma_params.num_chan		= data->channels;
 	dma_params.has_soft_reset	= true;
@@ -1043,7 +1205,7 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	if (!priv->dma) {
 		dev_err(priv->dev, "error initializing dma\n");
 		ret = -ENOMEM;
-		goto clean_iomap_ret;
+		goto clean_timer_ret;
 	}
 
 	priv->txch = cpdma_chan_create(priv->dma, tx_chan_num(0),
@@ -1120,6 +1282,10 @@ clean_dma_ret:
 	cpdma_chan_destroy(priv->txch);
 	cpdma_chan_destroy(priv->rxch);
 	cpdma_ctlr_destroy(priv->dma);
+clean_timer_ret:
+	omap_dm_timer_free(dmtimer_tx);
+clean_timer_rx_ret:
+	omap_dm_timer_free(dmtimer_rx);
 clean_iomap_ret:
 	iounmap(priv->regs);
 clean_cpsw_ss_iores_ret:
-- 
1.7.5.4

