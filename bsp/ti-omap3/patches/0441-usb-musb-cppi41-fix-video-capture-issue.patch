From e7e886d1a19be3e4bb3632d331f6a20a67a7f66c Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Tue, 18 Sep 2012 09:01:08 +0800
Subject: [PATCH 441/609] usb: musb: cppi41: fix video capture issue

Original commit: c31e70e7a38d57a710d15562ed3fe517df2cef01

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Fixes video capture issue with Logitech-prp9000 for 640X460 resolution.
The issues was with cppi41 dma programming for transparent mode with
high bandwidth endpoints where it was not taking care of multiple
maxpacket size data within one micro frame.

Added hb_mult to cppi41_channel structure to take care of such scenarios.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
---
 drivers/usb/musb/cppi41_dma.c |    6 ++++--
 drivers/usb/musb/musb_host.c  |   16 +++++++++-------
 2 files changed, 13 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index dc73253..235de41 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -100,6 +100,7 @@ struct cppi41_channel {
 	u8  zlp_queued;
 	u8  inf_mode;
 	u8  tx_complete;
+	u8  hb_mult;
 	u8  count;
 };
 
@@ -799,7 +800,7 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 		} else {
 			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
 			cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
-			max_rx_transfer_size = rx_ch->pkt_size;
+			max_rx_transfer_size = rx_ch->hb_mult * rx_ch->pkt_size;
 		}
 	}
 
@@ -914,7 +915,8 @@ static int cppi41_channel_program(struct dma_channel *channel,	u16 maxpacket,
 	/* Set the transfer parameters, then queue up the first segment */
 	cppi_ch->start_addr = dma_addr;
 	cppi_ch->curr_offset = 0;
-	cppi_ch->pkt_size = maxpacket;
+	cppi_ch->hb_mult = (maxpacket >> 11) & 0x03;
+	cppi_ch->pkt_size = maxpacket & 0x7ff;
 	cppi_ch->length = length;
 	cppi_ch->transfer_mode = mode;
 	cppi_ch->zlp_queued = 0;
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 6426b57..443e11d 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -710,7 +710,8 @@ static bool musb_tx_dma_program(struct dma_controller *dma,
 	 */
 	wmb();
 
-	if (!dma->channel_program(channel, pkt_size, mode,
+	if (!dma->channel_program(channel, pkt_size |
+			(qh->hb_mult << 11), mode,
 			urb->transfer_dma + offset, length)) {
 		dma->channel_release(channel);
 		hw_ep->tx_channel = NULL;
@@ -835,9 +836,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 					| ((hw_ep->max_packet_sz_tx /
 						packet_sz) - 1) << 11);
 			else
-				musb_writew(epio, MUSB_TXMAXP,
-						qh->maxpacket |
-						((qh->hb_mult - 1) << 11));
+				musb_writew(epio, MUSB_TXMAXP, qh->maxpacket |
+						(qh->hb_mult << 11));
 			musb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);
 		} else {
 			musb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);
@@ -911,7 +911,8 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 			 * errors, we dare not queue multiple transfers.
 			 */
 			dma_ok = dma_controller->channel_program(dma_channel,
-					packet_sz, !(urb->transfer_flags &
+					packet_sz | (qh->hb_mult << 11),
+					 !(urb->transfer_flags &
 						     URB_SHORT_NOT_OK),
 					urb->transfer_dma + offset,
 					qh->segsize);
@@ -1681,7 +1682,8 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 				length =
 					urb->iso_frame_desc[qh->iso_idx].length;
 
-				ret = c->channel_program(dma, qh->maxpacket,
+				ret = c->channel_program(dma, qh->maxpacket |
+						(qh->hb_mult << 11),
 						0, (u32) buf, length);
 				done = false;
 			} else {
@@ -1827,7 +1829,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			 * adjusted first...
 			 */
 			ret = c->channel_program(
-				dma, qh->maxpacket,
+				dma, qh->maxpacket | ((qh->hb_mult - 1) << 11),
 				dma->desired_mode, buf, length);
 
 			if (!ret) {
-- 
1.7.5.4

