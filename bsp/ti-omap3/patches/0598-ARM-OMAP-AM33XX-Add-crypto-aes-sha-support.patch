From 81d8b3c8ce132d473291443e1d39741d772d0b5d Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 21 Sep 2012 01:06:48 +0800
Subject: [PATCH 598/609] ARM: OMAP: AM33XX: Add crypto aes/sha support

Original file comes from:
  ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install

Remove the old implementation too, like "#if 0", and static definition
of omap4_sham_resources, which will be built dynamically.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-omap2/devices.c              |   56 ++
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   17 +-
 arch/arm/plat-omap/include/plat/am33xx.h   |   14 +-
 drivers/crypto/Kconfig                     |   22 +-
 drivers/crypto/Makefile                    |    2 +
 drivers/crypto/omap4-aes.c                 |  968 +++++++++++++++++++
 drivers/crypto/omap4-sham.c                | 1448 ++++++++++++++++++++++++++++
 drivers/crypto/omap4.h                     |  192 ++++
 8 files changed, 2712 insertions(+), 7 deletions(-)
 create mode 100644 drivers/crypto/omap4-aes.c
 create mode 100644 drivers/crypto/omap4-sham.c
 create mode 100644 drivers/crypto/omap4.h

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index d998bb0..d290a29 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -704,6 +704,34 @@ static void omap_init_sham(void)
 	}
 	platform_device_register(&sham_device);
 }
+
+#elif defined(CONFIG_CRYPTO_DEV_OMAP4_SHAM) || defined(CONFIG_CRYPTO_DEV_OMAP4_SHAM_MODULE)
+
+int __init omap_init_sham(void)
+{
+	int id = -1;
+	struct platform_device *pdev;
+	struct omap_hwmod *oh;
+	char *oh_name = "sha0";
+	char *name = "omap4-sham";
+
+	oh = omap_hwmod_lookup(oh_name);
+	if (!oh) {
+		pr_err("Could not look up %s\n", oh_name);
+		return -ENODEV;
+	}
+
+	pdev = omap_device_build(name, id, oh, NULL, 0, NULL, 0, 0);
+
+	if (IS_ERR(pdev)) {
+		WARN(1, "Can't build omap_device for %s:%s.\n",
+						name, oh->name);
+		return PTR_ERR(pdev);
+	}
+	printk(KERN_INFO "OMAP33XX SHA initialized successfully.\n");
+	return 0;
+}
+
 #else
 static inline void omap_init_sham(void) { }
 #endif
@@ -774,6 +802,34 @@ static void omap_init_aes(void)
 	platform_device_register(&aes_device);
 }
 
+#elif defined(CONFIG_CRYPTO_DEV_OMAP4_AES) || defined(CONFIG_CRYPTO_DEV_OMAP4_AES_MODULE)
+
+int __init omap_init_aes(void)
+{
+	int id = -1;
+	struct platform_device *pdev;
+	struct omap_hwmod *oh;
+	char *oh_name = "aes0";
+	char *name = "omap4-aes";
+
+	oh = omap_hwmod_lookup(oh_name);
+	if (!oh) {
+		pr_err("Could not look up %s\n", oh_name);
+		return -ENODEV;
+	}
+
+	pdev = omap_device_build(name, id, oh, NULL, 0, NULL, 0, 0);
+
+	if (IS_ERR(pdev)) {
+		WARN(1, "Can't build omap_device for %s:%s.\n",
+						name, oh->name);
+		return PTR_ERR(pdev);
+	}
+
+	printk(KERN_INFO "OMAP33XX AES initialized successfully.\n");
+	return 0;
+}
+
 #else
 static inline void omap_init_aes(void) { }
 #endif
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index 1ada9fa..3b7d90f 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -430,15 +430,22 @@ static struct omap_hwmod_class am33xx_aes_hwmod_class = {
 
 /* aes0 */
 static struct omap_hwmod_irq_info am33xx_aes0_irqs[] = {
-	{ .irq = 102 },
+	{ .irq = AM33XX_IRQ_AESEIP36t0_P },
 	{ .irq = -1 }
 };
 
+static struct omap_hwmod_dma_info am33xx_aes0_dma[] = {
+	{ .dma_req = AM33XX_DMA_AESEIP36T0_DOUT },
+	{ .dma_req = AM33XX_DMA_AESEIP36T0_DIN },
+	{ .dma_req = -1 }
+};
+
 static struct omap_hwmod am33xx_aes0_hwmod = {
 	.name		= "aes0",
 	.class		= &am33xx_aes_hwmod_class,
 	.clkdm_name	= "l3_clkdm",
 	.mpu_irqs	= am33xx_aes0_irqs,
+	.sdma_reqs      = am33xx_aes0_dma,
 	.main_clk	= "aes0_fck",
 	.prcm		= {
 		.omap4	= {
@@ -2164,15 +2171,21 @@ static struct omap_hwmod_class am33xx_sha0_hwmod_class = {
 };
 
 static struct omap_hwmod_irq_info am33xx_sha0_irqs[] = {
-	{ .irq = 108 },
+	{ .irq = AM33XX_IRQ_SHAEIP57t0_P },
 	{ .irq = -1 }
 };
 
+static struct omap_hwmod_dma_info am33xx_sha0_dma[] = {
+	{ .dma_req = AM33XX_DMA_SHAEIP57T0_DIN },
+	{ .dma_req = -1 }
+};
+
 static struct omap_hwmod am33xx_sha0_hwmod = {
 	.name		= "sha0",
 	.class		= &am33xx_sha0_hwmod_class,
 	.clkdm_name	= "l3_clkdm",
 	.mpu_irqs	= am33xx_sha0_irqs,
+	.sdma_reqs      = am33xx_sha0_dma,
 	.main_clk	= "sha0_fck",
 	.prcm		= {
 		.omap4	= {
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index 4865f3a..a4b8996 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -43,9 +43,6 @@
 #define AM33XX_TSC_BASE		0x44E0D000
 #define AM33XX_RTC_BASE		0x44E3E000
 
-#define AM33XX_ASP0_BASE	0x48038000
-#define AM33XX_ASP1_BASE	0x4803C000
-
 #define AM33XX_MAILBOX0_BASE	0x480C8000
 
 #define AM33XX_MMC0_BASE	0x48060100
@@ -79,6 +76,17 @@
 
 #define AM33XX_ELM_BASE		0x48080000
 
+/* Base address for crypto modules */
+#define AM33XX_SHA1MD5_S_BASE   0x53000000
+#define AM33XX_SHA1MD5_P_BASE   0x53100000
+
+#define AM33XX_AES0_S_BASE      0x53400000
+#define AM33XX_AES0_P_BASE      0x53500000
+#define AM33XX_AES1_S_BASE      0x53600000
+#define AM33XX_AES1_P_BASE      0x53700000
+
+#define AM33XX_RNG_BASE         0x48310000
+
 /*
  * ----------------------------------------------------------------------------
  * CPSW
diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig
index dd414d9..2c54a62 100644
--- a/drivers/crypto/Kconfig
+++ b/drivers/crypto/Kconfig
@@ -242,7 +242,7 @@ config CRYPTO_DEV_PPC4XX
 
 config CRYPTO_DEV_OMAP_SHAM
 	tristate "Support for OMAP SHA1/MD5 hw accelerator"
-	depends on ARCH_OMAP2 || ARCH_OMAP3
+	depends on (ARCH_OMAP2) || (ARCH_OMAP3) && (!SOC_AM33XX)
 	select CRYPTO_SHA1
 	select CRYPTO_MD5
 	help
@@ -251,12 +251,30 @@ config CRYPTO_DEV_OMAP_SHAM
 
 config CRYPTO_DEV_OMAP_AES
 	tristate "Support for OMAP AES hw engine"
-	depends on ARCH_OMAP2 || ARCH_OMAP3
+	depends on (ARCH_OMAP2) || (ARCH_OMAP3) && (!SOC_AM33XX)
 	select CRYPTO_AES
 	help
 	  OMAP processors have AES module accelerator. Select this if you
 	  want to use the OMAP module for AES algorithms.
 
+config CRYPTO_DEV_OMAP4_AES
+	tristate "Support for OMAP4 AES hw engine"
+	depends on SOC_AM33XX
+	select CRYPTO_AES
+	help
+	  OMAP4 -based processors have AES module accelerators. Select this if you
+	  want to use the OMAP4 module for AES algorithms.
+
+config CRYPTO_DEV_OMAP4_SHAM
+	tristate "Support for OMAP4 SHA/MD5 hw engine"
+	depends on SOC_AM33XX
+	select CRYPTO_SHA1
+	select CRYPTO_SHA256
+	select CRYPTO_MD5
+	help
+	  OMAP4 -based processors have SHA/MD5 module accelerators. Select this if you
+	  want to use the OMAP4 module for SHA/MD5 algorithms.
+
 config CRYPTO_DEV_PICOXCELL
 	tristate "Support for picoXcell IPSEC and Layer2 crypto engines"
 	depends on ARCH_PICOXCELL && HAVE_CLK
diff --git a/drivers/crypto/Makefile b/drivers/crypto/Makefile
index f3e64ea..422d406 100644
--- a/drivers/crypto/Makefile
+++ b/drivers/crypto/Makefile
@@ -11,6 +11,8 @@ obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_PPC4XX) += amcc/
 obj-$(CONFIG_CRYPTO_DEV_OMAP_SHAM) += omap-sham.o
 obj-$(CONFIG_CRYPTO_DEV_OMAP_AES) += omap-aes.o
+obj-$(CONFIG_CRYPTO_DEV_OMAP4_AES) += omap4-aes.o
+obj-$(CONFIG_CRYPTO_DEV_OMAP4_SHAM) += omap4-sham.o
 obj-$(CONFIG_CRYPTO_DEV_PICOXCELL) += picoxcell_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_S5P) += s5p-sss.o
 obj-$(CONFIG_CRYPTO_DEV_TEGRA_AES) += tegra-aes.o
diff --git a/drivers/crypto/omap4-aes.c b/drivers/crypto/omap4-aes.c
new file mode 100644
index 0000000..b5fe90f
--- /dev/null
+++ b/drivers/crypto/omap4-aes.c
@@ -0,0 +1,968 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for OMAP AES HW acceleration.
+ *
+ * Copyright (c) 2010 Nokia Corporation
+ * Author: Dmitry Kasatkin <dmitry.kasatkin@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+/*
+ * Copyright © 2011 Texas Instruments Incorporated
+ * Author: Herman Schuurman
+ * Change: July 2011 - Adapted the omap-aes.c driver to support Netra
+ *	implementation of AES hardware accelerator.
+ */
+/*
+ * Copyright © 2011 Texas Instruments Incorporated
+ * Author: Greg Turner
+ * Change: November 2011 - Adapted for AM33x support HW accelerator.
+ */
+
+//#define	DEBUG
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/crypto.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/aes.h>
+
+#include <plat/cpu.h>
+#include <plat/dma.h>
+#include <mach/edma.h>
+#include <mach/hardware.h>
+#include "omap4.h"
+
+#define DEFAULT_TIMEOUT		(5*HZ)
+
+#define FLAGS_MODE_MASK		0x000f
+#define FLAGS_ENCRYPT		BIT(0)
+#define FLAGS_CBC		BIT(1)
+#define	FLAGS_CTR		BIT(2)
+#define FLAGS_GIV		BIT(3)
+
+#define FLAGS_INIT		BIT(4)
+#define FLAGS_FAST		BIT(5)
+#define FLAGS_BUSY		BIT(6)
+
+struct omap4_aes_ctx {
+	struct omap4_aes_dev *dd;
+
+	int		keylen;
+	u32		key[AES_KEYSIZE_256 / sizeof(u32)];
+	unsigned long	flags;
+};
+
+struct omap4_aes_reqctx {
+	unsigned long mode;
+};
+
+#define AM33X_AES_QUEUE_LENGTH	1
+#define AM33X_AES_CACHE_SIZE	0
+
+struct omap4_aes_dev {
+	struct list_head		list;
+	unsigned long			phys_base;
+	void __iomem			*io_base;
+	struct clk			*iclk;
+	struct omap4_aes_ctx		*ctx;
+	struct device			*dev;
+	unsigned long			flags;
+	int				err;
+
+	spinlock_t			lock;
+	struct crypto_queue		queue;
+
+	struct tasklet_struct		done_task;
+	struct tasklet_struct		queue_task;
+
+	struct ablkcipher_request	*req;
+	size_t				total;
+	struct scatterlist		*in_sg;
+	size_t				in_offset;
+	struct scatterlist		*out_sg;
+	size_t				out_offset;
+
+	size_t				buflen;
+	void				*buf_in;
+	size_t				dma_size;
+	int				dma_in;
+	int				dma_lch_in;
+	dma_addr_t			dma_addr_in;
+	void				*buf_out;
+	int				dma_out;
+	int				dma_lch_out;
+	dma_addr_t			dma_addr_out;
+};
+
+/* keep registered devices data here */
+static LIST_HEAD(dev_list);
+static DEFINE_SPINLOCK(list_lock);
+
+static inline u32 omap4_aes_read(struct omap4_aes_dev *dd, u32 offset)
+{
+	return __raw_readl(dd->io_base + offset);
+}
+
+static inline void omap4_aes_write(struct omap4_aes_dev *dd, u32 offset,
+				  u32 value)
+{
+	__raw_writel(value, dd->io_base + offset);
+}
+
+static inline void omap4_aes_write_mask(struct omap4_aes_dev *dd, u32 offset,
+				       u32 value, u32 mask)
+{
+	u32 val;
+
+	val = omap4_aes_read(dd, offset);
+	val &= ~mask;
+	val |= value;
+	omap4_aes_write(dd, offset, val);
+}
+
+static void omap4_aes_write_n(struct omap4_aes_dev *dd, u32 offset,
+			     u32 *value, int count)
+{
+	for (; count--; value++, offset += 4)
+		omap4_aes_write(dd, offset, *value);
+}
+
+static int omap4_aes_hw_init(struct omap4_aes_dev *dd)
+{
+	omap4_aes_write(dd, AES_REG_SYSCFG, 0);
+
+	if (!(dd->flags & FLAGS_INIT)) {
+		dd->flags |= FLAGS_INIT;
+		dd->err = 0;
+	}
+
+	return 0;
+}
+
+static int omap4_aes_write_ctrl(struct omap4_aes_dev *dd)
+{
+	unsigned int key32;
+	int i, err;
+	u32 val, mask;
+
+	err = omap4_aes_hw_init(dd);
+	if (err)
+		return err;
+
+	pr_debug("Set key\n");
+	key32 = dd->ctx->keylen / sizeof(u32);
+
+	/* set a key */
+	for (i = 0; i < key32; i++) {
+		omap4_aes_write(dd, AES_REG_KEY1(i),
+			       __le32_to_cpu(dd->ctx->key[i]));
+	}
+
+	if ((dd->flags & (FLAGS_CBC | FLAGS_CTR)) && dd->req->info)
+		omap4_aes_write_n(dd, AES_REG_IV(0), dd->req->info, 4);
+
+	val = FLD_VAL(((dd->ctx->keylen >> 3) - 1), 4, 3);
+	if (dd->flags & FLAGS_CBC)
+		val |= AES_REG_CTRL_CBC;
+	else if (dd->flags & FLAGS_CTR)
+		val |= AES_REG_CTRL_CTR | AES_REG_CTRL_CTR_WIDTH_32;
+	if (dd->flags & FLAGS_ENCRYPT)
+		val |= AES_REG_CTRL_DIRECTION;
+
+	mask = AES_REG_CTRL_CBC | AES_REG_CTRL_CTR | AES_REG_CTRL_DIRECTION |
+		AES_REG_CTRL_KEY_SIZE_MASK | AES_REG_CTRL_CTR_WIDTH_MASK;
+
+	omap4_aes_write_mask(dd, AES_REG_CTRL, val, mask);
+
+	return 0;
+}
+
+static struct omap4_aes_dev *omap4_aes_find_dev(struct omap4_aes_ctx *ctx)
+{
+	struct omap4_aes_dev *dd = NULL, *tmp;
+
+	spin_lock_bh(&list_lock);
+	if (!ctx->dd) {
+		list_for_each_entry(tmp, &dev_list, list) {
+			/* FIXME: take fist available aes core */
+			dd = tmp;
+			break;
+		}
+		ctx->dd = dd;
+	} else {
+		/* already found before */
+		dd = ctx->dd;
+	}
+	spin_unlock_bh(&list_lock);
+
+	return dd;
+}
+
+static void omap4_aes_dma_callback(unsigned int lch, u16 ch_status, void *data)
+{
+	struct omap4_aes_dev *dd = data;
+
+	edma_stop(lch);
+
+	if (ch_status != DMA_COMPLETE) {
+		pr_err("omap4-aes DMA error status: 0x%hx\n", ch_status);
+		dd->err = -EIO;
+		dd->flags &= ~FLAGS_INIT; /* request to re-initialize */
+	} else if (lch == dd->dma_lch_in) {
+		return;
+	}
+
+	/* dma_lch_out - completed */
+	tasklet_schedule(&dd->done_task);
+}
+
+static int omap4_aes_dma_init(struct omap4_aes_dev *dd)
+{
+	int err = -ENOMEM;
+
+	dd->dma_lch_out = -1;
+	dd->dma_lch_in = -1;
+
+	dd->buf_in = (void *)__get_free_pages(GFP_KERNEL, AM33X_AES_CACHE_SIZE);
+	dd->buf_out = (void *)__get_free_pages(GFP_KERNEL, AM33X_AES_CACHE_SIZE);
+	dd->buflen = PAGE_SIZE << AM33X_AES_CACHE_SIZE;
+	dd->buflen &= ~(AES_BLOCK_SIZE - 1);
+
+	if (!dd->buf_in || !dd->buf_out) {
+		dev_err(dd->dev, "unable to alloc pages.\n");
+		goto err_alloc;
+	}
+
+	/* MAP here */
+	dd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in, dd->buflen,
+					 DMA_TO_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_in)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_in;
+	}
+
+	dd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out, dd->buflen,
+					  DMA_FROM_DEVICE);
+	if (dma_mapping_error(dd->dev, dd->dma_addr_out)) {
+		dev_err(dd->dev, "dma %d bytes error\n", dd->buflen);
+		err = -EINVAL;
+		goto err_map_out;
+	}
+
+	dd->dma_lch_in = edma_alloc_channel(dd->dma_in, omap4_aes_dma_callback,
+					    dd, EVENTQ_DEFAULT);
+
+	if (dd->dma_lch_in < 0) {
+		dev_err(dd->dev, "Unable to request DMA channel\n");
+		goto err_dma_in;
+	}
+
+	dd->dma_lch_out = edma_alloc_channel(dd->dma_out, omap4_aes_dma_callback, dd, EVENTQ_2);
+
+	if (dd->dma_lch_out < 0) {
+		dev_err(dd->dev, "Unable to request DMA channel\n");
+		goto err_dma_out;
+	}
+
+	return 0;
+
+err_dma_out:
+	edma_free_channel(dd->dma_lch_in);
+err_dma_in:
+	dma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,
+			 DMA_FROM_DEVICE);
+err_map_out:
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen, DMA_TO_DEVICE);
+err_map_in:
+	free_pages((unsigned long)dd->buf_out, AM33X_AES_CACHE_SIZE);
+	free_pages((unsigned long)dd->buf_in, AM33X_AES_CACHE_SIZE);
+err_alloc:
+	if (err)
+		pr_err("error: %d\n", err);
+	return err;
+}
+
+static void omap4_aes_dma_cleanup(struct omap4_aes_dev *dd)
+{
+	edma_free_channel(dd->dma_lch_out);
+	edma_free_channel(dd->dma_lch_in);
+	dma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,
+			 DMA_FROM_DEVICE);
+	dma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen, DMA_TO_DEVICE);
+	free_pages((unsigned long)dd->buf_out, AM33X_AES_CACHE_SIZE);
+	free_pages((unsigned long)dd->buf_in, AM33X_AES_CACHE_SIZE);
+}
+
+static void sg_copy_buf(void *buf, struct scatterlist *sg,
+			unsigned int start, unsigned int nbytes, int out)
+{
+	struct scatter_walk walk;
+
+	if (!nbytes)
+		return;
+
+	scatterwalk_start(&walk, sg);
+	scatterwalk_advance(&walk, start);
+	scatterwalk_copychunks(buf, &walk, nbytes, out);
+	scatterwalk_done(&walk, out, 0);
+}
+
+static int sg_copy(struct scatterlist **sg, size_t *offset, void *buf,
+		   size_t buflen, size_t total, int out)
+{
+	unsigned int count, off = 0;
+
+	while (buflen && total) {
+		count = min((*sg)->length - *offset, total);
+		count = min(count, buflen);
+
+		if (!count)
+			return off;
+
+		/*
+		 * buflen and total are AES_BLOCK_SIZE size aligned,
+		 * so count should be also aligned
+		 */
+
+		sg_copy_buf(buf + off, *sg, *offset, count, out);
+
+		off += count;
+		buflen -= count;
+		*offset += count;
+		total -= count;
+
+		if (*offset == (*sg)->length) {
+			*sg = sg_next(*sg);
+			if (*sg)
+				*offset = 0;
+			else
+				total = 0;
+		}
+	}
+
+	return off;
+}
+
+static int omap4_aes_crypt_dma(struct crypto_tfm *tfm, dma_addr_t dma_addr_in,
+			      dma_addr_t dma_addr_out, int length)
+{
+	struct omap4_aes_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct omap4_aes_dev *dd = ctx->dd;
+	int nblocks;
+	struct edmacc_param p_ram;
+
+	pr_debug("len: %d\n", length);
+
+	dd->dma_size = length;
+
+	if (!(dd->flags & FLAGS_FAST))
+		dma_sync_single_for_device(dd->dev, dma_addr_in, length,
+					   DMA_TO_DEVICE);
+
+	nblocks = DIV_ROUND_UP(length, AES_BLOCK_SIZE);
+
+	/* EDMA IN */
+	p_ram.opt	   = TCINTEN |
+		EDMA_TCC(EDMA_CHAN_SLOT(dd->dma_lch_in));
+	p_ram.src	   = dma_addr_in;
+	p_ram.a_b_cnt      = AES_BLOCK_SIZE | nblocks << 16;
+	p_ram.dst          = dd->phys_base + AES_REG_DATA;
+	p_ram.src_dst_bidx = AES_BLOCK_SIZE;
+	p_ram.link_bcntrld = 1 << 16 | 0xFFFF;
+	p_ram.src_dst_cidx = 0;
+	p_ram.ccnt         = 1;
+	edma_write_slot(dd->dma_lch_in, &p_ram);
+
+	/* EDMA OUT */
+	p_ram.opt	   = TCINTEN |
+		EDMA_TCC(EDMA_CHAN_SLOT(dd->dma_lch_out));
+	p_ram.src	   = dd->phys_base + AES_REG_DATA;
+	p_ram.dst          = dma_addr_out;
+	p_ram.src_dst_bidx = AES_BLOCK_SIZE << 16;
+	edma_write_slot(dd->dma_lch_out, &p_ram);
+
+	edma_start(dd->dma_lch_in);
+	edma_start(dd->dma_lch_out);
+
+	/* write data length info out */
+	omap4_aes_write(dd, AES_REG_LENGTH_N(0), length);
+	omap4_aes_write(dd, AES_REG_LENGTH_N(1), 0);
+	/* start DMA or disable idle mode */
+	omap4_aes_write_mask(dd, AES_REG_SYSCFG,
+			   AES_REG_SYSCFG_DREQ_DATA_OUT_EN | AES_REG_SYSCFG_DREQ_DATA_IN_EN,
+			   AES_REG_SYSCFG_DREQ_MASK);
+
+	return 0;
+}
+
+static int omap4_aes_crypt_dma_start(struct omap4_aes_dev *dd)
+{
+	struct crypto_tfm *tfm = crypto_ablkcipher_tfm(
+					crypto_ablkcipher_reqtfm(dd->req));
+	int err, fast = 0, in, out;
+	size_t count;
+	dma_addr_t addr_in, addr_out;
+
+	pr_debug("total: %d\n", dd->total);
+
+	if (sg_is_last(dd->in_sg) && sg_is_last(dd->out_sg)) {
+		/* check for alignment */
+		in = IS_ALIGNED((u32)dd->in_sg->offset, sizeof(u32));
+		out = IS_ALIGNED((u32)dd->out_sg->offset, sizeof(u32));
+
+		fast = in && out;
+	}
+
+	if (fast)  {
+		count = min(dd->total, sg_dma_len(dd->in_sg));
+		count = min(count, sg_dma_len(dd->out_sg));
+
+		if (count != dd->total) {
+			pr_err("request length != buffer length\n");
+			return -EINVAL;
+		}
+
+		pr_debug("fast\n");
+
+		err = dma_map_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);
+		if (!err) {
+			dev_err(dd->dev, "dma_map_sg() error\n");
+			return -EINVAL;
+		}
+
+		err = dma_map_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);
+		if (!err) {
+			dev_err(dd->dev, "dma_map_sg() error\n");
+			dma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);
+			return -EINVAL;
+		}
+
+		addr_in = sg_dma_address(dd->in_sg);
+		addr_out = sg_dma_address(dd->out_sg);
+
+		dd->flags |= FLAGS_FAST;
+
+	} else {
+		/* use cache buffers */
+		count = sg_copy(&dd->in_sg, &dd->in_offset, dd->buf_in,
+				dd->buflen, dd->total, 0);
+
+		addr_in = dd->dma_addr_in;
+		addr_out = dd->dma_addr_out;
+
+		dd->flags &= ~FLAGS_FAST;
+
+	}
+
+	dd->total -= count;
+
+	err = omap4_aes_crypt_dma(tfm, addr_in, addr_out, count);
+	if (err) {
+		dma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);
+		dma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_TO_DEVICE);
+	}
+
+	return err;
+}
+
+static void omap4_aes_finish_req(struct omap4_aes_dev *dd, int err)
+{
+	struct ablkcipher_request *req = dd->req;
+
+	pr_debug("err: %d\n", err);
+
+	dd->flags &= ~FLAGS_BUSY;
+
+	req->base.complete(&req->base, err);
+}
+
+static int omap4_aes_crypt_dma_stop(struct omap4_aes_dev *dd)
+{
+	int err = 0;
+	size_t count;
+
+	pr_debug("total: %d\n", dd->total);
+
+	omap4_aes_write_mask(dd, AES_REG_SYSCFG, 0, AES_REG_SYSCFG_DREQ_MASK);
+
+	edma_stop(dd->dma_lch_in);
+	edma_clean_channel(dd->dma_lch_in);
+	edma_stop(dd->dma_lch_out);
+	edma_clean_channel(dd->dma_lch_out);
+
+	if (dd->flags & FLAGS_FAST) {
+		dma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);
+		dma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);
+	} else {
+		dma_sync_single_for_device(dd->dev, dd->dma_addr_out,
+					   dd->dma_size, DMA_FROM_DEVICE);
+
+		/* copy data */
+		count = sg_copy(&dd->out_sg, &dd->out_offset, dd->buf_out,
+				dd->buflen, dd->dma_size, 1);
+		if (count != dd->dma_size) {
+			err = -EINVAL;
+			pr_err("not all data converted: %u\n", count);
+		}
+	}
+
+	return err;
+}
+
+static int omap4_aes_handle_queue(struct omap4_aes_dev *dd,
+				 struct ablkcipher_request *req)
+{
+	struct crypto_async_request *async_req, *backlog;
+	struct omap4_aes_ctx *ctx;
+	struct omap4_aes_reqctx *rctx;
+	unsigned long flags;
+	int err, ret = 0;
+
+	spin_lock_irqsave(&dd->lock, flags);
+	if (req)
+		ret = ablkcipher_enqueue_request(&dd->queue, req);
+
+	if (dd->flags & FLAGS_BUSY) {
+		spin_unlock_irqrestore(&dd->lock, flags);
+		return ret;
+	}
+	backlog = crypto_get_backlog(&dd->queue);
+	async_req = crypto_dequeue_request(&dd->queue);
+	if (async_req)
+		dd->flags |= FLAGS_BUSY;
+	spin_unlock_irqrestore(&dd->lock, flags);
+
+	if (!async_req)
+		return ret;
+
+	if (backlog)
+		backlog->complete(backlog, -EINPROGRESS);
+
+	req = ablkcipher_request_cast(async_req);
+
+	/* assign new request to device */
+	dd->req = req;
+	dd->total = req->nbytes;
+	dd->in_offset = 0;
+	dd->in_sg = req->src;
+	dd->out_offset = 0;
+	dd->out_sg = req->dst;
+
+	rctx = ablkcipher_request_ctx(req);
+	ctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));
+	rctx->mode &= FLAGS_MODE_MASK;
+	dd->flags = (dd->flags & ~FLAGS_MODE_MASK) | rctx->mode;
+
+	dd->ctx = ctx;
+	ctx->dd = dd;
+
+	err = omap4_aes_write_ctrl(dd);
+	if (!err)
+		err = omap4_aes_crypt_dma_start(dd);
+	if (err) {
+		/* aes_task will not finish it, so do it here */
+		omap4_aes_finish_req(dd, err);
+		tasklet_schedule(&dd->queue_task);
+	}
+
+	return ret; /* return ret, which is enqueue return value */
+}
+
+static void omap4_aes_done_task(unsigned long data)
+{
+	struct omap4_aes_dev *dd = (struct omap4_aes_dev *)data;
+	int err;
+
+	pr_debug("enter\n");
+
+	err = omap4_aes_crypt_dma_stop(dd);
+
+	err = dd->err ? : err;
+
+	if (dd->total && !err) {
+		err = omap4_aes_crypt_dma_start(dd);
+		if (!err)
+			return; /* DMA started. Not finishing. */
+	}
+
+	omap4_aes_finish_req(dd, err);
+	omap4_aes_handle_queue(dd, NULL);
+
+	pr_debug("exit\n");
+}
+
+static void omap4_aes_queue_task(unsigned long data)
+{
+	struct omap4_aes_dev *dd = (struct omap4_aes_dev *)data;
+
+	omap4_aes_handle_queue(dd, NULL);
+}
+
+static int omap4_aes_crypt(struct ablkcipher_request *req, unsigned long mode)
+{
+	struct omap4_aes_ctx *ctx = crypto_ablkcipher_ctx(
+		crypto_ablkcipher_reqtfm(req));
+	struct omap4_aes_reqctx *rctx = ablkcipher_request_ctx(req);
+	struct omap4_aes_dev *dd;
+
+	pr_debug("nbytes: %d, enc: %d, cbc: %d, ctr: %d\n", req->nbytes,
+		 !!(mode & FLAGS_ENCRYPT),
+		 !!(mode & FLAGS_CBC),
+		 !!(mode & FLAGS_CTR));
+
+	if (!IS_ALIGNED(req->nbytes, AES_BLOCK_SIZE)) {
+		pr_err("request size is not exact amount of AES blocks\n");
+		return -EINVAL;
+	}
+
+	dd = omap4_aes_find_dev(ctx);
+	if (!dd)
+		return -ENODEV;
+
+	rctx->mode = mode;
+
+	return omap4_aes_handle_queue(dd, req);
+}
+
+/* ********************** ALG API ************************************ */
+
+static int omap4_aes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,
+			   unsigned int keylen)
+{
+	struct omap4_aes_ctx *ctx = crypto_ablkcipher_ctx(tfm);
+
+	if (keylen != AES_KEYSIZE_128 && keylen != AES_KEYSIZE_192 &&
+	    keylen != AES_KEYSIZE_256)
+		return -EINVAL;
+
+	pr_debug("enter, keylen: %d\n", keylen);
+
+	memcpy(ctx->key, key, keylen);
+	ctx->keylen = keylen;
+
+	return 0;
+}
+
+static int omap4_aes_ecb_encrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, FLAGS_ENCRYPT);
+}
+
+static int omap4_aes_ecb_decrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, 0);
+}
+
+static int omap4_aes_cbc_encrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, FLAGS_ENCRYPT | FLAGS_CBC);
+}
+
+static int omap4_aes_cbc_decrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, FLAGS_CBC);
+}
+
+static int omap4_aes_ctr_encrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, FLAGS_ENCRYPT | FLAGS_CTR);
+}
+
+static int omap4_aes_ctr_decrypt(struct ablkcipher_request *req)
+{
+	return omap4_aes_crypt(req, FLAGS_CTR);
+}
+
+static int omap4_aes_cra_init(struct crypto_tfm *tfm)
+{
+	pr_debug("enter\n");
+
+	tfm->crt_ablkcipher.reqsize = sizeof(struct omap4_aes_reqctx);
+
+	return 0;
+}
+
+static void omap4_aes_cra_exit(struct crypto_tfm *tfm)
+{
+	pr_debug("enter\n");
+}
+
+/* ********************** ALGS ************************************ */
+
+static struct crypto_alg algs[] = {
+	{
+		.cra_name		= "ecb(aes)",
+		.cra_driver_name	= "ecb-aes-omap4",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_aes_ctx),
+		.cra_alignmask		= 0,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_aes_cra_init,
+		.cra_exit		= omap4_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.setkey		= omap4_aes_setkey,
+			.encrypt	= omap4_aes_ecb_encrypt,
+			.decrypt	= omap4_aes_ecb_decrypt,
+		}
+	},
+	{
+		.cra_name		= "cbc(aes)",
+		.cra_driver_name	= "cbc-aes-omap4",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_aes_ctx),
+		.cra_alignmask		= 0,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_aes_cra_init,
+		.cra_exit		= omap4_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.geniv		= "eseqiv",
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= omap4_aes_setkey,
+			.encrypt	= omap4_aes_cbc_encrypt,
+			.decrypt	= omap4_aes_cbc_decrypt,
+
+		}
+	},
+	{
+		.cra_name		= "ctr(aes)",
+		.cra_driver_name	= "ctr-aes-omap4",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_ABLKCIPHER | CRYPTO_ALG_ASYNC,
+		.cra_blocksize		= AES_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_aes_ctx),
+		.cra_alignmask		= 0,
+		.cra_type		= &crypto_ablkcipher_type,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_aes_cra_init,
+		.cra_exit		= omap4_aes_cra_exit,
+		.cra_u.ablkcipher = {
+			.min_keysize	= AES_MIN_KEY_SIZE,
+			.max_keysize	= AES_MAX_KEY_SIZE,
+			.geniv		= "eseqiv",
+			.ivsize		= AES_BLOCK_SIZE,
+			.setkey		= omap4_aes_setkey,
+			.encrypt	= omap4_aes_ctr_encrypt,
+			.decrypt	= omap4_aes_ctr_decrypt,
+		}
+	}
+};
+
+static int omap4_aes_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct omap4_aes_dev *dd;
+	struct resource *res;
+	int err = -ENOMEM, i, j;
+	u32 reg;
+
+	dd = kzalloc(sizeof(struct omap4_aes_dev), GFP_KERNEL);
+	if (dd == NULL) {
+		dev_err(dev, "unable to alloc data struct.\n");
+		goto err_data;
+	}
+	dd->dev = dev;
+	platform_set_drvdata(pdev, dd);
+
+	spin_lock_init(&dd->lock);
+	crypto_init_queue(&dd->queue, AM33X_AES_QUEUE_LENGTH);
+
+	dd->phys_base = AM33XX_AES0_P_BASE;
+
+	/* Get the DMA */
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!res)
+		dev_info(dev, "no DMA info\n");
+	else
+		dd->dma_out = res->start;
+
+	/* Get the DMA */
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+	if (!res)
+		dev_info(dev, "no DMA info\n");
+	else
+		dd->dma_in = res->start;
+
+	pm_runtime_enable(dev);
+	udelay(1);
+	pm_runtime_get_sync(dev);
+	udelay(1);
+
+	dd->io_base = ioremap(dd->phys_base, SZ_4K);
+	if (!dd->io_base) {
+		dev_err(dev, "can't ioremap\n");
+		err = -ENOMEM;
+		goto err_io;
+	}
+
+	omap4_aes_hw_init(dd);
+	reg = omap4_aes_read(dd, AES_REG_REV);
+
+	dev_info(dev, "AM33X AES hw accel rev: %u.%02u\n",
+		 ((reg & AES_REG_REV_X_MAJOR_MASK) >> 8),
+		 (reg & AES_REG_REV_Y_MINOR_MASK));
+
+	tasklet_init(&dd->done_task, omap4_aes_done_task, (unsigned long)dd);
+	tasklet_init(&dd->queue_task, omap4_aes_queue_task, (unsigned long)dd);
+
+	err = omap4_aes_dma_init(dd);
+	if (err)
+		goto err_dma;
+
+	INIT_LIST_HEAD(&dd->list);
+	spin_lock(&list_lock);
+	list_add_tail(&dd->list, &dev_list);
+	spin_unlock(&list_lock);
+
+	for (i = 0; i < ARRAY_SIZE(algs); i++) {
+		pr_debug("reg alg: %s\n", algs[i].cra_name);
+		INIT_LIST_HEAD(&algs[i].cra_list);
+		err = crypto_register_alg(&algs[i]);
+		if (err)
+			goto err_algs;
+	}
+
+	pr_info("probe() done\n");
+
+	return 0;
+
+err_algs:
+	for (j = 0; j < i; j++)
+		crypto_unregister_alg(&algs[j]);
+	omap4_aes_dma_cleanup(dd);
+err_dma:
+	tasklet_kill(&dd->done_task);
+	tasklet_kill(&dd->queue_task);
+	iounmap(dd->io_base);
+
+err_io:
+	pm_runtime_put_sync(dev);
+	udelay(1);
+	pm_runtime_disable(dev);
+	udelay(1);
+
+
+//err_res:
+	//kfree(dd);
+	//dd = NULL;
+err_data:
+	dev_err(dev, "initialization failed.\n");
+	return err;
+}
+
+static int omap4_aes_remove(struct platform_device *pdev)
+{
+	struct omap4_aes_dev *dd = platform_get_drvdata(pdev);
+	int i;
+
+	if (!dd)
+		return -ENODEV;
+
+	spin_lock(&list_lock);
+	list_del(&dd->list);
+	spin_unlock(&list_lock);
+
+	for (i = 0; i < ARRAY_SIZE(algs); i++)
+		crypto_unregister_alg(&algs[i]);
+
+	tasklet_kill(&dd->done_task);
+	tasklet_kill(&dd->queue_task);
+	omap4_aes_dma_cleanup(dd);
+	iounmap(dd->io_base);
+	pm_runtime_put_sync(&pdev->dev);
+	udelay(1);
+	pm_runtime_disable(&pdev->dev);
+	udelay(1);
+
+	kfree(dd);
+	dd = NULL;
+
+	return 0;
+}
+
+static int omap4_aes_suspend(struct device *dev)
+{
+	pr_debug("#### Crypto: Suspend call ####\n");
+
+	return 0;
+}
+
+
+static int omap4_aes_resume(struct device *dev)
+{
+	pr_debug("#### Crypto: resume call ####\n");
+
+	return 0;
+}
+
+static struct dev_pm_ops omap4_aes_dev_pm_ops = {
+	.suspend	= omap4_aes_suspend,
+	.resume		= omap4_aes_resume,
+	.runtime_suspend = omap4_aes_suspend,
+	.runtime_resume = omap4_aes_resume,
+};
+
+static struct platform_driver omap4_aes_driver = {
+	.probe	= omap4_aes_probe,
+	.remove	= omap4_aes_remove,
+	.driver	= {
+		.name	= "omap4-aes",
+		.owner	= THIS_MODULE,
+		.pm		= &omap4_aes_dev_pm_ops
+	},
+};
+
+static int __init omap4_aes_mod_init(void)
+{
+	pr_info("loading AM33X AES driver\n");
+
+	/* This only works on a GP device */
+	if (!cpu_is_am33xx() || omap_type() != OMAP2_DEVICE_TYPE_GP) {
+		pr_err("Unsupported cpu\n");
+		return -ENODEV;
+	}
+	return  platform_driver_register(&omap4_aes_driver);
+}
+
+static void __exit omap4_aes_mod_exit(void)
+{
+	pr_info("unloading AM33X AES driver\n");
+
+	platform_driver_unregister(&omap4_aes_driver);
+}
+
+
+
+module_init(omap4_aes_mod_init);
+module_exit(omap4_aes_mod_exit);
+
+MODULE_DESCRIPTION("AM33X AES acceleration support.");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Herman Schuurman");
diff --git a/drivers/crypto/omap4-sham.c b/drivers/crypto/omap4-sham.c
new file mode 100644
index 0000000..2fb71b9
--- /dev/null
+++ b/drivers/crypto/omap4-sham.c
@@ -0,0 +1,1448 @@
+/*
+ * Cryptographic API.
+ *
+ * Support for OMAP SHA1/MD5 HW acceleration.
+ *
+ * Copyright (c) 2010 Nokia Corporation
+ * Author: Dmitry Kasatkin <dmitry.kasatkin@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ * Some ideas are from old omap-sha1-md5.c driver.
+ */
+/*
+ * Copyright © 2011 Texas Instruments Incorporated
+ * Author: Herman Schuurman
+ * Change: July 2011 - Adapted the omap-sham.c driver to support Netra
+ *	implementation of SHA/MD5 hardware accelerator.
+ *	Dec 2011 - Updated with latest omap-sham.c driver changes.
+ */
+
+//#define	DEBUG
+
+#define pr_fmt(fmt) "%s: " fmt, __func__
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/scatterlist.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/crypto.h>
+#include <linux/cryptohash.h>
+#include <linux/pm_runtime.h>
+#include <crypto/scatterwalk.h>
+#include <crypto/algapi.h>
+#include <crypto/sha.h>
+#include <crypto/md5.h>
+#include <crypto/hash.h>
+#include <crypto/internal/hash.h>
+
+#include <mach/hardware.h>
+#include <plat/cpu.h>
+#include <plat/dma.h>
+#include <mach/edma.h>
+#include <mach/irqs.h>
+#include "omap4.h"
+
+#define SHA2_MD5_BLOCK_SIZE		SHA1_BLOCK_SIZE
+
+#define DEFAULT_TIMEOUT_INTERVAL	HZ
+
+/* device flags */
+#define FLAGS_BUSY		0
+#define FLAGS_FINAL		1
+#define FLAGS_DMA_ACTIVE	2
+#define FLAGS_OUTPUT_READY	3 /* shared with context flags */
+#define FLAGS_INIT		4
+#define FLAGS_CPU		5 /* shared with context flags */
+#define	FLAGS_DMA_READY		6 /* shared with context flags */
+
+/* context flags */
+#define FLAGS_FINUP		16
+#define FLAGS_SG		17
+#define	FLAGS_MODE_SHIFT	18
+#define	FLAGS_MODE_MASK		(SHA_REG_MODE_ALGO_MASK     << (FLAGS_MODE_SHIFT - 1))
+#define	 FLAGS_MD5		(SHA_REG_MODE_ALGO_MD5_128  << (FLAGS_MODE_SHIFT - 1))
+#define  FLAGS_SHA1		(SHA_REG_MODE_ALGO_SHA1_160 << (FLAGS_MODE_SHIFT - 1))
+#define	 FLAGS_SHA224		(SHA_REG_MODE_ALGO_SHA2_224 << (FLAGS_MODE_SHIFT - 1))
+#define	 FLAGS_SHA256		(SHA_REG_MODE_ALGO_SHA2_256 << (FLAGS_MODE_SHIFT - 1))
+#define FLAGS_HMAC		20
+#define FLAGS_ERROR		21
+
+#define OP_UPDATE		1
+#define OP_FINAL		2
+
+#define AM33X_ALIGN_MASK	(sizeof(u32)-1)
+#define AM33X_ALIGNED		__attribute__((aligned(sizeof(u32))))
+
+#define BUFLEN			PAGE_SIZE
+
+struct omap4_sham_dev;
+
+struct omap4_sham_reqctx {
+	struct omap4_sham_dev	*dd;
+	unsigned long		rflags;
+	unsigned long		op;
+
+	u8			digest[SHA256_DIGEST_SIZE] AM33X_ALIGNED;
+	size_t			digcnt; /* total digest byte count */
+	size_t			bufcnt; /* bytes in buffer */
+	size_t			buflen; /* buffer length */
+	dma_addr_t		dma_addr;
+
+	/* walk state */
+	struct scatterlist	*sg;
+	unsigned int		offset;	/* offset in current sg */
+	unsigned int		total;	/* total request */
+
+	u8			buffer[0] AM33X_ALIGNED;
+};
+
+/* This structure holds the initial HMAC key value, and subsequently
+ * the outer digest in the first 32 bytes.  The inner digest will be
+ * kept within the request context to conform to hash only
+ * computations.
+ */
+struct omap4_sham_hmac_ctx {
+	struct crypto_shash	*shash;
+	u8			keypad[SHA2_MD5_BLOCK_SIZE] AM33X_ALIGNED;
+	u32			odigest[SHA256_DIGEST_SIZE / sizeof(u32)];
+};
+
+struct omap4_sham_ctx {
+	struct omap4_sham_dev	*dd;
+
+	unsigned long		cflags;
+
+	/* fallback stuff */
+	struct crypto_shash	*fallback;
+
+	struct omap4_sham_hmac_ctx base[0];
+};
+
+#define AM33X_SHAM_QUEUE_LENGTH	1
+
+struct omap4_sham_dev {
+	struct list_head	list;
+	unsigned long		phys_base;
+	struct device		*dev;
+	void __iomem		*io_base;
+	int			irq;
+	struct clk		*iclk;
+	spinlock_t		lock;
+	int			err;
+	int			dma;
+	int			dma_lch;
+	struct tasklet_struct	done_task;
+
+	unsigned long		dflags;
+	struct crypto_queue	queue;
+	struct ahash_request	*req;
+};
+
+struct omap4_sham_drv {
+	struct list_head	dev_list;
+	spinlock_t		lock;
+	unsigned long		flags; /* superfluous ???? */
+};
+
+static struct omap4_sham_drv sham = {
+	.dev_list = LIST_HEAD_INIT(sham.dev_list),
+	.lock = __SPIN_LOCK_UNLOCKED(sham.lock),
+};
+
+static inline u32 omap4_sham_read(struct omap4_sham_dev *dd, u32 offset)
+{
+	return __raw_readl(dd->io_base + offset);
+}
+
+static inline void omap4_sham_write(struct omap4_sham_dev *dd,
+				  u32 offset, u32 value)
+{
+	__raw_writel(value, dd->io_base + offset);
+}
+
+static inline void omap4_sham_write_mask(struct omap4_sham_dev *dd, u32 address,
+				       u32 value, u32 mask)
+{
+	u32 val;
+
+	val = omap4_sham_read(dd, address);
+	val &= ~mask;
+	val |= value;
+	omap4_sham_write(dd, address, val);
+}
+
+static inline void omap4_sham_write_n(struct omap4_sham_dev *dd, u32 offset,
+				    u32 *value, int count)
+{
+	for (; count--; value++, offset += 4)
+		omap4_sham_write(dd, offset, *value);
+}
+
+static inline int omap4_sham_wait(struct omap4_sham_dev *dd, u32 offset, u32 bit)
+{
+	unsigned long timeout = jiffies + DEFAULT_TIMEOUT_INTERVAL;
+
+	while (!(omap4_sham_read(dd, offset) & bit)) {
+		if (time_is_before_jiffies(timeout))
+			return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static void omap4_sham_copy_hash(struct ahash_request *req, int out)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	u32 *hash = (u32 *)ctx->digest;
+	int i;
+
+	if (ctx->rflags & BIT(FLAGS_HMAC)) {
+		struct crypto_ahash *tfm = crypto_ahash_reqtfm(ctx->dd->req);
+		struct omap4_sham_ctx *tctx = crypto_ahash_ctx(tfm);
+		struct omap4_sham_hmac_ctx *bctx = tctx->base;
+
+		for (i = 0; i < SHA256_DIGEST_SIZE / sizeof(u32); i++) {
+			if (out)
+				bctx->odigest[i] = omap4_sham_read(ctx->dd,
+						SHA_REG_ODIGEST_N(i));
+			else
+				omap4_sham_write(ctx->dd,
+					       SHA_REG_ODIGEST_N(i), bctx->odigest[i]);
+		}
+	}
+
+	/* Copy sha256 size to reduce code */
+	for (i = 0; i < SHA256_DIGEST_SIZE / sizeof(u32); i++) {
+		if (out)
+			hash[i] = omap4_sham_read(ctx->dd,
+						SHA_REG_IDIGEST_N(i));
+		else
+			omap4_sham_write(ctx->dd,
+				       SHA_REG_IDIGEST_N(i), hash[i]);
+	}
+}
+
+static void omap4_sham_copy_ready_hash(struct ahash_request *req)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	u32 *in = (u32 *)ctx->digest;
+	u32 *hash = (u32 *)req->result;
+	int i, d = 0;
+
+	if (!hash)
+		return;
+
+	switch (ctx->rflags & FLAGS_MODE_MASK) {
+	case FLAGS_MD5:
+		d = MD5_DIGEST_SIZE / sizeof(u32);
+		break;
+	case FLAGS_SHA1:
+		d = SHA1_DIGEST_SIZE / sizeof(u32);
+		break;
+	case FLAGS_SHA224:
+		d = SHA224_DIGEST_SIZE / sizeof(u32);
+		break;
+	case FLAGS_SHA256:
+		d = SHA256_DIGEST_SIZE / sizeof(u32);
+		break;
+	}
+
+	/* all results are in little endian */
+	for (i = 0; i < d; i++)
+		hash[i] = le32_to_cpu(in[i]);
+}
+
+#if 0
+static int omap4_sham_hw_init(struct omap4_sham_dev *dd)
+{
+	omap4_sham_write(dd, SHA_REG_SYSCFG, SHA_REG_SYSCFG_SOFTRESET);
+	/*
+	 * prevent OCP bus error (SRESP) in case an access to the module
+	 * is performed while the module is coming out of soft reset
+	 */
+	__asm__ __volatile__("nop");
+	__asm__ __volatile__("nop");
+
+	if (omap4_sham_wait(dd, SHA_REG_SYSSTATUS, SHA_REG_SYSSTATUS_RESETDONE))
+		return -ETIMEDOUT;
+
+	omap4_sham_write(dd, SHA_REG_SYSCFG,
+		       SHA_REG_SYSCFG_SIDLE_SMARTIDLE | SHA_REG_SYSCFG_AUTOIDLE);
+	set_bit(FLAGS_INIT, &dd->dflags);
+	dd->err = 0;
+
+	return 0;
+}
+#endif
+
+static void omap4_sham_write_ctrl(struct omap4_sham_dev *dd, int final, int dma)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	u32 val, mask;
+
+	/*
+	 * Setting ALGO_CONST only for the first iteration and
+	 * CLOSE_HASH only for the last one. Note that flags mode bits
+	 * correspond to algorithm encoding in mode register.
+	 */
+	val = (ctx->rflags & FLAGS_MODE_MASK) >> (FLAGS_MODE_SHIFT - 1);
+	if (!ctx->digcnt) {
+		struct crypto_ahash *tfm = crypto_ahash_reqtfm(dd->req);
+		struct omap4_sham_ctx *tctx = crypto_ahash_ctx(tfm);
+		struct omap4_sham_hmac_ctx *bctx = tctx->base;
+
+		val |= SHA_REG_MODE_ALGO_CONSTANT;
+		if (ctx->rflags & BIT(FLAGS_HMAC)) {
+			val |= SHA_REG_MODE_HMAC_KEY_PROC;
+			omap4_sham_write_n(dd, SHA_REG_ODIGEST, (u32 *) bctx->keypad,
+					 SHA2_MD5_BLOCK_SIZE / sizeof(u32));
+			ctx->digcnt += SHA2_MD5_BLOCK_SIZE;
+		}
+	}
+	if (final) {
+		val |= SHA_REG_MODE_CLOSE_HASH;
+
+		if (ctx->rflags & BIT(FLAGS_HMAC)) {
+			val |= SHA_REG_MODE_HMAC_OUTER_HASH;
+		}
+	}
+
+	mask = SHA_REG_MODE_ALGO_CONSTANT | SHA_REG_MODE_CLOSE_HASH |
+		SHA_REG_MODE_ALGO_MASK | SHA_REG_MODE_HMAC_OUTER_HASH |
+		SHA_REG_MODE_HMAC_KEY_PROC;
+
+	dev_dbg(dd->dev, "ctrl: %08x, flags: %08lx\n", val, ctx->rflags);
+	omap4_sham_write_mask(dd, SHA_REG_MODE, val, mask);
+	omap4_sham_write(dd, SHA_REG_IRQENA, SHA_REG_IRQENA_OUTPUT_RDY);
+	omap4_sham_write_mask(dd, SHA_REG_SYSCFG,
+			    SHA_REG_SYSCFG_SIT_EN | (dma ? SHA_REG_SYSCFG_SDMA_EN : 0),
+			    SHA_REG_SYSCFG_SIT_EN | SHA_REG_SYSCFG_SDMA_EN);
+}
+
+static int omap4_sham_xmit_cpu(struct omap4_sham_dev *dd, const u8 *buf,
+			      size_t length, int final)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	int count, len32;
+	const u32 *buffer = (const u32 *)buf;
+
+	dev_dbg(dd->dev, "xmit_cpu: digcnt: %d, length: %d, final: %d\n",
+						ctx->digcnt, length, final);
+
+	if (final)
+		set_bit(FLAGS_FINAL, &dd->dflags); /* catch last interrupt */
+
+	set_bit(FLAGS_CPU, &dd->dflags);
+
+	omap4_sham_write_ctrl(dd, final, 0);
+	/*
+	 * Setting the length field will also trigger start of
+	 * processing.
+	 */
+	omap4_sham_write(dd, SHA_REG_LENGTH, length);
+
+	/* short-circuit zero length */
+	if (likely(length)) {
+		ctx->digcnt += length;
+
+		if (omap4_sham_wait(dd, SHA_REG_IRQSTATUS, SHA_REG_IRQSTATUS_INPUT_RDY))
+			return -ETIMEDOUT;
+
+		len32 = DIV_ROUND_UP(length, sizeof(u32));
+
+		for (count = 0; count < len32; count++)
+			omap4_sham_write(dd, SHA_REG_DATA_N(count), buffer[count]);
+	}
+
+	return -EINPROGRESS;
+}
+
+static int omap4_sham_xmit_dma(struct omap4_sham_dev *dd, dma_addr_t dma_addr,
+			      size_t length, int final)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	int nblocks;
+	struct edmacc_param p_ram;
+
+	dev_dbg(dd->dev, "xmit_dma: digcnt: %d, length: %d, final: %d\n",
+						ctx->digcnt, length, final);
+
+	nblocks = DIV_ROUND_UP(length, SHA2_MD5_BLOCK_SIZE);
+
+	/* EDMA IN */
+	p_ram.opt	   = TCINTEN |
+		EDMA_TCC(EDMA_CHAN_SLOT(dd->dma_lch));
+	p_ram.src	   = dma_addr;
+	p_ram.a_b_cnt      = SHA2_MD5_BLOCK_SIZE | nblocks << 16;
+	p_ram.dst          = dd->phys_base + SHA_REG_DATA;
+	p_ram.src_dst_bidx = SHA2_MD5_BLOCK_SIZE;
+	p_ram.link_bcntrld = 1 << 16 | 0xFFFF;
+	p_ram.src_dst_cidx = 0;
+	p_ram.ccnt         = 1;
+	edma_write_slot(dd->dma_lch, &p_ram);
+
+	omap4_sham_write_ctrl(dd, final, 1);
+
+	ctx->digcnt += length;
+
+	if (final)
+		set_bit(FLAGS_FINAL, &dd->dflags); /* catch last interrupt */
+
+	set_bit(FLAGS_DMA_ACTIVE, &dd->dflags);
+
+	edma_start(dd->dma_lch);
+
+	/*
+	 * Setting the length field will also trigger start of
+	 * processing.
+	 */
+	omap4_sham_write(dd, SHA_REG_LENGTH, length);
+
+	return -EINPROGRESS;
+}
+
+static size_t omap4_sham_append_buffer(struct omap4_sham_reqctx *ctx,
+				const u8 *data, size_t length)
+{
+	size_t count = min(length, ctx->buflen - ctx->bufcnt);
+
+	count = min(count, ctx->total);
+	if (count <= 0)
+		return 0;
+	memcpy(ctx->buffer + ctx->bufcnt, data, count);
+	ctx->bufcnt += count;
+
+	return count;
+}
+
+static size_t omap4_sham_append_sg(struct omap4_sham_reqctx *ctx)
+{
+	size_t count;
+
+	while (ctx->sg) {
+		if (ctx->sg->length) {
+			count = omap4_sham_append_buffer(ctx,
+							 sg_virt(ctx->sg) + ctx->offset,
+							 ctx->sg->length - ctx->offset);
+			if (!count)
+				break;
+			ctx->offset += count;
+			ctx->total -= count;
+		}
+		if (ctx->offset == ctx->sg->length) {
+			ctx->sg = sg_next(ctx->sg);
+			if (ctx->sg)
+				ctx->offset = 0;
+			else
+				ctx->total = 0;
+		}
+	}
+
+	return 0;
+}
+
+static int omap4_sham_xmit_dma_map(struct omap4_sham_dev *dd,
+				  struct omap4_sham_reqctx *ctx,
+				  size_t length, int final)
+{
+	ctx->dma_addr = dma_map_single(dd->dev, ctx->buffer, ctx->buflen,
+				       DMA_TO_DEVICE);
+	if (dma_mapping_error(dd->dev, ctx->dma_addr)) {
+		dev_err(dd->dev, "dma %u bytes error\n", ctx->buflen);
+		return -EINVAL;
+	}
+
+	ctx->rflags &= ~BIT(FLAGS_SG);
+
+	/* next call does not fail... so no unmap in the case of error */
+	return omap4_sham_xmit_dma(dd, ctx->dma_addr, length, final);
+}
+
+static int omap4_sham_update_dma_slow(struct omap4_sham_dev *dd)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	unsigned int final;
+	size_t count;
+
+	omap4_sham_append_sg(ctx);
+
+	final = (ctx->rflags & BIT(FLAGS_FINUP)) && !ctx->total;
+
+	dev_dbg(dd->dev, "slow: bufcnt: %u, digcnt: %d, final: %d\n",
+					 ctx->bufcnt, ctx->digcnt, final);
+
+	if (final || (ctx->bufcnt == ctx->buflen && ctx->total)) {
+		count = ctx->bufcnt;
+		ctx->bufcnt = 0;
+		return omap4_sham_xmit_dma_map(dd, ctx, count, final);
+	}
+
+	return 0;
+}
+
+/* Start address alignment */
+#define SG_AA(sg)	(IS_ALIGNED(sg->offset, sizeof(u32)))
+/* SHA1 block size alignment */
+#define SG_SA(sg)	(IS_ALIGNED(sg->length, SHA2_MD5_BLOCK_SIZE))
+
+static int omap4_sham_update_dma_start(struct omap4_sham_dev *dd)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	unsigned int length, final, tail;
+	struct scatterlist *sg;
+
+	if (!ctx->total)
+		return 0;
+
+	if (ctx->bufcnt || ctx->offset)
+		return omap4_sham_update_dma_slow(dd);
+
+	dev_dbg(dd->dev, "fast: digcnt: %d, bufcnt: %u, total: %u\n",
+			ctx->digcnt, ctx->bufcnt, ctx->total);
+
+	sg = ctx->sg;
+
+	if (!SG_AA(sg))
+		return omap4_sham_update_dma_slow(dd);
+
+	if (!sg_is_last(sg) && !SG_SA(sg))
+		/* size is not SHA1_BLOCK_SIZE aligned */
+		return omap4_sham_update_dma_slow(dd);
+
+	length = min(ctx->total, sg->length);
+
+	if (sg_is_last(sg)) {
+		if (!(ctx->rflags & BIT(FLAGS_FINUP))) {
+			/* not last sg must be SHA2_MD5_BLOCK_SIZE aligned */
+			tail = length & (SHA2_MD5_BLOCK_SIZE - 1);
+			/* without finup() we need one block to close hash */
+			if (!tail)
+				tail = SHA2_MD5_BLOCK_SIZE;
+			length -= tail;
+		}
+	}
+
+	if (!dma_map_sg(dd->dev, ctx->sg, 1, DMA_TO_DEVICE)) {
+		dev_err(dd->dev, "dma_map_sg  error\n");
+		return -EINVAL;
+	}
+
+	ctx->rflags |= BIT(FLAGS_SG);
+
+	ctx->total -= length;
+	ctx->offset = length; /* offset where to start slow */
+
+	final = (ctx->rflags & BIT(FLAGS_FINUP)) && !ctx->total;
+
+	/* next call does not fail... so no unmap in the case of error */
+	return omap4_sham_xmit_dma(dd, sg_dma_address(ctx->sg), length, final);
+}
+
+static int omap4_sham_update_cpu(struct omap4_sham_dev *dd)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+	int bufcnt;
+
+	omap4_sham_append_sg(ctx);
+	bufcnt = ctx->bufcnt;
+	ctx->bufcnt = 0;
+
+	return omap4_sham_xmit_cpu(dd, ctx->buffer, bufcnt, 1);
+}
+
+static int omap4_sham_update_dma_stop(struct omap4_sham_dev *dd)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(dd->req);
+
+	edma_stop(dd->dma_lch);
+	if (ctx->rflags & BIT(FLAGS_SG)) {
+		dma_unmap_sg(dd->dev, ctx->sg, 1, DMA_TO_DEVICE);
+		if (ctx->sg->length == ctx->offset) {
+			ctx->sg = sg_next(ctx->sg);
+			if (ctx->sg)
+				ctx->offset = 0;
+		}
+	} else {
+		dma_unmap_single(dd->dev, ctx->dma_addr, ctx->buflen,
+				 DMA_TO_DEVICE);
+	}
+
+	return 0;
+}
+
+static int omap4_sham_init(struct ahash_request *req)
+{
+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);
+	struct omap4_sham_ctx *tctx = crypto_ahash_ctx(tfm);
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	struct omap4_sham_dev *dd = NULL, *tmp;
+
+	spin_lock_bh(&sham.lock);
+	if (!tctx->dd) {
+		list_for_each_entry(tmp, &sham.dev_list, list) {
+			dd = tmp;
+			break;
+		}
+		tctx->dd = dd;
+	} else {
+		dd = tctx->dd;
+	}
+	spin_unlock_bh(&sham.lock);
+
+	ctx->dd = dd;
+
+	ctx->rflags = 0;
+
+	dev_dbg(dd->dev, "init: digest size: %d (@0x%08lx)\n",
+		crypto_ahash_digestsize(tfm), dd->phys_base);
+
+	switch (crypto_ahash_digestsize(tfm)) {
+	case MD5_DIGEST_SIZE:
+		ctx->rflags |= FLAGS_MD5;
+		break;
+	case SHA1_DIGEST_SIZE:
+		ctx->rflags |= FLAGS_SHA1;
+		break;
+	case SHA224_DIGEST_SIZE:
+		ctx->rflags |= FLAGS_SHA224;
+		break;
+	case SHA256_DIGEST_SIZE:
+		ctx->rflags |= FLAGS_SHA256;
+		break;
+	}
+
+	ctx->bufcnt = 0;
+	ctx->digcnt = 0;
+	ctx->buflen = BUFLEN;
+
+	if (tctx->cflags & BIT(FLAGS_HMAC)) {
+		ctx->rflags |= BIT(FLAGS_HMAC);
+	}
+
+	return 0;
+}
+
+static int omap4_sham_update_req(struct omap4_sham_dev *dd)
+{
+	struct ahash_request *req = dd->req;
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	int err;
+
+	dev_dbg(dd->dev, "update_req: total: %u, digcnt: %d, finup: %d\n",
+		ctx->total, ctx->digcnt, (ctx->rflags & BIT(FLAGS_FINUP)) != 0);
+
+	if (ctx->rflags & BIT(FLAGS_CPU))
+		err = omap4_sham_update_cpu(dd);
+	else
+		err = omap4_sham_update_dma_start(dd);
+
+	/* wait for dma completion before can take more data */
+	dev_dbg(dd->dev, "update: err: %d, digcnt: %d\n", err, ctx->digcnt);
+
+	return err;
+}
+
+static int omap4_sham_final_req(struct omap4_sham_dev *dd)
+{
+	struct ahash_request *req = dd->req;
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	int err = 0;
+
+	if (ctx->bufcnt <= SHA2_MD5_BLOCK_SIZE) /* faster to handle single block with CPU */
+		err = omap4_sham_xmit_cpu(dd, ctx->buffer, ctx->bufcnt, 1);
+	else
+		err = omap4_sham_xmit_dma_map(dd, ctx, ctx->bufcnt, 1);
+
+	ctx->bufcnt = 0;
+
+	dev_dbg(dd->dev, "final_req: err: %d\n", err);
+
+	return err;
+}
+
+static int omap4_sham_finish(struct ahash_request *req)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	struct omap4_sham_dev *dd = ctx->dd;
+
+	omap4_sham_copy_ready_hash(req);
+	dev_dbg(dd->dev, "digcnt: %d, bufcnt: %d\n", ctx->digcnt, ctx->bufcnt);
+
+	return 0;
+}
+
+static void omap4_sham_finish_req(struct ahash_request *req, int err)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	struct omap4_sham_dev *dd = ctx->dd;
+
+	if (!err) {
+		omap4_sham_copy_hash(req, 1);
+		if (test_bit(FLAGS_FINAL, &dd->dflags)) {
+			err = omap4_sham_finish(req);
+		}
+	} else {
+		ctx->rflags |= BIT(FLAGS_ERROR);
+	}
+
+	/* atomic operation is not needed here */
+	dd->dflags &= ~(BIT(FLAGS_BUSY) | BIT(FLAGS_FINAL) | BIT(FLAGS_CPU) |
+			BIT(FLAGS_DMA_READY) | BIT(FLAGS_OUTPUT_READY));
+
+	if (req->base.complete)
+		req->base.complete(&req->base, err);
+
+	/* handle new request */
+	tasklet_schedule(&dd->done_task);
+}
+
+static int omap4_sham_handle_queue(struct omap4_sham_dev *dd,
+				  struct ahash_request *req)
+{
+	struct crypto_async_request *async_req, *backlog;
+	struct omap4_sham_reqctx *ctx;
+	unsigned long flags;
+	int err = 0, ret = 0;
+
+	spin_lock_irqsave(&dd->lock, flags);
+	if (req)
+		ret = ahash_enqueue_request(&dd->queue, req);
+	if (test_bit(FLAGS_BUSY, &dd->dflags)) {
+		spin_unlock_irqrestore(&dd->lock, flags);
+		return ret;
+	}
+	backlog = crypto_get_backlog(&dd->queue);
+	async_req = crypto_dequeue_request(&dd->queue);
+	if (async_req)
+		set_bit(FLAGS_BUSY, &dd->dflags);
+	spin_unlock_irqrestore(&dd->lock, flags);
+
+	if (!async_req)
+		return ret;
+
+	if (backlog)
+		backlog->complete(backlog, -EINPROGRESS);
+
+	req = ahash_request_cast(async_req);
+	dd->req = req;
+	ctx = ahash_request_ctx(req);
+
+	dev_dbg(dd->dev, "handling new req, op: %lu, nbytes: %d\n",
+						ctx->op, req->nbytes);
+
+	if (!test_bit(FLAGS_INIT, &dd->dflags)) {
+		set_bit(FLAGS_INIT, &dd->dflags);
+		dd->err = 0;
+	}
+
+	if (ctx->digcnt)	/* not initial request - restore hash */
+		omap4_sham_copy_hash(req, 0);
+
+	if (ctx->op == OP_UPDATE) {
+		err = omap4_sham_update_req(dd);
+		if (err != -EINPROGRESS && (ctx->rflags & BIT(FLAGS_FINUP)))
+			/* no final() after finup() */
+			err = omap4_sham_final_req(dd);
+	} else if (ctx->op == OP_FINAL) {
+		err = omap4_sham_final_req(dd);
+	}
+
+	if (err != -EINPROGRESS)
+		/* done_task will not finish it, so do it here */
+		omap4_sham_finish_req(req, err);
+
+	dev_dbg(dd->dev, "exit, err: %d\n", err);
+
+	return ret;
+}
+
+static int omap4_sham_enqueue(struct ahash_request *req, unsigned int op)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	struct omap4_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);
+	struct omap4_sham_dev *dd = tctx->dd;
+
+	ctx->op = op;
+
+	return omap4_sham_handle_queue(dd, req);
+}
+
+static int omap4_sham_update(struct ahash_request *req)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+
+	if (!(ctx->rflags & BIT(FLAGS_FINUP)))
+		if (!req->nbytes)
+			return 0;
+
+	ctx->total = req->nbytes;
+	ctx->sg = req->src;
+	ctx->offset = 0;
+
+	if (ctx->rflags & BIT(FLAGS_FINUP)) {
+		if (ctx->bufcnt + ctx->total <= SHA2_MD5_BLOCK_SIZE) {
+			/*
+			 * faster to use CPU for short transfers
+			 */
+			ctx->rflags |= BIT(FLAGS_CPU);
+		}
+	} else if (ctx->bufcnt + ctx->total < ctx->buflen) {
+		omap4_sham_append_sg(ctx);
+		return 0;
+	}
+
+	return omap4_sham_enqueue(req, OP_UPDATE);
+}
+
+static int omap4_sham_shash_digest(struct crypto_shash *shash, u32 flags,
+				  const u8 *data, unsigned int len, u8 *out)
+{
+	struct {
+		struct shash_desc shash;
+		char ctx[crypto_shash_descsize(shash)];
+	} desc;
+
+	desc.shash.tfm = shash;
+	desc.shash.flags = flags & CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	return crypto_shash_digest(&desc.shash, data, len, out);
+}
+
+static int omap4_sham_final(struct ahash_request *req)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+
+	ctx->rflags |= BIT(FLAGS_FINUP);
+
+	if (ctx->rflags & BIT(FLAGS_ERROR))
+		return 0; /* uncompleted hash is not needed */
+
+	return omap4_sham_enqueue(req, OP_FINAL);
+}
+
+static int omap4_sham_finup(struct ahash_request *req)
+{
+	struct omap4_sham_reqctx *ctx = ahash_request_ctx(req);
+	int err1, err2;
+
+	ctx->rflags |= BIT(FLAGS_FINUP);
+
+	err1 = omap4_sham_update(req);
+	if (err1 == -EINPROGRESS || err1 == -EBUSY)
+		return err1;
+	/*
+	 * final() has to be always called to cleanup resources
+	 * even if update() failed, except EINPROGRESS
+	 */
+	err2 = omap4_sham_final(req);
+
+	return err1 ?: err2;
+}
+
+static int omap4_sham_digest(struct ahash_request *req)
+{
+	return omap4_sham_init(req) ?: omap4_sham_finup(req);
+}
+
+static int omap4_sham_setkey(struct crypto_ahash *tfm, const u8 *key,
+		      unsigned int keylen)
+{
+	struct omap4_sham_ctx *tctx = crypto_ahash_ctx(tfm);
+	struct omap4_sham_hmac_ctx *bctx = tctx->base;
+	int bs = crypto_shash_blocksize(bctx->shash);
+	int ds = crypto_shash_digestsize(bctx->shash);
+	int err;
+
+	/* If key is longer than block size, use hash of original key */
+	if (keylen > bs) {
+		err = crypto_shash_setkey(tctx->fallback, key, keylen) ?:
+			omap4_sham_shash_digest(bctx->shash,
+				crypto_shash_get_flags(bctx->shash),
+				key, keylen, bctx->keypad);
+		if (err)
+			return err;
+		keylen = ds;
+	} else {
+		memcpy(bctx->keypad, key, keylen);
+	}
+
+	/* zero-pad the key (or its digest) */
+	if (keylen < bs)
+		memset(bctx->keypad + keylen, 0, bs - keylen);
+
+	return 0;
+}
+
+static int omap4_sham_cra_init_alg(struct crypto_tfm *tfm, const char *alg_base)
+{
+	struct omap4_sham_ctx *tctx = crypto_tfm_ctx(tfm);
+	const char *alg_name = crypto_tfm_alg_name(tfm);
+
+	/* Allocate a fallback and abort if it failed. */
+	tctx->fallback = crypto_alloc_shash(alg_name, 0,
+					    CRYPTO_ALG_NEED_FALLBACK);
+	if (IS_ERR(tctx->fallback)) {
+		pr_err("omap4-sham: fallback driver '%s' "
+				"could not be loaded.\n", alg_name);
+		return PTR_ERR(tctx->fallback);
+	}
+
+	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
+				 sizeof(struct omap4_sham_reqctx) + BUFLEN);
+
+	if (alg_base) {
+		struct omap4_sham_hmac_ctx *bctx = tctx->base;
+		tctx->cflags |= BIT(FLAGS_HMAC);
+		bctx->shash = crypto_alloc_shash(alg_base, 0,
+						CRYPTO_ALG_NEED_FALLBACK);
+		if (IS_ERR(bctx->shash)) {
+			pr_err("omap4-sham: base driver '%s' "
+					"could not be loaded.\n", alg_base);
+			crypto_free_shash(tctx->fallback);
+			return PTR_ERR(bctx->shash);
+		}
+
+	}
+
+	return 0;
+}
+
+static int omap4_sham_cra_init(struct crypto_tfm *tfm)
+{
+	return omap4_sham_cra_init_alg(tfm, NULL);
+}
+
+static int omap4_sham_cra_sha1_init(struct crypto_tfm *tfm)
+{
+	return omap4_sham_cra_init_alg(tfm, "sha1");
+}
+
+static int omap4_sham_cra_sha224_init(struct crypto_tfm *tfm)
+{
+	return omap4_sham_cra_init_alg(tfm, "sha224");
+}
+
+static int omap4_sham_cra_sha256_init(struct crypto_tfm *tfm)
+{
+	return omap4_sham_cra_init_alg(tfm, "sha256");
+}
+
+static int omap4_sham_cra_md5_init(struct crypto_tfm *tfm)
+{
+	return omap4_sham_cra_init_alg(tfm, "md5");
+}
+
+static void omap4_sham_cra_exit(struct crypto_tfm *tfm)
+{
+	struct omap4_sham_ctx *tctx = crypto_tfm_ctx(tfm);
+
+	crypto_free_shash(tctx->fallback);
+	tctx->fallback = NULL;
+
+	if (tctx->cflags & BIT(FLAGS_HMAC)) {
+		struct omap4_sham_hmac_ctx *bctx = tctx->base;
+		crypto_free_shash(bctx->shash);
+	}
+}
+
+static struct ahash_alg algs[] = {
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.halg.digestsize	= SHA1_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "sha1",
+		.cra_driver_name	= "omap4-sha1",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA1_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx),
+		.cra_alignmask		= 0,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.halg.digestsize	= SHA224_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "sha224",
+		.cra_driver_name	= "omap4-sha224",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA224_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx),
+		.cra_alignmask		= 0,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.halg.digestsize	= SHA256_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "sha256",
+		.cra_driver_name	= "omap4-sha256",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA256_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx),
+		.cra_alignmask		= 0,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.halg.digestsize	= MD5_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "md5",
+		.cra_driver_name	= "omap4-md5",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA1_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx),
+		.cra_alignmask		= AM33X_ALIGN_MASK,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.setkey		= omap4_sham_setkey,
+	.halg.digestsize	= SHA1_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "hmac(sha1)",
+		.cra_driver_name	= "omap4-hmac-sha1",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA1_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx) +
+					sizeof(struct omap4_sham_hmac_ctx),
+		.cra_alignmask		= AM33X_ALIGN_MASK,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_sha1_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.setkey		= omap4_sham_setkey,
+	.halg.digestsize	= SHA224_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "hmac(sha224)",
+		.cra_driver_name	= "omap4-hmac-sha224",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA224_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx) +
+					sizeof(struct omap4_sham_hmac_ctx),
+		.cra_alignmask		= AM33X_ALIGN_MASK,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_sha224_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.setkey		= omap4_sham_setkey,
+	.halg.digestsize	= SHA256_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "hmac(sha256)",
+		.cra_driver_name	= "omap4-hmac-sha256",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA256_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx) +
+					sizeof(struct omap4_sham_hmac_ctx),
+		.cra_alignmask		= AM33X_ALIGN_MASK,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_sha256_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+},
+{
+	.init		= omap4_sham_init,
+	.update		= omap4_sham_update,
+	.final		= omap4_sham_final,
+	.finup		= omap4_sham_finup,
+	.digest		= omap4_sham_digest,
+	.setkey		= omap4_sham_setkey,
+	.halg.digestsize	= MD5_DIGEST_SIZE,
+	.halg.base	= {
+		.cra_name		= "hmac(md5)",
+		.cra_driver_name	= "omap4-hmac-md5",
+		.cra_priority		= 300,
+		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
+						CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_NEED_FALLBACK,
+		.cra_blocksize		= SHA1_BLOCK_SIZE,
+		.cra_ctxsize		= sizeof(struct omap4_sham_ctx) +
+					sizeof(struct omap4_sham_hmac_ctx),
+		.cra_alignmask		= AM33X_ALIGN_MASK,
+		.cra_module		= THIS_MODULE,
+		.cra_init		= omap4_sham_cra_md5_init,
+		.cra_exit		= omap4_sham_cra_exit,
+	}
+}
+};
+
+static void omap4_sham_done_task(unsigned long data)
+{
+	struct omap4_sham_dev *dd = (struct omap4_sham_dev *)data;
+	int err = 0;
+
+	if (!test_bit(FLAGS_BUSY, &dd->dflags)) {
+		omap4_sham_handle_queue(dd, NULL);
+		return;
+	}
+
+	if (test_bit(FLAGS_CPU, &dd->dflags)) {
+		if (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->dflags))
+			goto finish;
+	} else if (test_bit(FLAGS_OUTPUT_READY, &dd->dflags)) {
+		if (test_and_clear_bit(FLAGS_DMA_ACTIVE, &dd->dflags)) {
+			omap4_sham_update_dma_stop(dd);
+			if (dd->err) {
+				err = dd->err;
+				goto finish;
+			}
+		}
+		if (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->dflags)) {
+			/* hash or semi-hash ready */
+			clear_bit(FLAGS_DMA_READY, &dd->dflags);
+			err = omap4_sham_update_dma_start(dd);
+			if (err != -EINPROGRESS)
+				goto finish;
+		}
+	}
+
+	return;
+
+finish:
+	dev_dbg(dd->dev, "update done: err: %d\n", err);
+	/* finish current request */
+	omap4_sham_finish_req(dd->req, err);
+}
+
+static irqreturn_t omap4_sham_irq(int irq, void *dev_id)
+{
+	struct omap4_sham_dev *dd = dev_id;
+
+#if 0
+	if (unlikely(test_bit(FLAGS_FINAL, &dd->flags)))
+		/* final -> allow device to go to power-saving mode */
+		omap4_sham_write_mask(dd, SHA_REG_CTRL, 0, SHA_REG_CTRL_LENGTH);
+#endif
+
+	/* TODO check whether the result needs to be read out here,
+	   or if we just disable the interrupt */
+	omap4_sham_write_mask(dd, SHA_REG_SYSCFG, 0, SHA_REG_SYSCFG_SIT_EN);
+
+	if (!test_bit(FLAGS_BUSY, &dd->dflags)) {
+		dev_warn(dd->dev, "Interrupt when no active requests.\n");
+	} else {
+		set_bit(FLAGS_OUTPUT_READY, &dd->dflags);
+		tasklet_schedule(&dd->done_task);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void omap4_sham_dma_callback(unsigned int lch, u16 ch_status, void *data)
+{
+	struct omap4_sham_dev *dd = data;
+
+	edma_stop(lch);
+
+	if (ch_status != DMA_COMPLETE) {
+		pr_err("omap4-sham DMA error status: 0x%hx\n", ch_status);
+		dd->err = -EIO;
+		clear_bit(FLAGS_INIT, &dd->dflags); /* request to re-initialize */
+	}
+
+	set_bit(FLAGS_DMA_READY, &dd->dflags);
+	tasklet_schedule(&dd->done_task);
+}
+
+static int omap4_sham_dma_init(struct omap4_sham_dev *dd)
+{
+	dd->dma_lch = -1;
+
+	dd->dma_lch = edma_alloc_channel(dd->dma, omap4_sham_dma_callback, dd, EVENTQ_2);
+	if (dd->dma_lch < 0) {
+		dev_err(dd->dev, "Unable to request EDMA channel\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static void omap4_sham_dma_cleanup(struct omap4_sham_dev *dd)
+{
+	if (dd->dma_lch >= 0) {
+		edma_free_channel(dd->dma_lch);
+		dd->dma_lch = -1;
+	}
+}
+
+static int __devinit omap4_sham_probe(struct platform_device *pdev)
+{
+	struct omap4_sham_dev *dd;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int err, i, j;
+	u32 reg;
+
+	dd = kzalloc(sizeof(struct omap4_sham_dev), GFP_KERNEL);
+	if (dd == NULL) {
+		dev_err(dev, "unable to alloc data struct.\n");
+		err = -ENOMEM;
+		goto data_err;
+	}
+	dd->dev = dev;
+	platform_set_drvdata(pdev, dd);
+
+	INIT_LIST_HEAD(&dd->list);
+	spin_lock_init(&dd->lock);
+	tasklet_init(&dd->done_task, omap4_sham_done_task, (unsigned long)dd);
+	crypto_init_queue(&dd->queue, AM33X_SHAM_QUEUE_LENGTH);
+
+	dd->irq = -1;
+
+	/* Get the base address */
+	//res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	//if (!res) {
+	//	dev_err(dev, "no MEM resource info\n");
+	//	err = -ENODEV;
+	//	goto res_err;
+	//}
+
+	//dd->phys_base = res->start;
+	dd->phys_base = AM33XX_SHA1MD5_P_BASE;
+
+	/* Get the DMA */
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (!res) {
+		dev_err(dev, "no DMA resource info\n");
+		err = -ENODEV;
+		goto res_err;
+	}
+	dd->dma = res->start;
+
+	/* Get the IRQ */
+	dd->irq = platform_get_irq(pdev,  0);
+	if (dd->irq < 0) {
+		dev_err(dev, "no IRQ resource info\n");
+		err = dd->irq;
+		goto res_err;
+	}
+
+	err = request_irq(dd->irq, omap4_sham_irq,
+			IRQF_TRIGGER_LOW, dev_name(dev), dd);
+	if (err) {
+		dev_err(dev, "unable to request irq.\n");
+		goto res_err;
+	}
+
+	err = omap4_sham_dma_init(dd);
+	if (err)
+		goto dma_err;
+
+	pm_runtime_enable(dev);
+	udelay(1);
+	pm_runtime_get_sync(dev);
+	udelay(1);
+
+	dd->io_base = ioremap(dd->phys_base, SZ_4K);
+	if (!dd->io_base) {
+		dev_err(dev, "can't ioremap\n");
+		err = -ENOMEM;
+		goto io_err;
+	}
+
+	reg = omap4_sham_read(dd, SHA_REG_REV);
+
+	dev_info(dev, "AM33X SHA/MD5 hw accel rev: %u.%02u\n",
+		 (reg & SHA_REG_REV_X_MAJOR_MASK) >> 8, reg & SHA_REG_REV_Y_MINOR_MASK);
+
+	spin_lock(&sham.lock);
+	list_add_tail(&dd->list, &sham.dev_list);
+	spin_unlock(&sham.lock);
+
+	for (i = 0; i < ARRAY_SIZE(algs); i++) {
+		err = crypto_register_ahash(&algs[i]);
+		if (err)
+			goto err_algs;
+	}
+
+	pr_info("probe() done\n");
+
+	return 0;
+
+err_algs:
+	for (j = 0; j < i; j++)
+		crypto_unregister_ahash(&algs[j]);
+	iounmap(dd->io_base);
+io_err:
+	pm_runtime_put_sync(dev);
+	udelay(1);
+	pm_runtime_disable(dev);
+	udelay(1);
+
+//clk_err:
+//	omap4_sham_dma_cleanup(dd);
+
+dma_err:
+	if (dd->irq >= 0)
+		free_irq(dd->irq, dd);
+res_err:
+	kfree(dd);
+	dd = NULL;
+data_err:
+	dev_err(dev, "initialization failed.\n");
+
+	return err;
+}
+
+static int __devexit omap4_sham_remove(struct platform_device *pdev)
+{
+	static struct omap4_sham_dev *dd;
+	int i;
+
+	dd = platform_get_drvdata(pdev);
+	if (!dd)
+		return -ENODEV;
+	spin_lock(&sham.lock);
+	list_del(&dd->list);
+	spin_unlock(&sham.lock);
+	for (i = 0; i < ARRAY_SIZE(algs); i++)
+		crypto_unregister_ahash(&algs[i]);
+	tasklet_kill(&dd->done_task);
+	iounmap(dd->io_base);
+	pm_runtime_put_sync(&pdev->dev);
+	udelay(1);
+	pm_runtime_disable(&pdev->dev);
+	udelay(1);
+
+	omap4_sham_dma_cleanup(dd);
+	if (dd->irq >= 0)
+		free_irq(dd->irq, dd);
+	kfree(dd);
+	dd = NULL;
+
+	return 0;
+}
+
+static int omap4_sham_suspend(struct device *dev)
+{
+	pr_debug("#### Crypto: Suspend call ####\n");
+
+	return 0;
+}
+
+
+static int omap4_sham_resume(struct device *dev)
+{
+	pr_debug("#### Crypto: resume call ####\n");
+
+	return 0;
+}
+
+static struct dev_pm_ops omap4_sham_dev_pm_ops = {
+	.suspend	= omap4_sham_suspend,
+	.resume		= omap4_sham_resume,
+	.runtime_suspend = omap4_sham_suspend,
+	.runtime_resume = omap4_sham_resume,
+};
+
+static struct platform_driver omap4_sham_driver = {
+	.probe	= omap4_sham_probe,
+	.remove	= omap4_sham_remove,
+	.driver	= {
+		.name	= "omap4-sham",
+		.owner	= THIS_MODULE,
+		.pm		= &omap4_sham_dev_pm_ops
+	},
+};
+
+static int __init omap4_sham_mod_init(void)
+{
+	pr_info("loading AM33X SHA/MD5 driver\n");
+
+	if (!cpu_is_am33xx() || omap_type() != OMAP2_DEVICE_TYPE_GP) {
+		pr_err("Unsupported cpu\n");
+		return -ENODEV;
+	}
+
+	return platform_driver_register(&omap4_sham_driver);
+}
+
+static void __exit omap4_sham_mod_exit(void)
+{
+	platform_driver_unregister(&omap4_sham_driver);
+}
+
+module_init(omap4_sham_mod_init);
+module_exit(omap4_sham_mod_exit);
+
+MODULE_DESCRIPTION("AM33x SHA/MD5 hw acceleration support.");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Herman Schuurman");
diff --git a/drivers/crypto/omap4.h b/drivers/crypto/omap4.h
new file mode 100644
index 0000000..d9d6315
--- /dev/null
+++ b/drivers/crypto/omap4.h
@@ -0,0 +1,192 @@
+/*
+ * drivers/crypto/omap4.h
+ *
+ * Copyright © 2011 Texas Instruments Incorporated
+ * Author: Greg Turner
+ *
+ * Adapted from Netra/Centaurus crypto driver
+ * Copyright © 2011 Texas Instruments Incorporated
+ * Author: Herman Schuurman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __DRIVERS_CRYPTO_AM33X_H
+#define __DRIVERS_CRYPTO_AM33X_H
+
+/* ==================================================================== */
+/** Crypto subsystem module layout
+ */
+/* ==================================================================== */
+
+#define AM33X_AES_CLKCTRL	(AM33XX_PRCM_BASE + 0x00000094)
+#define AM33X_SHA_CLKCTRL	(AM33XX_PRCM_BASE + 0x000000A0)
+
+#define FLD_MASK(start, end)		(((1 << ((start) - (end) + 1)) - 1) << (end))
+#define FLD_VAL(val, start, end)	(((val) << (end)) & FLD_MASK(start, end))
+
+/* ==================================================================== */
+/** AES module layout
+ */
+/* ==================================================================== */
+
+#define	AES_REG_KEY2(x)			(0x1C - ((x ^ 0x01) * 0x04))
+#define	AES_REG_KEY1(x)			(0x3C - ((x ^ 0x01) * 0x04))
+#define	AES_REG_IV(x)			(0x40 + ((x) * 0x04))
+
+#define	AES_REG_CTRL			0x50
+#define	AES_REG_CTRL_CTX_RDY		(1 << 31)
+#define	AES_REG_CTRL_SAVE_CTX_RDY	(1 << 30)
+#define	AES_REG_CTRL_SAVE_CTX		(1 << 29)
+#define	AES_REG_CTRL_CCM_M_MASK		(7 << 22)
+#define	AES_REG_CTRL_CCM_M_SHFT		22
+#define	AES_REG_CTRL_CCM_L_MASK		(7 << 19)
+#define	AES_REG_CTRL_CCM_L_SHFT		19
+#define	AES_REG_CTRL_CCM		(1 << 18)
+#define	AES_REG_CTRL_GCM		(3 << 16)
+#define	AES_REG_CTRL_CBCMAC		(1 << 15)
+#define	AES_REG_CTRL_F9			(1 << 14)
+#define	AES_REG_CTRL_F8			(1 << 13)
+#define	AES_REG_CTRL_XTS_MASK		(3 << 11)
+#define	 AES_REG_CTRL_XTS_01		(1 << 11)
+#define	 AES_REG_CTRL_XTS_10		(2 << 11)
+#define	 AES_REG_CTRL_XTS_11		(3 << 11)
+#define	AES_REG_CTRL_CFB		(1 << 10)
+#define	AES_REG_CTRL_ICM		(1 << 9)
+#define	AES_REG_CTRL_CTR_WIDTH_MASK	(3 << 7)
+#define	 AES_REG_CTRL_CTR_WIDTH_32	(0 << 7)
+#define	 AES_REG_CTRL_CTR_WIDTH_64	(1 << 7)
+#define	 AES_REG_CTRL_CTR_WIDTH_96	(2 << 7)
+#define	 AES_REG_CTRL_CTR_WIDTH_128	(3 << 7)
+#define	AES_REG_CTRL_CTR		(1 << 6)
+#define	AES_REG_CTRL_CBC		(1 << 5)
+#define	AES_REG_CTRL_KEY_SIZE_MASK	(3 << 3)
+#define	 AES_REG_CTRL_KEY_SIZE_128	(1 << 3)
+#define	 AES_REG_CTRL_KEY_SIZE_192	(2 << 3)
+#define	 AES_REG_CTRL_KEY_SIZE_256	(3 << 3)
+#define	AES_REG_CTRL_DIRECTION		(1 << 2)
+#define	AES_REG_CTRL_INPUT_RDY		(1 << 1)
+#define	AES_REG_CTRL_OUTPUT_RDY		(1 << 0)
+
+#define	AES_REG_LENGTH_N(x)		(0x54 + ((x) * 0x04))
+#define	AES_REG_AUTH_LENGTH		0x5C
+#define	AES_REG_DATA			0x60
+#define	AES_REG_DATA_N(x)		(0x60 + ((x) * 0x04))
+#define	AES_REG_TAG			0x70
+#define	AES_REG_TAG_N(x)		(0x70 + ((x) * 0x04))
+
+#define AES_REG_REV			0x80
+#define	 AES_REG_REV_SCHEME_MASK	(3 << 30)
+#define	 AES_REG_REV_FUNC_MASK		(0xFFF << 16)
+#define	 AES_REG_REV_R_RTL_MASK		(0x1F << 11)
+#define	 AES_REG_REV_X_MAJOR_MASK	(7 << 8)
+#define	 AES_REG_REV_CUSTOM_MASK	(3 << 6)
+#define	 AES_REG_REV_Y_MINOR_MASK	(0x3F << 0)
+
+#define	AES_REG_SYSCFG			0x84
+#define	AES_REG_SYSCFG_K3		(1 << 12)
+#define	AES_REG_SYSCFG_KEY_ENC		(1 << 11)
+#define	AES_REG_SYSCFG_KEK_MODE		(1 << 10)
+#define	AES_REG_SYSCFG_MAP_CTX_OUT	(1 << 9)
+#define	AES_REG_SYSCFG_DREQ_MASK	(15 << 5)
+#define	 AES_REG_SYSCFG_DREQ_CTX_OUT_EN	(1 << 8)
+#define	 AES_REG_SYSCFG_DREQ_CTX_IN_EN	(1 << 7)
+#define	 AES_REG_SYSCFG_DREQ_DATA_OUT_EN (1 << 6)
+#define	 AES_REG_SYSCFG_DREQ_DATA_IN_EN	(1 << 5)
+#define	AES_REG_SYSCFG_DIRECTBUSEN	(1 << 4)
+#define	AES_REG_SYSCFG_SIDLE_MASK	(3 << 2)
+#define	 AES_REG_SYSCFG_SIDLE_FORCEIDLE	(0 << 2)
+#define	 AES_REG_SYSCFG_SIDLE_NOIDLE	(1 << 2)
+#define	 AES_REG_SYSCFG_SIDLE_SMARTIDLE	(2 << 2)
+#define	AES_REG_SYSCFG_SOFTRESET	(1 << 1)
+#define	AES_REG_SYSCFG_AUTOIDLE		(1 << 0)
+
+#define	AES_REG_SYSSTATUS		0x88
+#define	AES_REG_SYSSTATUS_RESETDONE	(1 << 0)
+
+#define	AES_REG_IRQSTATUS		0x8C
+#define	AES_REG_IRQSTATUS_CTX_OUT	(1 << 3)
+#define	AES_REG_IRQSTATUS_DATA_OUT	(1 << 2)
+#define	AES_REG_IRQSTATUS_DATA_IN	(1 << 1)
+#define	AES_REG_IRQSTATUS_CTX_IN	(1 << 0)
+
+#define	AES_REG_IRQENA			0x90
+#define	AES_REG_IRQENA_CTX_OUT		(1 << 3)
+#define	AES_REG_IRQENA_DATA_OUT		(1 << 2)
+#define	AES_REG_IRQENA_DATA_IN		(1 << 1)
+#define	AES_REG_IRQENA_CTX_IN		(1 << 0)
+
+/* ==================================================================== */
+/** SHA / MD5 module layout.
+ */
+/* ==================================================================== */
+
+#define	SHA_REG_ODIGEST			0x00
+#define	SHA_REG_ODIGEST_N(x)		(0x00 + ((x) * 0x04))
+#define	SHA_REG_IDIGEST			0x20
+#define	SHA_REG_IDIGEST_N(x)		(0x20 + ((x) * 0x04))
+
+#define SHA_REG_DIGEST_COUNT		0x40
+#define SHA_REG_MODE			0x44
+#define SHA_REG_MODE_HMAC_OUTER_HASH	(1 << 7)
+#define SHA_REG_MODE_HMAC_KEY_PROC	(1 << 5)
+#define SHA_REG_MODE_CLOSE_HASH		(1 << 4)
+#define SHA_REG_MODE_ALGO_CONSTANT	(1 << 3)
+#define SHA_REG_MODE_ALGO_MASK		(3 << 1)
+#define  SHA_REG_MODE_ALGO_MD5_128	(0 << 1)
+#define  SHA_REG_MODE_ALGO_SHA1_160	(1 << 1)
+#define  SHA_REG_MODE_ALGO_SHA2_224	(2 << 1)
+#define  SHA_REG_MODE_ALGO_SHA2_256	(3 << 1)
+
+#define SHA_REG_LENGTH			0x48
+
+#define	SHA_REG_DATA			0x80
+#define	SHA_REG_DATA_N(x)		(0x80 + ((x) * 0x04))
+
+#define SHA_REG_REV			0x100
+#define	 SHA_REG_REV_SCHEME_MASK	(3 << 30)
+#define	 SHA_REG_REV_FUNC_MASK		(0xFFF << 16)
+#define	 SHA_REG_REV_R_RTL_MASK		(0x1F << 11)
+#define	 SHA_REG_REV_X_MAJOR_MASK	(7 << 8)
+#define	 SHA_REG_REV_CUSTOM_MASK	(3 << 6)
+#define	 SHA_REG_REV_Y_MINOR_MASK	(0x3F << 0)
+
+#define	SHA_REG_SYSCFG			0x110
+#define	SHA_REG_SYSCFG_SADVANCED	(1 << 7)
+#define	SHA_REG_SYSCFG_SCONT_SWT	(1 << 6)
+#define	SHA_REG_SYSCFG_SIDLE_MASK	(3 << 4)
+#define	 SHA_REG_SYSCFG_SIDLE_FORCEIDLE	(0 << 4)
+#define	 SHA_REG_SYSCFG_SIDLE_NOIDLE	(1 << 4)
+#define	 SHA_REG_SYSCFG_SIDLE_SMARTIDLE	(2 << 4)
+#define	SHA_REG_SYSCFG_SDMA_EN		(1 << 3)
+#define	SHA_REG_SYSCFG_SIT_EN		(1 << 2)
+#define	SHA_REG_SYSCFG_SOFTRESET	(1 << 1)
+#define	SHA_REG_SYSCFG_AUTOIDLE		(1 << 0)
+
+#define SHA_REG_SYSSTATUS		0x114
+#define SHA_REG_SYSSTATUS_RESETDONE	(1 << 0)
+
+#define SHA_REG_IRQSTATUS		0x118
+#define SHA_REG_IRQSTATUS_CTX_RDY	(1 << 3)
+#define SHA_REG_IRQSTATUS_PARTHASH_RDY (1 << 2)
+#define SHA_REG_IRQSTATUS_INPUT_RDY	(1 << 1)
+#define SHA_REG_IRQSTATUS_OUTPUT_RDY	(1 << 0)
+
+#define SHA_REG_IRQENA			0x11C
+#define SHA_REG_IRQENA_CTX_RDY		(1 << 3)
+#define SHA_REG_IRQENA_PARTHASH_RDY	(1 << 2)
+#define SHA_REG_IRQENA_INPUT_RDY	(1 << 1)
+#define SHA_REG_IRQENA_OUTPUT_RDY	(1 << 0)
+
+#endif /* __DRIVERS_CRYPTO_AM33X_H */
-- 
1.7.5.4

