From a248b7f2af8c1489431f577c8c1e242e5bfe4363 Mon Sep 17 00:00:00 2001
From: "Hebbar, Gururaja" <gururaja.hebbar@ti.com>
Date: Sat, 30 Jun 2012 08:24:24 +0800
Subject: [PATCH 037/609] arm:omap:am33xx: Register HSMMC Platform

Original commit: 6aeef6fd4d50bb7297d964b2352a3cad9307b59b

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch adds the hardware info like pin-mux, platform data and
registers the MMC module. AM335x SOC supports 3 HS-MMC instances.
However only 2 HS-MMC (MMC0, 1) instances are supported on EVM.

Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 arch/arm/mach-omap2/board-am335xevm.c      |  103 +++++++++++++++++++++++++++-
 arch/arm/mach-omap2/hsmmc.c                |   14 +++-
 arch/arm/mach-omap2/mux33xx.c              |    4 +-
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |    4 +-
 arch/arm/plat-omap/include/plat/dma-33xx.h |    2 +
 5 files changed, 116 insertions(+), 11 deletions(-)

diff --git a/arch/arm/mach-omap2/board-am335xevm.c b/arch/arm/mach-omap2/board-am335xevm.c
index 58d73c0..f38e340 100644
--- a/arch/arm/mach-omap2/board-am335xevm.c
+++ b/arch/arm/mach-omap2/board-am335xevm.c
@@ -41,10 +41,15 @@
 #include <plat/common.h>
 #include <plat/lcdc.h>
 #include <plat/usb.h>
+#include <plat/mmc.h>
 
 #include "board-flash.h"
 #include "mux.h"
 #include "devices.h"
+#include "hsmmc.h"
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
 
 static const struct display_panel disp_panel = {
 	WVGA,
@@ -129,6 +134,24 @@ static struct snd_platform_data am335x_evm_snd_data1 = {
 	.rxnumevt	= 1,
 };
 
+static struct omap2_hsmmc_info am335x_mmc[] __initdata = {
+	{
+		.mmc            = 1,
+		.caps           = MMC_CAP_4_BIT_DATA,
+		.gpio_cd        = GPIO_TO_PIN(0, 6),
+		.gpio_wp        = GPIO_TO_PIN(3, 18),
+		.ocr_mask       = MMC_VDD_32_33 | MMC_VDD_33_34, /* 3V3 */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{
+		.mmc            = 0,	/* will be set at runtime */
+	},
+	{}      /* Terminator */
+};
+
+
 #ifdef CONFIG_OMAP_MUX
 static struct omap_board_mux board_mux[] __initdata = {
 	AM33XX_MUX(I2C0_SDA, OMAP_MUX_MODE0 | AM33XX_SLEWCTRL_SLOW |
@@ -392,6 +415,48 @@ static struct pinmux_config mcasp1_pin_mux[] = {
 	{NULL, 0},
 };
 
+
+/* Module pin mux for mmc0 */
+static struct pinmux_config mmc0_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mcasp0_aclkr.mmc0_sdwp", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"spi0_cs1.mmc0_sdcd",  OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
+static struct pinmux_config mmc0_no_cd_pin_mux[] = {
+	{"mmc0_dat3.mmc0_dat3",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat2.mmc0_dat2",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat1.mmc0_dat1",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_dat0.mmc0_dat0",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_clk.mmc0_clk",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mmc0_cmd.mmc0_cmd",	OMAP_MUX_MODE0 | AM33XX_PIN_INPUT_PULLUP},
+	{"mcasp0_aclkr.mmc0_sdwp", OMAP_MUX_MODE4 | AM33XX_PIN_INPUT_PULLDOWN},
+	{NULL, 0},
+};
+
+/* Module pin mux for mmc1 */
+static struct pinmux_config mmc1_pin_mux[] = {
+	{"gpmc_ad7.mmc1_dat7",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad6.mmc1_dat6",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad5.mmc1_dat5",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad4.mmc1_dat4",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad3.mmc1_dat3",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad2.mmc1_dat2",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad1.mmc1_dat1",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_ad0.mmc1_dat0",	OMAP_MUX_MODE1 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn1.mmc1_clk",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn2.mmc1_cmd",	OMAP_MUX_MODE2 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_csn0.mmc1_sdwp",	OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{"gpmc_advn_ale.mmc1_sdcd", OMAP_MUX_MODE7 | AM33XX_PIN_INPUT_PULLUP},
+	{NULL, 0},
+};
+
 /*
 * @pin_mux - single module pin-mux structure which defines pin-mux
 *			details for all its pins.
@@ -446,9 +511,6 @@ static void _configure_device(int evm_id, struct evm_dev_cfg *dev_cfg,
 	}
 }
 
-/* Convert GPIO signal to GPIO pin number */
-#define GPIO_TO_PIN(bank, gpio) (32 * (bank) + (gpio))
-
 #define AM335X_LCD_BL_PIN	GPIO_TO_PIN(0, 7)
 
 /* pinmux for usb0 drvvbus */
@@ -653,6 +715,37 @@ static void mcasp1_init(int evm_id, int profile)
 	return;
 }
 
+static void mmc1_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc1_pin_mux);
+
+	am335x_mmc[1].mmc = 2;
+	am335x_mmc[1].caps = MMC_CAP_4_BIT_DATA;
+	am335x_mmc[1].gpio_cd = GPIO_TO_PIN(2, 2);
+	am335x_mmc[1].gpio_wp = GPIO_TO_PIN(1, 29);
+	am335x_mmc[1].ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34; /* 3V3 */
+
+	/* mmc will be initialized when mmc0_init is called */
+	return;
+}
+
+static void mmc0_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc0_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+static void mmc0_no_cd_init(int evm_id, int profile)
+{
+	setup_pin_mux(mmc0_no_cd_pin_mux);
+
+	omap2_hsmmc_init(am335x_mmc);
+	return;
+}
+
+
 /* Low-Cost EVM */
 static struct evm_dev_cfg low_cost_evm_dev_cfg[] = {
 	{rgmii1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
@@ -679,6 +772,9 @@ static struct evm_dev_cfg gen_purp_evm_dev_cfg[] = {
 		(PROFILE_ALL & ~PROFILE_2 & ~PROFILE_3)},
 	{i2c1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3 | PROFILE_7)},
 	{mcasp1_init,	DEV_ON_DGHTR_BRD, (PROFILE_0 | PROFILE_3 | PROFILE_7)},
+	{mmc1_init,	DEV_ON_DGHTR_BRD, PROFILE_2},
+	{mmc0_init,	DEV_ON_BASEBOARD, (PROFILE_ALL & ~PROFILE_5)},
+	{mmc0_no_cd_init,	DEV_ON_BASEBOARD, PROFILE_5},
 	{NULL, 0, 0},
 };
 
@@ -703,6 +799,7 @@ static struct evm_dev_cfg ip_phn_evm_dev_cfg[] = {
 	{evm_nand_init, DEV_ON_DGHTR_BRD, PROFILE_NONE},
 	{i2c1_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{mcasp1_init,	DEV_ON_DGHTR_BRD, PROFILE_NONE},
+	{mmc0_init,	DEV_ON_BASEBOARD, PROFILE_NONE},
 	{NULL, 0, 0},
 };
 
diff --git a/arch/arm/mach-omap2/hsmmc.c b/arch/arm/mach-omap2/hsmmc.c
index be697d4..2fe3d56 100644
--- a/arch/arm/mach-omap2/hsmmc.c
+++ b/arch/arm/mach-omap2/hsmmc.c
@@ -305,6 +305,9 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 		return -ENOMEM;
 	}
 
+	if (cpu_is_am33xx())
+		mmc->version = MMC_CTRL_VERSION_2;
+
 	if (c->name)
 		strncpy(hc_name, c->name, HSMMC_NAME_LEN);
 	else
@@ -365,10 +368,12 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 	else
 		mmc->slots[0].ocr_mask = c->ocr_mask;
 
-	if (!soc_is_am35xx())
+	if (!soc_is_am35xx() && !cpu_is_am33xx())
 		mmc->slots[0].features |= HSMMC_HAS_PBIAS;
 
-	if (cpu_is_omap44xx() && (omap_rev() > OMAP4430_REV_ES1_0))
+	if (cpu_is_omap44xx() && (omap_rev() > OMAP4430_REV_ES1_0) ||
+							cpu_is_am33xx())
+
 		mmc->slots[0].features |= HSMMC_HAS_UPDATED_RESET;
 
 	switch (c->mmc) {
@@ -388,7 +393,7 @@ static int __init omap_hsmmc_pdata_init(struct omap2_hsmmc_info *c,
 			}
 		}
 
-		if (soc_is_am35xx())
+		if (soc_is_am35xx() || cpu_is_am33xx())
 			mmc->slots[0].set_power = nop_mmc_set_power;
 
 		/* OMAP3630 HSMMC1 supports only 4-bit */
@@ -489,7 +494,8 @@ static void __init omap_hsmmc_init_one(struct omap2_hsmmc_info *hsmmcinfo,
 	if (res < 0)
 		goto free_mmc;
 
-	omap_hsmmc_mux(mmc_data, (ctrl_nr - 1));
+	if (!cpu_is_am33xx())
+		omap_hsmmc_mux(mmc_data, (ctrl_nr - 1));
 
 	name = "omap_hsmmc";
 	res = snprintf(oh_name, MAX_OMAP_MMC_HWMOD_NAME_LEN,
diff --git a/arch/arm/mach-omap2/mux33xx.c b/arch/arm/mach-omap2/mux33xx.c
index 017c18f..f4c052b 100644
--- a/arch/arm/mach-omap2/mux33xx.c
+++ b/arch/arm/mach-omap2/mux33xx.c
@@ -124,7 +124,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		NULL, NULL, "mcasp0_aclkr", NULL),
 	_AM33XX_MUXENTRY(GPMC_CSN0, 0,
 		"gpmc_csn0", NULL, NULL, NULL,
-		NULL, NULL, NULL, NULL),
+		NULL, NULL, NULL, "mmc1_sdwp"),
 	_AM33XX_MUXENTRY(GPMC_CSN1, 0,
 		"gpmc_csn1", NULL, "mmc1_clk", NULL,
 		NULL, NULL, NULL, NULL),
@@ -139,7 +139,7 @@ static struct omap_mux __initdata am33xx_muxmodes[] = {
 		NULL, NULL, "mcasp0_fsr", NULL),
 	_AM33XX_MUXENTRY(GPMC_ADVN_ALE, 0,
 		"gpmc_advn_ale", NULL, NULL, NULL,
-		NULL, NULL, NULL, NULL),
+		NULL, NULL, NULL, "mmc1_sdcd"),
 	_AM33XX_MUXENTRY(GPMC_OEN_REN, 0,
 		"gpmc_oen_ren", NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL),
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index 6b89815..a8c8c93 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -1138,8 +1138,8 @@ static struct omap_hwmod_irq_info am33xx_mmc2_irqs[] = {
 };
 
 static struct omap_hwmod_dma_info am33xx_mmc2_edma_reqs[] = {
-	{ .name = "tx", .dma_req = 64, },
-	{ .name = "rx", .dma_req = 65, },
+	{ .name = "tx", .dma_req = AM33XX_DMA_MMCHS2_W, },
+	{ .name = "rx", .dma_req = AM33XX_DMA_MMCHS2_R, },
 	{ .dma_req = -1 }
 };
 
diff --git a/arch/arm/plat-omap/include/plat/dma-33xx.h b/arch/arm/plat-omap/include/plat/dma-33xx.h
index f78edb4..bebdaa7 100644
--- a/arch/arm/plat-omap/include/plat/dma-33xx.h
+++ b/arch/arm/plat-omap/include/plat/dma-33xx.h
@@ -81,5 +81,7 @@
 #define AM33XX_DMA_MSHSI2COCP1_RX			61
 #define AM33XX_DMA_PWMSS2_ECAP				62
 #define AM33XX_DMA_PWMSS2_EPW				63
+#define AM33XX_DMA_MMCHS2_W				64	/* xBar */
+#define AM33XX_DMA_MMCHS2_R				65	/* xBar */
 
 #endif
-- 
1.7.5.4

