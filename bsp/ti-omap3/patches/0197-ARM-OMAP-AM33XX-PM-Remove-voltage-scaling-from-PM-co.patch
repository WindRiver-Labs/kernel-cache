From 43c00edd3a85038c646f6a85cdbe4fd69c6eacda Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 14 Mar 2012 22:45:27 +0530
Subject: [PATCH 197/609] ARM: OMAP: AM33XX: PM: Remove voltage scaling from
 PM code

Original commit: 39fb74f72337725a140618cc99d7a3cc18282e91

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Since the cpufreq driver is a consumer of the regulator that
is being used for scaling the voltage during suspend resume,
a regulator_set_voltage() without informing cpufreq gets into
issues with the min_uV and max_uV that both agree upon.

This was leading to suspend getting aborted and system eventually
dying.

A subsequent patch will add back the scaling using the cpufreq
driver itself.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-omap2/pm33xx.c |  110 +++--------------------------------------
 1 files changed, 8 insertions(+), 102 deletions(-)

diff --git a/arch/arm/mach-omap2/pm33xx.c b/arch/arm/mach-omap2/pm33xx.c
index 38e96b5..47b907f 100644
--- a/arch/arm/mach-omap2/pm33xx.c
+++ b/arch/arm/mach-omap2/pm33xx.c
@@ -24,7 +24,6 @@
 #include <linux/sched.h>
 #include <linux/suspend.h>
 #include <linux/completion.h>
-#include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
 
 #include <plat/prcm.h>
@@ -57,7 +56,6 @@ bool enable_deep_sleep = true;
 static suspend_state_t suspend_state = PM_SUSPEND_ON;
 
 static struct device *mpu_dev;
-static struct device *i2c_dev;
 static struct omap_mbox *m3_mbox;
 static struct powerdomain *cefuse_pwrdm, *gfx_pwrdm;
 static struct clockdomain *gfx_l3_clkdm, *gfx_l4ls_clkdm;
@@ -74,28 +72,6 @@ static void am33xx_m3_state_machine_reset(void);
 
 static DECLARE_COMPLETION(a8_m3_sync);
 
-#define VOLT_TOLERANCE	12500 /* 12.5mV */
-
-struct suspend_opp_change {
-	char *clk_name;
-	char *reg_name;
-	unsigned long freq1;	/* Frequency in suspend mode */
-	unsigned long freq2;	/* Frequency in active mode */
-	unsigned int volt1;	/* Voltage in suspend mode */
-	unsigned int volt2;	/* Voltage in active mode */
-	struct clk *clk;
-	struct regulator *reg;
-};
-
-static struct suspend_opp_change opp[] = {
-	{
-		.clk_name	= "dpll_mpu_ck",
-		.reg_name	= "vdd_mpu",
-		.freq1		= 275000000,
-		.volt1		= 965000,
-	},
-};
-
 static void save_padconf(void)
 {
 	lp_padconf.mii1_col	= readl(AM33XX_CTRL_REGADDR(0x0908));
@@ -142,57 +118,17 @@ static void restore_padconf(void)
 	writel(gmii_sel, AM33XX_CTRL_REGADDR(0x0650));
 }
 
-
 static int am33xx_pm_prepare_late(void)
 {
 	int ret = 0;
 
 	save_padconf();
 
-	if(!opp[0].clk || !opp[0].reg || !i2c_dev) {
-		pr_debug("Not attempting OPP change in suspend\n");
-		return ret;
-	}
-
-	opp[0].freq2 = clk_get_rate(opp[0].clk);
-	ret = clk_set_rate(opp[0].clk, opp[0].freq1);
-	if (ret) {
-		pr_debug("Failed to set %s frequency to %luMHz\n",
-					opp[0].clk_name, opp[0].freq1/1000000);
-	} else {
-		opp[0].volt2 = regulator_get_voltage(opp[0].reg);
-		ret = regulator_set_voltage(opp[0].reg, opp[0].volt1,
-					opp[0].volt1 + VOLT_TOLERANCE);
-		if (ret)
-			pr_debug("Failed to set %s voltage to %dmV\n",
-					opp[0].reg_name, opp[0].volt1/1000);
-	}
-
 	return ret;
 }
 
 static void am33xx_pm_finish(void)
 {
-	int ret = 0;
-
-	if(!opp[0].clk || !opp[0].reg || !i2c_dev) {
-		pr_debug("Not attempting OPP change in resume\n");
-		goto padconf;
-	}
-
-	ret = regulator_set_voltage(opp[0].reg, opp[0].volt2,
-					opp[0].volt2 + VOLT_TOLERANCE);
-	if (ret) {
-		pr_warning("Failed to restore %s voltage to %dmV\n",
-					opp[0].reg_name, opp[0].volt2/1000);
-	} else {
-		ret = clk_set_rate(opp[0].clk, opp[0].freq2);
-		if (ret)
-			pr_warning("Failed to restore %s frequency to %luMHz\n",
-					opp[0].clk_name, opp[0].freq2/1000000);
-	}
-
-padconf:
 	restore_padconf();
 }
 
@@ -220,7 +156,7 @@ static int am33xx_pm_suspend(void)
 	omap_hwmod_idle(usb_oh);
 	omap_hwmod_idle(gpmc_oh);
 
-	if(gfx_l3_clkdm && gfx_l4ls_clkdm) {
+	if (gfx_l3_clkdm && gfx_l4ls_clkdm) {
 		clkdm_sleep(gfx_l3_clkdm);
 		clkdm_sleep(gfx_l4ls_clkdm);
 	}
@@ -274,9 +210,6 @@ static int am33xx_pm_begin(suspend_state_t state)
 
 	disable_hlt();
 
-	if(i2c_dev)
-		pm_runtime_forbid(i2c_dev);
-
 	am33xx_lp_ipc.resume_addr = DS_RESUME_ADDR;
 	am33xx_lp_ipc.sleep_mode  = DS_MODE;
 	am33xx_lp_ipc.ipc_data1	  = DS_IPC_DEFAULT;
@@ -328,7 +261,7 @@ static void am33xx_m3_state_machine_reset(void)
 		if (!wait_for_completion_timeout(&a8_m3_sync, msecs_to_jiffies(5000)))
 			pr_err("A8<->CM3 sync failure\n");
 	} else {
-		pr_debug("Could not reset M3 state machine!!!\n");
+		pr_err("Could not reset M3 state machine!!!\n");
 		m3_state = M3_STATE_UNKNOWN;
 	}
 }
@@ -345,9 +278,6 @@ static void am33xx_pm_end(void)
 
 	am33xx_m3_state_machine_reset();
 
-	if(i2c_dev)
-		pm_runtime_allow(i2c_dev);
-
 	enable_hlt();
 
 	return;
@@ -390,12 +320,13 @@ static int am33xx_verify_lp_state(void)
 		pr_info("Successfully transitioned all domains to low power state\n");
 		goto clear_old_status;
 	} else if (status == 0x10000) {
-		pr_info("Could not enter low power state\n"
+		pr_err("Could not enter low power state\n"
 			"Please check for active clocks in PER domain\n");
 		ret = -1;
 		goto clear_old_status;
 	} else {
-		pr_info("Something went wrong :(\nStatus = %0x\n", status);
+		pr_err("Something is terribly wrong :(\nStatus = %0x\n",
+				status);
 		ret = -1;
 	}
 
@@ -422,7 +353,6 @@ static struct notifier_block wkup_m3_mbox_notifier = {
 	.notifier_call = wkup_m3_mbox_msg,
 };
 
-/* Interrupt from M3 to A8 */
 static irqreturn_t wkup_m3_txev_handler(int irq, void *unused)
 {
 	writel(0x1, m3_eoi);
@@ -436,7 +366,6 @@ static irqreturn_t wkup_m3_txev_handler(int irq, void *unused)
 			m3_mbox->ops->ack_irq(m3_mbox, IRQ_RX);
 		complete(&a8_m3_sync);
 	} else if (m3_state == M3_STATE_MSG_FOR_LP) {
-		/* Read back the MBOX and disable the interrupt to M3 since we are going down */
 		omap_mbox_msg_rx_flush(m3_mbox);
 		if (m3_mbox->ops->ack_irq)
 			m3_mbox->ops->ack_irq(m3_mbox, IRQ_RX);
@@ -511,9 +440,8 @@ static int wkup_m3_init(void)
 		goto err5;
 	}
 
-	pr_info("Trying to load am335x-pm-firmware.bin\n");
+	pr_info("Trying to load am335x-pm-firmware.bin (60 secs timeout)\n");
 
-	/* Now try to load the firware */
 	ret = request_firmware(&firmware, "am335x-pm-firmware.bin", mpu_dev);
 	if (ret < 0) {
 		dev_err(mpu_dev, "request_firmware failed\n");
@@ -523,7 +451,6 @@ static int wkup_m3_init(void)
 		pr_info("Copied the M3 firmware to UMEM\n");
 	}
 
-	/* Request the IRQ before M3 is released from reset */
 	ret = request_irq(AM33XX_IRQ_M3_M3SP_TXEV, wkup_m3_txev_handler,
 			  IRQF_DISABLED, "wkup_m3_txev", NULL);
 	if (ret) {
@@ -560,8 +487,7 @@ exit:
 }
 
 /*
- * Enable hardware supervised mode for all clockdomains if it's
- * supported. Initiate sleep transition for other clockdomains, if
+ * Initiate sleep transition for other clockdomains, if
  * they are not used
  */
 static int __init clkdms_setup(struct clockdomain *clkdm, void *unused)
@@ -583,7 +509,7 @@ void am33xx_push_sram_idle(void)
 
 static int __init am33xx_pm_init(void)
 {
-	int ret, i;
+	int ret;
 
 	if (!cpu_is_am33xx())
 		return -ENODEV;
@@ -619,26 +545,6 @@ static int __init am33xx_pm_init(void)
 		return -EINVAL;
 	}
 
-	i2c_dev = omap_device_get_by_hwmod_name("i2c1");
-
-	if (!i2c_dev) {
-		pr_warning("%s: unable to get the i2c device\n", __func__);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(opp); i++) {
-		opp[i].clk = clk_get(NULL, opp[i].clk_name);
-		if (IS_ERR(opp[i].clk))
-			pr_warning("Could not get %s clock\n", opp[i].clk_name);
-
-		if (opp[i].reg_name) {
-			opp[i].reg = regulator_get(NULL, opp[i].reg_name);
-			if (IS_ERR(opp[i].reg))
-				pr_warning("Could not get %s regulator\n",
-							opp[i].reg_name);
-		}
-	}
-
 	ret = wkup_m3_init();
 
 	if (ret) {
-- 
1.7.5.4

