From c670d0cac2dd2e3e954dd89f89211d0106769adf Mon Sep 17 00:00:00 2001
From: Ming Lei <tom.leiming@gmail.com>
Date: Thu, 23 Dec 2010 23:13:37 +0800
Subject: [PATCH 326/609] usb: musb: introduce get_hw_revision callback in
 glue ops

Original commit: 9229edd2a057b8481142f7e49bc29d86a4fed433

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patch introduces get_hw_revision callback in glue_ops,
and implement it in tusb glue driver, so tusb dma code can
get tusb revision via .get_hw_revision callback and we can
make glue drivers built as module easyly in later patches.

Signed-off-by: Ming Lei <tom.leiming@gmail.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/musb_core.h     |   11 +++++++++++
 drivers/usb/musb/tusb6010.c      |    8 +++++---
 drivers/usb/musb/tusb6010.h      |    2 --
 drivers/usb/musb/tusb6010_omap.c |    2 +-
 4 files changed, 17 insertions(+), 6 deletions(-)

diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index f4a40f0..884c890 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -209,6 +209,7 @@ enum musb_g_ep0_state {
  * @exit:	undoes @init
  * @set_mode:	forcefully changes operating mode
  * @try_ilde:	tries to idle the IP
+ * @get_hw_revision: get hardware revision
  * @vbus_status: returns vbus status if possible
  * @set_vbus:	forces vbus status
  * @adjust_channel_params: pre check for standard dma channel_program func
@@ -223,6 +224,8 @@ struct musb_platform_ops {
 	int	(*set_mode)(struct musb *musb, u8 mode);
 	void	(*try_idle)(struct musb *musb, unsigned long timeout);
 
+	u16  (*get_hw_revision)(struct musb *musb);
+
 	int	(*vbus_status)(struct musb *musb);
 	void	(*set_vbus)(struct musb *musb, int on);
 
@@ -603,4 +606,12 @@ static inline int musb_platform_exit(struct musb *musb)
 	return musb->ops->exit(musb);
 }
 
+static inline u16 musb_platform_get_hw_revision(struct musb *musb)
+{
+	if (!musb->ops->get_hw_revision)
+		return musb_readw(musb->mregs, MUSB_HWVERS);
+
+	return musb->ops->get_hw_revision(musb);
+}
+
 #endif	/* __MUSB_CORE_H__ */
diff --git a/drivers/usb/musb/tusb6010.c b/drivers/usb/musb/tusb6010.c
index de13559..40f6974 100644
--- a/drivers/usb/musb/tusb6010.c
+++ b/drivers/usb/musb/tusb6010.c
@@ -40,11 +40,11 @@ static void tusb_musb_set_vbus(struct musb *musb, int is_on);
  * Checks the revision. We need to use the DMA register as 3.0 does not
  * have correct versions for TUSB_PRCM_REV or TUSB_INT_CTRL_REV.
  */
-u8 tusb_get_revision(struct musb *musb)
+static u16 tusb_get_revision(struct musb *musb)
 {
 	void __iomem	*tbase = musb->ctrl_base;
 	u32		die_id;
-	u8		rev;
+	u16		rev;
 
 	rev = musb_readl(tbase, TUSB_DMA_CTRL_REV) & 0xff;
 	if (TUSB_REV_MAJOR(rev) == 3) {
@@ -61,7 +61,7 @@ EXPORT_SYMBOL_GPL(tusb_get_revision);
 static int tusb_print_revision(struct musb *musb)
 {
 	void __iomem	*tbase = musb->ctrl_base;
-	u8		rev;
+	u16		rev;
 
 	rev = tusb_get_revision(musb);
 
@@ -1161,6 +1161,8 @@ static const struct musb_platform_ops tusb_ops = {
 	.set_mode	= tusb_musb_set_mode,
 	.try_idle	= tusb_musb_try_idle,
 
+	.get_hw_revision	= tusb_get_revision,
+
 	.vbus_status	= tusb_musb_vbus_status,
 	.set_vbus	= tusb_musb_set_vbus,
 };
diff --git a/drivers/usb/musb/tusb6010.h b/drivers/usb/musb/tusb6010.h
index 35c933a..3d40c63 100644
--- a/drivers/usb/musb/tusb6010.h
+++ b/drivers/usb/musb/tusb6010.h
@@ -12,8 +12,6 @@
 #ifndef __TUSB6010_H__
 #define __TUSB6010_H__
 
-extern u8 tusb_get_revision(struct musb *musb);
-
 #ifdef CONFIG_USB_TUSB6010
 #define musb_in_tusb()			1
 #else
diff --git a/drivers/usb/musb/tusb6010_omap.c b/drivers/usb/musb/tusb6010_omap.c
index b67b4bc..834924e 100644
--- a/drivers/usb/musb/tusb6010_omap.c
+++ b/drivers/usb/musb/tusb6010_omap.c
@@ -697,7 +697,7 @@ dma_controller_create(struct musb *musb, void __iomem *base)
 	tusb_dma->controller.channel_program = tusb_omap_dma_program;
 	tusb_dma->controller.channel_abort = tusb_omap_dma_abort;
 
-	if (tusb_get_revision(musb) >= TUSB_REV_30)
+	if (musb_platform_get_hw_revision(musb) >= TUSB_REV_30)
 		tusb_dma->multichannel = 1;
 
 	for (i = 0; i < MAX_DMAREQ; i++) {
-- 
1.7.5.4

