From 42dfe0a8d409bd8b36de3aeaaef043dcb27daecc Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Wed, 1 Aug 2012 16:59:36 +0800
Subject: [PATCH 250/609] ARM: OMAP2+: cpsw: davinci_mdio: Adapt to HWMOD

Original commit: 8fe58e9635f1925cf7bea3f991e7c04915abb5a1

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

* Modify cpsw and davindi mdio from platform registry to hwmod
* dma_mask and dma_coherrent_mask is dropped as there is no visible way to
  pass the mask from platform data to driver in hwmod

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 arch/arm/mach-omap2/devices.c              |   91 ++++++++--------------------
 arch/arm/mach-omap2/omap_hwmod_33xx_data.c |   50 ++++++++++++++-
 2 files changed, 71 insertions(+), 70 deletions(-)

diff --git a/arch/arm/mach-omap2/devices.c b/arch/arm/mach-omap2/devices.c
index 70d36ed..f828a9e 100644
--- a/arch/arm/mach-omap2/devices.c
+++ b/arch/arm/mach-omap2/devices.c
@@ -1193,7 +1193,6 @@ arch_initcall(omap2_init_devices);
 #define CPSW_PORT_VLAN_SLAVE_0		2
 #define CPSW_PORT_VLAN_SLAVE_1		3
 
-static u64 am33xx_cpsw_dmamask = DMA_BIT_MASK(32);
 /* TODO : Verify the offsets */
 static struct cpsw_slave_data am33xx_cpsw_slaves[] = {
 	{
@@ -1234,67 +1233,6 @@ static struct mdio_platform_data am33xx_cpsw_mdiopdata = {
 	.bus_freq       = AM33XX_EMAC_MDIO_FREQ,
 };
 
-static struct resource am33xx_cpsw_mdioresources[] = {
-	{
-		.start  = AM33XX_CPSW_MDIO_BASE,
-		.end    = AM33XX_CPSW_MDIO_BASE + SZ_256 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device am33xx_cpsw_mdiodevice = {
-	.name           = "davinci_mdio",
-	.id             = 0,
-	.num_resources  = ARRAY_SIZE(am33xx_cpsw_mdioresources),
-	.resource       = am33xx_cpsw_mdioresources,
-	.dev.platform_data = &am33xx_cpsw_mdiopdata,
-};
-
-static struct resource am33xx_cpsw_resources[] = {
-	{
-		.start  = AM33XX_CPSW_BASE,
-		.end    = AM33XX_CPSW_BASE + SZ_2K - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start  = AM33XX_CPSW_SS_BASE,
-		.end    = AM33XX_CPSW_SS_BASE + SZ_256 - 1,
-		.flags  = IORESOURCE_MEM,
-	},
-	{
-		.start	= AM33XX_IRQ_CPSW_C0_RX,
-		.end	= AM33XX_IRQ_CPSW_C0_RX,
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= AM33XX_IRQ_DMTIMER5,
-		.end	= AM33XX_IRQ_DMTIMER5,
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= AM33XX_IRQ_DMTIMER6,
-		.end	= AM33XX_IRQ_DMTIMER6,
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= AM33XX_IRQ_CPSW_C0,
-		.end	= AM33XX_IRQ_CPSW_C0,
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device am33xx_cpsw_device = {
-	.name		=	"cpsw",
-	.id		=	0,
-	.num_resources	=	ARRAY_SIZE(am33xx_cpsw_resources),
-	.resource	=	am33xx_cpsw_resources,
-	.dev		=	{
-					.platform_data	= &am33xx_cpsw_pdata,
-					.dma_mask	= &am33xx_cpsw_dmamask,
-					.coherent_dma_mask = DMA_BIT_MASK(32),
-				},
-};
-
 static unsigned char  am33xx_macid0[ETH_ALEN];
 static unsigned char  am33xx_macid1[ETH_ALEN];
 
@@ -1325,6 +1263,8 @@ void am33xx_cpsw_macidfillup(char *eeprommacid0, char *eeprommacid1)
 int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 		     unsigned char *phy_id1)
 {
+	struct omap_hwmod *oh;
+	struct platform_device *pdev;
 	u32 mac_lo, mac_hi, gmii_sel;
 	u32 i;
 
@@ -1382,10 +1322,29 @@ int am33xx_cpsw_init(enum am33xx_cpsw_mac_mode mode, unsigned char *phy_id0,
 
 	memcpy(am33xx_cpsw_pdata.mac_addr,
 			am33xx_cpsw_slaves[0].mac_addr, ETH_ALEN);
-	platform_device_register(&am33xx_cpsw_mdiodevice);
-	platform_device_register(&am33xx_cpsw_device);
-	clk_add_alias(NULL, dev_name(&am33xx_cpsw_mdiodevice.dev),
-			NULL, &am33xx_cpsw_device.dev);
+
+	oh = omap_hwmod_lookup("mdio");
+	if (!oh) {
+		pr_err("could not find cpgmac0 hwmod data\n");
+		return -ENODEV;
+	}
+
+	pdev = omap_device_build("davinci_mdio", 0, oh, &am33xx_cpsw_mdiopdata,
+			sizeof(am33xx_cpsw_mdiopdata), NULL, 0, 0);
+	if (IS_ERR(pdev))
+		pr_err("could not build omap_device for cpsw\n");
+
+	oh = omap_hwmod_lookup("cpgmac0");
+	if (!oh) {
+		pr_err("could not find cpgmac0 hwmod data\n");
+		return -ENODEV;
+	}
+
+	pdev = omap_device_build("cpsw", -1, oh, &am33xx_cpsw_pdata,
+			sizeof(am33xx_cpsw_pdata), NULL, 0, 0);
+	if (IS_ERR(pdev))
+		pr_err("could not build omap_device for cpsw\n");
+
 	return 0;
 }
 
diff --git a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
index 1561be8..2edeb04 100644
--- a/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
+++ b/arch/arm/mach-omap2/omap_hwmod_33xx_data.c
@@ -81,6 +81,7 @@ static struct omap_hwmod am33xx_gpmc_hwmod;
 static struct omap_hwmod am33xx_lcdc_hwmod;
 static struct omap_hwmod am33xx_mailbox_hwmod;
 static struct omap_hwmod am33xx_cpgmac0_hwmod;
+static struct omap_hwmod am33xx_mdio_hwmod;
 
 /*
  * Interconnects hwmod structures
@@ -457,14 +458,19 @@ static struct omap_hwmod_class_sysconfig am33xx_cpgmac_sysc = {
 };
 
 static struct omap_hwmod_class am33xx_cpgmac0_hwmod_class = {
-	.name		= "cpgmac0",
+	.name		= "cpsw",
 	.sysc		= &am33xx_cpgmac_sysc,
 };
 
 struct omap_hwmod_addr_space am33xx_cpgmac0_addr_space[] = {
 	{
+		.pa_start	= 0x4A100000,
+		.pa_end		= 0x4A100000 + SZ_2K - 1,
+		.flags		= ADDR_MAP_ON_INIT,
+	},
+	{
 		.pa_start	= 0x4A101200,
-		.pa_end		= 0x4A101200 + SZ_8K - 1,
+		.pa_end		= 0x4A101200 + SZ_256 - 1,
 		.flags		= ADDR_MAP_ON_INIT | ADDR_TYPE_RT,
 	},
 	{ }
@@ -483,8 +489,8 @@ static struct omap_hwmod_ocp_if *am33xx_cpgmac0_slaves[] = {
 
 static struct omap_hwmod_irq_info am33xx_cpgmac0_irqs[] = {
 	{ .name = "c0_rx_thresh_pend", .irq = 40 },
-	{ .name = "c0_rx_pend", .irq = 41 },
-	{ .name = "c0_tx_pend", .irq = 42 },
+	{ .name = "c0_rx_pend", .irq = 93 },
+	{ .name = "c0_tx_pend", .irq = 94 },
 	{ .name = "c0_misc_pend", .irq = 43 },
 	{ .irq = -1 }
 };
@@ -507,6 +513,40 @@ static struct omap_hwmod am33xx_cpgmac0_hwmod = {
 				HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
 };
 
+/* mdio class */
+static struct omap_hwmod_class am33xx_mdio_hwmod_class = {
+	.name		= "davinci_mdio",
+};
+
+struct omap_hwmod_addr_space am33xx_mdio_addr_space[] = {
+	{
+		.pa_start	= 0x4A101000,
+		.pa_end		= 0x4A101000 + SZ_256 - 1,
+		.flags		= ADDR_MAP_ON_INIT,
+	},
+	{ }
+};
+
+struct omap_hwmod_ocp_if am33xx_cpgmac0__mdio = {
+	.master		= &am33xx_cpgmac0_hwmod,
+	.slave		= &am33xx_mdio_hwmod,
+	.addr		= am33xx_mdio_addr_space,
+	.user		= OCP_USER_MPU,
+};
+
+static struct omap_hwmod_ocp_if *am33xx_mdio_slaves[] = {
+	&am33xx_cpgmac0__mdio,
+};
+
+static struct omap_hwmod am33xx_mdio_hwmod = {
+	.name		= "mdio",
+	.class		= &am33xx_mdio_hwmod_class,
+	.clkdm_name	= "cpsw_125mhz_clkdm",
+	.main_clk	= "cpgmac0_ick",
+	.slaves		= am33xx_mdio_slaves,
+	.slaves_cnt	= ARRAY_SIZE(am33xx_mdio_slaves),
+};
+
 /* 'dcan' class */
 static struct omap_hwmod_class am33xx_dcan_hwmod_class = {
 	.name		= "d_can",
@@ -3390,6 +3430,8 @@ static __initdata struct omap_hwmod *am33xx_hwmods[] = {
 	&am33xx_usbss_hwmod,
 	/* cpgmac0 class */
 	&am33xx_cpgmac0_hwmod,
+	/* mdio class */
+	&am33xx_mdio_hwmod,
 	/* tptc class */
 	&am33xx_tptc0_hwmod,
 	&am33xx_tptc1_hwmod,
-- 
1.7.5.4

