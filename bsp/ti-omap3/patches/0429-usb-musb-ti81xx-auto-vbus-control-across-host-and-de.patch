From cde96e7bed895f5509912b25bcea3d1db2874a5a Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Thu, 22 Dec 2011 16:02:59 +0530
Subject: [PATCH 429/609] usb: musb: ti81xx: auto vbus control across host and
 device mode

Original commit: 5b20494150d8c045f152f06bee57da2e64dc4964

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Automatically control vbus using timer. Set the session bit periodically in a timer
context when nothing is connected to usb port. If mini-A is connected then Vbus will
get switched on and if mini-B is connected then Vbus will nto be driven.

Kill the timer when a device is attached in host mode or port is connected to external
host and revive the timer as soon as disconnect happens.

Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
---
 drivers/usb/musb/musb_core.c |    1 -
 drivers/usb/musb/ti81xx.c    |   19 ++++++++++++-------
 2 files changed, 12 insertions(+), 8 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index e041dba..3787d74 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -990,7 +990,6 @@ void musb_start(struct musb *musb)
 
 	musb->is_active = 0;
 	devctl = musb_readb(regs, MUSB_DEVCTL);
-	devctl &= ~MUSB_DEVCTL_SESSION;
 
 	if (is_otg_enabled(musb)) {
 		/* session started after:
diff --git a/drivers/usb/musb/ti81xx.c b/drivers/usb/musb/ti81xx.c
index 5a5e07c..6f3adcd 100644
--- a/drivers/usb/musb/ti81xx.c
+++ b/drivers/usb/musb/ti81xx.c
@@ -594,12 +594,14 @@ static void otg_timer(unsigned long _musb)
 		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE) {
-			musb->xceiv->state = OTG_STATE_B_IDLE;
-			MUSB_DEV_MODE(musb);
-		} else {
+		if (devctl & MUSB_DEVCTL_HM) {
 			musb->xceiv->state = OTG_STATE_A_IDLE;
 			MUSB_HST_MODE(musb);
+		} else {
+			musb->xceiv->state = OTG_STATE_B_IDLE;
+			MUSB_DEV_MODE(musb);
+			mod_timer(&musb->otg_workaround,
+					jiffies + POLL_SECONDS * HZ);
 		}
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
@@ -635,11 +637,14 @@ static void otg_timer(unsigned long _musb)
 		 * SRP but clearly it doesn't.
 		 */
 		devctl = musb_readb(mregs, MUSB_DEVCTL);
-		if (devctl & MUSB_DEVCTL_BDEVICE)
+		if (devctl & MUSB_DEVCTL_HM) {
+			musb->xceiv->state = OTG_STATE_A_IDLE;
+		} else {
 			mod_timer(&musb->otg_workaround,
 					jiffies + POLL_SECONDS * HZ);
-		else
-			musb->xceiv->state = OTG_STATE_A_IDLE;
+			musb_writeb(musb->mregs, MUSB_DEVCTL, devctl |
+				MUSB_DEVCTL_SESSION);
+		}
 		break;
 	default:
 		break;
-- 
1.7.5.4

