From baea3a21e7b466b48068a6bea8635debe42eaa3b Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Tue, 22 Mar 2011 14:04:00 +0530
Subject: [PATCH 398/609] musb:cppi41: Fix for modular support issue for
 TI81XX (DMA mode)

Original commit: 370c8dad45ae695b76e9c66f2be7c5b30511344b

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Cleanup of cppi41dma and added un-init routine for
queue manager and dma blocks.

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41.c     |  101 ++++++++++++++++++++++++++---------------
 drivers/usb/musb/cppi41.h     |   21 +++++++++
 drivers/usb/musb/cppi41_dma.c |   24 +++++++---
 drivers/usb/musb/ti81xx.c     |   46 ++++++++++++++++---
 4 files changed, 140 insertions(+), 52 deletions(-)

diff --git a/drivers/usb/musb/cppi41.c b/drivers/usb/musb/cppi41.c
index 1365c42..d48081c 100644
--- a/drivers/usb/musb/cppi41.c
+++ b/drivers/usb/musb/cppi41.c
@@ -135,6 +135,28 @@ int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size)
 }
 EXPORT_SYMBOL(cppi41_queue_mgr_init);
 
+int cppi41_queue_mgr_uninit(u8 q_mgr)
+{
+	void __iomem *q_mgr_regs;
+
+	if (q_mgr >= cppi41_num_queue_mgr)
+		return -EINVAL;
+
+	q_mgr_regs = cppi41_queue_mgr[q_mgr].q_mgr_rgn_base;
+
+	/* free the Queue Mgr linking ram space */
+	__raw_writel(0,	q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
+	__raw_writel(0, q_mgr_regs + QMGR_LINKING_RAM_RGN0_SIZE_REG);
+	dma_free_coherent(NULL, linking_ram[q_mgr].size,
+			linking_ram[q_mgr].virt_addr,
+			linking_ram[q_mgr].phys_addr);
+
+	/* free the allocated queues */
+	kfree(allocated_queues[q_mgr]);
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_queue_mgr_uninit);
+
 int cppi41_dma_sched_tbl_init(u8 dma_num, u8 q_mgr,
 			u32 *sched_tbl, u8 tbl_size)
 {
@@ -359,6 +381,43 @@ free_queue:
 }
 EXPORT_SYMBOL(cppi41_dma_block_init);
 
+int cppi41_dma_block_uninit(u8 dma_num, u8 q_mgr, u8 num_order,
+				 u32 *sched_tbl, u8 tbl_size)
+{
+	const struct cppi41_dma_block *dma_block;
+	unsigned num_reg;
+	int i;
+
+	/* popout all teardown descriptors */
+	cppi41_free_teardown_queue(dma_num);
+
+	/* free queue mgr region */
+	cppi41_mem_rgn_free(q_mgr, dma_teardown[dma_num].mem_rgn);
+	/* free the allocated teardown descriptors */
+	dma_free_coherent(NULL, dma_teardown[dma_num].rgn_size,
+			dma_teardown[dma_num].virt_addr,
+			dma_teardown[dma_num].phys_addr);
+
+	/* free the teardown queue*/
+	cppi41_queue_free(dma_teardown[dma_num].q_mgr,
+			dma_teardown[dma_num].q_num);
+
+	dma_block = (struct cppi41_dma_block *)&cppi41_dma_block[dma_num];
+	/* disable the dma schedular */
+	num_reg = (tbl_size + 3) / 4;
+	for (i = 0; i < num_reg; i++) {
+		__raw_writel(0, dma_block->sched_table_base +
+			     DMA_SCHED_TABLE_WORD_REG(i));
+		DBG("DMA scheduler table @ %p, value written: %x\n",
+		    dma_block->sched_table_base + DMA_SCHED_TABLE_WORD_REG(i),
+		    0);
+	}
+
+	__raw_writel(0,	dma_block->sched_ctrl_base + DMA_SCHED_CTRL_REG);
+
+	return 0;
+}
+EXPORT_SYMBOL(cppi41_dma_block_uninit);
 /*
  * cppi41_mem_rgn_alloc - allocate a memory region within the queue manager
  */
@@ -702,46 +761,14 @@ void cppi41_free_teardown_queue(int dma_num)
 {
 	unsigned long td_addr;
 
-	while ((td_addr =
-		cppi41_queue_pop(&dma_teardown[dma_num].queue_obj)) != 0)
-		DBG("pop tdDesc(%p) from tdQueue\n", td_addr);
-}
-EXPORT_SYMBOL(cppi41_free_teardown_queue);
+	while (1) {
+		td_addr = cppi41_queue_pop(&dma_teardown[dma_num].queue_obj);
 
-void cppi41_exit(void)
-{
-	int i;
-	for (i = 0; i < CPPI41_NUM_QUEUE_MGR; i++) {
-		if (linking_ram[i].virt_addr != NULL) {
-			dma_free_coherent(NULL, linking_ram[i].size,
-				linking_ram[i].virt_addr,
-				linking_ram[i].phys_addr);
-			linking_ram[i].virt_addr = 0;
-			linking_ram[i].phys_addr = 0;
-		}
-		if (allocated_queues[i] != NULL) {
-			kfree(allocated_queues[i]);
-			allocated_queues[i] = 0;
-		}
+		if (td_addr == 0)
+			break;
 	}
-
-	/*
-	 * pop all the teardwon descriptor queued to tdQueue
-	 */
-	cppi41_free_teardown_queue(0);
-
-	for (i = 0; i < CPPI41_NUM_DMA_BLOCK; i++)
-		if (dma_teardown[i].virt_addr != NULL) {
-
-			cppi41_mem_rgn_free(0,  dma_teardown[i].mem_rgn);
-			dma_free_coherent(NULL, dma_teardown[i].rgn_size,
-					dma_teardown[i].virt_addr,
-					dma_teardown[i].phys_addr);
-			dma_teardown[i].virt_addr = 0;
-			dma_teardown[i].phys_addr = 0;
-		}
 }
-EXPORT_SYMBOL(cppi41_exit);
+EXPORT_SYMBOL(cppi41_free_teardown_queue);
 
 /**
  * alloc_queue - allocate a queue in the given range
diff --git a/drivers/usb/musb/cppi41.h b/drivers/usb/musb/cppi41.h
index f694b2c..bc42ac2 100644
--- a/drivers/usb/musb/cppi41.h
+++ b/drivers/usb/musb/cppi41.h
@@ -494,6 +494,13 @@ struct cppi41_queue_obj {
  */
 int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size);
 
+/**
+ * cppi41_queue_mgr_init - CPPI 4.1 queue manager un-initialization.
+ * @q_mgr:	the queue manager to un-initialize
+ * Returns 0 on success, error otherwise.
+ */
+int cppi41_queue_mgr_uninit(u8 q_mgr);
+
 /*
  * CPPI 4.1 Queue Manager Memory Region Allocation and De-allocation APIs.
  */
@@ -541,6 +548,20 @@ int cppi41_mem_rgn_free(u8 q_mgr, u8 mem_rgn);
 int cppi41_dma_block_init(u8 dma_num, u8 q_mgr, u8 num_order,
 				 u32 *sched_tbl, u8 tbl_size);
 
+/**
+ * cppi41_dma_block_init - CPPI 4.1 DMA block un-initialization.
+ * @dma_num:	number of the DMA block
+ * @q_mgr:	the queue manager in which to allocate the free teardown
+ *		descriptor queue
+ * @num_order:	number of teardown descriptors as a power of two (at least 5)
+ * @sched_tbl:	the DMA scheduler table
+ * @tbl_size:	number of entries in the DMA scheduler table
+ *
+ * Returns 0 on success, error otherwise.
+ */
+int cppi41_dma_block_uninit(u8 dma_num, u8 q_mgr, u8 num_order,
+				 u32 *sched_tbl, u8 tbl_size);
+
 /*
  * CPPI 4.1 DMA Channel Management APIs
  */
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 3069d04..716866d 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -33,7 +33,7 @@
 #define USB_CPPI41_DESC_SIZE_SHIFT 6
 #define USB_CPPI41_DESC_ALIGN	(1 << USB_CPPI41_DESC_SIZE_SHIFT)
 #define USB_CPPI41_CH_NUM_PD	128	/* 4K bulk data at full speed */
-#define USB_CPPI41_MAX_PD	(USB_CPPI41_CH_NUM_PD * USB_CPPI41_NUM_CH)
+#define USB_CPPI41_MAX_PD	(USB_CPPI41_CH_NUM_PD * (USB_CPPI41_NUM_CH+1))
 
 #undef DEBUG_CPPI_TD
 #undef USBDRV_DEBUG
@@ -55,13 +55,15 @@ struct usb_pkt_desc;
 
 struct usb_pkt_desc {
 	/* Hardware descriptor fields from this point */
-	struct cppi41_host_pkt_desc hw_desc;
+	struct cppi41_host_pkt_desc hw_desc;	/* 40 bytes */
 	/* Protocol specific data */
-	dma_addr_t dma_addr;
-	struct usb_pkt_desc *next_pd_ptr;
+	dma_addr_t dma_addr;			/* offs:44 byte */
+	struct usb_pkt_desc *next_pd_ptr;	/* offs:48 byte*/
 	u8 ch_num;
 	u8 ep_num;
 	u8 eop;
+	u8 res1;				/* offs:52 */
+	u8 res2[12];				/* offs:64 */
 };
 
 /**
@@ -124,6 +126,7 @@ struct cppi41 {
 	u8 en_bd_intr;			/* enable bd interrupt */
 	u32 automode_reg_offs;		/* USB_AUTOREQ_REG offset */
 	u32 teardown_reg_offs;		/* USB_TEARDOWN_REG offset */
+	u32 bd_size;
 };
 
 struct usb_cppi41_info usb_cppi41_info[2];
@@ -203,15 +206,16 @@ static int __devinit cppi41_controller_start(struct dma_controller *controller)
 	 * dma_alloc_coherent()  will return a page aligned address, so our
 	 * alignment requirement will be honored.
 	 */
+	cppi->bd_size = USB_CPPI41_MAX_PD * sizeof(struct usb_pkt_desc);
 	cppi->pd_mem = dma_alloc_coherent(cppi->musb->controller,
-					  USB_CPPI41_MAX_PD *
-					  USB_CPPI41_DESC_ALIGN,
+					  cppi->bd_size,
 					  &cppi->pd_mem_phys,
 					  GFP_KERNEL | GFP_DMA);
 	if (cppi->pd_mem == NULL) {
 		dev_dbg(musb->controller, "ERROR: packet descriptor memory allocation failed\n");
 		return 0;
 	}
+
 	if (cppi41_mem_rgn_alloc(cppi_info->q_mgr, cppi->pd_mem_phys,
 				 USB_CPPI41_DESC_SIZE_SHIFT,
 				 get_count_order(USB_CPPI41_MAX_PD),
@@ -344,10 +348,14 @@ static int cppi41_controller_stop(struct dma_controller *controller)
 	if (cppi41_mem_rgn_free(cppi_info->q_mgr, cppi->pd_mem_rgn))
 		dev_dbg(musb->controller, "ERROR: failed to free queue manager memory region\n");
 
-	dma_free_coherent(cppi->musb->controller,
-			  USB_CPPI41_MAX_PD * USB_CPPI41_DESC_ALIGN,
+	dma_free_coherent(cppi->musb->controller, cppi->bd_size,
 			  cppi->pd_mem, cppi->pd_mem_phys);
 
+	cppi->pd_mem = 0;
+	cppi->pd_mem_phys = 0;
+	cppi->pd_pool_head = 0;
+	cppi->bd_size = 0;
+
 	reg_base = cppi->musb->ctrl_base;
 
 	/* Disable auto request mode */
diff --git a/drivers/usb/musb/ti81xx.c b/drivers/usb/musb/ti81xx.c
index be2e5a2..3724950 100644
--- a/drivers/usb/musb/ti81xx.c
+++ b/drivers/usb/musb/ti81xx.c
@@ -71,15 +71,19 @@ extern u32 omap_ctrl_readl(u16 offset);
 
 static inline u32 usbss_read(u32 offset)
 {
+	if (!usbss_init_done)
+		return 0;
 	return __raw_readl(usbss_virt_base + offset);
 }
 
 static inline void usbss_write(u32 offset, u32 data)
 {
+	if (!usbss_init_done)
+		return ;
 	__raw_writel(data, usbss_virt_base + offset);
 }
 
-static void __init usbotg_ss_init(struct musb *musb)
+static void usbotg_ss_init(struct musb *musb)
 {
 	if (!usbss_init_done) {
 		usbss_virt_base = ioremap(TI81XX_USBSS_BASE,
@@ -90,7 +94,14 @@ static void __init usbotg_ss_init(struct musb *musb)
 		usbss_write(USBSS_IRQ_STATUS, usbss_read(USBSS_IRQ_STATUS));
 	}
 }
-
+static void usbotg_ss_uninit(void)
+{
+	if (usbss_init_done) {
+		iounmap(usbss_virt_base);
+		usbss_init_done = 0;
+		usbss_virt_base = 0;
+	}
+}
 void set_frame_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value, u8 en_intr)
 {
 	u32     base, reg_val, frame_intr = 0, frame_base = 0;
@@ -454,7 +465,7 @@ int __devinit cppi41_init(struct musb *musb)
 			dma_sched_table, numch);
 
 	/* attach to the IRQ */
-	if (request_irq(nIrq, cppi41dma_Interrupt, 0, "cppi41_dma", musb))
+	if (request_irq(nIrq, cppi41dma_Interrupt, 0, "cppi41_dma", 0))
 		printk(KERN_INFO "request_irq %d failed!\n", nIrq);
 	else
 		printk(KERN_INFO "registerd cppi-dma Intr @ IRQ %d\n", nIrq);
@@ -477,11 +488,21 @@ int __devinit cppi41_init(struct musb *musb)
 
 void cppi41_free(void)
 {
+	u32 numch, blknum, order;
+	struct usb_cppi41_info *cppi_info = &usb_cppi41_info[0];
+
 	if (!cppi41_init_done)
 		return ;
 
-	/* REVISIT: iounmap causing issue in rmmod */
-	/* iounmap(cppi41_dma_base); */
+	numch =  USB_CPPI41_NUM_CH * 2 * 2;
+	order = get_count_order(numch);
+	blknum = cppi_info->dma_block;
+
+	cppi41_dma_block_uninit(blknum, cppi_info->q_mgr, order,
+			dma_sched_table, numch);
+	cppi41_queue_mgr_uninit(cppi_info->q_mgr);
+
+	iounmap(cppi41_dma_base);
 	cppi41_dma_base = 0;
 	cppi41_init_done = 0;
 }
@@ -1293,11 +1314,22 @@ subsys_initcall(ti81xx_glue_init);
 
 static void __exit ti81xx_glue_exit(void)
 {
+	/* free the usbss irq */
+	free_irq(TI81XX_IRQ_USBSS, 0);
+
+	/* disable the interrupts */
+	usbss_write(USBSS_IRQ_EOI, 0);
+	usbss_write(USBSS_IRQ_ENABLE_SET, 0);
+	usbss_write(USBSS_IRQ_DMA_ENABLE_0, 0);
+
+	/* unregister platform driver */
+	platform_driver_unregister(&ti81xx_musb_driver);
+
 #ifdef CONFIG_USB_TI_CPPI41_DMA
-	cppi41_exit();
 	cppi41_free();
 #endif
-	platform_driver_unregister(&ti81xx_musb_driver);
+
+	usbotg_ss_uninit();
 }
 module_exit(ti81xx_glue_exit);
 
-- 
1.7.5.4

