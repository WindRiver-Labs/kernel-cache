From 6f05f52492912d669231a32aac0d6c64ffef04bb Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Sun, 1 Jul 2012 00:48:11 +0800
Subject: [PATCH 463/609] ARM: OMAP2+: nand: Support for BCH

Original commit: a0ab73f957d37c1c73fe9bf11fb3bd0625f8e67a

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Patch is derived from "omap3: nand: bch ecc support added"
available at:
http://arago-project.org/git/projects/?p=linux-omap3.git;a=commit;
f=arch/arm/mach-omap2/gpmc.c;hb=79f5ddc6

This patch has the following modification
1. Removes the BCH4 support as it is not tested.
2. Configures GPMC for BCH ECC support.
3. Adds BCH ECC layout definitions.

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 arch/arm/mach-omap2/gpmc-nand.c        |    3 +-
 arch/arm/mach-omap2/gpmc.c             |  257 ++++++++++++---------
 arch/arm/plat-omap/include/plat/gpmc.h |   14 +-
 arch/arm/plat-omap/include/plat/nand.h |    1 -
 drivers/mtd/nand/Makefile              |    1 -
 drivers/mtd/nand/omap2.c               |   74 +------
 drivers/mtd/nand/omap_bch_decoder.c    |  393 --------------------------------
 7 files changed, 164 insertions(+), 579 deletions(-)
 delete mode 100644 drivers/mtd/nand/omap_bch_decoder.c

diff --git a/arch/arm/mach-omap2/gpmc-nand.c b/arch/arm/mach-omap2/gpmc-nand.c
index 3bab447..d1882d1 100644
--- a/arch/arm/mach-omap2/gpmc-nand.c
+++ b/arch/arm/mach-omap2/gpmc-nand.c
@@ -82,7 +82,7 @@ static int omap2_nand_gpmc_retime(struct omap_nand_platform_data *gpmc_nand_data
 	return 0;
 }
 
-int __init gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data)
+int __devinit gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data)
 {
 	int err	= 0;
 	u8 cs = 0;
@@ -131,7 +131,6 @@ int __init gpmc_nand_init(struct omap_nand_platform_data *gpmc_nand_data)
 		gpmc_cs_configure(gpmc_nand_data->cs, GPMC_CONFIG_RDY_BSY, 1);
 	}
 
-	gpmc_nand_data->ctrl_clk = gpmc_clock();
 	err = platform_device_register(&gpmc_nand_device);
 	if (err < 0) {
 		dev_err(dev, "Unable to register NAND device\n");
diff --git a/arch/arm/mach-omap2/gpmc.c b/arch/arm/mach-omap2/gpmc.c
index 830935c..fe25829 100644
--- a/arch/arm/mach-omap2/gpmc.c
+++ b/arch/arm/mach-omap2/gpmc.c
@@ -14,6 +14,8 @@
  */
 #undef DEBUG
 
+#include <linux/platform_device.h>
+
 #include <linux/irq.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -27,6 +29,7 @@
 
 #include <asm/mach-types.h>
 #include <plat/gpmc.h>
+#include <plat/nand.h>
 
 #include <plat/sdrc.h>
 
@@ -92,57 +95,98 @@ struct omap3_gpmc_regs {
 	struct gpmc_cs_config cs_context[GPMC_CS_NUM];
 };
 
-static struct resource	gpmc_mem_root;
-static struct resource	gpmc_cs_mem[GPMC_CS_NUM];
-static DEFINE_SPINLOCK(gpmc_mem_lock);
-static unsigned int gpmc_cs_map;	/* flag for cs which are initialized */
 
-static void __iomem *gpmc_base;
+#define	DRIVER_NAME	"omap-gpmc"
 
-static struct clk *gpmc_l3_clk;
+struct gpmc {
+	struct device	*dev;
+	void __iomem	*io_base;
+	unsigned long	phys_base;
+	u32		memsize;
+	unsigned int	cs_map;
+	int		ecc_used;
+	spinlock_t	mem_lock;
+	struct resource	mem_root;
+	struct resource	cs_mem[GPMC_CS_NUM];
+};
 
-static irqreturn_t gpmc_handle_irq(int irq, void *dev);
+static struct gpmc *gpmc;
 
 static void gpmc_write_reg(int idx, u32 val)
 {
-	__raw_writel(val, gpmc_base + idx);
+	writel(val, gpmc->io_base + idx);
 }
 
 static u32 gpmc_read_reg(int idx)
 {
-	return __raw_readl(gpmc_base + idx);
+	return readl(gpmc->io_base + idx);
 }
 
 static void gpmc_cs_write_byte(int cs, int idx, u8 val)
 {
 	void __iomem *reg_addr;
 
-	reg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
-	__raw_writeb(val, reg_addr);
+	reg_addr = gpmc->io_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
+	writeb(val, reg_addr);
 }
 
 static u8 gpmc_cs_read_byte(int cs, int idx)
 {
 	void __iomem *reg_addr;
 
-	reg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
-	return __raw_readb(reg_addr);
+	reg_addr = gpmc->io_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
+	return readb(reg_addr);
 }
 
 void gpmc_cs_write_reg(int cs, int idx, u32 val)
 {
 	void __iomem *reg_addr;
 
-	reg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
-	__raw_writel(val, reg_addr);
+	if (!gpmc) {
+		pr_err("%s invoked without initializing GPMC\n", __func__);
+		return;
+	}
+
+	reg_addr = gpmc->io_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
+	writel(val, reg_addr);
 }
 
 u32 gpmc_cs_read_reg(int cs, int idx)
 {
 	void __iomem *reg_addr;
 
-	reg_addr = gpmc_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
-	return __raw_readl(reg_addr);
+	if (!gpmc) {
+		pr_err("%s invoked without initializing GPMC\n", __func__);
+		return 0;
+	}
+
+	reg_addr = gpmc->io_base + GPMC_CS0_OFFSET + (cs * GPMC_CS_SIZE) + idx;
+	return readl(reg_addr);
+}
+
+static struct clk *gpmc_l3_clk;
+
+static void __devinit gpmc_clk_init(void)
+{
+	char *ck = NULL;
+
+	if (cpu_is_omap24xx())
+		ck = "core_l3_ck";
+	else if (cpu_is_omap34xx())
+		ck = "gpmc_fck";
+	else if (cpu_is_omap44xx())
+		ck = "gpmc_ck";
+
+	if (WARN_ON(!ck))
+		return;
+
+	gpmc_l3_clk = clk_get(NULL, ck);
+	if (IS_ERR(gpmc_l3_clk)) {
+		printk(KERN_ERR "Could not get GPMC clock %s\n", ck);
+		BUG();
+	}
+
+	clk_enable(gpmc_l3_clk);
 }
 
 /* TODO: Add support for gpmc_fck to clock framework and use it */
@@ -361,8 +405,8 @@ int gpmc_cs_set_reserved(int cs, int reserved)
 	if (cs > GPMC_CS_NUM)
 		return -ENODEV;
 
-	gpmc_cs_map &= ~(1 << cs);
-	gpmc_cs_map |= (reserved ? 1 : 0) << cs;
+	gpmc->cs_map &= ~(1 << cs);
+	gpmc->cs_map |= (reserved ? 1 : 0) << cs;
 
 	return 0;
 }
@@ -372,7 +416,7 @@ int gpmc_cs_reserved(int cs)
 	if (cs > GPMC_CS_NUM)
 		return -ENODEV;
 
-	return gpmc_cs_map & (1 << cs);
+	return gpmc->cs_map & (1 << cs);
 }
 
 static unsigned long gpmc_mem_align(unsigned long size)
@@ -391,22 +435,22 @@ static unsigned long gpmc_mem_align(unsigned long size)
 
 static int gpmc_cs_insert_mem(int cs, unsigned long base, unsigned long size)
 {
-	struct resource	*res = &gpmc_cs_mem[cs];
+	struct resource	*res = &gpmc->cs_mem[cs];
 	int r;
 
 	size = gpmc_mem_align(size);
-	spin_lock(&gpmc_mem_lock);
+	spin_lock(&gpmc->mem_lock);
 	res->start = base;
 	res->end = base + size - 1;
-	r = request_resource(&gpmc_mem_root, res);
-	spin_unlock(&gpmc_mem_lock);
+	r = request_resource(&gpmc->mem_root, res);
+	spin_unlock(&gpmc->mem_lock);
 
 	return r;
 }
 
 int gpmc_cs_request(int cs, unsigned long size, unsigned long *base)
 {
-	struct resource *res = &gpmc_cs_mem[cs];
+	struct resource *res = &gpmc->cs_mem[cs];
 	int r = -1;
 
 	if (cs > GPMC_CS_NUM)
@@ -416,7 +460,7 @@ int gpmc_cs_request(int cs, unsigned long size, unsigned long *base)
 	if (size > (1 << GPMC_SECTION_SHIFT))
 		return -ENOMEM;
 
-	spin_lock(&gpmc_mem_lock);
+	spin_lock(&gpmc->mem_lock);
 	if (gpmc_cs_reserved(cs)) {
 		r = -EBUSY;
 		goto out;
@@ -424,7 +468,7 @@ int gpmc_cs_request(int cs, unsigned long size, unsigned long *base)
 	if (gpmc_cs_mem_enabled(cs))
 		r = adjust_resource(res, res->start & ~(size - 1), size);
 	if (r < 0)
-		r = allocate_resource(&gpmc_mem_root, res, size, 0, ~0,
+		r = allocate_resource(&gpmc->mem_root, res, size, 0, ~0,
 				      size, NULL, NULL);
 	if (r < 0)
 		goto out;
@@ -433,24 +477,24 @@ int gpmc_cs_request(int cs, unsigned long size, unsigned long *base)
 	*base = res->start;
 	gpmc_cs_set_reserved(cs, 1);
 out:
-	spin_unlock(&gpmc_mem_lock);
+	spin_unlock(&gpmc->mem_lock);
 	return r;
 }
 EXPORT_SYMBOL(gpmc_cs_request);
 
 void gpmc_cs_free(int cs)
 {
-	spin_lock(&gpmc_mem_lock);
+	spin_lock(&gpmc->mem_lock);
 	if (cs >= GPMC_CS_NUM || cs < 0 || !gpmc_cs_reserved(cs)) {
 		printk(KERN_ERR "Trying to free non-reserved GPMC CS%d\n", cs);
 		BUG();
-		spin_unlock(&gpmc_mem_lock);
+		spin_unlock(&gpmc->mem_lock);
 		return;
 	}
 	gpmc_cs_disable_mem(cs);
-	release_resource(&gpmc_cs_mem[cs]);
+	release_resource(&gpmc->cs_mem[cs]);
 	gpmc_cs_set_reserved(cs, 0);
-	spin_unlock(&gpmc_mem_lock);
+	spin_unlock(&gpmc->mem_lock);
 }
 EXPORT_SYMBOL(gpmc_cs_free);
 
@@ -673,7 +717,7 @@ int gpmc_prefetch_reset(int cs)
 }
 EXPORT_SYMBOL(gpmc_prefetch_reset);
 
-static void __init gpmc_mem_init(void)
+static void __devinit gpmc_mem_init(void)
 {
 	int cs;
 	unsigned long boot_rom_space = 0;
@@ -685,8 +729,8 @@ static void __init gpmc_mem_init(void)
 	/* In apollon the CS0 is mapped as 0x0000 0000 */
 	if (machine_is_omap_apollon())
 		boot_rom_space = 0;
-	gpmc_mem_root.start = GPMC_MEM_START + boot_rom_space;
-	gpmc_mem_root.end = GPMC_MEM_END;
+	gpmc->mem_root.start = GPMC_MEM_START + boot_rom_space;
+	gpmc->mem_root.end = GPMC_MEM_END;
 
 	/* Reserve all regions that has been set up by bootloader */
 	for (cs = 0; cs < GPMC_CS_NUM; cs++) {
@@ -700,97 +744,91 @@ static void __init gpmc_mem_init(void)
 	}
 }
 
-static int __init gpmc_init(void)
+static int __devinit gpmc_probe(struct platform_device *pdev)
 {
-	u32 l, irq;
-	int cs, ret = -EINVAL;
-	int gpmc_irq;
-	char *ck = NULL;
+	u32 l;
+	int ret = -EINVAL;
+	struct resource *res = NULL;
+	struct gpmc_devices_info *gpmc_device = pdev->dev.platform_data;
+	void *p;
 
-	if (cpu_is_omap24xx()) {
-		ck = "core_l3_ck";
-		if (cpu_is_omap2420())
-			l = OMAP2420_GPMC_BASE;
-		else
-			l = OMAP34XX_GPMC_BASE;
-		gpmc_irq = INT_34XX_GPMC_IRQ;
-	} else if (cpu_is_omap34xx()) {
-		ck = "gpmc_fck";
-		if (cpu_is_am33xx()) {
-			l = OMAP44XX_GPMC_BASE;
-			gpmc_irq = AM33XX_IRQ_GPMC0;
-		} else {
-			l = OMAP34XX_GPMC_BASE;
-			gpmc_irq = INT_34XX_GPMC_IRQ;
-		}
-	} else if (cpu_is_omap44xx()) {
-		ck = "gpmc_ck";
-		l = OMAP44XX_GPMC_BASE;
-		gpmc_irq = OMAP44XX_IRQ_GPMC;
-	}
+	/* XXX: This should go away with HWMOD & runtime PM adaptation */
+	gpmc_clk_init();
 
-	if (WARN_ON(!ck))
-		return ret;
+	gpmc = devm_kzalloc(&pdev->dev, sizeof(struct gpmc), GFP_KERNEL);
+	if (!gpmc)
+		return -ENOMEM;
 
-	gpmc_l3_clk = clk_get(NULL, ck);
-	if (IS_ERR(gpmc_l3_clk)) {
-		printk(KERN_ERR "Could not get GPMC clock %s\n", ck);
-		BUG();
+	gpmc->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		ret = -ENOENT;
+		dev_err(gpmc->dev, "Failed to get resource: memory\n");
+		goto err_res;
+	}
+	gpmc->phys_base = res->start;
+	gpmc->memsize = resource_size(res);
+
+	if (request_mem_region(gpmc->phys_base,
+		gpmc->memsize, DRIVER_NAME) == NULL) {
+		ret = -ENOMEM;
+		dev_err(gpmc->dev, "Failed to request memory region\n");
+		goto err_mem;
 	}
 
-	gpmc_base = ioremap(l, SZ_4K);
-	if (!gpmc_base) {
-		clk_put(gpmc_l3_clk);
-		printk(KERN_ERR "Could not get GPMC register memory\n");
-		BUG();
+	gpmc->io_base = ioremap(gpmc->phys_base, gpmc->memsize);
+	if (!gpmc->io_base) {
+		ret = -ENOMEM;
+		dev_err(gpmc->dev, "Failed to ioremap memory\n");
+		goto err_remap;
 	}
 
-	clk_enable(gpmc_l3_clk);
+	gpmc->ecc_used = -EINVAL;
+	spin_lock_init(&gpmc->mem_lock);
+	platform_set_drvdata(pdev, gpmc);
 
 	l = gpmc_read_reg(GPMC_REVISION);
-	printk(KERN_INFO "GPMC revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
-	/* Set smart idle mode and automatic L3 clock gating */
-	l = gpmc_read_reg(GPMC_SYSCONFIG);
-	l &= 0x03 << 3;
-	l |= (0x02 << 3) | (1 << 0);
-	gpmc_write_reg(GPMC_SYSCONFIG, l);
+	dev_info(gpmc->dev, "GPMC revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
+
 	gpmc_mem_init();
 
-	/* initalize the irq_chained */
-	irq = OMAP_GPMC_IRQ_BASE;
-	for (cs = 0; cs < GPMC_CS_NUM; cs++) {
-		irq_set_chip_and_handler(irq, &dummy_irq_chip,
-						handle_simple_irq);
-		set_irq_flags(irq, IRQF_VALID);
-		irq++;
-	}
+	for (p = gpmc_device->pdata; p; gpmc_device++, p = gpmc_device->pdata)
+		if (gpmc_device->flag & GPMC_DEVICE_NAND)
+			gpmc_nand_init((struct omap_nand_platform_data *) p);
+	return 0;
 
-	ret = request_irq(gpmc_irq,
-			gpmc_handle_irq, IRQF_SHARED, "gpmc", gpmc_base);
-	if (ret)
-		pr_err("gpmc: irq-%d could not claim: err %d\n",
-						gpmc_irq, ret);
+err_remap:
+	release_mem_region(gpmc->phys_base, gpmc->memsize);
+err_mem:
+err_res:
+	devm_kfree(&pdev->dev, gpmc);
 	return ret;
 }
-postcore_initcall(gpmc_init);
 
-struct clk *gpmc_clock(void)
+static int __devexit gpmc_remove(struct platform_device *pdev)
 {
-	return gpmc_l3_clk;
-}
+	struct gpmc *gpmc = platform_get_drvdata(pdev);
 
-static irqreturn_t gpmc_handle_irq(int irq, void *dev)
-{
-	u8 cs;
+	platform_set_drvdata(pdev, NULL);
+	iounmap(gpmc->io_base);
+	release_mem_region(gpmc->phys_base, gpmc->memsize);
+	devm_kfree(&pdev->dev, gpmc);
 
-	/* check cs to invoke the irq */
-	cs = ((gpmc_read_reg(GPMC_PREFETCH_CONFIG1)) >> CS_NUM_SHIFT) & 0x7;
-	if (OMAP_GPMC_IRQ_BASE+cs <= OMAP_GPMC_IRQ_END)
-		generic_handle_irq(OMAP_GPMC_IRQ_BASE+cs);
-
-	return IRQ_HANDLED;
+	return 0;
 }
 
+static struct platform_driver gpmc_driver = {
+	.probe		= gpmc_probe,
+	.remove		= __devexit_p(gpmc_remove),
+	.driver		= {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+module_platform_driver(gpmc_driver);
+
 #ifdef CONFIG_ARCH_OMAP3
 static struct omap3_gpmc_regs gpmc_context;
 
@@ -866,7 +904,8 @@ void omap3_gpmc_restore_context(void)
  * @dev_width: device bus width(1 for x16, 0 for x8)
  * @ecc_size: bytes for which ECC will be generated
  */
-int gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size)
+int gpmc_enable_hwecc(int ecc_type, int cs, int mode,
+			int dev_width, int ecc_size)
 {
 	unsigned int bch_mod = 0, bch_wrapmode = 0, eccsize1 = 0, eccsize0 = 0;
 	unsigned int ecc_conf_val = 0, ecc_size_conf_val = 0;
@@ -885,7 +924,7 @@ int gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size)
 			eccsize1 = ((ecc_size >> 1) - 1);
 		break;
 	case GPMC_ECC_READSYN:
-		printk(KERN_INFO "Warning: No operations for ECC_READSYN\n");
+		printk(KERN_INFO "Fixme czm ### no ops for READSYN\n");
 		break;
 	case GPMC_ECC_WRITE:
 		if (ecc_type == OMAP_ECC_BCH4_CODE_HW) {
@@ -898,7 +937,6 @@ int gpmc_enable_hwecc(int cs, int mode, int dev_width, int ecc_size)
 			bch_wrapmode = 0x06;
 		} else
 			eccsize1 = ((ecc_size >> 1) - 1);
-
 		break;
 	default:
 		printk(KERN_INFO "Error: Unrecognized Mode[%d]!\n", mode);
@@ -941,7 +979,7 @@ EXPORT_SYMBOL_GPL(gpmc_enable_hwecc);
  * ECC bytes that has to be dealt with separately.
  */
 int gpmc_calculate_ecc(int ecc_type, int cs,
-			const u_char *dat, u_char *ecc_code)
+		const u_char *dat, u_char *ecc_code)
 {
 	unsigned int reg;
 	unsigned int val1 = 0x0, val2 = 0x0;
@@ -985,7 +1023,6 @@ int gpmc_calculate_ecc(int ecc_type, int cs,
 		/* P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e */
 		*ecc_code++ = ((val1 >> 8) & 0x0f) | ((val1 >> 20) & 0xf0);
 	}
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(gpmc_calculate_ecc);
diff --git a/arch/arm/plat-omap/include/plat/gpmc.h b/arch/arm/plat-omap/include/plat/gpmc.h
index 1927459..8c58367 100644
--- a/arch/arm/plat-omap/include/plat/gpmc.h
+++ b/arch/arm/plat-omap/include/plat/gpmc.h
@@ -135,6 +135,19 @@ struct gpmc_timings {
 
 extern int omap_init_gpmc(struct gpmc_devices_info *pdata, int pdata_len);
 
+
+struct gpmc_devices_info {
+	void	*pdata;
+	int	flag;
+};
+
+#define	GPMC_DEVICE_NAND	(1 << 0)
+#define	GPMC_DEVICE_ONENAND	(1 << 1)
+#define	GPMC_DEVICE_NOR		(1 << 2)
+#define	GPMC_DEVICE_SMC91X	(1 << 3)
+#define	GPMC_DEVICE_SMS911X	(1 << 4)
+#define	GPMC_DEVICE_TUSB6010	(1 << 5)
+
 extern unsigned int gpmc_ns_to_ticks(unsigned int time_ns);
 extern unsigned int gpmc_ps_to_ticks(unsigned int time_ps);
 extern unsigned int gpmc_ticks_to_ns(unsigned int ticks);
@@ -158,7 +171,6 @@ extern int gpmc_read_status(int cmd);
 extern int gpmc_cs_configure(int cs, int cmd, int wval);
 extern int gpmc_nand_read(int cs, int cmd);
 extern int gpmc_nand_write(int cs, int cmd, int wval);
-extern struct clk *gpmc_clock(void);
 
 int gpmc_enable_hwecc(int ecc, int cs, int mode, int dev_width, int ecc_size);
 int gpmc_calculate_ecc(int ecc, int cs, const u_char *dat, u_char *ecc_code);
diff --git a/arch/arm/plat-omap/include/plat/nand.h b/arch/arm/plat-omap/include/plat/nand.h
index b9422ef..67fc506 100644
--- a/arch/arm/plat-omap/include/plat/nand.h
+++ b/arch/arm/plat-omap/include/plat/nand.h
@@ -29,7 +29,6 @@ struct omap_nand_platform_data {
 	unsigned long		phys_base;
 	int			devsize;
 	enum omap_ecc           ecc_opt;
-	struct clk              *ctrl_clk;
 };
 
 /* minimum size for IO mapping */
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 70cc6fd..d4b4d87 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -30,7 +30,6 @@ obj-$(CONFIG_MTD_NAND_NDFC)		+= ndfc.o
 obj-$(CONFIG_MTD_NAND_ATMEL)		+= atmel_nand.o
 obj-$(CONFIG_MTD_NAND_GPIO)		+= gpio.o
 obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o
-obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap_bch_decoder.o
 obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c
index 29bcf0b..afd5b04 100644
--- a/drivers/mtd/nand/omap2.c
+++ b/drivers/mtd/nand/omap2.c
@@ -20,7 +20,6 @@
 #include <linux/mtd/partitions.h>
 #include <linux/io.h>
 #include <linux/slab.h>
-#include <linux/clk.h>
 
 #include <plat/dma.h>
 #include <plat/gpmc.h>
@@ -98,8 +97,6 @@
 
 #define MAX_HWECC_BYTES_OOB_64     24
 
-int decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc);
-
 /* oob info generated runtime depending on ecc algorithm and layout selected */
 static struct nand_ecclayout omap_oobinfo;
 /* Define some generic bad / good block scan pattern which are used
@@ -133,7 +130,6 @@ struct omap_nand_info {
 	u_char				*buf;
 	int				buf_len;
 	int				ecc_opt;
-	struct clk                      *ctrl_clk;
 };
 
 /**
@@ -530,6 +526,7 @@ static void omap_read_buf_irq_pref(struct mtd_info *mtd, u_char *buf, int len)
 	struct omap_nand_info *info = container_of(mtd,
 						struct omap_nand_info, mtd);
 	int ret = 0;
+
 	if (len <= mtd->oobsize) {
 		omap_read_buf_pref(mtd, buf, len);
 		return;
@@ -837,41 +834,6 @@ static int omap_correct_data(struct mtd_info *mtd, u_char *dat,
 		}
 		break;
 
-	case OMAP_ECC_BCH4_CODE_HW:
-		eccsize = 7;
-		gpmc_calculate_ecc(info->ecc_opt, info->gpmc_cs, dat, calc_ecc);
-		for (i = 0; i < blockCnt; i++) {
-			/* check if any ecc error */
-			eccflag = 0;
-			for (j = 0; (j < eccsize) && (eccflag == 0); j++)
-				if (calc_ecc[j] != 0)
-					eccflag = 1;
-
-			if (eccflag == 1) {
-				eccflag = 0;
-				for (j = 0; (j < eccsize) &&
-						(eccflag == 0); j++)
-					if (read_ecc[j] != 0xFF)
-						eccflag = 1;
-			}
-
-			count = 0;
-			if (eccflag == 1)
-				count = decode_bch(0, calc_ecc, err_loc);
-
-			for (j = 0; j < count; j++) {
-				if (err_loc[j] < 4096)
-					dat[err_loc[j] >> 3] ^=
-							1 << (err_loc[j] & 7);
-				/* else, not interested to correct ecc */
-			}
-
-			stat += count;
-			calc_ecc = calc_ecc + eccsize;
-			read_ecc = read_ecc + eccsize;
-			dat += 512;
-		}
-		break;
 	}
 	return stat;
 }
@@ -1000,7 +962,6 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 
 	info->pdev = pdev;
 
-	info->ctrl_clk		= pdata->ctrl_clk;
 	info->gpmc_cs		= pdata->cs;
 	info->phys_base		= pdata->phys_base;
 
@@ -1046,6 +1007,7 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 		info->nand.waitfunc = omap_wait;
 		info->nand.chip_delay = 50;
 	}
+
 	switch (pdata->xfer_type) {
 	case NAND_OMAP_PREFETCH_POLLED:
 		info->nand.read_buf   = omap_read_buf_pref;
@@ -1117,7 +1079,7 @@ static int __devinit omap_nand_probe(struct platform_device *pdev)
 			info->nand.ecc.bytes    = 3;
 			info->nand.ecc.size     = 512;
 		}
-		info->nand.ecc.strength         = 1;
+
 		info->nand.ecc.calculate        = omap_calculate_ecc;
 		info->nand.ecc.hwctl            = omap_enable_hwecc;
 		info->nand.ecc.correct          = omap_correct_data;
@@ -1211,39 +1173,9 @@ static int omap_nand_remove(struct platform_device *pdev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-static int omap_nand_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct mtd_info *mtd = platform_get_drvdata(pdev);
-	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
-							mtd);
-
-	mtd->suspend(mtd);
-	clk_disable(info->ctrl_clk);
-	elm_clk_disable();
-	return 0;
-}
-
-static int omap_nand_resume(struct platform_device *pdev)
-{
-	struct mtd_info *mtd = platform_get_drvdata(pdev);
-	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
-							mtd);
-
-	elm_clk_enable();
-	clk_enable(info->ctrl_clk);
-	mtd->resume(mtd);
-	return 0;
-}
-#endif
-
 static struct platform_driver omap_nand_driver = {
 	.probe		= omap_nand_probe,
 	.remove		= omap_nand_remove,
-#ifdef CONFIG_PM
-	.suspend	= omap_nand_suspend,
-	.resume		= omap_nand_resume,
-#endif
 	.driver		= {
 		.name	= DRIVER_NAME,
 		.owner	= THIS_MODULE,
diff --git a/drivers/mtd/nand/omap_bch_decoder.c b/drivers/mtd/nand/omap_bch_decoder.c
deleted file mode 100644
index bb85f00..0000000
--- a/drivers/mtd/nand/omap_bch_decoder.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * drivers/mtd/nand/omap_omap_bch_decoder.c
- *
- * Whole BCH ECC Decoder (Post hardware generated syndrome decoding)
- *
- * Copyright (c) 2007 Texas Instruments
- *
- * Author: Sukumar Ghorai <s-ghorai@ti.com
- *		   Michael Fillinger <m-fillinger@ti.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#undef DEBUG
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-
-#define mm		13
-#define kk_shorten	4096
-#define nn		8191	/* Length of codeword, n = 2**mm - 1 */
-
-#define PPP	0x201B	/* Primary Polynomial : x^13 + x^4 + x^3 + x + 1 */
-#define P	0x001B	/* With omitted x^13 */
-#define POLY	12	/* degree of the primary Polynomial less one */
-
-/**
- * mpy_mod_gf - GALOIS field multiplier
- * Input  : A(x), B(x)
- * Output : A(x)*B(x) mod P(x)
- */
-static unsigned int mpy_mod_gf(unsigned int a, unsigned int b)
-{
-	unsigned int R = 0;
-	unsigned int R1 = 0;
-	unsigned int k = 0;
-
-	for (k = 0; k < mm; k++) {
-
-		R = (R << 1) & 0x1FFE;
-		if (R1 == 1)
-			R ^= P;
-
-		if (((a >> (POLY - k)) & 1) == 1)
-			R ^= b;
-
-		if (k < POLY)
-			R1 = (R >> POLY) & 1;
-	}
-	return R;
-}
-
-/**
- * chien - CHIEN search
- *
- * @location - Error location vector pointer
- *
- * Inputs  : ELP(z)
- *	     No. of found errors
- *	     Size of input codeword
- * Outputs : Up to 8 locations
- *	     No. of errors
- */
-static int chien(unsigned int select_4_8, int err_nums,
-				unsigned int err[], unsigned int *location)
-{
-	int i, count; /* Number of dectected errors */
-	/* Contains accumulation of evaluation at x^i (i:1->8) */
-	unsigned int gammas[8] = {0};
-	unsigned int alpha;
-	unsigned int bit, ecc_bits;
-	unsigned int elp_sum;
-
-	ecc_bits = (select_4_8 == 0) ? 52 : 104;
-
-	/* Start evaluation at Alpha**8192 and decreasing */
-	for (i = 0; i < 8; i++)
-		gammas[i] = err[i];
-
-	count = 0;
-	for (i = 1; (i <= nn) && (count < err_nums); i++) {
-
-		/* Result of evaluation at root */
-		elp_sum = 1 ^ gammas[0] ^ gammas[1] ^
-				gammas[2] ^ gammas[3] ^
-				gammas[4] ^ gammas[5] ^
-				gammas[6] ^ gammas[7];
-
-		alpha = PPP >> 1;
-		gammas[0] = mpy_mod_gf(gammas[0], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-2 */
-		gammas[1] = mpy_mod_gf(gammas[1], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-2 */
-		gammas[2] = mpy_mod_gf(gammas[2], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-3 */
-		gammas[3] = mpy_mod_gf(gammas[3], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-4 */
-		gammas[4] = mpy_mod_gf(gammas[4], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-5 */
-		gammas[5] = mpy_mod_gf(gammas[5], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-6 */
-		gammas[6] = mpy_mod_gf(gammas[6], alpha);
-		alpha = mpy_mod_gf(alpha, (PPP >> 1));	/* x alphha^-7 */
-		gammas[7] = mpy_mod_gf(gammas[7], alpha);
-
-		if (elp_sum == 0) {
-			/* calculate bit position in main data area */
-			bit = ((i-1) & ~7)|(7-((i-1) & 7));
-			if (i >= 2 * ecc_bits)
-				location[count++] =
-					kk_shorten - (bit - 2 * ecc_bits) - 1;
-		}
-	}
-
-	/* Failure: No. of detected errors != No. or corrected errors */
-	if (count != err_nums) {
-		count = -1;
-		printk(KERN_ERR "BCH decoding failed\n");
-	}
-	for (i = 0; i < count; i++)
-		pr_debug("%d ", location[i]);
-
-	return count;
-}
-
-/* synd : 16 Syndromes
- * return: gamaas - Coefficients to the error polynomial
- * return: : Number of detected errors
-*/
-static unsigned int berlekamp(unsigned int select_4_8,
-			unsigned int synd[], unsigned int err[])
-{
-	int loop, iteration;
-	unsigned int LL = 0;		/* Detected errors */
-	unsigned int d = 0;	/* Distance between Syndromes and ELP[n](z) */
-	unsigned int invd = 0;		/* Inverse of d */
-	/* Intermediate ELP[n](z).
-	 * Final ELP[n](z) is Error Location Polynomial
-	 */
-	unsigned int gammas[16] = {0};
-	/* Intermediate normalized ELP[n](z) : D[n](z) */
-	unsigned int D[16] = {0};
-	/* Temporary value that holds an ELP[n](z) coefficient */
-	unsigned int next_gamma = 0;
-
-	int e = 0;
-	unsigned int sign = 0;
-	unsigned int u = 0;
-	unsigned int v = 0;
-	unsigned int C1 = 0, C2 = 0;
-	unsigned int ss = 0;
-	unsigned int tmp_v = 0, tmp_s = 0;
-	unsigned int tmp_poly;
-
-	/*-------------- Step 0 ------------------*/
-	for (loop = 0; loop < 16; loop++)
-		gammas[loop] = 0;
-	gammas[0] = 1;
-	D[1] = 1;
-
-	iteration = 0;
-	LL = 0;
-	while ((iteration < ((select_4_8+1)*2*4)) &&
-			(LL <= ((select_4_8+1)*4))) {
-
-		pr_debug("\nIteration.............%d\n", iteration);
-		d = 0;
-		/* Step: 0 */
-		for (loop = 0; loop <= LL; loop++) {
-			tmp_poly = mpy_mod_gf(
-					gammas[loop], synd[iteration - loop]);
-			d ^= tmp_poly;
-			pr_debug("%02d. s=0 LL=%x poly %x\n",
-					loop, LL, tmp_poly);
-		}
-
-		/* Step 1: 1 cycle only to perform inversion */
-		v = d << 1;
-		e = -1;
-		sign = 1;
-		ss = 0x2000;
-		invd = 0;
-		u = PPP;
-		for (loop = 0; (d != 0) && (loop <= (2 * POLY)); loop++) {
-			pr_debug("%02d. s=1 LL=%x poly NULL\n",
-						loop, LL);
-			C1 = (v >> 13) & 1;
-			C2 = C1 & sign;
-
-			sign ^= C2 ^ (e == 0);
-
-			tmp_v = v;
-			tmp_s = ss;
-
-			if (C1 == 1) {
-				v ^= u;
-				ss ^= invd;
-			}
-			v = (v << 1) & 0x3FFF;
-			if (C2 == 1) {
-				u = tmp_v;
-				invd = tmp_s;
-				e = -e;
-			}
-			invd >>= 1;
-			e--;
-		}
-
-		for (loop = 0; (d != 0) && (loop <= (iteration + 1)); loop++) {
-			/* Step 2
-			 * Interleaved with Step 3, if L<(n-k)
-			 * invd: Update of ELP[n](z) = ELP[n-1](z) - d.D[n-1](z)
-			 */
-
-			/* Holds value of ELP coefficient until precedent
-			 * value does not have to be used anymore
-			 */
-			tmp_poly = mpy_mod_gf(d, D[loop]);
-			pr_debug("%02d. s=2 LL=%x poly %x\n",
-						loop, LL, tmp_poly);
-
-			next_gamma = gammas[loop] ^ tmp_poly;
-			if ((2 * LL) < (iteration + 1)) {
-				/* Interleaving with Step 3
-				 * for parallelized update of ELP(z) and D(z)
-				 */
-			} else {
-				/* Update of ELP(z) only -> stay in Step 2 */
-				gammas[loop] = next_gamma;
-				if (loop == (iteration + 1)) {
-					/* to step 4 */
-					break;
-				}
-			}
-
-			/* Step 3
-			 * Always interleaved with Step 2 (case when L<(n-k))
-			 * Update of D[n-1](z) = ELP[n-1](z)/d
-			 */
-			D[loop] = mpy_mod_gf(gammas[loop], invd);
-			pr_debug("%02d. s=3 LL=%x poly %x\n",
-					loop, LL, D[loop]);
-
-			/* Can safely update ELP[n](z) */
-			gammas[loop] = next_gamma;
-
-			if (loop == (iteration + 1)) {
-				/* If update finished */
-				LL = iteration - LL + 1;
-				/* to step 4 */
-				break;
-			}
-			/* Else, interleaving to step 2*/
-		}
-
-		/* Step 4: Update D(z): i:0->L */
-		/* Final update of D[n](z) = D[n](z).z*/
-		for (loop = 0; loop < 15; loop++) /* Left Shift */
-			D[15 - loop] = D[14 - loop];
-
-		D[0] = 0;
-
-		iteration++;
-	} /* while */
-
-	/* Processing finished, copy ELP to final registers : 0->2t-1*/
-	for (loop = 0; loop < 8; loop++)
-		err[loop] = gammas[loop+1];
-
-	pr_debug("\n Err poly:");
-	for (loop = 0; loop < 8; loop++)
-		pr_debug("0x%x ", err[loop]);
-
-	return LL;
-}
-
-/*
- * syndrome - Generate syndrome components from hw generate syndrome
- * r(x) = c(x) + e(x)
- * s(x) = c(x) mod g(x) + e(x) mod g(x) =  e(x) mod g(x)
- * so receiver checks if the syndrome s(x) = r(x) mod g(x) is equal to zero.
- * unsigned int s[16]; - Syndromes
- */
-static void syndrome(unsigned int select_4_8,
-					unsigned char *ecc, unsigned int syn[])
-{
-	unsigned int k, l, t;
-	unsigned int alpha_bit, R_bit;
-	int ecc_pos, ecc_min;
-
-	/* 2t-1 = 15 (for t=8) minimal polynomials of the first 15 powers of a
-	 * primitive elemmants of GF(m); Even powers minimal polynomials are
-	 * duplicate of odd powers' minimal polynomials.
-	 * Odd powers of alpha (1 to 15)
-	 */
-	unsigned int pow_alpha[8] = {0x0002, 0x0008, 0x0020, 0x0080,
-				 0x0200, 0x0800, 0x001B, 0x006C};
-
-	pr_debug("\n ECC[0..n]: ");
-	for (k = 0; k < 13; k++)
-		pr_debug("0x%x ", ecc[k]);
-
-	if (select_4_8 == 0) {
-		t = 4;
-		ecc_pos = 55; /* bits(52-bits): 55->4 */
-		ecc_min = 4;
-	} else {
-		t = 8;
-		ecc_pos = 103; /* bits: 103->0 */
-		ecc_min = 0;
-	}
-
-	/* total numbber of syndrom to be used is 2t */
-	/* Step1: calculate the odd syndrome(s) */
-	R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);
-	ecc_pos--;
-	for (k = 0; k < t; k++)
-		syn[2 * k] = R_bit;
-
-	while (ecc_pos >= ecc_min) {
-		R_bit = ((ecc[ecc_pos/8] >> (7 - ecc_pos%8)) & 1);
-		ecc_pos--;
-
-		for (k = 0; k < t; k++) {
-			/* Accumulate value of x^i at alpha^(2k+1) */
-			if (R_bit == 1)
-				syn[2*k] ^= pow_alpha[k];
-
-			/* Compute a**(2k+1), using LSFR */
-			for (l = 0; l < (2 * k + 1); l++) {
-				alpha_bit = (pow_alpha[k] >> POLY) & 1;
-				pow_alpha[k] = (pow_alpha[k] << 1) & 0x1FFF;
-				if (alpha_bit == 1)
-					pow_alpha[k] ^= P;
-			}
-		}
-	}
-
-	/* Step2: calculate the even syndrome(s)
-	 * Compute S(a), where a is an even power of alpha
-	 * Evenry even power of primitive element has the same minimal
-	 * polynomial as some odd power of elemets.
-	 * And based on S(a^2) = S^2(a)
-	 */
-	for (k = 0; k < t; k++)
-		syn[2*k+1] = mpy_mod_gf(syn[k], syn[k]);
-
-	pr_debug("\n Syndromes: ");
-	for (k = 0; k < 16; k++)
-		pr_debug("0x%x ", syn[k]);
-}
-
-/**
- * decode_bch - BCH decoder for 4- and 8-bit error correction
- *
- * @ecc - ECC syndrome generated by hw BCH engine
- * @err_loc - pointer to error location array
- *
- * This function does post sydrome generation (hw generated) decoding
- * for:-
- * Dimension of Galoise Field: m = 13
- * Length of codeword: n = 2**m - 1
- * Number of errors that can be corrected: 4- or 8-bits
- * Length of information bit: kk = nn - rr
- */
-int decode_bch(int select_4_8, unsigned char *ecc, unsigned int *err_loc)
-{
-	int no_of_err;
-	unsigned int syn[16] = {0,};	/* 16 Syndromes */
-	unsigned int err_poly[8] = {0,};
-	/* Coefficients to the error polynomial
-	 * ELP(x) = 1 + err0.x + err1.x^2 + ... + err7.x^8
-	 */
-
-	/* Decoting involes three steps
-	 * 1. Compute the syndrom from teh received codeword,
-	 * 2. Find the error location polynomial from a set of equations
-	 *     derived from the syndrome,
-	 * 3. Use the error location polynomial to identify errants bits,
-	 *
-	 * And correcttion done by bit flips using error locaiton and expected
-	 * to be outseide of this implementation.
-	 */
-	syndrome(select_4_8, ecc, syn);
-	no_of_err = berlekamp(select_4_8, syn, err_poly);
-	if (no_of_err <= (4 << select_4_8))
-		no_of_err = chien(select_4_8, no_of_err, err_poly, err_loc);
-
-	return no_of_err;
-}
-EXPORT_SYMBOL(decode_bch);
-MODULE_LICENSE("GPL");
-- 
1.7.5.4

