From 264ab3501b4b0397be16e89c75e9fcd3b1aaf2a5 Mon Sep 17 00:00:00 2001
From: Mugunthan V N <mugunthanvnm@ti.com>
Date: Tue, 7 Aug 2012 14:06:53 +0800
Subject: [PATCH 315/609] ethernet: cpsw: runtime PM support

Original commit: a691913b9e2f1f4dfefde3c8f0a555f96c5302b9

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Enabling runtime PM support for cpsw and davinci mdio modules

As per hardware specs cpsw and mdio are of same module and has only one
clock control and sys control register. In software cpsw and davinci mdio
are two different independent devices, even if we specify cpsw as parent
and mdio as child, hwmod doesn't traverse the tree to ensure that all its
children are in disabled state before disabling parent's clock. To over
come this issue, cpgmac clock is enabled in cpsw probe itself, so that
cpgmac clock enable/disable happens only in cpsw/mdio probe/remove and
suspend/resume.

Side effects:
cpgmac module will be enabled even when Ethernet interface is not brought
up. For power optimization with no Ethernet, it is recommended to remove
the cpsw and mdio modules in kernel config which will make cpgmac to be
disabled state.

Todo:
Find a way in hwmod or driver to specify mdio and cpsw devices shares
same clock and the clock can be disabled only when both the devices are
in closed state

Signed-off-by: Mugunthan V N <mugunthanvnm@ti.com>
---
 drivers/net/ethernet/ti/cpsw.c          |   30 +++++++++++++++++-------------
 drivers/net/ethernet/ti/davinci_cpdma.c |   11 -----------
 drivers/net/ethernet/ti/davinci_mdio.c  |   26 ++++++++++++--------------
 3 files changed, 29 insertions(+), 38 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 4c36a6e..cffd492 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -28,6 +28,7 @@
 #include <linux/phy.h>
 #include <linux/workqueue.h>
 #include <linux/delay.h>
+#include <linux/pm_runtime.h>
 
 #include <linux/platform_data/cpsw.h>
 
@@ -1386,10 +1387,13 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	priv->slaves[0].ndev = ndev;
 	priv->emac_port = 0;
 
-	priv->clk = clk_get(&pdev->dev, NULL);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+	priv->clk = clk_get(&pdev->dev, "fck");
 	if (IS_ERR(priv->clk)) {
-		dev_err(priv->dev, "failed to get device clock)\n");
-		ret = -EBUSY;
+		dev_err(&pdev->dev, "fck is not found\n");
+		ret = -ENODEV;
+		goto clean_slave_ret;
 	}
 
 	priv->coal_intvl = 0;
@@ -1598,6 +1602,9 @@ clean_cpsw_iores_ret:
 			   resource_size(priv->cpsw_res));
 clean_clk_ret:
 	clk_put(priv->clk);
+clean_slave_ret:
+	pm_runtime_get_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 	kfree(priv->slaves);
 clean_ndev_ret:
 	free_netdev(ndev);
@@ -1646,10 +1653,11 @@ static inline void cpsw_start_slaves_interface(struct net_device *ndev)
 	}
 }
 
-static inline void cpsw_stop_slaves_interface(struct net_device *ndev,
-					      struct cpsw_priv *priv)
+static inline void cpsw_stop_slaves_interface(struct net_device *ndev)
 {
 	u32 i = 0;
+	struct cpsw_priv *priv = netdev_priv(ndev);
+
 	for (i = 0; i < priv->data.slaves; i++) {
 		ndev = cpsw_get_slave_ndev(priv, i);
 		if (netif_running(ndev))
@@ -1662,7 +1670,7 @@ static inline void cpsw_stop_slaves_interface(struct net_device *ndev,
 #define cpsw_start_slaves_interface(ndev)		\
 	if (netif_running(ndev))			\
 		cpsw_ndo_open(ndev)
-#define cpsw_stop_slaves_interface(ndev, priv)		\
+#define cpsw_stop_slaves_interface(ndev)		\
 	if (netif_running(ndev))			\
 		cpsw_ndo_stop(ndev)
 
@@ -1672,14 +1680,9 @@ static int cpsw_suspend(struct device *dev)
 {
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct net_device	*ndev = platform_get_drvdata(pdev);
-	struct cpsw_priv	*priv = netdev_priv(ndev);
-
-	cpsw_stop_slaves_interface(ndev, priv);
 
-	soft_reset("cpsw", &priv->regs->soft_reset);
-	soft_reset("sliver 0", &priv->slaves[0].sliver->soft_reset);
-	soft_reset("sliver 1", &priv->slaves[1].sliver->soft_reset);
-	soft_reset("cpsw_ss", &priv->ss_regs->soft_reset);
+	cpsw_stop_slaves_interface(ndev);
+	pm_runtime_put_sync(&pdev->dev);
 
 	return 0;
 }
@@ -1689,6 +1692,7 @@ static int cpsw_resume(struct device *dev)
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct net_device	*ndev = platform_get_drvdata(pdev);
 
+	pm_runtime_get_sync(&pdev->dev);
 	cpsw_start_slaves_interface(ndev);
 
 	return 0;
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 6a9c810..b608831 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -359,17 +359,6 @@ int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr)
 
 	ctlr->state = CPDMA_STATE_IDLE;
 
-	if (ctlr->params.has_soft_reset) {
-		unsigned long timeout = jiffies + HZ/10;
-
-		dma_reg_write(ctlr, CPDMA_SOFTRESET, 1);
-		while (time_before(jiffies, timeout)) {
-			if (dma_reg_read(ctlr, CPDMA_SOFTRESET) == 0)
-				break;
-		}
-		WARN_ON(!time_before(jiffies, timeout));
-	}
-
 	spin_unlock_irqrestore(&ctlr->lock, flags);
 
 	return 0;
diff --git a/drivers/net/ethernet/ti/davinci_mdio.c b/drivers/net/ethernet/ti/davinci_mdio.c
index d3bad97..53c89c2 100644
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@ -34,6 +34,7 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/pm_runtime.h>
 #include <linux/davinci_emac.h>
 
 /*
@@ -325,7 +326,9 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 	snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",
 		pdev->name, pdev->id);
 
-	data->clk = clk_get(dev, NULL);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+	data->clk = clk_get(&pdev->dev, "fck");
 	if (IS_ERR(data->clk)) {
 		dev_err(dev, "failed to get device clock\n");
 		ret = PTR_ERR(data->clk);
@@ -333,8 +336,6 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 		goto bail_out;
 	}
 
-	clk_enable(data->clk);
-
 	dev_set_drvdata(dev, data);
 	data->dev = dev;
 	spin_lock_init(&data->lock);
@@ -381,11 +382,10 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 bail_out:
 	if (data->bus)
 		mdiobus_free(data->bus);
-
-	if (data->clk) {
-		clk_disable(data->clk);
+	if (data->clk)
 		clk_put(data->clk);
-	}
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	kfree(data);
 
@@ -400,10 +400,10 @@ static int __devexit davinci_mdio_remove(struct platform_device *pdev)
 	if (data->bus)
 		mdiobus_free(data->bus);
 
-	if (data->clk) {
-		clk_disable(data->clk);
+	if (data->clk)
 		clk_put(data->clk);
-	}
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	dev_set_drvdata(dev, NULL);
 
@@ -425,8 +425,7 @@ static int davinci_mdio_suspend(struct device *dev)
 	__raw_writel(ctrl, &data->regs->control);
 	wait_for_idle(data);
 
-	if (data->clk)
-		clk_disable(data->clk);
+	pm_runtime_put_sync(data->dev);
 
 	data->suspended = true;
 	spin_unlock(&data->lock);
@@ -467,8 +466,7 @@ static int davinci_mdio_resume(struct device *dev)
 	u32 ctrl;
 
 	spin_lock(&data->lock);
-	if (data->clk)
-		clk_enable(data->clk);
+	pm_runtime_put_sync(data->dev);
 
 	/* Need to wait till Module is enabled */
 	wait_for_clock_enable(data);
-- 
1.7.5.4

