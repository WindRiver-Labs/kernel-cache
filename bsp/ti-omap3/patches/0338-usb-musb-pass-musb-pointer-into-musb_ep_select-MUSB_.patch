From 6d0cfcc1d455941aea25a4e413792ac6cf656ada Mon Sep 17 00:00:00 2001
From: Ming Lei <tom.leiming@gmail.com>
Date: Wed, 8 Aug 2012 13:59:32 +0800
Subject: [PATCH 338/609] usb: musb: pass musb pointer into musb_ep_select &
 MUSB_EP_OFFSET

Original commit: bdc0023ab80c8863657d07303807437172450af8

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This patche adds the paramer of musb pointer to musb_ep_select
and MUSB_EP_OFFSET, then we can pass musb into this two helpers
and can give corresponding implementation for flat mappings and
indexed mappings of hw endpoint register address using the information
from hw glue driver.

Signed-off-by: Ming Lei <tom.leiming@gmail.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi_dma.c        |   10 ++++++----
 drivers/usb/musb/musb_core.c       |   10 +++++-----
 drivers/usb/musb/musb_core.h       |    7 ++++---
 drivers/usb/musb/musb_gadget.c     |   20 ++++++++++----------
 drivers/usb/musb/musb_gadget_ep0.c |   24 ++++++++++++------------
 drivers/usb/musb/musb_host.c       |   26 +++++++++++++-------------
 drivers/usb/musb/musb_regs.h       |    8 ++++----
 drivers/usb/musb/musbhsdma.c       |   10 +++++-----
 drivers/usb/musb/tusb6010_omap.c   |    6 +++---
 9 files changed, 62 insertions(+), 59 deletions(-)

diff --git a/drivers/usb/musb/cppi_dma.c b/drivers/usb/musb/cppi_dma.c
index 709af43..6d6378b 100644
--- a/drivers/usb/musb/cppi_dma.c
+++ b/drivers/usb/musb/cppi_dma.c
@@ -359,8 +359,9 @@ cppi_dump_rx(int level, struct cppi_channel *c, const char *tag)
 {
 	void __iomem			*base = c->controller->mregs;
 	struct cppi_rx_stateram __iomem	*rx = c->state_ram;
+	struct musb		*musb = c->controller->musb;
 
-	musb_ep_select(base, c->index + 1);
+	musb_ep_select(musb, base, c->index + 1);
 
 	dev_dbg(c->controller->musb->controller,
 		"RX DMA%d%s: %d left, csr %04x, "
@@ -390,8 +391,9 @@ cppi_dump_tx(int level, struct cppi_channel *c, const char *tag)
 {
 	void __iomem			*base = c->controller->mregs;
 	struct cppi_tx_stateram __iomem	*tx = c->state_ram;
+	struct musb		*musb = c->controller->musb;
 
-	musb_ep_select(base, c->index + 1);
+	musb_ep_select(musb, base, c->index + 1);
 
 	dev_dbg(c->controller->musb->controller,
 		"TX DMA%d%s: csr %04x, "
@@ -1117,7 +1119,7 @@ static bool cppi_rx_scan(struct cppi *cppi, unsigned ch)
 			 */
 			WARN_ON(rx->head);
 		}
-		musb_ep_select(cppi->mregs, rx->index + 1);
+		musb_ep_select(cppi->musb, cppi->mregs, rx->index + 1);
 		csr = musb_readw(regs, MUSB_RXCSR);
 		if (csr & MUSB_RXCSR_DMAENAB) {
 			dev_dbg(musb->controller, "list%d %p/%p, last %llx%s, csr %04x\n",
@@ -1428,7 +1430,7 @@ static int cppi_channel_abort(struct dma_channel *channel)
 	 * and caller should rely on us not changing it.
 	 * peripheral code is safe ... check host too.
 	 */
-	musb_ep_select(mbase, cppi_ch->index + 1);
+	musb_ep_select(controller->musb, mbase, cppi_ch->index + 1);
 
 	if (cppi_ch->transmit) {
 		struct cppi_tx_stateram __iomem *tx_ram;
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index fcb0ad2..09bdc72 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -382,7 +382,7 @@ void musb_load_testpacket(struct musb *musb)
 {
 	void __iomem	*regs = musb->endpoints[0].regs;
 
-	musb_ep_select(musb->mregs, 0);
+	musb_ep_select(musb, musb->mregs, 0);
 	musb->ops->write_fifo(musb->control_ep,
 			sizeof(musb_test_packet), musb_test_packet);
 	musb_writew(regs, MUSB_CSR0, MUSB_CSR0_TXPKTRDY);
@@ -1368,7 +1368,7 @@ static int __devinit ep_config_from_hw(struct musb *musb)
 	/* FIXME pick up ep0 maxpacket size */
 
 	for (epnum = 1; epnum < musb->config->num_eps; epnum++) {
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		hw_ep = musb->endpoints + epnum;
 
 		ret = musb_read_fifosize(musb, hw_ep, epnum);
@@ -1501,7 +1501,7 @@ static int __devinit musb_core_init(u16 musb_type, struct musb *musb)
 			hw_ep->fifo = MUSB_FIFO_OFFSET(i) + mbase;
 		}
 
-		hw_ep->regs = MUSB_EP_OFFSET(i, 0) + mbase;
+		hw_ep->regs = MUSB_EP_OFFSET(musb, i, 0) + mbase;
 		hw_ep->target_regs = musb_read_target_reg_base(i, mbase);
 		hw_ep->rx_reinit = 1;
 		hw_ep->tx_reinit = 1;
@@ -1603,7 +1603,7 @@ irqreturn_t musb_interrupt(struct musb *musb)
 	ep_num = 1;
 	while (reg) {
 		if (reg & 1) {
-			/* musb_ep_select(musb->mregs, ep_num); */
+			/* musb_ep_select(musb, musb->mregs, ep_num); */
 			/* REVISIT just retval = ep->rx_irq(...) */
 			retval = IRQ_HANDLED;
 			if (devctl & MUSB_DEVCTL_HM) {
@@ -1624,7 +1624,7 @@ irqreturn_t musb_interrupt(struct musb *musb)
 	ep_num = 1;
 	while (reg) {
 		if (reg & 1) {
-			/* musb_ep_select(musb->mregs, ep_num); */
+			/* musb_ep_select(musb, musb->mregs, ep_num); */
 			/* REVISIT just retval |= ep->tx_irq(...) */
 			retval = IRQ_HANDLED;
 			if (devctl & MUSB_DEVCTL_HM) {
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 3336c71..d2d5cae 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -175,12 +175,13 @@ enum musb_g_ep0_state {
 
 /* "flat" mapping: each endpoint has its own i/o address */
 #ifdef	MUSB_FLAT_REG
-#define musb_ep_select(_mbase, _epnum)	(((void)(_mbase)), ((void)(_epnum)))
+#define musb_ep_select(_musb, _mbase, _epnum)	\
+	(((void)(_mbase)), ((void)(_epnum)))
 #define	MUSB_EP_OFFSET			MUSB_FLAT_OFFSET
 
 /* "indexed" mapping: INDEX register controls register bank select */
 #else
-#define musb_ep_select(_mbase, _epnum) \
+#define musb_ep_select(_musb, _mbase, _epnum) \
 	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
 #define	MUSB_EP_OFFSET			MUSB_INDEXED_OFFSET
 #endif
@@ -504,7 +505,7 @@ static inline int musb_read_fifosize(struct musb *musb,
 	u8 reg = 0;
 
 	/* read from core using indexed model */
-	reg = musb_readb(mbase, MUSB_EP_OFFSET(epnum, MUSB_FIFOSIZE));
+	reg = musb_readb(mbase, MUSB_EP_OFFSET(musb, epnum, MUSB_FIFOSIZE));
 	/* 0's returned when no more endpoints */
 	if (!reg)
 		return -ENODEV;
diff --git a/drivers/usb/musb/musb_gadget.c b/drivers/usb/musb/musb_gadget.c
index 5016d19..2e4ac84 100644
--- a/drivers/usb/musb/musb_gadget.c
+++ b/drivers/usb/musb/musb_gadget.c
@@ -492,7 +492,7 @@ void musb_g_tx(struct musb *musb, u8 epnum)
 	void __iomem		*epio = musb->endpoints[epnum].regs;
 	struct dma_channel	*dma;
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 	req = next_request(musb_ep);
 	request = &req->request;
 
@@ -910,7 +910,7 @@ void musb_g_rx(struct musb *musb, u8 epnum)
 	else
 		musb_ep = &hw_ep->ep_out;
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 
 	req = next_request(musb_ep);
 	if (!req)
@@ -1077,7 +1077,7 @@ static int musb_gadget_enable(struct usb_ep *ep,
 	/* enable the interrupts for the endpoint, set the endpoint
 	 * packet size (or fail), set the mode, clear the fifo
 	 */
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 	if (usb_endpoint_dir_in(desc)) {
 		u16 int_txe = musb_readw(mbase, MUSB_INTRTXE);
 
@@ -1217,7 +1217,7 @@ static int musb_gadget_disable(struct usb_ep *ep)
 
 	pm_runtime_get_sync(musb->controller);
 	spin_lock_irqsave(&musb->lock, flags);
-	musb_ep_select(musb->mregs, epnum);
+	musb_ep_select(musb, musb->mregs, epnum);
 
 	/* zero the endpoint sizes */
 	if (musb_ep->is_in) {
@@ -1299,7 +1299,7 @@ void musb_ep_restart(struct musb *musb, struct musb_request *req)
 		&req->request, req->request.length, req->epnum);
 
 	pm_runtime_get_sync(musb->controller);
-	musb_ep_select(musb->mregs, req->epnum);
+	musb_ep_select(musb, musb->mregs, req->epnum);
 	pm_runtime_put(musb->controller);
 
 	if (req->tx)
@@ -1395,7 +1395,7 @@ static int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *request)
 	else if (is_dma_capable() && musb_ep->dma) {
 		struct dma_controller	*c = musb->dma_controller;
 
-		musb_ep_select(musb->mregs, musb_ep->current_epnum);
+		musb_ep_select(musb, musb->mregs, musb_ep->current_epnum);
 		if (c->channel_abort)
 			status = c->channel_abort(musb_ep->dma);
 		else
@@ -1443,7 +1443,7 @@ static int musb_gadget_set_halt(struct usb_ep *ep, int value)
 		goto done;
 	}
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 
 	request = next_request(musb_ep);
 	if (value) {
@@ -1531,7 +1531,7 @@ static int musb_gadget_fifo_status(struct usb_ep *ep)
 
 		spin_lock_irqsave(&musb->lock, flags);
 
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		/* FIXME return zero unless RXPKTRDY is set */
 		retval = musb_readw(epio, MUSB_RXCOUNT);
 
@@ -1554,7 +1554,7 @@ static void musb_gadget_fifo_flush(struct usb_ep *ep)
 	mbase = musb->mregs;
 
 	spin_lock_irqsave(&musb->lock, flags);
-	musb_ep_select(mbase, (u8) epnum);
+	musb_ep_select(musb, mbase, (u8) epnum);
 
 	/* disable interrupts */
 	int_txe = musb_readw(mbase, MUSB_INTRTXE);
@@ -2019,7 +2019,7 @@ static void stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
 		for (i = 0, hw_ep = musb->endpoints;
 				i < musb->nr_endpoints;
 				i++, hw_ep++) {
-			musb_ep_select(musb->mregs, i);
+			musb_ep_select(musb, musb->mregs, i);
 			if (hw_ep->is_shared_fifo /* || !epnum */) {
 				nuke(&hw_ep->ep_in, -ESHUTDOWN);
 			} else {
diff --git a/drivers/usb/musb/musb_gadget_ep0.c b/drivers/usb/musb/musb_gadget_ep0.c
index e5b350d..32fd014 100644
--- a/drivers/usb/musb/musb_gadget_ep0.c
+++ b/drivers/usb/musb/musb_gadget_ep0.c
@@ -127,14 +127,14 @@ static int service_tx_status_request(
 			break;
 		}
 
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		if (is_in)
 			tmp = musb_readw(regs, MUSB_TXCSR)
 						& MUSB_TXCSR_P_SENDSTALL;
 		else
 			tmp = musb_readw(regs, MUSB_RXCSR)
 						& MUSB_RXCSR_P_SENDSTALL;
-		musb_ep_select(mbase, 0);
+		musb_ep_select(musb, mbase, 0);
 
 		result[0] = tmp ? 1 : 0;
 		} break;
@@ -282,7 +282,7 @@ __acquires(musb->lock)
 				if (musb_ep->wedged)
 					break;
 
-				musb_ep_select(mbase, epnum);
+				musb_ep_select(musb, mbase, epnum);
 				if (is_in) {
 					csr  = musb_readw(regs, MUSB_TXCSR);
 					csr |= MUSB_TXCSR_CLRDATATOG |
@@ -308,7 +308,7 @@ __acquires(musb->lock)
 				}
 
 				/* select ep0 again */
-				musb_ep_select(mbase, 0);
+				musb_ep_select(musb, mbase, 0);
 				} break;
 			default:
 				/* class, vendor, etc ... delegate */
@@ -441,7 +441,7 @@ stall:
 				if (!musb_ep->desc)
 					break;
 
-				musb_ep_select(mbase, epnum);
+				musb_ep_select(musb, mbase, epnum);
 				if (is_in) {
 					csr = musb_readw(regs, MUSB_TXCSR);
 					if (csr & MUSB_TXCSR_FIFONOTEMPTY)
@@ -460,7 +460,7 @@ stall:
 				}
 
 				/* select ep0 again */
-				musb_ep_select(mbase, 0);
+				musb_ep_select(musb, mbase, 0);
 				handled = 1;
 				} break;
 
@@ -527,7 +527,7 @@ static void ep0_rxstate(struct musb *musb)
 			return;
 		musb->ackpend = 0;
 	}
-	musb_ep_select(musb->mregs, 0);
+	musb_ep_select(musb, musb->mregs, 0);
 	musb_writew(regs, MUSB_CSR0, csr);
 }
 
@@ -584,7 +584,7 @@ static void ep0_txstate(struct musb *musb)
 	}
 
 	/* send it out, triggering a "txpktrdy cleared" irq */
-	musb_ep_select(musb->mregs, 0);
+	musb_ep_select(musb, musb->mregs, 0);
 	musb_writew(regs, MUSB_CSR0, csr);
 }
 
@@ -669,7 +669,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *musb)
 	void __iomem	*regs = musb->endpoints[0].regs;
 	irqreturn_t	retval = IRQ_NONE;
 
-	musb_ep_select(mbase, 0);	/* select ep0 */
+	musb_ep_select(musb, mbase, 0);	/* select ep0 */
 	csr = musb_readw(regs, MUSB_CSR0);
 	len = musb_readb(regs, MUSB_COUNT0);
 
@@ -879,7 +879,7 @@ setup:
 
 			handled = forward_to_driver(musb, &setup);
 			if (handled < 0) {
-				musb_ep_select(mbase, 0);
+				musb_ep_select(musb, mbase, 0);
 stall:
 				dev_dbg(musb->controller, "stall (%d)\n", handled);
 				musb->ackpend |= MUSB_CSR0_P_SENDSTALL;
@@ -974,7 +974,7 @@ musb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)
 			ep->name, ep->is_in ? "IN/TX" : "OUT/RX",
 			req->request.length);
 
-	musb_ep_select(musb->mregs, 0);
+	musb_ep_select(musb, musb->mregs, 0);
 
 	/* sequence #1, IN ... start writing the data */
 	if (musb->ep0_state == MUSB_EP0_STAGE_TX)
@@ -1037,7 +1037,7 @@ static int musb_g_ep0_halt(struct usb_ep *e, int value)
 		goto cleanup;
 	}
 
-	musb_ep_select(base, 0);
+	musb_ep_select(musb, base, 0);
 	csr = musb->ackpend;
 
 	switch (musb->ep0_state) {
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 3bcfafd..c5a9842 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -456,7 +456,7 @@ musb_host_packet_rx(struct musb *musb, struct urb *urb, u8 epnum, u8 iso_err)
 	int			pipe = urb->pipe;
 	void			*buffer = urb->transfer_buffer;
 
-	/* musb_ep_select(mbase, epnum); */
+	/* musb_ep_select(musb, mbase, epnum); */
 	rx_count = musb_readw(epio, MUSB_RXCOUNT);
 	dev_dbg(musb->controller, "RX%d count %d, buffer %p len %d/%d\n", epnum, rx_count,
 			urb->transfer_buffer, qh->offset,
@@ -692,7 +692,7 @@ static void musb_ep_program(struct musb *musb, u8 epnum,
 			qh->h_addr_reg, qh->h_port_reg,
 			len);
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 
 	/* candidate for DMA? */
 	dma_controller = musb->dma_controller;
@@ -968,7 +968,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *musb)
 	/* ep0 only has one queue, "in" */
 	urb = next_urb(qh);
 
-	musb_ep_select(mbase, 0);
+	musb_ep_select(musb, mbase, 0);
 	csr = musb_readw(epio, MUSB_CSR0);
 	len = (csr & MUSB_CSR0_RXPKTRDY)
 			? musb_readb(epio, MUSB_COUNT0)
@@ -1107,7 +1107,7 @@ void musb_host_tx(struct musb *musb, u8 epnum)
 	struct dma_channel	*dma;
 	bool			transfer_pending = false;
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 	tx_csr = musb_readw(epio, MUSB_TXCSR);
 
 	/* with CPPI, DMA sometimes triggers "extra" irqs */
@@ -1146,7 +1146,7 @@ void musb_host_tx(struct musb *musb, u8 epnum)
 		 * if (bulk && qh->ring.next != &musb->out_bulk), then
 		 * we have a candidate... NAKing is *NOT* an error
 		 */
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		musb_writew(epio, MUSB_TXCSR,
 				MUSB_TXCSR_H_WZC_BITS
 				| MUSB_TXCSR_TXPKTRDY);
@@ -1170,7 +1170,7 @@ void musb_host_tx(struct musb *musb, u8 epnum)
 				| MUSB_TXCSR_H_NAKTIMEOUT
 				);
 
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		musb_writew(epio, MUSB_TXCSR, tx_csr);
 		/* REVISIT may need to clear FLUSHFIFO ... */
 		musb_writew(epio, MUSB_TXCSR, tx_csr);
@@ -1325,7 +1325,7 @@ void musb_host_tx(struct musb *musb, u8 epnum)
 	musb->ops->write_fifo(hw_ep, length, urb->transfer_buffer + offset);
 	qh->segsize = length;
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 	musb_writew(epio, MUSB_TXCSR,
 			MUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);
 }
@@ -1382,7 +1382,7 @@ static void musb_bulk_rx_nak_timeout(struct musb *musb, struct musb_hw_ep *ep)
 	struct musb_qh		*cur_qh, *next_qh;
 	u16			rx_csr;
 
-	musb_ep_select(mbase, ep->epnum);
+	musb_ep_select(musb, mbase, ep->epnum);
 	dma = is_dma_capable() ? ep->rx_channel : NULL;
 
 	/* clear nak timeout bit */
@@ -1433,7 +1433,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 	u32			status;
 	struct dma_channel	*dma;
 
-	musb_ep_select(mbase, epnum);
+	musb_ep_select(musb, mbase, epnum);
 
 	urb = next_urb(qh);
 	dma = is_dma_capable() ? hw_ep->rx_channel : NULL;
@@ -1493,7 +1493,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 				musb_bulk_rx_nak_timeout(musb, hw_ep);
 				return;
 			}
-			musb_ep_select(mbase, epnum);
+			musb_ep_select(musb, mbase, epnum);
 			rx_csr |= MUSB_RXCSR_H_WZC_BITS;
 			rx_csr &= ~MUSB_RXCSR_DATAERROR;
 			musb_writew(epio, MUSB_RXCSR, rx_csr);
@@ -1555,7 +1555,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 				xfer_len, dma ? ", dma" : "");
 		rx_csr &= ~MUSB_RXCSR_H_REQPKT;
 
-		musb_ep_select(mbase, epnum);
+		musb_ep_select(musb, mbase, epnum);
 		musb_writew(epio, MUSB_RXCSR,
 				MUSB_RXCSR_H_WZC_BITS | rx_csr);
 	}
@@ -1618,7 +1618,7 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 
 /* SCRUB (RX) */
 			/* do the proper sequence to abort the transfer */
-			musb_ep_select(mbase, epnum);
+			musb_ep_select(musb, mbase, epnum);
 			val &= ~MUSB_RXCSR_H_REQPKT;
 			musb_writew(epio, MUSB_RXCSR, val);
 			goto finish;
@@ -2081,7 +2081,7 @@ static int musb_cleanup_urb(struct urb *urb, struct musb_qh *qh)
 	int			status = 0;
 	u16			csr;
 
-	musb_ep_select(regs, hw_end);
+	musb_ep_select(ep->musb, regs, hw_end);
 
 	if (is_dma_capable()) {
 		struct dma_channel	*dma;
diff --git a/drivers/usb/musb/musb_regs.h b/drivers/usb/musb/musb_regs.h
index 3321bae..1af0ea9 100644
--- a/drivers/usb/musb/musb_regs.h
+++ b/drivers/usb/musb/musb_regs.h
@@ -285,11 +285,11 @@
 #define MUSB_CONFIGDATA		MUSB_FIFOSIZE	/* Re-used for EP0 */
 
 /* Offsets to endpoint registers in indexed model (using INDEX register) */
-#define MUSB_INDEXED_OFFSET(_epnum, _offset)	\
+#define MUSB_INDEXED_OFFSET(_musb, _epnum, _offset)	\
 	(0x10 + (_offset))
 
 /* Offsets to endpoint registers in flat models */
-#define MUSB_FLAT_OFFSET(_epnum, _offset)	\
+#define MUSB_FLAT_OFFSET(_musb, _epnum, _offset)	\
 	(0x100 + (0x10*(_epnum)) + (_offset))
 
 #include "tusb6010.h"		/* Needed "only" for TUSB_EP0_CONF */
@@ -496,11 +496,11 @@ static inline u8  musb_read_txhubport(void __iomem *mbase, u8 epnum)
 #define MUSB_TXCOUNT		0x28
 
 /* Offsets to endpoint registers in indexed model (using INDEX register) */
-#define MUSB_INDEXED_OFFSET(_epnum, _offset)	\
+#define MUSB_INDEXED_OFFSET(_musb, _epnum, _offset)	\
 	(0x40 + (_offset))
 
 /* Offsets to endpoint registers in flat models */
-#define MUSB_FLAT_OFFSET(_epnum, _offset)	\
+#define MUSB_FLAT_OFFSET(_musb, _epnum, _offset)	\
 	(USB_OFFSET(USB_EP_NI0_TXMAXP) + (0x40 * (_epnum)) + (_offset))
 
 /* Not implemented - HW has separate Tx/Rx FIFO */
diff --git a/drivers/usb/musb/musbhsdma.c b/drivers/usb/musb/musbhsdma.c
index 444b9ee..4d7d83b 100644
--- a/drivers/usb/musb/musbhsdma.c
+++ b/drivers/usb/musb/musbhsdma.c
@@ -205,14 +205,14 @@ static int dma_channel_abort(struct dma_channel *channel)
 {
 	struct musb_dma_channel *musb_channel = channel->private_data;
 	void __iomem *mbase = musb_channel->controller->base;
-
+	struct musb *musb = musb_channel->controller->private_data;
 	u8 bchannel = musb_channel->idx;
 	int offset;
 	u16 csr;
 
 	if (channel->status == MUSB_DMA_STATUS_BUSY) {
 		if (musb_channel->transmit) {
-			offset = MUSB_EP_OFFSET(musb_channel->epnum,
+			offset = MUSB_EP_OFFSET(musb, musb_channel->epnum,
 						MUSB_TXCSR);
 
 			/*
@@ -225,7 +225,7 @@ static int dma_channel_abort(struct dma_channel *channel)
 			csr &= ~MUSB_TXCSR_DMAMODE;
 			musb_writew(mbase, offset, csr);
 		} else {
-			offset = MUSB_EP_OFFSET(musb_channel->epnum,
+			offset = MUSB_EP_OFFSET(musb, musb_channel->epnum,
 						MUSB_RXCSR);
 
 			csr = musb_readw(mbase, offset);
@@ -336,7 +336,7 @@ static irqreturn_t dma_controller_irq(int irq, void *private_data)
 					    (musb_channel->max_packet_sz - 1)))
 				    ) {
 					u8  epnum  = musb_channel->epnum;
-					int offset = MUSB_EP_OFFSET(epnum,
+					int offset = MUSB_EP_OFFSET(musb, epnum,
 								    MUSB_TXCSR);
 					u16 txcsr;
 
@@ -344,7 +344,7 @@ static irqreturn_t dma_controller_irq(int irq, void *private_data)
 					 * The programming guide says that we
 					 * must clear DMAENAB before DMAMODE.
 					 */
-					musb_ep_select(mbase, epnum);
+					musb_ep_select(musb, mbase, epnum);
 					txcsr = musb_readw(mbase, offset);
 					txcsr &= ~(MUSB_TXCSR_DMAENAB
 							| MUSB_TXCSR_AUTOSET);
diff --git a/drivers/usb/musb/tusb6010_omap.c b/drivers/usb/musb/tusb6010_omap.c
index 1cfc5d0..74fa695 100644
--- a/drivers/usb/musb/tusb6010_omap.c
+++ b/drivers/usb/musb/tusb6010_omap.c
@@ -211,7 +211,7 @@ static void tusb_omap_dma_cb(int lch, u16 ch_status, void *data)
 
 		if (chdat->tx) {
 			dev_dbg(musb->controller, "terminating short tx packet\n");
-			musb_ep_select(mbase, chdat->epnum);
+			musb_ep_select(musb, mbase, chdat->epnum);
 			csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
 			csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY
 				| MUSB_TXCSR_P_WZC_BITS;
@@ -386,14 +386,14 @@ static int tusb_omap_dma_program(struct dma_channel *channel, u16 packet_sz,
 	 * Prepare MUSB for DMA transfer
 	 */
 	if (chdat->tx) {
-		musb_ep_select(mbase, chdat->epnum);
+		musb_ep_select(musb, mbase, chdat->epnum);
 		csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
 		csr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB
 			| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
 		csr &= ~MUSB_TXCSR_P_UNDERRUN;
 		musb_writew(hw_ep->regs, MUSB_TXCSR, csr);
 	} else {
-		musb_ep_select(mbase, chdat->epnum);
+		musb_ep_select(musb, mbase, chdat->epnum);
 		csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 		csr |= MUSB_RXCSR_DMAENAB;
 		csr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);
-- 
1.7.5.4

