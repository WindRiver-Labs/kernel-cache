From 3dbad0d3a3131d538d66bd5f43885e41bd58eaee Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Fri, 8 Apr 2011 14:35:05 +0530
Subject: [PATCH 399/609] musb: Workaround for early rx cppi41 dma completion
 in GRNDIS mode

Original commit: b1ae00e1cf4d095592140f631369b60d27d5b087

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Fix for device resets during file transfer from one usb stick to other.
Multiple Resets of msc device while transfering file one usb
stick to other. Root caused at CPPI-41 DMA Level. During transfer
of file from one msc-device1 to msc-device2, there is continuous
scsi-read from device-1 and scsi-write to device-2.
After few Mega Bytes of data are transfered, the scsi-read operation
stops and timeout is occuring at scsi layer hence the scsi-subsystem
resets the device-1.
The CATC capture shows that after sending CBW command to read 240
sectors of data, IN tokens are send by controller to receive few
Kilo bytes, further there were no IN-tokens send by controller to
read the data from device-1.
The analysis shows the corresponding rx endpoint-FIFO is full and
XDMA is not moving the data due CPPI-4.1 Rx DMA channel halted.
What exactly happened was, the scsi submitted request to read 28K data,
one rx-bd is queued to rx-free queue of RX-DMA channel configured in
Generic-RNDIS mode and RNDIS-EPSIZE register is set to 28K value.
For some reason the interrupt has occured with 16K data in rx-bd and
the usb driver gives back this request to application layer.
Since this request is abnormally aborted by DMA, there are no free bd
at input queue and transfer DMA has send IN token to receive further data,
the data received is available in FIFO, FIFO is full and there is no rx-bd
the DMA Stalls. This is reason why there are no IN-token seen on the bus
and the request aborted and continuous resets to device is happening

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Sriramakrishnan A G <srk@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41_dma.c |   33 ++++++++++++++++++++++++++++++---
 1 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 716866d..51efb3c 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -1405,10 +1405,37 @@ static void usb_process_rx_queue(struct cppi41 *cppi, unsigned index)
 
 		if (unlikely(rx_ch->channel.actual_len >= rx_ch->length ||
 			     length < orig_buf_len)) {
-			rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
 
-			/* Rx completion routine callback */
-			musb_dma_completion(cppi->musb, ep_num, 0);
+#ifdef CONFIG_SOC_OMAPTI81XX
+			struct musb_hw_ep *ep;
+			u8 isoc, next_seg = 0;
+
+			/* Workaround for early rx completion of
+			 * cppi41 dma in Generic RNDIS mode for ti81xx
+			 */
+			if (cpu_is_ti81xx() && is_host_enabled(cppi->musb)) {
+				u32 pkt_size = rx_ch->pkt_size;
+				ep = cppi->musb->endpoints + ep_num;
+				isoc = musb_readb(ep->regs, MUSB_RXTYPE);
+				isoc = (isoc >> 4) & 0x1;
+
+				if (!isoc
+				&& (rx_ch->dma_mode == USB_GENERIC_RNDIS_MODE)
+				&& (rx_ch->channel.actual_len < rx_ch->length)
+				&& !(rx_ch->channel.actual_len % pkt_size))
+					next_seg = 1;
+			}
+			if (next_seg) {
+				rx_ch->curr_offset = rx_ch->channel.actual_len;
+				cppi41_next_rx_segment(rx_ch);
+			} else
+#endif
+			{
+				rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+				/* Rx completion routine callback */
+				musb_dma_completion(cppi->musb, ep_num, 0);
+			}
 		} else {
 			if (is_peripheral_active(cppi->musb) &&
 				((rx_ch->length - rx_ch->curr_offset) > 0))
-- 
1.7.5.4

