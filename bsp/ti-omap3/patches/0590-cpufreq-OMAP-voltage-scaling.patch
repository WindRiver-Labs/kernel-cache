From 451f41f4c92f16f48a5df0020f6a5d7838ba9a42 Mon Sep 17 00:00:00 2001
From: Afzal Mohammed <afzal@ti.com>
Date: Tue, 4 Sep 2012 12:45:14 +0800
Subject: [PATCH 590/609] cpufreq: OMAP: voltage scaling

Original commit: ea39a268185b4ca753b38039c09ced34b5977cf2

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

DVFS capability added, voltage scaled as per the
OPP for new frequency. Increase voltage first for
going to higher OPP, and decrease frequency first
for transition to lower OPP.

If regulator is not found, fail cpufreq init.

Signed-off-by: Afzal Mohammed <afzal@ti.com>
---
 drivers/cpufreq/omap-cpufreq.c |  154 +++++++++++++++++++++++----------------
 1 files changed, 91 insertions(+), 63 deletions(-)

diff --git a/drivers/cpufreq/omap-cpufreq.c b/drivers/cpufreq/omap-cpufreq.c
index 4369ba1..0d1d070 100644
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@ -28,6 +28,7 @@
 #include <linux/regulator/consumer.h>
 #include <linux/suspend.h>
 
+#include <asm/system.h>
 #include <asm/smp_plat.h>
 #include <asm/cpu.h>
 
@@ -38,8 +39,11 @@
 
 #include <mach/hardware.h>
 
-/* OPP tolerance in percentage */
-#define	OPP_TOLERANCE	4
+/* Tolerance for MPU voltage is 4%, we have to pass +4% as a
+ * maximum voltage while setting the MPU regulator voltage.
+ * Which is taken from AM33XX datasheet */
+#define MPU_TOLERANCE	4
+#define PER_ROUND_VAL	100
 
 /* Use 275MHz when entering suspend */
 #define SLEEP_FREQ	(275 * 1000)
@@ -87,10 +91,10 @@ static int omap_target(struct cpufreq_policy *policy,
 		       unsigned int relation)
 {
 	unsigned int i;
-	int r, ret = 0;
+	int ret = 0;
 	struct cpufreq_freqs freqs;
 	struct opp *opp;
-	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
+	int volt_old = 0, volt_new = 0;
 
 	if (is_suspended)
 		return -EBUSY;
@@ -121,56 +125,48 @@ static int omap_target(struct cpufreq_policy *policy,
 	if (freqs.old == freqs.new && policy->cur == freqs.new)
 		return ret;
 
-	/* notifiers */
-	for_each_cpu(i, policy->cpus) {
-		freqs.cpu = i;
-		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+	opp = opp_find_freq_exact(mpu_dev, freqs.new * 1000, true);
+	if (IS_ERR(opp)) {
+		dev_err(mpu_dev, "%s: cpu%d: no opp match for freq %d\n",
+			__func__, policy->cpu, target_freq);
+		return -EINVAL;
 	}
 
-	freq = freqs.new * 1000;
-
-	if (mpu_reg) {
-		opp = opp_find_freq_ceil(mpu_dev, &freq);
-		if (IS_ERR(opp)) {
-			dev_err(mpu_dev, "%s: unable to find MPU OPP for %d\n",
-				__func__, freqs.new);
-			return -EINVAL;
-		}
-		volt = opp_get_voltage(opp);
-		tol = volt * OPP_TOLERANCE / 100;
-		volt_old = regulator_get_voltage(mpu_reg);
+	volt_new = opp_get_voltage(opp);
+	if (!volt_new) {
+		dev_err(mpu_dev, "%s: cpu%d: no opp voltage for freq %d\n",
+			__func__, policy->cpu, target_freq);
+		return -EINVAL;
 	}
 
-	dev_dbg(mpu_dev, "cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\n", 
-		freqs.old / 1000, volt_old ? volt_old / 1000 : -1,
-		freqs.new / 1000, volt ? volt / 1000 : -1);
+	volt_old = regulator_get_voltage(mpu_reg);
 
-	/* scaling up?  scale voltage before frequency */
-	if (mpu_reg && (freqs.new > freqs.old)) {
-		r = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);
-		if (r < 0) {
-			dev_warn(mpu_dev, "%s: unable to scale voltage up.\n",
-				 __func__);
-			freqs.new = freqs.old;
-			goto done;
+#ifdef CONFIG_CPU_FREQ_DEBUG
+	pr_info("cpufreq-omap: frequency transition: %u --> %u\n",
+			freqs.old, freqs.new);
+	pr_info("cpufreq-omap: voltage transition: %d --> %d\n",
+			volt_old, volt_new);
+#endif
+
+	if (freqs.new > freqs.old) {
+		ret = regulator_set_voltage(mpu_reg, volt_new,
+			volt_new + (volt_new * MPU_TOLERANCE) / PER_ROUND_VAL);
+		if (ret) {
+			dev_err(mpu_dev, "%s: unable to set voltage to %d uV (for %u MHz)\n",
+				__func__, volt_new, freqs.new/1000);
+			return ret;
 		}
 	}
 
-	ret = clk_set_rate(mpu_clk, freqs.new * 1000);
-
-	/* scaling down?  scale voltage after frequency */
-	if (mpu_reg && (freqs.new < freqs.old)) {
-		r = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);
-		if (r < 0) {
-			dev_warn(mpu_dev, "%s: unable to scale voltage down.\n",
-				 __func__);
-			ret = clk_set_rate(mpu_clk, freqs.old * 1000);
-			freqs.new = freqs.old;
-			goto done;
-		}
+	/* notifiers */
+	for_each_cpu(i, policy->cpus) {
+		freqs.cpu = i;
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 	}
 
+	ret = clk_set_rate(mpu_clk, freqs.new * 1000);
 	freqs.new = omap_getspeed(policy->cpu);
+
 #ifdef CONFIG_SMP
 	/*
 	 * Note that loops_per_jiffy is not updated on SMP systems in
@@ -197,13 +193,44 @@ static int omap_target(struct cpufreq_policy *policy,
 					freqs.new);
 #endif
 
-done:
 	/* notifiers */
 	for_each_cpu(i, policy->cpus) {
 		freqs.cpu = i;
 		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
 	}
 
+	if (freqs.new < freqs.old) {
+		ret = regulator_set_voltage(mpu_reg, volt_new,
+			volt_new + (volt_new * MPU_TOLERANCE) / PER_ROUND_VAL);
+		if (ret) {
+			unsigned int temp;
+
+			dev_err(mpu_dev, "%s: unable to set voltage to %d uV (for %u MHz)\n",
+				__func__, volt_new, freqs.new/1000);
+
+			if (clk_set_rate(mpu_clk, freqs.old * 1000)) {
+				dev_err(mpu_dev,
+					"%s: failed restoring clock rate to %u MHz, clock rate is %u MHz",
+					__func__,
+					freqs.old/1000, freqs.new/1000);
+				return ret;
+			}
+
+			temp = freqs.new;
+			freqs.new = freqs.old;
+			freqs.old = temp;
+
+			for_each_cpu(i, policy->cpus) {
+				freqs.cpu = i;
+				cpufreq_notify_transition(&freqs,
+					CPUFREQ_PRECHANGE);
+				cpufreq_notify_transition(&freqs,
+					CPUFREQ_POSTCHANGE);
+			}
+			return ret;
+		}
+	}
+
 	return ret;
 }
 
@@ -258,11 +285,27 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	if (IS_ERR(mpu_clk))
 		return PTR_ERR(mpu_clk);
 
-	if (policy->cpu >= NR_CPUS) {
+	mpu_reg = regulator_get(NULL, "vdd_mpu");
+	if (IS_ERR(mpu_reg)) {
 		result = -EINVAL;
 		goto fail_ck;
 	}
 
+	/* success of regulator_get doesn't gurantee presence of driver for
+	   physical regulator and presence of physical regulator (this
+	   situation arises if dummy regulator is enabled),so check voltage
+	   to verify that physical regulator and it's driver is present
+	 */
+	if (regulator_get_voltage(mpu_reg) < 0) {
+		result = -EINVAL;
+		goto fail_reg;
+	}
+
+	if (policy->cpu >= NR_CPUS) {
+		result = -EINVAL;
+		goto fail_reg;
+	}
+
 	policy->cur = policy->min = policy->max = omap_getspeed(policy->cpu);
 
 	if (atomic_inc_return(&freq_table_users) == 1)
@@ -271,7 +314,7 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 	if (result) {
 		dev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",
 				__func__, policy->cpu, result);
-		goto fail_ck;
+		goto fail_reg;
 	}
 
 	result = cpufreq_frequency_table_cpuinfo(policy, freq_table);
@@ -305,6 +348,8 @@ static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
 
 fail_table:
 	freq_table_free();
+fail_reg:
+	regulator_put(mpu_reg);
 fail_ck:
 	clk_put(mpu_clk);
 	return result;
@@ -353,23 +398,6 @@ static int __init omap_cpufreq_init(void)
 		return -EINVAL;
 	}
 
-	mpu_reg = regulator_get(mpu_dev, "vcc");
-	if (IS_ERR(mpu_reg)) {
-		pr_warning("%s: unable to get MPU regulator\n", __func__);
-		mpu_reg = NULL;
-	} else {
-		/* 
-		 * Ensure physical regulator is present.
-		 * (e.g. could be dummy regulator.)
-		 */
-		if (regulator_get_voltage(mpu_reg) < 0) {
-			pr_warn("%s: physical regulator not present for MPU\n",
-				__func__);
-			regulator_put(mpu_reg);
-			mpu_reg = NULL;
-		}
-	}
-
 	return cpufreq_register_driver(&omap_driver);
 }
 
-- 
1.7.5.4

