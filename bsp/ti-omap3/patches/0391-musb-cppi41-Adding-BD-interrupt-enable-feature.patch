From 05a9f0c0e59f2419cb7a1abc172bdc785cff5e40 Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Thu, 9 Dec 2010 11:42:12 +0530
Subject: [PATCH 391/609] musb: cppi41: Adding BD interrupt enable feature

Original commit: 66e6d3c78ab94f66ad1c823e3a5a8ec66daf85d8

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Adding BD interrupt enable feature available in CPPI41 DMA on TI81xx
platform. This feature is not supported in AM35x/DA8x.

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/am35x.c      |    1 +
 drivers/usb/musb/cppi41.h     |    1 +
 drivers/usb/musb/cppi41_dma.c |   18 ++++++++++++++++--
 drivers/usb/musb/cppi41_dma.h |    1 +
 4 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/musb/am35x.c b/drivers/usb/musb/am35x.c
index b39e411..332df8b 100644
--- a/drivers/usb/musb/am35x.c
+++ b/drivers/usb/musb/am35x.c
@@ -212,6 +212,7 @@ int __devinit cppi41_init(struct musb *musb)
 	cppi_info->num_rx_comp_q = 15;
 	cppi_info->tx_comp_q = tx_comp_q;
 	cppi_info->rx_comp_q = rx_comp_q;
+	cppi_info->bd_intr_ctrl = 0; /* am35x dont support bd interrupt */
 
 	blknum = cppi_info->dma_block;
 
diff --git a/drivers/usb/musb/cppi41.h b/drivers/usb/musb/cppi41.h
index 1e539b2..c668077 100644
--- a/drivers/usb/musb/cppi41.h
+++ b/drivers/usb/musb/cppi41.h
@@ -264,6 +264,7 @@ struct cppi41_host_buf_desc {
 					CPPI41_SRC_TAG_SUB_CH_NUM_SHIFT)
 #define CPPI41_DEST_TAG_SHIFT		0
 #define CPPI41_DEST_TAG_MASK		(0xffff << CPPI41_DEST_TAG_SHIFT)
+#define CPPI41_PKT_INTR_FLAG		(1 << 31)
 
 /*
  * CPPI 4.1 Teardown Descriptor
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 6d3ae73..8ccc6ae 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -121,6 +121,7 @@ struct cppi41 {
 					/* object */
 	u32 pkt_info;			/* Tx PD Packet Information field */
 	struct usb_cppi41_info *cppi_info; /* cppi channel information */
+	u8 en_bd_intr;			/* enable bd interrupt */
 };
 
 struct usb_cppi41_info usb_cppi41_info[2];
@@ -552,6 +553,7 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 	struct usb_cppi41_info *cppi_info = cppi->cppi_info;
 	u16 q_mgr = cppi_info->q_mgr;
 	u16 tx_comp_q = cppi_info->tx_comp_q[tx_ch->ch_num];
+	u8 en_bd_intr = cppi->en_bd_intr;
 
 	/*
 	 * Tx can use the generic RNDIS mode where we can probably fit this
@@ -613,6 +615,9 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 		if (pkt_size == 0)
 			tx_ch->zlp_queued = 1;
 
+		if (en_bd_intr)
+			hw_desc->orig_buf_len |= CPPI41_PKT_INTR_FLAG;
+
 		dev_dbg(musb->controller, "TX PD %p: buf %08x, len %08x, pkt info %08x\n", curr_pd,
 		    hw_desc->buf_ptr, hw_desc->buf_len, hw_desc->pkt_info);
 
@@ -726,6 +731,7 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 	u32 max_rx_transfer_size = 64 * 1024;
 	u32 i, n_bd , pkt_len;
 	struct usb_gadget_driver *gadget_driver;
+	u8 en_bd_intr = cppi->en_bd_intr;
 
 	if (is_peripheral_active(cppi->musb)) {
 		/* TODO: temporary fix for CDC/RNDIS which needs to be in
@@ -796,6 +802,8 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 		curr_pd->eop = (length -= pkt_len) ? 0 : 1;
 		rx_ch->curr_offset += pkt_len;
 
+		if (en_bd_intr)
+			hw_desc->orig_buf_len |= CPPI41_PKT_INTR_FLAG;
 		/*
 		 * Push the free Rx packet descriptor
 		 * to the free descriptor/buffer queue.
@@ -1192,6 +1200,7 @@ cppi41_dma_controller_create(struct musb  *musb, void __iomem *mregs)
 	cppi->controller.channel_program = cppi41_channel_program;
 	cppi->controller.channel_abort = cppi41_channel_abort;
 	cppi->cppi_info = (struct usb_cppi41_info *)&usb_cppi41_info[musb->id];;
+	cppi->en_bd_intr = cppi->cppi_info->bd_intr_ctrl;
 
 	return &cppi->controller;
 }
@@ -1280,6 +1289,7 @@ static void usb_process_rx_queue(struct cppi41 *cppi, unsigned index)
 	unsigned long pd_addr;
 	struct usb_cppi41_info *cppi_info = cppi->cppi_info;
 	struct musb *musb = cppi->musb;
+	u8 en_bd_intr = cppi->en_bd_intr;
 
 	if (cppi41_queue_init(&rx_queue_obj, cppi_info->q_mgr,
 			      cppi_info->rx_comp_q[index])) {
@@ -1291,7 +1301,7 @@ static void usb_process_rx_queue(struct cppi41 *cppi, unsigned index)
 		struct usb_pkt_desc *curr_pd;
 		struct cppi41_channel *rx_ch;
 		u8 ch_num, ep_num;
-		u32 length;
+		u32 length, orig_buf_len;
 
 		curr_pd = usb_get_pd_ptr(cppi, pd_addr);
 		if (curr_pd == NULL) {
@@ -1320,8 +1330,12 @@ static void usb_process_rx_queue(struct cppi41 *cppi, unsigned index)
 		 */
 		usb_put_free_pd(cppi, curr_pd);
 
+		orig_buf_len = curr_pd->hw_desc.orig_buf_len;
+		if (en_bd_intr)
+			orig_buf_len &= ~CPPI41_PKT_INTR_FLAG;
+
 		if (unlikely(rx_ch->channel.actual_len >= rx_ch->length ||
-			     length < curr_pd->hw_desc.orig_buf_len)) {
+			     length < orig_buf_len)) {
 			rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
 
 			/* Rx completion routine callback */
diff --git a/drivers/usb/musb/cppi41_dma.h b/drivers/usb/musb/cppi41_dma.h
index c9e833f..fd746c3 100644
--- a/drivers/usb/musb/cppi41_dma.h
+++ b/drivers/usb/musb/cppi41_dma.h
@@ -39,6 +39,7 @@ struct usb_cppi41_info {
 	u8 num_rx_comp_q;
 	u16 *tx_comp_q;
 	u16 *rx_comp_q;
+	u8 bd_intr_ctrl;
 };
 
 extern struct usb_cppi41_info usb_cppi41_info[];
-- 
1.7.5.4

