From 0593416968e85d94e8ab94880a2ec0184e71732b Mon Sep 17 00:00:00 2001
From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date: Fri, 18 May 2012 10:52:46 +0530
Subject: [PATCH 533/609] ARM: edma: optimize the EDMA ISR

Original commit: 2b8b652d0aa28dda52e42d0a940b265e569355b2

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

This was taken from the davinci mainline,
[Commit bcd59b0f0c14b0584c1213ee3b53d5f84517c419]
Ported to AM335x. Observed below write performance,

SPI Write performance values:

Without this patch: 0.2661Mbps
With this patch: 0.2692Mbps

The original commit message is as below,
The ISR does quiete a lot of hw access which could be avoided. First it
checks for a pending interrupt by reading alteast one register. Then it
checks for the "activated" slots by reading another register. This is
more or a less a must. Now, once it found an active slot it does the
same two reads again. After that it "knows" that there must be a pending
transfer however it cross checks with the other register.
There are 32 bit in an interger which are polled instead of considering
only the set bits and ignoring those which are zero. This performs atleast
32 reads which could be avoided. In case of a first match it does
another read. This patch reorganizes the access by re-using the register
which have been read and then uses ffs() to find the matching slot instead
looping over it. By doing this we get rid of the last (32 + 2 + hits) reads.

It is possible however that by really busy bank0 we never get to handle bank1.
If this is a problem, we could try to handle bank1 after we are done with bank0
to check if there are any outstanding transfers.

To put some numbers on this, this is from spi transfer via spidev. The
first column is the number of total transfers, the time stamp is taken
before and after the ioctl():

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Signed-off-by: Sekhar Nori <nsekhar@ti.com>
Tested-by: Shankarmurthy, Akshay <akshay.s@ti.com>
---
 arch/arm/common/edma.c |   71 ++++++++++++++++++++++++-----------------------
 1 files changed, 36 insertions(+), 35 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index fe00c92..745b799 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -323,9 +323,10 @@ static int irq2ctlr(int irq)
  *****************************************************************************/
 static irqreturn_t dma_irq_handler(int irq, void *data)
 {
-	int i;
 	int ctlr;
-	unsigned int cnt = 0;
+	u32 sh_ier;
+	u32 sh_ipr;
+	u32 bank;
 
 	ctlr = irq2ctlr(irq);
 	if (ctlr < 0)
@@ -333,41 +334,41 @@ static irqreturn_t dma_irq_handler(int irq, void *data)
 
 	dev_dbg(data, "dma_irq_handler\n");
 
-	if ((edma_shadow0_read_array(ctlr, SH_IPR, 0) == 0) &&
-	    (edma_shadow0_read_array(ctlr, SH_IPR, 1) == 0))
-		return IRQ_NONE;
+	sh_ipr = edma_shadow0_read_array(ctlr, SH_IPR, 0);
+	if (!sh_ipr) {
+		sh_ipr = edma_shadow0_read_array(ctlr, SH_IPR, 1);
+		if (!sh_ipr)
+			return IRQ_NONE;
+		sh_ier = edma_shadow0_read_array(ctlr, SH_IER, 1);
+		bank = 1;
+	} else {
+		sh_ier = edma_shadow0_read_array(ctlr, SH_IER, 0);
+		bank = 0;
+	}
+
+	do {
+		u32 slot;
+		u32 channel;
+
+		dev_dbg(data, "IPR%d %08x\n", bank, sh_ipr);
+
+		slot = __ffs(sh_ipr);
+		sh_ipr &= ~(BIT(slot));
+
+		if (sh_ier & BIT(slot)) {
+			channel = (bank << 5) | slot;
+			/* Clear the corresponding IPR bits */
+			edma_shadow0_write_array(ctlr, SH_ICR, bank,
+					BIT(slot));
+			if (edma_cc[ctlr]->intr_data[channel].callback)
+				edma_cc[ctlr]->intr_data[channel].callback(
+					channel, DMA_COMPLETE,
+					edma_cc[ctlr]->intr_data[channel].data);
+
 
-	while (1) {
-		int j;
-		if (edma_shadow0_read_array(ctlr, SH_IPR, 0) &
-				edma_shadow0_read_array(ctlr, SH_IER, 0))
-			j = 0;
-		else if (edma_shadow0_read_array(ctlr, SH_IPR, 1) &
-				edma_shadow0_read_array(ctlr, SH_IER, 1))
-			j = 1;
-		else
-			break;
-		dev_dbg(data, "IPR%d %08x\n", j,
-				edma_shadow0_read_array(ctlr, SH_IPR, j));
-		for (i = 0; i < 32; i++) {
-			int k = (j << 5) + i;
-			if ((edma_shadow0_read_array(ctlr, SH_IPR, j) & BIT(i))
-					&& (edma_shadow0_read_array(ctlr,
-							SH_IER, j) & BIT(i))) {
-				/* Clear the corresponding IPR bits */
-				edma_shadow0_write_array(ctlr, SH_ICR, j,
-							BIT(i));
-				if (edma_cc[ctlr]->intr_data[k].callback)
-					edma_cc[ctlr]->intr_data[k].callback(
-						k, DMA_COMPLETE,
-						edma_cc[ctlr]->intr_data[k].
-						data);
-			}
 		}
-		cnt++;
-		if (cnt > 10)
-			break;
-	}
+	} while (sh_ipr);
+
 	edma_shadow0_write(ctlr, SH_IEVAL, 1);
 	return IRQ_HANDLED;
 }
-- 
1.7.5.4

