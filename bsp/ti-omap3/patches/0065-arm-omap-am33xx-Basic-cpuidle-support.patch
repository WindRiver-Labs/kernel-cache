From 8818869347359a6a510781bcaa1d21d7c9b58c5e Mon Sep 17 00:00:00 2001
From: Vaibhav Bedia <vaibhav.bedia@ti.com>
Date: Wed, 30 Nov 2011 21:31:47 +0530
Subject: [PATCH 065/609] arm:omap:am33xx: Basic cpuidle support

Original commit: 7a758f13828d9de75e59ad3debf9fad3aca510e0

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Add basic cpuidle support for AM33XX family of SoC.
Right now only two idle states (WFI and WFI+SR) are
supported. The latency/residency numbers chosen will
be fine-tuned based on power measurements on actual
hardware.

Signed-off-by: Vaibhav Bedia <vaibhav.bedia@ti.com>
---
 arch/arm/mach-davinci/cpuidle.c          |    1 -
 arch/arm/mach-omap2/Makefile             |    1 +
 arch/arm/mach-omap2/cpuidle33xx.c        |  179 ++++++++++++++++++++++++++++++
 arch/arm/mach-omap2/cpuidle33xx.h        |   24 ++++
 arch/arm/plat-omap/include/plat/am33xx.h |    2 +
 arch/arm/plat-omap/include/plat/emif.h   |   41 +++++++
 6 files changed, 247 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-omap2/cpuidle33xx.c
 create mode 100644 arch/arm/mach-omap2/cpuidle33xx.h
 create mode 100644 arch/arm/plat-omap/include/plat/emif.h

diff --git a/arch/arm/mach-davinci/cpuidle.c b/arch/arm/mach-davinci/cpuidle.c
index 9107691..92f7e57 100644
--- a/arch/arm/mach-davinci/cpuidle.c
+++ b/arch/arm/mach-davinci/cpuidle.c
@@ -159,4 +159,3 @@ static int __init davinci_cpuidle_init(void)
 						davinci_cpuidle_probe);
 }
 device_initcall(davinci_cpuidle_init);
-
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 536f5d4..e00967d 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -69,6 +69,7 @@ obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o \
 					   cpuidle34xx.o
 obj-$(CONFIG_ARCH_OMAP4)		+= pm44xx.o omap-mpuss-lowpower.o \
 					   cpuidle44xx.o
+obj-$(CONFIG_SOC_OMAPAM33XX)		+= cpuidle33xx.o
 obj-$(CONFIG_PM_DEBUG)			+= pm-debug.o
 obj-$(CONFIG_OMAP_SMARTREFLEX)          += sr_device.o smartreflex.o
 obj-$(CONFIG_OMAP_SMARTREFLEX_CLASS3)	+= smartreflex-class3.o
diff --git a/arch/arm/mach-omap2/cpuidle33xx.c b/arch/arm/mach-omap2/cpuidle33xx.c
new file mode 100644
index 0000000..7e14de4
--- /dev/null
+++ b/arch/arm/mach-omap2/cpuidle33xx.c
@@ -0,0 +1,179 @@
+/*
+ * CPU idle for AM33XX SoCs
+ *
+ * Copyright (C) 2011 Texas Instruments Incorporated. http://www.ti.com/
+ *
+ * Derived from Davinci CPU idle code
+ * (arch/arm/mach-davinci/cpuidle.c)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/cpuidle.h>
+#include <linux/sched.h>
+#include <asm/proc-fns.h>
+
+#include <plat/emif.h>
+
+#include "cpuidle33xx.h"
+
+#define AM33XX_CPUIDLE_MAX_STATES	2
+
+struct am33xx_ops {
+	void (*enter) (u32 flags);
+	void (*exit) (u32 flags);
+	u32 flags;
+};
+
+/* fields in am33xx_ops.flags */
+#define AM33XX_CPUIDLE_FLAGS_DDR2_PWDN	BIT(0)
+
+static struct cpuidle_driver am33xx_idle_driver = {
+	.name	= "cpuidle-am33xx",
+	.owner	= THIS_MODULE,
+};
+
+static DEFINE_PER_CPU(struct cpuidle_device, am33xx_cpuidle_device);
+static void __iomem *emif_base;
+
+static void am33xx_save_ddr_power(int enter, bool pdown)
+{
+	u32 val;
+
+	val = __raw_readl(emif_base + EMIF4_0_SDRAM_MGMT_CTRL);
+
+	/* TODO: Choose the mode based on memory type */
+	if (enter)
+		val = SELF_REFRESH_ENABLE(64);
+	else
+		val = SELF_REFRESH_DISABLE;
+
+	__raw_writel(val, emif_base + EMIF4_0_SDRAM_MGMT_CTRL);
+}
+
+static void am33xx_c2state_enter(u32 flags)
+{
+	am33xx_save_ddr_power(1, !!(flags & AM33XX_CPUIDLE_FLAGS_DDR2_PWDN));
+}
+
+static void am33xx_c2state_exit(u32 flags)
+{
+	am33xx_save_ddr_power(0, !!(flags & AM33XX_CPUIDLE_FLAGS_DDR2_PWDN));
+}
+
+static struct am33xx_ops am33xx_states[AM33XX_CPUIDLE_MAX_STATES] = {
+	[1] = {
+		.enter	= am33xx_c2state_enter,
+		.exit	= am33xx_c2state_exit,
+	},
+};
+
+/* Actual code that puts the SoC in different idle states */
+static int am33xx_enter_idle(struct cpuidle_device *dev,
+				struct cpuidle_driver *drv, int index)
+{
+	struct cpuidle_state_usage *state_usage = &dev->states_usage[index];
+	struct am33xx_ops *ops = cpuidle_get_statedata(state_usage);
+	struct timeval before, after;
+	int idle_time;
+
+	local_irq_disable();
+	do_gettimeofday(&before);
+
+	if (ops && ops->enter)
+		ops->enter(ops->flags);
+
+	/* Wait for interrupt state */
+	cpu_do_idle();
+	if (ops && ops->exit)
+		ops->exit(ops->flags);
+
+	do_gettimeofday(&after);
+	local_irq_enable();
+	idle_time = (after.tv_sec - before.tv_sec) * USEC_PER_SEC +
+			(after.tv_usec - before.tv_usec);
+
+	dev->last_residency = idle_time;
+
+	return index;
+}
+
+static int __init am33xx_cpuidle_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct cpuidle_device *device;
+	struct cpuidle_driver *driver = &am33xx_idle_driver;
+	struct am33xx_cpuidle_config *pdata = pdev->dev.platform_data;
+
+	device = &per_cpu(am33xx_cpuidle_device, smp_processor_id());
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "cannot get platform data\n");
+		return -ENOENT;
+	}
+
+	emif_base = pdata->emif_base;
+
+	/* Wait for interrupt state */
+	driver->states[0].enter = am33xx_enter_idle;
+	driver->states[0].exit_latency = 1;
+	driver->states[0].target_residency = 10000;
+	driver->states[0].flags = CPUIDLE_FLAG_TIME_VALID;
+	strcpy(driver->states[0].name, "WFI");
+	strcpy(driver->states[0].desc, "Wait for interrupt");
+
+	/* Wait for interrupt and DDR self refresh state */
+	driver->states[1].enter = am33xx_enter_idle;
+	driver->states[1].exit_latency = 100;
+	driver->states[1].target_residency = 10000;
+	driver->states[1].flags = CPUIDLE_FLAG_TIME_VALID;
+	strcpy(driver->states[1].name, "DDR SR");
+	strcpy(driver->states[1].desc, "WFI and DDR Self Refresh");
+	if (pdata->ddr2_pdown)
+		am33xx_states[1].flags |= AM33XX_CPUIDLE_FLAGS_DDR2_PWDN;
+	cpuidle_set_statedata(&device->states_usage[1], &am33xx_states[1]);
+
+	device->state_count = AM33XX_CPUIDLE_MAX_STATES;
+	driver->state_count = AM33XX_CPUIDLE_MAX_STATES;
+
+	ret = cpuidle_register_driver(&am33xx_idle_driver);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register driver\n");
+		return ret;
+	}
+
+	ret = cpuidle_register_device(device);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register device\n");
+		cpuidle_unregister_driver(&am33xx_idle_driver);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct platform_driver am33xx_cpuidle_driver = {
+	.driver = {
+		.name	= "cpuidle-am33xx",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init am33xx_cpuidle_init(void)
+{
+	return platform_driver_probe(&am33xx_cpuidle_driver,
+						am33xx_cpuidle_probe);
+}
+device_initcall(am33xx_cpuidle_init);
diff --git a/arch/arm/mach-omap2/cpuidle33xx.h b/arch/arm/mach-omap2/cpuidle33xx.h
new file mode 100644
index 0000000..c092fba
--- /dev/null
+++ b/arch/arm/mach-omap2/cpuidle33xx.h
@@ -0,0 +1,24 @@
+/*
+ * TI AM33XX cpuidle platform support
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _AM33XX_CPUIDLE_H
+#define _AM33XX_CPUIDLE_H
+
+struct am33xx_cpuidle_config {
+	u32 ddr2_pdown;
+	void __iomem *emif_base;
+};
+
+#endif
diff --git a/arch/arm/plat-omap/include/plat/am33xx.h b/arch/arm/plat-omap/include/plat/am33xx.h
index 2126965..d05a52f 100644
--- a/arch/arm/plat-omap/include/plat/am33xx.h
+++ b/arch/arm/plat-omap/include/plat/am33xx.h
@@ -22,6 +22,8 @@
 #define AM33XX_CTRL_BASE	AM33XX_SCM_BASE
 #define AM33XX_PRCM_BASE	0x44E00000
 
+#define AM33XX_EMIF0_BASE	0x4C000000
+
 #define AM33XX_GPIO0_BASE	0x44E07000
 #define AM33XX_GPIO1_BASE	0x4804C000
 #define AM33XX_GPIO2_BASE	0x481AC000
diff --git a/arch/arm/plat-omap/include/plat/emif.h b/arch/arm/plat-omap/include/plat/emif.h
new file mode 100644
index 0000000..314c126
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/emif.h
@@ -0,0 +1,41 @@
+/*
+ * EMIF register definitions for TI81xx and AM33xx
+ *
+ * Copyright (C) 2011 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __EMIF_H
+#define __EMIF_H
+
+#define EMIF_MOD_ID_REV			(0x0)
+#define EMIF4_0_SDRAM_STATUS            (0x04)
+#define EMIF4_0_SDRAM_CONFIG            (0x08)
+#define EMIF4_0_SDRAM_CONFIG2           (0x0C)
+#define EMIF4_0_SDRAM_REF_CTRL          (0x10)
+#define EMIF4_0_SDRAM_REF_CTRL_SHADOW   (0x14)
+#define EMIF4_0_SDRAM_TIM_1             (0x18)
+#define EMIF4_0_SDRAM_TIM_1_SHADOW      (0x1C)
+#define EMIF4_0_SDRAM_TIM_2             (0x20)
+#define EMIF4_0_SDRAM_TIM_2_SHADOW      (0x24)
+#define EMIF4_0_SDRAM_TIM_3             (0x28)
+#define EMIF4_0_SDRAM_TIM_3_SHADOW      (0x2C)
+#define EMIF4_0_SDRAM_MGMT_CTRL         (0x38)
+#define EMIF4_0_SDRAM_MGMT_CTRL_SHD     (0x3C)
+#define EMIF4_0_DDR_PHY_CTRL_1          (0xE4)
+#define EMIF4_0_DDR_PHY_CTRL_1_SHADOW   (0xE8)
+#define EMIF4_0_DDR_PHY_CTRL_2          (0xEC)
+#define EMIF4_0_IODFT_TLGC              (0x60)
+
+#define SELF_REFRESH_ENABLE(m)		(0x2 << 8 | (m << 4))
+#define SELF_REFRESH_DISABLE		(0x0 << 8)
+
+#endif /* __EMIF_H */
-- 
1.7.5.4

