From 306cb6f4fa84051da18cd36d8a55755ed99edebb Mon Sep 17 00:00:00 2001
From: Sekhar Nori <nsekhar@ti.com>
Date: Tue, 18 Sep 2012 09:35:57 +0800
Subject: [PATCH 523/609] arm: edma: use a more intuitive name for edma_info

Original commit: 393f03ae2b5f8b8899d34a2ebe999308534bbb04

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

edma_info structure inside the edma driver represents
a single instance of edma channel controller. Call it
edma_cc instead. This also avoids readers confusing
it with an instance of edma_soc_info structre which
carries the platform data for a single channel controller
instance.

Signed-off-by: Sekhar Nori <nsekhar@ti.com>
Signed-off-by: Kevin Hilman <khilman@deeprootsystems.com>
Signed-off-by: Hebbar, Gururaja <gururaja.hebbar@ti.com>
---
 arch/arm/common/edma.c                  |  172 +++++++++++++++----------------
 arch/arm/mach-omap2/include/mach/edma.h |    2 +-
 2 files changed, 85 insertions(+), 89 deletions(-)

diff --git a/arch/arm/common/edma.c b/arch/arm/common/edma.c
index 26ca9ba..1a3247d 100644
--- a/arch/arm/common/edma.c
+++ b/arch/arm/common/edma.c
@@ -218,7 +218,7 @@ static inline void clear_bits(int offset, int len, unsigned long *p)
 
 /*****************************************************************************/
 
-struct edma *edma_info[EDMA_MAX_CC];
+struct edma *edma_cc[EDMA_MAX_CC];
 static int arch_num_cc;
 static struct clk *tpcc_ick, *tptc0_ick, *tptc1_ick, *tptc2_ick;
 
@@ -237,7 +237,7 @@ static void map_dmach_queue(unsigned ctlr, unsigned ch_no,
 
 	/* default to low priority queue */
 	if (queue_no == EVENTQ_DEFAULT)
-		queue_no = edma_info[ctlr]->default_queue;
+		queue_no = edma_cc[ctlr]->default_queue;
 
 	queue_no &= 7;
 	edma_modify_array(ctlr, EDMA_DMAQNUM, (ch_no >> 3),
@@ -291,8 +291,8 @@ setup_dma_interrupt(unsigned lch,
 				(1 << (lch & 0x1f)));
 	}
 
-	edma_info[ctlr]->intr_data[lch].callback = callback;
-	edma_info[ctlr]->intr_data[lch].data = data;
+	edma_cc[ctlr]->intr_data[lch].callback = callback;
+	edma_cc[ctlr]->intr_data[lch].data = data;
 
 	if (callback) {
 		edma_shadow0_write_array(ctlr, SH_ICR, lch >> 5,
@@ -304,11 +304,10 @@ setup_dma_interrupt(unsigned lch,
 
 static int irq2ctlr(int irq)
 {
-	if (irq >= edma_info[0]->irq_res_start &&
-		irq <= edma_info[0]->irq_res_end)
+	if (irq >= edma_cc[0]->irq_res_start && irq <= edma_cc[0]->irq_res_end)
 		return 0;
-	else if (irq >= edma_info[1]->irq_res_start &&
-		irq <= edma_info[1]->irq_res_end)
+	else if (irq >= edma_cc[1]->irq_res_start &&
+		irq <= edma_cc[1]->irq_res_end)
 		return 1;
 
 	return -1;
@@ -350,10 +349,10 @@ static irqreturn_t dma_irq_handler(int irq, void *data)
 				/* Clear the corresponding IPR bits */
 				edma_shadow0_write_array(ctlr, SH_ICR, j,
 							(1 << i));
-				if (edma_info[ctlr]->intr_data[k].callback) {
-					edma_info[ctlr]->intr_data[k].callback(
+				if (edma_cc[ctlr]->intr_data[k].callback) {
+					edma_cc[ctlr]->intr_data[k].callback(
 						k, DMA_COMPLETE,
-						edma_info[ctlr]->intr_data[k].
+						edma_cc[ctlr]->intr_data[k].
 						data);
 				}
 			}
@@ -406,12 +405,12 @@ static irqreturn_t dma_ccerr_handler(int irq, void *data)
 					/* Clear any SER */
 					edma_shadow0_write_array(ctlr, SH_SECR,
 								j, (1 << i));
-					if (edma_info[ctlr]->intr_data[k].
+					if (edma_cc[ctlr]->intr_data[k].
 								callback) {
-						edma_info[ctlr]->intr_data[k].
+						edma_cc[ctlr]->intr_data[k].
 						callback(k,
 						DMA_CC_ERROR,
-						edma_info[ctlr]->intr_data
+						edma_cc[ctlr]->intr_data
 						[k].data);
 					}
 				}
@@ -469,9 +468,9 @@ static int reserve_contiguous_slots(int ctlr, unsigned int id,
 	int stop_slot = start_slot;
 	DECLARE_BITMAP(tmp_inuse, EDMA_MAX_PARAMENTRY);
 
-	for (i = start_slot; i < edma_info[ctlr]->num_slots; ++i) {
+	for (i = start_slot; i < edma_cc[ctlr]->num_slots; ++i) {
 		j = EDMA_CHAN_SLOT(i);
-		if (!test_and_set_bit(j, edma_info[ctlr]->edma_inuse)) {
+		if (!test_and_set_bit(j, edma_cc[ctlr]->edma_inuse)) {
 			/* Record our current beginning slot */
 			if (count == num_slots)
 				stop_slot = i;
@@ -498,12 +497,12 @@ static int reserve_contiguous_slots(int ctlr, unsigned int id,
 	 * of contiguous parameter RAM slots but do not find the exact number
 	 * requested as we may reach the total number of parameter RAM slots
 	 */
-	if (i == edma_info[ctlr]->num_slots)
+	if (i == edma_cc[ctlr]->num_slots)
 		stop_slot = i;
 
 	for (j = start_slot; j < stop_slot; j++)
 		if (test_bit(j, tmp_inuse))
-			clear_bit(j, edma_info[ctlr]->edma_inuse);
+			clear_bit(j, edma_cc[ctlr]->edma_inuse);
 
 	if (count)
 		return -EBUSY;
@@ -529,7 +528,7 @@ static int prepare_unused_channel_list(struct device *dev, void *data)
 							EDMA_MAX_DMACH))
 				clear_bit(
 					EDMA_CHAN_SLOT(pdev->resource[i].start),
-						edma_info[ctlr]->edma_unused);
+						edma_cc[ctlr]->edma_unused);
 		}
 	}
 
@@ -599,7 +598,7 @@ int edma_alloc_channel(int channel,
 			channel = EDMA_CHAN_SLOT(channel);
 			if (xbar_event_to_channel_map) {
 				ret = xbar_event_to_channel_map(channel,
-						&channel, edma_info[ctlr]->
+						&channel, edma_cc[ctlr]->
 						xbar_event_mapping);
 				if (ret != 0)
 					return ret;
@@ -610,14 +609,13 @@ int edma_alloc_channel(int channel,
 		for (i = 0; i < arch_num_cc; i++) {
 			channel = 0;
 			for (;;) {
-				channel = find_next_bit(edma_info[i]->
-						edma_unused,
-						edma_info[i]->num_channels,
+				channel = find_next_bit(edma_cc[i]->edma_unused,
+						edma_cc[i]->num_channels,
 						channel);
-				if (channel == edma_info[i]->num_channels)
+				if (channel == edma_cc[i]->num_channels)
 					break;
 				if (!test_and_set_bit(channel,
-						edma_info[i]->edma_inuse)) {
+						edma_cc[i]->edma_inuse)) {
 					done = 1;
 					ctlr = i;
 					break;
@@ -629,9 +627,9 @@ int edma_alloc_channel(int channel,
 		}
 		if (!done)
 			return -ENOMEM;
-	} else if (channel >= edma_info[ctlr]->num_channels) {
+	} else if (channel >= edma_cc[ctlr]->num_channels) {
 		return -EINVAL;
-	} else if (test_and_set_bit(channel, edma_info[ctlr]->edma_inuse)) {
+	} else if (test_and_set_bit(channel, edma_cc[ctlr]->edma_inuse)) {
 		return -EBUSY;
 	}
 
@@ -672,7 +670,7 @@ void edma_free_channel(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel >= edma_info[ctlr]->num_channels)
+	if (channel >= edma_cc[ctlr]->num_channels)
 		return;
 
 	setup_dma_interrupt(channel, NULL, NULL);
@@ -680,7 +678,7 @@ void edma_free_channel(unsigned channel)
 
 	memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(channel),
 			&dummy_paramset, PARM_SIZE);
-	clear_bit(channel, edma_info[ctlr]->edma_inuse);
+	clear_bit(channel, edma_cc[ctlr]->edma_inuse);
 }
 EXPORT_SYMBOL(edma_free_channel);
 
@@ -704,20 +702,19 @@ int edma_alloc_slot(unsigned ctlr, int slot)
 		slot = EDMA_CHAN_SLOT(slot);
 
 	if (slot < 0) {
-		slot = edma_info[ctlr]->num_channels;
+		slot = edma_cc[ctlr]->num_channels;
 		for (;;) {
-			slot = find_next_zero_bit(edma_info[ctlr]->edma_inuse,
-					edma_info[ctlr]->num_slots, slot);
-			if (slot == edma_info[ctlr]->num_slots)
+			slot = find_next_zero_bit(edma_cc[ctlr]->edma_inuse,
+					edma_cc[ctlr]->num_slots, slot);
+			if (slot == edma_cc[ctlr]->num_slots)
 				return -ENOMEM;
-			if (!test_and_set_bit(slot,
-						edma_info[ctlr]->edma_inuse))
+			if (!test_and_set_bit(slot, edma_cc[ctlr]->edma_inuse))
 				break;
 		}
-	} else if (slot < edma_info[ctlr]->num_channels ||
-			slot >= edma_info[ctlr]->num_slots) {
+	} else if (slot < edma_cc[ctlr]->num_channels ||
+			slot >= edma_cc[ctlr]->num_slots) {
 		return -EINVAL;
-	} else if (test_and_set_bit(slot, edma_info[ctlr]->edma_inuse)) {
+	} else if (test_and_set_bit(slot, edma_cc[ctlr]->edma_inuse)) {
 		return -EBUSY;
 	}
 
@@ -743,13 +740,13 @@ void edma_free_slot(unsigned slot)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_channels ||
-		slot >= edma_info[ctlr]->num_slots)
+	if (slot < edma_cc[ctlr]->num_channels ||
+		slot >= edma_cc[ctlr]->num_slots)
 		return;
 
 	memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(slot),
 			&dummy_paramset, PARM_SIZE);
-	clear_bit(slot, edma_info[ctlr]->edma_inuse);
+	clear_bit(slot, edma_cc[ctlr]->edma_inuse);
 }
 EXPORT_SYMBOL(edma_free_slot);
 
@@ -787,8 +784,8 @@ int edma_alloc_cont_slots(unsigned ctlr, unsigned int id, int slot, int count)
 	 * of slots
 	 */
 	if ((id != EDMA_CONT_PARAMS_ANY) &&
-		(slot < edma_info[ctlr]->num_channels ||
-		slot >= edma_info[ctlr]->num_slots))
+		(slot < edma_cc[ctlr]->num_channels ||
+		slot >= edma_cc[ctlr]->num_slots))
 		return -EINVAL;
 
 	/*
@@ -797,13 +794,13 @@ int edma_alloc_cont_slots(unsigned ctlr, unsigned int id, int slot, int count)
 	 * channels
 	 */
 	if (count < 1 || count >
-		(edma_info[ctlr]->num_slots - edma_info[ctlr]->num_channels))
+		(edma_cc[ctlr]->num_slots - edma_cc[ctlr]->num_channels))
 		return -EINVAL;
 
 	switch (id) {
 	case EDMA_CONT_PARAMS_ANY:
 		return reserve_contiguous_slots(ctlr, id, count,
-						 edma_info[ctlr]->num_channels);
+						 edma_cc[ctlr]->num_channels);
 	case EDMA_CONT_PARAMS_FIXED_EXACT:
 	case EDMA_CONT_PARAMS_FIXED_NOT_EXACT:
 		return reserve_contiguous_slots(ctlr, id, count, slot);
@@ -835,8 +832,8 @@ int edma_free_cont_slots(unsigned slot, int count)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_channels ||
-		slot >= edma_info[ctlr]->num_slots ||
+	if (slot < edma_cc[ctlr]->num_channels ||
+		slot >= edma_cc[ctlr]->num_slots ||
 		count < 1)
 		return -EINVAL;
 
@@ -846,7 +843,7 @@ int edma_free_cont_slots(unsigned slot, int count)
 
 		memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(slot_to_free),
 			&dummy_paramset, PARM_SIZE);
-		clear_bit(slot_to_free, edma_info[ctlr]->edma_inuse);
+		clear_bit(slot_to_free, edma_cc[ctlr]->edma_inuse);
 	}
 
 	return 0;
@@ -876,7 +873,7 @@ void edma_set_src(unsigned slot, dma_addr_t src_port,
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_slots) {
+	if (slot < edma_cc[ctlr]->num_slots) {
 		unsigned int i = edma_parm_read(ctlr, PARM_OPT, slot);
 
 		if (mode) {
@@ -914,7 +911,7 @@ void edma_set_dest(unsigned slot, dma_addr_t dest_port,
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_slots) {
+	if (slot < edma_cc[ctlr]->num_slots) {
 		unsigned int i = edma_parm_read(ctlr, PARM_OPT, slot);
 
 		if (mode) {
@@ -974,7 +971,7 @@ void edma_set_src_index(unsigned slot, s16 src_bidx, s16 src_cidx)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_slots) {
+	if (slot < edma_cc[ctlr]->num_slots) {
 		edma_parm_modify(ctlr, PARM_SRC_DST_BIDX, slot,
 				0xffff0000, src_bidx);
 		edma_parm_modify(ctlr, PARM_SRC_DST_CIDX, slot,
@@ -1000,7 +997,7 @@ void edma_set_dest_index(unsigned slot, s16 dest_bidx, s16 dest_cidx)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_slots) {
+	if (slot < edma_cc[ctlr]->num_slots) {
 		edma_parm_modify(ctlr, PARM_SRC_DST_BIDX, slot,
 				0x0000ffff, dest_bidx << 16);
 		edma_parm_modify(ctlr, PARM_SRC_DST_CIDX, slot,
@@ -1047,7 +1044,7 @@ void edma_set_transfer_params(unsigned slot,
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot < edma_info[ctlr]->num_slots) {
+	if (slot < edma_cc[ctlr]->num_slots) {
 		edma_parm_modify(ctlr, PARM_LINK_BCNTRLD, slot,
 				0x0000ffff, bcnt_rld << 16);
 		if (sync_mode == ASYNC)
@@ -1077,9 +1074,9 @@ void edma_link(unsigned from, unsigned to)
 	ctlr_to = EDMA_CTLR(to);
 	to = EDMA_CHAN_SLOT(to);
 
-	if (from >= edma_info[ctlr_from]->num_slots)
+	if (from >= edma_cc[ctlr_from]->num_slots)
 		return;
-	if (to >= edma_info[ctlr_to]->num_slots)
+	if (to >= edma_cc[ctlr_to]->num_slots)
 		return;
 	edma_parm_modify(ctlr_from, PARM_LINK_BCNTRLD, from, 0xffff0000,
 				PARM_OFFSET(to));
@@ -1100,7 +1097,7 @@ void edma_unlink(unsigned from)
 	ctlr = EDMA_CTLR(from);
 	from = EDMA_CHAN_SLOT(from);
 
-	if (from >= edma_info[ctlr]->num_slots)
+	if (from >= edma_cc[ctlr]->num_slots)
 		return;
 	edma_parm_or(ctlr, PARM_LINK_BCNTRLD, from, 0xffff);
 }
@@ -1127,7 +1124,7 @@ void edma_write_slot(unsigned slot, const struct edmacc_param *param)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot >= edma_info[ctlr]->num_slots)
+	if (slot >= edma_cc[ctlr]->num_slots)
 		return;
 	memcpy_toio(edmacc_regs_base[ctlr] + PARM_OFFSET(slot), param,
 			PARM_SIZE);
@@ -1149,7 +1146,7 @@ void edma_read_slot(unsigned slot, struct edmacc_param *param)
 	ctlr = EDMA_CTLR(slot);
 	slot = EDMA_CHAN_SLOT(slot);
 
-	if (slot >= edma_info[ctlr]->num_slots)
+	if (slot >= edma_cc[ctlr]->num_slots)
 		return;
 	memcpy_fromio(param, edmacc_regs_base[ctlr] + PARM_OFFSET(slot),
 			PARM_SIZE);
@@ -1174,7 +1171,7 @@ void edma_pause(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel < edma_info[ctlr]->num_channels) {
+	if (channel < edma_cc[ctlr]->num_channels) {
 		unsigned int mask = (1 << (channel & 0x1f));
 
 		edma_shadow0_write_array(ctlr, SH_EECR, channel >> 5, mask);
@@ -1195,7 +1192,7 @@ void edma_resume(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel < edma_info[ctlr]->num_channels) {
+	if (channel < edma_cc[ctlr]->num_channels) {
 		unsigned int mask = (1 << (channel & 0x1f));
 
 		edma_shadow0_write_array(ctlr, SH_EESR, channel >> 5, mask);
@@ -1221,12 +1218,12 @@ int edma_start(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel < edma_info[ctlr]->num_channels) {
+	if (channel < edma_cc[ctlr]->num_channels) {
 		int j = channel >> 5;
 		unsigned int mask = (1 << (channel & 0x1f));
 
 		/* EDMA channels without event association */
-		if (test_bit(channel, edma_info[ctlr]->edma_unused)) {
+		if (test_bit(channel, edma_cc[ctlr]->edma_unused)) {
 			pr_debug("EDMA: ESR%d %08x\n", j,
 				edma_shadow0_read_array(ctlr, SH_ESR, j));
 			edma_shadow0_write_array(ctlr, SH_ESR, j, mask);
@@ -1266,7 +1263,7 @@ void edma_stop(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel < edma_info[ctlr]->num_channels) {
+	if (channel < edma_cc[ctlr]->num_channels) {
 		int j = channel >> 5;
 		unsigned int mask = (1 << (channel & 0x1f));
 
@@ -1305,7 +1302,7 @@ void edma_clean_channel(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel < edma_info[ctlr]->num_channels) {
+	if (channel < edma_cc[ctlr]->num_channels) {
 		int j = (channel >> 5);
 		unsigned int mask = 1 << (channel & 0x1f);
 
@@ -1333,7 +1330,7 @@ void edma_clear_event(unsigned channel)
 	ctlr = EDMA_CTLR(channel);
 	channel = EDMA_CHAN_SLOT(channel);
 
-	if (channel >= edma_info[ctlr]->num_channels)
+	if (channel >= edma_cc[ctlr]->num_channels)
 		return;
 	if (channel < 32)
 		edma_write(ctlr, EDMA_ECR, 1 << channel);
@@ -1436,34 +1433,33 @@ static int __init edma_probe(struct platform_device *pdev)
 			goto fail1;
 		}
 
-		edma_info[j] = kmalloc(sizeof(struct edma), GFP_KERNEL);
-		if (!edma_info[j]) {
+		edma_cc[j] = kmalloc(sizeof(struct edma), GFP_KERNEL);
+		if (!edma_cc[j]) {
 			status = -ENOMEM;
 			goto fail1;
 		}
-		memset(edma_info[j], 0, sizeof(struct edma));
+		memset(edma_cc[j], 0, sizeof(struct edma));
 
-		edma_info[j]->num_channels = min_t(unsigned, info[j].n_channel,
+		edma_cc[j]->num_channels = min_t(unsigned, info[j].n_channel,
 							EDMA_MAX_DMACH);
-		edma_info[j]->num_slots = min_t(unsigned, info[j].n_slot,
+		edma_cc[j]->num_slots = min_t(unsigned, info[j].n_slot,
 							EDMA_MAX_PARAMENTRY);
-		edma_info[j]->num_cc = min_t(unsigned, info[j].n_cc,
-							EDMA_MAX_CC);
+		edma_cc[j]->num_cc = min_t(unsigned, info[j].n_cc, EDMA_MAX_CC);
 
-		edma_info[j]->default_queue = info[j].default_queue;
-		if (!edma_info[j]->default_queue)
-			edma_info[j]->default_queue = EVENTQ_1;
+		edma_cc[j]->default_queue = info[j].default_queue;
+		if (!edma_cc[j]->default_queue)
+			edma_cc[j]->default_queue = EVENTQ_1;
 
 		dev_dbg(&pdev->dev, "DMA REG BASE ADDR=%p\n",
 			edmacc_regs_base[j]);
 
-		for (i = 0; i < edma_info[j]->num_slots; i++)
+		for (i = 0; i < edma_cc[j]->num_slots; i++)
 			memcpy_toio(edmacc_regs_base[j] + PARM_OFFSET(i),
 					&dummy_paramset, PARM_SIZE);
 
 		/* Mark all channels as unused */
-		memset(edma_info[j]->edma_unused, 0xff,
-			sizeof(edma_info[j]->edma_unused));
+		memset(edma_cc[j]->edma_unused, 0xff,
+			sizeof(edma_cc[j]->edma_unused));
 
 		/* Clear the reserved channels in unused list */
 		rsv_chans = info[j].rsv_chans;
@@ -1474,7 +1470,7 @@ static int __init edma_probe(struct platform_device *pdev)
 				/* confirm the range */
 				if ((off+ln) < EDMA_MAX_DMACH)
 					clear_bits(off, ln,
-						edma_info[j]->edma_unused);
+						edma_cc[j]->edma_unused);
 			}
 		}
 
@@ -1484,13 +1480,13 @@ static int __init edma_probe(struct platform_device *pdev)
 			for (i = 0; rsv_slots[i][0] != -1; i++) {
 				off = rsv_slots[i][0];
 				ln = rsv_slots[i][1];
-				set_bits(off, ln, edma_info[j]->edma_inuse);
+				set_bits(off, ln, edma_cc[j]->edma_inuse);
 			}
 		}
 
 		sprintf(irq_name, "edma%d", j);
 		irq[j] = platform_get_irq_byname(pdev, irq_name);
-		edma_info[j]->irq_res_start = irq[j];
+		edma_cc[j]->irq_res_start = irq[j];
 		status = request_irq(irq[j], dma_irq_handler, 0, "edma",
 					&pdev->dev);
 		if (status < 0) {
@@ -1501,7 +1497,7 @@ static int __init edma_probe(struct platform_device *pdev)
 
 		sprintf(irq_name, "edma%d_err", j);
 		err_irq[j] = platform_get_irq_byname(pdev, irq_name);
-		edma_info[j]->irq_res_end = err_irq[j];
+		edma_cc[j]->irq_res_end = err_irq[j];
 		status = request_irq(err_irq[j], dma_ccerr_handler, 0,
 					"edma_error", &pdev->dev);
 		if (status < 0) {
@@ -1514,7 +1510,7 @@ static int __init edma_probe(struct platform_device *pdev)
 		 * specified. This way, long transfers on the low priority queue
 		 * started by the codec engine will not cause audio defects.
 		 */
-		for (i = 0; i < edma_info[j]->num_channels; i++)
+		for (i = 0; i < edma_cc[j]->num_channels; i++)
 			map_dmach_queue(j, i, EVENTQ_1);
 
 		queue_tc_mapping = info[j].queue_tc_mapping;
@@ -1543,11 +1539,11 @@ static int __init edma_probe(struct platform_device *pdev)
 			edma_write_array(j, EDMA_QRAE, i, 0x0);
 		}
 
-		edma_info[j]->is_xbar = info[j].is_xbar;
+		edma_cc[j]->is_xbar = info[j].is_xbar;
 
-		if (edma_info[j]->is_xbar) {
-			edma_info[j]->num_events = info[j].n_events;
-			edma_info[j]->xbar_event_mapping =
+		if (edma_cc[j]->is_xbar) {
+			edma_cc[j]->num_events = info[j].n_events;
+			edma_cc[j]->xbar_event_mapping =
 						info[j].xbar_event_mapping;
 			xbar_event_to_channel_map = info[j].map_xbar_channel;
 		}
@@ -1570,7 +1566,7 @@ fail1:
 			release_mem_region(r[i]->start, len[i]);
 		if (edmacc_regs_base[i])
 			iounmap(edmacc_regs_base[i]);
-		kfree(edma_info[i]);
+		kfree(edma_cc[i]);
 	}
 	edma_clk_setup(0);
 	return status;
diff --git a/arch/arm/mach-omap2/include/mach/edma.h b/arch/arm/mach-omap2/include/mach/edma.h
index 436ff25..3855f12 100644
--- a/arch/arm/mach-omap2/include/mach/edma.h
+++ b/arch/arm/mach-omap2/include/mach/edma.h
@@ -167,7 +167,7 @@ struct edma {
 	struct event_to_channel_map	*xbar_event_mapping;
 };
 
-extern struct edma *edma_info[EDMA_MAX_CC];
+extern struct edma *edma_cc[EDMA_MAX_CC];
 
 /* alloc/free DMA channels and their dedicated parameter RAM slots */
 int edma_alloc_channel(int channel,
-- 
1.7.5.4

