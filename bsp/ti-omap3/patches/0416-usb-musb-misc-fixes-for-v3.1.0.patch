From 4a5897df4ff4d5509eb450744344cfdcff9f07fe Mon Sep 17 00:00:00 2001
From: Ajay Kumar Gupta <ajay.gupta@ti.com>
Date: Fri, 23 Sep 2011 14:39:57 +0530
Subject: [PATCH 416/609] usb: musb: misc fixes for v3.1.0

Original commit: 53b035bd727ee53f2a8648738b75b54bbf2006aa

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Changes
	- v3.1-rc3 has replaced all DBG to dev_dbg.
	- CONFIG_MUSB_DEBUG related cleanups
	- drivers always in OTG mode so drop all GADGET or HOST ifdefs

Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/Kconfig       |    4 +-
 drivers/usb/musb/Makefile      |    4 +--
 drivers/usb/musb/cppi41_dma.c  |    3 +-
 drivers/usb/musb/musb_core.h   |   12 --------
 drivers/usb/musb/musb_procfs.c |   62 ++-------------------------------------
 drivers/usb/musb/ti81xx.c      |   55 ++++++++++++++++++-----------------
 drivers/usb/musb/ti81xx.h      |    6 ++-
 7 files changed, 40 insertions(+), 106 deletions(-)

diff --git a/drivers/usb/musb/Kconfig b/drivers/usb/musb/Kconfig
index ab72bb2..fbe05ea 100644
--- a/drivers/usb/musb/Kconfig
+++ b/drivers/usb/musb/Kconfig
@@ -8,7 +8,7 @@ config USB_MUSB_HDRC
 	tristate 'Inventra Highspeed Dual Role Controller (TI, ADI, ...)'
 	depends on USB && USB_GADGET
 	select NOP_USB_XCEIV if (ARCH_DAVINCI || MACH_OMAP3EVM || BLACKFIN)
-	select NOP_USB_XCEIV if (ARCH_TI81XX)
+	select NOP_USB_XCEIV if (SOC_OMAPTI81XX)
 	select TWL4030_USB if MACH_OMAP_3430SDP
 	select TWL6030_USB if MACH_OMAP_4430SDP || MACH_OMAP4_PANDA
 	select USB_OTG_UTILS
@@ -63,7 +63,7 @@ config USB_MUSB_AM35X_GLUE
 config USB_MUSB_TI81XX_GLUE
 	select USB_MUSB_TI81XX
 	tristate "TI81XX"
-	depends on ARCH_TI81XX && USB_MUSB_HDRC
+	depends on SOC_OMAPTI81XX && USB_MUSB_HDRC
 
 config USB_MUSB_BLACKFIN_GLUE
 	select USB_MUSB_BLACKFIN
diff --git a/drivers/usb/musb/Makefile b/drivers/usb/musb/Makefile
index 7f2e07c..da5421b 100644
--- a/drivers/usb/musb/Makefile
+++ b/drivers/usb/musb/Makefile
@@ -9,9 +9,7 @@ musb_hdrc-y := musb_core.o
 musb_hdrc-y					+= musb_gadget_ep0.o musb_gadget.o
 musb_hdrc-y					+= musb_virthub.o musb_host.o
 musb_hdrc-$(CONFIG_DEBUG_FS)			+= musb_debugfs.o
-ifeq ($(CONFIG_USB_MUSB_DEBUG),y)
-	musb_hdrc-$(CONFIG_PROC_FS)             += musb_procfs.o
-endif
+musb_hdrc-$(CONFIG_PROC_FS)			+= musb_procfs.o
 # Hardware Glue Layer
 obj-$(CONFIG_USB_MUSB_OMAP2PLUS_GLUE)		+= omap2430.o
 obj-$(CONFIG_USB_MUSB_AM35X_GLUE)		+= am35x.o
diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 13050f5..b274732 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -760,9 +760,8 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 		 * GENERIC_RNDIS mode. Without this RNDIS gadget taking
 		 * more then 2K ms for a 64 byte pings.
 		 */
-#if defined(CONFIG_USB_GADGET_MUSB_HDRC) || defined(CONFIG_USB_GADGET_MUSB_HDRC_MODULE)
 		gadget_driver = cppi->musb->gadget_driver;
-#endif
+
 		pkt_len = rx_ch->pkt_size;
 		mode = USB_GENERIC_RNDIS_MODE;
 		if (!strcmp(gadget_driver->driver.name, "g_file_storage")) {
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 997446e..107c58d 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -649,18 +649,6 @@ extern void musb_gb_work(struct work_struct *data);
 
 struct proc_dir_entry;
 
-#if defined(CONFIG_USB_MUSB_DEBUG) && defined(MUSB_CONFIG_PROC_FS)
 extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
 extern void musb_debug_delete(char *name, struct musb *data);
-
-#else
-static inline struct proc_dir_entry *
-musb_debug_create(char *name, struct musb *data)
-{
-	return NULL;
-}
-static inline void musb_debug_delete(char *name, struct musb *data)
-{
-}
-#endif
 #endif	/* __MUSB_CORE_H__ */
diff --git a/drivers/usb/musb/musb_procfs.c b/drivers/usb/musb/musb_procfs.c
index ce44d06..16f01e5 100644
--- a/drivers/usb/musb/musb_procfs.c
+++ b/drivers/usb/musb/musb_procfs.c
@@ -42,8 +42,6 @@
 
 #include "davinci.h"
 
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-
 static int dump_qh(struct musb_qh *qh, char *buf, unsigned max)
 {
 	int				count;
@@ -104,9 +102,6 @@ dump_queue(struct list_head *q, char *buf, unsigned max)
 	return count;
 }
 
-#endif	/* HCD */
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 static int dump_ep(struct musb_ep *ep, char *buffer, unsigned max)
 {
 	char		*buf = buffer;
@@ -205,7 +200,6 @@ static int dump_ep(struct musb_ep *ep, char *buffer, unsigned max)
 	} while (0);
 	return buf - buffer;
 }
-#endif
 
 static int
 dump_end_info(struct musb *musb, u8 epnum, char *aBuffer, unsigned max)
@@ -216,7 +210,6 @@ dump_end_info(struct musb *musb, u8 epnum, char *aBuffer, unsigned max)
 
 	do {
 		musb_ep_select(musb, musb->mregs, epnum);
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 		if (is_host_active(musb)) {
 			int		dump_rx, dump_tx;
 			void __iomem	*regs = hw_ep->regs;
@@ -425,8 +418,6 @@ dump_end_info(struct musb *musb, u8 epnum, char *aBuffer, unsigned max)
 				}
 			}
 		}
-#endif
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		if (is_peripheral_active(musb)) {
 			code = 0;
 
@@ -447,7 +438,6 @@ dump_end_info(struct musb *musb, u8 epnum, char *aBuffer, unsigned max)
 				max -= code;
 			}
 		}
-#endif
 	} while (0);
 
 	return buf - aBuffer;
@@ -474,7 +464,7 @@ static int dump_header_stats(struct musb *musb, char *buffer)
 	buffer += count;
 
 	code = sprintf(buffer, "OTG state: %s; %sactive\n",
-			otg_state_string(musb),
+			otg_state_string(musb->xceiv->state),
 			musb->is_active ? "" : "in");
 	if (code <= 0)
 		goto done;
@@ -495,38 +485,27 @@ static int dump_header_stats(struct musb *musb, char *buffer)
 			"?dma?"
 #endif
 			", "
-#ifdef CONFIG_USB_MUSB_OTG
 			"otg (peripheral+host)"
-#elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
-			"peripheral"
-#elif defined(CONFIG_USB_MUSB_HDRC_HCD)
-			"host"
-#endif
-			", debug=%d [eps=%d]\n",
-		musb_debug,
+			", [eps=%d]\n",
 		musb->nr_endpoints);
 	if (code <= 0)
 		goto done;
 	count += code;
 	buffer += code;
 
-#ifdef	CONFIG_USB_GADGET_MUSB_HDRC
 	code = sprintf(buffer, "Peripheral address: %02x\n",
 			musb_readb(musb->ctrl_base, MUSB_FADDR));
 	if (code <= 0)
 		goto done;
 	buffer += code;
 	count += code;
-#endif
 
-#ifdef	CONFIG_USB_MUSB_HDRC_HCD
 	code = sprintf(buffer, "Root port status: %08x\n",
 			musb->port1_status);
 	if (code <= 0)
 		goto done;
 	buffer += code;
 	count += code;
-#endif
 
 #ifdef	CONFIG_ARCH_DAVINCI
 	code = sprintf(buffer,
@@ -594,7 +573,6 @@ static int dump_header_stats(struct musb *musb, char *buffer)
 		buffer += code;
 	}
 
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	if (is_peripheral_enabled(musb)) {
 		code = sprintf(buffer, "Gadget driver: %s\n",
 				musb->gadget_driver
@@ -605,7 +583,6 @@ static int dump_header_stats(struct musb *musb, char *buffer)
 		count += code;
 		buffer += code;
 	}
-#endif
 
 done:
 	return count;
@@ -710,38 +687,8 @@ static int musb_proc_write(struct file *file, const char __user *buffer,
 					MUSB_TEST_PACKET);
 			musb_writew(musb->endpoints[0].regs,
 				MUSB_CSR0, MUSB_CSR0_TXPKTRDY);
-			DBG(2, "musb:testmode sending test packet\n");
-		}
-		break;
-
-#if (CONFIG_USB_MUSB_DEBUG > 0)
-		/* set/read debug level */
-	case 'D':{
-			if (count > 1) {
-				char digits[8], *p = digits;
-				int i = 0, level = 0, sign = 1;
-				int len = min(count - 1, (unsigned long)8);
-
-				if (copy_from_user(&digits, &buffer[1], len))
-					return -EFAULT;
-
-				/* optional sign */
-				if (*p == '-') {
-					len -= 1;
-					sign = -sign;
-					p++;
-				}
-
-				/* read it */
-				while (i++ < len && *p > '0' && *p < '9') {
-					level = level * 10 + (*p - '0');
-					p++;
-				}
-
-				level *= sign;
-				DBG(1, "debug level %d\n", level);
-				musb_debug = level;
-			}
+			dev_dbg(musb->controller,
+				"musb:testmode sending test packet\n");
 		}
 		break;
 
@@ -773,7 +720,6 @@ static int musb_proc_write(struct file *file, const char __user *buffer,
 		INFO("D: set/read dbug level\n");
 		INFO("K/k: enable/disable babble workaround\n");
 		break;
-#endif
 
 	default:
 		ERR("Command %c not implemented\n", cmd);
diff --git a/drivers/usb/musb/ti81xx.c b/drivers/usb/musb/ti81xx.c
index f0aa597..b106f08 100644
--- a/drivers/usb/musb/ti81xx.c
+++ b/drivers/usb/musb/ti81xx.c
@@ -107,17 +107,17 @@ static void usbotg_ss_uninit(void)
 		usbss_virt_base = 0;
 	}
 }
-void set_frame_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value, u8 en_intr)
+void set_frame_threshold(struct musb *musb, u8 is_tx, u8 epnum, u8 value, u8 en_intr)
 {
 	u32     base, reg_val, frame_intr = 0, frame_base = 0;
 	u32     offs = epnum/4*4;
 	u8      indx = (epnum % 4) * 8;
 
 	if (is_tx)
-		base = musb_id ? USBSS_IRQ_FRAME_THRESHOLD_TX1 :
+		base = musb->id ? USBSS_IRQ_FRAME_THRESHOLD_TX1 :
 				USBSS_IRQ_FRAME_THRESHOLD_TX0;
 	else
-		base = musb_id ? USBSS_IRQ_FRAME_THRESHOLD_RX1 :
+		base = musb->id ? USBSS_IRQ_FRAME_THRESHOLD_RX1 :
 				USBSS_IRQ_FRAME_THRESHOLD_RX0;
 
 	reg_val = usbss_read(base + offs);
@@ -126,24 +126,24 @@ void set_frame_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value, u8 en_intr)
 	usbss_write(base + offs, reg_val);
 
 	if (en_intr) {
-		frame_base = musb_id ? USBSS_IRQ_FRAME_ENABLE_1 :
+		frame_base = musb->id ? USBSS_IRQ_FRAME_ENABLE_1 :
 			USBSS_IRQ_FRAME_ENABLE_0;
-		frame_intr = musb_id ? usbss_read(USBSS_IRQ_FRAME_ENABLE_0) :
+		frame_intr = musb->id ? usbss_read(USBSS_IRQ_FRAME_ENABLE_0) :
 			usbss_read(USBSS_IRQ_FRAME_ENABLE_1);
 		frame_intr |= is_tx ? (1 << epnum) : (1 << (16 + epnum));
 		usbss_write(frame_base, frame_intr);
-		DBG(4, "%s: framebase=%x, frame_intr=%x\n", is_tx ? "tx" : "rx",
-			frame_base, frame_intr);
+		dev_dbg(musb->controller, "%s: framebase=%x, frame_intr=%x\n",
+			is_tx ? "tx" : "rx", frame_base, frame_intr);
 	}
 }
 
-void set_dma_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value)
+void set_dma_threshold(struct musb *musb, u8 is_tx, u8 epnum, u8 value)
 {
 	u32     base, reg_val;
 	u32     offs = epnum/4*4;
 	u8      indx = (epnum % 4) * 8;
 
-	if (musb_id == 0)
+	if (musb->id == 0)
 		base = is_tx ? USBSS_IRQ_DMA_THRESHOLD_TX0 :
 				USBSS_IRQ_DMA_THRESHOLD_RX0;
 	else
@@ -153,7 +153,7 @@ void set_dma_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value)
 	reg_val = usbss_read(base + offs);
 	reg_val &= ~(0xFF << indx);
 	reg_val |= (value << indx);
-	DBG(4, "base=%x, offs=%x, indx=%d, reg_val = (%x)%x\n",
+	dev_dbg(musb->controller, "base=%x, offs=%x, indx=%d, reg_val = (%x)%x\n",
 		base, offs, indx, reg_val, usbss_read(base + offs));
 	usbss_write(base + offs, reg_val);
 }
@@ -481,7 +481,7 @@ int __devinit cppi41_init(u8 id, u8 irq)
 
 	cppi41_init_done = 1;
 
-	DBG(4, "Cppi41 Init Done Qmgr-base(%p) dma-base(%p)\n",
+	printk(KERN_INFO "Cppi41 Init Done Qmgr-base(%p) dma-base(%p)\n",
 		cppi41_queue_mgr[0].q_mgr_rgn_base,
 		cppi41_dma_block[0].global_ctrl_base);
 
@@ -592,7 +592,8 @@ static void otg_timer(unsigned long _musb)
 	* status change events (from the transceiver) otherwise.
 	 */
 	devctl = musb_readb(mregs, MUSB_DEVCTL);
-	DBG(7, "Poll devctl %02x (%s)\n", devctl, otg_state_string(musb));
+	dev_dbg(musb->controller, "Poll devctl %02x (%s)\n", devctl,
+			otg_state_string(musb->xceiv->state));
 
 	spin_lock_irqsave(&musb->lock, flags);
 	switch (musb->xceiv->state) {
@@ -665,20 +666,22 @@ void ti81xx_musb_try_idle(struct musb *musb, unsigned long timeout)
 	/* Never idle if active, or when VBUS timeout is not set as host */
 	if (musb->is_active || (musb->a_wait_bcon == 0 &&
 				musb->xceiv->state == OTG_STATE_A_WAIT_BCON)) {
-		DBG(4, "%s active, deleting timer\n", otg_state_string(musb));
+		dev_dbg(musb->controller, "%s active, deleting timer\n",
+			otg_state_string(musb->xceiv->state));
 		del_timer(&otg_workaround);
 		last_timer = jiffies;
 		return;
 	}
 
 	if (time_after(last_timer, timeout) && timer_pending(&otg_workaround)) {
-		DBG(4, "Longer idle timer already pending, ignoring...\n");
+		dev_dbg(musb->controller, "Longer idle timer already pending, ignoring...\n");
 		return;
 	}
 	last_timer = timeout;
 
-	DBG(4, "%s inactive, starting idle timer for %u ms\n",
-	    otg_state_string(musb), jiffies_to_msecs(timeout - jiffies));
+	dev_dbg(musb->controller, "%s inactive, starting idle timer for %u ms\n",
+	    otg_state_string(musb->xceiv->state),
+		jiffies_to_msecs(timeout - jiffies));
 	mod_timer(&otg_workaround, timeout);
 }
 
@@ -729,7 +732,7 @@ static irqreturn_t cppi41dma_Interrupt(int irq, void *hci)
 
 	/* get proper musb handle based usb0/usb1 ctrl-id */
 
-	DBG(4, "CPPI 4.1 IRQ: Tx %x, Rx %x\n", usb0_tx_intr,
+	dev_dbg(musb->controller, "CPPI 4.1 IRQ: Tx %x, Rx %x\n", usb0_tx_intr,
 				usb0_rx_intr);
 	if (gmusb[0] && (usb0_tx_intr || usb0_rx_intr)) {
 		spin_lock_irqsave(&gmusb[0]->lock, flags);
@@ -739,7 +742,7 @@ static irqreturn_t cppi41dma_Interrupt(int irq, void *hci)
 		ret = IRQ_HANDLED;
 	}
 
-	DBG(4, "CPPI 4.1 IRQ: Tx %x, Rx %x\n", usb1_tx_intr,
+	dev_dbg(musb->controller, "CPPI 4.1 IRQ: Tx %x, Rx %x\n", usb1_tx_intr,
 		usb1_rx_intr);
 	if (gmusb[1] && (usb1_rx_intr || usb1_tx_intr)) {
 		spin_lock_irqsave(&gmusb[1]->lock, flags);
@@ -837,7 +840,7 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 	/* Get usb core interrupts */
 	usbintr = musb_readl(reg_base, USB_CORE_INTR_STATUS_REG);
 	if (!usbintr && !epintr) {
-		DBG(4, "sprious interrupt\n");
+		dev_dbg(musb->controller, "sprious interrupt\n");
 		goto eoi;
 	}
 
@@ -845,7 +848,7 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 		musb_writel(reg_base, USB_CORE_INTR_STATUS_REG, usbintr);
 	musb->int_usb =	(usbintr & USB_INTR_USB_MASK) >> USB_INTR_USB_SHIFT;
 
-	DBG(4, "usbintr (%x) epintr(%x)\n", usbintr, epintr);
+	dev_dbg(musb->controller, "usbintr (%x) epintr(%x)\n", usbintr, epintr);
 	/*
 	 * DRVVBUS IRQs are the only proxy we have (a very poor one!) for
 	 * AM3517's missing ID change IRQ.  We need an ID change IRQ to
@@ -892,20 +895,18 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 			MUSB_HST_MODE(musb);
 			musb->xceiv->default_a = 1;
 			musb->xceiv->state = OTG_STATE_A_WAIT_VRISE;
-			portstate(musb->port1_status |= USB_PORT_STAT_POWER);
 			del_timer(&otg_workaround);
 		} else {
 			musb->is_active = 0;
 			MUSB_DEV_MODE(musb);
 			musb->xceiv->default_a = 0;
 			musb->xceiv->state = OTG_STATE_B_IDLE;
-			portstate(musb->port1_status &= ~USB_PORT_STAT_POWER);
 		}
 
 		/* NOTE: this must complete power-on within 100 ms. */
 		dev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",
 				drvvbus ? "on" : "off",
-				otg_state_string(musb),
+				otg_state_string(musb->xceiv->state),
 				err ? " ERROR" : "",
 				devctl);
 		ret = IRQ_HANDLED;
@@ -933,7 +934,7 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 			 * We sometimes get unhandled IRQs in the peripheral
 			 * mode from EP0 and SOF...
 			 */
-			DBG(2, "Unhandled USB IRQ %08x-%08x\n",
+			dev_dbg(musb->controller, "Unhandled USB IRQ %08x-%08x\n",
 					 epintr, usbintr);
 		else if (printk_ratelimit())
 			/*
@@ -941,7 +942,7 @@ static irqreturn_t ti81xx_interrupt(int irq, void *hci)
 			 * peripheral mode after USB reset and then after some
 			 * time a real interrupt storm starting...
 			 */
-			DBG(2, "Spurious IRQ, CPPI 4.1 status %08x, %08x\n",
+			dev_dbg(musb->controller, "Spurious IRQ, CPPI 4.1 status %08x, %08x\n",
 					 pend1, pend2);
 	}
 
@@ -973,7 +974,7 @@ int ti81xx_musb_set_mode(struct musb *musb, u8 musb_mode)
 
 		musb_writel(reg_base, USB_MODE_REG, regval);
 		musb_writel(musb->ctrl_base, USB_PHY_UTMI_REG, 0x02);
-		DBG(4, "host: value of mode reg=%x regval(%x)\n",
+		dev_dbg(musb->controller, "host: value of mode reg=%x regval(%x)\n",
 			musb_readl(reg_base, USB_MODE_REG), regval);
 	} else if (musb_mode == MUSB_PERIPHERAL) {
 		/* TODO commmented writing 8 to USB_MODE_REG device
@@ -985,7 +986,7 @@ int ti81xx_musb_set_mode(struct musb *musb, u8 musb_mode)
 			regval |= USBMODE_USBID_MUXSEL;
 
 		musb_writel(reg_base, USB_MODE_REG, regval);
-		DBG(4, "device: value of mode reg=%x regval(%x)\n",
+		dev_dbg(musb->controller, "device: value of mode reg=%x regval(%x)\n",
 			musb_readl(reg_base, USB_MODE_REG), regval);
 	} else if (musb_mode == MUSB_OTG) {
 		musb_writel(musb->ctrl_base, USB_PHY_UTMI_REG, 0x02);
diff --git a/drivers/usb/musb/ti81xx.h b/drivers/usb/musb/ti81xx.h
index 423725f..95423bf 100644
--- a/drivers/usb/musb/ti81xx.h
+++ b/drivers/usb/musb/ti81xx.h
@@ -10,6 +10,10 @@
 #ifndef __MUSB_HDRDF_H__
 #define __MUSB_HDRDF_H__
 
+#define TI81XX_USB_CPPIDMA_BASE 0x47402000
+#define TI81XX_USB_CPPIDMA_LEN  0x5FFF
+#define TI81XX_IRQ_USBSS        17
+
 /* Netra USB susbsystem register offsets */
 #define USBSS_REVISION			0x0000
 #define USBSS_SYSCONFIG			0x0010
@@ -162,6 +166,4 @@
 #define	USBMODE_USBID_HIGH	0x100
 
 extern void usb_nop_xceiv_register(int id);
-void set_frame_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value, u8 en_intr);
-void set_dma_threshold(u8 musb_id, u8 is_tx, u8 epnum, u8 value);
 #endif
-- 
1.7.5.4

