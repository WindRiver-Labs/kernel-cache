From 339c6e12ac4e9412960a5981510bfeac0621256e Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Thu, 9 Dec 2010 11:21:29 +0530
Subject: [PATCH 384/609] musb: cppi41: General cleanup

Original commit: 94ddb9b3d128724e546f56daf52728746a1e5f4f

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Changes:
	- Removed the hard coded constants for size by adding 'size'
	  field into cppi41 strcuture
	- Added q_num and q_mgr as required to support multi-controller

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Ajay Kumar Gupta <ajay.gupta@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41.c |   32 +++++++++++++++++++++++---------
 1 files changed, 23 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/musb/cppi41.c b/drivers/usb/musb/cppi41.c
index f768c0f..36f4379 100644
--- a/drivers/usb/musb/cppi41.c
+++ b/drivers/usb/musb/cppi41.c
@@ -43,6 +43,7 @@
 static struct {
 	void *virt_addr;
 	dma_addr_t phys_addr;
+	u32     size;
 } linking_ram[CPPI41_NUM_QUEUE_MGR];
 
 static u32 *allocated_queues[CPPI41_NUM_QUEUE_MGR];
@@ -57,6 +58,8 @@ static struct {
 	dma_addr_t phys_addr;
 	struct cppi41_queue_obj queue_obj;
 	u8 mem_rgn;
+	u16 q_mgr;
+	u16 q_num;
 } dma_teardown[CPPI41_NUM_DMA_BLOCK];
 
 struct cppi41_dma_sched_tbl_t {
@@ -103,6 +106,7 @@ int cppi41_queue_mgr_init(u8 q_mgr, dma_addr_t rgn0_base, u16 rgn0_size)
 		return -ENOMEM;
 	}
 	linking_ram[q_mgr].virt_addr = ptr;
+	linking_ram[q_mgr].size = rgn0_size * 4;
 
 	__raw_writel(linking_ram[q_mgr].phys_addr,
 			q_mgr_regs + QMGR_LINKING_RAM_RGN0_BASE_REG);
@@ -308,6 +312,8 @@ int cppi41_dma_block_init(u8 dma_num, u8 q_mgr, u8 num_order,
 		goto free_rgn;
 	}
 
+	dma_teardown[dma_num].q_num = q_num;
+	dma_teardown[dma_num].q_mgr = q_mgr;
 	/*
 	 * Push all teardown descriptors to the free teardown queue
 	 * for the CPPI 4.1 system.
@@ -706,12 +712,17 @@ void cppi41_exit(void)
 {
 	int i;
 	for (i = 0; i < CPPI41_NUM_QUEUE_MGR; i++) {
-		if (linking_ram[i].virt_addr != NULL)
-			dma_free_coherent(NULL, 0x10000,
+		if (linking_ram[i].virt_addr != NULL) {
+			dma_free_coherent(NULL, linking_ram[i].size,
 				linking_ram[i].virt_addr,
 				linking_ram[i].phys_addr);
-		if (allocated_queues[i] != NULL)
+			linking_ram[i].virt_addr = 0;
+			linking_ram[i].phys_addr = 0;
+		}
+		if (allocated_queues[i] != NULL) {
 			kfree(allocated_queues[i]);
+			allocated_queues[i] = 0;
+		}
 	}
 	for (i = 0; i < CPPI41_NUM_DMA_BLOCK; i++)
 		if (dma_teardown[i].virt_addr != NULL) {
@@ -720,6 +731,8 @@ void cppi41_exit(void)
 			dma_free_coherent(NULL, dma_teardown[i].rgn_size,
 					dma_teardown[i].virt_addr,
 					dma_teardown[i].phys_addr);
+			dma_teardown[i].virt_addr = 0;
+			dma_teardown[i].phys_addr = 0;
 		}
 }
 EXPORT_SYMBOL(cppi41_exit);
@@ -821,12 +834,13 @@ int cppi41_queue_free(u8 q_mgr, u16 q_num)
 {
 	int index = q_num >> 5, bit = 1 << (q_num & 0x1f);
 
-	if (q_mgr >= cppi41_num_queue_mgr ||
-	    q_num >= cppi41_queue_mgr[q_mgr].num_queue ||
-	    !(allocated_queues[q_mgr][index] & bit))
-		return -EINVAL;
-
-	allocated_queues[q_mgr][index] &= ~bit;
+	if (allocated_queues[q_mgr] != NULL) {
+		if (q_mgr >= cppi41_num_queue_mgr ||
+		    q_num >= cppi41_queue_mgr[q_mgr].num_queue ||
+		    !(allocated_queues[q_mgr][index] & bit))
+			return -EINVAL;
+		allocated_queues[q_mgr][index] &= ~bit;
+	}
 	return 0;
 }
 EXPORT_SYMBOL(cppi41_queue_free);
-- 
1.7.5.4

