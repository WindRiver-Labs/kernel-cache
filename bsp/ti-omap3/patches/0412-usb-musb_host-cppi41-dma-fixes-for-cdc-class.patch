From 1ef9edd7a0a21712e8cb9b658a6d48299c4b6686 Mon Sep 17 00:00:00 2001
From: Ravi B <ravibabu@ti.com>
Date: Wed, 14 Sep 2011 18:24:12 +0530
Subject: [PATCH 412/609] usb: musb_host: cppi41 dma fixes for cdc-class

Original commit: 098bb5d14b967ec29a3e53bc1077f6a9d6cbf45e

  From git://arago-project.org/git/projects/linux-am33x.git
  And ti-sdk-am335x-evm-05.05.00.00-Linux-x86-Install image

Fixes the cppi41 dma issue while configuring rx dma.
Fixes the bug in rx short pkt completion in
musb-host-rx.

Signed-off-by: Ravi B <ravibabu@ti.com>
Signed-off-by: Vaibhav Hiremath <hvaibhav@ti.com>
---
 drivers/usb/musb/cppi41_dma.c |   14 ++++++--------
 drivers/usb/musb/musb_host.c  |    3 ++-
 2 files changed, 8 insertions(+), 9 deletions(-)

diff --git a/drivers/usb/musb/cppi41_dma.c b/drivers/usb/musb/cppi41_dma.c
index 79b7d57..1061453 100644
--- a/drivers/usb/musb/cppi41_dma.c
+++ b/drivers/usb/musb/cppi41_dma.c
@@ -576,15 +576,15 @@ static unsigned cppi41_next_tx_segment(struct cppi41_channel *tx_ch)
 	 * transfer in one PD and one IRQ.  The only time we would NOT want
 	 * to use it is when the hardware constraints prevent it...
 	 */
-	if ((pkt_size & 0x3f) == 0 && length > pkt_size) {
-		num_pds  = 1;
-		pkt_size = length;
+	if ((pkt_size & 0x3f) == 0) {
+		num_pds  = length ? 1 : 0;
 		cppi41_mode_update(tx_ch, USB_GENERIC_RNDIS_MODE);
 	} else {
 		num_pds  = (length + pkt_size - 1) / pkt_size;
 		cppi41_mode_update(tx_ch, USB_TRANSPARENT_MODE);
 	}
 
+	pkt_size = length;
 	/*
 	 * If length of transmit buffer is 0 or a multiple of the endpoint size,
 	 * then send the zero length packet.
@@ -787,18 +787,16 @@ static unsigned cppi41_next_rx_segment(struct cppi41_channel *rx_ch)
 		 * probably fit this transfer in one PD and one IRQ
 		 * (or two with a short packet).
 		 */
-		if ((pkt_size & 0x3f) == 0 && length >= 2 * pkt_size) {
+		if ((pkt_size & 0x3f) == 0) {
 			cppi41_mode_update(rx_ch, USB_GENERIC_RNDIS_MODE);
 			cppi41_autoreq_update(rx_ch, USB_AUTOREQ_ALL_BUT_EOP);
 
-			if (likely(length < 0x10000))
-				pkt_size = length - length % pkt_size;
-			else
-				pkt_size = 0x10000;
+			pkt_size = (length > 0x10000) ? 0x10000 : length;
 			cppi41_set_ep_size(rx_ch, pkt_size);
 		} else {
 			cppi41_mode_update(rx_ch, USB_TRANSPARENT_MODE);
 			cppi41_autoreq_update(rx_ch, USB_NO_AUTOREQ);
+			max_rx_transfer_size = rx_ch->pkt_size;
 		}
 	}
 
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 2b3ff29..d6a5af0 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -1678,7 +1678,8 @@ void musb_host_rx(struct musb *musb, u8 epnum)
 			/* done if urb buffer is full or short packet is recd */
 			done = (urb->actual_length + xfer_len >=
 					urb->transfer_buffer_length
-				|| dma->actual_len < qh->maxpacket);
+				|| dma->actual_len < qh->maxpacket
+				|| dma->actual_len % qh->maxpacket);
 		}
 
 		/* send IN token for next packet, without AUTOREQ */
-- 
1.7.5.4

