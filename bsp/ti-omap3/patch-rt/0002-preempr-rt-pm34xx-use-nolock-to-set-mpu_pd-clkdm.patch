From 85f612088e3c51f126acd6a5fb98c6a2deac4c92 Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Wed, 30 Sep 2015 13:37:12 +0800
Subject: [PATCH] preempr-rt: pm34xx: use nolock to set mpu_pd clkdm

replace the clkdm_deny_idle with clkdm_deny_idle_nolock, it doesn't
need to add a lock to protect the race condition for mpu_pd clkdm,
it is only called in cpuidle driver, the irq is always disabled,
also there isn't irq context to race it, so replace it with
clkdm_deny_idle_nolock, otherwise some calltrace will be occured in
preempt-rt:
$
[<c0017610>] (unwind_backtrace) from [<c0013154>] (show_stack+0x20/0x24)
[<c0013154>] (show_stack) from [<c072fc14>] (dump_stack+0x24/0x28)
[<c072fc14>] (dump_stack) from [<c006ab90>] (__might_sleep+0x108/0x160)
[<c006ab90>] (__might_sleep) from [<c07346bc>] (rt_spin_lock+0x2c/0x6c)
[<c07346bc>] (rt_spin_lock) from [<c0031124>] (pwrdm_lock+0x24/0x28)
[<c0031124>] (pwrdm_lock) from [<c0033144>] (clkdm_deny_idle+0x20/0x34)
[<c0033144>] (clkdm_deny_idle) from [<c002dc14>]
(omap3_enter_idle_bm+0x120/0x23c)
[<c002dc14>] (omap3_enter_idle_bm) from [<c059818c>]
(cpuidle_enter_state+0x50/0xf4)
[<c059818c>] (cpuidle_enter_state) from [<c0598320>]
(cpuidle_idle_call+0xf0/0x2bc)
[<c0598320>] (cpuidle_idle_call) from [<c000fe4c>]
(arch_cpu_idle+0x18/0x48)
[<c000fe4c>] (arch_cpu_idle) from [<c0080388>]
(cpu_startup_entry+0x158/0x2a0)
[<c0080388>] (cpu_startup_entry) from [<c072b5a4>] (rest_init+0x94/0x98)
[<c072b5a4>] (rest_init) from [<c0a17b24>] (start_kernel+0x37c/0x388)

Signed-off-by: czou <cao.zou@windriver.com>
---
 arch/arm/mach-omap2/cpuidle34xx.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/arm/mach-omap2/cpuidle34xx.c b/arch/arm/mach-omap2/cpuidle34xx.c
index e18709d..1a7b04a 100644
--- a/arch/arm/mach-omap2/cpuidle34xx.c
+++ b/arch/arm/mach-omap2/cpuidle34xx.c
@@ -117,7 +117,7 @@ static int omap3_enter_idle(struct cpuidle_device *dev,
 
 	/* Deny idle for C1 */
 	if (cx->flags & OMAP_CPUIDLE_CX_NO_CLKDM_IDLE) {
-		clkdm_deny_idle(mpu_pd->pwrdm_clkdms[0]);
+		clkdm_deny_idle_nolock(mpu_pd->pwrdm_clkdms[0]);
 	} else {
 		pwrdm_set_next_pwrst(mpu_pd, cx->mpu_state);
 		pwrdm_set_next_pwrst(core_pd, cx->core_state);
@@ -143,7 +143,7 @@ static int omap3_enter_idle(struct cpuidle_device *dev,
 
 	/* Re-allow idle for C1 */
 	if (cx->flags & OMAP_CPUIDLE_CX_NO_CLKDM_IDLE)
-		clkdm_allow_idle(mpu_pd->pwrdm_clkdms[0]);
+		clkdm_allow_idle_nolock(mpu_pd->pwrdm_clkdms[0]);
 
 return_sleep_time:
 
-- 
1.9.1

