From 2e85773a733a7c173947e23f9f5e08a83916173e Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 7 Dec 2012 15:49:42 +0800
Subject: [PATCH 1/2] wireless: wl12xx: remove IEEE related codes out of
 spinlock

It is not necessary for wl_lock to protect ieee80211_queue_work() and
related routines from interrupt threads because they are interrupt safe.
If these routines are called within the spinlock, it is possible for
wl12xx to reboot firmware or panic in a preempt-rt kernel (but it can
also happen in any preempt configuration).

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/wireless/wl12xx/main.c |   16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
index a5c79f1..bea5e23 100644
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -999,9 +999,11 @@ out:
 	/* In case TX was not handled here, queue TX work */
 	clear_bit(WL1271_FLAG_TX_PENDING, &wl->flags);
 	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
-	    wl1271_tx_total_queue_count(wl) > 0)
+	    wl1271_tx_total_queue_count(wl) > 0) {
+		spin_unlock_irqrestore(&wl->wl_lock, flags);
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	} else
+		spin_unlock_irqrestore(&wl->wl_lock, flags);
 
 	mutex_unlock(&wl->mutex);
 
@@ -1537,18 +1539,18 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 
 	hlid = wl12xx_tx_get_hlid(wl, wlvif, skb);
 
-	spin_lock_irqsave(&wl->wl_lock, flags);
-
 	/* queue the packet */
 	if (hlid == WL12XX_INVALID_LINK_ID ||
 	    (wlvif && !test_bit(hlid, wlvif->links_map))) {
 		wl1271_debug(DEBUG_TX, "DROP skb hlid %d q %d", hlid, q);
 		ieee80211_free_txskb(hw, skb);
-		goto out;
+		return ;
 	}
 
 	wl1271_debug(DEBUG_TX, "queue skb hlid %d q %d len %d",
 		     hlid, q, skb->len);
+
+	spin_lock_irqsave(&wl->wl_lock, flags);
 	skb_queue_tail(&wl->links[hlid].tx_queue[q], skb);
 
 	wl->tx_queue_count[q]++;
@@ -1563,6 +1565,7 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 		set_bit(q, &wl->stopped_queues_map);
 	}
 
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
 	/*
 	 * The chip specific setup must run before the first TX packet -
 	 * before that, the tx_work will not be initialized!
@@ -1571,9 +1574,6 @@ static void wl1271_op_tx(struct ieee80211_hw *hw, struct sk_buff *skb)
 	if (!test_bit(WL1271_FLAG_FW_TX_BUSY, &wl->flags) &&
 	    !test_bit(WL1271_FLAG_TX_PENDING, &wl->flags))
 		ieee80211_queue_work(wl->hw, &wl->tx_work);
-
-out:
-	spin_unlock_irqrestore(&wl->wl_lock, flags);
 }
 
 int wl1271_tx_dummy_packet(struct wl1271 *wl)
-- 
1.7.9.7

