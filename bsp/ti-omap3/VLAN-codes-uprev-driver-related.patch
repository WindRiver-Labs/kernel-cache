From 80591991b49758b4da266b56be0d68658d8d9d71 Mon Sep 17 00:00:00 2001
From: Wangrui Shen <wangrui.shen@windriver.com>
Date: Mon, 24 Jun 2013 17:54:57 +0800
Subject: [PATCH] VLAN codes uprev driver related

In TI-am335x-sk, VLAN/IPv6 ping failed. After applying
the patch both issues disappear, when DUAL_EMAC disable.

The patch is a series of patches from upstream linux-3.2.0-psp05.06:
git://arago-project.org/git/projects/linux-am33x.git
They are:
0b8bc853 [cpsw: support both silicon versions]
dbb0b6ce [cpsw: remember the silicon version]
41d0a2bf [cpsw: support the HWTSTAMP ioctl and the CPTS]
1a421332 [drivers: net: ethernet: cpsw: add multicast address to ALE]
a867d485 [drivers: net: ethernet: cpsw: add promiscuous support]
0d7d53b7 [cpsw: rename register banks to match the reference manual]
46c9dc5c [net: ethernet: fix kernel OOPS when remove davinci_mdio]

Signed-off-by: Wangrui Shen <wangrui.shen@windriver.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/ti/cpsw.c         |  360 ++++++++++++++++++++++++++------
 drivers/net/ethernet/ti/cpsw_ale.c     |   31 +++-
 drivers/net/ethernet/ti/cpsw_ale.h     |    4 +
 drivers/net/ethernet/ti/davinci_mdio.c |    4 +-
 4 files changed, 329 insertions(+), 70 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 578a93e..ed22311 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -75,6 +75,8 @@ do {								\
 #define CPSW_MINOR_VERSION(reg)		(reg & 0xff)
 #define CPSW_RTL_VERSION(reg)		((reg >> 11) & 0x1f)
 
+#define CPSW_VERSION1		0x19010a
+#define CPSW_VERSION2		0x19010c
 #define CPDMA_RXTHRESH		0x0c0
 #define CPDMA_RXFREE		0x0e0
 #define CPDMA_TXHDP_VER1	0x100
@@ -131,6 +133,83 @@ do {								\
 #define CPSW_RX_TIMER_REQ	5
 #define CPSW_TX_TIMER_REQ	6
 
+/* CPSW_PORT_V1 */
+#define CPSW1_MAX_BLKS      0x00 /* Maximum FIFO Blocks */
+#define CPSW1_BLK_CNT       0x04 /* FIFO Block Usage Count (Read Only) */
+#define CPSW1_TX_IN_CTL     0x08 /* Transmit FIFO Control */
+#define CPSW1_PORT_VLAN     0x0c /* VLAN Register */
+#define CPSW1_TX_PRI_MAP    0x10 /* Tx Header Priority to Switch Pri Mapping */
+#define CPSW1_TS_CTL        0x14 /* Time Sync Control */
+#define CPSW1_TS_SEQ_LTYPE  0x18 /* Time Sync Sequence ID Offset and Msg Type */
+#define CPSW1_TS_VLAN       0x1c /* Time Sync VLAN1 and VLAN2 */
+
+/* CPSW_PORT_V2 */
+#define CPSW2_CONTROL       0x00 /* Control Register */
+#define CPSW2_MAX_BLKS      0x08 /* Maximum FIFO Blocks */
+#define CPSW2_BLK_CNT       0x0c /* FIFO Block Usage Count (Read Only) */
+#define CPSW2_TX_IN_CTL     0x10 /* Transmit FIFO Control */
+#define CPSW2_PORT_VLAN     0x14 /* VLAN Register */
+#define CPSW2_TX_PRI_MAP    0x18 /* Tx Header Priority to Switch Pri Mapping */
+#define CPSW2_TS_SEQ_MTYPE  0x1c /* Time Sync Sequence ID Offset and Msg Type */
+
+/* CPSW_PORT_V1 and V2 */
+#define SA_LO               0x20 /* CPGMAC_SL Source Address Low */
+#define SA_HI               0x24 /* CPGMAC_SL Source Address High */
+#define SEND_PERCENT        0x28 /* Transmit Queue Send Percentages */
+
+/* CPSW_PORT_V2 only */
+#define RX_DSCP_PRI_MAP0    0x30 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP1    0x34 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP2    0x38 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP3    0x3c /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP4    0x40 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP5    0x44 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP6    0x48 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP7    0x4c /* Rx DSCP Priority to Rx Packet Mapping */
+
+/* Bit definitions for the CPSW2_CONTROL register */
+#define PASS_PRI_TAGGED     (1<<24) /* Pass Priority Tagged */
+#define VLAN_LTYPE2_EN      (1<<21) /* VLAN LTYPE 2 enable */
+#define VLAN_LTYPE1_EN      (1<<20) /* VLAN LTYPE 1 enable */
+#define DSCP_PRI_EN         (1<<16) /* DSCP Priority Enable */
+#define TS_320              (1<<14) /* Time Sync Dest Port 320 enable */
+#define TS_319              (1<<13) /* Time Sync Dest Port 319 enable */
+#define TS_132              (1<<12) /* Time Sync Dest IP Addr 132 enable */
+#define TS_131              (1<<11) /* Time Sync Dest IP Addr 131 enable */
+#define TS_130              (1<<10) /* Time Sync Dest IP Addr 130 enable */
+#define TS_129              (1<<9)  /* Time Sync Dest IP Addr 129 enable */
+#define TS_BIT8             (1<<8)  /* ts_ttl_nonzero? */
+#define TS_ANNEX_D_EN       (1<<4)  /* Time Sync Annex D enable */
+#define TS_LTYPE2_EN        (1<<3)  /* Time Sync LTYPE 2 enable */
+#define TS_LTYPE1_EN        (1<<2)  /* Time Sync LTYPE 1 enable */
+#define TS_TX_EN            (1<<1)  /* Time Sync Transmit Enable */
+#define TS_RX_EN            (1<<0)  /* Time Sync Receive Enable */
+
+#define CTRL_TS_BITS \
+	(TS_320 | TS_319 | TS_132 | TS_131 | TS_130 | TS_129 | TS_BIT8 | \
+	 TS_ANNEX_D_EN | TS_LTYPE1_EN)
+
+#define CTRL_ALL_TS_MASK (CTRL_TS_BITS | TS_TX_EN | TS_RX_EN)
+#define CTRL_TX_TS_BITS  (CTRL_TS_BITS | TS_TX_EN)
+#define CTRL_RX_TS_BITS  (CTRL_TS_BITS | TS_RX_EN)
+
+/* Bit definitions for the CPSW2_TS_SEQ_MTYPE register */
+#define TS_SEQ_ID_OFFSET_SHIFT   (16)    /* Time Sync Sequence ID Offset */
+#define TS_SEQ_ID_OFFSET_MASK    (0x3f)
+#define TS_MSG_TYPE_EN_SHIFT     (0)     /* Time Sync Message Type Enable */
+#define TS_MSG_TYPE_EN_MASK      (0xffff)
+
+/* The PTP event messages - Sync, Delay_Req, Pdelay_Req, and Pdelay_Resp. */
+#define EVENT_MSG_BITS ((1<<0) | (1<<1) | (1<<2) | (1<<3))
+
+/* Bit definitions for the CPSW1_TS_CTL register */
+#define CPSW_V1_TS_RX_EN		BIT(0)
+#define CPSW_V1_TS_TX_EN		BIT(4)
+#define CPSW_V1_MSG_TYPE_OFS		16
+
+/* Bit definitions for the CPSW1_TS_SEQ_LTYPE register */
+#define CPSW_V1_SEQ_ID_OFS_SHIFT	16
+
 #ifdef CONFIG_TI_CPSW_DUAL_EMAC
 
 /* Enable VLAN aware mode to add VLAN for induvudual interface */
@@ -212,7 +291,7 @@ static int rx_packet_max = CPSW_MAX_PACKET_SIZE;
 module_param(rx_packet_max, int, 0);
 MODULE_PARM_DESC(rx_packet_max, "maximum receive packet size (bytes)");
 
-struct cpsw_ss_regs {
+struct cpsw_wr_regs {
 	u32	id_ver;
 	u32	soft_reset;
 	u32	control;
@@ -231,7 +310,7 @@ struct cpsw_ss_regs {
 	u32	tx_imax;
 };
 
-struct cpsw_regs {
+struct cpsw_ss_regs {
 	u32	id_ver;
 	u32	control;
 	u32	soft_reset;
@@ -242,19 +321,9 @@ struct cpsw_regs {
 	u32	gap_thresh;
 	u32	tx_start_wds;
 	u32	flow_control;
-};
-
-struct cpsw_slave_regs {
-	u32	max_blks;
-	u32	blk_cnt;
-	u32	flow_thresh;
-	u32	port_vlan;
-	u32	tx_pri_map;
-	u32	ts_ctl;
-	u32	ts_seq_ltype;
-	u32	ts_vlan;
-	u32	sa_lo;
-	u32	sa_hi;
+	u32	vlan_ltype;
+	u32	ts_ltype;
+	u32	dlr_ltype;
 };
 
 struct cpsw_host_regs {
@@ -281,7 +350,7 @@ struct cpsw_sliver_regs {
 };
 
 struct cpsw_slave {
-	struct cpsw_slave_regs __iomem	*regs;
+	void __iomem			*regs;
 	struct cpsw_sliver_regs __iomem	*sliver;
 	int				slave_num;
 	u32				mac_control;
@@ -341,11 +410,12 @@ struct cpsw_priv {
 	struct napi_struct		napi;
 	struct device			*dev;
 	struct cpsw_platform_data	data;
-	struct cpsw_regs __iomem	*regs;
-	struct cpsw_ss_regs __iomem	*ss_regs;
+	struct cpsw_ss_regs __iomem	*regs;
+	struct cpsw_wr_regs __iomem	*wr_regs;
 	struct cpsw_hw_stats __iomem	*hw_stats;
 	struct cpsw_host_regs __iomem	*host_port_regs;
 	u32				msg_enable;
+	u32				version;
 	u32				coal_intvl;
 	u32				bus_freq_mhz;
 	struct net_device_stats		stats;
@@ -365,8 +435,75 @@ struct cpsw_priv {
 };
 
 
+static inline u32 slave_read(struct cpsw_slave *slave, u32 offset)
+{
+	return readl(slave->regs + offset);
+}
+
+static inline void slave_write(struct cpsw_slave *slave, u32 val, u32 offset)
+{
+	writel(val, slave->regs + offset);
+}
+
 #ifdef CONFIG_TI_CPSW_DUAL_EMAC
 
+static void cpsw_ndo_set_rx_mode(struct net_device *ndev)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct cpsw_slave *slave = priv->slaves + priv->emac_port;
+
+	/* Clear all mcast from ALE */
+	cpsw_ale_flush_vlan_multicast(priv->ale, slave->port_vlan,
+			1 << (priv->emac_port + 1) | 1 << priv->host_port);
+
+	if (!netdev_mc_empty(ndev)) {
+		struct netdev_hw_addr *ha;
+
+		/* program multicast address list into ALE register */
+		netdev_for_each_mc_addr(ha, ndev) {
+			cpsw_ale_vlan_add_mcast(priv->ale, (u8 *)ha->addr,
+					1 << (priv->emac_port + 1) |
+					1 << priv->host_port,
+					slave->port_vlan, 0, 0);
+		}
+	}
+}
+
+static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct cpsw_ale *ale = priv->ale;
+
+	if (flags & IFF_PROMISC) {
+		if ((priv->slaves[0].ndev->flags & IFF_PROMISC) ||
+				(priv->slaves[1].ndev->flags & IFF_PROMISC)) {
+			/*
+			 * Enabling promiscuous mode for one interface will be
+			 * common for both the interface as the interface
+			 * shares the same hardware resource.
+			 */
+
+			/* Enable Bypass */
+			cpsw_ale_control_set(ale, 0, ALE_BYPASS, 1);
+
+			dev_err(&ndev->dev, "promiscuity enabled\n");
+		} else {
+			/* Disable Bypass */
+			cpsw_ale_control_set(ale, 0, ALE_BYPASS, 0);
+			dev_err(&ndev->dev, "promiscuity disabled\n");
+		}
+	}
+
+	/*
+	 * The switch cannot filter multicast traffic unless it is configured
+	 * in "VLAN Aware" mode.  Unfortunately, VLAN awareness requires a
+	 * whole bunch of additional logic that this driver does not implement
+	 * at present.
+	 */
+	if ((flags & IFF_ALLMULTI) && !(ndev->flags & IFF_ALLMULTI))
+		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
+}
+
 static inline void cpsw_p0_fifo_type_select(struct cpsw_priv *priv)
 {
 	u32 reg;
@@ -380,7 +517,10 @@ static inline void cpsw_add_dual_emac_mode_default_ale_entries(
 		struct cpsw_priv *priv, struct cpsw_slave *slave,
 		u32 slave_port)
 {
-	writel(slave->port_vlan, &slave->regs->port_vlan);
+	if (priv->version == CPSW_VERSION1)
+		slave_write(slave, slave->port_vlan, CPSW1_PORT_VLAN);
+	else
+		slave_write(slave, slave->port_vlan, CPSW2_PORT_VLAN);
 	cpsw_ale_add_vlan(priv->ale, slave->port_vlan,
 		1 << slave_port | 1 << priv->host_port, 0,
 		1 << slave_port | 1 << priv->host_port,
@@ -423,6 +563,85 @@ static inline int cpsw_tx_packet_submit(struct net_device *ndev,
 
 #else	/* CONFIG_TI_CPSW_DUAL_EMAC */
 
+static void cpsw_ndo_set_rx_mode(struct net_device *ndev)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+
+	/* Clear all mcast from ALE */
+	cpsw_ale_flush_multicast(priv->ale, ALE_ALL_PORTS << priv->host_port);
+
+	if (!netdev_mc_empty(ndev)) {
+		struct netdev_hw_addr *ha;
+
+		/* program multicast address list into ALE register */
+		netdev_for_each_mc_addr(ha, ndev) {
+			cpsw_ale_add_mcast(priv->ale, (u8 *)ha->addr,
+				ALE_ALL_PORTS << priv->host_port, 0, 0);
+		}
+	}
+}
+
+static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+	struct cpsw_ale *ale = priv->ale;
+	int i;
+
+	if (flags & IFF_PROMISC) {
+		if (ndev->flags & IFF_PROMISC) {
+			unsigned long timeout = jiffies + HZ;
+
+			/* Disable Learn for all ports */
+			for (i = 0; i <= priv->data.slaves; i++) {
+				cpsw_ale_control_set(ale, i,
+						     ALE_PORT_NOLEARN, 1);
+				cpsw_ale_control_set(ale, i,
+						     ALE_PORT_NO_SA_UPDATE, 1);
+			}
+
+			/* Clear All Untouched entries */
+			cpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);
+			do {
+				cpu_relax();
+				if (cpsw_ale_control_get(ale, 0, ALE_AGEOUT))
+					break;
+			} while (time_after(timeout, jiffies));
+			cpsw_ale_control_set(ale, 0, ALE_AGEOUT, 1);
+
+			/* Clear all mcast from ALE */
+			cpsw_ale_flush_multicast(ale,
+					ALE_ALL_PORTS << priv->host_port);
+
+			/* Flood All Unicast Packets to Host port */
+			cpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 1);
+			dev_err(&ndev->dev, "promiscuity enabled\n");
+		} else {
+			/* Flood All Unicast Packets to Host port */
+			cpsw_ale_control_set(ale, 0, ALE_P0_UNI_FLOOD, 0);
+
+			/* Enable Learn for all ports */
+			for (i = 0; i <= priv->data.slaves; i++) {
+				cpsw_ale_control_set(ale, i,
+						     ALE_PORT_NOLEARN, 0);
+				cpsw_ale_control_set(ale, i,
+						     ALE_PORT_NO_SA_UPDATE, 0);
+			}
+
+			cpsw_ndo_set_rx_mode(ndev);
+			dev_err(&ndev->dev, "promiscuity disabled\n");
+		}
+	}
+
+	/*
+	 * The switch cannot filter multicast traffic unless it is configured
+	 * in "VLAN Aware" mode.  Unfortunately, VLAN awareness requires a
+	 * whole bunch of additional logic that this driver does not implement
+	 * at present.
+	 */
+	if ((flags & IFF_ALLMULTI) && !(ndev->flags & IFF_ALLMULTI))
+		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
+}
+
 #define cpsw_p0_fifo_type_select(priv)
 #define cpsw_add_dual_emac_mode_default_ale_entries(priv, slave, slave_port)
 #define cpsw_update_slave_open_state(priv, state)
@@ -447,8 +666,8 @@ static int cpsw_set_coalesce(struct net_device *ndev,
 
 static void cpsw_intr_enable(struct cpsw_priv *priv)
 {
-	__raw_writel(0xFF, &priv->ss_regs->tx_en);
-	__raw_writel(0xFF, &priv->ss_regs->rx_en);
+	__raw_writel(0xFF, &priv->wr_regs->tx_en);
+	__raw_writel(0xFF, &priv->wr_regs->rx_en);
 
 	cpdma_ctlr_int_ctrl(priv->dma, true);
 	return;
@@ -456,8 +675,8 @@ static void cpsw_intr_enable(struct cpsw_priv *priv)
 
 static void cpsw_intr_disable(struct cpsw_priv *priv)
 {
-	__raw_writel(0, &priv->ss_regs->tx_en);
-	__raw_writel(0, &priv->ss_regs->rx_en);
+	__raw_writel(0, &priv->wr_regs->tx_en);
+	__raw_writel(0, &priv->wr_regs->rx_en);
 
 	cpdma_ctlr_int_ctrl(priv->dma, false);
 	return;
@@ -593,8 +812,8 @@ static inline void soft_reset(const char *module, void __iomem *reg)
 static void cpsw_set_slave_mac(struct cpsw_slave *slave,
 			       struct cpsw_priv *priv)
 {
-	__raw_writel(mac_hi(priv->mac_addr), &slave->regs->sa_hi);
-	__raw_writel(mac_lo(priv->mac_addr), &slave->regs->sa_lo);
+	slave_write(slave, mac_hi(priv->mac_addr), SA_HI);
+	slave_write(slave, mac_lo(priv->mac_addr), SA_LO);
 }
 
 static void _cpsw_adjust_link(struct cpsw_slave *slave,
@@ -796,7 +1015,10 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 
 	/* setup priority mapping */
 	__raw_writel(RX_PRIORITY_MAPPING, &slave->sliver->rx_pri_map);
-	__raw_writel(TX_PRIORITY_MAPPING, &slave->regs->tx_pri_map);
+	if (priv->version == CPSW_VERSION1)
+		slave_write(slave, 0x33221100, CPSW1_TX_PRI_MAP);
+	else
+		slave_write(slave, 0x33221100, CPSW2_TX_PRI_MAP);
 
 	/* setup max packet size, and mac address */
 	__raw_writel(priv->rx_packet_max, &slave->sliver->rx_maxlen);
@@ -829,8 +1051,17 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 static inline void cpsw_add_default_vlan(struct cpsw_priv *priv)
 {
 	writel(priv->data.default_vlan, &priv->host_port_regs->port_vlan);
-	writel(priv->data.default_vlan, &priv->slaves[0].regs->port_vlan);
-	writel(priv->data.default_vlan, &priv->slaves[1].regs->port_vlan);
+	if (priv->version == CPSW_VERSION1) {
+		slave_write(&priv->slaves[0], priv->data.default_vlan,
+			    CPSW1_PORT_VLAN);
+		slave_write(&priv->slaves[1], priv->data.default_vlan,
+			    CPSW1_PORT_VLAN);
+	} else {
+		slave_write(&priv->slaves[0], priv->data.default_vlan,
+			    CPSW2_PORT_VLAN);
+		slave_write(&priv->slaves[1], priv->data.default_vlan,
+			    CPSW2_PORT_VLAN);
+	}
 	cpsw_ale_add_vlan(priv->ale, priv->data.default_vlan,
 			ALE_ALL_PORTS << priv->host_port,
 			ALE_ALL_PORTS << priv->host_port,
@@ -881,6 +1112,7 @@ static int cpsw_ndo_open(struct net_device *ndev)
 		(*priv->data.phy_control)(true);
 
 	reg = __raw_readl(&priv->regs->id_ver);
+	priv->version = reg;
 
 	cpsw_info(priv, ifup, "initializing cpsw version %d.%d (%d)\n",
 	    (reg >> 8 & 0x7), reg & 0xff, (reg >> 11) & 0x1f);
@@ -1187,6 +1419,7 @@ static int cpsw_config_dump(struct cpsw_priv *priv, u8 *buf, u32 size)
 
 	if (vlan_aware) {
 		int port_vlan;
+		struct cpsw_slave *slave;
 
 		port_state = cpsw_ale_control_get(priv->ale, 0, ALE_PORT_STATE);
 		port_vlan = readl(&priv->host_port_regs->port_vlan);
@@ -1196,14 +1429,22 @@ static int cpsw_config_dump(struct cpsw_priv *priv, u8 *buf, u32 size)
 			port_state_str[port_state]);
 
 		port_state = cpsw_ale_control_get(priv->ale, 1, ALE_PORT_STATE);
-		port_vlan = readl(&priv->slaves[0].regs->port_vlan);
+		slave = &priv->slaves[0];
+		if (priv->version == CPSW_VERSION1)
+			port_vlan = slave_read(slave, CPSW1_PORT_VLAN);
+		else
+			port_vlan = slave_read(slave, CPSW2_PORT_VLAN);
 		out_len += snprintf(buf + out_len, size - out_len,
 			"\t%-8u %-8u %-8u %s\n", 1,
 			port_vlan & 0xfff, (port_vlan > 13) & 0x7,
 			port_state_str[port_state]);
 
 		port_state = cpsw_ale_control_get(priv->ale, 2, ALE_PORT_STATE);
-		port_vlan = readl(&priv->slaves[1].regs->port_vlan);
+		slave = &priv->slaves[1];
+		if (priv->version == CPSW_VERSION1)
+			port_vlan = slave_read(slave, CPSW1_PORT_VLAN);
+		else
+			port_vlan = slave_read(slave, CPSW2_PORT_VLAN);
 		out_len += snprintf(buf + out_len, size - out_len,
 			"\t%-8u %-8u %-8u %s\n", 2,
 			port_vlan & 0xfff, (port_vlan > 13) & 0x7,
@@ -1446,15 +1687,24 @@ static int cpsw_switch_config_ioctl(struct net_device *ndev,
 			if (switchcmd(switch_config).CFI_port)
 				port_vlan |= (1 << 12);
 
-			if (switchcmd(switch_config).port == 0)
+			if (switchcmd(switch_config).port == 0) {
 				writel(port_vlan,
 					&priv->host_port_regs->port_vlan);
-			else if (switchcmd(switch_config).port == 1)
-				writel(port_vlan,
-					&(priv->slaves[0].regs->port_vlan));
-			else
-				writel(port_vlan,
-					&(priv->slaves[1].regs->port_vlan));
+			} else if (switchcmd(switch_config).port == 1) {
+				if (priv->version == CPSW_VERSION1)
+					slave_write(&priv->slaves[0], port_vlan,
+						    CPSW1_PORT_VLAN);
+				else
+					slave_write(&priv->slaves[0], port_vlan,
+						    CPSW2_PORT_VLAN);
+			} else {
+				if (priv->version == CPSW_VERSION1)
+					slave_write(&priv->slaves[1], port_vlan,
+						    CPSW1_PORT_VLAN);
+				else
+					slave_write(&priv->slaves[1], port_vlan,
+						    CPSW2_PORT_VLAN);
+			}
 			ret = 0;
 		} else {
 			dev_err(priv->dev, "Invalid Arguments\n");
@@ -1757,29 +2007,6 @@ static int cpsw_ndo_do_ioctl(struct net_device *ndev, struct ifreq *ifrq,
 	return 0;
 }
 
-static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
-{
-	/*
-	 * The switch cannot operate in promiscuous mode without substantial
-	 * headache.  For promiscuous mode to work, we would need to put the
-	 * ALE in bypass mode and route all traffic to the host port.
-	 * Subsequently, the host will need to operate as a "bridge", learn,
-	 * and flood as needed.  For now, we simply complain here and
-	 * do nothing about it :-)
-	 */
-	if ((flags & IFF_PROMISC) && (ndev->flags & IFF_PROMISC))
-		dev_err(&ndev->dev, "promiscuity ignored!\n");
-
-	/*
-	 * The switch cannot filter multicast traffic unless it is configured
-	 * in "VLAN Aware" mode.  Unfortunately, VLAN awareness requires a
-	 * whole bunch of additional logic that this driver does not implement
-	 * at present.
-	 */
-	if ((flags & IFF_ALLMULTI) && !(ndev->flags & IFF_ALLMULTI))
-		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
-}
-
 static int cpsw_ndo_set_mac_address(struct net_device *ndev, void *p)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
@@ -1921,6 +2148,7 @@ static const struct net_device_ops cpsw_netdev_ops = {
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_tx_timeout		= cpsw_ndo_tx_timeout,
 	.ndo_get_stats		= cpsw_ndo_get_stats,
+	.ndo_set_rx_mode	= cpsw_ndo_set_rx_mode,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= cpsw_ndo_poll_controller,
 #endif
@@ -1991,7 +2219,7 @@ static int cpsw_set_coalesce(struct net_device *ndev,
 
 	coal_intvl = coal->rx_coalesce_usecs;
 
-	int_ctrl =  __raw_readl(&priv->ss_regs->int_control);
+	int_ctrl =  __raw_readl(&priv->wr_regs->int_control);
 	prescale = priv->bus_freq_mhz * 4;
 
 	if (coal_intvl < CPSW_CMINTMIN_INTVL)
@@ -2020,10 +2248,10 @@ static int cpsw_set_coalesce(struct net_device *ndev,
 	int_ctrl |= CPSW_INTPACEEN;
 	int_ctrl &= (~CPSW_INTPRESCALE_MASK);
 	int_ctrl |= (prescale & CPSW_INTPRESCALE_MASK);
-	__raw_writel(int_ctrl, &priv->ss_regs->int_control);
+	__raw_writel(int_ctrl, &priv->wr_regs->int_control);
 
-	__raw_writel(num_interrupts, &priv->ss_regs->rx_imax);
-	__raw_writel(num_interrupts, &priv->ss_regs->tx_imax);
+	__raw_writel(num_interrupts, &priv->wr_regs->rx_imax);
+	__raw_writel(num_interrupts, &priv->wr_regs->tx_imax);
 
 	printk(KERN_INFO"Set coalesce to %d usecs.\n", coal_intvl);
 	priv->coal_intvl = coal_intvl;
@@ -2140,7 +2368,7 @@ static int cpsw_init_slave_emac(struct platform_device *pdev,
 	priv_sl2->host_port_regs = priv->host_port_regs;
 	priv_sl2->hw_stats = priv->hw_stats;
 	priv_sl2->cpsw_ss_res = priv->cpsw_ss_res;
-	priv_sl2->ss_regs = priv->ss_regs;
+	priv_sl2->wr_regs = priv->wr_regs;
 	priv_sl2->dma = priv->dma;
 	priv_sl2->txch = priv->txch;
 	priv_sl2->rxch = priv->rxch;
@@ -2297,7 +2525,7 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 		dev_err(priv->dev, "unable to map i/o region\n");
 		goto clean_cpsw_ss_iores_ret;
 	}
-	priv->ss_regs = regs;
+	priv->wr_regs = regs;
 
 	for_each_slave(priv, cpsw_slave_init, priv);
 	omap_ctrl_writel(CPSW_TIMER_MASK, CPSW_TIMER_CAP_REG);
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index aaa1b31..58fd0ef 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -235,10 +235,10 @@ static void cpsw_ale_flush_mcast(struct cpsw_ale *ale, u32 *ale_entry,
 	mask &= ~port_mask;
 
 	/* free if only remaining port is host port */
-	if (mask == BIT(ale->params.ale_ports))
-		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
-	else
+	if (mask)
 		cpsw_ale_set_port_mask(ale_entry, mask);
+	else
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
 }
 
 int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask)
@@ -265,6 +265,31 @@ int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask)
 	return 0;
 }
 
+void cpsw_ale_flush_vlan_multicast(struct cpsw_ale *ale, u16 vid, int port_mask)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	int ret, idx;
+
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		ret = cpsw_ale_get_entry_type(ale_entry);
+		if (ret != ALE_TYPE_VLAN_ADDR)
+			continue;
+		if (cpsw_ale_get_vlan_id(ale_entry) != vid)
+			continue;
+
+		if (cpsw_ale_get_mcast(ale_entry)) {
+			u8 addr[6];
+
+			cpsw_ale_get_addr(ale_entry, addr);
+			if (!is_broadcast_ether_addr(addr)) {
+				cpsw_ale_flush_mcast(ale, ale_entry, port_mask);
+				cpsw_ale_write(ale, idx, ale_entry);
+			}
+		}
+	}
+}
+
 static void cpsw_ale_flush_ucast(struct cpsw_ale *ale, u32 *ale_entry,
 				 int port_mask)
 {
diff --git a/drivers/net/ethernet/ti/cpsw_ale.h b/drivers/net/ethernet/ti/cpsw_ale.h
index 1b56364..eee949f 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.h
+++ b/drivers/net/ethernet/ti/cpsw_ale.h
@@ -40,6 +40,7 @@ enum cpsw_ale_control {
 	ALE_ENABLE,
 	ALE_CLEAR,
 	ALE_AGEOUT,
+	ALE_P0_UNI_FLOOD,
 	ALE_VLAN_NOLEARN,
 	ALE_NO_PORT_VLAN,
 	ALE_OUI_DENY,
@@ -53,6 +54,7 @@ enum cpsw_ale_control {
 	ALE_PORT_DROP_UNTAGGED,
 	ALE_PORT_DROP_UNKNOWN_VLAN,
 	ALE_PORT_NOLEARN,
+	ALE_PORT_NO_SA_UPDATE,
 	ALE_PORT_UNKNOWN_VLAN_MEMBER,
 	ALE_PORT_UNKNOWN_MCAST_FLOOD,
 	ALE_PORT_UNKNOWN_REG_MCAST_FLOOD,
@@ -107,6 +109,8 @@ int cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control);
 int cpsw_ale_control_set(struct cpsw_ale *ale, int port,
 			 int control, int value);
 int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask);
+void cpsw_ale_flush_vlan_multicast(struct cpsw_ale *ale, u16 vid,
+				   int port_mask);
 int cpsw_ale_dump(struct cpsw_ale *ale, int index, char *buf, int len);
 int cpsw_ale_match_addr(struct cpsw_ale *ale, u8* addr, u16 vid);
 int cpsw_ale_match_vlan(struct cpsw_ale *ale, u16 vid);
diff --git a/drivers/net/ethernet/ti/davinci_mdio.c b/drivers/net/ethernet/ti/davinci_mdio.c
index b5d9fae..ed3b047 100644
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@ -397,8 +397,10 @@ static int __devexit davinci_mdio_remove(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct davinci_mdio_data *data = dev_get_drvdata(dev);
 
-	if (data->bus)
+	if (data->bus) {
+		mdiobus_unregister(data->bus);
 		mdiobus_free(data->bus);
+	}
 
 	if (data->clk)
 		clk_put(data->clk);
-- 
1.7.5.4

