From 9a97d45e07a178c5948c931772e0fe3480a459d0 Mon Sep 17 00:00:00 2001
From: czou <cao.zou@windriver.com>
Date: Tue, 29 Sep 2015 10:20:01 +0800
Subject: [PATCH] tfp410: use workqueue to request the dt gpio for fixing sys

usually omap2fb, connector-dvi and tfp410 has a strict loading
sequence, first tfp410 , second connector-dvi, the last omap2fb,
if connect-dvi and tfp410 is later than omap2fb, connect-dvi and
tfp410 can't register the display sys interface again.

tfp410 doesn't use the soc gpio in some boards, sometime it use
the i2c soc gpio, it will cause the slowly loader for tfp410, it
need to wait for the i2c driver initialization, than it is later
than omap2fb, block the tfp410 initialization is driver wait for
i2c soc gpio ready, so add a system_wq to wait the gpio.

Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/video/omap2/displays-new/encoder-tfp410.c | 57 ++++++++++++++++++-----
 1 file changed, 45 insertions(+), 12 deletions(-)

diff --git a/drivers/video/omap2/displays-new/encoder-tfp410.c b/drivers/video/omap2/displays-new/encoder-tfp410.c
index b4e9a42..e5234f3 100644
--- a/drivers/video/omap2/displays-new/encoder-tfp410.c
+++ b/drivers/video/omap2/displays-new/encoder-tfp410.c
@@ -14,18 +14,24 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/of_gpio.h>
+#include <linux/delay.h>
 
 #include <video/omapdss.h>
 #include <video/omap-panel-data.h>
 
+#define GPIO_RETRY_MAX (3)
+
 struct panel_drv_data {
 	struct omap_dss_device dssdev;
 	struct omap_dss_device *in;
+	struct device *dev;
 
 	int pd_gpio;
 	int data_lines;
 
 	struct omap_video_timings timings;
+	struct delayed_work gpio_wq;
+	int gpio_retry;
 };
 
 #define to_panel_data(x) container_of(x, struct panel_drv_data, dssdev)
@@ -160,6 +166,7 @@ static int tfp410_probe_pdata(struct platform_device *pdev)
 	struct panel_drv_data *ddata = platform_get_drvdata(pdev);
 	struct encoder_tfp410_platform_data *pdata;
 	struct omap_dss_device *dssdev, *in;
+	int r;
 
 	pdata = dev_get_platdata(&pdev->dev);
 
@@ -178,6 +185,14 @@ static int tfp410_probe_pdata(struct platform_device *pdev)
 	dssdev = &ddata->dssdev;
 	dssdev->name = pdata->name;
 
+	if (gpio_is_valid(ddata->pd_gpio)) {
+		r = devm_gpio_request_one(&pdev->dev, ddata->pd_gpio,
+				GPIOF_OUT_INIT_LOW, "tfp410 PD");
+		if (r) {
+			return r;
+		}
+	}
+
 	return 0;
 }
 
@@ -192,6 +207,9 @@ static int tfp410_probe_of(struct platform_device *pdev)
 
 	if (gpio_is_valid(gpio) || gpio == -ENOENT) {
 		ddata->pd_gpio = gpio;
+	} else if (gpio == -EPROBE_DEFER) {
+		dev_info(&pdev->dev, "PD GPIO isn't ready, delay request\n");
+		queue_delayed_work(system_wq, &ddata->gpio_wq, 10 * HZ);
 	} else {
 		dev_err(&pdev->dev, "failed to parse PD gpio\n");
 		return gpio;
@@ -208,6 +226,29 @@ static int tfp410_probe_of(struct platform_device *pdev)
 	return 0;
 }
 
+static void pd_gpio_detect(struct work_struct *work)
+{
+	struct panel_drv_data *data =
+		container_of(to_delayed_work(work), struct panel_drv_data,
+				gpio_wq);
+	struct device_node *node = data->dev->of_node;
+	int r, gpio;
+	gpio = of_get_named_gpio(node, "powerdown-gpios", 0);
+
+	if (gpio_is_valid(gpio) || gpio == -ENOENT) {
+		r = devm_gpio_request_one(data->dev, gpio,
+				GPIOF_OUT_INIT_LOW, "tfp410 PD");
+		if (!r) {
+			data->pd_gpio = gpio;
+		} else {
+			if (data->gpio_retry++ > GPIO_RETRY_MAX)
+				dev_err(data->dev, "error to request PD gpio!\n");
+			else
+				queue_delayed_work(system_wq, &data->gpio_wq, 10 * HZ);
+		}
+	}
+}
+
 static int tfp410_probe(struct platform_device *pdev)
 {
 	struct panel_drv_data *ddata;
@@ -218,8 +260,10 @@ static int tfp410_probe(struct platform_device *pdev)
 	if (!ddata)
 		return -ENOMEM;
 
+	ddata->dev = &pdev->dev;
 	platform_set_drvdata(pdev, ddata);
 
+	INIT_DELAYED_WORK(&ddata->gpio_wq, pd_gpio_detect);
 	if (dev_get_platdata(&pdev->dev)) {
 		r = tfp410_probe_pdata(pdev);
 		if (r)
@@ -232,16 +276,6 @@ static int tfp410_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	if (gpio_is_valid(ddata->pd_gpio)) {
-		r = devm_gpio_request_one(&pdev->dev, ddata->pd_gpio,
-				GPIOF_OUT_INIT_LOW, "tfp410 PD");
-		if (r) {
-			dev_err(&pdev->dev, "Failed to request PD GPIO %d\n",
-					ddata->pd_gpio);
-			goto err_gpio;
-		}
-	}
-
 	dssdev = &ddata->dssdev;
 	dssdev->ops.dvi = &tfp410_dvi_ops;
 	dssdev->dev = &pdev->dev;
@@ -258,8 +292,6 @@ static int tfp410_probe(struct platform_device *pdev)
 
 	return 0;
 err_reg:
-err_gpio:
-	omap_dss_put_device(ddata->in);
 	return r;
 }
 
@@ -269,6 +301,7 @@ static int __exit tfp410_remove(struct platform_device *pdev)
 	struct omap_dss_device *dssdev = &ddata->dssdev;
 	struct omap_dss_device *in = ddata->in;
 
+	cancel_delayed_work(&ddata->gpio_wq);
 	omapdss_unregister_output(&ddata->dssdev);
 
 	WARN_ON(omapdss_device_is_enabled(dssdev));
-- 
1.9.1

