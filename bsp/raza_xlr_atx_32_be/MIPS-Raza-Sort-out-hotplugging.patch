From 25ff6b97c68d1d7fd58e614506c91cf5b8700604 Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf.baechle@windriver.com>
Date: Fri, 14 Aug 2009 03:19:01 +0100
Subject: [PATCH] MIPS: Raza: Sort out hotplugging.

The default behaviour of the kernel isn't good enough for the snapshotting
code.  Iow, this patch is a prerequisite for live snapshots.

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
---
 arch/mips/Kconfig           |    1 +
 arch/mips/rmi/phoenix/irq.c |   34 +++++++++++++++-
 arch/mips/rmi/phoenix/smp.c |   95 ++++++++++++++++++++++++++++++++++---------
 3 files changed, 109 insertions(+), 21 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 915392d..187c80d 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -614,6 +614,7 @@ config RMI_PTR
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_EDAC
 	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select ZONE_DMA if 64BIT
 	select DMA_COHERENT
         select SYS_SUPPORTS_64BIT_KERNEL if EXPERIMENTAL
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index 0219ab1..940c688 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -413,7 +413,7 @@ void __init init_phoenix_irqs(void)
 
 extern void on_chip_shutoff_msgring(void);
 
-void __init phoenix_smp_init(void)
+void __cpuinit phoenix_smp_init(void)
 {
 	/* Set up kseg0 to be cachable coherent */
 	change_c0_config(CONF_CM_CMASK, _page_cachable_default >> _CACHE_SHIFT);
@@ -523,3 +523,35 @@ asmlinkage void plat_irq_dispatch(void)
 	else
 		do_IRQ(irq);
 }
+
+#ifdef CONFIG_HOTPLUG_CPU
+void fixup_irqs(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned int irq, cpu = smp_processor_id();
+	cpumask_t mask0 = cpumask_of_cpu(0);
+	cpumask_t mycpu = cpumask_of_cpu(cpu);
+	uint32_t hw0_mask, my_mask, hw_mask;
+	unsigned long flags;
+
+	hw0_mask = phoenix_smp_logical_to_hw_mask((uint32_t)(mask0.bits[0]));
+	my_mask = phoenix_smp_logical_to_hw_mask((uint32_t)(mycpu.bits[0]));
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+	for (irq = 0; irq < 63; irq++) {
+		if (!PIC_IRQ_IS_IRT(irq))
+			continue;
+
+		hw_mask = phoenix_read_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE);
+		if (!hw_mask)
+			continue;
+
+		hw_mask &= ~my_mask;
+		if (!hw_mask)
+			hw_mask |= hw0_mask;
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, hw_mask);
+
+	}
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+#endif
diff --git a/arch/mips/rmi/phoenix/smp.c b/arch/mips/rmi/phoenix/smp.c
index e42e2f6..7559b52 100644
--- a/arch/mips/rmi/phoenix/smp.c
+++ b/arch/mips/rmi/phoenix/smp.c
@@ -55,6 +55,7 @@ extern void phoenix_smp_time_init(void);
 
 static int phoenix_ipi_stats[NR_CPUS];
 static uint32_t phoenix_logical_hi_mask = 0;
+extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 
 static void phoenix_send_ipi_single(int logical_cpu, unsigned int action)
 {
@@ -181,7 +182,7 @@ extern void asmlinkage smp_bootstrap(void);
 /* 
  * Boot all other cpus in the system, initialize them, and
  * bring them into the boot fn 
-*/
+ */
 void phoenix_boot_secondary(int logical_cpu, struct task_struct *idle)
 {
 	unsigned long gp = (unsigned long)task_thread_info(idle);
@@ -207,8 +208,8 @@ unsigned int fast_syscall_cpumask_phy = 0x1;
 
 void __init phoenix_smp_setup(void)
 {
-	int num_cpus = 1;
-	int i=0, j=0;
+	int num_cpus;
+	int i, j;
 
 	__u32 boot_cpu_online_map = 0, boot_cpu = 0x0;
 
@@ -218,44 +219,43 @@ void __init phoenix_smp_setup(void)
 	cpus_clear(cpu_possible_map);
 
 	/* Initialize the ipi debug stat variables */
-	for(i=0;i<NR_CPUS;i++) {
-		for(j=0;j<NR_CPUS;j++)
+	for (i = 0; i < NR_CPUS; i++) {
+		for (j = 0; j < NR_CPUS; j++)
 			ipi_3_counter_tx[i][j] = 0;
   
 		ipi_3_counter_rx[i] = 0;
 	}
 
-	if(xlr_loader_support) {
+	if (xlr_loader_support)
 		smp_boot.online_map &= ~phnx_loader_mask;
-	}
 
 	boot_cpu_online_map = smp_boot.online_map;
 	printk("(PROM) CPU present map: %x\n", boot_cpu_online_map);
 
 	/* 
 	 * 0th entry in the logical_map should be the bootcpu and all
-     * others proceeds after that
+	 * others proceeds after that
 	 * Fill the entries for boot cpu 
-	*/
+	 */
 	boot_cpu_online_map &= (~(1 << boot_cpu));
 	cpu_set(boot_cpu, phys_cpu_present_map);
 	__cpu_number_map[boot_cpu] = 0;
 	__cpu_logical_map[0] = boot_cpu;
 	cpu_set(0, cpu_possible_map);
 
-	for(i = 0;i<NR_CPUS;i++) {
-		if (boot_cpu_online_map & (1<<i)) {
-			cpu_set(i, phys_cpu_present_map);
+	num_cpus = 1;
+	for (i = 0; i < NR_CPUS; i++) {
+		if (boot_cpu_online_map & (1 << i)) {
+			cpu_set(num_cpus, cpu_possible_map);
+			cpu_set(num_cpus, cpu_present_map);
 			__cpu_number_map[i] = num_cpus;
 			__cpu_logical_map[num_cpus] = i;
-			cpu_set(num_cpus, cpu_possible_map);
-			++num_cpus;
+			num_cpus++;
 		}
 	}
 
-	for(i = boot_cpu+1; i < NR_CPUS; i++) {
+	for (i = boot_cpu + 1; i < NR_CPUS; i++)
 		phoenix_logical_hi_mask |= (1 << i);
-	}
 
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
 
@@ -288,22 +288,77 @@ void phoenix_prepare_cpus(unsigned int max_cpus)
 {
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+
+extern void fixup_irqs(void);
+
+static DEFINE_SPINLOCK(smp_reserve_lock);
+
+static int phoenix_cpu_disable(void)
+{
+	unsigned int cpu = smp_processor_id();
+
+	if (cpu == 0)
+		return -EBUSY;
+
+	spin_lock(&smp_reserve_lock);
+
+	cpu_clear(cpu, cpu_online_map);
+	cpu_clear(cpu, cpu_callin_map);
+	local_irq_disable();
+	fixup_irqs();
+	local_irq_enable();
+
+	flush_cache_all();
+	local_flush_tlb_all();
+
+	spin_unlock(&smp_reserve_lock);
+
+	return 0;
+}
+
+static void phoenix_cpu_die(unsigned int cpu)
+{
+	while (smp_boot.boot_info[cpu].ready)
+		cpu_relax();
+}
+
+void play_dead(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct smp_boot_info_percpu *bic;
+
+	bic = smp_boot.boot_info + cpu;
+	idle_task_exit();
+	bic->ready = 0;
+
+	local_irq_disable();
+	while (!bic->ready)
+		cpu_relax();
+
+	ptr_smp_boot(bic->fn, bic->sp, bic->gp);
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
 struct plat_smp_ops phoenix_smp_ops = {
 	.send_ipi_single	= phoenix_send_ipi_single,
 	.send_ipi_mask		= phoenix_send_ipi_mask,
 	.init_secondary		= phoenix_init_secondary,
-	.smp_finish			= phoenix_smp_finish,
-	.cpus_done			= phoenix_cpus_done,
+	.smp_finish		= phoenix_smp_finish,
+	.cpus_done		= phoenix_cpus_done,
 	.boot_secondary		= phoenix_boot_secondary,
-	.smp_setup			= phoenix_smp_setup,
+	.smp_setup		= phoenix_smp_setup,
 	.prepare_cpus		= phoenix_prepare_cpus,
+#ifdef CONFIG_HOTPLUG_CPU
+	.cpu_disable		= phoenix_cpu_disable,
+	.cpu_die		= phoenix_cpu_die,
+#endif
 };
 
 
 static spinlock_t smp_boot_lock = SPIN_LOCK_UNLOCKED;
 extern unsigned long phnx_ebase;
 extern void prom_reconfigure_thr_resources(void);
-extern void ptr_smp_boot(unsigned long, unsigned long, unsigned long);
 
 void prom_boot_cpus_secondary(void *args)
 {
-- 
1.6.0.4

