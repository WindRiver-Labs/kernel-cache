From 6c61b98f73ad49f4940ae81186d6cd99de048b1d Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Sat, 11 Jul 2009 17:05:15 -0400
Subject: [PATCH] RMI/kexec: Add support for 64-bit parameters to kernel

The RMI bootloader passes 32-bit parameters in the kseg0 segement.
However, kexec has to put the parameters somewhere in kernel memory
which is referenced by 64-bit xkphys addresses.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/mips/rmi/ptr/setup.c |   21 +++++++++++++++++++--
 1 files changed, 19 insertions(+), 2 deletions(-)

diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
index 41a5a31..9542fad 100644
--- a/arch/mips/rmi/ptr/setup.c
+++ b/arch/mips/rmi/ptr/setup.c
@@ -1295,9 +1295,21 @@ void __init prom_init(void)
 	void (*wakeup)(void *, void *, __u32);
 	__u32 wakeup_mask;
 
-    temp = (int)fw_arg1;
+	/* Normally, when booting from the bootloader, the addresses passed are
+	 * in the 32-bit kseg0 segment (ie. 0xffffffff8xxxxxxx). However, when
+	 * coming in from a kexec call, they are actually 64-bit living in the
+	 * xkphys 0xa800000000000000 segment. Find out where we're from.
+	 */
+	if(((fw_arg1 >> 56) & 0xff) == 0xa8) {
+		temp = (long)fw_arg1;
+	} else {
+		temp = (int)fw_arg1;
+	}
     argv = (char **)temp;
 
+	/* envp doesn't seem to be used... kexec always passes in a NULL pointer,
+	 * so we don't have to look for a pointer in the xkphys segment
+	 */
     temp = (int)fw_arg2;
     envp = (char **)temp;
 
@@ -1319,7 +1331,12 @@ void __init prom_init(void)
 	if(dev_tree_en) {
 		prom_info = &prom_info_copy;
 	} else {
-	    temp = (int)fw_arg3;
+		/* see comment above for fw_arg1 */
+		if(((fw_arg3 >> 56) & 0xff) == 0xa8) {
+			temp = (long)fw_arg3;
+		} else {
+			temp = (int)fw_arg3;
+		}
     	prom_info = &prom_info_copy;
 		t_prom_info = (struct psb_info *)temp;
 	    memcpy((void *)prom_info, (void *)t_prom_info, sizeof(struct psb_info));
-- 
1.6.0.4

