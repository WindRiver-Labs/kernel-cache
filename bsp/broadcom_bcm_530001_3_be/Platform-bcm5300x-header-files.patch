From 1424ea40858bb3bd81a757eafaea1c5580e11514 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Sun, 6 Jun 2010 14:21:25 +0800
Subject: [PATCH 17/21] Platform bcm5300x header files

Add header files for bcm5300x

Source: from broadcom SDK

Signed-off-by: Liu Changhui <changhui.liu@windriver.com>
---
 include/asm-mips/bcmsi/aidmp.h          |  368 ++++++++
 include/asm-mips/bcmsi/bcmdefs.h        |  221 +++++
 include/asm-mips/bcmsi/bcmdevs.h        |  495 ++++++++++
 include/asm-mips/bcmsi/bcmendian.h      |  199 +++++
 include/asm-mips/bcmsi/bcmenetmib.h     |   94 ++
 include/asm-mips/bcmsi/bcmenetphy.h     |   92 ++
 include/asm-mips/bcmsi/bcmenetrxh.h     |   54 ++
 include/asm-mips/bcmsi/bcmgmacrxh.h     |   57 ++
 include/asm-mips/bcmsi/bcmnvram.h       |  184 ++++
 include/asm-mips/bcmsi/bcmotp.h         |   59 ++
 include/asm-mips/bcmsi/bcmsrom.h        |   50 +
 include/asm-mips/bcmsi/bcmsrom_fmt.h    |  329 +++++++
 include/asm-mips/bcmsi/bcmsrom_tbl.h    |  371 ++++++++
 include/asm-mips/bcmsi/bcmstdlib.h      |  110 +++
 include/asm-mips/bcmsi/bcmutils.h       |  634 +++++++++++++
 include/asm-mips/bcmsi/cfe_api.h        |  212 +++++
 include/asm-mips/bcmsi/cfe_error.h      |  120 +++
 include/asm-mips/bcmsi/hndchipc.h       |   47 +
 include/asm-mips/bcmsi/hndcpu.h         |   44 +
 include/asm-mips/bcmsi/hnddma.h         |  191 ++++
 include/asm-mips/bcmsi/hndmips.h        |   60 ++
 include/asm-mips/bcmsi/hndpci.h         |   72 ++
 include/asm-mips/bcmsi/hndpmu.h         |   76 ++
 include/asm-mips/bcmsi/hndsoc.h         |  202 +++++
 include/asm-mips/bcmsi/lib_types.h      |   22 +
 include/asm-mips/bcmsi/linux_osl.h      |  639 +++++++++++++
 include/asm-mips/bcmsi/linuxver.h       |  530 +++++++++++
 include/asm-mips/bcmsi/mips33_core.h    |   60 ++
 include/asm-mips/bcmsi/mips74k_core.h   |   60 ++
 include/asm-mips/bcmsi/mipsinc.h        |  568 ++++++++++++
 include/asm-mips/bcmsi/nicpci.h         |  105 +++
 include/asm-mips/bcmsi/osl.h            |   81 ++
 include/asm-mips/bcmsi/pci_core.h       |  133 +++
 include/asm-mips/bcmsi/pcicfg.h         |  539 +++++++++++
 include/asm-mips/bcmsi/pcie_core.h      |  300 +++++++
 include/asm-mips/bcmsi/proto/802.1d.h   |   51 ++
 include/asm-mips/bcmsi/proto/bcmip.h    |  157 ++++
 include/asm-mips/bcmsi/proto/ethernet.h |  193 ++++
 include/asm-mips/bcmsi/proto/vlan.h     |   65 ++
 include/asm-mips/bcmsi/sbchipc.h        | 1486 +++++++++++++++++++++++++++++++
 include/asm-mips/bcmsi/sbconfig.h       |  283 ++++++
 include/asm-mips/bcmsi/sbhnddma.h       |  306 +++++++
 include/asm-mips/bcmsi/sbmemc.h         |  160 ++++
 include/asm-mips/bcmsi/sbpcmcia.h       |  203 +++++
 include/asm-mips/bcmsi/sbsdram.h        |   89 ++
 include/asm-mips/bcmsi/sbsocram.h       |  109 +++
 include/asm-mips/bcmsi/siutils.h        |  316 +++++++
 include/asm-mips/bcmsi/typedefs.h       |  415 +++++++++
 include/asm-mips/mach-bcm5300x/war.h    |   41 +
 include/asm-mips/mipsregs.h             |   23 +-
 50 files changed, 11274 insertions(+), 1 deletions(-)
 create mode 100644 include/asm-mips/bcmsi/aidmp.h
 create mode 100644 include/asm-mips/bcmsi/bcmdefs.h
 create mode 100644 include/asm-mips/bcmsi/bcmdevs.h
 create mode 100644 include/asm-mips/bcmsi/bcmendian.h
 create mode 100644 include/asm-mips/bcmsi/bcmenetmib.h
 create mode 100644 include/asm-mips/bcmsi/bcmenetphy.h
 create mode 100644 include/asm-mips/bcmsi/bcmenetrxh.h
 create mode 100644 include/asm-mips/bcmsi/bcmgmacrxh.h
 create mode 100644 include/asm-mips/bcmsi/bcmnvram.h
 create mode 100644 include/asm-mips/bcmsi/bcmotp.h
 create mode 100644 include/asm-mips/bcmsi/bcmsrom.h
 create mode 100644 include/asm-mips/bcmsi/bcmsrom_fmt.h
 create mode 100644 include/asm-mips/bcmsi/bcmsrom_tbl.h
 create mode 100644 include/asm-mips/bcmsi/bcmstdlib.h
 create mode 100644 include/asm-mips/bcmsi/bcmutils.h
 create mode 100644 include/asm-mips/bcmsi/cfe_api.h
 create mode 100644 include/asm-mips/bcmsi/cfe_error.h
 create mode 100644 include/asm-mips/bcmsi/hndchipc.h
 create mode 100644 include/asm-mips/bcmsi/hndcpu.h
 create mode 100644 include/asm-mips/bcmsi/hnddma.h
 create mode 100644 include/asm-mips/bcmsi/hndmips.h
 create mode 100644 include/asm-mips/bcmsi/hndpci.h
 create mode 100644 include/asm-mips/bcmsi/hndpmu.h
 create mode 100644 include/asm-mips/bcmsi/hndsoc.h
 create mode 100644 include/asm-mips/bcmsi/lib_types.h
 create mode 100644 include/asm-mips/bcmsi/linux_osl.h
 create mode 100644 include/asm-mips/bcmsi/linuxver.h
 create mode 100644 include/asm-mips/bcmsi/mips33_core.h
 create mode 100644 include/asm-mips/bcmsi/mips74k_core.h
 create mode 100644 include/asm-mips/bcmsi/mipsinc.h
 create mode 100644 include/asm-mips/bcmsi/nicpci.h
 create mode 100644 include/asm-mips/bcmsi/osl.h
 create mode 100644 include/asm-mips/bcmsi/pci_core.h
 create mode 100644 include/asm-mips/bcmsi/pcicfg.h
 create mode 100644 include/asm-mips/bcmsi/pcie_core.h
 create mode 100644 include/asm-mips/bcmsi/proto/802.1d.h
 create mode 100644 include/asm-mips/bcmsi/proto/bcmip.h
 create mode 100644 include/asm-mips/bcmsi/proto/ethernet.h
 create mode 100644 include/asm-mips/bcmsi/proto/vlan.h
 create mode 100644 include/asm-mips/bcmsi/sbchipc.h
 create mode 100644 include/asm-mips/bcmsi/sbconfig.h
 create mode 100644 include/asm-mips/bcmsi/sbhnddma.h
 create mode 100644 include/asm-mips/bcmsi/sbmemc.h
 create mode 100644 include/asm-mips/bcmsi/sbpcmcia.h
 create mode 100644 include/asm-mips/bcmsi/sbsdram.h
 create mode 100644 include/asm-mips/bcmsi/sbsocram.h
 create mode 100644 include/asm-mips/bcmsi/siutils.h
 create mode 100644 include/asm-mips/bcmsi/typedefs.h
 create mode 100644 include/asm-mips/mach-bcm5300x/war.h

diff --git a/include/asm-mips/bcmsi/aidmp.h b/include/asm-mips/bcmsi/aidmp.h
new file mode 100644
index 0000000..75fdc05
--- /dev/null
+++ b/include/asm-mips/bcmsi/aidmp.h
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Broadcom AMBA Interconnect definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_AIDMP_H
+#define	_AIDMP_H
+
+/* Manufacturer Ids */
+#define	MFGID_ARM		0x43b
+#define	MFGID_BRCM		0x4bf
+#define	MFGID_MIPS		0x4a7
+
+/* Componnent Classes */
+#define	CC_SIM			0
+#define	CC_EROM			1
+#define	CC_CORESIGHT		9
+#define	CC_VERIF		0xb
+#define	CC_OPTIMO		0xd
+#define	CC_GEN			0xe
+#define	CC_PRIMECELL		0xf
+
+/* Enumeration ROM registers */
+#define	ER_EROMENTRY		0x000
+#define	ER_REMAPCONTROL		0xe00
+#define	ER_REMAPSELECT		0xe04
+#define	ER_MASTERSELECT		0xe10
+#define	ER_ITCR			0xf00
+#define	ER_ITIP			0xf04
+
+/* Erom entries */
+#define	ER_TAG			0xe
+#define	ER_TAG1			0x6
+#define	ER_VALID		1
+#define	ER_CI			0
+#define	ER_MP			2
+#define	ER_ADD			4
+#define	ER_END			0xe
+#define	ER_BAD			0xffffffff
+
+/* EROM CompIdentA */
+#define	CIA_MFG_MASK		0xfff00000
+#define	CIA_MFG_SHIFT		20
+#define	CIA_CID_MASK		0x000fff00
+#define	CIA_CID_SHIFT		8
+#define	CIA_CCL_MASK		0x000000f0
+#define	CIA_CCL_SHIFT		4
+
+/* EROM CompIdentB */
+#define	CIB_REV_MASK		0xff000000
+#define	CIB_REV_SHIFT		24
+#define	CIB_NSW_MASK		0x00f80000
+#define	CIB_NSW_SHIFT		19
+#define	CIB_NMW_MASK		0x0007c000
+#define	CIB_NMW_SHIFT		14
+#define	CIB_NSP_MASK		0x00003e00
+#define	CIB_NSP_SHIFT		9
+#define	CIB_NMP_MASK		0x000001f0
+#define	CIB_NMP_SHIFT		4
+
+/* EROM MasterPortDesc */
+#define	MPD_MUI_MASK		0x0000ff00
+#define	MPD_MUI_SHIFT		8
+#define	MPD_MP_MASK		0x000000f0
+#define	MPD_MP_SHIFT		4
+
+/* EROM AddrDesc */
+#define	AD_ADDR_MASK		0xfffff000
+#define	AD_SP_MASK		0x00000f00
+#define	AD_SP_SHIFT		8
+#define	AD_ST_MASK		0x000000c0
+#define	AD_ST_SHIFT		6
+#define	AD_ST_SLAVE		0x00000000
+#define	AD_ST_BRIDGE		0x00000040
+#define	AD_ST_SWRAP		0x00000080
+#define	AD_ST_MWRAP		0x000000c0
+#define	AD_SZ_MASK		0x00000030
+#define	AD_SZ_SHIFT		4
+#define	AD_SZ_4K		0x00000000
+#define	AD_SZ_8K		0x00000010
+#define	AD_SZ_16K		0x00000020
+#define	AD_SZ_SZD		0x00000030
+#define	AD_AG32			0x00000008
+#define	AD_ADDR_ALIGN		0x00000fff
+#define	AD_SZ_BASE		0x00001000	/* 4KB */
+
+/* EROM SizeDesc */
+#define	SD_SZ_MASK		0xfffff000
+#define	SD_SG32			0x00000008
+#define	SD_SZ_ALIGN		0x00000fff
+
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+typedef volatile struct _aidmp {
+    uint32 oobselina30;		/* 0x000 */
+    uint32 oobselina74;		/* 0x004 */
+    uint32 PAD[6];
+    uint32 oobselinb30;		/* 0x020 */
+    uint32 oobselinb74;		/* 0x024 */
+    uint32 PAD[6];
+    uint32 oobselinc30;		/* 0x040 */
+    uint32 oobselinc74;		/* 0x044 */
+    uint32 PAD[6];
+    uint32 oobselind30;		/* 0x060 */
+    uint32 oobselind74;		/* 0x064 */
+    uint32 PAD[38];
+    uint32 oobselouta30;	/* 0x100 */
+    uint32 oobselouta74;	/* 0x104 */
+    uint32 PAD[6];
+    uint32 oobseloutb30;	/* 0x120 */
+    uint32 oobseloutb74;	/* 0x124 */
+    uint32 PAD[6];
+    uint32 oobseloutc30;	/* 0x140 */
+    uint32 oobseloutc74;	/* 0x144 */
+    uint32 PAD[6];
+    uint32 oobseloutd30;	/* 0x160 */
+    uint32 oobseloutd74;	/* 0x164 */
+    uint32 PAD[38];
+    uint32 oobsynca;		/* 0x200 */
+    uint32 oobseloutaen;	/* 0x204 */
+    uint32 PAD[6];
+    uint32 oobsyncb;		/* 0x220 */
+    uint32 oobseloutben;	/* 0x224 */
+    uint32 PAD[6];
+    uint32 oobsyncc;		/* 0x240 */
+    uint32 oobseloutcen;	/* 0x244 */
+    uint32 PAD[6];
+    uint32 oobsyncd;		/* 0x260 */
+    uint32 oobseloutden;	/* 0x264 */
+    uint32 PAD[38];
+    uint32 oobaextwidth;	/* 0x300 */
+    uint32 oobainwidth;		/* 0x304 */
+    uint32 oobaoutwidth;	/* 0x308 */
+    uint32 PAD[5];
+    uint32 oobbextwidth;	/* 0x320 */
+    uint32 oobbinwidth;		/* 0x324 */
+    uint32 oobboutwidth;	/* 0x328 */
+    uint32 PAD[5];
+    uint32 oobcextwidth;	/* 0x340 */
+    uint32 oobcinwidth;		/* 0x344 */
+    uint32 oobcoutwidth;	/* 0x348 */
+    uint32 PAD[5];
+    uint32 oobdextwidth;	/* 0x360 */
+    uint32 oobdinwidth;		/* 0x364 */
+    uint32 oobdoutwidth;	/* 0x368 */
+    uint32 PAD[37];
+    uint32 ioctrlset;		/* 0x400 */
+    uint32 ioctrlclear;		/* 0x404 */
+    uint32 ioctrl;		/* 0x408 */
+    uint32 PAD[61];
+    uint32 iostatus;		/* 0x500 */
+    uint32 PAD[127];
+    uint32 ioctrlwidth;		/* 0x700 */
+    uint32 iostatuswidth;	/* 0x704 */
+    uint32 PAD[62];
+    uint32 resetctrl;		/* 0x800 */
+    uint32 resetstatus;		/* 0x804 */
+    uint32 resetreadid;		/* 0x808 */
+    uint32 resetwriteid;	/* 0x80c */
+    uint32 PAD[60];
+    uint32 errlogctrl;		/* 0x900 */
+    uint32 errlogdone;		/* 0x904 */
+    uint32 errlogstatus;	/* 0x908 */
+    uint32 errlogaddrlo;	/* 0x90c */
+    uint32 errlogaddrhi;	/* 0x910 */
+    uint32 errlogid;		/* 0x914 */
+    uint32 errloguser;		/* 0x918 */
+    uint32 errlogflags;		/* 0x91c */
+    uint32 PAD[56];
+    uint32 intstatus;		/* 0xa00 */
+    uint32 PAD[127];
+    uint32 config;		/* 0xe00 */
+    uint32 PAD[63];
+    uint32 itcr;		/* 0xf00 */
+    uint32 PAD[3];
+    uint32 itipooba;		/* 0xf10 */
+    uint32 itipoobb;		/* 0xf14 */
+    uint32 itipoobc;		/* 0xf18 */
+    uint32 itipoobd;		/* 0xf1c */
+    uint32 PAD[4];
+    uint32 itipoobaout;		/* 0xf30 */
+    uint32 itipoobbout;		/* 0xf34 */
+    uint32 itipoobcout;		/* 0xf38 */
+    uint32 itipoobdout;		/* 0xf3c */
+    uint32 PAD[4];
+    uint32 itopooba;		/* 0xf50 */
+    uint32 itopoobb;		/* 0xf54 */
+    uint32 itopoobc;		/* 0xf58 */
+    uint32 itopoobd;		/* 0xf5c */
+    uint32 PAD[4];
+    uint32 itopoobain;		/* 0xf70 */
+    uint32 itopoobbin;		/* 0xf74 */
+    uint32 itopoobcin;		/* 0xf78 */
+    uint32 itopoobdin;		/* 0xf7c */
+    uint32 PAD[4];
+    uint32 itopreset;		/* 0xf90 */
+    uint32 PAD[15];
+    uint32 peripherialid4;	/* 0xfd0 */
+    uint32 peripherialid5;	/* 0xfd4 */
+    uint32 peripherialid6;	/* 0xfd8 */
+    uint32 peripherialid7;	/* 0xfdc */
+    uint32 peripherialid0;	/* 0xfe0 */
+    uint32 peripherialid1;	/* 0xfe4 */
+    uint32 peripherialid2;	/* 0xfe8 */
+    uint32 peripherialid3;	/* 0xfec */
+    uint32 componentid0;	/* 0xff0 */
+    uint32 componentid1;	/* 0xff4 */
+    uint32 componentid2;	/* 0xff8 */
+    uint32 componentid3;	/* 0xffc */
+} aidmp_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* Out-of-band Router registers */
+#define	OOB_BUSCONFIG		0x020
+#define	OOB_STATUSA		0x100
+#define	OOB_STATUSB		0x104
+#define	OOB_STATUSC		0x108
+#define	OOB_STATUSD		0x10c
+#define	OOB_ENABLEA0		0x200
+#define	OOB_ENABLEA1		0x204
+#define	OOB_ENABLEA2		0x208
+#define	OOB_ENABLEA3		0x20c
+#define	OOB_ENABLEB0		0x280
+#define	OOB_ENABLEB1		0x284
+#define	OOB_ENABLEB2		0x288
+#define	OOB_ENABLEB3		0x28c
+#define	OOB_ENABLEC0		0x300
+#define	OOB_ENABLEC1		0x304
+#define	OOB_ENABLEC2		0x308
+#define	OOB_ENABLEC3		0x30c
+#define	OOB_ENABLED0		0x380
+#define	OOB_ENABLED1		0x384
+#define	OOB_ENABLED2		0x388
+#define	OOB_ENABLED3		0x38c
+#define	OOB_ITCR		0xf00
+#define	OOB_ITIPOOBA		0xf10
+#define	OOB_ITIPOOBB		0xf14
+#define	OOB_ITIPOOBC		0xf18
+#define	OOB_ITIPOOBD		0xf1c
+#define	OOB_ITOPOOBA		0xf30
+#define	OOB_ITOPOOBB		0xf34
+#define	OOB_ITOPOOBC		0xf38
+#define	OOB_ITOPOOBD		0xf3c
+
+/* DMP wrapper registers */
+#define	AI_OOBSELINA30		0x000
+#define	AI_OOBSELINA74		0x004
+#define	AI_OOBSELINB30		0x020
+#define	AI_OOBSELINB74		0x024
+#define	AI_OOBSELINC30		0x040
+#define	AI_OOBSELINC74		0x044
+#define	AI_OOBSELIND30		0x060
+#define	AI_OOBSELIND74		0x064
+#define	AI_OOBSELOUTA30		0x100
+#define	AI_OOBSELOUTA74		0x104
+#define	AI_OOBSELOUTB30		0x120
+#define	AI_OOBSELOUTB74		0x124
+#define	AI_OOBSELOUTC30		0x140
+#define	AI_OOBSELOUTC74		0x144
+#define	AI_OOBSELOUTD30		0x160
+#define	AI_OOBSELOUTD74		0x164
+#define	AI_OOBSYNCA		0x200
+#define	AI_OOBSELOUTAEN		0x204
+#define	AI_OOBSYNCB		0x220
+#define	AI_OOBSELOUTBEN		0x224
+#define	AI_OOBSYNCC		0x240
+#define	AI_OOBSELOUTCEN		0x244
+#define	AI_OOBSYNCD		0x260
+#define	AI_OOBSELOUTDEN		0x264
+#define	AI_OOBAEXTWIDTH		0x300
+#define	AI_OOBAINWIDTH		0x304
+#define	AI_OOBAOUTWIDTH		0x308
+#define	AI_OOBBEXTWIDTH		0x320
+#define	AI_OOBBINWIDTH		0x324
+#define	AI_OOBBOUTWIDTH		0x328
+#define	AI_OOBCEXTWIDTH		0x340
+#define	AI_OOBCINWIDTH		0x344
+#define	AI_OOBCOUTWIDTH		0x348
+#define	AI_OOBDEXTWIDTH		0x360
+#define	AI_OOBDINWIDTH		0x364
+#define	AI_OOBDOUTWIDTH		0x368
+#define	AI_IOCTRLSET		0x400
+#define	AI_IOCTRLCLEAR		0x404
+#define	AI_IOCTRL		0x408
+#define	AI_IOSTATUS		0x500
+#define	AI_IOCTRLWIDTH		0x700
+#define	AI_IOSTATUSWIDTH	0x704
+#define	AI_RESETCTRL		0x800
+#define	AI_RESETSTATUS		0x804
+#define	AI_RESETREADID		0x808
+#define	AI_RESETWRITEID		0x80c
+#define	AI_ERRLOGCTRL		0xa00
+#define	AI_ERRLOGDONE		0xa04
+#define	AI_ERRLOGSTATUS		0xa08
+#define	AI_ERRLOGADDRLO		0xa0c
+#define	AI_ERRLOGADDRHI		0xa10
+#define	AI_ERRLOGID		0xa14
+#define	AI_ERRLOGUSER		0xa18
+#define	AI_ERRLOGFLAGS		0xa1c
+#define	AI_INTSTATUS		0xa00
+#define	AI_CONFIG		0xe00
+#define	AI_ITCR			0xf00
+#define	AI_ITIPOOBA		0xf10
+#define	AI_ITIPOOBB		0xf14
+#define	AI_ITIPOOBC		0xf18
+#define	AI_ITIPOOBD		0xf1c
+#define	AI_ITIPOOBAOUT		0xf30
+#define	AI_ITIPOOBBOUT		0xf34
+#define	AI_ITIPOOBCOUT		0xf38
+#define	AI_ITIPOOBDOUT		0xf3c
+#define	AI_ITOPOOBA		0xf50
+#define	AI_ITOPOOBB		0xf54
+#define	AI_ITOPOOBC		0xf58
+#define	AI_ITOPOOBD		0xf5c
+#define	AI_ITOPOOBAIN		0xf70
+#define	AI_ITOPOOBBIN		0xf74
+#define	AI_ITOPOOBCIN		0xf78
+#define	AI_ITOPOOBDIN		0xf7c
+#define	AI_ITOPRESET		0xf90
+#define	AI_PERIPHERIALID4	0xfd0
+#define	AI_PERIPHERIALID5	0xfd4
+#define	AI_PERIPHERIALID6	0xfd8
+#define	AI_PERIPHERIALID7	0xfdc
+#define	AI_PERIPHERIALID0	0xfe0
+#define	AI_PERIPHERIALID1	0xfe4
+#define	AI_PERIPHERIALID2	0xfe8
+#define	AI_PERIPHERIALID3	0xfec
+#define	AI_COMPONENTID0		0xff0
+#define	AI_COMPONENTID1		0xff4
+#define	AI_COMPONENTID2		0xff8
+#define	AI_COMPONENTID3		0xffc
+
+/* resetctrl */
+#define	AIRC_RESET		1
+
+/* config */
+#define	AICFG_OOB		0x00000020
+#define	AICFG_IOS		0x00000010
+#define	AICFG_IOC		0x00000008
+#define	AICFG_TO		0x00000004
+#define	AICFG_ERRL		0x00000002
+#define	AICFG_RST		0x00000001
+
+#endif				/* _AIDMP_H */
diff --git a/include/asm-mips/bcmsi/bcmdefs.h b/include/asm-mips/bcmsi/bcmdefs.h
new file mode 100644
index 0000000..1d13813
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmdefs.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Misc system wide definitions
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef	_bcmdefs_h_
+#define	_bcmdefs_h_
+
+/*
+ * One doesn't need to include this file explicitly, gets included automatically if
+ * typedefs.h is included.
+ */
+
+/* Reclaiming text and data :
+ * The following macros specify special linker sections that can be reclaimed
+ * after a system is considered 'up'.
+ */
+
+
+#ifdef DONGLEBUILD
+
+extern bool bcmreclaimed;
+
+#define BCMATTACHDATA(_data)	__attribute__ ((__section__ (".dataini2." #_data))) _data
+#define BCMATTACHFN(_fn)	__attribute__ ((__section__ (".textini2." #_fn))) _fn
+
+#if defined(BCMRECLAIM)
+#define BCMINITDATA(_data)	__attribute__ ((__section__ (".dataini1." #_data))) _data
+#define BCMINITFN(_fn)		__attribute__ ((__section__ (".textini1." #_fn))) _fn
+#define CONST
+#else
+#define BCMINITDATA(_data)	_data
+#define BCMINITFN(_fn)		_fn
+#define CONST	const
+#endif
+
+#ifdef BCMNODOWN
+#define BCMUNINITFN(_fn)	BCMINITFN(_fn)
+#else
+#define BCMUNINITFN(_fn)	_fn
+#endif
+
+#else				/* DONGLEBUILD */
+
+#define bcmreclaimed 		0
+#define BCMATTACHDATA(_data)	_data
+#define BCMATTACHFN(_fn)	_fn
+#define BCMINITDATA(_data)	_data
+#define BCMINITFN(_fn)		_fn
+#define BCMUNINITFN(_fn)	_fn
+#define CONST	const
+
+#endif				/* DONGLEBUILD */
+
+/* Put some library data/code into ROM to reduce RAM requirements */
+#if defined(BCMROMOFFLOAD)
+#define BCMROMDATA(_data)	__attribute__ ((__section__ (".datarom." #_data))) _data
+#define BCMROMFN(_fn)		__attribute__ ((noinline, long_call)) _fn
+#else
+#define BCMROMDATA(_data)	_data
+#define BCMROMFN(_fn)		_fn
+#endif
+
+/* Bus types */
+#define	SI_BUS			0	/* SOC Interconnenct */
+#define	PCI_BUS			1	/* PCI target */
+#define	PCMCIA_BUS		2	/* PCMCIA target */
+#define SDIO_BUS		3	/* SDIO target */
+#define JTAG_BUS		4	/* JTAG */
+#define USB_BUS			5	/* USB (does not support R/W REG) */
+#define SPI_BUS			6	/* gSPI target */
+#define RPC_BUS			7	/* RPC target */
+
+/* Allows size optimization for single-bus image */
+#ifdef BCMBUSTYPE
+#define BUSTYPE(bus) 	(BCMBUSTYPE)
+#else
+#define BUSTYPE(bus) 	(bus)
+#endif
+
+/* Allows size optimization for SPROM support */
+#if defined(BCMSPROMBUS)
+#define SPROMBUS	(BCMSPROMBUS)
+#elif defined(SI_PCMCIA_SROM)
+#define SPROMBUS	(PCMCIA_BUS)
+#else
+#define SPROMBUS	(PCI_BUS)
+#endif
+
+/* Allows size optimization for single-chip image */
+/* XXX This macro is NOT meant to encourage writing chip-specific code.
+ * Use it only when it is appropriate for example in PMU PLL/CHIP/SWREG
+ * controls and in chip specific workarounds.
+ */
+#ifdef BCMCHIPID
+#define CHIPID(chip)	(BCMCHIPID)
+#else
+#define CHIPID(chip)	(chip)
+#endif
+
+/* Defines for DMA Address Width - Shared between OSL and HNDDMA */
+#define DMADDR_MASK_32 0x0	/* Address mask for 32-bits */
+#define DMADDR_MASK_30 0xc0000000	/* Address mask for 30-bits */
+#define DMADDR_MASK_0  0xffffffff	/* Address mask for 0-bits (hi-part) */
+
+#define	DMADDRWIDTH_30  30	/* 30-bit addressing capability */
+#define	DMADDRWIDTH_32  32	/* 32-bit addressing capability */
+#define	DMADDRWIDTH_63  63	/* 64-bit addressing capability */
+#define	DMADDRWIDTH_64  64	/* 64-bit addressing capability */
+
+/* packet headroom necessary to accomodate the largest header in the system, (i.e TXOFF).
+ * By doing, we avoid the need  to allocate an extra buffer for the header when bridging to WL.
+ * There is a compile time check in wlc.c which ensure that this value is at least as big
+ * as TXOFF. This value is used in dma_rxfill (hnddma.c).
+ */
+#define BCMEXTRAHDROOM 160
+
+/* Headroom required for dongle-to-host communication.  Packets allocated
+ * locally in the dongle (e.g. for CDC ioctls or RNDIS messages) should
+ * leave this much room in front for low-level message headers which may
+ * be needed to get across the dongle bus to the host.  (These messages
+ * don't go over the network, so room for the full WL header above would
+ * be a waste.).
+ */
+#ifdef BCMUSBDEV
+#define BCMDONGLEHDRSZ 0
+#else
+#define BCMDONGLEHDRSZ 12
+#endif
+
+#ifdef BCMDBG
+
+#ifndef BCMDBG_ERR
+#define BCMDBG_ERR
+#endif				/* BCMDBG_ERR */
+
+#ifndef BCMDBG_ASSERT
+#define BCMDBG_ASSERT
+#endif				/* BCMDBG_ASSERT */
+
+#endif				/* BCMDBG */
+
+/* Brett's nifty macros for doing definition and get/set of bitfields
+ * Usage example, e.g. a three-bit field (bits 4-6):
+ *    #define <NAME>_M	BITFIELD_MASK(3)
+ *    #define <NAME>_S	4
+ * ...
+ *    regval = R_REG(osh, &regs->regfoo);
+ *    field = GFIELD(regval, <NAME>);
+ *    regval = SFIELD(regval, <NAME>, 1);
+ *    W_REG(osh, &regs->regfoo, regval);
+ */
+#define BITFIELD_MASK(width) \
+		(((unsigned)1 << (width)) - 1)
+#define GFIELD(val, field) \
+		(((val) >> field ## _S) & field ## _M)
+#define SFIELD(val, field, bits) \
+		(((val) & (~(field ## _M << field ## _S))) | \
+		 ((unsigned)(bits) << field ## _S))
+
+/* define BCMSMALL to remove misc features for memory constrained enviroments */
+#ifdef BCMSMALL
+#undef	BCMSPACE
+#define bcmspace	FALSE	/* if (bcmspace) code is discarded */
+#else
+#define	BCMSPACE
+#define bcmspace	TRUE	/* if (bcmspace) code is retained */
+#endif
+
+/* Max. nvram variable table size */
+#define	MAXSZ_NVRAM_VARS	4096	/* XXX should be reduced */
+
+/* How the locator reduces its memory footprint without #ifdef'ing
+ *
+ * The locator uses the weak external symbol feature of the linker
+ * plus the compiler's ability to place each function in a unique
+ * text section to allow wl_locator.c to provide an alternate, typically
+ * trivial, implementation for many functions.
+ *
+ * Many of these routines would normally be static but they must
+ * be external for this technique to work.  Instead of placing these function's
+ * prototypes in a module's public header file and inviting an improper public
+ * usage, use the below LOCATOR_EXTERN macro in the module implementation
+ * file, both on the function declaration and definition.  This will cause
+ * these functions to be static in all builds except locator builds.
+ *
+ * This methodology also allows the optimizer to possibly discard
+ * dead (static) functions in non locator builds as well as provide
+ * more explicit/grep'able documentation of functions used by the
+ * locator in this way.
+ *
+ */
+
+#ifdef WL_LOCATOR
+#define LOCATOR_EXTERN
+#else
+#define LOCATOR_EXTERN static
+#endif
+
+#endif				/* _bcmdefs_h_ */
diff --git a/include/asm-mips/bcmsi/bcmdevs.h b/include/asm-mips/bcmsi/bcmdevs.h
new file mode 100644
index 0000000..2cf01c8
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmdevs.h
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Broadcom device-specific manifest constants.
+ *
+ *  
+ * $Copyright Open Broadcom Corporation$
+ */
+
+#ifndef	_BCMDEVS_H
+#define	_BCMDEVS_H
+
+/* PCI vendor ID's */
+#define	VENDOR_EPIGRAM		0xfeda
+#define	VENDOR_BROADCOM		0x14e4
+#define	VENDOR_3COM		0x10b7
+#define	VENDOR_NETGEAR		0x1385
+#define	VENDOR_DIAMOND		0x1092
+#define	VENDOR_INTEL		0x8086
+#define	VENDOR_DELL		0x1028
+#define	VENDOR_HP		0x103c
+#define	VENDOR_HP_COMPAQ	0x0e11
+#define	VENDOR_APPLE		0x106b
+#define VENDOR_SI_IMAGE		0x1095	/* Silicon Image, used by Arasan SDIO Host */
+#define VENDOR_BUFFALO		0x1154	/* Buffalo vendor id */
+#define VENDOR_TI		0x104c	/* Texas Instruments */
+#define VENDOR_RICOH		0x1180	/* Ricoh */
+#ifdef BCMINTERNAL
+#define VENDOR_JINVANI		0x1947	/* Jinvani Systech, Inc. */
+#endif
+
+/* PCMCIA vendor ID's */
+#define	VENDOR_BROADCOM_PCMCIA	0x02d0
+
+/* SDIO vendor ID's */
+#define	VENDOR_BROADCOM_SDIO	0x00BF
+
+/* DONGLE VID/PIDs */
+#define BCM_DNGL_VID            0xa5c
+#define BCM_DNGL_BL_PID_4328    0xbd12
+#define BCM_DNGL_BL_PID_4322    0xbd13
+#define BCM_DNGL_BDC_PID        0xbdc
+
+/* PCI Device ID's */
+#define	BCM4210_DEVICE_ID	0x1072	/* never used */
+#define	BCM4230_DEVICE_ID	0x1086	/* never used */
+#define	BCM4401_ENET_ID		0x170c	/* 4401b0 production enet cards */
+#define	BCM3352_DEVICE_ID	0x3352	/* bcm3352 device id */
+#define	BCM3360_DEVICE_ID	0x3360	/* bcm3360 device id */
+#define	BCM4211_DEVICE_ID	0x4211
+#define	BCM4231_DEVICE_ID	0x4231
+#define	BCM4303_D11B_ID		0x4303	/* 4303 802.11b */
+#define	BCM4311_D11G_ID		0x4311	/* 4311 802.11b/g id */
+#define	BCM4311_D11DUAL_ID	0x4312	/* 4311 802.11a/b/g id */
+#define	BCM4311_D11A_ID		0x4313	/* 4311 802.11a id */
+#define	BCM4328_D11DUAL_ID	0x4314	/* 4328 802.11a/g id */
+#define	BCM4328_D11G_ID		0x4315	/* 4328 802.11g id */
+#define	BCM4328_D11A_ID		0x4316	/* 4328 802.11a id */
+#define	BCM4318_D11G_ID		0x4318	/* 4318 802.11b/g id */
+#define	BCM4318_D11DUAL_ID	0x4319	/* 4318 802.11a/b/g id */
+#define	BCM4318_D11A_ID		0x431a	/* 4318 802.11a id */
+#define	BCM4325_D11DUAL_ID	0x431b	/* 4325 802.11a/g id */
+#define	BCM4325_D11G_ID		0x431c	/* 4325 802.11g id */
+#define	BCM4325_D11A_ID		0x431d	/* 4325 802.11a id */
+#define	BCM4306_D11G_ID		0x4320	/* 4306 802.11g */
+#define	BCM4306_D11A_ID		0x4321	/* 4306 802.11a */
+#define	BCM4306_UART_ID		0x4322	/* 4306 uart */
+#define	BCM4306_V90_ID		0x4323	/* 4306 v90 codec */
+#define	BCM4306_D11DUAL_ID	0x4324	/* 4306 dual A+B */
+#define	BCM4306_D11G_ID2	0x4325	/* same as BCM4306_D11G_ID; shipped INF
+					 * w/loose binding workaround
+					 */
+#define	BCM4321_D11N_ID		0x4328	/* 4321 802.11n dualband id */
+#define	BCM4321_D11N2G_ID	0x4329	/* 4321 802.11n 2.4Ghz band id */
+#define	BCM4321_D11N5G_ID	0x432a	/* 4321 802.11n 5Ghz band id */
+#define BCM4322_D11N_ID		0x432b	/* 4322 802.11n dualband device */
+#define BCM4322_D11N2G_ID	0x432c	/* 4322 802.11n 2.4GHz device */
+#define BCM4322_D11N5G_ID	0x432d	/* 4322 802.11n 5GHz device */
+#ifdef UNRELEASEDCHIP
+#define BCM4329_D11N_ID		0x432e	/* 4329 802.11n dualband device */
+#define BCM4329_D11N2G_ID	0x432f	/* 4329 802.11n 2.4G device */
+#define BCM4329_D11N5G_ID	0x4330	/* 4329 802.11n 5G device */
+#define BCM4331_D11N_ID		0x4331	/* 4331 802.11n dualband id */
+#define BCM4331_D11N2G_ID	0x4332	/* 4331 802.11n 2.4Ghz band id */
+#define BCM4331_D11N5G_ID	0x4333	/* 4331 802.11n 5Ghz band id */
+#define	BCM4315_D11DUAL_ID	0x4334	/* 4315 802.11a/g id */
+#define	BCM4315_D11G_ID		0x4335	/* 4315 802.11g id */
+#define	BCM4315_D11A_ID		0x4336	/* 4315 802.11a id */
+#define BCM4319_D11N_ID		0x4337	/* 4319 802.11n dualband device */
+#define BCM4319_D11N2G_ID	0x4338	/* 4319 802.11n 2.4G device */
+#define BCM4319_D11N5G_ID	0x4339	/* 4319 802.11n 5G device */
+#endif				/* UNRELEASEDCHIP */
+#define	BCMGPRS_UART_ID		0x4333	/* Uart id used by 4306/gprs card */
+#define	BCMGPRS2_UART_ID	0x4344	/* Uart id used by 4306/gprs card */
+#define FPGA_JTAGM_ID		0x43f0	/* FPGA jtagm device id */
+#define BCM_JTAGM_ID		0x43f1	/* BCM jtagm device id */
+#define SDIOH_FPGA_ID		0x43f2	/* sdio host fpga */
+#define BCM_SDIOH_ID		0x43f3	/* BCM sdio host id */
+#define SDIOD_FPGA_ID		0x43f4	/* sdio device fpga */
+#define SPIH_FPGA_ID		0x43f5	/* PCI SPI Host Controller FPGA */
+#define BCM_SPIH_ID		0x43f6	/* Synopsis SPI Host Controller */
+#define MIMO_FPGA_ID		0x43f8	/* FPGA mimo minimacphy device id */
+#define	BCM4402_ENET_ID		0x4402	/* 4402 enet */
+#define	BCM4402_V90_ID		0x4403	/* 4402 v90 codec */
+#define	BCM4410_DEVICE_ID	0x4410	/* bcm44xx family pci iline */
+#define	BCM4412_DEVICE_ID	0x4412	/* bcm44xx family pci enet */
+#define	BCM4430_DEVICE_ID	0x4430	/* bcm44xx family cardbus iline */
+#define	BCM4432_DEVICE_ID	0x4432	/* bcm44xx family cardbus enet */
+#define	BCM4704_ENET_ID		0x4706	/* 4704 enet (Use 47XX_ENET_ID instead!) */
+#define	BCM4710_DEVICE_ID	0x4710	/* 4710 primary function 0 */
+#define	BCM47XX_AUDIO_ID	0x4711	/* 47xx audio codec */
+#define	BCM47XX_V90_ID		0x4712	/* 47xx v90 codec */
+#define	BCM47XX_ENET_ID		0x4713	/* 47xx enet */
+#define	BCM47XX_EXT_ID		0x4714	/* 47xx external i/f */
+#define	BCM47XX_GMAC_ID		0x4715	/* 47xx Unimac based GbE */
+#define	BCM47XX_USBH_ID		0x4716	/* 47xx usb host */
+#define	BCM47XX_USBD_ID		0x4717	/* 47xx usb device */
+#define	BCM47XX_IPSEC_ID	0x4718	/* 47xx ipsec */
+#define	BCM47XX_ROBO_ID		0x4719	/* 47xx/53xx roboswitch core */
+#define	BCM47XX_USB20H_ID	0x471a	/* 47xx usb 2.0 host */
+#define	BCM47XX_USB20D_ID	0x471b	/* 47xx usb 2.0 device */
+#define	BCM47XX_ATA100_ID	0x471d	/* 47xx parallel ATA */
+#define	BCM47XX_SATAXOR_ID	0x471e	/* 47xx serial ATA & XOR DMA */
+#define	BCM47XX_GIGETH_ID	0x471f	/* 47xx GbE (5700) */
+#define	BCM4712_MIPS_ID		0x4720	/* 4712 base devid */
+#define	BCM4716_DEVICE_ID	0x4722	/* 4716 base devid */
+#define BCM47XX_SMBUS_EMU_ID	0x47fe	/* 47xx emulated SMBus device */
+#define	BCM47XX_XOR_EMU_ID	0x47ff	/* 47xx emulated XOR engine */
+#define	EPI41210_DEVICE_ID	0xa0fa	/* bcm4210 */
+#define	EPI41230_DEVICE_ID	0xa10e	/* bcm4230 */
+#define JINVANI_SDIOH_ID	0x4743	/* Jinvani SDIO Gold Host */
+#define BCM27XX_SDIOH_ID	0x2702	/* BCM27xx Standard SDIO Host */
+#define PCIXX21_FLASHMEDIA_ID	0x803b	/* TI PCI xx21 Standard Host Controller */
+#define PCIXX21_SDIOH_ID	0x803c	/* TI PCI xx21 Standard Host Controller */
+#define R5C822_SDIOH_ID		0x0822	/* Ricoh Co Ltd R5C822 SD/SDIO/MMC/MS/MSPro Host */
+#define BCM53000_GMAC_ID	0x4715
+
+/* Chip ID's */
+#define	BCM4306_CHIP_ID		0x4306	/* 4306 chipcommon chipid */
+#define	BCM4311_CHIP_ID		0x4311	/* 4311 PCIe 802.11a/b/g */
+#define	BCM4312_CHIP_ID		0x4312	/* 4312 chipcommon chipid */
+#ifdef UNRELEASEDCHIP
+#define	BCM4315_CHIP_ID		0x4315	/* 4315 chip id */
+#define	BCM4319_CHIP_ID		0x4319	/* 4319 chip id */
+#endif
+#define	BCM4318_CHIP_ID		0x4318	/* 4318 chipcommon chipid */
+#define	BCM4320_CHIP_ID		0x4320	/* 4320 chipcommon chipid */
+#define	BCM4321_CHIP_ID		0x4321	/* 4321 chipcommon chipid */
+#define	BCM4322_CHIP_ID		0x4322	/* 4322 chipcommon chipid */
+#define	BCM4325_CHIP_ID		0x4325	/* 4325 chip id */
+#define	BCM4328_CHIP_ID		0x4328	/* 4328 chip id */
+#ifdef UNRELEASEDCHIP
+#define	BCM4329_CHIP_ID		0x4329	/* 4329 chipcommon chipid */
+#define	BCM4331_CHIP_ID		0x4331	/* 4331 chipcommon chipid */
+#endif				/* UNRELEASEDCHIP */
+#define	BCM4402_CHIP_ID		0x4402	/* 4402 chipid */
+#define	BCM4704_CHIP_ID		0x4704	/* 4704 chipcommon chipid */
+#define	BCM4710_CHIP_ID		0x4710	/* 4710 chipid */
+#define	BCM4712_CHIP_ID		0x4712	/* 4712 chipcommon chipid */
+#define	BCM4716_CHIP_ID		0x4716	/* 4716 chipcommon chipid */
+#define BCM4785_CHIP_ID		0x4785	/* 4785 chipcommon chipid */
+#define BCM5365_CHIP_ID		0x5365	/* 5365 chipcommon chipid */
+#define	BCM5350_CHIP_ID		0x5350	/* 5350 chipcommon chipid */
+#define	BCM5352_CHIP_ID		0x5352	/* 5352 chipcommon chipid */
+#define	BCM5354_CHIP_ID		0x5354	/* 5354 chipcommon chipid */
+
+#define BCM53000_CHIP_ID            0x5300	/* 53000 chipcommon chipid */
+
+/* Package ID's */
+#define	BCM4303_PKG_ID		2	/* 4303 package id */
+#define	BCM4309_PKG_ID		1	/* 4309 package id */
+#define	BCM4712LARGE_PKG_ID	0	/* 340pin 4712 package id */
+#define	BCM4712SMALL_PKG_ID	1	/* 200pin 4712 package id */
+#define	BCM4712MID_PKG_ID	2	/* 225pin 4712 package id */
+#define BCM4328USBD11G_PKG_ID	2	/* 4328 802.11g USB package id */
+#define BCM4328USBDUAL_PKG_ID	3	/* 4328 802.11a/g USB package id */
+#define BCM4328SDIOD11G_PKG_ID	4	/* 4328 802.11g SDIO package id */
+#define BCM4328SDIODUAL_PKG_ID	5	/* 4328 802.11a/g SDIO package id */
+#define BCM4329_289PIN_PKG_ID	0	/* 4329 289-pin package id */
+#define BCM4329_182PIN_PKG_ID	1	/* 4329N 182-pin package id */
+#define BCM5354E_PKG_ID		1	/* 5354E package id */
+#define HDLSIM5350_PKG_ID	1	/* HDL simulator package id for a 5350 */
+#define HDLSIM_PKG_ID		14	/* HDL simulator package id */
+#define HWSIM_PKG_ID		15	/* Hardware simulator package id */
+
+#define BCM53003_PKG_ID            0	/* 53003 package id */
+#define BCM53001_PKG_ID            1	/* 53001 package id */
+
+
+#define PCIXX21_FLASHMEDIA0_ID	0x8033	/* TI PCI xx21 Standard Host Controller */
+#define PCIXX21_SDIOH0_ID	0x8034	/* TI PCI xx21 Standard Host Controller */
+
+/* boardflags */
+#define	BFL_BTCOEXIST	0x00000001	/* This board implements Bluetooth coexistance */
+#define	BFL_PACTRL	0x00000002	/* This board has gpio 9 controlling the PA */
+#define	BFL_AIRLINEMODE	0x00000004	/* This board implements gpio13 radio disable indication */
+#define	BFL_ADCDIV	0x00000008	/* This board has the rssi ADC divider */
+#define	BFL_ENETROBO	0x00000010	/* This board has robo switch or core */
+#define	BFL_NOPLLDOWN	0x00000020	/* Not ok to power down the chip pll and oscillator */
+#define	BFL_CCKHIPWR	0x00000040	/* Can do high-power CCK transmission */
+#define	BFL_ENETADM	0x00000080	/* This board has ADMtek switch */
+#define	BFL_ENETVLAN	0x00000100	/* This board has vlan capability */
+#ifdef WLAFTERBURNER
+#define	BFL_AFTERBURNER	0x00000200	/* This board supports Afterburner mode */
+#endif				/* WLAFTERBURNER */
+#define BFL_NOPCI		0x00000400	/* This board leaves PCI floating */
+#define BFL_FEM		0x00000800	/* This board supports the Front End Module */
+#define BFL_EXTLNA		0x00001000	/* This board has an external LNA */
+#define BFL_HGPA		0x00002000	/* This board has a high gain PA */
+#define	BFL_BTCMOD	0x00004000	/* This board' BTCOEXIST is in the alternate gpios */
+#define	BFL_ALTIQ	0x00008000	/* Alternate I/Q settings */
+#define BFL_NOPA		0x00010000	/* This board has no PA */
+#define BFL_RSSIINV	0x00020000	/* This board's RSSI uses positive slope(not TSSI) */
+#define BFL_PAREF		0x00040000	/* This board uses the PARef LDO */
+#define BFL_3TSWITCH	0x00080000	/* This board uses a triple throw switch shared with BT */
+#define BFL_PHASESHIFT	0x00100000	/* This board can support phase shifter */
+#define BFL_BUCKBOOST	0x00200000	/* Power topology has BUCKBOOST */
+#define BFL_FEM_BT		0x00400000	/* This board has FEM and switch to share antenna w/ BT */
+#define BFL_NOCBUCK	0x00800000	/* Power topology has no CBUCK */
+#define BFL_CCKFAVOREVM	0x01000000	/* Favor CCK EVM over spectral mask */
+#define BFL_PALDO		0x02000000	/* Power topology has PALDO */
+/* boardflags2 */
+#define BFL2_RXBB_INT_REG_DIS	0x00000001	/* This board has an external rxbb regulator */
+#define BFL2_DEPRECIATED_STUB	0x00000002	/* This board flag is depreciated */
+#define BFL2_TXPWRCTRL_EN	0x00000004	/* This board permits enabling TX Power Control */
+#define BFL2_2X4_DIV		0x00000008	/* This board supports the 2X4 diversity switch */
+#define BFL2_5G_PWRGAIN	0x00000010	/* This board supports 5G band power gain */
+#define BFL2_PCIEWAR_OVR	0x00000020	/* This board overrides ASPM and Clkreq settings */
+#define BFL2_CAESERS_BRD	0x00000040	/* This board is Caesers brd (unused by sw) */
+#define BFL2_BTC3WIRE		0x00000080	/* This board used 3-wire BTC */
+#define BFL2_SKWRKFEM_BRD	0x00000100	/* This board 4321mcm93 uses Skyworks FEM */
+
+/* board specific GPIO assignment, gpio 0-3 are also customer-configurable led */
+#define	BOARD_GPIO_BTC3W_IN		0x850	/* bit 4 is RF_ACTIVE, bit 6 is STATUS, bit 11 is PRI */
+#define	BOARD_GPIO_BTC3W_OUT	0x020	/* bit 5 is TX_CONF */
+#define	BOARD_GPIO_BTCMOD_IN	0x010	/* bit 4 is the alternate BT Coexistance Input */
+#define	BOARD_GPIO_BTCMOD_OUT	0x020	/* bit 5 is the alternate BT Coexistance Out */
+#define	BOARD_GPIO_BTC_IN		0x080	/* bit 7 is BT Coexistance Input */
+#define	BOARD_GPIO_BTC_OUT		0x100	/* bit 8 is BT Coexistance Out */
+#define	BOARD_GPIO_PACTRL		0x200	/* bit 9 controls the PA on new 4306 boards */
+#define	BOARD_GPIO_12			0x1000	/* gpio 12 */
+#define	BOARD_GPIO_13			0x2000	/* gpio 13 */
+
+#define	PCI_CFG_GPIO_SCS	0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
+#define	PCI_CFG_GPIO_HWRAD	0x20	/* PCI config space GPIO 13 for hw radio disable */
+#define	PCI_CFG_GPIO_XTAL	0x40	/* PCI config space GPIO 14 for Xtal powerup */
+#define	PCI_CFG_GPIO_PLL	0x80	/* PCI config space GPIO 15 for PLL powerdown */
+
+/* XXX, need to be moved to a chip specific header file */
+/* power control defines */
+#define	PLL_DELAY			150	/* us pll on delay */
+#define	FREF_DELAY			200	/* us fref change delay */
+#define	MIN_SLOW_CLK		32	/* us Slow clock period */
+#define	XTAL_ON_DELAY		1000	/* us crystal power-on delay */
+
+/* Reference Board Types */
+#define	BU4710_BOARD		0x0400
+#define	VSIM4710_BOARD		0x0401
+#define	QT4710_BOARD		0x0402
+
+#define	BU4309_BOARD		0x040a
+#define	BCM94309CB_BOARD	0x040b
+#define	BCM94309MP_BOARD	0x040c
+#define	BCM4309AP_BOARD		0x040d
+
+#define	BCM94302MP_BOARD	0x040e
+
+#define	BU4306_BOARD		0x0416
+#define	BCM94306CB_BOARD	0x0417
+#define	BCM94306MP_BOARD	0x0418
+
+#define	BCM94710D_BOARD		0x041a
+#define	BCM94710R1_BOARD	0x041b
+#define	BCM94710R4_BOARD	0x041c
+#define	BCM94710AP_BOARD	0x041d
+
+#define	BU2050_BOARD		0x041f
+
+#define	BCM94306P50_BOARD	0x0420
+
+#define	BCM94309G_BOARD		0x0421
+
+#define	BU4704_BOARD		0x0423
+#define	BU4702_BOARD		0x0424
+
+#define	BCM94306PC_BOARD	0x0425	/* pcmcia 3.3v 4306 card */
+
+#define	MPSG4306_BOARD		0x0427
+
+#define	BCM94702MN_BOARD	0x0428
+
+/* BCM4702 1U CompactPCI Board */
+#define	BCM94702CPCI_BOARD	0x0429
+
+/* BCM4702 with BCM95380 VLAN Router */
+#define	BCM95380RR_BOARD	0x042a
+
+/* cb4306 with SiGe PA */
+#define	BCM94306CBSG_BOARD	0x042b
+
+/* cb4306 with SiGe PA */
+#define	PCSG94306_BOARD		0x042d
+
+/* bu4704 with sdram */
+#define	BU4704SD_BOARD		0x042e
+
+/* Dual 11a/11g Router */
+#define	BCM94704AGR_BOARD	0x042f
+
+/* 11a-only minipci */
+#define	BCM94308MP_BOARD	0x0430
+
+/* 4306/gprs combo */
+#define	BCM94306GPRS_BOARD	0x0432
+
+/* BCM5365/BCM4704 FPGA Bringup Board */
+#define BU5365_FPGA_BOARD	0x0433
+
+#define	BU4712_BOARD		0x0444
+#define	BU4712SD_BOARD		0x045d
+#define	BU4712L_BOARD		0x045f
+
+/* BCM4712 boards */
+#define BCM94712AP_BOARD		0x0445
+#define BCM94712P_BOARD		0x0446
+
+/* BCM4318 boards */
+#define BU4318_BOARD		0x0447
+#define CB4318_BOARD		0x0448
+#define MPG4318_BOARD		0x0449
+#define MP4318_BOARD		0x044a
+#define SD4318_BOARD		0x044b
+
+/* BCM63XX boards */
+#define BCM96338_BOARD		0x6338
+#define BCM96348_BOARD		0x6348
+#define BCM96358_BOARD		0x6358
+#define BCM96368_BOARD		0x6368
+
+/* Another mp4306 with SiGe */
+#define	BCM94306P_BOARD		0x044c
+
+/* mp4303 */
+#define	BCM94303MP_BOARD	0x044e
+
+/* mpsgh4306 */
+#define	BCM94306MPSGH_BOARD	0x044f
+
+/* BRCM 4306 w/ Front End Modules */
+#define BCM94306MPM  		0x0450
+#define BCM94306MPL  		0x0453
+
+/* 4712agr */
+#define	BCM94712AGR_BOARD	0x0451
+
+/* pcmcia 4303 */
+#define	PC4303_BOARD		0x0454
+
+/* 5350K */
+#define	BCM95350K_BOARD		0x0455
+
+/* 5350R */
+#define	BCM95350R_BOARD		0x0456
+
+/* 4306mplna */
+#define	BCM94306MPLNA_BOARD	0x0457
+
+/* 4320 boards */
+#define	BU4320_BOARD		0x0458
+#define	BU4320S_BOARD		0x0459
+#define	BCM94320PH_BOARD	0x045a
+
+/* 4306mph */
+#define	BCM94306MPH_BOARD	0x045b
+
+/* 4306pciv */
+#define	BCM94306PCIV_BOARD	0x045c
+
+#define	BU4712SD_BOARD		0x045d
+
+#define	BCM94320PFLSH_BOARD	0x045e
+
+#define	BU4712L_BOARD		0x045f
+#define	BCM94712LGR_BOARD	0x0460
+#define	BCM94320R_BOARD		0x0461
+
+#define	BU5352_BOARD		0x0462
+
+#define	BCM94318MPGH_BOARD	0x0463
+
+#define	BU4311_BOARD		0x0464
+#define	BCM94311MC_BOARD	0x0465
+#define	BCM94311MCAG_BOARD	0x0466
+
+#define	BCM95352GR_BOARD	0x0467
+
+/* bcm95351agr */
+#define	BCM95351AGR_BOARD	0x0470
+
+/* bcm94704mpcb */
+#define	BCM94704MPCB_BOARD	0x0472
+
+/* 4785 boards */
+#define BU4785_BOARD		0x0478
+
+/* 4321 boards */
+#define BU4321_BOARD		0x046b
+#define BU4321E_BOARD		0x047c
+#define MP4321_BOARD		0x046c
+#define CB2_4321_BOARD		0x046d
+#define CB2_4321_AG_BOARD	0x0066
+#define MC4321_BOARD		0x046e
+
+/* 4328 boards */
+#define BU4328_BOARD			0x0481
+#define BCM4328SDG_BOARD		0x0482
+#define BCM4328SDAG_BOARD		0x0483
+#define BCM4328UG_BOARD		0x0484
+#define BCM4328UAG_BOARD		0x0485
+#define BCM4328PC_BOARD		0x0486
+#define BCM4328CF_BOARD		0x0487
+
+/* 4325 boards */
+#define BCM94325DEVBU_BOARD	0x0490
+#define BCM94325BGABU_BOARD	0x0491
+
+/* 4322 boards */
+#define BCM94322MC_SSID		0x04a4
+#define BCM94322U_SSID			0x04a8
+#define BCM94322HM_SSID		0x04b0
+#define BCM94322USB_SSID		0x04a8
+#define BCM94322USB2D_SSID		0x04bf
+
+#define BCM94325SDGMDL_BOARD	0x04aa
+#define BCM94325SDGMDL2_BOARD	0x04c6
+
+/* # of GPIO pins */
+#define GPIO_NUMPINS		16
+
+/* radio ID codes */
+#define	NORADIO_ID			0xe4f5
+#define	NORADIO_IDCODE		0x4e4f5246
+
+#define	BCM2050_ID			0x2050
+#define	BCM2050_IDCODE		0x02050000
+#define	BCM2050A0_IDCODE	0x1205017f
+#define	BCM2050A1_IDCODE	0x2205017f
+#define	BCM2050R8_IDCODE	0x8205017f
+
+#define BCM2055_ID			0x2055
+#define BCM2055_IDCODE		0x02055000
+#define BCM2055A0_IDCODE	0x1205517f
+
+#define BCM2056_ID			0x2056
+#define BCM2056_IDCODE		0x02056000
+#define BCM2056A0_IDCODE	0x1205517f
+
+#define	BCM2060_ID			0x2060
+#define	BCM2060_IDCODE		0x02060000
+#define	BCM2060WW_IDCODE	0x1206017f
+
+#define BCM2062_ID			0x2062
+#define BCM2062_IDCODE		0x02062000
+#define BCM2062A0_IDCODE	0x0206217f
+
+#define BCM2063_ID			0x2063
+#define BCM2063_IDCODE		0x02063000
+#define BCM2063A0_IDCODE	0x0206317f
+
+/* parts of an idcode: */
+#define	IDCODE_MFG_MASK		0x00000fff
+#define	IDCODE_MFG_SHIFT	0
+#define	IDCODE_ID_MASK		0x0ffff000
+#define	IDCODE_ID_SHIFT		12
+#define	IDCODE_REV_MASK		0xf0000000
+#define	IDCODE_REV_SHIFT	28
+
+#endif				/* _BCMDEVS_H */
diff --git a/include/asm-mips/bcmsi/bcmendian.h b/include/asm-mips/bcmsi/bcmendian.h
new file mode 100644
index 0000000..35a65a8
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmendian.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * local version of endian.h - byte order defines
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *   
+*/
+
+#ifndef _BCMENDIAN_H_
+#define _BCMENDIAN_H_
+
+#include "typedefs.h"
+
+/* Byte swap a 16 bit value */
+#define BCMSWAP16(val) \
+	((uint16)(\
+		(((uint16)(val) & (uint16)0x00ffU) << 8) | \
+		(((uint16)(val) & (uint16)0xff00U) >> 8)))
+
+/* Byte swap a 32 bit value */
+#define BCMSWAP32(val) \
+	((uint32)(\
+		(((uint32)(val) & (uint32)0x000000ffUL) << 24) | \
+		(((uint32)(val) & (uint32)0x0000ff00UL) <<  8) | \
+		(((uint32)(val) & (uint32)0x00ff0000UL) >>  8) | \
+		(((uint32)(val) & (uint32)0xff000000UL) >> 24)))
+
+/* 2 Byte swap a 32 bit value */
+#define BCMSWAP32BY16(val) \
+	((uint32)(\
+		(((uint32)(val) & (uint32)0x0000ffffUL) << 16) | \
+		(((uint32)(val) & (uint32)0xffff0000UL) >> 16)))
+
+
+static INLINE uint16 bcmswap16(uint16 val)
+{
+    return BCMSWAP16(val);
+}
+
+static INLINE uint32 bcmswap32(uint32 val)
+{
+    return BCMSWAP32(val);
+}
+
+static INLINE uint32 bcmswap32by16(uint32 val)
+{
+    return BCMSWAP32BY16(val);
+}
+
+/* buf	- start of buffer of shorts to swap */
+/* len  - byte length of buffer */
+static INLINE void bcmswap16_buf(uint16 * buf, uint len)
+{
+    len = len / 2;
+
+    while (len--) {
+	*buf = bcmswap16(*buf);
+	buf++;
+    }
+}
+
+#ifndef	hton16
+#ifndef 	IL_BIGENDIAN
+#define 	HTON16(i) BCMSWAP16(i)
+#define 	hton16(i) bcmswap16(i)
+#define 	hton32(i) bcmswap32(i)
+#define 	ntoh16(i) bcmswap16(i)
+#define	ntoh32(i) bcmswap32(i)
+#define 	ltoh16(i) (i)
+#define 	ltoh32(i) (i)
+#define 	htol16(i) (i)
+#define 	htol32(i) (i)
+#else
+#define 	HTON16(i) (i)
+#define	hton16(i) (i)
+#define	hton32(i) (i)
+#define	ntoh16(i) (i)
+#define	ntoh32(i) (i)
+#define	ltoh16(i) bcmswap16(i)
+#define	ltoh32(i) bcmswap32(i)
+#define 	htol16(i) bcmswap16(i)
+#define 	htol32(i) bcmswap32(i)
+#endif				/* IL_BIGENDIAN */
+#endif				/* hton16 */
+
+#ifndef IL_BIGENDIAN
+#define ltoh16_buf(buf, i)
+#define htol16_buf(buf, i)
+#else
+#define ltoh16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
+#define htol16_buf(buf, i) bcmswap16_buf((uint16*)buf, i)
+#endif				/* IL_BIGENDIAN */
+
+/*
+* store 16-bit value to unaligned little endian byte array.
+*/
+static INLINE void htol16_ua_store(uint16 val, uint8 * bytes)
+{
+    bytes[0] = val & 0xff;
+    bytes[1] = val >> 8;
+}
+
+/*
+* store 32-bit value to unaligned little endian byte array.
+*/
+static INLINE void htol32_ua_store(uint32 val, uint8 * bytes)
+{
+    bytes[0] = val & 0xff;
+    bytes[1] = (val >> 8) & 0xff;
+    bytes[2] = (val >> 16) & 0xff;
+    bytes[3] = val >> 24;
+}
+
+/*
+* store 16-bit value to unaligned network(big) endian byte array.
+*/
+static INLINE void hton16_ua_store(uint16 val, uint8 * bytes)
+{
+    bytes[1] = val & 0xff;
+    bytes[0] = val >> 8;
+}
+
+/*
+* store 32-bit value to unaligned network(big) endian byte array.
+*/
+static INLINE void hton32_ua_store(uint32 val, uint8 * bytes)
+{
+    bytes[3] = val & 0xff;
+    bytes[2] = (val >> 8) & 0xff;
+    bytes[1] = (val >> 16) & 0xff;
+    bytes[0] = val >> 24;
+}
+
+/*
+* load 16-bit value from unaligned little endian byte array.
+*/
+static INLINE uint16 ltoh16_ua(void *bytes)
+{
+    return (((uint8 *) bytes)[1] << 8) + ((uint8 *) bytes)[0];
+}
+
+/*
+* load 32-bit value from unaligned little endian byte array.
+*/
+static INLINE uint32 ltoh32_ua(void *bytes)
+{
+    return (((uint8 *) bytes)[3] << 24) + (((uint8 *) bytes)[2] << 16) +
+	(((uint8 *) bytes)[1] << 8) + ((uint8 *) bytes)[0];
+}
+
+/*
+* load 16-bit value from unaligned big(network) endian byte array.
+*/
+static INLINE uint16 ntoh16_ua(void *bytes)
+{
+    return (((uint8 *) bytes)[0] << 8) + ((uint8 *) bytes)[1];
+}
+
+/*
+* load 32-bit value from unaligned big(network) endian byte array.
+*/
+static INLINE uint32 ntoh32_ua(void *bytes)
+{
+    return (((uint8 *) bytes)[0] << 24) + (((uint8 *) bytes)[1] << 16) +
+	(((uint8 *) bytes)[2] << 8) + ((uint8 *) bytes)[3];
+}
+
+#define ltoh_ua(ptr) (\
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] : \
+	(((uint8 *)ptr)[3]<<24)+(((uint8 *)ptr)[2]<<16)+(((uint8 *)ptr)[1]<<8)+((uint8 *)ptr)[0] \
+)
+
+#define ntoh_ua(ptr) (\
+	sizeof(*(ptr)) == sizeof(uint8) ?  *(uint8 *)ptr : \
+	sizeof(*(ptr)) == sizeof(uint16) ? (((uint8 *)ptr)[0]<<8)+((uint8 *)ptr)[1] : \
+	(((uint8 *)ptr)[0]<<24)+(((uint8 *)ptr)[1]<<16)+(((uint8 *)ptr)[2]<<8)+((uint8 *)ptr)[3] \
+)
+
+#endif				/* _BCMENDIAN_H_ */
diff --git a/include/asm-mips/bcmsi/bcmenetmib.h b/include/asm-mips/bcmsi/bcmenetmib.h
new file mode 100644
index 0000000..f431a5d
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmenetmib.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Hardware-specific MIB definition for
+ * Broadcom Home Networking Division
+ * BCM44XX and BCM47XX 10/100 Mbps Ethernet cores.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _bcmenetmib_h_
+#define _bcmenetmib_h_
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+/*
+ * EMAC MIB Registers
+ */
+typedef volatile struct {
+    uint32 tx_good_octets;
+    uint32 tx_good_pkts;
+    uint32 tx_octets;
+    uint32 tx_pkts;
+    uint32 tx_broadcast_pkts;
+    uint32 tx_multicast_pkts;
+    uint32 tx_len_64;
+    uint32 tx_len_65_to_127;
+    uint32 tx_len_128_to_255;
+    uint32 tx_len_256_to_511;
+    uint32 tx_len_512_to_1023;
+    uint32 tx_len_1024_to_max;
+    uint32 tx_jabber_pkts;
+    uint32 tx_oversize_pkts;
+    uint32 tx_fragment_pkts;
+    uint32 tx_underruns;
+    uint32 tx_total_cols;
+    uint32 tx_single_cols;
+    uint32 tx_multiple_cols;
+    uint32 tx_excessive_cols;
+    uint32 tx_late_cols;
+    uint32 tx_defered;
+    uint32 tx_carrier_lost;
+    uint32 tx_pause_pkts;
+    uint32 PAD[8];
+
+    uint32 rx_good_octets;
+    uint32 rx_good_pkts;
+    uint32 rx_octets;
+    uint32 rx_pkts;
+    uint32 rx_broadcast_pkts;
+    uint32 rx_multicast_pkts;
+    uint32 rx_len_64;
+    uint32 rx_len_65_to_127;
+    uint32 rx_len_128_to_255;
+    uint32 rx_len_256_to_511;
+    uint32 rx_len_512_to_1023;
+    uint32 rx_len_1024_to_max;
+    uint32 rx_jabber_pkts;
+    uint32 rx_oversize_pkts;
+    uint32 rx_fragment_pkts;
+    uint32 rx_missed_pkts;
+    uint32 rx_crc_align_errs;
+    uint32 rx_undersize;
+    uint32 rx_crc_errs;
+    uint32 rx_align_errs;
+    uint32 rx_symbol_errs;
+    uint32 rx_pause_pkts;
+    uint32 rx_nonpause_pkts;
+} bcmenetmib_t;
+
+#endif				/* _bcmenetmib_h_ */
diff --git a/include/asm-mips/bcmsi/bcmenetphy.h b/include/asm-mips/bcmsi/bcmenetphy.h
new file mode 100644
index 0000000..9f5741c
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmenetphy.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Misc Broadcom BCM47XX MDC/MDIO enet phy definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef	_bcmenetphy_h_
+#define	_bcmenetphy_h_
+
+/* phy address */
+#define	MAXEPHY		32	/* mdio phy addresses are 5bit quantities */
+#define	EPHY_MASK	0x1f	/* phy mask */
+#define	EPHY_NONE	31	/* nvram: no phy present at all */
+#define	EPHY_NOREG	30	/* nvram: no local phy regs */
+
+#define	MAXPHYREG	32	/* max 32 registers per phy */
+
+/* just a few phy registers */
+#define	CTL_RESET	(1 << 15)	/* reset */
+#define	CTL_LOOP	(1 << 14)	/* loopback */
+#define	CTL_SPEED	(1 << 13)	/* speed selection lsb 0=10, 1=100 */
+#define	CTL_ANENAB	(1 << 12)	/* autonegotiation enable */
+#define	CTL_RESTART	(1 << 9)	/* restart autonegotiation */
+#define	CTL_DUPLEX	(1 << 8)	/* duplex mode 0=half, 1=full */
+#define	CTL_SPEED_MSB	(1 << 6)	/* speed selection msb */
+
+#define	CTL_SPEED_10	((0 << 6) | (0 << 13))	/* speed selection CTL.6=0, CTL.13=0 */
+#define	CTL_SPEED_100	((0 << 6) | (1 << 13))	/* speed selection CTL.6=0, CTL.13=1 */
+#define	CTL_SPEED_1000	((1 << 6) | (0 << 13))	/* speed selection CTL.6=1, CTL.13=0 */
+
+#define	ADV_10FULL	(1 << 6)	/* autonegotiate advertise 10full */
+#define	ADV_10HALF	(1 << 5)	/* autonegotiate advertise 10half */
+#define	ADV_100FULL	(1 << 8)	/* autonegotiate advertise 100full */
+#define	ADV_100HALF	(1 << 7)	/* autonegotiate advertise 100half */
+
+/* link partner ability register */
+#define LPA_SLCT	0x001f	/* same as advertise selector */
+#define LPA_10HALF	0x0020	/* can do 10mbps half-duplex */
+#define LPA_10FULL	0x0040	/* can do 10mbps full-duplex */
+#define LPA_100HALF	0x0080	/* can do 100mbps half-duplex */
+#define LPA_100FULL	0x0100	/* can do 100mbps full-duplex */
+#define LPA_100BASE4	0x0200	/* can do 100mbps 4k packets */
+#define LPA_RESV	0x1c00	/* unused */
+#define LPA_RFAULT	0x2000	/* link partner faulted */
+#define LPA_LPACK	0x4000	/* link partner acked us */
+#define LPA_NPAGE	0x8000	/* next page bit */
+
+#define LPA_DUPLEX	(LPA_10FULL | LPA_100FULL)
+#define LPA_100		(LPA_100FULL | LPA_100HALF | LPA_100BASE4)
+
+/* 1000BASE-T control register */
+#define	ADV_1000HALF	0x0100	/* advertise 1000BASE-T half duplex */
+#define	ADV_1000FULL	0x0200	/* advertise 1000BASE-T full duplex */
+
+/* 1000BASE-T status register */
+#define	LPA_1000HALF	0x0400	/* link partner 1000BASE-T half duplex */
+#define	LPA_1000FULL	0x0800	/* link partner 1000BASE-T full duplex */
+
+/* 1000BASE-T extended status register */
+#define	EST_1000THALF	0x1000	/* 1000BASE-T half duplex capable */
+#define	EST_1000TFULL	0x2000	/* 1000BASE-T full duplex capable */
+#define	EST_1000XHALF	0x4000	/* 1000BASE-X half duplex capable */
+#define	EST_1000XFULL	0x8000	/* 1000BASE-X full duplex capable */
+
+#define	STAT_REMFAULT	(1 << 4)	/* remote fault */
+#define	STAT_LINK	(1 << 2)	/* link status */
+#define	STAT_JAB	(1 << 1)	/* jabber detected */
+#define	AUX_FORCED	(1 << 2)	/* forced 10/100 */
+#define	AUX_SPEED	(1 << 1)	/* speed 0=10mbps 1=100mbps */
+#define	AUX_DUPLEX	(1 << 0)	/* duplex 0=half 1=full */
+
+#endif				/* _bcmenetphy_h_ */
diff --git a/include/asm-mips/bcmsi/bcmenetrxh.h b/include/asm-mips/bcmsi/bcmenetrxh.h
new file mode 100644
index 0000000..e7d2d32
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmenetrxh.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Hardware-specific Receive Data Header for the
+ * Broadcom Home Networking Division
+ * BCM44XX and BCM47XX 10/100 Mbps Ethernet cores.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _bcmenetrxh_h_
+#define	_bcmenetrxh_h_
+
+/*
+ * The Ethernet MAC core returns an 8-byte Receive Frame Data Header
+ * with every frame consisting of
+ * 16bits of frame length, followed by
+ * 16bits of EMAC rx descriptor info, followed by 32bits of undefined.
+ */
+typedef volatile struct {
+    uint16 len;
+    uint16 flags;
+    uint16 pad[12];
+} bcmenetrxh_t;
+
+#define	RXF_L		((uint16)1 << 11)	/* last buffer in a frame */
+#define	RXF_MISS	((uint16)1 << 7)	/* received due to promisc mode */
+#define	RXF_BRDCAST	((uint16)1 << 6)	/* dest is broadcast address */
+#define	RXF_MULT	((uint16)1 << 5)	/* dest is multicast address */
+#define	RXF_LG		((uint16)1 << 4)	/* frame length > rxmaxlength */
+#define	RXF_NO		((uint16)1 << 3)	/* odd number of nibbles */
+#define	RXF_RXER	((uint16)1 << 2)	/* receive symbol error */
+#define	RXF_CRC		((uint16)1 << 1)	/* crc error */
+#define	RXF_OV		((uint16)1 << 0)	/* fifo overflow */
+
+#endif				/* _bcmenetrxh_h_ */
diff --git a/include/asm-mips/bcmsi/bcmgmacrxh.h b/include/asm-mips/bcmsi/bcmgmacrxh.h
new file mode 100644
index 0000000..43dd982
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmgmacrxh.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Hardware-specific Receive Data Header for the
+ * Broadcom Home Networking Division
+ * BCM47XX GbE cores.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _bcmgmacrxh_h_
+#define	_bcmgmacrxh_h_
+
+/*
+ * The Ethernet GMAC core returns an 8-byte Receive Frame Data Header
+ * with every frame consisting of
+ * 16 bits of frame length, followed by
+ * 16 bits of GMAC rx descriptor info, followed by 32bits of undefined.
+ */
+typedef volatile struct {
+    uint16 len;
+    uint16 flags;
+    uint16 pad[14];
+} bcmgmacrxh_t;
+
+#define	RXHDR_LEN	32	/* Header length */
+
+#define	GRXF_DT_MASK	((uint16)0xf)	/* data type */
+#define	GRXF_DT_SHIFT	12
+#define	GRXF_DC_MASK	((uint16)0xf)	/* (num descr to xfer the frame) - 1 */
+#define	GRXF_DC_SHIFT	8
+#define	GRXF_OVF	((uint16)1 << 7)	/* overflow error occured */
+#define	GRXF_OVERSIZE	((uint16)1 << 2)	/* frame size > rxmaxlength */
+#define	GRXF_CRC	((uint16)1 << 3)	/* crc error */
+#define	GRXF_PT_MASK	((uint16)3)	/* packet type 0 - Unicast,
+					 * 1 - Multicast, 2 - Broadcast
+					 */
+
+#endif				/* _bcmgmacrxh_h_ */
diff --git a/include/asm-mips/bcmsi/bcmnvram.h b/include/asm-mips/bcmsi/bcmnvram.h
new file mode 100644
index 0000000..321e45a
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmnvram.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * NVRAM variable manipulation
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _bcmnvram_h_
+#define _bcmnvram_h_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+
+struct nvram_header {
+    uint32 magic;
+    uint32 len;
+    uint32 crc_ver_init;	/* 0:7 crc, 8:15 ver, 16:31 sdram_init */
+    uint32 config_refresh;	/* 0:15 sdram_config, 16:31 sdram_refresh */
+    uint32 config_ncdl;		/* ncdl values for memc */
+};
+
+struct nvram_tuple {
+    char *name;
+    char *value;
+    struct nvram_tuple *next;
+};
+
+/*
+ * Get default value for an NVRAM variable
+ */
+extern char *nvram_default_get(const char *name);
+
+/*
+ * Initialize NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern int nvram_init(void *sih);
+
+/*
+ * Append a chunk of nvram variables to the global list
+ */
+extern int nvram_append(void *si, char *vars, uint varsz);
+
+/*
+ * Check for reset button press for restoring factory defaults.
+ */
+extern bool nvram_reset(void *sih);
+
+/*
+ * Disable NVRAM access. May be unnecessary or undefined on certain
+ * platforms.
+ */
+extern void nvram_exit(void *sih);
+
+/*
+ * Get the value of an NVRAM variable. The pointer returned may be
+ * invalid after a set.
+ * @param	name	name of variable to get
+ * @return	value of variable or NULL if undefined
+ */
+extern char *nvram_get(const char *name);
+
+/* 
+ * Read the reset GPIO value from the nvram and set the GPIO
+ * as input
+ */
+extern int BCMINITFN(nvram_resetgpio_init) (void *sih);
+
+/* 
+ * Get the value of an NVRAM variable.
+ * @param	name	name of variable to get
+ * @return	value of variable or NUL if undefined
+ */
+#define nvram_safe_get(name) (nvram_get(name) ? : "")
+
+/*
+ * Match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is string equal
+ *		to match or FALSE otherwise
+ */
+static INLINE int nvram_match(char *name, char *match)
+{
+    const char *value = nvram_get(name);
+    return (value && !strcmp(value, match));
+}
+
+/*
+ * Inversely match an NVRAM variable.
+ * @param	name	name of variable to match
+ * @param	match	value to compare against value of variable
+ * @return	TRUE if variable is defined and its value is not string
+ *		equal to invmatch or FALSE otherwise
+ */
+static INLINE int nvram_invmatch(char *name, char *invmatch)
+{
+    const char *value = nvram_get(name);
+    return (value && strcmp(value, invmatch));
+}
+
+/*
+ * Set the value of an NVRAM variable. The name and value strings are
+ * copied into private storage. Pointers to previously set values
+ * may become invalid. The new value may be immediately
+ * retrieved but will not be permanently stored until a commit.
+ * @param	name	name of variable to set
+ * @param	value	value of variable
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_set(const char *name, const char *value);
+
+/*
+ * Unset an NVRAM variable. Pointers to previously set values
+ * remain valid until a set.
+ * @param	name	name of variable to unset
+ * @return	0 on success and errno on failure
+ * NOTE: use nvram_commit to commit this change to flash.
+ */
+extern int nvram_unset(const char *name);
+
+/*
+ * Commit NVRAM variables to permanent storage. All pointers to values
+ * may be invalid after a commit.
+ * NVRAM values are undefined after a commit.
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_commit(void);
+
+/*
+ * Get all NVRAM variables (format name=value\0 ... \0\0).
+ * @param	buf	buffer to store variables
+ * @param	count	size of buffer in bytes
+ * @return	0 on success and errno on failure
+ */
+extern int nvram_getall(char *nvram_buf, int count);
+
+/*
+ * returns the crc value of the nvram
+ * @param	nvh	nvram header pointer
+ */
+uint8 nvram_calc_crc(struct nvram_header *nvh);
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* The NVRAM version number stored as an NVRAM variable */
+#define NVRAM_SOFTWARE_VERSION	"1"
+#define NVRAM_MAGIC		0x48534C46	/* 'FLSH' */
+
+#define NVRAM_CLEAR_MAGIC	0x0
+#define NVRAM_INVALID_MAGIC	0xFFFFFFFF
+#define NVRAM_VERSION		1
+#define NVRAM_HEADER_SIZE	20
+#define NVRAM_SPACE		0x8000
+
+#define NVRAM_MAX_VALUE_LEN 255
+#define NVRAM_MAX_PARAM_LEN 64
+
+#define NVRAM_CRC_START_POSITION	9	/* magic, len, crc8 to be skipped */
+#define NVRAM_CRC_VER_MASK	0xffffff00	/* for crc_ver_init */
+
+#endif				/* _bcmnvram_h_ */
diff --git a/include/asm-mips/bcmsi/bcmotp.h b/include/asm-mips/bcmsi/bcmotp.h
new file mode 100644
index 0000000..99d0ca4
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmotp.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * OTP support.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+/* OTP regions */
+#define OTP_HW_RGN	1
+#define OTP_SW_RGN	2
+#define OTP_CI_RGN	4
+#define OTP_FUSE_RGN	8
+
+#if !defined(BCMDONGLEHOST)
+extern void *otp_init(si_t * sih);
+#endif				/* !defined(BCMDONGLEHOST) */
+
+extern int otp_status(void *oh);
+extern int otp_size(void *oh);
+
+extern int otp_read_region(void *oh, int region, uint16 * data,
+			   uint * wlen);
+extern uint16 otpr(void *oh, chipcregs_t * cc, uint wn);
+extern int otp_nvread(void *oh, char *data, uint * len);
+
+#ifdef BCMNVRAMW
+#if !defined(BCMDONGLEHOST)
+extern int otp_write_region(void *oh, int region, uint16 * data,
+			    uint wlen);
+extern int otp_fix_word16(void *oh, uint wn, uint16 mask, uint16 val);
+extern int otp_write_rde(void *oh, int rde, uint bit, uint val);
+extern int otpw(void *oh, int wn, uint16 data);
+extern int otp_nvwrite(void *oh, uint16 * data, uint wlen);
+#endif				/* !defined(BCMDONGLEHOST) */
+#endif				/* BCMNVRAMW */
+
+#if defined(WLTEST) || defined (BCMINTERNAL)
+extern int otp_dump(void *oh, int arg, char *buf, uint size);
+#endif
diff --git a/include/asm-mips/bcmsi/bcmsrom.h b/include/asm-mips/bcmsi/bcmsrom.h
new file mode 100644
index 0000000..6e83070
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmsrom.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Misc useful routines to access NIC local SROM/OTP .
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_bcmsrom_h_
+#define	_bcmsrom_h_
+
+#include "bcmsrom_fmt.h"
+
+/* Prototypes */
+extern int srom_var_init(si_t * sih, uint bus, void *curmap, osl_t * osh,
+			 char **vars, uint * count);
+
+extern int srom_read(si_t * sih, uint bus, void *curmap, osl_t * osh,
+		     uint byteoff, uint nbytes, uint16 * buf,
+		     bool check_crc);
+
+extern int srom_write(si_t * sih, uint bus, void *curmap, osl_t * osh,
+		      uint byteoff, uint nbytes, uint16 * buf);
+
+/* parse standard PCMCIA cis, normally used by SB/PCMCIA/SDIO/SPI/OTP
+ *   and extract from it into name=value pairs
+ */
+extern int srom_parsecis(osl_t * osh, uint8 ** pcis, uint ciscnt,
+			 char **vars, uint * count);
+
+#endif				/* _bcmsrom_h_ */
diff --git a/include/asm-mips/bcmsi/bcmsrom_fmt.h b/include/asm-mips/bcmsi/bcmsrom_fmt.h
new file mode 100644
index 0000000..1e422cf
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmsrom_fmt.h
@@ -0,0 +1,329 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * SROM format definition.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_bcmsrom_fmt_h_
+#define	_bcmsrom_fmt_h_
+
+/* Maximum srom: 4 Kilobits == 512 bytes */
+#define	SROM_MAX		512
+#define SROM_MAXW		256
+
+/* SROM Rev 2: 1 Kilobit map for 11a/b/g devices.
+ * SROM Rev 3: Upward compatible modification for lpphy and PCIe
+ * hardware workaround.
+ */
+
+#define	SROM_WORDS			64
+
+#define	SROM3_SWRGN_OFF		28	/* s/w region offset in words */
+
+#define	SROM_SSID			2
+
+#define	SROM_WL1LHMAXP		29
+
+#define	SROM_WL1LPAB0		30
+#define	SROM_WL1LPAB1		31
+#define	SROM_WL1LPAB2		32
+
+#define	SROM_WL1HPAB0		33
+#define	SROM_WL1HPAB1		34
+#define	SROM_WL1HPAB2		35
+
+#define	SROM_MACHI_IL0		36
+#define	SROM_MACMID_IL0		37
+#define	SROM_MACLO_IL0		38
+#define	SROM_MACHI_ET0		39
+#define	SROM_MACMID_ET0		40
+#define	SROM_MACLO_ET0		41
+#define	SROM_MACHI_ET1		42
+#define	SROM_MACMID_ET1		43
+#define	SROM_MACLO_ET1		44
+#define	SROM3_MACHI			37
+#define	SROM3_MACMID		38
+#define	SROM3_MACLO			39
+
+#define	SROM_BXARSSI2G		40
+#define	SROM_BXARSSI5G		41
+
+#define	SROM_TRI52G			42
+#define	SROM_TRI5GHL		43
+
+#define	SROM_RXPO52G		45
+
+#define	SROM2_ENETPHY		45
+
+#define	SROM_AABREV			46
+/* Fields in AABREV */
+#define	SROM_BR_MASK		0x00ff
+#define	SROM_CC_MASK		0x0f00
+#define	SROM_CC_SHIFT		8
+#define	SROM_AA0_MASK		0x3000
+#define	SROM_AA0_SHIFT		12
+#define	SROM_AA1_MASK		0xc000
+#define	SROM_AA1_SHIFT		14
+
+#define	SROM_WL0PAB0		47
+#define	SROM_WL0PAB1		48
+#define	SROM_WL0PAB2		49
+
+#define	SROM_LEDBH10		50
+#define	SROM_LEDBH32		51
+
+#define	SROM_WL10MAXP		52
+
+#define	SROM_WL1PAB0		53
+#define	SROM_WL1PAB1		54
+#define	SROM_WL1PAB2		55
+
+#define	SROM_ITT		56
+
+#define	SROM_BFL		57
+#define	SROM_BFL2		28
+#define	SROM3_BFL2		61
+
+#define	SROM_AG10		58
+
+#define	SROM_CCODE		59
+
+#define	SROM_OPO		60
+
+#define	SROM3_LEDDC		62
+
+#define	SROM_CRCREV		63
+
+/* SROM Rev 4: Reallocate the software part of the srom to accomodate
+ * MIMO features. It assumes up to two PCIE functions and 440 bytes
+ * of useable srom i.e. the useable storage in chips with OTP that
+ * implements hardware redundancy.
+ */
+
+#define	SROM4_WORDS		220
+
+#define	SROM4_SIGN		32
+#define	SROM4_SIGNATURE	0x5372
+
+#define	SROM4_BREV		33
+
+#define	SROM4_BFL0		34
+#define	SROM4_BFL1		35
+#define	SROM4_BFL2		36
+#define	SROM4_BFL3		37
+#define	SROM5_BFL0		37
+#define	SROM5_BFL1		38
+#define	SROM5_BFL2		39
+#define	SROM5_BFL3		40
+
+#define	SROM4_MACHI		38
+#define	SROM4_MACMID	39
+#define	SROM4_MACLO		40
+#define	SROM5_MACHI		41
+#define	SROM5_MACMID	42
+#define	SROM5_MACLO		43
+
+#define	SROM4_CCODE		41
+#define	SROM4_REGREV	42
+#define	SROM5_CCODE		34
+#define	SROM5_REGREV	35
+
+#define	SROM4_LEDBH10	43
+#define	SROM4_LEDBH32	44
+#define	SROM5_LEDBH10	59
+#define	SROM5_LEDBH32	60
+
+#define	SROM4_LEDDC		45
+#define	SROM5_LEDDC		45
+
+#define	SROM4_AA		46
+#define	SROM4_AA2G_MASK		0x00ff
+#define	SROM4_AA2G_SHIFT	0
+#define	SROM4_AA5G_MASK		0xff00
+#define	SROM4_AA5G_SHIFT	8
+
+#define	SROM4_AG10		47
+#define	SROM4_AG32		48
+
+#define	SROM4_TXPID2G	49
+#define	SROM4_TXPID5G	51
+#define	SROM4_TXPID5GL	53
+#define	SROM4_TXPID5GH	55
+
+#define SROM4_TXRXC		61
+#define SROM4_TXCHAIN_MASK	0x000f
+#define SROM4_TXCHAIN_SHIFT	0
+#define SROM4_RXCHAIN_MASK	0x00f0
+#define SROM4_RXCHAIN_SHIFT	4
+#define SROM4_SWITCH_MASK	0xff00
+#define SROM4_SWITCH_SHIFT	8
+
+/* Per-path fields */
+#define	MAX_PATH_SROM	4
+#define	SROM4_PATH0		64
+#define	SROM4_PATH1		87
+#define	SROM4_PATH2		110
+#define	SROM4_PATH3		133
+
+#define	SROM4_2G_ITT_MAXP	0
+#define	SROM4_2G_PA			1
+#define	SROM4_5G_ITT_MAXP	5
+#define	SROM4_5GLH_MAXP		6
+#define	SROM4_5G_PA			7
+#define	SROM4_5GL_PA		11
+#define	SROM4_5GH_PA		15
+
+/* Fields in the ITT_MAXP and 5GLH_MAXP words */
+#define	B2G_MAXP_MASK		0xff
+#define	B2G_ITT_SHIFT		8
+#define	B5G_MAXP_MASK		0xff
+#define	B5G_ITT_SHIFT		8
+#define	B5GH_MAXP_MASK		0xff
+#define	B5GL_MAXP_SHIFT		8
+
+/* All the miriad power offsets */
+#define	SROM4_2G_CCKPO		156
+#define	SROM4_2G_OFDMPO		157
+#define	SROM4_5G_OFDMPO		159
+#define	SROM4_5GL_OFDMPO	161
+#define	SROM4_5GH_OFDMPO	163
+#define	SROM4_2G_MCSPO		165
+#define	SROM4_5G_MCSPO		173
+#define	SROM4_5GL_MCSPO		181
+#define	SROM4_5GH_MCSPO		189
+#define	SROM4_CDDPO			197
+#define	SROM4_STBCPO		198
+#define	SROM4_BW40PO		199
+#define	SROM4_BWDUPPO		200
+
+#define	SROM4_CRCREV		219
+
+
+/*SROM Rev 8: Make space for a 48word hardware header for PCIe rev >= 6.
+ * This is acombined srom for both MIMO and SISO boards, usable in
+ * the .130 4Kilobit OTP with hardware redundancy.
+ */
+
+#define	SROM8_SIGN		64
+
+#define	SROM8_BREV		65
+
+#define	SROM8_BFL0		66
+#define	SROM8_BFL1		67
+#define	SROM8_BFL2		68
+#define	SROM8_BFL3		69
+
+#define	SROM8_MACHI		70
+#define	SROM8_MACMID	71
+#define	SROM8_MACLO		72
+
+#define	SROM8_CCODE		73
+#define	SROM8_REGREV	74
+
+#define	SROM8_LEDBH10	75
+#define	SROM8_LEDBH32	76
+
+#define	SROM8_LEDDC		77
+
+#define	SROM8_AA		78
+
+#define	SROM8_AG10		79
+#define	SROM8_AG32		80
+
+#define	SROM8_TXRXC		81
+
+#define	SROM8_BXARSSI2G	82
+#define	SROM8_BXARSSI5G	83
+#define	SROM8_TRI52G	84
+#define	SROM8_TRI5GHL	85
+#define	SROM8_RXPO52G	86
+
+#define SROM8_FEM2G		87
+#define SROM8_FEM5G		88
+#define SROM8_FEM_ANTSWLUT_MASK		0xf800
+#define SROM8_FEM_ANTSWLUT_SHIFT	11
+#define SROM8_FEM_TR_ISO_MASK		0x0700
+#define SROM8_FEM_TR_ISO_SHIFT		8
+#define SROM8_FEM_PDET_RANGE_MASK	0x00f8
+#define SROM8_FEM_PDET_RANGE_SHIFT	3
+#define SROM8_FEM_EXTPA_GAIN_MASK	0x0006
+#define SROM8_FEM_EXTPA_GAIN_SHIFT	1
+#define SROM8_FEM_TSSIPOS_MASK		0x0001
+#define SROM8_FEM_TSSIPOS_SHIFT		0
+
+/* Per-path offsets & fields */
+#define	SROM8_PATH0		96
+#define	SROM8_PATH1		112
+#define	SROM8_PATH2		128
+#define	SROM8_PATH3		144
+
+#define	SROM8_2G_ITT_MAXP	0
+#define	SROM8_2G_PA			1
+#define	SROM8_5G_ITT_MAXP	4
+#define	SROM8_5GLH_MAXP		5
+#define	SROM8_5G_PA			6
+#define	SROM8_5GL_PA		9
+#define	SROM8_5GH_PA		12
+
+/* All the miriad power offsets */
+#define	SROM8_2G_CCKPO		160
+
+#define	SROM8_2G_OFDMPO		161
+#define	SROM8_5G_OFDMPO		163
+#define	SROM8_5GL_OFDMPO	165
+#define	SROM8_5GH_OFDMPO	167
+
+#define	SROM8_2G_MCSPO		169
+#define	SROM8_5G_MCSPO		177
+#define	SROM8_5GL_MCSPO		185
+#define	SROM8_5GH_MCSPO		193
+
+#define	SROM8_CDDPO			201
+#define	SROM8_STBCPO		202
+#define	SROM8_BW40PO		203
+#define	SROM8_BWDUPPO		204
+
+/* SISO PA parameters are in the path0 spaces */
+#define	SROM8_SISO		96
+
+/* Legacy names for SISO PA paramters */
+#define	SROM8_W0_ITTMAXP	(SROM8_SISO + SROM8_2G_ITT_MAXP)
+#define	SROM8_W0_PAB0		(SROM8_SISO + SROM8_2G_PA)
+#define	SROM8_W0_PAB1		(SROM8_SISO + SROM8_2G_PA + 1)
+#define	SROM8_W0_PAB2		(SROM8_SISO + SROM8_2G_PA + 2)
+#define	SROM8_W1_ITTMAXP	(SROM8_SISO + SROM8_5G_ITT_MAXP)
+#define	SROM8_W1_MAXP_LCHC	(SROM8_SISO + SROM8_5GLH_MAXP)
+#define	SROM8_W1_PAB0		(SROM8_SISO + SROM8_5G_PA)
+#define	SROM8_W1_PAB1		(SROM8_SISO + SROM8_5G_PA + 1)
+#define	SROM8_W1_PAB2		(SROM8_SISO + SROM8_5G_PA + 2)
+#define	SROM8_W1_PAB0_LC	(SROM8_SISO + SROM8_5GL_PA)
+#define	SROM8_W1_PAB1_LC	(SROM8_SISO + SROM8_5GL_PA + 1)
+#define	SROM8_W1_PAB2_LC	(SROM8_SISO + SROM8_5GL_PA + 2)
+#define	SROM8_W1_PAB0_HC	(SROM8_SISO + SROM8_5GH_PA)
+#define	SROM8_W1_PAB1_HC	(SROM8_SISO + SROM8_5GH_PA + 1)
+#define	SROM8_W1_PAB2_HC	(SROM8_SISO + SROM8_5GH_PA + 2)
+
+#define	SROM8_CRCREV		219
+
+#endif				/* _bcmsrom_fmt_h_ */
diff --git a/include/asm-mips/bcmsi/bcmsrom_tbl.h b/include/asm-mips/bcmsi/bcmsrom_tbl.h
new file mode 100644
index 0000000..8543201
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmsrom_tbl.h
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Table that encodes the srom formats for PCI/PCIe NICs.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+typedef struct {
+    const char *name;
+    uint32 revmask;
+    uint32 flags;
+    uint16 off;
+    uint16 mask;
+} sromvar_t;
+
+#define SRFL_MORE	1	/* value continues as described by the next entry */
+#define	SRFL_NOFFS	2	/* value bits can't be all one's */
+#define	SRFL_PRHEX	4	/* value is in hexdecimal format */
+#define	SRFL_PRSIGN	8	/* value is in signed decimal format */
+#define	SRFL_CCODE	0x10	/* value is in country code format */
+#define	SRFL_ETHADDR	0x20	/* value is an Ethernet address */
+#define SRFL_LEDDC	0x40	/* value is an LED duty cycle */
+
+/* Assumptions:
+ * - Ethernet address spans across 3 consective words
+ *
+ * Table rules:
+ * - Add multiple entries next to each other if a value spans across multiple words
+ *   (even multiple fields in the same word) with each entry except the last having
+ *   it's SRFL_MORE bit set.
+ * - Ethernet address entry does not follow above rule and must not have SRFL_MORE
+ *   bit set. Its SRFL_ETHADDR bit implies it takes multiple words.
+ * - The last entry's name field must be NULL to indicate the end of the table. Other
+ *   entries must have non-NULL name.
+ */
+
+static const sromvar_t pci_sromvars[] = {
+    {"boardrev", 0x0000000e, SRFL_PRHEX, SROM_AABREV, SROM_BR_MASK},
+    {"boardrev", 0x000000f0, SRFL_PRHEX, SROM4_BREV, 0xffff},
+    {"boardrev", 0xffffff00, SRFL_PRHEX, SROM8_BREV, 0xffff},
+    {"boardflags", 0x00000002, SRFL_PRHEX, SROM_BFL, 0xffff},
+    {"boardflags", 0x00000004, SRFL_PRHEX | SRFL_MORE, SROM_BFL, 0xffff},
+    {"", 0, 0, SROM_BFL2, 0xffff},
+    {"boardflags", 0x00000008, SRFL_PRHEX | SRFL_MORE, SROM_BFL, 0xffff},
+    {"", 0, 0, SROM3_BFL2, 0xffff},
+    {"boardflags", 0x00000010, SRFL_PRHEX | SRFL_MORE, SROM4_BFL0, 0xffff},
+    {"", 0, 0, SROM4_BFL1, 0xffff},
+    {"boardflags", 0x000000e0, SRFL_PRHEX | SRFL_MORE, SROM5_BFL0, 0xffff},
+    {"", 0, 0, SROM5_BFL1, 0xffff},
+    {"boardflags", 0xffffff00, SRFL_PRHEX | SRFL_MORE, SROM8_BFL0, 0xffff},
+    {"", 0, 0, SROM8_BFL1, 0xffff},
+    {"boardflags2", 0x00000010, SRFL_PRHEX | SRFL_MORE, SROM4_BFL2,
+     0xffff},
+    {"", 0, 0, SROM4_BFL3, 0xffff},
+    {"boardflags2", 0x000000e0, SRFL_PRHEX | SRFL_MORE, SROM5_BFL2,
+     0xffff},
+    {"", 0, 0, SROM5_BFL3, 0xffff},
+    {"boardflags2", 0xffffff00, SRFL_PRHEX | SRFL_MORE, SROM8_BFL2,
+     0xffff},
+    {"", 0, 0, SROM8_BFL3, 0xffff},
+    {"boardtype", 0xfffffffc, SRFL_PRHEX, SROM_SSID, 0xffff},
+    {"boardnum", 0x00000006, 0, SROM_MACLO_IL0, 0xffff},
+    {"boardnum", 0x00000008, 0, SROM3_MACLO, 0xffff},
+    {"boardnum", 0x00000010, 0, SROM4_MACLO, 0xffff},
+    {"boardnum", 0x000000e0, 0, SROM5_MACLO, 0xffff},
+    {"boardnum", 0xffffff00, 0, SROM8_MACLO, 0xffff},
+    {"cc", 0x00000002, 0, SROM_AABREV, SROM_CC_MASK},
+    {"regrev", 0x00000008, 0, SROM_OPO, 0xff00},
+    {"regrev", 0x00000010, 0, SROM4_REGREV, 0x00ff},
+    {"regrev", 0x000000e0, 0, SROM5_REGREV, 0x00ff},
+    {"regrev", 0xffffff00, 0, SROM8_REGREV, 0x00ff},
+    {"ledbh0", 0x0000000e, SRFL_NOFFS, SROM_LEDBH10, 0x00ff},
+    {"ledbh1", 0x0000000e, SRFL_NOFFS, SROM_LEDBH10, 0xff00},
+    {"ledbh2", 0x0000000e, SRFL_NOFFS, SROM_LEDBH32, 0x00ff},
+    {"ledbh3", 0x0000000e, SRFL_NOFFS, SROM_LEDBH32, 0xff00},
+    {"ledbh0", 0x00000010, SRFL_NOFFS, SROM4_LEDBH10, 0x00ff},
+    {"ledbh1", 0x00000010, SRFL_NOFFS, SROM4_LEDBH10, 0xff00},
+    {"ledbh2", 0x00000010, SRFL_NOFFS, SROM4_LEDBH32, 0x00ff},
+    {"ledbh3", 0x00000010, SRFL_NOFFS, SROM4_LEDBH32, 0xff00},
+    {"ledbh0", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH10, 0x00ff},
+    {"ledbh1", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH10, 0xff00},
+    {"ledbh2", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH32, 0x00ff},
+    {"ledbh3", 0x000000e0, SRFL_NOFFS, SROM5_LEDBH32, 0xff00},
+    {"ledbh0", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH10, 0x00ff},
+    {"ledbh1", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH10, 0xff00},
+    {"ledbh2", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH32, 0x00ff},
+    {"ledbh3", 0xffffff00, SRFL_NOFFS, SROM8_LEDBH32, 0xff00},
+    {"pa0b0", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB0, 0xffff},
+    {"pa0b1", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB1, 0xffff},
+    {"pa0b2", 0x0000000e, SRFL_PRHEX, SROM_WL0PAB2, 0xffff},
+    {"pa0itssit", 0x0000000e, 0, SROM_ITT, 0x00ff},
+    {"pa0maxpwr", 0x0000000e, 0, SROM_WL10MAXP, 0x00ff},
+    {"pa0b0", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB0, 0xffff},
+    {"pa0b1", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB1, 0xffff},
+    {"pa0b2", 0xffffff00, SRFL_PRHEX, SROM8_W0_PAB2, 0xffff},
+    {"pa0itssit", 0xffffff00, 0, SROM8_W0_ITTMAXP, 0xff00},
+    {"pa0maxpwr", 0xffffff00, 0, SROM8_W0_ITTMAXP, 0x00ff},
+    {"opo", 0x0000000c, 0, SROM_OPO, 0x00ff},
+    {"opo", 0xffffff00, 0, SROM8_2G_OFDMPO, 0x00ff},
+    {"aa2g", 0x0000000e, 0, SROM_AABREV, SROM_AA0_MASK},
+    {"aa2g", 0x000000f0, 0, SROM4_AA, 0x00ff},
+    {"aa2g", 0xffffff00, 0, SROM8_AA, 0x00ff},
+    {"aa5g", 0x0000000e, 0, SROM_AABREV, SROM_AA1_MASK},
+    {"aa5g", 0x000000f0, 0, SROM4_AA, 0xff00},
+    {"aa5g", 0xffffff00, 0, SROM8_AA, 0xff00},
+    {"ag0", 0x0000000e, 0, SROM_AG10, 0x00ff},
+    {"ag1", 0x0000000e, 0, SROM_AG10, 0xff00},
+    {"ag0", 0x000000f0, 0, SROM4_AG10, 0x00ff},
+    {"ag1", 0x000000f0, 0, SROM4_AG10, 0xff00},
+    {"ag2", 0x000000f0, 0, SROM4_AG32, 0x00ff},
+    {"ag3", 0x000000f0, 0, SROM4_AG32, 0xff00},
+    {"ag0", 0xffffff00, 0, SROM8_AG10, 0x00ff},
+    {"ag1", 0xffffff00, 0, SROM8_AG10, 0xff00},
+    {"ag2", 0xffffff00, 0, SROM8_AG32, 0x00ff},
+    {"ag3", 0xffffff00, 0, SROM8_AG32, 0xff00},
+    {"pa1b0", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB0, 0xffff},
+    {"pa1b1", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB1, 0xffff},
+    {"pa1b2", 0x0000000e, SRFL_PRHEX, SROM_WL1PAB2, 0xffff},
+    {"pa1lob0", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB0, 0xffff},
+    {"pa1lob1", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB1, 0xffff},
+    {"pa1lob2", 0x0000000c, SRFL_PRHEX, SROM_WL1LPAB2, 0xffff},
+    {"pa1hib0", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB0, 0xffff},
+    {"pa1hib1", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB1, 0xffff},
+    {"pa1hib2", 0x0000000c, SRFL_PRHEX, SROM_WL1HPAB2, 0xffff},
+    {"pa1itssit", 0x0000000e, 0, SROM_ITT, 0xff00},
+    {"pa1maxpwr", 0x0000000e, 0, SROM_WL10MAXP, 0xff00},
+    {"pa1lomaxpwr", 0x0000000c, 0, SROM_WL1LHMAXP, 0xff00},
+    {"pa1himaxpwr", 0x0000000c, 0, SROM_WL1LHMAXP, 0x00ff},
+    {"pa1b0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0, 0xffff},
+    {"pa1b1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1, 0xffff},
+    {"pa1b2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2, 0xffff},
+    {"pa1lob0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0_LC, 0xffff},
+    {"pa1lob1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1_LC, 0xffff},
+    {"pa1lob2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2_LC, 0xffff},
+    {"pa1hib0", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB0_HC, 0xffff},
+    {"pa1hib1", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB1_HC, 0xffff},
+    {"pa1hib2", 0xffffff00, SRFL_PRHEX, SROM8_W1_PAB2_HC, 0xffff},
+    {"pa1itssit", 0xffffff00, 0, SROM8_W1_ITTMAXP, 0xff00},
+    {"pa1maxpwr", 0xffffff00, 0, SROM8_W1_ITTMAXP, 0x00ff},
+    {"pa1lomaxpwr", 0xffffff00, 0, SROM8_W1_MAXP_LCHC, 0xff00},
+    {"pa1himaxpwr", 0xffffff00, 0, SROM8_W1_MAXP_LCHC, 0x00ff},
+    {"bxa2g", 0x00000008, 0, SROM_BXARSSI2G, 0x1800},
+    {"rssisav2g", 0x00000008, 0, SROM_BXARSSI2G, 0x0700},
+    {"rssismc2g", 0x00000008, 0, SROM_BXARSSI2G, 0x00f0},
+    {"rssismf2g", 0x00000008, 0, SROM_BXARSSI2G, 0x000f},
+    {"bxa2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x1800},
+    {"rssisav2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x0700},
+    {"rssismc2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x00f0},
+    {"rssismf2g", 0xffffff00, 0, SROM8_BXARSSI2G, 0x000f},
+    {"bxa5g", 0x00000008, 0, SROM_BXARSSI5G, 0x1800},
+    {"rssisav5g", 0x00000008, 0, SROM_BXARSSI5G, 0x0700},
+    {"rssismc5g", 0x00000008, 0, SROM_BXARSSI5G, 0x00f0},
+    {"rssismf5g", 0x00000008, 0, SROM_BXARSSI5G, 0x000f},
+    {"bxa5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x1800},
+    {"rssisav5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x0700},
+    {"rssismc5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x00f0},
+    {"rssismf5g", 0xffffff00, 0, SROM8_BXARSSI5G, 0x000f},
+    {"tri2g", 0x00000008, 0, SROM_TRI52G, 0x00ff},
+    {"tri5g", 0x00000008, 0, SROM_TRI52G, 0xff00},
+    {"tri5gl", 0x00000008, 0, SROM_TRI5GHL, 0x00ff},
+    {"tri5gh", 0x00000008, 0, SROM_TRI5GHL, 0xff00},
+    {"tri2g", 0xffffff00, 0, SROM8_TRI52G, 0x00ff},
+    {"tri5g", 0xffffff00, 0, SROM8_TRI52G, 0xff00},
+    {"tri5gl", 0xffffff00, 0, SROM8_TRI5GHL, 0x00ff},
+    {"tri5gh", 0xffffff00, 0, SROM8_TRI5GHL, 0xff00},
+    {"rxpo2g", 0x00000008, SRFL_PRSIGN, SROM_RXPO52G, 0x00ff},
+    {"rxpo5g", 0x00000008, SRFL_PRSIGN, SROM_RXPO52G, 0xff00},
+    {"rxpo2g", 0xffffff00, SRFL_PRSIGN, SROM8_RXPO52G, 0x00ff},
+    {"rxpo5g", 0xffffff00, SRFL_PRSIGN, SROM8_RXPO52G, 0xff00},
+    {"txchain", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_TXCHAIN_MASK},
+    {"rxchain", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_RXCHAIN_MASK},
+    {"antswitch", 0x000000f0, SRFL_NOFFS, SROM4_TXRXC, SROM4_SWITCH_MASK},
+    {"txchain", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_TXCHAIN_MASK},
+    {"rxchain", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_RXCHAIN_MASK},
+    {"antswitch", 0xffffff00, SRFL_NOFFS, SROM8_TXRXC, SROM4_SWITCH_MASK},
+    {"tssipos2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_TSSIPOS_MASK},
+    {"extpagain2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_EXTPA_GAIN_MASK},
+    {"pdetrange2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_PDET_RANGE_MASK},
+    {"triso2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_TR_ISO_MASK},
+    {"antswctl2g", 0xffffff00, 0, SROM8_FEM2G, SROM8_FEM_ANTSWLUT_MASK},
+    {"tssipos5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_TSSIPOS_MASK},
+    {"extpagain5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_EXTPA_GAIN_MASK},
+    {"pdetrange5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_PDET_RANGE_MASK},
+    {"triso5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_TR_ISO_MASK},
+    {"antswctl5g", 0xffffff00, 0, SROM8_FEM5G, SROM8_FEM_ANTSWLUT_MASK},
+    {"txpid2ga0", 0x000000f0, 0, SROM4_TXPID2G, 0x00ff},
+    {"txpid2ga1", 0x000000f0, 0, SROM4_TXPID2G, 0xff00},
+    {"txpid2ga2", 0x000000f0, 0, SROM4_TXPID2G + 1, 0x00ff},
+    {"txpid2ga3", 0x000000f0, 0, SROM4_TXPID2G + 1, 0xff00},
+    {"txpid5ga0", 0x000000f0, 0, SROM4_TXPID5G, 0x00ff},
+    {"txpid5ga1", 0x000000f0, 0, SROM4_TXPID5G, 0xff00},
+    {"txpid5ga2", 0x000000f0, 0, SROM4_TXPID5G + 1, 0x00ff},
+    {"txpid5ga3", 0x000000f0, 0, SROM4_TXPID5G + 1, 0xff00},
+    {"txpid5gla0", 0x000000f0, 0, SROM4_TXPID5GL, 0x00ff},
+    {"txpid5gla1", 0x000000f0, 0, SROM4_TXPID5GL, 0xff00},
+    {"txpid5gla2", 0x000000f0, 0, SROM4_TXPID5GL + 1, 0x00ff},
+    {"txpid5gla3", 0x000000f0, 0, SROM4_TXPID5GL + 1, 0xff00},
+    {"txpid5gha0", 0x000000f0, 0, SROM4_TXPID5GH, 0x00ff},
+    {"txpid5gha1", 0x000000f0, 0, SROM4_TXPID5GH, 0xff00},
+    {"txpid5gha2", 0x000000f0, 0, SROM4_TXPID5GH + 1, 0x00ff},
+    {"txpid5gha3", 0x000000f0, 0, SROM4_TXPID5GH + 1, 0xff00},
+    {"cck2gpo", 0x000000f0, 0, SROM4_2G_CCKPO, 0xffff},
+    {"cck2gpo", 0xffffff00, 0, SROM8_2G_CCKPO, 0xffff},
+    {"ofdm2gpo", 0x000000f0, SRFL_MORE, SROM4_2G_OFDMPO, 0xffff},
+    {"", 0, 0, SROM4_2G_OFDMPO + 1, 0xffff},
+    {"ofdm5gpo", 0x000000f0, SRFL_MORE, SROM4_5G_OFDMPO, 0xffff},
+    {"", 0, 0, SROM4_5G_OFDMPO + 1, 0xffff},
+    {"ofdm5glpo", 0x000000f0, SRFL_MORE, SROM4_5GL_OFDMPO, 0xffff},
+    {"", 0, 0, SROM4_5GL_OFDMPO + 1, 0xffff},
+    {"ofdm5ghpo", 0x000000f0, SRFL_MORE, SROM4_5GH_OFDMPO, 0xffff},
+    {"", 0, 0, SROM4_5GH_OFDMPO + 1, 0xffff},
+    {"ofdm2gpo", 0xffffff00, SRFL_MORE, SROM8_2G_OFDMPO, 0xffff},
+    {"", 0, 0, SROM8_2G_OFDMPO + 1, 0xffff},
+    {"ofdm5gpo", 0xffffff00, SRFL_MORE, SROM8_5G_OFDMPO, 0xffff},
+    {"", 0, 0, SROM8_5G_OFDMPO + 1, 0xffff},
+    {"ofdm5glpo", 0xffffff00, SRFL_MORE, SROM8_5GL_OFDMPO, 0xffff},
+    {"", 0, 0, SROM8_5GL_OFDMPO + 1, 0xffff},
+    {"ofdm5ghpo", 0xffffff00, SRFL_MORE, SROM8_5GH_OFDMPO, 0xffff},
+    {"", 0, 0, SROM8_5GH_OFDMPO + 1, 0xffff},
+    {"mcs2gpo0", 0x000000f0, 0, SROM4_2G_MCSPO, 0xffff},
+    {"mcs2gpo1", 0x000000f0, 0, SROM4_2G_MCSPO + 1, 0xffff},
+    {"mcs2gpo2", 0x000000f0, 0, SROM4_2G_MCSPO + 2, 0xffff},
+    {"mcs2gpo3", 0x000000f0, 0, SROM4_2G_MCSPO + 3, 0xffff},
+    {"mcs2gpo4", 0x000000f0, 0, SROM4_2G_MCSPO + 4, 0xffff},
+    {"mcs2gpo5", 0x000000f0, 0, SROM4_2G_MCSPO + 5, 0xffff},
+    {"mcs2gpo6", 0x000000f0, 0, SROM4_2G_MCSPO + 6, 0xffff},
+    {"mcs2gpo7", 0x000000f0, 0, SROM4_2G_MCSPO + 7, 0xffff},
+    {"mcs5gpo0", 0x000000f0, 0, SROM4_5G_MCSPO, 0xffff},
+    {"mcs5gpo1", 0x000000f0, 0, SROM4_5G_MCSPO + 1, 0xffff},
+    {"mcs5gpo2", 0x000000f0, 0, SROM4_5G_MCSPO + 2, 0xffff},
+    {"mcs5gpo3", 0x000000f0, 0, SROM4_5G_MCSPO + 3, 0xffff},
+    {"mcs5gpo4", 0x000000f0, 0, SROM4_5G_MCSPO + 4, 0xffff},
+    {"mcs5gpo5", 0x000000f0, 0, SROM4_5G_MCSPO + 5, 0xffff},
+    {"mcs5gpo6", 0x000000f0, 0, SROM4_5G_MCSPO + 6, 0xffff},
+    {"mcs5gpo7", 0x000000f0, 0, SROM4_5G_MCSPO + 7, 0xffff},
+    {"mcs5glpo0", 0x000000f0, 0, SROM4_5GL_MCSPO, 0xffff},
+    {"mcs5glpo1", 0x000000f0, 0, SROM4_5GL_MCSPO + 1, 0xffff},
+    {"mcs5glpo2", 0x000000f0, 0, SROM4_5GL_MCSPO + 2, 0xffff},
+    {"mcs5glpo3", 0x000000f0, 0, SROM4_5GL_MCSPO + 3, 0xffff},
+    {"mcs5glpo4", 0x000000f0, 0, SROM4_5GL_MCSPO + 4, 0xffff},
+    {"mcs5glpo5", 0x000000f0, 0, SROM4_5GL_MCSPO + 5, 0xffff},
+    {"mcs5glpo6", 0x000000f0, 0, SROM4_5GL_MCSPO + 6, 0xffff},
+    {"mcs5glpo7", 0x000000f0, 0, SROM4_5GL_MCSPO + 7, 0xffff},
+    {"mcs5ghpo0", 0x000000f0, 0, SROM4_5GH_MCSPO, 0xffff},
+    {"mcs5ghpo1", 0x000000f0, 0, SROM4_5GH_MCSPO + 1, 0xffff},
+    {"mcs5ghpo2", 0x000000f0, 0, SROM4_5GH_MCSPO + 2, 0xffff},
+    {"mcs5ghpo3", 0x000000f0, 0, SROM4_5GH_MCSPO + 3, 0xffff},
+    {"mcs5ghpo4", 0x000000f0, 0, SROM4_5GH_MCSPO + 4, 0xffff},
+    {"mcs5ghpo5", 0x000000f0, 0, SROM4_5GH_MCSPO + 5, 0xffff},
+    {"mcs5ghpo6", 0x000000f0, 0, SROM4_5GH_MCSPO + 6, 0xffff},
+    {"mcs5ghpo7", 0x000000f0, 0, SROM4_5GH_MCSPO + 7, 0xffff},
+    {"mcs2gpo0", 0xffffff00, 0, SROM8_2G_MCSPO, 0xffff},
+    {"mcs2gpo1", 0xffffff00, 0, SROM8_2G_MCSPO + 1, 0xffff},
+    {"mcs2gpo2", 0xffffff00, 0, SROM8_2G_MCSPO + 2, 0xffff},
+    {"mcs2gpo3", 0xffffff00, 0, SROM8_2G_MCSPO + 3, 0xffff},
+    {"mcs2gpo4", 0xffffff00, 0, SROM8_2G_MCSPO + 4, 0xffff},
+    {"mcs2gpo5", 0xffffff00, 0, SROM8_2G_MCSPO + 5, 0xffff},
+    {"mcs2gpo6", 0xffffff00, 0, SROM8_2G_MCSPO + 6, 0xffff},
+    {"mcs2gpo7", 0xffffff00, 0, SROM8_2G_MCSPO + 7, 0xffff},
+    {"mcs5gpo0", 0xffffff00, 0, SROM8_5G_MCSPO, 0xffff},
+    {"mcs5gpo1", 0xffffff00, 0, SROM8_5G_MCSPO + 1, 0xffff},
+    {"mcs5gpo2", 0xffffff00, 0, SROM8_5G_MCSPO + 2, 0xffff},
+    {"mcs5gpo3", 0xffffff00, 0, SROM8_5G_MCSPO + 3, 0xffff},
+    {"mcs5gpo4", 0xffffff00, 0, SROM8_5G_MCSPO + 4, 0xffff},
+    {"mcs5gpo5", 0xffffff00, 0, SROM8_5G_MCSPO + 5, 0xffff},
+    {"mcs5gpo6", 0xffffff00, 0, SROM8_5G_MCSPO + 6, 0xffff},
+    {"mcs5gpo7", 0xffffff00, 0, SROM8_5G_MCSPO + 7, 0xffff},
+    {"mcs5glpo0", 0xffffff00, 0, SROM8_5GL_MCSPO, 0xffff},
+    {"mcs5glpo1", 0xffffff00, 0, SROM8_5GL_MCSPO + 1, 0xffff},
+    {"mcs5glpo2", 0xffffff00, 0, SROM8_5GL_MCSPO + 2, 0xffff},
+    {"mcs5glpo3", 0xffffff00, 0, SROM8_5GL_MCSPO + 3, 0xffff},
+    {"mcs5glpo4", 0xffffff00, 0, SROM8_5GL_MCSPO + 4, 0xffff},
+    {"mcs5glpo5", 0xffffff00, 0, SROM8_5GL_MCSPO + 5, 0xffff},
+    {"mcs5glpo6", 0xffffff00, 0, SROM8_5GL_MCSPO + 6, 0xffff},
+    {"mcs5glpo7", 0xffffff00, 0, SROM8_5GL_MCSPO + 7, 0xffff},
+    {"mcs5ghpo0", 0xffffff00, 0, SROM8_5GH_MCSPO, 0xffff},
+    {"mcs5ghpo1", 0xffffff00, 0, SROM8_5GH_MCSPO + 1, 0xffff},
+    {"mcs5ghpo2", 0xffffff00, 0, SROM8_5GH_MCSPO + 2, 0xffff},
+    {"mcs5ghpo3", 0xffffff00, 0, SROM8_5GH_MCSPO + 3, 0xffff},
+    {"mcs5ghpo4", 0xffffff00, 0, SROM8_5GH_MCSPO + 4, 0xffff},
+    {"mcs5ghpo5", 0xffffff00, 0, SROM8_5GH_MCSPO + 5, 0xffff},
+    {"mcs5ghpo6", 0xffffff00, 0, SROM8_5GH_MCSPO + 6, 0xffff},
+    {"mcs5ghpo7", 0xffffff00, 0, SROM8_5GH_MCSPO + 7, 0xffff},
+    {"cddpo", 0x000000f0, 0, SROM4_CDDPO, 0xffff},
+    {"stbcpo", 0x000000f0, 0, SROM4_STBCPO, 0xffff},
+    {"bw40po", 0x000000f0, 0, SROM4_BW40PO, 0xffff},
+    {"bwduppo", 0x000000f0, 0, SROM4_BWDUPPO, 0xffff},
+    {"cddpo", 0xffffff00, 0, SROM8_CDDPO, 0xffff},
+    {"stbcpo", 0xffffff00, 0, SROM8_STBCPO, 0xffff},
+    {"bw40po", 0xffffff00, 0, SROM8_BW40PO, 0xffff},
+    {"bwduppo", 0xffffff00, 0, SROM8_BWDUPPO, 0xffff},
+    {"ccode", 0x0000000f, SRFL_CCODE, SROM_CCODE, 0xffff},
+    {"ccode", 0x00000010, SRFL_CCODE, SROM4_CCODE, 0xffff},
+    {"ccode", 0x000000e0, SRFL_CCODE, SROM5_CCODE, 0xffff},
+    {"ccode", 0xffffff00, SRFL_CCODE, SROM8_CCODE, 0xffff},
+    {"macaddr", 0xffffff00, SRFL_ETHADDR, SROM8_MACHI, 0xffff},
+    {"macaddr", 0x000000e0, SRFL_ETHADDR, SROM5_MACHI, 0xffff},
+    {"macaddr", 0x00000010, SRFL_ETHADDR, SROM4_MACHI, 0xffff},
+    {"macaddr", 0x00000008, SRFL_ETHADDR, SROM3_MACHI, 0xffff},
+    {"il0macaddr", 0x00000007, SRFL_ETHADDR, SROM_MACHI_IL0, 0xffff},
+    {"et1macaddr", 0x00000007, SRFL_ETHADDR, SROM_MACHI_ET1, 0xffff},
+    {"leddc", 0xffffff00, SRFL_NOFFS | SRFL_LEDDC, SROM8_LEDDC, 0xffff},
+    {"leddc", 0x000000e0, SRFL_NOFFS | SRFL_LEDDC, SROM5_LEDDC, 0xffff},
+    {"leddc", 0x00000010, SRFL_NOFFS | SRFL_LEDDC, SROM4_LEDDC, 0xffff},
+    {"leddc", 0x00000008, SRFL_NOFFS | SRFL_LEDDC, SROM3_LEDDC, 0xffff},
+    {NULL, 0, 0, 0, 0}
+};
+
+static const sromvar_t perpath_pci_sromvars[] = {
+    {"maxp2ga", 0x000000f0, 0, SROM4_2G_ITT_MAXP, 0x00ff},
+    {"itt2ga", 0x000000f0, 0, SROM4_2G_ITT_MAXP, 0xff00},
+    {"itt5ga", 0x000000f0, 0, SROM4_5G_ITT_MAXP, 0xff00},
+    {"pa2gw0a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA, 0xffff},
+    {"pa2gw1a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 1, 0xffff},
+    {"pa2gw2a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 2, 0xffff},
+    {"pa2gw3a", 0x000000f0, SRFL_PRHEX, SROM4_2G_PA + 3, 0xffff},
+    {"maxp5ga", 0x000000f0, 0, SROM4_5G_ITT_MAXP, 0x00ff},
+    {"maxp5gha", 0x000000f0, 0, SROM4_5GLH_MAXP, 0x00ff},
+    {"maxp5gla", 0x000000f0, 0, SROM4_5GLH_MAXP, 0xff00},
+    {"pa5gw0a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA, 0xffff},
+    {"pa5gw1a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 1, 0xffff},
+    {"pa5gw2a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 2, 0xffff},
+    {"pa5gw3a", 0x000000f0, SRFL_PRHEX, SROM4_5G_PA + 3, 0xffff},
+    {"pa5glw0a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA, 0xffff},
+    {"pa5glw1a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 1, 0xffff},
+    {"pa5glw2a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 2, 0xffff},
+    {"pa5glw3a", 0x000000f0, SRFL_PRHEX, SROM4_5GL_PA + 3, 0xffff},
+    {"pa5ghw0a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA, 0xffff},
+    {"pa5ghw1a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 1, 0xffff},
+    {"pa5ghw2a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 2, 0xffff},
+    {"pa5ghw3a", 0x000000f0, SRFL_PRHEX, SROM4_5GH_PA + 3, 0xffff},
+    {"maxp2ga", 0xffffff00, 0, SROM8_2G_ITT_MAXP, 0x00ff},
+    {"itt2ga", 0xffffff00, 0, SROM8_2G_ITT_MAXP, 0xff00},
+    {"itt5ga", 0xffffff00, 0, SROM8_5G_ITT_MAXP, 0xff00},
+    {"pa2gw0a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA, 0xffff},
+    {"pa2gw1a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA + 1, 0xffff},
+    {"pa2gw2a", 0xffffff00, SRFL_PRHEX, SROM8_2G_PA + 2, 0xffff},
+    {"maxp5ga", 0xffffff00, 0, SROM8_5G_ITT_MAXP, 0x00ff},
+    {"maxp5gha", 0xffffff00, 0, SROM8_5GLH_MAXP, 0x00ff},
+    {"maxp5gla", 0xffffff00, 0, SROM8_5GLH_MAXP, 0xff00},
+    {"pa5gw0a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA, 0xffff},
+    {"pa5gw1a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA + 1, 0xffff},
+    {"pa5gw2a", 0xffffff00, SRFL_PRHEX, SROM8_5G_PA + 2, 0xffff},
+    {"pa5glw0a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA, 0xffff},
+    {"pa5glw1a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA + 1, 0xffff},
+    {"pa5glw2a", 0xffffff00, SRFL_PRHEX, SROM8_5GL_PA + 2, 0xffff},
+    {"pa5ghw0a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA, 0xffff},
+    {"pa5ghw1a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA + 1, 0xffff},
+    {"pa5ghw2a", 0xffffff00, SRFL_PRHEX, SROM8_5GH_PA + 2, 0xffff},
+    {NULL, 0, 0, 0, 0}
+};
diff --git a/include/asm-mips/bcmsi/bcmstdlib.h b/include/asm-mips/bcmsi/bcmstdlib.h
new file mode 100644
index 0000000..9cc4fb5
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmstdlib.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * prototypes for functions defined in bcmstdlib.c
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+/*
+ * bcmstdlib.h file should be used only to construct an OSL or alone without any OSL
+ * It should not be used with any orbitarary OSL's as there could be a conflict
+ * with some of the routines defined here.
+*/
+
+#ifndef	_BCMSTDLIB_H
+#define	_BCMSTDLIB_H
+
+#include "typedefs.h"
+#include "bcmdefs.h"
+
+#if !defined(vxworks) && (!defined(_WIN32) || defined(EFI)) && !defined(_CFE_)
+
+typedef int FILE;
+#define stdout ((FILE *)1)
+#define stderr ((FILE *)2)
+
+/* i/o functions */
+extern int fputc(int c, FILE * stream);
+extern void putc(int c);
+/* extern int putc(int c, FILE *stream); */
+#define putchar(c) putc(c)
+extern int fputs(const char *s, FILE * stream);
+extern int puts(const char *s);
+extern int getc(void);
+extern bool keypressed(void);
+
+/* string functions */
+#define PRINTF_BUFLEN	512
+extern int printf(const char *fmt, ...);
+extern int BCMROMFN(sprintf) (char *buf, const char *fmt, ...);
+
+extern char *BCMROMFN(index) (const char *s, int c);
+
+/* For EFI, use some of the common EFI Driver Library functions
+ * to reduce final size and improve efficiency
+ */
+#ifndef EFI
+extern int BCMROMFN(strcmp) (const char *s1, const char *s2);
+extern size_t BCMROMFN(strlen) (const char *s);
+extern char *BCMROMFN(strcpy) (char *dest, const char *src);
+extern char *BCMROMFN(strstr) (const char *s, const char *find);
+extern char *BCMROMFN(strncpy) (char *dest, const char *src, size_t n);
+extern char *BCMROMFN(strcat) (char *d, const char *s);
+#endif				/* EFI */
+
+extern int BCMROMFN(strncmp) (const char *s1, const char *s2, size_t n);
+extern char *BCMROMFN(strchr) (const char *str, int c);
+extern char *BCMROMFN(strrchr) (const char *str, int c);
+extern size_t BCMROMFN(strspn) (const char *s1, const char *s2);
+extern size_t BCMROMFN(strcspn) (const char *s1, const char *s2);
+extern unsigned long BCMROMFN(strtoul) (const char *cp, char **endp,
+					int base);
+#define strtol(nptr, endptr, base) ((long)strtoul((nptr), (endptr), (base)))
+#define	atoi(s)	((int)(strtoul((s), NULL, 10)))
+
+extern void *BCMROMFN(memmove) (void *dest, const void *src, size_t n);
+extern void *BCMROMFN(memchr) (const void *s, int c, size_t n);
+
+extern int BCMROMFN(vsprintf) (char *buf, const char *fmt, va_list ap);
+/* mem functions */
+#ifndef EFI
+/* For EFI, using EFIDriverLib versions */
+/* Cannot use memmem in ROM because of character array initialization wiht "" in gcc */
+extern void *memset(void *dest, int c, size_t n);
+/* Cannot use memcpy in ROM because of structure assignmnets in gcc */
+extern void *memcpy(void *dest, const void *src, size_t n);
+extern int BCMROMFN(memcmp) (const void *s1, const void *s2, size_t n);
+
+/* bcopy, bcmp, and bzero */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+#endif				/* EFI */
+
+extern unsigned long rand(void);
+
+#endif				/* !defined(vxworks) && !defined(_WIN32) && !defined(_CFE_) */
+
+extern int BCMROMFN(snprintf) (char *str, size_t n, char const *fmt, ...);
+extern int BCMROMFN(vsnprintf) (char *buf, size_t size, const char *fmt,
+				va_list ap);
+
+#endif				/* _BCMSTDLIB_H */
diff --git a/include/asm-mips/bcmsi/bcmutils.h b/include/asm-mips/bcmsi/bcmutils.h
new file mode 100644
index 0000000..0aa587f
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmutils.h
@@ -0,0 +1,634 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Misc useful os-independent macros and functions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef	_bcmutils_h_
+#define	_bcmutils_h_
+
+/* ctype replacement */
+#define _BCM_U	0x01		/* upper */
+#define _BCM_L	0x02		/* lower */
+#define _BCM_D	0x04		/* digit */
+#define _BCM_C	0x08		/* cntrl */
+#define _BCM_P	0x10		/* punct */
+#define _BCM_S	0x20		/* white space (space/lf/tab) */
+#define _BCM_X	0x40		/* hex digit */
+#define _BCM_SP	0x80		/* hard space (0x20) */
+
+extern const unsigned char bcm_ctype[];
+#define bcm_ismask(x)	(bcm_ctype[(int)(unsigned char)(x)])
+
+#define bcm_isalnum(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_isalpha(c)	((bcm_ismask(c)&(_BCM_U|_BCM_L)) != 0)
+#define bcm_iscntrl(c)	((bcm_ismask(c)&(_BCM_C)) != 0)
+#define bcm_isdigit(c)	((bcm_ismask(c)&(_BCM_D)) != 0)
+#define bcm_isgraph(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D)) != 0)
+#define bcm_islower(c)	((bcm_ismask(c)&(_BCM_L)) != 0)
+#define bcm_isprint(c)	((bcm_ismask(c)&(_BCM_P|_BCM_U|_BCM_L|_BCM_D|_BCM_SP)) != 0)
+#define bcm_ispunct(c)	((bcm_ismask(c)&(_BCM_P)) != 0)
+#define bcm_isspace(c)	((bcm_ismask(c)&(_BCM_S)) != 0)
+#define bcm_isupper(c)	((bcm_ismask(c)&(_BCM_U)) != 0)
+#define bcm_isxdigit(c)	((bcm_ismask(c)&(_BCM_D|_BCM_X)) != 0)
+#define bcm_tolower(c)	(bcm_isupper((c)) ? ((c) + 'a' - 'A') : (c))
+#define bcm_toupper(c)	(bcm_islower((c)) ? ((c) + 'A' - 'a') : (c))
+
+/* Buffer structure for collecting string-formatted data
+* using bcm_bprintf() API.
+* Use bcm_binit() to initialize before use
+*/
+
+struct bcmstrbuf {
+    char *buf;			/* pointer to current position in origbuf */
+    unsigned int size;		/* current (residual) size in bytes */
+    char *origbuf;		/* unmodified pointer to orignal buffer */
+    unsigned int origsize;	/* unmodified orignal buffer size in bytes */
+};
+
+/* ** driver-only section ** */
+#ifdef BCMDRIVER
+#include "osl.h"
+
+#define GPIO_PIN_NOTDEFINED 	0x20	/* Pin not defined */
+
+/*
+ * Spin at most 'us' microseconds while 'exp' is true.
+ * Caller should explicitly test 'exp' when this completes
+ * and take appropriate error action if 'exp' is still true.
+ */
+#define SPINWAIT(exp, us) { \
+	uint countdown = (us) + 9; \
+	while ((exp) && (countdown >= 10)) {\
+		OSL_DELAY(10); \
+		countdown -= 10; \
+	} \
+}
+
+
+/* osl multi-precedence packet queue */
+#ifndef PKTQ_LEN_DEFAULT
+#define PKTQ_LEN_DEFAULT        128	/* Max 128 packets */
+#endif
+#ifndef PKTQ_MAX_PREC
+#define PKTQ_MAX_PREC           16	/* Maximum precedence levels */
+#endif
+
+typedef struct pktq_prec {
+    void *head;			/* first packet to dequeue */
+    void *tail;			/* last packet to dequeue */
+    uint16 len;			/* number of queued packets */
+    uint16 max;			/* maximum number of queued packets */
+} pktq_prec_t;
+
+
+/* multi-priority pkt queue */
+struct pktq {
+    uint16 num_prec;		/* number of precedences in use */
+    uint16 hi_prec;		/* rapid dequeue hint (>= highest non-empty prec) */
+    uint16 max;			/* total max packets */
+    uint16 len;			/* total number of packets */
+    /* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+    struct pktq_prec q[PKTQ_MAX_PREC];
+};
+
+/* simple, non-priority pkt queue */
+struct spktq {
+    uint16 num_prec;		/* number of precedences in use (always 1) */
+    uint16 hi_prec;		/* rapid dequeue hint (>= highest non-empty prec) */
+    uint16 max;			/* total max packets */
+    uint16 len;			/* total number of packets */
+    /* q array must be last since # of elements can be either PKTQ_MAX_PREC or 1 */
+    struct pktq_prec q[1];
+};
+
+#define PKTQ_PREC_ITER(pq, prec)        for (prec = (pq)->num_prec - 1; prec >= 0; prec--)
+
+/* forward definition of ether_addr structure used by some function prototypes */
+
+struct ether_addr;
+
+/* operations on a specific precedence in packet queue */
+
+#define pktq_psetmax(pq, prec, _max)    ((pq)->q[prec].max = (_max))
+#define pktq_plen(pq, prec)             ((pq)->q[prec].len)
+#define pktq_pavail(pq, prec)           ((pq)->q[prec].max - (pq)->q[prec].len)
+#define pktq_pfull(pq, prec)            ((pq)->q[prec].len >= (pq)->q[prec].max)
+#define pktq_pempty(pq, prec)           ((pq)->q[prec].len == 0)
+
+#define pktq_ppeek(pq, prec)            ((pq)->q[prec].head)
+#define pktq_ppeek_tail(pq, prec)       ((pq)->q[prec].tail)
+
+extern void *pktq_penq(struct pktq *pq, int prec, void *p);
+extern void *pktq_penq_head(struct pktq *pq, int prec, void *p);
+extern void *pktq_pdeq(struct pktq *pq, int prec);
+extern void *pktq_pdeq_tail(struct pktq *pq, int prec);
+/* Empty the queue at particular precedence level */
+extern void pktq_pflush(osl_t * osh, struct pktq *pq, int prec, bool dir);
+/* Remove a specified packet from its queue */
+extern bool pktq_pdel(struct pktq *pq, void *p, int prec);
+
+/* operations on a set of precedences in packet queue */
+
+extern int pktq_mlen(struct pktq *pq, uint prec_bmp);
+extern void *pktq_mdeq(struct pktq *pq, uint prec_bmp, int *prec_out);
+
+/* operations on packet queue as a whole */
+
+#define pktq_len(pq)                    ((int)(pq)->len)
+#define pktq_max(pq)                    ((int)(pq)->max)
+#define pktq_avail(pq)                  ((int)((pq)->max - (pq)->len))
+#define pktq_full(pq)                   ((pq)->len >= (pq)->max)
+#define pktq_empty(pq)                  ((pq)->len == 0)
+
+/* operations for single precedence queues */
+#define pktenq(pq, p)		pktq_penq(((struct pktq *)pq), 0, (p))
+#define pktenq_head(pq, p)	pktq_penq_head(((struct pktq *)pq), 0, (p))
+#define pktdeq(pq)		pktq_pdeq(((struct pktq *)pq), 0)
+#define pktdeq_tail(pq)		pktq_pdeq_tail(((struct pktq *)pq), 0)
+#define pktqinit(pq, len) pktq_init(((struct pktq *)pq), 1, len)
+
+extern void pktq_init(struct pktq *pq, int num_prec, int max_len);
+/* prec_out may be NULL if caller is not interested in return value */
+extern void *pktq_deq(struct pktq *pq, int *prec_out);
+extern void *pktq_deq_tail(struct pktq *pq, int *prec_out);
+extern void *pktq_peek(struct pktq *pq, int *prec_out);
+extern void *pktq_peek_tail(struct pktq *pq, int *prec_out);
+extern void pktq_flush(osl_t * osh, struct pktq *pq, bool dir);	/* Empty the entire queue */
+
+/* externs */
+/* packet */
+extern uint pktcopy(osl_t * osh, void *p, uint offset, int len,
+		    uchar * buf);
+extern uint pktfrombuf(osl_t * osh, void *p, uint offset, int len,
+		       uchar * buf);
+extern uint pkttotlen(osl_t * osh, void *p);
+extern void *pktlast(osl_t * osh, void *p);
+extern uint pktsegcnt(osl_t * osh, void *p);
+
+/* Get priority from a packet and pass it back in scb (or equiv) */
+extern uint pktsetprio(void *pkt, bool update_vtag);
+#define	PKTPRIO_VDSCP	0x100	/* DSCP prio found after VLAN tag */
+#define	PKTPRIO_VLAN	0x200	/* VLAN prio found */
+#define	PKTPRIO_UPD	0x400	/* DSCP used to update VLAN prio */
+#define	PKTPRIO_DSCP	0x800	/* DSCP prio found */
+
+/* string */
+extern int BCMROMFN(bcm_atoi) (char *s);
+extern ulong BCMROMFN(bcm_strtoul) (char *cp, char **endp, uint base);
+extern char *BCMROMFN(bcmstrstr) (char *haystack, char *needle);
+extern char *BCMROMFN(bcmstrcat) (char *dest, const char *src);
+extern char *BCMROMFN(bcmstrncat) (char *dest, const char *src, uint size);
+extern ulong wchar2ascii(char *abuf, ushort * wbuf, ushort wbuflen,
+			 ulong abuflen);
+/* ethernet address */
+extern char *bcm_ether_ntoa(const struct ether_addr *ea, char *buf);
+extern int BCMROMFN(bcm_ether_atoe) (char *p, struct ether_addr * ea);
+
+/* ip address */
+struct ipv4_addr;
+extern char *bcm_ip_ntoa(struct ipv4_addr *ia, char *buf);
+
+/* delay */
+extern void bcm_mdelay(uint ms);
+/* variable access */
+extern char *getvar(char *vars, const char *name);
+extern int getintvar(char *vars, const char *name);
+extern uint getgpiopin(char *vars, char *pin_name, uint def_pin);
+#ifdef BCMDBG
+extern void prpkt(const char *msg, osl_t * osh, void *p0);
+#endif				/* BCMDBG */
+#ifdef BCMPERFSTATS
+extern void bcm_perf_enable(void);
+extern void bcmstats(char *fmt);
+extern void bcmlog(char *fmt, uint a1, uint a2);
+extern void bcmdumplog(char *buf, int size);
+extern int bcmdumplogent(char *buf, uint idx);
+#else
+#define bcm_perf_enable()
+#define bcmstats(fmt)
+#define	bcmlog(fmt, a1, a2)
+#define	bcmdumplog(buf, size)	*buf = '\0'
+#define	bcmdumplogent(buf, idx)	-1
+#endif				/* BCMPERFSTATS */
+
+#if defined(BCMTSTAMPEDLOGS)
+#define TSF_TICKS_PER_MS	1024
+/* Store a TSF timestamp and a log line in the log buffer */
+extern void bcmtslog(uint32 tstamp, char *fmt, uint a1, uint a2);
+/* Print out the log buffer with timestamps */
+extern void bcmprinttslogs(void);
+/* Print out a microsecond timestamp as "sec.ms.us " */
+extern void bcmprinttstamp(uint32 us);
+#else
+#define bcmtslog(tstamp, fmt, a1, a2)
+#define bcmprinttslogs()
+#define bcmprinttstamp(us)
+#endif				/* BCMTSTAMPEDLOGS */
+
+extern char *bcm_nvram_vars(uint * length);
+extern int bcm_nvram_cache(void *sih);
+
+/* Support for sharing code across in-driver iovar implementations.
+ * The intent is that a driver use this structure to map iovar names
+ * to its (private) iovar identifiers, and the lookup function to
+ * find the entry.  Macros are provided to map ids and get/set actions
+ * into a single number space for a switch statement.
+ */
+
+/* iovar structure */
+typedef struct bcm_iovar {
+    const char *name;		/* name for lookup and display */
+    uint16 varid;		/* id for switch */
+    uint16 flags;		/* driver-specific flag bits */
+    uint16 type;		/* base type of argument */
+    uint16 minlen;		/* min length for buffer vars */
+} bcm_iovar_t;
+
+/* varid definitions are per-driver, may use these get/set bits */
+
+/* IOVar action bits for id mapping */
+#define IOV_GET 0		/* Get an iovar */
+#define IOV_SET 1		/* Set an iovar */
+
+/* Varid to actionid mapping */
+#define IOV_GVAL(id)		((id)*2)
+#define IOV_SVAL(id)		(((id)*2)+IOV_SET)
+#define IOV_ISSET(actionid)	((actionid & IOV_SET) == IOV_SET)
+
+/* flags are per-driver based on driver attributes */
+
+extern const bcm_iovar_t *bcm_iovar_lookup(const bcm_iovar_t * table,
+					   const char *name);
+extern int bcm_iovar_lencheck(const bcm_iovar_t * table, void *arg,
+			      int len, bool set);
+
+#endif				/* BCMDRIVER */
+
+/* Base type definitions */
+#define IOVT_VOID	0	/* no value (implictly set only) */
+#define IOVT_BOOL	1	/* any value ok (zero/nonzero) */
+#define IOVT_INT8	2	/* integer values are range-checked */
+#define IOVT_UINT8	3	/* unsigned int 8 bits */
+#define IOVT_INT16	4	/* int 16 bits */
+#define IOVT_UINT16	5	/* unsigned int 16 bits */
+#define IOVT_INT32		6	/* int 32 bits */
+#define IOVT_UINT32	7	/* unsigned int 32 bits */
+#define IOVT_BUFFER	8	/* buffer is size-checked as per minlen */
+#define BCM_IOVT_VALID(type) (((unsigned int)(type)) <= IOVT_BUFFER)
+
+/* Initializer for IOV type strings */
+#define BCM_IOV_TYPE_INIT { \
+	"void", \
+	"bool", \
+	"int8", \
+	"uint8", \
+	"int16", \
+	"uint16", \
+	"int32", \
+	"uint32", \
+	"buffer", \
+	"" }
+
+#define BCM_IOVT_IS_INT(type) (\
+	(type == IOVT_BOOL) || \
+	(type == IOVT_INT8) || \
+	(type == IOVT_UINT8) || \
+	(type == IOVT_INT16) || \
+	(type == IOVT_UINT16) || \
+	(type == IOVT_INT32) || \
+	(type == IOVT_UINT32))
+
+/* ** driver/apps-shared section ** */
+
+#define BCME_STRLEN 		64	/* Max string length for BCM errors */
+#define VALID_BCMERROR(e)  ((e <= 0) && (e >= BCME_LAST))
+
+
+/*
+ * error codes could be added but the defined ones shouldn't be changed/deleted
+ * these error codes are exposed to the user code
+ * when ever a new error code is added to this list
+ * please update errorstring table with the related error string and
+ * update osl files with os specific errorcode map
+*/
+
+#define BCME_OK				0	/* Success */
+#define BCME_ERROR			-1	/* Error generic */
+#define BCME_BADARG			-2	/* Bad Argument */
+#define BCME_BADOPTION			-3	/* Bad option */
+#define BCME_NOTUP			-4	/* Not up */
+#define BCME_NOTDOWN			-5	/* Not down */
+#define BCME_NOTAP			-6	/* Not AP */
+#define BCME_NOTSTA			-7	/* Not STA  */
+#define BCME_BADKEYIDX			-8	/* BAD Key Index */
+#define BCME_RADIOOFF 			-9	/* Radio Off */
+#define BCME_NOTBANDLOCKED		-10	/* Not  band locked */
+#define BCME_NOCLK			-11	/* No Clock */
+#define BCME_BADRATESET			-12	/* BAD Rate valueset */
+#define BCME_BADBAND			-13	/* BAD Band */
+#define BCME_BUFTOOSHORT		-14	/* Buffer too short */
+#define BCME_BUFTOOLONG			-15	/* Buffer too long */
+#define BCME_BUSY			-16	/* Busy */
+#define BCME_NOTASSOCIATED		-17	/* Not Associated */
+#define BCME_BADSSIDLEN			-18	/* Bad SSID len */
+#define BCME_OUTOFRANGECHAN		-19	/* Out of Range Channel */
+#define BCME_BADCHAN			-20	/* Bad Channel */
+#define BCME_BADADDR			-21	/* Bad Address */
+#define BCME_NORESOURCE			-22	/* Not Enough Resources */
+#define BCME_UNSUPPORTED		-23	/* Unsupported */
+#define BCME_BADLEN			-24	/* Bad length */
+#define BCME_NOTREADY			-25	/* Not Ready */
+#define BCME_EPERM			-26	/* Not Permitted */
+#define BCME_NOMEM			-27	/* No Memory */
+#define BCME_ASSOCIATED			-28	/* Associated */
+#define BCME_RANGE			-29	/* Not In Range */
+#define BCME_NOTFOUND			-30	/* Not Found */
+#define BCME_WME_NOT_ENABLED		-31	/* WME Not Enabled */
+#define BCME_TSPEC_NOTFOUND		-32	/* TSPEC Not Found */
+#define BCME_ACM_NOTSUPPORTED		-33	/* ACM Not Supported */
+#define BCME_NOT_WME_ASSOCIATION	-34	/* Not WME Association */
+#define BCME_SDIO_ERROR			-35	/* SDIO Bus Error */
+#define BCME_DONGLE_DOWN		-36	/* Dongle Not Accessible */
+#define BCME_VERSION			-37	/* Incorrect version */
+#define BCME_LAST			BCME_VERSION
+
+/* These are collection of BCME Error strings */
+#define BCMERRSTRINGTABLE {		\
+	"OK",				\
+	"Undefined error",		\
+	"Bad Argument",			\
+	"Bad Option",			\
+	"Not up",			\
+	"Not down",			\
+	"Not AP",			\
+	"Not STA",			\
+	"Bad Key Index",		\
+	"Radio Off",			\
+	"Not band locked",		\
+	"No clock",			\
+	"Bad Rate valueset",		\
+	"Bad Band",			\
+	"Buffer too short",		\
+	"Buffer too long",		\
+	"Busy",				\
+	"Not Associated",		\
+	"Bad SSID len",			\
+	"Out of Range Channel",		\
+	"Bad Channel",			\
+	"Bad Address",			\
+	"Not Enough Resources",		\
+	"Unsupported",			\
+	"Bad length",			\
+	"Not Ready",			\
+	"Not Permitted",		\
+	"No Memory",			\
+	"Associated",			\
+	"Not In Range",			\
+	"Not Found",			\
+	"WME Not Enabled",		\
+	"TSPEC Not Found",		\
+	"ACM Not Supported",		\
+	"Not WME Association",		\
+	"SDIO Bus Error",		\
+	"Dongle Not Accessible",	\
+	"Incorrect version"	\
+}
+
+#ifndef ABS
+#define	ABS(a)			(((a) < 0)?-(a):(a))
+#endif				/* ABS */
+
+#ifndef MIN
+#define	MIN(a, b)		(((a) < (b))?(a):(b))
+#endif				/* MIN */
+
+#ifndef MAX
+#define	MAX(a, b)		(((a) > (b))?(a):(b))
+#endif				/* MAX */
+
+#define CEIL(x, y)		(((x) + ((y)-1)) / (y))
+#define	ROUNDUP(x, y)		((((x)+((y)-1))/(y))*(y))
+#define	ISALIGNED(a, x)		(((a) & ((x)-1)) == 0)
+#define ALIGN_ADDR(addr, boundary) (void *)(((uintptr)(addr) + (boundary) - 1) \
+	                                         & ~((boundary) - 1))
+#define	ISPOWEROF2(x)		((((x)-1)&(x)) == 0)
+#define VALID_MASK(mask)	!((mask) & ((mask) + 1))
+#ifndef OFFSETOF
+#define	OFFSETOF(type, member)	((uint)(uintptr)&((type *)0)->member)
+#endif				/* OFFSETOF */
+#ifndef ARRAYSIZE
+#define ARRAYSIZE(a)		(sizeof(a)/sizeof(a[0]))
+#endif
+
+/* bit map related macros */
+#ifndef setbit
+#ifndef NBBY			/* the BSD family defines NBBY */
+#define	NBBY	8		/* 8 bits per byte */
+#endif				/* #ifndef NBBY */
+#define	setbit(a, i)	(((uint8 *)a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a, i)	(((uint8 *)a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a, i)	(((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a, i)	((((const uint8 *)a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+#endif				/* setbit */
+
+#define	NBITS(type)	(sizeof(type) * 8)
+#define NBITVAL(nbits)	(1 << (nbits))
+#define MAXBITVAL(nbits)	((1 << (nbits)) - 1)
+#define	NBITMASK(nbits)	MAXBITVAL(nbits)
+#define MAXNBVAL(nbyte)	MAXBITVAL((nbyte) * 8)
+
+/* basic mux operation - can be optimized on several architectures */
+#define MUX(pred, true, false) ((pred) ? (true) : (false))
+
+/* modulo inc/dec - assumes x E [0, bound - 1] */
+#define MODDEC(x, bound) MUX((x) == 0, (bound) - 1, (x) - 1)
+#define MODINC(x, bound) MUX((x) == (bound) - 1, 0, (x) + 1)
+
+/* modulo inc/dec, bound = 2^k */
+#define MODDEC_POW2(x, bound) (((x) - 1) & ((bound) - 1))
+#define MODINC_POW2(x, bound) (((x) + 1) & ((bound) - 1))
+
+/* modulo add/sub - assumes x, y E [0, bound - 1] */
+#define MODADD(x, y, bound) \
+    MUX((x) + (y) >= (bound), (x) + (y) - (bound), (x) + (y))
+#define MODSUB(x, y, bound) \
+    MUX(((int)(x)) - ((int)(y)) < 0, (x) - (y) + (bound), (x) - (y))
+
+/* module add/sub, bound = 2^k */
+#define MODADD_POW2(x, y, bound) (((x) + (y)) & ((bound) - 1))
+#define MODSUB_POW2(x, y, bound) (((x) - (y)) & ((bound) - 1))
+
+/* crc defines */
+#define CRC8_INIT_VALUE  0xff	/* Initial CRC8 checksum value */
+#define CRC8_GOOD_VALUE  0x9f	/* Good final CRC8 checksum value */
+#define CRC16_INIT_VALUE 0xffff	/* Initial CRC16 checksum value */
+#define CRC16_GOOD_VALUE 0xf0b8	/* Good final CRC16 checksum value */
+#define CRC32_INIT_VALUE 0xffffffff	/* Initial CRC32 checksum value */
+#define CRC32_GOOD_VALUE 0xdebb20e3	/* Good final CRC32 checksum value */
+
+/* bcm_format_flags() bit description structure */
+typedef struct bcm_bit_desc {
+    uint32 bit;
+    const char *name;
+} bcm_bit_desc_t;
+
+/* tag_ID/length/value_buffer tuple */
+typedef struct bcm_tlv {
+    uint8 id;
+    uint8 len;
+    uint8 data[1];
+} bcm_tlv_t;
+
+/* Check that bcm_tlv_t fits into the given buflen */
+#define bcm_valid_tlv(elt, buflen) ((buflen) >= 2 && (int)(buflen) >= (int)(2 + (elt)->len))
+
+/* buffer length for ethernet address from bcm_ether_ntoa() */
+#define ETHER_ADDR_STR_LEN	18	/* 18-bytes of Ethernet address buffer length */
+
+/* unaligned load and store macros */
+#ifdef IL_BIGENDIAN
+static INLINE uint32 load32_ua(uint8 *a)
+{
+    return ((a[0] << 24) | (a[1] << 16) | (a[2] << 8) | a[3]);
+}
+
+static INLINE void store32_ua(uint8 *a, uint32 v)
+{
+    a[0] = (v >> 24) & 0xff;
+    a[1] = (v >> 16) & 0xff;
+    a[2] = (v >> 8) & 0xff;
+    a[3] = v & 0xff;
+}
+
+static INLINE uint16 load16_ua(uint8 *a)
+{
+    return ((a[0] << 8) | a[1]);
+}
+
+static INLINE void store16_ua(uint8 *a, uint16 v)
+{
+    a[0] = (v >> 8) & 0xff;
+    a[1] = v & 0xff;
+}
+
+#else				/* IL_BIGENDIAN */
+
+static INLINE uint32 load32_ua(uint8 *a)
+{
+    return ((a[3] << 24) | (a[2] << 16) | (a[1] << 8) | a[0]);
+}
+
+static INLINE void store32_ua(uint8 *a, uint32 v)
+{
+    a[3] = (v >> 24) & 0xff;
+    a[2] = (v >> 16) & 0xff;
+    a[1] = (v >> 8) & 0xff;
+    a[0] = v & 0xff;
+}
+
+static INLINE uint16 load16_ua(uint8 *a)
+{
+    return ((a[1] << 8) | a[0]);
+}
+
+static INLINE void store16_ua(uint8 *a, uint16 v)
+{
+    a[1] = (v >> 8) & 0xff;
+    a[0] = v & 0xff;
+}
+
+#endif				/* IL_BIGENDIAN */
+
+/* externs */
+/* crc */
+extern uint8 BCMROMFN(hndcrc8) (uint8 * p, uint nbytes, uint8 crc);
+extern uint16 BCMROMFN(hndcrc16) (uint8 * p, uint nbytes, uint16 crc);
+extern uint32 BCMROMFN(hndcrc32) (uint8 * p, uint nbytes, uint32 crc);
+/* format/print */
+#if defined(BCMDBG) || defined(BCMDBG_ERR) || defined(WLMSG_PRHDRS) || \
+    defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC) || defined(BCMDBG_DUMP)
+extern int bcm_format_flags(const bcm_bit_desc_t * bd, uint32 flags,
+			    char *buf, int len);
+extern int bcm_format_hex(char *str, const void *bytes, int len);
+extern void prhex(const char *msg, uchar *buf, uint len);
+#endif
+#ifdef BCMDBG
+extern void deadbeef(void *p, uint len);
+#endif
+extern char *bcm_brev_str(uint32 brev, char *buf);
+extern void printbig(char *buf);
+
+/* IE parsing */
+extern bcm_tlv_t *BCMROMFN(bcm_next_tlv) (bcm_tlv_t *elt, int *buflen);
+extern bcm_tlv_t *BCMROMFN(bcm_parse_tlvs) (void *buf, int buflen,
+					    uint key);
+extern bcm_tlv_t *BCMROMFN(bcm_parse_ordered_tlvs) (void *buf, int buflen,
+						    uint key);
+
+/* bcmerror */
+extern const char *bcmerrorstr(int bcmerror);
+
+/* multi-bool data type: set of bools, mbool is true if any is set */
+typedef uint32 mbool;
+#define mboolset(mb, bit)		((mb) |= (bit))	/* set one bool */
+#define mboolclr(mb, bit)		((mb) &= ~(bit))	/* clear one bool */
+#define mboolisset(mb, bit)		(((mb) & (bit)) != 0)	/* TRUE if one bool is set */
+#define	mboolmaskset(mb, mask, val)	((mb) = (((mb) & ~(mask)) | (val)))
+
+/* power conversion */
+extern uint16 BCMROMFN(bcm_qdbm_to_mw) (uint8 qdbm);
+extern uint8 BCMROMFN(bcm_mw_to_qdbm) (uint16 mw);
+
+/* generic datastruct to help dump routines */
+struct fielddesc {
+    const char *nameandfmt;
+    uint32 offset;
+    uint32 len;
+};
+
+extern void bcm_binit(struct bcmstrbuf *b, char *buf, uint size);
+extern int bcm_bprintf(struct bcmstrbuf *b, const char *fmt, ...);
+
+typedef uint32(*bcmutl_rdreg_rtn) (void *arg0, uint arg1, uint32 offset);
+extern uint bcmdumpfields(bcmutl_rdreg_rtn func_ptr, void *arg0, uint arg1,
+			  struct fielddesc *str, char *buf,
+			  uint32 bufsize);
+
+extern uint bcm_mkiovar(char *name, char *data, uint datalen, char *buf,
+			uint len);
+extern uint BCMROMFN(bcm_bitcount) (uint8 *bitmap, uint bytelength);
+
+#ifdef BCMDBG_PKT		/* pkt logging for debugging */
+#define PKTLIST_SIZE 1000
+typedef struct {
+    void *list[PKTLIST_SIZE];	/* List of pointers to packets */
+    uint count;			/* Total count of the packets */
+} pktlist_info_t;
+
+extern void pktlist_add(pktlist_info_t *pktlist, void *p);
+extern void pktlist_remove(pktlist_info_t *pktlist, void *p);
+extern char *pktlist_dump(pktlist_info_t *pktlist, char *buf);
+#endif				/* BCMDBG_PKT */
+
+#endif				/* _bcmutils_h_ */
diff --git a/include/asm-mips/bcmsi/cfe_api.h b/include/asm-mips/bcmsi/cfe_api.h
new file mode 100644
index 0000000..4164d04
--- /dev/null
+++ b/include/asm-mips/bcmsi/cfe_api.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*   */
+
+/*
+ * Copyright 2000, 2001, 2002
+ * Broadcom Corporation. All rights reserved.
+ *
+ * This software is furnished under license and may be used and copied only
+ * in accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * modified or unmodified copies of this software in source and/or binary
+ * form. No title or ownership is transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and
+ *    retain this copyright notice and list of conditions as they appear in
+ *    the source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of
+ *    Broadcom Corporation.  The "Broadcom Corporation" name may not be
+ *    used to endorse or promote products derived from this software
+ *    without the prior written permission of Broadcom Corporation.
+ *
+ * 3) THIS SOFTWARE IS PROVIDED "AS-IS" AND ANY EXPRESS OR IMPLIED
+ *    WARRANTIES, INCLUDING BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
+ *    NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM BE LIABLE
+ *    FOR ANY DAMAGES WHATSOEVER, AND IN PARTICULAR, BROADCOM SHALL NOT BE
+ *    LIABLE FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ *    BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ *    OR OTHERWISE), EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*  *********************************************************************
+    *
+    *  Broadcom Common Firmware Environment (CFE)
+    *
+    *  Device function prototypes		File: cfe_api.h
+    *
+    *  This file contains declarations for doing callbacks to
+    *  cfe from an application.  It should be the only header
+    *  needed by the application to use this library
+    *
+    *  Authors:  Mitch Lichtenberg, Chris Demetriou
+    *
+    ********************************************************************* */
+
+#ifndef CFE_API_H
+#define CFE_API_H
+
+/*
+ * Apply customizations here for different OSes.  These need to:
+ *	* typedef uint64_t, int64_t, intptr_t, uintptr_t.
+ *	* define cfe_strlen() if use of an existing function is desired.
+ *	* define CFE_API_IMPL_NAMESPACE if API functions are to use
+ *	  names in the implementation namespace.
+ * Also, optionally, if the build environment does not do so automatically,
+ * CFE_API_* can be defined here as desired.
+ */
+/* Begin customization. */
+#include "lib_types.h"
+/* End customization. */
+
+
+/*  *********************************************************************
+    *  Constants
+    ********************************************************************* */
+
+/* Seal indicating CFE's presence, passed to user program. */
+#define CFE_EPTSEAL 0x43464531
+
+#define CFE_MI_RESERVED	0	/* memory is reserved, do not use */
+#define CFE_MI_AVAILABLE 1	/* memory is available */
+
+#define CFE_FLG_WARMSTART     0x00000001
+#define CFE_FLG_FULL_ARENA    0x00000001
+#define CFE_FLG_ENV_PERMANENT 0x00000001
+
+#define CFE_CPU_CMD_START 1
+#define CFE_CPU_CMD_STOP 0
+
+#define CFE_STDHANDLE_CONSOLE	0
+
+#define CFE_DEV_NETWORK 	1
+#define CFE_DEV_DISK		2
+#define CFE_DEV_FLASH		3
+#define CFE_DEV_SERIAL		4
+#define CFE_DEV_CPU		5
+#define CFE_DEV_NVRAM		6
+#define CFE_DEV_CLOCK		7
+#define CFE_DEV_OTHER		8
+#define CFE_DEV_MASK		0x0F
+
+#define CFE_CACHE_FLUSH_D	1
+#define CFE_CACHE_INVAL_I	2
+#define CFE_CACHE_INVAL_D	4
+#define CFE_CACHE_INVAL_L2	8
+
+#define CFE_FWI_64BIT		0x00000001
+#define CFE_FWI_32BIT		0x00000002
+#define CFE_FWI_RELOC		0x00000004
+#define CFE_FWI_UNCACHED	0x00000008
+#define CFE_FWI_MULTICPU	0x00000010
+#define CFE_FWI_FUNCSIM	0x00000020
+#define CFE_FWI_RTLSIM		0x00000040
+
+typedef struct {
+    int64_t fwi_version;	/* major, minor, eco version */
+    int64_t fwi_totalmem;	/* total installed mem */
+    int64_t fwi_flags;		/* various flags */
+    int64_t fwi_boardid;	/* board ID */
+    int64_t fwi_bootarea_va;	/* VA of boot area */
+    int64_t fwi_bootarea_pa;	/* PA of boot area */
+    int64_t fwi_bootarea_size;	/* size of boot area */
+} cfe_fwinfo_t;
+
+
+/*
+ * cfe_strlen is handled specially: If already defined, it has been
+ * overridden in this environment with a standard strlen-like function.
+ */
+#ifdef cfe_strlen
+# define CFE_API_STRLEN_CUSTOM
+#else
+# ifdef CFE_API_IMPL_NAMESPACE
+#  define cfe_strlen(a)			__cfe_strlen(a)
+# endif
+int cfe_strlen(char *name);
+#endif
+
+/*
+ * Defines and prototypes for functions which take no arguments.
+ */
+#ifdef CFE_API_IMPL_NAMESPACE
+int64_t __cfe_getticks(void);
+#define cfe_getticks()			__cfe_getticks()
+#else
+int64_t cfe_getticks(void);
+#endif
+
+/*
+ * Defines and prototypes for the rest of the functions.
+ */
+#ifdef CFE_API_IMPL_NAMESPACE
+#define cfe_close(a)			__cfe_close(a)
+#define cfe_cpu_start(a,b,c,d,e)	__cfe_cpu_start(a,b,c,d,e)
+#define cfe_cpu_stop(a)			__cfe_cpu_stop(a)
+#define cfe_enumenv(a,b,d,e,f)		__cfe_enumenv(a,b,d,e,f)
+#define cfe_enummem(a,b,c,d,e)		__cfe_enummem(a,b,c,d,e)
+#define cfe_exit(a,b)			__cfe_exit(a,b)
+#define cfe_flushcache(a)		__cfe_cacheflush(a)
+#define cfe_getdevinfo(a)		__cfe_getdevinfo(a)
+#define cfe_getenv(a,b,c)		__cfe_getenv(a,b,c)
+#define cfe_getfwinfo(a)		__cfe_getfwinfo(a)
+#define cfe_getstdhandle(a)	__cfe_getstdhandle(a)
+#define cfe_init(a,b)			__cfe_init(a,b)
+#define cfe_inpstat(a)			__cfe_inpstat(a)
+#define cfe_ioctl(a,b,c,d,e,f)	__cfe_ioctl(a,b,c,d,e,f)
+#define cfe_open(a)			__cfe_open(a)
+#define cfe_read(a,b,c)		__cfe_read(a,b,c)
+#define cfe_readblk(a,b,c,d)	__cfe_readblk(a,b,c,d)
+#define cfe_setenv(a,b)		__cfe_setenv(a,b)
+#define cfe_write(a,b,c)		__cfe_write(a,b,c)
+#define cfe_writeblk(a,b,c,d)	__cfe_writeblk(a,b,c,d)
+#endif				/* CFE_API_IMPL_NAMESPACE */
+
+int cfe_close(int handle);
+int cfe_cpu_start(int cpu, void (*fn) (void), long sp, long gp, long a1);
+int cfe_cpu_stop(int cpu);
+int cfe_enumenv(int idx, char *name, int namelen, char *val, int vallen);
+int cfe_enummem(int idx, int flags, uint64_t *start, uint64_t *length,
+		uint64_t *type);
+int cfe_exit(int warm, int status);
+int cfe_flushcache(int flg);
+int cfe_getdevinfo(char *name);
+int cfe_getenv(char *name, char *dest, int destlen);
+int cfe_getfwinfo(cfe_fwinfo_t *info);
+int cfe_getstdhandle(int flg);
+int cfe_init(uint64_t handle, uint64_t ept);
+int cfe_inpstat(int handle);
+int cfe_ioctl(int handle, unsigned int ioctlnum, unsigned char *buffer,
+	      int length, int *retlen, uint64_t offset);
+int cfe_open(char *name);
+int cfe_read(int handle, unsigned char *buffer, int length);
+int cfe_readblk(int handle, int64_t offset, unsigned char *buffer,
+		int length);
+int cfe_setenv(char *name, char *val);
+int cfe_write(int handle, unsigned char *buffer, int length);
+int cfe_writeblk(int handle, int64_t offset, unsigned char *buffer,
+		 int length);
+
+#endif				/* CFE_API_H */
diff --git a/include/asm-mips/bcmsi/cfe_error.h b/include/asm-mips/bcmsi/cfe_error.h
new file mode 100644
index 0000000..794e315
--- /dev/null
+++ b/include/asm-mips/bcmsi/cfe_error.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*   */
+
+/*
+ * Copyright 2000, 2001, 2002
+ * Broadcom Corporation. All rights reserved.
+ *
+ * This software is furnished under license and may be used and copied only
+ * in accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * modified or unmodified copies of this software in source and/or binary
+ * form. No title or ownership is transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and
+ *    retain this copyright notice and list of conditions as they appear in
+ *    the source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of
+ *    Broadcom Corporation.  The "Broadcom Corporation" name may not be
+ *    used to endorse or promote products derived from this software
+ *    without the prior written permission of Broadcom Corporation.
+ *
+ * 3) THIS SOFTWARE IS PROVIDED "AS-IS" AND ANY EXPRESS OR IMPLIED
+ *    WARRANTIES, INCLUDING BUT NOT LIMITED TO, ANY IMPLIED WARRANTIES OF
+ *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
+ *    NON-INFRINGEMENT ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM BE LIABLE
+ *    FOR ANY DAMAGES WHATSOEVER, AND IN PARTICULAR, BROADCOM SHALL NOT BE
+ *    LIABLE FOR DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ *    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ *    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ *    BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ *    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ *    OR OTHERWISE), EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*  *********************************************************************
+    *
+    *  Broadcom Common Firmware Environment (CFE)
+    *
+    *  Error codes				File: cfe_error.h
+    *
+    *  CFE's global error code list is here.
+    *
+    *  Author:  Mitch Lichtenberg
+    *
+    ********************************************************************* */
+
+
+#define CFE_OK			 0
+#define CFE_ERR                 -1	/* generic error */
+#define CFE_ERR_INV_COMMAND	-2
+#define CFE_ERR_EOF		-3
+#define CFE_ERR_IOERR		-4
+#define CFE_ERR_NOMEM		-5
+#define CFE_ERR_DEVNOTFOUND	-6
+#define CFE_ERR_DEVOPEN		-7
+#define CFE_ERR_INV_PARAM	-8
+#define CFE_ERR_ENVNOTFOUND	-9
+#define CFE_ERR_ENVREADONLY	-10
+
+#define CFE_ERR_NOTELF		-11
+#define CFE_ERR_NOT32BIT 	-12
+#define CFE_ERR_WRONGENDIAN 	-13
+#define CFE_ERR_BADELFVERS 	-14
+#define CFE_ERR_NOTMIPS 	-15
+#define CFE_ERR_BADELFFMT 	-16
+#define CFE_ERR_BADADDR 	-17
+
+#define CFE_ERR_FILENOTFOUND	-18
+#define CFE_ERR_UNSUPPORTED	-19
+
+#define CFE_ERR_HOSTUNKNOWN	-20
+
+#define CFE_ERR_TIMEOUT		-21
+
+#define CFE_ERR_PROTOCOLERR	-22
+
+#define CFE_ERR_NETDOWN		-23
+#define CFE_ERR_NONAMESERVER	-24
+
+#define CFE_ERR_NOHANDLES		-25
+#define CFE_ERR_ALREADYBOUND	-26
+
+#define CFE_ERR_CANNOTSET	-27
+#define CFE_ERR_NOMORE		-28
+#define CFE_ERR_BADFILESYS	-29
+#define CFE_ERR_FSNOTAVAIL	-30
+
+#define CFE_ERR_INVBOOTBLOCK	-31
+#define CFE_ERR_WRONGDEVTYPE	-32
+#define CFE_ERR_BBCHECKSUM		-33
+#define CFE_ERR_BOOTPROGCHKSUM	-34
+
+#define CFE_ERR_LDRNOTAVAIL	-35
+
+#define CFE_ERR_NOTREADY		-36
+
+#define CFE_ERR_GETMEM			-37
+#define CFE_ERR_SETMEM			-38
+
+#define CFE_ERR_NOTCONN		-39
+#define CFE_ERR_ADDRINUSE		-40
diff --git a/include/asm-mips/bcmsi/hndchipc.h b/include/asm-mips/bcmsi/hndchipc.h
new file mode 100644
index 0000000..30ddabe
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndchipc.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * HND SiliconBackplane chipcommon support.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _hndchipc_h_
+#define _hndchipc_h_
+
+typedef void (*si_serial_init_fn) (void *regs, uint irq, uint baud_base,
+				   uint reg_shift);
+
+extern void si_serial_init(si_t *sih, si_serial_init_fn add,
+			   uint32 baudrate);
+
+extern void *hnd_jtagm_init(si_t *sih, uint clkd, bool exttap);
+extern void hnd_jtagm_disable(osl_t *osh, void *h);
+extern uint32 jtag_rwreg(osl_t *osh, void *h, uint32 ir, uint32 dr);
+
+typedef void (*cc_isr_fn) (void *cbdata, uint32 ccintst);
+
+extern bool si_cc_register_isr(si_t *sih, cc_isr_fn isr, uint32 ccintmask,
+			       void *cbdata);
+extern void si_cc_isr(si_t *sih, chipcregs_t *regs);
+
+#endif				/* _hndchipc_h_ */
diff --git a/include/asm-mips/bcmsi/hndcpu.h b/include/asm-mips/bcmsi/hndcpu.h
new file mode 100644
index 0000000..54792f1
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndcpu.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * HND SiliconBackplane MIPS/ARM cores software interface.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _hndcpu_h_
+#define _hndcpu_h_
+
+#if defined(mips)
+#include "hndmips.h"
+#elif defined(__arm__) || defined(__thumb__) || defined(__thumb2__)
+#include <hndarm.h>
+#endif
+
+extern uint si_irq(si_t *sih);
+extern uint32 si_cpu_clock(si_t *sih);
+extern uint32 si_mem_clock(si_t *sih);
+extern void hnd_cpu_wait(si_t *sih);
+extern void hnd_cpu_jumpto(void *addr);
+extern void hnd_cpu_reset(si_t *sih);
+
+#endif				/* _hndcpu_h_ */
diff --git a/include/asm-mips/bcmsi/hnddma.h b/include/asm-mips/bcmsi/hnddma.h
new file mode 100644
index 0000000..9319638
--- /dev/null
+++ b/include/asm-mips/bcmsi/hnddma.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Generic Broadcom Home Networking Division (HND) DMA engine SW interface
+ * This supports the following chips: BCM42xx, 44xx, 47xx .
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef	_hnddma_h_
+#define	_hnddma_h_
+
+typedef const struct hnddma_pub hnddma_t;
+
+/* dma function type */
+typedef void (*di_detach_t) (hnddma_t *dmah);
+typedef bool(*di_txreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxreset_t) (hnddma_t *dmah);
+typedef bool(*di_rxidle_t) (hnddma_t *dmah);
+typedef void (*di_txinit_t) (hnddma_t *dmah);
+typedef bool(*di_txenabled_t) (hnddma_t *dmah);
+typedef void (*di_rxinit_t) (hnddma_t *dmah);
+typedef void (*di_txsuspend_t) (hnddma_t *dmah);
+typedef void (*di_txresume_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspended_t) (hnddma_t *dmah);
+typedef bool(*di_txsuspendedidle_t) (hnddma_t *dmah);
+typedef int (*di_txfast_t) (hnddma_t *dmah, void *p, bool commit);
+typedef void (*di_fifoloopbackenable_t) (hnddma_t *dmah, bool on);
+typedef bool(*di_txstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxstopped_t) (hnddma_t *dmah);
+typedef bool(*di_rxenable_t) (hnddma_t *dmah);
+typedef bool(*di_rxenabled_t) (hnddma_t *dmah);
+typedef void *(*di_rx_t) (hnddma_t *dmah);
+typedef void (*di_rxfill_t) (hnddma_t *dmah);
+typedef void (*di_txreclaim_t) (hnddma_t *dmah, bool forceall);
+typedef void (*di_rxreclaim_t) (hnddma_t *dmah);
+typedef uintptr(*di_getvar_t) (hnddma_t *dmah, const char *name);
+typedef void *(*di_getnexttxp_t) (hnddma_t *dmah, bool forceall);
+typedef void *(*di_getnextrxp_t) (hnddma_t *dmah, bool forceall);
+typedef void *(*di_peeknexttxp_t) (hnddma_t *dmah);
+typedef void (*di_txblock_t) (hnddma_t *dmah);
+typedef void (*di_txunblock_t) (hnddma_t *dmah);
+typedef uint(*di_txactive_t) (hnddma_t *dmah);
+typedef void (*di_txrotate_t) (hnddma_t *dmah);
+typedef void (*di_counterreset_t) (hnddma_t *dmah);
+typedef char *(*di_dump_t) (hnddma_t *dmah, struct bcmstrbuf *b,
+			    bool dumpring);
+typedef char *(*di_dumptx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
+			      bool dumpring);
+typedef char *(*di_dumprx_t) (hnddma_t *dmah, struct bcmstrbuf *b,
+			      bool dumpring);
+typedef uint(*di_rxactive_t) (hnddma_t *dmah);
+typedef uint(*di_txpending_t) (hnddma_t *dmah);
+typedef void (*di_rxsephdrctrl_t) (hnddma_t *dmah, bool enable,
+				   uint memtype, uint size);
+
+/* dma opsvec */
+typedef struct di_fcn_s {
+    di_detach_t detach;
+    di_txinit_t txinit;
+    di_txreset_t txreset;
+    di_txenabled_t txenabled;
+    di_txsuspend_t txsuspend;
+    di_txresume_t txresume;
+    di_txsuspended_t txsuspended;
+    di_txsuspendedidle_t txsuspendedidle;
+    di_txfast_t txfast;
+    di_txstopped_t txstopped;
+    di_txreclaim_t txreclaim;
+    di_getnexttxp_t getnexttxp;
+    di_peeknexttxp_t peeknexttxp;
+    di_txblock_t txblock;
+    di_txunblock_t txunblock;
+    di_txactive_t txactive;
+    di_txrotate_t txrotate;
+
+    di_rxinit_t rxinit;
+    di_rxreset_t rxreset;
+    di_rxidle_t rxidle;
+    di_rxstopped_t rxstopped;
+    di_rxenable_t rxenable;
+    di_rxenabled_t rxenabled;
+    di_rx_t rx;
+    di_rxfill_t rxfill;
+    di_rxreclaim_t rxreclaim;
+    di_getnextrxp_t getnextrxp;
+
+    di_fifoloopbackenable_t fifoloopbackenable;
+    di_getvar_t d_getvar;
+    di_counterreset_t counterreset;
+    di_dump_t dump;
+    di_dumptx_t dumptx;
+    di_dumprx_t dumprx;
+    di_rxactive_t rxactive;
+    di_txpending_t txpending;
+    di_rxsephdrctrl_t rxsephdrctrl;
+    uint endnum;
+} di_fcn_t;
+
+/*
+ * Exported data structure (read-only)
+ */
+/* export structure */
+struct hnddma_pub {
+    di_fcn_t di_fn;		/* DMA function pointers */
+    uint txavail;		/* # free tx descriptors */
+
+    /* rx error counters */
+    uint rxgiants;		/* rx giant frames */
+    uint rxnobuf;		/* rx out of dma descriptors */
+    /* tx error counters */
+    uint txnobuf;		/* tx out of dma descriptors */
+};
+
+
+extern hnddma_t *dma_attach(osl_t *osh, char *name, si_t *sih,
+			    void *dmaregstx, void *dmaregsrx, uint ntxd,
+			    uint nrxd, uint rxbufsize, uint nrxpost,
+			    uint rxoffset, uint *msg_level, uint pkt_mem,
+			    uint pkthdr_mem, uint en_rxsephdr);
+#define dma_detach(di)			((di)->di_fn.detach(di))
+#define dma_txreset(di)			((di)->di_fn.txreset(di))
+#define dma_rxreset(di)			((di)->di_fn.rxreset(di))
+#define dma_rxidle(di)			((di)->di_fn.rxidle(di))
+#define dma_txinit(di)                  ((di)->di_fn.txinit(di))
+#define dma_txenabled(di)               ((di)->di_fn.txenabled(di))
+#define dma_rxinit(di)                  ((di)->di_fn.rxinit(di))
+#define dma_txsuspend(di)               ((di)->di_fn.txsuspend(di))
+#define dma_txresume(di)                ((di)->di_fn.txresume(di))
+#define dma_txsuspended(di)             ((di)->di_fn.txsuspended(di))
+#define dma_txsuspendedidle(di)         ((di)->di_fn.txsuspendedidle(di))
+#define dma_txfast(di, p, commit)	((di)->di_fn.txfast(di, p, commit))
+#define dma_fifoloopbackenable(di, on)      ((di)->di_fn.fifoloopbackenable(di, on))
+#define dma_txstopped(di)               ((di)->di_fn.txstopped(di))
+#define dma_rxstopped(di)               ((di)->di_fn.rxstopped(di))
+#define dma_rxenable(di)                ((di)->di_fn.rxenable(di))
+#define dma_rxenabled(di)               ((di)->di_fn.rxenabled(di))
+#define dma_rx(di)                      ((di)->di_fn.rx(di))
+#define dma_rxfill(di)                  ((di)->di_fn.rxfill(di))
+#define dma_txreclaim(di, forceall)	((di)->di_fn.txreclaim(di, forceall))
+#define dma_rxreclaim(di)               ((di)->di_fn.rxreclaim(di))
+#define dma_getvar(di, name)		((di)->di_fn.d_getvar(di, name))
+#define dma_getnexttxp(di, forceall)    ((di)->di_fn.getnexttxp(di, forceall))
+#define dma_getnextrxp(di, forceall)    ((di)->di_fn.getnextrxp(di, forceall))
+#define dma_peeknexttxp(di)             ((di)->di_fn.peeknexttxp(di))
+#define dma_txblock(di)                 ((di)->di_fn.txblock(di))
+#define dma_txunblock(di)               ((di)->di_fn.txunblock(di))
+#define dma_txactive(di)                ((di)->di_fn.txactive(di))
+#define dma_rxactive(di)                ((di)->di_fn.rxactive(di))
+#define dma_txrotate(di)                ((di)->di_fn.txrotate(di))
+#define dma_counterreset(di)            ((di)->di_fn.counterreset(di))
+#define dma_txpending(di)		((di)->di_fn.txpending(di))
+#define dma_rxsephdrctrl(di, enable, memtype, size)            ((di)->di_fn.rxsephdrctrl(di, enable, memtype, size))
+#if defined(BCMDBG) || defined(BCMDBG_DUMP)
+#define dma_dump(di, buf, dumpring)	((di)->di_fn.dump(di, buf, dumpring))
+#define dma_dumptx(di, buf, dumpring)	((di)->di_fn.dumptx(di, buf, dumpring))
+#define dma_dumprx(di, buf, dumpring)	((di)->di_fn.dumprx(di, buf, dumpring))
+#endif
+
+/* return addresswidth allowed
+ * This needs to be done after SB attach but before dma attach.
+ * SB attach provides ability to probe backplane and dma core capabilities
+ * This info is needed by DMA_ALLOC_CONSISTENT in dma attach
+ */
+extern uint dma_addrwidth(si_t *sih, void *dmaregs);
+
+/* pio helpers */
+extern void dma_txpioloopback(osl_t *osh, dma32regs_t *);
+
+
+#define	RXSEPHDRSZ		64	/* rx separate header size */
+
+#endif				/* _hnddma_h_ */
diff --git a/include/asm-mips/bcmsi/hndmips.h b/include/asm-mips/bcmsi/hndmips.h
new file mode 100644
index 0000000..c8b0f7d
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndmips.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * HND SiliconBackplane MIPS core software interface.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _hndmips_h_
+#define _hndmips_h_
+
+extern void si_mips_init(si_t *sih, uint shirq_map_base);
+extern bool si_mips_setclock(si_t *sih, uint32 mipsclock, uint32 sbclock,
+			     uint32 pciclock);
+extern void enable_pfc(uint32 mode);
+extern uint32 si_memc_get_ncdl(si_t *sih);
+
+#if defined(BCMINTERNAL) || defined (BCMPERFSTATS)
+/* enable counting - exclusive version. Only one set of counters allowed at a time */
+extern void hndmips_perf_cyclecount_enable(void);
+extern void hndmips_perf_instrcount_enable(void);
+extern void hndmips_perf_icachecount_enable(void);
+extern void hndmips_perf_dcachecount_enable(void);
+/* start and stop counting */
+#define hndmips_perf_start01() \
+	MTC0(C0_PERFORMANCE, 4, MFC0(C0_PERFORMANCE, 4) | 0x80008000)
+#define hndmips_perf_stop01() \
+	MTC0(C0_PERFORMANCE, 4, MFC0(C0_PERFORMANCE, 4) & ~0x80008000)
+/* retrieve coutners - counters *decrement* */
+#define hndmips_perf_read0() -(long)(MFC0(C0_PERFORMANCE, 0))
+#define hndmips_perf_read1() -(long)(MFC0(C0_PERFORMANCE, 1))
+#define hndmips_perf_read2() -(long)(MFC0(C0_PERFORMANCE, 2))
+/* enable counting - modular version. Each counters can be enabled separately. */
+extern void hndmips_perf_icache_hit_enable(void);
+extern void hndmips_perf_icache_miss_enable(void);
+extern uint32 hndmips_perf_read_instrcount(void);
+extern uint32 hndmips_perf_read_cache_miss(void);
+extern uint32 hndmips_perf_read_cache_hit(void);
+#endif				/*  defined(BCMINTERNAL) || defined (BCMPERFSTATS) */
+
+#endif				/* _hndmips_h_ */
diff --git a/include/asm-mips/bcmsi/hndpci.h b/include/asm-mips/bcmsi/hndpci.h
new file mode 100644
index 0000000..8b1394f
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndpci.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * HND SiliconBackplane PCI core software interface.
+ *
+ *  
+ * $Copyright Open Broadcom Corporation$
+ */
+
+#ifndef _hndpci_h_
+#define _hndpci_h_
+
+/* Starting bus for secondary PCIE port */
+#define PCIE_PORT1_BUS_START    (17)
+
+/* Host bridge */
+#define PCIE_PORT0_HB_BUS       (1)
+#define PCIE_PORT1_HB_BUS       (17)
+
+/* PCIE mapped addresses per port */
+#define SI_PCI_MEM(p)           ((p)? SI_PCI1_MEM : SI_PCI0_MEM)
+#define SI_PCI_CFG(p)           ((p)? SI_PCI1_CFG : SI_PCI0_CFG)
+#define SI_PCIE_DMA_HIGH(p)     ((p)? SI_PCIE1_DMA_H32 : SI_PCIE_DMA_H32)
+
+/* Determine actual port by bus number */
+#define PCIE_GET_PORT_BY_BUS(bus)       \
+    ((bus) >= PCIE_PORT1_BUS_START ? 1 : 0)
+
+/* Check if the given bus has a host bridge */
+#define PCIE_IS_BUS_HOST_BRIDGE(bus)    \
+    ((bus == PCIE_PORT0_HB_BUS) || (bus == PCIE_PORT1_HB_BUS))
+
+/* Get bus number that has a host bridge by given port */
+#define PCIE_GET_HOST_BRIDGE_BUS(port)   \
+    ((port)? PCIE_PORT1_HB_BUS : PCIE_PORT0_HB_BUS)
+
+
+extern int hndpci_read_config(si_t *sih, uint bus, uint dev, uint func,
+			      uint off, void *buf, int len);
+extern int extpci_read_config(si_t *sih, uint bus, uint dev, uint func,
+			      uint off, void *buf, int len);
+extern int hndpci_write_config(si_t *sih, uint bus, uint dev, uint func,
+			       uint off, void *buf, int len);
+extern int extpci_write_config(si_t *sih, uint bus, uint dev, uint func,
+			       uint off, void *buf, int len);
+extern void hndpci_ban(uint16 core, uint8 unit);
+extern int hndpci_init(si_t *sih);
+extern int hndpci_init_pci(si_t *sih, uint8 port);
+extern void hndpci_init_cores(si_t *sih);
+extern void hndpci_arb_park(si_t *sih, uint parkid);
+
+#define PCI_PARK_NVRAM    0xff
+#define PCIE_ROM_ADDRESS_ENABLE     0x1
+
+#endif				/* _hndpci_h_ */
diff --git a/include/asm-mips/bcmsi/hndpmu.h b/include/asm-mips/bcmsi/hndpmu.h
new file mode 100644
index 0000000..3ff8dac
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndpmu.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * HND SiliconBackplane PMU support.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _hndpmu_h_
+#define _hndpmu_h_
+
+#if !defined(BCMDONGLEHOST)
+#define SET_LDO_VOLTAGE_LDO1	1
+#define SET_LDO_VOLTAGE_LDO2	2
+#define SET_LDO_VOLTAGE_LDO3	3
+#define SET_LDO_VOLTAGE_PAREF	4
+#define SET_LDO_VOLTAGE_CLDO_PWM	5
+#define SET_LDO_VOLTAGE_CLDO_BURST	6
+#define SET_LDO_VOLTAGE_CBUCK_PWM	7
+#define SET_LDO_VOLTAGE_CBUCK_BURST	8
+
+extern void si_pmu_init(si_t *sih, osl_t *osh);
+extern void si_pmu_chip_init(si_t *sih, osl_t *osh);
+extern void si_pmu_pll_init(si_t *sih, osl_t *osh, uint32 xtalfreq);
+extern void si_pmu_res_init(si_t *sih, osl_t *osh);
+extern void si_pmu_swreg_init(si_t *sih, osl_t *osh);
+
+extern uint32 si_pmu_force_ilp(si_t *sih, osl_t *osh, bool force);
+
+extern uint32 si_pmu_si_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_cpu_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_mem_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_alp_clock(si_t *sih, osl_t *osh);
+extern uint32 si_pmu_ilp_clock(si_t *sih, osl_t *osh);
+
+extern void si_pmu_set_switcher_voltage(si_t *sih, osl_t *osh,
+					uint8 bb_voltage,
+					uint8 rf_voltage);
+extern void si_pmu_set_ldo_voltage(si_t *sih, osl_t *osh, uint8 ldo,
+				   uint8 voltage);
+extern void si_pmu_paref_ldo_enable(si_t *sih, osl_t *osh, bool enable);
+extern uint16 si_pmu_fast_pwrup_delay(si_t *sih, osl_t *osh);
+extern void si_pmu_rcal(si_t *sih, osl_t *osh);
+
+extern void si_pmu_spuravoid(si_t *sih, osl_t *osh, bool spuravoid);
+
+extern bool si_pmu_is_otp_powered(si_t *sih, osl_t *osh);
+#endif				/* !defined(BCMDONGLEHOST) */
+
+extern void si_pmu_otp_power(si_t *sih, osl_t *osh, bool on);
+extern void si_sdiod_drive_strength_init(si_t *sih, osl_t *osh,
+					 uint32 drivestrength);
+extern void si_pmu_chipcontrol(si_t *sih, uint reg, uint32 mask,
+			       uint32 val);
+
+
+#endif				/* _hndpmu_h_ */
diff --git a/include/asm-mips/bcmsi/hndsoc.h b/include/asm-mips/bcmsi/hndsoc.h
new file mode 100644
index 0000000..dd73655
--- /dev/null
+++ b/include/asm-mips/bcmsi/hndsoc.h
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Broadcom HND chip & on-chip-interconnect-related definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#ifndef _HNDSOC_H
+#define _HNDSOC_H
+
+/* Include the soci specific files */
+#include "sbconfig.h"
+#include "aidmp.h"
+
+/*
+ * SOC Interconnect Address Map.
+ * All regions may not exist on all chips.
+ */
+#define SI_SDRAM_BASE       0x00000000	/* Physical SDRAM */
+#define SI_PCI_MEM_SZ       (64 * 1024 * 1024)
+
+#define SI_PCI0_MEM         0x08000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SI_PCI0_CFG         0x0c000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+
+#define SI_PCI1_MEM         0x40000000	/* Host Mode sb2pcitranslation0 (64 MB) */
+#define SI_PCI1_CFG         0x44000000	/* Host Mode sb2pcitranslation1 (64 MB) */
+
+#define SI_SDRAM_SWAPPED    0x10000000	/* Byteswapped Physical SDRAM */
+
+#define SI_ENUM_BASE        0x18000000	/* Enumeration space base */
+#define SI_CORE_SIZE        0x1000	/* each core gets 4Kbytes for registers */
+#define SI_MAXCORES         32	/* Max cores (this is arbitrary, for software
+				 * convenience and could be changed if we
+				 * make any larger chips */
+
+#define SI_FASTRAM      0x19000000	/* On-chip RAM on chips that also have DDR */
+
+#define SI_FLASH2           0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
+#define SI_FLASH2_SZ        0x02000000	/* Size of Flash Region 2 */
+#define SI_ARMCM3_ROM       0x1e000000	/* ARM Cortex-M3 ROM */
+#define SI_FLASH1           0x1fc00000	/* MIPS Flash Region 1 */
+#define SI_FLASH1_SZ        0x00400000	/* MIPS Size of Flash Region 1 */
+#define SI_ARM7S_ROM        0x20000000	/* ARM7TDMI-S ROM */
+#define SI_ARMCM3_SRAM2     0x60000000	/* ARM Cortex-M3 SRAM Region 2 */
+#define SI_ARM7S_SRAM2      0x80000000	/* ARM7TDMI-S SRAM Region 2 */
+#define SI_ARM_FLASH1       0xffff0000	/* ARM Flash Region 1 */
+#define SI_ARM_FLASH1_SZ    0x00010000	/* ARM Size of Flash Region 1 */
+
+#define SI_PCI_DMA          0x40000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SI_PCI_DMA2         0x80000000	/* Client Mode sb2pcitranslation2 (1 GB) */
+#define SI_PCI_DMA_SZ       0x40000000	/* Client Mode sb2pcitranslation2 size in bytes */
+#define SI_PCIE_DMA_L32     0x00000000	/* PCIE Client Mode sb2pcitranslation2
+					 * (2 ZettaBytes), low 32 bits
+					 */
+#define SI_PCIE_DMA_H32     0x80000000	/* PCIE Client Mode sb2pcitranslation2
+					 * (2 ZettaBytes), high 32 bits
+					 */
+#define SI_PCIE1_DMA_H32    0xc0000000	/* PCIE Client Mode sb2pcitranslation2
+					 * (2 ZettaBytes), high 32 bits
+					 */
+/* core codes */
+#define NODEV_CORE_ID       0x700	/* Invalid coreid */
+#define CC_CORE_ID          0x500	/* chipcommon core */
+#define ILINE20_CORE_ID     0x801	/* iline20 core */
+#define SRAM_CORE_ID        0x802	/* sram core */
+#define SDRAM_CORE_ID       0x803	/* sdram core */
+#define PCI_CORE_ID         0x804	/* pci core */
+#define MIPS_CORE_ID        0x805	/* mips core */
+#define ENET_CORE_ID        0x806	/* enet mac core */
+#define CODEC_CORE_ID       0x807	/* v90 codec core */
+#define USB_CORE_ID         0x808	/* usb 1.1 host/device core */
+#define ADSL_CORE_ID        0x809	/* ADSL core */
+#define ILINE100_CORE_ID    0x80a	/* iline100 core */
+#define IPSEC_CORE_ID       0x80b	/* ipsec core */
+#define UTOPIA_CORE_ID      0x80c	/* utopia core */
+#define PCMCIA_CORE_ID      0x80d	/* pcmcia core */
+#define SOCRAM_CORE_ID      0x50e	/* internal memory core */
+#define MEMC_CORE_ID        0x80f	/* memc sdram core */
+#define OFDM_CORE_ID        0x810	/* OFDM phy core */
+#define EXTIF_CORE_ID       0x811	/* external interface core */
+#define D11_CORE_ID         0x812	/* 802.11 MAC core */
+#define APHY_CORE_ID        0x813	/* 802.11a phy core */
+#define BPHY_CORE_ID        0x814	/* 802.11b phy core */
+#define GPHY_CORE_ID        0x815	/* 802.11g phy core */
+#define MIPS33_CORE_ID      0x816	/* mips3302 core */
+#define USB11H_CORE_ID      0x817	/* usb 1.1 host core */
+#define USB11D_CORE_ID      0x818	/* usb 1.1 device core */
+#define USB20H_CORE_ID      0x819	/* usb 2.0 host core */
+#define USB20D_CORE_ID      0x81a	/* usb 2.0 device core */
+#define SDIOH_CORE_ID       0x81b	/* sdio host core */
+#define ROBO_CORE_ID        0x81c	/* roboswitch core */
+#define ATA100_CORE_ID      0x81d	/* parallel ATA core */
+#define SATAXOR_CORE_ID     0x81e	/* serial ATA & XOR DMA core */
+#define GIGETH_CORE_ID      0x81f	/* gigabit ethernet core */
+#define PCIE_CORE_ID        0x820	/* pci express core */
+#define NPHY_CORE_ID        0x821	/* 802.11n 2x2 phy core */
+#define SRAMC_CORE_ID       0x822	/* SRAM controller core */
+#define MINIMAC_CORE_ID     0x823	/* MINI MAC/phy core */
+#define ARM11_CORE_ID       0x824	/* ARM 1176 core */
+#define ARM7S_CORE_ID       0x825	/* ARM7tdmi-s core */
+#define LPPHY_CORE_ID       0x826	/* 802.11a/b/g phy core */
+#define PMU_CORE_ID         0x827	/* PMU core */
+#define SSNPHY_CORE_ID      0x828	/* 802.11n single-stream phy core */
+#define SDIOD_CORE_ID       0x829	/* SDIO device core */
+#define ARMCM3_CORE_ID      0x82a	/* ARM Cortex M3 core */
+#define QNPHY_CORE_ID       0x82b	/* 802.11n 4x4 phy core */
+#define MIPS74K_CORE_ID     0x82c	/* mips 74k core */
+#define GMAC_CORE_ID        0x52d	/* Gigabit MAC core */
+#define DMEMC_CORE_ID       0x52e	/* DDR1/2 memory controller core */
+#define PCIERC_CORE_ID      0x82f	/* PCIE Root Complex core */
+#define OCP_CORE_ID         0x830	/* OCP2OCP bridge core */
+#define SC_CORE_ID          0x831	/* shared common core */
+#define AHB_CORE_ID         0x832	/* OCP2AHB bridge core */
+#define SPIH_CORE_ID        0x833	/* SPI host core */
+#define I2S_CORE_ID         0x834	/* I2S core */
+#define ALTA_CORE_ID        0x534	/* Alta core */
+#define GMAC_COM_CORE_ID    0x5dc	/* gmac common core */
+#define DDR2_PHY_CORE_ID    0x5dd	/* ddr2 phy core */
+#define DEF_AI_COMP         0xfff	/* Default component, in ai chips it maps all
+					 * unused address ranges
+					 */
+
+/* There are TWO constants on all HND chips: SI_ENUM_BASE above,
+ * and chipcommon being the first core:
+ */
+#define SI_CC_IDX       0
+
+/* SOC Interconnect types (aka chip types) */
+#define SOCI_SB         0
+#define SOCI_AI         1
+
+/* Common core control flags */
+#define SICF_BIST_EN        0x8000
+#define SICF_PME_EN         0x4000
+#define SICF_CORE_BITS      0x3ffc
+#define SICF_FGC            0x0002
+#define SICF_CLOCK_EN       0x0001
+
+/* Common core status flags */
+#define SISF_BIST_DONE      0x8000
+#define SISF_BIST_ERROR     0x4000
+#define SISF_GATED_CLK      0x2000
+#define SISF_DMA64          0x1000
+#define SISF_CORE_BITS      0x0fff
+
+/* A register that is common to all cores to
+ * communicate w/PMU regarding clock control.
+ */
+#define SI_CLK_CTL_ST       0x1e0	/* clock control and status */
+
+/* clk_ctl_st register */
+#define CCS_FORCEALP        0x00000001	/* force ALP request */
+#define CCS_FORCEHT         0x00000002	/* force HT request */
+#define CCS_FORCEILP        0x00000004	/* force ILP request */
+#define CCS_ALPAREQ         0x00000008	/* ALP Avail Request */
+#define CCS_HTAREQ          0x00000010	/* HT Avail Request */
+#define CCS_FORCEHWREQOFF   0x00000020	/* Force HW Clock Request Off */
+#define CCS_ALPAVAIL        0x00010000	/* ALP is available */
+#define CCS_HTAVAIL         0x00020000	/* HT is available */
+#define CCS0_HTAVAIL        0x00010000	/* HT avail in chipc and pcmcia on 4328a0 */
+#define CCS0_ALPAVAIL       0x00020000	/* ALP avail in chipc and pcmcia on 4328a0 */
+
+/* Not really related to SOC Interconnect, but a couple of software
+ * conventions for the use the flash space:
+ */
+
+/* Minumum amount of flash we support */
+#define FLASH_MIN           0x00020000	/* Minimum flash size */
+
+/* A boot/binary may have an embedded block that describes its size  */
+#define BISZ_OFFSET         0x3e0	/* At this offset into the binary */
+#define BISZ_MAGIC          0x4249535a	/* Marked with this value: 'BISZ' */
+#define BISZ_MAGIC_IDX      0	/* Word 0: magic */
+#define BISZ_TXTST_IDX      1	/*  1: text start */
+#define BISZ_TXTEND_IDX     2	/*  2: text end */
+#define BISZ_DATAST_IDX     3	/*  3: data start */
+#define BISZ_DATAEND_IDX    4	/*  4: data end */
+#define BISZ_BSSST_IDX      5	/*  5: bss start */
+#define BISZ_BSSEND_IDX     6	/*  6: bss end */
+#define BISZ_SIZE           7	/* descriptor size in 32-bit intergers */
+
+#endif				/* _HNDSOC_H */
diff --git a/include/asm-mips/bcmsi/lib_types.h b/include/asm-mips/bcmsi/lib_types.h
new file mode 100644
index 0000000..c5be75c
--- /dev/null
+++ b/include/asm-mips/bcmsi/lib_types.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+#include <linux/types.h>
+
+typedef long intptr_t;
diff --git a/include/asm-mips/bcmsi/linux_osl.h b/include/asm-mips/bcmsi/linux_osl.h
new file mode 100644
index 0000000..21e15e8
--- /dev/null
+++ b/include/asm-mips/bcmsi/linux_osl.h
@@ -0,0 +1,639 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Linux OS Independent Layer
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _linux_osl_h_
+#define _linux_osl_h_
+
+#include <asm/bcmsi/typedefs.h>
+
+#ifdef BCMDRIVER
+
+/* use current 2.4.x calling conventions */
+#include <asm/bcmsi/linuxver.h>
+
+/* assert and panic */
+#ifdef BCMDBG_ASSERT
+#define ASSERT(exp) \
+	do { if (!(exp)) osl_assert(#exp, __FILE__, __LINE__); } while (0)
+extern void osl_assert(char *exp, char *file, int line);
+#else				/* BCMDBG_ASSERT */
+#ifdef __GNUC__
+#define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#if GCC_VERSION > 30100
+#define	ASSERT(exp)		do {} while (0)
+#else
+/* ASSERT could causes segmentation fault on GCC3.1, use empty instead */
+#define	ASSERT(exp)
+#endif				/* GCC_VERSION > 30100 */
+#endif				/* __GNUC__ */
+#endif				/* BCMDBG_ASSERT */
+
+/* microsecond delay */
+#define	OSL_DELAY(usec)		osl_delay(usec)
+extern void osl_delay(uint usec);
+
+#if defined(DSLCPE_DELAY)
+typedef struct {
+    int long_delay;
+    spinlock_t *lock;
+    void *wl;
+    unsigned long MIPS;
+} shared_osl_t;
+
+#define	OSL_LONG_DELAY(osh, usec)		osl_long_delay(osh, usec, 0)
+#define OSL_YIELD_EXEC(osh, usec)		osl_long_delay(osh, usec, 1)
+extern void osl_long_delay(osl_t *osh, uint usec, bool yield);
+extern int in_long_delay(osl_t *osh);
+extern void osl_oshsh_init(osl_t *osh, shared_osl_t *oshsh);
+#define IN_LONG_DELAY(osh)	in_long_delay(osh)
+#endif
+
+/* PCMCIA attribute space access macros */
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+struct pcmcia_dev {
+    dev_link_t link;		/* PCMCIA device pointer */
+    dev_node_t node;		/* PCMCIA node structure */
+    void *base;			/* Mapped attribute memory window */
+    size_t size;		/* Size of window */
+    void *drv;			/* Driver data */
+};
+#endif				/* defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE) */
+#define	OSL_PCMCIA_READ_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_read_attr((osh), (offset), (buf), (size))
+#define	OSL_PCMCIA_WRITE_ATTR(osh, offset, buf, size) \
+	osl_pcmcia_write_attr((osh), (offset), (buf), (size))
+extern void osl_pcmcia_read_attr(osl_t *osh, uint offset, void *buf,
+				 int size);
+extern void osl_pcmcia_write_attr(osl_t *osh, uint offset, void *buf,
+				  int size);
+
+/* PCI configuration space access macros */
+#define	OSL_PCI_READ_CONFIG(osh, offset, size) \
+	osl_pci_read_config((osh), (offset), (size))
+#define	OSL_PCI_WRITE_CONFIG(osh, offset, size, val) \
+	osl_pci_write_config((osh), (offset), (size), (val))
+extern uint32 osl_pci_read_config(osl_t *osh, uint offset, uint size);
+extern void osl_pci_write_config(osl_t *osh, uint offset, uint size,
+				 uint val);
+
+/* PCI device bus # and slot # */
+#define OSL_PCI_BUS(osh)	osl_pci_bus(osh)
+#define OSL_PCI_SLOT(osh)	osl_pci_slot(osh)
+extern uint osl_pci_bus(osl_t *osh);
+extern uint osl_pci_slot(osl_t *osh);
+
+/* Pkttag flag should be part of public information */
+typedef struct {
+    bool pkttag;
+    uint pktalloced;		/* Number of allocated packet buffers */
+    bool mmbus;			/* Bus supports memory-mapped register accesses */
+    pktfree_cb_fn_t tx_fn;	/* Callback function for PKTFREE */
+    void *tx_ctx;		/* Context to the callback function */
+#ifdef OSLREGOPS
+    osl_rreg_fn_t rreg_fn;	/* Read Register function */
+    osl_wreg_fn_t wreg_fn;	/* Write Register function */
+    void *reg_ctx;		/* Context to the reg callback functions */
+#endif
+} osl_pubinfo_t;
+
+/* OSL initialization */
+extern osl_t *osl_attach(void *pdev, uint bustype, bool pkttag);
+extern void osl_detach(osl_t *osh);
+
+#define PKTFREESETCB(osh, _tx_fn, _tx_ctx)		\
+	do {						\
+	   ((osl_pubinfo_t*)osh)->tx_fn = _tx_fn;	\
+	   ((osl_pubinfo_t*)osh)->tx_ctx = _tx_ctx;	\
+	} while (0)
+
+#ifdef OSLREGOPS
+#define REGOPSSET(osh, rreg, wreg, ctx)			\
+	do {						\
+	   ((osl_pubinfo_t*)osh)->rreg_fn = rreg;	\
+	   ((osl_pubinfo_t*)osh)->wreg_fn = wreg;	\
+	   ((osl_pubinfo_t*)osh)->reg_ctx = ctx;	\
+	} while (0)
+#endif				/* OSLREGOPS */
+
+/* host/bus architecture-specific byte swap */
+#define BUS_SWAP32(v)		(v)
+
+#ifdef BCMDBG_MEM
+
+#define	MALLOC(osh, size)	osl_debug_malloc((osh), (size), __LINE__, __FILE__)
+#define	MFREE(osh, addr, size)	osl_debug_mfree((osh), (addr), (size), __LINE__, __FILE__)
+#define MALLOCED(osh)		osl_malloced((osh))
+#define	MALLOC_DUMP(osh, b) osl_debug_memdump((osh), (b))
+extern void *osl_debug_malloc(osl_t *osh, uint size, int line,
+			      char *file);
+extern void osl_debug_mfree(osl_t *osh, void *addr, uint size, int line,
+			    char *file);
+struct bcmstrbuf;
+extern int osl_debug_memdump(osl_t *osh, struct bcmstrbuf *b);
+
+#else
+
+#define	MALLOC(osh, size)	osl_malloc((osh), (size))
+#define	MFREE(osh, addr, size)	osl_mfree((osh), (addr), (size))
+#define MALLOCED(osh)		osl_malloced((osh))
+
+#endif				/* BCMDBG_MEM */
+
+#define	MALLOC_FAILED(osh)	osl_malloc_failed((osh))
+
+extern void *osl_malloc(osl_t *osh, uint size);
+extern void osl_mfree(osl_t *osh, void *addr, uint size);
+extern uint osl_malloced(osl_t *osh);
+extern uint osl_malloc_failed(osl_t *osh);
+
+/* allocate/free shared (dma-able) consistent memory */
+#define	DMA_CONSISTENT_ALIGN	PAGE_SIZE
+#define	DMA_ALLOC_CONSISTENT(osh, size, pap, dmah) \
+	osl_dma_alloc_consistent((osh), (size), (pap))
+#define	DMA_FREE_CONSISTENT(osh, va, size, pa, dmah) \
+	osl_dma_free_consistent((osh), (void *)(va), (size), (pa))
+extern void *osl_dma_alloc_consistent(osl_t *osh, uint size, ulong *pap);
+extern void osl_dma_free_consistent(osl_t *osh, void *va, uint size,
+				    ulong pa);
+
+/* map/unmap direction */
+#define	DMA_TX	1		/* TX direction for DMA */
+#define	DMA_RX	2		/* RX direction for DMA */
+
+/* map/unmap shared (dma-able) memory */
+#define	DMA_MAP(osh, va, size, direction, p, dmah) \
+	osl_dma_map((osh), (va), (size), (direction))
+#define	DMA_UNMAP(osh, pa, size, direction, p, dmah) \
+	osl_dma_unmap((osh), (pa), (size), (direction))
+extern uint osl_dma_map(osl_t *osh, void *va, uint size, int direction);
+extern void osl_dma_unmap(osl_t *osh, uint pa, uint size, int direction);
+
+/* API for DMA addressing capability */
+#define OSL_DMADDRWIDTH(osh, addrwidth) do {} while (0)
+
+/* register access macros */
+#if defined(BCMSDIO)
+#include <bcmsdh.h>
+#define OSL_WRITE_REG(osh, r, v) (bcmsdh_reg_write(NULL, (uintptr)(r), sizeof(*(r)), (v)))
+#define OSL_READ_REG(osh, r) (bcmsdh_reg_read(NULL, (uintptr)(r), sizeof(*(r))))
+#elif defined(BCMJTAG)
+#include <bcmjtag.h>
+#define OSL_WRITE_REG(osh, r, v) (bcmjtag_write(NULL, (uintptr)(r), (v), sizeof(*(r))))
+#define OSL_READ_REG(osh, r) (bcmjtag_read(NULL, (uintptr)(r), sizeof(*(r))))
+#endif
+
+#if defined(BCMSDIO) || defined (BCMJTAG)
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) if (((osl_pubinfo_t *)(osh))->mmbus) \
+	mmap_op else bus_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) (((osl_pubinfo_t *)(osh))->mmbus) ? \
+	mmap_op : bus_op
+#else
+#define SELECT_BUS_WRITE(osh, mmap_op, bus_op) mmap_op
+#define SELECT_BUS_READ(osh, mmap_op, bus_op) mmap_op
+#endif				/* defined(BCMSDIO) || defined (BCMJTAG) */
+
+/*
+ * BINOSL selects the slightly slower function-call-based binary compatible osl.
+ * Macros expand to calls to functions defined in linux_osl.c .
+ */
+#ifndef BINOSL
+
+/* string library, kernel mode */
+#ifndef printf
+#define	printf(fmt, args...)	printk(fmt , ## args)
+#endif				/* printf */
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/* register access macros */
+#if defined(OSLREGOPS)
+#define R_REG(osh, r) (\
+	sizeof(*(r)) == sizeof(uint8) ? osl_readb((osh), (volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? osl_readw((osh), (volatile uint16*)(r)) : \
+	osl_readl((osh), (volatile uint32*)(r)) \
+)
+#define W_REG(osh, r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	osl_writeb((osh), (volatile uint8*)(r), (uint8)(v)); break; \
+	case sizeof(uint16):	osl_writew((osh), (volatile uint16*)(r), (uint16)(v)); break; \
+	case sizeof(uint32):	osl_writel((osh), (volatile uint32*)(r), (uint32)(v)); break; \
+	} \
+} while (0)
+
+extern uint8 osl_readb(osl_t *osh, volatile uint8 *r);
+extern uint16 osl_readw(osl_t *osh, volatile uint16 *r);
+extern uint32 osl_readl(osl_t *osh, volatile uint32 *r);
+extern void osl_writeb(osl_t *osh, volatile uint8 *r, uint8 v);
+extern void osl_writew(osl_t *osh, volatile uint16 *r, uint16 v);
+extern void osl_writel(osl_t *osh, volatile uint32 *r, uint32 v);
+
+#else				/* OSLREGOPS */
+
+#define R_REG(osh, r) (\
+	SELECT_BUS_READ(osh, \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			__asm__ __volatile__("sync"); \
+			switch (sizeof(*(r))) { \
+				case sizeof(uint8):	__osl_v = \
+					readb((volatile uint8*)(r)); break; \
+				case sizeof(uint16):	__osl_v = \
+					readw((volatile uint16*)(r)); break; \
+				case sizeof(uint32):	__osl_v = \
+					readl((volatile uint32*)(r)); break; \
+			} \
+			__asm__ __volatile__("sync"); \
+			__osl_v; \
+		}), \
+		({ \
+			__typeof(*(r)) __osl_v; \
+			__asm__ __volatile__("sync"); \
+			__osl_v = OSL_READ_REG(osh, r); \
+			__asm__ __volatile__("sync"); \
+			__osl_v; \
+		})) \
+)
+
+
+#define W_REG(osh, r, v) do { \
+	SELECT_BUS_WRITE(osh,  \
+		switch (sizeof(*(r))) { \
+			case sizeof(uint8):	writeb((uint8)(v), (volatile uint8*)(r)); break; \
+			case sizeof(uint16):	writew((uint16)(v), (volatile uint16*)(r)); break; \
+			case sizeof(uint32):	writel((uint32)(v), (volatile uint32*)(r)); break; \
+		}, \
+		(OSL_WRITE_REG(osh, r, v))); \
+	} while (0)
+
+#endif				/* OSLREGOPS */
+
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
+
+/* bcopy, bcmp, and bzero */
+#define	bcopy(src, dst, len)	memcpy((dst), (src), (len))
+#define	bcmp(b1, b2, len)	memcmp((b1), (b2), (len))
+#define	bzero(b, len)		memset((b), '\0', (len))
+
+/* uncached virtual address */
+#ifdef mips
+#define OSL_UNCACHED(va)	((void *)KSEG1ADDR((va)))
+#include <asm/addrspace.h>
+#else
+#define OSL_UNCACHED(va)	((void *)va)
+#endif				/* mips */
+
+/* get processor cycle count */
+#if defined(mips)
+#if defined DSLCPE_DELAY
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count())
+#define TICKDIFF(_x2_, _x1_)	\
+	((_x2_ >= _x1_) ? (_x2_ - _x1_) : ((unsigned long)(-1) - _x2_ + _x1_))
+#else
+#define	OSL_GETCYCLES(x)	((x) = read_c0_count() * 2)
+#endif
+#elif defined(__i386__)
+#define	OSL_GETCYCLES(x)	rdtscl((x))
+#else
+#define OSL_GETCYCLES(x)	((x) = 0)
+#endif				/* defined(mips) */
+
+/* dereference an address that may cause a bus exception */
+#ifdef mips
+#if defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 17))
+#define BUSPROBE(val, addr)	panic("get_dbe() will not fixup a bus exception when compiled into"\
+					" a module")
+#else
+#define	BUSPROBE(val, addr)	get_dbe((val), (addr))
+#include <asm/paccess.h>
+#endif				/* defined(MODULE) && (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 17)) */
+#else
+#define	BUSPROBE(val, addr)	({ (val) = R_REG(NULL, (addr)); 0; })
+#endif				/* mips */
+
+/* map/unmap physical to virtual I/O */
+#define	REG_MAP(pa, size)	ioremap_nocache((unsigned long)(pa), (unsigned long)(size))
+#define	REG_UNMAP(va)		iounmap((va))
+
+/* shared (dma-able) memory access macros */
+#if defined(BCMSIM)
+#define R_SM(r)			R_REG(NULL, (r))
+#define W_SM(r, v)		W_REG(osh, (r), (v))
+#define BZERO_SM(r, len)	bzero_sm((uchar *)(r), (len))
+extern void bzero_sm(uchar *r, uint len);
+#else
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	memset((r), '\0', (len))
+#endif				/* defined(BCMSIM) */
+
+/* Memory types for packet primitives */
+#define MEMORY_DDRRAM 0
+#define MEMORY_SOCRAM 1
+#define MEMORY_PCIMEM 2
+
+/* packet primitives */
+#define	PKTGET(osh, len, send, mt)		osl_pktget((osh), (len))
+#define	PKTFREE(osh, skb, send, mt)		osl_pktfree((osh), (skb), (send))
+#define	PKTDATA(osh, skb)		(((struct sk_buff *)(skb))->data)
+#define	PKTLEN(osh, skb)		(((struct sk_buff *)(skb))->len)
+#define PKTHEADROOM(osh, skb)		(PKTDATA(osh, skb)-(((struct sk_buff *)(skb))->head))
+#define PKTTAILROOM(osh, skb) ((((struct sk_buff *)(skb))->end)-(((struct sk_buff *)(skb))->tail))
+#define	PKTNEXT(osh, skb)		(((struct sk_buff *)(skb))->next)
+#define	PKTSETNEXT(osh, skb, x)		(((struct sk_buff *)(skb))->next = (struct sk_buff *)(x))
+#define	PKTSETLEN(osh, skb, len)	__skb_trim((struct sk_buff *)(skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	skb_push((struct sk_buff *)(skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	skb_pull((struct sk_buff *)(skb), (bytes))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define	PKTTAG(skb)			((void*)(((struct sk_buff *)(skb))->cb))
+#define PKTALLOCED(osh)			((osl_pubinfo_t *)(osh))->pktalloced
+#define PKTFLAGTS(osh, lb)      (0)
+#ifdef BCMDBG_PKT		/* pkt logging for debugging */
+#define PKTLIST_DUMP(osh, buf) 		osl_pktlist_dump(osh, buf)
+#else				/* BCMDBG_PKT */
+#define PKTLIST_DUMP(osh, buf)
+#endif				/* BCMDBG_PKT */
+
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
+extern void *osl_pktdup(osl_t *osh, void *skb);
+
+#ifdef BCMDBG_PKT		/* pkt logging for debugging */
+extern void osl_pktlist_add(osl_t *osh, void *p);
+extern void osl_pktlist_remove(osl_t *osh, void *p);
+extern char *osl_pktlist_dump(osl_t *osh, char *buf);
+#endif				/* BCMDBG_PKT */
+
+/* Convert a native(OS) packet to driver packet.
+ * In the process, native packet is destroyed, there is no copying
+ * Also, a packettag is zeroed out
+ */
+static INLINE void *osl_pkt_frmnative(osl_pubinfo_t *osh,
+				      struct sk_buff *skb)
+{
+    struct sk_buff *nskb;
+
+    if (osh->pkttag)
+	bzero((void *) skb->cb, OSL_PKTTAG_SZ);
+
+    /* Increment the packet counter */
+    for (nskb = skb; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+	osl_pktlist_add((osl_t *) osh, (void *) nskb);
+#endif				/* BCMDBG_PKT */
+	osh->pktalloced++;
+    }
+
+    return (void *) skb;
+}
+
+#define PKTFRMNATIVE(osh, skb)	osl_pkt_frmnative(((osl_pubinfo_t *)osh), (struct sk_buff*)(skb))
+
+/* Convert a driver packet to native(OS) packet
+ * In the process, packettag is zeroed out before sending up
+ * IP code depends on skb->cb to be setup correctly with various options
+ * In our case, that means it should be 0
+ */
+static INLINE struct sk_buff *osl_pkt_tonative(osl_pubinfo_t * osh,
+					       void *pkt)
+{
+    struct sk_buff *nskb;
+
+    if (osh->pkttag)
+	bzero(((struct sk_buff *) pkt)->cb, OSL_PKTTAG_SZ);
+
+    /* Decrement the packet counter */
+    for (nskb = (struct sk_buff *) pkt; nskb; nskb = nskb->next) {
+#ifdef BCMDBG_PKT
+	osl_pktlist_remove((osl_t *) osh, (void *) nskb);
+#endif				/* BCMDBG_PKT */
+	osh->pktalloced--;
+    }
+
+    return (struct sk_buff *) pkt;
+}
+
+#define PKTTONATIVE(osh, pkt)		osl_pkt_tonative((osl_pubinfo_t *)(osh), (pkt))
+
+#define	PKTLINK(skb)			(((struct sk_buff *)(skb))->prev)
+#define	PKTSETLINK(skb, x)		(((struct sk_buff *)(skb))->prev = (struct sk_buff *)(x))
+#define	PKTPRIO(skb)			(((struct sk_buff *)(skb))->priority)
+#define	PKTSETPRIO(skb, x)		(((struct sk_buff *)(skb))->priority = (x))
+#define PKTSUMNEEDED(skb)		(((struct sk_buff *)(skb))->ip_summed == CHECKSUM_HW)
+#define PKTSETSUMGOOD(skb, x)		(((struct sk_buff *)(skb))->ip_summed = \
+						((x) ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE))
+/* PKTSETSUMNEEDED and PKTSUMGOOD are not possible because skb->ip_summed is overloaded */
+#define PKTSHARED(skb)                  (((struct sk_buff *)(skb))->cloned)
+
+#else				/* BINOSL */
+
+/* string library */
+#ifndef LINUX_OSL
+#undef printf
+#define	printf(fmt, args...)		osl_printf((fmt) , ## args)
+#undef sprintf
+#define sprintf(buf, fmt, args...)	osl_sprintf((buf), (fmt) , ## args)
+#undef strcmp
+#define	strcmp(s1, s2)			osl_strcmp((s1), (s2))
+#undef strncmp
+#define	strncmp(s1, s2, n)		osl_strncmp((s1), (s2), (n))
+#undef strlen
+#define strlen(s)			osl_strlen((s))
+#undef strcpy
+#define	strcpy(d, s)			osl_strcpy((d), (s))
+#undef strncpy
+#define	strncpy(d, s, n)		osl_strncpy((d), (s), (n))
+#endif				/* LINUX_OSL */
+extern int osl_printf(const char *format, ...);
+extern int osl_sprintf(char *buf, const char *format, ...);
+extern int osl_strcmp(const char *s1, const char *s2);
+extern int osl_strncmp(const char *s1, const char *s2, uint n);
+extern int osl_strlen(const char *s);
+extern char *osl_strcpy(char *d, const char *s);
+extern char *osl_strncpy(char *d, const char *s, uint n);
+
+/* register access macros */
+#if !defined(BCMSDIO) && !defined(BCMJTAG)
+#define R_REG(osh, r) (\
+	sizeof(*(r)) == sizeof(uint8) ? osl_readb((volatile uint8*)(r)) : \
+	sizeof(*(r)) == sizeof(uint16) ? osl_readw((volatile uint16*)(r)) : \
+	osl_readl((volatile uint32*)(r)) \
+)
+#define W_REG(osh, r, v) do { \
+	switch (sizeof(*(r))) { \
+	case sizeof(uint8):	osl_writeb((uint8)(v), (volatile uint8*)(r)); break; \
+	case sizeof(uint16):	osl_writew((uint16)(v), (volatile uint16*)(r)); break; \
+	case sizeof(uint32):	osl_writel((uint32)(v), (volatile uint32*)(r)); break; \
+	} \
+} while (0)
+
+/* else added by johnvb to make sdio and jtag work with BINOSL, at least compile ... UNTESTED */
+#else
+#define R_REG(osh, r) OSL_READ_REG(osh, r)
+#define W_REG(osh, r, v) do { OSL_WRITE_REG(osh, r, v); } while (0)
+#endif				/* !defined(BCMSDIO) && !defined(BCMJTAG) */
+
+#define	AND_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) & (v))
+#define	OR_REG(osh, r, v)		W_REG(osh, (r), R_REG(osh, r) | (v))
+extern uint8 osl_readb(volatile uint8 *r);
+extern uint16 osl_readw(volatile uint16 *r);
+extern uint32 osl_readl(volatile uint32 *r);
+extern void osl_writeb(uint8 v, volatile uint8 *r);
+extern void osl_writew(uint16 v, volatile uint16 *r);
+extern void osl_writel(uint32 v, volatile uint32 *r);
+
+/* bcopy, bcmp, and bzero */
+extern void bcopy(const void *src, void *dst, size_t len);
+extern int bcmp(const void *b1, const void *b2, size_t len);
+extern void bzero(void *b, size_t len);
+
+/* uncached virtual address */
+#define OSL_UNCACHED(va)	osl_uncached((va))
+extern void *osl_uncached(void *va);
+
+/* get processor cycle count */
+#define OSL_GETCYCLES(x)	((x) = osl_getcycles())
+extern uint osl_getcycles(void);
+
+/* dereference an address that may target abort */
+#define	BUSPROBE(val, addr)	osl_busprobe(&(val), (addr))
+extern int osl_busprobe(uint32 *val, uint32 addr);
+
+/* map/unmap physical to virtual */
+#define	REG_MAP(pa, size)	osl_reg_map((pa), (size))
+#define	REG_UNMAP(va)		osl_reg_unmap((va))
+extern void *osl_reg_map(uint32 pa, uint size);
+extern void osl_reg_unmap(void *va);
+
+/* shared (dma-able) memory access macros */
+#define	R_SM(r)			*(r)
+#define	W_SM(r, v)		(*(r) = (v))
+#define	BZERO_SM(r, len)	bzero((r), (len))
+
+/* Memory types for packet primitives */
+#define MEMORY_DDRRAM 0
+#define MEMORY_SOCRAM 1
+#define MEMORY_PCIMEM 2
+
+/* packet primitives */
+#define	PKTGET(osh, len, send)		osl_pktget((osh), (len))
+#define	PKTFREE(osh, skb, send)		osl_pktfree((osh), (skb), (send))
+#define	PKTDATA(osh, skb)		osl_pktdata((osh), (skb))
+#define	PKTLEN(osh, skb)		osl_pktlen((osh), (skb))
+#define PKTHEADROOM(osh, skb)		osl_pktheadroom((osh), (skb))
+#define PKTTAILROOM(osh, skb)		osl_pkttailroom((osh), (skb))
+#define	PKTNEXT(osh, skb)		osl_pktnext((osh), (skb))
+#define	PKTSETNEXT(osh, skb, x)		osl_pktsetnext((skb), (x))
+#define	PKTSETLEN(osh, skb, len)	osl_pktsetlen((osh), (skb), (len))
+#define	PKTPUSH(osh, skb, bytes)	osl_pktpush((osh), (skb), (bytes))
+#define	PKTPULL(osh, skb, bytes)	osl_pktpull((osh), (skb), (bytes))
+#define	PKTDUP(osh, skb)		osl_pktdup((osh), (skb))
+#define PKTTAG(skb)			osl_pkttag((skb))
+#define PKTFRMNATIVE(osh, skb)		osl_pkt_frmnative((osh), (struct sk_buff*)(skb))
+#define PKTTONATIVE(osh, pkt)		osl_pkt_tonative((osh), (pkt))
+#define	PKTLINK(skb)			osl_pktlink((skb))
+#define	PKTSETLINK(skb, x)		osl_pktsetlink((skb), (x))
+#define	PKTPRIO(skb)			osl_pktprio((skb))
+#define	PKTSETPRIO(skb, x)		osl_pktsetprio((skb), (x))
+#define PKTSHARED(skb)                  osl_pktshared((skb))
+#define PKTALLOCED(osh)			osl_pktalloced((osh))
+#define PKTFLAGTS(osh, lb)      (0)
+#ifdef BCMDBG_PKT
+#define PKTLIST_DUMP(osh, buf) 		osl_pktlist_dump(osh, buf)
+#else				/* BCMDBG_PKT */
+#define PKTLIST_DUMP(osh, buf)
+#endif				/* BCMDBG_PKT */
+
+extern void *osl_pktget(osl_t *osh, uint len);
+extern void osl_pktfree(osl_t *osh, void *skb, bool send);
+extern uchar *osl_pktdata(osl_t *osh, void *skb);
+extern uint osl_pktlen(osl_t *osh, void *skb);
+extern uint osl_pktheadroom(osl_t *osh, void *skb);
+extern uint osl_pkttailroom(osl_t *osh, void *skb);
+extern void *osl_pktnext(osl_t *osh, void *skb);
+extern void osl_pktsetnext(void *skb, void *x);
+extern void osl_pktsetlen(osl_t *osh, void *skb, uint len);
+extern uchar *osl_pktpush(osl_t *osh, void *skb, int bytes);
+extern uchar *osl_pktpull(osl_t *osh, void *skb, int bytes);
+extern void *osl_pktdup(osl_t *osh, void *skb);
+extern void *osl_pkttag(void *skb);
+extern void *osl_pktlink(void *skb);
+extern void osl_pktsetlink(void *skb, void *x);
+extern uint osl_pktprio(void *skb);
+extern void osl_pktsetprio(void *skb, uint x);
+extern void *osl_pkt_frmnative(osl_t *osh, struct sk_buff *skb);
+extern struct sk_buff *osl_pkt_tonative(osl_t *osh, void *pkt);
+extern bool osl_pktshared(void *skb);
+extern uint osl_pktalloced(osl_t *osh);
+
+#ifdef BCMDBG_PKT		/* pkt logging for debugging */
+extern char *osl_pktlist_dump(osl_t *osh, char *buf);
+extern void osl_pktlist_add(osl_t *osh, void *p);
+extern void osl_pktlist_remove(osl_t *osh, void *p);
+#endif				/* BCMDBG_PKT */
+
+#endif				/* BINOSL */
+
+#define OSL_ERROR(bcmerror)	osl_error(bcmerror)
+extern int osl_error(int bcmerror);
+
+/* the largest reasonable packet buffer driver uses for ethernet MTU in bytes */
+#define	PKTBUFSZ	2048	/* largest reasonable packet buffer, driver uses for ethernet MTU */
+
+/* get system up time in miliseconds */
+#define OSL_SYSUPTIME()		((uint32)jiffies * (1000 / HZ))
+
+#else				/* ! BCMDRIVER */
+
+/* assert and panic */
+#ifdef BCMDBG_ASSERT
+
+#include <assert.h>
+#define ASSERT assert
+
+#else				/* BCMDBG_ASSERT */
+
+#define	ASSERT(exp)	do {} while (0)
+
+#endif				/* BCMDBG_ASSERT */
+
+/* malloc and printf */
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#define MALLOC(o, l) malloc(l)
+#define MFREE(o, p, l) free(p)
+
+/* bcopy, bcmp, and bzero */
+extern void bcopy(const void *src, void *dst, size_t len);
+extern int bcmp(const void *b1, const void *b2, size_t len);
+extern void bzero(void *b, size_t len);
+
+#endif				/* ! BCMDRIVER */
+
+#endif				/* _linux_osl_h_ */
diff --git a/include/asm-mips/bcmsi/linuxver.h b/include/asm-mips/bcmsi/linuxver.h
new file mode 100644
index 0000000..31c5c8f
--- /dev/null
+++ b/include/asm-mips/bcmsi/linuxver.h
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Linux-specific abstractions to gain some independence from linux kernel versions.
+ * Pave over some 2.2 versus 2.4 versus 2.6 kernel differences.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _linuxver_h_
+#define _linuxver_h_
+
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+#include <linux/config.h>
+#else
+#include <linux/autoconf.h>
+#endif
+#include <linux/module.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0))
+/* __NO_VERSION__ must be defined for all linkables except one in 2.2 */
+#ifdef __UNDEF_NO_VERSION__
+#undef __NO_VERSION__
+#else
+#define __NO_VERSION__
+#endif
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define module_param(_name_, _type_, _perm_)	MODULE_PARM(_name_, "i")
+#define module_param_string(_name_, _string_, _size_, _perm_) \
+		MODULE_PARM(_string_, "c" __MODULE_STRING(_size_))
+#endif
+
+/* linux/malloc.h is deprecated, use linux/slab.h instead. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 9))
+#include <linux/malloc.h>
+#else
+#include <linux/slab.h>
+#endif
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41))
+#include <linux/workqueue.h>
+#else
+#include <linux/tqueue.h>
+#ifndef work_struct
+#define work_struct tq_struct
+#endif
+#ifndef INIT_WORK
+#define INIT_WORK(_work, _func, _data) INIT_TQUEUE((_work), (_func), (_data))
+#endif
+#ifndef schedule_work
+#define schedule_work(_work) schedule_task((_work))
+#endif
+#ifndef flush_scheduled_work
+#define flush_scheduled_work() flush_scheduled_tasks()
+#endif
+#endif				/* LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 41) */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#define	MY_INIT_WORK(_work, _func)	INIT_WORK(_work, _func)
+#else
+#define	MY_INIT_WORK(_work, _func)	INIT_WORK(_work, _func, _work)
+typedef void (*work_func_t) (void *work);
+#endif				/* >= 2.6.20 */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+/* Some distributions have their own 2.6.x compatibility layers */
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE
+#define IRQ_HANDLED
+#define IRQ_RETVAL(x)
+#endif
+#else
+typedef irqreturn_t(*FN_ISR) (int irq, void *dev_id,
+			      struct pt_regs * ptregs);
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0) */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+#define IRQF_SHARED	SA_SHIRQ
+#endif				/* < 2.6.18 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 17)
+#ifdef	CONFIG_NET_RADIO
+#define	CONFIG_WIRELESS_EXT
+#endif
+#endif				/* < 2.6.17 */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 67)
+#ifndef SANDGATE2G
+#define MOD_INC_USE_COUNT
+#endif				/* not SANDGATE2G */
+#endif				/* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 67) */
+
+#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/cisreg.h>
+#include <pcmcia/ds.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 69))
+/* In 2.5 (as of 2.5.69 at least) there is a cs_error exported which
+ * does this, but it's not in 2.4 so we do our own for now.
+ */
+static inline void cs_error(client_handle_t handle, int func, int ret)
+{
+    error_info_t err = { func, ret };
+    CardServices(ReportError, handle, &err);
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 16))
+
+typedef struct pcmcia_device dev_link_t;
+
+#endif
+
+#endif				/* CONFIG_PCMCIA */
+
+#ifndef __exit
+#define __exit
+#endif
+#ifndef __devexit
+#define __devexit
+#endif
+#ifndef __devinit
+#define __devinit	__init
+#endif
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+#ifndef __devexit_p
+#define __devexit_p(x)	x
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0))
+
+#define pci_get_drvdata(dev)		(dev)->sysdata
+#define pci_set_drvdata(dev, value)	(dev)->sysdata = (value)
+
+/*
+ * New-style (2.4.x) PCI/hot-pluggable PCI/CardBus registration
+ */
+
+struct pci_device_id {
+    unsigned int vendor, device;	/* Vendor and device ID or PCI_ANY_ID */
+    unsigned int subvendor, subdevice;	/* Subsystem ID's or PCI_ANY_ID */
+    unsigned int class, class_mask;	/* (class,subclass,prog-if) triplet */
+    unsigned long driver_data;	/* Data private to the driver */
+};
+
+struct pci_driver {
+    struct list_head node;
+    char *name;
+    const struct pci_device_id *id_table;	/* NULL if wants all devices */
+    int (*probe) (struct pci_dev *dev, const struct pci_device_id *id);	/* New device inserted */
+    void (*remove) (struct pci_dev *dev);	/* Device removed (NULL if not a hot-plug
+						 * capable driver)
+						 */
+    void (*suspend) (struct pci_dev *dev);	/* Device suspended */
+    void (*resume) (struct pci_dev *dev);	/* Device woken up */
+};
+
+#define MODULE_DEVICE_TABLE(type, name)
+#define PCI_ANY_ID (~0)
+
+/* compatpci.c */
+#define pci_module_init pci_register_driver
+extern int pci_register_driver(struct pci_driver *drv);
+extern void pci_unregister_driver(struct pci_driver *drv);
+
+#endif				/* PCI registration */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18))
+#define pci_module_init pci_register_driver
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18))
+#ifdef MODULE
+#define module_init(x) int init_module(void) { return x(); }
+#define module_exit(x) void cleanup_module(void) { x(); }
+#else
+#define module_init(x)	__initcall(x);
+#define module_exit(x)	__exitcall(x);
+#endif
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18) */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 48))
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; pos != (head); pos = pos->next)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 13))
+#define pci_resource_start(dev, bar)	((dev)->base_address[(bar)])
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 44))
+#define pci_resource_start(dev, bar)	((dev)->resource[(bar)].start)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 23))
+#define pci_enable_device(dev) do { } while (0)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 14))
+#define net_device device
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 42))
+
+/*
+ * DMA mapping
+ *
+ * See linux/Documentation/DMA-mapping.txt
+ */
+
+#ifndef PCI_DMA_TODEVICE
+#define	PCI_DMA_TODEVICE	1
+#define	PCI_DMA_FROMDEVICE	2
+#endif
+
+typedef u32 dma_addr_t;
+
+/* Pure 2^n version of get_order */
+static inline int get_order(unsigned long size)
+{
+    int order;
+
+    size = (size - 1) >> (PAGE_SHIFT - 1);
+    order = -1;
+    do {
+	size >>= 1;
+	order++;
+    } while (size);
+    return order;
+}
+
+static inline void *pci_alloc_consistent(struct pci_dev *hwdev,
+					 size_t size,
+					 dma_addr_t *dma_handle)
+{
+    void *ret;
+    int gfp = GFP_ATOMIC | GFP_DMA;
+
+    ret = (void *) __get_free_pages(gfp, get_order(size));
+
+    if (ret != NULL) {
+	memset(ret, 0, size);
+	*dma_handle = virt_to_bus(ret);
+    }
+    return ret;
+}
+
+static inline void pci_free_consistent(struct pci_dev *hwdev, size_t size,
+				       void *vaddr, dma_addr_t dma_handle)
+{
+    free_pages((unsigned long) vaddr, get_order(size));
+}
+
+#ifdef ILSIM
+extern uint pci_map_single(void *dev, void *va, uint size, int direction);
+extern void pci_unmap_single(void *dev, uint pa, uint size, int direction);
+#else
+#define pci_map_single(cookie, address, size, dir)	virt_to_bus(address)
+#define pci_unmap_single(cookie, address, size, dir)
+#endif
+
+#endif				/* DMA mapping */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 43))
+
+#define dev_kfree_skb_any(a)		dev_kfree_skb(a)
+#define netif_down(dev)			do { (dev)->start = 0; } while (0)
+
+/* pcmcia-cs provides its own netdevice compatibility layer */
+#ifndef _COMPAT_NETDEVICE_H
+
+/*
+ * SoftNet
+ *
+ * For pre-softnet kernels we need to tell the upper layer not to
+ * re-enter start_xmit() while we are in there. However softnet
+ * guarantees not to enter while we are in there so there is no need
+ * to do the netif_stop_queue() dance unless the transmit queue really
+ * gets stuck. This should also improve performance according to tests
+ * done by Aman Singla.
+ */
+
+#define dev_kfree_skb_irq(a)	dev_kfree_skb(a)
+#define netif_wake_queue(dev) \
+		do { clear_bit(0, &(dev)->tbusy); mark_bh(NET_BH); } while (0)
+#define netif_stop_queue(dev)	set_bit(0, &(dev)->tbusy)
+
+static inline void netif_start_queue(struct net_device *dev)
+{
+    dev->tbusy = 0;
+    dev->interrupt = 0;
+    dev->start = 1;
+}
+
+#define netif_queue_stopped(dev)	(dev)->tbusy
+#define netif_running(dev)		(dev)->start
+
+#endif				/* _COMPAT_NETDEVICE_H */
+
+#define netif_device_attach(dev)	netif_start_queue(dev)
+#define netif_device_detach(dev)	netif_stop_queue(dev)
+
+/* 2.4.x renamed bottom halves to tasklets */
+#define tasklet_struct				tq_struct
+static inline void tasklet_schedule(struct tasklet_struct *tasklet)
+{
+    queue_task(tasklet, &tq_immediate);
+    mark_bh(IMMEDIATE_BH);
+}
+
+static inline void tasklet_init(struct tasklet_struct *tasklet,
+				void (*func) (unsigned long),
+				unsigned long data)
+{
+    tasklet->next = NULL;
+    tasklet->sync = 0;
+    tasklet->routine = (void (*)(void *)) func;
+    tasklet->data = (void *) data;
+}
+
+#define tasklet_kill(tasklet)	{ do{} while (0); }
+
+/* 2.4.x introduced del_timer_sync() */
+#define del_timer_sync(timer) del_timer(timer)
+
+#else
+
+#define netif_down(dev)
+
+#endif				/* SoftNet */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3))
+
+/*
+ * Emit code to initialise a tq_struct's routine and data pointers
+ */
+#define PREPARE_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		(_tq)->routine = _routine;			\
+		(_tq)->data = _data;				\
+	} while (0)
+
+/*
+ * Emit code to initialise all of a tq_struct
+ */
+#define INIT_TQUEUE(_tq, _routine, _data)			\
+	do {							\
+		INIT_LIST_HEAD(&(_tq)->list);			\
+		(_tq)->sync = 0;				\
+		PREPARE_TQUEUE((_tq), (_routine), (_data));	\
+	} while (0)
+
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 3) */
+
+/* Power management related macro & routines */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 9)
+#define	PCI_SAVE_STATE(a,b)	pci_save_state(a)
+#define	PCI_RESTORE_STATE(a,b)	pci_restore_state(a)
+#else
+#define	PCI_SAVE_STATE(a,b)	pci_save_state(a,b)
+#define	PCI_RESTORE_STATE(a,b)	pci_restore_state(a,b)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6))
+static inline int pci_save_state(struct pci_dev *dev, u32 * buffer)
+{
+    int i;
+    if (buffer) {
+	/* XXX: 100% dword access ok here? */
+	for (i = 0; i < 16; i++)
+	    pci_read_config_dword(dev, i * 4, &buffer[i]);
+    }
+    return 0;
+}
+
+static inline int pci_restore_state(struct pci_dev *dev, u32 *buffer)
+{
+    int i;
+
+    if (buffer) {
+	for (i = 0; i < 16; i++)
+	    pci_write_config_dword(dev, i * 4, buffer[i]);
+    }
+    /*
+     * otherwise, write the context information we know from bootup.
+     * This works around a problem where warm-booting from Windows
+     * combined with a D3(hot)->D0 transition causes PCI config
+     * header data to be forgotten.
+     */
+    else {
+	for (i = 0; i < 6; i++)
+	    pci_write_config_dword(dev,
+				   PCI_BASE_ADDRESS_0 + (i * 4),
+				   pci_resource_start(dev, i));
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+    }
+    return 0;
+}
+#endif				/* PCI power management */
+
+/* Old cp0 access macros deprecated in 2.4.19 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 19))
+#define read_c0_count() read_32bit_cp0_register(CP0_COUNT)
+#endif
+
+/* Module refcount handled internally in 2.6.x */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24))
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)		do {} while (0)
+#define OLD_MOD_INC_USE_COUNT		MOD_INC_USE_COUNT
+#define OLD_MOD_DEC_USE_COUNT		MOD_DEC_USE_COUNT
+#else
+#define OLD_MOD_INC_USE_COUNT		do {} while (0)
+#define OLD_MOD_DEC_USE_COUNT		do {} while (0)
+#endif
+#else				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24) */
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)		do {} while (0)
+#endif
+#ifndef MOD_INC_USE_COUNT
+#define MOD_INC_USE_COUNT			do {} while (0)
+#endif
+#ifndef MOD_DEC_USE_COUNT
+#define MOD_DEC_USE_COUNT			do {} while (0)
+#endif
+#define OLD_MOD_INC_USE_COUNT		MOD_INC_USE_COUNT
+#define OLD_MOD_DEC_USE_COUNT		MOD_DEC_USE_COUNT
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24) */
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)	do {} while (0)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(dev)		kfree(dev)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0))
+/* struct packet_type redefined in 2.6.x */
+#define af_packet_priv			data
+#endif
+
+/* suspend args */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 11)
+#define DRV_SUSPEND_STATE_TYPE pm_message_t
+#else
+#define DRV_SUSPEND_STATE_TYPE uint32
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+#define CHECKSUM_HW	CHECKSUM_PARTIAL
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0))
+#include <linux/time.h>
+#include <linux/wait.h>
+#else
+#include <linux/sched.h>
+
+#define __wait_event_interruptible_timeout(wq, condition, ret)		\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			ret = schedule_timeout(ret);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+
+#define wait_event_interruptible_timeout(wq, condition, timeout)	\
+({									\
+	long __ret = timeout;						\
+	if (!(condition))						\
+		__wait_event_interruptible_timeout(wq, condition, __ret); \
+	__ret;								\
+})
+
+#endif				/* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)) */
+
+#endif				/* _linuxver_h_ */
diff --git a/include/asm-mips/bcmsi/mips33_core.h b/include/asm-mips/bcmsi/mips33_core.h
new file mode 100644
index 0000000..92ace43
--- /dev/null
+++ b/include/asm-mips/bcmsi/mips33_core.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Broadcom SiliconBackplane MIPS definitions
+ *
+ * SB MIPS cores are custom MIPS32 processors with SiliconBackplane
+ * OCP interfaces. The CP0 processor ID is 0x00024000, where bits
+ * 23:16 mean Broadcom and bits 15:8 mean a MIPS core with an OCP
+ * interface. The core revision is stored in the SB ID register in SB
+ * configuration space.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_mips33_core_h_
+#define	_mips33_core_h_
+
+#include <mipsinc.h>
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+typedef volatile struct {
+    uint32 corecontrol;
+    uint32 PAD[2];
+    uint32 biststatus;
+    uint32 PAD[4];
+    uint32 intstatus;
+    uint32 intmask;
+    uint32 timer;
+} mips33regs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#endif				/* _mips33_core_h_ */
diff --git a/include/asm-mips/bcmsi/mips74k_core.h b/include/asm-mips/bcmsi/mips74k_core.h
new file mode 100644
index 0000000..3c73426
--- /dev/null
+++ b/include/asm-mips/bcmsi/mips74k_core.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * MIPS 74k definitions
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#ifndef	_mips74k_core_h_
+#define	_mips74k_core_h_
+
+#include <mipsinc.h>
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+typedef volatile struct {
+    uint32 corecontrol;
+    uint32 exceptionbase;
+    uint32 PAD[1];
+    uint32 biststatus;
+    uint32 intstatus;
+    uint32 intmask[6];
+    uint32 nmimask;
+    uint32 PAD[4];
+    uint32 gpioselect;
+    uint32 gpiooutput;
+    uint32 gpioenable;
+    uint32 PAD[101];
+    uint32 clkcontrolstatus;
+} mips74kregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#endif				/* _mips74k_core_h_ */
diff --git a/include/asm-mips/bcmsi/mipsinc.h b/include/asm-mips/bcmsi/mipsinc.h
new file mode 100644
index 0000000..2a22dde
--- /dev/null
+++ b/include/asm-mips/bcmsi/mipsinc.h
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * HND Run Time Environment for standalone MIPS programs.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_MISPINC_H
+#define _MISPINC_H
+
+
+/* MIPS defines */
+
+#ifdef	_LANGUAGE_ASSEMBLY
+
+/*
+ * Symbolic register names for 32 bit ABI
+ */
+#define zero	$0		/* wired zero */
+#define AT	$1		/* assembler temp - uppercase because of ".set at" */
+#define v0	$2		/* return value */
+#define v1	$3
+#define a0	$4		/* argument registers */
+#define a1	$5
+#define a2	$6
+#define a3	$7
+#define t0	$8		/* caller saved */
+#define t1	$9
+#define t2	$10
+#define t3	$11
+#define t4	$12
+#define t5	$13
+#define t6	$14
+#define t7	$15
+#define s0	$16		/* callee saved */
+#define s1	$17
+#define s2	$18
+#define s3	$19
+#define s4	$20
+#define s5	$21
+#define s6	$22
+#define s7	$23
+#define t8	$24		/* caller saved */
+#define t9	$25
+#define jp	$25		/* PIC jump register */
+#define k0	$26		/* kernel scratch */
+#define k1	$27
+#define gp	$28		/* global pointer */
+#define sp	$29		/* stack pointer */
+#define fp	$30		/* frame pointer */
+#define s8	$30		/* same like fp! */
+#define ra	$31		/* return address */
+
+
+/* CP0 Registers */
+
+#define C0_INX		$0
+#define C0_RAND		$1
+#define C0_TLBLO0	$2
+#define C0_TLBLO	C0_TLBLO0
+#define C0_TLBLO1	$3
+#define C0_CTEXT	$4
+#define C0_PGMASK	$5
+#define C0_WIRED	$6
+#define C0_INFO		$7
+#define C0_BADVADDR	$8
+#define C0_COUNT 	$9
+#define C0_TLBHI	$10
+#define C0_COMPARE	$11
+#define C0_SR		$12
+#define C0_STATUS	C0_SR
+#define C0_CAUSE	$13
+#define C0_EPC		$14
+#define C0_PRID		$15
+#define C0_CONFIG	$16
+#define C0_LLADDR	$17
+#define C0_WATCHLO	$18
+#define C0_WATCHHI	$19
+#define C0_XCTEXT	$20
+#define C0_DIAGNOSTIC	$22
+#define C0_BROADCOM	C0_DIAGNOSTIC
+#define	C0_PERFORMANCE	$25
+#define C0_ECC		$26
+#define C0_CACHEERR	$27
+#define C0_TAGLO	$28
+#define C0_TAGHI	$29
+#define C0_ERREPC	$30
+#define C0_DESAVE	$31
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define LEAF(symbol)				\
+		.globl	symbol;			\
+		.align	2;			\
+		.type	symbol, @function;	\
+		.ent	symbol, 0;		\
+symbol:		.frame	sp, 0, ra
+
+/*
+ * END - mark end of function
+ */
+#define END(function)				\
+		.end	function;		\
+		.size	function, . - function
+
+#define _ULCAST_
+
+ /*CSTYLED*/
+#define MFC0_SEL(dst, src, sel) .word (0x40000000 | ((dst) << 16) | ((src) << 11) | (sel))
+     /*CSTYLED*/
+#define MTC0_SEL(dst, src, sel) .word (0x40800000 | ((dst) << 16) | ((src) << 11) | (sel))
+#else
+
+/*
+ * The following macros are especially useful for __asm__
+ * inline assembler.
+ */
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#define _ULCAST_ (unsigned long)
+
+
+/* CP0 Registers */
+
+#define C0_INX		0	/* CP0: TLB Index */
+#define C0_RAND		1	/* CP0: TLB Random */
+#define C0_TLBLO0	2	/* CP0: TLB EntryLo0 */
+#define C0_TLBLO	C0_TLBLO0	/* CP0: TLB EntryLo0 */
+#define C0_TLBLO1	3	/* CP0: TLB EntryLo1 */
+#define C0_CTEXT	4	/* CP0: Context */
+#define C0_PGMASK	5	/* CP0: TLB PageMask */
+#define C0_WIRED	6	/* CP0: TLB Wired */
+#define C0_INFO		7	/* CP0: Info */
+#define C0_BADVADDR	8	/* CP0: Bad Virtual Address */
+#define C0_COUNT 	9	/* CP0: Count */
+#define C0_TLBHI	10	/* CP0: TLB EntryHi */
+#define C0_COMPARE	11	/* CP0: Compare */
+#define C0_SR		12	/* CP0: Processor Status */
+#define C0_STATUS	C0_SR	/* CP0: Processor Status */
+#define C0_CAUSE	13	/* CP0: Exception Cause */
+#define C0_EPC		14	/* CP0: Exception PC */
+#define C0_PRID		15	/* CP0: Processor Revision Indentifier */
+#define C0_CONFIG	16	/* CP0: Config */
+#define C0_LLADDR	17	/* CP0: LLAddr */
+#define C0_WATCHLO	18	/* CP0: WatchpointLo */
+#define C0_WATCHHI	19	/* CP0: WatchpointHi */
+#define C0_XCTEXT	20	/* CP0: XContext */
+#define C0_DIAGNOSTIC	22	/* CP0: Diagnostic */
+#define C0_BROADCOM	C0_DIAGNOSTIC	/* CP0: Broadcom Register */
+#define	C0_PERFORMANCE	25	/* CP0: Performance Counter/Control Registers */
+#define C0_ECC		26	/* CP0: ECC */
+#define C0_CACHEERR	27	/* CP0: CacheErr */
+#define C0_TAGLO	28	/* CP0: TagLo */
+#define C0_TAGHI	29	/* CP0: TagHi */
+#define C0_ERREPC	30	/* CP0: ErrorEPC */
+#define C0_DESAVE	31	/* CP0: DebugSave */
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/*
+ * Memory segments (32bit kernel mode addresses)
+ */
+#undef KUSEG
+#undef KSEG0
+#undef KSEG1
+#undef KSEG2
+#undef KSEG3
+#define KUSEG		0x00000000
+#define KSEG0		0x80000000
+#define KSEG1		0xa0000000
+#define KSEG2		0xc0000000
+#define KSEG3		0xe0000000
+#define PHYSADDR_MASK	0x1fffffff
+
+/*
+ * Map an address to a certain kernel segment
+ */
+#undef PHYSADDR
+#undef KSEG0ADDR
+#undef KSEG1ADDR
+#undef KSEG2ADDR
+#undef KSEG3ADDR
+
+#define PHYSADDR(a)	(_ULCAST_(a) & PHYSADDR_MASK)
+#define KSEG0ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG0)
+#define KSEG1ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG1)
+#define KSEG2ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG2)
+#define KSEG3ADDR(a)	((_ULCAST_(a) & PHYSADDR_MASK) | KSEG3)
+
+
+#ifndef	Index_Invalidate_I
+/*
+ * Cache Operations
+ */
+#define Index_Invalidate_I	0x00
+#define Index_Writeback_Inv_D	0x01
+#define Index_Invalidate_SI	0x02
+#define Index_Writeback_Inv_SD	0x03
+#define Index_Load_Tag_I	0x04
+#define Index_Load_Tag_D	0x05
+#define Index_Load_Tag_SI	0x06
+#define Index_Load_Tag_SD	0x07
+#define Index_Store_Tag_I	0x08
+#define Index_Store_Tag_D	0x09
+#define Index_Store_Tag_SI	0x0A
+#define Index_Store_Tag_SD	0x0B
+#define Create_Dirty_Excl_D	0x0d
+#define Create_Dirty_Excl_SD	0x0f
+#define Hit_Invalidate_I	0x10
+#define Hit_Invalidate_D	0x11
+#define Hit_Invalidate_SI	0x12
+#define Hit_Invalidate_SD	0x13
+#define Fill_I			0x14
+#define Hit_Writeback_Inv_D	0x15
+					/* 0x16 is unused */
+#define Hit_Writeback_Inv_SD	0x17
+#define R5K_Page_Invalidate_S	0x17
+#define Hit_Writeback_I		0x18
+#define Hit_Writeback_D		0x19
+					/* 0x1a is unused */
+#define Hit_Writeback_SD	0x1b
+					/* 0x1c is unused */
+					/* 0x1e is unused */
+#define Hit_Set_Virtual_SI	0x1e
+#define Hit_Set_Virtual_SD	0x1f
+#endif				/* !Index_Invalidate_I */
+
+
+/*
+ * R4x00 interrupt enable / cause bits
+ */
+#define IE_SW0			(_ULCAST_(1) <<  8)
+#define IE_SW1			(_ULCAST_(1) <<  9)
+#define IE_IRQ0			(_ULCAST_(1) << 10)
+#define IE_IRQ1			(_ULCAST_(1) << 11)
+#define IE_IRQ2			(_ULCAST_(1) << 12)
+#define IE_IRQ3			(_ULCAST_(1) << 13)
+#define IE_IRQ4			(_ULCAST_(1) << 14)
+#define IE_IRQ5			(_ULCAST_(1) << 15)
+
+#ifndef	ST0_UM
+/*
+ * Bitfields in the mips32 cp0 status register
+ */
+#define ST0_IE			0x00000001
+#define ST0_EXL			0x00000002
+#define ST0_ERL			0x00000004
+#define ST0_UM			0x00000010
+#define ST0_SWINT0		0x00000100
+#define ST0_SWINT1		0x00000200
+#define ST0_HWINT0		0x00000400
+#define ST0_HWINT1		0x00000800
+#define ST0_HWINT2		0x00001000
+#define ST0_HWINT3		0x00002000
+#define ST0_HWINT4		0x00004000
+#define ST0_HWINT5		0x00008000
+#define ST0_IM			0x0000ff00
+#define ST0_NMI			0x00080000
+#define ST0_SR			0x00100000
+#define ST0_TS			0x00200000
+#define ST0_BEV			0x00400000
+#define ST0_RE			0x02000000
+#define ST0_RP			0x08000000
+#define ST0_CU			0xf0000000
+#define ST0_CU0			0x10000000
+#define ST0_CU1			0x20000000
+#define ST0_CU2			0x40000000
+#define ST0_CU3			0x80000000
+#endif				/* !ST0_UM */
+
+
+/*
+ * Bitfields in the mips32 cp0 cause register
+ */
+#define C_EXC			0x0000007c
+#define C_EXC_SHIFT		2
+#define C_INT			0x0000ff00
+#define C_INT_SHIFT		8
+#define C_SW0			(_ULCAST_(1) <<  8)
+#define C_SW1			(_ULCAST_(1) <<  9)
+#define C_IRQ0			(_ULCAST_(1) << 10)
+#define C_IRQ1			(_ULCAST_(1) << 11)
+#define C_IRQ2			(_ULCAST_(1) << 12)
+#define C_IRQ3			(_ULCAST_(1) << 13)
+#define C_IRQ4			(_ULCAST_(1) << 14)
+#define C_IRQ5			(_ULCAST_(1) << 15)
+#define C_WP			0x00400000
+#define C_IV			0x00800000
+#define C_CE			0x30000000
+#define C_CE_SHIFT		28
+#define C_BD			0x80000000
+
+/* Values in C_EXC */
+#define EXC_INT			0
+#define EXC_TLBM		1
+#define EXC_TLBL		2
+#define EXC_TLBS		3
+#define EXC_AEL			4
+#define EXC_AES			5
+#define EXC_IBE			6
+#define EXC_DBE			7
+#define EXC_SYS			8
+#define EXC_BPT			9
+#define EXC_RI			10
+#define EXC_CU			11
+#define EXC_OV			12
+#define EXC_TR			13
+#define EXC_WATCH		23
+#define EXC_MCHK		24
+
+
+/*
+ * Bits in the cp0 config register.
+ */
+#define CONF_CM_CACHABLE_NO_WA		0
+#define CONF_CM_CACHABLE_WA		1
+#define CONF_CM_UNCACHED		2
+#define CONF_CM_CACHABLE_NONCOHERENT	3
+#define CONF_CM_CACHABLE_CE		4
+#define CONF_CM_CACHABLE_COW		5
+#define CONF_CM_CACHABLE_CUW		6
+#define CONF_CM_CACHABLE_ACCELERATED	7
+#define CONF_CM_CMASK			7
+#define CONF_CU				(_ULCAST_(1) <<  3)
+#define CONF_DB				(_ULCAST_(1) <<  4)
+#define CONF_IB				(_ULCAST_(1) <<  5)
+#define CONF_AR				(_ULCAST_(7) << 10)
+#define CONF_AR_SHIFT			10
+#define CONF_AT				(_ULCAST_(3) << 13)
+#define CONF_AT_SHIFT			13
+#ifndef CONF_BE			/* duplicate in mipsregs.h */
+#define CONF_BE				(_ULCAST_(1) << 15)
+#endif
+#define CONF_SC				(_ULCAST_(1) << 17)
+#define CONF_AC				(_ULCAST_(1) << 23)
+#define CONF_HALT			(_ULCAST_(1) << 25)
+#ifndef CONF_M			/* duplicate in mipsregs.h */
+#define CONF_M				(_ULCAST_(1) << 31)
+#endif
+
+
+/*
+ * Bits in the cp0 config register select 1.
+ */
+#define CONF1_FP		0x00000001	/* FPU present */
+#define CONF1_EP		0x00000002	/* EJTAG present */
+#define CONF1_CA		0x00000004	/* mips16 implemented */
+#define CONF1_WR		0x00000008	/* Watch registers present */
+#define CONF1_PC		0x00000010	/* Performance counters present */
+#define CONF1_DA_SHIFT		7	/* D$ associativity */
+#define CONF1_DA_MASK		0x00000380
+#define CONF1_DA_BASE		1
+#define CONF1_DL_SHIFT		10	/* D$ line size */
+#define CONF1_DL_MASK		0x00001c00
+#define CONF1_DL_BASE		2
+#define CONF1_DS_SHIFT		13	/* D$ sets/way */
+#define CONF1_DS_MASK		0x0000e000
+#define CONF1_DS_BASE		64
+#define CONF1_IA_SHIFT		16	/* I$ associativity */
+#define CONF1_IA_MASK		0x00070000
+#define CONF1_IA_BASE		1
+#define CONF1_IL_SHIFT		19	/* I$ line size */
+#define CONF1_IL_MASK		0x00380000
+#define CONF1_IL_BASE		2
+#define CONF1_IS_SHIFT		22	/* Instruction cache sets/way */
+#define CONF1_IS_MASK		0x01c00000
+#define CONF1_IS_BASE		64
+#define CONF1_MS_MASK		0x7e000000	/* Number of tlb entries */
+#define CONF1_MS_SHIFT		25
+
+
+/*
+ * Bits in the cp0 config register select 7.
+ */
+#define CONF7_ES		    (1 << 8)	/* ExternalSync */
+
+
+/* PRID register */
+#define PRID_COPT_MASK		0xff000000
+#define PRID_COMP_MASK		0x00ff0000
+#define PRID_IMP_MASK		0x0000ff00
+#define PRID_REV_MASK		0x000000ff
+
+#define PRID_COMP_LEGACY	0x000000
+#define PRID_COMP_MIPS		0x010000
+#define PRID_COMP_BROADCOM	0x020000
+#define PRID_COMP_ALCHEMY	0x030000
+#define PRID_COMP_SIBYTE	0x040000
+#define PRID_IMP_BCM4710	0x4000
+#define PRID_IMP_BCM3302	0x9000
+#define PRID_IMP_BCM3303	0x9100
+#define PRID_IMP_74K            0x9700
+
+#define PRID_IMP_UNKNOWN	0xff00
+
+#define BCM330X(id) \
+		(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == \
+		 (PRID_COMP_BROADCOM | PRID_IMP_BCM3302)) || \
+		((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == \
+		 (PRID_COMP_BROADCOM | PRID_IMP_BCM3303)))
+
+#define MIPS74K(id) \
+		(((id & (PRID_COMP_MASK | PRID_IMP_MASK)) == \
+		 (PRID_COMP_MIPS | PRID_IMP_74K)))
+
+/* Bits in C0_BROADCOM */
+#define BRCM_PFC_AVAIL		0x20000000	/* PFC is available */
+#define BRCM_DC_ENABLE		0x40000000	/* Enable Data $ */
+#define BRCM_IC_ENABLE		0x80000000	/* Enable Instruction $ */
+#define BRCM_PFC_ENABLE		0x00400000	/* Obsolete? Enable PFC (at least on 4310) */
+#define BRCM_CLF_ENABLE		0x00100000	/* Enable cache line first feature */
+
+/* PreFetch Cache aka Read Ahead Cache */
+
+#define PFC_CR0			0xff400000	/* control reg 0 */
+#define PFC_CR1			0xff400004	/* control reg 1 */
+
+/* PFC operations */
+#define PFC_I			0x00000001	/* Enable PFC use for instructions */
+#define PFC_D			0x00000002	/* Enable PFC use for data */
+#define PFC_PFI			0x00000004	/* Enable seq. prefetch for instructions */
+#define PFC_PFD			0x00000008	/* Enable seq. prefetch for data */
+#define PFC_CINV		0x00000010	/* Enable selective (i/d) cacheop flushing */
+#define PFC_NCH			0x00000020	/* Disable flushing based on cacheops */
+#define PFC_DPF			0x00000040	/* Enable directional prefetching */
+#define PFC_FLUSH		0x00000100	/* Flush the PFC */
+#define PFC_BRR			0x40000000	/* Bus error indication */
+#define PFC_PWR			0x80000000	/* Disable power saving (clock gating) */
+
+/* Handy defaults */
+#define PFC_DISABLED		0
+#define PFC_AUTO			0xffffffff	/* auto select the default mode */
+#define PFC_INST		(PFC_I | PFC_PFI | PFC_CINV)
+#define PFC_INST_NOPF		(PFC_I | PFC_CINV)
+#define PFC_DATA		(PFC_D | PFC_PFD | PFC_CINV)
+#define PFC_DATA_NOPF		(PFC_D | PFC_CINV)
+#define PFC_I_AND_D		(PFC_INST | PFC_DATA)
+#define PFC_I_AND_D_NOPF	(PFC_INST_NOPF | PFC_DATA_NOPF)
+
+#ifndef	_LANGUAGE_ASSEMBLY
+
+/*
+ * Macros to access the system control coprocessor
+ */
+
+#define MFC0(source, sel)					\
+({								\
+	int __res;						\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	.word\t"STR(0x40010000 | ((source) << 11) | (sel))";	\
+	move\t%0, $1;						\
+	.set\tat;						\
+	.set\treorder"						\
+	:"=r" (__res)						\
+	:							\
+	:"$1");							\
+	__res;							\
+})
+
+#define MTC0(source, sel, value)				\
+do {								\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	move\t$1, %z0;						\
+	.word\t"STR(0x40810000 | ((source) << 11) | (sel))";	\
+	.set\tat;						\
+	.set\treorder"						\
+	:							\
+	:"jr" (value)						\
+	:"$1");							\
+} while (0)
+
+#define get_c0_count()						\
+({								\
+	int __res;						\
+	__asm__ __volatile__("					\
+	.set\tnoreorder;					\
+	.set\tnoat;						\
+	mfc0\t%0, $9;						\
+	.set\tat;						\
+	.set\treorder"						\
+	:"=r" (__res));						\
+	__res;							\
+})
+
+static INLINE void icache_probe(uint32 config1, uint *size, uint *lsize)
+{
+    uint lsz, sets, ways;
+
+    /* Instruction Cache Size = Associativity * Line Size * Sets Per Way */
+    if ((lsz = ((config1 & CONF1_IL_MASK) >> CONF1_IL_SHIFT)))
+	lsz = CONF1_IL_BASE << lsz;
+    sets = CONF1_IS_BASE << ((config1 & CONF1_IS_MASK) >> CONF1_IS_SHIFT);
+    ways = CONF1_IA_BASE + ((config1 & CONF1_IA_MASK) >> CONF1_IA_SHIFT);
+    *size = lsz * sets * ways;
+    *lsize = lsz;
+}
+
+static INLINE void dcache_probe(uint32 config1, uint *size, uint *lsize)
+{
+    uint lsz, sets, ways;
+
+    /* Data Cache Size = Associativity * Line Size * Sets Per Way */
+    if ((lsz = ((config1 & CONF1_DL_MASK) >> CONF1_DL_SHIFT)))
+	lsz = CONF1_DL_BASE << lsz;
+    sets = CONF1_DS_BASE << ((config1 & CONF1_DS_MASK) >> CONF1_DS_SHIFT);
+    ways = CONF1_DA_BASE + ((config1 & CONF1_DA_MASK) >> CONF1_DA_SHIFT);
+    *size = lsz * sets * ways;
+    *lsize = lsz;
+}
+
+#define cache_op(base, op)			\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, (%0);			\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#define cache_unroll4(base, delta, op)		\
+	__asm__ __volatile__("			\
+		.set noreorder;			\
+		.set mips3;			\
+		cache %1, 0(%0);		\
+		cache %1, delta(%0);		\
+		cache %1, (2 * delta)(%0);	\
+		cache %1, (3 * delta)(%0);	\
+		.set mips0;			\
+		.set reorder"			\
+		:				\
+		: "r" (base),			\
+		  "i" (op));
+
+#endif				/* !_LANGUAGE_ASSEMBLY */
+
+#endif				/* _MISPINC_H */
diff --git a/include/asm-mips/bcmsi/nicpci.h b/include/asm-mips/bcmsi/nicpci.h
new file mode 100644
index 0000000..d3af761
--- /dev/null
+++ b/include/asm-mips/bcmsi/nicpci.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * BCM43XX PCI/E core sw API definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_NICPCI_H
+#define	_NICPCI_H
+
+#if defined(BCMSDIO) || defined(BCMDHDUSB) || (defined(BCMBUSTYPE) && (BCMBUSTYPE == SI_BUS))
+#define pcicore_find_pci_capability(a, b, c, d) (0)
+#define pcie_readreg(a, b, c, d) (0)
+#define pcie_writereg(a, b, c, d, e) (0)
+
+#define pcie_clkreq(a, b, c) (0)
+
+#define pcicore_init(a, b, c) (0x0dadbeef)
+#define pcicore_deinit(a)	do { } while (0)
+#define pcicore_attach(a, b, c)	do { } while (0)
+#define pcicore_hwup(a)		do { } while (0)
+#define pcicore_up(a, b)	do { } while (0)
+#define pcicore_sleep(a)	do { } while (0)
+#define pcicore_down(a, b)	do { } while (0)
+
+#define pcie_war_ovr_aspm_disable(a)	do { } while (0)
+
+#ifdef BCMINTERNAL
+#define pcicore_pciereg(a, b, c, d, e) (0)
+#define pcicore_pcieserdesreg(a, b, c, d, e) (0)
+#ifdef BCMDBG
+#define pcicore_dump_pcieregs(a, b) (0)
+#endif
+#endif				/* BCMINTERNAL */
+#ifdef BCMDBG
+#define pcie_lcreg(a, b, c) (0)
+#define pcicore_dump(a, b)	do { } while (0)
+#endif
+
+#define pcicore_pmecap_fast(a)	(FALSE)
+#define pcicore_pmeen(a)	do { } while (0)
+#define pcicore_pmeclr(a)	(FALSE)
+#else
+struct sbpcieregs;
+
+extern uint8 pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id,
+					 uchar *buf, uint32 *buflen);
+extern uint pcie_readreg(osl_t *osh, struct sbpcieregs *pcieregs,
+			 uint addrtype, uint offset);
+extern uint pcie_writereg(osl_t *osh, struct sbpcieregs *pcieregs,
+			  uint addrtype, uint offset, uint val);
+
+extern uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val);
+
+extern void *pcicore_init(si_t *sih, osl_t *osh, void *regs);
+extern void pcicore_deinit(void *pch);
+extern void pcicore_attach(void *pch, char *pvars, int state);
+extern void pcicore_hwup(void *pch);
+extern void pcicore_up(void *pch, int state);
+extern void pcicore_sleep(void *pch);
+extern void pcicore_down(void *pch, int state);
+
+extern void pcie_war_ovr_aspm_disable(void *pch);
+
+#ifdef BCMINTERNAL
+extern uint32 pcicore_pciereg(void *pch, uint32 offset, uint32 mask,
+			      uint32 val, uint type);
+extern uint32 pcicore_pcieserdesreg(void *pch, uint32 mdioslave,
+				    uint32 offset, uint32 mask,
+				    uint32 val);
+#ifdef BCMDBG
+extern int pcicore_dump_pcieregs(void *pch, struct bcmstrbuf *b);
+#endif
+#endif				/* BCMINTERNAL */
+#ifdef BCMDBG
+extern uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val);
+extern void pcicore_dump(void *pch, struct bcmstrbuf *b);
+#endif
+
+extern bool pcicore_pmecap_fast(osl_t *osh);
+extern void pcicore_pmeen(void *pch);
+extern bool pcicore_pmeclr(void *pch);
+#endif				/* (BCMBUSTYPE == SI_BUS) || defined(BCMSDIO) || defined(BCMDHDUSB) */
+
+#endif				/* _NICPCI_H */
diff --git a/include/asm-mips/bcmsi/osl.h b/include/asm-mips/bcmsi/osl.h
new file mode 100644
index 0000000..57138c4
--- /dev/null
+++ b/include/asm-mips/bcmsi/osl.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * OS Abstraction Layer
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _osl_h_
+#define _osl_h_
+
+/* osl handle type forward declaration */
+typedef struct osl_info osl_t;
+typedef struct osl_dmainfo osldma_t;
+
+#define OSL_PKTTAG_SZ	32	/* Size of PktTag */
+
+/* Drivers use PKTFREESETCB to register a callback function when a packet is freed by OSL */
+typedef void (*pktfree_cb_fn_t) (void *ctx, void *pkt,
+				 unsigned int status);
+
+#ifdef OSLREGOPS
+/* Drivers use REGOPSSET() to register register read/write funcitons */
+typedef unsigned int (*osl_rreg_fn_t) (void *ctx, void *reg,
+				       unsigned int size);
+typedef void (*osl_wreg_fn_t) (void *ctx, void *reg, unsigned int val,
+			       unsigned int size);
+#endif
+
+#if defined(vxworks)
+#include "vx_osl.h"
+#elif defined(__ECOS)
+#include "ecos_osl.h"
+#elif  defined(DOS)
+#include <dos_osl.h>
+#elif defined(PCBIOS)
+#include <pcbios_osl.h>
+#elif defined(__IOPOS__)
+#include <iopos_osl.h>
+#elif defined(linux)
+#include <asm/bcmsi/linux_osl.h>
+#elif defined(NDIS)
+#include <ndis_osl.h>
+#elif defined(_CFE_)
+#include <cfe_osl.h>
+#elif defined(_HNDRTE_)
+#include <hndrte_osl.h>
+#elif defined(_MINOSL_)
+#include <min_osl.h>
+#elif defined(MACOSX)
+#include <macosx_osl.h>
+#elif defined(__NetBSD__)
+#include <bsd_osl.h>
+#elif defined(EFI)
+#include <efi_osl.h>
+#else
+#error "Unsupported OSL requested"
+#endif				/* defined(vxworks) */
+
+/* handy */
+#define	SET_REG(osh, r, mask, val)	W_REG((osh), (r), ((R_REG((osh), r) & ~(mask)) | (val)))
+
+#endif				/* _osl_h_ */
diff --git a/include/asm-mips/bcmsi/pci_core.h b/include/asm-mips/bcmsi/pci_core.h
new file mode 100644
index 0000000..b18c653
--- /dev/null
+++ b/include/asm-mips/bcmsi/pci_core.h
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * BCM43XX PCI core hardware definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#ifndef	_PCI_CORE_H_
+#define	_PCI_CORE_H_
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* Sonics side: PCI core and host control registers */
+typedef struct sbpciregs {
+    uint32 control;		/* PCI control */
+    uint32 PAD[3];
+    uint32 arbcontrol;		/* PCI arbiter control */
+    uint32 clkrun;		/* Clkrun Control (>=rev11) */
+    uint32 PAD[2];
+    uint32 intstatus;		/* Interrupt status */
+    uint32 intmask;		/* Interrupt mask */
+    uint32 sbtopcimailbox;	/* Sonics to PCI mailbox */
+    uint32 PAD[9];
+    uint32 bcastaddr;		/* Sonics broadcast address */
+    uint32 bcastdata;		/* Sonics broadcast data */
+    uint32 PAD[2];
+    uint32 gpioin;		/* ro: gpio input (>=rev2) */
+    uint32 gpioout;		/* rw: gpio output (>=rev2) */
+    uint32 gpioouten;		/* rw: gpio output enable (>= rev2) */
+    uint32 gpiocontrol;		/* rw: gpio control (>= rev2) */
+    uint32 PAD[36];
+    uint32 sbtopci0;		/* Sonics to PCI translation 0 */
+    uint32 sbtopci1;		/* Sonics to PCI translation 1 */
+    uint32 sbtopci2;		/* Sonics to PCI translation 2 */
+    uint32 PAD[189];
+    uint32 pcicfg[4][64];	/* 0x400 - 0x7FF, PCI Cfg Space (>=rev8) */
+    uint16 sprom[36];		/* SPROM shadow Area */
+    uint32 PAD[46];
+} sbpciregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* PCI control */
+#define PCI_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
+#define PCI_RST		0x02	/* Value driven out to pin */
+#define PCI_CLK_OE	0x04	/* When set, drives clock as gated by PCI_CLK out to pin */
+#define PCI_CLK		0x08	/* Gate for clock driven out to pin */
+
+/* PCI arbiter control */
+#define PCI_INT_ARB	0x01	/* When set, use an internal arbiter */
+#define PCI_EXT_ARB	0x02	/* When set, use an external arbiter */
+/* ParkID - for PCI corerev >= 8 */
+#define PCI_PARKID_MASK		0x1c	/* Selects which agent is parked on an idle bus */
+#define PCI_PARKID_SHIFT	2
+#define PCI_PARKID_EXT0		0	/* External master 0 */
+#define PCI_PARKID_EXT1		1	/* External master 1 */
+#define PCI_PARKID_EXT2		2	/* External master 2 */
+#define PCI_PARKID_EXT3		3	/* External master 3 (rev >= 11) */
+#define PCI_PARKID_INT		3	/* Internal master (rev < 11) */
+#define PCI11_PARKID_INT	4	/* Internal master (rev >= 11) */
+#define PCI_PARKID_LAST		4	/* Last active master (rev < 11) */
+#define PCI11_PARKID_LAST	5	/* Last active master (rev >= 11) */
+
+#define PCI_CLKRUN_DSBL	0x8000	/* Bit 15 forceClkrun */
+
+/* Interrupt status/mask */
+#define PCI_INTA	0x01	/* PCI INTA# is asserted */
+#define PCI_INTB	0x02	/* PCI INTB# is asserted */
+#define PCI_SERR	0x04	/* PCI SERR# has been asserted (write one to clear) */
+#define PCI_PERR	0x08	/* PCI PERR# has been asserted (write one to clear) */
+#define PCI_PME		0x10	/* PCI PME# is asserted */
+
+/* (General) PCI/SB mailbox interrupts, two bits per pci function */
+#define	MAILBOX_F0_0	0x100	/* function 0, int 0 */
+#define	MAILBOX_F0_1	0x200	/* function 0, int 1 */
+#define	MAILBOX_F1_0	0x400	/* function 1, int 0 */
+#define	MAILBOX_F1_1	0x800	/* function 1, int 1 */
+#define	MAILBOX_F2_0	0x1000	/* function 2, int 0 */
+#define	MAILBOX_F2_1	0x2000	/* function 2, int 1 */
+#define	MAILBOX_F3_0	0x4000	/* function 3, int 0 */
+#define	MAILBOX_F3_1	0x8000	/* function 3, int 1 */
+
+/* Sonics broadcast address */
+#define BCAST_ADDR_MASK	0xff	/* Broadcast register address */
+
+/* Sonics to PCI translation types */
+#define SBTOPCI0_MASK	0xfc000000
+#define SBTOPCI1_MASK	0xfc000000
+#define SBTOPCI2_MASK	0xc0000000
+#define SBTOPCI_MEM	0
+#define SBTOPCI_IO	1
+#define SBTOPCI_CFG0	2
+#define SBTOPCI_CFG1	3
+#define	SBTOPCI_PREF	0x4	/* prefetch enable */
+#define	SBTOPCI_BURST	0x8	/* burst enable */
+#define	SBTOPCI_RC_MASK		0x30	/* read command (>= rev11) */
+#define	SBTOPCI_RC_READ		0x00	/* memory read */
+#define	SBTOPCI_RC_READLINE	0x10	/* memory read line */
+#define	SBTOPCI_RC_READMULTI	0x20	/* memory read multiple */
+
+/* PCI core index in SROM shadow area */
+#define SRSH_PI_OFFSET	0	/* first word */
+#define SRSH_PI_MASK	0xf000	/* bit 15:12 */
+#define SRSH_PI_SHIFT	12	/* bit 15:12 */
+
+#endif				/* _PCI_CORE_H_ */
diff --git a/include/asm-mips/bcmsi/pcicfg.h b/include/asm-mips/bcmsi/pcicfg.h
new file mode 100644
index 0000000..cb98dac
--- /dev/null
+++ b/include/asm-mips/bcmsi/pcicfg.h
@@ -0,0 +1,539 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * pcicfg.h: PCI configuration constants and structures.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_h_pcicfg_
+#define	_h_pcicfg_
+
+/* The following inside ifndef's so we don't collide with NTDDK.H */
+#ifndef PCI_MAX_BUS
+#define PCI_MAX_BUS		0x100
+#endif
+#ifndef PCI_MAX_DEVICES
+#define PCI_MAX_DEVICES		0x20
+#endif
+#ifndef PCI_MAX_FUNCTION
+#define PCI_MAX_FUNCTION	0x8
+#endif
+
+#ifndef PCI_INVALID_VENDORID
+#define PCI_INVALID_VENDORID	0xffff
+#endif
+#ifndef PCI_INVALID_DEVICEID
+#define PCI_INVALID_DEVICEID	0xffff
+#endif
+
+
+/* Convert between bus-slot-function-register and config addresses */
+
+#define	PCICFG_BUS_SHIFT	16	/* Bus shift */
+#define	PCICFG_SLOT_SHIFT	11	/* Slot shift */
+#define	PCICFG_FUN_SHIFT	8	/* Function shift */
+#define	PCICFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCICFG_BUS_MASK		0xff	/* Bus mask */
+#define	PCICFG_SLOT_MASK	0x1f	/* Slot mask */
+#define	PCICFG_FUN_MASK		7	/* Function mask */
+#define	PCICFG_OFF_MASK		0xff	/* Bus mask */
+
+#define	PCI_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCICFG_BUS_MASK) << PCICFG_BUS_SHIFT)		\
+		 | (((s) & PCICFG_SLOT_MASK) << PCICFG_SLOT_SHIFT)	\
+		 | (((f) & PCICFG_FUN_MASK) << PCICFG_FUN_SHIFT)	\
+		 | (((o) & PCICFG_OFF_MASK) << PCICFG_OFF_SHIFT))
+
+#define	PCI_CONFIG_BUS(a)	(((a) >> PCICFG_BUS_SHIFT) & PCICFG_BUS_MASK)
+#define	PCI_CONFIG_SLOT(a)	(((a) >> PCICFG_SLOT_SHIFT) & PCICFG_SLOT_MASK)
+#define	PCI_CONFIG_FUN(a)	(((a) >> PCICFG_FUN_SHIFT) & PCICFG_FUN_MASK)
+#define	PCI_CONFIG_OFF(a)	(((a) >> PCICFG_OFF_SHIFT) & PCICFG_OFF_MASK)
+
+/* PCIE Config space accessing MACROS */
+
+#define	PCIECFG_BUS_SHIFT	24	/* Bus shift */
+#define	PCIECFG_SLOT_SHIFT	19	/* Slot/Device shift */
+#define	PCIECFG_FUN_SHIFT	16	/* Function shift */
+#define	PCIECFG_OFF_SHIFT	0	/* Register shift */
+
+#define	PCIECFG_BUS_MASK	0xff	/* Bus mask */
+#define	PCIECFG_SLOT_MASK	0x1f	/* Slot/Device mask */
+#define	PCIECFG_FUN_MASK	7	/* Function mask */
+#define	PCIECFG_OFF_MASK	0xfff	/* Register mask */
+
+#define	PCIE_CONFIG_ADDR(b, s, f, o)					\
+		((((b) & PCIECFG_BUS_MASK) << PCIECFG_BUS_SHIFT)		\
+		 | (((s) & PCIECFG_SLOT_MASK) << PCIECFG_SLOT_SHIFT)	\
+		 | (((f) & PCIECFG_FUN_MASK) << PCIECFG_FUN_SHIFT)	\
+		 | (((o) & PCIECFG_OFF_MASK) << PCIECFG_OFF_SHIFT))
+
+#define	PCIE_CONFIG_BUS(a)	(((a) >> PCIECFG_BUS_SHIFT) & PCIECFG_BUS_MASK)
+#define	PCIE_CONFIG_SLOT(a)	(((a) >> PCIECFG_SLOT_SHIFT) & PCIECFG_SLOT_MASK)
+#define	PCIE_CONFIG_FUN(a)	(((a) >> PCIECFG_FUN_SHIFT) & PCIECFG_FUN_MASK)
+#define	PCIE_CONFIG_OFF(a)	(((a) >> PCIECFG_OFF_SHIFT) & PCIECFG_OFF_MASK)
+
+/* The actual config space */
+
+#define	PCI_BAR_MAX		6
+
+#define	PCI_ROM_BAR		8
+
+#define	PCR_RSVDA_MAX		2
+
+/* Bits in PCI bars' flags */
+
+#define	PCIBAR_FLAGS		0xf
+#define	PCIBAR_IO		0x1
+#define	PCIBAR_MEM1M		0x2
+#define	PCIBAR_MEM64		0x4
+#define	PCIBAR_PREFETCH		0x8
+#define	PCIBAR_MEM32_MASK	0xFFFFFF80
+
+/* pci config status reg has a bit to indicate that capability ptr is present */
+
+#define PCI_CAPPTR_PRESENT	0x0010
+
+typedef struct _pci_config_regs {
+    unsigned short vendor;
+    unsigned short device;
+    unsigned short command;
+    unsigned short status;
+    unsigned char rev_id;
+    unsigned char prog_if;
+    unsigned char sub_class;
+    unsigned char base_class;
+    unsigned char cache_line_size;
+    unsigned char latency_timer;
+    unsigned char header_type;
+    unsigned char bist;
+    unsigned long base[PCI_BAR_MAX];
+    unsigned long cardbus_cis;
+    unsigned short subsys_vendor;
+    unsigned short subsys_id;
+    unsigned long baserom;
+    unsigned long rsvd_a[PCR_RSVDA_MAX];
+    unsigned char int_line;
+    unsigned char int_pin;
+    unsigned char min_gnt;
+    unsigned char max_lat;
+    unsigned char dev_dep[192];
+} pci_config_regs;
+
+#define	SZPCR		(sizeof (pci_config_regs))
+#define	MINSZPCR	64	/* offsetof (dev_dep[0] */
+
+/* A structure for the config registers is nice, but in most
+ * systems the config space is not memory mapped, so we need
+ * field offsetts. :-(
+ */
+#define	PCI_CFG_VID		0
+#define	PCI_CFG_DID		2
+#define	PCI_CFG_CMD		4
+#define	PCI_CFG_STAT		6
+#define	PCI_CFG_REV		8
+#define	PCI_CFG_PROGIF		9
+#define	PCI_CFG_SUBCL		0xa
+#define	PCI_CFG_BASECL		0xb
+#define	PCI_CFG_CLSZ		0xc
+#define	PCI_CFG_LATTIM		0xd
+#define	PCI_CFG_HDR		0xe
+#define	PCI_CFG_BIST		0xf
+#define	PCI_CFG_BAR0		0x10
+#define	PCI_CFG_BAR1		0x14
+#define	PCI_CFG_BAR2		0x18
+#define	PCI_CFG_BAR3		0x1c
+#define	PCI_CFG_BAR4		0x20
+#define	PCI_CFG_BAR5		0x24
+#define	PCI_CFG_CIS		0x28
+#define	PCI_CFG_SVID		0x2c
+#define	PCI_CFG_SSID		0x2e
+#define	PCI_CFG_ROMBAR		0x30
+#define PCI_CFG_CAPPTR		0x34
+#define	PCI_CFG_INT		0x3c
+#define	PCI_CFG_PIN		0x3d
+#define	PCI_CFG_MINGNT		0x3e
+#define	PCI_CFG_MAXLAT		0x3f
+
+#ifdef __NetBSD__
+/* Workaround to undefine PCI base class names in NetBSD due
+ * to a clash in the namespace
+ */
+#undef	PCI_CLASS_DISPLAY
+#undef	PCI_CLASS_MEMORY
+#undef	PCI_CLASS_BRIDGE
+#undef	PCI_CLASS_INPUT
+#undef	PCI_CLASS_DOCK
+#endif				/* __NetBSD__ */
+
+#ifdef EFI
+#undef PCI_CLASS_BRIDGE
+#undef PCI_CLASS_OLD
+#undef PCI_CLASS_DISPLAY
+#undef PCI_CLASS_SERIAL
+#undef PCI_CLASS_SATELLITE
+#endif				/* EFI */
+
+/* Classes and subclasses */
+
+typedef enum {
+    PCI_CLASS_OLD = 0,
+    PCI_CLASS_DASDI,
+    PCI_CLASS_NET,
+    PCI_CLASS_DISPLAY,
+    PCI_CLASS_MMEDIA,
+    PCI_CLASS_MEMORY,
+    PCI_CLASS_BRIDGE,
+    PCI_CLASS_COMM,
+    PCI_CLASS_BASE,
+    PCI_CLASS_INPUT,
+    PCI_CLASS_DOCK,
+    PCI_CLASS_CPU,
+    PCI_CLASS_SERIAL,
+    PCI_CLASS_INTELLIGENT = 0xe,
+    PCI_CLASS_SATELLITE,
+    PCI_CLASS_CRYPT,
+    PCI_CLASS_DSP,
+    PCI_CLASS_XOR = 0xfe
+} pci_classes;
+
+typedef enum {
+    PCI_DASDI_SCSI,
+    PCI_DASDI_IDE,
+    PCI_DASDI_FLOPPY,
+    PCI_DASDI_IPI,
+    PCI_DASDI_RAID,
+    PCI_DASDI_OTHER = 0x80
+} pci_dasdi_subclasses;
+
+typedef enum {
+    PCI_NET_ETHER,
+    PCI_NET_TOKEN,
+    PCI_NET_FDDI,
+    PCI_NET_ATM,
+    PCI_NET_OTHER = 0x80
+} pci_net_subclasses;
+
+typedef enum {
+    PCI_DISPLAY_VGA,
+    PCI_DISPLAY_XGA,
+    PCI_DISPLAY_3D,
+    PCI_DISPLAY_OTHER = 0x80
+} pci_display_subclasses;
+
+typedef enum {
+    PCI_MMEDIA_VIDEO,
+    PCI_MMEDIA_AUDIO,
+    PCI_MMEDIA_PHONE,
+    PCI_MEDIA_OTHER = 0x80
+} pci_mmedia_subclasses;
+
+typedef enum {
+    PCI_MEMORY_RAM,
+    PCI_MEMORY_FLASH,
+    PCI_MEMORY_OTHER = 0x80
+} pci_memory_subclasses;
+
+typedef enum {
+    PCI_BRIDGE_HOST,
+    PCI_BRIDGE_ISA,
+    PCI_BRIDGE_EISA,
+    PCI_BRIDGE_MC,
+    PCI_BRIDGE_PCI,
+    PCI_BRIDGE_PCMCIA,
+    PCI_BRIDGE_NUBUS,
+    PCI_BRIDGE_CARDBUS,
+    PCI_BRIDGE_RACEWAY,
+    PCI_BRIDGE_OTHER = 0x80
+} pci_bridge_subclasses;
+
+typedef enum {
+    PCI_COMM_UART,
+    PCI_COMM_PARALLEL,
+    PCI_COMM_MULTIUART,
+    PCI_COMM_MODEM,
+    PCI_COMM_OTHER = 0x80
+} pci_comm_subclasses;
+
+typedef enum {
+    PCI_BASE_PIC,
+    PCI_BASE_DMA,
+    PCI_BASE_TIMER,
+    PCI_BASE_RTC,
+    PCI_BASE_PCI_HOTPLUG,
+    PCI_BASE_OTHER = 0x80
+} pci_base_subclasses;
+
+typedef enum {
+    PCI_INPUT_KBD,
+    PCI_INPUT_PEN,
+    PCI_INPUT_MOUSE,
+    PCI_INPUT_SCANNER,
+    PCI_INPUT_GAMEPORT,
+    PCI_INPUT_OTHER = 0x80
+} pci_input_subclasses;
+
+typedef enum {
+    PCI_DOCK_GENERIC,
+    PCI_DOCK_OTHER = 0x80
+} pci_dock_subclasses;
+
+typedef enum {
+    PCI_CPU_386,
+    PCI_CPU_486,
+    PCI_CPU_PENTIUM,
+    PCI_CPU_ALPHA = 0x10,
+    PCI_CPU_POWERPC = 0x20,
+    PCI_CPU_MIPS = 0x30,
+    PCI_CPU_COPROC = 0x40,
+    PCI_CPU_OTHER = 0x80
+} pci_cpu_subclasses;
+
+typedef enum {
+    PCI_SERIAL_IEEE1394,
+    PCI_SERIAL_ACCESS,
+    PCI_SERIAL_SSA,
+    PCI_SERIAL_USB,
+    PCI_SERIAL_FIBER,
+    PCI_SERIAL_SMBUS,
+    PCI_SERIAL_OTHER = 0x80
+} pci_serial_subclasses;
+
+typedef enum {
+    PCI_INTELLIGENT_I2O
+} pci_intelligent_subclasses;
+
+typedef enum {
+    PCI_SATELLITE_TV,
+    PCI_SATELLITE_AUDIO,
+    PCI_SATELLITE_VOICE,
+    PCI_SATELLITE_DATA,
+    PCI_SATELLITE_OTHER = 0x80
+} pci_satellite_subclasses;
+
+typedef enum {
+    PCI_CRYPT_NETWORK,
+    PCI_CRYPT_ENTERTAINMENT,
+    PCI_CRYPT_OTHER = 0x80
+} pci_crypt_subclasses;
+
+typedef enum {
+    PCI_DSP_DPIO,
+    PCI_DSP_OTHER = 0x80
+} pci_dsp_subclasses;
+
+typedef enum {
+    PCI_XOR_QDMA,
+    PCI_XOR_OTHER = 0x80
+} pci_xor_subclasses;
+
+/* Header types */
+#define	PCI_HEADER_MULTI	0x80
+#define	PCI_HEADER_MASK		0x7f
+typedef enum {
+    PCI_HEADER_NORMAL,
+    PCI_HEADER_BRIDGE,
+    PCI_HEADER_CARDBUS
+} pci_header_types;
+
+
+/* Overlay for a PCI-to-PCI bridge */
+
+#define	PPB_RSVDA_MAX		2
+#define	PPB_RSVDD_MAX		8
+
+typedef struct _ppb_config_regs {
+    unsigned short vendor;
+    unsigned short device;
+    unsigned short command;
+    unsigned short status;
+    unsigned char rev_id;
+    unsigned char prog_if;
+    unsigned char sub_class;
+    unsigned char base_class;
+    unsigned char cache_line_size;
+    unsigned char latency_timer;
+    unsigned char header_type;
+    unsigned char bist;
+    unsigned long rsvd_a[PPB_RSVDA_MAX];
+    unsigned char prim_bus;
+    unsigned char sec_bus;
+    unsigned char sub_bus;
+    unsigned char sec_lat;
+    unsigned char io_base;
+    unsigned char io_lim;
+    unsigned short sec_status;
+    unsigned short mem_base;
+    unsigned short mem_lim;
+    unsigned short pf_mem_base;
+    unsigned short pf_mem_lim;
+    unsigned long pf_mem_base_hi;
+    unsigned long pf_mem_lim_hi;
+    unsigned short io_base_hi;
+    unsigned short io_lim_hi;
+    unsigned short subsys_vendor;
+    unsigned short subsys_id;
+    unsigned long rsvd_b;
+    unsigned char rsvd_c;
+    unsigned char int_pin;
+    unsigned short bridge_ctrl;
+    unsigned char chip_ctrl;
+    unsigned char diag_ctrl;
+    unsigned short arb_ctrl;
+    unsigned long rsvd_d[PPB_RSVDD_MAX];
+    unsigned char dev_dep[192];
+} ppb_config_regs;
+
+
+/* PCI CAPABILITY DEFINES */
+#define PCI_CAP_POWERMGMTCAP_ID		0x01
+#define PCI_CAP_MSICAP_ID		0x05
+#define PCI_CAP_VENDSPEC_ID		0x09
+#define PCI_CAP_PCIECAP_ID		0x10
+
+/* Data structure to define the Message Signalled Interrupt facility 
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_msi {
+    unsigned char capID;
+    unsigned char nextptr;
+    unsigned short msgctrl;
+    unsigned int msgaddr;
+} pciconfig_cap_msi;
+
+/* Data structure to define the Power managment facility
+ * Valid for PCI and PCIE configurations
+ */
+typedef struct _pciconfig_cap_pwrmgmt {
+    unsigned char capID;
+    unsigned char nextptr;
+    unsigned short pme_cap;
+    unsigned short pme_sts_ctrl;
+    unsigned char pme_bridge_ext;
+    unsigned char data;
+} pciconfig_cap_pwrmgmt;
+
+#define PME_CAP_PM_STATES (0x1f << 27)	/* Bits 31:27 states that can generate PME */
+#define PME_CSR_OFFSET	    0x4	/* 4-bytes offset */
+#define PME_CSR_PME_EN	  (1 << 8)	/* Bit 8 Enable generating of PME */
+#define PME_CSR_PME_STAT  (1 << 15)	/* Bit 15 PME got asserted */
+
+/* Data structure to define the PCIE capability */
+typedef struct _pciconfig_cap_pcie {
+    unsigned char capID;
+    unsigned char nextptr;
+    unsigned short pcie_cap;
+    unsigned int dev_cap;
+    unsigned short dev_ctrl;
+    unsigned short dev_status;
+    unsigned int link_cap;
+    unsigned short link_ctrl;
+    unsigned short link_status;
+    unsigned short slot_cap;
+    unsigned short slot_ctrl;
+    unsigned short slot_status;
+    unsigned short root_cap;
+    unsigned short root_ctrl;
+    unsigned short root_status;
+} pciconfig_cap_pcie;
+
+/* PCIE Enhanced CAPABILITY DEFINES */
+#define PCIE_EXTCFG_OFFSET	0x100
+#define PCIE_ADVERRREP_CAPID	0x0001
+#define PCIE_VC_CAPID		0x0002
+#define PCIE_DEVSNUM_CAPID	0x0003
+#define PCIE_PWRBUDGET_CAPID	0x0004
+
+/* Header to define the PCIE specific capabilities in the extended config space */
+typedef struct _pcie_enhanced_caphdr {
+    unsigned short capID;
+    unsigned short cap_ver:4;
+    unsigned short next_ptr:12;
+} pcie_enhanced_caphdr;
+
+
+/* Everything below is BRCM HND proprietary */
+
+
+/* Brcm PCI configuration registers */
+#define cap_list	rsvd_a[0]
+#define bar0_window	dev_dep[0x80 - 0x40]
+#define bar1_window	dev_dep[0x84 - 0x40]
+#define sprom_control	dev_dep[0x88 - 0x40]
+
+#define	PCI_BAR0_WIN		0x80	/* backplane addres space accessed by BAR0 */
+#define	PCI_BAR1_WIN		0x84	/* backplane addres space accessed by BAR1 */
+#define	PCI_SPROM_CONTROL	0x88	/* sprom property control */
+#define	PCI_BAR1_CONTROL	0x8c	/* BAR1 region burst control */
+#define	PCI_INT_STATUS		0x90	/* PCI and other cores interrupts */
+#define	PCI_INT_MASK		0x94	/* mask of PCI and other cores interrupts */
+#define PCI_TO_SB_MB		0x98	/* signal backplane interrupts */
+#define PCI_BACKPLANE_ADDR	0xa0	/* address an arbitrary location on the system backplane */
+#define PCI_BACKPLANE_DATA	0xa4	/* data at the location specified by above address */
+#define	PCI_CLK_CTL_ST		0xa8	/* pci config space clock control/status (>=rev14) */
+#define	PCI_BAR0_WIN2		0xac	/* backplane addres space accessed by second 4KB of BAR0 */
+#define	PCI_GPIO_IN		0xb0	/* pci config space gpio input (>=rev3) */
+#define	PCI_GPIO_OUT		0xb4	/* pci config space gpio output (>=rev3) */
+#define	PCI_GPIO_OUTEN		0xb8	/* pci config space gpio output enable (>=rev3) */
+
+#define	PCI_BAR0_SHADOW_OFFSET	(2 * 1024)	/* bar0 + 2K accesses sprom shadow (in pci core) */
+#define	PCI_BAR0_SPROM_OFFSET	(4 * 1024)	/* bar0 + 4K accesses external sprom */
+#define	PCI_BAR0_PCIREGS_OFFSET	(6 * 1024)	/* bar0 + 6K accesses pci core registers */
+#define	PCI_BAR0_PCISBR_OFFSET	(4 * 1024)	/* pci core SB registers are at the end of the
+						 * 8KB window, so their address is the "regular"
+						 * address plus 4K
+						 */
+#define PCI_BAR0_WINSZ		(16 * 1024)	/* bar0 window size Match with corerev 13 */
+
+/* On pci corerev >= 13 and all pcie, the bar0 is now 16KB and it maps: */
+#define	PCI_16KB0_PCIREGS_OFFSET (8 * 1024)	/* bar0 + 8K accesses pci/pcie core registers */
+#define	PCI_16KB0_CCREGS_OFFSET	(12 * 1024)	/* bar0 + 12K accesses chipc core registers */
+#define PCI_16KBB0_WINSZ	(16 * 1024)	/* bar0 window size */
+
+/* PCI_INT_STATUS */
+#define	PCI_SBIM_STATUS_SERR	0x4	/* backplane SBErr interrupt status */
+
+/* PCI_INT_MASK */
+#define	PCI_SBIM_SHIFT		8	/* backplane core interrupt mask bits offset */
+#define	PCI_SBIM_MASK		0xff00	/* backplane core interrupt mask */
+#define	PCI_SBIM_MASK_SERR	0x4	/* backplane SBErr interrupt mask */
+
+/* PCI_SPROM_CONTROL */
+#define SPROM_SZ_MSK		0x02	/* SPROM Size Mask */
+#define SPROM_LOCKED		0x08	/* SPROM Locked */
+#define	SPROM_BLANK		0x04	/* indicating a blank SPROM */
+#define SPROM_WRITEEN		0x10	/* SPROM write enable */
+#define SPROM_BOOTROM_WE	0x20	/* external bootrom write enable */
+#define SPROM_BACKPLANE_EN	0x40	/* Enable indirect backplane access */
+#define SPROM_OTPIN_USE		0x80	/* device OTP In use */
+
+/* Bits in PCI command and status regs */
+#define PCI_CMD_IO		0x00000001	/* I/O enable */
+#define PCI_CMD_MEMORY		0x00000002	/* Memory enable */
+#define PCI_CMD_MASTER		0x00000004	/* Master enable */
+#define PCI_CMD_SPECIAL		0x00000008	/* Special cycles enable */
+#define PCI_CMD_INVALIDATE	0x00000010	/* Invalidate? */
+#define PCI_CMD_VGA_PAL		0x00000040	/* VGA Palate */
+#define PCI_STAT_TA		0x08000000	/* target abort status */
+
+#endif				/* _h_pcicfg_ */
diff --git a/include/asm-mips/bcmsi/pcie_core.h b/include/asm-mips/bcmsi/pcie_core.h
new file mode 100644
index 0000000..0738de9
--- /dev/null
+++ b/include/asm-mips/bcmsi/pcie_core.h
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * BCM43XX PCIE core hardware definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+#ifndef	_PCIE_CORE_H
+#define	_PCIE_CORE_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* PCIE Enumeration space offsets */
+#define  PCIE_CORE_CONFIG_OFFSET	0x0
+#define  PCIE_FUNC0_CONFIG_OFFSET	0x400
+#define  PCIE_FUNC1_CONFIG_OFFSET	0x500
+#define  PCIE_FUNC2_CONFIG_OFFSET	0x600
+#define  PCIE_FUNC3_CONFIG_OFFSET	0x700
+#define  PCIE_SPROM_SHADOW_OFFSET	0x800
+#define  PCIE_SBCONFIG_OFFSET		0xE00
+
+/* PCIE Bar0 Address Mapping. Each function maps 16KB config space */
+#define PCIE_DEV_BAR0_SIZE		0x4000
+#define PCIE_BAR0_WINMAPCORE_OFFSET	0x0
+#define PCIE_BAR0_EXTSPROM_OFFSET	0x1000
+#define PCIE_BAR0_PCIECORE_OFFSET	0x2000
+#define PCIE_BAR0_CCCOREREG_OFFSET	0x3000
+
+/* different register spaces to access thr'u pcie indirect access */
+#define PCIE_CONFIGREGS 	1	/* Access to config space */
+#define PCIE_PCIEREGS 		2	/* Access to pcie registers */
+
+/* SB side: PCIE core and host control registers */
+typedef struct sbpcieregs {
+    uint32 control;		/* host mode only */
+    uint32 PAD[2];
+    uint32 biststatus;		/* bist Status: 0x00C */
+    uint32 gpiosel;		/* PCIE gpio sel: 0x010 */
+    uint32 gpioouten;		/* PCIE gpio outen: 0x14 */
+    uint32 PAD[2];
+    uint32 intstatus;		/* Interrupt status: 0x20 */
+    uint32 intmask;		/* Interrupt mask: 0x24 */
+    uint32 sbtopcimailbox;	/* sb to pcie mailbox: 0x028 */
+    uint32 PAD[53];
+    uint32 sbtopcie0;		/* sb to pcie translation 0: 0x100 */
+    uint32 sbtopcie1;		/* sb to pcie translation 1: 0x104 */
+    uint32 sbtopcie2;		/* sb to pcie translation 2: 0x108 */
+    uint32 PAD[5];
+
+    /* pcie core supports in direct access to config space */
+    uint32 configaddr;		/* pcie config space access: Address field: 0x120 */
+    uint32 configdata;		/* pcie config space access: Data field: 0x124 */
+
+    /* mdio access to serdes */
+    uint32 mdiocontrol;		/* controls the mdio access: 0x128 */
+    uint32 mdiodata;		/* Data to the mdio access: 0x12c */
+
+    /* pcie protocol phy/dllp/tlp register indirect access mechanism */
+    uint32 pcieindaddr;		/* indirect access to the internal register: 0x130 */
+    uint32 pcieinddata;		/* Data to/from the internal regsiter: 0x134 */
+
+    uint32 clkreqenctrl;	/* >= rev 6, Clkreq rdma control : 0x138 */
+    uint32 PAD[177];
+    uint32 pciecfg[4][64];	/* 0x400 - 0x7FF, PCIE Cfg Space */
+    uint16 sprom[36];		/* SPROM shadow Area */
+} sbpcieregs_t;
+
+/* PCI control */
+#define PCIE_RST_OE	0x01	/* When set, drives PCI_RESET out to pin */
+#define PCIE_RST	0x02	/* Value driven out to pin */
+
+#define	PCIE_CFGADDR	0x120	/* offsetof(configaddr) */
+#define	PCIE_CFGDATA	0x124	/* offsetof(configdata) */
+
+/* Interrupt status/mask */
+#define PCIE_INTA	0x01	/* PCIE INTA message is received */
+#define PCIE_INTB	0x02	/* PCIE INTB message is received */
+#define PCIE_INTFATAL	0x04	/* PCIE INTFATAL message is received */
+#define PCIE_INTNFATAL	0x08	/* PCIE INTNONFATAL message is received */
+#define PCIE_INTCORR	0x10	/* PCIE INTCORR message is received */
+#define PCIE_INTPME	0x20	/* PCIE INTPME message is received */
+
+/* SB to PCIE translation masks */
+#define SBTOPCIE0_MASK	0xfc000000
+#define SBTOPCIE1_MASK	0xfc000000
+#define SBTOPCIE2_MASK	0xc0000000
+
+/* Access type bits (0:1) */
+#define SBTOPCIE_MEM	0
+#define SBTOPCIE_IO	1
+#define SBTOPCIE_CFG0	2
+#define SBTOPCIE_CFG1	3
+
+/* Prefetch enable bit 2 */
+#define SBTOPCIE_PF		4
+
+/* Write Burst enable for memory write bit 3 */
+#define SBTOPCIE_WR_BURST	8
+
+/* config access */
+#define CONFIGADDR_FUNC_MASK	0x7000
+#define CONFIGADDR_FUNC_SHF	12
+#define CONFIGADDR_REG_MASK	0x0FFF
+#define CONFIGADDR_REG_SHF	0
+
+/* PCIE protocol regs Indirect Address */
+#define PCIEADDR_PROT_MASK	0x300
+#define PCIEADDR_PROT_SHF	8
+#define PCIEADDR_PL_TLP		0
+#define PCIEADDR_PL_DLLP	1
+#define PCIEADDR_PL_PLP		2
+
+/* PCIE protocol PHY diagnostic registers */
+#define	PCIE_PLP_MODEREG		0x200	/* Mode */
+#define	PCIE_PLP_STATUSREG		0x204	/* Status */
+#define PCIE_PLP_LTSSMCTRLREG		0x208	/* LTSSM control */
+#define PCIE_PLP_LTLINKNUMREG		0x20c	/* Link Training Link number */
+#define PCIE_PLP_LTLANENUMREG		0x210	/* Link Training Lane number */
+#define PCIE_PLP_LTNFTSREG		0x214	/* Link Training N_FTS */
+#define PCIE_PLP_ATTNREG		0x218	/* Attention */
+#define PCIE_PLP_ATTNMASKREG		0x21C	/* Attention Mask */
+#define PCIE_PLP_RXERRCTR		0x220	/* Rx Error */
+#define PCIE_PLP_RXFRMERRCTR		0x224	/* Rx Framing Error */
+#define PCIE_PLP_RXERRTHRESHREG		0x228	/* Rx Error threshold */
+#define PCIE_PLP_TESTCTRLREG		0x22C	/* Test Control reg */
+#define PCIE_PLP_SERDESCTRLOVRDREG	0x230	/* SERDES Control Override */
+#define PCIE_PLP_TIMINGOVRDREG		0x234	/* Timing param override */
+#define PCIE_PLP_RXTXSMDIAGREG		0x238	/* RXTX State Machine Diag */
+#define PCIE_PLP_LTSSMDIAGREG		0x23C	/* LTSSM State Machine Diag */
+
+/* PCIE protocol DLLP diagnostic registers */
+#define PCIE_DLLP_LCREG			0x100	/* Link Control */
+#define PCIE_DLLP_LSREG			0x104	/* Link Status */
+#define PCIE_DLLP_LAREG			0x108	/* Link Attention */
+#define PCIE_DLLP_LAMASKREG		0x10C	/* Link Attention Mask */
+#define PCIE_DLLP_NEXTTXSEQNUMREG	0x110	/* Next Tx Seq Num */
+#define PCIE_DLLP_ACKEDTXSEQNUMREG	0x114	/* Acked Tx Seq Num */
+#define PCIE_DLLP_PURGEDTXSEQNUMREG	0x118	/* Purged Tx Seq Num */
+#define PCIE_DLLP_RXSEQNUMREG		0x11C	/* Rx Sequence Number */
+#define PCIE_DLLP_LRREG			0x120	/* Link Replay */
+#define PCIE_DLLP_LACKTOREG		0x124	/* Link Ack Timeout */
+#define PCIE_DLLP_PMTHRESHREG		0x128	/* Power Management Threshold */
+#define PCIE_DLLP_RTRYWPREG		0x12C	/* Retry buffer write ptr */
+#define PCIE_DLLP_RTRYRPREG		0x130	/* Retry buffer Read ptr */
+#define PCIE_DLLP_RTRYPPREG		0x134	/* Retry buffer Purged ptr */
+#define PCIE_DLLP_RTRRWREG		0x138	/* Retry buffer Read/Write */
+#define PCIE_DLLP_ECTHRESHREG		0x13C	/* Error Count Threshold */
+#define PCIE_DLLP_TLPERRCTRREG		0x140	/* TLP Error Counter */
+#define PCIE_DLLP_ERRCTRREG		0x144	/* Error Counter */
+#define PCIE_DLLP_NAKRXCTRREG		0x148	/* NAK Received Counter */
+#define PCIE_DLLP_TESTREG		0x14C	/* Test */
+#define PCIE_DLLP_PKTBIST		0x150	/* Packet BIST */
+#define PCIE_DLLP_PCIE11		0x154	/* DLLP PCIE 1.1 reg */
+
+#define PCIE_DLLP_LSREG_LINKUP		(1 << 16)
+
+/* PCIE protocol TLP diagnostic registers */
+#define PCIE_TLP_CONFIGREG		0x000	/* Configuration */
+#define PCIE_TLP_WORKAROUNDSREG		0x004	/* TLP Workarounds */
+#define PCIE_TLP_WRDMAUPPER		0x010	/* Write DMA Upper Address */
+#define PCIE_TLP_WRDMALOWER		0x014	/* Write DMA Lower Address */
+#define PCIE_TLP_WRDMAREQ_LBEREG	0x018	/* Write DMA Len/ByteEn Req */
+#define PCIE_TLP_RDDMAUPPER		0x01C	/* Read DMA Upper Address */
+#define PCIE_TLP_RDDMALOWER		0x020	/* Read DMA Lower Address */
+#define PCIE_TLP_RDDMALENREG		0x024	/* Read DMA Len Req */
+#define PCIE_TLP_MSIDMAUPPER		0x028	/* MSI DMA Upper Address */
+#define PCIE_TLP_MSIDMALOWER		0x02C	/* MSI DMA Lower Address */
+#define PCIE_TLP_MSIDMALENREG		0x030	/* MSI DMA Len Req */
+#define PCIE_TLP_SLVREQLENREG		0x034	/* Slave Request Len */
+#define PCIE_TLP_FCINPUTSREQ		0x038	/* Flow Control Inputs */
+#define PCIE_TLP_TXSMGRSREQ		0x03C	/* Tx StateMachine and Gated Req */
+#define PCIE_TLP_ADRACKCNTARBLEN	0x040	/* Address Ack XferCnt and ARB Len */
+#define PCIE_TLP_DMACPLHDR0		0x044	/* DMA Completion Hdr 0 */
+#define PCIE_TLP_DMACPLHDR1		0x048	/* DMA Completion Hdr 1 */
+#define PCIE_TLP_DMACPLHDR2		0x04C	/* DMA Completion Hdr 2 */
+#define PCIE_TLP_DMACPLMISC0		0x050	/* DMA Completion Misc0 */
+#define PCIE_TLP_DMACPLMISC1		0x054	/* DMA Completion Misc1 */
+#define PCIE_TLP_DMACPLMISC2		0x058	/* DMA Completion Misc2 */
+#define PCIE_TLP_SPTCTRLLEN		0x05C	/* Split Controller Req len */
+#define PCIE_TLP_SPTCTRLMSIC0		0x060	/* Split Controller Misc 0 */
+#define PCIE_TLP_SPTCTRLMSIC1		0x064	/* Split Controller Misc 1 */
+#define PCIE_TLP_BUSDEVFUNC		0x068	/* Bus/Device/Func */
+#define PCIE_TLP_RESETCTR		0x06C	/* Reset Counter */
+#define PCIE_TLP_RTRYBUF		0x070	/* Retry Buffer value */
+#define PCIE_TLP_TGTDEBUG1		0x074	/* Target Debug Reg1 */
+#define PCIE_TLP_TGTDEBUG2		0x078	/* Target Debug Reg2 */
+#define PCIE_TLP_TGTDEBUG3		0x07C	/* Target Debug Reg3 */
+#define PCIE_TLP_TGTDEBUG4		0x080	/* Target Debug Reg4 */
+
+/* MDIO control */
+#define MDIOCTL_DIVISOR_MASK		0x7f	/* clock to be used on MDIO */
+#define MDIOCTL_DIVISOR_VAL		0x2
+#define MDIOCTL_PREAM_EN		0x80	/* Enable preamble sequnce */
+#define MDIOCTL_ACCESS_DONE		0x100	/* Tranaction complete */
+
+/* MDIO Data */
+#define MDIODATA_MASK			0x0000ffff	/* data 2 bytes */
+#define MDIODATA_TA			0x00020000	/* Turnaround */
+#define MDIODATA_REGADDR_SHF_OLD	18	/* Regaddr shift (rev < 10) */
+#define MDIODATA_REGADDR_MASK_OLD	0x003c0000	/* Regaddr Mask (rev < 10) */
+#define MDIODATA_DEVADDR_SHF_OLD	22	/* Physmedia devaddr shift (rev < 10) */
+#define MDIODATA_DEVADDR_MASK_OLD	0x0fc00000	/* Physmedia devaddr Mask (rev < 10) */
+#define MDIODATA_REGADDR_SHF		18	/* Regaddr shift */
+#define MDIODATA_REGADDR_MASK		0x007c0000	/* Regaddr Mask */
+#define MDIODATA_DEVADDR_SHF		23	/* Physmedia devaddr shift */
+#define MDIODATA_DEVADDR_MASK		0x0f800000	/* Physmedia devaddr Mask */
+#define MDIODATA_WRITE			0x10000000	/* write Transaction */
+#define MDIODATA_READ			0x20000000	/* Read Transaction */
+#define MDIODATA_START			0x40000000	/* start of Transaction */
+
+#define MDIODATA_DEV_ADDR		0x0	/* dev address for serdes */
+#define	MDIODATA_BLK_ADDR		0x1F	/* blk address for serdes */
+
+
+/* MDIO devices (SERDES modules) 
+ *  unlike old pcie cores (rev < 10), rev10 pcie serde organizes registers into a few blocks.
+ *  two layers mapping (blockidx, register offset) is required
+ */
+#define MDIO_DEV_IEEE0		0x000
+#define MDIO_DEV_IEEE1		0x001
+#define MDIO_DEV_BLK0		0x800
+#define MDIO_DEV_BLK1		0x801
+#define MDIO_DEV_BLK2		0x802
+#define MDIO_DEV_BLK3		0x803
+#define MDIO_DEV_BLK4		0x804
+#define MDIO_DEV_TXPLL		0x808	/* TXPLL register block idx */
+#define MDIO_DEV_TXCTRL0	0x820
+#define MDIO_DEV_SERDESID	0x831
+#define MDIO_DEV_RXCTRL0	0x840
+
+/* serdes regs (rev < 10) */
+#define MDIODATA_DEV_PLL       		0x1d	/* SERDES PLL Dev */
+#define MDIODATA_DEV_TX        		0x1e	/* SERDES TX Dev */
+#define MDIODATA_DEV_RX        		0x1f	/* SERDES RX Dev */
+	/* SERDES RX registers */
+#define SERDES_RX_CTRL			1	/* Rx cntrl */
+#define SERDES_RX_TIMER1		2	/* Rx Timer1 */
+#define SERDES_RX_CDR			6	/* CDR */
+#define SERDES_RX_CDRBW			7	/* CDR BW */
+
+	/* SERDES RX control register */
+#define SERDES_RX_CTRL_FORCE		0x80	/* rxpolarity_force */
+#define SERDES_RX_CTRL_POLARITY		0x40	/* rxpolarity_value */
+
+	/* SERDES PLL registers */
+#define SERDES_PLL_CTRL                 1	/* PLL control reg */
+#define PLL_CTRL_FREQDET_EN             0x4000	/* bit 14 is FREQDET on */
+
+/* Power management threshold */
+#define PCIE_L0THRESHOLDTIME_MASK       0xFF00	/* bits 0 - 7 */
+#define PCIE_L1THRESHOLDTIME_MASK       0xFF00	/* bits 8 - 15 */
+#define PCIE_L1THRESHOLDTIME_SHIFT      8	/* PCIE_L1THRESHOLDTIME_SHIFT */
+#define PCIE_L1THRESHOLD_WARVAL         0x72	/* WAR value */
+#define PCIE_ASPMTIMER_EXTEND		0x01000000	/* > rev7: enable extend ASPM timer */
+
+/* SPROM offsets */
+#define SRSH_ASPM_OFFSET		4	/* word 4 */
+#define SRSH_ASPM_ENB			0x18	/* bit 3, 4 */
+#define SRSH_PCIE_MISC_CONFIG		5	/* word 5 */
+#define SRSH_L23READY_EXIT_NOPERST	0x8000	/* bit 15 */
+#define SRSH_CLKREQ_OFFSET_REV5		20	/* word 20 for srom rev <= 5 */
+#define SRSH_CLKREQ_OFFSET_REV8		52	/* word 52 for srom rev 8 */
+#define SRSH_CLKREQ_ENB			0x0800	/* bit 11 */
+#define SRSH_BD_OFFSET                  6	/* word 6 */
+#define SRSH_AUTOINIT_OFFSET            18	/* auto initialization enable */
+
+/* Linkcontrol reg offset in PCIE Cap */
+#define PCIE_CAP_LINKCTRL_OFFSET	16	/* linkctrl offset in pcie cap */
+#define PCIE_CAP_LCREG_ASPML0s		0x01	/* ASPM L0s in linkctrl */
+#define PCIE_CAP_LCREG_ASPML1		0x02	/* ASPM L1 in linkctrl */
+#define PCIE_ASPM_ENAB			0x03	/* ASPM L0s & L1 in linkctrl */
+#define PCIE_CLKREQ_ENAB		0x100	/* CLKREQ Enab in linkctrl */
+
+/* Status reg PCIE_PLP_STATUSREG */
+#define PCIE_PLP_POLARITYINV_STAT	0x10
+#endif				/* _PCIE_CORE_H */
diff --git a/include/asm-mips/bcmsi/proto/802.1d.h b/include/asm-mips/bcmsi/proto/802.1d.h
new file mode 100644
index 0000000..19b28cd
--- /dev/null
+++ b/include/asm-mips/bcmsi/proto/802.1d.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * $Copyright Open Broadcom Corporation$
+ *
+ * Fundamental types and constants relating to 802.1D
+ *
+ *  
+ */
+
+#ifndef _802_1_D_
+#define _802_1_D_
+
+/* 802.1D priority defines */
+#define	PRIO_8021D_NONE		2	/* None = - */
+#define	PRIO_8021D_BK		1	/* BK - Background */
+#define	PRIO_8021D_BE		0	/* BE - Best-effort */
+#define	PRIO_8021D_EE		3	/* EE - Excellent-effort */
+#define	PRIO_8021D_CL		4	/* CL - Controlled Load */
+#define	PRIO_8021D_VI		5	/* Vi - Video */
+#define	PRIO_8021D_VO		6	/* Vo - Voice */
+#define	PRIO_8021D_NC		7	/* NC - Network Control */
+#define	MAXPRIO			7	/* 0-7 */
+#define NUMPRIO			(MAXPRIO + 1)
+
+#define ALLPRIO		-1	/* All prioirty */
+
+/* Converts prio to precedence since the numerical value of
+ * PRIO_8021D_BE and PRIO_8021D_NONE are swapped.
+ */
+#define PRIO2PREC(prio) \
+	(((prio) == PRIO_8021D_NONE || (prio) == PRIO_8021D_BE) ? ((prio^2)) : (prio))
+
+#endif /* _802_1_D__ */
diff --git a/include/asm-mips/bcmsi/proto/bcmip.h b/include/asm-mips/bcmsi/proto/bcmip.h
new file mode 100644
index 0000000..c77b1bb
--- /dev/null
+++ b/include/asm-mips/bcmsi/proto/bcmip.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * $Copyright Open Broadcom Corporation$
+ *
+ * Fundamental constants relating to IP Protocol
+ *
+ *  
+ */
+
+#ifndef _bcmip_h_
+#define _bcmip_h_
+
+/* enable structure packing */
+#if defined (__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#pragma pack(1)
+#define	PACKED
+#endif
+
+
+/* IPV4 and IPV6 common */
+#define IP_VER_OFFSET		0x0	/* offset to version field */
+#define IP_VER_MASK		0xf0	/* version mask */
+#define IP_VER_SHIFT		4	/* version shift */
+#define IP_VER_4		4	/* version number for IPV4 */
+#define IP_VER_6		6	/* version number for IPV6 */
+
+#define IP_VER(ip_body) \
+	((((uint8 *)(ip_body))[IP_VER_OFFSET] & IP_VER_MASK) >> IP_VER_SHIFT)
+
+#define IP_PROT_ICMP		0x1	/* ICMP protocol */
+#define IP_PROT_TCP		0x6	/* TCP protocol */
+#define IP_PROT_UDP		0x11	/* UDP protocol type */
+
+/* IPV4 field offsets */
+#define IPV4_VER_HL_OFFSET	0	/* version and ihl byte offset */
+#define IPV4_TOS_OFFSET		1	/* type of service offset */
+#define IPV4_PKTLEN_OFFSET	2	/* packet length offset */
+#define IPV4_PKTFLAG_OFFSET	6	/* more-frag,dont-frag flag offset */
+#define IPV4_PROT_OFFSET	9	/* protocol type offset */
+#define IPV4_CHKSUM_OFFSET	10	/* IP header checksum offset */
+#define IPV4_SRC_IP_OFFSET	12	/* src IP addr offset */
+#define IPV4_DEST_IP_OFFSET	16	/* dest IP addr offset */
+#define IPV4_OPTIONS_OFFSET	20	/* IP options offset */
+
+/* IPV4 field decodes */
+#define IPV4_VER_MASK		0xf0	/* IPV4 version mask */
+#define IPV4_VER_SHIFT		4	/* IPV4 version shift */
+
+#define IPV4_HLEN_MASK		0x0f	/* IPV4 header length mask */
+#define IPV4_HLEN(ipv4_body)	(4 * (((uint8 *)(ipv4_body))[IPV4_VER_HL_OFFSET] & IPV4_HLEN_MASK))
+
+#define IPV4_ADDR_LEN		4	/* IPV4 address length */
+
+#define IPV4_ADDR_NULL(a)	((((uint8 *)(a))[0] | ((uint8 *)(a))[1] | \
+				  ((uint8 *)(a))[2] | ((uint8 *)(a))[3]) == 0)
+
+#define IPV4_ADDR_BCAST(a)	((((uint8 *)(a))[0] & ((uint8 *)(a))[1] & \
+				  ((uint8 *)(a))[2] & ((uint8 *)(a))[3]) == 0xff)
+
+#define	IPV4_TOS_DSCP_MASK	0xfc	/* DiffServ codepoint mask */
+#define	IPV4_TOS_DSCP_SHIFT	2	/* DiffServ codepoint shift */
+
+#define	IPV4_TOS(ipv4_body)	(((uint8 *)(ipv4_body))[IPV4_TOS_OFFSET])
+
+#define	IPV4_TOS_PREC_MASK	0xe0	/* Historical precedence mask */
+#define	IPV4_TOS_PREC_SHIFT	5	/* Historical precedence shift */
+
+#define IPV4_TOS_LOWDELAY	0x10	/* Lowest delay requested */
+#define IPV4_TOS_THROUGHPUT	0x8	/* Best throughput requested */
+#define IPV4_TOS_RELIABILITY	0x4	/* Most reliable delivery requested */
+
+#define IPV4_PROT(ipv4_body)	(((uint8 *)(ipv4_body))[IPV4_PROT_OFFSET])
+
+#define IPV4_FRAG_RESV		0x8000	/* Reserved */
+#define IPV4_FRAG_DONT		0x4000	/* Don't fragment */
+#define IPV4_FRAG_MORE		0x2000	/* More fragments */
+#define IPV4_FRAG_OFFSET_MASK	0x1fff	/* Fragment offset */
+
+#define IPV4_ADDR_STR_LEN	16	/* Max IP address length in string format */
+
+/* IPV4 packet formats */
+struct ipv4_addr {
+	uint8	addr[IPV4_ADDR_LEN];
+} PACKED;
+
+struct ipv4_hdr {
+	uint8	version_ihl;		/* Version and Internet Header Length */
+	uint8	tos;			/* Type Of Service */
+	uint16	tot_len;		/* Number of bytes in packet (max 65535) */
+	uint16	id;
+	uint16	frag;			/* 3 flag bits and fragment offset */
+	uint8	ttl;			/* Time To Live */
+	uint8	prot;			/* Protocol */
+	uint16	hdr_chksum;		/* IP header checksum */
+	uint8	src_ip[IPV4_ADDR_LEN];	/* Source IP Address */
+	uint8	dst_ip[IPV4_ADDR_LEN];	/* Destination IP Address */
+} PACKED;
+
+/* IPV6 field offsets */
+#define IPV6_PAYLOAD_LEN_OFFSET	4	/* payload length offset */
+#define IPV6_NEXT_HDR_OFFSET	6	/* next header/protocol offset */
+#define IPV6_HOP_LIMIT_OFFSET	7	/* hop limit offset */
+#define IPV6_SRC_IP_OFFSET	8	/* src IP addr offset */
+#define IPV6_DEST_IP_OFFSET	24	/* dst IP addr offset */
+
+/* IPV6 field decodes */
+#define IPV6_TRAFFIC_CLASS(ipv6_body) \
+	(((((uint8 *)(ipv6_body))[0] & 0x0f) << 4) | \
+	 ((((uint8 *)(ipv6_body))[1] & 0xf0) >> 4))
+
+#define IPV6_FLOW_LABEL(ipv6_body) \
+	(((((uint8 *)(ipv6_body))[1] & 0x0f) << 16) | \
+	 (((uint8 *)(ipv6_body))[2] << 8) | \
+	 (((uint8 *)(ipv6_body))[3]))
+
+#define IPV6_PAYLOAD_LEN(ipv6_body) \
+	((((uint8 *)(ipv6_body))[IPV6_PAYLOAD_LEN_OFFSET + 0] << 8) | \
+	 ((uint8 *)(ipv6_body))[IPV6_PAYLOAD_LEN_OFFSET + 1])
+
+#define IPV6_NEXT_HDR(ipv6_body) \
+	(((uint8 *)(ipv6_body))[IPV6_NEXT_HDR_OFFSET])
+
+#define IPV6_PROT(ipv6_body)	IPV6_NEXT_HDR(ipv6_body)
+
+#define IPV6_ADDR_LEN		16	/* IPV6 address length */
+
+/* IPV4 TOS or IPV6 Traffic Classifier or 0 */
+#define IP_TOS(ip_body) \
+	(IP_VER(ip_body) == IP_VER_4 ? IPV4_TOS(ip_body) : \
+	 IP_VER(ip_body) == IP_VER_6 ? IPV6_TRAFFIC_CLASS(ip_body) : 0)
+
+#undef PACKED
+#if !defined (__GNUC__)
+#pragma pack()
+#endif
+
+#endif	/* _bcmip_h_ */
diff --git a/include/asm-mips/bcmsi/proto/ethernet.h b/include/asm-mips/bcmsi/proto/ethernet.h
new file mode 100644
index 0000000..9bfc361
--- /dev/null
+++ b/include/asm-mips/bcmsi/proto/ethernet.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * From FreeBSD 2.2.7: Fundamental constants relating to ethernet.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _NET_ETHERNET_H_	/* use native BSD ethernet.h when available */
+#define _NET_ETHERNET_H_
+
+#ifndef _TYPEDEFS_H_
+#include "typedefs.h"
+#endif
+
+/* enable structure packing */
+#if defined (__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#pragma pack(1)
+#define	PACKED
+#endif
+
+/*
+ * The number of bytes in an ethernet (MAC) address.
+ */
+#define	ETHER_ADDR_LEN		6
+
+/*
+ * The number of bytes in the type field.
+ */
+#define	ETHER_TYPE_LEN		2
+
+/*
+ * The number of bytes in the trailing CRC field.
+ */
+#define	ETHER_CRC_LEN		4
+
+/*
+ * The length of the combined header.
+ */
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
+
+/*
+ * The minimum packet length.
+ */
+#define	ETHER_MIN_LEN		64
+
+/*
+ * The minimum packet user data length.
+ */
+#define	ETHER_MIN_DATA		46
+
+/*
+ * The maximum packet length.
+ */
+#define	ETHER_MAX_LEN		1518
+
+/*
+ * The maximum packet user data length.
+ */
+#define	ETHER_MAX_DATA		1500
+
+/* ether types */
+#define ETHER_TYPE_MIN		0x0600		/* Anything less than MIN is a length */
+#define	ETHER_TYPE_IP		0x0800		/* IP */
+#define ETHER_TYPE_ARP		0x0806		/* ARP */
+#define ETHER_TYPE_8021Q	0x8100		/* 802.1Q */
+#define	ETHER_TYPE_BRCM		0x886c		/* Broadcom Corp. */
+#define	ETHER_TYPE_802_1X	0x888e		/* 802.1x */
+#ifdef BCMWPA2
+#define	ETHER_TYPE_802_1X_PREAUTH 0x88c7	/* 802.1x preauthentication */
+#endif
+
+/* Broadcom subtype follows ethertype;  First 2 bytes are reserved; Next 2 are subtype; */
+#define	ETHER_BRCM_SUBTYPE_LEN	4	/* Broadcom 4 byte subtype */
+#define	ETHER_BRCM_CRAM		1	/* Broadcom subtype cram protocol */
+
+/* ether header */
+#define ETHER_DEST_OFFSET	(0 * ETHER_ADDR_LEN)	/* dest address offset */
+#define ETHER_SRC_OFFSET	(1 * ETHER_ADDR_LEN)	/* src address offset */
+#define ETHER_TYPE_OFFSET	(2 * ETHER_ADDR_LEN)	/* ether type offset */
+
+/*
+ * A macro to validate a length with
+ */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+
+#ifndef __INCif_etherh /* Quick and ugly hack for VxWorks */
+/*
+ * Structure of a 10Mb/s Ethernet header.
+ */
+struct	ether_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];
+	uint8	ether_shost[ETHER_ADDR_LEN];
+	uint16	ether_type;
+} PACKED;
+
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+struct	ether_addr {
+	uint8 octet[ETHER_ADDR_LEN];
+} PACKED;
+#elif VX_BSD4_3
+/*
+ * Structure of a 48-bit Ethernet address.
+ */
+struct	ether_addr {
+	uint8 octet[ETHER_ADDR_LEN];
+} PACKED;
+#endif	/* !__INCif_etherh Quick and ugly hack for VxWorks */
+
+/*
+ * Takes a pointer, set, test, clear, toggle locally admininistered
+ * address bit in the 48-bit Ethernet address.
+ */
+#define ETHER_SET_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] | 2))
+#define ETHER_IS_LOCALADDR(ea) 	(((uint8 *)(ea))[0] & 2)
+#define ETHER_CLR_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & 0xd))
+#define ETHER_TOGGLE_LOCALADDR(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] ^ 2))
+
+/* Takes a pointer, marks unicast address bit in the MAC address */
+#define ETHER_SET_UNICAST(ea)	(((uint8 *)(ea))[0] = (((uint8 *)(ea))[0] & ~1))
+
+/*
+ * Takes a pointer, returns true if a 48-bit multicast address
+ * (including broadcast, since it is all ones)
+ */
+#define ETHER_ISMULTI(ea) (((const uint8 *)(ea))[0] & 1)
+
+
+/* compare two ethernet addresses - assumes the pointers can be referenced as shorts */
+#define	ether_cmp(a, b)	(!(((short*)a)[0] == ((short*)b)[0]) | \
+			 !(((short *)a)[1] == ((short *)b)[1]) | \
+			 !(((short *)a)[2] == ((short *)b)[2]))
+
+/* copy an ethernet address - assumes the pointers can be referenced as shorts */
+#define	ether_copy(s, d) { \
+		((short *)d)[0] = ((short *)s)[0]; \
+		((short *)d)[1] = ((short *)s)[1]; \
+		((short *)d)[2] = ((short *)s)[2]; }
+
+/*
+ * Takes a pointer, returns true if a 48-bit broadcast (all ones)
+ */
+#define ETHER_ISBCAST(ea) ((((uint8 *)(ea))[0] &		\
+			    ((uint8 *)(ea))[1] &		\
+			    ((uint8 *)(ea))[2] &		\
+			    ((uint8 *)(ea))[3] &		\
+			    ((uint8 *)(ea))[4] &		\
+			    ((uint8 *)(ea))[5]) == 0xff)
+
+static const struct ether_addr ether_bcast = {{255, 255, 255, 255, 255, 255}};
+static const struct ether_addr ether_null = {{0, 0, 0, 0, 0, 0}};
+
+/*
+ * Takes a pointer, returns true if a 48-bit null address (all zeros)
+ */
+#define ETHER_ISNULLADDR(ea) ((((uint8 *)(ea))[0] |		\
+			    ((uint8 *)(ea))[1] |		\
+			    ((uint8 *)(ea))[2] |		\
+			    ((uint8 *)(ea))[3] |		\
+			    ((uint8 *)(ea))[4] |		\
+			    ((uint8 *)(ea))[5]) == 0)
+
+#undef PACKED
+#if !defined (__GNUC__)
+#pragma pack()
+#endif
+
+#endif /* _NET_ETHERNET_H_ */
diff --git a/include/asm-mips/bcmsi/proto/vlan.h b/include/asm-mips/bcmsi/proto/vlan.h
new file mode 100644
index 0000000..ca53d19
--- /dev/null
+++ b/include/asm-mips/bcmsi/proto/vlan.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * 802.1Q VLAN protocol definitions
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef _vlan_h_
+#define _vlan_h_
+
+/* enable structure packing */
+#if defined (__GNUC__)
+#define	PACKED	__attribute__((packed))
+#else
+#pragma pack(1)
+#define	PACKED
+#endif
+
+#define VLAN_VID_MASK		0xfff	/* low 12 bits are vlan id */
+#define	VLAN_CFI_SHIFT		12	/* canonical format indicator bit */
+#define VLAN_PRI_SHIFT		13	/* user priority */
+
+#define VLAN_PRI_MASK		7	/* 3 bits of priority */
+
+#define	VLAN_TAG_LEN		4
+#define	VLAN_TAG_OFFSET		(2 * ETHER_ADDR_LEN)	/* offset in Ethernet II packet only */
+
+#define VLAN_TPID		0x8100	/* VLAN ethertype/Tag Protocol ID */
+
+struct ethervlan_header {
+	uint8	ether_dhost[ETHER_ADDR_LEN];
+	uint8	ether_shost[ETHER_ADDR_LEN];
+	uint16	vlan_type;		/* 0x8100 */
+	uint16	vlan_tag;		/* priority, cfi and vid */
+	uint16	ether_type;
+};
+
+#define	ETHERVLAN_HDR_LEN	(ETHER_HDR_LEN + VLAN_TAG_LEN)
+
+#undef PACKED
+#if !defined (__GNUC__)
+#pragma pack()
+#endif
+
+#endif /* _vlan_h_ */
diff --git a/include/asm-mips/bcmsi/sbchipc.h b/include/asm-mips/bcmsi/sbchipc.h
new file mode 100644
index 0000000..f2f5fda
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbchipc.h
@@ -0,0 +1,1486 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * SiliconBackplane Chipcommon core hardware definitions.
+ *
+ * The chipcommon core provides chip identification, SB control,
+ * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
+ * gpio interface, extbus, and support for serial and parallel flashes.
+ *
+ *  
+ *
+ * $Copyright Open Broadcom Corporation$
+ */
+
+#ifndef _SBCHIPC_H
+#define _SBCHIPC_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define _PADLINE(line)  pad ## line
+#define _XSTR(line) _PADLINE(line)
+#define PAD     _XSTR(__LINE__)
+#endif				/* PAD */
+
+typedef volatile struct {
+    uint32 chipid;		/* 0x0 */
+    uint32 capabilities;
+    uint32 corecontrol;		/* corerev >= 1 */
+    uint32 PAD[5];
+
+    /* Interrupt control */
+    uint32 intstatus;		/* 0x20 */
+    uint32 intmask;
+    uint32 chipcontrol;		/* 0x28, rev >= 11 */
+    uint32 chipstatus;		/* 0x2c, rev >= 11 */
+
+    /* Jtag Master */
+    uint32 jtagcmd;		/* 0x30, rev >= 10 */
+    uint32 jtagir;
+    uint32 jtagdr;
+    uint32 jtagctrl;
+
+    /* serial flash interface registers */
+    uint32 sflashcontrol;	/* 0x40 */
+    uint32 sflashaddress;
+    uint32 sflashdata;
+    uint32 sflashpara;
+
+    /* Silicon backplane configuration broadcast control */
+    uint32 broadcastaddress;	/* 0x50 */
+    uint32 broadcastdata;
+
+    /* gpio - cleared only by power-on-reset */
+    uint32 gpiopullup;		/* 0x58, corerev >= 20 */
+    uint32 gpiopulldown;	/* 0x5c, corerev >= 20 */
+    uint32 gpioin;		/* 0x60 */
+    uint32 gpioout;
+    uint32 gpioouten;
+    uint32 gpiocontrol;
+    uint32 gpiointpolarity;
+    uint32 gpiointmask;
+
+    /* GPIO events corerev >= 11 */
+    uint32 gpioevent;
+    uint32 gpioeventintmask;
+
+    /* Watchdog timer */
+    uint32 watchdog;		/* 0x80 */
+
+    /* GPIO events corerev >= 11 */
+    uint32 gpioeventintpolarity;
+
+    /* GPIO based LED powersave registers corerev >= 16 */
+    uint32 gpiotimerval;	/* 0x88 */
+    uint32 gpiotimeroutmask;
+
+    /* clock control */
+    uint32 clockcontrol_n;	/* 0x90 */
+    uint32 clockcontrol_sb;	/* aka m0 */
+    uint32 clockcontrol_pci;	/* aka m1 */
+    uint32 clockcontrol_m2;	/* mii/uart/mipsref */
+    uint32 clockcontrol_m3;	/* cpu */
+    uint32 clkdiv;		/* corerev >= 3 */
+    uint32 PAD[2];
+
+    /* pll delay registers (corerev >= 4) */
+    uint32 pll_on_delay;	/* 0xb0 */
+    uint32 fref_sel_delay;
+    uint32 slow_clk_ctl;	/* 5 < corerev < 10 */
+    uint32 PAD[1];
+
+    /* Instaclock registers (corerev >= 10) */
+    uint32 system_clk_ctl;	/* 0xc0 */
+    uint32 clkstatestretch;
+    uint32 PAD[2];
+
+    /* Backplane address registers */
+    uint32 bpaddrlow;		/* 0xd0 */
+    uint32 bpaddrhigh;
+    uint32 bpdata;
+    uint32 PAD[1];
+    uint32 bpindaccess;
+    uint32 PAD[6];
+
+    /* In AI chips, pointer to erom */
+    uint32 eromptr;
+
+    /* ExtBus control registers (corerev >= 3) */
+    uint32 extif_cs2_config;	/* 0x100 */
+    uint32 extif_cs2_waitcount;
+    uint32 PAD[6];
+    uint32 extif_cs3_config;
+    uint32 extif_cs3_waitcount;
+    uint32 pflash_config;
+    uint32 pflash_waitcount;
+    uint32 pflash_waitcount_pf1;
+    uint32 PAD[3];
+
+#if !defined(BCMDONGLEHOST)
+    /* Enhanced Coexistance Interface (ECI) registers (corerev >= 21) */
+    uint32 eci_output;		/* 0x140 */
+    uint32 eci_control;
+    uint32 eci_inputlo;
+    uint32 eci_inputmi;
+    uint32 eci_inputhi;
+    uint32 eci_inputintpolaritylo;
+    uint32 eci_inputintpolaritymi;
+    uint32 eci_inputintpolarityhi;
+    uint32 eci_intmasklo;
+    uint32 eci_intmaskmi;
+    uint32 eci_intmaskhi;
+    uint32 eci_eventlo;
+    uint32 eci_eventmi;
+    uint32 eci_eventhi;
+    uint32 eci_eventmasklo;
+    uint32 eci_eventmaskmi;
+    uint32 eci_eventmaskhi;
+#else
+    uint32 PAD[17];
+#endif				/* !defined(BCMDONGLEHOST) */
+
+
+    /* Flash struct configuration registers */
+    uint32 PAD[2];
+    uint32 flashstrconfig;	/* 0x18c */
+    uint32 PAD[4];
+
+    /* NAND flash registers */
+    uint32 nflashctrl;		/* 0x1a0 */
+    uint32 nflashconf;
+    uint32 nflashcoladdr;
+    uint32 nflashrowaddr;
+    uint32 nflashdata;
+    uint32 nflashwaitcnt0;
+    uint32 PAD[2];
+
+    /*  Multi-Purpose Timer registers */
+    uint32 MPcnt0;		/* 0x1c0 */
+    uint32 MPcnt1;
+    uint32 MPcnt2;
+    uint32 MPcnt3;
+    uint32 MPcnt_status;
+    uint32 PAD[3];
+
+    /* Clock control and hardware workarounds (corerev >= 20) */
+    uint32 clk_ctl_st;		/* 0x1e0 */
+    uint32 PAD[7];
+
+    /* I2C registers (for keystone only) */
+    uint8 i2c_slaveaddr;	/* 0x200, 1st I2C */
+    uint8 i2c_data;
+    uint8 i2c_control;
+    uint8 i2c_sts_ccr;		/* Status Reg(read), Clock Control Reg(write only) */
+    uint8 i2c_extaddr;		/* externed slave address (10-bit addressing mode) */
+    uint8 PAD[2];
+    uint8 i2c_swreset;		/* software reset */
+    uint8 PAD[8];
+    uint8 i2c1_slaveaddr;	/* 0x210, 2nd I2C */
+    uint8 i2c1_data;
+    uint8 i2c1_control;
+    uint8 i2c1_sts_ccr;
+    uint8 i2c1_extaddr;
+    uint8 PAD[2];
+    uint8 i2c1_swreset;
+    uint8 PAD[104];
+
+    /* SPI registers (for keystone only) */
+    uint32 spi_mode_ctrl;	/* 0x280, SPI Mode Control registers */
+    uint32 spi_config;		/* 0x284, SPI Configuration registers */
+    uint32 spi_fifo_io;		/* 0x288, SPI FIFO IO registers */
+    uint32 spi_status;		/* 0x28c, SPI Status registers */
+    uint32 PAD[24];
+
+    /* Serial Interface registers */
+    uint32 SERIAL_IO_INTMASK;	/* 0x2f0 */
+    uint32 SERIAL_IO_SEL;
+    uint32 PAD[2];
+
+    /* uarts */
+    uint8 uart0data;		/* 0x300 */
+    uint8 uart0imr;
+    uint8 uart0fcr;
+    uint8 uart0lcr;
+    uint8 uart0mcr;
+    uint8 uart0lsr;
+    uint8 uart0msr;
+    uint8 uart0scratch;
+    uint8 PAD[248];		/* corerev >= 1 */
+
+    uint8 uart1data;		/* 0x400 */
+    uint8 uart1imr;
+    uint8 uart1fcr;
+    uint8 uart1lcr;
+    uint8 uart1mcr;
+    uint8 uart1lsr;
+    uint8 uart1msr;
+    uint8 uart1scratch;
+    uint32 PAD[126];
+
+    /* PMU registers (corerev >= 20) */
+    uint32 pmucontrol;		/* 0x600 */
+    uint32 pmucapabilities;
+    uint32 pmustatus;
+    uint32 res_state;
+    uint32 res_pending;
+    uint32 pmutimer;
+    uint32 min_res_mask;
+    uint32 max_res_mask;
+    uint32 res_table_sel;
+    uint32 res_dep_mask;
+    uint32 res_updn_timer;
+    uint32 PAD[2];
+    uint32 pmuwatchdog;
+    uint32 PAD[6];
+    uint32 chipcontrol_addr;	/* 0x650 */
+    uint32 chipcontrol_data;	/* 0x654 */
+    uint32 regcontrol_addr;
+    uint32 regcontrol_data;
+    uint32 pllcontrol_addr;
+    uint32 pllcontrol_data;
+} chipcregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#define CC_CHIPID       0
+#define CC_CAPABILITIES     4
+#define CC_OTPST        0x10
+#define CC_CHIPST       0x2c
+#define CC_JTAGCMD      0x30
+#define CC_JTAGIR       0x34
+#define CC_JTAGDR       0x38
+#define CC_JTAGCTRL     0x3c
+#define CC_WATCHDOG     0x80
+#define CC_CLKC_N       0x90
+#define CC_CLKC_M0      0x94
+#define CC_CLKC_M1      0x98
+#define CC_CLKC_M2      0x9c
+#define CC_CLKC_M3      0xa0
+#define CC_CLKDIV       0xa4
+#define CC_SYS_CLK_CTL      0xc0
+#define CC_CLK_CTL_ST       SI_CLK_CTL_ST
+#define CC_EROMPTR      0xfc
+#define PMU_CTL         0x600
+#define PMU_CAP         0x604
+#define PMU_ST          0x608
+#define PMU_RES_STATE       0x60c
+#define PMU_TIMER       0x614
+#define PMU_MIN_RES_MASK    0x618
+#define PMU_MAX_RES_MASK    0x61c
+#define PMU_REG_CONTROL_ADDR    0x658
+#define PMU_REG_CONTROL_DATA    0x65C
+#define PMU_PLL_CONTROL_ADDR    0x660
+#define PMU_PLL_CONTROL_DATA    0x664
+#define CC_OTP          0x800	/* OTP address space */
+
+#define CC_I2C0_ADDR_BASE       0x200	/* 1st I2C address space */
+#define CC_I2C1_ADDR_BASE       0x210	/* 2nd I2C address space */
+
+/* chipid */
+#define CID_ID_MASK     0x0000ffff	/* Chip Id mask */
+#define CID_REV_MASK        0x000f0000	/* Chip Revision mask */
+#define CID_REV_SHIFT       16	/* Chip Revision shift */
+#define CID_PKG_MASK        0x00f00000	/* Package Option mask */
+#define CID_PKG_SHIFT       20	/* Package Option shift */
+#define CID_CC_MASK     0x0f000000	/* CoreCount (corerev >= 4) */
+#define CID_CC_SHIFT        24
+#define CID_TYPE_MASK       0xf0000000	/* Chip Type */
+#define CID_TYPE_SHIFT      28
+
+/* capabilities */
+#define CC_CAP_UARTS_MASK   0x00000003	/* Number of uarts */
+#define CC_CAP_MIPSEB       0x00000004	/* MIPS is in big-endian mode */
+#define CC_CAP_UCLKSEL      0x00000018	/* UARTs clock select */
+#define CC_CAP_UINTCLK      0x00000008	/* UARTs are driven by internal divided clock */
+#define CC_CAP_UARTGPIO     0x00000020	/* UARTs own Gpio's 15:12 */
+#define CC_CAP_EXTBUS_MASK  0x000000c0	/* External bus mask */
+#define CC_CAP_EXTBUS_NONE  0x00000000	/* No ExtBus present */
+#define CC_CAP_EXTBUS_FULL  0x00000040	/* ExtBus: PCMCIA, IDE & Prog */
+#define CC_CAP_EXTBUS_PROG  0x00000080	/* ExtBus: ProgIf only */
+#define CC_CAP_FLASH_MASK   0x00000700	/* Type of flash */
+#define CC_CAP_PLL_MASK     0x00038000	/* Type of PLL */
+#define CC_CAP_PWR_CTL      0x00040000	/* Power control */
+#define CC_CAP_OTPSIZE      0x00380000	/* OTP Size (0 = none) */
+#define CC_CAP_OTPSIZE_SHIFT    19	/* OTP Size shift */
+#define CC_CAP_OTPSIZE_BASE 5	/* OTP Size base */
+#define CC_CAP_JTAGP        0x00400000	/* JTAG Master Present */
+#define CC_CAP_ROM      0x00800000	/* Internal boot rom active */
+#define CC_CAP_BKPLN64      0x08000000	/* 64-bit backplane */
+#define CC_CAP_PMU      0x10000000	/* PMU Present, rev >= 20 */
+#define CC_CAP_ECI      0x20000000	/* ECI Present, rev >= 21 */
+
+/* PLL type */
+#define PLL_NONE        0x00000000
+#define PLL_TYPE1       0x00010000	/* 48Mhz base, 3 dividers */
+#define PLL_TYPE2       0x00020000	/* 48Mhz, 4 dividers */
+#define PLL_TYPE3       0x00030000	/* 25Mhz, 2 dividers */
+#define PLL_TYPE4       0x00008000	/* 48Mhz, 4 dividers */
+#define PLL_TYPE5       0x00018000	/* 25Mhz, 4 dividers */
+#define PLL_TYPE6       0x00028000	/* 100/200 or 120/240 only */
+#define PLL_TYPE7       0x00038000	/* 25Mhz, 4 dividers */
+
+/* ILP clock */
+#define ILP_CLOCK       32000
+
+/* ALP clock on pre-PMU chips */
+#define ALP_CLOCK       25000000
+
+/* HT clock */
+#define HT_CLOCK        80000000
+
+/* corecontrol */
+#define CC_UARTCLKO     0x00000001	/* Drive UART with internal clock */
+#define CC_SE           0x00000002	/* sync clk out enable (corerev >= 3) */
+#define CC_UARTCLKEN        0x00000008	/* enable UART Clock (corerev > = 21 */
+
+/* chipcontrol */
+#define CHIPCTRL_4321A0_DEFAULT 0x3a4	/* PR37037 & PR37877, dflt value for 4321a0 */
+#define CHIPCTRL_4321A1_DEFAULT 0x0a4	/* PR37037, dflt value for 4321a1 */
+#define CHIPCTRL_4321_PLL_DOWN  0x800000	/* serdes PLL down override */
+
+/* chipstatus */
+#define CHIPSTATUS_LOWCOST_BONDING      0x00000001	/* Low cost bonding */
+#define CHIPSTATUS_SFLASH_BOOT_EN       0x00000002	/* Serial flash boot */
+#define CHIPSTATUS_BOOT_FLASH_TYPE      0x00000004	/* Boot flash type */
+#define CHIPSTATUS_MIPS_ENDIAN_BIG      0x00000008	/* big endian */
+#define CHIPSTATUS_PCIE_PORT1_DISABLE   0x00000020	/* PCIE 1 disabled */
+#define CHIPSTATUS_PCIE_PORT0_ENDPOINT  0x00002000	/* PCIE 0 is endpoint */
+#define CHIPSTATUS_FREQ_ADJ_CTL_MASK    0x1C000000	/* CPU frequency adjusting */
+#define CHIPSTATUS_FREQ_ADJ_CTL_SHIFT   26	/* CPU frequency adjusting */
+
+/* Fields in the otpstatus register in rev >= 21 */
+#define OTPS_OL_MASK        0x000000ff
+#define OTPS_OL_MFG     0x00000001	/* manuf row is locked */
+#define OTPS_OL_OR1     0x00000002	/* otp redundancy row 1 is locked */
+#define OTPS_OL_OR2     0x00000004	/* otp redundancy row 2 is locked */
+#define OTPS_OL_GU      0x00000008	/* general use region is locked */
+#define OTPS_GUP_MASK       0x00000f00
+#define OTPS_GUP_SHIFT      8
+#define OTPS_GUP_HW     0x00000100	/* h/w subregion is programmed */
+#define OTPS_GUP_SW     0x00000200	/* s/w subregion is programmed */
+#define OTPS_GUP_CI     0x00000400	/* chipid/pkgopt subregion is programmed */
+#define OTPS_GUP_FUSE       0x00000800	/* fuse subregion is programmed */
+#define OTPS_READY      0x00001000
+#define OTPS_RV(x)      (1 << (16 + (x)))	/* redundancy entry valid */
+#define OTPS_RV_MASK        0x0fff0000
+
+/* Fields in the otpcontrol register in rev >= 21 */
+#define OTPC_PROGSEL        0x00000001
+#define OTPC_PCOUNT_MASK    0x0000000e
+#define OTPC_PCOUNT_SHIFT   1
+#define OTPC_VSEL_MASK      0x000000f0
+#define OTPC_VSEL_SHIFT     4
+#define OTPC_TMM_MASK       0x00000700
+#define OTPC_TMM_SHIFT      8
+#define OTPC_ODM        0x00000800
+#define OTPC_PROGEN     0x80000000
+
+/* Fields in otpprog in rev >= 21 */
+#define OTPP_COL_MASK       0x000000ff
+#define OTPP_COL_SHIFT      0
+#define OTPP_ROW_MASK       0x0000ff00
+#define OTPP_ROW_SHIFT      8
+#define OTPP_OC_MASK        0x0f000000
+#define OTPP_OC_SHIFT       24
+#define OTPP_READERR        0x10000000
+#define OTPP_VALUE_MASK     0x20000000
+#define OTPP_VALUE_SHIFT    29
+#define OTPP_START_BUSY     0x80000000
+
+/* Opcodes for OTPP_OC field */
+#define OTPPOC_READ     0
+#define OTPPOC_BIT_PROG     1
+#define OTPPOC_VERIFY       3
+#define OTPPOC_INIT     4
+#define OTPPOC_SET      5
+#define OTPPOC_RESET        6
+#define OTPPOC_OCST     7
+#define OTPPOC_ROW_LOCK     8
+#define OTPPOC_PRESCN_TEST  9
+
+/* jtagcmd */
+#define JCMD_START      0x80000000
+#define JCMD_BUSY       0x80000000
+#define JCMD_STATE_MASK     0x60000000
+#define JCMD_STATE_TLR      0x00000000	/* Test-logic-reset */
+#define JCMD_STATE_PIR      0x20000000	/* Pause IR */
+#define JCMD_STATE_PDR      0x40000000	/* Pause DR */
+#define JCMD_STATE_RTI      0x60000000	/* Run-test-idle */
+#define JCMD0_ACC_MASK      0x0000f000
+#define JCMD0_ACC_IRDR      0x00000000
+#define JCMD0_ACC_DR        0x00001000
+#define JCMD0_ACC_IR        0x00002000
+#define JCMD0_ACC_RESET     0x00003000
+#define JCMD0_ACC_IRPDR     0x00004000
+#define JCMD0_ACC_PDR       0x00005000
+#define JCMD0_IRW_MASK      0x00000f00
+#define JCMD_ACC_MASK       0x000f0000	/* Changes for corerev 11 */
+#define JCMD_ACC_IRDR       0x00000000
+#define JCMD_ACC_DR     0x00010000
+#define JCMD_ACC_IR     0x00020000
+#define JCMD_ACC_RESET      0x00030000
+#define JCMD_ACC_IRPDR      0x00040000
+#define JCMD_ACC_PDR        0x00050000
+#define JCMD_ACC_PIR        0x00060000
+#define JCMD_ACC_IRDR_I     0x00070000	/* rev 28: return to run-test-idle */
+#define JCMD_ACC_DR_I       0x00080000	/* rev 28: return to run-test-idle */
+#define JCMD_IRW_MASK       0x00001f00
+#define JCMD_IRW_SHIFT      8
+#define JCMD_DRW_MASK       0x0000003f
+
+/* jtagctrl */
+#define JCTRL_FORCE_CLK     4	/* Force clock */
+#define JCTRL_EXT_EN        2	/* Enable external targets */
+#define JCTRL_EN        1	/* Enable Jtag master */
+
+/* Fields in clkdiv */
+#define CLKD_SFLASH     0x0f000000
+#define CLKD_SFLASH_SHIFT   24
+#define CLKD_OTP        0x000f0000
+#define CLKD_OTP_SHIFT      16
+#define CLKD_JTAG       0x00000f00
+#define CLKD_JTAG_SHIFT     8
+#define CLKD_UART       0x000000ff
+
+/* intstatus/intmask */
+#define CI_GPIO         0x00000001	/* gpio intr */
+#define CI_EI           0x00000002	/* extif intr (corerev >= 3) */
+#define CI_TEMP         0x00000004	/* temp. ctrl intr (corerev >= 15) */
+#define CI_SIRQ         0x00000008	/* serial IRQ intr (corerev >= 15) */
+#define CI_ECI          0x00000010	/* eci intr (corerev >= 21) */
+#define CI_PMU          0x00000020	/* pmu intr (corerev >= 21) */
+#define CI_UART         0x00000040	/* uart intr (corerev >= 21) */
+#define	CI_MP_CNT_0		0x00000100	/* multipurpose timer0 */
+#define	CI_MP_CNT_1		0x00000200	/* multipurpose timer1 */
+#define	CI_MP_CNT_2		0x00000400	/* multipurpose timer2 */
+#define	CI_MP_CNT_3		0x00000800	/* multipurpose timer3 */
+#define	CI_MP_CNT_SIFT		8
+#define CI_WDRESET      0x80000000	/* watchdog reset occurred */
+
+/* slow_clk_ctl */
+#define SCC_SS_MASK     0x00000007	/* slow clock source mask */
+#define SCC_SS_LPO      0x00000000	/* source of slow clock is LPO */
+#define SCC_SS_XTAL     0x00000001	/* source of slow clock is crystal */
+#define SCC_SS_PCI      0x00000002	/* source of slow clock is PCI */
+#define SCC_LF          0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
+#define SCC_LP          0x00000400	/* LPOPowerDown, 1: LPO is disabled,
+					 * 0: LPO is enabled
+					 */
+#define SCC_FS          0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock,
+					 * 0: power logic control
+					 */
+#define SCC_IP          0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors
+					 * PLL clock disable requests from core
+					 */
+#define SCC_XC          0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't
+					 * disable crystal when appropriate
+					 */
+#define SCC_XP          0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
+#define SCC_CD_MASK     0xffff0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
+#define SCC_CD_SHIFT        16
+
+/* system_clk_ctl */
+#define SYCC_IE         0x00000001	/* ILPen: Enable Idle Low Power */
+#define SYCC_AE         0x00000002	/* ALPen: Enable Active Low Power */
+#define SYCC_FP         0x00000004	/* ForcePLLOn */
+#define SYCC_AR         0x00000008	/* Force ALP (or HT if ALPen is not set */
+#define SYCC_HR         0x00000010	/* Force HT */
+#define SYCC_CD_MASK        0xffff0000	/* ClkDiv  (ILP = 1/(4 * (divisor + 1)) */
+#define SYCC_CD_SHIFT       16
+
+/* pcmcia/prog/pflash_config */
+#define CF_EN           0x00000001	/* enable */
+#define CF_EM_MASK      0x0000000e	/* mode */
+#define CF_EM_SHIFT     1
+#define CF_EM_FLASH     0	/* flash/asynchronous mode */
+#define CF_EM_SYNC      2	/* synchronous mode */
+#define CF_EM_PCMCIA        4	/* pcmcia mode */
+#define CF_DS           0x00000010	/* destsize:  0=8bit, 1=16bit */
+#define CF_BS           0x00000020	/* byteswap */
+#define CF_CD_MASK      0x000000c0	/* clock divider */
+#define CF_CD_SHIFT     6
+#define CF_CD_DIV2      0x00000000	/* backplane/2 */
+#define CF_CD_DIV3      0x00000040	/* backplane/3 */
+#define CF_CD_DIV4      0x00000080	/* backplane/4 */
+#define CF_CE           0x00000100	/* clock enable */
+#define CF_SB           0x00000200	/* size/bytestrobe (synch only) */
+
+/* pcmcia_memwait */
+#define PM_W0_MASK      0x0000003f	/* waitcount0 */
+#define PM_W1_MASK      0x00001f00	/* waitcount1 */
+#define PM_W1_SHIFT     8
+#define PM_W2_MASK      0x001f0000	/* waitcount2 */
+#define PM_W2_SHIFT     16
+#define PM_W3_MASK      0x1f000000	/* waitcount3 */
+#define PM_W3_SHIFT     24
+
+/* pcmcia_attrwait */
+#define PA_W0_MASK      0x0000003f	/* waitcount0 */
+#define PA_W1_MASK      0x00001f00	/* waitcount1 */
+#define PA_W1_SHIFT     8
+#define PA_W2_MASK      0x001f0000	/* waitcount2 */
+#define PA_W2_SHIFT     16
+#define PA_W3_MASK      0x1f000000	/* waitcount3 */
+#define PA_W3_SHIFT     24
+
+/* pcmcia_iowait */
+#define PI_W0_MASK      0x0000003f	/* waitcount0 */
+#define PI_W1_MASK      0x00001f00	/* waitcount1 */
+#define PI_W1_SHIFT     8
+#define PI_W2_MASK      0x001f0000	/* waitcount2 */
+#define PI_W2_SHIFT     16
+#define PI_W3_MASK      0x1f000000	/* waitcount3 */
+#define PI_W3_SHIFT     24
+
+/* prog_waitcount */
+#define PW_W0_MASK      0x0000001f	/* waitcount0 */
+#define PW_W1_MASK      0x00001f00	/* waitcount1 */
+#define PW_W1_SHIFT     8
+#define PW_W2_MASK      0x001f0000	/* waitcount2 */
+#define PW_W2_SHIFT     16
+#define PW_W3_MASK      0x1f000000	/* waitcount3 */
+#define PW_W3_SHIFT     24
+
+#define PW_W0               0x0000000c
+#define PW_W1               0x00000a00
+#define PW_W2               0x00020000
+#define PW_W3               0x01000000
+
+/* pflash_waitcount */
+#define FW_W0_MASK      0x0000003f	/* waitcount0 */
+#define FW_W1_MASK      0x00001f00	/* waitcount1 */
+#define FW_W1_SHIFT     8
+#define FW_W2_MASK      0x001f0000	/* waitcount2 */
+#define FW_W2_SHIFT     16
+#define FW_W3_MASK      0x1f000000	/* waitcount3 */
+#define FW_W3_SHIFT     24
+
+/* flashstrconfig */
+#define FLASH_STRCF_MASK        0x000000ff	/* flashstrconfig */
+#define FLASH_STRCF_SF1     0x00000001	/* 2nd serial flash present */
+#define FLASH_STRCF_PF1     0x00000002	/* 2nd parallel flash present */
+#define FLASH_STRCF_SF1_TYPE        0x00000004	/* 2nd serial flash type : 0 : ST, 1 : Atmel */
+#define FLASH_STRCF_NF1     0x00000008	/* 2nd NAND flash present */
+#define FLASH_STRCF_1ST_MADDR_SEG_MASK      0x000000f0	/* Valid value mask */
+#define FLASH_STRCF_1ST_MADDR_SEG_4MB       0x00000010	/* 4MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_8MB       0x00000020	/* 8MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_16MB      0x00000030	/* 16MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_32MB      0x00000040	/* 32MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_64MB      0x00000050	/* 64MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_128MB     0x00000060	/* 128MB */
+#define FLASH_STRCF_1ST_MADDR_SEG_256MB     0x00000070	/* 256MB */
+
+/* watchdog */
+#define WATCHDOG_CLOCK      48000000	/* Hz */
+#define WATCHDOG_CLOCK_5354     32000	/* Hz */
+
+/* Fields in pmucontrol */
+#define PCTL_ILP_DIV_MASK   0xffff0000
+#define PCTL_ILP_DIV_SHIFT  16
+#define PCTL_PLL_PLLCTL_UPD 0x00000400	/* rev 2 */
+#define PCTL_NOILP_ON_WAIT  0x00000200	/* rev 1 */
+#define PCTL_HT_REQ_EN      0x00000100
+#define PCTL_ALP_REQ_EN     0x00000080
+#define PCTL_XTALFREQ_MASK  0x0000007c
+#define PCTL_XTALFREQ_SHIFT 2
+#define PCTL_ILP_DIV_EN     0x00000002
+#define PCTL_LPO_SEL        0x00000001
+
+/* gpiotimerval */
+#define GPIO_ONTIME_SHIFT   16
+
+/* clockcontrol_n */
+/* XXX: Some pll types use less than the number of bits in some of these (n or m) masks */
+#define CN_N1_MASK      0x3f	/* n1 control */
+#define CN_N2_MASK      0x3f00	/* n2 control */
+#define CN_N2_SHIFT     8
+#define CN_PLLC_MASK        0xf0000	/* pll control */
+#define CN_PLLC_SHIFT       16
+
+/* clockcontrol_sb/pci/uart */
+#define CC_M1_MASK      0x3f	/* m1 control */
+#define CC_M2_MASK      0x3f00	/* m2 control */
+#define CC_M2_SHIFT     8
+#define CC_M3_MASK      0x3f0000	/* m3 control */
+#define CC_M3_SHIFT     16
+#define CC_MC_MASK      0x1f000000	/* mux control */
+#define CC_MC_SHIFT     24
+
+/* N3M Clock control magic field values */
+#define CC_F6_2         0x02	/* A factor of 2 in */
+#define CC_F6_3         0x03	/* 6-bit fields like */
+#define CC_F6_4         0x05	/* N1, M1 or M3 */
+#define CC_F6_5         0x09
+#define CC_F6_6         0x11
+#define CC_F6_7         0x21
+
+#define CC_F5_BIAS      5	/* 5-bit fields get this added */
+
+#define CC_MC_BYPASS        0x08
+#define CC_MC_M1        0x04
+#define CC_MC_M1M2      0x02
+#define CC_MC_M1M2M3        0x01
+#define CC_MC_M1M3      0x11
+
+/* Type 2 Clock control magic field values */
+#define CC_T2_BIAS      2	/* n1, n2, m1 & m3 bias */
+#define CC_T2M2_BIAS        3	/* m2 bias */
+
+#define CC_T2MC_M1BYP       1
+#define CC_T2MC_M2BYP       2
+#define CC_T2MC_M3BYP       4
+
+/* Type 6 Clock control magic field values */
+#define CC_T6_MMASK     1	/* bits of interest in m */
+#define CC_T6_M0        120000000	/* sb clock for m = 0 */
+#define CC_T6_M1        100000000	/* sb clock for m = 1 */
+#define SB2MIPS_T6(sb)      (2 * (sb))
+
+/* Common clock base */
+#define CC_CLOCK_BASE1      24000000	/* Half the clock freq */
+#define CC_CLOCK_BASE2      12500000	/* Alternate crystal on some PLL's */
+
+/* Clock control values for 200Mhz in 5350 */
+#define CLKC_5350_N     0x0311
+#define CLKC_5350_M     0x04020009
+
+/* Flash types in the chipcommon capabilities register */
+#define FLASH_NONE      0x000	/* No flash */
+#define SFLASH_ST       0x100	/* ST serial flash */
+#define SFLASH_AT       0x200	/* Atmel serial flash */
+#define PFLASH          0x700	/* Parallel flash */
+
+/* Bits in the ExtBus config registers */
+#define CC_CFG_EN       0x0001	/* Enable */
+#define CC_CFG_EM_MASK      0x000e	/* Extif Mode */
+#define CC_CFG_EM_ASYNC     0x0000	/*   Async/Parallel flash */
+#define CC_CFG_EM_SYNC      0x0002	/*   Synchronous */
+#define CC_CFG_EM_PCMCIA    0x0004	/*   PCMCIA */
+#define CC_CFG_EM_IDE       0x0006	/*   IDE */
+#define CC_CFG_DS       0x0010	/* Data size, 0=8bit, 1=16bit */
+#define CC_CFG_CD_MASK      0x00e0	/* Sync: Clock divisor, rev >= 20 */
+#define CC_CFG_CE       0x0100	/* Sync: Clock enable, rev >= 20 */
+#define CC_CFG_SB       0x0200	/* Sync: Size/Bytestrobe, rev >= 20 */
+#define CC_CFG_IS       0x0400	/* Extif Sync Clk Select, rev >= 20 */
+
+/* ExtBus address space */
+#define CC_EB_BASE      0x1a000000	/* Chipc ExtBus base address */
+#define CC_EB_PCMCIA_MEM    0x1a000000	/* PCMCIA 0 memory base address */
+#define CC_EB_PCMCIA_IO     0x1a200000	/* PCMCIA 0 I/O base address */
+#define CC_EB_PCMCIA_CFG    0x1a400000	/* PCMCIA 0 config base address */
+#define CC_EB_IDE       0x1a800000	/* IDE memory base */
+#define CC_EB_PCMCIA1_MEM   0x1a800000	/* PCMCIA 1 memory base address */
+#define CC_EB_PCMCIA1_IO    0x1aa00000	/* PCMCIA 1 I/O base address */
+#define CC_EB_PCMCIA1_CFG   0x1ac00000	/* PCMCIA 1 config base address */
+#define CC_EB_PROGIF        0x1b000000	/* ProgIF Async/Sync base address */
+
+
+/* Start/busy bit in sflashcontrol */
+#define SFLASH_OPCODE       0x000000ff
+#define SFLASH_ACTION       0x00000700
+#define SFLASH_CS_ACTIVE    0x00001000	/* Chip Select Active, rev >= 20 */
+#define SFLASH_START        0x80000000
+#define SFLASH_BUSY     SFLASH_START
+
+/* sflashcontrol action codes */
+#define SFLASH_ACT_OPONLY   0x0000	/* Issue opcode only */
+#define SFLASH_ACT_OP1D     0x0100	/* opcode + 1 data byte */
+#define SFLASH_ACT_OP3A     0x0200	/* opcode + 3 address bytes */
+#define SFLASH_ACT_OP3A1D   0x0300	/* opcode + 3 addres & 1 data bytes */
+#define SFLASH_ACT_OP3A4D   0x0400	/* opcode + 3 addres & 4 data bytes */
+#define SFLASH_ACT_OP3A4X4D 0x0500	/* opcode + 3 addres, 4 don't care & 4 data bytes */
+#define SFLASH_ACT_OP3A1X4D 0x0700	/* opcode + 3 addres, 1 don't care & 4 data bytes */
+
+/* sflashcontrol action+opcodes for ST flashes */
+#define SFLASH_ST_WREN      0x0006	/* Write Enable */
+#define SFLASH_ST_WRDIS     0x0004	/* Write Disable */
+#define SFLASH_ST_RDSR      0x0105	/* Read Status Register */
+#define SFLASH_ST_WRSR      0x0101	/* Write Status Register */
+#define SFLASH_ST_READ      0x0303	/* Read Data Bytes */
+#define SFLASH_ST_PP        0x0302	/* Page Program */
+#define SFLASH_ST_SE        0x02d8	/* Sector Erase */
+#define SFLASH_ST_BE        0x00c7	/* Bulk Erase */
+#define SFLASH_ST_DP        0x00b9	/* Deep Power-down */
+#define SFLASH_ST_RES       0x03ab	/* Read Electronic Signature */
+#define SFLASH_ST_CSA       0x1000	/* Keep chip select asserted */
+
+/* Status register bits for ST flashes */
+#define SFLASH_ST_WIP       0x01	/* Write In Progress */
+#define SFLASH_ST_WEL       0x02	/* Write Enable Latch */
+#define SFLASH_ST_BP_MASK   0x1c	/* Block Protect */
+#define SFLASH_ST_BP_SHIFT  2
+#define SFLASH_ST_SRWD      0x80	/* Status Register Write Disable */
+
+/* sflashcontrol action+opcodes for Atmel flashes */
+#define SFLASH_AT_READ              0x07e8
+#define SFLASH_AT_PAGE_READ         0x07d2
+/* PR9631: impossible to specify Atmel Buffer Read command */
+#define SFLASH_AT_BUF1_READ
+#define SFLASH_AT_BUF2_READ
+#define SFLASH_AT_STATUS            0x01d7
+#define SFLASH_AT_BUF1_WRITE            0x0384
+#define SFLASH_AT_BUF2_WRITE            0x0387
+#define SFLASH_AT_BUF1_ERASE_PROGRAM        0x0283
+#define SFLASH_AT_BUF2_ERASE_PROGRAM        0x0286
+#define SFLASH_AT_BUF1_PROGRAM          0x0288
+#define SFLASH_AT_BUF2_PROGRAM          0x0289
+#define SFLASH_AT_PAGE_ERASE            0x0281
+#define SFLASH_AT_BLOCK_ERASE           0x0250
+#define SFLASH_AT_BUF1_WRITE_ERASE_PROGRAM  0x0382
+#define SFLASH_AT_BUF2_WRITE_ERASE_PROGRAM  0x0385
+#define SFLASH_AT_BUF1_LOAD         0x0253
+#define SFLASH_AT_BUF2_LOAD         0x0255
+#define SFLASH_AT_BUF1_COMPARE          0x0260
+#define SFLASH_AT_BUF2_COMPARE          0x0261
+#define SFLASH_AT_BUF1_REPROGRAM        0x0258
+#define SFLASH_AT_BUF2_REPROGRAM        0x0259
+
+/* Status register bits for Atmel flashes */
+#define SFLASH_AT_READY             0x80
+#define SFLASH_AT_MISMATCH          0x40
+#define SFLASH_AT_ID_MASK           0x38
+#define SFLASH_AT_ID_SHIFT          3
+
+#ifndef _LANGUAGE_ASSEMBLY
+/* I2C bus ID  :
+ *  - Keystone has two I2C bus implemented.
+ */
+typedef enum cc_i2c_id_e {
+    CC_I2C_ID0 = 0,
+    CC_I2C_ID1,
+    CC_I2C_NUM_BUS
+} cc_i2c_id_t;
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#define CC_I2C_ID_IS_VALID(_id)    ((_id) < CC_I2C_NUM_BUS)
+
+#define CC_I2C_OFFSETOF(_id)  \
+        (((_id) == CC_I2C_ID1) ? CC_I2C1_ADDR_BASE : CC_I2C0_ADDR_BASE)
+
+/* I2C reg-i2c_slaveaddrl :field defintiion */
+#define CC_I2CSADDR_ADDR_MASK       0xFE
+#define CC_I2CSADDR_ADDR_OFFSET     1
+#define CC_I2CSADDR_GENC_MASK       0x01
+
+/* I2C reg-i2c_slaveaddrl :field defintiion */
+#define CC_I2CDATA_MASK     0xFF
+
+/* I2C reg-i2c_sts_ccr :field defintiion */
+#define CC_I2CCCR_MMASK     0x78
+#define CC_I2CCCR_MSHIFT    3
+#define CC_I2CCCR_NMASK     0x07
+#define CC_I2CCCR_MASK      (CC_I2CCCR_MMASK | CC_I2CCCR_NMASK)
+#define CC_I2CSTS_MASK      0xF8	/* Status value mask */
+
+/* I2C reg-i2c_control :field defintiion */
+#define CC_I2CCTRL_MASK     0xfc	/* interrupt enable */
+#define CC_I2CCTRL_INTEN    0x80	/* interrupt enable */
+#define CC_I2CCTRL_BUSEN    0x40	/* bus enable */
+#define CC_I2CCTRL_MSTART   0x20	/* Master Start */
+#define CC_I2CCTRL_MSTOP    0x10	/* Master Stop */
+#define CC_I2CCTRL_INTFLAG  0x08	/* interrupt status flag */
+#define CC_I2CCTRL_AAK      0x04	/* assert Ack */
+
+/* I2C reg-i2c_ext_slaveaddr :field defintiion */
+#define CC_I2EXTADDR_ADDR_MASK  0x07	/* [2:0] address mask for the MSB of 10 bit addr */
+
+/* I2C reg-i2c_data :status value defintiion 
+ *
+ * Note that all of the status codes are multiples of 8.
+ */
+#define CC_I2CSTS_BUS_ERR               0x00
+#define CC_I2CSTS_TX_MSTART             0x08	/* (Master)Start Transmitted */
+#define CC_I2CSTS_TX_MRSTART            0x10	/* (Master)Repeated Start Transmitted */
+#define CC_I2CSTS_TX_MWADDR_ACK         0x18	/* (Master)Receive Ack when address+write trasnmitted */
+#define CC_I2CSTS_TX_MWADDR_NACK        0x20	/* (Master)Receive no Ack when address+write trasnmitted */
+#define CC_I2CSTS_TX_MDATA_ACK          0x28	/* (Master)Receive Ack when data trasnmitted */
+#define CC_I2CSTS_TX_MDATA_NACK         0x30	/* (Master)Receive no Ack when data trasnmitted */
+#define CC_I2CSTS_ABT_LOST              0x38	/* Arbitration lost */
+#define CC_I2CSTS_TX_MRADDR_ACK         0x40	/* (Master)Receive Ack when address+read trasnmitted */
+#define CC_I2CSTS_TX_MRADDR_NACK        0x48	/* (Master)Receive no Ack when address+read trasnmitted */
+#define CC_I2CSTS_RX_MDATA_ACK          0x50	/* Ack transmitted when data received in master mode */
+#define CC_I2CSTS_RX_MDATA_NACK         0x58	/* No Ack transmitted when data received in master mode */
+#define CC_I2CSTS_RX_WADDR_ACK          0x60	/* Ack transmitted when addr+write received */
+#define CC_I2CSTS_ABT_LOST1_ACK         0x68	/* Ack transmitted when Arbitration lost for case 1 */
+#define CC_I2CSTS_RX_GENC_ACK           0x70	/* Ack transmitted when General Call address received. */
+#define CC_I2CSTS_ABT_LOST2_ACK         0x78	/* Ack transmitted when Arbitration lost for case 2 */
+#define CC_I2CSTS_RX_ADDRDATA_ACK       0x80
+#define CC_I2CSTS_RX_ADDRDATA_NACK      0x88
+#define CC_I2CSTS_RX_GENCDATA_ACK       0x90
+#define CC_I2CSTS_RX_GENCDATA_NACK      0x98
+#define CC_I2CSTS_RX_SSTOP_SRSTART      0xA0	/* (Slave)Stop or Repeat Start received */
+#define CC_I2CSTS_RX_SRADDR_ACK         0xA8	/* (Slave)Ack transmitted when received address+read */
+#define CC_I2CSTS_ABT_LOST3_ACK         0xB0	/* Ack transmitted when Arbitration lost for case 3 */
+#define CC_I2CSTS_TX_SDATA_ACK          0xB8
+#define CC_I2CSTS_TX_SDATA_NACK         0xC0
+#define CC_I2CSTS_TX_SLASTDATA_ACK      0xC8
+#define CC_I2CSTS_TX_MW2NDADDR_ACK      0xD0
+#define CC_I2CSTS_TX_MW2NDADDR_NACK     0xD8
+#define CC_I2CSTS_TX_MR2NDADDR_ACK      0xE0
+#define CC_I2CSTS_TX_MR2NDADDR_NACK     0xE8
+#define CC_I2CSTS_NO_STATUS             0xF8
+
+/* I2C reg-i2c_extaddr */
+#define CC_I2CEXTADDR_MASK      0x07	/* valid MSB 3 bits */
+#define CC_I2CEXTADDR_PREFIX    0xF8	/* 5 bits prefix in 10 bit addressing mode */
+
+/* I2C reg-i2c_reset : this register mask/val definition is referenced from 
+ * ESW CMIC_I2C_RESET relevant design 
+ */
+#define CC_I2CRESET_MASK        0xFF	/* valid MSB 3 bits */
+#define CC_I2CRESET_VAL         0xFF	/* value one to reset */
+
+/* Serial IO eanble and interrupt registers MASK and bit value definition */
+#define CC_SERIAL_IO_I2C0_MASK      0x1
+#define CC_SERIAL_IO_I2C1_MASK      0x2
+#define CC_SERIAL_IO_I2C_SHIFT      0
+#define CC_SERIAL_IO_SPI_SHIFT      2
+#define CC_SERIAL_IO_SPI_MASK       0x1C
+/* all serial IO select mask */
+#define CC_SERIAL_IOSEL_ALL_MASK    \
+        (CC_SERIAL_IO_I2C0_MASK | CC_SERIAL_IO_I2C1_MASK | \
+        CC_SERIAL_IO_SPI_MASK)
+/* i2c serial IO select mask */
+#define CC_SERIAL_IOSEL_I2C_MASK    \
+        (CC_SERIAL_IO_I2C0_MASK | CC_SERIAL_IO_I2C1_MASK)
+/* all serial IO interrupt(CC level) mask */
+#define CC_SERIAL_IOINT_ALL_MASK    \
+        (CC_SERIAL_IO_I2C0_MASK | CC_SERIAL_IO_I2C1_MASK | \
+        CC_SERIAL_IO_SPI_MASK)
+/* i2c serial IO interrupt(CC level) mask */
+#define CC_SERIAL_IOINT_I2C_MASK    \
+        (CC_SERIAL_IO_I2C0_MASK | CC_SERIAL_IO_I2C1_MASK)
+
+#ifndef _LANGUAGE_ASSEMBLY
+/* SPI device ID  :
+ *  - Keystone has three SPI device selected.
+ */
+typedef enum cc_spi_id_e {
+    CC_SPI_SS0 = 0,
+    CC_SPI_SS1,
+    CC_SPI_SS2,
+    CC_SPI_NUM_DEV
+} cc_spi_id_t;
+
+/* SPI Mode :
+ *  - Keystone has four SPI mode control.
+ */
+typedef enum cc_spi_mode_e {
+    CC_SPI_MODE_CPOL_0_CPHA_0 = 0,
+    CC_SPI_MODE_CPOL_0_CPHA_1,
+    CC_SPI_MODE_CPOL_1_CPHA_0,
+    CC_SPI_MODE_CPOL_1_CPHA_1,
+    CC_SPI_NUM_MODE
+} cc_spi_mode_t;
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+#define CC_SPI_ID_IS_VALID(_id)    ((_id) < CC_SPI_NUM_DEV)
+
+#define CC_SPI_MODE_IS_VALID(_id)    ((_id) < CC_SPI_NUM_MODE)
+
+/* SPI reg-spi_mode_ctrl :field defintiion */
+#define CC_SPIMCTRL_MODE_MASK     0x3	/* SPI mode valid bits */
+#define CC_SPIMCTRL_MODE_0     0x0	/* SPI mode : CPOL = 0, CPHA = 0 */
+#define CC_SPIMCTRL_MODE_1     0x1	/* SPI mode : CPOL = 0, CPHA = 1 */
+#define CC_SPIMCTRL_MODE_2     0x2	/* SPI mode : CPOL = 1, CPHA = 0 */
+#define CC_SPIMCTRL_MODE_3     0x3	/* SPI mode : CPOL = 1, CPHA = 1 */
+#define CC_SPIMCTRL_ACKEN_MASK     0x4	/* SPI RACK enable valid bits */
+#define CC_SPIMCTRL_ACKEN     0x4	/* SPI RACK */
+#define CC_SPIMCTRL_ENDIAN_MASK     0x8	/* SPI endiag valid bits */
+#define CC_SPIMCTRL_BE     0x8	/* SPI endiag : big endian mode */
+#define CC_SPIMCTRL_LE     0x0	/* SPI endiag : little endian mode */
+#define CC_SPIMCTRL_LSB_MASK     0x100	/* SPI LSB first valid bits */
+#define CC_SPIMCTRL_LSB_FIRST     0x100	/* SPI LSB : big endian mode */
+#define CC_SPIMCTRL_MSB_FIRST    0x0	/* SPI LSB : little endian mode */
+#define CC_SPIMCTRL_CLK_MASK     0xf0	/* SPI clock divider valid bits */
+
+/* SPI reg-spi_config :field defintiion */
+#define CC_SPICFG_MASK     0x9f87e1fb	/* SPI config valid bits */
+
+/* SPI reg-spi_fifo_io :field defintiion */
+#define CC_SPIFIFOIO_MASK     0xffffffff	/* SPI FIFO IO valid bits */
+
+/* SPI reg-spi_status :field defintiion */
+#define CC_SPISTS_MASK     0x37	/* SPI status valid bits */
+#define CC_SPISTS_READY    0x1	/* SPI ready */
+#define CC_SPISTS_RDONE    0x2	/* SPI transaction done and FIFO is empty when reading data */
+#define CC_SPISTS_INTFLAG   0x4	/* SPI Interrupt Flag */
+#define CC_SPISTS_FIFOE    0x10	/* SPI FIFO empty */
+#define CC_SPISTS_FIFOF  0x20	/* SPI FIFO full */
+
+/* Serial IO eanble MASK and bit value definition */
+#define CC_SERIAL_IO_SPI_INTR_MASK       0x4
+#define CC_SERIAL_IO_SPI0_MASK       0x4
+#define CC_SERIAL_IO_SPI1_MASK       0xc
+#define CC_SERIAL_IO_SPI2_MASK       0x1c
+
+/* 
+ * These are the UART port assignments, expressed as offsets from the base
+ * register.  These assignments should hold for any serial port based on
+ * a 8250, 16450, or 16550(A).
+ */
+
+#define UART_RX     0		/* In:  Receive buffer (DLAB=0) */
+#define UART_TX     0		/* Out: Transmit buffer (DLAB=0) */
+#define UART_DLL    0		/* Out: Divisor Latch Low (DLAB=1) */
+#define UART_IER    1		/* In/Out: Interrupt Enable Register (DLAB=0) */
+#define UART_DLM    1		/* Out: Divisor Latch High (DLAB=1) */
+#define UART_IIR    2		/* In: Interrupt Identity Register  */
+#define UART_FCR    2		/* Out: FIFO Control Register */
+#define UART_LCR    3		/* Out: Line Control Register */
+#define UART_MCR    4		/* Out: Modem Control Register */
+#define UART_LSR    5		/* In:  Line Status Register */
+#define UART_MSR    6		/* In:  Modem Status Register */
+#define UART_SCR    7		/* I/O: Scratch Register */
+#define UART_LCR_DLAB   0x80	/* Divisor latch access bit */
+#define UART_LCR_WLEN8  0x03	/* Wordlength: 8 bits */
+#define UART_MCR_OUT2   0x08	/* MCR GPIO out 2 */
+#define UART_MCR_LOOP   0x10	/* Enable loopback test mode */
+#define UART_LSR_THRE   0x20	/* Transmit-hold-register empty */
+#define UART_LSR_RXRDY  0x01	/* Receiver ready */
+#define UART_FCR_FIFO_ENABLE 1	/* FIFO control register bit controlling FIFO enable/disable */
+
+/* Interrupt Identity Register (IIR) bits */
+#define UART_IIR_FIFO_MASK  0xc0	/* IIR FIFO disable/enabled mask */
+#define UART_IIR_INT_MASK   0xf	/* IIR interrupt ID source */
+#define UART_IIR_MDM_CHG    0x0	/* Modem status changed */
+#define UART_IIR_NOINT      0x1	/* No interrupt pending */
+#define UART_IIR_THRE       0x2	/* THR empty */
+#define UART_IIR_RCVD_DATA  0x4	/* Received data available */
+#define UART_IIR_RCVR_STATUS    0x6	/* Receiver status */
+#define UART_IIR_CHAR_TIME  0xc	/* Character time */
+
+/* Interrupt Enable Register (IER) bits */
+#define UART_IER_EDSSI  8	/* enable modem status interrupt */
+#define UART_IER_ELSI   4	/* enable receiver line status interrupt */
+#define UART_IER_ETBEI  2	/* enable transmitter holding register empty interrupt */
+#define UART_IER_ERBFI  1	/* enable data available interrupt */
+
+/* pmustatus */
+#define PST_INTPEND 0x0040
+#define PST_SBCLKST 0x0030
+#define PST_ALPAVAIL    0x0008
+#define PST_HTAVAIL 0x0004
+#define PST_RESINIT 0x0003
+
+/* pmucapabilities */
+#define PCAP_REV_MASK   0x000000ff
+#define PCAP_RC_MASK    0x00001f00
+#define PCAP_RC_SHIFT   8
+#define PCAP_TC_MASK    0x0001e000
+#define PCAP_TC_SHIFT   13
+#define PCAP_PC_MASK    0x001e0000
+#define PCAP_PC_SHIFT   17
+#define PCAP_VC_MASK    0x01e00000
+#define PCAP_VC_SHIFT   21
+#define PCAP_CC_MASK    0x1e000000
+#define PCAP_CC_SHIFT   25
+#define PCAP5_PC_MASK   0x003e0000	/* PMU corerev >= 5 */
+#define PCAP5_PC_SHIFT  17
+#define PCAP5_VC_MASK   0x07c00000
+#define PCAP5_VC_SHIFT  22
+#define PCAP5_CC_MASK   0xf8000000
+#define PCAP5_CC_SHIFT  27
+
+/* PMU Resource Request Timer registers */
+/* This is based on PmuRev0 */
+#define PRRT_TIME_MASK  0x03ff
+#define PRRT_INTEN  0x0400
+#define PRRT_REQ_ACTIVE 0x0800
+#define PRRT_ALP_REQ    0x1000
+#define PRRT_HT_REQ 0x2000
+
+/* PMU resource bit position */
+#define PMURES_BIT(bit) (1 << (bit))
+
+/* PMU resource number limit */
+#define PMURES_MAX_RESNUM   30
+
+/* PMU corerev and chip specific PLL controls.
+ * PMU<rev>_PLL<num>_XXXX where <rev> is PMU corerev and <num> is an arbitary number
+ * to differentiate different PLLs controlled by the same PMU rev.
+ */
+/* XXX PMU corerev 0 for BCM4328 BCM5354 pll */
+/* pllcontrol registers */
+/* PDIV, div_phy, div_arm, div_adc, dith_sel, ioff, kpd_scale, lsb_sel, mash_sel, lf_c & lf_r */
+#define PMU0_PLL0_PLLCTL0       0
+#define PMU0_PLL0_PC0_PDIV_MASK     1
+#define PMU0_PLL0_PC0_PDIV_FREQ     25000
+#define PMU0_PLL0_PC0_DIV_ARM_MASK  0x00000038
+#define PMU0_PLL0_PC0_DIV_ARM_SHIFT 3
+#define PMU0_PLL0_PC0_DIV_ARM_BASE  8
+
+/* PC0_DIV_ARM for PLLOUT_ARM */
+#define PMU0_PLL0_PC0_DIV_ARM_110MHZ    0
+#define PMU0_PLL0_PC0_DIV_ARM_97_7MHZ   1
+#define PMU0_PLL0_PC0_DIV_ARM_88MHZ 2
+#define PMU0_PLL0_PC0_DIV_ARM_80MHZ 3	/* Default */
+#define PMU0_PLL0_PC0_DIV_ARM_73_3MHZ   4
+#define PMU0_PLL0_PC0_DIV_ARM_67_7MHZ   5
+#define PMU0_PLL0_PC0_DIV_ARM_62_9MHZ   6
+#define PMU0_PLL0_PC0_DIV_ARM_58_6MHZ   7
+
+/* Wildcard base, stop_mod, en_lf_tp, en_cal & lf_r2 */
+#define PMU0_PLL0_PLLCTL1       1
+#define PMU0_PLL0_PC1_WILD_INT_MASK 0xf0000000
+#define PMU0_PLL0_PC1_WILD_INT_SHIFT    28
+#define PMU0_PLL0_PC1_WILD_FRAC_MASK    0x0fffff00
+#define PMU0_PLL0_PC1_WILD_FRAC_SHIFT   8
+#define PMU0_PLL0_PC1_STOP_MOD      0x00000040
+
+/* Wildcard base, vco_calvar, vco_swc, vco_var_selref, vso_ical & vco_sel_avdd */
+#define PMU0_PLL0_PLLCTL2       2
+#define PMU0_PLL0_PC2_WILD_INT_MASK 0xf
+#define PMU0_PLL0_PC2_WILD_INT_SHIFT    4
+
+/* Chip specific PMU resources. */
+#define RES4328_EXT_SWITCHER_PWM    0	/* 0x00001 */
+#define RES4328_BB_SWITCHER_PWM     1	/* 0x00002 */
+#define RES4328_BB_SWITCHER_BURST   2	/* 0x00004 */
+#define RES4328_BB_EXT_SWITCHER_BURST   3	/* 0x00008 */
+#define RES4328_ILP_REQUEST     4	/* 0x00010 */
+#define RES4328_RADIO_SWITCHER_PWM  5	/* 0x00020 */
+#define RES4328_RADIO_SWITCHER_BURST    6	/* 0x00040 */
+#define RES4328_ROM_SWITCH      7	/* 0x00080 */
+#define RES4328_PA_REF_LDO      8	/* 0x00100 */
+#define RES4328_RADIO_LDO       9	/* 0x00200 */
+#define RES4328_AFE_LDO         10	/* 0x00400 */
+#define RES4328_PLL_LDO         11	/* 0x00800 */
+#define RES4328_BG_FILTBYP      12	/* 0x01000 */
+#define RES4328_TX_FILTBYP      13	/* 0x02000 */
+#define RES4328_RX_FILTBYP      14	/* 0x04000 */
+#define RES4328_XTAL_PU         15	/* 0x08000 */
+#define RES4328_XTAL_EN         16	/* 0x10000 */
+#define RES4328_BB_PLL_FILTBYP      17	/* 0x20000 */
+#define RES4328_RF_PLL_FILTBYP      18	/* 0x40000 */
+#define RES4328_BB_PLL_PU       19	/* 0x80000 */
+
+#define RES5354_EXT_SWITCHER_PWM    0	/* 0x00001 */
+#define RES5354_BB_SWITCHER_PWM     1	/* 0x00002 */
+#define RES5354_BB_SWITCHER_BURST   2	/* 0x00004 */
+#define RES5354_BB_EXT_SWITCHER_BURST   3	/* 0x00008 */
+#define RES5354_ILP_REQUEST     4	/* 0x00010 */
+#define RES5354_RADIO_SWITCHER_PWM  5	/* 0x00020 */
+#define RES5354_RADIO_SWITCHER_BURST    6	/* 0x00040 */
+#define RES5354_ROM_SWITCH      7	/* 0x00080 */
+#define RES5354_PA_REF_LDO      8	/* 0x00100 */
+#define RES5354_RADIO_LDO       9	/* 0x00200 */
+#define RES5354_AFE_LDO         10	/* 0x00400 */
+#define RES5354_PLL_LDO         11	/* 0x00800 */
+#define RES5354_BG_FILTBYP      12	/* 0x01000 */
+#define RES5354_TX_FILTBYP      13	/* 0x02000 */
+#define RES5354_RX_FILTBYP      14	/* 0x04000 */
+#define RES5354_XTAL_PU         15	/* 0x08000 */
+#define RES5354_XTAL_EN         16	/* 0x10000 */
+#define RES5354_BB_PLL_FILTBYP      17	/* 0x20000 */
+#define RES5354_RF_PLL_FILTBYP      18	/* 0x40000 */
+#define RES5354_BB_PLL_PU       19	/* 0x80000 */
+
+/* pllcontrol registers */
+/* ndiv_pwrdn, pwrdn_ch<x>, refcomp_pwrdn, dly_ch<x>, p1div, p2div, _bypsss_sdmod */
+#define PMU1_PLL0_PLLCTL0       0
+#define PMU1_PLL0_PC0_P1DIV_MASK    0x00f00000
+#define PMU1_PLL0_PC0_P1DIV_SHIFT   20
+#define PMU1_PLL0_PC0_P2DIV_MASK    0x0f000000
+#define PMU1_PLL0_PC0_P2DIV_SHIFT   24
+
+/* m<x>div */
+#define PMU1_PLL0_PLLCTL1       1
+#define PMU1_PLL0_PC1_M1DIV_MASK    0x000000ff
+#define PMU1_PLL0_PC1_M1DIV_SHIFT   0
+#define PMU1_PLL0_PC1_M2DIV_MASK    0x0000ff00
+#define PMU1_PLL0_PC1_M2DIV_SHIFT   8
+#define PMU1_PLL0_PC1_M3DIV_MASK    0x00ff0000
+#define PMU1_PLL0_PC1_M3DIV_SHIFT   16
+#define PMU1_PLL0_PC1_M4DIV_MASK    0xff000000
+#define PMU1_PLL0_PC1_M4DIV_SHIFT   24
+
+#define DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT 8
+#define DOT11MAC_880MHZ_CLK_DIVISOR_MASK (0xFF << DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT)
+#define DOT11MAC_880MHZ_CLK_DIVISOR_VAL  (0xE << DOT11MAC_880MHZ_CLK_DIVISOR_SHIFT)
+
+/* m<x>div, ndiv_dither_mfb, ndiv_mode, ndiv_int */
+#define PMU1_PLL0_PLLCTL2       2
+#define PMU1_PLL0_PC2_M5DIV_MASK    0x000000ff
+#define PMU1_PLL0_PC2_M5DIV_SHIFT   0
+#define PMU1_PLL0_PC2_M6DIV_MASK    0x0000ff00
+#define PMU1_PLL0_PC2_M6DIV_SHIFT   8
+#define PMU1_PLL0_PC2_NDIV_MODE_MASK    0x000e0000
+#define PMU1_PLL0_PC2_NDIV_MODE_SHIFT   17
+#define PMU1_PLL0_PC2_NDIV_INT_MASK 0x1ff00000
+#define PMU1_PLL0_PC2_NDIV_INT_SHIFT    20
+
+/* ndiv_frac */
+#define PMU1_PLL0_PLLCTL3       3
+#define PMU1_PLL0_PC3_NDIV_FRAC_MASK    0x00ffffff
+#define PMU1_PLL0_PC3_NDIV_FRAC_SHIFT   0
+
+/* pll_ctrl */
+#define PMU1_PLL0_PLLCTL4       4
+
+/* pll_ctrl, vco_rng, clkdrive_ch<x> */
+#define PMU1_PLL0_PLLCTL5       5
+#define PMU1_PLL0_PC5_CLK_DRV_MASK 0xffffff00
+#define PMU1_PLL0_PC5_CLK_DRV_SHIFT 8
+
+/* PMU rev 2 control words */
+#define PMU2_PHY_PLL_PLLCTL     4
+#define PMU2_SI_PLL_PLLCTL      10
+
+/* PMU rev 5 */
+#define PMU5_MAINPLL_PLL0       12
+
+#define PMU5_PLL_P1P2_OFF       0
+#define PMU5_PLL_P1_MASK        0x0f000000
+#define PMU5_PLL_P1_SHIFT       24
+#define PMU5_PLL_P2_MASK        0x00f00000
+#define PMU5_PLL_P2_SHIFT       20
+#define PMU5_PLL_M14_OFF        1
+#define PMU5_PLL_MDIV_MASK      0x000000ff
+#define PMU5_PLL_MDIV_WIDTH     8
+#define PMU5_PLL_NM5_OFF        2
+#define PMU5_PLL_NDIV_MASK      0xfff00000
+#define PMU5_PLL_NDIV_SHIFT     20
+#define PMU5_PLL_FMAB_OFF       3
+#define PMU5_PLL_MRAT_MASK      0xf0000000
+#define PMU5_PLL_MRAT_SHIFT     28
+#define PMU5_PLL_ABRAT_MASK     0x08000000
+#define PMU5_PLL_ABRAT_SHIFT        27
+#define PMU5_PLL_FDIV_MASK      0x07ffffff
+#define PMU5_PLL_PLLCTL_OFF     4
+#define PMU5_PLL_PCHI_OFF       5
+#define PMU5_PLL_PCHI_MASK      0x0000003f
+
+/* Divider allocation in 4716 */
+#define PMU5_MAINPLL_CPU        1
+#define PMU5_MAINPLL_MEM        2
+#define PMU5_MAINPLL_SI         3
+
+/* A0/A1 resources */
+#define RES4325_BUCK_BOOST_BURST    0	/* 0x00000001 */
+#define RES4325_CBUCK_BURST     1	/* 0x00000002 */
+#define RES4325_CBUCK_PWM       2	/* 0x00000004 */
+#define RES4325_CLDO_CBUCK_BURST    3	/* 0x00000008 */
+#define RES4325_CLDO_CBUCK_PWM      4	/* 0x00000010 */
+#define RES4325_BUCK_BOOST_PWM      5	/* 0x00000020 */
+#define RES4325_ILP_REQUEST     6	/* 0x00000040 */
+#define RES4325_ABUCK_BURST     7	/* 0x00000080 */
+#define RES4325_ABUCK_PWM       8	/* 0x00000100 */
+#define RES4325_LNLDO1_PU       9	/* 0x00000200 */
+#define RES4325_LNLDO2_PU       10	/* 0x00000400 */
+#define RES4325_LNLDO3_PU       11	/* 0x00000800 */
+#define RES4325_LNLDO4_PU       12	/* 0x00001000 */
+#define RES4325_XTAL_PU         13	/* 0x00002000 */
+#define RES4325_ALP_AVAIL       14	/* 0x00004000 */
+#define RES4325_RX_PWRSW_PU     15	/* 0x00008000 */
+#define RES4325_TX_PWRSW_PU     16	/* 0x00010000 */
+#define RES4325_RFPLL_PWRSW_PU      17	/* 0x00020000 */
+#define RES4325_LOGEN_PWRSW_PU      18	/* 0x00040000 */
+#define RES4325_AFE_PWRSW_PU        19	/* 0x00080000 */
+#define RES4325_BBPLL_PWRSW_PU      20	/* 0x00100000 */
+#define RES4325_HT_AVAIL        21	/* 0x00200000 */
+
+/* B0/C0 resources */
+#define RES4325B0_CBUCK_LPOM        1	/* 0x00000002 */
+#define RES4325B0_CBUCK_BURST       2	/* 0x00000004 */
+#define RES4325B0_CBUCK_PWM     3	/* 0x00000008 */
+#define RES4325B0_CLDO_PU       4	/* 0x00000010 */
+
+/* C1 resources */
+#define RES4325C1_OTP_PWRSW_PU      10	/* 0x00000400 */
+#define RES4325C1_LNLDO2_PU     12	/* 0x00001000 */
+
+/* Chip specific ChipStatus register bits */
+#define CST4325_SPROM_OTP_SEL_MASK  0x00000003
+#define CST4325_DEFCIS_SEL      0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4325_SPROM_SEL       1	/* OTP is powered up, SPROM is present */
+#define CST4325_OTP_SEL         2	/* OTP is powered up, no SPROM */
+#define CST4325_OTP_PWRDN       3	/* OTP is powered down, SPROM is present */
+#define CST4325_SDIO_USB_MODE_MASK  0x00000004
+#define CST4325_SDIO_USB_MODE_SHIFT 2
+#define CST4325_RCAL_VALID_MASK     0x00000008
+#define CST4325_RCAL_VALID_SHIFT    3
+#define CST4325_RCAL_VALUE_MASK     0x000001f0
+#define CST4325_RCAL_VALUE_SHIFT    4
+#define CST4325_PMUTOP_2B_MASK      0x00000200	/* 1 for 2b, 0 for to 2a */
+#define CST4325_PMUTOP_2B_SHIFT     9
+
+#ifdef UNRELEASEDCHIP
+#define RES4329_RESERVED0       0	/* 0x00000001 */
+#define RES4329_CBUCK_LPOM      1	/* 0x00000002 */
+#define RES4329_CBUCK_BURST     2	/* 0x00000004 */
+#define RES4329_CBUCK_PWM       3	/* 0x00000008 */
+#define RES4329_CLDO_PU         4	/* 0x00000010 */
+#define RES4329_PALDO_PU        5	/* 0x00000020 */
+#define RES4329_ILP_REQUEST     6	/* 0x00000040 */
+#define RES4329_RESERVED7       7	/* 0x00000080 */
+#define RES4329_RESERVED8       8	/* 0x00000100 */
+#define RES4329_LNLDO1_PU       9	/* 0x00000200 */
+#define RES4329_OTP_PU          10	/* 0x00000400 */
+#define RES4329_RESERVED11      11	/* 0x00000800 */
+#define RES4329_LNLDO2_PU       12	/* 0x00001000 */
+#define RES4329_XTAL_PU         13	/* 0x00002000 */
+#define RES4329_ALP_AVAIL       14	/* 0x00004000 */
+#define RES4329_RX_PWRSW_PU     15	/* 0x00008000 */
+#define RES4329_TX_PWRSW_PU     16	/* 0x00010000 */
+#define RES4329_RFPLL_PWRSW_PU      17	/* 0x00020000 */
+#define RES4329_LOGEN_PWRSW_PU      18	/* 0x00040000 */
+#define RES4329_AFE_PWRSW_PU        19	/* 0x00080000 */
+#define RES4329_BBPLL_PWRSW_PU      20	/* 0x00100000 */
+#define RES4329_HT_AVAIL        21	/* 0x00200000 */
+
+#define CST4329_SPROM_OTP_SEL_MASK  0x00000003
+#define CST4329_DEFCIS_SEL      0	/* OTP is powered up, use def. CIS, no SPROM */
+#define CST4329_SPROM_SEL       1	/* OTP is powered up, SPROM is present */
+#define CST4329_OTP_SEL         2	/* OTP is powered up, no SPROM */
+#define CST4329_OTP_PWRDN       3	/* OTP is powered down, SPROM is present */
+#define CST4329_SPI_SDIO_MODE_MASK  0x00000004
+#define CST4329_SPI_SDIO_MODE_SHIFT 2
+#endif				/* UNRELEASEDCHIP */
+
+/* all PMU chips with little memory constraint */
+#define RES4312_SWITCHER_BURST      0	/* 0x00000001 */
+#define RES4312_SWITCHER_PWM        1	/* 0x00000002 */
+#define RES4312_PA_REF_LDO      2	/* 0x00000004 */
+#define RES4312_CORE_LDO_BURST      3	/* 0x00000008 */
+#define RES4312_CORE_LDO_PWM        4	/* 0x00000010 */
+#define RES4312_RADIO_LDO       5	/* 0x00000020 */
+#define RES4312_ILP_REQUEST     6	/* 0x00000040 */
+#define RES4312_BG_FILTBYP      7	/* 0x00000080 */
+#define RES4312_TX_FILTBYP      8	/* 0x00000100 */
+#define RES4312_RX_FILTBYP      9	/* 0x00000200 */
+#define RES4312_XTAL_PU         10	/* 0x00000400 */
+#define RES4312_ALP_AVAIL       11	/* 0x00000800 */
+#define RES4312_BB_PLL_FILTBYP      12	/* 0x00001000 */
+#define RES4312_RF_PLL_FILTBYP      13	/* 0x00002000 */
+#define RES4312_HT_AVAIL        14	/* 0x00004000 */
+
+#define RES4322_RF_LDO          0
+#define RES4322_ILP_REQUEST     1
+#define RES4322_XTAL_PU         2
+#define RES4322_ALP_AVAIL       3
+#define RES4322_SI_PLL_ON       4
+#define RES4322_HT_SI_AVAIL     5
+#define RES4322_PHY_PLL_ON      6
+#define RES4322_HT_PHY_AVAIL        7
+#define RES4322_OTP_PU          8
+
+/* Chip specific ChipStatus register bits */
+#define CST4322_XTAL_FREQ_20_40MHZ  0x00000020
+#define CST4322_SPROM_OTP_SEL_MASK  0x000000c0
+#define CST4322_SPROM_OTP_SEL_SHIFT 6
+#define CST4322_NO_SPROM_OTP        0	/* no OTP, no SPROM */
+#define CST4322_SPROM_PRESENT       1	/* SPROM is present */
+#define CST4322_OTP_PRESENT     2	/* OTP is present */
+#define CST4322_PCI_OR_USB      0x00000100
+#define CST4322_BOOT_MASK       0x00000600
+#define CST4322_BOOT_SHIFT      9
+#define CST4322_BOOT_FROM_SRAM      0	/* boot from SRAM, ARM in reset */
+#define CST4322_BOOT_FROM_ROM       1	/* boot from ROM */
+#define CST4322_BOOT_FROM_FLASH     2	/* boot from FLASH */
+#define CST4322_BOOT_FROM_INVALID   3
+#define CST4322_ILP_DIV_EN      0x00000800
+#define CST4322_FLASH_TYPE_MASK     0x00001000
+#define CST4322_FLASH_TYPE_SHIFT    12
+#define CST4322_FLASH_TYPE_SHIFT_ST 0	/* ST serial FLASH */
+#define CST4322_FLASH_TYPE_SHIFT_ATMEL  1	/* ATMEL flash */
+#define CST4322_ARM_TAP_SEL     0x00002000
+#define CST4322_RES_INIT_MODE_MASK  0x0000c000
+#define CST4322_RES_INIT_MODE_SHIFT 14
+#define CST4322_RES_INIT_MODE_ILPAVAIL  0	/* resinitmode: ILP available */
+#define CST4322_RES_INIT_MODE_ILPREQ    1	/* resinitmode: ILP request */
+#define CST4322_RES_INIT_MODE_ALPAVAIL  2	/* resinitmode: ALP available */
+#define CST4322_RES_INIT_MODE_HTAVAIL   3	/* resinitmode: HT avilable */
+#define CST4322_PCIPLLCLK_GATING    0x00010000
+#define CST4322_CLK_SWITCH_PCI_TO_ALP   0x00020000
+#define CST4322_PCI_CARDBUS_MODE    0x00040000
+
+#ifdef UNRELEASEDCHIP
+#define RES4315_CBUCK_LPOM      1	/* 0x00000002 */
+#define RES4315_CBUCK_BURST     2	/* 0x00000004 */
+#define RES4315_CBUCK_PWM       3	/* 0x00000008 */
+#define RES4315_CLDO_PU         4	/* 0x00000010 */
+#define RES4315_PALDO_PU        5	/* 0x00000020 */
+#define RES4315_ILP_REQUEST     6	/* 0x00000040 */
+#define RES4315_LNLDO1_PU       9	/* 0x00000200 */
+#define RES4315_OTP_PU          10	/* 0x00000400 */
+#define RES4315_LNLDO2_PU       12	/* 0x00001000 */
+#define RES4315_XTAL_PU         13	/* 0x00002000 */
+#define RES4315_ALP_AVAIL       14	/* 0x00004000 */
+#define RES4315_RX_PWRSW_PU     15	/* 0x00008000 */
+#define RES4315_TX_PWRSW_PU     16	/* 0x00010000 */
+#define RES4315_RFPLL_PWRSW_PU      17	/* 0x00020000 */
+#define RES4315_LOGEN_PWRSW_PU      18	/* 0x00040000 */
+#define RES4315_AFE_PWRSW_PU        19	/* 0x00080000 */
+#define RES4315_BBPLL_PWRSW_PU      20	/* 0x00100000 */
+#define RES4315_HT_AVAIL        21	/* 0x00200000 */
+
+#define CST4315_SPROM_OTP_SEL_MASK  0x00000003	/* gpio [7:6], SDIO CIS selection */
+#define CST4315_DEFCIS_SEL      0x00000000	/* use default CIS, OTP is powered up */
+#define CST4315_SPROM_SEL       0x00000001	/* use SPROM, OTP is powered up */
+#define CST4315_OTP_SEL         0x00000002	/* use OTP, OTP is powered up */
+#define CST4315_OTP_PWRDN       0x00000003	/* use SPROM, OTP is powered down */
+#define CST4315_SDIO_MODE       0x00000004	/* gpio [8], sdio/usb mode */
+#define CST4315_RCAL_VALID      0x00000008
+#define CST4315_RCAL_VALUE_MASK     0x000001f0
+#define CST4315_RCAL_VALUE_SHIFT    4
+#define CST4315_PALDO_EXTPNP        0x00000200	/* PALDO is configured with external PNP */
+#define CST4315_CBUCK_MODE_MASK     0x00000c00
+#define CST4315_CBUCK_MODE_BURST    0x00000400
+#define CST4315_CBUCK_MODE_LPBURST  0x00000c00
+#endif				/* UNRELEASEDCHIP */
+
+#ifdef UNRELEASEDCHIP
+#define RES4319_CBUCK_LPOM      1	/* 0x00000002 */
+#define RES4319_CBUCK_BURST     2	/* 0x00000004 */
+#define RES4319_CBUCK_PWM       3	/* 0x00000008 */
+#define RES4319_CLDO_PU         4	/* 0x00000010 */
+#define RES4319_PALDO_PU        5	/* 0x00000020 */
+#define RES4319_ILP_REQUEST     6	/* 0x00000040 */
+#define RES4319_LNLDO1_PU       9	/* 0x00000200 */
+#define RES4319_OTP_PU          10	/* 0x00000400 */
+#define RES4319_LNLDO2_PU       12	/* 0x00001000 */
+#define RES4319_XTAL_PU         13	/* 0x00002000 */
+#define RES4319_ALP_AVAIL       14	/* 0x00004000 */
+#define RES4319_RX_PWRSW_PU     15	/* 0x00008000 */
+#define RES4319_TX_PWRSW_PU     16	/* 0x00010000 */
+#define RES4319_RFPLL_PWRSW_PU      17	/* 0x00020000 */
+#define RES4319_LOGEN_PWRSW_PU      18	/* 0x00040000 */
+#define RES4319_AFE_PWRSW_PU        19	/* 0x00080000 */
+#define RES4319_BBPLL_PWRSW_PU      20	/* 0x00100000 */
+#define RES4319_HT_AVAIL        21	/* 0x00200000 */
+
+#define CST4319_SPROM_OTP_SEL_MASK  0x00000003	/* gpio [7:6], SDIO CIS selection */
+#define CST4319_DEFCIS_SEL      0x00000000	/* use default CIS, OTP is powered up */
+#define CST4319_SPROM_SEL       0x00000001	/* use SPROM, OTP is powered up */
+#define CST4319_OTP_SEL         0x00000002	/* use OTP, OTP is powered up */
+#define CST4319_OTP_PWRDN       0x00000003	/* use SPROM, OTP is powered down */
+#define CST4319_SDIO_USB_MODE       0x00000004	/* gpio [8], sdio/usb mode */
+#define CST4319_RCAL_VALID      0x00000008
+#define CST4319_RCAL_VALUE_MASK     0x000001f0
+#define CST4319_RCAL_VALUE_SHIFT    4
+#define CST4319_PALDO_EXTPNP        0x00000200	/* PALDO is configured with external PNP */
+#define CST4319_CBUCK_MODE_MASK     0x00000c00
+#define CST4319_CBUCK_MODE_BURST    0x00000400
+#define CST4319_CBUCK_MODE_LPBURST  0x00000c00
+#endif				/* UNRELEASEDCHIP */
+
+/*
+* Maximum delay for the PMU state transition in us.
+* This is an upper bound intended for spinwaits etc.
+*/
+#define PMU_MAX_TRANSITION_DLY  15000
+
+/* PMU resource up transition time in ILP cycles */
+#define PMURES_UP_TRANSITION    2
+
+#if !defined(BCMDONGLEHOST)
+/*
+* Infromation from BT to WLAN over eci_inputlo, eci_inputmi &
+* eci_inputhi register.  Rev >=21
+*/
+/* Fields in eci_inputlo register - [0:31] */
+#define ECI_INLO_TASKTYPE_MASK  0x0000000f	/* [3:0] - 4 bits */
+#define ECI_INLO_TASKTYPE_SHIFT 0
+#define ECI_INLO_PKTDUR_MASK    0x000000f0	/* [7:4] - 4 bits */
+#define ECI_INLO_PKTDUR_SHIFT   4
+#define ECI_INLO_ROLE_MASK  0x00000100	/* [8] - 1 bits */
+#define ECI_INLO_ROLE_SHIFT 8
+#define ECI_INLO_MLP_MASK   0x00000e00	/* [11:9] - 3 bits */
+#define ECI_INLO_MLP_SHIFT  9
+#define ECI_INLO_TXPWR_MASK 0x000ff000	/* [19:12] - 8 bits */
+#define ECI_INLO_TXPWR_SHIFT    12
+#define ECI_INLO_RSSI_MASK  0x0ff00000	/* [27:20] - 8 bits */
+#define ECI_INLO_RSSI_SHIFT 20
+#define ECI_INLO_VAD_MASK   0x10000000	/* [28] - 1 bits */
+#define ECI_INLO_VAD_SHIFT  28
+
+/*
+* Register eci_inputlo bitfield values.
+* - BT packet type information bits [7:0]
+*/
+/*  [3:0] - Task (link) type */
+#define BT_ACL              0x00
+#define BT_SCO              0x01
+#define BT_eSCO             0x02
+#define BT_A2DP             0x03
+#define BT_SNIFF            0x04
+#define BT_PAGE_SCAN            0x05
+#define BT_INQUIRY_SCAN         0x06
+#define BT_PAGE             0x07
+#define BT_INQUIRY          0x08
+#define BT_MSS              0x09
+#define BT_PARK             0x0a
+#define BT_RSSISCAN         0x0b
+#define BT_MD_ACL           0x0c
+#define BT_MD_eSCO          0x0d
+#define BT_SCAN_WITH_SCO_LINK       0x0e
+#define BT_SCAN_WITHOUT_SCO_LINK    0x0f
+/* [7:4] = packet duration code */
+/* [8] - Master / Slave */
+#define BT_MASTER           0
+#define BT_SLAVE            1
+/* [11:9] - multi-level priority */
+#define BT_LOWEST_PRIO          0x0
+#define BT_HIGHEST_PRIO         0x3
+/* [19:12] - BT transmit power */
+/* [27:20] - BT RSSI */
+/* [28] - VAD silence */
+/* [31:29] - Undefined */
+/* Register eci_inputmi values - [32:63] - none defined */
+/* [63:32] - Undefined */
+
+/* Infromation from WLAN to BT over eci_output register. */
+/* Fields in eci_output register - [0:31] */
+#define ECI_OUT_CHANNEL_MASK        0x0000000f	/* [3:0] - 4 bits */
+#define ECI_OUT_CHANNEL_SHIFT       0
+#define ECI_OUT_BW_MASK         0x00000070	/* [6:4] - 3 bits */
+#define ECI_OUT_BW_SHIFT        4
+#define ECI_OUT_ANTENNA_MASK        0x00000080	/* [7] - 1 bits */
+#define ECI_OUT_ANTENNA_SHIFT       7
+#define ECI_OUT_CUR_TXPOWER_MASK    0x00000f00	/* [11:8] - 4 bits */
+#define ECI_OUT_CUR_TXPOWER_SHIFT   8
+#define ECI_OUT_CUR_RSSI_MASK       0x0000f000	/* [15:12] - 4 bits */
+#define ECI_OUT_CUR_RSSI_SHIFT      12
+#define ECI_OUT_SIMUL_TXRX_MASK     0x00010000	/* [16] - 1 bits */
+#define ECI_OUT_SIMUL_TXRX_SHIFT    15
+
+/* Indicate controll of bits between s/w and dot11mac.
+ * Current assignment :
+ * 7:0 - wl
+ * 15:8 - dot11mac/ucode
+ * 31:16 - unassigned (presumed to be with do11mac/ucode)
+ */
+#define ECI_WL_BITS         0xffffff00
+#endif				/* !defined(BCMDONGLEHOST) */
+
+/* WLAN channel numbers - used from wifi.h */
+
+/* WLAN BW */
+#define BW_20   0x0
+#define BW_40   0x4
+
+/* WLAN - number of antenna */
+#define WLAN_NUM_ANT1 TXANT_0
+#define WLAN_NUM_ANT2 TXANT_1
+
+#endif				/* _SBCHIPC_H */
diff --git a/include/asm-mips/bcmsi/sbconfig.h b/include/asm-mips/bcmsi/sbconfig.h
new file mode 100644
index 0000000..bf3fdfc
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbconfig.h
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Broadcom SiliconBackplane hardware register definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_SBCONFIG_H
+#define	_SBCONFIG_H
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif
+
+/* enumeration in SB is based on the premise that cores are contiguos in the
+ * enumeration space.
+ */
+#define SB_BUS_SIZE		0x10000	/* Each bus gets 64Kbytes for cores */
+#define SB_BUS_BASE(b)		(SI_ENUM_BASE + (b) * SB_BUS_SIZE)
+#define	SB_BUS_MAXCORES		(SB_BUS_SIZE / SI_CORE_SIZE)	/* Max cores per bus */
+
+/*
+ * Sonics Configuration Space Registers.
+ */
+#define	SBCONFIGOFF		0xf00	/* core sbconfig regs are top 256bytes of regs */
+#define	SBCONFIGSIZE		256	/* sizeof (sbconfig_t) */
+
+#define SBIPSFLAG		0x08
+#define SBTPSFLAG		0x18
+#define	SBTMERRLOGA		0x48	/* sonics >= 2.3 */
+#define	SBTMERRLOG		0x50	/* sonics >= 2.3 */
+#define SBADMATCH3		0x60
+#define SBADMATCH2		0x68
+#define SBADMATCH1		0x70
+#define SBIMSTATE		0x90
+#define SBINTVEC		0x94
+#define SBTMSTATELOW		0x98
+#define SBTMSTATEHIGH		0x9c
+#define SBBWA0			0xa0
+#define SBIMCONFIGLOW		0xa8
+#define SBIMCONFIGHIGH		0xac
+#define SBADMATCH0		0xb0
+#define SBTMCONFIGLOW		0xb8
+#define SBTMCONFIGHIGH		0xbc
+#define SBBCONFIG		0xc0
+#define SBBSTATE		0xc8
+#define SBACTCNFG		0xd8
+#define	SBFLAGST		0xe8
+#define SBIDLOW			0xf8
+#define SBIDHIGH		0xfc
+
+/* All the previous registers are above SBCONFIGOFF, but with Sonics 2.3, we have
+ * a few registers *below* that line. I think it would be very confusing to try
+ * and change the value of SBCONFIGOFF, so I'm definig them as absolute offsets here,
+ */
+
+#define SBIMERRLOGA		0xea8
+#define SBIMERRLOG		0xeb0
+#define SBTMPORTCONNID0		0xed8
+#define SBTMPORTLOCK0		0xef8
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+typedef volatile struct _sbconfig {
+    uint32 PAD[2];
+    uint32 sbipsflag;		/* initiator port ocp slave flag */
+    uint32 PAD[3];
+    uint32 sbtpsflag;		/* target port ocp slave flag */
+    uint32 PAD[11];
+    uint32 sbtmerrloga;		/* (sonics >= 2.3) */
+    uint32 PAD;
+    uint32 sbtmerrlog;		/* (sonics >= 2.3) */
+    uint32 PAD[3];
+    uint32 sbadmatch3;		/* address match3 */
+    uint32 PAD;
+    uint32 sbadmatch2;		/* address match2 */
+    uint32 PAD;
+    uint32 sbadmatch1;		/* address match1 */
+    uint32 PAD[7];
+    uint32 sbimstate;		/* initiator agent state */
+    uint32 sbintvec;		/* interrupt mask */
+    uint32 sbtmstatelow;	/* target state */
+    uint32 sbtmstatehigh;	/* target state */
+    uint32 sbbwa0;		/* bandwidth allocation table0 */
+    uint32 PAD;
+    uint32 sbimconfiglow;	/* initiator configuration */
+    uint32 sbimconfighigh;	/* initiator configuration */
+    uint32 sbadmatch0;		/* address match0 */
+    uint32 PAD;
+    uint32 sbtmconfiglow;	/* target configuration */
+    uint32 sbtmconfighigh;	/* target configuration */
+    uint32 sbbconfig;		/* broadcast configuration */
+    uint32 PAD;
+    uint32 sbbstate;		/* broadcast state */
+    uint32 PAD[3];
+    uint32 sbactcnfg;		/* activate configuration */
+    uint32 PAD[3];
+    uint32 sbflagst;		/* current sbflags */
+    uint32 PAD[3];
+    uint32 sbidlow;		/* identification */
+    uint32 sbidhigh;		/* identification */
+} sbconfig_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* sbipsflag */
+#define	SBIPS_INT1_MASK		0x3f	/* which sbflags get routed to mips interrupt 1 */
+#define	SBIPS_INT1_SHIFT	0
+#define	SBIPS_INT2_MASK		0x3f00	/* which sbflags get routed to mips interrupt 2 */
+#define	SBIPS_INT2_SHIFT	8
+#define	SBIPS_INT3_MASK		0x3f0000	/* which sbflags get routed to mips interrupt 3 */
+#define	SBIPS_INT3_SHIFT	16
+#define	SBIPS_INT4_MASK		0x3f000000	/* which sbflags get routed to mips interrupt 4 */
+#define	SBIPS_INT4_SHIFT	24
+
+/* sbtpsflag */
+#define	SBTPS_NUM0_MASK		0x3f	/* interrupt sbFlag # generated by this core */
+#define	SBTPS_F0EN0		0x40	/* interrupt is always sent on the backplane */
+
+/* sbtmerrlog */
+#define	SBTMEL_CM		0x00000007	/* command */
+#define	SBTMEL_CI		0x0000ff00	/* connection id */
+#define	SBTMEL_EC		0x0f000000	/* error code */
+#define	SBTMEL_ME		0x80000000	/* multiple error */
+
+/* sbimstate */
+#define	SBIM_PC			0xf	/* pipecount */
+#define	SBIM_AP_MASK		0x30	/* arbitration policy */
+#define	SBIM_AP_BOTH		0x00	/* use both timeslaces and token */
+#define	SBIM_AP_TS		0x10	/* use timesliaces only */
+#define	SBIM_AP_TK		0x20	/* use token only */
+#define	SBIM_AP_RSV		0x30	/* reserved */
+#define	SBIM_IBE		0x20000	/* inbanderror */
+#define	SBIM_TO			0x40000	/* timeout */
+#define	SBIM_BY			0x01800000	/* busy (sonics >= 2.3) */
+#define	SBIM_RJ			0x02000000	/* reject (sonics >= 2.3) */
+
+/* sbtmstatelow */
+#define	SBTML_RESET		0x0001	/* reset */
+#define	SBTML_REJ_MASK		0x0006	/* reject field */
+#define	SBTML_REJ		0x0002	/* reject */
+#define	SBTML_TMPREJ		0x0004	/* temporary reject, for error recovery */
+
+#define	SBTML_SICF_SHIFT	16	/* Shift to locate the SI control flags in sbtml */
+
+/* sbtmstatehigh */
+#define	SBTMH_SERR		0x0001	/* serror */
+#define	SBTMH_INT		0x0002	/* interrupt */
+#define	SBTMH_BUSY		0x0004	/* busy */
+#define	SBTMH_TO		0x0020	/* timeout (sonics >= 2.3) */
+
+#define	SBTMH_SISF_SHIFT	16	/* Shift to locate the SI status flags in sbtmh */
+
+/* sbbwa0 */
+#define	SBBWA_TAB0_MASK		0xffff	/* lookup table 0 */
+#define	SBBWA_TAB1_MASK		0xffff	/* lookup table 1 */
+#define	SBBWA_TAB1_SHIFT	16
+
+/* sbimconfiglow */
+#define	SBIMCL_STO_MASK		0x7	/* service timeout */
+#define	SBIMCL_RTO_MASK		0x70	/* request timeout */
+#define	SBIMCL_RTO_SHIFT	4
+#define	SBIMCL_CID_MASK		0xff0000	/* connection id */
+#define	SBIMCL_CID_SHIFT	16
+
+/* sbimconfighigh */
+#define	SBIMCH_IEM_MASK		0xc	/* inband error mode */
+#define	SBIMCH_TEM_MASK		0x30	/* timeout error mode */
+#define	SBIMCH_TEM_SHIFT	4
+#define	SBIMCH_BEM_MASK		0xc0	/* bus error mode */
+#define	SBIMCH_BEM_SHIFT	6
+
+/* sbadmatch0 */
+#define	SBAM_TYPE_MASK		0x3	/* address type */
+#define	SBAM_AD64		0x4	/* reserved */
+#define	SBAM_ADINT0_MASK	0xf8	/* type0 size */
+#define	SBAM_ADINT0_SHIFT	3
+#define	SBAM_ADINT1_MASK	0x1f8	/* type1 size */
+#define	SBAM_ADINT1_SHIFT	3
+#define	SBAM_ADINT2_MASK	0x1f8	/* type2 size */
+#define	SBAM_ADINT2_SHIFT	3
+#define	SBAM_ADEN		0x400	/* enable */
+#define	SBAM_ADNEG		0x800	/* negative decode */
+#define	SBAM_BASE0_MASK		0xffffff00	/* type0 base address */
+#define	SBAM_BASE0_SHIFT	8
+#define	SBAM_BASE1_MASK		0xfffff000	/* type1 base address for the core */
+#define	SBAM_BASE1_SHIFT	12
+#define	SBAM_BASE2_MASK		0xffff0000	/* type2 base address for the core */
+#define	SBAM_BASE2_SHIFT	16
+
+/* sbtmconfiglow */
+#define	SBTMCL_CD_MASK		0xff	/* clock divide */
+#define	SBTMCL_CO_MASK		0xf800	/* clock offset */
+#define	SBTMCL_CO_SHIFT		11
+#define	SBTMCL_IF_MASK		0xfc0000	/* interrupt flags */
+#define	SBTMCL_IF_SHIFT		18
+#define	SBTMCL_IM_MASK		0x3000000	/* interrupt mode */
+#define	SBTMCL_IM_SHIFT		24
+
+/* sbtmconfighigh */
+#define	SBTMCH_BM_MASK		0x3	/* busy mode */
+#define	SBTMCH_RM_MASK		0x3	/* retry mode */
+#define	SBTMCH_RM_SHIFT		2
+#define	SBTMCH_SM_MASK		0x30	/* stop mode */
+#define	SBTMCH_SM_SHIFT		4
+#define	SBTMCH_EM_MASK		0x300	/* sb error mode */
+#define	SBTMCH_EM_SHIFT		8
+#define	SBTMCH_IM_MASK		0xc00	/* int mode */
+#define	SBTMCH_IM_SHIFT		10
+
+/* sbbconfig */
+#define	SBBC_LAT_MASK		0x3	/* sb latency */
+#define	SBBC_MAX0_MASK		0xf0000	/* maxccntr0 */
+#define	SBBC_MAX0_SHIFT		16
+#define	SBBC_MAX1_MASK		0xf00000	/* maxccntr1 */
+#define	SBBC_MAX1_SHIFT		20
+
+/* sbbstate */
+#define	SBBS_SRD		0x1	/* st reg disable */
+#define	SBBS_HRD		0x2	/* hold reg disable */
+
+/* sbidlow */
+#define	SBIDL_CS_MASK		0x3	/* config space */
+#define	SBIDL_AR_MASK		0x38	/* # address ranges supported */
+#define	SBIDL_AR_SHIFT		3
+#define	SBIDL_SYNCH		0x40	/* sync */
+#define	SBIDL_INIT		0x80	/* initiator */
+#define	SBIDL_MINLAT_MASK	0xf00	/* minimum backplane latency */
+#define	SBIDL_MINLAT_SHIFT	8
+#define	SBIDL_MAXLAT		0xf000	/* maximum backplane latency */
+#define	SBIDL_MAXLAT_SHIFT	12
+#define	SBIDL_FIRST		0x10000	/* this initiator is first */
+#define	SBIDL_CW_MASK		0xc0000	/* cycle counter width */
+#define	SBIDL_CW_SHIFT		18
+#define	SBIDL_TP_MASK		0xf00000	/* target ports */
+#define	SBIDL_TP_SHIFT		20
+#define	SBIDL_IP_MASK		0xf000000	/* initiator ports */
+#define	SBIDL_IP_SHIFT		24
+#define	SBIDL_RV_MASK		0xf0000000	/* sonics backplane revision code */
+#define	SBIDL_RV_SHIFT		28
+#define	SBIDL_RV_2_2		0x00000000	/* version 2.2 or earlier */
+#define	SBIDL_RV_2_3		0x10000000	/* version 2.3 */
+
+/* sbidhigh */
+#define	SBIDH_RC_MASK		0x000f	/* revision code */
+#define	SBIDH_RCE_MASK		0x7000	/* revision code extension field */
+#define	SBIDH_RCE_SHIFT		8
+#define	SBCOREREV(sbidh) \
+	((((sbidh) & SBIDH_RCE_MASK) >> SBIDH_RCE_SHIFT) | ((sbidh) & SBIDH_RC_MASK))
+#define	SBIDH_CC_MASK		0x8ff0	/* core code */
+#define	SBIDH_CC_SHIFT		4
+#define	SBIDH_VC_MASK		0xffff0000	/* vendor code */
+#define	SBIDH_VC_SHIFT		16
+
+#define	SB_COMMIT		0xfd8	/* update buffered registers value */
+
+/* vendor codes */
+#define	SB_VEND_BCM		0x4243	/* Broadcom's SB vendor code */
+
+#endif				/* _SBCONFIG_H */
diff --git a/include/asm-mips/bcmsi/sbhnddma.h b/include/asm-mips/bcmsi/sbhnddma.h
new file mode 100644
index 0000000..13999ad
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbhnddma.h
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Generic Broadcom Home Networking Division (HND) DMA engine HW interface
+ * This supports the following chips: BCM42xx, 44xx, 47xx .
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_sbhnddma_h_
+#define	_sbhnddma_h_
+
+/* DMA structure:
+ *  support two DMA engines: 32 bits address or 64 bit addressing
+ *  basic DMA register set is per channel(transmit or receive)
+ *  a pair of channels is defined for convenience
+ */
+
+
+/* 32 bits addressing */
+
+/* dma registers per channel(xmt or rcv) */
+typedef volatile struct {
+    uint32 control;		/* enable, et al */
+    uint32 addr;		/* descriptor ring base address (4K aligned) */
+    uint32 ptr;			/* last descriptor posted to chip */
+    uint32 status;		/* current active descriptor, et al */
+} dma32regs_t;
+
+typedef volatile struct {
+    dma32regs_t xmt;		/* dma tx channel */
+    dma32regs_t rcv;		/* dma rx channel */
+} dma32regp_t;
+
+typedef volatile struct {	/* diag access */
+    uint32 fifoaddr;		/* diag address */
+    uint32 fifodatalow;		/* low 32bits of data */
+    uint32 fifodatahigh;	/* high 32bits of data */
+    uint32 pad;			/* reserved */
+} dma32diag_t;
+
+/*
+ * DMA Descriptor
+ * Descriptors are only read by the hardware, never written back.
+ */
+typedef volatile struct {
+    uint32 ctrl;		/* misc control bits & bufcount */
+    uint32 addr;		/* data buffer address */
+} dma32dd_t;
+
+/*
+ * Each descriptor ring must be 4096byte aligned, and fit within a single 4096byte page.
+ */
+#define	D32MAXRINGSZ	4096
+#define	D32RINGALIGN	4096
+#define	D32MAXDD	(D32MAXRINGSZ / sizeof (dma32dd_t))
+
+/* transmit channel control */
+#define	XC_XE		((uint32)1 << 0)	/* transmit enable */
+#define	XC_SE		((uint32)1 << 1)	/* transmit suspend request */
+#define	XC_LE		((uint32)1 << 2)	/* loopback enable */
+#define	XC_FL		((uint32)1 << 4)	/* flush request */
+#define	XC_PD		((uint32)1 << 11)	/* parity check disable */
+#define	XC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	XC_AE_SHIFT	16
+
+/* transmit descriptor table pointer */
+#define	XP_LD_MASK	0xfff	/* last valid descriptor */
+
+/* transmit channel status */
+#define	XS_CD_MASK	0x0fff	/* current descriptor pointer */
+#define	XS_XS_MASK	0xf000	/* transmit state */
+#define	XS_XS_SHIFT	12
+#define	XS_XS_DISABLED	0x0000	/* disabled */
+#define	XS_XS_ACTIVE	0x1000	/* active */
+#define	XS_XS_IDLE	0x2000	/* idle wait */
+#define	XS_XS_STOPPED	0x3000	/* stopped */
+#define	XS_XS_SUSP	0x4000	/* suspend pending */
+#define	XS_XE_MASK	0xf0000	/* transmit errors */
+#define	XS_XE_SHIFT	16
+#define	XS_XE_NOERR	0x00000	/* no error */
+#define	XS_XE_DPE	0x10000	/* descriptor protocol error */
+#define	XS_XE_DFU	0x20000	/* data fifo underrun */
+#define	XS_XE_BEBR	0x30000	/* bus error on buffer read */
+#define	XS_XE_BEDA	0x40000	/* bus error on descriptor access */
+#define	XS_AD_MASK	0xfff00000	/* active descriptor */
+#define	XS_AD_SHIFT	20
+
+/* receive channel control */
+#define	RC_RE		((uint32)1 << 0)	/* receive enable */
+#define	RC_RO_MASK	0xfe	/* receive frame offset */
+#define	RC_RO_SHIFT	1
+#define	RC_FM		((uint32)1 << 8)	/* direct fifo receive (pio) mode */
+#define	RC_SH		((uint32)1 << 9)	/* separate rx header descriptor enable */
+#define	RC_OC		((uint32)1 << 10)	/* overflow continue */
+#define	RC_PD		((uint32)1 << 11)	/* parity check disable */
+#define	RC_AE		((uint32)3 << 16)	/* address extension bits */
+#define	RC_AE_SHIFT	16
+
+/* receive descriptor table pointer */
+#define	RP_LD_MASK	0xfff	/* last valid descriptor */
+
+/* receive channel status */
+#define	RS_CD_MASK	0x0fff	/* current descriptor pointer */
+#define	RS_RS_MASK	0xf000	/* receive state */
+#define	RS_RS_SHIFT	12
+#define	RS_RS_DISABLED	0x0000	/* disabled */
+#define	RS_RS_ACTIVE	0x1000	/* active */
+#define	RS_RS_IDLE	0x2000	/* idle wait */
+#define	RS_RS_STOPPED	0x3000	/* reserved */
+#define	RS_RE_MASK	0xf0000	/* receive errors */
+#define	RS_RE_SHIFT	16
+#define	RS_RE_NOERR	0x00000	/* no error */
+#define	RS_RE_DPE	0x10000	/* descriptor protocol error */
+#define	RS_RE_DFO	0x20000	/* data fifo overflow */
+#define	RS_RE_BEBW	0x30000	/* bus error on buffer write */
+#define	RS_RE_BEDA	0x40000	/* bus error on descriptor access */
+#define	RS_AD_MASK	0xfff00000	/* active descriptor */
+#define	RS_AD_SHIFT	20
+
+/* fifoaddr */
+#define	FA_OFF_MASK	0xffff	/* offset */
+#define	FA_SEL_MASK	0xf0000	/* select */
+#define	FA_SEL_SHIFT	16
+#define	FA_SEL_XDD	0x00000	/* transmit dma data */
+#define	FA_SEL_XDP	0x10000	/* transmit dma pointers */
+#define	FA_SEL_RDD	0x40000	/* receive dma data */
+#define	FA_SEL_RDP	0x50000	/* receive dma pointers */
+#define	FA_SEL_XFD	0x80000	/* transmit fifo data */
+#define	FA_SEL_XFP	0x90000	/* transmit fifo pointers */
+#define	FA_SEL_RFD	0xc0000	/* receive fifo data */
+#define	FA_SEL_RFP	0xd0000	/* receive fifo pointers */
+#define	FA_SEL_RSD	0xe0000	/* receive frame status data */
+#define	FA_SEL_RSP	0xf0000	/* receive frame status pointers */
+
+/* descriptor control flags */
+#define	CTRL_BC_MASK	0x1fff	/* buffer byte count */
+#define	CTRL_AE		((uint32)3 << 16)	/* address extension bits */
+#define	CTRL_AE_SHIFT	16
+#define	CTRL_EOT	((uint32)1 << 28)	/* end of descriptor table */
+#define	CTRL_IOC	((uint32)1 << 29)	/* interrupt on completion */
+#define	CTRL_EOF	((uint32)1 << 30)	/* end of frame */
+#define	CTRL_SOF	((uint32)1 << 31)	/* start of frame */
+
+/* control flags in the range [27:20] are core-specific and not defined here */
+#define	CTRL_CORE_MASK	0x0ff00000
+
+/* 64 bits addressing */
+
+/* dma registers per channel(xmt or rcv) */
+typedef volatile struct {
+    uint32 control;		/* enable, et al */
+    uint32 ptr;			/* last descriptor posted to chip */
+    uint32 addrlow;		/* descriptor ring base address low 32-bits (8K aligned) */
+    uint32 addrhigh;		/* descriptor ring base address bits 63:32 (8K aligned) */
+    uint32 status0;		/* current descriptor, xmt state */
+    uint32 status1;		/* active descriptor, xmt error */
+} dma64regs_t;
+
+typedef volatile struct {
+    dma64regs_t tx;		/* dma64 tx channel */
+    dma64regs_t rx;		/* dma64 rx channel */
+} dma64regp_t;
+
+typedef volatile struct {	/* diag access */
+    uint32 fifoaddr;		/* diag address */
+    uint32 fifodatalow;		/* low 32bits of data */
+    uint32 fifodatahigh;	/* high 32bits of data */
+    uint32 pad;			/* reserved */
+} dma64diag_t;
+
+/*
+ * DMA Descriptor
+ * Descriptors are only read by the hardware, never written back.
+ */
+typedef volatile struct {
+    uint32 ctrl1;		/* misc control bits & bufcount */
+    uint32 ctrl2;		/* buffer count and address extension */
+    uint32 addrlow;		/* memory address of the date buffer, bits 31:0 */
+    uint32 addrhigh;		/* memory address of the date buffer, bits 63:32 */
+} dma64dd_t;
+
+/*
+ * Each descriptor ring must be 8kB aligned, and fit within a contiguous 8kB physical addresss.
+ */
+#define	D64MAXRINGSZ	8192
+#define	D64RINGALIGN	8192
+#define	D64MAXDD	(D64MAXRINGSZ / sizeof (dma64dd_t))
+
+/* transmit channel control */
+#define	D64_XC_XE		0x00000001	/* transmit enable */
+#define	D64_XC_SE		0x00000002	/* transmit suspend request */
+#define	D64_XC_LE		0x00000004	/* loopback enable */
+#define	D64_XC_FL		0x00000010	/* flush request */
+#define	D64_XC_PD		0x00000800	/* parity check disable */
+#define	D64_XC_AE		0x00030000	/* address extension bits */
+#define	D64_XC_AE_SHIFT		16
+
+/* transmit descriptor table pointer */
+#define	D64_XP_LD_MASK		0x00000fff	/* last valid descriptor */
+
+/* transmit channel status */
+#define	D64_XS0_CD_MASK		0x00001fff	/* current descriptor pointer */
+#define	D64_XS0_XS_MASK		0xf0000000	/* transmit state */
+#define	D64_XS0_XS_SHIFT		28
+#define	D64_XS0_XS_DISABLED	0x00000000	/* disabled */
+#define	D64_XS0_XS_ACTIVE	0x10000000	/* active */
+#define	D64_XS0_XS_IDLE		0x20000000	/* idle wait */
+#define	D64_XS0_XS_STOPPED	0x30000000	/* stopped */
+#define	D64_XS0_XS_SUSP		0x40000000	/* suspend pending */
+
+#define	D64_XS1_AD_MASK		0x0001ffff	/* active descriptor */
+#define	D64_XS1_XE_MASK		0xf0000000	/* transmit errors */
+#define	D64_XS1_XE_SHIFT		28
+#define	D64_XS1_XE_NOERR	0x00000000	/* no error */
+#define	D64_XS1_XE_DPE		0x10000000	/* descriptor protocol error */
+#define	D64_XS1_XE_DFU		0x20000000	/* data fifo underrun */
+#define	D64_XS1_XE_DTE		0x30000000	/* data transfer error */
+#define	D64_XS1_XE_DESRE	0x40000000	/* descriptor read error */
+#define	D64_XS1_XE_COREE	0x50000000	/* core error */
+
+/* receive channel control */
+#define	D64_RC_RE		0x00000001	/* receive enable */
+#define	D64_RC_RO_MASK		0x000000fe	/* receive frame offset */
+#define	D64_RC_RO_SHIFT		1
+#define	D64_RC_FM		0x00000100	/* direct fifo receive (pio) mode */
+#define	D64_RC_SH		0x00000200	/* separate rx header descriptor enable */
+#define	D64_RC_OC		0x00000400	/* overflow continue */
+#define	D64_RC_PD		0x00000800	/* parity check disable */
+#define	D64_RC_AE		0x00030000	/* address extension bits */
+#define	D64_RC_AE_SHIFT		16
+
+/* receive descriptor table pointer */
+#define	D64_RP_LD_MASK		0x00000fff	/* last valid descriptor */
+
+/* receive channel status */
+#define	D64_RS0_CD_MASK		0x00001fff	/* current descriptor pointer */
+#define	D64_RS0_RS_MASK		0xf0000000	/* receive state */
+#define	D64_RS0_RS_SHIFT		28
+#define	D64_RS0_RS_DISABLED	0x00000000	/* disabled */
+#define	D64_RS0_RS_ACTIVE	0x10000000	/* active */
+#define	D64_RS0_RS_IDLE		0x20000000	/* idle wait */
+#define	D64_RS0_RS_STOPPED	0x30000000	/* stopped */
+#define	D64_RS0_RS_SUSP		0x40000000	/* suspend pending */
+
+#define	D64_RS1_AD_MASK		0x0001ffff	/* active descriptor */
+#define	D64_RS1_RE_MASK		0xf0000000	/* receive errors */
+#define	D64_RS1_RE_SHIFT		28
+#define	D64_RS1_RE_NOERR	0x00000000	/* no error */
+#define	D64_RS1_RE_DPO		0x10000000	/* descriptor protocol error */
+#define	D64_RS1_RE_DFU		0x20000000	/* data fifo overflow */
+#define	D64_RS1_RE_DTE		0x30000000	/* data transfer error */
+#define	D64_RS1_RE_DESRE	0x40000000	/* descriptor read error */
+#define	D64_RS1_RE_COREE	0x50000000	/* core error */
+
+/* fifoaddr */
+#define	D64_FA_OFF_MASK		0xffff	/* offset */
+#define	D64_FA_SEL_MASK		0xf0000	/* select */
+#define	D64_FA_SEL_SHIFT	16
+#define	D64_FA_SEL_XDD		0x00000	/* transmit dma data */
+#define	D64_FA_SEL_XDP		0x10000	/* transmit dma pointers */
+#define	D64_FA_SEL_RDD		0x40000	/* receive dma data */
+#define	D64_FA_SEL_RDP		0x50000	/* receive dma pointers */
+#define	D64_FA_SEL_XFD		0x80000	/* transmit fifo data */
+#define	D64_FA_SEL_XFP		0x90000	/* transmit fifo pointers */
+#define	D64_FA_SEL_RFD		0xc0000	/* receive fifo data */
+#define	D64_FA_SEL_RFP		0xd0000	/* receive fifo pointers */
+#define	D64_FA_SEL_RSD		0xe0000	/* receive frame status data */
+#define	D64_FA_SEL_RSP		0xf0000	/* receive frame status pointers */
+
+/* descriptor control flags 1 */
+#define	D64_CTRL1_TS		((uint32)1 << 27)	/* tx time stamp */
+#define	D64_CTRL1_EOT		((uint32)1 << 28)	/* end of descriptor table */
+#define	D64_CTRL1_IOC		((uint32)1 << 29)	/* interrupt on completion */
+#define	D64_CTRL1_EOF		((uint32)1 << 30)	/* end of frame */
+#define	D64_CTRL1_SOF		((uint32)1 << 31)	/* start of frame */
+
+/* descriptor control flags 2 */
+#define	D64_CTRL2_BC_MASK	0x00007fff	/* buffer byte count mask */
+#define	D64_CTRL2_AE		0x00030000	/* address extension bits */
+#define	D64_CTRL2_AE_SHIFT	16
+
+/* control flags in the range [27:20] are core-specific and not defined here */
+#define	D64_CTRL_CORE_MASK	0x0ff00000
+
+
+#endif				/* _sbhnddma_h_ */
diff --git a/include/asm-mips/bcmsi/sbmemc.h b/include/asm-mips/bcmsi/sbmemc.h
new file mode 100644
index 0000000..080180f
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbmemc.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * BCM47XX Sonics SiliconBackplane DDR/SDRAM controller core hardware definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_SBMEMC_H
+#define	_SBMEMC_H
+
+#ifdef _LANGUAGE_ASSEMBLY
+
+#define	MEMC_CONTROL		0x00
+#define	MEMC_CONFIG		0x04
+#define	MEMC_REFRESH		0x08
+#define	MEMC_BISTSTAT		0x0c
+#define	MEMC_MODEBUF		0x10
+#define	MEMC_BKCLS		0x14
+#define	MEMC_PRIORINV		0x18
+#define	MEMC_DRAMTIM		0x1c
+#define	MEMC_INTSTAT		0x20
+#define	MEMC_INTMASK		0x24
+#define	MEMC_INTINFO		0x28
+#define	MEMC_NCDLCTL		0x30
+#define	MEMC_RDNCDLCOR		0x34
+#define	MEMC_WRNCDLCOR		0x38
+#define	MEMC_MISCDLYCTL		0x3c
+#define	MEMC_DQSGATENCDL	0x40
+#define	MEMC_SPARE		0x44
+#define	MEMC_TPADDR		0x48
+#define	MEMC_TPDATA		0x4c
+#define	MEMC_BARRIER		0x50
+#define	MEMC_CORE		0x54
+
+#else				/* !_LANGUAGE_ASSEMBLY */
+
+/* Sonics side: MEMC core registers */
+typedef volatile struct sbmemcregs {
+    uint32 control;
+    uint32 config;
+    uint32 refresh;
+    uint32 biststat;
+    uint32 modebuf;
+    uint32 bkcls;
+    uint32 priorinv;
+    uint32 dramtim;
+    uint32 intstat;
+    uint32 intmask;
+    uint32 intinfo;
+    uint32 reserved1;
+    uint32 ncdlctl;
+    uint32 rdncdlcor;
+    uint32 wrncdlcor;
+    uint32 miscdlyctl;
+    uint32 dqsgatencdl;
+    uint32 spare;
+    uint32 tpaddr;
+    uint32 tpdata;
+    uint32 barrier;
+    uint32 core;
+} sbmemcregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* MEMC Core Init values (OCP ID 0x80f) */
+
+/* For sdr: */
+#define MEMC_SD_CONFIG_INIT	0x00048000
+#define MEMC_SD_DRAMTIM2_INIT	0x000754d8
+#define MEMC_SD_DRAMTIM3_INIT	0x000754da
+#define MEMC_SD_RDNCDLCOR_INIT	0x00000000
+#define MEMC_SD_WRNCDLCOR_INIT	0x49351200
+#define MEMC_SD1_WRNCDLCOR_INIT	0x14500200	/* For corerev 1 (4712) */
+#define MEMC_SD_MISCDLYCTL_INIT	0x00061c1b
+#define MEMC_SD1_MISCDLYCTL_INIT 0x00021416	/* For corerev 1 (4712) */
+#define MEMC_SD_CONTROL_INIT0	0x00000002
+#define MEMC_SD_CONTROL_INIT1	0x00000008
+#define MEMC_SD_CONTROL_INIT2	0x00000004
+#define MEMC_SD_CONTROL_INIT3	0x00000010
+#define MEMC_SD_CONTROL_INIT4	0x00000001
+#define MEMC_SD_MODEBUF_INIT	0x00000000
+#define MEMC_SD_REFRESH_INIT	0x0000840f
+
+
+/* This is for SDRM8X8X4 */
+#define	MEMC_SDR_INIT		0x0008
+#define	MEMC_SDR_MODE		0x32
+#define	MEMC_SDR_NCDL		0x00020032
+#define	MEMC_SDR1_NCDL		0x0002020f	/* For corerev 1 (4712) */
+
+/* For ddr: */
+#define MEMC_CONFIG_INIT	0x00048000
+#define MEMC_DRAMTIM2_INIT	0x000754d8
+#define MEMC_DRAMTIM25_INIT	0x000754d9
+#define MEMC_RDNCDLCOR_INIT	0x00000000
+#define MEMC_RDNCDLCOR_SIMINIT	0xf6f6f6f6	/* For hdl sim */
+#define MEMC_WRNCDLCOR_INIT	0x49351200
+#define MEMC_1_WRNCDLCOR_INIT	0x14500200
+#define MEMC_DQSGATENCDL_INIT	0x00030000
+#define MEMC_MISCDLYCTL_INIT	0x21061c1b
+#define MEMC_1_MISCDLYCTL_INIT	0x21021400
+#define MEMC_NCDLCTL_INIT	0x00002001
+#define MEMC_CONTROL_INIT0	0x00000002
+#define MEMC_CONTROL_INIT1	0x00000008
+#define MEMC_MODEBUF_INIT0	0x00004000
+#define MEMC_CONTROL_INIT2	0x00000010
+#define MEMC_MODEBUF_INIT1	0x00000100
+#define MEMC_CONTROL_INIT3	0x00000010
+#define MEMC_CONTROL_INIT4	0x00000008
+#define MEMC_REFRESH_INIT	0x0000840f
+#define MEMC_CONTROL_INIT5	0x00000004
+#define MEMC_MODEBUF_INIT2	0x00000000
+#define MEMC_CONTROL_INIT6	0x00000010
+#define MEMC_CONTROL_INIT7	0x00000001
+
+
+/* This is for DDRM16X16X2 */
+#define	MEMC_DDR_INIT		0x0009
+#define	MEMC_DDR_MODE		0x62
+#define	MEMC_DDR_NCDL		0x0005050a
+#define	MEMC_DDR1_NCDL		0x00000a0a	/* For corerev 1 (4712) */
+
+/* mask for sdr/ddr calibration registers */
+#define MEMC_RDNCDLCOR_RD_MASK	0x000000ff
+#define MEMC_WRNCDLCOR_WR_MASK	0x000000ff
+#define MEMC_DQSGATENCDL_G_MASK	0x000000ff
+
+/* masks for miscdlyctl registers */
+#define MEMC_MISC_SM_MASK	0x30000000
+#define MEMC_MISC_SM_SHIFT	28
+#define MEMC_MISC_SD_MASK	0x0f000000
+#define MEMC_MISC_SD_SHIFT	24
+
+/* hw threshhold for calculating wr/rd for sdr memc */
+#define MEMC_CD_THRESHOLD	128
+
+/* Low bit of init register says if memc is ddr or sdr */
+#define MEMC_CONFIG_DDR		0x00000001
+
+#endif				/* _SBMEMC_H */
diff --git a/include/asm-mips/bcmsi/sbpcmcia.h b/include/asm-mips/bcmsi/sbpcmcia.h
new file mode 100644
index 0000000..69c1ab3
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbpcmcia.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * BCM43XX Sonics SiliconBackplane PCMCIA core hardware definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_SBPCMCIA_H
+#define	_SBPCMCIA_H
+
+
+/* All the addresses that are offsets in attribute space are divided
+ * by two to account for the fact that odd bytes are invalid in
+ * attribute space and our read/write routines make the space appear
+ * as if they didn't exist. Still we want to show the original numbers
+ * as documented in the hnd_pcmcia core manual.
+ */
+
+/* PCMCIA Function Configuration Registers */
+#define	PCMCIA_FCR		(0x700 / 2)
+
+#define	FCR0_OFF		0
+#define	FCR1_OFF		(0x40 / 2)
+#define	FCR2_OFF		(0x80 / 2)
+#define	FCR3_OFF		(0xc0 / 2)
+
+#define	PCMCIA_FCR0		(0x700 / 2)
+#define	PCMCIA_FCR1		(0x740 / 2)
+#define	PCMCIA_FCR2		(0x780 / 2)
+#define	PCMCIA_FCR3		(0x7c0 / 2)
+
+/* Standard PCMCIA FCR registers */
+
+#define	PCMCIA_COR		0
+
+#define	COR_RST			0x80
+#define	COR_LEV			0x40
+#define	COR_IRQEN		0x04
+#define	COR_BLREN		0x01
+#define	COR_FUNEN		0x01
+
+
+#define	PCICIA_FCSR		(2 / 2)
+#define	PCICIA_PRR		(4 / 2)
+#define	PCICIA_SCR		(6 / 2)
+#define	PCICIA_ESR		(8 / 2)
+
+
+#define PCM_MEMOFF		0x0000
+#define F0_MEMOFF		0x1000
+#define F1_MEMOFF		0x2000
+#define F2_MEMOFF		0x3000
+#define F3_MEMOFF		0x4000
+
+/* Memory base in the function fcr's */
+#define MEM_ADDR0		(0x728 / 2)
+#define MEM_ADDR1		(0x72a / 2)
+#define MEM_ADDR2		(0x72c / 2)
+
+/* PCMCIA base plus Srom access in fcr0: */
+#define PCMCIA_ADDR0		(0x072e / 2)
+#define PCMCIA_ADDR1		(0x0730 / 2)
+#define PCMCIA_ADDR2		(0x0732 / 2)
+
+#define MEM_SEG			(0x0734 / 2)
+#define SROM_CS			(0x0736 / 2)
+#define SROM_DATAL		(0x0738 / 2)
+#define SROM_DATAH		(0x073a / 2)
+#define SROM_ADDRL		(0x073c / 2)
+#define SROM_ADDRH		(0x073e / 2)
+#define	SROM_INFO2		(0x0772 / 2)	/* Corerev >= 2 && <= 5 */
+#define	SROM_INFO		(0x07be / 2)	/* Corerev >= 6 */
+
+/*  Values for srom_cs: */
+#define SROM_IDLE		0
+#define SROM_WRITE		1
+#define SROM_READ		2
+#define SROM_WEN		4
+#define SROM_WDS		7
+#define SROM_DONE		8
+
+/* Fields in srom_info: */
+#define	SRI_SZ_MASK		0x03
+#define	SRI_BLANK		0x04
+#define	SRI_OTP			0x80
+
+/* CIS stuff */
+
+/* The CIS stops where the FCRs start */
+#define	CIS_SIZE		PCMCIA_FCR
+
+/* CIS tuple length field max */
+#define CIS_TUPLE_LEN_MAX	0xff
+
+/* Standard tuples we know about */
+
+#define	CISTPL_VERS_1		0x15	/* CIS ver, manf, dev & ver strings */
+#define	CISTPL_MANFID		0x20	/* Manufacturer and device id */
+#define CISTPL_FUNCID		0x21	/* Function identification */
+#define	CISTPL_FUNCE		0x22	/* Function extensions */
+#define	CISTPL_CFTABLE		0x1b	/* Config table entry */
+#define	CISTPL_END		0xff	/* End of the CIS tuple chain */
+
+/* Function identifier provides context for the function extentions tuple */
+
+#ifdef BCMSDIO
+#define CISTPL_FID_SDIO		0x0c	/* Extensions defined by SDIO spec */
+#endif				/* def BCMSDIO */
+
+/* Function extensions for LANs */
+
+#define	LAN_TECH		1	/* Technology type */
+#define	LAN_SPEED		2	/* Raw bit rate */
+#define	LAN_MEDIA		3	/* Transmission media */
+#define	LAN_NID			4	/* Node identification (aka MAC addr) */
+#define	LAN_CONN		5	/* Connector standard */
+
+
+/* CFTable */
+#define CFTABLE_REGWIN_2K	0x08	/* 2k reg windows size */
+#define CFTABLE_REGWIN_4K	0x10	/* 4k reg windows size */
+#define CFTABLE_REGWIN_8K	0x20	/* 8k reg windows size */
+
+/* Vendor unique tuples are 0x80-0x8f. Within Broadcom we'll
+ * take one for HNBU, and use "extensions" (a la FUNCE) within it.
+ */
+
+#define	CISTPL_BRCM_HNBU	0x80
+
+/* Subtypes of BRCM_HNBU: */
+
+#define HNBU_SROMREV		0x00	/* A byte with sromrev, 1 if not present */
+#define HNBU_CHIPID		0x01	/* Two 16bit values: PCI vendor & device id */
+#define HNBU_BOARDREV		0x02	/* One byte board revision */
+#define HNBU_PAPARMS		0x03	/* PA parameters: 8 (sromrev == 1)
+					 * or 9 (sromrev > 1) bytes
+					 */
+#define HNBU_OEM		0x04	/* Eight bytes OEM data (sromrev == 1) */
+#define HNBU_CC			0x05	/* Default country code (sromrev == 1) */
+#define	HNBU_AA			0x06	/* Antennas available */
+#define	HNBU_AG			0x07	/* Antenna gain */
+#define HNBU_BOARDFLAGS		0x08	/* board flags (2 or 4 bytes) */
+#define HNBU_LEDS		0x09	/* LED set */
+#define HNBU_CCODE		0x0a	/* Country code (2 bytes ascii + 1 byte cctl)
+					 * in rev 2
+					 */
+#define HNBU_CCKPO		0x0b	/* 2 byte cck power offsets in rev 3 */
+#define HNBU_OFDMPO		0x0c	/* 4 byte 11g ofdm power offsets in rev 3 */
+#define HNBU_GPIOTIMER		0x0d	/* 2 bytes with on/off values in rev 3 */
+#define HNBU_PAPARMS5G		0x0e	/* 5G PA params */
+#define HNBU_ANT5G		0x0f	/* 4328 5G antennas available/gain */
+#define HNBU_RDLID		0x10	/* 2 byte USB remote downloader (RDL) product Id */
+#define HNBU_RSSISMBXA2G	0x11	/* 4328 2G RSSI mid pt sel & board switch arch,
+					 * 2 bytes, rev 3.
+					 */
+#define HNBU_RSSISMBXA5G	0x12	/* 4328 5G RSSI mid pt sel & board switch arch,
+					 * 2 bytes, rev 3.
+					 */
+#define HNBU_XTALFREQ		0x13	/* 4 byte Crystal frequency in kilohertz */
+#define HNBU_TRI2G		0x14	/* 4328 2G TR isolation, 1 byte */
+#define HNBU_TRI5G		0x15	/* 4328 5G TR isolation, 3 bytes */
+#define HNBU_RXPO2G		0x16	/* 4328 2G RX power offset, 1 byte */
+#define HNBU_RXPO5G		0x17	/* 4328 5G RX power offset, 1 byte */
+#define HNBU_BOARDNUM	0x18	/* board serial number, independent of mac addr */
+#define HNBU_MACADDR	0x19	/* mac addr override for the standard CIS LAN_NID */
+#define HNBU_RDLSN		0x1a	/* 2 bytes; serial # advertised in USB descriptor */
+#define HNBU_BOARDTYPE		0x1b	/* 2 bytes; boardtype */
+#define HNBU_LEDDC		0x1c	/* 2 bytes; LED duty cycle */
+#define HNBU_RDLRNDIS		0x20	/* 1 byte; 1 = RDL advertises RNDIS config */
+#define HNBU_RDLRWU		0x30	/* 1 byte; 1 = RDL advertises Remote Wake-up */
+#define HNBU_USBFS		0x32	/* 1 byte; 1 = USB advertises FS mode only */
+#define HNBU_SROM3SWRGN		0x80	/* 78 bytes; srom rev 3 s/w region without crc8
+					 * plus extra info appended.
+					 */
+
+/* sbtmstatelow */
+#define SBTML_INT_ACK		0x40000	/* ack the sb interrupt */
+#define SBTML_INT_EN		0x20000	/* enable sb interrupt */
+
+/* sbtmstatehigh */
+#define SBTMH_INT_STATUS	0x40000	/* sb interrupt status */
+
+#endif				/* _SBPCMCIA_H */
diff --git a/include/asm-mips/bcmsi/sbsdram.h b/include/asm-mips/bcmsi/sbsdram.h
new file mode 100644
index 0000000..b890b44
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbsdram.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * BCM47XX Sonics SiliconBackplane SDRAM controller core hardware definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_SBSDRAM_H
+#define	_SBSDRAM_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* Sonics side: SDRAM core registers */
+typedef volatile struct sbsdramregs {
+    uint32 initcontrol;		/* Generates external SDRAM initialization sequence */
+    uint32 config;		/* Initializes external SDRAM mode register */
+    uint32 refresh;		/* Controls external SDRAM refresh rate */
+    uint32 pad1;
+    uint32 pad2;
+} sbsdramregs_t;
+
+#endif				/* !_LANGUAGE_ASSEMBLY */
+
+/* SDRAM initialization control (initcontrol) register bits */
+#define SDRAM_CBR	0x0001	/* Writing 1 generates refresh cycle and toggles bit */
+#define SDRAM_PRE	0x0002	/* Writing 1 generates precharge cycle and toggles bit */
+#define SDRAM_MRS	0x0004	/* Writing 1 generates mode register select cycle and toggles bit */
+#define SDRAM_EN	0x0008	/* When set, enables access to SDRAM */
+#define SDRAM_16Mb	0x0000	/* Use 16 Megabit SDRAM */
+#define SDRAM_64Mb	0x0010	/* Use 64 Megabit SDRAM */
+#define SDRAM_128Mb	0x0020	/* Use 128 Megabit SDRAM */
+#define SDRAM_RSVMb	0x0030	/* Use special SDRAM */
+#define SDRAM_RST	0x0080	/* Writing 1 causes soft reset of controller */
+#define SDRAM_SELFREF	0x0100	/* Writing 1 enables self refresh mode */
+#define SDRAM_PWRDOWN	0x0200	/* Writing 1 causes controller to power down */
+#define SDRAM_32BIT	0x0400	/* When set, indicates 32 bit SDRAM interface */
+#define SDRAM_9BITCOL	0x0800	/* When set, indicates 9 bit column */
+
+/* SDRAM configuration (config) register bits */
+#define SDRAM_BURSTFULL	0x0000	/* Use full page bursts */
+#define SDRAM_BURST8	0x0001	/* Use burst of 8 */
+#define SDRAM_BURST4	0x0002	/* Use burst of 4 */
+#define SDRAM_BURST2	0x0003	/* Use burst of 2 */
+#define SDRAM_CAS3	0x0000	/* Use CAS latency of 3 */
+#define SDRAM_CAS2	0x0004	/* Use CAS latency of 2 */
+
+/* SDRAM refresh control (refresh) register bits */
+#define SDRAM_REF(p)	(((p)&0xff) | SDRAM_REF_EN)	/* Refresh period */
+#define SDRAM_REF_EN	0x8000	/* Writing 1 enables periodic refresh */
+
+/* SDRAM Core default Init values (OCP ID 0x803) */
+#define SDRAM_INIT	MEM4MX16X2
+#define SDRAM_CONFIG    SDRAM_BURSTFULL
+#define SDRAM_REFRESH   SDRAM_REF(0x40)
+
+#define MEM1MX16	0x009	/* 2 MB */
+#define MEM1MX16X2	0x409	/* 4 MB */
+#define MEM2MX8X2	0x809	/* 4 MB */
+#define MEM2MX8X4	0xc09	/* 8 MB */
+#define MEM2MX32	0x439	/* 8 MB */
+#define MEM4MX16	0x019	/* 8 MB */
+#define MEM4MX16X2	0x419	/* 16 MB */
+#define MEM8MX8X2	0x819	/* 16 MB */
+#define MEM8MX16	0x829	/* 16 MB */
+#define MEM4MX32	0x429	/* 16 MB */
+#define MEM8MX8X4	0xc19	/* 32 MB */
+#define MEM8MX16X2	0xc29	/* 32 MB */
+
+#endif				/* _SBSDRAM_H */
diff --git a/include/asm-mips/bcmsi/sbsocram.h b/include/asm-mips/bcmsi/sbsocram.h
new file mode 100644
index 0000000..8090a41
--- /dev/null
+++ b/include/asm-mips/bcmsi/sbsocram.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * BCM47XX Sonics SiliconBackplane embedded ram core
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_SBSOCRAM_H
+#define	_SBSOCRAM_H
+
+#ifndef _LANGUAGE_ASSEMBLY
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+/* Memcsocram core registers */
+typedef volatile struct sbsocramregs {
+    uint32 coreinfo;
+    uint32 bwalloc;
+    uint32 PAD;
+    uint32 biststat;
+    uint32 bankidx;
+    uint32 standbyctrl;
+    uint32 PAD[116];
+    uint32 pwrctl;		/* corerev >= 2 */
+} sbsocramregs_t;
+
+#endif				/* _LANGUAGE_ASSEMBLY */
+
+/* Register offsets */
+#define	SR_COREINFO		0x00
+#define	SR_BWALLOC		0x04
+#define	SR_BISTSTAT		0x0c
+#define	SR_BANKINDEX		0x10
+#define	SR_BANKSTBYCTL		0x14
+#define SR_PWRCTL		0x1e8
+
+/* Coreinfo register */
+#define	SRCI_PT_MASK		0x00030000
+#define	SRCI_PT_SHIFT		16
+/* corerev >= 3 */
+#define SRCI_LSS_MASK		0x00f00000
+#define SRCI_LSS_SHIFT		20
+#define SRCI_LRS_MASK		0x0f000000
+#define SRCI_LRS_SHIFT		24
+
+/* In corerev 0, the memory size is 2 to the power of the
+ * base plus 16 plus to the contents of the memsize field plus 1.
+ */
+#define	SRCI_MS0_MASK		0xf
+#define SR_MS0_BASE		16
+
+/*
+ * In corerev 1 the bank size is 2 ^ the bank size field plus 14,
+ * the memory size is number of banks times bank size.
+ * The same applies to rom size.
+ */
+#define	SRCI_ROMNB_MASK		0xf000
+#define	SRCI_ROMNB_SHIFT	12
+#define	SRCI_ROMBSZ_MASK	0xf00
+#define	SRCI_ROMBSZ_SHIFT	8
+#define	SRCI_SRNB_MASK		0xf0
+#define	SRCI_SRNB_SHIFT		4
+#define	SRCI_SRBSZ_MASK		0xf
+#define	SRCI_SRBSZ_SHIFT	0
+
+#define SR_BSZ_BASE		14
+
+/* Standby control register */
+#define	SRSC_SBYOVR_MASK	0x80000000
+#define	SRSC_SBYOVR_SHIFT	31
+#define	SRSC_SBYOVRVAL_MASK	0x60000000
+#define	SRSC_SBYOVRVAL_SHIFT	29
+#define	SRSC_SBYEN_MASK		0x01000000	/* rev >= 3 */
+#define	SRSC_SBYEN_SHIFT	24
+
+/* Power control register */
+#define SRPC_PMU_STBYDIS_MASK	0x00000010	/* rev >= 3 */
+#define SRPC_PMU_STBYDIS_SHIFT	4
+#define SRPC_STBYOVRVAL_MASK	0x00000008
+#define SRPC_STBYOVRVAL_SHIFT	3
+#define SRPC_STBYOVR_MASK	0x00000007
+#define SRPC_STBYOVR_SHIFT	0
+
+#endif				/* _SBSOCRAM_H */
diff --git a/include/asm-mips/bcmsi/siutils.h b/include/asm-mips/bcmsi/siutils.h
new file mode 100644
index 0000000..ab44966
--- /dev/null
+++ b/include/asm-mips/bcmsi/siutils.h
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Misc utility routines for accessing the SOC Interconnects
+ * of Broadcom HNBU chips.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#ifndef	_siutils_h_
+#define	_siutils_h_
+
+/*
+ * Data structure to export all chip specific common variables
+ *   public (read-only) portion of siutils handle returned by si_attach()/si_kattach()
+ */
+struct si_pub {
+    uint socitype;		/* SOCI_SB, SOCI_AI */
+
+    uint bustype;		/* SI_BUS, PCI_BUS */
+    uint buscoretype;		/* PCI_CORE_ID, PCIE_CORE_ID, PCMCIA_CORE_ID */
+    uint buscorerev;		/* buscore rev */
+    uint buscoreidx;		/* buscore index */
+    int ccrev;			/* chip common core rev */
+    uint32 cccaps;		/* chip common capabilities */
+    int pmurev;			/* pmu core rev */
+    uint32 pmucaps;		/* pmu capabilities */
+    uint boardtype;		/* board type */
+    uint boardvendor;		/* board vendor */
+    uint boardflags;		/* board flags */
+    uint chip;			/* chip number */
+    uint chiprev;		/* chip revision */
+    uint chippkg;		/* chip package option */
+    uint32 chipst;		/* chip status */
+    bool issim;			/* chip is in simulation or emulation */
+    uint socirev;		/* SOC interconnect rev */
+    bool pci_pr32414;		/* XXX whether 432414 WAR applis to the chip */
+};
+
+#if defined(WLC_HIGH) && !defined(WLC_LOW)
+typedef struct si_pub si_t;
+#else
+typedef const struct si_pub si_t;
+#endif
+
+/*
+ * Many of the routines below take an 'sih' handle as their first arg.
+ * Allocate this by calling si_attach().  Free it by calling si_detach().
+ * At any one time, the sih is logically focused on one particular si core
+ * (the "current core").
+ * Use si_setcore() or si_setcoreidx() to change the association to another core.
+ */
+#define	SI_OSH		NULL	/* Use for si_kattach when no osh is available */
+
+/* clkctl xtal what flags */
+#define	XTAL			0x1	/* primary crystal oscillator (2050) */
+#define	PLL			0x2	/* main chip pll */
+
+/* clkctl clk mode */
+#define	CLK_FAST		0	/* force fast (pll) clock */
+#define	CLK_DYNAMIC		2	/* enable dynamic clock control */
+
+/* GPIO usage priorities */
+#define GPIO_DRV_PRIORITY	0	/* Driver */
+#define GPIO_APP_PRIORITY	1	/* Application */
+#define GPIO_HI_PRIORITY	2	/* Highest priority. Ignore GPIO reservation */
+
+/* GPIO pull up/down */
+#define GPIO_PULLUP		0
+#define GPIO_PULLDN		1
+
+/* GPIO event regtype */
+#define GPIO_REGEVT		0	/* GPIO register event */
+#define GPIO_REGEVT_INTMSK	1	/* GPIO register event int mask */
+#define GPIO_REGEVT_INTPOL	2	/* GPIO register event int polarity */
+
+/* device path */
+#define SI_DEVPATH_BUFSZ	16	/* min buffer size in bytes */
+
+/* SI routine enumeration: to be used by update function with multiple hooks */
+#define	SI_DOATTACH	1
+#define SI_PCIDOWN	2
+#define SI_PCIUP	3
+
+#if defined(BCMINTERNAL) || defined(BCMQT)
+#define	ISSIM_ENAB(sih)	((sih)->issim)
+#else
+#define	ISSIM_ENAB(sih)	0
+#endif
+
+/* PMU clock/power control */
+#if defined(BCMPMUCTL)
+#define PMUCTL_ENAB(sih)	(BCMPMUCTL)
+#else
+#define PMUCTL_ENAB(sih)	((sih)->cccaps & CC_CAP_PMU)
+#endif
+
+/* chipcommon clock/power control (exclusive with PMU's) */
+#if defined(BCMPMUCTL) && BCMPMUCTL
+#define CCCTL_ENAB(sih)		(0)
+#define CCPLL_ENAB(sih)		(0)
+#else
+#define CCCTL_ENAB(sih)		((sih)->cccaps & CC_CAP_PWR_CTL)
+#define CCPLL_ENAB(sih)		((sih)->cccaps & CC_CAP_PLL_MASK)
+#endif
+
+typedef void (*gpio_handler_t) (uint32 stat, void *arg);
+
+
+/* === exported functions === */
+extern si_t *si_attach(uint pcidev, osl_t *osh, void *regs, uint bustype,
+		       void *sdh, char **vars, uint *varsz);
+extern si_t *si_kattach(osl_t *osh);
+extern void si_detach(si_t *sih);
+extern bool si_pci_war16165(si_t *sih);
+
+extern uint si_corelist(si_t *sih, uint coreid[]);
+extern uint si_coreid(si_t *sih);
+extern uint si_flag(si_t *sih);
+extern uint si_coreidx(si_t *sih);
+extern uint si_coreunit(si_t *sih);
+extern uint si_corevendor(si_t *sih);
+extern uint si_corerev(si_t *sih);
+extern void *si_osh(si_t *sih);
+extern void si_setosh(si_t *sih, osl_t *osh);
+extern uint si_corereg(si_t *sih, uint coreidx, uint regoff, uint mask,
+		       uint val);
+extern uint8 si_corereg8(si_t *sih, uint coreidx, uint regoff, uint8 mask,
+			 uint8 val);
+extern void *si_coreregs(si_t *sih);
+extern uint32 si_core_cflags(si_t *sih, uint32 mask, uint32 val);
+extern void si_core_cflags_wo(si_t *sih, uint32 mask, uint32 val);
+extern uint32 si_core_sflags(si_t *sih, uint32 mask, uint32 val);
+extern bool si_iscoreup(si_t *sih);
+extern uint si_findcoreidx(si_t *sih, uint coreid, uint coreunit);
+extern void *si_setcoreidx(si_t *sih, uint coreidx);
+extern void *si_setcore(si_t *sih, uint coreid, uint coreunit);
+extern void *si_switch_core(si_t *sih, uint coreid, uint *origidx,
+			    uint *intr_val);
+extern void si_restore_core(si_t *sih, uint coreid, uint intr_val);
+extern int si_numaddrspaces(si_t *sih);
+extern uint32 si_addrspace(si_t *sih, uint asidx);
+extern uint32 si_addrspacesize(si_t *sih, uint asidx);
+extern int si_corebist(si_t *sih);
+extern void si_core_reset(si_t *sih, uint32 bits, uint32 resetbits);
+extern void si_core_tofixup(si_t *sih);
+extern void si_core_disable(si_t *sih, uint32 bits);
+extern char *si_chipname(si_t *sih, char *buf, uint len);
+extern uint32 si_clock_rate(uint32 pll_type, uint32 n, uint32 m);
+extern uint32 si_clock(si_t *sih);
+extern void si_clock_pmu_spuravoid(si_t *sih, bool spuravoid);
+extern uint32 si_alp_clock(si_t *sih);
+extern uint32 si_ilp_clock(si_t *sih);
+extern void si_pci_setup(si_t *sih, uint coremask);
+extern void si_pcmcia_init(si_t *sih);
+extern void si_setint(si_t *sih, int siflag);
+extern bool si_backplane64(si_t *sih);
+extern void si_register_intr_callback(si_t *sih, void *intrsoff_fn,
+				      void *intrsrestore_fn,
+				      void *intrsenabled_fn,
+				      void *intr_arg);
+extern void si_deregister_intr_callback(si_t *sih);
+extern void si_clkctl_init(si_t *sih);
+extern uint16 si_clkctl_fast_pwrup_delay(si_t *sih);
+extern bool si_clkctl_cc(si_t *sih, uint mode);
+extern int si_clkctl_xtal(si_t *sih, uint what, bool on);
+extern uint32 si_gpiotimerval(si_t *sih, uint32 mask, uint32 val);
+extern bool si_backplane64(si_t *sih);
+extern void si_btcgpiowar(si_t *sih);
+extern bool si_deviceremoved(si_t *sih);
+extern uint32 si_socram_size(si_t *sih);
+
+extern void si_watchdog(si_t *sih, uint nticks);
+extern void si_watchdog_ms(si_t *sih, uint32 ms);
+extern void *si_gpiosetcore(si_t *sih);
+extern uint32 si_gpiocontrol(si_t *sih, uint32 mask, uint32 val,
+			     uint8 priority);
+extern uint32 si_gpioouten(si_t *sih, uint32 mask, uint32 val,
+			   uint8 priority);
+extern uint32 si_gpioout(si_t *sih, uint32 mask, uint32 val,
+			 uint8 priority);
+extern uint32 si_gpioin(si_t *sih);
+extern uint32 si_gpiointpolarity(si_t *sih, uint32 mask, uint32 val,
+				 uint8 priority);
+extern uint32 si_gpiointmask(si_t *sih, uint32 mask, uint32 val,
+			     uint8 priority);
+extern uint32 si_gpioled(si_t *sih, uint32 mask, uint32 val);
+extern uint32 si_gpioreserve(si_t *sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiorelease(si_t *sih, uint32 gpio_num, uint8 priority);
+extern uint32 si_gpiopull(si_t *sih, bool updown, uint32 mask,
+			  uint32 val);
+extern uint32 si_gpioevent(si_t *sih, uint regtype, uint32 mask,
+			   uint32 val);
+extern uint32 si_gpio_int_enable(si_t *sih, bool enable);
+extern uint32 si_gpiotimer_outmask(si_t *sih, uint32 mask, uint32 val);
+
+/* GPIO event handlers */
+extern void *si_gpio_handler_register(si_t *sih, uint32 e, bool lev,
+				      gpio_handler_t cb, void *arg);
+extern void si_gpio_handler_unregister(si_t *sih, void *gpioh);
+extern void si_gpio_handler_process(si_t *sih);
+
+/* Wake-on-wireless-LAN (WOWL) */
+extern bool si_pci_pmecap(si_t *sih);
+struct osl_info;
+extern bool si_pci_fastpmecap(struct osl_info *osh);
+extern bool si_pci_pmeclr(si_t *sih);
+extern void si_pci_pmeen(si_t *sih);
+extern uint si_pcie_readreg(void *sih, uint addrtype, uint offset);
+
+#ifdef BCMSDIO
+extern void si_sdio_init(si_t *sih);
+#endif
+
+extern uint16 si_d11_devid(si_t *sih);
+extern int si_corepciid(si_t *sih, uint func, uint16 *pcivendor,
+			uint16 *pcidevice, uint8 *pciclass,
+			uint8 *pcisubclass, uint8 *pciprogif,
+			uint8 *pciheader);
+
+#ifdef BCMECICOEX
+extern void *si_eci_init(si_t *sih);
+extern void si_eci_notify_bt(si_t *sih, uint32 mask, uint32 val);
+#else
+#define si_eci_init(sih) (0)
+#define si_eci_notify_bt(sih, type, val)  (0)
+#endif				/* BCMECICOEX */
+
+/* OTP status */
+extern bool si_is_otp_disabled(si_t *sih);
+extern bool si_is_otp_powered(si_t *sih);
+extern void si_otp_power(si_t *sih, bool on);
+
+/* SPROM availability */
+extern bool si_is_sprom_available(si_t *sih);
+
+/*
+ * Build device path. Path size must be >= SI_DEVPATH_BUFSZ.
+ * The returned path is NULL terminated and has trailing '/'.
+ * Return 0 on success, nonzero otherwise.
+ */
+extern int si_devpath(si_t *sih, char *path, int size);
+/* Read variable with prepending the devpath to the name */
+extern char *si_getdevpathvar(si_t *sih, const char *name);
+extern int si_getdevpathintvar(si_t *sih, const char *name);
+
+
+/* === XXX HW PR WARs === */
+extern uint8 si_pcieclkreq(si_t *sih, uint32 mask, uint32 val);
+extern void si_war42780_clkreq(si_t *sih, bool clkreq);
+extern void si_pci_sleep(si_t *sih);
+extern void si_pci_down(si_t *sih);
+extern void si_pci_up(si_t *sih);
+extern void si_pcie_war_ovr_disable(si_t *sih);
+extern void si_pcie_extendL1timer(si_t *sih, bool extend);
+extern int si_pci_fixcfg(si_t *sih);
+#ifndef BCMDONGLEHOST
+extern bool si_ldo_war(si_t *sih, uint devid);
+#endif
+
+/* === debug routines === */
+
+/* XXX Mogrifier hack alert- BCMINTERNAL should not be the last in the following ifdefine string */
+#if defined(BCMINTERNAL) || defined(BCMDBG_ASSERT) || defined(BCMDBG_ERR) || defined(BCMDBG_DUMP)
+extern bool si_taclear(si_t *sih, bool details);
+#endif
+
+#ifdef BCMDBG
+extern void si_view(si_t *sih, bool verbose);
+extern void si_viewall(si_t *sih, bool verbose);
+extern uint32 si_pcielcreg(si_t *sih, uint32 mask, uint32 val);
+#endif
+
+#if defined(BCMINTERNAL) && defined(BCMDBG) || defined(BCMDBG_DUMP)
+extern void si_dump(si_t *sih, struct bcmstrbuf *b);
+extern void si_ccreg_dump(si_t *sih, struct bcmstrbuf *b);
+extern void si_clkctl_dump(si_t *sih, struct bcmstrbuf *b);
+extern int si_gpiodump(si_t *sih, struct bcmstrbuf *b);
+#endif
+#if defined(BCMDBG) || defined(BCMDBG_DUMP)
+extern void si_dumpregs(si_t *sih, struct bcmstrbuf *b);
+#endif
+#if defined(BCMINTERNAL) && defined(BCMDBG)
+extern int si_dump_pcieregs(si_t *sih, struct bcmstrbuf *b);
+#endif
+
+#ifdef BCMINTERNAL
+extern uint32 si_pciereg(si_t *sih, uint32 offset, uint32 mask,
+			 uint32 val, uint type);
+extern uint32 si_pciesbreg(si_t *sih, uint32 offset, uint32 mask,
+			   uint32 val);
+extern uint32 si_pcieserdesreg(si_t *sih, uint32 mdioslave, uint32 offset,
+			       uint32 mask, uint32 val);
+extern uint32 si_ccreg(si_t *sih, uint32 offset, uint32 mask, uint32 val);
+#endif
+
+#endif				/* _siutils_h_ */
diff --git a/include/asm-mips/bcmsi/typedefs.h b/include/asm-mips/bcmsi/typedefs.h
new file mode 100644
index 0000000..30a3d2e
--- /dev/null
+++ b/include/asm-mips/bcmsi/typedefs.h
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _TYPEDEFS_H_
+#define _TYPEDEFS_H_
+
+/* Define 'SITE_TYPEDEFS' in the compile to include a site specific
+ * typedef file "site_typedefs.h".
+ *
+ * If 'SITE_TYPEDEFS' is not defined, then the "Inferred Typedefs"
+ * section of this file makes inferences about the compile environment
+ * based on defined symbols and possibly compiler pragmas.
+ *
+ * Following these two sections is the "Default Typedefs"
+ * section. This section is only prcessed if 'USE_TYPEDEF_DEFAULTS' is
+ * defined. This section has a default set of typedefs and a few
+ * proprocessor symbols (TRUE, FALSE, NULL, ...).
+ */
+
+#ifdef SITE_TYPEDEFS
+
+/*
+ * Site Specific Typedefs
+ *
+ */
+
+#include "site_typedefs.h"
+
+#else
+
+/*
+ * Inferred Typedefs
+ *
+ */
+
+/* Infer the compile environment based on preprocessor symbols and pramas.
+ * Override type definitions as needed, and include configuration dependent
+ * header files to define types.
+ */
+
+#ifdef __cplusplus
+
+#define TYPEDEF_BOOL
+#ifndef FALSE
+#define FALSE	false
+#endif
+#ifndef TRUE
+#define TRUE	true
+#endif
+
+#else				/* ! __cplusplus */
+
+#if defined(_WIN32)
+
+#define TYPEDEF_BOOL
+typedef unsigned char bool;	/* consistent w/BOOL */
+
+#endif				/* _WIN32 */
+
+#endif				/* ! __cplusplus */
+
+/* use the Windows ULONG_PTR type when compiling for 64 bit */
+#if defined(_WIN64) && !defined(EFI)
+#include <basetsd.h>
+#define TYPEDEF_UINTPTR
+typedef ULONG_PTR uintptr;
+#elif defined(__x86_64__)
+#define TYPEDEF_UINTPTR
+typedef unsigned long long int uintptr;
+#endif
+
+#if defined(_HNDRTE_) && !defined(_HNDRTE_SIM_)
+#define _NEED_SIZE_T_
+#endif
+
+#if defined(_MINOSL_)
+#define _NEED_SIZE_T_
+#endif
+
+#if defined(EFI) && !defined(_WIN64)
+#define _NEED_SIZE_T_
+#endif
+
+#if defined(_NEED_SIZE_T_)
+typedef long unsigned int size_t;
+#endif
+
+#ifdef __DJGPP__
+typedef long unsigned int size_t;
+#endif				/* __DJGPP__ */
+
+#ifdef _MSC_VER			/* Microsoft C */
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+typedef signed __int64 int64;
+typedef unsigned __int64 uint64;
+#endif
+
+#if defined(MACOSX)
+#define TYPEDEF_BOOL
+#endif
+
+#if defined(__NetBSD__)
+#define TYPEDEF_ULONG
+#endif
+
+#if defined(vxworks)
+#define TYPEDEF_USHORT
+#endif
+
+#ifdef	linux
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#define TYPEDEF_ULONG
+#ifdef __KERNEL__
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19))
+#define TYPEDEF_BOOL
+#endif				/* >= 2.6.19 */
+#endif				/* __KERNEL__ */
+#endif				/* linux */
+
+#if defined(__ECOS)
+#define TYPEDEF_BOOL
+#endif
+
+#if !defined(linux) && !defined(vxworks) && !defined(_WIN32) && !defined(_CFE_) && \
+!defined(_HNDRTE_) && !defined(_MINOSL_) && !defined(__DJGPP__) && \
+!defined(__IOPOS__) && !defined(__ECOS)
+#define TYPEDEF_UINT
+#define TYPEDEF_USHORT
+#endif
+
+#if defined(vxworks)
+/* Do not support the int64 type in VxWorks */
+#define TYPEDEF_INT64
+#endif
+
+/* Do not support the (u)int64 types with strict ansi for GNU C */
+#if defined(__GNUC__) && defined(__STRICT_ANSI__)
+#define TYPEDEF_INT64
+#define TYPEDEF_UINT64
+#endif
+
+/* ICL accepts unsigned 64 bit type only, and complains in ANSI mode
+ * for singned or unsigned
+ */
+#if defined(__ICL)
+
+#define TYPEDEF_INT64
+
+#if defined(__STDC__)
+#define TYPEDEF_UINT64
+#endif
+
+#endif				/* __ICL */
+
+#if !defined(_WIN32) && !defined(_CFE_) && !defined(_HNDRTE_) && !defined(_MINOSL_) && \
+	!defined(__DJGPP__) && !defined(__IOPOS__)
+
+/* pick up ushort & uint from standard types.h */
+#if defined(linux) && defined(__KERNEL__)
+
+#include <linux/types.h>	/* sys/types.h and linux/types.h are oil and water */
+
+#else
+
+#if defined(__ECOS)
+#include <pkgconf/infra.h>
+#include <cyg/infra/cyg_type.h>
+#include <stdarg.h>
+#endif
+
+#include <sys/types.h>
+
+#endif				/* linux && __KERNEL__ */
+
+#endif				/* !_WIN32 && !PMON && !_CFE_ && !_HNDRTE_  && !_MINOSL_ && !__DJGPP__ */
+
+#if defined(MACOSX)
+
+#ifdef __BIG_ENDIAN__
+#define IL_BIGENDIAN
+#else
+#ifdef IL_BIGENDIAN
+#error "IL_BIGENDIAN was defined for a little-endian compile"
+#endif
+#endif				/* __BIG_ENDIAN__ */
+
+#if !defined(__cplusplus)
+
+#if defined (__i386__)
+typedef unsigned char bool;
+#else
+typedef unsigned int bool;
+#endif
+#define TYPE_BOOL 1
+enum {
+    false = 0,
+    true = 1
+};
+
+#if defined(KERNEL)
+#include <IOKit/IOTypes.h>
+#endif				/* KERNEL */
+
+#endif				/* __cplusplus */
+
+#endif				/* MACOSX */
+
+#if defined(vxworks)
+#include <private/cplusLibP.h>
+#endif
+
+/* use the default typedefs in the next section of this file */
+#define USE_TYPEDEF_DEFAULTS
+
+#endif				/* SITE_TYPEDEFS */
+
+
+/*
+ * Default Typedefs
+ *
+ */
+
+#ifdef USE_TYPEDEF_DEFAULTS
+#undef USE_TYPEDEF_DEFAULTS
+
+#ifndef TYPEDEF_BOOL
+typedef /* @abstract@ */ unsigned char bool;
+#endif
+
+/* define uchar, ushort, uint, ulong */
+
+#ifndef TYPEDEF_UCHAR
+typedef unsigned char uchar;
+#endif
+
+#ifndef TYPEDEF_USHORT
+typedef unsigned short ushort;
+#endif
+
+#ifndef TYPEDEF_UINT
+typedef unsigned int uint;
+#endif
+
+#ifndef TYPEDEF_ULONG
+typedef unsigned long ulong;
+#endif
+
+/* define [u]int8/16/32/64, uintptr */
+
+#ifndef _SAL_TYPES_H
+
+#ifndef TYPEDEF_UINT8
+typedef unsigned char uint8;
+#endif
+
+#ifndef TYPEDEF_UINT16
+typedef unsigned short uint16;
+#endif
+
+#ifndef TYPEDEF_UINT32
+typedef unsigned int uint32;
+#endif
+
+#ifndef TYPEDEF_UINT64
+typedef unsigned long long uint64;
+#endif
+
+#ifndef TYPEDEF_UINTPTR
+typedef unsigned int uintptr;
+#endif
+
+#ifndef TYPEDEF_INT8
+typedef signed char int8;
+#endif
+
+#ifndef TYPEDEF_INT16
+typedef signed short int16;
+#endif
+
+#ifndef TYPEDEF_INT32
+typedef signed int int32;
+#endif
+
+#ifndef TYPEDEF_INT64
+typedef signed long long int64;
+#endif
+
+#endif				/* !_SAL_TYPES_H */
+
+/* define float32/64, float_t */
+
+#ifndef TYPEDEF_FLOAT32
+typedef float float32;
+#endif
+
+#ifndef TYPEDEF_FLOAT64
+typedef double float64;
+#endif
+
+
+/*
+ * abstracted floating point type allows for compile time selection of
+ * single or double precision arithmetic.  Compiling with -DFLOAT32
+ * selects single precision; the default is double precision.
+ */
+
+#ifndef TYPEDEF_FLOAT_T
+
+#if defined(FLOAT32)
+typedef float32 float_t;
+#else				/* default to double precision floating point */
+typedef float64 float_t;
+#endif
+
+#endif				/* TYPEDEF_FLOAT_T */
+
+/* define macro values */
+
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#ifndef TRUE
+#define TRUE	1		/* TRUE */
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef OFF
+#define	OFF	0
+#endif
+
+#ifndef ON
+#define	ON	1		/* ON = 1 */
+#endif
+
+#define	AUTO	(-1)		/* Auto = -1 */
+
+/* define PTRSZ, INLINE */
+
+#ifndef PTRSZ
+#define	PTRSZ	sizeof(char *)
+#endif
+
+#ifndef INLINE
+
+#ifdef _MSC_VER
+
+#define INLINE __inline
+
+#elif defined(__GNUC__)
+
+#define INLINE __inline__
+
+#else
+
+#define INLINE
+
+#endif				/* _MSC_VER */
+
+#endif				/* INLINE */
+
+#undef TYPEDEF_BOOL
+#undef TYPEDEF_UCHAR
+#undef TYPEDEF_USHORT
+#undef TYPEDEF_UINT
+#undef TYPEDEF_ULONG
+#undef TYPEDEF_UINT8
+#undef TYPEDEF_UINT16
+#undef TYPEDEF_UINT32
+#undef TYPEDEF_UINT64
+#undef TYPEDEF_UINTPTR
+#undef TYPEDEF_INT8
+#undef TYPEDEF_INT16
+#undef TYPEDEF_INT32
+#undef TYPEDEF_INT64
+#undef TYPEDEF_FLOAT32
+#undef TYPEDEF_FLOAT64
+#undef TYPEDEF_FLOAT_T
+
+#endif				/* USE_TYPEDEF_DEFAULTS */
+
+/* 
+ * Including the bcmdefs.h here, to make sure everyone including typedefs.h
+ * gets this automatically
+*/
+#include "bcmdefs.h"
+
+#endif				/* _TYPEDEFS_H_ */
diff --git a/include/asm-mips/mach-bcm5300x/war.h b/include/asm-mips/mach-bcm5300x/war.h
new file mode 100644
index 0000000..0ed432c
--- /dev/null
+++ b/include/asm-mips/mach-bcm5300x/war.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+#ifndef __ASM_MIPS_MACH_BCM95300X_WAR_H
+#define __ASM_MIPS_MACH_BCM95300X_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR		0
+#define R4600_V2_HIT_CACHEOP_WAR		0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR					0
+#define SIBYTE_1956_WAR				0
+#define MIPS4K_ICACHE_REFILL_WAR		0
+#define MIPS_CACHE_SYNC_WAR			0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR			0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR				0
+#define MIPS34K_MISSED_ITLB_WAR		0
+#if defined(CONFIG_BCM53000) 
+#define bcm53000_compare_irq_war		1
+#else
+#define bcm53000_compare_irq_war		0
+#endif
+#endif /* __ASM_MIPS_MACH_BCM95300X_WAR_H */
diff --git a/include/asm-mips/mipsregs.h b/include/asm-mips/mipsregs.h
index c9c820e..2ebfdda 100644
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -604,21 +604,42 @@ do {								\
 /*
  * Macros to access the system control coprocessor
  */
-
+#ifdef CONFIG_BCM53000
 #define __read_32bit_c0_register(source, sel)				\
 ({ int __res;								\
 	if (sel == 0)							\
 		__asm__ __volatile__(					\
 			"mfc0\t%0, " #source "\n\t"			\
+			".set\tmips32r2\n\t" \
+			"ehb	 \n\t" \
+			".set\tmips0\n\t"  \
 			: "=r" (__res));				\
 	else								\
 		__asm__ __volatile__(					\
 			".set\tmips32\n\t"				\
 			"mfc0\t%0, " #source ", " #sel "\n\t"		\
+			".set\tmips32r2\n\t" \
+			"ehb	 \n\t" \
 			".set\tmips0\n\t"				\
 			: "=r" (__res));				\
 	__res;								\
 })
+#else
+#define __read_32bit_c0_register(source, sel)				\
+({ int __res;								\
+	if (sel == 0)							\
+		__asm__ __volatile__(					\
+			"mfc0\t%0, " #source "\n\t"			\
+			: "=r" (__res));				\
+	else								\
+		__asm__ __volatile__(					\
+			".set\tmips32\n\t"				\
+			"mfc0\t%0, " #source ", " #sel "\n\t"		\
+			".set\tmips0\n\t"				\
+			: "=r" (__res));				\
+	__res;								\
+})
+#endif
 
 #define __read_64bit_c0_register(source, sel)				\
 ({ unsigned long long __res;						\
-- 
1.7.0.4

