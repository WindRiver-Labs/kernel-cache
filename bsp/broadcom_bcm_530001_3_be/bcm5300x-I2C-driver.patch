From 9c80d3e3c22289ddd0ae16f3ac5f7d115f103327 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Sun, 6 Jun 2010 14:24:57 +0800
Subject: [PATCH 20/21] bcm5300x I2C driver

bcm5300x I2C support, here add some I2C operate functions.
RTC could work with I2C via these functions, and these are
not standard I2C interface, so you can't access I2C via
standard I2C interface.

Source: from broadcom SDK

Signed-off-by: Liu Changhui <changhui.liu@windriver.com>
---
 drivers/i2c/busses/Kconfig         |    7 +-
 drivers/i2c/busses/Makefile        |    1 +
 drivers/i2c/busses/i2c-bcm5300x.c  | 2177 ++++++++++++++++++++++++++++++++++++
 include/asm-mips/bcmsi/chipc_i2c.h |  247 ++++
 4 files changed, 2431 insertions(+), 1 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-bcm5300x.c
 create mode 100644 include/asm-mips/bcmsi/chipc_i2c.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..81bd5a0 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -270,7 +270,12 @@ config I2C_AT91
 	  documented way to issue repeated START conditions, as needed
 	  to support combined I2C messages.  Use the i2c-gpio driver
 	  unless your system can cope with those limitations.
-
+config I2C_BCM5300X
+	tristate "Broadcom BCM5300X I2C interface support"
+	depends on I2C
+	help
+          This supports the use of the I2C interface on Broadcom BCM5300X
+          processor.
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on SOC_AU1550 || SOC_AU1200
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..6aa8101 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 
 # Embebbed system I2C/SMBus host controller drivers
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
+obj-$(CONFIG_I2C_BCM5300X)	+= i2c-bcm5300x.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
 obj-$(CONFIG_I2C_CPM)		+= i2c-cpm.o
diff --git a/drivers/i2c/busses/i2c-bcm5300x.c b/drivers/i2c/busses/i2c-bcm5300x.c
new file mode 100644
index 0000000..8b42a72
--- /dev/null
+++ b/drivers/i2c/busses/i2c-bcm5300x.c
@@ -0,0 +1,2177 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * The general level I2C driver for KeyStone I2C interface.
+ *
+ * The I2C interfaces (two I2C I/O ports) in Keystone can support the I2C 
+ * features are :
+ *  1. Speed mode : 
+ *      - Standard Mode (SM): 100 kbit/s
+ *      - Fast Mode(FM) : 400 kbit/s
+ *      - High-speed Mode(HM) : 3.4 mbit/s
+ *  2. M/S mode : 
+ *      - Master Mode : 
+ *      - Slave Mode : HW supported but SW is not supported yet.
+ *      - Mix Mode : In the case for Multi-Master connected on the I2C bus. 
+ *                  SW is not supported yet.
+ *  3. Addressing mode.
+ *      -7  bits Mode : default supported.
+ *      -10 bits mode : HW supportd but SW is not supported yet.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *  
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <sbchipc.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <pcicfg.h>
+#include <nicpci.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <chipc_i2c.h>
+
+#include "siutils_priv.h"
+
+#define I2C_CTRL_IFLG_CLEAR(_ctrl)     \
+        (_ctrl) = (CC_I2CCTRL_INTEN | CC_I2CCTRL_BUSEN)
+
+#ifdef BCMDBG_ERR
+#define	I2C_ERROR(args)	printf args
+#else
+#define	I2C_ERROR(args)
+#endif				/* BCMDBG_ERR */
+
+#ifdef BCMDBG
+#define	I2C_MSG(args)	printf args
+#else
+#define	I2C_MSG(args)
+#endif				/* BCMDBG */
+
+static si_t *ksi2c_sih = NULL;
+static ks_i2c_bus_t ksi2c_bus[CC_I2C_NUM_BUS];
+
+
+
+#define KSI2C_INIT_CHK  \
+    if (ksi2c_sih == NULL) {\
+         I2C_MSG(("%s,I2C bus not init yet!\n", __func__)); \
+         return KSI2C_ERR_INTERNAL; \
+    }
+
+#ifndef KHZ_TO_HZ
+#define KHZ_TO_HZ(n) ((n)*1000)
+#endif				/* KHZ_TO_HZ */
+
+/* definitions for the driver's verification stage :
+ *  - These definitions will be the final driver style after all verification 
+ *      on read chip is done. And these symbole must be removed then.
+ *  1. KSI2C_BUS_DRIVER_READY
+ */
+#define KSI2C_BUS_DRIVER_READY          1
+
+/* --------- I2C register access level driver --------- 
+ *  The drivers in this level read/write i2c register directly.
+ */
+
+/* change logical "focus" to the i2c core for optimized access */
+void *si_i2c_setcore(si_t * sih)
+{
+    return (si_setcoreidx(sih, SI_CC_IDX));
+}
+
+/* enable the I2C I/O port */
+int si_i2c_select(si_t * sih, uint8 i2c_id, int en)
+{
+	si_info_t *sii;
+	uint origidx;
+	uint intr_val = 0;
+	uint32 reg_val = 0, temp;
+	chipcregs_t *cc;
+
+	/* select the I2C port */
+	if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+	}
+
+	sii = SI_INFO(sih);
+	INTR_OFF(sii, intr_val);
+	origidx = si_coreidx(sih);
+
+	cc = (chipcregs_t *) si_i2c_setcore(sih);
+	ASSERT(cc);
+
+	/* CHECK: if the register name is not changed */
+	reg_val = R_REG(sii->osh, &cc->SERIAL_IO_SEL);
+	temp = (i2c_id == CC_I2C_ID0) ? CC_SERIAL_IO_I2C0_MASK :
+	(i2c_id == CC_I2C_ID1) ? CC_SERIAL_IO_I2C1_MASK : 0;
+	if (en) {
+		reg_val |= temp;
+	} else {
+		reg_val &= ~temp;
+	}
+	W_REG(sii->osh, &cc->SERIAL_IO_SEL, reg_val);
+
+	/* restore the original index */
+	si_setcoreidx(sih, origidx);
+
+	INTR_RESTORE(sii, intr_val);
+	return 0;
+
+}
+
+/* enable CC lever interrupt on the I2C I/O port */
+int si_i2c_ccint_enable(si_t * sih, uint8 i2c_id, bool en)
+{
+    si_info_t *sii;
+    uint origidx;
+    uint intr_val = 0;
+    uint32 reg_val = 0, temp;
+    chipcregs_t *cc;
+
+    /* select the I2C port */
+    if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+    }
+
+    sii = SI_INFO(sih);
+    INTR_OFF(sii, intr_val);
+    origidx = si_coreidx(sih);
+
+    cc = (chipcregs_t *) si_i2c_setcore(sih);
+    ASSERT(cc);
+
+    /* CHECK: if the register name is not changed */
+    reg_val = R_REG(sii->osh, &cc->SERIAL_IO_INTMASK);
+    temp = (i2c_id == CC_I2C_ID0) ? CC_SERIAL_IO_I2C0_MASK :
+	(i2c_id == CC_I2C_ID1) ? CC_SERIAL_IO_I2C1_MASK : 0;
+	if (en) {
+		reg_val |= temp;
+	} else {
+		reg_val &= ~temp;
+	}
+
+    W_REG(sii->osh, &cc->SERIAL_IO_INTMASK, reg_val);
+
+    /* restore the original index */
+    si_setcoreidx(sih, origidx);
+
+    INTR_RESTORE(sii, intr_val);
+    return 0;
+}
+
+/* mask&set i2c_swreset bits */
+uint8 si_i2c_swreset(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val)
+{
+    uint regoff = 0;
+
+	if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+	} else {
+		regoff = OFFSETOF(chipcregs_t, i2c_swreset);
+		regoff |= CC_I2C_OFFSETOF(i2c_id);
+	}
+
+	return (si_corereg8(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set i2c_data bits */
+uint8 si_i2c_data(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val)
+{
+	uint regoff = 0;
+
+	if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+	} else {
+		regoff = OFFSETOF(chipcregs_t, i2c_data);
+		regoff |= CC_I2C_OFFSETOF(i2c_id);
+	}
+
+	return (si_corereg8(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set i2c_slaveaddr bits */
+uint8 si_i2c_slaveaddr(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val)
+{
+    uint regoff = 0;
+
+	if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+	} else {
+		regoff = OFFSETOF(chipcregs_t, i2c_slaveaddr);
+		regoff |= CC_I2C_OFFSETOF(i2c_id);
+	}
+
+	return (si_corereg8(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+
+/* mask&set i2c_control bits */
+uint8 si_i2c_control(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val)
+{
+	uint regoff = 0;
+
+	if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+	} else {
+		regoff = OFFSETOF(chipcregs_t, i2c_control);
+		regoff |= CC_I2C_OFFSETOF(i2c_id);
+	}
+
+	return (si_corereg8(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+/* mask&set i2c_sts_ccr bits.
+ *  - status register is read only.
+ *  - Clock_Control_Reg is write only.
+ * 
+ * Note :
+ *  1. read CCR is not allowed.
+ */
+int si_i2c_clock(si_t * sih, uint8 i2c_id, uint8 val)
+{
+    uint origidx = 0;
+    uint intr_val = 0;
+
+    si_info_t *sii;
+    chipcregs_t *cc;
+
+    if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+    }
+
+    sii = SI_INFO(sih);
+
+    INTR_OFF(sii, intr_val);
+
+    /* save current core index */
+    origidx = si_coreidx(&sii->pub);
+
+    cc = (chipcregs_t *) si_i2c_setcore(sih);
+    ASSERT(cc);
+
+    val &= CC_I2CCCR_MASK;
+
+    if (i2c_id == CC_I2C_ID1) {
+		W_REG(sii->osh, &cc->i2c1_sts_ccr, val);
+    } else {
+		W_REG(sii->osh, &cc->i2c_sts_ccr, val);
+    }
+
+    /* restore the original index */
+    si_setcoreidx(sih, origidx);
+
+    INTR_RESTORE(sii, intr_val);
+
+    return 0;
+
+}
+
+/* mask&set i2c_sts_ccr bits.
+ *  - status register is read only.
+ *  - Clock_Control_Reg is write only.
+ */
+int si_i2c_status(si_t * sih, uint8 i2c_id, uint8 mask, uint8 * val)
+{
+    si_info_t *sii;
+    uint origidx;
+    uint intr_val = 0;
+    uint8 reg_val = 0;
+    chipcregs_t *cc;
+
+    /* select the I2C port */
+    if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+    }
+
+    sii = SI_INFO(sih);
+    INTR_OFF(sii, intr_val);
+
+    /* save current core index */
+    origidx = si_coreidx(sih);
+
+    cc = (chipcregs_t *) si_i2c_setcore(sih);
+    ASSERT(cc);
+
+    if (i2c_id == CC_I2C_ID1) {
+		reg_val = R_REG(sii->osh, &cc->i2c1_sts_ccr);
+    } else {
+		reg_val = R_REG(sii->osh, &cc->i2c_sts_ccr);
+    }
+
+    *val = (uint8) (reg_val & mask);
+
+    /* restore the original index */
+    si_setcoreidx(sih, origidx);
+
+    INTR_RESTORE(sii, intr_val);
+
+    return 0;
+}
+
+/* mask&set i2c_extaddr bits */
+uint8 si_i2c_extaddr(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val)
+{
+    uint regoff = 0;
+
+    /* prevent the invalid extented address in val */
+    val = CC_I2CEXTADDR_PREFIX | (val & CC_I2CEXTADDR_MASK);
+
+    if (!CC_I2C_ID_IS_VALID(i2c_id)) {
+		SI_ERROR(("%s: invalid i2c_id\n", __func__));
+		return -1;
+    } else {
+		regoff = OFFSETOF(chipcregs_t, i2c_extaddr);
+		regoff |= CC_I2C_OFFSETOF(i2c_id);
+    }
+
+    return (si_corereg8(sih, SI_CC_IDX, regoff, mask, val));
+}
+
+
+/* --------- I2C Bus level(Low Level) driver --------- 
+ *  The drivers in this level will combine the Keystone's register 
+ *      configuration to proceed the requesting process.
+ *  - interface between I2C Core driver and High level driver.
+ */
+
+/* Function : ksi2c_bus_attach 
+ *  - Enable Keystone's I2C port.
+ * Return :
+ * Note :
+ */
+int
+ksi2c_bus_attach(si_t * sih, cc_i2c_id_t id, uint32 flags, int speed_khz)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint32 speed_hz;
+    uint8 i2creg_val, bus_status;
+
+    I2C_MSG(("%s,id=%d,flag=0x%x,speed(khz)=%d\n",
+	     __func__, id, flags, speed_khz));
+    ASSERT(sih);
+
+    if (!CC_I2C_ID_IS_VALID(id)) {
+		I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+		return KSI2C_ERR_PARAM;
+    }
+    i2cbus = ksi2c_bus + id;
+
+    if (i2cbus->flags & KS_I2C_BUS_ATTACHED) {
+		return KSI2C_ERR_INTERNAL;
+    }
+    I2C_MSG(("%s, current flag =0x%x\n", __func__, i2cbus->flags));
+    I2C_MSG(("%s, oldspeed=%d newspeed=%d\n",
+	     __func__, i2cbus->frequency, KHZ_TO_HZ(speed_khz)));
+
+    /* Choose one or the other IO mode, default
+     * to PIO driven
+     */
+    if ((flags & KS_I2C_BUS_INTR) == ((flags & KS_I2C_BUS_PIO))) {
+	/* both INTR and PIO is set or not set >> use polling mode */
+		i2cbus->flags = KS_I2C_BUS_PIO;
+    } else {
+		i2cbus->flags = flags & (KS_I2C_BUS_INTR | KS_I2C_BUS_PIO);
+    }
+
+    /* Number of PIO's (IFLG/ACK) */
+    i2cbus->pio_retries = KS_I2C_PIO_RETRY;
+
+    /* Use default speed if zero or bad value specified */
+    if ((speed_khz <= 0) || (speed_khz > KS_I2C_SPEED_HIGH)) {
+		speed_khz = KS_I2C_SPEED_DEFAULT;
+    }
+    speed_hz = KHZ_TO_HZ(speed_khz);
+
+    /* 1) set I2C clock */
+    if (ksi2c_bus_set_freq(sih, id, speed_hz)) {
+		I2C_ERROR(("%s, failed on setting clock at I2C_%d!\n", __func__,
+		   id));
+		return KSI2C_ERR_INTERNAL;
+    }
+
+    /* set slave addr */
+    i2creg_val = si_i2c_slaveaddr(sih, (uint8) id, CC_I2CSADDR_ADDR_MASK,
+				  (KSI2C_SLAVE_ADDR_BASE | id) <<
+				  CC_I2CSADDR_ADDR_OFFSET);
+    i2cbus->master_addr = i2creg_val;
+    I2C_MSG(("%s,I2C_%d set to slave-addr=0x%x(%x)\n",
+	     __func__, id,
+	     (KSI2C_SLAVE_ADDR_BASE | id) << CC_I2CSADDR_ADDR_OFFSET,
+	     i2cbus->master_addr));
+
+    /* update bus op status */
+    i2cbus->opcode = KS_I2C_PROBE;
+
+    bus_status = ksi2c_bus_status(sih, id);
+    if (bus_status == CC_I2CSTS_NO_STATUS) {
+		i2cbus->opcode = KS_I2C_IDLE;
+    }
+    i2cbus->flags |= KS_I2C_BUS_ATTACHED;
+
+    return KSI2C_ERR_NONE;
+
+}
+
+/* Function : ksi2c_bus_enable 
+ *  - Enable Keystone's I2C port.
+ * Return :
+ * Note :
+ */
+int ksi2c_bus_enable(si_t * sih, cc_i2c_id_t id, int en)
+{
+	ks_i2c_bus_t *i2cbus;
+	int retry;
+
+	ASSERT(sih);
+	if (!CC_I2C_ID_IS_VALID(id)) {
+		I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+		return KSI2C_ERR_PARAM;
+	}
+
+	i2cbus = ksi2c_bus + id;
+
+	if (KSI2C_BUS_ENABLED(i2cbus)) {
+		if (en) {
+			I2C_MSG(("Msg: %s, I2C_%d enabled already!\n", __func__, id));
+			return KSI2C_ERR_NONE;;
+		}
+	} else {
+		if (!en) {
+			I2C_MSG(("Msg: %s, I2C_%d disabled already!\n", __func__, id));
+			return KSI2C_ERR_NONE;;
+		}
+	}
+
+	/* check if the bus is not reserved and the i2c OP is IDLE */
+	for (retry = 0; retry < i2cbus->pio_retries; retry++) {
+		if (KSI2C_BUS_OP_IDLE_CHECK(i2cbus)) {
+			break;
+		}
+	}
+
+	if (retry == i2cbus->pio_retries) {
+		I2C_ERROR(("%s, Timeout on %s I2C_%d!\n",
+				__func__, (en) ? "Enabling" : "Disabling", id));
+		return KSI2C_ERR_TIMEOUT;
+	}
+
+	/* select the i2c interface */
+	if (si_i2c_select(sih, (uint8) id, (en) ? TRUE : FALSE)) {
+	I2C_ERROR(("%s, Failed on %s I2C_%d !",
+			__func__, (en) ? "Enabling" : "Disabling", id));
+	return KSI2C_ERR_INTERNAL;
+	}
+
+    /* check if the Serial IO interrupt need to open here 
+     *  - the interrupt flag will open the CC layer interrupt 
+     */
+	if (i2cbus->flags & KS_I2C_BUS_INTR) {
+		if (si_i2c_ccint_enable(sih, (uint8) id, en)) {
+			I2C_ERROR(("%s, Failed on %s I2C_%d !",
+					__func__, (en) ? "Enabling" : "Disabling", id));
+			return KSI2C_ERR_INTERNAL;
+		}
+	}
+	if (en) {
+		i2cbus->flags |= KS_I2C_BUS_ENABLED;
+	} else {
+		i2cbus->flags &= ~KS_I2C_BUS_ENABLED;
+	}
+
+	I2C_MSG(("DEBUG:%s,i2c_%d, enabling(%d) is DONE!\n",
+			__func__, id, en));
+	return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_bus_set_freq 
+ *  - set Keystone's I2C frequency
+ * Return :
+ * Note :
+ *  1. I2C clock is Keystone backplant
+ *  2. the unit of the speed is khz.
+ *  3. i2c_fre = sys_fre / (M+1)*2 ^(N+1))
+ *  4. System Clock will be retrieved from SI interface and a proper i2c 
+ *      clock value will be auto-generated and selected to match user's 
+ *      request frequency.
+ *      - This routine will choose a pair of 'm' and 'n' for the closest i2c 
+ *          clock. 
+ */
+int ksi2c_bus_set_freq(si_t * sih, cc_i2c_id_t id, uint32 speed_hz)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 ccr_val;
+    uint sys_clock, i2c_clock = 0;
+    int i;
+    int m, n;
+    uint i2c_clk_tmp = 0, diff0, diff1;
+    int found = 0;
+
+    ASSERT(sih);
+    if (!CC_I2C_ID_IS_VALID(id)) {
+		I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+		return KSI2C_ERR_PARAM;
+    }
+    i2cbus = ksi2c_bus + id;
+
+    /* check if the bus is not reserved and the i2c OP is IDLE */
+	for (i = 0; i < i2cbus->pio_retries; i++) {
+		if (KSI2C_BUS_OP_IDLE_CHECK(i2cbus)) {
+	    	break;
+		}
+	}
+
+	if (i == i2cbus->pio_retries) {
+		I2C_ERROR(("%s, Timeout on I2C_%d !\n", __func__, id));
+		return KSI2C_ERR_TIMEOUT;
+	}
+
+    /* -------- set i2c clock --------- */
+    /* get Fsys */
+    sys_clock = si_clock(sih);
+
+    /* retrive the M and N value */
+    diff0 = diff1 = 0;
+    /* i2c clock counting formula  : i2c_fre = sys_fre / (M+1)*2 ^(N+1)) */
+	for (n = 0; n < CCI2C_CCR_NMAX; n++) {
+		for (m = 0; m < CCI2C_CCR_MMAX; m++) {
+	    	i2c_clock = sys_clock / ((m + 1) * (2 << (n + 1)));
+
+	    /* 1. Normally, the i2c clock will be decreased when the m is 
+	     *      increased.
+	     * 2. When N is increased, the counted i2c clock will less than
+	     *      the clock in previous loop. 
+	     * >> Those faster clock value items when N is just increased can
+	     *      be skip to fast the search process for the clock 
+	     *      resolution will be large than previous n loop.
+	     */
+			if ((i2c_clk_tmp != 0) && (i2c_clock > i2c_clk_tmp)) {
+			/* i2c_clk_tmp!=0 means the previous clock is a valid clock */
+			continue;
+			}
+
+			if (i2c_clock > speed_hz) {
+				diff0 = ABS(i2c_clock - speed_hz);
+				i2c_clk_tmp = i2c_clock;
+			} else {
+				if (m == 0 && n == 0) {
+				/* means all valid i2c clock are slower than user's 
+				 * requested i2c clock!
+				 */
+					I2C_ERROR(("%s, sys_clock=%d, user's i2c_clock=%d is too " "fast to be configurred!\n", __func__, id));
+					return KSI2C_ERR_PARAM;
+				}
+				diff1 = ABS(i2c_clock - speed_hz);
+
+				found = 1;
+				break;
+			}
+	}
+		if (found) {
+			break;
+		}
+   }
+
+    if (found == 0) {
+		/* means all valid i2c clock are faster than user's 
+		 * requested i2c clock!
+		 */
+		I2C_ERROR(("%s, sys_clock=%d, user's i2c_clock=%d is too slow to "
+			"be configurred!\n", __func__, id));
+		return KSI2C_ERR_PARAM;
+	} else {
+		/* here can select a better frequency setting :
+		 *  - choose the most close to user's request frequency 
+		 */
+		if (diff0 < diff1) {	/* previous i2c clock will be selected */
+			if (m == 0) {
+				n--;
+			} else {
+				m--;
+			}
+			i2c_clock = i2c_clk_tmp;	/* set the clock back to previous */
+		}
+
+	i2cbus->m_val = m;
+	i2cbus->n_val = n;
+	ccr_val = ((m << CC_I2CCCR_MSHIFT) & CC_I2CCCR_MMASK) |
+	    (n & CC_I2CCCR_NMASK);
+	}
+
+    /* set to i2c_ccr register */
+    si_i2c_clock(sih, (uint8) id, ccr_val);
+
+    /* keep the current working frequency */
+    i2cbus->frequency = i2c_clock;
+    /*printf("I2C_Clock set to %d on i2c_bus%d\n",
+	   (i2cbus->frequency) / 1000, id);*/
+    I2C_MSG(("DEBUG:%s, frequency=%d !\n", __func__, i2cbus->frequency));
+
+    return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_bus_wait_for_iflg_set 
+ *  - wait the i2c interrupt flag.
+ * Return :
+ * Note :
+ */
+static int _ksi2c_bus_wait_for_iflg_set(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 i2creg_val = 0;
+    uint32 retry;
+
+    ASSERT(sih);
+    i2cbus = ksi2c_bus + id;
+    retry = i2cbus->pio_retries;
+
+    I2C_MSG(("%s,%d,Start..\n", __func__, __LINE__));
+    /* check if the i2c IFLG is set */
+	while (!((i2creg_val = si_i2c_control
+		(sih, (uint8) id, CCI2C_READREG_MASK, i2creg_val)) &
+		CC_I2CCTRL_INTFLAG) && --retry) {
+		OSL_DELAY(1);
+		i2creg_val = 0;		/* clear for read through SI interface */
+	}
+	I2C_MSG(("%s,%d,i2creg_val=%x,retry=%d\n",
+			__func__, __LINE__, i2creg_val, retry));
+
+	/* update the statistics to SW information */
+	i2cbus->iflg_polls = ABS((int) i2cbus->pio_retries - (int) retry);
+
+	return (retry > 0) ? KSI2C_ERR_NONE : KSI2C_ERR_TIMEOUT;
+}
+
+/* Function : ksi2c_bus_wait 
+ *  - wait the i2c interrupt flag.
+ * Return :
+ * Note :
+ */
+int ksi2c_bus_wait(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 i2creg_val = 0;
+    int rv = KSI2C_ERR_NONE;
+
+    ASSERT(sih);
+    i2cbus = ksi2c_bus + id;
+
+    if (i2cbus->flags & KS_I2C_BUS_INTR) {
+	/* wait interrupt till timeout */
+	/* ####### TBD : enable interrupt ####### */
+    } else {
+	/* PIO : poll IFLG = 1 */
+	rv = _ksi2c_bus_wait_for_iflg_set(sih, id);
+    }
+
+    /* get bus status */
+    i2creg_val = ksi2c_bus_status(sih, id);
+
+    I2C_MSG(("%s, current status=0x%x at I2C_%d\n", __func__, i2creg_val,
+	     id));
+    return rv;
+
+}
+
+/* Function : _ksi2c_bus_start_bit 
+ *  - Request to send a I2C Start bit (internal usage)
+ * Return :
+ * Note :
+ *  1. This is an single action routine and no error check is requirred. 
+ *      The caller need to confirm if the bus status is proper for 
+ *      sending start bit.
+ */
+static void _ksi2c_bus_start_bit(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 ctrlbyte = 0;
+
+    ASSERT(sih);
+    i2cbus = ksi2c_bus + id;
+
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte |= CC_I2CCTRL_MSTART;
+
+    /* If in interrupt mode, make sure I2C interrupt is disabled. */
+    if (i2cbus->flags & KS_I2C_BUS_INTR) {
+	/* ####### TBD : disable interrupt ####### */
+    }
+
+    /* send start bit */
+    ctrlbyte = si_i2c_control(sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* If in interrupt mode, make sure I2C interrupt is enabled. */
+    if (i2cbus->flags & KS_I2C_BUS_INTR) {
+	/* ####### TBD : enable interrupt ####### */
+    }
+    I2C_MSG(("%s,%d DONE!\n", __func__, __LINE__));
+
+}
+
+/* Function : _ksi2c_bus_next_bus_phase 
+ *  - Interrupt clear/next operation continue.  Clear the IFLG
+ * to trigger or complete a CPU initiated transaction.  If tx_ack is
+ * set, then an acknowledgement will be sent; usually tx_ack is only
+ * relevant for receive operations.
+ * Return :
+ * Purpose: 
+ * Note :
+ *    The nature of the next bus phase depends on the current state
+ *    of the I2C controller.
+
+ */
+static void
+_ksi2c_bus_next_bus_phase(si_t * sih, cc_i2c_id_t id, bool aack)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 ctrlbyte = 0;
+
+    ASSERT(sih);
+    i2cbus = ksi2c_bus + id;
+    ctrlbyte =
+	si_i2c_control(sih, (uint8) id, CCI2C_READREG_MASK, ctrlbyte);
+
+    /* clear the IFLG to start next phase */
+    ctrlbyte &= ~CC_I2CCTRL_INTFLAG;
+
+    /* AACK request */
+    if (aack) {
+	ctrlbyte |= CC_I2CCTRL_AAK;
+    } else {
+	ctrlbyte &= ~CC_I2CCTRL_AAK;
+    }
+
+    I2C_MSG(("%s,%d, set control to %x\n", __func__, __LINE__, ctrlbyte));
+    ctrlbyte = si_i2c_control(sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* if in the interrupt mode, re-enable the I2C interrupt */
+    if (i2cbus->flags & KS_I2C_BUS_INTR) {
+	/* ####### TBD : enable interrupt ####### */
+    }
+
+}
+
+/* Function : ksi2c_bus_start 
+ *  - Request to send a I2C Start.
+ * Return :
+ * Note :
+ * 
+ */
+int
+ksi2c_bus_start(si_t * sih, cc_i2c_id_t id, i2c_addr_t slave_addr,
+		bool op, bool rep)
+{
+    int rv;
+    ks_i2c_bus_t *i2cbus;
+    ks_i2c_status_t correct_next_stat = KS_I2C_NO_STATUS;
+    uint8 i2creg_val = 0;
+
+    ASSERT(sih);
+    ASSERT(CC_I2C_ID_IS_VALID(id));
+    I2C_MSG(("%s, id=%d,saddr=0x%x,op=%d,repeat=%d\n",
+	     __func__, id, slave_addr, op, rep));
+
+    i2cbus = ksi2c_bus + id;
+
+    /* check if the bus is not reserved and the i2c OP is IDLE and the has 
+     *  no bus event.
+     */
+    if (!rep) {
+	ASSERT(KSI2C_BUS_OP_IDLE_CHECK(i2cbus));
+    }
+
+    /* send START bit */
+    _ksi2c_bus_start_bit(sih, id);
+
+    if (rep) {
+	i2cbus->opcode = KS_I2C_REP_START;
+	correct_next_stat = KS_I2C_REP_START_TX;
+    } else {
+	i2cbus->opcode = KS_I2C_START;
+	correct_next_stat = KS_I2C_START_TX;
+    }
+
+    if (ksi2c_bus_wait(sih, id)) {
+	/* timeout occurred */
+	I2C_ERROR(("%s, TIMEOUT after START at I2C_%d\n", __func__, id));
+	rv = KSI2C_ERR_TIMEOUT;
+	goto err_stop;
+    } else {
+
+	if (i2cbus->stat == correct_next_stat) {
+	    i2c_addr_t saddr_internal;
+
+	    saddr_internal = (slave_addr << I2C_SADDR_ADDR_OFFSET) &
+		I2C_SADDR_ADDR_MASK;
+	    /*
+	     * We generated start, now send the slave's bus address byte 
+	     * with OP code added.
+	     * (7-bit address mode only)
+	     */
+	    i2creg_val = saddr_internal | ((op == I2C_OP_READ) ?
+					   I2C_OP_READ : I2C_OP_WRITE);
+	    I2C_MSG(("%s,%d,saddr+op(%x)\n", __func__, __LINE__,
+		     i2creg_val));
+	    i2creg_val =
+		si_i2c_data(sih, (uint8) id, CC_I2CDATA_MASK, i2creg_val);
+
+	    _ksi2c_bus_next_bus_phase(sih, id, FALSE);
+
+	} else {
+	    I2C_ERROR(("%s, unhandled status at I2C_%d\n", __func__, id));
+	    rv = KSI2C_ERR_UNKNOW;
+	    goto err_stop;
+	}
+    }
+
+    /*
+     * Now, wait again for an interrupt. One of four possible
+     * interrupts should occur:
+     *
+     * Ready for IO: (R/W)
+     *    KS_I2C_ADDR_WR_BIT_TX_ACK_RX - Device ready for writing
+     *    KS_I2C_ADDR_RD_BIT_TX_ACK_RX - Device ready for reading
+     * No Device :
+     *    KS_I2C_ADDR_WR_BIT_TX_NO_ACK_RX - No device ready
+     *                                       for write
+     *    KS_I2C_ADDR_RD_BIT_TX_NO_ACK_RX - No device ready
+     *                                       for read
+     */
+    if ((rv = ksi2c_bus_wait(sih, id)) == KSI2C_ERR_NONE) {
+
+	ks_i2c_status_t bus_status = ksi2c_bus_status(sih, id);
+
+	if (bus_status == KS_I2C_ADDR_WR_BIT_TX_ACK_RX) {
+	    i2cbus->opcode = KS_I2C_TX;
+	    rv = KSI2C_ERR_NONE;
+	} else if (bus_status == KS_I2C_ADDR_RD_BIT_TX_ACK_RX) {
+	    i2cbus->opcode = KS_I2C_RX;
+	    rv = KSI2C_ERR_NONE;
+	} else if (bus_status == KS_I2C_ADDR_RD_BIT_TX_NO_ACK_RX ||
+		   bus_status == KS_I2C_ADDR_WR_BIT_TX_NO_ACK_RX) {
+	    I2C_MSG(("%s, i2c device (saddr=0x%02x) no response\n",
+		     __func__, slave_addr));
+	    rv = KSI2C_ERR_TIMEOUT;
+	} else {
+	    I2C_MSG(("%s, i2c device (saddr=0x%02x) no response\n",
+		     __func__, slave_addr));
+	    rv = KSI2C_ERR_INTERNAL;
+	}
+
+    } else {
+	I2C_MSG(("%s,TIMEOUT on retriving the bus status at I2C_%d\n",
+		 __func__, id));
+	rv = KSI2C_ERR_TIMEOUT;
+    }
+
+  err_stop:
+    if (rv != KSI2C_ERR_NONE) {
+	/* Very important, if anything went wrong,
+	 * we MUST release the bus to return to idle state!
+	 * >> Caller need to handle the error return and issue STOP.
+	 */
+	I2C_MSG(("%s, Need STOP to release bus to idle state!!\n",
+		 __func__));
+    }
+
+    return rv;
+
+}
+
+/* Function : ksi2c_bus_repstart 
+ *  - Request to send a I2C repeat Start.
+ * Return :
+ * Note :
+ *  Caller need to issue STOP if error returned.
+ */
+int
+ksi2c_bus_repstart(si_t * sih, cc_i2c_id_t id, i2c_addr_t slave_addr,
+		   bool op)
+{
+    return ksi2c_bus_start(sih, id, slave_addr, op, TRUE);
+}
+
+/* Function : _ksi2c_stop_bits 
+ *  - Generate stop condition on the I2C Bus.
+ *           This also recovers from an I2C bus error.
+ * Return :
+ * Note :
+ */
+static void _ksi2c_bus_stop_bits(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+    uint8 ctrlbyte = 0;
+
+    ASSERT(sih);
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+	return;
+    }
+    i2cbus = ksi2c_bus + id;
+
+    /*
+     *  Clear Intr from any previous phase, and initiate STOP phase.
+     *      IFLG will NOT set when the STOP phase has completed.
+     */
+    ctrlbyte = CC_I2CCTRL_BUSEN | CC_I2CCTRL_MSTOP;
+
+    /* send stop bit */
+    I2C_MSG(("%s,%d,set control(%x)\n", __func__, __LINE__, ctrlbyte));
+    ctrlbyte = si_i2c_control(sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* If in interrupt mode, leave I2C interrupt unmasked (enabled). */
+    if ((i2cbus->flags & KS_I2C_BUS_INTR)) {
+	/* ####### TBD : disable interrupt ####### */
+    }
+}
+
+/* Function : ksi2c_bus_stop 
+ *  - Generate stop condition on the I2C bus. This routine is
+ *          used to signal the end of a data transfer and releases
+ *          the bus according to the I2C protocol.
+ * Return :
+ * Note :
+ */
+int ksi2c_bus_stop(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+
+    ASSERT(sih);
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    i2cbus->opcode = KS_I2C_STOP;
+    _ksi2c_bus_stop_bits(sih, id);
+
+    return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_bus_nbytes_read 
+ *  - Request to read n bytes with or without ack at latest byte.
+ * Parameters:
+ *    data - address to place data byte received from slave
+ *    len - (in)  number of bytes to read from slave.
+ *          (out) number of bytes actually read.
+ *    ack_last_byte -
+ *             if set, an ACK will automatically be sent by the
+ *             controller for the last byte read from the slave.
+ *             If not set, a NAK is pulsed when the last byte
+ *             has been received. Set when a master would like
+ *             to signify that this block read is NOT the last
+ *             data to be read from the slave.
+ * Return :
+ * Note :
+ *  1. The ack_last_byte field only affects the last byte; this
+ *       allows support for the following I2C byte read transactions:
+ *
+ *       START Addr Rd [ACK] [Data] ACK REPSTART ...
+ *       START Addr Rd [ACK] [Data] NAK REPSTART ...
+ *
+ *       START Addr Rd [ACK] [Data] ACK [DATA] ACK STOP
+ *       START Addr Rd [ACK] [Data] ACK [DATA] NAK STOP
+ *
+ *       We always transmit an ACK when two or more bytes
+ *       remain to be read, i.e. the non-last byte(s).
+ *
+ *       Before this routine can be used, the I2C controller must
+ *       be in a read-ready state, i.e. following a START-READ_SADDR
+ *       phase or a previous read operation.
+ */
+int
+ksi2c_bus_nbytes_read(si_t * sih, cc_i2c_id_t id, uint8 * data,
+		      int *len, bool aack_last_byte)
+{
+    int aack;
+    uint32 nread, nbytes;
+    uint8 *ptr;
+    ks_i2c_bus_t *i2cbus;
+    uint8 i2creg_val = 0;
+    ks_i2c_status_t s;
+
+    ASSERT(sih);
+    if (!len || (*len <= 0)) {
+	return KSI2C_ERR_PARAM;
+    }
+
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;	/* Make sure we're in a read-ready state. */
+    if (i2cbus->opcode != KS_I2C_RX) {
+	return KSI2C_ERR_INTERNAL;
+    }
+
+    nbytes = *len;
+    ptr = data;
+
+    I2C_MSG(("%s,%d,STARTing to read %d bytes...\n", __func__, __LINE__,
+	     *len));
+    /* Read up to len bytes ... */
+    *len = 0;
+
+    /*
+     * Some sort of start condition and slave address has been sent
+     * by the I2C controller (master) and ACK'd by the slave device,
+     * or one or more bytes have already been read.
+     * The I2C controller is now in a state that will perform byte
+     * reads until a stop or repeat start is explicitly initiated.
+     * We'll only do the requested number of byte reads here, and
+     * leave it up to the calling code to do the stop or start.
+     */
+    for (nread = 0; nread < nbytes; nread++) {
+	/* ACK the byte we're about to read */
+	if (!aack_last_byte) {
+	    aack = (nread == nbytes - 1) ? 0 : 1;
+	} else {
+	    aack = 1;
+	}
+	I2C_MSG(("%s,%d,read byte_%d,aack=%d\n",
+		 __func__, __LINE__, nread, aack));
+
+	/* Initiate the next byte read. */
+	_ksi2c_bus_next_bus_phase(sih, id, aack);
+
+	if (KSI2C_ERR_NONE != ksi2c_bus_wait(sih, id)) {
+	    I2C_MSG(("%s, no IFLG at i2c_%d\n", __func__, id));
+	    return KSI2C_ERR_TIMEOUT;
+	} else {
+
+	    /* Store the read data byte, or deal with error condition. */
+	    if (((s =
+		  ksi2c_bus_status(sih, id)) == KS_I2C_DATA_BYTE_RX_ACK_TX)
+		|| (s == KS_I2C_DATA_BYTE_RX_NO_ACK_TX)) {
+
+		i2cbus->opcode = KS_I2C_RX;
+		i2creg_val =
+		    si_i2c_data(sih, (uint8) id, CCI2C_READREG_MASK, 0);
+
+		*ptr++ = (uint8) i2creg_val;
+		*len = *len + 1;
+	    } else {
+		return KSI2C_ERR_INTERNAL;
+	    }
+	}
+    }				/* read nbytes bytes */
+
+    return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_bus_byte_write 
+ *  - Request to write n bytes to i2c device 
+ * Parameters:
+ *    data - address to place data byte received from slave
+ *    len - (in)  number of bytes to write to slave.
+ *          (out) number of bytes actually write.
+ * Return :
+ * Note :
+ */
+int
+ksi2c_bus_nbytes_write(si_t * sih, cc_i2c_id_t id, uint8 * data,
+		       uint * len)
+{
+    uint32 nwrite, nbytes;
+    uint8 i2creg_val = 0;
+    ks_i2c_bus_t *i2cbus;
+    ks_i2c_status_t s;
+
+    ASSERT(sih);
+    if (!len || (*len <= 0) || (data == NULL)) {
+	return KSI2C_ERR_PARAM;
+    }
+
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("%s,Invalid I2C Bus ID!\n", __func__));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;	/* Make sure we're in a write-ready state. */
+    if (i2cbus->opcode != KS_I2C_TX) {
+	I2C_ERROR(("%s,Improper OP state=%d\n", __func__, i2cbus->opcode));
+	return KSI2C_ERR_INTERNAL;
+    }
+
+    nbytes = *len;
+    /* Write up to len bytes ... */
+    *len = 0;
+
+    /*
+     * Some sort of start condition and slave address has been sent
+     * by the I2C controller (master) and ACK'd by the slave device,
+     * or one or more bytes have already been write.
+     * The I2C controller is now in a state that will perform byte
+     * writes until a stop or repeat start is explicitly initiated.
+     * We'll only do the requested number of byte wrties here, and
+     * leave it up to the calling code to do the stop or start.
+     */
+    for (nwrite = 0; nwrite < nbytes; nwrite++) {
+
+	/* write byte to i2c device */
+	i2creg_val =
+	    si_i2c_data(sih, (uint8) id, CC_I2CDATA_MASK,
+			(uint8) data[nwrite]);
+
+	_ksi2c_bus_next_bus_phase(sih, id, FALSE);
+
+	/* wait for next tx byte */
+	if (KSI2C_ERR_NONE != ksi2c_bus_wait(sih, id)) {
+	    I2C_MSG(("%s, no IFLG at i2c_%d\n", __func__, id));
+	    return KSI2C_ERR_TIMEOUT;
+	} else {
+
+	    if ((s =
+		 ksi2c_bus_status(sih,
+				  id)) == KS_I2C_DATA_BYTE_TX_ACK_RX) {
+
+		i2cbus->opcode = KS_I2C_TX;
+		*len = *len + 1;
+
+	    } else {
+		/* Standard allowed "KS_I2C_DATA_BYTE_TX_NO_ACK_RX" when the 
+		 * latest byte was write. 
+		 */
+		if (s == KS_I2C_DATA_BYTE_TX_NO_ACK_RX) {
+		    if (nwrite == (nbytes - 1)) {
+			I2C_MSG(("%s,No ACK on the latest byte write!\n",
+				 __func__));
+			*len = *len + 1;
+		    } else {
+			I2C_MSG(("%s, No ACK after one byte write\n",
+				 __func__));
+			return KSI2C_ERR_INTERNAL;
+		    }
+		} else {
+		    I2C_MSG(("%s, unexpected status after one byte write "
+			     "at i2c_%d\n", __func__, id));
+		    return KSI2C_ERR_INTERNAL;
+		}
+	    }
+	}
+
+    }
+
+    return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_bus_status 
+ *     - get i2c bus interrupt flags(31 events).
+ * Return :
+ *     - Return the current I2C status.
+ * Note :
+ */
+uint8 ksi2c_bus_status(si_t * sih, cc_i2c_id_t id)
+{
+    uint8 i2c_status = 0;
+    ks_i2c_bus_t *i2cbus;
+
+    ASSERT(sih);
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    if (si_i2c_status(sih, id, CC_I2CSTS_MASK, &i2c_status)) {
+	I2C_ERROR(("%s,I2C_%d bus error\n", __func__, id));
+	i2c_status = CC_I2CSTS_BUS_ERR;	/* value = 0 */
+    }
+    i2c_status &= CC_I2CSTS_MASK;
+    i2cbus->stat = i2c_status;
+
+    return i2c_status;
+
+}
+
+/* Function : ksi2c_bus_reset 
+ *  -reset the Keystone's I2C bus to IDLE state.
+ * Return :
+ * Note :
+ *  1. Any I2C transaction will be stopped
+ */
+void ksi2c_bus_reset(si_t * sih, cc_i2c_id_t id)
+{
+    ASSERT(sih);
+    si_i2c_swreset(sih, id, CC_I2CRESET_MASK, CC_I2CRESET_VAL);
+    /* CHECK about the proper time for wait */
+    OSL_DELAY(100);
+}
+
+/* Function : ksi2c_bus_detach 
+ *  - Detach the Keystone's I2C bus handler.
+ * Return :
+ * Note :
+ */
+int ksi2c_bus_detach(si_t * sih, cc_i2c_id_t id)
+{
+    ks_i2c_bus_t *i2cbus;
+
+    ASSERT(sih);
+    if (!CC_I2C_ID_IS_VALID(id)) {
+	I2C_ERROR(("Invalid I2C Bus ID!\n", __func__));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    /* clear all assigned info on this i2c bus */
+    bzero(i2cbus, sizeof(*i2cbus));
+
+    return KSI2C_ERR_NONE;;
+}
+
+
+/* --------- I2C High level driver --------- 
+ * The drivers in this level also know as general I2C driver. 
+ *  - Request the I2C read/write on I2C device through I2C bus driver.
+ * Function : ksi2c_init 
+ * Function : ksi2c_open 
+ * Function : ksi2c_write 
+ * Function : ksi2c_read 
+ * Function : ksi2c_rw_pack 
+ * Function : ksi2c_close 
+ */
+
+/* Function : ksi2c_init 
+ *  - init Keystone's I2C bus_0 and bus_1.
+ * Return :
+ * Note :
+ *  1. disable all i2c buses.
+ *  2. reset all i2c buses.
+ */
+int ksi2c_init(void)
+{
+    int rv = KSI2C_ERR_NONE;
+    int i2c_id;
+
+    ksi2c_sih = si_kattach(SI_OSH);
+
+#if KSI2C_BUS_DRIVER_READY
+    ks_i2c_bus_t *i2cbus;
+
+    for (i2c_id = 0; i2c_id < CC_I2C_NUM_BUS; i2c_id++) {
+	/* driver handler reset */
+	i2cbus = ksi2c_bus + i2c_id;
+	ASSERT(i2cbus);
+	bzero(i2cbus, sizeof(*i2cbus));
+
+	/* force bus reset to prevent any unexpected status on the bus */
+	ksi2c_bus_reset(ksi2c_sih, i2c_id);
+
+	/* disable I2C bus and mask off the relevant interrupt */
+	rv |= ksi2c_bus_enable(ksi2c_sih, i2c_id, FALSE);
+
+    }
+#else				/* KSI2C_BUS_DRIVER_READY */
+
+
+    for (i2c_id = 0; i2c_id < CC_I2C_NUM_BUS; i2c_id++) {
+	/* force bus reset to prevent any unexpected status on the bus */
+	ksi2c_bus_reset(ksi2c_sih, i2c_id);
+
+	/* disable the i2c interface */
+	if (si_i2c_select(ksi2c_sih, (uint8) i2c_id, FALSE)) {
+	    I2C_ERROR(("%s,Failed on disabling I2C_%d!", __func__,
+		       i2c_id));
+	    rv |= KSI2C_ERR_INTERNAL;
+	}
+    }
+#endif				/* KSI2C_BUS_DRIVER_READY */
+
+    return rv;
+}
+
+
+/* Function : ksi2c_reset 
+ *  - reset Keystone's I2C.
+ * Return : 
+ * Note :
+ */
+void ksi2c_reset(cc_i2c_id_t id)
+{
+    if (ksi2c_sih == NULL) {
+	printf("\n i2c not init yet! \n", id);
+	return;
+    }
+    ksi2c_bus_reset(ksi2c_sih, id);
+}
+
+/* Function : ksi2c_open 
+ *  - open Keystone's I2C.
+ * Return :
+ * Note :
+ */
+int ksi2c_open(cc_i2c_id_t id, uint32 flags, int speed_khz)
+{
+    KSI2C_INIT_CHK;
+#if KSI2C_BUS_DRIVER_READY
+    if (ksi2c_bus_attach(ksi2c_sih, id, flags, speed_khz)) {
+	I2C_ERROR(("%s, Failed on attaching I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_INTERNAL;
+    }
+
+    if (ksi2c_bus_enable(ksi2c_sih, id, TRUE)) {
+	I2C_ERROR(("%s, Failed on enabling I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_INTERNAL;
+    }
+#else				/* KSI2C_BUS_DRIVER_READY */
+
+    /* select the i2c interface */
+    if (si_i2c_select(ksi2c_sih, (uint8) id, TRUE)) {
+	I2C_ERROR(("%s, Failed on %s I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_INTERNAL;
+    }
+
+    /* set bus clock */
+    uint32 m, n, speed_hz;
+    uint8 feq;
+    uint sys_clock, i2c_clock = 0, i2c_clk_tmp = 0, diff0, diff1;
+    int found = 0;
+
+    /* get Fsys */
+    sys_clock = si_clock();
+
+    /* Use default speed if zero or bad value specified */
+    if ((speed_khz <= 0) || (speed_khz > KS_I2C_SPEED_HIGH)) {
+	speed_khz = KS_I2C_SPEED_DEFAULT;
+    }
+    speed_hz = KHZ_TO_HZ(speed_khz);
+
+    /* retrive the M and N value */
+    diff0 = diff1 = 0;
+    /* i2c clock counting formula  : i2c_fre = sys_fre / (M+1)*2 ^(N+1)) */
+    for (n = 0; n < CCI2C_CCR_NMAX; n++) {
+	for (m = 0; m < CCI2C_CCR_MMAX; m++) {
+	    i2c_clock = sys_clock / (m + 1) * (2 << (n + 1));
+
+	    /* 1. Normally, the i2c clock will be decreased when the m is 
+	     *      increased.
+	     * 2. When N is increased, the counted i2c clock will less than
+	     *      the clock in previous loop. 
+	     * >> Those faster clock value items when N is just increased can
+	     *      be skip to fast the search process for the clock 
+	     *      resolution will be large than previous n loop.
+	     */
+	    if ((i2c_clk_tmp != 0) && (i2c_clock > i2c_clk_tmp)) {
+		/* i2c_clk_tmp!=0 means the previous clock is a valid clock */
+		continue;
+	    }
+
+	    if (i2c_clock > speed_hz) {
+		diff0 = ABS(i2c_clock - speed_hz);
+		i2c_clk_tmp = i2c_clock;
+	    } else {
+		if (m == 0 && n == 0) {
+		    /* means all valid i2c clock are slower than user's 
+		     * requested i2c clock!
+		     */
+		    I2C_ERROR(("%s, sys_clock=%d, user's i2c_clock=%d is too " "fast to be configurred!\n", __func__, id));
+		    return KSI2C_ERR_PARAM;
+		}
+		diff1 = ABS(i2c_clock - speed_hz);
+
+		found = 1;
+		break;
+	    }
+	}
+	if (found) {
+	    break;
+	}
+    }
+
+    if (found == 0) {
+	/* means all valid i2c clock are faster than user's 
+	 * requested i2c clock!
+	 */
+	I2C_ERROR(("%s, sys_clock=%d, user's i2c_clock=%d is too slow to "
+		   "be configurred!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    } else {
+	/* here can select a better frequency setting :
+	 *  - choose the most close to user's request frequency 
+	 */
+	if (diff0 < diff1) {	/* previous i2c clock will be selected */
+	    if (m == 0) {
+		n--;
+	    } else {
+		m--;
+	    }
+	    i2c_clock = i2c_clk_tmp;	/* set the clock back to previous */
+	}
+
+	feq = ((m << CC_I2CCCR_MSHIFT) & CC_I2CCCR_MMASK) |
+	    (n & CC_I2CCCR_NMASK);
+    }
+
+    I2C_MSG(("%s, setting I2C_%d CCR=%x!\n", __func__, id, feq));
+    if (si_i2c_clock(ksi2c_sih, (uint8) id, feq)) {
+	I2C_ERROR(("%s, failed on setting I2C_%d clock!\n", __func__, id));
+    }
+#endif				/* KSI2C_BUS_DRIVER_READY */
+    return KSI2C_ERR_NONE;
+}
+
+/* Function : ksi2c_write 
+ *  - Write operation through Keystone's I2C.
+ * Return :
+ * Note : 
+ */
+int
+ksi2c_write(cc_i2c_id_t id, i2c_addr_t slave_addr, uint8 * data, int len)
+{
+#if KSI2C_BUS_DRIVER_READY
+    ks_i2c_bus_t *i2cbus;
+    int rv, retry;
+
+    KSI2C_INIT_CHK;
+    if (data == NULL || len == 0) {
+	I2C_ERROR(("%s, No data to write at I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    if (!KSI2C_BUS_ENABLED(i2cbus)) {
+	I2C_ERROR(("%s,I2C_%d is not enabled yet!\n", __func__, id));
+	return KSI2C_ERR_UNAVAIL;
+    }
+
+    I2C_MSG(("%s, i2c_%d WRITE starting (saddr=0x%02x, len=%d)...\n",
+	     __func__, id, slave_addr, len));
+
+    /* check bus idle status */
+    for (retry = 0; retry < i2cbus->pio_retries; retry++) {
+	if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus)) {
+	    ks_i2c_status_t bus_status;
+
+	    bus_status = ksi2c_bus_status(ksi2c_sih, id);
+	    if (bus_status == CC_I2CSTS_BUS_ERR) {
+		rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+		goto fail_i2c_transaction;
+	    } else {
+		if (bus_status == CC_I2CSTS_NO_STATUS) {
+		    i2cbus->opcode = KS_I2C_IDLE;
+		    break;
+		}
+	    }
+	} else {
+	    break;
+	}
+    }
+
+    if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus) || retry == i2cbus->pio_retries) {
+	rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+	goto fail_i2c_transaction;
+    } else {
+	/* start the i2c read transaction */
+	I2C_MSG(("%s,Send START..\n", __func__));
+	/* start with slave_addr + op */
+	rv = ksi2c_bus_start(ksi2c_sih, id,
+			     slave_addr, I2C_OP_WRITE, FALSE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on START stage in Read I2C OP\n",
+		       __func__));
+	    goto fail_i2c_transaction;
+	}
+
+	/* data write */
+	I2C_MSG(("%s,write bytes..\n", __func__));
+	rv = ksi2c_bus_nbytes_write(ksi2c_sih, id, data, (uint *) & len);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on DATA stage in Write I2C OP! rv=%d"
+		       "(%d bytes write already)\n", __func__, rv, len));
+	    goto fail_i2c_transaction;
+	}
+
+	/* stop */
+	I2C_MSG(("%s,send STOP..\n", __func__));
+	rv = ksi2c_bus_stop(ksi2c_sih, id);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on STOP stage in Write I2C OP"
+		       "(%d bytes sent already)\n", __func__, len));
+	    goto fail_i2c_transaction;
+	}
+
+	return KSI2C_ERR_NONE;
+    }
+
+  fail_i2c_transaction:
+    if (rv == KSI2C_ERR_TIMEOUT || rv == KSI2C_ERR_UNKNOW ||
+	rv == KSI2C_ERR_INTERNAL) {
+	I2C_ERROR(("%s, Bus receovering through STOP\n", __func__));
+	if (ksi2c_bus_stop(ksi2c_sih, id)) {
+	    I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	    ksi2c_bus_reset(ksi2c_sih, id);
+	}
+    } else if (rv == KSI2C_ERR_BUS) {
+	I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	ksi2c_bus_reset(ksi2c_sih, id);
+    } else {
+	I2C_ERROR(("%s, rv=%d, i2c write failed!\n", __func__, rv));
+    }
+    return rv;
+
+#else				/* KSI2C_BUS_DRIVER_READY */
+
+    uint8 databyte = 0, ctrlbyte = 0, i2c_iflg = CC_I2CSTS_NO_STATUS;
+    uint8 temp_val;
+    int i, retry;
+    i2c_addr_t saddr_internal;
+
+    saddr_internal = (slave_addr << I2C_SADDR_ADDR_OFFSET) &
+	I2C_SADDR_ADDR_MASK;
+
+    KSI2C_INIT_CHK;
+    if (data == NULL || len == 0) {
+	I2C_ERROR(("%s, No data to write at I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    } else {
+	if (len > sizeof(data)) {
+	    I2C_ERROR(("%s, Unexpected Data size!\n", __func__));
+	    return KSI2C_ERR_PARAM;
+	}
+    }
+
+    /* 0. start the transaction and check IFLG */
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte |= CC_I2CCTRL_MSTART;
+    ctrlbyte =
+	si_i2c_control(ksi2c_sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after START(expect:0x08)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    I2C_MSG(("%s,%d,retry=%d!!\n", __func__, __LINE__, retry));
+
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to write at I2C_%d, TIMEOUT!\n", __func__,
+		   id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+    /* 1. set addr+op to i2c data buffer 
+     *  - Note if the slave_addr is pre-shift already.
+     */
+    databyte = saddr_internal | (I2C_OP_WRITE & I2C_SADDR_OP_MASK);
+    temp_val =
+	si_i2c_data(ksi2c_sih, (uint8) id, CC_I2CDATA_MASK, databyte);
+
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte = si_i2c_control(ksi2c_sih, (uint8) id,
+			      CC_I2CCTRL_MASK, ctrlbyte);
+
+    I2C_MSG(("%s,%d,saddr+op!!!!\n", __func__, __LINE__));
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after SADDR(expect:0x18)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    I2C_MSG(("%s,%d,retry=%d!!\n", __func__, __LINE__, retry));
+
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to write at I2C_%d, TIMEOUT!\n", __func__,
+		   id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+    /* 2. write n bytes data */
+    for (i = 0; i < len; i++) {
+	databyte = data[i];
+	I2C_MSG(("%s,%d,writing #%d byte = 0x%02x!\n",
+		 __func__, __LINE__, i, databyte));
+	temp_val = si_i2c_data(ksi2c_sih, (uint8) id,
+			       CC_I2CDATA_MASK, databyte);
+
+	/* reset IFLG for write data byte */
+	I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+	ctrlbyte = si_i2c_control(ksi2c_sih, (uint8) id,
+				  CC_I2CCTRL_MASK, ctrlbyte);
+
+	/* 2.1 check IFLG and clear IFLG for going to next process */
+	for (retry = 0; retry < 1000; retry++) {
+	    OSL_DELAY(1);	/* delay 1 us and timeout after 1 S. */
+
+	    if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+		continue;
+	    }
+	    if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+		I2C_MSG(("%s, IFLG=[%02x] after DATA[%d](expect:0x28)\n",
+			 __func__, i2c_iflg, i));
+		break;
+	    }
+	}
+	if (retry == 1000) {
+	    I2C_ERROR(("%s, failed to write at I2C_%d, TIMEOUT!\n",
+		       __func__, id));
+	    return KSI2C_ERR_TIMEOUT;
+	}
+    }
+
+    /* 2.2 check IFLG after latest date byte write */
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after DATA[%d](expect:0x28/0x30)\n",
+		     __func__, i2c_iflg, i));
+	    break;
+	}
+    }
+    if (retry == 1000000) {
+	I2C_ERROR(("%s, failed to write at I2C_%d, TIMEOUT!\n",
+		   __func__, id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+    /* 3. Stop transaction */
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte |= CC_I2CCTRL_MSTOP;
+    ctrlbyte =
+	si_i2c_control(ksi2c_sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* check the IFLG */
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	if (i2c_iflg == CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after STOP(expect:0xf8)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to send STOP at I2C_%d, TIMEOUT!\n",
+		   __func__, id));
+	return KSI2C_ERR_TIMEOUT;
+    } else {
+	I2C_MSG(("%s, write DONE at I2C_%d\n", __func__, id));
+	return KSI2C_ERR_NONE;;
+    }
+    I2C_MSG(("%s, write DONE at I2C_%d\n", __func__, id));
+    return KSI2C_ERR_NONE;;
+
+
+#endif				/* KSI2C_BUS_DRIVER_READY */
+}
+
+/* Function : ksi2c_i2cdev_read 
+ *  - Read operation through Keystone's I2C with i2c device's address 
+ *      indicated for read operation.
+ * Return :
+ * Note :
+ *  1. Parameters :
+ *      - data : the data buffer for reporting the read data.
+ *      - len : the length of the read data.
+ *      - dev_addr : The input value to indicate the i2c device's address for 
+ *              this read opration.
+ *      - dev_addr_len : the i2c device's address lengh (byte unit)
+ *      >> P.S. the real length of data and dev_addr must be verified before 
+ *              calling this API.
+ *  2. Normally, this API is used for reading the i2c device at a specific 
+ *      device address. For the i2c deivce may have different length of 
+ *      address format, this API need user to tell the length(byte) of device 
+ *      address and the i2c protocol will preform a i2c_write befor i2c_read  
+ *      to tell the device about the target address for read operation. 
+ */
+int
+ksi2c_i2cdev_read(cc_i2c_id_t id,
+		  i2c_addr_t slave_addr, uint8 * data, int len,
+		  uint32 dev_addr, int dev_addr_len)
+{
+    ks_i2c_bus_t *i2cbus;
+    int rv, retry, temp_len;
+
+    KSI2C_INIT_CHK;
+    if (data == NULL || len == 0) {
+	I2C_ERROR(("%s, No data to READ at I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    }
+
+    if (dev_addr_len == 0) {
+	I2C_ERROR(("%s, No device address to READ at I2C_%d!\n",
+		   __func__, id));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    if (!KSI2C_BUS_ENABLED(i2cbus)) {
+	I2C_ERROR(("%s,I2C_%d is not enabled yet!\n", __func__, id));
+	return KSI2C_ERR_UNAVAIL;
+    }
+
+    I2C_MSG(("%s, i2c_%d Dev_READ starting (saddr=0x%02x, len=%d)...\n",
+	     __func__, id, slave_addr, len));
+
+    /* check bus idle status */
+    for (retry = 0; retry < i2cbus->pio_retries; retry++) {
+	if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus)) {
+	    ks_i2c_status_t bus_status;
+
+	    bus_status = ksi2c_bus_status(ksi2c_sih, id);
+	    if (bus_status == CC_I2CSTS_BUS_ERR) {
+		rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+		goto fail_i2c_transaction;
+	    } else {
+		if (bus_status == CC_I2CSTS_NO_STATUS) {
+		    i2cbus->opcode = KS_I2C_IDLE;
+		    break;
+		}
+	    }
+	} else {
+	    break;
+	}
+    }
+
+    if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus) || retry == i2cbus->pio_retries) {
+	rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+	goto fail_i2c_transaction;
+    } else {
+	/* start the i2c read transaction */
+	I2C_MSG(("%s,Send START..\n", __func__));
+	/* start with slave_addr + op */
+	rv = ksi2c_bus_start(ksi2c_sih, id,
+			     slave_addr, I2C_OP_WRITE, FALSE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on START stage in Read I2C OP\n",
+		       __func__));
+	    goto fail_i2c_transaction;
+	}
+
+	/* i2c device address write */
+	I2C_MSG(("%s,write dev_addr..\n", __func__));
+	temp_len = dev_addr_len;
+	rv = ksi2c_bus_nbytes_write(ksi2c_sih, id, (uint8 *) & dev_addr,
+				    (uint *) & temp_len);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on DATA stage in Write I2C OP! rv=%d"
+		       "(%d bytes write already)\n",
+		       __func__, rv, dev_addr_len));
+	    goto fail_i2c_transaction;
+	}
+
+	/* Rep-start the i2c read transaction */
+	I2C_MSG(("%s,Send START..\n", __func__));
+	/* start with slave_addr + op */
+	rv = ksi2c_bus_start(ksi2c_sih, id, slave_addr, I2C_OP_READ, TRUE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on START stage in Read I2C OP\n",
+		       __func__));
+	    goto fail_i2c_transaction;
+	}
+
+	/* data read */
+	I2C_MSG(("%s,read bytes..\n", __func__));
+	bzero(data, len);	/* set to zero on data */
+	rv = ksi2c_bus_nbytes_read(ksi2c_sih, id, data, &len, FALSE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on DATA stage in Read I2C OP"
+		       "(%d bytes sent already)\n", __func__, len));
+	    goto fail_i2c_transaction;
+	}
+
+	/* stop */
+	I2C_MSG(("%s,send STOP..\n", __func__));
+	rv = ksi2c_bus_stop(ksi2c_sih, id);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on STOP stage in Read I2C OP"
+		       "(%d bytes sent already)\n", __func__, len));
+	    goto fail_i2c_transaction;
+	}
+
+	return KSI2C_ERR_NONE;
+    }
+
+  fail_i2c_transaction:
+    if (rv == KSI2C_ERR_TIMEOUT || rv == KSI2C_ERR_UNKNOW ||
+	rv == KSI2C_ERR_INTERNAL) {
+	I2C_ERROR(("%s, Bus receovering through STOP\n", __func__));
+	if (ksi2c_bus_stop(ksi2c_sih, id)) {
+	    I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	    ksi2c_bus_reset(ksi2c_sih, id);
+	}
+    } else if (rv == KSI2C_ERR_BUS) {
+	I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	ksi2c_bus_reset(ksi2c_sih, id);
+	/* check if i2c clock is requirred to set again after reset */
+    } else {
+	I2C_ERROR(("%s, rv=%d, i2c read failed!\n", __func__, rv));
+    }
+    return rv;
+}
+
+/* Function : ksi2c_read 
+ *  - Read operation through Keystone's I2C.
+ * Return :
+ * Note :
+ */
+int
+ksi2c_read(cc_i2c_id_t id, i2c_addr_t slave_addr, uint8 * data, int len)
+{
+#if KSI2C_BUS_DRIVER_READY
+    ks_i2c_bus_t *i2cbus;
+    int rv, retry;
+
+    KSI2C_INIT_CHK;
+    if (data == NULL || len == 0) {
+	I2C_ERROR(("%s, No data to READ at I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    }
+
+    i2cbus = ksi2c_bus + id;
+
+    if (!KSI2C_BUS_ENABLED(i2cbus)) {
+	I2C_ERROR(("%s,I2C_%d is not enabled yet!\n", __func__, id));
+	return KSI2C_ERR_UNAVAIL;
+    }
+
+    I2C_MSG(("%s, i2c_%d READ starting (saddr=0x%02x, len=%d)...\n",
+	     __func__, id, slave_addr, len));
+
+    /* check bus idle status */
+    for (retry = 0; retry < i2cbus->pio_retries; retry++) {
+	if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus)) {
+	    ks_i2c_status_t bus_status;
+
+	    bus_status = ksi2c_bus_status(ksi2c_sih, id);
+	    if (bus_status == CC_I2CSTS_BUS_ERR) {
+		rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+		goto fail_i2c_transaction;
+	    } else {
+		if (bus_status == CC_I2CSTS_NO_STATUS) {
+		    i2cbus->opcode = KS_I2C_IDLE;
+		    break;
+		}
+	    }
+	} else {
+	    break;
+	}
+    }
+
+    if (!KSI2C_BUS_OP_IDLE_CHECK(i2cbus) || retry == i2cbus->pio_retries) {
+	rv = KSI2C_ERR_BUS;	/* set bus error here for reset */
+	goto fail_i2c_transaction;
+    } else {
+	/* start the i2c read transaction */
+	I2C_MSG(("%s,Send START..\n", __func__));
+	/* start with slave_addr + op */
+	rv = ksi2c_bus_start(ksi2c_sih, id,
+			     slave_addr, I2C_OP_READ, FALSE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on START stage in Read I2C OP\n",
+		       __func__));
+	    goto fail_i2c_transaction;
+	}
+
+	/* data read */
+	I2C_MSG(("%s,read bytes..\n", __func__));
+	bzero(data, len);	/* set to zero on data */
+	rv = ksi2c_bus_nbytes_read(ksi2c_sih, id, data, &len, FALSE);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on DATA stage in Read I2C OP"
+		       "(%d bytes sent already)\n", __func__, len));
+	    goto fail_i2c_transaction;
+	}
+
+	/* stop */
+	I2C_MSG(("%s,send STOP..\n", __func__));
+	rv = ksi2c_bus_stop(ksi2c_sih, id);
+	if (rv) {
+	    I2C_ERROR(("%s,Failed on STOP stage in Read I2C OP"
+		       "(%d bytes sent already)\n", __func__, len));
+	    goto fail_i2c_transaction;
+	}
+
+	return KSI2C_ERR_NONE;
+    }
+
+  fail_i2c_transaction:
+    if (rv == KSI2C_ERR_TIMEOUT || rv == KSI2C_ERR_UNKNOW ||
+	rv == KSI2C_ERR_INTERNAL) {
+	I2C_ERROR(("%s, Bus receovering through STOP\n", __func__));
+	if (ksi2c_bus_stop(ksi2c_sih, id)) {
+	    I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	    ksi2c_bus_reset(ksi2c_sih, id);
+	}
+    } else if (rv == KSI2C_ERR_BUS) {
+	I2C_ERROR(("%s, Bus receovering through Reset\n", __func__));
+	ksi2c_bus_reset(ksi2c_sih, id);
+	/* check if i2c clock is requirred to set again after reset */
+    } else {
+	I2C_ERROR(("%s, rv=%d, i2c read failed!\n", __func__, rv));
+    }
+    return rv;
+#else				/* KSI2C_BUS_DRIVER_READY */
+    uint8 databyte = 0, ctrlbyte = 0, i2c_iflg = CC_I2CSTS_NO_STATUS;
+    uint8 temp_val;
+    int i, retry;
+    i2c_addr_t saddr_internal;
+
+    saddr_internal = (slave_addr << I2C_SADDR_ADDR_OFFSET) &
+	I2C_SADDR_ADDR_MASK;
+
+    KSI2C_INIT_CHK;
+    if (len == 0) {
+	I2C_ERROR(("%s, No data to read at I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_PARAM;
+    } else {
+	if (len > sizeof(data)) {
+	    I2C_ERROR(("%s, Unexpected Data size!\n", __func__));
+	    return KSI2C_ERR_PARAM;
+	}
+    }
+
+    /* 0. start the transaction and check IFLG */
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte |= CC_I2CCTRL_MSTART;
+    ctrlbyte = si_i2c_control(ksi2c_sih, (uint8) id,
+			      CC_I2CCTRL_MASK, ctrlbyte);
+
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us  */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	/* @@ should check start */
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after START (Expect:0x08)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    I2C_MSG(("%s,%d,retry=%d!!\n", __func__, __LINE__, retry));
+
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to read at I2C_%d, TIMEOUT!\n", __func__,
+		   id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+    /* 1. set addr+op to i2c data buffer 
+     *  - Note if the slave_addr is pre-shift already.
+     */
+    databyte = saddr_internal | (I2C_OP_READ & I2C_SADDR_OP_MASK);
+    temp_val =
+	si_i2c_data(ksi2c_sih, (uint8) id, CC_I2CDATA_MASK, databyte);
+
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte =
+	si_i2c_control(ksi2c_sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    I2C_MSG(("%s,%d,saddr+op!!!!\n", __func__, __LINE__));
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	/* @@ should check addr+op tx with ACK */
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after SADDR+OP(Expect:0x40)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    I2C_MSG(("%s,%d,retry=%d!!\n", __func__, __LINE__, retry));
+
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to read at I2C_%d, TIMEOUT!\n", __func__,
+		   id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+    /* reset to start data read */
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte =
+	si_i2c_control(ksi2c_sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* 2. read n bytes data : */
+    for (i = 0; i < len; i++) {
+
+	/* 2.1 check IFLG and clear IFLG for going to next process */
+	for (retry = 0; retry < 1000; retry++) {
+	    OSL_DELAY(1);	/* delay 1 us */
+
+	    if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+		continue;
+	    }
+
+	    if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+		I2C_MSG(("%s,IFLG=[%02x] after rx DATA[%d],(expect:0x50/58\n", __func__, i2c_iflg, i));
+		break;
+	    }
+	}
+	if (retry == 1000) {
+	    I2C_ERROR(("%s, failed to read at I2C_%d, TIMEOUT!\n",
+		       __func__, id));
+	    return KSI2C_ERR_TIMEOUT;
+	}
+
+	databyte = 0;
+	databyte =
+	    si_i2c_data(ksi2c_sih, (uint8) id, CCI2C_READREG_MASK, 0);
+	I2C_MSG(("%s,%d,read #%d byte = 0x%02x!\n", __func__, __LINE__, i,
+		 databyte));
+	data[i] = databyte;
+
+	I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+	/* skip the Assert ACK at the latest data bye read */
+	if (i < (len - 1)) {
+	    /* AACK and reset IFLG */
+	    ctrlbyte |= CC_I2CCTRL_AAK;
+	}
+	ctrlbyte =
+	    si_i2c_control(ksi2c_sih, id, CC_I2CCTRL_MASK, ctrlbyte);
+    }
+    /* 2.2 check IFLG and clear IFLG for going to next process */
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+
+	if (i2c_iflg != CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after last DATA byte,(expect:0x58)\n", __func__, i2c_iflg));
+	    break;
+	}
+    }
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to read at I2C_%d, TIMEOUT!\n", __func__,
+		   id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+
+
+    /* 3. Stop transaction */
+    I2C_CTRL_IFLG_CLEAR(ctrlbyte);
+    ctrlbyte |= CC_I2CCTRL_MSTOP;
+    ctrlbyte =
+	si_i2c_control(ksi2c_sih, (uint8) id, CC_I2CCTRL_MASK, ctrlbyte);
+
+    /* check the IFLG */
+    I2C_MSG(("%s,%d,stoping!!!!\n", __func__, __LINE__));
+    for (retry = 0; retry < 1000; retry++) {
+	OSL_DELAY(1);		/* delay 1 us and timeout after 1 S. */
+
+	if (si_i2c_status(ksi2c_sih, id, CC_I2CSTS_MASK, &i2c_iflg)) {
+	    continue;
+	}
+	if (i2c_iflg == CC_I2CSTS_NO_STATUS) {
+	    I2C_MSG(("%s, IFLG=[%02x] after STOP,(expect:0xf8)\n",
+		     __func__, i2c_iflg));
+	    break;
+	}
+    }
+    if (retry == 1000) {
+	I2C_ERROR(("%s, failed to send STOP at I2C_%d, TIMEOUT!\n",
+		   __func__, id));
+	return KSI2C_ERR_TIMEOUT;
+    }
+    I2C_MSG(("%s, read DONE at I2C_%d\n", __func__, id));
+    return KSI2C_ERR_NONE;;
+
+#endif				/* KSI2C_BUS_DRIVER_READY */
+}
+
+/* Function : ksi2c_rw_pack 
+ *  - Mix the read/write operations in a i2c transaction.
+ * Return :
+ * Note :
+ *  1. the parameter is not defined yet.
+ */
+int ksi2c_rw_pack(cc_i2c_id_t id)
+{
+    KSI2C_INIT_CHK;
+    /* TBD, implemented in next stage */
+    return KSI2C_ERR_UNAVAIL;
+}
+
+
+
+/* Function : ksi2c_close 
+ *  - close Keystone's I2C port.
+ * Return :
+ * Note :
+ */
+int ksi2c_close(cc_i2c_id_t id)
+{
+    KSI2C_INIT_CHK;
+#if KSI2C_BUS_DRIVER_READY
+    if (ksi2c_bus_enable(ksi2c_sih, id, FALSE)) {
+	I2C_ERROR(("%s, Failed on disabling I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_INTERNAL;
+    }
+    return ksi2c_bus_detach(ksi2c_sih, id);
+#else				/* KSI2C_BUS_DRIVER_READY */
+
+    /* select the i2c interface */
+    if (si_i2c_select(ksi2c_sih, (uint8) id, FALSE)) {
+	I2C_ERROR(("%s, Failed on %s I2C_%d!\n", __func__, id));
+	return KSI2C_ERR_INTERNAL;
+    }
+
+    return KSI2C_ERR_NONE;
+#endif				/* KSI2C_BUS_DRIVER_READY */
+
+}
diff --git a/include/asm-mips/bcmsi/chipc_i2c.h b/include/asm-mips/bcmsi/chipc_i2c.h
new file mode 100644
index 0000000..80e7045
--- /dev/null
+++ b/include/asm-mips/bcmsi/chipc_i2c.h
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ *  
+ * $Copyright Open Broadcom Corporation$
+ */
+
+#ifndef _chipc_i2c_h_
+#define _chipc_i2c_h_
+
+#include <sbchipc.h>
+
+/* QuickTure PC test */
+#ifdef CFG_QUICKTURN
+/* QTPC allows quite limited frequency range.  
+ * >> i2c_ccr at 0x43 : m=8,n=3, clock ->1.04MHz
+ */
+#define QTPC_KSI2C_CCR      0x43
+#define QTPC_KSI2C_CLK_KHZ  1041	/* counted from QTPC_KSI2C_CCR */
+#endif				/* CFG_QUICKTURN */
+
+/* Bus Controller flag bit values and their meanings */
+#define KS_I2C_BUS_ATTACHED     0x01	/* attached status */
+#define KS_I2C_BUS_ENABLED      0x02	/* enabled status */
+#define KS_I2C_BUS_INTR         0x04	/* Interrupt mode */
+#define KS_I2C_BUS_PIO          0x08	/* Programmed IO mode (Polling mode) */
+
+/* define for the usage to read ChipCommon i2c related register through 
+ *  SI interfaces.
+ */
+#define CCI2C_READREG_MASK      0x0
+
+typedef uint8 i2c_addr_t;
+#define I2C_SADDR_ADDR_MASK     0xfe
+#define I2C_SADDR_ADDR_OFFSET   1
+#define I2C_SADDR_OP_MASK       0x01
+#define I2C_OP_READ     1
+#define I2C_OP_WRITE    0
+
+#define CCI2C_CCR_MMAX      0xF	/* max m value for i2c clock(CCR) */
+#define CCI2C_CCR_NMAX      0x7	/* max n value for i2c clock(CCR) */
+
+/* this definition is the same ESW chip, SW effort is requirred to tell 
+ *      which is working at master mode.
+ *
+ *  Note :
+ *  1. in those I2C bus connected devices, the slave address on each 
+ *      device shoud be unique.
+ *  2. to avoid some reserved I2C address, the KSI2C slave address is 
+ *      set to 0x10.
+ *  3. default reset slave address is 0x44 (on both bus)
+ */
+#define KSI2C_SLAVE_ADDR_BASE  0x10
+
+/*
+ * I2C Bus Status codes:
+ *
+ * The 31 possible status codes of the Keystone I2C port
+ * register bits: 0-7, enumerated for namespace reasons. Note that
+ * all of the status codes are multiples of 8.
+ */
+typedef enum ks_i2c_status_e {
+    KS_I2C_BUSERR = CC_I2CSTS_BUS_ERR,
+    KS_I2C_START_TX = CC_I2CSTS_TX_MSTART,
+    KS_I2C_REP_START_TX = CC_I2CSTS_TX_MRSTART,
+    KS_I2C_ADDR_WR_BIT_TX_ACK_RX = CC_I2CSTS_TX_MWADDR_ACK,
+    KS_I2C_ADDR_WR_BIT_TX_NO_ACK_RX = CC_I2CSTS_TX_MWADDR_NACK,
+    KS_I2C_DATA_BYTE_TX_ACK_RX = CC_I2CSTS_TX_MDATA_ACK,
+    KS_I2C_DATA_BYTE_TX_NO_ACK_RX = CC_I2CSTS_TX_MDATA_NACK,
+    KS_I2C_ARB_LOST = CC_I2CSTS_ABT_LOST,
+    KS_I2C_ADDR_RD_BIT_TX_ACK_RX = CC_I2CSTS_TX_MRADDR_ACK,
+    KS_I2C_ADDR_RD_BIT_TX_NO_ACK_RX = CC_I2CSTS_TX_MRADDR_NACK,
+    KS_I2C_DATA_BYTE_RX_ACK_TX = CC_I2CSTS_RX_MDATA_ACK,
+    KS_I2C_DATA_BYTE_RX_NO_ACK_TX = CC_I2CSTS_RX_MDATA_NACK,
+    KS_I2C_SADDR_RX_WR_BIT_RX_ACK_TX = CC_I2CSTS_RX_WADDR_ACK,
+    KS_I2C_ARB_LOST_SADDR_RX_WR_BIT_RX_ACK_TX = CC_I2CSTS_ABT_LOST1_ACK,
+    KS_I2C_GC_ADDR_RX_ACK_TX = CC_I2CSTS_RX_GENC_ACK,
+    KS_I2C_ARB_LOST_GC_ADDR_RX_ACK_TX = CC_I2CSTS_ABT_LOST2_ACK,
+    KS_I2C_DATA_BYTE_RX_AFTER_SADDR_RX_ACK_TX = CC_I2CSTS_RX_ADDRDATA_ACK,
+    KS_I2C_DATA_BYTE_RX_AFTER_SADDR_RX_NO_ACK_TX =
+	CC_I2CSTS_RX_ADDRDATA_NACK,
+    KS_I2C_DATA_BYTE_RX_AFTER_GC_ADDR_RX_ACK_TX =
+	CC_I2CSTS_RX_GENCDATA_ACK,
+    KS_I2C_DATA_BYTE_RX_AFTER_GC_ADDR_RX_NO_ACK_TX =
+	CC_I2CSTS_RX_GENCDATA_NACK,
+    KS_I2C_STOP_OR_REP_START_COND_RX_IN_SLAVE_MODE =
+	CC_I2CSTS_RX_SSTOP_SRSTART,
+    KS_I2C_SADDR_RX_RD_BIT_RX_ACK_TX = CC_I2CSTS_RX_SRADDR_ACK,
+    KS_I2C_ARB_LOST_IN_ADDR_PHASE_SADDR_RX_RD_BIT_RX_ACK_TX =
+	CC_I2CSTS_ABT_LOST3_ACK,
+    KS_I2C_SM_DATA_BYTE_TX_ACK_RX = CC_I2CSTS_TX_SDATA_ACK,
+    KS_I2C_SM_DATA_BYTE_TX_NO_ACK_RX = CC_I2CSTS_TX_SDATA_NACK,
+    KS_I2C_SM_LAST_BYTE_TX_ACK_RX = CC_I2CSTS_TX_SLASTDATA_ACK,
+    KS_I2C_2ND_ADDR_BYTE_TX_WR_BIT_TX_ACK_RX = CC_I2CSTS_TX_MW2NDADDR_ACK,
+    KS_I2C_2ND_ADDR_BYTE_TX_WR_BIT_TX_NO_ACK_RX =
+	CC_I2CSTS_TX_MW2NDADDR_NACK,
+    KS_I2C_2ND_ADDR_BYTE_TX_RD_BIT_TX_ACK_RX = CC_I2CSTS_TX_MR2NDADDR_ACK,
+    KS_I2C_2ND_ADDR_BYTE_TX_RD_BIT_TX_NO_ACK_RX =
+	CC_I2CSTS_TX_MR2NDADDR_NACK,
+    KS_I2C_UNDEFINED = 0xF0,	/* Not defined, for symmetry only */
+    KS_I2C_NO_STATUS = CC_I2CSTS_NO_STATUS,
+    KS_I2C_NUM_STATUS_CODES	/* Always last please */
+} ks_i2c_status_t;
+
+/*
+ * CPU/Master Initiated actions.
+ */
+typedef enum ks_i2c_op_e {
+    KS_I2C_IDLE,
+    KS_I2C_START,
+    KS_I2C_REP_START,
+    KS_I2C_TX,
+    KS_I2C_RX,
+    KS_I2C_STOP,
+    KS_I2C_PROBE
+} ks_i2c_op_t;
+
+/* keystone I2C bus controler */
+typedef struct ks_i2c_bus_s {
+    uint32 flags;		/* Bitmask of control flag : see below */
+    uint32 master_addr;		/* Master address (reset default 0x44) */
+    uint32 frequency;		/* Frequency */
+    uint8 m_val;		/* M for frequency setting */
+    uint8 n_val;		/* N for frequency setting */
+    ks_i2c_op_t opcode;		/* Current bus operation in progress */
+    uint32 pio_retries;		/* Max number of times to sleep for IFLG=0 */
+    uint32 iflg_polls;		/* Polls of IFLG on last operation (PIO) */
+    ks_i2c_status_t stat;	/* STAT: current state of bus */
+
+} ks_i2c_bus_t;
+
+#define KSI2C_BUS_ENABLED(_i2cbus)          \
+            ((_i2cbus)->flags & KS_I2C_BUS_ENABLED )
+#define KSI2C_BUS_OP_IDLE_CHECK(_i2cbus)    \
+            ((_i2cbus)->opcode == KS_I2C_IDLE )
+
+/* retry times on checking I2C IFLG */
+#define KS_I2C_PIO_RETRY    1000000
+
+/* KeyStone I2C speed mode */
+#define KS_I2C_SPEED_STANDARD       100
+#define KS_I2C_SPEED_FAST           400
+#define KS_I2C_SPEED_HIGH           3400	/* Maximum i2c speed in latest i2c spec. */
+#define KS_I2C_SPEED_DEFAULT        KS_I2C_SPEED_STANDARD
+
+/* reutrn value for I2C driver */
+#define KSI2C_ERR_NONE          0
+#define KSI2C_ERR_TIMEOUT       -1
+#define KSI2C_ERR_INTERNAL      -2
+#define KSI2C_ERR_PARAM         -3
+#define KSI2C_ERR_UNAVAIL       -4
+#define KSI2C_ERR_UNKNOW        -5
+#define KSI2C_ERR_BUS           -6	/* need RESET to release bus to idel */
+
+/* i2c register access level function prototype */
+extern void *si_i2c_setcore(si_t * sih);
+extern int si_i2c_select(si_t * sih, uint8 i2c_id, int en);
+extern int si_i2c_ccint_enable(si_t * sih, uint8 i2c_id, bool en);
+extern uint32 si_i2c_ccint_flag(si_t * sih, uint32 mask, uint32 val);
+extern uint8 si_i2c_swreset(si_t * sih, uint8 i2c_id, uint8 mask,
+			    uint8 val);
+extern uint8 si_i2c_data(si_t * sih, uint8 i2c_id, uint8 mask, uint8 val);
+extern uint8 si_i2c_slaveaddr(si_t * sih, uint8 i2c_id, uint8 mask,
+			      uint8 val);
+extern uint8 si_i2c_control(si_t * sih, uint8 i2c_id, uint8 mask,
+			    uint8 val);
+extern int si_i2c_clock(si_t * sih, uint8 i2c_id, uint8 val);
+extern int si_i2c_status(si_t * sih, uint8 i2c_id, uint8 mask,
+			 uint8 * val);
+extern uint8 si_i2c_extaddr(si_t * sih, uint8 i2c_id, uint8 mask,
+			    uint8 val);
+
+/* i2c bus level function prototype */
+extern int ksi2c_bus_set_freq(si_t * sih, cc_i2c_id_t id, uint32 speed_hz);
+extern int ksi2c_bus_attach(si_t * sih, cc_i2c_id_t id, uint32 flags,
+			    int speed_khz);
+extern int ksi2c_bus_detach(si_t * sih, cc_i2c_id_t id);
+extern int ksi2c_bus_enable(si_t * sih, cc_i2c_id_t id, int en);
+extern int ksi2c_bus_nbytes_read(si_t * sih, cc_i2c_id_t id, uint8 * data,
+				 int *len, bool aack_last_byte);
+extern int ksi2c_bus_nbytes_write(si_t * sih, cc_i2c_id_t id, uint8 * data,
+				  uint * len);
+extern int ksi2c_bus_repstart(si_t * sih, cc_i2c_id_t id,
+			      i2c_addr_t slave_addr, bool op);
+extern void ksi2c_bus_reset(si_t * sih, cc_i2c_id_t id);
+extern int ksi2c_bus_start(si_t * sih, cc_i2c_id_t id,
+			   i2c_addr_t slave_addr, bool op, bool rep);
+extern uint8 ksi2c_bus_status(si_t * sih, cc_i2c_id_t id);
+extern int ksi2c_bus_stop(si_t * sih, cc_i2c_id_t id);
+extern int ksi2c_bus_wait(si_t * sih, cc_i2c_id_t id);
+
+/* i2c high level function prototype */
+extern int ksi2c_init(void);
+extern int ksi2c_open(cc_i2c_id_t id, uint32 flags, int speed_khz);
+extern int ksi2c_read(cc_i2c_id_t id, i2c_addr_t slave_addr, uint8 * data,
+		      int len);
+extern int ksi2c_write(cc_i2c_id_t id, i2c_addr_t slave_addr, uint8 * data,
+		       int len);
+extern int ksi2c_i2cdev_read(cc_i2c_id_t id, i2c_addr_t slave_addr,
+			     uint8 * data, int len, uint32 dev_addr,
+			     int dev_addr_len);
+extern int ksi2c_rw_pack(cc_i2c_id_t id);
+extern int ksi2c_close(cc_i2c_id_t id);
+extern void ksi2c_reset(cc_i2c_id_t id);
+extern void ksi2c_test_dumpreg(void);
+extern int ksi2c_test_busio(cc_i2c_id_t id, int op, int act, uint8 * val);
+
+/* ------------ for GPIO QT test usage only */
+extern void ksgpio_Init(void);
+extern int ksgpio_InEventMaskSet(uint16 emask);
+extern int ksgpio_InEventChk(uint16 * event);
+extern int ksgpio_InGet(uint16 * val);
+extern int ksgpio_OutSet(uint16 val);
+extern int ksgpio_OutGet(uint16 * val);
+extern int ksgpio_OutEnGet(uint16 * enmask);
+extern int ksgpio_OutEnSet(uint16 enmask);
+extern int ksgpio_CtrlGet(uint16 * ctrl);
+extern int ksgpio_CtrlSet(uint16 ctrl);
+extern int ksgpio_TimerEnableSet(uint16 enmask);
+extern int ksgpio_TimerEnableGet(uint16 * enmask);
+extern int ksgpio_TimerSet(uint16 on_cnt, uint16 off_cnt);
+extern int ksgpio_TimerGet(uint16 * on_cnt, uint16 * off_cnt);
+extern int ksgpio_PullGet(bool op, uint16 * val);
+extern int ksgpio_PullSet(bool op, uint16 val);
+extern void ksgpio_dumpreg(void);
+
+extern int ksgpio_test_init(void);
+extern int ksgpio_test_output(uint16 pin_mask);
+extern int ksgpio_test_input(uint16 pin_mask);
+#endif				/* _chipc_i2c_h_ */
-- 
1.7.0.4

