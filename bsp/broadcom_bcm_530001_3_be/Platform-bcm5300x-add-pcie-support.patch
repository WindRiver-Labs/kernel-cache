From 31549c85c0be51f041b75e3b1b65531ce995c0d1 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Sun, 6 Jun 2010 14:06:06 +0800
Subject: [PATCH 08/21] Platform bcm5300x add pcie support

Add pcie special support code for bcm5300x

Source: from broadcom SDK

Signed-off-by: Liu Changhui <changhui.liu@windriver.com>
---
 arch/mips/bcm53000/Makefile    |    2 +-
 arch/mips/bcm53000/hndpci.c    |  986 ++++++++++++++++++++++++++++++++++++
 arch/mips/bcm53000/nicpci.c    | 1079 ++++++++++++++++++++++++++++++++++++++++
 arch/mips/pci/Makefile         |    2 +
 arch/mips/pci/fixup-bcm53000.c |  235 +++++++++
 arch/mips/pci/pci-bcm53000.c   |  183 +++++++
 6 files changed, 2486 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/bcm53000/hndpci.c
 create mode 100644 arch/mips/bcm53000/nicpci.c
 create mode 100644 arch/mips/pci/fixup-bcm53000.c
 create mode 100644 arch/mips/pci/pci-bcm53000.c

diff --git a/arch/mips/bcm53000/Makefile b/arch/mips/bcm53000/Makefile
index 0ced130..33a090b 100644
--- a/arch/mips/bcm53000/Makefile
+++ b/arch/mips/bcm53000/Makefile
@@ -18,6 +18,6 @@
 #
 #
 
-obj-y += time.o prom.o setup.o irq.o hndmips.o hnddma.o
+obj-y += time.o prom.o setup.o irq.o hndmips.o hnddma.o hndpci.o nicpci.o
 
 EXTRA_CFLAGS += -DCFE_API_ALL
diff --git a/arch/mips/bcm53000/hndpci.c b/arch/mips/bcm53000/hndpci.c
new file mode 100644
index 0000000..c1f5450
--- /dev/null
+++ b/arch/mips/bcm53000/hndpci.c
@@ -0,0 +1,986 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Low-Level PCI and SI support for BCM47xx
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <pcicfg.h>
+#include <bcmdevs.h>
+#include <hndsoc.h>
+#include <sbchipc.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <pci_core.h>
+#include <pcie_core.h>
+#include <bcmendian.h>
+#include <bcmnvram.h>
+#include <hndcpu.h>
+#include <hndpci.h>
+#include <nicpci.h>
+
+/* For now we need some real Silicon Backplane utils */
+#include "siutils_priv.h"
+
+/* debug/trace */
+#ifdef BCMDBG_PCI
+#define PCI_MSG(args)   printf args
+#else
+#define PCI_MSG(args)
+#endif
+
+/* to free some function memory after boot */
+#ifndef linux
+#define __init
+#endif				/* linux */
+
+/* Emulated configuration space */
+typedef struct {
+    int n;
+    uint size[PCI_BAR_MAX];
+} si_bar_cfg_t;
+static pci_config_regs si_config_regs[SI_MAXCORES];
+static si_bar_cfg_t si_bar_cfg[SI_MAXCORES];
+
+/* Links to emulated and real PCI configuration spaces */
+#define MAXFUNCS    2
+typedef struct {
+    pci_config_regs *emu;	/* emulated PCI config */
+    pci_config_regs *pci;	/* real PCI config */
+    si_bar_cfg_t *bar;		/* region sizes */
+} si_pci_cfg_t;
+static si_pci_cfg_t si_pci_cfg[SI_MAXCORES][MAXFUNCS];
+
+/* Special emulated config space for non-existing device */
+static pci_config_regs si_pci_null = { 0xffff, 0xffff };
+
+/* Banned cores */
+static uint32 pci_ban[SI_MAXCORES] = { 0 };	/* Higher 16bit is coreunit */
+
+static uint pci_banned = 0;
+
+/* CardBus mode */
+static bool cardbus = FALSE;
+
+/* Disable PCI host core */
+static bool pci_disabled[] = {
+    FALSE,
+    TRUE
+};
+
+/* Host bridge slot #, default to 0 */
+static uint8 pci_hbslot = 0;
+
+/* Internal macros */
+#define PCI_SLOTAD_MAP  16	/* SLOT<n> mapps to AD<n+16> */
+#define PCI_HBSBCFG_REV 8	/* MIN corerev to access host bridge PCI cfg space from SB */
+
+/* Functions for accessing external PCI configuration space, Assume one-hot slot wiring */
+#define PCI_SLOT_MAX    16	/* Max. PCI Slots */
+
+static uint32
+config_cmd(si_t *sih, uint bus, uint dev, uint func, uint off)
+{
+    uint coreidx;
+    sbpciregs_t *pci;
+    uint32 addr = 0, *sbtopci1;
+    osl_t *osh;
+    uint8 port;
+
+    /* CardBusMode supports only one device */
+    if (cardbus && dev > 1)
+	return 0;
+
+    /* Convert logical bus to physical port/bus for following processing */
+    port = PCIE_GET_PORT_BY_BUS(bus);
+    if (port == 1) {
+	/* 1-based bus number */
+	bus = bus - PCIE_PORT1_BUS_START + 1;
+    }
+
+    osh = si_osh(sih);
+
+    coreidx = si_coreidx(sih);
+    pci = (sbpciregs_t *) si_setcore(sih, PCI_CORE_ID, port);
+
+    if (pci) {
+	sbtopci1 = &pci->sbtopci1;
+    } else {
+	sbpcieregs_t *pcie;
+
+	pcie = (sbpcieregs_t *) si_setcore(sih, PCIE_CORE_ID, port);
+
+	/* Issue config commands only when the data link is up (atleast
+	 * one external pcie device is present).
+	 */
+	if (pcie && (dev < 2) &&
+	    (pcie_readreg(osh, pcie, PCIE_PCIEREGS,
+			  PCIE_DLLP_LSREG) & PCIE_DLLP_LSREG_LINKUP)) {
+	    sbtopci1 = &pcie->sbtopcie1;
+	} else {
+	    si_setcoreidx(sih, coreidx);
+	    return 0;
+	}
+    }
+
+
+    /* Type 0 transaction */
+    if (bus == 1) {
+	/* Skip unwired slots */
+	if (dev < PCI_SLOT_MAX) {
+	    /* Slide the PCI window to the appropriate slot */
+	    if (pci) {
+		uint32 win;
+
+		win = (SBTOPCI_CFG0 |
+		       ((1 << (dev + PCI_SLOTAD_MAP)) & SBTOPCI1_MASK));
+		W_REG(osh, sbtopci1, win);
+		addr = (SI_PCI_CFG(port) |
+			((1 << (dev + PCI_SLOTAD_MAP)) & ~SBTOPCI1_MASK) |
+			(func << PCICFG_FUN_SHIFT) | (off & ~3));
+	    } else {
+		W_REG(osh, sbtopci1, SBTOPCI_CFG0);
+		addr = (SI_PCI_CFG(port) |
+			(dev << PCIECFG_SLOT_SHIFT) |
+			(func << PCIECFG_FUN_SHIFT) | (off & ~3));
+	    }
+	}
+    } else {
+	/* Type 1 transaction */
+	addr = SI_PCI_CFG(port);
+	if (pci) {
+	    addr |= PCI_CONFIG_ADDR(bus, dev, func, (off & ~3));
+
+	    /*
+	     * Higher bus bits (which lets the address exceed the 64MB space)
+	     * should be specified in sbtopci1's UpperAddress.
+	     */
+	    W_REG(osh, sbtopci1, SBTOPCI_CFG1 | (addr & SBTOPCI1_MASK));
+
+	    /* To not exceed the 64MB space (by using UA instead) */
+	    addr &= ~SBTOPCI1_MASK;
+	} else {
+	    addr |= PCIE_CONFIG_ADDR((bus - 1), dev, func, (off & ~3));
+
+	    /*
+	     * Higher bus bits (which lets the address exceed the 64MB space)
+	     * should be specified in sbtopci1's UpperAddress.
+	     */
+	    W_REG(osh, sbtopci1, SBTOPCI_CFG1 | (addr & SBTOPCIE1_MASK));
+
+	    /* To not exceed the 64MB space (by using UA instead) */
+	    addr &= ~SBTOPCIE1_MASK;
+	}
+    }
+
+    si_setcoreidx(sih, coreidx);
+
+    return addr;
+}
+
+/*
+ * Read host bridge PCI config registers from Silicon Backplane ( >= rev8 ).
+ *
+ * It returns TRUE to indicate that access to the host bridge's pci config
+ * from SI is ok, and values in 'addr' and 'val' are valid.
+ *
+ * It can only read registers at multiple of 4-bytes. Callers must pick up
+ * needed bytes from 'val' based on 'off' value. Value in 'addr' reflects
+ * the register address where value in 'val' is read.
+ */
+static bool
+si_pcihb_read_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		     uint32 **addr, uint32 *val)
+{
+    sbpciregs_t *pci;
+    osl_t *osh;
+    uint coreidx;
+    bool ret = FALSE;
+    uint8 port;
+
+    /* sanity check */
+    ASSERT(PCIE_IS_BUS_HOST_BRIDGE(bus));
+    ASSERT(dev == pci_hbslot);
+
+    /* we support only two functions on device 0 */
+    if (func > 1)
+	return FALSE;
+
+    /* Convert logical bus to physical port/bus for following processing */
+    port = PCIE_GET_PORT_BY_BUS(bus);
+
+    osh = si_osh(sih);
+
+    /* read pci config when core rev >= 8 */
+    coreidx = si_coreidx(sih);
+    pci = (sbpciregs_t *) si_setcore(sih, PCI_CORE_ID, port);
+    if (pci) {
+	if (si_corerev(sih) >= PCI_HBSBCFG_REV) {
+	    *addr = (uint32 *) & pci->pcicfg[func][off >> 2];
+	    *val = R_REG(osh, *addr);
+	    ret = TRUE;
+	}
+    } else {
+	sbpcieregs_t *pcie;
+
+	/* read pcie config */
+	pcie = (sbpcieregs_t *) si_setcore(sih, PCIE_CORE_ID, port);
+	if (pcie) {
+	    if (off < 0x100) {
+		/* Direct access */
+		*addr = (uint32 *) & pcie->pciecfg[func][off >> 2];
+		*val = R_REG(osh, *addr);
+	    } else {
+		/* Indirect access */
+		*val = pcie_readreg(osh, pcie, PCIE_CONFIGREGS, off);
+	    }
+	    ret = TRUE;
+	}
+    }
+
+    si_setcoreidx(sih, coreidx);
+
+    return ret;
+}
+
+int
+extpci_read_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		   void *buf, int len)
+{
+    uint32 addr = 0, *reg = NULL, val;
+    int ret = 0;
+
+    /*
+     * Set value to -1 when:
+     *  flag 'pci_disabled' is true;
+     *  value of 'addr' is zero;
+     *  REG_MAP() fails;
+     *  BUSPROBE() fails;
+     */
+    if (pci_disabled[PCIE_GET_PORT_BY_BUS(bus)]) {
+	val = 0xffffffff;
+    } else if (PCIE_IS_BUS_HOST_BRIDGE(bus) && dev == pci_hbslot) {
+	if (!si_pcihb_read_config(sih, bus, dev, func, off, &reg, &val)) {
+	    return -1;
+	}
+    } else if (((addr = config_cmd(sih, bus, dev, func, off)) == 0) ||
+	       ((reg = (uint32 *) REG_MAP(addr, len)) == 0) ||
+	       (BUSPROBE(val, reg) != 0)) {
+	PCI_MSG(("%s: Failed to read!\n", __FUNCTION__));
+	val = 0xffffffff;
+    }
+
+    PCI_MSG(("%s: 0x%x <= 0x%p(0x%x), len %d, off 0x%x, buf 0x%p\n",
+	     __FUNCTION__, val, reg, addr, len, off, buf));
+
+    val >>= 8 * (off & 3);
+    if (len == 4)
+	*((uint32 *) buf) = val;
+    else if (len == 2)
+	*((uint16 *) buf) = (uint16) val;
+    else if (len == 1)
+	*((uint8 *) buf) = (uint8) val;
+    else
+	ret = -1;
+
+    if (reg && addr)
+	REG_UNMAP(reg);
+
+    return ret;
+}
+
+int
+extpci_write_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		    void *buf, int len)
+{
+    osl_t *osh;
+    uint32 addr = 0, *reg = NULL, val;
+    int ret = 0;
+
+    osh = si_osh(sih);
+
+    /*
+     * Ignore write attempt when:
+     *  flag 'pci_disabled' is true;
+     *  value of 'addr' is zero;
+     *  REG_MAP() fails;
+     *  BUSPROBE() fails;
+     */
+    if (pci_disabled[PCIE_GET_PORT_BY_BUS(bus)]) {
+	return 0;
+    } else if (PCIE_IS_BUS_HOST_BRIDGE(bus) && dev == pci_hbslot) {
+	if (!si_pcihb_read_config(sih, bus, dev, func, off, &reg, &val)) {
+	    return -1;
+	}
+    } else if (((addr = config_cmd(sih, bus, dev, func, off)) == 0) ||
+	       ((reg = (uint32 *) REG_MAP(addr, len)) == 0) ||
+	       (BUSPROBE(val, reg) != 0)) {
+	PCI_MSG(("%s: Failed to write!\n", __FUNCTION__));
+	goto done;
+    }
+
+    if (len == 4)
+	val = *((uint32 *) buf);
+    else if (len == 2) {
+	val &= ~(0xffff << (8 * (off & 3)));
+	val |= *((uint16 *) buf) << (8 * (off & 3));
+    } else if (len == 1) {
+	val &= ~(0xff << (8 * (off & 3)));
+	val |= *((uint8 *) buf) << (8 * (off & 3));
+    } else {
+	ret = -1;
+	goto done;
+    }
+
+    PCI_MSG(("%s: 0x%x => 0x%p\n", __FUNCTION__, val, reg));
+
+    W_REG(osh, reg, val);
+
+    /*
+     * Workaround for PCIE transaction ordering issue
+     *
+     * For PCIE config write: write then read back
+     * For PCIE memory write: write then sync (with Config7.ES set)
+     */
+    val = R_REG(osh, reg);
+
+  done:
+    if (reg && addr)
+	REG_UNMAP(reg);
+
+    return ret;
+}
+
+/*
+ * Must access emulated PCI configuration at these locations even when
+ * the real PCI config space exists and is accessible.
+ *
+ * PCI_CFG_VID (0x00)
+ * PCI_CFG_DID (0x02)
+ * PCI_CFG_PROGIF (0x09)
+ * PCI_CFG_SUBCL  (0x0a)
+ * PCI_CFG_BASECL (0x0b)
+ * PCI_CFG_HDR (0x0e)
+ * PCI_CFG_INT (0x3c)
+ * PCI_CFG_PIN (0x3d)
+ */
+#define FORCE_EMUCFG(off, len) \
+    ((off == PCI_CFG_VID) || (off == PCI_CFG_DID) || \
+     (off == PCI_CFG_PROGIF) || \
+     (off == PCI_CFG_SUBCL) || (off == PCI_CFG_BASECL) || \
+     (off == PCI_CFG_HDR) || \
+     (off == PCI_CFG_INT) || (off == PCI_CFG_PIN))
+
+/* Sync the emulation registers and the real PCI config registers. */
+static void
+si_pcid_read_config(si_t *sih, uint coreidx, si_pci_cfg_t *cfg, uint off,
+		    uint len)
+{
+    osl_t *osh;
+    uint oldidx;
+
+    ASSERT(cfg);
+    ASSERT(cfg->emu);
+    ASSERT(cfg->pci);
+
+    /* decide if real PCI config register access is necessary */
+    if (FORCE_EMUCFG(off, len))
+	return;
+
+    osh = si_osh(sih);
+
+    /* access to the real pci config space only when the core is up */
+    oldidx = si_coreidx(sih);
+    si_setcoreidx(sih, coreidx);
+    if (si_iscoreup(sih)) {
+	if (len == 4)
+	    *(uint32 *) ((ulong) cfg->emu + off) =
+		htol32(R_REG(osh, (uint32 *) ((ulong) cfg->pci + off)));
+	else if (len == 2)
+	    *(uint16 *) ((ulong) cfg->emu + off) =
+		htol16(R_REG(osh, (uint16 *) ((ulong) cfg->pci + off)));
+	else if (len == 1)
+	    *(uint8 *) ((ulong) cfg->emu + off) =
+		R_REG(osh, (uint8 *) ((ulong) cfg->pci + off));
+    }
+    si_setcoreidx(sih, oldidx);
+}
+
+static void
+si_pcid_write_config(si_t *sih, uint coreidx, si_pci_cfg_t *cfg,
+		     uint off, uint len)
+{
+    osl_t *osh;
+    uint oldidx;
+
+    ASSERT(cfg);
+    ASSERT(cfg->emu);
+    ASSERT(cfg->pci);
+
+    osh = si_osh(sih);
+
+    /* decide if real PCI config register access is necessary */
+    if (FORCE_EMUCFG(off, len))
+	return;
+
+    /* access to the real pci config space only when the core is up */
+    oldidx = si_coreidx(sih);
+    si_setcoreidx(sih, coreidx);
+    if (si_iscoreup(sih)) {
+	if (len == 4)
+	    W_REG(osh, (uint32 *) ((ulong) cfg->pci + off),
+		  ltoh32(*(uint32 *) ((ulong) cfg->emu + off)));
+	else if (len == 2)
+	    W_REG(osh, (uint16 *) ((ulong) cfg->pci + off),
+		  ltoh16(*(uint16 *) ((ulong) cfg->emu + off)));
+	else if (len == 1)
+	    W_REG(osh, (uint8 *) ((ulong) cfg->pci + off),
+		  *(uint8 *) ((ulong) cfg->emu + off));
+    }
+    si_setcoreidx(sih, oldidx);
+}
+
+/*
+ * Functions for accessing translated SI configuration space
+ */
+static int
+si_read_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+	       void *buf, int len)
+{
+    pci_config_regs *cfg;
+
+    if (dev >= SI_MAXCORES || func >= MAXFUNCS
+	|| (off + len) > sizeof(pci_config_regs))
+	return -1;
+
+    cfg = si_pci_cfg[dev][func].emu;
+
+    ASSERT(ISALIGNED(off, len));
+    ASSERT(ISALIGNED((uintptr) buf, len));
+
+    /* use special config space if the device does not exist */
+    if (!cfg)
+	cfg = &si_pci_null;
+    /* sync emulation with real PCI config if necessary */
+    else if (si_pci_cfg[dev][func].pci)
+	si_pcid_read_config(sih, dev, &si_pci_cfg[dev][func], off, len);
+
+    if (len == 4)
+	*((uint32 *) buf) = ltoh32(*((uint32 *) ((ulong) cfg + off)));
+    else if (len == 2)
+	*((uint16 *) buf) = ltoh16(*((uint16 *) ((ulong) cfg + off)));
+    else if (len == 1)
+	*((uint8 *) buf) = *((uint8 *) ((ulong) cfg + off));
+    else
+	return -1;
+
+    return 0;
+}
+
+static int
+si_write_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		void *buf, int len)
+{
+    uint coreidx;
+    void *regs;
+    pci_config_regs *cfg;
+    osl_t *osh;
+    si_bar_cfg_t *bar;
+
+    if (dev >= SI_MAXCORES || func >= MAXFUNCS
+	|| (off + len) > sizeof(pci_config_regs))
+	return -1;
+    cfg = si_pci_cfg[dev][func].emu;
+    if (!cfg)
+	return -1;
+
+    ASSERT(ISALIGNED(off, len));
+    ASSERT(ISALIGNED((uintptr) buf, len));
+
+    osh = si_osh(sih);
+
+    /* Emulate BAR sizing */
+    if (off >= OFFSETOF(pci_config_regs, base[0]) &&
+	off <= OFFSETOF(pci_config_regs, base[3]) &&
+	len == 4 && *((uint32 *) buf) == ~0) {
+	coreidx = si_coreidx(sih);
+	if ((regs = si_setcoreidx(sih, dev))) {
+	    bar = si_pci_cfg[dev][func].bar;
+	    /* Highest numbered address match register */
+	    if (off == OFFSETOF(pci_config_regs, base[0]))
+		cfg->base[0] = ~(bar->size[0] - 1);
+	    else if (off == OFFSETOF(pci_config_regs, base[1])
+		     && bar->n >= 1)
+		cfg->base[1] = ~(bar->size[1] - 1);
+	    else if (off == OFFSETOF(pci_config_regs, base[2])
+		     && bar->n >= 2)
+		cfg->base[2] = ~(bar->size[2] - 1);
+	    else if (off == OFFSETOF(pci_config_regs, base[3])
+		     && bar->n >= 3)
+		cfg->base[3] = ~(bar->size[3] - 1);
+	}
+	si_setcoreidx(sih, coreidx);
+    } else if (off == OFFSETOF(pci_config_regs, baserom) &&
+	       len == 4 && *((uint32 *) buf) == ~PCIE_ROM_ADDRESS_ENABLE) {
+	cfg->baserom = 0;
+    } else if (len == 4)
+	*((uint32 *) ((ulong) cfg + off)) = htol32(*((uint32 *) buf));
+    else if (len == 2)
+	*((uint16 *) ((ulong) cfg + off)) = htol16(*((uint16 *) buf));
+    else if (len == 1)
+	*((uint8 *) ((ulong) cfg + off)) = *((uint8 *) buf);
+    else
+	return -1;
+
+    /* sync emulation with real PCI config if necessary */
+    if (si_pci_cfg[dev][func].pci)
+	si_pcid_write_config(sih, dev, &si_pci_cfg[dev][func], off, len);
+
+    return 0;
+}
+
+int
+hndpci_read_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		   void *buf, int len)
+{
+    if (bus == 0)
+	return si_read_config(sih, bus, dev, func, off, buf, len);
+    else
+	return extpci_read_config(sih, bus, dev, func, off, buf, len);
+}
+
+int
+hndpci_write_config(si_t *sih, uint bus, uint dev, uint func, uint off,
+		    void *buf, int len)
+{
+    if (bus == 0)
+	return si_write_config(sih, bus, dev, func, off, buf, len);
+    else
+	return extpci_write_config(sih, bus, dev, func, off, buf, len);
+}
+
+void hndpci_ban(uint16 core, uint8 unit)
+{
+    if (unit > 1) {
+	return;
+    }
+    if (pci_banned < ARRAYSIZE(pci_ban))
+	pci_ban[pci_banned++] = (((uint32) unit) << 16) | core;
+}
+
+/*
+ * Initiliaze PCI core. Return 0 after a successful initialization. Otherwise
+ *  return -1 to indicate there is no PCI core and return 1 to indicate PCI core is disabled.
+ */
+int __init hndpci_init_pci(si_t *sih, uint8 port)
+{
+    uint chip, chiprev, chippkg, host;
+    uint32 boardflags;
+    sbpciregs_t *pci;
+    sbpcieregs_t *pcie = NULL;
+    uint32 val;
+    int ret = 0;
+    char *hbslot;
+    osl_t *osh;
+
+    chip = sih->chip;
+    chiprev = sih->chiprev;
+    chippkg = sih->chippkg;
+
+    osh = si_osh(sih);
+
+    pci = (sbpciregs_t *) si_setcore(sih, PCI_CORE_ID, port);
+    if (pci == NULL) {
+	pcie = (sbpcieregs_t *) si_setcore(sih, PCIE_CORE_ID, port);
+	if (pcie == NULL) {
+	    printf("PCI: no core for port %d\n", port);
+	    pci_disabled[port] = TRUE;
+	    return -1;
+	}
+    }
+
+    boardflags = (uint32) getintvar(NULL, "boardflags");
+
+    /*
+     * The 200-pin BCM4712 package does not bond out PCI. Even when
+     * PCI is bonded out, some boards may leave the pins floating.
+     */
+    if (((chip == BCM4712_CHIP_ID) && ((chippkg == BCM4712SMALL_PKG_ID) ||
+				       (chippkg == BCM4712MID_PKG_ID)))
+	|| (boardflags & BFL_NOPCI))
+	pci_disabled[port] = TRUE;
+
+    /* Enable the core */
+    if (!pci_disabled[port]) {
+	si_core_reset(sih, 0, 0);
+    }
+
+    /*
+     * If the PCI core should not be touched (disabled, not bonded
+     * out, or pins floating), do not even attempt to access core
+     * registers. Otherwise, try to determine if it is in host mode.
+     */
+    if (pci_disabled[port])
+	host = 0;
+    else
+	host = !BUSPROBE(val, (pci ? &pci->control : &pcie->control));
+
+    if (!host) {
+	ret = 1;
+
+	/* Disable PCI interrupts in client mode */
+	si_setint(sih, -1);
+
+	/* Disable the PCI bridge in client mode */
+	hndpci_ban(pci ? PCI_CORE_ID : PCIE_CORE_ID, port);
+
+	/*
+	 * XXX: In QT, this will cause QTPC to hang.
+	 *      Need to check if it's ok in silicon.
+	 si_core_disable(sih, 0);
+	 */
+
+	printf("PCI: Disabled for port %d\n", port);
+    } else {
+	printf("PCI: Initializing host for %d\n", port);
+
+	if (pci) {
+	    /* Reset the external PCI bus and enable the clock */
+	    W_REG(osh, &pci->control, 0x5);	/* enable tristate drivers */
+	    W_REG(osh, &pci->control, 0xd);	/* enable the PCI clock */
+	    OSL_DELAY(150);	/* delay > 100 us */
+	    W_REG(osh, &pci->control, 0xf);	/* deassert PCI reset */
+	    /* Use internal arbiter and park REQ/GRNT at external master 0
+	     * We will set it later after the bus has been probed
+	     */
+	    W_REG(osh, &pci->arbcontrol, PCI_INT_ARB);
+	    OSL_DELAY(1);	/* delay 1 us */
+	} else {
+	    OSL_DELAY(3000);
+	    W_REG(osh, &pcie->control, PCIE_RST_OE);
+	    OSL_DELAY(1000);	/* delay 1 ms */
+	    W_REG(osh, &pcie->control, PCIE_RST | PCIE_RST_OE);
+	    OSL_DELAY(1000);	/* delay 1 ms */
+	}
+
+	/* Enable CardBusMode */
+	cardbus = getintvar(NULL, "cardbus") == 1;
+	if (cardbus) {
+	    printf("PCI: Enabling CardBus\n");
+	    /* GPIO 1 resets the CardBus device on bcm94710ap */
+	    si_gpioout(sih, 1, 1, GPIO_DRV_PRIORITY);
+	    si_gpioouten(sih, 1, 1, GPIO_DRV_PRIORITY);
+	    W_REG(osh, &pci->sprom[0], R_REG(osh, &pci->sprom[0]) | 0x400);
+	}
+
+	if (pci) {
+	    /* 64 MB I/O access window */
+	    W_REG(osh, &pci->sbtopci0, SBTOPCI_IO);
+	    /* 64 MB configuration access window */
+	    W_REG(osh, &pci->sbtopci1, SBTOPCI_CFG0);
+	    /* 1 GB memory access window */
+	    W_REG(osh, &pci->sbtopci2, SBTOPCI_MEM | SI_PCI_DMA);
+	} else {
+	    /* 64 MB I/O access window. On 4716 rev 0, use
+	     * sbtopcie0 to access the device registers. We
+	     * can't use address match 2 (1 GB window) region
+	     * as mips can't generate 64-bit address on the
+	     * backplane.
+	     */
+	    if (chip == BCM53000_CHIP_ID)
+		W_REG(osh, &pcie->sbtopcie0,
+		      SBTOPCIE_MEM | SI_PCI_MEM(port) |
+		      SBTOPCI_PREF | SBTOPCI_BURST);
+	    else if ((chip == BCM4716_CHIP_ID) && (chiprev == 0))
+		W_REG(osh, &pcie->sbtopcie0,
+		      SBTOPCIE_MEM | SI_PCI_MEM(port) |
+		      SBTOPCI_PREF | SBTOPCI_BURST);
+	    else
+		W_REG(osh, &pcie->sbtopcie0, SBTOPCIE_IO);
+
+	    /* 64 MB configuration access window */
+	    W_REG(osh, &pcie->sbtopcie1, SBTOPCIE_CFG0);
+
+	    /* Large memory access window */
+	    W_REG(osh, &pcie->sbtopcie2,
+		  SBTOPCIE_MEM | SI_PCIE_DMA_HIGH(port) |
+		  SBTOPCI_PREF | SBTOPCI_BURST);
+	}
+
+	/* Host bridge slot # nvram overwrite */
+	if ((hbslot = nvram_get("pcihbslot"))) {
+	    pci_hbslot = bcm_strtoul(hbslot, NULL, 0);
+	    ASSERT(pci_hbslot < PCI_MAX_DEVICES);
+	}
+
+	/* Enable PCI bridge BAR0 memory & master access */
+	val = PCI_CMD_MASTER | PCI_CMD_MEMORY;
+	hndpci_write_config(sih, PCIE_GET_HOST_BRIDGE_BUS(port),
+			    pci_hbslot, 0, PCI_CFG_CMD, &val, sizeof(val)
+	    );
+
+	/* Enable PCI interrupts */
+	if (pci)
+	    W_REG(osh, &pci->intmask, PCI_INTA);
+	else
+	    W_REG(osh, &pcie->intmask, PCI_INTA);
+    }
+
+    return ret;
+}
+
+/* PR38069: Called after completing fixing up the devices on ext bus.
+ * The parkid parameter is the value to set the pci core parkid.  A value of
+ * PCI_PARK_NVRAM will allow the NVRAM to determine the value of parkid, if
+ * NVRAM not present than use default which is PCI_PARK_LAST.  If an invalid
+ * value is specified for park either by caller or NVRAM than use default option.
+ */
+void hndpci_arb_park(si_t *sih, uint parkid)
+{
+    sbpciregs_t *pci;
+    uint pcirev;
+    uint32 arb;
+
+    pci = (sbpciregs_t *) si_setcore(sih, PCI_CORE_ID, 0);
+    if ((pci == NULL) || pci_disabled) {
+	/* Should not happen */
+	PCI_MSG(("%s: no PCI core\n", __FUNCTION__));
+	return;
+    }
+
+    pcirev = si_corerev(sih);
+
+    /* Nothing to do, not supported for these revs */
+    if (pcirev < 8)
+	return;
+
+    /* Get parkid from NVRAM */
+    if (parkid == PCI_PARK_NVRAM) {
+	parkid = getintvar(NULL, "parkid");
+	if (getvar(NULL, "parkid") == NULL)
+	    /* Not present in NVRAM use defaults */
+	    parkid = (pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST;
+    }
+
+    /* Check the parkid is valid, if not set it to default */
+    if (parkid > ((pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST)) {
+	printf("%s: Invalid parkid %d\n", __FUNCTION__, parkid);
+	parkid = (pcirev >= 11) ? PCI11_PARKID_LAST : PCI_PARKID_LAST;
+    }
+
+    /* Now set the parkid */
+    arb = R_REG(si_osh(sih), &pci->arbcontrol);
+    arb &= ~PCI_PARKID_MASK;
+    arb |= parkid << PCI_PARKID_SHIFT;
+    W_REG(si_osh(sih), &pci->arbcontrol, arb);
+    OSL_DELAY(1);
+}
+
+/*
+ * Get the PCI region address and size information.
+ */
+static void __init
+hndpci_init_regions(si_t *sih, uint func, pci_config_regs *cfg,
+		    si_bar_cfg_t *bar)
+{
+    bool issb = sih->socitype == SOCI_SB;
+    uint i, n;
+
+    if (si_coreid(sih) == USB20H_CORE_ID) {
+	uint32 base, base1;
+
+	base = htol32(si_addrspace(sih, 0));
+	if (issb) {
+	    base1 = base + 0x800;	/* OHCI/EHCI */
+	} else {
+	    /* In AI chips EHCI is addrspace 0, OHCI is 1 */
+	    base1 = base;
+	    base = htol32(si_addrspace(sih, 1));
+	}
+
+	i = bar->n = 1;
+	cfg->base[0] = func == 0 ? base : base1;
+	bar->size[0] = issb ? 0x800 : 0x1000;
+    } else {
+	bar->n = n = si_numaddrspaces(sih);
+	for (i = 0; i < n; i++) {
+	    int size = si_addrspacesize(sih, i);
+
+	    if (size) {
+		/* XXX: Should size be byteswapped too? */
+		cfg->base[i] = htol32(si_addrspace(sih, i));
+		bar->size[i] = size;
+	    }
+	}
+    }
+    for (; i < PCI_BAR_MAX; i++) {
+	cfg->base[i] = 0;
+	bar->size[i] = 0;
+    }
+}
+
+/*
+ * Construct PCI config spaces for SB cores to be accessed as if they were PCI devices.
+ */
+void __init hndpci_init_cores(si_t *sih)
+{
+    uint chiprev, coreidx, i;
+    pci_config_regs *cfg, *pci;
+    si_bar_cfg_t *bar;
+    void *regs;
+    osl_t *osh;
+    uint16 vendor, device;
+    uint16 coreid;
+    uint8 class, subclass, progif;
+    uint dev;
+    uint8 header;
+    uint func;
+
+    chiprev = sih->chiprev;
+    coreidx = si_coreidx(sih);
+
+    osh = si_osh(sih);
+
+    /* Scan the SI bus */
+    bzero(si_config_regs, sizeof(si_config_regs));
+    bzero(si_bar_cfg, sizeof(si_bar_cfg));
+    bzero(si_pci_cfg, sizeof(si_pci_cfg));
+    memset(&si_pci_null, -1, sizeof(si_pci_null));
+    cfg = si_config_regs;
+    bar = si_bar_cfg;
+    for (dev = 0; dev < SI_MAXCORES; dev++) {
+	/* Check if the core exists */
+	if (!(regs = si_setcoreidx(sih, dev)))
+	    continue;
+
+	/* Check if this core is banned */
+	coreid = si_coreid(sih);
+	for (i = 0; i < pci_banned; i++) {
+	    if (coreid == (pci_ban[i] & 0xFFFF) &&
+		si_coreunit(sih) == (pci_ban[i] >> 16)) {
+		break;
+	    }
+	}
+	if (i < pci_banned)
+	    continue;
+
+	for (func = 0; func < MAXFUNCS; ++func) {
+	    /* Make sure we won't go beyond the limit */
+	    if (cfg >= &si_config_regs[SI_MAXCORES]) {
+		printf("PCI: too many emulated devices\n");
+		goto done;
+	    }
+
+	    /* Convert core id to pci id */
+	    if (si_corepciid
+		(sih, func, &vendor, &device, &class, &subclass, &progif,
+		 &header))
+		continue;
+
+	    /*
+	     * Differentiate real PCI config from emulated.
+	     * non zero 'pci' indicate there is a real PCI config space
+	     * for this device.
+	     */
+	    switch (device) {
+	    case BCM47XX_GIGETH_ID:
+		pci = (pci_config_regs *) ((uint32) regs + 0x800);
+		break;
+	    case BCM47XX_SATAXOR_ID:
+		pci = (pci_config_regs *) ((uint32) regs + 0x400);
+		break;
+	    case BCM47XX_ATA100_ID:
+		pci = (pci_config_regs *) ((uint32) regs + 0x800);
+		break;
+	    default:
+		pci = NULL;
+		break;
+	    }
+	    /* Supported translations */
+	    cfg->vendor = htol16(vendor);
+	    cfg->device = htol16(device);
+	    cfg->rev_id = chiprev;
+	    cfg->prog_if = progif;
+	    cfg->sub_class = subclass;
+	    cfg->base_class = class;
+	    cfg->header_type = header;
+	    hndpci_init_regions(sih, func, cfg, bar);
+	    /* Save core interrupt flag */
+	    cfg->int_pin = si_flag(sih);
+	    /* Save core interrupt assignment */
+	    cfg->int_line = si_irq(sih);
+	    /* Indicate there is no SROM */
+	    *((uint32 *) & cfg->sprom_control) = 0xffffffff;
+
+	    /* Point to the PCI config spaces */
+	    si_pci_cfg[dev][func].emu = cfg;
+	    si_pci_cfg[dev][func].pci = pci;
+	    si_pci_cfg[dev][func].bar = bar;
+	    cfg++;
+	    bar++;
+	}
+    }
+
+  done:
+    si_setcoreidx(sih, coreidx);
+}
+
+/*
+ * Initialize PCI core and construct PCI config spaces for SI cores.
+ * Must propagate hndpci_init_pci() return value to the caller to let
+ * them know the PCI core initialization status.
+ */
+int __init hndpci_init(si_t *sih)
+{
+    int status;
+    osl_t *osh = si_osh(sih);
+
+    /* Determine status of PCIE port 0 and 1 */
+    {
+	chipcregs_t *cc;
+
+	/* Determine whether any of PCIE ports should be disabled */
+	cc = (chipcregs_t *) si_setcore(sih, CC_CORE_ID, 0);
+	if (!cc) {
+	    /* Not likely */
+	    return -1;
+	}
+
+	if (R_REG(osh, &cc->chipstatus) & CHIPSTATUS_PCIE_PORT0_ENDPOINT) {
+	    /* Do not touch PCIE port 0 if it's in endpoint mode */
+	    pci_disabled[0] = TRUE;
+	}
+	if (!(R_REG(osh, &cc->chipstatus) & CHIPSTATUS_PCIE_PORT1_DISABLE)) {
+	    /* PCIE port 1 enabled */
+	    pci_disabled[1] = FALSE;
+	}
+    }
+
+    status = hndpci_init_pci(sih, 0);
+    status |= hndpci_init_pci(sih, 1);
+
+    hndpci_init_cores(sih);
+    return status;
+}
diff --git a/arch/mips/bcm53000/nicpci.c b/arch/mips/bcm53000/nicpci.c
new file mode 100644
index 0000000..1af17c0
--- /dev/null
+++ b/arch/mips/bcm53000/nicpci.c
@@ -0,0 +1,1079 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Code to operate on PCI/E core, in NIC mode
+ * Implements pci_api.h
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#include <typedefs.h>
+#include <bcmdefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <siutils.h>
+#include <hndsoc.h>
+#include <bcmdevs.h>
+#include <sbchipc.h>
+#include <pci_core.h>
+#include <pcie_core.h>
+#include <nicpci.h>
+#include <pcicfg.h>
+
+typedef struct {
+    union {
+	sbpcieregs_t *pcieregs;
+	sbpciregs_t *pciregs;
+    } regs;			/* Memory mapped register to the core */
+
+    si_t *sih;			/* System interconnect handle */
+    osl_t *osh;			/* OSL handle */
+    uint8 pciecap_lcreg_offset;	/* PCIE capability LCreg offset in the config space */
+    bool pcie_pr42767;		/* XXX make sure clkreq is not enabled before this WAR */
+    uint8 pcie_polarity;	/* XXX PR43448: remember and store the polarity */
+    bool pcie_war_aspm_ovr;	/* Override ASPM/Clkreq settings */
+
+    uint8 pmecap_offset;	/* PM Capability offset in the config space */
+    bool pmecap;		/* Capable of generating PME */
+} pcicore_info_t;
+
+/* debug/trace */
+#ifdef BCMDBG_ERR
+#define	PCI_ERROR(args)	printf args
+#else
+#define	PCI_ERROR(args)
+#endif				/* BCMDBG_ERR */
+
+/* routines to access mdio slave device registers */
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk);
+static int pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr,
+		       bool write, uint *val);
+static int pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint readdr,
+			  uint val);
+static int pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint readdr,
+			 uint *ret_val);
+
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend);
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state);
+
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi);
+static void pcie_war_serdes(pcicore_info_t *pi);
+static void pcie_war_noplldown(pcicore_info_t *pi);
+static void pcie_war_polarity(pcicore_info_t *pi);
+static void pcie_war_pci_setup(pcicore_info_t *pi);
+
+static bool pcicore_pmecap(pcicore_info_t *pi);
+static void pcicore_fixlatencytimer(pcicore_info_t *pch, uint8 timer_val);
+
+/* XXX PCIE ASPM related wars */
+#define PCIE(sih) ((BUSTYPE((sih)->bustype) == PCI_BUS) && ((sih)->buscoretype == PCIE_CORE_ID))
+#define PCIE_ASPM(sih)	((PCIE(sih)) && (((sih)->buscorerev >= 3) && ((sih)->buscorerev <= 5)))
+
+#define DWORD_ALIGN(x)  (x & ~(0x03))
+#define BYTE_POS(x) (x & 0x3)
+#define WORD_POS(x) (x & 0x1)
+
+#define BYTE_SHIFT(x)  (8 * BYTE_POS(x))
+#define WORD_SHIFT(x)  (16 * WORD_POS(x))
+
+#define BYTE_VAL(a, x) ((a >> BYTE_SHIFT(x)) & 0xFF)
+#define WORD_VAL(a, x) ((a >> WORD_SHIFT(x)) & 0xFFFF)
+
+#define read_pci_cfg_byte(a) \
+	(BYTE_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xff)
+
+#define read_pci_cfg_word(a) \
+	(WORD_VAL(OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4), a) & 0xffff)
+
+#define write_pci_cfg_byte(a, val) do { \
+	uint32 tmpval  = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFF << BYTE_POS(a)) | \
+	        val << BYTE_POS(a); \
+	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
+	} while (0)
+
+#define write_pci_cfg_word(a, val) do { \
+	uint32 tmpval = (OSL_PCI_READ_CONFIG(osh, DWORD_ALIGN(a), 4) & ~0xFFFF << WORD_POS(a)) | \
+	        val << WORD_POS(a); \
+	OSL_PCI_WRITE_CONFIG(osh, DWORD_ALIGN(a), 4, tmpval); \
+	} while (0)
+
+/* delay needed between the mdio control/ mdiodata register data access */
+#define PR28829_DELAY() OSL_DELAY(10)
+
+/* Initialize the PCI core. It's caller's responsibility to make sure that this is done
+ * only once
+ */
+void *pcicore_init(si_t *sih, osl_t *osh, void *regs)
+{
+    pcicore_info_t *pi;
+
+    ASSERT(sih->bustype == PCI_BUS);
+
+    /* alloc pcicore_info_t */
+    if ((pi = MALLOC(osh, sizeof(pcicore_info_t))) == NULL) {
+	PCI_ERROR(("pci_attach: malloc failed! malloced %d bytes\n",
+		   MALLOCED(osh)));
+	return (NULL);
+    }
+
+    bzero(pi, sizeof(pcicore_info_t));
+
+    pi->sih = sih;
+    pi->osh = osh;
+
+    if (sih->buscoretype == PCIE_CORE_ID) {
+	uint8 cap_ptr;
+	pi->regs.pcieregs = (sbpcieregs_t *) regs;
+	cap_ptr =
+	    pcicore_find_pci_capability(pi->osh, PCI_CAP_PCIECAP_ID, NULL,
+					NULL);
+	ASSERT(cap_ptr);
+	pi->pciecap_lcreg_offset = cap_ptr + PCIE_CAP_LINKCTRL_OFFSET;
+    } else
+	pi->regs.pciregs = (sbpciregs_t *) regs;
+
+    return pi;
+}
+
+void pcicore_deinit(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    if (pi == NULL)
+	return;
+    MFREE(pi->osh, pi, sizeof(pcicore_info_t));
+}
+
+/* return cap_offset if requested capability exists in the PCI config space */
+/* Note that it's caller's responsibility to make sure it's a pci bus */
+uint8
+pcicore_find_pci_capability(osl_t *osh, uint8 req_cap_id, uchar *buf,
+			    uint32 *buflen)
+{
+    uint8 cap_id;
+    uint8 cap_ptr = 0;
+    uint32 bufsize;
+    uint8 byte_val;
+
+    /* check for Header type 0 */
+    byte_val = read_pci_cfg_byte(PCI_CFG_HDR);
+    if ((byte_val & 0x7f) != PCI_HEADER_NORMAL)
+	goto end;
+
+    /* check if the capability pointer field exists */
+    byte_val = read_pci_cfg_byte(PCI_CFG_STAT);
+    if (!(byte_val & PCI_CAPPTR_PRESENT))
+	goto end;
+
+    cap_ptr = read_pci_cfg_byte(PCI_CFG_CAPPTR);
+    /* check if the capability pointer is 0x00 */
+    if (cap_ptr == 0x00)
+	goto end;
+
+    /* loop thr'u the capability list and see if the pcie capabilty exists */
+
+    cap_id = read_pci_cfg_byte(cap_ptr);
+
+    while (cap_id != req_cap_id) {
+	cap_ptr = read_pci_cfg_byte((cap_ptr + 1));
+	if (cap_ptr == 0x00)
+	    break;
+	cap_id = read_pci_cfg_byte(cap_ptr);
+    }
+    if (cap_id != req_cap_id) {
+	goto end;
+    }
+    /* found the caller requested capability */
+    if ((buf != NULL) && (buflen != NULL)) {
+	uint8 cap_data;
+
+	bufsize = *buflen;
+	if (!bufsize)
+	    goto end;
+	*buflen = 0;
+	/* copy the cpability data excluding cap ID and next ptr */
+	cap_data = cap_ptr + 2;
+	if ((bufsize + cap_data) > SZPCR)
+	    bufsize = SZPCR - cap_data;
+	*buflen = bufsize;
+	while (bufsize--) {
+	    *buf = read_pci_cfg_byte(cap_data);
+	    cap_data++;
+	    buf++;
+	}
+    }
+  end:
+    return cap_ptr;
+}
+
+/* ***** Register Access API */
+uint
+pcie_readreg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype,
+	     uint offset)
+{
+    uint retval = 0xFFFFFFFF;
+
+    ASSERT(pcieregs != NULL);
+
+    switch (addrtype) {
+    case PCIE_CONFIGREGS:
+	W_REG(osh, (&pcieregs->configaddr), offset);
+	retval = R_REG(osh, &(pcieregs->configdata));
+	break;
+    case PCIE_PCIEREGS:
+	W_REG(osh, &(pcieregs->pcieindaddr), offset);
+	retval = R_REG(osh, &(pcieregs->pcieinddata));
+	break;
+    default:
+	ASSERT(0);
+	break;
+    }
+
+    return retval;
+}
+
+uint
+pcie_writereg(osl_t *osh, sbpcieregs_t *pcieregs, uint addrtype,
+	      uint offset, uint val)
+{
+    ASSERT(pcieregs != NULL);
+
+    switch (addrtype) {
+    case PCIE_CONFIGREGS:
+	W_REG(osh, (&pcieregs->configaddr), offset);
+	W_REG(osh, (&pcieregs->configdata), val);
+	break;
+    case PCIE_PCIEREGS:
+	W_REG(osh, (&pcieregs->pcieindaddr), offset);
+	W_REG(osh, (&pcieregs->pcieinddata), val);
+	break;
+    default:
+	ASSERT(0);
+	break;
+    }
+    return 0;
+}
+
+static bool pcie_mdiosetblock(pcicore_info_t *pi, uint blk)
+{
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    uint mdiodata, i = 0;
+    uint pcie_serdes_spinwait = 200;
+
+    mdiodata =
+	MDIODATA_START | MDIODATA_WRITE | (MDIODATA_DEV_ADDR <<
+					   MDIODATA_DEVADDR_SHF) |
+	(MDIODATA_BLK_ADDR << MDIODATA_REGADDR_SHF) | MDIODATA_TA | (blk <<
+								     4);
+    W_REG(pi->osh, &pcieregs->mdiodata, mdiodata);
+
+    PR28829_DELAY();
+    /* retry till the transaction is complete */
+    while (i < pcie_serdes_spinwait) {
+	if (R_REG(pi->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+	    break;
+	}
+	OSL_DELAY(1000);
+	i++;
+    }
+
+    if (i >= pcie_serdes_spinwait) {
+	PCI_ERROR(("pcie_mdiosetblock: timed out\n"));
+	return FALSE;
+    }
+
+    return TRUE;
+}
+
+static int
+pcie_mdioop(pcicore_info_t *pi, uint physmedia, uint regaddr, bool write,
+	    uint *val)
+{
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    uint mdiodata;
+    uint i = 0;
+    uint pcie_serdes_spinwait = 10;
+
+    /* enable mdio access to SERDES */
+    W_REG(pi->osh, (&pcieregs->mdiocontrol),
+	  MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+    if (pi->sih->buscorerev >= 10) {
+	/* new serdes is slower in rw, using two layers of reg address mapping */
+	if (!pcie_mdiosetblock(pi, physmedia))
+	    return 1;
+	mdiodata = (MDIODATA_DEV_ADDR << MDIODATA_DEVADDR_SHF) |
+	    (regaddr << MDIODATA_REGADDR_SHF);
+	pcie_serdes_spinwait *= 20;
+    } else {
+	mdiodata = (physmedia << MDIODATA_DEVADDR_SHF_OLD) |
+	    (regaddr << MDIODATA_REGADDR_SHF_OLD);
+    }
+
+    if (!write)
+	mdiodata |= (MDIODATA_START | MDIODATA_READ | MDIODATA_TA);
+    else
+	mdiodata |= (MDIODATA_START | MDIODATA_WRITE | MDIODATA_TA | *val);
+
+    W_REG(pi->osh, &pcieregs->mdiodata, mdiodata);
+
+    PR28829_DELAY();
+
+    /* retry till the transaction is complete */
+    while (i < pcie_serdes_spinwait) {
+	if (R_REG(pi->osh, &(pcieregs->mdiocontrol)) & MDIOCTL_ACCESS_DONE) {
+	    if (!write) {
+		PR28829_DELAY();
+		*val =
+		    (R_REG(pi->osh, &(pcieregs->mdiodata)) &
+		     MDIODATA_MASK);
+	    }
+	    /* Disable mdio access to SERDES */
+	    W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
+	    return 0;
+	}
+	OSL_DELAY(1000);
+	i++;
+    }
+
+    PCI_ERROR(("pcie_mdioop: timed out op: %d\n", write));
+    /* Disable mdio access to SERDES */
+    W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
+    return 1;
+}
+
+/* use the mdio interface to read from mdio slaves */
+static int
+pcie_mdioread(pcicore_info_t *pi, uint physmedia, uint regaddr,
+	      uint *regval)
+{
+    return pcie_mdioop(pi, physmedia, regaddr, FALSE, regval);
+}
+
+/* use the mdio interface to write to mdio slaves */
+static int
+pcie_mdiowrite(pcicore_info_t *pi, uint physmedia, uint regaddr, uint val)
+{
+    return pcie_mdioop(pi, physmedia, regaddr, TRUE, &val);
+}
+
+/* ***** Support functions ***** */
+uint8 pcie_clkreq(void *pch, uint32 mask, uint32 val)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    uint32 reg_val;
+    uint8 offset;
+
+    offset = pi->pciecap_lcreg_offset;
+    if (!offset)
+	return 0;
+
+    reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+    /* set operation */
+    if (mask) {
+	if (val)
+	    reg_val |= PCIE_CLKREQ_ENAB;
+	else
+	    reg_val &= ~PCIE_CLKREQ_ENAB;
+	OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), reg_val);
+	reg_val = OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+    }
+    if (reg_val & PCIE_CLKREQ_ENAB)
+	return 1;
+    else
+	return 0;
+}
+
+static void pcie_extendL1timer(pcicore_info_t *pi, bool extend)
+{
+    uint32 w;
+    si_t *sih = pi->sih;
+    osl_t *osh = pi->osh;
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+
+    if (!PCIE(sih) || !(sih->buscorerev == 7 || sih->buscorerev == 8))
+	return;
+
+    /* to workaround throughput degradation due to tx underflow */
+    w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG);
+    if (extend)
+	w |= PCIE_ASPMTIMER_EXTEND;
+    else
+	w &= ~PCIE_ASPMTIMER_EXTEND;
+    pcie_writereg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG, w);
+    w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG);
+}
+
+/* centralized clkreq control policy */
+static void pcie_clkreq_upd(pcicore_info_t *pi, uint state)
+{
+    si_t *sih = pi->sih;
+    ASSERT(PCIE(sih));
+
+    switch (state) {
+    case SI_DOATTACH:
+	/* XXX PR42780 WAR: Disable clk req when coming up */
+	if (PCIE_ASPM(sih))
+	    pcie_clkreq((void *) pi, 1, 0);
+	break;
+    case SI_PCIDOWN:
+	if (sih->buscorerev == 6) {	/* turn on serdes PLL down */
+	    si_corereg(sih, SI_CC_IDX,
+		       OFFSETOF(chipcregs_t, chipcontrol_addr), ~0, 0);
+	    si_corereg(sih, SI_CC_IDX,
+		       OFFSETOF(chipcregs_t, chipcontrol_data), ~0x40, 0);
+	} else if (pi->pcie_pr42767) {
+	    /* When the driver going down, enable clkreq if PR42767 has been applied.
+	     * Also, adjust the state as system could hibernate, so Serdes PLL WAR is
+	     * a must before doing this
+	     */
+	    pcie_clkreq((void *) pi, 1, 1);
+	}
+	break;
+    case SI_PCIUP:
+	if (sih->buscorerev == 6) {	/* turn off serdes PLL down */
+	    si_corereg(sih, SI_CC_IDX,
+		       OFFSETOF(chipcregs_t, chipcontrol_addr), ~0, 0);
+	    si_corereg(sih, SI_CC_IDX,
+		       OFFSETOF(chipcregs_t, chipcontrol_data), ~0x40,
+		       0x40);
+	} else if (PCIE_ASPM(sih)) {	/* disable clkreq */
+	    pcie_clkreq((void *) pi, 1, 0);
+	}
+	break;
+    default:
+	ASSERT(0);
+	break;
+    }
+}
+
+/* ***** PCI core WARs ***** */
+/* XXX Fix the polarity on start */
+/* Done only once at attach time */
+static void pcie_war_polarity(pcicore_info_t *pi)
+{
+    uint32 w;
+
+    if (pi->pcie_polarity != 0)
+	return;
+
+    w = pcie_readreg(pi->osh, pi->regs.pcieregs, PCIE_PCIEREGS,
+		     PCIE_PLP_STATUSREG);
+
+    /* Detect the current polarity at attach and force that polarity and
+     * disable changing the polarity
+     */
+    if ((w & PCIE_PLP_POLARITYINV_STAT) == 0)
+	pi->pcie_polarity = (SERDES_RX_CTRL_FORCE);
+    else
+	pi->pcie_polarity =
+	    (SERDES_RX_CTRL_FORCE | SERDES_RX_CTRL_POLARITY);
+}
+
+/* enable ASPM and CLKREQ if srom doesn't have it */
+/* Needs to happen when update to shadow SROM is needed
+ *   : Coming out of 'standby'/'hibernate'
+ *   : If pcie_war_aspm_ovr state changed
+ */
+static void pcie_war_aspm_clkreq(pcicore_info_t *pi)
+{
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    si_t *sih = pi->sih;
+    uint16 val16, *reg16;
+    uint32 w;
+
+    if (!PCIE_ASPM(sih))
+	return;
+
+    /* PR43448 WAR: Enable ASPM in the shadow SROM and Link control */
+    /* bypass this on QT or VSIM */
+    if (sih->chippkg != HDLSIM_PKG_ID && sih->chippkg != HWSIM_PKG_ID) {
+
+	reg16 = &pcieregs->sprom[SRSH_ASPM_OFFSET];
+	val16 = R_REG(pi->osh, reg16);
+	if (!pi->pcie_war_aspm_ovr)
+	    val16 |= SRSH_ASPM_ENB;
+	else
+	    val16 &= ~SRSH_ASPM_ENB;
+	W_REG(pi->osh, reg16, val16);
+
+	w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+				sizeof(uint32));
+	if (!pi->pcie_war_aspm_ovr)
+	    w |= PCIE_ASPM_ENAB;
+	else
+	    w &= ~PCIE_ASPM_ENAB;
+	OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+			     sizeof(uint32), w);
+    }
+
+    /* PR42767 WAR: if clockreq is not advertized in SROM, advertize it */
+    reg16 = &pcieregs->sprom[SRSH_CLKREQ_OFFSET_REV5];
+    val16 = R_REG(pi->osh, reg16);
+
+    if (!pi->pcie_war_aspm_ovr) {
+	val16 |= SRSH_CLKREQ_ENB;
+	pi->pcie_pr42767 = TRUE;
+    } else
+	val16 &= ~SRSH_CLKREQ_ENB;
+
+    W_REG(pi->osh, reg16, val16);
+}
+
+/* Apply the polarity determined at the start */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_serdes(pcicore_info_t *pi)
+{
+    uint32 w = 0;
+
+    /* PR43448: program the correct polarity and disable future polarity inversions */
+    if (pi->pcie_polarity != 0)
+	pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CTRL,
+		       pi->pcie_polarity);
+
+    /* PR42767 workaround start: modify the SERDESS PLL control register */
+    pcie_mdioread(pi, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, &w);
+    if (w & PLL_CTRL_FREQDET_EN) {
+	w &= ~PLL_CTRL_FREQDET_EN;
+	pcie_mdiowrite(pi, MDIODATA_DEV_PLL, SERDES_PLL_CTRL, w);
+    }
+}
+
+/* Fix MISC config to allow coming out of L2/L3-Ready state w/o PRST */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void BCMINITFN(pcie_misc_config_fixup) (pcicore_info_t *pi) {
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    uint16 val16, *reg16;
+
+    reg16 = &pcieregs->sprom[SRSH_PCIE_MISC_CONFIG];
+    val16 = R_REG(pi->osh, reg16);
+
+    if ((val16 & SRSH_L23READY_EXIT_NOPERST) == 0) {
+	val16 |= SRSH_L23READY_EXIT_NOPERST;
+	W_REG(pi->osh, reg16, val16);
+    }
+}
+
+/* quick hack for testing */
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_noplldown(pcicore_info_t *pi)
+{
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    uint16 *reg16;
+
+    ASSERT(pi->sih->buscorerev == 7);
+
+    /* turn off serdes PLL down */
+    si_corereg(pi->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
+	       CHIPCTRL_4321_PLL_DOWN, CHIPCTRL_4321_PLL_DOWN);
+
+    /*  clear srom shadow backdoor */
+    reg16 = &pcieregs->sprom[SRSH_BD_OFFSET];
+    W_REG(pi->osh, reg16, 0);
+}
+
+/* Needs to happen when coming out of 'standby'/'hibernate' */
+static void pcie_war_pci_setup(pcicore_info_t *pi)
+{
+    si_t *sih = pi->sih;
+    osl_t *osh = pi->osh;
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    uint32 w;
+
+    /* PR 29224  enable_9715_fix bit in the TLP workaround register should be set */
+    if ((sih->buscorerev == 0) || (sih->buscorerev == 1)) {
+	w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
+			 PCIE_TLP_WORKAROUNDSREG);
+	w |= 0x8;
+	pcie_writereg(osh, pcieregs, PCIE_PCIEREGS,
+		      PCIE_TLP_WORKAROUNDSREG, w);
+    }
+
+    /* PR 34651 set bit6 to enable pcie-pm power mgmt in DLLP LC Reg, default is off */
+    if (sih->buscorerev == 1) {
+	w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_LCREG);
+	w |= (0x40);
+	pcie_writereg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_LCREG, w);
+    }
+
+    if (sih->buscorerev == 0) {
+	/* PR30841 WAR */
+	pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_TIMER1, 0x8128);
+	pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CDR, 0x0100);
+	pcie_mdiowrite(pi, MDIODATA_DEV_RX, SERDES_RX_CDRBW, 0x1466);
+    } else if (PCIE_ASPM(sih)) {
+	/* PR42766 WAR */
+	/* Change the L1 threshold for better performance */
+	w = pcie_readreg(osh, pcieregs, PCIE_PCIEREGS,
+			 PCIE_DLLP_PMTHRESHREG);
+	w &= ~(PCIE_L1THRESHOLDTIME_MASK);
+	w |= (PCIE_L1THRESHOLD_WARVAL << PCIE_L1THRESHOLDTIME_SHIFT);
+	pcie_writereg(osh, pcieregs, PCIE_PCIEREGS, PCIE_DLLP_PMTHRESHREG,
+		      w);
+
+	pcie_war_serdes(pi);
+
+	pcie_war_aspm_clkreq(pi);
+    } else if (pi->sih->buscorerev == 7)
+	pcie_war_noplldown(pi);
+
+    /* Note that the fix is actually in the SROM, that's why this is open-ended */
+    if (pi->sih->buscorerev >= 6)
+	pcie_misc_config_fixup(pi);
+}
+
+void pcie_war_ovr_aspm_disable(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    pi->pcie_war_aspm_ovr = FALSE;
+
+    /* Update the current state */
+    pcie_war_aspm_clkreq(pi);
+}
+
+/* ***** Functions called during driver state changes ***** */
+void pcicore_attach(void *pch, char *pvars, int state)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    si_t *sih = pi->sih;
+
+    /* Determine if this board needs override */
+    pi->pcie_war_aspm_ovr = ((sih->boardvendor == VENDOR_APPLE) &&
+			     ((uint8) getintvar(pvars, "sromrev") == 4) &&
+			     ((uint8) getintvar(pvars, "boardrev") <=
+			      0x71))
+	|| ((uint32) getintvar(pvars, "boardflags2") & BFL2_PCIEWAR_OVR);
+
+    /* These need to happen in this order only */
+    pcie_war_polarity(pi);
+
+    pcie_war_serdes(pi);
+
+    pcie_war_aspm_clkreq(pi);
+
+    pcie_clkreq_upd(pi, state);
+}
+
+void pcicore_hwup(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    if (!pi || !PCIE(pi->sih))
+	return;
+
+    if (pi->sih->boardtype == CB2_4321_BOARD
+	|| pi->sih->boardtype == CB2_4321_AG_BOARD)
+	pcicore_fixlatencytimer(pch, 0x20);
+
+    pcie_war_pci_setup(pi);
+}
+
+void pcicore_up(void *pch, int state)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    if (!pi || !PCIE(pi->sih))
+	return;
+
+    /* Restore L1 timer for better performance */
+    pcie_extendL1timer(pi, TRUE);
+
+    pcie_clkreq_upd(pi, state);
+}
+
+/* When the device is going to enter D3 state (or the system is going to enter S3/S4 states */
+void pcicore_sleep(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    uint32 w;
+
+    if (!pi || !PCIE_ASPM(pi->sih))
+	return;
+
+    /* PR43448: Clear ASPM L1 when going to sleep as while coming out of standby/sleep,
+     * ASPM L1 should not be accidentally enabled before driver has a chance to apply
+     * the WAR
+     */
+    w = OSL_PCI_READ_CONFIG(pi->osh, pi->pciecap_lcreg_offset,
+			    sizeof(uint32));
+    w &= ~PCIE_CAP_LCREG_ASPML1;
+    OSL_PCI_WRITE_CONFIG(pi->osh, pi->pciecap_lcreg_offset, sizeof(uint32),
+			 w);
+
+    /* Clear the state for PR42767 to make sure it's applied on the way up */
+    pi->pcie_pr42767 = FALSE;
+}
+
+void pcicore_down(void *pch, int state)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    if (!pi || !PCIE(pi->sih))
+	return;
+
+    pcie_clkreq_upd(pi, state);
+
+    /* Reduce L1 timer for better power savings */
+    pcie_extendL1timer(pi, FALSE);
+}
+
+/* ***** Wake-on-wireless-LAN (WOWL) support functions ***** */
+/* Just uses PCI config accesses to find out, when needed before sb_attach is done */
+bool pcicore_pmecap_fast(osl_t *osh)
+{
+    uint8 cap_ptr;
+    uint32 pmecap;
+
+    cap_ptr =
+	pcicore_find_pci_capability(osh, PCI_CAP_POWERMGMTCAP_ID, NULL,
+				    NULL);
+
+    if (!cap_ptr)
+	return FALSE;
+
+    pmecap = OSL_PCI_READ_CONFIG(osh, cap_ptr, sizeof(uint32));
+
+    return ((pmecap & PME_CAP_PM_STATES) != 0);
+}
+
+/* return TRUE if PM capability exists in the pci config space
+ * Uses and caches the information using core handle
+ */
+static bool pcicore_pmecap(pcicore_info_t *pi)
+{
+    uint8 cap_ptr;
+    uint32 pmecap;
+
+    if (!pi->pmecap_offset) {
+	cap_ptr =
+	    pcicore_find_pci_capability(pi->osh, PCI_CAP_POWERMGMTCAP_ID,
+					NULL, NULL);
+	if (!cap_ptr)
+	    return FALSE;
+
+	pi->pmecap_offset = cap_ptr;
+
+	pmecap =
+	    OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset,
+				sizeof(uint32));
+
+	/* At least one state can generate PME */
+	pi->pmecap = (pmecap & PME_CAP_PM_STATES) != 0;
+    }
+
+    return pi->pmecap;
+}
+
+/* Enable PME generation */
+void pcicore_pmeen(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    uint32 w;
+
+    /* if not pmecapable return */
+    if (!pcicore_pmecap(pi))
+	return;
+
+    w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			    sizeof(uint32));
+    w |= (PME_CSR_PME_EN);
+    OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			 sizeof(uint32), w);
+}
+
+/* Disable PME generation, clear the PME status bit if set and
+ * return TRUE if PME status set
+ */
+bool pcicore_pmeclr(void *pch)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    uint32 w;
+    bool ret = FALSE;
+
+    if (!pcicore_pmecap(pi))
+	return ret;
+
+    w = OSL_PCI_READ_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			    sizeof(uint32));
+
+    PCI_ERROR(("pcicore_pci_pmeclr PMECSR : 0x%x\n", w));
+    ret = (w & PME_CSR_PME_STAT) == PME_CSR_PME_STAT;
+
+    /* PMESTAT is cleared by writing 1 to it */
+    w &= ~(PME_CSR_PME_EN);
+
+    OSL_PCI_WRITE_CONFIG(pi->osh, pi->pmecap_offset + PME_CSR_OFFSET,
+			 sizeof(uint32), w);
+
+    return ret;
+}
+
+
+/* WAR for PR5730: If the latency value is zero set it to 0x20, which exceeds the PCI burst
+ * size; this is only seen on certain Ricoh controllers, and only on Vista, and should
+ * only be applied to 4321 single/dualband cardbus cards for now
+ */
+static void pcicore_fixlatencytimer(pcicore_info_t *pch, uint8 timer_val)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    osl_t *osh = pi->osh;
+    uint8 lattim = read_pci_cfg_byte(PCI_CFG_LATTIM);
+
+    if (!lattim) {
+	PCI_ERROR(("%s: Modifying PCI_CFG_LATTIM from 0x%x to 0x%x\n",
+		   __FUNCTION__, lattim, timer_val));
+	write_pci_cfg_byte(PCI_CFG_LATTIM, timer_val);
+    }
+}
+
+#ifdef BCMDBG
+uint32 pcie_lcreg(void *pch, uint32 mask, uint32 val)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    uint8 offset;
+
+    offset = pi->pciecap_lcreg_offset;
+    if (!offset)
+	return 0;
+
+    /* set operation */
+    if (mask)
+	OSL_PCI_WRITE_CONFIG(pi->osh, offset, sizeof(uint32), val);
+
+    return OSL_PCI_READ_CONFIG(pi->osh, offset, sizeof(uint32));
+}
+
+void pcicore_dump(void *pch, struct bcmstrbuf *b)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    bcm_bprintf(b, "FORCEHT %d pcie_polarity 0x%x pcie_war_ovr %d\n",
+		pi->sih->pci_pr32414, pi->pcie_polarity,
+		pi->pcie_war_aspm_ovr);
+}
+#endif				/* BCMDBG */
+
+#ifdef BCMINTERNAL
+uint32
+pcicore_pciereg(void *pch, uint32 offset, uint32 mask, uint32 val,
+		uint type)
+{
+    uint32 reg_val = 0;
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    osl_t *osh = pi->osh;
+
+    if (mask) {
+	PCI_ERROR(("PCIEREG: 0x%x writeval  0x%x\n", offset, val));
+	pcie_writereg(osh, pcieregs, type, offset, val);
+    }
+
+    /* Should not read register 0x154 */
+    /* PR42815: PCIE: Accesses to dlinkPCIE1_1 register (0x154 address) broken */
+    if (pi->sih->buscorerev <= 5 && offset == PCIE_DLLP_PCIE11
+	&& type == PCIE_PCIEREGS)
+	return reg_val;
+
+    reg_val = pcie_readreg(osh, pcieregs, type, offset);
+    PCI_ERROR(("PCIEREG: 0x%x readval is 0x%x\n", offset, reg_val));
+
+    return reg_val;
+}
+
+uint32
+pcicore_pcieserdesreg(void *pch, uint32 mdioslave, uint32 offset,
+		      uint32 mask, uint32 val)
+{
+    uint32 reg_val = 0;
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+
+    if (mask) {
+	PCI_ERROR(("PCIEMDIOREG: 0x%x writeval  0x%x\n", offset, val));
+	pcie_mdiowrite(pi, mdioslave, offset, val);
+    }
+
+    if (pcie_mdioread(pi, mdioslave, offset, &reg_val))
+	reg_val = 0xFFFFFFFF;
+    PCI_ERROR(("PCIEMDIOREG: dev 0x%x offset 0x%x read 0x%x\n", mdioslave,
+	       offset, reg_val));
+
+    return reg_val;
+}
+#endif				/* BCMINTERNAL */
+
+#if defined(BCMINTERNAL) && defined(BCMDBG)
+const struct fielddesc pcie_plp_regdesc[] = {
+    {"Mode 0x%04x ", PCIE_PLP_MODEREG, 4},
+    {"Status 0x%04x ", PCIE_PLP_STATUSREG, 4},
+    {"LTSSMControl 0x%04x ", PCIE_PLP_LTSSMCTRLREG, 4},
+    {"LinkNumber 0x%04x ", PCIE_PLP_LTLINKNUMREG, 4},
+    {"LaneNumber 0x%04x ", PCIE_PLP_LTLANENUMREG, 4},
+    {"N_FTS 0x%04x ", PCIE_PLP_LTNFTSREG, 4},
+    {"Attention 0x%04x ", PCIE_PLP_ATTNREG, 4},
+    {"AttentionMask 0x%04x ", PCIE_PLP_ATTNMASKREG, 4},
+    {"RxErrCnt 0x%04x ", PCIE_PLP_RXERRCTR, 4},
+    {"RxFramingErrCnt 0x%04x ", PCIE_PLP_RXFRMERRCTR, 4},
+    {"TestCtrl 0x%04x ", PCIE_PLP_TESTCTRLREG, 4},
+    {"SERDESCtrlOvrd 0x%04x ", PCIE_PLP_SERDESCTRLOVRDREG, 4},
+    {"TimingparamOvrd 0x%04x ", PCIE_PLP_TIMINGOVRDREG, 4},
+    {"RXTXSMdbgReg 0x%04x ", PCIE_PLP_RXTXSMDIAGREG, 4},
+    {"LTSSMdbgReg 0x%04x\n", PCIE_PLP_LTSSMDIAGREG, 4},
+    {NULL, 0, 0}
+};
+
+const struct fielddesc pcie_dllp_regdesc[] = {
+    {"LinkControl 0x%04x ", PCIE_DLLP_LCREG, 4},
+    {"LinkStatus 0x%04x ", PCIE_DLLP_LSREG, 4},
+    {"LinkAttention 0x%04x ", PCIE_DLLP_LAREG, 4},
+    {"LinkAttentionMask 0x%04x ", PCIE_DLLP_LAMASKREG, 4},
+    {"NextTxSeqNum 0x%04x ", PCIE_DLLP_NEXTTXSEQNUMREG, 4},
+    {"AckedTxSeqNum 0x%04x ", PCIE_DLLP_ACKEDTXSEQNUMREG, 4},
+    {"PurgedTxSeqNum 0x%04x ", PCIE_DLLP_PURGEDTXSEQNUMREG, 4},
+    {"RxSeqNum 0x%04x ", PCIE_DLLP_RXSEQNUMREG, 4},
+    {"LinkReplay 0x%04x ", PCIE_DLLP_LRREG, 4},
+    {"LinkAckTimeout 0x%04x ", PCIE_DLLP_LACKTOREG, 4},
+    {"PowerManagementThreshold 0x%04x ", PCIE_DLLP_PMTHRESHREG, 4},
+    {"RetryBufferwrptr 0x%04x ", PCIE_DLLP_RTRYWPREG, 4},
+    {"RetryBufferrdptr 0x%04x ", PCIE_DLLP_RTRYRPREG, 4},
+    {"RetryBufferpuptr 0x%04x ", PCIE_DLLP_RTRYPPREG, 4},
+    {"RetryBufferRd/Wr 0x%04x ", PCIE_DLLP_RTRRWREG, 4},
+    {"ErrorCountthreshold 0x%04x ", PCIE_DLLP_ECTHRESHREG, 4},
+    {"TLPErrorcounter 0x%04x ", PCIE_DLLP_TLPERRCTRREG, 4},
+    {"Errorcounter 0x%04x ", PCIE_DLLP_ERRCTRREG, 4},
+    {"NAKRecdcounter 0x%04x ", PCIE_DLLP_NAKRXCTRREG, 4},
+    {"Test 0x%04x\n", PCIE_DLLP_TESTREG, 4},
+    {NULL, 0, 0}
+};
+
+const struct fielddesc pcie_tlp_regdesc[] = {
+    {"Config 0x%04x ", PCIE_TLP_CONFIGREG, 4},
+    {"Workarounds 0x%04x ", PCIE_TLP_WORKAROUNDSREG, 4},
+    {"WR-DMA-UA 0x%04x ", PCIE_TLP_WRDMAUPPER, 4},
+    {"WR-DMA-LA 0x%04x ", PCIE_TLP_WRDMALOWER, 4},
+    {"WR-DMA Len/BE 0x%04x ", PCIE_TLP_WRDMAREQ_LBEREG, 4},
+    {"RD-DMA-UA 0x%04x ", PCIE_TLP_RDDMAUPPER, 4},
+    {"RD-DMA-LA 0x%04x ", PCIE_TLP_RDDMALOWER, 4},
+    {"RD-DMA Len 0x%04x ", PCIE_TLP_RDDMALENREG, 4},
+    {"MSI-DMA-UA 0x%04x ", PCIE_TLP_MSIDMAUPPER, 4},
+    {"MSI-DMA-LA 0x%04x ", PCIE_TLP_MSIDMALOWER, 4},
+    {"MSI-DMALen 0x%04x ", PCIE_TLP_MSIDMALENREG, 4},
+    {"SlaveReqLen 0x%04x ", PCIE_TLP_SLVREQLENREG, 4},
+    {"FlowControlInput 0x%04x ", PCIE_TLP_FCINPUTSREQ, 4},
+    {"TxStateMachine 0x%04x ", PCIE_TLP_TXSMGRSREQ, 4},
+    {"AddressAckXferCnt 0x%04x ", PCIE_TLP_ADRACKCNTARBLEN, 4},
+    {"DMACompletion HDR0 0x%04x ", PCIE_TLP_DMACPLHDR0, 4},
+    {"DMACompletion HDR1 0x%04x ", PCIE_TLP_DMACPLHDR1, 4},
+    {"DMACompletion HDR2 0x%04x ", PCIE_TLP_DMACPLHDR2, 4},
+    {"DMACompletionMISC0 0x%04x ", PCIE_TLP_DMACPLMISC0, 4},
+    {"DMACompletionMISC1 0x%04x ", PCIE_TLP_DMACPLMISC1, 4},
+    {"DMACompletionMISC2 0x%04x ", PCIE_TLP_DMACPLMISC2, 4},
+    {"SplitControllerReqLen 0x%04x ", PCIE_TLP_SPTCTRLLEN, 4},
+    {"SplitControllerMISC0 0x%04x ", PCIE_TLP_SPTCTRLMSIC0, 4},
+    {"SplitControllerMISC1 0x%04x ", PCIE_TLP_SPTCTRLMSIC1, 4},
+    {"bus/dev/func 0x%04x ", PCIE_TLP_BUSDEVFUNC, 4},
+    {"ResetCounter 0x%04x ", PCIE_TLP_RESETCTR, 4},
+    {"RetryBufferValue 0x%04x ", PCIE_TLP_RTRYBUF, 4},
+    {"TargetDebug1 0x%04x ", PCIE_TLP_TGTDEBUG1, 4},
+    {"TargetDebug2 0x%04x ", PCIE_TLP_TGTDEBUG2, 4},
+    {"TargetDebug3 0x%04x\n", PCIE_TLP_TGTDEBUG3, 4},
+    {NULL, 0, 0}
+};
+
+/* size that can take bitfielddump */
+#define BITFIELD_DUMP_SIZE  320
+
+/* Dump PCIE PLP/DLLP/TLP  diagnostic registers */
+int pcicore_dump_pcieregs(void *pch, struct bcmstrbuf *b)
+{
+    pcicore_info_t *pi = (pcicore_info_t *) pch;
+    sbpcieregs_t *pcieregs = pi->regs.pcieregs;
+    si_t *sih = pi->sih;
+    uint reg_val = 0;
+    char bitfield_dump_buf[BITFIELD_DUMP_SIZE];
+
+    bcm_bprintf(b, "PLPRegs \t");
+    bcmdumpfields(si_pcie_readreg, (void *) (uintptr) pi->sih,
+		  PCIE_PCIEREGS,
+		  (struct fielddesc *) (uintptr) pcie_plp_regdesc,
+		  bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "%s", bitfield_dump_buf);
+    bzero(bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "\n");
+    bcm_bprintf(b, "DLLPRegs \t");
+    bcmdumpfields(si_pcie_readreg, (void *) (uintptr) pi->sih,
+		  PCIE_PCIEREGS,
+		  (struct fielddesc *) (uintptr) pcie_dllp_regdesc,
+		  bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "%s", bitfield_dump_buf);
+    bzero(bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "\n");
+    bcm_bprintf(b, "TLPRegs \t");
+    bcmdumpfields(si_pcie_readreg, (void *) (uintptr) pi->sih,
+		  PCIE_PCIEREGS,
+		  (struct fielddesc *) (uintptr) pcie_tlp_regdesc,
+		  bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "%s", bitfield_dump_buf);
+    bzero(bitfield_dump_buf, BITFIELD_DUMP_SIZE);
+    bcm_bprintf(b, "\n");
+
+    /* enable mdio access to SERDES */
+    W_REG(pi->osh, (&pcieregs->mdiocontrol),
+	  MDIOCTL_PREAM_EN | MDIOCTL_DIVISOR_VAL);
+
+    bcm_bprintf(b, "SERDES regs \n");
+    if (sih->buscorerev >= 10) {
+	pcie_mdioread(pi, MDIO_DEV_IEEE0, 0x2, &reg_val);
+	bcm_bprintf(b, "block IEEE0, offset 2: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_IEEE0, 0x3, &reg_val);
+	bcm_bprintf(b, "block IEEE0, offset 2: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_IEEE1, 0x08, &reg_val);
+	bcm_bprintf(b, "block IEEE1, lanestatus: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_IEEE1, 0x0a, &reg_val);
+	bcm_bprintf(b, "block IEEE1, lanestatus2: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_BLK4, 0x16, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_BLK4, lanetest0: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_TXPLL, 0x11, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_TXPLL, pllcontrol: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_TXPLL, 0x12, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_TXPLL, plltimer1: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_TXPLL, 0x13, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_TXPLL, plltimer2: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_TXPLL, 0x14, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_TXPLL, plltimer3: 0x%x\n", reg_val);
+	pcie_mdioread(pi, MDIO_DEV_TXPLL, 0x17, &reg_val);
+	bcm_bprintf(b, "MDIO_DEV_TXPLL, freqdetcounter: 0x%x\n", reg_val);
+    } else {
+	pcie_mdioread(pi, MDIODATA_DEV_RX, SERDES_RX_TIMER1, &reg_val);
+	bcm_bprintf(b, "rxtimer1 0x%x ", reg_val);
+	pcie_mdioread(pi, MDIODATA_DEV_RX, SERDES_RX_CDR, &reg_val);
+	bcm_bprintf(b, "rxCDR 0x%x ", reg_val);
+	pcie_mdioread(pi, MDIODATA_DEV_RX, SERDES_RX_CDRBW, &reg_val);
+	bcm_bprintf(b, "rxCDRBW 0x%x\n", reg_val);
+    }
+
+    /* disable mdio access to SERDES */
+    W_REG(pi->osh, (&pcieregs->mdiocontrol), 0);
+
+    return 0;
+}
+
+#endif				/* BCMDBG && BCMINTERNAL */
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index c8c32f4..9e61122 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -51,3 +51,5 @@ obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
+obj-$(CONFIG_BCM53000)		+= fixup-bcm53000.o pci-bcm53000.o
+
diff --git a/arch/mips/pci/fixup-bcm53000.c b/arch/mips/pci/fixup-bcm53000.c
new file mode 100644
index 0000000..d38bb63
--- /dev/null
+++ b/arch/mips/pci/fixup-bcm53000.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Low-Level PCI and SB support for BCM53000 (Linux support code)
+ *
+ */
+#include <linux/pci.h>
+#include <asm/delay.h>
+#include <asm/bcmsi/typedefs.h>
+#include <asm/bcmsi/bcmutils.h>
+#include <asm/bcmsi/hndsoc.h>
+#include <asm/bcmsi/siutils.h>
+#include <asm/bcmsi/hndpci.h>
+#include <asm/bcmsi/pcicfg.h>
+#include <asm/bcmsi/bcmdevs.h>
+#include <asm/bcmsi/bcmnvram.h>
+#include <asm/bcmsi/hndcpu.h>
+
+/* Global SB handle */
+extern void *bcm53000_sih;
+extern spinlock_t bcm53000_sih_lock;
+
+/* Convenience */
+#define sih bcm53000_sih
+#define sih_lock bcm53000_sih_lock
+
+static u32 pci_iobase = 0x100;
+static u32 pci_membase;
+
+/* PCI port fixup */
+static bool fixup_pci_flag[] = {
+    FALSE,
+    FALSE
+};
+
+static void bcm53000_fixup(struct pci_dev *d)
+{
+    struct pci_bus *b;
+    struct list_head *ln;
+    struct resource *res;
+    unsigned int pos, reg, size;
+    u32 *base, l, align, *pcie = NULL;
+    u8 port, bar;
+
+    b = d->bus;
+
+    /* Fix up external PCI  and not the host bridge */
+    /* only fix up resources for devices */
+    if (b->number != 0) {
+	port = PCIE_GET_PORT_BY_BUS(b->number);
+
+	if (!fixup_pci_flag[port]) {
+	    pci_membase = SI_PCI_MEM(port);
+	    for (ln = b->devices.next; ln != &b->devices; ln = ln->next) {
+		d = pci_dev_b(ln);
+		if (PCI_SLOT(d->devfn) == 0) {
+		    continue;
+		}
+		bar = 0;
+		/* Fix up resource bases */
+		for (pos = 0; pos < 6; pos++) {
+		    res = &d->resource[pos];
+		    base = (res->flags & IORESOURCE_IO) ?
+			&pci_iobase : &pci_membase;
+		    reg = PCI_BASE_ADDRESS_0 + (pos << 2);
+
+		    pci_read_config_dword(d, reg, &l);
+
+		    if (l & PCI_BASE_ADDRESS_MEM_TYPE_64) {
+			pos++;
+		    }
+		    if (res->end) {
+			size = res->end - res->start + 1;
+			align =
+			    (*base & (size - 1)) ? (*base +
+						    size) & ~(size -
+							      1) : *base;
+			/* check if there's enough resource to assign */
+			if ((align + size) <=
+			    (SI_PCI_MEM(port) + SI_PCI_MEM_SZ)) {
+			    *base = align;
+			    res->start = *base;
+			    res->end = res->start + size - 1;
+			    *base += size;
+			    pci_write_config_dword(d, reg, res->start);
+
+			    pr_debug
+				("PCI: reserve %s region #%d:%x@%x for device %s\n",
+				 res->
+				 flags & IORESOURCE_IO ? "I/O" : "mem",
+				 bar, size, res->start, pci_name(d));
+
+			} else {
+
+			    pr_debug("PCI: Unable to reserve %s region #%d:%llx@%llx " "for device %s\n", res->flags & IORESOURCE_IO ? "I/O" : "mem", bar,	/* PCI BAR # */
+				     (unsigned long long)
+				     pci_resource_len(d, bar),
+				     (unsigned long long)
+				     pci_resource_start(d, bar),
+				     pci_name(d));
+			    break;
+			}
+		    }
+
+		    bar++;
+		}
+		/* Fix up interrupt lines */
+		pcie = si_setcore(sih, PCIE_CORE_ID, port);
+		if (pcie)
+		    d->irq = si_irq(sih) + 2;
+		else {
+		    d->irq = 2;
+		    printk("ERROR: pcie core does not exist!\n");
+		}
+		pci_write_config_byte(d, PCI_INTERRUPT_LINE, d->irq);
+		printk("dev %x irq %d\n", d->device, d->irq);
+	    }
+	    fixup_pci_flag[port] = TRUE;
+	}
+    }
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, bcm53000_fixup);
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+    return 0;
+}
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+    return (dev->irq + 2);
+}
+
+static void __init pcibios_fixup_resources(struct pci_dev *dev)
+{
+    ulong flags;
+    uint coreidx;
+    u16 pci_cmd;
+    void *regs;
+
+    if (dev->bus->number == 0) {
+	/*
+	 * Chipcommon, RAM controller and PCI bridge must not be reset!
+	 */
+	if (dev->device == MIPS_CORE_ID ||
+	    dev->device == MIPS33_CORE_ID ||
+	    dev->device == MIPS74K_CORE_ID ||
+	    dev->device == DMEMC_CORE_ID ||
+	    dev->device == PCIE_CORE_ID ||
+	    dev->device == SOCRAM_CORE_ID || dev->device == CC_CORE_ID) {
+	    return;
+	}
+	spin_lock_irqsave(&sih_lock, flags);
+	coreidx = si_coreidx(sih);
+	regs = si_setcoreidx(sih, PCI_SLOT(dev->devfn));
+	if (!regs) {
+	    si_setcoreidx(sih, coreidx);
+	    spin_unlock_irqrestore(&sih_lock, flags);
+	    return;
+	}
+
+	/*
+	 * The USB core requires a special bit to be set during core
+	 * reset to enable host (OHCI) mode. Resetting the SB core here
+	 * is a hack for compatibility with vanilla usb-ohci so that it
+	 * does not have to know about SB.  A driver that wants to  use
+	 * the  USB core in device mode should know about SB and should
+	 * reset the bit back to 0.
+	 */
+	if (si_coreid(sih) == USB_CORE_ID) {
+	    /* PR10028 WAR: Disable currently selected USB core first */
+	    si_core_disable(sih, si_core_cflags(sih, 0, 0));
+	    si_core_reset(sih, 1 << 13, 0);
+	}
+	/*
+	 * USB 2.0 special considerations:
+	 *
+	 * 1. Since the core supports both OHCI and EHCI functions, it must
+	 *    only be reset once.
+	 *
+	 * 2. In addition to the standard SI reset sequence, the Host Control
+	 *    Register must be programmed to bring the USB core and various
+	 *    phy components out of reset.
+	 */
+	else if (si_coreid(sih) == USB20H_CORE_ID) {
+	    if (!si_iscoreup(sih)) {
+		si_core_reset(sih, 0, 0);
+		writel(0x7ff, (uintptr) regs + 0x200);
+		udelay(1);
+	    }
+	} else {
+	    si_core_reset(sih, 0, 0);
+	}
+	si_setcoreidx(sih, coreidx);
+	spin_unlock_irqrestore(&sih_lock, flags);
+	return;
+    }
+
+    if (PCI_SLOT(dev->devfn) != 0)
+	return;
+
+    if (PCIE_IS_BUS_HOST_BRIDGE(dev->bus->number)) {
+	printk("PCI: Fixing up bridge\n");
+
+	/* Enable PCI bridge bus mastering and transparent access */
+	pci_read_config_word(dev, PCI_COMMAND, &pci_cmd);
+	pci_cmd |=
+	    (PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+	pci_write_config_word(dev, PCI_COMMAND, pci_cmd);
+
+	/* Enable PCI bridge BAR1 prefetch and burst */
+	pci_write_config_dword(dev, PCI_BAR1_CONTROL, 0x3);
+    }
+
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pcibios_fixup_resources);
diff --git a/arch/mips/pci/pci-bcm53000.c b/arch/mips/pci/pci-bcm53000.c
new file mode 100644
index 0000000..b5ca1c8
--- /dev/null
+++ b/arch/mips/pci/pci-bcm53000.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Low-Level PCI and SB support for BCM53000 (Linux support code)
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/paccess.h>
+
+#include <asm/bcmsi/typedefs.h>
+#include <asm/bcmsi/bcmutils.h>
+#include <asm/bcmsi/hndsoc.h>
+#include <asm/bcmsi/siutils.h>
+#include <asm/bcmsi/hndpci.h>
+#include <asm/bcmsi/pcicfg.h>
+#include <asm/bcmsi/bcmdevs.h>
+#include <asm/bcmsi/bcmnvram.h>
+
+/* Convenience */
+extern si_t *bcm53000_sih;
+extern spinlock_t bcm53000_sih_lock;
+
+#define sih bcm53000_sih
+#define sih_lock bcm53000_sih_lock
+
+static int
+bcm53000_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+			 int where, int size, u32 *value)
+{
+    unsigned long flags;
+    int ret;
+    u8 val8;
+    u16 val16;
+    u32 *pval;
+
+    spin_lock_irqsave(&sih_lock, flags);
+
+	if (size == 1)
+		pval = &val8;
+	else if (size == 2)
+		pval = &val16;
+	else
+		pval = value;
+
+    ret =
+	hndpci_read_config(sih, bus->number, PCI_SLOT(devfn),
+			   PCI_FUNC(devfn), where, pval, size);
+
+	if (size == 1)
+		*value = (u32) val8;
+	else if (size == 2)
+		*value = (u32) val16;
+
+    spin_unlock_irqrestore(&sih_lock, flags);
+    return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+
+}
+
+static int
+bcm53000_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+			  int where, int size, u32 value)
+{
+    unsigned long flags;
+    int ret;
+    u8 val8;
+    u16 val16;
+    u32 *pval;
+
+    spin_lock_irqsave(&sih_lock, flags);
+    if (size == 1) {
+	val8 = value;
+	pval = &val8;
+    } else if (size == 2) {
+	val16 = value;
+	pval = &val16;
+    } else {
+	pval = &value;
+    }
+    ret =
+	hndpci_write_config(sih, bus->number, PCI_SLOT(devfn),
+			    PCI_FUNC(devfn), where, pval, size);
+    spin_unlock_irqrestore(&sih_lock, flags);
+    return ret ? PCIBIOS_DEVICE_NOT_FOUND : PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops pcibios_ops = {
+    .read = bcm53000_pci_read_config,
+    .write = bcm53000_pci_write_config
+};
+
+static struct resource bcm53000_mem_resource_port0 = {
+    .name = "bcm53000 mem port 0",
+    .start = SI_PCI0_MEM,
+    .end = SI_PCI0_MEM + 0x04000000,
+    .flags = IORESOURCE_MEM,
+};
+
+static struct resource bcm53000_io_resource_port0 = {
+    .name = "bcm53000 io port 0",
+    .start = 0,
+    .end = 0,
+    .flags = IORESOURCE_IO,
+};
+
+static struct pci_controller bcm53000_controller_port0 = {
+    .pci_ops = &pcibios_ops,
+    .mem_resource = &bcm53000_mem_resource_port0,
+    .io_resource = &bcm53000_io_resource_port0,
+};
+
+static struct resource bcm53000_mem_resource_port1 = {
+    .name = "bcm53000 mem port1",
+    .start = SI_PCI1_MEM,
+    .end = SI_PCI1_MEM + 0x04000000,
+    .flags = IORESOURCE_MEM,
+};
+
+static struct resource bcm53000_io_resource_port1 = {
+    .name = "bcm53000 io port 1",
+    .start = 1,
+    .end = 1,
+    .flags = IORESOURCE_IO,
+};
+
+static int bcm53000_pcibios_get_busno(void)
+{
+    return PCIE_PORT1_BUS_START;
+}
+
+static struct pci_controller bcm53000_controller_port1 = {
+    .pci_ops = &pcibios_ops,
+    .mem_resource = &bcm53000_mem_resource_port1,
+    .io_resource = &bcm53000_io_resource_port1,
+    .get_busno = bcm53000_pcibios_get_busno,
+};
+
+static int __init bcm53000_pcibios_init(void)
+{
+    ulong flags;
+    extern int pci_probe_only;
+
+    pci_probe_only = 1;
+    if (!(sih = si_kattach(SI_OSH)))
+	panic("sb_kattach failed");
+    spin_lock_init(&sih_lock);
+    spin_lock_irqsave(&sih_lock, flags);
+
+    hndpci_init(sih);
+    spin_unlock_irqrestore(&sih_lock, flags);
+
+    register_pci_controller(&bcm53000_controller_port0);
+
+    register_pci_controller(&bcm53000_controller_port1);
+
+    return 0;
+}
+
+arch_initcall(bcm53000_pcibios_init);
-- 
1.7.0.4

