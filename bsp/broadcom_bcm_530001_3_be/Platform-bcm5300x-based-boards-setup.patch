From 7c2c264c71a2ce0a5d5c045fb4cf8695195340cd Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Sun, 6 Jun 2010 13:59:02 +0800
Subject: [PATCH 04/21] Platform bcm5300x based boards setup

Add early setup for bcm5300x

Source: from broadcom SDK

Signed-off-by: Liu Changhui <changhui.liu@windriver.com>
---
 arch/mips/bcm53000/Makefile |    2 +-
 arch/mips/bcm53000/prom.c   |  317 +++++++++++++++++++++++++++++++++++++++++++
 arch/mips/bcm53000/setup.c  |  188 +++++++++++++++++++++++++
 3 files changed, 506 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/bcm53000/prom.c
 create mode 100644 arch/mips/bcm53000/setup.c

diff --git a/arch/mips/bcm53000/Makefile b/arch/mips/bcm53000/Makefile
index d0af10e..18c8c8a 100644
--- a/arch/mips/bcm53000/Makefile
+++ b/arch/mips/bcm53000/Makefile
@@ -18,6 +18,6 @@
 #
 #
 
-obj-y += time.o 
+obj-y += time.o prom.o setup.o
 
 EXTRA_CFLAGS += -DCFE_API_ALL
diff --git a/arch/mips/bcm53000/prom.c b/arch/mips/bcm53000/prom.c
new file mode 100644
index 0000000..e5a3812
--- /dev/null
+++ b/arch/mips/bcm53000/prom.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Early initialization code for BCM953000 boards
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/reboot.h>
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmutils.h>
+#include <hndsoc.h>
+#include <siutils.h>
+#include <hndcpu.h>
+#include <mips74k_core.h>
+#include <cfe_api.h>
+#include <cfe_error.h>
+
+#ifdef CONFIG_HIGHMEM
+#define MAX_RAM_SIZE (0xffffffffULL)
+#else
+#define MAX_RAM_SIZE (0x1fffffffULL)
+#endif
+
+#define BCM53000_MAX_MEM_REGIONS 8
+phys_t board_mem_region_addrs[BCM53000_MAX_MEM_REGIONS];
+phys_t board_mem_region_sizes[BCM53000_MAX_MEM_REGIONS];
+unsigned int board_mem_region_count;
+
+int cfe_cons_handle;
+
+#ifdef CONFIG_BLK_DEV_INITRD
+extern unsigned long initrd_start, initrd_end;
+#endif
+
+
+static void ATTRIB_NORET cfe_linux_exit(void *arg)
+{
+    int warm = *(int *) arg;
+
+    if (smp_processor_id()) {
+	static int reboot_smp;
+
+	/* Don't repeat the process from another CPU */
+	if (!reboot_smp) {
+	    /* Get CPU 0 to do the cfe_exit */
+	    reboot_smp = 1;
+	    smp_call_function(cfe_linux_exit, arg, 1);
+	}
+    } else {
+	printk("Passing control back to CFE...\n");
+	cfe_exit(warm, 0);
+	printk("cfe_exit returned??\n");
+    }
+	while (1);
+}
+
+static void ATTRIB_NORET cfe_linux_restart(char *command)
+{
+    static const int zero;
+
+    cfe_linux_exit((void *) &zero);
+}
+
+static void ATTRIB_NORET cfe_linux_halt(void)
+{
+    static const int one = 1;
+
+    cfe_linux_exit((void *) &one);
+}
+
+static __init void prom_meminit(void)
+{
+    u64 addr, size, type;	/* regardless of 64BIT_PHYS_ADDR */
+    int mem_flags = 0;
+    unsigned int idx;
+    int rd_flag;
+#ifdef CONFIG_BLK_DEV_INITRD
+    unsigned long initrd_pstart;
+    unsigned long initrd_pend;
+
+    initrd_pstart = CPHYSADDR(initrd_start);
+    initrd_pend = CPHYSADDR(initrd_end);
+    if (initrd_start && ((initrd_pstart > MAX_RAM_SIZE)
+			 || (initrd_pend > MAX_RAM_SIZE))) {
+	panic("initrd out of addressable memory");
+    }
+#endif				/* INITRD */
+
+    for (idx = 0;
+	 cfe_enummem(idx, mem_flags, &addr, &size,
+		     &type) != CFE_ERR_NOMORE; idx++) {
+	rd_flag = 0;
+	if (type == CFE_MI_AVAILABLE) {
+	    /*
+	     * See if this block contains (any portion of) the
+	     * ramdisk
+	     */
+#ifdef CONFIG_BLK_DEV_INITRD
+	    if (initrd_start) {
+		if ((initrd_pstart > addr) &&
+		    (initrd_pstart < (addr + size))) {
+		    add_memory_region(addr,
+				      initrd_pstart - addr, BOOT_MEM_RAM);
+		    rd_flag = 1;
+		}
+		if ((initrd_pend > addr) && (initrd_pend < (addr + size))) {
+		    add_memory_region(initrd_pend,
+				      (addr + size) - initrd_pend,
+				      BOOT_MEM_RAM);
+		    rd_flag = 1;
+		}
+	    }
+#endif
+	    if (!rd_flag) {
+		if (addr > MAX_RAM_SIZE)
+		    continue;
+		if (addr + size > MAX_RAM_SIZE)
+		    size = MAX_RAM_SIZE - (addr + size) + 1;
+		/*
+		 * memcpy/__copy_user prefetch, which
+		 * will cause a bus error for
+		 * KSEG/KUSEG addrs not backed by RAM.
+		 * Hence, reserve some padding for the
+		 * prefetch distance.
+		 */
+		if (size > 512)
+		    size -= 512;
+		add_memory_region(addr, size, BOOT_MEM_RAM);
+	    }
+		board_mem_region_addrs[board_mem_region_count] = addr;
+		board_mem_region_sizes[board_mem_region_count] = size;
+		board_mem_region_count++;
+		if (board_mem_region_count == BCM53000_MAX_MEM_REGIONS) {
+		/*
+		 * Too many regions.  Need to configure more
+		 */
+			while (1);
+	    }
+	}
+    }
+#ifdef CONFIG_BLK_DEV_INITRD
+    if (initrd_start) {
+	add_memory_region(initrd_pstart, initrd_pend - initrd_pstart,
+			  BOOT_MEM_RESERVED);
+    }
+#endif
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+static int __init initrd_setup(char *str)
+{
+    char rdarg[64];
+    int idx;
+    char *tmp, *endptr;
+    unsigned long initrd_size;
+
+    /* Make a copy of the initrd argument so we can smash it up here */
+    for (idx = 0; idx < sizeof(rdarg) - 1; idx++) {
+	if (!str[idx] || (str[idx] == ' '))
+	    break;
+	rdarg[idx] = str[idx];
+    }
+
+    rdarg[idx] = 0;
+    str = rdarg;
+
+    /*
+     *Initrd location comes in the form "<hex size of ramdisk in bytes>@<location in memory>"
+     *  e.g. initrd=3abfd@80010000.  This is set up by the loader.
+     */
+    for (tmp = str; *tmp != '@'; tmp++) {
+	if (!*tmp) {
+	    goto fail;
+	}
+    }
+    *tmp = 0;
+    tmp++;
+    if (!*tmp) {
+	goto fail;
+    }
+    initrd_size = simple_strtoul(str, &endptr, 16);
+    if (*endptr) {
+	*(tmp - 1) = '@';
+	goto fail;
+    }
+    *(tmp - 1) = '@';
+    initrd_start = simple_strtoul(tmp, &endptr, 16);
+    if (*endptr) {
+	goto fail;
+    }
+    initrd_end = initrd_start + initrd_size;
+    printk("Found initrd of %lx@%lx\n", initrd_size, initrd_start);
+    return 1;
+  fail:
+    printk("Bad initrd argument.  Disabling initrd\n");
+    initrd_start = 0;
+    initrd_end = 0;
+    return 1;
+}
+
+#endif
+
+void __init prom_init(void)
+{
+    uint32_t cfe_ept, cfe_handle;
+    unsigned int cfe_eptseal;
+    int argc = fw_arg0;
+    char **envp = (char **) fw_arg2;
+    int *prom_vec = (int *) fw_arg3;
+    char temp[8];
+
+    _machine_restart = cfe_linux_restart;
+    _machine_halt = cfe_linux_halt;
+
+    /*
+     * Check if a loader was used; if NOT, the 4 arguments are
+     * what CFE gives us (handle, 0, EPT and EPTSEAL)
+     */
+    if (argc < 0) {
+	cfe_handle = (uint32_t) (long) argc;
+	cfe_ept = (long) envp;
+	cfe_eptseal = (uint32_t) (unsigned long) prom_vec;
+    } else {
+	if ((int32_t) (long) prom_vec < 0) {
+	    /*
+	     * Old loader; all it gives us is the handle,
+	     * so use the "known" entrypoint and assume
+	     * the seal.
+	     */
+	    cfe_handle = (uint32_t) (long) prom_vec;
+	    cfe_ept = (uint32_t) ((int32_t) 0x9fc00500);
+	    cfe_eptseal = CFE_EPTSEAL;
+	} else {
+	    /*
+	     * Newer loaders bundle the handle/ept/eptseal
+	     * Note: prom_vec is in the loader's useg
+	     * which is still alive in the TLB.
+	     */
+	    cfe_handle = (uint32_t) ((int32_t *) prom_vec)[0];
+	    cfe_ept = (uint32_t) ((int32_t *) prom_vec)[2];
+	    cfe_eptseal = (unsigned int) ((uint32_t *) prom_vec)[3];
+	}
+    }
+    if (cfe_eptseal != CFE_EPTSEAL) {
+		/* too early for panic to do any good */
+		printk("CFE's entrypoint seal doesn't match. Spinning.");
+		while (1);
+    }
+    cfe_init(cfe_handle, cfe_ept);
+    /*
+     * Get the handle for (at least) prom_putchar, possibly for
+     * boot console
+     */
+    cfe_cons_handle = cfe_getstdhandle(CFE_STDHANDLE_CONSOLE);
+
+    /*
+     * Overwrite LINUX_CMDLINE if it's given from bootloader.
+     * Since cfe_getenv() will overwrite the buffer even if not found,
+     * we use a temp buffer to check if the varaible is available.
+     */
+    if (cfe_getenv("LINUX_CMDLINE", temp, sizeof(temp)) == 0) {
+	cfe_getenv("LINUX_CMDLINE", arcs_cmdline, CL_SIZE);
+    }
+#ifdef CONFIG_BLK_DEV_INITRD
+    {
+	char *ptr;
+	/* Need to find out early whether we've got an initrd.
+	 * So scan the list looking now */
+	for (ptr = arcs_cmdline; *ptr; ptr++) {
+		while (*ptr == ' ')
+			ptr++;
+
+	    if (!strncmp(ptr, "initrd=", 7)) {
+		initrd_setup(ptr + 7);
+		break;
+	    } else {
+		while (*ptr && (*ptr != ' ')) {
+		    ptr++;
+		}
+	    }
+	}
+    }
+#endif				/* CONFIG_BLK_DEV_INITRD */
+
+    /* Not sure this is needed, but it's the safe way. */
+    arcs_cmdline[CL_SIZE - 1] = 0;
+
+
+    prom_meminit();
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
diff --git a/arch/mips/bcm53000/setup.c b/arch/mips/bcm53000/setup.c
new file mode 100644
index 0000000..3a92565
--- /dev/null
+++ b/arch/mips/bcm53000/setup.c
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Generic setup routines for Broadcom MIPS boards
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+
+#ifdef CONFIG_MTD_PARTITIONS
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/minix_fs.h>
+#include <linux/ext2_fs.h>
+#include <linux/romfs_fs.h>
+#include <linux/cramfs_fs.h>
+#endif
+
+#include <typedefs.h>
+#include <bcmdevs.h>
+#include <bcmutils.h>
+#include <bcmnvram.h>
+#include <siutils.h>
+#include <hndmips.h>
+#include <sbchipc.h>
+#include <hndchipc.h>
+#include <asm/bcmsi/cfe_api.h>
+#include <asm/bcmsi/cfe_error.h>
+
+extern void bcm53000_time_init(void);
+
+/* Global SB handle */
+si_t *bcm53000_sih = NULL;
+spinlock_t bcm53000_sih_lock = SPIN_LOCK_UNLOCKED;
+EXPORT_SYMBOL(bcm53000_sih);
+EXPORT_SYMBOL(bcm53000_sih_lock);
+
+/* Convenience */
+#define sih bcm53000_sih
+#define sih_lock bcm53000_sih_lock
+
+extern int m41t81_probe(void);
+extern int m41t81_set_time(unsigned long);
+extern unsigned long m41t81_get_time(void);
+
+static int bcm953000_rtc_hookup(void)
+{
+	if (m41t81_probe() < 0) {
+		return -ENXIO;
+	} 
+		return 0;
+}
+
+unsigned long read_persistent_clock(void)
+{
+    return m41t81_get_time();
+}
+
+int rtc_mips_set_time(unsigned long time)
+{
+    return m41t81_set_time(time);
+}
+
+void bcm53000_machine_restart(char *command)
+{
+    char name[128];
+    printk("Please stand by while rebooting the system...\n");
+
+    local_irq_disable();
+
+    if (sih->chiprev != 0) {
+	/* Set the watchdog timer to reset immediately */
+	si_watchdog(sih, 1);
+    } else {
+	/* Using the GPIO pins wired to CPU/board reset to achieve system reboot */
+	/* BCM953003C using GPIO 11 and 12 */
+	/* BCM953001R24M using GPIO 7 */
+	cfe_getenv("boardtype", name, 128);
+	if (!strncmp(name, "bcm953003c", strlen("bcm953003c"))) {
+		*(volatile uint32*)(0xb8000064) = 0x00001800;
+		*(volatile uint32*)(0xb8000068) = 0x0000f800;
+		*(volatile uint32*)(0xb8000064) = 0x00000000;
+	} else if (!strncmp(name, "bcm953001r", strlen("bcm953001r"))) {
+		*(volatile uint32*)(0xb8000064) = 0x00000080;
+		*(volatile uint32*)(0xb8000068) = 0x00000080;
+		*(volatile uint32*)(0xb8000064) = 0x00000000;
+	} else {
+	    /* The boards bcm953003rsp and bcm953003rwap use */
+	    /* GPIO 6 and 7 for the system reset */
+		*(volatile uint32*)(0xb8000064) = 0x000000c0;
+		*(volatile uint32*)(0xb8000068) = 0x000000c0;
+		*(volatile uint32*)(0xb8000064) = 0x00000000;
+	    /* Set the watchdog timer to reset immediately */
+	    si_watchdog(sih, 1);
+	}
+   }
+	while (1)
+		;
+}
+
+void bcm53000_machine_halt(void)
+{
+    printk("System halted\n");
+
+    /* Disable interrupts and watchdog and spin forever */
+    local_irq_disable();
+    si_watchdog(sih, 0);
+    while (1)
+		;
+}
+
+#ifdef CONFIG_SERIAL_8250
+static void __init serial_setup(si_t *sih)
+{
+    /*
+     * Since 8250 UART driver will control divider of UART module to achieve
+     * baud rate specified in kernel arguments, we simply use ALP clock
+     * (so the baud base is clock / 2).
+     */
+    si_serial_init(sih, NULL, 0);
+}
+#endif				/* CONFIG_SERIAL_8250 */
+
+/* Virtual IRQ base, after last hw IRQ */
+#define SBMIPS_VIRTIRQ_BASE	6
+
+void __init plat_mem_setup(void)
+{
+    /* Get global SB handle */
+    sih = si_kattach(SI_OSH);
+
+    /* Initialize clocks and interrupts */
+    si_mips_init(sih, SBMIPS_VIRTIRQ_BASE);
+
+#ifdef CONFIG_SERIAL_8250
+    /* Initialize UARTs */
+    serial_setup(sih);
+#endif
+
+    bcm953000_rtc_hookup();
+
+    /* Generic setup */
+    _machine_restart = bcm53000_machine_restart;
+    _machine_halt = bcm53000_machine_halt;
+    /* _machine_power_off = bcm53000_machine_halt; */
+    pm_power_off = bcm53000_machine_halt;
+
+    /* board_timer_setup = bcm53000_timer_setup; */
+}
+
+const char *get_system_type(void)
+{
+    static char s[32];
+
+    if (bcm53000_sih) {
+	sprintf(s, "Broadcom BCM%X chip rev %d", bcm53000_sih->chip,
+		bcm53000_sih->chiprev);
+	return s;
+    } else
+	return "Broadcom bcm53000";
+}
+
+void __init bus_error_init(void)
+{
+}
-- 
1.7.0.4

