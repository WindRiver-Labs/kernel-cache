From ee63566137064fd32c2455b5cee8745ca36ce5d4 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Sun, 6 Jun 2010 14:23:26 +0800
Subject: [PATCH 19/21] bcm5300x gmac driver

bcm5300x gmac driver

Source: from broadcom SDK

Signed-off-by: Liu Changhui <changhui.liu@windriver.com>
---
 drivers/net/Kconfig                  |    6 +
 drivers/net/Makefile                 |    1 +
 drivers/net/gmac/Makefile            |   29 +
 drivers/net/gmac/et_dbg.h            |   87 +
 drivers/net/gmac/et_export.h         |   48 +
 drivers/net/gmac/et_linux.c          | 1395 +++++++++++++
 drivers/net/gmac/et_linux.h          |   51 +
 drivers/net/gmac/etc.c               |  880 +++++++++
 drivers/net/gmac/etc.h               |  319 +++
 drivers/net/gmac/etcgmac.c           | 3564 ++++++++++++++++++++++++++++++++++
 drivers/net/gmac/etcgmac.h           |  815 ++++++++
 include/asm-mips/bcmsi/bcmgmacmib.h  |  107 +
 include/asm-mips/bcmsi/etioctl.h     |  143 ++
 include/asm-mips/bcmsi/gmac0_core.h  | 1233 ++++++++++++
 include/asm-mips/bcmsi/gmac_common.h |  566 ++++++
 15 files changed, 9244 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/gmac/Makefile
 create mode 100644 drivers/net/gmac/et_dbg.h
 create mode 100644 drivers/net/gmac/et_export.h
 create mode 100644 drivers/net/gmac/et_linux.c
 create mode 100644 drivers/net/gmac/et_linux.h
 create mode 100644 drivers/net/gmac/etc.c
 create mode 100644 drivers/net/gmac/etc.h
 create mode 100644 drivers/net/gmac/etcgmac.c
 create mode 100644 drivers/net/gmac/etcgmac.h
 create mode 100644 include/asm-mips/bcmsi/bcmgmacmib.h
 create mode 100644 include/asm-mips/bcmsi/etioctl.h
 create mode 100644 include/asm-mips/bcmsi/gmac0_core.h
 create mode 100644 include/asm-mips/bcmsi/gmac_common.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 2b4bbc4..0d87e1d 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1916,6 +1916,12 @@ config DL2K
 	  To compile this driver as a module, choose M here: the
 	  module will be called dl2k.
 
+config BCM5300x_GMAC
+	tristate "BCM5300x Gigabit Ethernet support"
+	depends on PCI
+	help
+	  This driver supports BCM5300x onboard  Gigabit ethernet cards,
+
 config E1000
 	tristate "Intel(R) PRO/1000 Gigabit Ethernet support"
 	depends on PCI
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 0818ce2..21d703b 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -138,6 +138,7 @@ obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
 
+obj-$(CONFIG_BCM5300x_GMAC) += gmac/
 obj-$(CONFIG_SLIP) += slip.o
 obj-$(CONFIG_SLHC) += slhc.o
 
diff --git a/drivers/net/gmac/Makefile b/drivers/net/gmac/Makefile
new file mode 100644
index 0000000..f4db67b
--- /dev/null
+++ b/drivers/net/gmac/Makefile
@@ -0,0 +1,29 @@
+#
+#  Copyright (C) 2009 Broadcom Corporation
+#
+#  This program is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License
+#  as published by the Free Software Foundation; either version 2
+#  of the License, or (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software
+#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+#
+#
+#
+obj-$(CONFIG_BCM53000)	+= et_linux.o etc.o etcgmac.o
+    EXTRA_CFLAGS += -DBCM47XX_CHOPS
+    EXTRA_CFLAGS += -I$(TOPDIR)/drivers/net/gmac
+    EXTRA_CFLAGS += -I$(TOPDIR)/include/asm-mips/bcmsi/proto	
+    ifdef CONFIG_CPU_BIG_ENDIAN
+    EXTRA_CFLAGS += -DIL_BIGENDIAN
+    endif 
+    ifdef CONFIG_QT
+    EXTRA_CFLAGS += -DCFG_QUICKTURN
+    endif
diff --git a/drivers/net/gmac/et_dbg.h b/drivers/net/gmac/et_dbg.h
new file mode 100644
index 0000000..bd5e202
--- /dev/null
+++ b/drivers/net/gmac/et_dbg.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ * 
+ * 
+ */
+/*
+ * Minimal debug/trace/assert driver definitions for
+ * Broadcom Home Networking Division 10/100 Mbit/s Ethernet
+ * Device Driver.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _et_dbg_
+#define _et_dbg_
+
+#ifdef	BCMDBG
+struct ether_header;
+extern void etc_prhdr(char *msg, struct ether_header *eh, uint len,
+		      int unit);
+extern void etc_prhex(char *msg, uchar *buf, uint nbytes, int unit);
+/*
+ * et_msg_level is a bitvector:
+ *	0	errors
+ *	1	function-level tracing
+ *	2	one-line frame tx/rx summary
+ *	3	complex frame tx/rx in hex
+ */
+#define	ET_ERROR(args)	if (!(et_msg_level & 1)) ; else printf args
+#define	ET_TRACE(args)	if (!(et_msg_level & 2)) ; else printf args
+#define	ET_PRHDR(msg, eh, len, unit)	if (!(et_msg_level & 4)) ; else etc_prhdr(msg, eh, len, unit)
+#define	ET_PRPKT(msg, buf, len, unit)	if (!(et_msg_level & 8)) ; else etc_prhex(msg, buf, len, unit)
+#else				/* BCMDBG */
+struct ether_header;
+extern void etc_prhdr(char *msg, struct ether_header *eh, uint len,
+		      int unit);
+extern void etc_prhex(char *msg, uchar *buf, uint nbytes, int unit);
+
+#define	ET_ERROR(args)
+#define	ET_TRACE(args)
+#define	ET_PRHDR(msg, eh, len, unit)
+#define	ET_PRPKT(msg, buf, len, unit)
+#endif				/* BCMDBG */
+
+extern uint32 et_msg_level;
+
+#ifdef BCMINTERNAL
+#define	ET_LOG(fmt, a1, a2)	if (!(et_msg_level & 0x10000)) ; else bcmlog(fmt, a1, a2)
+#else
+#define	ET_LOG(fmt, a1, a2)
+#endif
+
+/* include port-specific tunables */
+#ifdef NDIS
+#include <et_ndis.h>
+#elif defined(__ECOS)
+#include <et_ecos.h>
+#elif defined(vxworks)
+#include <et_vx.h>
+#elif defined(linux)
+#include <et_linux.h>
+#elif defined(PMON)
+#include <et_pmon.h>
+#elif defined(_CFE_)
+#include <et_cfe.h>
+#elif defined(_HNDRTE_)
+#include <et_rte.h>
+#else
+#error
+#endif
+
+#endif				/* _et_dbg_ */
diff --git a/drivers/net/gmac/et_export.h b/drivers/net/gmac/et_export.h
new file mode 100644
index 0000000..6200d53
--- /dev/null
+++ b/drivers/net/gmac/et_export.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Required functions exported by the port-specific (os-dependent) driver
+ * to common (os-independent) driver code.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *  
+ */
+
+#ifndef _et_export_h_
+#define _et_export_h_
+
+/* misc callbacks */
+extern void et_init(void *et, uint options);
+extern void et_reset(void *et);
+extern void et_link_up(void *et);
+extern void et_link_down(void *et);
+extern int et_up(void *et);
+extern int et_down(void *et, int reset);
+extern void et_dump(void *et, struct bcmstrbuf *b);
+extern void et_intrson(void *et);
+
+#ifdef BCM47XX_CHOPS
+/* for BCM5222 dual-phy shared mdio contortion */
+extern void *et_phyfind(void *et, uint coreunit);
+extern uint16 et_phyrd(void *et, uint phyaddr, uint reg);
+extern void et_phywr(void *et, uint reg, uint phyaddr, uint16 val);
+#endif
+
+#endif				/* _et_export_h_ */
diff --git a/drivers/net/gmac/et_linux.c b/drivers/net/gmac/et_linux.c
new file mode 100644
index 0000000..062906e
--- /dev/null
+++ b/drivers/net/gmac/et_linux.c
@@ -0,0 +1,1395 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Linux device driver for
+ * Broadcom BCM47XX 10/100/1000 Mbps Ethernet Controller
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#define __UNDEF_NO_VERSION__
+
+#include <asm/bcmsi/typedefs.h>
+
+#include <linux/module.h>
+#include <asm/bcmsi/linuxver.h>
+#include <asm/bcmsi/bcmdefs.h>
+#include <asm/bcmsi/osl.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/sockios.h>
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#endif				/* SIOCETHTOOL */
+#include <linux/ip.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/uaccess.h>
+
+
+#include <asm/bcmsi/bcmendian.h>
+#include <asm/bcmsi/bcmdefs.h>
+#include <asm/bcmsi/proto/ethernet.h>
+#include <asm/bcmsi/proto/vlan.h>
+#include <asm/bcmsi/bcmdevs.h>
+#include <asm/bcmsi/bcmenetmib.h>
+#include <asm/bcmsi/bcmgmacmib.h>
+#include <asm/bcmsi/bcmenetrxh.h>
+#include <asm/bcmsi/bcmenetphy.h>
+#include <asm/bcmsi/etioctl.h>
+#include <asm/bcmsi/bcmutils.h>
+#include <asm/bcmsi/pcicfg.h>
+#include <et_dbg.h>
+#include <asm/bcmsi/hndsoc.h>
+#include <asm/bcmsi/bcmgmacrxh.h>
+#include <etc.h>
+#include <asm/bcmsi/cfe_api.h>
+#include <asm/bcmsi/cfe_error.h>
+
+typedef struct et_info {
+    etc_info_t *etc;		/* pointer to common os-independent data */
+    struct net_device *dev;	/* backpoint to device */
+    struct pci_dev *pdev;	/* backpoint to pci_dev */
+    void *osh;			/* pointer to os handle */
+    spinlock_t lock;		/* per-device perimeter lock */
+    struct sk_buff_head txq[NUMTXQ];	/* send queue */
+    void *regsva;		/* opaque chip registers virtual address */
+    struct timer_list timer;	/* one second watchdog timer */
+    struct net_device_stats stats;	/* stat counter reporting structure */
+    int events;			/* bit channel between isr and dpc */
+    struct et_info *next;	/* pointer to next et_info_t in chain */
+#ifndef BCM_NAPI
+    struct tasklet_struct tasklet;	/* dpc tasklet */
+#endif				/* BCM_NAPI */
+    bool resched;		/* dpc was rescheduled */
+} et_info_t;
+
+
+#define EPI_VERSION_STR     "3.50.21.0"
+
+static int et_found = 0;
+static et_info_t *et_list = NULL;
+
+/* defines */
+#define DATAHIWAT   50		/* data msg txq hiwat mark */
+
+#define ET_INFO(dev)    (et_info_t*)((dev)->priv)
+#define ET_GMAC(etc)    ((etc)->coreid == GMAC_CORE_ID)
+
+#define ET_LOCK(et) spin_lock_bh(&(et)->lock)
+#define ET_UNLOCK(et)   spin_unlock_bh(&(et)->lock)
+
+#define INT_LOCK(flags)     local_irq_save(flags)
+#define INT_UNLOCK(flags)   local_irq_restore(flags)
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 4, 5)
+#error Linux version must be newer than 2.4.5
+#endif				/* LINUX_VERSION_CODE <= KERNEL_VERSION(2, 4, 5) */
+
+/* prototypes called by etc.c */
+void et_init(et_info_t *et, uint options);
+void et_reset(et_info_t *et);
+void et_link_up(et_info_t *et);
+void et_link_down(et_info_t *et);
+void et_up(et_info_t *et);
+void et_down(et_info_t *et, int reset);
+void et_dump(et_info_t *et, struct bcmstrbuf *b);
+
+/* local prototypes */
+static void et_free(et_info_t *et);
+static int et_open(struct net_device *dev);
+static int et_close(struct net_device *dev);
+static int et_start(struct sk_buff *skb, struct net_device *dev);
+static void et_sendnext(et_info_t *et);
+static struct net_device_stats *et_get_stats(struct net_device *dev);
+static int et_set_mac_address(struct net_device *dev, void *addr);
+static void et_set_multicast_list(struct net_device *dev);
+static void et_watchdog(ulong data);
+static int et_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+static irqreturn_t et_isr(int irq, void *dev_id);
+#else
+static irqreturn_t et_isr(int irq, void *dev_id, struct pt_regs *ptregs);
+#endif
+#ifdef BCM_NAPI
+static int et_poll(struct net_device *dev, int *budget);
+#else				/* BCM_NAPI */
+static void et_dpc(ulong data);
+#endif				/* BCM_NAPI */
+static void et_sendup(et_info_t *et, struct sk_buff *skb);
+#ifdef BCMDBG
+static void et_dumpet(et_info_t *et, struct bcmstrbuf *b);
+#endif				/* BCMDBG */
+
+/* recognized PCI IDs */
+static struct pci_device_id et_id_table[] __devinitdata = {
+	{	.vendor	=	PCI_ANY_ID,
+		.device	=	PCI_ANY_ID,
+		.subvendor	=	PCI_ANY_ID,
+		.subdevice	=	PCI_ANY_ID,
+		.class	=	PCI_CLASS_NETWORK_ETHERNET << 8,
+		.class_mask	=	0xffff00,
+		.driver_data	=	0,
+	},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(pci, et_id_table);
+
+#if defined(BCMDBG)
+static uint32 msglevel = 0xdeadbeef;
+module_param(msglevel, uint, 0644);
+#endif				/* defined(BCMDBG) */
+
+static int __devinit
+et_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+    struct net_device *dev;
+    et_info_t *et = NULL;
+    osl_t *osh;
+    char name[128];
+    int i, unit = et_found;
+
+#if defined(BCMDBG)
+    if (msglevel != 0xdeadbeef) {
+	et_msg_level = msglevel;
+
+	printf("et%d: et_probe: et_msg_level set to 0x%x\n", unit,
+	       msglevel);
+    }
+#endif				/* defined(BCMDBG) */
+    ET_TRACE(("et%d: et_probe: bus %d slot %d func %d irq %d\n", unit,
+	      pdev->bus->number, PCI_SLOT(pdev->devfn),
+	      PCI_FUNC(pdev->devfn), pdev->irq));
+
+    if (!etc_chipmatch(pdev->vendor, pdev->device))
+	return -ENODEV;
+
+    et_found++;
+    cfe_getenv("boardtype", name, 128);
+
+    if (!strncmp(name, "bcm953003c", strlen("bcm953003c"))) {
+	if (et_found == 1) {
+	    return -ENODEV;
+	}
+    } else if (!strncmp(name, "bcm953001r", strlen("bcm953001r"))) {
+	return -ENODEV;
+    }
+
+    osh = osl_attach(pdev, PCI_BUS, FALSE);
+    ASSERT(osh);
+
+    pci_set_master(pdev);
+    pci_enable_device(pdev);
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+    if ((dev = alloc_etherdev(0)) == NULL) {
+	ET_ERROR(("et%d: et_probe: alloc_etherdev() failed\n", unit));
+	osl_detach(osh);
+	return -ENOMEM;
+    }
+#else
+    if (!
+	(dev =
+	 (struct net_device *) MALLOC(osh, sizeof(struct net_device)))) {
+	ET_ERROR(("et%d: et_probe: out of memory, malloced %d bytes\n",
+		  unit, MALLOCED(osh)));
+	osl_detach(osh);
+	return -ENOMEM;
+    }
+    bzero(dev, sizeof(struct net_device));
+
+    if (!init_etherdev(dev, 0)) {
+	ET_ERROR(("et%d: et_probe: init_etherdev() failed\n", unit));
+	MFREE(osh, dev, sizeof(struct net_device));
+	osl_detach(osh);
+	return -ENOMEM;
+    }
+#endif				/* >= 2.6.0 */
+
+    /* allocate private info */
+    if ((et = (et_info_t *) MALLOC(osh, sizeof(et_info_t))) == NULL) {
+	ET_ERROR(("et%d: et_probe: out of memory, malloced %d bytes\n",
+		  unit, MALLOCED(osh)));
+	MFREE(osh, dev, sizeof(et_info_t));
+	osl_detach(osh);
+	return -ENOMEM;
+    }
+    bzero(et, sizeof(et_info_t));
+    dev->priv = (void *) et;
+    et->dev = dev;
+    et->pdev = pdev;
+    et->osh = osh;
+    pci_set_drvdata(pdev, et);
+
+    if (!strncmp(name, "bcm953003c", strlen("bcm953003c"))) {
+	strcpy(dev->name, "eth1");
+    } else {
+	dev_alloc_name(dev, dev->name);
+    }
+    /* map chip registers (47xx: and sprom) */
+    dev->base_addr = pci_resource_start(pdev, 0);
+    if ((et->regsva =
+	 ioremap_nocache(dev->base_addr, PCI_BAR0_WINSZ)) == NULL) {
+	ET_ERROR(("et%d: ioremap() failed\n", unit));
+	goto fail;
+    }
+
+    spin_lock_init(&et->lock);
+
+    for (i = 0; i < NUMTXQ; i++)
+	skb_queue_head_init(&et->txq[i]);
+
+    /* common load-time initialization */
+    if ((et->etc =
+	 etc_attach((void *) et, pdev->vendor, pdev->device, unit, osh,
+		    et->regsva)) == NULL) {
+	ET_ERROR(("et%d: etc_attach() failed\n", unit));
+	goto fail;
+    }
+
+    bcopy(&et->etc->cur_etheraddr, dev->dev_addr, ETHER_ADDR_LEN);
+
+    /* init 1 second watchdog timer */
+    init_timer(&et->timer);
+    et->timer.data = (ulong) dev;
+    et->timer.function = et_watchdog;
+
+#ifndef BCM_NAPI
+    /* setup the bottom half handler */
+    tasklet_init(&et->tasklet, et_dpc, (ulong) et);
+#endif				/* BCM_NAPI */
+
+    /* register our interrupt handler */
+    if (request_irq(pdev->irq, et_isr, IRQF_SHARED, dev->name, et)) {
+	ET_ERROR(("et%d: request_irq() failed\n", unit));
+	goto fail;
+    }
+    dev->irq = pdev->irq;
+
+    /* add us to the global linked list */
+    et->next = et_list;
+    et_list = et;
+
+    /* lastly, enable our entry points */
+    dev->open = et_open;
+    dev->stop = et_close;
+    dev->hard_start_xmit = et_start;
+    dev->get_stats = et_get_stats;
+    dev->set_mac_address = et_set_mac_address;
+    dev->set_multicast_list = et_set_multicast_list;
+    dev->do_ioctl = et_ioctl;
+#ifdef BCM_NAPI
+    dev->poll = et_poll;
+    dev->weight = (ET_GMAC(et->etc) ? 64 : 32);
+#endif				/* BCM_NAPI */
+
+
+    if (register_netdev(dev)) {
+	ET_ERROR(("et%d: register_netdev() failed\n", unit));
+	goto fail;
+    }
+
+
+    /* print hello string */
+    (*et->etc->chops->longname) (et->etc->ch, name, sizeof(name));
+    printf("%s: %s %s\n", dev->name, name, EPI_VERSION_STR);
+
+    return (0);
+
+  fail:
+    et_free(et);
+    return (-ENODEV);
+}
+
+static int et_suspend(struct pci_dev *pdev, DRV_SUSPEND_STATE_TYPE state)
+{
+    et_info_t *et;
+
+    if ((et = (et_info_t *) pci_get_drvdata(pdev))) {
+	netif_device_detach(et->dev);
+	ET_LOCK(et);
+	et_down(et, 1);
+	ET_UNLOCK(et);
+    }
+
+    return 0;
+}
+
+static int et_resume(struct pci_dev *pdev)
+{
+    et_info_t *et;
+
+    if ((et = (et_info_t *) pci_get_drvdata(pdev))) {
+	ET_LOCK(et);
+	et_up(et);
+	ET_UNLOCK(et);
+	netif_device_attach(et->dev);
+    }
+
+    return 0;
+}
+
+/* Compatibility routines */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6)
+static void _et_suspend(struct pci_dev *pdev)
+{
+    et_suspend(pdev, 0);
+}
+
+static void _et_resume(struct pci_dev *pdev)
+{
+    et_resume(pdev);
+}
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6) */
+
+static void __devexit et_remove(struct pci_dev *pdev)
+{
+    et_info_t *et;
+
+    if (!etc_chipmatch(pdev->vendor, pdev->device))
+	return;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
+    et_suspend(pdev, 0);
+#else
+    et_suspend(pdev, PMSG_SUSPEND);
+#endif
+
+    if ((et = (et_info_t *) pci_get_drvdata(pdev))) {
+	et_free(et);
+	pci_set_drvdata(pdev, NULL);
+    }
+}
+
+static struct pci_driver et_pci_driver = {
+	.name	=	"et",
+	.probe	=	et_probe,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6)
+	.suspend	=	_et_suspend,
+	.resume	=	_et_resume,
+#else
+	.suspend	=	et_suspend,
+	.resume	=	et_resume,
+#endif				/* LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 6) */
+	.remove	=	__devexit_p(et_remove),
+	.id_table	=	et_id_table,
+};
+
+static int __init et_module_init(void)
+{
+    return pci_module_init(&et_pci_driver);
+}
+
+static void __exit et_module_exit(void)
+{
+    pci_unregister_driver(&et_pci_driver);
+}
+
+module_init(et_module_init);
+module_exit(et_module_exit);
+
+static void et_free(et_info_t *et)
+{
+    et_info_t **prev;
+    osl_t *osh;
+
+    if (et == NULL)
+	return;
+
+    ET_TRACE(("et: et_free\n"));
+
+    if (et->dev && et->dev->irq)
+	free_irq(et->dev->irq, et);
+
+    if (et->dev) {
+	unregister_netdev(et->dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
+	free_netdev(et->dev);
+#else
+	MFREE(et->osh, et->dev, sizeof(struct net_device));
+#endif
+	et->dev = NULL;
+    }
+
+    /* free common resources */
+    if (et->etc) {
+	etc_detach(et->etc);
+	et->etc = NULL;
+    }
+
+    /*
+     * unregister_netdev() calls get_stats() which may read chip registers
+     * so we cannot unmap the chip registers until after calling unregister_netdev() .
+     */
+    if (et->regsva) {
+	iounmap((void *) et->regsva);
+	et->regsva = NULL;
+    }
+
+    /* remove us from the global linked list */
+    for (prev = &et_list; *prev; prev = &(*prev)->next)
+	if (*prev == et) {
+	    *prev = et->next;
+	    break;
+	}
+
+    osh = et->osh;
+    MFREE(et->osh, et, sizeof(et_info_t));
+
+    ASSERT(MALLOCED(osh) == 0);
+
+    osl_detach(osh);
+}
+
+static int et_open(struct net_device *dev)
+{
+    et_info_t *et;
+
+    et = ET_INFO(dev);
+
+    ET_TRACE(("et%d: et_open\n", et->etc->unit));
+
+    et->etc->promisc = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
+
+    ET_LOCK(et);
+    et_up(et);
+    ET_UNLOCK(et);
+
+    OLD_MOD_INC_USE_COUNT;
+
+    return 0;
+}
+
+static int et_close(struct net_device *dev)
+{
+    et_info_t *et;
+
+    et = ET_INFO(dev);
+
+    ET_TRACE(("et%d: et_close\n", et->etc->unit));
+
+    et->etc->promisc = FALSE;
+
+    ET_LOCK(et);
+    et_down(et, 1);
+    ET_UNLOCK(et);
+
+    OLD_MOD_DEC_USE_COUNT;
+
+    return (0);
+}
+
+/*
+ * Yeah, queueing the packets on a tx queue instead of throwing them
+ * directly into the descriptor ring in the case of dma is kinda lame,
+ * but this results in a unified transmit path for both dma and pio
+ * and localizes/simplifies the netif_*_queue semantics, too.
+ */
+static int et_start(struct sk_buff *skb, struct net_device *dev)
+{
+    et_info_t *et;
+    uint32 q = 0;
+
+    et = ET_INFO(dev);
+
+    if (ET_GMAC(et->etc) && (et->etc->qos))
+	q = etc_up2tc(PKTPRIO(skb));
+
+    ET_TRACE(("et%d: et_start: len %d\n", et->etc->unit, skb->len));
+    ET_LOG("et%d: et_start: len %d", et->etc->unit, skb->len);
+
+    ET_LOCK(et);
+
+    /* put it on the tx queue and call sendnext */
+    skb_queue_tail(&et->txq[q], skb);
+    et->etc->txq_state |= (1 << q);
+    et_sendnext(et);
+
+    ET_UNLOCK(et);
+
+    ET_LOG("et%d: et_start ret\n", et->etc->unit, 0);
+
+    return (0);
+}
+
+static void et_sendnext(et_info_t *et)
+{
+    etc_info_t *etc;
+    struct sk_buff *skb;
+    void *p;
+    uint32 priq = TX_Q0;
+
+    etc = et->etc;
+
+    ET_TRACE(("et%d: et_sendnext\n", etc->unit));
+    ET_LOG("et%d: et_sendnext", etc->unit, 0);
+
+    /* dequeue packets from highest priority queue and send */
+    priq = etc_priq(etc->txq_state);
+    ET_TRACE(("et%d: txq_state %x priq %d txavail %d\n",
+	      etc->unit, etc->txq_state, priq,
+	      *(uint *) etc->txavail[priq]));
+    while (etc->txq_state != 0) {
+	if (skb_peek(&et->txq[priq]) == NULL) {
+	    etc->txq_state &= ~(1 << priq);
+	    priq = etc_priq(etc->txq_state);
+	    continue;
+	}
+#ifdef DMA
+	/* current highest priority dma queue is full */
+	if (*(uint *) (etc->txavail[priq]) == 0)
+#else				/* DMA */
+	if (etc->pioactive != NULL)
+#endif				/* DMA */
+	    break;
+
+	skb = skb_dequeue(&et->txq[priq]);
+
+	ET_PRHDR("tx", (struct ether_header *) skb->data, skb->len,
+		 etc->unit);
+	ET_PRPKT("txpkt", skb->data, skb->len, etc->unit);
+
+	/* Convert the packet. */
+	if ((p = PKTFRMNATIVE(et->osh, skb)) == NULL) {
+	    dev_kfree_skb_any(skb);
+	    return;
+	}
+
+	(*etc->chops->tx) (etc->ch, p);
+
+	etc->txframe++;
+	etc->txbyte += skb->len;
+    }
+
+    /* no flow control when qos is enabled */
+    if (!et->etc->qos) {
+	/* stop the queue whenever txq fills */
+	if ((skb_queue_len(&et->txq[TX_Q0]) > DATAHIWAT)
+	    && !netif_queue_stopped(et->dev))
+	    netif_stop_queue(et->dev);
+	else if (netif_queue_stopped(et->dev) &&
+		 (skb_queue_len(&et->txq[TX_Q0]) < (DATAHIWAT / 2)))
+	    netif_wake_queue(et->dev);
+    }
+}
+
+void et_init(et_info_t *et, uint options)
+{
+    ET_TRACE(("et%d: et_init\n", et->etc->unit));
+    ET_LOG("et%d: et_init", et->etc->unit, 0);
+
+    et_reset(et);
+
+    etc_init(et->etc, options);
+}
+
+
+void et_reset(et_info_t *et)
+{
+    ET_TRACE(("et%d: et_reset\n", et->etc->unit));
+
+    etc_reset(et->etc);
+
+    /* zap any pending dpc interrupt bits */
+    et->events = 0;
+
+    /* dpc will not be rescheduled */
+    et->resched = 0;
+}
+
+void et_up(et_info_t *et)
+{
+    etc_info_t *etc;
+
+    etc = et->etc;
+
+    if (etc->up)
+	return;
+
+    ET_TRACE(("et%d: et_up\n", etc->unit));
+
+    etc_up(etc);
+
+    /* schedule one second watchdog timer */
+    et->timer.expires = jiffies + HZ;
+    add_timer(&et->timer);
+
+    netif_start_queue(et->dev);
+}
+
+void et_down(et_info_t *et, int reset)
+{
+    etc_info_t *etc;
+    struct sk_buff *skb;
+    int32 i;
+
+    etc = et->etc;
+
+    ET_TRACE(("et%d: et_down\n", etc->unit));
+
+    netif_down(et->dev);
+    netif_stop_queue(et->dev);
+
+    /* stop watchdog timer */
+    del_timer(&et->timer);
+
+    etc_down(etc, reset);
+
+    /* flush the txq(s) */
+    for (i = 0; i < NUMTXQ; i++)
+	while ((skb = skb_dequeue(&et->txq[i])))
+	    dev_kfree_skb_any(skb);
+
+#ifndef BCM_NAPI
+    /* kill dpc */
+    ET_UNLOCK(et);
+    tasklet_kill(&et->tasklet);
+    ET_LOCK(et);
+#endif				/* BCM_NAPI */
+}
+
+/*
+ * These are interrupt on/off entry points. Disable interrupts
+ * during interrupt state transition.
+ */
+void et_intrson(et_info_t *et)
+{
+    unsigned long flags;
+    INT_LOCK(flags);
+    (*et->etc->chops->intrson) (et->etc->ch);
+    INT_UNLOCK(flags);
+}
+
+static void et_watchdog(ulong data)
+{
+    et_info_t *et;
+
+    et = ET_INFO((struct net_device *) data);
+
+    ET_LOCK(et);
+
+    etc_watchdog(et->etc);
+
+    /* reschedule one second watchdog timer */
+    et->timer.expires = jiffies + HZ;
+    add_timer(&et->timer);
+
+    ET_UNLOCK(et);
+}
+
+#ifdef BCMINTERNAL
+/* programmable packet generator */
+static int et_txgen(et_info_t *et, struct txg *txg)
+{
+    struct sk_buff *skb;
+
+    if (txg->size > (ETHER_MAX_LEN - ETHER_CRC_LEN))
+	return (-EINVAL);
+
+    ET_LOCK(et);
+
+    while (txg->num-- > 0) {
+
+	/* spin when tx packets start backing up */
+	while (skb_queue_len(&et->txq[TX_Q0]) > (DATAHIWAT / 2)) {
+	    ET_UNLOCK(et);
+	    udelay(10);
+	    ET_LOCK(et);
+	}
+
+	/* alloc skb and copy frame into it */
+	if ((skb = dev_alloc_skb(txg->size)) == NULL) {
+	    ET_ERROR(("et%d: txgen: out of skb\n", et->etc->unit));
+	    (*et->etc->chops->txreclaim) (et->etc->ch, FALSE);
+	    continue;
+	}
+	skb_put(skb, txg->size);
+	bcopy(txg->buf, skb->data, txg->size);
+
+	/* put it on the tx queue and call sendnext */
+	skb_queue_tail(&et->txq[TX_Q0], skb);
+	et->etc->txq_state |= (1 << TX_Q0);
+	et_sendnext(et);
+
+	/* drop the lock, wait, reacquire the lock */
+	ET_UNLOCK(et);
+	udelay(txg->delay);
+	ET_LOCK(et);
+
+	(*et->etc->chops->txreclaim) (et->etc->ch, FALSE);
+    }
+
+    ET_UNLOCK(et);
+
+    return 0;
+}
+#endif				/* BCMINTERNAL */
+
+#ifdef SIOCETHTOOL
+static int et_ethtool(et_info_t *et, struct ethtool_cmd *ecmd)
+{
+    int ret = 0;
+    int speed;
+    struct ethtool_drvinfo *info;
+
+    ET_LOCK(et);
+
+    switch (ecmd->cmd) {
+    case ETHTOOL_GSET:
+	ecmd->supported =
+	    (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     SUPPORTED_Autoneg);
+	ecmd->advertising = ADVERTISED_TP;
+	ecmd->advertising |= (et->etc->advertise & ADV_10HALF) ?
+	    ADVERTISED_10baseT_Half : 0;
+	ecmd->advertising |= (et->etc->advertise & ADV_10FULL) ?
+	    ADVERTISED_10baseT_Full : 0;
+	ecmd->advertising |= (et->etc->advertise & ADV_100HALF) ?
+	    ADVERTISED_100baseT_Half : 0;
+	ecmd->advertising |= (et->etc->advertise & ADV_100FULL) ?
+	    ADVERTISED_100baseT_Full : 0;
+	if (et->etc->linkstate) {
+	    ecmd->speed = (et->etc->speed == 1000) ? SPEED_1000 :
+		((et->etc->speed == 100) ? SPEED_100 : SPEED_10);
+	    ecmd->duplex =
+		(et->etc->duplex == 1) ? DUPLEX_FULL : DUPLEX_HALF;
+	} else {
+	    ecmd->speed = 0;
+	    ecmd->duplex = 0;
+	}
+	ecmd->port = PORT_TP;
+	ecmd->phy_address = 0;
+	ecmd->transceiver = XCVR_INTERNAL;
+	ecmd->autoneg =
+	    (et->etc->forcespeed ==
+	     ET_AUTO) ? AUTONEG_ENABLE : AUTONEG_DISABLE;
+	ecmd->maxtxpkt = 0;
+	ecmd->maxrxpkt = 0;
+	break;
+    case ETHTOOL_SSET:
+	if (!capable(CAP_NET_ADMIN)) {
+	    ret = -EPERM;
+	    break;
+	} else if (ecmd->speed == SPEED_10 && ecmd->duplex == DUPLEX_HALF)
+	    speed = ET_10HALF;
+	else if (ecmd->speed == SPEED_10 && ecmd->duplex == DUPLEX_FULL)
+	    speed = ET_10FULL;
+	else if (ecmd->speed == SPEED_100 && ecmd->duplex == DUPLEX_HALF)
+	    speed = ET_100HALF;
+	else if (ecmd->speed == SPEED_100 && ecmd->duplex == DUPLEX_FULL)
+	    speed = ET_100FULL;
+	else if (ET_GMAC(et->etc) &&
+		 (ecmd->speed == SPEED_1000
+		  && ecmd->duplex == DUPLEX_FULL))
+	    speed = ET_1000FULL;
+	else if (ecmd->autoneg == AUTONEG_ENABLE)
+	    speed = ET_AUTO;
+	else {
+	    ret = -EINVAL;
+	    break;
+	}
+	ret = etc_ioctl(et->etc, ETCSPEED, &speed);
+	break;
+    case ETHTOOL_GDRVINFO:
+	info = (struct ethtool_drvinfo *) ecmd;
+	bzero(info, sizeof(struct ethtool_drvinfo));
+	info->cmd = ETHTOOL_GDRVINFO;
+	sprintf(info->driver, "et%d", et->etc->unit);
+	strcpy(info->version, EPI_VERSION_STR);
+	break;
+    default:
+	ret = -EINVAL;
+	break;
+    }
+
+    ET_UNLOCK(et);
+
+    return ret;
+}
+#endif				/* SIOCETHTOOL */
+
+static int et_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+    et_info_t *et;
+    int error;
+    char *buf;
+    int size, ethtoolcmd;
+    bool get, set;
+
+    et = ET_INFO(dev);
+
+    ET_TRACE(("et%d: et_ioctl: cmd 0x%x\n", et->etc->unit, cmd));
+
+    switch (cmd) {
+#ifdef SIOCETHTOOL
+    case SIOCETHTOOL:
+	if (copy_from_user(&ethtoolcmd, ifr->ifr_data, sizeof(uint32)))
+	    return -EFAULT;
+
+	if (ethtoolcmd == ETHTOOL_GDRVINFO)
+	    size = sizeof(struct ethtool_drvinfo);
+	else
+	    size = sizeof(struct ethtool_cmd);
+	get = TRUE;
+	set = TRUE;
+	break;
+#endif				/* SIOCETHTOOL */
+#ifdef BCMINTERNAL
+    case SIOCTXGEN:
+	size = sizeof(struct txg);
+	get = FALSE;
+	set = TRUE;
+	break;
+#endif				/* BCMINTERNAL */
+    case SIOCGETCDUMP:
+	size = 4096;
+	get = TRUE;
+	set = FALSE;
+	break;
+    case SIOCGETCPHYRD:
+    case SIOCGETCPHYRD2:
+    case SIOCGETCROBORD:
+	size = sizeof(int) * 2;
+	get = TRUE;
+	set = TRUE;
+	break;
+    case SIOCSETCPHYWR:
+    case SIOCSETCPHYWR2:
+    case SIOCSETCROBOWR:
+	size = sizeof(int) * 2;
+	get = FALSE;
+	set = TRUE;
+	break;
+    default:
+	size = sizeof(int);
+	get = FALSE;
+	set = TRUE;
+	break;
+    }
+
+    if ((buf = MALLOC(et->osh, size)) == NULL) {
+	ET_ERROR(("et: et_ioctl: out of memory, malloced %d bytes\n",
+		  MALLOCED(et->osh)));
+	return (-ENOMEM);
+    }
+
+    if (set && copy_from_user(buf, ifr->ifr_data, size)) {
+	MFREE(et->osh, buf, size);
+	return (-EFAULT);
+    }
+
+    switch (cmd) {
+#ifdef SIOCETHTOOL
+    case SIOCETHTOOL:
+	error = et_ethtool(et, (struct ethtool_cmd *) buf);
+	break;
+#endif				/* SIOCETHTOOL */
+#ifdef BCMINTERNAL
+    case SIOCTXGEN:
+	error = et_txgen(et, (struct txg *) buf);
+	break;
+#endif				/* BCMINTERNAL */
+    default:
+	ET_LOCK(et);
+	error = etc_ioctl(et->etc, cmd - SIOCSETCUP, buf) ? -EINVAL : 0;
+	ET_UNLOCK(et);
+	break;
+    }
+
+    if (!error && get)
+	error = copy_to_user(ifr->ifr_data, buf, size);
+
+    MFREE(et->osh, buf, size);
+
+    return error;
+}
+
+static struct net_device_stats *et_get_stats(struct net_device *dev)
+{
+    et_info_t *et;
+    etc_info_t *etc;
+    struct net_device_stats *stats;
+
+    et = ET_INFO(dev);
+
+    ET_TRACE(("et%d: et_get_stats\n", et->etc->unit));
+
+    ET_LOCK(et);
+
+    etc = et->etc;
+    stats = &et->stats;
+    bzero(stats, sizeof(struct net_device_stats));
+
+    /* refresh stats */
+    if (et->etc->up)
+	(*etc->chops->statsupd) (etc->ch);
+
+    /* SWAG */
+    stats->rx_packets = etc->rxframe;
+    stats->tx_packets = etc->txframe;
+    stats->rx_bytes = etc->rxbyte;
+    stats->tx_bytes = etc->txbyte;
+    stats->rx_errors = etc->rxerror;
+    stats->tx_errors = etc->txerror;
+
+    if (ET_GMAC(etc)) {
+	gmacmib_t *mib;
+
+	mib = etc->mib;
+	stats->collisions = mib->tx_total_cols;
+	stats->rx_length_errors =
+	    (mib->rx_oversize_pkts + mib->rx_undersize);
+	stats->rx_crc_errors = mib->rx_crc_errs;
+	stats->rx_frame_errors = mib->rx_align_errs;
+	stats->rx_missed_errors = mib->rx_missed_pkts;
+    } else {
+	bcmenetmib_t *mib;
+
+	mib = etc->mib;
+	stats->collisions = mib->tx_total_cols;
+	stats->rx_length_errors =
+	    (mib->rx_oversize_pkts + mib->rx_undersize);
+	stats->rx_crc_errors = mib->rx_crc_errs;
+	stats->rx_frame_errors = mib->rx_align_errs;
+	stats->rx_missed_errors = mib->rx_missed_pkts;
+
+    }
+
+    stats->rx_fifo_errors = etc->rxoflo;
+    stats->rx_over_errors = etc->rxoflo;
+    stats->tx_fifo_errors = etc->txuflo;
+
+    ET_UNLOCK(et);
+
+    return stats;
+}
+
+static int et_set_mac_address(struct net_device *dev, void *addr)
+{
+    et_info_t *et;
+    struct sockaddr *sa = (struct sockaddr *) addr;
+
+    et = ET_INFO(dev);
+    ET_TRACE(("et%d: et_set_mac_address\n", et->etc->unit));
+
+    if (et->etc->up)
+	return -EBUSY;
+
+    bcopy(sa->sa_data, dev->dev_addr, ETHER_ADDR_LEN);
+    bcopy(dev->dev_addr, &et->etc->cur_etheraddr, ETHER_ADDR_LEN);
+
+    return 0;
+}
+
+static void et_set_multicast_list(struct net_device *dev)
+{
+    et_info_t *et;
+    etc_info_t *etc;
+    struct dev_mc_list *mclist;
+    int i;
+
+    et = ET_INFO(dev);
+    etc = et->etc;
+
+    ET_TRACE(("et%d: et_set_multicast_list\n", etc->unit));
+
+    ET_LOCK(et);
+
+    if (etc->up) {
+	etc->promisc = (dev->flags & IFF_PROMISC) ? TRUE : FALSE;
+	etc->allmulti = (dev->flags & IFF_ALLMULTI) ? TRUE : FALSE;
+
+	/* copy the list of multicasts into our private table */
+	for (i = 0, mclist = dev->mc_list; mclist && (i < dev->mc_count);
+	     i++, mclist = mclist->next) {
+	    if (i >= MAXMULTILIST) {
+		etc->allmulti = TRUE;
+		i = 0;
+		break;
+	    }
+	    etc->multicast[i] = *((struct ether_addr *) mclist->dmi_addr);
+	}
+	etc->nmulticast = i;
+
+	et_init(et, ET_INIT_DEF_OPTIONS);
+    }
+
+    ET_UNLOCK(et);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+static irqreturn_t et_isr(int irq, void *dev_id)
+#else
+static irqreturn_t et_isr(int irq, void *dev_id, struct pt_regs *ptregs)
+#endif
+{
+    et_info_t *et;
+    struct chops *chops;
+    void *ch;
+    uint events = 0;
+
+    et = (et_info_t *) dev_id;
+    chops = et->etc->chops;
+    ch = et->etc->ch;
+
+    /* guard against shared interrupts */
+    if (!et->etc->up)
+	goto done;
+
+    /* get interrupt condition bits */
+    events = (*chops->getintrevents) (ch, TRUE);
+
+
+    /* not for us */
+    if (!(events & INTR_NEW))
+	goto done;
+
+    ET_TRACE(("et%d: et_isr: events 0x%x\n", et->etc->unit, events));
+    ET_LOG("et%d: et_isr: events 0x%x", et->etc->unit, events);
+
+    /* disable interrupts */
+    (*chops->intrsoff) (ch);
+
+    /* save intstatus bits */
+    ASSERT(et->events == 0);
+    et->events = events;
+
+    ASSERT(et->resched == FALSE);
+#ifdef BCM_NAPI
+    /* allow the device to be added to the cpu polling list if we are up */
+    if (netif_rx_schedule_prep(et->dev)) {
+	/* tell the network core that we have packets to send up */
+	__netif_rx_schedule(et->dev);
+    } else {
+	ET_ERROR(("et%d: et_isr: intr while in poll!\n", et->etc->unit));
+	(*chops->intrson) (ch);
+    }
+#else				/* BCM_NAPI */
+    /* schedule dpc */
+    tasklet_schedule(&et->tasklet);
+#endif				/* BCM_NAPI */
+
+  done:
+    ET_LOG("et%d: et_isr ret", et->etc->unit, 0);
+
+    return IRQ_RETVAL(events & INTR_NEW);
+}
+
+#ifdef BCM_NAPI
+static int et_poll(struct net_device *dev, int *budget)
+{
+    int quota = min(dev->quota, *budget);
+    et_info_t *et = ET_INFO(dev);
+#else				/* BCM_NAPI */
+static void et_dpc(ulong data)
+{
+    int quota = RXBND;
+    et_info_t *et = (et_info_t *) data;
+#endif				/* BCM_NAPI */
+    struct chops *chops;
+    void *ch;
+    struct sk_buff *skb;
+    void *p = NULL;
+    osl_t *osh;
+
+    chops = et->etc->chops;
+    ch = et->etc->ch;
+    osh = et->etc->osh;
+
+    ET_TRACE(("et%d: et_dpc: events 0x%x\n", et->etc->unit, et->events));
+    ET_LOG("et%d: et_dpc: events 0x%x", et->etc->unit, et->events);
+
+#ifndef BCM_NAPI
+    ET_LOCK(et);
+#endif				/* BCM_NAPI */
+
+    if (!et->etc->up)
+	goto done;
+
+    /* get interrupt condition bits again when dpc was rescheduled */
+    if (et->resched) {
+	et->events = (*chops->getintrevents) (ch, FALSE);
+	et->resched = FALSE;
+    }
+
+    if (et->events & INTR_RX) {
+	uint processed = 0;
+	while ((p = (*chops->rx) (ch))) {
+	    skb = PKTTONATIVE(osh, p);
+	    et_sendup(et, skb);
+	    /* we reached quota already */
+	    if (++processed >= quota) {
+		/* reschedule et_dpc()/et_poll() */
+		et->resched = TRUE;
+		break;
+	    }
+	}
+
+	/* post more rx bufs */
+	(*chops->rxfill) (ch);
+
+#ifdef BCM_NAPI
+	/* update number of frames processed */
+	*budget -= processed;
+	dev->quota -= processed;
+#endif				/* BCM_NAPI */
+    }
+
+    if (et->events & INTR_TX)
+	(*chops->txreclaim) (ch, FALSE);
+
+    /* handle error conditions, if reset required leave interrupts off! */
+    if (et->events & INTR_ERROR)
+	if ((*chops->errors)(ch))
+	    et_init(et, ET_INIT_INTROFF);
+
+    /* run the tx queue */
+    if (et->etc->txq_state != 0)
+	et_sendnext(et);
+
+    /* clear this before re-enabling interrupts */
+    et->events = 0;
+
+    /* something may bring the driver down */
+    if (!et->etc->up) {
+	et->resched = FALSE;
+	goto done;
+    }
+#ifndef BCM_NAPI
+    /* there may be frames left, reschedule et_dpc() */
+    if (et->resched)
+	tasklet_schedule(&et->tasklet);
+    /* re-enable interrupts */
+    else
+	(*chops->intrson) (ch);
+#endif				/* BCM_NAPI */
+
+  done:
+    ET_LOG("et%d: et_dpc ret", et->etc->unit, 0);
+
+#ifdef BCM_NAPI
+    ET_TRACE(("et%d: et_poll: quota %d budget %d\n",
+	      et->etc->unit, dev->quota, *budget));
+
+    /* we got packets but no quota */
+    if (et->resched)
+	/* indicate that we are not done, don't enable
+	 * interrupts yet. linux network core will call
+	 * us again.
+	 */
+	return (1);
+
+    /* enable interrupts now */
+    (*chops->intrson) (ch);
+
+    netif_rx_complete(dev);
+
+    /* indicate that we are done */
+    return (0);
+#else				/* BCM_NAPI */
+    ET_UNLOCK(et);
+    return;
+#endif				/* BCM_NAPI */
+}
+
+void et_sendup(et_info_t *et, struct sk_buff *skb)
+{
+    etc_info_t *etc;
+    void *rxh;
+    uint16 flags;
+    uchar eabuf[32];
+
+    etc = et->etc;
+
+    /* packet buffer starts with rxhdr */
+    rxh = skb->data;
+
+    /* strip off rxhdr */
+    skb_pull(skb, HWRXOFF);
+
+    ET_TRACE(("et%d: et_sendup: %d bytes\n", et->etc->unit, skb->len));
+    ET_LOG("et%d: et_sendup: len %d", et->etc->unit, skb->len);
+
+    etc->rxframe++;
+    etc->rxbyte += skb->len;
+
+    /* eh should now be aligned 2-mod-4 */
+    ASSERT(((ulong) skb->data & 3) == 2);
+
+    /* strip off crc32 */
+    skb_trim(skb, skb->len - ETHER_CRC_LEN);
+
+    ET_PRHDR("rx", (struct ether_header *) skb->data, skb->len, etc->unit);
+    ET_PRPKT("rxpkt", skb->data, skb->len, etc->unit);
+
+    /* get the error flags */
+    flags = RXH_FLAGS(etc, rxh);
+
+    /* check for reported frame errors */
+    if (flags)
+	goto err;
+
+    /* Extract priority from payload and store it out-of-band in skb->priority */
+    if (et->etc->qos)
+	pktsetprio(skb, TRUE);
+
+    skb->dev = et->dev;
+    skb->protocol = eth_type_trans(skb, et->dev);
+
+    /* send it up */
+#ifdef BCM_NAPI
+    netif_receive_skb(skb);
+#else				/* BCM_NAPI */
+    netif_rx(skb);
+#endif				/* BCM_NAPI */
+
+    ET_LOG("et%d: et_sendup ret", et->etc->unit, 0);
+
+    return;
+
+  err:
+    bcm_ether_ntoa((struct ether_addr *) ((struct ether_header *) skb->
+					  data)->ether_shost, eabuf);
+    if (RXH_OVERSIZE(etc, rxh)) {
+	ET_ERROR(("et%d: rx: over size packet from %s\n", etc->unit,
+		  eabuf));
+    }
+    if (RXH_CRC(etc, rxh)) {
+	ET_ERROR(("et%d: rx: crc error from %s\n", etc->unit, eabuf));
+    }
+    if (RXH_OVF(etc, rxh)) {
+	ET_ERROR(("et%d: rx: fifo overflow\n", etc->unit));
+    }
+    if (RXH_NO(etc, rxh)) {
+	ET_ERROR(("et%d: rx: crc error (odd nibbles) from %s\n",
+		  etc->unit, eabuf));
+    }
+    if (RXH_RXER(etc, rxh)) {
+	ET_ERROR(("et%d: rx: symbol error from %s\n", etc->unit, eabuf));
+    }
+
+    dev_kfree_skb_any(skb);
+
+    return;
+}
+
+void et_dump(et_info_t *et, struct bcmstrbuf *b)
+{
+    bcm_bprintf(b, "et%d: %s %s version %s\n", et->etc->unit,
+		__DATE__, __TIME__, EPI_VERSION_STR);
+
+#ifdef BCMDBG
+    et_dumpet(et, b);
+    etc_dump(et->etc, b);
+#endif				/* BCMDBG */
+}
+
+#ifdef BCMDBG
+static void et_dumpet(et_info_t *et, struct bcmstrbuf *b)
+{
+    bcm_bprintf(b,
+		"et %p dev %p name %s tbusy %d txq[0].qlen %d malloced %d\n",
+		et, et->dev, et->dev->name,
+		(uint) netif_queue_stopped(et->dev), et->txq[0].qlen,
+		MALLOCED(et->osh));
+}
+#endif				/* BCMDBG */
+
+void et_link_up(et_info_t *et)
+{
+    ET_ERROR(("et%d: link up (%d%s)\n",
+	      et->etc->unit, et->etc->speed,
+	      (et->etc->duplex ? "FD" : "HD")));
+}
+
+void et_link_down(et_info_t *et)
+{
+    ET_ERROR(("et%d: link down\n", et->etc->unit));
+}
+
+#ifdef BCM47XX_CHOPS
+/*
+ * 47XX-specific shared mdc/mdio contortion:
+ * Find the et associated with the same chip as <et>
+ * and coreunit matching <coreunit>.
+ */
+void *et_phyfind(et_info_t *et, uint coreunit)
+{
+    et_info_t *tmp;
+    uint bus, slot;
+
+    bus = et->pdev->bus->number;
+    slot = PCI_SLOT(et->pdev->devfn);
+
+    /* walk the list et's */
+    for (tmp = et_list; tmp; tmp = tmp->next) {
+	if (et->etc == NULL)
+	    continue;
+	if (tmp->pdev == NULL)
+	    continue;
+	if (tmp->pdev->bus->number != bus)
+	    continue;
+	if (tmp->etc->nicmode)
+	    if (PCI_SLOT(tmp->pdev->devfn) != slot)
+		continue;
+	if (tmp->etc->coreunit != coreunit)
+	    continue;
+	break;
+    }
+    return (tmp);
+}
+
+/* shared phy read entry point */
+uint16 et_phyrd(et_info_t *et, uint phyaddr, uint reg)
+{
+    uint16 val;
+
+    ET_LOCK(et);
+    val = et->etc->chops->phyrd(et->etc->ch, phyaddr, reg);
+    ET_UNLOCK(et);
+
+    return (val);
+}
+
+/* shared phy write entry point */
+void et_phywr(et_info_t *et, uint phyaddr, uint reg, uint16 val)
+{
+    ET_LOCK(et);
+    et->etc->chops->phywr(et->etc->ch, phyaddr, reg, val);
+    ET_UNLOCK(et);
+}
+#endif				/* BCM47XX_CHOPS */
diff --git a/drivers/net/gmac/et_linux.h b/drivers/net/gmac/et_linux.h
new file mode 100644
index 0000000..d161b50
--- /dev/null
+++ b/drivers/net/gmac/et_linux.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Linux device driver tunables for
+ * Broadcom BCM53000 10/100Mbps Ethernet Device Driver
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#ifndef _et_linux_h_
+#define _et_linux_h_
+
+/* tunables */
+#define	NTXD		64	/* # tx dma ring descriptors (must be ^2) */
+#define	NRXD		512	/* # rx dma ring descriptors (must be ^2) */
+#define	NRXBUFPOST	48	/* try to keep this # rbufs posted to the chip */
+#define	BUFSZ		2048	/* packet data buffer size */
+#define	RXBUFSZ		(BUFSZ - 256)	/* receive buffer size */
+
+#ifndef RXBND
+#define RXBND		8	/* max # rx frames to process in dpc */
+#endif
+
+#if defined(ILSIM) || defined(__arch_um__)
+#undef	NTXD
+#define	NTXD		16
+#undef	NRXD
+#define	NRXD		16
+#undef	NRXBUFPOST
+#define	NRXBUFPOST	2
+#endif
+
+#endif				/* _et_linux_h_ */
diff --git a/drivers/net/gmac/etc.c b/drivers/net/gmac/etc.c
new file mode 100644
index 0000000..850b697
--- /dev/null
+++ b/drivers/net/gmac/etc.c
@@ -0,0 +1,880 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Common [OS-independent] portion of
+ * Broadcom Home Networking Division 10/100 Mbit/s Ethernet
+ * Device Driver.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmendian.h>
+#include <ethernet.h>
+#include <802.1d.h>
+#include <bcmenetrxh.h>
+#include <bcmenetphy.h>
+#include <et_dbg.h>
+#include <etc.h>
+#include <et_export.h>
+#include <bcmutils.h>
+
+uint32 et_msg_level =
+#ifdef BCMDBG
+    1;
+#else
+    0;
+#endif				/* BCMDBG */
+
+#ifdef CFG_QUICKTURN
+#define QT_TEST			/* define for the MDIO test on quickturn */
+#endif
+
+/* local prototypes */
+static void etc_loopback(etc_info_t *etc, int on);
+#ifdef BCMDBG
+static void etc_dumpetc(etc_info_t *etc, struct bcmstrbuf *b);
+#endif				/* BCMDBG */
+
+
+/* 802.1d priority to traffic class mapping. queues correspond one-to-one
+ * with traffic classes.
+ */
+uint32 up2tc[NUMPRIO] = {
+    TC_BE,			/* 0    BE    TC_BE    Best Effort */
+    TC_BK,			/* 1    BK    TC_BK    Background */
+    TC_BK,			/* 2    --    TC_BK    Background */
+    TC_BE,			/* 3    EE    TC_BE    Best Effort */
+    TC_CL,			/* 4    CL    TC_CL    Controlled Load */
+    TC_CL,			/* 5    VI    TC_CL    Controlled Load */
+    TC_VO,			/* 6    VO    TC_VO    Voice */
+    TC_VO			/* 7    NC    TC_VO    Voice */
+};
+
+uint32 priq_selector[] = {
+    [0x0] = TC_NONE, [0x1] = TC_BK, [0x2] = TC_BE, [0x3] = TC_BE,
+    [0x4] = TC_CL, [0x5] = TC_CL, [0x6] = TC_CL, [0x7] = TC_CL,
+    [0x8] = TC_VO, [0x9] = TC_VO, [0xa] = TC_VO, [0xb] = TC_VO,
+    [0xc] = TC_VO, [0xd] = TC_VO, [0xe] = TC_VO, [0xf] = TC_VO
+};
+
+/* find the chip opsvec for this chip */
+struct chops *etc_chipmatch(uint vendor, uint device)
+{
+    {
+	extern struct chops bcmgmac_et_chops;
+
+	if (bcmgmac_et_chops.id(vendor, device))
+	    return (&bcmgmac_et_chops);
+    }
+    return NULL;
+}
+
+void *etc_attach(void *et, uint vendor, uint device, uint unit, void *osh,
+		 void *regsva)
+{
+    etc_info_t *etc;
+    int i;
+
+    ET_TRACE(("et%d: etc_attach: vendor 0x%x device 0x%x\n", unit, vendor,
+	      device));
+
+    /* some code depends on packed structures */
+    ASSERT(sizeof(struct ether_addr) == ETHER_ADDR_LEN);
+    ASSERT(sizeof(struct ether_header) == ETHER_HDR_LEN);
+
+    /* allocate etc_info_t state structure */
+    if ((etc = (etc_info_t *) MALLOC(osh, sizeof(etc_info_t))) == NULL) {
+	ET_ERROR(("et%d: etc_attach: out of memory, malloced %d bytes\n",
+		  unit, MALLOCED(osh)));
+	return NULL;
+    }
+    bzero((char *) etc, sizeof(etc_info_t));
+
+    etc->et = et;
+    etc->unit = unit;
+    etc->osh = osh;
+    etc->vendorid = (uint16) vendor;
+    etc->deviceid = (uint16) device;
+    etc->forcespeed = ET_AUTO;
+    etc->linkstate = FALSE;
+    /* Set Promisc mode as deafult for testing */
+    etc->promisc = 1;
+    etc->pkt_mem = MEMORY_DDRRAM;
+    /* separate header buffer memory type */
+    etc->pkthdr_mem = MEMORY_DDRRAM;
+    /* flow control */
+    etc->flowcntl_mode = FLOW_CTRL_MODE_DISABLE;	/* default mode */
+    etc->flowcntl_auto_on_thresh = FLWO_CTRL_AUTO_MODE_DEFAULT_ON_THRESH;
+    etc->flowcntl_auto_off_thresh = FLWO_CTRL_AUTO_MODE_DEFAULT_OFF_THRESH;
+    etc->flowcntl_cpu_pause_on = 0;
+    for (i = 0; i < NUMRXQ; i++) {
+	etc->flowcntl_rx_on_thresh[i] = 0;
+	etc->flowcntl_rx_off_thresh[i] = 0;
+	etc->en_rxsephdr[i] = 0;
+    }
+
+    /* tx qos */
+    etc->txqos_mode = TXQOS_MODE_1STRICT_3WRR;
+    for (i = 0; i < NUMTXQ; i++) {
+	etc->txqos_weight[i] = TXQOS_DEFAULT_WEIGHT;
+    }
+
+    /* tpid */
+    for (i = 0; i < NUM_STAG_TPID; i++) {
+	etc->tpid[i] = STAG_TPID_DEFAULT;
+    }
+
+    /* set chip opsvec */
+    etc->chops = etc_chipmatch(vendor, device);
+    ASSERT(etc->chops);
+
+    /* chip attach */
+    if ((etc->ch = (*etc->chops->attach) (etc, osh, regsva)) == NULL) {
+	ET_ERROR(("et%d: chipattach error\n", unit));
+	goto fail;
+    }
+
+    return ((void *) etc);
+
+  fail:
+    etc_detach(etc);
+    return NULL;
+}
+
+void etc_detach(etc_info_t *etc)
+{
+    if (etc == NULL)
+	return;
+
+    /* free chip private state */
+    if (etc->ch) {
+	(*etc->chops->detach) (etc->ch);
+	etc->chops = etc->ch = NULL;
+    }
+
+    MFREE(etc->osh, etc, sizeof(etc_info_t));
+}
+
+void etc_reset(etc_info_t *etc)
+{
+    ET_TRACE(("et%d: etc_reset\n", etc->unit));
+
+    etc->reset++;
+
+    /* reset the chip */
+    (*etc->chops->reset) (etc->ch);
+
+    /* free any posted tx packets */
+    (*etc->chops->txreclaim) (etc->ch, TRUE);
+
+    /* free any posted rx packets */
+    (*etc->chops->rxreclaim) (etc->ch);
+
+}
+
+void etc_init(etc_info_t *etc, uint options)
+{
+    ET_TRACE(("et%d: etc_init\n", etc->unit));
+
+    ASSERT(etc->pioactive == NULL);
+    ASSERT(!ETHER_ISNULLADDR(&etc->cur_etheraddr));
+    ASSERT(!ETHER_ISMULTI(&etc->cur_etheraddr));
+
+    /* init the chip */
+    (*etc->chops->init) (etc->ch, options);
+}
+
+/* mark interface up */
+void etc_up(etc_info_t *etc)
+{
+    etc->up = TRUE;
+
+    et_init(etc->et, ET_INIT_DEF_OPTIONS);
+}
+
+/* mark interface down */
+uint etc_down(etc_info_t *etc, int reset)
+{
+    uint callback;
+
+    callback = 0;
+
+    ET_FLAG_DOWN(etc);
+
+    if (reset)
+	et_reset(etc->et);
+
+    /* suppress link state changes during power management mode changes */
+    if (etc->linkstate) {
+	etc->linkstate = FALSE;
+	if (!etc->pm_modechange)
+	    et_link_down(etc->et);
+    }
+
+    return callback;
+}
+
+#ifdef QT_TEST
+#define QT_MDIO_PHYADDR 0x1
+#endif				/* QT_TEST */
+
+/* common ioctl handler.  return: 0=ok, -1=error */
+int etc_ioctl(etc_info_t *etc, int cmd, void *arg)
+{
+    int error;
+    int val;
+    int *vec = (int *) arg;
+
+    error = 0;
+
+    val = arg ? *(int *) arg : 0;
+
+    ET_TRACE(("et%d: etc_ioctl: cmd 0x%x\n", etc->unit, cmd));
+
+    switch (cmd) {
+    case ETCUP:
+	et_up(etc->et);
+	break;
+
+    case ETCDOWN:
+	et_down(etc->et, TRUE);
+	break;
+
+    case ETCLOOP:
+	etc_loopback(etc, val);
+	break;
+
+    case ETCDUMP:
+	if (et_msg_level & 0x10000)
+	    bcmdumplog((char *) arg, 4096);
+#ifdef BCMDBG
+	else {
+	    struct bcmstrbuf b;
+	    bcm_binit(&b, (char *) arg, 4096);
+	    et_dump(etc->et, &b);
+	}
+#endif				/* BCMDBG */
+	break;
+
+    case ETCSETMSGLEVEL:
+	et_msg_level = val;
+	break;
+
+    case ETCPROMISC:
+	etc_promisc(etc, val);
+	break;
+
+    case ETCQOS:
+	etc_qos(etc, val);
+	break;
+
+    case ETCSPEED:
+	if ((val != ET_AUTO) && (val != ET_10HALF) && (val != ET_10FULL) &&
+	    (val != ET_100HALF) && (val != ET_100FULL)
+	    && (val != ET_1000FULL))
+	    goto err;
+	etc->forcespeed = val;
+
+	/* explicitly reset the phy */
+	(*etc->chops->phyreset) (etc->ch, etc->phyaddr);
+
+	/* request restart autonegotiation if we're reverting to adv mode */
+	if ((etc->forcespeed == ET_AUTO) & etc->advertise)
+	    etc->needautoneg = TRUE;
+
+	et_init(etc->et, ET_INIT_DEF_OPTIONS);
+	break;
+
+    case ETCPHYRD:
+	if (vec) {
+
+#ifdef QT_TEST
+	    vec[1] =
+		(*etc->chops->phyrd) (etc->ch, QT_MDIO_PHYADDR, vec[0]);
+#else				/* QT_TEST */
+	    vec[1] = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, vec[0]);
+#endif				/* QT_TEST */
+	    ET_TRACE(("etc_ioctl: ETCPHYRD of reg 0x%x => 0x%x\n", vec[0],
+		      vec[1]));
+	}
+	break;
+
+    case ETCPHYRD2:
+	if (vec) {
+	    uint phyaddr, reg;
+	    phyaddr = vec[0] >> 16;
+	    if (phyaddr < MAXEPHY) {
+		reg = vec[0] & 0xffff;
+		vec[1] = (*etc->chops->phyrd) (etc->ch, phyaddr, reg);
+		ET_TRACE(("etc_ioctl: ETCPHYRD2 of phy 0x%x, reg 0x%x => 0x%x\n", phyaddr, reg, vec[1]));
+	    }
+	}
+	break;
+
+    case ETCPHYWR:
+	if (vec) {
+	    ET_TRACE(("etc_ioctl: ETCPHYWR to reg 0x%x <= 0x%x\n", vec[0],
+		      vec[1]));
+#ifdef QT_TEST
+	    (*etc->chops->phywr) (etc->ch, QT_MDIO_PHYADDR, vec[0],
+				  (uint16) vec[1]);
+#else				/* QT_TEST */
+	    (*etc->chops->phywr) (etc->ch, etc->phyaddr, vec[0],
+				  (uint16) vec[1]);
+#endif				/* QT_TEST */
+	}
+	break;
+
+    case ETCPHYWR2:
+	if (vec) {
+	    uint phyaddr, reg;
+	    phyaddr = vec[0] >> 16;
+	    if (phyaddr < MAXEPHY) {
+		reg = vec[0] & 0xffff;
+		(*etc->chops->phywr) (etc->ch, phyaddr, reg,
+				      (uint16) vec[1]);
+		ET_TRACE(("etc_ioctl: ETCPHYWR2 to phy 0x%x, reg 0x%x <= 0x%x\n", phyaddr, reg, vec[1]));
+	    }
+	}
+	break;
+    case ETCCFPRD:
+	(*etc->chops->cfprd) (etc->ch, arg);
+	break;
+    case ETCCFPWR:
+	(*etc->chops->cfpwr) (etc->ch, arg);
+	break;
+    case ETCCFPFIELDRD:
+	(*etc->chops->cfpfldrd) (etc->ch, arg);
+	break;
+    case ETCCFPFIELDWR:
+	(*etc->chops->cfpfldwr) (etc->ch, arg);
+	break;
+    case ETCCFPUDFRD:
+	(*etc->chops->cfpudfrd) (etc->ch, arg);
+	break;
+    case ETCCFPUDFWR:
+	(*etc->chops->cfpudfwr) (etc->ch, arg);
+	break;
+    case ETCPKTMEMSET:
+	if ((val != MEMORY_DDRRAM) && (val != MEMORY_SOCRAM)
+	    && (val != MEMORY_PCIMEM))
+	    goto err;
+	etc->pkt_mem = val;
+
+	et_init(etc->et, ET_INIT_DEF_OPTIONS);
+	break;
+    case ETCPKTHDRMEMSET:
+	if ((val != MEMORY_DDRRAM) && (val != MEMORY_SOCRAM)
+	    && (val != MEMORY_PCIMEM))
+	    goto err;
+	etc->pkthdr_mem = val;
+
+	et_init(etc->et, ET_INIT_DEF_OPTIONS);
+	break;
+    case ETCRXRATE:
+	if (vec) {
+	    uint chan, pps;
+	    chan = vec[0];
+	    pps = vec[1];
+	    error = (*etc->chops->rxrateset) (etc->ch, chan, pps);
+	    if (!error) {
+		etc->rx_pps[chan] = pps;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCTXRATE:
+	if (vec) {
+	    uint chan, rate, burst;
+	    chan = vec[0];
+	    rate = vec[1];
+	    burst = vec[2];
+	    error = (*etc->chops->txrateset) (etc->ch, chan, rate, burst);
+	    if (!error) {
+		etc->tx_rate[chan] = rate;
+		etc->tx_burst[chan] = burst;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCFLOWCTRLMODE:
+	if (vec) {
+	    uint mode;
+
+	    mode = vec[0];
+	    error = (*etc->chops->flowctrlmodeset) (etc->ch, mode);
+	    if (!error) {
+		etc->flowcntl_mode = mode;
+		et_init(etc->et, ET_INIT_DEF_OPTIONS);
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCFLOWCTRLCPUSET:
+	if (vec) {
+	    uint pause_on;
+
+	    pause_on = vec[0];
+	    error = (*etc->chops->flowctrlcpuset) (etc->ch, pause_on);
+	    if (!error) {
+		etc->flowcntl_cpu_pause_on = pause_on;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCFLOWCTRLAUTOSET:
+	if (vec) {
+	    uint on_th, off_th;
+
+	    on_th = vec[0];
+	    off_th = vec[1];
+	    error =
+		(*etc->chops->flowctrlautoset) (etc->ch, on_th, off_th);
+	    if (!error) {
+		etc->flowcntl_auto_on_thresh = on_th;
+		etc->flowcntl_auto_off_thresh = off_th;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCFLOWCTRLRXCHANSET:
+	if (vec) {
+	    uint rxchan, on_th, off_th;
+
+	    rxchan = vec[0];
+	    if (rxchan >= NUMRXQ) {
+		goto err;
+	    }
+	    on_th = vec[1];
+	    off_th = vec[2];
+	    error =
+		(*etc->chops->flowctrlrxchanset) (etc->ch, rxchan, on_th,
+						  off_th);
+	    if (!error) {
+		etc->flowcntl_rx_on_thresh[rxchan] = on_th;
+		etc->flowcntl_rx_off_thresh[rxchan] = off_th;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCTPID:
+	if (vec) {
+	    uint id, tpid;
+	    id = vec[0];
+	    tpid = vec[1];
+	    error = (*etc->chops->tpidset) (etc->ch, id, tpid);
+	    if (!error) {
+		etc->tpid[id] = tpid;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCPVTAG:
+	if (vec) {
+	    uint ptag;
+	    ptag = vec[0];
+	    error = (*etc->chops->pvtagset) (etc->ch, ptag);
+	    if (!error) {
+		etc->ptag = ptag;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+
+	/* RX separate header */
+    case ETCRXSEPHDR:
+	if (vec) {
+	    uint enable;
+	    uint i;
+	    enable = vec[0];
+	    error = (*etc->chops->rxsephdrset) (etc->ch, enable);
+	    if (!error) {
+		for (i = 0; i < NUMRXQ; i++) {
+		    etc->en_rxsephdr[i] = enable;
+		}
+	    }
+	} else {
+	    goto err;
+	}
+	et_init(etc->et, ET_INIT_DEF_OPTIONS);
+	break;
+    case ETCTXQOSMODE:
+	if (vec) {
+	    uint mode;
+
+	    mode = vec[0];
+	    error = (*etc->chops->txqosmodeset) (etc->ch, mode);
+	    if (!error) {
+		etc->txqos_mode = mode;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+    case ETCTXQOSWEIGHTSET:
+	if (vec) {
+	    uint queue, weight;
+
+	    queue = vec[0];
+	    if (queue >= NUMTXQ) {
+		goto err;
+	    }
+	    weight = vec[1];
+	    error = (*etc->chops->txqosweightset) (etc->ch, queue, weight);
+	    if (!error) {
+		etc->txqos_weight[queue] = weight;
+	    }
+	} else {
+	    goto err;
+	}
+	break;
+
+
+    default:
+      err:
+	error = -1;
+    }
+
+    return (error);
+}
+
+/* called once per second */
+void etc_watchdog(etc_info_t *etc)
+{
+    uint16 status;
+    uint16 lpa;
+
+    etc->now++;
+
+    /* no local phy registers */
+    if (etc->phyaddr == EPHY_NOREG) {
+	etc->linkstate = TRUE;
+	etc->duplex = 1;
+	/* keep emac txcontrol duplex bit consistent with current phy duplex */
+	(*etc->chops->duplexupd) (etc->ch);
+	return;
+    }
+
+    status = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 1);
+    /* check for bad mdio read */
+    if (status == 0xffff) {
+	ET_ERROR(("et%d: etc_watchdog: bad mdio read: phyaddr %d mdcport %d\n", etc->unit, etc->phyaddr, etc->mdcport));
+	return;
+    }
+
+    if (etc->forcespeed == ET_AUTO) {
+	uint16 adv, adv2 = 0, status2 = 0, estatus;
+
+	adv = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 4);
+	lpa = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 5);
+
+	/* read extended status register. if we are 1000BASE-T
+	 * capable then get our advertised capabilities and the
+	 * link partner capabilities from 1000BASE-T control and
+	 * status registers.
+	 */
+	estatus = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 15);
+	if ((estatus != 0xffff) && (estatus & EST_1000TFULL)) {
+	    /* read 1000BASE-T control and status registers */
+	    adv2 = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 9);
+	    status2 = (*etc->chops->phyrd) (etc->ch, etc->phyaddr, 10);
+	}
+
+	/* update current speed and duplex */
+	if ((adv2 & ADV_1000FULL) && (status2 & LPA_1000FULL)) {
+	    etc->speed = 1000;
+	    etc->duplex = 1;
+	} else if ((adv2 & ADV_1000HALF) && (status2 & LPA_1000HALF)) {
+	    etc->speed = 1000;
+	    etc->duplex = 0;
+	} else if ((adv & ADV_100FULL) && (lpa & LPA_100FULL)) {
+	    etc->speed = 100;
+	    etc->duplex = 1;
+	} else if ((adv & ADV_100HALF) && (lpa & LPA_100HALF)) {
+	    etc->speed = 100;
+	    etc->duplex = 0;
+	} else if ((adv & ADV_10FULL) && (lpa & LPA_10FULL)) {
+	    etc->speed = 10;
+	    etc->duplex = 1;
+	} else {
+	    etc->speed = 10;
+	    etc->duplex = 0;
+	}
+    }
+
+    /* monitor link state */
+    if (!etc->linkstate && (status & STAT_LINK)) {
+	etc->linkstate = TRUE;
+	if (etc->pm_modechange)
+	    etc->pm_modechange = FALSE;
+	else
+	    et_link_up(etc->et);
+    } else if (etc->linkstate && !(status & STAT_LINK)) {
+	etc->linkstate = FALSE;
+	if (!etc->pm_modechange)
+	    et_link_down(etc->et);
+    }
+
+    /* keep emac txcontrol duplex bit consistent with current phy duplex */
+    (*etc->chops->duplexupd) (etc->ch);
+
+    /* check for remote fault error */
+    if (status & STAT_REMFAULT) {
+	ET_ERROR(("et%d: remote fault\n", etc->unit));
+    }
+
+    /* check for jabber error */
+    if (status & STAT_JAB) {
+	ET_ERROR(("et%d: jabber\n", etc->unit));
+    }
+
+    /*
+     * Read chip mib counters occationally before the 16bit ones can wrap.
+     * We don't use the high-rate mib counters.
+     */
+    if ((etc->now % 30) == 0)
+	(*etc->chops->statsupd) (etc->ch);
+}
+
+static void etc_loopback(etc_info_t *etc, int on)
+{
+    ET_TRACE(("et%d: etc_loopback: %d\n", etc->unit, on));
+
+    etc->loopbk = (bool) on;
+    et_init(etc->et, ET_INIT_DEF_OPTIONS);
+}
+
+void etc_promisc(etc_info_t *etc, uint on)
+{
+    ET_TRACE(("et%d: etc_promisc: %d\n", etc->unit, on));
+
+    etc->promisc = (bool) on;
+    et_init(etc->et, ET_INIT_DEF_OPTIONS);
+}
+
+void etc_qos(etc_info_t *etc, uint on)
+{
+    ET_TRACE(("et%d: etc_qos: %d\n", etc->unit, on));
+
+    etc->qos = (bool) on;
+    et_init(etc->et, ET_INIT_DEF_OPTIONS);
+}
+
+#ifdef BCMDBG
+void etc_dump(etc_info_t *etc, struct bcmstrbuf *b)
+{
+    etc_dumpetc(etc, b);
+    (*etc->chops->dump) (etc->ch, b);
+}
+
+static void etc_dumpetc(etc_info_t *etc, struct bcmstrbuf *b)
+{
+    char perm[32], cur[32];
+    uint i;
+
+    printf("etc 0x%x et 0x%x unit %d msglevel %d speed/duplex %d%s\n",
+	   (ulong) etc, (ulong) etc->et, etc->unit, et_msg_level,
+	   etc->speed, (etc->duplex ? "full" : "half"));
+    printf("up %d promisc %d loopbk %d forcespeed %d advertise 0x%x "
+	   "needautoneg %d\n",
+	   etc->up, etc->promisc, etc->loopbk, etc->forcespeed,
+	   etc->advertise, etc->needautoneg);
+    printf("piomode %d pioactive 0x%x nmulticast %d allmulti %d qos %d\n",
+	   etc->piomode, (ulong) etc->pioactive, etc->nmulticast,
+	   etc->allmulti, etc->qos);
+    printf
+	("vendor 0x%x device 0x%x rev %d coreunit %d phyaddr %d mdcport %d\n",
+	 etc->vendorid, etc->deviceid, etc->chiprev, etc->coreunit,
+	 etc->phyaddr, etc->mdcport);
+
+    printf("perm_etheraddr %s cur_etheraddr %s\n",
+	   bcm_ether_ntoa(&etc->perm_etheraddr, perm),
+	   bcm_ether_ntoa(&etc->cur_etheraddr, cur));
+
+    if (etc->nmulticast) {
+	printf("multicast: ");
+	for (i = 0; i < etc->nmulticast; i++)
+	    printf("%s ", bcm_ether_ntoa(&etc->multicast[i], cur));
+	printf("\n");
+    }
+
+    printf("linkstate %d\n", etc->linkstate);
+    printf("\n");
+
+    printf("flow control mode is ", etc->flowcntl_mode);
+    switch (etc->flowcntl_mode) {
+    case FLOW_CTRL_MODE_DISABLE:
+	printf(" Disabled.\n");
+	break;
+    case FLOW_CTRL_MODE_AUTO:
+	printf(" Auto mode.\n");
+	break;
+    case FLOW_CTRL_MODE_CPU:
+	printf(" CPU mode.\n");
+	break;
+    case FLOW_CTRL_MODE_MIX:
+	printf(" Auto and CPU mode.\n");
+	break;
+    default:
+	printf("Unknow.\n");
+	break;
+    }
+
+    printf
+	("flow control auto mode : on threshod= %d, off threshold = %d\n",
+	 etc->flowcntl_auto_on_thresh, etc->flowcntl_auto_off_thresh);
+    printf("flow control cpu mode : pause_on = %d\n",
+	   etc->flowcntl_cpu_pause_on);
+    for (i = 0; i < NUMRXQ; i++) {
+	printf
+	    ("RX channel flow control : channel %d, on threshod= %d, off threshold = %d\n",
+	     i, etc->flowcntl_rx_on_thresh[i],
+	     etc->flowcntl_rx_off_thresh[i]);
+	printf("RX separate header is %s\n",
+	       (etc->en_rxsephdr[i]) ? "enabled" : "disabled");
+    }
+    printf("\n");
+
+    printf("TX qos mode is ");
+    switch (etc->txqos_mode) {
+    case TXQOS_MODE_1STRICT_3WRR:
+	printf("Q3 Strict, Q2 WRR, Q1 WRR, Q0 WRR\n");
+	break;
+    case TXQOS_MODE_2STRICT_2WRR:
+	printf("Q3 Strict, Q2 Strict, Q1 WRR, Q0 WRR\n");
+	break;
+    case TXQOS_MODE_3STRICT_1WRR:
+	printf("Q3 Strict, Q2 Strict, Q1 Strict, Q0 WRR\n");
+	break;
+    case TXQOS_MODE_ALL_STRICT:
+	printf("Q3~Q0 all Strict\n");
+	break;
+    default:
+	printf(" Unknow\n");
+	break;
+    }
+    for (i = 0; i < (NUMTXQ - 1); i++) {
+	printf("TX qos : queue %d, weight = %d\n",
+	       i, etc->txqos_weight[i]);
+    }
+    printf("\n");
+
+    /* TPID */
+    for (i = 0; i < NUM_STAG_TPID; i++) {
+	printf("STAG TPID %d = 0x%x\n", i, etc->tpid[i]);
+    }
+    printf("\n");
+
+    /* refresh stat counters */
+    (*etc->chops->statsupd) (etc->ch);
+
+    /* summary stat counter line */
+    /* use sw frame and byte counters -- hw mib counters wrap too quickly */
+    printf
+	("txframe %d txbyte %d txerror %d rxframe %d rxbyte %d rxerror %d\n",
+	 etc->txframe, etc->txbyte, etc->txerror, etc->rxframe,
+	 etc->rxbyte, etc->rxerror);
+
+    /* transmit & receive stat counters */
+    /* hardware mib pkt and octet counters wrap too quickly to be useful */
+    (*etc->chops->dumpmib) (etc->ch, (char *) b->buf);
+
+    printf("txnobuf %d reset %d dmade %d dmada %d dmape %d\n",
+	   etc->txnobuf, etc->reset, etc->dmade, etc->dmada, etc->dmape);
+
+    /* hardware mib pkt and octet counters wrap too quickly to be useful */
+    printf("rxnobuf %d rxdmauflo %d rxoflo %d rxbadlen %d\n",
+	   etc->rxnobuf, etc->rxdmauflo, etc->rxoflo, etc->rxbadlen);
+
+    printf("\n");
+}
+#endif				/* BCMDBG */
+
+uint etc_totlen(etc_info_t *etc, void *p)
+{
+    uint total;
+
+    total = 0;
+    for (; p; p = PKTNEXT(etc->osh, p))
+	total += PKTLEN(etc->osh, p);
+    return (total);
+}
+
+#ifdef BCMDBG
+void etc_prhdr(char *msg, struct ether_header *eh, uint len, int unit)
+{
+    char da[32], sa[32];
+
+    if (msg && (msg[0] != '\0'))
+	printf("et%d: %s: ", unit, msg);
+    else
+	printf("et%d: ", unit);
+
+    printf("dst %s src %s type 0x%x len %d\n",
+	   bcm_ether_ntoa((struct ether_addr *) eh->ether_dhost, da),
+	   bcm_ether_ntoa((struct ether_addr *) eh->ether_shost, sa),
+	   ntoh16(eh->ether_type), len);
+}
+
+void etc_prhex(char *msg, uchar *buf, uint nbytes, int unit)
+{
+    if (msg && (msg[0] != '\0'))
+	printf("et%d: %s:\n", unit, msg);
+    else
+	printf("et%d:\n", unit);
+
+    prhex(NULL, buf, nbytes);
+}
+#endif				/* BCMDBG */
+
+uint32 etc_up2tc(uint32 up)
+{
+    extern uint32 up2tc[];
+
+    /* Checking if the priority is overflow , return the max  queue number */
+    if (up > MAXPRIO) {
+	return TC_VO;
+    }
+
+    return (up2tc[up]);
+}
+
+uint32 etc_priq(uint32 txq_state)
+{
+    extern uint32 priq_selector[];
+
+    /* Checking if the input value is overflow */
+    if (txq_state > ((0x1 << NUMTXQ) - 1)) {
+	txq_state &= ((0x1 << NUMTXQ) - 1);
+    }
+
+    return (priq_selector[txq_state]);
+}
diff --git a/drivers/net/gmac/etc.h b/drivers/net/gmac/etc.h
new file mode 100644
index 0000000..a4eef00
--- /dev/null
+++ b/drivers/net/gmac/etc.h
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Common [OS-independent] header file for
+ * Broadcom BCM47XX 10/100Mbps Ethernet Device Driver
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ *
+ */
+
+#ifndef _etc_h_
+#define _etc_h_
+
+#include <etioctl.h>
+#include <802.1d.h>
+
+#define MAXMULTILIST    32
+
+#ifndef ch_t
+#define ch_t void
+#endif
+
+#define NUMTXQ      4
+#define NUMRXQ      4
+#define NUM_STAG_TPID       4
+
+struct etc_info;		/* forward declaration */
+struct bcmstrbuf;		/* forward declaration */
+
+/* each chip type supports a set of chip-type-specific ops */
+struct chops {
+    bool(*id) (uint vendor, uint device);	/* return true if match */
+    void *(*attach) (struct etc_info *etc, void *dev, void *regs);
+    void (*detach) (ch_t *ch);	/* free chip private state */
+    void (*reset) (ch_t *ch);	/* chip reset */
+    void (*init) (ch_t *ch, uint options);	/* chip init */
+     bool(*tx) (ch_t *ch, void *p);	/* transmit frame */
+    void *(*rx) (ch_t *ch);	/* receive frame */
+    void (*rxfill) (ch_t *ch);	/* post dma rx buffers */
+    int (*getintrevents) (ch_t *ch, bool in_isr);	/* return intr events */
+     bool(*errors) (ch_t *ch);	/* handle chip errors */
+    void (*intrson) (ch_t *ch);	/* enable chip interrupts */
+    void (*intrsoff) (ch_t *ch);	/* disable chip interrupts */
+    void (*txreclaim) (ch_t *ch, bool all);	/* reclaim transmit resources */
+    void (*rxreclaim) (ch_t *ch);	/* reclaim receive resources */
+    void (*statsupd) (ch_t *ch);	/* update sw stat counters */
+    void (*dumpmib) (ch_t *ch, char *buf);	/* get sw mib counters */
+    void (*enablepme) (ch_t *ch);	/* enable PME */
+    void (*disablepme) (ch_t *ch);	/* disable PME */
+    void (*phyreset) (ch_t *ch, uint phyaddr);	/* reset phy */
+     uint16(*phyrd) (ch_t *ch, uint phyaddr, uint reg);	/* read phy reg */
+    void (*phywr) (ch_t *ch, uint phyaddr, uint reg, uint16 val);	/* write phy register */
+    void (*dump) (ch_t *ch, struct bcmstrbuf *b);	/* debugging output */
+    void (*longname) (ch_t *ch, char *buf, uint bufsize);	/* return descriptive name */
+    void (*duplexupd) (ch_t *ch);	/* keep mac duplex consistent */
+    int (*cfprd) (ch_t *ch, void *buf);	/* read CFP entry from hw */
+    int (*cfpwr) (ch_t *ch, void *buf);	/* write CFP entry into hw */
+    int (*cfpfldrd) (ch_t *ch, void *buf);	/* get CFP field value */
+    int (*cfpfldwr) (ch_t *ch, void *buf);	/* set CFP field value */
+    int (*cfpudfrd) (ch_t *ch, void *buf);	/* get CFP UDF configuration */
+    int (*cfpudfwr) (ch_t *ch, void *buf);	/* set CFP UDF configuration */
+    int (*rxrateset) (ch_t *ch, uint channel, uint pps);	/* RX rate configuration */
+    int (*rxrateget) (ch_t *ch, uint channel, uint *pps);	/* RX rate configuration */
+    int (*txrateset) (ch_t *ch, uint channel, uint rate, uint burst);	/* TX rate configuration */
+    int (*txrateget) (ch_t *ch, uint channel, uint *rate, uint *burst);	/* TX rate configuration */
+    int (*flowctrlmodeset) (ch_t *ch, uint mode);	/* set flow control mode */
+    int (*flowctrlmodeget) (ch_t *ch, uint *mode);	/* get flow control mode */
+    int (*flowctrlautoset) (ch_t *ch, uint on_thresh, uint off_thresh);	/* set on/off threshold for auto mode */
+    int (*flowctrlautoget) (ch_t *ch, uint *on_thresh, uint *off_thresh);	/* get on/off threshold for auto mode */
+    int (*flowctrlcpuset) (ch_t *ch, uint pause_on);	/* enable/disable pause frame for cpu mode */
+    int (*flowctrlcpuget) (ch_t *ch, uint *pause_on);	/* get the enable/disable pause frame for cpu mode */
+    int (*flowctrlrxchanset) (ch_t *ch, uint chan, uint on_thresh, uint off_thresh);	/* set rx channel thresholds */
+    int (*flowctrlrxchanget) (ch_t *ch, uint chan, uint *on_thresh, uint *off_thresh);	/* get rx channel thresholds */
+    int (*tpidset) (ch_t *ch, uint index, uint tpid);	/* Set the S-TAG TPID value */
+    int (*tpidget) (ch_t *ch, uint index, uint *tpid);	/* Get the S-TAG TPID value */
+    int (*pvtagset) (ch_t *ch, uint private_tag);	/* Set the private tag value */
+    int (*pvtagget) (ch_t *ch, uint *private_tag);	/* Get the private tag value */
+    int (*rxsephdrset) (ch_t *ch, uint enable);	/* Enable/Disable the RX separate header */
+    int (*rxsepgetget) (ch_t *ch, uint *enable);	/* Get the value of RX separate header feature */
+    int (*txqosmodeset) (ch_t *ch, uint mode);	/* set tx qos mode */
+    int (*txqosmodeget) (ch_t *ch, uint *mode);	/* get tx qos mode */
+    int (*txqosweightset) (ch_t *ch, uint queue, uint weight);	/* set tx queue weight */
+    int (*txqosweightget) (ch_t *ch, uint queue, uint *weight);	/* get tx queue weight */
+};
+
+/*
+ * "Common" os-independent software state structure.
+ */
+typedef struct etc_info {
+    void *et;			/* pointer to os-specific private state */
+    uint unit;			/* device instance number */
+    void *osh;			/* pointer to os handler */
+    void *mib;			/* pointer to s/w maintained mib counters */
+    bool up;			/* interface up and running */
+    bool promisc;		/* promiscuous destination address */
+    bool qos;			/* QoS priority determination on rx */
+    bool loopbk;		/* loopback override mode */
+
+    int forcespeed;		/* disable autonegotiation and force speed/duplex */
+    uint advertise;		/* control speed/duplex advertised capability bits */
+    uint advertise2;		/* control gige speed/duplex advertised caps */
+    bool needautoneg;		/* request restart autonegotiation */
+    int speed;			/* current speed: 10, 100 */
+    int duplex;			/* current duplex: 0=half, 1=full */
+
+    bool piomode;		/* enable programmed io (!dma) */
+    void *pioactive;		/* points to pio packet being transmitted */
+    volatile uint *txavail[NUMTXQ];	/* dma: # tx descriptors available */
+
+    uint16 vendorid;		/* pci function vendor id */
+    uint16 deviceid;		/* pci function device id */
+    uint chip;			/* chip number */
+    uint chiprev;		/* chip revision */
+    uint coreid;		/* core id */
+    uint corerev;		/* core revision */
+
+    bool nicmode;		/* is this core using its own pci i/f */
+
+    struct chops *chops;	/* pointer to chip-specific opsvec */
+    void *ch;			/* pointer to chip-specific state */
+    void *robo;			/* optional robo private data */
+
+    uint txq_state;		/* tx queues state bits */
+    uint coreunit;		/* sb chips: chip enet instance # */
+    uint phyaddr;		/* sb chips: mdio 5-bit phy address */
+    uint mdcport;		/* sb chips: which mii to use (enet core #) to access phy */
+
+    struct ether_addr cur_etheraddr;	/* our local ethernet address */
+    struct ether_addr perm_etheraddr;	/* original sprom local ethernet address */
+
+    struct ether_addr multicast[MAXMULTILIST];
+    uint nmulticast;
+    bool allmulti;		/* enable all multicasts */
+
+    bool linkstate;		/* link integrity state */
+    bool pm_modechange;		/* true if mode change is to due pm */
+
+    uint32 now;			/* elapsed seconds */
+
+    uint32 boardflags;		/* board flags */
+    uint32 pkt_mem;		/* The memory type of packet buffer */
+    uint32 pkthdr_mem;		/* The memory type of packet header buffer */
+    uint32 en_rxsephdr[NUMRXQ];
+
+    /* rx rate */
+    uint32 rx_pps[NUMRXQ];
+    uint32 tx_rate[NUMTXQ];
+    uint32 tx_burst[NUMTXQ];
+
+    /* tx qos mode */
+    uint32 txqos_mode;
+    uint32 txqos_weight[NUMTXQ];
+
+    /* flow control */
+    uint32 flowcntl_mode;
+    uint32 flowcntl_auto_on_thresh;
+    uint32 flowcntl_auto_off_thresh;
+    uint32 flowcntl_cpu_pause_on;
+    uint32 flowcntl_rx_on_thresh[NUMRXQ];
+    uint32 flowcntl_rx_off_thresh[NUMRXQ];
+
+    /* TPID */
+    uint32 tpid[NUM_STAG_TPID];
+
+    /* Private Tag */
+    uint32 ptag;
+
+    /* sw-maintained stat counters */
+    uint32 txframe;		/* transmitted frames */
+    uint32 txbyte;		/* transmitted bytes */
+    uint32 rxframe;		/* received frames */
+    uint32 rxbyte;		/* received bytes */
+    uint32 txerror;		/* total tx errors */
+    uint32 txnobuf;		/* tx out-of-buffer errors */
+    uint32 rxerror;		/* total rx errors */
+    uint32 rxnobuf;		/* rx out-of-buffer errors */
+    uint32 reset;		/* reset count */
+    uint32 dmade;		/* pci descriptor errors */
+    uint32 dmada;		/* pci data errors */
+    uint32 dmape;		/* descriptor protocol error */
+    uint32 rxdmauflo;		/* receive descriptor underflow */
+    uint32 rxoflo;		/* receive fifo overflow */
+    uint32 txuflo;		/* transmit fifo underflow */
+    uint32 rxbadlen;		/* 802.3 len field != read length */
+} etc_info_t;
+
+/* interrupt event bitvec */
+#define INTR_TX     0x1
+#define INTR_RX     0x2
+#define INTR_ERROR  0x4
+#define INTR_TO     0x8
+#define INTR_NEW    0x10
+
+/* forcespeed values */
+#define ET_AUTO     -1
+#define ET_10HALF   0
+#define ET_10FULL   1
+#define ET_100HALF  2
+#define ET_100FULL  3
+#define ET_1000HALF 4
+#define ET_1000FULL 5
+
+/* init options */
+#define ET_INIT_FULL     0x1
+#define ET_INIT_INTRON   0x2
+
+/* Specific init options for et_init */
+#define ET_INIT_DEF_OPTIONS   (ET_INIT_FULL | ET_INIT_INTRON)
+#define ET_INIT_INTROFF       (ET_INIT_FULL)
+#define ET_INIT_PARTIAL      (0)
+
+/* macro to safely clear the UP flag */
+#define ET_FLAG_DOWN(x)   (*(x)->chops->intrsoff)((x)->ch);  \
+              (x)->up = FALSE;
+
+/*
+ * Least-common denominator rxbuf start-of-data offset:
+ * Must be >= size of largest rxhdr
+ * Must be 2-mod-4 aligned so IP is 0-mod-4
+ */
+#define HWRXOFF     32
+
+#define TC_BK       0		/* background traffic class */
+#define TC_BE       1		/* best effort traffic class */
+#define TC_CL       2		/* controlled load traffic class */
+#define TC_VO       3		/* voice traffic class */
+#define TC_NONE     -1		/* traffic class none */
+
+#define RX_Q0       0		/* receive DMA queue */
+#define RX_Q1       1		/* receive DMA queue */
+#define RX_Q2       2		/* receive DMA queue */
+#define RX_Q3       3		/* receive DMA queue */
+
+#define TX_Q0       TC_BK	/* DMA txq 0 */
+#define TX_Q1       TC_BE	/* DMA txq 1 */
+#define TX_Q2       TC_CL	/* DMA txq 2 */
+#define TX_Q3       TC_VO	/* DMA txq 3 */
+
+/* flow control */
+#define FLOW_CTRL_MODE_DISABLE     0x0	/* disable mode */
+#define FLOW_CTRL_MODE_AUTO     0x1	/* auto mode */
+#define FLOW_CTRL_MODE_CPU     0x2	/* cpu mode */
+#define FLOW_CTRL_MODE_MIX     0x3	/* auto + cpu mode */
+
+#define FLWO_CTRL_AUTO_MODE_DEFAULT_ON_THRESH       0x6a4
+#define FLWO_CTRL_AUTO_MODE_DEFAULT_OFF_THRESH       0x578
+
+/* tx qos mode */
+#define TXQOS_MODE_1STRICT_3WRR     0x0
+#define TXQOS_MODE_2STRICT_2WRR     0x1
+#define TXQOS_MODE_3STRICT_1WRR     0x2
+#define TXQOS_MODE_ALL_STRICT     0x3
+
+#define TXQOS_DEFAULT_WEIGHT        0xa
+
+
+/* S-TAG TPID */
+#define STAG_TPID_DEFAULT       0x88a8
+
+extern uint32 etc_up2tc(uint32 up);
+extern uint32 etc_priq(uint32 txq_state);
+
+/* rx header flags bits */
+#define RXH_FLAGS(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    (ltoh16(((bcmgmacrxh_t *)(rxh))->flags) & (GRXF_CRC | GRXF_OVF | GRXF_OVERSIZE)) : \
+    (ltoh16(((bcmenetrxh_t *)(rxh))->flags) & (RXF_NO | RXF_RXER | RXF_CRC | RXF_OV)))
+
+#define RXH_OVERSIZE(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    (ltoh16(((bcmgmacrxh_t *)(rxh))->flags) & GRXF_OVERSIZE) : FALSE)
+
+#define RXH_CRC(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    (ltoh16(((bcmgmacrxh_t *)(rxh))->flags) & GRXF_CRC) : \
+    (ltoh16(((bcmenetrxh_t *)(rxh))->flags) & RXF_CRC))
+
+#define RXH_OVF(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    (ltoh16(((bcmgmacrxh_t *)(rxh))->flags) & GRXF_OVF) : \
+    (ltoh16(((bcmenetrxh_t *)(rxh))->flags) & RXF_OV))
+
+#define RXH_RXER(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    FALSE : (ltoh16(((bcmenetrxh_t *)(rxh))->flags) & RXF_RXER))
+
+#define RXH_NO(etc, rxh) (((etc)->coreid == GMAC_CORE_ID) ? \
+    FALSE : (ltoh16(((bcmenetrxh_t *)(rxh))->flags) & RXF_NO))
+
+/* exported prototypes */
+extern struct chops *etc_chipmatch(uint vendor, uint device);
+extern void *etc_attach(void *et, uint vendor, uint device, uint unit,
+			void *dev, void *regsva);
+extern void etc_detach(etc_info_t *etc);
+extern void etc_reset(etc_info_t *etc);
+extern void etc_init(etc_info_t *etc, uint options);
+extern void etc_up(etc_info_t *etc);
+extern uint etc_down(etc_info_t *etc, int reset);
+extern int etc_ioctl(etc_info_t *etc, int cmd, void *arg);
+extern void etc_promisc(etc_info_t *etc, uint on);
+extern void etc_qos(etc_info_t *etc, uint on);
+extern void etc_dump(etc_info_t *etc, struct bcmstrbuf *b);
+extern void etc_watchdog(etc_info_t *etc);
+extern uint etc_totlen(etc_info_t *etc, void *p);
+
+#endif				/* _etc_h_ */
diff --git a/drivers/net/gmac/etcgmac.c b/drivers/net/gmac/etcgmac.c
new file mode 100644
index 0000000..471d888
--- /dev/null
+++ b/drivers/net/gmac/etcgmac.c
@@ -0,0 +1,3564 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ * 
+ */
+/*
+ * Broadcom Gigabit Ethernet MAC (Unimac) core.
+ *
+ * This file implements the chip-specific routines for the GMAC core.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#include <typedefs.h>
+#include <osl.h>
+#include <bcmendian.h>
+#include <bcmutils.h>
+#include <bcmdevs.h>
+#include <bcmenetphy.h>
+#include <ethernet.h>
+#include <802.1d.h>
+#include <siutils.h>
+#include <sbhnddma.h>
+#include <hnddma.h>
+#include <et_dbg.h>
+#include <hndsoc.h>
+#include <bcmgmacmib.h>
+#include <gmac0_core.h>
+#include <gmac_common.h>
+#include <et_export.h>		/* for et_phyxx() routines */
+#include <etcgmac.h>
+
+struct bcmgmac;			/* forward declaration */
+#define ch_t    struct bcmgmac
+#include <etc.h>
+
+/* private chip state */
+struct bcmgmac {
+    void *et;			/* pointer to et private state */
+    etc_info_t *etc;		/* pointer to etc public state */
+
+    gmac0regs_t *regs;		/* pointer to chip registers */
+    osl_t *osh;			/* os handle */
+
+    void *etphy;		/* pointer to et for shared mdc/mdio contortion */
+
+    uint32 intstatus;		/* saved interrupt condition bits */
+    uint32 intmask;		/* current software interrupt mask */
+
+    hnddma_t *di[NUMTXQ];	/* dma engine software state */
+
+    bool mibgood;		/* true once mib registers have been cleared */
+    gmacmib_t mib;		/* mib statistic counters */
+    si_t *sih;			/* si utils handle */
+
+    char *vars;			/* sprom name=value */
+    uint vars_size;
+
+    void *adm;			/* optional admtek private data */
+    mcfilter_t mf;		/* multicast filter */
+};
+
+/* Using CFP entries to achieve the promiscuous function */
+/* Masked it due to reset GMAC cores will impact CFP entries. */
+/* #define GMAC_PROMISC_BY_CFP */
+
+/* local prototypes */
+static bool chipid(uint vendor, uint device);
+static void *chipattach(etc_info_t *etc, void *osh, void *regsva);
+static void chipdetach(ch_t *ch);
+static void chipreset(ch_t *ch);
+static void chipinit(ch_t *ch, uint options);
+static bool chiptx(ch_t *ch, void *p);
+static void *chiprx(ch_t *ch);
+static void chiprxfill(ch_t *ch);
+static int chipgetintrevents(ch_t *ch, bool in_isr);
+static bool chiperrors(ch_t *ch);
+static void chipintrson(ch_t *ch);
+static void chipintrsoff(ch_t *ch);
+static void chiptxreclaim(ch_t *ch, bool all);
+static void chiprxreclaim(ch_t *ch);
+static void chipstatsupd(ch_t *ch);
+static void chipdumpmib(ch_t *ch, char *b);
+static void chipenablepme(ch_t *ch);
+static void chipdisablepme(ch_t *ch);
+static void chipphyreset(ch_t *ch, uint phyaddr);
+static uint16 chipphyrd(ch_t *ch, uint phyaddr, uint reg);
+static void chipphywr(ch_t *ch, uint phyaddr, uint reg, uint16 v);
+static void chipdump(ch_t *ch, struct bcmstrbuf *b);
+static void chiplongname(ch_t *ch, char *buf, uint bufsize);
+static void chipduplexupd(ch_t *ch);
+
+static void chipphyinit(ch_t *ch, uint phyaddr);
+static void chipphyor(ch_t *ch, uint phyaddr, uint reg, uint16 v);
+static void chipphyforce(ch_t *ch, uint phyaddr);
+static void chipphyadvertise(ch_t *ch, uint phyaddr);
+static int chipcfprd(ch_t *ch, void *buf);
+static int chipcfpwr(ch_t *ch, void *buf);
+static int chipcfpfldrd(ch_t *ch, void *buf);
+static int chipcfpfldwr(ch_t *ch, void *buf);
+static int chipcfpudfrd(ch_t *ch, void *buf);
+static int chipcfpudfwr(ch_t *ch, void *buf);
+static int chiprxrateset(ch_t *ch, uint channel, uint pps);
+static int chiprxrateget(ch_t *ch, uint channel, uint *pps);
+static int chiptxrateset(ch_t *ch, uint channel, uint rate, uint burst);
+static int chiptxrateget(ch_t *ch, uint channel, uint *rate,
+			 uint *burst);
+static int chipflowctrlmodeset(ch_t *ch, uint mode);
+static int chipflowctrlmodeget(ch_t *ch, uint *mode);
+static int chipflowctrlautoset(ch_t *ch, uint on_thresh, uint off_thresh);
+static int chipflowctrlautoget(ch_t *ch, uint *on_thresh,
+			       uint *off_thresh);
+static int chipflowctrlcpuset(ch_t *ch, uint pause_on);
+static int chipflowctrlcpuget(ch_t *ch, uint *pause_on);
+static int chipflowctrlrxchanset(ch_t *ch, uint rxchan, uint on_thresh,
+				 uint off_thresh);
+static int chipflowctrlrxchanget(ch_t *ch, uint rxchan, uint *on_thresh,
+				 uint *off_thresh);
+static int chiptpidset(ch_t *ch, uint index, uint tpid);
+static int chiptpidget(ch_t *ch, uint index, uint *tpid);
+static int chippvtagset(ch_t *ch, uint private_tag);
+static int chippvtagget(ch_t *ch, uint *private_tag);
+static int chiprxsephdrset(ch_t *ch, uint enable);
+static int chiprxsephdrget(ch_t *ch, uint *enable);
+static int chiptxqosmodeset(ch_t *ch, uint mode);
+static int chiptxqosmodeget(ch_t *ch, uint *mode);
+static int chiptxqosweightset(ch_t *ch, uint queue, uint weight);
+static int chiptxqosweightget(ch_t *ch, uint queue, uint *weight);
+
+#ifdef CFG_ROBO
+static void robo_port_enable(ch_t *ch);
+static void robo_port_stop(ch_t *ch);
+#define SWAP16(x) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8))
+#endif				/* CFG_ROBO */
+
+#ifdef BCMDBG
+static void chipdumpregs(ch_t *ch, gmac0regs_t *regs,
+			 struct bcmstrbuf *b);
+#endif				/* BCMDBG */
+static void gmac_mf_cleanup(ch_t *ch);
+static int gmac_speed(ch_t *ch, uint32 speed);
+static void gmac_miiconfig(ch_t *ch);
+
+struct chops bcmgmac_et_chops = {
+    chipid,
+    chipattach,
+    chipdetach,
+    chipreset,
+    chipinit,
+    chiptx,
+    chiprx,
+    chiprxfill,
+    chipgetintrevents,
+    chiperrors,
+    chipintrson,
+    chipintrsoff,
+    chiptxreclaim,
+    chiprxreclaim,
+    chipstatsupd,
+    chipdumpmib,
+    chipenablepme,
+    chipdisablepme,
+    chipphyreset,
+    chipphyrd,
+    chipphywr,
+    chipdump,
+    chiplongname,
+    chipduplexupd,
+    chipcfprd,
+    chipcfpwr,
+    chipcfpfldrd,
+    chipcfpfldwr,
+    chipcfpudfrd,
+    chipcfpudfwr,
+    chiprxrateset,
+    chiprxrateget,
+    chiptxrateset,
+    chiptxrateget,
+    chipflowctrlmodeset,
+    chipflowctrlmodeget,
+    chipflowctrlautoset,
+    chipflowctrlautoget,
+    chipflowctrlcpuset,
+    chipflowctrlcpuget,
+    chipflowctrlrxchanset,
+    chipflowctrlrxchanget,
+    chiptpidset,
+    chiptpidget,
+    chippvtagset,
+    chippvtagget,
+    chiprxsephdrset,
+    chiprxsephdrget,
+    chiptxqosmodeset,
+    chiptxqosmodeget,
+    chiptxqosweightset,
+    chiptxqosweightget
+};
+
+static uint devices[] = {
+    BCM53000_GMAC_ID,
+    0x0000
+};
+
+#ifdef GMAC_PROMISC_BY_CFP
+#define CFP_PROMISC_ENTRY_NUM   12
+
+static uint cfp_promisc[] = {
+    0x1,
+    0x1
+};
+#endif				/* GMAC_PROMISC_BY_CFP */
+
+
+static bool chipid(uint vendor, uint device)
+{
+    int i;
+
+    if (vendor != VENDOR_BROADCOM)
+	return (FALSE);
+
+    for (i = 0; devices[i]; i++) {
+	if (device == devices[i])
+	    return (TRUE);
+    }
+
+    return (FALSE);
+}
+
+/* Check ME : 
+ *   - the QT_MDIO_PHYADDR is a force defined value for testing the MDIO 
+ *      model in QT 18. Must be removed for the formal release.
+ */
+static void *chipattach(etc_info_t *etc, void *osh, void *regsva)
+{
+    ch_t *ch;
+    gmac0regs_t *regs;
+    uint i;
+    char name[16];
+    uint boardflags, boardtype;
+#ifndef CFG_QUICKTURN
+    char *var;
+#endif
+
+    ET_TRACE(("et%d: chipattach: regsva 0x%lx\n", etc->unit,
+	      (ulong) regsva));
+
+    if ((ch = (ch_t *) MALLOC(osh, sizeof(ch_t))) == NULL) {
+	ET_ERROR(("et%d: chipattach: out of memory, malloced %d bytes\n",
+		  etc->unit, MALLOCED(osh)));
+	return (NULL);
+    }
+    bzero((char *) ch, sizeof(ch_t));
+
+    ch->etc = etc;
+    ch->et = etc->et;
+    ch->osh = osh;
+
+
+    /* store the pointer to the sw mib */
+    etc->mib = (void *) &ch->mib;
+
+    /* get si handle */
+    if ((ch->sih =
+	 si_attach(etc->deviceid, ch->osh, regsva, PCI_BUS, NULL,
+		   &ch->vars, &ch->vars_size)) == NULL) {
+	ET_ERROR(("et%d: chipattach: si_attach error\n", etc->unit));
+	goto fail;
+    }
+
+    if ((regs =
+	 (gmac0regs_t *) si_setcore(ch->sih, GMAC_CORE_ID,
+				    etc->unit)) == NULL) {
+	ET_ERROR(("et%d: chipattach: Could not setcore to the GMAC core\n",
+		  etc->unit));
+	goto fail;
+    }
+
+    ch->regs = regs;
+    etc->chip = ch->sih->chip;
+    etc->chiprev = ch->sih->chiprev;
+    etc->coreid = si_coreid(ch->sih);
+    etc->corerev = si_corerev(ch->sih);
+    etc->nicmode = !(ch->sih->bustype == SI_BUS);
+    etc->coreunit = si_coreunit(ch->sih);
+    etc->boardflags = getintvar(ch->vars, "boardflags");
+    etc->allmulti = 1;		/* enable all multicasts */
+
+    boardflags = etc->boardflags;
+    boardtype = ch->sih->boardtype;
+
+    /* configure pci core */
+    si_pci_setup(ch->sih, (1 << si_coreidx(ch->sih)));
+
+    etc->phyaddr = EPHY_NOREG;	/* CHECK ME */
+    /* reset the gmac core */
+    chipreset(ch);
+
+    /* dma attach */
+    sprintf(name, "et%d", etc->coreunit);
+
+    /* allocate dma resources for txqs */
+    /* TX: TC_BK, RX: RX_Q0 */
+    ch->di[0] = dma_attach(osh, name, ch->sih,
+			   DMAREG(ch, DMA_TX, TX_Q0),
+			   DMAREG(ch, DMA_RX, RX_Q0),
+			   NTXD, NRXD, RXBUFSZ, NRXBUFPOST, HWRXOFF,
+			   &et_msg_level, etc->pkt_mem, etc->pkthdr_mem,
+			   etc->en_rxsephdr[0]);
+
+    /* TX: TC_BE, RX: RX_Q1 */
+    ch->di[1] = dma_attach(osh, name, ch->sih,
+			   DMAREG(ch, DMA_TX, TX_Q1),
+			   DMAREG(ch, DMA_RX, RX_Q1),
+			   NTXD, NRXD, RXBUFSZ, NRXBUFPOST, HWRXOFF,
+			   &et_msg_level, etc->pkt_mem, etc->pkthdr_mem,
+			   etc->en_rxsephdr[1]);
+
+    /* TX: TC_CL, RX: RX_Q2 */
+    ch->di[2] = dma_attach(osh, name, ch->sih,
+			   DMAREG(ch, DMA_TX, TX_Q2),
+			   DMAREG(ch, DMA_RX, RX_Q2),
+			   NTXD, NRXD, RXBUFSZ, NRXBUFPOST, HWRXOFF,
+			   &et_msg_level, etc->pkt_mem, etc->pkthdr_mem,
+			   etc->en_rxsephdr[2]);
+    /* TX: TC_VO, RX: RX_Q3 */
+    ch->di[3] = dma_attach(osh, name, ch->sih,
+			   DMAREG(ch, DMA_TX, TX_Q3),
+			   DMAREG(ch, DMA_RX, RX_Q3),
+			   NTXD, NRXD, RXBUFSZ, NRXBUFPOST, HWRXOFF,
+			   &et_msg_level, etc->pkt_mem, etc->pkthdr_mem,
+			   etc->en_rxsephdr[3]);
+    for (i = 0; i < NUMTXQ; i++)
+	if (ch->di[i] == NULL) {
+	    ET_ERROR(("et%d: chipattach: dma_attach failed\n", etc->unit));
+	    goto fail;
+	}
+
+    for (i = 0; i < NUMTXQ; i++)
+	if (ch->di[i] != NULL)
+	    etc->txavail[i] = (uint *) dma_getvar(ch->di[i], "&txavail");
+
+#ifdef CFG_QUICKTURN
+
+    etc->perm_etheraddr.octet[0] = 0x0;
+    etc->perm_etheraddr.octet[1] = 0x10;
+    etc->perm_etheraddr.octet[2] = 0x18;
+    etc->perm_etheraddr.octet[3] = 0x53;
+    etc->perm_etheraddr.octet[4] = 0x00;
+    etc->perm_etheraddr.octet[5] = 0x00 | (uint8) etc->coreunit;
+    bcopy((char *) &etc->perm_etheraddr, (char *) &etc->cur_etheraddr,
+	  ETHER_ADDR_LEN);
+
+#else				/* !CFG_QUICKTURN */
+
+    /* get our local ether addr */
+    sprintf(name, "ETH%d_HWADDR", etc->coreunit);
+    var = getvar(ch->vars, name);
+    if (var == NULL) {
+	ET_ERROR(("et%d: chipattach: getvar(%s) not found, using default value\n", etc->unit, name));
+	etc->perm_etheraddr.octet[0] = 0x0;
+	etc->perm_etheraddr.octet[1] = 0x10;
+	etc->perm_etheraddr.octet[2] = 0x18;
+	etc->perm_etheraddr.octet[3] = 0x53;
+	etc->perm_etheraddr.octet[4] = 0x00;
+	etc->perm_etheraddr.octet[5] = 0x00 | (uint8) etc->coreunit;
+	bcopy((char *) &etc->perm_etheraddr, (char *) &etc->cur_etheraddr,
+	      ETHER_ADDR_LEN);
+    } else {
+	bcm_ether_atoe(var, &etc->perm_etheraddr);
+    }
+
+    if (ETHER_ISNULLADDR(&etc->perm_etheraddr)) {
+	ET_ERROR(("et%d: chipattach: invalid format: %s=%s\n", etc->unit,
+		  name, var));
+	goto fail;
+    }
+    bcopy((char *) &etc->perm_etheraddr, (char *) &etc->cur_etheraddr,
+	  ETHER_ADDR_LEN);
+
+    /*
+     * Too much can go wrong in scanning MDC/MDIO playing "whos my phy?" .
+     * Instead, explicitly require the environment var "et<coreunit>phyaddr=<val>".
+     */
+
+    /* get our phyaddr value */
+    sprintf(name, "et%dphyaddr", etc->coreunit);
+    var = getvar(ch->vars, name);
+    if (var == NULL) {
+	ET_ERROR(("et%d: chipattach: getvar(%s) not found, using default value\n", etc->unit, name));
+	etc->phyaddr = EPHY_NOREG;
+    } else {
+	etc->phyaddr = bcm_atoi(var) & EPHY_MASK;
+    }
+
+    /* nvram says no phy is present */
+    if (etc->phyaddr == EPHY_NONE) {
+	ET_ERROR(("et%d: chipattach: phy not present\n", etc->unit));
+	goto fail;
+    }
+#endif				/* CFG_QUICKTURN */
+
+    /* set default sofware intmask */
+    ch->intmask = DEF_INTMASK;
+
+    /* reset phy: reset it once now */
+    chipphyreset(ch, etc->phyaddr);
+
+#ifdef CFG_ROBO
+    if (etc->unit == 0) {
+	robo_port_enable(ch);
+    }
+#endif				/* CFG_ROBO */
+
+    return ((void *) ch);
+
+  fail:
+    chipdetach(ch);
+    return (NULL);
+}
+
+static void chipdetach(ch_t *ch)
+{
+    int32 i;
+
+    ET_TRACE(("et%d: chipdetach\n", ch->etc->unit));
+
+    if (ch == NULL)
+	return;
+
+#ifdef CFG_ROBO
+    if (ch->etc->unit == 0) {
+	robo_port_stop(ch);
+    }
+#endif				/* CFG_ROBO */
+
+    /* free dma state */
+    for (i = 0; i < NUMTXQ; i++)
+	if (ch->di[i] != NULL) {
+	    dma_detach(ch->di[i]);
+	    ch->di[i] = NULL;
+	}
+
+    /* put the core back into reset */
+    if (ch->sih)
+	si_core_disable(ch->sih, 0);
+
+    ch->etc->mib = NULL;
+
+    /* free si handle */
+    si_detach(ch->sih);
+    ch->sih = NULL;
+
+    /* free vars */
+    if (ch->vars)
+	MFREE(ch->osh, ch->vars, ch->vars_size);
+
+    /* free chip private state */
+    MFREE(ch->osh, ch, sizeof(ch_t));
+}
+
+static void chiplongname(ch_t *ch, char *buf, uint bufsize)
+{
+    char *s;
+
+    switch (ch->etc->deviceid) {
+    case BCM53000_GMAC_ID:
+    default:
+	s = "Broadcom BCM53000 10/100/1000 Mbps Ethernet Controller";
+	break;
+    }
+
+    strncpy(buf, s, bufsize);
+    buf[bufsize - 1] = '\0';
+}
+
+static void chipdump(ch_t *ch, struct bcmstrbuf *b)
+{
+#ifdef BCMDBG
+    int32 i;
+
+    printf("regs 0x%lx etphy 0x%lx ch->intstatus 0x%x intmask 0x%x\n",
+	   (ulong) ch->regs, (ulong) ch->etphy, ch->intstatus,
+	   ch->intmask);
+    printf("\n");
+
+    /* XXX bcm_binit() to move up in chain of functions where b is allocated, when
+     * all sprintf's are replaced by bcm_bprintf's
+     */
+    /* dma engine state */
+    for (i = 0; i < NUMTXQ; i++) {
+	dma_dump(ch->di[i], b, TRUE);
+	printf("\n");
+    }
+
+    /* registers */
+    chipdumpregs(ch, ch->regs, b);
+    printf("\n");
+
+#endif				/* BCMDBG */
+}
+
+#define PRREG(name) printf(#name " 0x%x ", R_REG(ch->osh, &regs->name))
+#define PRMIB(name) printf(#name " 0x%x ", ch->mib.name)
+
+#ifdef BCMDBG
+
+static void
+chipdumpregs(ch_t *ch, gmac0regs_t *regs, struct bcmstrbuf *b)
+{
+    uint phyaddr;
+
+    phyaddr = ch->etc->phyaddr;
+
+    PRREG(devcontrol);
+    PRREG(devstatus);
+    printf("\n");
+    PRREG(biststatus);
+    printf("\n");
+    PRREG(intstatus);
+    PRREG(intmask);
+    PRREG(gptimer);
+    printf("\n");
+    PRREG(rx_ch0_flow_ctrl);
+    PRREG(rx_ch1_flow_ctrl);
+    printf("\n");
+    PRREG(rx_ch2_flow_ctrl);
+    PRREG(rx_ch3_flow_ctrl);
+    PRREG(desc_flow_ctrl_ps_stat);
+    printf("\n");
+    PRREG(intrecvlazy);
+    printf("\n");
+    PRREG(flowctlthresh);
+    PRREG(txqos);
+    PRREG(gmac_idle_cnt_thresh);
+    printf("\n");
+    PRREG(fifoaccessaddr);
+    PRREG(fifoaccessbyte);
+    PRREG(fifoaccessdata);
+    printf("\n");
+    PRREG(irc_cfg);
+    printf("\n");
+    PRREG(erc0_cfg);
+    PRREG(erc1_cfg);
+    PRREG(erc2_cfg);
+    PRREG(erc3_cfg);
+    printf("\n");
+    PRREG(txqctl);
+    PRREG(rxqctl);
+    printf("\n");
+    PRREG(gpioselect);
+    PRREG(gpio_output_en);
+    printf("\n");
+    PRREG(clk_ctl_st);
+    PRREG(pwrctl);
+    printf("\n");
+
+    /* unimac registers */
+    PRREG(core_version);
+    PRREG(ipg_hd_bkp_cntl);
+    printf("\n");
+    PRREG(command_config);
+    printf("\n");
+    PRREG(mac_0);
+    PRREG(mac_1);
+    printf("\n");
+    PRREG(frm_length);
+    PRREG(pause_quant);
+    PRREG(mac_mode);
+    printf("\n");
+    PRREG(tx_ipg_length);
+    PRREG(ts_status_cntrl);
+    PRREG(tx_ts_data);
+    PRREG(pause_control);
+    printf("\n");
+    PRREG(flush_control);
+    PRREG(rxfifo_stat);
+    PRREG(txfifo_stat);
+    printf("\n");
+
+    if (phyaddr != EPHY_NOREG) {
+	/* print a few interesting phy registers */
+	printf("phy0 0x%x phy1 0x%x phy2 0x%x phy3 0x%x\n",
+	       chipphyrd(ch, phyaddr, 0),
+	       chipphyrd(ch, phyaddr, 1),
+	       chipphyrd(ch, phyaddr, 2), chipphyrd(ch, phyaddr, 3));
+	printf("phy4 0x%x phy5 0x%x phy24 0x%x phy25 0x%x\n",
+	       chipphyrd(ch, phyaddr, 4),
+	       chipphyrd(ch, phyaddr, 5),
+	       chipphyrd(ch, phyaddr, 24), chipphyrd(ch, phyaddr, 25));
+    }
+
+}
+#endif				/* BCMDBG */
+
+static void gmac_clearmib(ch_t *ch)
+{
+    volatile uint32 *ptr;
+
+    /* enable clear on read */
+    OR_REG(ch->osh, &ch->regs->devcontrol,
+	   DEVCONTROL_MIB_RESET_ON_READ_MASK);
+
+    for (ptr = &ch->regs->tx_good_octets; ptr <= &ch->regs->rx_cfp_drop;
+	 ptr++) {
+	(void) R_REG(ch->osh, ptr);
+	if (ptr == &ch->regs->tx_pause_pkts)
+	    ptr = ptr + 5;
+    }
+
+    return;
+}
+
+static void gmac_init_reset(ch_t *ch)
+{
+    OR_REG(ch->osh, &ch->regs->command_config,
+	   COMMAND_CONFIG_SW_RESET_MASK);
+    OSL_DELAY(GMAC_RESET_DELAY);
+}
+
+static void gmac_clear_reset(ch_t *ch)
+{
+    AND_REG(ch->osh, &ch->regs->command_config,
+	    ~COMMAND_CONFIG_SW_RESET_MASK);
+    OSL_DELAY(GMAC_RESET_DELAY);
+}
+
+static void gmac_reset(ch_t *ch)
+{
+    uint32 ocmdcfg, cmdcfg;
+
+    /* put the mac in reset */
+    gmac_init_reset(ch);
+
+    /* initialize default config */
+    ocmdcfg = cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    cmdcfg &= ~(COMMAND_CONFIG_TX_ENA_MASK | COMMAND_CONFIG_RX_ENA_MASK |
+		COMMAND_CONFIG_PAUSE_IGNORE_MASK |
+		COMMAND_CONFIG_TX_ADDR_INS_MASK |
+		COMMAND_CONFIG_HD_ENA_MASK |
+		COMMAND_CONFIG_MAC_LOOP_CON_MASK |
+		COMMAND_CONFIG_CNTL_FRM_ENA_MASK |
+		COMMAND_CONFIG_LINE_LOOPBACK_MASK |
+		COMMAND_CONFIG_IGNORE_TX_PAUSE_MASK |
+		COMMAND_CONFIG_PAD_EN_MASK);
+    cmdcfg |=
+	(COMMAND_CONFIG_PROMIS_EN_MASK | COMMAND_CONFIG_PAUSE_FWD_MASK |
+	 COMMAND_CONFIG_NO_LGTH_CHECK_MASK |
+	 COMMAND_CONFIG_CNTL_FRM_ENA_MASK);
+
+    /* GNAT: Keystone_DVT/3853 */
+    /* The bit of COMMAND_CONFIG_ENA_EXT_CONFIG_MASK should be clear */
+    if (ch->etc->flowcntl_mode != FLOW_CTRL_MODE_DISABLE) {
+	cmdcfg &= ~COMMAND_CONFIG_ENA_EXT_CONFIG_MASK;
+    }
+
+    if (cmdcfg != ocmdcfg)
+	W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+}
+
+#ifdef GMAC_PROMISC_BY_CFP
+
+#define SET_CFP_FIELD_PARAM(fld_idx, fld_val, ram, l3_fram, s_id, buf_ptr) { \
+    buf_ptr->field_idx = fld_idx; buf_ptr->field_value = fld_val; \
+    buf_ptr->ram_type = ram; buf_ptr->l3_framing = l3_fram; \
+    buf_ptr->slice_id = s_id;}
+
+
+/* Construct a valid entry with drop action */
+static void
+gmac_cfp_entry_init(ch_t *ch, uint l3_fram, uint slice_id, void *arg)
+{
+    int i;
+    cfp_ioctl_buf_t *cfp_buf_ptr;
+
+    cfp_buf_ptr = (cfp_ioctl_buf_t *) arg;
+
+    for (i = 0; i < CFP_TCAM_ENTRY_WORD; i++) {
+	cfp_buf_ptr->cfp_entry.tcam[i] = 0;
+	cfp_buf_ptr->cfp_entry.tcam_mask[i] = 0;
+    }
+    cfp_buf_ptr->cfp_entry.action = 0;
+
+    /* Create valid entry and drop action */
+    cfp_buf_ptr->entry_idx = 0;
+    SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_VALID, 3, CFP_RAM_TYPE_TCAM,
+			CFP_L3_FRAMING_IPV4, slice_id, cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+
+    SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_VALID, 3, CFP_RAM_TYPE_TCAM_MASK,
+			CFP_L3_FRAMING_IPV4, slice_id, cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+
+    /* Configure the L3 Framming value */
+    SET_CFP_FIELD_PARAM(CFP_FIELD_NONIP_L3_FRAMING, l3_fram,
+			CFP_RAM_TYPE_TCAM, CFP_L3_FRAMING_IPV4, slice_id,
+			cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+    SET_CFP_FIELD_PARAM(CFP_FIELD_NONIP_L3_FRAMING, 0x3,
+			CFP_RAM_TYPE_TCAM_MASK, CFP_L3_FRAMING_IPV4,
+			slice_id, cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+
+    /* set slice id */
+    SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SLICE_ID, slice_id,
+			CFP_RAM_TYPE_TCAM, CFP_L3_FRAMING_IPV4, slice_id,
+			cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+    SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SLICE_ID, 3,
+			CFP_RAM_TYPE_TCAM_MASK, CFP_L3_FRAMING_IPV4,
+			slice_id, cfp_buf_ptr);
+    chipcfpfldwr(ch, (void *) (cfp_buf_ptr));
+
+}
+
+
+/*
+ * Using CFP entries to meet the promiscous mode
+ */
+static void gmac_cfp_promisc(ch_t *ch, bool on)
+{
+    cfp_ioctl_buf_t *cfp_buffer;
+    uint slice_id, start_entry_idx;
+    uint udf_field_idx = 0, field_value, field_mask;
+    uint udf_valid_field_idx = 0;
+    uint i, l3_fram;
+
+    ET_TRACE(("et%d: gamc_cfp_promisc: %d\n", ch->etc->unit, on));
+
+    if (!
+	(cfp_buffer =
+	 (cfp_ioctl_buf_t *) MALLOC(ch->osh, sizeof(cfp_ioctl_buf_t)))) {
+	printf("Error : gamc_cfp_promisc() KMALLOC failed!");
+	return;
+    }
+
+
+    /* Using the last 12 entries */
+    start_entry_idx = CFP_TCAM_NUM - CFP_PROMISC_ENTRY_NUM;
+
+    /* Choose the UDF 0, 1, 2 of SLICE 2 to use */
+    slice_id = 0;
+
+    for (l3_fram = 0; l3_fram <= CFP_L3_FRAMING_NONIP; l3_fram++) {
+	/* Check L3 framing */
+	if ((l3_fram != CFP_L3_FRAMING_IPV4) &&
+	    (l3_fram != CFP_L3_FRAMING_IPV6) &&
+	    (l3_fram != CFP_L3_FRAMING_NONIP)) {
+	    continue;
+	}
+	gmac_cfp_entry_init(ch, l3_fram, slice_id, cfp_buffer);
+
+	/* Configure the UDF offset value and base */
+	for (i = 0; i < 3; i++) {
+	    cfp_buffer->field_idx = i;	/* UDF index */
+	    cfp_buffer->l3_framing = l3_fram;
+	    cfp_buffer->slice_id = slice_id;
+	    cfp_buffer->field_value = (2 * i);	/* offset value */
+	    cfp_buffer->flags = CFP_UDF_OFFSET_BASE_STARTOFFRAME;
+	    chipcfpudfwr(ch, (void *) (cfp_buffer));
+	}
+    }
+
+    /* CFP entries */
+    for (l3_fram = 0; l3_fram <= CFP_L3_FRAMING_NONIP; l3_fram++) {
+	/* Check L3 framing */
+	if ((l3_fram != CFP_L3_FRAMING_IPV4) &&
+	    (l3_fram != CFP_L3_FRAMING_IPV6) &&
+	    (l3_fram != CFP_L3_FRAMING_NONIP)) {
+	    continue;
+	}
+
+	switch (l3_fram) {
+	case CFP_L3_FRAMING_IPV4:
+	    udf_field_idx = CFP_FIELD_IPV4_UDF0;
+	    udf_valid_field_idx = CFP_FIELD_IPV4_UDF0_VLD;
+	    break;
+	case CFP_L3_FRAMING_IPV6:
+	    udf_field_idx = CFP_FIELD_IPV6_UDF0;
+	    udf_valid_field_idx = CFP_FIELD_IPV6_UDF0_VLD;
+	    break;
+	case CFP_L3_FRAMING_NONIP:
+	    udf_field_idx = CFP_FIELD_NONIP_UDF0;
+	    udf_valid_field_idx = CFP_FIELD_NONIP_UDF0_VLD;
+	    break;
+	}
+
+	/* 1. First entry for broadcast and multicast packets pass to CPU */
+	/* Configure the TCAM DATA and MASK to 0x0100 of UDF0 */
+	gmac_cfp_entry_init(ch, l3_fram, slice_id, cfp_buffer);
+	cfp_buffer->entry_idx = start_entry_idx++;
+	/* UDF value */
+	SET_CFP_FIELD_PARAM(udf_field_idx, 0x0100,
+			    CFP_RAM_TYPE_TCAM, l3_fram, slice_id,
+			    cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	SET_CFP_FIELD_PARAM(udf_field_idx, 0x0100,
+			    CFP_RAM_TYPE_TCAM_MASK, l3_fram, slice_id,
+			    cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	/* UDF valid */
+	SET_CFP_FIELD_PARAM(udf_valid_field_idx, 0x1,
+			    CFP_RAM_TYPE_TCAM, l3_fram, slice_id,
+			    cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	SET_CFP_FIELD_PARAM(udf_valid_field_idx, 0x1,
+			    CFP_RAM_TYPE_TCAM_MASK, l3_fram, slice_id,
+			    cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	/* write this entry to CFP */
+	chipcfpwr(ch, (void *) (cfp_buffer));
+
+	/* 2. DA match my MAC address packets will be pass to CPU */
+	if (ch->etc->unit == 1) {
+	    /* Bypass the entry for GMAC 0 */
+	    start_entry_idx++;
+	}
+	gmac_cfp_entry_init(ch, l3_fram, slice_id, cfp_buffer);
+	cfp_buffer->entry_idx = start_entry_idx++;
+	for (i = 0; i < 3; i++) {
+	    field_value = ((ch->etc->perm_etheraddr.octet[(2 * i)] << 8) |
+			   (ch->etc->perm_etheraddr.octet[(2 * i) + 1]));
+	    /* UDF value */
+	    SET_CFP_FIELD_PARAM(udf_field_idx + i, field_value,
+				CFP_RAM_TYPE_TCAM, l3_fram, slice_id,
+				cfp_buffer);
+	    chipcfpfldwr(ch, (void *) (cfp_buffer));
+	    SET_CFP_FIELD_PARAM(udf_field_idx + i, 0xffff,
+				CFP_RAM_TYPE_TCAM_MASK, l3_fram, slice_id,
+				cfp_buffer);
+	    chipcfpfldwr(ch, (void *) (cfp_buffer));
+	    /* UDF valid */
+	    SET_CFP_FIELD_PARAM(udf_valid_field_idx + i, 0x1,
+				CFP_RAM_TYPE_TCAM, l3_fram, slice_id,
+				cfp_buffer);
+	    chipcfpfldwr(ch, (void *) (cfp_buffer));
+	    SET_CFP_FIELD_PARAM(udf_valid_field_idx + i, 0x1,
+				CFP_RAM_TYPE_TCAM_MASK, l3_fram, slice_id,
+				cfp_buffer);
+	    chipcfpfldwr(ch, (void *) (cfp_buffer));
+	}
+	/* Since the source port bitmap is the same for all l3 framing types */
+	/* We use IPv4 format to configure it */
+	SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SRC_PMAP, 0x1 << ch->etc->unit,
+			    CFP_RAM_TYPE_TCAM, CFP_L3_FRAMING_IPV4,
+			    slice_id, cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+
+	SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SRC_PMAP, 0x3,
+			    CFP_RAM_TYPE_TCAM_MASK, CFP_L3_FRAMING_IPV4,
+			    slice_id, cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	/* write this entry to CFP */
+	chipcfpwr(ch, (void *) (cfp_buffer));
+	if (ch->etc->unit == 0) {
+	    /* Bypass the entry for GMAC 1 */
+	    start_entry_idx++;
+	}
+
+	/* 3. Default entry to dop all packets */
+	gmac_cfp_entry_init(ch, l3_fram, slice_id, cfp_buffer);
+	cfp_buffer->entry_idx = start_entry_idx++;
+
+	if (!cfp_promisc[0] && !cfp_promisc[1]) {
+	    /* Alwaye hit */
+	    field_value = 0x3;
+	    field_mask = 0x0;
+	} else if (!cfp_promisc[0]) {
+	    /* port 0 */
+	    field_value = 0x1;
+	    field_mask = 0x3;
+	} else if (!cfp_promisc[1]) {
+	    /* port 1 */
+	    field_value = 0x2;
+	    field_mask = 0x3;
+	} else {
+	    /* Not port 0 and not port 1 */
+	    field_value = 0x0;
+	    field_mask = 0x3;
+	}
+	/* Since the source port bitmap is the same for all l3 framing types */
+	/* We use IPv4 format to configure it */
+	SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SRC_PMAP, field_value,
+			    CFP_RAM_TYPE_TCAM, CFP_L3_FRAMING_IPV4,
+			    slice_id, cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+
+	SET_CFP_FIELD_PARAM(CFP_FIELD_IPV4_SRC_PMAP, field_mask,
+			    CFP_RAM_TYPE_TCAM_MASK, CFP_L3_FRAMING_IPV4,
+			    slice_id, cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	SET_CFP_FIELD_PARAM(CFP_FIELD_ACT_DROP, 1, CFP_RAM_TYPE_ACTION,
+			    l3_fram, slice_id, cfp_buffer);
+	chipcfpfldwr(ch, (void *) (cfp_buffer));
+	/* write this entry to CFP */
+	chipcfpwr(ch, (void *) (cfp_buffer));
+
+    }
+
+    MFREE(ch->osh, cfp_buffer, sizeof(cfp_ioctl_buf_t));
+}
+
+#endif				/* GMAC_PROMISC_BY_CFP */
+
+static void gmac_promisc(ch_t *ch, bool mode)
+{
+#ifndef GMAC_PROMISC_BY_CFP
+    uint32 cmdcfg;
+
+    cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+#endif				/* GMAC_PROMISC_BY_CFP */
+
+    /* put the mac in reset */
+    gmac_init_reset(ch);
+
+#ifdef GMAC_PROMISC_BY_CFP
+    cfp_promisc[ch->etc->unit] = mode;
+    gmac_cfp_promisc(ch, mode);
+
+#else				/* !GMAC_PROMISC_BY_CFP */
+
+    /* enable or disable promiscuous mode */
+    if (mode)
+	cmdcfg |= COMMAND_CONFIG_PROMIS_EN_MASK;
+    else
+	cmdcfg &= ~COMMAND_CONFIG_PROMIS_EN_MASK;
+
+    W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+#endif				/* GMAC_PROMISC_BY_CFP */
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+}
+
+static int gmac_speed(ch_t *ch, uint32 speed)
+{
+    uint32 cmdcfg;
+    uint32 hd_ena = 0;
+
+    switch (speed) {
+    case ET_10HALF:
+	hd_ena = COMMAND_CONFIG_HD_ENA_MASK;
+	/* FALLTHRU */
+
+    case ET_10FULL:
+	speed = 0;
+	break;
+
+    case ET_100HALF:
+	hd_ena = COMMAND_CONFIG_HD_ENA_MASK;
+	/* FALLTHRU */
+
+    case ET_100FULL:
+	speed = 1;
+	break;
+
+    case ET_1000FULL:
+	speed = 2;
+	break;
+
+    case ET_1000HALF:
+	ET_ERROR(("et%d: gmac_speed: supports 1000 mbps full duplex only\n", ch->etc->unit));
+	return FAILURE;
+
+    default:
+	ET_ERROR(("et%d: gmac_speed: speed %d not supported\n",
+		  ch->etc->unit, speed));
+	return FAILURE;
+    }
+
+    cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    /* put mac in reset */
+    gmac_init_reset(ch);
+
+    /* set the speed */
+    cmdcfg &=
+	~(COMMAND_CONFIG_ETH_SPEED_MASK | COMMAND_CONFIG_HD_ENA_MASK);
+    cmdcfg |= ((speed << COMMAND_CONFIG_ETH_SPEED_SHIFT) | hd_ena);
+    W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+
+    return SUCCESS;
+}
+
+static void gmac_macloopback(ch_t *ch, bool on)
+{
+    uint32 ocmdcfg, cmdcfg;
+
+    ocmdcfg = cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    /* put mac in reset */
+    gmac_init_reset(ch);
+
+    /* set/clear the mac loopback mode */
+    if (on)
+	cmdcfg |= COMMAND_CONFIG_LOOP_ENA_MASK;
+    else
+	cmdcfg &= ~COMMAND_CONFIG_LOOP_ENA_MASK;
+
+    if (cmdcfg != ocmdcfg)
+	W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+}
+
+static int gmac_loopback(ch_t *ch, uint32 mode)
+{
+    switch (mode) {
+    case LOOPBACK_MODE_DMA:
+	/* to enable loopback for any channel set the loopback
+	 * enable bit in xmt0control register.
+	 */
+	dma_fifoloopbackenable(ch->di[TX_Q0], TRUE);
+	break;
+
+    case LOOPBACK_MODE_MAC:
+	gmac_macloopback(ch, TRUE);
+	break;
+
+    case LOOPBACK_MODE_NONE:
+	gmac_macloopback(ch, FALSE);
+	/* Disable DMA lookback */
+	dma_fifoloopbackenable(ch->di[TX_Q0], FALSE);
+	break;
+
+    default:
+	ET_ERROR(("et%d: gmac_loopaback: Unknown loopback mode %d\n",
+		  ch->etc->unit, mode));
+	return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+static void gmac_enable(ch_t *ch)
+{
+    uint32 ocmdcfg, cmdcfg, rxqctl;
+    gmac0regs_t *regs;
+
+    regs = ch->regs;
+
+    ocmdcfg = cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    /* put mac in reset */
+    gmac_init_reset(ch);
+
+    cmdcfg |= COMMAND_CONFIG_SW_RESET_MASK;
+
+    /* first deassert rx_ena and tx_ena while in reset */
+    cmdcfg &= ~(COMMAND_CONFIG_RX_ENA_MASK | COMMAND_CONFIG_TX_ENA_MASK);
+    W_REG(ch->osh, &regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+
+    /* enable the mac transmit and receive paths now */
+    OSL_DELAY(2);
+    cmdcfg &= ~COMMAND_CONFIG_SW_RESET_MASK;
+    cmdcfg |= (COMMAND_CONFIG_RX_ENA_MASK | COMMAND_CONFIG_TX_ENA_MASK);
+
+    /* assert rx_ena and tx_ena when out of reset to enable the mac */
+    W_REG(ch->osh, &regs->command_config, cmdcfg);
+
+    /* request ht clock */
+    W_REG(ch->osh, &regs->clk_ctl_st, 0x2);
+
+    /* init the mac data period to 9. this is the optimal value for
+     * gmac to work at all backplane clock speeds
+     */
+    rxqctl = R_REG(ch->osh, &regs->rxqctl);
+    rxqctl &= ~RXQCTL_RESERVED0_MASK;
+    W_REG(ch->osh, &regs->rxqctl,
+	  rxqctl | (RC_MAC_DATA_PERIOD << RXQCTL_RESERVED0_SHIFT));
+
+    return;
+}
+
+static void gmac_txflowcontrol(ch_t *ch, bool on)
+{
+    uint32 cmdcfg;
+
+    cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    /* put the mac in reset */
+    gmac_init_reset(ch);
+
+    /* to enable tx flow control clear the rx pause ignore bit */
+    if (on)
+	cmdcfg &= ~(COMMAND_CONFIG_PAUSE_IGNORE_MASK |
+		    COMMAND_CONFIG_IGNORE_TX_PAUSE_MASK);
+    else
+	cmdcfg |= COMMAND_CONFIG_PAUSE_IGNORE_MASK |
+	    COMMAND_CONFIG_IGNORE_TX_PAUSE_MASK;
+
+    W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+}
+
+static void gmac_miiconfig(ch_t *ch)
+{
+    uint32 devstatus, mode;
+    gmac0regs_t *regs;
+
+    regs = ch->regs;
+
+    if (ch->etc->phyaddr != EPHY_NOREG)
+	return;
+
+    /* Read the devstatus to figure out the configuration
+     * mode of the interface.
+     */
+    devstatus = R_REG(ch->osh, &regs->devstatus);
+    mode = ((devstatus &
+	     DEVSTATUS_MII_MODE_MASK) >> DEVSTATUS_MII_MODE_SHIFT);
+
+    /* Set the speed to 100 if the switch interface is
+     * using mii/rev mii.
+     */
+    if ((mode == 0) || (mode == 1)) {
+	if (ch->etc->forcespeed == ET_AUTO)
+	    gmac_speed(ch, ET_100FULL);
+	else
+	    gmac_speed(ch, ch->etc->forcespeed);
+    } else if ((mode == 2) || (mode == 3)) {
+	if (ch->etc->forcespeed == ET_AUTO)
+	    gmac_speed(ch, ET_1000FULL);
+	else
+	    gmac_speed(ch, ch->etc->forcespeed);
+    }
+}
+
+static void chipreset(ch_t *ch)
+{
+    gmac0regs_t *regs;
+    gmac_commonregs_t *com_regs;
+    uint32 i;
+    uint origidx;
+
+    ET_TRACE(("et%d: chipreset\n", ch->etc->unit));
+
+    regs = ch->regs;
+
+    if (!si_iscoreup(ch->sih)) {
+	if (!ch->etc->nicmode)
+	    si_pci_setup(ch->sih, (1 << si_coreidx(ch->sih)));
+	/* power on reset: reset the enet core */
+	goto chipinreset;
+    }
+
+    /* update software counters before resetting the chip */
+    if (ch->mibgood)
+	chipstatsupd(ch);
+
+    /* reset the tx dma engines */
+    for (i = 0; i < NUMTXQ; i++)
+	if (ch->di[i])
+	    dma_txreset(ch->di[i]);
+
+
+    /* set gmac into loopback mode to ensure no rx traffic */
+    gmac_loopback(ch, LOOPBACK_MODE_MAC);
+    OSL_DELAY(1);
+
+    /* reset the rx dma engine */
+    for (i = 0; i < NUMRXQ; i++) {
+	if (ch->di[i])
+	    dma_rxreset(ch->di[i]);
+    }
+
+    /* clear the multicast filter table */
+    gmac_mf_cleanup(ch);
+
+  chipinreset:
+    /* reset core */
+    si_core_reset(ch->sih, 0, 0);
+
+    /* reset gmac */
+    gmac_reset(ch);
+
+    /* clear mib */
+    gmac_clearmib(ch);
+    ch->mibgood = TRUE;
+
+    /* Drive mdc clock */
+    origidx = si_coreidx(ch->sih);
+    com_regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+    OR_REG(ch->osh, &com_regs->phycontrol,
+	   PHYCONTROL_MDC_TRANSITION_EN_MASK);
+    si_setcoreidx(ch->sih, origidx);
+
+
+    /* Read the devstatus to figure out the configuration mode of
+     * the interface. Set the speed to 100 if the switch interface
+     * is mii/rmii.
+     */
+    gmac_miiconfig(ch);
+
+    /* gmac doesn't have internal phy */
+    chipphyinit(ch, ch->etc->phyaddr);
+
+    /* clear persistent sw intstatus */
+    ch->intstatus = 0;
+}
+
+/*
+ * Lookup a multicast address in the filter hash table.
+ */
+static int gmac_mf_lkup(ch_t *ch, struct ether_addr *mcaddr)
+{
+    mflist_t *ptr;
+
+    /* find the multicast address */
+    for (ptr = ch->mf.bucket[GMAC_MCADDR_HASH(mcaddr)]; ptr != NULL;
+	 ptr = ptr->next) {
+	if (!ETHER_MCADDR_CMP(&ptr->mc_addr, mcaddr))
+	    return (SUCCESS);
+    }
+
+    return FAILURE;
+}
+
+/*
+ * Add a multicast address to the filter hash table.
+ */
+static int gmac_mf_add(ch_t *ch, struct ether_addr *mcaddr)
+{
+    uint32 hash;
+    mflist_t *entry;
+    uint8 mac[ETHER_ADDR_STR_LEN];
+
+    /* Avoid compiler warning if ET_ERROR does nothing */
+    mac[0] = 0;
+
+    /* add multicast addresses only */
+    if (!ETHER_ISMULTI(mcaddr)) {
+	ET_ERROR(("et%d: adding invalid multicast address %s\n",
+		  ch->etc->unit, bcm_ether_ntoa(mcaddr, (char *) mac)));
+	return FAILURE;
+    }
+
+    /* discard duplicate add requests */
+    if (gmac_mf_lkup(ch, mcaddr) == SUCCESS) {
+	ET_ERROR(("et%d: adding duplicate mcast filter entry\n",
+		  ch->etc->unit));
+	return FAILURE;
+    }
+
+    /* allocate memory for list entry */
+    entry = MALLOC(ch->osh, sizeof(mflist_t));
+    if (entry == NULL) {
+		ET_ERROR(("et%d: out of memory allocating mcast filter entry\n",
+		ch->etc->unit));
+		return FAILURE;
+    }
+
+    /* add the entry to the hash bucket */
+    ether_copy(mcaddr, &entry->mc_addr);
+    hash = GMAC_MCADDR_HASH(mcaddr);
+    entry->next = ch->mf.bucket[hash];
+    ch->mf.bucket[hash] = entry;
+
+    return SUCCESS;
+}
+
+/*
+ * Cleanup the multicast filter hash table.
+ */
+static void gmac_mf_cleanup(ch_t *ch)
+{
+    mflist_t *ptr, *next;
+    int32 i;
+
+    for (i = 0; i < GMAC_HASHT_SIZE; i++) {
+	for (ptr = ch->mf.bucket[i]; ptr != NULL; ptr = next) {
+	    next = ptr->next;
+	    MFREE(ch->osh, ptr, sizeof(mflist_t));
+	}
+	ch->mf.bucket[i] = NULL;
+    }
+}
+
+/*
+ * Initialize all the chip registers.  If dma mode, init tx and rx dma engines
+ * but leave the devcontrol tx and rx (fifos) disabled.
+ */
+static void chipinit(ch_t *ch, uint options)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint idx;
+    uint i;
+
+    regs = ch->regs;
+    etc = ch->etc;
+    idx = 0;
+
+    ET_TRACE(("et%d: chipinit\n", etc->unit));;
+
+    /* enable one rx interrupt per received frame */
+    W_REG(ch->osh, &regs->intrecvlazy,
+	  (1 << INTRECVLAZY_FRAME_COUNT_SHIFT));
+
+
+
+    /* flow control mode */
+    chipflowctrlmodeset(ch, etc->flowcntl_mode);
+
+    chipflowctrlautoset(ch, etc->flowcntl_auto_on_thresh,
+			etc->flowcntl_auto_off_thresh);
+
+    chipflowctrlcpuset(ch, etc->flowcntl_cpu_pause_on);
+
+    for (i = 0; i < NUMRXQ; i++) {
+	chipflowctrlrxchanset(ch, i, etc->flowcntl_rx_on_thresh[i],
+			      etc->flowcntl_rx_off_thresh[i]);
+    }
+
+    /* tx qos mode */
+    chiptxqosmodeset(ch, etc->txqos_mode);
+    for (i = 0; i < (NUMTXQ - 1); i++) {
+	chiptxqosweightset(ch, i, etc->txqos_weight[i]);
+    }
+
+    for (i = 0; i < NUM_STAG_TPID; i++) {
+	chiptpidset(ch, i, etc->tpid[i]);
+    }
+
+    /* RX separate header is global for Keystone */
+    if (etc->en_rxsephdr[0]) {
+	chiprxsephdrset(ch, 1);
+    } else {
+	chiprxsephdrset(ch, 0);
+    }
+    for (i = 0; i < NUMRXQ; i++) {
+	dma_rxsephdrctrl(ch->di[i], etc->en_rxsephdr[i],
+			 etc->pkthdr_mem, RXSEPHDRSZ);
+    }
+
+    /* enable/disable promiscuous mode */
+    gmac_promisc(ch, etc->promisc);
+
+    /* Set TX IPG length */
+    W_REG(ch->osh, &regs->tx_ipg_length, 12);
+
+    if (!etc->promisc) {
+	/* set our local address */
+	W_REG(ch->osh, &regs->mac_0,
+	      hton32(*(uint32 *) & etc->cur_etheraddr.octet[0]));
+	W_REG(ch->osh, &regs->mac_1,
+	      hton16(*(uint16 *) & etc->cur_etheraddr.octet[4]));
+
+	/* gmac doesn't have a cam, hence do the multicast address filtering
+	 * in the software
+	 */
+	/* allmulti or a list of discrete multicast addresses */
+	if (!etc->allmulti && etc->nmulticast)
+	    for (i = 0; i < etc->nmulticast; i++)
+		(void) gmac_mf_add(ch, &etc->multicast[i]);
+    }
+
+    /* optionally enable mac-level loopback */
+    if (etc->loopbk == LOOPBACK_MODE_MAC)
+	gmac_loopback(ch, LOOPBACK_MODE_MAC);
+    else if (etc->loopbk == LOOPBACK_MODE_DMA)
+	gmac_loopback(ch, LOOPBACK_MODE_DMA);
+    else
+	gmac_loopback(ch, LOOPBACK_MODE_NONE);
+
+    /* set max frame lengths - account for possible vlan tag */
+    W_REG(ch->osh, &regs->frm_length, ETHER_MAX_LEN + 32);
+
+    /*
+     * Optionally, disable phy autonegotiation and force our speed/duplex
+     * or constrain our advertised capabilities.
+     */
+    if (etc->forcespeed != ET_AUTO) {
+	gmac_speed(ch, etc->forcespeed);
+	chipphyforce(ch, etc->phyaddr);
+    } else if (etc->advertise && etc->needautoneg)
+	chipphyadvertise(ch, etc->phyaddr);
+
+    if (options & ET_INIT_FULL) {
+	/* initialize the tx and rx dma channels */
+	for (i = 0; i < NUMTXQ; i++)
+	    dma_txinit(ch->di[i]);
+
+	for (i = 0; i < NUMRXQ; i++) {
+	    dma_rxinit(ch->di[i]);
+	    /* post dma receive buffers */
+	    dma_rxfill(ch->di[i]);
+	}
+
+	/* lastly, enable interrupts */
+	if (options & ET_INIT_INTRON)
+	    et_intrson(etc->et);
+    } else
+	dma_rxenable(ch->di[RX_Q0]);
+
+    /* turn on the emac */
+    gmac_enable(ch);
+}
+
+/* dma transmit */
+static bool chiptx(ch_t *ch, void *p0)
+{
+    int error, len;
+    uint32 q = TX_Q0;
+
+    ET_TRACE(("et%d: chiptx\n", ch->etc->unit));
+    ET_LOG("et%d: chiptx", ch->etc->unit, 0);
+
+    len = PKTLEN(ch->osh, p0);
+
+    /* check tx max length */
+    if (len > (ETHER_MAX_LEN + 32)) {
+	ET_ERROR(("et%d: chiptx: max frame length exceeded\n",
+		  ch->etc->unit));
+	return FALSE;
+    }
+
+    /* gmac rev 0 workaround:  unimac can only transmit frames of
+     * length 17 bytes or greater. so pad the frame and send a
+     * 17 byte frame. to do the padding just modify the packet
+     * length that we provide to the dma. unimac does the extra
+     * padding * required to send 64 byte frames.
+     */
+    if ((len < GMAC_MIN_FRAMESIZE) && (ch->etc->corerev == 0)) {
+	PKTSETLEN(ch->osh, p0, GMAC_MIN_FRAMESIZE);
+    }
+
+    /* queue the packet based on its priority */
+    if (ch->etc->qos)
+	q = etc_up2tc(PKTPRIO(p0));
+
+    ASSERT(q < NUMTXQ);
+    error = dma_txfast(ch->di[q], p0, TRUE);
+
+    /* set back the orig length */
+    PKTSETLEN(ch->osh, p0, len);
+
+    if (error) {
+	ET_ERROR(("et%d: chiptx: out of txds\n", ch->etc->unit));
+	ch->etc->txnobuf++;
+	return FALSE;
+    }
+
+    return TRUE;
+}
+
+/* reclaim completed transmit descriptors and packets */
+static void chiptxreclaim(ch_t *ch, bool forceall)
+{
+    int32 i;
+
+    ET_TRACE(("et%d: chiptxreclaim\n", ch->etc->unit));
+
+    for (i = 0; i < NUMTXQ; i++) {
+	dma_txreclaim(ch->di[i], forceall);
+	ch->intstatus &= ~(INTMASK_XMT0INTERRUPT_MASK << i);
+    }
+}
+
+/* dma receive: returns a pointer to the next frame received, or NULL if there are no more */
+static void *chiprx(ch_t *ch)
+{
+    void *p;
+    struct ether_addr *da;
+    int i;
+
+    ET_TRACE(("et%d: chiprx\n", ch->etc->unit));
+    ET_LOG("et%d: chiprx", ch->etc->unit, 0);
+
+    /* gmac doesn't have a cam to do address filtering. so we implement
+     * the multicast address filtering here.
+     */
+    /* CHECK ME: should add other 3 rx queue checking */
+    for (i = 0; i < NUMRXQ; i++) {
+	while ((p = dma_rx(ch->di[NUMRXQ - i - 1])) != NULL) {
+	    /* skip the rx header */
+	    PKTPULL(ch->osh, p, HWRXOFF);
+
+	    /* do filtering only for multicast packets when allmulti is false */
+	    da = (struct ether_addr *) PKTDATA(ch->osh, p);
+	    if (!ETHER_ISMULTI(da) || ch->etc->allmulti ||
+		(gmac_mf_lkup(ch, da) == SUCCESS) || ETHER_ISBCAST(da)) {
+		PKTPUSH(ch->osh, p, HWRXOFF);
+		return (p);
+	    }
+
+	    PKTFREE(ch->osh, p, FALSE, ch->etc->pkt_mem);
+	}
+    }
+
+    ch->intstatus &=
+	~(INTMASK_RCVINTERRUPT_0_MASK | INTMASK_RCVINTERRUPT_1_MASK |
+	  INTMASK_RCVINTERRUPT_2_MASK | INTMASK_RCVINTERRUPT_3_MASK);
+
+    for (i = 0; i < NUMRXQ; i++) {
+	/* post more rx buffers since we consumed a few */
+	dma_rxfill(ch->di[i]);
+    }
+
+    return (NULL);
+}
+
+/* reclaim completed dma receive descriptors and packets */
+static void chiprxreclaim(ch_t *ch)
+{
+    int32 i;
+
+    ET_TRACE(("et%d: chiprxreclaim\n", ch->etc->unit));
+    for (i = 0; i < NUMRXQ; i++) {
+	dma_rxreclaim(ch->di[i]);
+	ch->intstatus &= ~(INTMASK_RCVINTERRUPT_0_MASK << i);
+    }
+}
+
+/* allocate and post dma receive buffers */
+static void chiprxfill(ch_t *ch)
+{
+    int32 i;
+    ET_TRACE(("et%d: chiprxfill\n", ch->etc->unit));
+    ET_LOG("et%d: chiprx", ch->etc->unit, 0);
+    for (i = 0; i < NUMRXQ; i++) {
+	dma_rxfill(ch->di[i]);
+    }
+}
+
+/* get current and pending interrupt events */
+static int chipgetintrevents(ch_t *ch, bool in_isr)
+{
+    uint32 intstatus;
+    int events;
+
+    events = 0;
+
+    /* read the interrupt status register */
+    intstatus = R_REG(ch->osh, &ch->regs->intstatus);
+
+    /* defer unsolicited interrupts */
+    intstatus &= (in_isr ? ch->intmask : DEF_INTMASK);
+
+    if (intstatus != 0)
+	events = INTR_NEW;
+
+    /* or new bits into persistent intstatus */
+    intstatus = (ch->intstatus |= intstatus);
+
+    /* return if no events */
+    if (intstatus == 0)
+	return 0;
+
+    /* convert chip-specific intstatus bits into generic intr event bits */
+    if (intstatus &
+	(INTMASK_RCVINTERRUPT_0_MASK | INTMASK_RCVINTERRUPT_1_MASK |
+	 INTMASK_RCVINTERRUPT_2_MASK | INTMASK_RCVINTERRUPT_3_MASK))
+	events |= INTR_RX;
+    if (intstatus &
+	(INTMASK_XMT0INTERRUPT_MASK | INTMASK_XMT1INTERRUPT_MASK |
+	 INTMASK_XMT2INTERRUPT_MASK | INTMASK_XMT3INTERRUPT_MASK))
+	events |= INTR_TX;
+    if (intstatus & I_ERRORS)
+	events |= INTR_ERROR;
+
+    return events;
+}
+
+/* enable chip interrupts */
+static void chipintrson(ch_t *ch)
+{
+    ch->intmask = DEF_INTMASK;
+    W_REG(ch->osh, &ch->regs->intmask, ch->intmask);
+}
+
+/* disable chip interrupts */
+static void chipintrsoff(ch_t *ch)
+{
+    /* disable further interrupts from gmac */
+    W_REG(ch->osh, &ch->regs->intmask, 0);
+    (void) R_REG(ch->osh, &ch->regs->intmask);	/* sync readback */
+    ch->intmask = 0;
+
+    /* clear the interrupt conditions */
+    W_REG(ch->osh, &ch->regs->intstatus, ch->intstatus);
+}
+
+/* return true of caller should re-initialize, otherwise false */
+static bool chiperrors(ch_t *ch)
+{
+    uint32 intstatus;
+    etc_info_t *etc;
+
+    etc = ch->etc;
+
+    intstatus = ch->intstatus;
+    ch->intstatus &= ~(I_ERRORS);
+
+    ET_TRACE(("et%d: chiperrors: intstatus 0x%x\n", etc->unit, intstatus));
+
+    if (intstatus & INTMASK_PCIDESCERROR_MASK) {
+	ET_ERROR(("et%d: descriptor error\n", etc->unit));
+	etc->dmade++;
+    }
+
+    if (intstatus & INTMASK_PCIDATAERROR_MASK) {
+	ET_ERROR(("et%d: data error\n", etc->unit));
+	etc->dmada++;
+    }
+
+    if (intstatus & INTMASK_DESCERROR_MASK) {
+	ET_ERROR(("et%d: descriptor protocol error\n", etc->unit));
+	etc->dmape++;
+    }
+
+    if (intstatus & (INTMASK_RCVDESCUF_0_MASK | INTMASK_RCVDESCUF_1_MASK
+		     | INTMASK_RCVDESCUF_2_MASK |
+		     INTMASK_RCVDESCUF_3_MASK)) {
+	ET_ERROR(("et%d: receive descriptor underflow\n", etc->unit));
+	etc->rxdmauflo++;
+    }
+
+    if (intstatus & INTMASK_RCVFIFOOVERFLOW_MASK) {
+	ET_ERROR(("et%d: receive fifo overflow\n", etc->unit));
+	etc->rxoflo++;
+    }
+
+    if (intstatus & INTMASK_XMTFIFOUNDERFLOW_MASK) {
+	ET_ERROR(("et%d: transmit fifo underflow\n", etc->unit));
+	etc->txuflo++;
+    }
+
+    /* if overflows or decriptors underflow, don't report it
+     * as an error and  provoque a reset
+     */
+    /* if (intstatus & ~(I_RDU) & I_ERRORS) */
+    if (intstatus & I_ERRORS)
+	return TRUE;
+
+    return FALSE;
+}
+
+static void chipstatsupd(ch_t *ch)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    volatile uint32 *s;
+    uint32 *d;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    /* read the mib counters and update the driver maintained software
+     * counters.
+     */
+    OR_REG(ch->osh, &regs->devcontrol, DEVCONTROL_MIB_RESET_ON_READ_MASK);
+    for (s = &regs->tx_good_octets, d = &ch->mib.tx_good_octets;
+	 s <= &regs->rx_cfp_drop; s++, d++) {
+	*d += R_REG(ch->osh, s);
+	if (s == &ch->regs->tx_pause_pkts) {
+	    s = s + 5;
+	    d = d + 5;
+	}
+    }
+
+
+    /*
+     * Aggregate transmit and receive errors that probably resulted
+     * in the loss of a frame are computed on the fly.
+     *
+     * We seem to get lots of tx_carrier_lost errors when flipping
+     * speed modes so don't count these as tx errors.
+     *
+     * Arbitrarily lump the non-specific dma errors as tx errors.
+     */
+    etc->txerror = ch->mib.tx_jabber_pkts + ch->mib.tx_oversize_pkts
+	+ ch->mib.tx_underruns + ch->mib.tx_excessive_cols
+	+ ch->mib.tx_late_cols + etc->txnobuf + etc->dmade
+	+ etc->dmada + etc->dmape + etc->txuflo;
+    etc->rxerror = ch->mib.rx_jabber_pkts + ch->mib.rx_oversize_pkts
+	+ ch->mib.rx_missed_pkts + ch->mib.rx_align_errs
+	+ ch->mib.rx_undersize + ch->mib.rx_crc_errs
+	+ ch->mib.rx_symbol_errs
+	+ etc->rxnobuf + etc->rxdmauflo + etc->rxoflo + etc->rxbadlen;
+}
+
+static void chipdumpmib(ch_t *ch, char *buf)
+{
+    /* mib registers */
+    PRMIB(tx_good_octets);
+    PRMIB(tx_good_octets_high);
+    PRMIB(tx_good_pkts);
+    printf("\n");
+    PRMIB(tx_octets);
+    PRMIB(tx_octets_high);
+    PRMIB(tx_pkts);
+    printf("\n");
+    PRMIB(tx_broadcast_pkts);
+    PRMIB(tx_multicast_pkts);
+    PRMIB(tx_uni_pkts);
+    printf("\n");
+    PRMIB(tx_len_64);
+    PRMIB(tx_len_65_to_127);
+    PRMIB(tx_len_128_to_255);
+    printf("\n");
+    PRMIB(tx_len_256_to_511);
+    PRMIB(tx_len_512_to_1023);
+    PRMIB(tx_len_1024_to_max);
+    printf("\n");
+    PRMIB(tx_len_max_to_jumbo);
+    printf("\n");
+    PRMIB(tx_jabber_pkts);
+    PRMIB(tx_oversize_pkts);
+    PRMIB(tx_fragment_pkts);
+    printf("\n");
+    PRMIB(tx_underruns);
+    PRMIB(tx_total_cols);
+    PRMIB(tx_single_cols);
+    printf("\n");
+    PRMIB(tx_multiple_cols);
+    PRMIB(tx_excessive_cols);
+    PRMIB(tx_late_cols);
+    printf("\n");
+    PRMIB(tx_defered);
+    PRMIB(tx_pause_pkts);
+    printf("\n");
+
+    PRMIB(rx_good_octets);
+    PRMIB(rx_good_octets_high);
+    PRMIB(rx_good_pkts);
+    printf("\n");
+    PRMIB(rx_octets);
+    PRMIB(rx_octets_high);
+    PRMIB(rx_pkts);
+    printf("\n");
+    PRMIB(rx_broadcast_pkts);
+    PRMIB(rx_multicast_pkts);
+    PRMIB(rx_uni_pkts);
+    printf("\n");
+    PRMIB(rx_len_64);
+    PRMIB(rx_len_65_to_127);
+    PRMIB(rx_len_128_to_255);
+    printf("\n");
+    PRMIB(rx_len_256_to_511);
+    PRMIB(rx_len_512_to_1023);
+    PRMIB(rx_len_1024_to_max);
+    printf("\n");
+    PRMIB(rx_len_max_to_jumbo);
+    printf("\n");
+    PRMIB(rx_jabber_pkts);
+    PRMIB(rx_oversize_pkts);
+    PRMIB(rx_fragment_pkts);
+    printf("\n");
+    PRMIB(rx_missed_pkts);
+    PRMIB(rx_undersize);
+    printf("\n");
+    PRMIB(rx_crc_errs);
+    PRMIB(rx_align_errs);
+    PRMIB(rx_symbol_errs);
+    printf("\n");
+    PRMIB(rx_pause_pkts);
+    PRMIB(rx_nonpause_pkts);
+    printf("\n");
+    PRMIB(rxq0_irc_drop);
+    PRMIB(rxq1_irc_drop);
+    PRMIB(rxq2_irc_drop);
+    PRMIB(rxq3_irc_drop);
+    printf("\n");
+    PRMIB(rx_cfp_drop);
+    printf("\n");
+}
+
+static void chipenablepme(ch_t *ch)
+{
+    return;
+}
+
+static void chipdisablepme(ch_t *ch)
+{
+    return;
+}
+
+static void chipduplexupd(ch_t *ch)
+{
+    uint32 cmdcfg;
+    int32 duplex, speed;
+
+    cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+
+    /* check if duplex mode changed */
+    if (ch->etc->duplex && (cmdcfg & COMMAND_CONFIG_HD_ENA_MASK))
+	duplex = 0;
+    else if (!ch->etc->duplex
+	     && ((cmdcfg & COMMAND_CONFIG_HD_ENA_MASK) == 0))
+	duplex = COMMAND_CONFIG_HD_ENA_MASK;
+    else
+	duplex = -1;
+
+    /* check if the speed changed */
+    speed = ((cmdcfg & COMMAND_CONFIG_ETH_SPEED_MASK)
+	     >> COMMAND_CONFIG_ETH_SPEED_SHIFT);
+    if ((ch->etc->speed == 1000) && (speed != 2))
+	speed = 2;
+    else if ((ch->etc->speed == 100) && (speed != 1))
+	speed = 1;
+    else if ((ch->etc->speed == 10) && (speed != 0))
+	speed = 0;
+    else
+	speed = -1;
+
+    /* no duplex or speed change required */
+    if ((speed == -1) && (duplex == -1))
+	return;
+
+    /* update the speed */
+    if (speed != -1) {
+	cmdcfg &= ~COMMAND_CONFIG_ETH_SPEED_MASK;
+	cmdcfg |= (speed << COMMAND_CONFIG_ETH_SPEED_SHIFT);
+    }
+
+    /* update the duplex mode */
+    if (duplex != -1) {
+	cmdcfg &= ~COMMAND_CONFIG_HD_ENA_MASK;
+	cmdcfg |= duplex;
+    }
+
+    ET_TRACE(("chipduplexupd: updating speed & duplex %x\n", cmdcfg));
+
+    /* put mac in reset */
+    gmac_init_reset(ch);
+
+    W_REG(ch->osh, &ch->regs->command_config, cmdcfg);
+
+    /* bring mac out of reset */
+    gmac_clear_reset(ch);
+}
+
+static uint16 chipphyrd(ch_t *ch, uint phyaddr, uint reg)
+{
+    uint32 tmp;
+    uint origidx;
+    gmac_commonregs_t *regs;
+
+    ASSERT(phyaddr < MAXEPHY);
+    ASSERT(reg < MAXPHYREG);
+
+    if (phyaddr == EPHY_NOREG) {
+	ET_ERROR(("et%d: chipphyrd: no phy\n", ch->etc->unit));
+	return 0xffff;
+    }
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    /* set phyaccess for read/write */
+    W_REG(ch->osh, &regs->phyaccess,
+	  (PHYACCESS_TRIGGER_MASK |
+	   (phyaddr << PHYACCESS_CPU_PHY_ADDR_SHIFT) | (reg <<
+							PHYACCESS_CPU_REG_ADDR_SHIFT)));
+
+    /* wait for it to complete */
+    SPINWAIT((R_REG(ch->osh, &regs->phyaccess) & PHYACCESS_TRIGGER_MASK),
+	     1000);
+    tmp = R_REG(ch->osh, &regs->phyaccess);
+    if (tmp & PHYACCESS_TRIGGER_MASK) {
+	ET_ERROR(("et%d: chipphyrd: did not complete\n", ch->etc->unit));
+	tmp = 0xffff;
+    }
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return (tmp & PHYACCESS_ACC_DATA_MASK);
+}
+
+static void chipphywr(ch_t *ch, uint phyaddr, uint reg, uint16 v)
+{
+    uint origidx;
+    gmac_commonregs_t *regs;
+
+    ASSERT(phyaddr < MAXEPHY);
+    ASSERT(reg < MAXPHYREG);
+
+    if (phyaddr == EPHY_NOREG)
+	return;
+
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    /* set phyaccess for read/write */
+    W_REG(ch->osh, &regs->phyaccess,
+	  (PHYACCESS_TRIGGER_MASK | PHYACCESS_WR_CMD_MASK |
+	   (phyaddr << PHYACCESS_CPU_PHY_ADDR_SHIFT) |
+	   (reg << PHYACCESS_CPU_REG_ADDR_SHIFT) | v));
+
+    /* wait for it to complete */
+    SPINWAIT((R_REG(ch->osh, &regs->phyaccess) & PHYACCESS_TRIGGER_MASK),
+	     1000);
+    if (R_REG(ch->osh, &regs->phyaccess) & PHYACCESS_TRIGGER_MASK) {
+	ET_ERROR(("et%d: chipphywr: did not complete\n", ch->etc->unit));
+    }
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+}
+
+static void chipphyor(ch_t *ch, uint phyaddr, uint reg, uint16 v)
+{
+    uint16 tmp;
+
+    tmp = chipphyrd(ch, phyaddr, reg);
+    tmp |= v;
+    chipphywr(ch, phyaddr, reg, tmp);
+}
+
+static void chipphyreset(ch_t *ch, uint phyaddr)
+{
+    ASSERT(phyaddr < MAXEPHY);
+
+    if (phyaddr == EPHY_NOREG)
+	return;
+
+    chipphywr(ch, phyaddr, 0, CTL_RESET);
+    OSL_DELAY(100);
+    if (chipphyrd(ch, phyaddr, 0) & CTL_RESET) {
+	ET_ERROR(("et%d: chipphyreset: reset not complete\n",
+		  ch->etc->unit));
+    }
+
+    chipphyinit(ch, phyaddr);
+}
+
+static void chipphyinit(ch_t *ch, uint phyaddr)
+{
+    if (phyaddr == EPHY_NOREG)
+	return;
+
+    ET_TRACE(("et%d: chipphyinit: phyaddr %d\n", ch->etc->unit, phyaddr));
+}
+
+static void chipphyforce(ch_t *ch, uint phyaddr)
+{
+    etc_info_t *etc;
+    uint16 ctl;
+
+    ASSERT(phyaddr < MAXEPHY);
+
+    if (phyaddr == EPHY_NOREG)
+	return;
+
+    etc = ch->etc;
+
+    if (etc->forcespeed == ET_AUTO)
+	return;
+
+    ctl = chipphyrd(ch, phyaddr, 0);
+    ctl &= ~(CTL_SPEED | CTL_SPEED_MSB | CTL_ANENAB | CTL_DUPLEX);
+
+    switch (etc->forcespeed) {
+    case ET_10HALF:
+	break;
+
+    case ET_10FULL:
+	ctl |= CTL_DUPLEX;
+	break;
+
+    case ET_100HALF:
+	ctl |= CTL_SPEED_100;
+	break;
+
+    case ET_100FULL:
+	ctl |= (CTL_SPEED_100 | CTL_DUPLEX);
+	break;
+
+    case ET_1000FULL:
+	ctl |= (CTL_SPEED_1000 | CTL_DUPLEX);
+	break;
+    }
+
+    chipphywr(ch, phyaddr, 0, ctl);
+}
+
+/* set selected capability bits in autonegotiation advertisement */
+static void chipphyadvertise(ch_t *ch, uint phyaddr)
+{
+    etc_info_t *etc;
+    uint16 adv, adv2;
+
+    ASSERT(phyaddr < MAXEPHY);
+
+    if (phyaddr == EPHY_NOREG)
+	return;
+
+    etc = ch->etc;
+
+    if ((etc->forcespeed != ET_AUTO) || !etc->needautoneg)
+	return;
+
+    ASSERT(etc->advertise);
+
+    /* reset our advertised capabilitity bits */
+    adv = chipphyrd(ch, phyaddr, 4);
+    adv &= ~(ADV_100FULL | ADV_100HALF | ADV_10FULL | ADV_10HALF);
+    adv |= etc->advertise;
+    chipphywr(ch, phyaddr, 4, adv);
+    adv2 = chipphyrd(ch, phyaddr, 9);
+    adv2 &= ~(ADV_1000FULL | ADV_1000HALF);
+    adv2 |= etc->advertise2;
+    chipphywr(ch, phyaddr, 9, adv2);
+
+    ET_TRACE(("et%d: chipphyadvertise: phyaddr %d adv %x adv2 %x phyad0 %x\n", ch->etc->unit, phyaddr, adv, adv2, chipphyrd(ch, phyaddr, 0)));
+
+    /* restart autonegotiation */
+    chipphyor(ch, phyaddr, 0, CTL_RESTART);
+
+    etc->needautoneg = FALSE;
+}
+
+static int chipcfprd(ch_t *ch, void *arg)
+{
+    uint32 tmp, i;
+    uint origidx;
+    gmac_commonregs_t *regs;
+    cfp_ioctl_buf_t *buf;
+
+    ET_TRACE(("et%d: chipcfprd\n", ch->etc->unit));
+
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    ASSERT(buf->entry_idx < CFP_TCAM_NUM);
+
+    /* Read tcam */
+    tmp = R_REG(ch->osh, &regs->cfp_access);
+    tmp &= ~(CFP_ACCESS_OP_START_DONE_MASK | CFP_ACCESS_OP_SEL_MASK |
+	     CFP_ACCESS_RAM_SEL_MASK | CFP_ACCESS_XCESS_ADDR_MASK);
+    tmp |= (buf->entry_idx << CFP_ACCESS_XCESS_ADDR_SHIFT) |
+	(CFP_RAM_HW_TCAM << CFP_ACCESS_RAM_SEL_SHIFT) |
+	(CFP_TCAM_OP_READ << CFP_ACCESS_OP_SEL_SHIFT) |
+	CFP_ACCESS_OP_START_DONE_MASK;
+    W_REG(ch->osh, &regs->cfp_access, tmp);
+
+    /* wait complete */
+    for (i = 0; i < CFP_RETRY_TIME; i++) {
+	tmp = R_REG(ch->osh, &regs->cfp_access);
+	if (!(tmp & CFP_ACCESS_OP_START_DONE_MASK)) {
+	    break;
+	}
+    }
+    if (i >= CFP_RETRY_TIME) {
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return TIMEOUT;
+    }
+
+
+    for (i = 0; i < CFP_TCAM_ENTRY_WORD; i++) {
+	buf->cfp_entry.tcam[i] =
+	    R_REG(ch->osh, (&(regs->cfp_tcam_data0) + i));
+	buf->cfp_entry.tcam_mask[i] =
+	    R_REG(ch->osh, (&(regs->cfp_tcam_mask0) + i));
+    }
+
+    /* Read Action ram */
+    tmp = R_REG(ch->osh, &regs->cfp_access);
+    tmp &= ~(CFP_ACCESS_OP_START_DONE_MASK | CFP_ACCESS_OP_SEL_MASK |
+	     CFP_ACCESS_RAM_SEL_MASK | CFP_ACCESS_XCESS_ADDR_MASK);
+    tmp |= (buf->entry_idx << CFP_ACCESS_XCESS_ADDR_SHIFT) |
+	(CFP_RAM_HW_ACTION << CFP_ACCESS_RAM_SEL_SHIFT) |
+	(CFP_TCAM_OP_READ << CFP_ACCESS_OP_SEL_SHIFT) |
+	CFP_ACCESS_OP_START_DONE_MASK;
+    W_REG(ch->osh, &regs->cfp_access, tmp);
+
+    /* wait complete */
+    for (i = 0; i < CFP_RETRY_TIME; i++) {
+	tmp = R_REG(ch->osh, &regs->cfp_access);
+	if (!(tmp & CFP_ACCESS_OP_START_DONE_MASK)) {
+	    break;
+	}
+    }
+    if (i >= CFP_RETRY_TIME) {
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return TIMEOUT;
+    }
+
+    buf->cfp_entry.action = R_REG(ch->osl, &regs->cfp_action_data);
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return SUCCESS;
+}
+
+static int chipcfpwr(ch_t *ch, void *arg)
+{
+    uint32 tmp, i;
+    uint origidx;
+    gmac_commonregs_t *regs;
+    cfp_ioctl_buf_t *buf;
+
+    ET_TRACE(("et%d: chipcfpwr\n", ch->etc->unit));
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    ASSERT(buf->entry_idx < CFP_TCAM_NUM);
+
+    /* Write tcam */
+
+    for (i = 0; i < CFP_TCAM_ENTRY_WORD; i++) {
+	W_REG(ch->osh, (&(regs->cfp_tcam_data0) + i),
+	      buf->cfp_entry.tcam[i]);
+	W_REG(ch->osh, (&(regs->cfp_tcam_mask0) + i),
+	      buf->cfp_entry.tcam_mask[i]);
+    }
+
+    tmp = R_REG(ch->osh, &regs->cfp_access);
+    tmp &= ~(CFP_ACCESS_OP_START_DONE_MASK | CFP_ACCESS_OP_SEL_MASK |
+	     CFP_ACCESS_RAM_SEL_MASK | CFP_ACCESS_XCESS_ADDR_MASK);
+    tmp |= (buf->entry_idx << CFP_ACCESS_XCESS_ADDR_SHIFT) |
+	(CFP_RAM_HW_TCAM << CFP_ACCESS_RAM_SEL_SHIFT) |
+	(CFP_TCAM_OP_WRITE << CFP_ACCESS_OP_SEL_SHIFT) |
+	CFP_ACCESS_OP_START_DONE_MASK;
+    W_REG(ch->osh, &regs->cfp_access, tmp);
+
+    /* wait complete */
+    for (i = 0; i < CFP_RETRY_TIME; i++) {
+	tmp = R_REG(ch->osh, &regs->cfp_access);
+	if (!(tmp & CFP_ACCESS_OP_START_DONE_MASK)) {
+	    break;
+	}
+    }
+    if (i >= CFP_RETRY_TIME) {
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return TIMEOUT;
+    }
+
+    /* Write Action ram */
+    W_REG(ch->osl, &regs->cfp_action_data, buf->cfp_entry.action);
+
+    tmp = R_REG(ch->osh, &regs->cfp_access);
+    tmp &= ~(CFP_ACCESS_OP_START_DONE_MASK | CFP_ACCESS_OP_SEL_MASK |
+	     CFP_ACCESS_RAM_SEL_MASK | CFP_ACCESS_XCESS_ADDR_MASK);
+    tmp |= (buf->entry_idx << CFP_ACCESS_XCESS_ADDR_SHIFT) |
+	(CFP_RAM_HW_ACTION << CFP_ACCESS_RAM_SEL_SHIFT) |
+	(CFP_TCAM_OP_WRITE << CFP_ACCESS_OP_SEL_SHIFT) |
+	CFP_ACCESS_OP_START_DONE_MASK;
+    W_REG(ch->osh, &regs->cfp_access, tmp);
+
+    /* wait complete */
+    for (i = 0; i < CFP_RETRY_TIME; i++) {
+	tmp = R_REG(ch->osh, &regs->cfp_access);
+	if (!(tmp & CFP_ACCESS_OP_START_DONE_MASK)) {
+	    break;
+	}
+    }
+    if (i >= CFP_RETRY_TIME) {
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return TIMEOUT;
+    }
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return SUCCESS;
+}
+
+
+#define GET_FIELD_REG32(r, shift, len) (r & (((0x1 << len) - 1) << shift))
+#define SET_FIELD_REG32(r, shift, len, v) { \
+    r &= ~(((0x1 << len) - 1) << shift); \
+    r |= (v << shift); \
+}
+
+#define GET_FIELD_LEN(f)   (cfp_field_info[f].len)
+#define GET_FIELD_SHIFT(f)  (cfp_field_info[f].shift)
+
+static cfp_field_info_t cfp_field_info[CFP_FIELD_COUNT + 1] =
+    CFP_FIELD_INFO;
+static uint rx_rate_map[RX_RATE_MAX_MAP_VALUE + 1] = RX_RATE_VALUE_MAPPING;
+
+static int chipcfpfldrd(ch_t *ch, void *arg)
+{
+    cfp_ioctl_buf_t *buf;
+    uint32 fld_len, fld_shift, fld_base, temp;
+    int cross_32bit = 0;
+
+    ET_TRACE(("et%d: chipcfpfldrd\n", ch->etc->unit));
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+    /* Get the length, shift and base location of the specified field */
+    fld_len = GET_FIELD_LEN(buf->field_idx);
+    fld_shift = GET_FIELD_SHIFT(buf->field_idx) % 32;
+    fld_base = GET_FIELD_SHIFT(buf->field_idx) / 32;
+
+    /* Check if this field cross over 32 bit boundary */
+    if ((fld_len + fld_shift) > 32) {
+	cross_32bit = 1;
+    }
+
+    if (cross_32bit == 0) {
+	switch (buf->ram_type) {
+	case CFP_RAM_TYPE_TCAM:
+	    /* Get the value of field */
+	    buf->field_value =
+		GET_FIELD_REG32(buf->cfp_entry.tcam[fld_base], fld_shift,
+				fld_len);
+	    buf->field_value = buf->field_value >> fld_shift;
+	    break;
+	case CFP_RAM_TYPE_TCAM_MASK:
+	    /* Get the value of field */
+	    buf->field_value =
+		GET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base],
+				fld_shift, fld_len);
+	    buf->field_value = buf->field_value >> fld_shift;
+	    break;
+	case CFP_RAM_TYPE_ACTION:
+	    /* Get the value of field */
+	    buf->field_value =
+		GET_FIELD_REG32(buf->cfp_entry.action, fld_shift, fld_len);
+	    buf->field_value = buf->field_value >> fld_shift;
+	    break;
+	default:
+	    return FAILURE;
+	}
+    } else {			/* cross over 32 bit boundary */
+	switch (buf->ram_type) {
+	case CFP_RAM_TYPE_TCAM:
+	    /* Get the value of in the base location */
+	    temp =
+		GET_FIELD_REG32(buf->cfp_entry.tcam[fld_base], fld_shift,
+				(32 - fld_shift));
+	    temp = temp >> fld_shift;
+	    /* Get the value of in the (base+1) location */
+	    buf->field_value =
+		GET_FIELD_REG32(buf->cfp_entry.tcam[fld_base + 1], 0,
+				(fld_len + fld_shift - 32));
+	    buf->field_value = buf->field_value << (32 - fld_shift);
+	    /* Combine them */
+	    buf->field_value |= temp;
+	    break;
+	case CFP_RAM_TYPE_TCAM_MASK:
+	    /* Get the value of in the base location */
+	    temp =
+		GET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base],
+				fld_shift, (32 - fld_shift));
+	    temp = temp >> fld_shift;
+	    /* Get the value of in the (base+1) location */
+	    buf->field_value =
+		GET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base + 1], 0,
+				(fld_len + fld_shift - 32));
+	    buf->field_value = buf->field_value << (32 - fld_shift);
+	    /* Combine them */
+	    buf->field_value |= temp;
+	    break;
+	default:
+	    return FAILURE;
+	}
+    }
+
+    return SUCCESS;
+}
+
+static int chipcfpfldwr(ch_t *ch, void *arg)
+{
+    cfp_ioctl_buf_t *buf;
+    uint32 fld_len, fld_shift, fld_base, temp;
+    int cross_32bit = 0;
+
+    ET_TRACE(("et%d: chipcfpfldwr\n", ch->etc->unit));
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+
+    /* Get the length, shift and base location of the specified field */
+    fld_len = GET_FIELD_LEN(buf->field_idx);
+    fld_shift = GET_FIELD_SHIFT(buf->field_idx) % 32;
+    fld_base = GET_FIELD_SHIFT(buf->field_idx) / 32;
+
+    /* Check if this field cross over 32 bit boundary */
+    if ((fld_len + fld_shift) > 32) {
+	cross_32bit = 1;
+    }
+
+    if (cross_32bit == 0) {
+	switch (buf->ram_type) {
+	case CFP_RAM_TYPE_TCAM:
+	    /* Set the value of field */
+	    SET_FIELD_REG32(buf->cfp_entry.tcam[fld_base],
+			    fld_shift, fld_len, buf->field_value);
+	    break;
+	case CFP_RAM_TYPE_TCAM_MASK:
+	    /* Set the value of field */
+	    SET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base],
+			    fld_shift, fld_len, buf->field_value);
+	    break;
+	case CFP_RAM_TYPE_ACTION:
+	    /* Set the value of field */
+	    SET_FIELD_REG32(buf->cfp_entry.action,
+			    fld_shift, fld_len, buf->field_value);
+	    break;
+	default:
+	    return FAILURE;
+	}
+    } else {			/* cross over 32-bit bounary */
+	switch (buf->ram_type) {
+	case CFP_RAM_TYPE_TCAM:
+	    /* Set the value of field in base location */
+	    temp = ((0x1 << (32 - fld_shift)) - 1) & buf->field_value;
+	    SET_FIELD_REG32(buf->cfp_entry.tcam[fld_base],
+			    fld_shift, (32 - fld_shift), temp);
+	    /* Set the value of field in (base +1) location */
+	    temp = buf->field_value >> (32 - fld_shift);
+	    SET_FIELD_REG32(buf->cfp_entry.tcam[fld_base + 1],
+			    0, (fld_len + fld_shift - 32), temp);
+	    break;
+	case CFP_RAM_TYPE_TCAM_MASK:
+	    /* Set the value of field in base location */
+	    temp = ((0x1 << (32 - fld_shift)) - 1) & buf->field_value;
+	    SET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base],
+			    fld_shift, (32 - fld_shift), temp);
+	    /* Set the value of field in (base + 1) location */
+	    temp = buf->field_value >> (32 - fld_shift);
+	    SET_FIELD_REG32(buf->cfp_entry.tcam_mask[fld_base + 1],
+			    0, (fld_len + fld_shift - 32), temp);
+	    break;
+	default:
+	    return FAILURE;
+	}
+    }
+
+    return SUCCESS;
+}
+
+static int chipcfpudfrd(ch_t *ch, void *arg)
+{
+    uint32 tmp, shift;
+    uint origidx;
+    gmac_commonregs_t *regs;
+    cfp_ioctl_buf_t *buf;
+
+    ET_TRACE(("et%d: chipcfpudfrd\n", ch->etc->unit));
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    /* Check L3 Framing and slice ID */
+    switch (buf->l3_framing) {
+    case CFP_L3_FRAMING_IPV4:
+	if (buf->slice_id > CFP_IPV4_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	tmp = R_REG(ch->osh, &regs->udf_0_a3_a0 +
+		    (buf->slice_id * 4) + (buf->field_idx / 4));
+	shift = (buf->field_idx % 4) * 8;
+	buf->field_value = (tmp >> shift) & CFP_UDF_OFFSET_BASE_VALUE_MASK;
+	buf->flags = (tmp >> (shift + CFP_UDF_OFFSET_BASE_FLAGS_SHIFT))
+	    & CFP_UDF_OFFSET_BASE_FLAGS_MASK;
+	break;
+    case CFP_L3_FRAMING_IPV6:
+	/* slice id 3 means Chain slice */
+	if (buf->slice_id > CFP_IPV6_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	if (buf->slice_id == CFP_IPV6_MAX_SLICE_ID) {
+	    tmp = R_REG(ch->osh, &regs->udf_0_d3_d0 +
+			(buf->field_idx / 4));
+	} else {
+	    tmp = R_REG(ch->osh, &regs->udf_0_b3_b0 +
+			(buf->slice_id * 4) + (buf->field_idx / 4));
+	}
+	shift = (buf->field_idx % 4) * 8;
+	buf->field_value = (tmp >> shift) & CFP_UDF_OFFSET_BASE_VALUE_MASK;
+	buf->flags = (tmp >> (shift + CFP_UDF_OFFSET_BASE_FLAGS_SHIFT))
+	    & CFP_UDF_OFFSET_BASE_FLAGS_MASK;
+	break;
+    case CFP_L3_FRAMING_NONIP:
+	if (buf->slice_id > CFP_NONIP_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	tmp = R_REG(ch->osh, &regs->udf_0_c3_c0 +
+		    (buf->slice_id * 4) + (buf->field_idx / 4));
+	shift = (buf->field_idx % 4) * 8;
+	buf->field_value = (tmp >> shift) & CFP_UDF_OFFSET_BASE_VALUE_MASK;
+	buf->flags = (tmp >> (shift + CFP_UDF_OFFSET_BASE_FLAGS_SHIFT))
+	    & CFP_UDF_OFFSET_BASE_FLAGS_MASK;
+	break;
+    default:
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return FAILURE;
+    }
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return SUCCESS;
+}
+
+static int chipcfpudfwr(ch_t *ch, void *arg)
+{
+    uint32 tmp, shift, mask;
+    uint origidx;
+    gmac_commonregs_t *regs;
+    cfp_ioctl_buf_t *buf;
+
+    ET_TRACE(("et%d: chipcfpudfwr\n", ch->etc->unit));
+    buf = (cfp_ioctl_buf_t *) arg;
+    ASSERT(buf != NULL);
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    /* Check L3 Framing and slice ID */
+    switch (buf->l3_framing) {
+    case CFP_L3_FRAMING_IPV4:
+	if (buf->slice_id > CFP_IPV4_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	tmp = R_REG(ch->osh, &regs->udf_0_a3_a0 +
+		    (buf->slice_id * 4) + (buf->field_idx / 4));
+	shift = (buf->field_idx % 4) * 8;
+	mask = UDF_0_A3_A0_CFG_UDF_0_A0_MASK << shift;
+	tmp &= ~mask;
+	tmp |=
+	    (((buf->field_value /
+	       2) | buf->flags) & UDF_0_A3_A0_CFG_UDF_0_A0_MASK) << shift;
+	W_REG(ch->osh,
+	      &regs->udf_0_a3_a0 + (buf->slice_id * 4) +
+	      (buf->field_idx / 4), tmp);
+	break;
+    case CFP_L3_FRAMING_IPV6:
+	/* slice id 3 means Chain slice */
+	if (buf->slice_id > CFP_IPV6_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	if (buf->slice_id == CFP_IPV6_MAX_SLICE_ID) {
+	    tmp = R_REG(ch->osh, &regs->udf_0_d3_d0 +
+			(buf->slice_id * 4) + (buf->field_idx / 4));
+	} else {
+	    tmp = R_REG(ch->osh, &regs->udf_0_b3_b0 +
+			(buf->slice_id * 4) + (buf->field_idx / 4));
+	}
+	shift = (buf->field_idx % 4) * 8;
+	mask = 0xff << shift;
+	tmp &= ~mask;
+	tmp |= (((buf->field_value / 2) | buf->flags) & 0xff) << shift;
+	if (buf->slice_id == CFP_IPV6_MAX_SLICE_ID) {
+	    W_REG(ch->osh, &regs->udf_0_d3_d0 +
+		  (buf->slice_id * 4) + (buf->field_idx / 4), tmp);
+	} else {
+	    W_REG(ch->osh, &regs->udf_0_b3_b0 +
+		  (buf->slice_id * 4) + (buf->field_idx / 4), tmp);
+	}
+	break;
+    case CFP_L3_FRAMING_NONIP:
+	if (buf->slice_id > CFP_NONIP_MAX_SLICE_ID) {
+	    /* Return to original core */
+	    si_setcoreidx(ch->sih, origidx);
+	    return FAILURE;
+	}
+	tmp = R_REG(ch->osh, &regs->udf_0_c3_c0 +
+		    (buf->slice_id * 4) + (buf->field_idx / 4));
+	shift = (buf->field_idx % 4) * 8;
+	mask = 0xff << shift;
+	tmp &= ~mask;
+	tmp |= (((buf->field_value / 2) | buf->flags) & 0xff) << shift;
+	W_REG(ch->osh, &regs->udf_0_c3_c0 +
+	      (buf->slice_id * 4) + (buf->field_idx / 4), tmp);
+	break;
+    default:
+	/* Return to original core */
+	si_setcoreidx(ch->sih, origidx);
+	return FAILURE;
+    }
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return SUCCESS;
+}
+
+static uint chiprxratemapping(uint pps)
+{
+    uint i;
+    for (i = 0; i <= RX_RATE_MAX_MAP_VALUE; i++) {
+	if (pps <= rx_rate_map[i]) {
+	    return i;
+	}
+    }
+
+    /* return the max value */
+    return RX_RATE_MAX_MAP_VALUE;
+}
+
+static int chiprxrateset(ch_t *ch, uint channel, uint pps)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint reg_val, tmp;
+    uint map_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiprxrateset\n", etc->unit));
+    if (channel >= NUMRXQ) {
+	return FAILURE;
+    }
+
+    /* Get the PPS of the specific channel from the register */
+    reg_val = R_REG(ch->osh, &regs->irc_cfg);
+    tmp = (reg_val >> (channel * IRC_CFG_IRC1_IDX_SHIFT)) &
+	IRC_CFG_IRC0_IDX_MASK;
+
+    map_val = chiprxratemapping(pps);
+
+    /* Configure the new PPS value */
+    if (tmp != map_val) {
+	reg_val &= ~(IRC_CFG_IRC0_IDX_MASK <<
+		     (channel * IRC_CFG_IRC1_IDX_SHIFT));
+	reg_val |= ((map_val & IRC_CFG_IRC0_IDX_MASK) <<
+		    (channel * IRC_CFG_IRC1_IDX_SHIFT));
+	W_REG(ch->osh, &regs->irc_cfg, reg_val);
+    }
+
+    return SUCCESS;
+}
+
+static int chiprxrateget(ch_t *ch, uint channel, uint *pps)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint reg_val, tmp;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiprxrateget\n", etc->unit));
+    if (channel >= NUMRXQ) {
+	return FAILURE;
+    }
+
+    /* Get the PPS of the specific channel from the register */
+    reg_val = R_REG(ch->osh, &regs->irc_cfg);
+    tmp = (reg_val >> (channel * IRC_CFG_IRC1_IDX_SHIFT)) &
+	IRC_CFG_IRC0_IDX_MASK;
+
+    *pps = rx_rate_map[tmp];
+
+    return SUCCESS;
+}
+
+static int chiptxrateset(ch_t *ch, uint channel, uint rate, uint burst)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val, tmp;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiptxrateset\n", etc->unit));
+    if (channel >= NUMTXQ) {
+	return FAILURE;
+    }
+
+    /* Get the TX rate value from chip */
+    reg_val = R_REG(ch->osh, &regs->erc0_cfg + channel);
+    if (rate) {
+	/* Set enable bit */
+	reg_val |= ERC0_CFG_ENABLE_MASK;
+	/* Set refres count */
+	tmp = (rate + (TX_RATE_VALUE_BASE - 1)) / TX_RATE_VALUE_BASE;
+	reg_val &= ~ERC1_CFG_RFSHCNT_MASK;
+	reg_val |= tmp << ERC1_CFG_RFSHCNT_SHIFT;
+
+	/* Set burst size */
+	tmp = (burst + (TX_RATE_BURST_BASE - 1)) / TX_RATE_BURST_BASE;
+	reg_val &= ~ERC1_CFG_BKTSIZE_MASK;
+	reg_val |= tmp << ERC1_CFG_BKTSIZE_SHIFT;
+    } else {
+	/* Disable Egress rate */
+	reg_val &= ~ERC0_CFG_ENABLE_MASK;
+    }
+    W_REG(ch->osh, &regs->erc0_cfg + channel, reg_val);
+
+    return SUCCESS;
+}
+
+static int chiptxrateget(ch_t *ch, uint channel, uint *rate,
+			 uint *burst)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val, tmp;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiptxrateget\n", etc->unit));
+    if (channel >= NUMTXQ) {
+	return FAILURE;
+    }
+
+    /* Get the TX rate value from chip */
+    reg_val = R_REG(ch->osh, &regs->erc0_cfg + channel);
+    if (reg_val & ERC0_CFG_ENABLE_MASK) {
+	/* Get the refresh count value */
+	tmp = (reg_val & ERC1_CFG_RFSHCNT_MASK) >> ERC1_CFG_RFSHCNT_SHIFT;
+	*rate = tmp * TX_RATE_VALUE_BASE;
+	/* Get the bucket size */
+	tmp = (reg_val & ERC1_CFG_BKTSIZE_MASK) >> ERC1_CFG_BKTSIZE_SHIFT;
+	*burst = tmp * TX_RATE_BURST_BASE;
+    } else {
+	/* Egress rate control wasn't enabled */
+	*rate = 0;
+	*burst = 0;
+    }
+
+    return SUCCESS;
+}
+
+static int chipflowctrlmodeset(ch_t *ch, uint mode)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlmodeset\n", etc->unit));
+
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    reg_val &= ~DEVCONTROL_FLOW_CTRL_MODE_MASK;
+    switch (mode) {
+    case FLOW_CTRL_MODE_DISABLE:
+	gmac_txflowcontrol(ch, FALSE);
+	return SUCCESS;
+    case FLOW_CTRL_MODE_AUTO:
+	reg_val |= 0x0 << DEVCONTROL_FLOW_CTRL_MODE_SHIFT;
+	break;
+    case FLOW_CTRL_MODE_CPU:
+	reg_val |= 0x1 << DEVCONTROL_FLOW_CTRL_MODE_SHIFT;
+	break;
+    case FLOW_CTRL_MODE_MIX:
+	reg_val |= 0x2 << DEVCONTROL_FLOW_CTRL_MODE_SHIFT;
+	break;
+    default:
+	return FAILURE;
+    }
+    gmac_txflowcontrol(ch, TRUE);
+    W_REG(ch->osh, &regs->devcontrol, reg_val);
+
+    return SUCCESS;
+}
+
+static int chipflowctrlmodeget(ch_t *ch, uint *mode)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+    uint32 cmdcfg;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlmodeget\n", etc->unit));
+
+    cmdcfg = R_REG(ch->osh, &ch->regs->command_config);
+    if (cmdcfg & COMMAND_CONFIG_PAUSE_IGNORE_MASK) {
+	*mode = FLOW_CTRL_MODE_DISABLE;
+	return SUCCESS;
+    }
+
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    switch ((reg_val & DEVCONTROL_FLOW_CTRL_MODE_MASK) >>
+	    DEVCONTROL_FLOW_CTRL_MODE_SHIFT) {
+    case 0:
+	*mode = FLOW_CTRL_MODE_AUTO;
+	break;
+    case 1:
+	*mode = FLOW_CTRL_MODE_CPU;
+	break;
+    case 2:
+	*mode = FLOW_CTRL_MODE_MIX;
+	break;
+    default:
+	return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+static int chipflowctrlautoset(ch_t *ch, uint on_th, uint off_th)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlautoset\n", etc->unit));
+
+    if ((on_th > 0xfff) || (off_th > 0xfff)) {
+	return FAILURE;
+    }
+
+    /* Set the value of Pause on/off threashod */
+    reg_val = R_REG(ch->osh, &regs->flowctlthresh);
+    reg_val &= ~FLOWCTLTHRESH_ON_THRESH_MASK;
+    reg_val |= on_th << FLOWCTLTHRESH_ON_THRESH_SHIFT;
+    reg_val &= ~FLOWCTLTHRESH_OFF_THRESH_MASK;
+    reg_val |= off_th << FLOWCTLTHRESH_OFF_THRESH_SHIFT;
+    W_REG(ch->osh, &regs->flowctlthresh, reg_val);
+
+    return SUCCESS;
+}
+
+static int chipflowctrlautoget(ch_t *ch, uint *on_th, uint *off_th)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlautoget\n", etc->unit));
+
+    /* Get the value of Pause on/off threashod */
+    reg_val = R_REG(ch->osh, &regs->flowctlthresh);
+    *on_th = (reg_val & FLOWCTLTHRESH_ON_THRESH_MASK) >>
+	FLOWCTLTHRESH_ON_THRESH_SHIFT;
+    *off_th = (reg_val & FLOWCTLTHRESH_OFF_THRESH_MASK) >>
+	FLOWCTLTHRESH_OFF_THRESH_SHIFT;
+
+    return SUCCESS;
+}
+
+static int chipflowctrlcpuset(ch_t *ch, uint pause_on)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlcpuset\n", etc->unit));
+
+    /* Set the pause on value */
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    reg_val &= ~DEVCONTROL_CPU_FLOW_CTRL_ON_MASK;
+    if (pause_on) {
+	reg_val |= 1 << DEVCONTROL_CPU_FLOW_CTRL_ON_SHIFT;
+    }
+    W_REG(ch->osh, &regs->devcontrol, reg_val);
+
+    return SUCCESS;
+}
+
+static int chipflowctrlcpuget(ch_t *ch, uint *pause_on)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlcpuget\n", etc->unit));
+
+    /* Get the pause on value */
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    *pause_on = (reg_val & DEVCONTROL_CPU_FLOW_CTRL_ON_MASK) >>
+	DEVCONTROL_CPU_FLOW_CTRL_ON_SHIFT;;
+
+    return SUCCESS;
+}
+
+static int chipflowctrlrxchanset(ch_t *ch, uint chan, uint on_th,
+				 uint off_th)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlrxchanset\n", etc->unit));
+
+    if (chan >= NUMRXQ) {
+	return FAILURE;
+    }
+
+    /* Value Checking */
+    /*
+     * The pause off should be less than the value (NRXBUFPOST - 1).
+     * Otherwise, the pause frame will keep sending occasionally.
+     */
+    if ((on_th > NRXBUFPOST) || (off_th >= (NRXBUFPOST - 1)) ||
+	(on_th > off_th)) {
+	return FAILURE;
+    }
+
+    /* Set the pause on/off threshold of specific channel */
+    reg_val = R_REG(ch->osh, &regs->rx_ch0_flow_ctrl + chan);
+    reg_val &= ~RX_CH0_FLOW_CTRL_FLOWCNTLONTH_MASK;
+    reg_val |= on_th << RX_CH0_FLOW_CTRL_FLOWCNTLONTH_SHIFT;
+    reg_val &= ~RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_MASK;
+    reg_val |= off_th << RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT;
+    W_REG(ch->osh, &regs->rx_ch0_flow_ctrl + chan, reg_val);
+
+    return SUCCESS;
+}
+
+static int chipflowctrlrxchanget(ch_t *ch, uint chan, uint *on_th,
+				 uint *off_th)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlrxchanget\n", etc->unit));
+
+    if (chan >= NUMRXQ) {
+	return FAILURE;
+    }
+
+    /* Get the pause on/off threshold of specific channel */
+    reg_val = R_REG(ch->osh, &regs->rx_ch0_flow_ctrl + chan);
+    *on_th = (reg_val & RX_CH0_FLOW_CTRL_FLOWCNTLONTH_MASK) >>
+	RX_CH0_FLOW_CTRL_FLOWCNTLONTH_SHIFT;
+    *off_th = (reg_val & RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_MASK) >>
+	RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT;
+
+    return SUCCESS;
+}
+
+static int chiptpidset(ch_t *ch, uint index, uint tpid)
+{
+    uint32 reg_val;
+    uint origidx;
+    gmac_commonregs_t *regs;
+
+    ET_TRACE(("et%d: chiptpidset\n", ch->etc->unit));
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    if (index >= NUM_STAG_TPID) {
+	return FAILURE;
+    }
+
+    /* Set TPID */
+    reg_val = R_REG(ch->osh, &regs->stag0 + index);
+    reg_val &= ~STAG0_TPID_MASK;
+    reg_val |= tpid & STAG0_TPID_MASK;
+    W_REG(ch->osh, &regs->stag0 + index, reg_val);
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+
+    return SUCCESS;
+}
+
+static int chiptpidget(ch_t *ch, uint index, uint *tpid)
+{
+    uint32 reg_val;
+    uint origidx;
+    gmac_commonregs_t *regs;
+
+    ET_TRACE(("et%d: chiptpidget\n", ch->etc->unit));
+
+    /* Remember original core before switch to gmac common */
+    origidx = si_coreidx(ch->sih);
+    regs = si_setcore(ch->sih, GMAC_COM_CORE_ID, 0);
+    ASSERT(regs != NULL);
+
+    if (index >= NUM_STAG_TPID) {
+	si_setcoreidx(ch->sih, origidx);
+	return FAILURE;
+    }
+
+    /* Get TPID */
+    reg_val = R_REG(ch->osh, &regs->stag0 + index);
+    *tpid = reg_val & STAG0_TPID_MASK;
+
+    /* Return to original core */
+    si_setcoreidx(ch->sih, origidx);
+    return SUCCESS;
+}
+
+static int chippvtagset(ch_t *ch, uint private_tag)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chippvtagset\n", etc->unit));
+
+    if (private_tag > MAX_PRIVATE_TAG_VALUE) {
+	return FAILURE;
+    }
+
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    reg_val &= ~DEVCONTROL_PV_TAG_MASK;
+    reg_val |= private_tag << DEVCONTROL_PV_TAG_SHIFT;
+    W_REG(ch->osh, &regs->devcontrol, reg_val);
+
+    return SUCCESS;
+}
+
+static int chippvtagget(ch_t *ch, uint *private_tag)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chippvtagget\n", etc->unit));
+
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    *private_tag = (reg_val & DEVCONTROL_PV_TAG_MASK) >>
+	DEVCONTROL_PV_TAG_SHIFT;
+
+    return SUCCESS;
+}
+
+static int chiprxsephdrset(ch_t *ch, uint enable)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val, field_val = 0;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiprxsephdrset\n", etc->unit));
+
+    if (enable) {
+	field_val = 1;
+    }
+
+    reg_val = R_REG(ch->osh, &regs->d64rcv0control);
+    reg_val &= ~D64RCV0CONTROL_SEPDESCRHDREN_MASK;
+    reg_val |= field_val << D64RCV0CONTROL_SEPDESCRHDREN_SHIFT;
+    W_REG(ch->osh, &regs->d64rcv0control, reg_val);
+
+    return SUCCESS;
+}
+
+static int chiprxsephdrget(ch_t *ch, uint *enable)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiprxsephdrget\n", etc->unit));
+
+    reg_val = R_REG(ch->osh, &regs->devcontrol);
+    *enable = (reg_val & D64RCV0CONTROL_SEPDESCRHDREN_MASK) >>
+	D64RCV0CONTROL_SEPDESCRHDREN_SHIFT;
+
+    return SUCCESS;
+}
+
+static int chiptxqosmodeset(ch_t *ch, uint mode)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiptxqosmodeset\n", etc->unit));
+
+    reg_val = R_REG(ch->osh, &regs->txqos);
+    reg_val &= ~TXQOS_TXQOS_POLICY_MASK;
+    switch (mode) {
+    case TXQOS_MODE_1STRICT_3WRR:
+	reg_val |= 0x0 << TXQOS_TXQOS_POLICY_SHIFT;
+	break;
+    case TXQOS_MODE_2STRICT_2WRR:
+	reg_val |= 0x1 << TXQOS_TXQOS_POLICY_SHIFT;
+	break;
+    case TXQOS_MODE_3STRICT_1WRR:
+	reg_val |= 0x2 << TXQOS_TXQOS_POLICY_SHIFT;
+	break;
+    case TXQOS_MODE_ALL_STRICT:
+	reg_val |= 0x3 << TXQOS_TXQOS_POLICY_SHIFT;
+	break;
+    default:
+	return FAILURE;
+    }
+    W_REG(ch->osh, &regs->txqos, reg_val);
+
+    return SUCCESS;
+}
+
+static int chiptxqosmodeget(ch_t *ch, uint *mode)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chipflowctrlmodeget\n", etc->unit));
+
+    reg_val = R_REG(ch->osh, &regs->txqos);
+    *mode = (reg_val & TXQOS_TXQOS_POLICY_MASK) >>
+	TXQOS_TXQOS_POLICY_SHIFT;
+
+    return SUCCESS;
+}
+
+static int chiptxqosweightset(ch_t *ch, uint queue, uint weight)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiptxqosweightset\n", etc->unit));
+
+    if (queue >= NUMTXQ) {
+	return FAILURE;
+    }
+
+    /* Value Checking */
+    if (weight > 0xff) {
+	return FAILURE;
+    }
+
+    /* highest queue always with strict mode */
+    if (queue == TX_Q3) {
+	return FAILURE;
+    }
+
+    /* Set the pause on/off threshold of specific channel */
+    reg_val = R_REG(ch->osh, &regs->txqos);
+    reg_val &= ~(TXQOS_TXQOS_WEIGHT0_MASK <<
+		 (queue * TXQOS_TXQOS_WEIGHT1_SHIFT));
+    reg_val |= weight << (queue * TXQOS_TXQOS_WEIGHT1_SHIFT);
+    W_REG(ch->osh, &regs->txqos, reg_val);
+
+    return SUCCESS;
+}
+
+static int chiptxqosweightget(ch_t *ch, uint queue, uint *weight)
+{
+    etc_info_t *etc;
+    gmac0regs_t *regs;
+    uint32 reg_val;
+
+    etc = ch->etc;
+    regs = ch->regs;
+
+    ET_TRACE(("et%d: chiptxqosweightget\n", etc->unit));
+
+    if (queue >= NUMTXQ) {
+	return FAILURE;
+    }
+
+    /* highest queue always with strict mode */
+    if (queue == TX_Q3) {
+	return FAILURE;
+    }
+
+    /* Get the pause on/off threshold of specific channel */
+    reg_val = R_REG(ch->osh, &regs->txqos);
+    *weight = (reg_val >> (queue * TXQOS_TXQOS_WEIGHT1_SHIFT))
+	&& TXQOS_TXQOS_WEIGHT0_MASK;
+
+    return SUCCESS;
+}
+
+
+#ifdef CFG_ROBO
+static void robo_fege_port_enable(int handle, int ge_num)
+{
+    int fh = handle;
+    uint16_t miiaddr;
+    uint8_t miireg;
+    int i;
+
+    /* reset chip */
+    miiaddr = 0x37c;
+    miireg = 0x1;
+
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* Wait for chip reset complete */
+    for (i = 0; i < 10000000; i++) {
+	miireg = 0;
+	cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+	if (!(miireg & 0x1)) {
+	    /* Reset is complete */
+	    break;
+	}
+    }
+    miiaddr = 0x140;
+    /* MII port state override (page 1 register 40) */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable IMP port link before doing change in 1Q vlan, mstp
+     * and management mode
+     */
+    miireg = 0x0;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /*
+     * Make sure 802.1Q VLAN, MSTP and management mode are bothe disabled
+     * The system may be reset from runtime...
+     */
+    miireg = 0;
+    /* Disable management mode */
+    cfe_writeblk(fh, 0x0300, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable 802.1Q VLAN */
+    cfe_writeblk(fh, 0x3400, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable MSTP */
+    cfe_writeblk(fh, 0x4500, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    miireg = 0x47;
+
+    /* Enable the IMP port link and speed duplex for in-band networking */
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    miireg = 0;
+    /* Read back */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    if ((miireg & 0x47) != 0x47) {
+	printf("robo_rvmii: error enabling mode");
+    }
+
+}
+
+static void bcm5324_port_enable(int handle, int ge_num)
+{
+    int fh = handle;
+    uint16_t miiaddr;
+    uint8_t miireg;
+    int i;
+
+    /* Check if 5324 chip */
+    /* 5324 chip */
+    /* do not override port status */
+    for (i = 0; i < 24; i++) {
+	/* fe port */
+	miiaddr = 0xa0 + i;
+	miireg = 0;
+	cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    }
+    for (i = 0; i < 2; i++) {
+	/* ge port */
+	miiaddr = 0xb9 + i;
+	miireg = 0;
+	cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    }
+    miiaddr = 0xb8;
+
+    /* MII port state override (page 0 register 14) */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable IMP port link before doing change in 1Q vlan, mstp
+     * and management mode
+     */
+    miireg &= 0xF0;
+    miireg |= 0x80;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /*
+     * Make sure 802.1Q VLAN, MSTP and management mode are bothe disabled
+     * The system may be reset from runtime...
+     */
+    miireg = 0;
+    /* Disable management mode */
+    cfe_writeblk(fh, 0x0200, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable 802.1Q VLAN */
+    cfe_writeblk(fh, 0x3400, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable MSTP */
+    cfe_writeblk(fh, 0x4300, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* Enable the IMP port link and speed duplex for in-band networking */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    miireg |= 0x87;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    miireg = 0;
+    /* Read back */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    if ((miireg & 0x87) != 0x87) {
+	printf("robo_rvmii: error enabling mode");
+    }
+
+}
+
+static void bcm5398_port_enable(int handle, int ge_num)
+{
+    int fh = handle;
+    uint16_t miiaddr;
+    uint8_t miireg;
+    int i;
+
+
+    for (i = 0; i < ge_num; i++) {
+	/* ge port */
+	miiaddr = 0x58 + i;
+	miireg = 0;
+	cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    }
+    miiaddr = 0xe;
+
+    /* MII port state override (page 0 register 14) */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable IMP port link before doing change in 1Q vlan, mstp
+     * and management mode
+     */
+    miireg &= 0xF0;
+    miireg |= 0x80;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /*
+     * Make sure 802.1Q VLAN, MSTP and management mode are bothe disabled
+     * The system may be reset from runtime...
+     */
+    miireg = 0;
+    /* Disable management mode */
+    cfe_writeblk(fh, 0x0200, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable 802.1Q VLAN */
+    cfe_writeblk(fh, 0x3400, PTR2HSADDR(&miireg), sizeof(miireg));
+    /* Disable MSTP */
+    cfe_writeblk(fh, 0x4300, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* Enable the IMP port link and speed duplex for in-band networking */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    miireg |= 0x87;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    miireg = 0;
+    /* Read back */
+    cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+	if ((miireg & 0x87) != 0x87)
+		printf("robo_rvmii: error enabling mode");
+
+
+}
+
+static void robo_ge_port_enable(int handle, int ge_num)
+{
+    int fh = handle;
+    uint16_t miiaddr;
+    uint8_t miireg;
+    int i;
+
+    /* bcm53115 chip */
+
+    /* force IMP port link down before all configuration is done. */
+    miiaddr = 0x000e;
+    miireg = 0x8a;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* set to Management mode */
+    miiaddr = 0x000b;
+    miireg = 0x7;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* enable IMP port */
+    miiaddr = 0x0200;
+    miireg = 0x82;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* disable BRCM header */
+    miiaddr = 0x0203;
+    miireg = 0x0;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+    /* GE port setting */
+    for (i = 0; i < ge_num; i++) {
+	/* clear stateoverride */
+	miiaddr = 0x0058 + i;
+	cfe_readblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+	miireg &= ~0x40;
+	cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+	/* set forwarding state and enable tx/rx */
+	miiaddr = 0x0 + i;
+	miireg = 0xa0;
+	cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+    }
+
+    /* force IMP port to link at 100FD for in-band connectivity */
+    miiaddr = 0x000e;
+    miireg = 0x8b;
+    cfe_writeblk(fh, miiaddr, PTR2HSADDR(&miireg), sizeof(miireg));
+
+}
+
+static void robo_53242_misc_init(int handle)
+{
+    int fh = handle;
+    uint16_t regaddr;
+    uint16_t ledfun;
+    uint8_t led_map[8];
+
+
+    /* Configure the LED function for BCM53242 */
+    regaddr = 0x5c;
+    ledfun = 0x104;
+#if ENDIAN_BIG
+    ledfun = SWAP16(ledfun);
+#endif
+    cfe_writeblk(fh, regaddr, PTR2HSADDR(&ledfun), sizeof(ledfun));
+
+    regaddr = 0x5e;
+    ledfun = 0x106;
+#if ENDIAN_BIG
+    ledfun = SWAP16(ledfun);
+#endif
+    cfe_writeblk(fh, regaddr, PTR2HSADDR(&ledfun), sizeof(ledfun));
+
+    regaddr = 0x60;
+    bzero(&led_map[0], 8);
+    led_map[6] = 0x06;
+    cfe_writeblk(fh, regaddr, PTR2HSADDR(&led_map[0]), 8);
+
+    return;
+}
+
+static void _robo_port_stop(int handle, uint16_t mii_reg)
+{
+    int fh = handle;
+    uint8_t value;
+
+    cfe_readblk(fh, mii_reg, PTR2HSADDR(&value), sizeof(value));
+    value &= 0xfe;		/* force IMP port link down */
+    cfe_writeblk(fh, mii_reg, PTR2HSADDR(&value), sizeof(value));
+}
+
+typedef struct chip_info_s {
+    char *name;
+    uint16_t phyidh;
+    uint16_t phyidl;
+    uint16_t ge_num;
+    void (*port_enable) (int handle, int ge_num);
+    void (*misc_init) (int handle);
+    uint16_t mii_reg;		/* IMP override reg */
+} chip_info_t;
+
+static chip_info_t _robo_chip_info[] = {
+    {"BCM5324",
+     0x0143,
+     0xbc20,
+     2,
+     bcm5324_port_enable,
+     NULL,
+     0x00b8},
+    {"BCM5398",
+     0x0143,
+     0xbcd0,
+     8,
+     bcm5398_port_enable,
+     NULL,
+     0x000e},
+    {"BCM5348/47",
+     0x0143,
+     0xbe40,
+     4,
+     robo_fege_port_enable,
+     NULL,
+     0x0140},
+    {"BCM5395",
+     0x0143,
+     0xbcf0,
+     5,
+     robo_ge_port_enable,
+     NULL,
+     0x000e},
+    {"BCM53242",
+     0x0143,
+     0xbf10,
+     2,
+     robo_fege_port_enable,
+     robo_53242_misc_init,
+     0x0140},
+    {"BCM53262",
+     0x0143,
+     0xbf20,
+     2,
+     robo_fege_port_enable,
+     NULL,
+     0x0140},
+    {"BCM53115",
+     0x0143,
+     0xbf80,
+     6,
+     robo_ge_port_enable,
+     NULL,
+     0x000e},
+    {"BCM53118",
+     0x0143,
+     0xbfe0,
+     8,
+     robo_ge_port_enable,
+     NULL,
+     0x000e},
+    {NULL, -1}
+};
+
+
+static void robo_port_enable(ch_t * ch)
+{
+    int fh;
+    chip_info_t *chip;
+    uint16_t phyidl, phyidh;
+
+    /* For now, robo0 is the default for spi channel */
+    if ((fh = cfe_open("robo0")) < 0) {
+	printf("cfe_open robo0 failed\n");
+	return;
+    }
+
+    cfe_readblk(fh, ((0x10 << 8) | (0x4 << 0)),
+		PTR2HSADDR(&phyidh), sizeof(phyidh));
+    cfe_readblk(fh, ((0x10 << 8) | (0x6 << 0)),
+		PTR2HSADDR(&phyidl), sizeof(phyidl));
+
+#if ENDIAN_BIG
+    phyidh = SWAP16(phyidh);
+    phyidl = SWAP16(phyidl);
+#endif
+
+    chip = _robo_chip_info;
+
+    while (chip->name) {
+	if ((phyidh == chip->phyidh)
+	    && ((phyidl & 0xfff0) == chip->phyidl)) {
+	    chip->port_enable(fh, chip->ge_num);
+	    if (chip->misc_init) {
+		chip->misc_init(fh);
+	    }
+	    break;
+	}
+	chip++;
+    }
+
+    cfe_close(fh);
+
+}
+
+static void robo_port_stop(ch_t *ch)
+{
+    int fh;
+    chip_info_t *chip;
+    uint16_t phyidl, phyidh;
+
+    /* For now, robo0 is the default for spi channel */
+    if ((fh = cfe_open("robo0")) < 0) {
+	printf("cfe_open robo0 failed\n");
+	return;
+    }
+
+    cfe_readblk(fh, ((0x10 << 8) | (0x4 << 0)),
+		PTR2HSADDR(&phyidh), sizeof(phyidh));
+    cfe_readblk(fh, ((0x10 << 8) | (0x6 << 0)),
+		PTR2HSADDR(&phyidl), sizeof(phyidl));
+
+#if ENDIAN_BIG
+    phyidh = SWAP16(phyidh);
+    phyidl = SWAP16(phyidl);
+#endif
+
+    chip = _robo_chip_info;
+
+    while (chip->name) {
+	if ((phyidh == chip->phyidh)
+	    && ((phyidl & 0xfff0) == chip->phyidl)) {
+	    _robo_port_stop(fh, chip->mii_reg);
+	    break;
+	}
+	chip++;
+    }
+    cfe_close(fh);
+}
+#endif				/* CFG_ROBO */
diff --git a/drivers/net/gmac/etcgmac.h b/drivers/net/gmac/etcgmac.h
new file mode 100644
index 0000000..26733cd
--- /dev/null
+++ b/drivers/net/gmac/etcgmac.h
@@ -0,0 +1,815 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Broadcom Gigabit Ethernet MAC defines.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+#ifndef _etcgmac_h_
+#define _etcgmac_h_
+
+/* chip interrupt bit error summary */
+#define	I_ERRORS		(INTMASK_PCIDESCERROR_MASK | INTMASK_PCIDATAERROR_MASK | \
+     INTMASK_DESCERROR_MASK  | INTMASK_XMTFIFOUNDERFLOW_MASK)
+#define	DEF_INTMASK		(INTMASK_XMT0INTERRUPT_MASK | INTMASK_XMT1INTERRUPT_MASK \
+    | INTMASK_XMT2INTERRUPT_MASK | INTMASK_XMT3INTERRUPT_MASK | INTMASK_RCVINTERRUPT_0_MASK | \
+    INTMASK_RCVINTERRUPT_1_MASK | INTMASK_RCVINTERRUPT_2_MASK | INTMASK_RCVINTERRUPT_3_MASK | \
+    I_ERRORS)
+
+#define GMAC_RESET_DELAY 	2
+
+#define GMAC_MIN_FRAMESIZE	17	/* gmac can only send frames of
+					 * size above 17 octetes.
+					 */
+
+#define LOOPBACK_MODE_DMA	0	/* loopback the packet at the DMA engine */
+#define LOOPBACK_MODE_MAC	1	/* loopback the packet at MAC */
+#define LOOPBACK_MODE_NONE	2	/* no Loopback */
+
+#define RC_MAC_DATA_PERIOD	9
+
+#define DMAREG(ch, dir, qnum)	((dir == DMA_TX) ? \
+	                         (void *)(uintptr)(&(ch->regs->d64xmt0control) + (0x10 * qnum)) : \
+	                         (void *)(uintptr)(&(ch->regs->d64rcv0control) + (0x10 * qnum)))
+
+
+/*
+ * Add multicast address to the list. Multicast address are maintained as
+ * hash table with chaining.
+ */
+typedef struct mclist {
+    struct ether_addr mc_addr;	/* multicast address to allow */
+    struct mclist *next;	/* next entry */
+} mflist_t;
+
+#define GMAC_HASHT_SIZE		16	/* hash table size */
+#define GMAC_MCADDR_HASH(m)	((((uint8 *)(m))[3] + ((uint8 *)(m))[4] + \
+	                         ((uint8 *)(m))[5]) & (GMAC_HASHT_SIZE - 1))
+
+#define ETHER_MCADDR_CMP(x, y) ((((uint16 *)(x))[0] ^ ((uint16 *)(y))[0]) | \
+				(((uint16 *)(x))[1] ^ ((uint16 *)(y))[1]) | \
+				(((uint16 *)(x))[2] ^ ((uint16 *)(y))[2]))
+
+#define SUCCESS			0
+#define FAILURE			-1
+#define TIMEOUT                 -2
+
+typedef struct mcfilter {
+    /* hash table for multicast filtering */
+    mflist_t *bucket[GMAC_HASHT_SIZE];
+} mcfilter_t;
+
+extern uint32 find_priq(uint32 pri_map);
+
+
+typedef enum cfp_field_e {
+    CFP_FIELD_IPV4_VALID,
+    CFP_FIELD_IPV4_SLICE_ID,
+    CFP_FIELD_IPV4_UDF0,
+    CFP_FIELD_IPV4_UDF1,
+    CFP_FIELD_IPV4_UDF2,
+    CFP_FIELD_IPV4_UDF3,
+    CFP_FIELD_IPV4_UDF4,
+    CFP_FIELD_IPV4_UDF5,
+    CFP_FIELD_IPV4_UDF6,
+    CFP_FIELD_IPV4_UDF7,
+    CFP_FIELD_IPV4_UDF8,
+    CFP_FIELD_IPV4_CTAG,
+    CFP_FIELD_IPV4_STAG,
+    CFP_FIELD_IPV4_UDF0_VLD,
+    CFP_FIELD_IPV4_UDF1_VLD,
+    CFP_FIELD_IPV4_UDF2_VLD,
+    CFP_FIELD_IPV4_UDF3_VLD,
+    CFP_FIELD_IPV4_UDF4_VLD,
+    CFP_FIELD_IPV4_UDF5_VLD,
+    CFP_FIELD_IPV4_UDF6_VLD,
+    CFP_FIELD_IPV4_UDF7_VLD,
+    CFP_FIELD_IPV4_UDF8_VLD,
+    CFP_FIELD_IPV4_TTL_RANGE,
+    CFP_FIELD_IPV4_IP_AUTH,
+    CFP_FIELD_IPV4_NON_FIRST_FRAG,
+    CFP_FIELD_IPV4_IP_FRAG,
+    CFP_FIELD_IPV4_IP_PROTO,
+    CFP_FIELD_IPV4_IP_TOS,
+    CFP_FIELD_IPV4_L3_FRAMING,
+    CFP_FIELD_IPV4_L2_FRAMING,
+    CFP_FIELD_IPV4_C_TAGGED,
+    CFP_FIELD_IPV4_S_TAGGED,
+    CFP_FIELD_IPV4_SRC_PMAP,
+    CFP_FIELD_IPV6_VALID,
+    CFP_FIELD_IPV6_SLICE_ID,
+    CFP_FIELD_IPV6_UDF0,
+    CFP_FIELD_IPV6_UDF1,
+    CFP_FIELD_IPV6_UDF2,
+    CFP_FIELD_IPV6_UDF3,
+    CFP_FIELD_IPV6_UDF4,
+    CFP_FIELD_IPV6_UDF5,
+    CFP_FIELD_IPV6_UDF6,
+    CFP_FIELD_IPV6_UDF7,
+    CFP_FIELD_IPV6_UDF8,
+    CFP_FIELD_IPV6_CTAG,
+    CFP_FIELD_IPV6_STAG,
+    CFP_FIELD_IPV6_UDF0_VLD,
+    CFP_FIELD_IPV6_UDF1_VLD,
+    CFP_FIELD_IPV6_UDF2_VLD,
+    CFP_FIELD_IPV6_UDF3_VLD,
+    CFP_FIELD_IPV6_UDF4_VLD,
+    CFP_FIELD_IPV6_UDF5_VLD,
+    CFP_FIELD_IPV6_UDF6_VLD,
+    CFP_FIELD_IPV6_UDF7_VLD,
+    CFP_FIELD_IPV6_UDF8_VLD,
+    CFP_FIELD_IPV6_HOPLIMIT_RANGE,
+    CFP_FIELD_IPV6_IP_AUTH,
+    CFP_FIELD_IPV6_NON_FIRST_FRAG,
+    CFP_FIELD_IPV6_IP_FRAG,
+    CFP_FIELD_IPV6_IP_PROTO,
+    CFP_FIELD_IPV6_IP_TOS,
+    CFP_FIELD_IPV6_L3_FRAMING,
+    CFP_FIELD_IPV6_L2_FRAMING,
+    CFP_FIELD_IPV6_C_TAGGED,
+    CFP_FIELD_IPV6_S_TAGGED,
+    CFP_FIELD_IPV6_SRC_PMAP,
+    CFP_FIELD_NONIP_VALID,
+    CFP_FIELD_NONIP_SLICE_ID,
+    CFP_FIELD_NONIP_UDF0,
+    CFP_FIELD_NONIP_UDF1,
+    CFP_FIELD_NONIP_UDF2,
+    CFP_FIELD_NONIP_UDF3,
+    CFP_FIELD_NONIP_UDF4,
+    CFP_FIELD_NONIP_UDF5,
+    CFP_FIELD_NONIP_UDF6,
+    CFP_FIELD_NONIP_UDF7,
+    CFP_FIELD_NONIP_UDF8,
+    CFP_FIELD_NONIP_CTAG,
+    CFP_FIELD_NONIP_STAG,
+    CFP_FIELD_NONIP_UDF0_VLD,
+    CFP_FIELD_NONIP_UDF1_VLD,
+    CFP_FIELD_NONIP_UDF2_VLD,
+    CFP_FIELD_NONIP_UDF3_VLD,
+    CFP_FIELD_NONIP_UDF4_VLD,
+    CFP_FIELD_NONIP_UDF5_VLD,
+    CFP_FIELD_NONIP_UDF6_VLD,
+    CFP_FIELD_NONIP_UDF7_VLD,
+    CFP_FIELD_NONIP_UDF8_VLD,
+    CFP_FIELD_NONIP_ETHERTYPE_SAP,
+    CFP_FIELD_NONIP_L3_FRAMING,
+    CFP_FIELD_NONIP_L2_FRAMING,
+    CFP_FIELD_NONIP_C_TAGGED,
+    CFP_FIELD_NONIP_S_TAGGED,
+    CFP_FIELD_NONIP_SRC_PMAP,
+    CFP_FIELD_CHAIN_VALID,
+    CFP_FIELD_CHAIN_SLICE_ID,
+    CFP_FIELD_CHAIN_UDF0,
+    CFP_FIELD_CHAIN_UDF1,
+    CFP_FIELD_CHAIN_UDF2,
+    CFP_FIELD_CHAIN_UDF3,
+    CFP_FIELD_CHAIN_UDF4,
+    CFP_FIELD_CHAIN_UDF5,
+    CFP_FIELD_CHAIN_UDF6,
+    CFP_FIELD_CHAIN_UDF7,
+    CFP_FIELD_CHAIN_UDF8,
+    CFP_FIELD_CHAIN_UDF9,
+    CFP_FIELD_CHAIN_UDF10,
+    CFP_FIELD_CHAIN_UDF11,
+    CFP_FIELD_CHAIN_UDF0_VLD,
+    CFP_FIELD_CHAIN_UDF1_VLD,
+    CFP_FIELD_CHAIN_UDF2_VLD,
+    CFP_FIELD_CHAIN_UDF3_VLD,
+    CFP_FIELD_CHAIN_UDF4_VLD,
+    CFP_FIELD_CHAIN_UDF5_VLD,
+    CFP_FIELD_CHAIN_UDF6_VLD,
+    CFP_FIELD_CHAIN_UDF7_VLD,
+    CFP_FIELD_CHAIN_UDF8_VLD,
+    CFP_FIELD_CHAIN_UDF9_VLD,
+    CFP_FIELD_CHAIN_UDF10_VLD,
+    CFP_FIELD_CHAIN_UDF11_VLD,
+    CFP_FIELD_CHAIN_CHAIN_ID,
+    CFP_FIELD_ACT_CHAIN_ID,
+    CFP_FIELD_ACT_CLASSFICATION_ID = CFP_FIELD_ACT_CHAIN_ID,
+    CFP_FIELD_ACT_RX_CHANNEL_ID,
+    CFP_FIELD_ACT_DROP,
+    CFP_FIELD_COUNT
+} cfp_field_t;
+
+#define CFP_FIELD_STRINGS \
+{ \
+    "CFP_FIELD_IPV4_VALID", \
+    "CFP_FIELD_IPV4_SLICE_ID", \
+    "CFP_FIELD_IPV4_UDF0", \
+    "CFP_FIELD_IPV4_UDF1", \
+    "CFP_FIELD_IPV4_UDF2", \
+    "CFP_FIELD_IPV4_UDF3", \
+    "CFP_FIELD_IPV4_UDF4", \
+    "CFP_FIELD_IPV4_UDF5", \
+    "CFP_FIELD_IPV4_UDF6", \
+    "CFP_FIELD_IPV4_UDF7", \
+    "CFP_FIELD_IPV4_UDF8", \
+    "CFP_FIELD_IPV4_CTAG", \
+    "CFP_FIELD_IPV4_STAG", \
+    "CFP_FIELD_IPV4_UDF0_VLD", \
+    "CFP_FIELD_IPV4_UDF1_VLD", \
+    "CFP_FIELD_IPV4_UDF2_VLD", \
+    "CFP_FIELD_IPV4_UDF3_VLD", \
+    "CFP_FIELD_IPV4_UDF4_VLD", \
+    "CFP_FIELD_IPV4_UDF5_VLD", \
+    "CFP_FIELD_IPV4_UDF6_VLD", \
+    "CFP_FIELD_IPV4_UDF7_VLD", \
+    "CFP_FIELD_IPV4_UDF8_VLD", \
+    "CFP_FIELD_IPV4_TTL_RANGE", \
+    "CFP_FIELD_IPV4_IP_AUTH", \
+    "CFP_FIELD_IPV4_NON_FIRST_FRAG", \
+    "CFP_FIELD_IPV4_IP_FRAG", \
+    "CFP_FIELD_IPV4_IP_PROTO", \
+    "CFP_FIELD_IPV4_IP_TOS", \
+    "CFP_FIELD_IPV4_L3_FRAMING", \
+    "CFP_FIELD_IPV4_L2_FRAMING", \
+    "CFP_FIELD_IPV4_C_TAGGED", \
+    "CFP_FIELD_IPV4_S_TAGGED", \
+    "CFP_FIELD_IPV4_SRC_PMAP", \
+    "CFP_FIELD_IPV6_VALID", \
+    "CFP_FIELD_IPV6_SLICE_ID", \
+    "CFP_FIELD_IPV6_UDF0", \
+    "CFP_FIELD_IPV6_UDF1", \
+    "CFP_FIELD_IPV6_UDF2", \
+    "CFP_FIELD_IPV6_UDF3", \
+    "CFP_FIELD_IPV6_UDF4", \
+    "CFP_FIELD_IPV6_UDF5", \
+    "CFP_FIELD_IPV6_UDF6", \
+    "CFP_FIELD_IPV6_UDF7", \
+    "CFP_FIELD_IPV6_UDF8", \
+    "CFP_FIELD_IPV6_CTAG", \
+    "CFP_FIELD_IPV6_STAG", \
+    "CFP_FIELD_IPV6_UDF0_VLD", \
+    "CFP_FIELD_IPV6_UDF1_VLD", \
+    "CFP_FIELD_IPV6_UDF2_VLD", \
+    "CFP_FIELD_IPV6_UDF3_VLD", \
+    "CFP_FIELD_IPV6_UDF4_VLD", \
+    "CFP_FIELD_IPV6_UDF5_VLD", \
+    "CFP_FIELD_IPV6_UDF6_VLD", \
+    "CFP_FIELD_IPV6_UDF7_VLD", \
+    "CFP_FIELD_IPV6_UDF8_VLD", \
+    "CFP_FIELD_IPV6_HOPLIMIT_RANGE", \
+    "CFP_FIELD_IPV6_IP_AUTH", \
+    "CFP_FIELD_IPV6_NON_FIRST_FRAG", \
+    "CFP_FIELD_IPV6_IP_FRAG", \
+    "CFP_FIELD_IPV6_IP_PROTO", \
+    "CFP_FIELD_IPV6_IP_TOS", \
+    "CFP_FIELD_IPV6_L3_FRAMING", \
+    "CFP_FIELD_IPV6_L2_FRAMING", \
+    "CFP_FIELD_IPV6_C_TAGGED", \
+    "CFP_FIELD_IPV6_S_TAGGED", \
+    "CFP_FIELD_IPV6_SRC_PMAP", \
+    "CFP_FIELD_NONIP_VALID", \
+    "CFP_FIELD_NONIP_SLICE_ID", \
+    "CFP_FIELD_NONIP_UDF0", \
+    "CFP_FIELD_NONIP_UDF1", \
+    "CFP_FIELD_NONIP_UDF2", \
+    "CFP_FIELD_NONIP_UDF3", \
+    "CFP_FIELD_NONIP_UDF4", \
+    "CFP_FIELD_NONIP_UDF5", \
+    "CFP_FIELD_NONIP_UDF6", \
+    "CFP_FIELD_NONIP_UDF7", \
+    "CFP_FIELD_NONIP_UDF8", \
+    "CFP_FIELD_NONIP_CTAG", \
+    "CFP_FIELD_NONIP_STAG", \
+    "CFP_FIELD_NONIP_UDF0_VLD", \
+    "CFP_FIELD_NONIP_UDF1_VLD", \
+    "CFP_FIELD_NONIP_UDF2_VLD", \
+    "CFP_FIELD_NONIP_UDF3_VLD", \
+    "CFP_FIELD_NONIP_UDF4_VLD", \
+    "CFP_FIELD_NONIP_UDF5_VLD", \
+    "CFP_FIELD_NONIP_UDF6_VLD", \
+    "CFP_FIELD_NONIP_UDF7_VLD", \
+    "CFP_FIELD_NONIP_UDF8_VLD", \
+    "CFP_FIELD_NONIP_ETHERTYPE_SAP", \
+    "CFP_FIELD_NONIP_L3_FRAMING", \
+    "CFP_FIELD_NONIP_L2_FRAMING", \
+    "CFP_FIELD_NONIP_C_TAGGED", \
+    "CFP_FIELD_NONIP_S_TAGGED", \
+    "CFP_FIELD_NONIP_SRC_PMAP", \
+    "CFP_FIELD_CHAIN_VALID", \
+    "CFP_FIELD_CHAIN_SLICE_ID", \
+    "CFP_FIELD_CHAIN_UDF0", \
+    "CFP_FIELD_CHAIN_UDF1", \
+    "CFP_FIELD_CHAIN_UDF2", \
+    "CFP_FIELD_CHAIN_UDF3", \
+    "CFP_FIELD_CHAIN_UDF4", \
+    "CFP_FIELD_CHAIN_UDF5", \
+    "CFP_FIELD_CHAIN_UDF6", \
+    "CFP_FIELD_CHAIN_UDF7", \
+    "CFP_FIELD_CHAIN_UDF8", \
+    "CFP_FIELD_CHAIN_UDF9", \
+    "CFP_FIELD_CHAIN_UDF10", \
+    "CFP_FIELD_CHAIN_UDF11", \
+    "CFP_FIELD_CHAIN_UDF0_VLD", \
+    "CFP_FIELD_CHAIN_UDF1_VLD", \
+    "CFP_FIELD_CHAIN_UDF2_VLD", \
+    "CFP_FIELD_CHAIN_UDF3_VLD", \
+    "CFP_FIELD_CHAIN_UDF4_VLD", \
+    "CFP_FIELD_CHAIN_UDF5_VLD", \
+    "CFP_FIELD_CHAIN_UDF6_VLD", \
+    "CFP_FIELD_CHAIN_UDF7_VLD", \
+    "CFP_FIELD_CHAIN_UDF8_VLD", \
+    "CFP_FIELD_CHAIN_UDF9_VLD", \
+    "CFP_FIELD_CHAIN_UDF10_VLD", \
+    "CFP_FIELD_CHAIN_UDF11_VLD", \
+    "CFP_FIELD_CHAIN_CHAIN_ID", \
+    "CFP_FIELD_ACT_CHAIN_ID", \
+    "CFP_FIELD_ACT_RX_CHANNEL_ID", \
+    "CFP_FIELD_ACT_DROP", \
+    "CFP_FIELD_COUNT" \
+}
+
+typedef struct cfp_field_info_s {
+    uint32 shift;
+    uint32 len;
+} cfp_field_info_t;
+
+
+/* Field Index */
+/* IPV4 SLICE */
+#define CFP_FIELD_IPV4_VALID_LEN  2
+#define CFP_FIELD_IPV4_VALID_SHIFT  0
+#define CFP_FIELD_IPV4_SLICE_ID_LEN  2
+#define CFP_FIELD_IPV4_SLICE_ID_SHIFT  2
+#define CFP_FIELD_IPV4_UDF0_LEN  16
+#define CFP_FIELD_IPV4_UDF0_SHIFT  8
+#define CFP_FIELD_IPV4_UDF1_LEN  16
+#define CFP_FIELD_IPV4_UDF1_SHIFT  24
+#define CFP_FIELD_IPV4_UDF2_LEN  16
+#define CFP_FIELD_IPV4_UDF2_SHIFT  40
+#define CFP_FIELD_IPV4_UDF3_LEN  16
+#define CFP_FIELD_IPV4_UDF3_SHIFT  56
+#define CFP_FIELD_IPV4_UDF4_LEN  16
+#define CFP_FIELD_IPV4_UDF4_SHIFT  72
+#define CFP_FIELD_IPV4_UDF5_LEN  16
+#define CFP_FIELD_IPV4_UDF5_SHIFT  88
+#define CFP_FIELD_IPV4_UDF6_LEN  16
+#define CFP_FIELD_IPV4_UDF6_SHIFT  104
+#define CFP_FIELD_IPV4_UDF7_LEN  16
+#define CFP_FIELD_IPV4_UDF7_SHIFT  120
+#define CFP_FIELD_IPV4_UDF8_LEN  16
+#define CFP_FIELD_IPV4_UDF8_SHIFT  136
+#define CFP_FIELD_IPV4_CTAG_LEN  16
+#define CFP_FIELD_IPV4_CTAG_SHIFT  152
+#define CFP_FIELD_IPV4_STAG_LEN  16
+#define CFP_FIELD_IPV4_STAG_SHIFT  168
+#define CFP_FIELD_IPV4_UDF0_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF0_VLD_SHIFT  184
+#define CFP_FIELD_IPV4_UDF1_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF1_VLD_SHIFT  185
+#define CFP_FIELD_IPV4_UDF2_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF2_VLD_SHIFT  186
+#define CFP_FIELD_IPV4_UDF3_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF3_VLD_SHIFT  187
+#define CFP_FIELD_IPV4_UDF4_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF4_VLD_SHIFT  188
+#define CFP_FIELD_IPV4_UDF5_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF5_VLD_SHIFT  189
+#define CFP_FIELD_IPV4_UDF6_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF6_VLD_SHIFT  190
+#define CFP_FIELD_IPV4_UDF7_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF7_VLD_SHIFT  191
+#define CFP_FIELD_IPV4_UDF8_VLD_LEN  1
+#define CFP_FIELD_IPV4_UDF8_VLD_SHIFT  192
+#define CFP_FIELD_IPV4_TTL_RANGE_LEN  2
+#define CFP_FIELD_IPV4_TTL_RANGE_SHIFT  195
+#define CFP_FIELD_IPV4_IP_AUTH_LEN  1
+#define CFP_FIELD_IPV4_IP_AUTH_SHIFT  197
+#define CFP_FIELD_IPV4_NON_FIRST_FRAG_LEN  1
+#define CFP_FIELD_IPV4_NON_FIRST_FRAG_SHIFT  198
+#define CFP_FIELD_IPV4_IP_FRAG_LEN  1
+#define CFP_FIELD_IPV4_IP_FRAG_SHIFT  199
+#define CFP_FIELD_IPV4_IP_PROTO_LEN  8
+#define CFP_FIELD_IPV4_IP_PROTO_SHIFT  200
+#define CFP_FIELD_IPV4_IP_TOS_LEN  8
+#define CFP_FIELD_IPV4_IP_TOS_SHIFT  208
+#define CFP_FIELD_IPV4_L3_FRAMING_LEN  2
+#define CFP_FIELD_IPV4_L3_FRAMING_SHIFT  216
+#define CFP_FIELD_IPV4_L2_FRAMING_LEN  2
+#define CFP_FIELD_IPV4_L2_FRAMING_SHIFT  218
+#define CFP_FIELD_IPV4_C_TAGGED_LEN  2
+#define CFP_FIELD_IPV4_C_TAGGED_SHIFT  220
+#define CFP_FIELD_IPV4_S_TAGGED_LEN  2
+#define CFP_FIELD_IPV4_S_TAGGED_SHIFT  222
+#define CFP_FIELD_IPV4_SRC_PMAP_LEN  8
+#define CFP_FIELD_IPV4_SRC_PMAP_SHIFT  224
+
+
+/* IPV6 SLICE */
+#define CFP_FIELD_IPV6_VALID_LEN  2
+#define CFP_FIELD_IPV6_VALID_SHIFT  0
+#define CFP_FIELD_IPV6_SLICE_ID_LEN  2
+#define CFP_FIELD_IPV6_SLICE_ID_SHIFT  2
+#define CFP_FIELD_IPV6_UDF0_LEN  16
+#define CFP_FIELD_IPV6_UDF0_SHIFT  8
+#define CFP_FIELD_IPV6_UDF1_LEN  16
+#define CFP_FIELD_IPV6_UDF1_SHIFT  24
+#define CFP_FIELD_IPV6_UDF2_LEN  16
+#define CFP_FIELD_IPV6_UDF2_SHIFT  40
+#define CFP_FIELD_IPV6_UDF3_LEN  16
+#define CFP_FIELD_IPV6_UDF3_SHIFT  56
+#define CFP_FIELD_IPV6_UDF4_LEN  16
+#define CFP_FIELD_IPV6_UDF4_SHIFT  72
+#define CFP_FIELD_IPV6_UDF5_LEN  16
+#define CFP_FIELD_IPV6_UDF5_SHIFT  88
+#define CFP_FIELD_IPV6_UDF6_LEN  16
+#define CFP_FIELD_IPV6_UDF6_SHIFT  104
+#define CFP_FIELD_IPV6_UDF7_LEN  16
+#define CFP_FIELD_IPV6_UDF7_SHIFT  120
+#define CFP_FIELD_IPV6_UDF8_LEN  16
+#define CFP_FIELD_IPV6_UDF8_SHIFT  136
+#define CFP_FIELD_IPV6_CTAG_LEN  16
+#define CFP_FIELD_IPV6_CTAG_SHIFT  152
+#define CFP_FIELD_IPV6_STAG_LEN  16
+#define CFP_FIELD_IPV6_STAG_SHIFT  168
+#define CFP_FIELD_IPV6_UDF0_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF0_VLD_SHIFT  184
+#define CFP_FIELD_IPV6_UDF1_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF1_VLD_SHIFT  185
+#define CFP_FIELD_IPV6_UDF2_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF2_VLD_SHIFT  186
+#define CFP_FIELD_IPV6_UDF3_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF3_VLD_SHIFT  187
+#define CFP_FIELD_IPV6_UDF4_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF4_VLD_SHIFT  188
+#define CFP_FIELD_IPV6_UDF5_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF5_VLD_SHIFT  189
+#define CFP_FIELD_IPV6_UDF6_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF6_VLD_SHIFT  190
+#define CFP_FIELD_IPV6_UDF7_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF7_VLD_SHIFT  191
+#define CFP_FIELD_IPV6_UDF8_VLD_LEN  1
+#define CFP_FIELD_IPV6_UDF8_VLD_SHIFT  192
+#define CFP_FIELD_IPV6_HOPLIMIT_RANGE_LEN  2
+#define CFP_FIELD_IPV6_HOPLIMIT_RANGE_SHIFT  195
+#define CFP_FIELD_IPV6_IP_AUTH_LEN  1
+#define CFP_FIELD_IPV6_IP_AUTH_SHIFT  197
+#define CFP_FIELD_IPV6_NON_FIRST_FRAG_LEN  1
+#define CFP_FIELD_IPV6_NON_FIRST_FRAG_SHIFT  198
+#define CFP_FIELD_IPV6_IP_FRAG_LEN  1
+#define CFP_FIELD_IPV6_IP_FRAG_SHIFT  199
+#define CFP_FIELD_IPV6_IP_PROTO_LEN  8
+#define CFP_FIELD_IPV6_IP_PROTO_SHIFT  200
+#define CFP_FIELD_IPV6_IP_TOS_LEN  8
+#define CFP_FIELD_IPV6_IP_TOS_SHIFT  208
+#define CFP_FIELD_IPV6_L3_FRAMING_LEN  2
+#define CFP_FIELD_IPV6_L3_FRAMING_SHIFT  216
+#define CFP_FIELD_IPV6_L2_FRAMING_LEN  2
+#define CFP_FIELD_IPV6_L2_FRAMING_SHIFT  218
+#define CFP_FIELD_IPV6_C_TAGGED_LEN  2
+#define CFP_FIELD_IPV6_C_TAGGED_SHIFT  220
+#define CFP_FIELD_IPV6_S_TAGGED_LEN  2
+#define CFP_FIELD_IPV6_S_TAGGED_SHIFT  222
+#define CFP_FIELD_IPV6_SRC_PMAP_LEN  8
+#define CFP_FIELD_IPV6_SRC_PMAP_SHIFT  224
+
+
+/* NONIP SLICE */
+#define CFP_FIELD_NONIP_VALID_LEN  2
+#define CFP_FIELD_NONIP_VALID_SHIFT  0
+#define CFP_FIELD_NONIP_SLICE_ID_LEN  2
+#define CFP_FIELD_NONIP_SLICE_ID_SHIFT  2
+#define CFP_FIELD_NONIP_UDF0_LEN  16
+#define CFP_FIELD_NONIP_UDF0_SHIFT  8
+#define CFP_FIELD_NONIP_UDF1_LEN  16
+#define CFP_FIELD_NONIP_UDF1_SHIFT  24
+#define CFP_FIELD_NONIP_UDF2_LEN  16
+#define CFP_FIELD_NONIP_UDF2_SHIFT  40
+#define CFP_FIELD_NONIP_UDF3_LEN  16
+#define CFP_FIELD_NONIP_UDF3_SHIFT  56
+#define CFP_FIELD_NONIP_UDF4_LEN  16
+#define CFP_FIELD_NONIP_UDF4_SHIFT  72
+#define CFP_FIELD_NONIP_UDF5_LEN  16
+#define CFP_FIELD_NONIP_UDF5_SHIFT  88
+#define CFP_FIELD_NONIP_UDF6_LEN  16
+#define CFP_FIELD_NONIP_UDF6_SHIFT  104
+#define CFP_FIELD_NONIP_UDF7_LEN  16
+#define CFP_FIELD_NONIP_UDF7_SHIFT  120
+#define CFP_FIELD_NONIP_UDF8_LEN  16
+#define CFP_FIELD_NONIP_UDF8_SHIFT  136
+#define CFP_FIELD_NONIP_CTAG_LEN  16
+#define CFP_FIELD_NONIP_CTAG_SHIFT  152
+#define CFP_FIELD_NONIP_STAG_LEN  16
+#define CFP_FIELD_NONIP_STAG_SHIFT  168
+#define CFP_FIELD_NONIP_UDF0_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF0_VLD_SHIFT  184
+#define CFP_FIELD_NONIP_UDF1_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF1_VLD_SHIFT  185
+#define CFP_FIELD_NONIP_UDF2_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF2_VLD_SHIFT  186
+#define CFP_FIELD_NONIP_UDF3_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF3_VLD_SHIFT  187
+#define CFP_FIELD_NONIP_UDF4_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF4_VLD_SHIFT  188
+#define CFP_FIELD_NONIP_UDF5_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF5_VLD_SHIFT  189
+#define CFP_FIELD_NONIP_UDF6_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF6_VLD_SHIFT  190
+#define CFP_FIELD_NONIP_UDF7_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF7_VLD_SHIFT  191
+#define CFP_FIELD_NONIP_UDF8_VLD_LEN  1
+#define CFP_FIELD_NONIP_UDF8_VLD_SHIFT  192
+#define CFP_FIELD_NONIP_ETHERTYPE_SAP_LEN  16
+#define CFP_FIELD_NONIP_ETHERTYPE_SAP_SHIFT  200
+#define CFP_FIELD_NONIP_L3_FRAMING_LEN  2
+#define CFP_FIELD_NONIP_L3_FRAMING_SHIFT  216
+#define CFP_FIELD_NONIP_L2_FRAMING_LEN  2
+#define CFP_FIELD_NONIP_L2_FRAMING_SHIFT  218
+#define CFP_FIELD_NONIP_C_TAGGED_LEN  2
+#define CFP_FIELD_NONIP_C_TAGGED_SHIFT  220
+#define CFP_FIELD_NONIP_S_TAGGED_LEN  2
+#define CFP_FIELD_NONIP_S_TAGGED_SHIFT  222
+#define CFP_FIELD_NONIP_SRC_PMAP_LEN  8
+#define CFP_FIELD_NONIP_SRC_PMAP_SHIFT  224
+
+/* CHAIN SLICE */
+#define CFP_FIELD_CHAIN_VALID_LEN  2
+#define CFP_FIELD_CHAIN_VALID_SHIFT  0
+#define CFP_FIELD_CHAIN_SLICE_ID_LEN  2
+#define CFP_FIELD_CHAIN_SLICE_ID_SHIFT  2
+#define CFP_FIELD_CHAIN_UDF0_LEN  16
+#define CFP_FIELD_CHAIN_UDF0_SHIFT  8
+#define CFP_FIELD_CHAIN_UDF1_LEN  16
+#define CFP_FIELD_CHAIN_UDF1_SHIFT  24
+#define CFP_FIELD_CHAIN_UDF2_LEN  16
+#define CFP_FIELD_CHAIN_UDF2_SHIFT  40
+#define CFP_FIELD_CHAIN_UDF3_LEN  16
+#define CFP_FIELD_CHAIN_UDF3_SHIFT  56
+#define CFP_FIELD_CHAIN_UDF4_LEN  16
+#define CFP_FIELD_CHAIN_UDF4_SHIFT  72
+#define CFP_FIELD_CHAIN_UDF5_LEN  16
+#define CFP_FIELD_CHAIN_UDF5_SHIFT  88
+#define CFP_FIELD_CHAIN_UDF6_LEN  16
+#define CFP_FIELD_CHAIN_UDF6_SHIFT  104
+#define CFP_FIELD_CHAIN_UDF7_LEN  16
+#define CFP_FIELD_CHAIN_UDF7_SHIFT  120
+#define CFP_FIELD_CHAIN_UDF8_LEN  16
+#define CFP_FIELD_CHAIN_UDF8_SHIFT  136
+#define CFP_FIELD_CHAIN_UDF9_LEN  16
+#define CFP_FIELD_CHAIN_UDF9_SHIFT  152
+#define CFP_FIELD_CHAIN_UDF10_LEN  16
+#define CFP_FIELD_CHAIN_UDF10_SHIFT  168
+#define CFP_FIELD_CHAIN_UDF11_LEN  16
+#define CFP_FIELD_CHAIN_UDF11_SHIFT  184
+#define CFP_FIELD_CHAIN_UDF0_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF0_VLD_SHIFT  200
+#define CFP_FIELD_CHAIN_UDF1_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF1_VLD_SHIFT  201
+#define CFP_FIELD_CHAIN_UDF2_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF2_VLD_SHIFT  202
+#define CFP_FIELD_CHAIN_UDF3_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF3_VLD_SHIFT  203
+#define CFP_FIELD_CHAIN_UDF4_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF4_VLD_SHIFT  204
+#define CFP_FIELD_CHAIN_UDF5_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF5_VLD_SHIFT  205
+#define CFP_FIELD_CHAIN_UDF6_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF6_VLD_SHIFT  206
+#define CFP_FIELD_CHAIN_UDF7_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF7_VLD_SHIFT  207
+#define CFP_FIELD_CHAIN_UDF8_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF8_VLD_SHIFT  208
+#define CFP_FIELD_CHAIN_UDF9_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF9_VLD_SHIFT  209
+#define CFP_FIELD_CHAIN_UDF10_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF10_VLD_SHIFT  210
+#define CFP_FIELD_CHAIN_UDF11_VLD_LEN  1
+#define CFP_FIELD_CHAIN_UDF11_VLD_SHIFT  211
+#define CFP_FIELD_CHAIN_CHAIN_ID_LEN  8
+#define CFP_FIELD_CHAIN_CHAIN_ID_SHIFT  216
+
+
+/* Action Ram */
+#define CFP_FIELD_ACTION_CHAIN_ID_LEN  8
+#define CFP_FIELD_ACTION_CHAIN_ID_SHIFT  0
+#define CFP_FIELD_ACTION_RX_CHANNEL_ID_LEN  4
+#define CFP_FIELD_ACTION_RX_CHANNEL_ID_SHIFT  8
+#define CFP_FIELD_ACTION_DROP_LEN  1
+#define CFP_FIELD_ACTION_DROP_SHIFT  12
+
+#define CFP_FIELD_INFO \
+{ \
+    {CFP_FIELD_IPV4_VALID_SHIFT, CFP_FIELD_IPV4_VALID_LEN}, \
+    {CFP_FIELD_IPV4_SLICE_ID_SHIFT, CFP_FIELD_IPV4_SLICE_ID_LEN}, \
+    {CFP_FIELD_IPV4_UDF0_SHIFT, CFP_FIELD_IPV4_UDF0_LEN}, \
+    {CFP_FIELD_IPV4_UDF1_SHIFT, CFP_FIELD_IPV4_UDF1_LEN}, \
+    {CFP_FIELD_IPV4_UDF2_SHIFT, CFP_FIELD_IPV4_UDF2_LEN}, \
+    {CFP_FIELD_IPV4_UDF3_SHIFT, CFP_FIELD_IPV4_UDF3_LEN}, \
+    {CFP_FIELD_IPV4_UDF4_SHIFT, CFP_FIELD_IPV4_UDF4_LEN}, \
+    {CFP_FIELD_IPV4_UDF5_SHIFT, CFP_FIELD_IPV4_UDF5_LEN}, \
+    {CFP_FIELD_IPV4_UDF6_SHIFT, CFP_FIELD_IPV4_UDF6_LEN}, \
+    {CFP_FIELD_IPV4_UDF7_SHIFT, CFP_FIELD_IPV4_UDF7_LEN}, \
+    {CFP_FIELD_IPV4_UDF8_SHIFT, CFP_FIELD_IPV4_UDF8_LEN}, \
+    {CFP_FIELD_IPV4_CTAG_SHIFT, CFP_FIELD_IPV4_CTAG_LEN}, \
+    {CFP_FIELD_IPV4_STAG_SHIFT, CFP_FIELD_IPV4_STAG_LEN}, \
+    {CFP_FIELD_IPV4_UDF0_VLD_SHIFT, CFP_FIELD_IPV4_UDF0_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF1_VLD_SHIFT, CFP_FIELD_IPV4_UDF1_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF2_VLD_SHIFT, CFP_FIELD_IPV4_UDF2_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF3_VLD_SHIFT, CFP_FIELD_IPV4_UDF3_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF4_VLD_SHIFT, CFP_FIELD_IPV4_UDF4_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF5_VLD_SHIFT, CFP_FIELD_IPV4_UDF5_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF6_VLD_SHIFT, CFP_FIELD_IPV4_UDF6_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF7_VLD_SHIFT, CFP_FIELD_IPV4_UDF7_VLD_LEN}, \
+    {CFP_FIELD_IPV4_UDF8_VLD_SHIFT, CFP_FIELD_IPV4_UDF8_VLD_LEN}, \
+    {CFP_FIELD_IPV4_TTL_RANGE_SHIFT, CFP_FIELD_IPV4_TTL_RANGE_LEN}, \
+    {CFP_FIELD_IPV4_IP_AUTH_SHIFT, CFP_FIELD_IPV4_IP_AUTH_LEN}, \
+    {CFP_FIELD_IPV4_NON_FIRST_FRAG_SHIFT, CFP_FIELD_IPV4_NON_FIRST_FRAG_LEN}, \
+    {CFP_FIELD_IPV4_IP_FRAG_SHIFT, CFP_FIELD_IPV4_IP_FRAG_LEN}, \
+    {CFP_FIELD_IPV4_IP_PROTO_SHIFT, CFP_FIELD_IPV4_IP_PROTO_LEN}, \
+    {CFP_FIELD_IPV4_IP_TOS_SHIFT, CFP_FIELD_IPV4_IP_TOS_LEN}, \
+    {CFP_FIELD_IPV4_L3_FRAMING_SHIFT, CFP_FIELD_IPV4_L3_FRAMING_LEN}, \
+    {CFP_FIELD_IPV4_L2_FRAMING_SHIFT, CFP_FIELD_IPV4_L2_FRAMING_LEN}, \
+    {CFP_FIELD_IPV4_C_TAGGED_SHIFT, CFP_FIELD_IPV4_C_TAGGED_LEN}, \
+    {CFP_FIELD_IPV4_S_TAGGED_SHIFT, CFP_FIELD_IPV4_S_TAGGED_LEN}, \
+    {CFP_FIELD_IPV4_SRC_PMAP_SHIFT, CFP_FIELD_IPV4_SRC_PMAP_LEN}, \
+    {CFP_FIELD_IPV6_VALID_SHIFT, CFP_FIELD_IPV6_VALID_LEN}, \
+    {CFP_FIELD_IPV6_SLICE_ID_SHIFT, CFP_FIELD_IPV6_SLICE_ID_LEN}, \
+    {CFP_FIELD_IPV6_UDF0_SHIFT, CFP_FIELD_IPV6_UDF0_LEN}, \
+    {CFP_FIELD_IPV6_UDF1_SHIFT, CFP_FIELD_IPV6_UDF1_LEN}, \
+    {CFP_FIELD_IPV6_UDF2_SHIFT, CFP_FIELD_IPV6_UDF2_LEN}, \
+    {CFP_FIELD_IPV6_UDF3_SHIFT, CFP_FIELD_IPV6_UDF3_LEN}, \
+    {CFP_FIELD_IPV6_UDF4_SHIFT, CFP_FIELD_IPV6_UDF4_LEN}, \
+    {CFP_FIELD_IPV6_UDF5_SHIFT, CFP_FIELD_IPV6_UDF5_LEN}, \
+    {CFP_FIELD_IPV6_UDF6_SHIFT, CFP_FIELD_IPV6_UDF6_LEN}, \
+    {CFP_FIELD_IPV6_UDF7_SHIFT, CFP_FIELD_IPV6_UDF7_LEN}, \
+    {CFP_FIELD_IPV6_UDF8_SHIFT, CFP_FIELD_IPV6_UDF8_LEN}, \
+    {CFP_FIELD_IPV6_CTAG_SHIFT, CFP_FIELD_IPV6_CTAG_LEN}, \
+    {CFP_FIELD_IPV6_STAG_SHIFT, CFP_FIELD_IPV6_STAG_LEN}, \
+    {CFP_FIELD_IPV6_UDF0_VLD_SHIFT, CFP_FIELD_IPV6_UDF0_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF1_VLD_SHIFT, CFP_FIELD_IPV6_UDF1_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF2_VLD_SHIFT, CFP_FIELD_IPV6_UDF2_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF3_VLD_SHIFT, CFP_FIELD_IPV6_UDF3_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF4_VLD_SHIFT, CFP_FIELD_IPV6_UDF4_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF5_VLD_SHIFT, CFP_FIELD_IPV6_UDF5_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF6_VLD_SHIFT, CFP_FIELD_IPV6_UDF6_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF7_VLD_SHIFT, CFP_FIELD_IPV6_UDF7_VLD_LEN}, \
+    {CFP_FIELD_IPV6_UDF8_VLD_SHIFT, CFP_FIELD_IPV6_UDF8_VLD_LEN}, \
+    {CFP_FIELD_IPV6_HOPLIMIT_RANGE_SHIFT, CFP_FIELD_IPV6_HOPLIMIT_RANGE_LEN}, \
+    {CFP_FIELD_IPV6_IP_AUTH_SHIFT, CFP_FIELD_IPV6_IP_AUTH_LEN}, \
+    {CFP_FIELD_IPV6_NON_FIRST_FRAG_SHIFT, CFP_FIELD_IPV6_NON_FIRST_FRAG_LEN}, \
+    {CFP_FIELD_IPV6_IP_FRAG_SHIFT, CFP_FIELD_IPV6_IP_FRAG_LEN}, \
+    {CFP_FIELD_IPV6_IP_PROTO_SHIFT, CFP_FIELD_IPV6_IP_PROTO_LEN}, \
+    {CFP_FIELD_IPV6_IP_TOS_SHIFT, CFP_FIELD_IPV6_IP_TOS_LEN}, \
+    {CFP_FIELD_IPV6_L3_FRAMING_SHIFT, CFP_FIELD_IPV6_L3_FRAMING_LEN}, \
+    {CFP_FIELD_IPV6_L2_FRAMING_SHIFT, CFP_FIELD_IPV6_L2_FRAMING_LEN}, \
+    {CFP_FIELD_IPV6_C_TAGGED_SHIFT, CFP_FIELD_IPV6_C_TAGGED_LEN}, \
+    {CFP_FIELD_IPV6_S_TAGGED_SHIFT, CFP_FIELD_IPV6_S_TAGGED_LEN}, \
+    {CFP_FIELD_IPV6_SRC_PMAP_SHIFT, CFP_FIELD_IPV6_SRC_PMAP_LEN}, \
+    {CFP_FIELD_NONIP_VALID_SHIFT, CFP_FIELD_NONIP_VALID_LEN}, \
+    {CFP_FIELD_NONIP_SLICE_ID_SHIFT, CFP_FIELD_NONIP_SLICE_ID_LEN}, \
+    {CFP_FIELD_NONIP_UDF0_SHIFT, CFP_FIELD_NONIP_UDF0_LEN}, \
+    {CFP_FIELD_NONIP_UDF1_SHIFT, CFP_FIELD_NONIP_UDF1_LEN}, \
+    {CFP_FIELD_NONIP_UDF2_SHIFT, CFP_FIELD_NONIP_UDF2_LEN}, \
+    {CFP_FIELD_NONIP_UDF3_SHIFT, CFP_FIELD_NONIP_UDF3_LEN}, \
+    {CFP_FIELD_NONIP_UDF4_SHIFT, CFP_FIELD_NONIP_UDF4_LEN}, \
+    {CFP_FIELD_NONIP_UDF5_SHIFT, CFP_FIELD_NONIP_UDF5_LEN}, \
+    {CFP_FIELD_NONIP_UDF6_SHIFT, CFP_FIELD_NONIP_UDF6_LEN}, \
+    {CFP_FIELD_NONIP_UDF7_SHIFT, CFP_FIELD_NONIP_UDF7_LEN}, \
+    {CFP_FIELD_NONIP_UDF8_SHIFT, CFP_FIELD_NONIP_UDF8_LEN}, \
+    {CFP_FIELD_NONIP_CTAG_SHIFT, CFP_FIELD_NONIP_CTAG_LEN}, \
+    {CFP_FIELD_NONIP_STAG_SHIFT, CFP_FIELD_NONIP_STAG_LEN}, \
+    {CFP_FIELD_NONIP_UDF0_VLD_SHIFT, CFP_FIELD_NONIP_UDF0_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF1_VLD_SHIFT, CFP_FIELD_NONIP_UDF1_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF2_VLD_SHIFT, CFP_FIELD_NONIP_UDF2_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF3_VLD_SHIFT, CFP_FIELD_NONIP_UDF3_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF4_VLD_SHIFT, CFP_FIELD_NONIP_UDF4_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF5_VLD_SHIFT, CFP_FIELD_NONIP_UDF5_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF6_VLD_SHIFT, CFP_FIELD_NONIP_UDF6_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF7_VLD_SHIFT, CFP_FIELD_NONIP_UDF7_VLD_LEN}, \
+    {CFP_FIELD_NONIP_UDF8_VLD_SHIFT, CFP_FIELD_NONIP_UDF8_VLD_LEN}, \
+    {CFP_FIELD_NONIP_ETHERTYPE_SAP_SHIFT, CFP_FIELD_NONIP_ETHERTYPE_SAP_LEN}, \
+    {CFP_FIELD_NONIP_L3_FRAMING_SHIFT, CFP_FIELD_NONIP_L3_FRAMING_LEN}, \
+    {CFP_FIELD_NONIP_L2_FRAMING_SHIFT, CFP_FIELD_NONIP_L2_FRAMING_LEN}, \
+    {CFP_FIELD_NONIP_C_TAGGED_SHIFT, CFP_FIELD_NONIP_C_TAGGED_LEN}, \
+    {CFP_FIELD_NONIP_S_TAGGED_SHIFT, CFP_FIELD_NONIP_S_TAGGED_LEN}, \
+    {CFP_FIELD_NONIP_SRC_PMAP_SHIFT, CFP_FIELD_NONIP_SRC_PMAP_LEN}, \
+    {CFP_FIELD_CHAIN_VALID_SHIFT, CFP_FIELD_CHAIN_VALID_LEN}, \
+    {CFP_FIELD_CHAIN_SLICE_ID_SHIFT, CFP_FIELD_CHAIN_SLICE_ID_LEN}, \
+    {CFP_FIELD_CHAIN_UDF0_SHIFT, CFP_FIELD_CHAIN_UDF0_LEN}, \
+    {CFP_FIELD_CHAIN_UDF1_SHIFT, CFP_FIELD_CHAIN_UDF1_LEN}, \
+    {CFP_FIELD_CHAIN_UDF2_SHIFT, CFP_FIELD_CHAIN_UDF2_LEN}, \
+    {CFP_FIELD_CHAIN_UDF3_SHIFT, CFP_FIELD_CHAIN_UDF3_LEN}, \
+    {CFP_FIELD_CHAIN_UDF4_SHIFT, CFP_FIELD_CHAIN_UDF4_LEN}, \
+    {CFP_FIELD_CHAIN_UDF5_SHIFT, CFP_FIELD_CHAIN_UDF5_LEN}, \
+    {CFP_FIELD_CHAIN_UDF6_SHIFT, CFP_FIELD_CHAIN_UDF6_LEN}, \
+    {CFP_FIELD_CHAIN_UDF7_SHIFT, CFP_FIELD_CHAIN_UDF7_LEN}, \
+    {CFP_FIELD_CHAIN_UDF8_SHIFT, CFP_FIELD_CHAIN_UDF8_LEN}, \
+    {CFP_FIELD_CHAIN_UDF9_SHIFT, CFP_FIELD_CHAIN_UDF9_LEN}, \
+    {CFP_FIELD_CHAIN_UDF10_SHIFT, CFP_FIELD_CHAIN_UDF10_LEN}, \
+    {CFP_FIELD_CHAIN_UDF11_SHIFT, CFP_FIELD_CHAIN_UDF11_LEN}, \
+    {CFP_FIELD_CHAIN_UDF0_VLD_SHIFT, CFP_FIELD_CHAIN_UDF0_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF1_VLD_SHIFT, CFP_FIELD_CHAIN_UDF1_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF2_VLD_SHIFT, CFP_FIELD_CHAIN_UDF2_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF3_VLD_SHIFT, CFP_FIELD_CHAIN_UDF3_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF4_VLD_SHIFT, CFP_FIELD_CHAIN_UDF4_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF5_VLD_SHIFT, CFP_FIELD_CHAIN_UDF5_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF6_VLD_SHIFT, CFP_FIELD_CHAIN_UDF6_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF7_VLD_SHIFT, CFP_FIELD_CHAIN_UDF7_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF8_VLD_SHIFT, CFP_FIELD_CHAIN_UDF8_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF9_VLD_SHIFT, CFP_FIELD_CHAIN_UDF9_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF10_VLD_SHIFT, CFP_FIELD_CHAIN_UDF10_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_UDF11_VLD_SHIFT, CFP_FIELD_CHAIN_UDF11_VLD_LEN}, \
+    {CFP_FIELD_CHAIN_CHAIN_ID_SHIFT, CFP_FIELD_CHAIN_CHAIN_ID_LEN}, \
+    {CFP_FIELD_ACTION_CHAIN_ID_SHIFT, CFP_FIELD_ACTION_CHAIN_ID_LEN}, \
+    {CFP_FIELD_ACTION_RX_CHANNEL_ID_SHIFT, CFP_FIELD_ACTION_RX_CHANNEL_ID_LEN}, \
+    {CFP_FIELD_ACTION_DROP_SHIFT, CFP_FIELD_ACTION_DROP_LEN}, \
+}
+
+/* Definition for CFP for GMAC */
+
+/* operation type */
+#define CFP_TCAM_OP_READ    0x1
+#define CFP_TCAM_OP_WRITE    0x2
+
+/* RAM Type */
+#define CFP_RAM_TYPE_TCAM    0x1
+#define CFP_RAM_TYPE_TCAM_MASK    0x2
+#define CFP_RAM_TYPE_ACTION    0x3
+
+/* HW Ram Type value */
+#define CFP_RAM_HW_TCAM     0x1
+#define CFP_RAM_HW_ACTION   0x2
+
+/* L3 FRAMING */
+#define CFP_L3_FRAMING_IPV4    0x0
+#define CFP_L3_FRAMING_IPV6    0x1
+#define CFP_L3_FRAMING_NONIP    0x3
+
+#define CFP_IPV4_MAX_SLICE_ID        0x2
+#define CFP_IPV6_MAX_SLICE_ID        0x3
+#define CFP_NONIP_MAX_SLICE_ID        0x2
+
+/* UDF Offset Base flags*/
+#define CFP_UDF_OFFSET_BASE_STARTOFFRAME    0x0
+#define CFP_UDF_OFFSET_BASE_ENDOFL2    0x40
+#define CFP_UDF_OFFSET_BASE_ENDOFL3    0x60
+
+/* bit 0~4 is the UDF offset base value */
+#define CFP_UDF_OFFSET_BASE_VALUE_MASK    0x1f
+#define CFP_UDF_OFFSET_BASE_VALUE_SHIFT    0
+/* bit 5~7 is the UDF offset base flags value */
+#define CFP_UDF_OFFSET_BASE_FLAGS_MASK    0x7
+#define CFP_UDF_OFFSET_BASE_FLAGS_SHIFT    5
+
+#define CFP_TCAM_ENTRY_LEN    230
+#define CFP_TCAM_ENTRY_WORD     (CFP_TCAM_ENTRY_LEN + 31) / 32
+
+typedef struct cfp_hw_entry {
+    uint32 tcam[CFP_TCAM_ENTRY_WORD];
+    uint32 tcam_mask[CFP_TCAM_ENTRY_WORD];
+    uint32 action;
+} cfp_hw_entry_t;
+
+typedef struct cfp_ioctl_buf {
+    uint32 entry_idx;		/* CFP entry index */
+    uint32 ram_type;		/* RAM TYPE */
+    uint32 l3_framing;		/* L3 FRAMING TYPE */
+    uint32 slice_id;		/* SLICE ID number */
+    uint32 field_idx;		/* CFP Field index */
+    uint32 field_value;		/* CFP Field value */
+    uint32 flags;		/* UDF Offset flags */
+    cfp_hw_entry_t cfp_entry;	/* CFP raw data */
+} cfp_ioctl_buf_t;
+
+
+#define CFP_TCAM_NUM 128
+#define CFP_RETRY_TIME  100
+
+#define RX_RATE_MAX_MAP_VALUE   63
+#define RX_RATE_VALUE_MAPPING \
+{ 384, 512, 640, 768, 1024, 1280, 1536, 1792, 2304, 2816, \
+   3328, 3840, 4864, 5888, 6912, 7936, 9984, 12032, 14080, 16128, \
+   20224, 24320, 28416, 32512, 40704, 48896, 57088, 65280, 81664, 98048, \
+   114432, 130816, 147200, 163584, 179968, 196352, 212736, 229120, 245504, \
+   261888, 278272, 294656, 311040, 327424, 343808, 360192, 376576, 392960, \
+   409344, 442112, 474880, 507648, 540416, 573184, 605952, 638720, \
+   671488, 704256, 835328, 966400, 1097472, 1228544, 1359616, 1490688 }
+
+
+
+#define TX_RATE_VALUE_BASE   64000
+#define TX_RATE_BURST_BASE    64
+
+
+#define MAX_PRIVATE_TAG_VALUE   7
+
+#endif				/* _etcgmac_h_ */
diff --git a/include/asm-mips/bcmsi/bcmgmacmib.h b/include/asm-mips/bcmsi/bcmgmacmib.h
new file mode 100644
index 0000000..1096694
--- /dev/null
+++ b/include/asm-mips/bcmsi/bcmgmacmib.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * Hardware-specific MIB definition for
+ * Broadcom Home Networking Division
+ * GbE Unimac core
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#ifndef	_bcmgmacmib_h_
+#define	_bcmgmacmib_h_
+
+
+/* cpp contortions to concatenate w/arg prescan */
+#ifndef PAD
+#define	_PADLINE(line)	pad ## line
+#define	_XSTR(line)	_PADLINE(line)
+#define	PAD		_XSTR(__LINE__)
+#endif				/* PAD */
+
+/* GMAC MIB structure */
+
+typedef struct _gmacmib {
+    uint32 tx_good_octets;	/* 0x300 */
+    uint32 tx_good_octets_high;	/* 0x304 */
+    uint32 tx_good_pkts;	/* 0x308 */
+    uint32 tx_octets;		/* 0x30c */
+    uint32 tx_octets_high;	/* 0x310 */
+    uint32 tx_pkts;		/* 0x314 */
+    uint32 tx_broadcast_pkts;	/* 0x318 */
+    uint32 tx_multicast_pkts;	/* 0x31c */
+    uint32 tx_uni_pkts;		/* 0x320 */
+    uint32 tx_len_64;		/* 0x324 */
+    uint32 tx_len_65_to_127;	/* 0x328 */
+    uint32 tx_len_128_to_255;	/* 0x32c */
+    uint32 tx_len_256_to_511;	/* 0x330 */
+    uint32 tx_len_512_to_1023;	/* 0x334 */
+    uint32 tx_len_1024_to_max;	/* 0x338 */
+    uint32 tx_len_max_to_jumbo;	/* 0x33c */
+    uint32 tx_jabber_pkts;	/* 0x340 */
+    uint32 tx_oversize_pkts;	/* 0x344 */
+    uint32 tx_fragment_pkts;	/* 0x348 */
+    uint32 tx_underruns;	/* 0x34c */
+    uint32 tx_total_cols;	/* 0x350 */
+    uint32 tx_single_cols;	/* 0x354 */
+    uint32 tx_multiple_cols;	/* 0x358 */
+    uint32 tx_excessive_cols;	/* 0x35c */
+    uint32 tx_late_cols;	/* 0x360 */
+    uint32 tx_defered;		/* 0x364 */
+    uint32 tx_pause_pkts;	/* 0x368 */
+    uint32 PAD[5];
+    uint32 rx_good_octets;	/* 0x380 */
+    uint32 rx_good_octets_high;	/* 0x384 */
+    uint32 rx_good_pkts;	/* 0x388 */
+    uint32 rx_octets;		/* 0x38c */
+    uint32 rx_octets_high;	/* 0x390 */
+    uint32 rx_pkts;		/* 0x394 */
+    uint32 rx_broadcast_pkts;	/* 0x398 */
+    uint32 rx_multicast_pkts;	/* 0x39c */
+    uint32 rx_uni_pkts;		/* 0x3a0 */
+    uint32 rx_len_64;		/* 0x3a4 */
+    uint32 rx_len_65_to_127;	/* 0x3a8 */
+    uint32 rx_len_128_to_255;	/* 0x3ac */
+    uint32 rx_len_256_to_511;	/* 0x3b0 */
+    uint32 rx_len_512_to_1023;	/* 0x3b4 */
+    uint32 rx_len_1024_to_max;	/* 0x3b8 */
+    uint32 rx_len_max_to_jumbo;	/* 0x3bc */
+    uint32 rx_jabber_pkts;	/* 0x3c0 */
+    uint32 rx_oversize_pkts;	/* 0x3c4 */
+    uint32 rx_fragment_pkts;	/* 0x3c8 */
+    uint32 rx_missed_pkts;	/* 0x3cc */
+    uint32 rx_undersize;	/* 0x3d0 */
+    uint32 rx_crc_errs;		/* 0x3d4 */
+    uint32 rx_align_errs;	/* 0x3d8 */
+    uint32 rx_symbol_errs;	/* 0x3dc */
+    uint32 rx_pause_pkts;	/* 0x3e0 */
+    uint32 rx_nonpause_pkts;	/* 0x3e4 */
+    uint32 rxq0_irc_drop;	/* 0x3e8 */
+    uint32 rxq1_irc_drop;	/* 0x3ec */
+    uint32 rxq2_irc_drop;	/* 0x3f0 */
+    uint32 rxq3_irc_drop;	/* 0x3f4 */
+    uint32 rx_cfp_drop;		/* 0x3f8 */
+} gmacmib_t;
+
+#define	GM_MIB_BASE		0x300
+#define	GM_MIB_LIMIT		0x800
+
+#endif				/* _bcmgmacmib_h_ */
diff --git a/include/asm-mips/bcmsi/etioctl.h b/include/asm-mips/bcmsi/etioctl.h
new file mode 100644
index 0000000..a1c2622
--- /dev/null
+++ b/include/asm-mips/bcmsi/etioctl.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * BCM44XX Ethernet Windows device driver custom OID definitions.
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#ifndef _etioctl_h_
+#define	_etioctl_h_
+
+/*
+ * Minor kludge alert:
+ * Duplicate a few definitions that irelay requires from epiioctl.h here
+ * so caller doesn't have to include this file and epiioctl.h .
+ * If this grows any more, it would be time to move these irelay-specific
+ * definitions out of the epiioctl.h and into a separate driver common file.
+ */
+#ifndef EPICTRL_COOKIE
+#define EPICTRL_COOKIE		0xABADCEDE
+#endif
+
+/* common ioctl definitions */
+#define	ETCUP		0
+#define	ETCDOWN		1
+#define ETCLOOP		2
+#define ETCDUMP		3
+#define ETCSETMSGLEVEL	4
+#define	ETCPROMISC	5
+#define	ETCSPEED	7
+#define ETCPHYRD	9
+#define ETCPHYWR	10
+#define	ETCQOS		11
+#define ETCPHYRD2	12
+#define ETCPHYWR2	13
+#define ETCROBORD	14
+#define ETCROBOWR	15
+#define ETCCFPRD	16
+#define ETCCFPWR      17
+#define ETCCFPFIELDRD	18
+#define ETCCFPFIELDWR      19
+#define ETCCFPUDFRD	 20
+#define ETCCFPUDFWR      21
+#define ETCPKTMEMGET    22
+#define ETCPKTMEMSET    23
+#define ETCPKTHDRMEMGET 24
+#define ETCPKTHDRMEMSET 25
+#define ETCRXRATE 26
+#define ETCTXRATE 27
+#define ETCFLOWCTRLMODE 28
+#define ETCFLOWCTRLAUTOSET 29
+#define ETCFLOWCTRLCPUSET 30
+#define ETCFLOWCTRLRXCHANSET 31
+#define ETCTPID 32
+#define ETCPVTAG 33
+#define ETCRXSEPHDR    34
+#define ETCTXQOSMODE    35
+#define ETCTXQOSWEIGHTSET    36
+
+#if defined(linux)
+#define SIOCSETCUP		(SIOCDEVPRIVATE + ETCUP)
+#define SIOCSETCDOWN		(SIOCDEVPRIVATE + ETCDOWN)
+#define SIOCSETCLOOP		(SIOCDEVPRIVATE + ETCLOOP)
+#define SIOCGETCDUMP		(SIOCDEVPRIVATE + ETCDUMP)
+#define SIOCSETCSETMSGLEVEL	(SIOCDEVPRIVATE + ETCSETMSGLEVEL)
+#define SIOCSETCPROMISC		(SIOCDEVPRIVATE + ETCPROMISC)
+#define SIOCSETCTXDOWN		(SIOCDEVPRIVATE + 6)	/* obsolete */
+#define SIOCSETCSPEED		(SIOCDEVPRIVATE + ETCSPEED)
+#define SIOCTXGEN		(SIOCDEVPRIVATE + 8)
+#define SIOCGETCPHYRD		(SIOCDEVPRIVATE + ETCPHYRD)
+#define SIOCSETCPHYWR		(SIOCDEVPRIVATE + ETCPHYWR)
+#define SIOCSETCQOS		(SIOCDEVPRIVATE + ETCQOS)
+#define SIOCGETCPHYRD2		(SIOCDEVPRIVATE + ETCPHYRD2)
+#define SIOCSETCPHYWR2		(SIOCDEVPRIVATE + ETCPHYWR2)
+#define SIOCGETCROBORD		(SIOCDEVPRIVATE + ETCROBORD)
+#define SIOCSETCROBOWR		(SIOCDEVPRIVATE + ETCROBOWR)
+
+/* arg to SIOCTXGEN */
+struct txg {
+    uint32 num;			/* number of frames to send */
+    uint32 delay;		/* delay in microseconds between sending each */
+    uint32 size;		/* size of ether frame to send */
+    uchar buf[1514];		/* starting ether frame data */
+};
+#endif				/* linux */
+
+#if  defined(vxworks)
+/* Broadcom's IOCTL for enabling QOS in the Ethernet driver */
+#define EIOCQOS _IOWR('e', 200, int)
+
+#endif				/* vxworks */
+
+/*
+ * custom OID support
+ *
+ * 0xFF - implementation specific OID
+ * 0xE4 - first byte of Broadcom PCI vendor ID
+ * 0x14 - second byte of Broadcom PCI vendor ID
+ * 0xXX - the custom OID number
+ */
+#define ET_OID_BASE		0xFFE41400	/* OID Base for ET */
+
+#define	OID_ET_UP				(ET_OID_BASE + ETCUP)
+#define	OID_ET_DOWN				(ET_OID_BASE + ETCDOWN)
+#define	OID_ET_LOOP				(ET_OID_BASE + ETCLOOP)
+#define	OID_ET_DUMP				(ET_OID_BASE + ETCDUMP)
+#define	OID_ET_SETMSGLEVEL			(ET_OID_BASE + ETCSETMSGLEVEL)
+#define	OID_ET_PROMISC				(ET_OID_BASE + ETCPROMISC)
+#define	OID_ET_TXDOWN				(ET_OID_BASE + 6)
+#define	OID_ET_SPEED				(ET_OID_BASE + ETCSPEED)
+#define	OID_ET_GETINSTANCE			(ET_OID_BASE + 8)
+#define	OID_ET_SETCALLBACK			(ET_OID_BASE + 9)
+#define	OID_ET_UNSETCALLBACK			(ET_OID_BASE + 10)
+
+#define IS_ET_OID(oid) (((oid) & 0xFFFFFF00) == 0xFFE41400)
+
+#define	ET_ISQUERYOID(oid)	((oid == OID_ET_DUMP) || (oid == OID_ET_GETINSTANCE))
+
+/* OID_ET_SETCALLBACK data type */
+typedef struct et_cb {
+    void (*fn) (void *, int);	/* Callback function */
+    void *context;		/* Passed to callback function */
+} et_cb_t;
+
+#endif				/* _etioctl_h_ */
diff --git a/include/asm-mips/bcmsi/gmac0_core.h b/include/asm-mips/bcmsi/gmac0_core.h
new file mode 100644
index 0000000..2fa4ff4
--- /dev/null
+++ b/include/asm-mips/bcmsi/gmac0_core.h
@@ -0,0 +1,1233 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * gmacdefs - Broadcom gmac (Unimac) specific definitions
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#ifndef _gmac0_core_h_
+#define _gmac0_core_h_
+
+#ifndef PAD
+#define     _PADLINE(line)    pad ## line
+#define     _XSTR(line)     _PADLINE(line)
+#define     PAD     XSTR(__LINE__)
+#endif
+
+typedef volatile struct _gmac0regs {
+    uint32 devcontrol;
+    uint32 devstatus;
+    uint32 PAD[1];
+    uint32 biststatus;
+    uint32 PAD[4];
+    uint32 intstatus;
+    uint32 intmask;
+    uint32 gptimer;
+    uint32 PAD[1];
+    uint32 rx_ch0_flow_ctrl;
+    uint32 rx_ch1_flow_ctrl;
+    uint32 rx_ch2_flow_ctrl;
+    uint32 rx_ch3_flow_ctrl;
+    uint32 desc_flow_ctrl_ps_stat;
+    uint32 PAD[47];
+    uint32 intrecvlazy;
+    uint32 flowctlthresh;
+    uint32 txqos;
+    uint32 gmac_idle_cnt_thresh;
+    uint32 PAD[4];
+    uint32 fifoaccessaddr;
+    uint32 fifoaccessbyte;
+    uint32 fifoaccessdata;
+    uint32 PAD[1];
+    uint32 irc_cfg;
+    uint32 PAD[1];
+    uint32 erc0_cfg;
+    uint32 erc1_cfg;
+    uint32 erc2_cfg;
+    uint32 erc3_cfg;
+    uint32 PAD[2];
+    uint32 xmt0launch;
+    uint32 xmt1launch;
+    uint32 xmt2launch;
+    uint32 xmt3launch;
+    uint32 PAD[11];
+    uint32 txqctl;
+    uint32 rxqctl;
+    uint32 gpioselect;
+    uint32 gpio_output_en;
+    uint32 PAD[17];
+    uint32 clk_ctl_st;
+    uint32 PAD[1];
+    uint32 pwrctl;
+    uint32 PAD[5];
+    uint32 d64xmt0control;
+    uint32 d64xmt0ptr;
+    uint32 d64xmt0addrlow;
+    uint32 d64xmt0addrhigh;
+    uint32 d64xmt0status0;
+    uint32 d64xmt0status1;
+    uint32 PAD[2];
+    uint32 d64rcv0control;
+    uint32 d64rcv0ptr;
+    uint32 d64rcv0addrlow;
+    uint32 d64rcv0addrhigh;
+    uint32 d64rcv0status0;
+    uint32 d64rcv0status1;
+    uint32 PAD[2];
+    uint32 d64xmt1control;
+    uint32 d64xmt1ptr;
+    uint32 d64xmt1addrlow;
+    uint32 d64xmt1addrhigh;
+    uint32 d64xmt1status0;
+    uint32 d64xmt1status1;
+    uint32 PAD[2];
+    uint32 d64rcv1control;
+    uint32 d64rcv1ptr;
+    uint32 d64rcv1addrlow;
+    uint32 d64rcv1addrhigh;
+    uint32 d64rcv1status0;
+    uint32 d64rcv1status1;
+    uint32 PAD[2];
+    uint32 d64xmt2control;
+    uint32 d64xmt2ptr;
+    uint32 d64xmt2addrlow;
+    uint32 d64xmt2addrhigh;
+    uint32 d64xmt2status0;
+    uint32 d64xmt2status1;
+    uint32 PAD[2];
+    uint32 d64rcv2control;
+    uint32 d64rcv2ptr;
+    uint32 d64rcv2addrlow;
+    uint32 d64rcv2addrhigh;
+    uint32 d64rcv2status0;
+    uint32 d64rcv2status1;
+    uint32 PAD[2];
+    uint32 d64xmt3control;
+    uint32 d64xmt3ptr;
+    uint32 d64xmt3addrlow;
+    uint32 d64xmt3addrhigh;
+    uint32 d64xmt3status0;
+    uint32 d64xmt3status1;
+    uint32 PAD[2];
+    uint32 d64rcv3control;
+    uint32 d64rcv3ptr;
+    uint32 d64rcv3addrlow;
+    uint32 d64rcv3addrhigh;
+    uint32 d64rcv3status0;
+    uint32 d64rcv3status1;
+    uint32 PAD[2];
+    uint32 tx_good_octets;
+    uint32 tx_good_octets_high;
+    uint32 tx_good_pkts;
+    uint32 tx_octets;
+    uint32 tx_octets_high;
+    uint32 tx_pkts;
+    uint32 tx_broadcast_pkts;
+    uint32 tx_multicast_pkts;
+    uint32 tx_uni_pkts;
+    uint32 tx_len_64;
+    uint32 tx_len_65_to_127;
+    uint32 tx_len_128_to_255;
+    uint32 tx_len_256_to_511;
+    uint32 tx_len_512_to_1023;
+    uint32 tx_len_1024_to_max;
+    uint32 tx_len_max_to_jumbo;
+    uint32 tx_jabber_pkts;
+    uint32 tx_oversize_pkts;
+    uint32 tx_fragment_pkts;
+    uint32 tx_underruns;
+    uint32 tx_total_cols;
+    uint32 tx_single_cols;
+    uint32 tx_mulitple_cols;
+    uint32 tx_excessive_cols;
+    uint32 tx_late_cols;
+    uint32 tx_defered;
+    uint32 tx_pause_pkts;
+    uint32 PAD[5];
+    uint32 rx_good_octets;
+    uint32 rx_good_octets_high;
+    uint32 rx_good_pkts;
+    uint32 rx_octets;
+    uint32 rx_octets_high;
+    uint32 rx_pkts;
+    uint32 rx_broadcast_pkts;
+    uint32 rx_multicast_pkts;
+    uint32 rx_uni_pkts;
+    uint32 rx_len_64;
+    uint32 rx_len_65_to_127;
+    uint32 rx_len_128_to_255;
+    uint32 rx_len_256_to_511;
+    uint32 rx_len_512_to_1023;
+    uint32 rx_len_1024_to_max;
+    uint32 rx_len_max_to_jumbo;
+    uint32 rx_jabber_pkts;
+    uint32 rx_oversize_pkts;
+    uint32 rx_fragment_pkts;
+    uint32 rx_missed_pkts;
+    uint32 rx_undersize;
+    uint32 rx_crc_errs;
+    uint32 rx_align_errs;
+    uint32 rx_symbol_errs;
+    uint32 rx_pause_pkts;
+    uint32 rx_nonpause_pkts;
+    uint32 rxq0_irc_drop;
+    uint32 rxq1_irc_drop;
+    uint32 rxq2_irc_drop;
+    uint32 rxq3_irc_drop;
+    uint32 rx_cfp_drop;
+    uint32 PAD[257];
+    uint32 core_version;
+    uint32 ipg_hd_bkp_cntl;
+    uint32 command_config;
+    uint32 mac_0;
+    uint32 mac_1;
+    uint32 frm_length;
+    uint32 pause_quant;
+    uint32 PAD[10];
+    uint32 mac_mode;
+    uint32 PAD[5];
+    uint32 tx_ipg_length;
+    uint32 PAD[174];
+    uint32 ts_status_cntrl;
+    uint32 tx_ts_data;
+    uint32 PAD[4];
+    uint32 pause_control;
+    uint32 flush_control;
+    uint32 rxfifo_stat;
+    uint32 txfifo_stat;
+} gmac0regs_t;
+
+/*  devcontrol offset0x0  */
+#define 	DEVCONTROL_PV_TAG_SHIFT	20
+#define 	DEVCONTROL_PV_TAG_MASK	0x700000
+#define 	DEVCONTROL_RESERVED3_SHIFT	18
+#define 	DEVCONTROL_RESERVED3_MASK	0xc0000
+#define 	DEVCONTROL_RESERVED2_SHIFT	16
+#define 	DEVCONTROL_RESERVED2_MASK	0x30000
+#define 	DEVCONTROL_TXQ_FLUSH_SHIFT	8
+#define 	DEVCONTROL_TXQ_FLUSH_MASK	0x100
+#define 	DEVCONTROL_FLOW_CTRL_MODE_SHIFT	5
+#define 	DEVCONTROL_FLOW_CTRL_MODE_MASK	0x60
+#define 	DEVCONTROL_MIB_RESET_ON_READ_SHIFT	4
+#define 	DEVCONTROL_MIB_RESET_ON_READ_MASK	0x10
+#define 	DEVCONTROL_CPU_FLOW_CTRL_ON_SHIFT	2
+#define 	DEVCONTROL_CPU_FLOW_CTRL_ON_MASK	0x4
+#define 	DEVCONTROL_SW_LINK_SHIFT	1
+#define 	DEVCONTROL_SW_LINK_MASK	0x2
+#define 	DEVCONTROL_SW_OVR_SHIFT	0
+#define 	DEVCONTROL_SW_OVR_MASK	0x1
+
+/*  devstatus offset0x4  */
+#define 	DEVSTATUS_MII_MODE_SHIFT	8
+#define 	DEVSTATUS_MII_MODE_MASK	0x300
+#define 	DEVSTATUS_PAUSE_ON_SHIFT	6
+#define 	DEVSTATUS_PAUSE_ON_MASK	0x40
+#define 	DEVSTATUS_TXQ_INFO_FULL_SHIFT	5
+#define 	DEVSTATUS_TXQ_INFO_FULL_MASK	0x20
+#define 	DEVSTATUS_TXQ_DATA_FULL_SHIFT	4
+#define 	DEVSTATUS_TXQ_DATA_FULL_MASK	0x10
+#define 	DEVSTATUS_TXQ_BURST_FULL_SHIFT	3
+#define 	DEVSTATUS_TXQ_BURST_FULL_MASK	0x8
+#define 	DEVSTATUS_RXQ_INFO_FULL_SHIFT	2
+#define 	DEVSTATUS_RXQ_INFO_FULL_MASK	0x4
+#define 	DEVSTATUS_RXQ_DATA_FULL_SHIFT	1
+#define 	DEVSTATUS_RXQ_DATA_FULL_MASK	0x2
+#define 	DEVSTATUS_RXQ_BURST_FULL_SHIFT	0
+#define 	DEVSTATUS_RXQ_BURST_FULL_MASK	0x1
+
+/*  biststatus offset0xc  */
+#define 	BISTSTATUS_UNIMAC_RX_FIFO_SHIFT	10
+#define 	BISTSTATUS_UNIMAC_RX_FIFO_MASK	0x400
+#define 	BISTSTATUS_UNIMAC_TX_FIFO_SHIFT	9
+#define 	BISTSTATUS_UNIMAC_TX_FIFO_MASK	0x200
+#define 	BISTSTATUS_UNIMAC_RE_TX_FIFO_SHIFT	8
+#define 	BISTSTATUS_UNIMAC_RE_TX_FIFO_MASK	0x100
+#define 	BISTSTATUS_RXQ_BURST_FIFO_SHIFT	7
+#define 	BISTSTATUS_RXQ_BURST_FIFO_MASK	0x80
+#define 	BISTSTATUS_RXQ_INFO_BUFFER_SHIFT	6
+#define 	BISTSTATUS_RXQ_INFO_BUFFER_MASK	0x40
+#define 	BISTSTATUS_RXQ_DATA_BUFFER_SHIFT	5
+#define 	BISTSTATUS_RXQ_DATA_BUFFER_MASK	0x20
+#define 	BISTSTATUS_TXQ_BURST_FIFO_SHIFT	4
+#define 	BISTSTATUS_TXQ_BURST_FIFO_MASK	0x10
+#define 	BISTSTATUS_TXQ_INFO_BUFFER_SHIFT	3
+#define 	BISTSTATUS_TXQ_INFO_BUFFER_MASK	0x8
+#define 	BISTSTATUS_TXQ_DATA_BUFFER_SHIFT	2
+#define 	BISTSTATUS_TXQ_DATA_BUFFER_MASK	0x4
+#define 	BISTSTATUS_MIB_RX_FIFO_SHIFT	1
+#define 	BISTSTATUS_MIB_RX_FIFO_MASK	0x2
+#define 	BISTSTATUS_MIB_TX_FIFO_SHIFT	0
+#define 	BISTSTATUS_MIB_TX_FIFO_MASK	0x1
+
+/*  intstatus offset0x20  */
+#define 	INTSTATUS_XMT3INTERRUPT_SHIFT	27
+#define 	INTSTATUS_XMT3INTERRUPT_MASK	0x8000000
+#define 	INTSTATUS_XMT2INTERRUPT_SHIFT	26
+#define 	INTSTATUS_XMT2INTERRUPT_MASK	0x4000000
+#define 	INTSTATUS_XMT1INTERRUPT_SHIFT	25
+#define 	INTSTATUS_XMT1INTERRUPT_MASK	0x2000000
+#define 	INTSTATUS_XMT0INTERRUPT_SHIFT	24
+#define 	INTSTATUS_XMT0INTERRUPT_MASK	0x1000000
+#define 	INTSTATUS_RCVDESCUF_3_SHIFT	23
+#define 	INTSTATUS_RCVDESCUF_3_MASK	0x800000
+#define 	INTSTATUS_RCVDESCUF_2_SHIFT	22
+#define 	INTSTATUS_RCVDESCUF_2_MASK	0x400000
+#define 	INTSTATUS_RCVDESCUF_1_SHIFT	21
+#define 	INTSTATUS_RCVDESCUF_1_MASK	0x200000
+#define 	INTSTATUS_RCVDESCUF_0_SHIFT	20
+#define 	INTSTATUS_RCVDESCUF_0_MASK	0x100000
+#define 	INTSTATUS_RCVINTERRUPT_3_SHIFT	19
+#define 	INTSTATUS_RCVINTERRUPT_3_MASK	0x80000
+#define 	INTSTATUS_RCVINTERRUPT_2_SHIFT	18
+#define 	INTSTATUS_RCVINTERRUPT_2_MASK	0x40000
+#define 	INTSTATUS_RCVINTERRUPT_1_SHIFT	17
+#define 	INTSTATUS_RCVINTERRUPT_1_MASK	0x20000
+#define 	INTSTATUS_RCVINTERRUPT_0_SHIFT	16
+#define 	INTSTATUS_RCVINTERRUPT_0_MASK	0x10000
+#define 	INTSTATUS_XMTFIFOUNDERFLOW_SHIFT	15
+#define 	INTSTATUS_XMTFIFOUNDERFLOW_MASK	0x8000
+#define 	INTSTATUS_RCVFIFOOVERFLOW_SHIFT	14
+#define 	INTSTATUS_RCVFIFOOVERFLOW_MASK	0x4000
+#define 	INTSTATUS_TSINT_SHIFT	13
+#define 	INTSTATUS_TSINT_MASK	0x2000
+#define 	INTSTATUS_DESCERROR_SHIFT	12
+#define 	INTSTATUS_DESCERROR_MASK	0x1000
+#define 	INTSTATUS_PCIDATAERROR_SHIFT	11
+#define 	INTSTATUS_PCIDATAERROR_MASK	0x800
+#define 	INTSTATUS_PCIDESCERROR_SHIFT	10
+#define 	INTSTATUS_PCIDESCERROR_MASK	0x400
+#define 	INTSTATUS_TIMEOUT_SHIFT	7
+#define 	INTSTATUS_TIMEOUT_MASK	0x80
+#define 	INTSTATUS_MIB_TX_SHIFT	6
+#define 	INTSTATUS_MIB_TX_MASK	0x40
+#define 	INTSTATUS_MIB_RX_SHIFT	5
+#define 	INTSTATUS_MIB_RX_MASK	0x20
+#define 	INTSTATUS_MDIO_SHIFT	4
+#define 	INTSTATUS_MDIO_MASK	0x10
+#define 	INTSTATUS_LINK_STAT_SHIFT	3
+#define 	INTSTATUS_LINK_STAT_MASK	0x8
+#define 	INTSTATUS_TXQ_FLUSH_DONE_SHIFT	2
+#define 	INTSTATUS_TXQ_FLUSH_DONE_MASK	0x4
+#define 	INTSTATUS_MIB_TX_OV_SHIFT	1
+#define 	INTSTATUS_MIB_TX_OV_MASK	0x2
+#define 	INTSTATUS_MIB_RX_OV_SHIFT	0
+#define 	INTSTATUS_MIB_RX_OV_MASK	0x1
+
+/*  intmask offset0x24  */
+#define 	INTMASK_XMT3INTERRUPT_SHIFT	27
+#define 	INTMASK_XMT3INTERRUPT_MASK	0x8000000
+#define 	INTMASK_XMT2INTERRUPT_SHIFT	26
+#define 	INTMASK_XMT2INTERRUPT_MASK	0x4000000
+#define 	INTMASK_XMT1INTERRUPT_SHIFT	25
+#define 	INTMASK_XMT1INTERRUPT_MASK	0x2000000
+#define 	INTMASK_XMT0INTERRUPT_SHIFT	24
+#define 	INTMASK_XMT0INTERRUPT_MASK	0x1000000
+#define 	INTMASK_RCVDESCUF_3_SHIFT	23
+#define 	INTMASK_RCVDESCUF_3_MASK	0x800000
+#define 	INTMASK_RCVDESCUF_2_SHIFT	22
+#define 	INTMASK_RCVDESCUF_2_MASK	0x400000
+#define 	INTMASK_RCVDESCUF_1_SHIFT	21
+#define 	INTMASK_RCVDESCUF_1_MASK	0x200000
+#define 	INTMASK_RCVDESCUF_0_SHIFT	20
+#define 	INTMASK_RCVDESCUF_0_MASK	0x100000
+#define 	INTMASK_RCVINTERRUPT_3_SHIFT	19
+#define 	INTMASK_RCVINTERRUPT_3_MASK	0x80000
+#define 	INTMASK_RCVINTERRUPT_2_SHIFT	18
+#define 	INTMASK_RCVINTERRUPT_2_MASK	0x40000
+#define 	INTMASK_RCVINTERRUPT_1_SHIFT	17
+#define 	INTMASK_RCVINTERRUPT_1_MASK	0x20000
+#define 	INTMASK_RCVINTERRUPT_0_SHIFT	16
+#define 	INTMASK_RCVINTERRUPT_0_MASK	0x10000
+#define 	INTMASK_XMTFIFOUNDERFLOW_SHIFT	15
+#define 	INTMASK_XMTFIFOUNDERFLOW_MASK	0x8000
+#define 	INTMASK_RCVFIFOOVERFLOW_SHIFT	14
+#define 	INTMASK_RCVFIFOOVERFLOW_MASK	0x4000
+#define 	INTMASK_TSINTEN_SHIFT	13
+#define 	INTMASK_TSINTEN_MASK	0x2000
+#define 	INTMASK_DESCERROR_SHIFT	12
+#define 	INTMASK_DESCERROR_MASK	0x1000
+#define 	INTMASK_PCIDATAERROR_SHIFT	11
+#define 	INTMASK_PCIDATAERROR_MASK	0x800
+#define 	INTMASK_PCIDESCERROR_SHIFT	10
+#define 	INTMASK_PCIDESCERROR_MASK	0x400
+#define 	INTMASK_TIMEOUT_SHIFT	7
+#define 	INTMASK_TIMEOUT_MASK	0x80
+#define 	INTMASK_MIB_TX_SHIFT	6
+#define 	INTMASK_MIB_TX_MASK	0x40
+#define 	INTMASK_MIB_RX_SHIFT	5
+#define 	INTMASK_MIB_RX_MASK	0x20
+#define 	INTMASK_MDIO_SHIFT	4
+#define 	INTMASK_MDIO_MASK	0x10
+#define 	INTMASK_LINK_STAT_SHIFT	3
+#define 	INTMASK_LINK_STAT_MASK	0x8
+#define 	INTMASK_TXQ_FLUSH_DONE_SHIFT	2
+#define 	INTMASK_TXQ_FLUSH_DONE_MASK	0x4
+#define 	INTMASK_MIB_TX_OV_SHIFT	1
+#define 	INTMASK_MIB_TX_OV_MASK	0x2
+#define 	INTMASK_MIB_RX_OV_SHIFT	0
+#define 	INTMASK_MIB_RX_OV_MASK	0x1
+
+/*  gptimer offset0x28  */
+#define 	GPTIMER_GPTIMER_SHIFT	0
+#define 	GPTIMER_GPTIMER_MASK	0xffffffff
+
+/*  rx_ch0_flow_ctrl offset0x30  */
+#define 	RX_CH0_FLOW_CTRL_FLOWCNTLONTH_SHIFT	0
+#define 	RX_CH0_FLOW_CTRL_FLOWCNTLONTH_MASK	0x1ff
+#define 	RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT	16
+#define 	RX_CH0_FLOW_CTRL_FLOWCNTLOFFTH_MASK	0x1ff0000
+
+/*  rx_ch1_flow_ctrl offset0x34  */
+#define 	RX_CH1_FLOW_CTRL_FLOWCNTLONTH_SHIFT	0
+#define 	RX_CH1_FLOW_CTRL_FLOWCNTLONTH_MASK	0x1ff
+#define 	RX_CH1_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT	16
+#define 	RX_CH1_FLOW_CTRL_FLOWCNTLOFFTH_MASK	0x1ff0000
+
+/*  rx_ch2_flow_ctrl offset0x38  */
+#define 	RX_CH2_FLOW_CTRL_FLOWCNTLONTH_SHIFT	0
+#define 	RX_CH2_FLOW_CTRL_FLOWCNTLONTH_MASK	0x1ff
+#define 	RX_CH2_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT	16
+#define 	RX_CH2_FLOW_CTRL_FLOWCNTLOFFTH_MASK	0x1ff0000
+
+/*  rx_ch3_flow_ctrl offset0x3c  */
+#define 	RX_CH3_FLOW_CTRL_FLOWCNTLONTH_SHIFT	0
+#define 	RX_CH3_FLOW_CTRL_FLOWCNTLONTH_MASK	0x1ff
+#define 	RX_CH3_FLOW_CTRL_FLOWCNTLOFFTH_SHIFT	16
+#define 	RX_CH3_FLOW_CTRL_FLOWCNTLOFFTH_MASK	0x1ff0000
+
+/*  desc_flow_ctrl_ps_stat offset0x40  */
+#define 	DESC_FLOW_CTRL_PS_STAT_PS_STAT_SHIFT	0
+#define 	DESC_FLOW_CTRL_PS_STAT_PS_STAT_MASK	0xf
+
+/*  intrecvlazy offset0x100  */
+#define 	INTRECVLAZY_FRAME_COUNT_SHIFT	24
+#define 	INTRECVLAZY_FRAME_COUNT_MASK	0xff000000
+#define 	INTRECVLAZY_TIME_OUT_SHIFT	0
+#define 	INTRECVLAZY_TIME_OUT_MASK	0xffffff
+
+/*  flowctlthresh offset0x104  */
+#define 	FLOWCTLTHRESH_OFF_THRESH_SHIFT	16
+#define 	FLOWCTLTHRESH_OFF_THRESH_MASK	0xfff0000
+#define 	FLOWCTLTHRESH_ON_THRESH_SHIFT	0
+#define 	FLOWCTLTHRESH_ON_THRESH_MASK	0xfff
+
+/*  txqos offset0x108  */
+#define 	TXQOS_TXQOS_GRNL_SHIFT	26
+#define 	TXQOS_TXQOS_GRNL_MASK	0x4000000
+#define 	TXQOS_TXQOS_POLICY_SHIFT	24
+#define 	TXQOS_TXQOS_POLICY_MASK	0x3000000
+#define 	TXQOS_TXQOS_WEIGHT2_SHIFT	16
+#define 	TXQOS_TXQOS_WEIGHT2_MASK	0xff0000
+#define 	TXQOS_TXQOS_WEIGHT1_SHIFT	8
+#define 	TXQOS_TXQOS_WEIGHT1_MASK	0xff00
+#define 	TXQOS_TXQOS_WEIGHT0_SHIFT	0
+#define 	TXQOS_TXQOS_WEIGHT0_MASK	0xff
+
+/*  gmac_idle_cnt_thresh offset0x10c  */
+#define 	GMAC_IDLE_CNT_THRESH_TX_IDLE_TH_SHIFT	8
+#define 	GMAC_IDLE_CNT_THRESH_TX_IDLE_TH_MASK	0xff00
+#define 	GMAC_IDLE_CNT_THRESH_RX_IDLE_TH_SHIFT	0
+#define 	GMAC_IDLE_CNT_THRESH_RX_IDLE_TH_MASK	0xff
+
+/*  fifoaccessaddr offset0x120  */
+#define 	FIFOACCESSADDR_SELECT_SHIFT	16
+#define 	FIFOACCESSADDR_SELECT_MASK	0xf0000
+#define 	FIFOACCESSADDR_OFFSETX_SHIFT	0
+#define 	FIFOACCESSADDR_OFFSETX_MASK	0xffff
+
+/*  fifoaccessbyte offset0x124  */
+#define 	FIFOACCESSBYTE_BYTEENABLE_SHIFT	0
+#define 	FIFOACCESSBYTE_BYTEENABLE_MASK	0xf
+
+/*  fifoaccessdata offset0x128  */
+#define 	FIFOACCESSDATA_FIFODATA_SHIFT	0
+#define 	FIFOACCESSDATA_FIFODATA_MASK	0xffffffff
+
+/*  irc_cfg offset0x130  */
+#define 	IRC_CFG_IRC3_IDX_SHIFT	24
+#define 	IRC_CFG_IRC3_IDX_MASK	0x3f000000
+#define 	IRC_CFG_IRC2_IDX_SHIFT	16
+#define 	IRC_CFG_IRC2_IDX_MASK	0x3f0000
+#define 	IRC_CFG_IRC1_IDX_SHIFT	8
+#define 	IRC_CFG_IRC1_IDX_MASK	0x3f00
+#define 	IRC_CFG_IRC0_IDX_SHIFT	0
+#define 	IRC_CFG_IRC0_IDX_MASK	0x3f
+
+/*  erc0_cfg offset0x138  */
+#define 	ERC0_CFG_ENABLE_SHIFT	24
+#define 	ERC0_CFG_ENABLE_MASK	0x1000000
+#define 	ERC0_CFG_BURSTACC_SHIFT	23
+#define 	ERC0_CFG_BURSTACC_MASK	0x800000
+#define 	ERC0_CFG_BKTSIZE_SHIFT	15
+#define 	ERC0_CFG_BKTSIZE_MASK	0x7f8000
+#define 	ERC0_CFG_RESERVED_SHIFT	14
+#define 	ERC0_CFG_RESERVED_MASK	0x4000
+#define 	ERC0_CFG_RFSHCNT_SHIFT	0
+#define 	ERC0_CFG_RFSHCNT_MASK	0x3fff
+
+/*  erc1_cfg offset0x13c  */
+#define 	ERC1_CFG_ENABLE_SHIFT	24
+#define 	ERC1_CFG_ENABLE_MASK	0x1000000
+#define 	ERC1_CFG_BURSTACC_SHIFT	23
+#define 	ERC1_CFG_BURSTACC_MASK	0x800000
+#define 	ERC1_CFG_BKTSIZE_SHIFT	15
+#define 	ERC1_CFG_BKTSIZE_MASK	0x7f8000
+#define 	ERC1_CFG_RFSHCNT_SHIFT	0
+#define 	ERC1_CFG_RFSHCNT_MASK	0x7fff
+
+/*  erc2_cfg offset0x140  */
+#define 	ERC2_CFG_ENABLE_SHIFT	24
+#define 	ERC2_CFG_ENABLE_MASK	0x1000000
+#define 	ERC2_CFG_BURSTACC_SHIFT	23
+#define 	ERC2_CFG_BURSTACC_MASK	0x800000
+#define 	ERC2_CFG_BKTSIZE_SHIFT	15
+#define 	ERC2_CFG_BKTSIZE_MASK	0x7f8000
+#define 	ERC2_CFG_RFSHCNT_SHIFT	0
+#define 	ERC2_CFG_RFSHCNT_MASK	0x7fff
+
+/*  erc3_cfg offset0x144  */
+#define 	ERC3_CFG_ENABLE_SHIFT	24
+#define 	ERC3_CFG_ENABLE_MASK	0x1000000
+#define 	ERC3_CFG_BURSTACC_SHIFT	23
+#define 	ERC3_CFG_BURSTACC_MASK	0x800000
+#define 	ERC3_CFG_BKTSIZE_SHIFT	15
+#define 	ERC3_CFG_BKTSIZE_MASK	0x7f8000
+#define 	ERC3_CFG_RFSHCNT_SHIFT	0
+#define 	ERC3_CFG_RFSHCNT_MASK	0x7fff
+
+/*  xmt0launch offset0x150  */
+#define 	XMT0LAUNCH_LAUNCH_TIME_SHIFT	0
+#define 	XMT0LAUNCH_LAUNCH_TIME_MASK	0xffffffff
+
+/*  xmt1launch offset0x154  */
+#define 	XMT1LAUNCH_LAUNCH_TIME_SHIFT	0
+#define 	XMT1LAUNCH_LAUNCH_TIME_MASK	0xffffffff
+
+/*  xmt2launch offset0x158  */
+#define 	XMT2LAUNCH_LAUNCH_TIME_SHIFT	0
+#define 	XMT2LAUNCH_LAUNCH_TIME_MASK	0xffffffff
+
+/*  xmt3launch offset0x15c  */
+#define 	XMT3LAUNCH_LAUNCH_TIME_SHIFT	0
+#define 	XMT3LAUNCH_LAUNCH_TIME_MASK	0xffffffff
+
+/*  txqctl offset0x18c  */
+#define 	TXQCTL_DATA_BUFFER_THRESH_SHIFT	0
+#define 	TXQCTL_DATA_BUFFER_THRESH_MASK	0xfff
+
+/*  rxqctl offset0x190  */
+#define 	RXQCTL_RESERVED0_SHIFT	24
+#define 	RXQCTL_RESERVED0_MASK	0x3f000000
+#define 	RXQCTL_RXQ_PERF_TEST_EN_SHIFT	12
+#define 	RXQCTL_RXQ_PERF_TEST_EN_MASK	0x1000
+#define 	RXQCTL_RXQ_DATA_BUF_TH_SHIFT	0
+#define 	RXQCTL_RXQ_DATA_BUF_TH_MASK	0xfff
+
+/*  gpioselect offset0x194  */
+#define 	GPIOSELECT_GPIO_SELECT_SHIFT	0
+#define 	GPIOSELECT_GPIO_SELECT_MASK	0xf
+
+/*  gpio_output_en offset0x198  */
+#define 	GPIO_OUTPUT_EN_GPIO_OE_SHIFT	0
+#define 	GPIO_OUTPUT_EN_GPIO_OE_MASK	0xffff
+
+/*  clk_ctl_st offset0x1e0  */
+#define 	CLK_CTL_ST_DMP_OOB_CIN_5_4_3_SHIFT	24
+#define 	CLK_CTL_ST_DMP_OOB_CIN_5_4_3_MASK	0x7000000
+#define 	CLK_CTL_ST_DMP_OOB_CIN_7_6_SHIFT	18
+#define 	CLK_CTL_ST_DMP_OOB_CIN_7_6_MASK	0xc0000
+#define 	CLK_CTL_ST_HTCLOCKAVAILABLE_SHIFT	17
+#define 	CLK_CTL_ST_HTCLOCKAVAILABLE_MASK	0x20000
+#define 	CLK_CTL_ST_RESERVED4_SHIFT	16
+#define 	CLK_CTL_ST_RESERVED4_MASK	0x10000
+#define 	CLK_CTL_ST_EXTRSRCREQ_SHIFT	8
+#define 	CLK_CTL_ST_EXTRSRCREQ_MASK	0x100
+#define 	CLK_CTL_ST_RESERVED3_SHIFT	5
+#define 	CLK_CTL_ST_RESERVED3_MASK	0x20
+#define 	CLK_CTL_ST_HTAVAILREQ_SHIFT	4
+#define 	CLK_CTL_ST_HTAVAILREQ_MASK	0x10
+#define 	CLK_CTL_ST_RESERVED2_SHIFT	3
+#define 	CLK_CTL_ST_RESERVED2_MASK	0x8
+#define 	CLK_CTL_ST_RESERVED1_SHIFT	2
+#define 	CLK_CTL_ST_RESERVED1_MASK	0x4
+#define 	CLK_CTL_ST_FORCEHT_SHIFT	1
+#define 	CLK_CTL_ST_FORCEHT_MASK	0x2
+#define 	CLK_CTL_ST_RESERVED0_SHIFT	0
+#define 	CLK_CTL_ST_RESERVED0_MASK	0x1
+
+/*  pwrctl offset0x1e8  */
+#define 	PWRCTL_PWRCTL_SHIFT	0
+#define 	PWRCTL_PWRCTL_MASK	0xf
+
+/*  d64xmt0control offset0x200  */
+#define 	D64XMT0CONTROL_ADDREXT_SHIFT	16
+#define 	D64XMT0CONTROL_ADDREXT_MASK	0x30000
+#define 	D64XMT0CONTROL_TX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64XMT0CONTROL_TX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64XMT0CONTROL_TX_LAUNCH_TIME_EN_SHIFT	3
+#define 	D64XMT0CONTROL_TX_LAUNCH_TIME_EN_MASK	0x8
+#define 	D64XMT0CONTROL_DMA_LB_SHIFT	2
+#define 	D64XMT0CONTROL_DMA_LB_MASK	0x4
+#define 	D64XMT0CONTROL_TXSUSPEND_SHIFT	1
+#define 	D64XMT0CONTROL_TXSUSPEND_MASK	0x2
+#define 	D64XMT0CONTROL_XMTEN_SHIFT	0
+#define 	D64XMT0CONTROL_XMTEN_MASK	0x1
+
+/*  d64xmt0ptr offset0x204  */
+#define 	D64XMT0PTR_LASTDSCR_SHIFT	0
+#define 	D64XMT0PTR_LASTDSCR_MASK	0x1fff
+
+/*  d64xmt0addrlow offset0x208  */
+#define 	D64XMT0ADDRLOW_XMTADDR_LOW_SHIFT	0
+#define 	D64XMT0ADDRLOW_XMTADDR_LOW_MASK	0xffffffff
+
+/*  d64xmt0addrhigh offset0x20c  */
+#define 	D64XMT0ADDRHIGH_XMTADDR_HIGH_SHIFT	0
+#define 	D64XMT0ADDRHIGH_XMTADDR_HIGH_MASK	0xffffffff
+
+/*  d64xmt0status0 offset0x210  */
+#define 	D64XMT0STATUS0_XMTSTATE_SHIFT	28
+#define 	D64XMT0STATUS0_XMTSTATE_MASK	0xf0000000
+#define 	D64XMT0STATUS0_CURRDSCR_SHIFT	0
+#define 	D64XMT0STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64xmt0status1 offset0x214  */
+#define 	D64XMT0STATUS1_XMTERR_SHIFT	28
+#define 	D64XMT0STATUS1_XMTERR_MASK	0xf0000000
+#define 	D64XMT0STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64XMT0STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64rcv0control offset0x220  */
+#define 	D64RCV0CONTROL_ADDREXT_SHIFT	16
+#define 	D64RCV0CONTROL_ADDREXT_MASK	0x30000
+#define 	D64RCV0CONTROL_RX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64RCV0CONTROL_RX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64RCV0CONTROL_OFLOWEN_SHIFT	10
+#define 	D64RCV0CONTROL_OFLOWEN_MASK	0x400
+#define 	D64RCV0CONTROL_SEPDESCRHDREN_SHIFT	9
+#define 	D64RCV0CONTROL_SEPDESCRHDREN_MASK	0x200
+#define 	D64RCV0CONTROL_RCVOFFSET_SHIFT	1
+#define 	D64RCV0CONTROL_RCVOFFSET_MASK	0xfe
+#define 	D64RCV0CONTROL_REVEN_SHIFT	0
+#define 	D64RCV0CONTROL_REVEN_MASK	0x1
+
+/*  d64rcv0ptr offset0x224  */
+#define 	D64RCV0PTR_RCVPTR_SHIFT	0
+#define 	D64RCV0PTR_RCVPTR_MASK	0x1fff
+
+/*  d64rcv0addrlow offset0x228  */
+#define 	D64RCV0ADDRLOW_RCVADDR_LOW_SHIFT	0
+#define 	D64RCV0ADDRLOW_RCVADDR_LOW_MASK	0xffffffff
+
+/*  d64rcv0addrhigh offset0x22c  */
+#define 	D64RCV0ADDRHIGH_RCVADDR_HIGH_SHIFT	0
+#define 	D64RCV0ADDRHIGH_RCVADDR_HIGH_MASK	0xffffffff
+
+/*  d64rcv0status0 offset0x230  */
+#define 	D64RCV0STATUS0_RCVSTATE_SHIFT	28
+#define 	D64RCV0STATUS0_RCVSTATE_MASK	0xf0000000
+#define 	D64RCV0STATUS0_CURRDSCR_SHIFT	0
+#define 	D64RCV0STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64rcv0status1 offset0x234  */
+#define 	D64RCV0STATUS1_RCVERR_SHIFT	28
+#define 	D64RCV0STATUS1_RCVERR_MASK	0xf0000000
+#define 	D64RCV0STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64RCV0STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64xmt1control offset0x240  */
+#define 	D64XMT1CONTROL_ADDREXT_SHIFT	16
+#define 	D64XMT1CONTROL_ADDREXT_MASK	0x30000
+#define 	D64XMT1CONTROL_TX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64XMT1CONTROL_TX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64XMT1CONTROL_TX_LAUNCH_TIME_EN_SHIFT	3
+#define 	D64XMT1CONTROL_TX_LAUNCH_TIME_EN_MASK	0x8
+#define 	D64XMT1CONTROL_TXSUSPEND_SHIFT	1
+#define 	D64XMT1CONTROL_TXSUSPEND_MASK	0x2
+#define 	D64XMT1CONTROL_XMTEN_SHIFT	0
+#define 	D64XMT1CONTROL_XMTEN_MASK	0x1
+
+/*  d64xmt1ptr offset0x244  */
+#define 	D64XMT1PTR_LASTDSCR_SHIFT	0
+#define 	D64XMT1PTR_LASTDSCR_MASK	0x1fff
+
+/*  d64xmt1addrlow offset0x248  */
+#define 	D64XMT1ADDRLOW_XMTADDR_LOW_SHIFT	0
+#define 	D64XMT1ADDRLOW_XMTADDR_LOW_MASK	0xffffffff
+
+/*  d64xmt1addrhigh offset0x24c  */
+#define 	D64XMT1ADDRHIGH_XMTADDR_HIGH_SHIFT	0
+#define 	D64XMT1ADDRHIGH_XMTADDR_HIGH_MASK	0xffffffff
+
+/*  d64xmt1status0 offset0x250  */
+#define 	D64XMT1STATUS0_XMTSTATE_SHIFT	28
+#define 	D64XMT1STATUS0_XMTSTATE_MASK	0xf0000000
+#define 	D64XMT1STATUS0_CURRDSCR_SHIFT	0
+#define 	D64XMT1STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64xmt1status1 offset0x254  */
+#define 	D64XMT1STATUS1_XMTERR_SHIFT	28
+#define 	D64XMT1STATUS1_XMTERR_MASK	0xf0000000
+#define 	D64XMT1STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64XMT1STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64rcv1control offset0x260  */
+#define 	D64RCV1CONTROL_ADDREXT_SHIFT	16
+#define 	D64RCV1CONTROL_ADDREXT_MASK	0x30000
+#define 	D64RCV1CONTROL_RX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64RCV1CONTROL_RX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64RCV1CONTROL_OFLOWEN_SHIFT	10
+#define 	D64RCV1CONTROL_OFLOWEN_MASK	0x400
+#define 	D64RCV1CONTROL_RCVOFFSET_SHIFT	1
+#define 	D64RCV1CONTROL_RCVOFFSET_MASK	0xfe
+#define 	D64RCV1CONTROL_REVEN_SHIFT	0
+#define 	D64RCV1CONTROL_REVEN_MASK	0x1
+
+/*  d64rcv1ptr offset0x264  */
+#define 	D64RCV1PTR_RCVPTR_SHIFT	0
+#define 	D64RCV1PTR_RCVPTR_MASK	0x1fff
+
+/*  d64rcv1addrlow offset0x268  */
+#define 	D64RCV1ADDRLOW_RCVADDR_LOW_SHIFT	0
+#define 	D64RCV1ADDRLOW_RCVADDR_LOW_MASK	0xffffffff
+
+/*  d64rcv1addrhigh offset0x26c  */
+#define 	D64RCV1ADDRHIGH_RCVADDR_HIGH_SHIFT	0
+#define 	D64RCV1ADDRHIGH_RCVADDR_HIGH_MASK	0xffffffff
+
+/*  d64rcv1status0 offset0x270  */
+#define 	D64RCV1STATUS0_RCVSTATE_SHIFT	28
+#define 	D64RCV1STATUS0_RCVSTATE_MASK	0xf0000000
+#define 	D64RCV1STATUS0_CURRDSCR_SHIFT	0
+#define 	D64RCV1STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64rcv1status1 offset0x274  */
+#define 	D64RCV1STATUS1_RCVERR_SHIFT	28
+#define 	D64RCV1STATUS1_RCVERR_MASK	0xf0000000
+#define 	D64RCV1STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64RCV1STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64xmt2control offset0x280  */
+#define 	D64XMT2CONTROL_ADDREXT_SHIFT	16
+#define 	D64XMT2CONTROL_ADDREXT_MASK	0x30000
+#define 	D64XMT2CONTROL_TX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64XMT2CONTROL_TX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64XMT2CONTROL_TX_LAUNCH_TIME_EN_SHIFT	3
+#define 	D64XMT2CONTROL_TX_LAUNCH_TIME_EN_MASK	0x8
+#define 	D64XMT2CONTROL_TXSUSPEND_SHIFT	1
+#define 	D64XMT2CONTROL_TXSUSPEND_MASK	0x2
+#define 	D64XMT2CONTROL_XMTEN_SHIFT	0
+#define 	D64XMT2CONTROL_XMTEN_MASK	0x1
+
+/*  d64xmt2ptr offset0x284  */
+#define 	D64XMT2PTR_LASTDSCR_SHIFT	0
+#define 	D64XMT2PTR_LASTDSCR_MASK	0x1fff
+
+/*  d64xmt2addrlow offset0x288  */
+#define 	D64XMT2ADDRLOW_XMTADDR_LOW_SHIFT	0
+#define 	D64XMT2ADDRLOW_XMTADDR_LOW_MASK	0xffffffff
+
+/*  d64xmt2addrhigh offset0x28c  */
+#define 	D64XMT2ADDRHIGH_XMTADDR_HIGH_SHIFT	0
+#define 	D64XMT2ADDRHIGH_XMTADDR_HIGH_MASK	0xffffffff
+
+/*  d64xmt2status0 offset0x290  */
+#define 	D64XMT2STATUS0_XMTSTATE_SHIFT	28
+#define 	D64XMT2STATUS0_XMTSTATE_MASK	0xf0000000
+#define 	D64XMT2STATUS0_CURRDSCR_SHIFT	0
+#define 	D64XMT2STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64xmt2status1 offset0x294  */
+#define 	D64XMT2STATUS1_XMTERR_SHIFT	28
+#define 	D64XMT2STATUS1_XMTERR_MASK	0xf0000000
+#define 	D64XMT2STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64XMT2STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64rcv2control offset0x2a0  */
+#define 	D64RCV2CONTROL_ADDREXT_SHIFT	16
+#define 	D64RCV2CONTROL_ADDREXT_MASK	0x30000
+#define 	D64RCV2CONTROL_RX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64RCV2CONTROL_RX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64RCV2CONTROL_OFLOWEN_SHIFT	10
+#define 	D64RCV2CONTROL_OFLOWEN_MASK	0x400
+#define 	D64RCV2CONTROL_RCVOFFSET_SHIFT	1
+#define 	D64RCV2CONTROL_RCVOFFSET_MASK	0xfe
+#define 	D64RCV2CONTROL_REVEN_SHIFT	0
+#define 	D64RCV2CONTROL_REVEN_MASK	0x1
+
+/*  d64rcv2ptr offset0x2a4  */
+#define 	D64RCV2PTR_RCVPTR_SHIFT	0
+#define 	D64RCV2PTR_RCVPTR_MASK	0x1fff
+
+/*  d64rcv2addrlow offset0x2a8  */
+#define 	D64RCV2ADDRLOW_RCVADDR_LOW_SHIFT	0
+#define 	D64RCV2ADDRLOW_RCVADDR_LOW_MASK	0xffffffff
+
+/*  d64rcv2addrhigh offset0x2ac  */
+#define 	D64RCV2ADDRHIGH_RCVADDR_HIGH_SHIFT	0
+#define 	D64RCV2ADDRHIGH_RCVADDR_HIGH_MASK	0xffffffff
+
+/*  d64rcv2status0 offset0x2b0  */
+#define 	D64RCV2STATUS0_RCVSTATE_SHIFT	28
+#define 	D64RCV2STATUS0_RCVSTATE_MASK	0xf0000000
+#define 	D64RCV2STATUS0_CURRDSCR_SHIFT	0
+#define 	D64RCV2STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64rcv2status1 offset0x2b4  */
+#define 	D64RCV2STATUS1_RCVERR_SHIFT	28
+#define 	D64RCV2STATUS1_RCVERR_MASK	0xf0000000
+#define 	D64RCV2STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64RCV2STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64xmt3control offset0x2c0  */
+#define 	D64XMT3CONTROL_ADDREXT_SHIFT	16
+#define 	D64XMT3CONTROL_ADDREXT_MASK	0x30000
+#define 	D64XMT3CONTROL_TX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64XMT3CONTROL_TX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64XMT3CONTROL_TX_LAUNCH_TIME_EN_SHIFT	3
+#define 	D64XMT3CONTROL_TX_LAUNCH_TIME_EN_MASK	0x8
+#define 	D64XMT3CONTROL_TXSUSPEND_SHIFT	1
+#define 	D64XMT3CONTROL_TXSUSPEND_MASK	0x2
+#define 	D64XMT3CONTROL_XMTEN_SHIFT	0
+#define 	D64XMT3CONTROL_XMTEN_MASK	0x1
+
+/*  d64xmt3ptr offset0x2c4  */
+#define 	D64XMT3PTR_LASTDSCR_SHIFT	0
+#define 	D64XMT3PTR_LASTDSCR_MASK	0x1fff
+
+/*  d64xmt3addrlow offset0x2c8  */
+#define 	D64XMT3ADDRLOW_XMTADDR_LOW_SHIFT	0
+#define 	D64XMT3ADDRLOW_XMTADDR_LOW_MASK	0xffffffff
+
+/*  d64xmt3addrhigh offset0x2cc  */
+#define 	D64XMT3ADDRHIGH_XMTADDR_HIGH_SHIFT	0
+#define 	D64XMT3ADDRHIGH_XMTADDR_HIGH_MASK	0xffffffff
+
+/*  d64xmt3status0 offset0x2d0  */
+#define 	D64XMT3STATUS0_XMTSTATE_SHIFT	28
+#define 	D64XMT3STATUS0_XMTSTATE_MASK	0xf0000000
+#define 	D64XMT3STATUS0_CURRDSCR_SHIFT	0
+#define 	D64XMT3STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64xmt3status1 offset0x2d4  */
+#define 	D64XMT3STATUS1_XMTERR_SHIFT	28
+#define 	D64XMT3STATUS1_XMTERR_MASK	0xf0000000
+#define 	D64XMT3STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64XMT3STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  d64rcv3control offset0x2e0  */
+#define 	D64RCV3CONTROL_ADDREXT_SHIFT	16
+#define 	D64RCV3CONTROL_ADDREXT_MASK	0x30000
+#define 	D64RCV3CONTROL_RX_PT_CHK_DISABLE_SHIFT	11
+#define 	D64RCV3CONTROL_RX_PT_CHK_DISABLE_MASK	0x800
+#define 	D64RCV3CONTROL_OFLOWEN_SHIFT	10
+#define 	D64RCV3CONTROL_OFLOWEN_MASK	0x400
+#define 	D64RCV3CONTROL_RCVOFFSET_SHIFT	1
+#define 	D64RCV3CONTROL_RCVOFFSET_MASK	0xfe
+#define 	D64RCV3CONTROL_REVEN_SHIFT	0
+#define 	D64RCV3CONTROL_REVEN_MASK	0x1
+
+/*  d64rcv3ptr offset0x2e4  */
+#define 	D64RCV3PTR_RCVPTR_SHIFT	0
+#define 	D64RCV3PTR_RCVPTR_MASK	0x1fff
+
+/*  d64rcv3addrlow offset0x2e8  */
+#define 	D64RCV3ADDRLOW_RCVADDR_LOW_SHIFT	0
+#define 	D64RCV3ADDRLOW_RCVADDR_LOW_MASK	0xffffffff
+
+/*  d64rcv3addrhigh offset0x2ec  */
+#define 	D64RCV3ADDRHIGH_RCVADDR_HIGH_SHIFT	0
+#define 	D64RCV3ADDRHIGH_RCVADDR_HIGH_MASK	0xffffffff
+
+/*  d64rcv3status0 offset0x2f0  */
+#define 	D64RCV3STATUS0_RCVSTATE_SHIFT	28
+#define 	D64RCV3STATUS0_RCVSTATE_MASK	0xf0000000
+#define 	D64RCV3STATUS0_CURRDSCR_SHIFT	0
+#define 	D64RCV3STATUS0_CURRDSCR_MASK	0x1fff
+
+/*  d64rcv3status1 offset0x2f4  */
+#define 	D64RCV3STATUS1_RCVERR_SHIFT	28
+#define 	D64RCV3STATUS1_RCVERR_MASK	0xf0000000
+#define 	D64RCV3STATUS1_ACTIVEDESCR_SHIFT	0
+#define 	D64RCV3STATUS1_ACTIVEDESCR_MASK	0x1fff
+
+/*  tx_good_octets offset0x300  */
+#define 	TX_GOOD_OCTETS_COUNT_SHIFT	0
+#define 	TX_GOOD_OCTETS_COUNT_MASK	0xffffffff
+
+/*  tx_good_octets_high offset0x304  */
+#define 	TX_GOOD_OCTETS_HIGH_COUNT_SHIFT	0
+#define 	TX_GOOD_OCTETS_HIGH_COUNT_MASK	0xffffffff
+
+/*  tx_good_pkts offset0x308  */
+#define 	TX_GOOD_PKTS_COUNT_SHIFT	0
+#define 	TX_GOOD_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_octets offset0x30c  */
+#define 	TX_OCTETS_COUNT_SHIFT	0
+#define 	TX_OCTETS_COUNT_MASK	0xffffffff
+
+/*  tx_octets_high offset0x310  */
+#define 	TX_OCTETS_HIGH_COUNT_SHIFT	0
+#define 	TX_OCTETS_HIGH_COUNT_MASK	0xffffffff
+
+/*  tx_pkts offset0x314  */
+#define 	TX_PKTS_COUNT_SHIFT	0
+#define 	TX_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_broadcast_pkts offset0x318  */
+#define 	TX_BROADCAST_PKTS_COUNT_SHIFT	0
+#define 	TX_BROADCAST_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_multicast_pkts offset0x31c  */
+#define 	TX_MULTICAST_PKTS_COUNT_SHIFT	0
+#define 	TX_MULTICAST_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_uni_pkts offset0x320  */
+#define 	TX_UNI_PKTS_COUNT_SHIFT	0
+#define 	TX_UNI_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_len_64 offset0x324  */
+#define 	TX_LEN_64_COUNT_SHIFT	0
+#define 	TX_LEN_64_COUNT_MASK	0xffffffff
+
+/*  tx_len_65_to_127 offset0x328  */
+#define 	TX_LEN_65_TO_127_COUNT_SHIFT	0
+#define 	TX_LEN_65_TO_127_COUNT_MASK	0xffffffff
+
+/*  tx_len_128_to_255 offset0x32c  */
+#define 	TX_LEN_128_TO_255_COUNT_SHIFT	0
+#define 	TX_LEN_128_TO_255_COUNT_MASK	0xffffffff
+
+/*  tx_len_256_to_511 offset0x330  */
+#define 	TX_LEN_256_TO_511_COUNT_SHIFT	0
+#define 	TX_LEN_256_TO_511_COUNT_MASK	0xffffffff
+
+/*  tx_len_512_to_1023 offset0x334  */
+#define 	TX_LEN_512_TO_1023_COUNT_SHIFT	0
+#define 	TX_LEN_512_TO_1023_COUNT_MASK	0xffffffff
+
+/*  tx_len_1024_to_max offset0x338  */
+#define 	TX_LEN_1024_TO_MAX_COUNT_SHIFT	0
+#define 	TX_LEN_1024_TO_MAX_COUNT_MASK	0xffffffff
+
+/*  tx_len_max_to_jumbo offset0x33c  */
+#define 	TX_LEN_MAX_TO_JUMBO_COUNT_SHIFT	0
+#define 	TX_LEN_MAX_TO_JUMBO_COUNT_MASK	0xffffffff
+
+/*  tx_jabber_pkts offset0x340  */
+#define 	TX_JABBER_PKTS_COUNT_SHIFT	0
+#define 	TX_JABBER_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_oversize_pkts offset0x344  */
+#define 	TX_OVERSIZE_PKTS_COUNT_SHIFT	0
+#define 	TX_OVERSIZE_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_fragment_pkts offset0x348  */
+#define 	TX_FRAGMENT_PKTS_COUNT_SHIFT	0
+#define 	TX_FRAGMENT_PKTS_COUNT_MASK	0xffffffff
+
+/*  tx_underruns offset0x34c  */
+#define 	TX_UNDERRUNS_COUNT_SHIFT	0
+#define 	TX_UNDERRUNS_COUNT_MASK	0xffffffff
+
+/*  tx_total_cols offset0x350  */
+#define 	TX_TOTAL_COLS_COUNT_SHIFT	0
+#define 	TX_TOTAL_COLS_COUNT_MASK	0xffffffff
+
+/*  tx_single_cols offset0x354  */
+#define 	TX_SINGLE_COLS_COUNT_SHIFT	0
+#define 	TX_SINGLE_COLS_COUNT_MASK	0xffffffff
+
+/*  tx_mulitple_cols offset0x358  */
+#define 	TX_MULITPLE_COLS_COUNT_SHIFT	0
+#define 	TX_MULITPLE_COLS_COUNT_MASK	0xffffffff
+
+/*  tx_excessive_cols offset0x35c  */
+#define 	TX_EXCESSIVE_COLS_COUNT_SHIFT	0
+#define 	TX_EXCESSIVE_COLS_COUNT_MASK	0xffffffff
+
+/*  tx_late_cols offset0x360  */
+#define 	TX_LATE_COLS_COUNT_SHIFT	0
+#define 	TX_LATE_COLS_COUNT_MASK	0xffffffff
+
+/*  tx_defered offset0x364  */
+#define 	TX_DEFERED_COUNT_SHIFT	0
+#define 	TX_DEFERED_COUNT_MASK	0xffffffff
+
+/*  tx_pause_pkts offset0x368  */
+#define 	TX_PAUSE_PKTS_COUNT_SHIFT	0
+#define 	TX_PAUSE_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_good_octets offset0x380  */
+#define 	RX_GOOD_OCTETS_COUNT_SHIFT	0
+#define 	RX_GOOD_OCTETS_COUNT_MASK	0xffffffff
+
+/*  rx_good_octets_high offset0x384  */
+#define 	RX_GOOD_OCTETS_HIGH_COUNT_SHIFT	0
+#define 	RX_GOOD_OCTETS_HIGH_COUNT_MASK	0xffffffff
+
+/*  rx_good_pkts offset0x388  */
+#define 	RX_GOOD_PKTS_COUNT_SHIFT	0
+#define 	RX_GOOD_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_octets offset0x38c  */
+#define 	RX_OCTETS_COUNT_SHIFT	0
+#define 	RX_OCTETS_COUNT_MASK	0xffffffff
+
+/*  rx_octets_high offset0x390  */
+#define 	RX_OCTETS_HIGH_COUNT_SHIFT	0
+#define 	RX_OCTETS_HIGH_COUNT_MASK	0xffffffff
+
+/*  rx_pkts offset0x394  */
+#define 	RX_PKTS_COUNT_SHIFT	0
+#define 	RX_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_broadcast_pkts offset0x398  */
+#define 	RX_BROADCAST_PKTS_COUNT_SHIFT	0
+#define 	RX_BROADCAST_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_multicast_pkts offset0x39c  */
+#define 	RX_MULTICAST_PKTS_COUNT_SHIFT	0
+#define 	RX_MULTICAST_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_uni_pkts offset0x3a0  */
+#define 	RX_UNI_PKTS_COUNT_SHIFT	0
+#define 	RX_UNI_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_len_64 offset0x3a4  */
+#define 	RX_LEN_64_COUNT_SHIFT	0
+#define 	RX_LEN_64_COUNT_MASK	0xffffffff
+
+/*  rx_len_65_to_127 offset0x3a8  */
+#define 	RX_LEN_65_TO_127_COUNT_SHIFT	0
+#define 	RX_LEN_65_TO_127_COUNT_MASK	0xffffffff
+
+/*  rx_len_128_to_255 offset0x3ac  */
+#define 	RX_LEN_128_TO_255_COUNT_SHIFT	0
+#define 	RX_LEN_128_TO_255_COUNT_MASK	0xffffffff
+
+/*  rx_len_256_to_511 offset0x3b0  */
+#define 	RX_LEN_256_TO_511_COUNT_SHIFT	0
+#define 	RX_LEN_256_TO_511_COUNT_MASK	0xffffffff
+
+/*  rx_len_512_to_1023 offset0x3b4  */
+#define 	RX_LEN_512_TO_1023_COUNT_SHIFT	0
+#define 	RX_LEN_512_TO_1023_COUNT_MASK	0xffffffff
+
+/*  rx_len_1024_to_max offset0x3b8  */
+#define 	RX_LEN_1024_TO_MAX_COUNT_SHIFT	0
+#define 	RX_LEN_1024_TO_MAX_COUNT_MASK	0xffffffff
+
+/*  rx_len_max_to_jumbo offset0x3bc  */
+#define 	RX_LEN_MAX_TO_JUMBO_COUNT_SHIFT	0
+#define 	RX_LEN_MAX_TO_JUMBO_COUNT_MASK	0xffffffff
+
+/*  rx_jabber_pkts offset0x3c0  */
+#define 	RX_JABBER_PKTS_COUNT_SHIFT	0
+#define 	RX_JABBER_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_oversize_pkts offset0x3c4  */
+#define 	RX_OVERSIZE_PKTS_COUNT_SHIFT	0
+#define 	RX_OVERSIZE_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_fragment_pkts offset0x3c8  */
+#define 	RX_FRAGMENT_PKTS_COUNT_SHIFT	0
+#define 	RX_FRAGMENT_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_missed_pkts offset0x3cc  */
+#define 	RX_MISSED_PKTS_COUNT_SHIFT	0
+#define 	RX_MISSED_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_undersize offset0x3d0  */
+#define 	RX_UNDERSIZE_COUNT_SHIFT	0
+#define 	RX_UNDERSIZE_COUNT_MASK	0xffffffff
+
+/*  rx_crc_errs offset0x3d4  */
+#define 	RX_CRC_ERRS_COUNT_SHIFT	0
+#define 	RX_CRC_ERRS_COUNT_MASK	0xffffffff
+
+/*  rx_align_errs offset0x3d8  */
+#define 	RX_ALIGN_ERRS_COUNT_SHIFT	0
+#define 	RX_ALIGN_ERRS_COUNT_MASK	0xffffffff
+
+/*  rx_symbol_errs offset0x3dc  */
+#define 	RX_SYMBOL_ERRS_COUNT_SHIFT	0
+#define 	RX_SYMBOL_ERRS_COUNT_MASK	0xffffffff
+
+/*  rx_pause_pkts offset0x3e0  */
+#define 	RX_PAUSE_PKTS_COUNT_SHIFT	0
+#define 	RX_PAUSE_PKTS_COUNT_MASK	0xffffffff
+
+/*  rx_nonpause_pkts offset0x3e4  */
+#define 	RX_NONPAUSE_PKTS_COUNT_SHIFT	0
+#define 	RX_NONPAUSE_PKTS_COUNT_MASK	0xffffffff
+
+/*  rxq0_irc_drop offset0x3e8  */
+#define 	RXQ0_IRC_DROP_COUNT_SHIFT	0
+#define 	RXQ0_IRC_DROP_COUNT_MASK	0xffffffff
+
+/*  rxq1_irc_drop offset0x3ec  */
+#define 	RXQ1_IRC_DROP_COUNT_SHIFT	0
+#define 	RXQ1_IRC_DROP_COUNT_MASK	0xffffffff
+
+/*  rxq2_irc_drop offset0x3f0  */
+#define 	RXQ2_IRC_DROP_COUNT_SHIFT	0
+#define 	RXQ2_IRC_DROP_COUNT_MASK	0xffffffff
+
+/*  rxq3_irc_drop offset0x3f4  */
+#define 	RXQ3_IRC_DROP_COUNT_SHIFT	0
+#define 	RXQ3_IRC_DROP_COUNT_MASK	0xffffffff
+
+/*  rx_cfp_drop offset0x3f8  */
+#define 	RX_CFP_DROP_COUNT_SHIFT	0
+#define 	RX_CFP_DROP_COUNT_MASK	0xffffffff
+
+/*  core_version offset0x800  */
+#define 	CORE_VERSION_CORE_VERSION_SHIFT	0
+#define 	CORE_VERSION_CORE_VERSION_MASK	0xffff
+#define 	CORE_VERSION_CUST_VERSION_SHIFT	16
+#define 	CORE_VERSION_CUST_VERSION_MASK	0xffff0000
+
+/*  ipg_hd_bkp_cntl offset0x804  */
+#define 	IPG_HD_BKP_CNTL_HD_FC_ENA_SHIFT	0
+#define 	IPG_HD_BKP_CNTL_HD_FC_ENA_MASK	0x1
+#define 	IPG_HD_BKP_CNTL_HD_FC_BKOFF_OK_SHIFT	1
+#define 	IPG_HD_BKP_CNTL_HD_FC_BKOFF_OK_MASK	0x2
+#define 	IPG_HD_BKP_CNTL_IPG_CONFIG_RX_SHIFT	2
+#define 	IPG_HD_BKP_CNTL_IPG_CONFIG_RX_MASK	0x7c
+
+/*  command_config offset0x808  */
+#define 	COMMAND_CONFIG_TX_ENA_SHIFT	0
+#define 	COMMAND_CONFIG_TX_ENA_MASK	0x1
+#define 	COMMAND_CONFIG_RX_ENA_SHIFT	1
+#define 	COMMAND_CONFIG_RX_ENA_MASK	0x2
+#define 	COMMAND_CONFIG_ETH_SPEED_SHIFT	2
+#define 	COMMAND_CONFIG_ETH_SPEED_MASK	0xc
+#define 	COMMAND_CONFIG_PROMIS_EN_SHIFT	4
+#define 	COMMAND_CONFIG_PROMIS_EN_MASK	0x10
+#define 	COMMAND_CONFIG_PAD_EN_SHIFT	5
+#define 	COMMAND_CONFIG_PAD_EN_MASK	0x20
+#define 	COMMAND_CONFIG_CRC_FWD_SHIFT	6
+#define 	COMMAND_CONFIG_CRC_FWD_MASK	0x40
+#define 	COMMAND_CONFIG_PAUSE_FWD_SHIFT	7
+#define 	COMMAND_CONFIG_PAUSE_FWD_MASK	0x80
+#define 	COMMAND_CONFIG_PAUSE_IGNORE_SHIFT	8
+#define 	COMMAND_CONFIG_PAUSE_IGNORE_MASK	0x100
+#define 	COMMAND_CONFIG_TX_ADDR_INS_SHIFT	9
+#define 	COMMAND_CONFIG_TX_ADDR_INS_MASK	0x200
+#define 	COMMAND_CONFIG_HD_ENA_SHIFT	10
+#define 	COMMAND_CONFIG_HD_ENA_MASK	0x400
+#define 	COMMAND_CONFIG_OVERFLOW_EN_SHIFT	12
+#define 	COMMAND_CONFIG_OVERFLOW_EN_MASK	0x1000
+#define 	COMMAND_CONFIG_SW_RESET_SHIFT	13
+#define 	COMMAND_CONFIG_SW_RESET_MASK	0x2000
+#define 	COMMAND_CONFIG_LOOP_ENA_SHIFT	15
+#define 	COMMAND_CONFIG_LOOP_ENA_MASK	0x8000
+#define 	COMMAND_CONFIG_MAC_LOOP_CON_SHIFT	16
+#define 	COMMAND_CONFIG_MAC_LOOP_CON_MASK	0x10000
+#define 	COMMAND_CONFIG_ENA_EXT_CONFIG_SHIFT	22
+#define 	COMMAND_CONFIG_ENA_EXT_CONFIG_MASK	0x400000
+#define 	COMMAND_CONFIG_CNTL_FRM_ENA_SHIFT	23
+#define 	COMMAND_CONFIG_CNTL_FRM_ENA_MASK	0x800000
+#define 	COMMAND_CONFIG_NO_LGTH_CHECK_SHIFT	24
+#define 	COMMAND_CONFIG_NO_LGTH_CHECK_MASK	0x1000000
+#define 	COMMAND_CONFIG_LINE_LOOPBACK_SHIFT	25
+#define 	COMMAND_CONFIG_LINE_LOOPBACK_MASK	0x2000000
+#define 	COMMAND_CONFIG_RESVERED_1_SHIFT	26
+#define 	COMMAND_CONFIG_RESVERED_1_MASK	0x4000000
+#define 	COMMAND_CONFIG_RESERVED_2_SHIFT	27
+#define 	COMMAND_CONFIG_RESERVED_2_MASK	0x8000000
+#define 	COMMAND_CONFIG_IGNORE_TX_PAUSE_SHIFT	28
+#define 	COMMAND_CONFIG_IGNORE_TX_PAUSE_MASK	0x10000000
+#define 	COMMAND_CONFIG_SW_CTRL_RXTX_AFTER_LKUP_SHIFT	29
+#define 	COMMAND_CONFIG_SW_CTRL_RXTX_AFTER_LKUP_MASK	0x20000000
+#define 	COMMAND_CONFIG_RESVERED_3_SHIFT	30
+#define 	COMMAND_CONFIG_RESVERED_3_MASK	0x40000000
+
+/*  mac_0 offset0x80c  */
+#define 	MAC_0_MAC_ADDR0_SHIFT	0
+#define 	MAC_0_MAC_ADDR0_MASK	0xffffffff
+
+/*  mac_1 offset0x810  */
+#define 	MAC_1_MAC_ADDR1_SHIFT	0
+#define 	MAC_1_MAC_ADDR1_MASK	0xffff
+
+/*  frm_length offset0x814  */
+#define 	FRM_LENGTH_MAXFR_SHIFT	0
+#define 	FRM_LENGTH_MAXFR_MASK	0x3fff
+
+/*  pause_quant offset0x818  */
+#define 	PAUSE_QUANT_STAD2_SHIFT	0
+#define 	PAUSE_QUANT_STAD2_MASK	0xffff
+
+/*  mac_mode offset0x844  */
+#define 	MAC_MODE_MAC_SPEED_SHIFT	0
+#define 	MAC_MODE_MAC_SPEED_MASK	0x3
+#define 	MAC_MODE_MAC_DUPLEX_SHIFT	2
+#define 	MAC_MODE_MAC_DUPLEX_MASK	0x4
+#define 	MAC_MODE_MAC_RX_PAUSE_SHIFT	3
+#define 	MAC_MODE_MAC_RX_PAUSE_MASK	0x8
+#define 	MAC_MODE_MAC_TX_PAUSE_SHIFT	4
+#define 	MAC_MODE_MAC_TX_PAUSE_MASK	0x10
+#define 	MAC_MODE_LINK_STATUS_SHIFT	5
+#define 	MAC_MODE_LINK_STATUS_MASK	0x20
+
+/*  tx_ipg_length offset0x85c  */
+#define 	TX_IPG_LENGTH_TX_IPG_LENGTH_SHIFT	0
+#define 	TX_IPG_LENGTH_TX_IPG_LENGTH_MASK	0x7f
+
+/*  ts_status_cntrl offset0xb18  */
+#define 	TS_STATUS_CNTRL_WORD_AVAIL_SHIFT	2
+#define 	TS_STATUS_CNTRL_WORD_AVAIL_MASK	0x1c
+#define 	TS_STATUS_CNTRL_TX_TS_FIFO_EMPTY_SHIFT	1
+#define 	TS_STATUS_CNTRL_TX_TS_FIFO_EMPTY_MASK	0x2
+#define 	TS_STATUS_CNTRL_TX_TS_FIFO_FULL_SHIFT	0
+#define 	TS_STATUS_CNTRL_TX_TS_FIFO_FULL_MASK	0x1
+
+/*  tx_ts_data offset0xb1c  */
+#define 	TX_TS_DATA_TX_TS_DATA_SHIFT	0
+#define 	TX_TS_DATA_TX_TS_DATA_MASK	0xffffffff
+
+/*  pause_control offset0xb30  */
+#define 	PAUSE_CONTROL_VALUE_SHIFT	0
+#define 	PAUSE_CONTROL_VALUE_MASK	0x1ffff
+#define 	PAUSE_CONTROL_ENABLE_SHIFT	17
+#define 	PAUSE_CONTROL_ENABLE_MASK	0x20000
+
+/*  flush_control offset0xb34  */
+#define 	FLUSH_CONTROL_FLUSH_SHIFT	0
+#define 	FLUSH_CONTROL_FLUSH_MASK	0x1
+
+/*  rxfifo_stat offset0xb38  */
+#define 	RXFIFO_STAT_RXFIFO_UNDERRUN_SHIFT	0
+#define 	RXFIFO_STAT_RXFIFO_UNDERRUN_MASK	0x1
+#define 	RXFIFO_STAT_RXFIFO_OVERRUN_SHIFT	1
+#define 	RXFIFO_STAT_RXFIFO_OVERRUN_MASK	0x2
+
+/*  txfifo_stat offset0xb3c  */
+#define 	TXFIFO_STAT_TXFIFO_UNDERRUN_SHIFT	0
+#define 	TXFIFO_STAT_TXFIFO_UNDERRUN_MASK	0x1
+#define 	TXFIFO_STAT_TXFIFO_OVERRUN_SHIFT	1
+#define 	TXFIFO_STAT_TXFIFO_OVERRUN_MASK	0x2
+
+#endif				/* _gmac0_core_h_ */
diff --git a/include/asm-mips/bcmsi/gmac_common.h b/include/asm-mips/bcmsi/gmac_common.h
new file mode 100644
index 0000000..431f463
--- /dev/null
+++ b/include/asm-mips/bcmsi/gmac_common.h
@@ -0,0 +1,566 @@
+/*
+ * Copyright (C) 2009 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,USA.
+ *
+ *
+ */
+/*
+ * gmacdefs - Broadcom gmac (Unimac) specific definitions
+ *
+ * $Copyright Open Broadcom Corporation$
+ *
+ */
+
+#ifndef _gmac_common_core_h_
+#define _gmac_common_core_h_
+
+#ifndef PAD
+#define     _PADLINE(line)    pad ## line
+#define     _XSTR(line)     _PADLINE(line)
+#define     PAD     XSTR(__LINE__)
+#endif
+
+typedef volatile struct _gmac_commonregs {
+    uint32 stag0;
+    uint32 stag1;
+    uint32 stag2;
+    uint32 stag3;
+    uint32 PAD[4];
+    uint32 parsercontrol;
+    uint32 mib_max_len;
+    uint32 PAD[54];
+    uint32 phyaccess;
+    uint32 phycontrol;
+    uint32 PAD[2];
+    uint32 gmac0_rgmii_cntl;
+    uint32 PAD[59];
+    uint32 cfp_access;
+    uint32 PAD[3];
+    uint32 cfp_tcam_data0;
+    uint32 cfp_tcam_data1;
+    uint32 cfp_tcam_data2;
+    uint32 cfp_tcam_data3;
+    uint32 cfp_tcam_data4;
+    uint32 cfp_tcam_data5;
+    uint32 cfp_tcam_data6;
+    uint32 cfp_tcam_data7;
+    uint32 cfp_tcam_mask0;
+    uint32 cfp_tcam_mask1;
+    uint32 cfp_tcam_mask2;
+    uint32 cfp_tcam_mask3;
+    uint32 cfp_tcam_mask4;
+    uint32 cfp_tcam_mask5;
+    uint32 cfp_tcam_mask6;
+    uint32 cfp_tcam_mask7;
+    uint32 cfp_action_data;
+    uint32 PAD[19];
+    uint32 tcam_bist_cntl;
+    uint32 tcam_bist_status;
+    uint32 tcam_cmp_status;
+    uint32 tcam_disable;
+    uint32 PAD[16];
+    uint32 tcam_test_cntl;
+    uint32 PAD[3];
+    uint32 udf_0_a3_a0;
+    uint32 udf_0_a7_a4;
+    uint32 udf_0_a8;
+    uint32 PAD[1];
+    uint32 udf_1_a3_a0;
+    uint32 udf_1_a7_a4;
+    uint32 udf_1_a8;
+    uint32 PAD[1];
+    uint32 udf_2_a3_a0;
+    uint32 udf_2_a7_a4;
+    uint32 udf_2_a8;
+    uint32 PAD[1];
+    uint32 udf_0_b3_b0;
+    uint32 udf_0_b7_b4;
+    uint32 udf_0_b8;
+    uint32 PAD[1];
+    uint32 udf_1_b3_b0;
+    uint32 udf_1_b7_b4;
+    uint32 udf_1_b8;
+    uint32 PAD[1];
+    uint32 udf_2_b3_b0;
+    uint32 udf_2_b7_b4;
+    uint32 udf_2_b8;
+    uint32 PAD[1];
+    uint32 udf_0_c3_c0;
+    uint32 udf_0_c7_c4;
+    uint32 udf_0_c8;
+    uint32 PAD[1];
+    uint32 udf_1_c3_c0;
+    uint32 udf_1_c7_c4;
+    uint32 udf_1_c8;
+    uint32 PAD[1];
+    uint32 udf_2_c3_c0;
+    uint32 udf_2_c7_c4;
+    uint32 udf_2_c8;
+    uint32 PAD[1];
+    uint32 udf_0_d3_d0;
+    uint32 udf_0_d7_d4;
+    uint32 udf_0_d11_d8;
+} gmac_commonregs_t;
+
+/*  stag0 offset0x0  */
+#define 	STAG0_TPID_SHIFT	0
+#define 	STAG0_TPID_MASK	0xffff
+
+/*  stag1 offset0x4  */
+#define 	STAG1_TPID_SHIFT	0
+#define 	STAG1_TPID_MASK	0xffff
+
+/*  stag2 offset0x8  */
+#define 	STAG2_TPID_SHIFT	0
+#define 	STAG2_TPID_MASK	0xffff
+
+/*  stag3 offset0xc  */
+#define 	STAG3_TPID_SHIFT	0
+#define 	STAG3_TPID_MASK	0xffff
+
+/*  parsercontrol offset0x20  */
+#define 	PARSERCONTROL_MAX_PARSER_LEN_TH_SHIFT	0
+#define 	PARSERCONTROL_MAX_PARSER_LEN_TH_MASK	0x3fff
+
+/*  mib_max_len offset0x24  */
+#define 	MIB_MAX_LEN_MIB_MAX_LEN_SHIFT	0
+#define 	MIB_MAX_LEN_MIB_MAX_LEN_MASK	0x3fff
+
+/*  phyaccess offset0x100  */
+#define 	PHYACCESS_TRIGGER_SHIFT	30
+#define 	PHYACCESS_TRIGGER_MASK	0x40000000
+#define 	PHYACCESS_WR_CMD_SHIFT	29
+#define 	PHYACCESS_WR_CMD_MASK	0x20000000
+#define 	PHYACCESS_CPU_REG_ADDR_SHIFT	24
+#define 	PHYACCESS_CPU_REG_ADDR_MASK	0x1f000000
+#define 	PHYACCESS_CPU_PHY_ADDR_SHIFT	16
+#define 	PHYACCESS_CPU_PHY_ADDR_MASK	0x1f0000
+#define 	PHYACCESS_ACC_DATA_SHIFT	0
+#define 	PHYACCESS_ACC_DATA_MASK	0xffff
+
+/*  phycontrol offset0x104  */
+#define 	PHYCONTROL_SD_ACCESS_EN_SHIFT	25
+#define 	PHYCONTROL_SD_ACCESS_EN_MASK	0x2000000
+#define 	PHYCONTROL_NWAY_AUTO_POLLING_EN_SHIFT	24
+#define 	PHYCONTROL_NWAY_AUTO_POLLING_EN_MASK	0x1000000
+#define 	PHYCONTROL_MDC_TRANSITION_EN_SHIFT	23
+#define 	PHYCONTROL_MDC_TRANSITION_EN_MASK	0x800000
+#define 	PHYCONTROL_MDC_CYCLE_TH_SHIFT	16
+#define 	PHYCONTROL_MDC_CYCLE_TH_MASK	0x7f0000
+#define 	PHYCONTROL_EXT_PHY_ADDR_SHIFT	0
+#define 	PHYCONTROL_EXT_PHY_ADDR_MASK	0x1f
+
+/*  gmac0_rgmii_cntl offset0x110  */
+#define 	GMAC0_RGMII_CNTL_TIMING_SEL_SHIFT	0
+#define 	GMAC0_RGMII_CNTL_TIMING_SEL_MASK	0x1
+#define 	GMAC0_RGMII_CNTL_RGMII_DLL_RXC_BYPASS_SHIFT	1
+#define 	GMAC0_RGMII_CNTL_RGMII_DLL_RXC_BYPASS_MASK	0x2
+#define 	GMAC0_RGMII_CNTL_BYPASS_2NS_DEL_SHIFT	2
+#define 	GMAC0_RGMII_CNTL_BYPASS_2NS_DEL_MASK	0x4
+#define 	GMAC0_RGMII_CNTL_DEL_STRB_SHIFT	3
+#define 	GMAC0_RGMII_CNTL_DEL_STRB_MASK	0x8
+#define 	GMAC0_RGMII_CNTL_DEL_VALUE_SHIFT	4
+#define 	GMAC0_RGMII_CNTL_DEL_VALUE_MASK	0x70
+#define 	GMAC0_RGMII_CNTL_DEL_ADDR_SHIFT	7
+#define 	GMAC0_RGMII_CNTL_DEL_ADDR_MASK	0x780
+
+/*  cfp_access offset0x200  */
+#define 	CFP_ACCESS_OP_START_DONE_SHIFT	0
+#define 	CFP_ACCESS_OP_START_DONE_MASK	0x1
+#define 	CFP_ACCESS_OP_SEL_SHIFT	1
+#define 	CFP_ACCESS_OP_SEL_MASK	0xe
+#define 	CFP_ACCESS_CFP_RAM_CLEAR_SHIFT	4
+#define 	CFP_ACCESS_CFP_RAM_CLEAR_MASK	0x10
+#define 	CFP_ACCESS_RESERVED1_SHIFT	5
+#define 	CFP_ACCESS_RESERVED1_MASK	0x3e0
+#define 	CFP_ACCESS_RAM_SEL_SHIFT	10
+#define 	CFP_ACCESS_RAM_SEL_MASK	0x7c00
+#define 	CFP_ACCESS_TCAM_RESET_SHIFT	15
+#define 	CFP_ACCESS_TCAM_RESET_MASK	0x8000
+#define 	CFP_ACCESS_XCESS_ADDR_SHIFT	16
+#define 	CFP_ACCESS_XCESS_ADDR_MASK	0x1ff0000
+#define 	CFP_ACCESS_RESERVED0_SHIFT	25
+#define 	CFP_ACCESS_RESERVED0_MASK	0xe000000
+#define 	CFP_ACCESS_RD_STATUS_SHIFT	28
+#define 	CFP_ACCESS_RD_STATUS_MASK	0xf0000000
+
+/*  cfp_tcam_data0 offset0x210  */
+#define 	CFP_TCAM_DATA0_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA0_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data1 offset0x214  */
+#define 	CFP_TCAM_DATA1_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA1_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data2 offset0x218  */
+#define 	CFP_TCAM_DATA2_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA2_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data3 offset0x21c  */
+#define 	CFP_TCAM_DATA3_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA3_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data4 offset0x220  */
+#define 	CFP_TCAM_DATA4_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA4_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data5 offset0x224  */
+#define 	CFP_TCAM_DATA5_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA5_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data6 offset0x228  */
+#define 	CFP_TCAM_DATA6_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA6_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_data7 offset0x22c  */
+#define 	CFP_TCAM_DATA7_DATA_SHIFT	0
+#define 	CFP_TCAM_DATA7_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask0 offset0x230  */
+#define 	CFP_TCAM_MASK0_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK0_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask1 offset0x234  */
+#define 	CFP_TCAM_MASK1_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK1_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask2 offset0x238  */
+#define 	CFP_TCAM_MASK2_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK2_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask3 offset0x23c  */
+#define 	CFP_TCAM_MASK3_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK3_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask4 offset0x240  */
+#define 	CFP_TCAM_MASK4_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK4_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask5 offset0x244  */
+#define 	CFP_TCAM_MASK5_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK5_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask6 offset0x248  */
+#define 	CFP_TCAM_MASK6_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK6_DATA_MASK	0xffffffff
+
+/*  cfp_tcam_mask7 offset0x24c  */
+#define 	CFP_TCAM_MASK7_DATA_SHIFT	0
+#define 	CFP_TCAM_MASK7_DATA_MASK	0xffffffff
+
+/*  cfp_action_data offset0x250  */
+#define 	CFP_ACTION_DATA_CHAINID_SHIFT	0
+#define 	CFP_ACTION_DATA_CHAINID_MASK	0xff
+#define 	CFP_ACTION_DATA_CHANNELID_SHIFT	8
+#define 	CFP_ACTION_DATA_CHANNELID_MASK	0xf00
+#define 	CFP_ACTION_DATA_DROP_SHIFT	12
+#define 	CFP_ACTION_DATA_DROP_MASK	0x1000
+#define 	CFP_ACTION_DATA_RESERVED_SHIFT	13
+#define 	CFP_ACTION_DATA_RESERVED_MASK	0xffffe000
+
+/*  tcam_bist_cntl offset0x2a0  */
+#define 	TCAM_BIST_CNTL_TCAM_BIST_EN_SHIFT	0
+#define 	TCAM_BIST_CNTL_TCAM_BIST_EN_MASK	0x1
+#define 	TCAM_BIST_CNTL_TCAM_BIST_TCAM_SEL_SHIFT	1
+#define 	TCAM_BIST_CNTL_TCAM_BIST_TCAM_SEL_MASK	0x6
+#define 	TCAM_BIST_CNTL_RESERVED1_SHIFT	3
+#define 	TCAM_BIST_CNTL_RESERVED1_MASK	0x8
+#define 	TCAM_BIST_CNTL_TCAM_BIST_STATUS_SEL_SHIFT	4
+#define 	TCAM_BIST_CNTL_TCAM_BIST_STATUS_SEL_MASK	0xf0
+#define 	TCAM_BIST_CNTL_TCAM_BIST_SKIP_ERR_CNT_SHIFT	8
+#define 	TCAM_BIST_CNTL_TCAM_BIST_SKIP_ERR_CNT_MASK	0xff00
+#define 	TCAM_BIST_CNTL_TCAM_TEST_COMPARE_SHIFT	16
+#define 	TCAM_BIST_CNTL_TCAM_TEST_COMPARE_MASK	0x10000
+#define 	TCAM_BIST_CNTL_RESERVED_SHIFT	17
+#define 	TCAM_BIST_CNTL_RESERVED_MASK	0x7ffe0000
+#define 	TCAM_BIST_CNTL_TCAM_BIST_DONE_SHIFT	31
+#define 	TCAM_BIST_CNTL_TCAM_BIST_DONE_MASK	0x80000000
+
+/*  tcam_bist_status offset0x2a4  */
+#define 	TCAM_BIST_STATUS_TCAM_BIST_STATUS_SHIFT	0
+#define 	TCAM_BIST_STATUS_TCAM_BIST_STATUS_MASK	0xffff
+#define 	TCAM_BIST_STATUS_RESERVED_SHIFT	16
+#define 	TCAM_BIST_STATUS_RESERVED_MASK	0xffff0000
+
+/*  tcam_cmp_status offset0x2a8  */
+#define 	TCAM_CMP_STATUS_TCAM_HIT_ADDR_SHIFT	0
+#define 	TCAM_CMP_STATUS_TCAM_HIT_ADDR_MASK	0x1ff
+#define 	TCAM_CMP_STATUS_RESERVED2_SHIFT	9
+#define 	TCAM_CMP_STATUS_RESERVED2_MASK	0x7e00
+#define 	TCAM_CMP_STATUS_TCAM_HIT_SHIFT	15
+#define 	TCAM_CMP_STATUS_TCAM_HIT_MASK	0x8000
+#define 	TCAM_CMP_STATUS_RESERVED1_SHIFT	16
+#define 	TCAM_CMP_STATUS_RESERVED1_MASK	0xffff0000
+
+/*  tcam_disable offset0x2ac  */
+#define 	TCAM_DISABLE_TCAM_DISABLE_SHIFT	0
+#define 	TCAM_DISABLE_TCAM_DISABLE_MASK	0xf
+#define 	TCAM_DISABLE_RESERVED_SHIFT	4
+#define 	TCAM_DISABLE_RESERVED_MASK	0xfffffff0
+
+/*  tcam_test_cntl offset0x2f0  */
+#define 	TCAM_TEST_CNTL_TCAM_TEST_CNTL_SHIFT	0
+#define 	TCAM_TEST_CNTL_TCAM_TEST_CNTL_MASK	0x7ff
+#define 	TCAM_TEST_CNTL_RESERVED_SHIFT	11
+#define 	TCAM_TEST_CNTL_RESERVED_MASK	0xfffff800
+
+/*  udf_0_a3_a0 offset0x300  */
+#define 	UDF_0_A3_A0_CFG_UDF_0_A0_SHIFT	0
+#define 	UDF_0_A3_A0_CFG_UDF_0_A0_MASK	0xff
+#define 	UDF_0_A3_A0_CFG_UDF_0_A1_SHIFT	8
+#define 	UDF_0_A3_A0_CFG_UDF_0_A1_MASK	0xff00
+#define 	UDF_0_A3_A0_CFG_UDF_0_A2_SHIFT	16
+#define 	UDF_0_A3_A0_CFG_UDF_0_A2_MASK	0xff0000
+#define 	UDF_0_A3_A0_CFG_UDF_0_A3_SHIFT	24
+#define 	UDF_0_A3_A0_CFG_UDF_0_A3_MASK	0xff000000
+
+/*  udf_0_a7_a4 offset0x304  */
+#define 	UDF_0_A7_A4_CFG_UDF_0_A4_SHIFT	0
+#define 	UDF_0_A7_A4_CFG_UDF_0_A4_MASK	0xff
+#define 	UDF_0_A7_A4_CFG_UDF_0_A5_SHIFT	8
+#define 	UDF_0_A7_A4_CFG_UDF_0_A5_MASK	0xff00
+#define 	UDF_0_A7_A4_CFG_UDF_0_A6_SHIFT	16
+#define 	UDF_0_A7_A4_CFG_UDF_0_A6_MASK	0xff0000
+#define 	UDF_0_A7_A4_CFG_UDF_0_A7_SHIFT	24
+#define 	UDF_0_A7_A4_CFG_UDF_0_A7_MASK	0xff000000
+
+/*  udf_0_a8 offset0x308  */
+#define 	UDF_0_A8_CFG_UDF_0_A8_SHIFT	0
+#define 	UDF_0_A8_CFG_UDF_0_A8_MASK	0xff
+
+/*  udf_1_a3_a0 offset0x310  */
+#define 	UDF_1_A3_A0_CFG_UDF_1_A0_SHIFT	0
+#define 	UDF_1_A3_A0_CFG_UDF_1_A0_MASK	0xff
+#define 	UDF_1_A3_A0_CFG_UDF_1_A1_SHIFT	8
+#define 	UDF_1_A3_A0_CFG_UDF_1_A1_MASK	0xff00
+#define 	UDF_1_A3_A0_CFG_UDF_1_A2_SHIFT	16
+#define 	UDF_1_A3_A0_CFG_UDF_1_A2_MASK	0xff0000
+#define 	UDF_1_A3_A0_CFG_UDF_1_A3_SHIFT	24
+#define 	UDF_1_A3_A0_CFG_UDF_1_A3_MASK	0xff000000
+
+/*  udf_1_a7_a4 offset0x314  */
+#define 	UDF_1_A7_A4_CFG_UDF_1_A4_SHIFT	0
+#define 	UDF_1_A7_A4_CFG_UDF_1_A4_MASK	0xff
+#define 	UDF_1_A7_A4_CFG_UDF_1_A5_SHIFT	8
+#define 	UDF_1_A7_A4_CFG_UDF_1_A5_MASK	0xff00
+#define 	UDF_1_A7_A4_CFG_UDF_1_A6_SHIFT	16
+#define 	UDF_1_A7_A4_CFG_UDF_1_A6_MASK	0xff0000
+#define 	UDF_1_A7_A4_CFG_UDF_1_A7_SHIFT	24
+#define 	UDF_1_A7_A4_CFG_UDF_1_A7_MASK	0xff000000
+
+/*  udf_1_a8 offset0x318  */
+#define 	UDF_1_A8_CFG_UDF_1_A8_SHIFT	0
+#define 	UDF_1_A8_CFG_UDF_1_A8_MASK	0xff
+
+/*  udf_2_a3_a0 offset0x320  */
+#define 	UDF_2_A3_A0_CFG_UDF_2_A0_SHIFT	0
+#define 	UDF_2_A3_A0_CFG_UDF_2_A0_MASK	0xff
+#define 	UDF_2_A3_A0_CFG_UDF_2_A1_SHIFT	8
+#define 	UDF_2_A3_A0_CFG_UDF_2_A1_MASK	0xff00
+#define 	UDF_2_A3_A0_CFG_UDF_2_A2_SHIFT	16
+#define 	UDF_2_A3_A0_CFG_UDF_2_A2_MASK	0xff0000
+#define 	UDF_2_A3_A0_CFG_UDF_2_A3_SHIFT	24
+#define 	UDF_2_A3_A0_CFG_UDF_2_A3_MASK	0xff000000
+
+/*  udf_2_a7_a4 offset0x324  */
+#define 	UDF_2_A7_A4_CFG_UDF_2_A4_SHIFT	0
+#define 	UDF_2_A7_A4_CFG_UDF_2_A4_MASK	0xff
+#define 	UDF_2_A7_A4_CFG_UDF_2_A5_SHIFT	8
+#define 	UDF_2_A7_A4_CFG_UDF_2_A5_MASK	0xff00
+#define 	UDF_2_A7_A4_CFG_UDF_2_A6_SHIFT	16
+#define 	UDF_2_A7_A4_CFG_UDF_2_A6_MASK	0xff0000
+#define 	UDF_2_A7_A4_CFG_UDF_2_A7_SHIFT	24
+#define 	UDF_2_A7_A4_CFG_UDF_2_A7_MASK	0xff000000
+
+/*  udf_2_a8 offset0x328  */
+#define 	UDF_2_A8_CFG_UDF_2_A8_SHIFT	0
+#define 	UDF_2_A8_CFG_UDF_2_A8_MASK	0xff
+
+/*  udf_0_b3_b0 offset0x330  */
+#define 	UDF_0_B3_B0_CFG_UDF_0_B0_SHIFT	0
+#define 	UDF_0_B3_B0_CFG_UDF_0_B0_MASK	0xff
+#define 	UDF_0_B3_B0_CFG_UDF_0_B1_SHIFT	8
+#define 	UDF_0_B3_B0_CFG_UDF_0_B1_MASK	0xff00
+#define 	UDF_0_B3_B0_CFG_UDF_0_B2_SHIFT	16
+#define 	UDF_0_B3_B0_CFG_UDF_0_B2_MASK	0xff0000
+#define 	UDF_0_B3_B0_CFG_UDF_0_B3_SHIFT	24
+#define 	UDF_0_B3_B0_CFG_UDF_0_B3_MASK	0xff000000
+
+/*  udf_0_b7_b4 offset0x334  */
+#define 	UDF_0_B7_B4_CFG_UDF_0_B4_SHIFT	0
+#define 	UDF_0_B7_B4_CFG_UDF_0_B4_MASK	0xff
+#define 	UDF_0_B7_B4_CFG_UDF_0_B5_SHIFT	8
+#define 	UDF_0_B7_B4_CFG_UDF_0_B5_MASK	0xff00
+#define 	UDF_0_B7_B4_CFG_UDF_0_B6_SHIFT	16
+#define 	UDF_0_B7_B4_CFG_UDF_0_B6_MASK	0xff0000
+#define 	UDF_0_B7_B4_CFG_UDF_0_B7_SHIFT	24
+#define 	UDF_0_B7_B4_CFG_UDF_0_B7_MASK	0xff000000
+
+/*  udf_0_b8 offset0x338  */
+#define 	UDF_0_B8_CFG_UDF_0_B8_SHIFT	0
+#define 	UDF_0_B8_CFG_UDF_0_B8_MASK	0xff
+
+/*  udf_1_b3_b0 offset0x340  */
+#define 	UDF_1_B3_B0_CFG_UDF_1_B0_SHIFT	0
+#define 	UDF_1_B3_B0_CFG_UDF_1_B0_MASK	0xff
+#define 	UDF_1_B3_B0_CFG_UDF_1_B1_SHIFT	8
+#define 	UDF_1_B3_B0_CFG_UDF_1_B1_MASK	0xff00
+#define 	UDF_1_B3_B0_CFG_UDF_1_B2_SHIFT	16
+#define 	UDF_1_B3_B0_CFG_UDF_1_B2_MASK	0xff0000
+#define 	UDF_1_B3_B0_CFG_UDF_1_B3_SHIFT	24
+#define 	UDF_1_B3_B0_CFG_UDF_1_B3_MASK	0xff000000
+
+/*  udf_1_b7_b4 offset0x344  */
+#define 	UDF_1_B7_B4_CFG_UDF_1_B4_SHIFT	0
+#define 	UDF_1_B7_B4_CFG_UDF_1_B4_MASK	0xff
+#define 	UDF_1_B7_B4_CFG_UDF_1_B5_SHIFT	8
+#define 	UDF_1_B7_B4_CFG_UDF_1_B5_MASK	0xff00
+#define 	UDF_1_B7_B4_CFG_UDF_1_B6_SHIFT	16
+#define 	UDF_1_B7_B4_CFG_UDF_1_B6_MASK	0xff0000
+#define 	UDF_1_B7_B4_CFG_UDF_1_B7_SHIFT	24
+#define 	UDF_1_B7_B4_CFG_UDF_1_B7_MASK	0xff000000
+
+/*  udf_1_b8 offset0x348  */
+#define 	UDF_1_B8_CFG_UDF_1_B8_SHIFT	0
+#define 	UDF_1_B8_CFG_UDF_1_B8_MASK	0xff
+
+/*  udf_2_b3_b0 offset0x350  */
+#define 	UDF_2_B3_B0_CFG_UDF_2_B0_SHIFT	0
+#define 	UDF_2_B3_B0_CFG_UDF_2_B0_MASK	0xff
+#define 	UDF_2_B3_B0_CFG_UDF_2_B1_SHIFT	8
+#define 	UDF_2_B3_B0_CFG_UDF_2_B1_MASK	0xff00
+#define 	UDF_2_B3_B0_CFG_UDF_2_B2_SHIFT	16
+#define 	UDF_2_B3_B0_CFG_UDF_2_B2_MASK	0xff0000
+#define 	UDF_2_B3_B0_CFG_UDF_2_B3_SHIFT	24
+#define 	UDF_2_B3_B0_CFG_UDF_2_B3_MASK	0xff000000
+
+/*  udf_2_b7_b4 offset0x354  */
+#define 	UDF_2_B7_B4_CFG_UDF_2_B4_SHIFT	0
+#define 	UDF_2_B7_B4_CFG_UDF_2_B4_MASK	0xff
+#define 	UDF_2_B7_B4_CFG_UDF_2_B5_SHIFT	8
+#define 	UDF_2_B7_B4_CFG_UDF_2_B5_MASK	0xff00
+#define 	UDF_2_B7_B4_CFG_UDF_2_B6_SHIFT	16
+#define 	UDF_2_B7_B4_CFG_UDF_2_B6_MASK	0xff0000
+#define 	UDF_2_B7_B4_CFG_UDF_2_B7_SHIFT	24
+#define 	UDF_2_B7_B4_CFG_UDF_2_B7_MASK	0xff000000
+
+/*  udf_2_b8 offset0x358  */
+#define 	UDF_2_B8_CFG_UDF_2_B8_SHIFT	0
+#define 	UDF_2_B8_CFG_UDF_2_B8_MASK	0xff
+
+/*  udf_0_c3_c0 offset0x360  */
+#define 	UDF_0_C3_C0_CFG_UDF_0_C0_SHIFT	0
+#define 	UDF_0_C3_C0_CFG_UDF_0_C0_MASK	0xff
+#define 	UDF_0_C3_C0_CFG_UDF_0_C1_SHIFT	8
+#define 	UDF_0_C3_C0_CFG_UDF_0_C1_MASK	0xff00
+#define 	UDF_0_C3_C0_CFG_UDF_0_C2_SHIFT	16
+#define 	UDF_0_C3_C0_CFG_UDF_0_C2_MASK	0xff0000
+#define 	UDF_0_C3_C0_CFG_UDF_0_C3_SHIFT	24
+#define 	UDF_0_C3_C0_CFG_UDF_0_C3_MASK	0xff000000
+
+/*  udf_0_c7_c4 offset0x364  */
+#define 	UDF_0_C7_C4_CFG_UDF_0_C4_SHIFT	0
+#define 	UDF_0_C7_C4_CFG_UDF_0_C4_MASK	0xff
+#define 	UDF_0_C7_C4_CFG_UDF_0_C5_SHIFT	8
+#define 	UDF_0_C7_C4_CFG_UDF_0_C5_MASK	0xff00
+#define 	UDF_0_C7_C4_CFG_UDF_0_C6_SHIFT	16
+#define 	UDF_0_C7_C4_CFG_UDF_0_C6_MASK	0xff0000
+#define 	UDF_0_C7_C4_CFG_UDF_0_C7_SHIFT	24
+#define 	UDF_0_C7_C4_CFG_UDF_0_C7_MASK	0xff000000
+
+/*  udf_0_c8 offset0x368  */
+#define 	UDF_0_C8_CFG_UDF_0_C8_SHIFT	0
+#define 	UDF_0_C8_CFG_UDF_0_C8_MASK	0xff
+
+/*  udf_1_c3_c0 offset0x370  */
+#define 	UDF_1_C3_C0_CFG_UDF_1_C0_SHIFT	0
+#define 	UDF_1_C3_C0_CFG_UDF_1_C0_MASK	0xff
+#define 	UDF_1_C3_C0_CFG_UDF_1_C1_SHIFT	8
+#define 	UDF_1_C3_C0_CFG_UDF_1_C1_MASK	0xff00
+#define 	UDF_1_C3_C0_CFG_UDF_1_C2_SHIFT	16
+#define 	UDF_1_C3_C0_CFG_UDF_1_C2_MASK	0xff0000
+#define 	UDF_1_C3_C0_CFG_UDF_1_C3_SHIFT	24
+#define 	UDF_1_C3_C0_CFG_UDF_1_C3_MASK	0xff000000
+
+/*  udf_1_c7_c4 offset0x374  */
+#define 	UDF_1_C7_C4_CFG_UDF_1_C4_SHIFT	0
+#define 	UDF_1_C7_C4_CFG_UDF_1_C4_MASK	0xff
+#define 	UDF_1_C7_C4_CFG_UDF_1_C5_SHIFT	8
+#define 	UDF_1_C7_C4_CFG_UDF_1_C5_MASK	0xff00
+#define 	UDF_1_C7_C4_CFG_UDF_1_C6_SHIFT	16
+#define 	UDF_1_C7_C4_CFG_UDF_1_C6_MASK	0xff0000
+#define 	UDF_1_C7_C4_CFG_UDF_1_C7_SHIFT	24
+#define 	UDF_1_C7_C4_CFG_UDF_1_C7_MASK	0xff000000
+
+/*  udf_1_c8 offset0x378  */
+#define 	UDF_1_C8_CFG_UDF_1_C8_SHIFT	0
+#define 	UDF_1_C8_CFG_UDF_1_C8_MASK	0xff
+
+/*  udf_2_c3_c0 offset0x380  */
+#define 	UDF_2_C3_C0_CFG_UDF_2_C0_SHIFT	0
+#define 	UDF_2_C3_C0_CFG_UDF_2_C0_MASK	0xff
+#define 	UDF_2_C3_C0_CFG_UDF_2_C1_SHIFT	8
+#define 	UDF_2_C3_C0_CFG_UDF_2_C1_MASK	0xff00
+#define 	UDF_2_C3_C0_CFG_UDF_2_C2_SHIFT	16
+#define 	UDF_2_C3_C0_CFG_UDF_2_C2_MASK	0xff0000
+#define 	UDF_2_C3_C0_CFG_UDF_2_C3_SHIFT	24
+#define 	UDF_2_C3_C0_CFG_UDF_2_C3_MASK	0xff000000
+
+/*  udf_2_c7_c4 offset0x384  */
+#define 	UDF_2_C7_C4_CFG_UDF_2_C4_SHIFT	0
+#define 	UDF_2_C7_C4_CFG_UDF_2_C4_MASK	0xff
+#define 	UDF_2_C7_C4_CFG_UDF_2_C5_SHIFT	8
+#define 	UDF_2_C7_C4_CFG_UDF_2_C5_MASK	0xff00
+#define 	UDF_2_C7_C4_CFG_UDF_2_C6_SHIFT	16
+#define 	UDF_2_C7_C4_CFG_UDF_2_C6_MASK	0xff0000
+#define 	UDF_2_C7_C4_CFG_UDF_2_C7_SHIFT	24
+#define 	UDF_2_C7_C4_CFG_UDF_2_C7_MASK	0xff000000
+
+/*  udf_2_c8 offset0x388  */
+#define 	UDF_2_C8_CFG_UDF_2_C8_SHIFT	0
+#define 	UDF_2_C8_CFG_UDF_2_C8_MASK	0xff
+
+/*  udf_0_d3_d0 offset0x390  */
+#define 	UDF_0_D3_D0_CFG_UDF_0_D0_SHIFT	0
+#define 	UDF_0_D3_D0_CFG_UDF_0_D0_MASK	0xff
+#define 	UDF_0_D3_D0_CFG_UDF_0_D1_SHIFT	8
+#define 	UDF_0_D3_D0_CFG_UDF_0_D1_MASK	0xff00
+#define 	UDF_0_D3_D0_CFG_UDF_0_D2_SHIFT	16
+#define 	UDF_0_D3_D0_CFG_UDF_0_D2_MASK	0xff0000
+#define 	UDF_0_D3_D0_CFG_UDF_0_D3_SHIFT	24
+#define 	UDF_0_D3_D0_CFG_UDF_0_D3_MASK	0xff000000
+
+/*  udf_0_d7_d4 offset0x394  */
+#define 	UDF_0_D7_D4_CFG_UDF_0_D4_SHIFT	0
+#define 	UDF_0_D7_D4_CFG_UDF_0_D4_MASK	0xff
+#define 	UDF_0_D7_D4_CFG_UDF_0_D5_SHIFT	8
+#define 	UDF_0_D7_D4_CFG_UDF_0_D5_MASK	0xff00
+#define 	UDF_0_D7_D4_CFG_UDF_0_D6_SHIFT	16
+#define 	UDF_0_D7_D4_CFG_UDF_0_D6_MASK	0xff0000
+#define 	UDF_0_D7_D4_CFG_UDF_0_D7_SHIFT	24
+#define 	UDF_0_D7_D4_CFG_UDF_0_D7_MASK	0xff000000
+
+/*  udf_0_d11_d8 offset0x398  */
+#define 	UDF_0_D11_D8_CFG_UDF_0_D8_SHIFT	0
+#define 	UDF_0_D11_D8_CFG_UDF_0_D8_MASK	0xff
+#define 	UDF_0_D11_D8_CFG_UDF_0_D9_SHIFT	8
+#define 	UDF_0_D11_D8_CFG_UDF_0_D9_MASK	0xff00
+#define 	UDF_0_D11_D8_CFG_UDF_0_D10_SHIFT	16
+#define 	UDF_0_D11_D8_CFG_UDF_0_D10_MASK	0xff0000
+#define 	UDF_0_D11_D8_CFG_UDF_0_D11_SHIFT	24
+#define 	UDF_0_D11_D8_CFG_UDF_0_D11_MASK	0xff000000
+
+#endif				/* _gmac_common_core_h_ */
-- 
1.7.0.4

