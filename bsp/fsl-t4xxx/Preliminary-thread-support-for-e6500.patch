From 88d84dde98ad81dc61297e512955b10f8f78ba51 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Thu, 8 Dec 2011 01:20:27 -0600
Subject: [PATCH 04/57] Preliminary thread support for e6500

commit 19dda798ffedde0a842999c5cdafd6c7bc999b02 from
https://git.freescale.com/git-private/cgit.cgi/ppc/t4240/linux.git

Add support for starting hardware threads on e6500.

The general idea is that each core will release all of its
threads into the secondary thread startup code, which will
eventually wait in the secondary core holding area, for the
appropriate bit in the PACA to be set. The kick_cpu function
pointer will set that bit in the PACA, and thus "release"
the core/thread to boot.

This is my third attempt. It boots with 24 threads. The big
change was the simulator, but I also moved thread enabling so
that only the first thread was doing it.

Caches are probably screwed up, as the "restore" function
doesn't know about the shared nature of the caches.

Also of note: there's no MMU protection. I was hoping that we could
show threads working without robustness, but that may be wrong. :)

Signed-off-by: Andy Fleming <afleming@freescale.com>
---
 arch/powerpc/include/asm/cputable.h  |    2 +-
 arch/powerpc/include/asm/reg_booke.h |   23 ++++++++++++++++
 arch/powerpc/kernel/exceptions-64e.S |   48 ++++++++++++++++++++++++++--------
 arch/powerpc/kernel/head_64.S        |   18 ++++++++++---
 arch/powerpc/kernel/prom.c           |   31 +++++++++-------------
 arch/powerpc/kernel/setup-common.c   |    9 ++++---
 arch/powerpc/kernel/setup_64.c       |    2 +-
 arch/powerpc/platforms/85xx/Kconfig  |    8 ++++++
 arch/powerpc/platforms/85xx/smp.c    |   15 ++++++++++-
 9 files changed, 116 insertions(+), 40 deletions(-)

diff --git a/arch/powerpc/include/asm/cputable.h b/arch/powerpc/include/asm/cputable.h
index 1c8d41a..ab88904 100644
--- a/arch/powerpc/include/asm/cputable.h
+++ b/arch/powerpc/include/asm/cputable.h
@@ -394,7 +394,7 @@ extern const char *powerpc_base_platform;
 #define CPU_FTRS_E6500	(CPU_FTR_USE_TB | CPU_FTR_NODSISRALIGN | \
 	    CPU_FTR_L2CSR | CPU_FTR_LWSYNC | CPU_FTR_NOEXECUTE | \
 	    CPU_FTR_DBELL | CPU_FTR_POPCNTB | CPU_FTR_POPCNTD | \
-	    CPU_FTR_DEBUG_LVL_EXC)
+	    CPU_FTR_DEBUG_LVL_EXC | CPU_FTR_SMT)
 #define CPU_FTRS_GENERIC_32	(CPU_FTR_COMMON | CPU_FTR_NODSISRALIGN)
 
 /* 64-bit CPUs */
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index 504a240..ab2c9a5 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -706,5 +706,28 @@
 #define MMUBE1_VBE4		0x00000002
 #define MMUBE1_VBE5		0x00000001
 
+#ifdef CONFIG_FSL_THREADS
+#define TMRN_TPRI0	0x0C0	/* Thread Priority Register 0 */
+#define TMRN_TPRI1	0x0C1	/* Thread Priority Register 1 */
+#define TMRN_TPRI2	0x0C2	/* Thread Priority Register 2 */
+#define TMRN_INIA0	0x140	/* Next Instruction Address Register 0 */
+#define TMRN_INIA1	0x141	/* Next Instruction Address Register 1 */
+#define TMRN_INIA2	0x142	/* Next Instruction Address Register 2 */
+#define TMRN_IMSR0	0x120	/* Initial MSR Register 0 */
+#define TMRN_IMSR1	0x121	/* Initial MSR Register 1 */
+#define SPRN_TENSR	0x1b5	/* Thread Enable Status Register */
+#define SPRN_TENS	0x1b6	/* Thread Enable Set Register */
+#define SPRN_TENC	0x1b7	/* Thread Enable Clear Register */
+
+#define TEN_THREAD(x)	(1 << x)
+
+#define SPRN_PPR32	0x382	/* Processor Priority Register */
+
+#define TMRN(x)		(((x & 0x1f) << 16) | ((x & 0x3e0) << 6))
+#define MTTMR(tmr, reg)	.long (0x7c0003dc | TMRN(tmr) | (reg << 21))
+#define MFTMR(tmr, reg)	.long (0x7c0002dc | TMRN(tmr) | (reg << 21))
+
+#endif
+
 #endif /* __ASM_POWERPC_REG_BOOKE_H__ */
 #endif /* __KERNEL__ */
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 5f9ef1b..371d74d 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -1223,6 +1223,11 @@ _GLOBAL(book3e_secondary_core_init)
 	/* Init global core bits */
 2:	bl	.init_core_book3e
 
+#ifdef CONFIG_FSL_THREADS
+	/* Start threads */
+	bl      .fsl_enable_threads
+#endif
+
 	/* Init per-thread bits */
 3:	bl	.init_thread_book3e
 
@@ -1258,6 +1263,27 @@ _STATIC(init_core_book3e)
 	sync
 	blr
 
+#ifdef CONFIG_FSL_THREADS
+_GLOBAL(fsl_enable_threads)
+	/* Configure the MSR per the default */
+	LOAD_REG_IMMEDIATE(r3, MSR_KERNEL);
+	MTTMR(TMRN_IMSR1, 3);
+
+	/*
+	 * Set the NIA for the secondary thread to
+	 * generic_secondary_thread_init
+	 */
+	LOAD_REG_IMMEDIATE(r3, .fsl_secondary_thread_init);
+	MTTMR(TMRN_INIA1, 3);
+
+	/* Release the other thread. It will spin until kick_cpu is called */
+	li	r3, 2
+	mtspr	SPRN_TENS, r3
+
+	blr
+#endif
+
+
 _STATIC(init_thread_book3e)
 	lis	r3,(SPRN_EPCR_ICM | SPRN_EPCR_GICM)@h
 	mtspr	SPRN_EPCR,r3
@@ -1276,18 +1302,18 @@ _STATIC(init_thread_book3e)
 _GLOBAL(__setup_base_ivors)
 	SET_IVOR(0, 0x020) /* Critical Input */
 	SET_IVOR(1, 0x000) /* Machine Check */
-	SET_IVOR(2, 0x060) /* Data Storage */ 
+	SET_IVOR(2, 0x060) /* Data Storage */
 	SET_IVOR(3, 0x080) /* Instruction Storage */
-	SET_IVOR(4, 0x0a0) /* External Input */ 
-	SET_IVOR(5, 0x0c0) /* Alignment */ 
-	SET_IVOR(6, 0x0e0) /* Program */ 
-	SET_IVOR(7, 0x100) /* FP Unavailable */ 
-	SET_IVOR(8, 0x120) /* System Call */ 
-	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */ 
-	SET_IVOR(10, 0x160) /* Decrementer */ 
-	SET_IVOR(11, 0x180) /* Fixed Interval Timer */ 
-	SET_IVOR(12, 0x1a0) /* Watchdog Timer */ 
-	SET_IVOR(13, 0x1c0) /* Data TLB Error */ 
+	SET_IVOR(4, 0x0a0) /* External Input */
+	SET_IVOR(5, 0x0c0) /* Alignment */
+	SET_IVOR(6, 0x0e0) /* Program */
+	SET_IVOR(7, 0x100) /* FP Unavailable */
+	SET_IVOR(8, 0x120) /* System Call */
+	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */
+	SET_IVOR(10, 0x160) /* Decrementer */
+	SET_IVOR(11, 0x180) /* Fixed Interval Timer */
+	SET_IVOR(12, 0x1a0) /* Watchdog Timer */
+	SET_IVOR(13, 0x1c0) /* Data TLB Error */
 	SET_IVOR(14, 0x1e0) /* Instruction TLB Error */
 	SET_IVOR(15, 0x040) /* Debug */
 
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index 58bddee..0ad03f7 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -161,6 +161,12 @@ exception_marker:
 #include "exceptions-64s.S"
 #endif
 
+#ifdef CONFIG_FSL_THREADS
+_GLOBAL(fsl_secondary_thread_init)
+	mfspr	r3, SPRN_PIR
+	rlwimi	r3, r3, 30, 2, 30
+#endif
+
 _GLOBAL(generic_secondary_thread_init)
 	mr	r24,r3
 
@@ -295,7 +301,7 @@ _STATIC(__mmu_off)
  *
  *   r5 != NULL -> OF entry, we go to prom_init, "legacy" parameter content
  *                 in r3...r7
- *   
+ *
  *   r5 == NULL -> kexec style entry. r3 is a physical pointer to the
  *                 DT block, r4 is a physical pointer to the kernel itself
  *
@@ -514,7 +520,7 @@ __secondary_start_pmac_0:
 	b	1f
 	li	r24,3
 1:
-	
+
 _GLOBAL(pmac_secondary_start)
 	/* turn on 64-bit mode */
 	bl	.enable_64b_mode
@@ -619,7 +625,7 @@ __secondary_start:
 	RFI
 	b	.	/* prevent speculative execution */
 
-/* 
+/*
  * Running with relocation on at this point.  All we want to do is
  * zero the stack back-chain pointer and get the TOC virtual address
  * before going into C code.
@@ -746,7 +752,7 @@ _INIT_STATIC(start_here_multiplatform)
 	mtspr	SPRN_SRR1,r4
 	RFI
 	b	.	/* prevent speculative execution */
-	
+
 	/* This is where all platforms converge execution */
 _INIT_GLOBAL(start_here_common)
 	/* relocation is on at this point */
@@ -758,6 +764,10 @@ _INIT_GLOBAL(start_here_common)
 	/* Do more system initializations in virtual mode */
 	bl	.setup_system
 
+#ifdef CONFIG_FSL_THREADS
+	bl	.fsl_enable_threads
+#endif
+
 	/* Mark interrupts soft and hard disabled (they might be enabled
 	 * in the PACA when doing hotplug)
 	 */
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index b021ff0..120edb7 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -309,12 +309,10 @@ static int __init early_init_dt_scan_cpus(unsigned long node,
 
 	/* Get physical cpuid */
 	intserv = of_get_flat_dt_prop(node, "ibm,ppc-interrupt-server#s", &len);
-	if (intserv) {
-		nthreads = len / sizeof(int);
-	} else {
-		intserv = of_get_flat_dt_prop(node, "reg", NULL);
-		nthreads = 1;
-	}
+	if (!intserv)
+		intserv = of_get_flat_dt_prop(node, "reg", &len);
+
+	nthreads = len / sizeof(int);
 
 	/*
 	 * Now see if any of these threads match our boot cpu.
@@ -851,23 +849,18 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 		intserv = of_get_property(np, "ibm,ppc-interrupt-server#s",
 				&plen);
 		if (intserv == NULL) {
-			const u32 *reg = of_get_property(np, "reg", NULL);
-			if (reg == NULL)
+			intserv = of_get_property(np, "reg", &plen);
+			if (intserv == NULL)
 				continue;
-			if (*reg == hardid) {
+		}
+
+		plen /= sizeof(u32);
+		for (t = 0; t < plen; t++) {
+			if (hardid == intserv[t]) {
 				if (thread)
-					*thread = 0;
+					*thread = t;
 				return np;
 			}
-		} else {
-			plen /= sizeof(u32);
-			for (t = 0; t < plen; t++) {
-				if (hardid == intserv[t]) {
-					if (thread)
-						*thread = t;
-					return np;
-				}
-			}
 		}
 	}
 	return NULL;
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index bdc499c..1f6cbae0c 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -444,16 +444,19 @@ void __init smp_setup_cpu_maps(void)
 		intserv = of_get_property(dn, "ibm,ppc-interrupt-server#s",
 				&len);
 		if (intserv) {
-			nthreads = len / sizeof(int);
 			DBG("    ibm,ppc-interrupt-server#s -> %d threads\n",
 			    nthreads);
 		} else {
 			DBG("    no ibm,ppc-interrupt-server#s -> 1 thread\n");
-			intserv = of_get_property(dn, "reg", NULL);
-			if (!intserv)
+			intserv = of_get_property(dn, "reg", &len);
+			if (!intserv) {
 				intserv = &cpu;	/* assume logical == phys */
+				len = 4;
+			}
 		}
 
+		nthreads = len / sizeof(int);
+
 		for (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {
 			DBG("    thread %d -> cpu %d (hard id %d)\n",
 			    j, cpu, intserv[j]);
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 389bd4f..e45f21c 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -421,7 +421,7 @@ void __init setup_system(void)
 	smp_setup_cpu_maps();
 	check_smt_enabled();
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_FSL_THREADS)
 	/* Release secondary cpus out of their spinloops at 0x60 now that
 	 * we can map physical -> logical CPU ids
 	 */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 27780bd..8fb5fe0 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -259,6 +259,14 @@ config P4080_DS
 
 endif # PPC32
 
+# Note that this is a big hack, surely we have to figure this out
+# at runtime.
+config FSL_THREADS
+	bool "Freescale smt"
+	default y
+	help
+	  This option enables support for e6500 SMT
+
 config P5020_DS
 	bool "Freescale P5020 DS"
 	select DEFAULT_UIMAGE
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index ddc0ef5..08611aa 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -25,6 +25,7 @@
 #include <asm/mpic.h>
 #include <asm/cacheflush.h>
 #include <asm/dbell.h>
+#include <asm/cputhreads.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/mpic.h>
@@ -74,7 +75,6 @@ static void __cpuinit smp_85xx_mach_cpu_die(void)
 #endif
 
 static int __cpuinit smp_85xx_kick_cpu(int nr)
-
 {
 	unsigned long flags;
 	const u64 *cpu_rel_addr;
@@ -89,6 +89,19 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 
 	pr_debug("smp_85xx_kick_cpu: kick CPU #%d\n", nr);
 
+#ifdef CONFIG_PPC64
+	/* If the cpu we're kicking is a thread, kick it and return */
+	if (cpu_thread_in_core(nr) != 0) {
+		local_irq_save(flags);
+
+		smp_generic_kick_cpu(nr);
+
+		local_irq_restore(flags);
+
+		return 0;
+	}
+#endif
+
 	np = of_get_cpu_node(nr, NULL);
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 
-- 
1.7.9.7

