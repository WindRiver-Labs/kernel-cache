From 76b52e83d0da93d138c514c66a8df5e0e5bed3f4 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Tue, 19 Jun 2012 20:16:48 +0300
Subject: [PATCH 36/57] fmd: Add FMan v3 specific files

commit 7a204b2c331bc38f5f147a2475a2e16368db579f from
https://git.freescale.com/git-private/cgit.cgi/ppc/t4240/linux.git

Added support for MEMAC and frame replicator.

These are specific to FMan v3 and therefore needed for when
v3 support will be enabled.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
---
 .../dpa/NetCommSw/Peripherals/FM/MAC/Makefile      |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.c       | 1060 ++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.h       |  389 +++++++
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c   |  138 +++
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h   |   80 ++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/Makefile      |    3 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c   | 1176 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h   |   95 ++
 8 files changed, 2941 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
index 00c36a1..7ea2b83 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -11,4 +11,4 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-MAC.o
 
-fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
+fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o memac.o memac_mii_acc.o
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
new file mode 100644
index 0000000..cb6959b
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
@@ -0,0 +1,1060 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          memac.c
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "fm_common.h"
+#include "memac.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Memac *p_Memac)
+{
+    e_FmMacType     portType;
+
+    portType = ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+#if (FM_MAX_NUM_OF_10G_MACS > 0)
+    if((portType == e_FM_MAC_10G) && (p_Memac->macId >= FM_MAX_NUM_OF_10G_MACS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("10G MAC ID must be less than %d", FM_MAX_NUM_OF_10G_MACS));
+#endif
+    if((portType == e_FM_MAC_1G) && (p_Memac->macId >= FM_MAX_NUM_OF_1G_MACS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("1G MAC ID must be less than %d", FM_MAX_NUM_OF_1G_MACS));
+    if(p_Memac->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC must have a valid MAC address"));
+    if(!p_Memac->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Exception"));
+    if(!p_Memac->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Event"));
+    return E_OK;
+
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+    if(!p_Memac->p_MemacDriverParam->noLengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+
+}
+
+/* .............................................................................. */
+
+static void SetDefaultParam(t_MemacDriverParam *p_MemacDriverParam)
+{
+    p_MemacDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
+    p_MemacDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousEnable;
+    p_MemacDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
+    p_MemacDriverParam->pauseIgnore              = DEFAULT_rxIgnorePause;
+    p_MemacDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
+
+    p_MemacDriverParam->loopbackEnable           = DEFAULT_loopback;
+    p_MemacDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
+    p_MemacDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
+    p_MemacDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
+    p_MemacDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
+
+    p_MemacDriverParam->noLengthCheckEnable      = !DEFAULT_lengthCheckEnable;
+
+    p_MemacDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
+    p_MemacDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
+    p_MemacDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
+    p_MemacDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
+    p_MemacDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
+
+    p_MemacDriverParam->txIpgLength              = DEFAULT_txIpgLength;
+    p_MemacDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
+
+    p_MemacDriverParam->debugMode                = DEFAULT_debugMode;
+
+    p_MemacDriverParam->pauseTime                = DEFAULT_pauseTime;
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    p_MemacDriverParam->skipFman11Workaround     = DEFAULT_skipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+}
+
+/* ........................................................................... */
+
+static void MemacErrException(t_Handle h_Memac)
+{
+    t_Memac             *p_Memac = (t_Memac *)h_Memac;
+    uint32_t            event;
+    t_MemacMemMap        *p_MemacMemMap = p_Memac->p_MemMap;
+
+    event = GET_UINT32(p_MemacMemMap->ievent);
+    /* do not handle MDIO events */
+    //event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+
+    event &= GET_UINT32(p_MemacMemMap->imask);
+
+    WRITE_UINT32(p_MemacMemMap->ievent, event);
+
+}
+
+
+static void FreeInitResources(t_Memac *p_Memac)
+{
+    e_FmMacType             portType;
+
+    portType =
+        ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+    if (portType == e_FM_MAC_10G)
+        FmUnregisterIntr(p_Memac->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Memac->macId, e_FM_INTR_TYPE_ERR);
+    else
+        FmUnregisterIntr(p_Memac->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Memac->macId, e_FM_INTR_TYPE_ERR);
+
+    /* release the driver's group hash table */
+    FreeHashTable(p_Memac->p_MulticastAddrHash);
+    p_Memac->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Memac->p_UnicastAddrHash);
+    p_Memac->p_UnicastAddrHash =     NULL;
+}
+
+/* .............................................................................. */
+
+static void HardwareClearAddrInPaddr(t_Memac *p_Memac, uint8_t paddrNum)
+{
+    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_l, 0x0);
+    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_u, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Memac *p_Memac, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t        tmpReg32 = 0;
+    uint64_t        addr = *p_Addr;
+    t_MemacMemMap   *p_MemacMemMap = p_Memac->p_MemMap;
+
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_u, tmpReg32);
+}
+
+/*****************************************************************************/
+/*                     10G MAC API routines                                  */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+    }
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    switch (mode)
+    {
+        case e_COMM_MODE_RX:
+            tmpReg32 &= ~CMD_CFG_RX_EN;
+            break;
+        case e_COMM_MODE_TX:
+            tmpReg32 &= ~CMD_CFG_TX_EN;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
+{
+    t_Memac       *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap *p_MemacMemMap;
+    uint32_t     tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    tmpReg32 = GET_UINT32(p_MemacMemMap->command_config);
+
+    if (newVal)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    else
+        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+
+    WRITE_UINT32(p_MemacMemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Memac Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->loopbackEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->wanModeEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigMaxFrameLength(t_Handle h_Memac, uint16_t newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->noLengthCheckEnable = !newVal;
+
+    return E_OK;
+}
+
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+/* .............................................................................. */
+
+static t_Error MemacConfigSkipFman11Workaround(t_Handle h_Memac)
+{
+    t_Memac      *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->skipFman11Workaround     = TRUE;
+
+    return E_OK;
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+
+/*****************************************************************************/
+/*                      Memac Run Time API functions                         */
+/*****************************************************************************/
+
+static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
+                                     uint8_t  priority,
+                                     uint16_t pauseTime,
+                                     uint16_t threshTime)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    uint32_t         tmpReg32 = 0;
+    t_MemacMemMap    *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    if (priority == FM_MAC_NO_PFC)
+    {
+        tmpReg32 &= ~CMD_CFG_PFC_MODE;
+        priority = 0;
+    }
+    else
+        tmpReg32 |= CMD_CFG_PFC_MODE;
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    tmpReg32 =  GET_UINT32(p_MemMap->pause_quanta[priority/2]);
+    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
+    tmpReg32 |= ((uint32_t)pauseTime<<(16*(priority%2)));
+    WRITE_UINT32(p_MemMap->pause_quanta[priority/2], tmpReg32);
+
+    tmpReg32 =  GET_UINT32(p_MemMap->pause_thresh[priority/2]);
+    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
+    tmpReg32 |= ((uint32_t)threshTime<<(16*(priority%2)));
+    WRITE_UINT32(p_MemMap->pause_thresh[priority/2], tmpReg32);
+
+    return E_OK;
+}
+/* .............................................................................. */
+static t_Error MemacSetTxAutoPauseFrames(t_Handle h_Memac,
+                                         uint16_t pauseTime)
+{
+    return MemacSetTxPauseFrames(h_Memac, FM_MAC_NO_PFC, pauseTime,0);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    if (en)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    else
+        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* .............................................................................. */
+
+static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statistics)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    p_Statistics->eStatPkts64           = (((uint64_t)GET_UINT32(p_MemacMemMap->r64_u)<<32)|GET_UINT32(p_MemacMemMap->r64_l));
+    p_Statistics->eStatPkts65to127      = (((uint64_t)GET_UINT32(p_MemacMemMap->r127_u)<<32)|GET_UINT32(p_MemacMemMap->r127_l));
+    p_Statistics->eStatPkts128to255     = (((uint64_t)GET_UINT32(p_MemacMemMap->r255_u)<<32)|GET_UINT32(p_MemacMemMap->r255_l));
+    p_Statistics->eStatPkts256to511     = (((uint64_t)GET_UINT32(p_MemacMemMap->r511_u)<<32)|GET_UINT32(p_MemacMemMap->r511_l));
+    p_Statistics->eStatPkts512to1023    = (((uint64_t)GET_UINT32(p_MemacMemMap->r1023_u)<<32)|GET_UINT32(p_MemacMemMap->r1023_l));
+    p_Statistics->eStatPkts1024to1518   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1518_u)<<32)|GET_UINT32(p_MemacMemMap->r1518_l));
+    p_Statistics->eStatPkts1519to1522   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1519x_u)<<32)|GET_UINT32(p_MemacMemMap->r1519x_l));
+/* */
+    p_Statistics->eStatFragments        = (((uint64_t)GET_UINT32(p_MemacMemMap->rfrg_u)<<32)|GET_UINT32(p_MemacMemMap->rfrg_l));
+    p_Statistics->eStatJabbers          = (((uint64_t)GET_UINT32(p_MemacMemMap->rjbr_u)<<32)|GET_UINT32(p_MemacMemMap->rjbr_l));
+
+    p_Statistics->eStatsDropEvents      = (((uint64_t)GET_UINT32(p_MemacMemMap->rdrp_u)<<32)|GET_UINT32(p_MemacMemMap->rdrp_l));
+    p_Statistics->eStatCRCAlignErrors   = (((uint64_t)GET_UINT32(p_MemacMemMap->raln_u)<<32)|GET_UINT32(p_MemacMemMap->raln_l));
+
+    p_Statistics->eStatUndersizePkts    = (((uint64_t)GET_UINT32(p_MemacMemMap->tund_u)<<32)|GET_UINT32(p_MemacMemMap->tund_l));
+    p_Statistics->eStatOversizePkts     = (((uint64_t)GET_UINT32(p_MemacMemMap->rovr_u)<<32)|GET_UINT32(p_MemacMemMap->rovr_l));
+/* Pause */
+    p_Statistics->reStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->rxpf_u)<<32)|GET_UINT32(p_MemacMemMap->rxpf_l));
+    p_Statistics->teStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->txpf_u)<<32)|GET_UINT32(p_MemacMemMap->txpf_l));
+
+/* MIB II */
+    p_Statistics->ifInOctets            = (((uint64_t)GET_UINT32(p_MemacMemMap->roct_u)<<32)|GET_UINT32(p_MemacMemMap->roct_l));
+    p_Statistics->ifInMcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rmca_u)<<32)|GET_UINT32(p_MemacMemMap->rmca_l));
+    p_Statistics->ifInBcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rbca_u)<<32)|GET_UINT32(p_MemacMemMap->rbca_l));
+    p_Statistics->ifInPkts              = (((uint64_t)GET_UINT32(p_MemacMemMap->ruca_u)<<32)|GET_UINT32(p_MemacMemMap->ruca_l))
+                                        + p_Statistics->ifInMcastPkts
+                                        + p_Statistics->ifInBcastPkts;
+    p_Statistics->ifInDiscards          = 0;
+    p_Statistics->ifInErrors            = (((uint64_t)GET_UINT32(p_MemacMemMap->rerr_u)<<32)|GET_UINT32(p_MemacMemMap->rerr_l));
+
+    p_Statistics->ifOutOctets           = (((uint64_t)GET_UINT32(p_MemacMemMap->toct_u)<<32)|GET_UINT32(p_MemacMemMap->toct_l));
+    p_Statistics->ifOutMcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tmca_u)<<32)|GET_UINT32(p_MemacMemMap->tmca_l));
+    p_Statistics->ifOutBcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tbca_u)<<32)|GET_UINT32(p_MemacMemMap->tbca_l));
+    p_Statistics->ifOutPkts             = (((uint64_t)GET_UINT32(p_MemacMemMap->tuca_u)<<32)|GET_UINT32(p_MemacMemMap->tuca_l))
+                                            + p_Statistics->ifOutMcastPkts
+                                            + p_Statistics->ifOutBcastPkts;
+    p_Statistics->ifOutDiscards         = 0;
+    p_Statistics->ifOutErrors           = (((uint64_t)GET_UINT32(p_MemacMemMap->terr_u)<<32)|GET_UINT32(p_MemacMemMap->terr_l));
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
+{
+    t_Memac              *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap        *p_MemacMemMap;
+    uint32_t            tmpReg32 = 0;
+    uint64_t            addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Memac->addr = addr;
+
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_u, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacResetCounters (t_Handle h_Memac)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap       *p_MemMap ;
+    uint32_t            tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->statn_config);
+
+    tmpReg32 |= STATS_CFG_CLR;
+
+    WRITE_UINT32(p_MemMap->statn_config, tmpReg32);
+
+    while (tmpReg32 & STATS_CFG_CLR)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->statn_config);
+    }
+
+    /*for (i=0; i<1000; i++)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->command_config);
+        if (!(tmpReg32 & CMD_CFG_STAT_CLR))
+            break;
+    }
+
+    cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
+    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);*/
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac   *p_Memac = (t_Memac *) h_Memac;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+        if (p_Memac->indAddrRegUsed[paddrNum])
+            if (p_Memac->paddr[paddrNum] == ethAddr)
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+        if (!(p_Memac->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Memac->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Memac->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Memac, &ethAddr, paddrNum);
+            p_Memac->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac   *p_Memac = (t_Memac *) h_Memac;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Memac->indAddrRegUsed[paddrNum]) &&
+            (p_Memac->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Memac->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Memac, paddrNum);
+            p_Memac->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+    t_EthHashEntry  *p_HashEntry;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (!(ethAddr & GROUP_ADDRESS))
+        /* Unicast addresses not supported in hash */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    LIST_AddToTail(&(p_HashEntry->node), &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]));
+    WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+
+    LIST_FOR_EACH(p_Pos, &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
+    {
+
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+        if(p_HashEntry->addr == ethAddr)
+        {
+            LIST_DelAndInit(&p_HashEntry->node);
+            XX_Free(p_HashEntry);
+            break;
+        }
+    }
+    if(LIST_IsEmpty(&p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
+        WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+/* .............................................................................. */
+
+static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
+{
+    t_Memac              *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_VALUE(p_Memac, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Memac->p_MemMap->maxfrm);
+}
+
+/* .............................................................................. */
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+static t_Error MemacTxEccWorkaround(t_Memac *p_Memac)
+{
+    t_Error err;
+
+#if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
+    XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
+#endif /* (DEBUG_ERRORS > 0) */
+    /* enable and set promiscuous */
+    WRITE_UINT32(p_Memac->p_MemMap->command_config, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+    err = Fm10GTxEccWorkaround(p_Memac->fmMacControllerDriver.h_Fm, p_Memac->macId);
+    /* disable */
+    WRITE_UINT32(p_Memac->p_MemMap->command_config, 0);
+#if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
+    if (err)
+        XX_Print("FAILED!\n");
+    else
+        XX_Print("done.\n");
+#endif /* (DEBUG_ERRORS > 0) */
+    MemacResetCounters (p_Memac);
+
+    return err;
+}
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+/* .............................................................................. */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error MemacDumpRegs(t_Handle h_Memac)
+{
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacInit(t_Handle h_Memac)
+{
+    t_Memac                 *p_Memac = (t_Memac *)h_Memac;
+    t_MemacDriverParam      *p_MemacDriverParam;
+    t_MemacMemMap           *p_MemMap;
+    uint64_t                addr;
+    uint32_t                tmpReg32;
+    e_FmMacType             portType;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    if (p_Memac->fmMacControllerDriver.fmRevInfo.majorRev <= 6 )/*fixed for rev3 */
+    {
+        if (!p_Memac->p_MemacDriverParam->skipFman11Workaround &&
+            ((err = MemacTxEccWorkaround(p_Memac)) != E_OK))
+        {
+            FreeInitResources(p_Memac);
+            RETURN_ERROR(MAJOR, err, ("MemacTxEccWorkaround FAILED"));
+        }
+    }
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+    CHECK_INIT_PARAMETERS(p_Memac, CheckInitParameters);
+
+    p_MemacDriverParam = p_Memac->p_MemacDriverParam;
+    p_MemMap = p_Memac->p_MemMap;
+
+    portType =
+        ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+    /* First, reset the MAC if desired. */
+    if (p_MemacDriverParam->resetOnInit)
+    {
+        WRITE_UINT32(p_MemMap->command_config,
+                     GET_UINT32(p_MemMap->command_config) | CMD_CFG_SW_RESET);
+        XX_UDelay(10);
+        while (GET_UINT32(p_MemMap->command_config) | CMD_CFG_SW_RESET) ;
+    }
+
+    /* MAC Address */
+    addr = p_Memac->addr;
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_u, tmpReg32);
+
+    /* Config */
+    tmpReg32 = 0;
+    if (p_MemacDriverParam->wanModeEnable)
+        tmpReg32 |= CMD_CFG_WAN_MODE;
+    if (p_MemacDriverParam->promiscuousModeEnable)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    if (p_MemacDriverParam->pauseForwardEnable)
+        tmpReg32 |= CMD_CFG_PAUSE_FWD;
+    if (p_MemacDriverParam->pauseIgnore)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    if (p_MemacDriverParam->txAddrInsEnable)
+        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+    if (p_MemacDriverParam->loopbackEnable)
+        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
+    if (p_MemacDriverParam->cmdFrameEnable)
+        tmpReg32 |= CMD_CFG_CNT_FRM_EN;
+    if (p_MemacDriverParam->sendIdleEnable)
+        tmpReg32 |= CMD_CFG_SEND_IDLE;
+    if (p_MemacDriverParam->noLengthCheckEnable)
+        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+    if (p_MemacDriverParam->rxSfdAny)
+        tmpReg32 |= CMD_CFG_SFD_ANY;
+    tmpReg32 |= CMD_CFG_SW_RESET | CMD_CFG_CRC_FWD | CMD_CFG_TX_PAD_EN;
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    /* Set up interface bits */
+    tmpReg32 = GET_UINT32(p_MemMap->if_mode) & ~IF_MODE_MASK;
+    if (portType == e_FM_MAC_10G)
+        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_XGMII);
+    else
+        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_GMII);
+
+    /* Max Frame Length */
+    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_MemacDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Memac->fmMacControllerDriver.h_Fm, portType, p_Memac->fmMacControllerDriver.macId, p_MemacDriverParam->maxFrameLength);
+    if(err)
+    {
+        FreeInitResources(p_Memac);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    /* Pause Time */
+    WRITE_UINT32(p_MemMap->pause_quanta[0], p_MemacDriverParam->pauseTime);
+    WRITE_UINT32(p_MemMap->pause_thresh[0], 0);
+
+#ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
+    if (p_Memac->fmMacControllerDriver.fmRevInfo.majorRev == 2 /*fixed for rev3 */)
+    {
+        WRITE_UINT32(p_Memac->p_MemMap->tx_ipg_length,
+            (GET_UINT32(p_Memac->p_MemMap->tx_ipg_length) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
+    }
+#endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
+
+    p_Memac->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Memac->p_MulticastAddrHash)
+    {
+        FreeInitResources(p_Memac);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Memac->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Memac->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Memac);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    /* interrupts */
+    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
+    WRITE_UINT32(p_MemMap->imask, p_Memac->exceptions);
+
+    if (portType == e_FM_MAC_10G)
+        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
+                       e_FM_MOD_10G_MAC,
+                       p_Memac->macId,
+                       e_FM_INTR_TYPE_ERR,
+                       MemacErrException,
+                       p_Memac);
+    else
+        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
+                       e_FM_MOD_1G_MAC,
+                       p_Memac->macId,
+                       e_FM_INTR_TYPE_ERR,
+                       MemacErrException,
+                       p_Memac);
+    /*if ((p_Memac->mdioIrq != 0) && (p_Memac->mdioIrq != NO_IRQ))
+    {
+        XX_SetIntr(p_Memac->mdioIrq, MemacException, p_Memac);
+        XX_EnableIntr(p_Memac->mdioIrq);
+    }
+    else if (p_Memac->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));*/
+
+    XX_Free(p_MemacDriverParam);
+    p_Memac->p_MemacDriverParam = NULL;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacFree(t_Handle h_Memac)
+{
+    t_Memac       *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+
+    FreeInitResources(p_Memac);
+
+    if (p_Memac->p_MemacDriverParam)
+    {
+        XX_Free(p_Memac->p_MemacDriverParam);
+        p_Memac->p_MemacDriverParam = NULL;
+    }
+    XX_Free (p_Memac);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = MemacInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = MemacFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetStatistics             = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = MemacConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = MemacConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = MemacConfigWan;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = NULL; /* MEMAC always works with pad+crc */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = MemacConfigLengthCheck;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = NULL; //MemacConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL; //MemacConfigResetOnInit;
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround= MemacConfigSkipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = NULL; //MemacSetExcpetion;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = NULL; //MemacEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL; //MemacDisable1588TimeStamp;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = MemacSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = NULL;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = MemacEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = MemacDisable;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = MemacSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = MemacSetTxPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = MemacSetRxIgnorePauseFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = MemacResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = MemacGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = MemacModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = MemacAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = MemacDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = MemacAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = MemacDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = MemacGetMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MEMAC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MEMAC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = MemacDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+
+/*****************************************************************************/
+/*                      Memac Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Memac                 *p_Memac;
+    t_MemacDriverParam      *p_MemacDriverParam;
+    uintptr_t               baseAddr;
+    uint8_t                 i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    baseAddr = p_FmMacParam->baseAddr;
+
+    /* Allocate memory for the mEMAC data structure */
+    p_Memac = (t_Memac *) XX_Malloc(sizeof(t_Memac));
+    if (!p_Memac)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver structure"));
+        return NULL;
+    }
+    /* Zero out *p_Memac */
+    memset(p_Memac, 0, sizeof(t_Memac));
+    InitFmMacControllerDriver(&p_Memac->fmMacControllerDriver);
+
+    /* Allocate memory for the mEMAC driver parameters data structure */
+    p_MemacDriverParam = (t_MemacDriverParam *) XX_Malloc(sizeof(t_MemacDriverParam));
+    if (!p_MemacDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver parameters"));
+        MemacFree(p_Memac);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_MemacDriverParam, 0, sizeof(t_MemacDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Memac->p_MemacDriverParam = p_MemacDriverParam;
+
+    SetDefaultParam(p_MemacDriverParam);
+
+   for (i=0; i < sizeof(p_FmMacParam->addr); i++)
+        p_Memac->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
+
+    p_Memac->p_MemMap        = (t_MemacMemMap *)UINT_TO_PTR(baseAddr);
+    p_Memac->p_MiiMemMap     = (t_MemacMiiAccessMemMap *)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
+    p_Memac->enetMode        = p_FmMacParam->enetMode;
+    p_Memac->macId           = p_FmMacParam->macId;
+    p_Memac->exceptions      = DEFAULT_exceptions;
+    p_Memac->f_Exception     = p_FmMacParam->f_Exception;
+    p_Memac->f_Event         = p_FmMacParam->f_Event;
+    p_Memac->h_App           = p_FmMacParam->h_App;
+
+    return p_Memac;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
new file mode 100644
index 0000000..c729b6b
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
@@ -0,0 +1,389 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          memac.h
+
+ @Description   FM Multirate Ethernet MAC (mEMAC)
+*//***************************************************************************/
+#ifndef __MEMAC_H
+#define __MEMAC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "memac_mii_acc.h"
+#include "fm_mac.h"
+
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_PCS                   0x80000000  /* 0 PCS
+                                                 * XGMII - PCS event
+                                                 * GMII - link synchronization event
+                                                 */
+#define IMASK_AN                    0x40000000  /* 1 AN
+                                                 * XGMII - Auto-negotiation event
+                                                 * GMII - Auto-negotiation status
+                                                 */
+#define IMASK_LT                    0x20000000  /* 2 LT
+                                                 * XGMII - Link Training event
+                                                 * GMII - new page received by auto-negotiation function
+                                                 */
+#define IMASK_MGI                   0x00004000  /* 17 Magic packet detection indication event */
+#define IMASK_RX_FIFO_OVFL          0x00001000  /* 19 Receive FIFO overflow event */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 Transmit FIFO underflow event */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 Transmit FIFO overflow event */
+#define IMASK_TX_ECC_ER             0x00000200  /* 22 Transmit frame ECC error event */
+#define IMASK_RX_ECC_ER             0x00000100  /* 23 Receive frame ECC error event */
+#define IMASK_LI_FAULT              0x00000080  /* 24 Link Interruption fault event (XGMII) */
+#define IMASK_RX_EMPTY              0x00000040  /* 25 Receive FIFO empty event */
+#define IMASK_TX_EMPTY              0x00000020  /* 26 Transmit FIFO empty event */
+#define IMASK_RX_LOWP               0x00000010  /* 27 Low Power Idle event */
+#define IMASK_PHY_LOS               0x00000004  /* 29 Phy loss of signal event */
+#define IMASK_REM_FAULT             0x00000002  /* 30 Remote fault event (XGMII) */
+#define IMASK_LOC_FAULT             0x00000001  /* 31 Local fault event (XGMII) */
+
+#define EVENTS_MASK                 ((uint32_t)(IMASK_PCS           |  \
+                                                IMASK_AN            |  \
+                                                IMASK_LT            |  \
+                                                IMASK_MGI           |  \
+                                                IMASK_RX_FIFO_OVFL  |  \
+                                                IMASK_TX_FIFO_UNFL  |  \
+                                                IMASK_TX_FIFO_OVFL  |  \
+                                                IMASK_TX_ECC_ER     |  \
+                                                IMASK_RX_ECC_ER     |  \
+                                                IMASK_LI_FAULT      |  \
+                                                IMASK_RX_EMPTY      |  \
+                                                IMASK_TX_EMPTY      |  \
+                                                IMASK_RX_LOWP       |  \
+                                                IMASK_PHY_LOS       |  \
+                                                IMASK_REM_FAULT     |  \
+                                                IMASK_LOC_FAULT))
+
+#define GET_EXCEPTION_FLAG(bitMask, exception) \
+    (bitMask = EVENTS_MASK)
+
+
+#define DEFAULT_pauseForwardEnable          FALSE
+#define DEFAULT_txAddrInsEnable             FALSE
+#define DEFAULT_cmdFrameEnable              FALSE
+#define DEFAULT_rxErrorDiscard              FALSE
+#define DEFAULT_phyTxenaOn                  FALSE
+#define DEFAULT_sendIdleEnable              FALSE
+#define DEFAULT_lgthCheckNostdr             FALSE
+#define DEFAULT_rxSfdAny                    FALSE
+#define DEFAULT_rxPblFwd                    FALSE
+#define DEFAULT_txPblFwd                    FALSE
+#define DEFAULT_txIpgLength                 12
+#define DEFAULT_debugMode                   FALSE
+#define DEFAULT_timeStampEnable             FALSE
+
+#define DEFAULT_exceptions          ((uint32_t)(IMASK_RX_FIFO_OVFL  |  \
+                                                IMASK_TX_FIFO_UNFL  |  \
+                                                IMASK_TX_FIFO_OVFL  |  \
+                                                IMASK_TX_ECC_ER     |  \
+                                                IMASK_RX_ECC_ER     |  \
+                                                IMASK_RX_EMPTY      |  \
+                                                IMASK_TX_EMPTY      |  \
+                                                IMASK_REM_FAULT     |  \
+                                                IMASK_LOC_FAULT))
+
+
+/* Control and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_MG                  0x80000000  /* 00 Magic Packet detection */
+#define CMD_CFG_REG_LOWP_RXETY      0x01000000  /* 07 Rx low power indication */
+#define CMD_CFG_TX_LOWP_ENA         0x00800000  /* 08 Transmit Low Power Idle Enable */
+#define CMD_CFG_SFD_ANY             0x00200000  /* 10 Disable check of SFD (0xd5) character at frame start */
+#define CMD_CFG_PFC_MODE            0x00080000  /* 12 Enable Priority Flow Control (PFC) mode of operation */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 Payload length check disable */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 Force idle generation */
+#define CMD_CFG_CNT_FRM_EN          0x00002000  /* 18 Control frame reception enable */
+#define CMD_CFG_SW_RESET            0x00001000  /* 19 Software Reset, self clearing bit */
+#define CMD_CFG_TX_PAD_EN           0x00000800  /* 20 Enable padding of frames in transmit direction */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 XGMII/GMII loopback enable */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 Transmit source MAC address insertion */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 Ignore Pause frame quanta */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 Terminate/forward received Pause frames */
+#define CMD_CFG_CRC_FWD             0x00000040  /* 25 Terminate/forward CRC of received frames */
+#define CMD_CFG_PAD_EN              0x00000020  /* 26 Frame padding removal in receive path enable */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 Promiscuous operation enable */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN mode enable */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 MAC receive path enable */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 MAC transmit path enable */
+
+/* Interface Mode Register (IF_MODE) */
+#define IF_MODE_MASK                0x00000003  /* 30-31 Mask on interface mode bits */
+#define IF_MODE_XGMII               0x00000000  /* 30-31 XGMII (10G) interface */
+#define IF_MODE_GMII                0x00000002  /* 30-31 GMII (1G) interface */
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       26
+#define HASH_CTRL_MCAST_EN          0x00000100  /* 23 Multicast frame reception for the hash entry */
+#define HASH_CTRL_ADDR_MASK         0x0000003F  /* 26-31 Hash table address code */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* MAC multicast address bit indication */
+#define HASH_TABLE_SIZE             64          /* Hash table size (bits 26-31 in HASHTABLE_CTRL allows for 2^6 entries) */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x0000003F
+
+/* Statistics Configuration Register (STATN_CONFIG) */
+#define STATS_CFG_CLR               0x00000004  /* 29 Reset all counters */
+#define STATS_CFG_CLR_ON_RD         0x00000002  /* 30 Clear on read */
+#define STATS_CFG_SATURATE          0x00000001  /* 31 Saturate at the maximum value */
+
+#define MEMAC_NUM_OF_PADDRS         7           /* Number of additional exact match MAC address registers */
+typedef _Packed struct t_MacAddr
+{
+    volatile uint32_t   mac_addr_l;         /* Lower 32 bits of 48-bit MAC address */
+    volatile uint32_t   mac_addr_u;         /* Upper 16 bits of 48-bit MAC address */
+} t_MacAddr;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef _Packed struct t_MemacMemMap
+{
+    /* General Control and Status */
+    volatile uint32_t   reserved1[2];
+    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
+    t_MacAddr mac_addr0;                    /* 0x00C-0x010 MAC_ADDR_0...MAC_ADDR_1 */
+    volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
+    volatile uint32_t   reserved2[5];
+    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
+    volatile uint32_t   reserved3[4];
+    volatile uint32_t   ievent;             /* 0x040 IEVENT - Interrupt event register */
+    volatile uint32_t   tx_ipg_length;      /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
+    volatile uint32_t   imask;              /* 0x04C IMASK - Interrupt mask register */
+    volatile uint32_t   reserved4;
+    volatile uint32_t   pause_quanta[4];    /* 0x054 CL0x_PAUSE_QUANTA - CL0-7 Pause quanta register */
+    volatile uint32_t   pause_thresh[4];    /* 0x064 CL0x_PAUSE_THRESH - CL0-7 Pause quanta threshold register */
+    volatile uint32_t   rx_pause_status;    /* 0x074 RX_PAUSE_STATUS - Receive pause status register */
+    volatile uint32_t   reserved5[2];
+    t_MacAddr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 MAC_ADDR_2...MAC_ADDR_15 */
+    volatile uint32_t   lpwake_timer;       /* 0x0B8 LPWAKE_TIMER - EEE Low Power Wakeup Timer register */
+    volatile uint32_t   sleep_timer;        /* 0x0BC SLEEP_TIMER - Transmit EEE Low Power Timer register */
+    volatile uint32_t   reserved6[8];
+    volatile uint32_t   statn_config;       /* 0x0E0 STATN_CONFIG - Statistics configuration register */
+    volatile uint32_t   reserved7[7];
+
+    /* Rx Statistics Counter */
+    volatile uint32_t   reoct_l;
+    volatile uint32_t   reoct_u;
+    volatile uint32_t   roct_l;
+    volatile uint32_t   roct_u;
+    volatile uint32_t   raln_l;
+    volatile uint32_t   raln_u;
+    volatile uint32_t   rxpf_l;
+    volatile uint32_t   rxpf_u;
+    volatile uint32_t   rfrm_l;
+    volatile uint32_t   rfrm_u;
+    volatile uint32_t   rfcs_l;
+    volatile uint32_t   rfcs_u;
+    volatile uint32_t   rvlan_l;
+    volatile uint32_t   rvlan_u;
+    volatile uint32_t   rerr_l;
+    volatile uint32_t   rerr_u;
+    volatile uint32_t   ruca_l;
+    volatile uint32_t   ruca_u;
+    volatile uint32_t   rmca_l;
+    volatile uint32_t   rmca_u;
+    volatile uint32_t   rbca_l;
+    volatile uint32_t   rbca_u;
+    volatile uint32_t   rdrp_l;
+    volatile uint32_t   rdrp_u;
+    volatile uint32_t   rpkt_l;
+    volatile uint32_t   rpkt_u;
+    volatile uint32_t   rund_l;
+    volatile uint32_t   rund_u;
+    volatile uint32_t   r64_l;
+    volatile uint32_t   r64_u;
+    volatile uint32_t   r127_l;
+    volatile uint32_t   r127_u;
+    volatile uint32_t   r255_l;
+    volatile uint32_t   r255_u;
+    volatile uint32_t   r511_l;
+    volatile uint32_t   r511_u;
+    volatile uint32_t   r1023_l;
+    volatile uint32_t   r1023_u;
+    volatile uint32_t   r1518_l;
+    volatile uint32_t   r1518_u;
+    volatile uint32_t   r1519x_l;
+    volatile uint32_t   r1519x_u;
+    volatile uint32_t   rovr_l;
+    volatile uint32_t   rovr_u;
+    volatile uint32_t   rjbr_l;
+    volatile uint32_t   rjbr_u;
+    volatile uint32_t   rfrg_l;
+    volatile uint32_t   rfrg_u;
+    volatile uint32_t   rcnp_l;
+    volatile uint32_t   rcnp_u;
+    volatile uint32_t   rdrntp_l;
+    volatile uint32_t   rdrntp_u;
+    volatile uint32_t   reserved8[12];
+
+    /* Tx Statistics Counter */
+    volatile uint32_t   teoct_l;
+    volatile uint32_t   teoct_u;
+    volatile uint32_t   toct_l;
+    volatile uint32_t   toct_u;
+    volatile uint32_t   txpf_l;
+    volatile uint32_t   txpf_u;
+    volatile uint32_t   tfrm_l;
+    volatile uint32_t   tfrm_u;
+    volatile uint32_t   tfcs_l;
+    volatile uint32_t   tfcs_u;
+    volatile uint32_t   tvlan_l;
+    volatile uint32_t   tvlan_u;
+    volatile uint32_t   terr_l;
+    volatile uint32_t   terr_u;
+    volatile uint32_t   tuca_l;
+    volatile uint32_t   tuca_u;
+    volatile uint32_t   tmca_l;
+    volatile uint32_t   tmca_u;
+    volatile uint32_t   tbca_l;
+    volatile uint32_t   tbca_u;
+    volatile uint32_t   tpkt_l;
+    volatile uint32_t   tpkt_u;
+    volatile uint32_t   tund_l;
+    volatile uint32_t   tund_u;
+    volatile uint32_t   t64_l;
+    volatile uint32_t   t64_u;
+    volatile uint32_t   t127_l;
+    volatile uint32_t   t127_u;
+    volatile uint32_t   t255_l;
+    volatile uint32_t   t255_u;
+    volatile uint32_t   t511_l;
+    volatile uint32_t   t511_u;
+    volatile uint32_t   t1023_l;
+    volatile uint32_t   t1023_u;
+    volatile uint32_t   t1518_l;
+    volatile uint32_t   t1518_u;
+    volatile uint32_t   t1519x_l;
+    volatile uint32_t   t1519x_u;
+    volatile uint32_t   tcnp_l;
+    volatile uint32_t   tcnp_u;
+    volatile uint32_t   reserved9[14];
+
+    /* Line Interface Control */
+    volatile uint32_t   if_mode;            /* 0x300 IF_MODE - Interface Mode Control register */
+    volatile uint32_t   if_status;          /* 0x304 IF_STATUS - Interface Status register */
+    volatile uint32_t   reserved10[14];
+
+    /* HiGig/2 */
+    volatile uint32_t   hg_config;          /* 0x340 HG_CONFIG - HiGig/2 Control and configuration register */
+    volatile uint32_t   hg_pause_quanta;    /* 0x350 HG_PAUSE_QUANTA - HiGig2 Pause quanta register */
+    volatile uint32_t   hg_pause_thresh;    /* 0x360 HG_PAUSE_THRESH - HiGig2 Pause quanta threshold register */
+    volatile uint32_t   hgrx_pause_status;  /* 0x370 HGRX_PAUSE_STATUS - HiGig2 Receive pause status register*/
+    volatile uint32_t   hg_fifos_status;    /* 0x374 HG_FIFOS_STATUS - HiGig2 fifos status register */
+    volatile uint32_t   rhm;                /* 0x378 RHM - Receive HiGig2 messages counter register */
+    volatile uint32_t   thm;                /* 0x37C THM - Transmit HiGig2 messages counter register */
+} _PackedType t_MemacMemMap;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct t_MemacDriverParam
+{
+    bool resetOnInit;
+    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
+    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
+    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
+    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
+    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
+                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
+                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
+    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
+    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
+    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
+    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
+    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
+    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
+    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
+    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
+                                        1: IEEE 1588 is enabled.
+                                        0: IEEE 1588 is disabled. */
+    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
+    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
+                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
+                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
+    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
+                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
+                                        If cleared (default) the MAC */
+    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
+                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
+                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+/*.. */
+    uint16_t    maxFrameLength;
+    bool        debugMode;
+    uint16_t    pauseTime;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    bool        skipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+} t_MemacDriverParam;
+
+typedef struct t_Memac
+{
+    t_FmMacControllerDriver     fmMacControllerDriver;               /**< Upper Mac control block */
+    t_Handle                    h_App;                               /**< Handle to the upper layer application  */
+    t_MemacMemMap               *p_MemMap;                           /**< Pointer to MAC memory mapped registers */
+    t_MemacMiiAccessMemMap      *p_MiiMemMap;                        /**< Pointer to MII memory mapped registers */
+    uint64_t                    addr;                                /**< MAC address of device */
+    e_EnetMode                  enetMode;                            /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exception;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Event;
+    bool                        indAddrRegUsed[MEMAC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[MEMAC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs;                  /**< Number of individual addresses in registers for this station. */
+    t_EthHash                   *p_MulticastAddrHash;                /**< Pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;                  /**< Pointer to driver's individual address hash table  */
+    bool                        debugMode;
+    uint8_t                     macId;
+    uint32_t                    exceptions;
+    t_MemacDriverParam          *p_MemacDriverParam;
+} t_Memac;
+
+#define MEMAC_TO_MII_OFFSET         0x030       /* Offset from the MEM map to the MDIO mem map */
+
+t_Error MEMAC_MII_WritePhyReg(t_Handle h_Memac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __MEMAC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
new file mode 100644
index 0000000..26e644d
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "memac.h"
+#include "xx_ext.h"
+
+#include "fm_common.h"
+
+
+/*****************************************************************************/
+t_Error MEMAC_MII_WritePhyReg(t_Handle   h_Memac,
+                             uint8_t    phyAddr,
+                             uint8_t    reg,
+                             uint16_t   data)
+{
+    t_Memac                  *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMiiAccessMemMap   *p_MiiAccess;
+    uint32_t                cfgStatusReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Configure MII */
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+    cfgStatusReg &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    cfgStatusReg |=((((p_Memac->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_MiiAccess->mdio_cfg_status, cfgStatusReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
+                            uint8_t  phyAddr,
+                            uint8_t  reg,
+                            uint16_t *p_Data)
+{
+    t_Memac                  *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMiiAccessMemMap   *p_MiiAccess;
+    uint32_t                cfgStatusReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Configure MII */
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+    cfgStatusReg &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    cfgStatusReg |=((((p_Memac->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_MiiAccess->mdio_cfg_status, cfgStatusReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, (uint32_t)(phyAddr | MIIMCOM_READ_CYCLE));
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MIIDATA_BUSY)
+        XX_UDelay (1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+
+    if (cfgStatusReg & MIIMIND_READ_ERROR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgStatusReg 0x%x",
+                      ((phyAddr & 0xe0)>>5), (phyAddr & 0x1f), reg, cfgStatusReg));
+
+    return E_OK;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
new file mode 100644
index 0000000..71a8ecf
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __MEMAC_MII_ACC_H
+#define __MEMAC_MII_ACC_H
+
+#include "std_ext.h"
+
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_POST_INCREMENT 0x00004000
+#define MIIMCOM_READ_CYCLE          0x00008000
+#define MIIMCOM_SCAN_CYCLE          0x00000800
+#define MIIMCOM_PREAMBLE_DISABLE    0x00000400
+
+#define MIIMCOM_MDIO_HOLD_1_REG_CLK 0
+#define MIIMCOM_MDIO_HOLD_2_REG_CLK 1
+#define MIIMCOM_MDIO_HOLD_3_REG_CLK 2
+#define MIIMCOM_MDIO_HOLD_4_REG_CLK 3
+
+#define MIIMCOM_DIV_MASK            0x0000ff00
+#define MIIMCOM_DIV_SHIFT           8
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+#define MIIMIND_READ_ERROR          0x00000002
+
+#define MIIDATA_BUSY                0x80000000
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_MemacMiiAccessMemMap
+{
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+} _PackedType t_MemacMiiAccessMemMap ;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+#endif /* __MEMAC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
index b74ac31..4bf2630 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -12,7 +12,8 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
-fsl-ncsw-Pcd-objs	:= fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o
+fsl-ncsw-Pcd-objs	:= fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o \
+			   fm_replic.o
 
 ifeq ($(CONFIG_FMAN_P3040_P4080_P5020),y)
 fsl-ncsw-Pcd-objs	+= fm_manip.o
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
new file mode 100644
index 0000000..5a6136f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
@@ -0,0 +1,1176 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_replic.c
+
+ @Description   FM frame replicator
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_replic.h"
+#include "fm_cc.h"
+#include "list_ext.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static t_Error FrmReplicGroupTryLock(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    ASSERT_COND(h_ReplicGroup);
+
+    if (FmPcdLockTryLock(p_ReplicGroup->p_Lock))
+        return E_OK;
+
+    return ERROR_CODE(E_BUSY);
+}
+
+static void FrmReplicGroupReleaseLock(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    ASSERT_COND(h_ReplicGroup);
+
+    FmPcdLockUnlock(p_ReplicGroup->p_Lock);
+}
+
+static void  UpdateGroupOwner(t_FmPcdFrmReplicGroup *p_ReplicGroup, bool add)
+{
+    if (add)
+        p_ReplicGroup->owners++;
+    else
+    {
+        ASSERT_COND(p_ReplicGroup->owners);
+        p_ReplicGroup->owners--;
+    }
+}
+
+
+static e_UseSourceTdOption  CheckUseSourceTdOptionType(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    uint32_t                numOfOwnersInList = 0, numOfSourceTdOwners = 0;
+    e_UseSourceTdOption     useSourceTdOption = e_USE_SOURCE_TD_NONE;
+    t_List                  *p_Pos;
+    t_CcNodeInformation     *p_ReplicGroupOwner;
+
+    /* Check how the owners of the group use the source TD -
+       1. use the source TD itself or
+       2. copy the source Td to their own td or
+       3. 1+2 (both ways) */
+
+    /* count how many owners exist in the ownersList -
+       means how many owners copy the source Td to their own descriptor  */
+    for (p_Pos = LIST_FIRST(&p_ReplicGroup->ownersList); p_Pos != (&p_ReplicGroup->ownersList); p_Pos = LIST_NEXT(p_Pos))
+    {
+        /* get the cc node that points to this group */
+        p_ReplicGroupOwner = CC_NODE_F_OBJECT(p_Pos);
+
+        /* add the number of owners of this group on the specific cc node */
+        numOfOwnersInList+=p_ReplicGroupOwner->index;
+    }
+
+    if (numOfOwnersInList)
+        useSourceTdOption |= e_USE_SOURCE_TD_COPY_OPTION;
+    ASSERT_COND(numOfOwnersInList <= p_ReplicGroup->owners);
+
+    /* calculate the number of owners that use the source TD itself */
+    numOfSourceTdOwners = p_ReplicGroup->owners - numOfOwnersInList;
+    if (numOfSourceTdOwners)
+        useSourceTdOption |= e_USE_SOURCE_TD_ITSELF_OPTION;
+
+    return useSourceTdOption;
+}
+
+static uint8_t  GetMemberPosition(t_FmPcdFrmReplicGroup *p_ReplicGroup,
+                                  uint32_t              memberIndex,
+                                  bool                  isAddOperation)
+{
+    uint8_t     memberPosition;
+    uint32_t    lastMemberIndex;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    /* the last member index is different between add and remove operation -
+    in case of remove - this is exactly the last member index
+    in case of add - this is the last member index + 1 - e.g.
+    if we have 4 members, the index of the actual last member is 3(because the
+    index starts from 0) therefore in order to add a new member as the last
+    member we shall use memberIndex = 4 and not 3
+    */
+    if (isAddOperation)
+        lastMemberIndex = p_ReplicGroup->numOfEntries;
+    else
+        lastMemberIndex = p_ReplicGroup->numOfEntries-1;
+
+    /* last */
+    if (memberIndex == lastMemberIndex)
+        memberPosition = FRM_REPLIC_LAST_MEMBER_INDEX;
+    else
+    {
+        /* first */
+        if (memberIndex == FRM_REPLIC_FIRST_MEMBER_INDEX)
+            memberPosition = FRM_REPLIC_FIRST_MEMBER_INDEX;
+        else
+        {
+            /* middle */
+            ASSERT_COND(memberIndex < lastMemberIndex);
+            memberPosition = FRM_REPLIC_MIDDLE_MEMBER_INDEX;
+        }
+    }
+    return memberPosition;
+}
+
+static t_Error CheckParams(t_Handle                     h_FmPcd,
+                           t_FmPcdFrmReplicGroupParams *p_ReplicGroupParam)
+{
+    int             i;
+    t_Error         err;
+
+    /* check that max num of entries is at least 2 */
+    if (p_ReplicGroupParam->maxNumOfEntries <= 1)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfEntries in the frame replicator group should be greater than one"));
+
+    if (p_ReplicGroupParam->maxNumOfEntries >= FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfEntries in the frame replicator should not be greater than %d",FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES));
+
+    /* check that number of entries is greater than zero */
+    if (!p_ReplicGroupParam->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOFEntries in the frame replicator group should be greater than zero"));
+
+    /* check that max num of entries is equal or greater than number of entries */
+    if (p_ReplicGroupParam->maxNumOfEntries < p_ReplicGroupParam->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfEntries should be equal or greater than numOfEntries"));
+
+    for (i=0;i<p_ReplicGroupParam->numOfEntries;i++)
+    {
+
+        if (p_ReplicGroupParam->nextEngineParams[i].nextEngine == e_FM_PCD_CC)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Nect engine of a member can't be cc"));
+
+        if (p_ReplicGroupParam->nextEngineParams[i].nextEngine == e_FM_PCD_FR)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Nect engine of a member can't be replicator group"));
+
+        /* check the regular parameters of the next engine */
+        err = ValidateNextEngineParams(h_FmPcd, &p_ReplicGroupParam->nextEngineParams[i]);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("member next engine parameters"));
+    }
+    return E_OK;
+}
+
+static t_FmPcdFrmReplicMember *GetAvailableMember(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    t_FmPcdFrmReplicMember  *p_ReplicMember = NULL;
+    t_List                  *p_Next;
+
+    if (!LIST_IsEmpty(&p_ReplicGroup->availableMembersList))
+    {
+        p_Next = LIST_FIRST(&p_ReplicGroup->availableMembersList);
+        p_ReplicMember = LIST_OBJECT(p_Next, t_FmPcdFrmReplicMember, node);
+        ASSERT_COND(p_ReplicMember);
+        LIST_DelAndInit(p_Next);
+    }
+    return p_ReplicMember;
+}
+
+static void PutAvailableMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_FmPcdFrmReplicMember   *p_ReplicMember)
+{
+    LIST_AddToTail(&p_ReplicMember->node, &p_ReplicGroup->availableMembersList);
+}
+
+static void AddMemberToList(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                            t_FmPcdFrmReplicMember  *p_CurrentMember,
+                            t_List                  *p_ListHead)
+{
+    LIST_Add(&p_CurrentMember->node, p_ListHead);
+
+    p_ReplicGroup->numOfEntries++;
+}
+
+static void RemoveMemberFromList(t_FmPcdFrmReplicGroup  *p_ReplicGroup,
+                                 t_FmPcdFrmReplicMember *p_CurrentMember)
+{
+    ASSERT_COND(p_ReplicGroup->numOfEntries);
+    LIST_DelAndInit(&p_CurrentMember->node);
+    p_ReplicGroup->numOfEntries--;
+}
+
+static void LinkSourceToMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_AdOfTypeContLookup     *p_SourceTd,
+                               t_FmPcdFrmReplicMember   *p_ReplicMember)
+{
+    t_FmPcd             *p_FmPcd;
+
+    ASSERT_COND(p_SourceTd);
+    ASSERT_COND(p_ReplicMember);
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    /* Link the first member in the group to the source TD */
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+
+    WRITE_UINT32(p_SourceTd->matchTblPtr,
+        (uint32_t)(XX_VirtToPhys(p_ReplicMember->p_MemberAd) - p_FmPcd->physicalMuramBase));
+}
+
+static void LinkMemberToMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_FmPcdFrmReplicMember   *p_CurrentMember,
+                               t_FmPcdFrmReplicMember   *p_NextMember)
+{
+    t_AdOfTypeResult    *p_CurrReplicAd = (t_AdOfTypeResult*)p_CurrentMember->p_MemberAd;
+    t_AdOfTypeResult    *p_NextReplicAd = NULL;
+    t_FmPcd             *p_FmPcd;
+    uint32_t            address = 0;
+
+    /* Check if the next member exists or it's NULL (- means that this is the last member) */
+    if (p_NextMember)
+    {
+        p_NextReplicAd = (t_AdOfTypeResult*)p_NextMember->p_MemberAd;
+        p_FmPcd = p_ReplicGroup->h_FmPcd;
+        address = (XX_VirtToPhys(p_NextReplicAd) - (p_FmPcd->physicalMuramBase));
+        address = ((address>>NEXT_FRM_REPLIC_ADDR_SHIFT)<< NEXT_FRM_REPLIC_MEMBER_INDEX_SHIFT);
+    }
+
+    /* link the current AD to point to the AD of the next member */
+    WRITE_UINT32(p_CurrReplicAd->res, address);
+}
+
+static t_Error ModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                void                    *p_OldDescriptor,
+                                void                    *p_NewDescriptor)
+{
+    t_Handle            h_Hc;
+    t_Error             err;
+    uint32_t            oldDescriptorOffset, newDescriptorOffset;
+    t_FmPcd             *p_FmPcd;
+
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+    h_Hc = FmPcdGetHcHandle(p_FmPcd);
+    if (!h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Host command"));
+
+    oldDescriptorOffset =
+        (uint32_t)(XX_VirtToPhys(p_OldDescriptor) - p_FmPcd->physicalMuramBase);
+    newDescriptorOffset =
+        (uint32_t)(XX_VirtToPhys(p_NewDescriptor) - p_FmPcd->physicalMuramBase);
+
+    err = FmHcPcdCcDoDynamicChange(h_Hc, oldDescriptorOffset, newDescriptorOffset);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Dynamic change host command"));
+
+    return E_OK;
+}
+
+static t_Error ModifyGroupOwners(t_FmPcdFrmReplicGroup  *p_ReplicGroup,
+                                 t_FmPcdFrmReplicMember *p_Member,
+                                 bool                   useHostCommand)
+{
+    t_List                      h_List, adTablesList, *p_Pos, *p_Pos1;
+    uint32_t                    numOfAdTables, numOfOwnersInList, intFlags;
+    t_CcNodeInformation         *p_GroupOwner, *p_Node;
+    t_Error                     err;
+
+    /* Get the number of owners in the list */
+    numOfOwnersInList = LIST_NumOfObjs(&p_ReplicGroup->ownersList);
+
+    /* Go over all the nodes that use this replicator group */
+    LIST_FOR_EACH(p_Pos, &p_ReplicGroup->ownersList)
+    {
+        /* Get the node that use this replic group */
+        p_Node = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_Node);
+
+        /* lock the specific node */
+        INIT_LIST(&h_List);
+        INIT_LIST(&adTablesList);
+
+        intFlags = FmPcdLock(p_ReplicGroup->h_FmPcd);
+        err = FmPcdCcNodeTreeTryLock(p_ReplicGroup->h_FmPcd,
+                                     p_Node->h_CcNode,
+                                     &h_List);
+        FmPcdUnlock(p_ReplicGroup->h_FmPcd, intFlags);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("lock ccNode in ModifyGroupOwners"));
+
+        /* Get the Ad tables pointers of the specific node that use this replicator group */
+        FmPcdCcGetAdTablesThatPointOnReplicGroup(p_Node->h_CcNode,
+                                                 p_ReplicGroup,
+                                                 &adTablesList,
+                                                 &numOfAdTables);
+
+        /* go over all the ad tables that share the group handle and update them according to the
+           main source TD of the group */
+        LIST_FOR_EACH(p_Pos1, &adTablesList)
+        {
+            p_GroupOwner = CC_NODE_F_OBJECT(p_Pos1);
+            ASSERT_COND(p_GroupOwner);
+
+            /* Check if useHostCommand is set and this is the last owner in the list
+               and the last ad table in the node -
+               use a Host Command, otherwise there is no need of host command -
+               just an update of the owner descriptor */
+            if ((useHostCommand) && (numOfOwnersInList == 1) && (numOfAdTables == 1))
+            {
+                err = ModifyDescriptor(p_ReplicGroup,
+                                       p_GroupOwner->h_CcNode,    /*old pointer*/
+                                       p_ReplicGroup->p_SourceTd);/*new pointer*/
+                if (err)
+                {
+                    FmPcdCcNodeTreeReleaseLock(&h_List);
+                    RETURN_ERROR(MAJOR, err, ("Modify group owner"));
+                }
+            }
+            else
+                LinkSourceToMember(p_ReplicGroup, p_GroupOwner->h_CcNode, p_Member);
+
+            numOfAdTables--;
+        }
+        /* unlock node */
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        numOfOwnersInList--;
+
+        /* free the ad tables list */
+        ReleaseLst(&adTablesList);
+    }
+    return E_OK;
+}
+
+static void BuildSourceTd(void *p_Ad)
+{
+    t_AdOfTypeContLookup    *p_SourceTd;
+
+    ASSERT_COND(p_Ad);
+
+    p_SourceTd = (t_AdOfTypeContLookup *)p_Ad;
+
+    IOMemSet32((uint8_t*)p_SourceTd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    /* initialize the source table descriptor */
+    WRITE_UINT32(p_SourceTd->ccAdBase,     FM_PCD_AD_CONT_LOOKUP_TYPE);
+    WRITE_UINT32(p_SourceTd->pcAndOffsets, FRM_REPLIC_SOURCE_TD_OPCODE);
+}
+
+static void FillReplicAdOfTypeResult(void *p_ReplicAd, bool last)
+{
+    t_AdOfTypeResult    *p_CurrReplicAd = (t_AdOfTypeResult*)p_ReplicAd;
+    uint32_t            tmp;
+
+    tmp = GET_UINT32(p_CurrReplicAd->plcrProfile);
+    if (last)
+        /* clear the NL bit in case it's the last member in the group*/
+        WRITE_UINT32(p_CurrReplicAd->plcrProfile,(tmp & ~FRM_REPLIC_NL_BIT));
+    else
+        /* set the NL bit in case it's not the last member in the group */
+        WRITE_UINT32(p_CurrReplicAd->plcrProfile, (tmp |FRM_REPLIC_NL_BIT));
+
+    /* set FR bit in the action descriptor */
+    tmp = GET_UINT32(p_CurrReplicAd->nia);
+    WRITE_UINT32(p_CurrReplicAd->nia,
+        (tmp | FRM_REPLIC_FR_BIT | FM_PCD_AD_RESULT_EXTENDED_MODE ));
+}
+
+static t_FmPcdFrmReplicMember* GetMemberByIndex(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                                uint16_t                memberIndex)
+{
+    int                     i=0;
+    t_List                  *p_Pos;
+    t_FmPcdFrmReplicMember  *p_Member = NULL;
+
+    LIST_FOR_EACH(p_Pos, &p_ReplicGroup->membersList)
+    {
+        if (i == memberIndex)
+        {
+            p_Member = LIST_OBJECT(p_Pos, t_FmPcdFrmReplicMember, node);
+            return p_Member;
+        }
+        i++;
+    }
+    return p_Member;
+}
+
+static t_Error BuildShadowAndModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                              t_FmPcdFrmReplicMember  *p_NextMember,
+                                              t_FmPcdFrmReplicMember  *p_CurrentMember,
+                                              bool                    sourceDescriptor,
+                                              bool                    last)
+{
+    t_FmPcd                 *p_FmPcd;
+    t_FmPcdFrmReplicMember  shadowMember;
+    t_Error                 err;
+
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+    ASSERT_COND(p_FmPcd->p_CcShadow);
+
+    if (sourceDescriptor)
+    {
+        BuildSourceTd(p_FmPcd->p_CcShadow);
+        LinkSourceToMember(p_ReplicGroup, p_FmPcd->p_CcShadow, p_NextMember);
+
+        /* Modify the source table descriptor according to the prepared shadow descriptor */
+        err = ModifyDescriptor(p_ReplicGroup,
+                               p_ReplicGroup->p_SourceTd,
+                               p_FmPcd->p_CcShadow/* new prepared source td */);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("Modify source Descriptor in BuildShadowAndModifyDescriptor"));
+
+    }
+    else
+    {
+        IO2IOCpy32(p_FmPcd->p_CcShadow,
+                   p_CurrentMember->p_MemberAd,
+                   FM_PCD_CC_AD_ENTRY_SIZE);
+
+        FillReplicAdOfTypeResult(p_FmPcd->p_CcShadow, last);
+        shadowMember.p_MemberAd = p_FmPcd->p_CcShadow;
+        LinkMemberToMember(p_ReplicGroup, &shadowMember, p_NextMember);
+
+        /* Modify the next member according to the prepared shadow descriptor */
+        err = ModifyDescriptor(p_ReplicGroup,
+                               p_CurrentMember->p_MemberAd,
+                               &shadowMember.p_MemberAd);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("ModifyDescriptor in BuildShadowAndModifyDescriptor"));
+    }
+
+
+    return E_OK;
+}
+
+static t_FmPcdFrmReplicMember* InitMember(t_FmPcdFrmReplicGroup     *p_ReplicGroup,
+                                          t_FmPcdCcNextEngineParams *p_MemberParams,
+                                          bool                      last)
+{
+    t_FmPcdFrmReplicMember  *p_CurrentMember = NULL;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    /* Get an available member from the internal members list */
+    p_CurrentMember = GetAvailableMember(p_ReplicGroup);
+    if (!p_CurrentMember)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("Available member"));
+        return NULL;
+    }
+    p_CurrentMember->h_Manip = NULL;
+    /* clear the Ad of the new member */
+    IOMemSet32((uint8_t*)p_CurrentMember->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    INIT_LIST(&p_CurrentMember->node);
+
+    /* Initialize the Ad of the member */
+    NextStepAd(p_CurrentMember->p_MemberAd, p_MemberParams, p_ReplicGroup->h_FmPcd);
+
+    /* save Manip handle (for free needs) */
+    if (p_MemberParams->h_Manip)
+        p_CurrentMember->h_Manip = p_MemberParams->h_Manip;
+
+    /* Initialize the relevant frame replicator fields in the AD */
+    FillReplicAdOfTypeResult(p_CurrentMember->p_MemberAd, last);
+
+    return p_CurrentMember;
+}
+
+static void FreeMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                       t_FmPcdFrmReplicMember   *p_Member)
+{
+    /* Note: Can't free the member+statistics AD since the free member returns to the available
+       member list - only memset them */
+
+    /* zero the AD */
+    IOMemSet32(p_Member->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+
+    /* return the member to the available members list */
+    PutAvailableMember(p_ReplicGroup, p_Member);
+}
+
+static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                            uint16_t                memberIndex)
+{
+    t_FmPcd                 *p_FmPcd = NULL;
+    t_FmPcdFrmReplicMember  *p_CurrentMember = NULL, *p_PreviousMember = NULL, *p_NextMember = NULL;
+    t_Error                 err;
+    uint8_t                 memberPosition;
+    e_UseSourceTdOption     useSourceTdOption = e_USE_SOURCE_TD_NONE;
+
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+
+    p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+    ASSERT_COND(p_CurrentMember);
+
+    /* determine the member position in the group */
+    memberPosition = GetMemberPosition(p_ReplicGroup, memberIndex, FALSE/*remove operation*/);
+
+    switch (memberPosition)
+    {
+        case FRM_REPLIC_FIRST_MEMBER_INDEX:
+            p_NextMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex+1));
+            ASSERT_COND(p_NextMember);
+
+            /* Check how the owners of the group use the source TD -
+               1. use the source TD itself or
+               2. copy the source Td to their own td or
+               3. 1+2 (both ways) */
+            if (p_ReplicGroup->owners)
+                useSourceTdOption = CheckUseSourceTdOptionType(p_ReplicGroup);
+
+            /* The decision is to update the last table descriptor that use this group
+               by host command (for sync purposes).
+               if there are only owners that use the source Td itself- then we should update the
+               source Td by a host command (for sync) ,
+               if there are only owners that copy the source td to their own td so the
+               host command will be called when the last owner will update its own td (In ModifyGroupOwners routine)
+               If both cases - only one host command will be called when updating the source Td */
+
+            /* check how the owners use the source Td and modify it accordingly */
+            switch (useSourceTdOption)
+            {
+                case e_USE_SOURCE_TD_NONE:
+                    LinkSourceToMember(p_ReplicGroup, p_ReplicGroup->p_SourceTd, p_NextMember);
+                    break;
+
+                case e_USE_SOURCE_TD_ITSELF_OPTION:
+                    /* update the source td itself by using a host command */
+                    if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+                        return ERROR_CODE(E_BUSY);
+
+                    err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                         p_NextMember,
+                                                         NULL,
+                                                         TRUE/*sourceDescriptor*/,
+                                                         FALSE/*last*/);
+                    RELEASE_LOCK(p_FmPcd->shadowLock);
+
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of first member"));
+                    break;
+
+                case e_USE_SOURCE_TD_COPY_OPTION:
+                    LinkSourceToMember(p_ReplicGroup, p_ReplicGroup->p_SourceTd, p_NextMember);
+
+                    /* Update all the owners to point to the next member */
+                    err = ModifyGroupOwners(p_ReplicGroup, p_NextMember, TRUE/*useHostCommand*/);
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, ("Modify Group Owners"));
+                    break;
+
+                case e_USE_SOURCE_TD_ITSELF_AND_COPY_OPTION:
+                    /* Update all the owners to point to the next member */
+                    err = ModifyGroupOwners(p_ReplicGroup, p_NextMember, FALSE/*useHostCommand*/);
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, ("Modify Group Owners"));
+
+                    if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+                        return ERROR_CODE(E_BUSY);
+
+                    /* update the source TD by using a host command */
+                    err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                         p_NextMember,
+                                                         NULL,
+                                                         TRUE/*sourceDescriptor*/,
+                                                         FALSE/*last*/);
+                    RELEASE_LOCK(p_FmPcd->shadowLock);
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, ("Modify Group Owners"));
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("source td use"));
+            }
+            break;
+
+        case FRM_REPLIC_MIDDLE_MEMBER_INDEX:
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            p_NextMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex+1));
+            ASSERT_COND(p_NextMember);
+
+            if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+                return ERROR_CODE(E_BUSY);
+
+            err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                 p_NextMember,
+                                                 p_PreviousMember,
+                                                 FALSE/*sourceDescriptor*/,
+                                                 FALSE/*last*/);
+
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of middle member"));
+            break;
+
+        case FRM_REPLIC_LAST_MEMBER_INDEX:
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+                return ERROR_CODE(E_BUSY);
+
+            err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                 NULL,
+                                                 p_PreviousMember,
+                                                 FALSE/*sourceDescriptor*/,
+                                                 TRUE/*last*/);
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of last member"));
+            break;
+
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in remove member"));
+    }
+
+    if (p_CurrentMember->h_Manip)
+    {
+        FmPcdManipUpdateOwner(p_CurrentMember->h_Manip, FALSE);
+        p_CurrentMember->h_Manip = NULL;
+    }
+
+    /* remove the member from the driver internal members list */
+    RemoveMemberFromList(p_ReplicGroup, p_CurrentMember);
+
+    /* return the member to the available members list */
+    FreeMember(p_ReplicGroup, p_CurrentMember);
+    return E_OK;
+}
+
+static void DeleteGroup(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    int                     i, j;
+    t_Handle                h_Muram;
+    t_FmPcdFrmReplicMember  *p_Member, *p_CurrentMember;
+
+    if (p_ReplicGroup)
+    {
+        ASSERT_COND(p_ReplicGroup->h_FmPcd);
+        h_Muram = FmPcdGetMuramHandle(p_ReplicGroup->h_FmPcd);
+        ASSERT_COND(h_Muram);
+
+        /* free the source table descriptor */
+        if (p_ReplicGroup->p_SourceTd)
+        {
+            FM_MURAM_FreeMem(h_Muram, p_ReplicGroup->p_SourceTd);
+            p_ReplicGroup->p_SourceTd = NULL;
+        }
+
+        /* Remove all members from the members linked list (hw and sw) and return the
+           members to the available members list */
+        if (p_ReplicGroup->numOfEntries)
+        {
+            j = p_ReplicGroup->numOfEntries-1;
+
+            /* manually removal of the member because there are no owners of this group */
+            for (i=j; i>=0; i--)
+            {
+                p_CurrentMember = GetMemberByIndex(p_ReplicGroup, i/*memberIndex*/);
+                ASSERT_COND(p_CurrentMember);
+
+                if (p_CurrentMember->h_Manip)
+                {
+                    FmPcdManipUpdateOwner(p_CurrentMember->h_Manip, FALSE);
+                    p_CurrentMember->h_Manip = NULL;
+                }
+
+                /* remove the member from the internal driver members list */
+                RemoveMemberFromList(p_ReplicGroup, p_CurrentMember);
+
+                /* return the member to the available members list */
+                FreeMember(p_ReplicGroup, p_CurrentMember);
+            }
+        }
+
+        /* Free member AD + Statistics */
+        for (i=0;i<p_ReplicGroup->maxNumOfEntries;i++)
+        {
+            p_Member = GetAvailableMember(p_ReplicGroup);
+            if (p_Member)
+            {
+                if (p_Member->p_MemberAd)
+                {
+                    FM_MURAM_FreeMem(h_Muram, p_Member->p_MemberAd);
+                    p_Member->p_MemberAd = NULL;
+                }
+                XX_Free(p_Member);
+            }
+            else
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("Missing member from available"));
+                return;
+            }
+        }
+
+        /* release the lock */
+        if (p_ReplicGroup->p_Lock)
+            FmPcdReleaseLock(p_ReplicGroup->h_FmPcd, p_ReplicGroup->p_Lock);
+
+        /* free the replicator group */
+        XX_Free(p_ReplicGroup);
+    }
+}
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
+void * FrmReplicGetSourceTableDescriptor(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    if (!p_ReplicGroup)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("Frame replicator group"));
+        return NULL;
+    }
+    return (p_ReplicGroup->p_SourceTd);
+}
+
+void FrmReplicUpdateAdContLookupForCc(t_Handle  h_ReplicGroup,
+                                      t_Handle  p_Ad,
+                                      t_Handle  *h_AdNew)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    /* Copy the already prepared source table descriptor to the current AD pointer */
+    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,     GET_UINT32(((t_AdOfTypeContLookup *)(p_ReplicGroup->p_SourceTd))->ccAdBase));
+    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,  GET_UINT32(((t_AdOfTypeContLookup *)(p_ReplicGroup->p_SourceTd))->matchTblPtr));
+    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, GET_UINT32(((t_AdOfTypeContLookup *)(p_ReplicGroup->p_SourceTd))->pcAndOffsets));
+    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,        GET_UINT32(((t_AdOfTypeContLookup *)(p_ReplicGroup->p_SourceTd))->gmask));
+    *h_AdNew = NULL;
+}
+
+void  FrmReplicUpdateGroupOwner(t_Handle    h_ReplicGroup,
+                                bool        add,
+                                bool        fullUpdate,
+                                t_Handle    h_FmPcdCcNode)
+{
+    t_CcNodeInformation     *p_ReplicGroupOwner = NULL;
+    t_CcNodeInformation     replicGroupOwner;
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    /* lock */
+    /* TODO - ask p_ReplicGroup->h_SpinLock */
+    /* check if to update the information in the owners list */
+    if (fullUpdate)
+    {
+        ASSERT_COND(h_FmPcdCcNode);
+        /* search if this node already exists in the owners list */
+        p_ReplicGroupOwner = FindNodeInfoInReleventLst(&p_ReplicGroup->ownersList, h_FmPcdCcNode, NULL);
+
+        /* add a new owner to the list */
+        if (add)
+        {
+            /* found the owner in the list - just increment the counter */
+            if (p_ReplicGroupOwner)
+                p_ReplicGroupOwner->index++;
+            else
+            {
+                replicGroupOwner.h_CcNode  = h_FmPcdCcNode;
+                replicGroupOwner.index     = 1;
+                /* the routine will allocate internally group owner structure, initialize it
+                according to the replicGroupOwner parameters and insert it to the list */
+                EnqueueNodeInfoToRelevantLst(&p_ReplicGroup->ownersList, &replicGroupOwner, NULL);
+            }
+        }
+        else
+        {
+            /* update the groupOwner numbers */
+            UpdateGroupOwner(p_ReplicGroup, add);
+            if (p_ReplicGroupOwner)
+            {
+                p_ReplicGroupOwner->index--;
+                if (p_ReplicGroupOwner->index == 0)
+                {
+                    /* No more group owners in the node - remove it from the list */
+                    DequeueNodeInfoFromRelevantLst(&p_ReplicGroup->ownersList, p_ReplicGroupOwner, NULL);
+                    /* Free the group owner structure */
+                    XX_Free(p_ReplicGroupOwner);
+                }
+            }
+        }
+    }
+    else
+        /* update the groupOwner numbers */
+        UpdateGroupOwner(p_ReplicGroup, add);
+
+}
+
+
+/*********************** End of inter-module routines ************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle                      h_FmPcd,
+                                  t_FmPcdFrmReplicGroupParams   *p_ReplicGroupParam)
+{
+    t_FmPcdFrmReplicGroup       *p_ReplicGroup;
+    t_AdOfTypeResult            *p_Ad = NULL;
+    t_FmPcdFrmReplicMember      *p_CurrentMember, *p_NextMember;
+    int                         i;
+    t_Error                     err;
+    bool                        last = FALSE;
+    t_Handle                    h_Muram;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ReplicGroupParam, E_INVALID_HANDLE, NULL);
+
+    err = CheckParams(h_FmPcd, p_ReplicGroupParam);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, (NO_MSG));
+        return NULL;
+    }
+
+    p_ReplicGroup = (t_FmPcdFrmReplicGroup*)XX_Malloc(sizeof(t_FmPcdFrmReplicGroup));
+    if (!p_ReplicGroup)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_ReplicGroup, 0, sizeof(t_FmPcdFrmReplicGroup));
+
+    INIT_LIST(&p_ReplicGroup->availableMembersList);
+    INIT_LIST(&p_ReplicGroup->membersList);
+    INIT_LIST(&p_ReplicGroup->ownersList);
+
+    /* save parameter in the internal structure of the frame replicator group */
+    p_ReplicGroup->h_FmPcd = h_FmPcd;
+
+    h_Muram = FmPcdGetMuramHandle(p_ReplicGroup->h_FmPcd);
+    ASSERT_COND(h_Muram);
+
+    /* initialize the group lock */
+    p_ReplicGroup->p_Lock = FmPcdAcquireLock(p_ReplicGroup->h_FmPcd);
+    if (!p_ReplicGroup->p_Lock)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Replic group lock"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    /* update the shadow size - required for the host commands */
+    err = FmPcdUpdateCcShadow(p_ReplicGroup->h_FmPcd,
+                              FM_PCD_CC_AD_ENTRY_SIZE,
+                              FM_PCD_CC_AD_TABLE_ALIGN);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, ("Update CC shadow"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    p_ReplicGroup->maxNumOfEntries   = p_ReplicGroupParam->maxNumOfEntries;
+
+    /* Allocate the maximal number of members ADs and Statistics AD for the group
+       It prevents allocation of Muram in run-time */
+    for (i=0;i<p_ReplicGroup->maxNumOfEntries;i++)
+    {
+        /* Intialize an internal structure of a member to add to the available members list */
+        p_CurrentMember = (t_FmPcdFrmReplicMember *)XX_Malloc(sizeof(t_FmPcdFrmReplicMember));
+        if (!p_CurrentMember)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Frame replicator member"));
+            DeleteGroup(p_ReplicGroup);
+            return NULL;
+        }
+        memset(p_CurrentMember, 0 ,sizeof(t_FmPcdFrmReplicMember));
+
+        /* Allocate the member AD */
+        p_Ad =
+            (t_AdOfTypeResult*)FM_MURAM_AllocMem(h_Muram,
+                                                 FM_PCD_CC_AD_ENTRY_SIZE,
+                                                 FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!p_Ad)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for an AD table"));
+            DeleteGroup(p_ReplicGroup);
+            return NULL;
+        }
+        IOMemSet32((uint8_t*)p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        p_CurrentMember->p_MemberAd   = (void*)p_Ad;
+
+        /* Add the new member to the available members list */
+        LIST_AddToTail(&p_CurrentMember->node, &(p_ReplicGroup->availableMembersList));
+    }
+    p_NextMember = NULL;
+
+    /* Initialize the members linked list(hw - the one that is used by the FMan controller and
+       the sw one thaat is managed by the driver internally) */
+    for (i=(p_ReplicGroupParam->numOfEntries-1);i>=0;i--)
+    {
+        /* check if this is the last member in the group */
+        if (i == (p_ReplicGroupParam->numOfEntries-1))
+            last = TRUE;
+        else
+            last = FALSE;
+
+        /* Initialize a new member */
+        p_CurrentMember = InitMember(p_ReplicGroup,
+                                  &(p_ReplicGroupParam->nextEngineParams[i]),
+                                  last);
+        if (!p_CurrentMember)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No available member"));
+            DeleteGroup(p_ReplicGroup);
+            return NULL;
+        }
+        /* TODO - think if there is an option to combine those two routines to one routine ?? */
+
+        /* Build the members group - link two consecutive members in the hw linked list */
+        LinkMemberToMember(p_ReplicGroup, p_CurrentMember, p_NextMember);
+
+        /* update the driver internal members list to be compatible to the hw members linked list */
+        AddMemberToList(p_ReplicGroup, p_CurrentMember, &p_ReplicGroup->membersList);
+
+        p_NextMember = p_CurrentMember;
+    }
+
+    /* Allocate the frame replicator source table descriptor */
+    p_ReplicGroup->p_SourceTd =
+        (t_Handle)FM_MURAM_AllocMem(h_Muram,
+                                    FM_PCD_CC_AD_ENTRY_SIZE,
+                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_ReplicGroup->p_SourceTd)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("frame replicator source table descriptor"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    /* initialize the source table descriptor */
+    BuildSourceTd(p_ReplicGroup->p_SourceTd);
+
+    /* link the source table descriptor to point to the first member in the group */
+    LinkSourceToMember(p_ReplicGroup, p_ReplicGroup->p_SourceTd, p_NextMember);
+
+    return p_ReplicGroup;
+}
+
+t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    if (p_ReplicGroup->owners)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the group has owners and can't be deleted"));
+
+    DeleteGroup(p_ReplicGroup);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*       API Run-time Frame replicator Control unit functions                */
+/*****************************************************************************/
+t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
+                                  uint16_t                  memberIndex,
+                                  t_FmPcdCcNextEngineParams *p_MemberParams)
+{
+    t_FmPcdFrmReplicGroup       *p_ReplicGroup = (t_FmPcdFrmReplicGroup*) h_ReplicGroup;
+    t_FmPcdFrmReplicMember      *p_NewMember, *p_CurrentMember = NULL, *p_PreviousMember = NULL;
+    t_Error                     err;
+    uint8_t                     memberPosition;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_MemberParams, E_INVALID_HANDLE);
+
+    if (memberIndex > p_ReplicGroup->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("memberIndex is greater than the members in the list"));
+
+    if (memberIndex >= p_ReplicGroup->maxNumOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("memberIndex is greater than the allowed number of members in the group"));
+
+    if ((p_ReplicGroup->numOfEntries + 1) > FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries with new entry can not be larger than %d\n", FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES));
+
+    /* lock */
+    err = FrmReplicGroupTryLock(p_ReplicGroup);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Lock in add operation"));
+
+    /* determine the member position in the group */
+    memberPosition = GetMemberPosition(p_ReplicGroup, memberIndex, TRUE/* add operation */);
+
+    /* Initialize a new member */
+    p_NewMember =  InitMember(p_ReplicGroup,
+                              p_MemberParams,
+                              (memberPosition == FRM_REPLIC_LAST_MEMBER_INDEX ? TRUE : FALSE));
+    if (!p_NewMember)
+    {
+        /* unlock */
+        FrmReplicGroupReleaseLock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No available member"));
+    }
+
+    switch (memberPosition)
+    {
+        case FRM_REPLIC_FIRST_MEMBER_INDEX:
+
+            p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+            if (!p_CurrentMember)
+            {
+                /* unlock */
+                FrmReplicGroupReleaseLock(p_ReplicGroup);
+                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("current member in add member operation (case first) "));
+            }
+
+            LinkMemberToMember(p_ReplicGroup, p_NewMember, p_CurrentMember);
+
+            /* update the internal group source TD */
+            LinkSourceToMember(p_ReplicGroup,
+                               p_ReplicGroup->p_SourceTd,
+                               p_NewMember);
+
+            /* Go over all the nodes that use this replicator group and update all the ad tables
+               that point to the replicator group */
+            err = ModifyGroupOwners(p_ReplicGroup, p_NewMember, FALSE/*useHostCommand*/);
+            if (err)
+            {
+                /* unlock */
+                FrmReplicGroupReleaseLock(p_ReplicGroup);
+                RETURN_ERROR(MAJOR, err, ("Update owners in add operation"));
+            }
+
+            AddMemberToList(p_ReplicGroup, p_NewMember, &p_ReplicGroup->membersList);
+            break;
+
+        case FRM_REPLIC_MIDDLE_MEMBER_INDEX:
+
+            p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+            if (!p_CurrentMember)
+            {
+                /* unlock */
+                FrmReplicGroupReleaseLock(p_ReplicGroup);
+                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("current member in add member operation (case middle) "));
+            }
+
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            if (!p_PreviousMember)
+            {
+                /* unlock */
+                FrmReplicGroupReleaseLock(p_ReplicGroup);
+                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("previous member in add member operation (case middle) "));
+            }
+            LinkMemberToMember(p_ReplicGroup, p_NewMember, p_CurrentMember);
+            LinkMemberToMember(p_ReplicGroup, p_PreviousMember, p_NewMember);
+
+            AddMemberToList(p_ReplicGroup, p_NewMember, &p_PreviousMember->node);
+            break;
+
+        case FRM_REPLIC_LAST_MEMBER_INDEX:
+
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            if (!p_PreviousMember)
+            {
+                /* unlock */
+                FrmReplicGroupReleaseLock(p_ReplicGroup);
+                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("previous member in add member operation (case last) "));
+            }
+            LinkMemberToMember(p_ReplicGroup, p_PreviousMember, p_NewMember);
+            FillReplicAdOfTypeResult(p_PreviousMember->p_MemberAd, FALSE/*last*/);
+
+            /* add the new member to the internal member list */
+            AddMemberToList(p_ReplicGroup, p_NewMember, &p_PreviousMember->node);
+           break;
+
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in add member"));
+
+    }
+
+    /* unlock */
+    FrmReplicGroupReleaseLock(p_ReplicGroup);
+    return E_OK;
+}
+
+t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
+                                     uint16_t   memberIndex)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup*) h_ReplicGroup;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+
+    if (memberIndex >= p_ReplicGroup->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member index to remove"));
+
+    /* Design decision: group must contain at least one member
+       No possibility to remove the last member from the group */
+    if (p_ReplicGroup->numOfEntries == 1)
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Can't remove the last member. At least one member should be related to a group."));
+
+    /* lock */
+    err = FrmReplicGroupTryLock(p_ReplicGroup);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Lock in remove member"));
+
+    err = RemoveMember(p_ReplicGroup, memberIndex);
+    if (err)
+    {
+        /* unlock */
+        FrmReplicGroupReleaseLock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, err, ("Remove member"));
+    }
+
+    /* unlock */
+    FrmReplicGroupReleaseLock(p_ReplicGroup);
+    return E_OK;
+}
+
+/*********************** End of API routines ************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h
new file mode 100644
index 0000000..e642843
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_replic.h
+
+ @Description   FM frame replicator
+*//***************************************************************************/
+#ifndef __FM_REPLIC_H
+#define __FM_REPLIC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+#define FRM_REPLIC_SOURCE_TD_OPCODE           0x75
+#define NEXT_FRM_REPLIC_ADDR_SHIFT            4
+#define NEXT_FRM_REPLIC_MEMBER_INDEX_SHIFT    16
+#define FRM_REPLIC_FR_BIT                     0x08000000
+#define FRM_REPLIC_NL_BIT                     0x10000000
+#define FRM_REPLIC_INVALID_MEMBER_INDEX       0xffff
+#define FRM_REPLIC_FIRST_MEMBER_INDEX         0
+
+#define FRM_REPLIC_MIDDLE_MEMBER_INDEX        1
+#define FRM_REPLIC_LAST_MEMBER_INDEX          2
+
+
+typedef enum e_UseSourceTdOption
+{
+    e_USE_SOURCE_TD_NONE = 0,
+    e_USE_SOURCE_TD_ITSELF_OPTION = 1,
+    e_USE_SOURCE_TD_COPY_OPTION = 2,
+    e_USE_SOURCE_TD_ITSELF_AND_COPY_OPTION = e_USE_SOURCE_TD_ITSELF_OPTION | e_USE_SOURCE_TD_COPY_OPTION
+} e_UseSourceTdOption;
+
+typedef struct t_FmPcdFrmReplicMember
+{
+    void                        *p_MemberAd;    /**< pointer to the member AD */
+    void                        *p_StatisticsAd;/**< pointer to the statistics AD of the member */
+    t_Handle                    h_Manip;        /**< manip handle - need for free routines */
+    t_List                      node;
+} t_FmPcdFrmReplicMember;
+
+typedef struct t_FmPcdFrmReplicGroup
+{
+    t_Handle                    h_FmPcd;
+#ifdef UNDER_CONSTRUCTION_STATISTICS_SUPPORT
+    e_FmPcdCcStatsMode          statisticsMode;
+#endif /* UNDER_CONSTRUCTION_STATISTICS_SUPPORT */
+
+    uint8_t                     maxNumOfEntries;/**< maximal number of members in the group */
+    uint8_t                     numOfEntries;   /**< actual number of members in the group */
+    uint8_t                     owners;         /**< how many keys share this frame replicator group
+                                                     NOTE:this parameter counts also keys that use the source td itself */
+    void                        *p_SourceTd;     /**< pointer to the frame replicator source table descriptor */
+    t_List                      membersList;    /**< the members list - should reflect the order of the members as in the hw linked list*/
+    t_List                      availableMembersList;/**< list of all the available members in the group */
+    t_List                      ownersList;     /**< list of all the nodes that share this group
+                                                     NOTE: in case that the source uses the original source TD in the
+                                                     group , the list is not updated - just the owners field */
+    t_FmPcdLock                 *p_Lock;
+} t_FmPcdFrmReplicGroup;
+
+
+#endif /* __FM_REPLIC_H */
-- 
1.7.9.7

