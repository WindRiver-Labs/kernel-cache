From c0b42bc6aad38b58bcaa3e79c3ab4f885cde5d90 Mon Sep 17 00:00:00 2001
From: Jonathan Fournier <jonathan.fournier@windriver.com>
Date: Sat, 31 Jan 2009 20:22:08 -0500
Subject: [PATCH] atca6101: add hardware reboot support

The PowerPC 970 contained on the Emerson ATCA-6101 needs support
from a service processor to powercycle the board. This design
specific component isn't present/working like expected on this
board. A workaround is to use a register_reboot_notifier()
to trigger the IPMI watchdog presents on this board.

Signed-off-by: Jonathan Fournier <jonathan.fournier@windriver.com>
---
 drivers/char/ipmi/Kconfig               |    7 ++
 drivers/char/ipmi/Makefile              |    1 +
 drivers/char/ipmi/ipmi_atca6101_reset.c |  176 +++++++++++++++++++++++++++++++
 3 files changed, 184 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/ipmi/ipmi_atca6101_reset.c

diff --git a/drivers/char/ipmi/Kconfig b/drivers/char/ipmi/Kconfig
index c63466a..68ce79b 100644
--- a/drivers/char/ipmi/Kconfig
+++ b/drivers/char/ipmi/Kconfig
@@ -125,4 +125,11 @@ config IPMI_EMULATE_IMB
 	 MUST have the IPMI watchdog timer enabled to use this.  This code
 	 uses some of the watchdog code.
 
+config IPMI_ATCA6101_RESET 
+   tristate 'Software reset for Emerson ATCA-6101'
+   depends on IPMI_HANDLER && PPC_MAPLE
+   default n
+   help
+    This enables software reset of Emerson ATCA-6101 board.
+
 endif # IPMI_HANDLER
diff --git a/drivers/char/ipmi/Makefile b/drivers/char/ipmi/Makefile
index 6b90c06..e3d1e0d 100644
--- a/drivers/char/ipmi/Makefile
+++ b/drivers/char/ipmi/Makefile
@@ -15,3 +15,4 @@ obj-$(CONFIG_IPMI_WATCHDOG) += ipmi_watchdog.o
 obj-$(CONFIG_IPMI_POWEROFF) += ipmi_poweroff.o
 obj-$(CONFIG_IPMI_EMULATE_RADISYS) += ipmi_radisys.o
 obj-$(CONFIG_IPMI_EMULATE_IMB) += ipmi_imb.o
+obj-$(CONFIG_IPMI_ATCA6101_RESET) += ipmi_atca6101_reset.o
diff --git a/drivers/char/ipmi/ipmi_atca6101_reset.c b/drivers/char/ipmi/ipmi_atca6101_reset.c
new file mode 100644
index 0000000..e8bf7d2
--- /dev/null
+++ b/drivers/char/ipmi/ipmi_atca6101_reset.c
@@ -0,0 +1,176 @@
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+#include <linux/notifier.h>
+#include <linux/ipmi.h>
+#include <linux/reboot.h>
+#include <linux/list.h>
+
+#define PFX "IPMI atca6101_reset: "
+
+struct bmc_private {
+	ipmi_user_t                       user;
+	int                               default_retries;
+	unsigned int                      default_retry_time_ms;
+	struct ipmi_system_interface_addr addr;
+	int                               if_num;
+	struct list_head                  link;
+};
+
+LIST_HEAD(ipmi_intfq);
+
+static long reset_msgid = 0;
+
+static int atca6101_watchdog_reboot_handler(struct notifier_block *this,
+   unsigned long code,
+   void *unused)
+{
+	struct kernel_ipmi_msg msg;
+	unsigned char *data;
+	struct bmc_private *entry, *n;
+	int rc = 0;
+
+	data = kzalloc(6, GFP_KERNEL);
+	if (!data) {
+		printk(KERN_EMERG PFX "No memory\n");
+		return -ENOMEM;
+	}
+	/* Set the timer values */
+	data[0] = 64;
+	data[1] = 1;
+	data[2] = 1;
+	data[3] = 0;
+	data[4] = 10; /* 10*100ms */
+	data[5] = 0;
+	list_for_each_entry_safe(entry, n, &ipmi_intfq, link) {
+		/* Set the timer */
+		msg.netfn = 6;
+		msg.cmd = 36;
+		msg.data = data;
+		msg.data_len = 6;
+		rc = ipmi_request_settime(entry->user,
+			   (struct ipmi_addr *)&(entry->addr),
+			   reset_msgid++, &msg, NULL, 2,
+			   entry->default_retries,
+			   entry->default_retry_time_ms);
+		if (rc) {
+			printk(KERN_EMERG PFX "Set timer error\n");
+			goto out;
+		}
+		/* Kick the watchdog */
+		msg.netfn = 6;
+		msg.cmd = 34;
+		msg.data_len = 0;
+		msg.data = 0;
+		msg.data_len = 0;
+		rc = ipmi_request_settime(entry->user,
+			   (struct ipmi_addr *)&(entry->addr),
+			   reset_msgid++, &msg, NULL, 2,
+			   entry->default_retries,
+			   entry->default_retry_time_ms);
+		if (rc) {
+			printk(KERN_EMERG PFX "Kick Watchdog error \n");
+			goto out;
+		}
+		printk(KERN_EMERG PFX "Resetting the system ... \n");
+		while (1) schedule_timeout(msecs_to_jiffies(100));
+	}
+out:
+	kfree(data);
+	return rc;
+}
+
+static struct notifier_block atca6101_watchdog_reboot_notifier = {
+	.notifier_call = atca6101_watchdog_reboot_handler,
+	.next          = NULL,
+	.priority      = INT_MAX
+};
+
+static void bmc_receive_handler(struct ipmi_recv_msg *msg,
+   void *handler_data)
+{
+	msg->done(msg);
+}
+
+static struct ipmi_user_hndl ipmi_hndlrs = {
+	.ipmi_recv_hndl = bmc_receive_handler,
+};
+
+static void ipmi_atca6101_new_smi(int if_num, struct device *device)
+{
+	struct bmc_private *bmc_priv;
+	int rc;
+
+	if (if_num != 1) {
+		bmc_priv = kzalloc(sizeof(struct bmc_private), GFP_KERNEL);
+		if (bmc_priv) {
+			bmc_priv->if_num = if_num;
+
+			/* Use the low-level defaults. */
+			bmc_priv->default_retries = -1;
+			bmc_priv->default_retry_time_ms = 0;
+
+			bmc_priv->addr.addr_type  = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;
+			bmc_priv->addr.channel    = 0x00;
+			bmc_priv->addr.lun        = 0x00;
+
+			rc = ipmi_create_user(if_num, &ipmi_hndlrs, bmc_priv, &(bmc_priv->user));
+			if (rc) {
+				printk(KERN_ERR PFX "Unable to open channel to BMC device: error %d\n", rc);
+				kfree(bmc_priv);
+			} else {
+				list_add_tail(&bmc_priv->link, &ipmi_intfq);
+				printk(KERN_INFO PFX "Registered IPMI user on BMC interface number %d\n", if_num);
+			}
+		} else {
+			printk(KERN_ERR PFX "Unable to allocate memory\n");
+		}
+	}
+}
+
+static void ipmi_atca6101_smi_gone(int if_num)
+{
+	struct bmc_private *entry, *n;
+
+	list_for_each_entry_safe(entry, n, &ipmi_intfq, link) {
+		if (if_num == entry->if_num) {
+			ipmi_destroy_user(entry->user);
+			list_del(&(entry->link));
+			kfree(entry);
+			break;
+		}
+	}
+}
+
+static struct ipmi_smi_watcher smi_watcher = {
+	.owner    = THIS_MODULE,
+	.new_smi  = ipmi_atca6101_new_smi,
+	.smi_gone = ipmi_atca6101_smi_gone
+};
+
+static int __init ipmi_atca6101_reset_init(void)
+{
+	int rv;
+
+	INIT_LIST_HEAD(&ipmi_intfq);
+
+	/* Register watchdog reboot notifier */
+	register_reboot_notifier(&atca6101_watchdog_reboot_notifier);
+
+	rv = ipmi_smi_watcher_register(&smi_watcher);
+	return rv;
+}
+module_init(ipmi_atca6101_reset_init);
+
+static __exit void ipmi_atca6101_reset_cleanup(void)
+{
+	/* Unregister watchdog reboot notifier */
+	unregister_reboot_notifier(&atca6101_watchdog_reboot_notifier);
+
+	ipmi_smi_watcher_unregister(&smi_watcher);
+}
+module_exit(ipmi_atca6101_reset_cleanup);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("<support@windriver.com>");
+MODULE_DESCRIPTION("IPMI based watchdog fix for rebooting the Emerson ATCA-6101");
-- 
1.6.0.3

