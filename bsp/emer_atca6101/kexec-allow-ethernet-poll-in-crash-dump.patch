From 1f3cee6df92b33976b636354166670fe1f75ce7a Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Sat, 14 Feb 2009 02:57:42 -0500
Subject: [PATCH] kexec: allow ethernet poll in crash dump

Run the front panel ethernet interface in poll mode, on the ATCA6101 in
a crash dump kernel. Done by touching a semaphore every tick, waking up a
kernel thread polling the network interface by calling the interrupt
handler.

Signed-off by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/kernel/time.c |   16 ++++++++++++++++
 drivers/net/amd8111e.c     |   29 +++++++++++++++++++++++++++++
 2 files changed, 45 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 19ea532..be025fb 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -73,6 +73,14 @@
 #include <asm/iseries/hv_call_xm.h>
 #endif
 
+#if (defined(CONFIG_CRASH_DUMP) && defined(CONFIG_PPC_MAPLE))
+struct net_device;
+extern void amd8111e_poll(struct net_device *dev);
+extern struct net_device *amd8111e_dev_poll;
+extern struct semaphore amd8111e_poll_sem;
+extern volatile int amd8111e_poll_in_use;
+#endif
+
 /* powerpc clocksource/clockevent code */
 
 #include <linux/clockchips.h>
@@ -673,6 +681,14 @@ void timer_interrupt(struct pt_regs * regs)
 	set_irq_regs(old_regs);
 
 	trace_trap_exit();
+
+#if (defined(CONFIG_CRASH_DUMP) && defined(CONFIG_PPC_MAPLE))
+	if(amd8111e_dev_poll) {
+		if(!amd8111e_poll_in_use) {
+			up(&amd8111e_poll_sem);
+		}
+	}
+#endif
 }
 
 void wakeup_decrementer(void)
diff --git a/drivers/net/amd8111e.c b/drivers/net/amd8111e.c
index 7780f2f..baa347c 100644
--- a/drivers/net/amd8111e.c
+++ b/drivers/net/amd8111e.c
@@ -1206,7 +1206,11 @@ err_no_interrupt:
 }
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
+#if (defined(CONFIG_CRASH_DUMP) && defined(CONFIG_PPC_MAPLE))
+void amd8111e_poll(struct net_device *dev)
+#else
 static void amd8111e_poll(struct net_device *dev)
+#endif
 {
 	unsigned long flags;
 	local_irq_save(flags);
@@ -1251,6 +1255,25 @@ static int amd8111e_close(struct net_device * dev)
 }
 /* This function opens new interface.It requests irq for the device, initializes the device,buffers and descriptors, and starts the device.
 */
+#if (defined(CONFIG_CRASH_DUMP) && defined(CONFIG_PPC_MAPLE))
+struct net_device *amd8111e_dev_poll = NULL;
+struct semaphore amd8111e_poll_sem;
+volatile int amd8111e_poll_in_use = 0;
+EXPORT_SYMBOL(amd8111e_dev_poll);
+EXPORT_SYMBOL(amd8111e_poll_sem);
+EXPORT_SYMBOL(amd8111e_poll_in_use);
+static int poll_kthread(void *net_device)
+{
+	for(;;) {
+		down_interruptible(&amd8111e_poll_sem);
+		amd8111e_poll_in_use = 1;
+		amd8111e_poll(net_device);
+		amd8111e_poll_in_use = 0;
+	}
+	return -1;
+}
+#endif
+
 static int amd8111e_open(struct net_device * dev )
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
@@ -1284,6 +1307,12 @@ static int amd8111e_open(struct net_device * dev )
 
 	netif_start_queue(dev);
 
+#if (defined(CONFIG_CRASH_DUMP) && defined(CONFIG_PPC_MAPLE))
+	sema_init(&amd8111e_poll_sem, 0);
+	kernel_thread(poll_kthread, dev, 0);
+	amd8111e_dev_poll = dev;
+#endif
+
 	return 0;
 }
 /*
-- 
1.7.0

