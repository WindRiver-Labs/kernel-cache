From f05fc30d72d7287662a889ddd870105998b697dc Mon Sep 17 00:00:00 2001
Message-Id: <f05fc30d72d7287662a889ddd870105998b697dc.1224568101.git.weiwei.wang@windriver.com>
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 21 Oct 2008 13:44:31 +0800
Subject: [PATCH 1/5] Add MTD support for Maple

4 flash devices are on Maple 970FX Evaluation Board:
Device-Name  Base-Address,Size  Device-Size,Count  Boot  Type
/dev/flash0  FFE00000,00100000  00100000,00000001  No    SST49LF080A
/dev/flash1  FFF00000,00100000  00100000,00000001  Yes   SST49LF080A
/dev/flash2  B8000000,04000000  02000000,00000002  No    I256Banked
/dev/flash3  BC000000,04000000  02000000,00000002  No    I256Banked
So add MTD partitions for these flash devices.

Signed-off-by: Amy Fong <amy.fong@windriver.com>
Integrated-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 drivers/mtd/maps/Kconfig |    6 +-
 drivers/mtd/maps/pci.c   |  234 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 232 insertions(+), 8 deletions(-)

diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index e626d89..c39cff7 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -196,11 +196,13 @@ config MTD_SCx200_DOCFLASH
 
 config MTD_AMD76XROM
 	tristate "BIOS flash chip on AMD76x southbridge"
-	depends on X86 && MTD_JEDECPROBE
+	depends on MTD_JEDECPROBE
 	help
 	  Support for treating the BIOS flash chip on AMD76x motherboards
 	  as an MTD device - with this you can reprogram your BIOS.
 
+	  Also support for Emerson ATCA-6101 firmware flash support.
+
 	  BE VERY CAREFUL.
 
 config MTD_ICHXROM
@@ -484,7 +486,7 @@ config MTD_OMAP_NOR
 # This needs CFI or JEDEC, depending on the cards found.
 config MTD_PCI
 	tristate "PCI MTD driver"
-	depends on PCI && MTD_COMPLEX_MAPPINGS
+	depends on PCI && MTD_COMPLEX_MAPPINGS && MTD_PARTITIONS
 	help
 	  Mapping for accessing flash devices on add-in cards like the Intel XScale
 	  IQ80310 card, and the Intel EBSA285 card in blank ROM programming mode
diff --git a/drivers/mtd/maps/pci.c b/drivers/mtd/maps/pci.c
index 5c6a25c..5f6f8e6 100644
--- a/drivers/mtd/maps/pci.c
+++ b/drivers/mtd/maps/pci.c
@@ -47,7 +47,6 @@ static map_word mtd_pci_read8(struct map_info *_map, unsigned long ofs)
 	return val;
 }
 
-#if 0
 static map_word mtd_pci_read16(struct map_info *_map, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
@@ -56,7 +55,7 @@ static map_word mtd_pci_read16(struct map_info *_map, unsigned long ofs)
 //	printk("read16: %08lx => %04x\n", ofs, val.x[0]);
 	return val;
 }
-#endif
+
 static map_word mtd_pci_read32(struct map_info *_map, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
@@ -68,8 +67,19 @@ static map_word mtd_pci_read32(struct map_info *_map, unsigned long ofs)
 
 static void mtd_pci_copyfrom(struct map_info *_map, void *to, unsigned long from, ssize_t len)
 {
+#ifndef CONFIG_PPC_MAPLE
 	struct map_pci_info *map = (struct map_pci_info *)_map;
 	memcpy_fromio(to, map->base + map->translate(map, from), len);
+#else
+	int i;
+	map_word val;
+
+	/* let's home *from is aligned */
+	for (i = 0; i < len; i += 2) {
+		val = mtd_pci_read16(_map, from + i);
+		((unsigned short *)to)[i/2] = val.x[0];
+	}
+#endif
 }
 
 static void mtd_pci_write8(struct map_info *_map, map_word val, unsigned long ofs)
@@ -79,14 +89,13 @@ static void mtd_pci_write8(struct map_info *_map, map_word val, unsigned long of
 	writeb(val.x[0], map->base + map->translate(map, ofs));
 }
 
-#if 0
 static void mtd_pci_write16(struct map_info *_map, map_word val, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
 //	printk("write16: %08lx <= %04x\n", ofs, val.x[0]);
 	writew(val.x[0], map->base + map->translate(map, ofs));
 }
-#endif
+
 static void mtd_pci_write32(struct map_info *_map, map_word val, unsigned long ofs)
 {
 	struct map_pci_info *map = (struct map_pci_info *)_map;
@@ -96,8 +105,19 @@ static void mtd_pci_write32(struct map_info *_map, map_word val, unsigned long o
 
 static void mtd_pci_copyto(struct map_info *_map, unsigned long to, const void *from, ssize_t len)
 {
+#ifndef CONFIG_PPC_MAPLE
 	struct map_pci_info *map = (struct map_pci_info *)_map;
 	memcpy_toio(map->base + map->translate(map, to), from, len);
+#else
+	int i;
+	map_word val;
+
+	/* let's home *from is aligned */
+	for (i = 0; i < len; i += 2) {
+		val.x[0] = ((unsigned short *)from)[i/2];
+		mtd_pci_write16(_map, val, to + i);
+	}
+#endif
 }
 
 static const struct map_info mtd_pci_map = {
@@ -106,6 +126,136 @@ static const struct map_info mtd_pci_map = {
 	.copy_to =	mtd_pci_copyto,
 };
 
+
+/*
+ * Motorola PPC2100 Flash driver
+ */
+
+/*
+ * Writes to the device are restricted to 16 bit writes.
+ * Although 8 bit reads are possible, the FLASH parts are
+ * 16 bit parts.  So specific mot_2100_copyfrom and mot_2100_copyto
+ * functions are included to insure that the accesses are 16 bit and
+ * on even boundaries.
+ */
+static void
+mot_2100_copyfrom(struct map_info *_map, void *to, unsigned long from,
+		 ssize_t len)
+{
+
+	int i = 0, odd = 0, max = 0;
+	map_word val;
+	unsigned long t_from = from - 1;
+	u8 *tmp1;
+	u16 *tmp2;
+
+	tmp1 = (u8 *)to;
+	if (from & 0x1) {
+		val = mtd_pci_read16(_map, t_from);
+		tmp1[0] = (u8) (((u16) val.x[0]) >> 8);
+		tmp1++;
+		len--;
+		from++;
+	}
+
+	odd = len % 2;
+	if (odd == 1)
+		max = len - 1;
+	else
+		max = len;
+
+	tmp2 = (u16 *)tmp1;
+	for (i = 0; i < max; i += 2, tmp2++) {
+		val = mtd_pci_read16(_map, from + i);
+		*tmp2 = (u16) val.x[0];
+	}
+
+	tmp1 = (u8 *)tmp2;
+	if (odd) {
+		val.x[0] = 0;
+		val = mtd_pci_read16(_map, from + max);
+		*tmp1 = (u8) ((u16) val.x[0] >> 8);
+	}
+}
+
+static void
+mot_2100_copyto(struct map_info *_map, unsigned long to, const void *from,
+	       ssize_t len)
+{
+	int i = 0, odd = 0, max = 0;
+	map_word val;
+
+	/** Is address an odd boundary?
+	 ** fixup, don't forget to adjust location info
+	 **/
+	if (to & 0x1) {
+		/** FF will serve as a mask
+		 ** flash only allows for a 0 -> 1
+		 ** so this is a safe operation
+		 ** and should preserve orignal data.
+		 **/
+		val.x[0] = ((((u16 *) from)[0] << 8) | 0x00ffU);
+		mtd_pci_write16(_map, val, to - 1);
+		len--;
+		to++;
+		(u8 *) from++;
+	}
+
+	/** Is the length of the write an odd length?
+	 ** Read a byte past what we would normally write
+	 ** and use this for padding for 16-bit writes only
+	 **/
+	odd = len % 2;
+	if (odd == 1)
+		max = len - 1;
+	else
+		max = len;
+
+	for (i = 0; i < max; i += 2) {
+		val.x[0] = ((u16 *) from)[i / 2];
+		mtd_pci_write16(_map, val, to + i);
+	}
+
+	/** write the odd bite, but it must be in a 16
+	 ** So mask off the last byte
+	 **/
+	if (odd) {
+		val.x[0] = (0xff00U) | (u16) (((u8 *) from)[max]);
+		mtd_pci_write16(_map, val, to + max);
+	}
+}
+
+static struct map_info mot_2100_mtd_pci_map = {
+	.phys =		NO_XIP,
+	.copy_from =	mot_2100_copyfrom,
+	.copy_to =	mot_2100_copyto,
+};
+
+static struct mtd_partition mot_2100_parts[] = {
+	{
+		.name =         "kernel image A",
+		.size =         0x005E0000,
+		.offset =       0x20000,
+	}, {
+		.name =         "file system  A",
+		.size =         0x03A00000,
+		.offset =       MTDPART_OFS_APPEND,
+	}, {
+		.name =         "kernel image B",
+		.size =         0x00600000,
+		.offset =       MTDPART_OFS_APPEND,
+	}, {
+		.name =         "file system  B",
+		.size =         0x03A00000,
+		.offset =       MTDPART_OFS_APPEND,
+	}, {
+		.name =         "Firmware Configuration Data",
+		.size =         0x20000,
+		.offset =       0x00000,
+	}
+};
+
+
 /*
  * Intel IOP80310 Flash driver
  */
@@ -260,6 +410,53 @@ static struct mtd_pci_info intel_dc21285_info = {
 };
 
 /*
+ * Motorola PPC2100 Flash driver
+ */
+
+static int
+mot_2100_init(struct pci_dev *dev, struct map_pci_info *map)
+{
+	u32 i;
+
+	map->map.bankwidth = 2;
+	map->map.read = mtd_pci_read16,
+	map->map.write = mtd_pci_write16,
+
+	map->map.size     = pci_resource_len(dev, 0);
+	map->base         = ioremap_nocache(pci_resource_start(dev, 0),
+					    pci_resource_len(dev, 0));
+
+	/* enable writes */
+	pci_read_config_dword(dev, 0x40, &i);
+	pci_write_config_dword(dev, 0x40, i | 0xf);
+
+	if (!map->base)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void
+mot_2100_exit(struct pci_dev *dev, struct map_pci_info *map)
+{
+	if (map->base)
+		iounmap((void *)map->base);
+}
+
+static unsigned long
+mot_2100_translate(struct map_pci_info *map, unsigned long ofs)
+{
+	return ofs;
+}
+
+static struct mtd_pci_info mot_2100_info = {
+	.init =		mot_2100_init,
+	.exit =		mot_2100_exit,
+	.translate =	mot_2100_translate,
+	.map_name =	"cfi_probe",
+};
+
+/*
  * PCI device ID table
  */
 
@@ -280,6 +477,13 @@ static struct pci_device_id mtd_pci_ids[] = {
 		.subdevice =	0,	/* DC21285 defaults to 0 on reset */
 		.driver_data =	(unsigned long)&intel_dc21285_info,
 	},
+	{
+		.vendor =	PCI_VENDOR_ID_MOTOROLA,
+		.device =	0x4826,
+		.subvendor =	PCI_ANY_ID,
+		.subdevice =	PCI_ANY_ID,
+		.driver_data =	(unsigned long)&mot_2100_info,
+	},
 	{ 0, }
 };
 
@@ -308,7 +512,10 @@ mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (!map)
 		goto release;
 
-	map->map       = mtd_pci_map;
+	if (id->vendor == PCI_VENDOR_ID_MOTOROLA)
+		map->map       = mot_2100_mtd_pci_map;
+	else
+		map->map       = mtd_pci_map;
 	map->map.name  = pci_name(dev);
 	map->dev       = dev;
 	map->exit      = info->exit;
@@ -325,7 +532,22 @@ mtd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		goto release;
 
 	mtd->owner = THIS_MODULE;
-	add_mtd_device(mtd);
+	if (id->vendor == PCI_VENDOR_ID_MOTOROLA) {
+		printk(KERN_NOTICE " Adding MOTOROLA flash partitions\n");
+
+		if (mtd->unlock) {
+			/** unlock both of the filesystem partitions so that
+			** if they are mounted as root, they are readwrite
+			**/
+			mtd->unlock(mtd, 0x000000, 0x20000);
+			mtd->unlock(mtd, 0x600000, 0x3A00000);
+			mtd->unlock(mtd, 0x4600000, 0x3A00000);
+		}
+		add_mtd_partitions(mtd, mot_2100_parts,
+				   ARRAY_SIZE(mot_2100_parts));
+	} else {
+		add_mtd_device(mtd);
+	}
 
 	pci_set_drvdata(dev, mtd);
 
-- 
1.5.5.1

