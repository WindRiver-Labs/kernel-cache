From bdcabe031770ba11e3cf4d408fad7c858a64a4ba Mon Sep 17 00:00:00 2001
From: Chao Fu <B44548@freescale.com>
Date: Mon, 11 Aug 2014 16:15:16 +0800
Subject: [PATCH 251/255] spi:fsl-qspi:Add qspi ddr quad read support

This patch will support ddr quad read mode to read data of Quadspi bus.

QSPI provide the AMBA base to map flash and ddr through AHB bus access to
read data from spi flash.
In large mount of data case, QSPI will use quad read method.
In small mount of data case, QSPI will use IP comamnd method.

Signed-off-by: Chao Fu <B44548@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/spi-fsl-quadspi.c | 176 ++++++++++++++++++++++++++++++++++++------
 1 file changed, 153 insertions(+), 23 deletions(-)

diff --git a/drivers/spi/spi-fsl-quadspi.c b/drivers/spi/spi-fsl-quadspi.c
index d8b4bba..3286ed7 100644
--- a/drivers/spi/spi-fsl-quadspi.c
+++ b/drivers/spi/spi-fsl-quadspi.c
@@ -76,6 +76,13 @@
 #define QSPI_MCR_CLR_RXF_MASK	(1 << QSPI_MCR_CLR_RXF_SHIFT)
 #define QSPI_MCR_DDR_EN_SHIFT	7
 #define QSPI_MCR_DDR_EN_MASK	(1 << QSPI_MCR_DDR_EN_SHIFT)
+#define QSPI_MCR_END_CFG_SHIFT	2
+#define QSPI_MCR_END_CFG_MASK	(3 << QSPI_MCR_END_CFG_SHIFT)
+#define QSPI_MCR_SWRSTHD_SHIFT	1
+#define QSPI_MCR_SWRSTHD_MASK	(1 << QSPI_MCR_SWRSTHD_SHIFT)
+#define QSPI_MCR_SWRSTSD_SHIFT	0
+#define QSPI_MCR_SWRSTSD_MASK	(1 << QSPI_MCR_SWRSTSD_SHIFT)
+
 #define QSPI_MCR_RESERVED_SHIFT	16
 #define QSPI_MCR_RESERVED_MASK  (0xF << QSPI_MCR_RESERVED_SHIFT)
 
@@ -107,6 +114,17 @@
 #define QSPI_SR_BUSY_SHIFT		0
 #define QSPI_SR_BUSY_MASK		(1 << QSPI_SR_BUSY_SHIFT)
 
+#define QSPI_BUF0CR			0x10
+#define QSPI_BUF1CR			0x14
+#define QSPI_BUF2CR			0x18
+#define QSPI_BUFXCR_INVALID_MSTRID	0xe
+#define QSPI_BUF3CR			0x1c
+#define QSPI_BUF3CR_ALLMST_SHIFT	31
+#define QSPI_BUF3CR_ALLMST		(1 << QSPI_BUF3CR_ALLMST_SHIFT)
+
+#define QSPI_BUF0IND			0x30
+#define QSPI_BUF1IND			0x34
+#define QSPI_BUF2IND			0x38
 /* Field definitions for FR */
 #define QSPI_FR_TFF_MASK		1
 
@@ -118,6 +136,7 @@
 #define TX_SEQID			8
 #define RX_SEQID			9
 #define FSRD_SEQID			0xa
+#define QUADRD_SEQID			0xb
 
 /* Field definitions for IPCR */
 #define QSPI_IPCR_SEQID_SHIFT	24
@@ -139,6 +158,7 @@
 #define CMD			1
 #define ADDR			2
 #define ADDR24BIT		0x18
+#define ADDR32BIT		0x20
 #define DUMMY			3
 #define MODE			4
 #define MODE2			5
@@ -150,6 +170,11 @@
 #define MODE_DDR		11
 #define MODE2_DDR		12
 #define MODE4_DDR		13
+#define READ_DDR		14
+
+#define LUT_PAD1		0
+#define LUT_PAD2		1
+#define LUT_PAD4		2
 
 #define RX_BUFFER_SIZE		0x80
 #define TX_BUFFER_SIZE		0x40
@@ -180,6 +205,8 @@
 
 struct fsl_qspi {
 	void __iomem *iobase;
+	void __iomem *abh_base;
+	unsigned long amba_base;
 	struct clk *clk;
 
 	u32 select_cs;
@@ -192,7 +219,6 @@ struct fsl_qspi {
 	wait_queue_head_t waitt;
 	u32 waitflag_r;
 	u32 waitflag_t;
-	unsigned long amba_base;
 	bool big_endian;
 
 };
@@ -248,6 +274,63 @@ static irqreturn_t fsl_qspi_irq_handler(int this_irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static void fsl_qspi_invalid(struct fsl_qspi *q)
+{
+	u32 reg;
+
+	reg = qspi_readl(q, q->iobase + QSPI_MCR);
+	reg |= QSPI_MCR_SWRSTHD_MASK | QSPI_MCR_SWRSTSD_MASK;
+	qspi_writel(q, reg, q->iobase + QSPI_MCR);
+
+	/*
+	 * The minimum delay : 1 AHB + 2 SFCK clocks.
+	 * Delay 1 us is enough.
+	 */
+	udelay(1);
+
+	reg &= ~(QSPI_MCR_SWRSTHD_MASK | QSPI_MCR_SWRSTSD_MASK);
+	qspi_writel(q, reg, q->iobase + QSPI_MCR);
+}
+
+static void fsl_qspi_init_abh_read(struct fsl_qspi *q)
+{
+	void __iomem *base = q->iobase;
+	u32 reg, reg2;
+
+	/* AHB configuration for access buffer 0/1/2 .*/
+	qspi_writel(q, QSPI_BUFXCR_INVALID_MSTRID, base + QSPI_BUF0CR);
+	qspi_writel(q, QSPI_BUFXCR_INVALID_MSTRID, base + QSPI_BUF1CR);
+	qspi_writel(q, QSPI_BUFXCR_INVALID_MSTRID, base + QSPI_BUF2CR);
+	qspi_writel(q, QSPI_BUF3CR_ALLMST, base + QSPI_BUF3CR);
+
+	/* We only use the buffer3 */
+	qspi_writel(q, 0, base + QSPI_BUF0IND);
+	qspi_writel(q, 0, base + QSPI_BUF1IND);
+	qspi_writel(q, 0, base + QSPI_BUF2IND);
+
+	/* Set the default lut sequence for AHB Read. */
+
+	qspi_writel(q, QUADRD_SEQID << QSPI_BFGENCR_SEQID_SHIFT,
+		q->iobase + QSPI_BFGENCR);
+
+	/* enable the DDR quad read */
+	reg = qspi_readl(q, q->iobase + QSPI_MCR);
+
+	/* Firstly, disable the module */
+	qspi_writel(q, reg | QSPI_MCR_MDIS_MASK, q->iobase + QSPI_MCR);
+
+	/* Set the Sampling Register for DDR */
+	reg2 = qspi_readl(q, q->iobase + QSPI_SMPR);
+	reg2 &= ~QSPI_SMPR_DDRSMP_MASK;
+	reg2 |= (2 << QSPI_SMPR_DDRSMP_SHIFT);
+	qspi_writel(q, reg2, q->iobase + QSPI_SMPR);
+
+	/* Enable the module again (enable the DDR too) */
+	reg |= QSPI_MCR_DDR_EN_MASK;
+
+	qspi_writel(q, reg, q->iobase + QSPI_MCR);
+}
+
 static void fsl_qspi_set_lut(struct fsl_qspi *fsl_qspi)
 {
 	u32 lut_base;
@@ -317,6 +400,19 @@ static void fsl_qspi_set_lut(struct fsl_qspi *fsl_qspi)
 	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
 	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
+	/* SEQID  -  Receive transfer QuadDDR Read */
+	lut_base = QUADRD_SEQID * 4;
+	qspi_writel(fsl_qspi, OPRND0(0xee) | PAD0(LUT_PAD1) | INSTR0(CMD)
+			| OPRND1(ADDR24BIT) | PAD1(LUT_PAD4) | INSTR1(ADDR_DDR),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	qspi_writel(fsl_qspi, OPRND0(0xff) | PAD0(LUT_PAD4) | INSTR0(MODE_DDR)
+			| OPRND1(8) | PAD1(LUT_PAD1) | INSTR1(DUMMY),
+			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	qspi_writel(fsl_qspi, OPRND0(128) | PAD0(LUT_PAD4) | INSTR0(READ_DDR)
+			| OPRND1(0) | PAD1(LUT_PAD1) | INSTR1(JMP_ON_CS),
+			 fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
 	/* Lock the LUT */
 	qspi_writel(fsl_qspi, KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
 	qspi_writel(fsl_qspi, QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
@@ -368,20 +464,7 @@ static void set_lut(struct fsl_qspi *fsl_qspi, u8 opr, u8 *seqid)
 		*seqid = READSTATU_SEQID;
 		break;
 	case OPCODE_FAST_READ:
-		lut_base = RX_SEQID * 4;
-		qspi_writel(fsl_qspi, OPRND0(OPCODE_FAST_READ) |
-				PAD0(0) | INSTR0(CMD) | OPRND1(ADDR24BIT) |
-				PAD1(0) | INSTR1(ADDR),
-				fsl_qspi->iobase + QSPI_LUT(lut_base));
-		qspi_writel(fsl_qspi, OPRND0(8) | PAD0(0) | INSTR0(DUMMY) |
-				OPRND1(RX_BUFFER_SIZE) | PAD1(0) |
-				INSTR1(READ),
-				fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-		qspi_writel(fsl_qspi, 0x0,
-				fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-		qspi_writel(fsl_qspi, 0x0,
-				fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
-		*seqid = RX_SEQID;
+		*seqid = QUADRD_SEQID;
 		break;
 	case OPCODE_NORM_READ:
 		lut_base = RX_SEQID * 4;
@@ -473,6 +556,41 @@ static void fsl_qspi_do_rx(struct fsl_qspi *fsl_qspi, u32 position,
 
 }
 
+static void fsl_qspi_quad_rx(struct fsl_qspi *fsl_qspi, u32 position,
+		u32 len, u32 *rxbuf)
+{
+	unsigned long mcr;
+
+	mcr = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_MCR);
+
+	qspi_writel(fsl_qspi, position, fsl_qspi->iobase + QSPI_SFAR);
+
+	do {
+		unsigned long reg;
+		reg = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_SR);
+		if (reg & (QSPI_SR_IP_ACC_MASK | QSPI_SR_AHB_ACC_MASK)) {
+			udelay(1);
+			dev_dbg(fsl_qspi->dev,
+				"The controller is busy, 0x%08x\n",
+				(unsigned int)reg);
+			continue;
+		}
+		break;
+	} while (1);
+
+	qspi_writel(fsl_qspi, QUADRD_SEQID << QSPI_IPCR_SEQID_SHIFT | len,
+			fsl_qspi->iobase + QSPI_IPCR);
+	qspi_writel(fsl_qspi, mcr | QSPI_MCR_END_CFG_MASK,
+			fsl_qspi->iobase + QSPI_MCR);
+
+	fsl_qspi->waitflag_r = 1;
+	wait_event(fsl_qspi->waitr, !fsl_qspi->waitflag_r);
+
+	memcpy(rxbuf, fsl_qspi->abh_base + position, len);
+
+	qspi_writel(fsl_qspi, mcr, fsl_qspi->iobase + QSPI_MCR);
+}
+
 static void fsl_qspi_do_tx(struct fsl_qspi *fsl_qspi,
 		u32 position, u32 count, const u32 *txbuf)
 {
@@ -566,12 +684,17 @@ static int fsl_qspi_do_one_msg(struct spi_master *master,
 			} else {
 				fsl_qspi_do_tx(fsl_qspi, cpu_to_be32(pos),
 					t->len, t->tx_buf);
+				fsl_qspi_invalid(fsl_qspi);
 			}
 		}
 
 		if (t->rx_buf) {
-			fsl_qspi_do_rx(fsl_qspi, cpu_to_be32(pos),
-					t->len, t->rx_buf);
+			if (t->len < RX_BUFFER_SIZE)
+				fsl_qspi_do_rx(fsl_qspi, cpu_to_be32(pos),
+						t->len, t->rx_buf);
+			else
+				fsl_qspi_quad_rx(fsl_qspi, pos,
+						t->len, t->rx_buf);
 		}
 
 		m->actual_length += t->len;
@@ -676,18 +799,24 @@ static int fsl_qspi_probe(struct platform_device *pdev)
 
 	fsl_qspi = spi_master_get_devdata(master);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
+	/* find the resources */
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "QuadSPI");
+	fsl_qspi->iobase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(fsl_qspi->iobase)) {
 		dev_err(&pdev->dev, "could not get memory resource\n");
 		ret = -ENODEV;
 		goto out_master_put;
 	}
 
-	fsl_qspi->iobase = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(fsl_qspi->iobase)) {
-		ret = PTR_ERR(fsl_qspi->iobase);
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					"QuadSPI-memory");
+	fsl_qspi->abh_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(fsl_qspi->abh_base)) {
+		dev_err(&pdev->dev, "could not get AHB memory resource\n");
+		ret = -ENODEV;
 		goto out_master_put;
 	}
+	fsl_qspi->amba_base = res->start;
 
 	gate = devm_clk_get(&pdev->dev, "qspi_en");
 	if (IS_ERR(gate)) {
@@ -721,7 +850,6 @@ static int fsl_qspi_probe(struct platform_device *pdev)
 	}
 
 	fsl_qspi->big_endian = of_property_read_bool(np, "big-endian");
-	of_property_read_u32(np, "amba-base", (u32 *)&fsl_qspi->amba_base);
 
 	init_timer(&fsl_qspi->wait_timer);
 	fsl_qspi->wait_timer.function = &fsl_qspi_wait_do_timer;
@@ -741,6 +869,8 @@ static int fsl_qspi_probe(struct platform_device *pdev)
 	master->transfer_one_message = fsl_qspi_do_one_msg;
 	platform_set_drvdata(pdev, master);
 
+	fsl_qspi_init_abh_read(fsl_qspi);
+
 	ret = spi_register_master(master);
 	if (ret) {
 		dev_err(&pdev->dev,
-- 
2.0.2

