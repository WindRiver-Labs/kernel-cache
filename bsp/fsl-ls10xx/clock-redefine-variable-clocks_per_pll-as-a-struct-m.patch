From ca875e5983b4a3cebd3796f7b808366955d65795 Mon Sep 17 00:00:00 2001
From: Tang Yuantian <Yuantian.Tang@freescale.com>
Date: Wed, 22 Oct 2014 15:16:35 +0800
Subject: [PATCH 120/129] clock: redefine variable clocks_per_pll as a struct
 member

redefine variable clocks_per_pll as a struct member

If there are multiple PLL clock nodes, this variable will
get overwritten. Redefined it as a struct member can avoid this.

Signed-off-by: Tang Yuantian <Yuantian.Tang@freescale.com>
Change-Id: I892993ffaf046f333c564170a5cac7c845ef9ba8
Reviewed-on: http://git.am.freescale.net:8181/21873
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin:Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso and
aligned clk-qoriq.c with freescale SDK]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/clk/clk-qoriq.c |  193 ++++++++++++++++------------------------------
 drivers/clk/clk.c       |   77 +------------------
 2 files changed, 71 insertions(+), 199 deletions(-)

diff --git a/drivers/clk/clk-qoriq.c b/drivers/clk/clk-qoriq.c
index ae21621..9a503dd 100644
--- a/drivers/clk/clk-qoriq.c
+++ b/drivers/clk/clk-qoriq.c
@@ -5,11 +5,8 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  *
- * clock driver for Freescale QorIQ SoCs.
+ * clock driver for Freescale PowerPC corenet SoCs.
  */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
 #include <linux/clk-provider.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
@@ -22,8 +19,8 @@
 struct cmux_clk {
 	struct clk_hw hw;
 	void __iomem *reg;
-	unsigned int clk_per_pll;
 	u32 flags;
+	unsigned int clk_per_pll;
 };
 
 #define PLL_KILL			BIT(31)
@@ -31,6 +28,8 @@ struct cmux_clk {
 #define CLKSEL_ADJUST		BIT(0)
 #define to_cmux_clk(p)		container_of(p, struct cmux_clk, hw)
 
+static void __iomem *base;
+
 static int cmux_set_parent(struct clk_hw *hw, u8 idx)
 {
 	struct cmux_clk *clk = to_cmux_clk(hw);
@@ -59,7 +58,7 @@ static u8 cmux_get_parent(struct clk_hw *hw)
 	return clksel;
 }
 
-static const struct clk_ops cmux_ops = {
+const struct clk_ops cmux_ops = {
 	.get_parent = cmux_get_parent,
 	.set_parent = cmux_set_parent,
 };
@@ -88,23 +87,21 @@ static void __init core_mux_init(struct device_node *np)
 		pr_err("%s: get clock count error\n", np->name);
 		return;
 	}
-	parent_names = kcalloc(count, sizeof(char *), GFP_KERNEL);
-	if (!parent_names)
+	parent_names = kzalloc((sizeof(char *) * count), GFP_KERNEL);
+	if (!parent_names) {
+		pr_err("%s: could not allocate parent_names\n", __func__);
 		return;
+	}
 
 	for (i = 0; i < count; i++)
 		parent_names[i] = of_clk_get_parent_name(np, i);
 
-	cmux_clk = kzalloc(sizeof(*cmux_clk), GFP_KERNEL);
-	if (!cmux_clk)
+	cmux_clk = kzalloc(sizeof(struct cmux_clk), GFP_KERNEL);
+	if (!cmux_clk) {
+		pr_err("%s: could not allocate cmux_clk\n", __func__);
 		goto err_name;
-
-	cmux_clk->reg = of_iomap(np, 0);
-	if (!cmux_clk->reg) {
-		pr_err("%s: could not map register\n", __func__);
-		goto err_clk;
 	}
-
+	cmux_clk->reg = base + offset;
 	rc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", 0,
 					&clkspec);
 	if (rc) {
@@ -157,48 +154,51 @@ err_name:
 
 static void __init core_pll_init(struct device_node *np)
 {
-	u32 mult;
+	u32 offset, mult;
 	int i, rc, count;
 	const char *clk_name, *parent_name;
 	struct clk_onecell_data *onecell_data;
 	struct clk      **subclks;
-	void __iomem *base;
 
-	base = of_iomap(np, 0);
-	if (!base) {
-		pr_err("iomap error\n");
+	rc = of_property_read_u32(np, "reg", &offset);
+	if (rc) {
+		pr_err("%s: could not get reg property\n", np->name);
 		return;
 	}
 
 	/* get the multiple of PLL */
-	mult = ioread32be(base);
+	mult = ioread32be(base + offset);
 
 	/* check if this PLL is disabled */
 	if (mult & PLL_KILL) {
 		pr_debug("PLL:%s is disabled\n", np->name);
-		goto err_map;
+		return;
 	}
 	mult = (mult >> 1) & 0x3f;
 
 	parent_name = of_clk_get_parent_name(np, 0);
 	if (!parent_name) {
 		pr_err("PLL: %s must have a parent\n", np->name);
-		goto err_map;
+		return;
 	}
 
 	count = of_property_count_strings(np, "clock-output-names");
 	if (count < 0 || count > 4) {
 		pr_err("%s: clock is not supported\n", np->name);
-		goto err_map;
+		return;
 	}
 
-	subclks = kcalloc(count, sizeof(struct clk *), GFP_KERNEL);
-	if (!subclks)
-		goto err_map;
+	subclks = kzalloc(sizeof(struct clk *) * count, GFP_KERNEL);
+	if (!subclks) {
+		pr_err("%s: could not allocate subclks\n", __func__);
+		return;
+	}
 
-	onecell_data = kmalloc(sizeof(*onecell_data), GFP_KERNEL);
-	if (!onecell_data)
+	onecell_data = kzalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!onecell_data) {
+		pr_err("%s: could not allocate onecell_data\n", __func__);
 		goto err_clks;
+	}
 
 	for (i = 0; i < count; i++) {
 		rc = of_property_read_string_index(np, "clock-output-names",
@@ -238,125 +238,66 @@ static void __init core_pll_init(struct device_node *np)
 		goto err_cell;
 	}
 
-	iounmap(base);
 	return;
 err_cell:
 	kfree(onecell_data);
 err_clks:
 	kfree(subclks);
-err_map:
-	iounmap(base);
 }
 
-static void __init sysclk_init(struct device_node *node)
-{
-	struct clk *clk;
-	const char *clk_name = node->name;
-	struct device_node *np = of_get_parent(node);
-	u32 rate;
-
-	if (!np) {
-		pr_err("could not get parent node\n");
-		return;
-	}
-
-	if (of_property_read_u32(np, "clock-frequency", &rate)) {
-		of_node_put(node);
-		return;
-	}
-
-	of_property_read_string(np, "clock-output-names", &clk_name);
-
-	clk = clk_register_fixed_rate(NULL, clk_name, NULL, CLK_IS_ROOT, rate);
-	if (!IS_ERR(clk))
-		of_clk_add_provider(np, of_clk_src_simple_get, clk);
-}
+static const struct of_device_id clk_match[] __initconst = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "fsl,core-pll-clock", .data = core_pll_init, },
+	{ .compatible = "fsl,core-mux-clock", .data = core_mux_init, },
+	{}
+};
 
-static void __init pltfrm_pll_init(struct device_node *np)
+static int __init qoriq_corenet_clk_probe(struct platform_device *pdev)
 {
-	void __iomem *base;
-	uint32_t mult;
-	const char *parent_name, *clk_name;
-	int i, _errno;
-	struct clk_onecell_data *cod;
+	struct device_node *np;
 
+	np = pdev->dev.of_node;
 	base = of_iomap(np, 0);
 	if (!base) {
-		pr_err("%s(): %s: of_iomap() failed\n", __func__, np->name);
-		return;
+		dev_err(&pdev->dev, "iomap error\n");
+		return -ENOMEM;
 	}
+	of_clk_init(clk_match);
 
-	/* Get the multiple of PLL */
-	mult = ioread32be(base);
-
-	iounmap(base);
-
-	/* Check if this PLL is disabled */
-	if (mult & PLL_KILL) {
-		pr_debug("%s(): %s: Disabled\n", __func__, np->name);
-		return;
+	return 0;
 	}
-	mult = (mult & GENMASK(6, 1)) >> 1;
 
-	parent_name = of_clk_get_parent_name(np, 0);
-	if (!parent_name) {
-		pr_err("%s(): %s: of_clk_get_parent_name() failed\n",
-		       __func__, np->name);
-		return;
-	}
+static const struct of_device_id qoriq_clk_ids[] __initconst = {
+	{ .compatible = "fsl,qoriq-clockgen-1.0", },
+	{ .compatible = "fsl,qoriq-clockgen-2.0", },
+	{}
 
-	i = of_property_count_strings(np, "clock-output-names");
-	if (i < 0) {
-		pr_err("%s(): %s: of_property_count_strings(clock-output-names) = %d\n",
-		       __func__, np->name, i);
-		return;
-	}
+};
 
-	cod = kmalloc(sizeof(*cod) + i * sizeof(struct clk *), GFP_KERNEL);
-	if (!cod)
-		return;
-	cod->clks = (struct clk **)(cod + 1);
-	cod->clk_num = i;
-
-	for (i = 0; i < cod->clk_num; i++) {
-		_errno = of_property_read_string_index(np, "clock-output-names",
-						       i, &clk_name);
-		if (_errno < 0) {
-			pr_err("%s(): %s: of_property_read_string_index(clock-output-names) = %d\n",
-			       __func__, np->name, _errno);
-			goto return_clk_unregister;
-		}
 
-		cod->clks[i] = clk_register_fixed_factor(NULL, clk_name,
-					       parent_name, 0, mult, 1 + i);
-		if (IS_ERR(cod->clks[i])) {
-			pr_err("%s(): %s: clk_register_fixed_factor(%s) = %ld\n",
-			       __func__, np->name,
-			       clk_name, PTR_ERR(cod->clks[i]));
-			goto return_clk_unregister;
-		}
-	}
+static struct platform_driver qoriq_corenet_clk_driver = {
+	.driver = {
+		.name = "qoriq_corenet_clock",
+		.owner = THIS_MODULE,
+		.of_match_table = qoriq_clk_ids,
+	},
+
+	.probe = qoriq_corenet_clk_probe,
+};
 
-	_errno = of_clk_add_provider(np, of_clk_src_onecell_get, cod);
-	if (_errno < 0) {
-		pr_err("%s(): %s: of_clk_add_provider() = %d\n",
-		       __func__, np->name, _errno);
-		goto return_clk_unregister;
+static int __init qoriq_corenet_clk_init(void)
+{
+	return platform_driver_register(&qoriq_corenet_clk_driver);
 	}
+subsys_initcall(qoriq_corenet_clk_init);
 
+static void __init ls1021a_clocks_init(struct device_node *np)
+{
+	base = of_iomap(np, 0);
+	if (!base)
 	return;
 
-return_clk_unregister:
-	while (--i >= 0)
-		clk_unregister(cod->clks[i]);
-	kfree(cod);
+	of_clk_init(clk_match);
 }
 
-CLK_OF_DECLARE(qoriq_sysclk_1, "fsl,qoriq-sysclk-1.0", sysclk_init);
-CLK_OF_DECLARE(qoriq_sysclk_2, "fsl,qoriq-sysclk-2.0", sysclk_init);
-CLK_OF_DECLARE(qoriq_core_pll_1, "fsl,qoriq-core-pll-1.0", core_pll_init);
-CLK_OF_DECLARE(qoriq_core_pll_2, "fsl,qoriq-core-pll-2.0", core_pll_init);
-CLK_OF_DECLARE(qoriq_core_mux_1, "fsl,qoriq-core-mux-1.0", core_mux_init);
-CLK_OF_DECLARE(qoriq_core_mux_2, "fsl,qoriq-core-mux-2.0", core_mux_init);
-CLK_OF_DECLARE(qoriq_pltfrm_pll_1, "fsl,qoriq-platform-pll-1.0", pltfrm_pll_init);
-CLK_OF_DECLARE(qoriq_pltfrm_pll_2, "fsl,qoriq-platform-pll-2.0", pltfrm_pll_init);
+CLK_OF_DECLARE(ls1021a, "fsl,ls1021a-clockgen", ls1021a_clocks_init);
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 9f9cadd..121fb7e 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -3077,93 +3077,24 @@ struct clock_provider {
 
 static LIST_HEAD(clk_provider_list);
 
-/*
- * This function looks for a parent clock. If there is one, then it
- * checks that the provider for this parent clock was initialized, in
- * this case the parent clock will be ready.
- */
-static int parent_ready(struct device_node *np)
-{
-	int i = 0;
-
-	while (true) {
-		struct clk *clk = of_clk_get(np, i);
-
-		/* this parent is ready we can check the next one */
-		if (!IS_ERR(clk)) {
-			clk_put(clk);
-			i++;
-			continue;
-		}
-
-		/* at least one parent is not ready, we exit now */
-		if (PTR_ERR(clk) == -EPROBE_DEFER)
-			return 0;
-
-		/*
-		 * Here we make assumption that the device tree is
-		 * written correctly. So an error means that there is
-		 * no more parent. As we didn't exit yet, then the
-		 * previous parent are ready. If there is no clock
-		 * parent, no need to wait for them, then we can
-		 * consider their absence as being ready
-		 */
-		return 1;
-	}
-}
-
 /**
  * of_clk_init() - Scan and init clock providers from the DT
  * @matches: array of compatible values and init functions for providers.
  *
- * This function scans the device tree for matching clock providers
- * and calls their initialization functions. It also does it by trying
- * to follow the dependencies.
+ * This function scans the device tree for matching clock providers and
+ * calls their initialization functions
  */
 void __init of_clk_init(const struct of_device_id *matches)
 {
 	const struct of_device_id *match;
 	struct device_node *np;
-	struct clock_provider *clk_provider, *next;
-	bool is_init_done;
-	bool force = false;
 
 	if (!matches)
 		matches = &__clk_of_table;
 
-	/* First prepare the list of the clocks providers */
 	for_each_matching_node_and_match(np, matches, &match) {
-		struct clock_provider *parent =
-			kzalloc(sizeof(struct clock_provider),	GFP_KERNEL);
-
-		parent->clk_init_cb = match->data;
-		parent->np = np;
-		list_add_tail(&parent->node, &clk_provider_list);
-	}
-
-	while (!list_empty(&clk_provider_list)) {
-		is_init_done = false;
-		list_for_each_entry_safe(clk_provider, next,
-					&clk_provider_list, node) {
-			if (force || parent_ready(clk_provider->np)) {
-
-				clk_provider->clk_init_cb(clk_provider->np);
-				of_clk_set_defaults(clk_provider->np, true);
-
-				list_del(&clk_provider->node);
-				kfree(clk_provider);
-				is_init_done = true;
-			}
-		}
-
-		/*
-		 * We didn't manage to initialize any of the
-		 * remaining providers during the last loop, so now we
-		 * initialize all the remaining ones unconditionally
-		 * in case the clock parent was not mandatory
-		 */
-		if (!is_init_done)
-			force = true;
+		of_clk_init_cb_t clk_init_cb = match->data;
+		clk_init_cb(np);
 	}
 }
 #endif
-- 
1.7.5.4

