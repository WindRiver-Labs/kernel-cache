From d91714f490dae3bd73bd6ffaeca0e910a00207a8 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 1 Oct 2014 18:11:40 +0300
Subject: [PATCH 058/129] gianfar: Exclude SRAM alloc from non-PPC (ARM)

Allocation of Buffer Descriptors to SRAM is not supported
by the ARM based LS1 platform.  The CACHE_SRAM feature is
PPC specific (mpc85xx SoC family more exactly). The mpc85xx
CACHE_SRAM driver lies in the PPC architecture folders, so
the API calls in gianfar must be excluded from non-PPC builds,
otherwise obviously there will be compile errors on ARM (LS1).

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I5594ec8fd104794d183426b973d35309d44b64e2
Reviewed-on: http://git.am.freescale.net:8181/21173
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   33 +++++++++++++++--------------
 drivers/net/ethernet/freescale/gianfar.h |   34 +++++++++++++++--------------
 2 files changed, 35 insertions(+), 32 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 7f19a3a..d3fa8c3 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -167,10 +167,12 @@ static void gfar_set_mac_for_addr(struct net_device *dev, int num,
 				  const u8 *addr);
 static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
+#ifdef CONFIG_FSL_85XX_CACHE_SRAM
 bool gfar_l2sram_en = true;
 module_param(gfar_l2sram_en, bool, 0444);
 MODULE_PARM_DESC(gfar_l2sram_en,
 		 "Enable allocation to L2 SRAM.");
+#endif
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
@@ -251,7 +253,6 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 {
 	void *vaddr = NULL;
 	dma_addr_t addr;
-	phys_addr_t paddr;
 	int i, j, k;
 	struct gfar_private *priv = netdev_priv(ndev);
 	struct device *dev = priv->dev;
@@ -267,7 +268,9 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
 
 	/* Allocate memory for the buffer descriptors */
+#ifdef CONFIG_FSL_85XX_CACHE_SRAM
 	if (priv->bd_l2sram_en) {
+		phys_addr_t paddr;
 		vaddr = mpc85xx_cache_sram_alloc(BD_RING_REG_SZ(priv),
 						 &paddr, L1_CACHE_BYTES);
 		if (vaddr)
@@ -279,6 +282,7 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 			priv->bd_l2sram_en = 0;
 		}
 	}
+#endif
 
 	if (!priv->bd_l2sram_en)
 		vaddr = dma_alloc_coherent(dev, BD_RING_REG_SZ(priv),
@@ -736,27 +740,20 @@ static int gfar_parse_group(struct device_node *np,
 		grp->tx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
 
 		ret = of_property_read_u32(np, "fsl,rx-bit-map", &rxq_mask);
-		if (!ret) {
-			grp->rx_bit_map = rxq_mask ?
-			rxq_mask : (DEFAULT_MAPPING >> priv->num_grps);
-		}
+		if (!ret)
+			grp->rx_bit_map = rxq_mask;
 
 		ret = of_property_read_u32(np, "fsl,tx-bit-map", &txq_mask);
-		if (!ret) {
-			grp->tx_bit_map = txq_mask ?
-			txq_mask : (DEFAULT_MAPPING >> priv->num_grps);
-		}
+		if (!ret)
+			grp->tx_bit_map = txq_mask;
 
+#ifndef CONFIG_AS_FASTPATH
 		if (priv->poll_mode == GFAR_SQ_POLLING) {
 			/* One Q per interrupt group: Q0 to G0, Q1 to G1 */
 			grp->rx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
 			grp->tx_bit_map = (DEFAULT_MAPPING >> priv->num_grps);
-	#ifdef CONFIG_AS_FASTPATH
-			grp->rx_bit_map = rxq_mask ?
-			*rxq_mask : (DEFAULT_MAPPING >> priv->num_grps);
-			grp->tx_bit_map = txq_mask ?
-			*txq_mask : (DEFAULT_MAPPING >> priv->num_grps);
-	#endif
+		}
+#endif
 	} else {
 		grp->rx_bit_map = 0xFF;
 		grp->tx_bit_map = 0xFF;
@@ -937,10 +934,12 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 			goto err_grp_init;
 	}
 
+#ifdef CONFIG_FSL_85XX_CACHE_SRAM
 	if (gfar_l2sram_en) {
 		/* try to alloc the BD rings to L2 SRAM */
 		priv->bd_l2sram_en = 1;
 	}
+#endif
 
 	stash = of_find_property(np, "bd-stash", NULL);
 
@@ -2232,9 +2231,11 @@ static void free_skb_resources(struct gfar_private *priv)
 			free_skb_rx_queue(rx_queue);
 	}
 
+#ifdef CONFIG_FSL_85XX_CACHE_SRAM
 	if (priv->bd_l2sram_en)
 		mpc85xx_cache_sram_free(priv->tx_queue[0]->tx_bd_base);
 	else
+#endif
 		dma_free_coherent(priv->dev, BD_RING_REG_SZ(priv),
 				  priv->tx_queue[0]->tx_bd_base,
 				  priv->tx_queue[0]->tx_bd_dma_base);
@@ -2614,7 +2615,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		 */
 		vlan_ctrl = gfar_read(&regs->dfvlan);
 		vlan_ctrl &= ~0xFFFF;
-		vlan_ctrl |= (fcb->vlctl & 0xFFFF);
+		vlan_ctrl |= (be16_to_cpu(fcb->vlctl) & 0xFFFF);
 		gfar_write(&regs->dfvlan, vlan_ctrl);
 #endif
 	}
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 4ba33dc..c0aec0a 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1566,30 +1566,31 @@ static inline struct txfcb *gfar_add_fcb(struct sk_buff *skb)
 }
 
 static inline void gfar_tx_checksum(struct sk_buff *skb, struct txfcb *fcb,
-								int fcb_length)
+				    int fcb_length)
 {
 	/* If we're here, it's a IP packet with a TCP or UDP
-	* payload.  We set it to checksum, using a pseudo-header
-	* we provide
-	*/
+	 * payload.  We set it to checksum, using a pseudo-header
+	 * we provide
+	 */
 	u8 flags = TXFCB_DEFAULT;
 
 	/* Tell the controller what the protocol is
-	* And provide the already calculated phcs
-	*/
+	 * And provide the already calculated phcs
+	 */
 	if (ip_hdr(skb)->protocol == IPPROTO_UDP) {
 		flags |= TXFCB_UDP;
-		fcb->phcs = udp_hdr(skb)->check;
+		fcb->phcs = (__force __be16)(udp_hdr(skb)->check);
 	} else
-		fcb->phcs = tcp_hdr(skb)->check;
+		fcb->phcs = (__force __be16)(tcp_hdr(skb)->check);
 
 	/* l3os is the distance between the start of the
-	* frame (skb->data) and the start of the IP hdr.
-	* l4os is the distance between the start of the
-	* l3 hdr and the l4 hdr
-	*/
-	fcb->l3os = (u16)(skb_network_offset(skb) - fcb_length);
+	 * frame (skb->data) and the start of the IP hdr.
+	 * l4os is the distance between the start of the
+	 * l3 hdr and the l4 hdr
+	 */
+	fcb->l3os = (u8)(skb_network_offset(skb) - fcb_length);
 	fcb->l4os = skb_network_header_len(skb);
+
 	fcb->flags = flags;
 }
 
@@ -1612,7 +1613,7 @@ static inline void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue,
 {
 	u32 lstatus;
 
-	bdp->bufPtr = buf;
+	bdp->bufPtr = cpu_to_be32(buf);
 
 	lstatus = BD_LFLAG(RXBD_EMPTY | RXBD_INTERRUPT);
 	if (bdp == rx_queue->rx_bd_base + rx_queue->rx_ring_size - 1)
@@ -1620,7 +1621,7 @@ static inline void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue,
 
 	eieio();
 
-	bdp->lstatus = lstatus;
+	bdp->lstatus = cpu_to_be32(lstatus);
 }
 
 static inline void gfar_new_rxbdp(struct gfar_priv_rx_q *rx_queue,
@@ -1678,7 +1679,8 @@ static inline void gfar_rx_checksum(struct sk_buff *skb, struct rxfcb *fcb)
 	 * were verified, then we tell the kernel that no
 	 * checksumming is necessary.  Otherwise, it is [FIXME]
 	 */
-	if ((fcb->flags & RXFCB_CSUM_MASK) == (RXFCB_CIP | RXFCB_CTU))
+	if ((be16_to_cpu(fcb->flags) & RXFCB_CSUM_MASK) ==
+	    (RXFCB_CIP | RXFCB_CTU))
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 	else
 		skb_checksum_none_assert(skb);
-- 
1.7.5.4

