From b65794ee8ede62d9f36f6301ed6677d488fcbded Mon Sep 17 00:00:00 2001
From: Jason Jin <Jason.Jin@freescale.com>
Date: Thu, 5 Jun 2014 20:18:50 +0800
Subject: [PATCH 191/255] spi:fsl-dspi: Add DSPI support for LS1021AQDS

Signed-off-by: Alison Wang <alison.wang@freescale.com>
Signed-off-by: Chao Fu <B44548@freescale.com>
Signed-off-by: Jason Jin <Jason.Jin@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/boot/dts/ls1021a-qds.dts |   6 +-
 drivers/spi/spi-fsl-dspi.c        | 245 ++++++++++++++------------------------
 2 files changed, 91 insertions(+), 160 deletions(-)

diff --git a/arch/arm/boot/dts/ls1021a-qds.dts b/arch/arm/boot/dts/ls1021a-qds.dts
index 14ccccf..1ec846f 100644
--- a/arch/arm/boot/dts/ls1021a-qds.dts
+++ b/arch/arm/boot/dts/ls1021a-qds.dts
@@ -116,14 +116,14 @@
 	};
 };
 
-&dspi1 {
+&dspi0 {
 	bus-num = <0>;
 	status = "okay";
 
-	dspiflash: s25fl064k@0 {
+	dspiflash: at45db021d@0 {
 		#address-cells = <1>;
 		#size-cells = <1>;
-		compatible = "spansion,s25fl064k";
+		compatible = "atmel,at45db021d", "atmel,at45", "atmel,dataflash";
 		spi-max-frequency = <16000000>;
 		spi-cpol;
 		spi-cpha;
diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c
index da56202..905521c 100644
--- a/drivers/spi/spi-fsl-dspi.c
+++ b/drivers/spi/spi-fsl-dspi.c
@@ -18,7 +18,6 @@
 #include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/platform_device.h>
-#include <linux/regmap.h>
 #include <linux/sched.h>
 #include <linux/delay.h>
 #include <linux/io.h>
@@ -109,11 +108,11 @@ struct fsl_dspi {
 	struct spi_bitbang	bitbang;
 	struct platform_device	*pdev;
 
-	struct regmap		*regmap;
+	void __iomem		*base;
 	int			irq;
-	struct clk		*clk;
+	struct clk 		*clk;
 
-	struct spi_transfer	*cur_transfer;
+	struct spi_transfer 	*cur_transfer;
 	struct chip_data	*cur_chip;
 	size_t			len;
 	void			*tx;
@@ -124,17 +123,24 @@ struct fsl_dspi {
 	u8			cs;
 	u16			void_write_data;
 
-	wait_queue_head_t	waitq;
-	u32			waitflags;
+	wait_queue_head_t 	waitq;
+	u32 			waitflags;
 };
 
 static inline int is_double_byte_mode(struct fsl_dspi *dspi)
 {
-	unsigned int val;
+	return ((ioread32be(dspi->base + SPI_CTAR(dspi->cs)) & SPI_FRAME_BITS_MASK)
+			== SPI_FRAME_BITS(8)) ? 0 : 1;
+}
 
-	regmap_read(dspi->regmap, SPI_CTAR(dspi->cs), &val);
+static void set_bit_mode(struct fsl_dspi *dspi, unsigned char bits)
+{
+	u32 temp;
 
-	return ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;
+	temp = ioread32be(dspi->base + SPI_CTAR(dspi->cs));
+	temp &= ~SPI_FRAME_BITS_MASK;
+	temp |= SPI_FRAME_BITS(bits);
+	iowrite32be(temp, dspi->base + SPI_CTAR(dspi->cs));
 }
 
 static void hz_to_spi_baud(char *pbr, char *br, int speed_hz,
@@ -148,7 +154,7 @@ static void hz_to_spi_baud(char *pbr, char *br, int speed_hz,
 		4096,	8192,	16384,	32768 };
 	int temp, i = 0, j = 0;
 
-	temp = clkrate / 2 / speed_hz;
+	temp = clkrate / speed_hz;
 
 	for (i = 0; i < ARRAY_SIZE(pbr_tbl); i++)
 		for (j = 0; j < ARRAY_SIZE(brs); j++) {
@@ -171,8 +177,9 @@ static int dspi_transfer_write(struct fsl_dspi *dspi)
 	int tx_word;
 	u16 d16;
 	u8  d8;
-	u32 dspi_pushr = 0;
+	volatile u32 dspi_pushr = 0;
 	int first = 1;
+	u32 sr, tmp, count;
 
 	tx_word = is_double_byte_mode(dspi);
 
@@ -182,100 +189,78 @@ static int dspi_transfer_write(struct fsl_dspi *dspi)
 	 */
 	if (tx_word && (dspi->len == 1)) {
 		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
-		regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
-				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));
+		set_bit_mode(dspi, 8);
 		tx_word = 0;
 	}
 
-	while (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {
-		if (tx_word) {
-			if (dspi->len == 1)
-				break;
-
-			if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
-				d16 = *(u16 *)dspi->tx;
-				dspi->tx += 2;
+	while(dspi->len != 0) {
+		while (dspi->len && (tx_count < DSPI_FIFO_SIZE)) {
+			if (tx_word) {
+				if (dspi->len == 1)
+					break;
+
+				if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
+					d16 = *(u16 *)dspi->tx;
+					dspi->tx += 2;
+				} else {
+					d16 = dspi->void_write_data;
+				}
+
+				dspi_pushr = SPI_PUSHR_TXDATA(d16) |
+					SPI_PUSHR_PCS(dspi->cs) |
+					SPI_PUSHR_CTAS(dspi->cs) |
+					SPI_PUSHR_CONT;
+
+				dspi->len -= 2;
 			} else {
-				d16 = dspi->void_write_data;
+				if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
+					d8 = *(u8 *)dspi->tx;
+					dspi->tx++;
+				} else {
+					d8 = (u8)dspi->void_write_data;
+				}
+
+				dspi_pushr = SPI_PUSHR_TXDATA(d8) |
+					SPI_PUSHR_PCS(dspi->cs) |
+					SPI_PUSHR_CTAS(dspi->cs) |
+					SPI_PUSHR_CONT;
+
+				dspi->len--;
 			}
 
-			dspi_pushr = SPI_PUSHR_TXDATA(d16) |
-				SPI_PUSHR_PCS(dspi->cs) |
-				SPI_PUSHR_CTAS(dspi->cs) |
-				SPI_PUSHR_CONT;
-
-			dspi->len -= 2;
-		} else {
-			if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
-
-				d8 = *(u8 *)dspi->tx;
-				dspi->tx++;
-			} else {
-				d8 = (u8)dspi->void_write_data;
+			if (first) {
+				first = 0;
+				dspi_pushr |= SPI_PUSHR_CTCNT; /* clear counter */
 			}
 
-			dspi_pushr = SPI_PUSHR_TXDATA(d8) |
-				SPI_PUSHR_PCS(dspi->cs) |
-				SPI_PUSHR_CTAS(dspi->cs) |
-				SPI_PUSHR_CONT;
-
-			dspi->len--;
+			iowrite32be(dspi_pushr, dspi->base + SPI_PUSHR);
+			udelay(20);
+			while ((ioread32be(dspi->base + SPI_SR) & 0x0000f000) != 0);
+			tx_count++;
 		}
 
-		if (dspi->len == 0 || tx_count == DSPI_FIFO_SIZE - 1) {
-			/* last transfer in the transfer */
-			dspi_pushr |= SPI_PUSHR_EOQ;
-		} else if (tx_word && (dspi->len == 1))
-			dspi_pushr |= SPI_PUSHR_EOQ;
-
-		if (first) {
-			first = 0;
-			dspi_pushr |= SPI_PUSHR_CTCNT; /* clear counter */
+		while (1) {
+			sr = ioread32be(dspi->base + SPI_SR);
+			count = (sr & 0x000000f0) >> 4;
+			while (count != 0) {
+				tmp = SPI_POPR_RXDATA(ioread32be(dspi->base + SPI_POPR));
+				count -= 1;
+				if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
+					*(u8 *)dspi->rx = tmp;
+				dspi->rx++;
+			}
+			iowrite32be(dspi->cur_chip->mcr_val | SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,
+				dspi->base + SPI_MCR);
+			break;
 		}
 
-		regmap_write(dspi->regmap, SPI_PUSHR, dspi_pushr);
-
-		tx_count++;
+		iowrite32be(SPI_SR_EOQF, dspi->base + SPI_SR);
+		tx_count = 0;
 	}
 
 	return tx_count * (tx_word + 1);
 }
 
-static int dspi_transfer_read(struct fsl_dspi *dspi)
-{
-	int rx_count = 0;
-	int rx_word = is_double_byte_mode(dspi);
-	u16 d;
-	while ((dspi->rx < dspi->rx_end)
-			&& (rx_count < DSPI_FIFO_SIZE)) {
-		if (rx_word) {
-			unsigned int val;
-
-			if ((dspi->rx_end - dspi->rx) == 1)
-				break;
-
-			regmap_read(dspi->regmap, SPI_POPR, &val);
-			d = SPI_POPR_RXDATA(val);
-
-			if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
-				*(u16 *)dspi->rx = d;
-			dspi->rx += 2;
-
-		} else {
-			unsigned int val;
-
-			regmap_read(dspi->regmap, SPI_POPR, &val);
-			d = SPI_POPR_RXDATA(val);
-			if (!(dspi->dataflags & TRAN_STATE_RX_VOID))
-				*(u8 *)dspi->rx = d;
-			dspi->rx++;
-		}
-		rx_count++;
-	}
-
-	return rx_count;
-}
-
 static int dspi_txrx_transfer(struct spi_device *spi, struct spi_transfer *t)
 {
 	struct fsl_dspi *dspi = spi_master_get_devdata(spi->master);
@@ -297,18 +282,16 @@ static int dspi_txrx_transfer(struct spi_device *spi, struct spi_transfer *t)
 	if (!dspi->tx)
 		dspi->dataflags |= TRAN_STATE_TX_VOID;
 
-	regmap_write(dspi->regmap, SPI_MCR, dspi->cur_chip->mcr_val);
-	regmap_write(dspi->regmap, SPI_CTAR(dspi->cs), dspi->cur_chip->ctar_val);
-	regmap_write(dspi->regmap, SPI_RSER, SPI_RSER_EOQFE);
+	iowrite32be(dspi->cur_chip->mcr_val, dspi->base + SPI_MCR);
+	iowrite32be(dspi->cur_chip->ctar_val, dspi->base + SPI_CTAR(dspi->cs));
+	iowrite32be(SPI_RSER_EOQFE, dspi->base + SPI_RSER);
 
 	if (t->speed_hz)
-		regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
-				dspi->cur_chip->ctar_val);
+		iowrite32be(dspi->cur_chip->ctar_val,
+				dspi->base + SPI_CTAR(dspi->cs));
 
 	dspi_transfer_write(dspi);
 
-	if (wait_event_interruptible(dspi->waitq, dspi->waitflags))
-		dev_err(&dspi->pdev->dev, "wait transfer complete fail!\n");
 	dspi->waitflags = 0;
 
 	return t->len - dspi->len;
@@ -317,20 +300,16 @@ static int dspi_txrx_transfer(struct spi_device *spi, struct spi_transfer *t)
 static void dspi_chipselect(struct spi_device *spi, int value)
 {
 	struct fsl_dspi *dspi = spi_master_get_devdata(spi->master);
-	unsigned int pushr;
-
-	regmap_read(dspi->regmap, SPI_PUSHR, &pushr);
+	u32 pushr = ioread32be(dspi->base + SPI_PUSHR);
 
 	switch (value) {
 	case BITBANG_CS_ACTIVE:
 		pushr |= SPI_PUSHR_CONT;
-		break;
 	case BITBANG_CS_INACTIVE:
 		pushr &= ~SPI_PUSHR_CONT;
-		break;
 	}
 
-	regmap_write(dspi->regmap, SPI_PUSHR, pushr);
+	iowrite32be(pushr, dspi->base + SPI_PUSHR);
 }
 
 static int dspi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
@@ -342,8 +321,7 @@ static int dspi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 	/* Only alloc on first setup */
 	chip = spi_get_ctldata(spi);
 	if (chip == NULL) {
-		chip = devm_kzalloc(&spi->dev, sizeof(struct chip_data),
-				    GFP_KERNEL);
+		chip = kcalloc(1, sizeof(struct chip_data), GFP_KERNEL);
 		if (!chip)
 			return -ENOMEM;
 	}
@@ -354,6 +332,7 @@ static int dspi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
 		fmsz = spi->bits_per_word - 1;
 	} else {
 		pr_err("Invalid wordsize\n");
+		kfree(chip);
 		return -ENODEV;
 	}
 
@@ -379,31 +358,10 @@ static int dspi_setup(struct spi_device *spi)
 	if (!spi->max_speed_hz)
 		return -EINVAL;
 
-	return dspi_setup_transfer(spi, NULL);
-}
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
 
-static irqreturn_t dspi_interrupt(int irq, void *dev_id)
-{
-	struct fsl_dspi *dspi = (struct fsl_dspi *)dev_id;
-
-	regmap_write(dspi->regmap, SPI_SR, SPI_SR_EOQF);
-
-	dspi_transfer_read(dspi);
-
-	if (!dspi->len) {
-		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)
-			regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
-				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(16));
-
-		dspi->waitflags = 1;
-		wake_up_interruptible(&dspi->waitq);
-	} else {
-		dspi_transfer_write(dspi);
-
-		return IRQ_HANDLED;
-	}
-
-	return IRQ_HANDLED;
+	return dspi_setup_transfer(spi, NULL);
 }
 
 static struct of_device_id fsl_dspi_dt_ids[] = {
@@ -440,20 +398,12 @@ static const struct dev_pm_ops dspi_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(dspi_suspend, dspi_resume)
 };
 
-static struct regmap_config dspi_regmap_config = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.reg_stride = 4,
-	.max_register = 0x88,
-};
-
 static int dspi_probe(struct platform_device *pdev)
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct spi_master *master;
 	struct fsl_dspi *dspi;
 	struct resource *res;
-	void __iomem *base;
 	int ret = 0, cs_num, bus_num;
 
 	master = spi_alloc_master(&pdev->dev, sizeof(struct fsl_dspi));
@@ -488,24 +438,12 @@ static int dspi_probe(struct platform_device *pdev)
 	master->bus_num = bus_num;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(base)) {
-		ret = PTR_ERR(base);
+	dspi->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dspi->base)) {
+		ret = PTR_ERR(dspi->base);
 		goto out_master_put;
 	}
 
-	dspi_regmap_config.lock_arg = dspi;
-	dspi_regmap_config.val_format_endian =
-		of_property_read_bool(np, "big-endian")
-			? REGMAP_ENDIAN_BIG : REGMAP_ENDIAN_DEFAULT;
-	dspi->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "dspi", base,
-						&dspi_regmap_config);
-	if (IS_ERR(dspi->regmap)) {
-		dev_err(&pdev->dev, "failed to init regmap: %ld\n",
-				PTR_ERR(dspi->regmap));
-		return PTR_ERR(dspi->regmap);
-	}
-
 	dspi->irq = platform_get_irq(pdev, 0);
 	if (dspi->irq < 0) {
 		dev_err(&pdev->dev, "can't get platform irq\n");
@@ -513,13 +451,6 @@ static int dspi_probe(struct platform_device *pdev)
 		goto out_master_put;
 	}
 
-	ret = devm_request_irq(&pdev->dev, dspi->irq, dspi_interrupt, 0,
-			pdev->name, dspi);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "Unable to attach DSPI interrupt\n");
-		goto out_master_put;
-	}
-
 	dspi->clk = devm_clk_get(&pdev->dev, "dspi");
 	if (IS_ERR(dspi->clk)) {
 		ret = PTR_ERR(dspi->clk);
-- 
2.0.2

