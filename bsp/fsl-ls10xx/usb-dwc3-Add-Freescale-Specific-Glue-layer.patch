From 90c312b96618067694dbed4a3b794578d11e116f Mon Sep 17 00:00:00 2001
From: Suresh Gupta <suresh.gupta@freescale.com>
Date: Mon, 2 Jun 2014 18:38:36 +0530
Subject: [PATCH 159/255] usb: dwc3: Add Freescale Specific Glue layer

New FSL SoCs ship with DesignWare Core USB3 IP inside

Signed-off-by: Suresh Gupta <suresh.gupta@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/usb/dwc3/Kconfig    |   7 ++
 drivers/usb/dwc3/Makefile   |   1 +
 drivers/usb/dwc3/dwc3-fsl.c | 174 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 182 insertions(+)
 create mode 100644 drivers/usb/dwc3/dwc3-fsl.c

diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index e2c730f..336d589 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -77,6 +77,13 @@ config USB_DWC3_KEYSTONE
 	  Support of USB2/3 functionality in TI Keystone2 platforms.
 	  Say 'Y' or 'M' here if you have one such device
 
+config USB_DWC3_FSL
+	tristate "Freescale Platform"
+	default USB_DWC3
+	help
+	  New FSL SoCs ship with DesignWare Core USB3 IP inside,
+	  say 'Y' or 'M' if you have one such device.
+
 comment "Debugging features"
 
 config USB_DWC3_DEBUG
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 10ac3e7..0b2fe41 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -33,3 +33,4 @@ obj-$(CONFIG_USB_DWC3_OMAP)		+= dwc3-omap.o
 obj-$(CONFIG_USB_DWC3_EXYNOS)		+= dwc3-exynos.o
 obj-$(CONFIG_USB_DWC3_PCI)		+= dwc3-pci.o
 obj-$(CONFIG_USB_DWC3_KEYSTONE)		+= dwc3-keystone.o
+obj-$(CONFIG_USB_DWC3_FSL)		+= dwc3-fsl.o
diff --git a/drivers/usb/dwc3/dwc3-fsl.c b/drivers/usb/dwc3/dwc3-fsl.c
new file mode 100644
index 0000000..f889c82
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-fsl.c
@@ -0,0 +1,174 @@
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+
+
+struct dwc3_fsl {
+	struct device		*dev;
+#ifdef USB_WRAPPER
+	void __iomem		*usbregs;
+	/* device lock */
+	spinlock_t		lock;
+#endif
+/*        struct clk                      *clk;*/
+};
+
+#if 0
+static u64 dwc3_fsl_dma_mask;
+#endif
+
+#ifdef USB_WRAPPER
+static inline u32 fsldwc3_readl(void __iomem *base, u32 offset)
+{
+	return readl(base + offset);
+}
+
+static inline void fsldwc3_writel(void __iomem *base, u32 offset, u32 value)
+{
+	writel(value, base + offset);
+}
+
+
+
+static irqreturn_t dwc3_fsl_interrupt(int irq, void *_fsldwc)
+{
+	struct dwc3_fsl		*fsldwc = _fsldwc;
+
+	return IRQ_HANDLED;
+}
+#endif
+
+static int fsldwc3_probe(struct platform_device *pdev)
+{
+	struct device		*dev = &pdev->dev;
+	struct device_node	*node = pdev->dev.of_node;
+	struct dwc3_fsl		*fsldwc;
+#ifdef USB_WRAPPER
+	struct resource         *res;
+	int			irq;
+#endif
+	int ret = 0;
+
+	printk(KERN_INFO "\n\n\n ############ %s ###########\n\n\n", __func__);
+
+	/* Do we need platform data for setup */
+		/* Will check and Add */
+
+	fsldwc = devm_kzalloc(dev, sizeof(*fsldwc), GFP_KERNEL);
+	if (!fsldwc)
+		return -ENOMEM;
+
+	/* Set it here for now, will take dynamic value in LS2 */
+	if (!dev->dma_mask)
+		dev->dma_mask = &dev->coherent_dma_mask;
+	if (!dev->coherent_dma_mask)
+		dev->coherent_dma_mask = DMA_BIT_MASK(32);
+
+#if 0
+	dwc3_fsl_dma_mask = DMA_BIT_MASK(32);
+	ret = dma_coerce_mask_and_coherent(dev, dwc3_fsl_dma_mask);
+	if (ret)
+		return ret;
+#endif
+
+	/* Set private data */
+	platform_set_drvdata(pdev, fsldwc);
+
+	fsldwc->dev = dev;
+
+#ifdef USB_WRAPPER
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "missing usbregs resource\n");
+		return -EINVAL;
+	}
+
+	fsldwc->usbregs = devm_ioremap_resource(dev, res);
+	if (IS_ERR(fsldwc->usbregs))
+		return PTR_ERR(fsldwc->usbdwc);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "missing irq\n");
+		return -EINVAL;
+	}
+
+	ret = devm_request_irq(dev, irq, dwc3_fsl_interrupt, IRQF_SHARED,
+				dev_name(dev), fsldwc);
+	if (ret) {
+		dev_err(dev, "failed to request IRQ #%d --> %d\n",
+				irq, ret);
+		return -EINVAL;
+	}
+
+	/*enable irqs if needed */
+
+#endif
+
+
+	if (node) {
+		/* Time to add DWC3 Core */
+		ret = of_platform_populate(node, NULL, NULL, dev);
+		if (ret) {
+			dev_err(dev, "failed to add dwc3 core\n");
+			return ret;
+		}
+	} else {
+		dev_err(dev, "no device node, failed to add dwc3 core\n");
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
+static int dwc3_fsl_remove_child(struct device *dev, void *unused)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	platform_device_unregister(pdev);
+
+	return 0;
+}
+
+
+static int fsldwc3_remove(struct platform_device *pdev)
+{
+	struct dwc3_fsl      *fsldwc = platform_get_drvdata(pdev);
+
+	/* clk disable */
+	/* Disable PHY */
+	device_for_each_child(&pdev->dev, NULL, dwc3_fsl_remove_child);
+
+	return 0;
+}
+
+
+
+
+static const struct of_device_id fsldwc3_of_match[] = {
+	{ .compatible = "fsl,fsl-dwc3", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, fsldwc3_of_match);
+
+static struct platform_driver fsldwc3_driver = {
+	.probe          = fsldwc3_probe,
+	.remove         = fsldwc3_remove,
+	.driver         = {
+		.name   = "fsl-dwc3",
+		.owner          = THIS_MODULE,
+		.of_match_table = fsldwc3_of_match,
+	},
+};
+
+module_platform_driver(fsldwc3_driver);
+
+MODULE_ALIAS("platform:fsl-dwc3");
+MODULE_AUTHOR("Suresh Gupta <suresh.gupta@freescale.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DesignWare USB3 Freescale Glue Layer");
-- 
2.0.2

