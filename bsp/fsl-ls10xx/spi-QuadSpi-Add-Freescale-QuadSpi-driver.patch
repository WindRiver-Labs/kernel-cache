From c696201d07397cb2d72aece2dae85b6d47d77001 Mon Sep 17 00:00:00 2001
From: Chao Fu <B44548@freescale.com>
Date: Mon, 24 Mar 2014 15:56:09 +0800
Subject: [PATCH 031/255] spi: QuadSpi: Add Freescale QuadSpi driver

Add QuadSpi driver for Freescale's Quad Spi controller.
This controller is designed for serial flash access.
This driver has only been tested with m25p80 type chips.
The hardware has no support for other types of spi peripherals.
Chip select control is handled via Serial Flash Address Register.

This driver supports the:
- non DMA based transfer via the IP Bus interface.
- registration through DT only.

Signed-off-by: Alison Wang <b18965@freescale.com>
Signed-off-by: Xiaochun Li <b41219@freescale.com>
Signed-off-by: Chao Fu <b44548@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/Kconfig           |   5 +
 drivers/spi/Makefile          |   1 +
 drivers/spi/spi-fsl-quadspi.c | 713 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 719 insertions(+)
 create mode 100644 drivers/spi/spi-fsl-quadspi.c

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index b040fae..84682bd 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -284,6 +284,11 @@ config SPI_FSL_ESPI
 	  From MPC8536, 85xx platform uses the controller, and all P10xx,
 	  P20xx, P30xx,P40xx, P50xx uses this controller.
 
+config SPI_FSL_QUADSPI
+        tristate "Freescale Quad SPI controller"
+	help
+	  This enables support for the Quad SPI controller in master mode.
+
 config SPI_OC_TINY
 	tristate "OpenCores tiny SPI"
 	depends on GPIOLIB
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 95af48d..8b485c8 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -37,6 +37,7 @@ obj-$(CONFIG_SPI_FSL_DSPI)		+= spi-fsl-dspi.o
 obj-$(CONFIG_SPI_FSL_LIB)		+= spi-fsl-lib.o
 obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
 obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
+obj-$(CONFIG_SPI_FSL_QUADSPI)		+= spi-fsl-quadspi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
diff --git a/drivers/spi/spi-fsl-quadspi.c b/drivers/spi/spi-fsl-quadspi.c
new file mode 100644
index 0000000..0027775
--- /dev/null
+++ b/drivers/spi/spi-fsl-quadspi.c
@@ -0,0 +1,713 @@
+/*
+ * Freescale Quad SPI driver.
+ *
+ * Copyright 2012-2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+#define	DRIVER_NAME "fsl-quadspi"
+
+/* Quad SPI Controller*/
+#define QSPI_MCR		0x00
+#define QSPI_IPCR		0x08
+#define QSPI_BFGENCR		0x20
+#define QSPI_SFAR		0x100
+#define QSPI_SMPR		0x108
+#define QSPI_RBSR		0x10c
+#define QSPI_RBCT		0x110
+#define QSPI_TBSR		0x150
+#define QSPI_TBDR		0x154
+#define QSPI_SR			0x15c
+#define QSPI_FR			0x160
+#define QSPI_SFA1AD		0x180
+#define QSPI_SFA2AD		0x184
+#define QSPI_SFB1AD		0x188
+#define QSPI_SFB2AD		0x18c
+#define QSPI_RBDR		0x200
+#define QSPI_LUTKEY		0x300
+#define QSPI_LCKCR		0x304
+#define QSPI_RSER		0x164
+#define KEY_VALUE		0x5AF05AF0
+#define QSPI_LUT(x)		(0x310 + (x) * 4)
+
+#define INT_TFIE		(0x1 << 0)
+#define TPADA			(0x1 << 24)
+#define TPADB			(0x1 << 25)
+
+/* Field definitions for LCKCR */
+#define QSPI_LCKCR_LOCK		1
+#define QSPI_LCKCR_UNLOCK	2
+
+/* Field definitions for RBSR */
+#define QSPI_RBSR_RDBFL_SHIFT	8
+#define QSPI_RBSR_RDBFL_MASK	(0x3F << QSPI_RBSR_RDBFL_SHIFT)
+
+/* Field definitions for RBCT */
+#define QSPI_RBCT_WMRK_MASK	0x1F
+#define QSPI_RBCT_RXBRD_SHIFT	8
+#define QSPI_RBCT_RXBRD_USEIPS	(0x1 << QSPI_RBCT_RXBRD_SHIFT)
+
+/* Field definitions for MCR */
+#define QSPI_MCR_MDIS_SHIFT	14
+#define QSPI_MCR_MDIS_MASK	(1 << QSPI_MCR_MDIS_SHIFT)
+#define QSPI_MCR_CLR_TXF_SHIFT	11
+#define QSPI_MCR_CLR_TXF_MASK	(1 << QSPI_MCR_CLR_TXF_SHIFT)
+#define QSPI_MCR_CLR_RXF_SHIFT	10
+#define QSPI_MCR_CLR_RXF_MASK	(1 << QSPI_MCR_CLR_RXF_SHIFT)
+#define QSPI_MCR_DDR_EN_SHIFT	7
+#define QSPI_MCR_DDR_EN_MASK	(1 << QSPI_MCR_DDR_EN_SHIFT)
+#define QSPI_MCR_RESERVED_SHIFT	16
+#define QSPI_MCR_RESERVED_MASK  (0xF << QSPI_MCR_RESERVED_SHIFT)
+
+/* Field definitions for SMPR */
+#define QSPI_SMPR_DDRSMP_SHIFT		16
+#define QSPI_SMPR_DDRSMP_MASK		(7 << QSPI_SMPR_DDRSMP_SHIFT)
+#define QSPI_SMPR_FSDLY_SHIFT		6
+#define QSPI_SMPR_FSDLY_MASK		(1 << QSPI_SMPR_FSDLY_SHIFT)
+#define QSPI_SMPR_FSPHS_SHIFT		5
+#define QSPI_SMPR_FSPHS_MASK		(1 << QSPI_SMPR_FSPHS_SHIFT)
+#define QSPI_SMPR_HSENA_SHIFT		0
+#define QSPI_SMPR_HSENA_MASK		(1 << QSPI_SMPR_HSENA_SHIFT)
+
+/* Field definitions for BFGENCR */
+#define QSPI_BFGENCR_PAR_EN_SHIFT	(16)
+#define QSPI_BFGENCR_PAR_EN_MASK	(1 << (QSPI_BFGENCR_PAR_EN_SHIFT))
+#define QSPI_BFGENCR_SEQID_SHIFT	(12)
+#define QSPI_BFGENCR_SEQID_MASK		(0xF << QSPI_BFGENCR_SEQID_SHIFT)
+
+/* Field definitions for SR */
+#define QSPI_SR_TXFULL_SHIFT		27
+#define QSPI_SR_TXFULL_MASK		(1 << QSPI_SR_TXFULL_SHIFT)
+#define QSPI_SR_AHBTRN_SHIFT		6
+#define QSPI_SR_AHBTRN_MASK		(1 << QSPI_SR_AHBTRN_SHIFT)
+#define QSPI_SR_AHB_ACC_SHIFT		2
+#define QSPI_SR_AHB_ACC_MASK		(1 << QSPI_SR_AHB_ACC_SHIFT)
+#define QSPI_SR_IP_ACC_SHIFT		1
+#define QSPI_SR_IP_ACC_MASK		(1 << QSPI_SR_IP_ACC_SHIFT)
+#define QSPI_SR_BUSY_SHIFT		0
+#define QSPI_SR_BUSY_MASK		(1 << QSPI_SR_BUSY_SHIFT)
+
+/* Field definitions for FR */
+#define QSPI_FR_TFF_MASK		1
+
+/* Seqid */
+#define WRTEN_SEQID			1
+#define READSTATU_SEQID			3
+#define RDID_SEQID			6
+#define SERE_SEQID			7
+#define TX_SEQID			8
+#define RX_SEQID			9
+
+/* Field definitions for IPCR */
+#define QSPI_IPCR_SEQID_SHIFT	24
+#define QSPI_IPCR_SEQID_MASK	(0xF << QSPI_IPCR_SEQID_SHIFT)
+#define OPRND0_SHIFT		0
+#define OPRND0(x)		((x) << (OPRND0_SHIFT))
+#define PAD0_SHIFT		8
+#define PAD0(x)			((x) << (PAD0_SHIFT))
+#define INSTR0_SHIFT		10
+#define INSTR0(x)		((x) << (INSTR0_SHIFT))
+#define OPRND1_SHIFT		16
+#define OPRND1(x)		((x) << (OPRND1_SHIFT))
+#define PAD1_SHIFT		24
+#define PAD1(x)			((x) << (PAD1_SHIFT))
+#define INSTR1_SHIFT		26
+#define INSTR1(x)		((x) << (INSTR1_SHIFT))
+
+/* instruction set */
+#define CMD			1
+#define ADDR			2
+#define ADDR24BIT		0x18
+#define DUMMY			3
+#define MODE			4
+#define MODE2			5
+#define MODE4			6
+#define READ			7
+#define WRITE			8
+#define JMP_ON_CS		9
+#define ADDR_DDR		10
+#define MODE_DDR		11
+#define MODE2_DDR		12
+#define MODE4_DDR		13
+
+#define PSP_QSPI0_MEMMAP_BASE	0x20000000
+#define RX_BUFFER_SIZE		0x80
+#define TX_BUFFER_SIZE		0x40
+#define POS_LOCATION_MASK	0xFFFFFF00
+#define STATUS_BIT		24
+#define VALID_STATUS_BIT	0
+#define READ_STATUS_TIMEOUT	5000
+#define WRITE_ENABLE_BIT	25
+#define VALID_WRITE_ENABLE_BIT	1
+#define WRITE_ENABLE_TIMEOUT	10
+#define DEFALUT_SIZE		1
+
+/* Flash opcodes. */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+
+#define	FLASHSR_WIP		1	/* Write in progress */
+
+struct fsl_qspi {
+	void __iomem *iobase;
+	struct clk *clk;
+
+	u32 select_cs;
+	struct device *dev;
+
+	struct timer_list wait_timer;
+	bool timeout;
+
+	wait_queue_head_t waitr;
+	wait_queue_head_t waitt;
+	u32 waitflag_r;
+	u32 waitflag_t;
+
+};
+
+static inline unsigned int fsl_qspi_is_busy(struct fsl_qspi *fsl_qspi)
+{
+	return readl(fsl_qspi->iobase + QSPI_SR) & QSPI_SR_BUSY_MASK;
+}
+
+static void fsl_qspi_wait_do_timer(unsigned long arg)
+{
+	struct fsl_qspi *fsl_qspi = (struct fsl_qspi *)(arg);
+	fsl_qspi->timeout = true;
+}
+
+static irqreturn_t fsl_qspi_irq_handler(int this_irq, void *dev_id)
+{
+	struct fsl_qspi *fsl_qspi = dev_id;
+	u32 reg_fr = readl(fsl_qspi->iobase + QSPI_FR);
+
+	/* clear interrupt */
+	writel(reg_fr, fsl_qspi->iobase + QSPI_FR);
+	if (reg_fr & QSPI_FR_TFF_MASK) {
+		if (fsl_qspi->waitflag_r) {
+			fsl_qspi->waitflag_r = 0;
+			wake_up(&fsl_qspi->waitr);
+			return IRQ_HANDLED;
+		}
+		if (fsl_qspi->waitflag_t) {
+			fsl_qspi->waitflag_t = 0;
+			wake_up(&fsl_qspi->waitt);
+			return IRQ_HANDLED;
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static void fsl_qspi_set_lut(struct fsl_qspi *fsl_qspi)
+{
+	u32 lut_base;
+
+	/* Unlock the LUT */
+	writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+	writel(QSPI_LCKCR_UNLOCK, fsl_qspi->iobase + QSPI_LCKCR);
+
+	/* SEQID  - Write enable */
+	lut_base = WRTEN_SEQID * 4;
+	writel(OPRND0(OPCODE_WREN) | PAD0(0x0) | INSTR0(CMD),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* SEQID  - Read Status */
+	lut_base = READSTATU_SEQID * 4;
+	writel(OPRND0(OPCODE_RDSR) | PAD0(0x0) | INSTR0(CMD) |
+			OPRND1(0x1) | PAD1(0x0) | INSTR1(READ),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* SEQID  - Read Flash ID */
+	lut_base = RDID_SEQID * 4;
+	writel(OPRND0(OPCODE_RDID) | PAD0(0x0) | INSTR0(CMD) |
+			OPRND1(0x5) | PAD1(0x0) | INSTR1(READ),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* SEQID  - Recevie transfer */
+	lut_base = RX_SEQID * 4;
+	writel(OPRND0(OPCODE_NORM_READ) | PAD0(0x0) | INSTR0(CMD) |
+			  OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	writel(OPRND0(RX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(READ),
+			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* SEQID  - Send Transfer */
+	lut_base = TX_SEQID * 4;
+	writel(OPRND0(OPCODE_PP) | PAD0(0x0) | INSTR0(CMD)
+			 | OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	writel(OPRND0(TX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(WRITE),
+			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* Lock the LUT */
+	writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+	writel(QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
+}
+
+static void waiting_flash_ready(struct fsl_qspi *fsl_qspi,
+		u32 wait_bit)
+{
+	u32 reg, status_reg, count = 0;
+
+	fsl_qspi->timeout = false;
+	fsl_qspi->wait_timer.expires = jiffies + 10;/*time out is 10s*/
+	add_timer(&fsl_qspi->wait_timer);
+
+	status_reg = wait_bit;
+	while (status_reg & wait_bit) {
+		if (fsl_qspi->timeout) {
+			dev_err(fsl_qspi->dev, "tired waiting for end status\n");
+			break;
+		}
+		writel((READSTATU_SEQID << QSPI_IPCR_SEQID_SHIFT)
+				| DEFALUT_SIZE, fsl_qspi->iobase + QSPI_IPCR);
+		fsl_qspi->waitflag_t = 1;
+		wait_event(fsl_qspi->waitt, !fsl_qspi->waitflag_t);
+
+		reg = readl(fsl_qspi->iobase + QSPI_RBSR);
+		if (reg & QSPI_RBSR_RDBFL_MASK)
+			status_reg = readl(fsl_qspi->iobase +
+					QSPI_RBDR);
+
+		writel(readl(fsl_qspi->iobase + QSPI_MCR) |
+				QSPI_MCR_CLR_RXF_MASK,
+				fsl_qspi->iobase + QSPI_MCR);
+		count++;
+	}
+	del_timer(&fsl_qspi->wait_timer);
+}
+
+static void set_lut(struct fsl_qspi *fsl_qspi, u8 opr, u8 *seqid)
+{
+	switch (opr) {
+	case OPCODE_RDID:
+		*seqid = RDID_SEQID;
+		break;
+	case OPCODE_RDSR:
+		*seqid = READSTATU_SEQID;
+		break;
+	case OPCODE_NORM_READ:
+		*seqid = RX_SEQID;
+		break;
+	case OPCODE_WREN:
+		 *seqid = WRTEN_SEQID;
+		 break;
+	case OPCODE_PP:
+		*seqid = TX_SEQID;
+		break;
+	case OPCODE_SE:
+	case OPCODE_BE_4K:
+	case OPCODE_BE_32K: {
+		u32 lut[4] = {0}, lut_base;
+		lut[0] = OPRND0(opr) | PAD0(0x0) | INSTR0(CMD)
+			| OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR);
+		lut_base = SERE_SEQID * 4;
+		*seqid = SERE_SEQID;
+		writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+		writel(QSPI_LCKCR_UNLOCK, fsl_qspi->iobase + QSPI_LCKCR);
+		writel(lut[0], fsl_qspi->iobase + QSPI_LUT(lut_base));
+		writel(lut[1], fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+		writel(lut[2], fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+		writel(lut[3], fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+		writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+		writel(QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
+		break;
+	}
+	default:
+		dev_err(fsl_qspi->dev, "can't surport opr %x\n", opr);
+		break;
+
+	}
+}
+
+static void fsl_qspi_do_rx(struct fsl_qspi *fsl_qspi, u32 position,
+		u32 count, u32 *rxbuf)
+{
+	u32 tmp, i, size;
+
+	position += PSP_QSPI0_MEMMAP_BASE;
+	while (count > 0) {
+		writel(position, fsl_qspi->iobase + QSPI_SFAR);
+		size = (count > RX_BUFFER_SIZE) ?
+			RX_BUFFER_SIZE : count;
+
+		writel(RX_SEQID << QSPI_IPCR_SEQID_SHIFT | size,
+				fsl_qspi->iobase + QSPI_IPCR);
+		fsl_qspi->waitflag_r = 1;
+		wait_event(fsl_qspi->waitr, !fsl_qspi->waitflag_r);
+
+		position += size;
+		count -= size;
+
+		i = 0;
+		while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
+			tmp = readl(fsl_qspi->iobase + QSPI_RBDR +
+					i * 4);
+			*rxbuf = cpu_to_be32(tmp);
+			rxbuf++;
+			size -= 4;
+			i++;
+		}
+
+		writel(readl(fsl_qspi->iobase + QSPI_MCR) |
+				QSPI_MCR_CLR_RXF_MASK,
+				fsl_qspi->iobase + QSPI_MCR);
+	}
+
+}
+
+static void fsl_qspi_do_tx(struct fsl_qspi *fsl_qspi,
+		u32 position, u32 count, const u32 *txbuf)
+{
+	u32 tmp, i, j, size, tx_size;
+
+	position += PSP_QSPI0_MEMMAP_BASE;
+
+	while (count > 0) {
+		writel(position, fsl_qspi->iobase + QSPI_SFAR);
+		writel((WRTEN_SEQID << QSPI_IPCR_SEQID_SHIFT) | 0,
+				fsl_qspi->iobase + QSPI_IPCR);
+
+		tx_size = (count > TX_BUFFER_SIZE) ?
+			TX_BUFFER_SIZE : count;
+
+		position += tx_size;
+		count -= tx_size;
+
+		size = (tx_size + 3) / 4;
+		i = (size > 16) ? 16 : size;
+		for (j = 0; j < i; j++) {
+			tmp = cpu_to_be32(*txbuf);
+			writel(tmp, fsl_qspi->iobase + QSPI_TBDR);
+			txbuf++;
+		}
+
+		writel(TX_SEQID << QSPI_IPCR_SEQID_SHIFT | tx_size,
+				fsl_qspi->iobase + QSPI_IPCR);
+		waiting_flash_ready(fsl_qspi, cpu_to_be32(FLASHSR_WIP));
+
+		for (j = i; j < size; j++) {
+			tmp = cpu_to_be32(*txbuf);
+			writel(tmp, fsl_qspi->iobase + QSPI_TBDR);
+			txbuf++;
+		}
+
+		waiting_flash_ready(fsl_qspi, cpu_to_be32(FLASHSR_WIP));
+	}
+}
+
+static void fsl_qspi_do_tx_cmd(struct fsl_qspi *fsl_qspi,
+		u32 position, u8 seqid)
+{
+	position += PSP_QSPI0_MEMMAP_BASE;
+	writel(position, fsl_qspi->iobase + QSPI_SFAR);
+	writel((seqid << QSPI_IPCR_SEQID_SHIFT) | 0,
+			fsl_qspi->iobase + QSPI_IPCR);
+
+	fsl_qspi->waitflag_t = 1;
+	wait_event(fsl_qspi->waitt, !fsl_qspi->waitflag_t);
+}
+
+static int fsl_qspi_do_one_msg(struct spi_master *master,
+		struct spi_message *m)
+{
+	struct spi_transfer *t;
+	unsigned int xfer_num = 0;
+	int status = 0;
+	u8 opr = 0 , seqid = 0;
+	loff_t pos = 0;
+	u32 mcr_reg = 0;
+	struct fsl_qspi *fsl_qspi = spi_master_get_devdata(master);
+
+	writel(INT_TFIE, fsl_qspi->iobase + QSPI_RSER);
+	mcr_reg = readl(fsl_qspi->iobase + QSPI_MCR);
+	writel(QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+			QSPI_MCR_RESERVED_MASK,
+			fsl_qspi->iobase + QSPI_MCR);
+	writel(QSPI_RBCT_WMRK_MASK | QSPI_RBCT_RXBRD_USEIPS,
+			fsl_qspi->iobase + QSPI_RBCT);
+
+	list_for_each_entry(t, &m->transfers, transfer_list) {
+		if (xfer_num == 0) {
+			opr = *(u8 *)t->tx_buf;
+			if (t->len > 1)
+				pos = *(u32 *)t->tx_buf & POS_LOCATION_MASK;
+			else
+				pos = 0;
+			set_lut(fsl_qspi, opr, &seqid);
+		}
+
+		if (t->tx_buf) {
+			if (xfer_num == 0) {
+				if (seqid != TX_SEQID && seqid != RX_SEQID)
+					fsl_qspi_do_tx_cmd(fsl_qspi,
+						cpu_to_be32(pos), seqid);
+			} else {
+				fsl_qspi_do_tx(fsl_qspi, cpu_to_be32(pos),
+					t->len, t->tx_buf);
+			}
+		}
+
+		if (t->rx_buf) {
+			fsl_qspi_do_rx(fsl_qspi, cpu_to_be32(pos),
+					t->len, t->rx_buf);
+		}
+
+		m->actual_length += t->len;
+		xfer_num++;
+
+		if (t->delay_usecs)
+			udelay(t->delay_usecs);
+
+	}
+
+	writel(mcr_reg, fsl_qspi->iobase + QSPI_MCR);
+
+	m->status = status;
+	spi_finalize_current_message(master);
+
+	return m->status;
+}
+
+static int fsl_qspi_setup(struct spi_device *spi)
+{
+	u32 reg_val, smpr_val, seq_id;
+	struct fsl_qspi *fsl_qspi;
+
+	fsl_qspi = spi_master_get_devdata(spi->master);
+
+	if ((spi->bits_per_word < 8) || (spi->bits_per_word > 16)) {
+		dev_err(&spi->dev, "%d bits per word is not supported\n",
+				spi->bits_per_word);
+		return -EINVAL;
+	}
+
+	if (spi->chip_select >= spi->master->num_chipselect) {
+		dev_err(&spi->dev, "%d chip select is out of range\n",
+				spi->chip_select);
+		return -EINVAL;
+	}
+
+	writel(QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK,
+			fsl_qspi->iobase + QSPI_MCR);
+
+	reg_val = readl(fsl_qspi->iobase + QSPI_SMPR);
+
+	writel(reg_val & ~(QSPI_SMPR_FSDLY_MASK
+				| QSPI_SMPR_FSPHS_MASK
+				| QSPI_SMPR_HSENA_MASK),
+			fsl_qspi->iobase + QSPI_SMPR);
+
+	writel(QSPI_MCR_RESERVED_MASK, fsl_qspi->iobase + QSPI_MCR);
+
+	writel(TPADA | PSP_QSPI0_MEMMAP_BASE,
+			fsl_qspi->iobase + QSPI_SFA1AD);
+	writel(TPADA | PSP_QSPI0_MEMMAP_BASE,
+			fsl_qspi->iobase + QSPI_SFA2AD);
+	writel(TPADB | PSP_QSPI0_MEMMAP_BASE,
+			fsl_qspi->iobase + QSPI_SFB1AD);
+	writel(TPADB | PSP_QSPI0_MEMMAP_BASE,
+			fsl_qspi->iobase + QSPI_SFB2AD);
+
+	fsl_qspi_set_lut(fsl_qspi);
+
+	reg_val = 0;
+	reg_val |= QSPI_MCR_RESERVED_MASK;
+	smpr_val = readl(fsl_qspi->iobase + QSPI_SMPR);
+	smpr_val &= ~QSPI_SMPR_DDRSMP_MASK;
+	writel(smpr_val, fsl_qspi->iobase + QSPI_SMPR);
+	reg_val &= ~QSPI_MCR_DDR_EN_MASK;
+	writel(reg_val, fsl_qspi->iobase + QSPI_MCR);
+
+	seq_id = 0;
+	reg_val = readl(fsl_qspi->iobase + QSPI_BFGENCR);
+	reg_val &= ~QSPI_BFGENCR_SEQID_MASK;
+	reg_val |= (seq_id << QSPI_BFGENCR_SEQID_SHIFT);
+	reg_val &= ~QSPI_BFGENCR_PAR_EN_MASK;
+	writel(reg_val, fsl_qspi->iobase + QSPI_BFGENCR);
+
+	return 0;
+}
+
+static int fsl_qspi_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct spi_master *master;
+	struct fsl_qspi *fsl_qspi;
+	struct resource *res;
+	int ret, irq;
+	struct clk *gate;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*fsl_qspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "spi_alloc_master failed\n");
+		return -ENOMEM;
+	}
+
+	ret = of_property_read_u32(np, "fsl,spi-num-chipselects",
+			(u32 *)&master->num_chipselect);
+
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi-num-chipselects property not found\n");
+		goto out_master_put;
+	}
+
+	fsl_qspi = spi_master_get_devdata(master);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "could not get memory resource\n");
+		ret = -ENODEV;
+		goto out_master_put;
+	}
+
+	fsl_qspi->iobase = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(fsl_qspi->iobase)) {
+		ret = PTR_ERR(fsl_qspi->iobase);
+		goto out_master_put;
+	}
+
+	gate = devm_clk_get(&pdev->dev, "qspi_en");
+	if (IS_ERR(gate)) {
+		ret = PTR_ERR(gate);
+		dev_err(&pdev->dev, "could not get parent clk: %d\n", ret);
+		goto out_master_put;
+	}
+
+	fsl_qspi->clk = devm_clk_get(&pdev->dev, "qspi");
+	if (IS_ERR(fsl_qspi->clk)) {
+		ret = PTR_ERR(fsl_qspi->clk);
+		dev_err(&pdev->dev, "could not get clk: %d\n", ret);
+		goto out_master_put;
+	}
+
+	clk_prepare_enable(gate);
+	clk_prepare_enable(fsl_qspi->clk);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "could not get IRQ: %d\n", irq);
+		ret = irq;
+		goto out_clk_disable;
+	}
+
+	ret = devm_request_irq(&pdev->dev, irq,
+			fsl_qspi_irq_handler, 0, pdev->name, fsl_qspi);
+	if (ret) {
+		dev_err(&pdev->dev, "could not request IRQ: %d\n", ret);
+		goto out_clk_disable;
+	}
+
+	init_timer(&fsl_qspi->wait_timer);
+	fsl_qspi->wait_timer.function = &fsl_qspi_wait_do_timer;
+	fsl_qspi->wait_timer.data = (unsigned long)fsl_qspi;
+
+	init_waitqueue_head(&fsl_qspi->waitr);
+	init_waitqueue_head(&fsl_qspi->waitt);
+	fsl_qspi->waitflag_r = 0;
+	fsl_qspi->waitflag_t = 0;
+
+	fsl_qspi->dev = &pdev->dev;
+
+	master->bus_num = pdev->id;
+	master->dev.of_node = pdev->dev.of_node;
+
+	master->setup = fsl_qspi_setup;
+	master->transfer_one_message = fsl_qspi_do_one_msg;
+	platform_set_drvdata(pdev, master);
+
+	ret = spi_register_master(master);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"could not register FSL QuadSPI master: %d\n", ret);
+		goto out_free_irq;
+	}
+	dev_info(&pdev->dev, "FSL QuadSPI bus driver\n");
+
+	return 0;
+
+out_free_irq:
+	free_irq(irq, master);
+out_clk_disable:
+	clk_disable_unprepare(fsl_qspi->clk);
+out_master_put:
+	spi_master_put(master);
+
+	return ret;
+}
+
+static int fsl_qspi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct fsl_qspi *fsl_qspi = spi_master_get_devdata(master);
+
+	/* disable the hardware */
+	writel(0x0, fsl_qspi->iobase + QSPI_MCR);
+	writel(0x0, fsl_qspi->iobase + QSPI_RSER);
+
+	clk_disable_unprepare(fsl_qspi->clk);
+	spi_master_put(master);
+
+	return 0;
+}
+
+static struct of_device_id fsl_qspi_dt_ids[] = {
+	{ .compatible = "fsl,vf610-qspi", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, fsl_qspi_dt_ids);
+
+static struct platform_driver fsl_qspi_driver = {
+	.driver.name    = DRIVER_NAME,
+	.driver.of_match_table = fsl_qspi_dt_ids,
+	.driver.owner   = THIS_MODULE,
+	.probe          = fsl_qspi_probe,
+	.remove		= fsl_qspi_remove,
+};
+module_platform_driver(fsl_qspi_driver);
+
+MODULE_DESCRIPTION("FSL QuadSPI Controller Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
-- 
2.0.2

