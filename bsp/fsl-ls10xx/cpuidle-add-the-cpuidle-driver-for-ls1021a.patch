From 4345827c12d14984d62b84ecfb9be4261d386be9 Mon Sep 17 00:00:00 2001
From: Chenhui Zhao <chenhui.zhao@freescale.com>
Date: Wed, 4 Jun 2014 18:46:05 +0800
Subject: [PATCH 188/255] cpuidle: add the cpuidle driver for ls1021a

The cpuidle driver supports two states: doze (Wait State) and nap
(Cluster Stop Mode).

To enable this driver, select the option CONFIG_ARM_LS1_CPUIDLE.

Signed-off-by: Chenhui Zhao <chenhui.zhao@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/boot/dts/ls1021a.dtsi |   2 +-
 drivers/cpuidle/Kconfig.arm    |   6 +++
 drivers/cpuidle/Makefile       |   1 +
 drivers/cpuidle/cpuidle-ls1.c  | 101 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 109 insertions(+), 1 deletion(-)
 create mode 100644 drivers/cpuidle/cpuidle-ls1.c

diff --git a/arch/arm/boot/dts/ls1021a.dtsi b/arch/arm/boot/dts/ls1021a.dtsi
index f3ddb90..17a3857 100644
--- a/arch/arm/boot/dts/ls1021a.dtsi
+++ b/arch/arm/boot/dts/ls1021a.dtsi
@@ -244,8 +244,8 @@
 		};
 
 		rcpm: rcpm@1ee2000 {
+			compatible = "fsl,ls1021a-rcpm", "fsl,qoriq-rcpm-2.1";
 			reg = <0x0 0x1ee2000 0x0 0x10000>;
-			status = "disabled";
 		};
 
 		dspi0: dspi@2100000 {
diff --git a/drivers/cpuidle/Kconfig.arm b/drivers/cpuidle/Kconfig.arm
index d988948..45727cc 100644
--- a/drivers/cpuidle/Kconfig.arm
+++ b/drivers/cpuidle/Kconfig.arm
@@ -44,3 +44,9 @@ config ARM_AT91_CPUIDLE
 	depends on ARCH_AT91
 	help
 	  Select this to enable cpuidle for AT91 processors
+
+config ARM_LS1_CPUIDLE
+	bool "CPU Idle Driver for Freescale LS1"
+	depends on ARCH_LAYERSCAPE
+	help
+	  Select this option to enable cpuidle on Freescale LS1 SoCs.
diff --git a/drivers/cpuidle/Makefile b/drivers/cpuidle/Makefile
index f71ae1b..de792a4 100644
--- a/drivers/cpuidle/Makefile
+++ b/drivers/cpuidle/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_ARM_KIRKWOOD_CPUIDLE)	+= cpuidle-kirkwood.o
 obj-$(CONFIG_ARM_ZYNQ_CPUIDLE)		+= cpuidle-zynq.o
 obj-$(CONFIG_ARM_U8500_CPUIDLE)         += cpuidle-ux500.o
 obj-$(CONFIG_ARM_AT91_CPUIDLE)          += cpuidle-at91.o
+obj-$(CONFIG_ARM_LS1_CPUIDLE)		+= cpuidle-ls1.o
 
 ###############################################################################
 # POWERPC drivers
diff --git a/drivers/cpuidle/cpuidle-ls1.c b/drivers/cpuidle/cpuidle-ls1.c
new file mode 100644
index 0000000..8d126b4b
--- /dev/null
+++ b/drivers/cpuidle/cpuidle-ls1.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2014 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/cpuidle.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/cpuidle.h>
+#include <asm/proc-fns.h>
+
+#define LS1_CPUIDLE_MAX_STATES	2
+
+#define CCSR_CLPCL10SR		0x1c0
+#define CCSR_CLPCL10SETR	0x1c4
+
+static void __iomem *ls1_rcpm_base;
+static atomic_t master = ATOMIC_INIT(0);
+static DEFINE_SPINLOCK(master_lock);
+
+static void ls1_request_cluster_stop(int index)
+{
+	setbits32(ls1_rcpm_base + CCSR_CLPCL10SETR, 1 << index);
+}
+
+static void ls1_clear_cluster_stop(int index)
+{
+	clrbits32(ls1_rcpm_base + CCSR_CLPCL10SETR, 1 << index);
+}
+
+static int ls1_enter_cluster_stop(struct cpuidle_device *dev,
+				  struct cpuidle_driver *drv, int index)
+{
+	if ((atomic_inc_return(&master) == num_online_cpus()) &&
+	    spin_trylock(&master_lock)) {
+		/* LS1 only has one cluster */
+		ls1_request_cluster_stop(0);
+		cpu_do_idle();
+		ls1_clear_cluster_stop(0);
+		spin_unlock(&master_lock);
+	} else {
+		cpu_do_idle();
+	}
+
+	atomic_dec(&master);
+	return index;
+}
+
+static struct cpuidle_driver ls1_cpuidle_driver = {
+	.name = "ls1_cpuidle",
+	.owner = THIS_MODULE,
+	.states = {
+		/* doze: Wait State */
+		{
+			.exit_latency = 1,
+			.target_residency = 1,
+			.flags = CPUIDLE_FLAG_TIME_VALID,
+			.enter = arm_cpuidle_simple_enter,
+			.name = "doze",
+			.desc = "Wait State",
+
+		},
+		/* nap: Cluster Stop Mode */
+		{
+			.exit_latency = 50,
+			.target_residency = 75,
+			.flags = CPUIDLE_FLAG_TIME_VALID |
+				 CPUIDLE_FLAG_TIMER_STOP,
+			.enter = ls1_enter_cluster_stop,
+			.name = "nap",
+			.desc = "Cluster Stop Mode",
+		},
+	},
+	.state_count = LS1_CPUIDLE_MAX_STATES,
+	.safe_state_index = 0,
+};
+
+static int __init ls1_cpuidle_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,qoriq-rcpm-2.1");
+	if (!np) {
+		pr_err("%s(): Can not find the RCPM node.\n", __func__);
+		return -ENODEV;
+	}
+
+	ls1_rcpm_base = of_iomap(np, 0);
+	of_node_put(np);
+	WARN_ON(!ls1_rcpm_base);
+
+	return cpuidle_register(&ls1_cpuidle_driver, NULL);
+}
+
+device_initcall(ls1_cpuidle_init);
-- 
2.0.2

