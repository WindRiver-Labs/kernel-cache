From 8d35b4c54362fc3152f2d43d6c8cc15024abd48a Mon Sep 17 00:00:00 2001
From: Xiubo Li <Li.Xiubo@freescale.com>
Date: Mon, 13 Oct 2014 12:03:06 +0800
Subject: [PATCH 110/129] fb: dcu: add Power Management support.

Add PM support for DCU driver using callback function suspend
and resume in .driver.pm of platform_driver.

Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>

--
The first DRM version will be send out to the community
before 15 Dec 2014.

Change-Id: I959eec05d100f212d5d61faaf114fe99618fae19
Reviewed-on: http://git.am.freescale.net:8181/21572
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Dongsheng Wang <dongsheng.wang@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin:Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/video/fsl-dcu-fb.c |   96 +++++++++++++++++++++++++++++++++----------
 1 files changed, 73 insertions(+), 23 deletions(-)

diff --git a/drivers/video/fsl-dcu-fb.c b/drivers/video/fsl-dcu-fb.c
index 57a42f2..3fc0b79 100644
--- a/drivers/video/fsl-dcu-fb.c
+++ b/drivers/video/fsl-dcu-fb.c
@@ -914,28 +914,6 @@ static irqreturn_t fsl_dcu_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-#ifdef CONFIG_PM_RUNTIME
-static int fsl_dcu_runtime_suspend(struct device *dev)
-{
-	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
-
-	clk_disable_unprepare(dcufb->clk);
-	clk_disable_unprepare(dcufb->tcon_clk);
-
-	return 0;
-}
-
-static int fsl_dcu_runtime_resume(struct device *dev)
-{
-	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
-
-	clk_prepare_enable(dcufb->tcon_clk);
-	clk_prepare_enable(dcufb->clk);
-
-	return 0;
-}
-#endif
-
 static const struct regmap_config fsl_tcon_regmap_config = {
 	.reg_bits = 32,
 	.reg_stride = 4,
@@ -1179,9 +1157,81 @@ static int fsl_dcu_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_RUNTIME
+static int fsl_dcu_runtime_suspend(struct device *dev)
+{
+	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(dcufb->clk);
+	clk_disable_unprepare(dcufb->tcon_clk);
+
+	return 0;
+}
+
+static int fsl_dcu_runtime_resume(struct device *dev)
+{
+	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
+
+	clk_prepare_enable(dcufb->tcon_clk);
+	clk_prepare_enable(dcufb->clk);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+static int fsl_dcu_suspend(struct device *dev)
+{
+	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
+
+	regcache_cache_only(dcufb->regmap, true);
+	regcache_mark_dirty(dcufb->regmap);
+	clk_disable_unprepare(dcufb->clk);
+
+	if (dcufb->tcon_regmap) {
+		regcache_cache_only(dcufb->tcon_regmap, true);
+		regcache_mark_dirty(dcufb->tcon_regmap);
+		clk_disable_unprepare(dcufb->tcon_clk);
+	}
+
+	if (dcufb->scfg_regmap) {
+		regcache_cache_only(dcufb->scfg_regmap, true);
+		regcache_mark_dirty(dcufb->scfg_regmap);
+	}
+
+	return 0;
+}
+
+static int fsl_dcu_resume(struct device *dev)
+{
+	struct dcu_fb_data *dcufb = dev_get_drvdata(dev);
+	struct device_node *np = dev->of_node;
+
+	/* Enable clocks and restore all registers */
+	if (dcufb->tcon_regmap) {
+		clk_prepare_enable(dcufb->tcon_clk);
+		regcache_cache_only(dcufb->tcon_regmap, false);
+		regcache_sync(dcufb->tcon_regmap);
+	}
+
+	if (dcufb->scfg_regmap) {
+		regcache_cache_only(dcufb->scfg_regmap, false);
+		regcache_sync(dcufb->scfg_regmap);
+	}
+
+	clk_prepare_enable(dcufb->clk);
+	reset_total_layers(np, dcufb);
+	regcache_cache_only(dcufb->regmap, false);
+	regcache_sync(dcufb->regmap);
+
+	return 0;
+}
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct dev_pm_ops fsl_dcu_pm_ops = {
 	SET_RUNTIME_PM_OPS(fsl_dcu_runtime_suspend,
-			fsl_dcu_runtime_resume, NULL)
+			   fsl_dcu_runtime_resume, NULL)
+	SET_SYSTEM_SLEEP_PM_OPS(fsl_dcu_suspend, fsl_dcu_resume)
 };
 
 static struct of_device_id fsl_dcu_dt_ids[] = {
-- 
1.7.5.4

