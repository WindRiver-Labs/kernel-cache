From 127a725b8233f90dee1df87e8f7f8e450a791d3e Mon Sep 17 00:00:00 2001
From: Xiubo Li <Li.Xiubo@freescale.com>
Date: Wed, 9 Apr 2014 14:04:28 +0800
Subject: [PATCH 045/255] fb: Add DCU big eidianness support

The DCU driver will be working on Vybrid, LS1, LS2
platforms, and will be in different endianness mode in those SoCs:

SoCs         CPU endian mode      DCU endian mode
------------------------------------------------
Vybird           LE                    LE
LS1              LE                    BE
LS2              LE                    LE

This patch add the different endiannesses support for that.

Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/video/fsl-dcu-fb.c | 167 +++++++++++++++++++++++++++++----------------
 1 file changed, 109 insertions(+), 58 deletions(-)

diff --git a/drivers/video/fsl-dcu-fb.c b/drivers/video/fsl-dcu-fb.c
index 6b45357..1f4b52c 100644
--- a/drivers/video/fsl-dcu-fb.c
+++ b/drivers/video/fsl-dcu-fb.c
@@ -138,6 +138,7 @@ struct dcu_fb_data {
 	struct fb_info *fsl_dcu_info[DCU_LAYER_NUM_MAX];
 	struct device *dev;
 	void __iomem *reg_base;
+	bool big_endian;
 	unsigned int irq;
 	struct clk *clk;
 };
@@ -225,6 +226,22 @@ static struct mfb_info mfb_template[] = {
 	},
 };
 
+static inline u32 dcu_readl(bool big_endian, void __iomem *addr)
+{
+	if (big_endian)
+		return ioread32be(addr);
+	else
+		return ioread32(addr);
+}
+
+static inline void dcu_writel(bool big_endian, u32 val, void __iomem *addr)
+{
+	if (big_endian)
+		iowrite32be(val, addr);
+	else
+		iowrite32(val, addr);
+}
+
 static int enable_panel(struct fb_info *info)
 {
 	struct fb_var_screeninfo *var = &info->var;
@@ -232,14 +249,14 @@ static int enable_panel(struct fb_info *info)
 	struct dcu_fb_data *dcufb = mfbi->parent;
 	unsigned int bpp;
 
-	writel(DCU_CTRLDESCLN_1_HEIGHT(var->yres) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_1_HEIGHT(var->yres) |
 		DCU_CTRLDESCLN_1_WIDTH(var->xres),
 		dcufb->reg_base + DCU_CTRLDESCLN_1(mfbi->index));
-	writel(DCU_CTRLDESCLN_2_POSY(mfbi->y_layer_d) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_2_POSY(mfbi->y_layer_d) |
 		DCU_CTRLDESCLN_2_POSX(mfbi->x_layer_d),
 		dcufb->reg_base + DCU_CTRLDESCLN_2(mfbi->index));
 
-	writel(info->fix.smem_start,
+	dcu_writel(dcufb->big_endian, info->fix.smem_start,
 		dcufb->reg_base + DCU_CTRLDESCLN_3(mfbi->index));
 
 	switch (var->bits_per_pixel) {
@@ -258,30 +275,32 @@ static int enable_panel(struct fb_info *info)
 		return -EINVAL;
 	}
 
-	writel(DCU_CTRLDESCLN_4_EN |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_4_EN |
 		DCU_CTRLDESCLN_4_TRANS(mfbi->alpha) |
 		DCU_CTRLDESCLN_4_BPP(bpp) |
 		DCU_CTRLDESCLN_4_AB(mfbi->blend),
 		dcufb->reg_base + DCU_CTRLDESCLN_4(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_5_CKMAX_R(0xff) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_5_CKMAX_R(0xff) |
 		DCU_CTRLDESCLN_5_CKMAX_G(0xff) |
 		DCU_CTRLDESCLN_5_CKMAX_B(0xff),
 		dcufb->reg_base + DCU_CTRLDESCLN_5(mfbi->index));
-	writel(DCU_CTRLDESCLN_6_CKMIN_R(0) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_6_CKMIN_R(0) |
 		DCU_CTRLDESCLN_6_CKMIN_G(0) |
 		DCU_CTRLDESCLN_6_CKMIN_B(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_6(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_7_TILE_VER(0) | DCU_CTRLDESCLN_7_TILE_HOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_7_TILE_VER(0) |
+		DCU_CTRLDESCLN_7_TILE_HOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_7(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_8_FG_FCOLOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_8_FG_FCOLOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_8(mfbi->index));
-	writel(DCU_CTRLDESCLN_9_BG_BCOLOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_9_BG_BCOLOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_9(mfbi->index));
 
-	writel(DCU_UPDATE_MODE_READREG, dcufb->reg_base + DCU_UPDATE_MODE);
+	dcu_writel(dcufb->big_endian, DCU_UPDATE_MODE_READREG,
+			dcufb->reg_base + DCU_UPDATE_MODE);
 	return 0;
 }
 
@@ -290,33 +309,38 @@ static int disable_panel(struct fb_info *info)
 	struct mfb_info *mfbi = info->par;
 	struct dcu_fb_data *dcufb = mfbi->parent;
 
-	writel(DCU_CTRLDESCLN_1_HEIGHT(0) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_1_HEIGHT(0) |
 		DCU_CTRLDESCLN_1_WIDTH(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_1(mfbi->index));
-	writel(DCU_CTRLDESCLN_2_POSY(0) | DCU_CTRLDESCLN_2_POSX(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_2_POSY(0) |
+		DCU_CTRLDESCLN_2_POSX(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_2(mfbi->index));
 
-	writel(0, dcufb->reg_base + DCU_CTRLDESCLN_3(mfbi->index));
-	writel(0, dcufb->reg_base + DCU_CTRLDESCLN_4(mfbi->index));
+	dcu_writel(dcufb->big_endian, 0,
+		dcufb->reg_base + DCU_CTRLDESCLN_3(mfbi->index));
+	dcu_writel(dcufb->big_endian, 0,
+		dcufb->reg_base + DCU_CTRLDESCLN_4(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_5_CKMAX_R(0) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_5_CKMAX_R(0) |
 		DCU_CTRLDESCLN_5_CKMAX_G(0) |
 		DCU_CTRLDESCLN_5_CKMAX_B(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_5(mfbi->index));
-	writel(DCU_CTRLDESCLN_6_CKMIN_R(0) |
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_6_CKMIN_R(0) |
 		DCU_CTRLDESCLN_6_CKMIN_G(0) |
 		DCU_CTRLDESCLN_6_CKMIN_B(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_6(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_7_TILE_VER(0) | DCU_CTRLDESCLN_7_TILE_HOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_7_TILE_VER(0) |
+		DCU_CTRLDESCLN_7_TILE_HOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_7(mfbi->index));
 
-	writel(DCU_CTRLDESCLN_8_FG_FCOLOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_8_FG_FCOLOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_8(mfbi->index));
-	writel(DCU_CTRLDESCLN_9_BG_BCOLOR(0),
+	dcu_writel(dcufb->big_endian, DCU_CTRLDESCLN_9_BG_BCOLOR(0),
 		dcufb->reg_base + DCU_CTRLDESCLN_9(mfbi->index));
 
-	writel(DCU_UPDATE_MODE_READREG, dcufb->reg_base + DCU_UPDATE_MODE);
+	dcu_writel(dcufb->big_endian, DCU_UPDATE_MODE_READREG,
+		dcufb->reg_base + DCU_UPDATE_MODE);
 	return 0;
 }
 
@@ -326,8 +350,10 @@ static void enable_controller(struct fb_info *info)
 	struct dcu_fb_data *dcufb = mfbi->parent;
 	unsigned int dcu_mode;
 
-	dcu_mode = readl(dcufb->reg_base + DCU_DCU_MODE);
-	writel(dcu_mode | DCU_MODE_DCU_MODE(DCU_MODE_NORMAL),
+	dcu_mode = dcu_readl(dcufb->big_endian,
+		dcufb->reg_base + DCU_DCU_MODE);
+	dcu_writel(dcufb->big_endian, dcu_mode |
+		DCU_MODE_DCU_MODE(DCU_MODE_NORMAL),
 		dcufb->reg_base + DCU_DCU_MODE);
 }
 
@@ -336,7 +362,7 @@ static void disable_controller(struct fb_info *info)
 	struct mfb_info *mfbi = info->par;
 	struct dcu_fb_data *dcufb = mfbi->parent;
 
-	writel(DCU_MODE_DCU_MODE(DCU_MODE_OFF),
+	dcu_writel(dcufb->big_endian, DCU_MODE_DCU_MODE(DCU_MODE_OFF),
 		dcufb->reg_base + DCU_DCU_MODE);
 }
 
@@ -439,35 +465,38 @@ static void update_controller(struct fb_info *info)
 	unsigned int div;
 
 	div = fsl_dcu_calc_div(info);
-	writel((div - 1), dcufb->reg_base + DCU_DIV_RATIO);
+	dcu_writel(dcufb->big_endian, (div - 1),
+		dcufb->reg_base + DCU_DIV_RATIO);
 
-	writel(DCU_DISP_SIZE_DELTA_Y(var->yres) |
+	dcu_writel(dcufb->big_endian, DCU_DISP_SIZE_DELTA_Y(var->yres) |
 		DCU_DISP_SIZE_DELTA_X(var->xres / 16),
 		dcufb->reg_base + DCU_DISP_SIZE);
 
 	/* Horizontal and vertical sync parameters */
-	writel(DCU_HSYN_PARA_BP(var->left_margin) |
+	dcu_writel(dcufb->big_endian, DCU_HSYN_PARA_BP(var->left_margin) |
 		DCU_HSYN_PARA_PW(var->hsync_len) |
 		DCU_HSYN_PARA_FP(var->right_margin),
 		dcufb->reg_base + DCU_HSYN_PARA);
 
-	writel(DCU_VSYN_PARA_BP(var->upper_margin) |
+	dcu_writel(dcufb->big_endian, DCU_VSYN_PARA_BP(var->upper_margin) |
 		DCU_VSYN_PARA_PW(var->vsync_len) |
 		DCU_VSYN_PARA_FP(var->lower_margin),
 		dcufb->reg_base + DCU_VSYN_PARA);
 
-	writel(DCU_SYN_POL_INV_PXCK_FALL | DCU_SYN_POL_NEG_REMAIN |
-		DCU_SYN_POL_INV_VS_LOW | DCU_SYN_POL_INV_HS_LOW,
-		dcufb->reg_base + DCU_SYN_POL);
+	dcu_writel(dcufb->big_endian, DCU_SYN_POL_INV_PXCK_FALL |
+		DCU_SYN_POL_NEG_REMAIN | DCU_SYN_POL_INV_VS_LOW |
+		DCU_SYN_POL_INV_HS_LOW,	dcufb->reg_base + DCU_SYN_POL);
 
-	writel(DCU_BGND_R(0) | DCU_BGND_G(0) | DCU_BGND_B(0),
-		dcufb->reg_base + DCU_BGND);
+	dcu_writel(dcufb->big_endian, DCU_BGND_R(0) | DCU_BGND_G(0) |
+		DCU_BGND_B(0), dcufb->reg_base + DCU_BGND);
 
-	writel(DCU_MODE_BLEND_ITER(DCU_LAYER_NUM_MAX) | DCU_MODE_RASTER_EN,
-			dcufb->reg_base + DCU_DCU_MODE);
+	dcu_writel(dcufb->big_endian, DCU_MODE_BLEND_ITER(DCU_LAYER_NUM_MAX) |
+		DCU_MODE_RASTER_EN, dcufb->reg_base + DCU_DCU_MODE);
 
-	writel(DCU_THRESHOLD_LS_BF_VS(0x3) | DCU_THRESHOLD_OUT_BUF_HIGH(0x78) |
-		DCU_THRESHOLD_OUT_BUF_LOW(0), dcufb->reg_base + DCU_THRESHOLD);
+	dcu_writel(dcufb->big_endian, DCU_THRESHOLD_LS_BF_VS(0x3) |
+		DCU_THRESHOLD_OUT_BUF_HIGH(0x78) |
+		DCU_THRESHOLD_OUT_BUF_LOW(0),
+		dcufb->reg_base + DCU_THRESHOLD);
 }
 
 static int map_video_memory(struct fb_info *info)
@@ -516,8 +545,10 @@ static int fsl_dcu_set_layer(struct fb_info *info)
 	addr = info->fix.smem_start +
 		(pixel_offset * (var->bits_per_pixel >> 3));
 
-	writel(addr, dcufb->reg_base + DCU_CTRLDESCLN_3(mfbi->index));
-	writel(DCU_UPDATE_MODE_READREG, dcufb->reg_base + DCU_UPDATE_MODE);
+	dcu_writel(dcufb->big_endian, addr,
+		dcufb->reg_base + DCU_CTRLDESCLN_3(mfbi->index));
+	dcu_writel(dcufb->big_endian, DCU_UPDATE_MODE_READREG,
+		dcufb->reg_base + DCU_UPDATE_MODE);
 
 	return 0;
 }
@@ -698,24 +729,35 @@ static void reset_total_layers(struct dcu_fb_data *dcufb)
 	int i;
 
 	for (i = 1; i < DCU_TOTAL_LAYER_NUM; i++) {
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_1(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_2(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_3(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_4(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_5(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_6(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_7(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_8(i));
-		writel(0, dcufb->reg_base + DCU_CTRLDESCLN_9(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_1(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_2(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_3(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_4(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_5(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_6(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_7(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_8(i));
+		dcu_writel(dcufb->big_endian, 0,
+			dcufb->reg_base + DCU_CTRLDESCLN_9(i));
 	}
-	writel(DCU_UPDATE_MODE_READREG, dcufb->reg_base + DCU_UPDATE_MODE);
+	dcu_writel(dcufb->big_endian, DCU_UPDATE_MODE_READREG,
+		dcufb->reg_base + DCU_UPDATE_MODE);
 }
 
 static int fsl_dcu_open(struct fb_info *info, int user)
 {
 	struct mfb_info *mfbi = info->par;
 	struct dcu_fb_data *dcufb = mfbi->parent;
-	u32 int_mask = readl(dcufb->reg_base + DCU_INT_MASK);
+	u32 int_mask = dcu_readl(dcufb->big_endian,
+		dcufb->reg_base + DCU_INT_MASK);
 	int ret = 0;
 
 	mfbi->index = info->node;
@@ -727,7 +769,8 @@ static int fsl_dcu_open(struct fb_info *info, int user)
 		if (ret < 0)
 			mfbi->count--;
 		else
-			writel(int_mask & ~DCU_INT_MASK_UNDRUN,
+			dcu_writel(dcufb->big_endian,
+				int_mask & ~DCU_INT_MASK_UNDRUN,
 				dcufb->reg_base + DCU_INT_MASK);
 	}
 
@@ -872,20 +915,25 @@ static void uninstall_framebuffer(struct fb_info *info)
 static irqreturn_t fsl_dcu_irq(int irq, void *dev_id)
 {
 	struct dcu_fb_data *dcufb = dev_id;
-	unsigned int status = readl(dcufb->reg_base + DCU_INT_STATUS);
+	unsigned int status = dcu_readl(dcufb->big_endian,
+			dcufb->reg_base + DCU_INT_STATUS);
 	u32 dcu_mode;
 
 	if (status & DCU_INT_STATUS_UNDRUN) {
-		dcu_mode = readl(dcufb->reg_base + DCU_DCU_MODE);
+		dcu_mode = dcu_readl(dcufb->big_endian,
+			dcufb->reg_base + DCU_DCU_MODE);
 		dcu_mode &= ~DCU_MODE_DCU_MODE_MASK;
-		writel(dcu_mode | DCU_MODE_DCU_MODE(DCU_MODE_OFF),
+		dcu_writel(dcufb->big_endian, dcu_mode |
+			DCU_MODE_DCU_MODE(DCU_MODE_OFF),
 			dcufb->reg_base + DCU_DCU_MODE);
 		udelay(1);
-		writel(dcu_mode | DCU_MODE_DCU_MODE(DCU_MODE_NORMAL),
+		dcu_writel(dcufb->big_endian, dcu_mode |
+			DCU_MODE_DCU_MODE(DCU_MODE_NORMAL),
 			dcufb->reg_base + DCU_DCU_MODE);
 	}
 
-	writel(status, dcufb->reg_base + DCU_INT_STATUS);
+	dcu_writel(dcufb->big_endian, status,
+		dcufb->reg_base + DCU_INT_STATUS);
 	return IRQ_HANDLED;
 }
 
@@ -909,7 +957,7 @@ static int fsl_dcu_runtime_resume(struct device *dev)
 }
 #endif
 
-static int bypass_tcon(struct device_node *np)
+static int bypass_tcon(struct device_node *np, bool big_endian)
 {
 	struct device_node *tcon_np;
 	struct platform_device *tcon_pdev;
@@ -938,12 +986,13 @@ static int bypass_tcon(struct device_node *np)
 	if (IS_ERR(tcon_reg))
 		return PTR_ERR(tcon_reg);
 
-	writel(TCON_BYPASS_ENABLE, tcon_reg + TCON_CTRL1);
+	dcu_writel(big_endian, TCON_BYPASS_ENABLE, tcon_reg + TCON_CTRL1);
 	return 0;
 }
 
 static int fsl_dcu_probe(struct platform_device *pdev)
 {
+	struct device_node *np = pdev->dev.of_node;
 	struct dcu_fb_data *dcufb;
 	struct mfb_info *mfbi;
 	struct resource *res;
@@ -970,6 +1019,8 @@ static int fsl_dcu_probe(struct platform_device *pdev)
 		return PTR_ERR(dcufb->reg_base);
 	}
 
+	dcufb->big_endian = of_property_read_bool(np, "big-endians");
+
 	dcufb->irq = platform_get_irq(pdev, 0);
 	if (!dcufb->irq) {
 		dev_err(&pdev->dev, "could not get irq\n");
@@ -985,7 +1036,7 @@ static int fsl_dcu_probe(struct platform_device *pdev)
 
 	/* Put TCON in bypass mode, so the input signals from DCU are passed
 	 * through TCON unchanged */
-	ret = bypass_tcon(pdev->dev.of_node);
+	ret = bypass_tcon(np, dcufb->big_endian);
 	if (ret) {
 		dev_err(&pdev->dev, "could not bypass TCON\n");
 		goto failed_bypasstcon;
-- 
2.0.2

