From 4247dacf08f775fa690947c185ab5b0e5ec87173 Mon Sep 17 00:00:00 2001
From: Xiubo Li <Li.Xiubo@freescale.com>
Date: Tue, 5 Aug 2014 17:38:14 +0800
Subject: [PATCH 232/255] fb: Use the framebuffer's generic interface to
 simplfy the code.

Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/video/fsl_sii902x.c | 444 +++++++++++---------------------------------
 1 file changed, 112 insertions(+), 332 deletions(-)

diff --git a/drivers/video/fsl_sii902x.c b/drivers/video/fsl_sii902x.c
index b457f36..f16822c 100644
--- a/drivers/video/fsl_sii902x.c
+++ b/drivers/video/fsl_sii902x.c
@@ -29,7 +29,6 @@
 #include <linux/of_device.h>
 #include "edid.h"
 
-#define SII_EDID_LEN	256
 static bool g_enable_hdmi = false;
 
 struct sii902x_edid_cfg {
@@ -48,7 +47,6 @@ struct sii902x_data {
 	struct regmap *regmap;
 	unsigned int irq;
 	u8 cable_plugin;
-	u8 edid[SII_EDID_LEN];
 } *sii902x;
 
 static void sii902x_poweron(void);
@@ -59,7 +57,8 @@ static struct i2c_client *sii902x_to_i2c(struct sii902x_data *sii902x)
 	return sii902x->client;
 }
 
-static s32 sii902x_write(const struct i2c_client *client, u8 command, u8 value)
+static s32 sii902x_write(const struct i2c_client *client,
+			u8 command, u8 value)
 {
 	return i2c_smbus_write_byte_data(client, command, value);
 }
@@ -97,23 +96,6 @@ static ssize_t sii902x_show_state(struct device *dev,
 
 static DEVICE_ATTR(cable_state, S_IRUGO, sii902x_show_state, NULL);
 
-static ssize_t sii902x_show_edid(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	int i, j, len = 0;
-
-	for (j = 0; j < SII_EDID_LEN/16; j++) {
-		for (i = 0; i < 16; i++)
-			len += sprintf(buf+len, "0x%02X ",
-					sii902x->edid[j*16 + i]);
-		len += sprintf(buf+len, "\n");
-	}
-
-	return len;
-}
-
-static DEVICE_ATTR(edid, S_IRUGO, sii902x_show_edid, NULL);
-
 static void sii902x_power_up_tx(struct sii902x_data *sii902x)
 {
 	struct i2c_client *client = sii902x_to_i2c(sii902x);
@@ -131,8 +113,6 @@ static void sii902x_setup(struct fb_info *fbi)
 	u8 *tmp;
 	int i;
 
-	dev_dbg(&sii902x->client->dev, "Sii902x: setup..\n");
-
 	/* Power up */
 	sii902x_power_up_tx(sii902x);
 
@@ -161,233 +141,18 @@ static void sii902x_setup(struct fb_info *fbi)
 	sii902x_write(sii902x->client, 0x27, 0x00);
 }
 
-const struct fb_videomode sii902x_cea_modes[64] = {
-	/* #1: 640x480p@59.94/60Hz */
-	[1] = {
-		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #3: 720x480p@59.94/60Hz */
-	[3] = {
-		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #5: 1920x1080i@59.94/60Hz */
-	[5] = {
-		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
-		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-		FB_VMODE_INTERLACED, 0,
-	},
-	/* #7: 720(1440)x480iH@59.94/60Hz */
-	[7] = {
-		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
-		FB_VMODE_INTERLACED, 0,
-	},
-	/* #9: 720(1440)x240pH@59.94/60Hz */
-	[9] = {
-		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #18: 720x576pH@50Hz */
-	[18] = {
-		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #19: 1280x720p@50Hz */
-	[19] = {
-		NULL, 50, 1280, 720, 13468, 220, 440, 20, 5, 40, 5,
-		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #20: 1920x1080i@50Hz */
-	[20] = {
-		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
-		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-		FB_VMODE_INTERLACED, 0,
-	},
-	/* #32: 1920x1080p@23.98/24Hz */
-	[32] = {
-		NULL, 24, 1920, 1080, 13468, 148, 638, 36, 4, 44, 5,
-		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-	/* #35: (2880)x480p4x@59.94/60Hz */
-	[35] = {
-		NULL, 60, 2880, 480, 9250, 240, 64, 30, 9, 248, 6, 0,
-		FB_VMODE_NONINTERLACED, 0,
-	},
-};
-
-static void sii902x_get_detailed_timing(unsigned char *block,
-				struct fb_videomode *mode)
-{
-	mode->xres = H_ACTIVE;
-	mode->yres = V_ACTIVE;
-	mode->pixclock = PIXEL_CLOCK;
-	mode->pixclock /= 1000;
-	mode->pixclock = KHZ2PICOS(mode->pixclock);
-	mode->right_margin = H_SYNC_OFFSET;
-	mode->left_margin = (H_ACTIVE + H_BLANKING) -
-		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
-	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
-		V_SYNC_WIDTH;
-	mode->lower_margin = V_SYNC_OFFSET;
-	mode->hsync_len = H_SYNC_WIDTH;
-	mode->vsync_len = V_SYNC_WIDTH;
-	if (HSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
-	if (VSYNC_POSITIVE)
-		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
-	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
-				     (V_ACTIVE + V_BLANKING));
-	if (INTERLACED) {
-		mode->yres *= 2;
-		mode->upper_margin *= 2;
-		mode->lower_margin *= 2;
-		mode->vsync_len *= 2;
-		mode->vmode |= FB_VMODE_INTERLACED;
-	}
-	mode->flag = FB_MODE_IS_DETAILED;
-
-	printk("      %d MHz ",  PIXEL_CLOCK/1000000);
-	printk("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
-	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
-	printk("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
-	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
-	printk("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
-	       (VSYNC_POSITIVE) ? "+" : "-");
-}
-
-int sii902x_edid_parse_ext_blk(unsigned char *edid,
-		struct sii902x_edid_cfg *cfg,
-		struct fb_monspecs *specs)
+static int __sii902x_read_edid(struct i2c_adapter *adp,
+			unsigned char *edid, u8 *buf)
 {
-	char detail_timming_desc_offset;
-	struct fb_videomode *mode, *m;
-	unsigned char index = 0x0;
-	unsigned char *block;
-	int i, num = 0;
-
-	if (edid[index++] != 0x2) /* only support cea ext block now */
-		return -1;
-	if (edid[index++] != 0x3) /* only support version 3*/
-		return -1;
-	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
-	if (mode == NULL)
-		return -1;
-
-	detail_timming_desc_offset = edid[index++];
-
-	cfg->cea_underscan = (edid[index] >> 7) & 0x1;
-	cfg->cea_basicaudio = (edid[index] >> 6) & 0x1;
-	cfg->cea_ycbcr444 = (edid[index] >> 5) & 0x1;
-	cfg->cea_ycbcr422 = (edid[index] >> 4) & 0x1;
-
-	/* short desc */
-	printk("CEA Short desc timmings\n");
-	index++;
-	while (index < detail_timming_desc_offset) {
-		unsigned char tagcode, blklen;
-
-		tagcode = (edid[index] >> 5) & 0x7;
-		blklen = (edid[index]) & 0x1f;
-
-		printk("Tagcode %x Len %d\n", tagcode, blklen);
-
-		switch (tagcode) {
-		case 0x2: /*Video data block*/
-		{
-			int cea_idx;
-			i = 0;
-			while (i < blklen) {
-				index++;
-				cea_idx = edid[index] & 0x7f;
-				if (cea_idx < ARRAY_SIZE(sii902x_cea_modes) &&
-					(sii902x_cea_modes[cea_idx].xres)) {
-					printk("Support CEA Format #%d\n", cea_idx);
-					mode[num] = sii902x_cea_modes[cea_idx];
-					mode[num].flag |= FB_MODE_IS_STANDARD;
-					num++;
-				}
-				i++;
-			}
-			break;
-		}
-		case 0x3: /*Vendor specific data*/
-		{
-			unsigned char IEEE_reg_iden[3];
-			IEEE_reg_iden[0] = edid[index+1];
-			IEEE_reg_iden[1] = edid[index+2];
-			IEEE_reg_iden[2] = edid[index+3];
-
-			if ((IEEE_reg_iden[0] == 0x03) &&
-				(IEEE_reg_iden[1] == 0x0c) &&
-				(IEEE_reg_iden[2] == 0x00))
-				cfg->hdmi_cap = 1;
-			index += blklen;
-			break;
-		}
-		case 0x1: /*Audio data block*/
-		case 0x4: /*Speaker allocation block*/
-		case 0x7: /*User extended block*/
-		default:
-			/* skip */
-			index += blklen;
-			break;
-		}
-
-		index++;
-	}
-
-	/* long desc */
-	printk("CEA long desc timmings\n");
-	index = detail_timming_desc_offset;
-	block = edid + index;
-	while (index < (EDID_LENGTH - DETAILED_TIMING_DESCRIPTION_SIZE)) {
-		if (!(block[0] == 0x00 && block[1] == 0x00)) {
-			sii902x_get_detailed_timing(block, &mode[num]);
-			num++;
-		}
-		block += DETAILED_TIMING_DESCRIPTION_SIZE;
-		index += DETAILED_TIMING_DESCRIPTION_SIZE;
-	}
-
-	if (!num) {
-		kfree(mode);
-		return 0;
-	}
-
-	m = kmalloc((num + specs->modedb_len) *
-			sizeof(struct fb_videomode), GFP_KERNEL);
-	if (!m)
-		return 0;
-
-	if (specs->modedb_len) {
-		memmove(m, specs->modedb,
-			specs->modedb_len * sizeof(struct fb_videomode));
-		kfree(specs->modedb);
-	}
-	memmove(m+specs->modedb_len, mode,
-		num * sizeof(struct fb_videomode));
-	kfree(mode);
-
-	specs->modedb_len += num;
-	specs->modedb = m;
+	unsigned short addr = 0x50;
+	int ret;
 
-	return 0;
-}
-/* make sure edid has 256 bytes*/
-static int __sii902x_read_edid(struct i2c_adapter *adp, unsigned short addr,
-	unsigned char *edid, struct sii902x_edid_cfg *cfg, struct fb_info *fbi)
-{
-	u8 buf0[2] = {0, 0};
-	int dat = 0, i;
 	struct i2c_msg msg[2] = {
 		{
 		.addr	= addr,
 		.flags	= 0,
 		.len	= 1,
-		.buf	= buf0,
+		.buf	= buf,
 		}, {
 		.addr	= addr,
 		.flags	= I2C_M_RD,
@@ -399,55 +164,67 @@ static int __sii902x_read_edid(struct i2c_adapter *adp, unsigned short addr,
 	if (adp == NULL)
 		return -EINVAL;
 
-	memset(edid, 0, 256);
-	memset(cfg, 0, sizeof(struct sii902x_edid_cfg));
+	memset(edid, 0, EDID_LENGTH);
 
-	buf0[0] = 0x00;
-	dat = i2c_transfer(adp, msg, 2);
+	ret = i2c_transfer(adp, msg, 2);
+	if (ret < 0)
+		return ret;
 
 	/* If 0x50 fails, try 0x37. */
 	if (edid[1] == 0x00) {
 		msg[0].addr = msg[1].addr = 0x37;
-		dat = i2c_transfer(adp, msg, 2);
-		if (dat < 0)
-			return dat;
+		ret = i2c_transfer(adp, msg, 2);
+		if (ret < 0)
+			return ret;
 	}
 
 	if (edid[1] == 0x00)
 		return -ENOENT;
 
+	return 0;
+}
+/* make sure edid has 256 bytes*/
+static int __sii902x_get_edid(struct i2c_adapter *adp,
+		struct sii902x_edid_cfg *cfg, struct fb_info *fbi)
+{
+	u8 *edid;
+	u8 buf[2] = {0, 0};
+	int num, ret;
+
+	edid = kzalloc(EDID_LENGTH, GFP_KERNEL);
+	if (!edid)
+		return -ENOMEM;
+
+	ret = __sii902x_read_edid(adp, edid, buf);
+	if (ret)
+		return ret;
+
+	memset(cfg, 0, sizeof(struct sii902x_edid_cfg));
 	/* edid first block parsing */
 	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
 	fb_edid_to_monspecs(edid, &fbi->monspecs);
 
 	/* need read ext block? Only support one more blk now*/
-	if (edid[0x7E]) {
-			printk("Edid[0x7E != 0x%x\n", edid[0x7E]);
-		if (edid[0x7E] > 1)
+	num = edid[0x7E];
+	if (num) {
+		if (num > 1)
 			printk("Edid has %d ext block, \
-				but now only support 1 ext blk\n", edid[0x7E]);
-		buf0[0] = 0x80;
-		msg[1].buf = edid + EDID_LENGTH;
-		dat = i2c_transfer(adp, msg, 2);
-		if (dat < 0)
-			return dat;
-
-		/* edid ext block parsing */
-		sii902x_edid_parse_ext_blk(edid + 128, cfg, &fbi->monspecs);
-	}
+				but now only support 1 ext blk\n", num);
 
-	for (i = 0; i < 256; i++) {
-		if (i % 16 == 0)
-			printk("\n0x%02x~0x%02x: ", i, i+15);
-		printk("%02x ", edid[i]);
+		buf[0] = 0x80;
+		ret = __sii902x_read_edid(adp, edid, buf);
+		if (ret)
+			return ret;
+
+		fb_edid_add_monspecs(edid, &fbi->monspecs);
 	}
-	printk("\n");
+
+	kfree(edid);
 	return 0;
 }
-static int sii902x_read_edid(struct fb_info *fbi)
+static int sii902x_get_edid(struct fb_info *fbi)
 {
 	int old, dat, ret, cnt = 100;
-	unsigned short addr = 0x50;
 
 	old = sii902x_read(sii902x->client, 0x1A);
 
@@ -466,8 +243,8 @@ static int sii902x_read_edid(struct fb_info *fbi)
 	sii902x_write(sii902x->client, 0x1A, old | 0x06);
 
 	/* edid reading */
-	ret = __sii902x_read_edid(sii902x->client->adapter, addr,
-				sii902x->edid, &sii902x->edid_cfg, fbi);
+	ret = __sii902x_get_edid(sii902x->client->adapter,
+			&sii902x->edid_cfg, fbi);
 
 	cnt = 100;
 	do {
@@ -487,69 +264,73 @@ done:
 
 static void det_worker(struct work_struct *work)
 {
+	struct fb_info *fbi = sii902x->fbi;
+	struct fb_monspecs *monspecs = &fbi->monspecs;
 	int val, ret;
 	char event_string[16];
 	char *envp[] = { event_string, NULL };
 
 	val = sii902x_read(sii902x->client, 0x3D);
-	if (val & 0x1 || g_enable_hdmi) {
-		/* cable connection changes */
-		if (val & 0x4 || g_enable_hdmi) {
-			sii902x->cable_plugin = 1;
-			sprintf(event_string, "EVENT=plugin");
-
-			ret = sii902x_read_edid(sii902x->fbi);
-			if (ret < 0) {
-				dev_err(&sii902x->client->dev,
-						"Sii902x: read edid fail\n");
-				goto err;
-			}
-
-			/* make sure fb is powerdown */
-			console_lock();
-			fb_blank(sii902x->fbi, FB_BLANK_POWERDOWN);
-			console_unlock();
+	if (!(val & 0x1) && !g_enable_hdmi)
+		goto err;
+
+	/* cable connection changes */
+	if (val & 0x4 || g_enable_hdmi) {
+		sii902x->cable_plugin = 1;
+		sprintf(event_string, "EVENT=plugin");
+
+		ret = sii902x_get_edid(fbi);
+		if (ret < 0) {
+			dev_err(&sii902x->client->dev, "read edid fail\n");
+			goto err;
+		}
 
-			if (sii902x->fbi->monspecs.modedb_len > 0) {
-				int i;
-				const struct fb_videomode *mode;
-				struct fb_videomode m;
+		/* make sure fb is powerdown */
+		console_lock();
+		fb_blank(fbi, FB_BLANK_POWERDOWN);
+		console_unlock();
 
-				fb_destroy_modelist(&sii902x->fbi->modelist);
+		if (monspecs->modedb_len > 0) {
+			int i;
+			const struct fb_videomode *mode;
+			struct fb_videomode m;
 
-				for (i = 0; i < sii902x->fbi->monspecs.modedb_len; i++) {
-					/*FIXME now we do not support interlaced mode */
-					if (!(sii902x->fbi->monspecs.modedb[i].vmode & FB_VMODE_INTERLACED))
-						fb_add_videomode(&sii902x->fbi->monspecs.modedb[i],
-								&sii902x->fbi->modelist);
-				}
+			fb_destroy_modelist(&fbi->modelist);
 
-				fb_var_to_videomode(&m, &sii902x->fbi->var);
-				mode = fb_find_nearest_mode(&m,
-						&sii902x->fbi->modelist);
+			for (i = 0; i < monspecs->modedb_len; i++) {
+				/*FIXME now we do not support interlaced mode */
+				if (!(monspecs->modedb[i].vmode & FB_VMODE_INTERLACED))
+					fb_add_videomode(&monspecs->modedb[i],
+							&fbi->modelist);
+			}
 
-				fb_videomode_to_var(&sii902x->fbi->var, mode);
+			fb_var_to_videomode(&m, &fbi->var);
+			mode = fb_find_nearest_mode(&m,
+					&fbi->modelist);
 
-				sii902x->fbi->var.activate |= FB_ACTIVATE_FORCE;
-				console_lock();
-				sii902x->fbi->flags |= FBINFO_MISC_USEREVENT;
-				fb_set_var(sii902x->fbi, &sii902x->fbi->var);
-				sii902x->fbi->flags &= ~FBINFO_MISC_USEREVENT;
-				console_unlock();
-			}
+			fb_videomode_to_var(&fbi->var, mode);
 
+			fbi->var.activate |= FB_ACTIVATE_FORCE;
 			console_lock();
-			fb_blank(sii902x->fbi, FB_BLANK_UNBLANK);
-			console_unlock();
-		} else {
-			sii902x->cable_plugin = 0;
-			sprintf(event_string, "EVENT=plugout");
-			console_lock();
-			fb_blank(sii902x->fbi, FB_BLANK_POWERDOWN);
+			fbi->flags |= FBINFO_MISC_USEREVENT;
+			fb_set_var(fbi, &fbi->var);
+			fbi->flags &= ~FBINFO_MISC_USEREVENT;
 			console_unlock();
 		}
-		kobject_uevent_env(&sii902x->client->dev.kobj, KOBJ_CHANGE, envp);
+
+		console_lock();
+		fb_blank(fbi, FB_BLANK_UNBLANK);
+		console_unlock();
+	} else {
+		sii902x->cable_plugin = 0;
+		sprintf(event_string, "EVENT=plugout");
+		console_lock();
+		fb_blank(fbi, FB_BLANK_POWERDOWN);
+		console_unlock();
 	}
+	kobject_uevent_env(&sii902x->client->dev.kobj,
+			KOBJ_CHANGE, envp);
+
 err:
 	sii902x_write(sii902x->client, 0x3D, val);
 }
@@ -560,7 +341,8 @@ static irqreturn_t sii902x_detect_handler(int irq, void *data)
 		g_enable_hdmi = false;
 
 	if (sii902x->fbi)
-		schedule_delayed_work(&(sii902x->det_work), msecs_to_jiffies(20));
+		schedule_delayed_work(&(sii902x->det_work),
+				msecs_to_jiffies(20));
 	return IRQ_HANDLED;
 }
 
@@ -575,7 +357,8 @@ static int sii902x_fb_event(struct notifier_block *nb, unsigned long val, void *
 			break;
 		sii902x->fbi = fbi;
 		if (g_enable_hdmi && sii902x->fbi) {
-			schedule_delayed_work(&(sii902x->det_work), msecs_to_jiffies(20));
+			schedule_delayed_work(&(sii902x->det_work),
+					msecs_to_jiffies(20));
 		}
 		break;
 	case FB_EVENT_MODE_CHANGE:
@@ -620,7 +403,7 @@ static int sii902x_initialize(struct sii902x_data *sii902x)
 			break;
 	}
 	if (0 != ret)
-		dev_err(&client->dev, "Sii902x: cound not find device\n");
+		dev_err(&client->dev, "cound not find device\n");
 
 	return ret;
 }
@@ -652,7 +435,7 @@ static int sii902x_probe(struct i2c_client *client,
 		return -EPERM;
 
 	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE)) {
-		dev_err(&client->dev, "Sii902x: i2c_check_functionality error\n");
+		dev_err(&client->dev, "i2c_check_functionality error\n");
 		return -ENODEV;
 	}
 
@@ -672,15 +455,16 @@ static int sii902x_probe(struct i2c_client *client,
 	sii902x_enable_source(sii902x);
 
 	/* try to read edid */
-	if (sii902x_read_edid(&edid_fbi) < 0)
+	if (sii902x_get_edid(&edid_fbi) < 0)
 		dev_warn(&client->dev, "Can not read edid\n");
 
 	if (client->irq) {
-		ret = devm_request_irq(&client->dev, client->irq, sii902x_detect_handler, 0,
-				 "SII902x_det", sii902x);
+		ret = devm_request_irq(&client->dev, client->irq,
+				sii902x_detect_handler, 0,
+				"SII902x_det", sii902x);
 		if (ret < 0)
 			dev_warn(&client->dev,
-				"Sii902x: cound not request det irq %d\n",
+				"cound not request det irq %d\n",
 				client->irq);
 		else {
 			INIT_DELAYED_WORK(&(sii902x->det_work), det_worker);
@@ -690,15 +474,11 @@ static int sii902x_probe(struct i2c_client *client,
 		ret = device_create_file(&client->dev, &dev_attr_fb_name);
 		if (ret < 0)
 			dev_warn(&client->dev,
-				"Sii902x: cound not create sys node for fb name\n");
+				"cound not create sys node for fb name\n");
 		ret = device_create_file(&client->dev, &dev_attr_cable_state);
 		if (ret < 0)
 			dev_warn(&client->dev,
-				"Sii902x: cound not create sys node for cable state\n");
-		ret = device_create_file(&client->dev, &dev_attr_edid);
-		if (ret < 0)
-			dev_warn(&client->dev,
-				"Sii902x: cound not create sys node for edid\n");
+				"cound not create sys node for cable state\n");
 	}
 
 	fb_register_client(&nb);
-- 
2.0.2

