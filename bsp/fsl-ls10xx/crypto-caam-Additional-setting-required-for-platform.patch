From 1fef19e1efc8945e2be2b1edc30548d07e2d11e8 Mon Sep 17 00:00:00 2001
From: Ruchika Gupta <ruchika.gupta@freescale.com>
Date: Thu, 22 May 2014 13:56:51 +0530
Subject: [PATCH 117/255] crypto:caam - Additional setting required for
 platforms with virtualization enabled in SEC

For platforms with virtualization enabled
1. The job ring registers can be written to only is the job ring has been
   started i.e STARTR bit in JRSTART register is 1

2. For DECO's under direct software control, with virtualization enabled
   PL, BMT, ICID and SDID values need to be provided. These are provided by
   selecting a Job ring in start mode whose parameters would be used for the
   DECO access programming.

Signed-off-by: Ruchika Gupta <ruchika.gupta@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/caam/ctrl.c | 51 +++++++++++++++++++++++++++++++++++++++++++++-
 drivers/crypto/caam/regs.h | 19 ++++++++++++++++-
 2 files changed, 68 insertions(+), 2 deletions(-)

diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 23b9155..9025671 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -87,6 +87,14 @@ static inline int run_descriptor_deco0(struct device *ctrldev, u32 *desc,
 
 	/* Set the bit to request direct access to DECO0 */
 	topregs = (struct caam_full __iomem *)ctrlpriv->ctrl;
+
+	if (rd_reg32(&topregs->ctrl.jrstart) & JRSTART_JR0_START)
+		setbits32(&topregs->ctrl.deco_rsr, DECORSR_JR0);
+
+	while (!(rd_reg32(&topregs->ctrl.deco_rsr) & DECORSR_VALID) &&
+								 --timeout)
+		cpu_relax();
+
 	setbits32(&topregs->ctrl.deco_rq, DECORR_RQD0ENABLE);
 
 	while (!(rd_reg32(&topregs->ctrl.deco_rq) & DECORR_DEN0) &&
@@ -129,6 +137,9 @@ static inline int run_descriptor_deco0(struct device *ctrldev, u32 *desc,
 	*status = rd_reg32(&topregs->deco.op_status_hi) &
 		  DECO_OP_STATUS_HI_ERR_MASK;
 
+	if (rd_reg32(&topregs->ctrl.jrstart) & JRSTART_JR0_START)
+		clrbits32(&topregs->ctrl.deco_rsr, DECORSR_JR0);
+
 	/* Mark the DECO as free */
 	clrbits32(&topregs->ctrl.deco_rq, DECORR_RQD0ENABLE);
 
@@ -382,7 +393,7 @@ static int caam_probe(struct platform_device *pdev)
 #endif
 	u32 val_prev, val;
 	u32 scfgr;
-	u64 comp_params;
+	u32 comp_params;
 	u32 cha_vid_ls;
 
 	ctrlpriv = kzalloc(sizeof(struct caam_drv_private), GFP_KERNEL);
@@ -416,6 +427,44 @@ static int caam_probe(struct platform_device *pdev)
 	setbits32(&topregs->ctrl.mcr, MCFGR_WDENABLE |
 		  (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));
 
+
+	/*
+	 *  Read the Compile Time paramters and SCFGR to determine
+	 * if Virtualization is enabled for this platform 	
+	 */
+	comp_params = rd_reg32(&topregs->ctrl.perfmon.comp_parms_ms);
+	scfgr = rd_reg32(&topregs->ctrl.scfgr);
+
+	val_prev = rd_reg32(&topregs->ctrl.jrstart);
+	if (comp_params & CTPR_MS_VIRT_EN_INCL) {
+		/* VIRT_EN_INCL = 1 & VIRT_EN_POR = 1 or
+		 * VIRT_EN_INCL = 1 & VIRT_EN_POR = 0 & SCFGR_VIRT_EN = 1
+		 */
+		if ((comp_params & CTPR_MS_VIRT_EN_POR) ||
+		    (!(comp_params & CTPR_MS_VIRT_EN_POR) &&
+					(scfgr & SCFGR_VIRT_EN)))
+			setbits32(&topregs->ctrl.jrstart, JRSTART_JR0_START |
+				  JRSTART_JR1_START | JRSTART_JR2_START |
+				  JRSTART_JR3_START);
+	} else {
+		/* VIRT_EN_INCL = 0 && VIRT_EN_POR_VALUE = 1 */
+		if (comp_params & CTPR_MS_VIRT_EN_POR)
+			setbits32(&topregs->ctrl.jrstart, JRSTART_JR0_START |
+				  JRSTART_JR1_START | JRSTART_JR2_START |
+				  JRSTART_JR3_START);
+	}
+
+	val = rd_reg32(&topregs->ctrl.jrstart);
+	printk("Value in jrstart addr %x, value prev %x new %x\n", &topregs->ctrl.jrstart, val_prev, val);
+#if 0
+	val_prev = rd_reg32(&topregs->ctrl.jrstart);
+	/* Start Job rings. Setting this bit would allow the programming of Job 	 * ring registers */
+	setbits32(&topregs->ctrl.jrstart, JRSTART_JR0_START | JRSTART_JR1_START |
+						JRSTART_JR2_START | JRSTART_JR3_START);
+	val = rd_reg32(&topregs->ctrl.jrstart);
+	printk("Value in jrstart addr %x, value prev %x new %x\n", &topregs->ctrl.jrstart, val_prev, val);
+#endif
+
 	if (sizeof(dma_addr_t) == sizeof(u64))
 		if (of_device_is_compatible(nprop, "fsl,sec-v5.0"))
 			dma_set_mask(dev, DMA_BIT_MASK(40));
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index 4bdef91..333de58 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -186,6 +186,18 @@ struct caam_perfmon {
 	u32 cha_rev_ls;		/* CRNR - CHA Rev No. Least significant half*/
 #define CTPR_MS_QI_SHIFT	25
 #define CTPR_MS_QI_MASK		(0x1ull << CTPR_MS_QI_SHIFT)
+#if 0
+#define CTPR_MS_VIRT_EN_SHIFT	25
+#define CTPR_MS_VIRT_EN_MASK		(0x1ull << CTPR_MS_QI_SHIFT)
+#define CTPR_MS_QI_SHIFT	25
+#define CTPR_MS_QI_MASK		(0x1ull << CTPR_MS_QI_SHIFT)
+#define CTPR_MS_QI_SHIFT	25
+#define CTPR_MS_QI_MASK		(0x1ull << CTPR_MS_QI_SHIFT)
+#define CTPR_MS_QI_SHIFT	25
+#define CTPR_MS_QI_MASK		(0x1ull << CTPR_MS_QI_SHIFT)
+#endif
+#define CTPR_MS_VIRT_EN_INCL	0x00000001
+#define CTPR_MS_VIRT_EN_POR	0x00000002
 	u32 comp_parms_ms;	/* CTPR - Compile Parameters Register	*/
 	u32 comp_parms_ls;	/* CTPR - Compile Parameters Register	*/
 	u64 rsvd1[2];
@@ -322,7 +334,9 @@ struct caam_ctrl {
 	u32 rsvd3[11];
 	u32 jrstart;			/* JRSTART  Job Ring Start Register */
 	struct masterid rtic_mid[4];	/* RTICxLIODNR - RTIC LIODN setup */
-	u32 rsvd4[7];
+	u32 rsvd4[5];
+	u32 deco_rsr;			/* DECORSR - Deco Request Source */
+	u32 rsvd11;
 	u32 deco_rq;			/* DECORR - DECO Request */
 	struct partid deco_mid[5];	/* DECOxLIODNR - 1 per DECO */
 	u32 rsvd5[22];
@@ -366,7 +380,10 @@ struct caam_ctrl {
 #define MCFGR_DMA_RESET		0x10000000
 #define MCFGR_LONG_PTR		0x00010000 /* Use >32-bit desc addressing */
 #define SCFGR_RDBENABLE		0x00000400
+#define SCFGR_VIRT_EN		0x00008000
 #define DECORR_RQD0ENABLE	0x00000001 /* Enable DECO0 for direct access */
+#define DECORSR_JR0		0x00000001 /* Job ring to supply TZ,SDID ,ICID */
+#define DECORSR_VALID		0x80000000
 #define DECORR_DEN0		0x00010000 /* DECO0 available for access*/
 
 /* AXI read cache control */
-- 
2.0.2

