From d017855c992fa8440a5ae3d343e3c83d7aab399c Mon Sep 17 00:00:00 2001
From: Zhang Zhuoyu <Zhuoyu.Zhang@freescale.com>
Date: Wed, 19 Nov 2014 15:49:53 +0800
Subject: [PATCH 035/129] arm: ls1: provide a workaround for core soft reset

Due to an erratum, after core soft reset, core state machine registers
need to force release manually to avoid cache coherence issue.

Signed-off-by: Zhang Zhuoyu <Zhuoyu.Zhang@freescale.com>

----
Fix previous known issue
http://git.am.freescale.net:8181/21918
Change-Id: I44a7cf8a315bafe7dc413f73d2af2579da246fbb
Reviewed-on: http://git.am.freescale.net:8181/23520
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm/mach-imx/platsmp.c |   29 ++++++++++++++++++++++++++++-
 1 files changed, 28 insertions(+), 1 deletions(-)

diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index 0794bc1..cec6592 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -41,6 +41,7 @@ u32 g_diag_reg;
 static void __iomem *scu_base;
 static void __iomem *dcfg_base;
 static void __iomem *scfg_base;
+static void __iomem *dcsr_rcpm2_base;
 static u32 secondary_pre_boot_entry;
  
 static struct map_desc scu_io_desc __initdata = {
@@ -150,8 +151,25 @@ static int ls1021a_secondary_iomap(void)
 		goto scfg_err;
 	}
 
+	np = of_find_compatible_node(NULL, NULL, "fsl,ls1021a-dcsr-rcpm");
+	if (!np) {
+		pr_err("%s: failed to find dcsr node.\n", __func__);
+		ret = -EINVAL;
+		goto dcsr_err;
+	}
+
+	dcsr_rcpm2_base = of_iomap(np, 1);
+	of_node_put(np);
+	if (!dcsr_rcpm2_base) {
+		pr_err("%s: failed to map dcsr.\n", __func__);
+		ret = -ENOMEM;
+		goto dcsr_err;
+	}
+
 	return 0;
 
+dcsr_err:
+	iounmap(scfg_base);
 scfg_err:
 	iounmap(dcfg_base);
 dcfg_err:
@@ -176,7 +194,7 @@ static int ls1021a_reset_secondary(unsigned int cpu)
 {
 	u32 tmp;
 
-	if (!scfg_base || !dcfg_base)
+	if (!scfg_base || !dcfg_base || !dcsr_rcpm2_base)
 		return -ENOMEM;
 
 	writel_relaxed(secondary_pre_boot_entry,
@@ -190,6 +208,15 @@ static int ls1021a_reset_secondary(unsigned int cpu)
 	iowrite32be(0x80000000, scfg_base + SCFG_CORESRENCR);
 	iowrite32be(0x80000000, scfg_base +
 				SCFG_CORE0_SFT_RST + STRIDE_4B * cpu);
+	mdelay(6);
+
+	/* LS1021a errata. after reset, core state machine registers
+	 * need to force release manually.
+	 */
+	iowrite32be(0x00000080, dcsr_rcpm2_base + DCSR_RCPM2_DEBUG1);
+	iowrite32be(0x00000080, dcsr_rcpm2_base + DCSR_RCPM2_DEBUG2);
+	iowrite32be(0, dcsr_rcpm2_base + DCSR_RCPM2_DEBUG1);
+	iowrite32be(0, dcsr_rcpm2_base + DCSR_RCPM2_DEBUG2);
 
 	/* Release secondary core */
 	iowrite32be(1 << cpu, dcfg_base + DCFG_CCSR_BRR);
-- 
1.7.5.4

