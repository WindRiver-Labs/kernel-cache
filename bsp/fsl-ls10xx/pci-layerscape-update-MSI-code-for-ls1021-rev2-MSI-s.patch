From 4e3a0ae714af69ff6d798ef29a2fe943132426c2 Mon Sep 17 00:00:00 2001
From: Minghuan Lian <Minghuan.Lian@freescale.com>
Date: Mon, 8 Jun 2015 11:34:53 +0800
Subject: [PATCH 100/129] pci/layerscape: update MSI code for ls1021 rev2 MSI
 support

Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Change-Id: I68ac4e509f41c249d38579b34cb78d35e9231b0f
Reviewed-on: http://git.am.freescale.net:8181/37558
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Mingkai Hu <Mingkai.Hu@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin:Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/pci/host/pci-layerscape.c |  116 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 113 insertions(+), 3 deletions(-)

diff --git a/drivers/pci/host/pci-layerscape.c b/drivers/pci/host/pci-layerscape.c
index 4a6e62f..3344005 100644
--- a/drivers/pci/host/pci-layerscape.c
+++ b/drivers/pci/host/pci-layerscape.c
@@ -23,6 +23,7 @@
 #include <linux/resource.h>
 #include <linux/mfd/syscon.h>
 #include <linux/regmap.h>
+#include <linux/bitrev.h>
 
 #include "pcie-designware.h"
 
@@ -32,6 +33,13 @@
 #define LTSSM_STATE_MASK	0x3f
 #define LTSSM_PCIE_L0		0x11 /* L0 state */
 
+/* SCFG MSI register */
+#define SCFG_SPIMSICR		0x40
+#define SCFG_SPIMSICLRCR	0x90
+
+#define LS1021A_MSIIR_ADDR(idx)	(0x1570e00 + (idx) * 8)
+#define LS1021A_MSIR_OFF(idx)	(0x0e04 + (idx) * 8)
+
 /* Symbol Timer Register and Filter Mask Register 1 */
 #define PCIE_STRFMR1 0x71c
 
@@ -62,6 +70,65 @@ static int ls_pcie_link_up(struct pcie_port *pp)
 	return 1;
 }
 
+static u32 ls_pcie_get_msi_addr(struct pcie_port *pp)
+{
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+
+	return LS1021A_MSIIR_ADDR(pcie->index);
+}
+
+static u32 ls_pcie_get_msi_data(struct pcie_port *pp, int pos)
+{
+	return pos * 8;
+}
+
+static irqreturn_t ls_pcie_msi_irq_handler(int irq, void *data)
+{
+	struct pcie_port *pp = data;
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+	unsigned long val;
+	int msi_irq, ret, pos;
+
+	regmap_read(pcie->scfg, LS1021A_MSIR_OFF(pcie->index), (u32 *) &val);
+
+	if (val) {
+		ret = IRQ_HANDLED;
+		pos = 0;
+		while ((pos = find_next_bit(&val, 32, pos)) != 32) {
+			msi_irq = irq_find_mapping(pp->irq_domain, 31 - pos);
+			if (!msi_irq) {
+				/*
+				 * that's weird who triggered this?
+				 * just clear it
+				 */
+				dev_err(pcie->dev, "unexpected MSI\n");
+				ret = IRQ_NONE;
+				continue;
+			}
+
+	#if defined(CONFIG_PREEMPT_RT_FULL) || defined(CONFIG_PREEMPT_RTB)
+			local_irq_disable();
+	#endif
+			generic_handle_irq(msi_irq);
+	#if defined(CONFIG_PREEMPT_RT_FULL) || defined(CONFIG_PREEMPT_RTB)
+			local_irq_enable();
+	#endif
+			ret = IRQ_HANDLED;
+			pos++;
+		}
+	}
+
+	return ret;
+}
+
+static void ls_pcie_msi_clear_irq(struct pcie_port *pp, int irq)
+{
+}
+
+static void ls_pcie_msi_set_irq(struct pcie_port *pp, int irq)
+{
+}
+
 static void ls_pcie_host_init(struct pcie_port *pp)
 {
 	struct ls_pcie *pcie = to_ls_pcie(pp);
@@ -79,6 +146,7 @@ static void ls_pcie_host_init(struct pcie_port *pp)
 		}
 	}
 
+	if (of_device_is_compatible(pcie->dev->of_node, "fsl,ls1021a-pcie")) {
 	/*
 	 * LS1021A Workaround for internal TKT228622
 	 * to fix the INTx hang issue
@@ -86,11 +154,16 @@ static void ls_pcie_host_init(struct pcie_port *pp)
 	val = ioread32(pcie->dbi + PCIE_STRFMR1);
 	val &= 0xffff;
 	iowrite32(val, pcie->dbi + PCIE_STRFMR1);
+	}
 }
 
 static struct pcie_host_ops ls_pcie_host_ops = {
 	.link_up = ls_pcie_link_up,
 	.host_init = ls_pcie_host_init,
+	.msi_set_irq = ls_pcie_msi_set_irq,
+	.msi_clear_irq = ls_pcie_msi_clear_irq,
+	.get_msi_addr = ls_pcie_get_msi_addr,
+	.get_msi_data = ls_pcie_get_msi_data,
 };
 
 static int ls_add_pcie_port(struct ls_pcie *pcie)
@@ -98,9 +171,21 @@ static int ls_add_pcie_port(struct ls_pcie *pcie)
 	struct pcie_port *pp;
 	int ret;
 
+	if (!pcie)
+		return -EINVAL;
 	pp = &pcie->pp;
 	pp->dev = pcie->dev;
 	pp->dbi_base = pcie->dbi;
+	pp->msi_irq = pcie->msi_irq;
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		ret = devm_request_irq(pp->dev, pp->msi_irq,
+					ls_pcie_msi_irq_handler,
+					IRQF_SHARED, "ls-pcie-msi", pp);
+		if (ret) {
+			dev_err(pp->dev, "failed to request msi irq\n");
+			return ret;
+		}
+	}
 	pp->root_bus_nr = -1;
 	pp->ops = &ls_pcie_host_ops;
 
@@ -127,11 +212,13 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 	pcie->dev = &pdev->dev;
 
 	dbi_base = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");
-	pcie->dbi = devm_ioremap_resource(&pdev->dev, dbi_base);
-	if (IS_ERR(pcie->dbi)) {
+	if (!dbi_base) {
 		dev_err(&pdev->dev, "missing *regs* space\n");
-		return PTR_ERR(pcie->dbi);
+		return -ENODEV;
 	}
+	pcie->dbi = devm_ioremap_resource(&pdev->dev, dbi_base);
+	if (IS_ERR(pcie->dbi))
+		return PTR_ERR(pcie->dbi);
 
 	pcie->scfg = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
 						     "fsl,pcie-scfg");
@@ -146,6 +233,12 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 		return ret;
 	pcie->index = index[1];
 
+	pcie->msi_irq = platform_get_irq_byname(pdev, "msi");
+	if (pcie->msi_irq < 0) {
+		dev_err(&pdev->dev,
+			"failed to get MSI IRQ: %d\n", pcie->msi_irq);
+		return pcie->msi_irq;
+	}
 	ret = ls_add_pcie_port(pcie);
 	if (ret < 0)
 		return ret;
@@ -155,16 +248,33 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int ls_pcie_pm_suspend(struct device *dev)
+{
+	return 0;
+}
+static int ls_pcie_pm_resume(struct device *dev)
+{
+	struct ls_pcie *pcie = dev_get_drvdata(dev);
+	ls_pcie_host_init(&pcie->pp);
+	return 0;
+};
+#endif /* CONFIG_PM_SLEEP */
 static const struct of_device_id ls_pcie_of_match[] = {
 	{ .compatible = "fsl,ls1021a-pcie" },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, ls_pcie_of_match);
 
+static const struct dev_pm_ops ls_pcie_pm = {
+	SET_SYSTEM_SLEEP_PM_OPS(ls_pcie_pm_suspend, ls_pcie_pm_resume)
+};
 static struct platform_driver ls_pcie_driver = {
 	.driver = {
 		.name = "layerscape-pcie",
+		.owner = THIS_MODULE,
 		.of_match_table = ls_pcie_of_match,
+		.pm = &ls_pcie_pm,
 	},
 };
 
-- 
1.7.5.4

