From f75ddfa255046d077fe229e82617267382fd7e61 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 3 Dec 2014 17:10:44 +0200
Subject: [PATCH 064/129] gianfar: Disable Rx snooping for LS1

It was observed that Rx snooping incurs a significant
performance penalty.  My suspicion is that it interferes
with the DMA software coherency, currently performed
by DMA-API.  It is known that there are H/W coherency
issues at least for the Tx side (see read data interleaving
issue) which is why the software coherency is needed in the
first place.  This patch disables Rx snooping as well, as a
workaround, until the root cause for the Rx side coherency
related issue is found.

Change-Id: I00c3a5723d52d2f9a9d18e11b5c64c9c208c466b
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/25325
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
Reviewed-by: Matthew Weigel <Matthew.Weigel@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   29 ++++++++++++++++-------------
 drivers/net/ethernet/freescale/gianfar.h |    8 +++++++-
 2 files changed, 23 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index c9f1b3d..5402cfb 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -240,7 +240,7 @@ static int gfar_init_bds(struct net_device *ndev)
 			if (skb) {
 				bufaddr = be32_to_cpu(rxbdp->bufPtr);
 			} else {
-				skb = gfar_alloc_skb(ndev);
+				skb = gfar_new_skb(ndev, &bufaddr);
 				if (!skb) {
 					netdev_err(ndev, "Can't allocate RX buffers\n");
 					return -ENOMEM;
@@ -1864,9 +1864,7 @@ static int gfar_resume(struct device *dev)
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	u32 tempval;
-	int magic_packet = priv->wol_en &&
-			   (priv->device_flags &
-			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	u16 wol = priv->wol_opts;
 
 	if (!netif_running(ndev))
 		return 0;
@@ -2997,22 +2995,28 @@ static struct sk_buff *gfar_alloc_skb(struct net_device *dev)
 	return skb;
 }
 
-struct sk_buff *gfar_new_skb(struct net_device *dev)
+static struct sk_buff *gfar_new_skb(struct net_device *dev, dma_addr_t *bufaddr)
 {
        struct gfar_private *priv = netdev_priv(dev);
        struct sk_buff *skb;
+	dma_addr_t addr;
 
-       if (likely(priv->rx_buffer_size <= DEFAULT_RX_BUFFER_SIZE)) {
-               struct sk_buff_head *h = &__get_cpu_var(skb_recycle_list);
+	skb = gfar_alloc_skb(dev);
+	if (!skb)
+		return NULL;
 
-               skb = __skb_dequeue(h);
-               if (skb != NULL)
-                       return skb;
-       }
+	addr = dma_map_single(priv->dev, skb->data,
+			      priv->rx_buffer_size, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(priv->dev, addr))) {
+		dev_kfree_skb_any(skb);
+		return NULL;
+	}
 
-       return gfar_alloc_skb(dev);
+	*bufaddr = addr;
+	return skb;
 }
 
+
 irqreturn_t gfar_receive(int irq, void *grp_id)
 {
 	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
@@ -3042,7 +3046,6 @@ irqreturn_t gfar_receive(int irq, void *grp_id)
 
 	return IRQ_HANDLED;
 }
-EXPORT_SYMBOL(gfar_new_skb);
 
 /* Interrupt Handler for Transmit complete */
 static irqreturn_t gfar_transmit(int irq, void *grp_id)
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index e5b0869..ece1d08 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -29,6 +29,7 @@
 #include <linux/errno.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -490,7 +491,12 @@ extern const char gfar_driver_version[];
 #define ATTR_BUFSTASH		0x00004000
 
 #define ATTR_SNOOPING		0x000000c0
+
+#ifdef CONFIG_SOC_LS1021A
+#define ATTR_INIT_SETTINGS      0
+#else
 #define ATTR_INIT_SETTINGS      ATTR_SNOOPING
+#endif
 
 #define ATTRELI_INIT_SETTINGS   0x0
 #define ATTRELI_EL_MASK		0x3fff0000
@@ -1666,7 +1672,7 @@ static inline void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue,
 	if (bdp == rx_queue->rx_bd_base + rx_queue->rx_ring_size - 1)
 		lstatus |= BD_LFLAG(RXBD_WRAP);
 
-	eieio();
+	gfar_wmb();
 
 	bdp->lstatus = cpu_to_be32(lstatus);
 }
-- 
1.7.5.4

