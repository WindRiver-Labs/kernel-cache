From 4abd5d0c1abfa9758496f4c15fb17006dea71a3e Mon Sep 17 00:00:00 2001
From: Chenhui Zhao <chenhui.zhao@freescale.com>
Date: Thu, 7 May 2015 18:11:55 +0800
Subject: [PATCH 096/129] arm: ls1021a: add deep sleep support on
 TWR-LS1021A-PB

Add deep sleep support on TWR-LS1021A-PB, which has CPLD on board
instead of FPGA.

Enable the ftm0 node in .dts to enable wake-on-Flextimer feature.

Change-Id: I0b1234cdd80d852140964240234576705764cd89
Signed-off-by: Chenhui Zhao <chenhui.zhao@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/36250
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Dongsheng Wang <dongsheng.wang@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin:Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm/boot/dts/ls1021a-twr.dts |    9 ++++++
 arch/arm/mach-imx/pm-ls1.c        |   56 +++++++++++++++++++++++++------------
 2 files changed, 47 insertions(+), 18 deletions(-)

diff --git a/arch/arm/boot/dts/ls1021a-twr.dts b/arch/arm/boot/dts/ls1021a-twr.dts
index e829739..b39e4db 100644
--- a/arch/arm/boot/dts/ls1021a-twr.dts
+++ b/arch/arm/boot/dts/ls1021a-twr.dts
@@ -122,6 +122,10 @@
 	};
 };
 
+&ftm0 {
+       status = "okay";
+};
+
 &i2c0 {
 	status = "okay";
 };
@@ -165,6 +169,11 @@
 		bank-width = <2>;
 		device-width = <1>;
 	};
+
+        cpld@2,0 {
+                 compatible = "fsl,ls1021atwr-cpld";
+                 reg = <0x2 0x0 0x100>;
+        };
 };
 
 &lpuart0 {
diff --git a/arch/arm/mach-imx/pm-ls1.c b/arch/arm/mach-imx/pm-ls1.c
index b8bfdb5..50b0758 100644
--- a/arch/arm/mach-imx/pm-ls1.c
+++ b/arch/arm/mach-imx/pm-ls1.c
@@ -101,7 +101,7 @@ static struct ls1_pm_baseaddr ls1_pm_base;
 static unsigned int sleep_modes;
 static suspend_state_t ls1_pm_state;
 
-static void ls1_pm_iomap(void)
+static int ls1_pm_iomap(void)
 {
 	struct device_node *np;
 	void *base;
@@ -130,13 +130,24 @@ static void ls1_pm_iomap(void)
 	ls1_pm_base.dcfg = base;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,ls1021aqds-fpga");
-	base = of_iomap(np, 0);
-	BUG_ON(!base);
-	ls1_pm_base.fpga = base;
+	if (np) {
+		base = of_iomap(np, 0);
+		BUG_ON(!base);
+		ls1_pm_base.fpga = base;
+	} else {
+		np = of_find_compatible_node(NULL, NULL,
+					"fsl,ls1021atwr-cpld");
+		if (!np) {
+			pr_err("%s: Can not find cpld/fpga node.\n", __func__);
+			return -ENODEV;
+		}
+	}
 
 	base = ioremap(SRAM_CODE_BASE_PHY, PAGE_SIZE);
 	BUG_ON(!base);
 	ls1_pm_base.sram = base;
+
+	return 0;
 }
 
 static void ls1_pm_uniomap(void)
@@ -146,7 +157,10 @@ static void ls1_pm_uniomap(void)
 	iounmap(ls1_pm_base.dcsr_rcpm2);
 	iounmap(ls1_pm_base.scfg);
 	iounmap(ls1_pm_base.dcfg);
-	iounmap(ls1_pm_base.fpga);
+
+	if (ls1_pm_base.fpga)
+		iounmap(ls1_pm_base.fpga);
+
 	iounmap(ls1_pm_base.sram);
 }
 
@@ -299,15 +313,18 @@ static void ls1_enter_deepsleep(void)
 	/* setup the registers of the EPU FSM for deep sleep */
 	ls1_fsm_setup();
 
-	/* connect the EVENT button to IRQ in FPGA */
-	tmp = ioread8(ls1_pm_base.fpga + QIXIS_CTL_SYS);
-	tmp &= ~QIXIS_CTL_SYS_EVTSW_MASK;
-	tmp |= QIXIS_CTL_SYS_EVTSW_IRQ;
-	iowrite8(tmp, ls1_pm_base.fpga + QIXIS_CTL_SYS);
-
-	/* enable deep sleep signals in FPGA */
-	tmp = ioread8(ls1_pm_base.fpga + QIXIS_PWR_CTL2);
-	iowrite8(tmp | QIXIS_PWR_CTL2_PCTL, ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+	if (ls1_pm_base.fpga) {
+		/* connect the EVENT button to IRQ in FPGA */
+		tmp = ioread8(ls1_pm_base.fpga + QIXIS_CTL_SYS);
+		tmp &= ~QIXIS_CTL_SYS_EVTSW_MASK;
+		tmp |= QIXIS_CTL_SYS_EVTSW_IRQ;
+		iowrite8(tmp, ls1_pm_base.fpga + QIXIS_CTL_SYS);
+
+		/* enable deep sleep signals in FPGA */
+		tmp = ioread8(ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+		iowrite8(tmp | QIXIS_PWR_CTL2_PCTL,
+				ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+	}
 
 	/* enable Warm Device Reset */
 	ls1_clrsetbits_be32(ls1_pm_base.scfg + CCSR_SCFG_DPSLPCR,
@@ -329,9 +346,12 @@ static void ls1_enter_deepsleep(void)
 	ls1_clrsetbits_be32(ls1_pm_base.scfg + CCSR_SCFG_DPSLPCR,
 			    CCSR_SCFG_DPSLPCR_VAL, 0);
 
-	/* disable deep sleep signals in FPGA */
-	tmp = ioread8(ls1_pm_base.fpga + QIXIS_PWR_CTL2);
-	iowrite8(tmp & ~QIXIS_PWR_CTL2_PCTL, ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+	if (ls1_pm_base.fpga) {
+		/* disable deep sleep signals in FPGA */
+		tmp = ioread8(ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+		iowrite8(tmp & ~QIXIS_PWR_CTL2_PCTL,
+				ls1_pm_base.fpga + QIXIS_PWR_CTL2);
+	}
 }
 
 static void ls1_set_power_except(struct device *dev, int on)
@@ -414,7 +434,7 @@ static int ls1_suspend_begin(suspend_state_t state)
 	dpm_for_each_dev(NULL, ls1_set_wakeup_device);
 
 	if (ls1_pm_state == PM_SUSPEND_MEM)
-		ls1_pm_iomap();
+		return ls1_pm_iomap();
 
 	return 0;
 }
-- 
1.7.5.4

