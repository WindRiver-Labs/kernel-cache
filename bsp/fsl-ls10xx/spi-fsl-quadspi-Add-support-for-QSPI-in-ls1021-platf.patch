From ed8b43310c20cee3a7b044e9f8cafee17b0d2e9a Mon Sep 17 00:00:00 2001
From: Chao Fu <B44548@freescale.com>
Date: Wed, 4 Jun 2014 14:59:33 +0800
Subject: [PATCH 185/255] spi:fsl-quadspi:Add support for QSPI in ls1021
 platform

Signed-off-by: Chao Fu <B44548@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/spi-fsl-quadspi.c | 243 ++++++++++++++++++++++++++++--------------
 1 file changed, 163 insertions(+), 80 deletions(-)

diff --git a/drivers/spi/spi-fsl-quadspi.c b/drivers/spi/spi-fsl-quadspi.c
index 0027775..d8b4bba 100644
--- a/drivers/spi/spi-fsl-quadspi.c
+++ b/drivers/spi/spi-fsl-quadspi.c
@@ -117,6 +117,7 @@
 #define SERE_SEQID			7
 #define TX_SEQID			8
 #define RX_SEQID			9
+#define FSRD_SEQID			0xa
 
 /* Field definitions for IPCR */
 #define QSPI_IPCR_SEQID_SHIFT	24
@@ -150,7 +151,6 @@
 #define MODE2_DDR		12
 #define MODE4_DDR		13
 
-#define PSP_QSPI0_MEMMAP_BASE	0x20000000
 #define RX_BUFFER_SIZE		0x80
 #define TX_BUFFER_SIZE		0x40
 #define POS_LOCATION_MASK	0xFFFFFF00
@@ -174,6 +174,7 @@
 #define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+#define	OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
 
 #define	FLASHSR_WIP		1	/* Write in progress */
 
@@ -191,12 +192,32 @@ struct fsl_qspi {
 	wait_queue_head_t waitt;
 	u32 waitflag_r;
 	u32 waitflag_t;
+	unsigned long amba_base;
+	bool big_endian;
 
 };
 
+static inline void qspi_writel(struct fsl_qspi *q, u32 val, void __iomem *addr)
+{
+	q->big_endian ? __raw_writel(cpu_to_be32(val), addr) :
+			__raw_writel(cpu_to_le32(val), addr);
+}
+
+static inline u32 qspi_readl(struct fsl_qspi *q, void __iomem *addr)
+{
+	return q->big_endian ? cpu_to_be32((__force u32) __raw_readl(addr)) :
+				cpu_to_le32((__force u32) __raw_readl(addr));
+}
+
+static inline u32 qspi_endian_xchg(struct fsl_qspi *q, u32 data)
+{
+	return q->big_endian ? data : swab32(data);
+}
+
 static inline unsigned int fsl_qspi_is_busy(struct fsl_qspi *fsl_qspi)
 {
-	return readl(fsl_qspi->iobase + QSPI_SR) & QSPI_SR_BUSY_MASK;
+	return qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_SR)
+						& QSPI_SR_BUSY_MASK;
 }
 
 static void fsl_qspi_wait_do_timer(unsigned long arg)
@@ -208,10 +229,10 @@ static void fsl_qspi_wait_do_timer(unsigned long arg)
 static irqreturn_t fsl_qspi_irq_handler(int this_irq, void *dev_id)
 {
 	struct fsl_qspi *fsl_qspi = dev_id;
-	u32 reg_fr = readl(fsl_qspi->iobase + QSPI_FR);
+	u32 reg_fr = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_FR);
 
 	/* clear interrupt */
-	writel(reg_fr, fsl_qspi->iobase + QSPI_FR);
+	qspi_writel(fsl_qspi, reg_fr, fsl_qspi->iobase + QSPI_FR);
 	if (reg_fr & QSPI_FR_TFF_MASK) {
 		if (fsl_qspi->waitflag_r) {
 			fsl_qspi->waitflag_r = 0;
@@ -232,58 +253,73 @@ static void fsl_qspi_set_lut(struct fsl_qspi *fsl_qspi)
 	u32 lut_base;
 
 	/* Unlock the LUT */
-	writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
-	writel(QSPI_LCKCR_UNLOCK, fsl_qspi->iobase + QSPI_LCKCR);
+	qspi_writel(fsl_qspi, KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+	qspi_writel(fsl_qspi, QSPI_LCKCR_UNLOCK, fsl_qspi->iobase + QSPI_LCKCR);
 
 	/* SEQID  - Write enable */
 	lut_base = WRTEN_SEQID * 4;
-	writel(OPRND0(OPCODE_WREN) | PAD0(0x0) | INSTR0(CMD),
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_WREN) | PAD0(0x0) | INSTR0(CMD),
 			fsl_qspi->iobase + QSPI_LUT(lut_base));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
 	/* SEQID  - Read Status */
 	lut_base = READSTATU_SEQID * 4;
-	writel(OPRND0(OPCODE_RDSR) | PAD0(0x0) | INSTR0(CMD) |
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_RDSR) | PAD0(0x0) | INSTR0(CMD) |
 			OPRND1(0x1) | PAD1(0x0) | INSTR1(READ),
 			fsl_qspi->iobase + QSPI_LUT(lut_base));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
 	/* SEQID  - Read Flash ID */
 	lut_base = RDID_SEQID * 4;
-	writel(OPRND0(OPCODE_RDID) | PAD0(0x0) | INSTR0(CMD) |
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_RDID) | PAD0(0x0) | INSTR0(CMD) |
 			OPRND1(0x5) | PAD1(0x0) | INSTR1(READ),
 			fsl_qspi->iobase + QSPI_LUT(lut_base));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
 	/* SEQID  - Recevie transfer */
 	lut_base = RX_SEQID * 4;
-	writel(OPRND0(OPCODE_NORM_READ) | PAD0(0x0) | INSTR0(CMD) |
-			  OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR),
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_NORM_READ) | PAD0(0x0) |
+				INSTR0(CMD) | OPRND1(ADDR24BIT) |
+				PAD1(0x0) | INSTR1(ADDR),
 			fsl_qspi->iobase + QSPI_LUT(lut_base));
-	writel(OPRND0(RX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(READ),
+	qspi_writel(fsl_qspi, OPRND0(RX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(READ),
 			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
 	/* SEQID  - Send Transfer */
 	lut_base = TX_SEQID * 4;
-	writel(OPRND0(OPCODE_PP) | PAD0(0x0) | INSTR0(CMD)
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_PP) | PAD0(0x0) | INSTR0(CMD)
 			 | OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR),
 			fsl_qspi->iobase + QSPI_LUT(lut_base));
-	writel(OPRND0(TX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(WRITE),
+	qspi_writel(fsl_qspi,
+			OPRND0(TX_BUFFER_SIZE) | PAD0(0x0) | INSTR0(WRITE),
 			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-	writel(0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+
+	/* SEQID  - Receive transfer Fast Read */
+	lut_base = FSRD_SEQID * 4;
+	qspi_writel(fsl_qspi, OPRND0(OPCODE_FAST_READ) |
+			PAD0(0) | INSTR0(CMD) | OPRND1(ADDR24BIT) |
+			PAD1(0) | INSTR1(ADDR),
+			fsl_qspi->iobase + QSPI_LUT(lut_base));
+	qspi_writel(fsl_qspi, OPRND0(8) | PAD0(0) | INSTR0(DUMMY) |
+			OPRND1(RX_BUFFER_SIZE) | PAD1(0) |
+			INSTR1(READ),
+			fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 
 	/* Lock the LUT */
-	writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
-	writel(QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
+	qspi_writel(fsl_qspi, KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
+	qspi_writel(fsl_qspi, QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
 }
 
 static void waiting_flash_ready(struct fsl_qspi *fsl_qspi,
@@ -301,19 +337,20 @@ static void waiting_flash_ready(struct fsl_qspi *fsl_qspi,
 			dev_err(fsl_qspi->dev, "tired waiting for end status\n");
 			break;
 		}
-		writel((READSTATU_SEQID << QSPI_IPCR_SEQID_SHIFT)
+		qspi_writel(fsl_qspi, (READSTATU_SEQID << QSPI_IPCR_SEQID_SHIFT)
 				| DEFALUT_SIZE, fsl_qspi->iobase + QSPI_IPCR);
 		fsl_qspi->waitflag_t = 1;
 		wait_event(fsl_qspi->waitt, !fsl_qspi->waitflag_t);
 
-		reg = readl(fsl_qspi->iobase + QSPI_RBSR);
+		reg = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_RBSR);
 		if (reg & QSPI_RBSR_RDBFL_MASK)
-			status_reg = readl(fsl_qspi->iobase +
+			status_reg = qspi_readl(fsl_qspi, fsl_qspi->iobase +
 					QSPI_RBDR);
 
-		writel(readl(fsl_qspi->iobase + QSPI_MCR) |
-				QSPI_MCR_CLR_RXF_MASK,
-				fsl_qspi->iobase + QSPI_MCR);
+		qspi_writel(fsl_qspi,
+			qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_MCR) |
+			QSPI_MCR_CLR_RXF_MASK,
+			fsl_qspi->iobase + QSPI_MCR);
 		count++;
 	}
 	del_timer(&fsl_qspi->wait_timer);
@@ -321,6 +358,8 @@ static void waiting_flash_ready(struct fsl_qspi *fsl_qspi,
 
 static void set_lut(struct fsl_qspi *fsl_qspi, u8 opr, u8 *seqid)
 {
+	u32 lut[4] = {0}, lut_base;
+
 	switch (opr) {
 	case OPCODE_RDID:
 		*seqid = RDID_SEQID;
@@ -328,7 +367,35 @@ static void set_lut(struct fsl_qspi *fsl_qspi, u8 opr, u8 *seqid)
 	case OPCODE_RDSR:
 		*seqid = READSTATU_SEQID;
 		break;
+	case OPCODE_FAST_READ:
+		lut_base = RX_SEQID * 4;
+		qspi_writel(fsl_qspi, OPRND0(OPCODE_FAST_READ) |
+				PAD0(0) | INSTR0(CMD) | OPRND1(ADDR24BIT) |
+				PAD1(0) | INSTR1(ADDR),
+				fsl_qspi->iobase + QSPI_LUT(lut_base));
+		qspi_writel(fsl_qspi, OPRND0(8) | PAD0(0) | INSTR0(DUMMY) |
+				OPRND1(RX_BUFFER_SIZE) | PAD1(0) |
+				INSTR1(READ),
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+		qspi_writel(fsl_qspi, 0x0,
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+		qspi_writel(fsl_qspi, 0x0,
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+		*seqid = RX_SEQID;
+		break;
 	case OPCODE_NORM_READ:
+		lut_base = RX_SEQID * 4;
+		qspi_writel(fsl_qspi, OPRND0(OPCODE_NORM_READ) |
+				PAD0(0x0) | INSTR0(CMD) |
+				OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR),
+				fsl_qspi->iobase + QSPI_LUT(lut_base));
+		qspi_writel(fsl_qspi, OPRND0(RX_BUFFER_SIZE) |
+					PAD0(0x0) | INSTR0(READ),
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+		qspi_writel(fsl_qspi, 0x0,
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+		qspi_writel(fsl_qspi, 0x0,
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
 		*seqid = RX_SEQID;
 		break;
 	case OPCODE_WREN:
@@ -340,19 +407,26 @@ static void set_lut(struct fsl_qspi *fsl_qspi, u8 opr, u8 *seqid)
 	case OPCODE_SE:
 	case OPCODE_BE_4K:
 	case OPCODE_BE_32K: {
-		u32 lut[4] = {0}, lut_base;
 		lut[0] = OPRND0(opr) | PAD0(0x0) | INSTR0(CMD)
 			| OPRND1(ADDR24BIT) | PAD1(0x0) | INSTR1(ADDR);
 		lut_base = SERE_SEQID * 4;
 		*seqid = SERE_SEQID;
-		writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
-		writel(QSPI_LCKCR_UNLOCK, fsl_qspi->iobase + QSPI_LCKCR);
-		writel(lut[0], fsl_qspi->iobase + QSPI_LUT(lut_base));
-		writel(lut[1], fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
-		writel(lut[2], fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
-		writel(lut[3], fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
-		writel(KEY_VALUE, fsl_qspi->iobase + QSPI_LUTKEY);
-		writel(QSPI_LCKCR_LOCK, fsl_qspi->iobase + QSPI_LCKCR);
+		qspi_writel(fsl_qspi, KEY_VALUE,
+				fsl_qspi->iobase + QSPI_LUTKEY);
+		qspi_writel(fsl_qspi, QSPI_LCKCR_UNLOCK,
+				fsl_qspi->iobase + QSPI_LCKCR);
+		qspi_writel(fsl_qspi, lut[0],
+				fsl_qspi->iobase + QSPI_LUT(lut_base));
+		qspi_writel(fsl_qspi, lut[1],
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 1));
+		qspi_writel(fsl_qspi, lut[2],
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 2));
+		qspi_writel(fsl_qspi, lut[3],
+				fsl_qspi->iobase + QSPI_LUT(lut_base + 3));
+		qspi_writel(fsl_qspi, KEY_VALUE,
+				fsl_qspi->iobase + QSPI_LUTKEY);
+		qspi_writel(fsl_qspi, QSPI_LCKCR_LOCK,
+				fsl_qspi->iobase + QSPI_LCKCR);
 		break;
 	}
 	default:
@@ -367,13 +441,13 @@ static void fsl_qspi_do_rx(struct fsl_qspi *fsl_qspi, u32 position,
 {
 	u32 tmp, i, size;
 
-	position += PSP_QSPI0_MEMMAP_BASE;
+	position += fsl_qspi->amba_base;
 	while (count > 0) {
-		writel(position, fsl_qspi->iobase + QSPI_SFAR);
+		qspi_writel(fsl_qspi, position, fsl_qspi->iobase + QSPI_SFAR);
 		size = (count > RX_BUFFER_SIZE) ?
 			RX_BUFFER_SIZE : count;
 
-		writel(RX_SEQID << QSPI_IPCR_SEQID_SHIFT | size,
+		qspi_writel(fsl_qspi, RX_SEQID << QSPI_IPCR_SEQID_SHIFT | size,
 				fsl_qspi->iobase + QSPI_IPCR);
 		fsl_qspi->waitflag_r = 1;
 		wait_event(fsl_qspi->waitr, !fsl_qspi->waitflag_r);
@@ -383,16 +457,17 @@ static void fsl_qspi_do_rx(struct fsl_qspi *fsl_qspi, u32 position,
 
 		i = 0;
 		while ((RX_BUFFER_SIZE >= size) && (size > 0)) {
-			tmp = readl(fsl_qspi->iobase + QSPI_RBDR +
-					i * 4);
+			tmp = qspi_readl(fsl_qspi,
+					fsl_qspi->iobase + QSPI_RBDR + i * 4);
 			*rxbuf = cpu_to_be32(tmp);
 			rxbuf++;
 			size -= 4;
 			i++;
 		}
 
-		writel(readl(fsl_qspi->iobase + QSPI_MCR) |
-				QSPI_MCR_CLR_RXF_MASK,
+		qspi_writel(fsl_qspi, qspi_readl(fsl_qspi,
+				fsl_qspi->iobase + QSPI_MCR)
+				| QSPI_MCR_CLR_RXF_MASK,
 				fsl_qspi->iobase + QSPI_MCR);
 	}
 
@@ -403,11 +478,12 @@ static void fsl_qspi_do_tx(struct fsl_qspi *fsl_qspi,
 {
 	u32 tmp, i, j, size, tx_size;
 
-	position += PSP_QSPI0_MEMMAP_BASE;
+	position += fsl_qspi->amba_base;
 
 	while (count > 0) {
-		writel(position, fsl_qspi->iobase + QSPI_SFAR);
-		writel((WRTEN_SEQID << QSPI_IPCR_SEQID_SHIFT) | 0,
+		qspi_writel(fsl_qspi, position, fsl_qspi->iobase + QSPI_SFAR);
+		qspi_writel(fsl_qspi,
+				(WRTEN_SEQID << QSPI_IPCR_SEQID_SHIFT) | 0,
 				fsl_qspi->iobase + QSPI_IPCR);
 
 		tx_size = (count > TX_BUFFER_SIZE) ?
@@ -420,17 +496,20 @@ static void fsl_qspi_do_tx(struct fsl_qspi *fsl_qspi,
 		i = (size > 16) ? 16 : size;
 		for (j = 0; j < i; j++) {
 			tmp = cpu_to_be32(*txbuf);
-			writel(tmp, fsl_qspi->iobase + QSPI_TBDR);
+			qspi_writel(fsl_qspi, tmp,
+					fsl_qspi->iobase + QSPI_TBDR);
 			txbuf++;
 		}
 
-		writel(TX_SEQID << QSPI_IPCR_SEQID_SHIFT | tx_size,
+		qspi_writel(fsl_qspi,
+				TX_SEQID << QSPI_IPCR_SEQID_SHIFT | tx_size,
 				fsl_qspi->iobase + QSPI_IPCR);
 		waiting_flash_ready(fsl_qspi, cpu_to_be32(FLASHSR_WIP));
 
 		for (j = i; j < size; j++) {
 			tmp = cpu_to_be32(*txbuf);
-			writel(tmp, fsl_qspi->iobase + QSPI_TBDR);
+			qspi_writel(fsl_qspi, tmp,
+					fsl_qspi->iobase + QSPI_TBDR);
 			txbuf++;
 		}
 
@@ -441,9 +520,9 @@ static void fsl_qspi_do_tx(struct fsl_qspi *fsl_qspi,
 static void fsl_qspi_do_tx_cmd(struct fsl_qspi *fsl_qspi,
 		u32 position, u8 seqid)
 {
-	position += PSP_QSPI0_MEMMAP_BASE;
-	writel(position, fsl_qspi->iobase + QSPI_SFAR);
-	writel((seqid << QSPI_IPCR_SEQID_SHIFT) | 0,
+	position += fsl_qspi->amba_base;
+	qspi_writel(fsl_qspi, position, fsl_qspi->iobase + QSPI_SFAR);
+	qspi_writel(fsl_qspi, (seqid << QSPI_IPCR_SEQID_SHIFT) | 0,
 			fsl_qspi->iobase + QSPI_IPCR);
 
 	fsl_qspi->waitflag_t = 1;
@@ -461,12 +540,12 @@ static int fsl_qspi_do_one_msg(struct spi_master *master,
 	u32 mcr_reg = 0;
 	struct fsl_qspi *fsl_qspi = spi_master_get_devdata(master);
 
-	writel(INT_TFIE, fsl_qspi->iobase + QSPI_RSER);
-	mcr_reg = readl(fsl_qspi->iobase + QSPI_MCR);
-	writel(QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
+	qspi_writel(fsl_qspi, INT_TFIE, fsl_qspi->iobase + QSPI_RSER);
+	mcr_reg = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_MCR);
+	qspi_writel(fsl_qspi, QSPI_MCR_CLR_RXF_MASK | QSPI_MCR_CLR_TXF_MASK |
 			QSPI_MCR_RESERVED_MASK,
 			fsl_qspi->iobase + QSPI_MCR);
-	writel(QSPI_RBCT_WMRK_MASK | QSPI_RBCT_RXBRD_USEIPS,
+	qspi_writel(fsl_qspi, QSPI_RBCT_WMRK_MASK | QSPI_RBCT_RXBRD_USEIPS,
 			fsl_qspi->iobase + QSPI_RBCT);
 
 	list_for_each_entry(t, &m->transfers, transfer_list) {
@@ -503,7 +582,7 @@ static int fsl_qspi_do_one_msg(struct spi_master *master,
 
 	}
 
-	writel(mcr_reg, fsl_qspi->iobase + QSPI_MCR);
+	qspi_writel(fsl_qspi, mcr_reg, fsl_qspi->iobase + QSPI_MCR);
 
 	m->status = status;
 	spi_finalize_current_message(master);
@@ -530,43 +609,44 @@ static int fsl_qspi_setup(struct spi_device *spi)
 		return -EINVAL;
 	}
 
-	writel(QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK,
+	qspi_writel(fsl_qspi, QSPI_MCR_RESERVED_MASK | QSPI_MCR_MDIS_MASK,
 			fsl_qspi->iobase + QSPI_MCR);
 
-	reg_val = readl(fsl_qspi->iobase + QSPI_SMPR);
+	reg_val = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_SMPR);
 
-	writel(reg_val & ~(QSPI_SMPR_FSDLY_MASK
+	qspi_writel(fsl_qspi, reg_val & ~(QSPI_SMPR_FSDLY_MASK
 				| QSPI_SMPR_FSPHS_MASK
 				| QSPI_SMPR_HSENA_MASK),
 			fsl_qspi->iobase + QSPI_SMPR);
 
-	writel(QSPI_MCR_RESERVED_MASK, fsl_qspi->iobase + QSPI_MCR);
+	qspi_writel(fsl_qspi, QSPI_MCR_RESERVED_MASK,
+			fsl_qspi->iobase + QSPI_MCR);
 
-	writel(TPADA | PSP_QSPI0_MEMMAP_BASE,
+	qspi_writel(fsl_qspi, TPADA | fsl_qspi->amba_base,
 			fsl_qspi->iobase + QSPI_SFA1AD);
-	writel(TPADA | PSP_QSPI0_MEMMAP_BASE,
+	qspi_writel(fsl_qspi, TPADA | fsl_qspi->amba_base,
 			fsl_qspi->iobase + QSPI_SFA2AD);
-	writel(TPADB | PSP_QSPI0_MEMMAP_BASE,
+	qspi_writel(fsl_qspi, TPADB | fsl_qspi->amba_base,
 			fsl_qspi->iobase + QSPI_SFB1AD);
-	writel(TPADB | PSP_QSPI0_MEMMAP_BASE,
+	qspi_writel(fsl_qspi, TPADB | fsl_qspi->amba_base,
 			fsl_qspi->iobase + QSPI_SFB2AD);
 
 	fsl_qspi_set_lut(fsl_qspi);
 
 	reg_val = 0;
 	reg_val |= QSPI_MCR_RESERVED_MASK;
-	smpr_val = readl(fsl_qspi->iobase + QSPI_SMPR);
+	smpr_val = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_SMPR);
 	smpr_val &= ~QSPI_SMPR_DDRSMP_MASK;
-	writel(smpr_val, fsl_qspi->iobase + QSPI_SMPR);
+	qspi_writel(fsl_qspi, smpr_val, fsl_qspi->iobase + QSPI_SMPR);
 	reg_val &= ~QSPI_MCR_DDR_EN_MASK;
-	writel(reg_val, fsl_qspi->iobase + QSPI_MCR);
+	qspi_writel(fsl_qspi, reg_val, fsl_qspi->iobase + QSPI_MCR);
 
 	seq_id = 0;
-	reg_val = readl(fsl_qspi->iobase + QSPI_BFGENCR);
+	reg_val = qspi_readl(fsl_qspi, fsl_qspi->iobase + QSPI_BFGENCR);
 	reg_val &= ~QSPI_BFGENCR_SEQID_MASK;
 	reg_val |= (seq_id << QSPI_BFGENCR_SEQID_SHIFT);
 	reg_val &= ~QSPI_BFGENCR_PAR_EN_MASK;
-	writel(reg_val, fsl_qspi->iobase + QSPI_BFGENCR);
+	qspi_writel(fsl_qspi, reg_val, fsl_qspi->iobase + QSPI_BFGENCR);
 
 	return 0;
 }
@@ -640,6 +720,9 @@ static int fsl_qspi_probe(struct platform_device *pdev)
 		goto out_clk_disable;
 	}
 
+	fsl_qspi->big_endian = of_property_read_bool(np, "big-endian");
+	of_property_read_u32(np, "amba-base", (u32 *)&fsl_qspi->amba_base);
+
 	init_timer(&fsl_qspi->wait_timer);
 	fsl_qspi->wait_timer.function = &fsl_qspi_wait_do_timer;
 	fsl_qspi->wait_timer.data = (unsigned long)fsl_qspi;
@@ -684,8 +767,8 @@ static int fsl_qspi_remove(struct platform_device *pdev)
 	struct fsl_qspi *fsl_qspi = spi_master_get_devdata(master);
 
 	/* disable the hardware */
-	writel(0x0, fsl_qspi->iobase + QSPI_MCR);
-	writel(0x0, fsl_qspi->iobase + QSPI_RSER);
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_MCR);
+	qspi_writel(fsl_qspi, 0x0, fsl_qspi->iobase + QSPI_RSER);
 
 	clk_disable_unprepare(fsl_qspi->clk);
 	spi_master_put(master);
-- 
2.0.2

