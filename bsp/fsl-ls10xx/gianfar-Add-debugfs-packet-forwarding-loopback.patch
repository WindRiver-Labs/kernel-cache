From 54e47e6ceb9d67036ef301e45d666b9c2f64d8a9 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 13 Aug 2014 11:13:53 +0300
Subject: [PATCH 060/129] gianfar: Add debugfs packet forwarding loopback

Add the GFAR_DBG_LOOP config option and debugfs support
to be able to configure packet forwarding loops in the
Gianfar driver.  This config option is disabled by default
and should be used only for debugging/ benchmarking
purposes.
For details on how to configure a packet forwarding debug
loop refer to the help section of CONFIG_GFAR_DBG_LOOP.

Change-Id: I24d440edc4c7d63a055205e022b743e30f58409b
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/22861
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
Tested-by: Richard Schmitt <richard.schmitt@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c         |   23 +++-
 drivers/net/ethernet/freescale/gianfar.h         |   17 +++
 drivers/net/ethernet/freescale/gianfar_debugfs.c |  157 ++++++++++++++++++++++
 3 files changed, 195 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/gianfar_debugfs.c

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 36a6265..bc9d5e5 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1565,6 +1565,8 @@ static int gfar_probe(struct platform_device *ofdev)
 		netdev_info(dev, "TX BD ring size for Q[%d]: %d\n",
 			    i, priv->tx_queue[i]->tx_ring_size);
 
+	gfar_dbg_ndev_init(priv);
+
 	return 0;
 
 register_fail:
@@ -1584,8 +1586,12 @@ static int gfar_remove(struct platform_device *ofdev)
 {
 	struct gfar_private *priv = platform_get_drvdata(ofdev);
 
-	of_node_put(priv->phy_node);
-	of_node_put(priv->tbi_node);
+	gfar_dbg_ndev_exit(priv);
+
+	if (priv->phy_node)
+		of_node_put(priv->phy_node);
+	if (priv->tbi_node)
+		of_node_put(priv->tbi_node);
 
 	unregister_netdev(priv->ndev);
 	unmap_group_regs(priv);
@@ -3122,6 +3128,15 @@ static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 				       be16_to_cpu(fcb->vlctl));
 
 	/* Send the packet up the stack */
+#ifdef CONFIG_GFAR_DBG_LOOP
+	if (likely(priv->dbg_ndev_loopbk_tgt)) {
+		skb->dev = priv->dbg_ndev_loopbk_tgt;
+		skb->queue_mapping = 0;
+		skb_push(skb, ETH_HLEN);
+		gfar_start_xmit(skb, priv->dbg_ndev_loopbk_tgt);
+		return;
+	}
+#endif
 	napi_gro_receive(napi, skb);
 
 }
@@ -3858,6 +3873,8 @@ static int __init gfar_init(void)
 {
 	int i;
 
+	gfar_dbg_init();
+
 	for_each_possible_cpu(i) {
 		struct sk_buff_head *h = &per_cpu(skb_recycle_list, i);
 		skb_queue_head_init(h);
@@ -3870,6 +3887,8 @@ static void __exit gfar_exit(void)
 {
 	int i;
 
+	gfar_dbg_exit();
+
 	for_each_possible_cpu(i) {
 		struct sk_buff_head *h = &per_cpu(skb_recycle_list, i);
 		skb_queue_purge(h);
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index b6d6016..4558d6d 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1382,6 +1382,11 @@ struct gfar_private {
 	/*Filer table*/
 	unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 	unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
+#ifdef CONFIG_GFAR_DBG_LOOP
+	struct dentry *dbg_ndev_dir;
+	struct list_head dbg_ndev_node;
+	struct net_device *dbg_ndev_loopbk_tgt;
+#endif
 };
 
 #define BD_RING_REG_SZ(priv) ( \
@@ -1515,6 +1520,18 @@ void gfar_phy_test(struct mii_bus *bus, struct phy_device *phydev, int enable,
 void gfar_configure_coalescing_all(struct gfar_private *priv);
 int gfar_set_features(struct net_device *dev, netdev_features_t features);
 
+#ifdef CONFIG_GFAR_DBG_LOOP
+void gfar_dbg_init(void);
+void gfar_dbg_exit(void);
+void gfar_dbg_ndev_init(struct gfar_private *priv);
+void gfar_dbg_ndev_exit(struct gfar_private *priv);
+#else
+static inline void gfar_dbg_init(void) {}
+static inline void gfar_dbg_exit(void) {}
+static inline void gfar_dbg_ndev_init(struct gfar_private *priv) {}
+static inline void gfar_dbg_ndev_exit(struct gfar_private *priv) {}
+#endif
+
 extern const struct ethtool_ops gfar_ethtool_ops;
 
 #define MAX_FILER_CACHE_IDX (2*(MAX_FILER_IDX))
diff --git a/drivers/net/ethernet/freescale/gianfar_debugfs.c b/drivers/net/ethernet/freescale/gianfar_debugfs.c
new file mode 100644
index 0000000..b8f5e4c
--- /dev/null
+++ b/drivers/net/ethernet/freescale/gianfar_debugfs.c
@@ -0,0 +1,157 @@
+/* Copyright 2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/debugfs.h>
+
+#include "gianfar.h"
+
+static struct dentry *gfar_dbg_root;
+LIST_HEAD(gfar_dbg_ndevs);
+
+static ssize_t gfar_dbg_ndev_loopbk_read(struct file *f,
+					 char __user *buf,
+					 size_t count, loff_t *ppos)
+{
+	struct gfar_private *priv = f->private_data;
+	const char *name = NULL;
+	const char *b;
+	int len;
+
+	if (*ppos != 0)
+		return 0;
+
+	if (priv->dbg_ndev_loopbk_tgt)
+		name = priv->dbg_ndev_loopbk_tgt->name;
+
+	b = kasprintf(GFP_KERNEL, "%s\n", name ? name : "off");
+
+	if (!b)
+		return -ENOMEM;
+
+	if (count < strlen(b)) {
+		kfree(b);
+		return -ENOSPC;
+	}
+
+	len = simple_read_from_buffer(buf, count, ppos, b, strlen(b));
+
+	kfree(b);
+
+	return len;
+}
+
+static ssize_t gfar_dbg_ndev_loopbk_write(struct file *f,
+					  const char __user *buf,
+					  size_t count, loff_t *ppos)
+{
+	struct gfar_private *priv = f->private_data;
+	struct gfar_private *gfar_dbg_priv = NULL;
+	int found = 0;
+
+	if (*ppos != 0)
+		return 0;
+
+	if (!strncmp("off", buf, count - 1) || !strncmp("0", buf, count - 1))
+		goto update;
+
+	list_for_each_entry(gfar_dbg_priv, &gfar_dbg_ndevs, dbg_ndev_node) {
+		const char *name = gfar_dbg_priv->ndev->name;
+		if ((strlen(name) == count - 1) &&
+		    !strncmp(buf, name, count - 1)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		pr_err("Invalid loopback target device name!\n");
+		return count;
+	}
+
+update:
+	priv->dbg_ndev_loopbk_tgt = NULL;
+	if (gfar_dbg_priv)
+		priv->dbg_ndev_loopbk_tgt = gfar_dbg_priv->ndev;
+
+	return count;
+}
+
+static const struct file_operations gfar_dbg_ndev_loopbk_fops = {
+	.owner = THIS_MODULE,
+	.open = simple_open,
+	.read = gfar_dbg_ndev_loopbk_read,
+	.write = gfar_dbg_ndev_loopbk_write
+};
+
+void gfar_dbg_ndev_init(struct gfar_private *priv)
+{
+	const char *name = priv->ndev->name;
+	struct dentry *f;
+
+	priv->dbg_ndev_dir = debugfs_create_dir(name, gfar_dbg_root);
+	if (!priv->dbg_ndev_dir) {
+		pr_err("debugfs init failed for %s\n", name);
+		return;
+	}
+
+	f = debugfs_create_file("lo", 0600, priv->dbg_ndev_dir,
+				priv, &gfar_dbg_ndev_loopbk_fops);
+	if (!f) {
+		pr_err("debugfs failed to init loopback for %s\n", name);
+		return;
+	}
+
+	list_add(&priv->dbg_ndev_node, &gfar_dbg_ndevs);
+}
+
+void gfar_dbg_ndev_exit(struct gfar_private *priv)
+{
+	if (!priv->dbg_ndev_dir)
+		return;
+
+	list_del(&priv->dbg_ndev_node);
+
+	debugfs_remove_recursive(priv->dbg_ndev_dir);
+	priv->dbg_ndev_dir = NULL;
+	priv->dbg_ndev_loopbk_tgt = NULL;
+}
+
+void gfar_dbg_init(void)
+{
+	gfar_dbg_root = debugfs_create_dir(KBUILD_MODNAME, NULL);
+	if (!gfar_dbg_root)
+		pr_err("debugfs init failed\n");
+}
+
+void gfar_dbg_exit(void)
+{
+	debugfs_remove_recursive(gfar_dbg_root);
+}
-- 
1.7.5.4

