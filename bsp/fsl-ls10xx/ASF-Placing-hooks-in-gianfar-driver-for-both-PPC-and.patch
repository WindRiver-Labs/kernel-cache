From d5ae527a587781083b67ac0cfeecada07414bba9 Mon Sep 17 00:00:00 2001
From: Ganga Negi <ganga.negi@freescale.com>
Date: Tue, 4 Nov 2014 13:44:32 +0530
Subject: [PATCH 062/129] ASF: Placing hooks in gianfar driver for both PPC
 and ARM platforms.

Placing required compilation flags and hooks in gianfar
driver for both ARM and PowerPC platforms.

Signed-off-by: Ganga Negi <ganga.negi@freescale.com>
Change-Id: I2f6c8fe40a2223013559bc6909a60e8963aa2a96
CR:ENGR00338962
(cherry picked from commit 509f3236615193c77e07797cde4729ccc8cb2ef5)
Reviewed-on: http://git.am.freescale.net:8181/23585
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Xulin: Original patch taken from
Freescale-Linux-SDK-for-LS1021A-IOT-Rev2-v0.4-SOURCE-20150907-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   43 +++++++++++++++++++++++++++---
 drivers/net/ethernet/freescale/gianfar.h |   25 ++++++++++++++++-
 2 files changed, 62 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index bc9d5e5..c9f1b3d 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -115,7 +115,17 @@
 #endif
 
 #ifdef CONFIG_AS_FASTPATH
+#ifdef CONFIG_PPC
 #include "asf_gianfar.h"
+#else
+
+devfp_hook_t   devfp_rx_hook;
+EXPORT_SYMBOL(devfp_rx_hook);
+
+devfp_hook_t   devfp_tx_hook;
+EXPORT_SYMBOL(devfp_tx_hook);
+
+#endif
 #endif
 
 #define TX_TIMEOUT      (1*HZ)
@@ -876,7 +886,7 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 		return -EINVAL;
 	}
 
-#ifdef CONFIG_AS_FASTPATH
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_PPC)
 	/* Creating multilple queues for avoiding lock in xmit function.*/
 	num_tx_qs = (num_tx_qs < 2) ? 2 : num_tx_qs;
 #endif
@@ -2466,7 +2476,13 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	unsigned int nr_frags, nr_txbds, fcb_len = 0;
 
 #ifdef CONFIG_AS_FASTPATH
+#ifdef CONFIG_PPC
 	return gfar_asf_start_xmit(skb, dev);
+#else
+	if (devfp_tx_hook && (skb->pkt_type != PACKET_FASTROUTE))
+		if (devfp_tx_hook(skb, dev) == AS_FP_STOLEN)
+			return 0;
+#endif
 #endif
 
 	rq = skb->queue_mapping;
@@ -2967,7 +2983,7 @@ static struct sk_buff *gfar_alloc_skb(struct net_device *dev)
 	struct gfar_private *priv = netdev_priv(dev);
 	struct sk_buff *skb;
 
-#ifndef CONFIG_AS_FASTPATH
+#if !defined(CONFIG_AS_FASTPATH) || defined(CONFIG_ARM)
 	skb = netdev_alloc_skb(dev, priv->rx_buffer_size + RXBUF_ALIGNMENT);
 #else
 	skb = netdev_alloc_skb(dev, priv->rx_buffer_size + RXBUF_ALIGNMENT +
@@ -3035,7 +3051,7 @@ static irqreturn_t gfar_transmit(int irq, void *grp_id)
 	unsigned long flags;
 	u32 imask;
 
-#ifdef CONFIG_AS_FASTPATH
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_PPC)
 	return gfar_enable_tx_queue(irq, grp_id);
 #endif
 
@@ -3115,6 +3131,25 @@ static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 	if (dev->features & NETIF_F_RXCSUM)
 		gfar_rx_checksum(skb, fcb);
 
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_ARM)
+	if (devfp_rx_hook) {
+		/* Drop the packet silently if IP Checksum is not correct */
+		if ((be16_to_cpu(fcb->flags) & RXFCB_CIP) &&
+				(be16_to_cpu(fcb->flags) & RXFCB_EIP)) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+
+		if (dev->features & NETIF_F_HW_VLAN_CTAG_RX &&
+				be16_to_cpu(fcb->flags) & RXFCB_VLN)
+			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+					be16_to_cpu(fcb->vlctl));
+
+		skb->dev = dev;
+		if (devfp_rx_hook(skb, dev) == AS_FP_STOLEN)
+			return;
+	}
+#endif
 	/* Tell the skb what kind of packet this is */
 	skb->protocol = eth_type_trans(skb, dev);
 
@@ -3155,7 +3190,7 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 	int howmany = 0;
 	struct gfar_private *priv = netdev_priv(dev);
 
-#ifdef CONFIG_AS_FASTPATH
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_PPC)
 	return gfar_asf_clean_rx_ring(rx_queue, rx_work_limit);
 #endif
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 4558d6d..a094b7b 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -54,6 +54,27 @@
 #include <linux/circ_buf.h>
 #endif
 
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_ARM)
+#define AS_FP_PROCEED  1
+#define AS_FP_STOLEN   2
+
+typedef        int (*devfp_hook_t)(struct sk_buff *skb, struct net_device *dev);
+extern devfp_hook_t   devfp_rx_hook;
+extern devfp_hook_t   devfp_tx_hook;
+
+static inline int devfp_register_rx_hook(devfp_hook_t hook)
+{
+	devfp_rx_hook = hook;
+	return 0;
+}
+
+static inline int devfp_register_tx_hook(devfp_hook_t hook)
+{
+	devfp_tx_hook = hook;
+	return 0;
+}
+#endif
+
 struct ethtool_flow_spec_container {
 	struct ethtool_rx_flow_spec fs;
 	struct list_head list;
@@ -79,7 +100,7 @@ struct ethtool_rx_list {
 /* Number of bytes to align the rx bufs to */
 #define RXBUF_ALIGNMENT 64
 
-#ifdef CONFIG_AS_FASTPATH
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_PPC)
 /* Headroom required for IPSec processing in ASF */
 #define EXTRA_HEADROOM 128
 #endif
@@ -1708,7 +1729,7 @@ static inline void gfar_rx_checksum(struct sk_buff *skb, struct rxfcb *fcb)
 
 static inline void gfar_align_skb(struct sk_buff *skb)
 {
-#ifdef CONFIG_AS_FASTPATH
+#if defined(CONFIG_AS_FASTPATH) && defined(CONFIG_PPC)
 	/* Reserving the extra headroom required for ASF IPSec processing */
 	skb_reserve(skb, EXTRA_HEADROOM);
 #endif
-- 
1.7.5.4

