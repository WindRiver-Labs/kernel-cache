From a8260b3dc3ef07b94650643b19d36263870407e0 Mon Sep 17 00:00:00 2001
From: Zhao Qiang <B45475@freescale.com>
Date: Thu, 29 May 2014 10:26:51 +0800
Subject: [PATCH 164/255] qe-tdm: support qe-tdm for ls1021a

Signed-off-by: Zhao Qiang <B45475@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso, also remove the
unused function get_ticks().]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/include/asm/delay.h     | 10 ++++-----
 arch/arm/lib/delay.c             |  9 --------
 drivers/tdm/device/fsl_ucc_tdm.c | 44 ++++++++++++++++++++--------------------
 3 files changed, 27 insertions(+), 36 deletions(-)

diff --git a/arch/arm/include/asm/delay.h b/arch/arm/include/asm/delay.h
index 6be015d..f366bb8 100644
--- a/arch/arm/include/asm/delay.h
+++ b/arch/arm/include/asm/delay.h
@@ -65,18 +65,18 @@ extern void __loop_const_udelay(unsigned long);
 /* Delay-loop timer registration. */
 #define ARCH_HAS_READ_CURRENT_TIMER
 extern void register_current_timer_delay(const struct delay_timer *timer);
-unsigned long get_ticks(unsigned long time);
 
 #define spin_event_timeout(condition, timeout, delay)                          \
 ({                                                                             \
 	typeof(condition) __ret;                                               \
-	unsigned long __loops = get_ticks(timeout);		               \
-	unsigned long __start = get_cycles();                                  \
-	while (!(__ret = (condition)) && ((get_cycles() - __start) <= __loops))\
+	int i = 0;							       \
+	while (!(__ret = (condition)) && (i++ < timeout)) {		       \
 		if (delay)                                                     \
 			udelay(delay);                                         \
 		else                                                           \
-			cpu_relax();                                           \
+			cpu_relax();					       \
+		udelay(1);						       \
+	}								       \
 	if (!__ret)                                                            \
 		__ret = (condition);                                           \
 	__ret;		                                                       \
diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c
index b83d91f..5306de3 100644
--- a/arch/arm/lib/delay.c
+++ b/arch/arm/lib/delay.c
@@ -62,15 +62,6 @@ static void __timer_const_udelay(unsigned long xloops)
 	__timer_delay(loops >> UDELAY_SHIFT);
 }
 
-unsigned long get_ticks(unsigned long time)
-{
-	unsigned long long loops = time;
-	unsigned long value;
-	loops *= arm_delay_ops.ticks_per_jiffy;
-	value = loops >> UDELAY_SHIFT;
-	return value;
-}
-
 static void __timer_udelay(unsigned long usecs)
 {
 	__timer_const_udelay(usecs * UDELAY_MULT);
diff --git a/drivers/tdm/device/fsl_ucc_tdm.c b/drivers/tdm/device/fsl_ucc_tdm.c
index 7599aa2..09843bb 100644
--- a/drivers/tdm/device/fsl_ucc_tdm.c
+++ b/drivers/tdm/device/fsl_ucc_tdm.c
@@ -761,18 +761,18 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 	struct ucc_tdm_info *ut_info;
 	struct resource res;
 	int ucc_num;
-	const unsigned int *prop;
+	u32 val;
 	const char *sprop;
 	struct device_node *np2;
 	int ret;
 
-	prop = of_get_property(np, "cell-index", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "cell-index", 0, &val);
+	if (ret) {
 		dev_err(&pdev->dev, "Invalid ucc property\n");
 		return -ENODEV;
 	}
 
-	ucc_num = *prop - 1;
+	ucc_num = val - 1;
 	if ((ucc_num > 7) || (ucc_num < 0)) {
 		dev_err(&pdev->dev, ": Invalid UCC num\n");
 		return -EINVAL;
@@ -857,54 +857,54 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 	dev_set_drvdata(&pdev->dev, utdm_priv);
 	utdm_priv->dev = &pdev->dev;
 
-	prop = of_get_property(np, "fsl,tx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "Invalid tx-timeslot property\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tx_ts_mask = *prop;
+	utdm_priv->tx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,rx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,rx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "Invalid rx-timeslot property\n");
 		goto err_miss_property;
 	}
-	utdm_priv->rx_ts_mask = *prop;
+	utdm_priv->rx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,tdm-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tdm-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No fsl,tdm-id property for this UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_port = *prop;
+	utdm_priv->tdm_port = val;
 	ut_info->uf_info.tdm_num = utdm_priv->tdm_port;
 
-	prop = of_get_property(np, "fsl,tdm-mode", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-mode", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No tdm-mode property for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_mode = set_tdm_mode((const char *)prop);
+	utdm_priv->tdm_mode = set_tdm_mode(sprop);
 
-	prop = of_get_property(np, "fsl,tdm-framer-type", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-framer-type", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No tdm-framer-type property for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_framer_type = set_tdm_framer((const char *)prop);
+	utdm_priv->tdm_framer_type = set_tdm_framer(sprop);
 
-	prop = of_get_property(np, "fsl,siram-entry-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,siram-entry-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No siram entry id for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->siram_entry_id = *(const u32 *)prop;
+	utdm_priv->siram_entry_id = val;
 
 	np2 = of_find_node_by_name(NULL, "si");
 	if (!np2) {
-- 
2.0.2

