From 59060de60f7cf910f124a93731a684d2d891350b Mon Sep 17 00:00:00 2001
From: Jingchang Lu <b35083@freescale.com>
Date: Thu, 7 Nov 2013 14:23:27 +0800
Subject: [PATCH 005/255] ARM: imx: add LS1021A SMP support

Layerscape LS1021A deploys two cortex-A7 processor,
this adds bring-up support of the secondary core.

Signed-off-by: Jingchang Lu <b35083@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/mach-imx/Kconfig        |  1 +
 arch/arm/mach-imx/common.h       |  2 ++
 arch/arm/mach-imx/headsmp.S      | 11 ++++++++++
 arch/arm/mach-imx/mach-ls1021a.c |  1 +
 arch/arm/mach-imx/platsmp.c      | 44 ++++++++++++++++++++++++++++++++++++++++
 5 files changed, 59 insertions(+)

diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 30b861b..443eea9 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -851,6 +851,7 @@ config SOC_LS1021A
 	select ARM_GIC
 	select CLKSRC_OF
 	select HAVE_ARM_ARCH_TIMER
+	select HAVE_SMP
 
 	help
 	  This enable support for Freescale Layerscape LS1021A  processor.
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index baf439d..47cbba2 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -122,6 +122,7 @@ void v7_secondary_startup(void);
 void imx_scu_map_io(void);
 void imx_smp_prepare(void);
 void imx_scu_standby_enable(void);
+void ls1021a_secondary_startup(void);
 #else
 static inline void imx_scu_map_io(void) {}
 static inline void imx_smp_prepare(void) {}
@@ -165,5 +166,6 @@ static inline void imx_init_l2cache(void) {}
 #endif
 
 extern struct smp_operations imx_smp_ops;
+extern struct smp_operations ls1021a_smp_ops;
 
 #endif
diff --git a/arch/arm/mach-imx/headsmp.S b/arch/arm/mach-imx/headsmp.S
index 627f16f..1d45234 100644
--- a/arch/arm/mach-imx/headsmp.S
+++ b/arch/arm/mach-imx/headsmp.S
@@ -34,6 +34,17 @@ ENTRY(v7_secondary_startup)
 	set_diag_reg
 	b	secondary_startup
 ENDPROC(v7_secondary_startup)
+
+ENTRY(ls1021a_secondary_startup)
+	/* set CNTFREQ of secondary core */
+	ldr	r0, =12500000
+	mcr 	p15, 0, r0, c14, c0, 0
+	/* disable Physical and Virtural Timer */
+	mov	r0, #0x0
+	mcr	p15, 0, r0, c14, c2, 1
+	mcr	p15, 0, r0, c14, c3, 1
+	b	secondary_startup
+ENDPROC(ls1021a_secondary_startup)
 #endif
 
 #ifdef CONFIG_ARM_CPU_SUSPEND
diff --git a/arch/arm/mach-imx/mach-ls1021a.c b/arch/arm/mach-imx/mach-ls1021a.c
index 25ca0eb..42e2f9d 100644
--- a/arch/arm/mach-imx/mach-ls1021a.c
+++ b/arch/arm/mach-imx/mach-ls1021a.c
@@ -38,6 +38,7 @@ static const char *ls1021a_dt_compat[] __initdata = {
 };
 
 DT_MACHINE_START(ls1021a, "Freescale Layerscape LS1021A")
+	.smp		= smp_ops(ls1021a_smp_ops),
 	.init_irq	= ls1021a_init_irq,
 	.init_time	= ls1021a_init_time,
 	.init_machine   = ls1021a_init_machine,
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index 5b57c17..5166da0 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -16,6 +16,8 @@
 #include <asm/page.h>
 #include <asm/smp_scu.h>
 #include <asm/mach/map.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
 
 #include "common.h"
 #include "hardware.h"
@@ -104,3 +106,45 @@ struct smp_operations  imx_smp_ops __initdata = {
 	.cpu_kill		= imx_cpu_kill,
 #endif
 };
+
+static void __iomem *dcfg_base;
+#define DCFG_CCSR_BRR		0xE4
+#define DCFG_CCSR_SCRATCHRW1	0x200
+
+static int ls1021a_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long paddr;
+
+	paddr = virt_to_phys(ls1021a_secondary_startup);
+	writel_relaxed(cpu_to_be32(paddr), dcfg_base + DCFG_CCSR_SCRATCHRW1);
+	/* release core for booting */
+	writel_relaxed( cpu_to_be32(0x1 << cpu), dcfg_base + DCFG_CCSR_BRR);
+
+	return 0;
+}
+
+static void __init ls1021a_smp_init_cpus(void)
+{
+	int i, ncores;
+	/* get number of cores from CP15 L2 controller register(L2CTLR)*/
+	asm volatile ("mrc p15, 1, %0, c9, c0, 2" : "=r" (ncores));
+
+	ncores = ((ncores >> 24) & 0x3) + 1;
+	for (i = ncores; i < NR_CPUS; i++)
+		set_cpu_possible(i, false);
+}
+
+static void __init ls1021a_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,ls1021a-dcfg");
+	dcfg_base = of_iomap(np, 0);
+	WARN_ON(!dcfg_base);
+}
+
+struct smp_operations  ls1021a_smp_ops __initdata = {
+	.smp_init_cpus		= ls1021a_smp_init_cpus,
+	.smp_prepare_cpus	= ls1021a_smp_prepare_cpus,
+	.smp_boot_secondary	= ls1021a_boot_secondary,
+};
-- 
2.0.2

