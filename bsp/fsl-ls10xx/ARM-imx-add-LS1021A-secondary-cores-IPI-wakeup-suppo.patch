From d14c6f2ab727886294ee9be72d00e710df0bdc17 Mon Sep 17 00:00:00 2001
From: Xiubo Li <Li.Xiubo@freescale.com>
Date: Wed, 2 Jul 2014 16:26:43 +0800
Subject: [PATCH 206/255] ARM: imx: add LS1021A secondary cores IPI wakeup
 support

All the secondary cores will be booted and released in uboot,
and then just go to deep sleep waiting for the wake up interrupts
in kernel, here.

Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/mach-imx/headsmp.S | 28 ++++++++++++---
 arch/arm/mach-imx/platsmp.c | 86 ++++++++++++++++++++++++++++++++++++++++-----
 2 files changed, 100 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-imx/headsmp.S b/arch/arm/mach-imx/headsmp.S
index 1d45234..e1a2731 100644
--- a/arch/arm/mach-imx/headsmp.S
+++ b/arch/arm/mach-imx/headsmp.S
@@ -36,14 +36,32 @@ ENTRY(v7_secondary_startup)
 ENDPROC(v7_secondary_startup)
 
 ENTRY(ls1021a_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	bic	r0, #0xff000000
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
 	/* set CNTFREQ of secondary core */
-	ldr	r0, =12500000
-	mcr 	p15, 0, r0, c14, c0, 0
+@	ldr	r0, =12500000
+@	mcr 	p15, 0, r0, c14, c0, 0
 	/* disable Physical and Virtural Timer */
-	mov	r0, #0x0
-	mcr	p15, 0, r0, c14, c2, 1
-	mcr	p15, 0, r0, c14, c3, 1
+@	mov	r0, #0x0
+@	mcr	p15, 0, r0, c14, c2, 1
+@	mcr	p15, 0, r0, c14, c3, 1
 	b	secondary_startup
+
+	.align
+1:	.long	.
+	.long	pen_release
 ENDPROC(ls1021a_secondary_startup)
 #endif
 
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index 5166da0..41612e3 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -10,10 +10,13 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+#include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <asm/cacheflush.h>
 #include <asm/page.h>
+#include <asm/smp.h>
+#include <asm/smp_plat.h>
 #include <asm/smp_scu.h>
 #include <asm/mach/map.h>
 #include <linux/of.h>
@@ -107,20 +110,78 @@ struct smp_operations  imx_smp_ops __initdata = {
 #endif
 };
 
-static void __iomem *dcfg_base;
-#define DCFG_CCSR_BRR		0xE4
 #define DCFG_CCSR_SCRATCHRW1	0x200
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+static DEFINE_SPINLOCK(boot_lock);
 
-static int ls1021a_boot_secondary(unsigned int cpu, struct task_struct *idle)
+void ls1021a_secondary_init(unsigned int cpu)
 {
-	unsigned long paddr;
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
 
-	paddr = virt_to_phys(ls1021a_secondary_startup);
-	writel_relaxed(cpu_to_be32(paddr), dcfg_base + DCFG_CCSR_SCRATCHRW1);
-	/* release core for booting */
-	writel_relaxed( cpu_to_be32(0x1 << cpu), dcfg_base + DCFG_CCSR_BRR);
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
 
-	return 0;
+int ls1021a_boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	write_pen_release(cpu_logical_map(cpu));
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	arch_send_wakeup_ipi_mask(cpumask_of(cpu));
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
 }
 
 static void __init ls1021a_smp_init_cpus(void)
@@ -137,14 +198,21 @@ static void __init ls1021a_smp_init_cpus(void)
 static void __init ls1021a_smp_prepare_cpus(unsigned int max_cpus)
 {
 	struct device_node *np;
+	void __iomem *dcfg_base;
+	unsigned long paddr;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,ls1021a-dcfg");
 	dcfg_base = of_iomap(np, 0);
 	WARN_ON(!dcfg_base);
+
+	paddr = virt_to_phys(ls1021a_secondary_startup);
+	writel_relaxed(cpu_to_be32(paddr), dcfg_base + DCFG_CCSR_SCRATCHRW1);
+
 }
 
 struct smp_operations  ls1021a_smp_ops __initdata = {
 	.smp_init_cpus		= ls1021a_smp_init_cpus,
 	.smp_prepare_cpus	= ls1021a_smp_prepare_cpus,
 	.smp_boot_secondary	= ls1021a_boot_secondary,
+	.smp_secondary_init	= ls1021a_secondary_init,
 };
-- 
2.0.2

