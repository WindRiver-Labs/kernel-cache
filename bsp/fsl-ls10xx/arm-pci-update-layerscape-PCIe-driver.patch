From c675632896454e45004ca60dd6fc5a9658818e4e Mon Sep 17 00:00:00 2001
From: Minghuan Lian <Minghuan.Lian@freescale.com>
Date: Thu, 17 Jul 2014 18:58:45 +0000
Subject: [PATCH 212/255] arm: pci: update layerscape PCIe driver

1. Add MSI support and enable BIT_REVERSE for SCFG
2. create 4 outbound ATU:
   ATU0 is used for PCIe CFG0 transaction
   ATU1 is used for PCIe CFG1 transaction
   ATU2 is used for PCIe memory transaction
   ATU3 is used for PCIe IO transaction
3. Do not call interface of pci-designware.c
4. Use NO_BIT_REVERSE mode to access PCIe link status

Signed-off-by: Jason Jin <Jason.Jin@freescale.com>
Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/arm/boot/dts/ls1021a.dtsi     |   4 +-
 drivers/pci/host/pcie-layerscape.c | 860 ++++++++++++++++++++++++++++++++-----
 2 files changed, 750 insertions(+), 114 deletions(-)

diff --git a/arch/arm/boot/dts/ls1021a.dtsi b/arch/arm/boot/dts/ls1021a.dtsi
index e06374c..77eeb89 100644
--- a/arch/arm/boot/dts/ls1021a.dtsi
+++ b/arch/arm/boot/dts/ls1021a.dtsi
@@ -791,7 +791,7 @@
 		};
 
 		pcie@3400000 {
-			compatible = "fsl,pcie", "snps,dw-pcie", "fsl,ls1021a-pcie";
+			compatible = "fsl,pcie", "fsl,ls1021a-pcie";
 			reg = <0x0 0x3400000 0x0 0x10000>;
 			interrupts = <GIC_SPI 177 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 179 IRQ_TYPE_LEVEL_HIGH>,
@@ -815,7 +815,7 @@
 			};
 
 		pcie@3500000 {
-			compatible = "fsl,pcie", "snps,dw-pcie", "fsl,ls1021a-pcie";
+			compatible = "fsl,pcie", "fsl,ls1021a-pcie";
 			reg = <0x0 0x3500000 0x0 0x10000>;
 			interrupts = <GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH>,
 					<GIC_SPI 180 IRQ_TYPE_LEVEL_HIGH>,
diff --git a/drivers/pci/host/pcie-layerscape.c b/drivers/pci/host/pcie-layerscape.c
index ed255e5..943c6e4 100644
--- a/drivers/pci/host/pcie-layerscape.c
+++ b/drivers/pci/host/pcie-layerscape.c
@@ -10,11 +10,8 @@
  * published by the Free Software Foundation.
  */
 
-#include <linux/clk.h>
-#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
-#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_pci.h>
 #include <linux/of_platform.h>
@@ -22,176 +19,543 @@
 #include <linux/of_address.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
-#include <linux/regmap.h>
 #include <linux/resource.h>
-#include <linux/signal.h>
-#include <linux/types.h>
 
-#include "pcie-designware.h"
+#define MSI_CHIP_LS1021A	1
+#define MSI_LS1021A_IRQ_NUM	1
+#define MSI_LS1021A_DATA1	0xb3
+#define MSI_LS1021A_DATA2	0xb4
+#define MSI_MAX_IRQ_NUM		32
+
+#define SCFG_SPIMSICR_OFF	0x40
+#define SCFG_SPIMSICR_ADDR	0x1570040
+#define SCFG_SPIMSICLRCR_OFF	0x90
+#define SCFG_SCFGREVCR_OFF	0x200
+#define SCFG_BIT_REVERSE	0xFFFFFFFF
+#define SCFG_NO_BIT_REVERSE	0x0
+
+/* PCIE ATU configuration registers */
+#define PCIE_ATU_VIEWPORT		0x900
+#define PCIE_ATU_REGION_INBOUND		(0x1 << 31)
+#define PCIE_ATU_REGION_OUTBOUND	(0x0 << 31)
+#define PCIE_ATU_REGION_INDEX0		(0x0 << 0)
+#define PCIE_ATU_REGION_INDEX1		(0x1 << 0)
+#define PCIE_ATU_REGION_INDEX2		(0x2 << 0)
+#define PCIE_ATU_REGION_INDEX3		(0x3 << 0)
+#define PCIE_ATU_CFG0_INDEX		PCIE_ATU_REGION_INDEX0
+#define PCIE_ATU_CFG1_INDEX		PCIE_ATU_REGION_INDEX1
+#define PCIE_ATU_MEM_INDEX		PCIE_ATU_REGION_INDEX2
+#define PCIE_ATU_IO_INDEX		PCIE_ATU_REGION_INDEX3
+
+#define PCIE_ATU_CR1			0x904
+#define PCIE_ATU_TYPE_MEM		(0x0 << 0)
+#define PCIE_ATU_TYPE_IO		(0x2 << 0)
+#define PCIE_ATU_TYPE_CFG0		(0x4 << 0)
+#define PCIE_ATU_TYPE_CFG1		(0x5 << 0)
+#define PCIE_ATU_CR2			0x908
+#define PCIE_ATU_ENABLE			(0x1 << 31)
+#define PCIE_ATU_BAR_MODE_ENABLE	(0x1 << 30)
+#define PCIE_ATU_LOWER_BASE		0x90C
+#define PCIE_ATU_UPPER_BASE		0x910
+#define PCIE_ATU_LIMIT			0x914
+#define PCIE_ATU_LOWER_TARGET		0x918
+#define PCIE_ATU_BUS(x)			(((x) & 0xff) << 24)
+#define PCIE_ATU_DEV(x)			(((x) & 0x1f) << 19)
+#define PCIE_ATU_FUNC(x)		(((x) & 0x7) << 16)
+#define PCIE_ATU_UPPER_TARGET		0x91C
+
+/* PEX1/2 Misc Ports Status Register */
+#define PEXMSCPORTSR(idx)	(0x94 + (idx) * 4)
+#define LTSSM_STATE_SHIFT	20
+#define LTSSM_STATE_MASK	0x3f
+#define LTSSM_PCIE_L0		0x11 /* L0 state */
+
+struct ls_msi {
+	char name[32];
+	struct msi_chip chip;
+	struct ls_pcie *pcie;
+	DECLARE_BITMAP(used, MSI_MAX_IRQ_NUM);
+	struct irq_domain *domain;
+	struct mutex lock;
+	u64 addr;
+	u32 data;
+	int chip_id;
+	int chip_irq;
+	int irq_num;
+};
 
 struct ls_pcie {
 	struct list_head node;
+	int index;
+	char name[32];
 	struct device *dev;
+
+	u8 root_bus_nr;
 	struct pci_bus *bus;
-	void __iomem *dbi;
+
+	void __iomem *regs;
+	void __iomem *va_cfg0_base;
+	void __iomem *va_cfg1_base;
 	void __iomem *scfg;
-	struct pcie_port pp;
-	int index;
+	u64 cfg0_base;
+	u64 cfg1_base;
+	int cfg0_size;
+	int cfg1_size;
+
+	struct resource cfg;
+	struct resource io;
+	struct resource mem;
+	struct resource prefetch;
+	struct resource busn;
+
+	phys_addr_t io_bus_addr;
+	phys_addr_t mem_bus_addr;
+	phys_addr_t prefetch_bus_addr;
+
+	struct ls_msi msi;
 	int irq;
-	int msi_irq;
 	int pme_irq;
 	int cfg_irq;
 	int inta_irq;
 };
 
-/* PEX1/2 Misc Ports Status Register */
-#define PEXMSCPORTSR(idx)	(0x94 + (idx) * 4)
-#define LTSSM_STATE_SHIFT	20
-#define LTSSM_STATE_MASK	0x3f
-#define LTSSM_PCIE_L0		0x11 /* L0 state */
-
 static int global_index;
 static LIST_HEAD(ls_pcie_list);
+static unsigned long global_io_offset;
 
-#define to_ls_pcie(x)	container_of(x, struct ls_pcie, pp)
+static inline struct ls_pcie *sys_to_pcie(struct pci_sys_data *sys)
+{
+	return sys->private_data;
+}
 
-static int ls_pcie_link_up(struct pcie_port *pp)
+static int ls_pcie_link_up(struct ls_pcie *pcie)
 {
-	struct ls_pcie *pcie = to_ls_pcie(pp);
-	u32 rc;
+	u32 rc, tmp;
+
+	tmp = ioread32(pcie->scfg + SCFG_SCFGREVCR_OFF);
+	iowrite32(SCFG_NO_BIT_REVERSE, pcie->scfg + SCFG_SCFGREVCR_OFF);
 
-	/* RM did not say the value meaning */
 	rc = (ioread32(pcie->scfg + PEXMSCPORTSR(pcie->index)) >>
 	     LTSSM_STATE_SHIFT) & LTSSM_STATE_MASK;
 
+	iowrite32(tmp, pcie->scfg + SCFG_SCFGREVCR_OFF);
+
 	if (rc < LTSSM_PCIE_L0)
 		return 0;
 
 	return 1;
 }
 
+static inline u32 ls_pcie_read_reg(struct ls_pcie *pcie, u32 reg)
+{
+	return ioread32(pcie->regs + reg);
+}
 
-static irqreturn_t ls_pcie_msi_irq_handler(int irq, void *arg)
+static inline void ls_pcie_write_reg(struct ls_pcie *pcie, u32 val, u32 reg)
 {
-	struct pcie_port *pp = arg;
+	return iowrite32(val, pcie->regs + reg);
+}
 
-	dw_handle_msi_irq(pp);
+static void ls_pcie_atu_cfg0_set_busdev(struct ls_pcie *pcie, u32 busdev)
+{
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_CFG0_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, busdev, PCIE_ATU_LOWER_TARGET);
+}
 
-	return IRQ_HANDLED;
+static void ls_pcie_atu_cfg1_set_busdev(struct ls_pcie *pcie, u32 busdev)
+{
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_CFG1_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, busdev, PCIE_ATU_LOWER_TARGET);
 }
 
-static irqreturn_t ls_pcie_irq_handler(int irq, void *arg)
+static int ls_pcie_valid_config(struct ls_pcie *pcie,
+				struct pci_bus *bus, int dev)
 {
-	struct pcie_port *pp = arg;
+	/* If there is no link, then there is no device */
+	if (bus->number != pcie->root_bus_nr) {
+		if (!ls_pcie_link_up(pcie))
+			return 0;
+	}
 
-	printk("get irq %d\n", irq);
+	/* access only one slot on each root port */
+	if (bus->number == pcie->root_bus_nr && dev > 0)
+		return 0;
 
-	return IRQ_HANDLED;
+	return 1;
 }
 
-static void ls_pcie_host_init(struct pcie_port *pp)
+static int ls_pcie_read_conf(struct pci_bus *bus, u32 devfn, int where,
+			int size, u32 *val)
 {
-	int count = 0;
+	struct ls_pcie *pcie = sys_to_pcie(bus->sysdata);
+	void *addr;
+	u32 busdev;
+
+	if (!pcie) {
+		BUG();
+		return -EINVAL;
+	}
+
+	if (ls_pcie_valid_config(pcie, bus, PCI_SLOT(devfn)) == 0) {
+		*val = 0xffffffff;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
 
-	dw_pcie_setup_rc(pp);
+	if (bus->number != pcie->root_bus_nr) {
+		busdev = PCIE_ATU_BUS(bus->number) |
+			 PCIE_ATU_DEV(PCI_SLOT(devfn)) |
+			 PCIE_ATU_FUNC(PCI_FUNC(devfn));
+
+		if (bus->parent->number == pcie->root_bus_nr) {
+			ls_pcie_atu_cfg0_set_busdev(pcie, busdev);
+			addr = pcie->va_cfg0_base + (where & ~0x3);
+		} else {
+			ls_pcie_atu_cfg1_set_busdev(pcie, busdev);
+			addr = pcie->va_cfg1_base + (where & ~0x3);
+		}
+	} else
+		addr = pcie->regs + (where & ~0x3);
+
+	*val = ioread32(addr);
+
+	if (size == 1)
+		*val = (*val >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*val = (*val >> (8 * (where & 3))) & 0xffff;
+	else if (size != 4)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	return PCIBIOS_SUCCESSFUL;
+}
 
-	while (!ls_pcie_link_up(pp)) {
-		usleep_range(100, 1000);
-		count++;
-		if (count >= 200) {
-			dev_err(pp->dev, "phy link never came up\n");
-			return;
+static int ls_pcie_write_conf(struct pci_bus *bus, u32 devfn,
+			int where, int size, u32 val)
+{
+	struct ls_pcie *pcie = sys_to_pcie(bus->sysdata);
+	void *addr;
+	u32 busdev;
+
+	if (ls_pcie_valid_config(pcie, bus, PCI_SLOT(devfn)) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (bus->number != pcie->root_bus_nr) {
+		busdev = PCIE_ATU_BUS(bus->number) |
+			 PCIE_ATU_DEV(PCI_SLOT(devfn)) |
+			 PCIE_ATU_FUNC(PCI_FUNC(devfn));
+
+		if (bus->parent->number == pcie->root_bus_nr) {
+			ls_pcie_atu_cfg0_set_busdev(pcie, busdev);
+			addr = pcie->va_cfg0_base + (where & ~0x3);
+		} else {
+			ls_pcie_atu_cfg1_set_busdev(pcie, busdev);
+			addr = pcie->va_cfg1_base + (where & ~0x3);
 		}
+	} else
+		addr = pcie->regs + (where & ~0x3);
+
+	if (size == 4)
+		iowrite32(val, addr);
+	else if (size == 2)
+		iowrite16(val, addr + (where & 2));
+	else if (size == 1)
+		iowrite8(val, addr + (where & 3));
+	else
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ls_pcie_ops = {
+	.read = ls_pcie_read_conf,
+	.write = ls_pcie_write_conf,
+};
+
+static inline struct ls_msi *to_ls_msi(struct msi_chip *chip)
+{
+	return container_of(chip, struct ls_msi, chip);
+}
+
+static int ls_msi_alloc(struct ls_msi *chip)
+{
+	int msi;
+
+	mutex_lock(&chip->lock);
+
+	msi = find_first_zero_bit(chip->used, chip->irq_num);
+	if (msi < chip->irq_num)
+		set_bit(msi, chip->used);
+	else
+		msi = -ENOSPC;
+
+	mutex_unlock(&chip->lock);
+
+	return msi;
+}
+
+static void ls_msi_free(struct ls_msi *chip, unsigned long irq)
+{
+	struct device *dev = chip->chip.dev;
+
+	mutex_lock(&chip->lock);
+
+	if (!test_bit(irq, chip->used))
+		dev_err(dev, "trying to free unused MSI#%lu\n", irq);
+	else
+		clear_bit(irq, chip->used);
+
+	mutex_unlock(&chip->lock);
+}
+
+static irqreturn_t ls_pcie_msi_irq(int chip_irq, void *data)
+{
+	struct ls_pcie *pcie = data;
+	struct ls_msi *msi = &pcie->msi;
+	unsigned int irq, index, processed = 0;
+
+	if (msi->chip_id == MSI_CHIP_LS1021A) {
+		/* clear the interrupt */
+		iowrite32(msi->data, pcie->scfg + SCFG_SPIMSICLRCR_OFF);
+
+		index = 0;
+		irq = irq_find_mapping(msi->domain, index);
+		if (irq) {
+			if (test_bit(index, msi->used))
+				generic_handle_irq(irq);
+			else
+				dev_info(pcie->dev, "unhandled MSI\n");
+		} else {
+			/*
+			 * that's weird who triggered this?
+			 * just clear it
+			 */
+			dev_info(pcie->dev, "unexpected MSI\n");
+		}
+
+		processed++;
 	}
 
+	return processed > 0 ? IRQ_HANDLED : IRQ_NONE;
+}
 
-	if (IS_ENABLED(CONFIG_PCI_MSI))
-		dw_pcie_msi_init(pp);
+static int ls_msi_setup_irq(struct msi_chip *chip, struct pci_dev *pdev,
+			    struct msi_desc *desc)
+{
+	struct ls_msi *msi = to_ls_msi(chip);
+	struct msi_msg msg;
+	unsigned int irq;
+	int hwirq;
+
+	hwirq = ls_msi_alloc(msi);
+	if (hwirq < 0)
+		return hwirq;
+
+	irq = irq_create_mapping(msi->domain, hwirq);
+	if (!irq)
+		return -EINVAL;
+
+	irq_set_msi_desc(irq, desc);
+
+	msg.address_lo = msi->addr;
+	msg.address_hi = msi->addr >> 32;
+
+	if (msi->chip_id == MSI_CHIP_LS1021A)
+		msg.data = msi->data;
+	else
+		msg.data = hwirq;
+
+	/* MSI needs to set bit reverse */
+	iowrite32(SCFG_BIT_REVERSE, msi->pcie->scfg + SCFG_SCFGREVCR_OFF);
+	write_msi_msg(irq, &msg);
+
+	return 0;
+}
+
+static void ls_msi_teardown_irq(struct msi_chip *chip, unsigned int irq)
+{
+	struct ls_msi *msi = to_ls_msi(chip);
+	struct irq_data *d = irq_get_irq_data(irq);
 
-	return;
+	ls_msi_free(msi, d->hwirq);
 }
 
+static struct irq_chip ls_msi_irq_chip = {
+	.name = "MSI",
+	.irq_enable = unmask_msi_irq,
+	.irq_disable = mask_msi_irq,
+	.irq_mask = mask_msi_irq,
+	.irq_unmask = unmask_msi_irq,
+};
+
+static int ls_msi_map(struct irq_domain *domain, unsigned int irq,
+			 irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq, &ls_msi_irq_chip, handle_simple_irq);
+	irq_set_chip_data(irq, domain->host_data);
+	set_irq_flags(irq, IRQF_VALID);
+
+	return 0;
+}
 
-static struct pcie_host_ops ls_pcie_host_ops = {
-	.link_up = ls_pcie_link_up,
-	.host_init = ls_pcie_host_init,
+static const struct irq_domain_ops msi_domain_ops = {
+	.map = ls_msi_map,
 };
 
-static int ls_add_pcie_port(struct ls_pcie *pcie)
+static int ls_pcie_enable_msi(struct ls_pcie *pcie)
 {
-	struct pcie_port *pp;
-	int ret;
+	struct platform_device *pdev = to_platform_device(pcie->dev);
+	struct ls_msi *msi = &pcie->msi;
+	int err;
 
-	if (!pcie)
+	msi->chip_irq = platform_get_irq_byname(pdev, "msi");
+	if (msi->chip_irq < 0) {
+		dev_err(&pdev->dev,
+			"failed to get MSI IRQ: %d\n", msi->chip_irq);
 		return -EINVAL;
+	}
 
-	pp = &pcie->pp;
-	pp->dev = pcie->dev;
-	pp->dbi_base = pcie->dbi;
-	pp->irq = pcie->inta_irq;
+	mutex_init(&msi->lock);
+
+	snprintf(msi->name, sizeof(msi->name), "%s-msi", pcie->name);
+	msi->pcie = pcie;
+	msi->chip.dev = pcie->dev;
+	msi->chip.setup_irq = ls_msi_setup_irq;
+	msi->chip.teardown_irq = ls_msi_teardown_irq;
+
+	if (of_device_is_compatible(pdev->dev.of_node, "fsl,ls1021a-pcie")) {
+		msi->chip_id = MSI_CHIP_LS1021A;
+		msi->irq_num = MSI_LS1021A_IRQ_NUM;
+		if (pcie->index == 0)
+			msi->data = MSI_LS1021A_DATA1;
+		else
+			msi->data = MSI_LS1021A_DATA2;
+	} else
+		msi->irq_num = MSI_MAX_IRQ_NUM;
+
+	msi->addr = SCFG_SPIMSICR_ADDR;
+
+	msi->domain = irq_domain_add_linear(pcie->dev->of_node, msi->irq_num,
+					    &msi_domain_ops, &msi->chip);
+	if (!msi->domain) {
+		dev_err(&pdev->dev, "failed to create IRQ domain\n");
+		return -ENOMEM;
+	}
 
-	ret = devm_request_irq(pp->dev, pcie->irq, ls_pcie_irq_handler,
-				IRQF_SHARED, "ls-pcie", pp);
-	if (ret) {
-		dev_err(pp->dev, "failed to requesppt irq\n");
-		return ret;
+	err = request_irq(msi->chip_irq, ls_pcie_msi_irq, 0,
+			  msi->name, pcie);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to request IRQ: %d\n", err);
+		goto err;
 	}
 
-	ret = devm_request_irq(pp->dev, pcie->cfg_irq, ls_pcie_irq_handler,
-				IRQF_SHARED, "ls-pcie-cfg", pcie);
-	if (ret) {
-		dev_err(pp->dev, "failed to request CFG error irq\n");
-		return ret;
+	return 0;
+
+err:
+	irq_domain_remove(msi->domain);
+	return err;
+}
+
+static int ls_pcie_disable_msi(struct ls_pcie *pcie)
+{
+	struct ls_msi *msi = &pcie->msi;
+	unsigned int i, irq;
+
+	/* mask the MSI interrupt */
+	if (msi->chip_irq > 0)
+		free_irq(msi->chip_irq, pcie);
+
+	for (i = 0; i < msi->irq_num; i++) {
+		irq = irq_find_mapping(msi->domain, i);
+		if (irq > 0)
+			irq_dispose_mapping(irq);
 	}
 
-	if (IS_ENABLED(CONFIG_PCI_MSI)) {
-		pp->msi_irq = pcie->msi_irq;
-		ret = devm_request_irq(pp->dev, pp->msi_irq,
-					ls_pcie_msi_irq_handler,
-					IRQF_SHARED, "ls-pcie", pp);
-		if (ret) {
-			dev_err(pp->dev, "failed to request msi irq\n");
-			return ret;
-		}
+	irq_domain_remove(msi->domain);
+
+	return 0;
+}
+
+static irqreturn_t ls_pcie_irq_handler(int irq, void *arg)
+{
+	struct ls_pcie *pcie = arg;
+
+	pr_debug("get irq %d from PCIe%d\n", irq, pcie->index);
+
+	return IRQ_HANDLED;
+}
+
+static int ls_pcie_parse_dt(struct ls_pcie *pcie)
+{
+	struct device_node *np = pcie->dev->of_node;
+	struct of_pci_range_parser parser;
+	struct of_pci_range range;
+	struct resource res;
+	int err;
+
+	if (of_pci_range_parser_init(&parser, np)) {
+		dev_err(pcie->dev, "missing ranges property\n");
+		return -EINVAL;
 	}
 
-	pp->root_bus_nr = -1;
-	pp->ops = &ls_pcie_host_ops;
+	for_each_of_pci_range(&parser, &range) {
+		of_pci_range_to_resource(&range, np, &res);
+
+		switch (res.flags & IORESOURCE_TYPE_BITS) {
+		case IORESOURCE_IO:
+			pcie->io.name = "I/O";
+			memcpy(&pcie->io, &res, sizeof(res));
+			pcie->io_bus_addr = range.pci_addr;
+			break;
+
+		case IORESOURCE_MEM:
+			if (res.flags & IORESOURCE_PREFETCH) {
+				pcie->prefetch.name = "PREFETCH";
+				memcpy(&pcie->prefetch, &res, sizeof(res));
+				pcie->prefetch_bus_addr = range.pci_addr;
+			} else {
+				pcie->mem.name = "MEM";
+				memcpy(&pcie->mem, &res, sizeof(res));
+				pcie->mem_bus_addr = range.pci_addr;
+			}
+			break;
+		case 0:
+			memcpy(&pcie->cfg, &res, sizeof(res));
+		}
+	}
 
-	spin_lock_init(&pp->conf_lock);
-	ret = dw_pcie_host_init(pp);
-	if (ret) {
-		dev_err(pp->dev, "failed to initialize host\n");
-		return ret;
+	err = of_pci_parse_bus_range(np, &pcie->busn);
+	if (err < 0) {
+		dev_err(pcie->dev, "failed to parse ranges property: %d\n",
+			err);
+		pcie->busn.name = np->name;
+		pcie->busn.start = 0;
+		pcie->busn.end = 0xff;
+		pcie->busn.flags = IORESOURCE_BUS;
 	}
 
 	return 0;
 }
 
-static int __init ls_pcie_probe(struct platform_device *pdev)
+static int ls_pcie_get_resources(struct ls_pcie *pcie)
 {
-	struct ls_pcie *pcie;
-	struct resource *dbi_base;
+	struct platform_device *pdev = to_platform_device(pcie->dev);
+	struct resource *regs_res;
 	struct device_node *np;
 	int ret;
 
-	pcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);
-	if (!pcie)
-		return -ENOMEM;
-
-	pcie->dev = &pdev->dev;
-	pcie->index = global_index++;
-
-	dbi_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!dbi_base) {
+	regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs_res) {
 		dev_err(&pdev->dev, "dbi_base memory resource not found\n");
 		return -ENODEV;
 	}
 
-	pcie->dbi = devm_ioremap_resource(&pdev->dev, dbi_base);
-	if (IS_ERR(pcie->dbi)) {
-		ret = PTR_ERR(pcie->dbi);
-		goto err;
+	pcie->regs = devm_ioremap_resource(&pdev->dev, regs_res);
+	if (IS_ERR(pcie->regs)) {
+		ret = PTR_ERR(pcie->regs);
+		return ret;
 	}
 
 	/* map SCFG register */
@@ -200,46 +564,318 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 	if (!pcie->scfg) {
 		dev_err(&pdev->dev, "unable to find SCFG registers\n");
 		ret = -ENODEV;
-		goto err;
+		return ret;
+	}
+
+	pcie->cfg0_size = resource_size(&pcie->cfg)/2;
+	pcie->cfg1_size = resource_size(&pcie->cfg)/2;
+	pcie->cfg0_base = pcie->cfg.start;
+	pcie->cfg1_base = pcie->cfg.start + pcie->cfg0_size;
+
+	pcie->va_cfg0_base = devm_ioremap(pcie->dev, pcie->cfg0_base,
+					pcie->cfg0_size);
+	if (!pcie->va_cfg0_base) {
+		dev_err(pcie->dev, "error with ioremap\n");
+		return -ENOMEM;
+	}
+	pcie->va_cfg1_base = devm_ioremap(pcie->dev, pcie->cfg1_base,
+					pcie->cfg1_size);
+	if (!pcie->va_cfg1_base) {
+		dev_err(pcie->dev, "error with ioremap\n");
+		return -ENOMEM;
 	}
 
 	/* request interrupt */
 	pcie->irq = platform_get_irq_byname(pdev, "intr");
 	if (pcie->irq < 0) {
 		dev_err(&pdev->dev, "failed to get IRQ: %d\n", pcie->irq);
-		goto err;
+		return -ENODEV;
+	}
+	ret = devm_request_irq(pcie->dev, pcie->irq, ls_pcie_irq_handler,
+				IRQF_SHARED, pcie->name, pcie);
+	if (ret) {
+		dev_err(pcie->dev, "failed to requesppt irq\n");
+		return ret;
 	}
 
 	pcie->cfg_irq = platform_get_irq_byname(pdev, "cfg-err");
 	if (pcie->cfg_irq < 0) {
 		dev_err(&pdev->dev,
 			"failed to get CFG error IRQ: %d\n", pcie->cfg_irq);
-		goto err;
-	}
-
-	pcie->msi_irq = platform_get_irq_byname(pdev, "msi");
-	if (pcie->msi_irq < 0) {
-		dev_err(&pdev->dev,
-			"failed to get MSI IRQ: %d\n", pcie->msi_irq);
-		goto err;
+		return -ENODEV;
 	}
 
 	pcie->inta_irq = platform_get_irq_byname(pdev, "inta");
 	if (pcie->inta_irq < 0) {
 		dev_err(&pdev->dev,
 			"failed to get INTA IRQ: %d\n", pcie->inta_irq);
-		goto err;
+		return -ENODEV;
 	}
-	ret = ls_add_pcie_port(pcie);
-	if (ret < 0)
-		goto err;
 
-	platform_set_drvdata(pdev, pcie);
-	list_add(&pcie->node, &ls_pcie_list);
+	return 0;
+}
+
+static int ls_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct ls_pcie *pcie = sys_to_pcie(sys);
+
+	if (!pcie)
+		return 0;
+
+	pci_add_resource(&sys->resources, &pcie->busn);
+
+	sys->io_offset = global_io_offset - pcie->io_bus_addr;
+	pci_ioremap_io(global_io_offset, pcie->io.start);
+	global_io_offset += SZ_64K;
+	pci_add_resource_offset(&sys->resources, &pcie->io,
+				sys->io_offset);
+
+	sys->mem_offset = pcie->mem.start - pcie->mem_bus_addr;
+	pci_add_resource_offset(&sys->resources, &pcie->mem, sys->mem_offset);
+
+	return 1;
+	return 1;
+}
+
+static int ls_pcie_map_irq(const struct pci_dev *pdev, u8 slot, u8 pin)
+{
+	struct ls_pcie *pcie = sys_to_pcie(pdev->bus->sysdata);
+
+	return pcie->inta_irq;
+}
+
+static void ls_pcie_add_bus(struct pci_bus *bus)
+{
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		struct ls_pcie *pcie = sys_to_pcie(bus->sysdata);
+
+		bus->msi = &pcie->msi.chip;
+	}
+}
+
+static struct pci_bus *ls_pcie_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct ls_pcie *pcie = sys_to_pcie(sys);
+	struct pci_bus *bus;
+
+	if (!pcie)
+		return NULL;
+
+	pcie->root_bus_nr = sys->busnr;
+	bus = pci_scan_root_bus(pcie->dev, sys->busnr, &ls_pcie_ops, sys,
+				&sys->resources);
+
+	return bus;
+}
+
+#ifdef DEBUG
+static void ls_pcie_atu_dump(struct ls_pcie *pcie, int dir, int num)
+{
+	int i;
+
+	for (i = 0; i < num; i++) {
+		pr_info("ATU %s - %d:\n",
+			dir == PCIE_ATU_REGION_OUTBOUND ?
+				"OUTBOUND" : "INBOUNF", i);
+
+		ls_pcie_write_reg(pcie, dir | i, PCIE_ATU_VIEWPORT);
+
+		pr_info("LOWER_BASE:   0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_LOWER_BASE));
+		pr_info("UPPER_BASE:   0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_UPPER_BASE));
+		pr_info("LIMIT:        0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_LIMIT));
+		pr_info("LOWER_TARGET: 0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_LOWER_TARGET));
+		pr_info("UPPER_TARGET: 0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_UPPER_TARGET));
+		pr_info("CR1:          0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_CR1));
+		pr_info("CR2:          0x%08x\n",
+			ls_pcie_read_reg(pcie, PCIE_ATU_CR2));
+	}
+}
+#endif
+
+static void ls_pcie_atu_cfg0(struct ls_pcie *pcie)
+{
+	/* ATU 0 : OUTBOUND : CFG0 */
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_CFG0_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, pcie->cfg0_base, PCIE_ATU_LOWER_BASE);
+	ls_pcie_write_reg(pcie, (pcie->cfg0_base >> 32), PCIE_ATU_UPPER_BASE);
+	ls_pcie_write_reg(pcie, pcie->cfg0_base + pcie->cfg0_size - 1,
+			  PCIE_ATU_LIMIT);
+	ls_pcie_write_reg(pcie, 0, PCIE_ATU_LOWER_TARGET);
+	ls_pcie_write_reg(pcie, 0, PCIE_ATU_UPPER_TARGET);
+	ls_pcie_write_reg(pcie, PCIE_ATU_TYPE_CFG0, PCIE_ATU_CR1);
+	ls_pcie_write_reg(pcie, PCIE_ATU_ENABLE, PCIE_ATU_CR2);
+}
+
+static void ls_pcie_atu_cfg1(struct ls_pcie *pcie)
+{
+	/* ATU 1 : OUTBOUND : CFG1 */
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_CFG1_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, PCIE_ATU_TYPE_CFG1, PCIE_ATU_CR1);
+	ls_pcie_write_reg(pcie, pcie->cfg1_base, PCIE_ATU_LOWER_BASE);
+	ls_pcie_write_reg(pcie, (pcie->cfg1_base >> 32), PCIE_ATU_UPPER_BASE);
+	ls_pcie_write_reg(pcie, pcie->cfg1_base + pcie->cfg1_size - 1,
+			  PCIE_ATU_LIMIT);
+	ls_pcie_write_reg(pcie, 0, PCIE_ATU_LOWER_TARGET);
+	ls_pcie_write_reg(pcie, 0, PCIE_ATU_UPPER_TARGET);
+	ls_pcie_write_reg(pcie, PCIE_ATU_ENABLE, PCIE_ATU_CR2);
+}
+
+static void ls_pcie_atu_mem_outbound(struct ls_pcie *pcie)
+{
+	/* ATU 2 : OUTBOUND : MEM */
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_MEM_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, PCIE_ATU_TYPE_MEM, PCIE_ATU_CR1);
+	ls_pcie_write_reg(pcie, pcie->mem.start, PCIE_ATU_LOWER_BASE);
+	ls_pcie_write_reg(pcie, (pcie->mem.start >> 32), PCIE_ATU_UPPER_BASE);
+	ls_pcie_write_reg(pcie, pcie->mem.end, PCIE_ATU_LIMIT);
+	ls_pcie_write_reg(pcie, pcie->mem_bus_addr, PCIE_ATU_LOWER_TARGET);
+	ls_pcie_write_reg(pcie, upper_32_bits(pcie->mem_bus_addr),
+			  PCIE_ATU_UPPER_TARGET);
+	ls_pcie_write_reg(pcie, PCIE_ATU_ENABLE, PCIE_ATU_CR2);
+}
+
+static void ls_pcie_atu_io_outbound(struct ls_pcie *pcie)
+{
+	/* ATU 3 : OUTBOUND : IO */
+	ls_pcie_write_reg(pcie,
+			  PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_IO_INDEX,
+			  PCIE_ATU_VIEWPORT);
+	ls_pcie_write_reg(pcie, PCIE_ATU_TYPE_IO, PCIE_ATU_CR1);
+	ls_pcie_write_reg(pcie, pcie->io.start, PCIE_ATU_LOWER_BASE);
+	ls_pcie_write_reg(pcie, (pcie->io.start >> 32), PCIE_ATU_UPPER_BASE);
+	ls_pcie_write_reg(pcie, pcie->io.end, PCIE_ATU_LIMIT);
+	ls_pcie_write_reg(pcie, pcie->io_bus_addr, PCIE_ATU_LOWER_TARGET);
+	ls_pcie_write_reg(pcie, upper_32_bits(pcie->io_bus_addr),
+			  PCIE_ATU_UPPER_TARGET);
+	ls_pcie_write_reg(pcie, PCIE_ATU_ENABLE, PCIE_ATU_CR2);
+}
+
+static int ls_pcie_setup_atu(struct ls_pcie *pcie)
+{
+	ls_pcie_atu_cfg0(pcie);
+	ls_pcie_atu_cfg1(pcie);
+	ls_pcie_atu_mem_outbound(pcie);
+	ls_pcie_atu_io_outbound(pcie);
+
+#ifdef DEBUG
+	ls_pcie_atu_dump(pcie, PCIE_ATU_REGION_OUTBOUND, 4);
+#endif
 
 	return 0;
+}
 
-err:
+static struct hw_pci dw_pci = {
+	.setup		= ls_pcie_setup,
+	.scan		= ls_pcie_scan_bus,
+	.map_irq	= ls_pcie_map_irq,
+	.add_bus	= ls_pcie_add_bus,
+	.ops		= &ls_pcie_ops,
+};
+
+static int ls_pcie_enable(struct ls_pcie *pcie)
+{
+	u32 val, membase, memlimit;
+
+	pcie->root_bus_nr = -1;
+
+	/* program correct class for RC */
+	val = ls_pcie_read_reg(pcie, PCI_CLASS_REVISION);
+	val &= 0x0000ffff;
+	val |= PCI_CLASS_BRIDGE_PCI << 16;
+	ls_pcie_write_reg(pcie, val, PCI_CLASS_REVISION);
+
+	/* setup RC BARs */
+	ls_pcie_write_reg(pcie, 0x00000004, PCI_BASE_ADDRESS_0);
+	ls_pcie_write_reg(pcie, 0x00000000, PCI_BASE_ADDRESS_1);
+
+	/* setup bus numbers */
+	val = ls_pcie_read_reg(pcie, PCI_PRIMARY_BUS);
+	val &= 0xff000000;
+	val |= 0x00010100;
+	ls_pcie_write_reg(pcie, val, PCI_PRIMARY_BUS);
+
+	/* setup memory base, memory limit */
+	membase = ((u32)pcie->mem.start & 0xfff00000) >> 16;
+	memlimit = (pcie->mem.end) & 0xfff00000;
+	val = memlimit | membase;
+	ls_pcie_write_reg(pcie, val, PCI_MEMORY_BASE);
+
+	/* setup command register */
+	val = ls_pcie_read_reg(pcie, PCI_COMMAND);
+	val &= 0xffff0000;
+	val |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+		PCI_COMMAND_MASTER | PCI_COMMAND_SERR;
+	ls_pcie_write_reg(pcie, val, PCI_COMMAND);
+
+	dw_pci.nr_controllers = 1;
+	dw_pci.private_data = (void **)&pcie;
+	pci_common_init_dev(pcie->dev, &dw_pci);
+	pci_assign_unassigned_resources();
+
+#ifdef CONFIG_PCI_DOMAINS
+	dw_pci.domain++;
+#endif
+
+	return 0;
+}
+
+static int __init ls_pcie_probe(struct platform_device *pdev)
+{
+	struct ls_pcie *pcie;
+	int ret;
+
+	pcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+
+	pcie->dev = &pdev->dev;
+	pcie->index = global_index++;
+	snprintf(pcie->name, sizeof(pcie->name), "PCIe%d", pcie->index);
+
+	ret = ls_pcie_parse_dt(pcie);
+	if (ret)
+		return ret;
+
+	ret = ls_pcie_get_resources(pcie);
+	if (ret)
+		return ret;
+
+	/* setup the AFI address translations */
+	ls_pcie_setup_atu(pcie);
+
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		ret = ls_pcie_enable_msi(pcie);
+		if (ret) {
+			dev_err(&pdev->dev,
+				"failed to enable MSI support: %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = ls_pcie_enable(pcie);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable PCIe%d\n", pcie->index);
+		goto disable_msi;
+	}
+
+	platform_set_drvdata(pdev, pcie);
+	return 0;
+
+disable_msi:
+	if (IS_ENABLED(CONFIG_PCI_MSI))
+		ls_pcie_disable_msi(pcie);
 	return ret;
 }
 
-- 
2.0.2

