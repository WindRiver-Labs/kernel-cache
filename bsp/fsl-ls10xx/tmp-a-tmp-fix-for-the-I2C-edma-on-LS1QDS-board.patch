From 85922169ed9035eacc621fa4aee08a9488ff0a64 Mon Sep 17 00:00:00 2001
From: Jason Jin <Jason.Jin@freescale.com>
Date: Fri, 25 Jul 2014 10:55:31 +0800
Subject: [PATCH 227/255] tmp: a tmp fix for the I2C edma on LS1QDS board

The I2C eDMA support on QDS will interrupt the FPGA. this a temp fix.
Need clean up.

Signed-off-by: Yuan Yao <yao.yuan@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/i2c/busses/i2c-imx.c | 81 +++++++++++++++++++++++++++-----------------
 1 file changed, 49 insertions(+), 32 deletions(-)

diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index f6d5229..0c4ecfc 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -483,9 +483,6 @@ static int i2c_imx_start(struct imx_i2c_struct *i2c_imx)
 	i2c_imx->stopped = 0;
 
 	temp |= I2CR_IIEN | I2CR_MTX | I2CR_TXAK;
-	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-
-	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
 	temp &= ~I2CR_DMAEN;
 	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
 
@@ -742,41 +739,61 @@ static int i2c_imx_read(struct imx_i2c_struct *i2c_imx, struct i2c_msg *msgs)
 		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
 		temp &= ~I2CR_DMAEN;
 		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-	} else {
+
+		/* read n-1 byte data */
+		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
+		temp |= I2CR_TXAK;
+		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
+
+		msgs->buf[msgs->len-2] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
+		/* read n byte data */
+		result = i2c_imx_trx_complete(i2c_imx);
+		if (result)
+		return result;
+
+		/*
+		* It must generate STOP before read I2DR to prevent
+		* controller from generating another clock cycle
+		*/
+		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
+		temp &= ~(I2CR_MSTA | I2CR_MTX);
+		imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
+		i2c_imx_bus_busy(i2c_imx, 0);
+		i2c_imx->stopped = 1;
+		msgs->buf[msgs->len-1] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
+
+		} else {
 		/* read data */
-		for (i = 0; i < msgs->len - 2; i++) {
+		for (i = 0; i < msgs->len; i++) {
 			result = i2c_imx_trx_complete(i2c_imx);
 			if (result)
 				return result;
-			msgs->buf[i] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
-			dev_dbg(dev, "<%s> read byte: B%d=0x%X\n",
-				__func__, i, msgs->buf[i]);
-		}
-		result = i2c_imx_trx_complete(i2c_imx);
+			if (i == (msgs->len - 1)) {
+				/*
+				 * It must generate STOP before read I2DR to prevent
+				 * controller from generating another clock cycle
+				 */
+				dev_dbg(&i2c_imx->adapter.dev,
+                                 "<%s> clear MSTA\n", __func__);
+                         temp = readb(i2c_imx->base + IMX_I2C_I2CR);
+                         temp &= ~(I2CR_MSTA | I2CR_MTX);
+                         writeb(temp, i2c_imx->base + IMX_I2C_I2CR);
+                         i2c_imx_bus_busy(i2c_imx, 0);
+                         i2c_imx->stopped = 1;
+                 } else if (i == (msgs->len - 2)) {
+                         dev_dbg(&i2c_imx->adapter.dev,
+                                 "<%s> set TXAK\n", __func__);
+                         temp = readb(i2c_imx->base + IMX_I2C_I2CR);
+                         temp |= I2CR_TXAK;
+                         writeb(temp, i2c_imx->base + IMX_I2C_I2CR);
+                 }
+                 msgs->buf[i] = readb(i2c_imx->base + IMX_I2C_I2DR);
+                 dev_dbg(&i2c_imx->adapter.dev,
+                         "<%s> read byte: B%d=0x%X\n",
+                         __func__, i, msgs->buf[i]);
+         }
 	}
 
-	/* read n-1 byte data */
-	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
-	temp |= I2CR_TXAK;
-	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-
-	msgs->buf[msgs->len-2] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
-	/* read n byte data */
-	result = i2c_imx_trx_complete(i2c_imx);
-	if (result)
-		return result;
-
-	/*
-	 * It must generate STOP before read I2DR to prevent
-	 * controller from generating another clock cycle
-	 */
-	temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
-	temp &= ~(I2CR_MSTA | I2CR_MTX);
-	imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
-	i2c_imx_bus_busy(i2c_imx, 0);
-	i2c_imx->stopped = 1;
-	msgs->buf[msgs->len-1] = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2DR);
-
 	return 0;
 }
 
-- 
2.0.2

