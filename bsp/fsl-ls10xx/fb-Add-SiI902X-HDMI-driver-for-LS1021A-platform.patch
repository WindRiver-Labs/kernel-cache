From 6c393ef255e80c4404765c6acbe946bf7e6a7bbf Mon Sep 17 00:00:00 2001
From: Xiubo Li <Li.Xiubo@freescale.com>
Date: Wed, 30 Jul 2014 17:15:06 +0800
Subject: [PATCH 228/255] fb: Add SiI902X HDMI driver for LS1021A platform

Signed-off-by: Jason Chen <b02280@freescale.com>
Signed-off-by: Xiubo Li <Li.Xiubo@freescale.com>
[Kevin: Original patch taken from
LS1021A-SDK-V1.1-ARM-SOURCE-20140815-yocto.iso]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/video/Kconfig       |   4 +
 drivers/video/Makefile      |   1 +
 drivers/video/fsl_sii902x.c | 771 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 776 insertions(+)
 create mode 100644 drivers/video/fsl_sii902x.c

diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 190c94b..63bed6b 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1984,6 +1984,10 @@ config FB_MBX_DEBUG
 
          If unsure, say N.
 
+config FB_FSL_SII902X
+	depends on FB
+	tristate "Si Image SII9022 DVI/HDMI Interface Chip"
+
 config FB_FSL_DCU
 	tristate "Freescale DCU framebuffer support"
 	depends on FB
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 82b9d34..c314f96 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -129,6 +129,7 @@ obj-$(CONFIG_FB_IMX)              += imxfb.o
 obj-$(CONFIG_FB_S3C)		  += s3c-fb.o
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
+obj-$(CONFIG_FB_FSL_SII902X)	  += fsl_sii902x.o
 obj-$(CONFIG_FB_FSL_DCU)	  += fsl-dcu-fb.o
 obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
 obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
diff --git a/drivers/video/fsl_sii902x.c b/drivers/video/fsl_sii902x.c
new file mode 100644
index 0000000..b457f36
--- /dev/null
+++ b/drivers/video/fsl_sii902x.c
@@ -0,0 +1,771 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/fsl_devices.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include "edid.h"
+
+#define SII_EDID_LEN	256
+static bool g_enable_hdmi = false;
+
+struct sii902x_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+};
+
+struct sii902x_data {
+	struct i2c_client *client;
+	struct delayed_work det_work;
+	struct fb_info *fbi;
+	struct sii902x_edid_cfg edid_cfg;
+	struct regmap *regmap;
+	unsigned int irq;
+	u8 cable_plugin;
+	u8 edid[SII_EDID_LEN];
+} *sii902x;
+
+static void sii902x_poweron(void);
+static void sii902x_poweroff(void);
+
+static struct i2c_client *sii902x_to_i2c(struct sii902x_data *sii902x)
+{
+	return sii902x->client;
+}
+
+static s32 sii902x_write(const struct i2c_client *client, u8 command, u8 value)
+{
+	return i2c_smbus_write_byte_data(client, command, value);
+}
+
+static s32 sii902x_read(const struct i2c_client *client, u8 command)
+{
+	int val;
+
+	val = i2c_smbus_read_word_data(client, command);
+
+	return val & 0xff;
+}
+
+static ssize_t sii902x_show_name(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	strcpy(buf, sii902x->fbi->fix.id);
+	sprintf(buf+strlen(buf), "\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(fb_name, S_IRUGO, sii902x_show_name, NULL);
+
+static ssize_t sii902x_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (sii902x->cable_plugin == 0)
+		strcpy(buf, "plugout\n");
+	else
+		strcpy(buf, "plugin\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(cable_state, S_IRUGO, sii902x_show_state, NULL);
+
+static ssize_t sii902x_show_edid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int i, j, len = 0;
+
+	for (j = 0; j < SII_EDID_LEN/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					sii902x->edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(edid, S_IRUGO, sii902x_show_edid, NULL);
+
+static void sii902x_power_up_tx(struct sii902x_data *sii902x)
+{
+	struct i2c_client *client = sii902x_to_i2c(sii902x);
+	int val;
+
+	val = sii902x_read(client, 0x1E);
+	val &= ~0x3;
+	sii902x_write(client, 0x1E, val);
+}
+
+static void sii902x_setup(struct fb_info *fbi)
+{
+	u16 data[4];
+	u32 refresh;
+	u8 *tmp;
+	int i;
+
+	dev_dbg(&sii902x->client->dev, "Sii902x: setup..\n");
+
+	/* Power up */
+	sii902x_power_up_tx(sii902x);
+
+	/* set TPI video mode */
+	data[0] = PICOS2KHZ(fbi->var.pixclock) / 10;
+	data[2] = fbi->var.hsync_len + fbi->var.left_margin +
+		  fbi->var.xres + fbi->var.right_margin;
+	data[3] = fbi->var.vsync_len + fbi->var.upper_margin +
+		  fbi->var.yres + fbi->var.lower_margin;
+	refresh = data[2] * data[3];
+	refresh = (PICOS2KHZ(fbi->var.pixclock) * 1000) / refresh;
+	data[1] = refresh * 100;
+	tmp = (u8 *)data;
+	for (i = 0; i < 8; i++)
+		sii902x_write(sii902x->client, i, tmp[i]);
+
+	/* input bus/pixel: full pixel wide (24bit), rising edge */
+	sii902x_write(sii902x->client, 0x08, 0x70);
+	/* Set input format to RGB */
+	sii902x_write(sii902x->client, 0x09, 0x00);
+	/* set output format to RGB */
+	sii902x_write(sii902x->client, 0x0A, 0x00);
+	/* audio setup */
+	sii902x_write(sii902x->client, 0x25, 0x00);
+	sii902x_write(sii902x->client, 0x26, 0x40);
+	sii902x_write(sii902x->client, 0x27, 0x00);
+}
+
+const struct fb_videomode sii902x_cea_modes[64] = {
+	/* #1: 640x480p@59.94/60Hz */
+	[1] = {
+		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #3: 720x480p@59.94/60Hz */
+	[3] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #5: 1920x1080i@59.94/60Hz */
+	[5] = {
+		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED, 0,
+	},
+	/* #7: 720(1440)x480iH@59.94/60Hz */
+	[7] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED, 0,
+	},
+	/* #9: 720(1440)x240pH@59.94/60Hz */
+	[9] = {
+		NULL, 60, 1440, 240, 18554, 114, 38, 16, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #18: 720x576pH@50Hz */
+	[18] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #19: 1280x720p@50Hz */
+	[19] = {
+		NULL, 50, 1280, 720, 13468, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #20: 1920x1080i@50Hz */
+	[20] = {
+		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED, 0,
+	},
+	/* #32: 1920x1080p@23.98/24Hz */
+	[32] = {
+		NULL, 24, 1920, 1080, 13468, 148, 638, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+	/* #35: (2880)x480p4x@59.94/60Hz */
+	[35] = {
+		NULL, 60, 2880, 480, 9250, 240, 64, 30, 9, 248, 6, 0,
+		FB_VMODE_NONINTERLACED, 0,
+	},
+};
+
+static void sii902x_get_detailed_timing(unsigned char *block,
+				struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+	mode->pixclock /= 1000;
+	mode->pixclock = KHZ2PICOS(mode->pixclock);
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
+				     (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	printk("      %d MHz ",  PIXEL_CLOCK/1000000);
+	printk("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	printk("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	printk("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	       (VSYNC_POSITIVE) ? "+" : "-");
+}
+
+int sii902x_edid_parse_ext_blk(unsigned char *edid,
+		struct sii902x_edid_cfg *cfg,
+		struct fb_monspecs *specs)
+{
+	char detail_timming_desc_offset;
+	struct fb_videomode *mode, *m;
+	unsigned char index = 0x0;
+	unsigned char *block;
+	int i, num = 0;
+
+	if (edid[index++] != 0x2) /* only support cea ext block now */
+		return -1;
+	if (edid[index++] != 0x3) /* only support version 3*/
+		return -1;
+	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
+	if (mode == NULL)
+		return -1;
+
+	detail_timming_desc_offset = edid[index++];
+
+	cfg->cea_underscan = (edid[index] >> 7) & 0x1;
+	cfg->cea_basicaudio = (edid[index] >> 6) & 0x1;
+	cfg->cea_ycbcr444 = (edid[index] >> 5) & 0x1;
+	cfg->cea_ycbcr422 = (edid[index] >> 4) & 0x1;
+
+	/* short desc */
+	printk("CEA Short desc timmings\n");
+	index++;
+	while (index < detail_timming_desc_offset) {
+		unsigned char tagcode, blklen;
+
+		tagcode = (edid[index] >> 5) & 0x7;
+		blklen = (edid[index]) & 0x1f;
+
+		printk("Tagcode %x Len %d\n", tagcode, blklen);
+
+		switch (tagcode) {
+		case 0x2: /*Video data block*/
+		{
+			int cea_idx;
+			i = 0;
+			while (i < blklen) {
+				index++;
+				cea_idx = edid[index] & 0x7f;
+				if (cea_idx < ARRAY_SIZE(sii902x_cea_modes) &&
+					(sii902x_cea_modes[cea_idx].xres)) {
+					printk("Support CEA Format #%d\n", cea_idx);
+					mode[num] = sii902x_cea_modes[cea_idx];
+					mode[num].flag |= FB_MODE_IS_STANDARD;
+					num++;
+				}
+				i++;
+			}
+			break;
+		}
+		case 0x3: /*Vendor specific data*/
+		{
+			unsigned char IEEE_reg_iden[3];
+			IEEE_reg_iden[0] = edid[index+1];
+			IEEE_reg_iden[1] = edid[index+2];
+			IEEE_reg_iden[2] = edid[index+3];
+
+			if ((IEEE_reg_iden[0] == 0x03) &&
+				(IEEE_reg_iden[1] == 0x0c) &&
+				(IEEE_reg_iden[2] == 0x00))
+				cfg->hdmi_cap = 1;
+			index += blklen;
+			break;
+		}
+		case 0x1: /*Audio data block*/
+		case 0x4: /*Speaker allocation block*/
+		case 0x7: /*User extended block*/
+		default:
+			/* skip */
+			index += blklen;
+			break;
+		}
+
+		index++;
+	}
+
+	/* long desc */
+	printk("CEA long desc timmings\n");
+	index = detail_timming_desc_offset;
+	block = edid + index;
+	while (index < (EDID_LENGTH - DETAILED_TIMING_DESCRIPTION_SIZE)) {
+		if (!(block[0] == 0x00 && block[1] == 0x00)) {
+			sii902x_get_detailed_timing(block, &mode[num]);
+			num++;
+		}
+		block += DETAILED_TIMING_DESCRIPTION_SIZE;
+		index += DETAILED_TIMING_DESCRIPTION_SIZE;
+	}
+
+	if (!num) {
+		kfree(mode);
+		return 0;
+	}
+
+	m = kmalloc((num + specs->modedb_len) *
+			sizeof(struct fb_videomode), GFP_KERNEL);
+	if (!m)
+		return 0;
+
+	if (specs->modedb_len) {
+		memmove(m, specs->modedb,
+			specs->modedb_len * sizeof(struct fb_videomode));
+		kfree(specs->modedb);
+	}
+	memmove(m+specs->modedb_len, mode,
+		num * sizeof(struct fb_videomode));
+	kfree(mode);
+
+	specs->modedb_len += num;
+	specs->modedb = m;
+
+	return 0;
+}
+/* make sure edid has 256 bytes*/
+static int __sii902x_read_edid(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct sii902x_edid_cfg *cfg, struct fb_info *fbi)
+{
+	u8 buf0[2] = {0, 0};
+	int dat = 0, i;
+	struct i2c_msg msg[2] = {
+		{
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= buf0,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	if (adp == NULL)
+		return -EINVAL;
+
+	memset(edid, 0, 256);
+	memset(cfg, 0, sizeof(struct sii902x_edid_cfg));
+
+	buf0[0] = 0x00;
+	dat = i2c_transfer(adp, msg, 2);
+
+	/* If 0x50 fails, try 0x37. */
+	if (edid[1] == 0x00) {
+		msg[0].addr = msg[1].addr = 0x37;
+		dat = i2c_transfer(adp, msg, 2);
+		if (dat < 0)
+			return dat;
+	}
+
+	if (edid[1] == 0x00)
+		return -ENOENT;
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	/* need read ext block? Only support one more blk now*/
+	if (edid[0x7E]) {
+			printk("Edid[0x7E != 0x%x\n", edid[0x7E]);
+		if (edid[0x7E] > 1)
+			printk("Edid has %d ext block, \
+				but now only support 1 ext blk\n", edid[0x7E]);
+		buf0[0] = 0x80;
+		msg[1].buf = edid + EDID_LENGTH;
+		dat = i2c_transfer(adp, msg, 2);
+		if (dat < 0)
+			return dat;
+
+		/* edid ext block parsing */
+		sii902x_edid_parse_ext_blk(edid + 128, cfg, &fbi->monspecs);
+	}
+
+	for (i = 0; i < 256; i++) {
+		if (i % 16 == 0)
+			printk("\n0x%02x~0x%02x: ", i, i+15);
+		printk("%02x ", edid[i]);
+	}
+	printk("\n");
+	return 0;
+}
+static int sii902x_read_edid(struct fb_info *fbi)
+{
+	int old, dat, ret, cnt = 100;
+	unsigned short addr = 0x50;
+
+	old = sii902x_read(sii902x->client, 0x1A);
+
+	sii902x_write(sii902x->client, 0x1A, old | 0x4);
+	do {
+		cnt--;
+		msleep(10);
+		dat = sii902x_read(sii902x->client, 0x1A);
+	} while ((!(dat & 0x2)) && cnt);
+
+	if (!cnt) {
+		ret = -1;
+		goto done;
+	}
+
+	sii902x_write(sii902x->client, 0x1A, old | 0x06);
+
+	/* edid reading */
+	ret = __sii902x_read_edid(sii902x->client->adapter, addr,
+				sii902x->edid, &sii902x->edid_cfg, fbi);
+
+	cnt = 100;
+	do {
+		cnt--;
+		sii902x_write(sii902x->client, 0x1A, old & ~0x6);
+		msleep(10);
+		dat = sii902x_read(sii902x->client, 0x1A);
+	} while ((dat & 0x6) && cnt);
+
+	if (!cnt)
+		ret = -1;
+
+done:
+	sii902x_write(sii902x->client, 0x1A, old);
+	return ret;
+}
+
+static void det_worker(struct work_struct *work)
+{
+	int val, ret;
+	char event_string[16];
+	char *envp[] = { event_string, NULL };
+
+	val = sii902x_read(sii902x->client, 0x3D);
+	if (val & 0x1 || g_enable_hdmi) {
+		/* cable connection changes */
+		if (val & 0x4 || g_enable_hdmi) {
+			sii902x->cable_plugin = 1;
+			sprintf(event_string, "EVENT=plugin");
+
+			ret = sii902x_read_edid(sii902x->fbi);
+			if (ret < 0) {
+				dev_err(&sii902x->client->dev,
+						"Sii902x: read edid fail\n");
+				goto err;
+			}
+
+			/* make sure fb is powerdown */
+			console_lock();
+			fb_blank(sii902x->fbi, FB_BLANK_POWERDOWN);
+			console_unlock();
+
+			if (sii902x->fbi->monspecs.modedb_len > 0) {
+				int i;
+				const struct fb_videomode *mode;
+				struct fb_videomode m;
+
+				fb_destroy_modelist(&sii902x->fbi->modelist);
+
+				for (i = 0; i < sii902x->fbi->monspecs.modedb_len; i++) {
+					/*FIXME now we do not support interlaced mode */
+					if (!(sii902x->fbi->monspecs.modedb[i].vmode & FB_VMODE_INTERLACED))
+						fb_add_videomode(&sii902x->fbi->monspecs.modedb[i],
+								&sii902x->fbi->modelist);
+				}
+
+				fb_var_to_videomode(&m, &sii902x->fbi->var);
+				mode = fb_find_nearest_mode(&m,
+						&sii902x->fbi->modelist);
+
+				fb_videomode_to_var(&sii902x->fbi->var, mode);
+
+				sii902x->fbi->var.activate |= FB_ACTIVATE_FORCE;
+				console_lock();
+				sii902x->fbi->flags |= FBINFO_MISC_USEREVENT;
+				fb_set_var(sii902x->fbi, &sii902x->fbi->var);
+				sii902x->fbi->flags &= ~FBINFO_MISC_USEREVENT;
+				console_unlock();
+			}
+
+			console_lock();
+			fb_blank(sii902x->fbi, FB_BLANK_UNBLANK);
+			console_unlock();
+		} else {
+			sii902x->cable_plugin = 0;
+			sprintf(event_string, "EVENT=plugout");
+			console_lock();
+			fb_blank(sii902x->fbi, FB_BLANK_POWERDOWN);
+			console_unlock();
+		}
+		kobject_uevent_env(&sii902x->client->dev.kobj, KOBJ_CHANGE, envp);
+	}
+err:
+	sii902x_write(sii902x->client, 0x3D, val);
+}
+
+static irqreturn_t sii902x_detect_handler(int irq, void *data)
+{
+	if (g_enable_hdmi)
+		g_enable_hdmi = false;
+
+	if (sii902x->fbi)
+		schedule_delayed_work(&(sii902x->det_work), msecs_to_jiffies(20));
+	return IRQ_HANDLED;
+}
+
+static int sii902x_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+	struct fb_info *fbi = event->info;
+
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+		if (sii902x->fbi != NULL)
+			break;
+		sii902x->fbi = fbi;
+		if (g_enable_hdmi && sii902x->fbi) {
+			schedule_delayed_work(&(sii902x->det_work), msecs_to_jiffies(20));
+		}
+		break;
+	case FB_EVENT_MODE_CHANGE:
+		sii902x_setup(fbi);
+		break;
+	case FB_EVENT_BLANK:
+		if (*((int *)event->data) == FB_BLANK_UNBLANK)
+			sii902x_poweron();
+		else
+			sii902x_poweroff();
+		break;
+	}
+
+	return 0;
+}
+
+static void sii902x_chip_id(struct sii902x_data *sii902x)
+{
+	struct i2c_client *client = sii902x_to_i2c(sii902x);
+	int val;
+
+	/* read device ID */
+	val = sii902x_read(client, 0x1B);
+	printk("Sii902x: read id = 0x%02X", val);
+	val = sii902x_read(client, 0x1C);
+	printk("-0x%02X", val);
+	val = sii902x_read(client, 0x1D);
+	printk("-0x%02X", val);
+	val = sii902x_read(client, 0x30);
+	printk("-0x%02X\n", val);
+}
+
+static int sii902x_initialize(struct sii902x_data *sii902x)
+{
+	struct i2c_client *client = sii902x_to_i2c(sii902x);
+	int ret, cnt;
+
+	for (cnt = 0; cnt < 5; cnt++) {
+		/* Set 902x in hardware TPI mode on and jump out of D3 state */
+		ret = sii902x_write(client, 0xC7, 0x00);
+		if (ret < 0)
+			break;
+	}
+	if (0 != ret)
+		dev_err(&client->dev, "Sii902x: cound not find device\n");
+
+	return ret;
+}
+
+static void sii902x_enable_source(struct sii902x_data *sii902x)
+{
+	struct i2c_client *client = sii902x_to_i2c(sii902x);
+	int val;
+
+	sii902x_write(client, 0xBC, 0x01);
+	sii902x_write(client, 0xBD, 0x82);
+	val = sii902x_read(client, 0xBE);
+	val |= 0x1;
+	sii902x_write(client, 0xBE, val);
+}
+
+static struct notifier_block nb = {
+	.notifier_call = sii902x_fb_event,
+};
+
+static int sii902x_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+	int ret, err;
+	struct fb_info edid_fbi;
+
+	if (!g_enable_hdmi)
+		return -EPERM;
+
+	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_BYTE)) {
+		dev_err(&client->dev, "Sii902x: i2c_check_functionality error\n");
+		return -ENODEV;
+	}
+
+	sii902x = devm_kzalloc(&client->dev, sizeof(*sii902x), GFP_KERNEL);
+	if (!sii902x)
+		return -ENOMEM;
+
+	sii902x->client = client;
+	i2c_set_clientdata(client, sii902x);
+
+	err = sii902x_initialize(sii902x);
+	if (err)
+		return err;
+
+	sii902x_chip_id(sii902x);
+	sii902x_power_up_tx(sii902x);
+	sii902x_enable_source(sii902x);
+
+	/* try to read edid */
+	if (sii902x_read_edid(&edid_fbi) < 0)
+		dev_warn(&client->dev, "Can not read edid\n");
+
+	if (client->irq) {
+		ret = devm_request_irq(&client->dev, client->irq, sii902x_detect_handler, 0,
+				 "SII902x_det", sii902x);
+		if (ret < 0)
+			dev_warn(&client->dev,
+				"Sii902x: cound not request det irq %d\n",
+				client->irq);
+		else {
+			INIT_DELAYED_WORK(&(sii902x->det_work), det_worker);
+			/*enable cable hot plug irq*/
+			sii902x_write(client, 0x3C, 0x01);
+		}
+		ret = device_create_file(&client->dev, &dev_attr_fb_name);
+		if (ret < 0)
+			dev_warn(&client->dev,
+				"Sii902x: cound not create sys node for fb name\n");
+		ret = device_create_file(&client->dev, &dev_attr_cable_state);
+		if (ret < 0)
+			dev_warn(&client->dev,
+				"Sii902x: cound not create sys node for cable state\n");
+		ret = device_create_file(&client->dev, &dev_attr_edid);
+		if (ret < 0)
+			dev_warn(&client->dev,
+				"Sii902x: cound not create sys node for edid\n");
+	}
+
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int sii902x_remove(struct i2c_client *client)
+{
+	fb_unregister_client(&nb);
+	sii902x_poweroff();
+	return 0;
+}
+
+static void sii902x_poweron(void)
+{
+	/* Turn on DVI or HDMI */
+	if (sii902x->edid_cfg.hdmi_cap)
+		sii902x_write(sii902x->client, 0x1A, 0x01);
+	else
+		sii902x_write(sii902x->client, 0x1A, 0x00);
+	return;
+}
+
+static void sii902x_poweroff(void)
+{
+	/* disable tmds before changing resolution */
+	if (sii902x->edid_cfg.hdmi_cap)
+		sii902x_write(sii902x->client, 0x1A, 0x11);
+	else
+		sii902x_write(sii902x->client, 0x1A, 0x10);
+
+	return;
+}
+
+static const struct i2c_device_id sii902x_id[] = {
+	{ "sii902x", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, sii902x_id);
+
+static const struct of_device_id sii902x_dt_ids[] = {
+	{ .compatible = "fsl,sii902x", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sii902x_dt_ids);
+
+static struct i2c_driver sii902x_i2c_driver = {
+	.driver = {
+		.name = "sii902x",
+		.owner = THIS_MODULE,
+		.of_match_table = sii902x_dt_ids,
+	},
+	.probe = sii902x_probe,
+	.remove = sii902x_remove,
+	.id_table = sii902x_id,
+};
+module_i2c_driver(sii902x_i2c_driver);
+
+static int __init enable_hdmi_setup(char *str)
+{
+	g_enable_hdmi = true;
+
+	return 1;
+}
+__setup("hdmi", enable_hdmi_setup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SII902x DVI/HDMI driver");
+MODULE_LICENSE("GPL");
-- 
2.0.2

