From 664616b72aecd9cf33d5d717269ed96d157ef58d Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 26 Dec 2008 13:32:37 +0800
Subject: [PATCH] Support I2C Bus and Devices on emer_atcaf101

It's failed to access RTC device by calling directly the i2c-mv64xxx's original
algorithm. And the probing function of another i2c device, eeprom, uses one same
address as the RTC. So when debugging RTC driver the eeprom is corrupted by
some operations. As a result the board is broken since the MOTLoad firmware
cannot start for missing the some necessary board information from the eeprom.
Another point, here the i2c's special algorithm is also using some information
from the eeprom to implement the good operation, and some hardware issue also
should be set correctly while calling i2c read/write function. So it's safe and
necessary to uprev the original patches.

The main modifications:
1) Modify Kconfig and Makefile to use this given i2c-algo;
2) Add appropriate i2c-algo-mv64360;
	* i2c-algo-mv64360.c
	* i2c-mv64360.h
	* i2c-algo-mv64360.h
3) Modify the eeprom driver to skip probing the same address as RTC;
4) Export register base to i2c-algo-mv64360 to access i2c space;
	* i2c-mv64xxx.c
5) Export gpp base to i2c-algo-mv64360 to fix the hardware issue.
	* prpmc2800.c

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/platforms/embedded6xx/prpmc2800.c |    3 +-
 drivers/i2c/algos/Kconfig                      |    6 +
 drivers/i2c/algos/Makefile                     |    1 +
 drivers/i2c/algos/i2c-algo-mv64360.c           |  987 ++++++++++++++++++++++++
 drivers/i2c/algos/i2c-mv64360.h                |   96 +++
 drivers/i2c/busses/i2c-mv64xxx.c               |    8 +
 drivers/i2c/chips/eeprom.c                     |    7 +
 include/linux/i2c-algo-mv64360.h               |   39 +
 8 files changed, 1146 insertions(+), 1 deletions(-)
 create mode 100644 drivers/i2c/algos/i2c-algo-mv64360.c
 create mode 100644 drivers/i2c/algos/i2c-mv64360.h
 create mode 100644 include/linux/i2c-algo-mv64360.h

diff --git a/arch/powerpc/platforms/embedded6xx/prpmc2800.c b/arch/powerpc/platforms/embedded6xx/prpmc2800.c
index e40b5a8..5f81409 100644
--- a/arch/powerpc/platforms/embedded6xx/prpmc2800.c
+++ b/arch/powerpc/platforms/embedded6xx/prpmc2800.c
@@ -36,7 +36,8 @@
 static char prpmc2800_platform_name[PLATFORM_NAME_MAX];
 
 static void __iomem *mv64x60_mpp_reg_base;
-static void __iomem *mv64x60_gpp_reg_base;
+void __iomem *mv64x60_gpp_reg_base;
+EXPORT_SYMBOL(mv64x60_gpp_reg_base);
 
 static void __init prpmc2800_setup_arch(void)
 {
diff --git a/drivers/i2c/algos/Kconfig b/drivers/i2c/algos/Kconfig
index b788579..ae9c4ae 100644
--- a/drivers/i2c/algos/Kconfig
+++ b/drivers/i2c/algos/Kconfig
@@ -18,4 +18,10 @@ config I2C_ALGO_SGI
 	tristate
 	depends on SGI_IP22 || SGI_IP32 || X86_VISWS
 
+config I2C_ALGOMV64360
+	tristate "I2C MV64360 Interfaces"
+	depends on MV64X60 && PPC_PRPMC2800
+	help
+		This adds support for the I2C interface on the PrPMC-280.
+
 endmenu
diff --git a/drivers/i2c/algos/Makefile b/drivers/i2c/algos/Makefile
index cac1051..a32cb93 100644
--- a/drivers/i2c/algos/Makefile
+++ b/drivers/i2c/algos/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
+obj-$(CONFIG_I2C_ALGOMV64360)	+= i2c-algo-mv64360.o
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/algos/i2c-algo-mv64360.c b/drivers/i2c/algos/i2c-algo-mv64360.c
new file mode 100644
index 0000000..3766f7c
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-mv64360.c
@@ -0,0 +1,987 @@
+/*******************************************************************************
+**	FileName:	i2c-algo-mv64360.c
+**	Author	:	D K Raghunandan Copyright ( c ) 2003
+**	Date	:	11 Mar 2003
+**	Notes	:	I2C driver algorithms for MV64360 Discovery Adapter.
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+
+**    This program is distributed in the hope that it will be useful,
+**    but WITHOUT ANY WARRANTY; without even the implied warranty of
+**    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**    GNU General Public License for more details.
+********************************************************************************
+**	$Author	:$
+**	$Date	:$
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/types.h>
+
+#include <linux/mv643xx.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-mv64360.h>
+
+#include <asm/system.h>
+#include <asm/machdep.h>
+#include "i2c-mv64360.h"
+
+#define MV64x60_MPP_CNTL_0      0x0000
+#define MV64x60_MPP_CNTL_2      0x0008
+
+#define MV64x60_GPP_IO_CNTL     0x0000
+#define MV64x60_GPP_LEVEL_CNTL  0x0010
+#define MV64x60_GPP_VALUE_SET   0x0018
+#define	MV64x60_GPP_VALUE_CLR	0x001c
+
+extern void __iomem *mv64x60_gpp_reg_base;
+
+/*******************************************************************************
+**		Defines
+*******************************************************************************/
+#undef	DEBUG
+
+#ifdef	DEBUG
+#define	DBG( string, args... ) printk(KERN_INFO "i2c-algo:" string, ##args )
+#else
+#define	DBG( string, args... )
+#endif
+
+#define	true	1 
+#define	false	0 
+
+extern struct mv64x60_handle bh;
+extern void __iomem            *reg_addr;
+
+#define gt_read(reg) readl(reg_addr + reg)
+#define gt_write(reg,value) writel(value, reg_addr + reg)
+
+uint eeprom_type;
+
+/*******************************************************************************
+**		Prototype Functions
+*******************************************************************************/
+bool	isIntFlagSet( void );
+void	clearIntFlag( void );
+int	get_eeprom_size( u_char );
+
+
+/******************************************************************************
+**		Utility Functions
+******************************************************************************/
+/******************************************************************************
+**  Function	:	get_eeprom_size
+**  Description	:	Detects dynamically the size of the EEPROM using a
+**			simple technique of using the 16-bit EEPROMWrite 
+**			and the 8-bitEEPROMWrite routines.
+**  Inputs	:	I2C Address
+**  Output	:	EEPROM TYPE                                                       
+******************************************************************************/
+int get_eeprom_size( u_char devadd )
+{
+	u_char dat,val;
+	u_char buffer[2];     
+	int eeprom_size = -1;
+
+	dat = 0xdd;
+	buffer[0] = dat;
+	
+	DBG("Detecting EEPROM device ......\n" ) ;
+
+	if( i2c_word_write( devadd, 0x1230, 1, buffer )){
+		if( i2c_byte_read( devadd, 0x12, 2, buffer ))
+		{
+			val = buffer[1];
+		
+			if( val == dat)
+				eeprom_size = 2;
+			else
+				eeprom_size = 64; 
+		} 
+		else
+			DBG("i2c_byte_read failed. \n" ) ;
+	}
+	else
+		DBG("\nUnable to detect EEPROM Device\n");
+	return( eeprom_size );
+}
+
+/******************************************************************************
+**  Function	:     clearIntFlag
+******************************************************************************/
+void clearIntFlag( )
+{
+	uint temp;
+
+	temp = gt_read( I2C_CONTROL );
+	gt_write( I2C_CONTROL, temp & 0xfffffff7 );
+}
+
+/******************************************************************************
+**  Function	:	isIntFlagSet.
+**
+**  Description	:	Checks wether the interrupt flag bit of the 
+**			Control Register is set or not.
+** Inputs	:	None.
+**
+** Outputs	:	True if set else false
+******************************************************************************/
+bool isIntFlagSet()
+{
+	uint temp;
+
+	DBG("Waiting for the Interrupt flag to be set .....\n");
+
+	temp = gt_read( I2C_CONTROL );
+
+	if(( temp & 0x8 ) == 0x8 )
+		return true;
+	else
+	return false;
+}
+
+/******************************************************************************
+** Function     : i2c_byte_write                                               
+** Description  : This routine does page write in to AT24C02A serial EEPROM at 
+**                a specified offset                                           
+** Inputs       : devAdd      - EEPROM hardware address                        
+**                writeoffset - page offset                                    
+**                noBytes     - Number of bytes to be written                  
+**                regFile1    - Array of data to be written                    
+** Outputs      : true  - If successful                                        
+**                false - If not successful                                    
+******************************************************************************/ 
+bool i2c_byte_write( u_char devAdd, u_char writeoffset, 
+		     uint noBytes,  u_char *regFile1 ) 
+{
+	u_char  regFile2[9];
+	uint    i = 0, j = 0;
+	bool    ret = true;
+
+	if(( noBytes < 0 ) || ( noBytes > 256 )){
+		DBG("Only 0-256 Bytes can be written.\n");
+		return( false );
+	}	
+
+	gt_write( I2C_SOFT_RESET, 0x0 );
+	udelay( I2C_DELAY );
+
+	for( i = 0, j = 1; i < noBytes; i++ ){
+
+		regFile2[j]=regFile1[i];
+
+		if(( j == 8 - ( writeoffset % 8 )) || 
+		   ( i == ( noBytes - 1 ))){
+
+			udelay( I2C_DELAY ); 
+
+			regFile2[0] = writeoffset;
+			gt_write( I2C_SOFT_RESET, 0x0 );
+
+			udelay( I2C_DELAY );   
+
+			if( i2c_write ( devAdd, regFile2, j + 1 )){
+				DBG("Burning of a Page over\n");
+			}
+			else{
+				DBG("Page burning Failed...\n");
+				ret = false;
+				break;
+			}
+
+			j = 0;
+			writeoffset = writeoffset + 8;
+			/* To go to the next page*/
+			writeoffset = writeoffset & 0xfffffff8; 
+		}
+
+		j++;
+	}/* End for ... */
+	return( ret );
+}
+
+/******************************************************************************
+** Function     : i2c_word_write                                               
+** Description  : This routine does page write in to AT24C02A 
+**		  serial EEPROM at a specified offset                                           
+** Inputs       : devAdd      - EEPROM hardware address                        
+**                writeoffset - page offset                                    
+**                noBytes     - Number of bytes to be written                  
+**                regFile1    - Array of data to be written                    
+** Outputs      : true  - If successful                                        
+**                false - If not successful                                    
+******************************************************************************/
+bool i2c_word_write( u_char devAdd, uint writeoffset, 
+		     uint noBytes,  u_char *regFile1 )
+{
+	u_char	regFile2[34];
+	uint	i = 0, j = 0;
+	bool	ret = true;
+
+	/* 13-bit address for 64k EEPROM*/ 
+	writeoffset = writeoffset & 0x1fff;      
+                             
+	if(( noBytes < 0 ) || ( noBytes > 8192 )){
+		DBG("Only 0-8192 Bytes can be written.\n");
+		return( false );
+	}	
+
+	gt_write( I2C_SOFT_RESET, 0x0 );
+
+	udelay( I2C_DELAY );
+
+	for( i = 0,j = 2; i < noBytes; i++ ){
+
+		regFile2[j]=regFile1[i];
+		if(( j == ( 33 - ( writeoffset % 32 ))) || 
+		   ( i == (noBytes-1))){
+
+			udelay( I2C_DELAY );
+
+			regFile2[0] = ( writeoffset & 0xff00 ) >> 8;
+			regFile2[1] = writeoffset & 0x00ff;
+
+			gt_write( I2C_SOFT_RESET, 0x0 );
+			udelay( I2C_DELAY );   
+
+			if( i2c_write( devAdd, regFile2, j + 1 )){ 
+				DBG("Burning of a Page over\n");
+			}
+			else {
+				DBG("Page burning Failed...\n");
+				ret = false;
+				break;
+			}
+			
+			j = 1;
+			writeoffset = writeoffset + 0x0020;                  
+			writeoffset = writeoffset & 0xffffffe0;
+		}
+	
+		j++;
+	}
+	return( ret );
+}
+
+
+/******************************************************************************
+** Function    : i2c_write                                                   
+**                                                                           
+** Description : This is the lowest level driver to write 
+**		 to a slave I2C device
+** Inputs      : devAdd  - Slave device hardware address.                      
+**               regFile - Array of data to be sent to the slave device        
+**               noBytes - Number of bytes to be sent.(present in the array)   
+** Output      : true  - if successful                                         
+**               false - if not successful                                     
+******************************************************************************/
+bool i2c_write( u_char devAdd, u_char* regFile, uint noBytes )
+{
+	uint i2cstatus, temp = 0x0, count = 0, data = 0;
+	bool ret= false;
+
+	udelay( I2C_DELAY );
+	data = (( M << 3 ) | N ) ;
+	gt_write( I2C_STATUS_BAUD_RATE, data ); 
+                     
+	gt_write( I2C_CONTROL, 0x60 );           
+	while( !isIntFlagSet() );                   
+
+	i2cstatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+	if(( i2cstatus == 0x08) || ( i2cstatus == 0x10 )){
+
+		udelay( I2C_DELAY );
+		gt_write( I2C_DATA, devAdd | 0x00 ); 
+		clearIntFlag();
+
+		while( !isIntFlagSet() );
+
+		i2cstatus = gt_read( I2C_STATUS_BAUD_RATE );
+        
+		switch( i2cstatus ){
+			case I2CBUS_ERROR:
+				DBG("Bus Error!!!\n");
+				temp = gt_read( I2C_CONTROL );
+				gt_write( I2C_CONTROL,temp | 0x10 );
+				udelay( I2C_DELAY );
+				clearIntFlag();
+				return ret;
+
+			case ADDR_WB_TRA_ACK:
+				udelay( I2C_DELAY );
+
+				/***** Data Write ******/
+				for ( count=0; count < noBytes; count++ ){
+					gt_write( I2C_DATA, regFile[count] );
+					clearIntFlag();
+					while( !isIntFlagSet() );
+
+					i2cstatus = gt_read( I2C_STATUS_BAUD_RATE );
+					switch( i2cstatus ){
+						case MASTER_DATA_TRA_ACK:
+							udelay( I2C_DELAY );
+							ret= true;
+							break;
+
+						case MASTER_DATA_TRA_NACK:
+							DBG("MASTER_DATA_TRA_NACK\n" );
+							ret = false;
+							break;
+
+						case MASTER_LOST_ARBTR_DURING_ADR_DATA:
+							DBG("MASTER_LOST_ARBTR_DURING_ADR_DATA\n" );
+							ret = false;
+							break;
+
+						default:
+							DBG("Error, I2C status %x\n",i2cstatus);
+							ret = false;
+							break;
+					}
+					if ( ret == false )
+					break;
+			} /* End for ... */
+
+			udelay( I2C_DELAY );
+			temp = gt_read( I2C_CONTROL );
+			gt_write(I2C_CONTROL, temp | 0x10);
+			clearIntFlag();
+			return ret;
+
+			case ADDR_WB_TRA_NACK:
+				temp = gt_read( I2C_CONTROL );
+				gt_write(I2C_CONTROL, temp | 0x10);
+				clearIntFlag();
+				gt_write(I2C_CONTROL,0x0);
+				return ret;
+		}/* End Switch... */
+	}
+	else{
+		DBG("I2C Start Condition Fails!!!\nI2C Status = %x\n",i2cstatus);
+		temp = gt_read( I2C_CONTROL );
+		gt_write( I2C_CONTROL, temp | 0x10 );
+		clearIntFlag();
+		gt_write( I2C_CONTROL, 0x00 );
+		return ret;
+	}
+	return ret;	    
+}
+
+/******************************************************************************
+** Function    : i2c_dummy_byte_write
+** Description : This routine does "Dummy write" to the EEPROM device
+**               specifically, for random read and sequencial read  
+** Inputs      : devAdd  - EEPROM device hardware address
+**               roffset - Offset from where the next read command would 
+**                        like to read from.
+** Output      : true - If successful
+**               false - If not successful in issuing the "dummy write"
+******************************************************************************/
+bool i2c_dummy_byte_write( u_char devAdd, unsigned int roffset )
+{
+	uint i2cStatus, TempData = 0x0;
+	bool retval= false;
+
+	gt_write( I2C_STATUS_BAUD_RATE, 0x2c ); 
+
+	/* Start bit & enable bit*/
+	gt_write( I2C_CONTROL, 0x60 ); 
+	while( !isIntFlagSet() );
+
+	i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+    
+	if( i2cStatus==0x08 ){
+		gt_write( I2C_DATA, devAdd | 0x00); 
+		clearIntFlag();
+
+		while( !isIntFlagSet() );
+
+		i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+        
+		switch( i2cStatus ){
+			case I2CBUS_ERROR:
+				DBG("Bus error!!!\n");
+				TempData = gt_read( I2C_CONTROL );
+				/*generate stop bit*/
+				gt_write(I2C_CONTROL,TempData & 0x10 );
+				clearIntFlag();
+				return retval;
+
+			case ADDR_WB_TRA_ACK:
+				/* Word Address */
+				gt_write(I2C_DATA,roffset); 
+				clearIntFlag();
+				while(!isIntFlagSet());
+				i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+				switch( i2cStatus ){
+					case MASTER_DATA_TRA_ACK:
+						retval= true;
+						break;
+					case MASTER_DATA_TRA_NACK:
+						DBG("MASTER_DATA_TRA_NACK\n" );
+						retval = false;
+						break;
+					case MASTER_LOST_ARBTR_DURING_ADR_DATA:
+						DBG("MASTER_LOST_ARBTR_DURING_ADR_DATA\n");
+						retval = false;
+						break;
+				}
+				return retval;
+            
+			case ADDR_WB_TRA_NACK:
+				gt_write( I2C_CONTROL, TempData & 0x10 );
+				clearIntFlag();
+				udelay( I2C_DELAY );
+				gt_write( I2C_CONTROL, 0x0 );
+				return retval;
+		}
+	}
+	else
+	{
+		DBG("I2C Re-Start Condition Fails.....\n");
+		/* generate stop bit */
+		gt_write(I2C_CONTROL,TempData & 0x10);	
+		udelay( I2C_DELAY );
+		gt_write(I2C_CONTROL,0x0);
+		return retval;
+	}
+    return retval;
+}
+
+
+/******************************************************************************
+** Function    :  i2c_dummy_word_write
+** Description : This routine does "Dummy write" to the EEPROM device
+**               specifically, for random read and sequencial read  
+** Inputs      : devAdd  - EEPROM device hardware address
+**               roffset - Offset from where the next read command would 
+**                        like to read from.
+** Output      : true - If successful
+**               false - If not successful in issuing the "dummy write"
+******************************************************************************/
+bool i2c_dummy_word_write( u_char devAdd, uint roffset )
+{
+	uint i2cStatus, TempData = 0x0;
+	bool retval= false;
+	uint roffset1 = roffset;
+
+	gt_write( I2C_STATUS_BAUD_RATE, 0x2c );
+
+	/* Start bit & enable bit*/
+	gt_write( I2C_CONTROL, 0x60 ); 
+
+	while( !isIntFlagSet() );
+
+	i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+	if( i2cStatus == 0x08 ){
+		DBG("I2C Dummy Start Condition is succuessful\n");
+		DBG("Writes the Dummy Slave Address as :%x\n",devAdd);
+
+		gt_write(I2C_DATA,devAdd | 0x00); 
+		clearIntFlag();
+
+		while( !isIntFlagSet() );
+
+		i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+		switch( i2cStatus )
+		{
+			case I2CBUS_ERROR:
+				DBG("Bus error!!!\n");
+				TempData = gt_read( I2C_CONTROL );
+				gt_write( I2C_CONTROL, TempData & 0x10);
+				clearIntFlag( );
+				return retval;
+
+			case ADDR_WB_TRA_ACK:
+				DBG("The Offset : %x is being written\n",roffset);
+				roffset =( roffset & 0xff00 ) >> 8;
+				gt_write( I2C_DATA, roffset ); 
+				clearIntFlag();
+
+				while( !isIntFlagSet() );
+
+				i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+			switch( i2cStatus )
+			{
+				case MASTER_DATA_TRA_ACK:
+					roffset1 = roffset1 & 0x00ff;
+					gt_write( I2C_DATA, roffset1 );
+
+					clearIntFlag();
+					while( !isIntFlagSet() );
+					i2cStatus = gt_read( I2C_STATUS_BAUD_RATE );
+
+					switch( i2cStatus )
+					{
+					       case MASTER_DATA_TRA_ACK:
+						    retval = true;
+						    break;  
+					       case MASTER_DATA_TRA_NACK:
+						    retval=false;
+						    break;
+					       case MASTER_LOST_ARBTR_DURING_ADR_DATA:
+						    retval=false;
+						    break; 
+                    			}
+					return retval;
+				   case MASTER_DATA_TRA_NACK:
+					retval = false;
+					break;
+				   case MASTER_LOST_ARBTR_DURING_ADR_DATA:
+					retval = false;
+					break;
+			}
+			return retval;
+			case ADDR_WB_TRA_NACK:
+				DBG("ADDR_WB_TRA_NACK\n");
+				/*generate stop bit*/
+				gt_write(I2C_CONTROL,TempData & 0x10);
+				clearIntFlag();
+				udelay( I2C_DELAY );
+				gt_write(I2C_CONTROL,0x0);
+			return retval;
+		}
+	}
+	else{
+		DBG("I2C Re-Start Condition Fails.....\n");
+		/* generate stop bit */
+		gt_write(I2C_CONTROL,TempData & 0x10);	
+		udelay( I2C_DELAY );
+		gt_write(I2C_CONTROL,0x0);
+		return retval;
+	}
+    return retval;
+}
+
+/******************************************************************************
+**				READ Functions
+******************************************************************************/
+/******************************************************************************
+** Function      :  i2c_byte_read                                             
+** Description   : This routine reads from AT24C02A serial EEPROM at          
+**                 a specified offset                                         
+** Inputs        : devAdd     - EEPROM hardware device address                
+**                 readoffset - page offset                                   
+**                noBytes    - Number of bytes to be read                     
+**                 regFile    - Array where the read data has to be stored     
+** Outputs       : true  - If successful                                       
+**                 false - If not successful                                   
+******************************************************************************/ 
+bool i2c_byte_read( u_char devAdd, u_char readoffset,
+		    uint noBytes,  u_char *regFile )
+{ 
+	bool ret;
+
+	if(( noBytes < 0 ) || ( noBytes > 256 )){
+		DBG("Only 0-256 Bytes can be read.\n");
+		return( false );
+	}
+
+	udelay( I2C_DELAY * 2 );
+	gt_write( I2C_SOFT_RESET, 0x0 ); 
+	udelay( I2C_DELAY );
+
+	if( i2c_dummy_byte_write( devAdd, readoffset )){
+		DBG("Dummy write successful\n");
+		if( i2c_read( devAdd, regFile, noBytes))
+			ret = true;
+		else
+			ret = false;
+	}
+	else{ 
+		DBG("Dummy write NOT successful!!!\n");
+		ret = false;
+	}
+	return( ret );
+}	
+
+/******************************************************************************
+** Function      :  i2c_word_read                                              
+** Description   : This routine reads from AT24C02A serial EEPROM at           
+**                 a specified offset                                          
+** Inputs        : devAdd     - EEPROM hardware device address                 
+**                 readoffset - page offset                                    
+**                 noBytes    - Number of bytes to be read                     
+**                 regFile    - Array where the read data has to be stored     
+** Outputs       : true  - If successful                                       
+**                 false - If not successful                                   
+******************************************************************************/ 
+bool i2c_word_read( u_char devAdd, uint readoffset,
+		    uint noBytes,  u_char *regFile )
+{ 
+	bool ret;
+	/* 64k EEPROM requires 13-bit addrress */
+	readoffset = readoffset & 0x1fff;   
+
+	if(( noBytes < 0 ) || ( noBytes > 8192 )){
+		DBG("Only 0-8192 Bytes can be read.\n");
+		return( false );
+	}	
+	udelay( I2C_DELAY * 2 );
+	gt_write( I2C_SOFT_RESET, 0x0 ); 
+	udelay( I2C_DELAY );
+
+	if( i2c_dummy_word_write( devAdd, readoffset )){
+		DBG("Dummy write successful\n");
+		if( i2c_read( devAdd, regFile, noBytes ))
+			ret = true;
+		else
+			ret = false;
+	}
+	else{ 
+		DBG("Dummy write NOT successful!!!\n");
+		ret = false;
+	}
+	return( ret );
+}	
+	
+/******************************************************************************
+** Function    : i2c_read 
+**
+** Description : This is the lowest driver to read from the slave I2C device.
+** Inputs      : devAdd  - Slave I2c Device hardware address
+**               regFile - Array to store read data from slave
+**               index   - Number of bytes to read from slave
+** Output      : true  - If successful   
+**               false - If no successful
+******************************************************************************/
+bool i2c_read( u_char devAdd, u_char* regFile, uint index )
+{
+	uint	Status, Temp = 0x0, Count = 0, data = 0;
+	bool	Ret= false;
+
+	DBG("i2c_read() - 0x%x devaddr\n", devAdd ) ; 
+	data = (( M << 3 ) | N ) ;
+	gt_write( I2C_STATUS_BAUD_RATE, data );
+	gt_write( I2C_CONTROL, 0x64 );
+
+	udelay( I2C_DELAY );
+
+	while( !isIntFlagSet() );
+
+	Status = gt_read( I2C_STATUS_BAUD_RATE );
+	DBG("Status = 0x%x \n", Status );
+
+	if(( Status == 0x10) || ( Status == 0x08 ))
+	{
+		DBG("I2C Start Restart ok.\n" ) ;
+
+		gt_write(I2C_DATA,devAdd | 0x01);
+                                         
+		clearIntFlag();
+		while( !( isIntFlagSet() ));
+
+		Status = gt_read( I2C_STATUS_BAUD_RATE );
+
+		switch( Status ) 
+		{
+			case I2CBUS_ERROR:
+				DBG("Bus Error!!!\n");
+				Temp = gt_read( I2C_CONTROL);
+				gt_write( I2C_CONTROL, Temp & 0x10);
+				udelay( I2C_DELAY );
+				clearIntFlag();
+				return Ret;
+
+			case ADDR_RB_TRA_ACK:
+				DBG("In ADDR_RB_TRA_ACK... \n" ) ;
+				clearIntFlag(); 
+				udelay( I2C_DELAY * 2 );
+
+				for( Count = 0; Count < index; Count++ )
+				{
+					Status = gt_read( I2C_STATUS_BAUD_RATE );
+					switch( Status )
+					{
+						case MASTER_READ_ACK_TRA:
+						DBG("MASTER_READ_ACK_TRA \n " ) ;
+						regFile[Count] = gt_read( I2C_DATA );                   
+						clearIntFlag();  
+						udelay( I2C_DELAY * 5 );
+						Ret = true;
+						break;
+
+						case MASTER_READ_NACK_TRA:
+						DBG("MASTER_READ_NACK_TRA\n");
+						Ret = false;
+						clearIntFlag();
+						udelay( I2C_DELAY );
+						break;
+
+						default:
+						DBG("Failed to receive Data\n");
+						Ret = false;
+						clearIntFlag(); 
+						udelay( I2C_DELAY );
+						break;
+					}
+				} /*End of For loop */
+
+				Temp = gt_read( I2C_CONTROL );
+				gt_write( I2C_CONTROL, Temp & 0xfff0 );
+				udelay( I2C_DELAY );
+
+				gt_write( I2C_CONTROL, Temp & 0x10 ); 
+				clearIntFlag();
+				udelay( I2C_DELAY );
+				gt_write( I2C_CONTROL, 0x0 );
+				return Ret;
+
+			case ADDR_RB_TRA_NACK:
+				DBG("ADDR_RB_TRA_NACK\n");
+				gt_write(I2C_CONTROL,Temp & 0x10);
+				clearIntFlag();
+				udelay( I2C_DELAY );
+				gt_write( I2C_CONTROL, 0x0 );
+				return Ret;
+
+		}
+	}
+	else 
+	{
+		DBG("I2C Start/Re-start Condition Fails.....\n");
+		/* generate stop bit */
+		gt_write(I2C_CONTROL,Temp & 0x10); 
+		clearIntFlag();
+		udelay( I2C_DELAY );
+		gt_write( I2C_CONTROL, 0x0 );
+		return Ret;
+	}
+	return Ret;
+}
+
+/******************************************************************************/
+
+static int mv64360_init_i2c_core( void )
+{
+	eeprom_type = get_eeprom_size( 0xA8 ) ;
+	printk("AT24C%d EEPROM detected.\n", eeprom_type ) ;
+	return 0;
+}
+
+/******************************************************************************
+**		Device Algorithm Functions
+******************************************************************************/
+static int i2c_mv64360_xfer( struct i2c_adapter *adap, struct i2c_msg msg[],
+			     int num )
+{
+	struct i2c_algo_mv64360_data *adap_data = adap->algo_data ;
+	struct i2c_msg *pmsg ;
+	int i = 0 ;
+	u_char addr ;
+	u_char offset = adap_data->offset ;
+#if defined(CONFIG_PPC_PRPMC2800)
+	unsigned int temp;
+#endif /* CONFIG_PPC_PRPMC2800 */
+	
+	pmsg = &msg[i] ;
+	addr = ( pmsg->addr << 1 ) ;	
+	
+	DBG("Master Xfer: msg.flags = 0x%x, addr = 0x%x\n", 
+			 msg[i].flags, addr );
+
+#if defined(CONFIG_PPC_PRPMC2800)
+	/*****
+	 * Software needs to assert MPP9 low at the beginning of an I2C transaction and
+	 * assert it high again upon completion to catch the scenario where a RESET occurs
+	 * mid transaction. The PLD will not route the RESET signal if MPP9 is low. This
+	 * ensures that the tranaction will complete and not leave the I2C device being
+	 * accessed in a stale state.
+	 *****/
+
+	/* Mark as output */
+	temp = in_le32(mv64x60_gpp_reg_base + MV64x60_GPP_IO_CNTL);
+	temp |= (1<<9);
+	out_le32(mv64x60_gpp_reg_base + MV64x60_GPP_IO_CNTL, temp);
+
+	/* Mark as active high */
+	temp = in_le32(mv64x60_gpp_reg_base + MV64x60_GPP_LEVEL_CNTL);
+	temp |= (1<<9);
+	out_le32(mv64x60_gpp_reg_base + MV64x60_GPP_LEVEL_CNTL, temp);
+
+	/* Drive value low */
+	temp = in_le32(mv64x60_gpp_reg_base + MV64x60_GPP_VALUE_CLR);
+	temp |= (1<<9);
+	out_le32(mv64x60_gpp_reg_base + MV64x60_GPP_VALUE_CLR, temp);
+#endif /* CONFIG_PPC_PRPMC2800 */
+
+	/* Read */
+	if( pmsg->flags & I2C_M_RD ){
+		switch( eeprom_type )
+		{
+			case 2:		i2c_byte_read( addr,  offset, 
+						       pmsg->len, pmsg->buf ) ;
+					break;
+
+			case 64: 	i2c_word_read( addr, offset, 
+						       (uint) pmsg->len, pmsg->buf ) ;
+					break;
+
+			default:	printk("Read not implemented.\n" ) ;
+					break;
+		}
+			
+	}
+	/* Write */
+	else {
+		DBG("Writing...\n" );
+		switch( eeprom_type )	
+	{
+			case 2:		i2c_byte_write( addr, offset, 
+							pmsg->len, pmsg->buf );
+					break;
+	
+			case 64:	i2c_word_write( addr, offset, 
+							pmsg->len, pmsg->buf );
+					break;
+			
+			default:	printk("Write not implemented.\n" );
+					break;
+		}
+	}
+					
+#if defined(CONFIG_PPC_PRPMC2800)
+	/* Assert MPP9 High */
+	temp = in_le32(mv64x60_gpp_reg_base + MV64x60_GPP_VALUE_SET);
+	/* Drive value high */
+	temp |= (1<<9); 
+	out_le32(mv64x60_gpp_reg_base + MV64x60_GPP_VALUE_SET, temp);
+#endif /* CONFIG_PPC_PRPMC2800 */
+
+	return pmsg->len;
+}
+
+static u32 i2c_mv64360_func( struct i2c_adapter *adap )
+{
+	return ( I2C_FUNC_SMBUS_EMUL |
+		 I2C_FUNC_10BIT_ADDR |
+		 I2C_FUNC_PROTOCOL_MANGLING );
+}
+
+/******************************************************************************
+**		Exported Algorithm Data
+******************************************************************************/
+
+static struct i2c_algorithm i2c_mv64360_algo = {
+	/* older kernels */
+//	name: "MV64360 I2C Algorithm",	
+	/* older kernels */
+//	id: I2C_ALGO_EXP,		
+	master_xfer: i2c_mv64360_xfer,
+	smbus_xfer: NULL,
+	functionality: i2c_mv64360_func,
+};
+
+
+/******************************************************************************
+**		Registering fucntions to load algorithms at runtime
+******************************************************************************/
+
+int i2c_mv64360_add_bus( struct i2c_adapter *adap )
+{
+	DBG("Algorithm for MV64360 I2C %s registered.\n", adap->name );	
+
+	/* older kernels */
+//	adap->id |= i2c_mv64360_algo.id ;
+	adap->algo = &i2c_mv64360_algo ;
+
+	adap->timeout = 100;
+	adap->retries = 3;
+		
+	/* Now perform the MV64360 I2C initialization as mentioned 
+	   in the Data sheet */
+	mv64360_init_i2c_core( ) ;	
+
+	/* Add the Adapter */
+	
+	i2c_add_adapter( adap );
+	
+	return 0;
+}
+
+int i2c_mv64360_del_bus( struct i2c_adapter *adap )
+{
+	int res;
+	
+	if(( res = i2c_del_adapter( adap )) < 0 ){ 
+	
+		return res;
+	}
+	DBG("Delete Bus %s.\n", adap->name );
+	
+	return 0;
+}
+
+/*******************************************************************************
+**              Adapter Functions
+*******************************************************************************/
+static int i2c_mv64360_reg( struct i2c_client *client )
+{
+        DBG("Register Client, %s \n", client->name );
+        return 0;
+}
+
+static int i2c_mv64360_unreg( struct i2c_client *client )
+{
+        DBG("Unregister Client, %s \n", client->name );
+        return 0;
+}
+
+static struct i2c_algo_mv64360_data mv64360_data ;
+
+/******************************************************************************
+**              Exported Adapter Data
+******************************************************************************/
+static struct i2c_adapter i2c_mv64360_adap = {
+        .name = "MV64360",
+        .id = 0x00,
+        .algo = NULL, 
+        .algo_data = &mv64360_data,
+        .client_register = i2c_mv64360_reg,
+        .client_unregister = i2c_mv64360_unreg,
+};
+
+
+/******************************************************************************
+**		Initial Routine
+******************************************************************************/
+
+static int __init i2c_mv64360_init_module( void )
+{
+	printk( KERN_INFO "i2c-algo-mv64360: I2C MV64360 Module\n"); 
+
+	if( i2c_mv64360_add_bus( &i2c_mv64360_adap ) < 0 ){ 
+		printk("i2c-algo-mv64360: Unable to register with I2C.\n" );
+		return -ENODEV;
+	}
+
+	return 0; 
+}
+
+module_init( i2c_mv64360_init_module ) ;
+
+/******************************************************************************
+**		Exit Routine
+******************************************************************************/
+static void __exit i2c_mv64360_exit_module( void )
+{
+	printk( KERN_INFO "Unloading I2C MV64360 module.\n" );
+	i2c_mv64360_del_bus( &i2c_mv64360_adap );
+}
+
+module_exit( i2c_mv64360_exit_module ) ;
+
+MODULE_AUTHOR("D K Raghunandan" );
+MODULE_DESCRIPTION("I2C Bus MV64360 Algorithm" );
diff --git a/drivers/i2c/algos/i2c-mv64360.h b/drivers/i2c/algos/i2c-mv64360.h
new file mode 100644
index 0000000..2dfaeb2
--- /dev/null
+++ b/drivers/i2c/algos/i2c-mv64360.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+**	FileName	:	i2c-mv64360.h
+**	Author		:	D K Raghunandan
+**	Date		:	11 Mar 2003
+**	Notes		:	I2C MV64360 Discovery defines.
+**			Copyright ( c ) 2003 Force Computers India Pvt Ltd
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+
+**    This program is distributed in the hope that it will be useful,
+**    but WITHOUT ANY WARRANTY; without even the implied warranty of
+**    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**    GNU General Public License for more details.
+*******************************************************************************
+**	$Author		:$
+**	$Date		:$
+******************************************************************************/
+#ifndef	I2C_MV64360_H
+#define I2C_MV64360_H
+
+/******************************************************************************
+**	MV64360 I2C Registers
+******************************************************************************/
+#define	I2C_SLAVE_ADDR			0x00
+#define I2C_EXT_SLAVE_ADDR		0x40
+#define I2C_DATA			0x04
+#define I2C_CONTROL			0x08
+#define I2C_STATUS_BAUD_RATE		0x0C
+#define I2C_SOFT_RESET			0x1C
+
+/* Control Reg Bit defines */
+#define ACK				( 1 << 2 )
+#define IFLG				( 1 << 3 )
+#define STO				( 1 << 4 )
+#define STA				( 1 << 5 )
+#define I2CEN				( 1 << 6 )
+
+/* M and N Values for SYSCLK 100 MHz */
+#define M                               0x2
+#define N                               0x7
+
+
+#define GT_I2C_ADDRESS			0x08
+#define WRITE_BIT			0x0
+#define READ_BIT			0x1
+
+#define	I2C_DELAY			2000 
+
+
+/* I2C Status Codes */
+
+#define I2CBUS_ERROR						0x00
+#define I2C_START_TRA						0x08
+#define I2C_REP_START_TRA					0x08
+#define ADDR_WB_TRA_ACK						0x18
+#define ADDR_WB_TRA_NACK					0x20
+#define MASTER_DATA_TRA_ACK					0x28
+#define MASTER_DATA_TRA_NACK					0x30 
+#define MASTER_LOST_ARBTR_DURING_ADR_DATA			0x38
+#define ADDR_RB_TRA_ACK						0x40
+#define ADDR_RB_TRA_NACK					0x48
+#define MASTER_READ_ACK_TRA					0x50
+#define MASTER_READ_NACK_TRA					0x58
+#define SLAVE_RECD_ADDR_ACK					0x60
+#define MASTER_LOST_ARBTR_DURING_ADR_TRA_SLAVEW_ACK_TRA		0x68
+#define GEN_CALL_RECD_ACK_TRA					0x70
+#define MASTER_LOST_ARBTR_DURING_ADR_TRA_GCA_RECD_ACK_TRA	0x78
+#define SLAVE_RECD_WRT_DATA_AFTER_ADR_ACK_TRA			0x80
+#define SLAVE_RECD_WRT_DATA_AFTER_ADR_ACK_NTRA			0x88
+#define SLAVE_RECD_WRT_DATA_AFTER_GC_ACK_TRA			0x90
+#define SLAVE_RECD_WRT_DATA_AFTER_GC_ACK_NTRA			0x98
+#define SLAVE_RECD_STOP_REP_START				0xA0
+#define SLAVE_RECD_ADDR_RB_ACK_TRA				0xA8
+#define MASTER_LOST_ARBTR_DURING_ADR_TRA_SLAVER_ACK_TRA		0xB0
+#define SLAVE_TRA_READ_DATA_ACK_RECD				0xB8
+#define SLAVE_TRA_READ_DATA_ACK_NOT_RECD			0xC0
+#define	SLAVE_TRA_LOST_READ_BYTE_ACK_RECD			0xC8
+
+/* Prototypes */
+bool i2c_word_write( u_char, uint,unsigned int, u_char *);
+bool i2c_word_read( u_char, uint, unsigned int, u_char *);
+
+bool i2c_byte_write( u_char, u_char,unsigned int, u_char *);
+bool i2c_byte_read( u_char, u_char, unsigned int, u_char *);
+
+bool i2c_write( u_char,u_char*, unsigned int);
+bool i2c_read( u_char, u_char* , unsigned int );
+
+bool i2c_dummy_word_write( u_char , uint);
+bool i2c_dummy_byte_write(u_char , unsigned int);
+
+#endif /* I2C_MV64360_H */
+
diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index 9e8118d..d0b71be 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -101,6 +101,11 @@ struct mv64xxx_i2c_data {
 	struct i2c_adapter	adapter;
 };
 
+#if defined(CONFIG_PPC_PRPMC2800)
+void __iomem *reg_addr;
+EXPORT_SYMBOL(reg_addr);
+#endif
+
 /*
  *****************************************************************************
  *
@@ -476,6 +481,9 @@ mv64xxx_i2c_map_regs(struct platform_device *pd,
 		return -EBUSY;
 
 	drv_data->reg_base = ioremap(r->start, size);
+#if defined(CONFIG_PPC_PRPMC2800)
+	reg_addr = drv_data->reg_base;
+#endif
 	drv_data->reg_base_p = r->start;
 	drv_data->reg_size = size;
 
diff --git a/drivers/i2c/chips/eeprom.c b/drivers/i2c/chips/eeprom.c
index 2c27193..80ad7f4 100644
--- a/drivers/i2c/chips/eeprom.c
+++ b/drivers/i2c/chips/eeprom.c
@@ -29,8 +29,15 @@
 #include <linux/mutex.h>
 
 /* Addresses to scan */
+#if defined(CONFIG_PPC_PRPMC2800)
+/* We have to skip the same addres as RTC on PRPMC2800 platform. 
+ * Actually the eeprom is located only at 0x54.
+ */
+static const unsigned short normal_i2c[] = { 0x54, I2C_CLIENT_END };
+#else
 static const unsigned short normal_i2c[] = { 0x50, 0x51, 0x52, 0x53, 0x54,
 					0x55, 0x56, 0x57, I2C_CLIENT_END };
+#endif
 
 /* Insmod parameters */
 I2C_CLIENT_INSMOD_1(eeprom);
diff --git a/include/linux/i2c-algo-mv64360.h b/include/linux/i2c-algo-mv64360.h
new file mode 100644
index 0000000..73eebd1
--- /dev/null
+++ b/include/linux/i2c-algo-mv64360.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+**	FileNam	:	i2c-algo-mv64360.h
+**	Author	:	D K Raghunandan
+**	Date	:	11 Mar 2003
+**	Notes	:	I2C driver algorithms for MV64360 Discovery Adapter.
+**		Copyright ( c ) 2003
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+
+**    This program is distributed in the hope that it will be useful,
+**    but WITHOUT ANY WARRANTY; without even the implied warranty of
+**    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**    GNU General Public License for more details.
+*******************************************************************************
+**	$Author		:$
+**	$Date		:$
+******************************************************************************/
+#ifndef	I2C_ALGO_MV64360_H
+#define I2C_ALGO_MV64360_H
+
+#include <linux/i2c.h>
+
+struct i2c_algo_mv64360_data {
+	void *data;
+
+	/* local settings */
+	int udelay;
+	int mdelay;
+	int timeout;
+	unsigned int offset ;
+};
+
+int i2c_mv64360_add_bus( struct i2c_adapter * );
+int i2c_mv64360_del_bus( struct i2c_adapter * );
+
+#endif /* I2C_ALGO_MV64360_H */
-- 
1.6.0.3

