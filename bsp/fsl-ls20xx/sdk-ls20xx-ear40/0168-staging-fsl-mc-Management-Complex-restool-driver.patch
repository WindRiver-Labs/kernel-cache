From b59ac6bcbf99c422469ab8886edb6385148e70c0 Mon Sep 17 00:00:00 2001
From: Lijun Pan <Lijun.Pan@freescale.com>
Date: Wed, 18 Mar 2015 15:50:14 -0500
Subject: [PATCH 168/237] staging: fsl-mc: Management Complex restool driver

The kernel support for the restool is a driver
for the mc_restool device file. Its purpose is to provide
an ioctl interface, which the restool uses to interact
with the MC bus driver and with the MC firmware.

Signed-off-by: Lijun Pan <Lijun.Pan@freescale.com>
Change-Id: I1714274c5dd7c7e8bafd1056d18a2546284b896c
Reviewed-on: http://git.am.freescale.net:8181/33049
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Tested-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/Kconfig      |   7 +-
 drivers/staging/fsl-mc/bus/Makefile     |   3 +
 drivers/staging/fsl-mc/bus/mc-ioctl.h   |  25 ++++
 drivers/staging/fsl-mc/bus/mc-restool.c | 210 ++++++++++++++++++++++++++++++++
 4 files changed, 244 insertions(+), 1 deletion(-)
 create mode 100644 drivers/staging/fsl-mc/bus/mc-ioctl.h
 create mode 100644 drivers/staging/fsl-mc/bus/mc-restool.c

diff --git a/drivers/staging/fsl-mc/bus/Kconfig b/drivers/staging/fsl-mc/bus/Kconfig
index 0d779d9..39c6ef9 100644
--- a/drivers/staging/fsl-mc/bus/Kconfig
+++ b/drivers/staging/fsl-mc/bus/Kconfig
@@ -21,4 +21,9 @@ config FSL_MC_BUS
 	  Only enable this option when building the kernel for
 	  Freescale QorQIQ LS2xxxx SoCs.
 
-
+config FSL_MC_RESTOOL
+        tristate "Freescale Management Complex (MC) restool driver"
+        depends on FSL_MC_BUS
+        help
+          Driver that provides kernel support for the Freescale Management
+	  Complex resource manager user-space tool.
diff --git a/drivers/staging/fsl-mc/bus/Makefile b/drivers/staging/fsl-mc/bus/Makefile
index 25433a9..28b5fc0 100644
--- a/drivers/staging/fsl-mc/bus/Makefile
+++ b/drivers/staging/fsl-mc/bus/Makefile
@@ -15,3 +15,6 @@ mc-bus-driver-objs := mc-bus.o \
 		      mc-allocator.o \
 		      dpmcp.o \
 		      dpbp.o
+
+# MC restool kernel support
+obj-$(CONFIG_FSL_MC_RESTOOL) += mc-restool.o
diff --git a/drivers/staging/fsl-mc/bus/mc-ioctl.h b/drivers/staging/fsl-mc/bus/mc-ioctl.h
new file mode 100644
index 0000000..d5c1bc3
--- /dev/null
+++ b/drivers/staging/fsl-mc/bus/mc-ioctl.h
@@ -0,0 +1,25 @@
+/*
+ * Freescale Management Complex (MC) ioclt interface
+ *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Author: German Rivera <German.Rivera@freescale.com>
+ *	   Lijun Pan <Lijun.Pan@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef _FSL_MC_IOCTL_H_
+#define _FSL_MC_IOCTL_H_
+
+#include <linux/ioctl.h>
+
+#define RESTOOL_IOCTL_TYPE   'R'
+
+#define RESTOOL_GET_ROOT_DPRC_INFO \
+	_IOR(RESTOOL_IOCTL_TYPE, 0x1, uint32_t)
+
+#define RESTOOL_SEND_MC_COMMAND \
+	_IOWR(RESTOOL_IOCTL_TYPE, 0x4, struct mc_command)
+
+#endif /* _FSL_MC_IOCTL_H_ */
diff --git a/drivers/staging/fsl-mc/bus/mc-restool.c b/drivers/staging/fsl-mc/bus/mc-restool.c
new file mode 100644
index 0000000..a2715eb
--- /dev/null
+++ b/drivers/staging/fsl-mc/bus/mc-restool.c
@@ -0,0 +1,210 @@
+/*
+ * Freescale Management Complex (MC) restool driver
+ *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Author: German Rivera <German.Rivera@freescale.com>
+ *	   Lijun Pan <Lijun.Pan@freescale.com>
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include "../include/mc-private.h"
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include "mc-ioctl.h"
+#include "../include/mc-sys.h"
+#include "../include/mc-cmd.h"
+#include "../include/dpmng.h"
+
+/**
+ * Maximum number of DPRCs that can be opened at the same time
+ */
+#define MAX_DPRC_HANDLES	    64
+
+/**
+ * struct fsl_mc_restool - Management Complex (MC) resource manager object
+ * @tool_mc_io: pointer to the MC I/O object used by the restool
+ */
+struct fsl_mc_restool {
+	struct fsl_mc_io *tool_mc_io;
+};
+
+static int fsl_mc_restool_dev_open(struct inode *inode, struct file *filep)
+{
+	struct fsl_mc_device *root_mc_dev;
+	int error = -EINVAL;
+	struct fsl_mc_restool *fsl_mc_restool;
+
+	fsl_mc_restool = kmalloc(sizeof(struct fsl_mc_restool), GFP_KERNEL);
+	if (fsl_mc_restool == NULL)
+		goto error;
+
+	if (WARN_ON(fsl_mc_bus_type.dev_root == NULL))
+		goto error;
+
+	root_mc_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
+	error = fsl_mc_portal_allocate(root_mc_dev, 0,
+				       &fsl_mc_restool->tool_mc_io);
+	if (error < 0) {
+		pr_err("Not able to allocate MC portal\n");
+		goto error;
+	}
+
+	filep->private_data = fsl_mc_restool;
+	return 0;
+error:
+	if (fsl_mc_restool->tool_mc_io != NULL) {
+		fsl_mc_portal_free(fsl_mc_restool->tool_mc_io);
+		fsl_mc_restool->tool_mc_io = NULL;
+	}
+	kfree(fsl_mc_restool);
+	return error;
+}
+
+static int fsl_mc_restool_dev_release(struct inode *inode, struct file *filep)
+{
+	struct fsl_mc_restool *fsl_mc_restool = filep->private_data;
+
+	if (WARN_ON(filep->private_data == NULL))
+		return -EINVAL;
+
+	/* Globally clean up opened/untracked handles */
+	fsl_mc_portal_reset(fsl_mc_restool->tool_mc_io);
+
+	fsl_mc_portal_free(fsl_mc_restool->tool_mc_io);
+	kfree(filep->private_data);
+	filep->private_data = NULL;
+	return 0;
+}
+
+static int restool_get_root_dprc_info(unsigned long arg)
+{
+	int error = -EINVAL;
+	uint32_t root_dprc_id;
+	struct fsl_mc_device *root_mc_dev;
+
+	root_mc_dev = to_fsl_mc_device(fsl_mc_bus_type.dev_root);
+	root_dprc_id = root_mc_dev->obj_desc.id;
+	error = copy_to_user((void __user *)arg, &root_dprc_id,
+			     sizeof(root_dprc_id));
+	if (error < 0) {
+		pr_err("copy_to_user() failed with error %d\n", error);
+		goto error;
+	}
+
+	return 0;
+error:
+	return error;
+}
+
+static int restool_send_mc_command(unsigned long arg,
+				struct fsl_mc_restool *fsl_mc_restool)
+{
+	int error = -EINVAL;
+	struct mc_command mc_cmd;
+
+	error = copy_from_user(&mc_cmd, (void __user *)arg, sizeof(mc_cmd));
+	if (error < 0) {
+		pr_err("copy_to_user() failed with error %d\n", error);
+		goto error;
+	}
+
+	/*
+	 * Send MC command to the MC:
+	 */
+	error = mc_send_command(fsl_mc_restool->tool_mc_io, &mc_cmd);
+	if (error < 0)
+		goto error;
+
+	error = copy_to_user((void __user *)arg, &mc_cmd, sizeof(mc_cmd));
+	if (error < 0) {
+		pr_err("copy_to_user() failed with error %d\n", error);
+		goto error;
+	}
+
+	return 0;
+error:
+	return error;
+}
+
+static long
+fsl_mc_restool_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int error = -EINVAL;
+
+	if (WARN_ON(fsl_mc_bus_type.dev_root == NULL))
+		goto out;
+
+	switch (cmd) {
+	case RESTOOL_GET_ROOT_DPRC_INFO:
+		error = restool_get_root_dprc_info(arg);
+		break;
+
+	case RESTOOL_SEND_MC_COMMAND:
+		error = restool_send_mc_command(arg, file->private_data);
+		break;
+	default:
+		error = -EINVAL;
+	}
+out:
+	return error;
+}
+
+static const struct file_operations fsl_mc_restool_dev_fops = {
+	.owner = THIS_MODULE,
+	.open = fsl_mc_restool_dev_open,
+	.release = fsl_mc_restool_dev_release,
+	.unlocked_ioctl = fsl_mc_restool_dev_ioctl,
+};
+
+static struct miscdevice fsl_mc_restool_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mc_restool",
+	.fops = &fsl_mc_restool_dev_fops
+};
+
+static int __init fsl_mc_restool_driver_init(void)
+{
+	int error = -EINVAL;
+	bool restool_dev_registered = false;
+
+	if (fsl_mc_bus_type.dev_root == NULL) {
+		pr_err("fsl-mc bus not found, restool driver registration failed\n");
+		goto error;
+	}
+
+	error = misc_register(&fsl_mc_restool_dev);
+	if (error < 0) {
+		pr_err("misc_register() failed: %d\n", error);
+		goto error;
+	}
+
+	restool_dev_registered = true;
+	pr_info("%s driver registered\n", fsl_mc_restool_dev.name);
+	return 0;
+error:
+	if (restool_dev_registered)
+		misc_deregister(&fsl_mc_restool_dev);
+
+	return error;
+}
+
+module_init(fsl_mc_restool_driver_init);
+
+static void __exit fsl_mc_restool_driver_exit(void)
+{
+	misc_deregister(&fsl_mc_restool_dev);
+	pr_info("%s driver unregistered\n", fsl_mc_restool_dev.name);
+}
+
+module_exit(fsl_mc_restool_driver_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor Inc.");
+MODULE_DESCRIPTION("Freescale's MC restool driver");
+MODULE_LICENSE("GPL");
+
-- 
1.9.1

