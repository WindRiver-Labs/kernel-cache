From 8d342b7869ede60f9724430e4533e465a705985f Mon Sep 17 00:00:00 2001
From: Minghuan Lian <Minghuan.Lian@freescale.com>
Date: Mon, 16 Feb 2015 13:28:57 +0800
Subject: [PATCH 236/237] temp: pci/designware: comment out MSI related code

Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Change-Id: I09940c54094bcda0f5ebb61508f1dbde4c751e6c
Reviewed-on: http://git.am.freescale.net:8181/31065
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0. SDK patch uses
 "if 0" to comment out the code, I use "ifndef ARCH_FSL_LS2085A"]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/pci/host/pcie-designware.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c
index e4c0442..d84da5d 100644
--- a/drivers/pci/host/pcie-designware.c
+++ b/drivers/pci/host/pcie-designware.c
@@ -152,6 +152,7 @@ static int dw_pcie_wr_own_conf(struct pcie_port *pp, int where, int size,
 	return ret;
 }
 
+#ifndef CONFIG_ARCH_FSL_LS2085A
 static struct irq_chip dw_msi_irq_chip = {
 	.name = "PCI-MSI",
 	.irq_enable = unmask_msi_irq,
@@ -321,6 +322,7 @@ static struct msi_chip dw_pcie_msi_chip = {
 	.setup_irq = dw_msi_setup_irq,
 	.teardown_irq = dw_msi_teardown_irq,
 };
+#endif
 
 int dw_pcie_link_up(struct pcie_port *pp)
 {
@@ -330,6 +332,7 @@ int dw_pcie_link_up(struct pcie_port *pp)
 		return 0;
 }
 
+#ifndef CONFIG_ARCH_FSL_LS2085A
 static int dw_pcie_msi_map(struct irq_domain *domain, unsigned int irq,
 			irq_hw_number_t hwirq)
 {
@@ -343,6 +346,7 @@ static int dw_pcie_msi_map(struct irq_domain *domain, unsigned int irq,
 static const struct irq_domain_ops msi_domain_ops = {
 	.map = dw_pcie_msi_map,
 };
+#endif
 
 int __init dw_pcie_host_init(struct pcie_port *pp)
 {
@@ -472,7 +476,7 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 		dev_err(pp->dev, "Failed to parse the number of lanes\n");
 		return -EINVAL;
 	}
-
+#ifndef CONFIG_ARCH_FSL_LS2085A
 	if (IS_ENABLED(CONFIG_PCI_MSI)) {
 		if (!pp->ops->msi_host_init) {
 			pp->irq_domain = irq_domain_add_linear(pp->dev->of_node,
@@ -491,7 +495,7 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 				return ret;
 		}
 	}
-
+#endif
 	of_property_read_u32(np, "num-atus", &num_atus);
 	if (num_atus >= 4) {
 		pp->atu_idx[ATU_TYPE_CFG0] = PCIE_ATU_REGION_INDEX0;
@@ -518,9 +522,11 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 	dw_pcie_wr_own_conf(pp, PCIE_LINK_WIDTH_SPEED_CONTROL, 4, val);
 
 #ifdef CONFIG_PCI_MSI
+#ifndef CONFIG_ARCH_FSL_LS2085A
 	dw_pcie_msi_chip.dev = pp->dev;
 	dw_pci.msi_ctrl = &dw_pcie_msi_chip;
 #endif
+#endif
 
 	dw_pci.nr_controllers = 1;
 	dw_pci.private_data = (void **)&pp;
-- 
1.9.1

