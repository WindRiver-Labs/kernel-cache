From 484179742a391c1bd539ddd83354af418f97fdfd Mon Sep 17 00:00:00 2001
From: Alex Marginean <alexandru.marginean@freescale.com>
Date: Thu, 16 Apr 2015 12:59:16 +0300
Subject: [PATCH 231/237] staging: fsl-dpaa2: evb: Added Edge Virtual Bridge
 driver

Signed-off-by: Alex Marginean <alexandru.marginean@freescale.com>
Signed-off-by: Razvan Stefanescu <razvan.stefanescu@freescale.com>

Change-Id: I095ac1066eeaa3c98f592e808330c2bb02e9e182
Reviewed-on: http://git.am.freescale.net:8181/35105
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Razvan Stefanescu <razvan.stefanescu@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 MAINTAINERS                                |   6 +
 drivers/staging/fsl-dpaa2/Kconfig          |   1 +
 drivers/staging/fsl-dpaa2/Makefile         |   1 +
 drivers/staging/fsl-dpaa2/evb/Kconfig      |   6 +
 drivers/staging/fsl-dpaa2/evb/Makefile     |  10 +
 drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h | 268 +++++++++
 drivers/staging/fsl-dpaa2/evb/dpdmux.c     | 560 ++++++++++++++++++
 drivers/staging/fsl-dpaa2/evb/dpdmux.h     | 684 ++++++++++++++++++++++
 drivers/staging/fsl-dpaa2/evb/evb.c        | 883 +++++++++++++++++++++++++++++
 9 files changed, 2419 insertions(+)
 create mode 100644 drivers/staging/fsl-dpaa2/evb/Kconfig
 create mode 100644 drivers/staging/fsl-dpaa2/evb/Makefile
 create mode 100644 drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
 create mode 100644 drivers/staging/fsl-dpaa2/evb/dpdmux.c
 create mode 100644 drivers/staging/fsl-dpaa2/evb/dpdmux.h
 create mode 100644 drivers/staging/fsl-dpaa2/evb/evb.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 8ed44ad..2435c0e 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -3678,6 +3678,12 @@ L:	linux-kernel@vger.kernel.org
 S:	Maintained
 F:	drivers/staging/fsl-dpaa2/mac/
 
++FREESCALE DPAA2 EDGE VIRTUAL BRIDGE DRIVER
+M:	Alex Marginean <Alexandru.Marginean@freescale.com>
+L:	linux-kernel@vger.kernel.org
+S:	Maintained
+F:	drivers/staging/fsl-dpaa2/evb/
+
 FREEVXFS FILESYSTEM
 M:	Christoph Hellwig <hch@infradead.org>
 W:	ftp://ftp.openlinux.org/pub/people/hch/vxfs
diff --git a/drivers/staging/fsl-dpaa2/Kconfig b/drivers/staging/fsl-dpaa2/Kconfig
index 3fe47bc..79295233 100644
--- a/drivers/staging/fsl-dpaa2/Kconfig
+++ b/drivers/staging/fsl-dpaa2/Kconfig
@@ -10,3 +10,4 @@ config FSL_DPAA2
 # TODO move DPIO driver in-here?
 source "drivers/staging/fsl-dpaa2/ethernet/Kconfig"
 source "drivers/staging/fsl-dpaa2/mac/Kconfig"
+source "drivers/staging/fsl-dpaa2/evb/Kconfig"
diff --git a/drivers/staging/fsl-dpaa2/Makefile b/drivers/staging/fsl-dpaa2/Makefile
index bc687a1..67d9d0b 100644
--- a/drivers/staging/fsl-dpaa2/Makefile
+++ b/drivers/staging/fsl-dpaa2/Makefile
@@ -4,3 +4,4 @@
 
 obj-$(CONFIG_FSL_DPAA2_ETH)	+= ethernet/
 obj-$(CONFIG_FSL_DPAA2_MAC)	+= mac/
+obj-$(CONFIG_FSL_DPAA2_EVB)	+= evb/
diff --git a/drivers/staging/fsl-dpaa2/evb/Kconfig b/drivers/staging/fsl-dpaa2/evb/Kconfig
new file mode 100644
index 0000000..ee2c1de
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/Kconfig
@@ -0,0 +1,6 @@
+config FSL_DPAA2_EVB
+	tristate "DPAA2 Edge Virtual Bridge"
+	depends on FSL_MC_BUS && FSL_DPAA2 && FSL_DPAA2_ETH
+	select FSL_DPAA2_MAC
+	---help---
+	Prototype driver for DPAA2 Edge Virtual Bridge.
diff --git a/drivers/staging/fsl-dpaa2/evb/Makefile b/drivers/staging/fsl-dpaa2/evb/Makefile
new file mode 100644
index 0000000..ecc529d
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/Makefile
@@ -0,0 +1,10 @@
+
+obj-$(CONFIG_FSL_DPAA2_EVB) += dpaa2-evb.o
+
+dpaa2-evb-objs := evb.o dpdmux.o
+
+all:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+
+clean:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h b/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
new file mode 100644
index 0000000..e7b8dbc
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux-cmd.h
@@ -0,0 +1,268 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _FSL_DPDMUX_CMD_H
+#define _FSL_DPDMUX_CMD_H
+
+/* DPDMUX Version */
+#define DPDMUX_VER_MAJOR				4
+#define DPDMUX_VER_MINOR				0
+
+/* Command IDs */
+#define DPDMUX_CMDID_CLOSE				0x800
+#define DPDMUX_CMDID_OPEN				0x806
+#define DPDMUX_CMDID_CREATE				0x906
+#define DPDMUX_CMDID_DESTROY				0x900
+
+#define DPDMUX_CMDID_ENABLE				0x002
+#define DPDMUX_CMDID_DISABLE				0x003
+#define DPDMUX_CMDID_GET_ATTR				0x004
+#define DPDMUX_CMDID_RESET				0x005
+#define DPDMUX_CMDID_IS_ENABLED				0x006
+
+#define DPDMUX_CMDID_SET_IRQ				0x010
+#define DPDMUX_CMDID_GET_IRQ				0x011
+#define DPDMUX_CMDID_SET_IRQ_ENABLE			0x012
+#define DPDMUX_CMDID_GET_IRQ_ENABLE			0x013
+#define DPDMUX_CMDID_SET_IRQ_MASK			0x014
+#define DPDMUX_CMDID_GET_IRQ_MASK			0x015
+#define DPDMUX_CMDID_GET_IRQ_STATUS			0x016
+#define DPDMUX_CMDID_CLEAR_IRQ_STATUS			0x017
+
+#define DPDMUX_CMDID_UL_SET_MAX_FRAME_LENGTH		0x0a1
+#define DPDMUX_CMDID_SET_DEFAULT_IF			0x0a2
+#define DPDMUX_CMDID_UL_RESET_COUNTERS			0x0a3
+
+#define DPDMUX_CMDID_IF_SET_ACCEPTED_FRAMES		0x0a7
+#define DPDMUX_CMDID_IF_GET_ATTR			0x0a8
+#define DPDMUX_CMDID_GET_DEFAULT_IF			0x0a9
+
+#define DPDMUX_CMDID_IF_ADD_L2_RULE			0x0b0
+#define DPDMUX_CMDID_IF_REMOVE_L2_RULE			0x0b1
+#define DPDMUX_CMDID_IF_GET_COUNTER			0x0b2
+#define DPDMUX_CMDID_IF_SET_LINK_CFG		0x0b3
+#define DPDMUX_CMDID_IF_GET_LINK_STATE		0x0b4
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_OPEN(cmd, dpdmux_id) \
+	MC_CMD_OP(cmd, 0, 0,  32,  int,	dpdmux_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_CREATE(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  enum dpdmux_method, cfg->method);\
+	MC_CMD_OP(cmd, 0, 8,  8,  enum dpdmux_manip, cfg->manip);\
+	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, cfg->num_ifs);\
+	MC_CMD_OP(cmd, 0, 32, 32, int,	    cfg->control_if);\
+	MC_CMD_OP(cmd, 1, 0,  16, uint16_t, cfg->adv.max_dmat_entries);\
+	MC_CMD_OP(cmd, 1, 16, 16, uint16_t, cfg->adv.max_mc_groups);\
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, cfg->adv.max_vlan_ids);\
+	MC_CMD_OP(cmd, 2, 0,  64, uint64_t, cfg->adv.options);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_IS_ENABLED(cmd, en) \
+	MC_RSP_OP(cmd, 0, 0,  1,  int,	    en)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
+	MC_CMD_OP(cmd, 0, 0,  64, uint64_t, irq_addr);\
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_GET_IRQ(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_SET_IRQ_ENABLE(cmd, irq_index, en) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  en);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_GET_IRQ_ENABLE(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_GET_IRQ_ENABLE(cmd, en) \
+	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,  en)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_SET_IRQ_MASK(cmd, irq_index, mask) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, mask); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_GET_IRQ_MASK(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_GET_IRQ_MASK(cmd, mask) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, mask)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_GET_IRQ_STATUS(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_GET_IRQ_STATUS(cmd, status) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, status) \
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, status); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index); \
+} while (0)
+
+#define DPDMUX_RSP_GET_ATTR(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  8,  enum dpdmux_method, attr->method);\
+	MC_RSP_OP(cmd, 0, 8,  8,  enum dpdmux_manip, attr->manip);\
+	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, attr->num_ifs);\
+	MC_RSP_OP(cmd, 0, 32, 16, uint16_t, attr->mem_size);\
+	MC_RSP_OP(cmd, 1, 0,  32, int,	    attr->control_if);\
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    attr->id);\
+	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, attr->options);\
+	MC_RSP_OP(cmd, 4, 0,  16, uint16_t, attr->version.major);\
+	MC_RSP_OP(cmd, 4, 16, 16, uint16_t, attr->version.minor);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_UL_SET_MAX_FRAME_LENGTH(cmd, max_frame_length) \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, max_frame_length)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_SET_DEFAULT_IF(cmd, if_id, no_default_if) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 0, 16, 1,  int,	    no_default_if);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_GET_DEFAULT_IF(cmd, if_id) \
+	MC_RSP_OP(cmd, 0, 0,  16, uint16_t, if_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_IF_SET_ACCEPTED_FRAMES(cmd, if_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 0, 16, 4,  enum dpdmux_accepted_frames_type, cfg->type);\
+	MC_CMD_OP(cmd, 0, 20, 4,  enum dpdmux_unaccepted_frames_action, \
+					    cfg->unaccept_act);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_IF_GET_ATTR(cmd, if_id) \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_IF_GET_ATTR(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 56, 4,  enum dpdmux_accepted_frames_type, \
+					    attr->accept_frame_type);\
+	MC_RSP_OP(cmd, 0, 24,  1, int,	    attr->enabled);\
+	MC_RSP_OP(cmd, 0, 25,  1, int,	    attr->is_default);\
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, attr->rate);\
+} while (0)
+
+#define DPDMUX_CMD_IF_REMOVE_L2_RULE(cmd, if_id, l2_rule) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  l2_rule->mac_addr[5]);\
+	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  l2_rule->mac_addr[4]);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  l2_rule->mac_addr[3]);\
+	MC_CMD_OP(cmd, 0, 40, 8,  uint8_t,  l2_rule->mac_addr[2]);\
+	MC_CMD_OP(cmd, 0, 48, 8,  uint8_t,  l2_rule->mac_addr[1]);\
+	MC_CMD_OP(cmd, 0, 56, 8,  uint8_t,  l2_rule->mac_addr[0]);\
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, l2_rule->vlan_id);\
+} while (0)
+
+#define DPDMUX_CMD_IF_ADD_L2_RULE(cmd, if_id, l2_rule) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  l2_rule->mac_addr[5]);\
+	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  l2_rule->mac_addr[4]);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  l2_rule->mac_addr[3]);\
+	MC_CMD_OP(cmd, 0, 40, 8,  uint8_t,  l2_rule->mac_addr[2]);\
+	MC_CMD_OP(cmd, 0, 48, 8,  uint8_t,  l2_rule->mac_addr[1]);\
+	MC_CMD_OP(cmd, 0, 56, 8,  uint8_t,  l2_rule->mac_addr[0]);\
+	MC_CMD_OP(cmd, 1, 32, 16, uint16_t, l2_rule->vlan_id);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_IF_GET_COUNTER(cmd, if_id, counter_type) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 0, 16, 8,  enum dpdmux_counter_type, counter_type);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_IF_GET_COUNTER(cmd, counter) \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, counter)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_IF_SET_LINK_CFG(cmd, if_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id);\
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->rate);\
+	MC_CMD_OP(cmd, 2, 0,  64, uint64_t, cfg->options);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_CMD_IF_GET_LINK_STATE(cmd, if_id) \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, if_id) \
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPDMUX_RSP_IF_GET_LINK_STATE(cmd, state) \
+do { \
+	MC_RSP_OP(cmd, 0, 32, 1,  int,      state->up);\
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, state->rate);\
+	MC_RSP_OP(cmd, 2, 0,  64, uint64_t, state->options);\
+} while (0)
+
+#endif /* _FSL_DPDMUX_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux.c b/drivers/staging/fsl-dpaa2/evb/dpdmux.c
new file mode 100644
index 0000000..1e924de
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux.c
@@ -0,0 +1,560 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "../../fsl-mc/include/mc-sys.h"
+#include "../../fsl-mc/include/mc-cmd.h"
+#include "dpdmux.h"
+#include "dpdmux-cmd.h"
+
+int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_OPEN,
+					  MC_CMD_PRI_LOW, 0);
+	DPDMUX_CMD_OPEN(cmd, dpdmux_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+
+	return 0;
+}
+
+int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CLOSE,
+					  MC_CMD_PRI_HIGH,
+					  token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_create(struct fsl_mc_io *mc_io,
+		  const struct dpdmux_cfg *cfg,
+		  uint16_t *token)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CREATE,
+					  MC_CMD_PRI_LOW, 0);
+	DPDMUX_CMD_CREATE(cmd, cfg);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+
+	return 0;
+}
+
+int dpdmux_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_DESTROY,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_enable(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_ENABLE,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_disable(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_DISABLE,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IS_ENABLED,
+					  MC_CMD_PRI_LOW,
+					  token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_IS_ENABLED(cmd, *en);
+
+	return 0;
+}
+
+int dpdmux_reset(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_RESET,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_set_irq(struct fsl_mc_io *mc_io,
+		   uint16_t token,
+		   uint8_t irq_index,
+		   uint64_t irq_addr,
+		   uint32_t irq_val,
+		   int user_irq_id)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_get_irq(struct fsl_mc_io *mc_io,
+		   uint16_t token,
+		   uint8_t irq_index,
+		   int *type,
+		   uint64_t *irq_addr,
+		   uint32_t *irq_val,
+		   int *user_irq_id)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_GET_IRQ(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+
+	return 0;
+}
+
+int dpdmux_set_irq_enable(struct fsl_mc_io *mc_io,
+			  uint16_t token,
+			  uint8_t irq_index,
+			  uint8_t en)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ_ENABLE,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_get_irq_enable(struct fsl_mc_io *mc_io,
+			  uint16_t token,
+			  uint8_t irq_index,
+			  uint8_t *en)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_ENABLE,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_GET_IRQ_ENABLE(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_IRQ_ENABLE(cmd, *en);
+
+	return 0;
+}
+
+int dpdmux_set_irq_mask(struct fsl_mc_io *mc_io,
+			uint16_t token,
+			uint8_t irq_index,
+			uint32_t mask)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_IRQ_MASK,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_get_irq_mask(struct fsl_mc_io *mc_io,
+			uint16_t token,
+			uint8_t irq_index,
+			uint32_t *mask)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_MASK,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_GET_IRQ_MASK(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_IRQ_MASK(cmd, *mask);
+
+	return 0;
+}
+
+int dpdmux_get_irq_status(struct fsl_mc_io *mc_io,
+			  uint16_t token,
+			  uint8_t irq_index,
+			  uint32_t *status)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_IRQ_STATUS,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_GET_IRQ_STATUS(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_IRQ_STATUS(cmd, *status);
+
+	return 0;
+}
+
+int dpdmux_clear_irq_status(struct fsl_mc_io *mc_io,
+			    uint16_t token,
+			    uint8_t irq_index,
+			    uint32_t status)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_CLEAR_IRQ_STATUS,
+					  MC_CMD_PRI_LOW, token);
+	DPDMUX_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_get_attributes(struct fsl_mc_io *mc_io,
+			  uint16_t token,
+			  struct dpdmux_attr *attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_ATTR,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_ATTR(cmd, attr);
+
+	return 0;
+}
+
+int dpdmux_ul_set_max_frame_length(struct fsl_mc_io *mc_io,
+				   uint16_t token,
+				uint16_t max_frame_length)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_UL_SET_MAX_FRAME_LENGTH,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_UL_SET_MAX_FRAME_LENGTH(cmd, max_frame_length);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_set_default_if(struct fsl_mc_io *mc_io,
+			  uint16_t token,
+			  uint16_t if_id,
+			  int no_default_if)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_SET_DEFAULT_IF,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_SET_DEFAULT_IF(cmd, if_id, no_default_if);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_get_default_if(struct fsl_mc_io *mc_io, uint16_t token,
+			  uint16_t *if_id)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_GET_DEFAULT_IF,
+						  MC_CMD_PRI_LOW,
+						  token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_GET_DEFAULT_IF(cmd, *if_id);
+
+	return 0;
+}
+
+int dpdmux_ul_reset_counters(struct fsl_mc_io *mc_io,
+			     uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_UL_RESET_COUNTERS,
+					  MC_CMD_PRI_LOW,
+					  token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_if_set_accepted_frames(struct fsl_mc_io *mc_io,
+				  uint16_t token,
+				  uint16_t if_id,
+				  const struct dpdmux_accepted_frames *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_SET_ACCEPTED_FRAMES,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_SET_ACCEPTED_FRAMES(cmd, if_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_if_get_attributes(struct fsl_mc_io *mc_io,
+			     uint16_t token,
+			     uint16_t if_id,
+			     struct dpdmux_if_attr *attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_ATTR,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_GET_ATTR(cmd, if_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_IF_GET_ATTR(cmd, attr);
+
+	return 0;
+}
+
+int dpdmux_if_remove_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
+			     uint16_t if_id,
+			     const struct dpdmux_l2_rule *rule)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_REMOVE_L2_RULE,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_REMOVE_L2_RULE(cmd, if_id, rule);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_if_add_l2_rule(struct fsl_mc_io *mc_io, uint16_t token,
+			  uint16_t if_id,
+			  const struct dpdmux_l2_rule *rule)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_ADD_L2_RULE,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_ADD_L2_RULE(cmd, if_id, rule);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
+			  uint16_t			token,
+			  uint16_t			if_id,
+			  enum dpdmux_counter_type	counter_type,
+			  uint64_t			*counter)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_COUNTER,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_GET_COUNTER(cmd, if_id, counter_type);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_IF_GET_COUNTER(cmd, *counter);
+
+	return 0;
+}
+
+int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
+			   uint16_t token,
+			   uint16_t if_id,
+			   struct dpdmux_link_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_SET_LINK_CFG,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_SET_LINK_CFG(cmd, if_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpdmux_if_get_link_state(struct fsl_mc_io *mc_io,
+			     uint16_t token,
+			     uint16_t if_id,
+			     struct dpdmux_link_state *state)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPDMUX_CMDID_IF_GET_LINK_STATE,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPDMUX_CMD_IF_GET_LINK_STATE(cmd, if_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPDMUX_RSP_IF_GET_LINK_STATE(cmd, state);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-dpaa2/evb/dpdmux.h b/drivers/staging/fsl-dpaa2/evb/dpdmux.h
new file mode 100644
index 0000000..0035653
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/dpdmux.h
@@ -0,0 +1,684 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FSL_DPDMUX_H
+#define __FSL_DPDMUX_H
+
+#include "../../fsl-mc/include/net.h"
+
+struct fsl_mc_io;
+
+/* Data Path Demux API
+ * Contains API for handling DPDMUX topology and functionality
+ */
+
+/**
+ * dpdmux_open() - Open a control session for the specified object
+ * @mc_io:		Pointer to MC portal's I/O object
+ * @dpdmux_id:		DPDMUX unique ID
+ * @token:		Returned token; use in subsequent API calls
+ *
+ * This function can be used to open a control session for an
+ * already created object; an object may have been declared in
+ * the DPL or by calling the dpdmux_create() function.
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent commands for
+ * this specific object.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_open(struct fsl_mc_io *mc_io, int dpdmux_id, uint16_t *token);
+
+/**
+ * dpdmux_close() - Close the control session of the object
+ * @mc_io:		Pointer to MC portal's I/O object
+ * @token:		Token of DPDMUX object
+ *
+ * After this function is called, no further operations are
+ * allowed on the object without opening a new control session.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_close(struct fsl_mc_io *mc_io, uint16_t token);
+
+/*!
+ * @name DPDMUX general options
+ */
+#define DPDMUX_OPT_BRIDGE_EN		0x0000000000000002ULL
+/*!< Enable bridging between internal interfaces */
+/* @} */
+
+/**
+ * enum dpdmux_manip - DPDMUX manipulation operations
+ * @DPDMUX_MANIP_NONE:	No manipulation on frames
+ * @DPDMUX_MANIP_ADD_REMOVE_S_VLAN: Add S-VLAN on egress, remove it on ingress
+ */
+enum dpdmux_manip {
+	DPDMUX_MANIP_NONE = 0x0,
+	DPDMUX_MANIP_ADD_REMOVE_S_VLAN = 0x1
+};
+
+/**
+ * enum dpdmux_method - DPDMUX method options
+ * @DPDMUX_METHOD_NONE: no DPDMUX method
+ * @DPDMUX_METHOD_C_VLAN_MAC: DPDMUX based on C-VLAN and MAC address
+ * @DPDMUX_METHOD_MAC: DPDMUX based on MAC address
+ * @DPDMUX_METHOD_C_VLAN: DPDMUX based on C-VLAN
+ * @DPDMUX_METHOD_S_VLAN: DPDMUX based on S-VLAN
+ */
+enum dpdmux_method {
+	DPDMUX_METHOD_NONE = 0x0,
+	DPDMUX_METHOD_C_VLAN_MAC = 0x1,
+	DPDMUX_METHOD_MAC = 0x2,
+	DPDMUX_METHOD_C_VLAN = 0x3,
+	DPDMUX_METHOD_S_VLAN = 0x4
+};
+
+/**
+ * struct dpdmux_cfg - DPDMUX configuration parameters
+ * @method: Defines the operation method for the DPDMUX address table
+ * @manip: Required manipulation operation
+ * @control_if: The initial control interface
+ * @num_ifs: Number of interfaces (excluding the uplink interface)
+ * @adv: Advanced parameters; default is all zeros;
+ *	 use this structure to change default settings
+ */
+struct dpdmux_cfg {
+	enum dpdmux_method method;
+	enum dpdmux_manip manip;
+	int control_if;
+	uint16_t num_ifs;
+	/**
+	 * struct adv - Advanced parameters
+	 * @options: DPDMUX options - combination of 'DPDMUX_OPT_<X>' flags
+	 * @max_dmat_entries: Maximum entries in DPDMUX address table
+	 *		0 - indicates default: 64 entries per interface.
+	 * @max_mc_groups: Number of multicast groups in DPDMUX table
+	 *		0 - indicates default: 32 multicast groups
+	 * @max_vlan_ids: max vlan ids allowed in the system -
+	 *		relevant only case of working in mac+vlan method.
+	 *		0 - indicates default 16 vlan ids.
+	 */
+	struct {
+		uint64_t options;
+		uint16_t max_dmat_entries;
+		uint16_t max_mc_groups;
+		uint16_t max_vlan_ids;
+	} adv;
+};
+
+/**
+ * dpdmux_create() - Create the DPDMUX object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cfg:	Configuration structure
+ * @token:	Returned token; use in subsequent API calls
+ *
+ * Create the DPDMUX object, allocate required resources and
+ * perform required initialization.
+ *
+ * The object can be created either by declaring it in the
+ * DPL file, or by calling this function.
+ *
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent calls to
+ * this specific object. For objects that are created using the
+ * DPL file, call dpdmux_open() function to get an authentication
+ * token first.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_create(struct fsl_mc_io *mc_io, const struct dpdmux_cfg *cfg,
+		  uint16_t *token);
+
+/**
+ * dpdmux_destroy() - Destroy the DPDMUX object and release all its resources.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpdmux_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+
+/**
+ * dpdmux_enable() - Enable DPDMUX functionality
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_enable(struct fsl_mc_io *mc_io, uint16_t token);
+
+/**
+ * dpdmux_disable() - Disable DPDMUX functionality
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_disable(struct fsl_mc_io *mc_io, uint16_t token);
+
+/**
+ * dpdmux_is_enabled() - Check if the DPDMUX is enabled.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @en:		Returns '1' if object is enabled; '0' otherwise
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_is_enabled(struct fsl_mc_io *mc_io, uint16_t token, int *en);
+
+/**
+ * dpdmux_reset() - Reset the DPDMUX, returns the object to initial state.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_reset(struct fsl_mc_io *mc_io, uint16_t token);
+
+
+/**
+ * dpdmux_set_irq() - Set IRQ information for the DPDMUX to trigger an interrupt.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	Identifies the interrupt index to configure
+ * @irq_addr:	Address that must be written to
+ *		signal a message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_set_irq(struct fsl_mc_io	*mc_io,
+		   uint16_t		token,
+		   uint8_t		irq_index,
+		   uint64_t		irq_addr,
+		   uint32_t		irq_val,
+		   int			user_irq_id);
+
+/**
+ * dpdmux_get_irq() - Get IRQ information from the DPDMUX.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @type:	Returned interrupt type: 0 represents message interrupt
+ *		type (both irq_addr and irq_val are valid)
+ * @irq_addr:	Returned address that must be written to
+ *		signal the message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_irq(struct fsl_mc_io	*mc_io,
+		   uint16_t		token,
+		   uint8_t		irq_index,
+		   int			*type,
+		   uint64_t		*irq_addr,
+		   uint32_t		*irq_val,
+		   int			*user_irq_id);
+
+/**
+ * dpdmux_set_irq_enable() - Set overall interrupt state.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @en:		Interrupt state - enable = 1, disable = 0
+ *
+ * Allows GPP software to control when interrupts are generated.
+ * Each interrupt can have up to 32 causes.  The enable/disable control's the
+ * overall interrupt state. if the interrupt is disabled no causes will cause
+ * an interrupt.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_set_irq_enable(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  uint8_t		irq_index,
+			  uint8_t		en);
+
+/**
+ * dpdmux_get_irq_enable() - Get overall interrupt state.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @en:		Returned interrupt state - enable = 1, disable = 0
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_irq_enable(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  uint8_t		irq_index,
+			  uint8_t		*en);
+
+/**
+ * dpdmux_set_irq_mask() - Set interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	event mask to trigger interrupt;
+ *		each bit:
+ *			0 = ignore event
+ *			1 = consider event for asserting irq
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_set_irq_mask(struct fsl_mc_io	*mc_io,
+			uint16_t		token,
+			uint8_t			irq_index,
+			uint32_t		mask);
+
+/**
+ * dpdmux_get_irq_mask() - Get interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	Returned event mask to trigger interrupt
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_irq_mask(struct fsl_mc_io	*mc_io,
+			uint16_t		token,
+			uint8_t			irq_index,
+			uint32_t		*mask);
+
+/**
+ * dpdmux_get_irq_status() - Get the current status of any pending interrupts.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @status	Returned interrupts status - one bit per cause:
+ *			0 = no interrupt pending
+ *			1 = interrupt pending
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_irq_status(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  uint8_t		irq_index,
+			  uint32_t		*status);
+
+/**
+ * dpdmux_clear_irq_status() - Clear a pending interrupt's status
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @irq_index:	The interrupt index to configure
+ * @status:	bits to clear (W1C) - one bit per cause:
+ *			0 = don't change
+ *			1 = clear status bit
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_clear_irq_status(struct fsl_mc_io	*mc_io,
+			    uint16_t		token,
+			    uint8_t		irq_index,
+			    uint32_t		status);
+
+/**
+ * struct dpdmux_attr - Structure representing DPDMUX attributes
+ * @id: DPDMUX object ID
+ * @version: DPDMUX version
+ * @options: Configuration options (bitmap)
+ * @method: DPDMUX address table method
+ * @manip: DPDMUX manipulation type
+ * @num_ifs: Number of interfaces (excluding the uplink interface)
+ * @mem_size: DPDMUX frame storage memory size
+ * @control_if: Control interface ID
+ */
+struct dpdmux_attr {
+	int id;
+	/**
+	 * struct version - DPDMUX version
+	 * @major: DPDMUX major version
+	 * @minor: DPDMUX minor version
+	 */
+	struct {
+		uint16_t major;
+		uint16_t minor;
+	} version;
+	uint64_t options;
+	enum dpdmux_method method;
+	enum dpdmux_manip manip;
+	uint16_t num_ifs;
+	uint16_t mem_size;
+	int control_if;
+};
+
+/**
+ * dpdmux_get_attributes() - Retrieve DPDMUX attributes
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @attr:	Returned object's attributes
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_attributes(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  struct dpdmux_attr	*attr);
+
+/**
+ *
+ * dpdmux_ul_set_max_frame_length() - Set the maximum frame length in DPDMUX
+ * @mc_io:		Pointer to MC portal's I/O object
+ * @token:		Token of DPDMUX object
+ * @max_frame_length:	The required maximum frame length
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_ul_set_max_frame_length(struct fsl_mc_io	*mc_io,
+				   uint16_t		token,
+				   uint16_t		max_frame_length);
+
+/**
+ *
+ * dpdmux_set_default_if() - Set the interface to be the default interface
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
+ *		Ignored if 'no_default_if = 1'
+ * @no_default_if: Set to '1' to clear default interface setting -
+ *		   consequently, frames with no match in the
+ *		   Demux address table are dropped;
+ *
+ * Default interface is selected when the frame does not match
+ * any entry in the Demux address table. This function can also
+ * clear the default interface selection by passing 'set = 0'.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_set_default_if(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  uint16_t		if_id,
+			  int			no_default_if);
+
+/**
+ * dpdmux_get_default_if() - Get the default interface
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Returns default interface ID (0 for uplink,
+ *		or 1-num_ifs);
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_get_default_if(struct fsl_mc_io	*mc_io,
+			  uint16_t		token,
+			  uint16_t		*if_id);
+
+/**
+ * enum dpdmux_counter_type - Counter types
+ * @DPDMUX_CNT_ING_FRAME: Counts ingress frames
+ * @DPDMUX_CNT_ING_BYTE: Counts ingress bytes
+ * @DPDMUX_CNT_ING_FLTR_FRAME: Counts filtered ingress frames
+ * @DPDMUX_CNT_ING_FRAME_DISCARD: Counts discarded ingress frames
+ * @DPDMUX_CNT_ING_MCAST_FRAME: Counts ingress multicast frames
+ * @DPDMUX_CNT_ING_MCAST_BYTE: Counts ingress multicast bytes
+ * @DPDMUX_CNT_ING_BCAST_FRAME: Counts ingress broadcast frames
+ * @DPDMUX_CNT_ING_BCAST_BYTES: Counts ingress broadcast bytes
+ * @DPDMUX_CNT_EGR_FRAME: Counts egress frames
+ * @DPDMUX_CNT_EGR_BYTE: Counts egress bytes
+ * @DPDMUX_CNT_EGR_FRAME_DISCARD: Counts discarded egress frames
+ */
+enum dpdmux_counter_type {
+	DPDMUX_CNT_ING_FRAME = 0x0,
+	DPDMUX_CNT_ING_BYTE = 0x1,
+	DPDMUX_CNT_ING_FLTR_FRAME = 0x2,
+	DPDMUX_CNT_ING_FRAME_DISCARD = 0x3,
+	DPDMUX_CNT_ING_MCAST_FRAME = 0x4,
+	DPDMUX_CNT_ING_MCAST_BYTE = 0x5,
+	DPDMUX_CNT_ING_BCAST_FRAME = 0x6,
+	DPDMUX_CNT_ING_BCAST_BYTES = 0x7,
+	DPDMUX_CNT_EGR_FRAME = 0x8,
+	DPDMUX_CNT_EGR_BYTE = 0x9,
+	DPDMUX_CNT_EGR_FRAME_DISCARD = 0xa
+};
+
+/**
+ * enum dpdmux_accepted_frames_type - DPDMUX frame types
+ * @DPDMUX_ADMIT_ALL: The device accepts VLAN tagged, untagged and
+ *			priority-tagged frames
+ * @DPDMUX_ADMIT_ONLY_VLAN_TAGGED: The device discards untagged frames or
+ *				priority-tagged frames that are received on this
+ *				interface
+ * @DPDMUX_ADMIT_ONLY_UNTAGGED: Untagged frames or priority-tagged frames
+ *				received on this interface are accepted
+ */
+enum dpdmux_accepted_frames_type {
+	DPDMUX_ADMIT_ALL = 0,
+	DPDMUX_ADMIT_ONLY_VLAN_TAGGED = 1,
+	DPDMUX_ADMIT_ONLY_UNTAGGED = 2
+};
+
+/**
+ * enum dpdmux_action - DPDMUX action for un-accepted frames
+ * @DPDMUX_ACTION_DROP: Drop un-accepted frames
+ * @DPDMUX_ACTION_REDIRECT_TO_CTRL: Redirect un-accepted frames to the
+ *					control interface
+ */
+enum dpdmux_action {
+	DPDMUX_ACTION_DROP = 0,
+	DPDMUX_ACTION_REDIRECT_TO_CTRL = 1
+};
+
+/**
+ * struct dpdmux_accepted_frames - Frame types configuration
+ * @type: Defines ingress accepted frames
+ * @unaccept_act: Defines action on frames not accepted
+ */
+struct dpdmux_accepted_frames {
+	enum dpdmux_accepted_frames_type type;
+	enum dpdmux_action unaccept_act;
+};
+
+/**
+ * dpdmux_if_set_accepted_frames() - Set the accepted frame types
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
+ * @cfg:	Frame types configuration
+ *
+ * if 'DPDMUX_ADMIT_ONLY_VLAN_TAGGED' is set - untagged frames or
+ * priority-tagged frames are discarded.
+ * if 'DPDMUX_ADMIT_ONLY_UNTAGGED' is set - untagged frames or
+ * priority-tagged frames are accepted.
+ * if 'DPDMUX_ADMIT_ALL' is set (default mode) - all VLAN tagged,
+ * untagged and priority-tagged frame are accepted;
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_set_accepted_frames(struct fsl_mc_io			*mc_io,
+				  uint16_t				token,
+				  uint16_t				if_id,
+				  const struct dpdmux_accepted_frames	*cfg);
+
+/**
+ * struct dpdmux_if_attr - Structure representing frame types configuration
+ * @rate: Configured interface rate (in bits per second)
+ * @enabled: Indicates if interface is enabled
+ * @accept_frame_type: Indicates type of accepted frames for the interface
+ * @is_default: Indicates if configured as default interface
+ */
+struct dpdmux_if_attr {
+	uint32_t rate;
+	int enabled;
+	enum dpdmux_accepted_frames_type accept_frame_type;
+	int is_default;
+};
+
+/**
+ * dpdmux_if_get_attributes() - Obtain DPDMUX interface attributes
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Interface ID (0 for uplink, or 1-num_ifs);
+ * @attr:	Interface attributes
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_get_attributes(struct fsl_mc_io		*mc_io,
+			     uint16_t			token,
+			     uint16_t			if_id,
+			     struct dpdmux_if_attr	*attr);
+
+/**
+ * struct dpdmux_l2_rule - Structure representing L2 rule
+ * @mac_addr: MAC address
+ * @vlan_id: VLAN ID
+ */
+struct dpdmux_l2_rule {
+	uint8_t mac_addr[6];
+	uint16_t vlan_id;
+};
+
+/**
+ * dpdmux_if_remove_l2_rule() - Remove L2 rule from DPDMUX table
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Destination interface ID
+ * @rule:	L2 rule
+ *
+ * Function removes a L2 rule from DPDMUX table
+ * or adds an interface to an existing multicast address
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_remove_l2_rule(struct fsl_mc_io			*mc_io,
+			     uint16_t				token,
+			     uint16_t				if_id,
+			     const struct dpdmux_l2_rule	*rule);
+
+/**
+ * dpdmux_if_add_l2_rule() - Add L2 rule into DPDMUX table
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPDMUX object
+ * @if_id:	Destination interface ID
+ * @rule:	L2 rule
+ *
+ * Function adds a L2 rule into DPDMUX table
+ * or adds an interface to an existing multicast address
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_add_l2_rule(struct fsl_mc_io		*mc_io,
+			  uint16_t			token,
+			  uint16_t			if_id,
+			  const struct dpdmux_l2_rule	*rule);
+
+/**
+* @dpdmux_if_get_counter() - Functions obtains specific counter of an interface
+* @mc_io:	Pointer to MC portal's I/O object
+* @token:	Token of DPDMUX object
+* @if_id:  Interface Id
+* @counter_type: counter type
+* @counter: Returned specific counter information
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpdmux_if_get_counter(struct fsl_mc_io		*mc_io,
+			  uint16_t			token,
+			  uint16_t			if_id,
+			  enum dpdmux_counter_type	counter_type,
+			  uint64_t			*counter);
+
+/**
+* dpdmux_ul_reset_counters() - Function resets the uplink counter
+* @mc_io:	Pointer to MC portal's I/O object
+* @token:	Token of DPDMUX object
+*
+* Return:	'0' on Success; Error code otherwise.
+*/
+int dpdmux_ul_reset_counters(struct fsl_mc_io *mc_io, uint16_t token);
+
+/* Enable auto-negotiation */
+#define DPDMUX_LINK_OPT_AUTONEG		0x0000000000000001ULL
+/* Enable half-duplex mode */
+#define DPDMUX_LINK_OPT_HALF_DUPLEX	0x0000000000000002ULL
+/* Enable pause frames */
+#define DPDMUX_LINK_OPT_PAUSE		0x0000000000000004ULL
+/* Enable a-symmetric pause frames */
+#define DPDMUX_LINK_OPT_ASYM_PAUSE	0x0000000000000008ULL
+
+/**
+ * struct dpdmux_link_cfg - Structure representing DPDMUX link configuration
+ * @rate: Rate
+ * @options: Mask of available options; use 'DPDMUX_LINK_OPT_<X>' values
+ */
+struct dpdmux_link_cfg {
+	uint32_t rate;
+	uint64_t options;
+};
+
+/**
+ * dpdmux_if_set_link_cfg() - set the link configuration.
+ * @mc_io: Pointer to MC portal's I/O object
+ * @token: Token of DPSW object
+ * @if_id: interface id
+ * @cfg: Link configuration
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_set_link_cfg(struct fsl_mc_io *mc_io,
+			   uint16_t token,
+			   uint16_t if_id,
+			   struct dpdmux_link_cfg *cfg);
+/**
+ * struct dpdmux_link_state - Structure representing DPDMUX link state
+ * @rate: Rate
+ * @options: Mask of available options; use 'DPDMUX_LINK_OPT_<X>' values
+ * @up: 0 - down, 1 - up
+ */
+struct dpdmux_link_state {
+	uint32_t rate;
+	uint64_t options;
+	int      up;
+};
+
+/**
+ * dpdmux_if_get_link_state - Return the link state
+ * @mc_io: Pointer to MC portal's I/O object
+ * @token: Token of DPSW object
+ * @if_id: interface id
+ * @state: link state
+ *
+ * @returns	'0' on Success; Error code otherwise.
+ */
+int dpdmux_if_get_link_state(struct fsl_mc_io *mc_io,
+			     uint16_t token,
+			     uint16_t if_id,
+			     struct dpdmux_link_state *state);
+
+#endif /* __FSL_DPDMUX_H */
diff --git a/drivers/staging/fsl-dpaa2/evb/evb.c b/drivers/staging/fsl-dpaa2/evb/evb.c
new file mode 100644
index 0000000..2f3e885
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/evb/evb.c
@@ -0,0 +1,883 @@
+/* Copyright 2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_vlan.h>
+
+#include <uapi/linux/if_bridge.h>
+#include <net/netlink.h>
+
+#include "../../fsl-mc/include/mc.h"
+
+#include "dpdmux.h"
+#include "dpdmux-cmd.h"
+
+struct evb_port_priv {
+	struct net_device	*netdev;
+	struct list_head	list;
+	u16			port_index;
+	struct evb_priv		*evb_priv;
+	u8			vlans[VLAN_VID_MASK+1];
+};
+
+struct evb_priv {
+	/* keep first */
+	struct evb_port_priv	uplink;
+
+	struct fsl_mc_io	*mc_io;
+	struct list_head	port_list;
+	struct dpdmux_attr	attr;
+	uint16_t		mux_handle;
+	int			dev_id;
+};
+
+static netdev_tx_t evb_dropframe(struct sk_buff *skb, struct net_device *dev)
+{
+	/* we don't support I/O for now, drop the frame */
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int evb_port_add_rule(struct net_device *netdev,
+			     const unsigned char *addr, u16 vid)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct dpdmux_l2_rule	rule = { .vlan_id = vid };
+	int			err;
+
+	if (addr)
+		ether_addr_copy(rule.mac_addr, addr);
+
+	err = dpdmux_if_add_l2_rule(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index, &rule);
+	if (unlikely(err))
+		netdev_err(netdev, "dpdmux_if_add_l2_rule err %d\n", err);
+	return err;
+}
+
+static int evb_port_del_rule(struct net_device *netdev,
+			     const unsigned char *addr, u16 vid)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct dpdmux_l2_rule	rule = { .vlan_id = vid };
+	int err;
+
+	if (addr)
+		ether_addr_copy(rule.mac_addr, addr);
+
+	err = dpdmux_if_remove_l2_rule(port_priv->evb_priv->mc_io,
+				       port_priv->evb_priv->mux_handle,
+				       port_priv->port_index, &rule);
+	if (unlikely(err))
+		netdev_err(netdev, "dpdmux_if_remove_l2_rule err %d\n", err);
+	return err;
+}
+
+static bool _lookup_address(struct net_device *netdev,
+			    const unsigned char *addr)
+{
+	struct netdev_hw_addr	   *ha;
+	struct netdev_hw_addr_list *list = (is_unicast_ether_addr(addr)) ?
+					   &netdev->uc : &netdev->mc;
+
+	netif_addr_lock_bh(netdev);
+	list_for_each_entry(ha, &list->list, list) {
+		if (ether_addr_equal(ha->addr, addr)) {
+			netif_addr_unlock_bh(netdev);
+			return true;
+		}
+	}
+	netif_addr_unlock_bh(netdev);
+	return false;
+}
+
+static inline int evb_port_fdb_prep(struct nlattr *tb[],
+				    struct net_device *netdev,
+				    const unsigned char *addr, u16 *vid,
+				    bool del)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct evb_priv		*evb_priv = port_priv->evb_priv;
+
+	*vid = 0;
+
+	if (evb_priv->attr.method != DPDMUX_METHOD_MAC &&
+	    evb_priv->attr.method != DPDMUX_METHOD_C_VLAN_MAC) {
+		netdev_err(netdev,
+			   "EVB mode does not support MAC classification\n");
+		return -EOPNOTSUPP;
+	}
+
+	/* check if the address is configured on this port */
+	if (_lookup_address(netdev, addr)) {
+		if (!del)
+			return -EEXIST;
+	} else {
+		if (del)
+			return -ENOENT;
+	}
+
+	if (tb[NDA_VLAN] && evb_priv->attr.method == DPDMUX_METHOD_C_VLAN_MAC) {
+		if (nla_len(tb[NDA_VLAN]) != sizeof(unsigned short)) {
+			netdev_err(netdev, "invalid vlan size %d\n",
+				   nla_len(tb[NDA_VLAN]));
+			return -EINVAL;
+		}
+
+		*vid = nla_get_u16(tb[NDA_VLAN]);
+
+		if (!*vid || *vid >= VLAN_VID_MASK) {
+			netdev_err(netdev, "invalid vid value 0x%04x\n", *vid);
+			return -EINVAL;
+		}
+	} else if (evb_priv->attr.method == DPDMUX_METHOD_C_VLAN_MAC) {
+		netdev_err(netdev,
+			   "EVB mode requires explicit VLAN configuration\n");
+		return -EINVAL;
+	} else if (tb[NDA_VLAN]) {
+		netdev_warn(netdev, "VLAN not supported, argument ignored\n");
+	}
+
+	return 0;
+}
+
+static int evb_port_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
+			    struct net_device *netdev,
+			    const unsigned char *addr, u16 vid, u16 flags)
+{
+	u16 _vid;
+	int err;
+
+	/* TODO: add replace support when added to iproute bridge */
+	if (!(flags & NLM_F_REQUEST)) {
+		netdev_err(netdev,
+			   "evb_port_fdb_add unexpected flags value %08x\n",
+			   flags);
+		return -EINVAL;
+	}
+
+	err = evb_port_fdb_prep(tb, netdev, addr, &_vid, 0);
+	if (unlikely(err))
+		return err;
+
+
+	err = evb_port_add_rule(netdev, addr, _vid);
+	if (unlikely(err))
+		return err;
+
+	if (is_unicast_ether_addr(addr)) {
+		err = dev_uc_add(netdev, addr);
+		if (unlikely(err)) {
+			netdev_err(netdev, "dev_uc_add err %d\n", err);
+			return err;
+		}
+	} else {
+		err = dev_mc_add(netdev, addr);
+		if (unlikely(err)) {
+			netdev_err(netdev, "dev_mc_add err %d\n", err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int evb_port_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],
+			    struct net_device *netdev,
+			    const unsigned char *addr, u16 vid)
+{
+	u16 _vid;
+	int err;
+
+	err = evb_port_fdb_prep(tb, netdev, addr, &_vid, 1);
+	if (unlikely(err))
+		return err;
+
+	err = evb_port_del_rule(netdev, addr, _vid);
+	if (unlikely(err))
+		return err;
+
+	if (is_unicast_ether_addr(addr)) {
+		err = dev_uc_del(netdev, addr);
+		if (unlikely(err)) {
+			netdev_err(netdev, "dev_uc_del err %d\n", err);
+			return err;
+		}
+	} else {
+		err = dev_mc_del(netdev, addr);
+		if (unlikely(err)) {
+			netdev_err(netdev, "dev_mc_del err %d\n", err);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static const struct nla_policy ifla_br_policy[IFLA_MAX+1] = {
+	[IFLA_BRIDGE_FLAGS]	= { .type = NLA_U16 },
+	[IFLA_BRIDGE_MODE]	= { .type = NLA_U16 },
+	[IFLA_BRIDGE_VLAN_INFO]	= { .type = NLA_BINARY,
+				.len = sizeof(struct bridge_vlan_info), },
+};
+
+static int evb_setlink_af_spec(struct net_device *netdev,
+			       struct nlattr **tb)
+{
+	struct bridge_vlan_info	*vinfo;
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	int			err = 0;
+
+	if (!tb[IFLA_BRIDGE_VLAN_INFO]) {
+		netdev_err(netdev, "no VLAN INFO in nlmsg\n");
+		return -EOPNOTSUPP;
+	}
+
+	vinfo = nla_data(tb[IFLA_BRIDGE_VLAN_INFO]);
+
+	if (!vinfo->vid || vinfo->vid > VLAN_VID_MASK)
+		return -EINVAL;
+
+	err = evb_port_add_rule(netdev, NULL, vinfo->vid);
+	if (unlikely(err))
+		return err;
+
+	port_priv->vlans[vinfo->vid] = 1;
+
+	return 0;
+}
+
+static int evb_setlink(struct net_device *netdev, struct nlmsghdr *nlh)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct evb_priv		*evb_priv = port_priv->evb_priv;
+	struct nlattr		*attr;
+	struct nlattr		*tb[(IFLA_BRIDGE_MAX > IFLA_BRPORT_MAX) ?
+					IFLA_BRIDGE_MAX : IFLA_BRPORT_MAX+1];
+	int			err = 0;
+
+	if (evb_priv->attr.method != DPDMUX_METHOD_C_VLAN &&
+	    evb_priv->attr.method != DPDMUX_METHOD_S_VLAN) {
+		netdev_err(netdev,
+			   "EVB mode does not support VLAN only classification\n");
+		return -EOPNOTSUPP;
+	}
+
+	attr = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
+	if (attr) {
+		err = nla_parse_nested(tb, IFLA_BRIDGE_MAX, attr,
+				       ifla_br_policy);
+		if (unlikely(err)) {
+			netdev_err(netdev,
+				   "nla_parse_nested for br_policy err %d\n",
+				   err);
+			return err;
+		}
+
+		err = evb_setlink_af_spec(netdev, tb);
+		return err;
+	}
+
+	netdev_err(netdev, "nlmsg_find_attr found no AF_SPEC\n");
+	return -EOPNOTSUPP;
+}
+
+static int __nla_put_netdev(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct evb_priv		*evb_priv = port_priv->evb_priv;
+	u8			operstate = netif_running(netdev) ?
+				netdev->operstate : IF_OPER_DOWN;
+	int			err;
+
+	err = nla_put_string(skb, IFLA_IFNAME, netdev->name);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u32(skb, IFLA_MASTER, evb_priv->uplink.netdev->ifindex);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u32(skb, IFLA_MTU, netdev->mtu);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_OPERSTATE, operstate);
+	if (unlikely(err))
+		goto nla_put_err;
+	if (netdev->addr_len) {
+		err = nla_put(skb, IFLA_ADDRESS, netdev->addr_len,
+			      netdev->dev_addr);
+		if (unlikely(err))
+			goto nla_put_err;
+	}
+	if (netdev->ifindex != netdev->iflink) {
+		err = nla_put_u32(skb, IFLA_LINK, netdev->iflink);
+		if (unlikely(err))
+			goto nla_put_err;
+	}
+
+	return 0;
+
+nla_put_err:
+	netdev_err(netdev, "nla_put_ err %d\n", err);
+	return err;
+}
+
+static int __nla_put_port(struct sk_buff *skb, struct net_device *netdev)
+{
+	struct nlattr	*nest;
+	int		err;
+
+	nest = nla_nest_start(skb, IFLA_PROTINFO | NLA_F_NESTED);
+	if (!nest) {
+		netdev_err(netdev, "nla_nest_start failed\n");
+		return -ENOMEM;
+	}
+
+	err = nla_put_u8(skb, IFLA_BRPORT_STATE, BR_STATE_FORWARDING);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u16(skb, IFLA_BRPORT_PRIORITY, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u32(skb, IFLA_BRPORT_COST, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_MODE, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_GUARD, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_PROTECT, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_FAST_LEAVE, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_LEARNING, 0);
+	if (unlikely(err))
+		goto nla_put_err;
+	err = nla_put_u8(skb, IFLA_BRPORT_UNICAST_FLOOD, 1);
+	if (unlikely(err))
+		goto nla_put_err;
+	nla_nest_end(skb, nest);
+
+	return 0;
+
+nla_put_err:
+	netdev_err(netdev, "nla_put_ err %d\n", err);
+	nla_nest_cancel(skb, nest);
+	return err;
+}
+
+static int __nla_put_vlan(struct sk_buff *skb,  struct net_device *netdev)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct nlattr		*nest;
+	struct bridge_vlan_info	vinfo;
+	const u8		*vlans = port_priv->vlans;
+	u16			i;
+	int			err;
+
+	nest = nla_nest_start(skb, IFLA_AF_SPEC);
+	if (!nest) {
+		netdev_err(netdev, "nla_nest_start failed");
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < VLAN_VID_MASK+1; i++) {
+		if (!vlans[i])
+			continue;
+
+		vinfo.flags = 0;
+		vinfo.vid = i;
+
+		err = nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
+			      sizeof(vinfo), &vinfo);
+		if (unlikely(err))
+			goto nla_put_err;
+	}
+
+	nla_nest_end(skb, nest);
+
+	return 0;
+
+nla_put_err:
+	netdev_err(netdev, "nla_put_ err %d\n", err);
+	nla_nest_cancel(skb, nest);
+	return err;
+}
+
+static int evb_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+		       struct net_device *netdev, u32 filter_mask)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	struct evb_priv		*evb_priv = port_priv->evb_priv;
+	struct ifinfomsg	*hdr;
+	struct nlmsghdr		*nlh;
+	int			err;
+
+	if (evb_priv->attr.method != DPDMUX_METHOD_C_VLAN &&
+	    evb_priv->attr.method != DPDMUX_METHOD_S_VLAN) {
+		return 0;
+	}
+
+	nlh = nlmsg_put(skb, pid, seq, RTM_NEWLINK, sizeof(*hdr), NLM_F_MULTI);
+	if (!nlh)
+		return -EMSGSIZE;
+
+	hdr = nlmsg_data(nlh);
+	memset(hdr, 0, sizeof(*hdr));
+	hdr->ifi_family = AF_BRIDGE;
+	hdr->ifi_type = netdev->type;
+	hdr->ifi_index = netdev->ifindex;
+	hdr->ifi_flags = dev_get_flags(netdev);
+
+	err = __nla_put_netdev(skb, netdev);
+	if (unlikely(err))
+		goto nla_put_err;
+
+	err = __nla_put_port(skb, netdev);
+	if (unlikely(err))
+		goto nla_put_err;
+
+	/* Check if the VID information is requested */
+	if (filter_mask & RTEXT_FILTER_BRVLAN) {
+		err = __nla_put_vlan(skb, netdev);
+		if (unlikely(err))
+			goto nla_put_err;
+	}
+
+	return nlmsg_end(skb, nlh);
+
+nla_put_err:
+	nlmsg_cancel(skb, nlh);
+	return -EMSGSIZE;
+}
+
+static int evb_dellink(struct net_device *netdev, struct nlmsghdr *nlh)
+{
+	struct nlattr		*tb[IFLA_BRIDGE_MAX+1];
+	struct nlattr		*spec;
+	struct bridge_vlan_info	*vinfo;
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	int			err = 0;
+
+	spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
+	if (!spec)
+		return 0;
+
+	err = nla_parse_nested(tb, IFLA_BRIDGE_MAX, spec, ifla_br_policy);
+	if (unlikely(err))
+		return err;
+
+	if (!tb[IFLA_BRIDGE_VLAN_INFO])
+		return -EOPNOTSUPP;
+
+	vinfo = nla_data(tb[IFLA_BRIDGE_VLAN_INFO]);
+
+	if (!vinfo->vid || vinfo->vid > VLAN_VID_MASK)
+		return -EINVAL;
+
+	err = evb_port_del_rule(netdev, NULL, vinfo->vid);
+	if (unlikely(err)) {
+		netdev_err(netdev, "evb_port_del_rule err %d\n", err);
+		return err;
+	}
+	port_priv->vlans[vinfo->vid] = 0;
+
+	return 0;
+}
+
+static struct rtnl_link_stats64 *
+evb_port_get_stats(struct net_device *netdev,
+		   struct rtnl_link_stats64 *storage)
+{
+	struct evb_port_priv	*port_priv = netdev_priv(netdev);
+	u64			tmp;
+	int			err;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_ING_FRAME, &storage->rx_packets);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_ING_BYTE, &storage->rx_bytes);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_ING_FLTR_FRAME, &tmp);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_ING_FRAME_DISCARD,
+				    &storage->rx_dropped);
+	if (unlikely(err)) {
+		storage->rx_dropped = tmp;
+		goto error;
+	}
+	storage->rx_dropped += tmp;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_ING_MCAST_FRAME,
+				    &storage->multicast);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_EGR_FRAME, &storage->tx_packets);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_EGR_BYTE, &storage->tx_bytes);
+	if (unlikely(err))
+		goto error;
+
+	err = dpdmux_if_get_counter(port_priv->evb_priv->mc_io,
+				    port_priv->evb_priv->mux_handle,
+				    port_priv->port_index,
+				    DPDMUX_CNT_EGR_FRAME_DISCARD,
+				    &storage->tx_dropped);
+	if (unlikely(err))
+		goto error;
+
+	return storage;
+
+error:
+	netdev_err(netdev, "dpdmux_if_get_counter err %d\n", err);
+	return storage;
+}
+
+static const struct net_device_ops evb_port_ops = {
+	.ndo_start_xmit		= &evb_dropframe,
+
+	.ndo_fdb_add		= &evb_port_fdb_add,
+	.ndo_fdb_del		= &evb_port_fdb_del,
+
+	.ndo_get_stats64	= &evb_port_get_stats,
+};
+
+static int evb_open(struct net_device *netdev)
+{
+	struct evb_priv	*priv = netdev_priv(netdev);
+	int		err = 0;
+
+	err = dpdmux_enable(priv->mc_io, priv->mux_handle);
+	if (unlikely(err))
+		netdev_err(netdev, "dpdmux_enable err %d\n", err);
+
+	return err;
+}
+
+static int evb_close(struct net_device *netdev)
+{
+	struct evb_priv	*priv = netdev_priv(netdev);
+	int		err = 0;
+
+	err = dpdmux_disable(priv->mc_io, priv->mux_handle);
+	if (unlikely(err))
+		netdev_err(netdev, "dpdmux_disable err %d\n", err);
+
+	return err;
+}
+
+static const struct net_device_ops evb_ops = {
+	.ndo_start_xmit		= &evb_dropframe,
+	.ndo_open		= &evb_open,
+	.ndo_stop		= &evb_close,
+
+	.ndo_bridge_setlink	= &evb_setlink,
+	.ndo_bridge_getlink	= &evb_getlink,
+	.ndo_bridge_dellink	= &evb_dellink,
+
+	.ndo_get_stats64	= &evb_port_get_stats,
+};
+
+static int evb_takedown(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev = &evb_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+	int			err;
+
+	err = dpdmux_close(priv->mc_io, priv->mux_handle);
+	if (unlikely(err))
+		dev_warn(dev, "dpdmux_close err %d\n", err);
+
+	return 0;
+}
+
+static int evb_init(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev = &evb_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+	int			err = 0;
+
+	priv->dev_id = evb_dev->obj_desc.id;
+
+	err = dpdmux_open(priv->mc_io, priv->dev_id, &priv->mux_handle);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_open err %d\n", err);
+		goto err_exit;
+	}
+	if (!priv->mux_handle) {
+		dev_err(dev, "dpdmux_open returned null handle but no error\n");
+		err = -EFAULT;
+		goto err_exit;
+	}
+
+	err = dpdmux_get_attributes(priv->mc_io, priv->mux_handle,
+				    &priv->attr);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_get_attributes err %d\n", err);
+		goto err_close;
+	}
+
+	err = dpdmux_reset(priv->mc_io, priv->mux_handle);
+	if (unlikely(err)) {
+		dev_err(dev, "dpdmux_reset err %d\n", err);
+		goto err_close;
+	}
+
+	return 0;
+
+err_close:
+	dpdmux_close(priv->mc_io, priv->mux_handle);
+err_exit:
+	return err;
+}
+
+static int evb_remove(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev = &evb_dev->dev;
+	struct net_device	*netdev = dev_get_drvdata(dev);
+	struct evb_priv		*priv = netdev_priv(netdev);
+	struct evb_port_priv	*port_priv;
+	struct list_head	*pos;
+
+	list_for_each(pos, &priv->port_list) {
+		port_priv = list_entry(pos, struct evb_port_priv, list);
+
+		rtnl_lock();
+		netdev_upper_dev_unlink(port_priv->netdev, netdev);
+		rtnl_unlock();
+
+		unregister_netdev(port_priv->netdev);
+		free_netdev(port_priv->netdev);
+	}
+
+	unregister_netdev(netdev);
+
+	evb_takedown(evb_dev);
+	fsl_mc_portal_free(priv->mc_io);
+
+	dev_set_drvdata(dev, NULL);
+	free_netdev(netdev);
+
+	return 0;
+}
+
+static int evb_probe(struct fsl_mc_device *evb_dev)
+{
+	struct device		*dev;
+	struct evb_priv		*priv = NULL;
+	struct net_device	*netdev = NULL;
+	char			port_name[IFNAMSIZ];
+	int			i;
+	int			err = 0;
+
+	dev = &evb_dev->dev;
+
+	/* register switch device, it's for management only - no I/O */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		dev_err(dev, "alloc_etherdev error\n");
+		return -ENOMEM;
+	}
+	netdev->netdev_ops = &evb_ops;
+
+	dev_set_drvdata(dev, netdev);
+
+	priv = netdev_priv(netdev);
+
+	err = fsl_mc_portal_allocate(evb_dev, 0, &priv->mc_io);
+	if (unlikely(err)) {
+		dev_err(dev, "fsl_mc_portal_allocate err %d\n", err);
+		goto err_free_netdev;
+	}
+	if (!priv->mc_io) {
+		dev_err(dev, "fsl_mc_portal_allocate returned null handle but no error\n");
+		err = -EFAULT;
+		goto err_free_netdev;
+	}
+
+	err = evb_init(evb_dev);
+	if (unlikely(err)) {
+		dev_err(dev, "evb init err %d\n", err);
+		goto err_free_cmdport;
+	}
+
+	INIT_LIST_HEAD(&priv->port_list);
+	netdev->flags |= IFF_PROMISC | IFF_MASTER;
+
+	dev_alloc_name(netdev, "evb%d");
+
+	/* register switch ports */
+	snprintf(port_name, IFNAMSIZ, "%sp%%d", netdev->name);
+
+	/* only register downlinks? */
+	for (i = 0; i < priv->attr.num_ifs + 1; i++) {
+		struct net_device *port_netdev;
+		struct evb_port_priv *port_priv;
+
+		if (i) {
+			port_netdev =
+				alloc_etherdev(sizeof(struct evb_port_priv));
+			if (!port_netdev) {
+				dev_err(dev, "alloc_etherdev error\n");
+				goto err_takedown;
+			}
+
+			port_priv = netdev_priv(port_netdev);
+
+			port_netdev->flags |= IFF_PROMISC | IFF_SLAVE;
+
+			dev_alloc_name(port_netdev, port_name);
+		} else {
+			port_netdev = netdev;
+			port_priv = &priv->uplink;
+		}
+
+		port_priv->netdev = port_netdev;
+		port_priv->evb_priv = priv;
+		port_priv->port_index = i;
+
+		SET_NETDEV_DEV(port_netdev, dev);
+
+		if (i) {
+			port_netdev->netdev_ops = &evb_port_ops;
+
+			err = register_netdev(port_netdev);
+			if (err < 0) {
+				dev_err(dev, "register_netdev err %d\n", err);
+				free_netdev(port_netdev);
+				goto err_takedown;
+			}
+
+			rtnl_lock();
+			err = netdev_master_upper_dev_link(port_netdev, netdev);
+			if (unlikely(err)) {
+				dev_err(dev, "netdev_master_upper_dev_link err %d\n",
+					err);
+				unregister_netdev(port_netdev);
+				free_netdev(port_netdev);
+				rtnl_unlock();
+				goto err_takedown;
+			}
+			rtmsg_ifinfo(RTM_NEWLINK, port_netdev,
+				     IFF_SLAVE, GFP_KERNEL);
+			rtnl_unlock();
+
+			list_add(&(port_priv->list), &(priv->port_list));
+		} else {
+			err = register_netdev(netdev);
+
+			if (err < 0) {
+				dev_err(dev, "register_netdev error %d\n", err);
+				goto err_takedown;
+			}
+		}
+
+		/* ports are up from init */
+		rtnl_lock();
+		err = dev_open(port_netdev);
+		rtnl_unlock();
+		if (unlikely(err))
+			dev_warn(dev, "dev_open err %d\n", err);
+	}
+
+	dev_info(dev, "probed evb device with %d ports\n",
+		 priv->attr.num_ifs);
+	return 0;
+
+err_takedown:
+	evb_remove(evb_dev);
+err_free_cmdport:
+	fsl_mc_portal_free(priv->mc_io);
+err_free_netdev:
+	return err;
+}
+
+static const struct fsl_mc_device_match_id evb_match_id_table[] = {
+	{
+		.vendor = FSL_MC_VENDOR_FREESCALE,
+		.obj_type = "dpdmux",
+		.ver_major = DPDMUX_VER_MAJOR,
+		.ver_minor = DPDMUX_VER_MINOR,
+	},
+	{}
+};
+
+static struct fsl_mc_driver evb_drv = {
+	.driver = {
+		.name		= KBUILD_MODNAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= evb_probe,
+	.remove		= evb_remove,
+	.match_id_table = evb_match_id_table,
+};
+
+module_fsl_mc_driver(evb_drv);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Layerscape DPAA Edge Virtual Bridge driver (prototype)");
-- 
1.9.1

