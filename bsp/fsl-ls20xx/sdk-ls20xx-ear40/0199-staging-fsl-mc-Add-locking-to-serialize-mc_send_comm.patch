From a041c2addec74d4cb65a08b280ef3124681102fd Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Wed, 8 Apr 2015 18:23:26 -0500
Subject: [PATCH 199/237] staging: fsl-mc: Add locking to serialize
 mc_send_command() calls

Add a locking mechanism to serialize mc_send_command() calls that use
the same fsl_mc_io object (same MC portal). All mc_send_command() calls
with the same fsl_m_io object have to be either from non-atomic context
or from atomic context, but not both. When the fsl_mc_io object is
created the owner needs to know in which type of context the fsl_mc_io
object is going to be used. A flag passed-in to fsl_create_mc_io()
will indicate whether the fsl_mc_io object will be used in atomic or
non-atomic context. If the fsl_mc_io object is going to be used in
non-atomic context, mc_send_command() calls with it will be
serialized using a mutex. Otherwise, if the fsl_mc_io object is
going to be used in atomic context, mc_semd_command() calls with it
will be serialized using a spinlock.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: Icb770cd36e204ee6a17ad0f81e1d31cc9fe96816
Reviewed-on: http://git.am.freescale.net:8181/34876
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch from FSL LS2085 SDK EAR4.0]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/mc-sys.c     | 36 ++++++++++++++++++++++++++++-----
 drivers/staging/fsl-mc/include/mc-sys.h | 23 +++++++++++++++++++--
 2 files changed, 52 insertions(+), 7 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index 9ae000c..1679054 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -86,6 +86,11 @@ int __must_check fsl_create_mc_io(struct device *dev,
 	mc_io->portal_phys_addr = mc_portal_phys_addr;
 	mc_io->portal_size = mc_portal_size;
 	mc_io->resource = resource;
+	if (flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)
+		spin_lock_init(&mc_io->spinlock);
+	else
+		mutex_init(&mc_io->mutex);
+
 	res = devm_request_mem_region(dev,
 				      mc_portal_phys_addr,
 				      mc_portal_size,
@@ -230,15 +235,26 @@ static inline enum mc_cmd_status mc_read_response(struct mc_command __iomem *
  * @cmd: command to be sent
  *
  * Returns '0' on Success; Error code otherwise.
- *
- * NOTE: This function cannot be invoked from from atomic contexts.
  */
 int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 {
+	int error;
 	enum mc_cmd_status status;
 	unsigned long jiffies_until_timeout =
 	    jiffies + MC_CMD_COMPLETION_TIMEOUT_JIFFIES;
 
+	if (preemptible()) {
+		if (WARN_ON(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))
+			return -EINVAL;
+
+		mutex_lock(&mc_io->mutex);
+	} else {
+		if (WARN_ON(!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)))
+			return -EINVAL;
+
+		spin_lock(&mc_io->spinlock);
+	}
+
 	/*
 	 * Send command to the MC hardware:
 	 */
@@ -269,7 +285,8 @@ int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 				 (unsigned int)
 					MC_CMD_HDR_READ_CMDID(cmd->header));
 
-			return -ETIMEDOUT;
+			error = -ETIMEDOUT;
+			goto common_exit;
 		}
 	}
 
@@ -281,9 +298,18 @@ int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 			 mc_status_to_string(status),
 			 (unsigned int)status);
 
-		return mc_status_to_error(status);
+		error = mc_status_to_error(status);
+		goto common_exit;
 	}
 
-	return 0;
+	error = 0;
+
+common_exit:
+	if (preemptible())
+		mutex_unlock(&mc_io->mutex);
+	else
+		spin_unlock(&mc_io->spinlock);
+
+	return error;
 }
 EXPORT_SYMBOL(mc_send_command);
diff --git a/drivers/staging/fsl-mc/include/mc-sys.h b/drivers/staging/fsl-mc/include/mc-sys.h
index cb3b5a2..24e51f7 100644
--- a/drivers/staging/fsl-mc/include/mc-sys.h
+++ b/drivers/staging/fsl-mc/include/mc-sys.h
@@ -39,6 +39,13 @@
 #include <linux/errno.h>
 #include <linux/io.h>
 #include <linux/dma-mapping.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+
+/**
+ * Bit masks for a MC I/O object (struct fsl_mc_io) flags
+ */
+#define FSL_MC_IO_ATOMIC_CONTEXT_PORTAL	0x0001
 
 struct fsl_mc_resource;
 struct mc_command;
@@ -53,14 +60,26 @@ struct mc_command;
  * @resource: generic resource associated with the MC portal if
  * the MC portal came from a resource pool, or NULL if the MC portal
  * is permanently bound to a device (e.g., a DPRC)
+ * @mutex: Mutex to serialize mc_send_command() calls that use the same MC
+ * portal, if the fsl_mc_io object was created with the
+ * FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag off. mc_send_command() calls for this
+ * fsl_mc_io object must be made only from non-atomic context.
+ * @spinlock: Spinlock to serialize mc_send_command() calls that use the same MC
+ * portal, if the fsl_mc_io object was created with the
+ * FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag on. mc_send_command() calls for this
+ * fsl_mc_io object must be made only from atomic context.
  */
 struct fsl_mc_io {
 	struct device *dev;
-	uint32_t flags;
-	uint32_t portal_size;
+	uint16_t flags;
+	uint16_t portal_size;
 	phys_addr_t portal_phys_addr;
 	void __iomem *portal_virt_addr;
 	struct fsl_mc_resource *resource;
+	union {
+		struct mutex mutex;	/* serializes mc_send_command() calls */
+		spinlock_t spinlock;	/* serializes mc_send_command() calls */
+	};
 };
 
 int __must_check fsl_create_mc_io(struct device *dev,
-- 
1.9.1

