From dcc2c8409e83584a5ddf8540b815a0232f1b2f7d Mon Sep 17 00:00:00 2001
From: Marc Zyngier <marc.zyngier@arm.com>
Date: Mon, 24 Nov 2014 14:35:12 +0000
Subject: [PATCH 13/19] irqchip: GICv3: ITS: irqchip implementation

commit c48ed51c0d101ec4351530bdd6e1a01808f0a441 upstream

The usual methods that are used to present an irqchip to the rest
of the kernel

Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
Link: https://lkml.kernel.org/r/1416839720-18400-6-git-send-email-marc.zyngier@arm.com
Signed-off-by: Jason Cooper <jason@lakedaemon.net>
[irq-gic files are different from mainline, so this patch
 is not same as upstream.]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/irqchip/irq-gic-v3-its.c | 60 +++++++++++++++-------------------------
 1 file changed, 22 insertions(+), 38 deletions(-)

diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c
index b562876..c68a60f 100644
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -554,9 +554,21 @@ static void its_send_invall(struct its_node *its, struct its_collection *col)
 	its_send_single_command(its, its_build_invall_cmd, &desc);
 }
 
-static void lpi_set_config(struct its_device *its_dev, u32 hwirq,
-			   u32 id, int enable)
+/*
+ * irqchip functions - assumes MSI, mostly.
+ */
+
+static inline u32 its_get_event_id(struct irq_data *d)
+{
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	return d->hwirq - its_dev->lpi_base;
+}
+
+static void lpi_set_config(struct irq_data *d, bool enable)
 {
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
+	irq_hw_number_t hwirq = d->hwirq;
+	u32 id = its_get_event_id(d);
 	u8 *cfg = page_address(gic_rdist->prop_page) + hwirq - 8192;
 
 	if (enable)
@@ -576,41 +588,14 @@ static void lpi_set_config(struct its_device *its_dev, u32 hwirq,
 	its_send_inv(its_dev, id);
 }
 
-static inline u16 its_msi_get_entry_nr(struct msi_desc *desc)
-{
-	return desc->msi_attrib.entry_nr;
-}
-
 static void its_mask_irq(struct irq_data *d)
 {
-	struct its_device *its_dev = irq_data_get_irq_handler_data(d);
-	u32 id;
-
-	/* If MSI, propagate the unmask to the RC */
-	if (IS_ENABLED(CONFIG_PCI_MSI) && d->msi_desc) {
-		id = its_msi_get_entry_nr(d->msi_desc);
-		mask_msi_irq(d);
-	} else {
-		id = d->hwirq;
-	}
-
-	lpi_set_config(its_dev, d->hwirq, id, 0);
+	lpi_set_config(d, false);
 }
 
 static void its_unmask_irq(struct irq_data *d)
 {
-	struct its_device *its_dev = irq_data_get_irq_handler_data(d);
-	u32 id;
-
-	/* If MSI, propagate the unmask to the RC */
-	if (IS_ENABLED(CONFIG_PCI_MSI) && d->msi_desc) {
-		id = its_msi_get_entry_nr(d->msi_desc);
-		unmask_msi_irq(d);
-	} else {
-		id = d->hwirq;
-	}
-
-	lpi_set_config(its_dev, d->hwirq, id, 1);
+	lpi_set_config(d, true);
 }
 
 static void its_eoi_irq(struct irq_data *d)
@@ -622,19 +607,18 @@ static int its_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 			    bool force)
 {
 	unsigned int cpu = cpumask_any_and(mask_val, cpu_online_mask);
-	struct its_device *its_dev = irq_data_get_irq_handler_data(d);
+	struct its_device *its_dev = irq_data_get_irq_chip_data(d);
 	struct its_collection *target_col;
-	u32 id;
+	u32 id = its_get_event_id(d);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
 
 	target_col = &its_dev->its->collections[cpu];
-	if (IS_ENABLED(CONFIG_PCI_MSI) && d->msi_desc)
-		id = its_msi_get_entry_nr(d->msi_desc);
-	else
-		id = d->hwirq;
 	its_send_movi(its_dev, target_col, id);
 	its_dev->collection = target_col;
 
-	return IRQ_SET_MASK_OK;
+	return IRQ_SET_MASK_OK_DONE;
 }
 
 static void its_irq_compose_msi_msg(struct irq_data *d, struct msi_msg *msg)
-- 
1.9.1

