From ec01fc219538b005454737999420053f576e87d9 Mon Sep 17 00:00:00 2001
From: Liang Li <Liang.Li@windriver.com>
Date: Thu, 4 Sep 2008 00:07:06 +0800
Subject: [PATCH] Fix serial problem for SC16C2550 on sbc8560

The uart chip on the sb8560 is sc16c2550.  It needs to wait for
Transmit Holding register to become empty before writing data
into the register.

Then the backup timer is needed due to unstable IIR status of
the chip.

Signed-off-by: Liang Li <Liang.Li@windriver.com>
---
 drivers/serial/8250.c |   14 +++++++++++++-
 drivers/serial/8250.h |    7 +++++++
 2 files changed, 20 insertions(+), 1 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index d725ca9..3c24b1d 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -1360,6 +1360,8 @@ ignore_char:
 	*status = lsr;
 }
 
+static inline void wait_for_xmitr(struct uart_8250_port *up, int bits);
+
 static void transmit_chars(struct uart_8250_port *up)
 {
 	struct circ_buf *xmit = &up->port.info->xmit;
@@ -1382,6 +1384,9 @@ static void transmit_chars(struct uart_8250_port *up)
 
 	count = up->tx_loadsz;
 	do {
+		if(up->bugs & UART_BUG_TXW)
+			wait_for_xmitr(up, UART_LSR_THRE);
+
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		up->port.icount.tx++;
@@ -1812,9 +1817,11 @@ static int serial8250_startup(struct uart_port *port)
 	unsigned long flags;
 	unsigned char lsr, iir;
 	int retval;
+	unsigned int status;
 
 	up->capabilities = uart_config[up->port.type].flags;
 	up->mcr = 0;
+	up->bugs |= UART_KNOWN_BUGS;
 
 	if (up->port.type == PORT_16C950) {
 		/* Wake up and initialize UART */
@@ -1911,7 +1918,12 @@ static int serial8250_startup(struct uart_port *port)
 		 * If the interrupt is not reasserted, setup a timer to
 		 * kick the UART on a regular basis.
 		 */
-		if (!(iir1 & UART_IIR_NO_INT) && (iir & UART_IIR_NO_INT)) {
+		if(up->bugs & UART_BUG_IIR)
+			status = iir1 & UART_IIR_NO_INT;
+		else
+			status = !(iir1 & UART_IIR_NO_INT) && (iir & UART_IIR_NO_INT);
+
+		if (status) {
 			pr_debug("ttyS%d - using backup timer\n", port->line);
 			up->timer.function = serial8250_backup_timeout;
 			up->timer.data = (unsigned long)up;
diff --git a/drivers/serial/8250.h b/drivers/serial/8250.h
index 78c0016..d1a4d6f 100644
--- a/drivers/serial/8250.h
+++ b/drivers/serial/8250.h
@@ -47,6 +47,8 @@ struct serial8250_config {
 #define UART_BUG_QUOT	(1 << 0)	/* UART has buggy quot LSB */
 #define UART_BUG_TXEN	(1 << 1)	/* UART has buggy TX IIR status */
 #define UART_BUG_NOMSR	(1 << 2)	/* UART has buggy MSR status bits (Au1x00) */
+#define UART_BUG_TXW 	(1 << 3)	/* UART needs extra wait_for_xmitr() */
+#define UART_BUG_IIR 	(1 << 4)	/* UART has unstable iir status */
 
 #define PROBE_RSA	(1 << 0)
 #define PROBE_ANY	(~0)
@@ -73,6 +75,11 @@ struct serial8250_config {
  * the interrupt line _up_ instead of down, so if we register the IRQ
  * while the UART is in that state, we die in an IRQ storm. */
 #define ALPHA_KLUDGE_MCR (UART_MCR_OUT2)
+#define UART_KNOWN_BUGS (UART_BUG_TXW | UART_BUG_IIR)
 #else
 #define ALPHA_KLUDGE_MCR 0
 #endif
+
+#ifndef UART_KNOWN_BUGS
+#define UART_KNOWN_BUGS  0
+#endif
-- 
1.6.0

