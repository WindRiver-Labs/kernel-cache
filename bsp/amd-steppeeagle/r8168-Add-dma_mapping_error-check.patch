From e94bb096a1b9507022722c11b134bc8bfe9ff60e Mon Sep 17 00:00:00 2001
From: chunguang yang <chunguang.yang@windriver.com>
Date: Thu, 8 Jan 2015 09:32:10 +0800
Subject: [PATCH] r8168: Add dma_mapping_error check

commit d827d86b6fe [r8169: print errors when dma mapping fail] fixes a
similar issue when dma mappings fail. r8168_n.c is ported from
http://www.realtek.com.tw/. It's not in the upstream kernel. so We cannot
use commit d827d86b6fe directly and use r8169.c as a reference.

here is the calltrace:

[ 5.018828] r8168 0000:01:00.0: DMA-API: device driver failed to check
map error[device address=0x0000000063373002] [size=90 bytes] [mapped as
single]
[ 5.018893] Modules linked in:

[ 5.019034] CPU: 0 PID: 72 Comm: irq/73-eth0 Not tainted
3.10.55-ltsi-rt55-WR6.0.0.0_preempt-rt #1
[ 5.019102] Hardware name: To be filled by O.E.M. To be filled by
O.E.M./Larne CRB, BIOS 4.6.5 06/24/2014
[ 5.019175] 0000000000000009 ffff880062dfdc00 ffffffff8179f162
ffff880062dfdc38
[ 5.019178] ffffffff8103ad61 ffff880065e4d780 ffff880066a6d9b0
ffffffff81fc4610
[ 5.019182] ffffffff81ad32d4 000000000000005a ffff880062dfdc98
ffffffff8103adec
[ 5.019359] Call Trace:
[ 5.019417] [<ffffffff8179f162>] dump_stack+0x19/0x1b
[ 5.019424] [<ffffffff8103ad61>] warn_slowpath_common+0x61/0xa0
[ 5.019428] [<ffffffff8103adec>] warn_slowpath_fmt+0x4c/0x50
[ 5.019433] [<ffffffff81389b08>] check_unmap+0x4a8/0x950
[ 5.019438] [<ffffffff8138a00f>] debug_dma_unmap_page+0x5f/0x70
[ 5.019445] [<ffffffff8107006c>] ? migrate_enable+0x7c/0x200
[ 5.019452] [<ffffffff814e10dc>] rtl8168_unmap_tx_skb.isra.29+0x6c/0xb0
[ 5.019458] [<ffffffff814e7a0c>] rtl8168_interrupt+0x1bc/0x480
[ 5.019463] [<ffffffff810bb430>] ? irq_thread_fn+0x50/0x50
[ 5.019467] [<ffffffff810bb430>] ? irq_thread_fn+0x50/0x50

Signed-off-by: chunguang yang <chunguang.yang@windriver.com>
---
 drivers/net/ethernet/realtek/r8168_n.c |   66 ++++++++++++++++++++++++++------
 1 files changed, 54 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/realtek/r8168_n.c b/drivers/net/ethernet/realtek/r8168_n.c
index 8862f67..db35679 100644
--- a/drivers/net/ethernet/realtek/r8168_n.c
+++ b/drivers/net/ethernet/realtek/r8168_n.c
@@ -16241,13 +16241,15 @@ rtl8168_map_to_asic(struct RxDesc *desc,
 }
 
 static int
-rtl8168_alloc_rx_skb(struct pci_dev *pdev,
+rtl8168_alloc_rx_skb(struct rtl8168_private *tp,
 		     struct sk_buff **sk_buff,
 		     struct RxDesc *desc,
 		     int rx_buf_sz)
 {
 	struct sk_buff *skb;
 	dma_addr_t mapping;
+	struct pci_dev *pdev = tp->pci_dev;
+	struct device *d = &pdev->dev;
 	int ret = 0;
 
 	skb = dev_alloc_skb(rx_buf_sz + RTK_RX_ALIGN);
@@ -16260,11 +16262,20 @@ rtl8168_alloc_rx_skb(struct pci_dev *pdev,
 	mapping = pci_map_single(pdev, skb->data, rx_buf_sz,
 				 PCI_DMA_FROMDEVICE);
 
+	if (unlikely(dma_mapping_error(d, mapping))) {
+		if (net_ratelimit())
+			netif_err(tp, drv, tp->dev, "Failed to map RX DMA!\n");
+		goto err_out_dma_mapping;
+	}
+
 	rtl8168_map_to_asic(desc, mapping, rx_buf_sz);
 
 out:
 	return ret;
 
+err_out_dma_mapping:
+	dev_kfree_skb(skb);
+	*sk_buff = NULL;
 err_out:
 	ret = -ENOMEM;
 	rtl8168_make_unusable_by_asic(desc);
@@ -16297,7 +16308,7 @@ rtl8168_rx_fill(struct rtl8168_private *tp,
 		if (tp->Rx_skbuff[i])
 			continue;
 
-		ret = rtl8168_alloc_rx_skb(tp->pci_dev, tp->Rx_skbuff + i,
+		ret = rtl8168_alloc_rx_skb(tp, tp->Rx_skbuff + i,
 					   tp->RxDescArray + i, tp->rx_buf_sz);
 		if (ret < 0)
 			break;
@@ -16408,16 +16419,14 @@ rtl8168_unmap_tx_skb(struct pci_dev *pdev,
 	tx_skb->len = 0;
 }
 
-static void
-rtl8168_tx_clear(struct rtl8168_private *tp)
+
+static void rtl8168_tx_clear_range(struct rtl8168_private *tp, u32 start,
+                                   unsigned int n)
 {
 	unsigned int i;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
-	struct net_device *dev = tp->dev;
-#endif
 
-	for (i = tp->dirty_tx; i < tp->dirty_tx + NUM_TX_DESC; i++) {
-		unsigned int entry = i % NUM_TX_DESC;
+	for (i = 0; i < n; i++) {
+		unsigned int entry = (start + i) % NUM_TX_DESC;
 		struct ring_info *tx_skb = tp->tx_skb + entry;
 		unsigned int len = tx_skb->len;
 
@@ -16427,12 +16436,18 @@ rtl8168_tx_clear(struct rtl8168_private *tp)
 			rtl8168_unmap_tx_skb(tp->pci_dev, tx_skb,
 					     tp->TxDescArray + entry);
 			if (skb) {
-				dev_kfree_skb(skb);
+				tp->dev->stats.tx_dropped++;
+				dev_kfree_skb_any(skb);
 				tx_skb->skb = NULL;
 			}
-			RTLDEV->stats.tx_dropped++;
 		}
 	}
+}
+
+static void
+rtl8168_tx_clear(struct rtl8168_private *tp)
+{
+	rtl8168_tx_clear_range(tp, tp->dirty_tx, NUM_TX_DESC);
 	tp->cur_tx = tp->dirty_tx = 0;
 }
 
@@ -16572,6 +16587,7 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
 	struct skb_shared_info *info = skb_shinfo(skb);
 	unsigned int cur_frag, entry;
 	struct TxDesc *txd = NULL;
+	struct device *d = &tp->pci_dev->dev;
 
 	entry = tp->cur_tx;
 	for (cur_frag = 0; cur_frag < info->nr_frags; cur_frag++) {
@@ -16591,6 +16607,12 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
 		addr = skb_frag_address(frag);
 #endif
 		mapping = pci_map_single(tp->pci_dev, addr, len, PCI_DMA_TODEVICE);
+		if (unlikely(dma_mapping_error(d, mapping))) {
+			if (net_ratelimit())
+				netif_err(tp, drv, tp->dev,
+					  "Failed to map TX fragments DMA!\n");
+			goto err_out;
+		}
 
 		/* anti gcc 2.95.3 bugware (sic) */
 		status = opts1 | len | (RingEnd * !((entry + 1) % NUM_TX_DESC));
@@ -16607,6 +16629,10 @@ rtl8168_xmit_frags(struct rtl8168_private *tp,
 	}
 
 	return cur_frag;
+
+err_out:
+	rtl8168_tx_clear_range(tp, tp->cur_tx + 1, cur_frag);
+	return -EIO;
 }
 
 static inline u32
@@ -16660,6 +16686,7 @@ rtl8168_start_xmit(struct sk_buff *skb,
 	unsigned int frags, entry = tp->cur_tx % NUM_TX_DESC;
 	struct TxDesc *txd = tp->TxDescArray + entry;
 	void __iomem *ioaddr = tp->mmio_addr;
+	struct device *d = &tp->pci_dev->dev;
 	dma_addr_t mapping;
 	u32 status1, status2, len;
 	u32 opts1 = 0;
@@ -16692,7 +16719,9 @@ rtl8168_start_xmit(struct sk_buff *skb,
 	}
 
 	frags = rtl8168_xmit_frags(tp, skb, opts1);
-	if (frags) {
+	if (frags < 0)
+		goto err_dma_1;
+	else if (frags) {
 		len = skb_headlen(skb);
 		opts1 |= FirstFrag;
 	} else {
@@ -16714,6 +16743,11 @@ rtl8168_start_xmit(struct sk_buff *skb,
 	}
 
 	mapping = pci_map_single(tp->pci_dev, skb->data, len, PCI_DMA_TODEVICE);
+	if (unlikely(dma_mapping_error(d, mapping))) {
+		if (net_ratelimit())
+			netif_err(tp, drv, dev, "Failed to map TX DMA!\n");
+		goto err_dma_0;
+	}
 
 	tp->tx_skb[entry].len = len;
 	txd->addr = cpu_to_le64(mapping);
@@ -16744,6 +16778,14 @@ rtl8168_start_xmit(struct sk_buff *skb,
 
 out:
 	return ret;
+
+err_dma_1:
+	rtl8168_unmap_tx_skb(tp->pci_dev, tp->tx_skb + entry, txd);
+err_dma_0:
+	dev_kfree_skb_any(skb);
+	dev->stats.tx_dropped++;
+	return NETDEV_TX_OK;
+
 err_stop:
 	netif_stop_queue(dev);
 	ret = NETDEV_TX_BUSY;
-- 
1.7.5.4

