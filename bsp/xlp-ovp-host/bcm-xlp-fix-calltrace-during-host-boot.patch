From e1ed3594f2823fa6d9ef270fa7d118e8670c9f34 Mon Sep 17 00:00:00 2001
From: Nam Ninh <nam.ninh@windriver.com>
Date: Mon, 19 Jan 2015 10:04:58 -0500
Subject: [PATCH] bcm-xlp: fix calltrace during host boot

A patch was added on top of SDK 3.0.2 kernel in the base XLP BSP to
serialize the access to SPI bus. The patch adds spinlocks in
xlp_spi_interrupt. Since xlp_spi_interrupt is not a threaded interrupt
handler, it cannot be preempted and the patch works fine in
non-preemption kernel. When we turn on preemption in the kernel for OVP,
spinlocks in preemption kernel is preemptable with rtmutexes.
Using it in the XLP SPI interrupt handler causes the following exception
during NAND bad blocks scanning during boot.

Call Trace:
[<ffffffffc0a7da9c>] rt_spin_lock_slowlock+0x94/0x2cc
[<ffffffffc079649c>] xlp_spi_interrupt+0x64/0x2b0
[<ffffffffc03372e4>] handle_irq_event_percpu+0xa4/0x378
[<ffffffffc0337638>] handle_irq_event+0x80/0xd8
[<ffffffffc033b7c0>] handle_level_irq+0xe8/0x198
[<ffffffffc03366cc>] generic_handle_irq+0x54/0x88
[<ffffffffc0a7eda4>] do_IRQ+0x2c/0x40
[<ffffffffc0275140>] ret_from_irq+0x0/0x4
[<ffffffffc0a7ce24>] preempt_schedule_irq+0x44/0x80
[<ffffffffc02751b0>] need_resched+0x28/0x30

Code: 00621024  02621026  2c420001 <00020336> 66720ea0  0c29f9f2  0240202d  de620000  24030002
---[ end trace 0000000000000001 ]---
Kernel panic - not syncing: Fatal exception in interrupt

This fix to to use raw_spin_lock to avoid being preempted in the handler.
Since the main usage of the lock is to wrap around read/write to the SPI
configuration space, this conversion is safe.

Signed-off-by: Nam Ninh <nam.ninh@windriver.com>

diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index b08f479..35a964d 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -205,7 +205,7 @@ extern void nlm_kexec_init(void);
 #endif
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-spinlock_t g_flashmmc_lock;
+raw_spinlock_t g_flashmmc_lock;
 EXPORT_SYMBOL(g_flashmmc_lock);
 #endif
 
@@ -232,7 +232,7 @@ void __init prom_init(void)
 			(nlm_reset_entry_end - nlm_reset_entry));
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_init(&g_flashmmc_lock);
+	raw_spin_lock_init(&g_flashmmc_lock);
 #endif
 
 #ifdef CONFIG_SMP
diff --git a/drivers/mmc/host/sdhci-xlp.c b/drivers/mmc/host/sdhci-xlp.c
index 667fb28..b42647c 100644
--- a/drivers/mmc/host/sdhci-xlp.c
+++ b/drivers/mmc/host/sdhci-xlp.c
@@ -159,11 +159,11 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 		return -ENOMEM;
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 	ret = pci_enable_device(pdev);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 
 	if (ret) {
@@ -192,11 +192,11 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 	}
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 	writel(0x1C, sys_addr);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 
 	/*
@@ -224,11 +224,11 @@ static int sdhci_xlp_probe(struct pci_dev *pdev,
 
 err:
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 	pci_disable_device(pdev);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 	kfree(chip);
 
@@ -248,12 +248,12 @@ static void sdhci_xlp_remove(struct pci_dev *pdev)
 	if (chip) {
 		for (slotno = 0; slotno < XLP_NUM_SD_SLOT; slotno++) {
 #ifdef CONFIG_FLASH_MMC_LOCK
-			spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+			raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 			scratch = readl(chip->host[slotno]->ioaddr +
 					SDHCI_INT_STATUS);
 #ifdef CONFIG_FLASH_MMC_LOCK
-			spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+			raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 			if (scratch == (u32)-1)
 				dead = 1;
@@ -265,11 +265,11 @@ static void sdhci_xlp_remove(struct pci_dev *pdev)
 		pci_set_drvdata(pdev, NULL);
 	}
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 		pci_disable_device(pdev);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 }
 
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index bd534fa..ab288e8 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -21,7 +21,7 @@
 #include <linux/mmc/sdhci.h>
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-extern spinlock_t g_flashmmc_lock;
+extern raw_spinlock_t g_flashmmc_lock;
 #endif
 /*
  * Controller registers
@@ -355,9 +355,9 @@ static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
 {
 #ifdef CONFIG_FLASH_MMC_LOCK
 	unsigned long spinirq;
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	writel(val, host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #else
 	writel(val, host->ioaddr + reg);
 #endif
@@ -367,9 +367,9 @@ static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
 {
 #ifdef CONFIG_FLASH_MMC_LOCK
 	unsigned long spinirq;
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	writew(val, host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #else
 	writew(val, host->ioaddr + reg);
 #endif
@@ -380,9 +380,9 @@ static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
 {
 #ifdef CONFIG_FLASH_MMC_LOCK
 	unsigned long spinirq;
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	writeb(val, host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #else
 	writeb(val, host->ioaddr + reg);
 #endif
@@ -394,9 +394,9 @@ static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
 	unsigned long spinirq;
 	u32 value;
 
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	value = readl(host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 	return value;
 #else
 	return readl(host->ioaddr + reg);
@@ -409,9 +409,9 @@ static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
 	unsigned long spinirq;
 	u16 value;
 
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	value = readw(host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 	return value;
 #else
 	return readw(host->ioaddr + reg);
@@ -425,9 +425,9 @@ static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
 	unsigned long spinirq;
 	u8 value;
 
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	value = readb(host->ioaddr + reg);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 	return value;
 #else
 	return readb(host->ioaddr + reg);
diff --git a/drivers/spi/spi-xlp.c b/drivers/spi/spi-xlp.c
index 6036f0d..f716a7c 100644
--- a/drivers/spi/spi-xlp.c
+++ b/drivers/spi/spi-xlp.c
@@ -39,7 +39,7 @@
 #include <linux/interrupt.h>
 
 #ifdef CONFIG_FLASH_MMC_LOCK
-extern spinlock_t g_flashmmc_lock;
+extern raw_spinlock_t g_flashmmc_lock;
 #endif
 
 #define XLP_SPI_CONFIG			0x40
@@ -123,9 +123,9 @@ static inline int xlp_spi_reg_read(struct xlp_spi_priv *priv,
 	regidx += cs * SPI_CHAN_OFFSET;
 	addr = priv->base + (regidx << 2);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 	value = readl(addr);
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 	return value;
 #else
 	return readl(addr);
@@ -143,11 +143,11 @@ static inline void xlp_spi_reg_write(struct xlp_spi_priv *priv, int cs,
 	regidx += cs * SPI_CHAN_OFFSET;
 	addr = priv->base + (regidx << 2);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+	raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 #endif
 	writel(val, addr);
 #ifdef CONFIG_FLASH_MMC_LOCK
-	spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+	raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 #endif
 }
 
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index 3d13798..7e516c5 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -503,15 +503,15 @@ static inline int is_inside_flash_region(struct map_info *map)
 	return 0;
 }
 
-extern spinlock_t g_flashmmc_lock;
+extern raw_spinlock_t g_flashmmc_lock;
 static inline map_word map_read(struct map_info *map, unsigned long ofs)
 {
 	unsigned long spinirq;
 	map_word r;
 	if (is_inside_flash_region(map)) {
-		spin_lock_irqsave(&g_flashmmc_lock, spinirq);
+		raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);
 		r = inline_map_read(map, ofs);
-		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
+		raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);
 	} else {
 		r = inline_map_read(map, ofs);
 	}
@@ -522,9 +522,9 @@ static inline map_word map_read(struct map_info *map, unsigned long ofs)
 {\
 	unsigned long spinirq;\
 	if (is_inside_flash_region(map)) {\
-		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
 		inline_map_copy_from(map, to, from, len);\
-		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+		raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
 	} else \
 		inline_map_copy_from(map, to, from, len);\
 }
@@ -533,9 +533,9 @@ static inline map_word map_read(struct map_info *map, unsigned long ofs)
 {\
 	unsigned long spinirq;\
 	if (is_inside_flash_region(map)) {\
-		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
 		inline_map_write(map, datum, ofs);\
-		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+		raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
 	} else \
 		inline_map_write(map, datum, ofs);\
 }
@@ -543,9 +543,9 @@ static inline map_word map_read(struct map_info *map, unsigned long ofs)
 {\
 	unsigned long spinirq;\
 	if (is_inside_flash_region(map)) {\
-		spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
+		raw_spin_lock_irqsave(&g_flashmmc_lock, spinirq);\
 		inline_map_copy_to(map, to, from, len);\
-		spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
+		raw_spin_unlock_irqrestore(&g_flashmmc_lock, spinirq);\
 	} else \
 		inline_map_copy_to(map, to, from, len);\
 }
-- 
1.7.1

