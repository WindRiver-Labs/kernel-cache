From 3480ea6cc33926e87891be4144b29f55250890f6 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 7 Aug 2013 15:49:29 +0800
Subject: [PATCH 37/60] video: mmp3: add a basic media support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports the driver to WRLinux 3.4.x for
mmp3, and renders over Linux logo in LCD.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/include/mach/pxa168fb.h |    2 +
 arch/arm/mach-mmp/onboard/lcd_hdmi.c      |    2 -
 arch/arm/mach-mmp/onboard/lcd_mipi.c      |   93 +-
 drivers/media/video/Kconfig               |   10 +
 drivers/media/video/Makefile              |    1 +
 drivers/media/video/pxa168_overlay.c      | 2119 +++++++++++++++++++++++
 drivers/video/Kconfig                     |   20 +-
 drivers/video/Makefile                    |    6 +-
 drivers/video/pxa168fb.c                  | 2614 +++++++++++++++++++++++------
 drivers/video/pxa168fb.h                  | 1992 ++++++++++++++++++----
 drivers/video/pxa168fb_common.c           | 1727 +++++++++++++++++++
 drivers/video/pxa168fb_common.h           |   77 +
 drivers/video/pxa688_cmu.c                |  355 ++++
 drivers/video/pxa688_misc.c               | 1081 ++++++++++++
 drivers/video/pxa688_phy.c                | 1003 +++++++++++
 drivers/video/pxa688_vdma.c               |  824 +++++++++
 16 files changed, 10990 insertions(+), 936 deletions(-)
 create mode 100644 drivers/media/video/pxa168_overlay.c
 create mode 100644 drivers/video/pxa168fb_common.c
 create mode 100644 drivers/video/pxa168fb_common.h
 create mode 100644 drivers/video/pxa688_cmu.c
 create mode 100644 drivers/video/pxa688_misc.c
 create mode 100644 drivers/video/pxa688_phy.c
 create mode 100644 drivers/video/pxa688_vdma.c

diff --git a/arch/arm/mach-mmp/include/mach/pxa168fb.h b/arch/arm/mach-mmp/include/mach/pxa168fb.h
index 5f9a5ee..d2b34b4 100644
--- a/arch/arm/mach-mmp/include/mach/pxa168fb.h
+++ b/arch/arm/mach-mmp/include/mach/pxa168fb.h
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/earlysuspend.h>
 #include <linux/list.h>
+#include <linux/pm_qos.h>
 
 /* Dumb interface */
 #define PIN_MODE_DUMB_24		0
@@ -215,6 +216,7 @@ struct pxa168fb_info {
 	unsigned		irq_mask;
 
 	struct fb_var_screeninfo var_bak;
+	struct pm_qos_request qos_idle_fb;
 
 	/* gamma correction */
 	struct mvdisp_gamma	gamma;
diff --git a/arch/arm/mach-mmp/onboard/lcd_hdmi.c b/arch/arm/mach-mmp/onboard/lcd_hdmi.c
index 131e524..328f0f2 100644
--- a/arch/arm/mach-mmp/onboard/lcd_hdmi.c
+++ b/arch/arm/mach-mmp/onboard/lcd_hdmi.c
@@ -3,8 +3,6 @@
 #include <linux/regulator/machine.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
-#include <mach/mfp-mmp2.h>
-#include <mach/mmp2.h>
 #include <mach/mmp3.h>
 #include <mach/pxa168fb.h>
 
diff --git a/arch/arm/mach-mmp/onboard/lcd_mipi.c b/arch/arm/mach-mmp/onboard/lcd_mipi.c
index a2a75de..9cc7f66 100644
--- a/arch/arm/mach-mmp/onboard/lcd_mipi.c
+++ b/arch/arm/mach-mmp/onboard/lcd_mipi.c
@@ -2,16 +2,13 @@
 #include <linux/gpio.h>
 #include <linux/delay.h>
 #include <linux/regulator/machine.h>
+#include <plat/mfp.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
-#include <mach/mfp-mmp2.h>
-#include <mach/mmp2.h>
 #include <mach/mmp3.h>
-#include <mach/pxa988.h>
-#include <mach/tc35876x.h>
 #include <mach/pxa168fb.h>
-#include <mach/mmp2_plat_ver.h>
 #include <mach/regs-mcu.h>
+#include <mach/mfp-mmp2.h>
 
 /*
  * FIXME:add qhd_lcd to indicate if use qhd or use HVGA_VNC
@@ -156,68 +153,6 @@ static struct fb_videomode video_modes_emeidkb[] = {
 };
 #endif
 
-#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_QSEVEN)
-static int abilene_lvds_power(struct pxa168fb_info *fbi,
-				unsigned int spi_gpio_cs,
-				unsigned int spi_gpio_reset, int on)
-{
-	struct regulator *v_ldo10, *v_ldo19;
-	int lcd_rst_n;
-
-#ifdef CONFIG_MACH_QSEVEN
-	return 0;
-#endif
-	/*
-	 * FIXME: It is board related, baceuse zx will be replaced soon,
-	 * it is temproary distinguished by cpu
-	 */
-	lcd_rst_n = mfp_to_gpio(GPIO128_LCD_RST);
-	/* v_ldo19 AVDD_LVDS, 1.8V */
-	v_ldo19 = regulator_get(NULL, "v_ldo19");
-	/* v_ldo10, 2.8v */
-	v_ldo10 = regulator_get(NULL, "v_ldo10");
-
-	if (IS_ERR(v_ldo19) || IS_ERR(v_ldo10)) {
-		pr_err("%s regulator get error!\n", __func__);
-		v_ldo19 = NULL;
-		v_ldo10 = NULL;
-		return -EIO;
-	}
-
-	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
-		pr_err("gpio %d request failed\n", lcd_rst_n);
-		return -EIO;
-	}
-
-	if (on) {
-		/* v_ldo19 AVDD_LVDS, 1.8V */
-		regulator_set_voltage(v_ldo19, 1800000, 1800000);
-		regulator_enable(v_ldo19);
-
-		regulator_set_voltage(v_ldo10, 2800000, 2800000);
-		regulator_enable(v_ldo10);
-
-		/* release panel from reset */
-		gpio_direction_output(lcd_rst_n, 1);
-	} else {
-		/* disable v_ldo10 2.8v */
-		regulator_disable(v_ldo10);
-		regulator_put(v_ldo10);
-
-		/* disable v_ldo19 1.8v */
-		regulator_disable(v_ldo19);
-		regulator_put(v_ldo19);
-
-		gpio_direction_output(lcd_rst_n, 0);
-	}
-
-	gpio_free(lcd_rst_n);
-
-	pr_debug("%s on %d\n", __func__, on);
-	return 0;
-}
-#endif
-
 #ifdef CONFIG_MACH_YELLOWSTONE
 static int yellowstone_lvds_power(struct pxa168fb_info *fbi,
 			     unsigned int spi_gpio_cs,
@@ -553,13 +488,6 @@ static struct lvds_info lvdsinfo = {
 	.fmt	= LVDS_FMT_18BIT,
 };
 
-#if defined(CONFIG_MACH_THUNDERSTONEM)
-static struct lvds_info lvdsinfo_thunderstonem = {
-    .src    = LVDS_SRC_PN,
-    .fmt    = LVDS_FMT_24BIT,
-};
-#endif
-
 static void lvds_hook(struct pxa168fb_mach_info *mi)
 {
 	mi->phy_type = LVDS;
@@ -567,23 +495,6 @@ static void lvds_hook(struct pxa168fb_mach_info *mi)
 	mi->phy_info = (void *)&lvdsinfo;
 
 	mi->modes->refresh = 60;
-
-	if (machine_is_yellowstone()) {
-#ifdef CONFIG_MACH_YELLOWSTONE
-		mi->phy_info = (void *)&lvdsinfo;
-		mi->pxa168fb_lcd_power = yellowstone_lvds_power;
-#endif
-	} else if (machine_is_abilene()) {
-#ifdef CONFIG_MACH_ABILENE
-		mi->phy_info = (void *)&lvdsinfo;
-		mi->pxa168fb_lcd_power = abilene_lvds_power;
-#endif
-	} else if (machine_is_thunderstonem()) {
-#if defined(CONFIG_MACH_THUNDERSTONEM)
-		mi->pxa168fb_lcd_power = thunderstonem_lvds_power;
-		mi->phy_info = (void *)&lvdsinfo_thunderstonem;
-#endif
-	}
 }
 #endif
 
diff --git a/drivers/media/video/Kconfig b/drivers/media/video/Kconfig
index 94bce78..e0f7759 100644
--- a/drivers/media/video/Kconfig
+++ b/drivers/media/video/Kconfig
@@ -1249,3 +1249,13 @@ config VIDEO_MX2_EMMAPRP
 	    conversion.
 
 endif # V4L_MEM2MEM_DRIVERS
+
+config PXA168_V4L2_OVERLAY
+	bool
+	select VIDEOBUF2_DMA_CONTIG
+	select VIDEOBUF2_CORE
+	depends on VIDEO_V4L2
+	default y if CPU_MMP3
+        ---help---
+	  Marvell PXA168 LCD Controller overlay support. This is a video4linux2
+	  driver for the Marvell PXA168 LCD overlay controller.
diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 279cd6a..d9ff2eb 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -212,6 +212,7 @@ obj-$(CONFIG_VIDEO_IR_I2C)  += ir-kbd-i2c.o
 obj-y	+= davinci/
 
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
+obj-$(CONFIG_PXA168_V4L2_OVERLAY)  += pxa168_overlay.o
 
 ccflags-y += -I$(srctree)/drivers/media/dvb/dvb-core
 ccflags-y += -I$(srctree)/drivers/media/dvb/frontends
diff --git a/drivers/media/video/pxa168_overlay.c b/drivers/media/video/pxa168_overlay.c
new file mode 100644
index 0000000..19a8b12
--- /dev/null
+++ b/drivers/media/video/pxa168_overlay.c
@@ -0,0 +1,2119 @@
+/*
+ * PXA168 v4l2 overlay driver
+ *
+ * adapted from omap_vout.c
+ * Move to videobuf2 layer to support R/L frame pairs per HDMI 3D requirement.
+ *	- Jun 27 2011. Jun Nie(njun@marvell.com)
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/videodev2.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/irq.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/earlysuspend.h>
+
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-device.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include <asm/processor.h>
+#include <mach/dma.h>
+#include "../../video/pxa168fb_common.h"
+
+MODULE_AUTHOR("Jun Nie");
+MODULE_DESCRIPTION("PXA168 Video out driver");
+MODULE_LICENSE("GPL");
+
+/* configuration macros */
+#define VOUT_NAME		"pxa168_v4l2_ovly"
+
+#define VID_MAX_WIDTH		1920	/* Largest width */
+#define VID_MAX_HEIGHT		1080	/* Largest height */
+#define VID_QVGA_WIDTH		320
+#define VID_QVGA_HEIGHT		240
+#define VID_MIN_WIDTH		16
+#define VID_MIN_HEIGHT		16
+
+#define BUF_TYPE (ovly->hdmi3d ? V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE : \
+	V4L2_BUF_TYPE_VIDEO_OUTPUT)
+
+#define MAX_BUF_SIZE (VID_MAX_WIDTH*VID_MAX_HEIGHT*4)
+
+/* max control: hue, alpha, chroma key, contrast, saturation, gamma */
+#define MAX_CID		5
+#define COLOR_KEY_GFX_DST 0
+#define COLOR_KEY_VID_SRC 1
+
+/*
+ * Maximum amount of memory to use for rendering buffers.
+ * Default is enough to four (RGB24) DVI 720P buffers.
+ */
+#define MAX_ALLOWED_VIDBUFFERS            4
+
+const static struct v4l2_fmtdesc pxa168_formats[] = {
+	{
+	 .description = "YUV420, planer",
+	 .pixelformat = V4L2_PIX_FMT_YUV420,
+	},
+	{
+	 .description = "YVU420, planer",
+	 .pixelformat = V4L2_PIX_FMT_YVU420,
+	},
+	{
+	 .description = "YUV422, planer",
+	 .pixelformat = V4L2_PIX_FMT_YUV422P,
+	},
+	{
+	 .description = "YUYV (YUV 4:2:2), packed",
+	 .pixelformat = V4L2_PIX_FMT_YUYV,
+	},
+	{
+	 .description = "UYVY (YUV 4:2:2), packed",
+	 .pixelformat = V4L2_PIX_FMT_UYVY,
+	},
+	{
+	 .description = "RGB565",
+	 .pixelformat = V4L2_PIX_FMT_RGB565X,
+	},
+	{
+	 .description = "RGB8888, unpacked",
+	 .pixelformat = V4L2_PIX_FMT_RGB32,
+	},
+	{
+	 .description = "BGR8888, unpacked",
+	 .pixelformat = V4L2_PIX_FMT_BGR32,
+	},
+	{
+	 .description = "RGB888, packed",
+	 .pixelformat = V4L2_PIX_FMT_RGB24,
+	},
+	{
+	 .description = "BGR888, packed",
+	 .pixelformat = V4L2_PIX_FMT_BGR24,
+	},
+};
+#define NUM_OUTPUT_FORMATS (ARRAY_SIZE(pxa168_formats))
+
+struct pxa168_buf {
+	/* common v4l buffer stuff -- must be first */
+	struct vb2_buffer       vb;
+	struct list_head        list;
+};
+
+struct pxa168_overlay {
+	int id;
+	struct device *dev;
+	const char *name;
+	void *reg_base;
+	struct clk *clk;
+
+	struct video_device *vdev;
+	int opened;
+
+	int enabled;
+	bool hdmi3d;
+	bool alpha_enabled;
+	dma_addr_t paddr[2];
+	u16 ypitch;
+	u16 uvpitch;
+	int y_size;
+	int uv_size;
+	int trans_enabled;
+	int trans_key_type;
+	int trans_key;
+	bool mirror;
+
+	u16 pos_x;
+	u16 pos_y;
+	u16 out_width;		/* if 0, out_width == width */
+	u16 out_height;		/* if 0, out_height == height */
+	u8 global_alpha;
+	struct _sColorKeyNAlpha ckey_alpha;	/* fix me */
+	u32 dma_ctl0;
+	bool update;		/* if 1, update the overlay control info */
+
+	spinlock_t vbq_lock;	/* spinlock for videobuf queues */
+
+	/* non-NULL means streaming is in progress.
+	 * We could use native vb2 streaming flag vb2_is_streaming(&ovly->vbq)
+	 * But this hacking flag is needed for clone mode.
+	 * So ignore vb2 flag in driver
+	 */
+	bool streaming;
+
+	/* suspend/resume related */
+	struct early_suspend    early_suspend;
+
+	struct v4l2_pix_format pix;
+	struct v4l2_pix_format_mplane	pix_mp;
+	struct v4l2_rect crop;
+	struct v4l2_window win;
+	struct v4l2_framebuffer fbuf;	/* graphics layer info */
+
+	/* Lock to protect the shared data structures in ioctl */
+	struct mutex lock;
+
+	/* V4L2 control structure for different control id */
+	struct v4l2_control control[MAX_CID];
+	int flicker_filter;
+	/* V4L2 control structure for different control id */
+
+	int ps, vr_ps, line_length, field_id;
+	enum v4l2_memory memory;
+	struct pxa168_buf *cur_frm;
+	struct vb2_alloc_ctx    *alloc_ctx;
+	struct list_head dma_queue;
+	u32 cropped_offset;
+	s32 tv_field1_offset;
+
+	/* Buffer queue variabled */
+	enum v4l2_buf_type type;
+	struct vb2_queue vbq;
+};
+
+struct pxa168_overlay *v4l2_ovly[3];
+
+/* Local Helper functions */
+static void pxa168_ovly_cleanup_device(struct pxa168_overlay *ovly);
+static int debug;
+
+module_param(debug, bool, S_IRUGO);
+MODULE_PARM_DESC(debug, "Debug level (0-1)");
+
+/* Return the default overlay cropping rectangle in crop given the image
+ * size in pix and the video display size in fbuf.  The default
+ * cropping rectangle is the largest rectangle no larger than the capture size
+ * that will fit on the display.  The default cropping rectangle is centered in
+ * the image.  All dimensions and offsets are rounded down to even numbers.
+ */
+void pxa168_ovly_default_crop(struct v4l2_pix_format *pix,
+			      struct v4l2_framebuffer *fbuf,
+			      struct v4l2_rect *crop)
+{
+	crop->width = (pix->width < VID_MAX_WIDTH) ?
+	    pix->width : VID_MAX_WIDTH;
+	crop->height = (pix->height < VID_MAX_HEIGHT) ?
+	    pix->height : VID_MAX_HEIGHT;
+	crop->width &= ~1;
+	crop->height &= ~1;
+	crop->left = ((pix->width - crop->width) >> 1) & ~1;
+	crop->top = ((pix->height - crop->height) >> 1) & ~1;
+}
+
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The adjusted window parameters are
+ * returned in new_win.
+ * Returns zero if succesful, or -EINVAL if the requested window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int pxa168_ovly_try_window(struct v4l2_framebuffer *fbuf,
+			   struct v4l2_window *new_win)
+{
+	struct v4l2_rect try_win;
+
+	/* make a working copy of the new_win rectangle */
+	try_win = new_win->w;
+
+	/* adjust the preview window so it fits on the display by clipping any
+	 * offscreen areas
+	 */
+	if (try_win.left < 0) {
+		try_win.width += try_win.left;
+		try_win.left = 0;
+	}
+	if (try_win.top < 0) {
+		try_win.height += try_win.top;
+		try_win.top = 0;
+	}
+	try_win.width = (try_win.width < fbuf->fmt.width) ?
+	    try_win.width : fbuf->fmt.width;
+	try_win.height = (try_win.height < fbuf->fmt.height) ?
+	    try_win.height : fbuf->fmt.height;
+	if (try_win.left + try_win.width > fbuf->fmt.width)
+		try_win.width = fbuf->fmt.width - try_win.left;
+	if (try_win.top + try_win.height > fbuf->fmt.height)
+		try_win.height = fbuf->fmt.height - try_win.top;
+	try_win.width &= ~1;
+	try_win.height &= ~1;
+
+	if (try_win.width <= 0 || try_win.height <= 0)
+		return -EINVAL;
+
+	/* We now have a valid preview window, so go with it */
+	new_win->w = try_win;
+	new_win->field = V4L2_FIELD_ANY;
+	return 0;
+}
+
+/* Given a new render window in new_win, adjust the window to the
+ * nearest supported configuration.  The image cropping window in crop
+ * will also be adjusted if necessary.  Preference is given to keeping the
+ * the window as close to the requested configuration as possible.  If
+ * successful, new_win, ovly->win, and crop are updated.
+ * Returns zero if succesful, or -EINVAL if the requested preview window is
+ * impossible and cannot reasonably be adjusted.
+ */
+int pxa168_ovly_new_window(struct v4l2_rect *crop,
+			   struct v4l2_window *win,
+			   struct v4l2_framebuffer *fbuf,
+			   struct v4l2_window *new_win)
+{
+	int err;
+
+	err = pxa168_ovly_try_window(fbuf, new_win);
+	if (err)
+		return err;
+
+	/* update our preview window */
+	win->w = new_win->w;
+	win->field = new_win->field;
+	win->chromakey = new_win->chromakey;
+
+	/* adjust the cropping window to allow for resizing limitations */
+	if (crop->height >= (win->w.height << 2)) {
+		/* The maximum vertical downsizing ratio is 4:1 */
+		crop->height = win->w.height << 2;
+	}
+	if (crop->width >= (win->w.width << 2)) {
+		/* The maximum horizontal downsizing ratio is 4:1 */
+		crop->width = win->w.width << 2;
+	}
+	return 0;
+}
+
+/* Given a new cropping rectangle in new_crop, adjust the cropping rectangle to
+ * the nearest supported configuration.  The image render window in win will
+ * also be adjusted if necessary.  The preview window is adjusted such that the
+ * horizontal and vertical rescaling ratios stay constant.  If the render
+ * window would fall outside the display boundaries, the cropping rectangle
+ * will also be adjusted to maintain the rescaling ratios.  If successful, crop
+ * and win are updated.
+ * Returns zero if succesful, or -EINVAL if the requested cropping rectangle is
+ * impossible and cannot reasonably be adjusted.
+ */
+int pxa168_ovly_new_crop(struct v4l2_pix_format *pix,
+			 struct v4l2_rect *crop, struct v4l2_window *win,
+			 struct v4l2_framebuffer *fbuf,
+			 const struct v4l2_rect *new_crop)
+{
+	struct v4l2_rect try_crop;
+	unsigned long vresize, hresize;
+
+	/* make a working copy of the new_crop rectangle */
+	try_crop = *new_crop;
+
+	/* adjust the cropping rectangle so it fits in the image */
+	if (try_crop.left < 0) {
+		try_crop.width += try_crop.left;
+		try_crop.left = 0;
+	}
+	if (try_crop.top < 0) {
+		try_crop.height += try_crop.top;
+		try_crop.top = 0;
+	}
+	try_crop.width = (try_crop.width < pix->width) ?
+	    try_crop.width : pix->width;
+	try_crop.height = (try_crop.height < pix->height) ?
+	    try_crop.height : pix->height;
+	if (try_crop.left + try_crop.width > pix->width)
+		try_crop.width = pix->width - try_crop.left;
+	if (try_crop.top + try_crop.height > pix->height)
+		try_crop.height = pix->height - try_crop.top;
+	try_crop.width &= ~1;
+	try_crop.height &= ~1;
+	if (try_crop.width <= 0 || try_crop.height <= 0)
+		return -EINVAL;
+
+	/* vertical resizing */
+	vresize = (1024 * crop->height) / win->w.height;
+	if (vresize > 4096)
+		vresize = 4096;
+	else if (vresize == 0)
+		vresize = 1;
+	win->w.height = ((1024 * try_crop.height) / vresize) & ~1;
+	if (win->w.height == 0)
+		win->w.height = 2;
+	if (win->w.height + win->w.top > fbuf->fmt.height) {
+		/* We made the preview window extend below the bottom of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping height to maintain the vertical resizing ratio.
+		 */
+		win->w.height = (fbuf->fmt.height - win->w.top) & ~1;
+		if (try_crop.height == 0)
+			try_crop.height = 2;
+	}
+	/* horizontal resizing */
+	hresize = (1024 * crop->width) / win->w.width;
+	if (hresize > 4096)
+		hresize = 4096;
+	else if (hresize == 0)
+		hresize = 1;
+	win->w.width = ((1024 * try_crop.width) / hresize) & ~1;
+	if (win->w.width == 0)
+		win->w.width = 2;
+	if (win->w.width + win->w.left > fbuf->fmt.width) {
+		/* We made the preview window extend past the right side of the
+		 * display, so clip it to the display boundary and resize the
+		 * cropping width to maintain the horizontal resizing ratio.
+		 */
+		win->w.width = (fbuf->fmt.width - win->w.left) & ~1;
+		if (try_crop.width == 0)
+			try_crop.width = 2;
+	}
+
+	/* Check for resizing constraints */
+	if (try_crop.height >= (win->w.height << 2)) {
+		/* The maximum vertical downsizing ratio is 4:1 */
+		try_crop.height = win->w.height << 2;
+	}
+	if (try_crop.width >= (win->w.width << 2)) {
+		/* The maximum horizontal downsizing ratio is 4:1 */
+		try_crop.width = win->w.width << 2;
+	}
+
+	/* update our cropping rectangle and we're done */
+	*crop = try_crop;
+	return 0;
+}
+
+/* Given a new format in pix and fbuf,  crop and win
+ * structures are initialized to default values. crop
+ * is initialized to the largest window size that will fit on the display.  The
+ * crop window is centered in the image. win is initialized to
+ * the same size as crop and is centered on the display.
+ * All sizes and offsets are constrained to be even numbers.
+ */
+void pxa168_ovly_new_format(struct v4l2_pix_format *pix,
+			    struct v4l2_framebuffer *fbuf,
+			    struct v4l2_rect *crop, struct v4l2_window *win)
+{
+	/* crop defines the preview source window in the image capture
+	 * buffer
+	 */
+	pxa168_ovly_default_crop(pix, fbuf, crop);
+
+
+	win->w.width = (crop->width < fbuf->fmt.width) ?
+	    crop->width : fbuf->fmt.width;
+	win->w.height = (crop->height < fbuf->fmt.height) ?
+	    crop->height : fbuf->fmt.height;
+	win->w.width &= ~1;
+	win->w.height &= ~1;
+	win->w.left = ((fbuf->fmt.width - win->w.width) >> 1) & ~1;
+	win->w.top = ((fbuf->fmt.height - win->w.height) >> 1) & ~1;
+}
+
+void pixmp_to_pix(struct v4l2_pix_format *pix,
+		 struct v4l2_pix_format_mplane *pix_mp)
+{
+	pix->width = pix_mp->width;
+	pix->height = pix_mp->height;
+	pix->pixelformat = pix_mp->pixelformat;
+	pix->field = pix_mp->field;
+	pix->colorspace = pix_mp->colorspace;
+	pix->bytesperline = pix_mp->plane_fmt[0].bytesperline;
+	pix->sizeimage = pix_mp->plane_fmt[0].sizeimage;
+}
+
+/* Assume 3D R/L frame pairs. We do not support discrete YUV planars */
+void pix_to_pixmp(struct v4l2_pix_format *pix,
+		 struct v4l2_pix_format_mplane *pix_mp)
+{
+	pix_mp->width = pix->width;
+	pix_mp->height = pix->height;
+	pix_mp->pixelformat = pix->pixelformat;
+	pix_mp->field = pix->field;
+	pix_mp->colorspace = pix->colorspace;
+	pix_mp->plane_fmt[0].bytesperline = pix->bytesperline;
+	pix_mp->plane_fmt[0].sizeimage = pix->sizeimage;
+	pix_mp->plane_fmt[1].bytesperline = pix->bytesperline;
+	pix_mp->plane_fmt[1].sizeimage = pix->sizeimage;
+	pix_mp->num_planes = 2;
+}
+
+/* Try format */
+static int pxa168_ovly_try_format(struct v4l2_pix_format *pix)
+{
+	int ifmt, bpp = 0;
+
+	pix->height = clamp(pix->height, (u32) VID_MIN_HEIGHT,
+			    (u32) VID_MAX_HEIGHT);
+	pix->width =
+	    clamp(pix->width, (u32) VID_MIN_WIDTH, (u32) VID_MAX_WIDTH);
+
+	for (ifmt = 0; ifmt < NUM_OUTPUT_FORMATS; ifmt++) {
+		if (pix->pixelformat == pxa168_formats[ifmt].pixelformat)
+			break;
+	}
+
+	if (ifmt == NUM_OUTPUT_FORMATS)
+		ifmt = 0;
+
+	pix->pixelformat = pxa168_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_ANY;
+	pix->priv = 0;
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YUV420:
+	case V4L2_PIX_FMT_YVU420:
+	default:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		bpp = 12;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+	case V4L2_PIX_FMT_YUYV:
+	case V4L2_PIX_FMT_UYVY:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		bpp = 16;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = 16;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+	case V4L2_PIX_FMT_BGR24:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = 24;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+	case V4L2_PIX_FMT_BGR32:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		bpp = 32;
+		break;
+	}
+	pix->bytesperline = (pix->width * bpp) >> 3;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	return 0;
+}
+
+/* Setup the overlay info */
+int pxa168vid_setup_overlay(struct pxa168_overlay *ovly, int posx, int posy,
+			    int outw, int outh)
+{
+	ovly->pos_x = posx;
+	ovly->pos_y = posy;
+	ovly->out_width = outw;
+	ovly->out_height = outh;
+
+	ovly->global_alpha = ovly->win.global_alpha;
+	ovly->update = 1;
+
+	v4l2_dbg(1, debug, ovly->vdev,
+		 "%s:id %d ovly.enable=%d hdmi3d=%d ovly.addr=%x\n"
+		 "pix.width=%d pix.height=%d crop.width=%d crop.height=%d\n"
+		 "ovly.posx=%d ovly.posy=%d ovly.out_width = %d "
+		 "ovly.out_height=%d\n ",
+		 __func__, ovly->id, ovly->enabled, ovly->hdmi3d,
+		 ovly->paddr[0], ovly->pix.width, ovly->pix.height,
+		 ovly->crop.width, ovly->crop.height,
+		 ovly->pos_x, ovly->pos_y, ovly->out_width, ovly->out_height);
+	return 0;
+}
+
+/* Initialize the overlay structure */
+int pxa168vid_init(struct pxa168_overlay *ovly)
+{
+	int ret = 0;
+	int posx, posy;
+	int outw, outh;
+	u32 reg;
+	struct v4l2_window *win;
+	struct v4l2_pix_format *pix;
+	struct pxa168fb_mach_info *mi;
+
+	pix = &ovly->pix;
+	mi = ovly->dev->platform_data;
+
+	reg = dma_ctrl_read(ovly->id, 0);
+	reg &= 0xef0fffe1;
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_YVU420:
+		reg |= CFG_DMA_SWAPUV(1);
+	case V4L2_PIX_FMT_YUV420:
+	default:
+		reg |= CFG_DMAFORMAT(GMODE_YUV420PLANAR) |
+			CFG_YUV2RGB_DMA(1) |
+			(mi->panel_rbswap << 4);
+		ovly->ypitch = pix->width;
+		ovly->uvpitch = pix->width >> 1;
+		ovly->y_size = pix->width * pix->height;
+		ovly->uv_size = ovly->y_size >> 2;
+		break;
+	case V4L2_PIX_FMT_YUV422P:
+		reg |= CFG_DMAFORMAT(GMODE_YUV422PLANAR) |
+			CFG_YUV2RGB_DMA(1) |
+			(mi->panel_rbswap << 4);
+		ovly->ypitch = pix->width;
+		ovly->uvpitch = pix->width >> 1;
+		ovly->y_size = pix->width * pix->height;
+		ovly->uv_size = ovly->y_size >> 1;
+		break;
+	case V4L2_PIX_FMT_YUYV:
+		reg |= CFG_DMA_SWAPYU(1);
+	case V4L2_PIX_FMT_UYVY:
+		reg |= CFG_DMAFORMAT(GMODE_YUV422PACKED) |
+			CFG_YUV2RGB_DMA(1) |
+			(mi->panel_rbswap << 4);
+		ovly->ypitch = pix->width << 1;
+		ovly->uvpitch = 0;
+		break;
+	case V4L2_PIX_FMT_RGB565X:
+		/* most significant byte: RED; least significant byte: BLUE */
+		reg |= (mi->panel_rbswap) ? (0) : CFG_DMA_SWAPRB(1);
+		ovly->ypitch = pix->width << 1;
+		ovly->uvpitch = 0;
+		break;
+	case V4L2_PIX_FMT_BGR24:
+		reg |= CFG_DMAFORMAT(VMODE_RGB888PACKED);
+		/* most significant byte: RED; least significant byte: BLUE */
+		reg |= (mi->panel_rbswap) ? (0) : CFG_DMA_SWAPRB(1);
+		ovly->ypitch = pix->width * 3;
+		ovly->uvpitch = 0;
+		break;
+	case V4L2_PIX_FMT_RGB24:
+		reg |= CFG_DMAFORMAT(VMODE_RGB888PACKED);
+		/* most significant byte: BLUE; least significant byte: RED */
+		reg |= (mi->panel_rbswap) ? CFG_DMA_SWAPRB(1) : (0);
+		ovly->ypitch = pix->width * 3;
+		ovly->uvpitch = 0;
+		break;
+	case V4L2_PIX_FMT_BGR32:
+		reg |= CFG_DMAFORMAT(VMODE_RGBA888);
+		/* most significant byte: RED; least significant byte: BLUE */
+		reg |= (mi->panel_rbswap) ? (0) : (CFG_DMA_SWAPRB(1));
+		ovly->ypitch = pix->width << 2;
+		ovly->uvpitch = 0;
+		break;
+	case V4L2_PIX_FMT_RGB32:
+		reg |= CFG_DMAFORMAT(VMODE_RGBA888);
+		/* most significant byte: BLUE; least significant byte: RED */
+		reg |= (mi->panel_rbswap) ? CFG_DMA_SWAPRB(1) : (0);
+		ovly->ypitch = pix->width << 2;
+		ovly->uvpitch = 0;
+		break;
+	}
+
+	if (ovly->hdmi3d && 1 == ovly->id)
+		reg |= CFG_DMA_FTOGGLE_MASK;
+	else
+		reg &= ~CFG_DMA_FTOGGLE_MASK;
+
+	if (ovly->streaming)
+		reg |= CFG_DMA_ENA_MASK;
+	else
+		reg &= ~CFG_DMA_ENA_MASK;
+
+	ovly->dma_ctl0 = reg;
+
+	win = &ovly->win;
+	outw = win->w.width;
+	outh = win->w.height;
+	posx = win->w.left;
+	posy = win->w.top;
+
+	ret = pxa168vid_setup_overlay(ovly, posx, posy, outw, outh);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	printk(KERN_WARNING VOUT_NAME "apply_changes failed\n");
+	return ret;
+}
+
+int pxa168vid_apply_changes(struct pxa168_overlay *ovly)
+{
+	struct lcd_regs *regs;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	unsigned long addr_y0, addr_u0, addr_v0;
+	unsigned long addr_y1 = 0, addr_u1 = 0, addr_v1 = 0;
+	u32 bpp, offset;
+
+	regs = get_regs(ovly->id);
+	bpp = ovly->pix.bytesperline / ovly->pix.width;
+	offset = ovly->crop.top * ovly->ypitch + ovly->crop.left * bpp;
+
+	addr_y0 = ovly->paddr[0] + offset;
+	writel(addr_y0, &regs->v_y0);
+	if (ovly->hdmi3d)
+		addr_y1 = ovly->paddr[1] + offset;
+	if (ovly->uvpitch) {
+		offset = ovly->crop.top * ovly->uvpitch +
+			 ovly->crop.left * bpp;
+		addr_u0 = ovly->paddr[0] + ovly->y_size + offset;
+		addr_v0 = addr_u0 + ovly->uv_size;
+		writel(addr_u0, &regs->v_u0);
+		writel(addr_v0, &regs->v_v0);
+	}
+
+	if (ovly->hdmi3d) {
+		writel(addr_y1, &regs->v_y1);
+		if (ovly->uvpitch) {
+			addr_u1 = ovly->paddr[1] + ovly->y_size + offset;
+			addr_v1 = addr_u1 + ovly->uv_size;
+			writel(addr_u1, &regs->v_u1);
+			writel(addr_v1, &regs->v_v1);
+		}
+	}
+
+	if (ovly->update) {
+		writel(ovly->ypitch, &regs->v_pitch_yc);
+		writel((ovly->uvpitch) << 16 | (ovly->uvpitch),
+		       &regs->v_pitch_uv);
+
+		writel(CFG_DMA_OVSA_VLN(ovly->pos_y) | ovly->pos_x,
+		       &regs->v_start);
+		writel((ovly->crop.height << 16) | ovly->crop.width,
+			&regs->v_size);
+		writel((ovly->out_height << 16) | ovly->out_width,
+			 &regs->v_size_z);
+
+		dma_ctrl_write(ovly->id, 0, ovly->dma_ctl0);
+		ovly->update = 0;
+	}
+
+	lcd_vdma = request_vdma(ovly->id, 1);
+	if (lcd_vdma) {
+		vdma_info_update(lcd_vdma, ovly->opened,
+			ovly->streaming, ovly->pix.pixelformat, 0, 0);
+		pxa688_vdma_config(lcd_vdma);
+	}
+	if (vid_vsmooth)
+		pxa688fb_vsmooth_set(ovly->id, 1, vid_vsmooth);
+
+	return 0;
+}
+
+int pxa168_ovly_set_colorkeyalpha(struct pxa168_overlay *ovly)
+{
+	unsigned int rb, dma0, temp, x, layer, shift;
+	struct pxa168fb_mach_info *mi;
+	struct _sColorKeyNAlpha *color_a = &ovly->ckey_alpha;
+	struct lcd_regs *regs;
+
+	mi = ovly->dev->platform_data;
+	regs = get_regs(ovly->id);
+	shift = ovly->id ? 20 : 18;
+	rb = layer = 0;
+	dma0 = dma_ctrl_read(ovly->id, 0);
+	x = dma_ctrl_read(ovly->id, 1) & ~(CFG_COLOR_KEY_MASK |
+			CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+	/* switch to color key mode */
+	switch (color_a->mode) {
+	case FB_DISABLE_COLORKEY_MODE:
+		/* do nothing */
+		break;
+	case FB_ENABLE_Y_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		break;
+	case FB_ENABLE_U_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x2);
+		break;
+	case FB_ENABLE_V_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x4);
+		break;
+	case FB_ENABLE_RGB_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x3);
+		rb = 1;
+		break;
+	case FB_ENABLE_R_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		rb = 1;
+		break;
+	case FB_ENABLE_G_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x6);
+		break;
+	case FB_ENABLE_B_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x7);
+		rb = 1;
+		break;
+	default:
+		pr_info("unknown mode");
+		return -1;
+	}
+
+	/* switch to alpha path selection and decide whether to do RB swap */
+	switch (color_a->alphapath) {
+	case FB_VID_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x0);
+		layer = CFG_CKEY_DMA;
+		if (rb)
+			rb = ((dma0 & CFG_DMA_SWAPRB_MASK) >> 4) ^
+					(mi->panel_rbswap);
+		break;
+	case FB_GRA_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x1);
+		layer = CFG_CKEY_GRA;
+		if (rb)
+			rb = ((dma0 & CFG_GRA_SWAPRB_MASK) >> 12) ^
+				 (mi->panel_rbswap);
+		break;
+	case FB_CONFIG_ALPHA:
+		x |= CFG_ALPHA_MODE(0x2);
+		rb = 0;
+		break;
+	default:
+		printk(KERN_INFO "unknown alpha path");
+		return -1;
+	}
+
+	/* check whether DMA turn on RB swap for this pixelformat. */
+	if (rb) {
+		if (color_a->mode == FB_ENABLE_R_COLORKEY_MODE) {
+			x &= ~CFG_COLOR_KEY_MODE(0x1);
+			x |= CFG_COLOR_KEY_MODE(0x7);
+		}
+
+		if (color_a->mode == FB_ENABLE_B_COLORKEY_MODE) {
+			x &= ~CFG_COLOR_KEY_MODE(0x7);
+			x |= CFG_COLOR_KEY_MODE(0x1);
+		}
+
+		/* exchange r b fields. */
+		temp = color_a->Y_ColorAlpha;
+		color_a->Y_ColorAlpha = color_a->V_ColorAlpha;
+		color_a->V_ColorAlpha = temp;
+
+		/* only alpha_Y take effect, switch back from V */
+		if (color_a->mode == FB_ENABLE_RGB_COLORKEY_MODE) {
+			color_a->Y_ColorAlpha &= 0xffffff00;
+			temp = color_a->V_ColorAlpha & 0xff;
+			color_a->Y_ColorAlpha |= temp;
+		}
+	}
+
+	/* configure alpha */
+	x |= CFG_ALPHA((color_a->config & 0xff));
+	dma_ctrl_write(ovly->id, 1, x);
+	writel(color_a->Y_ColorAlpha, &regs->v_colorkey_y);
+	writel(color_a->U_ColorAlpha, &regs->v_colorkey_u);
+	writel(color_a->V_ColorAlpha, &regs->v_colorkey_v);
+
+	if (ovly->fbuf.flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA)
+		/* disable pix alpha mode because it was enabled by default */
+		dma_ctrl_set(ovly->id, 0, CFG_NOBLENDING_MASK,
+			CFG_NOBLENDING(1));
+	else
+		dma_ctrl_set(ovly->id, 0, CFG_NOBLENDING_MASK, 0);
+
+	if (ovly->id != 2) {
+		/* enable DMA colorkey on GRA/VID layer in panel/TV path */
+		x = readl(ovly->reg_base + LCD_TV_CTRL1);
+		x &= ~(3<<shift); x |= layer<<shift;
+		writel(x, ovly->reg_base + LCD_TV_CTRL1);
+	}
+
+	return 0;
+}
+
+/* ------------------------------------------------------------------
+* Video buffer call backs
+* ------------------------------------------------------------------*/
+static int queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,
+		unsigned int *nplanes, unsigned long sizes[],
+		void *alloc_ctxs[])
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vq);
+	u32 size;
+
+	if (!ovly)
+		return -EINVAL;
+
+	/* *size = PAGE_ALIGN(ovly->pix.width * ovly->pix.height * 2); */
+	size = PAGE_ALIGN(ovly->pix.sizeimage);
+	/* Why need 3 */
+	if (0 == *nbuffers)
+		*nbuffers = 3;
+
+	*nplanes = 1;
+	sizes[0] = size;
+	alloc_ctxs[0] = ovly->alloc_ctx;
+	if (ovly->hdmi3d) {
+		*nplanes = 2;
+		sizes[1] = size;
+		alloc_ctxs[1] = ovly->alloc_ctx;
+	}
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: queue_setup, buffers=%d "
+		"planes=%d, size=%d\n", ovly->id, *nbuffers, *nplanes, size);
+
+	return 0;
+}
+
+static int buffer_init(struct vb2_buffer *vb)
+{
+	struct pxa168_buf *buf = container_of(vb, struct pxa168_buf, vb);
+
+	INIT_LIST_HEAD(&buf->list);
+	return 0;
+}
+
+/* This function will be called when VIDIOC_QBUF ioctl is called.
+ * It prepare buffers before give out for the display. This function
+ * user space virtual address into physical address if userptr memory
+ * exchange mechanism is used.
+ */
+static int buffer_prepare(struct vb2_buffer *vb)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vb->vb2_queue);
+	int ret = 0;
+	u32 size = PAGE_ALIGN(ovly->pix.sizeimage);
+
+	if (vb2_plane_size(vb, 0) < size) {
+		v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s data will not fit "
+			"into plane (%lu < %u)\n", ovly->id, __func__,
+			 vb2_plane_size(vb, 0), size);
+		return -EINVAL;
+	}
+	vb2_set_plane_payload(vb, 0, size);
+
+	if (!ovly->hdmi3d)
+		return ret;
+
+	if (vb2_plane_size(vb, 1) < size) {
+		v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s data will not fit "
+			"into plane (%lu < %u)\n", ovly->id, __func__,
+			 vb2_plane_size(vb, 1), size);
+		return -EINVAL;
+	}
+	vb2_set_plane_payload(vb, 1, size);
+
+	return ret;
+}
+
+static int buffer_finish(struct vb2_buffer *vb)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vb->vb2_queue);
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s\n", ovly->id, __func__);
+	return 0;
+}
+
+/* Buffer queue funtion will be called from the videobuf layer when _QBUF
+ * ioctl is called. It is used to enqueue buffer, which is ready to be
+ * displayed. */
+static void buffer_queue(struct vb2_buffer *vb)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vb->vb2_queue);
+	struct pxa168_buf *buf = container_of(vb, struct pxa168_buf, vb);
+	unsigned long flags = 0;
+
+	/* Driver is also maintainig a queue. So enqueue buffer in the driver
+	 * queue */
+	spin_lock_irqsave(&ovly->vbq_lock, flags);
+	list_add_tail(&buf->list, &ovly->dma_queue);
+	spin_unlock_irqrestore(&ovly->vbq_lock, flags);
+}
+
+/* Buffer cleanup funtion will be called from the videobuf layer
+ * when REQBUFS(0) ioctl is called. It is used to cleanup the buffer
+ * queue which driver maintaining. */
+static void buffer_cleanup(struct vb2_buffer *vb)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vb->vb2_queue);
+	struct list_head *pos, *n;
+	unsigned long flags = 0;
+
+	/* Driver is also maintainig a queue. So clearup the driver queue */
+	spin_lock_irqsave(&ovly->vbq_lock, flags);
+	list_for_each_safe(pos, n, &ovly->dma_queue) {
+		list_del(pos);
+	}
+	spin_unlock_irqrestore(&ovly->vbq_lock, flags);
+}
+static int start_streaming(struct vb2_queue *vq)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vq);
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d : %s\n", ovly->id, __func__);
+	return 0;
+}
+
+/* abort streaming and wait for last buffer */
+static int stop_streaming(struct vb2_queue *vq)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vq);
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s\n", ovly->id, __func__);
+	return 0;
+}
+
+static void pxa168_lock(struct vb2_queue *vq)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vq);
+	mutex_lock(&ovly->lock);
+}
+
+static void pxa168_unlock(struct vb2_queue *vq)
+{
+	struct pxa168_overlay *ovly = vb2_get_drv_priv(vq);
+	mutex_unlock(&ovly->lock);
+}
+
+static struct vb2_ops video_vbq_ops = {
+	.queue_setup            = queue_setup,
+	.buf_init               = buffer_init,
+	.buf_prepare            = buffer_prepare,
+	.buf_finish             = buffer_finish,
+	.buf_queue              = buffer_queue,
+	.buf_cleanup		= buffer_cleanup,
+	.start_streaming        = start_streaming,
+	.stop_streaming         = stop_streaming,
+	.wait_prepare           = pxa168_unlock,
+	.wait_finish            = pxa168_lock,
+};
+
+/*
+ *  File operations
+ */
+static int pxa168_ovly_release(struct file *file)
+{
+
+	struct pxa168_overlay *ovly = file->private_data;
+	struct vb2_queue *q;
+	unsigned int ret;
+	unsigned long flags = 0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Entering %s\n",
+		 ovly->id, __func__);
+
+	if (!ovly)
+		return 0;
+	q = &ovly->vbq;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: vb2_is_streaming(q) %d\n",
+		 ovly->id, vb2_is_streaming(q));
+	spin_lock_irqsave(&ovly->vbq_lock, flags);
+	if (ovly->streaming) {
+		vb2_streamoff(q, BUF_TYPE);
+		ovly->streaming = 0;
+	}
+	spin_unlock_irqrestore(&ovly->vbq_lock, flags);
+	pxa688_vdma_release(ovly->id, 1);
+	pxa688fb_vsmooth_set(ovly->id, 1, 0);
+
+	/* Turn off the pipeline */
+	ret = pxa168vid_apply_changes(ovly);
+	if (ret)
+		printk(KERN_ERR VOUT_NAME "Unable to apply changes\n");
+
+	vb2_queue_release(q);
+	vb2_dma_contig_cleanup_ctx(ovly->alloc_ctx);
+	ovly->opened -= 1;
+	file->private_data = NULL;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Exiting %s\n",
+		 ovly->id, __func__);
+	return ret;
+}
+
+static int pxa168_ovly_open(struct file *file)
+{
+	struct pxa168_overlay *ovly = NULL;
+	struct vb2_queue *q;
+
+	ovly = video_drvdata(file);
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Entering %s\n",
+		ovly->id, __func__);
+
+	if (ovly == NULL)
+		return -ENODEV;
+
+	/* for now, we only support single open */
+	if (ovly->opened)
+		return -EBUSY;
+
+	ovly->opened += 1;
+
+	file->private_data = ovly;
+	ovly->type = BUF_TYPE;
+
+	q = &ovly->vbq;
+	memset(q, 0, sizeof(ovly->vbq));
+	q->type = BUF_TYPE;
+	q->io_modes = VB2_MMAP | VB2_USERPTR;
+	q->drv_priv = ovly;
+	q->buf_struct_size = sizeof(struct pxa168_buf);
+	q->ops = &video_vbq_ops;
+	q->mem_ops = &vb2_dma_contig_memops;
+
+	ovly->alloc_ctx = vb2_dma_contig_init_ctx(ovly->dev);
+	if (IS_ERR(ovly->alloc_ctx))
+		return PTR_ERR(ovly->alloc_ctx);
+
+	vb2_queue_init(q);
+
+	spin_lock_init(&ovly->vbq_lock);
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Exiting %s\n",
+		ovly->id, __func__);
+	return 0;
+}
+
+static unsigned int pxa168_poll(struct file *file,
+				struct poll_table_struct *wait)
+{
+	struct pxa168_overlay *ovly = file->private_data;
+	struct vb2_queue *q = &ovly->vbq;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s\n", ovly->id, __func__);
+
+	/*
+	if (BUF_TYPE != ovly->type)
+		return POLLERR;
+		*/
+
+	return vb2_poll(q, file, wait);
+}
+
+static int video_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct pxa168_overlay *ovly = file->private_data;
+
+	return vb2_mmap(&ovly->vbq, vma);
+}
+
+/* V4L2 ioctls */
+static int vidioc_querycap(struct file *file, void *fh,
+			   struct v4l2_capability *cap)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	strlcpy(cap->driver, VOUT_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, ovly->vdev->name, sizeof(cap->card));
+	cap->bus_info[0] = '\0';
+	cap->capabilities = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_OUTPUT;
+	return 0;
+}
+
+static int vidioc_enum_fmt_vid_out(struct file *file, void *fh,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	fmt->index = index;
+	fmt->type = type;
+	if (index >= NUM_OUTPUT_FORMATS)
+		return -EINVAL;
+
+	fmt->flags = pxa168_formats[index].flags;
+	strlcpy(fmt->description, pxa168_formats[index].description,
+		sizeof(fmt->description));
+	fmt->pixelformat = pxa168_formats[index].pixelformat;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_out(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	f->fmt.pix = ovly->pix;
+	return 0;
+
+}
+
+int vidioc_g_fmt_vid_out_mplane(struct file *file, void *fh,
+		struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	pix_to_pixmp(&ovly->pix, &f->fmt.pix_mp);
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_out(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	if (ovly->streaming)
+		return -EBUSY;
+
+	pxa168_ovly_try_format(&f->fmt.pix);
+	return 0;
+}
+
+static int vidioc_try_fmt_vid_out_mplane(struct file *file, void *fh,
+				  struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	if (ovly->streaming)
+		return -EBUSY;
+
+	if (2 != f->fmt.pix_mp.num_planes) {
+		v4l2_dbg(1, debug, ovly->vdev, "Error! ovly %d: plane number "
+			"%d is not supported\n", ovly->id,
+			 f->fmt.pix_mp.num_planes);
+		return -EINVAL;
+	}
+
+	pixmp_to_pix(&ovly->pix, &f->fmt.pix_mp);
+	pxa168_ovly_try_format(&ovly->pix);
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_out_mplane(struct file *file, void *fh,
+				struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct vb2_queue *q = &ovly->vbq;
+	spinlock_t *vbq_lock = &ovly->vbq_lock;
+	struct lcd_regs *regs = get_regs(ovly->id);
+	unsigned long flags = 0;
+	unsigned int x;
+	int ret = 0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: In %s\n", ovly->id, __func__);
+	if (ovly->streaming) {
+		v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Error, %s device "
+			 "busy\n", ovly->id, __func__);
+		return -EBUSY;
+	}
+
+	mutex_lock(&ovly->lock);
+	spin_lock_irqsave(vbq_lock, flags);
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == f->type) {
+		ovly->hdmi3d = 1;
+		q->type = ovly->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+		pixmp_to_pix(&ovly->pix, &f->fmt.pix_mp);
+	} else if (V4L2_BUF_TYPE_VIDEO_OUTPUT == f->type) {
+		ovly->hdmi3d = 0;
+		q->type = ovly->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		ovly->pix = f->fmt.pix;
+	} else {
+		v4l2_dbg(1, debug, ovly->vdev, "ovly %d: Invalid fmt %d\n",
+			 ovly->id, f->type);
+		ret = -EINVAL;
+		goto s_fmt;
+	}
+
+	pxa168_ovly_try_format(&ovly->pix);
+
+	/* We rely on base layer screen size to get the LCD size */
+	x = readl(&regs->screen_size);
+	ovly->fbuf.fmt.height = x >> 16;
+	ovly->fbuf.fmt.width = x & 0xffff;
+
+	/* set default crop and win */
+	pxa168_ovly_new_format(&ovly->pix, &ovly->fbuf, &ovly->crop,
+			       &ovly->win);
+
+	/* Save the changes in the overlay strcuture and set controller */
+	ret = pxa168vid_init(ovly);
+	if (ret) {
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+		goto s_fmt;
+	}
+	pix_to_pixmp(&ovly->pix, &f->fmt.pix_mp);
+s_fmt:
+	spin_unlock_irqrestore(vbq_lock, flags);
+	mutex_unlock(&ovly->lock);
+	return ret;
+}
+
+static int vidioc_try_fmt_vid_overlay(struct file *file, void *fh,
+				      struct v4l2_format *f)
+{
+	int err = -EINVAL;
+	struct pxa168_overlay *ovly = fh;
+	struct v4l2_window *win = &f->fmt.win;
+
+	err = pxa168_ovly_try_window(&ovly->fbuf, win);
+
+	if (err)
+		return err;
+
+	win->global_alpha = 255;
+
+	return 0;
+}
+
+static int vidioc_s_fmt_vid_overlay(struct file *file, void *fh,
+				    struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct v4l2_window *win = &f->fmt.win;
+	spinlock_t *vbq_lock = &ovly->vbq_lock;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: In %s\n", ovly->id, __func__);
+
+	mutex_lock(&ovly->lock);
+	spin_lock_irqsave(vbq_lock, flags);
+
+	ret = pxa168_ovly_new_window(&ovly->crop, &ovly->win, &ovly->fbuf, win);
+	if (ret)
+		goto out;
+	/* Save the changes in the overlay strcuture and set controller */
+	ret = pxa168vid_init(ovly);
+	if (ret) {
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+		goto out;
+	}
+
+	if (ovly->trans_enabled) {
+		/* color key enabled */
+		ovly->win.chromakey = f->fmt.win.chromakey;
+		ovly->trans_key = ovly->win.chromakey;
+		ovly->ckey_alpha.Y_ColorAlpha = ovly->win.chromakey;
+		ovly->ckey_alpha.U_ColorAlpha = ovly->win.chromakey;
+		ovly->ckey_alpha.V_ColorAlpha = ovly->win.chromakey;
+		ovly->ckey_alpha.mode = FB_ENABLE_RGB_COLORKEY_MODE;
+	} else {
+		ovly->win.chromakey = 0;
+		ovly->trans_key = ovly->win.chromakey;
+		ovly->ckey_alpha.Y_ColorAlpha = 0;
+		ovly->ckey_alpha.U_ColorAlpha = 0;
+		ovly->ckey_alpha.V_ColorAlpha = 0;
+		ovly->ckey_alpha.mode = FB_DISABLE_COLORKEY_MODE;
+	}
+
+	if (ovly->alpha_enabled) {
+		/* pixel alpha or config alpha enabled */
+		if (ovly->fbuf.flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) {
+			ovly->win.global_alpha = f->fmt.win.global_alpha;
+			ovly->ckey_alpha.config = ovly->win.global_alpha;
+			if (ovly->ckey_alpha.mode == FB_DISABLE_COLORKEY_MODE)
+				ovly->ckey_alpha.alphapath = FB_CONFIG_ALPHA;
+			else
+				ovly->ckey_alpha.alphapath = FB_GRA_PATH_ALPHA;
+		} else
+			/* pixel alpha enabled */
+			ovly->ckey_alpha.alphapath = FB_GRA_PATH_ALPHA;
+	} else {
+		ovly->win.global_alpha = 0xff;
+		ovly->ckey_alpha.config = ovly->win.global_alpha;
+		ovly->ckey_alpha.alphapath = FB_GRA_PATH_ALPHA;
+	}
+
+	pxa168_ovly_set_colorkeyalpha(ovly);
+out:
+	spin_unlock_irqrestore(vbq_lock, flags);
+	mutex_unlock(&ovly->lock);
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: chromakey %d, "
+		"global_alpha %d\n", ovly->id, ovly->win.chromakey,
+		 ovly->win.global_alpha);
+
+	return ret;
+}
+
+static int vidioc_enum_fmt_vid_overlay(struct file *file, void *fh,
+				       struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	fmt->index = index;
+	fmt->type = type;
+	if (index >= NUM_OUTPUT_FORMATS)
+		return -EINVAL;
+
+	fmt->flags = pxa168_formats[index].flags;
+	strlcpy(fmt->description, pxa168_formats[index].description,
+		sizeof(fmt->description));
+	fmt->pixelformat = pxa168_formats[index].pixelformat;
+	return 0;
+}
+
+static int vidioc_g_fmt_vid_overlay(struct file *file, void *fh,
+				    struct v4l2_format *f)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct v4l2_window *win = &f->fmt.win;
+	u32 key_value = 0;
+
+	win->w = ovly->win.w;
+	win->field = ovly->win.field;
+	win->global_alpha = ovly->win.global_alpha;
+
+	key_value = ovly->trans_key;
+	/* win->chromakey = key_value; */
+	win->chromakey = ovly->win.chromakey;
+	return 0;
+}
+
+static int vidioc_cropcap(struct file *file, void *fh,
+			  struct v4l2_cropcap *cropcap)
+{
+	struct pxa168_overlay *ovly = fh;
+	enum v4l2_buf_type type = cropcap->type;
+	struct v4l2_pix_format *pix = &ovly->pix;
+
+	cropcap->type = type;
+	/*
+	if (type != BUF_TYPE)
+		return -EINVAL;
+		*/
+
+	/* Width and height are always even */
+	cropcap->bounds.width = pix->width & ~1;
+	cropcap->bounds.height = pix->height & ~1;
+
+	pxa168_ovly_default_crop(&ovly->pix, &ovly->fbuf, &cropcap->defrect);
+	cropcap->pixelaspect.numerator = 1;
+	cropcap->pixelaspect.denominator = 1;
+	return 0;
+}
+
+static int vidioc_g_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	/*
+	if (crop->type != BUF_TYPE)
+		return -EINVAL;
+		*/
+	crop->c = ovly->crop;
+	return 0;
+}
+
+static int vidioc_s_crop(struct file *file, void *fh, struct v4l2_crop *crop)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct mutex *ovly_lock = &ovly->lock;
+	spinlock_t *vbq_lock = &ovly->vbq_lock;
+	unsigned long flags = 0;
+	int err = -EINVAL;
+
+	if (ovly->streaming)
+		return -EBUSY;
+
+	mutex_lock(ovly_lock);
+
+	/*if (crop->type == BUF_TYPE) {*/
+	if (1) {
+		spin_lock_irqsave(vbq_lock, flags);
+		err = pxa168_ovly_new_crop(&ovly->pix, &ovly->crop, &ovly->win,
+					   &ovly->fbuf, &crop->c);
+		if (!err)
+			ovly->update = 1;
+		spin_unlock_irqrestore(vbq_lock, flags);
+		mutex_unlock(ovly_lock);
+		return err;
+	} else {
+		mutex_unlock(ovly_lock);
+		return -EINVAL;
+	}
+}
+
+static int vidioc_queryctrl(struct file *file, void *fh,
+			    struct v4l2_queryctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_HUE:
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_GAMMA:
+
+		v4l2_ctrl_query_fill(ctrl, 0, 0xFFFFFF, 1, 0);
+		break;
+	default:
+		ctrl->name[0] = '\0';
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vidioc_g_ctrl(struct file *file, void *fh, struct v4l2_control *ctrl)
+{
+	/* struct pxa168_overlay *ovly = fh; */
+
+	switch (ctrl->id) {
+	case V4L2_CID_VFLIP:
+		{
+			return 0;
+		}
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int vidioc_s_ctrl(struct file *file, void *fh, struct v4l2_control *a)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	switch (a->id) {
+	case V4L2_CID_VFLIP:
+		{
+			unsigned int color = a->value;
+
+			mutex_lock(&ovly->lock);
+
+			ovly->control[1].value = color;
+			mutex_unlock(&ovly->lock);
+			return 0;
+		}
+
+	default:
+		return -EINVAL;
+	}
+
+}
+
+static int vidioc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *req)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct vb2_queue *q = &ovly->vbq;
+	unsigned long flags = 0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s\n", ovly->id, __func__);
+	/* if memory is not mmp or userptr
+	   return error */
+	if ((V4L2_MEMORY_MMAP != req->memory) &&
+	    (V4L2_MEMORY_USERPTR != req->memory))
+		return -EINVAL;
+
+	/*
+	if ((req->type != BUF_TYPE) || (req->count < 0))
+		return -EINVAL;
+		*/
+	spin_lock_irqsave(&ovly->vbq_lock, flags);
+	INIT_LIST_HEAD(&ovly->dma_queue);
+	spin_unlock_irqrestore(&ovly->vbq_lock, flags);
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: %s: vb2_reqbufs\n",
+		 ovly->id, __func__);
+	return vb2_reqbufs(q, req);
+}
+
+static int vidioc_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	return vb2_querybuf(&ovly->vbq, b);
+}
+
+static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *buffer)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct vb2_queue *q = &ovly->vbq;
+
+	/*
+	if (BUF_TYPE != buffer->type)
+		return -EINVAL;
+		*/
+
+	if (V4L2_MEMORY_USERPTR == buffer->memory) {
+		if (V4L2_BUF_TYPE_VIDEO_OUTPUT == q->type
+				&& ((buffer->length < ovly->pix.sizeimage) ||
+		    (0 == buffer->m.userptr))) {
+			return -EINVAL;
+		}
+		if (V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE == q->type
+			&& ((buffer->m.planes->length < ovly->pix.sizeimage) ||
+		    (0 == buffer->m.userptr))) {
+			return -EINVAL;
+		}
+		/* v4l2_dbg(1, debug, ovly->vdev, "qbuf id %d addr %p\n",
+		 * buffer->index, buffer->m.userptr); */
+	}
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: qbuf id %d vb %x\n", ovly->id,
+			 buffer->index, (unsigned int)q->bufs[buffer->index]);
+
+	return vb2_qbuf(q, buffer);
+}
+
+static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct vb2_queue *q = &ovly->vbq;
+	int ret = 0;
+
+	if (!ovly->streaming)
+		return -EINVAL;
+
+	mutex_lock(&ovly->lock);
+	if (file->f_flags & O_NONBLOCK)
+		/* Call videobuf_dqbuf for non blocking mode */
+		ret = vb2_dqbuf(q, (struct v4l2_buffer *) b, 1);
+	else
+		/* Call videobuf_dqbuf for  blocking mode */
+		ret = vb2_dqbuf(q, (struct v4l2_buffer *) b, 0);
+	if (!ret)
+		v4l2_dbg(1, debug, ovly->vdev, "ovly %d: dqbuf id %d vb %x\n",
+			ovly->id, b->index, (unsigned int)q->bufs[b->index]);
+	mutex_unlock(&ovly->lock);
+	return ret;
+}
+
+extern void wait_for_vsync(struct pxa168fb_info *fbi, unsigned char param);
+static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct pxa168_overlay *ovly = fh;
+	struct vb2_queue *q = &ovly->vbq;
+	struct mutex *ovly_lock = &ovly->lock;
+	spinlock_t *vbq_lock = &ovly->vbq_lock;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: enter stream on!\n",
+		 ovly->id);
+
+	if (ovly->streaming)
+		return -EBUSY;
+
+	mutex_lock(ovly_lock);
+
+	ret = vb2_streamon(q, i);
+	if (ret < 0)
+		goto stream_on;
+
+	spin_lock_irqsave(vbq_lock, flags);
+	if (list_empty(&ovly->dma_queue)) {
+		ret = -EINVAL;
+		goto out;
+	}
+	/* Get the next frame from the buffer queue */
+	ovly->cur_frm = list_first_entry(&ovly->dma_queue,
+			struct pxa168_buf, list);
+	/* Remove buffer from the buffer queue */
+	list_del(&ovly->cur_frm->list);
+#if 0
+	/* Initialize field_id and started member */
+	ovly->field_id = 0;
+	/* set flag here. Next QBUF will start DMA */
+#endif
+
+	ovly->paddr[0] = *((dma_addr_t *) vb2_plane_cookie
+				(&ovly->cur_frm->vb, 0));
+	if (ovly->hdmi3d)
+		ovly->paddr[1] = *((dma_addr_t *) vb2_plane_cookie
+					(&ovly->cur_frm->vb, 1));
+	/* First save the configuration in ovelray structure */
+	ret = pxa168vid_init(ovly);
+	if (ret)
+		printk(KERN_ERR VOUT_NAME "failed to set overlay ovly\n");
+	/* Enable the pipeline and set the Go bit */
+	ret = pxa168vid_apply_changes(ovly);
+	if (ret)
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+
+	ovly->streaming = 1;
+	dma_ctrl_set(ovly->id, 0, CFG_DMA_ENA_MASK, CFG_DMA_ENA_MASK);
+	pxa688fb_vsmooth_set(ovly->id, 1, vid_vsmooth);
+out:
+	spin_unlock_irqrestore(vbq_lock, flags);
+stream_on:
+	mutex_unlock(ovly_lock);
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: leave stream on!\n",
+		 ovly->id);
+	return ret;
+}
+
+static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct pxa168_overlay *ovly = fh;
+	spinlock_t *vbq_lock = &ovly->vbq_lock;
+	struct mutex *ovly_lock = &ovly->lock;
+	unsigned long flags = 0;
+
+	if (!ovly->streaming)
+		return -EINVAL;
+
+	mutex_lock(ovly_lock);
+	/* We have to hack in clone mode to avoid lock/unlock different ovly. */
+	vb2_streamoff(&ovly->vbq, i);
+
+	spin_lock_irqsave(vbq_lock, flags);
+	ovly->streaming = 0;
+	spin_unlock_irqrestore(vbq_lock, flags);
+	pxa688_vdma_release(ovly->id, 1);
+	pxa688fb_vsmooth_set(ovly->id, 1, 0);
+
+	mutex_unlock(ovly_lock);
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: stream off!\n", ovly->id);
+	return 0;
+}
+
+static int vidioc_s_fbuf(struct file *file, void *fh,
+			 struct v4l2_framebuffer *a)
+{
+	struct pxa168_overlay *ovly = fh;
+	int key_type = COLOR_KEY_GFX_DST;
+	int enable = 0;
+
+	/* Doesn't support the Destination color key
+	   and alpha blending together ?????????????????????????? */
+	if ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY) &&
+	    (a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA))
+		return -EINVAL;
+
+	/*if ((a->flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY)) {
+	   ovly->fbuf.flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;
+	   key_type =  COLOR_KEY_VID_SRC;
+	   } else
+	   ovly->fbuf.flags &= ~V4L2_FBUF_FLAG_SRC_CHROMAKEY;
+	 */
+
+	if ((a->flags & V4L2_FBUF_FLAG_CHROMAKEY)) {
+		ovly->fbuf.flags |= V4L2_FBUF_FLAG_CHROMAKEY;
+		key_type = COLOR_KEY_GFX_DST;
+	} else
+		ovly->fbuf.flags &= ~V4L2_FBUF_FLAG_CHROMAKEY;
+
+	if (a->flags & V4L2_FBUF_FLAG_CHROMAKEY)
+		enable = 1;
+	else
+		enable = 0;
+	ovly->trans_enabled = enable;
+	ovly->trans_key_type = key_type;
+
+	if (a->flags & V4L2_FBUF_FLAG_LOCAL_ALPHA) {
+		ovly->fbuf.flags |= V4L2_FBUF_FLAG_LOCAL_ALPHA;
+		enable = 1;
+	} else {
+		ovly->fbuf.flags &= ~V4L2_FBUF_FLAG_LOCAL_ALPHA;
+		enable = 0;
+	}
+
+	if (a->flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) {
+		ovly->fbuf.flags |= V4L2_FBUF_FLAG_GLOBAL_ALPHA;
+		enable = 1;
+	} else {
+		ovly->fbuf.flags &= ~V4L2_FBUF_FLAG_GLOBAL_ALPHA;
+		enable = 0;
+	}
+
+	/* set par */
+	ovly->alpha_enabled = enable;
+
+	return 0;
+}
+
+static int vidioc_g_fbuf(struct file *file, void *fh,
+			 struct v4l2_framebuffer *a)
+{
+	struct pxa168_overlay *ovly = fh;
+
+	a->flags = 0x0;
+
+	a->capability = V4L2_FBUF_CAP_GLOBAL_ALPHA |
+	    V4L2_FBUF_CAP_LOCAL_ALPHA | V4L2_FBUF_CAP_CHROMAKEY;
+
+	/*if (ovly->trans_key_type == COLOR_KEY_VID_SRC)
+	   a->flags |= V4L2_FBUF_FLAG_SRC_CHROMAKEY;
+	   if (ovly->trans_key_type == COLOR_KEY_GFX_DST)
+	   a->flags = V4L2_FBUF_FLAG_CHROMAKEY;
+
+	   if (ovly->alpha_enabled) */
+	a->flags = ovly->fbuf.flags;
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops vout_ioctl_ops = {
+	.vidioc_querycap = vidioc_querycap,
+	.vidioc_enum_fmt_vid_out = vidioc_enum_fmt_vid_out,
+	.vidioc_enum_fmt_vid_out_mplane = vidioc_enum_fmt_vid_out,
+	.vidioc_try_fmt_vid_out = vidioc_try_fmt_vid_out,
+	.vidioc_try_fmt_vid_out_mplane = vidioc_try_fmt_vid_out_mplane,
+	.vidioc_g_fmt_vid_out = vidioc_g_fmt_vid_out,
+	.vidioc_g_fmt_vid_out_mplane = vidioc_g_fmt_vid_out_mplane,
+	.vidioc_s_fmt_vid_out = vidioc_s_fmt_vid_out_mplane,
+	.vidioc_s_fmt_vid_out_mplane = vidioc_s_fmt_vid_out_mplane,
+	.vidioc_queryctrl = vidioc_queryctrl,
+	.vidioc_g_ctrl = vidioc_g_ctrl,
+	.vidioc_s_fbuf = vidioc_s_fbuf,
+	.vidioc_g_fbuf = vidioc_g_fbuf,
+	.vidioc_s_ctrl = vidioc_s_ctrl,
+	.vidioc_try_fmt_vid_overlay = vidioc_try_fmt_vid_overlay,
+	.vidioc_s_fmt_vid_overlay = vidioc_s_fmt_vid_overlay,
+	.vidioc_enum_fmt_vid_overlay = vidioc_enum_fmt_vid_overlay,
+	.vidioc_g_fmt_vid_overlay = vidioc_g_fmt_vid_overlay,
+	.vidioc_cropcap = vidioc_cropcap,
+	.vidioc_g_crop = vidioc_g_crop,
+	.vidioc_s_crop = vidioc_s_crop,
+	.vidioc_reqbufs = vidioc_reqbufs,
+	.vidioc_querybuf = vidioc_querybuf,
+	.vidioc_qbuf = vidioc_qbuf,
+	.vidioc_dqbuf = vidioc_dqbuf,
+	.vidioc_streamon = vidioc_streamon,
+	.vidioc_streamoff = vidioc_streamoff,
+};
+
+static const struct v4l2_file_operations pxa168_ovly_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = video_ioctl2,
+	.poll = pxa168_poll,
+	.mmap = video_mmap,
+	.open = pxa168_ovly_open,
+	.release = pxa168_ovly_release,
+};
+
+irqreturn_t pxa168_v4l2_isr(int id)
+{
+	struct pxa168_overlay *ovly = v4l2_ovly[id];
+	u32 ret = 0;
+
+	if (!ovly)
+		return IRQ_NONE;
+
+	if (!ovly->streaming) {
+		dma_ctrl_set(ovly->id, 0, CFG_DMA_ENA_MASK, 0);
+		return IRQ_NONE;
+	}
+
+	spin_lock(&ovly->vbq_lock);
+	if (list_empty(&ovly->dma_queue)) {
+		/*v4l2_dbg(2, debug, ovly->vdev, "ovly id: %d\n", id); */
+		goto irq;
+	}
+
+	vb2_buffer_done(&ovly->cur_frm->vb, VB2_BUF_STATE_DONE);
+	ovly->cur_frm = list_first_entry(&ovly->dma_queue,
+			struct pxa168_buf, list);
+
+	list_del(&ovly->cur_frm->list);
+
+	ovly->paddr[0] =
+	 *((dma_addr_t *) vb2_plane_cookie(&ovly->cur_frm->vb, 0));
+	if (ovly->hdmi3d)
+		ovly->paddr[1] =
+		*((dma_addr_t *) vb2_plane_cookie(&ovly->cur_frm->vb, 1));
+
+	ret = pxa168vid_apply_changes(ovly);
+	if (ret)
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+
+irq:
+	spin_unlock(&ovly->vbq_lock);
+
+	v4l2_dbg(1, debug, ovly->vdev, "ovly %d: buf %d is active! "
+		 "paddr[0] 0x%x\n", ovly->id, ovly->cur_frm->vb.v4l2_buf.index,
+		 ovly->paddr[0]);
+
+	return IRQ_HANDLED;
+}
+
+/* Init functions used during driver intitalization */
+/* Initial setup of video_data */
+static int __init pxa168_ovly_setup_video_data(struct pxa168_overlay *ovly)
+{
+	struct v4l2_pix_format *pix;
+	struct video_device *vdev;
+	struct v4l2_control *control;
+	struct lcd_regs *regs = get_regs(ovly->id);
+	unsigned int x;
+
+	/* set the default pix */
+	pix = &ovly->pix;
+
+	/* Set the default picture of QVGA  */
+	pix->width = VID_QVGA_WIDTH;
+	pix->height = VID_QVGA_HEIGHT;
+
+	/* Default pixel format is RGB 5-6-5 */
+	pix->pixelformat = V4L2_PIX_FMT_YUV420;
+	pix->field = V4L2_FIELD_ANY;
+	pix->bytesperline = (pix->width * 3) >> 1;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	pix->colorspace = V4L2_COLORSPACE_JPEG;
+
+	/* We rely on base layer screen size to get the LCD size */
+	x = readl(&regs->screen_size);
+	ovly->fbuf.fmt.height = x >> 16;
+	ovly->fbuf.fmt.width = x & 0xffff;
+
+	/* Set the data structures for the overlay parameters */
+	ovly->win.global_alpha = 255;
+	ovly->fbuf.flags = 0;
+	ovly->fbuf.capability = V4L2_FBUF_CAP_GLOBAL_ALPHA;
+	ovly->win.chromakey = 0;
+	INIT_LIST_HEAD(&ovly->dma_queue);
+
+	pxa168_ovly_new_format(pix, &ovly->fbuf, &ovly->crop, &ovly->win);
+
+	/*Initialize the control variables for
+	   and background color. */
+	control = ovly->control;
+	control[0].value = 0;
+	ovly->control[2].value = 0;
+
+	control[1].id = V4L2_CID_VFLIP;
+	control[1].value = 0;
+
+	/* initialize the video_device struct */
+	vdev = ovly->vdev = video_device_alloc();
+
+	if (!vdev) {
+		printk(KERN_ERR VOUT_NAME ": could not allocate"
+		       " video device struct\n");
+		return -ENOMEM;
+	}
+	vdev->release = video_device_release;
+	vdev->ioctl_ops = &vout_ioctl_ops;
+
+	strlcpy(vdev->name, ovly->name, sizeof(vdev->name));
+	vdev->vfl_type = VFL_TYPE_GRABBER;
+
+	/* need to register for a VID_HARDWARE_* ID in videodev.h */
+	vdev->fops = &pxa168_ovly_fops;
+	mutex_init(&ovly->lock);
+
+	vdev->minor = -1;
+	return 0;
+}
+
+/* Create video out devices and alloc buffer when boot up if needed */
+static int __init pxa168_ovly_create_video_devices(struct pxa168_overlay *ovly)
+{
+	int ret = 0;
+	struct video_device *vdev;
+
+	/* Setup the default configuration for the video devices
+	 */
+	if (pxa168_ovly_setup_video_data(ovly) != 0) {
+		ret = -ENOMEM;
+		goto error1;
+	}
+
+	vdev = ovly->vdev;
+	video_set_drvdata(vdev, ovly);
+
+	/* Register the Video device with V4L2
+	 */
+	if (video_register_device(vdev, VFL_TYPE_GRABBER, ovly->id + 1) < 0) {
+		printk(KERN_ERR VOUT_NAME ": could not register "
+		       "Video for Linux device\n");
+		vdev->minor = -1;
+		ret = -ENODEV;
+		goto error2;
+	}
+
+	/* Configure the overlay structure */
+	ret = pxa168vid_init(ovly);
+	if (ret)
+		printk(KERN_ERR VOUT_NAME "failed to set overlay ovly\n");
+
+	/* Enable the pipeline and set the Go bit */
+	ret = pxa168vid_apply_changes(ovly);
+	if (ret) {
+		printk(KERN_ERR VOUT_NAME "failed to change mode\n");
+		goto error2;
+	} else
+		goto success;
+error2:
+	video_device_release(vdev);
+error1:
+	kfree(ovly);
+	return ret;
+
+success:
+	printk(KERN_INFO VOUT_NAME ": registered and initialized "
+	       "video%d: minor num %d [v4l2]\n", vdev->num, vdev->minor);
+
+	return 0;
+}
+
+static void pxa168_ovly_cleanup_device(struct pxa168_overlay *ovly)
+{
+	struct video_device *vdev;
+
+	if (!ovly)
+		return;
+	vdev = ovly->vdev;
+
+	if (vdev) {
+		if (vdev->minor == -1) {
+			/*
+			 * The device was never registered, so release the
+			 * video_device struct directly.
+			 */
+			video_device_release(vdev);
+		} else {
+			/*
+			 * The unregister function will release the video_device
+			 * struct as well as unregistering it.
+			 */
+			video_unregister_device(vdev);
+		}
+	}
+
+	kfree(ovly);
+}
+
+/* Driver functions */
+static int pxa168_ovly_remove(struct platform_device *pdev)
+{
+	struct pxa168_overlay *ovly = platform_get_drvdata(pdev);
+
+	pxa168_ovly_cleanup_device(ovly);
+
+	/* put_device(ovly); */
+	kfree(ovly);
+	return 0;
+}
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void pxa168_early_suspend(struct early_suspend *h)
+{
+	struct pxa168_overlay *ovly = container_of(h, struct pxa168_overlay,
+						 early_suspend);
+
+	dma_ctrl_set(ovly->id, 0, CFG_DMA_ENA_MASK, 0);
+	return;
+}
+static void pxa168_late_resume(struct early_suspend *h)
+{
+#ifndef CONFIG_ANDROID
+	struct pxa168_overlay *ovly = container_of(h, struct pxa168_overlay,
+						 early_suspend);
+	if (ovly->dma_ctrl0 & CFG_DMA_ENA_MASK)
+		dma_ctrl_set(ovly->id, 0, CFG_DMA_ENA_MASK, CFG_DMA_ENA_MASK);
+#endif
+	return;
+}
+#endif
+
+static int __devinit pxa168_ovly_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct pxa168_overlay *ovly = NULL;
+	struct pxa168fb_mach_info *mi;
+	struct lcd_regs *regs;
+	struct resource *res;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -EINVAL;
+
+	mi = pdev->dev.platform_data;
+	if (mi == NULL)
+		return -EINVAL;
+
+	ovly = kzalloc(sizeof(struct pxa168_overlay), GFP_KERNEL);
+	if (ovly == NULL) {
+		ret = -ENOMEM;
+		return ret;
+	}
+
+	/* get LCD clock information. */
+	ovly->clk = clk_get(&pdev->dev, "LCDCLK");
+
+	ovly->id = pdev->id;
+	ovly->dev = &pdev->dev;
+
+	/*
+	 * Map LCD controller registers.
+	 */
+	ovly->reg_base = ioremap_nocache(res->start, res->end - res->start);
+	if (ovly->reg_base == NULL) {
+		pr_err("pxa168fb_ovly: no enough memory 2!\n");
+		ret = -ENOMEM;
+		goto error0;
+	}
+
+	/* init vdma clock/sram, etc. */
+	lcd_vdma = request_vdma(ovly->id, 1);
+	if (lcd_vdma) {
+		lcd_vdma->dev = ovly->dev;
+		lcd_vdma->reg_base = ovly->reg_base;
+		pxa688_vdma_init(lcd_vdma);
+	} else
+		pr_warn("path %d video layer : request vdma fail\n", ovly->id);
+
+	/*
+	 * Configure default register values.
+	 */
+	regs = get_regs(ovly->id);
+	writel(0, &regs->v_y1);
+	writel(0, &regs->v_u1);
+	writel(0, &regs->v_v1);
+	writel(0, &regs->v_start);
+	dma_ctrl_set(ovly->id, 0, CFG_DMA_ENA_MASK, 0);
+
+	/*
+	 * Get IRQ number.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL)
+		return -EINVAL;
+	ovly->name = mi->id;
+
+	v4l2_ovly[pdev->id] = ovly;
+
+	/* register v4l2 interface */
+	ret = pxa168_ovly_create_video_devices(ovly);
+	if (ret)
+		goto error0;
+
+	v4l2_dbg(1, debug, ovly->vdev, "v4l2_ovly %d probed\n", ovly->id);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/* let video layer suspend first and resume late than graphic layer */
+	ovly->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB -
+					(ovly->id + 3);
+	ovly->early_suspend.suspend = pxa168_early_suspend;
+	ovly->early_suspend.resume = pxa168_late_resume;
+	register_early_suspend(&ovly->early_suspend);
+#endif
+
+	return 0;
+
+error0:
+	return ret;
+}
+
+static const struct platform_device_id mmpv4l2_id_table[] = {
+	{"pxa168-v4l2_ovly", 0},
+	{"pxa910-v4l2_ovly", 1},
+};
+
+static struct platform_driver pxa168_ovly_driver = {
+	.driver = {
+		   .name = VOUT_NAME,
+		   },
+	.probe = pxa168_ovly_probe,
+	.remove = pxa168_ovly_remove,
+	.id_table = mmpv4l2_id_table,
+};
+
+static int __init pxa168_ovly_init(void)
+{
+
+	if (platform_driver_register(&pxa168_ovly_driver) != 0) {
+		printk(KERN_ERR VOUT_NAME
+		       ": could not register PXA168 V4L2 driver\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static void pxa168_ovly_cleanup(void)
+{
+	platform_driver_unregister(&pxa168_ovly_driver);
+}
+
+module_init(pxa168_ovly_init);
+module_exit(pxa168_ovly_cleanup);
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 2d1811a..9a0f4c7 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1907,14 +1907,32 @@ config FB_68328
 
 config FB_PXA168
 	tristate "PXA168/910 LCD framebuffer support"
-	depends on FB && (CPU_PXA168 || CPU_PXA910)
+	depends on FB && (CPU_PXA168 || CPU_PXA910 ||CPU_MMP3)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
+	select PXA168_V4L2_OVERLAY
+        select PXA688_PHY if (CPU_MMP3 || CPU_MMP2 || CPU_PXA988)
 	---help---
 	  Frame buffer driver for the built-in LCD controller in the Marvell
 	  MMP processor.
 
+config PXA688_PHY
+        bool "MMP2/MMP3 LCD DSI support"
+        depends on FB && (CPU_MMP3 || CPU_MMP2 || CPU_PXA988)
+
+config PXA688_CMU
+	tristate "MMP2/MMP3 CMU support"
+	depends on FB && (CPU_MMP3 || CPU_MMP2)
+	help
+	  Say Y here if you want to enable CMU for MMP2 & MMP3
+
+config PXA688_VDMA
+	tristate "MMP VDMA support"
+	depends on FB && (CPU_MMP2 || CPU_MMP3)
+	help
+	  Say Y here if you want to enable VDMA for MMP2 and MMP3
+
 config FB_PXA
 	tristate "PXA LCD framebuffer support"
 	depends on FB && ARCH_PXA
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index e3b14b0..2b9d928 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -106,7 +106,11 @@ obj-$(CONFIG_FB_GBE)              += gbefb.o
 obj-$(CONFIG_FB_CIRRUS)		  += cirrusfb.o
 obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o
 obj-$(CONFIG_FB_PXA)		  += pxafb.o
-obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o
+obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o pxa168fb_common.o
+obj-$(CONFIG_PXA688_PHY)	  += pxa688_phy.o
+obj-$(CONFIG_PXA688_CMU)	  += pxa688_cmu.o
+obj-$(CONFIG_PXA688_VDMA)	  += pxa688_vdma.o
+obj-$(CONFIG_PXA688_MISC)	  += pxa688_misc.o
 obj-$(CONFIG_FB_DB9000)		  += db9000fb.o
 obj-$(CONFIG_PXA3XX_GCU)	  += pxa3xx-gcu.o
 obj-$(CONFIG_FB_W100)		  += w100fb.o
diff --git a/drivers/video/pxa168fb.c b/drivers/video/pxa168fb.c
index f146089..792365e 100644
--- a/drivers/video/pxa168fb.c
+++ b/drivers/video/pxa168fb.c
@@ -4,8 +4,10 @@
  *  Copyright (C) 2008 Marvell International Ltd.
  *  All rights reserved.
  *
- *  2009-02-16  adapted from original version for PXA168/910
+ *  2009-02-16  adapted from original version for PXA168
+ *		Green Wan <gwan@marvell.com>
  *              Jun Nie <njun@marvell.com>
+ *		Kevin Liu <kliu5@marvell.com>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License. See the file COPYING in the main directory of this archive for
@@ -13,169 +15,401 @@
  */
 
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
+#include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/interrupt.h>
+#include <linux/console.h>
 #include <linux/slab.h>
-#include <linux/fb.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/io.h>
 #include <linux/ioport.h>
-#include <linux/platform_device.h>
+#include <linux/cpufreq.h>
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#include <linux/fb.h>
 #include <linux/uaccess.h>
-#include <video/pxa168fb.h>
+#include <linux/proc_fs.h>
+#include <linux/platform_device.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <plat/pm.h>
+#include "pxa168fb_common.h"
+#include <asm/cacheflush.h>
+
+#ifdef CONFIG_CPU_MMP2
+#include <mach/mmp2_pm.h>
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+
+/* interrupt timestamp collection to get:
+ * 0. ITC_NONE		don't enable any timestamp collection
+ * 1. ITC_INTERVAL	collect timestamps each time enter lcd interrupt
+ *			service, normally only display done interrupt is
+ *			enabled, should be same as LCD refresh period;
+ *			while test results shows it takes longer time
+ * 2. ITC_VSYNC		collect timestamp for display done interrupt and
+ *			vsync interrupt
+ * 3. ITC_GFX_DONE	collect timestamp for display done interrupt and
+ *			graphics layer frame done(dma finish) interrupt
+ * 4. ITC_VID_DONE	collect timestamp for display done interrupt and
+ *			video layer frame done(dma finish) interrupt
+ * 5. ITC_HANDLER	collect timestamp for display done interrupt and
+ *			main handler finish time
+ * usage:
+ * "echo x > /sys/devices/platform/pxa168-fb.0/itc" to enable/disable
+ * "cat /sys/devices/platform/pxa168-fb.0/itc" to get timestamps
+ *
+ * note: only panel path timestamp collection is supported now
+ */
+#define ITC_MAX_NUM		32
+#define ITC_NONE		(irqtm_check == 0)
+#define ITC_INTERVAL		(irqtm_check == 1)
+#define ITC_VSYNC		(irqtm_check == 2)
+#define ITC_GFX_DONE		(irqtm_check == 3)
+#define ITC_VID_DONE		(irqtm_check == 4)
+#define ITC_HANDLER		(irqtm_check == 5)
+#define gettime(val, count, update) do {			\
+	count %= ITC_MAX_NUM;					\
+	do_gettimeofday(&val[update ? count++ : count]);	\
+} while (0)
+static int ct1, ct2, irqtm_check;
+static struct timeval t0, t1[ITC_MAX_NUM], t2[ITC_MAX_NUM];
+#ifdef CONFIG_CPU_MMP3
+static atomic_t framedone = ATOMIC_INIT(0);
+#endif
+
+/* interrupt number collection to get real frame rate */
+#define VSYNC_CHECK_TIME	(10 * HZ)
+static int vsync_check;
+static int irq_count;
+static int vsync_count;
+static int dispd_count;
+static int f0_count;
+static int f1_count;
+static int vf0_count;
+static int vf1_count;
+static struct timer_list vsync_timer;
+#ifdef CONFIG_CPU_MMP3
+static int enable_3d_flg = 0;
+#endif
+
+static void vsync_check_timer(unsigned long data)
+{
+	int id = DBG_VSYNC_PATH;
+
+	/* disable count interrupts */
+	irq_mask_set(id, vsync_imask(id) | gf0_imask(id) |
+		gf1_imask(id) | vf0_imask(id) | vf1_imask(id), 0);
+
+	vsync_check = 0;
+	del_timer(&vsync_timer);
+	pr_info("fbi %d: irq_count %d\n", id, irq_count);
+	pr_info("\tvsync_count %d\n",  vsync_count);
+	pr_info("\tdispd_count %d\n",  dispd_count);
+	pr_info("\tf0_count %d\n", f0_count);
+	pr_info("\tf1_count %d\n", f1_count);
+	pr_info("\tvf0_count %d\n", vf0_count);
+	pr_info("\tvf1_count %d\n", vf1_count);
+}
 
-#include "pxa168fb.h"
+void vsync_check_count()
+{
+	int path = DBG_VSYNC_PATH;
+	int mask = vsync_imask(path) | gf0_imask(path) | gf1_imask(path)
+		| vf0_imask(path) | vf1_imask(path);
+
+	if (vsync_check) {
+		pr_alert("count vsync ongoing, try again after 10s\n");
+		return;
+	}
+	/* enable count interrupts */
+	irq_mask_set(path, mask, mask);
+	irq_status_clear(path, mask);
+
+	/* clear counts */
+	vsync_count = dispd_count = irq_count = 0;
+	f0_count = f1_count = vf0_count = vf1_count = 0;
+	ct1 = 0; memset(t1, 0, sizeof(t1));
+	ct2 = 0; memset(t2, 0, sizeof(t2));
+
+	/* trigger vsync check */
+	vsync_check = 1;
+	init_timer(&vsync_timer);
+	vsync_timer.function = vsync_check_timer;
+	mod_timer(&vsync_timer, jiffies + 10*HZ);
+}
 
 #define DEFAULT_REFRESH		60	/* Hz */
 
-static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
+static unsigned int max_fb_size = 0;
+static unsigned int fb_size_from_cmd = 0;
+
+/* Globals:
+ * fb_share mode: TV path graphics share same frame buffer with panel path
+ */
+int fb_share = 0;
+struct fbi_info gfx_info;
+int gfx_udflow_count = 0;
+int vid_udflow_count = 0;
+int axi_err_count = 0;
+int debug_flag = 0;
+
+struct lcd_regs *get_regs(int id)
 {
-	/*
-	 * Pseudocolor mode?
-	 */
-	if (var->bits_per_pixel == 8)
-		return PIX_FMT_PSEUDOCOLOR;
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	struct lcd_regs *regs;
 
-	/*
-	 * Check for 565/1555.
-	 */
-	if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
-	    var->green.length <= 6 && var->blue.length <= 5) {
-		if (var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB565;
-			else
-				return PIX_FMT_BGR565;
-		}
+	if (!fbi)
+		return NULL;
 
-		if (var->transp.length == 1 && var->green.length <= 5) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB1555;
-			else
-				return PIX_FMT_BGR1555;
-		}
+	regs = (struct lcd_regs *)((unsigned)fbi->reg_base);
 
-		/* fall through */
-	}
+	if (id == 0)
+		regs = (struct lcd_regs *)((unsigned)fbi->reg_base + 0xc0);
+	if (id == 2)
+		regs = (struct lcd_regs *)((unsigned)fbi->reg_base + 0x200);
 
-	/*
-	 * Check for 888/A888.
-	 */
-	if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
-	    var->green.length <= 8 && var->blue.length <= 8) {
-		if (var->bits_per_pixel == 24 && var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888PACK;
-			else
-				return PIX_FMT_BGR888PACK;
-		}
+	return regs;
+}
+u32 dma_ctrl_read(int id, int ctrl1)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
 
-		if (var->bits_per_pixel == 32 && var->transp.length == 8) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGBA888;
-			else
-				return PIX_FMT_BGRA888;
-		} else {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888UNPACK;
-			else
-				return PIX_FMT_BGR888UNPACK;
-		}
+	return __raw_readl(reg);
+}
 
-		/* fall through */
-	}
+void dma_ctrl_write(int id, int ctrl1, u32 value)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
 
-	return -EINVAL;
+	__raw_writel(value, reg);
 }
 
-static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+void dma_ctrl_set(int id, int ctrl1, u32 mask, u32 value)
 {
-	switch (pix_fmt) {
-	case PIX_FMT_RGB565:
-		var->bits_per_pixel = 16;
-		var->red.offset = 11;    var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 6;
-		var->blue.offset = 0;    var->blue.length = 5;
-		var->transp.offset = 0;  var->transp.length = 0;
-		break;
-	case PIX_FMT_BGR565:
-		var->bits_per_pixel = 16;
-		var->red.offset = 0;     var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 6;
-		var->blue.offset = 11;   var->blue.length = 5;
-		var->transp.offset = 0;  var->transp.length = 0;
-		break;
-	case PIX_FMT_RGB1555:
-		var->bits_per_pixel = 16;
-		var->red.offset = 10;    var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 5;
-		var->blue.offset = 0;    var->blue.length = 5;
-		var->transp.offset = 15; var->transp.length = 1;
-		break;
-	case PIX_FMT_BGR1555:
-		var->bits_per_pixel = 16;
-		var->red.offset = 0;     var->red.length = 5;
-		var->green.offset = 5;   var->green.length = 5;
-		var->blue.offset = 10;   var->blue.length = 5;
-		var->transp.offset = 15; var->transp.length = 1;
-		break;
-	case PIX_FMT_RGB888PACK:
-		var->bits_per_pixel = 24;
-		var->red.offset = 16;    var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 reg = (u32)fbi->reg_base + dma_ctrl(ctrl1, id);
+	u32 tmp1, tmp2;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+	tmp2 &= ~mask;
+	tmp2 |= value;
+	if (tmp1 != tmp2)
+		__raw_writel(tmp2, reg);
+}
+
+void irq_mask_set(int id, u32 mask, u32 val)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 temp = readl(fbi->reg_base + SPU_IRQ_ENA);
+
+	temp &= ~mask; temp |= val;
+	writel(temp, fbi->reg_base + SPU_IRQ_ENA);
+}
+
+void irq_status_clear(int id, u32 mask)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	writel(mi->isr_clear_mask & (~mask), fbi->reg_base + SPU_IRQ_ISR);
+}
+
+u32 clk_reg(int id, u32 type)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 offset = 0;
+
+	switch (type) {
+	case clk_sclk:
+		offset = id ? (id & 1 ? LCD_TCLK_DIV : LCD_PN2_SCLK_DIV)
+				: LCD_CFG_SCLK_DIV;
 		break;
-	case PIX_FMT_BGR888PACK:
-		var->bits_per_pixel = 24;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 16;   var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	case clk_lvds_rd:
+		offset = LCD_LVDS_SCLK_DIV_RD;
 		break;
-	case PIX_FMT_RGBA888:
-		var->bits_per_pixel = 32;
-		var->red.offset = 16;    var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 24; var->transp.length = 8;
+	case clk_lvds_wr:
+		offset = LCD_LVDS_SCLK_DIV_WR;
 		break;
-	case PIX_FMT_BGRA888:
-		var->bits_per_pixel = 32;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 8;   var->green.length = 8;
-		var->blue.offset = 16;   var->blue.length = 8;
-		var->transp.offset = 24; var->transp.length = 8;
+	case clk_tclk:
+		if (id == 1)
+			offset = LCD_TCLK_DIV;
+		else if (id == 2)
+			offset = LCD_PN2_TCLK_DIV;
 		break;
-	case PIX_FMT_PSEUDOCOLOR:
-		var->bits_per_pixel = 8;
-		var->red.offset = 0;     var->red.length = 8;
-		var->green.offset = 0;   var->green.length = 8;
-		var->blue.offset = 0;    var->blue.length = 8;
-		var->transp.offset = 0;  var->transp.length = 0;
+	default:
+		pr_err("%s path %d type %x not found\n", __func__, id, type);
 		break;
 	}
+
+	if (offset)
+		return (u32)fbi->reg_base + offset;
+
+	return 0;
 }
 
-static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
-		     struct fb_videomode *mode, int pix_fmt, int ystretch)
+int lcd_clk_get(int id, u32 type)
+{
+	u32 reg = clk_reg(id, type), val;
+
+	if (!reg)
+		return 0;
+
+	val = __raw_readl(reg);
+	pr_debug("%s path %d type %d: 0x%x (@ 0x%x)\n", __func__,
+		id, type, val, clk_reg(id, type));
+	return val;
+}
+
+void lcd_clk_set(int id, u32 type, u32 mask, u32 val)
 {
-	struct fb_info *info = fbi->info;
+	u32 reg = clk_reg(id, type), tmp1, tmp2;
+
+	if (!reg)
+		return;
+
+	tmp1 = tmp2 = __raw_readl(reg);
+	tmp2 &= ~mask;
+	tmp2 |= val;
+	if (tmp1 != tmp2)
+		__raw_writel(tmp2, reg);
 
+	pr_debug("%s type %d mask %x val %x: 0x%x -> 0x%x (@ 0x%x)\n",
+		__func__, type, mask, val, tmp1, tmp2,
+		clk_reg(id, type) & 0xfff);
+}
+
+int pxa168fb_spi_send(struct pxa168fb_info *fbi, void *value,
+		int count, unsigned int spi_gpio_cs)
+{
+	u32 x, spi_byte_len;
+	u8 *cmd = (u8 *)value;
+	int i, err, isr, iopad;
+	unsigned int timeout = 0;
+
+	if (spi_gpio_cs != -1) {
+		err = gpio_request(spi_gpio_cs, "LCD_SPI_CS");
+		if (err) {
+			pr_err("failed to request GPIO for LCD CS\n");
+			return -1;
+		}
+		gpio_direction_output(spi_gpio_cs, 1);
+	}
+	/* get spi data size */
+	spi_byte_len = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+	spi_byte_len = (spi_byte_len >> 8) & 0xff;
+	/* It should be (spi_byte_len + 7) >> 3, but spi controller
+	 * request set one less than bit length */
+	spi_byte_len = (spi_byte_len + 8) >> 3;
+	/* spi command provided by platform should be 1, 2, or 4 byte aligned */
+	if (spi_byte_len == 3)
+		spi_byte_len = 4;
+
+	/*After set mode1 it need a time to pull up the spi singals,
+	 * or it would cause the wrong waveform when send spi command,
+	 * especially on pxa910h*/
+	iopad = readl(fbi->reg_base + SPU_IOPAD_CONTROL);
+	if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI)
+		writel(PIN_MODE_DUMB_18_SPI |
+			(iopad & ~CFG_IOPADMODE_MASK),
+			fbi->reg_base + SPU_IOPAD_CONTROL);
+	udelay(20);
+
+	for (i = 0; i < count; i++) {
+		if (spi_gpio_cs != -1)
+			gpio_direction_output(spi_gpio_cs, 0);
+
+		irq_status_clear(fbi->id, SPI_IRQ_MASK);
+
+		switch (spi_byte_len) {
+		case 1:
+			writel(*cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 2:
+			writel(*(u16 *)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 4:
+			writel(*(u32 *)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		default:
+			pr_err("Wrong spi bit length\n");
+		}
+		cmd += spi_byte_len;
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x |= 0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+		timeout = 0;
+		while (!(isr & SPI_IRQ_ENA_MASK)) {
+			udelay(100);
+			isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+			if (timeout++ > 100) {
+				pr_err("SPI IRQ may miss, just skip and send "
+				"the following command, count %d!\n", i);
+				break;
+			}
+		}
+		irq_status_clear(fbi->id, SPI_IRQ_MASK);
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x &= ~0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		if (spi_gpio_cs != -1)
+			gpio_direction_output(spi_gpio_cs, 1);
+	}
+
+	if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI)
+		writel(iopad, fbi->reg_base + SPU_IOPAD_CONTROL);
+
+	if (spi_gpio_cs != -1)
+		gpio_free(spi_gpio_cs);
+	return 0;
+}
+
+static int pxa168fb_power(struct pxa168fb_info *fbi,
+		struct pxa168fb_mach_info *mi, int on)
+{
+	int ret = 0;
+	pr_debug("fbi->active %d on %d\n", fbi->active, on);
+	if ((mi->spi_ctrl != -1) && (mi->spi_ctrl & CFG_SPI_ENA_MASK))
+		writel(mi->spi_ctrl, fbi->reg_base + LCD_SPU_SPI_CTRL);
+
+	if ((mi->pxa168fb_lcd_power) && \
+		((fbi->active && !on) || (!fbi->active && on)))
+		ret = mi->pxa168fb_lcd_power(fbi, mi->spi_gpio_cs,
+					mi->spi_gpio_reset, on);
+
+	if ((mi->spi_ctrl != -1) && (mi->spi_ctrl & CFG_SPI_ENA_MASK))
+		writel(mi->spi_ctrl & ~CFG_SPI_ENA_MASK,
+			fbi->reg_base + LCD_SPU_SPI_CTRL);
+	return ret;
+}
+
+static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
+		     const struct fb_videomode *mode, int pix_fmt, int ystretch)
+{
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
 	set_pix_fmt(var, pix_fmt);
 
 	var->xres = mode->xres;
 	var->yres = mode->yres;
 	var->xres_virtual = max(var->xres, var->xres_virtual);
-	if (ystretch)
-		var->yres_virtual = info->fix.smem_len /
-			(var->xres_virtual * (var->bits_per_pixel >> 3));
+	if (ystretch && !fb_share)
+#if defined(CONFIG_MACH_QSEVEN) && !defined(CONFIG_ANDROID)
+		/* removed *2 for qseven X window */
+		var->yres_virtual = var->yres;
+#else
+		var->yres_virtual = var->yres * 2;
+#endif
 	else
 		var->yres_virtual = max(var->yres, var->yres_virtual);
 	var->grayscale = 0;
@@ -192,47 +426,154 @@ static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
 	var->rotate = FB_ROTATE_UR;
 }
 
-static int pxa168fb_check_var(struct fb_var_screeninfo *var,
-			      struct fb_info *info)
+#define     DSI1_BITCLK(div)                   ((div)<<8)
+#define     DSI1_BITCLK_DIV_MASK               0x00000F00
+#define     CLK_INT_DIV(div)                   (div)
+#define     CLK_INT_DIV_MASK                   0x000000FF
+static void calculate_dsi_clk(struct pxa168fb_info *fbi)
 {
-	struct pxa168fb_info *fbi = info->par;
-	int pix_fmt;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32 pclk2bclk_rate, byteclk, bitclk, pclk,
 
-	/*
-	 * Determine which pixel format we're going to use.
-	 */
-	pix_fmt = determine_best_pix_fmt(var);
-	if (pix_fmt < 0)
-		return pix_fmt;
-	set_pix_fmt(var, pix_fmt);
-	fbi->pix_fmt = pix_fmt;
+	pclk_div, bitclk_div = 1;
+	u64 div_result;
+
+	if (!di)
+		return;
+	if (!var->pixclock) {
+		pr_err("Input refresh or pixclock is wrong.\n");
+		return;
+	}
 
 	/*
-	 * Basic geometry sanity checks.
-	 */
-	if (var->xoffset + var->xres > var->xres_virtual)
-		return -EINVAL;
-	if (var->yoffset + var->yres > var->yres_virtual)
-		return -EINVAL;
-	if (var->xres + var->right_margin +
-	    var->hsync_len + var->left_margin > 2048)
-		return -EINVAL;
-	if (var->yres + var->lower_margin +
-	    var->vsync_len + var->upper_margin > 2048)
-		return -EINVAL;
+	* When DSI is used to refresh panel, the timing configuration should
+	* follow the rules below:
+	* 1.Because Async fifo exists between the pixel clock and byte clock
+	*   domain, so there is no strict ratio requirement between pix_clk
+	*   and byte_clk, we just need to meet the following inequation to
+	*   promise the data supply from LCD controller:
+	*   pix_clk * (nbytes/pixel) >= byte_clk * lane_num
+	*   (nbyte/pixel: the real byte in DSI transmission)
+	*   a)16-bit format n = 2; b) 18-bit packed format n = 18/8 = 9/4;
+	*   c)18-bit unpacked format  n=3; d)24-bit format  n=3;
+	*   if lane_num = 1 or 2, we can configure pix_clk/byte_clk = 1:1 >
+	*   lane_num/nbytes/pixel
+	*   if lane_num = 3 or 4, we can configure pix_clk/byte_clk = 2:1 >
+	*   lane_num/nbytes/pixel
+	* 2.The horizontal sync for LCD is synchronized from DSI,
+	*    so the refresh rate calculation should base on the
+	*    configuration of DSI.
+	*    byte_clk = (h_total * nbytes/pixel) * v_total * fps / lane_num;
+	*/
 
+	div_result = 1000000000000ll;
+	do_div(div_result, var->pixclock);
+	pclk = (u32)div_result;
+	pclk2bclk_rate = (di->lanes > 2) ? 2 : 1;
+	byteclk = pclk * (di->bpp >> 3) / di->lanes;
+	bitclk = byteclk << 3;
+
+	/* The minimum of DSI pll is 150MHz */
+	if (bitclk < 150000000)
+		bitclk_div = 150000000 / bitclk + 1;
+
+	fbi->sclk_src = bitclk * bitclk_div;
 	/*
-	 * Check size of framebuffer.
+	 * mi->sclk_src = pclk * pclk_div;
+	 * pclk / bitclk  = pclk / (8 * byteclk) = pclk2bclk_rate / 8;
+	 * pclk_div / bitclk_div = 8 / pclk2bclk_rate;
 	 */
-	if (var->xres_virtual * var->yres_virtual *
-	    (var->bits_per_pixel >> 3) > info->fix.smem_len)
-		return -EINVAL;
+	pclk_div = (bitclk_div << 3) / pclk2bclk_rate;
+
+	fbi->sclk_div &= ~(DSI1_BITCLK_DIV_MASK | CLK_INT_DIV_MASK);
+	fbi->sclk_div = 0xe0000000 |  DSI1_BITCLK(bitclk_div) |
+							CLK_INT_DIV(pclk_div);
+}
+static void calculate_lvds_clk(struct pxa168fb_info *fbi)
+{
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	u32 pclk, div, calc_div, calc_clk, calc_clk1;
+	int use_pll1;
+	u64 div_result;
+
+	if (!var->pixclock) {
+		pr_err("Input refresh or pixclock is wrong.\n");
+	return;
+	}
+
+	div_result = 1000000000000ll;
+	do_div(div_result, var->pixclock);
+	pclk = (u32)div_result;
+
+	calc_div = 800000000 / pclk;
+	calc_clk = 800000000 / calc_div;
+	pr_info("Required pixclk is %u\n", pclk);
+
+	if (pclk < (calc_clk - 10000000)) {
+		use_pll1 = 0;
+		pr_info("Using pll2 for LCD Controller\n");
+	} else {
+		use_pll1 = 1;
+		pr_info("Using pll1 for LCD Controller\n");
+	}
+
+	/* use pll1 by default
+	* we could set a more flexible clocking options by selecting pll3
+	* or pll2 in else loops, right now sticking it to pll1 for qseven
+	*/
+#if defined(CONFIG_MACH_QSEVEN_0)
+	use_pll1 = 1;
+#endif
+
+	if (use_pll1) {
+		/* src clock is 800MHz */
+		div = 800000000 / pclk;
+		calc_clk = 800000000 / div;
+		calc_clk1 = 800000000 / (div + 1);
+		if ((calc_clk - pclk) < (calc_clk1 - pclk))
+			pr_info("calculated clock final pll1 %u\n", calc_clk);
+		else {
+			pr_info("calculated clock final pll1 %u\n", calc_clk1);
+			div++;
+		}
+		fbi->sclk_src = 800000000;
+		fbi->sclk_div = 0x20000000 | div;
+	} else {
+		div = 1200000000 / pclk;
+		calc_clk = 1200000000 / div;
+		calc_clk1 = 1200000000 / (div + 1);
+		if ((calc_clk - pclk) < (calc_clk1 - pclk))
+			pr_info("calculated clock final pll2 %u\n", calc_clk);
+		else {
+			pr_info("calculated clock final pll2 %u\n", calc_clk1);
+			div++;
+		}
+
+		fbi->sclk_src = 1200000000;
+		fbi->sclk_div = 0x20000000 | div;
+	}
+
+	pr_info("\n%s sclk_src %d sclk_div 0x%x\n", __func__,
+	fbi->sclk_src, fbi->sclk_div);
 
-	return 0;
+}
+
+static void calculate_lcd_sclk(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+		calculate_dsi_clk(fbi);
+	else if (mi->phy_type & LVDS)
+		calculate_lvds_clk(fbi);
+	else
+		return;
 }
 
 /*
- * The hardware clock divider has an integer and a fractional
+ The hardware clock divider has an integer and a fractional
  * stage:
  *
  *	clk2 = clk_in / integer_divider
@@ -241,364 +582,1424 @@ static int pxa168fb_check_var(struct fb_var_screeninfo *var,
  * Calculate integer and fractional divider for given clk_in
  * and clk_out.
  */
-static void set_clock_divider(struct pxa168fb_info *fbi,
-			      const struct fb_videomode *m)
+static void set_clock_divider(struct pxa168fb_info *fbi)
 {
-	int divider_int;
-	int needed_pixclk;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	u32 divider_int, needed_pixclk, val, x = 0;
 	u64 div_result;
-	u32 x = 0;
 
-	/*
-	 * Notice: The field pixclock is used by linux fb
+	if (!fbi->id) {
+		calculate_lcd_sclk(fbi);
+		clk_disable(fbi->clk);
+		clk_set_rate(fbi->clk, fbi->sclk_src);
+		clk_enable(fbi->clk);
+	} else
+		fbi->sclk_div = mi->sclk_div;
+
+	/* check whether divider is fixed by platform */
+	if (fbi->sclk_div) {
+		val = fbi->sclk_div;
+
+		/*for 480i and 576i, pixel clock should be half of
+		 * the spec value because of pixel repetition */
+		if ((var->yres == 480 || var->yres == 576) &&
+			(var->vmode == FB_VMODE_INTERLACED)) {
+			val &= ~0xf;
+			val |= (mi->sclk_div & 0xf) << 1;
+		}
+
+		/* for lcd controller */
+		lcd_clk_set(fbi->id, clk_sclk, 0xfffff0ff, val & (~0xf00));
+
+		/* FIXME: for dsi/lvds clock */
+		if (mi->phy_type & (DSI | DSI2DPI)) {
+			if (di->id == 1)
+				lcd_clk_set(0, clk_sclk, 0xf00, val & 0xf00);
+			else if (di->id == 2) {
+				/* LCD_TCLK_DIV 0x9c: (11:8) for DSI2 */
+				lcd_clk_set(1, clk_sclk, 0xf00, val & 0xf00);
+				/* LCD_PN2_SCLK_DIV 0x1ec: (31:28) (7:0) for DSI2 */
+				lcd_clk_set(2, clk_sclk, 0xfffff0ff, val & (~0xf00));
+			}
+		} else if (mi->phy_type & LVDS) {
+			/* for lcd controller, select LVDS clk as clk source */
+			lcd_clk_set(fbi->id, clk_sclk, 0xffffffff, 0x1001);
+			lcd_clk_set(fbi->id, clk_lvds_wr, 0xffffffff, val);
+		}
+
+		if (!var->pixclock) {
+			divider_int = mi->sclk_div & CLK_INT_DIV_MASK;
+			if (!divider_int)
+				divider_int = 1;
+
+			if (!clk_get_rate(fbi->clk)) {
+				pr_err("%s: fbi->clk get rate null\n",
+						__func__);
+				return;
+			}
+
+			x = clk_get_rate(fbi->clk) / divider_int / 1000;
+			var->pixclock = 1000000000 / x;
+			pr_debug("%s pixclock %d x %d divider_int %d\n",
+				__func__, var->pixclock, x, divider_int);
+		}
+		x = var->xres + var->left_margin + var->hsync_len +
+			var->right_margin;
+		fbi->frm_usec = var->pixclock * (var->yres + var->upper_margin
+			+ var->vsync_len + var->lower_margin) / 1000 * x / 1000;
+		return;
+	}
+
+	/* Notice: The field pixclock is used by linux fb
 	 * is in pixel second. E.g. struct fb_videomode &
 	 * struct fb_var_screeninfo
 	 */
 
-	/*
-	 * Check input values.
-	 */
-	if (!m || !m->pixclock || !m->refresh) {
-		dev_err(fbi->dev, "Input refresh or pixclock is wrong.\n");
+	/* Check input values */
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+	if (!var->pixclock) {
+		pr_err("Input refresh or pixclock is wrong.\n");
 		return;
 	}
 
-	/*
-	 * Using PLL/AXI clock.
-	 */
-	x = 0x80000000;
+	/* Using PLL/AXI clock. */
+	x = 0x40000000;
 
-	/*
-	 * Calc divider according to refresh rate.
-	 */
+	/* Calc divider according to refresh rate */
 	div_result = 1000000000000ll;
-	do_div(div_result, m->pixclock);
+	do_div(div_result, var->pixclock);
 	needed_pixclk = (u32)div_result;
 
 	divider_int = clk_get_rate(fbi->clk) / needed_pixclk;
 
 	/* check whether divisor is too small. */
 	if (divider_int < 2) {
-		dev_warn(fbi->dev, "Warning: clock source is too slow."
-				"Try smaller resolution\n");
+		pr_warning("Warning: clock source is too slow."
+				 "Try smaller resolution\n");
 		divider_int = 2;
 	}
 
-	/*
-	 * Set setting to reg.
-	 */
+	/* Set setting to reg */
 	x |= divider_int;
-	writel(x, fbi->reg_base + LCD_CFG_SCLK_DIV);
+	if (fbi->id != 1)
+		lcd_clk_set(fbi->id, clk_sclk, CLK_INT_DIV_MASK, x);
+}
+
+void enable_graphic_layer(int id)
+{
+	int val;
+
+	val = check_modex_active(gfx_info.fbi[id]);
+	if (!(dma_ctrl_read(id, 0) & CFG_GRA_ENA_MASK)) {
+		dma_ctrl_set(id, 0, CFG_GRA_ENA_MASK, CFG_GRA_ENA(val));
+	}
+}
+
+static void set_dumb_panel_control(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	u32 x;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	/* Preserve enable flag */
+	x = readl(fbi->reg_base + intf_ctrl(fbi->id)) & 0x00000001;
+	x |= (fbi->is_blanked ? 0x7 : mi->dumb_mode) << 28;
+	if (fbi->id == 1) {
+		/* enable AXI urgent flag and vblank(for 3d formater) */
+		x |= (0xff << 16) | TV_VBLNK_VALID_EN;
+	} else {
+		x |= mi->gpio_output_data << 20;
+		x |= mi->gpio_output_mask << 12;
+	}
+	x |= mi->panel_rgb_reverse_lanes ? 0x00000080 : 0;
+	x |= mi->invert_composite_blank ? 0x00000040 : 0;
+	x |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;
+	x |= mi->invert_pix_val_ena ? 0x00000010 : 0;
+	x |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;
+	x |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;
+	x |= mi->invert_pixclock ? 0x00000002 : 0;
+	x |= 0x1;
+	writel(x, fbi->reg_base + intf_ctrl(fbi->id));	/* FIXME */
+}
+
+static void set_tv_interlace(void)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[1];
+	struct fb_info *info = fbi->fb_info;
+	struct fb_var_screeninfo *v = &info->var;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	int x, y, yres, interlaced = 0, vsync_ctrl;
+	static int vdma_enabled, vdma_layer;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	if (v->vmode & FB_VMODE_INTERLACED) {
+		/* enable interlaced mode */
+		interlaced = CFG_TV_INTERLACE_EN | CFG_TV_NIB;
+
+		x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
+
+		/* interlaced mode, recalculate vertical pixels */
+		yres = v->yres >> 1;
+		y = yres + v->lower_margin + v->vsync_len + v->upper_margin;
+
+		/* even field */
+		writel(((y + 1) << 16) | yres,
+			fbi->reg_base + LCD_TV_V_H_TOTAL_FLD);
+		writel(((v->upper_margin) << 16) | (v->lower_margin),
+			fbi->reg_base + LCD_TV_V_PORCH_FLD);
+		vsync_ctrl = (x >> 1) - v->left_margin - v->hsync_len;
+		writel(vsync_ctrl << 16 | vsync_ctrl,
+			fbi->reg_base + LCD_TV_SEPXLCNT_FLD);
+
+		/* odd field */
+		writel((yres << 16) | v->xres, &regs->screen_active);
+		writel((y << 16) | x, &regs->screen_size);
+	}
+	dma_ctrl_set(fbi->id, 1, CFG_TV_INTERLACE_EN | CFG_TV_NIB, interlaced);
+
+	lcd_vdma = request_vdma(fbi->id, 0);
+	if (!lcd_vdma) {
+		lcd_vdma = request_vdma(fbi->id, 1);
+		if (!lcd_vdma)
+			return;
+	}
+	if (v->vmode & FB_VMODE_INTERLACED) {
+		/* interlaced mode, TV path VDMA should be disabled */
+		if (lcd_vdma->enable) {
+			vdma_enabled = 1;
+			vdma_layer = lcd_vdma->vid;
+			pxa688_vdma_en(lcd_vdma, 0, lcd_vdma->vid);
+		}
+	} else if (vdma_enabled) {
+		/* vdma recovery */
+		vdma_enabled = 0;
+		pxa688_vdma_en(lcd_vdma, 1, vdma_layer);
+	}
+}
+
+static void set_dumb_screen_dimensions(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *v = &info->var;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	int x, y, h_porch, vec = 10, vsync_ctrl;
+
+	dev_dbg(info->dev, "Enter %s fb %d regs->screen_active 0x%p\n",
+			__func__, fbi->id, &regs->screen_active);
+
+	/* resolution, active */
+	writel((v->yres << 16) | v->xres, &regs->screen_active);
+
+	if (mi->phy_type & (DSI2DPI | DSI)) {
+		vec = ((di->lanes <= 2) ? 1 : 2) * 10 * di->bpp / 8 / di->lanes;
+
+		h_porch = (v->xres + v->right_margin) * vec / 10 - v->xres;
+		h_porch = (v->left_margin * vec / 10) << 16 | h_porch;
+		vsync_ctrl = 0x01330133;
+		if (di->master_mode)
+			writel(timing_master_config(fbi->id,
+				di->id - 1, di->id - 1),
+				fbi->reg_base + TIMING_MASTER_CONTROL);
+	} else {
+		h_porch = (v->left_margin) << 16 | v->right_margin;
+
+		if ((fbi->id == 0) || (fbi->id == 2))
+			vsync_ctrl = ((v->width + v->left_margin) << 16)
+				| (v->width + v->left_margin);
+		else
+			vsync_ctrl = ((v->xres + v->right_margin) << 16)
+				| (v->xres + v->right_margin);
+	}
+	/* h porch, left/right margin */
+	writel(h_porch, &regs->screen_h_porch);
+
+	/* v porch, upper/lower margin */
+	writel((v->upper_margin << 16) | v->lower_margin,
+			&regs->screen_v_porch);
+
+	x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
+	x = x * vec / 10;
+	y = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;
+	/* screen total size */
+	writel((y << 16) | x, &regs->screen_size);
+
+	/* vsync ctrl */
+	writel(vsync_ctrl, &regs->vsync_ctrl);	/* FIXME */
+
+}
+
+static void pxa168fb_clear_framebuffer(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+
+	memset(fbi->fb_start, 0, fbi->fb_size);
+}
+
+static int pxa168fb_set_par(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct regshadow *shadowreg = &fbi->shadowreg;
+	int pix_fmt;
+	u32 flags;
+
+	dev_dbg(info->dev, "Enter %s, graphics layer\n", __func__);
+#if 1
+	pr_info("Dynamic resolution change requested by userspace ");
+	pr_info("for fbi->id: %d.........\n", fbi->id);
+	pr_info("HActive: %u\n", var->xres);
+	pr_info("VActive: %u\n", var->yres);
+	pr_info("Hvirtual: %u\n", var->xres_virtual);
+	pr_info("Vvirtual: %u\n", var->yres_virtual);
+	pr_info("bits_per_pixel: %u\n", var->bits_per_pixel);
+	pr_info("red.offset: %u\n", var->red.offset);
+	pr_info("red.length: %u\n", var->red.length);
+	pr_info("green.offset: %u\n", var->green.offset);
+	pr_info("green.length: %u\n", var->green.length);
+	pr_info("blue.offset: %u\n", var->blue.offset);
+	pr_info("blue.length: %u\n", var->blue.length);
+	pr_info("transp.offset: %u\n", var->transp.offset);
+	pr_info("transp.length: %u\n", var->transp.length);
+	pr_info("pixel clock: %u\n", var->pixclock);
+#endif
+
+	/* Determine which pixel format we're going to use */
+	pix_fmt = determine_best_pix_fmt(var, fbi);
+	if (pix_fmt < 0)
+		return pix_fmt;
+	fbi->pix_fmt = pix_fmt;
+	set_pix_fmt(var, pix_fmt);
+
+	if (!var->xres_virtual)
+		var->xres_virtual = var->xres;
+	if (!var->yres_virtual) {
+#if defined(CONFIG_MACH_QSEVEN) && !defined(CONFIG_ANDROID)
+		/* removed *2 for qseven X window */
+		var->yres_virtual = var->yres;
+#else
+		var->yres_virtual = var->yres * 2;
+#endif
+	}
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->rotate = FB_ROTATE_UR;
+
+	/* Set additional mode info */
+	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		info->fix.visual = FB_VISUAL_TRUECOLOR;
+
+	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	/* when lcd is suspend, read or write lcd controller's
+	* register is not effective, so just return*/
+	if (!(gfx_info.fbi[fbi->id]->active)) {
+		printk(KERN_DEBUG"LCD is not active, don't touch hardware\n");
+		return 0;
+	}
+
+	set_dumb_screen_dimensions(info);
+
+	/* Calculate clock divisor. */
+	set_clock_divider(fbi);
+
+	/* Configure dumb panel ctrl regs & timings */
+	set_dumb_panel_control(info);
+
+	if (gfx_info.fbi[1] && (fbi->id == 1))
+		set_tv_interlace();
+
+	flags = UPDATE_ADDR | UPDATE_MODE | UPDATE_VIEW;
+	pxa168fb_set_var(info, shadowreg, flags);
+
+	if (!NEED_VSYNC(fbi))
+		pxa168fb_set_regs(fbi, shadowreg);
+
+	return 0;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static u32 to_rgb(u16 red, u16 green, u16 blue)
+{
+	red >>= 8; green >>= 8; blue >>= 8;
+
+	return (red << 16) | (green << 8) | blue;
+}
+
+static int
+pxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		 unsigned int blue, unsigned int trans, struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+	u32 val;
+
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+					7471 * blue) >> 16;
+
+	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		val =  chan_to_field(red,   &info->var.red);
+		val |= chan_to_field(green, &info->var.green);
+		val |= chan_to_field(blue , &info->var.blue);
+		fbi->pseudo_palette[regno] = val;
+	}
+
+	if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
+		val = to_rgb(red, green, blue);
+		writel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT);
+		writel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);
+	}
+
+	return 0;
+}
+
+static int pxa168fb_active(struct pxa168fb_info *fbi, int active)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+
+	dev_dbg(fbi->fb_info->dev, "Enter %s fbi[%d] active %d\n",
+			__func__, fbi->id, active);
+	if (!active && fbi->active) {
+		atomic_set(&fbi->w_intr, 1);
+		wake_up(&fbi->w_intr_wq);
+
+		/* disable external panel power */
+		if (pxa168fb_power(fbi, mi, 0))
+			pr_err("%s %d pxa168fb_power control failed!\n",
+				 __func__, __LINE__);
+
+		fbi->active = 0;
+
+		/* disable path clock */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, SCLK_DISABLE);
+	}
+
+	if (active && !fbi->active) {
+		/* enable path clock */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, 0);
+
+		/* enable external panel power */
+		if (pxa168fb_power(fbi, mi, 1))
+			pr_err("%s %d pxa168fb_power control failed!\n",
+				 __func__, __LINE__);
+
+		/* initialize external phy if needed */
+		if (mi->phy_init && mi->phy_init(fbi)) {
+			pr_err("%s fbi %d phy error\n", __func__, fbi->id);
+			return -EIO;
+		}
+
+		fbi->active = 1;
+		set_dma_active(fbi);
+	}
+	return 0;
+}
+
+static int pxa168fb_blank(int blank, struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+#ifdef CONFIG_PM
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+			/* de-activate the device */
+			pxa168fb_active(fbi, 0);
+
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+			wake_unlock(&fbi->idle_lock);
+#else
+			/* allow system enter low power modes */
+			pm_qos_update_request(&fbi->qos_idle_fb,
+						PM_QOS_DEFAULT_VALUE);
+#endif
+			break;
+
+	case FB_BLANK_UNBLANK:
+			/* activate the device */
+			pxa168fb_active(fbi, 1);
+
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+			wake_lock(&fbi->idle_lock);
+#else
+			/* avoid system enter low power modes */
+			pm_qos_update_request(&fbi->qos_idle_fb,
+						PM_QOS_CONSTRAINT);
+#endif
+			break;
+	default:
+			break;
+	}
+	return 0;
+#else
+	fbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;
+	set_dumb_panel_control(info);
+
+	return 0;
+#endif
+}
+
+static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = info->par;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	set_start_address(info, var->xoffset, var->yoffset, &fbi->shadowreg);
+	fbi->shadowreg.flags |= UPDATE_ADDR;
+	if (fbi->shadowreg.flags == UPDATE_ADDR)
+		/* only if address needs to be updated */
+		pxa168fb_set_regs(fbi, &fbi->shadowreg);
+
+	if (NEED_VSYNC(fbi))
+		wait_for_vsync(fbi, SYNC_SELF);
+
+	return 0;
+}
+
+#ifdef CONFIG_CPU_MMP3
+static irqreturn_t pxa168fb_threaded_handle_irq(int irq, void *dev_id)
+{
+	if (atomic_read(&framedone)) {
+#ifdef CONFIG_DDR_DEVFREQ
+		wakeup_ddr_fc_seq();
+#endif
+		atomic_set(&framedone, 0);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static u32 irq_mask_get(int id)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+
+	return readl(fbi->reg_base + SPU_IRQ_ENA);
+}
+
+static u32 irq_status_get(int id)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+
+	return readl(fbi->reg_base + SPU_IRQ_ISR);
+}
+
+extern void hdmi_3d_sync_view(int right);
+#endif
+static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)dev_id;
+	u32 isr_en = readl(fbi->reg_base + SPU_IRQ_ISR) &
+		readl(fbi->reg_base + SPU_IRQ_ENA);
+	u32 id, dispd, err, sts;
+
+#ifdef CONFIG_CPU_MMP3
+	u32 val;
+	if ((isr_en & TVSYNC_IRQ_MASK) && enable_3d_flg) {
+		/* hiden register bit22 is frame cnt for all video timing,
+		 * it is counting increasingly even no DMA is on */
+		val = readl(fbi->reg_base + LCD_FRAME_CNT);
+		hdmi_3d_sync_view(val & (1 << 22));
+	}
+#endif
+
+	if (ITC_INTERVAL) {
+		gettime(t1, ct1, 0);
+
+		t0 = ct1 ? t1[ct1 - 1] : t1[ITC_MAX_NUM - 1];
+		if (t0.tv_sec) {
+			t2[ct2].tv_usec = t1[ct1].tv_usec -
+				t0.tv_usec;
+			if (t1[ct1].tv_sec > t0.tv_sec)
+				t2[ct2].tv_usec += 1000000;
+		}
+		ct1++; ct2++; ct2 %= ITC_MAX_NUM;
+	}
+
+	do {
+		irq_status_clear(0, isr_en);
+		/* display done irq */
+		dispd = isr_en & display_done_imasks;
+		if (dispd) {
+			for (id = 0; id < 2; id++) {
+				sts = dispd & display_done_imask(id);
+				if (sts) {
+					if (vsync_check &&
+						id == DBG_VSYNC_PATH) {
+						if (!ITC_INTERVAL)
+							gettime(t1, ct1, 1);
+						dispd_count++;
+					}
+#if defined(CONFIG_CPU_MMP3)
+					if ((id == 0) &&
+					    !((isr_en |
+					    (irq_status_get(id) &
+					    irq_mask_get(id))) &
+					    vsync_imask(0)))
+						atomic_set(&framedone, 1);
+#endif
+#if defined(CONFIG_CPU_MMP2) && defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM)
+					wakeup_freq_seq();
+#endif
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+					pxa168_v4l2_isr(id);
+#endif
+					pxa168_fb_isr(id);
+
+					if (ITC_HANDLER && vsync_check &&
+						id == DBG_VSYNC_PATH)
+						gettime(t2, ct2, 1);
+				}
+			}
+			/* use panel path EOF to report vsync uevent */
+			if (fbi->vsync_u_en && (dispd & display_done_imask(0)))
+				schedule_work(&fbi->uevent_work);
+		}
+
+		/* LCD under run error detect */
+		err = isr_en & err_imasks;
+		if (err) {
+			for (id = 0; id < 3; id++) {
+				if (err & gfx_udflow_imask(id)) {
+					gfx_udflow_count++;
+					if (DBG_ERR_IRQ)
+						pr_err("fb%d gfx udflow\n", id);
+				}
+				if (err & vid_udflow_imask(id)) {
+					vid_udflow_count++;
+					if (DBG_ERR_IRQ)
+						pr_err("fb%d vid udflow\n", id);
+				}
+			}
+			if (err & AXI_BUS_ERROR_IRQ_ENA_MASK) {
+				axi_err_count++;
+				if (DBG_ERR_IRQ)
+					pr_info("axi bus err\n");
+			}
+			if (err & AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK) {
+				axi_err_count++;
+				if (DBG_ERR_IRQ)
+					pr_info("axi lantency too long\n");
+			}
+		}
+
+		/* count interrupts numbers in 10s */
+		if (vsync_check) {
+			id = DBG_VSYNC_PATH;
+			if (isr_en & path_imasks(id))
+				irq_count++;
+			if (isr_en & gf0_imask(id)) {
+				if (ITC_GFX_DONE)
+					gettime(t2, ct2, 1);
+				f0_count++;
+			}
+			if (isr_en & gf1_imask(id)) {
+				if (ITC_GFX_DONE)
+					gettime(t2, ct2, 1);
+				f1_count++;
+			}
+			if (isr_en & vf0_imask(id)) {
+				if (ITC_VID_DONE)
+					gettime(t2, ct2, 1);
+				vf0_count++;
+			}
+			if (isr_en & vf1_imask(id)) {
+				if (ITC_VID_DONE)
+					gettime(t2, ct2, 1);
+				vf1_count++;
+			}
+			if (isr_en & vsync_imask(id)) {
+				if (ITC_VSYNC)
+					gettime(t2, ct2, 1);
+				vsync_count++;
+			}
+		}
+	} while (((isr_en = readl(gfx_info.fbi[0]->reg_base + SPU_IRQ_ISR) &
+			readl(gfx_info.fbi[0]->reg_base + SPU_IRQ_ENA)) &
+			(path_imasks(0) | path_imasks(1) | err_imasks)) &&
+			!(irqtm_check && vsync_check));
+
+#if defined(CONFIG_CPU_MMP3)
+	return IRQ_WAKE_THREAD;
+#else
+	return IRQ_HANDLED;
+#endif
+}
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+static void debug_identify_called_ioctl(struct fb_info *info, int cmd,
+					 unsigned long arg)
+{
+	switch (cmd) {
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		dev_dbg(info->dev, "FB_IOCTL_CLEAR_FRAMEBUFFER\n");
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_RED_BLUE:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_RED_BLUE\
+			 with arg = %08x\n", (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_U_V:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_U_V with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_SWAP_GRAPHIC_Y_UV:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_SWAP_GRAPHIC_Y_UV with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_VIDEO_ALPHABLEND with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_GLOBAL_ALPHABLEND with arg = %08x\n",
+			 (unsigned int) arg);
+		break;
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		dev_dbg(info->dev, "FB_IOCTL_PUT_GRAPHIC_ALPHABLEND with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		dev_dbg(info->dev, "FB_IOCTL_FLIP_VID_BUFFER with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_GET_FREELIST:
+		dev_dbg(info->dev, "FB_IOCTL_GET_FREELIST with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	case FB_IOCTL_SWITCH_GRA_OVLY:
+		dev_dbg(info->dev, "FB_IOCTL_SWITCH_GRA_OVLY with arg = %08x\n",
+			 (unsigned int)arg);
+		break;
+	}
+}
+#endif
+
+static int pxa168_graphic_ioctl(struct fb_info *info, unsigned int cmd,
+				 unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int blendval;
+	int val, mask, gra_on;
+	unsigned long flags;
+	unsigned char param;
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct mvdisp_partdisp grap;
+	struct mvdisp_vdma vdma;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+	debug_identify_called_ioctl(info, cmd, arg);
+#endif
+	dev_dbg(info->dev, "%s cmd 0x%x\n", __func__, cmd);
+
+	switch (cmd) {
+
+	case FB_IOCTL_CLEAR_FRAMEBUFFER:
+		pxa168fb_clear_framebuffer(info);
+		break;
+#ifdef CONFIG_CPU_MMP3
+	case FB_IOCTL_ENABLE_3D:
+		enable_3d_flg = arg;
+		if (arg)
+			irq_mask_set(1, vsync_imask(1), vsync_imask(1));
+		else /* disable tv vsync interrupts */
+			irq_mask_set(1, vsync_imask(1), 0);
+		break;
+#endif
+	case FB_IOCTL_WAIT_VSYNC:
+		param = (arg & 0x3);
+		wait_for_vsync(fbi, param);
+		break;
+	case FB_IOCTL_WAIT_VSYNC_ON:
+		fbi->wait_vsync = 1;
+		break;
+	case FB_IOCTL_WAIT_VSYNC_OFF:
+		fbi->wait_vsync = 0;
+		break;
+	case FB_IOCTL_PUT_VIDEO_ALPHABLEND:
+		/* This puts the blending control to the Video layer */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(0) | CFG_ALPHA(0xff);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_PUT_GLOBAL_ALPHABLEND:
+		/*  The userspace application can specify a byte value for
+		 *  the amount of global blend between the video layer and
+		 *  the graphic layer.
+		 *  The alpha blending is per the formula below:
+		 *  P = (V[P] * blendval/255) + (G[P] * (1 - blendval/255))
+		 *
+		 *  where: P = Pixel value, V = Video Layer, G = Graphic Layer
+		 */
+		blendval = (arg & 0xff);
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(2) | CFG_ALPHA(blendval);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_PUT_GRAPHIC_ALPHABLEND:
+		/*  This puts the blending back to the default mode of
+		 * allowing the graphic layer to do pixel level blending.
+		 */
+		mask = CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK;
+		val = CFG_ALPHA_MODE(1) | CFG_ALPHA(0x0);
+		dma_ctrl_set(fbi->id, 1, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_RED_BLUE:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPRB_MASK;
+		val = CFG_GRA_SWAPRB(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_U_V:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPUV_MASK;
+		val = CFG_GRA_SWAPUV(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_SWAP_GRAPHIC_Y_UV:
+		param = (arg & 0x1);
+		mask = CFG_GRA_SWAPYU_MASK;
+		val = CFG_GRA_SWAPYU(param);
+		dma_ctrl_set(fbi->id, 0, mask, val);
+		break;
+
+	case FB_IOCTL_FLIP_VID_BUFFER:
+		val = flip_buffer(info, arg);
+		return val;
+	case FB_IOCTL_GET_FREELIST:
+		return get_freelist(info, arg);
+
+	case FB_IOCTL_SWITCH_GRA_OVLY:
+		if (copy_from_user(&gra_on, argp, sizeof(int)))
+			return -EFAULT;
+
+		spin_lock_irqsave(&fbi->var_lock, flags);
+		fbi->dma_on = gra_on ? 1 : 0;
+		mask = CFG_GRA_ENA_MASK;
+		val = CFG_GRA_ENA(check_modex_active(fbi));
+		if (!val && gfx_info.fbi[0]->active) {
+			pxa688_vdma_release(fbi->id, fbi->vid);
+			/* switch off, disable DMA */
+			dma_ctrl_set(fbi->id, 0, mask, val);
+		}
+
+		printk(KERN_DEBUG"SWITCH_GRA_OVLY fbi %d dma_on %d, val %d\n",
+			fbi->id, fbi->dma_on, val);
+
+		spin_unlock_irqrestore(&fbi->var_lock, flags);
+		break;
+
+	case FB_IOCTL_GRA_PARTDISP:
+		if (copy_from_user(&grap, argp, sizeof(grap)))
+			return -EFAULT;
+		return pxa688fb_partdisp_set(grap);
+		break;
+
+	case FB_IOCTL_GAMMA_SET:
+#ifdef CONFIG_PXA688_MISC
+		if (copy_from_user(&fbi->gamma, argp, sizeof(fbi->gamma)))
+			return -EFAULT;
+		return gamma_set(fbi->id, fbi->gamma.flag, fbi->gamma.table);
+#else
+		return -EINVAL;
+#endif
+		break;
+
+	case FB_IOCTL_VDMA_SET:
+		if (copy_from_user(&vdma, argp, sizeof(vdma)))
+			return -EFAULT;
+		lcd_vdma = request_vdma(vdma.path, vdma.layer);
+		if (!lcd_vdma) {
+			if (vdma.enable)
+				pr_err("request fail, vdma is occupied!\n");
+			return -EINVAL;
+		}
+		if (!lcd_vdma->sram_size && vdma.enable) {
+			pr_err("ERR: SRAM size is 0KB!!!!\n");
+			return -EINVAL;
+		}
+		return pxa688_vdma_en(lcd_vdma, vdma.enable, vdma.layer);
+
+	default:
+		if (mi->ioctl)
+			return mi->ioctl(info, cmd, arg);
+		else
+			pr_warning("%s: unknown IOCTL 0x%x\n", __func__, cmd);
+		break;
+
+	}
+	return 0;
+}
+
+static int pxa168fb_open(struct fb_info *info, int user)
+{
+	struct pxa168fb_mach_info *mi;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+
+	if (fbi->debug & (1<<4))
+		return 0;
+
+	pr_info("%s GFX layer, fbi %d opened %d times ----\n",
+		 __func__, fbi->id, atomic_read(&fbi->op_count));
+
+	/* Save screen info */
+	fbi->var_bak = *var;
+
+	mi = fbi->dev->platform_data;
+
+	memset(new_addr, 0, sizeof(struct _sVideoBufferAddr));
+	fbi->surface.videoMode = -1;
+	fbi->surface.viewPortInfo.srcWidth = var->xres;
+	fbi->surface.viewPortInfo.srcHeight = var->yres;
+
+	set_pix_fmt(var, fbi->pix_fmt);
+
+	if (mutex_is_locked(&fbi->access_ok))
+		mutex_unlock(&fbi->access_ok);
+
+	/* increase open count */
+	atomic_inc(&fbi->op_count);
+
+	return 0;
+}
+
+static int pxa168fb_release(struct fb_info *info, int user)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+
+	if (fbi->debug & (1<<4))
+		return 0;
+
+	pr_info("%s GFX layer, fbi %d opened %d times ----\n",
+		__func__, fbi->id, atomic_read(&fbi->op_count));
+
+	if (atomic_dec_and_test(&fbi->op_count))
+		pxa688_vdma_release(fbi->id, fbi->vid);
+
+	/* Turn off compatibility mode */
+	var->nonstd &= ~0xff000000;
+	fbi->compat_mode = 0;
+
+	memset(&fbi->surface, 0, sizeof(struct _sOvlySurface));
+	fbi->surface.videoMode = -1;
+
+	/* clear buffer list */
+	clear_buffer(fbi);
+
+	/* Recovery screen info */
+	*var = fbi->var_bak;
+
+	fbi->pix_fmt = determine_best_pix_fmt(var, fbi);
+
+	if (NEED_VSYNC(fbi))
+		wait_for_vsync(fbi, SYNC_SELF);
+
+	return 0;
+}
+
+static struct fb_ops pxa168fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_check_var	= pxa168fb_check_var,
+	.fb_open	= pxa168fb_open,
+	.fb_release	= pxa168fb_release,
+	.fb_set_par	= pxa168fb_set_par,
+	.fb_setcolreg	= pxa168fb_setcolreg,
+	.fb_blank	= pxa168fb_blank,
+	.fb_pan_display	= pxa168fb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_ioctl       = pxa168_graphic_ioctl,
+};
+
+static int pxa168fb_init_mode(struct fb_info *info,
+			      struct pxa168fb_mach_info *mi)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct fb_var_screeninfo *var = &info->var;
+	int ret = 0;
+	u32 refresh;
+	const struct fb_videomode *m;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	/* Set default value */
+	refresh = DEFAULT_REFRESH;
+
+	/* If has bootargs, apply it first */
+	if (fbi->dft_vmode.xres && fbi->dft_vmode.yres &&
+	    fbi->dft_vmode.refresh) {
+		/* set data according bootargs */
+		var->xres = fbi->dft_vmode.xres;
+		var->yres = fbi->dft_vmode.yres;
+		refresh = fbi->dft_vmode.refresh;
+	}
+
+	/* try to find best video mode. */
+	m = fb_find_best_mode(&info->var, &info->modelist);
+	if (m)
+		fb_videomode_to_var(&info->var, m);
+
+	/* Init settings. */
+	var->xres_virtual = var->xres;
+#if defined(CONFIG_MACH_QSEVEN) && !defined(CONFIG_ANDROID)
+	var->yres_virtual = var->yres; /* removed *2 for qseven X window */
+#else
+	var->yres_virtual = var->yres * 2;
+#endif
+
+#if 0
+	if (!var->pixclock) {
+		u32 total_w, total_h;
+		u64 div_result;
+
+		/* correct pixclock. */
+		total_w = var->xres + var->left_margin + var->right_margin +
+			var->hsync_len;
+		total_h = var->yres + var->upper_margin + var->lower_margin +
+			var->vsync_len;
+
+		div_result = 1000000000000ll;
+		do_div(div_result, total_w * total_h * refresh);
+		var->pixclock = (u32)div_result;
+	}
+#endif
+	return ret;
 }
 
-static void set_dma_control0(struct pxa168fb_info *fbi)
+static void pxa168fb_set_default(struct pxa168fb_info *fbi,
+		struct pxa168fb_mach_info *mi)
 {
-	u32 x;
-
+	struct lcd_regs *regs = get_regs(fbi->id);
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+	u32 dma_ctrl1 = 0x20320081, flag, tmp;
+#else
+	u32 dma_ctrl1 = 0x2032ff81, flag, tmp;
+#endif
 	/*
-	 * Set bit to enable graphics DMA.
+	 * LCD Global control(LCD_TOP_CTRL) should be configed before
+	 * any other LCD registers read/write, or there maybe issues.
 	 */
-	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	x &= ~CFG_GRA_ENA_MASK;
-	x |= fbi->active ? CFG_GRA_ENA(1) : CFG_GRA_ENA(0);
-
-	/*
-	 * If we are in a pseudo-color mode, we need to enable
-	 * palette lookup.
+	tmp = readl(fbi->reg_base + LCD_TOP_CTRL);
+	tmp |= 0xfff0;		/* FIXME */
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+	tmp |= 0x1 << 22;	/*TV DMA object go to panel */
+#endif
+	writel(tmp, fbi->reg_base + LCD_TOP_CTRL);
+
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+	tmp = readl(fbi->reg_base + LCD_AFA_ALL2ONE);
+	tmp &= 0xfffffff0;
+
+	/* PN video DMA as first layer, TV video DMA as second layer */
+	tmp |= 0x8;
+	writel(tmp, fbi->reg_base + LCD_AFA_ALL2ONE);
+#endif
+
+	/* Configure default register values */
+	writel(mi->io_pad_ctrl, fbi->reg_base + SPU_IOPAD_CONTROL);
+	/* enable 16 cycle burst length to get better formance */
+
+	writel(0x00000000, &regs->blank_color);
+	writel(0x00000000, &regs->g_1);
+	writel(0x00000000, &regs->g_start);
+
+	/* Configure default bits: vsync triggers DMA,
+	 * power save enable, configure alpha registers to
+	 * display 100% graphics, and set pixel command.
 	 */
-	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
-		x |= 0x10000000;
+	if (fbi->id == 1) {
+		if (mi->phy_type & (DSI2DPI | DSI))
+			dma_ctrl1 = 0xa03eff00;
+		else
+			dma_ctrl1 = 0x203eff00;	/* FIXME */
+	}
 
 	/*
-	 * Configure hardware pixel format.
+	 * vsync in LCD internal controller is always positive,
+	 * we default configure dma trigger @vsync falling edge,
+	 * so that DMA idle time between DMA frame done and
+	 *  next DMA transfer begin can be as large as possible
 	 */
-	x &= ~(0xF << 16);
-	x |= (fbi->pix_fmt >> 1) << 16;
+	dma_ctrl1 |= CFG_VSYNC_INV_MASK;
+	dma_ctrl_write(fbi->id, 1, dma_ctrl1);
 
 	/*
-	 * Check red and blue pixel swap.
-	 * 1. source data swap
-	 * 2. panel output data swap
+	 * 1.enable multiple burst request in DMA AXI
+	 * bus arbiter for faster read if not tv path;
+	 * 2.enable horizontal smooth filter;
 	 */
-	x &= ~(1 << 12);
-	x |= ((fbi->pix_fmt & 1) ^ (fbi->panel_rbswap)) << 12;
-
-	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	tmp = CFG_GRA_HSMOOTH_MASK | CFG_DMA_HSMOOTH_MASK;
+	flag = CFG_ARBFAST_ENA(1) | tmp;
+	if (fbi->id != 1)
+		dma_ctrl_set(fbi->id, 0, flag, flag);
+	else
+		dma_ctrl_set(fbi->id, 0, flag, tmp);
 }
 
-static void set_dma_control1(struct pxa168fb_info *fbi, int sync)
+static int __init get_fb_size(char *str)
 {
-	u32 x;
-
-	/*
-	 * Configure default bits: vsync triggers DMA, gated clock
-	 * enable, power save enable, configure alpha registers to
-	 * display 100% graphics, and set pixel command.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
-	x |= 0x2032ff81;
-
-	/*
-	 * We trigger DMA on the falling edge of vsync if vsync is
-	 * active low, or on the rising edge if vsync is active high.
-	 */
-	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
-		x |= 0x08000000;
-
-	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_fb_size = n;
+	fb_size_from_cmd = 1;
+	return 1;
 }
+__setup("fb_size=", get_fb_size);
 
-static void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)
+static int __init get_fb_share(char *str)
 {
-	struct pxa168fb_info *fbi = info->par;
-	struct fb_var_screeninfo *var = &info->var;
-	int pixel_offset;
-	unsigned long addr;
-
-	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
-
-	addr = fbi->fb_start_dma + (pixel_offset * (var->bits_per_pixel >> 3));
-	writel(addr, fbi->reg_base + LCD_CFG_GRA_START_ADDR0);
+	fb_share = 1;
+	return 1;
 }
+__setup("fb_share", get_fb_share);
 
-static void set_dumb_panel_control(struct fb_info *info)
+#ifdef CONFIG_PM
+
+static int _pxa168fb_suspend(struct pxa168fb_info *fbi)
 {
-	struct pxa168fb_info *fbi = info->par;
+	struct fb_info *info = fbi->fb_info;
 	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
-	u32 x;
+	u32 mask = CFG_GRA_ENA_MASK;
 
-	/*
-	 * Preserve enable flag.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL) & 0x00000001;
+	/* notify others */
+	fb_set_suspend(info, 1);
 
-	x |= (fbi->is_blanked ? 0x7 : mi->dumb_mode) << 28;
-	x |= mi->gpio_output_data << 20;
-	x |= mi->gpio_output_mask << 12;
-	x |= mi->panel_rgb_reverse_lanes ? 0x00000080 : 0;
-	x |= mi->invert_composite_blank ? 0x00000040 : 0;
-	x |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;
-	x |= mi->invert_pix_val_ena ? 0x00000010 : 0;
-	x |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;
-	x |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;
-	x |= mi->invert_pixclock ? 0x00000002 : 0;
+	/* stop dma transaction */
+#ifndef CONFIG_PXA168_V4L2_OVERLAY
+	mask |= CFG_DMA_ENA_MASK;
+#endif
+	dma_ctrl_set(fbi->id, 0, mask, 0);
 
-	writel(x, fbi->reg_base + LCD_SPU_DUMB_CTRL);
-}
+	/* Before disable lcd clk, disable all lcd interrupts */
+	fbi->irq_mask = readl(fbi->reg_base + SPU_IRQ_ENA);
+	irq_mask_set(fbi->id, 0xffffffff, 0);
 
-static void set_dumb_screen_dimensions(struct fb_info *info)
-{
-	struct pxa168fb_info *fbi = info->par;
-	struct fb_var_screeninfo *v = &info->var;
-	int x;
-	int y;
+	/* disable external panel power */
+	if (pxa168fb_power(fbi, mi, 0))
+		pr_err("%s %d pxa168fb_power control failed!\n",
+			 __func__, __LINE__);
 
-	x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
-	y = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;
+	fbi->active = 0;
+
+	if (fbi->id != 1) {
+		/* disable pixel clock, expect TV path which need it
+		 * for audio playback @ early suspend */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, SCLK_DISABLE);
+	}
+
+	/* disable clock */
+	clk_disable(fbi->clk);
 
-	writel((y << 16) | x, fbi->reg_base + LCD_SPUT_V_H_TOTAL);
+	pr_debug("pxa168fb.%d suspended\n", fbi->id);
+	return 0;
 }
 
-static int pxa168fb_set_par(struct fb_info *info)
+static int _pxa168fb_resume(struct pxa168fb_info *fbi)
 {
-	struct pxa168fb_info *fbi = info->par;
-	struct fb_var_screeninfo *var = &info->var;
-	struct fb_videomode mode;
-	u32 x;
-	struct pxa168fb_mach_info *mi;
-
-	mi = fbi->dev->platform_data;
+	struct fb_info *info = fbi->fb_info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
 
-	/*
-	 * Set additional mode info.
-	 */
-	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
-		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
-	else
-		info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
-	info->fix.ypanstep = var->yres;
+	/* enable clock */
+	if (fbi->sclk_src)
+		clk_set_rate(fbi->clk, fbi->sclk_src);
+	clk_enable(fbi->clk);
 
-	/*
-	 * Disable panel output while we setup the display.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x & ~1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
+	if (fbi->id != 1) {
+		/* enable pixel clock */
+		lcd_clk_set(fbi->id, clk_sclk, SCLK_DISABLE, 0);
+	}
 
-	/*
-	 * Configure global panel parameters.
-	 */
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_V_H_ACTIVE);
+	/* enable external panel power */
+	if (pxa168fb_power(fbi, mi, 1))
+		pr_err("%s %d pxa168fb_power control failed!\n",
+			 __func__, __LINE__);
 
-	/*
-	 * convet var to video mode
+	/* register setting should retain so no need to set again.
+	 * pxa168fb_set_par(info);
+	 * pxa168fb_set_default(fbi, mi);
 	 */
-	fb_var_to_videomode(&mode, &info->var);
 
-	/* Calculate clock divisor. */
-	set_clock_divider(fbi, &mode);
-
-	/* Configure dma ctrl regs. */
-	set_dma_control0(fbi);
-	set_dma_control1(fbi, info->var.sync);
+	/* initialize external phy if needed */
+	if (mi->phy_init && mi->phy_init(fbi)) {
+		pr_err("%s fbi %d phy error\n", __func__, fbi->id);
+		return -EIO;
+	}
 
-	/*
-	 * Configure graphics DMA parameters.
-	 */
-	x = readl(fbi->reg_base + LCD_CFG_GRA_PITCH);
-	x = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);
-	writel(x, fbi->reg_base + LCD_CFG_GRA_PITCH);
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_GRA_HPXL_VLN);
-	writel((var->yres << 16) | var->xres,
-		fbi->reg_base + LCD_SPU_GZM_HPXL_VLN);
+	/*After enable lcd clk, restore lcd interrupts*/
+	irq_mask_set(fbi->id, 0xffffffff, fbi->irq_mask);
 
-	/*
-	 * Configure dumb panel ctrl regs & timings.
-	 */
-	set_dumb_panel_control(info);
-	set_dumb_screen_dimensions(info);
+	/* restore gamma correction table */
+	gamma_set(fbi->id, fbi->gamma.flag, fbi->gamma.table);
 
-	writel((var->left_margin << 16) | var->right_margin,
-			fbi->reg_base + LCD_SPU_H_PORCH);
-	writel((var->upper_margin << 16) | var->lower_margin,
-			fbi->reg_base + LCD_SPU_V_PORCH);
+	/* restore dma after resume */
+	fbi->active = 1;
+#ifndef CONFIG_ANDROID
+	set_dma_active(fbi);
+#ifndef CONFIG_PXA168_V4L2_OVERLAY
+	set_dma_active(ovly_info.fbi[fbi->id]);
+#endif
+#endif
 
-	/*
-	 * Re-enable panel output.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
+	/* notify others */
+	fb_set_suspend(info, 0);
 
+	pr_debug("pxa168fb.%d resumed.\n", fbi->id);
 	return 0;
 }
 
-static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
-{
-	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
-}
+#ifdef CONFIG_HAS_EARLYSUSPEND
 
-static u32 to_rgb(u16 red, u16 green, u16 blue)
+static void pxa168fb_early_suspend(struct early_suspend *h)
 {
-	red >>= 8;
-	green >>= 8;
-	blue >>= 8;
+	struct pxa168fb_info *fbi = container_of(h, struct pxa168fb_info,
+						 early_suspend);
 
-	return (red << 16) | (green << 8) | blue;
-}
+	_pxa168fb_suspend(fbi);
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_unlock(&fbi->idle_lock);
+#else
+	pm_qos_update_request(&fbi->qos_idle_fb, PM_QOS_DEFAULT_VALUE);
+#endif
 
-static int
-pxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
-		 unsigned int blue, unsigned int trans, struct fb_info *info)
+	return;
+}
+static void pxa168fb_late_resume(struct early_suspend *h)
 {
-	struct pxa168fb_info *fbi = info->par;
-	u32 val;
+	struct pxa168fb_info *fbi = container_of(h, struct pxa168fb_info,
+						 early_suspend);
 
-	if (info->var.grayscale)
-		red = green = blue = (19595 * red + 38470 * green +
-					7471 * blue) >> 16;
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_lock(&fbi->idle_lock);
+#else
+	pm_qos_update_request(&fbi->qos_idle_fb, PM_QOS_CONSTRAINT);
+#endif
+	_pxa168fb_resume(fbi);
 
-	if (info->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
-		val =  chan_to_field(red,   &info->var.red);
-		val |= chan_to_field(green, &info->var.green);
-		val |= chan_to_field(blue , &info->var.blue);
-		fbi->pseudo_palette[regno] = val;
-	}
+	return;
+}
 
-	if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
-		val = to_rgb(red, green, blue);
-		writel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT);
-		writel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);
-	}
+#else
+
+static int pxa168fb_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+
+	_pxa168fb_suspend(fbi);
+	pdev->dev.power.power_state = mesg;
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_unlock(&fbi->idle_lock);
+#else
+	pm_qos_update_request(&fbi->qos_idle_fb, PM_QOS_DEFAULT_VALUE);
+#endif
 
 	return 0;
 }
 
-static int pxa168fb_blank(int blank, struct fb_info *info)
+static int pxa168fb_resume(struct platform_device *pdev)
 {
-	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
 
-	fbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;
-	set_dumb_panel_control(info);
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_lock(&fbi->idle_lock);
+#else
+	pm_qos_update_request(&fbi->qos_idle_fb, PM_QOS_CONSTRAINT);
+#endif
+	_pxa168fb_resume(fbi);
 
 	return 0;
 }
 
-static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
-				struct fb_info *info)
+#endif /* CONFIG_HAS_EARLYSUSPEND */
+
+#endif /* CONFIG_PM */
+
+static size_t vsync_help(char *buf)
 {
-	set_graphics_start(info, var->xoffset, var->yoffset);
+	int s = 0, f = DUMP_SPRINTF;
 
-	return 0;
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump path(pn/tv/pn2:0/1/2) graphics layer"
+			" wait vsync @ pan_display or not\n");
+	mvdisp_dump(f, "\tcat vsync\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] wait vsync @ pan_display\n");
+	mvdisp_dump(f, "\techo [en/dis:1/0] > vsync\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] vsync uevent report\n");
+	mvdisp_dump(f, "\techo [en/dis:u1/u0] > vsync\n");
+
+
+	return s;
 }
 
-static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
+static ssize_t vsync_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
-	struct pxa168fb_info *fbi = dev_id;
-	u32 isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	int s = 0;
 
-	if ((isr & GRA_FRAME_IRQ0_ENA_MASK)) {
+	s += sprintf(buf, "path %d wait vsync @ pan_display %s\n",
+			 fbi->id, fbi->wait_vsync ? "enabled" : "disabled");
+	s += sprintf(buf + s, "%s vsync uevent report\n\n",
+			 fbi->vsync_u_en ? "enable" : "disable");
 
-		writel(isr & (~GRA_FRAME_IRQ0_ENA_MASK),
-			fbi->reg_base + SPU_IRQ_ISR);
+	s += vsync_help(buf + s);
 
-		return IRQ_HANDLED;
+	return s;
+}
+
+static ssize_t vsync_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	char vol[30];
+
+	if ('u' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%d", &fbi->vsync_u_en) != 1)
+			pr_err("%s %d erro input of vsync uevent flag\n",\
+				__func__, __LINE__);
+	} else if (sscanf(buf, "%d", &fbi->wait_vsync) != 1)
+		pr_err("%s %d erro input of wait vsync flag\n",\
+			__func__, __LINE__);
+	return size;
+}
+static DEVICE_ATTR(vsync, S_IRUGO | S_IWUSR, vsync_show, vsync_store);
+
+static void vsync_uevent_worker(struct work_struct *work)
+{
+	struct pxa168fb_info *fbi = container_of(work, struct pxa168fb_info,
+						 uevent_work);
+	char str[64];
+	char *vsync_str[] = {str, NULL};
+	struct timespec vsync_time;
+	struct platform_device *pdev;
+	uint64_t nanoseconds;
+
+	if (!fbi) {
+		pr_err("failed to get fbi when report vsync uevent!\n");
+		return;
 	}
-	return IRQ_NONE;
+
+	pdev = to_platform_device(fbi->dev);
+	ktime_get_ts(&vsync_time);
+
+	nanoseconds = ((uint64_t)vsync_time.tv_sec)*1000*1000*1000 +
+		((uint64_t)vsync_time.tv_nsec);
+	snprintf(str, 64, "DISP_VSYNC=%lld", (uint64_t)nanoseconds);
+	dev_dbg(fbi->dev, "%s\n", str);
+
+	kobject_uevent_env(&pdev->dev.kobj, KOBJ_CHANGE, vsync_str);
 }
 
-static struct fb_ops pxa168fb_ops = {
-	.owner		= THIS_MODULE,
-	.fb_check_var	= pxa168fb_check_var,
-	.fb_set_par	= pxa168fb_set_par,
-	.fb_setcolreg	= pxa168fb_setcolreg,
-	.fb_blank	= pxa168fb_blank,
-	.fb_pan_display	= pxa168fb_pan_display,
-	.fb_fillrect	= cfb_fillrect,
-	.fb_copyarea	= cfb_copyarea,
-	.fb_imageblit	= cfb_imageblit,
-};
+static ssize_t itc_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "\ncommands:\n");
+	mvdisp_dump(f, " - dump display controller interrupt timestamps\n");
+	mvdisp_dump(f, "\tcat itc\n");
+	mvdisp_dump(f, " - set interrupt timestamp collection flag\n");
+	mvdisp_dump(f, "   [0]: disable all timestamps collection\n");
+	mvdisp_dump(f, "   [1]: collect timestamp each time enter lcd"
+			" interrupts service\n");
+	mvdisp_dump(f, "   [2]: collect timestamp for display done interrupt"
+			" and vsync interrupt\n");
+	mvdisp_dump(f, "   [3]: collect timestamp for display done interrupt"
+			" and graphic frame done interrupt\n");
+	mvdisp_dump(f, "   [4]: collect timestamp for display done interrupt"
+			" and video frame done interrupt\n");
+	mvdisp_dump(f, "   [5]: collect timestamp for display done interrupt"
+			" and main handler finish time\n");
+	mvdisp_dump(f, "\techo [0/1/2/3/4/5] > itc\n");
+
+	return s;
+}
 
-static int __devinit pxa168fb_init_mode(struct fb_info *info,
-			      struct pxa168fb_mach_info *mi)
+static ssize_t itc_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
 {
-	struct pxa168fb_info *fbi = info->par;
-	struct fb_var_screeninfo *var = &info->var;
-	int ret = 0;
-	u32 total_w, total_h, refresh;
-	u64 div_result;
-	const struct fb_videomode *m;
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	int i, j, s = 0, val, f = 1;
+
+	mvdisp_dump(f, "irqtm_check %d: t1 - %s, t2 - ", irqtm_check,
+			irqtm_check ? "display done" : "none");
+	if (ITC_INTERVAL)
+		mvdisp_dump(f, "irq interval\n");
+	else if (ITC_VSYNC)
+		mvdisp_dump(f, "vsync\n");
+	else if (ITC_GFX_DONE)
+		mvdisp_dump(f, "gfx frame done\n");
+	else if (ITC_VID_DONE)
+		mvdisp_dump(f, "vid frame done\n");
+	else if (ITC_HANDLER)
+		mvdisp_dump(f, "main handler\n");
+	else
+		mvdisp_dump(f, "none\n");
 
-	/*
-	 * Set default value
-	 */
-	refresh = DEFAULT_REFRESH;
+	mvdisp_dump(f, "     t1     t2 :   ");
+	if (ITC_INTERVAL)
+		mvdisp_dump(f, "t2-frm_usec\n");
+	else
+		mvdisp_dump(f, "t2-t1\n");
+	for (i = 0; i < ITC_MAX_NUM; i++) {
+		if (ITC_INTERVAL) {
+			val = 0;
+			if ((int)t2[i].tv_usec > 10000)
+				val = (int)t2[i].tv_usec - fbi->frm_usec;
+		} else
+			val = t2[i].tv_usec - t1[i].tv_usec;
+
+		for (j = 0; j < ITC_MAX_NUM; j++) {
+			val = (val < -10000 || val > 10000) ?
+				(t2[j].tv_usec - t1[i].tv_usec) : val;
+		}
 
-	/* try to find best video mode. */
-	m = fb_find_best_mode(&info->var, &info->modelist);
-	if (m)
-		fb_videomode_to_var(&info->var, m);
+		mvdisp_dump(f, " %6ld %6ld :  %6d", t1[i].tv_usec,
+			t2[i].tv_usec, val);
+		mvdisp_dump(f, "\n");
+	}
 
-	/* Init settings. */
-	var->xres_virtual = var->xres;
-	var->yres_virtual = info->fix.smem_len /
-		(var->xres_virtual * (var->bits_per_pixel >> 3));
-	dev_dbg(fbi->dev, "pxa168fb: find best mode: res = %dx%d\n",
-				var->xres, var->yres);
+	s += itc_help(buf + s);
+	return s;
+}
 
-	/* correct pixclock. */
-	total_w = var->xres + var->left_margin + var->right_margin +
-		  var->hsync_len;
-	total_h = var->yres + var->upper_margin + var->lower_margin +
-		  var->vsync_len;
+static ssize_t itc_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	sscanf(buf, "%d", &irqtm_check);
 
-	div_result = 1000000000000ll;
-	do_div(div_result, total_w * total_h * refresh);
-	var->pixclock = (u32)div_result;
+	if (irqtm_check && !ITC_INTERVAL)
+		vsync_check_count();
 
-	return ret;
+	return size;
 }
+static DEVICE_ATTR(itc, S_IRUGO | S_IWUSR, itc_show, itc_store);
 
 static int __devinit pxa168fb_probe(struct platform_device *pdev)
 {
@@ -607,15 +2008,29 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 	struct pxa168fb_info *fbi = 0;
 	struct resource *res;
 	struct clk *clk;
-	int irq, ret;
+	int irq, irq_mask, irq_enable_value, ret = 0;
+	struct dsi_info *di = NULL;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+#if !defined(CONFIG_WAKELOCK) || !defined(CONFIG_CPU_PXA910)
+	int pm_qos_class = PM_QOS_CPU_DMA_LATENCY;
+#ifdef CONFIG_CPU_PXA988
+	pm_qos_class = PM_QOS_CPUIDLE_KEEP_DDR;
+#endif
+#endif
 
 	mi = pdev->dev.platform_data;
 	if (mi == NULL) {
 		dev_err(&pdev->dev, "no platform data defined\n");
 		return -EINVAL;
 	}
+	/* if isr_clear_mask not initizlized, set to 0xffffffff as default */
+	if (!mi->isr_clear_mask) {
+		pr_err("%s: %s isr_clear_mask not been initialized!\n",
+			__func__, mi->id);
+		mi->isr_clear_mask = 0xffffffff;
+	}
 
-	clk = clk_get(&pdev->dev, "LCDCLK");
+	clk = clk_get(NULL, "LCDCLK");
 	if (IS_ERR(clk)) {
 		dev_err(&pdev->dev, "unable to get LCDCLK");
 		return PTR_ERR(clk);
@@ -636,150 +2051,331 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 	}
 
 	info = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
-	if (info == NULL) {
+	if ((info == NULL) || (!info->par)) {
 		ret = -ENOMEM;
 		goto failed_put_clk;
 	}
 
 	/* Initialize private data */
 	fbi = info->par;
-	fbi->info = info;
+	fbi->id = pdev->id;
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+	if (!fbi->id)
+		fbi->vid = 1;
+	else
+		fbi->vid = 0;
+#else
+		fbi->vid = 0;
+#endif
+	if (!fbi->id) {
+		memset(&gfx_info, 0, sizeof(gfx_info));
+		fbi->dma_on = 1;
+	}
+
+	gfx_info.fbi[fbi->id] = fbi;
+	if (mi->phy_type & (DSI | DSI2DPI))
+		di = (struct dsi_info *)mi->phy_info;
+	if (di) {
+		pr_info("fb%d dsi %d di->lanes %d di->bpp %d\n",
+			fbi->id, di->id, di->lanes, di->bpp);
+		if (di->id & 1)
+			di->regs = (unsigned)ioremap_nocache\
+			(DSI1_REGS_PHYSICAL_BASE, sizeof(struct dsi_regs));
+		else
+			di->regs = (unsigned)ioremap_nocache\
+			(DSI2_REGS_PHYSICAL_BASE, sizeof(struct dsi_regs));
+	}
+
+	fbi->fb_info = info;
+	platform_set_drvdata(pdev, fbi);
 	fbi->clk = clk;
-	fbi->dev = info->dev = &pdev->dev;
-	fbi->panel_rbswap = mi->panel_rbswap;
+	fbi->dev = &pdev->dev;
+	fbi->fb_info->dev = &pdev->dev;
 	fbi->is_blanked = 0;
 	fbi->active = mi->active;
 
-	/*
-	 * Initialise static fb parameters.
-	 */
+	/* Initialize boot setting */
+	fbi->dft_vmode.xres = mi->modes->xres;
+	fbi->dft_vmode.yres = mi->modes->yres;
+	fbi->dft_vmode.refresh = mi->modes->refresh;
+
+	init_waitqueue_head(&fbi->w_intr_wq);
+	mutex_init(&fbi->access_ok);
+
+	pxa168fb_list_init(fbi);
+
+	/* Initialise static fb parameters */
 	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
-		      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+			FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
 	info->node = -1;
-	strlcpy(info->fix.id, mi->id, 16);
+	strcpy(info->fix.id, mi->id);
 	info->fix.type = FB_TYPE_PACKED_PIXELS;
 	info->fix.type_aux = 0;
-	info->fix.xpanstep = 0;
-	info->fix.ypanstep = 0;
+	info->fix.xpanstep = 1;
+	info->fix.ypanstep = 1;
 	info->fix.ywrapstep = 0;
 	info->fix.mmio_start = res->start;
-	info->fix.mmio_len = resource_size(res);
+	info->fix.mmio_len = res->end - res->start + 1;
 	info->fix.accel = FB_ACCEL_NONE;
 	info->fbops = &pxa168fb_ops;
 	info->pseudo_palette = fbi->pseudo_palette;
 
-	/*
-	 * Map LCD controller registers.
-	 */
-	fbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,
-					     resource_size(res));
+	/* Map LCD controller registers */
+	fbi->reg_base = ioremap_nocache(res->start, res->end - res->start);
 	if (fbi->reg_base == NULL) {
 		ret = -ENOMEM;
 		goto failed_free_info;
 	}
 
-	/*
-	 * Allocate framebuffer memory.
-	 */
-	info->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);
-
-	info->screen_base = dma_alloc_writecombine(fbi->dev, info->fix.smem_len,
-						&fbi->fb_start_dma, GFP_KERNEL);
-	if (info->screen_base == NULL) {
-		ret = -ENOMEM;
-		goto failed_free_info;
+	/* Allocate framebuffer memory */
+	if (!fb_size_from_cmd) {
+		if (mi->max_fb_size)
+			max_fb_size = mi->max_fb_size;
+		else
+			max_fb_size = DEFAULT_FB_SIZE;
+	}
+	if (fb_share) {
+		/* fb_share mode, allocate more memory as frame buffer */
+		max_fb_size = max(max_fb_size, 2 * 4 * (mi->modes->xres *
+				(mi->modes->xres + mi->modes->yres)));
 	}
 
-	info->fix.smem_start = (unsigned long)fbi->fb_start_dma;
-	set_graphics_start(info, 0, 0);
+	max_fb_size = PAGE_ALIGN(max_fb_size);
+	if (mi->mmap)
+		fbi->fb_size = max_fb_size;
+
+	if (fb_share && (fbi->id == 1) && gfx_info.fbi[0]->fb_start) {
+		fbi->fb_size = gfx_info.fbi[0]->fb_size;
+		fbi->fb_start = gfx_info.fbi[0]->fb_start;
+		fbi->fb_start_dma = gfx_info.fbi[0]->fb_start_dma;
+		pr_info("--share--FB DMA buffer phy addr : %x\n",
+			(unsigned int)fbi->fb_start_dma);
+	} else if (mi->mmap) {
+		fbi->fb_start = dma_alloc_writecombine(fbi->dev, max_fb_size,
+				&fbi->fb_start_dma, GFP_KERNEL);
+
+		if (!fbi->fb_start || !fbi->fb_start_dma) {
+			fbi->fb_start = (void *)__get_free_pages(GFP_DMA |
+				GFP_KERNEL, get_order(fbi->fb_size));
+			fbi->fb_start_dma =
+				(dma_addr_t)__virt_to_phys(fbi->fb_start);
+		}
 
-	/*
-	 * Set video mode according to platform data.
-	 */
+		if (fbi->fb_start == NULL) {
+			pr_err("%s: no enough memory!\n", __func__);
+			ret = -ENOMEM;
+			goto failed_free_info;
+		}
+		pr_info("---------FB DMA buffer phy addr : %x\n",
+			(unsigned int)fbi->fb_start_dma);
+
+		memset(fbi->fb_start, 0, fbi->fb_size);
+	}
+
+	/* fill backup information for mode switch */
+	fbi->fb_start_dma_bak = fbi->fb_start_dma;
+	fbi->fb_start_bak = fbi->fb_start;
+
+	info->fix.smem_start = fbi->fb_start_dma;
+	info->fix.smem_len = fbi->fb_size;
+	info->screen_base = fbi->fb_start;
+	info->screen_size = fbi->fb_size;
+
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	/* init wake lock */
+	wake_lock_init(&fbi->idle_lock, WAKE_LOCK_IDLE, dev_name(fbi->dev));
+	/* avoid system enter low power modes */
+	wake_lock(&fbi->idle_lock);
+#else
+	/* init qos with constraint */
+	pm_qos_add_request(&fbi->qos_idle_fb, pm_qos_class,
+			PM_QOS_CONSTRAINT);
+#endif
+
+	/* Set video mode according to platform data */
 	set_mode(fbi, &info->var, mi->modes, mi->pix_fmt, 1);
 
 	fb_videomode_to_modelist(mi->modes, mi->num_modes, &info->modelist);
 
-	/*
-	 * init video mode data.
-	 */
+	/* init video mode data */
 	pxa168fb_init_mode(info, mi);
 
-	/*
-	 * Fill in sane defaults.
-	 */
-	ret = pxa168fb_check_var(&info->var, info);
-	if (ret)
-		goto failed_free_fbmem;
-
-	/*
-	 * enable controller clock
-	 */
+	/* enable controller clock */
+	if (mi->sclk_src)
+		clk_set_rate(fbi->clk, mi->sclk_src);
 	clk_enable(fbi->clk);
-
+	pr_info("fb%d: sclk_src %d clk_get_rate = %d\n", fbi->id,
+		mi->sclk_src, (int)clk_get_rate(fbi->clk));
+
+	/* init vdma clock/sram, etc. */
+	lcd_vdma = request_vdma(fbi->id, fbi->vid);
+	if (lcd_vdma) {
+		lcd_vdma->dev = fbi->dev;
+		lcd_vdma->reg_base = fbi->reg_base;
+		pxa688_vdma_init(lcd_vdma);
+	} else
+		pr_warn("path %d layer %d: request vdma fail\n", fbi->id, fbi->vid);
+
+	/* Fill in sane defaults */
+	pxa168fb_set_default(fbi, mi);	/* FIXME */
 	pxa168fb_set_par(info);
 
-	/*
-	 * Configure default register values.
-	 */
-	writel(0, fbi->reg_base + LCD_SPU_BLANKCOLOR);
-	writel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);
-	writel(0, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);
-	writel(0, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);
-	writel(0, fbi->reg_base + LCD_SPU_SRAM_PARA0);
-	writel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),
-		fbi->reg_base + LCD_SPU_SRAM_PARA1);
+	if (mi->dither_en)
+		dither_set(fbi, mi->dither_table, mi->dither_mode, 1);
 
-	/*
-	 * Allocate color map.
-	 */
+	/* Allocate color map */
 	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
 		ret = -ENOMEM;
 		goto failed_free_clk;
 	}
 
-	/*
-	 * Register irq handler.
-	 */
-	ret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,
-			       IRQF_SHARED, info->fix.id, fbi);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "unable to request IRQ\n");
-		ret = -ENXIO;
-		goto failed_free_cmap;
+	/* Register irq handler */
+	if (!fbi->id) {
+		/* Clear the irq status before kernel startup */
+		irq_status_clear(fbi->id, 0xFFFFFFFF);
+#if defined(CONFIG_CPU_MMP3)
+		ret = request_threaded_irq(irq, pxa168fb_handle_irq,
+					   pxa168fb_threaded_handle_irq,
+					   IRQF_DISABLED, mi->id, fbi);
+#else
+		ret = request_irq(irq, pxa168fb_handle_irq, IRQF_DISABLED,
+					 mi->id, fbi);
+#endif
+		if (ret < 0) {
+			dev_err(&pdev->dev, "unable to request IRQ\n");
+			ret = -ENXIO;
+			goto failed_free_cmap;
+		}
 	}
 
-	/*
-	 * Enable GFX interrupt
-	 */
-	writel(GRA_FRAME_IRQ0_ENA(0x1), fbi->reg_base + SPU_IRQ_ENA);
+	/* disable GFX interrupt
+	*  enable display done & err interrupt */
+	irq_mask = path_imasks(fbi->id) | err_imask(fbi->id);
+	irq_enable_value = display_done_imask(fbi->id) | err_imask(fbi->id);
+	irq_mask_set(fbi->id, irq_mask, irq_enable_value);
+	/* enable vsync interrupt */
+	irq_mask_set(fbi->id, vsync_imask(fbi->id), vsync_imask(fbi->id));
+	fbi->wait_vsync = 1;
+
+	/* enable power supply */
+	fbi->active = 0;
+	if (pxa168fb_power(fbi, mi, 1)) {
+			ret = -EINVAL;
+			goto failed_free_irq;
+		}
+	fbi->active = 1;
 
-	/*
-	 * Register framebuffer.
-	 */
+	/* initialize external phy if needed */
+	if (mi->phy_init && mi->phy_init(fbi)) {
+		pr_err("%s fbi %d phy error\n", __func__, fbi->id);
+		ret = -EIO;
+		goto failed_free_irq;
+	}
+
+	/* Register framebuffer */
 	ret = register_framebuffer(info);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to register pxa168-fb: %d\n", ret);
 		ret = -ENXIO;
-		goto failed_free_cmap;
+		goto failed_free_irq;
+	}
+	pr_info("pxa168fb: frame buffer device was loaded"
+		" to /dev/fb%d <%s>.\n", info->node, info->fix.id);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	/* let TV path suspend first and resume late than panel path */
+	fbi->early_suspend.level = EARLY_SUSPEND_LEVEL_DISABLE_FB - fbi->id;
+	fbi->early_suspend.suspend = pxa168fb_early_suspend;
+	fbi->early_suspend.resume = pxa168fb_late_resume;
+	register_early_suspend(&fbi->early_suspend);
+#endif
+
+#ifdef CONFIG_PXA688_PHY
+	ret = device_create_file(&pdev->dev, &dev_attr_phy);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		goto failed_free_irq;
 	}
+#endif
 
-	platform_set_drvdata(pdev, fbi);
+#ifdef CONFIG_PXA688_VDMA
+	ret = device_create_file(&pdev->dev, &dev_attr_vdma);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		return ret;
+	}
+#endif
+
+#ifdef CONFIG_PXA688_MISC
+	ret = device_create_file(&pdev->dev, &dev_attr_misc);
+	if (ret < 0) {
+		pr_err("device attr misc create fail: %d\n", ret);
+		return ret;
+	}
+#endif
+
+	ret = device_create_file(&pdev->dev, &dev_attr_lcd);
+	if (ret < 0) {
+		pr_err("device attr lcd create fail: %d\n", ret);
+		goto failed_free_irq;
+	}
+
+	ret = device_create_file(&pdev->dev, &dev_attr_vsync);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		goto failed_free_irq;
+	}
+
+	if (!fbi->id) {
+		ret = device_create_file(&pdev->dev, &dev_attr_itc);
+		if (ret < 0) {
+			pr_err("device attr create fail: %d\n", ret);
+			return ret;
+		}
+	}
+
+
+	INIT_WORK(&fbi->uevent_work, vsync_uevent_worker);
+#ifdef CONFIG_ANDROID
+	if (fbi->fb_start && (!fbi->id || !fb_share)) {
+		fb_prepare_logo(info, 0);
+		fb_show_logo(info, 0);
+		/* The size of frambuffer is too large to use
+		 * dma_alloc_writecombine to alloc non-cacheable dma buffer,
+		 * we use __get_free_pages instead. Therefore, it needs
+		 * flushing cache after frambuffer filled. Otherwise, the
+		 * logo data would lose some lines in cache when begins
+		 * to display */
+		flush_cache_all();
+	}
+#endif
 	return 0;
 
+failed_free_irq:
+	free_irq(irq, fbi);
 failed_free_cmap:
 	fb_dealloc_cmap(&info->cmap);
 failed_free_clk:
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_lock_destroy(&fbi->idle_lock);
+#else
+	pm_qos_remove_request(&fbi->qos_idle_fb);
+#endif
 	clk_disable(fbi->clk);
-failed_free_fbmem:
-	dma_free_coherent(fbi->dev, info->fix.smem_len,
-			info->screen_base, fbi->fb_start_dma);
+	dma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),
+				info->screen_base, info->fix.smem_start);
 failed_free_info:
+	platform_set_drvdata(pdev, NULL);
+
+	if (fbi && fbi->reg_base) {
+		iounmap(fbi->reg_base);
+		kfree(fbi);
+	}
 	kfree(info);
 failed_put_clk:
 	clk_put(clk);
+	pr_err("pxa168-fb: frame buffer device init failed\n");
 
-	dev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);
 	return ret;
 }
 
@@ -794,24 +2390,33 @@ static int __devexit pxa168fb_remove(struct platform_device *pdev)
 		return 0;
 
 	/* disable DMA transfer */
-	data = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	data &= ~CFG_GRA_ENA_MASK;
-	writel(data, fbi->reg_base + LCD_SPU_DMA_CTRL0);
 
-	info = fbi->info;
+	data = dma_ctrl_read(fbi->id, 0);
+	data &= ~0x00000100;
+	dma_ctrl_write(fbi->id, 0, data);
+
+	info = fbi->fb_info;
 
 	unregister_framebuffer(info);
 
-	writel(GRA_FRAME_IRQ0_ENA(0x0), fbi->reg_base + SPU_IRQ_ENA);
+	irq_mask_set(fbi->id, 0xffffffff, 0);
 
 	if (info->cmap.len)
 		fb_dealloc_cmap(&info->cmap);
 
 	irq = platform_get_irq(pdev, 0);
+	free_irq(irq, fbi);
 
+#if defined(CONFIG_WAKELOCK) && defined(CONFIG_CPU_PXA910)
+	wake_lock_destroy(&fbi->idle_lock);
+#else
+	pm_qos_remove_request(&fbi->qos_idle_fb);
+#endif
 	dma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),
 				info->screen_base, info->fix.smem_start);
 
+	iounmap(fbi->reg_base);
+
 	clk_disable(fbi->clk);
 	clk_put(fbi->clk);
 
@@ -827,11 +2432,26 @@ static struct platform_driver pxa168fb_driver = {
 	},
 	.probe		= pxa168fb_probe,
 	.remove		= __devexit_p(pxa168fb_remove),
+#ifdef CONFIG_PM
+#ifndef CONFIG_HAS_EARLYSUSPEND
+	.suspend	= pxa168fb_suspend,
+	.resume		= pxa168fb_resume,
+#endif
+#endif
 };
 
-module_platform_driver(pxa168fb_driver);
+static int __devinit pxa168fb_init(void)
+{
+	return platform_driver_register(&pxa168fb_driver);
+}
+module_init(pxa168fb_init);
+
+static void __exit pxa168fb_exit(void)
+{
+	platform_driver_unregister(&pxa168fb_driver);
+}
+module_exit(pxa168fb_exit);
 
-MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com> "
-	      "Green Wan <gwan@marvell.com>");
-MODULE_DESCRIPTION("Framebuffer driver for PXA168/910");
+MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for PXA168");
 MODULE_LICENSE("GPL");
diff --git a/drivers/video/pxa168fb.h b/drivers/video/pxa168fb.h
index eee0927..70ed9df 100644
--- a/drivers/video/pxa168fb.h
+++ b/drivers/video/pxa168fb.h
@@ -1,39 +1,225 @@
-#ifndef __PXA168FB_H__
-#define __PXA168FB_H__
+/*
+ * linux/include/video/dovefbreg.h -- Marvell frame buffer for DOVE
+ *
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * Written by Green Wan <gwan@marvell.com>
+ *
+ * Adapted from:  linux/drivers/video/skeletonfb.c
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ *
+ */
+#ifndef _PXA168FB_H_
+#define _PXA168FB_H_
 
 /* ------------< LCD register >------------ */
+struct lcd_regs {
+/* TV patch register for MMP2 */
+/* 32 bit		TV Video Frame0 Y Starting Address */
+#define LCD_TVD_START_ADDR_Y0			(0x0000)
+/* 32 bit		TV Video Frame0 U Starting Address */
+#define LCD_TVD_START_ADDR_U0			(0x0004)
+/* 32 bit		TV Video Frame0 V Starting Address */
+#define LCD_TVD_START_ADDR_V0			(0x0008)
+/* 32 bit		TV Video Frame0 Command Starting Address */
+#define LCD_TVD_START_ADDR_C0			(0x000C)
+/* 32 bit		TV Video Frame1 Y Starting Address Register*/
+#define LCD_TVD_START_ADDR_Y1			(0x0010)
+/* 32 bit		TV Video Frame1 U Starting Address Register*/
+#define LCD_TVD_START_ADDR_U1			(0x0014)
+/* 32 bit		TV Video Frame1 V Starting Address Register*/
+#define LCD_TVD_START_ADDR_V1			(0x0018)
+/* 32 bit		TV Video Frame1 Command Starting Address Register*/
+#define LCD_TVD_START_ADDR_C1			(0x001C)
+/* 32 bit		TV Video Y andC Line Length(Pitch)Register*/
+#define LCD_TVD_PITCH_YC			(0x0020)
+/* 32 bit		TV Video U andV Line Length(Pitch)Register*/
+#define LCD_TVD_PITCH_UV			(0x0024)
+/* 32 bit	  TV Video Starting Point on Screen Register*/
+#define LCD_TVD_OVSA_HPXL_VLN			(0x0028)
+/* 32 bit		TV Video Source Size Register*/
+#define LCD_TVD_HPXL_VLN			(0x002C)
+/* 32 bit	  TV Video Destination Size (After Zooming)Register*/
+#define LCD_TVDZM_HPXL_VLN			(0x0030)
+	u32 v_y0;
+	u32 v_u0;
+	u32 v_v0;
+	u32 v_c0;
+	u32 v_y1;
+	u32 v_u1;
+	u32 v_v1;
+	u32 v_c1;
+	u32 v_pitch_yc;		/* Video Y and C Line Length (Pitch) */
+	u32 v_pitch_uv;		/* Video U and V Line Length (Pitch) */
+	u32 v_start;		/* Video Starting Point on Screen */
+	u32 v_size;			/* Video Source Size */
+	u32 v_size_z;		/* Video Destination Size (After Zooming) */
+
+/* 32 bit	   TV Graphic Frame 0 Starting Address Register*/
+#define LCD_TVG_START_ADDR0				(0x0034)
+/* 32 bit	  TV Graphic Frame 1 Starting Address Register*/
+#define LCD_TVG_START_ADDR1				(0x0038)
+/* 32 bit		TV Graphic Line Length(Pitch)Register*/
+#define LCD_TVG_PITCH					(0x003C)
+/* 32 bit		TV Graphic Starting Point on Screen Register*/
+#define LCD_TVG_OVSA_HPXL_VLN				(0x0040)
+/* 32 bit		TV Graphic Source Size Register*/
+#define LCD_TVG_HPXL_VLN				(0x0044)
+/* 32 bit		TV Graphic Destination size (after Zooming)Register*/
+#define LCD_TVGZM_HPXL_VLN				(0x0048)
+	u32 g_0;			/* Graphic Frame 0/1 Starting Address */
+	u32 g_1;
+	u32 g_pitch;		/* Graphic Line Length (Pitch) */
+	u32 g_start;		/* Graphic Starting Point on Screen */
+	u32 g_size;			/* Graphic Source Size */
+	u32 g_size_z;		/* Graphic Destination Size (After Zooming) */
+
+/* 32 bit	  TV Hardware Cursor Starting Point on screen Register*/
+#define LCD_TVC_OVSA_HPXL_VLN				(0x004C)
+/* 32 bit		TV Hardware Cursor Size Register */
+#define LCD_TVC_HPXL_VLN				(0x0050)
+	u32 hc_start;			/* Hardware Cursor */
+	u32 hc_size;			/* Hardware Cursor */
+
+/* 32 bit		TV Total Screen Size Register*/
+#define LCD_TV_V_H_TOTAL				(0x0054)
+/* 32 bit		TV Screen Active Size Register*/
+#define LCD_TV_V_H_ACTIVE				(0x0058)
+/* 32 bit		TV Screen Horizontal Porch Register*/
+#define LCD_TV_H_PORCH					(0x005C)
+/* 32 bit		TV Screen Vertical Porch Register*/
+#define LCD_TV_V_PORCH					(0x0060)
+	u32 screen_size;		/* Screen Total Size */
+	u32 screen_active;		/* Screen Active Size */
+	u32 screen_h_porch;		/* Screen Horizontal Porch */
+	u32 screen_v_porch;		/* Screen Vertical Porch */
+
+/* 32 bit		TV Screen Blank Color Register*/
+#define LCD_TV_BLANKCOLOR				(0x0064)
+/* 32 bit		TV Hardware Cursor Color1 Register*/
+#define LCD_TV_ALPHA_COLOR1				(0x0068)
+/* 32 bit		TV Hardware Cursor Color2 Register*/
+#define LCD_TV_ALPHA_COLOR2				(0x006C)
+	u32 blank_color;		/* Screen Blank Color */
+	u32 hc_Alpha_color1;	/* Hardware Cursor Color1 */
+	u32 hc_Alpha_color2;	/* Hardware Cursor Color2 */
+
+/* 32 bit		TV Video Y Color Key Control*/
+#define LCD_TV_COLORKEY_Y				(0x0070)
+/* 32 bit		TV Video U Color Key Control*/
+#define LCD_TV_COLORKEY_U				(0x0074)
+/* 32 bit		TV Video V Color Key Control*/
+#define LCD_TV_COLORKEY_V				(0x0078)
+	u32 v_colorkey_y;		/* Video Y Color Key Control */
+	u32 v_colorkey_u;		/* Video U Color Key Control */
+	u32 v_colorkey_v;		/* Video V Color Key Control */
+
+/* 32 bit		TV VSYNC PulsePixel Edge Control Register*/
+#define LCD_TV_SEPXLCNT					(0x007C)
+	u32 vsync_ctrl;			/* VSYNC PulsePixel Edge Control */
+};
+
+#define intf_ctrl(id)		((id) ? (((id) & 1) ? LCD_TVIF_CTRL : \
+				LCD_DUMB2_CTRL) : LCD_SPU_DUMB_CTRL)
+#define dma_ctrl0(id)	   ((id) ? (((id) & 1) ? LCD_TV_CTRL0 : \
+				LCD_PN2_CTRL0) : LCD_SPU_DMA_CTRL0)
+#define dma_ctrl1(id)	   ((id) ? (((id) & 1) ? LCD_TV_CTRL1 : \
+				LCD_PN2_CTRL1) : LCD_SPU_DMA_CTRL1)
+#define dma_ctrl(ctrl1, id)	 (ctrl1 ? dma_ctrl1(id) : dma_ctrl0(id))
+
+/* 32 bit		TV Path DMA Control 0*/
+#define LCD_TV_CTRL0					(0x0080)
+/* 32 bit		TV Path DMA Control 1*/
+#define LCD_TV_CTRL1					(0x0084)
+/* 32 bit		TV Path Video Contrast*/
+#define LCD_TV_CONTRAST					(0x0088)
+/* 32 bit		TV Path Video Saturation*/
+#define LCD_TV_SATURATION				(0x008C)
+/* 32 bit		TV Path Video Hue Adjust*/
+#define LCD_TV_CBSH_HUE					(0x0090)
+/* 32 bit TV Path TVIF Control	Register */
+#define LCD_TVIF_CTRL					(0x0094)
+#define TV_VBLNK_VALID_EN				(1 << 12)
+
+/* 32 bit TV Path I/O Pad Control*/
+#define LCD_TVIOPAD_CTRL				(0x0098)
+/* 32 bit TV Path Cloc	Divider  */
+#define LCD_TCLK_DIV					(0x009C)
+
+/* dither configure */
+#ifdef CONFIG_CPU_PXA988
+#define LCD_DITHER_CTRL				(0x01EC)
+#else
+#define LCD_DITHER_CTRL				(0x00A0)
+#endif
+
+#define DITHER_TBL_INDEX_SEL(s)		((s) << 16)
+#define DITHER_MODE2(m)				((m) << 12)
+#define DITHER_MODE2_SHIFT			(12)
+#define DITHER_4X8_EN2				(1 << 9)
+#define DITHER_4X8_EN2_SHIFT		(9)
+#define DITHER_EN2					(1 << 8)
+#define DITHER_MODE1(m)				((m) << 4)
+#define DITHER_MODE1_SHIFT			(4)
+#define DITHER_4X8_EN1				(1 << 1)
+#define DITHER_4X8_EN1_SHIFT		(1)
+#define DITHER_EN1					(1)
+
+/* dither table data was fixed by video bpp of input and output*/
+#ifdef CONFIG_CPU_PXA988
+#define DITHER_TB_4X4_INDEX0		(0x6e4ca280)
+#define DITHER_TB_4X4_INDEX1		(0x5d7f91b3)
+#define DITHER_TB_4X8_INDEX0		(0xb391a280)
+#define DITHER_TB_4X8_INDEX1		(0x7f5d6e4c)
+#define DITHER_TB_4X8_INDEX2		(0x80a291b3)
+#define DITHER_TB_4X8_INDEX3		(0x4c6e5d7f)
+#define LCD_DITHER_TBL_DATA		(0x01F0)
+#else
+#define DITHER_TB_4X4_INDEX0		(0x3b19f7d5)
+#define DITHER_TB_4X4_INDEX1		(0x082ac4e6)
+#define DITHER_TB_4X8_INDEX0		(0xf7d508e6)
+#define DITHER_TB_4X8_INDEX1		(0x3b194c2a)
+#define DITHER_TB_4X8_INDEX2		(0xc4e6d5f7)
+#define DITHER_TB_4X8_INDEX3		(0x082a193b)
+#define LCD_DITHER_TBL_DATA		(0x00A4)
+#endif
+
 /* Video Frame 0&1 start address registers */
-#define	LCD_SPU_DMA_START_ADDR_Y0		0x00C0
-#define	LCD_SPU_DMA_START_ADDR_U0		0x00C4
-#define	LCD_SPU_DMA_START_ADDR_V0		0x00C8
-#define LCD_CFG_DMA_START_ADDR_0		0x00CC /* Cmd address */
-#define	LCD_SPU_DMA_START_ADDR_Y1		0x00D0
-#define	LCD_SPU_DMA_START_ADDR_U1		0x00D4
-#define	LCD_SPU_DMA_START_ADDR_V1		0x00D8
-#define LCD_CFG_DMA_START_ADDR_1		0x00DC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y0	0x00C0
+#define	LCD_SPU_DMA_START_ADDR_U0	0x00C4
+#define	LCD_SPU_DMA_START_ADDR_V0	0x00C8
+#define LCD_CFG_DMA_START_ADDR_0	0x00CC /* Cmd address */
+#define	LCD_SPU_DMA_START_ADDR_Y1	0x00D0
+#define	LCD_SPU_DMA_START_ADDR_U1	0x00D4
+#define	LCD_SPU_DMA_START_ADDR_V1	0x00D8
+#define LCD_CFG_DMA_START_ADDR_1	0x00DC /* Cmd address */
 
 /* YC & UV Pitch */
-#define LCD_SPU_DMA_PITCH_YC			0x00E0
-#define     SPU_DMA_PITCH_C(c)			((c) << 16)
-#define     SPU_DMA_PITCH_Y(y)			(y)
-#define LCD_SPU_DMA_PITCH_UV			0x00E4
-#define     SPU_DMA_PITCH_V(v)			((v) << 16)
-#define     SPU_DMA_PITCH_U(u)			(u)
+#define LCD_SPU_DMA_PITCH_YC		0x00E0
+#define	 SPU_DMA_PITCH_C(c)		((c)<<16)
+#define	 SPU_DMA_PITCH_Y(y)		(y)
+#define LCD_SPU_DMA_PITCH_UV		0x00E4
+#define	 SPU_DMA_PITCH_V(v)		((v)<<16)
+#define	 SPU_DMA_PITCH_U(u)		(u)
 
 /* Video Starting Point on Screen Register */
 #define LCD_SPUT_DMA_OVSA_HPXL_VLN		0x00E8
-#define     CFG_DMA_OVSA_VLN(y)			((y) << 16) /* 0~0xfff */
-#define     CFG_DMA_OVSA_HPXL(x)		(x)     /* 0~0xfff */
+#define	 CFG_DMA_OVSA_VLN(y)			((y)<<16) /* 0~0xfff */
+#define	 CFG_DMA_OVSA_HPXL(x)			(x)	 /* 0~0xfff */
 
 /* Video Size Register */
 #define LCD_SPU_DMA_HPXL_VLN			0x00EC
-#define     CFG_DMA_VLN(y)			((y) << 16)
-#define     CFG_DMA_HPXL(x)			(x)
+#define	 CFG_DMA_VLN(y)				((y)<<16)
+#define	 CFG_DMA_HPXL(x)			(x)
 
 /* Video Size After zooming Register */
 #define LCD_SPU_DZM_HPXL_VLN			0x00F0
-#define     CFG_DZM_VLN(y)			((y) << 16)
-#define     CFG_DZM_HPXL(x)			(x)
+#define	 CFG_DZM_VLN(y)				((y)<<16)
+#define	 CFG_DZM_HPXL(x)			(x)
 
 /* Graphic Frame 0&1 Starting Address Register */
 #define LCD_CFG_GRA_START_ADDR0			0x00F4
@@ -44,155 +230,191 @@
 
 /* Graphic Starting Point on Screen Register */
 #define LCD_SPU_GRA_OVSA_HPXL_VLN		0x0100
-#define     CFG_GRA_OVSA_VLN(y)			((y) << 16)
-#define     CFG_GRA_OVSA_HPXL(x)		(x)
+#define	 CFG_GRA_OVSA_VLN(y)			((y)<<16)
+#define	 CFG_GRA_OVSA_HPXL(x)			(x)
 
 /* Graphic Size Register */
 #define LCD_SPU_GRA_HPXL_VLN			0x0104
-#define     CFG_GRA_VLN(y)			((y) << 16)
-#define     CFG_GRA_HPXL(x)			(x)
+#define	 CFG_GRA_VLN(y)				((y)<<16)
+#define	 CFG_GRA_HPXL(x)			(x)
 
 /* Graphic Size after Zooming Register */
 #define LCD_SPU_GZM_HPXL_VLN			0x0108
-#define     CFG_GZM_VLN(y)			((y) << 16)
-#define     CFG_GZM_HPXL(x)			(x)
+#define	 CFG_GZM_VLN(y)				((y)<<16)
+#define	 CFG_GZM_HPXL(x)			(x)
 
 /* HW Cursor Starting Point on Screen Register */
 #define LCD_SPU_HWC_OVSA_HPXL_VLN		0x010C
-#define     CFG_HWC_OVSA_VLN(y)			((y) << 16)
-#define     CFG_HWC_OVSA_HPXL(x)		(x)
+#define	 CFG_HWC_OVSA_VLN(y)			((y)<<16)
+#define	 CFG_HWC_OVSA_HPXL(x)			(x)
 
 /* HW Cursor Size */
 #define LCD_SPU_HWC_HPXL_VLN			0x0110
-#define     CFG_HWC_VLN(y)			((y) << 16)
-#define     CFG_HWC_HPXL(x)			(x)
+#define	 CFG_HWC_VLN(y)				((y)<<16)
+#define	 CFG_HWC_HPXL(x)			(x)
 
 /* Total Screen Size Register */
 #define LCD_SPUT_V_H_TOTAL			0x0114
-#define     CFG_V_TOTAL(y)			((y) << 16)
-#define     CFG_H_TOTAL(x)			(x)
+#define	 CFG_V_TOTAL(y)				((y)<<16)
+#define	 CFG_H_TOTAL(x)				(x)
 
 /* Total Screen Active Size Register */
 #define LCD_SPU_V_H_ACTIVE			0x0118
-#define     CFG_V_ACTIVE(y)			((y) << 16)
-#define     CFG_H_ACTIVE(x)			(x)
+#define	 CFG_V_ACTIVE(y)			((y)<<16)
+#define	 CFG_H_ACTIVE(x)			(x)
 
 /* Screen H&V Porch Register */
 #define LCD_SPU_H_PORCH				0x011C
-#define     CFG_H_BACK_PORCH(b)			((b) << 16)
-#define     CFG_H_FRONT_PORCH(f)		(f)
+#define	 CFG_H_BACK_PORCH(b)			((b)<<16)
+#define	 CFG_H_FRONT_PORCH(f)			(f)
 #define LCD_SPU_V_PORCH				0x0120
-#define     CFG_V_BACK_PORCH(b)			((b) << 16)
-#define     CFG_V_FRONT_PORCH(f)		(f)
+#define	 CFG_V_BACK_PORCH(b)			((b)<<16)
+#define	 CFG_V_FRONT_PORCH(f)			(f)
 
 /* Screen Blank Color Register */
 #define LCD_SPU_BLANKCOLOR			0x0124
-#define     CFG_BLANKCOLOR_MASK			0x00FFFFFF
-#define     CFG_BLANKCOLOR_R_MASK		0x000000FF
-#define     CFG_BLANKCOLOR_G_MASK		0x0000FF00
-#define     CFG_BLANKCOLOR_B_MASK		0x00FF0000
+#define  CFG_BLANKCOLOR_MASK			0x00FFFFFF
+#define  CFG_BLANKCOLOR_R_MASK			0x000000FF
+#define  CFG_BLANKCOLOR_G_MASK			0x0000FF00
+#define  CFG_BLANKCOLOR_B_MASK			0x00FF0000
 
 /* HW Cursor Color 1&2 Register */
 #define LCD_SPU_ALPHA_COLOR1			0x0128
-#define     CFG_HWC_COLOR1			0x00FFFFFF
-#define     CFG_HWC_COLOR1_R(red)		((red) << 16)
-#define     CFG_HWC_COLOR1_G(green)		((green) << 8)
-#define     CFG_HWC_COLOR1_B(blue)		(blue)
-#define     CFG_HWC_COLOR1_R_MASK		0x000000FF
-#define     CFG_HWC_COLOR1_G_MASK		0x0000FF00
-#define     CFG_HWC_COLOR1_B_MASK		0x00FF0000
+#define	 CFG_HWC_COLOR1				0x00FFFFFF
+#define	 CFG_HWC_COLOR1_R(red)			((red)<<16)
+#define	 CFG_HWC_COLOR1_G(green)		((green)<<8)
+#define	 CFG_HWC_COLOR1_B(blue)			(blue)
+#define	 CFG_HWC_COLOR1_R_MASK			0x000000FF
+#define	 CFG_HWC_COLOR1_G_MASK			0x0000FF00
+#define	 CFG_HWC_COLOR1_B_MASK			0x00FF0000
 #define LCD_SPU_ALPHA_COLOR2			0x012C
-#define     CFG_HWC_COLOR2			0x00FFFFFF
-#define     CFG_HWC_COLOR2_R_MASK		0x000000FF
-#define     CFG_HWC_COLOR2_G_MASK		0x0000FF00
-#define     CFG_HWC_COLOR2_B_MASK		0x00FF0000
+#define	 CFG_HWC_COLOR2				0x00FFFFFF
+#define	 CFG_HWC_COLOR2_R_MASK			0x000000FF
+#define	 CFG_HWC_COLOR2_G_MASK			0x0000FF00
+#define	 CFG_HWC_COLOR2_B_MASK			0x00FF0000
 
 /* Video YUV Color Key Control */
 #define LCD_SPU_COLORKEY_Y			0x0130
-#define     CFG_CKEY_Y2(y2)			((y2) << 24)
-#define     CFG_CKEY_Y2_MASK			0xFF000000
-#define     CFG_CKEY_Y1(y1)			((y1) << 16)
-#define     CFG_CKEY_Y1_MASK			0x00FF0000
-#define     CFG_CKEY_Y(y)			((y) << 8)
-#define     CFG_CKEY_Y_MASK			0x0000FF00
-#define     CFG_ALPHA_Y(y)			(y)
-#define     CFG_ALPHA_Y_MASK			0x000000FF
+#define	 CFG_CKEY_Y2(y2)			((y2)<<24)
+#define	 CFG_CKEY_Y2_MASK			0xFF000000
+#define	 CFG_CKEY_Y1(y1)			((y1)<<16)
+#define	 CFG_CKEY_Y1_MASK			0x00FF0000
+#define	 CFG_CKEY_Y(y)				((y)<<8)
+#define	 CFG_CKEY_Y_MASK			0x0000FF00
+#define	 CFG_ALPHA_Y(y)				(y)
+#define	 CFG_ALPHA_Y_MASK			0x000000FF
 #define LCD_SPU_COLORKEY_U			0x0134
-#define     CFG_CKEY_U2(u2)			((u2) << 24)
-#define     CFG_CKEY_U2_MASK			0xFF000000
-#define     CFG_CKEY_U1(u1)			((u1) << 16)
-#define     CFG_CKEY_U1_MASK			0x00FF0000
-#define     CFG_CKEY_U(u)			((u) << 8)
-#define     CFG_CKEY_U_MASK			0x0000FF00
-#define     CFG_ALPHA_U(u)			(u)
-#define     CFG_ALPHA_U_MASK			0x000000FF
+#define	 CFG_CKEY_U2(u2)			((u2)<<24)
+#define	 CFG_CKEY_U2_MASK			0xFF000000
+#define	 CFG_CKEY_U1(u1)			((u1)<<16)
+#define	 CFG_CKEY_U1_MASK			0x00FF0000
+#define	 CFG_CKEY_U(u)				((u)<<8)
+#define	 CFG_CKEY_U_MASK			0x0000FF00
+#define	 CFG_ALPHA_U(u)				(u)
+#define	 CFG_ALPHA_U_MASK			0x000000FF
 #define LCD_SPU_COLORKEY_V			0x0138
-#define     CFG_CKEY_V2(v2)			((v2) << 24)
-#define     CFG_CKEY_V2_MASK			0xFF000000
-#define     CFG_CKEY_V1(v1)			((v1) << 16)
-#define     CFG_CKEY_V1_MASK			0x00FF0000
-#define     CFG_CKEY_V(v)			((v) << 8)
-#define     CFG_CKEY_V_MASK			0x0000FF00
-#define     CFG_ALPHA_V(v)			(v)
-#define     CFG_ALPHA_V_MASK			0x000000FF
+#define	 CFG_CKEY_V2(v2)			((v2)<<24)
+#define	 CFG_CKEY_V2_MASK			0xFF000000
+#define	 CFG_CKEY_V1(v1)			((v1)<<16)
+#define	 CFG_CKEY_V1_MASK			0x00FF0000
+#define	 CFG_CKEY_V(v)				((v)<<8)
+#define	 CFG_CKEY_V_MASK			0x0000FF00
+#define	 CFG_ALPHA_V(v)				(v)
+#define	 CFG_ALPHA_V_MASK			0x000000FF
+
+/* Graphics/Video DMA color key enable bits in LCD_TV_CTRL1 */
+#define	 CFG_CKEY_GRA				0x2
+#define	 CFG_CKEY_DMA				0x1
+
+/* Interlace mode enable bits in LCD_TV_CTRL1 */
+#define     CFG_TV_INTERLACE_EN                 (1 << 22)
+#define     CFG_TV_NIB                          (1 << 0)
+
+#define LCD_PN_SEPXLCNT				0x013c /* MMP2 */
 
 /* SPI Read Data Register */
 #define LCD_SPU_SPI_RXDATA			0x0140
 
 /* Smart Panel Read Data Register */
 #define LCD_SPU_ISA_RSDATA			0x0144
-#define     ISA_RXDATA_16BIT_1_DATA_MASK	0x000000FF
-#define     ISA_RXDATA_16BIT_2_DATA_MASK	0x0000FF00
-#define     ISA_RXDATA_16BIT_3_DATA_MASK	0x00FF0000
-#define     ISA_RXDATA_16BIT_4_DATA_MASK	0xFF000000
-#define     ISA_RXDATA_32BIT_1_DATA_MASK	0x00FFFFFF
+#define	 ISA_RXDATA_16BIT_1_DATA_MASK		0x000000FF
+#define	 ISA_RXDATA_16BIT_2_DATA_MASK		0x0000FF00
+#define	 ISA_RXDATA_16BIT_3_DATA_MASK		0x00FF0000
+#define	 ISA_RXDATA_16BIT_4_DATA_MASK		0xFF000000
+#define	 ISA_RXDATA_32BIT_1_DATA_MASK		0x00FFFFFF
+
+#define LCD_SPU_DBG_ISA				(0x0148) /* TTC */
+#define LCD_SPU_DMAVLD_YC			(0x014C)
+#define LCD_SPU_DMAVLD_UV			(0x0150)
+#define LCD_SPU_DMAVLD_UVSPU_GRAVLD		(0x0154)
+
+#define LCD_READ_IOPAD				(0x0148) /* MMP2*/
+#define LCD_DMAVLD_YC				(0x014C)
+#define LCD_DMAVLD_UV				(0x0150)
+#define LCD_TVGGRAVLD_HLEN			(0x0154)
 
 /* HWC SRAM Read Data Register */
 #define LCD_SPU_HWC_RDDAT			0x0158
 
 /* Gamma Table SRAM Read Data Register */
 #define LCD_SPU_GAMMA_RDDAT			0x015c
-#define     CFG_GAMMA_RDDAT_MASK		0x000000FF
+#define	 CFG_GAMMA_RDDAT_MASK			0x000000FF
 
 /* Palette Table SRAM Read Data Register */
 #define LCD_SPU_PALETTE_RDDAT			0x0160
-#define     CFG_PALETTE_RDDAT_MASK		0x00FFFFFF
+#define	 CFG_PALETTE_RDDAT_MASK			0x00FFFFFF
+
+#define LCD_SPU_DBG_DMATOP			(0x0164) /* TTC */
+#define LCD_SPU_DBG_GRATOP			(0x0168)
+#define LCD_SPU_DBG_TXCTRL			(0x016C)
+#define LCD_SPU_DBG_SLVTOP			(0x0170)
+#define LCD_SPU_DBG_MUXTOP			(0x0174)
+
+#define LCD_SLV_DBG				(0x0164) /* MMP2 */
+#define LCD_TVDVLD_YC				(0x0168)
+#define LCD_TVDVLD_UV				(0x016C)
+#define LCD_TVC_RDDAT				(0x0170)
+#define LCD_TV_GAMMA_RDDAT			(0x0174)
 
 /* I/O Pads Input Read Only Register */
 #define LCD_SPU_IOPAD_IN			0x0178
-#define     CFG_IOPAD_IN_MASK			0x0FFFFFFF
+#define	 CFG_IOPAD_IN_MASK			0x0FFFFFFF
+
+#define LCD_TV_PALETTE_RDDAT			(0x0178) /* MMP2 */
 
 /* Reserved Read Only Registers */
 #define LCD_CFG_RDREG5F				0x017C
-#define     IRE_FRAME_CNT_MASK			0x000000C0
-#define     IPE_FRAME_CNT_MASK			0x00000030
-#define     GRA_FRAME_CNT_MASK			0x0000000C  /* Graphic */
-#define     DMA_FRAME_CNT_MASK			0x00000003  /* Video */
+#define	 IRE_FRAME_CNT_MASK			0x000000C0
+#define	 IPE_FRAME_CNT_MASK			0x00000030
+#define	 GRA_FRAME_CNT_MASK			0x0000000C /* Graphic */
+#define	 DMA_FRAME_CNT_MASK			0x00000003 /* Video */
+
+#define LCD_FRAME_CNT				(0x017C) /* MMP2 */
 
 /* SPI Control Register. */
 #define LCD_SPU_SPI_CTRL			0x0180
-#define     CFG_SCLKCNT(div)			((div) << 24)  /* 0xFF~0x2 */
-#define     CFG_SCLKCNT_MASK			0xFF000000
-#define     CFG_RXBITS(rx)			((rx) << 16)   /* 0x1F~0x1 */
-#define     CFG_RXBITS_MASK			0x00FF0000
-#define     CFG_TXBITS(tx)			((tx) << 8)    /* 0x1F~0x1 */
-#define     CFG_TXBITS_MASK			0x0000FF00
-#define     CFG_CLKINV(clk)			((clk) << 7)
-#define     CFG_CLKINV_MASK			0x00000080
-#define     CFG_KEEPXFER(transfer)		((transfer) << 6)
-#define     CFG_KEEPXFER_MASK			0x00000040
-#define     CFG_RXBITSTO0(rx)			((rx) << 5)
-#define     CFG_RXBITSTO0_MASK			0x00000020
-#define     CFG_TXBITSTO0(tx)			((tx) << 4)
-#define     CFG_TXBITSTO0_MASK			0x00000010
-#define     CFG_SPI_ENA(spi)			((spi) << 3)
-#define     CFG_SPI_ENA_MASK			0x00000008
-#define     CFG_SPI_SEL(spi)			((spi) << 2)
-#define     CFG_SPI_SEL_MASK			0x00000004
-#define     CFG_SPI_3W4WB(wire)			((wire) << 1)
-#define     CFG_SPI_3W4WB_MASK			0x00000002
-#define     CFG_SPI_START(start)		(start)
-#define     CFG_SPI_START_MASK			0x00000001
+#define	 CFG_SCLKCNT(div)			((div)<<24) /* 0xFF~0x2 */
+#define	 CFG_SCLKCNT_MASK			0xFF000000
+#define	 CFG_RXBITS(rx)				(((rx) - 1)<<16) /* 0x1F~0x1 */
+#define	 CFG_RXBITS_MASK			0x00FF0000
+#define	 CFG_TXBITS(tx)				(((tx) - 1)<<8) /* 0x1F~0x1 */
+#define	 CFG_TXBITS_MASK			0x0000FF00
+#define	 CFG_CLKINV(clk)			((clk)<<7)
+#define	 CFG_CLKINV_MASK			0x00000080
+#define	 CFG_KEEPXFER(transfer)			((transfer)<<6)
+#define	 CFG_KEEPXFER_MASK			0x00000040
+#define	 CFG_RXBITSTO0(rx)			((rx)<<5)
+#define	 CFG_RXBITSTO0_MASK			0x00000020
+#define	 CFG_TXBITSTO0(tx)			((tx)<<4)
+#define	 CFG_TXBITSTO0_MASK			0x00000010
+#define	 CFG_SPI_ENA(spi)			((spi)<<3)
+#define	 CFG_SPI_ENA_MASK			0x00000008
+#define	 CFG_SPI_SEL(spi)			((spi)<<2)
+#define	 CFG_SPI_SEL_MASK			0x00000004
+#define	 CFG_SPI_3W4WB(wire)			((wire)<<1)
+#define	 CFG_SPI_3W4WB_MASK			0x00000002
+#define	 CFG_SPI_START(start)			(start)
+#define	 CFG_SPI_START_MASK			0x00000001
 
 /* SPI Tx Data Register */
 #define LCD_SPU_SPI_TXDATA			0x0184
@@ -205,97 +427,113 @@
 
 /* DMA Control 0 Register */
 #define LCD_SPU_DMA_CTRL0			0x0190
-#define     CFG_NOBLENDING(nb)			((nb) << 31)
-#define     CFG_NOBLENDING_MASK			0x80000000
-#define     CFG_GAMMA_ENA(gn)			((gn) << 30)
-#define     CFG_GAMMA_ENA_MASK			0x40000000
-#define     CFG_CBSH_ENA(cn)			((cn) << 29)
-#define     CFG_CBSH_ENA_MASK			0x20000000
-#define     CFG_PALETTE_ENA(pn)			((pn) << 28)
-#define     CFG_PALETTE_ENA_MASK		0x10000000
-#define     CFG_ARBFAST_ENA(an)			((an) << 27)
-#define     CFG_ARBFAST_ENA_MASK		0x08000000
-#define     CFG_HWC_1BITMOD(mode)		((mode) << 26)
-#define     CFG_HWC_1BITMOD_MASK		0x04000000
-#define     CFG_HWC_1BITENA(mn)			((mn) << 25)
-#define     CFG_HWC_1BITENA_MASK		0x02000000
-#define     CFG_HWC_ENA(cn)		        ((cn) << 24)
-#define     CFG_HWC_ENA_MASK			0x01000000
-#define     CFG_DMAFORMAT(dmaformat)		((dmaformat) << 20)
-#define     CFG_DMAFORMAT_MASK			0x00F00000
-#define     CFG_GRAFORMAT(graformat)		((graformat) << 16)
-#define     CFG_GRAFORMAT_MASK			0x000F0000
+#define	 CFG_NOBLENDING(nb)			((nb)<<31)
+#define	 CFG_NOBLENDING_MASK			0x80000000
+#define	 CFG_GAMMA_ENA(gn)			((gn)<<30)
+#define	 CFG_GAMMA_ENA_MASK			0x40000000
+#define	 CFG_CBSH_ENA(cn)			((cn)<<29)
+#define	 CFG_CBSH_ENA_MASK			0x20000000
+#define	 CFG_PALETTE_ENA(pn)			((pn)<<28)
+#define	 CFG_PALETTE_ENA_MASK			0x10000000
+#define	 CFG_ARBFAST_ENA(an)			((an)<<27)
+#define	 CFG_ARBFAST_ENA_MASK			0x08000000
+#define	 CFG_HWC_1BITMOD(mode)			((mode)<<26)
+#define	 CFG_HWC_1BITMOD_MASK			0x04000000
+#define	 CFG_HWC_1BITENA(mn)			((mn)<<25)
+#define	 CFG_HWC_1BITENA_MASK			0x02000000
+#define	 CFG_HWC_ENA(cn)			((cn)<<24)
+#define	 CFG_HWC_ENA_MASK			0x01000000
+#define	 CFG_DMAFORMAT(dmaformat)		((dmaformat)<<20)
+#define	 CFG_DMAFORMAT_MASK			0x00F00000
+#define	 CFG_GRAFORMAT(graformat)		((graformat)<<16)
+#define	 CFG_GRAFORMAT_MASK			0x000F0000
 /* for graphic part */
-#define     CFG_GRA_FTOGGLE(toggle)		((toggle) << 15)
-#define     CFG_GRA_FTOGGLE_MASK		0x00008000
-#define     CFG_GRA_HSMOOTH(smooth)		((smooth) << 14)
-#define     CFG_GRA_HSMOOTH_MASK		0x00004000
-#define     CFG_GRA_TSTMODE(test)		((test) << 13)
-#define     CFG_GRA_TSTMODE_MASK		0x00002000
-#define     CFG_GRA_SWAPRB(swap)		((swap) << 12)
-#define     CFG_GRA_SWAPRB_MASK			0x00001000
-#define     CFG_GRA_SWAPUV(swap)		((swap) << 11)
-#define     CFG_GRA_SWAPUV_MASK			0x00000800
-#define     CFG_GRA_SWAPYU(swap)		((swap) << 10)
-#define     CFG_GRA_SWAPYU_MASK			0x00000400
-#define     CFG_YUV2RGB_GRA(cvrt)		((cvrt) << 9)
-#define     CFG_YUV2RGB_GRA_MASK		0x00000200
-#define     CFG_GRA_ENA(gra)			((gra) << 8)
-#define     CFG_GRA_ENA_MASK			0x00000100
+#define	 CFG_GRA_FTOGGLE(toggle)		((toggle)<<15)
+#define	 CFG_GRA_FTOGGLE_MASK			0x00008000
+#define	 CFG_GRA_HSMOOTH(smooth)		((smooth)<<14)
+#define	 CFG_GRA_HSMOOTH_MASK			0x00004000
+#define	 CFG_GRA_TSTMODE(test)			((test)<<13)
+#define	 CFG_GRA_TSTMODE_MASK			0x00002000
+#define	 CFG_GRA_SWAPRB(swap)			((swap)<<12)
+#define	 CFG_GRA_SWAPRB_MASK			0x00001000
+#define	 CFG_GRA_SWAPUV(swap)			((swap)<<11)
+#define	 CFG_GRA_SWAPUV_MASK			0x00000800
+#define	 CFG_GRA_SWAPYU(swap)			((swap)<<10)
+#define	 CFG_GRA_SWAPYU_MASK			0x00000400
+#define	 CFG_GRA_SWAP_MASK			0x00001C00
+#define	 CFG_YUV2RGB_GRA(cvrt)			((cvrt)<<9)
+#define	 CFG_YUV2RGB_GRA_MASK			0x00000200
+#define	 CFG_GRA_ENA(gra)			((gra)<<8)
+#define	 CFG_GRA_ENA_MASK			0x00000100
+#define dma0_gfx_masks	(CFG_GRAFORMAT_MASK | CFG_GRA_FTOGGLE_MASK | \
+	CFG_GRA_HSMOOTH_MASK | CFG_GRA_TSTMODE_MASK | CFG_GRA_SWAP_MASK | \
+	CFG_YUV2RGB_GRA_MASK | CFG_GRA_ENA_MASK)
 /* for video part */
-#define     CFG_DMA_FTOGGLE(toggle)		((toggle) << 7)
-#define     CFG_DMA_FTOGGLE_MASK		0x00000080
-#define     CFG_DMA_HSMOOTH(smooth)		((smooth) << 6)
-#define     CFG_DMA_HSMOOTH_MASK		0x00000040
-#define     CFG_DMA_TSTMODE(test)		((test) << 5)
-#define     CFG_DMA_TSTMODE_MASK		0x00000020
-#define     CFG_DMA_SWAPRB(swap)		((swap) << 4)
-#define     CFG_DMA_SWAPRB_MASK			0x00000010
-#define     CFG_DMA_SWAPUV(swap)		((swap) << 3)
-#define     CFG_DMA_SWAPUV_MASK			0x00000008
-#define     CFG_DMA_SWAPYU(swap)		((swap) << 2)
-#define     CFG_DMA_SWAPYU_MASK			0x00000004
-#define     CFG_DMA_SWAP_MASK			0x0000001C
-#define     CFG_YUV2RGB_DMA(cvrt)		((cvrt) << 1)
-#define     CFG_YUV2RGB_DMA_MASK		0x00000002
-#define     CFG_DMA_ENA(video)			(video)
-#define     CFG_DMA_ENA_MASK			0x00000001
+#define	 CFG_DMA_FTOGGLE(toggle)		((toggle)<<7)
+#define	 CFG_DMA_FTOGGLE_MASK			0x00000080
+#define	 CFG_DMA_HSMOOTH(smooth)		((smooth)<<6)
+#define	 CFG_DMA_HSMOOTH_MASK			0x00000040
+#define	 CFG_DMA_TSTMODE(test)			((test)<<5)
+#define	 CFG_DMA_TSTMODE_MASK			0x00000020
+#define	 CFG_DMA_SWAPRB(swap)			((swap)<<4)
+#define	 CFG_DMA_SWAPRB_MASK			0x00000010
+#define	 CFG_DMA_SWAPUV(swap)			((swap)<<3)
+#define	 CFG_DMA_SWAPUV_MASK			0x00000008
+#define	 CFG_DMA_SWAPYU(swap)			((swap)<<2)
+#define	 CFG_DMA_SWAPYU_MASK			0x00000004
+#define	 CFG_DMA_SWAP_MASK			0x0000001C
+#define	 CFG_YUV2RGB_DMA(cvrt)			((cvrt)<<1)
+#define	 CFG_YUV2RGB_DMA_MASK			0x00000002
+#define	 CFG_DMA_ENA(video)			(video)
+#define	 CFG_DMA_ENA_MASK			0x00000001
+#define dma0_vid_masks	(CFG_DMAFORMAT_MASK | CFG_DMA_FTOGGLE_MASK | \
+	CFG_DMA_HSMOOTH_MASK | CFG_DMA_TSTMODE_MASK | CFG_DMA_SWAP_MASK | \
+	CFG_YUV2RGB_DMA_MASK | CFG_DMA_ENA_MASK)
+#define dma_palette(val)		((val ? 1 : 0) << 28)
+#define dma_fmt(vid, val)		((val & 0xf) << ((vid) ? 20 : 16))
+#define dma_swaprb(vid, val)		((val ? 1 : 0) << ((vid) ? 4 : 12))
+#define dma_swapuv(vid, val)		((val ? 1 : 0) << ((vid) ? 3 : 11))
+#define dma_swapyuv(vid, val)		((val ? 1 : 0) << ((vid) ? 2 : 10))
+#define dma_csc(vid, val)		((val ? 1 : 0) << ((vid) ? 1 : 9))
+#define dma_hsmooth(vid, val)		((val ? 1 : 0) << ((vid) ? 6 : 14))
+#define dma_mask(vid)	(dma_palette(1) | dma_fmt(vid, 0xf) | dma_csc(vid, 1) \
+	| dma_swaprb(vid, 1) | dma_swapuv(vid, 1) | dma_swapyuv(vid, 1))
 
 /* DMA Control 1 Register */
 #define LCD_SPU_DMA_CTRL1			0x0194
-#define     CFG_FRAME_TRIG(trig)		((trig) << 31)
-#define     CFG_FRAME_TRIG_MASK			0x80000000
-#define     CFG_VSYNC_TRIG(trig)		((trig) << 28)
-#define     CFG_VSYNC_TRIG_MASK			0x70000000
-#define     CFG_VSYNC_INV(inv)			((inv) << 27)
-#define     CFG_VSYNC_INV_MASK			0x08000000
-#define     CFG_COLOR_KEY_MODE(cmode)		((cmode) << 24)
-#define     CFG_COLOR_KEY_MASK			0x07000000
-#define     CFG_CARRY(carry)			((carry) << 23)
-#define     CFG_CARRY_MASK			0x00800000
-#define     CFG_LNBUF_ENA(lnbuf)		((lnbuf) << 22)
-#define     CFG_LNBUF_ENA_MASK			0x00400000
-#define     CFG_GATED_ENA(gated)		((gated) << 21)
-#define     CFG_GATED_ENA_MASK			0x00200000
-#define     CFG_PWRDN_ENA(power)		((power) << 20)
-#define     CFG_PWRDN_ENA_MASK			0x00100000
-#define     CFG_DSCALE(dscale)			((dscale) << 18)
-#define     CFG_DSCALE_MASK			0x000C0000
-#define     CFG_ALPHA_MODE(amode)		((amode) << 16)
-#define     CFG_ALPHA_MODE_MASK			0x00030000
-#define     CFG_ALPHA(alpha)			((alpha) << 8)
-#define     CFG_ALPHA_MASK			0x0000FF00
-#define     CFG_PXLCMD(pxlcmd)			(pxlcmd)
-#define     CFG_PXLCMD_MASK			0x000000FF
+#define	 CFG_FRAME_TRIG(trig)			((trig)<<31)
+#define	 CFG_FRAME_TRIG_MASK			0x80000000
+#define	 CFG_VSYNC_TRIG(trig)			((trig)<<28)
+#define	 CFG_VSYNC_TRIG_MASK			0x70000000
+#define	 CFG_VSYNC_INV(inv)			((inv)<<27)
+#define	 CFG_VSYNC_INV_MASK			0x08000000
+#define	 CFG_COLOR_KEY_MODE(cmode)		((cmode)<<24)
+#define	 CFG_COLOR_KEY_MASK			0x07000000
+#define	 CFG_CARRY(carry)			((carry)<<23)
+#define	 CFG_CARRY_MASK				0x00800000
+#define	 CFG_LNBUF_ENA(lnbuf)			((lnbuf)<<22)
+#define	 CFG_LNBUF_ENA_MASK			0x00400000
+#define	 CFG_GATED_ENA(gated)			((gated)<<21)
+#define	 CFG_GATED_ENA_MASK			0x00200000
+#define	 CFG_PWRDN_ENA(power)			((power)<<20)
+#define	 CFG_PWRDN_ENA_MASK			0x00100000
+#define	 CFG_DSCALE(dscale)			((dscale)<<18)
+#define	 CFG_DSCALE_MASK			0x000C0000
+#define	 CFG_ALPHA_MODE(amode)			((amode)<<16)
+#define	 CFG_ALPHA_MODE_MASK			0x00030000
+#define	 CFG_ALPHA(alpha)			((alpha)<<8)
+#define	 CFG_ALPHA_MASK				0x0000FF00
+#define	 CFG_PXLCMD(pxlcmd)			(pxlcmd)
+#define	 CFG_PXLCMD_MASK			0x000000FF
 
 /* SRAM Control Register */
 #define LCD_SPU_SRAM_CTRL			0x0198
-#define     CFG_SRAM_INIT_WR_RD(mode)		((mode) << 14)
-#define     CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
-#define     CFG_SRAM_ADDR_LCDID(id)		((id) << 8)
-#define     CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
-#define     CFG_SRAM_ADDR(addr)			(addr)
-#define     CFG_SRAM_ADDR_MASK			0x000000FF
+#define	 CFG_SRAM_INIT_WR_RD(mode)		((mode)<<14)
+#define	 CFG_SRAM_INIT_WR_RD_MASK		0x0000C000
+#define	 CFG_SRAM_ADDR_LCDID(id)		((id)<<8)
+#define	 CFG_SRAM_ADDR_LCDID_MASK		0x00000F00
+#define	 CFG_SRAM_ADDR(addr)			(addr)
+#define	 CFG_SRAM_ADDR_MASK			0x000000FF
 
 /* SRAM Write Data Register */
 #define LCD_SPU_SRAM_WRDAT			0x019C
@@ -305,178 +543,407 @@
 
 /* SRAM Power Down Control Register */
 #define LCD_SPU_SRAM_PARA1			0x01A4
-#define     CFG_CSB_256x32(hwc)			((hwc) << 15)	/* HWC */
-#define     CFG_CSB_256x32_MASK			0x00008000
-#define     CFG_CSB_256x24(palette)		((palette) << 14)	/* Palette */
-#define     CFG_CSB_256x24_MASK			0x00004000
-#define     CFG_CSB_256x8(gamma)		((gamma) << 13)	/* Gamma */
-#define     CFG_CSB_256x8_MASK			0x00002000
-#define     CFG_PDWN256x32(pdwn)		((pdwn) << 7)	/* HWC */
-#define     CFG_PDWN256x32_MASK			0x00000080
-#define     CFG_PDWN256x24(pdwn)		((pdwn) << 6)	/* Palette */
-#define     CFG_PDWN256x24_MASK			0x00000040
-#define     CFG_PDWN256x8(pdwn)			((pdwn) << 5)	/* Gamma */
-#define     CFG_PDWN256x8_MASK			0x00000020
-#define     CFG_PDWN32x32(pdwn)			((pdwn) << 3)
-#define     CFG_PDWN32x32_MASK			0x00000008
-#define     CFG_PDWN16x66(pdwn)			((pdwn) << 2)
-#define     CFG_PDWN16x66_MASK			0x00000004
-#define     CFG_PDWN32x66(pdwn)			((pdwn) << 1)
-#define     CFG_PDWN32x66_MASK			0x00000002
-#define     CFG_PDWN64x66(pdwn)			(pdwn)
-#define     CFG_PDWN64x66_MASK			0x00000001
+#define	 CFG_CSB_256x32(hwc)			((hwc)<<15)	/* HWC */
+#define	 CFG_CSB_256x32_MASK			0x00008000
+#define	 CFG_CSB_256x24(palette)		((palette)<<14)	/* Palette */
+#define	 CFG_CSB_256x24_MASK			0x00004000
+#define	 CFG_CSB_256x8(gamma)			((gamma)<<13)	/* Gamma */
+#define	 CFG_CSB_256x8_MASK			0x00002000
+#define	 CFG_PDWN256x32(pdwn)			((pdwn)<<7)	/* HWC */
+#define	 CFG_PDWN256x32_MASK			0x00000080
+#define	 CFG_PDWN256x24(pdwn)			((pdwn)<<6)	/* Palette */
+#define	 CFG_PDWN256x24_MASK			0x00000040
+#define	 CFG_PDWN256x8(pdwn)			((pdwn)<<5)	/* Gamma */
+#define	 CFG_PDWN256x8_MASK			0x00000020
+#define	 CFG_PDWN32x32(pdwn)			((pdwn)<<3)
+#define	 CFG_PDWN32x32_MASK			0x00000008
+#define	 CFG_PDWN16x66(pdwn)			((pdwn)<<2)
+#define	 CFG_PDWN16x66_MASK			0x00000004
+#define	 CFG_PDWN32x66(pdwn)			((pdwn)<<1)
+#define	 CFG_PDWN32x66_MASK			0x00000002
+#define	 CFG_PDWN64x66(pdwn)			(pdwn)
+#define	 CFG_PDWN64x66_MASK			0x00000001
 
 /* Smart or Dumb Panel Clock Divider */
 #define LCD_CFG_SCLK_DIV			0x01A8
-#define     SCLK_SOURCE_SELECT(src)		((src) << 31)
-#define     SCLK_SOURCE_SELECT_MASK		0x80000000
-#define     CLK_FRACDIV(frac)			((frac) << 16)
-#define     CLK_FRACDIV_MASK			0x0FFF0000
-#define     CLK_INT_DIV(div)			(div)
-#define     CLK_INT_DIV_MASK			0x0000FFFF
+#define	 SCLK_SOURCE_SELECT(src)		((src)<<31)
+#define	 SCLK_SOURCE_SELECT_MASK		0x80000000
+#define  SCLK_DISABLE				(1<<28)
+#define	 CLK_FRACDIV(frac)			((frac)<<16)
+#define	 CLK_FRACDIV_MASK			0x0FFF0000
+#define	 DSI1_BITCLK_DIV(div)			(div<<8)
+#define	 DSI1_BITCLK_DIV_MASK			0x00000F00
+#define	 CLK_INT_DIV(div)			(div)
+#define	 CLK_INT_DIV_MASK			0x000000FF
 
 /* Video Contrast Register */
 #define LCD_SPU_CONTRAST			0x01AC
-#define     CFG_BRIGHTNESS(bright)		((bright) << 16)
-#define     CFG_BRIGHTNESS_MASK			0xFFFF0000
-#define     CFG_CONTRAST(contrast)		(contrast)
-#define     CFG_CONTRAST_MASK			0x0000FFFF
+#define	 CFG_BRIGHTNESS(bright)			((bright)<<16)
+#define	 CFG_BRIGHTNESS_MASK			0xFFFF0000
+#define	 CFG_CONTRAST(contrast)			(contrast)
+#define	 CFG_CONTRAST_MASK			0x0000FFFF
 
 /* Video Saturation Register */
 #define LCD_SPU_SATURATION			0x01B0
-#define     CFG_C_MULTS(mult)			((mult) << 16)
-#define     CFG_C_MULTS_MASK			0xFFFF0000
-#define     CFG_SATURATION(sat)			(sat)
-#define     CFG_SATURATION_MASK			0x0000FFFF
+#define	 CFG_C_MULTS(mult)			((mult)<<16)
+#define	 CFG_C_MULTS_MASK			0xFFFF0000
+#define	 CFG_SATURATION(sat)			(sat)
+#define	 CFG_SATURATION_MASK			0x0000FFFF
 
 /* Video Hue Adjust Register */
 #define LCD_SPU_CBSH_HUE			0x01B4
-#define     CFG_SIN0(sin0)			((sin0) << 16)
-#define     CFG_SIN0_MASK			0xFFFF0000
-#define     CFG_COS0(con0)			(con0)
-#define     CFG_COS0_MASK			0x0000FFFF
+#define	 CFG_SIN0(sin0)				((sin0)<<16)
+#define	 CFG_SIN0_MASK				0xFFFF0000
+#define	 CFG_COS0(con0)				(con0)
+#define	 CFG_COS0_MASK				0x0000FFFF
 
 /* Dump LCD Panel Control Register */
 #define LCD_SPU_DUMB_CTRL			0x01B8
-#define     CFG_DUMBMODE(mode)			((mode) << 28)
-#define     CFG_DUMBMODE_MASK			0xF0000000
-#define     CFG_LCDGPIO_O(data)			((data) << 20)
-#define     CFG_LCDGPIO_O_MASK			0x0FF00000
-#define     CFG_LCDGPIO_ENA(gpio)		((gpio) << 12)
-#define     CFG_LCDGPIO_ENA_MASK		0x000FF000
-#define     CFG_BIAS_OUT(bias)			((bias) << 8)
-#define     CFG_BIAS_OUT_MASK			0x00000100
-#define     CFG_REVERSE_RGB(rRGB)		((rRGB) << 7)
-#define     CFG_REVERSE_RGB_MASK		0x00000080
-#define     CFG_INV_COMPBLANK(blank)		((blank) << 6)
-#define     CFG_INV_COMPBLANK_MASK		0x00000040
-#define     CFG_INV_COMPSYNC(sync)		((sync) << 5)
-#define     CFG_INV_COMPSYNC_MASK		0x00000020
-#define     CFG_INV_HENA(hena)			((hena) << 4)
-#define     CFG_INV_HENA_MASK			0x00000010
-#define     CFG_INV_VSYNC(vsync)		((vsync) << 3)
-#define     CFG_INV_VSYNC_MASK			0x00000008
-#define     CFG_INV_HSYNC(hsync)		((hsync) << 2)
-#define     CFG_INV_HSYNC_MASK			0x00000004
-#define     CFG_INV_PCLK(pclk)			((pclk) << 1)
-#define     CFG_INV_PCLK_MASK			0x00000002
-#define     CFG_DUMB_ENA(dumb)			(dumb)
-#define     CFG_DUMB_ENA_MASK			0x00000001
+#define	 CFG_DUMBMODE(mode)			((mode)<<28)
+#define	 CFG_DUMBMODE_MASK			0xF0000000
+#define	 CFG_LCDGPIO_O(data)			((data)<<20)
+#define	 CFG_LCDGPIO_O_MASK			0x0FF00000
+#define	 CFG_LCDGPIO_ENA(gpio)			((gpio)<<12)
+#define	 CFG_LCDGPIO_ENA_MASK			0x000FF000
+#define	 CFG_BIAS_OUT(bias)			((bias)<<8)
+#define	 CFG_BIAS_OUT_MASK			0x00000100
+#define	 CFG_REVERSE_RGB(rRGB)			((rRGB)<<7)
+#define	 CFG_REVERSE_RGB_MASK			0x00000080
+#define	 CFG_INV_COMPBLANK(blank)		((blank)<<6)
+#define	 CFG_INV_COMPBLANK_MASK			0x00000040
+#define	 CFG_INV_COMPSYNC(sync)			((sync)<<5)
+#define	 CFG_INV_COMPSYNC_MASK			0x00000020
+#define	 CFG_INV_HENA(hena)			((hena)<<4)
+#define	 CFG_INV_HENA_MASK			0x00000010
+#define	 CFG_INV_VSYNC(vsync)			((vsync)<<3)
+#define	 CFG_INV_VSYNC_MASK			0x00000008
+#define	 CFG_INV_HSYNC(hsync)			((hsync)<<2)
+#define	 CFG_INV_HSYNC_MASK			0x00000004
+#define	 CFG_INV_PCLK(pclk)			((pclk)<<1)
+#define	 CFG_INV_PCLK_MASK			0x00000002
+#define	 CFG_DUMB_ENA(dumb)			(dumb)
+#define	 CFG_DUMB_ENA_MASK			0x00000001
 
 /* LCD I/O Pads Control Register */
 #define SPU_IOPAD_CONTROL			0x01BC
-#define     CFG_GRA_VM_ENA(vm)			((vm) << 15)        /* gfx */
-#define     CFG_GRA_VM_ENA_MASK			0x00008000
-#define     CFG_DMA_VM_ENA(vm)			((vm) << 13)	/* video */
-#define     CFG_DMA_VM_ENA_MASK			0x00002000
-#define     CFG_CMD_VM_ENA(vm)			((vm) << 13)
-#define     CFG_CMD_VM_ENA_MASK			0x00000800
-#define     CFG_CSC(csc)			((csc) << 8)	/* csc */
-#define     CFG_CSC_MASK			0x00000300
-#define     CFG_AXICTRL(axi)			((axi) << 4)
-#define     CFG_AXICTRL_MASK			0x000000F0
-#define     CFG_IOPADMODE(iopad)		(iopad)
-#define     CFG_IOPADMODE_MASK			0x0000000F
+#define	 CFG_GRA_VM_ENA(vm)			((vm)<<15)
+#define	 CFG_GRA_VM_ENA_MASK			0x00008000
+#define	 CFG_DMA_VM_ENA(vm)			((vm)<<13)
+#define	 CFG_DMA_VM_ENA_MASK			0x00002000
+#define	 CFG_CMD_VM_ENA(vm)			((vm)<<13)
+#define	 CFG_CMD_VM_ENA_MASK			0x00000800
+#define	 CFG_CSC(csc)				((csc)<<8)
+#define	 CFG_CSC_MASK				0x00000300
+#define	 CFG_CYC_BURST_LEN16			(1<<4)
+#define	 CFG_CYC_BURST_LEN8			(0<<4)
+#define	 CFG_IOPADMODE(iopad)			(iopad)
+#define	 CFG_IOPADMODE_MASK			0x0000000F
 
 /* LCD Interrupt Control Register */
 #define SPU_IRQ_ENA				0x01C0
-#define     DMA_FRAME_IRQ0_ENA(irq)		((irq) << 31)
-#define     DMA_FRAME_IRQ0_ENA_MASK		0x80000000
-#define     DMA_FRAME_IRQ1_ENA(irq)		((irq) << 30)
-#define     DMA_FRAME_IRQ1_ENA_MASK		0x40000000
-#define     DMA_FF_UNDERFLOW_ENA(ff)		((ff) << 29)
-#define     DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
-#define     GRA_FRAME_IRQ0_ENA(irq)		((irq) << 27)
-#define     GRA_FRAME_IRQ0_ENA_MASK		0x08000000
-#define     GRA_FRAME_IRQ1_ENA(irq)		((irq) << 26)
-#define     GRA_FRAME_IRQ1_ENA_MASK		0x04000000
-#define     GRA_FF_UNDERFLOW_ENA(ff)		((ff) << 25)
-#define     GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
-#define     VSYNC_IRQ_ENA(vsync_irq)		((vsync_irq) << 23)
-#define     VSYNC_IRQ_ENA_MASK			0x00800000
-#define     DUMB_FRAMEDONE_ENA(fdone)		((fdone) << 22)
-#define     DUMB_FRAMEDONE_ENA_MASK		0x00400000
-#define     TWC_FRAMEDONE_ENA(fdone)		((fdone) << 21)
-#define     TWC_FRAMEDONE_ENA_MASK		0x00200000
-#define     HWC_FRAMEDONE_ENA(fdone)		((fdone) << 20)
-#define     HWC_FRAMEDONE_ENA_MASK		0x00100000
-#define     SLV_IRQ_ENA(irq)			((irq) << 19)
-#define     SLV_IRQ_ENA_MASK			0x00080000
-#define     SPI_IRQ_ENA(irq)			((irq) << 18)
-#define     SPI_IRQ_ENA_MASK			0x00040000
-#define     PWRDN_IRQ_ENA(irq)			((irq) << 17)
-#define     PWRDN_IRQ_ENA_MASK			0x00020000
-#define     ERR_IRQ_ENA(irq)			((irq) << 16)
-#define     ERR_IRQ_ENA_MASK			0x00010000
-#define     CLEAN_SPU_IRQ_ISR(irq)		(irq)
-#define     CLEAN_SPU_IRQ_ISR_MASK		0x0000FFFF
+#define	 DMA_FRAME_IRQ0_ENA(irq)		((irq)<<31)
+#define	 DMA_FRAME_IRQ0_ENA_MASK		0x80000000
+#define	 DMA_FRAME_IRQ1_ENA(irq)		((irq)<<30)
+#define	 DMA_FRAME_IRQ1_ENA_MASK		0x40000000
+#define	 DMA_FF_UNDERFLOW_ENA(ff)		((ff)<<29)
+#define	 DMA_FF_UNDERFLOW_ENA_MASK		0x20000000
+#define	 AXI_BUS_ERROR_IRQ_ENA(irq)		((irq)<<28)
+#define	 AXI_BUS_ERROR_IRQ_ENA_MASK		0x10000000
+#define	 GRA_FRAME_IRQ0_ENA(irq)		((irq)<<27)
+#define	 GRA_FRAME_IRQ0_ENA_MASK		0x08000000
+#define	 GRA_FRAME_IRQ1_ENA(irq)		((irq)<<26)
+#define	 GRA_FRAME_IRQ1_ENA_MASK		0x04000000
+#define	 GRA_FF_UNDERFLOW_ENA(ff)		((ff)<<25)
+#define	 GRA_FF_UNDERFLOW_ENA_MASK		0x02000000
+#define	 VSYNC_IRQ_ENA(vsync_irq)		((vsync_irq)<<23)
+#define	 VSYNC_IRQ_ENA_MASK			0x00800000
+#define	 DUMB_FRAMEDONE_ENA(fdone)		((fdone)<<22)
+#define	 DUMB_FRAMEDONE_ENA_MASK		0x00400000
+#define	 TWC_FRAMEDONE_ENA(fdone)		((fdone)<<21)
+#define	 TWC_FRAMEDONE_ENA_MASK			0x00200000
+#define	 HWC_FRAMEDONE_ENA(fdone)		((fdone)<<20)
+#define	 HWC_FRAMEDONE_ENA_MASK			0x00100000
+#define	 SLV_IRQ_ENA(irq)			((irq)<<19)
+#define	 SLV_IRQ_ENA_MASK			0x00080000
+#define	 SPI_IRQ_ENA(irq)			((irq)<<18)
+#define	 SPI_IRQ_ENA_MASK			0x00040000
+#define	 PWRDN_IRQ_ENA(irq)			((irq)<<17)
+#define	 PWRDN_IRQ_ENA_MASK			0x00020000
+#define	 AXI_LATENCY_TOO_LONG_IRQ_ENA(irq)	((irq)<<16)
+#define  AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK	0x00010000
+#define	 CLEAN_SPU_IRQ_ISR(irq)			(irq)
+#define	 CLEAN_SPU_IRQ_ISR_MASK			0x0000FFFF
+#define	 TV_DMA_FRAME_IRQ0_ENA(irq)		((irq)<<15)
+#define	 TV_DMA_FRAME_IRQ0_ENA_MASK		0x00008000
+#define	 TV_DMA_FRAME_IRQ1_ENA(irq)		((irq)<<14)
+#define	 TV_DMA_FRAME_IRQ1_ENA_MASK		0x00004000
+#define	 TV_DMA_FF_UNDERFLOW_ENA(unerrun)	((unerrun)<<13)
+#define	 TV_DMA_FF_UNDERFLOW_ENA_MASK		0x00002000
+#define	 TVSYNC_IRQ_ENA(irq)			((irq)<<12)
+#define	 TVSYNC_IRQ_ENA_MASK			0x00001000
+#define	 TV_FRAME_IRQ0_ENA(irq)			((irq)<<11)
+#define	 TV_FRAME_IRQ0_ENA_MASK			0x00000800
+#define	 TV_FRAME_IRQ1_ENA(irq)			((irq)<<10)
+#define	 TV_FRAME_IRQ1_ENA_MASK			0x00000400
+#define	 TV_GRA_FF_UNDERFLOW_ENA(unerrun)	((unerrun)<<9)
+#define	 TV_GRA_FF_UNDERFLOW_ENA_MASK		0x00000200
+#define	 TV_FRAMEDONE_ENA(irq)			((irq)<<8)
+#define	 TV_FRAMEDONE_ENA_MASK			0x00000100
+
+/* FIXME - JUST GUESS */
+#define	 PN2_DMA_FRAME_IRQ0_ENA(irq)		((irq)<<7)
+#define	 PN2_DMA_FRAME_IRQ0_ENA_MASK		0x00000080
+#define	 PN2_DMA_FRAME_IRQ1_ENA(irq)		((irq)<<6)
+#define	 PN2_DMA_FRAME_IRQ1_ENA_MASK		0x00000040
+#define	 PN2_DMA_FF_UNDERFLOW_ENA(ff)		((ff)<<5)
+#define	 PN2_DMA_FF_UNDERFLOW_ENA_MASK		0x00000020
+#define	 PN2_GRA_FRAME_IRQ0_ENA(irq)		((irq)<<3)
+#define	 PN2_GRA_FRAME_IRQ0_ENA_MASK		0x00000008
+#define	 PN2_GRA_FRAME_IRQ1_ENA(irq)		((irq)<<2)
+#define	 PN2_GRA_FRAME_IRQ1_ENA_MASK		0x04000004
+#define	 PN2_GRA_FF_UNDERFLOW_ENA(ff)		((ff)<<1)
+#define	 PN2_GRA_FF_UNDERFLOW_ENA_MASK		0x00000002
+#define	 PN2_VSYNC_IRQ_ENA(irq)			((irq)<<0)
+#define	 PN2_SYNC_IRQ_ENA_MASK			0x00000001
 
+#define gf0_imask(id)	((id) ? (((id) & 1) ? TV_FRAME_IRQ0_ENA_MASK \
+		: PN2_GRA_FRAME_IRQ0_ENA_MASK) : GRA_FRAME_IRQ0_ENA_MASK)
+#define gf1_imask(id)	((id) ? (((id) & 1) ? TV_FRAME_IRQ1_ENA_MASK \
+		: PN2_GRA_FRAME_IRQ1_ENA_MASK) : GRA_FRAME_IRQ1_ENA_MASK)
+#define vsync_imask(id)	((id) ? (((id) & 1) ? TVSYNC_IRQ_ENA_MASK \
+		: PN2_SYNC_IRQ_ENA_MASK) : VSYNC_IRQ_ENA_MASK)
+#define vsync_imasks	(vsync_imask(0) | vsync_imask(1))
+
+#define display_done_imask(id)	((id) ? (((id) & 1) ? TV_FRAMEDONE_ENA_MASK\
+	: (PN2_DMA_FRAME_IRQ0_ENA_MASK | PN2_DMA_FRAME_IRQ1_ENA_MASK))\
+	: DUMB_FRAMEDONE_ENA_MASK)
+
+#define display_done_imasks	(display_done_imask(0) | display_done_imask(1))
+
+#define vf0_imask(id)	((id) ? (((id) & 1) ? TV_DMA_FRAME_IRQ0_ENA_MASK \
+		: PN2_DMA_FRAME_IRQ0_ENA_MASK) : DMA_FRAME_IRQ0_ENA_MASK)
+#define vf1_imask(id)	((id) ? (((id) & 1) ? TV_DMA_FRAME_IRQ1_ENA_MASK \
+		: PN2_DMA_FRAME_IRQ1_ENA_MASK) : DMA_FRAME_IRQ1_ENA_MASK)
+
+#define gfx_imasks	(gf0_imask(0) | gf1_imask(0) | gf0_imask(1) | \
+		gf1_imask(1))
+#define vid_imasks	(vf0_imask(0) | vf1_imask(0) | vf0_imask(1) | \
+		vf1_imask(1))
+#define vid_imask(id)	(display_done_imask(id))
+
+#define pn1_imasks	(gf0_imask(0) | gf1_imask(0) | vsync_imask(0) | \
+		display_done_imask(0) | vf0_imask(0) | vf1_imask(0))
+#define tv_imasks	(gf0_imask(1) | gf1_imask(1) | vsync_imask(1) | \
+		display_done_imask(1) | vf0_imask(1) | vf1_imask(1))
+#define path_imasks(id)	((id) ? (tv_imasks) : (pn1_imasks))
+
+/* error indications */
+#define vid_udflow_imask(id)	((id) ? (((id) & 1) ? \
+	(TV_DMA_FF_UNDERFLOW_ENA_MASK) : (PN2_DMA_FF_UNDERFLOW_ENA_MASK)) : \
+	(DMA_FF_UNDERFLOW_ENA_MASK))
+#define gfx_udflow_imask(id)	((id) ? (((id) & 1) ? \
+	(TV_GRA_FF_UNDERFLOW_ENA_MASK) : (PN2_GRA_FF_UNDERFLOW_ENA_MASK)) : \
+	(GRA_FF_UNDERFLOW_ENA_MASK))
+
+#define err_imask(id) (vid_udflow_imask(id) | gfx_udflow_imask(id) | \
+	AXI_BUS_ERROR_IRQ_ENA_MASK | AXI_LATENCY_TOO_LONG_IRQ_ENA_MASK)
+#define err_imasks (err_imask(0) | err_imask(1) | err_imask(2))
 /* LCD Interrupt Status Register */
-#define SPU_IRQ_ISR				0x01C4
-#define     DMA_FRAME_IRQ0(irq)			((irq) << 31)
-#define     DMA_FRAME_IRQ0_MASK			0x80000000
-#define     DMA_FRAME_IRQ1(irq)			((irq) << 30)
-#define     DMA_FRAME_IRQ1_MASK			0x40000000
-#define     DMA_FF_UNDERFLOW(ff)		((ff) << 29)
-#define     DMA_FF_UNDERFLOW_MASK		0x20000000
-#define     GRA_FRAME_IRQ0(irq)			((irq) << 27)
-#define     GRA_FRAME_IRQ0_MASK			0x08000000
-#define     GRA_FRAME_IRQ1(irq)			((irq) << 26)
-#define     GRA_FRAME_IRQ1_MASK			0x04000000
-#define     GRA_FF_UNDERFLOW(ff)		((ff) << 25)
-#define     GRA_FF_UNDERFLOW_MASK		0x02000000
-#define     VSYNC_IRQ(vsync_irq)		((vsync_irq) << 23)
-#define     VSYNC_IRQ_MASK			0x00800000
-#define     DUMB_FRAMEDONE(fdone)		((fdone) << 22)
-#define     DUMB_FRAMEDONE_MASK			0x00400000
-#define     TWC_FRAMEDONE(fdone)		((fdone) << 21)
-#define     TWC_FRAMEDONE_MASK			0x00200000
-#define     HWC_FRAMEDONE(fdone)		((fdone) << 20)
-#define     HWC_FRAMEDONE_MASK			0x00100000
-#define     SLV_IRQ(irq)			((irq) << 19)
-#define     SLV_IRQ_MASK			0x00080000
-#define     SPI_IRQ(irq)			((irq) << 18)
-#define     SPI_IRQ_MASK			0x00040000
-#define     PWRDN_IRQ(irq)			((irq) << 17)
-#define     PWRDN_IRQ_MASK			0x00020000
-#define     ERR_IRQ(irq)			((irq) << 16)
-#define     ERR_IRQ_MASK			0x00010000
+#define SPU_IRQ_ISR			0x01C4
+#define	 DMA_FRAME_IRQ0(irq)		((irq)<<31)
+#define	 DMA_FRAME_IRQ0_MASK		0x80000000
+#define	 DMA_FRAME_IRQ1(irq)		((irq)<<30)
+#define	 DMA_FRAME_IRQ1_MASK		0x40000000
+#define	 DMA_FF_UNDERFLOW(ff)		((ff)<<29)
+#define	 DMA_FF_UNDERFLOW_MASK		0x20000000
+#define	 AXI_BUS_ERROR_IRQ(irq)		((irq)<<28)
+#define	 AXI_BUS_ERROR_IRQ_MASK		0x10000000
+#define	 GRA_FRAME_IRQ0(irq)		((irq)<<27)
+#define	 GRA_FRAME_IRQ0_MASK		0x08000000
+#define	 GRA_FRAME_IRQ1(irq)		((irq)<<26)
+#define	 GRA_FRAME_IRQ1_MASK		0x04000000
+#define	 GRA_FF_UNDERFLOW(ff)		((ff)<<25)
+#define	 GRA_FF_UNDERFLOW_MASK		0x02000000
+#define	 VSYNC_IRQ(vsync_irq)		((vsync_irq)<<23)
+#define	 VSYNC_IRQ_MASK			0x00800000
+#define	 DUMB_FRAMEDONE(fdone)		((fdone)<<22)
+#define	 DUMB_FRAMEDONE_MASK		0x00400000
+#define	 TWC_FRAMEDONE(fdone)		((fdone)<<21)
+#define	 TWC_FRAMEDONE_MASK		0x00200000
+#define	 HWC_FRAMEDONE(fdone)		((fdone)<<20)
+#define	 HWC_FRAMEDONE_MASK		0x00100000
+#define	 SLV_IRQ(irq)			((irq)<<19)
+#define	 SLV_IRQ_MASK			0x00080000
+#define	 SPI_IRQ(irq)			((irq)<<18)
+#define	 SPI_IRQ_MASK			0x00040000
+#define	 PWRDN_IRQ(irq)			((irq)<<17)
+#define	 PWRDN_IRQ_MASK			0x00020000
+#define	 AXI_LATENCY_TOO_LONGR_IRQ(irq)	((irq)<<16)
+#define	 AXI_LATENCY_TOO_LONGR_IRQ_MASK	0x00010000
+#define	 TV_DMA_FRAME_IRQ0(irq)		((irq)<<15)
+#define	 TV_DMA_FRAME_IRQ0_MASK		0x00008000
+#define	 TV_DMA_FRAME_IRQ1(irq)		((irq)<<14)
+#define	 TV_DMA_FRAME_IRQ1_MASK		0x00004000
+#define	 TV_DMA_FF_UNDERFLOW(unerrun)	((unerrun)<<13)
+#define	 TV_DMA_FF_UNDERFLOW_MASK	0x00002000
+#define	 TVSYNC_IRQ(irq)		((irq)<<12)
+#define	 TVSYNC_IRQ_MASK		0x00001000
+#define	 TV_FRAME_IRQ0(irq)		((irq)<<11)
+#define	 TV_FRAME_IRQ0_MASK		0x00000800
+#define	 TV_FRAME_IRQ1(irq)		((irq)<<10)
+#define	 TV_FRAME_IRQ1_MASK		0x00000400
+#define	 TV_GRA_FF_UNDERFLOW(unerrun)	((unerrun)<<9)
+#define	 TV_GRA_FF_UNDERFLOW_MASK	0x00000200
+#define	 PN2_DMA_FRAME_IRQ0(irq)	((irq)<<7)
+#define	 PN2_DMA_FRAME_IRQ0_MASK	0x00000080
+#define	 PN2_DMA_FRAME_IRQ1(irq)	((irq)<<6)
+#define	 PN2_DMA_FRAME_IRQ1_MASK	0x00000040
+#define	 PN2_DMA_FF_UNDERFLOW(ff)	((ff)<<5)
+#define	 PN2_DMA_FF_UNDERFLOW_MASK	0x00000020
+#define	 PN2_GRA_FRAME_IRQ0(irq)	((irq)<<3)
+#define	 PN2_GRA_FRAME_IRQ0_MASK	0x00000008
+#define	 PN2_GRA_FRAME_IRQ1(irq)	((irq)<<2)
+#define	 PN2_GRA_FRAME_IRQ1_MASK	0x04000004
+#define	 PN2_GRA_FF_UNDERFLOW(ff)	((ff)<<1)
+#define	 PN2_GRA_FF_UNDERFLOW_MASK	0x00000002
+#define	 PN2_VSYNC_IRQ(irq)		((irq)<<0)
+#define	 PN2_SYNC_IRQ_MASK		0x00000001
+
+/* LCD FIFO Depth register */
+#define LCD_FIFO_DEPTH			0x01c8
+#define	 VIDEO_FIFO(fi)			((fi) << 0)
+#define	 VIDEO_FIFO_MASK		0x00000003
+#define	 GRAPHIC_FIFO(fi)		((fi) << 2)
+#define	 GRAPHIC_FIFO_MASK		0x0000000c
+
 /* read-only */
-#define     DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
-#define     DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
-#define     DMA_FRAME_CNT_ISR_MASK		0x00003000
-#define     GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
-#define     GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
-#define     GRA_FRAME_CNT_ISR_MASK		0x00000300
-#define     VSYNC_IRQ_LEVEL_MASK		0x00000080
-#define     DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
-#define     TWC_FRAMEDONE_LEVEL_MASK		0x00000020
-#define     HWC_FRAMEDONE_LEVEL_MASK		0x00000010
-#define     SLV_FF_EMPTY_MASK			0x00000008
-#define     DMA_FF_ALLEMPTY_MASK		0x00000004
-#define     GRA_FF_ALLEMPTY_MASK		0x00000002
-#define     PWRDN_IRQ_LEVEL_MASK		0x00000001
+#define	 DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
+#define	 DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
+#define	 DMA_FRAME_CNT_ISR_MASK			0x00003000
+#define	 GRA_FRAME_IRQ0_LEVEL_MASK		0x00000800
+#define	 GRA_FRAME_IRQ1_LEVEL_MASK		0x00000400
+#define	 GRA_FRAME_CNT_ISR_MASK			0x00000300
+#define	 VSYNC_IRQ_LEVEL_MASK			0x00000080
+#define	 DUMB_FRAMEDONE_LEVEL_MASK		0x00000040
+#define	 TWC_FRAMEDONE_LEVEL_MASK		0x00000020
+#define	 HWC_FRAMEDONE_LEVEL_MASK		0x00000010
+#define	 SLV_FF_EMPTY_MASK			0x00000008
+#define	 DMA_FF_ALLEMPTY_MASK			0x00000004
+#define	 GRA_FF_ALLEMPTY_MASK			0x00000002
+#define	 PWRDN_IRQ_LEVEL_MASK			0x00000001
+
+/* 32 bit LCD Interrupt Reset Status*/
+#define SPU_IRQ_RSR				(0x01C8)
+/* 32 bit Panel Path Graphic Partial Display Horizontal Control Register*/
+#define LCD_GRA_CUTHPXL				(0x01CC)
+/* 32 bit Panel Path Graphic Partial Display Vertical Control Register*/
+#define LCD_GRA_CUTVLN				(0x01D0)
+/* 32 bit TV Path Graphic Partial Display	  Horizontal Control Register*/
+#define LCD_TVG_CUTHPXL				(0x01D4)
+/* 32 bit TV Path Graphic Partial Display Vertical Control Register*/
+#define LCD_TVG_CUTVLN				(0x01D8)
+/* 32 bit LCD Global Control Register*/
+#define LCD_TOP_CTRL				(0x01DC)
+/* 32 bit LCD SQU Line Buffer Control Register 1*/
+#define LCD_SQULN1_CTRL				(0x01E0)
+/* 32 bit LCD SQU Line Buffer Control Register 2*/
+#define LCD_SQULN2_CTRL				(0x01E4)
+#define squln_ctrl(id)	((id) ? (((id) & 1) ? LCD_SQULN2_CTRL : \
+			LCD_PN2_SQULN1_CTRL) : LCD_SQULN1_CTRL)
+
+/* 32 bit LCD Mixed Overlay Control Register */
+#define LCD_AFA_ALL2ONE				(0x01E8)
+
+#define LCD_PN2_SCLK_DIV			(0x01EC)
+#define LCD_PN2_TCLK_DIV			(0x01F0)
+#define LCD_LVDS_SCLK_DIV_WR			(0x01F4)
+#define LCD_LVDS_SCLK_DIV_RD			(0x01FC)
+#define PN2_LCD_DMA_START_ADDR_Y0		(0x0200)
+#define PN2_LCD_DMA_START_ADDR_U0		(0x0204)
+#define PN2_LCD_DMA_START_ADDR_V0		(0x0208)
+#define PN2_LCD_DMA_START_ADDR_C0		(0x020C)
+#define PN2_LCD_DMA_START_ADDR_Y1		(0x0210)
+#define PN2_LCD_DMA_START_ADDR_U1		(0x0214)
+#define PN2_LCD_DMA_START_ADDR_V1		(0x0218)
+#define PN2_LCD_DMA_START_ADDR_C1		(0x021C)
+#define PN2_LCD_DMA_PITCH_YC			(0x0220)
+#define PN2_LCD_DMA_PITCH_UV			(0x0224)
+#define PN2_LCD_DMA_OVSA_HPXL_VLN		(0x0228)
+#define PN2_LCD_DMA_HPXL_VLN			(0x022C)
+#define PN2_LCD_DMAZM_HPXL_VLN			(0x0230)
+#define PN2_LCD_GRA_START_ADDR0			(0x0234)
+#define PN2_LCD_GRA_START_ADDR1			(0x0238)
+#define PN2_LCD_GRA_PITCH			(0x023C)
+#define PN2_LCD_GRA_OVSA_HPXL_VLN		(0x0240)
+#define PN2_LCD_GRA_HPXL_VLN			(0x0244)
+#define PN2_LCD_GRAZM_HPXL_VLN			(0x0248)
+#define PN2_LCD_HWC_OVSA_HPXL_VLN		(0x024C)
+#define PN2_LCD_HWC_HPXL_VLN			(0x0250)
+#define LCD_PN2_V_H_TOTAL			(0x0254)
+#define LCD_PN2_V_H_ACTIVE			(0x0258)
+#define LCD_PN2_H_PORCH				(0x025C)
+#define LCD_PN2_V_PORCH				(0x0260)
+#define LCD_PN2_BLANKCOLOR			(0x0264)
+#define LCD_PN2_ALPHA_COLOR1			(0x0268)
+#define LCD_PN2_ALPHA_COLOR2			(0x026C)
+#define LCD_PN2_COLORKEY_Y			(0x0270)
+#define LCD_PN2_COLORKEY_U			(0x0274)
+#define LCD_PN2_COLORKEY_V			(0x0278)
+#define LCD_PN2_SEPXLCNT			(0x027C)
+#define LCD_TV_V_H_TOTAL_FLD			(0x0280)
+#define LCD_TV_V_PORCH_FLD			(0x0284)
+#define LCD_TV_SEPXLCNT_FLD			(0x0288)
 
+#define LCD_2ND_ALPHA				(0x0294)
+#define LCD_PN2_CONTRAST			(0x0298)
+#define LCD_PN2_SATURATION			(0x029c)
+#define LCD_PN2_CBSH_HUE			(0x02a0)
+#define LCD_TIMING_EXT				(0x02C0)
+#define LCD_PN2_LAYER_ALPHA_SEL1		(0x02c4)
+#define LCD_PN2_CTRL0				(0x02C8)
+#define TV_LAYER_ALPHA_SEL1			(0x02cc)
+#define LCD_SMPN2_CTRL				(0x02D0)
+#define LCD_IO_OVERL_MAP_CTRL			(0x02D4)
+#define LCD_DUMB2_CTRL				(0x02d8)
+#define LCD_PN2_CTRL1				(0x02DC)
+#define PN2_IOPAD_CONTROL			(0x02E0)
+#define LCD_PN2_SQULN1_CTRL			(0x02E4)
+#define PN2_LCD_GRA_CUTHPXL			(0x02e8)
+#define PN2_LCD_GRA_CUTVLN			(0x02ec)
+#define LCD_PN2_SQULN2_CTRL			(0x02F0)
+#define ALL_LAYER_ALPHA_SEL			(0x02F4)
+
+/* pxa988 has different MASTER_CTRL from MMP3/MMP2 */
+#ifdef CONFIG_CPU_PXA988
+#define TIMING_MASTER_CONTROL			(0x01F4)
+#define MASTER_ENH(id)				(1 << ((id) + 4))
+#define MASTER_ENV(id)				(1 << ((id) + 6))
+#else
+#define TIMING_MASTER_CONTROL			(0x02F8)
+#define MASTER_ENH(id)				(1 << (id))
+#define MASTER_ENV(id)				(1 << ((id) + 4))
+#endif
+
+#define DSI_START_SEL_SHIFT(id)		(((id) << 1) + 8)
+#define timing_master_config(path, dsi_id, lcd_id) \
+	(MASTER_ENH(path) | MASTER_ENV(path) | \
+	(((lcd_id) + ((dsi_id) << 1)) << DSI_START_SEL_SHIFT(path)))
+
+#define LCD_2ND_BLD_CTL				(0x02Fc)
+#define LVDS_SRC_MASK				(3 << 30)
+#define LVDS_SRC_SHIFT				(30)
+#define LVDS_FMT_MASK				(1 << 28)
+#define LVDS_FMT_SHIFT				(28)
+
+#define clk_sclk	(1 << 0)
+#define clk_tclk	(1 << 1)
+#define clk_lvds_rd	(1 << 2)
+#define clk_lvds_wr	(1 << 3)
+
+#define gra_partdisp_ctrl_hor(id)	((id) ? (((id) & 1) ? \
+	LCD_TVG_CUTHPXL : PN2_LCD_GRA_CUTHPXL) : LCD_GRA_CUTHPXL)
+#define gra_partdisp_ctrl_ver(id)	((id) ? (((id) & 1) ? \
+	LCD_TVG_CUTVLN : PN2_LCD_GRA_CUTVLN) : LCD_GRA_CUTVLN)
 
 /*
  * defined Video Memory Color format for DMA control 0 register
@@ -555,4 +1022,841 @@
 #define IOPAD_SMART16SPI	0x7
 #define IOPAD_SMART8BOTH	0x8
 
-#endif /* __PXA168FB_H__ */
+/*
+ * defined Dumb Panel Clock Divider register
+ * SCLK_Source bit[31]
+ */
+ /* 0: PLL clock select*/
+#define AXI_BUS_SEL			0x80000000
+#define CCD_CLK_SEL			0x40000000
+#define DCON_CLK_SEL			0x20000000
+#define ENA_CLK_INT_DIV			CONFIG_FB_DOVE_CLCD_SCLK_DIV
+#define IDLE_CLK_INT_DIV		0x1	  /* idle Integer Divider */
+#define DIS_CLK_INT_DIV			0x0	  /* Disable Integer Divider */
+
+/* SRAM ID */
+#define SRAMID_gamma_yr			0x0
+#define SRAMID_gamma_ug			0x1
+#define SRAMID_gamma_vb			0x2
+#define SRAMID_palette			0x3
+#define SRAMID_hwc			0xf
+
+/* SRAM INIT Read/Write */
+#define SRAMID_INIT_READ		0x0
+#define SRAMID_INIT_WRITE		0x2
+#define SRAMID_INIT_DEFAULT		0x3
+
+/*
+ * defined VSYNC selection mode for DMA control 1 register
+ * DMA1 bit[30:28]
+ */
+#define VMODE_SMPN			0x0
+#define VMODE_SMPNIRQ			0x1
+#define VMODE_DUMB			0x2
+#define VMODE_IPE			0x3
+#define VMODE_IRE			0x4
+
+/*
+ * defined Configure Alpha and Alpha mode for DMA control 1 register
+ * DMA1 bit[15:08](alpha) / bit[17:16](alpha mode)
+ */
+/* ALPHA mode */
+#define MODE_ALPHA_DMA			0x0
+#define MODE_ALPHA_GRA			0x1
+#define MODE_ALPHA_CFG			0x2
+
+/* alpha value */
+#define ALPHA_NOGRAPHIC			0xFF	  /* all video, no graphic */
+#define ALPHA_NOVIDEO			0x00	  /* all graphic, no video */
+#define ALPHA_GRAPHnVIDEO		0x0F	  /* Selects graphic & video */
+
+/*
+ * defined Pixel Command for DMA control 1 register
+ * DMA1 bit[07:00]
+ */
+#define PIXEL_CMD			0x81
+
+/* DSI */
+/* DSI1 - 4 Lane Controller base */
+#define DSI1_REGS_PHYSICAL_BASE		0xD420B800
+/* DSI2 - 3 Lane Controller base */
+#define DSI2_REGS_PHYSICAL_BASE		0xD420BA00
+
+/*	   DSI Controller Registers	   */
+struct dsi_lcd_regs {
+#define DSI_LCD1_CTRL_0  0x100   /* DSI Active Panel 1 Control register 0 */
+#define DSI_LCD1_CTRL_1  0x104   /* DSI Active Panel 1 Control register 1 */
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 reserved1[2];
+
+#define DSI_LCD1_TIMING_0		0x110   /* Timing register 0 */
+#define DSI_LCD1_TIMING_1		0x114   /* Timing register 1 */
+#define DSI_LCD1_TIMING_2		0x118   /* Timing register 2 */
+#define DSI_LCD1_TIMING_3		0x11C   /* Timing register 3 */
+#define DSI_LCD1_WC_0			0x120   /* Word Count register 0 */
+#define DSI_LCD1_WC_1			0x124   /* Word Count register 1 */
+#define DSI_LCD1_WC_2			0x128	 /* Word Count register 2 */
+	u32 timing0;
+	u32 timing1;
+	u32 timing2;
+	u32 timing3;
+	u32 wc0;
+	u32 wc1;
+	u32 wc2;
+	u32 reserved2[1];
+	u32 slot_cnt0;
+	u32 slot_cnt1;
+	u32 reserved3[2];
+	u32 status_0;
+	u32 status_1;
+	u32 status_2;
+	u32 status_3;
+	u32 status_4;
+};
+
+struct dsi_regs {
+#define DSI_CTRL_0	  0x000   /* DSI control register 0 */
+#define DSI_CTRL_1	  0x004   /* DSI control register 1 */
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 reserved1[2];
+	u32 irq_status;
+	u32 irq_mask;
+	u32 reserved2[2];
+
+#define DSI_CPU_CMD_0   0x020   /* DSI CPU packet command register 0 */
+#define DSI_CPU_CMD_1   0x024   /* DSU CPU Packet Command Register 1 */
+#define DSI_CPU_CMD_3	0x02C   /* DSU CPU Packet Command Register 3 */
+#define DSI_CPU_WDAT_0	0x030   /* DSI CUP */
+	u32 cmd0;
+	u32 cmd1;
+	u32 cmd2;
+	u32 cmd3;
+	u32 dat0;
+	u32 status0;
+	u32 status1;
+	u32 status2;
+	u32 status3;
+	u32 status4;
+	u32 reserved3[2];
+
+	u32 smt_cmd;
+	u32 smt_ctrl0;
+	u32 smt_ctrl1;
+	u32 reserved4[1];
+
+	u32 rx0_status;
+
+/* Rx Packet Header - data from slave device */
+#define DSI_RX_PKT_HDR_0 0x064
+	u32 rx0_header;
+	u32 rx1_status;
+	u32 rx1_header;
+	u32 rx_ctrl;
+	u32 rx_ctrl1;
+	u32 rx2_status;
+	u32 rx2_header;
+	u32 reserved5[1];
+
+	u32 phy_ctrl1;
+#define DSI_PHY_CTRL_2		0x088   /* DSI DPHI Control Register 2 */
+#define DSI_PHY_CTRL_3		0x08C   /* DPHY Control Register 3 */
+	u32 phy_ctrl2;
+	u32 phy_ctrl3;
+	u32 phy_status0;
+	u32 phy_status1;
+	u32 reserved6[5];
+	u32 phy_status2;
+
+#define DSI_PHY_RCOMP_0		0x0B0   /* DPHY Rcomp Control Register */
+	u32 phy_rcomp0;
+	u32 reserved7[3];
+#define DSI_PHY_TIME_0		0x0C0   /* DPHY Timing Control Register 0 */
+#define DSI_PHY_TIME_1		0x0C4   /* DPHY Timing Control Register 1 */
+#define DSI_PHY_TIME_2		0x0C8   /* DPHY Timing Control Register 2 */
+#define DSI_PHY_TIME_3		0x0CC   /* DPHY Timing Control Register 3 */
+#define DSI_PHY_TIME_4		0x0D0   /* DPHY Timing Control Register 4 */
+#define DSI_PHY_TIME_5		0x0D4   /* DPHY Timing Control Register 5 */
+	u32 phy_timing0;
+	u32 phy_timing1;
+	u32 phy_timing2;
+	u32 phy_timing3;
+	u32 phy_code_0;
+	u32 phy_code_1;
+	u32 reserved8[2];
+	u32 mem_ctrl;
+	u32 tx_timer;
+	u32 rx_timer;
+	u32 turn_timer;
+	u32 reserved9[4];
+
+#define DSI_LCD1_CTRL_0  0x100   /* DSI Active Panel 1 Control register 0 */
+#define DSI_LCD1_CTRL_1  0x104   /* DSI Active Panel 1 Control register 1 */
+#define DSI_LCD1_TIMING_0		0x110   /* Timing register 0 */
+#define DSI_LCD1_TIMING_1		0x114   /* Timing register 1 */
+#define DSI_LCD1_TIMING_2		0x118   /* Timing register 2 */
+#define DSI_LCD1_TIMING_3		0x11C   /* Timing register 3 */
+#define DSI_LCD1_WC_0			0x120   /* Word Count register 0 */
+#define DSI_LCD1_WC_1			0x124   /* Word Count register 1 */
+#define DSI_LCD1_WC_2			0x128   /* Word Count register 2 */
+	struct dsi_lcd_regs lcd1;
+	u32 reserved10[11];
+	struct dsi_lcd_regs lcd2;
+};
+
+#define DSI_LCD2_CTRL_0  0x180   /* DSI Active Panel 2 Control register 0 */
+#define DSI_LCD2_CTRL_1  0x184   /* DSI Active Panel 2 Control register 1 */
+#define DSI_LCD2_TIMING_0		0x190   /* Timing register 0 */
+#define DSI_LCD2_TIMING_1		0x194   /* Timing register 1 */
+#define DSI_LCD2_TIMING_2		0x198   /* Timing register 2 */
+#define DSI_LCD2_TIMING_3		0x19C   /* Timing register 3 */
+#define DSI_LCD2_WC_0			0x1A0   /* Word Count register 0 */
+#define DSI_LCD2_WC_1			0x1A4   /* Word Count register 1 */
+#define DSI_LCD2_WC_2			0x1A8	 /* Word Count register 2 */
+
+/*	DSI_CTRL_0		0x0000	DSI Control Register 0 */
+#define DSI_CTRL_0_CFG_SOFT_RST			(1<<31)
+#define DSI_CTRL_0_CFG_SOFT_RST_REG		(1<<30)
+#define DSI_CTRL_0_CFG_LCD1_TX_EN		(1<<8)
+#define DSI_CTRL_0_CFG_LCD1_SLV			(1<<4)
+#define DSI_CTRL_0_CFG_LCD1_EN			(1<<0)
+
+/*	DSI_CTRL_1		0x0004	DSI Control Register 1 */
+#define DSI_CTRL_1_CFG_EOTP			(1<<8)
+#define DSI_CTRL_1_CFG_RSVD			(2<<4)
+#define DSI_CTRL_1_CFG_LCD2_VCH_NO_MASK		(3<<2)
+#define DSI_CTRL_1_CFG_LCD2_VCH_NO_SHIFT	2
+#define DSI_CTRL_1_CFG_LCD1_VCH_NO_MASK		(3<<0)
+#define DSI_CTRL_1_CFG_LCD1_VCH_NO_SHIFT	0
+
+/*	DSI_LCD1_CTRL_1	0x0104	DSI Active Panel 1 Control Register 1 */
+/* LCD 1 Vsync Reset Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_VSYNC_RST_EN	(1<<31)
+/* LCD 1 2K Pixel Buffer Mode Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_M2K_EN		(1<<30)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_29_23 reserved */
+/* Long Blanking Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HLP_PKT_EN	(1<<22)
+/* Extra Long Blanking Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HEX_PKT_EN	(1<<21)
+/* Front Porch Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HFP_PKT_EN	(1<<20)
+/* hact Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HACT_PKT_EN	(1<<19)
+/* Back Porch Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HBP_PKT_EN	(1<<18)
+/* hse Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HSE_PKT_EN	(1<<17)
+/* hsa Packet Enable */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HSA_PKT_EN	(1<<16)
+/* All Item Enable after Pixel Data */
+#define	DSI_LCD1_CTRL_1_CFG_L1_ALL_SLOT_EN	(1<<15)
+/* Extra Long Packet Enable after Pixel Data */
+#define	DSI_LCD1_CTRL_1_CFG_L1_HEX_SLOT_EN	(1<<14)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_13_11 reserved */
+/* Turn Around Bus at Last h Line */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LAST_LINE_TURN	(1<<10)
+/* Go to Low Power Every Frame */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LPM_FRAME_EN	(1<<9)
+/* Go to Low Power Every Line */
+#define	DSI_LCD1_CTRL_1_CFG_L1_LPM_LINE_EN	(1<<8)
+/*		Bit(s) DSI_LCD1_CTRL_1_RSRV_7_4 reserved */
+/* DSI Transmission Mode for LCD 1 */
+#define DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_SHIFT	2
+#define DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_MASK	(3<<2)
+/* LCD 1 Input Data RGB Mode for LCD 1 */
+#define DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_SHIFT	0
+#define DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_MASK	(3<<2)
+
+/*	DSI_PHY_CTRL_2		0x0088	DPHY Control Register 2 */
+/*		Bit(s) DSI_PHY_CTRL_2_RSRV_31_12 reserved */
+/* DPHY LP Receiver Enable */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_RESC_EN_MASK	(0xf<<8)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_RESC_EN_SHIFT	8
+/* DPHY Data Lane Enable */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_MASK		(0xf<<4)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_SHIFT		4
+/* DPHY Bus Turn Around */
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_TURN_MASK		(0xf)
+#define	DSI_PHY_CTRL_2_CFG_CSR_LANE_TURN_SHIFT		0
+
+/*	DSI_CPU_CMD_1		0x0024	DSI CPU Packet Command Register 1 */
+/*		Bit(s) DSI_CPU_CMD_1_RSRV_31_24 reserved */
+/* LPDT TX Enable */
+#define	DSI_CPU_CMD_1_CFG_TXLP_LPDT_MASK		(0xf<<20)
+#define	DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT		20
+/* ULPS TX Enable */
+#define	DSI_CPU_CMD_1_CFG_TXLP_ULPS_MASK		(0xf<<16)
+#define	DSI_CPU_CMD_1_CFG_TXLP_ULPS_SHIFT		16
+/* Low Power TX Trigger Code */
+#define	DSI_CPU_CMD_1_CFG_TXLP_TRIGGER_CODE_MASK	(0xffff)
+#define	DSI_CPU_CMD_1_CFG_TXLP_TRIGGER_CODE_SHIFT	0
+
+/*	DSI_PHY_TIME_0	0x00c0	DPHY Timing Control Register 0 */
+/* Length of HS Exit Period in tx_clk_esc Cycles */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_MASK	(0xff<<24)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_SHIFT	24
+/* DPHY HS Trail Period Length */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_MASK	(0xff<<16)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_SHIFT	16
+/* DPHY HS Zero State Length */
+#define	DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_MASK	(0xff<<8)
+#define	DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_SHIFT	8
+/* DPHY HS Prepare State Length */
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_PREP_MASK	(0xff)
+#define	DSI_PHY_TIME_0_CFG_CSR_TIME_HS_PREP_SHIFT	0
+
+/*	DSI_PHY_TIME_1		0x00c4	DPHY Timing Control Register 1 */
+/* Time to Drive LP-00 by New Transmitter */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_MASK		(0xff<<24)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_SHIFT	24
+/* Time to Drive LP-00 after Turn Request */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_MASK		(0xff<<16)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_SHIFT		16
+/* DPHY HS Wakeup Period Length */
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_WAKEUP_MASK		(0xffff)
+#define	DSI_PHY_TIME_1_CFG_CSR_TIME_WAKEUP_SHIFT	0
+
+/*	DSI_PHY_TIME_2		0x00c8	DPHY Timing Control Register 2 */
+/* DPHY CLK Exit Period Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_MASK	(0xff<<24)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_SHIFT	24
+/* DPHY CLK Trail Period Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_MASK	(0xff<<16)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_SHIFT	16
+/* DPHY CLK Zero State Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_MASK	(0xff<<8)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_SHIFT	8
+/* DPHY CLK LP Length */
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_LPX_MASK		(0xff)
+#define	DSI_PHY_TIME_2_CFG_CSR_TIME_CK_LPX_SHIFT	0
+
+/*	DSI_PHY_TIME_3		0x00cc	DPHY Timing Control Register 3 */
+/*		Bit(s) DSI_PHY_TIME_3_RSRV_31_16 reserved */
+/* DPHY LP Length */
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_MASK		(0xff<<8)
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_SHIFT		8
+/* DPHY HS req to rdy Length */
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_REQRDY_MASK		(0xff)
+#define	DSI_PHY_TIME_3_CFG_CSR_TIME_REQRDY_SHIFT	0
+
+/*
+ * DSI timings
+ * PXA988 has diffrent ESC CLK with MMP2/MMP3
+ * it will be used in dsi_set_dphy() in pxa688_phy.c
+ * as low power mode clock.
+ */
+#ifdef CONFIG_CPU_PXA988
+#define DSI_ESC_CLK				52  /* Unit: Mhz */
+#define DSI_ESC_CLK_T				19  /* Unit: ns */
+#else
+#define DSI_ESC_CLK				66  /* Unit: Mhz */
+#define DSI_ESC_CLK_T				15  /* Unit: ns */
+#endif
+
+/* LVDS */
+/* LVDS_PHY_CTRL */
+#define LVDS_PHY_CTL				0x2A4
+#define LVDS_PLL_LOCK				(1 << 31)
+#define LVDS_PHY_EXT_MASK			(7 << 28)
+#define LVDS_PHY_EXT_SHIFT			(28)
+#define LVDS_CLK_PHASE_MASK			(0x7f << 16)
+#define LVDS_CLK_PHASE_SHIFT			(16)
+#define LVDS_SSC_RESET_EXT			(1 << 13)
+#define LVDS_SSC_MODE_DOWN_SPREAD		(1 << 12)
+#define LVDS_SSC_EN				(1 << 11)
+#define LVDS_PU_PLL				(1 << 10)
+#define LVDS_PU_TX				(1 << 9)
+#define LVDS_PU_IVREF				(1 << 8)
+#define LVDS_CLK_SEL				(1 << 7)
+#define LVDS_CLK_SEL_LVDS_PCLK			(1 << 7)
+#define LVDS_PD_CH_MASK				(0x3f << 1)
+#define LVDS_PD_CH(ch)				((ch) << 1)
+#define LVDS_RST				(1 << 0)
+
+#define LVDS_PHY_CTL_EXT	0x2A8
+
+/* LVDS_PHY_CTRL_EXT1 */
+#define LVDS_SSC_RNGE_MASK			(0x7ff << 16)
+#define LVDS_SSC_RNGE_SHIFT			(16)
+#define LVDS_RESERVE_IN_MASK			(0xf << 12)
+#define LVDS_RESERVE_IN_SHIFT			(12)
+#define LVDS_TEST_MON_MASK			(0x7 << 8)
+#define LVDS_TEST_MON_SHIFT			(8)
+#define LVDS_POL_SWAP_MASK			(0x3f << 0)
+#define LVDS_POL_SWAP_SHIFT			(0)
+
+/* LVDS_PHY_CTRL_EXT2 */
+#define LVDS_TX_DIF_AMP_MASK			(0xf << 24)
+#define LVDS_TX_DIF_AMP_SHIFT			(24)
+#define LVDS_TX_DIF_CM_MASK			(0x3 << 22)
+#define LVDS_TX_DIF_CM_SHIFT			(22)
+#define LVDS_SELLV_TXCLK_MASK			(0x1f << 16)
+#define LVDS_SELLV_TXCLK_SHIFT			(16)
+#define LVDS_TX_CMFB_EN				(0x1 << 15)
+#define LVDS_TX_TERM_EN				(0x1 << 14)
+#define LVDS_SELLV_TXDATA_MASK			(0x1f << 8)
+#define LVDS_SELLV_TXDATA_SHIFT			(8)
+#define LVDS_SELLV_OP7_MASK			(0x3 << 6)
+#define LVDS_SELLV_OP7_SHIFT			(6)
+#define LVDS_SELLV_OP6_MASK			(0x3 << 4)
+#define LVDS_SELLV_OP6_SHIFT			(4)
+#define LVDS_SELLV_OP9_MASK			(0x3 << 2)
+#define LVDS_SELLV_OP9_SHIFT			(2)
+#define LVDS_STRESSTST_EN			(0x1 << 0)
+
+/* LVDS_PHY_CTRL_EXT3 */
+#define LVDS_KVCO_MASK				(0xf << 28)
+#define LVDS_KVCO_SHIFT				(28)
+#define LVDS_CTUNE_MASK				(0x3 << 26)
+#define LVDS_CTUNE_SHIFT			(26)
+#define LVDS_VREG_IVREF_MASK			(0x3 << 24)
+#define LVDS_VREG_IVREF_SHIFT			(24)
+#define LVDS_VDDL_MASK				(0xf << 20)
+#define LVDS_VDDL_SHIFT				(20)
+#define LVDS_VDDM_MASK				(0x3 << 18)
+#define LVDS_VDDM_SHIFT				(18)
+#define LVDS_FBDIV_MASK				(0xf << 8)
+#define LVDS_FBDIV_SHIFT			(8)
+#define LVDS_REFDIV_MASK			(0x7f << 0)
+#define LVDS_REFDIV_SHIFT			(0)
+
+/* LVDS_PHY_CTRL_EXT4 */
+#define LVDS_SSC_FREQ_DIV_MASK			(0xffff << 16)
+#define LVDS_SSC_FREQ_DIV_SHIFT			(16)
+#define LVDS_INTPI_MASK				(0xf << 12)
+#define LVDS_INTPI_SHIFT			(12)
+#define LVDS_VCODIV_SEL_SE_MASK			(0xf << 8)
+#define LVDS_VCODIV_SEL_SE_SHIFT		(8)
+#define LVDS_RESET_INTP_EXT			(0x1 << 7)
+#define LVDS_VCO_VRNG_MASK			(0x7 << 4)
+#define LVDS_VCO_VRNG_SHIFT			(4)
+#define LVDS_PI_EN				(0x1 << 3)
+#define LVDS_ICP_MASK				(0x7 << 0)
+#define LVDS_ICP_SHIFT				(0)
+
+/* LVDS_PHY_CTRL_EXT5 */
+#define LVDS_FREQ_OFFSET_MASK			(0x1ffff << 15)
+#define LVDS_FREQ_OFFSET_SHIFT			(15)
+#define LVDS_FREQ_OFFSET_VALID			(0x1 << 2)
+#define LVDS_FREQ_OFFSET_MODE_CK_DIV4_OUT	(0x1 << 1)
+#define LVDS_FREQ_OFFSET_MODE_EN		(0x1 << 0)
+
+/* VDMA */
+struct vdma_ch_regs {
+#define VDMA_DC_SADDR_1		0x320
+#define VDMA_DC_SADDR_2		0x3A0
+#define VDMA_DC_SZ_1		0x324
+#define VDMA_DC_SZ_2		0x3A4
+#define VDMA_CTRL_1		0x328
+#define VDMA_CTRL_2		0x3A8
+#define VDMA_SRC_SZ_1		0x32C
+#define VDMA_SRC_SZ_2		0x3AC
+#define VDMA_SA_1		0x330
+#define VDMA_SA_2		0x3B0
+#define VDMA_DA_1		0x334
+#define VDMA_DA_2		0x3B4
+#define VDMA_SZ_1		0x338
+#define VDMA_SZ_2		0x3B8
+	u32	dc_saddr;
+	u32	dc_size;
+	u32	ctrl;
+	u32	src_size;
+	u32	src_addr;
+	u32	dst_addr;
+	u32	dst_size;
+#define VDMA_PITCH_1		0x33C
+#define VDMA_PITCH_2		0x3BC
+#define VDMA_ROT_CTRL_1		0x340
+#define VDMA_ROT_CTRL_2		0x3C0
+#define VDMA_RAM_CTRL0_1	0x344
+#define VDMA_RAM_CTRL0_2	0x3C4
+#define VDMA_RAM_CTRL1_1	0x348
+#define VDMA_RAM_CTRL1_2	0x3C8
+	u32	pitch;
+	u32	rot_ctrl;
+	u32	ram_ctrl0;
+	u32	ram_ctrl1;
+
+};
+struct vdma_regs {
+#define VDMA_ARBR_CTRL		0x300
+#define VDMA_IRQR		0x304
+#define VDMA_IRQM		0x308
+#define VDMA_IRQS		0x30C
+#define VDMA_MDMA_ARBR_CTRL	0x310
+	u32	arbr_ctr;
+	u32	irq_raw;
+	u32	irq_mask;
+	u32	irq_status;
+	u32	mdma_arbr_ctrl;
+	u32	reserved[3];
+
+	struct vdma_ch_regs	ch1;
+	u32	reserved2[21];
+	struct vdma_ch_regs	ch2;
+};
+
+/* CMU */
+#define CMU_PIP_DE_H_CFG	0x0008
+#define CMU_PRI1_H_CFG		0x000C
+#define CMU_PRI2_H_CFG		0x0010
+#define CMU_ACE_MAIN_DE1_H_CFG	0x0014
+#define CMU_ACE_MAIN_DE2_H_CFG	0x0018
+#define CMU_ACE_PIP_DE1_H_CFG	0x001C
+#define CMU_ACE_PIP_DE2_H_CFG	0x0020
+#define CMU_PIP_DE_V_CFG	0x0024
+#define CMU_PRI_V_CFG		0x0028
+#define CMU_ACE_MAIN_DE_V_CFG	0x002C
+#define CMU_ACE_PIP_DE_V_CFG	0x0030
+#define CMU_BAR_0_CFG		0x0034
+#define CMU_BAR_1_CFG		0x0038
+#define CMU_BAR_2_CFG		0x003C
+#define CMU_BAR_3_CFG		0x0040
+#define CMU_BAR_4_CFG		0x0044
+#define CMU_BAR_5_CFG		0x0048
+#define CMU_BAR_6_CFG		0x004C
+#define CMU_BAR_7_CFG		0x0050
+#define CMU_BAR_8_CFG		0x0054
+#define CMU_BAR_9_CFG		0x0058
+#define CMU_BAR_10_CFG		0x005C
+#define CMU_BAR_11_CFG		0x0060
+#define CMU_BAR_12_CFG		0x0064
+#define CMU_BAR_13_CFG		0x0068
+#define CMU_BAR_14_CFG		0x006C
+#define CMU_BAR_15_CFG		0x0070
+#define CMU_BAR_CTRL		0x0074
+#define PATTERN_TOTAL		0x0078
+#define PATTERN_ACTIVE		0x007C
+#define PATTERN_FRONT_PORCH	0x0080
+#define PATTERN_BACK_PORCH	0x0084
+#define CMU_CLK_CTRL		0x0088
+
+#define CMU_ICSC_M_C0_L		0x0900
+#define CMU_ICSC_M_C0_H		0x0901
+#define CMU_ICSC_M_C1_L		0x0902
+#define CMU_ICSC_M_C1_H		0x0903
+#define CMU_ICSC_M_C2_L		0x0904
+#define CMU_ICSC_M_C2_H		0x0905
+#define CMU_ICSC_M_C3_L		0x0906
+#define CMU_ICSC_M_C3_H		0x0907
+#define CMU_ICSC_M_C4_L		0x0908
+#define CMU_ICSC_M_C4_H		0x0909
+#define CMU_ICSC_M_C5_L		0x090A
+#define CMU_ICSC_M_C5_H		0x090B
+#define CMU_ICSC_M_C6_L		0x090C
+#define CMU_ICSC_M_C6_H		0x090D
+#define CMU_ICSC_M_C7_L		0x090E
+#define CMU_ICSC_M_C7_H		0x090F
+#define CMU_ICSC_M_C8_L		0x0910
+#define CMU_ICSC_M_C8_H		0x0911
+#define CMU_ICSC_M_O1_0		0x0914
+#define CMU_ICSC_M_O1_1		0x0915
+#define CMU_ICSC_M_O1_2		0x0916
+#define CMU_ICSC_M_O2_0		0x0918
+#define CMU_ICSC_M_O2_1		0x0919
+#define CMU_ICSC_M_O2_2		0x091A
+#define CMU_ICSC_M_O3_0		0x091C
+#define CMU_ICSC_M_O3_1		0x091D
+#define CMU_ICSC_M_O3_2		0x091E
+#define CMU_ICSC_P_C0_L		0x0920
+#define CMU_ICSC_P_C0_H		0x0921
+#define CMU_ICSC_P_C1_L		0x0922
+#define CMU_ICSC_P_C1_H		0x0923
+#define CMU_ICSC_P_C2_L		0x0924
+#define CMU_ICSC_P_C2_H		0x0925
+#define CMU_ICSC_P_C3_L		0x0926
+#define CMU_ICSC_P_C3_H		0x0927
+#define CMU_ICSC_P_C4_L		0x0928
+#define CMU_ICSC_P_C4_H		0x0929
+#define CMU_ICSC_P_C5_L		0x092A
+#define CMU_ICSC_P_C5_H		0x092B
+#define CMU_ICSC_P_C6_L		0x092C
+#define CMU_ICSC_P_C6_H		0x092D
+#define CMU_ICSC_P_C7_L		0x092E
+#define CMU_ICSC_P_C7_H		0x092F
+#define CMU_ICSC_P_C8_L		0x0930
+#define CMU_ICSC_P_C8_H		0x0931
+#define CMU_ICSC_P_O1_0		0x0934
+#define CMU_ICSC_P_O1_1		0x0935
+#define CMU_ICSC_P_O1_2		0x0936
+#define CMU_ICSC_P_O2_0		0x0938
+#define CMU_ICSC_P_O2_1		0x0939
+#define CMU_ICSC_P_O2_2		0x093A
+#define CMU_ICSC_P_O3_0		0x093C
+#define CMU_ICSC_P_O3_1		0x093D
+#define CMU_ICSC_P_O3_2		0x093E
+#define CMU_BR_M_EN		0x0940
+#define CMU_BR_M_TH1_L		0x0942
+#define CMU_BR_M_TH1_H		0x0943
+#define CMU_BR_M_TH2_L		0x0944
+#define CMU_BR_M_TH2_H		0x0945
+#define CMU_ACE_M_EN		0x0950
+#define CMU_ACE_M_WFG1		0x0951
+#define CMU_ACE_M_WFG2		0x0952
+#define CMU_ACE_M_WFG3		0x0953
+#define CMU_ACE_M_TH0		0x0954
+#define CMU_ACE_M_TH1		0x0955
+#define CMU_ACE_M_TH2		0x0956
+#define CMU_ACE_M_TH3		0x0957
+#define CMU_ACE_M_TH4		0x0958
+#define CMU_ACE_M_TH5		0x0959
+#define CMU_ACE_M_OP0_L		0x095A
+#define CMU_ACE_M_OP0_H		0x095B
+#define CMU_ACE_M_OP5_L		0x095C
+#define CMU_ACE_M_OP5_H		0x095D
+#define CMU_ACE_M_GB2		0x095E
+#define CMU_ACE_M_GB3		0x095F
+#define CMU_ACE_M_MS1		0x0960
+#define CMU_ACE_M_MS2		0x0961
+#define CMU_ACE_M_MS3		0x0962
+#define CMU_BR_P_EN		0x0970
+#define CMU_BR_P_TH1_L		0x0972
+#define CMU_BR_P_TH1_H		0x0973
+#define CMU_BR_P_TH2_L		0x0974
+#define CMU_BR_P_TH2_H		0x0975
+#define CMU_ACE_P_EN		0x0980
+#define CMU_ACE_P_WFG1		0x0981
+#define CMU_ACE_P_WFG2		0x0982
+#define CMU_ACE_P_WFG3		0x0983
+#define CMU_ACE_P_TH0		0x0984
+#define CMU_ACE_P_TH1		0x0985
+#define CMU_ACE_P_TH2		0x0986
+#define CMU_ACE_P_TH3		0x0987
+#define CMU_ACE_P_TH4		0x0988
+#define CMU_ACE_P_TH5		0x0989
+#define CMU_ACE_P_OP0_L		0x098A
+#define CMU_ACE_P_OP0_H		0x098B
+#define CMU_ACE_P_OP5_L		0x098C
+#define CMU_ACE_P_OP5_H		0x098D
+#define CMU_ACE_P_GB2		0x098E
+#define CMU_ACE_P_GB3		0x098F
+#define CMU_ACE_P_MS1		0x0990
+#define CMU_ACE_P_MS2		0x0991
+#define CMU_ACE_P_MS3		0x0992
+#define CMU_FTDC_M_EN		0x09A0
+#define CMU_FTDC_P_EN		0x09A1
+#define CMU_FTDC_INLOW_L	0x09A2
+#define CMU_FTDC_INLOW_H	0x09A3
+#define CMU_FTDC_INHIGH_L	0x09A4
+#define CMU_FTDC_INHIGH_H	0x09A5
+#define CMU_FTDC_OUTLOW_L	0x09A6
+#define CMU_FTDC_OUTLOW_H	0x09A7
+#define CMU_FTDC_OUTHIGH_L	0x09A8
+#define CMU_FTDC_OUTHIGH_H	0x09A9
+#define CMU_FTDC_YLOW		0x09AA
+#define CMU_FTDC_YHIGH		0x09AB
+#define CMU_FTDC_CH1		0x09AC
+#define CMU_FTDC_CH2_L		0x09AE
+#define CMU_FTDC_CH2_H		0x09AF
+#define CMU_FTDC_CH3_L		0x09B0
+#define CMU_FTDC_CH3_H		0x09B1
+#define CMU_FTDC_1_C00_6	0x09B2
+#define CMU_FTDC_1_C01_6	0x09B8
+#define CMU_FTDC_1_C11_6	0x09BE
+#define CMU_FTDC_1_C10_6	0x09C4
+#define CMU_FTDC_1_OFF00_6	0x09CA
+#define CMU_FTDC_1_OFF10_6	0x09D0
+#define CMU_HS_M_EN		0x0A00
+#define CMU_HS_M_AX1_L		0x0A02
+#define CMU_HS_M_AX1_H		0x0A03
+#define CMU_HS_M_AX2_L		0x0A04
+#define CMU_HS_M_AX2_H		0x0A05
+#define CMU_HS_M_AX3_L		0x0A06
+#define CMU_HS_M_AX3_H		0x0A07
+#define CMU_HS_M_AX4_L		0x0A08
+#define CMU_HS_M_AX4_H		0x0A09
+#define CMU_HS_M_AX5_L		0x0A0A
+#define CMU_HS_M_AX5_H		0x0A0B
+#define CMU_HS_M_AX6_L		0x0A0C
+#define CMU_HS_M_AX6_H		0x0A0D
+#define CMU_HS_M_AX7_L		0x0A0E
+#define CMU_HS_M_AX7_H		0x0A0F
+#define CMU_HS_M_AX8_L		0x0A10
+#define CMU_HS_M_AX8_H		0x0A11
+#define CMU_HS_M_AX9_L		0x0A12
+#define CMU_HS_M_AX9_H		0x0A13
+#define CMU_HS_M_AX10_L		0x0A14
+#define CMU_HS_M_AX10_H		0x0A15
+#define CMU_HS_M_AX11_L		0x0A16
+#define CMU_HS_M_AX11_H		0x0A17
+#define CMU_HS_M_AX12_L		0x0A18
+#define CMU_HS_M_AX12_H		0x0A19
+#define CMU_HS_M_AX13_L		0x0A1A
+#define CMU_HS_M_AX13_H		0x0A1B
+#define CMU_HS_M_AX14_L		0x0A1C
+#define CMU_HS_M_AX14_H		0x0A1D
+#define CMU_HS_M_H1_H14		0x0A1E
+#define CMU_HS_M_S1_S14		0x0A2C
+#define CMU_HS_M_GL		0x0A3A
+#define CMU_HS_M_MAXSAT_RGB_Y_L	0x0A3C
+#define CMU_HS_M_MAXSAT_RGB_Y_H	0x0A3D
+#define CMU_HS_M_MAXSAT_RCR_L	0x0A3E
+#define CMU_HS_M_MAXSAT_RCR_H	0x0A3F
+#define CMU_HS_M_MAXSAT_RCB_L	0x0A40
+#define CMU_HS_M_MAXSAT_RCB_H	0x0A41
+#define CMU_HS_M_MAXSAT_GCR_L	0x0A42
+#define CMU_HS_M_MAXSAT_GCR_H	0x0A43
+#define CMU_HS_M_MAXSAT_GCB_L	0x0A44
+#define CMU_HS_M_MAXSAT_GCB_H	0x0A45
+#define CMU_HS_M_MAXSAT_BCR_L	0x0A46
+#define CMU_HS_M_MAXSAT_BCR_H	0x0A47
+#define CMU_HS_M_MAXSAT_BCB_L	0x0A48
+#define CMU_HS_M_MAXSAT_BCB_H	0x0A49
+#define CMU_HS_M_ROFF_L		0x0A4A
+#define CMU_HS_M_ROFF_H		0x0A4B
+#define CMU_HS_M_GOFF_L		0x0A4C
+#define CMU_HS_M_GOFF_H		0x0A4D
+#define CMU_HS_M_BOFF_L		0x0A4E
+#define CMU_HS_M_BOFF_H		0x0A4F
+#define CMU_HS_P_EN		0x0A50
+#define CMU_HS_P_AX1_L		0x0A52
+#define CMU_HS_P_AX1_H		0x0A53
+#define CMU_HS_P_AX2_L		0x0A54
+#define CMU_HS_P_AX2_H		0x0A55
+#define CMU_HS_P_AX3_L		0x0A56
+#define CMU_HS_P_AX3_H		0x0A57
+#define CMU_HS_P_AX4_L		0x0A58
+#define CMU_HS_P_AX4_H		0x0A59
+#define CMU_HS_P_AX5_L		0x0A5A
+#define CMU_HS_P_AX5_H		0x0A5B
+#define CMU_HS_P_AX6_L		0x0A5C
+#define CMU_HS_P_AX6_H		0x0A5D
+#define CMU_HS_P_AX7_L		0x0A5E
+#define CMU_HS_P_AX7_H		0x0A5F
+#define CMU_HS_P_AX8_L		0x0A60
+#define CMU_HS_P_AX8_H		0x0A61
+#define CMU_HS_P_AX9_L		0x0A62
+#define CMU_HS_P_AX9_H		0x0A63
+#define CMU_HS_P_AX10_L		0x0A64
+#define CMU_HS_P_AX10_H		0x0A65
+#define CMU_HS_P_AX11_L		0x0A66
+#define CMU_HS_P_AX11_H		0x0A67
+#define CMU_HS_P_AX12_L		0x0A68
+#define CMU_HS_P_AX12_H		0x0A69
+#define CMU_HS_P_AX13_L		0x0A6A
+#define CMU_HS_P_AX13_H		0x0A6B
+#define CMU_HS_P_AX14_L		0x0A6C
+#define CMU_HS_P_AX14_H		0x0A6D
+#define CMU_HS_P_H1_H14		0x0A6E
+#define CMU_HS_P_S1_S14		0x0A7C
+#define CMU_HS_P_GL		0x0A8A
+#define CMU_HS_P_MAXSAT_RGB_Y_L	0x0A8C
+#define CMU_HS_P_MAXSAT_RGB_Y_H	0x0A8D
+#define CMU_HS_P_MAXSAT_RCR_L	0x0A8E
+#define CMU_HS_P_MAXSAT_RCR_H	0x0A8F
+#define CMU_HS_P_MAXSAT_RCB_L	0x0A90
+#define CMU_HS_P_MAXSAT_RCB_H	0x0A91
+#define CMU_HS_P_MAXSAT_GCR_L	0x0A92
+#define CMU_HS_P_MAXSAT_GCR_H	0x0A93
+#define CMU_HS_P_MAXSAT_GCB_L	0x0A94
+#define CMU_HS_P_MAXSAT_GCB_H	0x0A95
+#define CMU_HS_P_MAXSAT_BCR_L	0x0A96
+#define CMU_HS_P_MAXSAT_BCR_H	0x0A97
+#define CMU_HS_P_MAXSAT_BCB_L	0x0A98
+#define CMU_HS_P_MAXSAT_BCB_H	0x0A99
+#define CMU_HS_P_ROFF_L		0x0A9A
+#define CMU_HS_P_ROFF_H		0x0A9B
+#define CMU_HS_P_GOFF_L		0x0A9C
+#define CMU_HS_P_GOFF_H		0x0A9D
+#define CMU_HS_P_BOFF_L		0x0A9E
+#define CMU_HS_P_BOFF_H		0x0A9F
+#define CMU_GLCSC_M_C0_L	0x0AA0
+#define CMU_GLCSC_M_C0_H	0x0AA1
+#define CMU_GLCSC_M_C1_L	0x0AA2
+#define CMU_GLCSC_M_C1_H	0x0AA3
+#define CMU_GLCSC_M_C2_L	0x0AA4
+#define CMU_GLCSC_M_C2_H	0x0AA5
+#define CMU_GLCSC_M_C3_L	0x0AA6
+#define CMU_GLCSC_M_C3_H	0x0AA7
+#define CMU_GLCSC_M_C4_L	0x0AA8
+#define CMU_GLCSC_M_C4_H	0x0AA9
+#define CMU_GLCSC_M_C5_L	0x0AAA
+#define CMU_GLCSC_M_C5_H	0x0AAB
+#define CMU_GLCSC_M_C6_L	0x0AAC
+#define CMU_GLCSC_M_C6_H	0x0AAD
+#define CMU_GLCSC_M_C7_L	0x0AAE
+#define CMU_GLCSC_M_C7_H	0x0AAF
+#define CMU_GLCSC_M_C8_L	0x0AB0
+#define CMU_GLCSC_M_C8_H	0x0AB1
+#define CMU_GLCSC_M_O1_1	0x0AB4
+#define CMU_GLCSC_M_O1_2	0x0AB5
+#define CMU_GLCSC_M_O1_3	0x0AB6
+#define CMU_GLCSC_M_O2_1	0x0AB8
+#define CMU_GLCSC_M_O2_2	0x0AB9
+#define CMU_GLCSC_M_O2_3	0x0ABA
+#define CMU_GLCSC_M_O3_1	0x0ABC
+#define CMU_GLCSC_M_O3_2	0x0ABD
+#define CMU_GLCSC_M_O3_3	0x0ABE
+#define CMU_GLCSC_P_C0_L	0x0AC0
+#define CMU_GLCSC_P_C0_H	0x0AC1
+#define CMU_GLCSC_P_C1_L	0x0AC2
+#define CMU_GLCSC_P_C1_H	0x0AC3
+#define CMU_GLCSC_P_C2_L	0x0AC4
+#define CMU_GLCSC_P_C2_H	0x0AC5
+#define CMU_GLCSC_P_C3_L	0x0AC6
+#define CMU_GLCSC_P_C3_H	0x0AC7
+#define CMU_GLCSC_P_C4_L	0x0AC8
+#define CMU_GLCSC_P_C4_H	0x0AC9
+#define CMU_GLCSC_P_C5_L	0x0ACA
+#define CMU_GLCSC_P_C5_H	0x0ACB
+#define CMU_GLCSC_P_C6_L	0x0ACC
+#define CMU_GLCSC_P_C6_H	0x0ACD
+#define CMU_GLCSC_P_C7_L	0x0ACE
+#define CMU_GLCSC_P_C7_H	0x0ACF
+#define CMU_GLCSC_P_C8_L	0x0AD0
+#define CMU_GLCSC_P_C8_H	0x0AD1
+#define CMU_GLCSC_P_O1_1	0x0AD4
+#define CMU_GLCSC_P_O1_2	0x0AD5
+#define CMU_GLCSC_P_O1_3	0x0AD6
+#define CMU_GLCSC_P_O2_1	0x0AD8
+#define CMU_GLCSC_P_O2_2	0x0AD9
+#define CMU_GLCSC_P_O2_3	0x0ADA
+#define CMU_GLCSC_P_O3_1	0x0ADC
+#define CMU_GLCSC_P_O3_2	0x0ADD
+#define CMU_GLCSC_P_O3_3	0x0ADE
+#define CMU_PIXVAL_M_EN		0x0AE0
+#define CMU_PIXVAL_P_EN		0x0AE1
+
+#define CMU_CLK_CTRL_TCLK	0x0
+#define CMU_CLK_CTRL_SCLK	0x2
+#define CMU_CLK_CTRL_MSK	0x2
+#define CMU_CLK_CTRL_ENABLE	0x1
+
+#define LCD_TOP_CTRL_TV		0x2
+#define LCD_TOP_CTRL_PN		0x0
+#define LCD_TOP_CTRL_SEL_MSK	0x2
+#define LCD_IO_CMU_IN_SEL_MSK	(0x3 << 20)
+#define LCD_IO_CMU_IN_SEL_TV	0
+#define LCD_IO_CMU_IN_SEL_PN	1
+#define LCD_IO_CMU_IN_SEL_PN2	2
+#define LCD_IO_TV_OUT_SEL_MSK	(0x3 << 26)
+#define LCD_IO_PN_OUT_SEL_MSK	(0x3 << 24)
+#define LCD_IO_PN2_OUT_SEL_MSK	(0x3 << 28)
+#define LCD_IO_TV_OUT_SEL_NON	3
+#define LCD_IO_PN_OUT_SEL_NON	3
+#define LCD_IO_PN2_OUT_SEL_NON	3
+#define LCD_TOP_CTRL_CMU_ENABLE 0x1
+#define LCD_IO_OVERL_MSK	0xC00000
+#define LCD_IO_OVERL_TV		0x0
+#define LCD_IO_OVERL_LCD1	0x400000
+#define LCD_IO_OVERL_LCD2	0xC00000
+#define HINVERT_MSK		0x4
+#define VINVERT_MSK		0x8
+#define HINVERT_LEN		0x2
+#define VINVERT_LEN		0x3
+
+#define CMU_CTRL		0x88
+#define CMU_CTRL_A0_MSK		0x6
+#define CMU_CTRL_A0_TV		0x0
+#define CMU_CTRL_A0_LCD1	0x1
+#define CMU_CTRL_A0_LCD2	0x2
+#define CMU_CTRL_A0_HDMI	0x3
+
+#define ICR_DRV_ROUTE_OFF	0x0
+#define ICR_DRV_ROUTE_TV	0x1
+#define ICR_DRV_ROUTE_LCD1	0x2
+#define ICR_DRV_ROUTE_LCD2	0x3
+
+#endif	/* __PXA168FB_H__ */
diff --git a/drivers/video/pxa168fb_common.c b/drivers/video/pxa168fb_common.c
new file mode 100644
index 0000000..5493d39
--- /dev/null
+++ b/drivers/video/pxa168fb_common.c
@@ -0,0 +1,1727 @@
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include "pxa168fb_common.h"
+
+/* buffer management:
+ *    filterBufList: list return to upper layer which indicates buff is free
+ *    freelist: list indicates buff is free
+ *    waitlist: wait queue which indicates "using" buffer, will be writen in
+ *              DMA register
+ *    current: buffer on showing
+ * Operation:
+ *    flip: if !waitlist[0] || !waitlist[1] enqueue to waiting list;
+ *          else enqueue the  waitlist[0] to freelist, new buf to waitlist
+ *    get freelist: return freelist
+ *    eof intr: enqueue current to freelist; dequeue waitlist[0] to current;
+ *    buffers are protected spin_lock_irq disable/enable
+ *    suspend: when lcd is suspend, move all buffers as "switched",
+ *             but don't really set hw register.
+ */
+
+static int check_yuv_status(FBVideoMode videoMode, struct pxa168fb_info *fbi)
+{
+	u32 x;
+
+	if (fbi->vid) {     /* now in video layer */
+		x = dma_ctrl_read(fbi->id, 0);
+
+		if (!((videoMode & 0xf00) >> 8)) {
+			if ((x & 0xf0000)>>16 == 0x5) {
+				/* graphic layer broadcast YUV */
+				pr_warning(" vid layer: dma_ctrl0 0x%x\n", x);
+				return -EFAULT;
+			}
+		}
+	} else {
+		x = dma_ctrl_read(fbi->id, 0);
+
+		if (!((videoMode & 0xf00) >> 8)) {
+			if ((x & 0xf00000)>>20 >= 0x5
+					&& (x & 0xf00000)>>20 <= 0x7) {
+				pr_warning(" gfx layer: dma_ctrl0 0x%x\n", x);
+				return -EFAULT; /* video layer broadcast YUV */
+			}
+		}
+	}
+
+	return 0;
+}
+
+static void ovlysurface_clear_pitch(struct _sOvlySurface *surface)
+{
+	surface->viewPortInfo.yPitch = 0;
+	surface->viewPortInfo.uPitch = 0;
+	surface->viewPortInfo.vPitch = 0;
+}
+
+static void update_surface(struct _sOvlySurface *surface)
+{
+	int tmp;
+
+	if (surface->viewPortInfo.rotation == 90 ||
+		surface->viewPortInfo.rotation == 270) {
+		surface->viewPortInfo.rotation = 360 -
+		surface->viewPortInfo.rotation;
+		tmp = surface->viewPortInfo.srcWidth;
+		surface->viewPortInfo.srcWidth =
+		surface->viewPortInfo.srcHeight;
+		surface->viewPortInfo.srcHeight = tmp;
+		switch (surface->videoMode) {
+		case FB_VMODE_YUV422PACKED:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 1;
+			ovlysurface_clear_pitch(surface);
+			break;
+		case FB_VMODE_YUV422PACKED_SWAPUV:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 2;
+			ovlysurface_clear_pitch(surface);
+			break;
+		case FB_VMODE_YUV422PACKED_SWAPYUorV:
+			surface->videoMode = FB_VMODE_YUV422PACKED_IRE_90_270;
+			surface->viewPortInfo.yuv_format = 4;
+			ovlysurface_clear_pitch(surface);
+			break;
+		default:
+			surface->viewPortInfo.yuv_format = 0;
+		}
+	}
+}
+
+int unsupport_format(struct pxa168fb_info *fbi, struct _sViewPortInfo
+		viewPortInfo, FBVideoMode videoMode)
+{
+	if (check_yuv_status(videoMode, fbi) < 0)
+		return 1;
+
+	if ((viewPortInfo.rotation == 0) || (viewPortInfo.rotation == 1)) {
+		if (!fbi->vid) {
+			/* In graphic layer now */
+			switch (videoMode) {
+			case FB_VMODE_YUV422PLANAR:
+			case FB_VMODE_YUV420PLANAR:
+				pr_err("Planar is not supported!\n");
+				return 1;
+			default:
+				break;
+			}
+		}
+
+		return 0;
+	}
+
+	if (viewPortInfo.srcHeight == 1080) {
+		pr_err("1080P rotation is not supported!\n");
+		return 1;
+	}
+	if (viewPortInfo.srcHeight == 720) {
+		if (viewPortInfo.rotation == 180) {
+			pr_err("720p rotation 180 is not supported!\n");
+			return 1;
+		}
+	}
+
+	switch (videoMode) {
+	case FB_VMODE_YUV422PLANAR:
+	case FB_VMODE_YUV422PLANAR_SWAPUV:
+	case FB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case FB_VMODE_YUV420PLANAR:
+	case FB_VMODE_YUV420PLANAR_SWAPUV:
+	case FB_VMODE_YUV420PLANAR_SWAPYUorV:
+		pr_err("Planar is not supported!\n");
+		return 1;
+	default:
+		break;
+	}
+	return 0;
+}
+
+int convert_pix_fmt(u32 vmode)
+{
+/*	pr_info("vmode=%d\n", vmode); */
+	switch (vmode) {
+	case FB_VMODE_YUV422PACKED:
+		return PIX_FMT_YUV422PACK;
+	case FB_VMODE_YUV422PACKED_SWAPUV:
+		return PIX_FMT_YVU422PACK;
+	case FB_VMODE_YUV422PLANAR:
+		return PIX_FMT_YUV422PLANAR;
+	case FB_VMODE_YUV422PLANAR_SWAPUV:
+		return PIX_FMT_YVU422PLANAR;
+	case FB_VMODE_YUV420PLANAR:
+		return PIX_FMT_YUV420PLANAR;
+	case FB_VMODE_YUV420PLANAR_SWAPUV:
+		return PIX_FMT_YVU420PLANAR;
+	case FB_VMODE_YUV422PACKED_SWAPYUorV:
+		return PIX_FMT_YUYV422PACK;
+	case FB_VMODE_YUV422PACKED_IRE_90_270:
+		return PIX_FMT_YUV422PACK_IRE_90_270;
+	case FB_VMODE_RGB565:
+		return PIX_FMT_RGB565;
+	case FB_VMODE_BGR565:
+		return PIX_FMT_BGR565;
+	case FB_VMODE_RGB1555:
+		return PIX_FMT_RGB1555;
+	case FB_VMODE_BGR1555:
+		return PIX_FMT_BGR1555;
+	case FB_VMODE_RGB888PACK:
+		return PIX_FMT_RGB888PACK;
+	case FB_VMODE_BGR888PACK:
+		return PIX_FMT_BGR888PACK;
+	case FB_VMODE_RGBA888:
+		return PIX_FMT_RGBA888;
+	case FB_VMODE_BGRA888:
+		return PIX_FMT_BGRA888;
+	case FB_VMODE_RGB888UNPACK:
+		return PIX_FMT_RGB888UNPACK;
+	case FB_VMODE_BGR888UNPACK:
+		return PIX_FMT_BGR888UNPACK;
+	case FB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case FB_VMODE_YUV420PLANAR_SWAPYUorV:
+	default:
+		return -1;
+	}
+}
+
+int set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+{
+	switch (pix_fmt) {
+	case PIX_FMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_BGR565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 11;   var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_RGB1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 10;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 5 << 20;
+		break;
+	case PIX_FMT_BGR1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 10;   var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 5 << 20;
+		break;
+	case PIX_FMT_RGB888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 6 << 20;
+		break;
+	case PIX_FMT_BGR888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 6 << 20;
+		break;
+	case PIX_FMT_RGB888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	case PIX_FMT_BGR888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	case PIX_FMT_RGBA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 8 << 20;
+		break;
+	case PIX_FMT_BGRA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 8 << 20;
+		break;
+	case PIX_FMT_YUYV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;     var->red.length = 16;
+		var->green.offset = 4;   var->green.length = 16;
+		var->blue.offset = 0;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_YVU422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 16;
+		var->green.offset = 8;   var->green.length = 16;
+		var->blue.offset = 12;   var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_YUV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 4;     var->red.length = 16;
+		var->green.offset = 12;   var->green.length = 16;
+		var->blue.offset = 0;    var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 9 << 20;
+		break;
+	case PIX_FMT_PSEUDOCOLOR:
+		var->bits_per_pixel = 8;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 0;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YUV422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;	 var->red.length = 8;
+		var->green.offset = 4;   var->green.length = 4;
+		var->blue.offset = 0;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 3 << 20;
+		break;
+	case PIX_FMT_YVU422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 4;
+		var->blue.offset = 12;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 3 << 20;
+		break;
+	case PIX_FMT_YUV420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 4;	 var->red.length = 8;
+		var->green.offset = 2;   var->green.length = 2;
+		var->blue.offset = 0;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 4 << 20;
+		break;
+	case PIX_FMT_YVU420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 2;
+		var->blue.offset = 10;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 4 << 20;
+		break;
+	/*
+	 * YUV422 Packed will be YUV444 Packed after
+	 * IRE 90 and 270 degree rotation
+	 */
+	case PIX_FMT_YUV422PACK_IRE_90_270:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+		var->nonstd |= 7 << 20;
+		break;
+	default:
+		return  -EINVAL;
+	}
+
+	return 0;
+}
+
+int determine_best_pix_fmt(struct fb_var_screeninfo *var,
+			 struct pxa168fb_info *fbi)
+{
+	unsigned char pxa_format;
+
+	/* compatibility switch: if var->nonstd MSB is 0xAA then skip to
+	 * using the nonstd variable to select the color space
+	 */
+	if (fbi->compat_mode != 0x2625) {
+
+		/*
+		 * Pseudocolor mode?
+		 */
+		if (var->bits_per_pixel == 8)
+			return PIX_FMT_PSEUDOCOLOR;
+		/*
+		 * Check for YUV422PACK.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 16 &&
+			var->green.length == 16 && var->blue.length == 16) {
+			if (var->red.offset >= var->blue.offset) {
+				if (var->red.offset == 4)
+					return PIX_FMT_YUV422PACK;
+				else
+					return PIX_FMT_YUYV422PACK;
+			} else
+				return PIX_FMT_YVU422PACK;
+		}
+		/*
+		 * Check for YUV422PLANAR.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length == 8 &&
+			var->green.length == 4 && var->blue.length == 4 &&
+			fbi->vid) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_YUV422PLANAR;
+			else
+				return PIX_FMT_YVU422PLANAR;
+		}
+
+		/*
+		 * Check for YUV420PLANAR.
+		 */
+		if (var->bits_per_pixel == 12 && var->red.length == 8 &&
+			var->green.length == 2 && var->blue.length == 2 &&
+			 fbi->vid) {
+			if (var->red.offset >= var->blue.offset)
+				return PIX_FMT_YUV420PLANAR;
+			else
+				return PIX_FMT_YVU420PLANAR;
+		}
+		/*
+		 * Check for 565/1555.
+		 */
+		if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
+		    var->green.length <= 6 && var->blue.length <= 5) {
+			if (var->transp.length == 0) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGB565;
+				else
+					return PIX_FMT_BGR565;
+			}
+
+			if (var->transp.length == 1 && var->green.length <= 5) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGB1555;
+				else
+					return PIX_FMT_BGR1555;
+			}
+
+			/* fall through */
+		}
+
+		/*
+		 * Check for 888/A888.
+		 */
+		if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
+		    var->green.length <= 8 && var->blue.length <= 8) {
+			if (var->bits_per_pixel == 24 &&
+				 var->transp.length == 0) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGB888PACK;
+				else
+					return PIX_FMT_BGR888PACK;
+			}
+
+			if (var->bits_per_pixel == 32 &&
+				 var->transp.offset == 24) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGBA888;
+				else
+					return PIX_FMT_BGRA888;
+			} else {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGB888UNPACK;
+				else
+					return PIX_FMT_BGR888UNPACK;
+			}
+			/* fall through */
+		}
+	} else {
+
+		pxa_format = (var->nonstd >> 20) & 0xf;
+
+		switch (pxa_format) {
+		case 0:
+			return PIX_FMT_RGB565;
+			break;
+		case 3:
+			if (fbi->vid)
+				return PIX_FMT_YUV422PLANAR;
+			break;
+		case 4:
+			if (fbi->vid)
+				return PIX_FMT_YUV420PLANAR;
+			break;
+		case 5:
+			return PIX_FMT_RGB1555;
+			break;
+		case 6:
+			return PIX_FMT_RGB888PACK;
+			break;
+		case 7:
+			return PIX_FMT_RGB888UNPACK;
+			break;
+		case 8:
+			return PIX_FMT_RGBA888;
+			break;
+		case 9:
+			return PIX_FMT_YUV422PACK;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
+	return -EINVAL;
+}
+
+int pxa168fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int pix_fmt;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+	if (var->bits_per_pixel == 8) {
+		pr_info("bits per pixel too small\n");
+		return -EINVAL;
+	}
+
+	/* compatibility mode: if the MSB of var->nonstd is 0xAA then
+	 * set xres_virtual and yres_virtual to xres and yres.
+	 */
+
+	if ((var->nonstd >> 24) == 0xAA)
+		fbi->compat_mode = 0x2625;
+
+	if ((var->nonstd >> 24) == 0x55)
+		fbi->compat_mode = 0x0;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+
+	if (var->xoffset + var->xres > var->xres_virtual) {
+		pr_err("ERROR: xoffset(%d) + xres(%d) is greater than "
+			"xres_virtual(%d)\n", var->xoffset, var->xres,
+			var->xres_virtual);
+		return -EINVAL;
+	}
+	if (var->yoffset + var->yres > var->yres_virtual) {
+		pr_err("ERROR: yoffset(%d) + yres(%d) is greater than "
+			"yres_virtual(%d)\n", var->yoffset, var->yres,
+			var->yres_virtual);
+		return -EINVAL;
+	}
+
+	if (var->xres + var->right_margin +
+	    var->hsync_len + var->left_margin > 3500) {
+		pr_err("ERROR: var->xres(%d) + var->right_margin(%d) + "
+			"var->hsync_len(%d) + var->left_margin(%d) > 2048",
+			var->xres, var->right_margin, var->hsync_len,
+			var->left_margin);
+		return -EINVAL;
+	}
+	if (var->yres + var->lower_margin +
+	    var->vsync_len + var->upper_margin > 2500) {
+		pr_err("var->yres(%d) + var->lower_margin(%d) + "
+			"var->vsync_len(%d) + var->upper_margin(%d) > 2048",
+			var->yres, var->lower_margin, var->vsync_len,
+			var->upper_margin);
+		return -EINVAL;
+	}
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (mi->mmap && (var->xres_virtual * var->yres_virtual *
+	    (var->bits_per_pixel >> 3) > fbi->fb_size)) {
+		pr_err("xres_virtual(%d) * yres_virtual(%d) * "
+			"(bits_per_pixel(%d) >> 3) > max_fb_size(%d)",
+			var->xres_virtual, var->yres_virtual,
+			var->bits_per_pixel, fbi->fb_size);
+		return -EINVAL;
+	}
+
+	/*
+	 * Select most suitable hardware pixel format.
+	 */
+	pix_fmt = determine_best_pix_fmt(var, fbi);
+	dev_dbg(fi->dev, "%s determine_best_pix_fmt returned: %d\n",
+		 __func__, pix_fmt);
+	if (pix_fmt < 0)
+		return pix_fmt;
+
+	return 0;
+}
+
+int check_surface(struct fb_info *fi, struct _sOvlySurface *surface)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &fi->var;
+	FBVideoMode new_mode = surface->videoMode;
+	struct _sViewPortInfo *new_info = &surface->viewPortInfo;
+	struct _sViewPortOffset *new_offset = &surface->viewPortOffset;
+	struct _sVideoBufferAddr *new_addr = &surface->videoBufferAddr;
+	int ret = 0;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+
+	/* check view port settings. */
+	if (new_info && memcmp(&fbi->surface.viewPortInfo, new_info,
+			sizeof(struct _sViewPortInfo))) {
+		if (!(new_addr && new_addr->startAddr[0])) {
+			if (mi->mmap && (((new_info->srcWidth *
+			new_info->srcHeight * var->bits_per_pixel / 8) * 2)
+			> fbi->fb_size)) {
+				pr_err("%s: requested memory buffer size %d"
+					"exceed the max limit %d!\n", __func__,
+				(new_info->srcWidth * new_info->srcHeight
+				 * var->bits_per_pixel / 4), fbi->fb_size);
+				return -1;
+			}
+		}
+		fbi->surface.viewPortInfo = *new_info;
+		ret |= UPDATE_VIEW;
+	}
+
+	/* check mode */
+	if (new_mode >= 0 && fbi->surface.videoMode != new_mode) {
+		fbi->surface.videoMode = new_mode;
+		fbi->pix_fmt = convert_pix_fmt(new_mode);
+		set_pix_fmt(var, fbi->pix_fmt);
+		ret |= UPDATE_MODE;
+	}
+
+	/* Check offset	 */
+	if (new_offset && memcmp(&fbi->surface.viewPortOffset, new_offset,
+		sizeof(struct _sViewPortOffset))) {
+		fbi->surface.viewPortOffset.xOffset = new_offset->xOffset;
+		fbi->surface.viewPortOffset.yOffset = new_offset->yOffset;
+		ret |= UPDATE_VIEW;
+	}
+
+	/* Check buffer address */
+	if (new_addr && new_addr->startAddr[0] &&
+		(fbi->surface.videoBufferAddr.startAddr[0] !=
+		 new_addr->startAddr[0])) {
+		/*check overlay buffer address and pitch alignment*/
+		if (((unsigned long)new_addr->startAddr[0] & 63) &&
+			(fbi->surface.viewPortInfo.yPitch & 7) &&
+			(fbi->surface.viewPortInfo.uPitch & 7)) {
+			printk(KERN_WARNING "Ovly: the memory base 0x%08lx is"
+			" not 64 bytes aligned, pitch is not 8 bytes aligned,"
+			" video playback maybe wrong!\n",
+			(unsigned long)new_addr->startAddr[0]);
+		}
+		memcpy(fbi->surface.videoBufferAddr.startAddr,
+			 new_addr->startAddr, sizeof(new_addr->startAddr));
+		ret |= UPDATE_ADDR;
+	}
+
+	return ret;
+}
+
+int check_modex_active(struct pxa168fb_info *fbi)
+{
+	int active;
+
+	if (!fbi)
+		return 0;
+
+	active = fbi->active && fbi->dma_on;
+
+	/* disable all layers if in suspend */
+	if (!gfx_info.fbi[0]->active)
+		active = 0;
+
+	pr_debug("%s fbi[%d] vid %d fbi->active %d"
+		" dma_on %d: %d\n", __func__, fbi->id,
+		fbi->vid, fbi->active, fbi->dma_on, active);
+	return active;
+}
+
+void collectFreeBuf(struct pxa168fb_info *fbi,
+		u8 *filterList[][3], struct regshadow_list *reglist)
+{
+	struct regshadow_list *shadowreg_list = 0;
+	struct regshadow *shadowreg = 0;
+	struct list_head *pos, *n;
+	int i = 0;
+
+	if (!filterList || !reglist)
+		return;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"%s fbi %d vid %d\n",
+			 __func__, fbi->id, fbi->vid);
+
+	list_for_each_safe(pos, n, &reglist->dma_queue) {
+		shadowreg_list = list_entry(pos, struct regshadow_list,
+			dma_queue);
+		list_del(pos);
+		shadowreg = &shadowreg_list->shadowreg;
+
+		if (shadowreg) {
+			/* save ptrs which need to be freed.*/
+			memcpy(filterList[i], &shadowreg->paddr0,
+				 3 * sizeof(u8 *));
+			if (fbi->debug == 1)
+				printk(KERN_DEBUG"buf %x will be returned\n",
+				 shadowreg->paddr0[0]);
+		}
+
+		i++;
+
+		if (i >= MAX_QUEUE_NUM)
+			break;
+
+		kfree(shadowreg_list);
+	}
+}
+
+void clearFilterBuf(u8 *ppBufList[][3], int iFlag)
+{
+	/* Check null pointer. */
+	if (!ppBufList)
+		return;
+	if (RESET_BUF & iFlag)
+		memset(ppBufList, 0, 3 * MAX_QUEUE_NUM * sizeof(u8 *));
+}
+
+void buf_clear(struct regshadow_list *reglist, int iFlag)
+{
+	struct regshadow_list *shadowreg_list;
+	struct list_head *pos, *n;
+
+	/* Check null pointer. */
+	if (!reglist)
+		return;
+
+	/* free */
+	if (FREE_ENTRY & iFlag) {
+		list_for_each_safe(pos, n, &reglist->dma_queue) {
+			shadowreg_list = list_entry(pos, struct regshadow_list,
+				dma_queue);
+			list_del(pos);
+			kfree(shadowreg_list);
+		}
+	}
+}
+
+void clear_buffer(struct pxa168fb_info *fbi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&fbi->buf_lock, flags);
+	clearFilterBuf(fbi->filterBufList, RESET_BUF);
+	buf_clear(&fbi->buf_freelist, FREE_ENTRY);
+	buf_clear(&fbi->buf_waitlist, FREE_ENTRY);
+	kfree(fbi->buf_current);
+	fbi->buf_current = 0;
+	fbi->surface_set = 0;
+	spin_unlock_irqrestore(&fbi->buf_lock, flags);
+}
+
+void buf_endframe(void *point)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)point;
+	struct regshadow_list *shadowreg_list = 0;
+	struct regshadow *shadowreg;
+
+	if (list_empty(&fbi->buf_waitlist.dma_queue))
+		return;
+
+	shadowreg_list = list_first_entry(&fbi->buf_waitlist.dma_queue,
+					struct regshadow_list, dma_queue);
+	shadowreg = &shadowreg_list->shadowreg;
+	list_del(&shadowreg_list->dma_queue);
+
+	/* Update new surface settings */
+	pxa168fb_set_regs(fbi, shadowreg);
+
+	if (fbi->buf_current)
+		list_add_tail(&fbi->buf_current->dma_queue,
+				&fbi->buf_freelist.dma_queue);
+	fbi->buf_current = shadowreg_list;
+}
+
+#if 0
+static int get_list_count(struct regshadow_list *reglist)
+{
+	struct list_head *pos, *n;
+	int count = 0;
+
+	list_for_each_safe(pos, n, &reglist->dma_queue)
+		count++;
+	return count;
+}
+#endif
+
+int flip_buffer(struct fb_info *info, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	unsigned long flags;
+	struct regshadow_list *shadowreg_list = 0, *list;
+	struct regshadow *shadowreg = 0;
+	struct _sOvlySurface surface;
+	u8 *start_addr[3], *input_data;
+	u32 length;
+	int ret = 0;
+
+	mutex_lock(&fbi->access_ok);
+
+	/* Get user-mode data. */
+	if (copy_from_user(&surface, argp,
+				sizeof(struct _sOvlySurface))) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+	if (unsupport_format(fbi, surface.viewPortInfo, surface.videoMode)) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+
+	shadowreg_list = kzalloc(sizeof(struct regshadow_list), GFP_KERNEL);
+	if (shadowreg_list == NULL) {
+		mutex_unlock(&fbi->access_ok);
+		return -EFAULT;
+	}
+	shadowreg = &shadowreg_list->shadowreg;
+
+	update_surface(&surface);
+
+	length = surface.videoBufferAddr.length;
+	start_addr[0] = surface.videoBufferAddr.startAddr[0];
+	input_data = surface.videoBufferAddr.inputData;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d flip buf %p\n",
+				fbi->id, fbi->vid, start_addr[0]);
+	/*
+	 * Has DMA addr?
+	 */
+	if (start_addr[0] && (!input_data)) {
+		spin_lock_irqsave(&fbi->buf_lock, flags);
+#if 0
+		if (get_list_count(&fbi->buf_waitlist) >= 2) {
+			/*if there are more than two frames in waitlist, dequeue
+			*the older frame and enqueue it to freelist,
+			*then enqueue this frame to waitlist*/
+#else
+		while (!list_empty(&fbi->buf_waitlist.dma_queue)) {
+			/* free the waitlist elements if any */
+#endif
+			list = list_first_entry(&fbi->buf_waitlist.dma_queue,
+				struct regshadow_list, dma_queue);
+			list_del(&list->dma_queue);
+			list_add_tail(&list->dma_queue,
+				&fbi->buf_freelist.dma_queue);
+			memset(&fbi->surface, 0, sizeof(fbi->surface));
+			fbi->surface.videoMode = -1;
+		}
+		ret = check_surface(info, &surface);
+		if (ret >= 0) {
+			pxa168fb_set_var(info, shadowreg, ret);
+			if (ret) {
+				/* we update immediately if only addr update */
+				if (shadowreg->flags == UPDATE_ADDR)
+					pxa168fb_set_regs(fbi, shadowreg);
+
+				list_add_tail(&shadowreg_list->dma_queue,
+					&fbi->buf_waitlist.dma_queue);
+				ret = 0;
+			} else
+				/* enqueue the repeated buffer to freelist */
+				list_add_tail(&shadowreg_list->dma_queue,
+					&fbi->buf_freelist.dma_queue);
+		} else {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			ret = -EFAULT;
+		}
+		spin_unlock_irqrestore(&fbi->buf_lock, flags);
+	} else {
+		if (!mi->mmap) {
+			pr_err("fbi %d(line %d): input err, mmap is not"
+				" supported\n", fbi->id, __LINE__);
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return -EINVAL;
+		}
+
+		ret = check_surface(info, &surface);
+		if (ret >= 0) {
+			pxa168fb_set_var(info, shadowreg, ret);
+			ret = 0;
+		} else {
+			pr_err("fbi %d (line %d): vid %d, check surface"
+				"return error\n", fbi->id, __LINE__, fbi->vid);
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		/* copy buffer */
+		if (input_data) {
+			if (NEED_VSYNC(fbi))
+				wait_for_vsync(fbi, SYNC_SELF);
+			/* if support hw DMA, replace this. */
+			if (copy_from_user(fbi->fb_start,
+						input_data, length)){
+				kfree(shadowreg_list);
+				mutex_unlock(&fbi->access_ok);
+				return -EFAULT;
+			}
+			kfree(shadowreg_list);
+			mutex_unlock(&fbi->access_ok);
+			return 0;
+		}
+
+		/*
+		 * if it has its own physical address,
+		 * switch to this memory. don't support YUV planar format
+		 * with split YUV buffers. but below code seems have no
+		 * chancee to execute. - FIXME
+		 */
+		if (start_addr[0]) {
+			if (fbi->mem_status)
+				free_pages(
+						(unsigned long)fbi->fb_start,
+						get_order(fbi->fb_size));
+			else
+				dma_free_writecombine(fbi->dev,
+						fbi->fb_size,
+						fbi->fb_start,
+						fbi->fb_start_dma);
+
+			fbi->fb_start = __va(start_addr[0]);
+			fbi->fb_size = length;
+			fbi->fb_start_dma =
+				(dma_addr_t)__pa(fbi->fb_start);
+			fbi->mem_status = 1;
+			info->fix.smem_start = fbi->fb_start_dma;
+			info->fix.smem_len = fbi->fb_size;
+			info->screen_base = fbi->fb_start;
+			info->screen_size = fbi->fb_size;
+		}
+		kfree(shadowreg_list);
+	}
+	mutex_unlock(&fbi->access_ok);
+
+	return ret;
+}
+
+static void free_buf(struct pxa168fb_info *fbi)
+{
+	struct list_head *pos, *n;
+
+	/* put all buffers into free list */
+	list_for_each_safe(pos, n, &fbi->buf_waitlist.dma_queue) {
+		list_del(pos);
+		list_add_tail(pos, &fbi->buf_freelist.dma_queue);
+	}
+
+	if (fbi->buf_current) {
+		list_add_tail(&fbi->buf_current->dma_queue,
+			&fbi->buf_freelist.dma_queue);
+		fbi->buf_current = 0;
+	}
+
+	memset(&fbi->surface, 0, sizeof(struct _sOvlySurface));
+	fbi->surface.videoMode = -1;
+}
+
+int get_freelist(struct fb_info *info, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+	unsigned long flags;
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d get freelist\n",
+				 fbi->id, fbi->vid);
+
+	spin_lock_irqsave(&fbi->buf_lock, flags);
+
+	/* when lcd is suspend, move all buffers as "switched"*/
+	if (!(gfx_info.fbi[fbi->id]->active))
+		buf_endframe(fbi);
+	/* when video layer dma is off, free all buffers */
+	if (!fbi->dma_on)
+		free_buf(fbi);
+
+	/* Collect expired frame to list */
+	collectFreeBuf(fbi, fbi->filterBufList, &fbi->buf_freelist);
+	spin_unlock_irqrestore(&fbi->buf_lock, flags);
+
+	if (copy_to_user(argp, fbi->filterBufList,
+				3*MAX_QUEUE_NUM*sizeof(u8 *))) {
+		return -EFAULT;
+	}
+	clearFilterBuf(fbi->filterBufList, RESET_BUF);
+
+	if (fbi->debug == 1)
+		printk(KERN_DEBUG"fbi %d vid %d get freelist end\n",
+				fbi->id, fbi->vid);
+
+	return 0;
+}
+
+void set_dma_active(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lcd_regs *regs = get_regs(fbi->id);
+	struct fb_var_screeninfo *v = &gfx_info.fbi[fbi->id]->fb_info->var;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	u32 flag = fbi->vid ? CFG_DMA_ENA_MASK : CFG_GRA_ENA_MASK;
+	u32 enable = fbi->vid ? CFG_DMA_ENA(1) : CFG_GRA_ENA(1);
+	u32 value, dma1, v_size_dst, screen_active, active = 0;
+
+	if ((unsigned long)new_addr->startAddr[0] || mi->mmap ||
+		(!fbi->vid && fb_share && fbi->id == 1))
+		active = check_modex_active(fbi);
+
+	value = active ? enable : 0;
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+	if (fbi->id && !fbi->vid)
+		value = 0;
+#endif
+	/* if video layer is full screen without alpha blending
+	 * then turn off graphics dma to save bandwidth */
+	if (fbi->vid && active) {
+		dma1 = dma_ctrl_read(fbi->id, 1);
+		dma1 &= (CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+		if (dma1 == (CFG_ALPHA_MODE(2) | CFG_ALPHA(0xff))) {
+			v_size_dst = readl(&regs->v_size_z);
+			screen_active = readl(&regs->screen_active);
+			if (v->vmode & FB_VMODE_INTERLACED) {
+				screen_active = (screen_active & 0xffff) |
+					(((screen_active >> 16) << 1) << 16);
+			}
+			if (v_size_dst == screen_active) {
+				flag |= CFG_GRA_ENA_MASK;
+				value &= ~CFG_GRA_ENA_MASK;
+			} else if (check_modex_active(gfx_info.fbi[fbi->id])) {
+				flag |= CFG_GRA_ENA_MASK;
+				value |= CFG_GRA_ENA_MASK;
+			}
+		}
+	}
+
+	dma_ctrl_set(fbi->id, 0, flag, value);
+
+	pr_debug("%s fbi %d: vid %d mask %x vaule %x fbi->active %d\
+		 new_addr %lu\n", __func__, fbi->id, fbi->vid, flag,
+		 value, fbi->active, (unsigned long)new_addr->startAddr[0]);
+}
+
+int dispd_dma_enabled(struct pxa168fb_info *fbi)
+{
+	if (irqs_disabled() || !fbi->active)
+		return 0;
+
+	/* check whether display done irq enabled */
+	if (!(readl(fbi->reg_base + SPU_IRQ_ENA) &
+		display_done_imask(fbi->id)))
+		return 0;
+
+	/* check whether path clock is disabled */
+	if (lcd_clk_get(fbi->id, clk_sclk) & SCLK_DISABLE)
+		return 0;
+
+	/* in modex dma may not be enabled */
+	return dma_ctrl_read(fbi->id, 0) & (fbi->vid ?
+		CFG_DMA_ENA_MASK : CFG_GRA_ENA_MASK);
+}
+
+void clear_dispd_irq(struct pxa168fb_info *fbi)
+{
+	int isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+
+	if ((isr & display_done_imask(fbi->id))) {
+		irq_status_clear(fbi->id, display_done_imask(fbi->id));
+		pr_info("fbi %d irq miss, clear isr %x\n", fbi->id, isr);
+	}
+}
+
+void wait_for_vsync(struct pxa168fb_info *fbi, unsigned char param)
+{
+	struct fbi_info *info = fbi->vid ? NULL : &gfx_info;
+	int ret = 0;
+
+	pr_debug("fbi->id %d vid: %d\n", fbi->id, fbi->vid);
+
+	if(info == NULL && param != SYNC_SELF)
+		return;
+
+	switch (param) {
+	case SYNC_SELF:
+		atomic_set(&fbi->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&fbi->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(fbi);
+		break;
+	case SYNC_PANEL:
+		atomic_set(&info->fbi[0]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[0]->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(info->fbi[0]);
+		break;
+	case SYNC_TV:
+		atomic_set(&info->fbi[1]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[1]->w_intr), HZ/20);
+		if (!ret)
+			clear_dispd_irq(info->fbi[1]);
+		break;
+	case SYNC_PANEL_TV:
+		atomic_set(&info->fbi[0]->w_intr, 0);
+		atomic_set(&info->fbi[1]->w_intr, 0);
+		ret = wait_event_interruptible_timeout(gfx_info.fbi[0]->w_intr_wq,
+				atomic_read(&info->fbi[0]->w_intr) &&
+				atomic_read(&info->fbi[1]->w_intr), HZ/20);
+		if (!ret) {
+			if (atomic_read(&info->fbi[0]->w_intr) == 0)
+				clear_dispd_irq(info->fbi[0]);
+			if (atomic_read(&info->fbi[1]->w_intr) == 0)
+				clear_dispd_irq(info->fbi[1]);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+void pxa168fb_list_init(struct pxa168fb_info *fbi)
+{
+	INIT_LIST_HEAD(&fbi->buf_freelist.dma_queue);
+	INIT_LIST_HEAD(&fbi->buf_waitlist.dma_queue);
+	fbi->buf_current = 0;
+}
+
+void pxa168fb_misc_update(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	lcd_vdma = request_vdma(fbi->id, fbi->vid);
+	if (lcd_vdma) {
+		vdma_info_update(lcd_vdma, fbi->active, fbi->dma_on, fbi->pix_fmt,
+				fbi->surface.viewPortInfo.rotation,
+				fbi->surface.viewPortInfo.yuv_format);
+		pxa688_vdma_config(lcd_vdma);
+	}
+	if (fbi->vid && vid_vsmooth)
+		pxa688fb_vsmooth_set(fbi->id, 1, vid_vsmooth);
+	if (!fbi->vid) {
+		pxa688fb_partdisp_update(fbi->id);
+		if (gfx_vsmooth)
+			pxa688fb_vsmooth_set(fbi->id, 0, gfx_vsmooth);
+	}
+}
+
+void set_start_address(struct fb_info *info, int xoffset, int yoffset,
+			struct regshadow *shadowreg)
+{
+	struct pxa168fb_info *fbi = info->par;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_var_screeninfo *var = &info->var;
+	unsigned long addr_y0 = 0, addr_u0 = 0, addr_v0 = 0;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	int  pixel_offset;
+
+	dev_dbg(info->dev, "Enter %s\n", __func__);
+
+	if ((unsigned long)new_addr->startAddr[0]) {
+		memcpy(&shadowreg->paddr0, new_addr->startAddr,
+			 sizeof(new_addr->startAddr));
+		if (fbi->debug == 1)
+			printk(KERN_DEBUG"%s: buffer updated to %x\n",
+				 __func__, (int)new_addr->startAddr[0]);
+	} else {
+		if (!mi->mmap) {
+			pr_debug("fbi %d(line %d): input err, mmap is not"
+				" supported\n", fbi->id, __LINE__);
+			return;
+		}
+		pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+		addr_y0 = fbi->fb_start_dma + (pixel_offset *
+			(var->bits_per_pixel >> 3));
+		if ((fbi->pix_fmt >= 12) && (fbi->pix_fmt <= 15))
+			addr_u0 = addr_y0 + var->xres * var->yres;
+
+		if ((fbi->pix_fmt >> 1) == 6)
+			addr_v0 = addr_u0 + (var->xres * var->yres >> 1);
+		else if ((fbi->pix_fmt >> 1) == 7)
+			addr_v0 = addr_u0 + (var->xres * var->yres >> 2);
+
+		shadowreg->paddr0[0] = addr_y0;
+		shadowreg->paddr0[1] = addr_u0;
+		shadowreg->paddr0[2] = addr_v0;
+	}
+}
+
+void set_dma_control0(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct pxa168fb_mach_info *mi;
+	u32 x = 0, pix_fmt;
+
+	dev_dbg(fbi->fb_info->dev, "Enter %s\n", __func__);
+
+	mi = fbi->dev->platform_data;
+	pix_fmt = fbi->pix_fmt;
+
+	/* If we are in a pseudo-color mode, we need to enable
+	 * palette lookup  */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		x |= dma_palette(1);
+
+	/* Configure hardware pixel format */
+	x |= dma_fmt(fbi->vid, (pix_fmt & ~0x1000) >> 1);
+
+	/*
+	 * color format in memory:
+	 * PXA168/PXA910:
+	 * PIX_FMT_YUV422PACK: UYVY(CbY0CrY1)
+	 * PIX_FMT_YUV422PLANAR: YUV
+	 * PIX_FMT_YUV420PLANAR: YUV
+	 */
+	if (((pix_fmt & ~0x1000) >> 1) == 5) {
+		/* YUV422PACK, YVU422PACK, YUYV422PACK */
+		x |= dma_csc(fbi->vid, 1);
+		x |= dma_swaprb(fbi->vid, mi->panel_rbswap);
+		if (pix_fmt & 0x1000)
+			/* YUYV422PACK */
+			x |= dma_swapyuv(fbi->vid, 1);
+		else
+			/* YVU422PACK */
+			x |= dma_swapuv(fbi->vid, pix_fmt & 1);
+	} else if (pix_fmt >= 12) {
+		/* PIX_FMT_YUV422PACK_IRE_90_270 is here */
+		if (!fbi->vid)
+			pr_err("%s fmt %d not supported on graphics layer...\n",
+				__func__, pix_fmt);
+		/* PLANAR, YUV422PACK_IRE_90_270, PSEUDOCOLOR */
+		x |= dma_csc(fbi->vid, 1);
+		x |= dma_swapuv(fbi->vid, pix_fmt & 1);
+		x |= dma_swaprb(fbi->vid, (mi->panel_rbswap));
+	} else {
+		/* RGB formats */
+		/* Check red and blue pixel swap.
+		 * 1. source data swap. BGR[M:L] rather than RGB[M:L]
+		 *    is stored in memeory as source format.
+		 * 2. panel output data swap
+		 */
+		x |= dma_swaprb(fbi->vid, mi->panel_rbswap);
+	}
+
+	shadowreg->dma_ctrl0 = x;
+}
+
+void set_screen(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	struct _sOvlySurface *surface = &fbi->surface;
+	struct _sVideoBufferAddr *new_addr = &fbi->surface.videoBufferAddr;
+	u32 xres, yres, xres_z, yres_z, xres_virtual, bits_per_pixel;
+	u32 left = 0, top = 0, pitch[3], x;
+
+	var = &fbi->fb_info->var;
+	xres = var->xres; yres = var->yres;
+	xres_z = var->xres; yres_z = var->yres;
+	xres_virtual = var->xres_virtual;
+	bits_per_pixel = var->bits_per_pixel;
+
+	/* xres_z = total - left - right */
+	xres_z = xres_z - (left << 1);
+	/* yres_z = yres_z - top - bottom */
+	yres_z = yres_z - (top << 1);
+
+	if ((unsigned long)new_addr->startAddr[0]) {
+		xres = surface->viewPortInfo.srcWidth;
+		yres = surface->viewPortInfo.srcHeight;
+		var->xres_virtual = surface->viewPortInfo.srcWidth;
+		var->yres_virtual = surface->viewPortInfo.srcHeight * 2;
+		xres_virtual = surface->viewPortInfo.srcWidth;
+
+		xres_z = surface->viewPortInfo.zoomXSize;
+		yres_z = surface->viewPortInfo.zoomYSize;
+
+		left = surface->viewPortOffset.xOffset;
+		top = surface->viewPortOffset.yOffset;
+
+		pr_debug("surface: xres %d xres_z %d"
+			" yres %d yres_z %d\n left %d top %d\n",
+			xres, xres_z, yres, yres_z, left, top);
+	}
+
+	dev_dbg(fbi->fb_info->dev, "adjust: xres %d xres_z %d"
+		" yres %d yres_z %d\n left %d top %d\n",
+		xres, xres_z, yres, yres_z, left, top);
+
+	pitch[0] = surface->viewPortInfo.yPitch;
+	pitch[1] = surface->viewPortInfo.uPitch;
+	pitch[2] = surface->viewPortInfo.vPitch;
+
+	if (((fbi->pix_fmt & ~0x1000) >> 1) < 6) {
+		pitch[0] = pitch[0] ? pitch[0] : (xres_virtual *
+				 bits_per_pixel >> 3);
+		pitch[1] = pitch[2] = 0;
+	} else {
+		pitch[0] = pitch[0] ? pitch[0] : xres;
+		pitch[1] = pitch[1] ? pitch[1] : xres >> 1;
+		pitch[2] = pitch[2] ? pitch[2] : xres >> 1;
+	}
+	/* start address on screen */
+	shadowreg->start_point = (top << 16) | left;
+	/* resolution, src size */
+	shadowreg->src_size = (yres << 16) | xres;
+	/* resolution, dst size */
+	shadowreg->dst_size = (yres_z << 16) | xres_z;
+	/* pitch, pixels per line */
+	shadowreg->pitch[0] = pitch[0] & 0xFFFF;
+	shadowreg->pitch[1] = pitch[2] << 16 | pitch[1];
+
+	/* enable two-level zoom down if the ratio exceed 2 */
+	if (fbi->vid && xres_z && var->bits_per_pixel) {
+		int shift = (fbi->id == 1) ? 22 : 20;
+		u32 reg = (fbi->id == 2) ? LCD_PN2_LAYER_ALPHA_SEL1 :\
+			 LCD_AFA_ALL2ONE;
+
+		x = readl(fbi->reg_base + reg);
+		if (!(var->xres & 0x1) && ((var->xres >> 1) >= xres_z))
+			x |= 1 << shift;
+		else
+			x &= ~(1 << shift);
+		shadowreg->zoom = x;
+	}
+}
+
+int pxa168fb_set_var(struct fb_info *info, struct regshadow *shadowreg,
+		 u32 flags)
+{
+	struct pxa168fb_info *fbi = info->par;
+
+	/* Configure global panel parameters. */
+	if (flags & UPDATE_VIEW)
+		set_screen(fbi, shadowreg);
+	if (flags & UPDATE_MODE)
+		set_dma_control0(fbi, shadowreg);
+	/* buffer return to user in shadowreg_list->shadowreg */
+	set_start_address(info, info->var.xoffset,
+		info->var.yoffset, shadowreg);
+	shadowreg->flags = flags;
+	return 0;
+}
+
+void pxa168fb_set_regs(struct pxa168fb_info *fbi, struct regshadow *shadowreg)
+{
+	struct lcd_regs *regs = get_regs(fbi->id);
+
+	/* when lcd is suspend, read or write lcd controller's
+	* register is not effective, so just return*/
+	if (!(gfx_info.fbi[fbi->id]->active)) {
+		printk(KERN_DEBUG"LCD is not active, don't touch hardware\n");
+		return;
+	}
+
+	if (shadowreg->flags & UPDATE_ADDR) {
+		if (fbi->vid) {
+			writel(shadowreg->paddr0[0], &regs->v_y0);
+			writel(shadowreg->paddr0[1], &regs->v_u0);
+			writel(shadowreg->paddr0[2], &regs->v_v0);
+		} else
+			writel(shadowreg->paddr0[0], &regs->g_0);
+		shadowreg->flags &= ~UPDATE_ADDR;
+	}
+
+	if (shadowreg->flags & UPDATE_MODE) {
+		dma_ctrl_set(fbi->id, 0, dma_mask(fbi->vid),
+				 shadowreg->dma_ctrl0);
+		shadowreg->flags &= ~UPDATE_MODE;
+	}
+
+	if (shadowreg->flags & UPDATE_VIEW) {
+		if (fbi->vid) {
+			/* start address on screen */
+			writel(shadowreg->start_point, &regs->v_start);
+			/* pitch, pixels per line */
+			writel(shadowreg->pitch[0], &regs->v_pitch_yc);
+			writel(shadowreg->pitch[1], &regs->v_pitch_uv);
+			/* resolution, src size */
+			writel(shadowreg->src_size, &regs->v_size);
+			/* resolution, dst size */
+			writel(shadowreg->dst_size, &regs->v_size_z);
+
+			writel(shadowreg->zoom, fbi->reg_base +
+			 ((fbi->id == 2) ? (LCD_PN2_LAYER_ALPHA_SEL1) :
+			 (LCD_AFA_ALL2ONE)));
+		} else {
+			/* start address on screen */
+			writel(shadowreg->start_point, &regs->g_start);
+			/* pitch, pixels per line */
+			writel(shadowreg->pitch[0], &regs->g_pitch);
+			/* resolution, src size */
+			writel(shadowreg->src_size, &regs->g_size);
+			/* resolution, dst size */
+			writel(shadowreg->dst_size, &regs->g_size_z);
+		}
+		shadowreg->flags &= ~UPDATE_VIEW;
+	}
+
+	set_dma_active(fbi);
+	pxa168fb_misc_update(fbi);
+}
+
+irqreturn_t pxa168_fb_isr(int id)
+{
+	struct pxa168fb_info *fbi;
+	struct regshadow *shadowreg;
+	int vid;
+
+	/* First do video layer update, then graphics layer */
+	for (vid = 1; vid >= 0; vid--) {
+
+		fbi = vid ? NULL : (gfx_info.fbi[id]);
+		if (!fbi)
+			continue;
+
+		shadowreg = &fbi->shadowreg;
+		if (shadowreg && shadowreg->flags)
+			pxa168fb_set_regs(fbi, shadowreg);
+
+		if (atomic_read(&fbi->op_count)) {
+			spin_lock(&fbi->buf_lock);
+			/* do buffer switch for video flip */
+			buf_endframe(fbi);
+			spin_unlock(&fbi->buf_lock);
+		}
+
+		/* wake up queue, only use one queue for all layer */
+		if (atomic_read(&fbi->w_intr) == 0) {
+			atomic_set(&fbi->w_intr, 1);
+			wake_up(&gfx_info.fbi[0]->w_intr_wq);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+/*****************************************************************************/
+static int pxa168fb_regs_dump(int id, char *buf)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	struct lcd_regs *regs = get_regs(id);
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "register base: 0x%p\n", fbi->reg_base);
+	mvdisp_dump(f, "  video layer\n");
+	mvdisp_dump(f, "\tv_y0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_y0) & 0xfff, readl(&regs->v_y0));
+	mvdisp_dump(f, "\tv_u0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_u0) & 0xfff, readl(&regs->v_u0));
+	mvdisp_dump(f, "\tv_v0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_v0) & 0xfff, readl(&regs->v_v0));
+	mvdisp_dump(f, "\tv_c0        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_c0) & 0xfff, readl(&regs->v_c0));
+	mvdisp_dump(f, "\tv_y1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_y1) & 0xfff, readl(&regs->v_y1));
+	mvdisp_dump(f, "\tv_u1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_u1) & 0xfff, readl(&regs->v_u1));
+	mvdisp_dump(f, "\tv_v1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_v1) & 0xfff, readl(&regs->v_v1));
+	mvdisp_dump(f, "\tv_c1        ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_c1) & 0xfff, readl(&regs->v_c1));
+	mvdisp_dump(f, "\tv_pitch_yc  ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_pitch_yc) & 0xfff, readl(&regs->v_pitch_yc));
+	mvdisp_dump(f, "\tv_pitch_uv  ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_pitch_uv) & 0xfff, readl(&regs->v_pitch_uv));
+	mvdisp_dump(f, "\tv_start     ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_start) & 0xfff, readl(&regs->v_start));
+	mvdisp_dump(f, "\tv_size      ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_size) & 0xfff, readl(&regs->v_size));
+	mvdisp_dump(f, "\tv_size_z    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_size_z) & 0xfff, readl(&regs->v_size_z));
+
+	mvdisp_dump(f, "  graphic layer\n");
+	mvdisp_dump(f, "\tg_0         ( @%3x ) 0x%x\n",
+		(int)(&regs->g_0) & 0xfff, readl(&regs->g_0));
+	mvdisp_dump(f, "\tg_1         ( @%3x ) 0x%x\n",
+		(int)(&regs->g_1) & 0xfff, readl(&regs->g_1));
+	mvdisp_dump(f, "\tg_pitch     ( @%3x ) 0x%x\n",
+		(int)(&regs->g_pitch) & 0xfff, readl(&regs->g_pitch));
+	mvdisp_dump(f, "\tg_start     ( @%3x ) 0x%x\n",
+		(int)(&regs->g_start) & 0xfff, readl(&regs->g_start));
+	mvdisp_dump(f, "\tg_size      ( @%3x ) 0x%x\n",
+		(int)(&regs->g_size) & 0xfff, readl(&regs->g_size));
+	mvdisp_dump(f, "\tg_size_z    ( @%3x ) 0x%x\n",
+		(int)(&regs->g_size_z) & 0xfff, readl(&regs->g_size_z));
+
+	mvdisp_dump(f, "  hardware cursor\n");
+	mvdisp_dump(f, "\thc_start    ( @%3x ) 0x%x\n",
+		(int)(&regs->hc_start) & 0xfff, readl(&regs->hc_start));
+	mvdisp_dump(f, "\thc_size     ( @%3x ) 0x%x\n",
+		(int)(&regs->hc_size) & 0xfff, readl(&regs->hc_size));
+
+	mvdisp_dump(f, "  screen\n");
+	mvdisp_dump(f, "\tscreen_size     ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_size) & 0xfff,
+		 readl(&regs->screen_size));
+	mvdisp_dump(f, "\tscreen_active   ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_active) & 0xfff,
+		 readl(&regs->screen_active));
+	mvdisp_dump(f, "\tscreen_h_porch  ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_h_porch) & 0xfff,
+		 readl(&regs->screen_h_porch));
+	mvdisp_dump(f, "\tscreen_v_porch  ( @%3x ) 0x%x\n",
+		(int)(&regs->screen_v_porch) & 0xfff,
+		 readl(&regs->screen_v_porch));
+
+	mvdisp_dump(f, "  color\n");
+	mvdisp_dump(f, "\tblank_color     ( @%3x ) 0x%x\n",
+		 (int)(&regs->blank_color) & 0xfff,
+		 readl(&regs->blank_color));
+	mvdisp_dump(f, "\thc_Alpha_color1 ( @%3x ) 0x%x\n",
+		 (int)(&regs->hc_Alpha_color1) & 0xfff,
+		 readl(&regs->hc_Alpha_color1));
+	mvdisp_dump(f, "\thc_Alpha_color2 ( @%3x ) 0x%x\n",
+		 (int)(&regs->hc_Alpha_color2) & 0xfff,
+		 readl(&regs->hc_Alpha_color2));
+	mvdisp_dump(f, "\tv_colorkey_y    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_y) & 0xfff,
+		 readl(&regs->v_colorkey_y));
+	mvdisp_dump(f, "\tv_colorkey_u    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_u) & 0xfff,
+		 readl(&regs->v_colorkey_u));
+	mvdisp_dump(f, "\tv_colorkey_v    ( @%3x ) 0x%x\n",
+		 (int)(&regs->v_colorkey_v) & 0xfff,
+		 readl(&regs->v_colorkey_v));
+
+	mvdisp_dump(f, "  control\n");
+	mvdisp_dump(f, "\tvsync_ctrl      ( @%3x ) 0x%x\n",
+		 (int)(&regs->vsync_ctrl) & 0xfff,
+		 readl(&regs->vsync_ctrl));
+	mvdisp_dump(f, "\tdma_ctrl0       ( @%3x ) 0x%x\n",
+		 (int)(dma_ctrl(0, id)) & 0xfff,
+		 readl(fbi->reg_base + dma_ctrl0(id)));
+	mvdisp_dump(f, "\tdma_ctrl1       ( @%3x ) 0x%x\n",
+		 (int)(dma_ctrl(1, id)) & 0xfff,
+		 readl(fbi->reg_base + dma_ctrl1(id)));
+	mvdisp_dump(f, "\tintf_ctrl       ( @%3x ) 0x%x\n",
+		 (int)(intf_ctrl(id)) & 0xfff,
+		 readl(fbi->reg_base + intf_ctrl(id)));
+	mvdisp_dump(f, "\tirq_enable      ( @%3x ) 0x%8x\n",
+		 (int)(SPU_IRQ_ENA) & 0xfff,
+		 readl(fbi->reg_base + SPU_IRQ_ENA));
+	mvdisp_dump(f, "\tirq_status      ( @%3x ) 0x%8x\n",
+		 (int)(SPU_IRQ_ISR) & 0xfff,
+		 readl(fbi->reg_base + SPU_IRQ_ISR));
+	mvdisp_dump(f, "\tclk_sclk        ( @%3x ) 0x%x\n",
+		 (int)(clk_reg(id, clk_sclk)) & 0xfff,
+		 readl(clk_reg(id, clk_sclk)));
+	if (clk_reg(id, clk_tclk))
+		mvdisp_dump(f, "\tclk_tclk        ( @%3x ) 0x%x\n",
+			(int)(clk_reg(id, clk_tclk)) & 0xfff,
+			readl(clk_reg(id, clk_tclk)));
+	mvdisp_dump(f, "\tclk_lvds        ( @%3x ) 0x%x\n",
+		 (int)(clk_reg(id, clk_lvds_rd)) & 0xfff,
+		 readl(clk_reg(id, clk_lvds_rd)));
+
+	/* TV path registers */
+	if (id == 1) {
+		mvdisp_dump(f, "\ntv path interlace related:\n");
+		mvdisp_dump(f, "\tv_h_total         ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_V_H_TOTAL_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_V_H_TOTAL_FLD));
+		mvdisp_dump(f, "\tv_porch           ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_V_PORCH_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_V_PORCH_FLD));
+		mvdisp_dump(f, "\tvsync_ctrl        ( @%3x ) 0x%8x\n",
+			(int)(LCD_TV_SEPXLCNT_FLD) & 0xfff,
+			readl(fbi->reg_base + LCD_TV_SEPXLCNT_FLD));
+	}
+
+	mvdisp_dump(f, "\n");
+	return s;
+}
+
+/************************************************************************/
+static size_t lcd_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump path(pn/tv/pn2:0/1/2) registers, var info\n");
+	mvdisp_dump(f, "\tcat lcd\n");
+	mvdisp_dump(f, " - dump all display controller registers\n");
+	mvdisp_dump(f, "\techo l > /proc/pxa168fb\n");
+	mvdisp_dump(f, " - dump register @ [offset_hex]\n");
+	mvdisp_dump(f, "\techo -0x[offset_hex] > lcd\n");
+	mvdisp_dump(f, " - set register @ [offset_hex] with [value_hex]\n");
+	mvdisp_dump(f, "\techo 0x[value_hex] > lcd\n");
+	mvdisp_dump(f, " - count path(pn/tv/pn2:[0/1/2]) interrupts"
+			" within 10s\n");
+	mvdisp_dump(f, "\techo v[path:0/1/2] > lcd\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] error interrupts dump"
+			" (underflow/axi error) at run time\n");
+	mvdisp_dump(f, "\techo e[en/dis:1/0] > lcd\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] flip/free buffers info"
+			" dump (print level KERN_DEBUG)\n");
+	mvdisp_dump(f, "\techo d[en/dis:1/0] > lcd\n");
+
+	return s;
+}
+
+static ssize_t lcd_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct fb_var_screeninfo *var = &fbi->fb_info->var;
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "path %d:\n\tactive %d, dma_on %d\n",
+		fbi->id, fbi->active, fbi->dma_on);
+	if (!fbi->vid)
+		mvdisp_dump(f, "\tpath frm time %luus, clk_src %luMHz\n",
+			fbi->frm_usec, clk_get_rate(fbi->clk)/1000000);
+	mvdisp_dump(f, "\tgfx_udflow %d, vid_udflow %d, axi_err %d\n",
+		gfx_udflow_count, vid_udflow_count, axi_err_count);
+	mvdisp_dump(f, "\tdebug %d, DBG_VSYNC_PATH %d, DBG_ERR_IRQ %d\n",
+		fbi->debug, DBG_VSYNC_PATH, DBG_ERR_IRQ);
+
+	mvdisp_dump(f, "var info:\n");
+	mvdisp_dump(f, "\txres              %4d yres              %4d\n",
+		var->xres, var->yres);
+	mvdisp_dump(f, "\txres_virtual      %4d yres_virtual      %4d\n",
+		var->xres_virtual, var->yres_virtual);
+	mvdisp_dump(f, "\txoffset           %4d yoffset           %4d\n",
+		var->xoffset, var->yoffset);
+	mvdisp_dump(f, "\tleft_margin(hbp)  %4d right_margin(hfp) %4d\n",
+		var->left_margin, var->right_margin);
+	mvdisp_dump(f, "\tupper_margin(vbp) %4d lower_margin(vfp) %4d\n",
+		var->upper_margin, var->lower_margin);
+	mvdisp_dump(f, "\thsync_len         %4d vsync_len         %4d\n",
+		var->hsync_len,	var->vsync_len);
+	mvdisp_dump(f, "\tbits_per_pixel    %d\n", var->bits_per_pixel);
+	mvdisp_dump(f, "\tpixclock          %d\n", var->pixclock);
+	mvdisp_dump(f, "\tsync              0x%x\n", var->sync);
+	mvdisp_dump(f, "\tvmode             0x%x\n", var->vmode);
+	mvdisp_dump(f, "\trotate            0x%x\n\n", var->rotate);
+
+	s += pxa168fb_regs_dump(fbi->id, buf + s);
+#ifdef CONFIG_PXA688_MISC
+	if (fbi->id == fb_vsmooth) {
+		mvdisp_dump(f, "=== vertical smooth path %d by filter %d==\n",
+			fb_vsmooth, fb_filter);
+		s += pxa168fb_regs_dump(fb_filter, buf + s);
+	}
+#endif
+
+	s += lcd_help(buf + s);
+
+	return s;
+}
+
+static u32 mvdisp_reg;
+static ssize_t lcd_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	u32 addr = (u32)fbi->reg_base, i, tmp;
+	char vol[30];
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return size;
+	}
+
+	if ('d' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		fbi->debug = (int) simple_strtoul(vol, NULL, 10);
+		/* fbi->debug usage:
+		 *	1: show flip/get freelist sequence
+		 */
+		return size;
+	} else if ('e' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10) << DBG_ERR_SHIFT;
+		if (tmp != DBG_ERR_IRQ) {
+			debug_flag &= ~DBG_ERR_MASK; debug_flag |= tmp;
+		}
+		return size;
+	} else if ('v' == buf[0]) {
+		if (size > 2) {
+			memcpy(vol, (void *)((u32)buf + 1), size - 1);
+			tmp = (int) simple_strtoul(vol, NULL, 10) << DBG_VSYNC_SHIFT;
+		} else
+			tmp = fbi->id;
+		if (tmp != DBG_VSYNC_PATH) {
+			debug_flag &= ~DBG_VSYNC_MASK; debug_flag |= tmp;
+		}
+		vsync_check_count();
+		return size;
+	} else if ('-' == buf[0]) {
+		memcpy(vol, buf+1, size-1);
+		mvdisp_reg = (int) simple_strtoul(vol, NULL, 16);
+		pr_info("reg @ 0x%x: 0x%x\n", mvdisp_reg,
+			__raw_readl(addr + mvdisp_reg));
+		return size;
+	} else if ('0' == buf[0] && 'x' == buf[1]) {
+		/* set the register value */
+		tmp = (int)simple_strtoul(buf, NULL, 16);
+		__raw_writel(tmp, addr + mvdisp_reg);
+		pr_info("set reg @ 0x%x: 0x%x\n", mvdisp_reg,
+			__raw_readl(addr + mvdisp_reg));
+		return size;
+	} else if ('l' == buf[0]) {
+		pr_info("\ndisplay controller regs\n");
+		for (i = 0; i < 0x300; i += 4) {
+			if (!(i % 16))
+				printk("\n0x%3x: ", i);
+			printk(" %8x", __raw_readl(addr + i));
+		}
+		pr_info("\n");
+		return size;
+	}
+
+	return size;
+}
+
+DEVICE_ATTR(lcd, S_IRUGO | S_IWUSR, lcd_show, lcd_store);
diff --git a/drivers/video/pxa168fb_common.h b/drivers/video/pxa168fb_common.h
new file mode 100644
index 0000000..3987993
--- /dev/null
+++ b/drivers/video/pxa168fb_common.h
@@ -0,0 +1,77 @@
+#ifndef _PXA168FB_COMMON_
+#define _PXA168FB_COMMON_
+
+#include <mach/pxa168fb.h>
+#include "pxa168fb.h"
+
+#define RESET_BUF	0x1
+#define FREE_ENTRY	0x2
+
+#define DBG_VSYNC_SHIFT	(0)
+#define DBG_VSYNC_MASK	(0x3 << DBG_VSYNC_SHIFT)
+#define DBG_VSYNC_PATH	((debug_flag & DBG_VSYNC_MASK) >> DBG_VSYNC_SHIFT)
+#define DBG_ERR_SHIFT	(2)
+#define DBG_ERR_MASK	(0x1 << DBG_ERR_SHIFT)
+#define DBG_ERR_IRQ	((debug_flag & DBG_ERR_MASK) >> DBG_ERR_SHIFT)
+#define DBG_IRQ_PATH	(debug_flag & DBG_VSYNC_MASK)
+
+#define NEED_VSYNC(fbi)	(fbi->wait_vsync && dispd_dma_enabled(fbi))
+
+#define DUMP_SPRINTF	(1 << 0)
+#define DUMP_PRINFO	(1 << 1)
+#define mvdisp_dump(flag, fmt, ...)	do {			\
+	if (flag & DUMP_SPRINTF)				\
+		s += sprintf(buf + s, fmt, ##__VA_ARGS__);	\
+	if (flag & DUMP_PRINFO)					\
+		pr_info(fmt, ##__VA_ARGS__);			\
+} while (0)
+
+extern int fb_share;
+extern int gfx_udflow_count;
+extern int vid_udflow_count;
+extern int axi_err_count;
+extern int debug_flag;
+extern struct fbi_info gfx_info;
+extern struct fbi_info ovly_info;
+extern struct device_attribute dev_attr_lcd;
+extern struct device_attribute dev_attr_phy;
+extern struct device_attribute dev_attr_vdma;
+
+extern u32 clk_reg(int id, u32 type);
+extern void vsync_check_count(void);
+extern int unsupport_format(struct pxa168fb_info *fbi,
+	 struct _sViewPortInfo viewPortInfo, FBVideoMode videoMode);
+extern int convert_pix_fmt(u32 vmode);
+extern int set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt);
+extern int determine_best_pix_fmt(struct fb_var_screeninfo *var,
+	struct pxa168fb_info *fbi);
+extern int pxa168fb_check_var(struct fb_var_screeninfo *var,
+	 struct fb_info *fi);
+extern int check_surface(struct fb_info *fi, struct _sOvlySurface *surface);
+extern int check_surface_addr(struct fb_info *fi,
+	 struct _sOvlySurface *surface);
+extern int check_modex_active(struct pxa168fb_info *fbi);
+
+extern void buf_endframe(void *point);
+extern void clear_buffer(struct pxa168fb_info *fbi);
+extern void pxa168fb_list_init(struct pxa168fb_info *fbi);
+extern int flip_buffer(struct fb_info *info, unsigned long arg);
+extern int get_freelist(struct fb_info *info, unsigned long arg);
+
+extern void set_dma_active(struct pxa168fb_info *fbi);
+extern int dispd_dma_enabled(struct pxa168fb_info *fbi);
+extern void wait_for_vsync(struct pxa168fb_info *fbi, unsigned char param);
+extern void pxa168fb_misc_update(struct pxa168fb_info *fbi);
+extern void set_start_address(struct fb_info *info, int xoffset,
+		 int yoffset, struct regshadow *shadowreg);
+extern void set_dma_control0(struct pxa168fb_info *fbi,
+		 struct regshadow *shadowreg);
+extern void set_screen(struct pxa168fb_info *fbi, struct regshadow *shadowreg);
+extern int pxa168fb_set_var(struct fb_info *info,
+		 struct regshadow *shadowreg, u32 flags);
+extern void pxa168fb_set_regs(struct pxa168fb_info *fbi,
+		 struct regshadow *shadowreg);
+extern irqreturn_t pxa168_fb_isr(int id);
+extern irqreturn_t pxa168_v4l2_isr(int id);
+extern int wakeup_ddr_fc_seq(void);
+#endif
diff --git a/drivers/video/pxa688_cmu.c b/drivers/video/pxa688_cmu.c
new file mode 100644
index 0000000..02b08dc
--- /dev/null
+++ b/drivers/video/pxa688_cmu.c
@@ -0,0 +1,355 @@
+/*
+ * linux/drivers/video/pxa168fb.c -- Marvell PXA168 LCD Controller
+ *
+ *  Copyright (C) 2008 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2009-02-16  adapted from original version for PXA168
+ *		Kevin Liu <kliu5@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_PXA688_CMU
+
+#include "pxa168fb_common.h"
+#include <mach/io.h>
+#include <mach/irqs.h>
+#include <mach/pxa168fb.h>
+#include <mach/hardware.h>
+#include <mach/cputype.h>
+#include <mach/gpio.h>
+
+#include <asm/mach-types.h>
+#include <mach/regs-apmu.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/regs-mpmu.h>
+#include <asm/mach-types.h>
+
+
+static void pxa688fb_cmu_write(struct pxa168fb_info *fbi,
+			 unsigned int addr, unsigned int data)
+{
+	if (addr <= 0x88) {
+		writel(data, fbi->reg_base + 0x400 + addr);
+	} else {
+		writel(data & 0xff, fbi->reg_base + 0x400);
+		writel(addr | 0x80000000, fbi->reg_base + 0x404);
+	}
+}
+
+static unsigned int pxa688fb_cmu_read(struct pxa168fb_info *fbi,
+					 unsigned int addr)
+{
+	unsigned int val;
+	if (addr <= 0x88)
+		val = readl(fbi->reg_base + 0x400 + addr);
+	else {
+		writel(addr | 0x40000000, fbi->reg_base + 0x404);
+		val = readl(fbi->reg_base + 0x400) & 0xff;
+	}
+	return val;
+}
+
+int pxa688_cmu_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+	struct pxa168fb_info *fbi = info->par;
+	void __user *argp = (void __user *)arg;
+	struct mvdisp_cmu_config cmu_config;
+	struct mvdisp_cmu_pip rect;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct cmu_res res;
+	int val, val_top, val_io_overl, val_bln_ctl, vsync_enable, hsync_enable;
+	unsigned int pip_h, pip_v, main_h, main_v;
+	static int path = 0;
+	unsigned hsync_len = gfx_info.fbi[path]->fb_info->var.hsync_len;
+	unsigned vsync_len = gfx_info.fbi[path]->fb_info->var.vsync_len;
+	unsigned left_margin = gfx_info.fbi[path]->fb_info->var.left_margin;
+	unsigned upper_margin = gfx_info.fbi[path]->fb_info->var.upper_margin;
+	unsigned yres = gfx_info.fbi[path]->fb_info->var.yres;
+	unsigned xres = gfx_info.fbi[path]->fb_info->var.xres;
+
+	switch (cmd) {
+	case FB_IOCTL_CMU_GET_RES:
+		if (copy_from_user(&res, argp, sizeof(res)))
+			return -EFAULT;
+		res.width = xres;
+		res.height = yres;
+		return copy_to_user(argp, &res, sizeof(res)) ?
+			 -EFAULT : 0;
+		break;
+	case FB_IOCTL_CMU_SWITCH:	/* FIXME */
+		if (arg) {
+			writel(0x1, fbi->reg_base + 0x400 + CMU_CTRL);
+			val = readl(fbi->reg_base + LCD_TOP_CTRL);
+			if (fbi->id == 0)
+				val |= 0x1;
+			else
+				val |= 0x3;
+			writel(val, fbi->reg_base + LCD_TOP_CTRL);
+		} else {
+			val = readl(fbi->reg_base + LCD_TOP_CTRL);
+			val &= (~0x3);
+			writel(val, fbi->reg_base + LCD_TOP_CTRL);
+			writel(0x0, fbi->reg_base + 0x400 + CMU_CTRL);
+		}
+		break;
+	case FB_IOCTL_CMU_SET_PIP:
+		if (copy_from_user(&rect, argp, sizeof(rect)))
+			return -EFAULT;
+		/*if vsync/hsync inverted, exclude hsync_len and vsync_len*/
+		hsync_enable = (readl(fbi->reg_base + intf_ctrl(fbi->id))
+			& HINVERT_MSK) >> HINVERT_LEN;
+		vsync_enable = (readl(fbi->reg_base + intf_ctrl(fbi->id))
+			& VINVERT_MSK) >> VINVERT_LEN;
+		if (hsync_enable)
+			hsync_len = 0;
+		if (vsync_enable)
+			vsync_len = 0;
+		/*calculate pip setting data*/
+		pip_h = ((rect.left + left_margin + hsync_len +
+			 mi->cmu_cal[path].left) & 0xfff) |
+			((rect.right + left_margin + hsync_len +
+			 mi->cmu_cal[path].right)<<12 & 0xfff000);
+		pip_v = ((rect.top + upper_margin + vsync_len +
+			 mi->cmu_cal[path].top) & 0xfff) |
+			((rect.bottom + upper_margin + vsync_len +
+			 mi->cmu_cal[path].bottom)<<12 & 0xfff000);
+		main_h = ((left_margin + hsync_len) & 0xfff) |
+		((xres + hsync_len + left_margin)<<12 & 0xfff000);
+		main_v = ((upper_margin + vsync_len) & 0xfff) |
+		((yres + upper_margin + vsync_len)<<12 & 0xfff000);
+		/*set pip register*/
+		/* ACE_PIP_DE */
+		writel(pip_h, fbi->reg_base + 0x400 + 0x08);
+		writel(pip_v, fbi->reg_base + 0x400 + 0x0c);
+		/* PIP_DE */
+		writel(pip_h, fbi->reg_base + 0x400 + 0x28);
+		writel(pip_v, fbi->reg_base + 0x400 + 0x2c);
+		/* PRI */
+		writel(pip_h, fbi->reg_base + 0x400 + 0x10);
+		writel(pip_v, fbi->reg_base + 0x400 + 0x14);
+		/* ACE_MAIN_DE */
+		writel(main_h, fbi->reg_base + 0x400 + 0x20);
+		writel(main_v, fbi->reg_base + 0x400 + 0x24);
+		writel(0x3f, fbi->reg_base + 0x400 + 0x30);
+		break;
+
+	case FB_IOCTL_CMU_SET_LETTER_BOX:
+		if (copy_from_user(&rect, argp, sizeof(rect)))
+			return -EFAULT;
+		/* if vsync/hsync inverted, exclude hsync_len and vsync_len */
+		hsync_enable = (readl(fbi->reg_base + intf_ctrl(fbi->id))
+			& HINVERT_MSK) >> HINVERT_LEN;
+		vsync_enable = (readl(fbi->reg_base + intf_ctrl(fbi->id))
+			& VINVERT_MSK) >> VINVERT_LEN;
+		if (hsync_enable)
+			hsync_len = 0;
+		if (vsync_enable)
+			vsync_len = 0;
+		/* calculate letter box setting data */
+		pip_h = ((rect.left + left_margin + hsync_len +
+			 mi->cmu_cal_letter_box[path].left) & 0xfff) |
+			((rect.right + left_margin + hsync_len +
+			 mi->cmu_cal_letter_box[path].right) << 12 &
+			 0xfff000);
+		pip_v = ((rect.top + upper_margin + vsync_len +
+			 mi->cmu_cal_letter_box[path].top) & 0xfff) |
+			((rect.bottom + upper_margin + vsync_len +
+			 mi->cmu_cal_letter_box[path].bottom) << 12 &
+			 0xfff000);
+		/* set letter box register */
+		/* ACE_LETTER_BOX_DE */
+		writel(pip_h, fbi->reg_base + 0x400 + 0x18);
+		writel(pip_v, fbi->reg_base + 0x400 + 0x1c);
+		val = readl(fbi->reg_base + 0x400 + 0x30);
+		/* Enable Letter box setting */
+		writel(val|0x3, fbi->reg_base + 0x400 + 0x30);
+		break;
+
+	case FB_IOCTL_CMU_SET_ROUTE:
+		val = readl(fbi->reg_base + 0x400 + CMU_CTRL);
+		val_top = readl(fbi->reg_base + LCD_TOP_CTRL);
+		val_io_overl = 0;
+		val_bln_ctl = 0;
+		if (arg == ICR_DRV_ROUTE_OFF) {
+			val &= ~CMU_CLK_CTRL_ENABLE;
+			val_top &= ~LCD_TOP_CTRL_CMU_ENABLE;
+		} else if (arg == ICR_DRV_ROUTE_TV) {
+			val |= CMU_CLK_CTRL_ENABLE;
+			val &= ~CMU_CTRL_A0_MSK;
+			val |= CMU_CTRL_A0_TV << 1;
+
+			val_top |= LCD_TOP_CTRL_CMU_ENABLE;
+
+			val_io_overl &= ~LCD_IO_OVERL_MSK;
+			val_io_overl |= LCD_IO_OVERL_TV;
+
+			val_io_overl &= ~LCD_IO_CMU_IN_SEL_MSK;
+			val_io_overl |= LCD_IO_CMU_IN_SEL_TV << 20;
+
+			val_io_overl &= ~LCD_IO_TV_OUT_SEL_MSK;
+			val_io_overl |= LCD_IO_TV_OUT_SEL_NON << 26;
+			path = 1;
+		} else if (arg == ICR_DRV_ROUTE_LCD1) {
+			val |= CMU_CLK_CTRL_ENABLE;
+			val &= ~CMU_CTRL_A0_MSK;
+			val |= CMU_CTRL_A0_LCD1 << 1;
+
+			val_top |= LCD_TOP_CTRL_CMU_ENABLE;
+			val_io_overl &= ~LCD_IO_OVERL_MSK;
+			val_io_overl |= LCD_IO_OVERL_LCD1;
+			val_io_overl &= ~LCD_IO_CMU_IN_SEL_MSK;
+			val_io_overl |= LCD_IO_CMU_IN_SEL_PN << 20;
+			val_io_overl &= ~LCD_IO_PN_OUT_SEL_MSK;
+			val_io_overl |= LCD_IO_PN_OUT_SEL_NON << 24;
+
+			val_bln_ctl = 0x300;
+			path = 0;
+		} else if (arg == ICR_DRV_ROUTE_LCD2) {
+			val |= CMU_CLK_CTRL_ENABLE;
+			val &= ~CMU_CTRL_A0_MSK;
+			val |= CMU_CTRL_A0_LCD2 << 1;
+
+			val_top |= LCD_TOP_CTRL_CMU_ENABLE;
+			val_io_overl &= ~LCD_IO_OVERL_MSK;
+			val_io_overl |= LCD_IO_OVERL_LCD2;
+			val_io_overl &= ~LCD_IO_CMU_IN_SEL_MSK;
+			val_io_overl |= LCD_IO_CMU_IN_SEL_PN2 << 20;
+			val_io_overl &= ~LCD_IO_PN2_OUT_SEL_MSK;
+			val_io_overl |= LCD_IO_PN2_OUT_SEL_NON << 28;
+
+			val_bln_ctl = 0xc00;
+			path = 2;
+		}
+		/* CMU_CTRL_EN_CFG */
+		writel(0x3e, fbi->reg_base + 0x400 + 0x30);
+		writel(val_top, fbi->reg_base + LCD_TOP_CTRL);
+		writel(val, fbi->reg_base + 0x400 + CMU_CTRL);
+		writel(val_io_overl, fbi->reg_base +
+			 LCD_IO_OVERL_MAP_CTRL);
+		writel(val_bln_ctl, fbi->reg_base + LCD_2ND_BLD_CTL);
+		break;
+
+	case FB_IOCTL_CMU_WRITE:
+		if (copy_from_user(&cmu_config, argp,
+				 sizeof(cmu_config)))
+			return -EFAULT;
+		pxa688fb_cmu_write(fbi, cmu_config.addr,
+				 cmu_config.data);
+		break;
+
+	case FB_IOCTL_CMU_READ:
+		if (copy_from_user(&cmu_config, argp,
+			 sizeof(cmu_config)))
+			return -EFAULT;
+		cmu_config.data = pxa688fb_cmu_read(fbi,
+				 cmu_config.addr);
+		return copy_to_user(argp, &cmu_config,
+			 sizeof(cmu_config)) ? -EFAULT : 0;
+		break;
+
+	default:
+		pr_info("%s: unknown IOCTL 0x%x\n", __func__, cmd);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int cmu_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	void *cmu_base = fbi->reg_base + 0x400;
+	unsigned res;
+	unsigned addr = (unsigned)simple_strtoul(buf, NULL, 16);
+	writel(0x40000000 | addr, cmu_base + 4);
+	res = readl(cmu_base) & 0xff;
+	pr_info("addr 0x%x is 0x%x\n", addr, res);
+	return size;
+}
+static int cmu_show(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	void *cmu_base = fbi->reg_base + 0x400;
+	pr_info("cmu\n");
+	pr_info("CMU_PIP_DE_H_CFG : %8x\n", readl(cmu_base + 0x8));
+	pr_info("CMU_PIP_DE_V_CFG : %8x\n", readl(cmu_base + 0xc));
+	pr_info("CMU_PRI_H_CFG : %8x\n", readl(cmu_base + 0x10));
+	pr_info("CMU_PRI_V_CFG : %8x\n", readl(cmu_base + 0x14));
+	pr_info("CMU_LETTER_BOX_H_CFG : %8x\n", readl(cmu_base + 0x18));
+	pr_info("CMU_LETTER_BOX_V_CFG : %8x\n", readl(cmu_base + 0x1C));
+	pr_info("CMU_ACE_MAIN_DE_H_CFG : %8x\n", readl(cmu_base + 0x20));
+	pr_info("CMU_ACE_MAIN_DE_V_CFG : %8x\n", readl(cmu_base + 0x24));
+	pr_info("CMU_ACE_PIP_DE_H_CFG : %8x\n", readl(cmu_base + 0x28));
+	pr_info("CMU_ACE_PIP_DE_V_CFG : %8x\n", readl(cmu_base + 0x2c));
+	pr_info("CMU_CTL_EN_CFG : %8x\n", readl(cmu_base + 0x30));
+	pr_info("CMU_BAR_0_CFG : %8x\n", readl(cmu_base + 0x34));
+	pr_info("CMU_BAR_1_CFG : %8x\n", readl(cmu_base + 0x38));
+	pr_info("CMU_BAR_2_CFG : %8x\n", readl(cmu_base + 0x3c));
+	pr_info("CMU_BAR_3_CFG : %8x\n", readl(cmu_base + 0x40));
+	pr_info("CMU_BAR_4_CFG : %8x\n", readl(cmu_base + 0x44));
+	pr_info("CMU_BAR_5_CFG : %8x\n", readl(cmu_base + 0x48));
+	pr_info("CMU_BAR_6_CFG : %8x\n", readl(cmu_base + 0x4c));
+	pr_info("CMU_BAR_7_CFG : %8x\n", readl(cmu_base + 0x50));
+	pr_info("CMU_BAR_8_CFG : %8x\n", readl(cmu_base + 0x54));
+	pr_info("CMU_BAR_9_CFG : %8x\n", readl(cmu_base + 0x58));
+	pr_info("CMU_BAR_10_CFG : %8x\n", readl(cmu_base + 0x5c));
+	pr_info("CMU_BAR_11_CFG : %8x\n", readl(cmu_base + 0x60));
+	pr_info("CMU_BAR_12_CFG : %8x\n", readl(cmu_base + 0x64));
+	pr_info("CMU_BAR_13_CFG : %8x\n", readl(cmu_base + 0x68));
+	pr_info("CMU_BAR_14_CFG : %8x\n", readl(cmu_base + 0x6c));
+	pr_info("CMU_BAR_15_CFG : %8x\n", readl(cmu_base + 0x70));
+	pr_info("CMU_BAR_CTRL : %8x\n", readl(cmu_base + 0x74));
+	pr_info("PATTERN_TOTAL : %8x\n", readl(cmu_base + 0x78));
+	pr_info("PATTERN_ACTIVE : %8x\n", readl(cmu_base + 0x7c));
+	pr_info("PATTERN_FRONT_PORCH : %8x\n", readl(cmu_base + 0x80));
+	pr_info("PATTERN_BACK_PORCH : %8x\n", readl(cmu_base + 0x84));
+	pr_info("CMU_CTRL : %8x\n", readl(cmu_base + 0x88));
+	return 0;
+}
+
+static DEVICE_ATTR(cmu, S_IRUGO | S_IWUSR, cmu_show, cmu_store);
+
+static int __devinit cmu_init(void)
+{
+
+	int ret;
+	ret = device_create_file(gfx_info.fbi[0]->dev, &dev_attr_cmu);
+	if (ret < 0) {
+		pr_err("device attr create fail: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+module_init(cmu_init);
+
+MODULE_AUTHOR("Yifan Zhang<zhangyf@marvell.com>");
+MODULE_DESCRIPTION("CMU driver for PXA688");
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/video/pxa688_misc.c b/drivers/video/pxa688_misc.c
new file mode 100644
index 0000000..cc380fa
--- /dev/null
+++ b/drivers/video/pxa688_misc.c
@@ -0,0 +1,1081 @@
+/*
+ * linux/drivers/video/pxa688fb_misc.c -- Marvell PXA668 LCD Controller
+ *
+ * Copyright (C) Marvell Semiconductor Company.  All rights reserved.
+ *
+ * 2011-05-25  Jing Xiang <jxiang@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include <linux/timer.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <mach/pxa168fb.h>
+
+#include "pxa168fb_common.h"
+
+/* fb_vsmooth: the path that need to do smoothing. e.g. TV
+ * fb_filter: the path that used for smoothing. e.g. PN2
+ */
+int fb_vsmooth;
+int fb_filter;
+int gfx_vsmooth;
+int vid_vsmooth;
+
+static int debug;
+
+/* graphic layer partial display, color format should be RGB565 */
+int pxa688fb_partdisp_set(struct mvdisp_partdisp grap)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[1];
+	struct fb_info *info = fbi->fb_info;
+	struct fb_var_screeninfo *var = &info->var;
+	struct lcd_regs *regs;
+	u32 xres, yres, yres_z, color3_0, color7_4, color11_8, color15_12;
+	u32 base, mask, gfx_fmt, bytespp, shift, offset, threshold, region, tmp;
+
+	gfx_fmt = (dma_ctrl_read(grap.id, 0) & (0xf << 16)) >> 16;
+	if (gfx_fmt == PIX_FMT_RGB565 || gfx_fmt == PIX_FMT_RGB1555 >> 1 ||
+		gfx_fmt == PIX_FMT_YUV422PACK >> 1)
+		bytespp = 16 >> 3;
+	else if (gfx_fmt == PIX_FMT_RGB888PACK >> 1)
+		bytespp = 24 >> 3;
+	else if (gfx_fmt == PIX_FMT_RGB888UNPACK >> 1 ||
+		gfx_fmt == PIX_FMT_RGBA888 >> 1)
+		bytespp = 32 >> 3;
+	else
+		return -EINVAL;
+
+	regs = get_regs(grap.id);
+	xres = readl(&regs->g_size) & 0xfff;
+	yres = (readl(&regs->g_size) & 0xfff0000) >> 16;
+	yres_z = (readl(&regs->g_size_z) & 0xfff0000) >> 16;
+
+	if (!yres)
+		return -EINVAL;
+
+	/* partial display region should be not larger than source size*/
+	if (grap.horpix_start > xres)
+		grap.horpix_start = xres;
+	if (grap.horpix_end > xres)
+		grap.horpix_end = xres;
+	if (grap.vertline_start > yres)
+		grap.vertline_start = yres;
+	if (grap.vertline_end > yres)
+		grap.vertline_end = yres;
+
+	if (grap.id == 1 &&
+		var->vmode & FB_VMODE_INTERLACED) {
+		/* tv interlace mode */
+		grap.vertline_start = grap.vertline_start >> 1;
+		grap.vertline_end = grap.vertline_end >> 1;
+	}
+
+	/* adjust vertical start/end lines according to zoom size */
+	grap.vertline_start = grap.vertline_start * yres_z / yres;
+	grap.vertline_end = grap.vertline_end * yres_z / yres;
+
+	/* adjust hortizontal start/end pixel number according to:
+	 * 1. start pixel number should be
+	 *    (DMA burst length / bytes per pixel) aligned.
+	 * 2. (end pixel number - start pixel number -
+	 *    path threshold / bytes per pixel) should be
+	 *    64 / bytes per pixel aligned.
+	 */
+	if (grap.horpix_end > grap.horpix_start) {
+		shift = (grap.id == 1 ? 14 : 10);
+		offset = (grap.id == 1 ? 16 : 1);
+
+		/* THRESHOLD_x: the least bytes to operate for
+		 * horizontal partial display
+		 */
+		threshold = (grap.id == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+		base = (u32)fbi->reg_base +
+			(grap.id == 2 ? PN2_IOPAD_CONTROL : LCD_TOP_CTRL);
+		mask = readl(base) & (3 << shift);
+		mask = (((mask >> shift) + 1) << 6) / bytespp;
+
+		/* adjust horizontal start pixel number */
+		grap.horpix_start /= mask;
+		grap.horpix_start *= mask;
+
+		/* adjust horizontal end pixel number */
+		region = grap.horpix_end - grap.horpix_start;
+		if (region  > (threshold / bytespp)) {
+			region -= (threshold / bytespp);
+
+			/* BURST_LEN: AXI burst size, platform dependent */
+			if (region >= (BURST_LEN / bytespp)) {
+				tmp = region % (BURST_LEN / bytespp);
+				region /= (BURST_LEN / bytespp);
+				region *= (BURST_LEN / bytespp);
+				grap.horpix_end = grap.horpix_start + region +
+					threshold / bytespp;
+				if (grap.id == 1 && tmp >= (THRESHOLD_PN * 2 -
+					THRESHOLD_TV) / bytespp)
+					/* add extra 64 /bytespp for TV path*/
+					grap.horpix_end += (BURST_LEN / bytespp);
+			} else
+				grap.horpix_end = grap.horpix_start +
+					threshold / bytespp + offset;
+		} else
+			grap.horpix_end = grap.horpix_start;
+	}
+
+	color3_0 = grap.color & 0x000f;
+	color7_4 = (grap.color & 0x00f0) >> 4;
+	color11_8 = (grap.color & 0x0f00) >> 8;
+	color15_12 = (grap.color & 0xf000) >> 12;
+
+	/* horizontal register setting */
+	mask = grap.horpix_start | (color3_0 << 12)
+		| (grap.horpix_end << 16) | (color7_4 << 28);
+	writel(mask, (u32)fbi->reg_base + gra_partdisp_ctrl_hor(grap.id));
+	/* vertical register setting */
+	mask = grap.vertline_start	| (color11_8  << 12)
+		| (grap.vertline_end << 16) | (color15_12 << 28);
+	writel(mask, (u32)fbi->reg_base + gra_partdisp_ctrl_ver(grap.id));
+
+	return 0;
+}
+
+/* for partial display, only vertical lines need be updated
+ * when zoom size changed */
+void pxa688fb_partdisp_update(int id)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[id];
+	u32 base, mask, vertline_start, vertline_end,
+		screen_active, yres, yres_bak;
+	struct lcd_regs *regs;
+
+	regs = get_regs(fbi->id);
+	screen_active = readl(&regs->screen_active);
+	if (!fbi->scrn_act_bak)
+		fbi->scrn_act_bak = screen_active;
+	if (fbi->scrn_act_bak == screen_active)
+		/* no need to update partial display */
+		return;
+
+	base = (u32)fbi->reg_base;
+	mask = readl(base + gra_partdisp_ctrl_ver(id));
+
+	/* get original partial display vertical setting */
+	vertline_start = mask & 0xfff;
+	vertline_end = (mask & 0xfff0000) >> 16;
+
+	/* get original/new vertical lines */
+	yres_bak = (fbi->scrn_act_bak & 0x0fff0000) >> 16;
+	yres = (screen_active & 0x0fff0000) >> 16;
+
+	/* adjust partial display start/end vertical lines by
+	 * new / original ratio */
+	vertline_start = vertline_start * yres / yres_bak;
+	vertline_end = vertline_end * yres / yres_bak;
+
+	mask &= ~0xfff0fff;
+	mask |= vertline_start | (vertline_end << 16);
+	writel(mask, base + gra_partdisp_ctrl_ver(id));
+	fbi->scrn_act_bak = screen_active;
+}
+
+static int pxa688fb_map_layers(int src, int dst, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 map = (u32)fbi->reg_base + LCD_IO_OVERL_MAP_CTRL;
+	u32 val = readl(map), shift;
+#ifdef CONFIG_PXA688_VDMA
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	u32 vdma;
+#endif
+	/* map src path dma to dst */
+	switch (dst) {
+	case 0:
+		if (src == 2)
+			/* p2 -> pn */
+			shift = vid ? 6 : 7;
+		else if (src == 1) {
+			/* tv -> pn */
+			map = (u32)fbi->reg_base + LCD_TOP_CTRL;
+			val = readl(map);
+			shift = 22;
+			val &= ~(3 << shift);
+			if (en)
+				val |= 1 << shift;
+			goto top_ctrl;
+		} else
+			return -EINVAL;
+		break;
+	case 1:
+		if (src == 2)
+			/* p2 -> tv */
+			shift = vid ? 10 : 9;
+		else if (src == 0) {
+			/* pn -> tv */
+			map = (u32)fbi->reg_base + LCD_TOP_CTRL;
+			val = readl(map);
+			shift = 22;
+			val &= ~(3 << shift);
+			if (en)
+				val |= 2 << shift;
+			goto top_ctrl;
+		} else
+			return -EINVAL;
+		break;
+	case 2:
+		if (src == 1)
+			/* tv -> p2 */
+			shift = vid ? 3 : 4;
+		else if (src == 0)
+			/* pn -> p2 */
+			shift = vid ? 0 : 1;
+		else
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+	if (en)
+		val |= 1 << shift;
+	else
+		val &= ~(1 << shift);
+top_ctrl:
+	writel(val, map);
+	if (debug)
+		pr_info("%s %d: src %d dst %d vid %d shift %d map(%x): 0x%x\n",
+			__func__, en, src, dst, vid, shift, map & 0xfff, val);
+
+
+#ifdef CONFIG_PXA688_VDMA
+	lcd_vdma = request_vdma(dst, vid);
+	if (lcd_vdma && lcd_vdma->enable) {
+		vdma = readl((u32)fbi->reg_base + LCD_PN2_SQULN2_CTRL);
+		switch (src) {
+		case 2:
+			/* vdma0-pn/vdma1-tv is used for p2 */
+			vdma &= ~(3 << 30);
+			if (en)
+				vdma |= 1 << (dst ? 31 : 30);
+			break;
+		case 1:
+		case 0:
+			/* FIXME */
+		default:
+			pr_info("%s src %d dst %d not supported yet\n",
+				__func__, src, dst);
+		return -EINVAL;
+		}
+		writel(vdma, (u32)fbi->reg_base + LCD_PN2_SQULN2_CTRL);
+		if (debug)
+			pr_info("vdma 0x%x\n", vdma);
+	}
+#endif
+
+
+	return 0;
+}
+
+static int pxa688fb_vsmooth_config(int filter, int dst, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	int vsmooth = (u32)fbi->reg_base + LCD_AFA_ALL2ONE, shift, val, x;
+
+	switch (filter) {
+	case 0:
+		/* pn dma used as vertical filter channel */
+		shift = vid ? 16 : 18;
+		if (dst == 2) {
+			pr_err("%s (line %d) filter %d dst %d not supported\n",
+				__func__, __LINE__, filter, dst);
+			return -EINVAL;
+		} else
+			x = 3;
+		break;
+	case 1:
+		/* tv dma used as vertical filter channel */
+		shift = vid ? 16 : 18;
+		if (dst == 2) {
+			pr_err("%s (line %d) filter %d dst %d not supported\n",
+				__func__, __LINE__, filter, dst);
+			return -EINVAL;
+		} else
+			x = 2;
+		break;
+	case 2:
+		/* p2 dma used as vertical filter channel */
+		vsmooth = (u32)fbi->reg_base + LCD_PN2_LAYER_ALPHA_SEL1;
+		shift = vid ? 16 : 18;
+		x = dst ? 3 : 2;
+		break;
+	default:
+		pr_err("%s (line %d) filter %d dst %d not supported\n",
+			__func__, __LINE__, filter, dst);
+		return -EINVAL;
+	}
+	val = readl(vsmooth) & ~(3 << shift);
+	if (en)
+		val |= x << shift;
+	writel(val, vsmooth);
+	if (debug)
+		pr_info("%s filter %d en %d dst %d x %x shift %d"
+			" vsmooth(%x) 0x%x\n\n", __func__, filter,
+			en, dst, x, shift, vsmooth & 0xfff, val);
+	return 0;
+}
+
+static int pxa688_colorkey_get(int id, int vid)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, tmp = dma_ctrl_read(1, 1), en = 0;
+
+	if (id == 0)
+		en = vid ? ((tmp & (1 << 18)) >> 18) :
+			((tmp & (1 << 19)) >> 19);
+	else if (id == 1)
+		en = vid ? ((tmp & (1 << 20)) >> 20) :
+			((tmp & (1 << 21)) >> 21);
+	else {
+		tmp = __raw_readl(base + PN2_IOPAD_CONTROL);
+		en = vid ? ((tmp & (1 << 5)) >> 5) :
+			((tmp & (1 << 4)) >> 4);
+	}
+
+	return en;
+}
+
+static void pxa688_colorkey_set(int id, int vid, int en)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask;
+
+	if (id <= 1) {
+		mask = id ? (vid ? (en << 20) : (en << 21)) :
+			(vid ? (en << 18) : (en << 19));
+		dma_ctrl_set(1, 1, mask, mask);
+	} else {
+		mask = __raw_readl(base + PN2_IOPAD_CONTROL);
+		mask &= ~(vid ? (1 << 5) : (1 << 4));
+		mask |= vid ? (en << 5) : (en << 4);
+		__raw_writel(mask, base + PN2_IOPAD_CONTROL);
+	}
+}
+
+/* pxa688_clone_xxx(int src, int dst,..)
+ * These functions clone src path settings to dst path.
+ * e.g. if use PN2 path DMA to do TV path smoothing, so
+ * need to clone TV path settings to PN2.
+ */
+
+static int pxa688fb_clone_clk(int src, int dst)
+{
+	u32 mask = ~0;
+	/* video clk shift of register LCD_PN2_TCLK_DIV,
+	 * the shift is different according to MMP2/MMP3 spec,
+	 * default setting is specific for MMP2.
+	*/
+	u32 pn2_vid_shift = 30;
+	u32 pn2_gfx_shift = 2;
+
+	if (src == 1 || dst == 1)
+		/* TV path TCLK_DIV definitions different vs SCLK_DIV */
+		mask = 0xd000000f;
+	/* enable dst path clock */
+	if (dst == 2 && src <= 1) {
+		/* pn2 TCLK_DIV */
+		mask = src ? 2 : 1;
+#ifdef CONFIG_CPU_MMP3
+		pn2_vid_shift = 29;
+#endif
+		lcd_clk_set(dst, clk_tclk, (mask << pn2_vid_shift) | (mask << pn2_gfx_shift) | (mask),
+				(mask << pn2_vid_shift) | (mask << pn2_gfx_shift) | (mask));
+	} else
+		lcd_clk_set(dst, clk_sclk, lcd_clk_get(src, clk_sclk) & mask,
+			lcd_clk_get(src, clk_sclk) & mask);
+
+	return 0;
+}
+
+static void pxa688fb_clone_intf_ctrl(int src, int dst)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, reg = 0, mask = 0;
+
+	reg = readl(base + intf_ctrl(src));
+	switch (dst) {
+	case 0:
+		if (src == 1) {
+			/* tv -> pn */
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 15))
+				mask |= (1 << 9);
+		} else
+			/* pn2 -> pn */
+			mask = reg;
+		break;
+	case 1:
+		if (src == 0 || src == 2) {
+			/* pn -> tv or pn2 -> tv*/
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 9))
+				mask |= (1 << 15);
+		} else
+			mask = reg;
+		break;
+	case 2:
+		if (src == 1) {
+			/* tv -> pn2 */
+			mask = reg & 0xf00009ff;
+			if (reg & (1 << 15))
+				mask |= (1 << 9);
+		} else
+			/* pn -> pn2 */
+			mask = reg;
+		break;
+	default:
+		break;
+	}
+	writel(mask, base + intf_ctrl(dst));
+}
+
+static void pxa688fb_clone_vdma(int src, int dst, int vid)
+{
+#ifdef CONFIG_PXA688_VDMA
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask, vdma;
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+
+	mask = readl(base + LCD_PN2_SQULN2_CTRL);
+	vdma = readl(base + squln_ctrl(src));
+	lcd_vdma = request_vdma(src, vid);
+	if (lcd_vdma && lcd_vdma->enable) {
+		if (!lcd_vdma->vid) {
+			/* vdma for graphic layer */
+			mask &= ~(dst ? ((dst & 1) ? (1 << 25) :
+				(1 << 26)) : (1 << 24));
+		} else {
+			/* vdma for video layer */
+			mask |= dst ? ((dst & 1) ? (1 << 25) :
+				(1 << 26)) : (1 << 24);
+		}
+	}
+	writel(vdma, base + squln_ctrl(dst));
+	writel(mask, base + LCD_PN2_SQULN2_CTRL);
+#endif
+}
+
+static void pxa688fb_clone_partdisp_ctrl(int src, int dst)
+{
+	struct pxa168fb_info *fbi = gfx_info.fbi[src];
+	struct fb_info *info = fbi->fb_info;
+	struct fb_var_screeninfo *var = &info->var;
+
+	u32 base = (u32)fbi->reg_base, mask, region, bytespp,
+		horpix_end_src, horpix_end_dst, horpix_start,
+		threshold_src, threshold_dst;
+
+	mask = readl(base + gra_partdisp_ctrl_hor(src));
+	bytespp = var->bits_per_pixel >> 3;
+	horpix_end_src = (mask & 0xfff0000) >> 16;
+	horpix_start = mask & 0xfff;
+
+	/* THRESHOLD_x: the least bytes to operate for
+	 * horizontal partial display
+	 */
+	threshold_src = (src == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+	threshold_dst = (dst == 1 ? THRESHOLD_TV : THRESHOLD_PN);
+	if (horpix_end_src > horpix_start) {
+		region = horpix_end_src - horpix_start;
+
+		/* BURST_LEN: AXI burst size, platform dependent */
+		region = (region - threshold_src / bytespp) /
+			(BURST_LEN / bytespp);
+		horpix_end_dst = horpix_start + threshold_dst / bytespp +
+			region * (BURST_LEN / bytespp);
+		mask &= ~0xfff0000;
+		mask |= horpix_end_dst << 16;
+	}
+	writel(mask, base + gra_partdisp_ctrl_hor(dst));
+	writel(readl(base + gra_partdisp_ctrl_ver(src)),
+		base + gra_partdisp_ctrl_ver(dst));
+}
+
+static void pxa688fb_clone_base(int src, int dst, int vid)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+	struct pxa168fb_info *fbi = gfx_info.fbi[0];
+	u32 base = (u32)fbi->reg_base, mask, cokey_en;
+
+	/* screen info */
+	writel(readl(&regs_src->screen_size), &regs_dst->screen_size);
+	writel(readl(&regs_src->screen_active), &regs_dst->screen_active);
+	writel(readl(&regs_src->screen_h_porch), &regs_dst->screen_h_porch);
+	writel(readl(&regs_src->screen_v_porch), &regs_dst->screen_v_porch);
+	writel(readl(&regs_src->vsync_ctrl), &regs_dst->vsync_ctrl);
+
+	/* dma control1 */
+	mask = ~0;
+	if ((src == 1) || (dst ==  1))
+		mask &= ~((0x1f << 18) | 0xff);
+	dma_ctrl_set(dst, 1, mask, dma_ctrl_read(src, 1) & mask);
+
+	/* dma control0 */
+	mask = ~(vid ? dma0_gfx_masks : dma0_vid_masks);
+	if ((src == 1) || (dst ==  1))
+		mask &= ~(1 << 27);
+	dma_ctrl_set(dst, 0, mask, dma_ctrl_read(src, 0) & mask);
+
+	/* DMA burst length */
+	if (dst == 2)
+		writel(readl(base + PN2_IOPAD_CONTROL) |
+			(3 << 10) | (3 << 8), base + PN2_IOPAD_CONTROL);
+
+	/* DMA color key */
+	cokey_en = pxa688_colorkey_get(src, vid);
+	pxa688_colorkey_set(dst, vid, cokey_en);
+
+	/* intf ctrl */
+	pxa688fb_clone_intf_ctrl(src, dst);
+}
+
+/* clone src path graphics layer settings to dst path */
+static int pxa688fb_clone_gfx(int src, int dst, int en)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+	struct mvdisp_partdisp grap;
+
+	/* enable dst path clock */
+	pxa688fb_clone_clk(src, dst);
+
+	/* if disable vsmooth, disable dst path dma directly */
+	if (!en) {
+		dma_ctrl_set(dst, 0, CFG_GRA_ENA_MASK, 0);
+		if (debug)
+			pr_info("%s disabled: dma_ctrl0 0x%x\n",
+				__func__, dma_ctrl_read(dst, 0));
+		grap.id = dst;
+		grap.horpix_start = grap.horpix_end = 0;
+		grap.vertline_start = grap.vertline_end = 0;
+		grap.color = 0;
+		/* disable dst partial display */
+		pxa688fb_partdisp_set(grap);
+		return 0;
+	}
+
+	/* configure frame address */
+	writel(readl(&regs_src->g_0), &regs_dst->g_0);
+	writel(readl(&regs_src->g_1), &regs_dst->g_1);
+
+	/* partial display */
+	pxa688fb_clone_partdisp_ctrl(src, dst);
+
+	/* configure dst regs */
+	writel(readl(&regs_src->g_pitch), &regs_dst->g_pitch);
+	writel(readl(&regs_src->g_start), &regs_dst->g_start);
+	writel(readl(&regs_src->g_size), &regs_dst->g_size);
+	writel(readl(&regs_src->g_size_z), &regs_dst->g_size_z);
+	/* configure dma control0/1, screen info, color key, intf ctrl.. */
+	pxa688fb_clone_base(src, dst, 0);
+	return 0;
+}
+
+/* clone src path video layer settings to dst path */
+static int pxa688fb_clone_ovly(int src, int dst, int en)
+{
+	struct lcd_regs *regs_src = get_regs(src);
+	struct lcd_regs *regs_dst = get_regs(dst);
+
+	/* enable dst path clock */
+	pxa688fb_clone_clk(src, dst);
+
+	/* if disable vsmooth, disable dst path dma directly */
+	if (!en) {
+		dma_ctrl_set(dst, 0, CFG_DMA_ENA_MASK, 0);
+		if (debug)
+			pr_info("%s disable %d: dma_ctrl0 0x%x\n",
+				__func__, dst, dma_ctrl_read(dst, 0));
+		return 0;
+	}
+
+
+	/* configure dst regs */
+	writel(readl(&regs_src->v_y0), &regs_dst->v_y0);
+	writel(readl(&regs_src->v_u0), &regs_dst->v_u0);
+	writel(readl(&regs_src->v_v0), &regs_dst->v_v0);
+	writel(readl(&regs_src->v_c0), &regs_dst->v_c0);
+	writel(readl(&regs_src->v_y1), &regs_dst->v_y1);
+	writel(readl(&regs_src->v_u1), &regs_dst->v_u1);
+	writel(readl(&regs_src->v_v1), &regs_dst->v_v1);
+	writel(readl(&regs_src->v_c1), &regs_dst->v_c1);
+	writel(readl(&regs_src->v_pitch_yc), &regs_dst->v_pitch_yc);
+	writel(readl(&regs_src->v_pitch_uv), &regs_dst->v_pitch_uv);
+	writel(readl(&regs_src->v_start), &regs_dst->v_start);
+	writel(readl(&regs_src->v_size), &regs_dst->v_size);
+	writel(readl(&regs_src->v_size_z), &regs_dst->v_size_z);
+	/* configure dma control0/1, screen info, color key, intf ctrl.. */
+	pxa688fb_clone_base(src, dst, 1);
+	return 0;
+}
+
+static int pxa168fb_vsmooth_check(int id, int src, int dst, int vid, int en)
+{
+	struct lcd_regs *regs;
+	int x, x_z;
+
+	if (id != fb_vsmooth) {
+		if (debug)
+			pr_info("%s: fbi %d != fb_vsmooth %d\n",
+				__func__, id, fb_vsmooth);
+		return -EINVAL;
+	}
+
+	if (src == dst || src < 0 || src > 2 || dst < 0 || dst > 1) {
+		if (debug)
+			pr_info("%s input err: src %d dst %d vid %d en %d\n",
+				__func__, src, dst, vid, en);
+		return -EINVAL;
+	}
+
+	regs = get_regs(id);
+	x = (readl(vid ? &regs->v_size : &regs->g_size) >> 16) & 0xfff;
+	x_z = (readl(vid ? &regs->v_size_z : &regs->g_size_z) >> 16) & 0xfff;
+	if (debug)
+		pr_info("%s layer %s: x 0x%x x_z 0x%x\n",
+			__func__, vid ? "vid " : "gfx", x, x_z);
+	return (x_z > x) ? 0 : 1;
+}
+
+/* pxa688fb_vsmooth_set
+ * vid: video layer or graphics layer
+ * en: enable vsmooth mode or not
+ */
+int pxa688fb_vsmooth_set(int id, int vid, int en)
+{
+	int filter = fb_filter, dst = fb_vsmooth, ret = 0;
+
+	ret = pxa168fb_vsmooth_check(id, filter, dst, vid, en);
+	if (ret) {
+		if (ret == 1)
+			/* not scaling, disable mapping and filter path dma */
+			en = 0;
+		else
+			return -EINVAL;
+	}
+
+	if (vid)
+		ret = pxa688fb_clone_ovly(dst, filter, en);
+	else
+		ret = pxa688fb_clone_gfx(dst, filter, en);
+	if (ret) {
+		if (debug)
+			pr_info("%s clone %s err, filter %d dst %d\n",
+				__func__, vid ? "ovly" : "gfx", filter, dst);
+		return -EIO;
+	}
+
+	/* vdma clone */
+	pxa688fb_clone_vdma(dst, filter, vid);
+
+	pxa688fb_map_layers(filter, dst, vid, en);
+	pxa688fb_vsmooth_config(filter, dst, vid, en);
+	return 0;
+}
+
+/* gamma correction related functions */
+#define mmpdisp_regbase		((u32)gfx_info.fbi[0]->reg_base)
+#define sram_ctrl		(mmpdisp_regbase + LCD_SPU_SRAM_CTRL)
+#define sram_wrdat		(mmpdisp_regbase + LCD_SPU_SRAM_WRDAT)
+#define sram_para1		(mmpdisp_regbase + LCD_SPU_SRAM_PARA1)
+#define gamma_rddat(path)	(mmpdisp_regbase + (((path) & 1) ? \
+				LCD_TV_GAMMA_RDDAT : LCD_SPU_GAMMA_RDDAT))
+#define gamma_id_yr(path)	((path) ? (((path) & 1) ? 0x4 : 0x9) : 0x0)
+#define gamma_id_ug(path)	((path) ? (((path) & 1) ? 0x5 : 0xa) : 0x1)
+#define gamma_id_vb(path)	((path) ? (((path) & 1) ? 0x6 : 0xb) : 0x2)
+static u32 gamma_read(u32 addr, int gamma_id, int path)
+{
+	int count = 10000, val, pn2 = (path == 2) ? (1 << 16) : 0;
+
+	val = pn2 | (0x0 << 12) | (gamma_id << 8) | addr;
+	__raw_writel(val, sram_ctrl);
+	while (__raw_readl(sram_ctrl) & (1<<31) && count--);
+
+	if (count > 0)
+		val = __raw_readl(gamma_rddat(path)) & CFG_GAMMA_RDDAT_MASK;
+	else
+		val = -1;
+
+	return val;
+}
+
+static void gamma_write(u32 addr, u32 gamma_id, u32 val)
+{
+	__raw_writel(val, sram_wrdat);
+	val = (0x8 << 12) | (gamma_id << 8 ) | addr;
+	__raw_writel(val, sram_ctrl);
+}
+
+void gamma_dump(int path, int lines)
+{
+	u32 i = 0, val;
+
+	if (!(dma_ctrl_read(path, 0) & CFG_GAMMA_ENA_MASK)) {
+		pr_info("gamma correction not enabled yet\n");
+	}
+
+	/* enable gamma correction table update */
+	val = __raw_readl(sram_para1) | CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	for (; i < lines; i++)
+		pr_info("%3d: yr %3d, ug %3d, vb %3d\n", i,
+			gamma_read(i, gamma_id_yr(path), path),
+			gamma_read(i, gamma_id_ug(path), path),
+			gamma_read(i, gamma_id_vb(path), path));
+
+	val = __raw_readl(sram_para1) & ~CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+}
+
+int gamma_set(int path, int flag, char *gamma_table)
+{
+	u32 i = 0, val;
+
+	/* disable gamma correction */
+	dma_ctrl_set(path, 0, CFG_GAMMA_ENA_MASK, CFG_GAMMA_ENA(0));
+
+	if (!(flag & GAMMA_ENABLE))
+		goto dump;
+
+	/* check as only 2 gamma correction table avialable */
+	if (((path == 2) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(0, 0) & dma_ctrl_read(1, 0))) ||
+	    ((path == 1) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(2, 0) & dma_ctrl_read(0, 0))) ||
+	    ((path == 0) && (CFG_GAMMA_ENA(1) &
+			dma_ctrl_read(1, 0) & dma_ctrl_read(2, 0)))) {
+		pr_err("path %d gamma correction not avialable, pls "
+			"disable other path's and try again\n", path);
+		return -EINVAL;
+	}
+
+	/* enable gamma correction table update */
+	val = __raw_readl(sram_para1) | CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	/* write gamma corrrection table */
+	for (; i < GAMMA_TABLE_LEN; i++) {
+		gamma_write(i, gamma_id_yr(path), gamma_table[i]);
+		gamma_write(i, gamma_id_ug(path), gamma_table[i]);
+		gamma_write(i, gamma_id_vb(path), gamma_table[i]);
+	}
+
+	val = __raw_readl(sram_para1) & ~CFG_CSB_256x8_MASK;
+	__raw_writel(val, sram_para1);
+
+	/* enable gamma correction table */
+	dma_ctrl_set(path, 0, CFG_GAMMA_ENA_MASK, CFG_GAMMA_ENA(1));
+
+dump:
+	if (flag & GAMMA_DUMP)
+		gamma_dump(path, GAMMA_TABLE_LEN);
+
+	return 0;
+}
+
+static void dither_dump(struct pxa168fb_info *fbi)
+{
+	u32 base = (u32)fbi->reg_base;
+	u32 mask = readl(base + LCD_DITHER_CTRL);
+	int enabled, mode, table;
+
+	enabled = mask & (fbi->id ? DITHER_EN2 : DITHER_EN1);
+	if (!enabled)
+		pr_info("fbi%d dither was disabled\n", fbi->id);
+	else {
+		mode = mask & (fbi->id ? DITHER_MODE2(7) : DITHER_MODE1(7));
+		mode = mode >> (fbi->id ? DITHER_MODE2_SHIFT :
+			DITHER_MODE1_SHIFT);
+		table = mask & (fbi->id ? DITHER_4X8_EN2 : DITHER_4X8_EN1);
+		table = table >> (fbi->id ? DITHER_4X8_EN2_SHIFT :
+			DITHER_4X8_EN1_SHIFT);
+
+		pr_info("fbi%d dither mode:%d, table:%d\n",
+			fbi->id, mode, table);
+		mask &= ~DITHER_TBL_INDEX_SEL(3);
+		if (!table) {
+			writel(mask, base + LCD_DITHER_CTRL);
+			pr_info("4x4table index0:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(1),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x4table index1:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+		} else {
+			writel(mask, base + LCD_DITHER_CTRL);
+			pr_info("4x8table index0:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(1),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index1:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(2),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index2:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+			writel(mask | DITHER_TBL_INDEX_SEL(3),
+				base + LCD_DITHER_CTRL);
+			pr_info("4x8table index3:%x",
+				readl(base + LCD_DITHER_TBL_DATA));
+		}
+	}
+}
+
+void dither_set(struct pxa168fb_info *fbi, int table, int mode, int enable)
+{
+	u32 base = (u32)fbi->reg_base;
+	u32 mask = readl(base + LCD_DITHER_CTRL);
+
+	if (fbi->id && fbi->id != 2) {
+		pr_err("%s fbi:%d dither not support\n", __func__, fbi->id);
+		return;
+	}
+
+	if (!enable) {
+		mask &= ~(fbi->id ? DITHER_EN2 : DITHER_EN1);
+		writel(mask, base + LCD_DITHER_CTRL);
+		goto dump;
+	}
+
+	if (!fbi->id) {
+		mask = table ? DITHER_4X8_EN1 : 0;
+		mask |= DITHER_MODE1(mode);
+		mask |= DITHER_EN1;
+	} else {
+		mask = table ? DITHER_4X8_EN2 : 0;
+		mask |= DITHER_MODE2(mode);
+		mask |= DITHER_EN2;
+	}
+
+	if (!table) {
+		/* 4X4 table */
+		writel(mask, base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X4_INDEX0, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(1), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X4_INDEX1, base + LCD_DITHER_TBL_DATA);
+	} else {
+		/* 4X8 table */
+		writel(mask, base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX0, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(1), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX1, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(2), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX2, base + LCD_DITHER_TBL_DATA);
+		writel(mask | DITHER_TBL_INDEX_SEL(3), base + LCD_DITHER_CTRL);
+		writel(DITHER_TB_4X8_INDEX3, base + LCD_DITHER_TBL_DATA);
+	}
+
+dump:
+	if (debug)
+		dither_dump(fbi);
+}
+
+static ssize_t misc_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump partial display and vertical"
+			" smooth settings\n");
+	mvdisp_dump(f, "\tcat misc\n");
+	mvdisp_dump(f, " - select path(pn/tv/pn2:0/1/2]) to be"
+			" vertical smoothed\n");
+	mvdisp_dump(f, "\techo s[path:0/1/2] > misc\n");
+	mvdisp_dump(f, " - select path(pn/tv/pn2:0/1/2]) to work as filter"
+			" when vertical smooth enabled\n");
+	mvdisp_dump(f, "\techo f[path:0/1/2] > misc\n");
+	mvdisp_dump(f, " - graphics layer vertical vsmooth"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo g[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - video layer vertical vsmooth"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo v[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - vertical smooth kernel debug"
+			" enable[1]/disable[0]\n");
+	mvdisp_dump(f, "\techo d[en/dis:1/0] > misc\n");
+	mvdisp_dump(f, " - set graphics layer partial display area from pixel"
+			" [h_start][v_start]\n   to pixel [h_end][v_end]"
+			"  with RGB565 format [color]\n");
+	mvdisp_dump(f, "\techo p [h_start] [v_start] [h_end] [v_end]"
+			" [color] > misc\n");
+	mvdisp_dump(f, " - dither setting\n");
+	mvdisp_dump(f, "\techo i [4x4/4x8 table: 0/1]"
+		" [RBG444/RGB565/RGB666 mode: 0/1/2] [en/dis:1/0] > misc\n");
+
+	return s;
+}
+
+ssize_t misc_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct mvdisp_partdisp grap;
+	u32 mask;
+	int s = 0;
+
+	grap.id = fbi->id;
+again:
+	mask = readl((u32)fbi->reg_base + gra_partdisp_ctrl_hor(grap.id));
+	/* get horizontal start/end pixel number */
+	grap.horpix_start = mask & 0xfff;
+	grap.horpix_end = (mask & 0xfff0000) >> 16;
+	/* get color bit 0~7 */
+	grap.color = (mask & 0xf000) >> 12;
+	grap.color |= ((mask & 0xf0000000) >> 28) << 4;
+
+	mask = readl((u32)fbi->reg_base + gra_partdisp_ctrl_ver(grap.id));
+	/* get vertical start/end line */
+	grap.vertline_start = mask & 0xfff;
+	grap.vertline_end = (mask & 0xfff0000) >> 16;
+	/* get color bit 8~15 */
+	grap.color |= ((mask & 0xf000) >> 12) << 8;
+	grap.color |= ((mask & 0xf0000000) >> 28) << 12;
+
+	s += sprintf(buf + s, "partial display:\n  path %d, h_start %d,"
+		"v_start %d, h_end %d, v_end %d, color %d\n\n",
+		grap.id, grap.horpix_start, grap.vertline_start,
+		grap.horpix_end, grap.vertline_end, grap.color);
+
+	if (gfx_vsmooth && (fb_filter != fb_vsmooth)
+		&& (grap.id == fb_vsmooth)) {
+		grap.id = fb_filter;
+		goto again;
+	}
+
+	s += sprintf(buf + s, "vertical smooth:\n  filter(%d)->vsmooth(%d),"
+		" gfx %d, vid %d, debug %d\n\n", fb_filter, fb_vsmooth,
+		gfx_vsmooth, vid_vsmooth, debug);
+
+	s += misc_help(buf + s);
+	return s;
+}
+ssize_t misc_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct mvdisp_partdisp grap;
+	char vol[30];
+	int tmp, table, mode, enable;
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return size;
+	}
+	if ('s' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != fb_vsmooth) {
+			/* disable vsmooth for original path */
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, 0);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, 0);
+			/* enable vsmooth for new path */
+			fb_vsmooth = tmp;
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("fb_vsmooth: %d\n", fb_vsmooth);
+		}
+		return size;
+	} else if ('f' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != fb_filter) {
+			/* disable vsmooth for original path */
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, 0);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, 0);
+			/* enable vsmooth for new path */
+			fb_filter = tmp;
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("fb_filter: %d\n", fb_filter);
+		}
+		return size;
+	} else if ('g' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = gfx_vsmooth;
+		gfx_vsmooth = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != gfx_vsmooth) {
+			pxa688fb_vsmooth_set(fb_vsmooth, 0, gfx_vsmooth);
+			pr_info("gfx_vsmooth: %d -> %d\n", tmp, gfx_vsmooth);
+		}
+		return size;
+	} else if ('v' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		tmp = vid_vsmooth;
+		vid_vsmooth = (int) simple_strtoul(vol, NULL, 10);
+		if (tmp != vid_vsmooth) {
+			pxa688fb_vsmooth_set(fb_vsmooth, 1, vid_vsmooth);
+			pr_info("vid_vsmooth: %d -> %d\n", tmp, vid_vsmooth);
+		}
+		return size;
+	} else if ('d' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		debug = (int) simple_strtoul(vol, NULL, 10);
+		pr_info("debug: %d\n", debug);
+		return size;
+	} else if ('p' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u %u %u %hu", &grap.horpix_start,
+			&grap.vertline_start, &grap.horpix_end,
+			&grap.vertline_end, &grap.color) != 5) {
+			pr_err("partial display cmd should be like: "
+				"p horpix_start vertline_start "
+				"horpix_end verline_end color\n");
+			return size;
+		}
+		grap.id = fbi->id;
+		pxa688fb_partdisp_set(grap);
+		if ((grap.id == fb_vsmooth) && (gfx_vsmooth)) {
+			if (dma_ctrl_read(fb_filter, 0) & CFG_GRA_ENA_MASK) {
+				grap.id = fb_filter;
+				pxa688fb_partdisp_set(grap);
+			}
+		}
+		pr_info("lcd_part_disp\n");
+	} else if ('i' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u %u", &table, &mode, &enable) != 3) {
+			pr_err("dithering cmd should be:"
+				"i table mode enable\n");
+			return size;
+		}
+		dither_set(fbi, table, mode, enable);
+		pr_info("dither setting\n");
+	} else
+		pr_err("%s unknown command %s\n", __func__, buf);
+
+	return size;
+}
+DEVICE_ATTR(misc, S_IRUGO | S_IWUSR, misc_show, misc_store);
diff --git a/drivers/video/pxa688_phy.c b/drivers/video/pxa688_phy.c
new file mode 100644
index 0000000..07e54d0
--- /dev/null
+++ b/drivers/video/pxa688_phy.c
@@ -0,0 +1,1003 @@
+/*
+ * linux/drivers/video/pxa168fb.c -- Marvell PXA168 LCD Controller
+ *
+ *  Copyright (C) 2008 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2009-02-16  adapted from original version for PXA168
+ *		Kevin Liu <kliu5@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+
+#ifdef CONFIG_PXA688_PHY
+
+#include "pxa168fb.h"
+#include <mach/irqs.h>
+#include <mach/pxa168fb.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include <asm/mach-types.h>
+#include <mach/regs-apmu.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/regs-mpmu.h>
+#include <asm/mach-types.h>
+
+#include "pxa168fb_common.h"
+
+/* dsi phy timing */
+static struct dsi_phy phy = {
+	.hs_prep_constant	= 40,    /* Unit: ns. */
+	.hs_prep_ui		= 4,
+	.hs_zero_constant	= 145,
+	.hs_zero_ui		= 10,
+	.hs_trail_constant	= 0,
+	.hs_trail_ui		= 64,
+	.hs_exit_constant	= 100,
+	.hs_exit_ui		= 0,
+	.ck_zero_constant	= 300,
+	.ck_zero_ui		= 0,
+	.ck_trail_constant	= 60,
+	.ck_trail_ui		= 0,
+	.req_ready		= 0x3c,
+	.wakeup_constant        = 1000000,
+	.wakeup_ui      = 0,
+	.lpx_constant       = 50,
+	.lpx_ui     = 0,
+};
+
+#define dsi_ex_pixel_cnt		0
+#define dsi_hex_en			0
+/* (Unit: Mhz) */
+#define dsi_hsclk			(clk_get_rate(fbi->clk)/1000000)
+#define dsi_lpclk			3
+
+#define to_dsi_bcnt(timing, bpp)	(((timing) * (bpp)) >> 3)
+
+static unsigned int dsi_lane[5] = {0, 0x1, 0x3, 0x7, 0xf};
+
+static int is_odd_1s(u32 data)
+{
+	int num = 0;
+
+	while (data) {
+		if (data % 2)
+			num++;
+		data = data >> 1;
+	}
+	if (num % 2)
+		return 1;
+	return 0;
+}
+
+static unsigned char caluate_ecc(u32 data)
+{
+	int ecc_bit_depend[6], i;
+	u32 tmp;
+	unsigned char ret = 0;
+
+	ecc_bit_depend[0] = 0xf12cb7;
+	ecc_bit_depend[1] = 0xf2555b;
+	ecc_bit_depend[2] = 0x749a6d;
+	ecc_bit_depend[3] = 0xb8e38e;
+	ecc_bit_depend[4] = 0xdf03f0;
+	ecc_bit_depend[5] = 0xeffc00;
+
+	for (i = 0; i < 6; i++) {
+		tmp = data & ecc_bit_depend[i];
+		ret |= is_odd_1s(tmp) ? (1 << i) : 0;
+	}
+	return ret;
+}
+
+/* FIXME: only for short packet */
+void dsi_send_cmd(struct pxa168fb_info *fbi,
+	enum dsi_packet_di data_type, enum dsi_packet_dcs_id dcs, u8 parameter)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 send_data, waddr, tmp, ecc, count;
+
+	send_data = data_type & 0xff;
+	send_data |= (dcs & 0xff) << 8;
+	send_data |= (parameter & 0xff) << 16;
+
+	ecc = caluate_ecc(send_data);
+	send_data |= (ecc & 0xff) << 24;
+
+	writel(send_data, &dsi->dat0);
+
+	waddr = 0xc0000000;
+	writel(waddr, &dsi->cmd3);
+	count = 1000;
+	while (readl(&dsi->cmd3) & 0x80000000 && count)
+		count--;
+	if (count <= 0)
+		pr_err("%s error!\n", __func__);
+
+	tmp = 0xC8000000 | 4;
+	writel(tmp, &dsi->cmd0);
+
+	pr_debug("send data:%x, cmd3:%x, cmd0:%x\n",
+		send_data, waddr, tmp);
+	/* wait for completion */
+	count = 1000;
+	while (readl(&dsi->cmd0) & 0x80000000 && count)
+		count--;
+	if (count <= 0)
+		pr_err("%s error!\n", __func__);
+}
+
+void pxa168fb_dsi_send(struct pxa168fb_info *fbi, void *value)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u8 *dsi_cmd_tmp = (u8 *)value;
+	int count = (int)(*dsi_cmd_tmp);
+	u8 *dsi_cmd = (u8 *)&dsi_cmd_tmp[1];
+	unsigned int firstTimeFlag = 1, firstPacket = 0;
+	volatile int loop = 0, tmp = 0, bc = 0, dsiAddr = 0, wAddr = 0;
+
+	pr_debug("count is %d\r\n", count);
+
+	/* write all packet bytes to packet data buffer */
+	for (loop = 0; loop < count; loop++) {
+		tmp |= ((int)dsi_cmd[loop]) << (bc * 8);
+		bc++;
+
+		pr_debug("bc is %d\r\n", bc);
+		if (bc == 4) {
+			/* XM: save 1st packet */
+			if (firstTimeFlag) {
+				firstTimeFlag = 0;
+				firstPacket = tmp;
+			}
+
+			writel(tmp, &dsi->dat0);
+			wAddr = 0xC0000000 | (dsiAddr << 16);
+			writel(wAddr, &dsi->cmd3);
+
+			/* while (readl(&dsi->cmd3) & 0x80000000)
+				msleep(1); */
+			pr_debug("total count is %d, wAddr is 0x%08x,"
+				" data is 0x%08x\r\n", count, wAddr, tmp);
+			tmp = 0; bc = 0; dsiAddr += 4;
+		}
+	}
+
+	/* handle last none 4Byte align data */
+	if (bc) {
+		writel(tmp, &dsi->dat0);
+		wAddr = 0xC0000000 | (dsiAddr << 16);
+		writel(wAddr, &dsi->cmd3);
+
+		/* while (readl(&dsi->cmd3) & 0x80000000)
+			msleep(1); */
+		pr_debug("last one total count is %d, wAddr is 0x%08x,"
+			" data is 0x%08x\r\n", count, wAddr, tmp);
+		tmp = 0;
+	}
+
+	/* send out the packet */
+	tmp = 0xC8000000 | count; writel(tmp, &dsi->cmd0);
+	pr_debug("write count is 0x%08x\r\n", tmp);
+
+	/* wait for completion */
+	while (readl(&dsi->cmd0) & 0x80000000)
+		msleep(1);
+}
+#if 0 /* original version */
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int loop = 0, tmp = 0;
+	u8 *dsi_cmd = (u8 *)value;
+	int count = (int)(*dsi_cmd);
+	if (count != 0x4) {
+		/* set up packet header for long packet */
+		*(dsi_cmd + 1) = 0x29;
+		*(dsi_cmd + 2) = (u8)(count - 6);
+		*(dsi_cmd + 3) = 0;
+	}
+	/* write all packet bytes to packet data buffer */
+	for (loop = 0; loop < count; loop++) {
+		tmp |= ((int)*(dsi_cmd + loop + 1)) << ((loop % 4) * 8);
+		if (!((loop + 1) % 4)) {
+			writel(tmp, &dsi->dat0);
+			writel(0xc0000000 | ((loop - 3) << 16), &dsi->cmd3);
+			while (readl(&dsi->cmd3) & 0x80000000)
+				msleep(1);
+			tmp = 0;
+		}
+	}
+	if (loop % 4) {
+		writel(tmp, &dsi->dat0);
+		writel(0xc0000000 | (4 * (loop / 4) << 16), &dsi->cmd3);
+		while (readl(&dsi->cmd3) & 0x80000000)
+			msleep(1);
+		tmp = 0;
+	}
+	/* send out the packet */
+	if (count == 0x4)
+		tmp = 0xc0000000 | count;
+	else
+		tmp = 0x80000000 | (count - 6);
+	writel(tmp, &dsi->cmd0);
+	while (readl(&dsi->cmd0) & 0x80000000)
+		msleep(1);
+}
+#endif
+
+void dsi_cclk_set(struct pxa168fb_info *fbi, int en)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+
+	if (en)
+		writel(0x1, &dsi->phy_ctrl1);
+	else
+		writel(0x0, &dsi->phy_ctrl1);
+}
+
+void dsi_lanes_enable(struct pxa168fb_info *fbi, int en)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 reg = readl(&dsi->phy_ctrl2) & ~(0xf << 4);
+
+	reg &= ~(0xf << 4);
+	if (en)
+		reg |= (dsi_lane[di->lanes] << 4);
+
+	pr_debug("%s %d: phy_ctrl2 0x%x\n", __func__, en, reg);
+	writel(reg, &dsi->phy_ctrl2);
+}
+
+void dsi_set_dphy(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int ui, lpx_clk, lpx_time, ta_get, ta_go, wakeup, reg;
+	int hs_prep, hs_zero, hs_trail, hs_exit, ck_zero, ck_trail, ck_exit;
+
+	ui = 1000/dsi_hsclk + 1;
+	pr_debug("ui:%d\n", ui);
+
+	lpx_clk = (phy.lpx_constant + phy.lpx_ui * ui) / DSI_ESC_CLK_T;
+	lpx_time = (lpx_clk + 1) * DSI_ESC_CLK_T;
+	pr_debug("lpx_clk:%d, condition (TIME_LPX:%d > 50)\n",
+		lpx_clk, lpx_time);
+
+	/* Below is for NT35451 */
+	ta_get = lpx_time * 5 / DSI_ESC_CLK_T - 1;
+	ta_go = lpx_time * 4 / DSI_ESC_CLK_T - 1;
+	pr_debug("ta_get:%d, condition (TIME_TA_GET:%d == 5*TIME_LPX:%d)\n",
+		ta_get, (ta_get + 1) * DSI_ESC_CLK_T, lpx_time * 5);
+	pr_debug("ta_go:%d, condition (TIME_TA_GO:%d == 4*TIME_LPX:%d)\n",
+		ta_go, (ta_go + 1) * DSI_ESC_CLK_T, lpx_time * 4);
+
+	wakeup = phy.wakeup_constant;
+	wakeup = wakeup / DSI_ESC_CLK_T + 1;
+	pr_debug("wakeup:%d, condition (WAKEUP:%d > MIN:%d)\n",
+		wakeup, (wakeup + 1) * DSI_ESC_CLK_T, 1000000);
+
+	hs_prep = phy.hs_prep_constant + phy.hs_prep_ui * ui;
+	hs_prep = hs_prep / DSI_ESC_CLK_T + 1;
+	pr_debug("hs_prep:%d, condition (HS_PREP_MAX:%d > HS_PREP:%d "
+		"> HS_PREP_MIN:%d)\n", hs_prep, 85 + 6 * ui,
+		(hs_prep + 1) * DSI_ESC_CLK_T, 40 + 4 * ui);
+
+	/* Our hardware added 3-byte clk automatically.
+	 * 3-byte 3 * 8 * ui.
+	 */
+	hs_zero = phy.hs_zero_constant + phy.hs_zero_ui * ui -
+		(hs_prep + 1) * DSI_ESC_CLK_T;
+	hs_zero = (hs_zero - (3 * ui << 3)) / DSI_ESC_CLK_T + 4;
+	if (hs_zero < 0)
+		hs_zero = 0;
+	pr_debug("hs_zero:%d, condition (HS_ZERO + HS_PREP:%d > SUM_MIN:%d)\n",
+		hs_zero, (hs_zero - 2) * DSI_ESC_CLK_T + 24 * ui +
+		(hs_prep + 1) * DSI_ESC_CLK_T, 145 + 10 * ui);
+
+	hs_trail = phy.hs_trail_constant + phy.hs_trail_ui * ui;
+	hs_trail = hs_trail / DSI_ESC_CLK_T + 1;
+	pr_debug("hs_trail:%d, condition (HS_TRAIL:%d > MIN1:%d / MIN2:%d "
+		"/ MIN3:%d)\n", hs_trail, (hs_trail + 1) * DSI_ESC_CLK_T,
+		8 * ui, 60 + 4 * ui, 64 * ui);
+
+	hs_exit = phy.hs_exit_constant + phy.hs_exit_ui * ui;
+	hs_exit = hs_exit / DSI_ESC_CLK_T + 1;
+	pr_debug("hs_exit:%d, condition (HS_EXIT:%d > MIN:%d)\n",
+		hs_exit, (hs_exit + 1) * DSI_ESC_CLK_T, 100);
+
+	ck_zero = phy.ck_zero_constant + phy.ck_zero_ui * ui -
+		(hs_prep + 1) * DSI_ESC_CLK_T;
+	ck_zero = ck_zero / DSI_ESC_CLK_T + 1;
+	pr_debug("ck_zero:%d, condition (CK_ZERO + CK_PREP:%d > SUM_MIN:%d)\n",
+		ck_zero, (ck_zero + 1) * DSI_ESC_CLK_T +
+		(hs_prep + 1) * DSI_ESC_CLK_T, 300);
+
+	ck_trail = phy.ck_trail_constant + phy.ck_trail_ui * ui;
+	ck_trail = ck_trail / DSI_ESC_CLK_T + 1;
+	pr_debug("ck_trail:%d, condition (CK_TRIAL:%d > MIN:%d)\n",
+		ck_trail, (ck_trail + 1) * DSI_ESC_CLK_T, 60);
+
+	ck_exit = hs_exit;
+	pr_debug("ck_exit:%d\n", ck_exit);
+
+	/* bandgap ref enable */
+	reg = readl(&dsi->phy_rcomp0);
+	reg |= (1 << 9);
+	writel(reg, &dsi->phy_rcomp0);
+
+	/* timing_0 */
+	reg = (hs_exit << DSI_PHY_TIME_0_CFG_CSR_TIME_HS_EXIT_SHIFT)
+		| (hs_trail << DSI_PHY_TIME_0_CFG_CSR_TIME_HS_TRAIL_SHIFT)
+		| (hs_zero << DSI_PHY_TIME_0_CDG_CSR_TIME_HS_ZERO_SHIFT)
+		| (hs_prep);
+	writel(reg, &dsi->phy_timing0);
+
+	reg = (ta_get << DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GET_SHIFT)
+		| (ta_go << DSI_PHY_TIME_1_CFG_CSR_TIME_TA_GO_SHIFT)
+		| wakeup;
+	writel(reg, &dsi->phy_timing1);
+
+	reg = (ck_exit << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_EXIT_SHIFT)
+		| (ck_trail << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_TRAIL_SHIFT)
+		| (ck_zero << DSI_PHY_TIME_2_CFG_CSR_TIME_CK_ZERO_SHIFT)
+		| lpx_clk;
+	writel(reg, &dsi->phy_timing2);
+
+
+	reg = (lpx_clk << DSI_PHY_TIME_3_CFG_CSR_TIME_LPX_SHIFT) | \
+	      phy.req_ready;
+	writel(reg, &dsi->phy_timing3);
+
+	/* calculated timing on brownstone:
+	 * DSI_PHY_TIME_0 0x06080204
+	 * DSI_PHY_TIME_1 0x6d2bfff0
+	 * DSI_PHY_TIME_2 0x603130a
+	 * DSI_PHY_TIME_3 0xa3c
+	 */
+}
+
+void dsi_reset(struct pxa168fb_info *fbi, int hold)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	volatile unsigned int reg;
+
+	printk(KERN_DEBUG "%s\n", __func__);
+	writel(0x0, &dsi->ctrl0);
+	reg = readl(&dsi->ctrl0);
+	reg |= DSI_CTRL_0_CFG_SOFT_RST | DSI_CTRL_0_CFG_SOFT_RST_REG;
+
+	if (!hold) {
+		writel(reg, &dsi->ctrl0);
+		reg &= ~(DSI_CTRL_0_CFG_SOFT_RST | DSI_CTRL_0_CFG_SOFT_RST_REG);
+		mdelay(1);
+	}
+	writel(reg, &dsi->ctrl0);
+}
+
+void dsi_set_controller(struct pxa168fb_info *fbi)
+{
+	struct fb_var_screeninfo *var = &(fbi->fb_info->var);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	struct dsi_lcd_regs *dsi_lcd = &dsi->lcd1;
+	unsigned hsync_b, hbp_b, hact_b, hex_b, hfp_b, httl_b;
+	unsigned hsync, hbp, hact, hfp, httl, h_total, v_total;
+	unsigned hsa_wc, hbp_wc, hact_wc, hex_wc, hfp_wc, hlp_wc;
+	int bpp = di->bpp, hss_bcnt = 4, hse_bct = 4, lgp_over_head = 6, reg;
+
+	if (di->id & 2)
+		dsi_lcd = &dsi->lcd2;
+	pr_debug("%s dsi %d lanes %d burst_mode %d bpp %d\n",
+		__func__, di->id, di->lanes, di->burst_mode, bpp);
+
+	h_total = var->xres + var->left_margin +
+		 var->right_margin + var->hsync_len;
+	v_total = var->yres + var->upper_margin +
+		 var->lower_margin + var->vsync_len;
+
+	hact_b = to_dsi_bcnt(var->xres, bpp);
+	hfp_b = to_dsi_bcnt(var->right_margin, bpp);
+	hbp_b = to_dsi_bcnt(var->left_margin, bpp);
+	hsync_b = to_dsi_bcnt(var->hsync_len, bpp);
+	hex_b = to_dsi_bcnt(dsi_ex_pixel_cnt, bpp);
+	httl_b = hact_b + hsync_b + hfp_b + hbp_b + hex_b;
+
+	hact = hact_b / di->lanes;
+	hfp = hfp_b / di->lanes;
+	hbp = hbp_b / di->lanes;
+	hsync = hsync_b / di->lanes;
+	httl = hact + hfp + hbp + hsync;
+
+	/* word count in the unit of byte */
+	hsa_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(hsync_b - hss_bcnt - lgp_over_head) : 0;
+
+	/* Hse is with backporch */
+	hbp_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(hbp_b - hse_bct - lgp_over_head) \
+		: (hsync_b + hbp_b - hss_bcnt - lgp_over_head);
+
+	hfp_wc = ((di->burst_mode == DSI_BURST_MODE_BURST) && \
+		(dsi_hex_en == 0)) ? \
+		(hfp_b + hex_b - lgp_over_head - lgp_over_head) : \
+		(hfp_b - lgp_over_head - lgp_over_head);
+
+	hact_wc =  ((var->xres) * bpp) >> 3;
+
+	/* disable Hex currently */
+	hex_wc = 0;
+
+	/*  There is no hlp with active data segment.  */
+	hlp_wc = (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(httl_b - hsync_b - hse_bct - lgp_over_head) : \
+		(httl_b - hss_bcnt - lgp_over_head);
+
+	/* FIXME - need to double check the (*3) is bytes_per_pixel from
+	 * input data or output to panel */
+	/* dsi_lane_enable - Set according to specified DSI lane count */
+	writel(dsi_lane[di->lanes] << DSI_PHY_CTRL_2_CFG_CSR_LANE_EN_SHIFT,
+		 &dsi->phy_ctrl2);
+	writel(dsi_lane[di->lanes] << DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT,
+		 &dsi->cmd1);
+
+	/* SET UP LCD1 TIMING REGISTERS FOR DSI BUS */
+	/* NOTE: Some register values were obtained by trial and error */
+	writel((hact << 16) | httl, &dsi_lcd->timing0);
+	writel((hsync << 16) | hbp, &dsi_lcd->timing1);
+	/*
+	 * For now the active size is set really low (we'll use 10) to allow
+	 * the hardware to attain V Sync. Once the DSI bus is up and running,
+	 * the final value will be put in place for the active size (this is
+	 * done below). In a later stepping of the processor this workaround
+	 * will not be required.
+	 */
+	writel(((var->yres)<<16) | (v_total), &dsi_lcd->timing2);
+
+	writel(((var->vsync_len) << 16) | (var->upper_margin),
+		 &dsi_lcd->timing3);
+
+	/* SET UP LCD1 WORD COUNT REGISTERS FOR DSI BUS */
+	/* Set up for word(byte) count register 0 */
+	writel((hbp_wc << 16) | hsa_wc, &dsi_lcd->wc0);
+	writel((hfp_wc << 16) | hact_wc, &dsi_lcd->wc1);
+	writel((hex_wc << 16) | hlp_wc, &dsi_lcd->wc2);
+	/* calculated value on brownstone:
+	 * WC0: 0x1a0000
+	 * WC1: 0x1500f00
+	 * WC2: 0x1076 */
+
+	/* Configure LCD control register 1 FOR DSI BUS */
+	reg = ((di->rgb_mode << DSI_LCD2_CTRL_1_CFG_L1_RGB_TYPE_SHIFT)
+	  | (di->burst_mode << DSI_LCD1_CTRL_1_CFG_L1_BURST_MODE_SHIFT)
+	  | (di->lpm_line_en ? DSI_LCD1_CTRL_1_CFG_L1_LPM_LINE_EN : 0)
+	  | (di->lpm_frame_en ? DSI_LCD1_CTRL_1_CFG_L1_LPM_FRAME_EN : 0)
+	  | (di->last_line_turn ? DSI_LCD1_CTRL_1_CFG_L1_LAST_LINE_TURN : 0)
+	  | (di->hex_slot_en ? 0 : 0)   /* disable Hex slot */
+	  | (di->all_slot_en ? 0 : 0)   /* disable all slots */
+	  | (di->hbp_en ? DSI_LCD1_CTRL_1_CFG_L1_HBP_PKT_EN : 0)
+	  | (di->hact_en ? DSI_LCD1_CTRL_1_CFG_L1_HACT_PKT_EN : 0)
+	  | (di->hfp_en ? DSI_LCD1_CTRL_1_CFG_L1_HFP_PKT_EN : 0)
+	  | (di->hex_en ? 0 : 0)      /* Hex packet is disabled */
+	  | (di->hlp_en ? DSI_LCD1_CTRL_1_CFG_L1_HLP_PKT_EN : 0));
+
+	reg |= (di->burst_mode == DSI_BURST_MODE_SYNC_PULSE) ? \
+		(((di->hsa_en) ? DSI_LCD1_CTRL_1_CFG_L1_HSA_PKT_EN : 0)
+		| (DSI_LCD1_CTRL_1_CFG_L1_HSE_PKT_EN))  /* Hse is eabled */
+		:
+		(((di->hsa_en) ? 0 : 0)   /* Hsa packet is disabled */
+		| ((di->hse_en) ? 0 : 0)); /* Hse packet is disabled */
+
+	reg |=  DSI_LCD1_CTRL_1_CFG_L1_VSYNC_RST_EN;
+	writel(reg, &dsi_lcd->ctrl1);
+
+	/*Start the transfer of LCD data over the DSI bus*/
+	/* DSI_CTRL_1 */
+	reg = readl(&dsi->ctrl1);
+	reg &= ~(DSI_CTRL_1_CFG_LCD2_VCH_NO_MASK |
+		 DSI_CTRL_1_CFG_LCD1_VCH_NO_MASK);
+	reg |= 0x1 << ((di->id & 1) ? DSI_CTRL_1_CFG_LCD2_VCH_NO_SHIFT :
+		 DSI_CTRL_1_CFG_LCD1_VCH_NO_SHIFT);
+
+	reg &= ~(DSI_CTRL_1_CFG_EOTP);
+	if (di->eotp_en)
+		reg |= DSI_CTRL_1_CFG_EOTP;	/* EOTP */
+
+	writel(reg, &dsi->ctrl1);
+
+	/* DSI_CTRL_0 */
+	reg = (di->master_mode ? 0 : DSI_CTRL_0_CFG_LCD1_SLV) |
+		DSI_CTRL_0_CFG_LCD1_TX_EN | DSI_CTRL_0_CFG_LCD1_EN;
+	if (di->id & 2)
+		reg = reg << 1;
+	writel(reg, &dsi->ctrl0);
+
+	writel(((var->yres)<<16) | (v_total), &dsi_lcd->timing2);
+}
+
+void set_dsi_low_power_mode(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	u32 reg = readl(&dsi->phy_ctrl2);
+
+	/* enable data lane data0*/
+	reg &= ~(0xf << 4);
+	reg |= (1 << 4);
+	writel(reg, &dsi->phy_ctrl2);
+
+	/* LPDT TX enabled for data0 */
+	reg = readl(&dsi->cmd1);
+	reg &= ~(0xf << 20);
+	reg |= 1 << DSI_CPU_CMD_1_CFG_TXLP_LPDT_SHIFT;
+	writel(reg, &dsi->cmd1);
+}
+
+static int dsi_dump(struct pxa168fb_info *fbi, int f, char *buf, int s)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	int dsi_base = (int)(&dsi->ctrl0);
+
+	if (!di) {
+		pr_err("%s: no dsi info available\n", __func__);
+		return s;
+	}
+	mvdisp_dump(f, "dsi_info: ch %d lanes %d bpp %d\n\n", di->id,
+			di->lanes, di->bpp);
+
+	mvdisp_dump(f, "dsi regs base 0x%p\n", dsi);
+	mvdisp_dump(f, "\tctrl0      (@%3x):\t0x%x\n",
+		(int)(&dsi->ctrl0) - dsi_base, readl(&dsi->ctrl0));
+	mvdisp_dump(f, "\tctrl1      (@%3x):\t0x%x\n",
+		(int)(&dsi->ctrl1) - dsi_base, readl(&dsi->ctrl1));
+	mvdisp_dump(f, "\tirq_status (@%3x):\t0x%x\n",
+		(int)(&dsi->irq_status) - dsi_base, readl(&dsi->irq_status));
+	mvdisp_dump(f, "\tirq_mask   (@%3x):\t0x%x\n",
+		(int)(&dsi->irq_mask) - dsi_base, readl(&dsi->irq_mask));
+	mvdisp_dump(f, "\tcmd0       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd0) - dsi_base, readl(&dsi->cmd0));
+	mvdisp_dump(f, "\tcmd1       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd1) - dsi_base, readl(&dsi->cmd1));
+	mvdisp_dump(f, "\tcmd2       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd2) - dsi_base, readl(&dsi->cmd2));
+	mvdisp_dump(f, "\tcmd3       (@%3x):\t0x%x\n",
+		(int)(&dsi->cmd3) - dsi_base, readl(&dsi->cmd3));
+	mvdisp_dump(f, "\tdat0       (@%3x):\t0x%x\n",
+		(int)(&dsi->dat0) - dsi_base, readl(&dsi->dat0));
+	mvdisp_dump(f, "\tstatus0    (@%3x):\t0x%x\n",
+		(int)(&dsi->status0) - dsi_base, readl(&dsi->status0));
+	mvdisp_dump(f, "\tstatus1    (@%3x):\t0x%x\n",
+		(int)(&dsi->status1) - dsi_base, readl(&dsi->status1));
+	mvdisp_dump(f, "\tstatus2    (@%3x):\t0x%x\n",
+		(int)(&dsi->status2) - dsi_base, readl(&dsi->status2));
+	mvdisp_dump(f, "\tstatus3    (@%3x):\t0x%x\n",
+		(int)(&dsi->status3) - dsi_base, readl(&dsi->status3));
+	mvdisp_dump(f, "\tstatus4    (@%3x):\t0x%x\n",
+		(int)(&dsi->status4) - dsi_base, readl(&dsi->status4));
+	mvdisp_dump(f, "\tsmt_cmd    (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_cmd) - dsi_base, readl(&dsi->smt_cmd));
+	mvdisp_dump(f, "\tsmt_ctrl0  (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_ctrl0) - dsi_base, readl(&dsi->smt_ctrl0));
+	mvdisp_dump(f, "\tsmt_ctrl1  (@%3x):\t0x%x\n",
+		(int)(&dsi->smt_ctrl1) - dsi_base, readl(&dsi->smt_ctrl1));
+	mvdisp_dump(f, "\trx0_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx0_status) - dsi_base, readl(&dsi->rx0_status));
+	mvdisp_dump(f, "\trx0_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx0_header) - dsi_base, readl(&dsi->rx0_header));
+	mvdisp_dump(f, "\trx1_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx1_status) - dsi_base, readl(&dsi->rx1_status));
+	mvdisp_dump(f, "\trx1_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx1_header) - dsi_base, readl(&dsi->rx1_header));
+	mvdisp_dump(f, "\trx_ctrl    (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_ctrl) - dsi_base, readl(&dsi->rx_ctrl));
+	mvdisp_dump(f, "\trx_ctrl1   (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_ctrl1) - dsi_base, readl(&dsi->rx_ctrl1));
+	mvdisp_dump(f, "\trx2_status (@%3x):\t0x%x\n",
+		(int)(&dsi->rx2_status) - dsi_base, readl(&dsi->rx2_status));
+	mvdisp_dump(f, "\trx2_header (@%3x):\t0x%x\n",
+		(int)(&dsi->rx2_header) - dsi_base, readl(&dsi->rx2_header));
+	mvdisp_dump(f, "\tphy_ctrl1  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl1) - dsi_base, readl(&dsi->phy_ctrl1));
+	mvdisp_dump(f, "\tphy_ctrl2  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl2) - dsi_base, readl(&dsi->phy_ctrl2));
+	mvdisp_dump(f, "\tphy_ctrl3  (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_ctrl3) - dsi_base, readl(&dsi->phy_ctrl3));
+	mvdisp_dump(f, "\tphy_status0(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status0) - dsi_base, readl(&dsi->phy_status0));
+	mvdisp_dump(f, "\tphy_status1(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status1) - dsi_base, readl(&dsi->phy_status1));
+	mvdisp_dump(f, "\tphy_status2(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_status2) - dsi_base, readl(&dsi->phy_status2));
+	mvdisp_dump(f, "\tphy_rcomp0 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_rcomp0) - dsi_base, readl(&dsi->phy_rcomp0));
+	mvdisp_dump(f, "\tphy_timing0(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing0) - dsi_base, readl(&dsi->phy_timing0));
+	mvdisp_dump(f, "\tphy_timing1(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing1) - dsi_base, readl(&dsi->phy_timing1));
+	mvdisp_dump(f, "\tphy_timing2(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing2) - dsi_base, readl(&dsi->phy_timing2));
+	mvdisp_dump(f, "\tphy_timing3(@%3x):\t0x%x\n",
+		(int)(&dsi->phy_timing3) - dsi_base, readl(&dsi->phy_timing3));
+	mvdisp_dump(f, "\tphy_code_0 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_code_0) - dsi_base, readl(&dsi->phy_code_0));
+	mvdisp_dump(f, "\tphy_code_1 (@%3x):\t0x%x\n",
+		(int)(&dsi->phy_code_1) - dsi_base, readl(&dsi->phy_code_1));
+	mvdisp_dump(f, "\tmem_ctrl   (@%3x):\t0x%x\n",
+		(int)(&dsi->mem_ctrl) - dsi_base, readl(&dsi->mem_ctrl));
+	mvdisp_dump(f, "\ttx_timer   (@%3x):\t0x%x\n",
+		(int)(&dsi->tx_timer) - dsi_base, readl(&dsi->tx_timer));
+	mvdisp_dump(f, "\trx_timer   (@%3x):\t0x%x\n",
+		(int)(&dsi->rx_timer) - dsi_base, readl(&dsi->rx_timer));
+	mvdisp_dump(f, "\tturn_timer (@%3x):\t0x%x\n",
+		(int)(&dsi->turn_timer) - dsi_base, readl(&dsi->turn_timer));
+
+	mvdisp_dump(f, "\nlcd1 regs\n");
+	mvdisp_dump(f, "\tctrl0     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.ctrl0) - dsi_base, readl(&dsi->lcd1.ctrl0));
+	mvdisp_dump(f, "\tctrl1     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.ctrl1) - dsi_base, readl(&dsi->lcd1.ctrl1));
+	mvdisp_dump(f, "\ttiming0   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing0) - dsi_base,
+		readl(&dsi->lcd1.timing0));
+	mvdisp_dump(f, "\ttiming1   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing1) - dsi_base,
+		readl(&dsi->lcd1.timing1));
+	mvdisp_dump(f, "\ttiming2   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing2) - dsi_base,
+		readl(&dsi->lcd1.timing2));
+	mvdisp_dump(f, "\ttiming3   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.timing3) - dsi_base,
+		readl(&dsi->lcd1.timing3));
+	mvdisp_dump(f, "\twc0       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc0) - dsi_base, readl(&dsi->lcd1.wc0));
+	mvdisp_dump(f, "\twc1       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc1) - dsi_base, readl(&dsi->lcd1.wc1));
+	mvdisp_dump(f, "\twc2       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.wc2) - dsi_base, readl(&dsi->lcd1.wc2));
+	mvdisp_dump(f, "\tslot_cnt0 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.slot_cnt0) - dsi_base,
+		readl(&dsi->lcd1.slot_cnt0));
+	mvdisp_dump(f, "\tslot_cnt1 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.slot_cnt1) - dsi_base,
+		readl(&dsi->lcd1.slot_cnt1));
+	mvdisp_dump(f, "\tstatus_0  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_0) - dsi_base,
+		readl(&dsi->lcd1.status_0));
+	mvdisp_dump(f, "\tstatus_1  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_1) - dsi_base,
+		readl(&dsi->lcd1.status_1));
+	mvdisp_dump(f, "\tstatus_2  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_2) - dsi_base,
+		readl(&dsi->lcd1.status_2));
+	mvdisp_dump(f, "\tstatus_3  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_3) - dsi_base,
+		readl(&dsi->lcd1.status_3));
+	mvdisp_dump(f, "\tstatus_4  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd1.status_4) - dsi_base,
+		readl(&dsi->lcd1.status_4));
+
+	mvdisp_dump(f, "\nlcd2 regs\n");
+	mvdisp_dump(f, "\tctrl0     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.ctrl0) - dsi_base,
+		readl(&dsi->lcd2.ctrl0));
+	mvdisp_dump(f, "\tctrl1     (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.ctrl1) - dsi_base,
+		readl(&dsi->lcd2.ctrl1));
+	mvdisp_dump(f, "\ttiming0   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing0) - dsi_base,
+		readl(&dsi->lcd2.timing0));
+	mvdisp_dump(f, "\ttiming1   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing1) - dsi_base,
+		readl(&dsi->lcd2.timing1));
+	mvdisp_dump(f, "\ttiming2   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing2) - dsi_base,
+		readl(&dsi->lcd2.timing2));
+	mvdisp_dump(f, "\ttiming3   (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.timing3) - dsi_base,
+		readl(&dsi->lcd2.timing3));
+	mvdisp_dump(f, "\twc0       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc0) - dsi_base, readl(&dsi->lcd2.wc0));
+	mvdisp_dump(f, "\twc1       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc1) - dsi_base, readl(&dsi->lcd2.wc1));
+	mvdisp_dump(f, "\twc2       (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.wc2) - dsi_base, readl(&dsi->lcd2.wc2));
+	mvdisp_dump(f, "\tslot_cnt0 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.slot_cnt0) - dsi_base,
+		readl(&dsi->lcd2.slot_cnt0));
+	mvdisp_dump(f, "\tslot_cnt1 (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.slot_cnt1) - dsi_base,
+		readl(&dsi->lcd2.slot_cnt1));
+	mvdisp_dump(f, "\tstatus_0  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_0) - dsi_base,
+		readl(&dsi->lcd2.status_0));
+	mvdisp_dump(f, "\tstatus_1  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_1) - dsi_base,
+		readl(&dsi->lcd2.status_1));
+	mvdisp_dump(f, "\tstatus_2  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_2) - dsi_base,
+		readl(&dsi->lcd2.status_2));
+	mvdisp_dump(f, "\tstatus_3  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_3) - dsi_base,
+		readl(&dsi->lcd2.status_3));
+	mvdisp_dump(f, "\tstatus_4  (@%3x):\t0x%x\n",
+		(int)(&dsi->lcd2.status_4) - dsi_base,
+		readl(&dsi->lcd2.status_4));
+
+	mvdisp_dump(f, "\ncommands:\n");
+	mvdisp_dump(f, " - dump all DSI controller registers\n");
+	mvdisp_dump(f, "\tcat phy\n");
+	mvdisp_dump(f, " - dump DSI register @ [offset_hex]\n");
+	mvdisp_dump(f, "\techo -0x[offset_hex] > phy\n");
+	mvdisp_dump(f, " - set DSI register @ [offset_hex] with [value_hex]\n");
+	mvdisp_dump(f, "\techo 0x[value_hex] > phy\n");
+
+	return s;
+}
+
+/* select LVDS_PHY_CTL_EXTx */
+#define lvds_ext_select(ext, tmp, reg) do {				\
+	if ((ext < 0) || (ext > 5)) {					\
+		pr_err("%s ext %d not supported\n", __func__, ext);	\
+		return 0;						\
+	}								\
+	reg = (u32)gfx_info.fbi[0]->reg_base + LVDS_PHY_CTL;		\
+	if (ext) {							\
+		/* select LVDS_PHY_CTL_EXTx */				\
+		tmp = readl(reg) & (~LVDS_PHY_EXT_MASK);		\
+		writel(tmp | (ext - 1) << LVDS_PHY_EXT_SHIFT, reg);	\
+		/* switch to LVDS_PHY_CTL_EXTx */			\
+		reg -= LVDS_PHY_CTL; reg += LVDS_PHY_CTL_EXT;		\
+	}								\
+} while (0)
+
+static u32 lvds_get(int ext)
+{
+	u32 reg, tmp;
+
+	lvds_ext_select(ext, tmp, reg);
+
+	return readl(reg);
+}
+
+static int lvds_set(int ext, u32 mask, u32 val)
+{
+	u32 reg, tmp, tmp2;
+
+	lvds_ext_select(ext, tmp, reg);
+
+	tmp = tmp2 = readl(reg);
+	tmp2 &= ~mask; tmp2 |= val;
+	if (tmp != tmp2)
+		writel(tmp2, reg);
+
+	return 0;
+}
+
+static int lvds_dump(struct pxa168fb_info *fbi, int f, char *buf, int s)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lvds_info *lvds = (struct lvds_info *)mi->phy_info;
+	u32 reg = (u32)fbi->reg_base + LCD_2ND_BLD_CTL;
+	char *str;
+
+	switch (lvds->src) {
+	case LVDS_SRC_PN:
+		str = "PN";
+		break;
+	case LVDS_SRC_CMU:
+		str = "CMU";
+		break;
+	case LVDS_SRC_PN2:
+		str = "PN2";
+		break;
+	case LVDS_SRC_TV:
+		str = "TV";
+		break;
+	default:
+		str = "?";
+		break;
+	};
+
+	mvdisp_dump(f, "lvds_info: src %s fmt %s\n", str,
+		(lvds->fmt & LVDS_FMT_18BIT) ? "18bit" : "24bit");
+	mvdisp_dump(f, "LCD_2ND_BLD_CTL(0x%x): 0x%x\n\n",
+		reg & 0xfff, readl(reg));
+
+	mvdisp_dump(f, "LVDS_PHY_CTL: 0x%x\n", lvds_get(0));
+	mvdisp_dump(f, "        EXT1: 0x%x\n", lvds_get(1));
+	mvdisp_dump(f, "        EXT2: 0x%x\n", lvds_get(2));
+	mvdisp_dump(f, "        EXT3: 0x%x\n", lvds_get(3));
+	mvdisp_dump(f, "        EXT4: 0x%x\n", lvds_get(4));
+	mvdisp_dump(f, "        EXT5: 0x%x\n", lvds_get(5));
+
+	return s;
+}
+
+int pxa688_lvds_config(struct lvds_info *lvds)
+{
+	u32 reg = (u32)gfx_info.fbi[0]->reg_base + LCD_2ND_BLD_CTL;
+	u32 val = readl(reg) & ~(LVDS_SRC_MASK | LVDS_FMT_MASK);
+
+	val |= (lvds->src << LVDS_SRC_SHIFT) | (lvds->fmt << LVDS_FMT_SHIFT);
+	writel(val, reg);
+
+	return 0;
+}
+
+int pxa688_lvds_init(struct pxa168fb_info *fbi)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct lvds_info *lvds = (struct lvds_info *)mi->phy_info;
+	int count = 100000;
+	u32 mask, val;
+
+	/* configure lvds src and fmt */
+	pxa688_lvds_config(lvds);
+
+	/* release LVDS PHY from reset */
+	lvds_set(0, LVDS_RST, 0);
+	mdelay(1);
+
+	/* disable LVDS channel 0-5 power-down */
+	lvds_set(0, LVDS_PD_CH_MASK, 0);
+
+	/* select LVDS_PCLK instead of REFCLK as LVDS PHY clock */
+	lvds_set(0, LVDS_CLK_SEL, LVDS_CLK_SEL_LVDS_PCLK);
+
+	/* power up IP */
+	lvds_set(0, LVDS_PU_IVREF, LVDS_PU_IVREF);
+
+	/* REFDIV = 0x3, reference clock divider
+	 * FBDIV = 0xa, feedback clock divider
+	 * KVCO = 0x4, 1.7G - 1.9G */
+	mask = LVDS_REFDIV_MASK | LVDS_FBDIV_MASK | LVDS_REFDIV_MASK
+		| LVDS_CTUNE_MASK | LVDS_VREG_IVREF_MASK
+		| LVDS_VDDL_MASK | LVDS_VDDM_MASK;
+	val = (0x6 << LVDS_REFDIV_SHIFT) | (0x1 << LVDS_FBDIV_SHIFT)
+		| (0x4 << LVDS_KVCO_SHIFT | (0x2 << LVDS_CTUNE_SHIFT)
+		| (0x2 << LVDS_VREG_IVREF_SHIFT) | (0x9 << LVDS_VDDL_SHIFT)
+		| (0x1 << LVDS_VDDM_SHIFT));
+	lvds_set(3, mask, val);
+
+	/* VCO_VRNG = 0x3, LVDS PLL V to I gain control, for KVCO[3:0] = 0x4 */
+	mask = LVDS_VCO_VRNG_MASK | LVDS_ICP_MASK | LVDS_PI_EN
+		| LVDS_VCODIV_SEL_SE_MASK | LVDS_INTPI_MASK;
+	val = (0x3 << LVDS_VCO_VRNG_SHIFT) | (0x1 << LVDS_ICP_SHIFT)
+		| LVDS_PI_EN | (0xd << LVDS_VCODIV_SEL_SE_SHIFT)
+		| (0x3 << LVDS_INTPI_SHIFT);
+	lvds_set(4, mask, val);
+
+	/* enable PUPLL/PUTX to power up rest of PLL and TX */
+	lvds_set(0, LVDS_PU_TX | LVDS_PU_PLL, LVDS_PU_TX | LVDS_PU_PLL);
+
+	/* poll on lock bit until LVDS PLL locks */
+	while (!(lvds_get(0) & LVDS_PLL_LOCK) && count--);
+	if (count <= 0) {
+		pr_err("%s failed\n", __func__);
+		lvds_dump(fbi, DUMP_PRINFO, NULL, 0);
+	}
+
+	/* enable common mode feedback circuit */
+	mask = LVDS_SELLV_OP9_MASK | LVDS_SELLV_OP7_MASK | LVDS_SELLV_OP6_MASK
+		| LVDS_SELLV_TXDATA_MASK | LVDS_SELLV_TXCLK_MASK | LVDS_TX_DIF_CM_MASK
+		| LVDS_TX_DIF_AMP_MASK | LVDS_TX_TERM_EN | LVDS_TX_CMFB_EN;
+	val = (0x1 << LVDS_SELLV_OP9_SHIFT) | (0x1 << LVDS_SELLV_OP7_SHIFT)
+		| (0x1 << LVDS_SELLV_OP6_SHIFT) | (0x5 << LVDS_SELLV_TXDATA_SHIFT)
+		| (0x5 << LVDS_SELLV_TXCLK_SHIFT) | (0x3 << LVDS_TX_DIF_CM_SHIFT)
+		| (0x8 << LVDS_TX_DIF_AMP_SHIFT) | LVDS_TX_TERM_EN;
+	lvds_set(2, mask, val);
+
+	/* Flip all the N\P pins in order to get correct display,
+	 * the pins might be inverted in the chip */
+	lvds_set(1, LVDS_POL_SWAP_MASK, 0x3f << LVDS_POL_SWAP_SHIFT);
+
+	return 0;
+}
+
+static void dsi_store(struct pxa168fb_mach_info *mi,
+	const char *buf, size_t size)
+{
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct dsi_regs *dsi = (struct dsi_regs *)di->regs;
+	static u32 mvdsi_reg;
+	char vol[30];
+	u32 addr, tmp;
+
+	if (size > 30) {
+		pr_err("%s size = %d > max 30 chars\n", __func__, size);
+		return;
+	}
+
+	addr = (u32)&dsi->ctrl0;
+	if ('-' == buf[0]) {
+		memcpy(vol, buf + 1, size - 1);
+		mvdsi_reg = (int)simple_strtoul(vol, NULL, 16);
+		pr_info("dsi reg @ 0x%x: 0x%x\n", mvdsi_reg,
+			__raw_readl(addr + mvdsi_reg));
+	} else if ('0' == buf[0] && 'x' == buf[1]) {
+		/* set the register value */
+		tmp = (int)simple_strtoul(buf, NULL, 16);
+		__raw_writel(tmp, addr + mvdsi_reg);
+		pr_info("set dsi reg @ 0x%x: 0x%x\n", mvdsi_reg,
+			__raw_readl(addr + mvdsi_reg));
+	}
+}
+
+ssize_t phy_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int s = 0;
+
+	if (!mi)
+		goto out;
+
+	if (mi->phy_type & LVDS)
+		s += lvds_dump(fbi, DUMP_SPRINTF, buf, s);
+
+	if ((mi->phy_type & (DSI | DSI2DPI)))
+		s += dsi_dump(fbi, DUMP_SPRINTF, buf, s);
+
+out:
+	return s;
+}
+
+ssize_t phy_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int value;
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+		dsi_store(mi, buf, size);
+	else
+		sscanf(buf, "%d", &value);
+
+	return size;
+}
+DEVICE_ATTR(phy, S_IRUGO | S_IWUSR, phy_show, phy_store);
+
+#endif
diff --git a/drivers/video/pxa688_vdma.c b/drivers/video/pxa688_vdma.c
new file mode 100644
index 0000000..46f1325
--- /dev/null
+++ b/drivers/video/pxa688_vdma.c
@@ -0,0 +1,824 @@
+/*
+ * linux/drivers/video/pxa168fb.c -- Marvell PXA168 LCD Controller
+ *
+ *  Copyright (C) 2008 Marvell International Ltd.
+ *  All rights reserved.
+ *
+ *  2009-02-16  adapted from original version for PXA168
+ *		Kevin Liu <kliu5@marvell.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file COPYING in the main directory of this archive for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/videodev2.h>
+
+#ifdef CONFIG_PXA688_VDMA
+
+#include "pxa168fb_common.h"
+#include <mach/irqs.h>
+#include <mach/pxa168fb.h>
+#include <mach/hardware.h>
+#include <mach/cputype.h>
+#include <mach/gpio.h>
+
+#include <asm/mach-types.h>
+#include <mach/regs-apmu.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/regs-mpmu.h>
+#include <asm/mach-types.h>
+#include <mach/sram.h>
+
+static DEFINE_SPINLOCK(ctrl_lock);
+
+static struct pxa168fb_vdma_info vdma0 = {
+	.ch = 0,
+	.path = 0,
+	.sram_paddr = 0,
+	.sram_size = 0,
+	.enable = 0,
+};
+static struct pxa168fb_vdma_info vdma1 = {
+	.ch = 1,
+	.path = 1,
+	.sram_paddr = 0,
+	.sram_size = 0,
+	.enable = 0,
+};
+
+/* convert pix fmt to vmode */
+static FBVideoMode pixfmt_to_vmode(int pix_fmt)
+{
+	switch(pix_fmt) {
+	case PIX_FMT_RGB565:
+	case V4L2_PIX_FMT_RGB565X:
+		return FB_VMODE_RGB565;
+	case PIX_FMT_BGR565:
+		return FB_VMODE_BGR565;
+	case PIX_FMT_RGB1555:
+	case V4L2_PIX_FMT_RGB555X:
+		return FB_VMODE_RGB1555;
+	case PIX_FMT_BGR1555:
+		return FB_VMODE_BGR1555;
+	case PIX_FMT_RGB888PACK:
+	case V4L2_PIX_FMT_RGB24:
+		return FB_VMODE_RGB888PACK;
+	case PIX_FMT_BGR888PACK:
+	case V4L2_PIX_FMT_BGR24:
+		return FB_VMODE_BGR888PACK;
+	case PIX_FMT_RGB888UNPACK:
+		return FB_VMODE_RGB888UNPACK;
+	case PIX_FMT_BGR888UNPACK:
+		return FB_VMODE_BGR888UNPACK;
+	case PIX_FMT_RGBA888:
+	case V4L2_PIX_FMT_RGB32:
+		return FB_VMODE_RGBA888;
+	case PIX_FMT_BGRA888:
+	case V4L2_PIX_FMT_BGR32:
+		return FB_VMODE_BGRA888;
+
+	case PIX_FMT_YUV422PACK:
+	case V4L2_PIX_FMT_UYVY:
+		return FB_VMODE_YUV422PACKED;
+	case PIX_FMT_YVU422PACK:
+		return FB_VMODE_YUV422PACKED_SWAPUV;
+	case PIX_FMT_YUV422PLANAR:
+	case V4L2_PIX_FMT_YUV422P:
+		return FB_VMODE_YUV422PLANAR;
+	case PIX_FMT_YVU422PLANAR:
+		return FB_VMODE_YUV422PLANAR_SWAPUV;
+	case PIX_FMT_YUV420PLANAR:
+	case V4L2_PIX_FMT_YUV420:
+		return FB_VMODE_YUV420PLANAR;
+	case PIX_FMT_YVU420PLANAR:
+	case V4L2_PIX_FMT_YVU420:
+		return FB_VMODE_YUV420PLANAR_SWAPUV;
+	case PIX_FMT_YUYV422PACK:
+	case V4L2_PIX_FMT_YUYV:
+		return FB_VMODE_YUV422PACKED_SWAPYUorV;
+	case PIX_FMT_YUV422PACK_IRE_90_270:
+		return FB_VMODE_YUV422PACKED_IRE_90_270;
+	default:
+		return -1;
+	};
+}
+
+#define vdma_ctrl(id)		(id ? VDMA_CTRL_2 : VDMA_CTRL_1)
+
+static u32 lcd_pitch_read(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	struct lcd_regs *regs = get_regs(lcd_vdma->path);
+	u32 reg = (u32)&regs->g_pitch;
+
+	if (lcd_vdma->vid)
+		reg = (u32)&regs->v_pitch_yc;
+
+	return __raw_readl(reg) & 0xffff;
+}
+
+static u32 lcd_height_read(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	struct lcd_regs *regs = get_regs(lcd_vdma->path);
+	u32 reg = (u32)&regs->g_size;
+
+	if (lcd_vdma->vid)
+		reg = (u32)&regs->v_size;
+
+	return (__raw_readl(reg) & 0xfff0000) >> 16;
+}
+
+static u32 lcd_width_read(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	struct lcd_regs *regs = get_regs(lcd_vdma->path);
+	u32 reg = (u32)&regs->g_size;
+
+	if (lcd_vdma->vid)
+		reg = (u32)&regs->v_size;
+
+	return __raw_readl(reg) & 0xfff;
+}
+
+static u32 vdma_ctrl_read(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	u32 reg = (u32)lcd_vdma->reg_base + vdma_ctrl(lcd_vdma->ch);
+
+	return __raw_readl(reg);
+}
+
+static int __get_vdma_rot_ctrl(int vmode, int angle, int yuv_format)
+{
+	int rotation, flag = 0, reg = 0;
+
+	if (!angle || (angle == 1))
+		return 0;
+
+	switch (angle) {
+	case 90:
+		rotation = 1;
+		break;
+	case 270:
+		rotation = 0;
+		break;
+	case 180:
+		rotation = 2;
+		break;
+	default:
+		rotation = 0;
+		break;
+		/* return rotation; */
+	}
+
+	switch (vmode) {
+	case FB_VMODE_RGB565:
+	case FB_VMODE_BGR565:
+	case FB_VMODE_RGB1555:
+	case FB_VMODE_BGR1555:
+		reg = 4 << 2;
+		reg |= rotation << 11;
+		break;
+	case FB_VMODE_YUV422PACKED:
+	case FB_VMODE_YUV422PACKED_SWAPUV:
+	case FB_VMODE_YUV422PACKED_SWAPYUorV:
+		flag = 1;
+	case FB_VMODE_YUV422PACKED_IRE_90_270:
+		reg = 1 << 5;
+		reg |= 1 << 7;
+		reg |= 3 << 2;
+		reg |= rotation << 11;
+		break;
+	default:
+		reg = 6 << 2;
+		reg |= rotation << 11;
+		reg |= 0 << 7;
+		break;
+	}
+
+	if (vmode == FB_VMODE_YUV422PACKED_IRE_90_270 || flag == 1) {
+		if (rotation == 2)
+			reg |= 2 << 21;
+		else
+			reg |= 1 << 21;
+
+		if (vmode == FB_VMODE_YUV422PACKED)
+			yuv_format = 1;
+		if (vmode == FB_VMODE_YUV422PACKED_SWAPUV)
+			yuv_format = 2;
+		if (vmode == FB_VMODE_YUV422PACKED_SWAPYUorV)
+			yuv_format = 4;
+
+		switch (yuv_format) {
+		case 1:/*YUV_FORMAT_UYVY*/
+			reg |= 1 << 9;
+			break;
+		case 2:/*YUV_FORMAT_VYUY*/
+			reg |= 0 << 9;
+			break;
+		case 3:/*YUV_FORAMT_YVYU*/
+			reg |= 3 << 9;
+			break;
+		case 4:/*YUV_FORMAT_YUYV*/
+			reg |= 2 << 9;
+			break;
+		}
+	}
+
+	return reg;
+}
+
+static int __get_vdma_src_sz(struct pxa168fb_vdma_info *lcd_vdma,
+		int vmode, int width, int height)
+{
+	int res = lcd_pitch_read(lcd_vdma) * height;
+
+	if (vmode == FB_VMODE_YUV422PACKED_IRE_90_270)
+		return res >> 1;
+	else
+		return res;
+}
+
+static int __get_vdma_sa(struct pxa168fb_vdma_info *lcd_vdma, int vmode,
+		int width, int height, int bpp, int rotation)
+{
+	struct lcd_regs *regs = get_regs(lcd_vdma->path);
+	int addr = 0;
+
+	if (vmode == FB_VMODE_YUV422PACKED_IRE_90_270)
+		bpp = 2;
+
+	if (lcd_vdma->vid)
+		addr = readl(&regs->v_y0);
+	else
+		addr = readl(&regs->g_0);
+
+	switch (rotation) {
+	case 90:
+		break;
+	case 180:
+		addr += width * height * bpp - 1;
+		break;
+	case 270:
+		addr += height * (width - 1) * bpp;
+		break;
+	}
+	return addr;
+
+}
+
+static int __get_vdma_sz(struct pxa168fb_vdma_info *lcd_vdma, int vmode,
+		int rotation, int width, int height, int bpp)
+{
+	int src_pitch = lcd_pitch_read(lcd_vdma);
+
+	if (vmode == FB_VMODE_YUV422PACKED_IRE_90_270)
+		bpp = 2;
+	switch (rotation) {
+	case 0:
+	case 1:
+		return height << 16 | src_pitch;
+	case 90:
+		return width << 16 | height;
+	case 180:
+		return width | height << 16;
+	case 270:
+		return width << 16 | height;
+	}
+	return 0;
+
+}
+
+static int __get_vdma_pitch(struct pxa168fb_vdma_info *lcd_vdma, int vmode,
+		int rotation, int width, int height, int bpp)
+{
+	int src_bpp = bpp, src_pitch = lcd_pitch_read(lcd_vdma);
+
+	if (vmode == FB_VMODE_YUV422PACKED_IRE_90_270)
+		src_bpp = 2;
+	switch (rotation) {
+	case 0:
+	case 1:
+		return src_pitch | (width * bpp << 16);
+	case 90:
+		return (width * bpp) << 16 | (height * src_bpp);
+	case 180:
+		return width * src_bpp | (width * bpp << 16);
+	case 270:
+		return (width * bpp) << 16 | (height * src_bpp);
+	}
+	return 0;
+
+}
+
+static int __get_vdma_ctrl(struct pxa168fb_vdma_info *lcd_vdma,
+				int rotation, int line)
+{
+	if (!rotation || (rotation == 1))
+		return (line << 8) | 0xa1;
+	else
+		return (line << 8) | 0xa5;
+}
+
+static void pxa688_vdma_clkset(int en)
+{
+	if (en)
+		writel(readl(APMU_LCD2_CLK_RES_CTRL) | 0x11b,
+				APMU_LCD2_CLK_RES_CTRL);
+}
+
+static int pxa688_vdma_get_linenum(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	int mulfactor, lines, lines_exp;
+	int pitch = lcd_pitch_read(lcd_vdma);
+	int height = lcd_height_read(lcd_vdma);
+	int angle = lcd_vdma->rotation;
+
+	if (!pitch)
+		return 0;
+	if (!angle || (angle == 1))
+		/* no rotation */
+		mulfactor = 2;
+	else
+		mulfactor = 16;
+	lines = (lcd_vdma->sram_size / pitch)&(~(mulfactor-1));
+
+	if (lines < 2)
+		return 0; /* at least 2 lines*/
+	if (lines > 64)
+		lines = 64;
+
+	for (lines_exp = 0; lines_exp < lines; lines_exp += mulfactor) {
+		if (height%(lines-lines_exp) == 0)
+			break;
+	}
+	if (lines_exp >= lines)
+		return 32;
+	lines -= lines_exp;
+	pr_debug("lines %d lines_exp %d angle %d mulfactor %d height %d"
+		" pitch %d sram_size %d\n", lines, lines_exp, angle,
+		mulfactor, height, pitch, lcd_vdma->sram_size);
+	return lines;
+}
+
+static void pxa688_vdma_set(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	struct vdma_regs *vdma = (struct vdma_regs *)((u32)lcd_vdma->reg_base
+			+ VDMA_ARBR_CTRL);
+	struct vdma_ch_regs *vdma_ch = lcd_vdma->ch ? &vdma->ch2 : &vdma->ch1;
+	u32 psqu = lcd_vdma->sram_paddr;
+	unsigned int lines = lcd_vdma->vdma_lines;
+	int pix_fmt = lcd_vdma->pix_fmt;
+	int rotation = lcd_vdma->rotation;
+	unsigned format = lcd_vdma->yuv_format;
+	unsigned int reg, width, height, bpp;
+	FBVideoMode vmode;
+
+	if (lines < 2) {
+		pr_warn("%s lines = %d < 2???\n", __func__, lines);
+		return;
+	}
+
+	width = lcd_width_read(lcd_vdma);
+	height = lcd_height_read(lcd_vdma);
+	bpp = lcd_pitch_read(lcd_vdma) / width;
+	vmode = pixfmt_to_vmode(pix_fmt);
+	if (vmode < 0) {
+		pr_err("%s pix_fmt %d not supported\n", __func__, pix_fmt);
+		return;
+	}
+
+	if (!psqu) {
+		pxa688_vdma_release(lcd_vdma->path, lcd_vdma->vid);
+		return;
+	} else {
+		/* select video layer or graphics layer */
+		reg = readl(lcd_vdma->reg_base + LCD_PN2_SQULN2_CTRL);
+		if (lcd_vdma->vid)
+			reg |= 1 << (24 + lcd_vdma->path);
+		else
+			reg &= ~(1 << (24 + lcd_vdma->path));
+		writel(reg, lcd_vdma->reg_base + LCD_PN2_SQULN2_CTRL);
+	}
+	reg = (u32)psqu | ((lines/2-1)<<1 | 0x1);
+	writel(reg, lcd_vdma->reg_base + squln_ctrl(lcd_vdma->path));
+
+	pr_debug("%s psqu %x reg %x, width %d height %d bpp %d lines %d\n",
+		__func__, psqu, reg, width, height, bpp, lines);
+
+	/* src/dst addr */
+	reg = __get_vdma_sa(lcd_vdma, vmode, width, height, bpp, rotation);
+	writel(reg, &vdma_ch->src_addr);
+	writel((u32)psqu, &vdma_ch->dst_addr);
+
+	/* source size */
+	reg = __get_vdma_src_sz(lcd_vdma, vmode, width, height);
+	writel(reg, &vdma_ch->src_size);
+
+	/* size */
+	reg = __get_vdma_sz(lcd_vdma, vmode, rotation, width, height, bpp);
+	writel(reg, &vdma_ch->dst_size);
+
+	/* pitch */
+	reg = __get_vdma_pitch(lcd_vdma, vmode, rotation, width, height, bpp);
+	writel(reg, &vdma_ch->pitch);
+
+	/* rotation ctrl */
+	reg = __get_vdma_rot_ctrl(vmode, rotation, format);
+	writel(reg, &vdma_ch->rot_ctrl);
+
+	if (vmode == FB_VMODE_YUV422PACKED_SWAPYUorV && rotation == 180) {
+		reg = dma_ctrl_read(lcd_vdma->path, 0);
+		reg &= ~(0x1 << 2);
+		dma_ctrl_write(lcd_vdma->path, 0, reg);
+	}
+
+	/* control */
+	reg = __get_vdma_ctrl(lcd_vdma, rotation, lines);
+	writel(reg, &vdma_ch->ctrl);
+}
+
+static void vdma_sel_config(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	u32 reg = readl(lcd_vdma->reg_base + LCD_PN2_SQULN2_CTRL);
+
+	switch (lcd_vdma->path) {
+	case 0:
+		reg &= ~(1 << 30);
+		break;
+	case 1:
+		reg &= ~(1 << 31);
+		break;
+	case 2:
+		reg |= 1 << (lcd_vdma->ch ? 31 : 30);
+	default:
+		break;
+	}
+	writel(reg, lcd_vdma->reg_base + LCD_PN2_SQULN2_CTRL);
+}
+
+struct pxa168fb_vdma_info *request_vdma(int path, int vid)
+{
+	struct pxa168fb_vdma_info *vdma = 0;
+
+	if ((vdma0.path == path) && (vdma0.vid == vid) && vdma0.enable)
+		return &vdma0;
+	else if ((vdma1.path == path) && (vdma1.vid == vid) && vdma1.enable)
+		return &vdma1;
+
+	switch (path) {
+	case 0:
+		vdma = vdma0.enable ? 0 : &vdma0;
+		break;
+	case 1:
+		vdma = vdma1.enable ? 0 : &vdma1;
+		break;
+	case 2:
+		if (!vdma1.enable)
+			vdma = &vdma1;
+		else if (!vdma0.enable)
+			vdma = &vdma0;
+	default:
+		break;
+	}
+
+	if (vdma) {
+		vdma->path = path;
+		vdma->vid = vid;
+	}
+	return vdma;
+}
+
+void pxa688_vdma_config(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	pr_debug("%s path %d vid %d vdma_enable %d active %d\n",
+		__func__, lcd_vdma->path, lcd_vdma->vid,
+		lcd_vdma->enable, lcd_vdma->active);
+	if (lcd_vdma->enable && lcd_vdma->active) {
+		if (lcd_vdma->dma_on) {
+			lcd_vdma->vdma_lines = pxa688_vdma_get_linenum(lcd_vdma);
+			pxa688_vdma_set(lcd_vdma);
+		} else
+			pxa688_vdma_release(lcd_vdma->path, lcd_vdma->vid);
+	}
+}
+
+void pxa688_vdma_init(struct pxa168fb_vdma_info *lcd_vdma)
+{
+	struct pxa168fb_mach_info *mi = lcd_vdma->dev->platform_data;
+
+	if (mi->vdma_enable) {
+		lcd_vdma->sram_size = mi->sram_size;
+		lcd_vdma->sram_vaddr = (u32)sram_alloc("mmp-videosram",
+			mi->sram_size, (dma_addr_t *)&lcd_vdma->sram_paddr);
+		if (lcd_vdma->sram_paddr) {
+			vdma_sel_config(lcd_vdma);
+			lcd_vdma->enable = mi->vdma_enable;
+			pr_info("vdma enabled, sram_paddr 0x%x sram_size 0x%x\n",
+				lcd_vdma->sram_paddr, mi->sram_size);
+		} else
+			pr_warn("%s path %d vdma enable failed\n",
+				__func__, lcd_vdma->path);
+	} else if (!lcd_vdma->sram_size)
+		lcd_vdma->sram_size = mi->sram_size;
+
+	pxa688_vdma_clkset(1);
+}
+
+void pxa688_vdma_release(int path, int vid)
+{
+	struct pxa168fb_vdma_info *lcd_vdma = request_vdma(path, vid);
+	struct vdma_regs *vdma;
+	struct vdma_ch_regs *vdma_ch;
+	unsigned reg; /*, isr, current_time, irq_mask; */
+
+	if (!lcd_vdma)
+		return;
+
+	vdma = (struct vdma_regs *)((u32)lcd_vdma->reg_base
+			+ VDMA_ARBR_CTRL);
+	vdma_ch = lcd_vdma->ch ? &vdma->ch2 : &vdma->ch1;
+
+	if (!(vdma_ctrl_read(lcd_vdma) & 1))
+		return;
+#if 0
+	isr = readl(lcd_vdma->reg_base + SPU_IRQ_ISR);
+	if (lcd_vdma->ch == 0)
+		irq_mask = DMA_FRAME_IRQ0_MASK | DMA_FRAME_IRQ1_MASK;
+	else if (lcd_vdma->ch == 1)
+		irq_mask = TV_DMA_FRAME_IRQ0_MASK | TV_DMA_FRAME_IRQ1_MASK;
+	else
+		irq_mask = PN2_DMA_FRAME_IRQ0_MASK | PN2_DMA_FRAME_IRQ1_MASK;
+	irq_status_clear(lcd_vdma->ch, irq_mask);
+	current_time = jiffies;
+	while ((readl(lcd_vdma->reg_base + SPU_IRQ_ISR) &	irq_mask) == 0) {
+		if (jiffies_to_msecs(jiffies - current_time) > EOF_TIMEOUT) {
+			pr_err("EOF not detected !");
+			break;
+		}
+	}
+#endif
+
+	reg = readl(&vdma_ch->ctrl);
+	reg &= ~0xF;
+	writel(reg, &vdma_ch->ctrl);
+
+	/* disable squ access */
+	reg = readl(lcd_vdma->reg_base + squln_ctrl(lcd_vdma->path));
+	reg &= (~0x1);
+	writel(reg, lcd_vdma->reg_base + squln_ctrl(lcd_vdma->path));
+#ifdef CONFIG_PXA688_MISC
+	if (lcd_vdma->path == fb_vsmooth && (gfx_vsmooth || vid_vsmooth))
+		writel(reg, lcd_vdma->reg_base + squln_ctrl(fb_filter));
+#endif
+	printk(KERN_DEBUG "%s path %d squln_ctrl %x\n", __func__, lcd_vdma->path,
+		readl(lcd_vdma->reg_base + squln_ctrl(lcd_vdma->path)));
+}
+
+int pxa688_vdma_en(struct pxa168fb_vdma_info *lcd_vdma, int enable, int vid)
+{
+	u32 reg;
+	unsigned long flags = 0;
+
+	if ((lcd_vdma->path == 1) && enable) {
+		reg = dma_ctrl_read(lcd_vdma->path, 1);
+		if (reg & (CFG_TV_INTERLACE_EN | CFG_TV_NIB))
+			return -EFAULT;
+	}
+
+	if (enable) {
+		if ((lcd_vdma->enable) && (lcd_vdma->vid == vid))
+			return 0;
+		reg = readl(lcd_vdma->reg_base + squln_ctrl(lcd_vdma->path));
+		if ((reg & 0x1) || lcd_vdma->enable) {
+			pr_warn("%s vdma has been enabled for"
+				" another layer\n", __func__);
+			return -EINVAL;
+		}
+		vdma_sel_config(lcd_vdma);
+
+		lcd_vdma->sram_vaddr = (u32)sram_alloc("mmp-videosram",
+			lcd_vdma->sram_size, (dma_addr_t *)&lcd_vdma->sram_paddr);
+		if (lcd_vdma->sram_paddr) {
+			lcd_vdma->vid = vid;
+			lcd_vdma->enable = 1;
+		} else {
+			pr_warn("%s path %d vdma enable failed\n",
+				__func__, lcd_vdma->path);
+			return -EFAULT;
+		}
+	} else {
+		if (!lcd_vdma->enable || (lcd_vdma->vid != vid))
+			return 0;
+		spin_lock_irqsave(&ctrl_lock, flags);
+		pxa688_vdma_release(lcd_vdma->path, lcd_vdma->vid);
+		lcd_vdma->enable = 0;
+		spin_unlock_irqrestore(&ctrl_lock, flags);
+		sram_free("mmp-videosram",
+			(dma_addr_t *)lcd_vdma->sram_vaddr, lcd_vdma->sram_size);
+		lcd_vdma->sram_paddr = 0;
+		lcd_vdma->sram_vaddr = 0;
+	}
+
+	pr_debug("path %d %s layer, vdma %d %s, sram size:0x%x, vaddr:0x%x, paddr:0x%x\n",
+		lcd_vdma->path, lcd_vdma->vid ? "vid" : "gfx",
+		lcd_vdma->ch, lcd_vdma->enable ? "enabled" : "disabled",
+		lcd_vdma->sram_size, lcd_vdma->sram_vaddr, lcd_vdma->sram_paddr);
+	return 0;
+}
+
+static ssize_t vdma_help(char *buf)
+{
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "commands:\n");
+	mvdisp_dump(f, " - dump VDMA configuration, registers\n");
+	mvdisp_dump(f, "\tcat vdma\n");
+	mvdisp_dump(f, " - enable[1]/disable[0] vdma for path(pn/tv/pn2:"
+			"[0/1/2]) graphics/video[0/1] layer\n");
+	mvdisp_dump(f, "\techo e [path:0/1/2] [layer:0/1]"
+			" [en/dis:1/0] > vdma\n");
+	mvdisp_dump(f, " - configure vdma channel sram size with KB unit\n");
+	mvdisp_dump(f, "\techo s [vdma_ch0_size](KB)"
+			" [vdma_ch1_size](KB) > vdma\n");
+
+	return s;
+}
+
+ssize_t vdma_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct pxa168fb_info *fbi = dev_get_drvdata(dev);
+	struct vdma_regs *vdma = (struct vdma_regs *)((u32)fbi->reg_base
+			+ VDMA_ARBR_CTRL);
+	int s = 0, f = DUMP_SPRINTF;
+
+	mvdisp_dump(f, "vdma0:\n");
+	mvdisp_dump(f, "\tlcd_vdma->ch:     %d\n", vdma0.ch);
+	mvdisp_dump(f, "\tlcd_vdma->path:   %d\n", vdma0.path);
+	mvdisp_dump(f, "\tlcd_vdma->vid:    %d\n", vdma0.vid);
+	mvdisp_dump(f, "\tlcd_vdma->enable: %d\n", vdma0.enable);
+	mvdisp_dump(f, "\tvdma_lines        %d\n", vdma0.vdma_lines);
+	mvdisp_dump(f, "\tsram_paddr        0x%x\n", vdma0.sram_paddr);
+	mvdisp_dump(f, "\tsram_size         %dKB\n", vdma0.sram_size/1024);
+
+	mvdisp_dump(f, "vdma1:\n");
+	mvdisp_dump(f, "\tlcd_vdma->ch:     %d\n", vdma1.ch);
+	mvdisp_dump(f, "\tlcd_vdma->path:   %d\n", vdma1.path);
+	mvdisp_dump(f, "\tlcd_vdma->vid:    %d\n", vdma1.vid);
+	mvdisp_dump(f, "\tlcd_vdma->enable: %d\n", vdma1.enable);
+	mvdisp_dump(f, "\tvdma_lines     %d\n", vdma1.vdma_lines);
+	mvdisp_dump(f, "\tsram_paddr     0x%x\n", vdma1.sram_paddr);
+	mvdisp_dump(f, "\tsram_size      %dKB\n", vdma1.sram_size/1024);
+
+	mvdisp_dump(f, "\nregister base: 0x%p\n", fbi->reg_base);
+	mvdisp_dump(f, "\tarbr_ctr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->arbr_ctr)&0xfff, readl(&vdma->arbr_ctr));
+	mvdisp_dump(f, "\tirq_raw        (@%3x):\t0x%x\n",
+		 (int)(&vdma->irq_raw)&0xfff, readl(&vdma->irq_raw));
+	mvdisp_dump(f, "\tirq_mask       (@%3x):\t0x%x\n",
+		 (int)(&vdma->irq_mask)&0xfff, readl(&vdma->irq_mask));
+	mvdisp_dump(f, "\tirq_status     (@%3x):\t0x%x\n",
+		 (int)(&vdma->irq_status)&0xfff, readl(&vdma->irq_status));
+	mvdisp_dump(f, "\tmdma_arbr_ctrl (@%3x):\t0x%x\n",
+	 (int)(&vdma->mdma_arbr_ctrl)&0xfff, readl(&vdma->mdma_arbr_ctrl));
+
+	mvdisp_dump(f, "  channel 1\n");
+	mvdisp_dump(f, "\tdc_saddr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.dc_saddr)&0xfff, readl(&vdma->ch1.dc_saddr));
+	mvdisp_dump(f, "\tdc_size        (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.dc_size)&0xfff, readl(&vdma->ch1.dc_size));
+	mvdisp_dump(f, "\tctrl           (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.ctrl)&0xfff, readl(&vdma->ch1.ctrl));
+	mvdisp_dump(f, "\tsrc_size       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.src_size)&0xfff, readl(&vdma->ch1.src_size));
+	mvdisp_dump(f, "\tsrc_addr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.src_addr)&0xfff, readl(&vdma->ch1.src_addr));
+	mvdisp_dump(f, "\tdst_addr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.dst_addr)&0xfff, readl(&vdma->ch1.dst_addr));
+	mvdisp_dump(f, "\tdst_size       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.dst_size)&0xfff, readl(&vdma->ch1.dst_size));
+	mvdisp_dump(f, "\tpitch          (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.pitch)&0xfff, readl(&vdma->ch1.pitch));
+	mvdisp_dump(f, "\trot_ctrl       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch1.rot_ctrl)&0xfff, readl(&vdma->ch1.rot_ctrl));
+	mvdisp_dump(f, "\tram_ctrl0      (@%3x):\t0x%x\n",
+	 (int)(&vdma->ch1.ram_ctrl0)&0xfff, readl(&vdma->ch1.ram_ctrl0));
+	mvdisp_dump(f, "\tram_ctrl1      (@%3x):\t0x%x\n",
+	 (int)(&vdma->ch1.ram_ctrl1)&0xfff, readl(&vdma->ch1.ram_ctrl1));
+
+	mvdisp_dump(f, "  channel 2\n");
+	mvdisp_dump(f, "\tdc_saddr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.dc_saddr)&0xfff, readl(&vdma->ch2.dc_saddr));
+	mvdisp_dump(f, "\tdc_size        (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.dc_size)&0xfff, readl(&vdma->ch2.dc_size));
+	mvdisp_dump(f, "\tctrl           (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.ctrl)&0xfff, readl(&vdma->ch2.ctrl));
+	mvdisp_dump(f, "\tsrc_size       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.src_size)&0xfff, readl(&vdma->ch2.src_size));
+	mvdisp_dump(f, "\tsrc_addr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.src_addr)&0xfff, readl(&vdma->ch2.src_addr));
+	mvdisp_dump(f, "\tdst_addr       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.dst_addr)&0xfff, readl(&vdma->ch2.dst_addr));
+	mvdisp_dump(f, "\tdst_size       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.dst_size)&0xfff, readl(&vdma->ch2.dst_size));
+	mvdisp_dump(f, "\tpitch          (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.pitch)&0xfff, readl(&vdma->ch2.pitch));
+	mvdisp_dump(f, "\trot_ctrl       (@%3x):\t0x%x\n",
+		 (int)(&vdma->ch2.rot_ctrl)&0xfff, readl(&vdma->ch2.rot_ctrl));
+	mvdisp_dump(f, "\tram_ctrl0      (@%3x):\t0x%x\n",
+	 (int)(&vdma->ch2.ram_ctrl0)&0xfff, readl(&vdma->ch2.ram_ctrl0));
+	mvdisp_dump(f, "\tram_ctrl1      (@%3x):\t0x%x\n",
+	 (int)(&vdma->ch2.ram_ctrl1)&0xfff, readl(&vdma->ch2.ram_ctrl1));
+
+	mvdisp_dump(f, "  display controller related\n");
+	mvdisp_dump(f, "\tsquln_ctrl     (@%3x):\t0x%x\n",
+		 (int)(fbi->reg_base + squln_ctrl(fbi->id))&0xfff,
+		 readl(fbi->reg_base + squln_ctrl(fbi->id)));
+	mvdisp_dump(f, "\tpn2_squln2_ctrl(@%3x):\t0x%x\n\n",
+		 (int)(fbi->reg_base + LCD_PN2_SQULN2_CTRL)&0xfff,
+		 readl(fbi->reg_base + LCD_PN2_SQULN2_CTRL));
+
+	s += vdma_help(buf + s);
+
+	return s;
+}
+
+#define MMP2_VDMA_SIZE 90
+#define MMP3_VDMA_SIZE 64
+ssize_t vdma_store(
+		struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct pxa168fb_vdma_info *lcd_vdma = 0;
+	unsigned int path, vid, enable, tmp0, tmp1;
+	char vol[10];
+
+	if ('s' == buf[0]) {
+		if (vdma0.enable || vdma1.enable) {
+			pr_err("vdma must disabled first before set size\n");
+			return size;
+		}
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u", &tmp0, &tmp1) != 2) {
+			pr_err("vdma sram size setting cmd should be like: "
+				"s [vdma_ch0_size](KB) [vdma_ch1_size](KB)\n");
+			return size;
+		}
+#ifdef CONFIG_CPU_MMP2
+		if ((tmp0 + tmp1) > MMP2_VDMA_SIZE) {
+#endif
+#ifdef CONFIG_CPU_MMP3
+		if ((tmp0 + tmp1) > MMP3_VDMA_SIZE) {
+#endif
+			pr_err("size exceed the max size of video sram\n");
+			return size;
+		}
+		vdma0.sram_size = tmp0 * 1024;
+		vdma1.sram_size = tmp1 * 1024;
+		pr_info("vdma0 size 0x%x, vdma1 size 0x%x\n",
+			vdma0.sram_size, vdma1.sram_size);
+	} else if ('e' == buf[0]) {
+		memcpy(vol, (void *)((u32)buf + 1), size - 1);
+		if (sscanf(vol, "%u %u %u", &path,
+			&vid, &enable) != 3) {
+			pr_err("enable/disable vdma cmd should be like: "
+				"e [0/1/2](pn/tv/pn2 path) [0/1](graphics/"
+				"video layer) [1/0](enable/disable)\n");
+			return size;
+		}
+		lcd_vdma = request_vdma(path, vid);
+		if (!lcd_vdma) {
+			if (enable)
+				pr_err("request fail, vdma is occupied!\n");
+			return size;
+		}
+		if (!lcd_vdma->sram_size && enable) {
+			pr_err("ERR: SRAM size is 0KB!!!!\n");
+			return size;
+		}
+		pxa688_vdma_en(lcd_vdma, enable, vid);
+	}
+
+	return size;
+}
+DEVICE_ATTR(vdma, S_IRUGO | S_IWUSR, vdma_show, vdma_store);
+#endif
-- 
1.7.5.4

