From 22ffced7493b54147029698a5cc2ab3a73289f8f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 4 Sep 2013 13:59:29 +0800
Subject: [PATCH 51/60] input: tsc2007: add support for QSEVEN by gpio

Original patches come from M5.3.12.5.4_sources.
wake up from d2 state. patch will also address issue
of touch screen hang during bootup time touches by adding
write fifo empty isr in i2c and powerdown mode in touch
driver.

Signed-off-by: dipen <dpatel@marvell.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/input/touchscreen/tsc2007.c |  263 ++++++++++++++++++++--------------
 1 files changed, 155 insertions(+), 108 deletions(-)

diff --git a/drivers/input/touchscreen/tsc2007.c b/drivers/input/touchscreen/tsc2007.c
index 1473d23..c8b49a9 100644
--- a/drivers/input/touchscreen/tsc2007.c
+++ b/drivers/input/touchscreen/tsc2007.c
@@ -26,6 +26,9 @@
 #include <linux/interrupt.h>
 #include <linux/i2c.h>
 #include <linux/i2c/tsc2007.h>
+#include <linux/pm_wakeup.h>
+#include <linux/pm.h>
+#include <plat/mfp.h>
 
 #define TSC2007_MEASURE_TEMP0		(0x0 << 4)
 #define TSC2007_MEASURE_AUX		(0x2 << 4)
@@ -57,6 +60,8 @@
 #define READ_X		(ADC_ON_12BIT | TSC2007_MEASURE_X)
 #define PWRDOWN		(TSC2007_12BIT | TSC2007_POWER_OFF_IRQ_EN)
 
+static bool wake_en;
+
 struct ts_event {
 	u16	x;
 	u16	y;
@@ -66,6 +71,7 @@ struct ts_event {
 struct tsc2007 {
 	struct input_dev	*input;
 	char			phys[32];
+	struct delayed_work	work;
 
 	struct i2c_client	*client;
 
@@ -75,11 +81,9 @@ struct tsc2007 {
 	unsigned long		poll_delay;
 	unsigned long		poll_period;
 
+	bool			pendown;
 	int			irq;
 
-	wait_queue_head_t	wait;
-	bool			stopped;
-
 	int			(*get_pendown_state)(void);
 	void			(*clear_penirq)(void);
 };
@@ -108,6 +112,7 @@ static inline int tsc2007_xfer(struct tsc2007 *tsc, u8 cmd)
 
 static void tsc2007_read_values(struct tsc2007 *tsc, struct ts_event *tc)
 {
+	tsc2007_xfer(tsc, PWRDOWN);
 	/* y- still on; turn on only y+ (and ADC) */
 	tc->y = tsc2007_xfer(tsc, READ_Y);
 
@@ -142,8 +147,25 @@ static u32 tsc2007_calculate_pressure(struct tsc2007 *tsc, struct ts_event *tc)
 	return rt;
 }
 
-static bool tsc2007_is_pen_down(struct tsc2007 *ts)
+static void tsc2007_send_up_event(struct tsc2007 *tsc)
+{
+	struct input_dev *input = tsc->input;
+
+	dev_dbg(&tsc->client->dev, "UP\n");
+
+	input_report_key(input, BTN_TOUCH, 0);
+	input_report_abs(input, ABS_PRESSURE, 0);
+	input_sync(input);
+}
+
+static void tsc2007_work(struct work_struct *work)
 {
+	struct tsc2007 *ts =
+		container_of(to_delayed_work(work), struct tsc2007, work);
+	bool debounced = false;
+	struct ts_event tc;
+	u32 rt;
+
 	/*
 	 * NOTE: We can't rely on the pressure to determine the pen down
 	 * state, even though this controller has a pressure sensor.
@@ -154,82 +176,81 @@ static bool tsc2007_is_pen_down(struct tsc2007 *ts)
 	 * The only safe way to check for the pen up condition is in the
 	 * work function by reading the pen signal state (it's a GPIO
 	 * and IRQ). Unfortunately such callback is not always available,
-	 * in that case we assume that the pen is down and expect caller
-	 * to fall back on the pressure reading.
+	 * in that case we have rely on the pressure anyway.
 	 */
+	if (ts->get_pendown_state) {
+		if (unlikely(!ts->get_pendown_state())) {
+			tsc2007_send_up_event(ts);
+			ts->pendown = false;
+			goto out;
+		}
 
-	if (!ts->get_pendown_state)
-		return true;
-
-	return ts->get_pendown_state();
-}
-
-static irqreturn_t tsc2007_soft_irq(int irq, void *handle)
-{
-	struct tsc2007 *ts = handle;
-	struct input_dev *input = ts->input;
-	struct ts_event tc;
-	u32 rt;
+		dev_dbg(&ts->client->dev, "pen is still down\n");
+	}
 
-	while (!ts->stopped && tsc2007_is_pen_down(ts)) {
+	disable_irq(ts->irq);
+	tsc2007_read_values(ts, &tc);
+	enable_irq(ts->irq);
 
-		/* pen is down, continue with the measurement */
-		tsc2007_read_values(ts, &tc);
+	rt = tsc2007_calculate_pressure(ts, &tc);
+	if (rt > ts->max_rt) {
+		/*
+		 * Sample found inconsistent by debouncing or pressure is
+		 * beyond the maximum. Don't report it to user space,
+		 * repeat at least once more the measurement.
+		 */
+		dev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);
+		debounced = true;
+		goto out;
 
-		rt = tsc2007_calculate_pressure(ts, &tc);
+	}
 
-		if (rt == 0 && !ts->get_pendown_state) {
-			/*
-			 * If pressure reported is 0 and we don't have
-			 * callback to check pendown state, we have to
-			 * assume that pen was lifted up.
-			 */
-			break;
-		}
+	if (rt) {
+		struct input_dev *input = ts->input;
 
-		if (rt <= ts->max_rt) {
-			dev_dbg(&ts->client->dev,
-				"DOWN point(%4d,%4d), pressure (%4u)\n",
-				tc.x, tc.y, rt);
+		if (!ts->pendown) {
+			dev_dbg(&ts->client->dev, "DOWN\n");
 
 			input_report_key(input, BTN_TOUCH, 1);
-			input_report_abs(input, ABS_X, tc.x);
-			input_report_abs(input, ABS_Y, tc.y);
-			input_report_abs(input, ABS_PRESSURE, rt);
-
-			input_sync(input);
-
-		} else {
-			/*
-			 * Sample found inconsistent by debouncing or pressure is
-			 * beyond the maximum. Don't report it to user space,
-			 * repeat at least once more the measurement.
-			 */
-			dev_dbg(&ts->client->dev, "ignored pressure %d\n", rt);
+			ts->pendown = true;
 		}
 
-		wait_event_timeout(ts->wait, ts->stopped,
-				   msecs_to_jiffies(ts->poll_period));
-	}
+		input_report_abs(input, ABS_X, tc.x);
+		input_report_abs(input, ABS_Y, tc.y);
+		input_report_abs(input, ABS_PRESSURE, rt);
 
-	dev_dbg(&ts->client->dev, "UP\n");
+		input_sync(input);
 
-	input_report_key(input, BTN_TOUCH, 0);
-	input_report_abs(input, ABS_PRESSURE, 0);
-	input_sync(input);
+		dev_dbg(&ts->client->dev, "point(%4d,%4d), pressure (%4u)\n",
+			tc.x, tc.y, rt);
 
-	if (ts->clear_penirq)
-		ts->clear_penirq();
+	} else if (!ts->get_pendown_state && ts->pendown) {
+		/*
+		 * We don't have callback to check pendown state, so we
+		 * have to assume that since pressure reported is 0 the
+		 * pen was lifted up.
+		 */
+		tsc2007_send_up_event(ts);
+		ts->pendown = false;
+	}
 
-	return IRQ_HANDLED;
+ out:
+	if (ts->pendown || debounced)
+		schedule_delayed_work(&ts->work,
+				      msecs_to_jiffies(ts->poll_period));
+	else
+		enable_irq(ts->irq);
 }
 
-static irqreturn_t tsc2007_hard_irq(int irq, void *handle)
+static irqreturn_t tsc2007_irq(int irq, void *handle)
 {
 	struct tsc2007 *ts = handle;
 
-	if (!ts->get_pendown_state || likely(ts->get_pendown_state()))
-		return IRQ_WAKE_THREAD;
+	if (!ts->get_pendown_state || likely(ts->get_pendown_state())) {
+		disable_irq_nosync(ts->irq);
+		schedule_delayed_work(&ts->work,
+				      msecs_to_jiffies(ts->poll_delay));
+	}
 
 	if (ts->clear_penirq)
 		ts->clear_penirq();
@@ -237,40 +258,17 @@ static irqreturn_t tsc2007_hard_irq(int irq, void *handle)
 	return IRQ_HANDLED;
 }
 
-static void tsc2007_stop(struct tsc2007 *ts)
-{
-	ts->stopped = true;
-	mb();
-	wake_up(&ts->wait);
-
-	disable_irq(ts->irq);
-}
-
-static int tsc2007_open(struct input_dev *input_dev)
+static void tsc2007_free_irq(struct tsc2007 *ts)
 {
-	struct tsc2007 *ts = input_get_drvdata(input_dev);
-	int err;
-
-	ts->stopped = false;
-	mb();
-
-	enable_irq(ts->irq);
-
-	/* Prepare for touch readings - power down ADC and enable PENIRQ */
-	err = tsc2007_xfer(ts, PWRDOWN);
-	if (err < 0) {
-		tsc2007_stop(ts);
-		return err;
+	free_irq(ts->irq, ts);
+	if (cancel_delayed_work_sync(&ts->work)) {
+		/*
+		 * Work was pending, therefore we need to enable
+		 * IRQ here to balance the disable_irq() done in the
+		 * interrupt handler.
+		 */
+		enable_irq(ts->irq);
 	}
-
-	return 0;
-}
-
-static void tsc2007_close(struct input_dev *input_dev)
-{
-	struct tsc2007 *ts = input_get_drvdata(input_dev);
-
-	tsc2007_stop(ts);
 }
 
 static int __devinit tsc2007_probe(struct i2c_client *client,
@@ -300,7 +298,7 @@ static int __devinit tsc2007_probe(struct i2c_client *client,
 	ts->client = client;
 	ts->irq = client->irq;
 	ts->input = input_dev;
-	init_waitqueue_head(&ts->wait);
+	INIT_DELAYED_WORK(&ts->work, tsc2007_work);
 
 	ts->model             = pdata->model;
 	ts->x_plate_ohms      = pdata->x_plate_ohms;
@@ -310,23 +308,19 @@ static int __devinit tsc2007_probe(struct i2c_client *client,
 	ts->get_pendown_state = pdata->get_pendown_state;
 	ts->clear_penirq      = pdata->clear_penirq;
 
+#ifndef CONFIG_MACH_QSEVEN
 	if (pdata->x_plate_ohms == 0) {
 		dev_err(&client->dev, "x_plate_ohms is not set up in platform data");
 		err = -EINVAL;
 		goto err_free_mem;
 	}
-
+#endif
 	snprintf(ts->phys, sizeof(ts->phys),
 		 "%s/input0", dev_name(&client->dev));
 
 	input_dev->name = "TSC2007 Touchscreen";
-	input_dev->phys = ts->phys;
-	input_dev->id.bustype = BUS_I2C;
-
-	input_dev->open = tsc2007_open;
-	input_dev->close = tsc2007_close;
-
-	input_set_drvdata(input_dev, ts);
+	input_dev->phys = "tsc2007/input0";
+	input_dev->dev.parent = &client->dev;
 
 	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
 	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
@@ -339,14 +333,23 @@ static int __devinit tsc2007_probe(struct i2c_client *client,
 	if (pdata->init_platform_hw)
 		pdata->init_platform_hw();
 
-	err = request_threaded_irq(ts->irq, tsc2007_hard_irq, tsc2007_soft_irq,
-				   IRQF_ONESHOT, client->dev.driver->name, ts);
+	err = request_irq(ts->irq, tsc2007_irq, IRQF_TRIGGER_FALLING,
+			client->dev.driver->name, ts);
 	if (err < 0) {
 		dev_err(&client->dev, "irq %d busy?\n", ts->irq);
 		goto err_free_mem;
 	}
-
-	tsc2007_stop(ts);
+#ifdef CONFIG_MACH_QSEVEN
+	err = device_init_wakeup(&client->dev, 1);
+	if (err < 0) {
+		pr_info("Touch screen did not init as wake up source......\n");
+		goto err_free_mem;
+	}
+#endif
+	/* Prepare for touch readings - power down ADC and enable PENIRQ */
+	err = tsc2007_xfer(ts, PWRDOWN);
+	if (err < 0)
+		goto err_free_irq;
 
 	err = input_register_device(input_dev);
 	if (err)
@@ -357,7 +360,7 @@ static int __devinit tsc2007_probe(struct i2c_client *client,
 	return 0;
 
  err_free_irq:
-	free_irq(ts->irq, ts);
+	tsc2007_free_irq(ts);
 	if (pdata->exit_platform_hw)
 		pdata->exit_platform_hw();
  err_free_mem:
@@ -371,7 +374,7 @@ static int __devexit tsc2007_remove(struct i2c_client *client)
 	struct tsc2007	*ts = i2c_get_clientdata(client);
 	struct tsc2007_platform_data *pdata = client->dev.platform_data;
 
-	free_irq(ts->irq, ts);
+	tsc2007_free_irq(ts);
 
 	if (pdata->exit_platform_hw)
 		pdata->exit_platform_hw();
@@ -389,10 +392,54 @@ static const struct i2c_device_id tsc2007_idtable[] = {
 
 MODULE_DEVICE_TABLE(i2c, tsc2007_idtable);
 
+#ifdef CONFIG_PM
+static int tsc2007_suspend(struct device *dev)
+{
+	pr_info("Touch screen is going to suspend....\n");
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsc2007 *ts = i2c_get_clientdata(client);
+
+#ifdef CONFIG_MACH_QSEVEN
+	if (device_may_wakeup(&client->dev) && !wake_en) {
+		if (enable_irq_wake(ts->irq) == 0) {
+			unsigned long val = 0;
+			val = MFPR_SLEEP_OE_N
+				| MFPR_EDGE_FALL_EN | MFPR_SLEEP_SEL;
+			lpm_mfpr_edge_detect_config(MFP_PIN_GPIO78, val);
+			pr_info("Touch screen irq is set as wake up source\n");
+			wake_en = true;
+		} else
+			dev_err(&client->dev, "enable_irq_wake failed\n");
+	}
+#endif
+	return 0;
+}
+static int tsc2007_resume(struct device *dev)
+{
+	pr_info("Touch screen is going to resume....\n");
+	struct i2c_client *client = to_i2c_client(dev);
+	struct tsc2007 *ts = i2c_get_clientdata(client);
+#ifdef CONFIG_MACH_QSEVEN
+	if (device_may_wakeup(&client->dev) && wake_en) {
+		disable_irq_wake(ts->irq);
+		lpm_mfpr_edge_detect_clear_config(MFP_PIN_GPIO78);
+		pr_info("Touch screen irq is disbled as wake up source");
+		wake_en = false;
+	}
+#endif
+	return 0;
+}
+static SIMPLE_DEV_PM_OPS(tsc2007_pm, tsc2007_suspend, tsc2007_resume);
+#endif
+
 static struct i2c_driver tsc2007_driver = {
 	.driver = {
 		.owner	= THIS_MODULE,
-		.name	= "tsc2007"
+		.name	= "tsc2007",
+#ifdef CONFIG_PM
+		.pm	= &tsc2007_pm,
+#endif
+
 	},
 	.id_table	= tsc2007_idtable,
 	.probe		= tsc2007_probe,
-- 
1.7.5.4

