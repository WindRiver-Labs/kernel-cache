From 3d0feddb5e911b4b09368be546992aaad8c93c40 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 28 Aug 2013 15:05:29 +0800
Subject: [PATCH 1/2] bluetooth: sdio: Add sdio bluetooth driver support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31.

Singed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/bluetooth/Kconfig              |    3 +
 drivers/bluetooth/Makefile             |    1 +
 drivers/bluetooth/marvell/Kconfig      |   13 +
 drivers/bluetooth/marvell/Makefile     |   37 +
 drivers/bluetooth/marvell/bt_drv.h     |  608 ++++++++++++
 drivers/bluetooth/marvell/bt_init.c    |  410 ++++++++
 drivers/bluetooth/marvell/bt_main.c    | 1407 +++++++++++++++++++++++++++
 drivers/bluetooth/marvell/bt_proc.c    |  634 +++++++++++++
 drivers/bluetooth/marvell/bt_sdio.h    |  248 +++++
 drivers/bluetooth/marvell/bt_sdiommc.c | 1617 ++++++++++++++++++++++++++++++++
 drivers/bluetooth/marvell/include.h    |   47 +
 11 files changed, 5025 insertions(+), 0 deletions(-)
 create mode 100644 drivers/bluetooth/marvell/Kconfig
 create mode 100644 drivers/bluetooth/marvell/Makefile
 create mode 100644 drivers/bluetooth/marvell/bt_drv.h
 create mode 100644 drivers/bluetooth/marvell/bt_init.c
 create mode 100644 drivers/bluetooth/marvell/bt_main.c
 create mode 100644 drivers/bluetooth/marvell/bt_proc.c
 create mode 100644 drivers/bluetooth/marvell/bt_sdio.h
 create mode 100644 drivers/bluetooth/marvell/bt_sdiommc.c
 create mode 100644 drivers/bluetooth/marvell/include.h

diff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig
index 5ccf142..b8b7da4 100644
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@ -229,4 +229,7 @@ config BT_WILINK
 
 	  Say Y here to compile support for Texas Instrument's WiLink7 driver
 	  into the kernel or say M to compile it as module.
+
+source "drivers/bluetooth/marvell/Kconfig"
+
 endmenu
diff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile
index f4460f4..6b328c7 100644
--- a/drivers/bluetooth/Makefile
+++ b/drivers/bluetooth/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_BT_ATH3K)		+= ath3k.o
 obj-$(CONFIG_BT_MRVL)		+= btmrvl.o
 obj-$(CONFIG_BT_MRVL_SDIO)	+= btmrvl_sdio.o
 obj-$(CONFIG_BT_WILINK)		+= btwilink.o
+obj-$(CONFIG_BT_MARVELL_SDIO)	+= marvell/
 
 btmrvl-y			:= btmrvl_main.o
 btmrvl-$(CONFIG_DEBUG_FS)	+= btmrvl_debugfs.o
diff --git a/drivers/bluetooth/marvell/Kconfig b/drivers/bluetooth/marvell/Kconfig
new file mode 100644
index 0000000..658b6e5
--- /dev/null
+++ b/drivers/bluetooth/marvell/Kconfig
@@ -0,0 +1,13 @@
+config BT_MARVELL_SDIO
+        tristate "Marvell BT-over-SDIO driver"
+        depends on MMC
+        select FW_LOADER
+        help
+          The driver for Marvell Bluetooth chipsets with SDIO interface.
+
+          This driver is required if you want to use Marvell Bluetooth
+          devices with SDIO interface. Currently SD8688/SD8787/SD8797
+          chipsets are supported.
+
+          Say Y here to compile support for Marvell BT-over-SDIO driver
+          into the kernel or say M to compile it as module.
diff --git a/drivers/bluetooth/marvell/Makefile b/drivers/bluetooth/marvell/Makefile
new file mode 100644
index 0000000..1465045
--- /dev/null
+++ b/drivers/bluetooth/marvell/Makefile
@@ -0,0 +1,37 @@
+# File: Makefile
+# Copyright (C) 2007-2012, Marvell International Ltd.
+#############################################################################
+# Compiler Flags
+#############################################################################
+	EXTRA_CFLAGS += -DFPNUM='"66"'
+
+ifeq ($(CONFIG_DEBUG),1)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+endif
+
+ifeq ($(CONFIG_DEBUG),2)
+	EXTRA_CFLAGS += -DDEBUG_LEVEL1
+	EXTRA_CFLAGS += -DDEBUG_LEVEL2
+	DBG=	-dbg
+endif
+
+ifeq ($(CONFIG_SDIO_SUSPEND_RESUME),y)
+	EXTRA_CFLAGS += -DSDIO_SUSPEND_RESUME
+endif
+
+#############################################################################
+# Make Targets
+#############################################################################
+
+ifneq ($(KERNELRELEASE),)
+
+BTOBJS = bt_main.o bt_sdiommc.o bt_proc.o bt_init.o
+
+bt8xxx-objs := $(BTOBJS)
+obj-$(CONFIG_BT_MARVELL_SDIO) += bt8xxx.o
+
+# Otherwise we were called directly from the command line; invoke the kernel build system.
+else
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+endif
diff --git a/drivers/bluetooth/marvell/bt_drv.h b/drivers/bluetooth/marvell/bt_drv.h
new file mode 100644
index 0000000..3b68d1e
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_drv.h
@@ -0,0 +1,608 @@
+/** @file bt_drv.h
+ *  @brief This header file contains global constant/enum definitions,
+ *  global variable declaration.
+ *       
+ *  Copyright (C) 2007-2011, Marvell International Ltd.
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_DRV_H_
+#define _BT_DRV_H_
+
+#ifndef BIT
+/** BIT definition */
+#define BIT(x) (1UL << (x))
+#endif
+
+/** Debug level : Message */
+#define	DBG_MSG			BIT(0)
+/** Debug level : Fatal */
+#define DBG_FATAL		BIT(1)
+/** Debug level : Error */
+#define DBG_ERROR		BIT(2)
+/** Debug level : Data */
+#define DBG_DATA		BIT(3)
+/** Debug level : Command */
+#define DBG_CMD			BIT(4)
+/** Debug level : Event */
+#define DBG_EVENT		BIT(5)
+/** Debug level : Interrupt */
+#define DBG_INTR		BIT(6)
+
+/** Debug entry : Data dump */
+#define DBG_DAT_D		BIT(16)
+/** Debug entry : Data dump */
+#define DBG_CMD_D		BIT(17)
+
+/** Debug level : Entry */
+#define DBG_ENTRY		BIT(28)
+/** Debug level : Warning */
+#define DBG_WARN		BIT(29)
+/** Debug level : Informative */
+#define DBG_INFO		BIT(30)
+
+#ifdef	DEBUG_LEVEL1
+extern ulong drvdbg;
+
+#ifdef  DEBUG_LEVEL2
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  do {if (drvdbg & DBG_INFO)  printk(KERN_DEBUG msg);} while(0)
+/** Print warning message */
+#define	PRINTM_WARN(msg...)  do {if (drvdbg & DBG_WARN)  printk(KERN_DEBUG msg);} while(0)
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) do {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);} while(0)
+#else
+/** Print informative message */
+#define	PRINTM_INFO(msg...)  do {} while(0)
+/** Print warning message */
+#define	PRINTM_WARN(msg...)  do {} while(0)
+/** Print entry message */
+#define	PRINTM_ENTRY(msg...) do {} while(0)
+#endif /* DEBUG_LEVEL2 */
+
+/** Print interrupt message */
+#define	PRINTM_INTR(msg...)  do {if (drvdbg & DBG_INTR)  printk(KERN_DEBUG msg);} while(0)
+/** Print event message */
+#define	PRINTM_EVENT(msg...) do {if (drvdbg & DBG_EVENT) printk(KERN_DEBUG msg);} while(0)
+/** Print command message */
+#define	PRINTM_CMD(msg...)   do {if (drvdbg & DBG_CMD)   printk(KERN_DEBUG msg);} while(0)
+/** Print data message */
+#define	PRINTM_DATA(msg...)  do {if (drvdbg & DBG_DATA)  printk(KERN_DEBUG msg);} while(0)
+/** Print error message */
+#define	PRINTM_ERROR(msg...) do {if (drvdbg & DBG_ERROR) printk(KERN_ERR msg);} while(0)
+/** Print fatal message */
+#define	PRINTM_FATAL(msg...) do {if (drvdbg & DBG_FATAL) printk(KERN_ERR msg);} while(0)
+/** Print message */
+#define	PRINTM_MSG(msg...)   do {if (drvdbg & DBG_MSG)   printk(KERN_ALERT msg);} while(0)
+
+/** Print data dump message */
+#define	PRINTM_DAT_D(msg...)  do {if (drvdbg & DBG_DAT_D)  printk(KERN_DEBUG msg);} while(0)
+/** Print data dump message */
+#define	PRINTM_CMD_D(msg...)  do {if (drvdbg & DBG_CMD_D)  printk(KERN_DEBUG msg);} while(0)
+
+/** Print message with required level */
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+/** Debug dump buffer length */
+#define DBG_DUMP_BUF_LEN 	64
+/** Maximum number of dump per line */
+#define MAX_DUMP_PER_LINE	16
+/** Maximum data dump length */
+#define MAX_DATA_DUMP_LEN	48
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s: len=%d\n", prompt, len);
+    for (i = 1; i <= len; i++) {
+        ptr += snprintf(ptr, 4, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+/** Debug hexdump of debug data */
+#define DBG_HEXDUMP_ERROR(x,y,z)     do {if (drvdbg & DBG_ERROR) hexdump(x,y,z);} while(0)
+#define DBG_HEXDUMP_DAT_D(x,y,z)     do {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);} while(0)
+/** Debug hexdump of debug command */
+#define DBG_HEXDUMP_CMD_D(x,y,z)     do {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);} while(0)
+
+/** Debug hexdump */
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+
+/** Mark entry point */
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__func__, __LINE__)
+/** Mark exit point */
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__func__, __LINE__)
+#else
+/** Do nothing */
+#define	PRINTM(level,msg...) do {} while (0);
+/** Do nothing */
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0);
+/** Do nothing */
+#define	ENTER()  do {} while (0);
+/** Do nothing */
+#define	LEAVE()  do {} while (0);
+#endif /* DEBUG_LEVEL1 */
+
+/** Length of device name */
+#define DEV_NAME_LEN				32
+/** Bluetooth upload size */
+#define	BT_UPLD_SIZE				2312
+/** Bluetooth status success */
+#define BT_STATUS_SUCCESS			(0)
+/** Bluetooth status failure */
+#define BT_STATUS_FAILURE			(-1)
+
+#ifndef	TRUE
+/** True value */
+#define TRUE			1
+#endif
+#ifndef	FALSE
+/** False value */
+#define	FALSE			0
+#endif
+
+/** Set thread state */
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+/** Time to wait until Host Sleep state change in millisecond */
+#define WAIT_UNTIL_HS_STATE_CHANGED 2000
+/** Time to wait cmd resp in millisecond */
+#define WAIT_UNTIL_CMD_RESP	    5000
+
+/** Sleep until a condition gets true or a timeout elapses */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	interruptible_sleep_on_timeout(&waitq, ((timeout) * HZ / 1000))
+#else
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, ((timeout) * HZ / 1000))
+#endif
+
+typedef struct
+{
+    /** Task */
+    struct task_struct *task;
+    /** Queue */
+    wait_queue_head_t waitQ;
+    /** PID */
+    pid_t pid;
+    /** Private structure */
+    void *priv;
+} bt_thread;
+
+static inline void
+bt_activate_thread(bt_thread * thr)
+{
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+
+        /** Record the thread pid */
+    thr->pid = current->pid;
+}
+
+static inline void
+bt_deactivate_thread(bt_thread * thr)
+{
+    thr->pid = 0;
+    return;
+}
+
+static inline void
+bt_create_thread(int (*btfunc) (void *), bt_thread * thr, char *name)
+{
+    thr->task = kthread_run(btfunc, thr, "%s", name);
+}
+
+static inline int
+bt_terminate_thread(bt_thread * thr)
+{
+    /* Check if the thread is active or not */
+    if (!thr->pid)
+        return -1;
+
+    kthread_stop(thr->task);
+    return 0;
+}
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+/** Data structure for the Marvell Bluetooth device */
+typedef struct _bt_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+    /** HCI device */
+    struct hci_dev *hcidev;
+
+    /** Tx download ready flag */
+    u8 tx_dnld_rdy;
+    /** Function */
+    u8 fn;
+    /** Rx unit */
+    u8 rx_unit;
+    /** Power Save mode : Timeout configuration */
+    u16 idle_timeout;
+    /** Power Save mode */
+    u8 psmode;
+    /** Power Save command */
+    u8 pscmd;
+    /** Host Sleep mode */
+    u8 hsmode;
+    /** Host Sleep command */
+    u8 hscmd;
+    /** Low byte is gap, high byte is GPIO */
+    u16 gpio_gap;
+    /** Host Sleep configuration command */
+    u8 hscfgcmd;
+    /** Host Send Cmd Flag		 */
+    u8 sendcmdflag;
+    /** ocf for Send Cmd */
+    u16 send_cmd_ocf;
+    /** Device Type			*/
+    u8 devType;
+    /** cmd52 function */
+    u8 cmd52_func;
+    /** cmd52 register */
+    u8 cmd52_reg;
+    /** cmd52 value */
+    u8 cmd52_val;
+    /** SDIO pull control command */
+    u8 sdio_pull_ctrl;
+    /** Low 2 bytes is pullUp, high 2 bytes for pull-down */
+    u32 sdio_pull_cfg;
+} bt_dev_t, *pbt_dev_t;
+
+typedef struct _bt_adapter
+{
+    /** Chip revision ID */
+    u8 chip_rev;
+    /** Surprise removed flag */
+    u8 SurpriseRemoved;
+    /** IRQ number */
+    int irq;
+    /** Interrupt counter */
+    u32 IntCounter;
+    /** Tx packet queue */
+    struct sk_buff_head tx_queue;
+    /** Pending Tx packet queue */
+    struct sk_buff_head pending_queue;
+    /** tx lock flag */
+    u8 tx_lock;
+    /** Power Save mode */
+    u8 psmode;
+    /** Power Save state */
+    u8 ps_state;
+    /** Host Sleep state */
+    u8 hs_state;
+        /** hs skip count */
+    u32 hs_skip;
+        /** suspend_fail flag */
+    u8 suspend_fail;
+        /** suspended flag */
+    u8 is_suspended;
+    /** Number of wakeup tries */
+    u8 WakeupTries;
+    /** Host Sleep wait queue */
+    wait_queue_head_t cmd_wait_q __ATTRIB_ALIGN__;
+    /** Host Cmd complet state */
+    u8 cmd_complete;
+    /** last irq recv */
+    u8 irq_recv;
+    /** last irq processed */
+    u8 irq_done;
+    /** sdio int status */
+    u8 sd_ireg;
+    /** tx pending */
+    u32 skb_pending;
+/** Version string buffer length */
+#define MAX_VER_STR_LEN         128
+        /** Driver version */
+    u8 drv_ver[MAX_VER_STR_LEN];
+} bt_adapter, *pbt_adapter;
+
+struct item_data
+{
+    /** Name */
+    char name[32];
+    /** Size */
+    u32 size;
+    /** Address */
+    u32 addr;
+    /** Offset */
+    u32 offset;
+    /** Flag */
+    u32 flag;
+};
+
+struct proc_private_data
+{
+    /** Name */
+    char name[32];
+    /** File flag */
+    u32 fileflag;
+    /** Buffer size */
+    u32 bufsize;
+    /** Number of items */
+    u32 num_items;
+    /** Item data */
+    struct item_data *pdata;
+    /** Private structure */
+    struct _bt_private *pbt;
+    /** File operations */
+    struct file_operations *fops;
+};
+
+/** Private structure for the MV device */
+typedef struct _bt_private
+{
+    /** Bluetooth device */
+    bt_dev_t bt_dev;
+    /** Adapter */
+    bt_adapter *adapter;
+    /** Firmware helper */
+    const struct firmware *fw_helper;
+    /** Firmware */
+    const struct firmware *firmware;
+        /** Firmware request start time */
+    struct timeval req_fw_time;
+    /** Hotplug device */
+    struct device *hotplug_device;
+        /** thread to service interrupts */
+    bt_thread MainThread;
+    /** Proc directory entry */
+    struct proc_dir_entry *proc_entry;
+        /** num of proc files */
+    u8 num_proc_files;
+        /** pointer to proc_private_data */
+    struct proc_private_data *pfiles;
+    /** Driver lock */
+    spinlock_t driver_lock;
+    /** Driver lock flags */
+    ulong driver_flags;
+    /** CRC check flag */
+    u16 fw_crc_check;
+} bt_private, *pbt_private;
+
+/** Disable interrupt */
+#define OS_INT_DISABLE	spin_lock_irqsave(&priv->driver_lock, priv->driver_flags)
+/** Enable interrupt */
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&priv->driver_lock, priv->driver_flags)
+
+#ifndef HCI_BT_AMP
+/** BT_AMP flag for device type */
+#define  HCI_BT_AMP			0x80
+#endif
+
+/** Device type of BT */
+#define DEV_TYPE_BT 			0x00
+/** Device type of AMP */
+#define DEV_TYPE_AMP			0x01
+
+/** Marvell vendor packet */
+#define MRVL_VENDOR_PKT			0xFE
+/** Bluetooth command : Get FW Version */
+#define BT_CMD_GET_FW_VERSION		0x0F
+/** Bluetooth command : Sleep mode */
+#define BT_CMD_AUTO_SLEEP_MODE		0x23
+/** Bluetooth command : Host Sleep configuration */
+#define BT_CMD_HOST_SLEEP_CONFIG	0x59
+/** Bluetooth command : Host Sleep enable */
+#define BT_CMD_HOST_SLEEP_ENABLE	0x5A
+/** Bluetooth command : Module Configuration request */
+#define BT_CMD_MODULE_CFG_REQ		0x5B
+/** Bluetooth command : SDIO pull up down configuration request */
+#define BT_CMD_SDIO_PULL_CFG_REQ	0x69
+/** Sub Command: Module Bring Up Request */
+#define MODULE_BRINGUP_REQ		0xF1
+/** Sub Command: Module Shut Down Request */
+#define MODULE_SHUTDOWN_REQ		0xF2
+/** Module already up */
+#define MODULE_CFG_RESP_ALREADY_UP      0x0c
+/** Sub Command: Host Interface Control Request */
+#define MODULE_INTERFACE_CTRL_REQ	0xF5
+
+/** Bluetooth event : Power State */
+#define BT_EVENT_POWER_STATE		0x20
+
+/** Bluetooth Power State : Enable */
+#define BT_PS_ENABLE			0x02
+/** Bluetooth Power State : Disable */
+#define BT_PS_DISABLE			0x03
+/** Bluetooth Power State : Sleep */
+#define BT_PS_SLEEP			0x01
+/** Bluetooth Power State : Awake */
+#define BT_PS_AWAKE			0x02
+
+/** OGF */
+#define OGF				0x3F
+
+/** Host Sleep activated */
+#define HS_ACTIVATED			0x01
+/** Host Sleep deactivated */
+#define HS_DEACTIVATED			0x00
+
+/** Power Save sleep */
+#define PS_SLEEP			0x01
+/** Power Save awake */
+#define PS_AWAKE			0x00
+
+/** bt header length */
+#define BT_HEADER_LEN			4
+
+#ifndef MAX
+/** Return maximum of two */
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** This is for firmware specific length */
+#define EXTRA_LEN	36
+
+/** Command buffer size for Marvell driver */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+
+/** Bluetooth Rx packet buffer size for Marvell driver */
+#define MRVDRV_BT_RX_PACKET_BUFFER_SIZE \
+	(HCI_MAX_FRAME_SIZE + EXTRA_LEN)
+
+/** Buffer size to allocate */
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_BT_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + SDIO_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/** Request FW timeout in second */
+#define REQUEST_FW_TIMEOUT		30
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/** The number of times to try when waiting for downloaded firmware to 
+    become active when multiple interface is present */
+#define MAX_MULTI_INTERFACE_POLL_TRIES  1000
+
+/** The number of times to try when waiting for downloaded firmware to 
+     become active. (polling the scratch register). */
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+/** default idle time */
+#define DEFAULT_IDLE_TIME           0
+
+typedef struct _BT_CMD
+{
+    /** OCF OGF */
+    u16 ocf_ogf;
+    /** Length */
+    u8 length;
+    /** Data */
+    u8 data[6];
+} __ATTRIB_PACK__ BT_CMD;
+
+typedef struct _BT_EVENT
+{
+    /** Event Counter */
+    u8 EC;
+    /** Length */
+    u8 length;
+    /** Data */
+    u8 data[8];
+} BT_EVENT;
+
+int check_evtpkt(bt_private * priv, struct sk_buff *skb);
+
+/* Prototype of global function */
+bt_private *bt_add_card(void *card);
+int bt_remove_card(void *card);
+void bt_interrupt(struct hci_dev *hdev);
+
+int bt_root_proc_init(void);
+int bt_root_proc_remove(void);
+
+int bt_proc_init(bt_private * priv);
+void bt_proc_remove(bt_private * priv);
+int bt_process_event(bt_private * priv, struct sk_buff *skb);
+int bt_enable_hs(bt_private * priv);
+int bt_prepare_command(bt_private * priv);
+
+int *sbi_register(void);
+void sbi_unregister(void);
+int sbi_register_dev(bt_private * priv);
+int sbi_unregister_dev(bt_private * priv);
+int sbi_host_to_card(bt_private * priv, u8 * payload, u16 nb);
+int sbi_enable_host_int(bt_private * priv);
+int sbi_disable_host_int(bt_private * priv);
+int sbi_download_fw(bt_private * priv);
+int sbi_get_int_status(bt_private * priv, u8 * ireg);
+int sbi_wakeup_firmware(bt_private * priv);
+int sd_register_conf_dpc(bt_private * priv);
+void bt_free_adapter(bt_private * priv);
+int sd_download_firmware_w_helper(bt_private * priv);
+
+typedef struct _BT_HCI_CMD
+{
+    /** OCF OGF */
+    u16 ocf_ogf;
+    /** Length */
+    u8 length;
+    /** cmd type */
+    u8 cmd_type;
+    /** cmd len */
+    u8 cmd_len;
+    /** Data */
+    u8 data[6];
+} __ATTRIB_PACK__ BT_HCI_CMD;
+
+/** Max line length allowed in init config file */
+#define MAX_LINE_LEN        256
+/** Max MAC address string length allowed */
+#define MAX_MAC_ADDR_LEN    18
+/** Max register type/offset/value etc. parameter length allowed */
+#define MAX_PARAM_LEN       12
+
+/** Bluetooth command : Mac address configuration */
+#define BT_CMD_CONFIG_MAC_ADDR     	0x22
+/** Bluetooth command : Write CSU register */
+#define BT_CMD_CSU_WRITE_REG        0x66
+
+typedef struct _BT_CSU_CMD
+{
+    /** OCF OGF */
+    u16 ocf_ogf;
+    /** Length */
+    u8 length;
+    /** reg type */
+    u8 type;
+    /** address */
+    u8 offset[4];
+    /** Data */
+    u8 value[2];
+} __ATTRIB_PACK__ BT_CSU_CMD;
+
+int bt_set_mac_address(bt_private * priv, u8 * mac);
+int bt_write_reg(bt_private * priv, u8 type, u32 offset, u16 value);
+int bt_init_config(bt_private * priv, char *cfg_file);
+
+#endif /* _BT_DRV_H_ */
diff --git a/drivers/bluetooth/marvell/bt_init.c b/drivers/bluetooth/marvell/bt_init.c
new file mode 100644
index 0000000..6eb060b
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_init.c
@@ -0,0 +1,410 @@
+/** @file bt_init.c
+  *  
+  * @brief This file contains the init functions for BlueTooth
+  * driver.
+  * 
+  * Copyright (C) 2011, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+
+#include "include.h"
+
+#define isxdigit(c)	(('0' <= (c) && (c) <= '9') \
+			 || ('a' <= (c) && (c) <= 'f') \
+			 || ('A' <= (c) && (c) <= 'F'))
+
+#define isdigit(c)	(('0' <= (c) && (c) <= '9'))
+
+/** 
+ *  @brief Return hex value of a give character
+ *
+ *  @param chr	    Character to be converted
+ *
+ *  @return 	    The converted character if chr is a valid hex, else 0
+ */
+static int
+bt_hexval(char chr)
+{
+    ENTER();
+
+    if (chr >= '0' && chr <= '9')
+        return chr - '0';
+    if (chr >= 'A' && chr <= 'F')
+        return chr - 'A' + 10;
+    if (chr >= 'a' && chr <= 'f')
+        return chr - 'a' + 10;
+
+    LEAVE();
+    return 0;
+}
+
+/** 
+ *  @brief Extension of strsep lib command. This function will also take care
+ *	   escape character
+ *
+ *  @param s         A pointer to array of chars to process
+ *  @param delim     The delimiter character to end the string
+ *  @param esc       The escape character to ignore for delimiter
+ *
+ *  @return          Pointer to the separated string if delim found, else NULL
+ */
+static char *
+bt_strsep(char **s, char delim, char esc)
+{
+    char *se = *s, *sb;
+
+    ENTER();
+
+    if (!(*s) || (*se == '\0')) {
+        LEAVE();
+        return NULL;
+    }
+
+    for (sb = *s; *sb != '\0'; ++sb) {
+        if (*sb == esc && *(sb + 1) == esc) {
+            /* 
+             * We get a esc + esc seq then keep the one esc
+             * and chop off the other esc character
+             */
+            memmove(sb, sb + 1, strlen(sb));
+            continue;
+        }
+        if (*sb == esc && *(sb + 1) == delim) {
+            /* 
+             * We get a delim + esc seq then keep the delim
+             * and chop off the esc character
+             */
+            memmove(sb, sb + 1, strlen(sb));
+            continue;
+        }
+        if (*sb == delim)
+            break;
+    }
+
+    if (*sb == '\0')
+        sb = NULL;
+    else
+        *sb++ = '\0';
+
+    *s = sb;
+
+    LEAVE();
+    return se;
+}
+
+/**
+ *  @brief Return hex value of a given ascii string
+ *
+ *  @param a	    String to be converted 
+ *
+ *  @return 	    hex value
+ */
+static int
+bt_atox(char *a)
+{
+    int i = 0;
+    ENTER();
+    while (isxdigit(*a))
+        i = i * 16 + bt_hexval(*a++);
+
+    LEAVE();
+    return i;
+}
+
+/**
+ *  @brief Convert mac address from string to t_u8 buffer.
+ *
+ *  @param mac_addr The buffer to store the mac address in.	    
+ *  @param buf      The source of mac address which is a string.	    
+ *
+ *  @return 	    N/A
+ */
+static void
+bt_mac2u8(u8 * mac_addr, char *buf)
+{
+    char *begin = buf, *end;
+    int i;
+
+    ENTER();
+
+    for (i = 0; i < ETH_ALEN; ++i) {
+        end = bt_strsep(&begin, ':', '/');
+        if (end)
+            mac_addr[i] = bt_atox(end);
+    }
+
+    LEAVE();
+}
+
+/**
+ *  @brief Return integer value of a given ascii string
+ *
+ *  @param data    Converted data to be returned
+ *  @param a       String to be converted
+ *
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_atoi(int *data, char *a)
+{
+    int i, val = 0, len;
+
+    ENTER();
+
+    len = strlen(a);
+    if (!strncmp(a, "0x", 2)) {
+        a = a + 2;
+        len -= 2;
+        *data = bt_atox(a);
+        return BT_STATUS_SUCCESS;
+    }
+    for (i = 0; i < len; i++) {
+        if (isdigit(a[i])) {
+            val = val * 10 + (a[i] - '0');
+        } else {
+            PRINTM(ERROR, "Invalid char %c in string %s\n", a[i], a);
+            return BT_STATUS_FAILURE;
+        }
+    }
+    *data = val;
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/**
+ *    @brief BT get one line data from ASCII format data
+ *   
+ *    @param data         Source data
+ *    @param size         Source data length
+ *    @param line_pos     Destination data
+ *    @return             -1 or length of the line
+ */
+int
+parse_cfg_get_line(u8 * data, u32 size, u8 * line_pos)
+{
+    static s32 pos = 0;
+    u8 *src, *dest;
+
+    if (pos >= size) {          /* reach the end */
+        pos = 0;                /* Reset position for rfkill */
+        return -1;
+    }
+    memset(line_pos, 0, MAX_LINE_LEN);
+    src = data + pos;
+    dest = line_pos;
+
+    while (*src != '\x0A' && *src != '\0') {
+        if (*src != ' ' && *src != '\t')        /* parse space */
+            *dest++ = *src++;
+        else
+            src++;
+        pos++;
+    }
+    *dest = '\0';
+    /* parse new line */
+    pos++;
+    return strlen(line_pos);
+}
+
+/**
+ *    @brief BT parse ASCII format data to MAC address
+ *   
+ *    @param priv          BT private handle
+ *    @param data          Source data
+ *    @param size          data length
+ *    @return              BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_init_cfg(bt_private * priv, u8 * data, u32 size)
+{
+    u8 *pos;
+    u8 *intf_s, *intf_e;
+    u8 s[MAX_LINE_LEN];         /* 1 line data */
+    u32 line_len;
+    char hci_name[MAX_PARAM_LEN];
+    u8 buf[MAX_PARAM_LEN];
+    u8 bt_addr[MAX_MAC_ADDR_LEN];
+    u8 bt_mac[ETH_ALEN];
+    int setting = 0;
+    u8 type = 0;
+    u16 value = 0;
+    u32 offset = 0;
+    int ret = BT_STATUS_FAILURE;
+
+    memset(hci_name, 0, sizeof(hci_name));
+    memset(bt_addr, 0, sizeof(bt_addr));
+    memset(bt_mac, 0, sizeof(bt_mac));
+
+    while ((line_len = parse_cfg_get_line(data, size, s)) != -1) {
+        pos = s;
+        while (*pos == ' ' || *pos == '\t')
+            pos++;
+
+        if (*pos == '#' || (*pos == '\r' && *(pos + 1) == '\n') ||
+            *pos == '\n' || *pos == '\0')
+            continue;           /* Need n't process this line */
+
+        /* Process MAC addr */
+        if (strncmp(pos, "mac_addr", 8) == 0) {
+            intf_s = strchr(pos, '=');
+            if (intf_s != NULL)
+                intf_e = strchr(intf_s, ':');
+            else
+                intf_e = NULL;
+            if (intf_s != NULL && intf_e != NULL) {
+                if ((intf_e - intf_s) > MAX_PARAM_LEN) {
+                    PRINTM(ERROR, "BT: Too long interface name %d\n", __LINE__);
+                    goto done;
+                }
+                strncpy(hci_name, intf_s + 1, intf_e - intf_s - 1);
+                hci_name[intf_e - intf_s - 1] = '\0';
+                if (strcmp(hci_name, priv->bt_dev.hcidev->name) == 0) { /* found 
+                                                                           hci
+                                                                           device 
+                                                                         */
+                    strncpy(bt_addr, intf_e + 1, MAX_MAC_ADDR_LEN - 1);
+                    bt_addr[MAX_MAC_ADDR_LEN - 1] = '\0';
+                    /* Convert MAC format */
+                    bt_mac2u8(bt_mac, bt_addr);
+                    PRINTM(CMD,
+                           "HCI: %s new BT Address %02x:%02x:%02x:%02x:%02x:%02x\n",
+                           hci_name, bt_mac[0], bt_mac[1], bt_mac[2], bt_mac[3],
+                           bt_mac[4], bt_mac[5]);
+                    if (BT_STATUS_SUCCESS != bt_set_mac_address(priv, bt_mac)) {
+                        PRINTM(FATAL, "BT: Fail to set mac address\n");
+                        goto done;
+                    }
+                }
+            } else {
+                PRINTM(ERROR, "BT: Wrong config file format %d\n", __LINE__);
+                goto done;
+            }
+        }
+        /* Process REG value */
+        else if (strncmp(pos, "bt_reg", 6) == 0) {
+            intf_s = strchr(pos, '=');
+            if (intf_s != NULL)
+                intf_e = strchr(intf_s, ',');
+            else
+                intf_e = NULL;
+            if (intf_s != NULL && intf_e != NULL) {
+                /* Copy type */
+                memset(buf, 0, sizeof(buf));
+                strncpy(buf, intf_s + 1, 1);
+                buf[1] = '\0';
+                if (0 == bt_atoi(&setting, buf))
+                    type = (u8) setting;
+                else {
+                    PRINTM(ERROR, "BT: Fail to parse reg type\n");
+                    goto done;
+                }
+            } else {
+                PRINTM(ERROR, "BT: Wrong config file format %d\n", __LINE__);
+                goto done;
+            }
+            intf_s = intf_e + 1;
+            if (intf_s != NULL)
+                intf_e = strchr(intf_s, ',');
+            else
+                intf_e = NULL;
+            if (intf_s != NULL && intf_e != NULL) {
+                if ((intf_e - intf_s) >= MAX_PARAM_LEN) {
+                    PRINTM(ERROR, "BT: Regsier offset is too long %d\n",
+                           __LINE__);
+                    goto done;
+                }
+                /* Copy offset */
+                memset(buf, 0, sizeof(buf));
+                strncpy(buf, intf_s, intf_e - intf_s);
+                buf[intf_e - intf_s] = '\0';
+                if (0 == bt_atoi(&setting, buf))
+                    offset = (u32) setting;
+                else {
+                    PRINTM(ERROR, "BT: Fail to parse reg offset\n");
+                    goto done;
+                }
+            } else {
+                PRINTM(ERROR, "BT: Wrong config file format %d\n", __LINE__);
+                goto done;
+            }
+            intf_s = intf_e + 1;
+            if (intf_s != NULL) {
+                if ((strlen(intf_s) >= MAX_PARAM_LEN)) {
+                    PRINTM(ERROR, "BT: Regsier value is too long %d\n",
+                           __LINE__);
+                    goto done;
+                }
+                /* Copy value */
+                memset(buf, 0, sizeof(buf));
+                strncpy(buf, intf_s, sizeof(buf));
+                if (0 == bt_atoi(&setting, buf))
+                    value = (u16) setting;
+                else {
+                    PRINTM(ERROR, "BT: Fail to parse reg value\n");
+                    goto done;
+                }
+            } else {
+                PRINTM(ERROR, "BT: Wrong config file format %d\n", __LINE__);
+                goto done;
+            }
+
+            PRINTM(CMD, "BT: Write reg type: %d offset: 0x%x value: 0x%x\n",
+                   type, offset, value);
+            if (BT_STATUS_SUCCESS != bt_write_reg(priv, type, offset, value)) {
+                PRINTM(FATAL,
+                       "BT: Write reg failed. type: %d offset: 0x%x value: 0x%x\n",
+                       type, offset, value);
+                goto done;
+            }
+        }
+    }
+    ret = BT_STATUS_SUCCESS;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *    @brief BT set user defined init data and param
+ *   
+ *    @param priv     BT private handle
+ *    @param cfg_file user cofig file    
+ *    @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_init_config(bt_private * priv, char *cfg_file)
+{
+    const struct firmware *cfg = NULL;
+    int ret = BT_STATUS_SUCCESS;
+
+    ENTER();
+    if ((request_firmware(&cfg, cfg_file, priv->hotplug_device)) < 0) {
+        PRINTM(FATAL, "BT: request_firmware() %s failed\n", cfg_file);
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    if (cfg) {
+        ret = bt_process_init_cfg(priv, (u8 *) cfg->data, cfg->size);
+    } else
+        ret = BT_STATUS_FAILURE;
+  done:
+    if (cfg)
+        release_firmware(cfg);
+    LEAVE();
+    return ret;
+}
diff --git a/drivers/bluetooth/marvell/bt_main.c b/drivers/bluetooth/marvell/bt_main.c
new file mode 100644
index 0000000..4812471
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_main.c
@@ -0,0 +1,1407 @@
+/** @file bt_main.c
+  *  
+  * @brief This file contains the major functions in BlueTooth
+  * driver. It includes init, exit, open, close and main
+  * thread etc..
+  * 
+  * Copyright (C) 2007-2011, Marvell International Ltd. 
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+/**
+  * @mainpage M-BT Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * The M-BT is a Linux reference driver for Marvell SDIO Bluetooth chipset.
+  * 
+  * @section copyright_sec Copyright
+  *
+  * Copyright (C) 2007-2011, Marvell International Ltd.
+  *
+  */
+#include "include.h"
+
+/** Version */
+#define VERSION "M2614014"
+
+/** Driver version */
+static char driver_version[] = "sd8787-%s-" VERSION "-(" "FP" FPNUM ")"
+#ifdef DEBUG_LEVEL2
+    "-dbg"
+#endif
+    " ";
+
+static char fw_version[32] = "0.0.0.p0";
+
+/** Firmware flag */
+int fw = 1;
+/** default powermode */
+int psmode = 1;
+/** Default CRC check control */
+static int fw_crc_check = 1;
+/** Init config file (MAC address, register etc.) */
+static char *init_cfg = NULL;
+
+#ifdef	DEBUG_LEVEL1
+#ifdef  DEBUG_LEVEL2
+#define DEFAULT_DEBUG_MASK  (0xffffffff & ~DBG_EVENT)
+#else
+#define DEFAULT_DEBUG_MASK  (DBG_MSG | DBG_FATAL | DBG_ERROR)
+#endif /* DEBUG_LEVEL2 */
+ulong drvdbg = DEFAULT_DEBUG_MASK;
+#endif
+#ifdef SDIO_SUSPEND_RESUME
+/** PM keep power */
+int pm_keep_power = 1;
+#endif
+
+/** 
+ *  @brief This function verify the received event pkt
+ *
+ *  Event format:
+ *  +--------+--------+--------+--------+--------+
+ *  | Event  | Length |  ncmd  |      Opcode     |
+ *  +--------+--------+--------+--------+--------+
+ *  | 1-byte | 1-byte | 1-byte |      2-byte     |
+ *  +--------+--------+--------+--------+--------+
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+check_evtpkt(bt_private * priv, struct sk_buff *skb)
+{
+    struct hci_event_hdr *hdr = (struct hci_event_hdr *) skb->data;
+    struct hci_ev_cmd_complete *ec;
+    u16 opcode, ocf;
+    u8 ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (!priv->bt_dev.sendcmdflag) {
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    if (hdr->evt == HCI_EV_CMD_COMPLETE) {
+        ec = (struct hci_ev_cmd_complete *) (skb->data + HCI_EVENT_HDR_SIZE);
+        opcode = __le16_to_cpu(ec->opcode);
+        ocf = hci_opcode_ocf(opcode);
+        PRINTM(CMD, "BT: CMD_COMPLTE ocf=0x%x, send_cmd_ocf=0x%x\n", ocf,
+               priv->bt_dev.send_cmd_ocf);
+        if (ocf != priv->bt_dev.send_cmd_ocf) {
+            ret = BT_STATUS_FAILURE;
+            goto exit;
+        }
+        switch (ocf) {
+        case BT_CMD_MODULE_CFG_REQ:
+        case BT_CMD_CONFIG_MAC_ADDR:
+        case BT_CMD_CSU_WRITE_REG:
+        case BT_CMD_AUTO_SLEEP_MODE:
+        case BT_CMD_HOST_SLEEP_CONFIG:
+        case BT_CMD_SDIO_PULL_CFG_REQ:
+            priv->bt_dev.sendcmdflag = FALSE;
+            priv->adapter->cmd_complete = TRUE;
+            wake_up_interruptible(&priv->adapter->cmd_wait_q);
+            break;
+        case BT_CMD_GET_FW_VERSION:
+            {
+                u8 *pos = (skb->data + HCI_EVENT_HDR_SIZE +
+                           sizeof(struct hci_ev_cmd_complete) + 1);
+                snprintf(fw_version, sizeof(fw_version), "%u.%u.%u.p%u",
+                         pos[2], pos[1], pos[0], pos[3]);
+                priv->bt_dev.sendcmdflag = FALSE;
+                priv->adapter->cmd_complete = TRUE;
+                wake_up_interruptible(&priv->adapter->cmd_wait_q);
+                break;
+            }
+        case BT_CMD_HOST_SLEEP_ENABLE:
+            priv->bt_dev.sendcmdflag = FALSE;
+            break;
+        default:
+            ret = BT_STATUS_FAILURE;
+            break;
+        }
+    }
+  exit:
+    if (ret == BT_STATUS_SUCCESS)
+        kfree_skb(skb);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function process the received event
+ *
+ *  Event format:
+ *  +--------+--------+--------+--------+-----+
+ *  |   EC   | Length |           Data        |
+ *  +--------+--------+--------+--------+-----+
+ *  | 1-byte | 1-byte |          n-byte       |
+ *  +--------+--------+--------+--------+-----+
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to rx skb 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_process_event(bt_private * priv, struct sk_buff *skb)
+{
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_EVENT *pEvent;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+    ENTER();
+    pEvent = (BT_EVENT *) skb->data;
+    if (pEvent->EC != 0xff) {
+        PRINTM(CMD, "BT: Not Marvell Event=0x%x\n", pEvent->EC);
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    switch (pEvent->data[0]) {
+    case BT_CMD_AUTO_SLEEP_MODE:
+        if (pEvent->data[2] == BT_STATUS_SUCCESS) {
+            if (pEvent->data[1] == BT_PS_ENABLE)
+                priv->adapter->psmode = 1;
+            else
+                priv->adapter->psmode = 0;
+            PRINTM(CMD, "BT: PS Mode %s:%s\n", hdev->name,
+                   (priv->adapter->psmode) ? "Enable" : "Disable");
+        } else
+            PRINTM(CMD, "BT: PS Mode Command Fail %s\n", hdev->name);
+        break;
+    case BT_CMD_HOST_SLEEP_CONFIG:
+        if (pEvent->data[3] == BT_STATUS_SUCCESS) {
+            PRINTM(CMD, "BT: %s: gpio=0x%x, gap=0x%x\n", hdev->name,
+                   pEvent->data[1], pEvent->data[2]);
+        } else
+            PRINTM(CMD, "BT: %s: HSCFG Command Fail\n", hdev->name);
+        break;
+    case BT_CMD_HOST_SLEEP_ENABLE:
+        if (pEvent->data[1] == BT_STATUS_SUCCESS) {
+            priv->adapter->hs_state = HS_ACTIVATED;
+            if (priv->adapter->suspend_fail == FALSE) {
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+                bt_is_suspended(priv);
+#endif
+#endif
+#endif
+                wake_up_interruptible(&priv->adapter->cmd_wait_q);
+            }
+            if (priv->adapter->psmode)
+                priv->adapter->ps_state = PS_SLEEP;
+            PRINTM(CMD, "BT: EVENT %s: HS ACTIVATED!\n", hdev->name);
+        } else
+            PRINTM(CMD, "BT: %s: HS Enable Fail\n", hdev->name);
+        break;
+    case BT_CMD_MODULE_CFG_REQ:
+        if ((priv->bt_dev.sendcmdflag == TRUE) &&
+            ((pEvent->data[1] == MODULE_BRINGUP_REQ)
+             || (pEvent->data[1] == MODULE_SHUTDOWN_REQ))) {
+            if (pEvent->data[1] == MODULE_BRINGUP_REQ) {
+                PRINTM(CMD, "BT: EVENT %s:%s\n", hdev->name,
+                       (pEvent->data[2] &&
+                        (pEvent->data[2] !=
+                         MODULE_CFG_RESP_ALREADY_UP)) ? "Bring up Fail" :
+                       "Bring up success");
+                priv->bt_dev.devType = pEvent->data[3];
+                PRINTM(CMD, "devType:%s\n",
+                       (pEvent->data[3] ==
+                        DEV_TYPE_AMP) ? "AMP controller" : "BR/EDR controller");
+
+            }
+            if (pEvent->data[1] == MODULE_SHUTDOWN_REQ) {
+                PRINTM(CMD, "BT: EVENT %s:%s\n", hdev->name,
+                       (pEvent->
+                        data[2]) ? "Shut down Fail" : "Shut down success");
+            }
+            if (pEvent->data[2]) {
+                priv->bt_dev.sendcmdflag = FALSE;
+                priv->adapter->cmd_complete = TRUE;
+                wake_up_interruptible(&priv->adapter->cmd_wait_q);
+            }
+        } else {
+            PRINTM(CMD, "BT_CMD_MODULE_CFG_REQ resp for APP\n");
+            ret = BT_STATUS_FAILURE;
+        }
+        break;
+    case BT_EVENT_POWER_STATE:
+        if (pEvent->data[1] == BT_PS_SLEEP)
+            priv->adapter->ps_state = PS_SLEEP;
+        PRINTM(CMD, "BT: EVENT %s:%s\n", hdev->name,
+               (priv->adapter->ps_state) ? "PS_SLEEP" : "PS_AWAKE");
+        break;
+    case BT_CMD_SDIO_PULL_CFG_REQ:
+        if (pEvent->data[pEvent->length - 1] == BT_STATUS_SUCCESS) {
+            PRINTM(CMD, "BT: %s: SDIO pull configuration success\n",
+                   hdev->name);
+        } else {
+            PRINTM(CMD, "BT: %s: SDIO pull configuration fail\n", hdev->name);
+	}
+        break;
+    default:
+        PRINTM(CMD, "BT: Unknown Event=%d %s\n", pEvent->data[0], hdev->name);
+        ret = BT_STATUS_FAILURE;
+        break;
+    }
+  exit:
+    if (ret == BT_STATUS_SUCCESS)
+        kfree_skb(skb);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function send module cfg cmd to firmware
+ *
+ *  Command format:
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     OCF OGF     | Length |                Data               |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     2-byte      | 1-byte |               4-byte              |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param subcmd  sub command 
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_module_cfg_cmd(bt_private * priv, int subcmd)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "BT: No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_MODULE_CFG_REQ;
+    pCmd->length = 1;
+    pCmd->data[0] = subcmd;
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_MODULE_CFG_REQ;
+    priv->adapter->cmd_complete = FALSE;
+    PRINTM(CMD, "Queue module cfg Command(0x%x)\n", pCmd->ocf_ogf);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    /* 
+       On some Android platforms certain delay is needed for HCI daemon to
+       remove this module and close itself gracefully. Otherwise it hangs. This 
+       10ms delay is a workaround for such platforms as the root cause has not
+       been found yet. */
+    mdelay(10);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: module_cfg_cmd (0x%x): timeout sendcmdflag=%d\n",
+               subcmd, priv->bt_dev.sendcmdflag);
+    } else {
+        PRINTM(CMD, "BT: module cfg Command done\n");
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function enable power save mode 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_ps(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_AUTO_SLEEP_MODE;
+    if (priv->bt_dev.psmode)
+        pCmd->data[0] = BT_PS_ENABLE;
+    else
+        pCmd->data[0] = BT_PS_DISABLE;
+    if (priv->bt_dev.idle_timeout) {
+        pCmd->length = 3;
+        pCmd->data[1] = (u8) (priv->bt_dev.idle_timeout & 0x00ff);
+        pCmd->data[2] = (priv->bt_dev.idle_timeout & 0xff00) >> 8;
+    } else {
+        pCmd->length = 1;
+    }
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    PRINTM(CMD, "Queue PSMODE Command(0x%x):%d\n", pCmd->ocf_ogf,
+           pCmd->data[0]);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_AUTO_SLEEP_MODE;
+    priv->adapter->cmd_complete = FALSE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: psmode timeout: %d, %d,%d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function send hscfg command 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_hscfg_cmd(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_HOST_SLEEP_CONFIG;
+    pCmd->length = 2;
+    pCmd->data[0] = (priv->bt_dev.gpio_gap & 0xff00) >> 8;
+    pCmd->data[1] = (u8) (priv->bt_dev.gpio_gap & 0x00ff);
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    PRINTM(CMD, "Queue HSCFG Command(0x%x),gpio=0x%x,gap=0x%x\n", pCmd->ocf_ogf,
+           pCmd->data[0], pCmd->data[1]);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_HOST_SLEEP_CONFIG;
+    priv->adapter->cmd_complete = FALSE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: HSCFG timeout: %d, %d,%d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function send sdio pull ctrl command 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_send_sdio_pull_ctrl_cmd(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_SDIO_PULL_CFG_REQ;
+    pCmd->length = 4;
+    pCmd->data[0] = (priv->bt_dev.sdio_pull_cfg & 0x000000ff);
+    pCmd->data[1] = (priv->bt_dev.sdio_pull_cfg & 0x0000ff00) >> 8;
+    pCmd->data[2] = (priv->bt_dev.sdio_pull_cfg & 0x00ff0000) >> 16;
+    pCmd->data[3] = (priv->bt_dev.sdio_pull_cfg & 0xff000000) >> 24;
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    PRINTM(CMD,
+           "Queue SDIO PULL CFG Command(0x%x), PullUp=0x%x%x,PullDown=0x%x%x\n",
+           pCmd->ocf_ogf, pCmd->data[1], pCmd->data[0], pCmd->data[3],
+           pCmd->data[2]);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_SDIO_PULL_CFG_REQ;
+    priv->adapter->cmd_complete = FALSE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: SDIO PULL CFG timeout: %d, %d,%d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function enable host sleep 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_enable_hs(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    priv->adapter->suspend_fail = FALSE;
+    pCmd = (BT_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_HOST_SLEEP_ENABLE;
+    pCmd->length = 0;
+    bt_cb(skb)->pkt_type = MRVL_VENDOR_PKT;
+    skb_put(skb, sizeof(BT_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_HOST_SLEEP_ENABLE;
+    PRINTM(CMD, "Queue hs enable Command(0x%x)\n", pCmd->ocf_ogf);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    os_wait_interruptible_timeout(priv->adapter->cmd_wait_q,
+                                  priv->adapter->hs_state,
+                                  WAIT_UNTIL_HS_STATE_CHANGED);
+    OS_INT_DISABLE;
+    if ((priv->adapter->hs_state == HS_ACTIVATED) ||
+        (priv->adapter->is_suspended == TRUE)) {
+        OS_INT_RESTORE;
+        PRINTM(MSG, "BT: suspend success! skip=%d\n", priv->adapter->hs_skip);
+    } else {
+        priv->adapter->suspend_fail = TRUE;
+        OS_INT_RESTORE;
+        priv->adapter->hs_skip++;
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG,
+               "BT: suspend skipped! state=%d skip=%d ps_state= %d WakeupTries=%d\n",
+               priv->adapter->hs_state, priv->adapter->hs_skip,
+               priv->adapter->ps_state, priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function gets FW version
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_get_fw_version(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_HCI_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_HCI_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_HCI_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_GET_FW_VERSION;
+    pCmd->length = 0x01;
+    pCmd->cmd_type = 0x00;
+    bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+    skb_put(skb, 4);
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_GET_FW_VERSION;
+    priv->adapter->cmd_complete = FALSE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: Get FW version: timeout: %d, %d,%d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function set mac address 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param mac     A pointer to mac address
+ *
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_set_mac_address(bt_private * priv, u8 * mac)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_HCI_CMD *pCmd;
+    int i = 0;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_HCI_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_HCI_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_CONFIG_MAC_ADDR;
+    pCmd->length = 8;
+    pCmd->cmd_type = MRVL_VENDOR_PKT;
+    pCmd->cmd_len = 6;
+    for (i = 0; i < 6; i++)
+        pCmd->data[i] = mac[5 - i];
+    bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+    skb_put(skb, sizeof(BT_HCI_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_CONFIG_MAC_ADDR;
+    priv->adapter->cmd_complete = FALSE;
+    PRINTM(CMD, "BT: Set mac address %02x:%02x:%02x:%02x:%02x:%02x (0x%x)\n",
+           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5], pCmd->ocf_ogf);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(MSG, "BT: Set mac address: timeout: %d, %d,%d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function write value to CSU registers
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param type    reg type
+ *  @param offset  register address
+ *  @param value   register value to write
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_write_reg(bt_private * priv, u8 type, u32 offset, u16 value)
+{
+    struct sk_buff *skb = NULL;
+    u8 ret = BT_STATUS_SUCCESS;
+    BT_CSU_CMD *pCmd;
+    ENTER();
+    skb = bt_skb_alloc(sizeof(BT_CSU_CMD), GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    pCmd = (BT_CSU_CMD *) skb->tail;
+    pCmd->ocf_ogf = (OGF << 10) | BT_CMD_CSU_WRITE_REG;
+    pCmd->length = 7;
+    pCmd->type = type;
+    pCmd->offset[0] = (offset & 0x000000ff);
+    pCmd->offset[1] = (offset & 0x0000ff00) >> 8;
+    pCmd->offset[2] = (offset & 0x00ff0000) >> 16;
+    pCmd->offset[3] = (offset & 0xff000000) >> 24;
+    pCmd->value[0] = (value & 0x00ff);
+    pCmd->value[1] = (value & 0xff00) >> 8;
+    bt_cb(skb)->pkt_type = HCI_COMMAND_PKT;
+    skb_put(skb, sizeof(BT_CSU_CMD));
+    skb->dev = (void *) priv->bt_dev.hcidev;
+    skb_queue_head(&priv->adapter->tx_queue, skb);
+    priv->bt_dev.sendcmdflag = TRUE;
+    priv->bt_dev.send_cmd_ocf = BT_CMD_CSU_WRITE_REG;
+    priv->adapter->cmd_complete = FALSE;
+    PRINTM(CMD, "BT: Set CSU reg type=%d reg=0x%x value=0x%x\n", type, offset,
+           value);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (!os_wait_interruptible_timeout
+        (priv->adapter->cmd_wait_q, priv->adapter->cmd_complete,
+         WAIT_UNTIL_CMD_RESP)) {
+        ret = BT_STATUS_FAILURE;
+        PRINTM(ERROR, "BT: Set CSU reg timeout: %d, %d, %d\n",
+               priv->adapter->cmd_complete, priv->adapter->ps_state,
+               priv->adapter->WakeupTries);
+    }
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function used to restore tx_queue
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        N/A
+ */
+void
+bt_restore_tx_queue(bt_private * priv)
+{
+    struct sk_buff *skb = NULL;
+    while (!skb_queue_empty(&priv->adapter->pending_queue)) {
+        skb = skb_dequeue(&priv->adapter->pending_queue);
+        skb_queue_tail(&priv->adapter->tx_queue, skb);
+    }
+    wake_up_interruptible(&priv->MainThread.waitQ);
+}
+
+/** 
+ *  @brief This function used to send command to firmware
+ *
+ *  Command format:
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     OCF OGF     | Length |                Data               |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  |     2-byte      | 1-byte |               4-byte              |
+ *  +--------+--------+--------+--------+--------+--------+--------+
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return        BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_prepare_command(bt_private * priv)
+{
+    u8 ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (priv->bt_dev.hscfgcmd) {
+        priv->bt_dev.hscfgcmd = 0;
+        ret = bt_send_hscfg_cmd(priv);
+    }
+    if (priv->bt_dev.pscmd) {
+        priv->bt_dev.pscmd = 0;
+        ret = bt_enable_ps(priv);
+    }
+    if (priv->bt_dev.sdio_pull_ctrl) {
+        priv->bt_dev.sdio_pull_ctrl = 0;
+        ret = bt_send_sdio_pull_ctrl_cmd(priv);
+    }
+    if (priv->bt_dev.hscmd) {
+        priv->bt_dev.hscmd = 0;
+        if (priv->bt_dev.hsmode)
+            ret = bt_enable_hs(priv);
+        else {
+            ret = sbi_wakeup_firmware(priv);
+            priv->adapter->hs_state = HS_DEACTIVATED;
+        }
+    }
+    LEAVE();
+    return ret;
+}
+
+/** @brief This function processes a single packet 
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param skb     A pointer to skb which includes TX packet
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+SendSinglePacket(bt_private * priv, struct sk_buff *skb)
+{
+    int ret;
+    ENTER();
+    if (!skb || !skb->data)
+        return BT_STATUS_FAILURE;
+    if (!skb->len || ((skb->len + BT_HEADER_LEN) > BT_UPLD_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n", skb->len,
+               BT_UPLD_SIZE);
+        return BT_STATUS_FAILURE;
+    }
+    /* This is SDIO specific header length: byte[3][2][1], type: byte[0]
+       (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor) */
+    skb_push(skb, BT_HEADER_LEN);
+    skb->data[0] = (skb->len & 0x0000ff);
+    skb->data[1] = (skb->len & 0x00ff00) >> 8;
+    skb->data[2] = (skb->len & 0xff0000) >> 16;
+    skb->data[3] = bt_cb(skb)->pkt_type;
+    if (bt_cb(skb)->pkt_type == MRVL_VENDOR_PKT)
+        PRINTM(CMD, "DNLD_CMD: ocf_ogf=0x%x len=%d\n",
+               *((u16 *) & skb->data[4]), skb->len);
+    ret = sbi_host_to_card(priv, skb->data, skb->len);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   N/A
+ */
+static void
+bt_init_adapter(bt_private * priv)
+{
+    ENTER();
+    skb_queue_head_init(&priv->adapter->tx_queue);
+    skb_queue_head_init(&priv->adapter->pending_queue);
+    priv->adapter->tx_lock = FALSE;
+    priv->adapter->ps_state = PS_AWAKE;
+    priv->adapter->suspend_fail = FALSE;
+    priv->adapter->is_suspended = FALSE;
+    priv->adapter->hs_skip = 0;
+    init_waitqueue_head(&priv->adapter->cmd_wait_q);
+    LEAVE();
+}
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_fw(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    ENTER();
+    if (fw == 0) {
+        sbi_enable_host_int(priv);
+        goto done;
+    }
+    sbi_disable_host_int(priv);
+    priv->fw_crc_check = fw_crc_check;
+    if (sbi_download_fw(priv)) {
+        PRINTM(ERROR, "BT FW failed to be download!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function frees the structure of adapter
+ *    
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   N/A
+ */
+void
+bt_free_adapter(bt_private * priv)
+{
+    bt_adapter *Adapter = priv->adapter;
+    ENTER();
+    skb_queue_purge(&priv->adapter->tx_queue);
+    /* Free the adapter object itself */
+    kfree(Adapter);
+    priv->adapter = NULL;
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handle the ioctl 
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  @cmd   	   ioctl cmd 
+ *  @arg   	   argument
+ *  @return 	   -ENOIOCTLCMD
+ */
+static int
+bt_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)
+{
+    ENTER();
+    LEAVE();
+    return -ENOIOCTLCMD;
+}
+
+/** 
+ *  @brief This function handle destruct 
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   N/A
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+static void
+bt_destruct(struct hci_dev *hdev)
+{
+    ENTER();
+    LEAVE();
+    return;
+}
+#endif
+
+/** 
+ *  @brief This function handle the transmit
+ *  
+ *  @param skb     A pointer to sk_buffer structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS or other error no.   
+ */
+static int
+bt_send_frame(struct sk_buff *skb)
+{
+    struct hci_dev *hdev = (struct hci_dev *) skb->dev;
+    bt_private *priv = NULL;
+
+    ENTER();
+    PRINTM(DATA, "bt_send_frame %s: Type=%d, len=%d\n", hdev->name,
+           skb->pkt_type, skb->len);
+    DBG_HEXDUMP(CMD_D, "bt_send_frame", skb->data, skb->len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    if (!hdev || !hdev->core_data) {
+#else
+    if (!hdev || !hdev->driver_data) {
+#endif
+        PRINTM(ERROR, "Frame for unknown HCI device (hdev=NULL)\n");
+        LEAVE();
+        return -ENODEV;
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    priv = (bt_private *) hdev->core_data;
+#else
+    priv = (bt_private *) hdev->driver_data;
+#endif
+    if (!test_bit(HCI_RUNNING, &hdev->flags)) {
+        PRINTM(ERROR, "Fail test HCI_RUNING, flag=0x%lx\n", hdev->flags);
+        LEAVE();
+        return -EBUSY;
+    }
+    switch (bt_cb(skb)->pkt_type) {
+    case HCI_COMMAND_PKT:
+        hdev->stat.cmd_tx++;
+        break;
+    case HCI_ACLDATA_PKT:
+        hdev->stat.acl_tx++;
+        break;
+    case HCI_SCODATA_PKT:
+        hdev->stat.sco_tx++;
+        break;
+    }
+    if (priv->adapter->tx_lock == TRUE)
+        skb_queue_tail(&priv->adapter->pending_queue, skb);
+    else
+        skb_queue_tail(&priv->adapter->tx_queue, skb);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function flush the transmit queue
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS   
+ */
+static int
+bt_flush(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    bt_private *priv = (bt_private *) hdev->core_data;
+#else
+    bt_private *priv = (bt_private *) hdev->driver_data;
+#endif
+    ENTER();
+    skb_queue_purge(&priv->adapter->tx_queue);
+    skb_queue_purge(&priv->adapter->pending_queue);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function close the bluetooth device
+ *  
+ *  @param hev     A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS   
+ */
+static int
+bt_close(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    bt_private *priv = (bt_private *) hdev->core_data;
+#else
+    bt_private *priv = (bt_private *) hdev->driver_data;
+#endif
+    ENTER();
+    if (!test_and_clear_bit(HCI_RUNNING, &hdev->flags)) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    skb_queue_purge(&priv->adapter->tx_queue);
+    module_put(THIS_MODULE);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function open the bluetooth device
+ *  
+ *  @param hdev    A pointer to hci_dev structure
+ *  
+ *  @return 	   BT_STATUS_SUCCESS  or other
+ */
+static int
+bt_open(struct hci_dev *hdev)
+{
+    ENTER();
+    if (try_module_get(THIS_MODULE) == 0)
+        return BT_STATUS_FAILURE;
+    set_bit(HCI_RUNNING, &hdev->flags);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the major job in bluetooth driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *  
+ *  @param data    A pointer to bt_thread structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+static int
+bt_service_main_thread(void *data)
+{
+    bt_thread *thread = data;
+    bt_private *priv = thread->priv;
+    bt_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    struct sk_buff *skb;
+    ENTER();
+    bt_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+    current->flags |= PF_NOFREEZE;
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+        if (priv->adapter->WakeupTries ||
+            ((!priv->adapter->IntCounter) &&
+             (!priv->bt_dev.tx_dnld_rdy ||
+              skb_queue_empty(&priv->adapter->tx_queue)))) {
+            PRINTM(INFO, "Main: Thread sleeping...\n");
+            schedule();
+        }
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+        if (kthread_should_stop() || Adapter->SurpriseRemoved) {
+            PRINTM(INFO, "main-thread: break from main thread: "
+                   "SurpriseRemoved=0x%x\n", Adapter->SurpriseRemoved);
+            break;
+        }
+
+        PRINTM(INFO, "Main: Thread waking up...\n");
+        if (priv->adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+            sbi_get_int_status(priv, &ireg);
+        } else if ((priv->adapter->ps_state == PS_SLEEP) &&
+                   !skb_queue_empty(&priv->adapter->tx_queue)) {
+            priv->adapter->WakeupTries++;
+            sbi_wakeup_firmware(priv);
+            continue;
+        }
+        if (priv->adapter->ps_state == PS_SLEEP)
+            continue;
+        if (priv->bt_dev.tx_dnld_rdy == TRUE) {
+            if (!skb_queue_empty(&priv->adapter->tx_queue)) {
+                skb = skb_dequeue(&priv->adapter->tx_queue);
+                if (skb) {
+                    if (SendSinglePacket(priv, skb))
+                        priv->bt_dev.hcidev->stat.err_tx++;
+                    else
+                        priv->bt_dev.hcidev->stat.byte_tx += skb->len;
+                    kfree_skb(skb);
+                }
+            }
+        }
+    }
+    bt_deactivate_thread(thread);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *  
+ *  @param hdev    A pointer to hci_dev structure
+ *  @return        N/A
+ */
+void
+bt_interrupt(struct hci_dev *hdev)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    bt_private *priv = (bt_private *) hdev->core_data;
+#else
+    bt_private *priv = (bt_private *) hdev->driver_data;
+#endif
+    ENTER();
+    PRINTM(INTR, "*\n");
+    priv->adapter->ps_state = PS_AWAKE;
+    if (priv->adapter->hs_state == HS_ACTIVATED) {
+        PRINTM(CMD, "BT: %s: HS DEACTIVATED in ISR!\n", hdev->name);
+        priv->adapter->hs_state = HS_DEACTIVATED;
+    }
+    priv->adapter->WakeupTries = 0;
+    priv->adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    LEAVE();
+
+}
+
+/** 
+ *  @brief Module configuration and register device
+ *  
+ *  @param priv      A Pointer to bt_private structure
+ *  @return 	     BT_STATUS_SUCCESS or BT_STATUS_FAILURE	
+ */
+int
+sd_register_conf_dpc(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+
+    ENTER();
+
+    priv->bt_dev.tx_dnld_rdy = TRUE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+    hdev->bus = HCI_SDIO;
+#else
+    hdev->type = HCI_SDIO;
+#endif /* >= 2.6.34 */
+    hdev->open = bt_open;
+    hdev->close = bt_close;
+    hdev->flush = bt_flush;
+    hdev->send = bt_send_frame;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+    hdev->destruct = bt_destruct;
+#endif
+    hdev->ioctl = bt_ioctl;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+    hdev->owner = THIS_MODULE;
+#endif
+    ret = bt_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);
+    if (ret < 0) {
+        PRINTM(FATAL, "Module cfg command send failed!\n");
+        goto done;
+    }
+    if (psmode) {
+        priv->bt_dev.psmode = TRUE;
+        priv->bt_dev.idle_timeout = DEFAULT_IDLE_TIME;
+        ret = bt_enable_ps(priv);
+        if (ret < 0) {
+            PRINTM(FATAL, "Enable PS mode failed!\n");
+            goto done;
+        }
+    }
+#ifdef SDIO_SUSPEND_RESUME
+    priv->bt_dev.gpio_gap = 0xffff;
+    ret = bt_send_hscfg_cmd(priv);
+    if (ret < 0) {
+        PRINTM(FATAL, "Send HSCFG failed!\n");
+        goto done;
+    }
+#endif
+    priv->bt_dev.sdio_pull_cfg = 0xffffffff;
+    priv->bt_dev.sdio_pull_ctrl = 0;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (priv->bt_dev.devType == DEV_TYPE_AMP)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+	hdev->dev_type = HCI_AMP;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+        hdev->bus |= HCI_AMP;
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,34)
+        hdev->bus |= HCI_80211;
+#else
+        hdev->type |= HCI_BT_AMP;
+#endif
+
+    /* block all the packet from bluez */
+    if (init_cfg)
+        priv->adapter->tx_lock = TRUE;
+    ret = hci_register_dev(hdev);
+    if (ret < 0) {
+        PRINTM(FATAL, "Can not register HCI device\n");
+        goto done;
+    }
+    if (init_cfg) {
+        if (BT_STATUS_SUCCESS != bt_init_config(priv, init_cfg)) {
+            PRINTM(FATAL, "BT: Set user init data and param failed\n");
+            /* UnRegister to HCI Core */
+            hci_unregister_dev(hdev);
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        } else {
+            priv->adapter->tx_lock = FALSE;
+            bt_restore_tx_queue(priv);
+        }
+    }
+
+    /* Get FW version */
+    if (priv->bt_dev.devType == DEV_TYPE_BT)
+        bt_get_fw_version(priv);
+    snprintf(priv->adapter->drv_ver, MAX_VER_STR_LEN, driver_version,
+             fw_version);
+
+    bt_proc_init(priv);
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function adds the card. it will probe the
+ *  card, allocate the bt_priv and initialize the device. 
+ *  
+ *  @param card    A pointer to card
+ *  @return        A pointer to bt_private structure
+ */
+
+bt_private *
+bt_add_card(void *card)
+{
+    struct hci_dev *hdev = NULL;
+    bt_private *priv = NULL;
+
+    ENTER();
+
+    priv = kzalloc(sizeof(bt_private), GFP_KERNEL);
+    if (!priv) {
+        PRINTM(FATAL, "Can not allocate priv\n");
+        LEAVE();
+        return NULL;
+    }
+    /* allocate buffer for bt_adapter */
+    if (!(priv->adapter = kzalloc(sizeof(bt_adapter), GFP_KERNEL))) {
+        PRINTM(FATAL, "Allocate buffer for bt_adapter failed!\n");
+        goto err_kmalloc;
+    }
+
+    bt_init_adapter(priv);
+
+    /* Register to HCI Core */
+    hdev = hci_alloc_dev();
+    if (!hdev) {
+        PRINTM(FATAL, "Can not allocate HCI device\n");
+        goto err_kmalloc;
+    }
+
+    PRINTM(INFO, "Starting kthread...\n");
+    priv->MainThread.priv = priv;
+    spin_lock_init(&priv->driver_lock);
+
+    bt_create_thread(bt_service_main_thread, &priv->MainThread,
+                     "bt_main_service");
+
+    /* wait for mainthread to up */
+    while (!priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+    priv->bt_dev.hcidev = hdev;
+    priv->bt_dev.card = card;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+    hdev->core_data = priv;
+#else
+    hdev->driver_data = priv;
+#endif
+    ((struct sdio_mmc_card *) card)->priv = priv;
+    priv->adapter->sd_ireg = 0;
+    /* 
+     * Register the device. Fillup the private data structure with
+     * relevant information from the card and request for the required
+     * IRQ. 
+     */
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register bt device!\n");
+        goto err_registerdev;
+    }
+    if (bt_init_fw(priv)) {
+        PRINTM(FATAL, "BT Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+    LEAVE();
+    return priv;
+
+  err_init_fw:
+    PRINTM(INFO, "unregister device\n");
+    sbi_unregister_dev(priv);
+  err_registerdev:
+    ((struct sdio_mmc_card *) card)->priv = NULL;
+    /* Stop the thread servicing the interrupts */
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+  err_kmalloc:
+    if (hdev)
+        kfree(hdev);
+    if (priv->adapter)
+        bt_free_adapter(priv);
+    kfree(priv);
+    LEAVE();
+    return NULL;
+}
+
+/** 
+ *  @brief This function removes the card.
+ *  
+ *  @param card    A pointer to card
+ *  @return        BT_STATUS_SUCCESS
+ */
+
+int
+bt_remove_card(void *card)
+{
+    struct hci_dev *hdev;
+    bt_private *priv = (bt_private *) card;
+
+    ENTER();
+
+    if (!priv) {
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    if (!priv->adapter->SurpriseRemoved) {
+        bt_send_module_cfg_cmd(priv, MODULE_SHUTDOWN_REQ);
+        /* Disable interrupts on the card */
+        sbi_disable_host_int(priv);
+        priv->adapter->SurpriseRemoved = TRUE;
+    }
+    hdev = priv->bt_dev.hcidev;
+
+    wake_up_interruptible(&priv->adapter->cmd_wait_q);
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+        wake_up_interruptible(&priv->MainThread.waitQ);
+    }
+    bt_proc_remove(priv);
+    PRINTM(INFO, "unregester dev\n");
+    sbi_unregister_dev(priv);
+
+    /* UnRegister to HCI Core */
+    hci_unregister_dev(hdev);
+    hci_free_dev(hdev);
+    priv->bt_dev.hcidev = NULL;
+    PRINTM(INFO, "BT: Free Adapter\n");
+    bt_free_adapter(priv);
+    kfree(priv);
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function initializes module.
+ *  
+ *  @param     N/A
+ *  @return    BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+bt_init_module(void)
+{
+    int ret = BT_STATUS_SUCCESS;
+    ENTER();
+    bt_root_proc_init();
+    if (sbi_register() == NULL) {
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function cleans module
+ *  
+ *  @param         N/A
+ *  @return        N/A
+ */
+static void
+bt_exit_module(void)
+{
+    ENTER();
+    sbi_unregister();
+    bt_root_proc_remove();
+    LEAVE();
+}
+
+module_init(bt_init_module);
+module_exit(bt_exit_module);
+
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_DESCRIPTION("Marvell Bluetooth Driver Ver. " VERSION);
+MODULE_VERSION(VERSION);
+MODULE_LICENSE("GPL");
+module_param(fw, int, 1);
+MODULE_PARM_DESC(fw, "0: Skip firmware download; otherwise: Download firmware");
+module_param(fw_crc_check, int, 1);
+MODULE_PARM_DESC(fw_crc_check,
+                 "1: Enable FW download CRC check (default); 0: Disable FW download CRC check");
+module_param(psmode, int, 1);
+MODULE_PARM_DESC(psmode, "1: Enable powermode; 0: Disable powermode");
+#ifdef	DEBUG_LEVEL1
+module_param(drvdbg, ulong, 0);
+MODULE_PARM_DESC(drvdbg, "BIT3:DBG_DATA BIT4:DBG_CMD 0xFF:DBG_ALL");
+#endif
+#ifdef SDIO_SUSPEND_RESUME
+module_param(pm_keep_power, int, 1);
+MODULE_PARM_DESC(pm_keep_power, "1: PM keep power; 0: PM no power");
+#endif
+module_param(init_cfg, charp, 0);
+MODULE_PARM_DESC(init_cfg, "BT init config file name");
diff --git a/drivers/bluetooth/marvell/bt_proc.c b/drivers/bluetooth/marvell/bt_proc.c
new file mode 100644
index 0000000..a2780ae
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_proc.c
@@ -0,0 +1,634 @@
+/** @file bt_proc.c
+  *  
+  * @brief This file handle the functions for proc files
+  * 
+  * Copyright (C) 2007-2011, Marvell International Ltd.
+  *   
+  * This software file (the "File") is distributed by Marvell International 
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+  * (the "License").  You may use, redistribute and/or modify this File in 
+  * accordance with the terms and conditions of the License, a copy of which 
+  * is available along with the File in the gpl.txt file or by writing to 
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+  * this warranty disclaimer.
+  *
+  */
+
+#include "include.h"
+
+/** proc diretory root */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define PROC_DIR NULL
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#define PROC_DIR &proc_root
+#else
+#define PROC_DIR proc_net
+#endif
+
+/** Proc mbt directory entry */
+static struct proc_dir_entry *proc_mbt = NULL;
+
+#define     CMD52_STR_LEN   50
+static bt_private *bpriv = NULL;
+static char cmd52_string[CMD52_STR_LEN];
+
+struct proc_data
+{
+    /** Read length */
+    int rdlen;
+    /** Read buffer */
+    char *rdbuf;
+    /** Write length */
+    int wrlen;
+    /** Maximum write length */
+    int maxwrlen;
+    /** Write buffer */
+    char *wrbuf;
+    void (*on_close) (struct inode *, struct file *);
+};
+
+/** Default file permission */
+#define DEFAULT_FILE_PERM  0644
+
+/** Bluetooth device offset */
+#define OFFSET_BT_DEV		0x01
+/** Bluetooth adapter offset */
+#define OFFSET_BT_ADAPTER	0x02
+/** Show integer */
+#define SHOW_INT		0x10
+/** Show hex */
+#define SHOW_HEX		0x20
+/** Show string */
+#define SHOW_STRING		0x40
+
+/** Device size */
+#define item_dev_size(n) (sizeof ((bt_dev_t *)0)->n)
+/** Device address */
+#define item_dev_addr(n) ((u32) &((bt_dev_t *)0)->n)
+
+/** Adapter size */
+#define item_adapter_size(n) (sizeof ((bt_adapter *)0)->n)
+/** Adapter address */
+#define item_adapter_addr(n) ((u32) &((bt_adapter *)0)->n)
+static struct item_data config_items[] = {
+#ifdef	DEBUG_LEVEL1
+    {"drvdbg", sizeof(u32), (u32) & drvdbg, 0, SHOW_HEX}
+    ,
+#endif
+    {"idle_timeout", item_dev_size(idle_timeout), 0,
+     item_dev_addr(idle_timeout), OFFSET_BT_DEV | SHOW_HEX}
+    ,
+    {"psmode", item_dev_size(psmode), 0, item_dev_addr(psmode),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"pscmd", item_dev_size(pscmd), 0, item_dev_addr(pscmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"hsmode", item_dev_size(hsmode), 0, item_dev_addr(hsmode),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"hscmd", item_dev_size(hscmd), 0, item_dev_addr(hscmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"gpio_gap", item_dev_size(gpio_gap), 0, item_dev_addr(gpio_gap),
+     OFFSET_BT_DEV | SHOW_HEX}
+    ,
+    {"hscfgcmd", item_dev_size(hscfgcmd), 0, item_dev_addr(hscfgcmd),
+     OFFSET_BT_DEV | SHOW_INT}
+    ,
+    {"sdio_pull_cfg", item_dev_size(sdio_pull_cfg), 0,
+     item_dev_addr(sdio_pull_cfg), OFFSET_BT_DEV | SHOW_HEX}
+    ,
+    {"sdio_pull_ctrl", item_dev_size(sdio_pull_ctrl), 0,
+     item_dev_addr(sdio_pull_ctrl), OFFSET_BT_DEV | SHOW_INT}
+    ,
+};
+
+static struct item_data status_items[] = {
+    {"version", item_adapter_size(drv_ver), 0, item_adapter_addr(drv_ver),
+     OFFSET_BT_ADAPTER | SHOW_STRING},
+    {"tx_dnld_rdy", item_dev_size(tx_dnld_rdy), 0, item_dev_addr(tx_dnld_rdy),
+     OFFSET_BT_DEV | SHOW_INT},
+    {"psmode", item_adapter_size(psmode), 0, item_adapter_addr(psmode),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"hs_state", item_adapter_size(hs_state), 0, item_adapter_addr(hs_state),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"hs_skip", item_adapter_size(hs_skip), 0, item_adapter_addr(hs_skip),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"ps_state", item_adapter_size(ps_state), 0, item_adapter_addr(ps_state),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"WakeupTries", item_adapter_size(WakeupTries), 0,
+     item_adapter_addr(WakeupTries), OFFSET_BT_ADAPTER | SHOW_INT},
+    {"irq_recv", item_adapter_size(irq_recv), 0, item_adapter_addr(irq_recv),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"irq_done", item_adapter_size(irq_done), 0, item_adapter_addr(irq_done),
+     OFFSET_BT_ADAPTER | SHOW_INT},
+    {"skb_pending", item_adapter_size(skb_pending), 0,
+     item_adapter_addr(skb_pending), OFFSET_BT_ADAPTER | SHOW_INT},
+};
+
+static struct item_data debug_items[] = {
+    {"sdcmd52rw", 0, (u32) cmd52_string, 0, SHOW_STRING},
+};
+
+/** 
+ *  @brief convert string to number
+ *
+ *  @param s   	   pointer to numbered string
+ *  @return 	   converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+    int r = 0;
+    int base = 0;
+    int pn = 1;
+
+    if (strncmp(s, "-", 1) == 0) {
+        pn = -1;
+        s++;
+    }
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0)) {
+        base = 16;
+        s += 2;
+    } else
+        base = 10;
+
+    for (s = s; *s != 0; s++) {
+        if ((*s >= '0') && (*s <= '9'))
+            r = (r * base) + (*s - '0');
+        else if ((*s >= 'A') && (*s <= 'F'))
+            r = (r * base) + (*s - 'A' + 10);
+        else if ((*s >= 'a') && (*s <= 'f'))
+            r = (r * base) + (*s - 'a' + 10);
+        else
+            break;
+    }
+
+    return (r * pn);
+}
+
+/** 
+ *  @brief Create cmd52 string
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+static int
+form_cmd52_string(bt_private * priv)
+{
+    ENTER();
+
+    memset(cmd52_string, 0, CMD52_STR_LEN);
+    snprintf(cmd52_string, CMD52_STR_LEN - 1, "BT: %d 0x%0x 0x%02X",
+             priv->bt_dev.cmd52_func, priv->bt_dev.cmd52_reg,
+             priv->bt_dev.cmd52_val);
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/*
+ *  @brief Parse cmd52 string
+ *
+ *  @param buffer  A pointer user buffer
+ *  @param len     Length of user buffer
+ *  @param func    Parsed func number
+ *  @param reg     Parsed reg value
+ *  @param val     Parsed value to set
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+static int
+parse_cmd52_string(const char __user * buffer, size_t len, int *func, int *reg,
+                   int *val)
+{
+    int ret = BT_STATUS_SUCCESS;
+    char *string = NULL;
+    char *pos = NULL;
+
+    ENTER();
+
+    string = (char *) kmalloc(CMD52_STR_LEN, GFP_KERNEL);
+    memset(string, 0, CMD52_STR_LEN);
+    memcpy(string, buffer + strlen("sdcmd52rw="), len - strlen("sdcmd52rw="));
+    string = strstrip(string);
+
+    *func = -1;
+    *reg = -1;
+    *val = -1;
+
+    /* Get func */
+    pos = strsep(&string, " \t");
+    if (pos) {
+        *func = string_to_number(pos);
+    }
+
+    /* Get reg */
+    pos = strsep(&string, " \t");
+    if (pos) {
+        *reg = string_to_number(pos);
+    }
+
+    /* Get val (optional) */
+    pos = strsep(&string, " \t");
+    if (pos) {
+        *val = string_to_number(pos);
+    }
+    if (string)
+        kfree(string);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function handle generic proc file close
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+static int
+proc_close(struct inode *inode, struct file *file)
+{
+    struct proc_data *pdata = file->private_data;
+    ENTER();
+    if (pdata) {
+        if (pdata->on_close != NULL)
+            pdata->on_close(inode, file);
+        if (pdata->rdbuf)
+            kfree(pdata->rdbuf);
+        if (pdata->wrbuf)
+            kfree(pdata->wrbuf);
+        kfree(pdata);
+    }
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function handle generic proc file read
+ *  
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to output buffer
+ *  @param len     number of byte to read
+ *  @param offset  A pointer to offset of file
+ *  @return 	   number of output data
+ */
+static ssize_t
+proc_read(struct file *file, char __user * buffer, size_t len, loff_t * offset)
+{
+    loff_t pos = *offset;
+    struct proc_data *pdata = (struct proc_data *) file->private_data;
+    if ((!pdata->rdbuf) || (pos < 0))
+        return -EINVAL;
+    if (pos >= pdata->rdlen)
+        return 0;
+    if (len > pdata->rdlen - pos)
+        len = pdata->rdlen - pos;
+    if (copy_to_user(buffer, pdata->rdbuf + pos, len))
+        return -EFAULT;
+    *offset = pos + len;
+    return len;
+}
+
+/** 
+ *  @brief This function handle generic proc file write
+ *  
+ *  @param file    A pointer to file structure
+ *  @param buffer  A pointer to input buffer
+ *  @param len     number of byte to write
+ *  @param offset  A pointer to offset of file
+ *  @return 	   number of input data
+ */
+static ssize_t
+proc_write(struct file *file,
+           const char __user * buffer, size_t len, loff_t * offset)
+{
+    loff_t pos = *offset;
+    struct proc_data *pdata = (struct proc_data *) file->private_data;
+    int func, reg, val;
+
+    if (!pdata->wrbuf || (pos < 0))
+        return -EINVAL;
+    if (pos >= pdata->maxwrlen)
+        return 0;
+    if (len > pdata->maxwrlen - pos)
+        len = pdata->maxwrlen - pos;
+    if (copy_from_user(pdata->wrbuf + pos, buffer, len))
+        return -EFAULT;
+    if (!strncmp(buffer, "sdcmd52rw=", strlen("sdcmd52rw="))) {
+        parse_cmd52_string(buffer, len, &func, &reg, &val);
+        sd_write_cmd52_val(bpriv, func, reg, val);
+    }
+    if (pos + len > pdata->wrlen)
+        pdata->wrlen = len + file->f_pos;
+    *offset = pos + len;
+    return len;
+}
+
+/** 
+ *  @brief This function handle the generic file close 
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   N/A
+ */
+static void
+proc_on_close(struct inode *inode, struct file *file)
+{
+    struct proc_dir_entry *entry = PDE(inode);
+    struct proc_private_data *priv = entry->data;
+    struct proc_data *pdata = file->private_data;
+    char *line;
+    int i;
+    ENTER();
+    if (!pdata->wrlen)
+        return;
+    line = pdata->wrbuf;
+    while (line[0]) {
+        for (i = 0; i < priv->num_items; i++) {
+            if (!strncmp
+                (line, priv->pdata[i].name, strlen(priv->pdata[i].name))) {
+                line += strlen(priv->pdata[i].name) + 1;
+                if (priv->pdata[i].size == 1)
+                    *((u8 *) priv->pdata[i].addr) = (u8) string_to_number(line);
+                else if (priv->pdata[i].size == 2)
+                    *((u16 *) priv->pdata[i].addr) =
+                        (u16) string_to_number(line);
+                else if (priv->pdata[i].size == 4)
+                    *((u32 *) priv->pdata[i].addr) =
+                        (u32) string_to_number(line);
+            }
+        }
+        while (line[0] && line[0] != '\n')
+            line++;
+        if (line[0])
+            line++;
+    }
+    if (priv->pbt->bt_dev.hscmd || priv->pbt->bt_dev.pscmd
+        || priv->pbt->bt_dev.sdio_pull_ctrl || priv->pbt->bt_dev.hscfgcmd) {
+        bt_prepare_command(priv->pbt);
+        wake_up_interruptible(&priv->pbt->MainThread.waitQ);
+    }
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function handle the generic file open
+ *  
+ *  @param inode   A pointer to inode structure
+ *  @param file    A pointer to file structure
+ *  @return 	   BT_STATUS_SUCCESS or other error no.
+ */
+static int
+proc_open(struct inode *inode, struct file *file)
+{
+    struct proc_dir_entry *entry = PDE(inode);
+    struct proc_private_data *priv = entry->data;
+    struct proc_data *pdata;
+    int i;
+    char *p;
+    u32 val = 0;
+    ENTER();
+    priv->pbt->adapter->skb_pending =
+        skb_queue_len(&priv->pbt->adapter->tx_queue);
+    if ((file->private_data =
+         kzalloc(sizeof(struct proc_data), GFP_KERNEL)) == NULL) {
+        PRINTM(ERROR, "BT: Can not alloc mem for proc_data\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    pdata = (struct proc_data *) file->private_data;
+    if ((pdata->rdbuf = kmalloc(priv->bufsize, GFP_KERNEL)) == NULL) {
+        PRINTM(ERROR, "BT: Can not alloc mem for rdbuf\n");
+        kfree(file->private_data);
+        LEAVE();
+        return -ENOMEM;
+    }
+    if (priv->fileflag == DEFAULT_FILE_PERM) {
+        if ((pdata->wrbuf = kzalloc(priv->bufsize, GFP_KERNEL)) == NULL) {
+            PRINTM(ERROR, "BT: Can not alloc mem for wrbuf\n");
+            kfree(pdata->rdbuf);
+            kfree(file->private_data);
+            return -ENOMEM;
+        }
+        pdata->maxwrlen = priv->bufsize;
+        pdata->on_close = proc_on_close;
+    }
+    p = pdata->rdbuf;
+    for (i = 0; i < priv->num_items; i++) {
+        if (priv->pdata[i].size == 1)
+            val = *((u8 *) priv->pdata[i].addr);
+        else if (priv->pdata[i].size == 2)
+            val = *((u16 *) priv->pdata[i].addr);
+        else if (priv->pdata[i].size == 4)
+            val = *((u32 *) priv->pdata[i].addr);
+        if (priv->pdata[i].flag & SHOW_INT)
+            p += sprintf(p, "%s=%d\n", priv->pdata[i].name, val);
+        else if (priv->pdata[i].flag & SHOW_HEX)
+            p += sprintf(p, "%s=0x%x\n", priv->pdata[i].name, val);
+        else if (priv->pdata[i].flag & SHOW_STRING) {
+            if (!strncmp(priv->pdata[i].name, "sdcmd52rw", strlen("sdcmd52rw"))) {
+                sd_read_cmd52_val(bpriv);
+                form_cmd52_string(bpriv);
+            }
+            p += sprintf(p, "%s=%s\n", priv->pdata[i].name,
+                         (char *) priv->pdata[i].addr);
+        }
+    }
+    pdata->rdlen = strlen(pdata->rdbuf);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+static struct file_operations proc_read_ops = {
+    .read = proc_read,
+    .open = proc_open,
+    .release = proc_close
+};
+
+static struct file_operations proc_rw_ops = {
+    .read = proc_read,
+    .write = proc_write,
+    .open = proc_open,
+    .release = proc_close
+};
+
+static struct proc_private_data proc_files[] = {
+    {"status", S_IRUGO, 1024, sizeof(status_items) / sizeof(status_items[0]),
+     &status_items[0], NULL, &proc_read_ops}
+    ,
+    {"config", DEFAULT_FILE_PERM, 512,
+     sizeof(config_items) / sizeof(config_items[0]), &config_items[0], NULL,
+     &proc_rw_ops}
+    ,
+    {"debug", DEFAULT_FILE_PERM, 512,
+     sizeof(debug_items) / sizeof(debug_items[0]), &debug_items[0], NULL,
+     &proc_rw_ops}
+    ,
+};
+
+/** 
+ *  @brief This function initializes proc entry
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_proc_init(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    struct proc_dir_entry *entry;
+    int i, j;
+    ENTER();
+    bpriv = priv;
+    memset(cmd52_string, 0, CMD52_STR_LEN);
+    if (proc_mbt) {
+        priv->proc_entry = proc_mkdir(priv->bt_dev.hcidev->name, proc_mbt);
+        if (!priv->proc_entry) {
+            PRINTM(ERROR, "BT: Could not mkdir %s!\n",
+                   priv->bt_dev.hcidev->name);
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        priv->pfiles =
+            (struct proc_private_data *) kmalloc(sizeof(proc_files),
+                                                 GFP_ATOMIC);
+        if (!priv->pfiles) {
+            PRINTM(ERROR, "BT: Could not alloc memory for pfile!\n");
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        memcpy((u8 *) priv->pfiles, (u8 *) proc_files, sizeof(proc_files));
+        priv->num_proc_files = sizeof(proc_files) / sizeof(proc_files[0]);
+        for (j = 0; j < priv->num_proc_files; j++)
+            priv->pfiles[j].pdata = NULL;
+        for (j = 0; j < priv->num_proc_files; j++) {
+            priv->pfiles[j].pdata =
+                (struct item_data *) kmalloc(priv->pfiles[j].num_items *
+                                             sizeof(struct item_data),
+                                             GFP_ATOMIC);
+            if (!priv->pfiles[j].pdata) {
+                PRINTM(ERROR, "BT: Could not alloc memory for pdata!\n");
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            memcpy((u8 *) priv->pfiles[j].pdata, (u8 *) proc_files[j].pdata,
+                   priv->pfiles[j].num_items * sizeof(struct item_data));
+            for (i = 0; i < priv->pfiles[j].num_items; i++) {
+                if (priv->pfiles[j].pdata[i].flag & OFFSET_BT_DEV)
+                    priv->pfiles[j].pdata[i].addr =
+                        priv->pfiles[j].pdata[i].offset + (u32) & priv->bt_dev;
+                if (priv->pfiles[j].pdata[i].flag & OFFSET_BT_ADAPTER)
+                    priv->pfiles[j].pdata[i].addr =
+                        priv->pfiles[j].pdata[i].offset + (u32) priv->adapter;
+            }
+            priv->pfiles[j].pbt = priv;
+            entry =
+                create_proc_entry(proc_files[j].name,
+                                  S_IFREG | proc_files[j].fileflag,
+                                  priv->proc_entry);
+            if (entry) {
+                entry->data = &priv->pfiles[j];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+                entry->owner = THIS_MODULE;
+#endif
+                entry->proc_fops = proc_files[j].fops;
+            } else
+                PRINTM(MSG, "BT: Fail to create proc %s\n", proc_files[j].name);
+        }
+    }
+  done:
+    if (ret == BT_STATUS_FAILURE) {
+        if (priv->proc_entry) {
+            remove_proc_entry(priv->bt_dev.hcidev->name, proc_mbt);
+            priv->proc_entry = NULL;
+        }
+        if (priv->pfiles) {
+            for (j = 0; j < priv->num_proc_files; j++) {
+                if (priv->pfiles[j].pdata) {
+                    kfree(priv->pfiles[j].pdata);
+                    priv->pfiles[j].pdata = NULL;
+                }
+            }
+            kfree(priv->pfiles);
+            priv->pfiles = NULL;
+        }
+    }
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function removes proc interface
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   N/A
+ */
+void
+bt_proc_remove(bt_private * priv)
+{
+    int j;
+    ENTER();
+    PRINTM(INFO, "BT: Remove Proc Interface\n");
+    if (proc_mbt) {
+        if (priv->proc_entry) {
+            for (j = 0; j < sizeof(proc_files) / sizeof(proc_files[0]); j++)
+                remove_proc_entry(proc_files[j].name, priv->proc_entry);
+        }
+        remove_proc_entry(priv->bt_dev.hcidev->name, proc_mbt);
+        priv->proc_entry = NULL;
+        if (priv->pfiles) {
+            for (j = 0; j < priv->num_proc_files; j++) {
+                if (priv->pfiles[j].pdata) {
+                    kfree(priv->pfiles[j].pdata);
+                    priv->pfiles[j].pdata = NULL;
+                }
+            }
+            kfree(priv->pfiles);
+            priv->pfiles = NULL;
+        }
+    }
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function creates proc interface 
+ *  directory structure
+ *
+ *  @param 		N/A
+ *  @return		BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+bt_root_proc_init(void)
+{
+    PRINTM(INFO, "BT: Create Proc Interface\n");
+    proc_mbt = proc_mkdir("mbt", PROC_DIR);
+    if (!proc_mbt) {
+        PRINTM(ERROR, "BT: Cannot create proc interface\n");
+        return BT_STATUS_FAILURE;
+    }
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function removes proc interface 
+ *  directory structure
+ *
+ *  @param 		N/A
+ *  @return		BT_STATUS_SUCCESS
+ */
+int
+bt_root_proc_remove(void)
+{
+    remove_proc_entry("mbt", PROC_DIR);
+    proc_mbt = NULL;
+    return BT_STATUS_SUCCESS;
+}
diff --git a/drivers/bluetooth/marvell/bt_sdio.h b/drivers/bluetooth/marvell/bt_sdio.h
new file mode 100644
index 0000000..4ec967b
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_sdio.h
@@ -0,0 +1,248 @@
+/** @file bt_sdio.h
+ *  @brief This file contains SDIO (interface) module
+ *  related macros, enum, and structure.
+ *       
+ *  Copyright (C) 2007-2011, Marvell International Ltd.
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _BT_SDIO_H_
+#define _BT_SDIO_H_
+
+/** IRQ return type */
+typedef irqreturn_t IRQ_RET_TYPE;
+/** IRQ return */
+#define IRQ_RET		return IRQ_HANDLED
+/** ISR notifier function */
+typedef IRQ_RET_TYPE(*isr_notifier_fn_t) (s32 irq, void *dev_id,
+                                          struct pt_regs * reg);
+
+/** SDIO header length */
+#define SDIO_HEADER_LEN			4
+
+/* SD block size can not bigger than 64 due to buf size limit in firmware */
+/** define SD block size for data Tx/Rx */
+#define SD_BLOCK_SIZE			64
+/** define SD block size for firmware download */
+#define SD_BLOCK_SIZE_FW_DL		256
+
+/** Number of blocks for firmware transfer */
+#define FIRMWARE_TRANSFER_NBLOCK	2
+
+/** Firmware ready */
+#define FIRMWARE_READY			0xfedc
+
+/* Bus Interface Control Reg 0x07 */
+/** SD BUS width 1 */
+#define SD_BUS_WIDTH_1			0x00
+/** SD BUS width 4 */
+#define SD_BUS_WIDTH_4			0x02
+/** SD BUS width mask */
+#define SD_BUS_WIDTH_MASK		0x03
+/** Asynchronous interrupt mode */
+#define ASYNC_INT_MODE			0x20
+/* Host Control Registers */
+/** Host Control Registers : I/O port 0 */
+#define IO_PORT_0_REG			0x78
+/** Host Control Registers : I/O port 1 */
+#define IO_PORT_1_REG			0x79
+/** Host Control Registers : I/O port 2 */
+#define IO_PORT_2_REG			0x7A
+
+/** Host Control Registers : Configuration */
+#define CONFIGURATION_REG		0x00
+/** Host Control Registers : Host without Command 53 finish host*/
+#define HOST_TO_CARD_EVENT       (0x1U << 3)
+/** Host Control Registers : Host without Command 53 finish host */
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+/** Host Control Registers : Host power up */
+#define HOST_POWER_UP			(0x1U << 1)
+/** Host Control Registers : Host power down */
+#define HOST_POWER_DOWN			(0x1U << 0)
+
+/** Host Control Registers : Host interrupt mask */
+#define HOST_INT_MASK_REG		0x02
+/** Host Control Registers : Upload host interrupt mask */
+#define UP_LD_HOST_INT_MASK		(0x1U)
+/** Host Control Registers : Download host interrupt mask */
+#define DN_LD_HOST_INT_MASK		(0x2U)
+/** Enable Host interrupt mask */
+#define HIM_ENABLE			(UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK)
+/** Disable Host interrupt mask */
+#define	HIM_DISABLE			0xff
+
+/** Host Control Registers : Host interrupt status */
+#define HOST_INTSTATUS_REG		0x03
+/** Host Control Registers : Upload host interrupt status */
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+/** Host Control Registers : Download host interrupt status */
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+
+/** Host Control Registers : Host interrupt RSR */
+#define HOST_INT_RSR_REG		0x01
+/** Host Control Registers : Upload host interrupt RSR */
+#define UP_LD_HOST_INT_RSR		(0x1U)
+
+/** Host Control Registers : Host interrupt status */
+#define HOST_INT_STATUS_REG		0x28
+/** Host Control Registers : Upload CRC error */
+#define UP_LD_CRC_ERR			(0x1U << 2)
+/** Host Control Registers : Upload restart */
+#define UP_LD_RESTART              	(0x1U << 1)
+/** Host Control Registers : Download restart */
+#define DN_LD_RESTART              	(0x1U << 0)
+
+/* Card Control Registers */
+/** Card Control Registers : Read SQ base address A0 register */
+#define SQ_READ_BASE_ADDRESS_A0_REG  	0x40
+/** Card Control Registers : Read SQ base address A1 register */
+#define SQ_READ_BASE_ADDRESS_A1_REG  	0x41
+/** Card Control Registers : Read SQ base address A2 register */
+#define SQ_READ_BASE_ADDRESS_A2_REG  	0x42
+/** Card Control Registers : Read SQ base address A3 register */
+#define SQ_READ_BASE_ADDRESS_A3_REG  	0x43
+/** Card Control Registers : Read SQ base address B0 register */
+#define SQ_READ_BASE_ADDRESS_B0_REG  	0x44
+/** Card Control Registers : Read SQ base address B1 register */
+#define SQ_READ_BASE_ADDRESS_B1_REG  	0x45
+/** Card Control Registers : Read SQ base address B2 register */
+#define SQ_READ_BASE_ADDRESS_B2_REG  	0x46
+/** Card Control Registers : Read SQ base address B3 register */
+#define SQ_READ_BASE_ADDRESS_B3_REG  	0x47
+
+/** Card Control Registers : Card status register */
+#define CARD_STATUS_REG              	0x30
+/** Card Control Registers : Card I/O ready */
+#define CARD_IO_READY              	(0x1U << 3)
+/** Card Control Registers : CIS card ready */
+#define CIS_CARD_RDY                 	(0x1U << 2)
+/** Card Control Registers : Upload card ready */
+#define UP_LD_CARD_RDY               	(0x1U << 1)
+/** Card Control Registers : Download card ready */
+#define DN_LD_CARD_RDY               	(0x1U << 0)
+
+/** Card Control Registers : Host interrupt mask register */
+#define HOST_INTERRUPT_MASK_REG      	0x34
+/** Card Control Registers : Host power interrupt mask */
+#define HOST_POWER_INT_MASK          	(0x1U << 3)
+/** Card Control Registers : Abort card interrupt mask */
+#define ABORT_CARD_INT_MASK          	(0x1U << 2)
+/** Card Control Registers : Upload card interrupt mask */
+#define UP_LD_CARD_INT_MASK          	(0x1U << 1)
+/** Card Control Registers : Download card interrupt mask */
+#define DN_LD_CARD_INT_MASK          	(0x1U << 0)
+
+/** Card Control Registers : Card interrupt status register */
+#define CARD_INTERRUPT_STATUS_REG    	0x38
+/** Card Control Registers : Power up interrupt */
+#define POWER_UP_INT                 	(0x1U << 4)
+/** Card Control Registers : Power down interrupt */
+#define POWER_DOWN_INT               	(0x1U << 3)
+
+/** Card Control Registers : Card interrupt RSR register */
+#define CARD_INTERRUPT_RSR_REG       	0x3c
+/** Card Control Registers : Power up RSR */
+#define POWER_UP_RSR                 	(0x1U << 4)
+/** Card Control Registers : Power down RSR */
+#define POWER_DOWN_RSR               	(0x1U << 3)
+
+/** Card Control Registers : Debug 0 register */
+#define DEBUG_0_REG                  	0x70
+/** Card Control Registers : SD test BUS 0 */
+#define SD_TESTBUS0                  	(0x1U)
+/** Card Control Registers : Debug 1 register */
+#define DEBUG_1_REG                  	0x71
+/** Card Control Registers : SD test BUS 1 */
+#define SD_TESTBUS1                  	(0x1U)
+/** Card Control Registers : Debug 2 register */
+#define DEBUG_2_REG                  	0x72
+/** Card Control Registers : SD test BUS 2 */
+#define SD_TESTBUS2                  	(0x1U)
+/** Card Control Registers : Debug 3 register */
+#define DEBUG_3_REG                  	0x73
+/** Card Control Registers : SD test BUS 3 */
+#define SD_TESTBUS3                  	(0x1U)
+/** Card Control Registers : Card OCR 0 register */
+#define CARD_OCR_0_REG               	0x68
+/** Card Control Registers : Card OCR 1 register */
+#define CARD_OCR_1_REG               	0x69
+/** Card Control Registers : Card OCR 3 register */
+#define CARD_OCR_3_REG               	0x6A
+/** Card Control Registers : Card config register */
+#define CARD_CONFIG_REG              	0x6B
+/** Card Control Registers : Card revision register */
+#define CARD_REVISION_REG            	0x5c
+/** Card Control Registers : Command 53 finish G BUS */
+#define CMD53_FINISH_GBUS            	(0x1U << 1)
+/** Card Control Registers : SD negative edge */
+#define SD_NEG_EDGE                  	(0x1U << 0)
+
+/* Special registers in function 0 of the SDxx card */
+/** Special register in function 0 of the SDxxx card : Scratch 0 */
+#define	SCRATCH_0_REG			0x80fe
+/** Special register in function 0 of the SDxxx card : Scratch 1 */
+#define	SCRATCH_1_REG			0x80ff
+/** Host F1 read base 0 */
+#define HOST_F1_RD_BASE_0		0x0040
+/** Host F1 read base 1 */
+#define HOST_F1_RD_BASE_1		0x0041
+/** Host F1 card ready */
+#define HOST_F1_CARD_RDY		0x0020
+
+/** Chip Id Register 0 */
+#define CARD_CHIP_ID_0_REG		0x801c
+/** Chip Id Register 1 */
+#define CARD_CHIP_ID_1_REG		0x801d
+/** Firmware status 0 register */
+#define CARD_FW_STATUS0_REG		0x60
+/** Firmware status 1 register */
+#define CARD_FW_STATUS1_REG		0x61
+/** Rx length register */
+#define CARD_RX_LEN_REG			0x62
+/** Rx unit register */
+#define CARD_RX_UNIT_REG		0x63
+/** Card Control Registers : Miscellaneous Configuration Register */
+#define CARD_MISC_CFG_REG              	0x6C
+/** Misc. Config Register : Auto Re-enable interrupts */
+#define AUTO_RE_ENABLE_INT  	(0x1U << 4)
+struct sdio_mmc_card
+{
+        /** sdio_func structure pointer */
+    struct sdio_func *func;
+        /** bt_private structure pointer */
+    bt_private *priv;
+};
+/** DMA alignment value */
+#define DMA_ALIGNMENT	64
+/** Macros for Data Alignment : size */
+#define ALIGN_SZ(p, a)	\
+	(((p) + ((a) - 1)) & ~((a) - 1))
+
+/** Macros for Data Alignment : address */
+#define ALIGN_ADDR(p, a)	\
+	((((u32)(p)) + (((u32)(a)) - 1)) & ~(((u32)(a)) - 1))
+
+int sd_read_cmd52_val(bt_private * priv);
+int sd_write_cmd52_val(bt_private * priv, int func, int reg, int val);
+
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+void bt_is_suspended(bt_private * priv);
+#endif
+#endif
+#endif
+#endif /* _BT_SDIO_H_ */
diff --git a/drivers/bluetooth/marvell/bt_sdiommc.c b/drivers/bluetooth/marvell/bt_sdiommc.c
new file mode 100644
index 0000000..53043a8
--- /dev/null
+++ b/drivers/bluetooth/marvell/bt_sdiommc.c
@@ -0,0 +1,1617 @@
+/** @file bt_sdiommc.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ * 
+ * Copyright (C) 2007-2011, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International 
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ * (the "License").  You may use, redistribute and/or modify this File in 
+ * accordance with the terms and conditions of the License, a copy of which 
+ * is available along with the File in the gpl.txt file or by writing to 
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ * this warranty disclaimer.
+ *
+ */
+
+#include "include.h"
+
+/** define marvell vendor id */
+#define MARVELL_VENDOR_ID 0x02df
+
+/** Max retry number of CMD53 write */
+#define MAX_WRITE_IOMEM_RETRY	2
+/** Firmware name */
+static char *fw_name = NULL;
+/** request firmware nowait */
+static int req_fw_nowait = 0;
+/** SDIO multi-fn support */
+static int multi_fn = BIT(2) | BIT(3);
+/** FW header length for CRC check disable */
+#define FW_CRC_HEADER   24
+/** FW header for CRC check disable */
+static u8 fw_crc_header[FW_CRC_HEADER] = {
+	0x01, 0x00, 0x00, 0x00, 0x04, 0xfd, 0x00, 0x04,
+	0x08, 0x00, 0x00, 0x00, 0x26, 0x52, 0x2a, 0x7b,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+
+/** Default firmware name */
+#define DEFAULT_FW_NAME "mrvl/sd8787_uapsta.bin"
+
+/** Function number 2 */
+#define FN2			2
+/** Device ID for SD8787 FN2 */
+#define SD_DEVICE_ID_8787_BT_FN2    0x911A
+/** Device ID for SD8787 FN3 */
+#define SD_DEVICE_ID_8787_BT_FN3    0x911B
+
+static const struct sdio_device_id bt_ids[] = {
+    {SDIO_DEVICE(MARVELL_VENDOR_ID, SD_DEVICE_ID_8787_BT_FN2)},
+    {SDIO_DEVICE(MARVELL_VENDOR_ID, SD_DEVICE_ID_8787_BT_FN3)},
+    {}
+};
+
+static const struct sdio_device_id bt_fn2_ids[] = {
+    {SDIO_DEVICE(MARVELL_VENDOR_ID, SD_DEVICE_ID_8787_BT_FN2)},
+    {}
+};
+
+MODULE_DEVICE_TABLE(sdio, bt_ids);
+
+/********************************************************
+		Global Variables
+********************************************************/
+/** unregiser bus driver flag */
+static u8 unregister = 0;
+#ifdef SDIO_SUSPEND_RESUME
+/** PM keep power */
+extern int pm_keep_power;
+#endif
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/** 
+ *  @brief This function get rx_unit value
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_get_rx_unit(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 reg;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    reg = sdio_readb(card->func, CARD_RX_UNIT_REG, &ret);
+    if (ret == BT_STATUS_SUCCESS)
+        priv->bt_dev.rx_unit = reg;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function reads fwstatus registers
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_read_firmware_status(bt_private * priv, u16 * dat)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 fws0;
+    u8 fws1;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    fws0 = sdio_readb(card->func, CARD_FW_STATUS0_REG, &ret);
+    if (ret < 0) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+
+    fws1 = sdio_readb(card->func, CARD_FW_STATUS1_REG, &ret);
+    if (ret < 0) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+
+    *dat = (((u16) fws1) << 8) | fws0;
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function reads rx length
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   BT_STATUS_SUCCESS or other error no.
+ */
+static int
+sd_read_rx_len(bt_private * priv, u16 * dat)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 reg;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    reg = sdio_readb(card->func, CARD_RX_LEN_REG, &ret);
+    if (ret == BT_STATUS_SUCCESS)
+        *dat = (u16) reg << priv->bt_dev.rx_unit;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function enables the host interrupts mask
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_enable_host_int_mask(bt_private * priv, u8 mask)
+{
+    int ret = BT_STATUS_SUCCESS;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    sdio_writeb(card->func, mask, HOST_INT_MASK_REG, &ret);
+    if (ret) {
+        PRINTM(WARN, "BT: Unable to enable the host interrupt!\n");
+        ret = BT_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**  @brief This function disables the host interrupts mask.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   BT_STATUS_SUCCESS or other error no.
+ */
+static int
+sd_disable_host_int_mask(bt_private * priv, u8 mask)
+{
+    int ret = BT_STATUS_FAILURE;
+    u8 host_int_mask;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    /* Read back the host_int_mask register */
+    host_int_mask = sdio_readb(card->func, HOST_INT_MASK_REG, &ret);
+    if (ret)
+        goto done;
+
+    /* Update with the mask and write back to the register */
+    host_int_mask &= ~mask;
+    sdio_writeb(card->func, host_int_mask, HOST_INT_MASK_REG, &ret);
+    if (ret < 0) {
+        PRINTM(WARN, "BT: Unable to diable the host interrupt!\n");
+        goto done;
+    }
+    ret = BT_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function polls the card status register.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @param bits    	the bit mask
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_poll_card_status(bt_private * priv, u8 bits)
+{
+    int tries;
+    int rval;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+    u8 cs;
+
+    ENTER();
+
+    for (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {
+        cs = sdio_readb(card->func, CARD_STATUS_REG, &rval);
+        if (rval != 0)
+            break;
+        if (rval == 0 && (cs & bits) == bits) {
+            LEAVE();
+            return BT_STATUS_SUCCESS;
+        }
+        udelay(1);
+    }
+    PRINTM(ERROR,
+           "BT: sdio_poll_card_status failed (%d), tries = %d, cs = 0x%x\n",
+           rval, tries, cs);
+
+    LEAVE();
+    return BT_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function reads updates the Cmd52 value in dev structure
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_read_cmd52_val(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 func, reg, val;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    func = priv->bt_dev.cmd52_func;
+    reg = priv->bt_dev.cmd52_reg;
+    sdio_claim_host(card->func);
+    if (func)
+        val = sdio_readb(card->func, reg, &ret);
+    else
+        val = sdio_f0_readb(card->func, reg, &ret);
+    sdio_release_host(card->func);
+    if (ret) {
+        PRINTM(ERROR, "BT: Cannot read value from func %d reg %d\n", func, reg);
+    } else {
+        priv->bt_dev.cmd52_val = val;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function updates card reg based on the Cmd52 value in dev structure
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @param func    	A pointer to store func variable
+ *  @param reg    	A pointer to store reg variable
+ *  @param val    	A pointer to store val variable
+ *  @return 	   	BT_STATUS_SUCCESS or other error no.
+ */
+int
+sd_write_cmd52_val(bt_private * priv, int func, int reg, int val)
+{
+    int ret = BT_STATUS_SUCCESS;
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    if (val >= 0) {
+        /* Perform actual write only if val is provided */
+        sdio_claim_host(card->func);
+        if (func)
+            sdio_writeb(card->func, val, reg, &ret);
+        else
+            sdio_f0_writeb(card->func, val, reg, &ret);
+        sdio_release_host(card->func);
+        if (ret) {
+            PRINTM(ERROR, "BT: Cannot write value (0x%x) to func %d reg %d\n",
+                   val, func, reg);
+            goto done;
+        }
+        priv->bt_dev.cmd52_val = val;
+    }
+
+    /* Save current func and reg for future read */
+    priv->bt_dev.cmd52_func = func;
+    priv->bt_dev.cmd52_reg = reg;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function probe the card
+ *  
+ *  @param func    A pointer to sdio_func structure.
+ *  @param id	   A pointer to structure sd_device_id	
+ *  @return 	   BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+static int
+sd_probe_card(struct sdio_func *func, const struct sdio_device_id *id)
+{
+    int ret = BT_STATUS_SUCCESS;
+    bt_private *priv = NULL;
+    struct sdio_mmc_card *card = NULL;
+
+    ENTER();
+
+    PRINTM(INFO, "BT: vendor=0x%x,device=0x%x,class=%d,fn=%d\n", id->vendor,
+           id->device, id->class, func->num);
+    card = kzalloc(sizeof(struct sdio_mmc_card), GFP_KERNEL);
+    if (!card) {
+        ret = -ENOMEM;
+        goto done;
+    }
+    card->func = func;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+    /* wait for chip fully wake up */
+    if (!func->enable_timeout)
+        func->enable_timeout = 200;
+#endif
+    sdio_claim_host(func);
+    ret = sdio_enable_func(func);
+    if (ret) {
+        sdio_disable_func(func);
+        sdio_release_host(func);
+        PRINTM(FATAL, "BT: sdio_enable_func() failed: ret=%d\n", ret);
+        kfree(card);
+        LEAVE();
+        return -EIO;
+    }
+    sdio_release_host(func);
+    priv = bt_add_card(card);
+    if (!priv) {
+        sdio_claim_host(func);
+        sdio_disable_func(func);
+        sdio_release_host(func);
+        ret = BT_STATUS_FAILURE;
+        kfree(card);
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *  
+ *  @param priv     A pointer to bt_private structure
+ *  @param pollnum  Number of times to poll fw status 
+ *  @return         BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_verify_fw_download(bt_private * priv, int pollnum)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u16 firmwarestat;
+    int tries;
+
+    ENTER();
+
+    /* Wait for firmware initialization event */
+    for (tries = 0; tries < pollnum; tries++) {
+        if (sd_read_firmware_status(priv, &firmwarestat) < 0)
+            continue;
+        if (firmwarestat == FIRMWARE_READY) {
+            PRINTM(MSG, "BT FW is active(%d)\n", tries);
+            ret = BT_STATUS_SUCCESS;
+            break;
+        } else {
+            mdelay(100);
+            ret = BT_STATUS_FAILURE;
+        }
+    }
+    if (ret < 0)
+        goto done;
+
+    ret = BT_STATUS_SUCCESS;
+  done:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief Transfer firmware to card
+ *  
+ *  @param priv      A Pointer to bt_private structure
+ *  @return 	     BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.	
+ */
+static int
+sd_init_fw_dpc(bt_private * priv)
+{
+    struct sdio_mmc_card *card = (struct sdio_mmc_card *) priv->bt_dev.card;
+    u8 *firmware = NULL;
+    int firmwarelen;
+    u8 base0;
+    u8 base1;
+    int ret = BT_STATUS_SUCCESS;
+    int offset;
+    void *tmpfwbuf = NULL;
+    int tmpfwbufsz;
+    u8 *fwbuf;
+    u16 len;
+    int txlen = 0;
+    int tx_blocks = 0;
+    int i = 0;
+    int tries = 0;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+    u8 crc_buffer = 0;
+
+    ENTER();
+    firmware = (u8 *) priv->firmware->data;
+    firmwarelen = priv->firmware->size;
+
+    PRINTM(INFO, "BT: Downloading FW image (%d bytes)\n", firmwarelen);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+    tmpfwbufsz = ALIGN_SZ(BT_UPLD_SIZE, DMA_ALIGNMENT);
+    tmpfwbuf = kmalloc(tmpfwbufsz, GFP_KERNEL);
+    if (!tmpfwbuf) {
+        PRINTM(ERROR,
+               "BT: Unable to allocate buffer for firmware. Terminating download\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmpfwbuf, 0, tmpfwbufsz);
+    /* Ensure 8-byte aligned firmware buffer */
+    fwbuf = (u8 *) ALIGN_ADDR(tmpfwbuf, DMA_ALIGNMENT);
+
+    if (!(priv->fw_crc_check)) {
+        /* CRC check not required, use custom header first */
+        firmware = fw_crc_header;
+        firmwarelen = FW_CRC_HEADER;
+        crc_buffer = 1;
+    }
+
+    /* Perform firmware data transfer */
+    offset = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = sd_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL,
+                   "BT: FW download with helper poll status timeout @ %d\n",
+                   offset);
+            goto done;
+        }
+
+        if (!crc_buffer)
+            /* More data? */
+            if (offset >= firmwarelen)
+                break;
+
+        for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+            base0 = sdio_readb(card->func, SQ_READ_BASE_ADDRESS_A0_REG, &ret);
+            if (ret) {
+                PRINTM(WARN, "Dev BASE0 register read failed:"
+                       " base0=0x%04X(%d). Terminating download\n", base0,
+                       base0);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            base1 = sdio_readb(card->func, SQ_READ_BASE_ADDRESS_A1_REG, &ret);
+            if (ret) {
+                PRINTM(WARN, "Dev BASE1 register read failed:"
+                       " base1=0x%04X(%d). Terminating download\n", base1,
+                       base1);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            len = (((u16) base1) << 8) | base0;
+
+            if (len != 0)
+                break;
+            udelay(10);
+        }
+
+        if (len == 0)
+            break;
+        else if (len > BT_UPLD_SIZE) {
+            PRINTM(FATAL, "BT: FW download failure @ %d, invalid length %d\n",
+                   offset, len);
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+
+        txlen = len;
+
+        if (len & BIT(0)) {
+            i++;
+            if (i > MAX_WRITE_IOMEM_RETRY) {
+                PRINTM(FATAL,
+                       "BT: FW download failure @ %d, over max retry count\n",
+                       offset);
+                ret = BT_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(ERROR, "BT: FW CRC error indicated by the helper:"
+                   " len = 0x%04X, txlen = %d\n", len, txlen);
+            len &= ~BIT(0);
+
+            PRINTM(ERROR, "BT: retry: %d, offset %d\n", i, offset);
+            DBG_HEXDUMP(ERROR, "BT: FW block:", fwbuf, len);
+
+            /* Setting this to 0 to resend from same offset */
+            txlen = 0;
+        } else {
+            i = 0;
+
+            /* Set blocksize to transfer - checking for last block */
+            if (firmwarelen - offset < txlen)
+                txlen = firmwarelen - offset;
+
+            PRINTM(INFO, ".");
+
+            tx_blocks = (txlen + SD_BLOCK_SIZE_FW_DL - 1) / SD_BLOCK_SIZE_FW_DL;
+
+            /* Copy payload to buffer */
+            memcpy(fwbuf, &firmware[offset], txlen);
+        }
+
+        /* Send data */
+        ret =
+            sdio_writesb(card->func, priv->bt_dev.ioport, fwbuf,
+                         tx_blocks * SD_BLOCK_SIZE_FW_DL);
+
+        if (ret < 0) {
+            PRINTM(ERROR, "BT: FW download, write iomem (%d) failed @ %d\n", i,
+                   offset);
+            sdio_writeb(card->func, 0x04, CONFIGURATION_REG, &ret);
+            if (ret)
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+        }
+
+        offset += txlen;
+        if (crc_buffer) {
+            if (offset >= FW_CRC_HEADER) {
+                /* Custom header download complete, restore original FW */
+                offset = 0;
+                firmware = (u8 *) priv->firmware->data;
+                firmwarelen = priv->firmware->size;
+                crc_buffer = 0;
+            }
+        }
+    } while (TRUE);
+
+    PRINTM(INFO, "\nBT: FW download over, size %d bytes\n", offset);
+
+    ret = BT_STATUS_SUCCESS;
+  done:
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "FW: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+    if (tmpfwbuf)
+        kfree(tmpfwbuf);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ * @brief request_firmware callback
+ *  
+ * @param fw_firmware  A pointer to firmware structure
+ * @param context      A Pointer to bt_private structure
+ * @return             BT_STATUS_SUCCESS or BT_STATUS_FAILURE    
+ */
+static int
+sd_request_fw_dpc(const struct firmware *fw_firmware, void *context)
+{
+    int ret = BT_STATUS_SUCCESS;
+    bt_private *priv = (bt_private *) context;
+    struct sdio_mmc_card *card = NULL;
+    struct hci_dev *hdev = NULL;
+    struct timeval tstamp;
+
+    ENTER();
+
+    if ((priv == NULL) || (priv->adapter == NULL) || (priv->bt_dev.card == NULL)
+        || (priv->bt_dev.hcidev == NULL)) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+
+    card = (struct sdio_mmc_card *) priv->bt_dev.card;
+    hdev = priv->bt_dev.hcidev;
+
+    if (!fw_firmware) {
+        do_gettimeofday(&tstamp);
+        if (tstamp.tv_sec > (priv->req_fw_time.tv_sec + REQUEST_FW_TIMEOUT)) {
+            PRINTM(ERROR, "BT: No firmware image found. Skipping download\n");
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        PRINTM(ERROR, "BT: No firmware image found! Retrying download\n");
+        /* Wait a second here before calling the callback again */
+        os_sched_timeout(1000);
+        sd_download_firmware_w_helper(priv);
+        LEAVE();
+        return ret;
+    }
+
+    priv->firmware = fw_firmware;
+    if (BT_STATUS_FAILURE == sd_init_fw_dpc(priv)) {
+        PRINTM(ERROR,
+               "BT: sd_init_fw_dpc failed (download fw with nowait: %d). Terminating download\n",
+               req_fw_nowait);
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* check if the fimware is downloaded successfully or not */
+    if (sd_verify_fw_download(priv, MAX_FIRMWARE_POLL_TRIES)) {
+        PRINTM(ERROR, "BT: FW failed to be active in time!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    sdio_release_host(card->func);
+    sbi_enable_host_int(priv);
+    if (BT_STATUS_FAILURE == sd_register_conf_dpc(priv)) {
+        PRINTM(ERROR,
+               "BT: sd_register_conf_dpc failed. Terminating download\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    if (fw_firmware) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+        if (!req_fw_nowait)
+#endif
+            release_firmware(fw_firmware);
+    }
+    LEAVE();
+    return ret;
+
+  done:
+    if (fw_firmware) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+        if (!req_fw_nowait)
+#endif
+            release_firmware(fw_firmware);
+    }
+    hdev->dev = *priv->hotplug_device;
+    /* For synchronous download cleanup will be done in add_card */
+    if (!req_fw_nowait)
+        return ret;
+    sdio_release_host(card->func);
+    PRINTM(INFO, "unregister device\n");
+    sbi_unregister_dev(priv);
+    ((struct sdio_mmc_card *) card)->priv = NULL;
+    /* Stop the thread servicing the interrupts */
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+    if (hdev)
+        hci_free_dev(hdev);
+    if (priv->adapter)
+        bt_free_adapter(priv);
+    kfree(priv);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ * @brief request_firmware callback
+ *        This function is invoked by request_firmware_nowait system call
+ * 
+ * @param firmware     A pointer to firmware structure
+ * @param context      A Pointer to bt_private structure
+ * @return             None    
+ **/
+static void
+sd_request_fw_callback(const struct firmware *firmware, void *context)
+{
+    ENTER();
+    sd_request_fw_dpc(firmware, context);
+    LEAVE();
+    return;
+}
+
+/** 
+ *  @brief This function downloads firmware image to the card.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sd_download_firmware_w_helper(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    int err;
+    char *cur_fw_name = NULL;
+
+    ENTER();
+
+    cur_fw_name = fw_name;
+
+    if (req_fw_nowait) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32)
+        if ((ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+                                           cur_fw_name, priv->hotplug_device,
+                                           GFP_KERNEL, priv,
+                                           sd_request_fw_callback)) < 0)
+#else
+        if ((ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+                                           cur_fw_name, priv->hotplug_device,
+                                           priv, sd_request_fw_callback)) < 0)
+#endif
+            PRINTM(FATAL,
+                   "BT: request_firmware_nowait() failed, error code = %#x\n",
+                   ret);
+    } else {
+        if ((err =
+             request_firmware(&priv->firmware, cur_fw_name,
+                              priv->hotplug_device)) < 0) {
+            PRINTM(FATAL, "BT: request_firmware() failed, error code = %#x\n",
+                   err);
+            ret = BT_STATUS_FAILURE;
+        } else
+            ret = sd_request_fw_dpc(priv->firmware, priv);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function reads data from the card.
+ *  
+ *  @param priv    	A pointer to bt_private structure
+ *  @return 	   	BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+static int
+sd_card_to_host(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u16 buf_len = 0;
+    int buf_block_len;
+    int blksz;
+    struct sk_buff *skb = NULL;
+    u32 type;
+    u8 *payload = NULL;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "BT: card or function is NULL!\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Read the length of data to be transferred */
+    ret = sd_read_rx_len(priv, &buf_len);
+    if (ret < 0) {
+        PRINTM(ERROR, "BT: card_to_host, read scratch reg failed\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Allocate buffer */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (buf_len + blksz - 1) / blksz;
+    if (buf_len <= BT_HEADER_LEN || (buf_block_len * blksz) > ALLOC_BUF_SIZE) {
+        PRINTM(ERROR, "BT: card_to_host, invalid packet length: %d\n", buf_len);
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    skb = bt_skb_alloc(buf_block_len * blksz + DMA_ALIGNMENT, GFP_ATOMIC);
+    if (skb == NULL) {
+        PRINTM(WARN, "BT: No free skb\n");
+        goto exit;
+    }
+    if ((u32) skb->data & (DMA_ALIGNMENT - 1)) {
+        skb_put(skb, DMA_ALIGNMENT - ((u32) skb->data & (DMA_ALIGNMENT - 1)));
+        skb_pull(skb, DMA_ALIGNMENT - ((u32) skb->data & (DMA_ALIGNMENT - 1)));
+    }
+
+    payload = skb->tail;
+    ret = sdio_readsb(card->func, payload, priv->bt_dev.ioport,
+                      buf_block_len * blksz);
+    if (ret < 0) {
+        PRINTM(ERROR, "BT: card_to_host, read iomem failed: %d\n", ret);
+        kfree_skb(skb);
+        skb = NULL;
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+    /* This is SDIO specific header length: byte[2][1][0], type: byte[3]
+       (HCI_COMMAND = 1, ACL_DATA = 2, SCO_DATA = 3, 0xFE = Vendor) */
+    buf_len = payload[0];
+    buf_len |= (u16) payload[1] << 8;
+    type = payload[3];
+    PRINTM(DATA, "BT: SDIO Blk Rd %s: len=%d type=%d\n", hdev->name, buf_len,
+           type);
+    if (buf_len > buf_block_len * blksz) {
+        PRINTM(ERROR,
+               "BT: Drop invalid rx pkt, len in hdr=%d, cmd53 length=%d\n",
+               buf_len, buf_block_len * blksz);
+        ret = BT_STATUS_FAILURE;
+        kfree_skb(skb);
+        skb = NULL;
+        goto exit;
+    }
+    DBG_HEXDUMP(DAT_D, "BT: SDIO Blk Rd", payload, buf_len);
+    switch (type) {
+    case HCI_ACLDATA_PKT:
+    case HCI_SCODATA_PKT:
+    case HCI_EVENT_PKT:
+        bt_cb(skb)->pkt_type = type;
+        skb->dev = (void *) hdev;
+        skb_put(skb, buf_len);
+        skb_pull(skb, BT_HEADER_LEN);
+        if (type == HCI_EVENT_PKT) {
+            if (BT_STATUS_SUCCESS == check_evtpkt(priv, skb))
+                break;
+        }
+        hci_recv_frame(skb);
+        hdev->stat.byte_rx += buf_len;
+        break;
+    case MRVL_VENDOR_PKT:
+        bt_cb(skb)->pkt_type = HCI_VENDOR_PKT;
+        skb->dev = (void *) hdev;
+        skb_put(skb, buf_len);
+        skb_pull(skb, BT_HEADER_LEN);
+        if (BT_STATUS_SUCCESS != bt_process_event(priv, skb))
+            hci_recv_frame(skb);
+        hdev->stat.byte_rx += buf_len;
+        break;
+    default:
+        /* Driver specified event and command resp should be handle here */
+        PRINTM(INFO, "BT: Unknown PKT type:%d\n", type);
+        kfree_skb(skb);
+        skb = NULL;
+        break;
+    }
+  exit:
+    if (ret) {
+        hdev->stat.err_rx++;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function removes the card
+ *  
+ *  @param func    A pointer to sdio_func structure
+ *  @return        N/A
+ */
+static void
+sd_remove_card(struct sdio_func *func)
+{
+    struct sdio_mmc_card *card;
+
+    ENTER();
+
+    if (func) {
+        card = sdio_get_drvdata(func);
+        if (card) {
+            if (!unregister && card->priv) {
+                PRINTM(INFO, "BT: card removed from sd slot\n");
+                ((bt_private *) (card->priv))->adapter->SurpriseRemoved = TRUE;
+            }
+            bt_remove_card(card->priv);
+            kfree(card);
+        }
+    }
+
+    LEAVE();
+}
+
+/** 
+ *  @brief This function handles the interrupt.
+ *  
+ *  @param func  A pointer to sdio_func structure
+ *  @return      N/A
+ */
+static void
+sd_interrupt(struct sdio_func *func)
+{
+    bt_private *priv;
+    struct hci_dev *hcidev;
+    struct sdio_mmc_card *card;
+    int ret = BT_STATUS_SUCCESS;
+    u8 ireg = 0;
+
+    ENTER();
+
+    card = sdio_get_drvdata(func);
+    if (!card || !card->priv) {
+        PRINTM(INFO,
+               "BT: %s: sbi_interrupt(%p) card or priv is NULL, card=%p\n",
+               __FUNCTION__, func, card);
+        LEAVE();
+        return;
+    }
+    priv = card->priv;
+    hcidev = priv->bt_dev.hcidev;
+
+    ireg = sdio_readb(card->func, HOST_INTSTATUS_REG, &ret);
+    if (ret) {
+        PRINTM(WARN, "BT: sdio_read_ioreg: read int status register failed\n");
+        goto done;
+    }
+    if (ireg != 0) {
+        /* 
+         * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+         * Clear the interrupt status register and re-enable the interrupt
+         */
+        PRINTM(INTR, "BT: INT %s: sdio_ireg = 0x%x\n", hcidev->name, ireg);
+        priv->adapter->irq_recv = ireg;
+    } else {
+        PRINTM(ERROR, "BT: ERR: ireg=0\n");
+    }
+    OS_INT_DISABLE;
+    priv->adapter->sd_ireg |= ireg;
+    OS_INT_RESTORE;
+    bt_interrupt(hcidev);
+  done:
+    LEAVE();
+}
+
+/** 
+ *  @brief This function checks if the interface is ready to download
+ *  or not while other download interfaces are present
+ *  
+ *  @param priv   A pointer to bt_private structure
+ *  @param val    Winner status (0: winner)
+ *  @return       BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sd_check_winner_status(bt_private * priv, u8 * val)
+{
+
+    int ret = BT_STATUS_SUCCESS;
+    u8 winner = 0;
+    struct sdio_mmc_card *cardp = (struct sdio_mmc_card *) priv->bt_dev.card;
+
+    ENTER();
+
+    winner = sdio_readb(cardp->func, CARD_FW_STATUS0_REG, &ret);
+    if (ret != BT_STATUS_SUCCESS) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    *val = winner;
+
+    LEAVE();
+    return ret;
+}
+
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+#ifdef MMC_PM_FUNC_SUSPENDED
+/**  @brief This function tells lower driver that BT is suspended
+ *
+ *  @param priv    A pointer to bt_private structure
+ *  @return        None
+ */
+void
+bt_is_suspended(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    priv->adapter->is_suspended = TRUE;
+    sdio_func_suspended(card->func);
+}
+#endif
+
+/**  @brief This function handles client driver suspend
+ *  
+ *  @param dev	   A pointer to device structure
+ *  @return 	   BT_STATUS_SUCCESS or other error no.
+ */
+int
+bt_sdio_suspend(struct device *dev)
+{
+    struct sdio_func *func = dev_to_sdio_func(dev);
+    mmc_pm_flag_t pm_flags = 0;
+    bt_private *priv = NULL;
+    struct sdio_mmc_card *cardp;
+    struct hci_dev *hcidev;
+
+    ENTER();
+
+    if (func) {
+        pm_flags = sdio_get_host_pm_caps(func);
+        PRINTM(CMD, "BT: %s: suspend: PM flags = 0x%x\n", sdio_func_id(func),
+               pm_flags);
+        if (!(pm_flags & MMC_PM_KEEP_POWER)) {
+            PRINTM(ERROR,
+                   "BT: %s: cannot remain alive while host is suspended\n",
+                   sdio_func_id(func));
+            return -ENOSYS;
+        }
+        cardp = sdio_get_drvdata(func);
+        if (!cardp || !cardp->priv) {
+            PRINTM(ERROR, "BT: Card or priv structure is not valid\n");
+            LEAVE();
+            return BT_STATUS_SUCCESS;
+        }
+    } else {
+        PRINTM(ERROR, "BT: sdio_func is not specified\n");
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    priv = cardp->priv;
+
+    if ((pm_keep_power) && (priv->adapter->hs_state != HS_ACTIVATED)) {
+        if (BT_STATUS_SUCCESS != bt_enable_hs(priv)) {
+            PRINTM(CMD, "BT: HS not actived, suspend fail!\n");
+            LEAVE();
+            return -EBUSY;
+        }
+    }
+    hcidev = priv->bt_dev.hcidev;
+    PRINTM(CMD, "BT %s: SDIO suspend\n", hcidev->name);
+    hci_suspend_dev(hcidev);
+    skb_queue_purge(&priv->adapter->tx_queue);
+
+    priv->adapter->is_suspended = TRUE;
+    LEAVE();
+    /* We will keep the power when hs enabled successfully */
+    if ((pm_keep_power) && (priv->adapter->hs_state == HS_ACTIVATED)) {
+#ifdef MMC_PM_SKIP_RESUME_PROBE
+        PRINTM(CMD, "BT: suspend with MMC_PM_KEEP_POWER and "
+               "MMC_PM_SKIP_RESUME_PROBE\n");
+        return sdio_set_host_pm_flags(func,
+                                      MMC_PM_KEEP_POWER |
+                                      MMC_PM_SKIP_RESUME_PROBE);
+#else
+        PRINTM(CMD, "BT: suspend with MMC_PM_KEEP_POWER\n");
+        return sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+#endif
+    } else {
+        PRINTM(CMD, "BT: suspend without MMC_PM_KEEP_POWER\n");
+        return BT_STATUS_SUCCESS;
+    }
+}
+
+/**  @brief This function handles client driver resume
+ *  
+ *  @param dev	   A pointer to device structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+bt_sdio_resume(struct device *dev)
+{
+    struct sdio_func *func = dev_to_sdio_func(dev);
+    mmc_pm_flag_t pm_flags = 0;
+    bt_private *priv = NULL;
+    struct sdio_mmc_card *cardp;
+    struct hci_dev *hcidev;
+
+    ENTER();
+    if (func) {
+        pm_flags = sdio_get_host_pm_caps(func);
+        PRINTM(CMD, "BT: %s: resume: PM flags = 0x%x\n", sdio_func_id(func),
+               pm_flags);
+        cardp = sdio_get_drvdata(func);
+        if (!cardp || !cardp->priv) {
+            PRINTM(ERROR, "BT: Card or priv structure is not valid\n");
+            LEAVE();
+            return BT_STATUS_SUCCESS;
+        }
+    } else {
+        PRINTM(ERROR, "BT: sdio_func is not specified\n");
+        LEAVE();
+        return BT_STATUS_SUCCESS;
+    }
+    priv = cardp->priv;
+    priv->adapter->is_suspended = FALSE;
+    hcidev = priv->bt_dev.hcidev;
+    PRINTM(CMD, "BT %s: SDIO resume\n", hcidev->name);
+    hci_resume_dev(hcidev);
+    sbi_wakeup_firmware(priv);
+    priv->adapter->hs_state = HS_DEACTIVATED;
+    PRINTM(CMD, "BT:%s: HS DEACTIVATED in Resume!\n", hcidev->name);
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+#endif
+#endif
+
+/********************************************************
+		Global Functions
+********************************************************/
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+static struct dev_pm_ops bt_sdio_pm_ops = {
+    .suspend = bt_sdio_suspend,
+    .resume = bt_sdio_resume,
+};
+#endif
+#endif
+static struct sdio_driver sdio_bt = {
+    .name = "sdio_bt",
+    .id_table = bt_ids,
+    .probe = sd_probe_card,
+    .remove = sd_remove_card,
+#ifdef SDIO_SUSPEND_RESUME
+#ifdef MMC_PM_KEEP_POWER
+    .drv = {
+            .pm = &bt_sdio_pm_ops,
+            }
+#endif
+#endif
+};
+
+/** 
+ *  @brief This function registers the bt module in bus driver.
+ *  
+ *  @return	   An int pointer that keeps returned value
+ */
+int *
+sbi_register(void)
+{
+    int *ret;
+
+    ENTER();
+
+    if (multi_fn == BIT(2))
+        sdio_bt.id_table = bt_fn2_ids;
+    if (sdio_register_driver(&sdio_bt) != 0) {
+        PRINTM(FATAL, "BT: SD Driver Registration Failed \n");
+        LEAVE();
+        return NULL;
+    } else
+        ret = (int *) 1;
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function de-registers the bt module in bus driver.
+ *  
+ *  @return 	   N/A
+ */
+void
+sbi_unregister(void)
+{
+    ENTER();
+    unregister = TRUE;
+    sdio_unregister_driver(&sdio_bt);
+    LEAVE();
+}
+
+/** 
+ *  @brief This function registers the device.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_register_dev(bt_private * priv)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 reg;
+    u8 chiprev;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    struct sdio_func *func;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "BT: Error: card or function is NULL!\n");
+        goto failed;
+    }
+    func = card->func;
+    priv->hotplug_device = &func->dev;
+    if (fw_name == NULL)
+        fw_name = DEFAULT_FW_NAME;
+
+    /* Initialize the private structure */
+    strncpy(priv->bt_dev.name, "bt_sdio0", sizeof(priv->bt_dev.name));
+    priv->bt_dev.ioport = 0;
+    priv->bt_dev.fn = func->num;
+
+    sdio_claim_host(func);
+    ret = sdio_claim_irq(func, sd_interrupt);
+    if (ret) {
+        PRINTM(FATAL, "BT: sdio_claim_irq failed: ret=%d\n", ret);
+        goto release_host;
+    }
+    ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE);
+    if (ret) {
+        PRINTM(FATAL, "BT: %s: cannot set SDIO block size\n", __FUNCTION__);
+        goto release_irq;
+    }
+
+    /* read Revision Register to get the chip revision number */
+    chiprev = sdio_readb(func, CARD_REVISION_REG, &ret);
+    if (ret) {
+        PRINTM(FATAL, "BT: cannot read CARD_REVISION_REG\n");
+        goto release_irq;
+    }
+    priv->adapter->chip_rev = chiprev;
+    PRINTM(INFO, "revision=%#x\n", chiprev);
+
+    /* 
+     * Read the HOST_INTSTATUS_REG for ACK the first interrupt got
+     * from the bootloader. If we don't do this we get a interrupt
+     * as soon as we register the irq. 
+     */
+    reg = sdio_readb(func, HOST_INTSTATUS_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+
+    /* Read the IO port */
+    reg = sdio_readb(func, IO_PORT_0_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= reg;
+
+    reg = sdio_readb(func, IO_PORT_1_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= (reg << 8);
+
+    reg = sdio_readb(func, IO_PORT_2_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    else
+        priv->bt_dev.ioport |= (reg << 16);
+
+    PRINTM(INFO, "BT: SDIO FUNC%d IO port: 0x%x\n", priv->bt_dev.fn,
+           priv->bt_dev.ioport);
+#define SDIO_INT_MASK       0x3F
+    /* Set Host interrupt reset to read to clear */
+    reg = sdio_readb(func, HOST_INT_RSR_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    sdio_writeb(func, reg | SDIO_INT_MASK, HOST_INT_RSR_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    /* Set auto re-enable */
+    reg = sdio_readb(func, CARD_MISC_CFG_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+    sdio_writeb(func, reg | AUTO_RE_ENABLE_INT, CARD_MISC_CFG_REG, &ret);
+    if (ret < 0)
+        goto release_irq;
+
+    sdio_set_drvdata(func, card);
+    sdio_release_host(func);
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+  release_irq:
+    sdio_release_irq(func);
+  release_host:
+    sdio_release_host(func);
+  failed:
+
+    LEAVE();
+    return BT_STATUS_FAILURE;
+}
+
+/** 
+ *  @brief This function de-registers the device.
+ *  
+ *  @param priv    A pointer to  bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+
+    ENTER();
+
+    if (card && card->func) {
+        sdio_claim_host(card->func);
+        sdio_release_irq(card->func);
+        sdio_disable_func(card->func);
+        sdio_release_host(card->func);
+        sdio_set_drvdata(card->func, NULL);
+    }
+
+    LEAVE();
+    return BT_STATUS_SUCCESS;
+}
+
+/** 
+ *  @brief This function enables the host interrupts.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_enable_host_int(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    ret = sd_enable_host_int_mask(priv, HIM_ENABLE);
+    sd_get_rx_unit(priv);
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function disables the host interrupts.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sbi_disable_host_int(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    ret = sd_disable_host_int_mask(priv, HIM_DISABLE);
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/**  
+ *  @brief This function sends data to the card.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb	   Length of data/cmd
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(bt_private * priv, u8 * payload, u16 nb)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+    int buf_block_len;
+    int blksz;
+    int i = 0;
+    u8 *buf = NULL;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+    void *tmpbuf = NULL;
+    int tmpbufsz;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "BT: card or function is NULL!\n");
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    buf = payload;
+
+    /* Allocate buffer and copy payload */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (nb + blksz - 1) / blksz;
+    if ((u32) payload & (DMA_ALIGNMENT - 1)) {
+        tmpbufsz = buf_block_len * blksz + DMA_ALIGNMENT;
+        tmpbuf = kmalloc(tmpbufsz, GFP_KERNEL);
+        memset(tmpbuf, 0, tmpbufsz);
+        /* Ensure 8-byte aligned CMD buffer */
+        buf = (u8 *) ALIGN_ADDR(tmpbuf, DMA_ALIGNMENT);
+        memcpy(buf, payload, nb);
+    }
+    sdio_claim_host(card->func);
+#define MAX_WRITE_IOMEM_RETRY	2
+    do {
+        /* Transfer data to card */
+        ret = sdio_writesb(card->func, priv->bt_dev.ioport, buf,
+                           buf_block_len * blksz);
+        if (ret < 0) {
+            i++;
+            PRINTM(ERROR, "BT: host_to_card, write iomem (%d) failed: %d\n", i,
+                   ret);
+            sdio_writeb(card->func, HOST_WO_CMD53_FINISH_HOST,
+                        CONFIGURATION_REG, &ret);
+            udelay(20);
+            ret = BT_STATUS_FAILURE;
+            if (i > MAX_WRITE_IOMEM_RETRY)
+                goto exit;
+        } else {
+            DBG_HEXDUMP(DAT_D, "BT: SDIO Blk Wr", payload, nb);
+            PRINTM(DATA, "BT: SDIO Blk Wr %s: len=%d\n", hdev->name, nb);
+        }
+    } while (ret == BT_STATUS_FAILURE);
+    priv->bt_dev.tx_dnld_rdy = FALSE;
+  exit:
+    sdio_release_host(card->func);
+    if (tmpbuf)
+        kfree(tmpbuf);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function initializes firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS or BT_STATUS_FAILURE
+ */
+int
+sbi_download_fw(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+    int poll_num = MAX_FIRMWARE_POLL_TRIES;
+    u8 winner = 0;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "BT: card or function is NULL!\n");
+        ret = BT_STATUS_FAILURE;
+        goto exit;
+    }
+
+    sdio_claim_host(card->func);
+    if (BT_STATUS_SUCCESS == sd_verify_fw_download(priv, 1)) {
+        PRINTM(MSG, "BT: FW already downloaded!\n");
+        sdio_release_host(card->func);
+        sbi_enable_host_int(priv);
+        if (BT_STATUS_FAILURE == sd_register_conf_dpc(priv)) {
+            PRINTM(ERROR,
+                   "BT: sd_register_conf_dpc failed. Terminating download\n");
+            ret = BT_STATUS_FAILURE;
+        }
+        goto exit;
+    }
+    /* Check if other interface is downloading */
+    ret = sd_check_winner_status(priv, &winner);
+    if (ret == BT_STATUS_FAILURE) {
+        PRINTM(FATAL, "BT read winner status failed!\n");
+        goto done;
+    }
+    if (winner) {
+        PRINTM(MSG, "BT is not the winner (0x%x). Skip FW download\n", winner);
+        poll_num = MAX_MULTI_INTERFACE_POLL_TRIES;
+        /* check if the fimware is downloaded successfully or not */
+        if (sd_verify_fw_download(priv, poll_num)) {
+            PRINTM(FATAL, "BT: FW failed to be active in time!\n");
+            ret = BT_STATUS_FAILURE;
+            goto done;
+        }
+        sdio_release_host(card->func);
+        sbi_enable_host_int(priv);
+        if (BT_STATUS_FAILURE == sd_register_conf_dpc(priv)) {
+            PRINTM(ERROR,
+                   "BT: sd_register_conf_dpc failed. Terminating download\n");
+            ret = BT_STATUS_FAILURE;
+        }
+        goto exit;
+    }
+
+    do_gettimeofday(&priv->req_fw_time);
+    /* Download the main firmware via the helper firmware */
+    if (sd_download_firmware_w_helper(priv)) {
+        PRINTM(INFO, "BT: FW download failed!\n");
+        ret = BT_STATUS_FAILURE;
+        goto done;
+    }
+    goto exit;
+  done:
+    sdio_release_host(card->func);
+  exit:
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @param ireg    A pointer to variable that keeps returned value
+ *  @return 	   BT_STATUS_SUCCESS 
+ */
+int
+sbi_get_int_status(bt_private * priv, u8 * ireg)
+{
+    int ret = BT_STATUS_SUCCESS;
+    u8 sdio_ireg = 0;
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    struct hci_dev *hdev = priv->bt_dev.hcidev;
+
+    ENTER();
+
+    *ireg = 0;
+    OS_INT_DISABLE;
+    sdio_ireg = priv->adapter->sd_ireg;
+    priv->adapter->sd_ireg = 0;
+    OS_INT_RESTORE;
+    sdio_claim_host(card->func);
+    PRINTM(INTR, "BT: get_int_status %s: sdio_ireg=0x%x\n", hdev->name,
+           sdio_ireg);
+    priv->adapter->irq_done = sdio_ireg;
+    if (sdio_ireg & DN_LD_HOST_INT_STATUS) {    /* tx_done INT */
+        if (priv->bt_dev.tx_dnld_rdy) { /* tx_done already received */
+            PRINTM(INFO,
+                   "BT: warning: tx_done already received: tx_dnld_rdy=0x%x int status=0x%x\n",
+                   priv->bt_dev.tx_dnld_rdy, sdio_ireg);
+        } else {
+            priv->bt_dev.tx_dnld_rdy = TRUE;
+        }
+    }
+    if (sdio_ireg & UP_LD_HOST_INT_STATUS)
+        sd_card_to_host(priv);
+
+    *ireg = sdio_ireg;
+    ret = BT_STATUS_SUCCESS;
+    sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
+
+/** 
+ *  @brief This function wakeup firmware
+ *  
+ *  @param priv    A pointer to bt_private structure
+ *  @return 	   BT_STATUS_SUCCESS/BT_STATUS_FAILURE or other error no.
+ */
+int
+sbi_wakeup_firmware(bt_private * priv)
+{
+    struct sdio_mmc_card *card = priv->bt_dev.card;
+    int ret = BT_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "BT: card or function is NULL!\n");
+        LEAVE();
+        return BT_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
+    sdio_release_host(card->func);
+    PRINTM(CMD, "BT wake up firmware\n");
+
+    LEAVE();
+    return ret;
+}
+
+module_param(fw_name, charp, 0);
+MODULE_PARM_DESC(fw_name, "Firmware name");
+module_param(req_fw_nowait, int, 0);
+MODULE_PARM_DESC(req_fw_nowait,
+                 "0: Use request_firmware API; 1: Use request_firmware_nowait API");
+module_param(multi_fn, int, 12);
+MODULE_PARM_DESC(multi_fn, "Bit 2: FN2; Bit 3: FN3");
diff --git a/drivers/bluetooth/marvell/include.h b/drivers/bluetooth/marvell/include.h
new file mode 100644
index 0000000..e0c9387
--- /dev/null
+++ b/drivers/bluetooth/marvell/include.h
@@ -0,0 +1,47 @@
+/** @file include.h
+ *  @brief This file contains all the necessary include file.
+ *       
+ *  Copyright (C) 2007-2011, Marvell International Ltd.
+ *
+ *  This software file (the "File") is distributed by Marvell International 
+ *  Ltd. under the terms of the GNU General Public License Version 2, June 1991 
+ *  (the "License").  You may use, redistribute and/or modify this File in 
+ *  accordance with the terms and conditions of the License, a copy of which 
+ *  is available along with the File in the gpl.txt file or by writing to 
+ *  the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 
+ *  02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ *  THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE 
+ *  IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE 
+ *  ARE EXPRESSLY DISCLAIMED.  The License provides additional details about 
+ *  this warranty disclaimer.
+ *
+ */
+
+#ifndef _INCLUDE_H_
+#define _INCLUDE_H_
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/proc_fs.h>
+
+#include  <linux/version.h>
+#include <linux/string.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#include "bt_drv.h"
+#include "bt_sdio.h"
+#endif /* _INCLUDE_H_ */
-- 
1.7.5.4

