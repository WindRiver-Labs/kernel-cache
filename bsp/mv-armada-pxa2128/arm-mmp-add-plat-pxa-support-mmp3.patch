From eb4dcfb84442216defcfc6bf8c42fcc59ca75e0f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 19 Aug 2013 21:09:07 +0800
Subject: [PATCH 03/60] arm: mmp: add plat-pxa support mmp3

Original patches come from M5.3.12.5.4_sources, which has totally
more than 6000 thousand patches including many boards with MMPs.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/plat-pxa/Kconfig                      |   28 +
 arch/arm/plat-pxa/Makefile                     |    1 +
 arch/arm/plat-pxa/clock.c                      |  553 +++++++++++++++++++
 arch/arm/plat-pxa/debugfs.c                    |  676 ++++++++++++++++++++++++
 arch/arm/plat-pxa/dma.c                        |    6 +-
 arch/arm/plat-pxa/dvfs.c                       |  295 +++++++++++
 arch/arm/plat-pxa/gpio.c                       |  342 ++++++++++++
 arch/arm/plat-pxa/include/plat/clock.h         |  112 ++++
 arch/arm/plat-pxa/include/plat/debugfs.h       |   22 +
 arch/arm/plat-pxa/include/plat/devfreq.h       |   56 ++
 arch/arm/plat-pxa/include/plat/dma.h           |    2 +
 arch/arm/plat-pxa/include/plat/dvfs.h          |   69 +++
 arch/arm/plat-pxa/include/plat/fb_ioctl.h      |  276 ++++++++++
 arch/arm/plat-pxa/include/plat/gpio.h          |   64 +++
 arch/arm/plat-pxa/include/plat/mfp.h           |  192 +++++++-
 arch/arm/plat-pxa/include/plat/pm.h            |   43 ++
 arch/arm/plat-pxa/include/plat/pmem.h          |   20 +
 arch/arm/plat-pxa/include/plat/pxa27x_keypad.h |    3 +
 arch/arm/plat-pxa/include/plat/pxa3xx_nand.h   |   79 ---
 arch/arm/plat-pxa/include/plat/pxa_uart.h      |   19 +
 arch/arm/plat-pxa/include/plat/reg_rw.h        |   57 ++
 arch/arm/plat-pxa/include/plat/ssp.h           |  259 +++++++++
 arch/arm/plat-pxa/include/plat/usb.h           |   94 ++++
 arch/arm/plat-pxa/mfp.c                        |  139 ++---
 arch/arm/plat-pxa/pmem.c                       |  127 +++++
 arch/arm/plat-pxa/pwm.c                        |    4 +-
 arch/arm/plat-pxa/reg_rw.c                     |  158 ++++++
 27 files changed, 3524 insertions(+), 172 deletions(-)
 create mode 100644 arch/arm/plat-pxa/clock.c
 create mode 100644 arch/arm/plat-pxa/debugfs.c
 create mode 100644 arch/arm/plat-pxa/dvfs.c
 create mode 100644 arch/arm/plat-pxa/gpio.c
 create mode 100644 arch/arm/plat-pxa/include/plat/clock.h
 create mode 100644 arch/arm/plat-pxa/include/plat/debugfs.h
 create mode 100644 arch/arm/plat-pxa/include/plat/devfreq.h
 create mode 100644 arch/arm/plat-pxa/include/plat/dvfs.h
 create mode 100644 arch/arm/plat-pxa/include/plat/fb_ioctl.h
 create mode 100644 arch/arm/plat-pxa/include/plat/gpio.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pm.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pmem.h
 delete mode 100644 arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
 create mode 100644 arch/arm/plat-pxa/include/plat/pxa_uart.h
 create mode 100644 arch/arm/plat-pxa/include/plat/reg_rw.h
 create mode 100644 arch/arm/plat-pxa/include/plat/ssp.h
 create mode 100644 arch/arm/plat-pxa/include/plat/usb.h
 create mode 100644 arch/arm/plat-pxa/pmem.c
 create mode 100644 arch/arm/plat-pxa/reg_rw.c

diff --git a/arch/arm/plat-pxa/Kconfig b/arch/arm/plat-pxa/Kconfig
index da53395..3807902 100644
--- a/arch/arm/plat-pxa/Kconfig
+++ b/arch/arm/plat-pxa/Kconfig
@@ -5,4 +5,32 @@ config PXA_SSP
 	help
 	  Enable support for PXA2xx SSP ports
 
+config PXA_SSP
+	tristate
+	help
+	  Enable support for PXA2xx SSP ports
+
+config PXA_PANIC_FLUSH
+	bool "PXA cache flush when panic"
+	depends on KEXEC
+	help
+	  Enable support for flush all cache during panic
+
+config PXA_32KTIMER
+	bool "PXA 32K Timer"
+	depends on (ARCH_PXA || ARCH_MMP)
+	default y
+	help
+	  32KHz timer support for PXA27x and PXA3xx/9xx Processor
+
+config PINMUX_DEBUG_FS
+	bool "PINMUX dump debug fs support"
+	depends on (PXA3xx || PXA95x || ARCH_MMP)
+	default n
+	help
+	  Allows to dump all MFPR values. Implemented in debug fs.
+	  In order to use do the following:
+	  mount -t debugfs none /sys/kernel/debug
+	  cat sys/kernel/debug/PINMUX/Pinmux
+
 endif
diff --git a/arch/arm/plat-pxa/Makefile b/arch/arm/plat-pxa/Makefile
index f302d04..722fa5c 100644
--- a/arch/arm/plat-pxa/Makefile
+++ b/arch/arm/plat-pxa/Makefile
@@ -10,3 +10,4 @@ obj-$(CONFIG_ARCH_MMP)		+= mfp.o
 
 obj-$(CONFIG_HAVE_PWM)		+= pwm.o
 obj-$(CONFIG_PXA_SSP)		+= ssp.o
+obj-$(CONFIG_CPU_MMP3)          += pmem.o gpio.o clock.o dvfs.o
diff --git a/arch/arm/plat-pxa/clock.c b/arch/arm/plat-pxa/clock.c
new file mode 100644
index 0000000..c2b55cf
--- /dev/null
+++ b/arch/arm/plat-pxa/clock.c
@@ -0,0 +1,553 @@
+/*
+ *  linux/arch/arm/plat-pxa/clock.c
+ *
+ *  based on arch/arm/mach-tegra/clock.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+
+#include <plat/clock.h>
+
+
+static DEFINE_MUTEX(clock_list_lock);
+static LIST_HEAD(clocks);
+
+
+static inline bool clk_cansleep(struct clk *c)
+{
+	return c->cansleep;
+}
+
+#define clk_lock_save(c, flags)						\
+	do {								\
+		if (clk_cansleep(c)) {					\
+			flags = 0;					\
+			mutex_lock(&c->mutex);				\
+		} else {						\
+			spin_lock_irqsave(&c->spinlock, flags);		\
+		}							\
+	} while (0)
+
+#define clk_unlock_restore(c, flags)					\
+	do {								\
+		if (clk_cansleep(c))					\
+			mutex_unlock(&c->mutex);			\
+		else							\
+			spin_unlock_irqrestore(&c->spinlock, flags);	\
+	} while (0)
+
+#ifdef CONFIG_LOCKDEP
+
+#define clock_set_lockdep_class(c, lock)				\
+	do {								\
+		lockdep_set_class(lock, &c->lockdep_key);		\
+	} while (0)
+
+#else
+
+#define clock_set_lockdep_class(c, lock)	do {} while (0)
+
+#endif
+
+static inline void clk_lock_init(struct clk *c)
+{
+	mutex_init(&c->mutex);
+	clock_set_lockdep_class(c, &c->mutex);
+	spin_lock_init(&c->spinlock);
+	clock_set_lockdep_class(c, &c->spinlock);
+}
+
+static void __clk_set_cansleep(struct clk *c)
+{
+	struct clk *child;
+	BUG_ON(mutex_is_locked(&c->mutex));
+	BUG_ON(spin_is_locked(&c->spinlock));
+
+	list_for_each_entry(child, &clocks, node) {
+		if (child->parent != c)
+			continue;
+
+		WARN(child->ops && child->ops->set_parent,
+			"can't make child clock %s of %s "
+			"sleepable if it's parent could change",
+			child->name, c->name);
+
+		__clk_set_cansleep(child);
+	}
+
+	c->cansleep = true;
+}
+
+/* Must be called before any clk_get calls */
+void clk_set_cansleep(struct clk *c)
+{
+
+	mutex_lock(&clock_list_lock);
+	__clk_set_cansleep(c);
+	mutex_unlock(&clock_list_lock);
+}
+
+int clk_reparent(struct clk *c, struct clk *parent)
+{
+	c->parent = parent;
+	return 0;
+}
+
+void clk_init(struct clk *c)
+{
+	clk_lock_init(c);
+
+	if (c->ops && c->ops->init)
+		c->ops->init(c);
+
+	if (!c->ops || !c->ops->enable)
+		c->refcnt++;
+
+	mutex_lock(&clock_list_lock);
+	list_add(&c->node, &clocks);
+	mutex_unlock(&clock_list_lock);
+}
+
+/* Must be called with clk_lock(c) held */
+static unsigned long clk_predict_rate_from_parent(struct clk *c, struct clk *p)
+{
+	u64 rate;
+
+	rate = clk_get_rate(p);
+
+	if (c->mul != 0 && c->div != 0) {
+		rate *= c->mul;
+		do_div(rate, c->div);
+	}
+
+	return rate;
+}
+
+/* Must be called with clk_lock(c) held */
+unsigned long clk_get_rate_locked(struct clk *c)
+{
+	unsigned long rate;
+
+	if (c->ops && c->ops->getrate)
+		rate = c->ops->getrate(c);
+	else if (c->parent)
+		rate = clk_predict_rate_from_parent(c, c->parent);
+	else
+		rate = c->rate;
+
+	return rate;
+}
+
+int clk_enable(struct clk *c)
+{
+	int ret = 0;
+	unsigned long flags;
+	int i = 0;
+	u32 dependence_count = c->dependence_count;
+
+	clk_lock_save(c, flags);
+
+	if (clk_is_dvfs(c)) {
+		ret = dvfs_set_rate(c, clk_get_rate_locked(c));
+		if (ret)
+			goto out;
+	}
+
+	if (c->refcnt == 0) {
+		while (dependence_count != 0) {
+			dependence_count--;
+			ret = clk_enable(c->dependence[i]);
+			if (ret) {
+				while (i > 0)
+					clk_disable(c->dependence[--i]);
+				goto out;
+			}
+			i++;
+		}
+
+		if (c->parent) {
+			ret = clk_enable(c->parent);
+			if (ret)
+				goto disable_depend;
+		}
+
+		if (c->ops && c->ops->enable) {
+			ret = c->ops->enable(c);
+			if (ret) {
+				if (c->parent)
+					clk_disable(c->parent);
+				goto disable_depend;
+			}
+		}
+	}
+	c->refcnt++;
+
+	clk_unlock_restore(c, flags);
+	return 0;
+
+disable_depend:
+	dependence_count = c->dependence_count;
+	while (dependence_count != 0)
+		clk_disable(c->dependence[--dependence_count]);
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *c)
+{
+	unsigned long flags;
+	u32 dependence_count = c->dependence_count;
+
+	clk_lock_save(c, flags);
+
+	if (c->refcnt == 0) {
+		clk_unlock_restore(c, flags);
+		return;
+	}
+	if (c->refcnt == 1) {
+		if (c->ops && c->ops->disable)
+			c->ops->disable(c);
+
+		if (c->parent)
+			clk_disable(c->parent);
+
+		while (dependence_count != 0)
+			clk_disable(c->dependence[--dependence_count]);
+	}
+	c->refcnt--;
+
+	if (clk_is_dvfs(c) && c->refcnt == 0)
+		dvfs_set_rate(c, 0);
+
+	clk_unlock_restore(c, flags);
+}
+EXPORT_SYMBOL(clk_disable);
+
+int clk_set_rate(struct clk *c, unsigned long rate)
+{
+	int ret = 0;
+	unsigned long flags, new_rate, old_rate;
+	int sr_flag = 0;
+
+	clk_lock_save(c, flags);
+
+	if ((c->refcnt != 0) && !c->dynamic_change) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	if (!c->ops || !c->ops->setrate) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	old_rate = clk_get_rate_locked(c);
+
+	if (c->ops && c->ops->round_rate) {
+		new_rate = c->ops->round_rate(c, rate);
+
+		if (new_rate < 0) {
+			ret = new_rate;
+			goto out;
+		}
+
+		rate = new_rate;
+	}
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && rate > old_rate) {
+		ret = dvfs_set_rate(c, rate);
+		if (ret)
+			goto out;
+	}
+
+	new_rate = rate;
+	ret = c->ops->setrate(c, rate);
+	if (ret)
+		goto out;
+
+	if (c->ops->getrate)
+		new_rate = c->ops->getrate(c);
+	if (rate != new_rate) {
+		rate = new_rate;
+		sr_flag = 1;
+	}
+
+	c->rate = rate;
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && (rate < old_rate || sr_flag)) {
+		ret = dvfs_set_rate(c, rate);
+		if (ret)
+			goto out;
+	}
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_rate);
+
+unsigned long clk_get_rate(struct clk *c)
+{
+	unsigned long flags;
+	unsigned long rate;
+
+	clk_lock_save(c, flags);
+
+	rate = clk_get_rate_locked(c);
+
+	clk_unlock_restore(c, flags);
+
+	return rate;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+int clk_set_parent(struct clk *c, struct clk *parent)
+{
+	int ret = 0;
+	unsigned long flags, new_rate, old_rate;
+
+	clk_lock_save(c, flags);
+
+	if (!c->ops || !c->ops->set_parent) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	new_rate = clk_predict_rate_from_parent(c, parent);
+	old_rate = clk_get_rate_locked(c);
+
+	if (c->ops && c->ops->getrate)
+		new_rate = c->ops->getrate(c);
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && new_rate > old_rate) {
+		ret = dvfs_set_rate(c, new_rate);
+		if (ret)
+			goto out;
+	}
+
+	ret = c->ops->set_parent(c, parent);
+	if (ret)
+		goto out;
+
+	if (clk_is_dvfs(c) && c->refcnt > 0 && new_rate < old_rate)
+		ret = dvfs_set_rate(c, new_rate);
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_set_parent);
+
+struct clk *clk_get_parent(struct clk *c)
+{
+	return c->parent;
+}
+EXPORT_SYMBOL(clk_get_parent);
+
+long clk_round_rate(struct clk *c, unsigned long rate)
+{
+	unsigned long flags;
+	long ret;
+
+	clk_lock_save(c, flags);
+
+	if (!c->ops || !c->ops->round_rate) {
+		ret = -ENOSYS;
+		goto out;
+	}
+
+	ret = c->ops->round_rate(c, rate);
+
+out:
+	clk_unlock_restore(c, flags);
+	return ret;
+}
+EXPORT_SYMBOL(clk_round_rate);
+
+struct clk *get_clock_by_name(const char *name)
+{
+	struct clk *c;
+	struct clk *ret = NULL;
+	mutex_lock(&clock_list_lock);
+	list_for_each_entry(c, &clocks, node) {
+		if (strcmp(c->name, name) == 0) {
+			ret = c;
+			break;
+		}
+	}
+	mutex_unlock(&clock_list_lock);
+	return ret;
+}
+
+#if defined(CONFIG_DEBUG_FS)
+DEFINE_MUTEX(clk_mutex);
+static int clk_enable_open(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t
+clk_enable_read(struct file *filp, char __user *ubuf, size_t cnt,
+		loff_t *ppos)
+{
+	struct clk *clk= filp->private_data;
+	char buf[5];
+	int ret;
+
+	mutex_lock(&clk_mutex);
+	sprintf(buf, "%4x", clk->refcnt);
+	mutex_unlock(&clk_mutex);
+	buf[4] = '\n';
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, 5);
+
+	return ret;
+}
+
+static ssize_t
+clk_enable_write(struct file *filp, const char __user *ubuf, size_t cnt,
+		 loff_t *ppos)
+{
+	struct clk *clk= filp->private_data;
+	char buf[64];
+	unsigned long val;
+	int ret;
+
+	if (cnt >= sizeof(buf))
+		return -EINVAL;
+
+	if (copy_from_user(&buf, ubuf, cnt))
+		return -EFAULT;
+
+	buf[cnt] = 0;
+
+	ret = strict_strtoul(buf, 10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	*ppos += cnt;
+	mutex_lock(&clk_mutex);
+	if (val)
+		clk_enable(clk);
+	else
+		clk_disable(clk);
+	mutex_unlock(&clk_mutex);
+
+	return cnt;
+}
+
+static const struct file_operations clk_enable_fops = {
+	.open = clk_enable_open,
+	.read = clk_enable_read,
+	.write = clk_enable_write,
+};
+
+/*
+ *	debugfs support to trace clock tree hierarchy and attributes
+ */
+static struct dentry *clk_debugfs_root;
+
+static int clk_debugfs_register_one(struct clk *c)
+{
+	int err;
+	struct dentry *d, *child, *child_tmp;
+	struct clk *pa = c->parent;
+	char s[255];
+	char *p = s;
+
+	if (!c->name) {
+		return -EINVAL;
+	}
+	p += sprintf(p, "%s", c->name);
+	d = debugfs_create_dir(s, pa ? pa->dent : clk_debugfs_root);
+	if (!d)
+		return -ENOMEM;
+	c->dent = d;
+
+	d = debugfs_create_u32("usecount", S_IRUGO, c->dent, (u32 *)&c->refcnt);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_u32("rate", S_IRUGO, c->dent, (u32 *)&c->rate);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	d = debugfs_create_file("enable", 0644, c->dent, c, &clk_enable_fops);
+	if (!d) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+	return 0;
+
+err_out:
+	d = c->dent;
+	list_for_each_entry_safe(child, child_tmp, &d->d_subdirs, d_u.d_child)
+		debugfs_remove(child);
+	debugfs_remove(c->dent);
+	return err;
+}
+
+static int clk_debugfs_register(struct clk *c)
+{
+	int err;
+	struct clk *pa = c->parent;
+
+	if (pa && !pa->dent) {
+		err = clk_debugfs_register(pa);
+		if (err)
+			return err;
+	}
+
+	if (!c->dent) {
+		err = clk_debugfs_register_one(c);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int __init clk_debugfs_init(void)
+{
+	struct clk *c;
+	struct dentry *d;
+	int err;
+
+	d = debugfs_create_dir("clock", NULL);
+	if (!d)
+		return -ENOMEM;
+	clk_debugfs_root = d;
+
+	list_for_each_entry(c, &clocks, node) {
+		err = clk_debugfs_register(c);
+		if (err)
+			goto err_out;
+	}
+	return 0;
+err_out:
+	debugfs_remove_recursive(clk_debugfs_root);
+	return err;
+}
+late_initcall(clk_debugfs_init);
+
+#endif /* CONFIG_DEBUG_FS */
diff --git a/arch/arm/plat-pxa/debugfs.c b/arch/arm/plat-pxa/debugfs.c
new file mode 100644
index 0000000..4c291bc
--- /dev/null
+++ b/arch/arm/plat-pxa/debugfs.c
@@ -0,0 +1,676 @@
+/*
+ * arch/arm/plat-pxa/debugfs.c
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/io.h>
+
+#include <mach/addr-map.h>
+#include <plat/debugfs.h>
+
+#ifdef CONFIG_CACHE_L2X0
+#include <asm/hardware/cache-l2x0.h>
+#endif
+
+#ifdef CONFIG_ARM_GIC
+#include <asm/hardware/gic.h>
+#endif
+
+static ssize_t cp15_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	pr_info("cp15 doesn't support read a giving register now.\n"
+		"Please cat it directly.\n");
+
+	return count;
+}
+
+static ssize_t cp15_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char *p;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	p = (char *)__get_free_pages(GFP_KERNEL, 0);
+	if (!p)
+		return -ENOMEM;
+
+	buf_len	= (PAGE_SIZE - 1);
+
+	/* c0 registers */
+	asm volatile("mrc p15, 0, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cache Type: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"TLB Type: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Processor Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Processor Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Debug Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Auxiliary Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 5" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 6" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Model Feature 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 3: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Set Attribute 4: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Current Cache Size ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cache Size Selection: 0x%08x\n", value);
+
+	/* c1 registers */
+	asm volatile("mrc p15, 0, %0, c1, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"System Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Auxiliary Control: 0x%08x\n", value);
+
+	len += snprintf(p + len, buf_len - len, "\tL2 prefetch: %s\n",
+			(value & (1 << 1)) ? "Enabled" : "Disabled");
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Coprocessor Access Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Secure Configuration: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Secure Debug Enable: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Non-Secure Access Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c1, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Virtualization Control: 0x%08x\n", value);
+
+	/* c2 registers */
+	asm volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Base 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Base 1: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Translation Table Control: 0x%08x\n", value);
+
+	/* c3 registers */
+	asm volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Domain Access Control: 0x%08x\n", value);
+
+	/* c5 registers */
+	asm volatile("mrc p15, 0, %0, c5, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Data Fault Status: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Fault Status: 0x%08x\n", value);
+
+	/* c6 registers */
+	asm volatile("mrc p15, 0, %0, c6, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Data Fault Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Instruction Fault Address: 0x%08x\n", value);
+
+	/* c7 register */
+	asm volatile("mrc p15, 0, %0, c7, c4, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Physical Address: 0x%08x\n", value);
+
+	/* c9 register */
+	asm volatile("mrc p15, 0, %0, c9, c12, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Performance Monitor Control(PMCR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Count Enable Set(PMCNTENSET): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Count Enable Clear(PMCNTENCLR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 3" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Overflow Flag Status(PMOVSR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c12, 5" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Counter Selection(PMSELR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Cycle Count(PMCCNTR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Type Select(PMXEVTYPER): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c13, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Event Count(PMXEVCNTR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"User Enable(PMUSERENR): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Enable Set(PMINTENSET): 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c9, c14, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Enable Clear(PMINTENCLR): 0x%08x\n", value);
+
+	/* c10 registers */
+	asm volatile("mrc p15, 0, %0, c10, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"TLB Lockdown: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Memory Attribute NMRR: 0x%08x\n", value);
+
+	/* c11 register */
+	asm volatile("mrc p15, 0, %0, c11, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Preload Engine User Accessibility: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c11, c1, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Preload Engine Parameters Control: 0x%08x\n", value);
+
+	/* c12 register */
+	asm volatile("mrc p15, 0, %0, c12, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Vector Base Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c12, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Monitor Vector Base Address: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c12, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Interrupt Status: 0x%08x\n", value);
+
+	/* c13 register */
+	asm volatile("mrc p15, 0, %0, c13, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"FCSE Process ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 1" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Context ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"User Thread ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c13, c0, 4" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Privileged Only Thread ID: 0x%08x\n", value);
+
+	/* c15 registers */
+	asm volatile("mrc p15, 0, %0, c15, c0, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Power Control: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c1, 0" : "=r"(value));
+	len += snprintf(p + len, buf_len - len, "NEON is: %s\n",
+			(value & (1 << 0)) ?  "Busy" : "Idle");
+
+	asm volatile("mrc p15, 0, %0, c15, c5, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB VA: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c6, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB PA: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c15, c7, 2" : "=r"(value));
+	len += snprintf(p + len, buf_len - len,
+			"Main TLB Attribute: 0x%08x\n", value);
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping cp15 is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+	free_pages((unsigned long)p, 0);
+
+	return ret;
+}
+
+const struct file_operations dumpregs_cp15_fops = {
+	.read = cp15_read,
+	.write = cp15_write,
+};
+
+
+#ifdef CONFIG_ARM_GIC
+#define GIC_DIST_STATUS		0xD00
+
+static int gic_offset = -1;
+
+static ssize_t gic_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check gic offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0xffc)
+		pr_err("The offset is out of GIC distributor range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		gic_offset = offset;
+
+	return count;
+
+}
+
+static ssize_t gic_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	void __iomem *dist_base = (void __iomem *)GIC_DIST_VIRT_BASE;
+	char *p;
+	size_t ret, buf_len;
+	u32 gic_irqs;
+	u32 value;
+	int i, len = 0;
+
+	p = (char *)__get_free_pages(GFP_KERNEL, 0);
+	if (!p)
+		return -ENOMEM;
+
+	buf_len = (PAGE_SIZE - 1);
+
+	if (gic_offset != -1) {
+		value = readl_relaxed(dist_base + gic_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", gic_offset, value);
+	} else {
+		gic_irqs = readl_relaxed(dist_base + GIC_DIST_CTR) & 0x1f;
+		gic_irqs = (gic_irqs + 1) * 32;
+		if (gic_irqs > 1020)
+			gic_irqs = 1020;
+
+		value = readl_relaxed(dist_base + GIC_DIST_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Dist Control Register: 0x%08x\n", value);
+
+		for (i = 32; i < gic_irqs; i += 4) {
+			value = readl_relaxed(dist_base + GIC_DIST_TARGET
+					+ i * 4 / 4);
+			len += snprintf(p + len, buf_len - len,
+				"Target setting[%d]: 0x%08x\n", i / 4, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_ENABLE_SET
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"Enable setting[%d]: 0x%08x\n", i / 32, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_PENDING_SET
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"Pending status[%d]: 0x%08x\n", i / 32, value);
+		}
+
+		for (i = 32; i < gic_irqs; i += 32) {
+			value = readl_relaxed(dist_base + GIC_DIST_STATUS
+					+ i * 4 / 32);
+			len += snprintf(p + len, buf_len - len,
+				"SPI status[%d]: 0x%08x\n", i / 32, value);
+		}
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping gic is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, p, len);
+
+	free_pages((unsigned long)p, 0);
+
+	if (gic_offset != -1 && !ret)
+		gic_offset = -1;
+
+	return ret;
+}
+
+const struct file_operations dumpregs_gic_fops = {
+	.read = gic_read,
+	.write = gic_write,
+};
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+
+static int l2_offset = -1;
+
+static ssize_t l2_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check L2 offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0xffc)
+		pr_err("The offset is out of L2 register range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		l2_offset = offset;
+
+	return count;
+
+}
+
+static ssize_t l2_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[256];
+	char *p = buf;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	buf_len = sizeof(buf) - 1;
+
+	if (l2_offset != -1) {
+		value = readl_relaxed(l2x0_base + l2_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", l2_offset, value);
+	} else {
+		value = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Auxiliary Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_TAG_LATENCY_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Tag RAM Latency: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_DATA_LATENCY_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Data RAM Latency: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_ADDR_FILTER_START);
+		len += snprintf(p + len, buf_len - len,
+				"Address filtering Start: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_ADDR_FILTER_END);
+		len += snprintf(p + len, buf_len - len,
+				"Address filtering End: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_PREFETCH_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Prefetch Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_POWER_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"Power Control: 0x%08x\n", value);
+
+		value = readl_relaxed(l2x0_base + L2X0_CTRL);
+		len += snprintf(p + len, buf_len - len, "L2 Cache: %s\n",
+			(value & (1 << 0)) ? "Enabled" : "Disabled");
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping L2 is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	if (l2_offset != -1 && !ret)
+		l2_offset = -1;
+	return ret;
+}
+
+const struct file_operations dumpregs_l2_fops = {
+	.read = l2_read,
+	.write = l2_write,
+};
+#endif
+
+#ifdef CONFIG_HAVE_ARM_SCU
+
+#define SCU_CTRL		0x00
+#define SCU_CONFIG		0x04
+#define SCU_CPU_STATUS		0x08
+
+static int scu_offset = -1;
+
+static ssize_t scu_write(struct file *filp, const char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[32] = {0};
+	int offset;
+
+	/* copy user's input to kernel space */
+	if (copy_from_user(buf, buffer, count))
+		return -EFAULT;
+
+	sscanf(buf, "%x", &offset);
+	pr_info("Check SCU offset: 0x%x\n", offset);
+
+	if (offset < 0 || offset > 0x54)
+		pr_err("The offset is out of SCU register range.\n");
+	else if (offset % 4)
+		pr_err("offset should be aligned to 4 bytes.\n");
+	else
+		scu_offset = offset;
+
+	return count;
+}
+
+static ssize_t scu_read(struct file *filp, char __user *buffer,
+		size_t count, loff_t *ppos)
+{
+	char buf[256];
+	char *p = buf;
+	size_t ret, buf_len;
+	u32 value;
+	int len = 0;
+
+	buf_len = sizeof(buf) - 1;
+
+	if (scu_offset != -1) {
+		value = readl_relaxed(SCU_VIRT_BASE + scu_offset);
+		len += snprintf(p + len, buf_len - len,
+				"offset[0x%x]: 0x%08x\n", scu_offset, value);
+	} else {
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CTRL);
+		len += snprintf(p + len, buf_len - len,
+				"SCU Control: 0x%08x\n", value);
+
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CONFIG);
+		len += snprintf(p + len, buf_len - len,
+				"SCU Configuration: 0x%08x\n", value);
+
+		value = readl_relaxed(SCU_VIRT_BASE + SCU_CPU_STATUS);
+		len += snprintf(p + len, buf_len - len,
+				"SCU CPU Power Status: 0x%08x\n", value);
+	}
+
+	if (len == buf_len)
+		pr_warn("The buffer for dumpping SCU is full now!\n");
+
+	ret = simple_read_from_buffer(buffer, count, ppos, buf, len);
+	if (scu_offset != -1 && !ret)
+		scu_offset = -1;
+	return ret;
+}
+
+const struct file_operations dumpregs_scu_fops = {
+	.read = scu_read,
+	.write = scu_write,
+};
+#endif
+
+struct dentry *pxa;
+
+static int __init pxa_debugfs_init(void)
+{
+	struct dentry *dumpregs_cp15, *dumpregs_gic, *dumpregs_l2;
+	struct dentry *dumpregs_scu;
+
+	pxa = debugfs_create_dir("pxa", NULL);
+	if (!pxa)
+		return -ENOENT;
+
+	dumpregs_cp15 = debugfs_create_file("cp15", 0666,
+					pxa, NULL, &dumpregs_cp15_fops);
+	if (!dumpregs_cp15)
+		goto err_cp15;
+
+#ifdef CONFIG_ARM_GIC
+	dumpregs_gic = debugfs_create_file("gic_dist", 0666,
+					pxa, NULL, &dumpregs_gic_fops);
+	if (!dumpregs_gic)
+		goto err_gic;
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+	dumpregs_l2 = debugfs_create_file("l2", 0666,
+					pxa, NULL, &dumpregs_l2_fops);
+	if (!dumpregs_l2)
+		goto err_l2;
+#endif
+
+#ifdef CONFIG_HAVE_ARM_SCU
+	dumpregs_scu = debugfs_create_file("scu", 0666,
+				pxa, NULL, &dumpregs_scu_fops);
+	if (!dumpregs_scu)
+		goto err_scu;
+#endif
+
+	return 0;
+
+#ifdef CONFIG_HAVE_ARM_SCU
+err_scu:
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+	debugfs_remove(dumpregs_l2);
+	dumpregs_l2 = NULL;
+err_l2:
+#endif
+
+#ifdef CONFIG_ARM_GIC
+	debugfs_remove(dumpregs_gic);
+	dumpregs_gic = NULL;
+#endif
+
+#ifdef CONFIG_ARM_GIC
+err_gic:
+#endif
+	debugfs_remove(dumpregs_cp15);
+	dumpregs_cp15 = NULL;
+
+err_cp15:
+	debugfs_remove(pxa);
+	pxa = NULL;
+
+	return -ENOENT;
+}
+
+postcore_initcall(pxa_debugfs_init);
diff --git a/arch/arm/plat-pxa/dma.c b/arch/arm/plat-pxa/dma.c
index 79ef102..ab22e69 100644
--- a/arch/arm/plat-pxa/dma.c
+++ b/arch/arm/plat-pxa/dma.c
@@ -20,6 +20,7 @@
 #include <linux/errno.h>
 #include <linux/dma-mapping.h>
 
+#include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/memory.h>
 #include <mach/hardware.h>
@@ -242,7 +243,7 @@ static void pxa_dma_init_debugfs(void)
 	if (!dbgfs_state)
 		goto err_state;
 
-	dbgfs_chan = kmalloc(sizeof(*dbgfs_state) * num_dma_channels,
+	dbgfs_chan = kmalloc(sizeof(dbgfs_state) * num_dma_channels,
 			     GFP_KERNEL);
 	if (!dbgfs_chan)
 		goto err_alloc;
@@ -377,7 +378,8 @@ int __init pxa_init_dma(int irq, int num_ch)
 		spin_lock_init(&dma_channels[i].lock);
 	}
 
-	ret = request_irq(irq, dma_irq_handler, IRQF_DISABLED, "DMA", NULL);
+	ret = request_irq(irq, dma_irq_handler, IRQF_DISABLED | IRQF_SHARED,
+			  "DMA", "DMAC");
 	if (ret) {
 		printk (KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
 		kfree(dma_channels);
diff --git a/arch/arm/plat-pxa/dvfs.c b/arch/arm/plat-pxa/dvfs.c
new file mode 100644
index 0000000..2ee4c64
--- /dev/null
+++ b/arch/arm/plat-pxa/dvfs.c
@@ -0,0 +1,295 @@
+/*
+ *  linux/arch/arm/plat-pxa/dvfs.c
+ *
+ *  based on arch/arm/mach-tegra/dvfs.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/err.h>
+#include <linux/regulator/consumer.h>
+#include <linux/list.h>
+
+#include <plat/clock.h>
+#include <plat/dvfs.h>
+
+static LIST_HEAD(dvfs_rail_list);
+static DEFINE_MUTEX(dvfs_lock);
+
+static int dvfs_rail_update(struct dvfs_rail *rail);
+void dvfs_add_relationships(struct dvfs_relationship *rels, int n)
+{
+	int i;
+	struct dvfs_relationship *rel;
+
+	mutex_lock(&dvfs_lock);
+
+	for (i = 0; i < n; i++) {
+		rel = &rels[i];
+		list_add_tail(&rel->from_node, &rel->to->relationships_from);
+		list_add_tail(&rel->to_node, &rel->from->relationships_to);
+	}
+
+	mutex_unlock(&dvfs_lock);
+}
+
+int dvfs_init_rails(struct dvfs_rail *rails[], int n)
+{
+	int i;
+
+	mutex_lock(&dvfs_lock);
+
+	for (i = 0; i < n; i++) {
+		INIT_LIST_HEAD(&rails[i]->dvfs);
+		INIT_LIST_HEAD(&rails[i]->relationships_from);
+		INIT_LIST_HEAD(&rails[i]->relationships_to);
+		rails[i]->millivolts = rails[i]->nominal_millivolts;
+		rails[i]->new_millivolts = rails[i]->nominal_millivolts;
+		if (!rails[i]->step)
+			rails[i]->step = rails[i]->max_millivolts;
+
+		list_add_tail(&rails[i]->node, &dvfs_rail_list);
+	}
+
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+};
+
+static int dvfs_solve_relationship(struct dvfs_relationship *rel)
+{
+	return rel->solve(rel->from, rel->to);
+}
+
+/*
+ * Sets the voltage on a dvfs rail to a specific value, and updates any
+ * rails that depend on this rail.
+ */
+static int dvfs_rail_set_voltage(struct dvfs_rail *rail, int millivolts)
+{
+	int ret = 0;
+	struct dvfs_relationship *rel;
+	int step = (millivolts > rail->millivolts) ? rail->step : -rail->step;
+	int i;
+	int steps;
+
+	if (!rail->reg) {
+		if (millivolts == rail->millivolts)
+			return 0;
+		else
+			return -EINVAL;
+	}
+
+	steps = DIV_ROUND_UP(abs(millivolts - rail->millivolts), rail->step);
+
+	for (i = 0; i < steps; i++) {
+		if (abs(millivolts - rail->millivolts) > rail->step)
+			rail->new_millivolts = rail->millivolts + step;
+		else
+			rail->new_millivolts = millivolts;
+
+		/*
+		 * Before changing the voltage, tell each rail that depends
+		 * on this rail that the voltage will change.
+		 * This rail will be the "from" rail in the relationship,
+		 * the rail that depends on this rail will be the "to" rail.
+		 * from->millivolts will be the old voltage
+		 * from->new_millivolts will be the new voltage
+		 */
+		list_for_each_entry(rel, &rail->relationships_to, to_node) {
+			ret = dvfs_rail_update(rel->to);
+			if (ret)
+				return ret;
+		}
+
+		ret = regulator_set_voltage(rail->reg,
+				rail->new_millivolts * 1000,
+				rail->max_millivolts * 1000);
+		if (ret) {
+			pr_err("Failed to set dvfs regulator %s\n",
+				rail->reg_id);
+			return ret;
+		}
+
+		rail->millivolts = rail->new_millivolts;
+
+		/*
+		 * After changing the voltage, tell each rail that depends
+		 * on this rail that the voltage has changed.
+		 * from->millivolts and from->new_millivolts will be the
+		 * new voltage
+		 */
+		list_for_each_entry(rel, &rail->relationships_to, to_node) {
+			ret = dvfs_rail_update(rel->to);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (unlikely(rail->millivolts != millivolts)) {
+		pr_err("%s: rail didn't reach target %d in %d steps (%d)\n",
+			__func__, millivolts, steps, rail->millivolts);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+/*
+ * Determine the minimum valid voltage for a rail, taking into account
+ * the dvfs clocks and any rails that this rail depends on.  Calls
+ * dvfs_rail_set_voltage with the new voltage, which will call
+ * dvfs_rail_update on any rails that depend on this rail.
+ */
+static int dvfs_rail_update(struct dvfs_rail *rail)
+{
+	int millivolts = 0;
+	struct dvfs *d;
+	struct dvfs_relationship *rel;
+	int ret = 0;
+
+	/* if regulators are not connected yet, return and handle it later */
+	if (!rail->reg)
+		return 0;
+
+	/* Find the maximum voltage requested by any clock */
+	list_for_each_entry(d, &rail->dvfs, dvfs_node)
+		millivolts = max(d->millivolts, millivolts);
+
+	if (millivolts != 0)
+		rail->new_millivolts = millivolts;
+
+	/* Check any rails that this rail depends on */
+	list_for_each_entry(rel, &rail->relationships_from, from_node)
+		rail->new_millivolts = dvfs_solve_relationship(rel);
+
+	if (rail->new_millivolts != rail->millivolts) {
+		pr_info("Voltage updated to %d\n", rail->new_millivolts);
+		ret = dvfs_rail_set_voltage(rail, rail->new_millivolts);
+	}
+	return ret;
+}
+
+static int dvfs_rail_connect_to_regulator(struct dvfs_rail *rail)
+{
+	struct regulator *reg;
+
+	if (!rail->reg) {
+		reg = regulator_get(NULL, rail->reg_id);
+		if (IS_ERR(reg))
+			return -EINVAL;
+	}
+
+	rail->reg = reg;
+
+	if (regulator_is_enabled(reg))
+		rail->nominal_millivolts = regulator_get_voltage(reg) / 1000;
+
+	return 0;
+}
+
+static int
+__dvfs_set_rate(struct dvfs *d, unsigned long rate)
+{
+	int i = 0;
+	int ret;
+
+	if (d->vol_freq_table == NULL)
+		return -ENODEV;
+
+	if (rate > d->vol_freq_table[d->num_freqs - 1].freq) {
+		pr_warn("dvfs: rate %lu too high for dvfs on %s\n", rate,
+			d->clk_name);
+		return -EINVAL;
+	}
+
+	if (rate == 0) {
+		d->millivolts = 0;
+	} else {
+		while (i < d->num_freqs && rate > d->vol_freq_table[i].freq)
+			i++;
+
+		d->millivolts = d->vol_freq_table[i].millivolts;
+	}
+
+	ret = dvfs_rail_update(d->dvfs_rail);
+	if (ret)
+		pr_err("Failed to set regulator %s for clock %s to %d mV\n",
+			d->dvfs_rail->reg_id, d->clk_name, d->millivolts);
+
+	return ret;
+}
+
+int dvfs_set_rate(struct clk *c, unsigned long rate)
+{
+	int ret;
+
+	if (!c->dvfs)
+		return -EINVAL;
+
+	mutex_lock(&dvfs_lock);
+	ret = __dvfs_set_rate(c->dvfs, rate);
+	mutex_unlock(&dvfs_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dvfs_set_rate);
+/* May only be called during clock init, does not take any locks on clock c. */
+int __init enable_dvfs_on_clk(struct clk *c, struct dvfs *d)
+{
+	unsigned long rate;
+	int i = 0;
+
+	if (c->dvfs) {
+		pr_err("Error when enabling dvfs on %s for clock %s:\n",
+			d->dvfs_rail->reg_id, c->name);
+		pr_err("DVFS already enabled for %s\n",
+			c->dvfs->dvfs_rail->reg_id);
+		return -EINVAL;
+	}
+
+	clk_set_cansleep(c);
+	mutex_lock(&c->mutex);
+	rate = clk_get_rate_locked(c);
+	mutex_unlock(&c->mutex);
+	if (rate) {
+		while (i < d->num_freqs && rate > d->vol_freq_table[i].freq)
+			i++;
+		d->millivolts = d->vol_freq_table[i].millivolts;
+	}
+	c->dvfs = d;
+	mutex_lock(&dvfs_lock);
+	list_add_tail(&d->dvfs_node, &d->dvfs_rail->dvfs);
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+}
+
+/*
+ * Iterate through all the dvfs regulators, finding the regulator exported
+ * by the regulator api for each one.
+ * Must be called after all the regulator api initialized (subsys_initcall).
+ * Must be called before all the cpufreq/devfreq framework initialized
+ * (module_initcall).
+ */
+int __init dvfs_late_init(void)
+{
+	struct dvfs_rail *rail;
+
+	mutex_lock(&dvfs_lock);
+
+	list_for_each_entry(rail, &dvfs_rail_list, node)
+		dvfs_rail_connect_to_regulator(rail);
+
+	list_for_each_entry(rail, &dvfs_rail_list, node)
+		dvfs_rail_update(rail);
+
+	mutex_unlock(&dvfs_lock);
+
+	return 0;
+}
+fs_initcall(dvfs_late_init);
+
diff --git a/arch/arm/plat-pxa/gpio.c b/arch/arm/plat-pxa/gpio.c
new file mode 100644
index 0000000..c06f64e
--- /dev/null
+++ b/arch/arm/plat-pxa/gpio.c
@@ -0,0 +1,342 @@
+/*
+ *  linux/arch/arm/plat-pxa/gpio.c
+ *
+ *  Generic PXA GPIO handling
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/syscore_ops.h>
+#include <linux/slab.h>
+
+#include <mach/gpio.h>
+#include <asm/mach/irq.h>
+
+int pxa_last_gpio;
+
+struct pxa_gpio_chip {
+	struct gpio_chip chip;
+	void __iomem	*regbase;
+	char label[10];
+
+	unsigned long	irq_mask;
+	unsigned long	irq_edge_rise;
+	unsigned long	irq_edge_fall;
+
+#ifdef CONFIG_PM
+	unsigned long	saved_gplr;
+	unsigned long	saved_gpdr;
+	unsigned long	saved_grer;
+	unsigned long	saved_gfer;
+#endif
+};
+
+static DEFINE_SPINLOCK(gpio_lock);
+static struct pxa_gpio_chip *pxa_gpio_chips;
+
+#define for_each_gpio_chip(i, c)			\
+	for (i = 0, c = &pxa_gpio_chips[0]; i <= pxa_last_gpio; i += 32, c++)
+
+static inline void __iomem *gpio_chip_base(struct gpio_chip *c)
+{
+	return container_of(c, struct pxa_gpio_chip, chip)->regbase;
+}
+
+static inline struct pxa_gpio_chip *gpio_to_pxachip(unsigned gpio)
+{
+	return &pxa_gpio_chips[gpio_to_bank(gpio)];
+}
+
+static int pxa_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *base = gpio_chip_base(chip);
+	uint32_t value, mask = 1 << offset;
+	unsigned long flags;
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	value = __raw_readl(base + GPDR_OFFSET);
+	if (__gpio_is_inverted(chip->base + offset))
+		value |= mask;
+	else
+		value &= ~mask;
+	__raw_writel(value, base + GPDR_OFFSET);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	return 0;
+}
+
+static int pxa_gpio_direction_output(struct gpio_chip *chip,
+				     unsigned offset, int value)
+{
+	void __iomem *base = gpio_chip_base(chip);
+	uint32_t tmp, mask = 1 << offset;
+	unsigned long flags;
+
+	__raw_writel(mask, base + (value ? GPSR_OFFSET : GPCR_OFFSET));
+
+	spin_lock_irqsave(&gpio_lock, flags);
+
+	tmp = __raw_readl(base + GPDR_OFFSET);
+	if (__gpio_is_inverted(chip->base + offset))
+		tmp &= ~mask;
+	else
+		tmp |= mask;
+	__raw_writel(tmp, base + GPDR_OFFSET);
+
+	spin_unlock_irqrestore(&gpio_lock, flags);
+	return 0;
+}
+
+static int pxa_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	return __raw_readl(gpio_chip_base(chip) + GPLR_OFFSET) & (1 << offset);
+}
+
+static void pxa_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	__raw_writel(1 << offset, gpio_chip_base(chip) +
+				(value ? GPSR_OFFSET : GPCR_OFFSET));
+}
+
+static int __init pxa_init_gpio_chip(int gpio_end)
+{
+	int i, gpio, nbanks = gpio_to_bank(gpio_end) + 1;
+	struct pxa_gpio_chip *chips;
+
+	chips = kzalloc(nbanks * sizeof(struct pxa_gpio_chip), GFP_KERNEL);
+	if (chips == NULL) {
+		pr_err("%s: failed to allocate GPIO chips\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (i = 0, gpio = 0; i < nbanks; i++, gpio += 32) {
+		struct gpio_chip *c = &chips[i].chip;
+
+		sprintf(chips[i].label, "gpio-%d", i);
+		chips[i].regbase = (void __iomem *)GPIO_BANK(i);
+
+		c->base  = gpio;
+		c->label = chips[i].label;
+
+		c->direction_input  = pxa_gpio_direction_input;
+		c->direction_output = pxa_gpio_direction_output;
+		c->get = pxa_gpio_get;
+		c->set = pxa_gpio_set;
+
+		/* number of GPIOs on last bank may be less than 32 */
+		c->ngpio = (gpio + 31 > gpio_end) ? (gpio_end - gpio + 1) : 32;
+		gpiochip_add(c);
+	}
+	pxa_gpio_chips = chips;
+	return 0;
+}
+
+/* Update only those GRERx and GFERx edge detection register bits if those
+ * bits are set in c->irq_mask
+ */
+static inline void update_edge_detect(struct pxa_gpio_chip *c)
+{
+	uint32_t grer, gfer;
+
+	grer = __raw_readl(c->regbase + GRER_OFFSET) & ~c->irq_mask;
+	gfer = __raw_readl(c->regbase + GFER_OFFSET) & ~c->irq_mask;
+	grer |= c->irq_edge_rise & c->irq_mask;
+	gfer |= c->irq_edge_fall & c->irq_mask;
+	__raw_writel(grer, c->regbase + GRER_OFFSET);
+	__raw_writel(gfer, c->regbase + GFER_OFFSET);
+}
+
+static int pxa_gpio_irq_type(struct irq_data *d, unsigned int type)
+{
+	struct pxa_gpio_chip *c;
+	int gpio = irq_to_gpio(d->irq);
+	unsigned long gpdr, mask = GPIO_bit(gpio);
+
+	c = gpio_to_pxachip(gpio);
+
+	if (type == IRQ_TYPE_PROBE) {
+		/* Don't mess with enabled GPIOs using preconfigured edges or
+		 * GPIOs set to alternate function or to output during probe
+		 */
+		if ((c->irq_edge_rise | c->irq_edge_fall) & GPIO_bit(gpio))
+			return 0;
+
+		if (__gpio_is_occupied(gpio))
+			return 0;
+
+		type = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;
+	}
+
+	gpdr = __raw_readl(c->regbase + GPDR_OFFSET);
+
+	if (__gpio_is_inverted(gpio))
+		__raw_writel(gpdr | mask,  c->regbase + GPDR_OFFSET);
+	else
+		__raw_writel(gpdr & ~mask, c->regbase + GPDR_OFFSET);
+
+	if (type & IRQ_TYPE_EDGE_RISING)
+		c->irq_edge_rise |= mask;
+	else
+		c->irq_edge_rise &= ~mask;
+
+	if (type & IRQ_TYPE_EDGE_FALLING)
+		c->irq_edge_fall |= mask;
+	else
+		c->irq_edge_fall &= ~mask;
+
+	update_edge_detect(c);
+
+	pr_debug("%s: IRQ%d (GPIO%d) - edge%s%s\n", __func__, d->irq, gpio,
+		((type & IRQ_TYPE_EDGE_RISING)  ? " rising"  : ""),
+		((type & IRQ_TYPE_EDGE_FALLING) ? " falling" : ""));
+	return 0;
+}
+
+static void pxa_gpio_demux_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct pxa_gpio_chip *c;
+	int loop, gpio, gpio_base, n;
+	unsigned long gedr;
+	struct irq_chip *chip = irq_get_chip(irq);
+
+	chained_irq_enter(chip, desc);
+	do {
+		loop = 0;
+		for_each_gpio_chip(gpio, c) {
+			gpio_base = c->chip.base;
+
+			gedr = __raw_readl(c->regbase + GEDR_OFFSET);
+
+			n = find_first_bit(&gedr, BITS_PER_LONG);
+			while (n < BITS_PER_LONG) {
+				loop = 1;
+
+				generic_handle_irq(gpio_to_irq(gpio_base + n));
+				n = find_next_bit(&gedr, BITS_PER_LONG, n + 1);
+			}
+		}
+	} while (loop);
+	chained_irq_exit(chip, desc);
+}
+
+static void pxa_ack_muxed_gpio(struct irq_data *d)
+{
+	int gpio = irq_to_gpio(d->irq);
+	struct pxa_gpio_chip *c = gpio_to_pxachip(gpio);
+
+	__raw_writel(GPIO_bit(gpio), c->regbase + GEDR_OFFSET);
+}
+
+static void pxa_mask_muxed_gpio(struct irq_data *d)
+{
+	int gpio = irq_to_gpio(d->irq);
+	struct pxa_gpio_chip *c = gpio_to_pxachip(gpio);
+	uint32_t grer, gfer;
+
+	c->irq_mask &= ~GPIO_bit(gpio);
+
+	grer = __raw_readl(c->regbase + GRER_OFFSET) & ~GPIO_bit(gpio);
+	gfer = __raw_readl(c->regbase + GFER_OFFSET) & ~GPIO_bit(gpio);
+	__raw_writel(grer, c->regbase + GRER_OFFSET);
+	__raw_writel(gfer, c->regbase + GFER_OFFSET);
+}
+
+static void pxa_unmask_muxed_gpio(struct irq_data *d)
+{
+	int gpio = irq_to_gpio(d->irq);
+	struct pxa_gpio_chip *c = gpio_to_pxachip(gpio);
+
+	c->irq_mask |= GPIO_bit(gpio);
+	update_edge_detect(c);
+}
+
+static struct irq_chip pxa_muxed_gpio_chip = {
+	.name		= "GPIO",
+	.irq_ack	= pxa_ack_muxed_gpio,
+	.irq_mask	= pxa_mask_muxed_gpio,
+	.irq_unmask	= pxa_unmask_muxed_gpio,
+	.irq_enable	= pxa_unmask_muxed_gpio,
+	.irq_disable	= pxa_mask_muxed_gpio,
+	.irq_set_type	= pxa_gpio_irq_type,
+};
+
+void __init pxa_init_gpio(int mux_irq, int start, int end, set_wake_t fn)
+{
+	struct pxa_gpio_chip *c;
+	int gpio, irq;
+
+	pxa_last_gpio = end;
+
+	/* Initialize GPIO chips */
+	pxa_init_gpio_chip(end);
+
+	/* clear all GPIO edge detects */
+	for_each_gpio_chip(gpio, c) {
+		__raw_writel(0, c->regbase + GFER_OFFSET);
+		__raw_writel(0, c->regbase + GRER_OFFSET);
+		__raw_writel(~0,c->regbase + GEDR_OFFSET);
+	}
+
+	for (irq  = gpio_to_irq(start); irq <= gpio_to_irq(end); irq++) {
+		irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
+					 handle_edge_irq);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	/* Install handler for GPIO>=2 edge detect interrupts */
+	irq_set_chained_handler(mux_irq, pxa_gpio_demux_handler);
+	pxa_muxed_gpio_chip.irq_set_wake = fn;
+}
+
+#ifdef CONFIG_PM
+static int pxa_gpio_suspend(void)
+{
+	struct pxa_gpio_chip *c;
+	int gpio;
+
+	for_each_gpio_chip(gpio, c) {
+		c->saved_gplr = __raw_readl(c->regbase + GPLR_OFFSET);
+		c->saved_gpdr = __raw_readl(c->regbase + GPDR_OFFSET);
+		c->saved_grer = __raw_readl(c->regbase + GRER_OFFSET);
+		c->saved_gfer = __raw_readl(c->regbase + GFER_OFFSET);
+
+		/* Clear GPIO transition detect bits */
+		__raw_writel(0xffffffff, c->regbase + GEDR_OFFSET);
+	}
+	return 0;
+}
+
+static void pxa_gpio_resume(void)
+{
+	struct pxa_gpio_chip *c;
+	int gpio;
+
+	for_each_gpio_chip(gpio, c) {
+		/* restore level with set/clear */
+		__raw_writel( c->saved_gplr, c->regbase + GPSR_OFFSET);
+		__raw_writel(~c->saved_gplr, c->regbase + GPCR_OFFSET);
+
+		__raw_writel(c->saved_grer, c->regbase + GRER_OFFSET);
+		__raw_writel(c->saved_gfer, c->regbase + GFER_OFFSET);
+		__raw_writel(c->saved_gpdr, c->regbase + GPDR_OFFSET);
+	}
+}
+#else
+#define pxa_gpio_suspend	NULL
+#define pxa_gpio_resume		NULL
+#endif
+
+struct syscore_ops pxa_gpio_syscore_ops = {
+	.suspend	= pxa_gpio_suspend,
+	.resume		= pxa_gpio_resume,
+};
diff --git a/arch/arm/plat-pxa/include/plat/clock.h b/arch/arm/plat-pxa/include/plat/clock.h
new file mode 100644
index 0000000..4d1de60
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/clock.h
@@ -0,0 +1,112 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/pxa/clock.h
+ *
+ *  based on arch/arm/mach-tegra/clock.h
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef __MACH_PXA_CLOCK_H
+#define __MACH_PXA_CLOCK_H
+
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/clkdev.h>
+
+#include <plat/dvfs.h>
+
+struct clk_mux_sel {
+	struct clk *input;
+	u32 value;
+};
+
+enum reg_type {
+	SOURCE = 0,
+	DIV,
+	MUL,
+	REG_TYPE_NUM,
+};
+
+enum reg_control {
+	STATUS = 0,
+	CONTROL,
+	REG_CONTROL_NUM,
+};
+
+struct clkops {
+	void (*init) (struct clk *);
+	int (*enable) (struct clk *);
+	void (*disable) (struct clk *);
+	unsigned long (*getrate) (struct clk *);
+	int (*setrate) (struct clk *, unsigned long);
+	int (*set_parent) (struct clk *, struct clk *);
+	long (*round_rate) (struct clk *, unsigned long);
+};
+
+struct clk {
+	const struct clkops *ops;
+
+	/* node for master clocks list */
+	struct list_head node;
+	struct clk_lookup lookup;
+	struct dvfs *dvfs;
+
+	bool cansleep;
+	bool dynamic_change;
+	const char *name;
+
+	u32 refcnt;
+	struct clk *parent;
+	struct clk **dependence;
+	u32 dependence_count;
+	u32 div;
+	u32 mul;
+
+	const struct clk_mux_sel *inputs;
+
+	struct {
+		u32 reg;
+		u32 reg_shift;
+		u32 reg_mask;
+	} reg_data[REG_TYPE_NUM][REG_CONTROL_NUM];
+
+	struct list_head shared_bus_list;
+
+	struct mutex mutex;
+	spinlock_t spinlock;
+
+	unsigned long rate;
+
+#ifdef CONFIG_LOCKDEP
+	struct lock_class_key lockdep_key;
+#endif
+	/*
+	 * This is for the old MMP clock implementation
+	 * will remove them later
+	 */
+	/* For APBC clocks */
+	void __iomem *clk_rst;
+	int fnclksel;
+	/* value for clock enable (APMU) */
+	uint32_t enable_val;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*dent;	/* For visible tree hierarchy */
+#endif
+};
+
+void clk_init(struct clk *clk);
+int clk_reparent(struct clk *c, struct clk *parent);
+void clk_set_cansleep(struct clk *c);
+unsigned long clk_get_rate_locked(struct clk *c);
+struct clk *get_clock_by_name(const char *name);
+
+static inline bool clk_is_dvfs(struct clk *c)
+{
+	return (c->dvfs != NULL);
+}
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/debugfs.h b/arch/arm/plat-pxa/include/plat/debugfs.h
new file mode 100644
index 0000000..e55d4de
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/debugfs.h
@@ -0,0 +1,22 @@
+/*
+ * arch/arm/plat-pxa/debugfs.h
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PXA_DEBUGFS_H_
+#define __PXA_DEBUGFS_H_
+
+#ifdef CONFIG_CACHE_L2X0
+extern void __iomem *l2x0_base;
+#endif
+
+extern struct dentry *pxa;
+
+#endif  /* __PXA_DEBUGFS_H_ */
diff --git a/arch/arm/plat-pxa/include/plat/devfreq.h b/arch/arm/plat-pxa/include/plat/devfreq.h
new file mode 100644
index 0000000..0a12517
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/devfreq.h
@@ -0,0 +1,56 @@
+/*
+ * devfreq: Generic Dynamic Voltage and Frequency Scaling (DVFS) Framework
+ *	    for Non-CPU Devices.
+ *
+ * Copyright (C) 2012 Marvell
+ *	Xiaoguang Chen <chenxg@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __PXA_DEVFREQ_H__
+#define __PXA_DEVFREQ_H__
+
+#include <linux/devfreq.h>
+
+#define INIT_FREQ_TABLE(_index, _freq)	\
+	{				\
+		.index = _index,	\
+		.frequency = _freq,	\
+	}
+
+struct devfreq_platform_data {
+	const char *clk_name;
+	struct devfreq_frequency_table *freq_table;
+	int (*setup_freq_table) (struct devfreq *devfreq);
+#ifdef CONFIG_DDR_DEVFREQ
+	unsigned int interleave_is_on;
+	unsigned int hw_base[2];
+	struct devfreq_pm_qos_table *qos_list;
+#endif
+};
+
+#ifdef CONFIG_DDR_DEVFREQ
+/*
+ * DDR PM constraint value, these lvl can be used by device driver.
+ * The relationship of Qos lvl and corresponding ddr frequency
+ * should be handled in platform. Frequency should be ordered in
+ * ascending.
+ * This can be used to avoid driver use the same lvl Qos value
+ * instead of different frequency on different platforms.
+ */
+enum ddr_pm_qos_constraint {
+	DDR_CONSTRAINT_LVL_RSV = 0,
+	DDR_CONSTRAINT_LVL0,
+	DDR_CONSTRAINT_LVL1,
+	DDR_CONSTRAINT_LVL2,
+	DDR_CONSTRAINT_LVL4,
+	DDR_CONSTRAINT_LVL5,
+	DDR_CONSTRAINT_LVL_MAX,
+};
+
+#endif
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/dma.h b/arch/arm/plat-pxa/include/plat/dma.h
index a7b91dc..fb4c393 100644
--- a/arch/arm/plat-pxa/include/plat/dma.h
+++ b/arch/arm/plat-pxa/include/plat/dma.h
@@ -16,7 +16,9 @@
 #define DCSR_RUN	(1 << 31)	/* Run Bit (read / write) */
 #define DCSR_NODESC	(1 << 30)	/* No-Descriptor Fetch (read / write) */
 #define DCSR_STOPIRQEN	(1 << 29)	/* Stop Interrupt Enable (read / write) */
+#define DCSR_RASIRQEN	(1 << 23)	/* RAS Interrupt enable (read / write)*/
 #define DCSR_REQPEND	(1 << 8)	/* Request Pending (read-only) */
+#define DCSR_RASINTR	(1 << 4)	/* RAS Interrupt status (read / write)*/
 #define DCSR_STOPSTATE	(1 << 3)	/* Stop State (read-only) */
 #define DCSR_ENDINTR	(1 << 2)	/* End Interrupt (read / write) */
 #define DCSR_STARTINTR	(1 << 1)	/* Start Interrupt (read / write) */
diff --git a/arch/arm/plat-pxa/include/plat/dvfs.h b/arch/arm/plat-pxa/include/plat/dvfs.h
new file mode 100644
index 0000000..e36728f
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/dvfs.h
@@ -0,0 +1,69 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/plat/dvfs.h
+ *
+ *  based on arch/arm/mach-tegra/dvfs.h
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef _PXA_DVFS_H_
+#define _PXA_DVFS_H_
+
+/*
+ * dvfs_relationship between to rails, "from" and "to"
+ * when the rail changes, it will call dvfs_rail_update on the rails
+ * in the relationship_to list.
+ * when determining the voltage to set a rail to, it will consider each
+ * rail in the relationship_from list.
+ */
+struct dvfs_relationship {
+	struct dvfs_rail *to;
+	struct dvfs_rail *from;
+	int (*solve)(struct dvfs_rail *, struct dvfs_rail *);
+
+	struct list_head to_node; /* node in relationship_to list */
+	struct list_head from_node; /* node in relationship_from list */
+};
+
+struct dvfs_rail {
+	const char *reg_id;
+	int min_millivolts;
+	int max_millivolts;
+	int nominal_millivolts;
+	int step;
+
+	struct list_head node;  /* node in dvfs_rail_list */
+	struct list_head dvfs;  /* list head of attached dvfs clocks */
+	struct list_head relationships_to;
+	struct list_head relationships_from;
+	struct regulator *reg;
+	int millivolts;
+	int new_millivolts;
+};
+
+struct vol_table {
+	unsigned long freq; /* in KHz */
+	int millivolts;
+};
+
+struct dvfs {
+	const char *clk_name;
+
+	/* Must be initialized before dvfs_init */
+	struct vol_table *vol_freq_table;
+	int num_freqs;
+	struct dvfs_rail *dvfs_rail;
+
+	int millivolts;
+	struct list_head dvfs_node;
+};
+
+int enable_dvfs_on_clk(struct clk *c, struct dvfs *d);
+int dvfs_init_rails(struct dvfs_rail *dvfs_rails[], int n);
+void dvfs_add_relationships(struct dvfs_relationship *rels, int n);
+int dvfs_set_rate(struct clk *c, unsigned long rate);
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/fb_ioctl.h b/arch/arm/plat-pxa/include/plat/fb_ioctl.h
new file mode 100644
index 0000000..e8c42df
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/fb_ioctl.h
@@ -0,0 +1,276 @@
+/*
+ * linux/arch/arm/plat-pxa/include/plat/overlay_ioctl.h
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_PLAT_FB_IOCTL_H
+#define __ASM_PLAT_FB_IOCTL_H
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define FB_IOC_MAGIC                        'm'
+#define FB_IOCTL_CONFIG_CURSOR              _IO(FB_IOC_MAGIC, 0)
+#define FB_IOCTL_DUMP_REGS                  _IO(FB_IOC_MAGIC, 1)
+#define FB_IOCTL_CLEAR_IRQ                  _IO(FB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define FB_IOCTL_SET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 3)
+#define FB_IOCTL_GET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define FB_IOCTL_CREATE_VID_BUFFER          _IO(FB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define FB_IOCTL_SET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 6)
+#define FB_IOCTL_GET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    FB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define FB_IOCTL_FLIP_VID_BUFFER            _IO(FB_IOC_MAGIC, 8)
+
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use FB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define FB_IOCTL_GET_BUFF_ADDR              _IO(FB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define FB_IOCTL_SET_VID_OFFSET             _IO(FB_IOC_MAGIC, 10)
+#define FB_IOCTL_GET_VID_OFFSET             _IO(FB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_MEMORY_TOGGLE          _IO(FB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 14)
+#define FB_IOCTL_SWITCH_GRA_OVLY            _IO(FB_IOC_MAGIC, 15)
+#define FB_IOCTL_SWITCH_VID_OVLY            _IO(FB_IOC_MAGIC, 16)
+
+/* For VPro integration */
+#define FB_IOCTL_GET_FREELIST               _IO(FB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define FB_IOCTL_WAIT_VSYNC                 _IO(FB_IOC_MAGIC, 18)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FB_IOCTL_CLEAR_FRAMEBUFFER              _IO(FB_IOC_MAGIC, 19)
+
+/* Wait for vsync each time pan display */
+#define FB_IOCTL_WAIT_VSYNC_ON              _IO(FB_IOC_MAGIC, 20)
+#define FB_IOCTL_WAIT_VSYNC_OFF             _IO(FB_IOC_MAGIC, 21)
+
+/* Get and set the display surface */
+#define FB_IOCTL_GET_SURFACE			_IO(FB_IOC_MAGIC, 22)
+#define FB_IOCTL_SET_SURFACE			_IO(FB_IOC_MAGIC, 23)
+
+/* Graphic partial display ctrl */
+#define FB_IOCTL_GRA_PARTDISP			_IO(FB_IOC_MAGIC, 24)
+
+/* VDMA enable/disable */
+#define FB_IOCTL_VDMA_SET			_IO(FB_IOC_MAGIC, 25)
+
+/* enable/disable 3D mode. Hardcode ioctl id for hdmi stack include issue */
+#define FB_IOCTL_ENABLE_3D                 0xffee
+
+/* Global alpha blend controls - Maintaining compatibility with existing
+   user programs. */
+#define FB_IOCTL_PUT_VIDEO_ALPHABLEND            0xeb
+#define FB_IOCTL_PUT_GLOBAL_ALPHABLEND           0xe1
+#define FB_IOCTL_PUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FB_IOCTL_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FB_IOCTL_SWAP_GRAPHIC_U_V            0xe4
+#define FB_IOCTL_SWAP_GRAPHIC_Y_UV           0xe5
+#define FB_IOCTL_SWAP_VIDEO_RED_BLUE         0xe6
+#define FB_IOCTL_SWAP_VIDEO_U_V              0xe7
+#define FB_IOCTL_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FB_IOCTL_GET_CHROMAKEYS		0xe9
+#define FB_IOCTL_PUT_CHROMAKEYS		0xea
+
+/* cmu operation */
+#define FB_IOCTL_CMU_SWITCH		0xf1
+#define FB_IOCTL_CMU_WRITE		0xf2
+#define FB_IOCTL_CMU_READ		0xf3
+#define FB_IOCTL_CMU_SET_ROUTE		0xf4
+#define FB_IOCTL_CMU_SET_PIP		0xf5
+#define FB_IOCTL_CMU_GET_RES		0xf6
+#define FB_IOCTL_CMU_SET_LETTER_BOX 0xf7
+
+/* gamma correction */
+#define FB_IOCTL_GAMMA_SET 		0xff
+
+#define FB_VMODE_RGB565			0x100
+#define FB_VMODE_BGR565                 0x101
+#define FB_VMODE_RGB1555		0x102
+#define FB_VMODE_BGR1555                0x103
+#define FB_VMODE_RGB888PACK		0x104
+#define FB_VMODE_BGR888PACK		0x105
+#define FB_VMODE_RGB888UNPACK		0x106
+#define FB_VMODE_BGR888UNPACK		0x107
+#define FB_VMODE_RGBA888		0x108
+#define FB_VMODE_BGRA888		0x109
+
+#define FB_VMODE_YUV422PACKED               0x0
+#define FB_VMODE_YUV422PACKED_SWAPUV        0x1
+#define FB_VMODE_YUV422PACKED_SWAPYUorV     0x2
+#define FB_VMODE_YUV422PLANAR               0x3
+#define FB_VMODE_YUV422PLANAR_SWAPUV        0x4
+#define FB_VMODE_YUV422PLANAR_SWAPYUorV     0x5
+#define FB_VMODE_YUV420PLANAR               0x6
+#define FB_VMODE_YUV420PLANAR_SWAPUV        0x7
+#define FB_VMODE_YUV420PLANAR_SWAPYUorV     0x8
+#define FB_VMODE_YUV422PACKED_IRE_90_270    0x9
+
+#define FB_HWCMODE_1BITMODE                 0x0
+#define FB_HWCMODE_2BITMODE                 0x1
+
+#define FB_DISABLE_COLORKEY_MODE            0x0
+#define FB_ENABLE_Y_COLORKEY_MODE           0x1
+#define FB_ENABLE_U_COLORKEY_MODE           0x2
+#define FB_ENABLE_V_COLORKEY_MODE           0x4
+#define FB_ENABLE_RGB_COLORKEY_MODE         0x3
+#define FB_ENABLE_R_COLORKEY_MODE           0x5
+#define FB_ENABLE_G_COLORKEY_MODE           0x6
+#define FB_ENABLE_B_COLORKEY_MODE           0x7
+
+#define FB_VID_PATH_ALPHA		0x0
+#define FB_GRA_PATH_ALPHA		0x1
+#define FB_CONFIG_ALPHA			0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define MAX_QUEUE_NUM 30
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define FBVideoMode int
+
+struct _sViewPortInfo {
+	unsigned short srcWidth;        /* video source size */
+	unsigned short srcHeight;
+	unsigned short zoomXSize;       /* size after zooming */
+	unsigned short zoomYSize;
+	unsigned short yPitch;
+	unsigned short uPitch;
+	unsigned short vPitch;
+	unsigned int rotation;
+	unsigned int yuv_format;
+};
+
+struct _sViewPortOffset {
+	unsigned short xOffset;         /* position on screen */
+	unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+	unsigned char   frameID;        /* which frame wants */
+	 /* new buffer (PA). 3 addr for YUV planar */
+	unsigned char *startAddr[3];
+	unsigned char *inputData;       /* input buf address (VA) */
+	unsigned int length;            /* input data's length */
+};
+
+struct _sColorKeyNAlpha {
+	unsigned int mode;
+	unsigned int alphapath;
+	unsigned int config;
+	unsigned int Y_ColorAlpha;
+	unsigned int U_ColorAlpha;
+	unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+	FBVideoMode videoMode;
+	struct _sViewPortInfo viewPortInfo;
+	struct _sViewPortOffset viewPortOffset;
+	struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct mvdisp_cmu_config {
+	unsigned int addr;
+	unsigned int data;
+};
+
+struct mvdisp_cmu_pip {
+	unsigned int left;
+	unsigned int right;
+	unsigned int top;
+	unsigned int bottom;
+};
+
+struct mvdisp_partdisp {
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	int id;
+	/* partial display horizontal starting pixel number
+	 * NOTE: it must be 64x */
+	unsigned int horpix_start;
+	/* partial display vertical starting line number */
+	unsigned int vertline_start;
+	/* partial display horizontal ending pixel number
+	 * NOTE: it must be 64x */
+	unsigned int horpix_end;
+	/* partial display vertical ending line number */
+	unsigned int vertline_end;
+	/* graphic color for partial disabled area,
+	 * color format should be RGB565 */
+	unsigned short color;
+};
+
+struct mvdisp_vdma {
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	unsigned int path;
+	/* 0: grafhics, 1: video */
+	unsigned int layer;
+	unsigned int enable;
+};
+
+struct mvdisp_gamma {
+#define GAMMA_ENABLE	(1 << 0)
+#define GAMMA_DUMP	(1 << 1)
+	unsigned int	flag;
+#define GAMMA_TABLE_LEN	256
+	char 		table[GAMMA_TABLE_LEN];
+};
+
+enum {
+	SYNC_SELF,
+	SYNC_PANEL,
+	SYNC_TV,
+	SYNC_PANEL_TV,
+};
+#endif /* __ASM_PLAT_FB_IOCTL_H */
diff --git a/arch/arm/plat-pxa/include/plat/gpio.h b/arch/arm/plat-pxa/include/plat/gpio.h
new file mode 100644
index 0000000..1ddd2b9
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/gpio.h
@@ -0,0 +1,64 @@
+#ifndef __PLAT_GPIO_H
+#define __PLAT_GPIO_H
+
+struct irq_data;
+
+/*
+ * We handle the GPIOs by banks, each bank covers up to 32 GPIOs with
+ * one set of registers. The register offsets are organized below:
+ *
+ *           GPLR    GPDR    GPSR    GPCR    GRER    GFER    GEDR
+ * BANK 0 - 0x0000  0x000C  0x0018  0x0024  0x0030  0x003C  0x0048
+ * BANK 1 - 0x0004  0x0010  0x001C  0x0028  0x0034  0x0040  0x004C
+ * BANK 2 - 0x0008  0x0014  0x0020  0x002C  0x0038  0x0044  0x0050
+ *
+ * BANK 3 - 0x0100  0x010C  0x0118  0x0124  0x0130  0x013C  0x0148
+ * BANK 4 - 0x0104  0x0110  0x011C  0x0128  0x0134  0x0140  0x014C
+ * BANK 5 - 0x0108  0x0114  0x0120  0x012C  0x0138  0x0144  0x0150
+ *
+ * NOTE:
+ *   BANK 3 is only available on PXA27x and later processors.
+ *   BANK 4 and 5 are only available on PXA935
+ */
+
+#define GPIO_BANK(n)	(GPIO_REGS_VIRT + BANK_OFF(n))
+
+#define GPLR_OFFSET	0x00
+#define GPDR_OFFSET	0x0C
+#define GPSR_OFFSET	0x18
+#define GPCR_OFFSET	0x24
+#define GRER_OFFSET	0x30
+#define GFER_OFFSET	0x3C
+#define GEDR_OFFSET	0x48
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	if (__builtin_constant_p(gpio) && (gpio < NR_BUILTIN_GPIO))
+		return GPLR(gpio) & GPIO_bit(gpio);
+	else
+		return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	if (__builtin_constant_p(gpio) && (gpio < NR_BUILTIN_GPIO)) {
+		if (value)
+			GPSR(gpio) = GPIO_bit(gpio);
+		else
+			GPCR(gpio) = GPIO_bit(gpio);
+	} else
+		__gpio_set_value(gpio, value);
+}
+
+#define gpio_cansleep		__gpio_cansleep
+
+/* NOTE: some PXAs have fewer on-chip GPIOs (like PXA255, with 85).
+ * Those cases currently cause holes in the GPIO number space, the
+ * actual number of the last GPIO is recorded by 'pxa_last_gpio'.
+ */
+extern int pxa_last_gpio;
+
+typedef int (*set_wake_t)(struct irq_data *d, unsigned int on);
+
+extern void pxa_init_gpio(int mux_irq, int start, int end, set_wake_t fn);
+#endif /* __PLAT_GPIO_H */
diff --git a/arch/arm/plat-pxa/include/plat/mfp.h b/arch/arm/plat-pxa/include/plat/mfp.h
index 5c79c29..0567286 100644
--- a/arch/arm/plat-pxa/include/plat/mfp.h
+++ b/arch/arm/plat-pxa/include/plat/mfp.h
@@ -215,6 +215,80 @@ enum {
 	MFP_PIN_GPIO189,
 	MFP_PIN_GPIO190,
 	MFP_PIN_GPIO191,
+	MFP_PIN_GPIO_MAX,
+
+	MFP_PIN_RF_MFP0 = MFP_PIN_GPIO133,
+	MFP_PIN_RF_MFP1,
+	MFP_PIN_RF_MFP2,
+	MFP_PIN_RF_MFP3,
+	MFP_PIN_RF_MFP4,
+	MFP_PIN_RF_MFP5,
+	MFP_PIN_RF_MFP6,
+	MFP_PIN_RF_MFP7,
+	MFP_PIN_RF_MFP8,
+	MFP_PIN_RF_MFP9,
+	MFP_PIN_RF_MFP10,
+	MFP_PIN_RF_MFP11,
+	MFP_PIN_RF_MFP12,
+	MFP_PIN_RF_MFP13,
+	MFP_PIN_RF_MFP14,
+	MFP_PIN_RF_MFP15,
+	MFP_PIN_RF_MFP16,
+	MFP_PIN_RF_MFP17,
+	MFP_PIN_RF_MFP18,
+	MFP_PIN_RF_MFP19,
+	MFP_PIN_RF_MFP20,
+	MFP_PIN_RF_MFP21,
+	MFP_PIN_RF_MFP22,
+	MFP_PIN_RF_MFP23,
+	MFP_PIN_RF_MFP24,
+	MFP_PIN_RF_MFP25,
+	MFP_PIN_RF_MFP26,
+	MFP_PIN_RF_MFP27,
+	MFP_PIN_RF_MFP28,
+	MFP_PIN_RF_MFP29,
+	MFP_PIN_RF_MFP30,
+
+	MFP_PIN_MEM_MFP0 = MFP_PIN_GPIO164,
+	MFP_PIN_MEM_MFP1,
+	MFP_PIN_MEM_MFP2,
+	MFP_PIN_MEM_MFP3,
+	MFP_PIN_MEM_MFP4,
+	MFP_PIN_MEM_MFP5,
+	MFP_PIN_MEM_MFP6,
+	MFP_PIN_MEM_MFP7,
+	MFP_PIN_MEM_MFP8,
+	MFP_PIN_MEM_MFP9,
+	MFP_PIN_MEM_MFP10,
+	MFP_PIN_MEM_MFP11,
+	MFP_PIN_MEM_MFP12,
+	MFP_PIN_MEM_MFP13,
+	MFP_PIN_MEM_MFP14,
+	MFP_PIN_MEM_MFP15,
+	MFP_PIN_MEM_MFP16,
+	MFP_PIN_MEM_MFP17,
+	MFP_PIN_MEM_MFP18,
+	MFP_PIN_MEM_MFP19,
+	MFP_PIN_MEM_MFP20,
+	MFP_PIN_MEM_MFP21,
+	MFP_PIN_MEM_MFP22,
+	MFP_PIN_MEM_MFP23,
+	MFP_PIN_MEM_MFP24,
+	MFP_PIN_MEM_MFP25,
+	MFP_PIN_MEM_MFP26,
+	MFP_PIN_MEM_MFP27,
+	MFP_PIN_MEM_MFP28,
+	MFP_PIN_MEM_MFP29,
+	MFP_PIN_MEM_MFP30,
+	MFP_PIN_MEM_MFP31,
+	MFP_PIN_MEM_MFP32,
+	MFP_PIN_MEM_MFP33,
+	MFP_PIN_MEM_MFP34,
+	MFP_PIN_MEM_MFP35,
+	MFP_PIN_MEM_MFP36,
+	MFP_PIN_MEM_MFP37,
+	MFP_PIN_MEM_MFP38,
+	MFP_PIN_MEM_MFP39,
 
 	MFP_PIN_GPIO255 = 255,
 
@@ -308,11 +382,10 @@ enum {
 	MFP_PIN_MMC1_CD,
 	MFP_PIN_MMC1_WP,
 
+	/* additional pins on PXA910 */
+	MFP_PIN_VCXOREQ,
+
 	/* additional pins on PXA930 */
-	MFP_PIN_GSIM_UIO,
-	MFP_PIN_GSIM_UCLK,
-	MFP_PIN_GSIM_UDET,
-	MFP_PIN_GSIM_nURST,
 	MFP_PIN_PMIC_INT,
 	MFP_PIN_RDY,
 
@@ -323,6 +396,9 @@ enum {
 	MFP_PIN_TWSI4_SDA,
 	MFP_PIN_CLK_REQ,
 
+	/* additional pins on PXA988 */
+	MFP_PIN_ANT_SW4,
+
 	MFP_PIN_MAX,
 };
 
@@ -378,6 +454,10 @@ typedef unsigned long mfp_cfg_t;
 #define MFP_DS13X		(0x7 << 13)
 #define MFP_DS_MASK		(0x7 << 13)
 #define MFP_DS(x)		(((x) >> 13) & 0x7)
+#define MFP_VERY_SLOW		MFP_DS01X
+#define MFP_SLOW		MFP_DS02X
+#define MFP_MEDIUM		MFP_DS03X
+#define MFP_FAST		MFP_DS04X
 
 #define MFP_LPM_DEFAULT		(0x0 << 16)
 #define MFP_LPM_DRIVE_LOW	(0x1 << 16)
@@ -385,7 +465,6 @@ typedef unsigned long mfp_cfg_t;
 #define MFP_LPM_PULL_LOW	(0x3 << 16)
 #define MFP_LPM_PULL_HIGH	(0x4 << 16)
 #define MFP_LPM_FLOAT		(0x5 << 16)
-#define MFP_LPM_INPUT		(0x6 << 16)
 #define MFP_LPM_STATE_MASK	(0x7 << 16)
 #define MFP_LPM_STATE(x)	(((x) >> 16) & 0x7)
 
@@ -423,7 +502,12 @@ typedef unsigned long mfp_cfg_t;
 	((MFP_CFG_DEFAULT & ~(MFP_AF_MASK | MFP_DS_MASK | MFP_LPM_STATE_MASK)) |\
 	 (MFP_PIN(MFP_PIN_##pin) | MFP_##af | MFP_##drv | MFP_LPM_##lpm))
 
-#if defined(CONFIG_PXA3xx) || defined(CONFIG_PXA95x) || defined(CONFIG_ARCH_MMP)
+#define MFP_CFG_ALL(pin, af, drv, lpm, pull)    \
+	((MFP_CFG_DEFAULT & ~(MFP_AF_MASK | MFP_DS_MASK | MFP_LPM_STATE_MASK | MFP_PULL_MASK)) |\
+	 (MFP_PIN(MFP_PIN_##pin) | MFP_##af | MFP_##drv | MFP_LPM_##lpm | MFP_##pull))
+
+#if defined(CONFIG_PXA3xx) || defined(CONFIG_PXA93x)			\
+	|| defined(CONFIG_PXA95x) || defined(CONFIG_ARCH_MMP)
 /*
  * each MFP pin will have a MFPR register, since the offset of the
  * register varies between processors, the processor specific code
@@ -456,7 +540,96 @@ struct mfp_addr_map {
 
 #define MFP_ADDR_END	{ MFP_PIN_INVALID, 0 }
 
-void __init mfp_init_base(void __iomem *mfpr_base);
+#define MFPR_SIZE	(PAGE_SIZE)
+
+/* MFPR register bit definitions */
+#define MFPR_PULL_SEL		(0x1 << 15)
+#define MFPR_PULLUP_EN		(0x1 << 14)
+#define MFPR_PULLDOWN_EN	(0x1 << 13)
+#define MFPR_PULL_MASK		(0x7 << 13)
+#ifndef CONFIG_CPU_PXA988
+#define MFPR_SLEEP_SEL		(0x1 << 9)
+#else
+#define MFPR_SLEEP_SEL		((0x1 << 9) | (0x1 << 3))
+#endif
+#define MFPR_SLEEP_OE_N		(0x1 << 7)
+#define MFPR_EDGE_CLEAR		(0x1 << 6)
+#define MFPR_EDGE_FALL_EN	(0x1 << 5)
+#define MFPR_EDGE_RISE_EN	(0x1 << 4)
+
+#define MFPR_SLEEP_DATA(x)	(((x) & 0x1) << 8)
+#define MFPR_DRIVE(x)		(((x) & 0x7) << 10)
+#define MFPR_AF_SEL(x)		(((x) & 0x7) << 0)
+#define MFPR_AF_MASK		(0x7 << 0)
+
+#define MFPR_EDGE_NONE		(MFPR_EDGE_CLEAR)
+#define MFPR_EDGE_RISE		(MFPR_EDGE_RISE_EN)
+#define MFPR_EDGE_FALL		(MFPR_EDGE_FALL_EN)
+#define MFPR_EDGE_BOTH		(MFPR_EDGE_RISE | MFPR_EDGE_FALL)
+
+/*
+ * Table that determines the low power modes outputs, with actual settings
+ * used in parentheses for don't-care values. Except for the float output,
+ * the configured driven and pulled levels match, so if there is a need for
+ * non-LPM pulled output, the same configuration could probably be used.
+ *
+ * Output value  sleep_oe_n  sleep_data  pullup_en  pulldown_en  pull_sel
+ *                 (bit 7)    (bit 8)    (bit 14)     (bit 13)   (bit 15)
+ *
+ * Drive 0          0          0           0           X(1)       0
+ * Drive 1          0          1           X(1)        0	  0
+ * Pull hi (1)      1          X(1)        1           0	  0
+ * Pull lo (0)      1          X(0)        0           1	  0
+ * Z (float)        1          X(0)        0           0	  0
+ */
+#ifndef CONFIG_CPU_PXA988
+#define MFPR_LPM_NONE		(MFPR_SLEEP_OE_N)
+#define MFPR_LPM_DRIVE_LOW	(MFPR_SLEEP_DATA(0) | MFPR_PULLDOWN_EN)
+#define MFPR_LPM_DRIVE_HIGH	(MFPR_SLEEP_DATA(1) | MFPR_PULLUP_EN)
+#define MFPR_LPM_PULL_LOW	(MFPR_LPM_DRIVE_LOW  | MFPR_SLEEP_OE_N)
+#define MFPR_LPM_PULL_HIGH	(MFPR_LPM_DRIVE_HIGH | MFPR_SLEEP_OE_N)
+#define MFPR_LPM_FLOAT		(MFPR_SLEEP_OE_N)
+#define MFPR_LPM_MASK		(0xe080)
+#else /* CONFIG_CPU_PXA988 */
+/*
+ * Output value sleep_oe_n sleep_data sleep_sel
+ *               (bit 7)    (bit 8)   (bit 9/3)
+ * None            X(0)       X(0)      00
+ * Drive 0         0          0         11
+ * Drive 1         0          1         11
+ * Z (float)       1          X(0)      11
+ */
+#define MFPR_LPM_NONE		0
+#define MFPR_LPM_DRIVE_LOW	(MFPR_SLEEP_SEL | MFPR_SLEEP_DATA(0))
+#define MFPR_LPM_DRIVE_HIGH	(MFPR_SLEEP_SEL | MFPR_SLEEP_DATA(1))
+#define MFPR_LPM_PULL_LOW	0 /* Not supported */
+#define MFPR_LPM_PULL_HIGH	0 /* Not supported */
+#define MFPR_LPM_FLOAT		(MFPR_SLEEP_SEL | MFPR_SLEEP_OE_N)
+#define MFPR_LPM_MASK		(0x0388)
+#endif /* CONFIG_CPU_PXA988 */
+
+/*
+ * The pullup and pulldown state of the MFP pin at run mode is by default
+ * determined by the selected alternate function. In case that some buggy
+ * devices need to override this default behavior,  the definitions below
+ * indicates the setting of corresponding MFPR bits
+ *
+ * Definition       pull_sel  pullup_en  pulldown_en
+ * MFPR_PULL_NONE       0         0        0
+ * MFPR_PULL_LOW        1         0        1
+ * MFPR_PULL_HIGH       1         1        0
+ * MFPR_PULL_BOTH       1         1        1
+ * MFPR_PULL_FLOAT	1         0        0
+ */
+#define MFPR_PULL_NONE		(0)
+#define MFPR_PULL_LOW		(MFPR_PULL_SEL | MFPR_PULLDOWN_EN)
+#define MFPR_PULL_BOTH		(MFPR_PULL_LOW | MFPR_PULLUP_EN)
+#define MFPR_PULL_HIGH		(MFPR_PULL_SEL | MFPR_PULLUP_EN)
+#define MFPR_PULL_FLOAT		(MFPR_PULL_SEL)
+
+
+
+void __init mfp_init_base(unsigned long mfpr_base);
 void __init mfp_init_addr(struct mfp_addr_map *map);
 
 /*
@@ -470,6 +643,9 @@ void mfp_write(int mfp, unsigned long mfpr_val);
 void mfp_config(unsigned long *mfp_cfgs, int num);
 void mfp_config_run(void);
 void mfp_config_lpm(void);
-#endif /* CONFIG_PXA3xx || CONFIG_PXA95x || CONFIG_ARCH_MMP */
+void lpm_mfpr_edge_config(int mfp, unsigned long val);
+void lpm_mfpr_edge_detect_config(int mfp, unsigned long val);
+void lpm_mfpr_edge_detect_clear_config(int mfp);
+#endif /* CONFIG_PXA3xx || CONFIG_PXA93x || CONFIG_PXA95x || CONFIG_ARCH_MMP */
 
 #endif /* __ASM_PLAT_MFP_H */
diff --git a/arch/arm/plat-pxa/include/plat/pm.h b/arch/arm/plat-pxa/include/plat/pm.h
new file mode 100644
index 0000000..36b13ba
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pm.h
@@ -0,0 +1,43 @@
+/*
+ * Power Management Routines
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __PM_H__
+#define __PM_H__
+
+#include <linux/pm_qos_params.h>
+
+/* MMP2 cpuidle exit latency */
+#define EXIT_LATENCY_CORE_EXTIDLE		1
+#define EXIT_LATENCY_APPS_IDLE			10
+#define EXIT_LATENCY_APPS_SLEEP			20
+#define EXIT_LATENCY_CHIP_SLEEP			100
+
+#if defined(CONFIG_CPU_MMP2)
+#define PM_QOS_CONSTRAINT EXIT_LATENCY_CORE_EXTIDLE
+#define HDMI_FREQ_CONSTRAINT 800
+#elif defined(CONFIG_CPU_PXA988)
+#define PM_QOS_CONSTRAINT 1
+#elif defined(CONFIG_CPU_MMP3)
+#define PM_QOS_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#define HDMI_FREQ_CONSTRAINT 200
+#else
+#define PM_QOS_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#define HDMI_FREQ_CONSTRAINT PM_QOS_DEFAULT_VALUE
+#endif
+
+#if defined(CONFIG_CPU_MMP2) && defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM)
+void pwr_i2c_conflict_mutex_lock(void);
+void pwr_i2c_conflict_mutex_unlock(void);
+#else
+static inline void pwr_i2c_conflict_mutex_lock(void) {}
+static inline void pwr_i2c_conflict_mutex_unlock(void) {}
+#endif
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/pmem.h b/arch/arm/plat-pxa/include/plat/pmem.h
new file mode 100644
index 0000000..c36fcee
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pmem.h
@@ -0,0 +1,20 @@
+/*
+ *  arch/arm/plat-pxa/include/plat/pmem.h
+ *
+ *  Buffer Management Module
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+
+ *(C) Copyright 2009 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef _PXA_PMEM_H_
+#define _PXA_PMEM_H_
+
+extern void __init pxa_reserve_pmem_memblock(void);
+extern void __init pxa_add_pmem(void);
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h b/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
index abcc36e..0bcda30 100644
--- a/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
+++ b/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
@@ -43,7 +43,10 @@ struct pxa27x_keypad_platform_data {
 
 	/* direct keys */
 	int		direct_key_num;
+	unsigned int	direct_key_msk;
 	unsigned int	direct_key_map[MAX_DIRECT_KEY_NUM];
+	/* key polarity */
+	int active_low;
 
 	/* rotary encoders 0 */
 	int		enable_rotary0;
diff --git a/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h b/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
deleted file mode 100644
index c42f39f..0000000
--- a/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
+++ /dev/null
@@ -1,79 +0,0 @@
-#ifndef __ASM_ARCH_PXA3XX_NAND_H
-#define __ASM_ARCH_PXA3XX_NAND_H
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/partitions.h>
-
-struct pxa3xx_nand_timing {
-	unsigned int	tCH;  /* Enable signal hold time */
-	unsigned int	tCS;  /* Enable signal setup time */
-	unsigned int	tWH;  /* ND_nWE high duration */
-	unsigned int	tWP;  /* ND_nWE pulse time */
-	unsigned int	tRH;  /* ND_nRE high duration */
-	unsigned int	tRP;  /* ND_nRE pulse width */
-	unsigned int	tR;   /* ND_nWE high to ND_nRE low for read */
-	unsigned int	tWHR; /* ND_nWE high to ND_nRE low for status read */
-	unsigned int	tAR;  /* ND_ALE low to ND_nRE low delay */
-};
-
-struct pxa3xx_nand_cmdset {
-	uint16_t	read1;
-	uint16_t	read2;
-	uint16_t	program;
-	uint16_t	read_status;
-	uint16_t	read_id;
-	uint16_t	erase;
-	uint16_t	reset;
-	uint16_t	lock;
-	uint16_t	unlock;
-	uint16_t	lock_status;
-};
-
-struct pxa3xx_nand_flash {
-	char		*name;
-	uint32_t	chip_id;
-	unsigned int	page_per_block; /* Pages per block (PG_PER_BLK) */
-	unsigned int	page_size;	/* Page size in bytes (PAGE_SZ) */
-	unsigned int	flash_width;	/* Width of Flash memory (DWIDTH_M) */
-	unsigned int	dfc_width;	/* Width of flash controller(DWIDTH_C) */
-	unsigned int	num_blocks;	/* Number of physical blocks in Flash */
-
-	struct pxa3xx_nand_timing *timing;	/* NAND Flash timing */
-};
-
-/*
- * Current pxa3xx_nand controller has two chip select which
- * both be workable.
- *
- * Notice should be taken that:
- * When you want to use this feature, you should not enable the
- * keep configuration feature, for two chip select could be
- * attached with different nand chip. The different page size
- * and timing requirement make the keep configuration impossible.
- */
-
-/* The max num of chip select current support */
-#define NUM_CHIP_SELECT		(2)
-struct pxa3xx_nand_platform_data {
-
-	/* the data flash bus is shared between the Static Memory
-	 * Controller and the Data Flash Controller,  the arbiter
-	 * controls the ownership of the bus
-	 */
-	int	enable_arbiter;
-
-	/* allow platform code to keep OBM/bootloader defined NFC config */
-	int	keep_config;
-
-	/* indicate how many chip selects will be used */
-	int	num_cs;
-
-	const struct mtd_partition		*parts[NUM_CHIP_SELECT];
-	unsigned int				nr_parts[NUM_CHIP_SELECT];
-
-	const struct pxa3xx_nand_flash * 	flash;
-	size_t					num_flash;
-};
-
-extern void pxa3xx_set_nand_info(struct pxa3xx_nand_platform_data *info);
-#endif /* __ASM_ARCH_PXA3XX_NAND_H */
diff --git a/arch/arm/plat-pxa/include/plat/pxa_uart.h b/arch/arm/plat-pxa/include/plat/pxa_uart.h
new file mode 100644
index 0000000..9964fcb
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/pxa_uart.h
@@ -0,0 +1,19 @@
+/*
+ * Header file to define the uart platform info structure
+ *
+ * Copyright (C) 2009 Marvell International Ltd.
+ *     Xiaofan Tian <tianxf@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef PXA_UART_H
+#define PXA_UART_H
+
+struct pxa_uart_mach_info {
+	int stay_awake_in_suspend;
+};
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/reg_rw.h b/arch/arm/plat-pxa/include/plat/reg_rw.h
new file mode 100644
index 0000000..6fb15fe
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/reg_rw.h
@@ -0,0 +1,57 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/plat/reg_rw.h
+ *
+ *  Support for write-only or read-only register access on PXA platforms
+ *
+ *  Copyright (C) 2011 Marvell International Ltd.
+ *  Raymond Wu <xywu@marvell.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#ifndef _PXA_REG_RW_H_
+#define _PXA_REG_RW_H_
+
+/**
+ * pxa_reg_add - add "addr" into register list
+ * @addr: register's kernel virtual address
+ * @mask: mask the bit if it's write-only
+ *
+ * User must call this API before any read/write.
+ */
+int pxa_reg_add(u32 pa, u32 mask);
+
+/**
+ We don't support remove since there isn't a real case.
+ */
+int pxa_reg_remove(u32 pa);
+
+/**
+ * pxa_reg_read - read register value by mask
+ * @pa: register's physical address
+ * @*val: register value pointer to be read into
+ * @mask: Only masked bits are valid.
+ *
+ * User should not suppose other bits are good, though in fact
+ * the R/W and RO bits are correct.
+ * User must call pxa_reg_add before this API.
+ */
+int pxa_reg_read(u32 pa, u32 *val, u32 mask);
+
+/**
+ * pxa_reg_write - write register value by mask
+ * @pa: register's physical address
+ * @val: register value to be written
+ * @mask: Only masked bits will be written.
+ *
+ * User must call pxa_reg_add before this API.
+ */
+int pxa_reg_write(u32 pa, u32 val, u32 mask);
+
+#define PXA_REG_ERR_ALREADY_ADD		1
+#define PXA_REG_ERR_OK				0
+#define PXA_REG_ERR_FAIL			(-1)
+
+#endif
diff --git a/arch/arm/plat-pxa/include/plat/ssp.h b/arch/arm/plat-pxa/include/plat/ssp.h
new file mode 100644
index 0000000..8e4d161
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/ssp.h
@@ -0,0 +1,259 @@
+/*
+ *  ssp.h
+ *
+ *  Copyright (C) 2003 Russell King, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver supports the following PXA CPU/SSP ports:-
+ *
+ *       PXA250     SSP
+ *       PXA255     SSP, NSSP
+ *       PXA26x     SSP, NSSP, ASSP
+ *       PXA27x     SSP1, SSP2, SSP3
+ *       PXA3xx     SSP1, SSP2, SSP3, SSP4
+ *       PXA168     SSP1, SSP2, SSP3, SSP4, SSP5
+ */
+
+#ifndef __ASM_ARCH_SSP_H
+#define __ASM_ARCH_SSP_H
+
+#include <linux/list.h>
+#include <linux/io.h>
+
+/*
+ * SSP Serial Port Registers
+ * PXA250, PXA255, PXA26x and PXA27x SSP controllers are all slightly different.
+ * PXA255, PXA26x and PXA27x have extra ports, registers and bits.
+ */
+
+#define SSCR0		(0x00)	/* SSP Control Register 0 */
+#define SSCR1		(0x04)	/* SSP Control Register 1 */
+#define SSSR		(0x08)	/* SSP Status Register */
+#define SSITR		(0x0C)	/* SSP Interrupt Test Register */
+#define SSDR		(0x10)	/* SSP Data Write/Data Read Register */
+
+#define SSTO		(0x28)	/* SSP Time Out Register */
+#define SSPSP		(0x2C)	/* SSP Programmable Serial Protocol */
+#define SSTSA		(0x30)	/* SSP Tx Timeslot Active */
+#define SSRSA		(0x34)	/* SSP Rx Timeslot Active */
+#define SSTSS		(0x38)	/* SSP Timeslot Status */
+#define SSACD		(0x3C)	/* SSP Audio Clock Divider */
+#define SSACDD		(0x40)	/* SSP Audio Clock Dither Divider */
+
+/* Common PXA2xx bits first */
+#define SSCR0_DSS	(0x0000000f)	/* Data Size Select (mask) */
+#define SSCR0_DataSize(x)  ((x) - 1)	/* Data Size Select [4..16] */
+#define SSCR0_FRF	(0x00000030)	/* FRame Format (mask) */
+/* Motorola's Serial Peripheral Interface (SPI) */
+#define SSCR0_Motorola	(0x0 << 4)
+/* Texas Instruments' Synchronous Serial Protocol (SSP) */
+#define SSCR0_TI	(0x1 << 4)
+#define SSCR0_National	(0x2 << 4)	/* National Microwire */
+#define SSCR0_ECS	(1 << 6)	/* External clock select */
+#define SSCR0_SSE	(1 << 7)	/* Synchronous Serial Port Enable */
+#define SSCR0_SCR(x)	((x) << 8)	/* Serial Clock Rate (mask) */
+
+/* PXA27x, PXA3xx */
+#define SSCR0_EDSS	(1 << 20)	/* Extended data size select */
+#define SSCR0_NCS	(1 << 21)	/* Network clock select */
+/* Receive FIFO overrrun interrupt mask */
+#define SSCR0_RIM	(1 << 22)
+/* Transmit FIFO underrun interrupt mask */
+#define SSCR0_TUM	(1 << 23)
+#define SSCR0_FRDC	(0x07000000)	/* Frame rate divider control (mask) */
+/* Time slots per frame [1..8] */
+#define SSCR0_SlotsPerFrm(x) (((x) - 1) << 24)
+#define SSCR0_FPCKE	(1 << 29)	/* FIFO packing enable */
+#define SSCR0_ACS	(1 << 30)	/* Audio clock select */
+#define SSCR0_MOD	(1 << 31)	/* Mode (normal or network) */
+
+#define SSCR1_RIE	(1 << 0)	/* Receive FIFO Interrupt Enable */
+#define SSCR1_TIE	(1 << 1)	/* Transmit FIFO Interrupt Enable */
+#define SSCR1_LBM	(1 << 2)	/* Loop-Back Mode */
+/* Motorola SPI SSPSCLK polarity setting */
+#define SSCR1_SPO	(1 << 3)
+#define SSCR1_SPH	(1 << 4)	/* Motorola SPI SSPSCLK phase setting */
+#define SSCR1_MWDS	(1 << 5)	/* Microwire Transmit Data Size */
+#define SSCR1_TFT	(0x000003c0)	/* Transmit FIFO Threshold (mask) */
+#define SSCR1_TxTresh(x) (((x) - 1) << 6)	/* level [1..16] */
+#define SSCR1_RFT	(0x00003c00)	/* Receive FIFO Threshold (mask) */
+#define SSCR1_RxTresh(x) (((x) - 1) << 10)	/* level [1..16] */
+
+#define SSSR_TNF	(1 << 2)	/* Transmit FIFO Not Full */
+#define SSSR_RNE	(1 << 3)	/* Receive FIFO Not Empty */
+#define SSSR_BSY	(1 << 4)	/* SSP Busy */
+#define SSSR_TFS	(1 << 5)	/* Transmit FIFO Service Request */
+#define SSSR_RFS	(1 << 6)	/* Receive FIFO Service Request */
+#define SSSR_ROR	(1 << 7)	/* Receive FIFO Overrun */
+
+/* extra bits in PXA255, PXA26x and PXA27x SSP ports */
+#define SSCR0_TISSP		(1 << 4)	/* TI Sync Serial Protocol */
+/* PSP - Programmable Serial Protocol */
+#define SSCR0_PSP		(3 << 4)
+/* TXD Tristate Enable Last Phase */
+#define SSCR1_TTELP		(1 << 31)
+#define SSCR1_TTE		(1 << 30)	/* TXD Tristate Enable */
+/* Enable Bit Count Error interrupt */
+#define SSCR1_EBCEI		(1 << 29)
+#define SSCR1_SCFR		(1 << 28)	/* Slave Clock free Running */
+#define SSCR1_ECRA		(1 << 27)	/* Enable Clock Request A */
+#define SSCR1_ECRB		(1 << 26)	/* Enable Clock request B */
+/* Serial Bit Rate Clock Direction */
+#define SSCR1_SCLKDIR		(1 << 25)
+#define SSCR1_SFRMDIR		(1 << 24)	/* Frame Direction */
+#define SSCR1_RWOT		(1 << 23)	/* Receive Without Transmit */
+#define SSCR1_TRAIL		(1 << 22)	/* Trailing Byte */
+/* Transmit Service Request Enable */
+#define SSCR1_TSRE		(1 << 21)
+/* Receive Service Request Enable */
+#define SSCR1_RSRE		(1 << 20)
+/* Receiver Time-out Interrupt enable */
+#define SSCR1_TINTE		(1 << 19)
+/* Peripheral Trailing Byte Interupt Enable */
+#define SSCR1_PINTE		(1 << 18)
+#define SSCR1_IFS		(1 << 16)	/* Invert Frame Signal */
+#define SSCR1_STRF		(1 << 15)	/* Select FIFO or EFWR */
+#define SSCR1_EFWR		(1 << 14)	/* Enable FIFO Write/Read */
+
+#define SSSR_BCE		(1 << 23)	/* Bit Count Error */
+/* Clock Synchronisation Status */
+#define SSSR_CSS		(1 << 22)
+#define SSSR_TUR		(1 << 21)	/* Transmit FIFO Under Run */
+#define SSSR_EOC		(1 << 20)	/* End Of Chain */
+/* Receiver Time-out Interrupt */
+#define SSSR_TINT		(1 << 19)
+/* Peripheral Trailing Byte Interrupt */
+#define SSSR_PINT		(1 << 18)
+
+#define SSPSP_SCMODE(x)		((x) << 0)	/* Serial Bit Rate Clock Mode */
+#define SSPSP_SFRMP		(1 << 2)	/* Serial Frame Polarity */
+#define SSPSP_ETDS		(1 << 3)	/* End of Transfer data State */
+#define SSPSP_STRTDLY(x)	((x) << 4)	/* Start Delay */
+#define SSPSP_DMYSTRT(x)	((x) << 7)	/* Dummy Start */
+#define SSPSP_SFRMDLY(x)	((x) << 9)	/* Serial Frame Delay */
+#define SSPSP_SFRMWDTH(x)	((x) << 16)	/* Serial Frame Width */
+#define SSPSP_DMYSTOP(x)	((x) << 23)	/* Dummy Stop */
+#define SSPSP_FSRT		(1 << 25)	/* Frame Sync Relative Timing */
+
+/* PXA3xx */
+#define SSPSP_EDMYSTRT(x)	((x) << 26)	/* Extended Dummy Start */
+#define SSPSP_EDMYSTOP(x)	((x) << 28)	/* Extended Dummy Stop */
+#define SSPSP_TIMING_MASK	(0x7f8001f0)
+
+#define SSACD_SCDB		(1 << 3)	/* SSPSYSCLK Divider Bypass */
+#define SSACD_ACPS(x)		((x) << 4)	/* Audio clock PLL select */
+#define SSACD_ACDS(x)		((x) << 0)	/* Audio clock divider select */
+/* SYSCLK division ratio select */
+#define SSACD_SCDX8		(1 << 7)
+
+enum pxa_ssp_type {
+	SSP_UNDEFINED = 0,
+	PXA25x_SSP,		/* pxa 210, 250, 255, 26x */
+	PXA25x_NSSP,		/* pxa 255, 26x (including ASSP) */
+	PXA27x_SSP,
+	PXA168_SSP,
+	CE4100_SSP,
+	PXA910_SSP,
+	PXA988_SSP,
+	MMP_SSP,
+};
+
+struct mmp2_sspa_registers {
+	u32 rx_data;
+	u32 rx_id;
+	u32 rx_ctrl;
+	u32 rx_sp_ctrl;
+	u32 rx_fifo_ul;
+	u32 rx_int_msk;
+	u32 rx_core;
+	u32 rx_fifo_nofs;
+	u32 rx_fifo_size;
+	u32 tx_data;
+	u32 tx_id;
+	u32 tx_ctrl;
+	u32 tx_sp_ctrl;
+	u32 tx_fifo_ll;
+	u32 tx_int_msk;
+	u32 tx_core;
+	u32 tx_fifo_nofs;
+	u32 tx_fifo_size;
+	u32 aud_ctrl0;
+	u32 aud_pll_ctrl0;
+	u32 aud_pll_ctrl1;
+};
+
+#ifdef CONFIG_MMP_ZSP
+/* should be sync up with mmp2_zsp_audio.h */
+typedef struct {
+	u16 fwid;			/* fsync width */
+	u16 fsync_active;
+	u16 msl_select;		/* master/slave mode */
+	u16 fsp;			/* fsync polarity */
+	u16 ch_num;			/* channel number */
+	u16 word_length;
+	u16 sample_size;
+	u16 jst;			/* audio sample justification */
+	u16 data_delay;
+	u16 resv;			/* for 32 bit align */
+	u32 sample_rate;
+	u32 mclk;
+} ssp_config_t;
+#endif
+
+struct ssp_device {
+	struct platform_device *pdev;
+	struct list_head node;
+
+	struct clk *clk;
+	void __iomem *mmio_base;
+	unsigned long phys_base;
+	unsigned long sspa_sp;
+
+	const char *label;
+	int port_id;
+	int type;
+	int use_count;
+	int irq;
+	int drcmr_rx;
+	int drcmr_tx;
+#ifdef CONFIG_MMP_ZSP
+	int render_type[2];
+	ssp_config_t zsp_sspa_conf;
+#endif
+	struct mmp2_sspa_registers mmp2_sspa_saved;
+};
+
+/**
+ * pxa_ssp_write_reg - Write to a SSP register
+ *
+ * @dev: SSP device to access
+ * @reg: Register to write to
+ * @val: Value to be written.
+ */
+static inline void pxa_ssp_write_reg(struct ssp_device *dev, u32 reg, u32 val)
+{
+	__raw_writel(val, dev->mmio_base + reg);
+}
+
+/**
+ * pxa_ssp_read_reg - Read from a SSP register
+ *
+ * @dev: SSP device to access
+ * @reg: Register to read from
+ */
+static inline u32 pxa_ssp_read_reg(struct ssp_device *dev, u32 reg)
+{
+	return __raw_readl(dev->mmio_base + reg);
+}
+
+int pxa_ssp_write_word(struct ssp_device *ssp, u32 data);
+int pxa_ssp_read_word(struct ssp_device *ssp, u32 * data);
+int pxa_ssp_flush(struct ssp_device *ssp);
+void pxa_ssp_enable(struct ssp_device *ssp);
+void pxa_ssp_disable(struct ssp_device *ssp);
+struct ssp_device *pxa_ssp_request(int port, const char *label);
+void pxa_ssp_free(struct ssp_device *);
+#endif /* __ASM_ARCH_SSP_H */
diff --git a/arch/arm/plat-pxa/include/plat/usb.h b/arch/arm/plat-pxa/include/plat/usb.h
new file mode 100644
index 0000000..634aad4
--- /dev/null
+++ b/arch/arm/plat-pxa/include/plat/usb.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __MV_PLATFORM_USB_H
+#define __MV_PLATFORM_USB_H
+
+#include <linux/usb/mv_usb.h>
+
+enum pxa_ehci_type {
+	EHCI_UNDEFINED = 0,
+	PXA_U2OEHCI,  /* pxa 168, 9xx */
+	PXA_SPH, /* pxa 168, 9xx SPH */
+	MMP3_HSIC, /* mmp3 hsic */
+	MMP3_FSIC, /* mmp3 fsic */
+};
+
+enum usb_port_speed {
+	USB_PORT_SPEED_FULL = 0,	/* full speed: 0x0 */
+	USB_PORT_SPEED_LOW,		/* low speed: 0x1 */
+	USB_PORT_SPEED_HIGH,		/* high speed: 0x2 */
+	USB_PORT_SPEED_UNKNOWN,		/* unknown speed: 0x3 */
+};
+
+
+enum {
+	MV_USB_MODE_DEVICE = 0,
+	MV_USB_MODE_OTG,
+	MV_USB_MODE_HOST,
+};
+
+enum {
+	VBUS_LOW	= 0,
+	VBUS_HIGH	= 1 << 0,
+};
+
+enum charger_type {
+	NULL_CHARGER            = 0,
+	DEFAULT_CHARGER,
+	VBUS_CHARGER,
+	AC_CHARGER_STANDARD,
+	AC_CHARGER_OTHER,
+};
+
+extern int mv_udc_register_client(struct notifier_block *nb);
+extern int mv_udc_unregister_client(struct notifier_block *nb);
+
+struct mv_usb_addon_irq {
+	unsigned int	irq;
+	int		(*poll)(void);
+	void		(*init)(void);
+};
+
+struct mv_usb_platform_data {
+	unsigned int		clknum;
+	char			**clkname;
+	struct mv_usb_addon_irq	*id;	/* Only valid for OTG. ID pin change*/
+	struct mv_usb_addon_irq	*vbus;	/* valid for OTG/UDC. VBUS change*/
+	/* only valid for HCD. OTG or Host only*/
+	unsigned int		mode;
+
+	/* This flag is used for that needs id pin checked by otg */
+	unsigned int	disable_otg_clock_gating:1;
+	/* Force a_bus_req to be asserted */
+	unsigned int	otg_force_a_bus_req:1;
+
+	int     (*phy_init)(unsigned int regbase);
+	int     (*p_init)(unsigned int regbase);
+	void    (*phy_deinit)(unsigned int regbase);
+	int	(*set_vbus)(unsigned int vbus);
+	int	(*private_init)(struct mv_op_regs *opregs,
+					unsigned int phyregs);
+};
+
+extern int pxa_usb_phy_init(unsigned int base);
+extern void pxa_usb_phy_deinit(unsigned int base);
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_HSIC
+extern int mmp3_hsic_phy_init(unsigned int base);
+extern void mmp3_hsic_phy_deinit(unsigned int base);
+extern int mmp3_hsic_private_init(struct mv_op_regs *opregs,
+					unsigned int phyregs);
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_FSIC
+extern int mmp3_fsic_phy_init(unsigned int base);
+extern int mmp3_fsic_p_init(unsigned int base);
+#endif
+#endif
diff --git a/arch/arm/plat-pxa/mfp.c b/arch/arm/plat-pxa/mfp.c
index 2c4dbb1..aa41e84 100644
--- a/arch/arm/plat-pxa/mfp.c
+++ b/arch/arm/plat-pxa/mfp.c
@@ -18,71 +18,13 @@
 #include <linux/init.h>
 #include <linux/io.h>
 
-#include <plat/mfp.h>
-
-#define MFPR_SIZE	(PAGE_SIZE)
-
-/* MFPR register bit definitions */
-#define MFPR_PULL_SEL		(0x1 << 15)
-#define MFPR_PULLUP_EN		(0x1 << 14)
-#define MFPR_PULLDOWN_EN	(0x1 << 13)
-#define MFPR_SLEEP_SEL		(0x1 << 9)
-#define MFPR_SLEEP_OE_N		(0x1 << 7)
-#define MFPR_EDGE_CLEAR		(0x1 << 6)
-#define MFPR_EDGE_FALL_EN	(0x1 << 5)
-#define MFPR_EDGE_RISE_EN	(0x1 << 4)
-
-#define MFPR_SLEEP_DATA(x)	((x) << 8)
-#define MFPR_DRIVE(x)		(((x) & 0x7) << 10)
-#define MFPR_AF_SEL(x)		(((x) & 0x7) << 0)
-
-#define MFPR_EDGE_NONE		(0)
-#define MFPR_EDGE_RISE		(MFPR_EDGE_RISE_EN)
-#define MFPR_EDGE_FALL		(MFPR_EDGE_FALL_EN)
-#define MFPR_EDGE_BOTH		(MFPR_EDGE_RISE | MFPR_EDGE_FALL)
-
-/*
- * Table that determines the low power modes outputs, with actual settings
- * used in parentheses for don't-care values. Except for the float output,
- * the configured driven and pulled levels match, so if there is a need for
- * non-LPM pulled output, the same configuration could probably be used.
- *
- * Output value  sleep_oe_n  sleep_data  pullup_en  pulldown_en  pull_sel
- *                 (bit 7)    (bit 8)    (bit 14)     (bit 13)   (bit 15)
- *
- * Input            0          X(0)        X(0)        X(0)       0
- * Drive 0          0          0           0           X(1)       0
- * Drive 1          0          1           X(1)        0	  0
- * Pull hi (1)      1          X(1)        1           0	  0
- * Pull lo (0)      1          X(0)        0           1	  0
- * Z (float)        1          X(0)        0           0	  0
- */
-#define MFPR_LPM_INPUT		(0)
-#define MFPR_LPM_DRIVE_LOW	(MFPR_SLEEP_DATA(0) | MFPR_PULLDOWN_EN)
-#define MFPR_LPM_DRIVE_HIGH    	(MFPR_SLEEP_DATA(1) | MFPR_PULLUP_EN)
-#define MFPR_LPM_PULL_LOW      	(MFPR_LPM_DRIVE_LOW  | MFPR_SLEEP_OE_N)
-#define MFPR_LPM_PULL_HIGH     	(MFPR_LPM_DRIVE_HIGH | MFPR_SLEEP_OE_N)
-#define MFPR_LPM_FLOAT         	(MFPR_SLEEP_OE_N)
-#define MFPR_LPM_MASK		(0xe080)
+#ifdef CONFIG_ARCH_MMP
+#include <mach/cputype.h>
+#elif defined(CONFIG_ARCH_PXA)
+#include <mach/hardware.h>
+#endif
 
-/*
- * The pullup and pulldown state of the MFP pin at run mode is by default
- * determined by the selected alternate function. In case that some buggy
- * devices need to override this default behavior,  the definitions below
- * indicates the setting of corresponding MFPR bits
- *
- * Definition       pull_sel  pullup_en  pulldown_en
- * MFPR_PULL_NONE       0         0        0
- * MFPR_PULL_LOW        1         0        1
- * MFPR_PULL_HIGH       1         1        0
- * MFPR_PULL_BOTH       1         1        1
- * MFPR_PULL_FLOAT	1         0        0
- */
-#define MFPR_PULL_NONE		(0)
-#define MFPR_PULL_LOW		(MFPR_PULL_SEL | MFPR_PULLDOWN_EN)
-#define MFPR_PULL_BOTH		(MFPR_PULL_LOW | MFPR_PULLUP_EN)
-#define MFPR_PULL_HIGH		(MFPR_PULL_SEL | MFPR_PULLUP_EN)
-#define MFPR_PULL_FLOAT		(MFPR_PULL_SEL)
+#include <plat/mfp.h>
 
 /* mfp_spin_lock is used to ensure that MFP register configuration
  * (most likely a read-modify-write operation) is atomic, and that
@@ -103,13 +45,12 @@ static struct mfp_pin mfp_table[MFP_PIN_MAX];
 
 /* mapping of MFP_LPM_* definitions to MFPR_LPM_* register bits */
 static const unsigned long mfpr_lpm[] = {
-	MFPR_LPM_INPUT,
+	MFPR_LPM_NONE,
 	MFPR_LPM_DRIVE_LOW,
 	MFPR_LPM_DRIVE_HIGH,
 	MFPR_LPM_PULL_LOW,
 	MFPR_LPM_PULL_HIGH,
 	MFPR_LPM_FLOAT,
-	MFPR_LPM_INPUT,
 };
 
 /* mapping of MFP_PULL_* definitions to MFPR_PULL_* register bits */
@@ -164,8 +105,17 @@ static inline void __mfp_config_lpm(struct mfp_pin *p)
 void mfp_config(unsigned long *mfp_cfgs, int num)
 {
 	unsigned long flags;
-	int i;
-
+	int i, drv_b11 = 0, no_lpm = 0;
+
+#ifdef CONFIG_ARCH_MMP
+	if (cpu_is_pxa910_family() || cpu_is_pxa920_family() || cpu_is_mmp2() || cpu_is_mmp3())
+		drv_b11 = 1;
+	if (cpu_is_pxa168() || cpu_is_pxa910_family() || cpu_is_pxa920_family())
+		no_lpm = 1;
+#elif defined(CONFIG_ARCH_PXA)
+	if (cpu_is_pxa95x())
+		drv_b11 = 1;
+#endif
 	spin_lock_irqsave(&mfp_spin_lock, flags);
 
 	for (i = 0; i < num; i++, mfp_cfgs++) {
@@ -182,20 +132,14 @@ void mfp_config(unsigned long *mfp_cfgs, int num)
 		lpm = MFP_LPM_STATE(c);
 		edge = MFP_LPM_EDGE(c);
 		pull = MFP_PULL(c);
+		if (drv_b11)
+			drv = drv << 1;
+		if (no_lpm)
+			lpm = 0;
 
-		/* run-mode pull settings will conflict with MFPR bits of
-		 * low power mode state,  calculate mfpr_run and mfpr_lpm
-		 * individually if pull != MFP_PULL_NONE
-		 */
 		tmp = MFPR_AF_SEL(af) | MFPR_DRIVE(drv);
-
-		if (likely(pull == MFP_PULL_NONE)) {
-			p->mfpr_run = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
-			p->mfpr_lpm = p->mfpr_run;
-		} else {
-			p->mfpr_lpm = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
-			p->mfpr_run = tmp | mfpr_pull[pull];
-		}
+		p->mfpr_run = tmp | mfpr_pull[pull] | mfpr_lpm[lpm] | mfpr_edge[edge];
+		p->mfpr_lpm = p->mfpr_run;
 
 		p->config = c; __mfp_config_run(p);
 	}
@@ -229,7 +173,7 @@ void mfp_write(int mfp, unsigned long val)
 	spin_unlock_irqrestore(&mfp_spin_lock, flags);
 }
 
-void __init mfp_init_base(void __iomem *mfpr_base)
+void __init mfp_init_base(unsigned long mfpr_base)
 {
 	int i;
 
@@ -237,7 +181,7 @@ void __init mfp_init_base(void __iomem *mfpr_base)
 	for (i = 0; i < ARRAY_SIZE(mfp_table); i++)
 		mfp_table[i].config = -1;
 
-	mfpr_mmio_base = mfpr_base;
+	mfpr_mmio_base = (void __iomem *)mfpr_base;
 }
 
 void __init mfp_init_addr(struct mfp_addr_map *map)
@@ -271,6 +215,10 @@ void mfp_config_lpm(void)
 	struct mfp_pin *p = &mfp_table[0];
 	int pin;
 
+#ifdef CONFIG_ARCH_MMP
+	if (cpu_is_pxa168() || cpu_is_pxa910_family() || cpu_is_pxa920_family())
+		return;
+#endif
 	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)
 		__mfp_config_lpm(p);
 }
@@ -283,3 +231,30 @@ void mfp_config_run(void)
 	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++, p++)
 		__mfp_config_run(p);
 }
+void lpm_mfpr_edge_config(int mfp, unsigned long val)
+{
+	mfp_cfg_t m;
+	m = mfp_read(mfp);
+	m &= ~(MFPR_EDGE_CLEAR | MFPR_EDGE_FALL_EN
+						 | MFPR_EDGE_RISE_EN);
+	m |= mfpr_edge[MFP_LPM_EDGE(val)];
+	mfp_write(mfp, m);
+}
+void lpm_mfpr_edge_detect_config(int mfp, unsigned long val)
+{
+	mfp_cfg_t m;
+	m = mfp_read(mfp);
+	m &= ~(MFPR_EDGE_CLEAR | MFPR_SLEEP_OE_N | MFPR_EDGE_FALL_EN
+				| MFPR_SLEEP_SEL | MFPR_EDGE_RISE_EN);
+	m |= val;
+	mfp_write(mfp, m);
+}
+void lpm_mfpr_edge_detect_clear_config(int mfp)
+{
+	mfp_cfg_t m;
+	m = mfp_read(mfp);
+	m &= ~(MFPR_SLEEP_SEL | MFPR_SLEEP_OE_N | MFPR_EDGE_CLEAR
+			| MFPR_EDGE_FALL_EN | MFPR_EDGE_RISE_EN);
+	m |= MFPR_EDGE_CLEAR;
+	mfp_write(mfp, m);
+}
diff --git a/arch/arm/plat-pxa/pmem.c b/arch/arm/plat-pxa/pmem.c
new file mode 100644
index 0000000..ec5fb20
--- /dev/null
+++ b/arch/arm/plat-pxa/pmem.c
@@ -0,0 +1,127 @@
+/*
+ *  arch/arm/plat-pxa/pmem.c
+ *
+ *  Buffer Management Module
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+
+ *(C) Copyright 2009 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/android_pmem.h>
+#include <linux/memblock.h>
+
+#ifdef CONFIG_ANDROID_PMEM
+#include <plat/pmem.h>
+
+/*default reserve size:16MB*/
+static size_t __initdata pmem_reserve_size = 0x1000000;
+static unsigned long __initdata pmem_reserve_pa;
+
+static int __init pxa_reserve_early_init(char *arg)
+{
+	pmem_reserve_size = memparse(arg, &arg);
+#ifdef CONFIG_PXA910_1G_DDR_WORKAROUND
+	pmem_reserve_pa = 0x09000000;
+#endif
+	if (*arg == '@')
+		pmem_reserve_pa = memparse(arg + 1, &arg);
+	return 0;
+}
+early_param("reserve_pmem", pxa_reserve_early_init);
+
+static void __init  __pxa_add_pmem(char *name, size_t size, int no_allocator,
+				int cached, int buffered)
+{
+	struct platform_device *android_pmem_device;
+	struct android_pmem_platform_data *android_pmem_pdata;
+	static int id;
+
+	if (size > PAGE_SIZE && size > pmem_reserve_size)
+		return;
+
+	if (pmem_reserve_pa == 0)
+		return;
+
+	android_pmem_device = kzalloc(sizeof(struct platform_device),
+					GFP_KERNEL);
+	if (android_pmem_device == NULL)
+		return ;
+
+	android_pmem_pdata = kzalloc(sizeof(struct android_pmem_platform_data),
+					GFP_KERNEL);
+	if (android_pmem_pdata == NULL) {
+		kfree(android_pmem_device);
+		return ;
+	}
+
+	printk(KERN_INFO "pmem register %s reserve pa(0x%lx), request size=0x%x\n",
+		name, pmem_reserve_pa, size);
+
+	if (size > PAGE_SIZE) {
+		android_pmem_pdata->start = pmem_reserve_pa;
+		android_pmem_pdata->size = size;
+		pmem_reserve_pa += size;
+		pmem_reserve_size -= size;
+	} else {
+		android_pmem_pdata->start = size;
+		android_pmem_pdata->size = 0;
+	}
+
+	android_pmem_pdata->name = name;
+	android_pmem_pdata->no_allocator = no_allocator;
+	android_pmem_pdata->cached = cached;
+	android_pmem_pdata->buffered = buffered;
+
+	android_pmem_device->name = "android_pmem";
+	android_pmem_device->id = id++;
+	android_pmem_device->dev.platform_data = android_pmem_pdata;
+
+	platform_device_register(android_pmem_device);
+}
+
+void __init pxa_reserve_pmem_memblock(void)
+{
+	if (pmem_reserve_pa)
+		memblock_reserve(pmem_reserve_pa, pmem_reserve_size);
+	else {
+		pmem_reserve_pa = memblock_alloc(pmem_reserve_size, PAGE_SIZE);
+		if (!pmem_reserve_pa) {
+			pr_err("%s: failed to reserve %x bytes\n",
+					__func__, pmem_reserve_size);
+			return;
+		}
+	}
+	/* FIXME:
+	 * - memblock_free: remove the allocated buffer from the reserved
+	 *   region, Which means it will be not reserved.
+	 * - memblock_remove: remove the allocated buffer from the memory
+	 *   available to kernel, and the pages will not be mapped.
+	 *
+	 * ARM DMA APIs requires the DMA buffer pages to be mapped in kernel,
+	 * or it will do cache flush on the invalid virtual address.
+	 */
+#if 0
+	memblock_free(pmem_reserve_pa, pmem_reserve_size);
+	memblock_remove(pmem_reserve_pa, pmem_reserve_size);
+#endif
+}
+
+void __init pxa_add_pmem(void)
+{
+	__pxa_add_pmem("pmem", pmem_reserve_size, 0, 1, 1);
+	__pxa_add_pmem("pmem_adsp", 0, 0, 0, 0);
+	__pxa_add_pmem("pmem_wc", 0, 0, 0, 1);
+}
+
+#endif
diff --git a/arch/arm/plat-pxa/pwm.c b/arch/arm/plat-pxa/pwm.c
index ef32686..cc6c9c0 100644
--- a/arch/arm/plat-pxa/pwm.c
+++ b/arch/arm/plat-pxa/pwm.c
@@ -31,6 +31,8 @@ static const struct platform_device_id pwm_id_table[] = {
 	{ "pxa27x-pwm", 0 | HAS_SECONDARY_PWM },
 	{ "pxa168-pwm", 1 },
 	{ "pxa910-pwm", 1 },
+	{ "mmp2-pwm"  , 0 },
+	{ "pxa95x-pwm", 0 },
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, pwm_id_table);
@@ -91,7 +93,7 @@ int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)
 	 * before writing to the registers
 	 */
 	clk_enable(pwm->clk);
-	__raw_writel(prescale, pwm->mmio_base + PWMCR);
+	__raw_writel(prescale | PWMCR_SD, pwm->mmio_base + PWMCR);
 	__raw_writel(dc, pwm->mmio_base + PWMDCR);
 	__raw_writel(pv, pwm->mmio_base + PWMPCR);
 	clk_disable(pwm->clk);
diff --git a/arch/arm/plat-pxa/reg_rw.c b/arch/arm/plat-pxa/reg_rw.c
new file mode 100644
index 0000000..18e94f1
--- /dev/null
+++ b/arch/arm/plat-pxa/reg_rw.c
@@ -0,0 +1,158 @@
+/*
+ *  linux/arch/arm/plat-pxa/include/plat/reg_rw.h
+ *
+ *  Support for write-only register access on PXA platforms
+ *
+ *  Copyright (C) 2011 Marvell International Ltd.
+ *  Raymond Wu <xywu@marvell.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <mach/hardware.h>
+
+#include <plat/reg_rw.h>
+
+
+static LIST_HEAD(reg_list); /* registers list */
+typedef struct cache_reg{
+	struct list_head list;
+	/* physical address of the register */
+	u32 pa;
+	/* kernel mapped address of the register */
+	u32 kva;
+	/* If it's an write only register, set the corresponding bit as 1 */
+	u32 wo_mask;
+	/* If it has been written, set the corresponding bit as 0 */
+	u32 written;
+	/* register value cache for write-only register */
+	u32 val;
+} cache_reg_t;
+
+static spinlock_t reg_lock;
+
+int pxa_reg_add(u32 pa, u32 mask)
+{
+	cache_reg_t *r;
+	unsigned long flags;
+
+	spin_lock_irqsave(&reg_lock, flags);
+	list_for_each_entry(r, &reg_list, list) {
+		if (r->pa == pa) {
+			spin_unlock_irqrestore(&reg_lock, flags);
+			return PXA_REG_ERR_ALREADY_ADD;
+		}
+	}
+
+	r = (cache_reg_t *) kzalloc(sizeof(cache_reg_t), GFP_KERNEL);
+	if (r == NULL) {
+		printk(KERN_ERR"%s OOM \n", __FUNCTION__);
+		spin_unlock_irqrestore(&reg_lock, flags);
+		return PXA_REG_ERR_FAIL;
+	}
+
+	r->pa = pa;
+	r->wo_mask = mask;
+	r->written = 0xffffffff & r->wo_mask;
+	r->kva = (u32) ioremap(pa,sizeof(u32));
+	r->val = readl(r->kva);
+
+	list_add(&r->list, &reg_list);
+	spin_unlock_irqrestore(&reg_lock, flags);
+	return PXA_REG_ERR_OK;
+}
+
+int pxa_reg_remove(u32 addr)
+{
+	return PXA_REG_ERR_OK;
+}
+
+inline int pxa_reg_read(u32 pa, u32 *val, u32 mask)
+{
+	cache_reg_t *r;
+	u32 t;
+	unsigned long flags;
+
+	spin_lock_irqsave(&reg_lock, flags);
+
+	list_for_each_entry(r, &reg_list, list) {
+		if (r->pa == pa)
+			break;
+		if (list_is_last(&r->list, &reg_list)) {
+			spin_unlock_irqrestore(&reg_lock, flags);
+			printk(KERN_ERR"%s cannot find pa=0x%x in list\n",
+				   __FUNCTION__, pa);
+			return PXA_REG_ERR_FAIL;
+		}
+	}
+
+	if (r->written & r->wo_mask & mask) {
+		printk(KERN_WARNING"%s some bit cannot be read: "\
+			   "pa(0x%x) written(0x%x) wo_mask(0x%x) mask(0x%x)\n",\
+			   __FUNCTION__, r->pa, r->written, r->wo_mask, mask);
+		spin_unlock_irqrestore(&reg_lock, flags);
+		return PXA_REG_ERR_FAIL;
+	}
+
+	t = readl(r->kva);
+	*val = (t & ~(r->wo_mask)) | (r->val & r->wo_mask);
+	spin_unlock_irqrestore(&reg_lock, flags);
+	return PXA_REG_ERR_OK;
+}
+
+inline int pxa_reg_write(u32 pa, u32 val, u32 mask)
+{
+	cache_reg_t *r;
+	u32 t;
+	unsigned long flags;
+
+	spin_lock_irqsave(&reg_lock, flags);
+
+	list_for_each_entry(r, &reg_list, list) {
+		if (r->pa == pa)
+			break;
+		if (list_is_last(&r->list, &reg_list)) {
+			spin_unlock_irqrestore(&reg_lock, flags);
+			printk(KERN_ERR"%s cannot find pa=0x%x in list\n",
+				   __FUNCTION__, pa);
+			return PXA_REG_ERR_FAIL;
+		}
+	}
+
+	t = readl(r->kva);
+	t = (t & (~(r->wo_mask))) | (r->val & r->wo_mask);
+	t = (t & (~mask)) | (val & mask);
+	writel(t, r->kva);
+	r->val = t;
+	r->written &= ~mask;
+
+	spin_unlock_irqrestore(&reg_lock, flags);
+	return PXA_REG_ERR_OK;
+}
+
+static int __init reg_pxa_init(void)
+{
+	spin_lock_init(&reg_lock);
+	return 0;
+}
+
+static void __exit reg_pxa_exit(void)
+{
+	return;
+}
+
+module_init(reg_pxa_init);
+module_exit(reg_pxa_exit);
+
+EXPORT_SYMBOL(pxa_reg_write);
+EXPORT_SYMBOL(pxa_reg_read);
+MODULE_DESCRIPTION("Library for write-only registers access");
+MODULE_AUTHOR("Raymond Wu <xywu@marvell.com>");
+MODULE_LICENSE("GPL v2");
-- 
1.7.5.4

