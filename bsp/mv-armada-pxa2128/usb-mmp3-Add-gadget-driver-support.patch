From 925d453ca9e584063f0c4f8f35ea6ae5eb961577 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 11 Sep 2013 12:46:21 +0800
Subject: [PATCH 57/60] usb: mmp3: Add gadget driver support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch updates the usb host driver to cater for our
new kernel 3.4.x.

Singed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/gadget/mv_udc.h      |  220 +++----------
 drivers/usb/gadget/mv_udc_core.c |  649 ++++++++++++++++++++++++++++++--------
 2 files changed, 571 insertions(+), 298 deletions(-)

diff --git a/drivers/usb/gadget/mv_udc.h b/drivers/usb/gadget/mv_udc.h
index e2be951..b15ba2d 100644
--- a/drivers/usb/gadget/mv_udc.h
+++ b/drivers/usb/gadget/mv_udc.h
@@ -10,8 +10,6 @@
 #ifndef __MV_UDC_H
 #define __MV_UDC_H
 
-#define VUSBHS_MAX_PORTS	8
-
 #define DQH_ALIGNMENT		2048
 #define DTD_ALIGNMENT		64
 #define DMA_BOUNDARY		4096
@@ -29,185 +27,47 @@
 #define WAIT_FOR_OUT_STATUS	3
 #define DATA_STATE_RECV		4
 
-#define CAPLENGTH_MASK		(0xff)
-#define DCCPARAMS_DEN_MASK	(0x1f)
-
-#define HCSPARAMS_PPC		(0x10)
-
-/* Frame Index Register Bit Masks */
-#define USB_FRINDEX_MASKS	0x3fff
-
-/* Command Register Bit Masks */
-#define USBCMD_RUN_STOP				(0x00000001)
-#define USBCMD_CTRL_RESET			(0x00000002)
-#define USBCMD_SETUP_TRIPWIRE_SET		(0x00002000)
-#define USBCMD_SETUP_TRIPWIRE_CLEAR		(~USBCMD_SETUP_TRIPWIRE_SET)
-
-#define USBCMD_ATDTW_TRIPWIRE_SET		(0x00004000)
-#define USBCMD_ATDTW_TRIPWIRE_CLEAR		(~USBCMD_ATDTW_TRIPWIRE_SET)
-
-/* bit 15,3,2 are for frame list size */
-#define USBCMD_FRAME_SIZE_1024			(0x00000000) /* 000 */
-#define USBCMD_FRAME_SIZE_512			(0x00000004) /* 001 */
-#define USBCMD_FRAME_SIZE_256			(0x00000008) /* 010 */
-#define USBCMD_FRAME_SIZE_128			(0x0000000C) /* 011 */
-#define USBCMD_FRAME_SIZE_64			(0x00008000) /* 100 */
-#define USBCMD_FRAME_SIZE_32			(0x00008004) /* 101 */
-#define USBCMD_FRAME_SIZE_16			(0x00008008) /* 110 */
-#define USBCMD_FRAME_SIZE_8			(0x0000800C) /* 111 */
-
-#define EPCTRL_TX_ALL_MASK			(0xFFFF0000)
-#define EPCTRL_RX_ALL_MASK			(0x0000FFFF)
-
-#define EPCTRL_TX_DATA_TOGGLE_RST		(0x00400000)
-#define EPCTRL_TX_EP_STALL			(0x00010000)
-#define EPCTRL_RX_EP_STALL			(0x00000001)
-#define EPCTRL_RX_DATA_TOGGLE_RST		(0x00000040)
-#define EPCTRL_RX_ENABLE			(0x00000080)
-#define EPCTRL_TX_ENABLE			(0x00800000)
-#define EPCTRL_CONTROL				(0x00000000)
-#define EPCTRL_ISOCHRONOUS			(0x00040000)
-#define EPCTRL_BULK				(0x00080000)
-#define EPCTRL_INT				(0x000C0000)
-#define EPCTRL_TX_TYPE				(0x000C0000)
-#define EPCTRL_RX_TYPE				(0x0000000C)
-#define EPCTRL_DATA_TOGGLE_INHIBIT		(0x00000020)
-#define EPCTRL_TX_EP_TYPE_SHIFT			(18)
-#define EPCTRL_RX_EP_TYPE_SHIFT			(2)
-
-#define EPCOMPLETE_MAX_ENDPOINTS		(16)
-
-/* endpoint list address bit masks */
-#define USB_EP_LIST_ADDRESS_MASK              0xfffff800
-
-#define PORTSCX_W1C_BITS			0x2a
-#define PORTSCX_PORT_RESET			0x00000100
-#define PORTSCX_PORT_POWER			0x00001000
-#define PORTSCX_FORCE_FULL_SPEED_CONNECT	0x01000000
-#define PORTSCX_PAR_XCVR_SELECT			0xC0000000
-#define PORTSCX_PORT_FORCE_RESUME		0x00000040
-#define PORTSCX_PORT_SUSPEND			0x00000080
-#define PORTSCX_PORT_SPEED_FULL			0x00000000
-#define PORTSCX_PORT_SPEED_LOW			0x04000000
-#define PORTSCX_PORT_SPEED_HIGH			0x08000000
-#define PORTSCX_PORT_SPEED_MASK			0x0C000000
-
-/* USB MODE Register Bit Masks */
-#define USBMODE_CTRL_MODE_IDLE			0x00000000
-#define USBMODE_CTRL_MODE_DEVICE		0x00000002
-#define USBMODE_CTRL_MODE_HOST			0x00000003
-#define USBMODE_CTRL_MODE_RSV			0x00000001
-#define USBMODE_SETUP_LOCK_OFF			0x00000008
-#define USBMODE_STREAM_DISABLE			0x00000010
-
-/* USB STS Register Bit Masks */
-#define USBSTS_INT			0x00000001
-#define USBSTS_ERR			0x00000002
-#define USBSTS_PORT_CHANGE		0x00000004
-#define USBSTS_FRM_LST_ROLL		0x00000008
-#define USBSTS_SYS_ERR			0x00000010
-#define USBSTS_IAA			0x00000020
-#define USBSTS_RESET			0x00000040
-#define USBSTS_SOF			0x00000080
-#define USBSTS_SUSPEND			0x00000100
-#define USBSTS_HC_HALTED		0x00001000
-#define USBSTS_RCL			0x00002000
-#define USBSTS_PERIODIC_SCHEDULE	0x00004000
-#define USBSTS_ASYNC_SCHEDULE		0x00008000
-
-
-/* Interrupt Enable Register Bit Masks */
-#define USBINTR_INT_EN                          (0x00000001)
-#define USBINTR_ERR_INT_EN                      (0x00000002)
-#define USBINTR_PORT_CHANGE_DETECT_EN           (0x00000004)
-
-#define USBINTR_ASYNC_ADV_AAE                   (0x00000020)
-#define USBINTR_ASYNC_ADV_AAE_ENABLE            (0x00000020)
-#define USBINTR_ASYNC_ADV_AAE_DISABLE           (0xFFFFFFDF)
-
-#define USBINTR_RESET_EN                        (0x00000040)
-#define USBINTR_SOF_UFRAME_EN                   (0x00000080)
-#define USBINTR_DEVICE_SUSPEND                  (0x00000100)
-
-#define USB_DEVICE_ADDRESS_MASK			(0xfe000000)
-#define USB_DEVICE_ADDRESS_BIT_SHIFT		(25)
-
-struct mv_cap_regs {
-	u32	caplength_hciversion;
-	u32	hcsparams;	/* HC structural parameters */
-	u32	hccparams;	/* HC Capability Parameters*/
-	u32	reserved[5];
-	u32	dciversion;	/* DC version number and reserved 16 bits */
-	u32	dccparams;	/* DC Capability Parameters */
-};
-
-struct mv_op_regs {
-	u32	usbcmd;		/* Command register */
-	u32	usbsts;		/* Status register */
-	u32	usbintr;	/* Interrupt enable */
-	u32	frindex;	/* Frame index */
-	u32	reserved1[1];
-	u32	deviceaddr;	/* Device Address */
-	u32	eplistaddr;	/* Endpoint List Address */
-	u32	ttctrl;		/* HOST TT status and control */
-	u32	burstsize;	/* Programmable Burst Size */
-	u32	txfilltuning;	/* Host Transmit Pre-Buffer Packet Tuning */
-	u32	reserved[4];
-	u32	epnak;		/* Endpoint NAK */
-	u32	epnaken;	/* Endpoint NAK Enable */
-	u32	configflag;	/* Configured Flag register */
-	u32	portsc[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
-	u32	otgsc;
-	u32	usbmode;	/* USB Host/Device mode */
-	u32	epsetupstat;	/* Endpoint Setup Status */
-	u32	epprime;	/* Endpoint Initialize */
-	u32	epflush;	/* Endpoint De-initialize */
-	u32	epstatus;	/* Endpoint Status */
-	u32	epcomplete;	/* Endpoint Interrupt On Complete */
-	u32	epctrlx[16];	/* Endpoint Control, where x = 0.. 15 */
-	u32	mcr;		/* Mux Control */
-	u32	isr;		/* Interrupt Status */
-	u32	ier;		/* Interrupt Enable */
-};
-
 struct mv_udc {
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	spinlock_t			lock;
-	struct completion		*done;
+	struct completion		*done;	/* make sure release is done */
 	struct platform_device		*dev;
 	int				irq;
 
 	struct mv_cap_regs __iomem	*cap_regs;
 	struct mv_op_regs __iomem	*op_regs;
-	void __iomem                    *phy_regs;
+	unsigned int			phy_regs;
 	unsigned int			max_eps;
 	struct mv_dqh			*ep_dqh;
 	size_t				ep_dqh_size;
-	dma_addr_t			ep_dqh_dma;
+	dma_addr_t			ep_dqh_dma;	/* dma address of QH */
 
-	struct dma_pool			*dtd_pool;
+	struct dma_pool			*dtd_pool;	/* dma pool for DTD */
 	struct mv_ep			*eps;
 
 	struct mv_dtd			*dtd_head;
 	struct mv_dtd			*dtd_tail;
 	unsigned int			dtd_entries;
 
-	struct mv_req			*status_req;
+	struct mv_req			*status_req;	/* ep0 status request */
 	struct usb_ctrlrequest		local_setup_buff;
 
 	unsigned int		resume_state;	/* USB state to resume */
 	unsigned int		usb_state;	/* USB current state */
 	unsigned int		ep0_state;	/* Endpoint zero state */
-	unsigned int		ep0_dir;
+	unsigned int		ep0_dir;	/* Endpoint zero direction:
+						USB_DIR_IN or USB_DIR_OUT */
+
+	unsigned int		dev_addr;	/* Device USB address */
 
-	unsigned int		dev_addr;
-	unsigned int		test_mode;
+	unsigned int		test_mode;	/* the selected test mode */
 
 	int			errors;
 	unsigned		softconnect:1,
 				vbus_active:1,
 				remote_wakeup:1,
+				selfpowered:1,
 				softconnected:1,
 				force_fs:1,
 				clock_gating:1,
@@ -215,15 +75,22 @@ struct mv_udc {
 				stopped:1;      /* stop bit is setted */
 
 	struct work_struct	vbus_work;
-	struct workqueue_struct *qwork;
+	struct workqueue_struct	*qwork;
 
-	struct usb_phy		*transceiver;
+	unsigned int		power;
+	unsigned long		charger_type;
+	struct delayed_work	charger_work;
+	struct delayed_work	delayed_charger_work;
 
-	struct mv_usb_platform_data     *pdata;
+	struct work_struct event_work;
+
+	struct usb_phy          *transceiver;
+
+	struct mv_usb_platform_data	*pdata;
 
 	/* some SOC has mutiple clock sources for USB*/
-	unsigned int    clknum;
-	struct clk      *clk[0];
+	unsigned int	clknum;
+	struct clk	*clk[0];
 };
 
 /* endpoint data structure */
@@ -247,7 +114,7 @@ struct mv_req {
 	struct mv_dtd		*dtd, *head, *tail;
 	struct mv_ep		*ep;
 	struct list_head	queue;
-	unsigned int            test_mode;
+	unsigned int		test_mode;	/* the selected test mode */
 	unsigned		dtd_count;
 	unsigned		mapped:1;
 };
@@ -268,17 +135,18 @@ struct mv_req {
 #define EP_MAX_LENGTH_TRANSFER			0x4000
 
 struct mv_dqh {
-	/* Bits 16..26 Bit 15 is Interrupt On Setup */
+	/* Mult(31-30) , Zlt(29) , Max Pkt len(26-16)  and IOS(15) */
 	u32	max_packet_length;
 	u32	curr_dtd_ptr;		/* Current dTD Pointer */
 	u32	next_dtd_ptr;		/* Next dTD Pointer */
-	/* Total bytes (16..30), IOC (15), INT (8), STS (0-7) */
+
+	/* Total bytes (30-16), IOC (15),  MultO(11-10), STS (7-0)  */
 	u32	size_ioc_int_sts;
-	u32	buff_ptr0;		/* Buffer pointer Page 0 (12-31) */
-	u32	buff_ptr1;		/* Buffer pointer Page 1 (12-31) */
-	u32	buff_ptr2;		/* Buffer pointer Page 2 (12-31) */
-	u32	buff_ptr3;		/* Buffer pointer Page 3 (12-31) */
-	u32	buff_ptr4;		/* Buffer pointer Page 4 (12-31) */
+	u32	buff_ptr0;		/* Buffer pointer Page 0 (31-12) */
+	u32	buff_ptr1;		/* Buffer pointer Page 1 (31-12) */
+	u32	buff_ptr2;		/* Buffer pointer Page 2 (31-12) */
+	u32	buff_ptr3;		/* Buffer pointer Page 3 (31-12) */
+	u32	buff_ptr4;		/* Buffer pointer Page 4 (31-12) */
 	u32	reserved1;
 	/* 8 bytes of setup data that follows the Setup PID */
 	u8	setup_buffer[8];
@@ -287,19 +155,25 @@ struct mv_dqh {
 
 
 #define DTD_NEXT_TERMINATE		(0x00000001)
-#define DTD_IOC				(0x00008000)
-#define DTD_STATUS_ACTIVE		(0x00000080)
-#define DTD_STATUS_HALTED		(0x00000040)
-#define DTD_STATUS_DATA_BUFF_ERR	(0x00000020)
+#define DTD_STATUS_MASK			(0X000000FF)
 #define DTD_STATUS_TRANSACTION_ERR	(0x00000008)
-#define DTD_RESERVED_FIELDS		(0x00007F00)
-#define DTD_ERROR_MASK			(0x68)
-#define DTD_ADDR_MASK			(0xFFFFFFE0)
-#define DTD_PACKET_SIZE			0x7FFF0000
+#define DTD_STATUS_DATA_BUFF_ERR	(0x00000020)
+#define DTD_STATUS_HALTED		(0x00000040)
+#define DTD_STATUS_ACTIVE		(0x00000080)
+#define DTD_ERROR_MASK			(DTD_STATUS_HALTED \
+					| DTD_STATUS_DATA_BUFF_ERR \
+					| DTD_STATUS_TRANSACTION_ERR)
+#define DTD_RESERVED_FIELDS		(0x80007F00)
+#define DTD_IOC				(0x00008000)
+#define DTD_PACKET_SIZE			(0x7FFF0000)
 #define DTD_LENGTH_BIT_POS		(16)
 
+#define REQ_UNCOMPLETE			(1)
+
 struct mv_dtd {
+	/* Next TD pointer(31-5), T(0) set indicate invalid */
 	u32	dtd_next;
+	/* Total bytes (30-16), IOC (15), MultO(11-10), STS (7-0)  */
 	u32	size_ioc_sts;
 	u32	buff_ptr0;		/* Buffer pointer Page 0 */
 	u32	buff_ptr1;		/* Buffer pointer Page 1 */
@@ -312,4 +186,6 @@ struct mv_dtd {
 	struct mv_dtd *next_dtd_virt;
 };
 
+extern int mv_udc_phy_init(unsigned int base);
+
 #endif
diff --git a/drivers/usb/gadget/mv_udc_core.c b/drivers/usb/gadget/mv_udc_core.c
index a73cf40..e525f56 100644
--- a/drivers/usb/gadget/mv_udc_core.c
+++ b/drivers/usb/gadget/mv_udc_core.c
@@ -1,7 +1,5 @@
 /*
  * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
- * Author: Chao Xie <chao.xie@marvell.com>
- *	   Neil Zhang <zhangwm@marvell.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -33,10 +31,18 @@
 #include <linux/irq.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
-#include <linux/platform_data/mv_usb.h>
+#include <linux/usb/mv_usb.h>
+#include <asm/system.h>
 #include <asm/unaligned.h>
 
+#include <plat/usb.h>
+#include <plat/pm.h>
+
 #include "mv_udc.h"
+#if (defined CONFIG_ARCH_PXA && defined CONFIG_DVFM)
+#include <mach/dvfm.h>
+static int	dvfm_dev_idx;
+#endif
 
 #define DRIVER_DESC		"Marvell PXA USB Device Controller driver"
 #define DRIVER_VERSION		"8 Nov 2010"
@@ -50,23 +56,30 @@
 #define EPSTATUS_TIMEOUT	10000
 #define PRIME_TIMEOUT		10000
 #define READSAFE_TIMEOUT	1000
-#define DTD_TIMEOUT		1000
 
-#define LOOPS_USEC_SHIFT	4
+#define LOOPS_USEC_SHIFT	1
 #define LOOPS_USEC		(1 << LOOPS_USEC_SHIFT)
 #define LOOPS(timeout)		((timeout) >> LOOPS_USEC_SHIFT)
 
-static DECLARE_COMPLETION(release_done);
+#define	ENUMERATION_DELAY	(10 * HZ)
 
 static const char driver_name[] = "mv_udc";
 static const char driver_desc[] = DRIVER_DESC;
 
+static DECLARE_COMPLETION(release_done);
+
 /* controller device global variable */
 static struct mv_udc	*the_controller;
-int mv_usb_otgsc;
 
+#if defined(CONFIG_CPU_PXA988)
+static struct pm_qos_request_list qos_idle;
+#endif
+
+static int mv_udc_enable(struct mv_udc *udc);
+static void mv_udc_disable(struct mv_udc *udc);
 static void nuke(struct mv_ep *ep, int status);
 static void stop_activity(struct mv_udc *udc, struct usb_gadget_driver *driver);
+static void call_charger_notifier(struct mv_udc *udc);
 
 /* for endpoint 0 operations */
 static const struct usb_endpoint_descriptor mv_ep0_desc = {
@@ -94,7 +107,7 @@ static void ep0_reset(struct mv_udc *udc)
 		/* configure ep0 endpoint capabilities in dQH */
 		ep->dqh->max_packet_length =
 			(EP0_MAX_PKT_SIZE << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
-			| EP_QUEUE_HEAD_IOS;
+			| EP_QUEUE_HEAD_IOS | EP_QUEUE_HEAD_ZLT_SEL;
 
 		ep->dqh->next_dtd_ptr = EP_QUEUE_HEAD_NEXT_TERMINATE;
 
@@ -353,20 +366,28 @@ static int queue_dtd(struct mv_ep *ep, struct mv_req *req)
 	writel(bit_pos, &udc->op_regs->epprime);
 
 done:
-	return retval;
+	return retval;;
 }
 
-
 static struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,
 		dma_addr_t *dma, int *is_last)
 {
-	u32 temp;
+	u32 temp, mult = 0;
 	struct mv_dtd *dtd;
 	struct mv_udc *udc;
+	struct mv_dqh *dqh;
 
 	/* how big will this transfer be? */
-	*length = min(req->req.length - req->req.actual,
-			(unsigned)EP_MAX_LENGTH_TRANSFER);
+	if ((req->ep->desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)
+		== USB_ENDPOINT_XFER_ISOC) {
+		dqh = req->ep->dqh;
+		mult = (dqh->max_packet_length >> EP_QUEUE_HEAD_MULT_POS)
+				& 0x3;
+		*length = min(req->req.length - req->req.actual,
+				(unsigned)(mult * req->ep->ep.maxpacket));
+	} else
+		*length = min(req->req.length - req->req.actual,
+				(unsigned)EP_MAX_LENGTH_TRANSFER);
 
 	udc = req->ep->udc;
 
@@ -374,7 +395,7 @@ static struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,
 	 * Be careful that no _GFP_HIGHMEM is set,
 	 * or we can not use dma_to_virt
 	 */
-	dtd = dma_pool_alloc(udc->dtd_pool, GFP_KERNEL, dma);
+	dtd = dma_pool_alloc(udc->dtd_pool, GFP_ATOMIC, dma);
 	if (dtd == NULL)
 		return dtd;
 
@@ -407,6 +428,7 @@ static struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,
 	/* Enable interrupt for the last dtd of a request */
 	if (*is_last && !req->req.no_interrupt)
 		temp |= DTD_IOC;
+	temp |= mult << 10;
 
 	dtd->size_ioc_sts = temp;
 
@@ -472,7 +494,7 @@ static int mv_ep_enable(struct usb_ep *_ep,
 		return -ESHUTDOWN;
 
 	direction = ep_dir(ep);
-	max = usb_endpoint_maxp(desc);
+	max = le16_to_cpu(desc->wMaxPacketSize);
 
 	/*
 	 * disable HW zero length termination select
@@ -519,7 +541,7 @@ static int mv_ep_enable(struct usb_ep *_ep,
 
 	spin_lock_irqsave(&udc->lock, flags);
 	/* Get the endpoint queue head address */
-	dqh = ep->dqh;
+	dqh = (struct mv_dqh *)ep->dqh;
 	dqh->max_packet_length = (max << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)
 		| (mult << EP_QUEUE_HEAD_MULT_POS)
 		| (zlt ? EP_QUEUE_HEAD_ZLT_SEL : 0)
@@ -577,6 +599,7 @@ static int  mv_ep_disable(struct usb_ep *_ep)
 	struct mv_ep *ep;
 	struct mv_dqh *dqh;
 	u32 bit_pos, epctrlx, direction;
+	u32 active;
 	unsigned long flags;
 
 	ep = container_of(_ep, struct mv_ep, ep);
@@ -588,6 +611,10 @@ static int  mv_ep_disable(struct usb_ep *_ep)
 	/* Get the endpoint queue head address */
 	dqh = ep->dqh;
 
+	active = udc->active;
+	if (!active)
+		mv_udc_enable(udc);
+
 	spin_lock_irqsave(&udc->lock, flags);
 
 	direction = ep_dir(ep);
@@ -607,11 +634,12 @@ static int  mv_ep_disable(struct usb_ep *_ep)
 	nuke(ep, -ESHUTDOWN);
 
 	ep->desc = NULL;
-	ep->ep.desc = NULL;
 	ep->stopped = 1;
 
 	spin_unlock_irqrestore(&udc->lock, flags);
 
+	if (!active)
+		mv_udc_disable(udc);
 	return 0;
 }
 
@@ -644,7 +672,7 @@ static void mv_ep_fifo_flush(struct usb_ep *_ep)
 {
 	struct mv_udc *udc;
 	u32 bit_pos, direction;
-	struct mv_ep *ep;
+	struct mv_ep *ep = NULL;
 	unsigned int loops;
 
 	if (!_ep)
@@ -708,6 +736,7 @@ mv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	struct mv_req *req = container_of(_req, struct mv_req, req);
 	struct mv_udc *udc = ep->udc;
 	unsigned long flags;
+	int retval;
 
 	/* catch various bogus parameters */
 	if (!_req || !req->req.complete || !req->req.buf
@@ -719,10 +748,6 @@ mv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 		dev_err(&udc->dev->dev, "%s, bad ep", __func__);
 		return -EINVAL;
 	}
-	if (ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {
-		if (req->req.length > ep->ep.maxpacket)
-			return -EMSGSIZE;
-	}
 
 	udc = ep->udc;
 	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)
@@ -755,15 +780,17 @@ mv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 
 	/* build dtds and push them to device queue */
 	if (!req_to_dtd(req)) {
-		int retval;
 		retval = queue_dtd(ep, req);
 		if (retval) {
 			spin_unlock_irqrestore(&udc->lock, flags);
-			return retval;
+			dev_err(&udc->dev->dev, "Failed to queue dtd\n");
+			goto err_unmap_dma;
 		}
 	} else {
 		spin_unlock_irqrestore(&udc->lock, flags);
-		return -ENOMEM;
+		dev_err(&udc->dev->dev, "Failed to dma_pool_alloc\n");
+		retval = -ENOMEM;
+		goto err_unmap_dma;
 	}
 
 	/* Update ep0 state */
@@ -775,6 +802,22 @@ mv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	return 0;
+
+err_unmap_dma:
+	if (req->mapped) {
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+				req->req.dma, req->req.length,
+				((ep_dir(ep) == EP_DIR_IN) ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE));
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	} else
+		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length,
+					((ep_dir(ep) == EP_DIR_IN) ?
+					DMA_TO_DEVICE : DMA_FROM_DEVICE));
+
+	return retval;
 }
 
 static void mv_prime_ep(struct mv_ep *ep, struct mv_req *req)
@@ -811,6 +854,9 @@ static int mv_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	if (!_ep || !_req)
 		return -EINVAL;
 
+	if (!udc->active)
+		return 0;
+
 	spin_lock_irqsave(&ep->udc->lock, flags);
 	stopped = ep->stopped;
 
@@ -1065,7 +1111,7 @@ static int udc_reset(struct mv_udc *udc)
 	tmp |= USBMODE_CTRL_MODE_DEVICE;
 
 	/* turn setup lockout off, require setup tripwire in usbcmd */
-	tmp |= USBMODE_SETUP_LOCK_OFF | USBMODE_STREAM_DISABLE;
+	tmp |= USBMODE_SETUP_LOCK_OFF;
 
 	writel(tmp, &udc->op_regs->usbmode);
 
@@ -1176,6 +1222,19 @@ static int mv_udc_wakeup(struct usb_gadget *gadget)
 	return 0;
 }
 
+static void uevent_worker(struct work_struct *work)
+{
+	struct mv_udc *udc = the_controller;
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+
+	if (!udc)
+		return;
+
+	kobject_uevent_env(&udc->dev->dev.kobj, KOBJ_CHANGE,
+			udc->vbus_active ? connected : disconnected);
+}
+
 static int mv_udc_vbus_session(struct usb_gadget *gadget, int is_active)
 {
 	struct mv_udc *udc;
@@ -1187,28 +1246,74 @@ static int mv_udc_vbus_session(struct usb_gadget *gadget, int is_active)
 
 	udc->vbus_active = (is_active != 0);
 
-	dev_dbg(&udc->dev->dev, "%s: softconnect %d, vbus_active %d\n",
-		__func__, udc->softconnect, udc->vbus_active);
+	dev_dbg(&udc->dev->dev, "%s: driver %p, softconnect %d,"
+		"vbus_active %d\n", __func__, udc->driver, udc->softconnect,
+		udc->vbus_active);
 
-	if (udc->driver && udc->softconnect && udc->vbus_active) {
+	schedule_work(&udc->event_work);
+
+	if (udc->vbus_active) {
 		retval = mv_udc_enable(udc);
-		if (retval == 0) {
-			/* Clock is disabled, need re-init registers */
-			udc_reset(udc);
-			ep0_reset(udc);
-			udc_start(udc);
-		}
+		if (retval)
+			goto out;
+		udc->charger_type = DEFAULT_CHARGER;
+		schedule_delayed_work(&udc->charger_work, HZ >> 3);
+	} else {
+		udc->power = 0;
+		udc->charger_type = NULL_CHARGER;
+		schedule_delayed_work(&udc->charger_work, 0);
+
+#if defined(CONFIG_CPU_PXA988)
+		pm_qos_update_request(&qos_idle, PM_QOS_DEFAULT_VALUE);
+#endif
+	}
+
+	/*
+	* 1. No VBUS detect with OTG: we have to enable clock all the time.
+	* 2. No VBUS detect without OTG: we can disable/enable clock on demand.
+	* 3. VBUS detect: we can disable/enable clock on demand.
+	*/
+	if (udc->driver && udc->softconnect && udc->vbus_active) {
+		/*
+		* after clock is disabled, we lost all the register
+		*  context. We have to re-init registers
+		*/
+		udc_reset(udc);
+		ep0_reset(udc);
+		udc_start(udc);
+#if (defined CONFIG_ARCH_PXA && defined CONFIG_DVFM)
+		dvfm_disable_lowpower(dvfm_dev_idx);
+#endif
 	} else if (udc->driver && udc->softconnect) {
+		if (!udc->active)
+			goto out;
+
 		/* stop all the transfer in queue*/
 		stop_activity(udc, udc->driver);
 		udc_stop(udc);
-		mv_udc_disable(udc);
+#if (defined CONFIG_ARCH_PXA && defined CONFIG_DVFM)
+		dvfm_enable_lowpower(dvfm_dev_idx);
+#endif
 	}
 
+	if (!udc->vbus_active)
+		mv_udc_disable(udc);
+out:
 	spin_unlock_irqrestore(&udc->lock, flags);
 	return retval;
 }
 
+/* constrain controller's VBUS power usage */
+static int mv_udc_vbus_draw(struct usb_gadget *gadget, unsigned mA)
+{
+	struct mv_udc *udc;
+
+	udc = container_of(gadget, struct mv_udc, gadget);
+	udc->power = mA;
+
+	return 0;
+}
+
 static int mv_udc_pullup(struct usb_gadget *gadget, int is_on)
 {
 	struct mv_udc *udc;
@@ -1220,13 +1325,17 @@ static int mv_udc_pullup(struct usb_gadget *gadget, int is_on)
 
 	udc->softconnect = (is_on != 0);
 
-	dev_dbg(&udc->dev->dev, "%s: softconnect %d, vbus_active %d\n",
-			__func__, udc->softconnect, udc->vbus_active);
+	dev_dbg(&udc->dev->dev, "%s: driver %p, softconnect %d,"
+		"vbus_active%d\n", __func__, udc->driver, udc->softconnect,
+		udc->vbus_active);
 
 	if (udc->driver && udc->softconnect && udc->vbus_active) {
 		retval = mv_udc_enable(udc);
 		if (retval == 0) {
-			/* Clock is disabled, need re-init registers */
+			/*
+			* after clock is disabled, we lost all the register
+			*  context. We have to re-init registers
+			*/
 			udc_reset(udc);
 			ep0_reset(udc);
 			udc_start(udc);
@@ -1242,9 +1351,23 @@ static int mv_udc_pullup(struct usb_gadget *gadget, int is_on)
 	return retval;
 }
 
+static int mv_set_selfpowered(struct usb_gadget *gadget, int is_on)
+{
+	struct mv_udc *udc;
+	unsigned long flags;
+
+	udc = container_of(gadget, struct mv_udc, gadget);
+
+	spin_lock_irqsave(&udc->lock, flags);
+	udc->selfpowered = (is_on != 0);
+	spin_unlock_irqrestore(&udc->lock, flags);
+	return 0;
+}
+
 static int mv_udc_start(struct usb_gadget_driver *driver,
-		int (*bind)(struct usb_gadget *));
+			int (*bind)(struct usb_gadget *));
 static int mv_udc_stop(struct usb_gadget_driver *driver);
+
 /* device controller usb_gadget_ops structure */
 static const struct usb_gadget_ops mv_ops = {
 
@@ -1257,8 +1380,13 @@ static const struct usb_gadget_ops mv_ops = {
 	/* notify controller that VBUS is powered or not */
 	.vbus_session	= mv_udc_vbus_session,
 
+	/* constrain controller's VBUS power usage */
+	.vbus_draw	= mv_udc_vbus_draw,
+
 	/* D+ pullup, software-controlled connect/disconnect to USB host */
 	.pullup		= mv_udc_pullup,
+
+	.set_selfpowered = mv_set_selfpowered,
 	.start		= mv_udc_start,
 	.stop		= mv_udc_stop,
 };
@@ -1370,6 +1498,7 @@ static int mv_udc_start(struct usb_gadget_driver *driver,
 	udc->usb_state = USB_STATE_ATTACHED;
 	udc->ep0_state = WAIT_FOR_SETUP;
 	udc->ep0_dir = EP_DIR_OUT;
+	udc->selfpowered = 0;
 
 	spin_unlock_irqrestore(&udc->lock, flags);
 
@@ -1384,7 +1513,7 @@ static int mv_udc_start(struct usb_gadget_driver *driver,
 
 	if (udc->transceiver) {
 		retval = otg_set_peripheral(udc->transceiver->otg,
-					&udc->gadget);
+				&udc->gadget);
 		if (retval) {
 			dev_err(&udc->dev->dev,
 				"unable to register peripheral to otg\n");
@@ -1397,13 +1526,21 @@ static int mv_udc_start(struct usb_gadget_driver *driver,
 		}
 	}
 
+#ifndef CONFIG_USB_G_ANDROID
 	/* pullup is always on */
 	mv_udc_pullup(&udc->gadget, 1);
+#endif
 
-	/* When boot with cable attached, there will be no vbus irq occurred */
+	/* when transceiver is not NULL, qwork is NULL*/
 	if (udc->qwork)
 		queue_work(udc->qwork, &udc->vbus_work);
 
+#if defined CONFIG_ARCH_PXA && defined CONFIG_DVFM
+	dvfm_register("U2O", &dvfm_dev_idx);
+	if(udc->pdata->vbus && udc->pdata->vbus->poll() == VBUS_HIGH){
+		dvfm_disable_lowpower(dvfm_dev_idx);
+	}
+#endif
 	return 0;
 }
 
@@ -1432,6 +1569,9 @@ static int mv_udc_stop(struct usb_gadget_driver *driver)
 	udc->gadget.dev.driver = NULL;
 	udc->driver = NULL;
 
+#if defined CONFIG_ARCH_PXA && defined CONFIG_DVFM
+	dvfm_unregister("U2O", &dvfm_dev_idx);
+#endif
 	return 0;
 }
 
@@ -1499,15 +1639,17 @@ udc_prime_status(struct mv_udc *udc, u8 direction, u16 status, bool empty)
 	}
 
 	/* prime the data phase */
-	if (!req_to_dtd(req))
+	if (!req_to_dtd(req)) {
 		retval = queue_dtd(ep, req);
-	else{	/* no mem */
+		if (retval) {
+			dev_err(&udc->dev->dev,
+				"Failed to queue dtd when prime status\n");
+			goto out;
+		}
+	} else{	/* no mem */
 		retval = -ENOMEM;
-		goto out;
-	}
-
-	if (retval) {
-		dev_err(&udc->dev->dev, "response error on GET_STATUS request\n");
+		dev_err(&udc->dev->dev,
+			"Failed to dma_pool_alloc when prime status\n");
 		goto out;
 	}
 
@@ -1515,15 +1657,29 @@ udc_prime_status(struct mv_udc *udc, u8 direction, u16 status, bool empty)
 
 	return 0;
 out:
+	if (req->mapped) {
+		dma_unmap_single(ep->udc->gadget.dev.parent,
+				req->req.dma, req->req.length,
+				((ep_dir(ep) == EP_DIR_IN) ?
+				DMA_TO_DEVICE : DMA_FROM_DEVICE));
+		req->req.dma = DMA_ADDR_INVALID;
+		req->mapped = 0;
+	}
+
 	return retval;
 }
 
+#define TEST_DISABLE   0
+
 static void mv_udc_testmode(struct mv_udc *udc, u16 index)
 {
 	if (index <= TEST_FORCE_EN) {
 		udc->test_mode = index;
 		if (udc_prime_status(udc, EP_DIR_IN, 0, true))
 			ep0_stall(udc);
+
+		if (index == TEST_DISABLE)
+			mv_set_ptc(udc, TEST_DISABLE);
 	} else
 		dev_err(&udc->dev->dev,
 			"This test mode(%d) is not supported\n", index);
@@ -1543,7 +1699,7 @@ static void ch9setaddress(struct mv_udc *udc, struct usb_ctrlrequest *setup)
 static void ch9getstatus(struct mv_udc *udc, u8 ep_num,
 	struct usb_ctrlrequest *setup)
 {
-	u16 status = 0;
+	u16 status;
 	int retval;
 
 	if ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))
@@ -1551,7 +1707,7 @@ static void ch9getstatus(struct mv_udc *udc, u8 ep_num,
 		return;
 
 	if ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
-		status = 1 << USB_DEVICE_SELF_POWERED;
+		status = udc->selfpowered << USB_DEVICE_SELF_POWERED;
 		status |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;
 	} else if ((setup->bRequestType & USB_RECIP_MASK)
 			== USB_RECIP_INTERFACE) {
@@ -1587,6 +1743,9 @@ static void ch9clearfeature(struct mv_udc *udc, struct usb_ctrlrequest *setup)
 		case USB_DEVICE_REMOTE_WAKEUP:
 			udc->remote_wakeup = 0;
 			break;
+		case USB_DEVICE_TEST_MODE:
+			mv_udc_testmode(udc, TEST_DISABLE);
+			goto out;
 		default:
 			goto out;
 		}
@@ -1671,6 +1830,47 @@ out:
 	return;
 }
 
+static int is_set_configuration(struct usb_ctrlrequest *setup)
+{
+	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)
+		if (setup->bRequest == USB_REQ_SET_CONFIGURATION)
+			return 1;
+
+	return 0;
+}
+
+static const char *reqname(unsigned bRequest)
+{
+	switch (bRequest) {
+	case USB_REQ_GET_STATUS: return "GET_STATUS";
+	case USB_REQ_CLEAR_FEATURE: return "CLEAR_FEATURE";
+	case USB_REQ_SET_FEATURE: return "SET_FEATURE";
+	case USB_REQ_SET_ADDRESS: return "SET_ADDRESS";
+	case USB_REQ_GET_DESCRIPTOR: return "GET_DESCRIPTOR";
+	case USB_REQ_SET_DESCRIPTOR: return "SET_DESCRIPTOR";
+	case USB_REQ_GET_CONFIGURATION: return "GET_CONFIGURATION";
+	case USB_REQ_SET_CONFIGURATION: return "SET_CONFIGURATION";
+	case USB_REQ_GET_INTERFACE: return "GET_INTERFACE";
+	case USB_REQ_SET_INTERFACE: return "SET_INTERFACE";
+	default: return "*UNKNOWN*";
+	}
+}
+
+static const char *desc_type(unsigned type)
+{
+	switch (type) {
+	case USB_DT_DEVICE: return "USB_DT_DEVICE";
+	case USB_DT_CONFIG: return "USB_DT_CONFIG";
+	case USB_DT_STRING: return "USB_DT_STRING";
+	case USB_DT_INTERFACE: return "USB_DT_INTERFACE";
+	case USB_DT_ENDPOINT: return "USB_DT_ENDPOINT";
+	case USB_DT_DEVICE_QUALIFIER: return "USB_DT_DEVICE_QUALIFIER";
+	case USB_DT_OTHER_SPEED_CONFIG: return "USB_DT_OTHER_SPEED_CONFIG";
+	case USB_DT_INTERFACE_POWER: return "USB_DT_INTERFACE_POWER";
+	default: return "*UNKNOWN*";
+	}
+}
+
 static void handle_setup_packet(struct mv_udc *udc, u8 ep_num,
 	struct usb_ctrlrequest *setup)
 {
@@ -1678,9 +1878,11 @@ static void handle_setup_packet(struct mv_udc *udc, u8 ep_num,
 
 	nuke(&udc->eps[ep_num * 2 + EP_DIR_OUT], -ESHUTDOWN);
 
-	dev_dbg(&udc->dev->dev, "SETUP %02x.%02x v%04x i%04x l%04x\n",
-			setup->bRequestType, setup->bRequest,
-			setup->wValue, setup->wIndex, setup->wLength);
+	dev_dbg(&udc->dev->dev, "%s, \t%s, \t%d\n", reqname(setup->bRequest),
+		(setup->bRequest == USB_REQ_GET_DESCRIPTOR)
+		 ? desc_type(setup->wValue >> 8) : NULL,
+		 setup->wIndex);
+
 	/* We process some stardard setup requests here */
 	if ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
 		switch (setup->bRequest) {
@@ -1730,6 +1932,17 @@ static void handle_setup_packet(struct mv_udc *udc, u8 ep_num,
 			spin_lock(&udc->lock);
 			udc->ep0_state = WAIT_FOR_OUT_STATUS;
 		}
+
+		if (is_set_configuration(setup)) {
+			if (udc->charger_type == DEFAULT_CHARGER) {
+#if defined(CONFIG_CPU_PXA988)
+				pm_qos_update_request(&qos_idle,
+						PM_QOS_CONSTRAINT);
+#endif
+				udc->charger_type = VBUS_CHARGER;
+				schedule_delayed_work(&udc->charger_work, 0);
+			}
+		}
 	}
 }
 
@@ -2014,7 +2227,7 @@ static void irq_process_error(struct mv_udc *udc)
 static irqreturn_t mv_udc_irq(int irq, void *dev)
 {
 	struct mv_udc *udc = (struct mv_udc *)dev;
-	u32 status, intr;
+	u32 status, intr, usbmode;
 
 	/* Disable ISR when stopped bit is set */
 	if (udc->stopped)
@@ -2022,6 +2235,12 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 
 	spin_lock(&udc->lock);
 
+	usbmode = readl(&udc->op_regs->usbmode);
+	if ((usbmode & USBMODE_CTRL_MODE_MASK) != USBMODE_CTRL_MODE_DEVICE) {
+		spin_unlock(&udc->lock);
+		return IRQ_NONE;
+	}
+
 	status = readl(&udc->op_regs->usbsts);
 	intr = readl(&udc->op_regs->usbintr);
 	status &= intr;
@@ -2054,6 +2273,76 @@ static irqreturn_t mv_udc_irq(int irq, void *dev)
 	return IRQ_HANDLED;
 }
 
+static BLOCKING_NOTIFIER_HEAD(mv_udc_notifier_list);
+
+/* For any user that care about USB udc events, for example the charger*/
+int mv_udc_register_client(struct notifier_block *nb)
+{
+	struct mv_udc *udc = the_controller;
+	int ret = 0;
+
+	if (!udc)
+		return -ENODEV;
+
+	ret = blocking_notifier_chain_register(&mv_udc_notifier_list, nb);
+	if (ret)
+		return ret;
+
+	if (udc->charger_type)
+		call_charger_notifier(udc);
+
+	return 0;
+}
+EXPORT_SYMBOL(mv_udc_register_client);
+
+int mv_udc_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&mv_udc_notifier_list, nb);
+}
+EXPORT_SYMBOL(mv_udc_unregister_client);
+
+static void call_charger_notifier(struct mv_udc *udc)
+{
+	blocking_notifier_call_chain(&mv_udc_notifier_list,
+				udc->charger_type, &udc->power);
+}
+
+static void do_charger_work(struct work_struct *work)
+{
+	struct mv_udc *udc = NULL;
+	u32 val = 0;
+	u32 charger_mask = PORTSCX_PORT_DM | PORTSCX_PORT_DP;
+
+	udc = container_of(work, struct mv_udc, charger_work.work);
+
+	if (udc->charger_type == DEFAULT_CHARGER) {
+		val = readl(&udc->op_regs->portsc) & charger_mask;
+		if (val == charger_mask)
+			udc->charger_type = AC_CHARGER_STANDARD;
+		else
+			schedule_delayed_work(&udc->delayed_charger_work,
+						ENUMERATION_DELAY);
+	}
+
+	if (udc->charger_type == NULL_CHARGER
+		&& work_pending(&udc->delayed_charger_work.work))
+		cancel_delayed_work(&udc->delayed_charger_work);
+
+	call_charger_notifier(udc);
+}
+
+static void do_delayed_work(struct work_struct *work)
+{
+	struct mv_udc *udc = NULL;
+
+	udc = container_of(work, struct mv_udc, delayed_charger_work.work);
+
+	if (udc->charger_type == DEFAULT_CHARGER) {
+		udc->charger_type = AC_CHARGER_OTHER;
+		call_charger_notifier(udc);
+	}
+}
+
 static irqreturn_t mv_udc_vbus_irq(int irq, void *dev)
 {
 	struct mv_udc *udc = (struct mv_udc *)dev;
@@ -2083,6 +2372,68 @@ static void mv_udc_vbus_work(struct work_struct *work)
 		mv_udc_vbus_session(&udc->gadget, 0);
 }
 
+static ssize_t
+usb_reg_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mv_udc *udc = the_controller;
+	int ret, i;
+
+	if (!udc) {
+		dev_err(&udc->dev->dev,
+			"The controller is not initialized.\n");
+		return -1;
+	}
+
+	if (!udc->active) {
+		ret = sprintf(buf, "The controller is clock off now.\n");
+		return ret;
+	}
+
+	ret = sprintf(buf, "usbcmd: 0x%x\n",
+			readl(&udc->op_regs->usbcmd));
+	ret += sprintf(buf + ret, "usbsts: 0x%x\n",
+			readl(&udc->op_regs->usbsts));
+	ret += sprintf(buf + ret, "usbintr: 0x%x\n",
+			readl(&udc->op_regs->usbintr));
+	ret += sprintf(buf + ret, "epnak: 0x%x\n",
+			readl(&udc->op_regs->epnak));
+	ret += sprintf(buf + ret, "epnaken: 0x%x\n",
+			readl(&udc->op_regs->epnaken));
+	ret += sprintf(buf + ret, "configflag: 0x%x\n",
+			readl(&udc->op_regs->configflag));
+	ret += sprintf(buf + ret, "portsc: 0x%x\n",
+			readl(&udc->op_regs->portsc));
+	ret += sprintf(buf + ret, "otgsc: 0x%x\n",
+			readl(&udc->op_regs->otgsc));
+	ret += sprintf(buf + ret, "usbmode: 0x%x\n",
+			readl(&udc->op_regs->usbmode));
+	ret += sprintf(buf + ret, "epsetupstat: 0x%x\n",
+			readl(&udc->op_regs->epsetupstat));
+	ret += sprintf(buf + ret, "epprime: 0x%x\n",
+			readl(&udc->op_regs->epprime));
+	ret += sprintf(buf + ret, "epflush: 0x%x\n",
+			readl(&udc->op_regs->epflush));
+	ret += sprintf(buf + ret, "epstatus: 0x%x\n",
+			readl(&udc->op_regs->epstatus));
+	ret += sprintf(buf + ret, "epcomplete: 0x%x\n",
+			readl(&udc->op_regs->epcomplete));
+
+	for (i = 0; i < 16; i++)
+		ret += sprintf(buf + ret, "epctrlx[%d]: 0x%x\n",
+			i, readl(&udc->op_regs->epctrlx[i]));
+	return ret;
+}
+
+static DEVICE_ATTR(op_regs, S_IRUGO|S_IWUSR, usb_reg_show, NULL);
+
+static struct attribute *gadget_attrs[] = {
+	&dev_attr_op_regs.attr,
+	NULL,
+};
+static struct attribute_group gadget_attr_group = {
+	.attrs = gadget_attrs,
+};
+
 /* release device structure */
 static void gadget_release(struct device *_dev)
 {
@@ -2091,25 +2442,25 @@ static void gadget_release(struct device *_dev)
 	complete(udc->done);
 }
 
-static int __devexit mv_udc_remove(struct platform_device *dev)
+static __devexit int mv_udc_remove(struct platform_device *dev)
 {
 	struct mv_udc *udc = the_controller;
 	int clk_i;
 
-	usb_del_gadget_udc(&udc->gadget);
+	sysfs_remove_group(&udc->dev->dev.kobj, &gadget_attr_group);
+
+	if (udc->pdata && udc->pdata->vbus
+		&& udc->transceiver == NULL && udc->clock_gating)
+		free_irq(udc->pdata->vbus->irq, &dev->dev);
 
 	if (udc->qwork) {
 		flush_workqueue(udc->qwork);
 		destroy_workqueue(udc->qwork);
 	}
 
-	/*
-	 * If we have transceiver inited,
-	 * then vbus irq will not be requested in udc driver.
-	 */
-	if (udc->pdata && udc->pdata->vbus
-		&& udc->clock_gating && udc->transceiver == NULL)
-		free_irq(udc->pdata->vbus->irq, &dev->dev);
+#if defined(CONFIG_CPU_PXA988)
+	pm_qos_remove_request(&qos_idle);
+#endif
 
 	/* free memory allocated in probe */
 	if (udc->dtd_pool)
@@ -2128,9 +2479,11 @@ static int __devexit mv_udc_remove(struct platform_device *dev)
 
 	if (udc->cap_regs)
 		iounmap(udc->cap_regs);
+	udc->cap_regs = NULL;
 
 	if (udc->phy_regs)
-		iounmap(udc->phy_regs);
+		iounmap((void *)udc->phy_regs);
+	udc->phy_regs = 0;
 
 	if (udc->status_req) {
 		kfree(udc->status_req->req.buf);
@@ -2144,9 +2497,8 @@ static int __devexit mv_udc_remove(struct platform_device *dev)
 
 	/* free dev, wait for the release() finished */
 	wait_for_completion(udc->done);
-	kfree(udc);
-
 	the_controller = NULL;
+	kfree(udc);
 
 	return 0;
 }
@@ -2154,7 +2506,7 @@ static int __devexit mv_udc_remove(struct platform_device *dev)
 static int __devinit mv_udc_probe(struct platform_device *dev)
 {
 	struct mv_usb_platform_data *pdata = dev->dev.platform_data;
-	struct mv_udc *udc;
+	struct mv_udc *udc = NULL;
 	int retval = 0;
 	int clk_i = 0;
 	struct resource *r;
@@ -2162,24 +2514,26 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 
 	if (pdata == NULL) {
 		dev_err(&dev->dev, "missing platform_data\n");
-		return -ENODEV;
+		retval = -ENODEV;
+		goto err_pdata;
 	}
 
 	size = sizeof(*udc) + sizeof(struct clk *) * pdata->clknum;
 	udc = kzalloc(size, GFP_KERNEL);
 	if (udc == NULL) {
 		dev_err(&dev->dev, "failed to allocate memory for udc\n");
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto err_alloc_private;
 	}
 
 	the_controller = udc;
 	udc->done = &release_done;
-	udc->pdata = dev->dev.platform_data;
 	spin_lock_init(&udc->lock);
 
 	udc->dev = dev;
+	udc->pdata = dev->dev.platform_data;
 
-#ifdef CONFIG_USB_OTG_UTILS
+#ifdef CONFIG_USB_OTG
 	if (pdata->mode == MV_USB_MODE_OTG)
 		udc->transceiver = usb_get_transceiver();
 #endif
@@ -2189,7 +2543,7 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 		udc->clk[clk_i] = clk_get(&dev->dev, pdata->clkname[clk_i]);
 		if (IS_ERR(udc->clk[clk_i])) {
 			retval = PTR_ERR(udc->clk[clk_i]);
-			goto err_put_clk;
+			goto err_get_clk;
 		}
 	}
 
@@ -2197,7 +2551,7 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	if (r == NULL) {
 		dev_err(&dev->dev, "no I/O memory resource defined\n");
 		retval = -ENODEV;
-		goto err_put_clk;
+		goto err_get_cap_regs;
 	}
 
 	udc->cap_regs = (struct mv_cap_regs __iomem *)
@@ -2205,42 +2559,41 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	if (udc->cap_regs == NULL) {
 		dev_err(&dev->dev, "failed to map I/O memory\n");
 		retval = -EBUSY;
-		goto err_put_clk;
+		goto err_map_cap_regs;
 	}
 
 	r = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, "phyregs");
 	if (r == NULL) {
 		dev_err(&dev->dev, "no phy I/O memory resource defined\n");
 		retval = -ENODEV;
-		goto err_iounmap_capreg;
+		goto err_get_phy_regs;
 	}
 
-	udc->phy_regs = ioremap(r->start, resource_size(r));
-	if (udc->phy_regs == NULL) {
+	udc->phy_regs = (unsigned int)ioremap(r->start, resource_size(r));
+	if (udc->phy_regs == 0) {
 		dev_err(&dev->dev, "failed to map phy I/O memory\n");
 		retval = -EBUSY;
-		goto err_iounmap_capreg;
+		goto err_map_phy_regs;
 	}
 
 	/* we will acces controller register, so enable the clk */
 	retval = mv_udc_enable_internal(udc);
 	if (retval)
-		goto err_iounmap_phyreg;
+		goto err_phy_init;
 
-	udc->op_regs =
-		(struct mv_op_regs __iomem *)((unsigned long)udc->cap_regs
+	udc->op_regs = (struct mv_op_regs __iomem *)((u32)udc->cap_regs
 		+ (readl(&udc->cap_regs->caplength_hciversion)
 			& CAPLENGTH_MASK));
 	udc->max_eps = readl(&udc->cap_regs->dccparams) & DCCPARAMS_DEN_MASK;
 
 	/*
-	 * some platform will use usb to download image, it may not disconnect
-	 * usb gadget before loading kernel. So first stop udc here.
-	 */
+	* some platform will use usb to download image, it may not disconnect
+	* usb gadget before loading kernel. So first stop udc here.
+	*/
 	udc_stop(udc);
 	writel(0xFFFFFFFF, &udc->op_regs->usbsts);
 
-	size = udc->max_eps * sizeof(struct mv_dqh) *2;
+	size = udc->max_eps * sizeof(struct mv_dqh) * 2;
 	size = (size + DQH_ALIGNMENT - 1) & ~(DQH_ALIGNMENT - 1);
 	udc->ep_dqh = dma_alloc_coherent(&dev->dev, size,
 					&udc->ep_dqh_dma, GFP_KERNEL);
@@ -2248,7 +2601,7 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	if (udc->ep_dqh == NULL) {
 		dev_err(&dev->dev, "allocate dQH memory failed\n");
 		retval = -ENOMEM;
-		goto err_disable_clock;
+		goto err_alloc_dqh;
 	}
 	udc->ep_dqh_size = size;
 
@@ -2261,15 +2614,15 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 
 	if (!udc->dtd_pool) {
 		retval = -ENOMEM;
-		goto err_free_dma;
+		goto err_alloc_dtd_pool;
 	}
 
-	size = udc->max_eps * sizeof(struct mv_ep) *2;
+	size = udc->max_eps * sizeof(struct mv_ep) * 2;
 	udc->eps = kzalloc(size, GFP_KERNEL);
 	if (udc->eps == NULL) {
 		dev_err(&dev->dev, "allocate ep memory failed\n");
 		retval = -ENOMEM;
-		goto err_destroy_dma;
+		goto err_alloc_eps;
 	}
 
 	/* initialize ep0 status request structure */
@@ -2277,7 +2630,7 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	if (!udc->status_req) {
 		dev_err(&dev->dev, "allocate status_req memory failed\n");
 		retval = -ENOMEM;
-		goto err_free_eps;
+		goto err_alloc_status_req;
 	}
 	INIT_LIST_HEAD(&udc->status_req->queue);
 
@@ -2294,15 +2647,16 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	if (r == NULL) {
 		dev_err(&dev->dev, "no IRQ resource defined\n");
 		retval = -ENODEV;
-		goto err_free_status_req;
+		goto err_get_irq;
 	}
 	udc->irq = r->start;
 	if (request_irq(udc->irq, mv_udc_irq,
-		IRQF_SHARED, driver_name, udc)) {
+		IRQF_DISABLED | IRQF_SHARED, driver_name, udc)) {
 		dev_err(&dev->dev, "Request irq %d for UDC failed\n",
 			udc->irq);
+		udc->irq = 0;
 		retval = -ENODEV;
-		goto err_free_status_req;
+		goto err_request_irq;
 	}
 
 	/* initialize gadget structure */
@@ -2310,7 +2664,7 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	udc->gadget.ep0 = &udc->eps[0].ep;	/* gadget ep0 */
 	INIT_LIST_HEAD(&udc->gadget.ep_list);	/* ep_list */
 	udc->gadget.speed = USB_SPEED_UNKNOWN;	/* speed */
-	udc->gadget.max_speed = USB_SPEED_HIGH;	/* support dual speed */
+	udc->gadget.max_speed = USB_SPEED_HIGH; /* support dual speed */
 
 	/* the "gadget" abstracts/virtualizes the controller */
 	dev_set_name(&udc->gadget.dev, "gadget");
@@ -2321,44 +2675,67 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 
 	retval = device_register(&udc->gadget.dev);
 	if (retval)
-		goto err_free_irq;
+		goto err_register_gadget_device;
 
 	eps_init(udc);
 
-	/* VBUS detect: we can disable/enable clock on demand.*/
-	if (udc->transceiver)
-		udc->clock_gating = 1;
-	else if (pdata->vbus) {
+#if defined(CONFIG_CPU_PXA988)
+	pm_qos_add_request(&qos_idle, PM_QOS_CPUIDLE_KEEP_AXI,
+			PM_QOS_DEFAULT_VALUE);
+#endif
+
+	/* used to tell user space when usb cable plug in and out */
+	INIT_WORK(&udc->event_work, uevent_worker);
+
+	INIT_DELAYED_WORK(&udc->charger_work, do_charger_work);
+	INIT_DELAYED_WORK(&udc->delayed_charger_work, do_delayed_work);
+	udc->charger_type = NULL_CHARGER;
+
+	/*
+	 * 1. VBUS detect: we can disable/enable clock on demand.
+	 * 2. OTG enable: we can disable/enable clock on demand.
+	 * 3. No VBUS detect with OTG: we have to enable clock all the time.
+	 */
+	if (pdata->vbus || udc->transceiver)
 		udc->clock_gating = 1;
-		retval = request_threaded_irq(pdata->vbus->irq, NULL,
-				mv_udc_vbus_irq, IRQF_ONESHOT, "vbus", udc);
-		if (retval) {
-			dev_info(&dev->dev,
-				"Can not request irq for VBUS, "
-				"disable clock gating\n");
-			udc->clock_gating = 0;
-		}
 
+	if (pdata->vbus && udc->transceiver == NULL) {
 		udc->qwork = create_singlethread_workqueue("mv_udc_queue");
 		if (!udc->qwork) {
 			dev_err(&dev->dev, "cannot create workqueue\n");
 			retval = -ENOMEM;
-			goto err_unregister;
+			goto err_create_qwork;
 		}
 
 		INIT_WORK(&udc->vbus_work, mv_udc_vbus_work);
+		retval = request_threaded_irq(pdata->vbus->irq, NULL,
+				mv_udc_vbus_irq, IRQF_ONESHOT, "vbus", udc);
+		if (retval) {
+			dev_info(&dev->dev,
+				"Can not request irq for VBUS, "
+				"disable clock gating\n");
+			udc->clock_gating = 0;
+		}
 	}
 
 	/*
-	 * When clock gating is supported, we can disable clk and phy.
-	 * If not, it means that VBUS detection is not supported, we
-	 * have to enable vbus active all the time to let controller work.
-	 */
+	* For saving power disable clk. When clock is disabled,
+	* phy is deinit too.
+	* When clock is always on, It means that VBUS can not be detected,
+	* so enable vbus_active to make controller run at all the time.
+	*/
 	if (udc->clock_gating)
 		mv_udc_disable_internal(udc);
 	else
 		udc->vbus_active = 1;
 
+	retval = sysfs_create_group(&dev->dev.kobj, &gadget_attr_group);
+	if (retval < 0) {
+		dev_dbg(&dev->dev, "Can't register sysfs attr group: %d\n",
+			retval);
+		goto err_destroy_waklock;
+	}
+
 	retval = usb_add_gadget_udc(&dev->dev, &udc->gadget);
 	if (retval)
 		goto err_unregister;
@@ -2369,33 +2746,48 @@ static int __devinit mv_udc_probe(struct platform_device *dev)
 	return 0;
 
 err_unregister:
+err_destroy_waklock:
 	if (udc->pdata && udc->pdata->vbus
-		&& udc->clock_gating && udc->transceiver == NULL)
+		&& udc->transceiver == NULL && udc->clock_gating)
 		free_irq(pdata->vbus->irq, &dev->dev);
+	if (udc->qwork) {
+		flush_workqueue(udc->qwork);
+		destroy_workqueue(udc->qwork);
+	}
+err_create_qwork:
+#if defined(CONFIG_CPU_PXA988)
+	pm_qos_remove_request(&qos_idle);
+#endif
 	device_unregister(&udc->gadget.dev);
-err_free_irq:
+err_register_gadget_device:
 	free_irq(udc->irq, &dev->dev);
-err_free_status_req:
+err_request_irq:
+err_get_irq:
 	kfree(udc->status_req->req.buf);
 	kfree(udc->status_req);
-err_free_eps:
+err_alloc_status_req:
 	kfree(udc->eps);
-err_destroy_dma:
+err_alloc_eps:
 	dma_pool_destroy(udc->dtd_pool);
-err_free_dma:
+err_alloc_dtd_pool:
 	dma_free_coherent(&dev->dev, udc->ep_dqh_size,
-			udc->ep_dqh, udc->ep_dqh_dma);
-err_disable_clock:
+		udc->ep_dqh, udc->ep_dqh_dma);
+err_alloc_dqh:
 	mv_udc_disable_internal(udc);
-err_iounmap_phyreg:
-	iounmap(udc->phy_regs);
-err_iounmap_capreg:
+err_phy_init:
+	iounmap((void *)udc->phy_regs);
+err_map_phy_regs:
+err_get_phy_regs:
 	iounmap(udc->cap_regs);
-err_put_clk:
+err_map_cap_regs:
+err_get_cap_regs:
+err_get_clk:
 	for (clk_i--; clk_i >= 0; clk_i--)
 		clk_put(udc->clk[clk_i]);
 	the_controller = NULL;
 	kfree(udc);
+err_alloc_private:
+err_pdata:
 	return retval;
 }
 
@@ -2467,10 +2859,15 @@ static void mv_udc_shutdown(struct platform_device *dev)
 	struct mv_udc *udc = the_controller;
 	u32 mode;
 
+	if (!udc)
+		return;
+
+	mv_udc_enable(udc);
 	/* reset controller mode to IDLE */
 	mode = readl(&udc->op_regs->usbmode);
 	mode &= ~3;
 	writel(mode, &udc->op_regs->usbmode);
+	mv_udc_disable(udc);
 }
 
 static struct platform_driver udc_driver = {
@@ -2479,7 +2876,7 @@ static struct platform_driver udc_driver = {
 	.shutdown	= mv_udc_shutdown,
 	.driver		= {
 		.owner	= THIS_MODULE,
-		.name	= "mv-udc",
+		.name	= "pxa-u2o",
 #ifdef CONFIG_PM
 		.pm	= &mv_udc_pm_ops,
 #endif
-- 
1.7.5.4

