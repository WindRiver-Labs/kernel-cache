From 934068daf61b010d6c53a62aee2c6a1da682a3c4 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 6 Sep 2013 14:42:45 +0800
Subject: [PATCH 55/60] video: fixes to interrupt handler thread for mmp3

It seems there is a mistake in the original patch for irq thread
handler, and we shouldn't put wakeup in irq_disabled context, so
fix it to avoid the following calltrace:

in_atomic(): 1, irqs_disabled(): 128, pid: 325, name: X
[<c0017820>] (unwind_backtrace+0x0/0x104) from [<c0692a6c>] (dump_stack+0x20/0x24)
[<c0692a6c>] (dump_stack+0x20/0x24) from [<c0067bcc>] (__might_sleep+0x12c/0x130)
[<c0067bcc>] (__might_sleep+0x12c/0x130) from [<c069c83c>] (rt_spin_lock+0x2c/0x38)
[<c069c83c>] (rt_spin_lock+0x2c/0x38) from [<c03b7e94>] (pxa168_fb_isr+0x64/0xb4)
[<c03b7e94>] (pxa168_fb_isr+0x64/0xb4) from [<c03b2668>] (pxa168fb_handle_irq+0x104/0x7a8)
[<c03b2668>] (pxa168fb_handle_irq+0x104/0x7a8) from [<c00af23c>] (handle_irq_event_percpu+0xf0/0x43c)
[<c00af23c>] (handle_irq_event_percpu+0xf0/0x43c) from [<c00af600>] (handle_irq_event+0x78/0xa0)
[<c00af600>] (handle_irq_event+0x78/0xa0) from [<c00b2860>] (handle_fasteoi_irq+0xd4/0x18c)
[<c00b2860>] (handle_fasteoi_irq+0xd4/0x18c) from [<c00ae8fc>] (generic_handle_irq+0x40/0x50)
[<c00ae8fc>] (generic_handle_irq+0x40/0x50) from [<c000f824>] (handle_IRQ+0x68/0xbc)
[<c000f824>] (handle_IRQ+0x68/0xbc) from [<c00084b0>] (asm_do_IRQ+0x18/0x1c)
[<c00084b0>] (asm_do_IRQ+0x18/0x1c) from [<c069d234>] (__irq_svc+0x34/0xb4)

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/video/pxa168fb.c |   21 +++++++++------------
 1 files changed, 9 insertions(+), 12 deletions(-)

diff --git a/drivers/video/pxa168fb.c b/drivers/video/pxa168fb.c
index 792365e..5ec4ced 100644
--- a/drivers/video/pxa168fb.c
+++ b/drivers/video/pxa168fb.c
@@ -1073,16 +1073,13 @@ static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
 }
 
 #ifdef CONFIG_CPU_MMP3
-static irqreturn_t pxa168fb_threaded_handle_irq(int irq, void *dev_id)
+static irqreturn_t pxa168fb_hard_handle_irq(int irq, void *dev_id)
 {
 	if (atomic_read(&framedone)) {
-#ifdef CONFIG_DDR_DEVFREQ
-		wakeup_ddr_fc_seq();
-#endif
 		atomic_set(&framedone, 0);
 	}
 
-	return IRQ_HANDLED;
+	return IRQ_WAKE_THREAD;
 }
 
 static u32 irq_mask_get(int id)
@@ -1150,8 +1147,12 @@ static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
 					    !((isr_en |
 					    (irq_status_get(id) &
 					    irq_mask_get(id))) &
-					    vsync_imask(0)))
+					    vsync_imask(0))){
 						atomic_set(&framedone, 1);
+#ifdef CONFIG_DDR_DEVFREQ
+						wakeup_ddr_fc_seq();
+#endif
+					}
 #endif
 #if defined(CONFIG_CPU_MMP2) && defined(CONFIG_CPU_FREQ) && defined(CONFIG_PM)
 					wakeup_freq_seq();
@@ -1234,11 +1235,7 @@ static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
 			(path_imasks(0) | path_imasks(1) | err_imasks)) &&
 			!(irqtm_check && vsync_check));
 
-#if defined(CONFIG_CPU_MMP3)
-	return IRQ_WAKE_THREAD;
-#else
 	return IRQ_HANDLED;
-#endif
 }
 
 #ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
@@ -2234,8 +2231,8 @@ static int __devinit pxa168fb_probe(struct platform_device *pdev)
 		/* Clear the irq status before kernel startup */
 		irq_status_clear(fbi->id, 0xFFFFFFFF);
 #if defined(CONFIG_CPU_MMP3)
-		ret = request_threaded_irq(irq, pxa168fb_handle_irq,
-					   pxa168fb_threaded_handle_irq,
+		ret = request_threaded_irq(irq, pxa168fb_hard_handle_irq,
+					    pxa168fb_handle_irq,
 					   IRQF_DISABLED, mi->id, fbi);
 #else
 		ret = request_irq(irq, pxa168fb_handle_irq, IRQF_DISABLED,
-- 
1.7.5.4

