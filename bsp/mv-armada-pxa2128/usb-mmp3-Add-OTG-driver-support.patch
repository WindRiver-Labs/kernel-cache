From a266f6676fba434aeabc5e3839501f7547f1aed5 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 11 Sep 2013 12:46:23 +0800
Subject: [PATCH 59/60] usb: mmp3: Add OTG driver support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch updates the usb host driver to cater for our
new kernel 3.4.x.

Singed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/usb/otg/mv_otg.c |  528 ++++++++++++++++++++++++++--------------------
 drivers/usb/otg/mv_otg.h |  161 +++++----------
 2 files changed, 346 insertions(+), 343 deletions(-)

diff --git a/drivers/usb/otg/mv_otg.c b/drivers/usb/otg/mv_otg.c
index 6cc6c3f..d15a0d5 100644
--- a/drivers/usb/otg/mv_otg.c
+++ b/drivers/usb/otg/mv_otg.c
@@ -1,7 +1,5 @@
 /*
  * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
- * Author: Chao Xie <chao.xie@marvell.com>
- *	   Neil Zhang <zhangwm@marvell.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -25,18 +23,33 @@
 #include <linux/usb/otg.h>
 #include <linux/usb/gadget.h>
 #include <linux/usb/hcd.h>
-#include <linux/platform_data/mv_usb.h>
+#include <linux/usb/mv_usb.h>
+
+#include <mach/hardware.h>
+#include <asm/mach-types.h>
+#ifdef CONFIG_PXA95x
+#include <mach/dvfm.h>
+#endif
+
+#include <plat/usb.h>
 
 #include "mv_otg.h"
 
-#define	DRIVER_DESC	"Marvell USB OTG transceiver driver"
-#define	DRIVER_VERSION	"Jan 20, 2010"
+#define	DRIVER_DESC		"Marvell USB OTG transceiver driver"
+#define	DRIVER_VERSION		"Jan 20, 2010"
 
 MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Chao Xie <chao.xie@marvell.com>");
 MODULE_VERSION(DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
-static const char driver_name[] = "mv-otg";
+static const char driver_name[] = "mv_otg";
+
+static struct mv_otg *the_transceiver;
+static int otg_force_host_mode;
+#ifdef CONFIG_PXA95x
+static int dvfm_dev_idx;
+#endif
 
 static char *state_string[] = {
 	"undefined",
@@ -58,14 +71,16 @@ static char *state_string[] = {
 static int mv_otg_set_vbus(struct usb_otg *otg, bool on)
 {
 	struct mv_otg *mvotg = container_of(otg->phy, struct mv_otg, phy);
+
+	BUG_ON(mvotg != the_transceiver);
+
 	if (mvotg->pdata->set_vbus == NULL)
 		return -ENODEV;
 
 	return mvotg->pdata->set_vbus(on);
 }
 
-static int mv_otg_set_host(struct usb_otg *otg,
-			   struct usb_bus *host)
+static int mv_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
 {
 	otg->host = host;
 
@@ -73,30 +88,31 @@ static int mv_otg_set_host(struct usb_otg *otg,
 }
 
 static int mv_otg_set_peripheral(struct usb_otg *otg,
-				 struct usb_gadget *gadget)
+					struct usb_gadget *gadget)
 {
 	otg->gadget = gadget;
 
 	return 0;
 }
 
-static void mv_otg_run_state_machine(struct mv_otg *mvotg,
-				     unsigned long delay)
+static void mv_otg_run_state_machine(struct mv_otg *mvotg, unsigned long delay)
 {
-	dev_dbg(&mvotg->pdev->dev, "transceiver is updated\n");
+	int retval;
+
+	dev_dbg(&mvotg->dev->dev, "transceiver is updated\n");
 	if (!mvotg->qwork)
-		return;
+		return ;
 
-	queue_delayed_work(mvotg->qwork, &mvotg->work, delay);
+	retval = queue_delayed_work(mvotg->qwork, &mvotg->work, delay);
 }
 
 static void mv_otg_timer_await_bcon(unsigned long data)
 {
-	struct mv_otg *mvotg = (struct mv_otg *) data;
+	struct mv_otg *mvotg = (struct mv_otg *)data;
 
 	mvotg->otg_ctrl.a_wait_bcon_timeout = 1;
 
-	dev_info(&mvotg->pdev->dev, "B Device No Response!\n");
+	dev_info(&mvotg->dev->dev, "B Device No Response!\n");
 
 	if (spin_trylock(&mvotg->wq_lock)) {
 		mv_otg_run_state_machine(mvotg, 0);
@@ -120,8 +136,7 @@ static int mv_otg_cancel_timer(struct mv_otg *mvotg, unsigned int id)
 }
 
 static int mv_otg_set_timer(struct mv_otg *mvotg, unsigned int id,
-			    unsigned long interval,
-			    void (*callback) (unsigned long))
+	unsigned long interval, void (*callback)(unsigned long))
 {
 	struct timer_list *timer;
 
@@ -129,13 +144,13 @@ static int mv_otg_set_timer(struct mv_otg *mvotg, unsigned int id,
 		return -EINVAL;
 
 	timer = &mvotg->otg_ctrl.timer[id];
+
 	if (timer_pending(timer)) {
-		dev_err(&mvotg->pdev->dev, "Timer%d is already running\n", id);
+		dev_err(&mvotg->dev->dev, "Timer%d is already running\n", id);
 		return -EBUSY;
 	}
-
 	init_timer(timer);
-	timer->data = (unsigned long) mvotg;
+	timer->data = (unsigned long)mvotg;
 	timer->function = callback;
 	timer->expires = jiffies + interval;
 	add_timer(timer);
@@ -159,7 +174,7 @@ static int mv_otg_reset(struct mv_otg *mvotg)
 	loops = 500;
 	while (readl(&mvotg->op_regs->usbcmd) & USBCMD_CTRL_RESET) {
 		if (loops == 0) {
-			dev_err(&mvotg->pdev->dev,
+			dev_err(&mvotg->dev->dev,
 				"Wait for RESET completed TIMEOUT\n");
 			return -ETIMEDOUT;
 		}
@@ -179,15 +194,15 @@ static void mv_otg_init_irq(struct mv_otg *mvotg)
 	u32 otgsc;
 
 	mvotg->irq_en = OTGSC_INTR_A_SESSION_VALID
-	    | OTGSC_INTR_A_VBUS_VALID;
+			| OTGSC_INTR_A_VBUS_VALID;
 	mvotg->irq_status = OTGSC_INTSTS_A_SESSION_VALID
-	    | OTGSC_INTSTS_A_VBUS_VALID;
+			| OTGSC_INTSTS_A_VBUS_VALID;
 
 	if (mvotg->pdata->vbus == NULL) {
 		mvotg->irq_en |= OTGSC_INTR_B_SESSION_VALID
-		    | OTGSC_INTR_B_SESSION_END;
+			| OTGSC_INTR_B_SESSION_END;
 		mvotg->irq_status |= OTGSC_INTSTS_B_SESSION_VALID
-		    | OTGSC_INTSTS_B_SESSION_END;
+			| OTGSC_INTSTS_B_SESSION_END;
 	}
 
 	if (mvotg->pdata->id == NULL) {
@@ -202,22 +217,20 @@ static void mv_otg_init_irq(struct mv_otg *mvotg)
 
 static void mv_otg_start_host(struct mv_otg *mvotg, int on)
 {
-#ifdef CONFIG_USB
 	struct usb_otg *otg = mvotg->phy.otg;
 	struct usb_hcd *hcd;
 
 	if (!otg->host)
 		return;
 
-	dev_info(&mvotg->pdev->dev, "%s host\n", on ? "start" : "stop");
-
 	hcd = bus_to_hcd(otg->host);
 
+	dev_info(&mvotg->dev->dev, "%s host\n", on ? "start" : "stop");
+
 	if (on)
 		usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
 	else
 		usb_remove_hcd(hcd);
-#endif /* CONFIG_USB */
 }
 
 static void mv_otg_start_periphrals(struct mv_otg *mvotg, int on)
@@ -258,13 +271,13 @@ static int mv_otg_enable_internal(struct mv_otg *mvotg)
 	if (mvotg->active)
 		return 0;
 
-	dev_dbg(&mvotg->pdev->dev, "otg enabled\n");
+	dev_dbg(&mvotg->dev->dev, "otg enabled\n");
 
 	otg_clock_enable(mvotg);
 	if (mvotg->pdata->phy_init) {
 		retval = mvotg->pdata->phy_init(mvotg->phy_regs);
 		if (retval) {
-			dev_err(&mvotg->pdev->dev,
+			dev_err(&mvotg->dev->dev,
 				"init phy error %d\n", retval);
 			otg_clock_disable(mvotg);
 			return retval;
@@ -278,16 +291,18 @@ static int mv_otg_enable_internal(struct mv_otg *mvotg)
 
 static int mv_otg_enable(struct mv_otg *mvotg)
 {
+#ifdef CONFIG_PXA95x
+	dvfm_disable_lowpower(dvfm_dev_idx);
+#endif
 	if (mvotg->clock_gating)
 		return mv_otg_enable_internal(mvotg);
-
 	return 0;
 }
 
 static void mv_otg_disable_internal(struct mv_otg *mvotg)
 {
 	if (mvotg->active) {
-		dev_dbg(&mvotg->pdev->dev, "otg disabled\n");
+		dev_dbg(&mvotg->dev->dev, "otg disabled\n");
 		if (mvotg->pdata->phy_deinit)
 			mvotg->pdata->phy_deinit(mvotg->phy_regs);
 		otg_clock_disable(mvotg);
@@ -299,6 +314,10 @@ static void mv_otg_disable(struct mv_otg *mvotg)
 {
 	if (mvotg->clock_gating)
 		mv_otg_disable_internal(mvotg);
+
+#ifdef CONFIG_PXA95x
+	dvfm_enable_lowpower(dvfm_dev_idx);
+#endif
 }
 
 static void mv_otg_update_inputs(struct mv_otg *mvotg)
@@ -328,23 +347,27 @@ static void mv_otg_update_inputs(struct mv_otg *mvotg)
 
 	if (mvotg->pdata->otg_force_a_bus_req && !otg_ctrl->id)
 		otg_ctrl->a_bus_req = 1;
+	if (otg_force_host_mode) {
+		otg_ctrl->id = 0;
+		otg_ctrl->a_bus_req = 1;
+	}
 
 	otg_ctrl->a_sess_vld = !!(otgsc & OTGSC_STS_A_SESSION_VALID);
 	otg_ctrl->a_vbus_vld = !!(otgsc & OTGSC_STS_A_VBUS_VALID);
 
-	dev_dbg(&mvotg->pdev->dev, "%s: ", __func__);
-	dev_dbg(&mvotg->pdev->dev, "id %d\n", otg_ctrl->id);
-	dev_dbg(&mvotg->pdev->dev, "b_sess_vld %d\n", otg_ctrl->b_sess_vld);
-	dev_dbg(&mvotg->pdev->dev, "b_sess_end %d\n", otg_ctrl->b_sess_end);
-	dev_dbg(&mvotg->pdev->dev, "a_vbus_vld %d\n", otg_ctrl->a_vbus_vld);
-	dev_dbg(&mvotg->pdev->dev, "a_sess_vld %d\n", otg_ctrl->a_sess_vld);
+	dev_dbg(&mvotg->dev->dev, "%s: ", __func__);
+	dev_dbg(&mvotg->dev->dev, "id %d\n", otg_ctrl->id);
+	dev_dbg(&mvotg->dev->dev, "b_sess_vld %d\n", otg_ctrl->b_sess_vld);
+	dev_dbg(&mvotg->dev->dev, "b_sess_end %d\n", otg_ctrl->b_sess_end);
+	dev_dbg(&mvotg->dev->dev, "a_vbus_vld %d\n", otg_ctrl->a_vbus_vld);
+	dev_dbg(&mvotg->dev->dev, "a_sess_vld %d\n", otg_ctrl->a_sess_vld);
 }
 
 static void mv_otg_update_state(struct mv_otg *mvotg)
 {
-	struct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;
 	struct usb_phy *phy = &mvotg->phy;
 	int old_state = phy->state;
+	struct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;
 
 	switch (old_state) {
 	case OTG_STATE_UNDEFINED:
@@ -364,7 +387,7 @@ static void mv_otg_update_state(struct mv_otg *mvotg)
 		if (otg_ctrl->id)
 			phy->state = OTG_STATE_B_IDLE;
 		else if (!(otg_ctrl->a_bus_drop) &&
-			 (otg_ctrl->a_bus_req || otg_ctrl->a_srp_det))
+				(otg_ctrl->a_bus_req || otg_ctrl->a_srp_det))
 			phy->state = OTG_STATE_A_WAIT_VRISE;
 		break;
 	case OTG_STATE_A_WAIT_VRISE:
@@ -373,7 +396,7 @@ static void mv_otg_update_state(struct mv_otg *mvotg)
 		break;
 	case OTG_STATE_A_WAIT_BCON:
 		if (otg_ctrl->id || otg_ctrl->a_bus_drop
-		    || otg_ctrl->a_wait_bcon_timeout) {
+			|| otg_ctrl->a_wait_bcon_timeout) {
 			mv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);
 			mvotg->otg_ctrl.a_wait_bcon_timeout = 0;
 			phy->state = OTG_STATE_A_WAIT_VFALL;
@@ -389,21 +412,19 @@ static void mv_otg_update_state(struct mv_otg *mvotg)
 		}
 		break;
 	case OTG_STATE_A_HOST:
-		if (otg_ctrl->id || !otg_ctrl->b_conn
-		    || otg_ctrl->a_bus_drop)
+		if (otg_ctrl->id || !otg_ctrl->b_conn || otg_ctrl->a_bus_drop)
 			phy->state = OTG_STATE_A_WAIT_BCON;
 		else if (!otg_ctrl->a_vbus_vld)
 			phy->state = OTG_STATE_A_VBUS_ERR;
 		break;
 	case OTG_STATE_A_WAIT_VFALL:
-		if (otg_ctrl->id
-		    || (!otg_ctrl->b_conn && otg_ctrl->a_sess_vld)
-		    || otg_ctrl->a_bus_req)
+		if (otg_ctrl->id || (!otg_ctrl->b_conn && otg_ctrl->a_sess_vld)
+			|| otg_ctrl->a_bus_req)
 			phy->state = OTG_STATE_A_IDLE;
 		break;
 	case OTG_STATE_A_VBUS_ERR:
 		if (otg_ctrl->id || otg_ctrl->a_clr_err
-		    || otg_ctrl->a_bus_drop) {
+			|| otg_ctrl->a_bus_drop) {
 			otg_ctrl->a_clr_err = 0;
 			phy->state = OTG_STATE_A_WAIT_VFALL;
 		}
@@ -422,8 +443,10 @@ static void mv_otg_work(struct work_struct *work)
 
 	mvotg = container_of((struct delayed_work *)work, struct mv_otg, work);
 
+	BUG_ON(mvotg != the_transceiver);
+
 run:
-	/* work queue is single thread, or we need spin_lock to protect */
+	/* work queue is single thread, or we need spin_lock to protect*/
 	phy = &mvotg->phy;
 	otg = phy->otg;
 	old_state = phy->state;
@@ -435,9 +458,8 @@ run:
 	mv_otg_update_state(mvotg);
 
 	if (old_state != phy->state) {
-		dev_info(&mvotg->pdev->dev, "change from state %s to %s\n",
-			 state_string[old_state],
-			 state_string[phy->state]);
+		dev_info(&mvotg->dev->dev, "change from state %s to %s\n",
+			state_string[old_state], state_string[phy->state]);
 
 		switch (phy->state) {
 		case OTG_STATE_B_IDLE:
@@ -465,8 +487,7 @@ run:
 			if (old_state != OTG_STATE_A_HOST)
 				mv_otg_start_host(mvotg, 1);
 			mv_otg_set_timer(mvotg, A_WAIT_BCON_TIMER,
-					 T_A_WAIT_BCON,
-					 mv_otg_timer_await_bcon);
+				T_A_WAIT_BCON, mv_otg_timer_await_bcon);
 			/*
 			 * Now, we directly enter A_HOST. So set b_conn = 1
 			 * here. In fact, it need host driver to notify us.
@@ -494,19 +515,19 @@ run:
 
 static irqreturn_t mv_otg_irq(int irq, void *dev)
 {
-	struct mv_otg *mvotg = dev;
 	u32 otgsc;
+	struct mv_otg *mvotg = dev;
 
 	otgsc = readl(&mvotg->op_regs->otgsc);
 	writel(otgsc, &mvotg->op_regs->otgsc);
 
 	/*
-	 * if we have vbus, then the vbus detection for B-device
-	 * will be done by mv_otg_inputs_irq().
-	 */
+	* if we have vbus, then the vbus detection for B-device
+	* will be done by mv_otg_inputs_irq().
+	*/
 	if (mvotg->pdata->vbus)
-		if ((otgsc & OTGSC_STS_USB_ID) &&
-		    !(otgsc & OTGSC_INTSTS_USB_ID))
+		if ((otgsc & OTGSC_STS_USB_ID)
+			&& !(otgsc & OTGSC_INTSTS_USB_ID))
 			return IRQ_NONE;
 
 	if ((otgsc & mvotg->irq_status) == 0)
@@ -536,22 +557,25 @@ static ssize_t
 get_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct mv_otg *mvotg = dev_get_drvdata(dev);
-	return scnprintf(buf, PAGE_SIZE, "%d\n",
-			 mvotg->otg_ctrl.a_bus_req);
+	BUG_ON(mvotg != the_transceiver);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", mvotg->otg_ctrl.a_bus_req);
 }
 
 static ssize_t
 set_a_bus_req(struct device *dev, struct device_attribute *attr,
-	      const char *buf, size_t count)
+		const char *buf, size_t count)
 {
 	struct mv_otg *mvotg = dev_get_drvdata(dev);
 
+	BUG_ON(mvotg != the_transceiver);
+
 	if (count > 2)
 		return -1;
 
 	/* We will use this interface to change to A device */
 	if (mvotg->phy.state != OTG_STATE_B_IDLE
-	    && mvotg->phy.state != OTG_STATE_A_IDLE)
+		&& mvotg->phy.state != OTG_STATE_A_IDLE)
 		return -1;
 
 	/* The clock may disabled and we need to set irq for ID detected */
@@ -561,8 +585,7 @@ set_a_bus_req(struct device *dev, struct device_attribute *attr,
 	if (buf[0] == '1') {
 		mvotg->otg_ctrl.a_bus_req = 1;
 		mvotg->otg_ctrl.a_bus_drop = 0;
-		dev_dbg(&mvotg->pdev->dev,
-			"User request: a_bus_req = 1\n");
+		dev_dbg(&mvotg->dev->dev, "User request: a_bus_req = 1\n");
 
 		if (spin_trylock(&mvotg->wq_lock)) {
 			mv_otg_run_state_machine(mvotg, 0);
@@ -572,85 +595,115 @@ set_a_bus_req(struct device *dev, struct device_attribute *attr,
 
 	return count;
 }
-
-static DEVICE_ATTR(a_bus_req, S_IRUGO | S_IWUSR, get_a_bus_req,
-		   set_a_bus_req);
+static DEVICE_ATTR(a_bus_req, S_IRUGO | S_IWUSR, get_a_bus_req, set_a_bus_req);
 
 static ssize_t
 set_a_clr_err(struct device *dev, struct device_attribute *attr,
-	      const char *buf, size_t count)
+		const char *buf, size_t count)
 {
 	struct mv_otg *mvotg = dev_get_drvdata(dev);
+
+	BUG_ON(mvotg != the_transceiver);
+
 	if (!mvotg->phy.otg->default_a)
 		return -1;
-
 	if (count > 2)
 		return -1;
 
 	if (buf[0] == '1') {
 		mvotg->otg_ctrl.a_clr_err = 1;
-		dev_dbg(&mvotg->pdev->dev,
-			"User request: a_clr_err = 1\n");
+		dev_dbg(&mvotg->dev->dev, "User request: a_clr_err = 1\n");
 	}
-
 	if (spin_trylock(&mvotg->wq_lock)) {
 		mv_otg_run_state_machine(mvotg, 0);
 		spin_unlock(&mvotg->wq_lock);
 	}
-
 	return count;
 }
-
 static DEVICE_ATTR(a_clr_err, S_IWUSR, NULL, set_a_clr_err);
 
 static ssize_t
-get_a_bus_drop(struct device *dev, struct device_attribute *attr,
-	       char *buf)
+get_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct mv_otg *mvotg = dev_get_drvdata(dev);
-	return scnprintf(buf, PAGE_SIZE, "%d\n",
-			 mvotg->otg_ctrl.a_bus_drop);
+	BUG_ON(mvotg != the_transceiver);
+
+	return scnprintf(buf, PAGE_SIZE, "%d\n", mvotg->otg_ctrl.a_bus_drop);
 }
 
 static ssize_t
 set_a_bus_drop(struct device *dev, struct device_attribute *attr,
-	       const char *buf, size_t count)
+		const char *buf, size_t count)
 {
 	struct mv_otg *mvotg = dev_get_drvdata(dev);
+
+	BUG_ON(mvotg != the_transceiver);
+
 	if (!mvotg->phy.otg->default_a)
 		return -1;
-
 	if (count > 2)
 		return -1;
 
 	if (buf[0] == '0') {
 		mvotg->otg_ctrl.a_bus_drop = 0;
-		dev_dbg(&mvotg->pdev->dev,
-			"User request: a_bus_drop = 0\n");
+		dev_dbg(&mvotg->dev->dev, "User request: a_bus_drop = 0\n");
 	} else if (buf[0] == '1') {
 		mvotg->otg_ctrl.a_bus_drop = 1;
 		mvotg->otg_ctrl.a_bus_req = 0;
-		dev_dbg(&mvotg->pdev->dev,
-			"User request: a_bus_drop = 1\n");
-		dev_dbg(&mvotg->pdev->dev,
-			"User request: and a_bus_req = 0\n");
+		dev_dbg(&mvotg->dev->dev, "User request: a_bus_drop = 1\n");
+		dev_dbg(&mvotg->dev->dev, "User request: and a_bus_req = 0\n");
 	}
-
 	if (spin_trylock(&mvotg->wq_lock)) {
 		mv_otg_run_state_machine(mvotg, 0);
 		spin_unlock(&mvotg->wq_lock);
 	}
-
 	return count;
 }
-
 static DEVICE_ATTR(a_bus_drop, S_IRUGO | S_IWUSR,
-		   get_a_bus_drop, set_a_bus_drop);
+			get_a_bus_drop, set_a_bus_drop);
+
+static ssize_t
+get_otg_mode(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char *state = otg_force_host_mode ? "host" : "client";
+	return sprintf(buf, "OTG mode: %s\n", state);
+}
+
+static ssize_t
+set_otg_mode(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct mv_otg *mvotg = dev_get_drvdata(dev);
+	char *usage = "Usage: $echo host/client to switch otg mode";
+	char buff[16], *b;
+
+	BUG_ON(mvotg != the_transceiver);
+	strncpy(buff, buf, sizeof(buff));
+	b = strim(buff);
+	pr_info("OTG state is %s\n", state_string[mvotg->phy.state]);
+	if (!strcmp(b, "host")) {
+		if (mvotg->phy.state == OTG_STATE_B_PERIPHERAL) {
+			pr_err("Failed to swich mode, pls don't connect to PC!\n");
+			return count;
+		}
+		otg_force_host_mode = 1;
+	} else if (!strcmp(b, "client")) {
+		otg_force_host_mode = 0;
+	} else {
+		pr_err("%s\n", usage);
+		return count;
+	}
+	mv_otg_run_state_machine(mvotg, 0);
+
+	return count;
+}
+static DEVICE_ATTR(otg_mode, S_IRUGO | S_IWUSR, get_otg_mode, set_otg_mode);
 
 static struct attribute *inputs_attrs[] = {
 	&dev_attr_a_bus_req.attr,
 	&dev_attr_a_clr_err.attr,
 	&dev_attr_a_bus_drop.attr,
+	&dev_attr_otg_mode.attr,
 	NULL,
 };
 
@@ -659,65 +712,73 @@ static struct attribute_group inputs_attr_group = {
 	.attrs = inputs_attrs,
 };
 
-int mv_otg_remove(struct platform_device *pdev)
+int mv_otg_remove(struct platform_device *dev)
 {
-	struct mv_otg *mvotg = platform_get_drvdata(pdev);
+	struct mv_otg *mvotg = platform_get_drvdata(dev);
 	int clk_i;
 
-	sysfs_remove_group(&mvotg->pdev->dev.kobj, &inputs_attr_group);
+	BUG_ON(mvotg != the_transceiver);
 
-	if (mvotg->irq)
-		free_irq(mvotg->irq, mvotg);
-
-	if (mvotg->pdata->vbus)
+	if (mvotg->clock_gating) {
 		free_irq(mvotg->pdata->vbus->irq, mvotg);
-	if (mvotg->pdata->id)
 		free_irq(mvotg->pdata->id->irq, mvotg);
+	}
 
 	if (mvotg->qwork) {
 		flush_workqueue(mvotg->qwork);
 		destroy_workqueue(mvotg->qwork);
 	}
 
+	sysfs_remove_group(&mvotg->dev->dev.kobj, &inputs_attr_group);
+
+	if (mvotg->irq)
+		free_irq(mvotg->irq, mvotg);
+
 	mv_otg_disable(mvotg);
 
 	if (mvotg->cap_regs)
 		iounmap(mvotg->cap_regs);
 
 	if (mvotg->phy_regs)
-		iounmap(mvotg->phy_regs);
+		iounmap((void *)mvotg->phy_regs);
 
 	for (clk_i = 0; clk_i <= mvotg->clknum; clk_i++)
 		clk_put(mvotg->clk[clk_i]);
 
 	usb_set_transceiver(NULL);
-	platform_set_drvdata(pdev, NULL);
+	platform_set_drvdata(dev, NULL);
 
 	kfree(mvotg->phy.otg);
 	kfree(mvotg);
+	the_transceiver = NULL;
 
 	return 0;
 }
 
-static int mv_otg_probe(struct platform_device *pdev)
+static int mv_otg_probe(struct platform_device *dev)
 {
-	struct mv_usb_platform_data *pdata = pdev->dev.platform_data;
 	struct mv_otg *mvotg;
 	struct usb_otg *otg;
-	struct resource *r;
+	struct mv_usb_platform_data *pdata = dev->dev.platform_data;
 	int retval = 0, clk_i, i;
+	struct resource *r;
 	size_t size;
 
+	if (the_transceiver)
+		return 0;
+
 	if (pdata == NULL) {
-		dev_err(&pdev->dev, "failed to get platform data\n");
-		return -ENODEV;
+		dev_err(&dev->dev, "failed to get platform data\n");
+		retval = -ENODEV;
+		goto err_pdata;
 	}
 
 	size = sizeof(*mvotg) + sizeof(struct clk *) * pdata->clknum;
 	mvotg = kzalloc(size, GFP_KERNEL);
 	if (!mvotg) {
-		dev_err(&pdev->dev, "failed to allocate memory!\n");
-		return -ENOMEM;
+		dev_err(&dev->dev, "failed to allocate memory!\n");
+		retval = -ENOMEM;
+		goto err_alloc_private;
 	}
 
 	otg = kzalloc(sizeof *otg, GFP_KERNEL);
@@ -725,33 +786,31 @@ static int mv_otg_probe(struct platform_device *pdev)
 		kfree(mvotg);
 		return -ENOMEM;
 	}
+	the_transceiver = mvotg;
+	platform_set_drvdata(dev, mvotg);
 
-	platform_set_drvdata(pdev, mvotg);
-
-	mvotg->pdev = pdev;
+	mvotg->dev = dev;
 	mvotg->pdata = pdata;
 
 	mvotg->clknum = pdata->clknum;
 	for (clk_i = 0; clk_i < mvotg->clknum; clk_i++) {
-		mvotg->clk[clk_i] = clk_get(&pdev->dev, pdata->clkname[clk_i]);
+		mvotg->clk[clk_i] = clk_get(&dev->dev, pdata->clkname[clk_i]);
 		if (IS_ERR(mvotg->clk[clk_i])) {
 			retval = PTR_ERR(mvotg->clk[clk_i]);
-			goto err_put_clk;
+			goto err_get_clk;
 		}
 	}
 
 	mvotg->qwork = create_singlethread_workqueue("mv_otg_queue");
 	if (!mvotg->qwork) {
-		dev_dbg(&pdev->dev, "cannot create workqueue for OTG\n");
+		dev_dbg(&dev->dev, "cannot create workqueue for OTG\n");
 		retval = -ENOMEM;
-		goto err_put_clk;
+		goto err_qwork;
 	}
-
 	INIT_DELAYED_WORK(&mvotg->work, mv_otg_work);
 
 	/* OTG common part */
-	mvotg->pdev = pdev;
-	mvotg->phy.dev = &pdev->dev;
+	mvotg->phy.dev = &dev->dev;
 	mvotg->phy.otg = otg;
 	mvotg->phy.label = driver_name;
 	mvotg->phy.state = OTG_STATE_UNDEFINED;
@@ -761,213 +820,220 @@ static int mv_otg_probe(struct platform_device *pdev)
 	otg->set_peripheral = mv_otg_set_peripheral;
 	otg->set_vbus = mv_otg_set_vbus;
 
-	for (i = 0; i < OTG_TIMER_NUM; i++)
-		init_timer(&mvotg->otg_ctrl.timer[i]);
-
-	r = platform_get_resource_byname(mvotg->pdev,
-					 IORESOURCE_MEM, "phyregs");
+	r = platform_get_resource_byname(mvotg->dev, IORESOURCE_MEM, "capregs");
 	if (r == NULL) {
-		dev_err(&pdev->dev, "no phy I/O memory resource defined\n");
+		dev_err(&dev->dev, "no I/O memory resource defined\n");
 		retval = -ENODEV;
-		goto err_destroy_workqueue;
+		goto err_get_cap_regs;
 	}
 
-	mvotg->phy_regs = ioremap(r->start, resource_size(r));
-	if (mvotg->phy_regs == NULL) {
-		dev_err(&pdev->dev, "failed to map phy I/O memory\n");
-		retval = -EFAULT;
-		goto err_destroy_workqueue;
+	mvotg->cap_regs = (struct mv_cap_regs __iomem *)
+		ioremap(r->start, resource_size(r));
+	if (mvotg->cap_regs == NULL) {
+		dev_err(&dev->dev, "failed to map I/O memory\n");
+		retval = -EBUSY;
+		goto err_map_cap_regs;
 	}
 
-	r = platform_get_resource_byname(mvotg->pdev,
-					 IORESOURCE_MEM, "capregs");
+	r = platform_get_resource_byname(mvotg->dev, IORESOURCE_MEM, "phyregs");
 	if (r == NULL) {
-		dev_err(&pdev->dev, "no I/O memory resource defined\n");
+		dev_err(&dev->dev, "no phy I/O memory resource defined\n");
 		retval = -ENODEV;
-		goto err_unmap_phyreg;
+		goto err_get_phy_regs;
 	}
 
-	mvotg->cap_regs = ioremap(r->start, resource_size(r));
-	if (mvotg->cap_regs == NULL) {
-		dev_err(&pdev->dev, "failed to map I/O memory\n");
-		retval = -EFAULT;
-		goto err_unmap_phyreg;
+	mvotg->phy_regs = (unsigned int)ioremap(r->start, resource_size(r));
+	if (mvotg->phy_regs == 0) {
+		dev_err(&dev->dev, "failed to map phy I/O memory\n");
+		retval = -EBUSY;
+		goto err_map_phy_regs;
 	}
 
 	/* we will acces controller register, so enable the udc controller */
 	retval = mv_otg_enable_internal(mvotg);
 	if (retval) {
-		dev_err(&pdev->dev, "mv otg enable error %d\n", retval);
-		goto err_unmap_capreg;
-	}
-
-	mvotg->op_regs =
-		(struct mv_otg_regs __iomem *) ((unsigned long) mvotg->cap_regs
-			+ (readl(mvotg->cap_regs) & CAPLENGTH_MASK));
-
-	if (pdata->id) {
-		retval = request_threaded_irq(pdata->id->irq, NULL,
-					      mv_otg_inputs_irq,
-					      IRQF_ONESHOT, "id", mvotg);
-		if (retval) {
-			dev_info(&pdev->dev,
-				 "Failed to request irq for ID\n");
-			pdata->id = NULL;
-		}
-	}
-
-	if (pdata->vbus) {
-		mvotg->clock_gating = 1;
-		retval = request_threaded_irq(pdata->vbus->irq, NULL,
-					      mv_otg_inputs_irq,
-					      IRQF_ONESHOT, "vbus", mvotg);
-		if (retval) {
-			dev_info(&pdev->dev,
-				 "Failed to request irq for VBUS, "
-				 "disable clock gating\n");
-			mvotg->clock_gating = 0;
-			pdata->vbus = NULL;
-		}
+		dev_err(&dev->dev, "mv_otg_enable error %d\n", retval);
+		goto err_otg_enable;
 	}
 
-	if (pdata->disable_otg_clock_gating)
-		mvotg->clock_gating = 0;
+	mvotg->op_regs = (struct mv_op_regs __iomem *)((u32)mvotg->cap_regs
+		+ (readl(&mvotg->cap_regs->caplength_hciversion)
+			& CAPLENGTH_MASK));
 
 	mv_otg_reset(mvotg);
 	mv_otg_init_irq(mvotg);
 
-	r = platform_get_resource(mvotg->pdev, IORESOURCE_IRQ, 0);
+	r = platform_get_resource(mvotg->dev, IORESOURCE_IRQ, 0);
 	if (r == NULL) {
-		dev_err(&pdev->dev, "no IRQ resource defined\n");
+		dev_err(&dev->dev, "no IRQ resource defined\n");
 		retval = -ENODEV;
-		goto err_disable_clk;
+		goto err_get_irq;
 	}
-
 	mvotg->irq = r->start;
 	if (request_irq(mvotg->irq, mv_otg_irq, IRQF_SHARED,
 			driver_name, mvotg)) {
-		dev_err(&pdev->dev, "Request irq %d for OTG failed\n",
+		dev_err(&dev->dev, "Request irq %d for OTG failed\n",
 			mvotg->irq);
 		mvotg->irq = 0;
 		retval = -ENODEV;
-		goto err_disable_clk;
+		goto err_request_irq;
 	}
 
 	retval = usb_set_transceiver(&mvotg->phy);
 	if (retval < 0) {
-		dev_err(&pdev->dev, "can't register transceiver, %d\n",
-			retval);
-		goto err_free_irq;
+		dev_err(&dev->dev, "can't register transceiver, %d\n", retval);
+		goto err_set_transceiver;
 	}
 
-	retval = sysfs_create_group(&pdev->dev.kobj, &inputs_attr_group);
+	retval = sysfs_create_group(&dev->dev.kobj, &inputs_attr_group);
 	if (retval < 0) {
-		dev_dbg(&pdev->dev,
-			"Can't register sysfs attr group: %d\n", retval);
-		goto err_set_transceiver;
+		dev_dbg(&dev->dev, "Can't register sysfs attr group: %d\n",
+			retval);
+		goto err_create_sysfs;
+	}
+
+	for (i = 0; i < OTG_TIMER_NUM; i++)
+		init_timer(&mvotg->otg_ctrl.timer[i]);
+
+	if (pdata->id) {
+		retval = request_threaded_irq(pdata->id->irq, NULL,
+				mv_otg_inputs_irq, IRQF_ONESHOT, "id", mvotg);
+		if (retval) {
+			dev_info(&dev->dev,
+				"Can not request irq for ID\n");
+		}
+
+		if (pdata->id->init)
+			pdata->id->init();
+	}
+
+	if (pdata->vbus) {
+		mvotg->clock_gating = 1;
+		retval = request_threaded_irq(pdata->vbus->irq, NULL,
+						mv_otg_inputs_irq,
+						IRQF_ONESHOT, "vbus", mvotg);
+		if (retval) {
+			dev_info(&dev->dev,
+				"Can not request irq for VBUS, "
+				"disable clock gating\n");
+			mvotg->clock_gating = 0;
+		}
+
+		if (pdata->vbus->init)
+			pdata->vbus->init();
 	}
 
+	if (pdata->disable_otg_clock_gating)
+		mvotg->clock_gating = 0;
+
 	spin_lock_init(&mvotg->wq_lock);
 	if (spin_trylock(&mvotg->wq_lock)) {
-		mv_otg_run_state_machine(mvotg, 2 * HZ);
+		mv_otg_run_state_machine(mvotg, 2*HZ);
 		spin_unlock(&mvotg->wq_lock);
 	}
 
-	dev_info(&pdev->dev,
-		 "successful probe OTG device %s clock gating.\n",
-		 mvotg->clock_gating ? "with" : "without");
+	dev_info(&dev->dev, "successful probe OTG device %s clock gating.\n",
+		mvotg->clock_gating ? "with" : "without");
 
 	return 0;
 
-err_set_transceiver:
+err_create_sysfs:
 	usb_set_transceiver(NULL);
-err_free_irq:
+err_set_transceiver:
 	free_irq(mvotg->irq, mvotg);
-err_disable_clk:
-	if (pdata->vbus)
-		free_irq(pdata->vbus->irq, mvotg);
-	if (pdata->id)
-		free_irq(pdata->id->irq, mvotg);
+err_request_irq:
+err_get_irq:
 	mv_otg_disable_internal(mvotg);
-err_unmap_capreg:
+err_otg_enable:
+	iounmap((void *)mvotg->phy_regs);
+err_map_phy_regs:
+err_get_phy_regs:
 	iounmap(mvotg->cap_regs);
-err_unmap_phyreg:
-	iounmap(mvotg->phy_regs);
-err_destroy_workqueue:
+err_map_cap_regs:
+err_get_cap_regs:
 	flush_workqueue(mvotg->qwork);
 	destroy_workqueue(mvotg->qwork);
-err_put_clk:
+err_qwork:
+err_get_clk:
 	for (clk_i--; clk_i >= 0; clk_i--)
 		clk_put(mvotg->clk[clk_i]);
-
-	platform_set_drvdata(pdev, NULL);
-	kfree(otg);
+	the_transceiver = NULL;
+	platform_set_drvdata(dev, NULL);
 	kfree(mvotg);
-
+err_alloc_private:
+err_pdata:
 	return retval;
 }
 
 #ifdef CONFIG_PM
-static int mv_otg_suspend(struct platform_device *pdev, pm_message_t state)
+static int mv_otg_suspend(struct platform_device *dev, pm_message_t state)
 {
-	struct mv_otg *mvotg = platform_get_drvdata(pdev);
+	struct mv_otg *mvotg = platform_get_drvdata(dev);
 
 	if (mvotg->phy.state != OTG_STATE_B_IDLE) {
-		dev_info(&pdev->dev,
-			 "OTG state is not B_IDLE, it is %d!\n",
-			 mvotg->phy.state);
+		dev_info(&dev->dev, "OTG state is not B_IDLE, it is %d!\n",
+			mvotg->phy.state);
 		return -EAGAIN;
 	}
 
 	if (!mvotg->clock_gating)
 		mv_otg_disable_internal(mvotg);
 
+	mvotg->phy.state = OTG_STATE_UNDEFINED;
+
 	return 0;
 }
 
-static int mv_otg_resume(struct platform_device *pdev)
+static int mv_otg_resume(struct platform_device *dev)
 {
-	struct mv_otg *mvotg = platform_get_drvdata(pdev);
+	struct mv_otg *mvotg = platform_get_drvdata(dev);
 	u32 otgsc;
 
-	if (!mvotg->clock_gating) {
-		mv_otg_enable_internal(mvotg);
+	mv_otg_enable_internal(mvotg);
 
-		otgsc = readl(&mvotg->op_regs->otgsc);
-		otgsc |= mvotg->irq_en;
-		writel(otgsc, &mvotg->op_regs->otgsc);
+	otgsc = readl(&mvotg->op_regs->otgsc);
+	otgsc |= mvotg->irq_en;
+	writel(otgsc, &mvotg->op_regs->otgsc);
 
-		if (spin_trylock(&mvotg->wq_lock)) {
-			mv_otg_run_state_machine(mvotg, 0);
-			spin_unlock(&mvotg->wq_lock);
-		}
+	if (spin_trylock(&mvotg->wq_lock)) {
+		mv_otg_run_state_machine(mvotg, 0);
+		spin_unlock(&mvotg->wq_lock);
 	}
+
 	return 0;
 }
+
 #endif
 
 static struct platform_driver mv_otg_driver = {
-	.probe = mv_otg_probe,
-	.remove = __exit_p(mv_otg_remove),
-	.driver = {
-		   .owner = THIS_MODULE,
-		   .name = driver_name,
-		   },
+	.probe		= mv_otg_probe,
+	.remove		= __exit_p(mv_otg_remove),
+	.driver         = {
+		.owner	= THIS_MODULE,
+		.name   = "pxa-otg",
+	},
 #ifdef CONFIG_PM
-	.suspend = mv_otg_suspend,
-	.resume = mv_otg_resume,
+	.suspend	= mv_otg_suspend,
+	.resume		= mv_otg_resume,
 #endif
 };
 
 static int __init mv_otg_init(void)
 {
+#ifdef CONFIG_PXA95x
+	dvfm_register("MV_OTG", &dvfm_dev_idx);
+#endif
 	return platform_driver_register(&mv_otg_driver);
 }
 
 static void __exit mv_otg_exit(void)
 {
+#ifdef CONFIG_PXA95x
+	dvfm_unregister("MV_OTG", &dvfm_dev_idx);
+#endif
 	platform_driver_unregister(&mv_otg_driver);
 }
 
 module_init(mv_otg_init);
 module_exit(mv_otg_exit);
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/otg/mv_otg.h b/drivers/usb/otg/mv_otg.h
index 8a9e351..51e2626 100644
--- a/drivers/usb/otg/mv_otg.h
+++ b/drivers/usb/otg/mv_otg.h
@@ -12,39 +12,6 @@
 
 #include <linux/types.h>
 
-/* Command Register Bit Masks */
-#define USBCMD_RUN_STOP			(0x00000001)
-#define USBCMD_CTRL_RESET		(0x00000002)
-
-/* otgsc Register Bit Masks */
-#define OTGSC_CTRL_VUSB_DISCHARGE		0x00000001
-#define OTGSC_CTRL_VUSB_CHARGE			0x00000002
-#define OTGSC_CTRL_OTG_TERM			0x00000008
-#define OTGSC_CTRL_DATA_PULSING			0x00000010
-#define OTGSC_STS_USB_ID			0x00000100
-#define OTGSC_STS_A_VBUS_VALID			0x00000200
-#define OTGSC_STS_A_SESSION_VALID		0x00000400
-#define OTGSC_STS_B_SESSION_VALID		0x00000800
-#define OTGSC_STS_B_SESSION_END			0x00001000
-#define OTGSC_STS_1MS_TOGGLE			0x00002000
-#define OTGSC_STS_DATA_PULSING			0x00004000
-#define OTGSC_INTSTS_USB_ID			0x00010000
-#define OTGSC_INTSTS_A_VBUS_VALID		0x00020000
-#define OTGSC_INTSTS_A_SESSION_VALID		0x00040000
-#define OTGSC_INTSTS_B_SESSION_VALID		0x00080000
-#define OTGSC_INTSTS_B_SESSION_END		0x00100000
-#define OTGSC_INTSTS_1MS			0x00200000
-#define OTGSC_INTSTS_DATA_PULSING		0x00400000
-#define OTGSC_INTR_USB_ID			0x01000000
-#define OTGSC_INTR_A_VBUS_VALID			0x02000000
-#define OTGSC_INTR_A_SESSION_VALID		0x04000000
-#define OTGSC_INTR_B_SESSION_VALID		0x08000000
-#define OTGSC_INTR_B_SESSION_END		0x10000000
-#define OTGSC_INTR_1MS_TIMER			0x20000000
-#define OTGSC_INTR_DATA_PULSING			0x40000000
-
-#define CAPLENGTH_MASK		(0xff)
-
 /* Timer's interval, unit 10ms */
 #define T_A_WAIT_VRISE		100
 #define T_A_WAIT_BCON		2000
@@ -70,96 +37,66 @@ enum mv_otg_timer {
 
 /* PXA OTG state machine */
 struct mv_otg_ctrl {
-	/* internal variables */
-	u8 a_set_b_hnp_en;	/* A-Device set b_hnp_en */
-	u8 b_srp_done;
-	u8 b_hnp_en;
-
-	/* OTG inputs */
-	u8 a_bus_drop;
-	u8 a_bus_req;
-	u8 a_clr_err;
-	u8 a_bus_resume;
-	u8 a_bus_suspend;
-	u8 a_conn;
-	u8 a_sess_vld;
-	u8 a_srp_det;
-	u8 a_vbus_vld;
-	u8 b_bus_req;		/* B-Device Require Bus */
-	u8 b_bus_resume;
-	u8 b_bus_suspend;
-	u8 b_conn;
-	u8 b_se0_srp;
-	u8 b_sess_end;
-	u8 b_sess_vld;
-	u8 id;
-	u8 a_suspend_req;
-
-	/*Timer event */
-	u8 a_aidl_bdis_timeout;
-	u8 b_ase0_brst_timeout;
-	u8 a_bidl_adis_timeout;
-	u8 a_wait_bcon_timeout;
-
-	struct timer_list timer[OTG_TIMER_NUM];
-};
-
-#define VUSBHS_MAX_PORTS	8
-
-struct mv_otg_regs {
-	u32 usbcmd;		/* Command register */
-	u32 usbsts;		/* Status register */
-	u32 usbintr;		/* Interrupt enable */
-	u32 frindex;		/* Frame index */
-	u32 reserved1[1];
-	u32 deviceaddr;		/* Device Address */
-	u32 eplistaddr;		/* Endpoint List Address */
-	u32 ttctrl;		/* HOST TT status and control */
-	u32 burstsize;		/* Programmable Burst Size */
-	u32 txfilltuning;	/* Host Transmit Pre-Buffer Packet Tuning */
-	u32 reserved[4];
-	u32 epnak;		/* Endpoint NAK */
-	u32 epnaken;		/* Endpoint NAK Enable */
-	u32 configflag;		/* Configured Flag register */
-	u32 portsc[VUSBHS_MAX_PORTS];	/* Port Status/Control x, x = 1..8 */
-	u32 otgsc;
-	u32 usbmode;		/* USB Host/Device mode */
-	u32 epsetupstat;	/* Endpoint Setup Status */
-	u32 epprime;		/* Endpoint Initialize */
-	u32 epflush;		/* Endpoint De-initialize */
-	u32 epstatus;		/* Endpoint Status */
-	u32 epcomplete;		/* Endpoint Interrupt On Complete */
-	u32 epctrlx[16];	/* Endpoint Control, where x = 0.. 15 */
-	u32 mcr;		/* Mux Control */
-	u32 isr;		/* Interrupt Status */
-	u32 ier;		/* Interrupt Enable */
+	/* internal variables*/
+	u8	a_set_b_hnp_en;	   /* A-Device set b_hnp_en */
+	u8	b_srp_done;
+	u8	b_hnp_en;
+
+	/* OTG inputs*/
+	u8	a_bus_drop;
+	u8	a_bus_req;
+	u8	a_clr_err;
+	u8	a_bus_resume;
+	u8	a_bus_suspend;
+	u8	a_conn;
+	u8	a_sess_vld;
+	u8	a_srp_det;
+	u8	a_vbus_vld;
+	u8	b_bus_req;	/* B-Device Require Bus */
+	u8	b_bus_resume;
+	u8	b_bus_suspend;
+	u8	b_conn;
+	u8	b_se0_srp;
+	u8	b_sess_end;
+	u8	b_sess_vld;
+	u8	id;
+	u8	a_suspend_req;
+
+	/*Timer event*/
+	u8	a_aidl_bdis_timeout;
+	u8	b_ase0_brst_timeout;
+	u8	a_bidl_adis_timeout;
+	u8	a_wait_bcon_timeout;
+
+	struct timer_list	timer[OTG_TIMER_NUM];
 };
 
 struct mv_otg {
 	struct usb_phy phy;
-	struct mv_otg_ctrl otg_ctrl;
+	struct mv_otg_ctrl		otg_ctrl;
 
 	/* base address */
-	void __iomem *phy_regs;
-	void __iomem *cap_regs;
-	struct mv_otg_regs __iomem *op_regs;
+	struct mv_cap_regs __iomem	*cap_regs;
+	struct mv_op_regs __iomem	*op_regs;
+	unsigned int			phy_regs;
+
+	struct platform_device		*dev;
+	int				irq;
 
-	struct platform_device *pdev;
-	int irq;
-	u32 irq_status;
-	u32 irq_en;
+	u32				irq_status;
+	u32				irq_en;
 
-	struct delayed_work work;
-	struct workqueue_struct *qwork;
+	struct delayed_work		work;
+	struct workqueue_struct		*qwork;
 
-	spinlock_t wq_lock;
+	spinlock_t			wq_lock;
 
-	struct mv_usb_platform_data *pdata;
+	struct mv_usb_platform_data	*pdata;
 
-	unsigned int active;
-	unsigned int clock_gating;
-	unsigned int clknum;
-	struct clk *clk[0];
+	unsigned int			active;
+	unsigned int			clock_gating;
+	unsigned int			clknum;
+	struct clk			*clk[0];
 };
 
 #endif
-- 
1.7.5.4

