From 5be3bfe68bb36da0d5d43615d82ce4c0c395e04c Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 5 Sep 2013 14:05:05 +0800
Subject: [PATCH 52/60] arm: mmp3: mv_wtm get more data and clean-ups

These warnings are pretty clear for compiling warnings, so fix it.
And we can get more information from WTM, like SOC_stopping.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/devices.c |    4 ++--
 arch/arm/mach-mmp/mmp3.c    |   13 +++++++++----
 arch/arm/mach-mmp/mv_wtm.c  |   12 ++++++------
 arch/arm/mach-mmp/pm-mmp3.c |    2 +-
 arch/arm/mm/cache-l2x0.c    |    1 -
 arch/arm/plat-pxa/dvfs.c    |    8 +++++---
 6 files changed, 23 insertions(+), 17 deletions(-)

diff --git a/arch/arm/mach-mmp/devices.c b/arch/arm/mach-mmp/devices.c
index 33c238e..49a9cdb 100644
--- a/arch/arm/mach-mmp/devices.c
+++ b/arch/arm/mach-mmp/devices.c
@@ -713,10 +713,10 @@ int mmp3_ulpi_init(unsigned int base)
 
 int mmp3_fsic_phy_init(unsigned int base)
 {
-	pr_info("mmp3_fsic_phy_init !!!\n");
 	unsigned int otgphy;
-	u32 val;
 	otgphy = (unsigned int) ioremap(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+
+	pr_info("mmp3_fsic_phy_init !!!\n");
 	if (otgphy == 0) {
 		printk(KERN_ERR "%s: ioremap error\n", __func__);
 		return -ENOMEM;
diff --git a/arch/arm/mach-mmp/mmp3.c b/arch/arm/mach-mmp/mmp3.c
index dac9c6e..1dbb6e0 100644
--- a/arch/arm/mach-mmp/mmp3.c
+++ b/arch/arm/mach-mmp/mmp3.c
@@ -276,7 +276,7 @@ static void __init mmp3_init_pmua_regdump(void)
 	register_regdump_ops(&pmua_regdump_ops);
 }
 #else
-static void inline  __init mmp3_init_pmua_regdump() {}
+static void inline  __init mmp3_init_pmua_regdump(void) {}
 #endif
 
 void __init mmp3_init_irq(void)
@@ -1639,8 +1639,10 @@ int isppwr_power_control(int on)
 void gc_pwr(int power_on)
 {
 	unsigned long regval;
+
 	regval = __raw_readl(APMU_GC_CLK_RES_CTRL);
-	pr_err("apmu gc clk register value:%x !!!\n", regval);
+	pr_err("apmu gc clk register value:0x%lx !!!\n", regval);
+
 	if (power_on) {
 		//if (regval & (GC_PWRUP_MSK | GC_ISB))
 		if (regval &  GC_ISB)
@@ -1753,13 +1755,16 @@ static int __init panic_notifier(void)
 core_initcall(panic_notifier);
 #endif
 
-static int __init use_wtm_get_fuse_profile()
+static int __init use_wtm_get_fuse_profile(void)
 {
 	wtm_setup_remap();
-	wtm_read_profile();
+	wtm_init();
 	mdelay(10);
+	wtm_read_profile();
+	wtm_read_stepping();
 	mmp_plat_ref_clk = wtm_read_platform_config();
 	wtm_dump_info();
+	return 0;
 }
 
 core_initcall(use_wtm_get_fuse_profile);
diff --git a/arch/arm/mach-mmp/mv_wtm.c b/arch/arm/mach-mmp/mv_wtm.c
index ace4012..43a1089 100644
--- a/arch/arm/mach-mmp/mv_wtm.c
+++ b/arch/arm/mach-mmp/mv_wtm.c
@@ -175,7 +175,8 @@ void wtm_setup_remap(void)
 int wtm_read_platform_config(void)
 {
 	struct wtm_cmd cmd;
-	int status, i;
+	int status = -1;
+
 	memset(&cmd, 0, sizeof(cmd));
 
 	/* valid request */
@@ -215,7 +216,7 @@ int wtm_read_profile(void)
 	mv_profile	    = wtm_mb->cmd_status_1;
 	mv_max_freq	    = wtm_mb->cmd_status_2;
 	mv_ts_calibration = wtm_mb->cmd_status_3;
-
+	printk("QSEVEN board Profile 0x%x status is OK\n", mv_profile);
 out:
 	return status;
 }
@@ -223,9 +224,7 @@ void wtm_read_stepping(void)
 {
 	struct wtm_cmd cmd;
 	int status;
-
 	unsigned int chip_id;
-	unsigned int id;
 	unsigned int soc_stepping;
 
 	memset(&cmd, 0, sizeof(cmd));
@@ -239,8 +238,9 @@ void wtm_read_stepping(void)
 	}
 
 	soc_stepping = wtm_mb->cmd_status_0;
-/*	chip_id      = __raw_readl(0xd4282c00);
-	id           = read_cpuid(CPUID_ID);*/
+	chip_id      = __raw_readl(0xd4282c00);
+
+	printk("MMP3 Chip id 0x%x, SOC_step is 0x%x,  status is OK\n", chip_id, soc_stepping);
 	if ((chip_id & 0x00ff0000) == 0x00a00000) {
 
 		if (soc_stepping == 0x4130)
diff --git a/arch/arm/mach-mmp/pm-mmp3.c b/arch/arm/mach-mmp/pm-mmp3.c
index 0b9fd74..bf5a8c5 100644
--- a/arch/arm/mach-mmp/pm-mmp3.c
+++ b/arch/arm/mach-mmp/pm-mmp3.c
@@ -449,7 +449,7 @@ static struct mmp3_freq_plan mmp3_pps[] = {
 		.core = {{MMP3_FREQ_OP_GET, 3, 0, 0, 0, 1, 1, 2, 2},},/*1066*/
 		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
 	},
-#if MMP3_TEST_PP_2GHZ
+#ifdef MMP3_TEST_PP_2GHZ
 	{
 		.core = {{MMP3_FREQ_OP_GET, 2, 0, 0, 0, 1, 1, 2, 2},},/*1200*/
 		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c
index e5e35e0..dbd6fd9 100644
--- a/arch/arm/mm/cache-l2x0.c
+++ b/arch/arm/mm/cache-l2x0.c
@@ -315,7 +315,6 @@ void __init l2x0_init(void __iomem *base, u32 aux_val, u32 aux_mask)
 	u32 way_size = 0;
 	int ways;
 	const char *type;
-	u32 debug_ctrl;
 	__u32 prefetch_ctrl = 0;
 #ifdef CONFIG_CPU_MMP3
 	u32 aux2;
diff --git a/arch/arm/plat-pxa/dvfs.c b/arch/arm/plat-pxa/dvfs.c
index 2ee4c64..e30491f 100644
--- a/arch/arm/plat-pxa/dvfs.c
+++ b/arch/arm/plat-pxa/dvfs.c
@@ -9,9 +9,11 @@
  *  published by the Free Software Foundation.
  */
 
+#include <linux/init.h>
 #include <linux/err.h>
 #include <linux/regulator/consumer.h>
 #include <linux/list.h>
+#include <linux/export.h>
 
 #include <plat/clock.h>
 #include <plat/dvfs.h>
@@ -181,9 +183,9 @@ static int dvfs_rail_connect_to_regulator(struct dvfs_rail *rail)
 		reg = regulator_get(NULL, rail->reg_id);
 		if (IS_ERR(reg))
 			return -EINVAL;
-	}
-
-	rail->reg = reg;
+		rail->reg = reg;
+	} else
+		reg = rail->reg;
 
 	if (regulator_is_enabled(reg))
 		rail->nominal_millivolts = regulator_get_voltage(reg) / 1000;
-- 
1.7.5.4

