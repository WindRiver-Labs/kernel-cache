From 6c8d10e65f8fd6cf5e1cbbd051fdda4429b8c8c9 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 10 Sep 2013 13:37:36 +0800
Subject: [PATCH 41/60] net: pxa168: fix the logic of phy and eth port.

The original design of vendor drop is to drive LED in ethernet
driver, in which they might mess up many stuffs so that there
are two workaround patches from vendor in IP level(ipv4/) to
re-ifup the ethernet work driver(many #ifdef CONFIG_QSEVEN in
net/ipv4). From my side, marvell phy is not very well addressed
in that design to drive LED, so I re-design the phy part as the
general way to start phy, which lets the driver survived in -rt
kernel as well, especially in adjust_link.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/marvell/pxa168_eth.c |  209 ++++++++++++-----------------
 1 files changed, 85 insertions(+), 124 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index 99679a4..9cbd952 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -235,7 +235,6 @@ struct pxa168_eth_private {
 
 	struct net_device *dev;
 	struct napi_struct napi;
-	u8 work_todo;
 	int skb_size;
 
 	struct net_device_stats stats;
@@ -256,6 +255,8 @@ struct pxa168_eth_private {
 	struct mii_bus *smi_bus;
 	struct phy_device *phy;
 
+	u32 phy_port_status;
+
 	/* clock */
 	struct clk *clk;
 	struct pxa168_eth_platform_data *pd;
@@ -699,6 +700,27 @@ static int pxa168_eth_set_mac_address(struct net_device *dev, void *addr)
 	return 0;
 }
 
+static void pxa168_phy_init(struct pxa168_eth_private *pep, int speed, int duplex)
+{
+	struct phy_device *phy = pep->phy;
+
+	phy->supported &= PHY_BASIC_FEATURES;
+
+	if (speed == 0) {
+		phy->autoneg = AUTONEG_ENABLE;
+		phy->speed = 0;
+		phy->duplex = 0;
+		phy->advertising = phy->supported | ADVERTISED_Autoneg;
+	} else {
+		phy->autoneg = AUTONEG_DISABLE;
+		phy->advertising = 0;
+		phy->speed = speed;
+		phy->duplex = duplex;
+	}
+
+	phy_start_aneg(phy);
+}
+
 static void eth_port_start(struct net_device *dev)
 {
 	unsigned int val = 0;
@@ -707,11 +729,8 @@ static void eth_port_start(struct net_device *dev)
 
 	/* Perform PHY reset, if there is a PHY. */
 	if (pep->phy != NULL) {
-		struct ethtool_cmd cmd;
-
-		pxa168_get_settings(pep->dev, &cmd);
 		ethernet_phy_reset(pep);
-		pxa168_set_settings(pep->dev, &cmd);
+		pxa168_phy_init(pep, pep->pd->speed, pep->pd->duplex);
 	}
 
 	/* Assignment of Tx CTRP of given queue */
@@ -786,7 +805,6 @@ static int txq_reclaim(struct net_device *dev, int force)
 
 	netif_tx_lock(dev);
 
-	pep->work_todo &= ~WORK_TX_DONE;
 	while (pep->tx_desc_count > 0) {
 		tx_index = pep->tx_used_desc_q;
 		desc = &pep->p_tx_desc_area[tx_index];
@@ -963,7 +981,6 @@ static int pxa168_eth_collect_events(struct pxa168_eth_private *pep,
 
 	wrl(pep, INT_CAUSE, ~icr);
 	if (icr & (ICR_TXBUF_H | ICR_TXBUF_L)) {
-		pep->work_todo |= WORK_TX_DONE;
 		ret = 1;
 	}
 	if (icr & ICR_RXBUF) {
@@ -974,77 +991,61 @@ static int pxa168_eth_collect_events(struct pxa168_eth_private *pep,
 		ret = 1;
 	}
 	if (icr & ICR_MII_CH) {
-		pep->work_todo |= WORK_LINK;
 		ret = 1;
 	}
 	return ret;
 }
 
-static void handle_link_event(struct pxa168_eth_private *pep)
+static void _pxa168_adjust_link(struct pxa168_eth_private *pep)
 {
 	struct net_device *dev = pep->dev;
+	struct phy_device *phy = pep->phy;
 	u32 port_status;
-	int speed;
-	int duplex;
-	int fc;
-	int link_led;
-
-	link_led = mfp_to_gpio(MFP_PIN_GPIO87);
-	if (gpio_request(link_led, "link_led"))
-		printk(KERN_WARNING "gpio %d request failed\n", link_led);
 
 	port_status = rdl(pep, PORT_STATUS);
 
-	if (!(port_status & LINK_UP)) {
+	if (!phy->link) {
 		if (netif_carrier_ok(dev)) {
-			gpio_direction_output(link_led, 1);
-			gpio_free(link_led);
 			printk(KERN_INFO "%s: link down\n", dev->name);
-			netif_carrier_off(dev);
-			txq_reclaim(dev, 1);
 			atomic_set(&pep->blink, 0);
 			schedule_work(&pep->data_transfer_indicator);
 		}
 		return;
 	}
 
-	if (port_status & PORT_SPEED_100)
-		speed = 100;
-	else
-		speed = 10;
-
-	if (pep->phy->autoneg == AUTONEG_DISABLE) {
-		speed = pep->phy->speed;
-		duplex = pep->phy->duplex;
-		wrl(pep, PORT_CONFIG_EXT, rdl(pep, PORT_CONFIG_EXT)
-			| PCXR_SPEED_EN | PCXR_F_CTRL_EN | PCXR_DULX_EN);
-		if (duplex)
-			wrl(pep, PORT_CONFIG, rdl(pep, PORT_CONFIG) | PCR_HD);
-		else
-			wrl(pep, PORT_CONFIG,
-				rdl(pep, PORT_CONFIG) & (~PCR_HD));
-
-		if (speed == SPEED_100)
-			wrl(pep, PORT_CONFIG_EXT,
-				rdl(pep, PORT_CONFIG_EXT) | PCXR_SPEED_100);
-		else if (speed == SPEED_10)
-			wrl(pep, PORT_CONFIG_EXT, rdl(pep,
-				PORT_CONFIG_EXT) & (~PCXR_SPEED_100));
-		else
-			printk(KERN_INFO "We have not implemented 1000Mb/s or other speed yet.");
-		port_status = rdl(pep, PORT_STATUS);
+	if (pep->phy_port_status != port_status){
+		int link = port_status & LINK_UP;
+
+		pep->phy_port_status = port_status;
+		phy->speed = (port_status & PORT_SPEED_100) ? 100 : 10;
+		phy->duplex = (port_status & FULL_DUPLEX) ? 1 : 0;
+
+		if (phy->link != link) {
+			int fc, link;
+			fc = (port_status & FLOW_CONTROL_ENABLED) ? 1 : 0;
+			printk(KERN_INFO "%s: link %s, %d Mb/s, %s duplex, "
+			       "flow control %sabled\n", dev->name,
+				phy->link ? "up": "down",phy->speed,
+				phy->duplex ? "full" : "half",
+				fc ? "en" : "dis");
+		}
 	}
+}
 
-	gpio_direction_output(link_led, 0);
-	gpio_free(link_led);
+static void pxa168_adjust_link(struct net_device *ndev)
+{
+	struct pxa168_eth_private *pep = netdev_priv(ndev);
 
-	duplex = (port_status & FULL_DUPLEX) ? 1 : 0;
-	fc = (port_status & FLOW_CONTROL_ENABLED) ? 1 : 0;
-	printk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "
-	       "flow control %sabled\n", dev->name,
-	       speed, duplex ? "full" : "half", fc ? "en" : "dis");
-	if (!netif_carrier_ok(dev))
-		netif_carrier_on(dev);
+	_pxa168_adjust_link(pep);
+
+	if (pep->phy->link) {
+		netif_carrier_on(ndev);
+		if (netif_running(ndev))
+			netif_wake_queue(ndev);
+	} else {
+		netif_carrier_off(ndev);
+		netif_stop_queue(ndev);
+	}
 }
 
 static irqreturn_t pxa168_eth_int_handler(int irq, void *dev_id)
@@ -1260,11 +1261,28 @@ static void txq_deinit(struct net_device *dev)
 	kfree(pep->tx_skb);
 }
 
+static void pxa168_phy_start(struct pxa168_eth_private *pep)
+{
+	struct phy_device *phy = pep->phy;
+	struct net_device *dev = pep->dev;
+
+	printk("Trying to attach to %s\n", pep->smi_bus->id);
+
+	phy_connect(pep->dev, dev_name(&phy->dev), pxa168_adjust_link, 0, PHY_INTERFACE_MODE_MII);
+
+	phy_start(phy);
+
+	if(pep->phy->link)
+		netif_carrier_on(dev);
+}
+
 static int pxa168_eth_open(struct net_device *dev)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
 	int err;
 
+	netif_carrier_off(dev);
+
 	err = request_irq(dev->irq, pxa168_eth_int_handler,
 			  IRQF_DISABLED, dev->name, dev);
 	if (err) {
@@ -1285,8 +1303,9 @@ static int pxa168_eth_open(struct net_device *dev)
 	rxq_refill(dev);
 	pep->rx_used_desc_q = 0;
 	pep->rx_curr_desc_q = 0;
-	netif_carrier_off(dev);
 	eth_port_start(dev);
+
+	pxa168_phy_start(pep);
 	napi_enable(&pep->napi);
 	return 0;
 out_free_rx_skb:
@@ -1365,10 +1384,6 @@ static int pxa168_rx_poll(struct napi_struct *napi, int budget)
 	struct net_device *dev = pep->dev;
 	int work_done = 0;
 
-	if (unlikely(pep->work_todo & WORK_LINK)) {
-		pep->work_todo &= ~(WORK_LINK);
-		handle_link_event(pep);
-	}
 	/*
 	 * We call txq_reclaim every time since in NAPI interupts are disabled
 	 * and due to this we miss the TX_DONE interrupt,which is not updated in
@@ -1496,71 +1511,12 @@ static int pxa168_eth_do_ioctl(struct net_device *dev, struct ifreq *ifr,
 	return -EOPNOTSUPP;
 }
 
-static struct phy_device *phy_scan(struct pxa168_eth_private *pep, int phy_addr)
-{
-	struct mii_bus *bus = pep->smi_bus;
-	struct phy_device *phydev;
-	int start;
-	int num;
-	int i;
-
-	if (phy_addr == PXA168_ETH_PHY_ADDR_DEFAULT) {
-		/* Use phy addr specific to platform */
-		start = phy_addr & 0x1f;
-		num = 1;
-	} else {
-		/* Scan entire range */
-		start = ethernet_phy_get(pep);
-		num = 32;
-	}
-
-	phydev = NULL;
-	for (i = 0; i < num; i++) {
-		int addr = (start + i) & 0x1f;
-		if (bus->phy_map[addr] == NULL)
-			mdiobus_scan(bus, addr);
-
-		if (phydev == NULL) {
-			phydev = bus->phy_map[addr];
-			if (phydev != NULL)
-				ethernet_phy_set_addr(pep, addr);
-		}
-	}
-
-	return phydev;
-}
-
-static void phy_init(struct pxa168_eth_private *pep, int speed, int duplex)
-{
-	struct phy_device *phy = pep->phy;
-	ethernet_phy_reset(pep);
-
-	phy_attach(pep->dev, dev_name(&phy->dev), 0, PHY_INTERFACE_MODE_MII);
-	phy->supported &= PHY_BASIC_FEATURES;
-
-	if (speed == 0) {
-		phy->autoneg = AUTONEG_ENABLE;
-		phy->speed = 0;
-		phy->duplex = 0;
-		phy->advertising = phy->supported | ADVERTISED_Autoneg;
-	} else {
-		phy->autoneg = AUTONEG_DISABLE;
-		phy->advertising = 0;
-		phy->speed = speed;
-		phy->duplex = duplex;
-	}
-	phy_start_aneg(phy);
-}
-
 static int ethernet_phy_setup(struct net_device *dev)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
 
 	if (pep->pd->init)
 		pep->pd->init();
-	pep->phy = phy_scan(pep, pep->pd->phy_addr & 0x1f);
-	if (pep->phy != NULL)
-		phy_init(pep, pep->pd->speed, pep->pd->duplex);
 	update_hash_table_mac_address(pep, NULL, dev->dev_addr);
 
 	return 0;
@@ -1586,7 +1542,7 @@ static int pxa168_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 
 	if (speed != SPEED_100 && speed != SPEED_10)
 		return -EINVAL;
-	if (speed != pep->pd->speed) {
+	if (speed != pep->phy->speed) {
 		spin_lock_irqsave(&pep->clk->spinlock, flags);
 		if (speed == SPEED_10) {
 			pep->clk->div = 10;
@@ -1595,10 +1551,9 @@ static int pxa168_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 			pep->clk->div = 0;
 			pep->clk->mul = 10;
 		}
+		pep->phy->speed = speed;
 		pep->pd->speed = speed;
 		spin_unlock_irqrestore(&pep->clk->spinlock, flags);
-		clk_disable(pep->clk);
-		clk_enable(pep->clk);
 	}
 	return phy_ethtool_sset(pep->phy, cmd);
 }
@@ -1719,6 +1674,9 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 		err = -ENOMEM;
 		goto err_base;
 	}
+
+	if (pdev->id == -1)
+		pdev->id = 1;
 	pep->smi_bus->priv = pep;
 	pep->smi_bus->name = "pxa168_eth smi";
 	pep->smi_bus->read = pxa168_smi_read;
@@ -1726,11 +1684,14 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 	snprintf(pep->smi_bus->id, MII_BUS_ID_SIZE, "%s-%d",
 		pdev->name, pdev->id);
 	pep->smi_bus->parent = &pdev->dev;
-	pep->smi_bus->phy_mask = 0xffffffff;
+	pep->smi_bus->phy_mask = 0xfffffffe;
 	err = mdiobus_register(pep->smi_bus);
 	if (err)
 		goto err_free_mdio;
 
+	pep->phy = pep->smi_bus->phy_map[pep->pd->phy_addr & 0x1f];
+	printk("PEP portnum %d addr = %d fixme here \n",pep->port_num, ethernet_phy_get(pep));
+	ethernet_phy_set_addr(pep, pep->phy->addr);
 	pxa168_init_hw(pep);
 	err = ethernet_phy_setup(dev);
 	if (err)
-- 
1.7.5.4

