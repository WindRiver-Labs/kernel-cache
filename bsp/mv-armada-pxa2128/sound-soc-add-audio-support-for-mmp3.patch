From 81f11c84f09bbc3fdcca3817d3107c1ad5ba807e Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 3 Sep 2013 16:55:55 +0800
Subject: [PATCH 46/60] sound: soc: add audio support for mmp3

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports audio driver to WRLinux 3.4.x
kernel for mmp3.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 sound/soc/pxa/Kconfig     |   36 ++
 sound/soc/pxa/Makefile    |    4 +
 sound/soc/pxa/mmp2-squ.c  |  518 +++++++++++++++++++++++++++
 sound/soc/pxa/mmp2-squ.h  |   79 +++++
 sound/soc/pxa/mmp2-sspa.c |  859 +++++++++++++++++++++++++++++++++++++++++++++
 sound/soc/pxa/mmp2-sspa.h |   28 ++
 sound/soc/pxa/qseven.c    |  757 +++++++++++++++++++++++++++++++++++++++
 7 files changed, 2281 insertions(+), 0 deletions(-)
 create mode 100644 sound/soc/pxa/mmp2-squ.c
 create mode 100644 sound/soc/pxa/mmp2-squ.h
 create mode 100644 sound/soc/pxa/mmp2-sspa.c
 create mode 100644 sound/soc/pxa/mmp2-sspa.h
 create mode 100644 sound/soc/pxa/qseven.c

diff --git a/sound/soc/pxa/Kconfig b/sound/soc/pxa/Kconfig
index a0f7d3c..04d678c 100644
--- a/sound/soc/pxa/Kconfig
+++ b/sound/soc/pxa/Kconfig
@@ -194,3 +194,39 @@ config SND_PXA2XX_SOC_IMOTE2
        help
          Say Y if you want to add support for SoC audio on the
 	 IMote 2.
+
+config SND_MMP_LEGACY_SOC
+	bool "Soc Audio for Marvell MMP"
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the MMP2 SSPA interface.
+	  You will also need to select the audio interfaces to
+	  support below.
+
+menu "SoC Audio for the Marvell MMPx"
+config SND_MMP_SOC
+	tristate "SoC Audio for the Marvell MMPx chip"
+	depends on ARCH_MMP && SND && SND_MMP_LEGACY_SOC
+	select SND_ARM
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the MMP SSPA interface.
+
+config SND_MMP2_SOC
+	tristate "SoC Audio for the Marvell MMP2 chip"
+	depends on SND_MMP_LEGACY_SOC
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the MMP SSPA interface.
+
+config SND_MMP_SOC_QSEVEN
+        bool "SoC Audio support for MMP3 QSeven"
+	depends on SND_MMP_SOC && (MACH_QSEVEN) && SND_MMP_LEGACY_SOC
+	select SND_SOC_WM8731
+	select SND_SOC_QSEVEN_HDMI
+	help
+	  Say Y if you want to add support for SoC audio on QSeven
+endmenu
diff --git a/sound/soc/pxa/Makefile b/sound/soc/pxa/Makefile
index af35762..e6bbc33 100644
--- a/sound/soc/pxa/Makefile
+++ b/sound/soc/pxa/Makefile
@@ -3,11 +3,13 @@ snd-soc-pxa2xx-objs := pxa2xx-pcm.o
 snd-soc-pxa2xx-ac97-objs := pxa2xx-ac97.o
 snd-soc-pxa2xx-i2s-objs := pxa2xx-i2s.o
 snd-soc-pxa-ssp-objs := pxa-ssp.o
+snd-soc-mmp-objs := mmp2-sspa.o mmp2-squ.o
 
 obj-$(CONFIG_SND_PXA2XX_SOC) += snd-soc-pxa2xx.o
 obj-$(CONFIG_SND_PXA2XX_SOC_AC97) += snd-soc-pxa2xx-ac97.o
 obj-$(CONFIG_SND_PXA2XX_SOC_I2S) += snd-soc-pxa2xx-i2s.o
 obj-$(CONFIG_SND_PXA_SOC_SSP) += snd-soc-pxa-ssp.o
+obj-$(CONFIG_SND_MMP_SOC) += snd-soc-mmp.o
 
 # PXA Machine Support
 snd-soc-corgi-objs := corgi.o
@@ -28,6 +30,7 @@ snd-soc-mioa701-objs := mioa701_wm9713.o
 snd-soc-z2-objs := z2.o
 snd-soc-imote2-objs := imote2.o
 snd-soc-raumfeld-objs := raumfeld.o
+snd-soc-qseven-objs := qseven.o
 
 obj-$(CONFIG_SND_PXA2XX_SOC_CORGI) += snd-soc-corgi.o
 obj-$(CONFIG_SND_PXA2XX_SOC_POODLE) += snd-soc-poodle.o
@@ -47,3 +50,4 @@ obj-$(CONFIG_SND_SOC_TAVOREVB3) += snd-soc-tavorevb3.o
 obj-$(CONFIG_SND_SOC_ZYLONITE) += snd-soc-zylonite.o
 obj-$(CONFIG_SND_PXA2XX_SOC_IMOTE2) += snd-soc-imote2.o
 obj-$(CONFIG_SND_SOC_RAUMFELD) += snd-soc-raumfeld.o
+obj-$(CONFIG_SND_MMP_SOC_QSEVEN) += snd-soc-qseven.o
diff --git a/sound/soc/pxa/mmp2-squ.c b/sound/soc/pxa/mmp2-squ.c
new file mode 100644
index 0000000..a235d310
--- /dev/null
+++ b/sound/soc/pxa/mmp2-squ.c
@@ -0,0 +1,518 @@
+/*
+ * linux/sound/soc/pxa/mmp2-squ.c
+ *
+ * Base on linux/sound/soc/pxa/pxa2xx-pcm.c
+ *
+ * Copyright (C) 2011 Marvell International Ltd.
+ * Author: Bin Yang <bin.yang@marvell.com>
+ *			 Yael Sheli Chemla<yael.s.shemla@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <asm/dma.h>
+
+#include <mach/mmp_dma.h>
+#include <mach/sram.h>
+#include <mach/cputype.h>
+#include "mmp2-squ.h"
+
+#include <linux/delay.h>
+
+#define DMA_32BIT_MASK  DMA_BIT_MASK(32)
+
+#ifdef CONFIG_CPU_MMP2
+
+static const struct snd_pcm_hardware mmp2_pcm_hardware_playback = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S24_LE |
+				  SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 1024,
+	.period_bytes_max	= 2048,
+	.periods_min		= 2,
+	.periods_max		= PAGE_SIZE / sizeof(mmp_tdma_desc),
+	.buffer_bytes_max	= PAGE_SIZE,
+	.fifo_size		= 32,
+};
+
+static const struct snd_pcm_hardware mmp2_pcm_hardware_capture = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_PAUSE |
+				  SNDRV_PCM_INFO_RESUME,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE |
+				  SNDRV_PCM_FMTBIT_S24_LE |
+				  SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min	= 1024,
+	.period_bytes_max	= 2048,
+	.periods_min		= 2,
+	.periods_max		= PAGE_SIZE / sizeof(mmp_tdma_desc),
+	.buffer_bytes_max	= PAGE_SIZE,
+	.fifo_size		= 32,
+};
+
+#elif defined(CONFIG_CPU_MMP3)
+
+static const struct snd_pcm_hardware mmp2_pcm_hardware_playback = {
+	.info = SNDRV_PCM_INFO_MMAP |
+	    SNDRV_PCM_INFO_MMAP_VALID |
+	    SNDRV_PCM_INFO_INTERLEAVED |
+	    SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+	    SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min = 32,
+	.period_bytes_max = 10 * 1024,
+	.periods_min = 1,
+	.periods_max = PAGE_SIZE / sizeof(mmp_tdma_desc),
+	.buffer_bytes_max = 24 * 1024,
+	.fifo_size = 32,
+};
+
+static const struct snd_pcm_hardware mmp2_pcm_hardware_capture = {
+	.info = SNDRV_PCM_INFO_MMAP |
+	    SNDRV_PCM_INFO_MMAP_VALID |
+	    SNDRV_PCM_INFO_INTERLEAVED |
+	    SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+	    SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE,
+	.period_bytes_min = 32,
+	.period_bytes_max = 10 * 1024,
+	.periods_min = 1,
+	.periods_max = PAGE_SIZE / sizeof(mmp_tdma_desc),
+	.buffer_bytes_max = 24 * 1024,
+	.fifo_size = 32,
+};
+
+#endif
+
+static DECLARE_WAIT_QUEUE_HEAD(dma_wq);
+
+static int mmp2_sram_mmap_noncached(struct vm_area_struct *vma,
+				    void *cpu_addr, dma_addr_t dma_addr,
+				    size_t size)
+{
+	unsigned long user_size;
+	unsigned long off = vma->vm_pgoff;
+	u32 ret;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	user_size = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
+	ret = remap_pfn_range(vma, vma->vm_start,
+			      __phys_to_pfn(dma_addr) + off,
+			      user_size << PAGE_SHIFT, vma->vm_page_prot);
+
+	return ret;
+}
+
+static void mmp2_adma_irq(int dma_ch, void *dev_id)
+{
+	struct snd_pcm_substream *substream = dev_id;
+	struct mmp2_runtime_data *prtd = substream->runtime->private_data;
+
+	u32 base_register = mmp_get_dma_reg_base(dma_ch);
+	if (base_register) {
+		if (TDISR(base_register) & 0x1)
+			snd_pcm_period_elapsed(substream);
+		else {
+			printk(KERN_ERR "%s: SQU error on channel %d\n",
+			       prtd->params->name, dma_ch);
+		}
+		TDISR(base_register) = 0;
+	}
+}
+
+static int mmp2_pcm_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mmp2_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct mmp2_adma_params *dma;
+	size_t totsize = params_buffer_bytes(params);
+	size_t period = params_period_bytes(params);
+	mmp_tdma_desc *adma_desc;
+	dma_addr_t dma_buff_phys, next_desc_phys;
+	int ret;
+
+	dma = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+	    rtd->cpu_dai->playback_dma_data : rtd->cpu_dai->capture_dma_data;
+	/* return if this is a bufferless transfer e.g.
+	 * codec <--> BT codec or GSM modem -- lg FIXME */
+	if (!dma)
+		return 0;
+
+	/* this may get called several times by oss emulation
+	 * with different params */
+	if (prtd->params == NULL) {
+		prtd->params = dma;
+		ret = mmp_request_dma(prtd->params->name, dma->dma_ch,
+					 mmp2_adma_irq, substream);
+		if (ret < 0)
+			return ret;
+
+		prtd->adma_ch = ret;
+	} else if (prtd->params != dma) {
+		mmp_free_dma(prtd->adma_ch);
+		prtd->params = dma;
+		ret = mmp_request_dma(prtd->params->name, dma->dma_ch,
+					 mmp2_adma_irq, substream);
+		if (ret < 0)
+			return ret;
+
+		prtd->adma_ch = ret;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = totsize;
+
+	next_desc_phys = prtd->adma_desc_array_phys;
+	dma_buff_phys = runtime->dma_addr;
+
+	adma_desc = prtd->adma_desc_array;
+	do {
+		next_desc_phys += sizeof(mmp_tdma_desc);
+
+		adma_desc->nxt_desc = next_desc_phys;
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			adma_desc->src_addr = dma_buff_phys;
+			adma_desc->dst_addr = prtd->params->dev_addr;
+		} else {
+			adma_desc->src_addr = prtd->params->dev_addr;
+			adma_desc->dst_addr = dma_buff_phys;
+		}
+		if (period > totsize)
+			period = totsize;
+		adma_desc->byte_cnt = period;
+		adma_desc++;
+		dma_buff_phys += period;
+
+	} while (totsize -= period);
+	adma_desc[-1].nxt_desc = prtd->adma_desc_array_phys;
+
+	return 0;
+}
+
+static int mmp2_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct mmp2_runtime_data *prtd = substream->runtime->private_data;
+
+	if (prtd->adma_ch != -1) {
+		snd_pcm_set_runtime_buffer(substream, NULL);
+		mmp_free_dma(prtd->adma_ch);
+		prtd->adma_ch = -1;
+	}
+
+	return 0;
+}
+
+static int mmp2_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	int ret = 0;
+	struct mmp2_runtime_data *prtd = substream->runtime->private_data;
+
+	u32 base_register = mmp_get_dma_reg_base(prtd->adma_ch);
+	if (base_register) {
+		TDCR(base_register) = (prtd->params->dcmd)
+		    & (~TDCR_CHANEN);
+		TDIMR(base_register) = TDIMR_COMP;
+	} else
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static int mmp2_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mmp2_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+	u32 base_register;
+
+	base_register = mmp_get_dma_reg_base(prtd->adma_ch);
+	if (!base_register)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		TDNDPR(base_register) = prtd->adma_desc_array_phys;
+		TDCR(base_register) = prtd->params->dcmd | TDCR_CHANEN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		TDCR(base_register) = prtd->params->dcmd;
+		wake_up(&dma_wq);
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		TDCR(base_register) = prtd->params->dcmd | TDCR_CHANEN;
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		TDNDPR(base_register) = prtd->adma_desc_array_phys;
+		TDCR(base_register) = prtd->params->dcmd | TDCR_CHANEN;
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t mmp2_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mmp2_runtime_data *prtd = runtime->private_data;
+	dma_addr_t ptr;
+	snd_pcm_uframes_t x;
+
+	u32 base_register = mmp_get_dma_reg_base(prtd->adma_ch);
+	ptr = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+	    TDSAR(base_register) : TDDAR(base_register);
+
+	x = bytes_to_frames(runtime, ptr - runtime->dma_addr);
+
+	if (x == runtime->buffer_size)
+		x = 0;
+	return x;
+}
+
+static int mmp2_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mmp2_runtime_data *prtd;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_set_runtime_hwparams(substream,
+					     &mmp2_pcm_hardware_playback);
+	else
+		snd_soc_set_runtime_hwparams(substream,
+					     &mmp2_pcm_hardware_capture);
+
+	/*
+	 * For mysterious reasons (and despite what the manual says)
+	 * playback samples are lost if the DMA count is not a multiple
+	 * of the DMA burst size.  Let's add a rule to enforce that.
+	 */
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_step(runtime, 0,
+					 SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);
+	if (ret)
+		goto out;
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(struct mmp2_runtime_data), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	/*
+	 * avoid sram fragment, allocate dma buffer and
+	 * dma desc list at the same time.
+	 */
+	prtd->adma_desc_array = sram_alloc("audio sram", PAGE_SIZE,
+				    (dma_addr_t *)&prtd->adma_desc_array_phys);
+	if (!prtd->adma_desc_array) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	runtime->private_data = prtd;
+
+	return 0;
+
+err1:
+	kfree(prtd);
+out:
+	return ret;
+}
+
+static int mmp2_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mmp2_runtime_data *prtd = runtime->private_data;
+
+	sram_free("audio sram", (void *)prtd->adma_desc_array, PAGE_SIZE);
+
+	kfree(prtd);
+	runtime->private_data = NULL;
+	return 0;
+}
+
+static int mmp2_pcm_mmap(struct snd_pcm_substream *substream,
+			 struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return mmp2_sram_mmap_noncached(vma,
+					runtime->dma_area,
+					runtime->dma_addr, runtime->dma_bytes);
+}
+
+struct snd_pcm_ops mmp2_pcm_ops = {
+	.open = mmp2_pcm_open,
+	.close = mmp2_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = mmp2_pcm_hw_params,
+	.hw_free = mmp2_pcm_hw_free,
+	.prepare = mmp2_pcm_prepare,
+	.trigger = mmp2_pcm_trigger,
+	.pointer = mmp2_pcm_pointer,
+	.mmap = mmp2_pcm_mmap,
+};
+
+static int mmp2_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	size_t size;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
+		size = mmp2_pcm_hardware_playback.buffer_bytes_max;
+	else
+		size = mmp2_pcm_hardware_capture.buffer_bytes_max;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+	buf->area = sram_alloc("audio sram", size, &buf->addr);
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	return 0;
+}
+
+static void mmp2_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		sram_free("audio sram", (void *)buf->area, buf->bytes);
+		buf->area = NULL;
+	}
+}
+
+static u64 mmp2_pcm_dmamask = DMA_32BIT_MASK;
+
+int mmp2_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+		 struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &mmp2_pcm_dmamask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_32BIT_MASK;
+
+	if (dai->driver->playback.channels_min) {
+		ret = mmp2_pcm_preallocate_dma_buffer(pcm,
+				      SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		ret = mmp2_pcm_preallocate_dma_buffer(pcm,
+					      SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+out:
+	return ret;
+}
+
+struct snd_soc_platform_driver mmp2_soc_platform = {
+	.ops = &mmp2_pcm_ops,
+	.pcm_new = mmp2_pcm_new,
+	.pcm_free = mmp2_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(mmp2_soc_platform);
+
+static int __devinit mmp2_soc_platform_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &mmp2_soc_platform);
+}
+
+static int __devexit mmp2_soc_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver mmp2_pcm_driver = {
+	.driver = {
+		   .name = "mmp3-pcm-audio",
+		   .owner = THIS_MODULE,
+		   },
+
+	.probe = mmp2_soc_platform_probe,
+	.remove = __devexit_p(mmp2_soc_platform_remove),
+};
+
+static int __init snd_mmp2_pcm_init(void)
+{
+	return platform_driver_register(&mmp2_pcm_driver);
+}
+
+module_init(snd_mmp2_pcm_init);
+
+static void __exit snd_mmp2_pcm_exit(void)
+{
+	platform_driver_unregister(&mmp2_pcm_driver);
+}
+
+module_exit(snd_mmp2_pcm_exit);
+
+MODULE_AUTHOR("zhouqiao@marvell.com");
+MODULE_DESCRIPTION("MMP3 SQU DMA module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/pxa/mmp2-squ.h b/sound/soc/pxa/mmp2-squ.h
new file mode 100644
index 0000000..4f03bb4
--- /dev/null
+++ b/sound/soc/pxa/mmp2-squ.h
@@ -0,0 +1,79 @@
+/*
+ * linux/sound/soc/pxa/mmp2-squ.h
+ *
+ * Base on linux/sound/soc/pxa/pxa910-squ.h
+ *
+ * Copyright (C) 2011 Marvell International Ltd.
+ * Author: Leo Yan <leoy@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#ifndef _MMP2_SQU_H
+#define _MMP2_SQU_H
+
+#define MMP2_ADMA_BUF_SIZE		(PAGE_SIZE)
+#define MMP2_ADMA_DESC_SIZE		(1024)
+#define MMP2_DDR_BUF_SIZE		(MMP2_ADMA_BUF_SIZE << 4)
+
+/* adma buf and desc size */
+#define MMP2_ADMA_TOTAL_SIZE		(PAGE_SIZE + 1024)
+
+struct mmp2_adma_params {
+	char *name;			/* stream identifier */
+	u32 dma_ch;			/* the DMA request channel to use */
+	u32 dcmd;			/* DMA descriptor dcmd field */
+	u32 dev_addr;			/* device physical address for DMA */
+};
+
+struct mmp2_adma_registers {
+	u32 byte_counter;
+	u32 src_addr;
+	u32 dest_addr;
+	u32 next_desc_ptr;
+	u32 ctrl;
+	u32 chan_pri;			/* Only used in channel 0 */
+	u32 curr_desc_ptr;
+	u32 intr_mask;
+	u32 intr_status;
+};
+
+struct mmp2_runtime_data {
+	int adma_ch;
+	struct mmp2_adma_params *params;
+	void *adma_desc_array;
+	dma_addr_t adma_desc_array_phys;
+
+	spinlock_t lock;
+
+	/* sram buf */
+	unsigned int sram_virt;
+	unsigned int sram_phys;
+	unsigned int sram_size;
+	unsigned int sram_blk_idx;
+	unsigned int sram_blk_num;
+
+	/* notes: below ddr info should be unneccessary for MMP3 */
+	/* ddr buf */
+	unsigned int rbuf_virt;
+	unsigned int rbuf_phys;
+	unsigned int rbuf_size;
+	unsigned int rbuf_blk_idx;
+	unsigned int rbuf_blk_num;
+
+	unsigned int sync_blk;
+	/* end notes */
+	u32 blk_size;
+
+	struct snd_pcm_substream *substream;
+
+	struct mmp2_adma_registers adma_saved;
+	char sram_saved[MMP2_ADMA_TOTAL_SIZE];
+};
+
+extern struct snd_soc_platform_driver mmp2_soc_platform;
+
+#endif /* _MMP2_SQU_H */
diff --git a/sound/soc/pxa/mmp2-sspa.c b/sound/soc/pxa/mmp2-sspa.c
new file mode 100644
index 0000000..166b03a
--- /dev/null
+++ b/sound/soc/pxa/mmp2-sspa.c
@@ -0,0 +1,859 @@
+/*
+ * linux/sound/soc/pxa/mmp2-sspa.c
+ * Base on pxa2xx-ssp.c
+ *
+ * Copyright (C) 2007 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <linux/io.h>
+#include <mach/regs-sspa.h>
+#include <mach/mmp_dma.h>
+#include <plat/dma.h>
+#include <plat/ssp.h>
+
+#include "mmp2-squ.h"
+#include "mmp2-sspa.h"
+
+enum {
+	MMP2_SSPA1,
+	MMP2_SSPA2,
+};
+
+/*
+ * SSPA audio private data
+ */
+struct sspa_priv {
+	struct ssp_device *sspa;
+	unsigned int freq;
+	unsigned int sysclk;
+	int dai_fmt;
+	int suspend;
+	int running_cnt;
+#ifdef CONFIG_PM
+	uint32_t rxctrl;
+	uint32_t rxsp;
+	uint32_t rxfifo_ul;
+	uint32_t rxint_mask;
+	uint32_t txctrl;
+	uint32_t txsp;
+	uint32_t txfifo_ll;
+	uint32_t txint_mask;
+#endif
+};
+
+struct pll_set {
+	unsigned int freq_in;		/* vcxo freq */
+	unsigned int freq_out;		/* audio pll */
+	unsigned int mclk;
+	unsigned int fbcclk;
+	unsigned int fract;
+	unsigned int postdiv;
+	unsigned int oclk_modulo;
+	unsigned int oclk_pattern;
+};
+
+static struct pll_set audio_pll_set[] = {
+/* in out mclk fbcclk fract postdiv modulo pattern */
+{26000000, 147456000, 6, 34, 0x00da1,  1, 3, 0},
+{26000000,  36864000, 6, 34, 0x00da1,  4, 0, 0},
+{26000000,  24576000, 6, 34, 0x00da1,  6, 1, 1},
+{26000000,  18432000, 6, 34, 0x00da1,  8, 1, 0},
+{26000000,  16384000, 6, 34, 0x00da1,  9, 1, 2},
+{26000000,  12288000, 6, 34, 0x00da1, 12, 2, 1},
+{26000000,   9216000, 6, 34, 0x00da1, 16, 2, 0},
+{26000000,   8192000, 6, 34, 0x00da1, 18, 2, 2},
+{26000000,   6144000, 6, 34, 0x00da1, 24, 4, 1},
+{26000000,   4096000, 6, 34, 0x00da1, 36, 4, 2},
+{26000000,   3072000, 6, 34, 0x00da1, 48, 6, 1},
+{26000000,   2048000, 6, 34, 0x00da1, 72, 6, 2},
+{26000000, 135475200, 6, 31, 0x08a18,  1, 3, 0},
+{26000000,  33868800, 6, 31, 0x08a18,  4, 0, 0},
+{26000000,  22579200, 6, 31, 0x08a18,  6, 1, 1},
+{26000000,  16934400, 6, 31, 0x08a18,  8, 1, 0},
+{26000000,  11289600, 6, 31, 0x08a18, 12, 2, 1},
+{26000000,   8467200, 6, 31, 0x08a18, 16, 2, 0},
+{26000000,   5644800, 6, 31, 0x08a18, 24, 4, 1},
+{26000000, 104000000, 8, 32,     0x0,  1, 3, 0},
+{26000000,  52000000, 8, 32,     0x0,  2, 5, 0},
+{26000000,  26000000, 8, 32,     0x0,  4, 0, 0},
+{26000000,  13000000, 8, 32,     0x0,  8, 1, 0},
+};
+
+static struct mmp2_adma_params mmp2_pcm_adma_params[] = {
+	[0] = {
+		.name = "SSPA1 PCM out",
+	},
+	[1] = {
+		.name = "SSPA1 PCM in",
+	},
+	[2] = {
+		.name = "SSPA2 PCM out",
+	},
+	[3] = {
+		.name = "SSPA2 PCM in",
+	},
+};
+
+static void mmp2_sspa_write_reg(struct ssp_device *sspa, u32 reg, u32 val)
+{
+	__raw_writel(val, sspa->mmio_base + reg);
+}
+
+static u32 mmp2_sspa_read_reg(struct ssp_device *sspa, u32 reg)
+{
+	return __raw_readl(sspa->mmio_base + reg);
+}
+
+static void mmp2_sspa_tx_enable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp2_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp |= SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+}
+
+static void mmp2_sspa_tx_disable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp2_sspa_read_reg(sspa, SSPA_TXSP);
+	sspa_sp |= SSPA_SP_WEN | SSPA_SP_FFLUSH | SSPA_SP_S_RST;
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+
+	sspa_sp &= ~SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+
+	sspa_sp &= ~(SSPA_SP_FFLUSH | SSPA_SP_S_RST);
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+}
+
+static void mmp2_sspa_rx_enable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp2_sspa_read_reg(sspa, SSPA_RXSP);
+	sspa_sp |= SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+}
+
+static void mmp2_sspa_rx_disable(struct ssp_device *sspa)
+{
+	unsigned int sspa_sp;
+
+	sspa_sp = mmp2_sspa_read_reg(sspa, SSPA_RXSP);
+	sspa_sp |= SSPA_SP_WEN | SSPA_SP_FFLUSH | SSPA_SP_S_RST;
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	sspa_sp &= ~SSPA_SP_S_EN;
+	sspa_sp |= SSPA_SP_WEN;
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	sspa_sp &= ~(SSPA_SP_FFLUSH | SSPA_SP_S_RST);
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+}
+
+static void mmp2_sspa_clk_enable(struct ssp_device *sspa, int id)
+{
+	unsigned int val;
+
+	/* enable sspa clk */
+	val = __raw_readl(SSPA_AUD_CTRL);
+	if (id == MMP2_SSPA1)
+		val |= SSPA_AUD_CTRL_S1_ENA;
+	else
+		val |= SSPA_AUD_CTRL_S2_ENA;
+	__raw_writel(val, SSPA_AUD_CTRL);
+}
+
+static void mmp2_sspa_clk_disable(struct ssp_device *sspa, int id)
+{
+	unsigned int val;
+
+	/* disable sspa clk */
+	val = __raw_readl(SSPA_AUD_CTRL);
+	if (id == MMP2_SSPA1)
+		val &= ~SSPA_AUD_CTRL_S1_ENA;
+	else
+		val &= ~SSPA_AUD_CTRL_S2_ENA;
+	__raw_writel(val, SSPA_AUD_CTRL);
+}
+
+static void mmp2_sspa_sysclk_enable(struct ssp_device *sspa)
+{
+	unsigned int val;
+
+	/* enable sysclk clk */
+	val = __raw_readl(SSPA_AUD_CTRL);
+	val |= SSPA_AUD_CTRL_SYSCLK_ENA;
+	__raw_writel(val, SSPA_AUD_CTRL);
+}
+
+static void mmp2_sspa_sysclk_disable(struct ssp_device *sspa)
+{
+	unsigned int val;
+
+	/* disable sspa clk */
+	val = __raw_readl(SSPA_AUD_CTRL);
+	val &= ~SSPA_AUD_CTRL_SYSCLK_ENA;
+	__raw_writel(val, SSPA_AUD_CTRL);
+}
+
+static void mmp2_sspa_dump_reg(struct ssp_device *sspa)
+{
+	dev_dbg(&sspa->pdev->dev, "RXD         %08x RXID        %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_RXD),
+		mmp2_sspa_read_reg(sspa, SSPA_RXID));
+	dev_dbg(&sspa->pdev->dev, "RXCTL       %08x RXSP        %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_RXCTL),
+		mmp2_sspa_read_reg(sspa, SSPA_RXSP));
+	dev_dbg(&sspa->pdev->dev, "RXFIFO_UL   %08x RXINT_MASK  %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_RXFIFO_UL),
+		mmp2_sspa_read_reg(sspa, SSPA_RXINT_MASK));
+	dev_dbg(&sspa->pdev->dev, "RXC         %08x RXFIFO_NOFS %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_RXC),
+		mmp2_sspa_read_reg(sspa, SSPA_RXFIFO_NOFS));
+	dev_dbg(&sspa->pdev->dev, "RXFIFO_SIZE %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_RXFIFO_SIZE));
+
+	dev_dbg(&sspa->pdev->dev, "TXD         %08x TXID        %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_TXD),
+		mmp2_sspa_read_reg(sspa, SSPA_TXID));
+	dev_dbg(&sspa->pdev->dev, "TXCTL       %08x TXSP        %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_TXCTL),
+		mmp2_sspa_read_reg(sspa, SSPA_TXSP));
+	dev_dbg(&sspa->pdev->dev, "TXFIFO_LL   %08x TXINT_MASK  %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_TXFIFO_LL),
+		mmp2_sspa_read_reg(sspa, SSPA_TXINT_MASK));
+	dev_dbg(&sspa->pdev->dev, "TXC         %08x TXFIFO_NOFS %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_TXC),
+		mmp2_sspa_read_reg(sspa, SSPA_TXFIFO_NOFS));
+	dev_dbg(&sspa->pdev->dev, "TXFIFO_SIZE %08x\n",
+		mmp2_sspa_read_reg(sspa, SSPA_TXFIFO_SIZE));
+
+	return;
+}
+
+static struct mmp2_adma_params*
+mmp2_sspa_get_dma_params(int id, struct ssp_device *sspa, int width, int out)
+{
+	struct mmp2_adma_params *dma;
+	int index;
+
+	index = (id << 1) + (!out);
+	if (index >= ARRAY_SIZE(mmp2_pcm_adma_params))
+		return NULL;
+
+	dma = &mmp2_pcm_adma_params[index];
+	dma->dcmd = (out ? (TDCR_DSTDIR_ADDR_HOLD | TDCR_SRCDIR_ADDR_INC) :
+			   (TDCR_SRCDIR_ADDR_HOLD | TDCR_DSTDIR_ADDR_INC)) |
+		    TDCR_PACKMOD | TDCR_BURSTSZ_4B | TDCR_FETCHND | width;
+	dma->dma_ch = out ? sspa->drcmr_tx : sspa->drcmr_rx;
+	dma->dev_addr = out ? (sspa->phys_base + SSPA_TXD) :
+			      (sspa->phys_base + SSPA_RXD);
+	return dma;
+}
+
+static int mmp3_sspa_startup(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	int ret = 0;
+
+	/* enable sspa clk */
+	if (!cpu_dai->active)
+		mmp2_sspa_clk_enable(sspa, cpu_dai->id);
+
+	return ret;
+}
+
+static void mmp3_sspa_shutdown(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+
+	/* disable sspa clk */
+	if (!cpu_dai->active)
+		mmp2_sspa_clk_disable(sspa, cpu_dai->id);
+
+	return;
+}
+
+#ifdef CONFIG_PM
+
+static uint32_t aud_ctrl;
+static uint32_t aud_pll_ctrl0;
+static uint32_t aud_pll_ctrl1;
+
+static int mmp3_sspa_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+
+	pr_debug("%s: sspa id = %d\n", __func__, cpu_dai->id);
+
+	/* other card's dai link has suspended already */
+	if (priv->suspend)
+		return 0;
+
+	if (!cpu_dai->active)
+		mmp2_sspa_clk_enable(sspa, cpu_dai->id);
+
+	priv->rxctrl      = mmp2_sspa_read_reg(sspa, SSPA_RXCTL);
+	priv->rxsp        = mmp2_sspa_read_reg(sspa, SSPA_RXSP);
+	priv->rxfifo_ul   = mmp2_sspa_read_reg(sspa, SSPA_RXFIFO_UL);
+	priv->rxint_mask  = mmp2_sspa_read_reg(sspa, SSPA_RXINT_MASK);
+
+	priv->txctrl      = mmp2_sspa_read_reg(sspa, SSPA_TXCTL);
+	priv->txsp        = mmp2_sspa_read_reg(sspa, SSPA_TXSP);
+	priv->txfifo_ll   = mmp2_sspa_read_reg(sspa, SSPA_TXFIFO_LL);
+	priv->txint_mask  = mmp2_sspa_read_reg(sspa, SSPA_TXINT_MASK);
+
+	pr_debug("rxctrl %x rxsp %x rxfifo_ul %x rxint_mask %x\n",
+		priv->rxctrl, priv->rxsp,
+		priv->rxfifo_ul, priv->rxint_mask);
+	pr_debug("txctrl %x txsp %x txfifo_ll %x txint_mask %x\n",
+		priv->txctrl, priv->txsp,
+		priv->txfifo_ll, priv->txint_mask);
+
+	if (cpu_dai->id == MMP2_SSPA1) {
+		aud_ctrl      = __raw_readl(SSPA_AUD_CTRL);
+		aud_pll_ctrl0 = __raw_readl(SSPA_AUD_PLL_CTRL0);
+		aud_pll_ctrl1 = __raw_readl(SSPA_AUD_PLL_CTRL1);
+		mmp2_sspa_sysclk_disable(sspa);
+	}
+
+	mmp2_sspa_tx_disable(sspa);
+	mmp2_sspa_rx_disable(sspa);
+	mmp2_sspa_clk_disable(sspa, cpu_dai->id);
+	priv->suspend = 1;
+	return 0;
+}
+
+static int mmp3_sspa_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	u32 sspa_sp;
+
+	pr_debug("%s: sspa id = %d\n", __func__, cpu_dai->id);
+
+	if (!priv->suspend)
+		return 0;
+
+	if (cpu_dai->id == MMP2_SSPA1) {
+		__raw_writel(aud_ctrl,      SSPA_AUD_CTRL);
+		__raw_writel(aud_pll_ctrl0, SSPA_AUD_PLL_CTRL0);
+		__raw_writel(aud_pll_ctrl1, SSPA_AUD_PLL_CTRL1);
+		mmp2_sspa_sysclk_enable(sspa);
+	}
+
+	mmp2_sspa_clk_enable(sspa, cpu_dai->id);
+
+	pr_debug("%s: aud_ctrl = %x, aud_pll_ctrl0 = %x, "
+			"aud_pll_ctrl1 = %x\n",
+			__func__,
+			__raw_readl(SSPA_AUD_CTRL),
+			__raw_readl(SSPA_AUD_PLL_CTRL0),
+			__raw_readl(SSPA_AUD_PLL_CTRL1));
+
+	pr_debug("rxctrl %x rxsp %x rxfifo_ul %x rxint_mask %x\n",
+		priv->rxctrl, priv->rxsp,
+		priv->rxfifo_ul, priv->rxint_mask);
+	pr_debug("txctrl %x txsp %x txfifo_ll %x txint_mask %x\n",
+		priv->txctrl, priv->txsp,
+		priv->txfifo_ll, priv->txint_mask);
+
+	sspa_sp = priv->rxsp | SSPA_SP_WEN |
+		  SSPA_SP_FFLUSH | SSPA_SP_S_RST;
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+	mmp2_sspa_write_reg(sspa, SSPA_RXCTL, priv->rxctrl);
+	mmp2_sspa_write_reg(sspa, SSPA_RXFIFO_UL, priv->rxfifo_ul);
+	mmp2_sspa_write_reg(sspa, SSPA_RXINT_MASK, priv->rxint_mask);
+	sspa_sp &= ~(SSPA_SP_FFLUSH | SSPA_SP_S_RST);
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	sspa_sp = priv->txsp | SSPA_SP_WEN |
+		  SSPA_SP_FFLUSH | SSPA_SP_S_RST;
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	mmp2_sspa_write_reg(sspa, SSPA_TXCTL, priv->txctrl);
+	mmp2_sspa_write_reg(sspa, SSPA_TXFIFO_LL, priv->txfifo_ll);
+	mmp2_sspa_write_reg(sspa, SSPA_TXINT_MASK, priv->txint_mask);
+	sspa_sp &= ~(SSPA_SP_FFLUSH | SSPA_SP_S_RST);
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+
+	if (!cpu_dai->active)
+		mmp2_sspa_clk_disable(sspa, cpu_dai->id);
+
+	mmp2_sspa_dump_reg(sspa);
+	priv->suspend = 0;
+	return 0;
+}
+
+#else
+#define mmp3_sspa_suspend	NULL
+#define mmp3_sspa_resume	NULL
+#endif
+
+/*
+ * Set the SSP ports SYSCLK.
+ */
+static int mmp3_sspa_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				    int clk_id, unsigned int freq, int dir)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	int val, div;
+
+	div = priv->freq;
+	do_div(div, freq);
+	pr_debug("%s: devider = %d\n", __func__, div);
+
+	val  = __raw_readl(SSPA_AUD_CTRL);
+	val &= ~SSPA_AUD_CTRL_SYSCLK_DIV_MASK;
+	val |= SSPA_AUD_CTRL_SYSCLK_DIV(div);
+	__raw_writel(val, SSPA_AUD_CTRL);
+
+	mmp2_sspa_sysclk_enable(sspa);
+
+	return 0;
+}
+
+/*
+ * Set the SSP clock dividers.
+ */
+static int mmp2_sspa_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				    int div_id, int div)
+{
+	int val;
+
+	val = __raw_readl(SSPA_AUD_CTRL);
+	if (cpu_dai->id == MMP2_SSPA1) {
+		val &= ~SSPA_AUD_CTRL_S1_CLK_DIV_MASK;
+		val |= SSPA_AUD_CTRL_S1_CLK_DIV(div);
+	} else {
+		val &= ~SSPA_AUD_CTRL_S2_CLK_DIV_MASK;
+		val |= SSPA_AUD_CTRL_S2_CLK_DIV(div);
+	}
+	__raw_writel(val, SSPA_AUD_CTRL);
+
+	return 0;
+}
+
+static int mmp2_sspa_set_dai_pll(struct snd_soc_dai *cpu_dai, int pll_id,
+				 int source, unsigned int freq_in,
+				 unsigned int freq_out)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pll_set *set;
+	u32 val, i;
+
+	switch (pll_id) {
+	case SSPA_AUDIO_PLL:
+		set = audio_pll_set;
+		for (i = 0; i < ARRAY_SIZE(audio_pll_set); i++) {
+			if ((set->freq_in  == freq_in) &&
+			    (set->freq_out == freq_out))
+				break;
+			set++;
+		}
+
+		if (i == ARRAY_SIZE(audio_pll_set))
+			return -EINVAL;
+
+		val = SSPA_AUD_PLL_CTRL1_DIV_MCLK_MSB2(((set->mclk) & 0xc) >> 2) |
+		      SSPA_AUD_PLL_CTRL1_DIV_FBCCLK_MSB(((set->fbcclk) & 0x3c) >> 2) |
+		      SSPA_AUD_PLL_CTRL1_CLK_SEL_AUDIO_PLL |
+		      SSPA_AUD_PLL_CTRL1_PLL_LOCK |
+		      SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN(set->oclk_pattern);
+		__raw_writel(val, SSPA_AUD_PLL_CTRL1);
+
+		val = SSPA_AUD_PLL_CTRL0_DIV_MCLK1(((set->mclk) & 0x2) >> 1) |
+		      SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO(set->oclk_modulo) |
+		      SSPA_AUD_PLL_CTRL0_FRACT(set->fract) |
+		      SSPA_AUD_PLL_CTRL0_ENA_DITHER |
+		      SSPA_AUD_PLL_CTRL0_DIV_FBCCLK((set->fbcclk) & 0x3) |
+		      SSPA_AUD_PLL_CTRL0_DIV_MCLK((set->mclk) & 0x1) |
+		      SSPA_AUD_PLL_CTRL0_PU;
+
+		__raw_writel(val, SSPA_AUD_PLL_CTRL0);
+
+		val = __raw_readl(SSPA_AUD_CTRL);
+		if (cpu_dai->id == MMP2_SSPA1) {
+			val &= ~SSPA_AUD_CTRL_S1_CLK_SEL_MASK;
+			val |= SSPA_AUD_CTRL_S1_CLK_SEL_AUDIO_PLL;
+		} else {
+			val &= ~SSPA_AUD_CTRL_S2_CLK_SEL_MASK;
+			val |= SSPA_AUD_CTRL_S2_CLK_SEL_AUDIO_PLL;
+		}
+		__raw_writel(val, SSPA_AUD_CTRL);
+
+		pr_debug("aud_ctrl = %x, aud_pll_ctrl0 = %x, "
+			"aud_pll_ctrl1 = %x\n",
+			__raw_readl(SSPA_AUD_CTRL),
+			__raw_readl(SSPA_AUD_PLL_CTRL0),
+			__raw_readl(SSPA_AUD_PLL_CTRL1));
+		break;
+	case SSPA_I2S_PLL:
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	priv->freq = freq_out;
+	return 0;
+}
+
+/*
+ * Set up the sspa dai format. The sspa port must be inactive
+ * before calling this function as the physical
+ * interface format is changed.
+ */
+static int mmp2_sspa_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				 unsigned int fmt)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	u32 sspa_sp, sspa_ctrl;
+
+	pr_debug("%s: enter\n", __func__);
+
+	/* check if we need to change anything at all */
+	if (priv->dai_fmt == fmt)
+		return 0;
+
+	/* we can only change the settings if the port is not in use */
+	if ((mmp2_sspa_read_reg(sspa, SSPA_TXSP) & SSPA_SP_S_EN) ||
+	    (mmp2_sspa_read_reg(sspa, SSPA_RXSP) & SSPA_SP_S_EN)) {
+		dev_err(&sspa->pdev->dev,
+			"can't change hardware dai format: stream is in use\n");
+		return -EINVAL;
+	}
+
+	/* reset port settings */
+	sspa_sp = SSPA_SP_WEN | SSPA_SP_S_RST | SSPA_SP_FFLUSH;
+	sspa_ctrl = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		sspa_sp |= SSPA_SP_MSL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		sspa_sp |= SSPA_SP_FSP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		sspa_ctrl |= SSPA_CTL_XDATDLY(1);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	sspa_sp &= ~(SSPA_SP_S_RST | SSPA_SP_FFLUSH);
+	mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+
+	mmp2_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
+	mmp2_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
+
+	mmp2_sspa_dump_reg(sspa);
+
+	/* Since we are configuring the timings for the format by hand
+	 * we have to defer some things until hw_params() where we
+	 * know parameters like the sample size.
+	 */
+	priv->dai_fmt = fmt;
+	return 0;
+}
+
+/*
+ * Set the SSPA audio DMA parameters and sample size.
+ * Can be called multiple times by oss emulation.
+ */
+static int mmp3_sspa_hw_params(struct snd_pcm_substream *substream,
+			       struct snd_pcm_hw_params *params,
+			       struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	struct mmp2_adma_params *dma_data;
+	u32 sspa_ctrl, sspa_sp, as_width;
+	u32 bits_per_frame, word_size;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		sspa_ctrl = mmp2_sspa_read_reg(sspa, SSPA_TXCTL);
+		sspa_sp   = mmp2_sspa_read_reg(sspa, SSPA_TXSP);
+	} else {
+		sspa_ctrl = mmp2_sspa_read_reg(sspa, SSPA_RXCTL);
+		sspa_sp   = mmp2_sspa_read_reg(sspa, SSPA_RXSP);
+	}
+
+	sspa_ctrl &= ~SSPA_CTL_XFRLEN1_MASK;
+	sspa_ctrl |= SSPA_CTL_XFRLEN1(params_channels(params) - 1);
+	sspa_ctrl &= ~SSPA_CTL_XWDLEN1_MASK;
+	sspa_ctrl &= ~SSPA_CTL_XSSZ1_MASK;
+
+	sspa_sp &= ~SSPA_SP_FPER_MASK;
+	sspa_sp &= ~SSPA_SP_FWID_MASK;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S8:
+		word_size = SSPA_CTL_8_BITS;
+		bits_per_frame = 16;
+		as_width = TDCR_SSZ_8_BITS;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		word_size = SSPA_CTL_32_BITS;
+		bits_per_frame = 32;
+		as_width = TDCR_SSZ_16_BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		word_size = SSPA_CTL_24_BITS;
+		bits_per_frame = 48;
+		as_width = TDCR_SSZ_24_BITS;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		word_size = SSPA_CTL_32_BITS;
+		bits_per_frame = 64;
+		as_width = TDCR_SSZ_32_BITS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* I2S protocol: need to double the audio sample size to ensure
+	 * that word_size bit can be sent out. the word_size - 1 length of
+	 * 0 would be ignored in codec. it should be also appiled to other
+	 * formats besides S16_LE */
+	sspa_ctrl |= SSPA_CTL_XSSZ1(word_size) |
+		     SSPA_CTL_XWDLEN1(word_size);
+	sspa_sp |= SSPA_SP_FPER((bits_per_frame << 1) - 1) |
+		     SSPA_SP_FWID(bits_per_frame - 1);
+
+	sspa_sp |= SSPA_SP_WEN;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mmp2_sspa_write_reg(sspa, SSPA_TXCTL, sspa_ctrl);
+		mmp2_sspa_write_reg(sspa, SSPA_TXFIFO_LL, 0x1);
+		mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp);
+	} else {
+		mmp2_sspa_write_reg(sspa, SSPA_RXCTL, sspa_ctrl);
+		mmp2_sspa_write_reg(sspa, SSPA_RXFIFO_UL, 0x0);
+		mmp2_sspa_write_reg(sspa, SSPA_RXSP, sspa_sp);
+#ifdef CONFIG_CPU_MMP3
+		if (sspa_sp & SSPA_SP_MSL) {
+		/* FIXME: hw issue, for the rx port, can not config the
+		 * master mode in TXSP register. and must clear this bit
+		 * in TXSP register */
+		sspa_sp = mmp2_sspa_read_reg(sspa, SSPA_TXSP);
+		sspa_sp |= SSPA_SP_WEN;
+		mmp2_sspa_write_reg(sspa, SSPA_TXSP, sspa_sp & ~SSPA_SP_MSL);
+		}
+#endif
+	}
+
+	mmp2_sspa_dump_reg(sspa);
+
+	dma_data = mmp2_sspa_get_dma_params(cpu_dai->id, sspa, as_width,
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+
+	return 0;
+}
+
+static int mmp3_sspa_trigger(struct snd_pcm_substream *substream,
+			     int cmd, struct snd_soc_dai *cpu_dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(cpu_dai);
+	struct ssp_device *sspa = priv->sspa;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/*
+		 * whatever playback or capture, must enable rx.
+		 * this is a hw issue, so need check if rx has been
+		 * enabled or not; if has been enabled by another
+		 * stream, do not enable again.
+		 */
+		if (!priv->running_cnt)
+			mmp2_sspa_rx_enable(sspa);
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			mmp2_sspa_tx_enable(sspa);
+
+		priv->running_cnt++;
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		priv->running_cnt--;
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			mmp2_sspa_tx_disable(sspa);
+
+		/* have no capture stream, disable rx port */
+		if (!priv->running_cnt)
+			mmp2_sspa_rx_disable(sspa);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#define PXA688_SSPA_RATES 0xffffffff
+#define PXA688_SSPA_FORMATS 0xffffffff
+
+static struct snd_soc_dai_ops mmp3_sspa_dai_ops = {
+	.startup = mmp3_sspa_startup,
+	.shutdown = mmp3_sspa_shutdown,
+	.trigger = mmp3_sspa_trigger,
+	.hw_params = mmp3_sspa_hw_params,
+	.set_sysclk = mmp3_sspa_set_dai_sysclk,
+	.set_clkdiv	= mmp2_sspa_set_dai_clkdiv,
+	.set_pll	= mmp2_sspa_set_dai_pll,
+	.set_fmt	= mmp2_sspa_set_dai_fmt,
+};
+
+static int mmp3_sspa_probe(struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv;
+	int ret;
+
+	priv = kzalloc(sizeof(struct sspa_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->sspa = sspa_request(dai->id + 1, "SSPA");
+	if (priv->sspa == NULL) {
+		ret = -ENODEV;
+		goto err_priv;
+	}
+
+	priv->dai_fmt = (unsigned int)-1;
+	snd_soc_dai_set_drvdata(dai, priv);
+
+	return 0;
+
+err_priv:
+	kfree(priv);
+	return ret;
+}
+
+static int mmp3_sspa_remove(struct snd_soc_dai *dai)
+{
+	struct sspa_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+	sspa_free(priv->sspa);
+	kfree(priv);
+	return 0;
+}
+
+struct snd_soc_dai_driver mmp3_sspa_dai = {
+	.probe = mmp3_sspa_probe,
+	.remove = mmp3_sspa_remove,
+	.suspend = mmp3_sspa_suspend,
+	.resume = mmp3_sspa_resume,
+	.playback = {
+		     .channels_min = 1,
+		     .channels_max = 128,
+		     .rates = PXA688_SSPA_RATES,
+		     .formats = PXA688_SSPA_FORMATS,},
+	.capture = {
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = PXA688_SSPA_RATES,
+		    .formats = PXA688_SSPA_FORMATS,},
+	.ops = &mmp3_sspa_dai_ops,
+};
+EXPORT_SYMBOL_GPL(mmp3_sspa_dai);
+
+static __devinit int asoc_sspa_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_dai(&pdev->dev, &mmp3_sspa_dai);
+}
+
+static int __devexit asoc_sspa_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_dai(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver asoc_sspa_driver = {
+	.driver = {
+		   .name = "mmp3-sspa-dai",
+		   .owner = THIS_MODULE,
+		   },
+
+	.probe = asoc_sspa_probe,
+	.remove = __devexit_p(asoc_sspa_remove),
+};
+
+static int __init mmp3_sspa_modinit(void)
+{
+	return platform_driver_register(&asoc_sspa_driver);
+}
+
+module_init(mmp3_sspa_modinit);
+
+static void __exit mmp3_sspa_exit(void)
+{
+	platform_driver_unregister(&asoc_sspa_driver);
+}
+
+module_exit(mmp3_sspa_exit);
+/* Module information */
+MODULE_AUTHOR("zhouqiao@marvell.com");
+MODULE_DESCRIPTION("MMP3 SSPA SoC Interface");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/pxa/mmp2-sspa.h b/sound/soc/pxa/mmp2-sspa.h
new file mode 100644
index 0000000..4989b08
--- /dev/null
+++ b/sound/soc/pxa/mmp2-sspa.h
@@ -0,0 +1,28 @@
+/*
+ * linux/sound/soc/pxa/pxa688-sspa.h
+ *
+ * Copyright (C) 2007 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef _PXA688_SSPA_H
+#define _PXA688_SSPA_H
+
+extern struct ssp_device *sspa_request(int port, const char *label);
+extern void sspa_free(struct ssp_device *);
+extern struct snd_soc_dai_driver pxa688_sspa_dai;
+
+#endif
diff --git a/sound/soc/pxa/qseven.c b/sound/soc/pxa/qseven.c
new file mode 100644
index 0000000..596a9b3
--- /dev/null
+++ b/sound/soc/pxa/qseven.c
@@ -0,0 +1,757 @@
+/*
+ * linux/sound/soc/pxa/qseven.c
+ *
+ * Copyright (C) 2009 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <linux/i2c.h>
+
+#include <asm/mach-types.h>
+#include <linux/io.h>
+
+#include <linux/uaccess.h>
+#include <plat/ssp.h>
+#include <mach/addr-map.h>
+#include <mach/regs-sspa.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-apmu.h>
+
+#include <linux/mfd/wm8994/registers.h>
+#include "../codecs/wm8994.h"
+#include "../codecs/wm8731.h"
+#include "mmp2-squ.h"
+#include "mmp2-sspa.h"
+#include <linux/delay.h>
+
+#define MMP3ASOC_SAMPLE_RATES SNDRV_PCM_RATE_44100
+
+#define MMP3ASOC_HEADPHONE_FUNC		0
+#define MMP3ASOC_HS_MIC_FUNC		1
+#define MMP3ASOC_SPK_FUNC		2
+#define MMP3ASOC_MAIN_MIC_FUNC		3
+#define MMP3ASOC_JACK_FUNC		4
+
+#define MMP3ASOC_CTRL_ON	0
+#define MMP3ASOC_CTRL_OFF	1
+
+static int mmp3asoc_headphone_func;
+static int mmp3asoc_hs_mic_func;
+static int mmp3asoc_spk_func;
+static int mmp3asoc_main_mic_func;
+static int mmp3_qseven_jack;
+
+static void mmp3asoc_ext_control(struct snd_soc_dapm_context *dapm, int func)
+{
+	switch (func) {
+	case MMP3ASOC_HEADPHONE_FUNC:
+		if (mmp3asoc_headphone_func == MMP3ASOC_CTRL_ON)
+			snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+		else
+			snd_soc_dapm_disable_pin(dapm, "Headphone Jack");
+		break;
+	case MMP3ASOC_HS_MIC_FUNC:
+		if (mmp3asoc_hs_mic_func == MMP3ASOC_CTRL_ON)
+			snd_soc_dapm_enable_pin(dapm, "Headset Jack");
+		else
+			snd_soc_dapm_disable_pin(dapm, "Headset Jack");
+		break;
+	default:
+		pr_err("wrong func type\n");
+		return;
+	}
+
+	snd_soc_dapm_sync(dapm);
+	return;
+}
+
+static int qseven_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mmp3_qseven_jack;
+	return 0;
+}
+
+static int qseven_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	if (mmp3_qseven_jack == ucontrol->value.integer.value[0])
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	mmp3_qseven_jack = ucontrol->value.integer.value[0];
+
+	if (mmp3_qseven_jack == 0) {
+		mmp3asoc_headphone_func =  MMP3ASOC_CTRL_OFF;
+		mmp3asoc_hs_mic_func = MMP3ASOC_CTRL_OFF;
+		mmp3asoc_ext_control(dapm, MMP3ASOC_HEADPHONE_FUNC);
+		mmp3asoc_ext_control(dapm, MMP3ASOC_HS_MIC_FUNC);
+	} else {
+		mmp3asoc_headphone_func =  MMP3ASOC_CTRL_ON;
+		mmp3asoc_hs_mic_func = MMP3ASOC_CTRL_ON;
+		mmp3asoc_ext_control(dapm, MMP3ASOC_HEADPHONE_FUNC);
+		mmp3asoc_ext_control(dapm, MMP3ASOC_HS_MIC_FUNC);
+	}
+	mutex_unlock(&codec->mutex);
+	return 1;
+}
+
+static int mmp3asoc_get_headphone(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mmp3asoc_headphone_func;
+	return 0;
+}
+
+static int mmp3asoc_set_headphone(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	if (mmp3asoc_headphone_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	mmp3asoc_headphone_func = ucontrol->value.integer.value[0];
+	mmp3asoc_ext_control(dapm, MMP3ASOC_HEADPHONE_FUNC);
+	mutex_unlock(&codec->mutex);
+	return 1;
+}
+
+static int mmp3asoc_get_hs_mic(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mmp3asoc_hs_mic_func;
+	return 0;
+}
+
+static int mmp3asoc_set_hs_mic(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	if (mmp3asoc_hs_mic_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	mmp3asoc_hs_mic_func = ucontrol->value.integer.value[0];
+	mmp3asoc_ext_control(dapm, MMP3ASOC_HS_MIC_FUNC);
+	mutex_unlock(&codec->mutex);
+	return 1;
+}
+
+static int mmp3asoc_get_spk(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mmp3asoc_spk_func;
+	return 0;
+}
+
+static int mmp3asoc_set_spk(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	if (mmp3asoc_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	mmp3asoc_spk_func = ucontrol->value.integer.value[0];
+	mmp3asoc_ext_control(dapm, MMP3ASOC_SPK_FUNC);
+	mutex_unlock(&codec->mutex);
+	return 1;
+}
+
+static int mmp3asoc_get_main_mic(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = mmp3asoc_main_mic_func;
+	return 0;
+}
+
+static int mmp3asoc_set_main_mic(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	if (mmp3asoc_main_mic_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	mutex_lock(&codec->mutex);
+	mmp3asoc_main_mic_func = ucontrol->value.integer.value[0];
+	mmp3asoc_ext_control(dapm, MMP3ASOC_MAIN_MIC_FUNC);
+	mutex_unlock(&codec->mutex);
+	return 1;
+}
+
+static const struct snd_soc_dapm_widget mmp3asoc_dapm_widgets[] = {
+	SND_SOC_DAPM_SPK("Ext Left Spk", NULL),
+	SND_SOC_DAPM_SPK("Ext Right Spk", NULL),
+	SND_SOC_DAPM_HP("Headset Stereophone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Main Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route mmp3asoc_dapm_routes[] = {
+	{"Ext Left Spk", NULL, "SPKOUTLP"},
+	{"Ext Left Spk", NULL, "SPKOUTLN"},
+
+	{"Ext Right Spk", NULL, "SPKOUTRP"},
+	{"Ext Right Spk", NULL, "SPKOUTRN"},
+
+	{"Headset Stereophone", NULL, "HPOUT1L"},
+	{"Headset Stereophone", NULL, "HPOUT1R"},
+
+	{"IN1RN", NULL, "MICBIAS2"},
+	{"MICBIAS2", NULL, "Headset Mic"},
+
+	{"IN1LP", NULL, "MICBIAS1"},
+	{"IN1LN", NULL, "MICBIAS1"},
+	{"MICBIAS1", NULL, "Main Mic"},
+};
+
+static const char *headphone_function[] = {"On", "Off"};
+static const char *hs_mic_function[] = {"On", "Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const char *main_mic_function[] = {"On", "Off"};
+
+static const struct soc_enum mmp3asoc_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, headphone_function),
+	SOC_ENUM_SINGLE_EXT(2, hs_mic_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+	SOC_ENUM_SINGLE_EXT(2, main_mic_function),
+};
+
+
+static const struct snd_kcontrol_new mmp3asoc_wm8994_controls[] = {
+	SOC_ENUM_EXT("Headphone Function", mmp3asoc_enum[0],
+		     mmp3asoc_get_headphone, mmp3asoc_set_headphone),
+	SOC_ENUM_EXT("Headset Mic Function", mmp3asoc_enum[1],
+		     mmp3asoc_get_hs_mic, mmp3asoc_set_hs_mic),
+	SOC_ENUM_EXT("Speaker Function", mmp3asoc_enum[2],
+		     mmp3asoc_get_spk, mmp3asoc_set_spk),
+	SOC_ENUM_EXT("Main Mic Function", mmp3asoc_enum[3],
+		     mmp3asoc_get_main_mic, mmp3asoc_set_main_mic),
+};
+
+/* qseven machine dapm widgets */
+static const struct snd_soc_dapm_widget wm8731_qseven_dapm_widgets[] = {
+SND_SOC_DAPM_HP("Headphone Jack", NULL),
+SND_SOC_DAPM_HP("Headset Jack", NULL),
+};
+
+/* qseven machine audio map (connections to the codec pins) */
+static const struct snd_soc_dapm_route qseven_audio_map[] = {
+
+	/* headset Jack  - in = micin, out = LHPOUT*/
+	{"Headset Jack", NULL, "LHPOUT"},
+	{"Headset Jack", NULL, "RHPOUT"},
+
+	/* headphone connected to LHPOUT1, RHPOUT1 */
+	{"Headphone Jack", NULL, "LHPOUT"},
+	{"Headphone Jack", NULL, "RHPOUT"},
+	{"MICIN", NULL, "Headphone Jack"},
+
+	/* speaker connected to LOUT, ROUT
+	{"Ext Spk", NULL, "ROUT"},
+	{"Ext Spk", NULL, "LOUT"},
+
+	mic is connected to MICIN (via right channel of headphone jack)
+	{"MICIN", NULL, "Mic Jack"},
+
+	Same as the above but no mic bias for line signals
+	{"MICIN", NULL, "Line Jack"},*/
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset",
+	"Off"};
+static const struct soc_enum qseven_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+};
+
+static const struct snd_kcontrol_new wm8731_qseven_controls[] = {
+	SOC_ENUM_EXT("Jack Function", qseven_enum[0], qseven_get_jack,
+		qseven_set_jack),
+};
+
+static int codec_hdmi_init(struct snd_soc_pcm_runtime *rtd)
+{
+	return 0;
+}
+
+static struct platform_device *mmp3asoc_snd_device[2];
+
+#define __raw_modify(addr, toclear, toset)		\
+	do {						\
+		volatile unsigned int tval;		\
+		tval = __raw_readl(addr);		\
+		tval &= ~toclear;			\
+		tval |= toset;				\
+		__raw_writel(tval, (addr));		\
+		tval = __raw_readl(addr);		\
+		udelay(100);				\
+	} while (0)
+
+static void audio_subsystem_poweron(void)
+{
+	printk(KERN_INFO " audio subsystem power on (A stepping) 0x%08x\n",
+	       __raw_readl(APMU_REG(0x220)));
+
+	/* enable power switch 01 */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0, (1u << 9));
+	/* enable power switch 11 */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0, (2u << 9));
+	/* enable SRAM power */
+	__raw_modify(APMU_AUDIO_SRAM_PWR, 0, 0x5);
+	__raw_modify(APMU_AUDIO_SRAM_PWR, 0, 0xa);
+	__raw_modify(APMU_AUDIO_SRAM_PWR, 0, 0xc0);
+	/* audio island */
+	__raw_modify(APMU_ISLD_DSPA_CTRL, 0x7, 0);
+	__raw_modify(APMU_ISLD_DSPA_CTRL, 0, (1u << 4));
+	__raw_modify(APMU_ISLD_DSPA_CTRL, (1u << 4), 0);
+	/* audio DSA */
+	__raw_modify(APMU_AUDIO_DSA, 0xf, 0xa);
+	__raw_modify(APMU_AUDIO_DSA, 0xf, 0xf);
+	/* SSPA1 BIT/SYSCLK */
+	__raw_writel(0xd3ee2276, MPMU_ISCCRX0);
+	__raw_writel(0xd0040040, MPMU_ISCCRX1);
+	/* disable isolation */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0, (1u << 8));
+	/* enable peripheral */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0, (1u << 4));
+	/* pull peripheral out of reset */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0, (1u << 1));
+
+	/* Audio CFG: DSP core will stall after release from reset */
+	__raw_modify(DSP_AUDIO_CONFIG_REG, (1u << 1), 0);
+	/* DSP core clock : enable clock divier  */
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, 0, (1u << 3));
+	/* Release the core reset */
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, 0, (1u << 0));
+	/* Release the AXI reset */
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, 0, (1u << 1));
+
+	/* devices */
+	udelay(100);
+	__raw_writel(0x8, DSA_SSP_CLK_RES_CTRL);
+	__raw_writel(0x9, DSA_SSP_CLK_RES_CTRL);
+	udelay(100);
+	__raw_writel(0x8, DSA_ABU_CLK_RES_CTRL);
+	__raw_writel(0x9, DSA_ABU_CLK_RES_CTRL);
+	udelay(100);
+
+	__raw_modify(MPMU_CCGR, 0, 0x20);
+
+	udelay(1000);
+}
+
+static void audio_subsystem_poweroff(void)
+{
+	/* enable isolation */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x100, 0);
+	/* assert AXI and peripheral reset */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x3, 0);
+	/* gate axi and peripheral clock */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x18, 0);
+	/* power off */
+	__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x600, 0);
+}
+
+static void audio_subsystem_pll_config(void)
+{
+	/* select audio pll: Fvco = 135.4752MHz; OCLK = 11.2896MHz;
+	 * DIV_MCLK[1:0] = 0b10;
+	 * DIV_MODULO[2:0] = 0b010;
+	 * FRACT[27:8] = 0x8a18;
+	 * DIV_FBCCLK[1:0] = 0b00; */
+	__raw_writel(0x908a1899, SSPA_AUD_PLL_CTRL0);
+	msleep(100);
+
+	/* sspa_aud_pll_ctrl1[11] = 1 to choose audio PLL
+	 * div : 12, 44.1K
+	 * DIV_OCLK_PATTERN[1:0] = 0b01; */
+	__raw_writel(0x2e010801, SSPA_AUD_PLL_CTRL1);
+	msleep(100);
+
+	/* audio clock select: choose separate clock source for sspa1 and sspa2.
+	 * sspa_aud_ctrl[7] = 0, sspa1 chooses pm_vctcxo;
+	 * sspa_aud_ctrl[23] = 0, sspa2 chooses i2s_sc_apb; */
+	__raw_writel(0x111109, SSPA_AUD_CTRL);
+	msleep(100);
+
+	/* Switch the source clock for core and AXI clock to Audio PLL*/
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, 0x0, (1u << 2));
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, 0x0, (3u << 4));
+	__raw_modify(DSA_CORE_CLK_RES_CTRL, (1u << 2), 0x0);
+
+}
+
+static int codec_wm8731_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int err;
+
+	audio_subsystem_poweron();
+	/* currently the audio pll of mmp3 a0 stepping is not working */
+	audio_subsystem_pll_config();
+
+	snd_soc_dapm_nc_pin(dapm, "LLINEIN");
+	snd_soc_dapm_nc_pin(dapm, "RLINEIN");
+
+	/* Add mmp3asoc specific controls */
+	err = snd_soc_add_codec_controls(codec, wm8731_qseven_controls,
+				   ARRAY_SIZE(wm8731_qseven_controls));
+	if (err < 0)
+		return err;
+
+	/* add mmp3asoc specific widgets */
+	snd_soc_dapm_new_controls(dapm, wm8731_qseven_dapm_widgets,
+				  ARRAY_SIZE(wm8731_qseven_dapm_widgets));
+
+	/* set up mmp3asoc specific audio routes */
+	snd_soc_dapm_add_routes(dapm, qseven_audio_map,
+				ARRAY_SIZE(qseven_audio_map));
+
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(dapm, "Headset Jack");
+
+	/* init: disable HEADSET, enable SPK */
+	mutex_lock(&codec->mutex);
+	mmp3asoc_headphone_func = MMP3ASOC_CTRL_ON;
+	mmp3asoc_hs_mic_func = MMP3ASOC_CTRL_ON;
+	mmp3_qseven_jack = MMP3ASOC_CTRL_ON;
+	snd_soc_dapm_sync(dapm);
+	mutex_unlock(&codec->mutex);
+
+	return 0;
+}
+
+static int mmp3asoc_probe(struct snd_soc_card *card)
+{
+	return 0;
+}
+
+static int mmp3asoc_hdmi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+	cpu_dai->driver->playback.channels_min = 2;
+	cpu_dai->driver->playback.channels_max = 2;
+
+	cpu_dai->driver->playback.formats = SNDRV_PCM_FMTBIT_S16_LE;
+	cpu_dai->driver->playback.rates = MMP3ASOC_SAMPLE_RATES;
+
+	return 0;
+}
+
+static int mmp3asoc_hdmi_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int freq_in, freq_out, sspa_mclk, sysclk, sspa_div;
+
+	pr_debug("%s: enter, rate %d\n", __func__, params_rate(params));
+
+	freq_in = 26000000;
+	if (params_rate(params) > 11025) {
+		freq_out = params_rate(params) * 512;
+		sysclk = params_rate(params) * 256;
+		sspa_mclk = params_rate(params) * 64;
+	} else {
+		freq_out = params_rate(params) * 1024;
+		sysclk = params_rate(params) * 512;
+		sspa_mclk = params_rate(params) * 64;
+	}
+	sspa_div = freq_out;
+	do_div(sspa_div, sspa_mclk);
+
+#ifdef CONFIG_SND_HDMI_MASTER_MODE
+	snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+#else
+	snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+#endif
+
+	/* workaround for audio PLL, and should be removed after A1 */
+	switch (params_rate(params)) {
+	case 48000:
+		__raw_writel(0xd0040040, MPMU_ISCCRX1);
+		break;
+	case 44100:
+		__raw_writel(0xd0040044, MPMU_ISCCRX1);
+		break;
+	case 32000:
+		__raw_writel(0xd00800c0, MPMU_ISCCRX1);
+		break;
+	case 24000:
+		__raw_writel(0xd0020040, MPMU_ISCCRX1);
+		break;
+	case 22050:
+		__raw_writel(0xd0020044, MPMU_ISCCRX1);
+		break;
+	case 16000:
+		__raw_writel(0xd00400c0, MPMU_ISCCRX1);
+		break;
+	case 8000:
+		__raw_writel(0xd00400c0, MPMU_ISCCRX1);
+		break;
+	default:
+		break;
+	}
+
+	snd_soc_dai_set_pll(cpu_dai, SSPA_AUDIO_PLL, 0, freq_in, freq_out);
+	snd_soc_dai_set_clkdiv(cpu_dai, 0, sspa_div);
+	snd_soc_dai_set_sysclk(cpu_dai, 0, sysclk, 0);
+
+	return 0;
+}
+static int mmp3asoc_wm8731_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	cpu_dai->driver->playback.formats = SNDRV_PCM_FMTBIT_S16_LE;
+	cpu_dai->driver->capture.formats = SNDRV_PCM_FMTBIT_S16_LE;
+	cpu_dai->driver->playback.rates = MMP3ASOC_SAMPLE_RATES;
+	cpu_dai->driver->capture.rates = MMP3ASOC_SAMPLE_RATES;
+
+	mmp3asoc_headphone_func =  MMP3ASOC_CTRL_ON;
+	mmp3asoc_hs_mic_func = MMP3ASOC_CTRL_ON;
+	mmp3asoc_ext_control(dapm, MMP3ASOC_HEADPHONE_FUNC);
+	mmp3asoc_ext_control(dapm, MMP3ASOC_HS_MIC_FUNC);
+	/* turn on micbias 1/2 always */
+	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
+			    WM8994_MICB1_ENA_MASK |
+			    WM8994_MICB2_ENA_MASK,
+			    WM8994_MICB1_ENA |
+			    WM8994_MICB2_ENA);
+
+	return 0;
+}
+
+static int mmp3asoc_wm8731_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	int freq_in, freq_out, sspa_mclk, sysclk, sspa_div;
+
+	pr_info("%s: enter, rate %d\n", __func__, params_rate(params));
+	freq_in = 26000000;
+	if (params_rate(params) > 11025) {
+		freq_out = params_rate(params) * 512;
+		sysclk = params_rate(params) * 256;
+		sspa_mclk = params_rate(params) * 64;
+	} else {
+		freq_out = params_rate(params) * 1024;
+		sysclk = params_rate(params) * 512;
+		sspa_mclk = params_rate(params) * 64;
+	}
+	sspa_div = freq_out;
+	do_div(sspa_div, sspa_mclk);
+
+#ifdef CONFIG_SND_WM8731_MASTER_MODE
+	snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+#else
+	snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+	snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+			    SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBS_CFS);
+#endif
+
+	/* workaround for audio PLL, and should be removed after A1 */
+	/* SSPA2 clock formula: sysclk = (PLL1/4) * ISCCR1 Nom/Denom4
+	 * for 48k, the sysclk should be 12.2880MHz, but here we only get
+	 * approximate 12.458MHz, only for test purpose */
+	switch (params_rate(params)) {
+	case 48000:
+		__raw_writel(0xd0040040, MPMU_ISCCRX1);
+		break;
+	case 44100:
+		__raw_writel(0xd0040044, MPMU_ISCCRX1);
+		break;
+	case 32000:
+		__raw_writel(0xd00800c0, MPMU_ISCCRX1);
+		break;
+	case 24000:
+		__raw_writel(0xd0020040, MPMU_ISCCRX1);
+		break;
+	case 22050:
+		__raw_writel(0xd0020044, MPMU_ISCCRX1);
+		break;
+	case 16000:
+		__raw_writel(0xd00400c0, MPMU_ISCCRX1);
+		break;
+	case 8000:
+		__raw_writel(0xd00400c0, MPMU_ISCCRX1);
+		break;
+	default:
+		break;
+	}
+
+	/* set the codec system clock for DAC and ADC */
+	snd_soc_dai_set_pll(cpu_dai, SSPA_AUDIO_PLL, 0, freq_in, freq_out);
+	snd_soc_dai_set_clkdiv(cpu_dai, 0, sspa_div);
+	snd_soc_dai_set_sysclk(cpu_dai, 0, sysclk, 0);
+
+	/* set wm8731 sysclk */
+	snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK_XTAL, sysclk,
+				SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int mmp3asoc_suspend_post(struct snd_soc_card *card)
+{
+
+	return 0;
+}
+
+static int mmp3asoc_resume_pre(struct snd_soc_card *card)
+{
+
+	return 0;
+}
+
+#endif
+
+/* machine stream operations */
+static struct snd_soc_ops mmp3asoc_machine_ops[] = {
+	{
+	 .startup = mmp3asoc_hdmi_startup,
+	 .hw_params = mmp3asoc_hdmi_hw_params,
+	 },
+	{
+	 .startup = mmp3asoc_wm8731_startup,
+	 .hw_params = mmp3asoc_wm8731_hw_params,
+	 },
+};
+
+/* digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link mmp3_asoc_wm8731_dai[] = {
+	{
+	 .name = "WM8731",
+	 .stream_name = "WM8731",
+	 .codec_name = "wm8731.2-001a",
+	 .platform_name = "mmp3-pcm-audio",
+	 .cpu_dai_name = "mmp3-sspa-dai.1",
+	 .codec_dai_name = "wm8731-hifi",
+	 .ops = &mmp3asoc_machine_ops[1],
+	 .init = codec_wm8731_init,
+	 },
+};
+
+static struct snd_soc_dai_link mmp3_asoc_hdmi_dai[] = {
+	{
+	 .name = "HDMI",
+	 .stream_name = "hdmi Audio",
+	 .codec_name = "dummy-codec",
+	 .platform_name = "mmp3-pcm-audio",
+	 .cpu_dai_name = "mmp3-sspa-dai.0",
+	 .codec_dai_name = "dummy-dai",
+	 .ops = &mmp3asoc_machine_ops[0],
+	 .init = codec_hdmi_init,
+	 },
+};
+
+/* audio machine driver */
+static struct snd_soc_card snd_soc_mmp3asoc[] = {
+	{
+	 .name = "mmp3 asoc",
+	 .dai_link = &mmp3_asoc_wm8731_dai[0],
+	 .num_links = 1,
+	 .probe = mmp3asoc_probe,
+#ifdef CONFIG_PM
+	 .suspend_post = mmp3asoc_suspend_post,
+	 .resume_pre = mmp3asoc_resume_pre,
+#endif
+	 },
+	{
+	 .name = "mmp3 hdmi",
+	 .dai_link = &mmp3_asoc_hdmi_dai[0],
+	 .num_links = 1,
+	 .probe = mmp3asoc_probe,
+	 },
+};
+
+static int __init mmp3asoc_init(void)
+{
+	int i, ret[2];
+
+	if (!machine_is_qseven())
+		return -ENODEV;
+
+	for (i = 0; i < 2; i++) {
+		mmp3asoc_snd_device[i] = platform_device_alloc("soc-audio", i);
+		if (!mmp3asoc_snd_device[i])
+			return -ENOMEM;
+		platform_set_drvdata(mmp3asoc_snd_device[i], &snd_soc_mmp3asoc[i]);
+		ret[i] = platform_device_add(mmp3asoc_snd_device[i]);
+
+		if (ret[i])
+			platform_device_put(mmp3asoc_snd_device[i]);
+	}
+
+	return ret[1];
+}
+
+static void __exit mmp3asoc_exit(void)
+{
+	int i;
+	for (i = 0; i < 2; i++)
+		platform_device_unregister(mmp3asoc_snd_device[i]);
+}
+
+module_init(mmp3asoc_init);
+module_exit(mmp3asoc_exit);
+
+/* Module information */
+MODULE_DESCRIPTION("ALSA SoC WM8994 MMP3");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

