From 5a2af2dd225e9070bcdb66f9cbc63f8965fbbc6b Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 20 Aug 2013 06:47:28 +0800
Subject: [PATCH 40/60] usb: host: get EHCI_MV supported for mmp3

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch updates usb host driver to cater for WRLinux
3.4.x kernel.

Singed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/devices.c |    6 +-
 arch/arm/mach-mmp/mmp3.c    |    8 +-
 arch/arm/mach-mmp/qseven.c  |    2 +-
 drivers/usb/gadget/Kconfig  |    6 ++
 drivers/usb/host/Kconfig    |   25 ++++++
 include/linux/usb/mv_usb.h  |  183 +++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 222 insertions(+), 8 deletions(-)
 create mode 100644 include/linux/usb/mv_usb.h

diff --git a/arch/arm/mach-mmp/devices.c b/arch/arm/mach-mmp/devices.c
index 569066b..33c238e 100644
--- a/arch/arm/mach-mmp/devices.c
+++ b/arch/arm/mach-mmp/devices.c
@@ -192,7 +192,7 @@ void u2o_write(unsigned int base, unsigned int offset, unsigned int value)
 
 }
 
-#if defined(CONFIG_USB_PXA_U2O) || defined(CONFIG_USB_EHCI_PXA)
+#if defined(CONFIG_USB_PXA_U2O) || defined(CONFIG_USB_EHCI_MV)
 
 #ifdef CONFIG_CPU_MMP3
 
@@ -895,7 +895,7 @@ struct platform_device pxa168_device_u2oehci = {
 	.resource	= pxa168_u2oehci_resources,
 };
 
-#if defined(CONFIG_USB_PXA_U2O_OTG)
+#if defined(CONFIG_USB_MV_OTG)
 struct resource pxa168_u2ootg_resources[] = {
 	/* regbase */
 	[0] = {
@@ -929,7 +929,7 @@ struct platform_device pxa168_device_u2ootg = {
 	.num_resources	= ARRAY_SIZE(pxa168_u2ootg_resources),
 	.resource      = pxa168_u2ootg_resources,
 };
-#endif /* CONFIG_USB_PXA_U2O_OTG */
+#endif /* CONFIG_USB_MV_OTG */
 
 #endif
 #endif
diff --git a/arch/arm/mach-mmp/mmp3.c b/arch/arm/mach-mmp/mmp3.c
index d340774..5e9adf5 100644
--- a/arch/arm/mach-mmp/mmp3.c
+++ b/arch/arm/mach-mmp/mmp3.c
@@ -637,7 +637,7 @@ struct platform_device mmp3_device_u2o = {
 };
 #endif
 
-#ifdef CONFIG_USB_EHCI_PXA
+#ifdef CONFIG_USB_EHCI_MV
 #ifdef CONFIG_USB_EHCI_PXA_U2O
 struct resource mmp3_u2oehci_resources[] = {
 	/* regbase */
@@ -673,7 +673,7 @@ struct platform_device mmp3_device_u2oehci = {
 	.resource	= mmp3_u2oehci_resources,
 };
 
-#ifdef CONFIG_USB_PXA_U2O_OTG
+#ifdef CONFIG_USB_MV_OTG
 struct resource mmp3_u2ootg_resources[] = {
 	/* regbase */
 	[0] = {
@@ -708,7 +708,7 @@ struct platform_device mmp3_device_u2ootg = {
 	.resource	= mmp3_u2ootg_resources,
 };
 
-#endif	/* CONFIG_USB_PXA_U2O_OTG */
+#endif	/* CONFIG_USB_MV_OTG */
 #endif  /* CONFIG_USB_EHCI_PXA_U2O */
 
 #ifdef CONFIG_USB_EHCI_PXA_U2H_HSIC
@@ -880,7 +880,7 @@ struct platform_device mmp3_fsic_device = {
 
 #endif
 
-#endif  /* CONFIG_USB_EHCI_PXA */
+#endif  /* CONFIG_USB_EHCI_MV */
 #endif  /* CONFIG_USB_SUPPORT */
 #ifdef CONFIG_UIO_VMETA
 /* vmeta soc specific functions */
diff --git a/arch/arm/mach-mmp/qseven.c b/arch/arm/mach-mmp/qseven.c
index 6bea051c..ad7064c 100644
--- a/arch/arm/mach-mmp/qseven.c
+++ b/arch/arm/mach-mmp/qseven.c
@@ -967,7 +967,7 @@ static void __init qseven_init(void)
 	mmp3_device_u2oehci.dev.platform_data = (void *)&mmp3_usb_pdata;
 	platform_device_register(&mmp3_device_u2oehci);
 
-#ifdef CONFIG_USB_PXA_U2O_OTG
+#ifdef CONFIG_USB_MV_OTG
 	mmp3_device_u2ootg.dev.platform_data = (void *)&mmp3_usb_pdata;
 	platform_device_register(&mmp3_device_u2ootg);
 #endif
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 8b4f29f..bdf9878 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -341,6 +341,12 @@ config USB_MV_UDC
 	  USB2.0 OTG controller, which can be configured as high speed or
 	  full speed USB peripheral.
 
+config USB_PXA_U2O
+	bool
+	depends on USB_MV_UDC
+	select USB_GADGET_SELECTED
+	default y if CPU_MMP3
+
 #
 # Controllers available in both integrated and discrete versions
 #
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c532b6e..c7d5010 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -248,6 +248,31 @@ config USB_EHCI_MV
 	  USB SPH and OTG controller. SPH is a single port host, and it can
 	  only be EHCI host. OTG is controller that can switch to host mode.
 
+config USB_EHCI_PXA_U2O
+	bool "EHCI support for PXA USB OTG controller"
+	depends on USB_EHCI_MV
+	default y if CPU_MMP3
+	---help---
+	   Enables support for OTG controller. OTG is controller
+	   that can switch to be host mode.
+
+config USB_EHCI_PXA_U2H_HSIC
+	bool "EHCI support for PXA USB SPH of HSIC"
+	depends on USB_EHCI_MV
+	---help---
+	  Enables support for PXA USB SPH HSIC. SPH is a
+	  single port host, and it can only be EHCI host. HSIC can only
+	  run in High Speed.
+
+config USB_EHCI_PXA_U2H_FSIC
+	bool "EHCI support for PXA USB SPH of FSIC"
+	depends on USB_EHCI_MV
+	default y if CPU_MMP3
+	---help---
+	  Enables support for PXA USB SPH FSIC. SPH is a
+	  single port host, and it can only be EHCI host. FSIC can only
+	  run in full Speed.
+
 config USB_W90X900_EHCI
 	bool "W90X900(W90P910) EHCI support"
 	depends on USB_EHCI_HCD && ARCH_W90X900
diff --git a/include/linux/usb/mv_usb.h b/include/linux/usb/mv_usb.h
new file mode 100644
index 0000000..a64ca88
--- /dev/null
+++ b/include/linux/usb/mv_usb.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __MV_USB_H
+#define __MV_USB_H
+
+#define VUSBHS_MAX_PORTS	8
+#define CAPLENGTH_MASK		(0xff)
+#define DCCPARAMS_DEN_MASK	(0x1f)
+
+#define HCSPARAMS_PPC		(0x10)
+
+/* Frame Index Register Bit Masks */
+#define USB_FRINDEX_MASKS	0x3fff
+
+/* Command Register Bit Masks */
+#define USBCMD_RUN_STOP				(0x00000001)
+#define USBCMD_CTRL_RESET			(0x00000002)
+#define USBCMD_SETUP_TRIPWIRE_SET		(0x00002000)
+#define USBCMD_SETUP_TRIPWIRE_CLEAR		(~USBCMD_SETUP_TRIPWIRE_SET)
+
+/* add dTD tripwire */
+#define USBCMD_ATDTW_TRIPWIRE_SET		(0x00004000)
+#define USBCMD_ATDTW_TRIPWIRE_CLEAR		(~USBCMD_ATDTW_TRIPWIRE_SET)
+
+/* bit 15,3,2 are for frame list size */
+#define USBCMD_FRAME_SIZE_1024			(0x00000000) /* 000 */
+#define USBCMD_FRAME_SIZE_512			(0x00000004) /* 001 */
+#define USBCMD_FRAME_SIZE_256			(0x00000008) /* 010 */
+#define USBCMD_FRAME_SIZE_128			(0x0000000C) /* 011 */
+#define USBCMD_FRAME_SIZE_64			(0x00008000) /* 100 */
+#define USBCMD_FRAME_SIZE_32			(0x00008004) /* 101 */
+#define USBCMD_FRAME_SIZE_16			(0x00008008) /* 110 */
+#define USBCMD_FRAME_SIZE_8			(0x0000800C) /* 111 */
+
+#define EPCTRL_TX_ALL_MASK			(0xFFFF0000)
+#define EPCTRL_RX_ALL_MASK			(0x0000FFFF)
+
+#define EPCTRL_TX_DATA_TOGGLE_RST		(0x00400000)
+#define EPCTRL_TX_EP_STALL			(0x00010000)
+#define EPCTRL_RX_EP_STALL			(0x00000001)
+#define EPCTRL_RX_DATA_TOGGLE_RST		(0x00000040)
+#define EPCTRL_RX_ENABLE			(0x00000080)
+#define EPCTRL_TX_ENABLE			(0x00800000)
+#define EPCTRL_CONTROL				(0x00000000)
+#define EPCTRL_ISOCHRONOUS			(0x00040000)
+#define EPCTRL_BULK				(0x00080000)
+#define EPCTRL_INT				(0x000C0000)
+#define EPCTRL_TX_TYPE				(0x000C0000)
+#define EPCTRL_RX_TYPE				(0x0000000C)
+#define EPCTRL_DATA_TOGGLE_INHIBIT		(0x00000020)
+#define EPCTRL_TX_EP_TYPE_SHIFT			(18)
+#define EPCTRL_RX_EP_TYPE_SHIFT			(2)
+
+#define EPCOMPLETE_MAX_ENDPOINTS		(16)
+
+/* endpoint list address bit masks */
+#define USB_EP_LIST_ADDRESS_MASK              0xfffff800
+
+#define PORTSCX_W1C_BITS			0x2a
+#define PORTSCX_PORT_DM				(1 << 10)
+#define PORTSCX_PORT_DP				(1 << 11)
+#define PORTSCX_PORT_RESET			0x00000100
+#define PORTSCX_PORT_POWER			0x00001000
+#define PORTSCX_FORCE_FULL_SPEED_CONNECT	0x01000000
+#define PORTSCX_PAR_XCVR_SELECT			0xC0000000
+#define PORTSCX_PORT_FORCE_RESUME		0x00000040
+#define PORTSCX_PORT_SUSPEND			0x00000080
+#define PORTSCX_PORT_SPEED_FULL			0x00000000
+#define PORTSCX_PORT_SPEED_LOW			0x04000000
+#define PORTSCX_PORT_SPEED_HIGH			0x08000000
+#define PORTSCX_PORT_SPEED_MASK			0x0C000000
+
+/* otgsc Register Bit Masks */
+#define OTGSC_CTRL_VUSB_DISCHARGE		0x00000001
+#define OTGSC_CTRL_VUSB_CHARGE			0x00000002
+#define OTGSC_CTRL_OTG_TERM			0x00000008
+#define OTGSC_CTRL_DATA_PULSING			0x00000010
+#define OTGSC_STS_USB_ID			0x00000100
+#define OTGSC_STS_A_VBUS_VALID			0x00000200
+#define OTGSC_STS_A_SESSION_VALID		0x00000400
+#define OTGSC_STS_B_SESSION_VALID		0x00000800
+#define OTGSC_STS_B_SESSION_END			0x00001000
+#define OTGSC_STS_1MS_TOGGLE			0x00002000
+#define OTGSC_STS_DATA_PULSING			0x00004000
+#define OTGSC_INTSTS_USB_ID			0x00010000
+#define OTGSC_INTSTS_A_VBUS_VALID		0x00020000
+#define OTGSC_INTSTS_A_SESSION_VALID		0x00040000
+#define OTGSC_INTSTS_B_SESSION_VALID		0x00080000
+#define OTGSC_INTSTS_B_SESSION_END		0x00100000
+#define OTGSC_INTSTS_1MS			0x00200000
+#define OTGSC_INTSTS_DATA_PULSING		0x00400000
+#define OTGSC_INTR_USB_ID			0x01000000
+#define OTGSC_INTR_A_VBUS_VALID			0x02000000
+#define OTGSC_INTR_A_SESSION_VALID		0x04000000
+#define OTGSC_INTR_B_SESSION_VALID		0x08000000
+#define OTGSC_INTR_B_SESSION_END		0x10000000
+#define OTGSC_INTR_1MS_TIMER			0x20000000
+#define OTGSC_INTR_DATA_PULSING			0x40000000
+
+/* USB MODE Register Bit Masks */
+#define USBMODE_CTRL_MODE_IDLE			0x00000000
+#define USBMODE_CTRL_MODE_DEVICE		0x00000002
+#define USBMODE_CTRL_MODE_HOST			0x00000003
+#define USBMODE_CTRL_MODE_RSV			0x00000001
+#define USBMODE_CTRL_MODE_MASK			0x00000003
+#define USBMODE_SETUP_LOCK_OFF			0x00000008
+#define USBMODE_STREAM_DISABLE			0x00000010
+
+/* USB STS Register Bit Masks */
+#define USBSTS_INT			0x00000001
+#define USBSTS_ERR			0x00000002
+#define USBSTS_PORT_CHANGE		0x00000004
+#define USBSTS_FRM_LST_ROLL		0x00000008
+#define USBSTS_SYS_ERR			0x00000010
+#define USBSTS_IAA			0x00000020
+#define USBSTS_RESET			0x00000040
+#define USBSTS_SOF			0x00000080
+#define USBSTS_SUSPEND			0x00000100
+#define USBSTS_HC_HALTED		0x00001000
+#define USBSTS_RCL			0x00002000
+#define USBSTS_PERIODIC_SCHEDULE	0x00004000
+#define USBSTS_ASYNC_SCHEDULE		0x00008000
+
+
+/* Interrupt Enable Register Bit Masks */
+#define USBINTR_INT_EN                          (0x00000001)
+#define USBINTR_ERR_INT_EN                      (0x00000002)
+#define USBINTR_PORT_CHANGE_DETECT_EN           (0x00000004)
+
+#define USBINTR_ASYNC_ADV_AAE                   (0x00000020)
+#define USBINTR_ASYNC_ADV_AAE_ENABLE            (0x00000020)
+#define USBINTR_ASYNC_ADV_AAE_DISABLE           (0xFFFFFFDF)
+
+#define USBINTR_RESET_EN                        (0x00000040)
+#define USBINTR_SOF_UFRAME_EN                   (0x00000080)
+#define USBINTR_DEVICE_SUSPEND                  (0x00000100)
+
+#define USB_DEVICE_ADDRESS_MASK			(0xfe000000)
+#define USB_DEVICE_ADDRESS_BIT_SHIFT		(25)
+
+struct mv_cap_regs {
+	u32	caplength_hciversion;
+	u32	hcsparams;	/* HC structural parameters */
+	u32	hccparams;	/* HC Capability Parameters*/
+	u32	reserved[5];
+	u32	dciversion;	/* DC version number and reserved 16 bits */
+	u32	dccparams;	/* DC Capability Parameters */
+};
+
+struct mv_op_regs {
+	u32	usbcmd;		/* Command register  */
+	u32	usbsts;		/* Status register */
+	u32	usbintr;	/* Interrupt enable */
+	u32	frindex;	/* Frame index */
+	u32	reserved1[1];
+	u32	deviceaddr;	/* Device Address */
+	u32	eplistaddr;	/* Endpoint List Address */
+	u32	ttctrl;		/* HOST TT status and control */
+	u32	burstsize;	/* Programmable Burst Size */
+	u32	txfilltuning;	/* Host Transmit Pre-Buffer Packet Tuning */
+	u32	reserved[4];	/*  0x016c, 0x0170, 0x0174) */
+	u32	epnak;		/* Endpoint NAK */
+	u32	epnaken;	/* Endpoint NAK Enable */
+	u32	configflag;	/* Configured Flag register */
+	u32	portsc[VUSBHS_MAX_PORTS]; /* Port Status/Control x, x = 1..8 */
+	u32	otgsc;		/* OTG Status and Control Register */
+	u32	usbmode;	/* USB Host/Device mode */
+	u32	epsetupstat;	/* Endpoint Setup Status */
+	u32	epprime;	/* Endpoint Initialize */
+	u32	epflush;	/* Endpoint De-initialize */
+	u32	epstatus;	/* Endpoint Status */
+	u32	epcomplete;	/* Endpoint Interrupt On Complete */
+	u32	epctrlx[16];	/* Endpoint Control, where x = 0.. 15 */
+};
+
+#endif
-- 
1.7.5.4

