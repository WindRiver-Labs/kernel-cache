From 143d7e6184dc1f242c87400ddfb1e407840c204c Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 6 Aug 2013 11:11:22 +0800
Subject: [PATCH 34/60] eeprom: add 34aa02t support for mmp3

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports the driver to 3.4.x for mmp3.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/misc/eeprom/Kconfig            |   11 ++
 drivers/misc/eeprom/Makefile           |    1 +
 drivers/misc/eeprom/eeprom_34aa02t-i.c |  167 ++++++++++++++++++++++++++++++++
 3 files changed, 179 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/eeprom/eeprom_34aa02t-i.c

diff --git a/drivers/misc/eeprom/Kconfig b/drivers/misc/eeprom/Kconfig
index 701edf6..2474199 100644
--- a/drivers/misc/eeprom/Kconfig
+++ b/drivers/misc/eeprom/Kconfig
@@ -95,4 +95,15 @@ config EEPROM_DIGSY_MTC_CFG
 
 	  If unsure, say N.
 
+config EEPROM_34AA02T
+	tristate "Board MMP3 i2c eeprom reader"
+	depends on I2C
+	help
+          If you say yes here you get read-only access to the EEPROM data
+          available on modern memory DIMMs and Sony Vaio laptops via I2C. Such
+          EEPROMs could theoretically be available on other devices as well.
+
+          This driver can also be built as a module.  If so, the module
+          will be called eeprom.
+
 endmenu
diff --git a/drivers/misc/eeprom/Makefile b/drivers/misc/eeprom/Makefile
index fc1e81d..cf0f4e5 100644
--- a/drivers/misc/eeprom/Makefile
+++ b/drivers/misc/eeprom/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_EEPROM_MAX6875)	+= max6875.o
 obj-$(CONFIG_EEPROM_93CX6)	+= eeprom_93cx6.o
 obj-$(CONFIG_EEPROM_93XX46)	+= eeprom_93xx46.o
 obj-$(CONFIG_EEPROM_DIGSY_MTC_CFG) += digsy_mtc_eeprom.o
+obj-$(CONFIG_EEPROM_34AA02T)	+= eeprom_34aa02t-i.o
diff --git a/drivers/misc/eeprom/eeprom_34aa02t-i.c b/drivers/misc/eeprom/eeprom_34aa02t-i.c
new file mode 100644
index 0000000..6424b84
--- /dev/null
+++ b/drivers/misc/eeprom/eeprom_34aa02t-i.c
@@ -0,0 +1,167 @@
+/*
+ *  linux/driver/misc/eeprom/eeprom_34aa02t-i.c
+ *
+ *  Author:	RobinYeung <robinyeung@foxmail.com>
+ *
+ *  Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ *  based on driver/misc/eeprom/eeprom.c
+ *	 Copyright (C) 2004 Jean Delvare <khali@linux-fr.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+
+/* Size of EEPROM in bytes */
+#define EEPROM_SIZE		256
+
+/* possible types of eeprom's content */
+enum eeprom_nature {
+	BOARD_NAME = 0,
+	SERIAL_NUM = 0x40,
+	BOARD_MANU = 0x60,
+	BOARD_NETMAC = 0x64,
+	BOARD_CAMERA = 0xc6,
+	BOARD_LCD = 0xca,
+	BOARD_DDR = 0xd2,
+	BOARD_DATE = 0xd5,
+	BOARD_ECO = 0xd8,
+};
+
+/* Each client has this additional data */
+struct eeprom_data {
+	struct mutex update_lock;
+	unsigned long last_updated[8];	/* In jiffies */
+	u8 data[EEPROM_SIZE];		/* Register values */
+	enum eeprom_nature nature;
+};
+
+static struct i2c_client *eeprom_i2c_client;
+
+/*
+ * -------------------------------------------------
+ *  Read information from eeprom, please don't
+ *		call the function in ISR context.
+ *  Input:
+ *		offset: the eeprom start address
+ *		data: the buffer to fill
+ *		len: the buffer's length
+ *	Output
+ *		0			:	success
+ *		other value	:	fail
+ */
+int get_eeprom_boardinfo(u8 offset, u8 *data, u8 len)
+{
+	int i, ret;
+	struct eeprom_data *eeprom;
+
+	if (!eeprom_i2c_client) {
+		printk(KERN_ERR "Maybe eeprom driver isn't probed yet.\n");
+		return -EFAULT;
+	}
+	if (offset + len > 0xff)
+		return -ENOMEM;
+	eeprom = i2c_get_clientdata(eeprom_i2c_client);
+	mutex_lock(&eeprom->update_lock);
+	for (i = 0; i < len; ++i) {
+		ret = i2c_smbus_read_byte_data(eeprom_i2c_client, offset + i);
+		if (ret < 0) {
+			memset(data, 0, len);
+			mutex_unlock(&eeprom->update_lock);
+			return -EIO;
+		}
+		data[i] = ret;
+	}
+	mutex_unlock(&eeprom->update_lock);
+	return 0;
+}
+
+static int eeprom_34aa02t_detect(struct i2c_client *client)
+{
+	int i;
+	struct eeprom_data *data;
+	data = i2c_get_clientdata(client);
+	mutex_lock(&data->update_lock);
+	for (i = BOARD_NAME; i < SERIAL_NUM; ++i)
+		data->data[i] = i2c_smbus_read_byte_data(client, i);
+	mutex_unlock(&data->update_lock);
+	if (i == SERIAL_NUM && data->data[i - 1] != '\0')
+		return -1;
+	printk(KERN_INFO "Board name read from eeprom: %s\n", data->data);
+	return 0;
+}
+
+static int eeprom_34aa02t_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err;
+	struct eeprom_data *data;
+	eeprom_i2c_client = client;
+	data = kzalloc(sizeof(struct eeprom_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	memset(data->data, 0xff, EEPROM_SIZE);
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+
+	/* Detect the nature of EEPROMs. */
+	if (eeprom_34aa02t_detect(client)) {
+		err = -ENXIO;
+		goto exit;
+	}
+	return 0;
+
+exit:
+	return err;
+}
+
+static int eeprom_34aa02t_remove(struct i2c_client *client)
+{
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+static const struct i2c_device_id eeprom_34aa02t_id[] = {
+	{ "eeprom_34aa02t-i", 0 },
+	{ }
+};
+
+static struct i2c_driver eeprom_34aa02t_driver = {
+	.driver = {
+		.name	= "eeprom_34aa02t-i",
+	},
+	.probe		= eeprom_34aa02t_probe,
+	.remove		= eeprom_34aa02t_remove,
+	.id_table	= eeprom_34aa02t_id,
+};
+
+static int __init eeprom_34aa02t_init(void)
+{
+	return i2c_add_driver(&eeprom_34aa02t_driver);
+}
+
+static void __exit eeprom_34aa02t_exit(void)
+{
+	i2c_del_driver(&eeprom_34aa02t_driver);
+}
+
+
+MODULE_AUTHOR("robinyeung <robinyeung@foxmail.com>");
+MODULE_DESCRIPTION("I2C EEPROM 34AA02T-I driver");
+MODULE_LICENSE("GPL");
+
+module_init(eeprom_34aa02t_init);
+module_exit(eeprom_34aa02t_exit);
-- 
1.7.5.4

