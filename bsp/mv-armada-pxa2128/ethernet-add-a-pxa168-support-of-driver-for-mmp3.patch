From d489c301bf9a236905ded0a5ceb56a2e7109af62 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 28 Aug 2013 14:23:23 +0800
Subject: [PATCH 31/60] ethernet: add a pxa168 support of driver for mmp3

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports the driver to 3.4.x for mmp3.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/marvell/pxa168_eth.c |  216 +++++++++++++++++++++++++++--
 include/linux/pxa168_eth.h                |    2 +
 2 files changed, 207 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index efec6b6..99679a4 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -43,9 +43,14 @@
 #include <linux/interrupt.h>
 #include <linux/types.h>
 #include <asm/pgtable.h>
+#include <asm/system.h>
 #include <asm/cacheflush.h>
 #include <linux/pxa168_eth.h>
 
+#include <linux/gpio.h>
+#include <mach/mfp-mmp2.h>
+#include <plat/clock.h>
+
 #define DRIVER_NAME	"pxa168-eth"
 #define DRIVER_VERSION	"0.3"
 
@@ -77,7 +82,9 @@
 
 #define PHY_WAIT_ITERATIONS	10
 
-#define PXA168_ETH_PHY_ADDR_DEFAULT	0
+#define PXA168_ETH_PHY_ADDR_DEFAULT	 (0)
+#define PXA168_ETH_PHY_ADDR_SCAN	 (-1)
+
 /* RX & TX descriptor command */
 #define BUF_OWNED_BY_DMA	(1 << 31)
 
@@ -103,6 +110,7 @@
 #define SDMA_CMD_ERD		(1 << 7)
 
 /* Bit definitions of the Port Config Reg */
+#define PCR_HD			(1 << 15)	/* Full Duplex */
 #define PCR_HS			(1 << 12)
 #define PCR_EN			(1 << 7)
 #define PCR_PM			(1 << 0)
@@ -118,6 +126,11 @@
 #define PCXR_PRIO_TX_OFF	3
 #define PCXR_TX_HIGH_PRI	(7 << PCXR_PRIO_TX_OFF)
 
+#define PCXR_SPEED_EN		(1 << 19)
+#define PCXR_SPEED_100		(1 << 18)
+#define PCXR_F_CTRL_EN		(1 << 10)
+#define PCXR_DULX_EN		(1 << 9)
+
 /* Bit definitions of the SDMA Config Reg */
 #define SDCR_BSZ_OFF		12
 #define SDCR_BSZ8		(3 << SDCR_BSZ_OFF)
@@ -175,6 +188,10 @@
  */
 #define SKB_DMA_REALIGN		((PAGE_SIZE - NET_SKB_PAD) % SMP_CACHE_BYTES)
 
+#define MAC_STRLEN		17
+#define EEPROM_MAC_ADDR		0x64
+static u8 pxa168_mac_addr[ETH_ALEN];
+
 struct rx_desc {
 	u32 cmd_sts;		/* Descriptor command status            */
 	u16 byte_cnt;		/* Descriptor buffer byte count         */
@@ -213,12 +230,15 @@ struct pxa168_eth_private {
 	struct sk_buff **tx_skb;
 
 	struct work_struct tx_timeout_task;
+	atomic_t blink;
+	struct work_struct data_transfer_indicator;
 
 	struct net_device *dev;
 	struct napi_struct napi;
 	u8 work_todo;
 	int skb_size;
 
+	struct net_device_stats stats;
 	/* Size of Tx Ring per queue */
 	int tx_ring_size;
 	/* Number of tx descriptors in use */
@@ -276,6 +296,24 @@ static inline u32 rdl(struct pxa168_eth_private *pep, int offset)
 	return readl(pep->base + offset);
 }
 
+/*
+ * The function only uses for reversing MAC address.
+ * And the argument 'len' must be even.
+ */
+static inline int str_reverse(char *str, int len)
+{
+	int i;
+	char tmp;
+	if (!str)
+		return -1;
+	for (i = 0; i < len / 2; ++i) {
+		tmp = str[i];
+		str[i] = str[len - i - 1];
+		str[len - i - 1] = tmp;
+	}
+	return 0;
+}
+
 static inline void wrl(struct pxa168_eth_private *pep, int offset, u32 data)
 {
 	writel(data, pep->base + offset);
@@ -338,6 +376,32 @@ static void ethernet_phy_reset(struct pxa168_eth_private *pep)
 	} while (data >= 0 && data & BMCR_RESET);
 }
 
+static inline void
+pxa168_set_phy_power(struct pxa168_eth_private *pep, int is_down)
+{
+	int val;
+	val = phy_read(pep->phy, MII_BMCR);
+	if (is_down) { /* power down */
+		if (val & BMCR_PDOWN)
+			return;
+		val |= BMCR_PDOWN;
+	} else { /* power up */
+		if (!(val & BMCR_PDOWN))
+			return;
+		val &= ~BMCR_PDOWN;
+	}
+	/*
+	 * Power Down Mode
+	 *	When the port is switched from power down to normal
+	 *	operation, software reset and restart Auto-Negotiation
+	 *	are performed even when bits Reset (bit 15) and
+	 *	Restart Auto-Negotiation (bit 9) are not set by the user.
+	 *	0 = Normal operation
+	 *	1 = Power down
+	 */
+	phy_write(pep->phy, MII_BMCR, val);
+}
+
 static void rxq_refill(struct net_device *dev)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
@@ -778,6 +842,38 @@ static void pxa168_eth_tx_timeout_task(struct work_struct *work)
 	pxa168_eth_open(dev);
 }
 
+static void set_led_blink(int gpio_num, int msec, unsigned int count)
+{
+	int transfer_led, hold_time;
+	transfer_led = mfp_to_gpio(gpio_num);
+	if (gpio_request(transfer_led, "transfer_led"))
+		printk(KERN_WARNING "gpio %d request failed\n", transfer_led);
+	if (count == 0)
+		gpio_direction_output(transfer_led, 1);
+	else {
+		count &= 0xf;
+		hold_time = msec / count;
+		while (count--) {
+			gpio_direction_output(transfer_led, 1);
+			msleep(hold_time);
+			gpio_direction_output(transfer_led, 0);
+			msleep(hold_time);
+		}
+	}
+	gpio_free(transfer_led);
+}
+
+static void pxa168_eth_data_transfer_set_led(struct work_struct *work)
+{
+	struct pxa168_eth_private *pep = container_of(work,
+			struct pxa168_eth_private, data_transfer_indicator);
+	if (atomic_read(&pep->blink)) {
+		set_led_blink(MFP_PIN_GPIO84, 100, 1);
+		atomic_set(&pep->blink, 0);
+	} else
+		set_led_blink(MFP_PIN_GPIO84, 0, 0);
+}
+
 static int rxq_process(struct net_device *dev, int budget)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
@@ -870,8 +966,13 @@ static int pxa168_eth_collect_events(struct pxa168_eth_private *pep,
 		pep->work_todo |= WORK_TX_DONE;
 		ret = 1;
 	}
-	if (icr & ICR_RXBUF)
+	if (icr & ICR_RXBUF) {
+		if (!atomic_read(&pep->blink)) {
+			atomic_set(&pep->blink, 1);
+			schedule_work(&pep->data_transfer_indicator);
+		}
 		ret = 1;
+	}
 	if (icr & ICR_MII_CH) {
 		pep->work_todo |= WORK_LINK;
 		ret = 1;
@@ -886,21 +987,57 @@ static void handle_link_event(struct pxa168_eth_private *pep)
 	int speed;
 	int duplex;
 	int fc;
+	int link_led;
+
+	link_led = mfp_to_gpio(MFP_PIN_GPIO87);
+	if (gpio_request(link_led, "link_led"))
+		printk(KERN_WARNING "gpio %d request failed\n", link_led);
 
 	port_status = rdl(pep, PORT_STATUS);
+
 	if (!(port_status & LINK_UP)) {
 		if (netif_carrier_ok(dev)) {
+			gpio_direction_output(link_led, 1);
+			gpio_free(link_led);
 			printk(KERN_INFO "%s: link down\n", dev->name);
 			netif_carrier_off(dev);
 			txq_reclaim(dev, 1);
+			atomic_set(&pep->blink, 0);
+			schedule_work(&pep->data_transfer_indicator);
 		}
 		return;
 	}
+
 	if (port_status & PORT_SPEED_100)
 		speed = 100;
 	else
 		speed = 10;
 
+	if (pep->phy->autoneg == AUTONEG_DISABLE) {
+		speed = pep->phy->speed;
+		duplex = pep->phy->duplex;
+		wrl(pep, PORT_CONFIG_EXT, rdl(pep, PORT_CONFIG_EXT)
+			| PCXR_SPEED_EN | PCXR_F_CTRL_EN | PCXR_DULX_EN);
+		if (duplex)
+			wrl(pep, PORT_CONFIG, rdl(pep, PORT_CONFIG) | PCR_HD);
+		else
+			wrl(pep, PORT_CONFIG,
+				rdl(pep, PORT_CONFIG) & (~PCR_HD));
+
+		if (speed == SPEED_100)
+			wrl(pep, PORT_CONFIG_EXT,
+				rdl(pep, PORT_CONFIG_EXT) | PCXR_SPEED_100);
+		else if (speed == SPEED_10)
+			wrl(pep, PORT_CONFIG_EXT, rdl(pep,
+				PORT_CONFIG_EXT) & (~PCXR_SPEED_100));
+		else
+			printk(KERN_INFO "We have not implemented 1000Mb/s or other speed yet.");
+		port_status = rdl(pep, PORT_STATUS);
+	}
+
+	gpio_direction_output(link_led, 0);
+	gpio_free(link_led);
+
 	duplex = (port_status & FULL_DUPLEX) ? 1 : 0;
 	fc = (port_status & FLOW_CONTROL_ENABLED) ? 1 : 0;
 	printk(KERN_INFO "%s: link up, %d Mb/s, %s duplex, "
@@ -1259,6 +1396,11 @@ static int pxa168_eth_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	int tx_index;
 	int length;
 
+	if (!atomic_read(&pep->blink)) {
+		atomic_set(&pep->blink, 1);
+		schedule_work(&pep->data_transfer_indicator);
+	}
+
 	tx_index = eth_alloc_tx_desc_index(pep);
 	desc = &pep->p_tx_desc_area[tx_index];
 	length = skb->len;
@@ -1363,14 +1505,15 @@ static struct phy_device *phy_scan(struct pxa168_eth_private *pep, int phy_addr)
 	int i;
 
 	if (phy_addr == PXA168_ETH_PHY_ADDR_DEFAULT) {
-		/* Scan entire range */
-		start = ethernet_phy_get(pep);
-		num = 32;
-	} else {
 		/* Use phy addr specific to platform */
 		start = phy_addr & 0x1f;
 		num = 1;
+	} else {
+		/* Scan entire range */
+		start = ethernet_phy_get(pep);
+		num = 32;
 	}
+
 	phydev = NULL;
 	for (i = 0; i < num; i++) {
 		int addr = (start + i) & 0x1f;
@@ -1393,12 +1536,12 @@ static void phy_init(struct pxa168_eth_private *pep, int speed, int duplex)
 	ethernet_phy_reset(pep);
 
 	phy_attach(pep->dev, dev_name(&phy->dev), 0, PHY_INTERFACE_MODE_MII);
+	phy->supported &= PHY_BASIC_FEATURES;
 
 	if (speed == 0) {
 		phy->autoneg = AUTONEG_ENABLE;
 		phy->speed = 0;
 		phy->duplex = 0;
-		phy->supported &= PHY_BASIC_FEATURES;
 		phy->advertising = phy->supported | ADVERTISED_Autoneg;
 	} else {
 		phy->autoneg = AUTONEG_DISABLE;
@@ -1438,7 +1581,25 @@ static int pxa168_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 static int pxa168_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
+	u32 speed = ethtool_cmd_speed(cmd);
+	unsigned long flags;
 
+	if (speed != SPEED_100 && speed != SPEED_10)
+		return -EINVAL;
+	if (speed != pep->pd->speed) {
+		spin_lock_irqsave(&pep->clk->spinlock, flags);
+		if (speed == SPEED_10) {
+			pep->clk->div = 10;
+			pep->clk->mul = 0;
+		} else if (speed == SPEED_100) {
+			pep->clk->div = 0;
+			pep->clk->mul = 10;
+		}
+		pep->pd->speed = speed;
+		spin_unlock_irqrestore(&pep->clk->spinlock, flags);
+		clk_disable(pep->clk);
+		clk_enable(pep->clk);
+	}
 	return phy_ethtool_sset(pep->phy, cmd);
 }
 
@@ -1488,6 +1649,7 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 	}
 	clk_enable(clk);
 
+	clk->dynamic_change = true;
 	dev = alloc_etherdev(sizeof(struct pxa168_eth_private));
 	if (!dev) {
 		err = -ENOMEM;
@@ -1518,8 +1680,20 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 
 	INIT_WORK(&pep->tx_timeout_task, pxa168_eth_tx_timeout_task);
 
-	printk(KERN_INFO "%s:Using random mac address\n", DRIVER_NAME);
-	eth_hw_addr_random(dev);
+	INIT_WORK(&pep->data_transfer_indicator,
+		pxa168_eth_data_transfer_set_led);
+	atomic_set(&pep->blink, 0);
+
+	if (!get_eeprom_boardinfo(EEPROM_MAC_ADDR, pxa168_mac_addr, ETH_ALEN)
+			&& !str_reverse(pxa168_mac_addr, ETH_ALEN)
+			&& is_valid_ether_addr(pxa168_mac_addr)) {
+		/* clear multicast bit */
+		pxa168_mac_addr[0] &= 0xfe;
+		memcpy(dev->dev_addr, pxa168_mac_addr, ETH_ALEN);
+	} else {
+		printk(KERN_INFO "%s: Using random mac address\n", DRIVER_NAME);
+		eth_hw_addr_random(dev);
+	}
 
 	pep->pd = pdev->dev.platform_data;
 	pep->rx_ring_size = NUM_RX_DESCS;
@@ -1576,6 +1750,7 @@ err_base:
 err_netdev:
 	free_netdev(dev);
 err_clk:
+	clk->dynamic_change = false;
 	clk_disable(clk);
 	clk_put(clk);
 	return err;
@@ -1592,6 +1767,7 @@ static int pxa168_eth_remove(struct platform_device *pdev)
 		pep->htpr = NULL;
 	}
 	if (pep->clk) {
+		pep->clk->dynamic_change = false;
 		clk_disable(pep->clk);
 		clk_put(pep->clk);
 		pep->clk = NULL;
@@ -1619,12 +1795,30 @@ static void pxa168_eth_shutdown(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int pxa168_eth_resume(struct platform_device *pdev)
 {
-	return -ENOSYS;
+	struct net_device *dev = platform_get_drvdata(pdev);
+	struct pxa168_eth_private *pep = netdev_priv(dev);
+
+	if (netif_running(dev)) {
+		/* power up phy */
+		pxa168_set_phy_power(pep, false);
+		netif_device_attach(dev);
+	}
+
+	return 0;
 }
 
 static int pxa168_eth_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	return -ENOSYS;
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct pxa168_eth_private *pep = netdev_priv(ndev);
+
+	if (netif_running(ndev)) {
+		/* power down phy */
+		pxa168_set_phy_power(pep, BMCR_PDOWN);
+		netif_device_detach(ndev);
+	}
+
+	return 0;
 }
 
 #else
diff --git a/include/linux/pxa168_eth.h b/include/linux/pxa168_eth.h
index 18d75e7..c632d28 100644
--- a/include/linux/pxa168_eth.h
+++ b/include/linux/pxa168_eth.h
@@ -4,6 +4,8 @@
 #ifndef __LINUX_PXA168_ETH_H
 #define __LINUX_PXA168_ETH_H
 
+extern int get_eeprom_boardinfo(u8 offset, u8 *data, u8 len);
+
 struct pxa168_eth_platform_data {
 	int	port_number;
 	int	phy_addr;
-- 
1.7.5.4

