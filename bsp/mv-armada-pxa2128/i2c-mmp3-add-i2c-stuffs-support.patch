From 91c65df5c5dd299f0a77b733078c0c3585288f4f Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 8 Aug 2013 08:56:30 +0800
Subject: [PATCH 38/60] i2c: mmp3: add i2c stuffs support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports the driver to WRLinux 3.4.x for
mmp3.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/i2c/busses/i2c-pxa.c |  126 ++++++++++++++++++++++++++++++++++-------
 include/linux/i2c/pxa-i2c.h  |    1 +
 2 files changed, 105 insertions(+), 22 deletions(-)

diff --git a/drivers/i2c/busses/i2c-pxa.c b/drivers/i2c/busses/i2c-pxa.c
index f673326..4c92643 100644
--- a/drivers/i2c/busses/i2c-pxa.c
+++ b/drivers/i2c/busses/i2c-pxa.c
@@ -38,6 +38,7 @@
 #include <linux/slab.h>
 #include <linux/io.h>
 #include <linux/i2c/pxa-i2c.h>
+#include <plat/pm.h>
 
 #include <asm/irq.h>
 
@@ -60,6 +61,7 @@ enum pxa_i2c_types {
 	REGS_PXA2XX,
 	REGS_PXA3XX,
 	REGS_CE4100,
+	REGS_PXA910,
 };
 
 /*
@@ -87,12 +89,20 @@ static struct pxa_reg_layout pxa_reg_layout[] = {
 		.isr =	0x04,
 		/* no isar register */
 	},
+	[REGS_PXA910] = {
+		.ibmr = 0x00,
+		.idbr = 0x08,
+		.icr =	0x10,
+		.isr =	0x18,
+		.isar = 0x20,
+	},
 };
 
 static const struct platform_device_id i2c_pxa_id_table[] = {
 	{ "pxa2xx-i2c",		REGS_PXA2XX },
 	{ "pxa3xx-pwri2c",	REGS_PXA3XX },
 	{ "ce4100-i2c",		REGS_CE4100 },
+	{ "pxa910-i2c",		REGS_PXA910 },
 	{ },
 };
 MODULE_DEVICE_TABLE(platform, i2c_pxa_id_table);
@@ -138,6 +148,7 @@ struct pxa_i2c {
 	unsigned int		msg_idx;
 	unsigned int		msg_ptr;
 	unsigned int		slave_addr;
+	unsigned int		req_slave_addr;
 
 	struct i2c_adapter	adap;
 	struct clk		*clk;
@@ -162,6 +173,9 @@ struct pxa_i2c {
 	int			irq;
 	unsigned int		use_pio :1;
 	unsigned int		fast_mode :1;
+#ifdef  CONFIG_CPU_MMP3
+	struct pm_qos_request	qos_idle;
+#endif
 };
 
 #define _IBMR(i2c)	((i2c)->reg_ibmr)
@@ -175,6 +189,9 @@ struct pxa_i2c {
  */
 #define I2C_PXA_SLAVE_ADDR      0x1
 
+#define DEBUG 0
+static void i2c_pxa_reset(struct pxa_i2c *i2c);
+
 #ifdef DEBUG
 
 struct bits {
@@ -255,15 +272,30 @@ static void i2c_pxa_show_state(struct pxa_i2c *i2c, int lno, const char *fname)
 static void i2c_pxa_scream_blue_murder(struct pxa_i2c *i2c, const char *why)
 {
 	unsigned int i;
-	printk(KERN_ERR "i2c: error: %s\n", why);
+	struct i2c_pxa_platform_data *plat =
+		(i2c->adap.dev.parent)->platform_data;
+
+	printk(KERN_ERR"i2c: <%s> slave_0x%x error: %s\n", i2c->adap.name,
+		i2c->req_slave_addr >> 1, why);
 	printk(KERN_ERR "i2c: msg_num: %d msg_idx: %d msg_ptr: %d\n",
 		i2c->msg_num, i2c->msg_idx, i2c->msg_ptr);
-	printk(KERN_ERR "i2c: ICR: %08x ISR: %08x\n",
-	       readl(_ICR(i2c)), readl(_ISR(i2c)));
+	printk(KERN_ERR "i2c: IBMR: %08x IDBR: %08x ICR: %08x ISR: %08x\n",
+		readl(_IBMR(i2c)), readl(_IDBR(i2c)), readl(_ICR(i2c)),
+		readl(_ISR(i2c)));
 	printk(KERN_DEBUG "i2c: log: ");
 	for (i = 0; i < i2c->irqlogidx; i++)
 		printk("[%08x:%08x] ", i2c->isrlog[i], i2c->icrlog[i]);
 	printk("\n");
+	if (strcmp(why, "exhausted retries") != 0) {
+		if (plat && plat->i2c_bus_reset)
+		#ifdef CONFIG_CPU_PXA988
+			plat->i2c_bus_reset(i2c->adap.nr);
+		#else
+			plat->i2c_bus_reset();
+		#endif
+		/* reset i2c contorler when it's fail */
+		i2c_pxa_reset(i2c);
+	}
 }
 
 #else /* ifdef DEBUG */
@@ -467,6 +499,8 @@ static void i2c_pxa_reset(struct pxa_i2c *i2c)
 	/* set control register values */
 	writel(I2C_ICR_INIT | (i2c->fast_mode ? ICR_FM : 0), _ICR(i2c));
 
+	udelay(2);
+
 #ifdef CONFIG_I2C_PXA_SLAVE
 	dev_info(&i2c->adap.dev, "Enabling slave mode\n");
 	writel(readl(_ICR(i2c)) | ICR_SADIE | ICR_ALDIE | ICR_SSDIE, _ICR(i2c));
@@ -639,12 +673,13 @@ static inline void i2c_pxa_start_message(struct pxa_i2c *i2c)
 	 * Step 1: target slave address into IDBR
 	 */
 	writel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));
+	i2c->req_slave_addr = i2c_pxa_addr_byte(i2c->msg);
 
 	/*
 	 * Step 2: initiate the write.
 	 */
 	icr = readl(_ICR(i2c)) & ~(ICR_STOP | ICR_ALDIE);
-	writel(icr | ICR_START | ICR_TB, _ICR(i2c));
+	writel(icr | ICR_START | ICR_TB | ICR_ITEIE, _ICR(i2c));
 }
 
 static inline void i2c_pxa_stop_message(struct pxa_i2c *i2c)
@@ -668,7 +703,7 @@ static int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)
 	 * Wait for the bus to become free.
 	 */
 	while (timeout-- && readl(_ISR(i2c)) & (ISR_IBB | ISR_UB)) {
-		udelay(1000);
+		msleep(1);
 		show_state(i2c);
 	}
 
@@ -690,7 +725,7 @@ static int i2c_pxa_pio_set_master(struct pxa_i2c *i2c)
 static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 			       struct i2c_msg *msg, int num)
 {
-	unsigned long timeout = 500000; /* 5 seconds */
+	unsigned long timeout = 100000; /* 1 seconds */
 	int ret = 0;
 
 	ret = i2c_pxa_pio_set_master(i2c);
@@ -703,6 +738,10 @@ static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 	i2c->msg_ptr = 0;
 	i2c->irqlogidx = 0;
 
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_CONSTRAINT);
+#endif
+
 	i2c_pxa_start_message(i2c);
 
 	while (i2c->msg_num > 0 && --timeout) {
@@ -712,6 +751,10 @@ static int i2c_pxa_do_pio_xfer(struct pxa_i2c *i2c,
 
 	i2c_pxa_stop_message(i2c);
 
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_DEFAULT_VALUE);
+#endif
+
 	/*
 	 * We place the return code in i2c->msg_idx.
 	 */
@@ -721,6 +764,9 @@ out:
 	if (timeout == 0)
 		i2c_pxa_scream_blue_murder(i2c, "timeout");
 
+	if (ret < 0)
+		i2c_pxa_reset(i2c);
+
 	return ret;
 }
 
@@ -758,6 +804,10 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 	i2c->msg_ptr = 0;
 	i2c->irqlogidx = 0;
 
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_CONSTRAINT);
+#endif
+
 	i2c_pxa_start_message(i2c);
 
 	spin_unlock_irq(&i2c->lock);
@@ -765,9 +815,13 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 	/*
 	 * The rest of the processing occurs in the interrupt handler.
 	 */
-	timeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 5);
+	timeout = wait_event_timeout(i2c->wait, i2c->msg_num == 0, HZ * 1);
 	i2c_pxa_stop_message(i2c);
 
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_update_request(&i2c->qos_idle, PM_QOS_DEFAULT_VALUE);
+#endif
+
 	/*
 	 * We place the return code in i2c->msg_idx.
 	 */
@@ -775,10 +829,13 @@ static int i2c_pxa_do_xfer(struct pxa_i2c *i2c, struct i2c_msg *msg, int num)
 
 	if (!timeout && i2c->msg_num) {
 		i2c_pxa_scream_blue_murder(i2c, "timeout");
-		ret = I2C_RETRY;
+		return I2C_RETRY;
 	}
 
  out:
+	if (ret < 0)
+		i2c_pxa_reset(i2c);
+
 	return ret;
 }
 
@@ -881,7 +938,7 @@ static void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)
 		 */
 		writel(i2c->msg->buf[i2c->msg_ptr++], _IDBR(i2c));
 
-		icr |= ICR_ALDIE | ICR_TB;
+		icr |= ICR_ALDIE | ICR_TB | ICR_ITEIE;
 
 		/*
 		 * If this is the last byte of the last message, send
@@ -910,12 +967,12 @@ static void i2c_pxa_irq_txempty(struct pxa_i2c *i2c, u32 isr)
 		 * Write the next address.
 		 */
 		writel(i2c_pxa_addr_byte(i2c->msg), _IDBR(i2c));
-
+		i2c->req_slave_addr = i2c_pxa_addr_byte(i2c->msg);
 		/*
 		 * And trigger a repeated start, and send the byte.
 		 */
 		icr &= ~ICR_ALDIE;
-		icr |= ICR_START | ICR_TB;
+		icr |= ICR_START | ICR_TB | ICR_ITEIE;
 	} else {
 		if (i2c->msg->len == 0) {
 			/*
@@ -1015,6 +1072,7 @@ static int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num
 	struct pxa_i2c *i2c = adap->algo_data;
 	int ret, i;
 
+	enable_irq(i2c->irq);
 	for (i = adap->retries; i >= 0; i--) {
 		ret = i2c_pxa_do_xfer(i2c, msgs, num);
 		if (ret != I2C_RETRY)
@@ -1028,6 +1086,7 @@ static int i2c_pxa_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num
 	ret = -EREMOTEIO;
  out:
 	i2c_pxa_set_slave(i2c, ret);
+	disable_irq(i2c->irq);
 	return ret;
 }
 
@@ -1100,6 +1159,9 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	struct pxa_i2c *i2c;
 	struct resource *res = NULL;
 	int ret, irq;
+#if !defined(CONFIG_WAKELOCK) || !defined(CONFIG_CPU_PXA910)
+	int pm_qos_class = PM_QOS_CPU_DMA_LATENCY;
+#endif
 
 	i2c = kzalloc(sizeof(struct pxa_i2c), GFP_KERNEL);
 	if (!i2c) {
@@ -1126,8 +1188,10 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	}
 
 	i2c->adap.owner   = THIS_MODULE;
-	i2c->adap.retries = 5;
-
+	i2c->adap.retries = 3;
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_add_request(&i2c->qos_idle, pm_qos_class, PM_QOS_DEFAULT_VALUE);
+#endif
 	spin_lock_init(&i2c->lock);
 	init_waitqueue_head(&i2c->wait);
 
@@ -1136,7 +1200,7 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	 * The reason to do so is to avoid sysfs names that only make
 	 * sense when there are multiple adapters.
 	 */
-	i2c->adap.nr = dev->id;
+	i2c->adap.nr = dev->id != -1 ? dev->id : 0;
 	snprintf(i2c->adap.name, sizeof(i2c->adap.name), "pxa_i2c-i2c.%u",
 		 i2c->adap.nr);
 
@@ -1166,35 +1230,46 @@ static int i2c_pxa_probe(struct platform_device *dev)
 
 	i2c->slave_addr = I2C_PXA_SLAVE_ADDR;
 
-	if (plat) {
 #ifdef CONFIG_I2C_PXA_SLAVE
+	if (plat) {
 		i2c->slave_addr = plat->slave_addr;
 		i2c->slave = plat->slave;
-#endif
-		i2c->adap.class = plat->class;
 	}
+#endif
 
 	clk_enable(i2c->clk);
 
+	if (plat) {
+		i2c->adap.class = plat->class;
+		i2c->use_pio = plat->use_pio;
+		i2c->fast_mode = plat->fast_mode;
+	}
+
 	if (i2c->use_pio) {
 		i2c->adap.algo = &i2c_pxa_pio_algorithm;
 	} else {
 		i2c->adap.algo = &i2c_pxa_algorithm;
-		ret = request_irq(irq, i2c_pxa_handler, IRQF_SHARED,
-				  i2c->adap.name, i2c);
+		ret = request_irq(irq, i2c_pxa_handler,
+				IRQF_DISABLED | IRQF_NO_SUSPEND,
+				i2c->adap.name, i2c);
 		if (ret)
 			goto ereqirq;
 	}
 
 	i2c_pxa_reset(i2c);
 
+	disable_irq(irq);
+
 	i2c->adap.algo_data = i2c;
 	i2c->adap.dev.parent = &dev->dev;
 #ifdef CONFIG_OF
 	i2c->adap.dev.of_node = dev->dev.of_node;
 #endif
 
-	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if (i2c_type == REGS_CE4100)
+		ret = i2c_add_adapter(&i2c->adap);
+	else
+		ret = i2c_add_numbered_adapter(&i2c->adap);
 	if (ret < 0) {
 		printk(KERN_INFO "I2C: Failed to add bus\n");
 		goto eadapt;
@@ -1224,7 +1299,10 @@ eclk:
 	kfree(i2c);
 emalloc:
 	release_mem_region(res->start, resource_size(res));
-	return ret;
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_remove_request(&i2c->qos_idle);
+#endif
+return ret;
 }
 
 static int __exit i2c_pxa_remove(struct platform_device *dev)
@@ -1233,6 +1311,10 @@ static int __exit i2c_pxa_remove(struct platform_device *dev)
 
 	platform_set_drvdata(dev, NULL);
 
+#ifdef  CONFIG_CPU_MMP3
+	pm_qos_remove_request(&i2c->qos_idle);
+#endif
+
 	i2c_del_adapter(&i2c->adap);
 	if (!i2c->use_pio)
 		free_irq(i2c->irq, i2c);
@@ -1247,7 +1329,7 @@ static int __exit i2c_pxa_remove(struct platform_device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined(CONFIG_PM) && !defined(CONFIG_CPU_MMP3)
 static int i2c_pxa_suspend_noirq(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
diff --git a/include/linux/i2c/pxa-i2c.h b/include/linux/i2c/pxa-i2c.h
index 1a9f65e..7cb43fb 100644
--- a/include/linux/i2c/pxa-i2c.h
+++ b/include/linux/i2c/pxa-i2c.h
@@ -67,6 +67,7 @@ struct i2c_pxa_platform_data {
 	unsigned int		class;
 	unsigned int		use_pio :1;
 	unsigned int		fast_mode :1;
+	void			(*i2c_bus_reset)(void);
 };
 
 extern void pxa_set_i2c_info(struct i2c_pxa_platform_data *info);
-- 
1.7.5.4

