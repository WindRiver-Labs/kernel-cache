From 30c85c9783f214570c589f1ce19939e06fff3fce Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 28 Aug 2013 08:33:33 +0800
Subject: [PATCH 42/60] mmc: mmp3: get pxav3 supported.

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch updates mmc host driver to cater for WRLinux
3.4.x kernel.

Singed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/clock-mmp3.c          |    8 +-
 arch/arm/mach-mmp/mmp3.c                |    8 +-
 drivers/mmc/host/sdhci-pxav3.c          |  436 ++++++++++++++++++++++++++++++-
 drivers/mmc/host/sdhci.h                |   11 +
 include/linux/mmc/pm.h                  |    4 +
 include/linux/mmc/sdhci.h               |    6 +-
 include/linux/platform_data/pxa_sdhci.h |   75 ++++++
 7 files changed, 527 insertions(+), 21 deletions(-)

diff --git a/arch/arm/mach-mmp/clock-mmp3.c b/arch/arm/mach-mmp/clock-mmp3.c
index 696461b..dca32b2 100644
--- a/arch/arm/mach-mmp/clock-mmp3.c
+++ b/arch/arm/mach-mmp/clock-mmp3.c
@@ -1975,7 +1975,7 @@ static struct clk_mux_sel sdhc_clk_mux[] = {
 static struct clk mmp3_clk_sdh0 = {
 	.name = "sdh0",
 	.lookup = {
-		.dev_id = "sdhci-pxa.0",
+		.dev_id = "sdhci-pxav3.0",
 		.con_id = "PXA-SDHCLK",
 	},
 	.ops = &sdhc0_clk_ops,
@@ -1991,7 +1991,7 @@ static struct clk mmp3_clk_sdh0 = {
 static struct clk mmp3_clk_sdh1 = {
 	.name = "sdh1",
 	.lookup = {
-		.dev_id = "sdhci-pxa.1",
+		.dev_id = "sdhci-pxav3.1",
 		.con_id = "PXA-SDHCLK",
 	},
 	.ops = &sdhc1_4_clk_ops,
@@ -2002,7 +2002,7 @@ static struct clk mmp3_clk_sdh1 = {
 static struct clk mmp3_clk_sdh2 = {
 	.name = "sdh2",
 	.lookup = {
-		.dev_id = "sdhci-pxa.2",
+		.dev_id = "sdhci-pxav3.2",
 		.con_id = "PXA-SDHCLK",
 	},
 	.ops = &sdhc1_4_clk_ops,
@@ -2013,7 +2013,7 @@ static struct clk mmp3_clk_sdh2 = {
 static struct clk mmp3_clk_sdh3 = {
 	.name = "sdh3",
 	.lookup = {
-		.dev_id = "sdhci-pxa.3",
+		.dev_id = "sdhci-pxav3.3",
 		.con_id = "PXA-SDHCLK",
 	},
 	.ops = &sdhc1_4_clk_ops,
diff --git a/arch/arm/mach-mmp/mmp3.c b/arch/arm/mach-mmp/mmp3.c
index 5e9adf5..dac9c6e 100644
--- a/arch/arm/mach-mmp/mmp3.c
+++ b/arch/arm/mach-mmp/mmp3.c
@@ -533,10 +533,10 @@ MMP3_DEVICE(uart2, "pxa2xx-uart", 1, UART2, 0xd4017000, 0x30, 20, 21);
 MMP3_DEVICE(uart3, "pxa2xx-uart", 2, UART3, 0xd4018000, 0x30, 22, 23);
 MMP3_DEVICE(uart4, "pxa2xx-uart", 3, UART4, 0xd4016000, 0x30, 18, 19);
 MMP3_DEVICE(nand, "pxa3xx-nand", -1, NAND, 0xd4283000, 0x100, 28, 29);
-MMP3_DEVICE(sdh0, "sdhci-pxa", 0, MMC, 0xd4280000, 0x120);
-MMP3_DEVICE(sdh1, "sdhci-pxa", 1, MMC2, 0xd4280800, 0x120);
-MMP3_DEVICE(sdh2, "sdhci-pxa", 2, MMC3, 0xd4281000, 0x120);
-MMP3_DEVICE(sdh3, "sdhci-pxa", 3, MMC4, 0xd4281800, 0x120);
+MMP3_DEVICE(sdh0, "sdhci-pxav3", 0, MMC, 0xd4280000, 0x120);
+MMP3_DEVICE(sdh1, "sdhci-pxav3", 1, MMC2, 0xd4280800, 0x120);
+MMP3_DEVICE(sdh2, "sdhci-pxav3", 2, MMC3, 0xd4281000, 0x120);
+MMP3_DEVICE(sdh3, "sdhci-pxav3", 3, MMC4, 0xd4281800, 0x120);
 MMP3_DEVICE(twsi1, "pxa2xx-i2c", 0, TWSI1, 0xd4011000, 0x70);
 MMP3_DEVICE(twsi2, "pxa2xx-i2c", 1, TWSI2, 0xd4031000, 0x70);
 MMP3_DEVICE(twsi3, "pxa2xx-i2c", 2, TWSI3, 0xd4032000, 0x70);
diff --git a/drivers/mmc/host/sdhci-pxav3.c b/drivers/mmc/host/sdhci-pxav3.c
index f296956..695057d 100644
--- a/drivers/mmc/host/sdhci-pxav3.c
+++ b/drivers/mmc/host/sdhci-pxav3.c
@@ -28,14 +28,30 @@
 #include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/module.h>
+#include <linux/regulator/machine.h>
 #include "sdhci.h"
 #include "sdhci-pltfm.h"
+#include <plat/pm.h>
+
+#ifdef CONFIG_CPU_PXA978
+#include <mach/dvfm.h>
+#endif
+
+#define ERR_RETRY       2
+#define ERR_ABORT       1
+#define ERR_CONTINUE    0
 
 #define SD_CLOCK_BURST_SIZE_SETUP		0x10A
-#define SDCLK_SEL	0x100
+#define SDCLK_SEL		(1<<8)
 #define SDCLK_DELAY_SHIFT	9
 #define SDCLK_DELAY_MASK	0x1f
 
+#define SD_RX_CFG_REG		0x114
+#define RX_CFG_SDCLK_SEL		(1<<2)
+#define RX_CFG_SDCLK_SEL_MASK		(0x3<<2)
+#define RX_CFG_SDCLK_DELAY_SHIFT	8
+#define RX_CFG_SDCLK_DELAY_MASK		0x1ff
+
 #define SD_CFG_FIFO_PARAM       0x100
 #define SDCFG_GEN_PAD_CLK_ON	(1<<6)
 #define SDCFG_GEN_PAD_CLK_CNT_MASK	0xFF
@@ -48,6 +64,16 @@
 #define SDCE_MISC_INT		(1<<2)
 #define SDCE_MISC_INT_EN	(1<<1)
 
+/* controller should NOT gate bus clock for some device at any time, e.g. SDIO card */
+#define MMC_CAP_ENABLE_BUS_CLK_GATING   (1 << 31)
+
+static u32 pxav3_get_max_clock(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+
+	return clk_get_rate(pltfm_host->clk);
+}
+
 static void pxav3_set_private_registers(struct sdhci_host *host, u8 mask)
 {
 	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
@@ -58,16 +84,58 @@ static void pxav3_set_private_registers(struct sdhci_host *host, u8 mask)
 		 * tune timing of read data/command when crc error happen
 		 * no performance impact
 		 */
-		if (pdata && 0 != pdata->clk_delay_cycles) {
+		if (pdata && pdata->clk_delay_cycles) {
 			u16 tmp;
 
-			tmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
-			tmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)
-				<< SDCLK_DELAY_SHIFT;
-			tmp |= SDCLK_SEL;
-			writew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
+			if (!pdata->regs_extended) {
+				tmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
+				tmp &= ~(SDCLK_DELAY_MASK << SDCLK_DELAY_SHIFT);
+				tmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)
+					<< SDCLK_DELAY_SHIFT;
+				tmp |= SDCLK_SEL;
+				writew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
+			} else {
+				tmp = readw(host->ioaddr + SD_RX_CFG_REG);
+				tmp &= ~(RX_CFG_SDCLK_DELAY_MASK << RX_CFG_SDCLK_DELAY_SHIFT);
+				tmp |= (pdata->clk_delay_cycles & RX_CFG_SDCLK_DELAY_MASK)
+					<< RX_CFG_SDCLK_DELAY_SHIFT;
+				tmp &= ~(RX_CFG_SDCLK_SEL_MASK);
+				tmp |= RX_CFG_SDCLK_SEL;
+				writew(tmp, host->ioaddr + SD_RX_CFG_REG);
+			}
+		}
+	}
+}
+
+static int sdhci_pxa_safe_regulator_on(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_pxa *pxa;
+	int ret = 0;
+
+	pltfm_host = sdhci_priv(host);
+	pxa = pltfm_host->priv;
+
+	if (pxa && pxa->pdata && pxa->pdata->check_short_circuit)
+		if (pxa->pdata->check_short_circuit(host,
+			pxa->pdata->mfp_start,
+			pxa->pdata->mfp_num,
+			pxa->pdata->pull_up)) {
+
+			pr_info("WARNING SD short circuit detected\n");
+			ret = 1;
 		}
+
+	if (!ret) {
+		if (pxa && pxa->pdata && pxa->pdata->safe_regulator_on)
+			pxa->pdata->safe_regulator_on(host,
+				pxa->pdata->mfp_start,
+				pxa->pdata->mfp_num);
+		else
+			regulator_enable(host->vmmc);
 	}
+
+	return ret;
 }
 
 #define MAX_WAIT_COUNT 5
@@ -158,12 +226,288 @@ static int pxav3_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)
 	return 0;
 }
 
+static void pxav3_signal_vol_change(struct sdhci_host *host, u8 vol)
+{
+	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+
+	if (pdata && pdata->signal_1v8)
+		pdata->signal_1v8(MMC_SIGNAL_VOLTAGE_180 == vol);
+}
+
+static void pxav3_access_constrain(struct sdhci_host *host, unsigned int ac)
+{
+	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+#ifdef CONFIG_CPU_PXA978
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+#endif
+	if (!pdata)
+		return;
+
+#ifdef CONFIG_CPU_PXA978
+	if (ac && !pxa->clk_enable) {
+		if (pltfm_host->dvfm_dev_idx)
+			dvfm_disable_lowpower(pltfm_host->dvfm_dev_idx);
+		pxa->clk_enable = 1;
+	} else if (!ac && pxa->clk_enable) {
+		if (pltfm_host->dvfm_dev_idx)
+			dvfm_enable_lowpower(pltfm_host->dvfm_dev_idx);
+		pxa->clk_enable = 0;
+	}
+#else
+	if (ac)
+		pm_qos_update_request(&pdata->qos_idle, PM_QOS_CONSTRAINT);
+	else
+		pm_qos_update_request(&pdata->qos_idle, PM_QOS_DEFAULT_VALUE);
+#endif
+}
+
+static void ext_cd_notify_change(struct platform_device *pdev, int state)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	unsigned long flags;
+	static int old_state = 0;
+
+	if (host) {
+		spin_lock_irqsave(&host->lock, flags);
+		if (state && !old_state) {
+			old_state = state;
+			dev_dbg(&pdev->dev, "card inserted.\n");
+			host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
+			spin_unlock_irqrestore(&host->lock, flags);
+			if (host->vmmc) {
+				pr_info("mmc power on vmmc=0x%x\n",
+					(int)host->vmmc);
+				regulator_enable(host->vmmc);
+			}
+		} else if(!state && old_state) {
+			old_state = state;
+			dev_dbg(&pdev->dev, "card removed.\n");
+			host->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;
+
+			if (host->mrq) {
+				printk(KERN_ERR
+				       "%s: Card removed during transfer!\n",
+				       mmc_hostname(host->mmc));
+
+				host->mrq->cmd->error = -ENOMEDIUM;
+				tasklet_schedule(&host->finish_tasklet);
+			}
+
+			spin_unlock_irqrestore(&host->lock, flags);
+			if (host->vmmc) {
+				pr_info("mmc power off vmmc=0x%x\n",
+					(int)host->vmmc);
+				regulator_disable(host->vmmc);
+			}
+		} else
+			spin_unlock_irqrestore(&host->lock, flags);
+
+		mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	}
+}
+
+static inline int ext_cd_val(int gpio, int invert)
+{
+	int status;
+
+	status = gpio_get_value(gpio);
+	status &= (1 << (gpio % 32));
+	status = !!status;
+
+	if (invert)
+		status = !status;
+
+	return status;
+}
+
+static int pxav3_ext_cd_status(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_pxa *pxa;
+
+	pltfm_host = sdhci_priv(host);
+	pxa = pltfm_host->priv;
+
+	if (host->quirks & SDHCI_QUIRK_BROKEN_CARD_DETECTION)
+		return 1;
+	else
+		return ext_cd_val(pxa->pdata->ext_cd_gpio,pxa->pdata->ext_cd_gpio_invert);
+}
+
+static irqreturn_t ext_cd_irq_thread(int irq, void *dev_id)
+{
+	struct platform_device *pdev = dev_id;
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+	int status;
+
+	pr_info("sdcard gpio detected\n");
+
+	msleep(600);
+	status = ext_cd_val(pdata->ext_cd_gpio, pdata->ext_cd_gpio_invert);
+	ext_cd_notify_change(pdev, status);
+
+	return IRQ_HANDLED;
+}
+
+static int sdhci_pxa_recovery(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct sdhci_pxa *pxa;
+
+	pltfm_host = sdhci_priv(host);
+	pxa = pltfm_host->priv;
+
+	if (pxa && pxa->pdata && pxa->pdata->recovery)
+		return pxa->pdata->recovery(host, pxa->pdata);
+
+	return ERR_CONTINUE;
+}
+
+static void pxav3_clk_gate_ctl(struct sdhci_host *host, unsigned int clk_gate)
+{
+	u16 ctrl_2;
+
+	if (clk_gate) {
+		ctrl_2 = readw(host->ioaddr + SDHCI_HOST_CONTROL2);
+		ctrl_2 |= SDHCI_CTRL_AINT;
+		writew(ctrl_2, host->ioaddr + SDHCI_HOST_CONTROL2);
+	} else {
+		ctrl_2 = readw(host->ioaddr + SDHCI_HOST_CONTROL2);
+		ctrl_2 &= ~SDHCI_CTRL_AINT;
+		writew(ctrl_2, host->ioaddr + SDHCI_HOST_CONTROL2);
+	}
+}
+
 static struct sdhci_ops pxav3_sdhci_ops = {
+	.get_max_clock = pxav3_get_max_clock,
 	.platform_reset_exit = pxav3_set_private_registers,
 	.set_uhs_signaling = pxav3_set_uhs_signaling,
 	.platform_send_init_74_clocks = pxav3_gen_init_74_clocks,
+	.signal_vol_change = pxav3_signal_vol_change,
+	.access_constrain = pxav3_access_constrain,
+	.safe_regulator_on = sdhci_pxa_safe_regulator_on,
+	.recovery = sdhci_pxa_recovery,
+	.clk_gate_ctl = pxav3_clk_gate_ctl,
 };
 
+static int ext_cd_init(void *data)
+{
+	struct platform_device *pdev = data;
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+	int err, cd_irq, ext_cd_gpio;
+	int status;
+
+	cd_irq = gpio_to_irq(pdata->ext_cd_gpio);
+	ext_cd_gpio = pdata->ext_cd_gpio;
+
+	/*
+	 * setup GPIO for saarb MMC controller
+	 */
+	err = gpio_request(ext_cd_gpio, "mmc card detect");
+	if (err) {
+		printk(KERN_ERR "gpio_request err =%d\n", err);
+		goto err_request_cd;
+	}
+	gpio_direction_input(ext_cd_gpio);
+
+	err = request_threaded_irq(cd_irq, NULL, ext_cd_irq_thread,
+				   IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+				   "MMC card detect", pdev);
+	if (err) {
+		printk(KERN_ERR "%s: MMC/SD/SDIO: "
+		       "can't request card detect IRQ\n", __func__);
+		goto err_request_irq;
+	}
+
+	pr_info("sdcard gpio detect init done\n");
+	status = ext_cd_val(pdata->ext_cd_gpio, pdata->ext_cd_gpio_invert);
+	ext_cd_notify_change(pdev, status);
+
+	pxav3_sdhci_ops.is_present = pxav3_ext_cd_status;
+
+	return 0;
+
+err_request_irq:
+	gpio_free(ext_cd_gpio);
+err_request_cd:
+	return -1;
+}
+
+#ifdef CONFIG_PM
+static int sdhci_pxav3_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+	int ret = 0;
+
+	if (host->runtime_suspended) {
+		printk(KERN_WARNING"%s already suspended\n", mmc_hostname(host->mmc));
+		return ret;
+	}
+	host->runtime_suspended = true;
+	pdata->suspended = 1;
+
+	if(pxa->pdata->flags & PXA_FLAG_KEEP_POWER_IN_SUSPEND) {
+		if (host->mmc->card) {
+			mmc_claim_host(host->mmc);
+			mmc_send_status(host->mmc->card, NULL);
+			mmc_release_host(host->mmc);
+		}
+		return ret;
+	}
+
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(host->irq);
+
+	ret = sdhci_suspend_host(host);
+	if (ret) {
+		host->runtime_suspended = false;
+		return ret;
+	}
+
+	if (pdata->lp_switch) {
+		ret = pdata->lp_switch(1, (int)host->mmc->card);
+		if (ret) {
+			host->runtime_suspended = false;
+			sdhci_resume_host(host);
+			dev_err(&pdev->dev, "fail to switch gpio, resume..\n");
+		}
+	}
+
+	return ret;
+}
+
+static int sdhci_pxav3_resume(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+	int ret = 0;
+
+	if(pxa->pdata->flags & PXA_FLAG_KEEP_POWER_IN_SUSPEND)
+		goto exit_resume;
+
+	if (pdata->lp_switch)
+		pdata->lp_switch(0, (int)host->mmc->card);
+
+	ret = sdhci_resume_host(host);
+
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(host->irq);
+exit_resume:
+	host->runtime_suspended = false;
+	pdata->suspended = 0;
+
+	return ret;
+}
+#endif
+
 static int __devinit sdhci_pxav3_probe(struct platform_device *pdev)
 {
 	struct sdhci_pltfm_host *pltfm_host;
@@ -173,6 +517,12 @@ static int __devinit sdhci_pxav3_probe(struct platform_device *pdev)
 	struct sdhci_pxa *pxa = NULL;
 	int ret;
 	struct clk *clk;
+#if !defined(CONFIG_CPU_PXA978)
+	int pm_qos_class = PM_QOS_CPU_DMA_LATENCY;
+#ifdef CONFIG_CPU_PXA988
+	pm_qos_class = PM_QOS_CPUIDLE_KEEP_AXI;
+#endif
+#endif
 
 	pxa = kzalloc(sizeof(struct sdhci_pxa), GFP_KERNEL);
 	if (!pxa)
@@ -197,12 +547,14 @@ static int __devinit sdhci_pxav3_probe(struct platform_device *pdev)
 
 	host->quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
 		| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC
-		| SDHCI_QUIRK_32BIT_ADMA_SIZE;
-
-	/* enable 1/8V DDR capable */
-	host->mmc->caps |= MMC_CAP_1_8V_DDR;
+		| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;
 
 	if (pdata) {
+#if !defined(CONFIG_CPU_PXA978)
+		pm_qos_add_request(&pdata->qos_idle, pm_qos_class,
+			PM_QOS_DEFAULT_VALUE);
+#endif
+
 		if (pdata->flags & PXA_FLAG_CARD_PERMANENT) {
 			/* on-chip device */
 			host->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;
@@ -213,24 +565,81 @@ static int __devinit sdhci_pxav3_probe(struct platform_device *pdev)
 		if (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)
 			host->mmc->caps |= MMC_CAP_8_BIT_DATA;
 
+		if (pdata && pdata->flags & PXA_FLAG_ACITVE_IN_SUSPEND) {
+			host->mmc->pm_flags |= MMC_PM_ALWAYS_ACTIVE;
+		}
+
+		if (pdata && pdata->flags & PXA_FLAG_KEEP_POWER_IN_SUSPEND) {
+			host->mmc->pm_flags |= MMC_PM_KEEP_POWER;
+		}
+
+		if (pdata->flags & PXA_FLAG_ENABLE_CLOCK_GATING) {
+			pxav3_access_constrain(host, 1);
+			host->mmc->caps |= MMC_CAP_ENABLE_BUS_CLK_GATING;
+		}
+
+		if (pdata->flags & (PXA_FLAG_DISABLE_PROBE_CDSCAN |
+						PXA_FLAG_SDIO_CTRLCLKSRC_GATE))
+			host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;
+
+		if (pdata->handle_cdint)
+			pxav3_sdhci_ops.handle_cdint = pdata->handle_cdint;
+
 		if (pdata->quirks)
 			host->quirks |= pdata->quirks;
 		if (pdata->host_caps)
 			host->mmc->caps |= pdata->host_caps;
 		if (pdata->pm_caps)
 			host->mmc->pm_caps |= pdata->pm_caps;
+		if (pdata->clk_err_per_allow)
+			host->clk_err_per_allow = pdata->clk_err_per_allow;
 	}
 
+	host->quirks2 |= SDHCI_QUIRK2_NO_CURRENT_LIMIT;
+
+#ifdef CONFIG_CPU_PXA978
+	ret = dvfm_register((char *)mmc_hostname(host->mmc), &pltfm_host->dvfm_dev_idx);
+	if(ret) {
+		pr_err("Error %d: Fails to register %s into dvfm.\n",
+				ret, mmc_hostname(host->mmc));
+		goto err_clk_get;
+	}
+#endif
 	host->ops = &pxav3_sdhci_ops;
 
+	pxa->pdata = pdata;
 	ret = sdhci_add_host(host);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to add host\n");
 		goto err_add_host;
 	}
 
+	/* remove the caps that supported by the controller but not available
+	 * for certain platforms.
+	 */
+	if (pdata && pdata->host_caps_disable)
+		host->mmc->caps &= ~(pdata->host_caps_disable);
+
 	platform_set_drvdata(pdev, host);
 
+	if (pdata->flags & PXA_FLAG_WAKEUP_HOST)
+		device_init_wakeup(&pdev->dev, 1);
+	else
+		device_init_wakeup(&pdev->dev, 0);
+
+	if (pdata && pdata->ext_cd_gpio)
+		ext_cd_init(pdev);
+
+#ifdef CONFIG_SD8XXX_RFKILL
+	if (pxa->pdata->pmmc)
+		*pxa->pdata->pmmc = host->mmc;
+
+	if (pdata && pdata->flags & PXA_FLAG_SDIO_CTRLCLKSRC_GATE) {
+		host->clk = clk; /* hook the clock for rfkill use */
+		clk_disable(clk);
+	}
+#endif
+
 	return 0;
 
 err_add_host:
@@ -264,10 +673,13 @@ static struct platform_driver sdhci_pxav3_driver = {
 	.driver		= {
 		.name	= "sdhci-pxav3",
 		.owner	= THIS_MODULE,
-		.pm	= SDHCI_PLTFM_PMOPS,
 	},
 	.probe		= sdhci_pxav3_probe,
 	.remove		= __devexit_p(sdhci_pxav3_remove),
+#ifdef CONFIG_PM
+	.suspend	= sdhci_pxav3_suspend,
+	.resume		= sdhci_pxav3_resume,
+#endif
 };
 
 module_platform_driver(sdhci_pxav3_driver);
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index f761f23..add246d 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -167,6 +167,7 @@
 #define   SDHCI_CTRL_DRV_TYPE_D		0x0030
 #define  SDHCI_CTRL_EXEC_TUNING		0x0040
 #define  SDHCI_CTRL_TUNED_CLK		0x0080
+#define  SDHCI_CTRL_AINT		0x4000
 #define  SDHCI_CTRL_PRESET_VAL_ENABLE	0x8000
 
 #define SDHCI_CAPABILITIES	0x40
@@ -187,6 +188,7 @@
 #define  SDHCI_CAN_VDD_300	0x02000000
 #define  SDHCI_CAN_VDD_180	0x04000000
 #define  SDHCI_CAN_64BIT	0x10000000
+#define  SDHCI_CAN_ASYN_INT	0x20000000
 
 #define  SDHCI_SUPPORT_SDR50	0x00000001
 #define  SDHCI_SUPPORT_SDR104	0x00000002
@@ -241,6 +243,8 @@
  * End of controller registers.
  */
 
+extern int mmc_send_status(struct mmc_card *card, u32 *status);
+
 #define SDHCI_MAX_DIV_SPEC_200	256
 #define SDHCI_MAX_DIV_SPEC_300	2046
 
@@ -277,6 +281,13 @@ struct sdhci_ops {
 	void	(*hw_reset)(struct sdhci_host *host);
 	void	(*platform_suspend)(struct sdhci_host *host);
 	void	(*platform_resume)(struct sdhci_host *host);
+	void	(*signal_vol_change)(struct sdhci_host *host, u8 vol);
+	void	(*access_constrain)(struct sdhci_host *host, unsigned int ac);
+	void	(*handle_cdint)(struct sdhci_host *host);
+	int	(*is_present)(struct sdhci_host *host);
+	int	(*safe_regulator_on)(struct sdhci_host *host);
+	int	(*recovery)(struct sdhci_host *host);
+	void 	(*clk_gate_ctl)(struct sdhci_host *host, unsigned int clk_gate);
 };
 
 #ifdef CONFIG_MMC_SDHCI_IO_ACCESSORS
diff --git a/include/linux/mmc/pm.h b/include/linux/mmc/pm.h
index 4a13920..b068237 100644
--- a/include/linux/mmc/pm.h
+++ b/include/linux/mmc/pm.h
@@ -26,5 +26,9 @@ typedef unsigned int mmc_pm_flag_t;
 
 #define MMC_PM_KEEP_POWER	(1 << 0)	/* preserve card power during suspend */
 #define MMC_PM_WAKE_SDIO_IRQ	(1 << 1)	/* wake up host system on SDIO IRQ assertion */
+#define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */
+#define MMC_PM_FUNC_SUSPENDED   (1 << 3)        /* function is suspended */
+#define MMC_PM_ALWAYS_ACTIVE	(1 << 4)	/* keep host functional during suspend */
+#define MMC_PM_IRQ_ALWAYS_ON	(1 << 5)	/* keep host controller's irq enabled after suspend */
 
 #endif /* LINUX_MMC_PM_H */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index e9051e1..73a797b 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -89,8 +89,11 @@ struct sdhci_host {
 #define SDHCI_QUIRK_UNSTABLE_RO_DETECT			(1<<31)
 
 	unsigned int quirks2;	/* More deviations from spec. */
-
 #define SDHCI_QUIRK2_HOST_OFF_CARD_ON			(1<<0)
+/* Some SDHCI v3 controller doesn't suppport current limit error*/
+#define SDHCI_QUIRK2_NO_CURRENT_LIMIT			(2<<0)
+/* Controller only make sure 8 dummy clock druing system suspend */
+#define SDHCI_QUIRK2_DUMMY_CLK_ONLY_SUSPEND		(1<<2)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
@@ -128,6 +131,7 @@ struct sdhci_host {
 	unsigned int max_clk;	/* Max possible freq (MHz) */
 	unsigned int timeout_clk;	/* Timeout freq (KHz) */
 	unsigned int clk_mul;	/* Clock Muliplier value */
+	unsigned int clk_err_per_allow; /* how much percentage error allow */
 
 	unsigned int clock;	/* Current clock (MHz) */
 	u8 pwr;			/* Current voltage */
diff --git a/include/linux/platform_data/pxa_sdhci.h b/include/linux/platform_data/pxa_sdhci.h
index 51ad099..becdb02 100644
--- a/include/linux/platform_data/pxa_sdhci.h
+++ b/include/linux/platform_data/pxa_sdhci.h
@@ -14,6 +14,9 @@
 #ifndef _PXA_SDHCI_H_
 #define _PXA_SDHCI_H_
 
+#include <linux/pm_qos.h>
+#include <linux/mmc/sdhci.h>
+
 /* pxa specific flag */
 /* Require clock free running */
 #define PXA_FLAG_ENABLE_CLOCK_GATING (1<<0)
@@ -21,6 +24,22 @@
 #define PXA_FLAG_CARD_PERMANENT	(1<<1)
 /* Board design supports 8-bit data on SD/SDIO BUS */
 #define PXA_FLAG_SD_8_BIT_CAPABLE_SLOT (1<<2)
+/* adding host sleep feature needs a wakelock,
+       for sdio slot on Tavor/MG/Nevo only */
+#define PXA_FLAG_HS_NEED_WAKELOCK (1<<3)
+/* MMC functionality always active during suspend */
+#define PXA_FLAG_ACITVE_IN_SUSPEND (1<<4)
+/* wifi wakeup host sleep feature */
+#define PXA_FLAG_WAKEUP_HOST (1<<5)
+/* controller always active during suspend */
+#define PXA_FLAG_KEEP_POWER_IN_SUSPEND (1<<6)
+/* disable card scanning in probe procedure,
+	eg, for 8787 wifi/bt/fm sdio card */
+#define PXA_FLAG_DISABLE_PROBE_CDSCAN (1 << 7)
+/* the high-level controller clock source dynamic gating(eg, used for 8787):
+       clock source will be on/off when controller probe starts/ends,
+       8787 powering on, and powering off */
+#define PXA_FLAG_SDIO_CTRLCLKSRC_GATE (1 << 8)
 
 /*
  * struct pxa_sdhci_platdata() - Platform device data for PXA SDHCI
@@ -39,22 +58,78 @@
  * @host_caps: Standard MMC host capabilities bit field.
  * @quirks: quirks of platfrom
  * @pm_caps: pm_caps of platfrom
+ * @signal_1v8: signaling change to 1.8V
+ * @lp_switch(): slot operations needed while going in/out low-power mode
+ * @handle_cdint: special SDIO card interrupt hanlder
+ * @idle_lock: wake lock for idle
  */
+struct sdhci_pxa_platdata;
 struct sdhci_pxa_platdata {
 	unsigned int	flags;
 	unsigned int	clk_delay_cycles;
 	unsigned int	clk_delay_sel;
+	unsigned int	clk_err_per_allow;
 	bool		clk_delay_enable;
 	unsigned int	ext_cd_gpio;
 	bool		ext_cd_gpio_invert;
 	unsigned int	max_speed;
 	unsigned int	host_caps;
+	unsigned int	host_caps_disable;
 	unsigned int	quirks;
+	unsigned int	quirks2;
 	unsigned int	pm_caps;
+	int		mfp_start;
+	int		mfp_num;
+	int		pull_up;/*1--external pull-up, 0--no external pull-up*/
+
+	int		recovery_status;/* mmc recovery status */
+#define SDHCI_RECOVERY_INIT		0
+#define SDHCI_RECOVERY_DEL		1
+#define SDHCI_RECOVERY_DS		2
+#define SDHCI_RECOVERY_CLK_SLOW		3
+#define SDHCI_RECOVERY_OUTER		4
+#define SDHCI_RECOVERY_SIM		5
+#define SDHCI_RECOVERY_REM		6
+#define SDHCI_RECOVERY_FINISH		31
+
+	int		highspeed;/*indicate whether it's highspeed card*/
+	unsigned int	ori_ds;/*original drive strength*/
+	unsigned int 	ori_del;/*original delay clock*/
+	u32		del_addr;/*delay clock VA*/
+	unsigned int	ori_clk;/*original bus clock*/
+
+	void	(*signal_1v8)(int set);
+	int	(*lp_switch)(unsigned int on, int with_card);
+	void (*handle_cdint)(struct sdhci_host *host);
+	int	(*check_short_circuit)(struct sdhci_host *, const int,
+			const int, const int);
+	int	(*safe_regulator_on)(struct sdhci_host *, const int,
+			const int);
+	int	(*recovery)(struct sdhci_host *, struct sdhci_pxa_platdata *);
+	struct	pm_qos_request	qos_idle;
+
+	int	suspended;
+#ifdef CONFIG_WAKELOCK
+	struct wake_lock	idle_lock;
+#endif
+#ifdef CONFIG_SD8XXX_RFKILL
+	/*for sd8688-rfkill device*/
+	struct mmc_host **pmmc;
+#endif
+	int 	regs_extended;
 };
 
 struct sdhci_pxa {
 	u8	clk_enable;
 	u8	power_mode;
+
+	struct sdhci_pxa_platdata       *pdata;
 };
+
+#ifdef CONFIG_CPU_PXA910
+int mmc1_idle_switch(u32 on);
+#endif
+
+extern void sdhci_pxa_notify_change(struct sdhci_host *host, int state);
+
 #endif /* _PXA_SDHCI_H_ */
-- 
1.7.5.4

