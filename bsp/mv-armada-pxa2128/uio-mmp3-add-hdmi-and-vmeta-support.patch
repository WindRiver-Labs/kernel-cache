From df94ebb74eca1ad4b151f34435ff34cfe5d674b0 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 19 Aug 2013 23:33:21 +0800
Subject: [PATCH 35/60] uio: mmp3: add hdmi and vmeta support

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31. This patch forward-ports the driver to WRLinux 3.4.x for
mmp3.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/mmp3.c            |    1 +
 arch/arm/plat-pxa/include/plat/pm.h |    2 +-
 drivers/uio/Kconfig                 |   24 +
 drivers/uio/Makefile                |    2 +
 drivers/uio/uio.c                   |   52 ++-
 drivers/uio/uio_hdmi.c              |  760 ++++++++++++++++++++++++++++++++
 drivers/uio/uio_vmeta.c             |  811 +++++++++++++++++++++++++++++++++++
 drivers/uio/uio_vmeta.h             |   58 +++
 include/linux/uio_coda7542.h        |   24 +
 include/linux/uio_driver.h          |    6 +
 include/linux/uio_vmeta.h           |   58 +++
 include/linux/vdec_os_api.h         |  166 +++++++
 include/linux/vmeta.h               |   47 ++
 13 files changed, 2000 insertions(+), 11 deletions(-)
 create mode 100644 drivers/uio/uio_hdmi.c
 create mode 100644 drivers/uio/uio_vmeta.c
 create mode 100644 drivers/uio/uio_vmeta.h
 create mode 100644 include/linux/uio_coda7542.h
 create mode 100644 include/linux/uio_vmeta.h
 create mode 100644 include/linux/vdec_os_api.h
 create mode 100644 include/linux/vmeta.h

diff --git a/arch/arm/mach-mmp/mmp3.c b/arch/arm/mach-mmp/mmp3.c
index 2a98d4e..d340774 100644
--- a/arch/arm/mach-mmp/mmp3.c
+++ b/arch/arm/mach-mmp/mmp3.c
@@ -46,6 +46,7 @@
 #include <linux/memblock.h>
 #include <mach/isp_dev.h>
 #include <mach/mv_wtm.h>
+#include <linux/pm_qos.h>
 #include <linux/platform_device.h>
 
 #include <plat/mfp.h>
diff --git a/arch/arm/plat-pxa/include/plat/pm.h b/arch/arm/plat-pxa/include/plat/pm.h
index 36b13ba..daf7336 100644
--- a/arch/arm/plat-pxa/include/plat/pm.h
+++ b/arch/arm/plat-pxa/include/plat/pm.h
@@ -11,7 +11,7 @@
 #ifndef __PM_H__
 #define __PM_H__
 
-#include <linux/pm_qos_params.h>
+#include <linux/pm_qos.h>
 
 /* MMP2 cpuidle exit latency */
 #define EXIT_LATENCY_CORE_EXTIDLE		1
diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 82e2b89..33fcc90 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -127,4 +127,28 @@ config UIO_PRUSS
 	  To compile this driver as a module, choose M here: the module
 	  will be called uio_pruss.
 
+config UIO_VMETA
+	tristate "Vmeta UIO device driver"
+	depends on UIO && (PXA95x || CPU_MMP3 || CPU_MMP2)
+	default n
+	help
+	  Userspace IO interface to the Marvell multi-format video
+	  decoder engine.
+
+	  If you compile this as a module, it will be called uio_vmeta.
+
+config VMETA_POLLING_MODE
+	tristate "Vmeta poll mode"
+	depends on UIO_VMETA
+	default n
+	help
+	  Enable Vmeta interrupt mode by default. If it is set to y, it will be the polling mode.
+
+config UIO_HDMI
+	tristate "Userspace HDMI driver"
+	depends on UIO && !CPU_PXA955
+	default y
+	help
+	  Userspace IO interface to the Marvell hdmi controller.
+
 endif
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index b354c53..993a346 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -8,3 +8,5 @@ obj-$(CONFIG_UIO_SERCOS3)	+= uio_sercos3.o
 obj-$(CONFIG_UIO_PCI_GENERIC)	+= uio_pci_generic.o
 obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
 obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
+obj-$(CONFIG_UIO_VMETA)	+= uio_vmeta.o
+obj-$(CONFIG_UIO_HDMI) += uio_hdmi.o
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index a783d53..dc03d7a 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -430,11 +430,6 @@ static irqreturn_t uio_interrupt(int irq, void *dev_id)
 	return ret;
 }
 
-struct uio_listener {
-	struct uio_device *dev;
-	s32 event_count;
-};
-
 static int uio_open(struct inode *inode, struct file *filep)
 {
 	struct uio_device *idev;
@@ -507,13 +502,18 @@ static unsigned int uio_poll(struct file *filep, poll_table *wait)
 {
 	struct uio_listener *listener = filep->private_data;
 	struct uio_device *idev = listener->dev;
+	s32 event_count;
 
 	if (!idev->info->irq)
 		return -EIO;
 
 	poll_wait(filep, &idev->wait, wait);
-	if (listener->event_count != atomic_read(&idev->event))
+
+	event_count = atomic_read(&idev->event);
+	if (listener->event_count != event_count) {
+		listener->event_count = event_count;
 		return POLLIN | POLLRDNORM;
+	}
 	return 0;
 }
 
@@ -634,7 +634,8 @@ static int uio_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 	if (idev->info->mem[mi].memtype == UIO_MEM_LOGICAL)
 		page = virt_to_page(idev->info->mem[mi].addr + offset);
 	else
-		page = vmalloc_to_page((void *)(unsigned long)idev->info->mem[mi].addr + offset);
+		page = vmalloc_to_page((void *)idev->info->mem[mi].addr
+							+ offset);
 	get_page(page);
 	vmf->page = page;
 	return 0;
@@ -655,7 +656,12 @@ static int uio_mmap_physical(struct vm_area_struct *vma)
 
 	vma->vm_flags |= VM_IO | VM_RESERVED;
 
+#ifdef CONFIG_CPU_V7
+	vma->vm_page_prot = __pgprot_modify(
+		vma->vm_page_prot, L_PTE_MT_MASK, L_PTE_MT_DEV_SHARED);
+#else
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+#endif
 
 	return remap_pfn_range(vma,
 			       vma->vm_start,
@@ -711,6 +717,30 @@ static int uio_mmap(struct file *filep, struct vm_area_struct *vma)
 	}
 }
 
+static long uio_unlocked_ioctl(struct file *filep,
+				unsigned int cmd, unsigned long arg)
+{
+	struct uio_listener *listener = filep->private_data;
+	struct uio_device *idev = listener->dev;
+	int ret = 0;
+
+	if (!idev)
+		return -ENODEV;
+
+	if (idev->info) {
+		if (idev->info->ioctl) {
+			if (!try_module_get(idev->owner))
+				return -ENODEV;
+			ret = idev->info->ioctl(idev->info, cmd, arg);
+			module_put(idev->owner);
+
+			return ret;
+		}
+	}
+
+	return -EINVAL;
+}
+
 static const struct file_operations uio_fops = {
 	.owner		= THIS_MODULE,
 	.open		= uio_open,
@@ -718,6 +748,7 @@ static const struct file_operations uio_fops = {
 	.read		= uio_read,
 	.write		= uio_write,
 	.mmap		= uio_mmap,
+	.unlocked_ioctl	= uio_unlocked_ioctl,
 	.poll		= uio_poll,
 	.fasync		= uio_fasync,
 	.llseek		= noop_llseek,
@@ -749,13 +780,14 @@ static int uio_major_init(void)
 
 	uio_major = MAJOR(uio_dev);
 	uio_cdev = cdev;
-	return 0;
+	result = 0;
+out:
+	return result;
 out_put:
 	kobject_put(&cdev->kobj);
 out_unregister:
 	unregister_chrdev_region(uio_dev, UIO_MAX_DEVICES);
-out:
-	return result;
+	goto out;
 }
 
 static void uio_major_cleanup(void)
diff --git a/drivers/uio/uio_hdmi.c b/drivers/uio/uio_hdmi.c
new file mode 100644
index 0000000..d62b79a
--- /dev/null
+++ b/drivers/uio/uio_hdmi.c
@@ -0,0 +1,760 @@
+/*
+ * Marvell HDMI UIO driver, support hdmi@ MMP2/MMP3/NEVO
+ *
+ * Yifan Zhang <zhangyf@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ * (c) 2010
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/uio_driver.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <linux/earlysuspend.h>
+#include <linux/pm_qos.h>
+#include <plat/pm.h>
+#include <mach/uio_hdmi.h>
+#include <plat/devfreq.h>
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+#include <mach/addr-map.h>
+#include <mach/cputype.h>
+#endif
+#if defined(CONFIG_CPU_PXA978)
+#include <mach/dvfm.h>
+#endif
+
+static atomic_t hdmi_state = ATOMIC_INIT(0);
+enum connect_lock con_lock;
+static bool timer_inited = 0;
+static int late_disable_flag;
+static int early_suspend_flag;
+#if defined(CONFIG_CPU_PXA978)
+static int suspend_flag;
+extern int hdmi_conv_on;
+static int dvfm_dev_idx;
+static unsigned int *arb_f_mc, *arb_n_mc;
+static unsigned int val_f_mc, val_n_mc;
+extern void update_lcd_controller_clock(int on);
+#endif
+
+enum connect_status {
+	CABLE_CONNECT = 0,
+	CABLE_DISCNCT = 1,
+};
+
+enum hdmi_status {
+	HDMI_OFF = 0,
+	HDMI_ON = 1,
+};
+
+struct hdmi_instance {
+	struct clk *clk;
+	void *reg_base;
+	void *sspa1_reg_base;
+	unsigned int hpd_in; /* if cable plug in, this is the gpio value*/
+	unsigned int gpio;
+	unsigned int edid_bus_num;
+	struct timer_list jitter_timer;
+	struct work_struct work;
+	struct delayed_work delay_resumed;
+	struct delayed_work delay_disable;
+	struct uio_info uio_info;
+	struct early_suspend    early_suspend;
+	int (*hdmi_power)(int on);
+	struct pm_qos_request qos_cpufreq_min;
+	struct pm_qos_request qos_cpufreq_disable;
+	struct pm_qos_request qos_idle;
+	struct pm_qos_request qos_ddrfreq_min;
+};
+
+static void set_power_constraint(struct hdmi_instance *hi, int min)
+{
+#ifdef CONFIG_CPU_MMP2
+	pm_qos_update_request(&hi->qos_idle, PM_QOS_CONSTRAINT);
+	pm_qos_update_request(&hi->qos_cpufreq_min, min);
+	pm_qos_update_request(&hi->qos_cpufreq_disable, 1);
+#endif
+
+#ifdef CONFIG_CPU_MMP3
+	/* set DDR frequency constraint @ 400M, ddr constraint need 2x value */
+	pm_qos_update_request(&hi->qos_cpufreq_min, min);
+#if defined(CONFIG_DDR_DEVFREQ)
+	pm_qos_update_request(&hi->qos_ddrfreq_min, DDR_CONSTRAINT_LVL2);
+#endif
+#endif
+
+#ifdef CONFIG_CPU_PXA978
+	printk("hdmi: set_power_constraint\n");
+	dvfm_disable_op_name("728M", dvfm_dev_idx);
+	dvfm_disable_op_name("416M", dvfm_dev_idx);
+	dvfm_disable_op_name("312M", dvfm_dev_idx);
+	dvfm_disable_op_name("156M", dvfm_dev_idx);
+	/* Disable Lowpower mode */
+	dvfm_disable_op_name("D1", dvfm_dev_idx);
+	dvfm_disable_op_name("D2", dvfm_dev_idx);
+	dvfm_disable_op_name("CG", dvfm_dev_idx);
+#endif
+}
+
+static void unset_power_constraint(struct hdmi_instance *hi)
+{
+#ifdef CONFIG_CPU_MMP2
+	pm_qos_update_request(&hi->qos_idle, PM_QOS_DEFAULT_VALUE);
+	pm_qos_update_request(&hi->qos_cpufreq_min, PM_QOS_DEFAULT_VALUE);
+	pm_qos_update_request(&hi->qos_cpufreq_disable, PM_QOS_DEFAULT_VALUE);
+#endif
+
+#ifdef CONFIG_CPU_MMP3
+	pm_qos_update_request(&hi->qos_cpufreq_min, PM_QOS_DEFAULT_VALUE);
+#ifdef CONFIG_DDR_DEVFREQ
+	pm_qos_update_request(&hi->qos_ddrfreq_min, PM_QOS_DEFAULT_VALUE);
+#endif
+#endif
+
+#ifdef CONFIG_CPU_PXA978
+	printk("hdmi: unset_power_constraint\n");
+	dvfm_enable_op_name("156M", dvfm_dev_idx);
+	dvfm_enable_op_name("312M", dvfm_dev_idx);
+	dvfm_enable_op_name("416M", dvfm_dev_idx);
+	dvfm_enable_op_name("728M", dvfm_dev_idx);
+	/* Enable Lowpower mode */
+	dvfm_enable_op_name("D1", dvfm_dev_idx);
+	dvfm_enable_op_name("D2", dvfm_dev_idx);
+	dvfm_enable_op_name("CG", dvfm_dev_idx);
+#endif
+}
+
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+static u32 hdmi_direct_read(unsigned addr)
+{
+       u32 hdmi_addr = AXI_VIRT_BASE + 0xbc00;
+
+	return __raw_readl(hdmi_addr + addr);
+}
+static void hdmi_direct_write(unsigned addr, unsigned data)
+{
+       u32 hdmi_addr = AXI_VIRT_BASE + 0xbc00;
+
+	__raw_writel(data, hdmi_addr + addr);
+}
+
+void hdmi_3d_sync_view(int right)
+{
+	u32 v = right ? 0x7 : 0xf;
+	hdmi_direct_write(0x30, v);
+}
+EXPORT_SYMBOL_GPL(hdmi_3d_sync_view);
+
+#endif
+
+int hdmi_open(struct uio_info *info, struct inode *inode)
+{
+	return 0;
+}
+
+int hdmi_release(struct uio_info *info, struct inode *indoe)
+{
+	return 0;
+}
+
+static int hdmi_ioctl(struct uio_info *info, unsigned cmd, unsigned long arg)
+{
+	unsigned offset, val;
+	void *argp = (void *)arg;
+	struct hdmi_instance *hi =
+		container_of(info, struct hdmi_instance, uio_info);
+	int hpd = CABLE_DISCNCT;
+
+	switch (cmd) {
+	case SSPA1_GET_VALUE:
+		if (copy_from_user(&offset, argp, sizeof(offset)))
+			return -EFAULT;
+		val = readl(hi->sspa1_reg_base + offset);
+		if (copy_to_user(argp, &val, sizeof(val)))
+			return -EFAULT;
+		break;
+	case HPD_PIN_READ:
+		/* when resume, force disconnect/connect HDMI */
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+		if (con_lock == FIRST_ACCESS_LOCK) {
+			hpd = CABLE_DISCNCT;
+			con_lock = SECOND_ACCESS_LOCK;
+		} else if (con_lock == SECOND_ACCESS_LOCK) {
+			hpd = CABLE_CONNECT;
+			con_lock = UNLOCK;
+		}
+#elif defined(CONFIG_CPU_PXA978)
+		if (con_lock == FIRST_ACCESS_LOCK) {
+			hpd = CABLE_DISCNCT;
+			con_lock = UNLOCK;
+		}
+#endif
+		else {
+			if (atomic_read(&hdmi_state) == HDMI_ON)
+				hpd = CABLE_CONNECT;
+			else {
+				hpd = CABLE_DISCNCT;
+				/*if disconnected HDMI,
+				 * 300 ms is the time wait for HDMI is
+				 * disabled, then disp1_axi_bus can be disabled.
+				 * disp1_axi_bus clear will cause HDMI clock
+				 * disbaled and any operation not takes effects*/
+				if (late_disable_flag)
+					schedule_delayed_work(&hi->delay_disable,
+						msecs_to_jiffies(200));
+			}
+		}
+		if (copy_to_user(argp, &hpd, sizeof(int))) {
+			pr_err("copy_to_user error !~!\n");
+			return -EFAULT;
+		}
+		printk("uio_hdmi: report cable %s to hdmi-service\n",
+			(hpd==CABLE_CONNECT)?"pulg in":"pull out");
+		break;
+	case EDID_NUM:
+		if (copy_to_user(argp, &hi->edid_bus_num,
+					sizeof(unsigned int))) {
+			pr_err("copy to user error !\n");
+			return -EFAULT;
+		}
+		break;
+#ifdef CONFIG_CPU_PXA978
+	case HDMI_PLL_ENABLE:
+		clk_enable(hi->clk);
+		break;
+	case HDMI_PLL_DISABLE:
+		clk_disable(hi->clk);
+		break;
+	case HDMI_PLL_SETRATE: {
+			int hdmi_freq = 0;
+			if (copy_from_user(&hdmi_freq, argp, sizeof(hdmi_freq)))
+				return -EFAULT;
+			printk("uio_hdmi: set TMDS clk freq = %dMhz\n", hdmi_freq/5);
+			if (clk_set_rate(hi->clk, hdmi_freq * 1000000)) {
+				pr_err(KERN_ERR "uio_hdmi: HDMI PLL set failed!\n");
+				return -EFAULT;
+			}
+		}
+		break;
+#endif
+	default:
+		pr_err("uio_hdmi: no suppprt ioctl!\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static int hdmi_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#if defined(CONFIG_CPU_PXA978)
+static void arbiter_init(void)
+{
+	arb_f_mc = ioremap_nocache(0x7ff007b0, 4);
+	arb_n_mc = ioremap_nocache(0x7ff00280, 4);
+	val_f_mc = *arb_f_mc;
+	val_n_mc = *arb_n_mc;
+}
+
+static void arbiter_set(void)
+{
+	/* raise priority of display controller mc arbiter*/
+	val_f_mc = *arb_f_mc;
+	val_n_mc = *arb_n_mc;
+	*arb_f_mc = 0x010f0101;
+	*arb_n_mc = 0x010f0101;
+}
+
+static void arbiter_clr(void)
+{
+	*arb_f_mc = val_f_mc;
+	*arb_n_mc = val_n_mc;
+}
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hdmi_early_suspend_nevo(struct early_suspend *h)
+{
+	return;
+}
+
+static void hdmi_late_resume_nevo(struct early_suspend *h)
+{
+	struct hdmi_instance *hi =
+		container_of(h, struct hdmi_instance, early_suspend);
+	if (suspend_flag == 1) {
+		/* always turn on 5v power*/
+		if (hi->hdmi_power)
+			hi->hdmi_power(1);
+
+		con_lock = FIRST_ACCESS_LOCK;
+		/* send disconnect event to upper layer */
+		uio_event_notify(&hi->uio_info);
+		mod_timer(&hi->jitter_timer, jiffies + HZ/4);
+		suspend_flag = 0;
+	}
+	printk("uio_hdmi: hdmi late resume done!\n");
+	return;
+}
+#endif
+
+static int hdmi_suspend_nevo(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct hdmi_instance *hi = platform_get_drvdata(pdev);
+	suspend_flag = 1;
+	if (atomic_read(&hdmi_state) == HDMI_ON) {
+		clk_disable(hi->clk);
+		if (hi->hdmi_power)
+			hi->hdmi_power(0);
+		arbiter_clr();
+		atomic_set(&hdmi_state, HDMI_OFF);
+		unset_power_constraint(hi);
+		update_lcd_controller_clock(0);
+	}
+	/* always turn off 5v power*/
+	if (hi->hdmi_power)
+		hi->hdmi_power(0);
+	pdev->dev.power.power_state = mesg;
+	del_timer(&hi->jitter_timer);
+	printk("uio_hdmi: suspend done!\n");
+	return 0;
+}
+
+static int hdmi_resume_nevo(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#elif defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void hdmi_early_suspend_mmp(struct early_suspend *h)
+{
+	struct hdmi_instance *hi =
+		container_of(h, struct hdmi_instance, early_suspend);
+	if (atomic_read(&hdmi_state) == HDMI_ON)
+		unset_power_constraint(hi);
+	early_suspend_flag = 1;
+	return;
+}
+static void hdmi_late_resume_mmp(struct early_suspend *h)
+{
+	struct hdmi_instance *hi =
+		container_of(h, struct hdmi_instance, early_suspend);
+	if (atomic_read(&hdmi_state) == HDMI_ON)
+		set_power_constraint(hi, HDMI_FREQ_CONSTRAINT);
+	early_suspend_flag = 0;
+	return;
+}
+#endif
+static int hdmi_suspend_mmp(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct hdmi_instance *hi = platform_get_drvdata(pdev);
+
+	/* MMP3 */
+	if (cpu_is_mmp3()) {
+		clk_disable(hi->clk);
+		if (hi->hdmi_power)
+			hi->hdmi_power(0);
+	/* MMP2 */
+	} else if (atomic_read(&hdmi_state) == HDMI_ON) {
+		clk_disable(hi->clk);
+		if (hi->hdmi_power)
+			hi->hdmi_power(0);
+	}
+	pdev->dev.power.power_state = mesg;
+	printk("uio_hdmi: suspend done!\n");
+	return 0;
+}
+
+static int hdmi_resume_mmp(struct platform_device *pdev)
+{
+	struct hdmi_instance *hi = platform_get_drvdata(pdev);
+
+#if defined(CONFIG_CPU_MMP3)
+	/* always turn on 5v power and clock*/
+	if (hi->hdmi_power)
+		hi->hdmi_power(1);
+	clk_enable(hi->clk);
+#endif
+	if (gpio_get_value(hi->gpio) == hi->hpd_in) {
+		/*if connected, reset HDMI*/
+		atomic_set(&hdmi_state, HDMI_ON);
+#if defined(CONFIG_CPU_MMP2)
+		clk_enable(hi->clk);
+		if (hi->hdmi_power)
+			hi->hdmi_power(1);
+#endif
+		con_lock = FIRST_ACCESS_LOCK;
+		/* send disconnect event to upper layer */
+		uio_event_notify(&hi->uio_info);
+		/*if uio_event_notify both directly, 1 event will be
+		 * missed, so delayed_work*/
+		schedule_delayed_work(&hi->delay_resumed,
+			msecs_to_jiffies(1500));
+	} else if (atomic_read(&hdmi_state) == HDMI_ON) {
+		atomic_set(&hdmi_state, HDMI_OFF);
+		if (cpu_is_mmp2() && hi->hdmi_power)
+			hi->hdmi_power(0);
+		if (early_suspend_flag == 0)
+			unset_power_constraint(hi);
+		uio_event_notify(&hi->uio_info);
+	}
+
+	return 0;
+}
+
+static void delayed_resume(struct work_struct *work)
+{
+	struct hdmi_instance *hi = container_of((struct delayed_work *)work,
+			struct hdmi_instance, delay_resumed);
+	/* send connect event to upper layer */
+	uio_event_notify(&hi->uio_info);
+}
+#endif
+
+static void delayed_disable(struct work_struct *work)
+{
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_PXA978)
+	struct hdmi_instance *hi = container_of((struct delayed_work *)work,
+			struct hdmi_instance, delay_disable);
+#endif
+	if (late_disable_flag) {
+#if defined(CONFIG_CPU_PXA978)
+		if (atomic_read(&hdmi_state) == HDMI_OFF) {
+			if (hdmi_conv_on) {
+				printk(KERN_ERR "uio_hdmi: ERROR!!! hdmi clk should be off but lcd is still on ?!!\n");
+				WARN_ON(1);
+				return;
+			}
+			update_lcd_controller_clock(0);
+		} else {
+			printk(KERN_WARNING "uio_hdmi: WARN!!! hdmi is connected but ask for clk off ?!!\n");
+		}
+#endif
+
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_PXA978)
+		clk_disable(hi->clk);
+#endif
+		late_disable_flag = 0;
+	}
+}
+
+static void hdmi_switch_work(struct work_struct *work)
+{
+	struct hdmi_instance *hi =
+		container_of(work, struct hdmi_instance, work);
+	int state = gpio_get_value(hi->gpio);
+	if(state != hi->hpd_in) {
+		if (atomic_cmpxchg(&hdmi_state, HDMI_ON, HDMI_OFF) == HDMI_ON) {
+			late_disable_flag = 1;
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+			if (cpu_is_mmp2() && hi->hdmi_power)
+				hi->hdmi_power(0);
+			if (early_suspend_flag == 0)
+				unset_power_constraint(hi);
+#elif defined(CONFIG_CPU_PXA978)
+			arbiter_clr();
+			unset_power_constraint(hi);
+#endif
+			/*if hdmi_state change, report hpd*/
+			uio_event_notify(&hi->uio_info);
+		}
+	} else {
+		if (atomic_cmpxchg(&hdmi_state, HDMI_OFF, HDMI_ON) == HDMI_OFF) {
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+			if (cpu_is_mmp2()) {
+				if (hi->hdmi_power)
+					hi->hdmi_power(1);
+				clk_enable(hi->clk);
+			}
+			if (early_suspend_flag == 0)
+				set_power_constraint(hi, HDMI_FREQ_CONSTRAINT);
+#elif defined(CONFIG_CPU_PXA978)
+			set_power_constraint(hi, HDMI_FREQ_CONSTRAINT);
+			clk_enable(hi->clk);
+			arbiter_set();
+			update_lcd_controller_clock(1);
+#endif
+			/*if hdmi_state change, report hpd*/
+			uio_event_notify(&hi->uio_info);
+		}
+	}
+	pr_debug("++++++++++++ %s state %x hdmi_state %d\n", __func__,
+		state, atomic_read(&hdmi_state));
+}
+
+/* set_power_constraint can't be called in interrupt context, use timer to
+ * workaround this issue.
+ */
+void work_launch(unsigned long data)
+{
+	struct hdmi_instance *hi = (struct hdmi_instance *)data;
+	pr_debug("%s\n", __func__);
+	schedule_work(&hi->work);
+}
+
+/* use timer to remove jitter
+ */
+static irqreturn_t hpd_handler(int irq, struct uio_info *dev_info)
+{
+	struct hdmi_instance *hi =
+		container_of(dev_info, struct hdmi_instance, uio_info);
+
+	pr_debug("%s\n", __func__);
+#ifdef CONFIG_CPU_PXA978
+	/* during suspend, need not response to any irq*/
+	if (suspend_flag) {
+		printk("uio_hdmi: ~ignore all hpd during suspend~\n");
+		return IRQ_NONE;
+	}
+#endif
+	if (timer_inited)
+		mod_timer(&hi->jitter_timer, jiffies + HZ);
+#ifdef CONFIG_CPU_PXA978
+	/*
+	*cable in -> lcd on, but if lcd on is not completed,
+	*and cable out at this momoent, lcd mixer failed happend if hdmi clk disable
+	*/
+	if (HDMI_ON == atomic_read(&hdmi_state)
+		&& (hi->hpd_in != gpio_get_value(hi->gpio))) {
+		if (0 == hdmi_conv_on) {
+			printk("uio_hdmi: delay 5s to handle cable pull out, as lcd is not turn on completed at last time cable in!!!\n");
+			mod_timer(&hi->jitter_timer, jiffies + 5*HZ);
+		}
+	}
+#endif
+	/*printk("uio_hdmi: irq HDMI cable is %s\n",
+		(hi->hpd_in == gpio_get_value(hi->gpio))?"plug in":"pull out");*/
+	/*Don't report hpd in top half, wait for jitter is gone.*/
+	return IRQ_NONE;
+}
+
+static int hdmi_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct hdmi_instance *hi;
+	int ret;
+	struct uio_hdmi_platform_data *pdata;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pdata = pdev->dev.platform_data;
+	if (res == NULL) {
+		printk(KERN_ERR "hdmi_probe: no memory resources given");
+		return -ENODEV;
+	}
+
+	hi = kzalloc(sizeof(*hi), GFP_KERNEL);
+	if (hi == NULL) {
+		printk(KERN_ERR "%s: out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	hi->clk = clk_get(NULL, "HDMICLK");
+	if (IS_ERR(hi->clk)) {
+		pr_err("%s: can't get HDMICLK\n", __func__);
+		kfree(hi);
+		return  -EIO;
+	}
+
+	hi->reg_base = ioremap(res->start, res->end - res->start + 1);
+	if (hi->reg_base == NULL) {
+		printk(KERN_ERR "%s: can't remap resgister area", __func__);
+		ret =  -ENOMEM;
+		goto out_free;
+	}
+
+	if (pdata->sspa_reg_base) {
+		hi->sspa1_reg_base = ioremap_nocache(pdata->sspa_reg_base, 0xff);
+		if (hi->sspa1_reg_base == NULL) {
+			printk(KERN_WARNING "failed to request register memory\n");
+			ret = -EBUSY;
+			goto out_free;
+		}
+	}
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+	pm_qos_add_request(&hi->qos_cpufreq_min, PM_QOS_CPUFREQ_MIN,
+			PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&hi->qos_cpufreq_disable, PM_QOS_CPUFREQ_DISABLE,
+			PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&hi->qos_idle, PM_QOS_CPU_DMA_LATENCY,
+			PM_QOS_DEFAULT_VALUE);
+#endif
+
+#if defined(CONFIG_CPU_MMP3) && defined(CONFIG_DDR_DEVFREQ)
+	pm_qos_add_request(&hi->qos_ddrfreq_min, PM_QOS_DDR_DEVFREQ_MIN,
+			PM_QOS_DEFAULT_VALUE);
+#endif
+	platform_set_drvdata(pdev, hi);
+
+	hi->uio_info.name = "uio-hdmi";
+	hi->uio_info.version = "build1";
+	hi->uio_info.irq_flags = IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING;
+	hi->uio_info.handler = hpd_handler;
+	hi->gpio = pdata->gpio;
+	hi->hpd_in = pdata->hpd_val;
+	hi->edid_bus_num = pdata->edid_bus_num;
+	if (hi->edid_bus_num == 0)
+		hi->edid_bus_num = 6;
+
+	ret = gpio_request(pdata->gpio, pdev->name);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed in gpio_request\n", __func__);
+		goto out_free;
+	}
+	ret = gpio_direction_input(pdata->gpio);
+	if (ret < 0) {
+		printk(KERN_ERR "%s: failed in gpio_direction_input\n", __func__);
+		goto out_free;
+	}
+	hi->uio_info.irq = gpio_to_irq(pdata->gpio);
+	if (hi->uio_info.irq < 0) {
+		printk(KERN_ERR "%s: failed in gpio_to_irq\n", __func__);
+		ret = hi->uio_info.irq;
+		goto out_free;
+	}
+
+	hi->uio_info.mem[0].internal_addr = hi->reg_base;
+	hi->uio_info.mem[0].addr = res->start;
+	hi->uio_info.mem[0].memtype = UIO_MEM_PHYS;
+	hi->uio_info.mem[0].size = res->end - res->start + 1;
+	hi->uio_info.mem[0].name = "hdmi-iomap";
+	hi->uio_info.priv = hi;
+
+	if (pdata->itlc_reg_base) {
+		hi->uio_info.mem[1].internal_addr =
+			ioremap_nocache(pdata->itlc_reg_base, 0xff);
+		hi->uio_info.mem[1].addr = pdata->itlc_reg_base;
+		hi->uio_info.mem[1].memtype = UIO_MEM_PHYS;
+		hi->uio_info.mem[1].size = 0xff;
+	}
+
+	hi->uio_info.open = hdmi_open;
+	hi->uio_info.release = hdmi_release;
+	hi->uio_info.ioctl = hdmi_ioctl;
+	if (pdata->hdmi_v5p_power)
+		hi->hdmi_power = pdata->hdmi_v5p_power;
+
+#if defined(CONFIG_CPU_PXA978)
+	dvfm_register("uio-hdmi", &dvfm_dev_idx);
+	arbiter_init();
+	/* nevo need 5v to detect hpd*/
+	if (hi->hdmi_power)
+		hi->hdmi_power(1);
+#endif
+
+#if	defined(CONFIG_CPU_MMP3)
+	/* mmp3 need 5v to detect hpd*/
+	if (hi->hdmi_power)
+		hi->hdmi_power(1);
+	/* mmp3 always enable clk*/
+	clk_enable(hi->clk);
+#endif
+	/* Check HDMI cable when boot up */
+	ret = gpio_get_value(hi->gpio);
+	printk(KERN_INFO"%s hpd %s\n",
+		__func__, (ret == hi->hpd_in)?"plug in":"pull out");
+
+	if (ret == hi->hpd_in) {
+		atomic_set(&hdmi_state, HDMI_ON);
+		set_power_constraint(hi, HDMI_FREQ_CONSTRAINT);
+#if defined(CONFIG_CPU_MMP2)
+		if (hi->hdmi_power)
+			hi->hdmi_power(1);
+		clk_enable(hi->clk);
+#endif
+
+#if defined(CONFIG_CPU_PXA978)
+		arbiter_set();
+		clk_enable(hi->clk);
+		update_lcd_controller_clock(1);
+#endif
+	}
+
+	ret = uio_register_device(&pdev->dev, &hi->uio_info);
+	if (ret) {
+		printk(KERN_ERR"%s: register device fails !!!\n", __func__);
+		goto out_free;
+	}
+
+	/* avoid cable hot plug/pull out jitter within 1s*/
+	setup_timer(&hi->jitter_timer, work_launch, (unsigned long)hi);
+	INIT_WORK(&hi->work, hdmi_switch_work);
+	timer_inited = 1;
+
+	/* silicon issue on MMP: delayed 300ms to disable clk when cable pull out*/
+	INIT_DELAYED_WORK(&hi->delay_disable, delayed_disable);
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+	/* during resume: simulate cable pull out->wait 1.5s->plug in*/
+	INIT_DELAYED_WORK(&hi->delay_resumed, delayed_resume);
+#endif
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+	hi->early_suspend.suspend = hdmi_early_suspend_mmp;
+	hi->early_suspend.resume = hdmi_late_resume_mmp;
+#elif defined(CONFIG_CPU_PXA978)
+	hi->early_suspend.suspend = hdmi_early_suspend_nevo;
+	hi->early_suspend.resume = hdmi_late_resume_nevo;
+#endif
+	hi->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
+	register_early_suspend(&hi->early_suspend);
+#endif
+	platform_set_drvdata(pdev, hi);
+	return 0;
+
+out_free:
+	clk_disable(hi->clk);
+	clk_put(hi->clk);
+#if defined(CONFIG_CPU_PXA978) || defined(CONFIG_CPU_MMP3)
+	if (hi->hdmi_power)
+		hi->hdmi_power(0);
+#elif defined(CONFIG_CPU_MMP2)
+	if (atomic_read(&hdmi_state) == HDMI_ON && (hi->hdmi_power))
+		hi->hdmi_power(0);
+#endif
+	kfree(hi);
+	return ret;
+}
+
+static struct platform_driver hdmi_driver = {
+	.probe	= hdmi_probe,
+	.remove	= hdmi_remove,
+	.driver = {
+		.name	= "uio-hdmi",
+		.owner	= THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+#if defined(CONFIG_CPU_PXA978)
+	.suspend = hdmi_suspend_nevo,
+	.resume  = hdmi_resume_nevo,
+#elif defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+	.suspend = hdmi_suspend_mmp,
+	.resume  = hdmi_resume_mmp,
+#endif
+#endif
+};
+
+static void __init hdmi_exit(void)
+{
+	platform_driver_unregister(&hdmi_driver);
+}
+
+static int __init hdmi_init(void)
+{
+	return platform_driver_register(&hdmi_driver);
+}
+
+late_initcall(hdmi_init);
+module_exit(hdmi_exit);
+
+MODULE_DESCRIPTION("UIO driver for Marvell hdmi");
+MODULE_LICENSE("GPL");
diff --git a/drivers/uio/uio_vmeta.c b/drivers/uio/uio_vmeta.c
new file mode 100644
index 0000000..4624009
--- /dev/null
+++ b/drivers/uio/uio_vmeta.c
@@ -0,0 +1,811 @@
+/*
+ * drivers/uio/uio_vmeta.c
+ *
+ * Marvell multi-format video decoder engine UIO driver.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * Based on an earlier version by Peter Liao.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+
+#include <mach/hardware.h>
+#include <mach/soc_vmeta.h>
+#ifdef CONFIG_DVFM
+#include <mach/dvfm.h>
+#endif
+
+#define CONFIG_MEM_FOR_MULTIPROCESS
+#define VDEC_HW_CONTEXT_SIZE	SZ_1M
+#define VDEC_OBJ_SIZE			SZ_64K
+#define KERNEL_SHARE_SIZE		SZ_4K
+
+/* public */
+#define UIO_VMETA_VERSION	"build-006"
+
+#define VMETA_DEBUG 0
+
+#if VMETA_DEBUG
+#define vmeta_print printk
+#else
+#define vmeta_print(x, ...)
+#endif
+
+/*In case we need to export some infomation for other components like GC*/
+static struct vmeta_instance *vmeta_inst;
+
+static void vmeta_lock_init(struct vmeta_instance *vi)
+{
+	sema_init(vi->sema, 1);
+	sema_init(vi->priv_sema, 1);
+}
+
+static int vmeta_lock(unsigned long ms, struct vmeta_instance *vi)
+{
+	int ret;
+
+	ret = down_timeout(vi->sema, msecs_to_jiffies(ms));
+
+	return ret;
+}
+
+static int vmeta_unlock(struct vmeta_instance *vi)
+{
+	if (vi->sema->count == 0) {
+		up(vi->sema);
+		return 0;
+	} else if (vi->sema->count == 1) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+static int vmeta_priv_lock(unsigned long ms, struct vmeta_instance *vi)
+{
+	int ret;
+
+	ret = down_timeout(vi->priv_sema, msecs_to_jiffies(ms));
+
+	return ret;
+}
+
+static int vmeta_priv_unlock(struct vmeta_instance *vi)
+{
+	if (vi->priv_sema->count == 0) {
+		up(vi->priv_sema);
+		return 0;
+	} else if (vi->priv_sema->count == 1) {
+		return 0;
+	} else {
+		return -1;
+	}
+}
+
+int vmeta_power_status(void)
+{
+	if (vmeta_inst)
+		return vmeta_inst->power_status;
+
+	return -1;
+}
+EXPORT_SYMBOL(vmeta_power_status);
+
+static int vmeta_power_on(struct vmeta_instance *vi)
+{
+	mutex_lock(&vi->mutex);
+	if (vi->power_status == 1) {
+		mutex_unlock(&vi->mutex);
+		return 0;
+	}
+
+	vmeta_power_switch(VMETA_PWR_ENABLE);
+	vi->power_status = 1;
+
+	mutex_unlock(&vi->mutex);
+	return 0;
+}
+
+static int vmeta_clk_on(struct vmeta_instance *vi)
+{
+	int ret;
+
+	mutex_lock(&vi->mutex);
+	if (vi->clk_status != 0) {
+		mutex_unlock(&vi->mutex);
+		return 0;
+	}
+
+	ret = vmeta_runtime_constraint(vi, 1);
+	if (ret)
+		printk(KERN_ERR "vmeta op disable error with %d\n", ret);
+
+	if (NULL != vi->axi_clk)
+		clk_enable(vi->axi_clk);
+
+	if (NULL != vi->clk)
+		clk_enable(vi->clk);
+
+	vi->clk_status = 1;
+	mutex_unlock(&vi->mutex);
+
+	return 0;
+}
+
+/*
+vco bitmap
+31~24           23~16     15~8        0~7
+reserved        vop       step        flags
+vop: vmeta op table defined in kernel space
+step:  delta vop level;
+flags:  0-set vop for vmeta; 1-increase/decrease vop by the value in step;
+		2-max vop; 3-min vop
+e.g.
+a) set vmeta as OP3 vco = 0x00030000
+b) set vmeta higher vop by 1 step vco = 0x00000101
+
+VOP Definition, see detail uio_vmeta.h
+resolution <= VGA          -- VOP=[1~7]
+VGA < resolution <=720p    -- VOP=[8~13]
+resolution > 720p          -- VOP=[14]
+VOP 0/15 are reserved to notify upper layer.
+*/
+static int vmeta_clk_switch(struct vmeta_instance *vi, unsigned long clk_flag)
+{
+	int ret = -1;
+	int flags;
+	int vop = -1;
+
+	mutex_lock(&vi->mutex);
+	vmeta_print(KERN_INFO "[vmeta] clk switch 0x%lx\n", clk_flag);
+	flags = clk_flag & 0xff;
+	if (flags == 0) {
+		vop = (clk_flag & (0xff << 16)) >> 16;
+		vmeta_print(KERN_INFO"[vmeta] set vop as %d\n", vop);
+	} else if (flags == 1) {
+		signed char step;
+		step = (signed char)((clk_flag & (0xff << 8)) >> 8);
+		vmeta_print(KERN_INFO"[vmeta] +/- step= %d\n", step);
+		ret = vmeta_freq_change(vi, step);
+		if (ret < 0) {
+			mutex_unlock(&vi->mutex);
+			return ret;
+		}
+
+		vop = ret;
+		vmeta_print(KERN_INFO "[vmeta] set vop as %d\n", vop);
+	} else if (flags == 2) {
+		vop = VMETA_OP_1080P_MAX;
+		vmeta_print(KERN_INFO "[vmeta] set vop as %d\n", vop);
+	} else if (flags == 3) {
+		vop = VMETA_OP_VGA;
+		vmeta_print(KERN_INFO "[vmeta] set vop as %d\n", vop);
+	}
+
+	if (vi->vop != vop && vop >= VMETA_OP_MIN && vop <= VMETA_OP_MAX) {
+		vi->vop = vop;
+		printk(KERN_INFO"set vop to %d\n", vi->vop);
+	}
+
+	ret = vi->vop;
+	mutex_unlock(&vi->mutex);
+	return ret;
+}
+
+static int vmeta_turn_on(struct vmeta_instance *vi)
+{
+	int ret;
+
+	ret = vmeta_power_on(vi);
+	if (ret)
+		return -1;
+
+	ret = vmeta_clk_on(vi);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+static int vmeta_power_off(struct vmeta_instance *vi)
+{
+	mutex_lock(&vi->mutex);
+	if (vi->power_status == 0) {
+		mutex_unlock(&vi->mutex);
+		return 0;
+	}
+
+	vmeta_power_switch(VMETA_PWR_DISABLE);
+	vi->power_status = 0;
+	vi->vop_real = VMETA_OP_INVALID;
+	mutex_unlock(&vi->mutex);
+	return 0;
+}
+
+static int vmeta_clk_off(struct vmeta_instance *vi)
+{
+	int ret;
+
+	mutex_lock(&vi->mutex);
+	if (vi->clk_status == 0) {
+		mutex_unlock(&vi->mutex);
+		return 0;
+	}
+
+	if (NULL != vi->clk)
+		clk_disable(vi->clk);
+
+	if (NULL != vi->axi_clk)
+		clk_disable(vi->axi_clk);
+
+	ret = vmeta_runtime_constraint(vi, 0);
+	if (ret)
+		printk(KERN_ERR "vmeta unset_op_constraint error with %d\n", ret);
+	vi->clk_status = 0;
+	mutex_unlock(&vi->mutex);
+
+	return 0;
+}
+
+static int vmeta_turn_off(struct vmeta_instance *vi)
+{
+	int ret;
+
+	ret = vmeta_clk_off(vi);
+	if (ret)
+		return -1;
+
+	ret = vmeta_power_off(vi);
+	if (ret)
+		return -1;
+
+	return 0;
+}
+
+static int vmeta_open(struct uio_info *info, struct inode *inode,
+		      void *file_priv)
+{
+	struct vmeta_instance *vi;
+	struct uio_listener *priv = file_priv;
+	int *p, i;
+
+	priv->extend = kmalloc(sizeof(int) * MAX_VMETA_INSTANCE, GFP_KERNEL);
+	if (!priv->extend) {
+		printk(KERN_ERR "vmeta open error\n");
+		return -1;
+	}
+
+	p = (int *)priv->extend;
+
+	for (i = 0; i < MAX_VMETA_INSTANCE; i++)
+		p[i] = MAX_VMETA_INSTANCE;
+
+	vi = (struct vmeta_instance *)info->priv;
+	vmeta_turn_on(vi);
+
+	return 0;
+}
+
+static int vmeta_release(struct uio_info *info, struct inode *inode,
+			 void *file_priv)
+{
+	struct vmeta_instance *vi;
+	kernel_share *ks;
+	int current_id = 0;
+	struct uio_listener *priv = file_priv;
+	int *p, i;
+
+	vi = (struct vmeta_instance *)info->priv;
+	ks = (kernel_share *) vi->uio_info.mem[3].internal_addr;
+
+	if (!priv)
+		return -1;
+	p = (int *)priv->extend;
+
+	for (i = 0; i < MAX_VMETA_INSTANCE; i++) {
+		if (p[i] >= 0 && p[i] < MAX_VMETA_INSTANCE) {
+			/*if we go here, there is something abnormal */
+			current_id = p[i];
+			printk(KERN_INFO
+			       "vmeta release current tgid(%d) pid(%d), id to be closed=%d, active id=%d\n",
+			       current->tgid, current->pid, current_id,
+			       ks->active_user_id);
+
+			mutex_lock(&vi->mutex);
+			/*in case, current instance have been locked*/
+			if (ks->active_user_id == current_id) {
+				ks->active_user_id = MAX_VMETA_INSTANCE;
+				if (ks->lock_flag == VMETA_LOCK_ON) {
+					printk(KERN_ERR
+					       "vmeta error , instance id(%d) holds the lock and exit abnormally\n",
+					       current_id);
+					ks->lock_flag = VMETA_LOCK_FORCE_INIT;
+					vmeta_unlock(vi);
+				}
+			}
+			/*in case, it's an abnormal exit,
+			we should clear the instance*/
+			if (ks->user_id_list[current_id].status != 0) {
+				printk(KERN_ERR
+				       "vmeta error, clear instance[%d],previous status=0x%x\n",
+				       current_id,
+				       ks->user_id_list[current_id].status);
+				ks->ref_count--;
+				memset(&(ks->user_id_list[current_id]), 0x0,
+				       sizeof(id_instance));
+				printk(KERN_ERR
+				       "ref_count=%d, lock flag=%d,active_user_id=%d\n",
+				       ks->ref_count, ks->lock_flag,
+				       current_id);
+			}
+
+			mutex_unlock(&vi->mutex);
+			p[i] = MAX_VMETA_INSTANCE;
+		}
+	}
+
+	mutex_lock(&vi->mutex);
+	if (ks->ref_count == 0) {
+		mutex_unlock(&vi->mutex);
+		vmeta_turn_off(vi);
+		mutex_lock(&vi->mutex);
+		vi->vop = VMETA_OP_INVALID;
+		vi->vop_real = VMETA_OP_INVALID;
+	}
+	mutex_unlock(&vi->mutex);
+	kfree(priv->extend);
+
+	return 0;
+}
+
+/* Either register and unregister use the same function */
+static int vmeta_reg_unreg(struct uio_listener *file_priv, int uid)
+{
+	int *p = (int *)file_priv->extend;
+	int i;
+
+	if (!p) {
+		printk(KERN_ERR "vmeta register error, point NULL\n");
+		return -1;
+	}
+
+	for (i = 0; i < MAX_VMETA_INSTANCE; i++) {
+		if (p[i] == uid) {
+			p[i] = MAX_VMETA_INSTANCE;
+			printk(KERN_DEBUG "vmeta kern unregister p[%d]= %d\n",
+			       i, uid);
+			return 0;
+		}
+	}
+
+	for (i = 0; i < MAX_VMETA_INSTANCE; i++) {
+		if (p[i] < 0 || p[i] >= MAX_VMETA_INSTANCE)
+			break;
+	}
+
+	if (i >= MAX_VMETA_INSTANCE) {
+		printk(KERN_ERR "vmeta kern register full\n");
+		return -1;
+	}
+
+	p[i] = uid;
+	printk(KERN_DEBUG "vmeta kern register p[%d]= %d\n", i, p[i]);
+	return 0;
+}
+
+static void __attribute__ ((unused))
+vmeta_irq_poll_timer_handler(unsigned long data)
+{
+	struct vmeta_instance *vi = (struct vmeta_instance *)data;
+
+	uio_event_notify(&vi->uio_info);
+	mod_timer(&vi->irq_poll_timer, jiffies + HZ / 100);	/*10ms timer */
+}
+
+static irqreturn_t vmeta_func_irq_handler(int irq, struct uio_info *dev_info)
+{
+	struct vmeta_instance *priv = dev_info->priv;
+	unsigned long flags;
+
+	/* Just disable the interrupt in the interrupt controller, and
+	 * remember the state so we can allow user space to enable it later.
+	 */
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (!test_and_set_bit(0, &priv->flags))
+		disable_irq_nosync(irq);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int vmeta_irqcontrol(struct uio_info *dev_info, s32 irq_on)
+{
+	struct vmeta_instance *priv = dev_info->priv;
+	unsigned long flags;
+
+	/* Allow user space to enable and disable the interrupt
+	 * in the interrupt controller, but keep track of the
+	 * state to prevent per-irq depth damage.
+	 *
+	 * Serialize this operation to support multiple tasks.
+	 */
+
+	spin_lock_irqsave(&priv->lock, flags);
+	if (irq_on) {
+		if (test_and_clear_bit(0, &priv->flags))
+			enable_irq(dev_info->irq);
+	} else {
+		if (!test_and_set_bit(0, &priv->flags))
+			disable_irq(dev_info->irq);
+	}
+	spin_unlock_irqrestore(&priv->lock, flags);
+
+	return 0;
+}
+
+static int vmeta_ioctl(struct uio_info *info, unsigned int cmd,
+		       unsigned long arg, void *file_priv)
+{
+	int ret = 0;
+	struct vmeta_instance *priv = info->priv;
+
+	switch (cmd) {
+	case VMETA_CMD_POWER_ON:
+		ret = vmeta_power_on(priv);
+		break;
+	case VMETA_CMD_POWER_OFF:
+		ret = vmeta_power_off(priv);
+		break;
+	case VMETA_CMD_CLK_ON:
+		ret = vmeta_clk_on(priv);
+		break;
+	case VMETA_CMD_CLK_OFF:
+		ret = vmeta_clk_off(priv);
+		break;
+	case VMETA_CMD_CLK_SWITCH:
+		ret = vmeta_clk_switch(priv, arg);
+		break;
+	case VMETA_CMD_LOCK:
+		ret = vmeta_lock(arg, priv);
+		break;
+	case VMETA_CMD_UNLOCK:
+		ret = vmeta_unlock(priv);
+		break;
+	case VMETA_CMD_PRIV_LOCK:
+		ret = vmeta_priv_lock(arg, priv);
+		break;
+	case VMETA_CMD_PRIV_UNLOCK:
+		ret = vmeta_priv_unlock(priv);
+		break;
+	case VMETA_CMD_REG_UNREG:
+		ret =
+		    vmeta_reg_unreg((struct uio_listener *)file_priv, (int)arg);
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int vmeta_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct vmeta_instance *vi;
+	int ret = 0;
+	int irq_func, irq_bus;
+#ifdef CONFIG_MEM_FOR_MULTIPROCESS
+	kernel_share *p_ks;
+	dma_addr_t mem_dma_addr;
+	void *mem_vir_addr;
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resources given\n");
+		return -ENODEV;
+	}
+#ifndef CONFIG_VMETA_POLLING_MODE
+	irq_func = platform_get_irq(pdev, 0);
+	if (irq_func < 0) {
+		dev_err(&pdev->dev, "missing irq resource in interrupt mode\n");
+		return -ENODEV;
+	}
+#endif
+
+	vi = kzalloc(sizeof(*vi), GFP_KERNEL);
+	if (!vi) {
+		dev_err(&pdev->dev, "vmeta_instance: out of memory\n");
+		return -ENOMEM;
+	}
+
+	vi->plat_data = (struct vmeta_plat_data *)pdev->dev.platform_data;
+	if (!vi->plat_data) {
+		dev_err(&pdev->dev, "missing platform data\n");
+		goto err_pdata;
+	}
+	vi->sema = kzalloc(sizeof(struct semaphore), GFP_KERNEL);
+	if (!vi->sema) {
+		dev_err(&pdev->dev, "vmeta->sema: out of memory\n");
+		ret = -ENOMEM;
+		goto err_sema;
+	}
+	vi->priv_sema = kzalloc(sizeof(struct semaphore), GFP_KERNEL);
+	if (!vi->priv_sema) {
+		dev_err(&pdev->dev, "vmeta->priv_ema: out of memory\n");
+		ret = -ENOMEM;
+		goto err_priv_sema;
+	}
+
+	vi->clk = clk_get(&pdev->dev, "VMETA_CLK");
+	if (IS_ERR(vi->clk)) {
+		dev_err(&pdev->dev, "cannot get vmeta clock\n");
+		ret = PTR_ERR(vi->clk);
+		goto err_clk;
+	}
+
+	if (vi->plat_data->axi_clk_available) {
+		vi->axi_clk = clk_get(&pdev->dev, "AXICLK");
+		if (IS_ERR(vi->axi_clk)) {
+			printk(KERN_ERR "vmeta_probe: cannot get AXI clock\n");
+			ret = PTR_ERR(vi->axi_clk);
+			goto err_axi_clk;
+		}
+	}
+
+	vi->reg_base = (void *)ioremap(res->start, res->end - res->start + 1);
+	if (!vi->reg_base) {
+		dev_err(&pdev->dev, "can't remap register area\n");
+		ret = -ENOMEM;
+		goto err_reg_base;
+	}
+
+	platform_set_drvdata(pdev, vi);
+
+	spin_lock_init(&vi->lock);
+	vi->flags = 0;		/* interrupt is enabled to begin with */
+
+	vi->uio_info.name = UIO_VMETA_NAME;
+	vi->uio_info.version = UIO_VMETA_VERSION;
+	vi->uio_info.mem[0].internal_addr = (void __iomem *)vi->reg_base;
+	vi->uio_info.mem[0].addr = res->start;
+	vi->uio_info.mem[0].memtype = UIO_MEM_PHYS;
+	vi->uio_info.mem[0].size = res->end - res->start + 1;
+#ifdef CONFIG_MEM_FOR_MULTIPROCESS
+	mem_vir_addr = dma_alloc_coherent(&pdev->dev, VDEC_HW_CONTEXT_SIZE,
+					  &mem_dma_addr, GFP_KERNEL);
+	if (!mem_vir_addr) {
+		ret = -ENOMEM;
+		goto err_uio_mem_1;
+	}
+	vi->uio_info.mem[1].internal_addr = (void __iomem *)mem_vir_addr;
+	vi->uio_info.mem[1].addr = mem_dma_addr;
+	vi->uio_info.mem[1].memtype = UIO_MEM_PHYS;
+	vi->uio_info.mem[1].size = VDEC_HW_CONTEXT_SIZE;
+	vmeta_print("[1] internal addr[0x%08x],addr[0x%08x] size[%ld]\n",
+		    (unsigned int)vi->uio_info.mem[1].internal_addr,
+		    (unsigned int)vi->uio_info.mem[1].addr,
+		    vi->uio_info.mem[1].size);
+
+	/*this memory is allocated for VDEC_OBJ */
+	mem_vir_addr =
+	    dma_alloc_coherent(&pdev->dev, VDEC_OBJ_SIZE, &mem_dma_addr,
+			       GFP_KERNEL);
+	if (!mem_vir_addr) {
+		ret = -ENOMEM;
+		goto err_uio_mem_2;
+	}
+
+	vi->uio_info.mem[2].internal_addr = (void __iomem *)mem_vir_addr;
+	vi->uio_info.mem[2].addr = (unsigned long)mem_dma_addr;
+	vi->uio_info.mem[2].memtype = UIO_MEM_PHYS;
+	vi->uio_info.mem[2].size = VDEC_OBJ_SIZE;
+	vmeta_print("[2] internal addr[0x%08x],addr[0x%08x] size[%ld]\n",
+		    (unsigned int)vi->uio_info.mem[2].internal_addr,
+		    (unsigned int)vi->uio_info.mem[2].addr,
+		    vi->uio_info.mem[2].size);
+
+	/*this memory is allocated for vmeta driver internally and
+	shared between user space and kernel space */
+	mem_vir_addr =
+	    dma_alloc_coherent(&pdev->dev, KERNEL_SHARE_SIZE, &mem_dma_addr,
+			       GFP_KERNEL);
+	if (!mem_vir_addr) {
+		ret = -ENOMEM;
+		goto err_uio_mem_3;
+	}
+	memset(mem_vir_addr, 0, KERNEL_SHARE_SIZE);
+	vi->uio_info.mem[3].internal_addr = (void __iomem *)mem_vir_addr;
+	vi->uio_info.mem[3].addr = (unsigned long)mem_dma_addr;
+	vi->uio_info.mem[3].memtype = UIO_MEM_PHYS;
+	vi->uio_info.mem[3].size = KERNEL_SHARE_SIZE;
+	vmeta_print("[3] internal addr[0x%08x],addr[0x%08x] size[%ld]\n",
+		    (unsigned int)vi->uio_info.mem[3].internal_addr,
+		    (unsigned int)vi->uio_info.mem[3].addr,
+		    vi->uio_info.mem[3].size);
+
+	p_ks = (kernel_share *) mem_vir_addr;
+	p_ks->active_user_id = MAX_VMETA_INSTANCE;
+
+#endif
+
+#ifdef CONFIG_VMETA_POLLING_MODE
+	vi->uio_info.irq = UIO_IRQ_CUSTOM;
+	init_timer(&vi->irq_poll_timer);
+	vi->irq_poll_timer.data = (unsigned long)vi;
+	vi->irq_poll_timer.function = vmeta_irq_poll_timer_handler;
+#else
+	vi->uio_info.irq_flags = IRQF_ONESHOT;
+	vi->uio_info.irq = irq_func;
+	vi->uio_info.handler = vmeta_func_irq_handler;
+	vi->uio_info.irqcontrol = vmeta_irqcontrol;
+#endif
+	vi->uio_info.priv = vi;
+
+	vi->uio_info.open = vmeta_open;
+	vi->uio_info.release = vmeta_release;
+	vi->uio_info.ioctl = vmeta_ioctl;
+	vi->uio_info.mmap = NULL;
+
+	mutex_init(&(vi->mutex));
+	vmeta_lock_init(vi);
+
+	vi->vop = VMETA_OP_INVALID;
+	vi->vop_real = VMETA_OP_INVALID;
+	ret = uio_register_device(&pdev->dev, &vi->uio_info);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register uio device\n");
+		goto err_uio_register;
+	}
+
+#ifdef CONFIG_VMETA_POLLING_MODE
+	mod_timer(&vi->irq_poll_timer, jiffies + HZ / 100);
+#endif
+
+	irq_bus = platform_get_irq(pdev, 1);
+	if (irq_bus < 0) {
+		dev_dbg(&pdev->dev, "no bus irq resources given\n");
+	} else {
+		if (vi->plat_data->bus_irq_handler) {
+			ret =
+			    request_irq(irq_bus, vi->plat_data->bus_irq_handler,
+					0, UIO_VMETA_BUS_IRQ_NAME, vi);
+			if (ret) {
+				dev_err(&pdev->dev, "can't request bus irq\n");
+				goto err_request_bus_irq;
+			}
+		}
+	}
+
+	vmeta_init_constraint(vi);
+	vmeta_inst = vi;
+	return 0;
+
+err_request_bus_irq:
+#ifdef CONFIG_VMETA_POLLING_MODE
+	del_timer_sync(&vi->irq_poll_timer);
+#endif
+	uio_unregister_device(&vi->uio_info);
+err_uio_register:
+#ifdef CONFIG_MEM_FOR_MULTIPROCESS
+	dma_free_coherent(&pdev->dev, KERNEL_SHARE_SIZE,
+			(void *)vi->uio_info.mem[3].internal_addr,
+			vi->uio_info.mem[3].addr);
+err_uio_mem_3:
+	dma_free_coherent(&pdev->dev, VDEC_OBJ_SIZE,
+			(void *)vi->uio_info.mem[2].internal_addr,
+			vi->uio_info.mem[2].addr);
+err_uio_mem_2:
+	dma_free_coherent(&pdev->dev, VDEC_HW_CONTEXT_SIZE,
+			(void *)vi->uio_info.mem[1].internal_addr,
+			vi->uio_info.mem[1].addr);
+err_uio_mem_1:
+#endif
+	iounmap(vi->uio_info.mem[0].internal_addr);
+err_reg_base:
+	if (vi->plat_data->axi_clk_available)
+		clk_put(vi->axi_clk);
+err_axi_clk:
+	clk_put(vi->clk);
+err_clk:
+	kfree(vi->priv_sema);
+err_priv_sema:
+	kfree(vi->sema);
+err_sema:
+err_pdata:
+	kfree(vi);
+
+	return ret;
+}
+
+static int vmeta_remove(struct platform_device *pdev)
+{
+	struct vmeta_instance *vi = platform_get_drvdata(pdev);
+
+#ifdef CONFIG_VMETA_POLLING_MODE
+	del_timer_sync(&vi->irq_poll_timer);
+#endif
+	vmeta_clean_constraint(vi);
+
+	uio_unregister_device(&vi->uio_info);
+#ifdef CONFIG_MEM_FOR_MULTIPROCESS
+	dma_free_coherent(&pdev->dev, KERNEL_SHARE_SIZE,
+			(void *)vi->uio_info.mem[3].internal_addr,
+			vi->uio_info.mem[3].addr);
+	dma_free_coherent(&pdev->dev, VDEC_OBJ_SIZE,
+			(void *)vi->uio_info.mem[2].internal_addr,
+			vi->uio_info.mem[2].addr);
+	dma_free_coherent(&pdev->dev, VDEC_HW_CONTEXT_SIZE,
+			(void *)vi->uio_info.mem[1].internal_addr,
+			vi->uio_info.mem[1].addr);
+#endif
+	iounmap(vi->uio_info.mem[0].internal_addr);
+
+	if (vi->plat_data->axi_clk_available)
+		clk_put(vi->axi_clk);
+	clk_put(vi->clk);
+
+	kfree(vi->sema);
+	kfree(vi->priv_sema);
+	kfree(vi);
+
+	return 0;
+}
+
+static void vmeta_shutdown(struct platform_device *dev)
+{
+}
+
+#ifdef CONFIG_PM
+static int vmeta_suspend(struct platform_device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int vmeta_resume(struct platform_device *dev)
+{
+	return 0;
+}
+#endif
+
+static struct platform_driver vmeta_driver = {
+	.probe = vmeta_probe,
+	.remove = vmeta_remove,
+	.shutdown = vmeta_shutdown,
+#ifdef CONFIG_PM
+	.suspend = vmeta_suspend,
+	.resume = vmeta_resume,
+#endif
+	.driver = {
+		.name = UIO_VMETA_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init vmeta_init(void)
+{
+	return platform_driver_register(&vmeta_driver);
+}
+
+static void __exit vmeta_exit(void)
+{
+	platform_driver_unregister(&vmeta_driver);
+}
+
+module_init(vmeta_init);
+module_exit(vmeta_exit);
+
+MODULE_DESCRIPTION("UIO driver for Marvell multi-format video codec engine");
+MODULE_LICENSE("GPL");
diff --git a/drivers/uio/uio_vmeta.h b/drivers/uio/uio_vmeta.h
new file mode 100644
index 0000000..e55fb70
--- /dev/null
+++ b/drivers/uio/uio_vmeta.h
@@ -0,0 +1,58 @@
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2010 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __UIO_VMETA_H
+#define __UIO_VMETA_H
+
+typedef unsigned int vmeta_instance_status;
+
+typedef struct _id_instance {
+	vmeta_instance_status status;
+	vmeta_user_info info;
+	int frame_rate;
+	pid_t pid;
+	unsigned int pt;	/*pthread_t*/
+} id_instance;
+
+#define MAX_VMETA_INSTANCE 32
+
+typedef enum _VMETA_LOCK_FLAG {
+	VMETA_LOCK_OFF = 0,
+	VMETA_LOCK_ON,
+	VMETA_LOCK_FORCE_INIT
+} VMETA_LOCK_FLAG;
+
+/* This struct should be aligned with user space API */
+typedef struct _kernel_share {
+	int ref_count;
+	VMETA_LOCK_FLAG lock_flag;
+	int active_user_id;
+	struct timeval lock_start_tv;
+	id_instance user_id_list[MAX_VMETA_INSTANCE];
+} kernel_share;
+
+#define IOP_MAGIC	'v'
+
+#define VMETA_CMD_POWER_ON		_IO(IOP_MAGIC, 0)
+#define VMETA_CMD_POWER_OFF		_IO(IOP_MAGIC, 1)
+#define VMETA_CMD_CLK_ON		_IO(IOP_MAGIC, 2)
+#define VMETA_CMD_CLK_OFF		_IO(IOP_MAGIC, 3)
+#define VMETA_CMD_CLK_SWITCH		_IO(IOP_MAGIC, 4)
+#define VMETA_CMD_LOCK			_IO(IOP_MAGIC, 5)
+#define VMETA_CMD_UNLOCK		_IO(IOP_MAGIC, 6)
+#define VMETA_CMD_PRIV_LOCK		_IO(IOP_MAGIC, 7)
+#define VMETA_CMD_PRIV_UNLOCK		_IO(IOP_MAGIC, 8)
+#define VMETA_CMD_REG_UNREG		_IO(IOP_MAGIC, 9)
+
+/*
+This API is exposed in kernel space to inform other componets, like GC
+return: -1 failure; 0 power off; 1 power on
+*/
+int vmeta_power_status(void);
+
+#endif /* __UIO_VMETA_H */
diff --git a/include/linux/uio_coda7542.h b/include/linux/uio_coda7542.h
new file mode 100644
index 0000000..a2785fa
--- /dev/null
+++ b/include/linux/uio_coda7542.h
@@ -0,0 +1,24 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * (C) Copyright 2012 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef _UIO_CODA7542_H_
+#define _UIO_CODA7542_H_
+
+#define CODA7542_IOC_MAGIC 'C'
+#define CODA7542_POWER_ON	_IO(CODA7542_IOC_MAGIC, 1)
+#define CODA7542_POWER_OFF	_IO(CODA7542_IOC_MAGIC, 2)
+#define CODA7542_CLK_ON		_IO(CODA7542_IOC_MAGIC, 3)
+#define CODA7542_CLK_OFF	_IO(CODA7542_IOC_MAGIC, 4)
+#define CODA7542_LOCK		_IOW(CODA7542_IOC_MAGIC, 5, unsigned int)
+#define CODA7542_UNLOCK		_IO(CODA7542_IOC_MAGIC, 6)
+#define CODA7542_GETSET_INFO	_IOW(CODA7542_IOC_MAGIC, 7, unsigned int)
+
+extern void coda7542_power_switch(int on);
+
+#endif /* _UIO_CODA7542_H_ */
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 1ad4724..b33b6b0 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -64,6 +64,11 @@ struct uio_port {
 #define MAX_UIO_PORT_REGIONS	5
 
 struct uio_device;
+struct uio_listener {
+	struct uio_device *dev;
+	s32 event_count;
+	void *extend;
+};
 
 /**
  * struct uio_info - UIO device capabilities
@@ -95,6 +100,7 @@ struct uio_info {
 	int (*open)(struct uio_info *info, struct inode *inode);
 	int (*release)(struct uio_info *info, struct inode *inode);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	int (*ioctl)(struct uio_info *info, unsigned int cmd, unsigned long arg);
 };
 
 extern int __must_check
diff --git a/include/linux/uio_vmeta.h b/include/linux/uio_vmeta.h
new file mode 100644
index 0000000..e55fb70
--- /dev/null
+++ b/include/linux/uio_vmeta.h
@@ -0,0 +1,58 @@
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2010 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __UIO_VMETA_H
+#define __UIO_VMETA_H
+
+typedef unsigned int vmeta_instance_status;
+
+typedef struct _id_instance {
+	vmeta_instance_status status;
+	vmeta_user_info info;
+	int frame_rate;
+	pid_t pid;
+	unsigned int pt;	/*pthread_t*/
+} id_instance;
+
+#define MAX_VMETA_INSTANCE 32
+
+typedef enum _VMETA_LOCK_FLAG {
+	VMETA_LOCK_OFF = 0,
+	VMETA_LOCK_ON,
+	VMETA_LOCK_FORCE_INIT
+} VMETA_LOCK_FLAG;
+
+/* This struct should be aligned with user space API */
+typedef struct _kernel_share {
+	int ref_count;
+	VMETA_LOCK_FLAG lock_flag;
+	int active_user_id;
+	struct timeval lock_start_tv;
+	id_instance user_id_list[MAX_VMETA_INSTANCE];
+} kernel_share;
+
+#define IOP_MAGIC	'v'
+
+#define VMETA_CMD_POWER_ON		_IO(IOP_MAGIC, 0)
+#define VMETA_CMD_POWER_OFF		_IO(IOP_MAGIC, 1)
+#define VMETA_CMD_CLK_ON		_IO(IOP_MAGIC, 2)
+#define VMETA_CMD_CLK_OFF		_IO(IOP_MAGIC, 3)
+#define VMETA_CMD_CLK_SWITCH		_IO(IOP_MAGIC, 4)
+#define VMETA_CMD_LOCK			_IO(IOP_MAGIC, 5)
+#define VMETA_CMD_UNLOCK		_IO(IOP_MAGIC, 6)
+#define VMETA_CMD_PRIV_LOCK		_IO(IOP_MAGIC, 7)
+#define VMETA_CMD_PRIV_UNLOCK		_IO(IOP_MAGIC, 8)
+#define VMETA_CMD_REG_UNREG		_IO(IOP_MAGIC, 9)
+
+/*
+This API is exposed in kernel space to inform other componets, like GC
+return: -1 failure; 0 power off; 1 power on
+*/
+int vmeta_power_status(void);
+
+#endif /* __UIO_VMETA_H */
diff --git a/include/linux/vdec_os_api.h b/include/linux/vdec_os_api.h
new file mode 100644
index 0000000..add9dbc
--- /dev/null
+++ b/include/linux/vdec_os_api.h
@@ -0,0 +1,166 @@
+/*
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+
+ * (C) Copyright 2010 Marvell International Ltd.
+ * All Rights Reserved
+ */
+//---------------------------------------------------------------------------
+//  Description:    VDEC OS API
+//---------------------------------------------------------------------------
+
+#ifndef VDEC_OS_API_H
+#define VDEC_OS_API_H
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+
+typedef struct _vmeta_user_info {
+    /*in parameters*/
+    int usertype;            /*0:dec, 1:enc*/
+    int strm_fmt;            /*0:mpeg1, 1:mpeg2, 2:mpeg4, 3:h261, 4:h263, 5:h264, 6:vc1 ap, 7:jpeg, 8:mjpeg, 10:vc1 sp&mp*/
+    int width;
+    int height;
+    int perf_req;            /*-99: expect lowest perf, -1: expect lower perf, 0: default perf, 1: expect higher perf, 99: expect highest perf*/
+    /*out parameters*/
+    int curr_op;             /*filled by driver, inform high-level user current operation point after user info update*/
+}vmeta_user_info;
+
+#ifndef VMETA_OP_MAX
+#define VMETA_OP_MAX		15
+#define VMETA_OP_MIN		0
+#define VMETA_OP_VGA		1
+#define VMETA_OP_720P		8
+#define VMETA_OP_1080P		14
+#define VMETA_OP_VGA_MAX	(VMETA_OP_720P-1)
+#define VMETA_OP_720P_MAX	(VMETA_OP_1080P-1)
+#define VMETA_OP_1080P_MAX	VMETA_OP_1080P
+#define VMETA_OP_VGA_ENC	VMETA_OP_720P
+#define VMETA_OP_VGA_ENC_MAX	VMETA_OP_720P_MAX
+#define VMETA_OP_INVALID -1
+#endif
+
+#ifndef __KERNEL__
+//---------------------------------------------------------------------------
+// Macros
+//---------------------------------------------------------------------------
+
+#define VMETA_MAX_OP	VMETA_OP_MAX
+#define VMETA_MIN_OP	VMETA_OP_MIN
+
+#ifndef UNSG32
+#define UNSG32 unsigned int
+#endif
+
+#ifndef SIGN32
+#define SIGN32 int
+#endif
+
+#ifndef UNSG16
+#define UNSG16 unsigned short
+#endif
+
+#ifndef SIGN16
+#define SIGN16 short
+#endif
+
+
+#ifndef UNSG8
+#define UNSG8 unsigned char
+#endif
+
+#ifndef SIGN8
+#define SIGN8 char
+#endif
+
+#ifndef _ASM_LINUX_DMA_MAPPING_H
+#define _ASM_LINUX_DMA_MAPPING_H
+enum dma_data_direction {
+    DMA_BIDIRECTIONAL   = 0,
+    DMA_TO_DEVICE       = 1,
+    DMA_FROM_DEVICE     = 2,
+    DMA_NONE            = 3,
+};
+#endif
+
+typedef enum _LOCK_RET_CODE {
+	LOCK_RET_ERROR_TIMEOUT = -9999,
+	LOCK_RET_ERROR_UNKNOWN,
+	LOCK_RET_OHTERS_NORM = 0,
+	LOCK_RET_NULL,
+	LOCK_RET_ME,
+	LOCK_RET_FORCE_INIT,
+	LOCK_RET_FORCE_TO_OTHERS,
+}LOCK_RET_CODE;
+
+//---------------------------------------------------------------------------
+// Driver initialization API
+//---------------------------------------------------------------------------
+SIGN32 vdec_os_driver_init(void);
+SIGN32 vdec_os_driver_clean(void);
+
+//---------------------------------------------------------------------------
+// Memory operation API
+//---------------------------------------------------------------------------
+void * vdec_os_api_dma_alloc(UNSG32 size, UNSG32 align, UNSG32 * pPhysical);
+void * vdec_os_api_dma_alloc_writecombine(UNSG32 size, UNSG32 align, UNSG32 * pPhysical);
+void * vdec_os_api_dma_alloc_cached(UNSG32 size, UNSG32 align, UNSG32 * pPhysical);
+void vdec_os_api_dma_free(void *ptr);
+void *vdec_os_api_vmalloc(UNSG32 size, UNSG32 align);		// always return VA and can't be translated to PA
+void vdec_os_api_vfree(void *ptr);
+UNSG32 vdec_os_api_get_va(UNSG32 paddr);
+UNSG32 vdec_os_api_get_pa(UNSG32 vaddr);
+UNSG32 vdec_os_api_flush_cache(UNSG32 vaddr, UNSG32 size, enum dma_data_direction direction);
+
+//---------------------------------------------------------------------------
+// Mem/IO R/W API
+//---------------------------------------------------------------------------
+UNSG8 vdec_os_api_rd8(UNSG32 addr);
+UNSG16 vdec_os_api_rd16(UNSG32 addr);
+UNSG32 vdec_os_api_rd32(UNSG32 addr);
+void vdec_os_api_wr8(UNSG32 addr, UNSG8 data);
+void vdec_os_api_wr16(UNSG32 addr, UNSG16 data);
+void vdec_os_api_wr32(UNSG32 addr, UNSG32 data);
+UNSG32 vdec_os_api_get_regbase_addr(void);			// return VA
+
+//---------------------------------------------------------------------------
+// Interrupt register API
+//---------------------------------------------------------------------------
+SIGN32 vdec_os_api_set_sync_timeout_isr(UNSG32 timeout);
+SIGN32 vdec_os_api_sync_event(void);
+
+//---------------------------------------------------------------------------
+// Power Management API
+//---------------------------------------------------------------------------
+SIGN32 vdec_os_api_power_on(void);
+SIGN32 vdec_os_api_power_off(void);
+SIGN32 vdec_os_api_suspend_check(void);
+void vdec_os_api_suspend_ready(void);
+SIGN32 vdec_os_api_clock_on(void);
+SIGN32 vdec_os_api_clock_off(void);
+SIGN32 vdec_os_api_update_user_info(SIGN32 user_id, vmeta_user_info *info);
+
+//---------------------------------------------------------------------------
+// Multi-instance API
+//---------------------------------------------------------------------------
+SIGN32 vdec_os_api_get_user_id(void);
+SIGN32 vdec_os_api_free_user_id(SIGN32 user_id);
+SIGN32 vdec_os_api_register_user_id(SIGN32 user_id);
+SIGN32 vdec_os_api_unregister_user_id(SIGN32 user_id);
+SIGN32 vdec_os_api_get_hw_obj_addr(UNSG32 *vaddr, UNSG32 size);
+SIGN32 vdec_os_api_get_hw_context_addr(UNSG32 *paddr, UNSG32 *vaddr, UNSG32 size, SIGN32 flag);
+SIGN32 vdec_os_api_lock(SIGN32 user_id, UNSG32 to_ms);
+SIGN32 vdec_os_api_unlock(SIGN32 user_id);
+SIGN32 vdec_os_api_get_user_count(void);
+SIGN32 vdec_os_api_force_ini(void);
+
+#endif // end of #ifndef __KERNEL__
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/linux/vmeta.h b/include/linux/vmeta.h
new file mode 100644
index 0000000..76b5ce3
--- /dev/null
+++ b/include/linux/vmeta.h
@@ -0,0 +1,47 @@
+/*
+ * Marvell Vmeta Video Encoder and Decoder Engine
+ *
+ * Copyright (C) 2011 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _VMETA_H_
+#define _VMETA_H_
+
+#include <linux/uio_driver.h>
+#include <linux/pm_qos.h>
+
+struct vmeta_instance {
+	void *reg_base;
+	struct uio_info uio_info;
+	struct timer_list irq_poll_timer;
+	spinlock_t lock;
+	unsigned long flags;
+	struct clk *clk;
+	struct clk *axi_clk;
+	struct mutex mutex;
+	int power_constraint;
+	struct timer_list power_timer;
+	int power_status;	/* 0-off 1-on */
+	int vop;		/* vmeta operating point 0-min, 15-max */
+	int vop_real;		/* used in dvfm constraint only */
+	int clk_status;
+	struct semaphore *sema;
+	struct semaphore *priv_sema;
+	struct vmeta_plat_data *plat_data;
+	struct delayed_work unset_op_work;
+	struct mutex op_mutex;
+	struct pm_qos_request qos_cpufreq_min;
+	struct pm_qos_request qos_ddrfreq_min;
+	struct pm_qos_request qos_idle;
+};
+
+extern int vmeta_runtime_constraint(struct vmeta_instance *vi, int on);
+extern int vmeta_init_constraint(struct vmeta_instance *vi);
+extern int vmeta_clean_constraint(struct vmeta_instance *vi);
+extern int vmeta_freq_change(struct vmeta_instance *vi, int step);
+extern void vmeta_power_switch(unsigned int enable);
+
+#endif
-- 
1.7.5.4

