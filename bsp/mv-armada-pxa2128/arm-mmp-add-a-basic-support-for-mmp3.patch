From 76eb1195159d3ef033a57a25d08ff1401552c9fb Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Thu, 5 Sep 2013 13:58:59 +0800
Subject: [PATCH 02/60] arm: mmp: add a basic support for mmp3

Original patches come from M5.3.12.5.4_sources, and remove
most of reduandant stuffs.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/mach-mmp/Kconfig                      |   33 +
 arch/arm/mach-mmp/Makefile                     |   40 +-
 arch/arm/mach-mmp/Makefile.boot                |   16 +-
 arch/arm/mach-mmp/clock-mmp3.c                 | 3522 ++++++++++++++++++++++++
 arch/arm/mach-mmp/common.c                     |   83 +-
 arch/arm/mach-mmp/common.h                     |   29 +-
 arch/arm/mach-mmp/cpufreq-mmp3.c               |  424 +++
 arch/arm/mach-mmp/cpuidle-mmp3.c               |  123 +
 arch/arm/mach-mmp/delay-mmp3.S                 |   59 +
 arch/arm/mach-mmp/devices.c                    | 1045 +++++++
 arch/arm/mach-mmp/dvfs-mmp3.c                  |  192 ++
 arch/arm/mach-mmp/include/mach/addr-map.h      |   64 +-
 arch/arm/mach-mmp/include/mach/cputype.h       |  123 +-
 arch/arm/mach-mmp/include/mach/debug-macro.S   |    7 +
 arch/arm/mach-mmp/include/mach/devices.h       |   22 +
 arch/arm/mach-mmp/include/mach/entry-macro.S   |   71 +
 arch/arm/mach-mmp/include/mach/gpio.h          |   44 +-
 arch/arm/mach-mmp/include/mach/hsi_dev.h       |   35 +
 arch/arm/mach-mmp/include/mach/irqs.h          |  340 +++-
 arch/arm/mach-mmp/include/mach/isp_dev.h       |   69 +
 arch/arm/mach-mmp/include/mach/memory.h        |   29 +
 arch/arm/mach-mmp/include/mach/mfp-mmp2.h      |  224 ++-
 arch/arm/mach-mmp/include/mach/mmp-zmq.h       |  166 ++
 arch/arm/mach-mmp/include/mach/mmp-zsp.h       |  120 +
 arch/arm/mach-mmp/include/mach/mmp3-audio.h    |   20 +
 arch/arm/mach-mmp/include/mach/mmp3.h          |  299 ++
 arch/arm/mach-mmp/include/mach/mmp3_pm.h       |   96 +
 arch/arm/mach-mmp/include/mach/mmp_audisland.h |   25 +
 arch/arm/mach-mmp/include/mach/mmp_cm.h        |   36 +
 arch/arm/mach-mmp/include/mach/mmp_dma.h       |  101 +
 arch/arm/mach-mmp/include/mach/mmp_events.h    |   69 +
 arch/arm/mach-mmp/include/mach/mv_wtm.h        |   24 +
 arch/arm/mach-mmp/include/mach/pxa168fb.h      |  546 ++++
 arch/arm/mach-mmp/include/mach/regs-apbc.h     |   50 +
 arch/arm/mach-mmp/include/mach/regs-apmu.h     |  201 ++-
 arch/arm/mach-mmp/include/mach/regs-audio.h    |  138 +
 arch/arm/mach-mmp/include/mach/regs-ciu.h      |   71 +
 arch/arm/mach-mmp/include/mach/regs-fastenet.h |   22 +
 arch/arm/mach-mmp/include/mach/regs-fuse.h     |   52 +
 arch/arm/mach-mmp/include/mach/regs-icu.h      |  136 +
 arch/arm/mach-mmp/include/mach/regs-mcu.h      |  143 +
 arch/arm/mach-mmp/include/mach/regs-mpmu.h     |   72 +
 arch/arm/mach-mmp/include/mach/regs-pmu.h      |   22 +
 arch/arm/mach-mmp/include/mach/regs-rtc.h      |   19 +-
 arch/arm/mach-mmp/include/mach/regs-sspa.h     |  131 +
 arch/arm/mach-mmp/include/mach/regs-timers.h   |    1 +
 arch/arm/mach-mmp/include/mach/regs-usb.h      |  415 +++
 arch/arm/mach-mmp/include/mach/regs-zsp.h      |  156 ++
 arch/arm/mach-mmp/include/mach/smp.h           |   15 +
 arch/arm/mach-mmp/include/mach/soc_coda7542.h  |   10 +
 arch/arm/mach-mmp/include/mach/soc_vmeta.h     |   47 +
 arch/arm/mach-mmp/include/mach/sram.h          |   38 +-
 arch/arm/mach-mmp/include/mach/system.h        |   27 +
 arch/arm/mach-mmp/include/mach/timex.h         |   15 +-
 arch/arm/mach-mmp/include/mach/uio_hdmi.h      |   39 +
 arch/arm/mach-mmp/irq-mmp3.c                   |  243 ++
 arch/arm/mach-mmp/localtimer.c                 |   28 +
 arch/arm/mach-mmp/mmp2_sspa.c                  |  219 ++
 arch/arm/mach-mmp/mmp3.c                       | 1775 ++++++++++++
 arch/arm/mach-mmp/mmp3_coherent_fix.S          |  620 +++++
 arch/arm/mach-mmp/mmp3_headsmp.S               |   41 +
 arch/arm/mach-mmp/mmp3_hotplug.c               |  100 +
 arch/arm/mach-mmp/mmp_dma.c                    |  185 ++
 arch/arm/mach-mmp/mv_wtm.c                     |  280 ++
 arch/arm/mach-mmp/onboard.h                    |   20 +
 arch/arm/mach-mmp/onboard/Makefile             |    4 +
 arch/arm/mach-mmp/onboard/lcd_hdmi.c           |  318 +++
 arch/arm/mach-mmp/onboard/lcd_mipi.c           | 2046 ++++++++++++++
 arch/arm/mach-mmp/platsmp.c                    |  179 ++
 arch/arm/mach-mmp/platsmp.h                    |   19 +
 arch/arm/mach-mmp/pm-hotplug.c                 |  453 +++
 arch/arm/mach-mmp/pm-mmp3.c                    | 2297 +++++++++++++++
 arch/arm/mach-mmp/pmu.c                        |  174 ++
 arch/arm/mach-mmp/qseven.c                     | 1001 +++++++
 arch/arm/mach-mmp/reset-mmp3.c                 |   46 +
 arch/arm/mach-mmp/reset.c                      |  410 +++
 arch/arm/mach-mmp/soc_time.c                   |  390 +++
 arch/arm/mach-mmp/sram.c                       |  181 +-
 arch/arm/mach-mmp/suspend.c                    |  119 +
 79 files changed, 20885 insertions(+), 179 deletions(-)
 create mode 100644 arch/arm/mach-mmp/clock-mmp3.c
 create mode 100644 arch/arm/mach-mmp/cpufreq-mmp3.c
 create mode 100644 arch/arm/mach-mmp/cpuidle-mmp3.c
 create mode 100644 arch/arm/mach-mmp/delay-mmp3.S
 create mode 100644 arch/arm/mach-mmp/dvfs-mmp3.c
 create mode 100644 arch/arm/mach-mmp/include/mach/hsi_dev.h
 create mode 100644 arch/arm/mach-mmp/include/mach/isp_dev.h
 create mode 100644 arch/arm/mach-mmp/include/mach/memory.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp-zmq.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp-zsp.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp3-audio.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp3.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp3_pm.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp_audisland.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp_cm.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp_dma.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mmp_events.h
 create mode 100644 arch/arm/mach-mmp/include/mach/mv_wtm.h
 create mode 100644 arch/arm/mach-mmp/include/mach/pxa168fb.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-audio.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-ciu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-fastenet.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-fuse.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-mcu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-mpmu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-pmu.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-sspa.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-usb.h
 create mode 100644 arch/arm/mach-mmp/include/mach/regs-zsp.h
 create mode 100644 arch/arm/mach-mmp/include/mach/smp.h
 create mode 100644 arch/arm/mach-mmp/include/mach/soc_coda7542.h
 create mode 100644 arch/arm/mach-mmp/include/mach/soc_vmeta.h
 create mode 100644 arch/arm/mach-mmp/include/mach/system.h
 create mode 100644 arch/arm/mach-mmp/include/mach/uio_hdmi.h
 create mode 100644 arch/arm/mach-mmp/irq-mmp3.c
 create mode 100644 arch/arm/mach-mmp/localtimer.c
 create mode 100644 arch/arm/mach-mmp/mmp2_sspa.c
 create mode 100644 arch/arm/mach-mmp/mmp3.c
 create mode 100644 arch/arm/mach-mmp/mmp3_coherent_fix.S
 create mode 100644 arch/arm/mach-mmp/mmp3_headsmp.S
 create mode 100644 arch/arm/mach-mmp/mmp3_hotplug.c
 create mode 100644 arch/arm/mach-mmp/mmp_dma.c
 create mode 100644 arch/arm/mach-mmp/mv_wtm.c
 create mode 100644 arch/arm/mach-mmp/onboard.h
 create mode 100644 arch/arm/mach-mmp/onboard/Makefile
 create mode 100644 arch/arm/mach-mmp/onboard/lcd_hdmi.c
 create mode 100644 arch/arm/mach-mmp/onboard/lcd_mipi.c
 create mode 100644 arch/arm/mach-mmp/platsmp.c
 create mode 100644 arch/arm/mach-mmp/platsmp.h
 create mode 100644 arch/arm/mach-mmp/pm-hotplug.c
 create mode 100644 arch/arm/mach-mmp/pm-mmp3.c
 create mode 100644 arch/arm/mach-mmp/pmu.c
 create mode 100644 arch/arm/mach-mmp/qseven.c
 create mode 100644 arch/arm/mach-mmp/reset-mmp3.c
 create mode 100644 arch/arm/mach-mmp/reset.c
 create mode 100644 arch/arm/mach-mmp/soc_time.c
 create mode 100644 arch/arm/mach-mmp/suspend.c

diff --git a/arch/arm/mach-mmp/Kconfig b/arch/arm/mach-mmp/Kconfig
index 5a90b9a..c9dbf92 100644
--- a/arch/arm/mach-mmp/Kconfig
+++ b/arch/arm/mach-mmp/Kconfig
@@ -94,6 +94,12 @@ config MACH_GPLUGD
 	  Say 'Y' here if you want to support the Marvell PXA168-based
 	  GuruPlug Display (gplugD) Board
 
+config MACH_QSEVEN
+	bool "Marvell's MMP3 QSEVEN Development Board"
+	select CPU_MMP3
+	select HAVE_PWM
+	select ARM_GIC
+
 endmenu
 
 config CPU_PXA168
@@ -113,4 +119,31 @@ config CPU_MMP2
 	select CPU_PJ4
 	help
 	  Select code specific to MMP2. MMP2 is ARMv7 compatible.
+
+config CPU_MMP3
+	bool
+	select CPU_PJ4B
+	select CACHE_L2X0
+	select ARCH_PROVIDES_UDELAY
+	select SOC_LOCAL_TIMERS if !(LOCAL_TIMERS)
+	help
+	  Select code specific to MMP3.
+
+config SOC_LOCAL_TIMERS
+	bool
+	help
+	  use SOC timers as local timers
+
+config TZ_HYPERVISOR
+	bool
+	help
+	  use hypervisor code
+
+config CORE_MORPHING
+	bool "Enable core morphing"
+	depends on CPU_MMP3
+	select TZ_HYPERVISOR
+	help
+	  Say 'Y' here if you want to enable Marvell MMP core morphing.
+
 endif
diff --git a/arch/arm/mach-mmp/Makefile b/arch/arm/mach-mmp/Makefile
index 4fc0ff5..d2cdbce 100644
--- a/arch/arm/mach-mmp/Makefile
+++ b/arch/arm/mach-mmp/Makefile
@@ -2,12 +2,43 @@
 # Makefile for Marvell's PXA168 processors line
 #
 
-obj-y				+= common.o clock.o devices.o time.o
+obj-y				+= common.o devices.o pmu.o
 
 # SoC support
-obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq-pxa168.o
-obj-$(CONFIG_CPU_PXA910)	+= pxa910.o irq-pxa168.o
-obj-$(CONFIG_CPU_MMP2)		+= mmp2.o irq-mmp2.o sram.o
+obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq-pxa168.o clock.o time.o
+obj-$(CONFIG_CPU_PXA910)	+= pxa910.o irq-pxa168.o clock.o time.o
+obj-$(CONFIG_CPU_MMP2)		+= mmp2.o irq-mmp2.o sram.o clock.o time.o
+
+obj-$(CONFIG_CPU_MMP3)		+= mmp3.o irq-mmp3.o mmp_dma.o mmp2_sspa.o \
+				sram.o delay-mmp3.o clock-mmp3.o dvfs-mmp3.o \
+				pm-hotplug.o mmp3_coherent_fix.o mv_wtm.o
+
+obj-$(CONFIG_FB_PXA168)         += onboard/
+
+ifeq ($(CONFIG_SMP),y)
+obj-$(CONFIG_CPU_MMP3)          += platsmp.o mmp3_headsmp.o reset-mmp3.o
+endif
+
+ifeq ($(CONFIG_HOTPLUG_CPU),y)
+obj-$(CONFIG_CPU_MMP3)		+= mmp3_hotplug.o
+endif
+
+ifeq ($(CONFIG_SOC_LOCAL_TIMERS),y)
+obj-$(CONFIG_CPU_MMP3)		+= soc_time.o
+else ifneq ($(CONFIG_CPU_PXA988),y)
+obj-y				+= time.o
+obj-$(CONFIG_LOCAL_TIMERS)	+= localtimer.o
+endif
+
+ifeq ($(CONFIG_PM),y)
+obj-$(CONFIG_CPU_MMP3)		+= pm-mmp3.o
+obj-$(CONFIG_CPU_MMP3)		+= suspend.o
+ifeq ($(CONFIG_CPU_IDLE),y)
+obj-$(CONFIG_CPU_MMP3)		+= cpuidle-mmp3.o
+endif
+endif
+
+obj-$(CONFIG_CPU_FREQ_MMP3)     += cpufreq-mmp3.o
 
 # board support
 obj-$(CONFIG_MACH_ASPENITE)	+= aspenite.o
@@ -21,3 +52,4 @@ obj-$(CONFIG_MACH_MARVELL_JASPER) += jasper.o
 obj-$(CONFIG_MACH_MMP_DT)	+= mmp-dt.o
 obj-$(CONFIG_MACH_TETON_BGA)	+= teton_bga.o
 obj-$(CONFIG_MACH_GPLUGD)	+= gplugd.o
+obj-$(CONFIG_MACH_QSEVEN)	+= qseven.o
diff --git a/arch/arm/mach-mmp/Makefile.boot b/arch/arm/mach-mmp/Makefile.boot
index 5edf03e..bb8a588 100644
--- a/arch/arm/mach-mmp/Makefile.boot
+++ b/arch/arm/mach-mmp/Makefile.boot
@@ -1 +1,15 @@
-   zreladdr-y	+= 0x00008000
+
+ifeq ($(CONFIG_CRASH_DUMP),y)
+	__ADDRBASE := 0x06000000
+else
+ifeq ($(CONFIG_TZ_HYPERVISOR),y)
+	__ADDRBASE := 0x00200000
+else
+	__ADDRBASE := 0x00000000
+endif
+endif
+
+__ZRELADDR := $(shell /bin/bash -c 'printf "0x%08x" \
+	$$[$(TEXT_OFFSET) + $(__ADDRBASE)]')
+
+zreladdr-y := $(__ZRELADDR)
diff --git a/arch/arm/mach-mmp/clock-mmp3.c b/arch/arm/mach-mmp/clock-mmp3.c
new file mode 100644
index 0000000..696461b
--- /dev/null
+++ b/arch/arm/mach-mmp/clock-mmp3.c
@@ -0,0 +1,3522 @@
+/*
+ *  linux/arch/arm/mach-mmp/clock-mmp3.c
+ *
+ *  Author:	Raul Xiong <xjian@marvell.com>
+ *		Alan Zhu <wzhu10@marvell.com>
+ *  Copyright:	(C) 2011 Marvell International Ltd.
+ *
+ *  based on arch/arm/mach-tegra/tegra2_clocks.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <mach/mmp3_pm.h>
+#include <mach/regs-apbc.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/cputype.h>
+#include <plat/clock.h>
+#include <plat/devfreq.h>
+#include <linux/reboot.h>
+#include "common.h"
+
+#define CORE_NUM			3
+#define PMUA_CC				APMU_REG(0x4)
+#define PMUA_CC_2			APMU_REG(0x150)
+#define PMUA_CC_3			APMU_REG(0x188)
+#define PMUA_BUS			APMU_REG(0x6c)
+#define PMUA_DM_CC			APMU_REG(0xc)
+#define PMUA_DM_2_CC			APMU_REG(0x158)
+
+#define MMP3_PROTECT_CC(x)		(((x) & 0x0003fe3f) | 0x00bc0000)
+#define MMP3_PROTECT_CC2(x)		((x) & 0xfffffe07)
+#define MMP3_PROTECT_CC3(x)		((x) & 0x0effff1f)
+#define MMP3_PROTECT_BUSCLKRST(x)	((x) & 0x000001c3)
+#define MMP3_PROTECT_FCCR(x)		((x) & 0xff83ffff)
+
+extern unsigned int mmp_plat_ref_clk;
+
+/*#define CONFIG_MMP3_QSEVEN_26MHZ*/
+
+/* Dynamic Frequency Change Part */
+enum {
+	MMP3_FREQ_OP_GET = 0,
+	MMP3_FREQ_OP_UPDATE = 1,
+	MMP3_FREQ_OP_SHOW = 2,
+
+	MMP3_FREQ_PH_D_BY_4 = 1,
+	MMP3_FREQ_PH_D_BY_6 = 2,
+	MMP3_FREQ_PH_D_BY_8 = 3,
+	MMP3_FREQ_PH_D_BY_10 = 4,
+	MMP3_FREQ_PH_D_BY_12 = 5,
+	MMP3_FREQ_PH_D_BY_14 = 6,
+	MMP3_FREQ_PH_D_BY_15 = 7,
+
+	MMP3_FREQCH_VOLTING = (1u << 27),
+	MMP3_FREQCH_CORE = (1u << 24),
+	MMP3_FREQCH_DRAM = (9u << 22),	/* both channel */
+	MMP3_FREQCH_AXI = (1u << 26),
+};
+
+static struct clk mmp3_clk_pll1_d_2 = {
+	.name = "pll1_d_2",
+	.rate = 400000000,
+	.ops = NULL,
+};
+
+static struct clk mmp3_clk_pll1 = {
+	.name = "pll1",
+	.rate = 800000000,
+	.ops = NULL,
+};
+
+static int mmp3_clk_pll2_enable(struct clk *clk)
+{
+	u32 value;
+
+	/* disable PLL2 */
+	value = __raw_readl(MPMU_PLL2CR);
+
+	if (value & (1 << 8))
+		return 0; /* already enabled */
+
+	value &= ~(1 << 8);
+	__raw_writel(value, MPMU_PLL2CR);
+
+	/* select VCO as clock source */
+	value = __raw_readl(MPMU_PLL2_CTRL2);
+	value |= 1 << 0;
+	__raw_writel(value, MPMU_PLL2_CTRL2);
+
+	/* Program PLL2 for 1200Mhz, (VCO 2.4G)*/
+	__raw_writel(0x05390699, MPMU_PLL2_CTRL1);
+	__raw_writel(0x001C5200, MPMU_PLL2CR);
+
+	/* enable PLL2 */
+	value = __raw_readl(MPMU_PLL2CR);
+	value |= 1 << 8;
+	__raw_writel(value, MPMU_PLL2CR);
+
+	udelay(500);
+
+	/* take PLL2 out of reset */
+	value = __raw_readl(MPMU_PLL2_CTRL1);
+	value |= 1 << 29;
+	__raw_writel(value, MPMU_PLL2_CTRL1);
+
+	udelay(500);
+
+	return 0;
+}
+
+static void mmp3_clk_pll2_disable(struct clk *clk)
+{
+	u32 value;
+
+	/* PLL2 Control register, disable SW PLL2 */
+	value = __raw_readl(MPMU_PLL2CR);
+	value &= ~(1 << 8);
+	__raw_writel(value, MPMU_PLL2CR);
+
+	/* wait for PLLs to lock */
+	udelay(500);
+
+	/* MPMU_PLL2_CTRL1: put PLL2 into reset */
+	value = __raw_readl(MPMU_PLL2_CTRL1);
+	value = ~(1 << 29);
+	__raw_writel(value, MPMU_PLL2_CTRL1);
+
+	udelay(500);
+}
+
+static struct clkops mmp3_clk_pll2_ops = {
+	.enable = mmp3_clk_pll2_enable,
+	.disable = mmp3_clk_pll2_disable,
+};
+
+static struct clk mmp3_clk_pll2 = {
+	.name = "pll2",
+	.rate = 1200000000,
+	.ops = &mmp3_clk_pll2_ops,
+};
+
+static int mmp3_clk_pll1_clkoutp_enable(struct clk *clk)
+{
+	u32 value = __raw_readl(PMUM_PLL_DIFF_CTRL);
+	/* Set PLL1 CLKOUTP post VCO divider as 1.5 */
+	value &= ~(0xf << 0);
+	value |= 1 << 0;
+	value |= 1 << 4;
+	__raw_writel(value, PMUM_PLL_DIFF_CTRL);
+
+	return 0;
+}
+
+static void mmp3_clk_pll1_clkoutp_disable(struct clk *clk)
+{
+	u32 value = __raw_readl(PMUM_PLL_DIFF_CTRL);
+	__raw_writel(value & ~(1 << 4), PMUM_PLL_DIFF_CTRL);
+}
+
+static struct clkops mmp3_clk_pll1_clkoutp_ops = {
+	.enable = mmp3_clk_pll1_clkoutp_enable,
+	.disable = mmp3_clk_pll1_clkoutp_disable,
+};
+
+/*
+ * NOTE: actually pll1_clkoutp and pll1 share the same clock source
+ * pll1_VCO, which is 1600MHz. And pll1 has a post didiver 2, pll1_clkoutp
+ * has a post didiver 1.5. Since we don't expose pll1_VCO as a visible
+ * clock, here we use pll1 as its parent to workaround. So we have to
+ * set the div as 3 and mul as 4.
+ */
+static struct clk mmp3_clk_pll1_clkoutp = {
+	.name = "pll1_clkoutp",
+	.rate = 1066000000,
+	.parent = &mmp3_clk_pll1,
+	.mul = 4,
+	.div = 3,
+	.ops = &mmp3_clk_pll1_clkoutp_ops,
+};
+
+static int mmp3_clk_pll2_clkoutp_enable(struct clk *clk)
+{
+	u32 value = __raw_readl(PMUM_PLL_DIFF_CTRL);
+	/* Set PLL2 CLKOUTP post VCO divider as 2.5 */
+	value &= ~(0xf << 5);
+	value |= 3u << 5;
+	value |= 1u << 9;
+	__raw_writel(value, PMUM_PLL_DIFF_CTRL);
+
+	return 0;
+}
+
+static void mmp3_clk_pll2_clkoutp_disable(struct clk *clk)
+{
+	u32 value = __raw_readl(PMUM_PLL_DIFF_CTRL);
+	__raw_writel(value & ~(1 << 9), PMUM_PLL_DIFF_CTRL);
+}
+
+static struct clkops mmp3_clk_pll2_clkoutp_ops = {
+	.enable = mmp3_clk_pll2_clkoutp_enable,
+	.disable = mmp3_clk_pll2_clkoutp_disable,
+};
+
+/*
+ * NOTE: pll2_clkoutp and pll2 both divided from PLL2 VCO, which is 2.4G
+ *.in current configuration. And pll2 has a post didiver 2, pll2_clkoutp
+ * has a post didiver 2.5. Since we don't expose pll2_VCO as a visible
+ * clock, here we use pll2 as its parent to workaround. So we have to
+ * set the div as 5 and mul as 4.
+ */
+static struct clk mmp3_clk_pll2_clkoutp = {
+	.name = "pll2_clkoutp",
+	.rate = 960000000,
+	.parent = &mmp3_clk_pll2,
+	.mul = 4,
+	.div = 5,
+	.ops = &mmp3_clk_pll2_clkoutp_ops,
+};
+
+
+static struct clk mmp3_clk_vctcxo = {
+	.name = "vctcxo",
+	.rate = 26000000,
+	.ops = NULL,
+};
+
+static struct clk mmp3_clk_32k = {
+	.name = "32k",
+	.rate = 32768,
+	.ops = NULL,
+};
+
+static struct clk mmp3_clk_pll1_d_4 = {
+	.name = "pll1_d_4",
+	.rate = 200000000,
+	.ops = NULL,
+};
+
+static int mmp3_clk_pll3_enable(struct clk *clk)
+{
+	u64 div_result;
+	u32 tmp, pll3_ctrl1, pll3_cr, FBDIV;
+	u8 VCODIV_SEL_SE, KVCO, VCO_VRNG, REFDIV = 0x3;
+	unsigned long parent_rate, rate = clk->rate;
+
+	tmp = (__raw_readl(APMU_FSIC3_CLK_RES_CTRL) >> 8) & 0xF;
+	if (tmp == 0xD)
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+	else {
+		pr_err("Fatal error: pll3 has error clock input config\n");
+		BUG_ON(1);
+	}
+
+	/* PLL3 control register 1 - program ICP = 4 */
+	pll3_ctrl1 = 0x01010099;
+
+	/* 1.2GHz ~2.4GHz */
+	if ((rate >= 1200000000UL) && (rate <= 2400000000UL))
+		VCODIV_SEL_SE = 0x0 ;
+	else if (rate >= 800000000UL) { /* 800MHz */
+		rate /= 2;
+		VCODIV_SEL_SE = 0x1;
+	} else if (rate >= 600000000UL) /* 600MHz */
+		VCODIV_SEL_SE = 0x2;
+	else if (rate >= 480000000UL) { /* 480MHz */
+		rate /= 2;
+		VCODIV_SEL_SE = 0x3;
+	} else if (rate >= 400000000UL) /* 400MHz */
+		VCODIV_SEL_SE = 0x4;
+	else if (rate >= 300000000UL)   /* 300MHz */
+		VCODIV_SEL_SE = 0x5;
+	else if (rate >= 240000000UL)   /* 240MHz */
+		VCODIV_SEL_SE = 0x6;
+	else if (rate >= 200000000UL)   /* 200MHz */
+		VCODIV_SEL_SE = 0x7;
+	else if (rate >= 150000000UL)   /* 150MHz */
+		VCODIV_SEL_SE = 0x8;
+	else {
+		pr_err("Fatal error: pll3 config out of range\n");
+		BUG_ON(1);
+	}
+
+	/* rate = VCO/post_div, post_div = clk->div / REFDIV / (?2:1)*/
+	rate *= (clk->div / REFDIV);
+	if (rate > 1200000000UL && rate <= 1360000000UL)
+		KVCO = 0x1;
+	else if (rate > 1360000000UL && rate <= 1530000000UL)
+		KVCO = 0x2;
+	else if (rate > 1530000000UL && rate <= 1700000000UL)
+		KVCO = 0x3;
+	else if (rate > 1700000000UL && rate <= 1900000000UL)
+		KVCO = 0x4;
+	else if (rate > 1900000000UL && rate <= 2100000000UL)
+		KVCO = 0x5;
+	else if (rate > 2100000000UL && rate <= 2300000000UL)
+		KVCO = 0x6;
+	else if (rate > 2300000000UL && rate <= 2400000000UL)
+		KVCO = 0x7;
+	else
+		KVCO = 0x6;
+
+	if (KVCO >= 0x1 && KVCO <= 0x6)
+		VCO_VRNG = KVCO - 1;
+	else
+		VCO_VRNG = 0x5;
+
+	pll3_ctrl1 |= (VCODIV_SEL_SE << 25 | KVCO << 19 | VCO_VRNG << 8);
+
+	div_result = (u64)rate * REFDIV;
+	do_div(div_result, parent_rate);
+	FBDIV = div_result & 0x1ff;
+	pll3_cr = (REFDIV << 19) | (FBDIV << 10) | (0x1 << 9);
+
+	tmp = __raw_readl(PMUM_PLL3_CTRL2);
+	/* set SEL_VCO_CLK_SE in PMUM_PLL3_CTRL2 register */
+	__raw_writel(tmp | 0x00000001, PMUM_PLL3_CTRL2);
+
+	/* PLL3 control register 1 ICP = 4.*/
+	__raw_writel(pll3_ctrl1, PMUM_PLL3_CTRL1);
+
+	/* MPMU_PLL3CR: Program PLL3 VCO */
+	__raw_writel(pll3_cr, PMUM_PLL3_CR);
+
+	/* PLL3 Control register -Enable SW PLL3 */
+	tmp = __raw_readl(PMUM_PLL3_CR);
+	__raw_writel(tmp | 0x00000100, PMUM_PLL3_CR);
+
+	/* wait for PLLs to lock */
+	udelay(500);
+
+	/* PMUM_PLL3_CTRL1: take PLL3 out of reset */
+	tmp = __raw_readl(PMUM_PLL3_CTRL1);
+	__raw_writel(tmp | 0x20000000, PMUM_PLL3_CTRL1);
+
+	udelay(500);
+
+	return 0;
+}
+
+static void mmp3_clk_pll3_disable(struct clk *clk)
+{
+	u32 tmp = __raw_readl(PMUM_PLL3_CR);
+
+	/* PLL3 Control register, disable SW PLL3 */
+	__raw_writel(tmp & ~0x00000100, PMUM_PLL3_CR);
+
+	/* wait for PLLs to lock */
+	udelay(500);
+
+	/* PMUM_PLL3_CTRL1: put PLL3 into reset */
+	tmp = __raw_readl(PMUM_PLL3_CTRL1);
+	__raw_writel(tmp & ~0x20000000, PMUM_PLL3_CTRL1);
+
+	udelay(500);
+}
+
+static long mmp3_clk_pll3_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned int fb_div, post_div, ref_div = 0x3;
+	unsigned long parent_rate, rate_rounded;
+	u64 div_result;
+	u32 tmp = (__raw_readl(APMU_FSIC3_CLK_RES_CTRL) >> 8) & 0xF;
+
+	if (tmp == 0xD)
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+	else {
+		pr_err("Fatal error: pll3 has error clock input config");
+		BUG_ON(1);
+	}
+
+	/* 1.2GHz ~2.4GHz */
+	if (rate >= 1200000000UL && rate <= 2400000000UL)
+		post_div = 1;
+	else if (rate >= 800000000UL) /* 800MHz */
+		post_div = 3;         /* post divider actually is 1.5; */
+	else if (rate >= 600000000UL) /* 600MHz */
+		post_div = 2;
+	else if (rate >= 480000000UL) /* 480MHz */
+		post_div = 5;         /* post divider actually is 2.5; */
+	else if (rate >= 400000000UL) /* 400MHz */
+		post_div = 3;
+	else if (rate >= 300000000UL) /* 300MHz */
+		post_div = 4;
+	else if (rate >= 240000000UL) /* 240MHz */
+		post_div = 5;
+	else if (rate >= 200000000UL) /* 200MHz */
+		post_div = 6;
+	else if (rate >= 150000000UL) /* 150MHz */
+		post_div = 8;
+	else {
+		pr_err("Fatal error: pll3 config out of range: %lu\n", rate);
+		BUG_ON(1);
+	}
+
+	div_result = ((u64)rate) * ref_div * post_div;
+	div_result += parent_rate / 2; /* to round the FBDIV */
+	do_div(div_result, parent_rate);
+	fb_div = div_result;
+
+	div_result = ((u64)parent_rate) * fb_div;
+	do_div(div_result, (ref_div * post_div));
+	rate_rounded = div_result;
+
+	return rate_rounded;
+}
+
+static int mmp3_clk_pll3_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long parent_rate;
+	u64 div_result;
+	unsigned int ref_div = 0x3;
+	clk->div = 0;
+
+	parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+
+	if (rate >= 1200000000UL && rate <= 2400000000UL)  /* 1.2GHz ~2.4GHz */
+		clk->div = 1;
+	else if (rate >= 800000000UL) /* 800MHz */
+		clk->div = 3;
+	else if (rate >= 600000000UL) /* 600MHz */
+		clk->div = 2;
+	else if (rate >= 480000000UL) /* 480MHz */
+		clk->div = 5;
+	else if (rate >= 400000000UL) /* 400MHz */
+		clk->div = 3;
+	else if (rate >= 300000000UL) /* 300MHz */
+		clk->div = 4;
+	else if (rate >= 240000000UL) /* 240MHz */
+		clk->div = 5;
+	else if (rate >= 200000000UL) /* 200MHz */
+		clk->div = 6;
+	else if (rate >= 150000000UL) /* 150MHz */
+		clk->div = 8;
+	else {
+		pr_err("Fatal error: pll3 config out of range\n");
+		BUG_ON(1);
+	}
+	clk->div *= ref_div;
+	div_result = ((u64)rate) * clk->div;
+	div_result += parent_rate / 2; /* to round the mul */
+	do_div(div_result, parent_rate);
+	clk->mul = div_result;
+
+	return 0;
+}
+
+static struct clk_mux_sel mux_pll1_pll2_vctcxo[] = {
+	{.input = &mmp3_clk_pll1_d_2, .value = 0},
+	{.input = &mmp3_clk_pll1, .value = 1},
+	{.input = &mmp3_clk_pll2, .value = 2},
+	{.input = &mmp3_clk_pll1_clkoutp, .value = 3},
+	{.input = &mmp3_clk_vctcxo, .value = 4},
+	{0, 0},
+};
+
+static void mmp3_core_clk_trigger_change(void)
+{
+	u32 val;
+	val = __raw_readl(PMUA_CC);
+	val = MMP3_PROTECT_CC(val);	/* set reserved */
+	val = val | MMP3_FREQCH_CORE | MMP3_FREQCH_VOLTING;
+	/* A0 need to all cores run, we use coherent broadcasts */
+	dsb();
+	/* trigger change */
+	__raw_writel(val, PMUA_CC);
+	/* done, PJ_RD_STATUS should have been cleared by HW */
+}
+
+static void mmp3_clk_source_init(struct clk *c)
+{
+	u32 val, source;
+	const struct clk_mux_sel *sel;
+
+	c->dynamic_change = 1;
+	c->mul = 1;
+	c->div = 1;
+
+	val = __raw_readl(c->reg_data[SOURCE][STATUS].reg);
+	source = (val >> c->reg_data[SOURCE][STATUS].reg_shift)
+	    & c->reg_data[SOURCE][STATUS].reg_mask;
+	for (sel = c->inputs; sel->input != NULL; sel++) {
+		if (sel->value == source)
+			break;
+	}
+	BUG_ON(sel->input == NULL);
+	c->parent = sel->input;
+}
+
+static int mmp3_clk_set_parent(struct clk *c, struct clk *p)
+{
+	u32 val;
+	const struct clk_mux_sel *sel;
+
+	val = __raw_readl(c->reg_data[SOURCE][CONTROL].reg);
+	for (sel = c->inputs; sel->input != NULL; sel++) {
+		if (sel->input == p) {
+			if (c->reg_data[SOURCE][CONTROL].reg == MPMU_FCCR)
+				val = MMP3_PROTECT_FCCR(val);
+			else if (c->reg_data[SOURCE][CONTROL].reg == PMUA_BUS)
+				val = MMP3_PROTECT_BUSCLKRST(val);
+			val &= ~(c->reg_data[SOURCE][CONTROL].reg_mask
+				 << c->reg_data[SOURCE][CONTROL].reg_shift);
+			val |= sel->value
+			    << c->reg_data[SOURCE][CONTROL].reg_shift;
+			__raw_writel(val, c->reg_data[SOURCE][CONTROL].reg);
+			/*
+			 * FIXME: DO NOT trigger here since
+			 * we will triggered the changes together later
+			 */
+			/* mmp3_core_clk_trigger_change(); */
+			clk_reparent(c, p);
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+static struct clkops mmp3_clk_root_ops = {
+	.init = mmp3_clk_source_init,
+	.set_parent = mmp3_clk_set_parent,
+};
+
+static struct clk mmp3_clk_core_root = {
+	.name = "core_root",
+	.inputs = mux_pll1_pll2_vctcxo,
+	.ops = &mmp3_clk_root_ops,
+	.reg_data = {
+		     { {MPMU_FCCR, 29, 0x7}, {MPMU_FCCR, 29, 0x7} },
+		     { {0, 0, 0}, {0, 0, 0} } },
+};
+
+static void mmp3_clk_div_init(struct clk *c)
+{
+	u32 val;
+
+	c->dynamic_change = 1;
+	c->mul = 1;
+
+	val = __raw_readl(c->reg_data[DIV][STATUS].reg);
+	c->div = ((val >> c->reg_data[DIV][STATUS].reg_shift)
+		  & c->reg_data[DIV][STATUS].reg_mask) + 1;
+}
+
+static int mmp3_clk_set_rate(struct clk *c, unsigned long rate)
+{
+	int i;
+	int max_div = c->reg_data[DIV][CONTROL].reg_mask + 1;
+	u32 val = __raw_readl(c->reg_data[DIV][CONTROL].reg);
+	unsigned long parent_rate = clk_get_rate(c->parent);
+
+	for (i = 1; i <= max_div; i++) {
+		if (rate == parent_rate / i) {
+			if (c->reg_data[DIV][CONTROL].reg == PMUA_CC)
+				val = MMP3_PROTECT_CC(val);
+			else if (c->reg_data[DIV][CONTROL].reg == PMUA_CC_2)
+				val = MMP3_PROTECT_CC2(val);
+			else if (c->reg_data[DIV][CONTROL].reg == PMUA_CC_3)
+				val = MMP3_PROTECT_CC3(val);
+
+			val &= ~(c->reg_data[DIV][CONTROL].reg_mask
+				 << c->reg_data[DIV][CONTROL].reg_shift);
+			val |= (i - 1) << c->reg_data[DIV][CONTROL].reg_shift;
+			__raw_writel(val, c->reg_data[DIV][CONTROL].reg);
+			/*
+			 * FIXME: DO NOT trigger here since
+			 * we will triggered the changes together later
+			 */
+			/* mmp3_core_clk_trigger_change(); */
+			c->div = i;
+			c->mul = 1;
+			return 0;
+		}
+	}
+	return -EINVAL;
+}
+
+static struct clkops mmp3_clk_div_ops = {
+	.init = mmp3_clk_div_init,
+	.setrate = mmp3_clk_set_rate,
+};
+
+static struct clk mmp3_clk_virtual_pj = {
+	.name = "pj",
+	.parent = &mmp3_clk_core_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_CC, 0, 0x7}, {PMUA_CC, 0, 0x7} } },
+};
+
+static struct clk mmp3_clk_mp1 = {
+	.name = "mp1",
+	.parent = &mmp3_clk_virtual_pj,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 9, 0xf}, {PMUA_CC_2, 9, 0xf} } },
+};
+
+static struct clk mmp3_clk_mp2 = {
+	.name = "mp2",
+	.parent = &mmp3_clk_virtual_pj,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 13, 0xf}, {PMUA_CC_2, 13, 0xf} } },
+};
+
+static struct clk mmp3_clk_mm = {
+	.name = "mm",
+	.parent = &mmp3_clk_virtual_pj,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 17, 0xf}, {PMUA_CC_2, 17, 0xf} } },
+};
+
+static struct clk mmp3_clk_aclk = {
+	.name = "aclk",
+	.parent = &mmp3_clk_virtual_pj,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 21, 0xf}, {PMUA_CC_2, 21, 0xf} } },
+};
+
+static void mmp3_core_periph_init(struct clk *c)
+{
+	u32 val, div_val;
+
+	c->dynamic_change = 1;
+	c->mul = 1;
+
+	val = __raw_readl(c->reg_data[DIV][STATUS].reg);
+	div_val = (val >> c->reg_data[DIV][STATUS].reg_shift)
+	    & c->reg_data[DIV][STATUS].reg_mask;
+	if (div_val != 7)
+		c->div = (div_val + 1) * 2;
+	else
+		c->div = 15;
+}
+
+static int mmp3_core_periph_set_rate(struct clk *c, unsigned long rate)
+{
+	int i;
+	int max_div = 15;
+	u32 val = __raw_readl(c->reg_data[DIV][CONTROL].reg);
+	unsigned long parent_rate = clk_get_rate(c->parent);
+
+	for (i = 4; i < max_div; i += 2) {
+		if (rate == parent_rate / i) {
+			val = MMP3_PROTECT_CC(val);
+			val &= ~(c->reg_data[DIV][CONTROL].reg_mask
+				 << c->reg_data[DIV][CONTROL].reg_shift);
+			val |= (i / 2 - 1)
+			    << c->reg_data[DIV][CONTROL].reg_shift;
+			__raw_writel(val, c->reg_data[DIV][CONTROL].reg);
+			/*
+			 * FIXME: DO NOT trigger here since
+			 * we will triggered the changes together later
+			 */
+			/* mmp3_core_clk_trigger_change(); */
+			c->div = i;
+			c->mul = 1;
+			return 0;
+		}
+	}
+
+	if (rate == parent_rate / max_div) {
+		val = MMP3_PROTECT_CC(val);
+		val &= ~(c->reg_data[DIV][CONTROL].reg_mask
+			 << c->reg_data[DIV][CONTROL].reg_shift);
+		val |= 7 << c->reg_data[DIV][CONTROL].reg_shift;
+		__raw_writel(val, c->reg_data[DIV][CONTROL].reg);
+		/*
+		 * FIXME: DO NOT trigger here since
+		 * we will triggered the changes together later
+		 */
+		/* mmp3_core_clk_trigger_change(); */
+		c->div = max_div;
+		c->mul = 1;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static struct clkops mmp3_core_periph_ops = {
+	.init = mmp3_core_periph_init,
+	.setrate = mmp3_core_periph_set_rate,
+};
+
+static struct clk mmp3_clk_core_periph = {
+	.name = "periph",
+	.parent = &mmp3_clk_core_root,
+	.ops = &mmp3_core_periph_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 25, 0x7}, {PMUA_CC, 9, 0x7} } },
+};
+
+static struct clk mmp3_clk_atclk = {
+	.name = "atclk",
+	.parent = &mmp3_clk_core_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_CC, 3, 0x7}, {PMUA_CC, 3, 0x7} } },
+};
+
+static struct {
+	struct clk *source_clk;
+	unsigned long pj_rate;
+	unsigned long mp1_rate;
+	unsigned long mp2_rate;
+	unsigned long mm_rate;
+	unsigned long aclk_rate;
+	unsigned long ph_rate;
+	unsigned long atclk_rate;
+} mmp3_op_table[] = {
+	{
+	&mmp3_clk_pll1_d_2, 200000000, 200000000,
+		    200000000, 200000000, 200000000, 100000000, 200000000}, {
+	&mmp3_clk_pll1, 400000000, 400000000,
+		    400000000, 400000000, 400000000, 200000000, 400000000}, {
+	&mmp3_clk_pll1, 800000000, 800000000,
+		    800000000, 400000000, 400000000, 200000000, 400000000}, {
+	&mmp3_clk_pll1_clkoutp, 1062000000, 1062000000,
+		    1062000000, 531000000, 531000000, 177000000, 354000000}, {
+	    /* must be the last line! */
+	NULL, 0, 0, 0, 0, 0, 0, 0} };
+
+static void mmp3_cpu_clk_init(struct clk *c)
+{
+	c->dynamic_change = 1;
+	c->mul = 1;
+	c->div = 1;
+}
+
+static int mmp3_cpu_clk_set_rate(struct clk *c, unsigned long rate)
+{
+	int ret, index, i;
+
+	for (i = 0; mmp3_op_table[i].source_clk != NULL; i++) {
+		if (mmp3_op_table[i].mp1_rate >= rate) {
+			index = i;
+			break;
+		}
+	}
+	if (mmp3_op_table[i].source_clk == NULL)
+		return -EINVAL;
+
+	/* obtain FC onwership, should always pass */
+	i = 1000;
+	while ((__raw_readl(PMUA_DM_CC) & (1u << 24)) != 0) {
+		i--;
+		if (i <= 0) {
+			pr_err("Cannot gain owner of PMU DFC\n");
+			return -EAGAIN;
+		}
+	}
+
+	ret = clk_set_parent(&mmp3_clk_core_root,
+			     mmp3_op_table[index].source_clk);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_virtual_pj, mmp3_op_table[index].pj_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_mp1, mmp3_op_table[index].mp1_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_mp2, mmp3_op_table[index].mp2_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_mm, mmp3_op_table[index].mm_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_aclk, mmp3_op_table[index].aclk_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_core_periph, mmp3_op_table[index].ph_rate);
+	if (ret)
+		return ret;
+
+	ret = clk_set_rate(&mmp3_clk_atclk, mmp3_op_table[index].atclk_rate);
+	if (ret)
+		return ret;
+
+	mmp3_core_clk_trigger_change();
+
+	return 0;
+}
+
+static struct clkops mmp3_cpu_ops = {
+	.init = mmp3_cpu_clk_init,
+	.setrate = mmp3_cpu_clk_set_rate,
+};
+
+static struct clk mmp3_clk_virtual_cpu __maybe_unused = {
+	.name = "cpu",
+	.parent = &mmp3_clk_virtual_pj,
+	.ops = &mmp3_cpu_ops,
+};
+
+/* ddr clock definitions */
+static struct clk mmp3_clk_ddr_root = {
+	.name = "ddr_root",
+	.inputs = mux_pll1_pll2_vctcxo,
+	.ops = &mmp3_clk_root_ops,
+	.reg_data = {
+		     { {MPMU_FCCR, 23, 0x7}, {MPMU_FCCR, 23, 0x7} },
+		     { {0, 0, 0}, {0, 0, 0} } },
+};
+
+static struct clk mmp3_clk_ddr1 = {
+	.name = "ddr1",
+	.parent = &mmp3_clk_ddr_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_CC, 12, 0x7}, {PMUA_CC, 12, 0x7} } },
+};
+
+static struct clk mmp3_clk_ddr2 = {
+	.name = "ddr2",
+	.parent = &mmp3_clk_ddr_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_CC, 9, 0x7}, {PMUA_CC_3, 17, 0x7} } },
+};
+
+/* axi clock definitions */
+static struct clk mmp3_clk_axi_root = {
+	.name = "axi_root",
+	.inputs = mux_pll1_pll2_vctcxo,
+	.ops = &mmp3_clk_root_ops,
+	.reg_data = {
+		     { {PMUA_BUS, 6, 0x7}, {PMUA_BUS, 6, 0x7} },
+		     { {0, 0, 0}, {0, 0, 0} } },
+};
+
+static struct clk mmp3_clk_axi1 = {
+	.name = "axi1",
+	.parent = &mmp3_clk_axi_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_CC, 15, 0x7}, {PMUA_CC, 15, 0x7} } },
+};
+
+static struct clk mmp3_clk_axi2 = {
+	.name = "axi2",
+	.parent = &mmp3_clk_axi_root,
+	.ops = &mmp3_clk_div_ops,
+	.reg_data = {
+		     { {0, 0, 0}, {0, 0, 0} },
+		     { {PMUA_DM_2_CC, 0, 0x7}, {PMUA_CC_2, 0, 0x7} } },
+};
+
+static int clk_cpu_setrate(struct clk *clk, unsigned long val)
+{
+	/*
+	 * FIXME this need change when smp process id to real process id
+	 * mapping is ready, then we can do frequency table for each core
+	 * currently the mapping depends on which core to boot.
+	 * Also currently we assume only MP1/2 are active and they always runs
+	 * at the same frequency. so we only use and trigger DFC target on MP1
+	 */
+	mmp3_setfreq(MMP3_CLK_MP1, val);
+	return 0;
+}
+
+static unsigned long clk_cpu_getrate(struct clk *clk)
+{
+	return mmp3_getfreq(MMP3_CLK_MP1);
+}
+
+static struct clkops clk_cpu_ops = {
+	.setrate = clk_cpu_setrate,
+	.getrate = clk_cpu_getrate,
+};
+
+static struct clk mmp3_clk_cpu = {
+	.name = "cpu",
+	.ops = &clk_cpu_ops,
+	.dynamic_change = 1,
+};
+
+#ifdef CONFIG_DDR_DEVFREQ
+extern struct devfreq_frequency_table *mmp3_ddr_freq_table;
+
+static unsigned int target_freq = 800000;
+static unsigned int cur_freq = 800000;
+static atomic_t ddr_dfc_disabled = ATOMIC_INIT(0);
+static atomic_t dfc_trigger = ATOMIC_INIT(0);
+static struct mutex disable_ddr_lock;
+DECLARE_COMPLETION(vsync_complete);
+extern atomic_t mmp3_fb_is_suspended;
+
+int wakeup_ddr_fc_seq(void)
+{
+	if (atomic_read(&dfc_trigger)) {
+		if (cur_freq != target_freq) {
+			if (!atomic_read(&ddr_dfc_disabled))
+				mmp3_setfreq(MMP3_CLK_DDR_1, target_freq);
+			cur_freq = mmp3_getfreq(MMP3_CLK_DDR_1);
+		}
+		complete(&vsync_complete);
+	}
+
+	return 0;
+}
+
+void disable_ddr_devfreq(int disable)
+{
+	mutex_lock(&disable_ddr_lock);
+	if (disable == 1)
+		atomic_add(1, &ddr_dfc_disabled);
+	/* disable must be called first */
+	else if (readl(&ddr_dfc_disabled) > 0)
+		atomic_sub(1, &ddr_dfc_disabled);
+	mutex_unlock(&disable_ddr_lock);
+}
+
+static int clk_ddr_setrate(struct clk *clk, unsigned long val)
+{
+	int i;
+
+	val /= 1000;
+
+	for (i = 0; mmp3_ddr_freq_table[i+1].frequency != DEVFREQ_TABLE_END;
+		i++)
+		if (mmp3_ddr_freq_table[i].frequency >= val) break;
+	target_freq = mmp3_ddr_freq_table[i].frequency;
+	atomic_set(&dfc_trigger, 1);
+	if (atomic_read(&mmp3_fb_is_suspended))
+		wakeup_ddr_fc_seq();
+	wait_for_completion_timeout(&vsync_complete, msecs_to_jiffies(50));
+	atomic_set(&dfc_trigger, 0);
+
+	return 0;
+}
+
+static unsigned long clk_ddr_getrate(struct clk *clk)
+{
+	return mmp3_getfreq(MMP3_CLK_DDR_1) * 1000;
+}
+
+static struct clkops clk_ddr_ops = {
+	.setrate = clk_ddr_setrate,
+	.getrate = clk_ddr_getrate,
+};
+
+static struct clk mmp3_clk_ddr = {
+	.name = "ddr",
+	.ops = &clk_ddr_ops,
+	.dynamic_change = 1,
+};
+#endif
+
+static struct devfreq_frequency_table mmp3_gc_clk_table[] = {
+	INIT_FREQ_TABLE(1, 100000000),
+	INIT_FREQ_TABLE(2, 200000000),
+	INIT_FREQ_TABLE(3, 355000000),
+	INIT_FREQ_TABLE(4, 400000000),
+	INIT_FREQ_TABLE(5, 533000000),
+	INIT_FREQ_TABLE(6, DEVFREQ_TABLE_END),
+};
+
+static int devfreq_reboot_notifier_call(struct notifier_block *this,
+                                       unsigned long code, void *_cmd)
+{
+#ifdef CONFIG_DDR_DEVFREQ
+       disable_ddr_devfreq(1);
+#endif
+
+       return NOTIFY_DONE;
+}
+
+
+static struct notifier_block devfreq_reboot_notifier = {
+       .notifier_call = devfreq_reboot_notifier_call,
+};
+
+#define GC2D_CLK_DIV(n)		((n & 0xF) << 28)
+#define GC2D_CLK_DIV_MSK	GC2D_CLK_DIV(0xF)
+#define GC2D_CLK_SRC_SEL(n)	((n & 3) << 12)
+#define GC2D_CLK_SRC_SEL_MSK	GC2D_CLK_SRC_SEL(3)
+#define GC2D_AXICLK_EN		(1u << 19)
+
+#define GC3D_CLK_DIV(n)		((n & 0xF) << 24)
+#define GC3D_CLK_DIV_MSK	GC3D_CLK_DIV(0xF)
+#define GC3D_CLK_SRC_SEL(n)	((n & 3) << 6)
+#define GC3D_CLK_SRC_SEL_MSK	GC3D_CLK_SRC_SEL(3)
+#define GC3D_ACLK_SEL(n)	((n & 3) << 4)
+#define GC3D_ACLK_SEL_MSK	GC3D_ACLK_SEL(3)
+#define GC3D_AXICLK_EN		(1u << 2)
+
+#define GC2D3D_CLK_EN		(1u << 3)
+#define GC2D_CLK_EN		(1u << 20)
+
+#define GC_PWRUP(n)		((n & 3) << 9)
+#define GC_PWRUP_MSK		GC_PWRUP(3)
+#define GC_ISB			(1u << 8)
+
+#define GC_CLK_RATE(div, src, aclk)				\
+	(GC2D_CLK_DIV(div) | GC2D_CLK_SRC_SEL(src)		\
+	| GC3D_CLK_DIV(div) | GC3D_CLK_SRC_SEL(src)		\
+	| GC3D_ACLK_SEL(aclk))
+
+#define GC_CLK_RATE_MSK						\
+	(GC2D_CLK_DIV_MSK | GC2D_CLK_SRC_SEL_MSK		\
+	| GC3D_CLK_DIV_MSK | GC3D_CLK_SRC_SEL_MSK		\
+	| GC3D_ACLK_SEL_MSK)
+
+#define		CS_PLL1		0
+#define		CS_PLL2		1
+#define		CS_PLL1_COP	2
+#define		CS_PLL2_COP	3
+#define		PLL1D4		0
+#define		PLL1D6		1
+#define		PLL1D2		2
+#define		PLL2D2		3
+
+
+
+#define GC_SET_BITS(set, clear)	{\
+	unsigned long tmp;\
+	tmp = __raw_readl(clk->clk_rst);\
+	tmp &= ~(clear);\
+	tmp |= set;\
+	__raw_writel(tmp, clk->clk_rst);\
+}
+
+#ifdef CONFIG_DDR_DEVFREQ
+struct pm_qos_request_list gc_qos_ddrfreq_min;
+#endif
+static struct delayed_work gc_idle_work;
+static bool gc_force_high_rate = false;
+static void gc_set_constraint(struct work_struct *work)
+{
+	gc_force_high_rate = true;
+#ifdef CONFIG_DDR_DEVFREQ
+	pm_qos_update_request(&gc_qos_ddrfreq_min, PM_QOS_DEFAULT_VALUE);
+#endif
+}
+
+static void gc_clk_init(struct clk *clk)
+{
+	clk->rate = clk_get_rate(&mmp3_clk_pll1_clkoutp) / 2;
+	clk->enable_val = PLL1D2; /* reuse this field for the ACLK setting */
+	clk->div = 2;
+	clk->mul = 1;
+	clk->dynamic_change = 1;
+	clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	INIT_DELAYED_WORK(&gc_idle_work, gc_set_constraint);
+	gc_force_high_rate = true;
+#ifdef CONFIG_DDR_DEVFREQ
+	pm_qos_add_request(&gc_qos_ddrfreq_min, PM_QOS_DDR_DEVFREQ_MIN,
+		PM_QOS_DEFAULT_VALUE);
+#endif
+}
+
+static int gc_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long rate1 = rate;
+	if (gc_force_high_rate == true)
+		rate1 = 533333333;
+
+	clk->mul = 1;
+	if (rate1 == clk_get_rate(&mmp3_clk_pll1)/8) {
+		clk->enable_val = PLL1D6;
+		clk->div = 8;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll1)/4) {
+		clk->enable_val = PLL1D4;
+		clk->div = 4;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll1_clkoutp)/3) {
+		clk->enable_val = PLL1D2;
+		clk->div = 3;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll2_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2_clkoutp);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll1_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll2)/2) {
+		clk->enable_val = PLL2D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else if (rate1 == clk_get_rate(&mmp3_clk_pll1)) {
+		clk->enable_val = PLL1D2;
+		clk->div = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected gc clock rate %ld\n", __func__, rate1);
+		BUG();
+	}
+
+	return 0;
+}
+
+static int gc_clk_enable(struct clk *clk)
+{
+	unsigned long gc_rate_cfg;
+	unsigned long i;
+
+	/* TODO may need to request for different core voltage according to
+	 * different gc clock rate.
+	 */
+	cancel_delayed_work_sync(&gc_idle_work);
+#ifdef CONFIG_DDR_DEVFREQ
+	pm_qos_update_request(&gc_qos_ddrfreq_min, DDR_CONSTRAINT_LVL1);
+#endif
+
+	if (gc_force_high_rate == true)
+		gc_clk_setrate(clk, 533333333);
+	gc_force_high_rate = false;
+
+	i = 0;
+	while ((clk->inputs[i].input != clk->parent) && clk->inputs[i].input)
+		i++;
+
+	if (clk->inputs[i].input == 0) {
+		pr_err("%s: unexpected gc clock source\n", __func__);
+		return -1;
+	}
+
+	gc_rate_cfg = GC_CLK_RATE(clk->div,
+		clk->inputs[i].value, clk->enable_val);
+	gc_rate_cfg &= GC_CLK_RATE_MSK;
+
+	GC_SET_BITS(gc_rate_cfg, GC_CLK_RATE_MSK);
+	GC_SET_BITS(GC2D_CLK_EN | GC2D3D_CLK_EN | GC2D_AXICLK_EN\
+			| GC3D_AXICLK_EN, 0);
+
+	return 0;
+}
+
+static void gc_clk_disable(struct clk *clk)
+{
+	GC_SET_BITS(0, GC2D_AXICLK_EN | GC3D_AXICLK_EN | GC2D3D_CLK_EN\
+			| GC2D_CLK_EN);
+	schedule_delayed_work(&gc_idle_work, 1000);
+/*
+	GC_SET_BITS(0,GC2D3D_CLK_EN | GC2D_CLK_EN);
+	GC_SET_BITS(0, GC2D_AXICLK_EN | GC3D_AXICLK_EN);
+*/
+}
+
+static long gc_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (rate <= clk_get_rate(&mmp3_clk_pll1)/8)
+		return clk_get_rate(&mmp3_clk_pll1)/8; /* 100M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1)/4)
+		return clk_get_rate(&mmp3_clk_pll1)/4; /* 200M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1_clkoutp)/3)
+		return clk_get_rate(&mmp3_clk_pll1_clkoutp)/3; /* 354M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1)/2)
+		return clk_get_rate(&mmp3_clk_pll1)/2; /* 400M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2_clkoutp)/2)
+		return clk_get_rate(&mmp3_clk_pll2_clkoutp)/2; /* 480M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1_clkoutp)/2)
+		return clk_get_rate(&mmp3_clk_pll1_clkoutp)/2; /* 531M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2)/2)
+		return clk_get_rate(&mmp3_clk_pll2)/2; /* 600M */
+	else
+		return clk_get_rate(&mmp3_clk_pll1); /* 800M */
+}
+/*
+static int gc_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	clk->mul = 1;
+	if (rate == clk_get_rate(&mmp3_clk_pll1)/8) {
+		clk->enable_val = PLL1D6;
+		clk->div = 8;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)/4) {
+		clk->enable_val = PLL1D4;
+		clk->div = 4;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1_clkoutp)/3) {
+		clk->enable_val = PLL1D2;
+		clk->div = 3;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2)/2) {
+		clk->enable_val = PLL2D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)) {
+		clk->enable_val = PLL1D2;
+		clk->div = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected gc clock rate %ld\n", __func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+*/
+
+int get_gcu_freqs_table(unsigned long *gcu_freqs_table, unsigned int *item_counts,
+		unsigned int max_item_counts)
+{
+	int i;
+
+	if (max_item_counts < ARRAY_SIZE(mmp3_gc_clk_table)) {
+		pr_err("Too many GC frequencies!\n");
+		return -1;
+	}
+	for (i = 0; (mmp3_gc_clk_table[i].frequency != DEVFREQ_TABLE_END); i++)
+		gcu_freqs_table[i] = mmp3_gc_clk_table[i].frequency;
+	*item_counts = i;
+
+	return 0;
+}
+EXPORT_SYMBOL(get_gcu_freqs_table);
+
+struct clkops gc_clk_ops = {
+	.init		= gc_clk_init,
+	.enable		= gc_clk_enable,
+	.disable	= gc_clk_disable,
+	.setrate	= gc_clk_setrate,
+	.round_rate	= gc_clk_round_rate,
+	.set_parent	= mmp3_clk_set_parent,
+};
+
+static struct clk_mux_sel gc_mux_pll1_pll2[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 1},
+	{.input = &mmp3_clk_pll1_clkoutp, .value = 2},
+	{.input = &mmp3_clk_pll2_clkoutp, .value = 3},
+	{0, 0},
+};
+
+static struct clk mmp3_clk_gc = {
+	.name = "gc",
+	.inputs = gc_mux_pll1_pll2,
+	.lookup = {
+		.con_id = "GCCLK",
+	},
+	.clk_rst = (void __iomem *)APMU_GC,
+	.ops = &gc_clk_ops,
+};
+
+static int disp1_axi_clk_enable(struct clk *clk)
+{
+	u32 val = __raw_readl(clk->clk_rst);
+
+	/* enable Display1 AXI clock */
+	val |= (1<<3);
+	__raw_writel(val, clk->clk_rst);
+
+	/* release from reset */
+	val |= 1 |  (1 << 1);
+	__raw_writel(val, clk->clk_rst);
+	return 0;
+}
+
+static void disp1_axi_clk_disable(struct clk *clk)
+{
+	u32 val = __raw_readl(clk->clk_rst);
+
+	/*
+	 * disable display1 AXI clock:
+	 * In MMP3 A0, display1 AXI clock enable and reset
+	 * are connected opposite at the bus clock module,
+	 * so on A0, bit[0]: control axi clock enable/disable;
+	 * bit[3]: axi clock reset control. From B0, will fix back.
+	 */
+	if (cpu_is_mmp3_a0())
+		val &= ~1;
+	else
+		val &= ~(1<<3);
+	__raw_writel(val, clk->clk_rst);
+}
+
+struct clkops disp1_axi_clk_ops = {
+	.enable		= disp1_axi_clk_enable,
+	.disable	= disp1_axi_clk_disable,
+};
+
+static struct clk mmp3_clk_disp1_axi = {
+	.name = "disp1_axi",
+	.lookup = {
+		.con_id = "DISP1AXI",
+	},
+	.clk_rst = (void __iomem *)APMU_LCD_CLK_RES_CTRL,
+	.ops = &disp1_axi_clk_ops,
+};
+
+static int disp1_clk_enable(struct clk *clk)
+{
+	u32 val;
+
+	val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* enable Display1 peripheral clock */
+	val |= (1 << 4);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* release from reset */
+	val |= (1 << 1);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	return 0;
+}
+
+static void disp1_clk_disable(struct clk *clk)
+{
+	u32 val;
+
+	val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* disable Display1 peripheral clock */
+	val &= ~(1<<4);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+}
+
+static long disp1_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/*
+	 * disp1 clock actually has four clock source: pll1, pll1/16, pll2
+	 * and vctcxo.The range of the divider is 1 to 15.
+	 * here the policy is try to not use pll2 as possile as it can.
+	 * since the divider can be as large as 15 so it don't need pll1/16
+	 * as the clock source. For the very low rate requirement, we can
+	 * just use vctcxo as the clock source.
+	 */
+	int i;
+	unsigned long parent_rate;
+
+	/* for those which is less than 26M, use vctcxo as clock source */
+	if (rate <= clk_get_rate(&mmp3_clk_vctcxo)) {
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+
+		return parent_rate / (i - 1);
+	/* for those which is less than 800M, use pll1 as clock source */
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll1)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+
+		return parent_rate / (i - 1);
+	/* for those which is larger than 800M, use pll2 as clock source */
+	} else
+		return clk_get_rate(&mmp3_clk_pll2);
+}
+
+static int disp1_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long parent_rate;
+	const struct clk_mux_sel *sel;
+	u32 val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+
+	if (rate <= clk_get_rate(&mmp3_clk_vctcxo)) {
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_vctcxo);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_vctcxo)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("lcd: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll1)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll1);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll1)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("lcd: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll2)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll2);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll2);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll2)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("lcd: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	}
+
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	return 0;
+}
+
+struct clkops disp1_clk_ops = {
+	.enable = disp1_clk_enable,
+	.disable = disp1_clk_disable,
+	.round_rate = disp1_clk_round_rate,
+	.setrate = disp1_clk_setrate,
+};
+
+static struct clk_mux_sel disp1_clk_mux[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 2},
+	{.input = &mmp3_clk_vctcxo, .value = 3},
+	{0, 0},
+};
+
+/* Disp1 clock can be one of the source for lcd */
+static struct clk mmp3_clk_disp1 = {
+	.name = "disp1",
+	.lookup = {
+		.con_id = "DISP1_CLK",
+	},
+	.ops = &disp1_clk_ops,
+	.inputs = disp1_clk_mux,
+	.reg_data = {
+		     { {APMU_LCD_CLK_RES_CTRL, 6, 0x3},
+			{APMU_LCD_CLK_RES_CTRL, 6, 0x3} },
+		     {{APMU_LCD_CLK_RES_CTRL, 8, 0xf},
+			{APMU_LCD_CLK_RES_CTRL, 8, 0xf} } },
+};
+
+static struct clk *disp_depend_clk[] = {
+	&mmp3_clk_disp1_axi,
+	&mmp3_clk_disp1,
+};
+
+#define LCD_PN1_DSI_PHYSLOW_PRER	0x1A
+#define LCD_PN1_DSI_PHYSLOW_PRER_SHIFT	15
+#define LCD_PN1_DSI_PHYSLOW_PRER_MASK	0x1F
+
+static int lcd_pn1_clk_enable(struct clk *clk)
+{
+	u32 val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+
+	if (clk->parent == &mmp3_clk_vctcxo) {
+		/* enable DSI PHY ESC/SLOW clock */
+		val |= (1 << 12) | (1 << 5);
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+		/* use fixed prescaler for DSI PHY slow clock */
+		val &= ~(LCD_PN1_DSI_PHYSLOW_PRER_MASK <<
+			LCD_PN1_DSI_PHYSLOW_PRER_SHIFT);
+		val |= (LCD_PN1_DSI_PHYSLOW_PRER <<
+				LCD_PN1_DSI_PHYSLOW_PRER_SHIFT);
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+		/* release DSI PHY SLOW clock from reset */
+		val |= (1 << 2);
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+		/*
+		 * Here we fix the lcd clock souce as DSI PLL(PLL3). Because it
+		 * provides a more flexible clocking options for the DSI interface
+		 * which has very peculiar frequency requirements driven by the
+		 * display panel parameters. So enable the pll3 clk here.
+		 */
+		mmp3_clk_pll3_enable(clk);
+	} else if (clk->parent == &mmp3_clk_pll1) {
+		/* select PLL1 as clock source and disable unused clocks */
+		val &= ~((3 << 6) | (1 << 12) | (1 << 5) | (1 << 2));
+		/* divider select 1 */
+		val &= ~(3 << 8);
+		val |= 1 << 8;
+
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+	} else if (clk->parent == &mmp3_clk_pll2) {
+		/* select PLL2 as clock source and disable unused clocks */
+		val &= ~((3 << 6) | (1 << 12) | (1 << 5) | (1 << 2));
+		/* divider select 1 */
+		val &= ~(3 << 8);
+		val |= 1 << 8;
+		val |= 2 << 6;
+
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+	} else {
+		pr_err("%s clk->parent not inited\n", __func__);
+		return -EAGAIN;
+	}
+
+	/* release from reset */
+	val |= (1 << 1);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	pr_info("%s PMUA_DISPLAY1 = 0x%x, clk from %s", __func__, val,
+		(clk->parent == &mmp3_clk_pll2) ?  "pll2" : "pll1");
+
+	return 0;
+}
+
+static void lcd_pn1_clk_disable(struct clk *clk)
+{
+	u32 val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+
+	if (clk->parent == &mmp3_clk_vctcxo) {
+		/* lcd clock source is fixed as DSI PLL(PLL3), so disable pll3 clk */
+		mmp3_clk_pll3_disable(clk);
+
+		/* disable DSI clock */
+		val &= ~((1<<12) | (1<<5));
+		__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	}
+	pr_info("%s PMUA_DISPLAY1 = 0x%x, clk from %s", __func__, val,
+		(clk->parent == &mmp3_clk_pll2) ?  "pll2" : "pll1");
+}
+
+static long lcd_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	switch (rate) {
+	case 800000000:
+		clk_reparent(clk, &mmp3_clk_pll1);
+		break;
+	case 1200000000:
+		clk_reparent(clk, &mmp3_clk_pll2);
+		break;
+	default:
+		clk_reparent(clk, &mmp3_clk_vctcxo);
+		if (clk->dependence_count > 1)
+			/* remove depend clk disp1 */
+			clk->dependence_count--;
+		rate = mmp3_clk_pll3_round_rate(clk, rate);
+		break;
+	}
+	pr_debug("%s line %d rate %lu\n\n", __func__, __LINE__, rate);
+
+	return rate;
+}
+
+static int lcd_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	int ret = 0;
+
+	switch (rate) {
+	case 800000000:
+		break;
+	case 1200000000:
+		break;
+	default:
+		/* lcd clock source is fixed as DSI PLL(PLL3), so set pll3 clk rate */
+		ret = mmp3_clk_pll3_setrate(clk, rate);
+		break;
+	}
+	pr_debug("%s line %d rate %lu\n\n", __func__, __LINE__, rate);
+
+	return ret;
+}
+
+struct clkops lcd_pn1_clk_ops = {
+	.enable = lcd_pn1_clk_enable,
+	.disable = lcd_pn1_clk_disable,
+	.round_rate = lcd_clk_round_rate,
+	.setrate = lcd_clk_setrate,
+};
+
+static struct clk_mux_sel lcd_pn1_clk_mux[] = {
+	{.input = &mmp3_clk_vctcxo, 0},
+	{0, 0},
+};
+
+/*
+ * lcd clk actually has five clock souce: axi, display 1,
+ * display 2, HDMI PLL and DSI PLL(PLL3). Here we just fix it to be
+ * PLL3 since it provides a more flexible clocking options for the
+ * DSI interface which has very peculiar frequency requirements driven
+ * by the display panel parameters. And PLL3 satisfy the LCD/DSI very well.
+ */
+static struct clk mmp3_clk_lcd1 = {
+	.name = "lcd1",
+	.lookup = {
+		.con_id = "LCDCLK",
+	},
+	.ops = &lcd_pn1_clk_ops,
+	.dependence = disp_depend_clk,
+	.dependence_count = ARRAY_SIZE(disp_depend_clk),
+	.inputs = lcd_pn1_clk_mux,
+	.reg_data = {
+		     {{APMU_LCD_CLK_RES_CTRL, 6, 0x3},
+			{APMU_LCD_CLK_RES_CTRL, 6, 0x3} },
+		     {{APMU_LCD_CLK_RES_CTRL, 8, 0xf},
+			{APMU_LCD_CLK_RES_CTRL, 8, 0xf} } },
+};
+
+static int hdmi_clk_enable(struct clk *clk)
+{
+	/*
+	 * hdmi pll clock enable is done by user space,
+	 * to control it's dependence clock disp1_axi
+	 * here we just enable hdmi ref clock
+	 */
+	u32 val = __raw_readl(clk->clk_rst);
+	val |= (1 << 13);
+	__raw_writel(val, clk->clk_rst);
+	return 0;
+};
+
+static void hdmi_clk_disable(struct clk *clk)
+{
+	/*
+	 * hdmi pll clock disable is done by user space,
+	 * to control it's dependence clock disp1_axi
+	 * here we just enable hdmi ref clock
+	 */
+
+	u32 val = __raw_readl(clk->clk_rst);
+	val &= ~(1 << 13);
+	__raw_writel(val, clk->clk_rst);
+	return;
+};
+
+struct clkops hdmi_clk_ops = {
+	.enable = hdmi_clk_enable,
+	.disable = hdmi_clk_disable,
+};
+
+static struct clk mmp3_clk_hdmi = {
+	.name = "hdmi",
+	.lookup = {
+		.con_id = "HDMICLK",
+	},
+	.clk_rst = (void __iomem *)APMU_LCD_CLK_RES_CTRL,
+	.ops = &hdmi_clk_ops,
+	.dependence = disp_depend_clk,
+	.dependence_count = ARRAY_SIZE(disp_depend_clk),
+};
+
+static int thermal_clk_enable(struct clk *clk)
+{
+	uint32_t clk_rst, i;
+	ulong inc[4] = {0, 0x8, 0xc, 0x10};
+	ulong base;
+
+	for (i = 0; i < 4; i ++) {
+		base = (ulong)clk->clk_rst + inc[i];
+		clk_rst = __raw_readl(base);
+		clk_rst |= APBC_FNCLK | APBC_FNCLKSEL(0x0);
+		__raw_writel(clk_rst, base);
+		/*
+		 * delay two cycles of the solwest clock between the APB
+		 * bus clock and the functional module clock.
+		 */
+		udelay(10);
+
+		clk_rst |= APBC_APBCLK;
+		__raw_writel(clk_rst, base);
+		udelay(10);
+
+		clk_rst &= ~(APBC_RST);
+		__raw_writel(clk_rst, base);
+	}
+
+	return 0;
+}
+
+static void thermal_clk_disable(struct clk *clk)
+{
+	int inc[4] = {0, 0x8, 0xc, 0x10}, i;
+
+	for (i = 0; i < 4; i ++)
+		__raw_writel(0, clk->clk_rst + inc[i]);
+	mdelay(1);
+}
+
+struct clkops thermal_clk_ops = {
+	.enable = thermal_clk_enable,
+	.disable = thermal_clk_disable,
+};
+
+static struct clk mmp3_clk_thermal = {
+	.name = "mmp-thermal",
+	.lookup = {
+		.con_id = "THERMALCLK",
+	},
+	.clk_rst = (void __iomem *)APBC_MMP2_THSENS1,
+	.ops = &thermal_clk_ops,
+};
+
+static void sdhc_clk_init(struct clk *clk)
+{
+	const struct clk_mux_sel *sel;
+	u32 val = 0;
+
+	clk->mul = 1;
+	clk->div = 2;
+
+	clk_reparent(clk, &mmp3_clk_pll1_d_4);
+
+	if (!strcmp(clk->name, "sdh0")) {
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+				<< clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+			<< clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll1_d_4)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("sdh: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+				<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	}
+
+	clk->enable_val = val;
+}
+
+static int sdhc_clk_enable(struct clk *clk)
+{
+	u32 val;
+
+	val = clk->enable_val | 0x1b;
+	__raw_writel(val, clk->clk_rst);
+
+	return 0;
+}
+
+static void sdhc_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+}
+
+static long sdhc_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/*
+	 * SDH has four clock source: PLL1, PLL1/2, PLL1/4 and PLL2.
+	 * Here PLL1/2 is not used since PLL1 and PLL1/4 can cover it.
+	 * Only use PLL2 as clock source if the rate is larger than PLL1.
+	 */
+	int i;
+	unsigned long parent_rate;
+
+	/* for those which is less than pll1/4, use pll1/4 as clock source */
+	if (rate <= clk_get_rate(&mmp3_clk_pll1_d_4)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1_d_4);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+
+		return parent_rate / (i - 1);
+	/* else for those which is less than pll1, use pll1 as clock source */
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll1)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+
+		return parent_rate / (i - 1);
+	/* else for those which is larger than pll1, use pll2 as clock source */
+	} else {
+		parent_rate = clk_get_rate(&mmp3_clk_pll2);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+	}
+		return parent_rate / (i - 1);
+}
+
+static int sdhc_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long parent_rate;
+	const struct clk_mux_sel *sel;
+	u32 val = 0;
+
+	if (strcmp(clk->name, "sdh0"))
+		return -ENOSYS;
+
+	if (rate <= clk_get_rate(&mmp3_clk_pll1_d_4)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1_d_4);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll1_d_4);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll1_d_4)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("sdh: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll1)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll1);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll1)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("sdh: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll2)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll2);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll2);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll2)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("sdh: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	}
+
+	clk->enable_val = val;
+
+	return 0;
+}
+
+struct clkops sdhc0_clk_ops = {
+	.init = sdhc_clk_init,
+	.enable = sdhc_clk_enable,
+	.disable = sdhc_clk_disable,
+	.round_rate = sdhc_clk_round_rate,
+	.setrate = sdhc_clk_setrate,
+};
+
+struct clkops sdhc1_4_clk_ops = {
+	.init = sdhc_clk_init,
+	.enable = sdhc_clk_enable,
+	.disable = sdhc_clk_disable,
+	.round_rate = sdhc_clk_round_rate,
+};
+
+static struct clk_mux_sel sdhc_clk_mux[] = {
+	{.input = &mmp3_clk_pll1_d_4, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 1},
+	{.input = &mmp3_clk_pll1, .value = 3},
+	{0, 0},
+};
+
+/*
+ * all sdhx share the same clock which will be enabled when any of sdhx clock
+ * enable is set. but the clock source select and devider ratio is controlled
+ * by sdh0.
+*/
+static struct clk mmp3_clk_sdh0 = {
+	.name = "sdh0",
+	.lookup = {
+		.dev_id = "sdhci-pxa.0",
+		.con_id = "PXA-SDHCLK",
+	},
+	.ops = &sdhc0_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.reg_data = {
+		     { {APMU_SDH0, 8, 0x3},
+			{APMU_SDH0, 8, 0x3} },
+		     {{APMU_SDH0, 10, 0xf},
+			{APMU_SDH0, 10, 0xf} } },
+	.clk_rst = (void __iomem *)APMU_SDH0,
+};
+
+static struct clk mmp3_clk_sdh1 = {
+	.name = "sdh1",
+	.lookup = {
+		.dev_id = "sdhci-pxa.1",
+		.con_id = "PXA-SDHCLK",
+	},
+	.ops = &sdhc1_4_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.clk_rst = (void __iomem *)APMU_SDH1,
+};
+
+static struct clk mmp3_clk_sdh2 = {
+	.name = "sdh2",
+	.lookup = {
+		.dev_id = "sdhci-pxa.2",
+		.con_id = "PXA-SDHCLK",
+	},
+	.ops = &sdhc1_4_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.clk_rst = (void __iomem *)APMU_SDH2,
+};
+
+static struct clk mmp3_clk_sdh3 = {
+	.name = "sdh3",
+	.lookup = {
+		.dev_id = "sdhci-pxa.3",
+		.con_id = "PXA-SDHCLK",
+	},
+	.ops = &sdhc1_4_clk_ops,
+	.inputs = sdhc_clk_mux,
+	.clk_rst = (void __iomem *)APMU_SDH3,
+};
+
+#ifdef CONFIG_MMP3_HSI
+
+#define HSI_PLL1_DIV_2		0
+#define HSI_PLL1			1
+#define HSI_PLL2			2
+
+static void hsi_clk_init(struct clk *clk)
+{
+	/* HSI Clock default value is PLL1/2: 400MHz */
+	clk->rate = clk_get_rate(&mmp3_clk_pll1)/2; /* 400MHz */
+	clk->enable_val = HSI_PLL1;
+	clk->div = 2;
+	clk->mul = 1;
+	clk_reparent(clk, &mmp3_clk_pll1);
+}
+
+static int hsi_clk_enable(struct clk *clk)
+{
+	int reg;
+
+	clk_reparent(clk, clk->inputs[clk->enable_val].input);
+
+	/* Configure HSI Controller Clock */
+	reg = readl(MPMU_HSI_CLK_RES_CTRL);
+	reg &= ~0x3F;
+	reg |= (clk->enable_val);
+	reg |= (clk->div) << 2;
+	writel(reg, MPMU_HSI_CLK_RES_CTRL);
+
+	/* Release HSI Controller Reset */
+	reg = readl(MPMU_HSI_CLK_RES_CTRL);
+	reg |= 0x1 << 7;
+	reg |= 0x1 << 6;
+	writel(reg, MPMU_HSI_CLK_RES_CTRL);
+
+	/* enable APMU HSI bus and release HSI reset */
+	reg = readl(APMU_BUS);
+	reg |= 3 << 14;
+	writel(reg, APMU_BUS);
+
+	mdelay(10);
+
+	return 0;
+}
+
+static void hsi_clk_disable(struct clk *clk)
+{
+	int reg;
+
+	/* Reset HSI Controller */
+	reg = readl(MPMU_HSI_CLK_RES_CTRL);
+	reg &= ~(0x1 << 7);
+	reg &= ~(0x1 << 6);
+	writel(reg, MPMU_HSI_CLK_RES_CTRL);
+}
+
+static long hsi_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (rate <= clk_get_rate(&mmp3_clk_pll1)/4)
+		return clk_get_rate(&mmp3_clk_pll1)/4; /* 200M */
+	else
+		return clk_get_rate(&mmp3_clk_pll1)/2; /* 400M */
+}
+
+static int hsi_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	clk->mul = 1;
+	if (rate == clk_get_rate(&mmp3_clk_pll1)/4) {
+		clk->enable_val = HSI_PLL1_DIV_2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = HSI_PLL1;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected hsi clock rate %ld\n",
+			__func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+
+struct clkops hsi_clk_ops = {
+	.init		= hsi_clk_init,
+	.enable		= hsi_clk_enable,
+	.disable	= hsi_clk_disable,
+	.setrate	= hsi_clk_setrate,
+	.round_rate	= hsi_clk_round_rate,
+};
+
+static struct clk_mux_sel hsi_mux_pll1_pll2[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 1},
+	{0, 0},
+};
+
+static struct clk mmp3_clk_hsi = {
+	.name = "hsiclk",
+	.inputs = hsi_mux_pll1_pll2,
+	.lookup = {
+		.con_id = "hsi-clk",
+	},
+	.clk_rst = (void __iomem *)MPMU_HSI_CLK_RES_CTRL,
+	.ops = &hsi_clk_ops,
+};
+#endif
+#ifdef CONFIG_VIDEO_MVISP
+
+#define DXOISP_PLL1		1
+#define DXOISP_PLL2		2
+
+int mmp3_isp_reset_hw(void *param)
+{
+	int reg;
+
+	param = param;
+
+	reg = readl(APMU_ISPCLK);
+	reg &= ~(0x1 << 1);
+	writel(reg, APMU_ISPCLK);
+	mdelay(20);
+	reg |= 0x1 << 1;
+	writel(reg, APMU_ISPCLK);
+
+	return 0;
+}
+
+static void dxoisp_clk_init(struct clk *clk)
+{
+	clk->rate = clk_get_rate(&mmp3_clk_pll1)/2; /* 400MHz */
+	clk->enable_val = DXOISP_PLL1;
+	clk->div = 2;
+	clk->mul = 1;
+	clk_reparent(clk, &mmp3_clk_pll1);
+}
+
+static int dxoisp_clk_enable(struct clk *clk)
+{
+	int reg;
+
+	/*clock source and clock divider */
+	reg = readl(APMU_ISPCLK);
+	reg &= ~0xF00;
+	reg |= (clk->div) << 8;
+	writel(reg, APMU_ISPCLK);
+	reg &= ~0xC0;
+	reg |= (clk->enable_val) << 6;
+	writel(reg, APMU_ISPCLK);
+
+	/*enable ISP AXI clock*/
+	reg |= 0x1 << 3;
+	writel(reg, APMU_ISPCLK);
+
+	/*enable ISP clk*/
+	reg |= 0x1 << 4;
+	writel(reg, APMU_ISPCLK);
+
+	/*enable CCIC AXI Arbiter clock*/
+	reg = readl(APMU_CCIC_RST);
+	reg |= 0x1 << 15;
+	writel(reg, APMU_CCIC_RST);
+
+	return 0;
+}
+
+static void dxoisp_clk_disable(struct clk *clk)
+{
+	int reg;
+
+	/*disable ccic AXI Arbiter Clock*/
+	reg = readl(APMU_CCIC_RST);
+	reg &= ~(0x1 << 15);
+	writel(reg, APMU_CCIC_RST);
+
+	/*Disable ISP AXI clock*/
+	reg = readl(APMU_ISPCLK);
+	reg &= ~(0x1 << 4);
+	writel(reg, APMU_ISPCLK);
+
+	/*Disable ISP clock*/
+	reg &= ~(0x1 << 3);
+	writel(reg, APMU_ISPCLK);
+}
+
+static long dxoisp_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (rate <= clk_get_rate(&mmp3_clk_pll1)/4)
+		return clk_get_rate(&mmp3_clk_pll1)/4; /* 200M */
+	else
+		return clk_get_rate(&mmp3_clk_pll1)/2; /* 400M */
+}
+
+static int dxoisp_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	clk->mul = 1;
+	if (rate == clk_get_rate(&mmp3_clk_pll1)/4) {
+		clk->enable_val = DXOISP_PLL1;
+		clk->div = 4;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = DXOISP_PLL1;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected dxoisp clock rate %ld\n",
+			__func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+
+struct clkops dxoisp_clk_ops = {
+	.init		= dxoisp_clk_init,
+	.enable		= dxoisp_clk_enable,
+	.disable	= dxoisp_clk_disable,
+	.setrate	= dxoisp_clk_setrate,
+	.round_rate	= dxoisp_clk_round_rate,
+};
+
+static struct clk_mux_sel dxoisp_mux_pll1_pll2[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 1},
+	{0, 0},
+};
+
+static struct clk mmp3_clk_dxoisp = {
+	.name = "dxoisp",
+	.inputs = dxoisp_mux_pll1_pll2,
+	.lookup = {
+		.con_id = "ISP-CLK",
+	},
+	.clk_rst = (void __iomem *)APMU_ISPCLK,
+	.ops = &dxoisp_clk_ops,
+};
+
+#define DXOCCIC_PLL1_DIV2		0
+
+static void dxoccic_clk_init(struct clk *clk)
+{
+	clk->rate = clk_get_rate(&mmp3_clk_pll1)/2; /* 400MHz */
+	clk->enable_val = DXOCCIC_PLL1_DIV2;
+	clk->div = 1;
+	clk->mul = 1;
+	clk_reparent(clk, &mmp3_clk_pll1);
+}
+
+static int dxoccic_clk_enable(struct clk *clk)
+{
+	int reg;
+
+	reg = readl(clk->clk_rst);
+
+	/* Select PLL1/2 as CCIC clock source */
+	reg &= ~(0x3 << 6);
+	reg |= (clk->enable_val) << 6;
+	/* Select CCIC Clock Divider to 1 */
+	reg |= (clk->div) << 17;
+	/* Select PHY SLOW Divider to 26 */
+	reg |= (0x1A << 10);
+	writel(reg, clk->clk_rst);
+
+	/* Enable PHY SLOW clock */
+	reg |= (0x1 << 9);
+	/* Enable PHY clock */
+	reg |= (0x1 << 5);
+	/* Enable CCIC clock */
+	reg |= (0x1 << 4);
+	/* Enable AXI clock */
+	reg |= (0x1 << 3);
+	writel(reg, clk->clk_rst);
+
+	/* Deassert RST for PHY SLOW clock */
+	reg |= (0x1 << 8);
+	/* Deassert RST for PHY clock */
+	reg |= (0x1 << 2);
+	/* Deassert RST for CCIC clock */
+	reg |= (0x1 << 1);
+	/* Deassert RST for AXI clock */
+	reg |= (0x1 << 0);
+	writel(reg, clk->clk_rst);
+
+
+	reg = readl(APMU_CCIC_DBG);
+	reg |= (1 << 25) | (1 << 27);
+	writel(reg, APMU_CCIC_DBG);
+
+	reg = 0xFFFF;
+	writel(reg, APMU_CCIC_GATE);
+
+	return 0;
+}
+
+static void dxoccic_clk_disable(struct clk *clk)
+{
+	int reg;
+
+	reg = readl(APMU_CCIC_GATE);
+	reg &= ~(0xFFFF);
+	writel(reg, APMU_CCIC_GATE);
+
+	reg = readl(APMU_CCIC_DBG);
+	reg &= ~((1 << 25) | (1 << 27));
+	writel(reg, APMU_CCIC_DBG);
+
+	reg = readl(clk->clk_rst);
+	/* Assert RST for PHY SLOW clock */
+	reg &= ~(0x1 << 8);
+	/* Assert RST for PHY clock */
+	reg &= ~(0x1 << 2);
+	/* Assert RST for CCIC clock */
+	reg &= ~(0x1 << 1);
+	/* Assert RST for AXI clock */
+	reg &= ~(0x1 << 0);
+	writel(reg, clk->clk_rst);
+
+	reg = readl(clk->clk_rst);
+	/* Disable PHY SLOW clock */
+	reg &= ~(0x1 << 9);
+	/* Disable PHY clock */
+	reg &= ~(0x1 << 5);
+	/* Disable CCIC clock */
+	reg &= ~(0x1 << 4);
+	/* Disable AXI clock */
+	reg &= ~(0x1 << 3);
+	writel(reg, clk->clk_rst);
+}
+
+static long dxoccic_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk_get_rate(&mmp3_clk_pll1)/2; /* 400M */
+}
+
+static int dxoccic_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	clk->mul = 1;
+	if (rate == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = DXOCCIC_PLL1_DIV2;
+		clk->div = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected dxoccic clock rate %ld\n",
+			__func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+
+struct clkops dxoccic_clk_ops = {
+	.init		= dxoccic_clk_init,
+	.enable		= dxoccic_clk_enable,
+	.disable	= dxoccic_clk_disable,
+	.setrate	= dxoccic_clk_setrate,
+	.round_rate	= dxoccic_clk_round_rate,
+};
+
+static struct clk_mux_sel dxoccic_mux_pll1_pll2[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{0, 0},
+};
+
+static struct clk mmp3_clk_dxoccic = {
+	.name = "dxoccic",
+	.inputs = dxoccic_mux_pll1_pll2,
+	.lookup = {
+		.con_id = "CCIC-CLK",
+	},
+	.clk_rst = (void __iomem *)APMU_CCIC_RST,
+	.ops = &dxoccic_clk_ops,
+};
+#endif
+
+/* Frequency is in unit of Khz*/
+static struct devfreq_frequency_table mmp3_vmeta_clk_table[] = {
+	INIT_FREQ_TABLE(1, 200000),
+	INIT_FREQ_TABLE(2, 266666),
+	INIT_FREQ_TABLE(3, 400000),
+	INIT_FREQ_TABLE(4, 533333),
+	INIT_FREQ_TABLE(5, DEVFREQ_TABLE_END),
+};
+
+int set_vmeta_freqs_table(struct devfreq *devfreq)
+{
+	devfreq_set_freq_table(devfreq, mmp3_vmeta_clk_table);
+	devfreq->max_freq = 533333;	/* max is 533MHz */
+
+	return 0;
+}
+
+#ifdef CONFIG_UIO_VMETA
+
+static void vmeta_clk_init(struct clk *clk)
+{
+	clk->rate = clk_get_rate(&mmp3_clk_pll1_clkoutp) / 2;
+	clk->enable_val = PLL1D2; /* for ACLK setting */
+	clk->div = 2;
+	clk->mul = 1;
+	clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+}
+
+static int vmeta_clk_enable(struct clk *clk)
+{
+	int reg;
+	int i;
+
+	i = 0;
+	while ((clk->inputs[i].input != clk->parent) && clk->inputs[i].input)
+		i++;
+
+	if (clk->inputs[i].input == 0) {
+		pr_err("%s: unexpected vMeta clock source\n", __func__);
+		return -1;
+	}
+
+	reg = readl(clk->clk_rst);
+	/* vMeta clock setting */
+	reg &= ~APMU_VMETA_CLK_SEL_MASK;
+	reg &= ~APMU_VMETA_CLK_DIV_MASK;
+	reg |= (clk->inputs[i].value) << APMU_VMETA_CLK_SEL_SHIFT;
+	reg |= (clk->div) << APMU_VMETA_CLK_DIV_SHIFT;
+	/* vMeta bus clock setting */
+	reg &= ~APMU_VMETA_ACLK_MASK;
+	reg |= (clk->enable_val) << APMU_VMETA_ACLK_SEL_SHIFT;
+	writel(reg, clk->clk_rst);
+
+	reg = readl(clk->clk_rst);
+	reg |= (APMU_VMETA_AXICLK_EN | APMU_VMETA_CLK_EN);
+	writel(reg, clk->clk_rst);
+
+	return 0;
+}
+
+static void vmeta_clk_disable(struct clk *clk)
+{
+	int reg;
+
+	reg = readl(clk->clk_rst);
+	reg &= ~(APMU_VMETA_CLK_EN | APMU_VMETA_AXICLK_EN);
+	writel(reg, clk->clk_rst);
+}
+
+static long vmeta_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (rate <= clk_get_rate(&mmp3_clk_pll1)/4)
+		return clk_get_rate(&mmp3_clk_pll1)/4; /* 200M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1_clkoutp)/4)
+		return clk_get_rate(&mmp3_clk_pll1_clkoutp)/4; /* 266M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1)/2)
+		return clk_get_rate(&mmp3_clk_pll1)/2; /* 400M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2_clkoutp)/2)
+		return clk_get_rate(&mmp3_clk_pll2_clkoutp)/2; /* 480M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1_clkoutp)/2)
+		return clk_get_rate(&mmp3_clk_pll1_clkoutp)/2; /* 533M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2)/2)
+		return clk_get_rate(&mmp3_clk_pll2)/2; /* 600M */
+	else
+		return clk_get_rate(&mmp3_clk_pll1); /* 800M */
+}
+
+static int vmeta_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	clk->mul = 1;
+	if (rate == clk_get_rate(&mmp3_clk_pll1)/4) {
+		clk->enable_val = PLL1D4;
+		clk->div = 4;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1_clkoutp)/4) {
+		clk->enable_val = PLL1D4;
+		clk->div = 4;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1_clkoutp)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll1_clkoutp);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2)/2) {
+		clk->enable_val = PLL1D2;
+		clk->div = 2;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1)) {
+		clk->enable_val = PLL1D2;
+		clk->div = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else {
+		pr_err("%s: unexpected vmeta clock rate %ld\n", __func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+
+static unsigned long vmeta_clk_getrate(struct clk *clk)
+{
+	if (clk->parent && clk->div)
+		return clk_get_rate(clk->parent)/clk->div;
+	else
+		pr_err("%s, get vMeta clock fail\n", __func__);
+	return -EINVAL;
+}
+
+struct clkops vmeta_clk_ops = {
+	.init		= vmeta_clk_init,
+	.enable		= vmeta_clk_enable,
+	.disable	= vmeta_clk_disable,
+	.getrate	= vmeta_clk_getrate,
+	.setrate	= vmeta_clk_setrate,
+	.round_rate	= vmeta_clk_round_rate,
+};
+
+static struct clk_mux_sel vmeta_mux_pll1_pll2[] = {
+	{.input = &mmp3_clk_pll1, .value = 0},
+	{.input = &mmp3_clk_pll2, .value = 1},
+	{.input = &mmp3_clk_pll1_clkoutp, .value = 2},
+	{.input = &mmp3_clk_pll2_clkoutp, .value = 3},
+	{0, 0},
+};
+
+static struct clk mmp3_clk_vmeta = {
+	.name = "vmeta",
+	.inputs = vmeta_mux_pll1_pll2,
+	.lookup = {
+		.con_id = "VMETA_CLK",
+	},
+	.clk_rst = (void __iomem *)APMU_VMETA_CLK_RES_CTRL,
+	.ops = &vmeta_clk_ops,
+	.dynamic_change = 1,
+};
+#endif
+
+static void ccic_clk_init(struct clk *clk)
+{
+	const struct clk_mux_sel *sel;
+	u32 val = 0;
+
+	/* by default select pll1/2 as clock source and divider 1 */
+	clk->mul = 1;
+	clk->div = 1;
+
+	clk_reparent(clk, &mmp3_clk_pll1_d_2);
+
+	val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+		 << clk->reg_data[DIV][CONTROL].reg_shift);
+	val |= clk->div
+	    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+	for (sel = clk->inputs; sel->input != 0; sel++) {
+		if (sel->input == &mmp3_clk_pll1_d_2)
+			break;
+	}
+	if (sel->input == 0) {
+		pr_err("ccic: no matched input for this parent!\n");
+		BUG();
+	}
+
+	val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+		<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+	val |= sel->value
+		<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+
+	/* use fixed value 0x1a for CCIC_PHYSLOW_PRER */
+	clk->enable_val = val | (0x1a << 10);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+}
+
+static int ccic_clk_enable(struct clk *clk)
+{
+	u32 val;
+
+	val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg) & 0x18000;
+	val |= clk->enable_val;
+	/* enable clocks */
+	val |= 0x38;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* release reset */
+	val |= 0x307;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* enable MIPI DPHY CSI2's DVDD and AVDD */
+	val = __raw_readl(APMU_CCIC_DBG);
+	if (strncmp(clk->name, "ccic1", 5) == 0)
+		val |= (1 << 25) | (1 << 27);
+	else
+		val |= (1 << 26) | (1 << 28);
+	__raw_writel(val, APMU_CCIC_DBG);
+
+	return 0;
+}
+
+static void ccic_clk_disable(struct clk *clk)
+{
+	u32 val;
+
+	val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+	val &= 0x18000;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* disable MIPI DPHY CSI2's DVDD and AVDD */
+	val = __raw_readl(APMU_CCIC_DBG);
+	if (strncmp(clk->name, "ccic1", 5) == 0)
+		val &= ~((1 << 25) | (1 << 27));
+	else
+		val &= ~((1 << 26) | (1 << 28));
+	__raw_writel(val, APMU_CCIC_DBG);
+
+}
+
+static long ccic_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/*
+	 * CCIC has four clock source: PLL1/2, PLL1/16, and VCTCXO.
+	 * Here PLL1/16 is not used since PLL1/2 and VCTCXO can cover it.
+	 * Only use PLL1/2 as clock source if the rate is larger than VCTCXO.
+	 */
+	int i;
+	unsigned long parent_rate;
+
+	/* for those which is less than vctcxo, use vctcxo as clock source */
+	if (rate <= clk_get_rate(&mmp3_clk_vctcxo)) {
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+
+		return parent_rate / (i - 1);
+	/* else use pll1/2 as clock source */
+	} else {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1_d_2);
+		for (i = 2; i < 16; i++) {
+			if (rate > parent_rate / i)
+				break;
+		}
+	}
+		return parent_rate / (i - 1);
+}
+
+static int ccic_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long parent_rate;
+	const struct clk_mux_sel *sel;
+	u32 val = 0;
+
+	if (rate <= clk_get_rate(&mmp3_clk_vctcxo)) {
+		parent_rate = clk_get_rate(&mmp3_clk_vctcxo);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_vctcxo);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_vctcxo)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("ccic: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	} else if (rate <= clk_get_rate(&mmp3_clk_pll1_d_2)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1_d_2);
+		clk->mul = 1;
+		clk->div = parent_rate / rate;
+
+		clk_reparent(clk, &mmp3_clk_pll1_d_2);
+
+		val &= ~(clk->reg_data[DIV][CONTROL].reg_mask
+			 << clk->reg_data[DIV][CONTROL].reg_shift);
+		val |= clk->div
+		    << clk->reg_data[DIV][CONTROL].reg_shift;
+
+		for (sel = clk->inputs; sel->input != 0; sel++) {
+			if (sel->input == &mmp3_clk_pll2)
+				break;
+		}
+		if (sel->input == 0) {
+			pr_err("ccic: no matched input for this parent!\n");
+			BUG();
+		}
+
+		val &= ~(clk->reg_data[SOURCE][CONTROL].reg_mask
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift);
+		val |= sel->value
+			<< clk->reg_data[SOURCE][CONTROL].reg_shift;
+	}
+
+	/* use fixed value 0x1a for CCIC_PHYSLOW_PRER */
+	clk->enable_val = val | (0x1a << 10);
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	return 0;
+}
+
+
+struct clkops ccic_clk_ops = {
+	.init = ccic_clk_init,
+	.enable = ccic_clk_enable,
+	.disable = ccic_clk_disable,
+	.round_rate = ccic_clk_round_rate,
+	.setrate = ccic_clk_setrate,
+};
+
+static struct clk_mux_sel ccic_clk_mux[] = {
+	{.input = &mmp3_clk_pll1_d_2, .value = 0},
+	{.input = &mmp3_clk_vctcxo, .value = 2},
+	{0, 0},
+};
+
+static int ccic_share_clk_enable(struct clk *clk)
+{
+	u32 val;
+
+	/* ccic axi enable clocks */
+	val = 0x10000;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	/* ccic axi clock release reset */
+	val |= 0x8000;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+
+	return 0;
+}
+
+static void ccic_share_clk_disable(struct clk *clk)
+{
+	u32 val;
+
+	val = __raw_readl(clk->reg_data[SOURCE][CONTROL].reg);
+	val &= ~0x18000;
+	__raw_writel(val, clk->reg_data[SOURCE][CONTROL].reg);
+}
+
+struct clkops ccic_share_clk_ops = {
+	.init = NULL,
+	.enable = ccic_share_clk_enable,
+	.disable = ccic_share_clk_disable,
+	.round_rate = NULL,
+	.setrate = NULL,
+};
+
+static struct clk mmp3_clk_ccic0 = {
+	.name = "ccic0",
+	.ops = &ccic_share_clk_ops,
+	.inputs = ccic_clk_mux,
+	.reg_data = {
+		     { {APMU_CCIC_RST, 6, 0x3},
+			{APMU_CCIC_RST, 6, 0x3} },
+		     {{APMU_CCIC_RST, 17, 0xf},
+			{APMU_CCIC_RST, 17, 0xf} } },
+};
+
+static struct clk *ccic_depend_clk[] = {
+	&mmp3_clk_ccic0,
+};
+
+static struct clk mmp3_clk_ccic1 = {
+	.name = "ccic1",
+	.lookup = {
+		.dev_id = "mv-camera.0",
+		.con_id = "CCICRSTCLK",
+	},
+	.dependence = ccic_depend_clk,
+	.dependence_count = ARRAY_SIZE(ccic_depend_clk),
+	.ops = &ccic_clk_ops,
+	.inputs = ccic_clk_mux,
+	.reg_data = {
+		     { {APMU_CCIC_RST, 6, 0x3},
+			{APMU_CCIC_RST, 6, 0x3} },
+		     {{APMU_CCIC_RST, 17, 0xf},
+			{APMU_CCIC_RST, 17, 0xf} } },
+};
+
+static struct clk mmp3_clk_ccic2 = {
+	.name = "ccic2",
+	.lookup = {
+		.dev_id = "mv-camera.1",
+		.con_id = "CCICRSTCLK",
+	},
+	.dependence = ccic_depend_clk,
+	.dependence_count = ARRAY_SIZE(ccic_depend_clk),
+	.ops = &ccic_clk_ops,
+	.inputs = ccic_clk_mux,
+	.reg_data = {
+		     { {APMU_CCIC2_RST, 6, 0x3},
+			{APMU_CCIC2_RST, 6, 0x3} },
+		     {{APMU_CCIC2_RST, 17, 0xf},
+			{APMU_CCIC2_RST, 17, 0xf} } },
+};
+
+static struct clk *mmp3_clks_ptr[] = {
+	&mmp3_clk_pll1_d_2,
+	&mmp3_clk_pll1,
+	&mmp3_clk_pll2,
+	&mmp3_clk_pll1_clkoutp,
+	&mmp3_clk_pll2_clkoutp,
+	&mmp3_clk_vctcxo,
+	&mmp3_clk_32k,
+	&mmp3_clk_core_root,
+	&mmp3_clk_virtual_pj,
+	&mmp3_clk_mp1,
+	&mmp3_clk_mp2,
+	&mmp3_clk_mm,
+	&mmp3_clk_cpu,
+	&mmp3_clk_aclk,
+	&mmp3_clk_core_periph,
+	&mmp3_clk_atclk,
+	&mmp3_clk_ddr_root,
+	&mmp3_clk_ddr1,
+	&mmp3_clk_ddr2,
+#ifdef CONFIG_DDR_DEVFREQ
+	&mmp3_clk_ddr,
+#endif
+	&mmp3_clk_axi_root,
+	&mmp3_clk_axi1,
+	&mmp3_clk_axi2,
+	&mmp3_clk_pll1_d_4,
+	&mmp3_clk_gc,
+	&mmp3_clk_disp1,
+	&mmp3_clk_lcd1,
+	&mmp3_clk_sdh0,
+	&mmp3_clk_sdh1,
+	&mmp3_clk_sdh2,
+	&mmp3_clk_sdh3,
+	&mmp3_clk_disp1_axi,
+	&mmp3_clk_hdmi,
+	&mmp3_clk_thermal,
+	&mmp3_clk_ccic1,
+	&mmp3_clk_ccic2,
+#ifdef CONFIG_UIO_VMETA
+	&mmp3_clk_vmeta,
+#endif
+#ifdef CONFIG_VIDEO_MVISP
+	&mmp3_clk_dxoisp,
+	&mmp3_clk_dxoccic,
+#endif
+#ifdef CONFIG_MMP3_HSI
+	&mmp3_clk_hsi,
+#endif
+};
+
+static int apbc_clk_enable(struct clk *clk)
+{
+	unsigned long data;
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLKSEL(7));
+	data |= APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(data, clk->clk_rst);
+	/*
+	 * delay two cycles of the solwest clock between the APB bus clock
+	 * and the functional module clock.
+	 */
+	udelay(10);
+
+	data |= APBC_APBCLK;
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	data |= APBC_RST;
+	__raw_writel(data, clk->clk_rst);
+	udelay(100);
+
+	data &= ~APBC_RST;
+	__raw_writel(data, clk->clk_rst);
+	udelay(100);
+	return 0;
+}
+
+static void apbc_clk_disable(struct clk *clk)
+{
+	unsigned long data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLK | APBC_FNCLKSEL(7));
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	data &= ~APBC_APBCLK;
+	__raw_writel(data, clk->clk_rst);
+}
+
+struct clkops apbc_clk_ops = {
+	.enable = apbc_clk_enable,
+	.disable = apbc_clk_disable,
+};
+
+#define APBC_CLK(_name, _dev, _con, _reg, _fnclksel, _rate, _parent)\
+{							\
+	.name = _name,					\
+	.lookup = {					\
+		.dev_id = _dev,				\
+		.con_id = _con,				\
+	},						\
+	.clk_rst = (void __iomem *)APBC_##_reg,		\
+	.fnclksel = _fnclksel,				\
+	.rate = _rate,					\
+	.ops = &apbc_clk_ops,				\
+	.parent = _parent,				\
+}
+
+#define APBC_CLK_OPS(_name, _dev, _con, _reg, _fnclksel, _rate, _parent, _ops)\
+{							\
+	.name = _name,					\
+	.lookup = {					\
+		.dev_id = _dev,				\
+		.con_id = _con,				\
+	},						\
+	.clk_rst = (void __iomem *)APBC_##_reg,		\
+	.fnclksel = _fnclksel,				\
+	.rate = _rate,					\
+	.ops = _ops,					\
+	.parent = _parent,				\
+}
+
+static void uart_clk_init(struct clk *clk)
+{
+	clk->mul = clk->div = 1;
+	/*
+	 * Bit(s) PMUM_SUCCR_RSRV_31_29 reserved
+	 * UART Clock Generation Programmable Divider
+	 * Numerator Value
+	 */
+	clk->reg_data[DIV][CONTROL].reg = MPMU_SUCCR;
+	clk->reg_data[DIV][CONTROL].reg_shift = 16;
+	clk->reg_data[DIV][CONTROL].reg_mask = 0x1fff;
+	/*
+	 * Bit(s) PMUM_SUCCR_RSRV_15_13 reserved
+	 * UART Clock Generation Programmable Divider
+	 * Denominator Value
+	 */
+	clk->reg_data[MUL][CONTROL].reg = MPMU_SUCCR;
+	clk->reg_data[MUL][CONTROL].reg_shift = 0;
+	clk->reg_data[MUL][CONTROL].reg_mask = 0x1fff;
+}
+
+static int uart_clk_enable(struct clk *clk)
+{
+	uint32_t clk_rst;
+
+	clk_rst = __raw_readl(clk->clk_rst);
+	clk_rst |= APBC_FNCLK;
+	__raw_writel(clk_rst, clk->clk_rst);
+	mdelay(1);
+
+	clk_rst |= APBC_APBCLK;
+	__raw_writel(clk_rst, clk->clk_rst);
+	mdelay(1);
+
+	clk_rst &= ~(APBC_RST);
+	__raw_writel(clk_rst, clk->clk_rst);
+
+	if (clk->rate == clk_get_rate(&mmp3_clk_vctcxo)) {
+		/* choose vctcxo */
+		clk_rst = __raw_readl(clk->clk_rst);
+		clk_rst &= ~(APBC_FNCLKSEL(0x7));
+		clk_rst |= APBC_FNCLKSEL(0x1);
+		__raw_writel(clk_rst, clk->clk_rst);
+	} else {
+		/* choose programmable clk */
+		clk_rst = __raw_readl(clk->clk_rst);
+		clk_rst &= ~(APBC_FNCLKSEL(0x7));
+		__raw_writel(clk_rst, clk->clk_rst);
+	}
+
+	return 0;
+}
+
+static void uart_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+	mdelay(1);
+}
+
+static long uart_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long parent_rate;
+
+	if (rate >= clk_get_rate(&mmp3_clk_vctcxo)) {
+		parent_rate = clk_get_rate(&mmp3_clk_pll1_d_4);
+		return parent_rate * 16 / 27 / 2;
+	} else
+		return clk_get_rate(&mmp3_clk_vctcxo);
+}
+
+static int uart_clk_setrate(struct clk *clk, unsigned long val)
+{
+	uint32_t clk_rst;
+
+	if (val == clk_get_rate(&mmp3_clk_vctcxo)) {
+		/* choose vctcxo */
+		clk_rst = __raw_readl(clk->clk_rst);
+		clk_rst &= ~(APBC_FNCLKSEL(0x7));
+		clk_rst |= APBC_FNCLKSEL(0x1);
+		__raw_writel(clk_rst, clk->clk_rst);
+
+		clk->div = clk->mul = 1;
+
+		clk_reparent(clk, &mmp3_clk_vctcxo);
+	} else {
+		/* set m/n for high speed */
+		unsigned int numer = 27;
+		unsigned int denom = 16;
+
+		/*
+		 * n/d = base_clk/(2*out_clk)
+		 * base_clk = 199.33M, out_clk=199.33*16/27/2=59.06M
+		 * buadrate = clk/(16*divisor)
+		 */
+
+		clk_rst = __raw_readl(clk->reg_data[DIV][CONTROL].reg);
+		clk_rst &= ~(clk->reg_data[DIV][CONTROL].reg_mask <<
+				clk->reg_data[DIV][CONTROL].reg_shift);
+		clk_rst |= numer << clk->reg_data[DIV][CONTROL].reg_shift;
+		clk_rst &= ~(clk->reg_data[MUL][CONTROL].reg_mask <<
+				clk->reg_data[MUL][CONTROL].reg_shift);
+		clk_rst |= denom << clk->reg_data[MUL][CONTROL].reg_shift;
+		__raw_writel(clk_rst, clk->reg_data[DIV][CONTROL].reg);
+
+		/* choose programmable clk */
+		clk_rst = __raw_readl(clk->clk_rst);
+		clk_rst &= ~(APBC_FNCLKSEL(0x7));
+		__raw_writel(clk_rst, clk->clk_rst);
+
+		clk->div = numer * 2;
+		clk->mul = denom;
+
+		clk_reparent(clk, &mmp3_clk_pll1_d_4);
+	}
+
+	return 0;
+}
+
+struct clkops uart_clk_ops = {
+	.init = uart_clk_init,
+	.enable = uart_clk_enable,
+	.disable = uart_clk_disable,
+	.round_rate = uart_clk_round_rate,
+	.setrate = uart_clk_setrate,
+};
+
+static void nand_clk_init(struct clk *clk)
+{
+	clk->div = 8;
+	clk->mul = 1;
+
+	/* by default select pll1 as clock source and divider 8 */
+	clk->enable_val = 0x80;
+}
+
+static int nand_clk_enable(struct clk *clk)
+{
+	__raw_writel(clk->enable_val | 0x2d, clk->clk_rst);
+
+	return 0;
+}
+
+static void nand_clk_disable(struct clk *clk)
+{
+	__raw_writel(0x0, clk->clk_rst);
+}
+
+static long nand_clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (rate <= clk_get_rate(&mmp3_clk_vctcxo) / 2)
+		return clk_get_rate(&mmp3_clk_vctcxo) / 2; /* 13M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1) / 12)
+		return clk_get_rate(&mmp3_clk_pll1) / 12; /* 67M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1) / 8)
+		return clk_get_rate(&mmp3_clk_pll1) / 8; /* 100M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2) / 12)
+		return clk_get_rate(&mmp3_clk_pll2) / 12; /* 111M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1) / 6)
+		return clk_get_rate(&mmp3_clk_pll1) / 6; /* 133M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll2) / 8)
+		return clk_get_rate(&mmp3_clk_pll2) / 8; /* 167M */
+	else if (rate <= clk_get_rate(&mmp3_clk_pll1) / 4)
+		return clk_get_rate(&mmp3_clk_pll1) / 4; /* 200M */
+	else
+		return clk_get_rate(&mmp3_clk_pll2) / 6; /* 222M */
+}
+
+static int nand_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	if (rate == clk_get_rate(&mmp3_clk_vctcxo) / 2) {
+		clk->enable_val = 0x1c0;
+		clk->div = 2;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_vctcxo);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1) / 12) {
+		clk->enable_val = 0xc0;
+		clk->div = 12;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1) / 8) {
+		clk->enable_val = 0x80;
+		clk->div = 8;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2) / 12) {
+		clk->enable_val = 0x180;
+		clk->div = 12;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1) / 6) {
+		clk->enable_val = 0x40;
+		clk->div = 6;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2) / 8) {
+		clk->enable_val = 0x140;
+		clk->div = 8;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll1) / 4) {
+		clk->enable_val = 0x0;
+		clk->div = 4;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll1);
+	} else if (rate == clk_get_rate(&mmp3_clk_pll2) / 6) {
+		clk->enable_val = 0x100;
+		clk->div = 6;
+		clk->mul = 1;
+		clk_reparent(clk, &mmp3_clk_pll2);
+	} else {
+		pr_err("%s: unexpected clock rate %ld\n", __func__, rate);
+		BUG();
+	}
+
+	return 0;
+}
+
+struct clkops nand_clk_ops = {
+	.init = nand_clk_init,
+	.enable = nand_clk_enable,
+	.disable = nand_clk_disable,
+	.round_rate = nand_clk_round_rate,
+	.setrate = nand_clk_setrate,
+};
+
+static int apmu_clk_enable(struct clk *clk)
+{
+	__raw_writel(clk->enable_val, clk->clk_rst);
+
+	return 0;
+}
+
+static void apmu_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+}
+
+static int apmu_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	__raw_writel(rate, clk->clk_rst);
+
+	return 0;
+}
+
+struct clkops apmu_clk_ops = {
+	.enable = apmu_clk_enable,
+	.disable = apmu_clk_disable,
+	.setrate = apmu_clk_setrate,
+};
+
+#define APMU_CLK(_name, _dev, _con, _reg, _eval, _rate, _parent)\
+{								\
+	.name = _name,						\
+	.lookup = {						\
+		.dev_id = _dev,					\
+		.con_id = _con,					\
+	},							\
+	.clk_rst = (void __iomem *)APMU_##_reg,			\
+	.enable_val = _eval,					\
+	.rate = _rate,						\
+	.ops = &apmu_clk_ops,					\
+	.parent = _parent,					\
+}
+
+#define APMU_CLK_OPS(_name, _dev, _con, _reg, _eval, _rate, _parent, _ops)\
+{								\
+	.name = _name,						\
+	.lookup = {						\
+		.dev_id = _dev,					\
+		.con_id = _con,					\
+	},							\
+	.clk_rst = (void __iomem *)APMU_##_reg,			\
+	.enable_val = _eval,					\
+	.rate = _rate,						\
+	.parent = _parent,					\
+	.ops = _ops,						\
+}
+
+
+/* usb: hsic clock */
+static int hsic_clk_enable(struct clk *clk)
+{
+	uint32_t clk_rst;
+
+	clk_rst  =  __raw_readl(clk->clk_rst);
+	clk_rst |= 0x1b;
+	__raw_writel(clk_rst, clk->clk_rst);
+
+	return 0;
+}
+
+static void hsic_clk_disable(struct clk *clk)
+{
+	uint32_t clk_rst;
+
+	clk_rst  =  __raw_readl(clk->clk_rst);
+	clk_rst &= ~0x18;
+	__raw_writel(clk_rst, clk->clk_rst);
+}
+
+struct clkops hsic_clk_ops = {
+	.enable		= hsic_clk_enable,
+	.disable	= hsic_clk_disable,
+};
+
+/* fastenet: fastenet clock */
+static int fastenet_clk_enable(struct clk *clk)
+{
+#define PMUA_FASTENET_PHY_CTRL		(8)
+#define	 ETHPHY_PHYCLK_DIV10SEL_N	(1 << 18)
+	uint32_t clk_rst, tmp;
+
+	if (clk->dynamic_change) {
+		clk_rst = tmp = __raw_readl(clk->clk_rst
+			+ PMUA_FASTENET_PHY_CTRL);
+		if (clk->div == 10 && clk->mul == 0
+			&& (clk_rst & ETHPHY_PHYCLK_DIV10SEL_N))
+			clk_rst &= ~ETHPHY_PHYCLK_DIV10SEL_N;
+		if (clk->div == 0 && clk->mul == 10
+			&& !(clk_rst & ETHPHY_PHYCLK_DIV10SEL_N))
+			clk_rst |= ETHPHY_PHYCLK_DIV10SEL_N;
+		if (clk_rst != tmp)
+			__raw_writel(clk_rst,
+				clk->clk_rst + PMUA_FASTENET_PHY_CTRL);
+	} else {
+		clk_rst = __raw_readl(APMU_USBFSIC);
+		/*
+		 * Setting USB_PHY_REFCLK_SEL in PMUA_FSIC3_CLK_RES_CTRL to 0x2.
+		 * This setting will change USB-PHY/FASTENET-PHY/PLL3/HDMI-PLL
+		 */
+		if (!(clk_rst & 0x200))
+			__raw_writel(clk_rst | 0x200, APMU_USBFSIC);
+		clk_rst = 0x18;
+		__raw_writel(clk_rst, clk->clk_rst);
+		udelay(5);
+		clk_rst |= clk->enable_val;
+		__raw_writel(clk_rst, clk->clk_rst);
+	}
+	return 0;
+}
+
+static void fastenet_clk_disable(struct clk *clk)
+{
+	uint32_t clk_rst;
+	if (clk->dynamic_change)
+		return;
+	clk_rst  =  __raw_readl(clk->clk_rst);
+	clk_rst &= ~0x18;
+	__raw_writel(clk_rst, clk->clk_rst);
+}
+
+/* usb: fsic clock */
+static int fsic_clk_enable(struct clk *clk)
+{
+	uint32_t clk_rst;
+	if (mmp_plat_ref_clk == 0x3)
+		clk_rst = 0x1b;
+	else
+		clk_rst = 0xd1b;
+
+	clk->enable_val = clk_rst;
+	__raw_writel(clk_rst, clk->clk_rst);
+
+	return 0;
+}
+
+static void fsic_clk_disable(struct clk *clk)
+{
+	uint32_t clk_rst;
+
+	clk_rst  =  __raw_readl(clk->clk_rst);
+	clk_rst &= ~0x18;
+	__raw_writel(clk_rst, clk->clk_rst);
+}
+
+struct clkops fsic_clk_ops = {
+	.enable		= fsic_clk_enable,
+	.disable	= fsic_clk_disable,
+};
+struct clkops fastenet_clk_ops = {
+	.enable		= fastenet_clk_enable,
+	.disable	= fastenet_clk_disable,
+};
+
+static int pwm_clk_enable(struct clk *clk)
+{
+	struct clk *clk_apb = NULL, *clk_share = NULL;
+	unsigned long data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLKSEL(7));
+	data |= APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(data, clk->clk_rst);
+	/*
+	 * delay two cycles of the solwest clock between the APB bus clock
+	 * and the functional module clock.
+	 */
+	udelay(10);
+
+	/*
+	 * A dependence exists between pwm1 and pwm2.pwm1 can controll its
+	 * apb bus clk independently, while pwm2 apb bus clk is controlled
+	 * by pwm1's. The same relationship exists between pwm3 and pwm4.
+	 */
+	if (!strcmp(clk->name, "pwm1")) {
+		clk_share = clk_get_sys("mmp2-pwm.1", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm2")) {
+		clk_share = clk_get_sys("mmp2-pwm.0", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else if (!strcmp(clk->name, "pwm3")) {
+		clk_share = clk_get_sys("mmp2-pwm.3", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm4")) {
+		clk_share = clk_get_sys("mmp2-pwm.2", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	}
+
+	if ((clk->refcnt + clk_share->refcnt) == 0) {
+		data = __raw_readl(clk_apb->clk_rst);
+		data |= APBC_APBCLK;
+		__raw_writel(data, clk_apb->clk_rst);
+		udelay(10);
+		data = __raw_readl(clk->clk_rst);
+		data &= ~APBC_RST;
+		__raw_writel(data, clk->clk_rst);
+		if (strcmp(clk->name, clk_apb->name)) {
+			data = __raw_readl(clk_apb->clk_rst);
+			data &= ~APBC_RST;
+			__raw_writel(data, clk_apb->clk_rst);
+		}
+	}
+
+	return 0;
+}
+
+static void pwm_clk_disable(struct clk *clk)
+{
+	struct clk *clk_apb = NULL, *clk_share = NULL;
+	unsigned long data;
+
+	data = __raw_readl(clk->clk_rst) & ~(APBC_FNCLK | APBC_FNCLKSEL(7));
+	__raw_writel(data, clk->clk_rst);
+	udelay(10);
+
+	if (!strcmp(clk->name, "pwm1")) {
+		clk_share = clk_get_sys("mmp2-pwm.1", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm2")) {
+		clk_share = clk_get_sys("mmp2-pwm.0", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	} else if (!strcmp(clk->name, "pwm3")) {
+		clk_share = clk_get_sys("mmp2-pwm.3", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk;
+	} else if (!strcmp(clk->name, "pwm4")) {
+		clk_share = clk_get_sys("mmp2-pwm.2", NULL);
+		BUG_ON(IS_ERR(clk_share));
+		clk_apb = clk_share;
+	}
+
+	if ((clk->refcnt + clk_share->refcnt) == 1) {
+		data = __raw_readl(clk_apb->clk_rst);
+		data &= ~APBC_APBCLK;
+		__raw_writel(data, clk_apb->clk_rst);
+	}
+}
+
+struct clkops pwm_clk_ops = {
+	.enable = pwm_clk_enable,
+	.disable = pwm_clk_disable,
+};
+
+static struct clk mmp3_list_clks[] = {
+	APBC_CLK("twsi1", "pxa2xx-i2c.0", NULL, MMP2_TWSI1,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("twsi2", "pxa2xx-i2c.1", NULL, MMP2_TWSI2,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("twsi3", "pxa2xx-i2c.2", NULL, MMP2_TWSI3,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("twsi4", "pxa2xx-i2c.3", NULL, MMP2_TWSI4,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("twsi5", "pxa2xx-i2c.4", NULL, MMP2_TWSI5,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("twsi6", "pxa2xx-i2c.5", NULL, MMP2_TWSI6,
+			0, 26000000, &mmp3_clk_vctcxo),
+	APBC_CLK("keypad", "pxa27x-keypad", NULL, MMP2_KPC,
+			0, 32768, &mmp3_clk_32k),
+
+	APBC_CLK("ssp.1", "mmp-ssp.1", NULL, MMP2_SSP1,
+		0, 6500000, &mmp3_clk_vctcxo),
+	APBC_CLK("ssp.2", "mmp-ssp.2", NULL, MMP2_SSP2,
+		0, 6500000, &mmp3_clk_vctcxo),
+	APBC_CLK("ssp.3", "mmp-ssp.3", NULL, MMP2_SSP3,
+		0, 6500000, &mmp3_clk_vctcxo),
+	APBC_CLK("ssp.4", "mmp-ssp.4", NULL, MMP2_SSP4,
+		0, 6500000, &mmp3_clk_vctcxo),
+	/*
+	 * Bit 7 in APBC_RTC_CLK_RST must be set before enabling
+	 * RTC operations.
+	 */
+	APBC_CLK("rtc", "mmp-rtc", NULL, MMP2_RTC,
+			0x8, 32768, &mmp3_clk_32k),
+
+	APBC_CLK_OPS("pwm1", "mmp2-pwm.0", NULL, MMP2_PWM0,
+			0, 26000000, &mmp3_clk_vctcxo, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm2", "mmp2-pwm.1", NULL, MMP2_PWM1,
+			0, 26000000, &mmp3_clk_vctcxo, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm3", "mmp2-pwm.2", NULL, MMP2_PWM2,
+			0, 26000000, &mmp3_clk_vctcxo, &pwm_clk_ops),
+	APBC_CLK_OPS("pwm4", "mmp2-pwm.3", NULL, MMP2_PWM3,
+			0, 26000000, &mmp3_clk_vctcxo, &pwm_clk_ops),
+	APBC_CLK_OPS("uart1", "pxa2xx-uart.0", NULL, MMP2_UART1,
+			1, 26000000, &mmp3_clk_vctcxo, &uart_clk_ops),
+	APBC_CLK_OPS("uart2", "pxa2xx-uart.1", NULL, MMP2_UART2,
+			1, 26000000, &mmp3_clk_vctcxo, &uart_clk_ops),
+	APBC_CLK_OPS("uart3", "pxa2xx-uart.2", NULL, MMP2_UART3,
+			1, 26000000, &mmp3_clk_vctcxo, &uart_clk_ops),
+	APBC_CLK_OPS("uart4", "pxa2xx-uart.3", NULL, MMP2_UART4,
+			1, 26000000, &mmp3_clk_vctcxo, &uart_clk_ops),
+	APMU_CLK("u2o", NULL, "U2OCLK", USB,
+			0x9, 480000000, NULL),
+	APMU_CLK_OPS("nand", "pxa3xx-nand", NULL, NAND,
+			0xbf, 100000000, &mmp3_clk_pll1, &nand_clk_ops),
+	APMU_CLK_OPS("hsic1", NULL, "HSIC1CLK", USBHSIC1,
+			0x1b, 480000000, NULL, &hsic_clk_ops),
+	APMU_CLK_OPS("hsic2", NULL, "HSIC2CLK", USBHSIC2,
+			0x1b, 480000000, NULL, &hsic_clk_ops),
+	APMU_CLK_OPS("fsic", NULL, "FSICCLK", USBFSIC,
+			0x1b, 480000000, NULL, &fsic_clk_ops),
+	APMU_CLK_OPS("eth", NULL, "MFUCLK", FASTENET,
+			0x1b, 25000000, NULL, &fastenet_clk_ops),
+};
+
+static void mmp3_init_one_clock(struct clk *c)
+{
+	clk_init(c);
+	INIT_LIST_HEAD(&c->shared_bus_list);
+	if (!c->lookup.dev_id && !c->lookup.con_id)
+		c->lookup.con_id = c->name;
+	c->lookup.clk = c;
+	clkdev_add(&c->lookup);
+}
+
+static int __init mmp3_clk_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mmp3_clks_ptr); i++)
+		mmp3_init_one_clock(mmp3_clks_ptr[i]);
+	for (i = 0; i < ARRAY_SIZE(mmp3_list_clks); i++)
+		mmp3_init_one_clock(&mmp3_list_clks[i]);
+
+	register_reboot_notifier(&devfreq_reboot_notifier);
+#ifdef CONFIG_DDR_DEVFREQ
+	clk_set_cansleep(&mmp3_clk_ddr);
+	mutex_init(&disable_ddr_lock);
+#endif
+	clk_set_cansleep(&mmp3_clk_gc);
+	return 0;
+}
+
+core_initcall(mmp3_clk_init);
+
diff --git a/arch/arm/mach-mmp/common.c b/arch/arm/mach-mmp/common.c
index 9292b79..f42d946 100644
--- a/arch/arm/mach-mmp/common.c
+++ b/arch/arm/mach-mmp/common.c
@@ -14,28 +14,94 @@
 
 #include <asm/page.h>
 #include <asm/mach/map.h>
-#include <asm/system_misc.h>
 #include <mach/addr-map.h>
 #include <mach/cputype.h>
 
+#ifdef CONFIG_CPU_MMP2
+#include <mach/mmp2_pm.h>
+#endif
+#ifdef CONFIG_CPU_MMP3
+#include <mach/mmp_audisland.h>
+#endif
+
 #include "common.h"
 
 #define MMP_CHIPID	(AXI_VIRT_BASE + 0x82c00)
+#define MMP_CHIPID_B1	(AXI_VIRT_BASE + 0x82cd4)
+#define MMP_FUSE_95_64	(AXI_VIRT_BASE + 0x1498)
+#define MMP_FUSE_127_96	(AXI_VIRT_BASE + 0x149c)
 
 unsigned int mmp_chip_id;
 EXPORT_SYMBOL(mmp_chip_id);
 
+unsigned int mmp_chip_id_b1;
+EXPORT_SYMBOL(mmp_chip_id_b1);
+
+unsigned int mmp_fuse_id;
+EXPORT_SYMBOL(mmp_fuse_id);
+
+unsigned int mmp_1g_svc;
+EXPORT_SYMBOL(mmp_1g_svc);
+
+int mmp2_platform_version;
+
 static struct map_desc standard_io_desc[] __initdata = {
 	{
 		.pfn		= __phys_to_pfn(APB_PHYS_BASE),
-		.virtual	= (unsigned long)APB_VIRT_BASE,
+		.virtual	= APB_VIRT_BASE,
 		.length		= APB_PHYS_SIZE,
 		.type		= MT_DEVICE,
 	}, {
 		.pfn		= __phys_to_pfn(AXI_PHYS_BASE),
-		.virtual	= (unsigned long)AXI_VIRT_BASE,
+		.virtual	= AXI_VIRT_BASE,
 		.length		= AXI_PHYS_SIZE,
 		.type		= MT_DEVICE,
+#ifdef CONFIG_CPU_MMP2
+	}, {
+		.pfn		= __phys_to_pfn(FC_PHYS_BASE),
+		.virtual	= FC_VIRT_BASE,
+		.length		= FC_PHYS_SIZE,
+		.type		= MT_MEMORY_NONCACHED,
+#endif
+	}, {
+		.pfn		= __phys_to_pfn(DMCU_PHYS_BASE),
+		.virtual	= DMCU_VIRT_BASE,
+		.length		= DMCU_PHYS_SIZE,
+		.type		= MT_DEVICE,
+#ifdef CONFIG_CPU_MMP3
+	}, {
+		.pfn		= __phys_to_pfn(PGU_PHYS_BASE),
+		.virtual	= PGU_VIRT_BASE,
+		.length		= PGU_PHYS_SIZE,
+		.type		= MT_DEVICE,
+	}, {
+		.pfn            = __phys_to_pfn(AUD_PHYS_BASE),
+		.virtual        = AUD_VIRT_BASE,
+		.length         = AUD_PHYS_SIZE,
+		.type           = MT_DEVICE,
+	}, {
+		.pfn            = __phys_to_pfn(AUD_PHYS_BASE2),
+		.virtual        = AUD_VIRT_BASE2,
+		.length         = AUD_PHYS_SIZE2,
+		.type           = MT_DEVICE,
+	}, {
+		.pfn            = __phys_to_pfn(TZ_HV_PHYS_BASE),
+		.virtual        = TZ_HV_VIRT_BASE,
+		.length         = TZ_HV_PHYS_SIZE,
+		.type           = MT_MEMORY_NONCACHED,
+	}, {
+		.pfn		= __phys_to_pfn(SRAM_PHYS_BASE),
+		.virtual	= (unsigned long)SRAM_VIRT_BASE,
+		.length		= SRAM_PHYS_SIZE,
+		.type		= MT_DEVICE,
+#endif
+#ifdef CONFIG_CPU_PXA988
+	}, {
+		.pfn		= __phys_to_pfn(SCU_PHYS_BASE),
+		.virtual	= SCU_VIRT_BASE,
+		.length		= SCU_PHYS_SIZE,
+		.type		= MT_DEVICE,
+#endif
 	},
 };
 
@@ -45,9 +111,10 @@ void __init mmp_map_io(void)
 
 	/* this is early, initialize mmp_chip_id here */
 	mmp_chip_id = __raw_readl(MMP_CHIPID);
-}
-
-void mmp_restart(char mode, const char *cmd)
-{
-	soft_restart(0);
+	mmp_chip_id_b1 = __raw_readl(MMP_CHIPID_B1);
+#ifdef CONFIG_CPU_PXA910
+	mmp_fuse_id = __raw_readl(MMP_FUSE_95_64);
+	mmp_1g_svc = ((__raw_readl(MMP_FUSE_127_96) & 0x00003FFF) << 6)
+			| ((__raw_readl(MMP_FUSE_95_64) & 0xFC000000) >> 26);
+#endif
 }
diff --git a/arch/arm/mach-mmp/common.h b/arch/arm/mach-mmp/common.h
index 1c9d6c1..0d18470 100644
--- a/arch/arm/mach-mmp/common.h
+++ b/arch/arm/mach-mmp/common.h
@@ -1,9 +1,34 @@
+#include <linux/irq.h>
+
 #define ARRAY_AND_SIZE(x)	(x), ARRAY_SIZE(x)
 
+#define TIMER_RATE_32K	32768
+
 struct sys_timer;
 
-extern void timer_init(int irq);
+#ifdef CONFIG_SOC_LOCAL_TIMERS
+extern void timer_init(int irq0, int irq1, int irq2);
+#else
+extern void timer_init(int irq0, int irq1);
+#endif
+
+extern void __init stimer_event_config(int n, int cpu, int irq, int r);
+extern void __init stimer_source_select(int n, int r);
+extern void __init stimer_device_init(unsigned int base);
+
+extern int pxa910_set_wake(struct irq_data *data, unsigned int on);
+extern int mmp3_set_wake(struct irq_data *data, unsigned int on);
+extern int pxa988_set_wake(struct irq_data *data, unsigned int on);
 
 extern void __init icu_init_irq(void);
 extern void __init mmp_map_io(void);
-extern void mmp_restart(char, const char *);
+extern void __init mmp_wakeupgen_init(void);
+
+#ifdef CONFIG_SMP
+extern void __iomem *pxa_scu_base_addr(void);
+#else
+static inline void __iomem *pxa_scu_base_addr(void)
+{
+	return NULL;
+}
+#endif
diff --git a/arch/arm/mach-mmp/cpufreq-mmp3.c b/arch/arm/mach-mmp/cpufreq-mmp3.c
new file mode 100644
index 0000000..19d847c
--- /dev/null
+++ b/arch/arm/mach-mmp/cpufreq-mmp3.c
@@ -0,0 +1,424 @@
+/*
+ * linux/arch/arm/mach-mmp/cpufreq-mmp3.c
+ *
+ * Author:	Raul Xiong <xjian@marvell.com>
+ * Copyright:	(C) 2010 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/reboot.h>
+#include <mach/mmp3_pm.h>
+#include <mach/smp.h>
+#include <mach/mmp_cm.h>
+#include <plat/clock.h>
+#include <linux/pm_qos.h>
+
+static struct pm_qos_request cpufreq_qos_req_min;
+static int cpufreq_disable = 0;
+static int prof_freq_sav_khz = 0;
+#define MHZ_TO_KHZ	1000
+#define KHZ_TO_HZ	1000
+
+/*
+ * Frequency freq_table index must be sequential starting at 0
+ * and frequencies must be ascending
+ */
+#define MAX_CPU_NUM	3
+#define MAX_PP_NUM	8
+
+enum {
+	ONE_CORE_MM	= 0,
+	ONE_CORE_MP1	= 1,
+	TWO_CORES	= 2,
+	THREE_CORES	= 3,
+};
+static int mmp3_core_num;
+
+static struct cpufreq_frequency_table **freq_table;
+static u32 num_cpus;
+static struct clk *cpu_clk;
+
+static int cpu_frequency_index_to_pp_index[MAX_CPU_NUM][MAX_PP_NUM];
+static DEFINE_MUTEX(mmp3_cpu_lock);
+static int freq_notify_and_change(unsigned int cpu_idx, unsigned int pp_index);
+
+static int mmp3_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+				     policy->cpuinfo.max_freq);
+	return 0;
+}
+
+static unsigned int mmp3_cpufreq_get(unsigned int cpu)
+{
+	int clk_pp_khz = 0;
+	int clk_raw_khz;
+	int delta, i;
+
+	if (cpu >= num_cpus)
+		return -EINVAL;
+	clk_raw_khz = mmp3_get_core_clk(MMP3_CLK_MP1) / KHZ_TO_HZ;
+	for (i = 0; i < mmp3_get_pp_number(); i++) {
+		clk_pp_khz = mmp3_get_pp_freq(i, cpu);
+		delta = clk_pp_khz / 10;
+		if (clk_raw_khz > (clk_pp_khz - delta) &&
+			clk_raw_khz < (clk_pp_khz + delta))
+			break;
+	}
+	return clk_pp_khz;
+}
+
+static int mmp3_cpufreq_target(struct cpufreq_policy *policy,
+			       unsigned int target_freq, unsigned int relation)
+{
+	int index, i;
+	int prof_freq_khz, qos_freq_khz, freq_khz;
+	int ret = 0;
+
+	mutex_lock(&mmp3_cpu_lock);
+
+	if (cpufreq_disable)
+		goto out;
+	if (cpufreq_frequency_table_target(policy, freq_table[policy->cpu],
+					   target_freq, relation, &index)) {
+		pr_err("cpufreq: invalid target_freq: %d\n", target_freq);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (policy->cur == freq_table[policy->cpu][index].frequency)
+		goto out;
+
+	/* FIXME: always use MP1 core as the index to do FC */
+	prof_freq_khz = mmp3_get_pp_freq(index, MMP3_CLK_MP1);
+	qos_freq_khz = pm_qos_request(PM_QOS_CPUFREQ_MIN) * MHZ_TO_KHZ;
+	qos_freq_khz = min(qos_freq_khz, (int)mmp3_get_pp_freq(mmp3_get_pp_number() - 1, MMP3_CLK_MP1));
+	freq_khz = max(prof_freq_khz, qos_freq_khz);
+	prof_freq_sav_khz = prof_freq_khz;
+
+	for (i = 0; i < mmp3_get_pp_number(); i++)
+		if (mmp3_get_pp_freq(i, MMP3_CLK_MP1) >= freq_khz) {
+			freq_notify_and_change(0, i);
+			break;
+		}
+out:
+	mutex_unlock(&mmp3_cpu_lock);
+	return ret;
+}
+
+static unsigned int axi_freq[] = {
+#ifdef MMP3_TEST_PP
+	50000,		/* core 26 or 25Mhz, axi 50/50Mhz */
+	100000,		/* core 50Mhz,  axi 100/100Mhz */
+#endif
+	100000,		/* core 100Mhz, axi 100/100Mhz */
+	200000,		/* core 200Mhz, axi 200/100Mhz */
+	400000,		/* core 400Mhz, axi 400/200Mhz */
+	400000,		/* core 800Mhz, axi 400/200Mhz */
+	400000,		/* core 1Ghz,   axi 400/200Mhz */
+#if	defined(MMP3_TEST_PP_2GHZ)
+	400000,		/* core 1.2Ghz, axi 400/200Mhz */
+#endif
+};
+
+static int freq_notify_and_change(unsigned int cpu_idx, unsigned int pp_index)
+{
+	int cpu;
+	struct cpufreq_freqs freqs;
+	unsigned int cfreq, afreq;
+	int ret = 0;
+
+	BUG_ON(ARRAY_SIZE(axi_freq) <= pp_index);
+
+	/* FIXME: always use MP1 core as the index to do FC */
+	cfreq = mmp3_get_pp_freq(pp_index, MMP3_CLK_MP1);
+	afreq = axi_freq[pp_index];
+
+	freqs.cpu = cpu_idx;
+	freqs.old = mmp3_cpufreq_get(cpu_idx);
+	freqs.new = cfreq;
+
+	if (freqs.old == freqs.new)
+		return ret;
+
+	for_each_online_cpu(cpu)
+		cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	clk_set_rate(cpu_clk, cfreq);
+	mmp3_setfreq(MMP3_CLK_AXI_1, afreq);
+
+	freqs.new = mmp3_cpufreq_get(cpu_idx);
+	for_each_online_cpu(cpu)
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return ret;
+}
+
+static int cpufreq_min_notify(struct notifier_block *b,
+				unsigned long min_mhz, void *v)
+{
+	int i, min_khz, freq_khz;
+	mutex_lock(&mmp3_cpu_lock);
+
+	/* FIXME: always use MP1 core as the index to do FC */
+	min_khz = min_mhz * MHZ_TO_KHZ;
+	min_khz = min(min_khz, (int)mmp3_get_pp_freq(mmp3_get_pp_number() - 1, MMP3_CLK_MP1));
+
+	freq_khz = max(min_khz, prof_freq_sav_khz);
+	for (i = 0; i < mmp3_get_pp_number(); i++) {
+		if (mmp3_get_pp_freq(i, MMP3_CLK_MP1) >= freq_khz) {
+			freq_notify_and_change(0, i);
+			break;
+		}
+	}
+
+	mutex_unlock(&mmp3_cpu_lock);
+	return NOTIFY_OK;
+}
+
+static int cpufreq_disable_notify(struct notifier_block *b,
+				unsigned long disable, void *v)
+{
+	int i;
+	int qos_freq_khz, freq_khz;
+
+	mutex_lock(&mmp3_cpu_lock);
+	cpufreq_disable = disable;
+
+	/* FIXME: always use MP1 core as the index to do FC */
+	if (!cpufreq_disable) {
+		qos_freq_khz = pm_qos_request(PM_QOS_CPUFREQ_MIN) * MHZ_TO_KHZ;
+		qos_freq_khz = min(qos_freq_khz, (int)mmp3_get_pp_freq(mmp3_get_pp_number() - 1, MMP3_CLK_MP1));
+
+		freq_khz = max(qos_freq_khz, prof_freq_sav_khz);
+		for (i = 0; i < mmp3_get_pp_number(); i++) {
+			if (mmp3_get_pp_freq(i, MMP3_CLK_MP1) >= freq_khz) {
+				freq_notify_and_change(0, i);
+				break;
+			}
+		}
+	}
+
+	mutex_unlock(&mmp3_cpu_lock);
+	return NOTIFY_OK;
+}
+
+static int cpufreq_reboot_notifier_call(struct notifier_block *this,
+                                       unsigned long code, void *_cmd)
+{
+       mutex_lock(&mmp3_cpu_lock);
+       pr_err("%s: disabling cpufreq\n", __func__);
+       cpufreq_disable = 1;
+       mutex_unlock(&mmp3_cpu_lock);
+
+       return NOTIFY_DONE;
+}
+
+static struct notifier_block cpufreq_min_notifier = {
+	.notifier_call = cpufreq_min_notify,
+};
+
+static struct notifier_block cpufreq_disable_notifier = {
+	.notifier_call = cpufreq_disable_notify,
+};
+
+static struct notifier_block cpufreq_reboot_notifier = {
+       .notifier_call = cpufreq_reboot_notifier_call,
+};
+
+static int mmp3_cpufreq_init(struct cpufreq_policy *policy)
+{
+	int index;
+
+	cpufreq_frequency_table_cpuinfo(policy, freq_table[policy->cpu]);
+	cpufreq_frequency_table_get_attr(freq_table[policy->cpu], policy->cpu);
+
+	if (!cpu_clk) {
+		cpu_clk = clk_get(NULL, "cpu");
+		if (IS_ERR(cpu_clk))
+			return PTR_ERR(cpu_clk);
+	}
+
+	/* 100us, MMP3 FC takes 50 ~ 70 us*/
+	policy->cpuinfo.transition_latency = 100 * 1000;
+
+	policy->cur = mmp3_cpufreq_get(policy->cpu);
+	if (cpufreq_frequency_table_target(policy, freq_table[policy->cpu],
+				policy->cur, CPUFREQ_RELATION_L, &index)) {
+		pr_err("mmp3_cpufreq_init: invalid freq: %d\n", policy->cur);
+		return -EINVAL;
+	}
+
+        if (!cpu_online(1)) {
+		cpumask_copy(policy->related_cpus, cpu_possible_mask);
+		cpumask_copy(policy->cpus, cpu_online_mask);
+	} else {
+		cpumask_setall(policy->cpus);
+	}
+
+	pr_info("CPUFREQ cpu %d support for mmp3 initialized, cur %d\n",
+		policy->cpu, policy->cur);
+	return 0;
+}
+
+static struct freq_attr *mmp3_cpufreq_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver mmp3_cpufreq_driver = {
+	.name	= "mmp3-cpufreq",
+	.verify	= mmp3_cpufreq_verify,
+	.target	= mmp3_cpufreq_target,
+	.get	= mmp3_cpufreq_get,
+	.init	= mmp3_cpufreq_init,
+	.attr	= mmp3_cpufreq_attr,
+};
+
+static int __init cpufreq_init(void)
+{
+	int freq_table_item_count, i, j, k, core, freq;
+
+	/* add constraint for core morphing */
+	cm_vote_mp1();
+
+	freq_table_item_count = mmp3_get_pp_number();
+	/* FIXME: Here we assume all cores will be on before here! */
+	num_cpus = num_online_cpus();
+
+	freq_table =
+		kzalloc(num_cpus * sizeof(struct cpufreq_frequency_table *),
+			GFP_KERNEL);
+	if (!freq_table)
+		return -ENOMEM;
+
+	for (i = 0; i < num_cpus; i++) {
+		freq_table[i] =
+			kzalloc((freq_table_item_count + 1) *
+				sizeof(struct cpufreq_frequency_table),
+				GFP_KERNEL);
+		if (!freq_table[i])
+			goto _exit;
+	}
+
+	/*
+	 * FIXME:
+	 * this need change when smp process id to real process id
+	 * mapping is changed. We should do frequency table for each core.
+	 * Currently we assume there are three cases: 1. only MP1/2 are active,
+	 * the first core is MP1 and the second core is MP2. 2. Both MM and
+	 * MP1/2 are active, the first core is MM, the second core is MP1 and
+	 * the third core is MP2. MP1 and MP2 are always running at the same
+	 * frequency. 3. UP case, it's MP1 or MM core.
+	 */
+	if (num_cpus == 2) {
+		mmp3_core_num = TWO_CORES;
+		for (i = 0; i < num_cpus; i++) {
+			for (j = 0, k = 0; j < freq_table_item_count; j++) {
+				freq = mmp3_get_pp_freq(j, MMP3_CLK_MP1);
+				/* choose the lower pp */
+				if (k > 0 &&
+					freq == freq_table[i][k - 1].frequency)
+					continue;
+				freq_table[i][k].index = k;
+				freq_table[i][k].frequency = freq;
+				cpu_frequency_index_to_pp_index[i][k] = j;
+				k++;
+			}
+			freq_table[i][k].index = k;
+			freq_table[i][k].frequency = CPUFREQ_TABLE_END;
+		}
+	} else if (num_cpus == 3) {
+		mmp3_core_num = THREE_CORES;
+		for (i = 0; i < num_cpus; i++) {
+			if (i == 0)
+				core = MMP3_CLK_MM;
+			else
+				core = MMP3_CLK_MP1;
+			for (j = 0, k = 0; j < freq_table_item_count; j++) {
+				freq = mmp3_get_pp_freq(j, core);
+				if (k > 0 &&
+					freq == freq_table[i][k - 1].frequency)
+					continue;
+				freq_table[i][k].index = k;
+				freq_table[i][k].frequency = freq;
+				cpu_frequency_index_to_pp_index[i][k] = j;
+				k++;
+			}
+			freq_table[i][k].index = k;
+			freq_table[i][k].frequency = CPUFREQ_TABLE_END;
+		}
+	} else if (num_cpus == 1) {
+#ifdef CONFIG_SMP
+		pr_err("only one core detected in cpufreq driver!\n");
+#endif
+
+		/* use mp1 core's value to register into cpufreq */
+		mmp3_core_num = ONE_CORE_MP1;
+		core = MMP3_CLK_MP1;
+		for (j = 0, k = 0; j < freq_table_item_count; j++) {
+			freq = mmp3_get_pp_freq(j, core);
+			if (k > 0 &&
+				freq == freq_table[0][k - 1].frequency)
+				continue;
+			freq_table[0][k].index = k;
+			freq_table[0][k].frequency = freq;
+			cpu_frequency_index_to_pp_index[0][k] = j;
+			k++;
+		}
+		freq_table[0][k].index = k;
+		freq_table[0][k].frequency = CPUFREQ_TABLE_END;
+	}
+
+	pm_qos_add_notifier(PM_QOS_CPUFREQ_MIN, &cpufreq_min_notifier);
+	pm_qos_add_notifier(PM_QOS_CPUFREQ_DISABLE, &cpufreq_disable_notifier);
+
+	pm_qos_add_request(&cpufreq_qos_req_min, PM_QOS_CPUFREQ_MIN,
+			PM_QOS_DEFAULT_VALUE);
+
+	register_reboot_notifier(&cpufreq_reboot_notifier);
+	return cpufreq_register_driver(&mmp3_cpufreq_driver);
+
+_exit:
+	while (i > 0) {
+		kfree(freq_table[i]);
+		i--;
+	}
+
+	return -ENOMEM;
+}
+
+module_init(cpufreq_init);
+
+static void __exit cpufreq_exit(void)
+{
+	int i;
+	int num = num_possible_cpus();
+
+	unregister_reboot_notifier(&cpufreq_reboot_notifier);
+
+	for (i = 0; i < num; i++) {
+		if (!IS_ERR(freq_table[i]))
+			kfree(freq_table[i]);
+	}
+
+	cpufreq_unregister_driver(&mmp3_cpufreq_driver);
+}
+
+module_exit(cpufreq_exit);
+
+MODULE_DESCRIPTION("CPU frequency scaling driver for mmp3");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mmp/cpuidle-mmp3.c b/arch/arm/mach-mmp/cpuidle-mmp3.c
new file mode 100644
index 0000000..34654a5
--- /dev/null
+++ b/arch/arm/mach-mmp/cpuidle-mmp3.c
@@ -0,0 +1,123 @@
+/*
+ * linux/arch/arm/mach-mmp/cpuidle-mmp3.c
+ *
+ * Author:	Raul Xiong <xjian@marvell.com>
+ * Copyright:	(C) 2011 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/export.h>
+#include <linux/cpuidle.h>
+#include <asm/cpuidle.h>
+#include <mach/mmp3_pm.h>
+
+
+static struct cpuidle_driver mmp3_idle_driver = {
+	.name = "mmp3_idle",
+	.owner = THIS_MODULE,
+};
+
+static DEFINE_PER_CPU(struct cpuidle_device, mmp3_cpuidle_device);
+
+static int mmp3_enter_idle_c1(struct cpuidle_device *dev,
+	struct cpuidle_driver *drv, int index)
+{
+	struct timespec ts_preidle, ts_postidle;
+	int idletime_us;
+	local_irq_disable();
+	local_fiq_disable();
+	getnstimeofday(&ts_preidle);
+
+	mmp3_pm_enter_idle(dev->cpu);
+
+	getnstimeofday(&ts_postidle);
+	idletime_us = (ts_postidle.tv_sec - ts_preidle.tv_sec) *
+		USEC_PER_SEC + (ts_postidle.tv_nsec - ts_preidle.tv_nsec) /
+		NSEC_PER_USEC;
+	local_fiq_enable();
+	local_irq_enable();
+
+	return idletime_us;
+}
+
+static int mmp3_enter_idle_c2(struct cpuidle_device *dev,
+	struct cpuidle_driver *drv, int index)
+{
+	struct timespec ts_preidle, ts_postidle;
+	int idletime_us;
+
+	local_irq_disable();
+	local_fiq_disable();
+	getnstimeofday(&ts_preidle);
+
+	mmp3_pm_enter_c2(dev->cpu, 0);
+
+	getnstimeofday(&ts_postidle);
+	idletime_us = (ts_postidle.tv_sec - ts_preidle.tv_sec) *
+		USEC_PER_SEC + (ts_postidle.tv_nsec - ts_preidle.tv_nsec) /
+		NSEC_PER_USEC;
+	local_fiq_enable();
+	local_irq_enable();
+
+	return idletime_us;
+}
+
+static int mmp3_cpuidle_register_device(unsigned int cpu)
+{
+	struct cpuidle_device *device;
+	struct cpuidle_state *state;
+
+	device = &per_cpu(mmp3_cpuidle_device, cpu);
+	device->state_count = 0;
+	device->cpu = cpu;
+
+	state = (device->kobjs[0])->state;
+	strcpy(state->name, "C1");
+	strcpy(state->desc, "C1: core internal clock gate");
+	state->exit_latency = 1; /* FIXME: what's the real latency? */
+	state->target_residency = state->exit_latency * 2;
+	state->flags = CPUIDLE_FLAG_TIME_VALID;
+	state->enter = mmp3_enter_idle_c1;
+	device->state_count++;
+
+	state = device->kobjs[1]->state;
+	strcpy(state->name, "C2");
+	strcpy(state->desc, "C2: core state is retained");
+	state->exit_latency = 20; /* FIXME: what's the real latency? */
+	state->target_residency = state->exit_latency * 2;
+	state->flags = CPUIDLE_FLAG_TIME_VALID;
+	/* FIXME: C2 doesn't work now, use c1 instead temporarily */
+	state->enter = mmp3_enter_idle_c2;
+	device->state_count++;
+
+	if (cpuidle_register_device(device)) {
+		pr_err("CPU%u: failed to register cpuidle device\n", cpu);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int __init mmp3_cpuidle_init(void)
+{
+	int ret, cpu;
+
+	ret = cpuidle_register_driver(&mmp3_idle_driver);
+	if (ret)
+		return ret;
+
+	for_each_possible_cpu(cpu) {
+		if (mmp3_cpuidle_register_device(cpu))
+			pr_err("CPU%u: error registering cpuidle\n", cpu);
+	}
+
+	return 0;
+}
+
+module_init(mmp3_cpuidle_init);
diff --git a/arch/arm/mach-mmp/delay-mmp3.S b/arch/arm/mach-mmp/delay-mmp3.S
new file mode 100644
index 0000000..63ba432
--- /dev/null
+++ b/arch/arm/mach-mmp/delay-mmp3.S
@@ -0,0 +1,59 @@
+/*
+ * arch/arm/mach-mmp/delay-mmp3.S
+ *
+ * Copyright (C) 2011 Marvell, Inc.
+ *
+ * Author:
+ *  Raul Xiong <xjian@marvell.com>
+ *
+ * based on arch/arm/mach-tegra/delay.S
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/asm-offsets.h>
+
+	.text
+
+ENTRY(__udelay)
+ENTRY(__const_udelay)
+
+/*
+ * r4 - cycles we have to wait
+ * r5 - cycles before udelay
+ * r0 - input useconds/cycles after udelay
+ */
+	stmdb	sp!, {r4, r5, r6, lr}
+	mov	r4, r0
+	mrrc	p15, 0, r0, r1, c14
+	mov	r5, r0
+	mov	r0, r4
+	bl	us2cyc
+	mov	r4, r0
+loop:
+	mrrc	p15, 0, r0, r1, c14
+	rsb	r0, r5, r0
+	cmp	r0, r4
+	bcc	loop
+end:
+	ldmia	sp!, {r4, r5, r6, pc}
+ENDPROC(__const_udelay)
+ENDPROC(__udelay)
+
+@ Delay routine
+ENTRY(__delay)
+	subs  r0, r0, #1
+	bhi __delay
+	mov pc, lr
+ENDPROC(__delay)
+
diff --git a/arch/arm/mach-mmp/devices.c b/arch/arm/mach-mmp/devices.c
index 191d9de..569066b 100644
--- a/arch/arm/mach-mmp/devices.c
+++ b/arch/arm/mach-mmp/devices.c
@@ -9,9 +9,23 @@
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/delay.h>
 
 #include <asm/irq.h>
 #include <mach/devices.h>
+#include <mach/cputype.h>
+#include <mach/regs-usb.h>
+#include <mach/soc_vmeta.h>
+#include <mach/soc_coda7542.h>
+#include <mach/regs-pmu.h>
+#include <mach/isp_dev.h>
+#include <mach/hsi_dev.h>
+#include <mach/regs-icu.h>
+#include <mach/addr-map.h>
+
+/*#define CONFIG_MMP3_QSEVEN_26MHZ*/
+
+extern unsigned int mmp_plat_ref_clk;
 
 int __init pxa_register_device(struct pxa_device_desc *desc,
 				void *data, size_t size)
@@ -26,6 +40,11 @@ int __init pxa_register_device(struct pxa_device_desc *desc,
 
 	pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
 
+#ifdef CONFIG_PXA910_1G_DDR_WORKAROUND
+	if (!strncmp(desc->dev_name, "pxa910-uart", 11))
+		pdev->dev.coherent_dma_mask = SZ_512M - 1;
+#endif
+
 	memset(res, 0, sizeof(res));
 
 	if (desc->start != -1ul && desc->size > 0) {
@@ -67,3 +86,1029 @@ int __init pxa_register_device(struct pxa_device_desc *desc,
 
 	return platform_device_add(pdev);
 }
+
+#if defined(CONFIG_PXA9XX_ACIPC)
+#if defined(CONFIG_CPU_PXA910)
+static struct resource pxa9xx_resource_acipc[] = {
+	[0] = {
+		.start  = 0xD401D000,
+		.end    = 0xD401D0ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_PXA910_IPC_AP0,
+		.end    = IRQ_PXA910_IPC_AP0,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_DATAACK",
+	},
+	[2] = {
+		.start  = IRQ_PXA910_IPC_AP1,
+		.end    = IRQ_PXA910_IPC_AP1,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_CMD",
+	},
+	[3] = {
+		.start  = IRQ_PXA910_IPC_AP2,
+		.end    = IRQ_PXA910_IPC_AP2,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_MSG",
+	},
+};
+
+#elif defined(CONFIG_CPU_PXA988)
+static struct resource pxa9xx_resource_acipc[] = {
+	[0] = {
+		.start  = 0xD401D000,
+		.end    = 0xD401D0ff,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_PXA988_IPC_AP0,
+		.end    = IRQ_PXA988_IPC_AP0,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_DATAACK",
+	},
+	[2] = {
+		.start  = IRQ_PXA988_IPC_AP1,
+		.end    = IRQ_PXA988_IPC_AP1,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_CMD",
+	},
+	[3] = {
+		.start  = IRQ_PXA988_IPC_AP2,
+		.end    = IRQ_PXA988_IPC_AP2,
+		.flags  = IORESOURCE_IRQ,
+		.name   = "IPC_AP_SET_MSG",
+	},
+};
+#else
+static struct resource pxa9xx_resource_acipc[] = {};
+#endif
+
+struct platform_device pxa9xx_device_acipc = {
+	.name           = "pxa9xx-acipc",
+	.id             = -1,
+	.resource       = pxa9xx_resource_acipc,
+	.num_resources  = ARRAY_SIZE(pxa9xx_resource_acipc),
+};
+#endif
+
+#if defined(CONFIG_USB) || defined(CONFIG_USB_GADGET)
+
+/*****************************************************************************
+ * The registers read/write routines
+ *****************************************************************************/
+
+unsigned int u2o_get(unsigned int base, unsigned int offset)
+{
+	return readl(base + offset);
+}
+
+void u2o_set(unsigned int base, unsigned int offset, unsigned int value)
+{
+	volatile unsigned int reg;
+
+	reg = readl(base + offset);
+	reg |= value;
+	writel(reg, base + offset);
+	__raw_readl(base + offset);
+
+}
+
+void u2o_clear(unsigned int base, unsigned int offset, unsigned int value)
+{
+	volatile unsigned int reg;
+
+	reg = readl(base + offset);
+	reg &= ~value;
+	writel(reg, base + offset);
+	__raw_readl(base + offset);
+}
+
+void u2o_write(unsigned int base, unsigned int offset, unsigned int value)
+{
+	writel(value, base + offset);
+	__raw_readl(base + offset);
+
+}
+
+#if defined(CONFIG_USB_PXA_U2O) || defined(CONFIG_USB_EHCI_PXA)
+
+#ifdef CONFIG_CPU_MMP3
+
+static DEFINE_SPINLOCK(phy_lock);
+static int phy_init_cnt;
+
+static int usb_phy_init_internal(unsigned int base)
+{
+	int loops = 0;
+	u32 temp;
+
+	pr_info("Init usb phy!!!\n");
+
+	temp = __raw_readl(PMUA_REG(0x100));
+	temp &= ~0xF00;
+	temp |= 0xd00;
+	__raw_writel(temp, PMUA_REG(0x100));
+
+	udelay(100);
+
+	/*replaced with b1*/
+	if (cpu_is_mmp3_b1()) {
+		u2o_clear(base, USB2_PLL_REG0,
+			USB2_PLL_REFDIV_MASK_MMP3_B0
+			| USB2_PLL_FBDIV_MASK_MMP3_B0);
+		if (mmp_plat_ref_clk == 0x3) {
+			pr_info("usb init for 25Mhz ref clock\n");
+			u2o_set(base, USB2_PLL_REG0,
+				0x5 << USB2_PLL_REFDIV_SHIFT_MMP3_B0
+				| 0x60 << USB2_PLL_FBDIV_SHIFT_MMP3_B0);
+		} else {
+			pr_info("usb init for 26Mhz ref clock\n");
+			u2o_set(base, USB2_PLL_REG0,
+				0xd << USB2_PLL_REFDIV_SHIFT_MMP3_B0
+				| 0xf0 << USB2_PLL_FBDIV_SHIFT_MMP3_B0);
+		}
+	} else if (cpu_is_mmp3_a0()) {
+		/*USB2_PLL_REG0 = 0x5df0 */
+		u2o_clear(base, USB2_PLL_REG0, (USB2_PLL_FBDIV_MASK_MMP3
+			| USB2_PLL_REFDIV_MASK_MMP3));
+		u2o_set(base, USB2_PLL_REG0, 0xd << USB2_PLL_REFDIV_SHIFT_MMP3
+			| 0xf0 << USB2_PLL_FBDIV_SHIFT_MMP3);
+	}
+
+	/* USB2_PLL_REG1 = 0x3333 */
+	u2o_clear(base, USB2_PLL_REG1, USB2_PLL_PU_PLL_MASK
+		| USB2_PLL_ICP_MASK_MMP3
+		| USB2_PLL_KVCO_MASK_MMP3
+		| USB2_PLL_CALI12_MASK_MMP3);
+	u2o_set(base, USB2_PLL_REG1, 1 << USB2_PLL_PU_PLL_SHIFT_MMP3
+		| 1 << USB2_PLL_LOCK_BYPASS_SHIFT_MMP3
+		| 3 << USB2_PLL_ICP_SHIFT_MMP3
+		| 3 << USB2_PLL_KVCO_SHIFT_MMP3
+		| 3 << USB2_PLL_CAL12_SHIFT_MMP3);
+
+	/* USB2_TX_REG0 = 0x288 */
+	u2o_clear(base, USB2_TX_REG0, USB2_TX_IMPCAL_VTH_MASK_MMP3);
+	u2o_set(base, USB2_TX_REG0, 2 << USB2_TX_IMPCAL_VTH_SHIFT_MMP3);
+
+	/* USB2_TX_REG1 = 0x7c4 */
+	u2o_clear(base, USB2_TX_REG1, USB2_TX_VDD12_MASK_MMP3
+		| USB2_TX_AMP_MASK_MMP3
+		| USB2_TX_CK60_PHSEL_MASK_MMP3);
+	u2o_set(base, USB2_TX_REG1, 3 << USB2_TX_VDD12_SHIFT_MMP3
+		| 4 << USB2_TX_AMP_SHIFT_MMP3
+		| 4 << USB2_TX_CK60_PHSEL_SHIFT_MMP3);
+
+	/* USB2_TX_REG2 = 0xaff */
+	u2o_clear(base, USB2_TX_REG2, 3 << USB2_TX_DRV_SLEWRATE_SHIFT);
+	u2o_set(base, USB2_TX_REG2, 2 << USB2_TX_DRV_SLEWRATE_SHIFT);
+
+	/* USB2_RX_REG0 =  0xaaa1 */
+	u2o_clear(base, USB2_RX_REG0, USB2_RX_SQ_THRESH_MASK_MMP3);
+	u2o_set(base, USB2_RX_REG0, 0xa << USB2_RX_SQ_THRESH_SHIFT_MMP3);
+
+	/* USB2_ANA_REG1 =  0x5680 */
+	u2o_set(base, USB2_ANA_REG1, 0x1 << USB2_ANA_PU_ANA_SHIFT_MMP3);
+
+	/* USB2_OTG_REG0 =  0x8 */
+	u2o_set(base, USB2_OTG_REG0, 0x1 << USB2_OTG_PU_OTG_SHIFT_MMP3);
+
+	/* PLL Power up has been done in usb2CIEnableAppSubSysClocks routine
+	*  PLL VCO and TX Impedance Calibration Timing for Eshel & MMP3
+	*		   _____________________________________
+	*  PU   __________|
+	*			   ____________________________
+	*  VCOCAL START	__________|
+	*				  ___
+	*  REG_RCAL_START________________|   |________|_________
+	*		  | 200us |400us |40 | 400us  | USB PHY READY
+	* ------------------------------------------------------------------
+	*/
+	/* Calibrate PHY */
+	udelay(200);
+	u2o_set(base, USB2_PLL_REG1, 1 << USB2_PLL_VCOCAL_START_SHIFT_MMP3);
+	udelay(400);
+	u2o_set(base, USB2_TX_REG0, 1 << USB2_TX_RCAL_START_SHIFT_MMP3);
+	udelay(40);
+	u2o_clear(base, USB2_TX_REG0, 1 << USB2_TX_RCAL_START_SHIFT_MMP3);
+	udelay(400);
+
+	/* Make sure PHY PLL is ready */
+	loops = 0;
+	while ((u2o_get(base, USB2_PLL_REG1) & USB2_PLL_READY_MASK_MMP3) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			pr_warn("PLL_READY not set after 100mS.");
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static int usb_phy_deinit_internal(unsigned int base)
+{
+	pr_info("Deinit usb phy!!!\n");
+	return 0;
+}
+
+int pxa_usb_phy_init(unsigned int base)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (phy_init_cnt++ == 0)
+		usb_phy_init_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+	return 0;
+}
+
+void pxa_usb_phy_deinit(unsigned int base)
+{
+	unsigned long flags;
+
+	WARN_ON(phy_init_cnt == 0);
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (--phy_init_cnt == 0)
+		usb_phy_deinit_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+}
+
+#endif
+
+#if defined(CONFIG_CPU_PXA168) || defined(CONFIG_CPU_PXA910)
+
+static DEFINE_SPINLOCK(phy_lock);
+static int phy_init_cnt;
+
+static int usb_phy_init_internal(unsigned int base)
+{
+	int loops;
+
+	pr_info("Init usb phy!!!\n");
+
+	/* Initialize the USB PHY power */
+	if (cpu_is_pxa910_family() || cpu_is_pxa920_family()) {
+		u2o_set(base, UTMI_CTRL, (1<<UTMI_CTRL_INPKT_DELAY_SOF_SHIFT)
+			| (1<<UTMI_CTRL_PU_REF_SHIFT));
+	}
+
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+
+	/* UTMI_PLL settings */
+	u2o_clear(base, UTMI_PLL, UTMI_PLL_PLLVDD18_MASK
+		| UTMI_PLL_PLLVDD12_MASK | UTMI_PLL_PLLCALI12_MASK
+		| UTMI_PLL_FBDIV_MASK | UTMI_PLL_REFDIV_MASK
+		| UTMI_PLL_ICP_MASK | UTMI_PLL_KVCO_MASK);
+
+	u2o_set(base, UTMI_PLL, 0xee<<UTMI_PLL_FBDIV_SHIFT
+		| 0xb<<UTMI_PLL_REFDIV_SHIFT | 3<<UTMI_PLL_PLLVDD18_SHIFT
+		| 3<<UTMI_PLL_PLLVDD12_SHIFT | 3<<UTMI_PLL_PLLCALI12_SHIFT
+		| 1<<UTMI_PLL_ICP_SHIFT | 3<<UTMI_PLL_KVCO_SHIFT);
+
+	/* UTMI_TX */
+	u2o_clear(base, UTMI_TX, UTMI_TX_REG_EXT_FS_RCAL_EN_MASK
+		| UTMI_TX_TXVDD12_MASK | UTMI_TX_CK60_PHSEL_MASK
+		| UTMI_TX_IMPCAL_VTH_MASK | UTMI_TX_REG_EXT_FS_RCAL_MASK
+		| UTMI_TX_AMP_MASK);
+	u2o_set(base, UTMI_TX, 3<<UTMI_TX_TXVDD12_SHIFT
+		| 4<<UTMI_TX_CK60_PHSEL_SHIFT | 4<<UTMI_TX_IMPCAL_VTH_SHIFT
+		| 8<<UTMI_TX_REG_EXT_FS_RCAL_SHIFT | 3<<UTMI_TX_AMP_SHIFT);
+
+	/* UTMI_RX */
+	u2o_clear(base, UTMI_RX, UTMI_RX_SQ_THRESH_MASK
+		| UTMI_REG_SQ_LENGTH_MASK);
+	u2o_set(base, UTMI_RX, 7<<UTMI_RX_SQ_THRESH_SHIFT
+		| 2<<UTMI_REG_SQ_LENGTH_SHIFT);
+
+	/* UTMI_IVREF */
+	if (cpu_is_pxa168())
+		/* fixing Microsoft Altair board interface with NEC hub issue -
+		 * Set UTMI_IVREF from 0x4a3 to 0x4bf */
+		u2o_write(base, UTMI_IVREF, 0x4bf);
+
+	/* toggle VCOCAL_START bit of UTMI_PLL */
+	udelay(200);
+	u2o_set(base, UTMI_PLL, VCOCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_PLL, VCOCAL_START);
+
+	/* toggle REG_RCAL_START bit of UTMI_TX */
+	udelay(400);
+	u2o_set(base, UTMI_TX, REG_RCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_TX, REG_RCAL_START);
+	udelay(400);
+
+	/* Make sure PHY PLL is ready */
+	loops = 0;
+	while ((u2o_get(base, UTMI_PLL) & PLL_READY) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			printk(KERN_WARNING "calibrate timeout, UTMI_PLL %x\n",
+				u2o_get(base, UTMI_PLL));
+			break;
+		}
+	}
+
+	if (cpu_is_pxa168()) {
+		u2o_set(base, UTMI_RESERVE, 1 << 5);
+		/* Turn on UTMI PHY OTG extension */
+		u2o_write(base, UTMI_OTG_ADDON, 1);
+	}
+
+	return 0;
+}
+
+static int usb_phy_deinit_internal(unsigned int base)
+{
+	pr_info("Deinit usb phy!!!\n");
+
+	if (cpu_is_pxa168())
+		u2o_clear(base, UTMI_OTG_ADDON, UTMI_OTG_ADDON_OTG_ON);
+
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_RXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_TXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_USB_CLK_EN);
+	u2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+	u2o_clear(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+
+	return 0;
+}
+
+int pxa_usb_phy_init(unsigned int base)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (phy_init_cnt++ == 0)
+		usb_phy_init_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+	return 0;
+}
+
+void pxa_usb_phy_deinit(unsigned int base)
+{
+	unsigned long flags;
+
+	WARN_ON(phy_init_cnt == 0);
+
+	spin_lock_irqsave(&phy_lock, flags);
+	if (--phy_init_cnt == 0)
+		usb_phy_deinit_internal(base);
+	spin_unlock_irqrestore(&phy_lock, flags);
+}
+#endif
+
+#ifdef CONFIG_CPU_MMP2
+/* USB PHY PLL init */
+static int pxa_usb_phy_pll_init(unsigned int base)
+{
+	static int init_done;
+	int loops;
+
+	if (init_done) {
+		pr_debug("re-init phy\n\n");
+		/* return; */
+	}
+
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PLL_PWR_UP_SHIFT);
+
+	/* UTMI_PLL settings */
+	u2o_clear(base, UTMI_PLL, UTMI_PLL_PLLVDD18_MASK
+		| UTMI_PLL_PLLVDD12_MASK | UTMI_PLL_PLLCALI12_MASK
+		| UTMI_PLL_FBDIV_MASK | UTMI_PLL_REFDIV_MASK
+		| UTMI_PLL_ICP_MASK | UTMI_PLL_KVCO_MASK);
+
+	u2o_set(base, UTMI_PLL, 0xee<<UTMI_PLL_FBDIV_SHIFT
+		| 0xb<<UTMI_PLL_REFDIV_SHIFT | 3<<UTMI_PLL_PLLVDD18_SHIFT
+		| 3<<UTMI_PLL_PLLVDD12_SHIFT | 3<<UTMI_PLL_PLLCALI12_SHIFT
+		| 1<<UTMI_PLL_ICP_SHIFT | 3<<UTMI_PLL_KVCO_SHIFT);
+
+	/* UTMI_TX */
+	u2o_clear(base, UTMI_TX, UTMI_TX_REG_EXT_FS_RCAL_EN_MASK
+		| UTMI_TX_TXVDD12_MASK | UTMI_TX_CK60_PHSEL_MASK
+		| UTMI_TX_IMPCAL_VTH_MASK | UTMI_TX_REG_EXT_FS_RCAL_MASK
+		| UTMI_TX_AMP_MASK);
+	u2o_set(base, UTMI_TX, 3<<UTMI_TX_TXVDD12_SHIFT
+		| 4<<UTMI_TX_CK60_PHSEL_SHIFT | 4<<UTMI_TX_IMPCAL_VTH_SHIFT
+		| 8<<UTMI_TX_REG_EXT_FS_RCAL_SHIFT | 3<<UTMI_TX_AMP_SHIFT);
+
+	/* UTMI_RX */
+	u2o_clear(base, UTMI_RX, UTMI_RX_SQ_THRESH_MASK
+		| UTMI_REG_SQ_LENGTH_MASK);
+	u2o_set(base, UTMI_RX, 7<<UTMI_RX_SQ_THRESH_SHIFT
+		| 2<<UTMI_REG_SQ_LENGTH_SHIFT);
+
+	/* UTMI_IVREF */
+	/* fixing Microsoft Altair board interface with NEC hub issue
+	 * Set UTMI_IVREF from 0x4a3 to 0x4bf */
+	u2o_write(base, UTMI_IVREF, 0x4bf);
+
+	/* calibration */
+	loops = 0;
+	while ((u2o_get(base, UTMI_PLL) & PLL_READY) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			pr_warn("%s:calibrate timeout, UTMI_PLL: %x\n",
+					__func__, u2o_get(base, UTMI_PLL));
+			break;
+		}
+	}
+
+	/* toggle VCOCAL_START bit of UTMI_PLL */
+	udelay(200);
+	u2o_set(base, UTMI_PLL, VCOCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_PLL, VCOCAL_START);
+
+	/* toggle REG_RCAL_START bit of UTMI_TX */
+	udelay(200);
+	u2o_set(base, UTMI_TX, REG_RCAL_START);
+	udelay(40);
+	u2o_clear(base, UTMI_TX, REG_RCAL_START);
+	udelay(200);
+
+	/* Make sure PHY PLL is ready */
+	loops = 0;
+	while ((u2o_get(base, UTMI_PLL) & PLL_READY) == 0) {
+		mdelay(1);
+		loops++;
+		if (loops > 100) {
+			pr_warn("%s:calibrate timeout, UTMI_PLL %x\n",
+					__func__, u2o_get(base, UTMI_PLL));
+			break;
+		}
+	}
+
+	init_done = 1;
+	return 0;
+}
+
+/* USB PHY PLL deinit */
+static void pxa_usb_phy_pll_deinit(unsigned int base)
+{
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_RXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_TXBUF_PDWN);
+	u2o_clear(base, UTMI_CTRL, UTMI_CTRL_USB_CLK_EN);
+	u2o_clear(base, UTMI_CTRL, 1 << UTMI_CTRL_PLL_PWR_UP_SHIFT);
+}
+
+/* USB PHY power on */
+static void pxa_usb_phy_power_on(unsigned int base)
+{
+	u2o_set(base, UTMI_CTRL, 1<<UTMI_CTRL_PWR_UP_SHIFT);
+}
+
+/* USB PHY power off */
+static void pxa_usb_phy_power_off(unsigned int base)
+{
+	u2o_clear(base, UTMI_CTRL, 1 << UTMI_CTRL_PWR_UP_SHIFT);
+}
+
+/* For component whose clock depends on usb phy pll */
+void pxa_usb_phy_clk_enable(void)
+{
+	u32 base = (u32)ioremap_nocache(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+	if (!base)
+		return;
+	pxa_usb_phy_pll_init(base);
+	iounmap((void __iomem *)base);
+}
+
+void pxa_usb_phy_clk_disable(void)
+{
+	u32 base = (u32)ioremap_nocache(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+	if (!base)
+		return;
+	pxa_usb_phy_pll_deinit(base);
+	iounmap((void __iomem *)base);
+}
+
+DEFINE_MUTEX(usb_phy_lock);
+static int usb_phy_enabled;
+/* USB UTMI(OTG PHY) init */
+int pxa_usb_phy_init(unsigned int base)
+{
+	struct clk *clk = clk_get(NULL, "USBPHYCLK");
+	if (IS_ERR(clk)) {
+		pr_err("%s: can't get USB PHY clk\n", __func__);
+		return PTR_ERR(clk);
+	}
+	mutex_lock(&usb_phy_lock);
+	if (usb_phy_enabled++ == 0) {
+		/* pll init => power on */
+		clk_enable(clk);
+		pxa_usb_phy_power_on(base);
+	}
+	mutex_unlock(&usb_phy_lock);
+	return 0;
+}
+
+/* USB UTMI(OTG PHY) deinit */
+void pxa_usb_phy_deinit(unsigned int base)
+{
+	struct clk *clk = clk_get(NULL, "USBPHYCLK");
+	if (IS_ERR(clk)) {
+		pr_err("%s: can't get USB PHY clk\n", __func__);
+		return;
+	}
+	mutex_lock(&usb_phy_lock);
+	WARN_ON(usb_phy_enabled == 0);
+	if (--usb_phy_enabled == 0) {
+		/* power off => pll deinit */
+		pxa_usb_phy_power_off(base);
+		clk_disable(clk);
+	}
+	mutex_unlock(&usb_phy_lock);
+}
+#endif
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_HSIC
+#ifdef CONFIG_CPU_MMP3
+
+int mmp3_hsic_phy_init(unsigned int base)
+{
+	unsigned int otgphy;
+	u32 val;
+
+	pr_info("mmp3_hsic_phy_init !!!\n");
+
+	otgphy = (unsigned int) ioremap(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+	if (otgphy == 0) {
+		printk(KERN_ERR "%s: ioremap error\n", __func__);
+		return -ENOMEM;
+	}
+
+	pxa_usb_phy_init(otgphy);
+	iounmap((void __iomem *)otgphy);
+
+	/* Enable hsic phy */
+	val = __raw_readl(base + HSIC_CTRL);
+	val |= (HSIC_CTRL_HSIC_ENABLE | HSIC_CTRL_PLL_BYPASS);
+	__raw_writel(val, base + HSIC_CTRL);
+
+	return 0;
+}
+
+void mmp3_hsic_phy_deinit(unsigned int base)
+{
+	unsigned int otgphy;
+	u32 val;
+
+	pr_info("mmp3_hsic_phy_deinit !!!\n");
+
+	/* Disable HSIC PHY */
+	val = __raw_readl(base + HSIC_CTRL);
+	val &= ~HSIC_CTRL_HSIC_ENABLE;
+	__raw_writel(val, base + HSIC_CTRL);
+
+	otgphy = (unsigned int) ioremap(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+	if (otgphy == 0) {
+		printk(KERN_ERR "%s: ioremap error\n", __func__);
+		return;
+	}
+
+	pxa_usb_phy_deinit(otgphy);
+	iounmap((void __iomem *)otgphy);
+}
+#endif
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_FSIC
+#ifdef CONFIG_CPU_MMP3
+
+#define PORTSC	0x084
+int mmp3_ulpi_init(unsigned int base)
+{
+	u32 val;
+	pr_info("fsic phy init for ulpi\n");
+	/* check SPH clock source, should be PMU 60MHz */
+	val = __raw_readl(base + 0x30);
+	pr_debug(" SPH clock src 0xf0003830: 0x%x\n",
+		__raw_readl(base + 0x30));
+	if ((val & 0x100) == 0)
+		pr_warning("SPH clock from external ULPI???\n");
+
+	/* select ULPI interface in USB FSIC */
+	pr_info(" select ULPI interface in USB FSIC\n");
+	val = __raw_readl(base + FSIC_MISC);
+	val |= 1<<27;
+	__raw_writel(val, base + FSIC_MISC);
+
+	/* Use ULPI clock (disable PMU 60MHz) */
+	val = __raw_readl(base + FSIC_CTRL);
+	val &= ~(1<<8);
+	__raw_writel(val, base + FSIC_CTRL);
+
+	return 0;
+}
+
+int mmp3_fsic_phy_init(unsigned int base)
+{
+	pr_info("mmp3_fsic_phy_init !!!\n");
+	unsigned int otgphy;
+	u32 val;
+	otgphy = (unsigned int) ioremap(PXA168_U2O_PHYBASE, USB_PHY_RANGE);
+	if (otgphy == 0) {
+		printk(KERN_ERR "%s: ioremap error\n", __func__);
+		return -ENOMEM;
+	}
+
+	/*pxa_usb_phy_init(otgphy);*/
+	iounmap((void __iomem *)otgphy);
+
+
+	/* Enable PMU 60MHz clock to SPH controller */
+	__raw_writel(0x100, base + FSIC_CTRL);
+
+	pr_debug("%s select PMU 60MHz clock for FSIC/SPH3 FSIC_CTRL %x\n",
+		__func__, __raw_readl(base + FSIC_CTRL));
+
+	/*Select ULPI in SPH controller */
+	mmp3_ulpi_init(base);
+	return 0;
+}
+
+int mmp3_fsic_p_init(unsigned int base)
+{
+/*no need for below code but since it is implemented in the mmp2
+  we have included here for reference purpose only*/
+
+#if 1
+	u32 val;
+	pr_info(" select ULPI interface in SPH usb controller\n");
+	val = __raw_readl(base + PORTSC);
+	val &= ~(0x3<<30);
+	val |= 2<<30;
+	val &= 0xfdffffff;
+	__raw_writel(val, base + PORTSC);
+	return 0;
+#endif
+}
+
+#endif
+#endif
+
+#endif
+
+#ifdef CONFIG_CPU_MMP3
+u32 u3d_phy_read(u32 base, u32 reg)
+{
+	u32 addr, data;
+	addr = base;
+	data = base + 0x4;
+
+	writel(reg, addr);
+	return readl(data);
+}
+
+void u3d_phy_write(u32 base, u32 reg, u32 value)
+{
+	u32 addr, data;
+	addr = base;
+	data = base + 0x4;
+
+	writel(reg, addr);
+	writel(value, data);
+}
+
+void pxa_u3d_phy_deinit(unsigned int base)
+{
+	u32 val;
+
+	printk(KERN_INFO "%s\n", __func__);
+
+	/* Power down Reference Analog current, bit 15
+	 * Power down PLL, bit 14
+	 * Power down Receiver, bit 13
+	 * Power down Transmitter, bit 12
+	 * of USB3_POWER_PLL_CONTROL register
+	 */
+	val = u3d_phy_read(base, 0x1);
+	val &= ~(0xF << 12);
+	u3d_phy_write(base, 0x1, val);
+	udelay(100);
+}
+
+void pxa_u3d_phy_disable(void)
+{
+	unsigned int val;
+	void __iomem *phy_reg;
+	phy_reg = ioremap(0xD422B800, 0x1000);
+
+	/* enable usb3 clock */
+	val = readl(PMUA_REG(0x148));
+	val = 0x9;
+	writel(val, PMUA_REG(0x148));
+
+	/* deinit usb3 phy */
+	pxa_u3d_phy_deinit((unsigned int)phy_reg);
+
+	/* disable usb3 clock */
+	val = readl(PMUA_REG(0x148));
+	val = 0x0;
+	writel(val, PMUA_REG(0x148));
+
+	iounmap(phy_reg);
+}
+#endif
+
+#if (defined(CONFIG_USB_SUPPORT) && !defined(CONFIG_CPU_PXA988))
+static u64 usb_dma_mask = ~(u32)0;
+
+#ifdef CONFIG_USB_PXA_U2O
+struct resource pxa168_u2o_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2o = {
+	.name		= "pxa-u2o",
+	.id		= -1,
+	.resource	= pxa168_u2o_resources,
+	.num_resources	= ARRAY_SIZE(pxa168_u2o_resources),
+	.dev		=  {
+		.dma_mask	= &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	}
+};
+
+#endif /* CONFIG_USB_PXA_U2O */
+
+#ifdef CONFIG_USB_EHCI_PXA_U2O
+struct resource pxa168_u2oehci_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2oehci = {
+	.name		= "pxa-u2oehci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(pxa168_u2oehci_resources),
+	.resource	= pxa168_u2oehci_resources,
+};
+
+#if defined(CONFIG_USB_PXA_U2O_OTG)
+struct resource pxa168_u2ootg_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2ootg = {
+	.name		= "pxa-otg",
+	.id		= -1,
+	.dev  = {
+		.dma_mask          = &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(pxa168_u2ootg_resources),
+	.resource      = pxa168_u2ootg_resources,
+};
+#endif /* CONFIG_USB_PXA_U2O_OTG */
+
+#endif
+#endif
+
+#ifdef CONFIG_MMP3_HSI
+int hsi_config_int(void *param)
+{
+	/*
+	 * all mmp3 interrupts are route to GIC and bypass ICU
+	 * so should _NOT_ enable ICU HSI register here.
+	 */
+	return 0;
+}
+
+static u64 mmp_hsi_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource mmp3_hsi_resource[] = {
+	[0] = {
+		.name   = "func_reg_base",
+		.start  = 0xD4204000,
+		.end    = 0xD4204FFF,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MMP3_HSI1,
+		.end = IRQ_MMP3_HSI1,
+		.flags = IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device mmp3_hsi_device = {
+	.name           = "mmp3_hsi",
+	.id             = 0,
+	.dev			= {
+		.dma_mask = &mmp_hsi_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.num_resources  = ARRAY_SIZE(mmp3_hsi_resource),
+	.resource       = mmp3_hsi_resource,
+};
+
+void __init mmp_register_hsi(struct hsi_platform_data *data)
+{
+	int ret;
+
+	data->hsi_config_int = hsi_config_int;
+	mmp3_hsi_device.dev.platform_data = data;
+
+	ret = platform_device_register(&mmp3_hsi_device);
+	if (ret)
+		dev_err(&(mmp3_hsi_device.dev),
+			"unable to register hsi device: %d\n", ret);
+}
+
+#endif
+
+
+#ifdef CONFIG_UIO_VMETA
+static u64 mmp_vmeta_dam_mask = DMA_BIT_MASK(32);
+#ifdef CONFIG_CPU_MMP3
+static struct resource mmp_vmeta_resources[3] = {
+	[0] = {
+		.start = 0xF0400000,
+		.end   = 0xF07FFFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MMP3_VMETA,
+		.end   = IRQ_MMP3_VMETA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+#elif defined CONFIG_CPU_MMP2
+static struct resource mmp_vmeta_resources[] = {
+	[0] = {
+		.start = 0xF0400000,
+		.end   = 0xF07FFFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_MMP2_VMETA,
+		.end   = IRQ_MMP2_VMETA,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+#else
+static struct resource mmp_vmeta_resources[] = {};
+#endif
+
+struct platform_device mmp_device_vmeta = {
+	.name           = UIO_VMETA_NAME,
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &mmp_vmeta_dam_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource       = mmp_vmeta_resources,
+	.num_resources  = ARRAY_SIZE(mmp_vmeta_resources),
+};
+
+void __init mmp_register_vmeta(struct platform_device *dev, void *data)
+{
+	int ret;
+
+	dev->dev.platform_data = data;
+
+	ret = platform_device_register(dev);
+	if (ret)
+		dev_err(&dev->dev, "unable to register vmeta device: %d\n", ret);
+}
+
+void __init mmp_set_vmeta_info(void* info)
+{
+	mmp_register_vmeta(&mmp_device_vmeta, info);
+}
+#endif
+
+#ifdef CONFIG_UIO_CODA7542
+static u64 pxa_coda7542_dam_mask = DMA_BIT_MASK(32);
+static struct resource pxa_coda7542_resources[] = {
+	[0] = {
+		.start = 0xD420D000,
+		.end   = 0xD420DFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = SRAM_VIDEO_BASE,
+		.end   = SRAM_VIDEO_BASE + SRAM_VIDEO_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = IRQ_PXA988_CODA7542,
+		.end   = IRQ_PXA988_CODA7542,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa_device_coda7542 = {
+	.name		= UIO_CODA7542_NAME,
+	.id		= 0,
+	.dev		= {
+		.dma_mask = &pxa_coda7542_dam_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource	= pxa_coda7542_resources,
+	.num_resources	= ARRAY_SIZE(pxa_coda7542_resources),
+};
+
+void __init pxa_register_coda7542(void)
+{
+	int ret;
+
+	ret = platform_device_register(&pxa_device_coda7542);
+	if (ret)
+		dev_err(&(pxa_device_coda7542.dev),
+			"unable to register coda7542 device: %d\n", ret);
+}
+#endif
+
+#ifdef CONFIG_VMETA_DEVFREQ
+struct platform_device mmp_device_vMeta_devfreq = {
+	.name = "devfreq-vMeta",
+	.id = -1,
+};
+
+void __init mmp_register_devfreq_vmeta(struct platform_device *dev, void *data)
+{
+	int ret;
+
+	dev->dev.platform_data = data;
+
+	ret = platform_device_register(dev);
+	if (ret)
+		dev_err(&dev->dev, "unable to register vMeta-devfreq device: %d\n", ret);
+}
+
+void __init mmp_set_devfreq_vmeta_info(void* info)
+{
+	mmp_register_devfreq_vmeta(&mmp_device_vMeta_devfreq, info);
+}
+
+#endif
diff --git a/arch/arm/mach-mmp/dvfs-mmp3.c b/arch/arm/mach-mmp/dvfs-mmp3.c
new file mode 100644
index 0000000..e948f02
--- /dev/null
+++ b/arch/arm/mach-mmp/dvfs-mmp3.c
@@ -0,0 +1,192 @@
+/*
+ *  linux/arch/arm/mach-mmp/dvfs-mmp3.c
+ *
+ *  based on arch/arm/mach-tegra/tegra2_dvfs.c
+ *	 Copyright (C) 2010 Google, Inc. by Colin Cross <ccross@google.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+
+#include <plat/clock.h>
+#include <plat/dvfs.h>
+#include <mach/cputype.h>
+
+/*
+ * VCC_MAIN
+ */
+static enum {
+	MM = 0,
+	MP1, MP2, FAB,
+	DCLK1, DCLK2,
+	ACLK1, ACLK2,
+	GC,
+	VMETA,
+	MMP3_VM_ROW_FACTOR_NUM,
+};
+
+static enum {
+	V_EN = 0,
+	V0, V1, V2, V3, V4, V5,
+	MMP3_VM_COL_VOL_NUM,
+};
+#define MMP3_VM_VOL_NUM (MMP3_VM_COL_VOL_NUM - 1)
+
+/* mV */
+#define VCC_MAIN_STEP		25
+#define VCC_MAIN_DEFAULT	1200
+#define VCC_MAIN_MAX		1325
+#define VCC_MAIN_MIN		1150
+/* default */
+/*static const int vcc_main_vol_table_def[] = { [V0] = 1150, [V1] = 1150, [V2] = 1150, [V3] = 1200, [V4] = 1250, [V5] = 1300, };*/
+static const int vcc_main_vol_table_def[] = { [V0] = 1200, [V1] = 1200, [V2] = 1200, [V3] = 1200, [V4] = 1300, [V5] = 1300, };
+/* B0P */
+static const int vcc_main_vol_table_b0p[][MMP3_VM_COL_VOL_NUM] = {
+	[0] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1325, [V5] = 1325, },
+	[1] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1325, [V5] = 1325, },
+	[2] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1325, [V5] = 1325, },
+	[3] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1325, [V5] = 1325, },
+	[4] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1300, [V5] = 1325, },
+	[5] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1275, [V5] = 1300, },
+	[6] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1250, [V5] = 1275, },
+	[7] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1250, [V5] = 1250, },
+	[8] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1250, [V5] = 1250, },
+	[9] = { [V0] = 1150, [V1] = 1150, [V2] = 1250, [V3] = 1250, [V4] = 1250, [V5] = 1250, },
+};
+
+static const char *vcc_main_clk_name[] = {
+	[MM]	= "",
+	[MP1]	= "cpu",
+	[MP2]	= "",
+	[FAB]	= "",
+	[DCLK1]	= "ddr",
+	[DCLK2]	= "",
+	[ACLK1]	= "",
+	[ACLK2]	= "",
+	[GC]	= "",
+	[VMETA]	= "",
+};
+
+/* kHz */
+static const int vcc_main_threshold[][MMP3_VM_COL_VOL_NUM] = {
+	[MM]	= { 0, 0, 0, 0, 0, 0, 0 },
+	[MP1]	= { 1, 100000, 200000, 400000, 800000, 1066666, 1200000 },
+	[MP2]	= { 0, 0, 0, 0, 0, 0, 0 },
+	[FAB]	= { 0, 100000, 200000, 400000, 400000, 533333, 600000 },
+/*	[DCLK1]	= { 0, 400000, 400000, 400000, 400000, 400000, 400000 },*/
+	[DCLK1]	= { 1, 266666000, 355555000, 533333000, 800000000, 1066666000, 1066666000 },
+	[DCLK2]	= { 0, 0, 0, 0, 0, 0, 0 },
+	[ACLK1]	= { 0, 100000, 200000, 400000, 400000, 400000, 400000 },
+	[ACLK2]	= { 0, 100000, 100000, 200000, 200000, 200000, 200000 },
+	[GC]	= { 0, 533333, 533333, 533333, 533333, 533333, 533333 },
+	[VMETA]	= { 0, 400000, 400000, 400000, 400000, 400000, 400000 },
+};
+
+static struct dvfs_rail mmp3_dvfs_rail_vcc_main = {
+	.reg_id = "vcc_main",
+	.max_millivolts = VCC_MAIN_MAX,
+	.min_millivolts = VCC_MAIN_MIN,
+	.nominal_millivolts = VCC_MAIN_DEFAULT,
+	.step = VCC_MAIN_STEP,
+};
+
+static struct dvfs *vcc_main_dvfs_init(int factor, const int (*vcc_main_vol_table)[])
+{
+	struct dvfs *vm_dvfs = 0;
+	struct vol_table *vt = 0;
+	int i;
+
+	/* dvfs is not enabled for this factor in vcc_main_threshold */
+	if (!vcc_main_threshold[factor][V_EN])
+		goto err;
+	if (!(vm_dvfs = kzalloc(sizeof(struct dvfs), GFP_KERNEL))) {
+		pr_err("failed to request mem for vcc_main dvfs\n");
+		goto err;
+	}
+	if (!(vt = kzalloc(sizeof(struct vol_table) * MMP3_VM_VOL_NUM, GFP_KERNEL))) {
+		pr_err("failed to request mem for vcc_main vol table\n");
+		goto err_vt;
+	}
+
+	for (i = V0; i < MMP3_VM_COL_VOL_NUM; i++) {
+		vt[i - V0].freq = vcc_main_threshold[factor][i];
+		vt[i - V0].millivolts = (*vcc_main_vol_table)[i];
+	}
+	vm_dvfs->vol_freq_table = vt;
+	vm_dvfs->clk_name = vcc_main_clk_name[factor];
+	vm_dvfs->num_freqs = MMP3_VM_VOL_NUM;
+	vm_dvfs->dvfs_rail = &mmp3_dvfs_rail_vcc_main;
+
+	return vm_dvfs;
+err_vt:
+	kzfree(vm_dvfs);
+err:
+	return vm_dvfs;
+}
+
+/* set regulator name of vcc_main */
+static char vcc_main_reg_id[16];
+void mmp3_set_vcc_main_reg_id(const char *name)
+{
+	if (name) {
+		strcpy(vcc_main_reg_id, name);
+		mmp3_dvfs_rail_vcc_main.reg_id = vcc_main_reg_id;
+	}
+}
+EXPORT_SYMBOL(mmp3_set_vcc_main_reg_id);
+
+/*
+ * DVFS
+ */
+static struct dvfs_relationship mmp3_dvfs_relationships[] = {
+};
+
+static struct dvfs_rail *mmp3_dvfs_rails[] = {
+	&mmp3_dvfs_rail_vcc_main,
+};
+
+int __init mmp3_init_dvfs(void)
+{
+	int i;
+	struct dvfs *d;
+	struct clk *c;
+	int ret;
+	const int (*vcc_main_vol_table)[];
+
+	if (cpu_is_mmp3_b0p())
+		vcc_main_vol_table = &vcc_main_vol_table_b0p[mmp_soc_profile];
+	else
+		vcc_main_vol_table = &vcc_main_vol_table_def;
+
+	dvfs_init_rails(mmp3_dvfs_rails, ARRAY_SIZE(mmp3_dvfs_rails));
+	dvfs_add_relationships(mmp3_dvfs_relationships,
+			ARRAY_SIZE(mmp3_dvfs_relationships));
+
+	for (i = 0; i < MMP3_VM_ROW_FACTOR_NUM; i++) {
+		d = vcc_main_dvfs_init(i, vcc_main_vol_table);
+		if (!d)
+			continue;
+		c = get_clock_by_name(d->clk_name);
+		if (!c) {
+			pr_debug("mmp3_dvfs: no clock found for %s\n",
+					d->clk_name);
+			kzfree(d->vol_freq_table);
+			kzfree(d);
+			continue;
+		}
+		ret = enable_dvfs_on_clk(c, d);
+		if (ret) {
+			pr_err("mmp3_dvfs: failed to enable dvfs on %s\n",
+					c->name);
+			kzfree(d->vol_freq_table);
+			kzfree(d);
+		}
+	}
+
+	return 0;
+}
+subsys_initcall(mmp3_init_dvfs);
+
diff --git a/arch/arm/mach-mmp/include/mach/addr-map.h b/arch/arm/mach-mmp/include/mach/addr-map.h
index b1ece08..604a32b 100644
--- a/arch/arm/mach-mmp/include/mach/addr-map.h
+++ b/arch/arm/mach-mmp/include/mach/addr-map.h
@@ -18,17 +18,77 @@
  * peripherals on APB, let's count it into the ABP mapping area.
  */
 #define APB_PHYS_BASE		0xd4000000
-#define APB_VIRT_BASE		IOMEM(0xfe000000)
+#define APB_VIRT_BASE		0xfe000000
 #define APB_PHYS_SIZE		0x00200000
 
 #define AXI_PHYS_BASE		0xd4200000
-#define AXI_VIRT_BASE		IOMEM(0xfe200000)
+#define AXI_VIRT_BASE		0xfe200000
 #define AXI_PHYS_SIZE		0x00200000
 
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_PHYS_BASE		0xc0100000
+#define DMCU_VIRT_BASE		0xfe500000
+#define DMCU_PHYS_SIZE		0x00010000
+#else
+#define DMCU_PHYS_BASE		0xd0000000
+#define DMCU_VIRT_BASE		0xfe500000
+#define DMCU_PHYS_SIZE		0x00020000
+#endif
+
+#ifdef CONFIG_CPU_MMP3
+#define PGU_PHYS_BASE		0xe0000000
+#define PGU_VIRT_BASE		0xfe400000
+#define PGU_PHYS_SIZE		0x00100000
+
+#define SCU_VIRT_BASE		(PGU_VIRT_BASE)
+#define GIC_DIST_VIRT_BASE	(PGU_VIRT_BASE + 0x1000)
+#define GIC_CPU_VIRT_BASE	(PGU_VIRT_BASE + 0x0100)
+#define TWD_VIRT_BASE		(PGU_VIRT_BASE + 0x600)
+
+#define SL2C_PHYS_BASE		0xd0020000
+#define SL2C_VIRT_BASE		0xfe800000
+#define SL2C_PHYS_SIZE		SZ_8K
+
+#define TZ_HV_PHYS_BASE		0x00000000
+#define TZ_HV_VIRT_BASE		0xfe900000
+#define TZ_HV_PHYS_SIZE		SZ_1M
+#endif
+
+#ifdef CONFIG_CPU_PXA988
+#define SCU_PHYS_BASE		0xd1dfe000
+#define SCU_VIRT_BASE		0xfe400000
+#define SCU_PHYS_SIZE		0x00100000
+#define GIC_DIST_VIRT_BASE	(SCU_VIRT_BASE + 0x1000)
+#define GIC_CPU_VIRT_BASE	(SCU_VIRT_BASE + 0x0100)
+#define TWD_VIRT_BASE		(SCU_VIRT_BASE + 0x0600)
+
+#define SL2C_PHYS_BASE		0xd1dfb000
+#define SL2C_VIRT_BASE		0xfe800000
+#define SL2C_PHYS_SIZE		SZ_8K
+#endif /*CONFIG_CPU_PXA988*/
+
 /* Static Memory Controller - Chip Select 0 and 1 */
 #define SMC_CS0_PHYS_BASE	0x80000000
 #define SMC_CS0_PHYS_SIZE	0x10000000
 #define SMC_CS1_PHYS_BASE	0x90000000
 #define SMC_CS1_PHYS_SIZE	0x10000000
 
+#define SRAM_PHYS_BASE		0xd1000000
+#define SRAM_VIRT_BASE		0xfea00000
+#define SRAM_PHYS_SIZE		0x30000
+
+#ifdef CONFIG_CPU_PXA988
+#define SRAM_CP_BASE		SRAM_PHYS_BASE
+#define SRAM_CP_SIZE		0x4000
+
+#define SRAM_AUDIO_BASE		(SRAM_CP_BASE + SRAM_CP_SIZE)
+#define SRAM_AUDIO_SIZE		0xd000
+
+#define SRAM_VIDEO_BASE		(SRAM_AUDIO_BASE + SRAM_AUDIO_SIZE)
+#define SRAM_VIDEO_SIZE		0xe000
+
+#define SRAM_POWER_BASE		(SRAM_VIDEO_BASE + SRAM_VIDEO_SIZE)
+#define SRAM_POWER_SIZE		0x1000
+#endif
+
 #endif /* __ASM_MACH_ADDR_MAP_H */
diff --git a/arch/arm/mach-mmp/include/mach/cputype.h b/arch/arm/mach-mmp/include/mach/cputype.h
index 8a3b56d..ddaeb1a 100644
--- a/arch/arm/mach-mmp/include/mach/cputype.h
+++ b/arch/arm/mach-mmp/include/mach/cputype.h
@@ -20,6 +20,12 @@
  */
 
 extern unsigned int mmp_chip_id;
+extern unsigned int mmp_chip_id_b1;
+extern unsigned int mmp_fuse_id;
+extern unsigned int mmp_soc_stepping;
+extern unsigned int mmp_soc_profile;
+extern unsigned int mmp_1g_svc;
+
 
 #ifdef CONFIG_CPU_PXA168
 static inline int cpu_is_pxa168(void)
@@ -31,16 +37,72 @@ static inline int cpu_is_pxa168(void)
 #define cpu_is_pxa168()	(0)
 #endif
 
-/* cpu_is_pxa910() is shared on both pxa910 and pxa920 */
 #ifdef CONFIG_CPU_PXA910
+
 static inline int cpu_is_pxa910(void)
 {
 	return (((read_cpuid_id() >> 8) & 0xff) == 0x84) &&
 		(((mmp_chip_id & 0xfff) == 0x910) ||
 		 ((mmp_chip_id & 0xfff) == 0x920));
 }
+
+static inline int cpu_is_pxa910_family(void)
+{
+	return (((read_cpuid_id() >> 8) & 0xff) == 0x84) &&
+		(((mmp_chip_id & 0xfff) == 0x910));
+}
+
+static inline int cpu_is_pxa920_family(void)
+{
+	return (((read_cpuid_id() >> 8) & 0xff) == 0x84) &&
+		(((mmp_chip_id & 0xfff) == 0x920));
+}
+
+static inline int cpu_is_pxa910(void)
+{
+	if (cpu_is_pxa910_family() && ((mmp_fuse_id & 0x0000f000) == 0x00003000))
+		return 0;
+	if (cpu_is_pxa910_family())
+		return 1;
+	return 0;
+}
+
+static inline int cpu_is_pxa920(void)
+{
+	if (cpu_is_pxa920_family() && ((mmp_fuse_id & 0x3000000)) == 0x3000000)
+		return 0;
+	if (cpu_is_pxa920_family() && (mmp_1g_svc == 0x0) &&
+		((mmp_fuse_id & 0x0000f000) != 0x00003000))
+		return 1;
+	return 0;
+}
+
+static inline int cpu_is_pxa921(void)
+{
+	if (cpu_is_pxa920_family() && ((mmp_fuse_id & 0x3000000) == 0x3000000))
+		return 0;
+	if (cpu_is_pxa920_family() && ((mmp_1g_svc != 0x0) ||
+		((mmp_fuse_id & 0x0000f000) == 0x00003000)))
+		return 1;
+	return 0;
+}
+
+static inline int cpu_is_pxa918(void)
+{
+	return (cpu_is_pxa920_family() &&
+		((mmp_fuse_id & 0x03000000) == 0x03000000));
+}
+
+static inline int cpu_is_pxa910h(void)
+{
+	return (cpu_is_pxa910_family() &&
+		((mmp_fuse_id & 0x0000f000) == 0x00003000));
+}
+
 #else
 #define cpu_is_pxa910()	(0)
+#define cpu_is_pxa910_family()	(0)
+#define cpu_is_pxa920_family()	(0)
 #endif
 
 #ifdef CONFIG_CPU_MMP2
@@ -52,4 +114,63 @@ static inline int cpu_is_mmp2(void)
 #define cpu_is_mmp2()	(0)
 #endif
 
+#ifdef CONFIG_CPU_MMP3
+static inline int cpu_is_mmp3(void)
+{
+	return (((read_cpuid_id() >> 8) & 0xff) == 0x58);
+}
+
+static inline int cpu_is_mmp3_a0(void)
+{
+	if (cpu_is_mmp3() && ((mmp_chip_id & 0x00ff0000) == 0x00a00000))
+		return 1;
+	else
+		return 0;
+}
+
+static inline int cpu_is_mmp3_b0(void)
+{
+	if (cpu_is_mmp3() && ((mmp_chip_id & 0x00ff0000) == 0x00b00000))
+		return 1;
+	else
+		return 0;
+}
+
+static inline int cpu_is_mmp3_b1(void)
+{
+	if (cpu_is_mmp3() && ((mmp_chip_id_b1 & 0x00ff0000) == 0x00b10000))
+		return 1;
+	else
+		return 0;
+}
+
+static inline int cpu_is_mmp3_b0p(void)
+{
+	if (cpu_is_mmp3() && mmp_soc_stepping == 0x423050)
+		return 1;
+	else
+		return 0;
+}
+#else
+#define cpu_is_mmp3(id)	(0)
+#endif
+
+#ifdef CONFIG_CPU_PXA988
+static inline int cpu_is_pxa988(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		(((mmp_chip_id & 0xffff) == 0xc988) ||
+		((mmp_chip_id & 0xffff) == 0xc928));
+}
+static inline int cpu_is_pxa986(void)
+{
+	return (((read_cpuid_id() >> 4) & 0xfff) == 0xc09) &&
+		(((mmp_chip_id & 0xffff) == 0xc986) ||
+		((mmp_chip_id & 0xffff) == 0xc926));
+}
+#else
+#define cpu_is_pxa988()	(0)
+#define cpu_is_pxa986()	(0)
+#endif
+
 #endif /* __ASM_MACH_CPUTYPE_H */
diff --git a/arch/arm/mach-mmp/include/mach/debug-macro.S b/arch/arm/mach-mmp/include/mach/debug-macro.S
index b6f14d2..049bc1f 100644
--- a/arch/arm/mach-mmp/include/mach/debug-macro.S
+++ b/arch/arm/mach-mmp/include/mach/debug-macro.S
@@ -14,8 +14,15 @@
 		.macro	addruart, rp, rv, tmp
 		ldr	\rp, =APB_PHYS_BASE		@ physical
 		ldr	\rv, =APB_VIRT_BASE		@ virtual
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+		|| defined(CONFIG_MACH_BROWNSTONE) || defined(CONFIG_MACH_THUNDERSTONEM) \
+		|| defined(CONFIG_MACH_QSEVEN)
+		orr	\rp, \rp, #0x00018000
+		orr	\rv, \rv, #0x00018000
+#else
 		orr	\rp, \rp, #0x00017000
 		orr	\rv, \rv, #0x00017000
+#endif
 		.endm
 
 #define UART_SHIFT	2
diff --git a/arch/arm/mach-mmp/include/mach/devices.h b/arch/arm/mach-mmp/include/mach/devices.h
index d0ec7da..7ec2552 100644
--- a/arch/arm/mach-mmp/include/mach/devices.h
+++ b/arch/arm/mach-mmp/include/mach/devices.h
@@ -49,5 +49,27 @@ struct pxa_device_desc mmp2_device_##_name __initdata = {		\
 	.dma		= { _dma },					\
 }
 
+#define MMP3_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc mmp3_device_##_name __initdata = {		\
+	.dev_name	= "mmp3-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_MMP3_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
+#define PXA988_DEVICE(_name, _drv, _id, _irq, _start, _size, _dma...)	\
+struct pxa_device_desc pxa988_device_##_name __initdata = {		\
+	.dev_name	= "pxa988-" #_name,				\
+	.drv_name	= _drv,						\
+	.id		= _id,						\
+	.irq		= IRQ_PXA988_##_irq,				\
+	.start		= _start,					\
+	.size		= _size,					\
+	.dma		= { _dma },					\
+}
+
 extern int pxa_register_device(struct pxa_device_desc *, void *, size_t);
 #endif /* __MACH_DEVICE_H */
diff --git a/arch/arm/mach-mmp/include/mach/entry-macro.S b/arch/arm/mach-mmp/include/mach/entry-macro.S
index 9cff9e7..bff4883 100644
--- a/arch/arm/mach-mmp/include/mach/entry-macro.S
+++ b/arch/arm/mach-mmp/include/mach/entry-macro.S
@@ -8,6 +8,7 @@
 
 #include <mach/regs-icu.h>
 
+#if !defined(CONFIG_CPU_MMP3) && !defined(CONFIG_CPU_PXA988)
 	.macro	get_irqnr_preamble, base, tmp
 	mrc	p15, 0, \tmp, c0, c0, 0		@ CPUID
 	and	\tmp, \tmp, #0xff00
@@ -22,3 +23,73 @@
 	and	\irqnr, \tmp, #0x3f
 	tst	\tmp, #(1 << 6)
 	.endm
+#else
+#include <asm/hardware/gic.h>
+	.macro	disable_fiq
+	.endm
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	/*
+	 * The interrupt numbering scheme is defined in the
+	 * interrupt controller spec.  To wit:
+	 *
+	 * Interrupts 0-15 are IPI
+	 * 16-28 are reserved
+	 * 29-31 are local.  We allow 30 to be used for the watchdog.
+	 * 32-1020 are global
+	 * 1021-1022 are reserved
+	 * 1023 is "spurious" (no interrupt)
+	 *
+	 * For now, we ignore all local interrupts so only return an interrupt if it's
+	 * between 30 and 1020.  The test_for_ipi routine below will pick up on IPIs.
+	 *
+	 * A simple read from the controller will tell us the number of the highest
+	 * priority enabled interrupt.  We then just need to check whether it is in the
+	 * valid range for an IRQ (30-1020 inclusive).
+	 */
+
+	.macro  get_irqnr_and_base, irqnr, irqstat, base, tmp
+	ldr	\base, =GIC_CPU_VIRT_BASE
+	ldr     \irqstat, [\base, #GIC_CPU_INTACK] /* bits 12-10 = src CPU, 9-0 = int # */
+
+	ldr	\tmp, =1021
+
+	bic     \irqnr, \irqstat, #0x1c00
+
+	cmp     \irqnr, #29
+	cmpcc	\irqnr, \irqnr
+	cmpne	\irqnr, \tmp
+	cmpcs	\irqnr, \irqnr
+	.endm
+
+	/* We assume that irqstat (the raw value of the IRQ acknowledge
+	 * register) is preserved from the macro above.
+	 * If there is an IPI, we immediately signal end of interrupt on the
+	 * controller, since this requires the original irqstat value which
+	 * we won't easily be able to recreate later.
+	 */
+
+	.macro test_for_ipi, irqnr, irqstat, base, tmp
+	bic	\irqnr, \irqstat, #0x1c00
+	cmp	\irqnr, #16
+	strcc	\irqstat, [\base, #GIC_CPU_EOI]
+	cmpcs	\irqnr, \irqnr
+	.endm
+
+	/* As above, this assumes that irqstat and base are preserved.. */
+
+	.macro test_for_ltirq, irqnr, irqstat, base, tmp
+	bic	\irqnr, \irqstat, #0x1c00
+	mov 	\tmp, #0
+	cmp	\irqnr, #29
+	moveq	\tmp, #1
+	streq	\irqstat, [\base, #GIC_CPU_EOI]
+	cmp	\tmp, #0
+	.endm
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/gpio.h b/arch/arm/mach-mmp/include/mach/gpio.h
index 13219eb..d9459dc 100644
--- a/arch/arm/mach-mmp/include/mach/gpio.h
+++ b/arch/arm/mach-mmp/include/mach/gpio.h
@@ -1,8 +1,50 @@
 #ifndef __ASM_MACH_GPIO_H
 #define __ASM_MACH_GPIO_H
 
+#include <mach/addr-map.h>
+#include <mach/irqs.h>
 #include <asm-generic/gpio.h>
 
-#include <mach/cputype.h>
+#define GPIO_REGS_VIRT	(APB_VIRT_BASE + 0x19000)
+
+#define BANK_OFF(n)	(((n) < 3) ? (n) << 2 : 0x100 + (((n) - 3) << 2))
+#define GPIO_REG(x)	(*((volatile u32 *)(GPIO_REGS_VIRT + (x))))
+
+#define NR_BUILTIN_GPIO		IRQ_GPIO_NUM
+
+#define gpio_to_bank(gpio)	((gpio) >> 5)
+#define gpio_to_irq(gpio)	(IRQ_GPIO_START + (gpio))
+#define irq_to_gpio(irq)	((irq) - IRQ_GPIO_START)
+
+
+#define __gpio_is_inverted(gpio)	(0)
+#define __gpio_is_occupied(gpio)	(0)
+
+/* NOTE: these macros are defined here to make optimization of
+ * gpio_{get,set}_value() to work when 'gpio' is a constant.
+ * Usage of these macros otherwise is no longer recommended,
+ * use generic GPIO API whenever possible.
+ */
+#define GPIO_bit(gpio)	(1 << ((gpio) & 0x1f))
+
+#define GPLR(x)		GPIO_REG(BANK_OFF(gpio_to_bank(x)) + 0x00)
+#define GPDR(x)		GPIO_REG(BANK_OFF(gpio_to_bank(x)) + 0x0c)
+#define GPSR(x)		GPIO_REG(BANK_OFF(gpio_to_bank(x)) + 0x18)
+#define GPCR(x)		GPIO_REG(BANK_OFF(gpio_to_bank(x)) + 0x24)
+#define GPER(x)		GPIO_REG(BANK_OFF(gpio_to_bank(x)) + 0x48)
+
+#include <plat/gpio.h>
+
+#define GPIO_EXT0(x)	(NR_BUILTIN_GPIO + (x))
+#define GPIO_EXT1(x)	(NR_BUILTIN_GPIO + 16 + (x))
+
+/* I/O Domains Power Control Registers*/
+#define AIB_IO_POWER_VIRT_ADDR (APB_VIRT_BASE + 0x1e800)
+#define AIB_GPIO2_IO (AIB_IO_POWER_VIRT_ADDR+0xC)
+#define AIB_GPIO3_IO (AIB_IO_POWER_VIRT_ADDR+0x10)
+#define AIB_POWER_SHUTDOWN 0x0
+#define AIB_POWER_TURNON 0x1
+#define FIRST_SECURITY_VALUE  0xBABA
+#define SECOND_SECURITY_VALUE 0xEB10
 
 #endif /* __ASM_MACH_GPIO_H */
diff --git a/arch/arm/mach-mmp/include/mach/hsi_dev.h b/arch/arm/mach-mmp/include/mach/hsi_dev.h
new file mode 100644
index 0000000..e0999fa
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/hsi_dev.h
@@ -0,0 +1,35 @@
+/*
+ * hsi_dev.h
+ *
+ * Marvell HSI Controller
+ *
+ * Copyright:  (C) Copyright 2011 Marvell International Ltd.
+ *              Henry Zhao <xzhao10@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef HSI_DEV_H
+#define HSI_DEV_H
+
+struct hsi_platform_data {
+	int (*hsi_config_int)(void *param);
+};
+
+void __init mmp_register_hsi(struct hsi_platform_data *pdata);
+int hsi_config_int(void *param);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/irqs.h b/arch/arm/mach-mmp/include/mach/irqs.h
index d0e7466..cfa87e2 100644
--- a/arch/arm/mach-mmp/include/mach/irqs.h
+++ b/arch/arm/mach-mmp/include/mach/irqs.h
@@ -80,10 +80,10 @@
 #define IRQ_PXA910_IPC_CP1		22
 #define IRQ_PXA910_IPC_CP2		23
 #define IRQ_PXA910_IPC_CP3		24
-#define IRQ_PXA910_IPC_CP4		25
+#define IRQ_PXA910_CNM			25
 #define IRQ_PXA910_L2_DDR		26
-#define IRQ_PXA910_UART2		27
-#define IRQ_PXA910_UART3		28
+#define IRQ_PXA910_UART0		27
+#define IRQ_PXA910_UART1		28
 #define IRQ_PXA910_AP2_TIMER1		29
 #define IRQ_PXA910_AP2_TIMER2		30
 #define IRQ_PXA910_CP2_TIMER1		31
@@ -109,7 +109,7 @@
 #define IRQ_PXA910_USB2			51
 #define IRQ_PXA910_TWSI1		54
 #define IRQ_PXA910_CP_GPIO		55
-#define IRQ_PXA910_UART1		59	/* Slow UART */
+#define IRQ_PXA910_UART2		59	/* Slow UART */
 #define IRQ_PXA910_AP_PMU		60
 #define IRQ_PXA910_SM_INT		63	/* from PinMux */
 
@@ -119,27 +119,32 @@
 #define IRQ_MMP2_NONE			(-1)
 #define IRQ_MMP2_SSP1			0
 #define IRQ_MMP2_SSP2			1
+#define IRQ_MMP2_PZIPC			2
 #define IRQ_MMP2_SSPA1			2
 #define IRQ_MMP2_SSPA2			3
 #define IRQ_MMP2_PMIC_MUX		4	/* PMIC & Charger */
 #define IRQ_MMP2_RTC_MUX		5
+#define IRQ_MMP2_EPD1			6
 #define IRQ_MMP2_TWSI1			7
 #define IRQ_MMP2_GPU			8
-#define IRQ_MMP2_KEYPAD			9
-#define IRQ_MMP2_ROTARY			10
-#define IRQ_MMP2_TRACKBALL		11
+#define IRQ_MMP2_KEYPAD_MUX		9
+#define IRQ_MMP2_CAWAKE			10
+#define IRQ_MMP2_WDT_2			11
 #define IRQ_MMP2_ONEWIRE		12
 #define IRQ_MMP2_TIMER1			13
 #define IRQ_MMP2_TIMER2			14
 #define IRQ_MMP2_TIMER3			15
 #define IRQ_MMP2_RIPC			16
 #define IRQ_MMP2_TWSI_MUX		17	/* TWSI2 ~ TWSI6 */
+#define IRQ_MMP2_EPD2			18
 #define IRQ_MMP2_HDMI			19
 #define IRQ_MMP2_SSP3			20
 #define IRQ_MMP2_SSP4			21
 #define IRQ_MMP2_USB_HS1		22
 #define IRQ_MMP2_USB_HS2		23
 #define IRQ_MMP2_UART3			24
+#define IRQ_MMP2_ISP_DMA		25
+#define IRQ_MMP2_VMETA			26
 #define IRQ_MMP2_UART1			27
 #define IRQ_MMP2_UART2			28
 #define IRQ_MMP2_MIPI_DSI		29
@@ -163,11 +168,13 @@
 #define IRQ_MMP2_DMA_FIQ		47
 #define IRQ_MMP2_DMA_RIQ		48
 #define IRQ_MMP2_GPIO			49
-#define IRQ_MMP2_SSP_MUX		51
+#define IRQ_MMP2_MIPI_HSI1_MUX		51
 #define IRQ_MMP2_MMC2			52
 #define IRQ_MMP2_MMC3			53
 #define IRQ_MMP2_MMC4			54
-#define IRQ_MMP2_MIPI_HSI		55
+#define IRQ_MMP2_MIPI_HSI0_MUX		55
+#define IRQ_MMP2_IPC2			56
+#define IRQ_MMP2_ISP			57
 #define IRQ_MMP2_MSP			58
 #define IRQ_MMP2_MIPI_SLIM_DMA		59
 #define IRQ_MMP2_PJ4_FREQ_CHG		60
@@ -186,8 +193,14 @@
 #define IRQ_MMP2_RTC_ALARM		(IRQ_MMP2_RTC_BASE + 0)
 #define IRQ_MMP2_RTC			(IRQ_MMP2_RTC_BASE + 1)
 
+/* secondary interrupt of INT #9 */
+#define IRQ_MMP2_KEYPAD_BASE		(IRQ_MMP2_RTC_BASE + 2)
+#define IRQ_MMP2_KPC			(IRQ_MMP2_KEYPAD_BASE + 0)
+#define IRQ_MMP2_ROTORY			(IRQ_MMP2_KEYPAD_BASE + 1)
+#define IRQ_MMP2_TBALL			(IRQ_MMP2_KEYPAD_BASE + 2)
+
 /* secondary interrupt of INT #17 */
-#define IRQ_MMP2_TWSI_BASE		(IRQ_MMP2_RTC_BASE + 2)
+#define IRQ_MMP2_TWSI_BASE		(IRQ_MMP2_KEYPAD_BASE + 3)
 #define IRQ_MMP2_TWSI2			(IRQ_MMP2_TWSI_BASE + 0)
 #define IRQ_MMP2_TWSI3			(IRQ_MMP2_TWSI_BASE + 1)
 #define IRQ_MMP2_TWSI4			(IRQ_MMP2_TWSI_BASE + 2)
@@ -212,17 +225,308 @@
 #define IRQ_MMP2_COMMRX			(IRQ_MMP2_MISC_BASE + 14)
 
 /* secondary interrupt of INT #51 */
-#define IRQ_MMP2_SSP_BASE		(IRQ_MMP2_MISC_BASE + 15)
-#define IRQ_MMP2_SSP1_SRDY		(IRQ_MMP2_SSP_BASE + 0)
-#define IRQ_MMP2_SSP3_SRDY		(IRQ_MMP2_SSP_BASE + 1)
+#define IRQ_MMP2_MIPI_HSI1_BASE		(IRQ_MMP2_MISC_BASE + 15)
+#define IRQ_MMP2_HSI1_CAWAKE		(IRQ_MMP2_MIPI_HSI1_BASE + 0)
+#define IRQ_MMP2_MIPI_HSI_INT1		(IRQ_MMP2_MIPI_HSI1_BASE + 1)
+
+/* secondary interrupt of INT #55 */
+#define IRQ_MMP2_MIPI_HSI0_BASE		(IRQ_MMP2_MIPI_HSI1_BASE + 2)
+#define IRQ_MMP2_HSI0_CAWAKE		(IRQ_MMP2_MIPI_HSI0_BASE + 0)
+#define IRQ_MMP2_MIPI_HSI_INT0		(IRQ_MMP2_MIPI_HSI0_BASE + 1)
+
+#define IRQ_MMP2_MUX_END		(IRQ_MMP2_MIPI_HSI0_BASE + 2)
+
+/*
+ * Interrupt numbers for MMP3
+ */
+#define IRQ_LOCALTIMER			29
+#define IRQ_LOCALWDOG			30
+#define IRQ_LEGACYIRQ			31
+
+#define IRQ_MMP3_START			32
+#define IRQ_MMP3_NONE			(-1)
+#define IRQ_MMP3_SSP1			(IRQ_MMP3_START + 0)
+#define IRQ_MMP3_SSP2			(IRQ_MMP3_START + 1)
+#define IRQ_MMP3_SSPA1			(IRQ_MMP3_START + 2)
+#define IRQ_MMP3_SSPA2			(IRQ_MMP3_START + 3)
+#define IRQ_MMP3_PMIC_MUX		(IRQ_MMP3_START + 4)	/* PMIC & Charger */
+#define IRQ_MMP3_RTC_MUX		(IRQ_MMP3_START + 5)
+#define IRQ_MMP3_HSI3_MUX		(IRQ_MMP3_START + 6)
+#define IRQ_MMP3_TWSI1			(IRQ_MMP3_START + 7)
+#define IRQ_MMP3_GPU_MUX		(IRQ_MMP3_START + 8)
+#define IRQ_MMP3_KEYPAD			(IRQ_MMP3_START + 9)
+#define IRQ_MMP3_ROTARY			(IRQ_MMP3_START + 10)
+#define IRQ_MMP3_TRACKBALL		(IRQ_MMP3_START + 11)
+#define IRQ_MMP3_ONEWIRE		(IRQ_MMP3_START + 12)
+#define IRQ_MMP3_TIMER1			(IRQ_MMP3_START + 13)
+#define IRQ_MMP3_TIMER2			(IRQ_MMP3_START + 14)
+#define IRQ_MMP3_TIMER3			(IRQ_MMP3_START + 15)
+#define IRQ_MMP3_RIPC			(IRQ_MMP3_START + 16)
+#define IRQ_MMP3_TWSI_MUX		(IRQ_MMP3_START + 17)	/* TWSI2 ~ TWSI6 */
+#define IRQ_MMP3_HSI2_MUX		(IRQ_MMP3_START + 18)
+#define IRQ_MMP3_HDMI			(IRQ_MMP3_START + 19)
+#define IRQ_MMP3_SSP3			(IRQ_MMP3_START + 20)
+#define IRQ_MMP3_SSP4			(IRQ_MMP3_START + 21)
+#define IRQ_MMP3_USB_HS1		(IRQ_MMP3_START + 22)
+#define IRQ_MMP3_USB_HS2		(IRQ_MMP3_START + 23)
+#define IRQ_MMP3_UART3			(IRQ_MMP3_START + 24)
+#define IRQ_MMP3_VMETA			(IRQ_MMP3_START + 26)
+#define IRQ_MMP3_UART1			(IRQ_MMP3_START + 27)
+#define IRQ_MMP3_UART2			(IRQ_MMP3_START + 28)
+#define IRQ_MMP3_MIPI_DSI		(IRQ_MMP3_START + 29)
+#define IRQ_MMP3_DXO_MUX		(IRQ_MMP3_START + 30)
+#define IRQ_MMP3_PMU_TIMER1		(IRQ_MMP3_START + 31)
+#define IRQ_MMP3_PMU_TIMER2		(IRQ_MMP3_START + 32)
+#define IRQ_MMP3_PMU_TIMER3		(IRQ_MMP3_START + 33)
+#define IRQ_MMP3_USB_FS			(IRQ_MMP3_START + 34)
+#define IRQ_MMP3_MISC1_MUX		(IRQ_MMP3_START + 35)
+#define IRQ_MMP3_WDT1			(IRQ_MMP3_START + 36)
+#define IRQ_MMP3_NAND_DMA		(IRQ_MMP3_START + 37)
+#define IRQ_MMP3_USIM			(IRQ_MMP3_START + 38)
+#define IRQ_MMP3_MMC			(IRQ_MMP3_START + 39)
+#define IRQ_MMP3_WTM			(IRQ_MMP3_START + 40)
+#define IRQ_MMP3_LCD			(IRQ_MMP3_START + 41)
+#define IRQ_MMP3_CI_MUX			(IRQ_MMP3_START + 42)
+#define IRQ_MMP3_IRE			(IRQ_MMP3_START + 43)
+#define IRQ_MMP3_USB_OTG		(IRQ_MMP3_START + 44)
+#define IRQ_MMP3_NAND			(IRQ_MMP3_START + 45)
+#define IRQ_MMP3_UART4			(IRQ_MMP3_START + 46)
+#define IRQ_MMP3_DMA_FIQ		(IRQ_MMP3_START + 47)
+#define IRQ_MMP3_DMA_RIQ		(IRQ_MMP3_START + 48)
+#define IRQ_MMP3_GPIO			(IRQ_MMP3_START + 49)
+#define IRQ_MMP3_SECURITY		(IRQ_MMP3_START + 50)
+#define IRQ_MMP3_SSP_MUX		(IRQ_MMP3_START + 51)
+#define IRQ_MMP3_MMC2			(IRQ_MMP3_START + 52)
+#define IRQ_MMP3_MMC3			(IRQ_MMP3_START + 53)
+#define IRQ_MMP3_MMC4			(IRQ_MMP3_START + 54)
+#define IRQ_MMP3_HSI1_MUX		(IRQ_MMP3_START + 55)
+#define IRQ_MMP3_IPC2			(IRQ_MMP3_START + 56)
+#define IRQ_MMP3_MISC2_MUX		(IRQ_MMP3_START + 57)
+#define IRQ_MMP3_HSI0_MUX		(IRQ_MMP3_START + 58)
+#define IRQ_MMP3_MIPI_SLIM_DMA		(IRQ_MMP3_START + 59)
+#define IRQ_MMP3_PJ4_FREQ_CHG		(IRQ_MMP3_START + 60)
+#define IRQ_MMP3_MIPI_SLIM		(IRQ_MMP3_START + 62)
+#define IRQ_MMP3_SMC			(IRQ_MMP3_START + 63)
+#define IRQ_MMP3_PMU_INT0		(IRQ_MMP3_START + 86)
+#define IRQ_MMP3_PMU_INT1		(IRQ_MMP3_START + 87)
+#define IRQ_MMP3_PMU_INT2		(IRQ_MMP3_START + 88)
+#ifdef CONFIG_ARM_GIC
+#define IRQ_MMP3_END			(IRQ_MMP3_START + 96)
+#else
+#define IRQ_MMP3_END			(IRQ_MMP3_START + 64)
+#endif
+
+/* secondary interrupt of INT #4 */
+#define IRQ_MMP3_PMIC_BASE		(IRQ_MMP3_END)
+#define IRQ_MMP3_CHARGER		(IRQ_MMP3_PMIC_BASE + 0)
+#define IRQ_MMP3_PMIC			(IRQ_MMP3_PMIC_BASE + 1)
+#define IRQ_MMP3_SPMI			(IRQ_MMP3_PMIC_BASE + 2)
+#define IRQ_MMP3_CHRG_DTC_OUT		(IRQ_MMP3_PMIC_BASE + 3)
+
+/* secondary interrupt of INT #5 */
+#define IRQ_MMP3_RTC_BASE		(IRQ_MMP3_PMIC_BASE + 4)
+#define IRQ_MMP3_RTC_ALARM		(IRQ_MMP3_RTC_BASE + 0)
+#define IRQ_MMP3_RTC			(IRQ_MMP3_RTC_BASE + 1)
+
+/* secondary interrupt of INT #6 */
+#define IRQ_MMP3_HSI3_BASE		(IRQ_MMP3_RTC_BASE + 2)
+#define IRQ_MMP3_ETHER			(IRQ_MMP3_HSI3_BASE + 0)
+#define IRQ_MMP3_UNIPRO3		(IRQ_MMP3_HSI3_BASE + 1)
+#define IRQ_MMP3_HSI3			(IRQ_MMP3_HSI3_BASE + 2)
+
+/* secondary interrupt of INT #8 */
+#define IRQ_MMP3_GPU_BASE		(IRQ_MMP3_HSI3_BASE + 3)
+#define IRQ_MMP3_GC2000			(IRQ_MMP3_GPU_BASE + 0)
+#define IRQ_MMP3_GC360			(IRQ_MMP3_GPU_BASE + 1)
+#define IRQ_MMP3_GC300			(IRQ_MMP3_GPU_BASE + 2)
+
+/* secondary interrupt of INT #17 */
+#define IRQ_MMP3_TWSI_BASE		(IRQ_MMP3_GPU_BASE + 3)
+#define IRQ_MMP3_TWSI2			(IRQ_MMP3_TWSI_BASE + 0)
+#define IRQ_MMP3_TWSI3			(IRQ_MMP3_TWSI_BASE + 1)
+#define IRQ_MMP3_TWSI4			(IRQ_MMP3_TWSI_BASE + 2)
+#define IRQ_MMP3_TWSI5			(IRQ_MMP3_TWSI_BASE + 3)
+#define IRQ_MMP3_TWSI6			(IRQ_MMP3_TWSI_BASE + 4)
+
+/* secondary interrupt of INT #18 */
+#define IRQ_MMP3_HSI2_BASE		(IRQ_MMP3_TWSI_BASE + 5)
+#define IRQ_MMP3_UNIPRO2		(IRQ_MMP3_HSI3_BASE + 0)
+#define IRQ_MMP3_HSI2			(IRQ_MMP3_HSI3_BASE + 1)
+
+/* secondary interrupt of INT #30 */
+#define IRQ_MMP3_DXO_BASE		(IRQ_MMP3_HSI2_BASE + 2)
+#define IRQ_MMP3_ISP_DMA		(IRQ_MMP3_DXO_BASE + 0)
+#define IRQ_MMP3_DXO_ISP		(IRQ_MMP3_DXO_BASE + 1)
+
+/* secondary interrupt of INT #35 */
+#define IRQ_MMP3_MISC1_BASE		(IRQ_MMP3_DXO_BASE + 2)
+#define IRQ_MMP3_MOLTRES_TRIGGER	(IRQ_MMP3_MISC1_BASE + 0)
+#define IRQ_MMP3_MOLTRES_SNP_PERR0	(IRQ_MMP3_MISC1_BASE + 1)
+#define IRQ_MMP3_MOLTRES_SNP_PERR1	(IRQ_MMP3_MISC1_BASE + 2)
+#define IRQ_MMP3_MOLTRES_SNP_PERR2	(IRQ_MMP3_MISC1_BASE + 3)
+#define IRQ_MMP3_MOLTRES_L2CCINTR_MASK	(IRQ_MMP3_MISC1_BASE + 4)
+#define IRQ_MMP3_MOLTRES_L2C_PA_ERR	(IRQ_MMP3_MISC1_BASE + 5)
+#define IRQ_MMP3_MOLTRES_L2C_UERR 	(IRQ_MMP3_MISC1_BASE + 6)
+#define IRQ_MMP3_MOLTRES_L2C_CERR	(IRQ_MMP3_MISC1_BASE + 7)
+#define IRQ_MMP3_MOLTRES_ECNTRINTR	(IRQ_MMP3_MISC1_BASE + 8)
+#define IRQ_MMP3_MOLTRES_PARRTINTR	(IRQ_MMP3_MISC1_BASE + 9)
+#define IRQ_MMP3_MOLTRES_PARRDINTR	(IRQ_MMP3_MISC1_BASE + 10)
+#define IRQ_MMP3_MOLTRES_ERRWTINTR	(IRQ_MMP3_MISC1_BASE + 11)
+#define IRQ_MMP3_MOLTRES_ERRWDINTR	(IRQ_MMP3_MISC1_BASE + 12)
+#define IRQ_MMP3_MOLTRES_COMMTX_2_0	(IRQ_MMP3_MISC1_BASE + 13)
+#define IRQ_MMP3_MOLTRES_COMMRX_2_0	(IRQ_MMP3_MISC1_BASE + 14)
+#define IRQ_MMP3_MOLTRES_ERRRTINTR	(IRQ_MMP3_MISC1_BASE + 15)
+#define IRQ_MMP3_MOLTRES_ERRRDINTR	(IRQ_MMP3_MISC1_BASE + 16)
+#define IRQ_MMP3_MOLTRES_SLVERRINTR	(IRQ_MMP3_MISC1_BASE + 17)
+#define IRQ_MMP3_MOLTRES_DECERRINTR	(IRQ_MMP3_MISC1_BASE + 18)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_0	(IRQ_MMP3_MISC1_BASE + 19)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_1	(IRQ_MMP3_MISC1_BASE + 20)
+#define IRQ_MMP3_MOLTRES_CTI_NCTIIRQ_2	(IRQ_MMP3_MISC1_BASE + 21)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_0	(IRQ_MMP3_MISC1_BASE + 22)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_1	(IRQ_MMP3_MISC1_BASE + 23)
+#define IRQ_MMP3_MOLTRES_NPMUIRQ_2	(IRQ_MMP3_MISC1_BASE + 24)
+#define IRQ_MMP3_MOLTRES_DC_PERR	(IRQ_MMP3_MISC1_BASE + 25)
+#define IRQ_MMP3_MOLTRES_IC_PERR	(IRQ_MMP3_MISC1_BASE + 26)
+#define IRQ_MMP3_PJ4_PMU_INT_0		(IRQ_MMP3_MISC1_BASE + 27)
+#define IRQ_MMP3_PJ4_PMU_INT_1		(IRQ_MMP3_MISC1_BASE + 28)
+#define IRQ_MMP3_PJ4_PMU_INT_2		(IRQ_MMP3_MISC1_BASE + 29)
+#define IRQ_MMP3_USB3_DMA_INTR		(IRQ_MMP3_MISC1_BASE + 30)
+
+/* secondary interrupt of INT #42 */
+#define IRQ_MMP3_CI_BASE		(IRQ_MMP3_MISC1_BASE + 31)
+#define IRQ_MMP3_CCIC2			(IRQ_MMP3_CI_BASE + 0)
+#define IRQ_MMP3_CCIC1			(IRQ_MMP3_CI_BASE + 1)
+
+/* secondary interrupt of INT #51 */
+#define IRQ_MMP3_SSP_BASE		(IRQ_MMP3_CI_BASE + 2)
+#define IRQ_MMP3_SSP1_SRDY		(IRQ_MMP3_SSP_BASE + 0)
+#define IRQ_MMP3_SSP3_SRDY		(IRQ_MMP3_SSP_BASE + 1)
+
+/* secondary interrupt of INT #55 */
+#define IRQ_MMP3_HSI1_BASE		(IRQ_MMP3_SSP_BASE + 2)
+#define IRQ_MMP3_MMC5			(IRQ_MMP3_HSI1_BASE + 0)
+#define IRQ_MMP3_HSI1_RSVD		(IRQ_MMP3_HSI1_BASE + 1)
+#define IRQ_MMP3_UNIPRO1		(IRQ_MMP3_HSI1_BASE + 2)
+#define IRQ_MMP3_HSI1			(IRQ_MMP3_HSI1_BASE + 3)
 
-#define IRQ_MMP2_MUX_END		(IRQ_MMP2_SSP_BASE + 2)
+/* secondary interrupt of INT #57 */
+#define IRQ_MMP3_MISC2_BASE		(IRQ_MMP3_HSI1_BASE + 4)
+#define IRQ_MMP3_DSP_AUDIO_0		(IRQ_MMP3_MISC2_BASE + 0)
+#define IRQ_MMP3_DSP_AUDIO_1		(IRQ_MMP3_MISC2_BASE + 1)
+#define IRQ_MMP3_DSP_AUDIO_2		(IRQ_MMP3_MISC2_BASE + 2)
+#define IRQ_MMP3_DSP_AUDIO_3		(IRQ_MMP3_MISC2_BASE + 3)
+#define IRQ_MMP3_DSP_AUDIO_4		(IRQ_MMP3_MISC2_BASE + 4)
+#define IRQ_MMP3_DSP_AUDIO_5		(IRQ_MMP3_MISC2_BASE + 5)
+#define IRQ_MMP3_DSP_AUDIO_6		(IRQ_MMP3_MISC2_BASE + 6)
+#define IRQ_MMP3_DSP_AUDIO_7		(IRQ_MMP3_MISC2_BASE + 7)
+#define IRQ_MMP3_DSP_AUDIO_8		(IRQ_MMP3_MISC2_BASE + 8)
+#define IRQ_MMP3_DSP_AUDIO_9		(IRQ_MMP3_MISC2_BASE + 9)
+#define IRQ_MMP3_FABRIC_TIMEOUT		(IRQ_MMP3_MISC2_BASE + 10)
+#define IRQ_MMP3_THERMAL_SENSOR		(IRQ_MMP3_MISC2_BASE + 11)
+#define IRQ_MMP3_MPMU			(IRQ_MMP3_MISC2_BASE + 12)
+#define IRQ_MMP3_WDT2			(IRQ_MMP3_MISC2_BASE + 13)
+#define IRQ_MMP3_CORESIGHT		(IRQ_MMP3_MISC2_BASE + 14)
+#define IRQ_MMP3_DDR			(IRQ_MMP3_MISC2_BASE + 15)
+#define IRQ_MMP3_DDR2			(IRQ_MMP3_MISC2_BASE + 16)
+#define IRQ_MMP3_MOLTRES_NHWAFIRQ	(IRQ_MMP3_MISC2_BASE + 17)
+#define IRQ_MMP3_MOLTRES_SF_PERR	(IRQ_MMP3_MISC2_BASE + 18)
+#define IRQ_MMP3_MOLTRES_MMU_PERR	(IRQ_MMP3_MISC2_BASE + 19)
 
+/* secondary interrupt of INT #58 */
+#define IRQ_MMP3_HSI0_BASE		(IRQ_MMP3_MISC2_BASE + 20)
+#define IRQ_MMP3_MSP_CARD		(IRQ_MMP3_HSI0_BASE + 0)
+#define IRQ_MMP3_KERMIT_INT_0		(IRQ_MMP3_HSI0_BASE + 1)
+#define IRQ_MMP3_KERMIT_INT_1		(IRQ_MMP3_HSI0_BASE + 2)
+#define IRQ_MMP3_UNIPRO_INT_0		(IRQ_MMP3_HSI0_BASE + 3)
+#define IRQ_MMP3_HSI0			(IRQ_MMP3_HSI0_BASE + 4)
+
+#define IRQ_MMP3_MUX_END		(IRQ_MMP3_HSI0_BASE + 5)
+
+
+#ifdef CONFIG_ARM_GIC
+#define IRQ_PXA988_START		32
+#else
+#define IRQ_PXA988_START		0
+#endif
+
+#define IRQ_PXA988_NONE			(-1)
+#define IRQ_PXA988_AIRQ			(IRQ_PXA988_START + 0)
+#define IRQ_PXA988_SSP2			(IRQ_PXA988_START + 1)
+#define IRQ_PXA988_SSP1			(IRQ_PXA988_START + 2)
+#define IRQ_PXA988_SSP0			(IRQ_PXA988_START + 3)
+#define IRQ_PXA988_PMIC			(IRQ_PXA988_START + 4)
+#define IRQ_PXA988_RTC			(IRQ_PXA988_START + 5)
+#define IRQ_PXA988_RTC_ALARM		(IRQ_PXA988_START + 6)
+#define IRQ_PXA988_I2C0			(IRQ_PXA988_START + 7) /* I2C_AP */
+#define IRQ_PXA988_GPU			(IRQ_PXA988_START + 8)
+#define IRQ_PXA988_KEYPAD		(IRQ_PXA988_START + 9)
+#define IRQ_PXA988_DMA_INT2		(IRQ_PXA988_START + 10)
+#define IRQ_PXA988_DXO			(IRQ_PXA988_START + 11)
+#define IRQ_PXA988_ONEWIRE		(IRQ_PXA988_START + 12)
+#define IRQ_PXA988_AP_TIMER1		(IRQ_PXA988_START + 13)
+#define IRQ_PXA988_AP_TIMER2_3		(IRQ_PXA988_START + 14)
+#define IRQ_PXA988_ISP_DMA		(IRQ_PXA988_START + 15)
+#define IRQ_PXA988_IPC_AP0		(IRQ_PXA988_START + 16)
+#define IRQ_PXA988_IPC_AP1		(IRQ_PXA988_START + 17)
+#define IRQ_PXA988_IPC_AP2		(IRQ_PXA988_START + 18)
+#define IRQ_PXA988_IPC_AP3		(IRQ_PXA988_START + 19)
+#define IRQ_PXA988_IPC_AP4		(IRQ_PXA988_START + 20)
+#define IRQ_PXA988_IPC_CP0		(IRQ_PXA988_START + 21)
+#define IRQ_PXA988_IPC_CP1		(IRQ_PXA988_START + 22)
+#define IRQ_PXA988_IPC_CP2		(IRQ_PXA988_START + 23)
+#define IRQ_PXA988_IPC_CP3		(IRQ_PXA988_START + 24)
+#define IRQ_PXA988_CODA7542		(IRQ_PXA988_START + 25)
+#define IRQ_PXA988_L2_DDR		(IRQ_PXA988_START + 26)
+#define IRQ_PXA988_UART1		(IRQ_PXA988_START + 27)
+#define IRQ_PXA988_UART2		(IRQ_PXA988_START + 28)
+#define IRQ_PXA988_AP2_TIMER1		(IRQ_PXA988_START + 29)
+#define IRQ_PXA988_AP2_TIMER2_3		(IRQ_PXA988_START + 30)
+#define IRQ_PXA988_CP_TIMER1		(IRQ_PXA988_START + 31)
+#define IRQ_PXA988_CP_TIMER2_3		(IRQ_PXA988_START + 32)
+#define IRQ_PXA988_I2C1			(IRQ_PXA988_START + 33) /* I2C_INT */
+#define IRQ_PXA988_GSSP			(IRQ_PXA988_START + 34)
+#define IRQ_PXA988_WDT			(IRQ_PXA988_START + 35)
+#define IRQ_PXA988_MPMU			(IRQ_PXA988_START + 36)
+#define IRQ_PXA988_SEAGULL_FRQ		(IRQ_PXA988_START + 37)
+#define IRQ_PXA988_MOHAWK_FRQ		(IRQ_PXA988_START + 38)
+#define IRQ_PXA988_MMC			(IRQ_PXA988_START + 39)
+#define IRQ_PXA988_AEU			(IRQ_PXA988_START + 40)
+#define IRQ_PXA988_LCD			(IRQ_PXA988_START + 41)
+#define IRQ_PXA988_CI			(IRQ_PXA988_START + 42)
+#define IRQ_PXA988_IRE			(IRQ_PXA988_START + 43)
+#define IRQ_PXA988_USB1			(IRQ_PXA988_START + 44)
+#define IRQ_PXA988_NAND			(IRQ_PXA988_START + 45)
+#define IRQ_PXA988_HIFI_DMA		(IRQ_PXA988_START + 46)
+#define IRQ_PXA988_DMA_INT0		(IRQ_PXA988_START + 47)
+#define IRQ_PXA988_DMA_INT1		(IRQ_PXA988_START + 48)
+#define IRQ_PXA988_GPIO_AP		(IRQ_PXA988_START + 49)
+#define IRQ_PXA988_GPIO_EDGE		(IRQ_PXA988_START + 50)
+#define IRQ_PXA988_SPH			(IRQ_PXA988_START + 51)
+#define IRQ_PXA988_IPC_SRV0_SE		(IRQ_PXA988_START + 52)
+#define IRQ_PXA988_DSI			(IRQ_PXA988_START + 53)
+#define IRQ_PXA988_I2C2			(IRQ_PXA988_START + 54) /* I2C_CP */
+#define IRQ_PXA988_GPIO_CP		(IRQ_PXA988_START + 55)
+#define IRQ_PXA988_IPC_SRV0_MO		(IRQ_PXA988_START + 56)
+#define IRQ_PXA988_PC_CP		(IRQ_PXA988_START + 57)
+#define IRQ_PXA988_CORESIGHT		(IRQ_PXA988_START + 58)
+#define IRQ_PXA988_UART0		(IRQ_PXA988_START + 59)
+#define IRQ_PXA988_DRO_SENSOR		(IRQ_PXA988_START + 60)
+#define IRQ_PXA988_CORESIGHT2		(IRQ_PXA988_START + 61)
+#define IRQ_PXA988_FABRIC_TO		(IRQ_PXA988_START + 62)
+#define IRQ_PXA988_SM_INT		(IRQ_PXA988_START + 63)
+
+#define IRQ_PXA988_END			(IRQ_PXA988_SM_INT + 1)
+
+#ifdef CONFIG_CPU_MMP3
+#define IRQ_GPIO_START			IRQ_MMP3_MUX_END
+#else
 #define IRQ_GPIO_START			128
-#define MMP_NR_BUILTIN_GPIO		192
-#define MMP_GPIO_TO_IRQ(gpio)		(IRQ_GPIO_START + (gpio))
+#endif
+
+#define IRQ_GPIO_NUM			192
+#define IRQ_GPIO(x)			(IRQ_GPIO_START + (x))
 
-#define IRQ_BOARD_START			(IRQ_GPIO_START + MMP_NR_BUILTIN_GPIO)
-#define MMP_NR_IRQS			IRQ_BOARD_START
+#define IRQ_BOARD_START			(IRQ_GPIO_START + IRQ_GPIO_NUM)
 
+#define NR_IRQS				IRQ_BOARD_START
 #endif /* __ASM_MACH_IRQS_H */
diff --git a/arch/arm/mach-mmp/include/mach/isp_dev.h b/arch/arm/mach-mmp/include/mach/isp_dev.h
new file mode 100644
index 0000000..d9ff450
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/isp_dev.h
@@ -0,0 +1,69 @@
+/*
+ * isp_dev.h
+ *
+ * Marvell DxO ISP - Top level module
+ *	Based on omap3isp
+ *
+ * Copyright:  (C) Copyright 2011 Marvell International Ltd.
+ *              Henry Zhao <xzhao10@marvell.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+
+#ifndef ISP_DEV_H
+#define ISP_DEV_H
+
+enum mvisp_interface_type {
+	ISP_INTERFACE_PARALLEL_0,
+	ISP_INTERFACE_PARALLEL_1,
+	ISP_INTERFACE_CCIC_1,
+	ISP_INTERFACE_CCIC_2,
+};
+
+struct mvisp_subdev_i2c_board_info {
+	struct i2c_board_info *board_info;
+	int i2c_adapter_id;
+};
+
+struct mvisp_v4l2_subdevs_group {
+	struct mvisp_subdev_i2c_board_info *i2c_board_info;
+	enum mvisp_interface_type if_type;
+};
+
+struct mvisp_platform_data {
+	struct mvisp_v4l2_subdevs_group *subdev_group;
+	bool ccic_dummy_ena;
+	bool ispdma_dummy_ena;
+	unsigned int isp_clknum;
+	unsigned int ccic_clknum;
+	char **clkname;
+	int (*mvisp_reset)(void *param);
+	int (*isp_pwr_ctrl)(int);
+};
+
+#ifdef CONFIG_CPU_MMP3
+void __init mmp3_register_dxoisp(struct mvisp_platform_data *pdata);
+int mmp3_isp_reset_hw(void *param);
+int isppwr_power_control(int on);
+#endif
+
+#ifdef CONFIG_CPU_PXA988
+void __init pxa988_register_dxoisp(struct mvisp_platform_data *pdata);
+int pxa988_isp_reset_hw(void *param);
+int pxa988_isp_power_control(int on);
+#endif
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/memory.h b/arch/arm/mach-mmp/include/mach/memory.h
new file mode 100644
index 0000000..ca6fa45
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/memory.h
@@ -0,0 +1,29 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/memory.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_MEMORY_H
+#define __ASM_MACH_MEMORY_H
+
+#if defined(CONFIG_CRASH_DUMP)
+#define PLAT_PHYS_OFFSET	UL(0x06000000)
+#elif defined(CONFIG_TZ_HYPERVISOR)
+#define PLAT_PHYS_OFFSET	UL(0x00200000)
+#else
+#define PLAT_PHYS_OFFSET	UL(0x00000000)
+#endif
+
+/*
+ * Restrict DMA-able region to workaround silicon bug.  The bug
+ * restricts buffers available for DMA to AXI fabric 2 to be
+ * below 64M
+ */
+#ifdef CONFIG_ZONE_DMA
+#define ARM_DMA_ZONE_SIZE      SZ_64M
+#endif
+
+#endif /* __ASM_MACH_MEMORY_H */
diff --git a/arch/arm/mach-mmp/include/mach/mfp-mmp2.h b/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
index 4ad3862..c28caeb 100644
--- a/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
+++ b/arch/arm/mach-mmp/include/mach/mfp-mmp2.h
@@ -1,12 +1,7 @@
 #ifndef __ASM_MACH_MFP_MMP2_H
 #define __ASM_MACH_MFP_MMP2_H
 
-#include <mach/mfp.h>
-
-#define MFP_DRIVE_VERY_SLOW	(0x0 << 13)
-#define MFP_DRIVE_SLOW		(0x2 << 13)
-#define MFP_DRIVE_MEDIUM	(0x4 << 13)
-#define MFP_DRIVE_FAST		(0x6 << 13)
+#include <plat/mfp.h>
 
 /* GPIO */
 #define GPIO0_GPIO	MFP_CFG(GPIO0, AF0)
@@ -178,6 +173,21 @@
 #define GPIO166_GPIO	MFP_CFG(GPIO166, AF1)
 #define GPIO167_GPIO	MFP_CFG(GPIO167, AF1)
 #define GPIO168_GPIO	MFP_CFG(GPIO168, AF1)
+#define GPIO171_GPIO	MFP_CFG(GPIO171, AF0)
+
+/* touch */
+#define GPIO153_TOUCH_3V3	MFP_CFG_LPM(GPIO153, AF1, DRIVE_HIGH)
+#define GPIO91_TOUCH_SLP	MFP_CFG_LPM(GPIO91, AF0, FLOAT)
+
+/* platform version ID */
+#define GPIO125_VERS0	MFP_CFG_LPM(GPIO125, AF0, PULL_LOW)
+#define GPIO126_VERS1	MFP_CFG_LPM(GPIO126, AF0, PULL_LOW)
+#define GPIO127_VERS2	MFP_CFG_LPM(GPIO127, AF0, PULL_LOW)
+#define GPIO128_VERS3	MFP_CFG_LPM(GPIO128, AF0, PULL_LOW)
+
+#define GPIO16_BOARD_VERS0	MFP_CFG_ALL(GPIO16, AF0, DS01X, DEFAULT, PULL_FLOAT)
+#define GPIO17_BOARD_VERS1	MFP_CFG_ALL(GPIO17, AF0, DS01X, DEFAULT, PULL_FLOAT)
+#define GPIO18_BOARD_VERS2	MFP_CFG_ALL(GPIO18, AF0, DS01X, DEFAULT, PULL_FLOAT)
 
 /* DFI */
 #define GPIO108_DFI_D15		MFP_CFG(GPIO108, AF0)
@@ -231,25 +241,37 @@
 #define GPIO49_UART2_CTS	MFP_CFG(GPIO49, AF1)
 #define GPIO50_UART2_RTS	MFP_CFG(GPIO50, AF1)
 
+#define GPIO74_UART2_RXD	MFP_CFG(GPIO74, AF5)
+#define GPIO75_UART2_TXD	MFP_CFG(GPIO75, AF5)
+#define GPIO76_UART2_CTS	MFP_CFG(GPIO76, AF5)
+#define GPIO77_UART2_RTS	MFP_CFG(GPIO77, AF5)
+
 /* UART3 */
 #define GPIO51_UART3_RXD	MFP_CFG(GPIO51, AF1)
 #define GPIO52_UART3_TXD	MFP_CFG(GPIO52, AF1)
 #define GPIO53_UART3_CTS	MFP_CFG(GPIO53, AF1)
 #define GPIO54_UART3_RTS	MFP_CFG(GPIO54, AF1)
 
+/*PWM3*/
+#define GPIO53_PWM3		MFP_CFG_X(GPIO53, AF5, SLOW, PULL_LOW)
+/*PWM4 for QSeven rev 1 board not populated*/
+#define GPIO54_PWM4		MFP_CFG_X(GPIO54, AF5, SLOW, PULL_LOW)
+
 /* MMC1 */
-#define GPIO124_MMC1_DAT7	MFP_CFG_DRV(GPIO124, AF1, FAST)
-#define GPIO125_MMC1_DAT6	MFP_CFG_DRV(GPIO125, AF1, FAST)
-#define GPIO129_MMC1_DAT5	MFP_CFG_DRV(GPIO129, AF1, FAST)
-#define GPIO130_MMC1_DAT4	MFP_CFG_DRV(GPIO130, AF1, FAST)
-#define GPIO131_MMC1_DAT3	MFP_CFG_DRV(GPIO131, AF1, FAST)
-#define GPIO132_MMC1_DAT2	MFP_CFG_DRV(GPIO132, AF1, FAST)
-#define GPIO133_MMC1_DAT1	MFP_CFG_DRV(GPIO133, AF1, FAST)
-#define GPIO134_MMC1_DAT0	MFP_CFG_DRV(GPIO134, AF1, FAST)
-#define GPIO136_MMC1_CMD	MFP_CFG_DRV(GPIO136, AF1, FAST)
-#define GPIO139_MMC1_CLK	MFP_CFG_DRV(GPIO139, AF1, FAST)
-#define GPIO140_MMC1_CD		MFP_CFG_DRV(GPIO140, AF1, FAST)
-#define GPIO141_MMC1_WP		MFP_CFG_DRV(GPIO141, AF1, FAST)
+#define GPIO124_MMC1_DAT7	MFP_CFG_DRV(GPIO124, AF1, SLOW)
+#define GPIO125_MMC1_DAT6	MFP_CFG_DRV(GPIO125, AF1, SLOW)
+#define GPIO129_MMC1_DAT5	MFP_CFG_DRV(GPIO129, AF1, SLOW)
+#define GPIO130_MMC1_DAT4	MFP_CFG_DRV(GPIO130, AF1, SLOW)
+#define GPIO131_MMC1_DAT3	MFP_CFG_DRV(GPIO131, AF1, SLOW)
+#define GPIO132_MMC1_DAT2	MFP_CFG_DRV(GPIO132, AF1, SLOW)
+#define GPIO133_MMC1_DAT1	MFP_CFG_DRV(GPIO133, AF1, SLOW)
+#define GPIO134_MMC1_DAT0	MFP_CFG_DRV(GPIO134, AF1, SLOW)
+#define GPIO136_MMC1_CMD	MFP_CFG_DRV(GPIO136, AF1, SLOW)
+#define GPIO139_MMC1_CLK	MFP_CFG_DRV(GPIO139, AF1, SLOW)
+#define GPIO140_MMC1_CD		MFP_CFG_DRV(GPIO140, AF1, SLOW)
+#define GPIO141_MMC1_WP		MFP_CFG_DRV(GPIO141, AF1, SLOW)
+#define GPIO135_MMC1_CLK	MFP_CFG_DRV(GPIO135, AF1, SLOW)
+#define GPIO95_SDMMC_PEN        MFP_CFG(GPIO95, AF0)
 
 /*MMC2*/
 #define GPIO37_MMC2_DAT3	MFP_CFG_DRV(GPIO37, AF1, FAST)
@@ -271,6 +293,17 @@
 #define GPIO112_MMC3_CMD	MFP_CFG_DRV(GPIO112, AF2, FAST)
 #define GPIO151_MMC3_CLK	MFP_CFG_DRV(GPIO151, AF2, FAST)
 
+#define GPIO108_MMC3_DAT7	MFP_CFG_DRV(GPIO108, AF2, FAST)
+#define GPIO109_MMC3_DAT6	MFP_CFG_DRV(GPIO109, AF2, FAST)
+#define GPIO161_MMC3_DAT5	MFP_CFG_DRV(GPIO161, AF2, FAST)
+#define GPIO163_MMC3_DAT4	MFP_CFG_DRV(GPIO163, AF2, FAST)
+#define GPIO111_MMC3_DAT3	MFP_CFG_DRV(GPIO111, AF2, FAST)
+#define GPIO110_MMC3_DAT2	MFP_CFG_DRV(GPIO110, AF2, FAST)
+#define GPIO162_MMC3_DAT1	MFP_CFG_DRV(GPIO162, AF2, FAST)
+#define GPIO164_MMC3_DAT0	MFP_CFG_DRV(GPIO164, AF2, FAST)
+#define GPIO145_MMC3_CMD	MFP_CFG_DRV(GPIO145, AF2, FAST)
+#define GPIO146_MMC3_CLK	MFP_CFG_DRV(GPIO146, AF2, FAST)
+
 /* LCD */
 #define GPIO74_LCD_FCLK		MFP_CFG_DRV(GPIO74, AF1, FAST)
 #define GPIO75_LCD_LCLK		MFP_CFG_DRV(GPIO75, AF1, FAST)
@@ -306,14 +339,30 @@
 #define GPIO97_SPI_DOUT		MFP_CFG_DRV(GPIO97, AF3, FAST)
 #define GPIO98_LCD_RST		MFP_CFG_DRV(GPIO98, AF0, FAST)
 
+#define GPIO00_SPI_DCLK		MFP_CFG_DRV(GPIO0, AF3, FAST)
+#define GPIO01_SPI_CS0		MFP_CFG_DRV(GPIO1, AF3, FAST)
+#define GPIO02_SPI_DIN		MFP_CFG_DRV(GPIO2, AF3, FAST)
+#define GPIO03_SPI_DOUT		MFP_CFG_DRV(GPIO3, AF3, FAST)
+
+#define GPIO17_BL_EN		MFP_CFG_X(GPIO17, AF0, FAST, DRIVE_LOW)
+#define GPIO83_LCD_RST		MFP_CFG_X(GPIO83, AF0, FAST, DRIVE_LOW)
+#define GPIO89_5V_EN		MFP_CFG_X(GPIO89, AF0, FAST, DRIVE_LOW)
 #define GPIO114_MN_CLK_OUT	MFP_CFG_DRV(GPIO114, AF1, FAST)
+#define GPIO152_VLCD_3V3	MFP_CFG_X(GPIO152, AF1, FAST, DRIVE_LOW)
+
+#define GPIO49_LCD_RST_N	MFP_CFG_X(GPIO49, AF0, FAST, DRIVE_LOW)
+#define GPIO50_LCD_PWM		MFP_CFG_DRV(GPIO50, AF3, FAST)
 
+#define GPIO59_LED_R_CTRL	MFP_CFG(GPIO59, AF0) | MFP_PULL_HIGH
+#define GPIO60_LED_G_CTRL	MFP_CFG(GPIO60, AF0) | MFP_PULL_HIGH
+#define GPIO61_LED_B_CTRL	MFP_CFG(GPIO61, AF0) | MFP_PULL_HIGH
 /*LCD TV path*/
 #define GPIO124_LCD_DD24	MFP_CFG_DRV(GPIO124, AF2, FAST)
 #define GPIO125_LCD_DD25	MFP_CFG_DRV(GPIO125, AF2, FAST)
 #define GPIO126_LCD_DD33	MFP_CFG_DRV(GPIO126, AF2, FAST)
 #define GPIO127_LCD_DD26	MFP_CFG_DRV(GPIO127, AF2, FAST)
 #define GPIO128_LCD_DD27	MFP_CFG_DRV(GPIO128, AF2, FAST)
+#define GPIO128_LCD_RST		MFP_CFG_DRV(GPIO128, AF0, FAST) /* MMP3 A0*/
 #define GPIO129_LCD_DD28	MFP_CFG_DRV(GPIO129, AF2, FAST)
 #define GPIO130_LCD_DD29	MFP_CFG_DRV(GPIO130, AF2, FAST)
 #define GPIO135_LCD_DD30	MFP_CFG_DRV(GPIO135, AF2, FAST)
@@ -323,18 +372,33 @@
 #define GPIO141_LCD_DD35	MFP_CFG_DRV(GPIO141, AF2, FAST)
 
 /* I2C */
+#define TWSI1_SCL		MFP_CFG_DRV(TWSI1_SCL, AF0, SLOW)
+#define TWSI1_SDA		MFP_CFG_DRV(TWSI1_SDA, AF0, SLOW)
 #define GPIO43_TWSI2_SCL	MFP_CFG_DRV(GPIO43, AF1, SLOW)
 #define GPIO44_TWSI2_SDA	MFP_CFG_DRV(GPIO44, AF1, SLOW)
 #define GPIO71_TWSI3_SCL	MFP_CFG_DRV(GPIO71, AF1, SLOW)
 #define GPIO72_TWSI3_SDA	MFP_CFG_DRV(GPIO72, AF1, SLOW)
+#define HDA_RST_N_GPIO_79	MFP_CFG(GPIO79, AF0)
+
+/*QSeven rev 1 board TWSI2 and TWSI3*/
+#define GPIO55_TWSI2_SCL	MFP_CFG_DRV(GPIO55, AF5 , SLOW)
+#define GPIO56_TWSI2_SDA	MFP_CFG_DRV(GPIO56, AF5, SLOW)
+#define GPIO95_TWSI3_SCL	MFP_CFG_DRV(GPIO95, AF2 , SLOW)
+#define GPIO96_TWSI3_SDA	MFP_CFG_DRV(GPIO96, AF2, SLOW)
+
 #define TWSI4_SCL		MFP_CFG_DRV(TWSI4_SCL, AF0, SLOW)
 #define TWSI4_SDA		MFP_CFG_DRV(TWSI4_SDA, AF0, SLOW)
 #define GPIO99_TWSI5_SCL	MFP_CFG_DRV(GPIO99, AF4, SLOW)
 #define GPIO100_TWSI5_SDA	MFP_CFG_DRV(GPIO100, AF4, SLOW)
 #define GPIO97_TWSI6_SCL	MFP_CFG_DRV(GPIO97, AF2, SLOW)
 #define GPIO98_TWSI6_SDA	MFP_CFG_DRV(GPIO98, AF2, SLOW)
+#define GPIO47_TWSI6_SCL	MFP_CFG_DRV(GPIO47, AF3, SLOW)
+#define GPIO48_TWSI6_SDA	MFP_CFG_DRV(GPIO48, AF3, SLOW)
+#define GPIO53_TWSI2_SCL	MFP_CFG_DRV(GPIO53, AF2, SLOW)
+#define GPIO54_TWSI2_SDA	MFP_CFG_DRV(GPIO54, AF2, SLOW)
 
 /* SSPA1 */
+#define GPIO24_AUDPLL_SYSCLK	MFP_CFG(GPIO24, AF5)
 #define GPIO24_I2S_SYSCLK	MFP_CFG(GPIO24, AF1)
 #define GPIO25_I2S_BITCLK	MFP_CFG(GPIO25, AF1)
 #define GPIO26_I2S_SYNC		MFP_CFG(GPIO26, AF1)
@@ -348,6 +412,27 @@
 #define GPIO35_SSPA2_TXD	MFP_CFG(GPIO35, AF1)
 #define GPIO36_SSPA2_RXD	MFP_CFG(GPIO36, AF1)
 
+#define GPIO06_WM8994_LDOEN	MFP_CFG(GPIO6, AF0) | MFP_LPM_PULL_HIGH
+
+/* SSP1 QSEVEN REV 1*/
+
+#define SSP1_RXD_GPIO_43	MFP_CFG(GPIO43, AF3)
+#define SSP1_TXD_GPIO_44	MFP_CFG(GPIO44, AF3)
+#define SSP1_CLK_GPIO_45	MFP_CFG(GPIO45, AF3)
+#define SSP1_FRM_GPIO_46	MFP_CFG(GPIO46, AF3)
+
+/* SSP3 */
+#define GPIO74_SSP_CLK		MFP_CFG(GPIO74, AF4)
+#define GPIO75_SSP_FRM		MFP_CFG(GPIO75, AF4)
+#define GPIO76_SSP_TXD		MFP_CFG(GPIO76, AF4)
+#define GPIO77_SSP_RXD		MFP_CFG(GPIO77, AF4)
+
+/* SSP4 */
+#define GPIO78_SSP_CLK		MFP_CFG(GPIO78, AF5)
+#define GPIO79_SSP_FRM		MFP_CFG(GPIO79, AF5)
+#define GPIO80_SSP_TXD		MFP_CFG(GPIO80, AF5)
+#define GPIO81_SSP_RXD		MFP_CFG(GPIO81, AF5)
+
 /* Keypad */
 #define GPIO00_KP_MKIN0		MFP_CFG(GPIO0, AF1)
 #define GPIO01_KP_MKOUT0	MFP_CFG(GPIO1, AF1)
@@ -365,31 +450,96 @@
 #define GPIO13_KP_MKOUT6	MFP_CFG(GPIO13, AF1)
 #define GPIO14_KP_MKIN7		MFP_CFG(GPIO14, AF1)
 #define GPIO15_KP_MKOUT7	MFP_CFG(GPIO15, AF1)
-#define GPIO16_KP_DKIN0		MFP_CFG(GPIO16, AF1)
-#define GPIO17_KP_DKIN1		MFP_CFG(GPIO17, AF1)
-#define GPIO18_KP_DKIN2		MFP_CFG(GPIO18, AF1)
-#define GPIO19_KP_DKIN3		MFP_CFG(GPIO19, AF1)
-#define GPIO20_KP_DKIN4		MFP_CFG(GPIO20, AF1)
-#define GPIO21_KP_DKIN5		MFP_CFG(GPIO21, AF1)
-#define GPIO22_KP_DKIN6		MFP_CFG(GPIO22, AF1)
-#define GPIO23_KP_DKIN7		MFP_CFG(GPIO23, AF1)
+#define GPIO16_KP_DKIN0		MFP_CFG_LPM(GPIO16, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO17_KP_DKIN1		MFP_CFG_LPM(GPIO17, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO18_KP_DKIN2		MFP_CFG_LPM(GPIO18, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO19_KP_DKIN3		MFP_CFG_LPM(GPIO19, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO20_KP_DKIN4		MFP_CFG_LPM(GPIO20, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO21_KP_DKIN5		MFP_CFG_LPM(GPIO21, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO22_KP_DKIN6		MFP_CFG_LPM(GPIO22, AF1, PULL_HIGH) | MFP_PULL_HIGH
+#define GPIO23_KP_DKIN7		MFP_CFG_LPM(GPIO23, AF1, PULL_HIGH) | MFP_PULL_HIGH
 
 /* CAMERA */
-#define GPIO59_CCIC_IN7		MFP_CFG_DRV(GPIO59, AF1, FAST)
-#define GPIO60_CCIC_IN6		MFP_CFG_DRV(GPIO60, AF1, FAST)
-#define GPIO61_CCIC_IN5		MFP_CFG_DRV(GPIO61, AF1, FAST)
-#define GPIO62_CCIC_IN4		MFP_CFG_DRV(GPIO62, AF1, FAST)
-#define GPIO63_CCIC_IN3		MFP_CFG_DRV(GPIO63, AF1, FAST)
-#define GPIO64_CCIC_IN2		MFP_CFG_DRV(GPIO64, AF1, FAST)
-#define GPIO65_CCIC_IN1		MFP_CFG_DRV(GPIO65, AF1, FAST)
-#define GPIO66_CCIC_IN0		MFP_CFG_DRV(GPIO66, AF1, FAST)
-#define GPIO67_CAM_HSYNC	MFP_CFG_DRV(GPIO67, AF1, FAST)
-#define GPIO68_CAM_VSYNC	MFP_CFG_DRV(GPIO68, AF1, FAST)
+#define GPIO73_CAM_MCLK		MFP_CFG_DRV(GPIO73, AF4, FAST)
 #define GPIO69_CAM_MCLK		MFP_CFG_DRV(GPIO69, AF1, FAST)
-#define GPIO70_CAM_PCLK		MFP_CFG_DRV(GPIO70, AF1, FAST)
 
 /* PMIC */
 #define PMIC_PMIC_INT		MFP_CFG(PMIC_INT, AF0)
 
+/* HDMI */
+#define GPIO59_HDMI_DET         MFP_CFG(GPIO59, AF0)
+#define GPIO43_HDMI_DET         MFP_CFG(GPIO43, AF0)
+#define GPIO46_HDMI_DET 	MFP_CFG(GPIO46, AF0) | MFP_PULL_HIGH | MFP_LPM_PULL_HIGH
+#define GPIO54_HDMI_CEC         MFP_CFG(GPIO54, AF4) | MFP_PULL_HIGH
+#define GPIO94_HDMI_LS_OE	MFP_CFG(GPIO94, AF0)
+#define GPIO95_HDMI_CT_HPD	MFP_CFG(GPIO95, AF0)
+
+/* HDMI CEC - Orchid Board */
+#define GPIO113_HDMI_CEC	MFP_CFG(GPIO113, AF5) | MFP_PULL_HIGH
+
+/* OTG VBUS_EN - Abilene A0 Board */
+#define GPIO62_VBUS_EN		MFP_CFG(GPIO62, AF0)
+
+/* OTG VBUS_EN - YellowStone A0 Board */
+#define GPIO82_VBUS_EN		MFP_CFG(GPIO82, AF0)
+
+/* HSIC1 RESET - Abilene A0 Board */
+#define GPIO96_HSIC_RESET	MFP_CFG_LPM(GPIO96, AF0, DRIVE_LOW)
+
+/* BB Power Enable - Abilene Rev.5 */
+#define GPIO63_BB_POWER_EN	MFP_CFG(GPIO63, AF0)
+
+/* Codec */
+#define GPIO45_WM8994_LDOEN	MFP_CFG(GPIO45, AF0)
+
+/* TOUCH */
+#define GPIO101_TSI_INT		MFP_CFG_LPM(GPIO101, AF0, PULL_LOW)
+#define GPIO78_TSI_OE_N		MFP_CFG_LPM(GPIO78, AF0, PULL_LOW) | MFP_PULL_LOW
+#define TSI_INT_N		MFP_CFG(GPIO78, AF0) /* QSeven */
+
+/* GPS */
+#define GPIO14_GPS_ON		MFP_CFG_LPM(GPIO14, AF0, PULL_LOW)
+#define GPIO15_GPS_RST		MFP_CFG_LPM(GPIO15, AF0, PULL_LOW)
+
+/* LED */
+#define GPIO84_LED_O		MFP_CFG_LPM(GPIO84, AF0, PULL_HIGH)
+#define GPIO85_LED_B		MFP_CFG_LPM(GPIO85, AF0, PULL_HIGH)
+#define GPIO86_LED_R		MFP_CFG_LPM(GPIO86, AF0, PULL_HIGH)
+#define GPIO87_LED_G		MFP_CFG_LPM(GPIO87, AF0, PULL_HIGH)
+
+/* HSI */
+#define HSI_ACWAKE              MFP_CFG(GPIO115, AF2)
+#define HSI_ACREADY             MFP_CFG(GPIO116, AF2)
+#define HSI_ACFLAG              MFP_CFG(GPIO117, AF2)
+#define HSI_ACDATA              MFP_CFG(GPIO118, AF2)
+#define HSI_CAWAKE              MFP_CFG(GPIO119, AF2)
+#define HSI_CAREADY             MFP_CFG(GPIO120, AF2)
+#define HSI_CAFLAG              MFP_CFG(GPIO121, AF2)
+#define HSI_CADATA              MFP_CFG(GPIO122, AF2)
+
+/*ULPI for QSEVEN rev 1 board*/
+#define ULPI_DATA_0_GPIO_66	MFP_CFG(GPIO66, AF2)
+#define ULPI_DATA_1_GPIO_65	MFP_CFG(GPIO65, AF2)
+#define ULPI_DATA_2_GPIO_64	MFP_CFG(GPIO64, AF2)
+#define ULPI_DATA_3_GPIO_63	MFP_CFG(GPIO63, AF2)
+#define ULPI_DATA_4_GPIO_62	MFP_CFG(GPIO62, AF2)
+#define ULPI_DATA_5_GPIO_61	MFP_CFG(GPIO61, AF2)
+#define ULPI_DATA_6_GPIO_60	MFP_CFG(GPIO60, AF2)
+#define ULPI_DATA_7_GPIO_59	MFP_CFG(GPIO59, AF2)
+#define ULPI_RST_N_GPIO_71	MFP_CFG(GPIO71, AF0)
+#define ULPI_CLK_GPIO_70	MFP_CFG(GPIO70, AF2)
+#define ULPI_DIR_GPIO_69	MFP_CFG(GPIO69, AF2)
+#define ULPI_NXT_GPIO_68	MFP_CFG(GPIO68, AF2)
+#define ULPI_STP_GPIO_67	MFP_CFG(GPIO67, AF2)
+
+/* QSeven - WIFI */
+#define WIFI_32K_CLK_OUT	MFP_CFG(GPIO123, AF3)
+
+/* AP CP - Orchid */
+#define AP_RESET_OUT_N		MFP_CFG(GPIO154, AF1) | MFP_PULL_LOW
+
+/* smart bat - Orchid */
+#define SMART_BAT		MFP_CFG(GPIO123, AF2) | MFP_PULL_HIGH
+
 #endif /* __ASM_MACH_MFP_MMP2_H */
 
diff --git a/arch/arm/mach-mmp/include/mach/mmp-zmq.h b/arch/arm/mach-mmp/include/mach/mmp-zmq.h
new file mode 100644
index 0000000..f9fc203
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp-zmq.h
@@ -0,0 +1,166 @@
+/*
+ *
+ * Marvell MMP2 ZSP message queue driver.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _MMP2_MSG_QUEUE_H_
+#define _MMP2_MSG_QUEUE_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZMQ_DEVN_DIAGNOSE	"zmq_diagnose"
+#define ZMQ_DEVN_CODEC		"zmq_codec"
+#define ZMQ_DEVN_PLAYBACK_0	"zmq_playback0"
+#define ZMQ_DEVN_CAPTURE_0	"zmq_capture0"
+#define ZMQ_DEVN_PLAYBACK_1	"zmq_playback1"
+#define ZMQ_DEVN_CAPTURE_1	"zmq_capture1"
+
+typedef struct {
+	u32	_input;
+	u32	_output;
+	u32	_length;
+} zmq_ioc_pmemcpy_param_t;
+typedef struct {
+	u32	_type_id;
+} zmq_ioc_bind_param_t;
+enum {
+	ZMQ_IOC_BR_OP_CREATE		= 0,
+	ZMQ_IOC_BR_OP_DESTORY		= 1,
+	ZMQ_IOC_BR_OP_GET_BUFFER	= 2,
+	ZMQ_IOC_BR_OP_DELIVER_BUFFER	= 3,
+};
+typedef struct {
+	union{
+		struct {
+			u32	_op	:8;	/* operations */
+			u32	_dir	:1;	/* direction */
+			u32		:22;	/* reserved */
+			u32	_stat	:1;	/* return val */
+		};
+		u32	_val;
+	};
+	union {
+		struct {
+			u32	_physaddr;	/* in: DMA buffer */
+			u32	_size;		/* in: range size, on creation */
+			u32	_low;		/* in: water marker, on creation */
+		}; /* creation */
+		struct {
+			u32	_usize;		/* out: user usable size, in: user deliver size */
+			u32	_upos;		/* out: user usable position */
+		}; /* get buffer */
+		struct {
+			u32	_vsize;		/* in: delivered buffer */
+		}; /* deliver buffer */
+	};
+} zmq_ioc_br_param_t;
+typedef struct {
+	u32	_handle;
+	void*	_handlex;
+} zmq_ioc_session_handle_t;
+
+#define ZMQ_MSG_MK(cid, mid) ((((mid)&0x1f) << 3) | (((cid)&0x7) << 0))
+enum
+{
+	ZMQ_DEV_PORT_OFFSET		= 0x100,
+	ZMQ_DEV_MAJOR			= 300,
+	ZMQ_DEV_IOC_MAGIC		= ZMQ_DEV_MAJOR,
+	ZMQ_DEV_IOC_MAX			= 5,
+
+	ZMQ_IOC_BIND			= _IOW(ZMQ_DEV_IOC_MAGIC, 1, int ),
+	ZMQ_IOC_MDMA_PMEMCPY		= _IOW(ZMQ_DEV_IOC_MAGIC, 2, int ),
+	ZMQ_IOC_ZSP_SOFT_RESET		= _IOW(ZMQ_DEV_IOC_MAGIC, 3, int ),
+	ZMQ_IOC_BR_REQ			= _IOW(ZMQ_DEV_IOC_MAGIC, 4, int ),
+	ZMQ_IOC_GET_SESSION_HANDLE	= _IOW(ZMQ_DEV_IOC_MAGIC, 5, int ),
+	ZMQ_IOC_SET_SESSION_MASTER	= _IOW(ZMQ_DEV_IOC_MAGIC, 6, int ),
+	ZMQ_IOC_CLR_SESSION_MASTER	= _IOW(ZMQ_DEV_IOC_MAGIC, 7, int ),
+
+	/* limit the numbers just for a simple mapping deliver */
+	ZMQ_MSG_CLASS_NUMBER		= 6,
+	ZMQ_MSG_MODULE_NUMBER		= 8,
+	ZMQ_MSG_SESSION_NUMBER		= 8,
+	ZMQ_MSG_SEND_DEFAULT_RETRY	= 100,
+
+	ZMQ_MSG_CLASS_CODEC		= 0,
+	ZMQ_MSG_ID_CODEC		= ZMQ_MSG_MK(ZMQ_MSG_CLASS_CODEC, 0),
+
+	ZMQ_MSG_CLASS_RENDER		= 1,
+	ZMQ_MSG_ID_RENDER_PLAYBACK_0	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 0),
+	ZMQ_MSG_ID_RENDER_CAPTURE_0	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 1),
+	ZMQ_MSG_ID_RENDER_PLAYBACK_1	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 2),
+	ZMQ_MSG_ID_RENDER_CAPTURE_1	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 3),
+	ZMQ_MSG_ID_RENDER_PLAYBACK_6CH	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 4),
+	ZMQ_MSG_ID_RENDER_PLAYBACK_8CH	= ZMQ_MSG_MK(ZMQ_MSG_CLASS_RENDER, 5),
+
+	ZMQ_MSG_CLASS_SYS		= 3,
+	ZMQ_MSG_ID_STREAM		= ZMQ_MSG_MK(ZMQ_MSG_CLASS_SYS, 0),
+	ZMQ_MSG_ID_TEST			= ZMQ_MSG_MK(ZMQ_MSG_CLASS_SYS, 3),
+	ZMQ_MSG_ID_DAI_0		= ZMQ_MSG_MK(ZMQ_MSG_CLASS_SYS, 4),
+	ZMQ_MSG_ID_DAI_1		= ZMQ_MSG_MK(ZMQ_MSG_CLASS_SYS, 5),
+
+};
+
+enum {
+	ZMQ_DATA_FLOW_EVTS_LOW		= (1u << 0),
+	ZMQ_DATA_FLOW_EVTS_AUTO_STOP	= (1u << 1),
+
+	ZMQ_DATA_FLOW_DIR_P2Z		= (0u << 0),
+	ZMQ_DATA_FLOW_DIR_Z2P		= (1u << 0),
+};
+typedef struct {
+	u32	_addr;		/* buffer address (physical) */
+	u32	_len;		/* buffer length */
+	u32	_low;		/* low point of this descriptor */
+	u32	_evts	:15;	/* event map */
+	u32	_dir	:1;	/* direction, 0 in(pj->zsp), 1 out(zsp->pj) */
+	u32	_qclr	:16;	/* response only, cleared descriptor number from last notification */
+} zmq_data_flow_t;
+typedef void (* zmq_pfn_data_flow_cb)(zmq_data_flow_t *, void *);
+typedef struct {
+	u32			_upos;		/* offset */
+	u32			_size;
+	u32			_low;
+	u32			_start;
+} kzmq_data_flow_br_t;
+typedef void (* kzmq_pfn_data_flow_br_cb)(zmq_data_flow_t *, kzmq_data_flow_br_t *);
+
+typedef struct {
+	volatile u32	_class_id	:3;
+	volatile u32	_module_id	:5;
+	volatile u32	_session	:8;
+	volatile u32	_reserved	:16;
+} kzmq_info_t;
+
+void *	kzmq_open(int type_id);
+void	kzmq_close(void* hkzmq);
+void	kzmq_info(void* hkzmq, kzmq_info_t * pinfo);
+int	kzmq_read(void* hkzmq, void *pmsg, int len);
+int	kzmq_write(void* hkzmq, void *pmsg, int len);
+bool	kzmq_delegate(void* hkzmq, void* hmaster);
+bool	kzmq_register_data_flow(void* hkzmq, zmq_pfn_data_flow_cb callback, void * pctx);
+bool	kzmq_unregister_data_flow(void* hkzmq);
+bool	kzmq_data_flow_enqueue(void* hkzmq, u32 addr, u32 len, u32 low, u32 evts, u32 dir);
+u32	kzmq_data_flow_pos(void* hkzmq);
+bool	kzmq_data_flow_wait(void* hkzmq, u32* pos);
+
+/* buffer ring model */
+void *  kzmq_br_create(void * hzmq, u32 start, u32 size, u32 low, u32 dir, u8* vptr, kzmq_pfn_data_flow_br_cb callback);
+void	kzmq_br_destory(void * hbr);
+u32	kzmq_br_zpos(void* hbr);
+bool	kzmq_br_get_buffer(void* hbr, u32 * pupos, u32 * pvalidsize);
+bool	kzmq_br_deliver_buffer(void* hbr, u32 size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/mmp-zsp.h b/arch/arm/mach-mmp/include/mach/mmp-zsp.h
new file mode 100644
index 0000000..a40b8d5
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp-zsp.h
@@ -0,0 +1,120 @@
+/*
+ *
+ * Marvell MMP2 ZSP driver.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _MMP2_ZSP_H_
+#define _MMP2_ZSP_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include<linux/interrupt.h>
+#ifdef CONFIG_CPU_MMP3
+#include <mach/mmp3-audio.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef CONFIG_CPU_MMP2
+#define MMP_AUDIO_RAM_SIZE	(16*1024)
+#elif CONFIG_CPU_MMP3
+#define MMP_AUDIO_RAM_SIZE	(128*1024)
+#else
+#define MMP_AUDIO_RAM_SIZE      (0)
+#endif
+
+enum {
+	MMP_ZSP_SPD_PERFORMACE		= 0,
+	MMP_ZSP_SPD_BALANCED		= 1,
+	MMP_ZSP_SPD_POWERSAVING		= 2,
+	MMP_ZSP_SPD_NUMBER		= 3,
+	MMP_ZSP_SPD_FLAGS		= (1u << 0),
+
+	MMP_ZSP_CORECLKSRC_PMU		= 0,
+	MMP_ZSP_CORECLKSRC_AUDIOPLL	= 1,
+	MMP_ZSP_CORECLKSRC_NUMBER	= 2,
+	MMP_ZSP_CORECLKSRC_FLAGS	= (1u << 1),
+
+	MMP_ZSP_ASCLK_22579200		= 0,	/* for 44.1k group */
+	MMP_ZSP_ASCLK_24576000		= 1,	/* for 48k group */
+	MMP_ZSP_ASCLK_NUMBER		= 2,
+	MMP_ZSP_ASCLK_FLAGS		= (1u << 2),
+
+	MMP_ZSP_FLAGS_MSK		= 0x7,
+};
+struct mmp_zsp_clkcfg {
+	int spd;
+	int src;
+	int asclk;
+};
+struct mmp_zsp_platform_device {
+	struct mmp_zsp_clkcfg clkcfg;
+	unsigned long sram_size;
+	void (*domain_halt)(void);
+	void (*domain_on)(int spd, int src, int asclk);
+	void (*start_core)(void);
+	unsigned long (*hw_memcpy)
+		(unsigned long pdst, unsigned long psrc, unsigned int len);
+};
+
+#define mmp_zsp_set_bit_range(ref, val, msk, shft) \
+	(((ref) & (~((msk) << (shft)))) | (((val) & (msk)) << (shft)))
+
+
+/* interrupt bit setting for IPC */
+#define IPC_INTERRUPT_BIT_0_0	(0x00000001)
+#define IPC_INTERRUPT_BIT_0_1	(0x00000002)
+#define IPC_INTERRUPT_BIT_0_2	(0x00000004)
+#define IPC_INTERRUPT_BIT_0_3	(0x00000008)
+#define IPC_INTERRUPT_BIT_0_4	(0x00000010)
+#define IPC_INTERRUPT_BIT_0_5	(0x00000020)
+#define IPC_INTERRUPT_BIT_0_6	(0x00000040)
+#define IPC_INTERRUPT_BIT_0_7	(0x00000080)
+#define IPC_INTERRUPT_BIT_1_8	(0x00000100)
+#define IPC_INTERRUPT_BIT_2_9	(0x00000200)
+#define IPC_INTERRUPT_BIT_3_10	(0x00000400)
+
+/* 16 bits define in ZSP for IPC event id */
+enum ipc_client_id{
+	IPC_HANDSHAKE_ID		= 0x0,
+	IPC_MSG_TRANSFER_ID		= 0x1,
+	IPC_DMEM_REQ_ID			= 0x2,
+	IPC_DMEM_RLS_ID			= 0x3,
+	IPC_PORT_FLOWCONTROL_ID		= 0x4,
+	IPC_TEST_ID			= 0x5,
+	IPC_IPM_ID			= 0x6,
+	IPC_SOFT_RESET_ID		= 0x7,
+	IPC_FREQ_DONE_ID	= 0x8,
+	IPC_MAX_NUM,
+};
+
+enum pzipc_return_code{
+	PZIPC_RC_OK = 0,
+	PZIPC_RC_FAILURE,
+	PZIPC_RC_API_FAILURE,
+	PZIPC_RC_WRONG_PARAM,
+};
+
+enum pzipc_return_code pzipc_add_isr(enum ipc_client_id client_id,
+	irq_handler_t isr_handler);
+enum pzipc_return_code pzipc_remove_isr(enum ipc_client_id client_id);
+enum pzipc_return_code pzipc_set_interrupt(enum ipc_client_id client_id);
+void zsp_local_start(atomic_t *pcounter, int timeout_ms, int retry);
+void zsp_local_stop(atomic_t *pcounter);
+void* zsp_get_datawnd(void);
+struct mmp_zsp_platform_device *zsp_get_devop(void);
+int zsp_mmap_datawnd(struct vm_area_struct *vma);
+int zsp_set_clock_preference(u32 opmask, struct mmp_zsp_clkcfg * pcfg);
+
+int zsp_freq_test(int dumponly);
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/mmp3-audio.h b/arch/arm/mach-mmp/include/mach/mmp3-audio.h
new file mode 100644
index 0000000..a9cf5a5
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp3-audio.h
@@ -0,0 +1,20 @@
+/*
+*
+* Marvell MMP2 Audio Driver
+*
+* This file is licensed under the terms of the GNU General Public
+* License version 2.  This program is licensed "as is" without any
+* warranty of any kind, whether express or implied.
+*/
+
+#ifndef _MMP3_AUDIO_H_
+#define _MMP3_AUDIO_H_
+
+struct audio_dsp_pwr_status {
+	u32 zsp_cnt;
+	u32 main_pwr_cnt;
+	u32 aud_dev_cnt;
+	u32 aud_pll_cnt;
+};
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/mmp3.h b/arch/arm/mach-mmp/include/mach/mmp3.h
new file mode 100644
index 0000000..943cca0
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp3.h
@@ -0,0 +1,299 @@
+#ifndef __ASM_MACH_MMP3_H
+#define __ASM_MACH_MMP3_H
+
+struct sys_timer;
+
+extern struct sys_timer mmp3_timer;
+extern void __init mmp3_init_gic(void);
+extern void __init mmp3_init_irq(void);
+extern void __init mmp3_reserve(void);
+
+#include <linux/i2c.h>
+#include <linux/i2c/pxa-i2c.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <mach/devices.h>
+#include <mach/cputype.h>
+#include <mach/regs-apbc.h>
+#include <mach/pxa168fb.h>
+#include <mach/uio_hdmi.h>
+#include <plat/devfreq.h>
+#include <plat/pxa27x_keypad.h>
+#include <linux/platform_data/pxa_sdhci.h>
+#include <mach/sram.h>
+
+#define IOPWRDOM_VIRT_BASE	(APB_VIRT_BASE + 0x1e800)
+#define PAD_1V8			(1 << 2)
+#define PAD_POWERDOWN		(1 << 0)
+#define AIB_HSIC3_IO_REG	0x0000
+#define AIB_HSIC2_IO_REG	0x0004
+#define AIB_GPIO2_IO_REG	0x000C
+#define AIB_GPIO3_IO_REG	0x0010
+#define AIB_TWSI_IO_REG		0x0014
+#define AIB_SDMMC_IO_REG	0x001c
+#define AIB_NAND_IO_REG		0x0020
+#define AIB_USIM_IO_REG		0x002c
+#define AIB_BB_IO_REG		0x0030
+
+extern struct pxa_device_desc mmp3_device_uart1;
+extern struct pxa_device_desc mmp3_device_uart2;
+extern struct pxa_device_desc mmp3_device_uart3;
+extern struct pxa_device_desc mmp3_device_uart4;
+extern struct pxa_device_desc mmp3_device_twsi1;
+extern struct pxa_device_desc mmp3_device_twsi2;
+extern struct pxa_device_desc mmp3_device_twsi3;
+extern struct pxa_device_desc mmp3_device_twsi4;
+extern struct pxa_device_desc mmp3_device_twsi5;
+extern struct pxa_device_desc mmp3_device_twsi6;
+extern struct pxa_device_desc mmp3_device_nand;
+extern struct pxa_device_desc mmp3_device_sdh0;
+extern struct pxa_device_desc mmp3_device_sdh1;
+extern struct pxa_device_desc mmp3_device_sdh2;
+extern struct pxa_device_desc mmp3_device_sdh3;
+extern struct pxa_device_desc mmp3_device_camera0;
+extern struct pxa_device_desc mmp3_device_camera1;
+extern struct pxa_device_desc mmp3_device_pwm1;
+extern struct pxa_device_desc mmp3_device_pwm2;
+extern struct pxa_device_desc mmp3_device_pwm3;
+extern struct pxa_device_desc mmp3_device_pwm4;
+extern struct pxa_device_desc mmp3_device_keypad;
+extern struct pxa_device_desc mmp3_device_fb;
+extern struct pxa_device_desc mmp3_device_fb_ovly;
+extern struct pxa_device_desc mmp3_device_v4l2_ovly;
+extern struct pxa_device_desc mmp3_device_fb_tv;
+extern struct pxa_device_desc mmp3_device_fb_tv_ovly;
+extern struct pxa_device_desc mmp3_device_v4l2_tv_ovly;
+extern struct pxa_device_desc mmp3_device_hdmi;
+extern struct pxa_device_desc mmp3_device_ddr_devfreq;
+extern struct pxa_device_desc mmp3_device_videosram;
+extern struct pxa_device_desc mmp3_device_thermal;
+
+extern struct platform_device mmp3_device_rtc;
+extern struct platform_device mmp3_device_vnc_touch;
+extern struct pxa_device_desc mmp3_device_sspa1;
+extern struct pxa_device_desc mmp3_device_sspa2;
+extern struct pxa_device_desc mmp3_device_ssp1;
+extern struct pxa_device_desc mmp3_device_ssp2;
+extern struct pxa_device_desc mmp3_device_ssp3;
+extern struct pxa_device_desc mmp3_device_ssp4;
+
+extern struct pxa_device_desc mmp3_device_audiosram;
+extern struct platform_device mmp3_device_u2o;
+extern struct platform_device mmp3_device_u2ootg;
+extern struct platform_device mmp3_device_u2oehci;
+extern struct platform_device mmp3_hsic1_device;
+extern struct platform_device mmp3_hsic2_device;
+extern struct platform_device mmp3_fsic_device;
+
+extern void mmp_zsp_platform_device_init(void);
+extern void pxa_u3d_phy_disable(void);
+
+static inline void mmp3_io_domain_1v8(u16 reg, int set)
+{
+	u32 tmp;
+
+	writel(MAGIC_ASFAR, APBC_MMP2_ASFAR);
+	writel(MAGIC_ASSAR, APBC_MMP2_ASSAR);
+	tmp = readl(IOPWRDOM_VIRT_BASE + reg);
+
+	if (set)
+		tmp |= PAD_1V8;
+	else
+		tmp &= ~PAD_1V8;
+
+	writel(MAGIC_ASFAR, APBC_MMP2_ASFAR);
+	writel(MAGIC_ASSAR, APBC_MMP2_ASSAR);
+	writel(tmp, IOPWRDOM_VIRT_BASE + reg);
+}
+
+static inline int mmp3_add_ssp(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+		case 1: d = &mmp3_device_ssp1; break;
+		case 2: d = &mmp3_device_ssp2; break;
+		case 3: d = &mmp3_device_ssp3; break;
+		case 4: d = &mmp3_device_ssp4; break;
+		default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_spi(int id, struct pxa2xx_spi_master *pdata)
+{
+	struct platform_device *pd;
+	pd = platform_device_alloc("pxa2xx-spi", id);
+	if (pd == NULL) {
+		pr_err("pxa2xx-spi: failed to allocate device (id=%d)\n", id);
+		return -ENOMEM;
+	}
+
+	platform_device_add_data(pd, pdata, sizeof(*pdata));
+
+	return platform_device_add(pd);
+}
+
+static inline int mmp3_add_uart(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1: d = &mmp3_device_uart1; break;
+	case 2: d = &mmp3_device_uart2; break;
+	case 3: d = &mmp3_device_uart3; break;
+	case 4: d = &mmp3_device_uart4; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_thermal(void)
+{
+	return pxa_register_device(&mmp3_device_thermal, NULL, 0);
+}
+
+static inline int mmp3_add_twsi(int id, struct i2c_pxa_platform_data *data,
+				  struct i2c_board_info *info, unsigned size)
+{
+	struct pxa_device_desc *d = NULL;
+	int ret;
+
+	switch (id) {
+	case 1: d = &mmp3_device_twsi1; break;
+	case 2: d = &mmp3_device_twsi2; break;
+	case 3: d = &mmp3_device_twsi3; break;
+	case 4: d = &mmp3_device_twsi4; break;
+	case 5: d = &mmp3_device_twsi5; break;
+	case 6: d = &mmp3_device_twsi6; break;
+	default:
+		return -EINVAL;
+	}
+
+	ret = i2c_register_board_info(id - 1, info, size);
+	if (ret)
+		return ret;
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+
+static inline int mmp3_add_ddr_devfreq(struct devfreq_platform_data *data)
+{
+	return pxa_register_device(&mmp3_device_ddr_devfreq, data, sizeof(*data));
+}
+
+static inline int mmp3_add_sdh(int id, struct sdhci_pxa_platdata *data)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0: d = &mmp3_device_sdh0; break;
+	case 1: d = &mmp3_device_sdh1; break;
+	case 2: d = &mmp3_device_sdh2; break;
+	case 3: d = &mmp3_device_sdh3; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int mmp3_add_pwm(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1:
+		d = &mmp3_device_pwm1;
+		break;
+	case 2:
+		d = &mmp3_device_pwm2;
+		break;
+	case 3:
+		d = &mmp3_device_pwm3;
+		break;
+	case 4:
+		d = &mmp3_device_pwm4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_fb(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_v4l2_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_v4l2_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_tv(struct pxa168fb_mach_info *mi)
+{
+       return pxa_register_device(&mmp3_device_fb_tv, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_fb_tv_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_fb_tv_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_v4l2_tv_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&mmp3_device_v4l2_tv_ovly, mi, sizeof(*mi));
+}
+
+static inline int mmp3_add_hdmi(struct uio_hdmi_platform_data *data)
+{
+        return pxa_register_device(&mmp3_device_hdmi, data, sizeof(*data));
+}
+
+extern void mmp3_clear_keypad_wakeup(void);
+static inline int mmp3_add_keypad(struct pxa27x_keypad_platform_data *data)
+{
+	data->clear_wakeup_event = mmp3_clear_keypad_wakeup;
+	return pxa_register_device(&mmp3_device_keypad, data, sizeof(*data));
+}
+
+static inline int mmp3_add_audiosram(struct sram_bank *data)
+{
+	return pxa_register_device(&mmp3_device_audiosram, data, sizeof(*data));
+}
+
+static inline int mmp3_add_sspa(int id)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1:
+		d = &mmp3_device_sspa1;
+		break;
+	case 2:
+		d = &mmp3_device_sspa2;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, NULL, 0);
+}
+
+static inline int mmp3_add_videosram(struct sram_bank *data)
+{
+	return pxa_register_device(&mmp3_device_videosram, data, sizeof(*data));
+}
+
+#endif /* __ASM_MACH_MMP2_H */
diff --git a/arch/arm/mach-mmp/include/mach/mmp3_pm.h b/arch/arm/mach-mmp/include/mach/mmp3_pm.h
new file mode 100644
index 0000000..7959a02
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp3_pm.h
@@ -0,0 +1,96 @@
+/*
+ * MMP3 Power Management Routines
+ *
+ * This software program is licensed subject to the GNU General Public License
+ * (GPL).Version 2,June 1991, available at http://www.fsf.org/copyleft/gpl.html
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ */
+
+#ifndef __MMP3_PM_H__
+#define __MMP3_PM_H__
+
+enum {
+	MMP3_CLK_MP1 = 0,
+	MMP3_CLK_MP2,
+	MMP3_CLK_MM,
+	MMP3_CLK_ACLK,
+	MMP3_CLK_DDR_1,
+	MMP3_CLK_DDR_2,
+	MMP3_CLK_AXI_1,
+	MMP3_CLK_AXI_2,
+	MMP3_CLK_TOP_NUM,
+};
+
+struct dmc_regtable_entry {
+	u32 reg;
+	u32 b2c;
+	u32 b2s;
+};
+struct dmc_regtable {
+	u32 count;
+	struct dmc_regtable_entry *entry;
+};
+
+enum {
+	DMCRT_TM = 0,
+	DMCRT_PH,
+	DMCRT_RL,
+	DMCRT_WL,
+	DMCRT_TYPECNT,
+
+	DMC_MODE_4X = (1u << 0),
+};
+
+struct dmc_timing_entry {
+	u32 dsrc;
+	u32 mode4x;
+	u32 pre_d;
+	u32 cas;
+	struct dmc_regtable table[DMCRT_TYPECNT];
+};
+#define DEF_DMC_TAB_ENTRY(label, a)		\
+	[label] = {ARRAY_SIZE(a), a}
+
+#define DEF_DMC_TAB(tm, ph, rl, wl)			\
+	{						\
+		DEF_DMC_TAB_ENTRY(DMCRT_TM, tm),	\
+		DEF_DMC_TAB_ENTRY(DMCRT_PH, ph),	\
+		DEF_DMC_TAB_ENTRY(DMCRT_RL, rl),	\
+		DEF_DMC_TAB_ENTRY(DMCRT_WL, wl),	\
+	}
+
+
+void mmp3_setfreq(int clkid, unsigned long khz);
+unsigned long mmp3_getfreq(int clkid);
+int mmp3_get_pp_number(void);
+unsigned long mmp3_get_pp_freq(int ppidx, int clkid);
+void mmp3_pm_enter_idle(int cpu);
+void mmp3_pm_enter_c2(int cpu, int hpg);
+void mmp3_pm_enter_d2(void);
+void mmp3_set_vcc_main_reg_id(const char *name);
+int mmp3_get_core_clk(int cpu);
+
+void mmp3_pm_update_dram_timing_table(int count, struct dmc_timing_entry *tab);
+
+enum {
+	TRACE_DFC_MARKER_CORE = (1u << 0),
+	TRACE_DFC_MARKER_DRAM = (1u << 1),
+	TRACE_DFC_MARKER_AXI = (1u << 2),
+	TRACE_DFC_MARKER_ERR = (1u << 7),
+};
+
+union trace_dfc_log {
+	struct {
+		u32 marker:8;
+		u32 pp_core:8;
+		u32 pp_dram:8;
+		u32 pp_axi:8;
+	};
+	u32 val;
+};
+
+#include <mach/mmp_events.h>
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/mmp_audisland.h b/arch/arm/mach-mmp/include/mach/mmp_audisland.h
new file mode 100644
index 0000000..750395e
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp_audisland.h
@@ -0,0 +1,25 @@
+#ifndef __MACH_MMP_AUDISLAND_H
+#define __MACH_MMP_AUDISLAND_H
+
+#include <mach/addr-map.h>
+
+#if defined(CONFIG_CPU_MMP2)
+
+#define AUD_PHYS_BASE		(AXI_PHYS_BASE + 0xA0000)
+#define AUD_VIRT_BASE		(AXI_VIRT_BASE + 0xA0000)
+#define AUD_PHYS_SIZE		0x00003000
+
+#elif defined(CONFIG_CPU_MMP3)
+
+#define AUD_PHYS_BASE		0xc0ffd000
+#define AUD_VIRT_BASE		0xfeffd000
+#define AUD_PHYS_SIZE		0x00003000
+#define AUD_PHYS_BASE2		0xc0140000
+#define AUD_VIRT_BASE2		0xfef40000
+#define AUD_PHYS_SIZE2		0x00010000
+
+#else
+#error "unknown platform for audio island"
+#endif
+
+#endif /* __MACH_MMP_AUDISLAND_H */
diff --git a/arch/arm/mach-mmp/include/mach/mmp_cm.h b/arch/arm/mach-mmp/include/mach/mmp_cm.h
new file mode 100644
index 0000000..4a8e5be
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp_cm.h
@@ -0,0 +1,36 @@
+/*
+ * Driver for mmp platform's core morphing
+ *
+ * Copyright (c) 2011-2012 Marvell Semiconductors Inc.
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef MMP_CM_H
+#define MMP_CM_H
+
+#include <mach/smp.h>
+#include <mach/addr-map.h>
+
+#define MMP_CM_CPU_ID_MP1	0
+#define MMP_CM_CPU_ID_MM	1
+
+#define MMP_CM_REG_DIS_MP1	(PGU_VIRT_BASE + 0xc80)
+#define MMP_CM_REG_DIS_MP1_MP2	(PGU_VIRT_BASE + 0xc84)
+#define MMP_CM_REG		MMP_CM_REG_DIS_MP1_MP2
+
+#ifdef CONFIG_CORE_MORPHING
+extern int cm_get_active_core_id(void);
+extern int cm_vote_mp1(void);
+extern int cm_cancel_vote_mp1(void);
+extern void cm_enable(void);
+#else
+#define cm_get_active_core_id()	(0)
+#define cm_vote_mp1()		do { } while (0)
+#define cm_cancel_vote_mp1()	do { } while (0)
+#define cm_enable()		do { } while (0)
+#endif
+
+#endif /* MMP_CM_H */
diff --git a/arch/arm/mach-mmp/include/mach/mmp_dma.h b/arch/arm/mach-mmp/include/mach/mmp_dma.h
new file mode 100644
index 0000000..a36cdc1
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp_dma.h
@@ -0,0 +1,101 @@
+#ifndef __MACH_MMP_DMA_H
+#define __MACH_MMP_DMA_H
+
+#include <mach/mmp_audisland.h>
+
+#define __DMA_REG(x, y)		(*((volatile u32 *)(x + y)))
+
+#define ADMA1_CH0_BASE		(AUD_VIRT_BASE + 0x800)
+#define ADMA1_CH1_BASE		(AUD_VIRT_BASE + 0x804)
+#define ADMA2_CH0_BASE		(AUD_VIRT_BASE + 0x900)
+#define ADMA2_CH1_BASE		(AUD_VIRT_BASE + 0x904)
+#define MDMA1_CH0_BASE		(AXI_VIRT_BASE + 0xA0a00)
+#define MDMA1_CH1_BASE		(AXI_VIRT_BASE + 0xA0a04)
+#define VDMA1_CH0_BASE		(AXI_VIRT_BASE + 0x0B300)
+#define VDMA1_CH1_BASE		(AXI_VIRT_BASE + 0x0B380)
+
+/* Two-Channel DMA registers */
+#define TDBCR(base)		__DMA_REG(base, 0x0)	/* Byte Count Register */
+#define TDSAR(base)		__DMA_REG(base, 0x10)	/* Src Addr Register */
+#define TDDAR(base)		__DMA_REG(base, 0x20)   /* Dst Addr Register */
+#define TDNDPR(base)		__DMA_REG(base, 0x30)   /* Next Desc Pointer Register */
+#define TDCR(base)		__DMA_REG(base, 0x40)   /* Control Register */
+#define TDCP(base)		__DMA_REG(base, 0x60)   /* Priority Register */
+#define TDCDPR(base)		__DMA_REG(base, 0x70)   /* Current Desc Pointer Register */
+#define TDIMR(base)		__DMA_REG(base, 0x80)   /* Int Mask Register */
+#define TDISR(base)		__DMA_REG(base, 0xa0)   /* Int Status Register */
+#define VDCR(base)		__DMA_REG(base, 0x28)	/* FIXME: Remove VDMA from this file */
+
+/* Two-Channel DMA Control Register */
+#define TDCR_SSZ_8_BITS		(0x0 << 22)	/* Sample Size */
+#define TDCR_SSZ_12_BITS	(0x1 << 22)
+#define TDCR_SSZ_16_BITS	(0x2 << 22)
+#define TDCR_SSZ_20_BITS	(0x3 << 22)
+#define TDCR_SSZ_24_BITS	(0x4 << 22)
+#define TDCR_SSZ_32_BITS	(0x5 << 22)
+#define TDCR_SSZ_SHIFT		(0x1 << 22)
+#define TDCR_SSZ_MASK		(0x7 << 22)
+#define TDCR_ABR		(0x1 << 20)	/* Channel Abort */
+#define TDCR_CDE		(0x1 << 17)	/* Close Desc Enable */
+#define TDCR_PACKMOD		(0x1 << 16)	/* Pack Mode (ADMA Only) */
+#define TDCR_CLK_GATE_CTL	(0x1 << 16)	/* Clock Gate Conrol (MDMA Only) */
+#define TDCR_CLK_GATE_ON	(0x1 << 15)	/* Clock Gate On (MDMA Only) */
+#define TDCR_CHANACT		(0x1 << 14)	/* Channel Active */
+#define TDCR_FETCHND		(0x1 << 13)	/* Fetch Next Desc */
+#define TDCR_CHANEN		(0x1 << 12)	/* Channel Enable */
+#define TDCR_TRANSMOD		(0x1 << 11)	/* Transfer Mode, 1: Normal mode (MDMA Only) */
+#define TDCR_INTMODE		(0x1 << 10)	/* Interrupt Mode */
+#define TDCR_CHAINMOD		(0x1 << 9)	/* Chain Mode */
+#define TDCR_BURSTSZ_MSK	(0x7 << 6)	/* Burst Size */
+#define TDCR_BURSTSZ_4B		(0x0 << 6)
+#define TDCR_BURSTSZ_8B		(0x1 << 6)
+#define TDCR_BURSTSZ_16B	(0x3 << 6)
+#define TDCR_BURSTSZ_32B	(0x6 << 6)
+#define TDCR_BURSTSZ_64B	(0x7 << 6)
+#define TDCR_BURSTSZ_128B	(0x5 << 6)
+#define TDCR_DSTDIR_MSK		(0x3 << 4)	/* Dst Direction */
+#define TDCR_DSTDIR_ADDR_HOLD	(0x2 << 4)	/* Dst Addr Hold */
+#define TDCR_DSTDIR_ADDR_INC	(0x0 << 4)	/* Dst Addr Increment */
+#define TDCR_SRCDIR_MSK		(0x3 << 2)	/* Src Direction */
+#define TDCR_SRCDIR_ADDR_HOLD	(0x2 << 2)	/* Src Addr Hold */
+#define TDCR_SRCDIR_ADDR_INC	(0x0 << 2)	/* Src Addr Increment */
+#define TDCR_DSTDESCCONT	(0x1 << 1)
+#define TDCR_SRCDESTCONT	(0x1 << 0)
+
+/* Two-Channel DMA Int Mask Register */
+#define TDIMR_COMP		(0x1 << 0)
+
+/* Two-Channel DMA Int Status Register */
+#define TDISR_COMP		(0x1 << 0)
+
+enum mmp_tdma_type {
+	MDMA1_CH0 = 0,
+	MDMA1_CH1,
+	ADMA1_CH0,
+	ADMA1_CH1,
+	ADMA2_CH0,
+	ADMA2_CH1,
+	VDMA1_CH0,
+	VDMA1_CH1,
+	DMA_CH_NUM,
+};
+
+/*
+ * Two-Channel DMA Descriptor Struct
+ * NOTE: desc's buf must be aligned to 16 bytes.
+ */
+typedef struct mmp_tdma_desc {
+	volatile u32 byte_cnt;	/* byte count */
+	volatile u32 src_addr;	/* source address */
+	volatile u32 dst_addr;	/* target address */
+	volatile u32 nxt_desc;	/* next descriptor dress */
+} mmp_tdma_desc;
+
+int __init mmp_init_dma(unsigned int irq);
+unsigned int mmp_request_dma(char *name, unsigned int dma_ch,
+		void (*irq_handler)(int, void *), void *data);
+void mmp_free_dma(unsigned int dma_ch);
+
+u32 mmp_get_dma_reg_base(enum mmp_tdma_type dma_type);
+
+#endif /* __MACH_MMP_DMA_H */
diff --git a/arch/arm/mach-mmp/include/mach/mmp_events.h b/arch/arm/mach-mmp/include/mach/mmp_events.h
new file mode 100644
index 0000000..19ad201
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mmp_events.h
@@ -0,0 +1,69 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM mmp_events
+
+#if !defined(_TRACE_MMP_EVENTS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_MMP_EVENTS_H
+
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(dfc,
+
+	TP_PROTO(union trace_dfc_log *tgt),
+
+	TP_ARGS(tgt),
+
+	TP_STRUCT__entry(
+		__field(u32, dat)
+	),
+
+	TP_fast_assign(
+		__entry->dat = tgt->val;
+	),
+
+	TP_printk("DFC 0x%08x", __entry->dat)
+);
+
+
+TRACE_EVENT(idle_entry,
+
+	TP_PROTO(int mode),
+
+	TP_ARGS(mode),
+
+	TP_STRUCT__entry(
+		__field(int, mode)
+	),
+
+	TP_fast_assign(
+		__entry->mode	= mode;
+	),
+
+	TP_printk("enter idle, type=%d", __entry->mode)
+);
+
+TRACE_EVENT(idle_exit,
+
+	TP_PROTO(u32 reason),
+
+	TP_ARGS(reason),
+
+	TP_STRUCT__entry(
+		__field(u32, reason)
+	),
+
+	TP_fast_assign(
+		__entry->reason = reason;
+	),
+
+	TP_printk("exit idle, reason=0x%x", __entry->reason)
+);
+
+#endif /*  _TRACE_MMP_EVENTS_H */
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH mach
+
+#define TRACE_INCLUDE_FILE mmp_events
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff --git a/arch/arm/mach-mmp/include/mach/mv_wtm.h b/arch/arm/mach-mmp/include/mach/mv_wtm.h
new file mode 100644
index 0000000..80f4710
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/mv_wtm.h
@@ -0,0 +1,24 @@
+/*
+ * (C) Copyright 2012
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MV_WTM_H__
+#define __MV_WTM_H__
+
+int  wtm_read_profile(void);
+void wtm_read_stepping(void);
+void wtm_dump_info(void);
+void wtm_setup_remap(void);
+int wtm_read_platform_config(void);
+int wtm_init(void);
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/pxa168fb.h b/arch/arm/mach-mmp/include/mach/pxa168fb.h
new file mode 100644
index 0000000..5f9a5ee
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/pxa168fb.h
@@ -0,0 +1,546 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/pxa168fb.h
+ *
+ *  Copyright (C) 2009 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_PXA168FB_H
+#define __ASM_MACH_PXA168FB_H
+/* ---------------------------------------------- */
+/*              Header Files                      */
+/* ---------------------------------------------- */
+#include <linux/fb.h>
+#include <plat/fb_ioctl.h>
+
+#ifdef __KERNEL__
+#include <linux/interrupt.h>
+#include <linux/earlysuspend.h>
+#include <linux/list.h>
+
+/* Dumb interface */
+#define PIN_MODE_DUMB_24		0
+#define PIN_MODE_DUMB_18_SPI		1
+#define PIN_MODE_DUMB_18_GPIO		2
+#define PIN_MODE_DUMB_16_SPI		3
+#define PIN_MODE_DUMB_16_GPIO		4
+#define PIN_MODE_DUMB_12_SPI_GPIO	5
+#define PIN_MODE_SMART_18_SPI		6
+#define PIN_MODE_SMART_16_SPI		7
+#define PIN_MODE_SMART_8_SPI_GPIO	8
+#define PIN_MODE_DUMB_18_SMART_8	9
+#define PIN_MODE_DUMB_16_SMART_8_SPI	10
+#define PIN_MODE_DUMB_16_SMART_8_GPIO	11
+#define PIN_MODE_DUMB_16_DUMB_16	12
+
+/*I/O pad control*/
+#define CFG_BOUNDARY_1KB	(1<<5)	/*no crossing 1KB boundary*/
+#define CFG_BOUNDARY_4KB	(0<<5)	/*no crossing 4KB boundary*/
+#define CFG_CYC_BURST_LEN16	(1<<4)
+#define CFG_CYC_BURST_LEN8	(0<<4)
+
+/* Dumb interface pin allocation */
+#define DUMB_MODE_RGB565		0
+#define DUMB_MODE_RGB565_UPPER		1
+#define DUMB_MODE_RGB666		2
+#define DUMB_MODE_RGB666_UPPER		3
+#define DUMB_MODE_RGB444		4
+#define DUMB_MODE_RGB444_UPPER		5
+#define DUMB_MODE_RGB888		6
+
+/* default fb buffer size WVGA-32bits */
+#define DEFAULT_FB_SIZE	(800 * 480 * 4)
+
+/*
+ * Buffer pixel format
+ * bit0 is for rb swap.
+ * bit12 is for Y UorV swap
+ */
+#define PIX_FMT_RGB565		0
+#define PIX_FMT_BGR565		1
+#define PIX_FMT_RGB1555		2
+#define PIX_FMT_BGR1555		3
+#define PIX_FMT_RGB888PACK	4
+#define PIX_FMT_BGR888PACK	5
+#define PIX_FMT_RGB888UNPACK	6
+#define PIX_FMT_BGR888UNPACK	7
+#define PIX_FMT_RGBA888		8
+#define PIX_FMT_BGRA888		9
+#define PIX_FMT_YUV422PACK	10
+#define PIX_FMT_YVU422PACK	11
+#define PIX_FMT_YUV422PLANAR	12
+#define PIX_FMT_YVU422PLANAR	13
+#define PIX_FMT_YUV420PLANAR	14
+#define PIX_FMT_YVU420PLANAR	15
+#define PIX_FMT_PSEUDOCOLOR	20
+#define PIX_FMT_YUYV422PACK	(0x1000|PIX_FMT_YUV422PACK)
+#define PIX_FMT_YUV422PACK_IRE_90_270	(0x1000|PIX_FMT_RGB888UNPACK)
+
+/*
+ * panel interface
+ */
+#define DPI		0
+#define DSI2DPI		1
+#define DSI		2
+#define LVDS		4
+
+/* flags indicate update region for regshadow
+ * bit[0] = 1, address need update;
+ * bit[1] = 1, video mode need update;
+ * bit[2] = 1, viewport control info need update;
+ */
+#define UPDATE_ADDR (0x1 << 0)
+#define UPDATE_MODE (0x1 << 1)
+#define UPDATE_VIEW (0x1 << 2)
+
+struct regshadow {
+	u32	flags;
+
+	/* address */
+	u32	paddr0[3];
+	u32	paddr1[3];
+
+	/* video mode */
+	u32	dma_ctrl0;
+
+	/* viewport info*/
+	u32	pitch[2];
+	u32	start_point;
+	u32	src_size;
+	u32	dst_size;
+	u32	zoom;
+};
+
+/* shadowreg list for flip mode */
+struct regshadow_list {
+	struct regshadow shadowreg;
+	struct list_head dma_queue;
+};
+
+struct pxa168fb_vdma_info {
+	struct device	*dev;
+	void		*reg_base;
+	int		ch;
+	/* path id, 0->panel, 1->TV, 2->panel2 */
+	int		path;
+	int		pix_fmt;
+	unsigned int	sram_size;
+	unsigned int	rotation;
+	unsigned int	yuv_format;
+	unsigned int	vdma_lines;
+	unsigned int	sram_paddr;
+	unsigned int	sram_vaddr;
+	unsigned	vid:1,
+			active:1,
+			dma_on:1,
+			enable:1;
+};
+/*
+ * PXA LCD controller private state.
+ */
+struct pxa168fb_info {
+	struct device		*dev;
+	struct clk		*clk;
+	__kernel_suseconds_t	frm_usec;
+	int			id;
+	int			vid;
+	void			*reg_base;
+	void			*dsi1_reg_base;
+	void			*dsi2_reg_base;
+	unsigned char		*filterBufList[MAX_QUEUE_NUM][3];
+	struct regshadow_list	buf_freelist;
+	struct regshadow_list	buf_waitlist;
+	struct regshadow_list	*buf_current;
+	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	dma_addr_t		fb_start_dma_bak;
+	void			*fb_start_bak;
+	int			fb_size_bak;
+	u32			scrn_act_bak;
+	atomic_t		op_count;
+	atomic_t		w_intr;
+	wait_queue_head_t	w_intr_wq;
+	struct mutex		access_ok;
+	spinlock_t		buf_lock;
+	struct _sOvlySurface    surface;
+	struct _sOvlySurface    surface_bak;
+	struct regshadow	shadowreg;
+	struct _sColorKeyNAlpha ckey_alpha;
+	struct fb_videomode	dft_vmode;
+	struct fb_videomode     out_vmode;
+	int                     fixed_output;
+	unsigned char		*hwc_buf;
+	unsigned int		pseudo_palette[16];
+	char			*mode_option;
+	struct fb_info          *fb_info;
+	int                     io_pin_allocation;
+	int			pix_fmt;
+	int			debug;
+	unsigned		is_blanked:1,
+				surface_set:1,
+				active:1;
+	/* indicate dma on/off requirement from user space */
+	int			dma_on;
+	/* lock for variables, e.g. active */
+	spinlock_t		var_lock;
+	/* mem_status:
+	* 0: DMA mem is from DMA region.
+	* 1: DMA mem is from normal region.
+	* -1: no frame buffer.
+	*/
+	int			mem_status;
+	unsigned                wait_vsync;
+	unsigned                vsync_u_en;
+	struct work_struct	uevent_work;
+
+	/* Compatibility mode global switch .....
+	 *
+	 * This is a secret switch for user space programs that may want to
+	 * select color spaces and set resolutions the same as legacy PXA
+	 * display drivers. The switch is set and unset by setting a specific
+	 * value in the var_screeninfo.nonstd variable.
+	 *
+	 * To turn on/off compatibility with older PXA:
+	 * set the MSB of nonstd to 0xAA to turn it on.
+	 * set the MSB of nonstd to 0x55 to turn it off.
+	 */
+	unsigned int	compat_mode;
+
+	/* suspend/resume related */
+	struct early_suspend    early_suspend;
+	unsigned		irq_mask;
+
+	struct fb_var_screeninfo var_bak;
+
+	/* gamma correction */
+	struct mvdisp_gamma	gamma;
+	u32 sclk_src;
+	u32 sclk_div;
+};
+
+struct dsi_phy {
+	unsigned int hs_prep_constant;    /* Unit: ns. */
+	unsigned int hs_prep_ui;
+	unsigned int hs_zero_constant;
+	unsigned int hs_zero_ui;
+	unsigned int hs_trail_constant;
+	unsigned int hs_trail_ui;
+	unsigned int hs_exit_constant;
+	unsigned int hs_exit_ui;
+	unsigned int ck_zero_constant;
+	unsigned int ck_zero_ui;
+	unsigned int ck_trail_constant;
+	unsigned int ck_trail_ui;
+	unsigned int req_ready;
+	unsigned int wakeup_constant;
+	unsigned int wakeup_ui;
+	unsigned int lpx_constant;
+	unsigned int lpx_ui;
+};
+
+struct dsi_info {
+	unsigned	id;
+	unsigned	regs;
+	unsigned	lanes;
+	unsigned	bpp;
+	unsigned	rgb_mode;
+	unsigned	burst_mode;
+	unsigned	master_mode;
+	unsigned	lpm_line_en;
+	unsigned	lpm_frame_en;
+	unsigned	last_line_turn;
+	unsigned	hex_slot_en;
+	unsigned	all_slot_en;
+	unsigned	hbp_en;
+	unsigned	hact_en;
+	unsigned	hfp_en;
+	unsigned	hex_en;
+	unsigned	hlp_en;
+	unsigned	hsa_en;
+	unsigned	hse_en;
+	unsigned	eotp_en;
+	struct dsi_phy  *phy;
+};
+
+/* LVDS info */
+struct lvds_info {
+#define LVDS_SRC_PN	0
+#define LVDS_SRC_CMU	1
+#define LVDS_SRC_PN2	2
+#define LVDS_SRC_TV	3
+	u32	src;
+#define LVDS_FMT_24BIT	0
+#define LVDS_FMT_18BIT	1
+	u32	fmt;
+};
+
+/*
+ * CMU information
+ */
+struct cmu_calibration {
+	int left;
+	int right;
+	int top;
+	int bottom;
+};
+struct cmu_res {
+	int width;
+	int height;
+};
+
+/*
+ * PXA fb machine information
+ */
+struct pxa168fb_mach_info {
+	char	id[16];
+	unsigned int	sclk_src;
+	unsigned int	sclk_div;
+
+	int		num_modes;
+	struct fb_videomode *modes;
+	unsigned int max_fb_size;
+
+	/*
+	 * Pix_fmt
+	 */
+	unsigned	pix_fmt;
+	/*
+	 *ISR clear mask
+	 */
+	unsigned	isr_clear_mask;
+	/*
+	 * I/O pad control.
+	 */
+	unsigned int	io_pad_ctrl;
+
+	/*
+	 * Dumb panel -- assignment of R/G/B component info to the 24
+	 * available external data lanes.
+	 */
+	unsigned	dumb_mode:4;
+	unsigned	panel_rgb_reverse_lanes:1;
+
+	/*
+	 * Dumb panel -- GPIO output data.
+	 */
+	unsigned	gpio_output_mask:8;
+	unsigned	gpio_output_data:8;
+
+	/*
+	 * Dumb panel -- configurable output signal polarity.
+	 */
+	unsigned	invert_composite_blank:1;
+	unsigned	invert_pix_val_ena:1;
+	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
+	unsigned	panel_rbswap:1;
+	unsigned	active:1;
+	unsigned	enable_lcd:1;
+	unsigned	mmap:1;
+
+	/*
+	 * dither option
+	 */
+	unsigned	dither_en:1;
+#define DITHER_TBL_4X4	0
+#define DITHER_TBL_4X8	1
+	unsigned	dither_table:1;
+#define DITHER_MODE_RGB444	0
+#define DITHER_MODE_RGB565	1
+#define DITHER_MODE_RGB666	2
+	unsigned	dither_mode:2;
+
+	/*
+	 * SPI control
+	 */
+	unsigned int	spi_ctrl;
+	unsigned int	spi_gpio_cs;
+	unsigned int	spi_gpio_reset;
+
+	/*
+	 * panel interface
+	*/
+	unsigned int	phy_type;
+	int		(*phy_init)(struct pxa168fb_info *);
+	void		*phy_info;
+
+	/*
+	 * vdma option
+	 */
+	unsigned int vdma_enable;
+	unsigned int sram_size;
+	/*
+	 * power on/off function.
+	 */
+	int (*pxa168fb_lcd_power)(struct pxa168fb_info *,
+			 unsigned int, unsigned int, int);
+
+	/*
+	 * dsi to dpi setting function
+	 */
+	int (*dsi2dpi_set)(struct pxa168fb_info *);
+	int (*xcvr_reset)(struct pxa168fb_info *);
+
+	/* init config for panel via dsi */
+	void (*dsi_panel_config)(struct pxa168fb_info *);
+	/*
+	 * special ioctls
+	 */
+	int (*ioctl)(struct fb_info *info, unsigned int cmd, unsigned long arg);
+	/*CMU platform calibration*/
+	struct cmu_calibration cmu_cal[3];
+	struct cmu_calibration cmu_cal_letter_box[3];
+};
+
+struct fbi_info {
+	struct pxa168fb_info *fbi[3];
+};
+
+enum dsi_packet_di {
+	/* for sleep in/out display on/off */
+	DSI_DI_DCS_WRITE_N = 0x5,
+	/* for set_pixel_format */
+	DSI_DI_DCS_WRITE_1P = 0x15,
+	/* for video mode off */
+	DSI_DI_PERIPHE_CMD_OFF = 0x22,
+	/* for video mode on */
+	DSI_DI_PERIPHE_CMD_ON = 0x32,
+};
+
+enum dsi_packet_dcs_id {
+	DSI_DCS_SLEEP_EXIT = 0x11,
+	DSI_DCS_SLEEP_IN = 0x10,
+	DSI_DCS_DISPLAY_ON = 0x29,
+	DSI_DCS_DISPLAY_OFF = 0x28,
+	DSI_DCS_SET_PIXEL_FMT = 0x3a,
+};
+
+#define BPP_16		0x55
+#define BPP_18		0x66
+#define BPP_24		0x77
+
+/* LCD partial display */
+#define THRESHOLD_PN	64
+#define THRESHOLD_TV	100
+#define BURST_LEN		64
+
+/* DSI burst mode */
+#define DSI_BURST_MODE_SYNC_PULSE			0x0
+#define DSI_BURST_MODE_SYNC_EVENT			0x1
+#define DSI_BURST_MODE_BURST				0x2
+
+/* DSI input data RGB mode */
+#define DSI_LCD_INPUT_DATA_RGB_MODE_565			0
+#define DSI_LCD_INPUT_DATA_RGB_MODE_666PACKET		1
+#define DSI_LCD_INPUT_DATA_RGB_MODE_666UNPACKET		2
+#define DSI_LCD_INPUT_DATA_RGB_MODE_888			3
+
+/* LCD ISR clear mask */
+#define LCD_ISR_CLEAR_MASK_PXA168       0xffffffff
+#define LCD_ISR_CLEAR_MASK_PXA910       0xffff00cc
+
+extern struct lcd_regs *get_regs(int id);
+extern struct cmu_calibration cmu_cal[3];
+extern struct cmu_calibration cmu_cal_letter_box[3];
+extern struct cmu_res res;
+
+extern u32 dma_ctrl_read(int id, int ctrl1);
+extern void dma_ctrl_write(int id, int ctrl1, u32 value);
+extern void dma_ctrl_set(int id, int ctrl1, u32 mask, u32 value);
+extern void irq_mask_set(int id, u32 mask, u32 val);
+extern void irq_status_clear(int id, u32 mask);
+extern int lcd_clk_get(int id, u32 type);
+extern void lcd_clk_set(int id, u32 type, u32 mask, u32 val);
+
+extern int pxa168fb_spi_send(struct pxa168fb_info *fbi, void *cmd,
+				 int count, unsigned int spi_gpio_cs);
+extern int pxa688_cmu_ioctl(struct fb_info *info, unsigned int cmd,
+				 unsigned long arg);
+
+/* dsi related */
+extern void pxa168fb_dsi_send(struct pxa168fb_info *fbi, void *value);
+extern void dsi_send_cmd(struct pxa168fb_info *fbi,
+	enum dsi_packet_di data_type, enum dsi_packet_dcs_id dcs, u8 parameter);
+extern void set_dsi_low_power_mode(struct pxa168fb_info *fbi);
+extern void dsi_cclk_set(struct pxa168fb_info *fbi, int en);
+extern void dsi_set_dphy(struct pxa168fb_info *fbi);
+extern void dsi_reset(struct pxa168fb_info *fbi, int hold);
+extern void dsi_set_controller(struct pxa168fb_info *fbi);
+extern void dsi_lanes_enable(struct pxa168fb_info *fbi, int en);
+
+/* LVDS related */
+extern int pxa688_lvds_init(struct pxa168fb_info *fbi);
+
+/* VDMA related */
+#ifdef CONFIG_PXA688_VDMA
+#define EOF_TIMEOUT 20
+extern struct pxa168fb_vdma_info *request_vdma(int path, int vid);
+extern void pxa688_vdma_init(struct pxa168fb_vdma_info *lcd_vdma);
+extern void pxa688_vdma_config(struct pxa168fb_vdma_info *lcd_vdma);
+extern void pxa688_vdma_release(int path, int vid);
+extern int pxa688_vdma_en(struct pxa168fb_vdma_info *lcd_vdma,
+			int enable, int vid);
+static inline void vdma_info_update(struct pxa168fb_vdma_info *lcd_vdma,
+		int active, int dma_on, int pix_fmt, unsigned int rotation,
+		unsigned int yuv_format)
+{
+	lcd_vdma->active = active;
+	lcd_vdma->dma_on = dma_on;
+	lcd_vdma->pix_fmt = pix_fmt;
+	lcd_vdma->rotation = rotation;
+	lcd_vdma->yuv_format = yuv_format;
+}
+#else
+static inline struct pxa168fb_vdma_info *request_vdma(int path, int vid)
+{
+	return 0;
+}
+static inline void pxa688_vdma_init(struct pxa168fb_vdma_info *lcd_vdma) {}
+static inline void pxa688_vdma_config(struct pxa168fb_vdma_info *lcd_vdma) {}
+static inline void pxa688_vdma_release(int path, int vid) {}
+static inline int pxa688_vdma_en(struct pxa168fb_vdma_info *lcd_vdma,
+				int enable, int vid)
+{
+	return -EINVAL;
+}
+static inline void vdma_info_update(struct pxa168fb_vdma_info *lcd_vdma,
+				int active, int dma_on, int pix_fmt, unsigned int rotation,
+				unsigned int yuv_format) {}
+#endif
+
+/* misc */
+extern int fb_filter;
+extern int fb_vsmooth;
+extern int gfx_vsmooth;
+extern int vid_vsmooth;
+extern struct device_attribute dev_attr_misc;
+#ifdef CONFIG_PXA688_MISC
+extern int pxa688fb_vsmooth_set(int id, int vid, int en);
+extern int pxa688fb_partdisp_set(struct mvdisp_partdisp grap);
+extern void pxa688fb_partdisp_update(int id);
+extern int gamma_set(int path, int flag, char *gamma_table);
+extern void gamma_dump(int path, int lines);
+extern void dither_set(struct pxa168fb_info *fbi,
+	int table, int mode, int enable);
+#else
+static inline int pxa688fb_vsmooth_set(int id, int vid, int en)
+{
+	return 0;
+}
+static inline int pxa688fb_partdisp_set(struct mvdisp_partdisp grap)
+{
+	return -EINVAL;
+}
+static inline void pxa688fb_partdisp_update(int id) { }
+#define gamma_set(path, flag, gamma_table)		do {} while (0)
+#define gamma_dump(path, lines)				do {} while(0)
+#define dither_set(fbi, table, mode, enable)	do {} while (0)
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* __ASM_MACH_PXA168FB_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-apbc.h b/arch/arm/mach-mmp/include/mach/regs-apbc.h
index 8a37fb0..ca41444 100644
--- a/arch/arm/mach-mmp/include/mach/regs-apbc.h
+++ b/arch/arm/mach-mmp/include/mach/regs-apbc.h
@@ -15,6 +15,9 @@
 
 #define APBC_VIRT_BASE	(APB_VIRT_BASE + 0x015000)
 #define APBC_REG(x)	(APBC_VIRT_BASE + (x))
+/* add for AP controls GSSP device */
+#define CPBC_VIRT_BASE	(APB_VIRT_BASE + 0x03b000)
+#define CPBC_REG(x)	(CPBC_VIRT_BASE + (x))
 
 /*
  * APB clock register offsets for PXA168
@@ -47,8 +50,14 @@
 /*
  * APB Clock register offsets for PXA910
  */
+#define APBCP_VIRT_BASE	(APB_VIRT_BASE + 0x03B000)
+#define APBCP_REG(x)	(APBCP_VIRT_BASE + (x))
+
+#define APBC_PXA910_RIPC	APBCP_REG(0x038)
+
 #define APBC_PXA910_UART0	APBC_REG(0x000)
 #define APBC_PXA910_UART1	APBC_REG(0x004)
+#define APBC_PXA910_UART2	APBCP_REG(0x01c)
 #define APBC_PXA910_GPIO	APBC_REG(0x008)
 #define APBC_PXA910_PWM1	APBC_REG(0x00c)
 #define APBC_PXA910_PWM2	APBC_REG(0x010)
@@ -59,6 +68,7 @@
 #define APBC_PXA910_IPC		APBC_REG(0x024)
 #define APBC_PXA910_RTC		APBC_REG(0x028)
 #define APBC_PXA910_TWSI0	APBC_REG(0x02c)
+#define APBC_PXA910_TWSI1	APBCP_REG(0x0028)
 #define APBC_PXA910_KPC		APBC_REG(0x030)
 #define APBC_PXA910_TIMERS	APBC_REG(0x034)
 #define APBC_PXA910_TBROT	APBC_REG(0x038)
@@ -69,6 +79,9 @@
 #define APBC_PXA910_SSP3	APBC_REG(0x04c)
 #define APBC_PXA910_ASFAR	APBC_REG(0x050)
 #define APBC_PXA910_ASSAR	APBC_REG(0x054)
+/* GBS: clock for GSSP */
+#define APBC_PXA910_GBS		CPBC_REG(0x00c)
+#define APBC_PXA910_GCER	CPBC_REG(0x034)
 
 /*
  * APB Clock register offsets for MMP2
@@ -99,7 +112,9 @@
 #define APBC_MMP2_SSP5		APBC_REG(0x060)
 #define APBC_MMP2_AIB		APBC_REG(0x064)
 #define APBC_MMP2_ASFAR		APBC_REG(0x068)
+#define		MAGIC_ASFAR		0xbaba
 #define APBC_MMP2_ASSAR		APBC_REG(0x06c)
+#define		MAGIC_ASSAR		0xeb10
 #define APBC_MMP2_USIM		APBC_REG(0x070)
 #define APBC_MMP2_MPMU		APBC_REG(0x074)
 #define APBC_MMP2_IPC		APBC_REG(0x078)
@@ -111,6 +126,41 @@
 #define APBC_MMP2_THSENS1	APBC_REG(0x090)	/* Thermal Sensor */
 #define APBC_MMP2_THSENS_INTSTS	APBC_REG(0x0a4)
 
+/*
+ * APB Clock register offsets for PXA988
+ */
+#define APBC_PXA988_UART1	APBC_REG(0x000)
+#define APBC_PXA988_UART2	APBC_REG(0x004)
+#define APBC_PXA988_GPIO	APBC_REG(0x008)
+#define APBC_PXA988_PWM0	APBC_REG(0x00c)
+#define APBC_PXA988_PWM1	APBC_REG(0x010)
+#define APBC_PXA988_PWM2	APBC_REG(0x014)
+#define APBC_PXA988_PWM3	APBC_REG(0x018)
+#define APBC_PXA988_SSP0	APBC_REG(0x01c)
+#define APBC_PXA988_SSP1	APBC_REG(0x020)
+#define APBC_PXA988_IPC		APBC_REG(0x024)
+#define APBC_PXA988_RTC		APBC_REG(0x028)
+#define APBC_PXA988_TWSI0	APBC_REG(0x02c)
+#define APBC_PXA988_KPC		APBC_REG(0x030)
+#define APBC_PXA988_TIMERS	APBC_REG(0x034)
+#define APBC_PXA988_TBROT	APBC_REG(0x038)
+#define APBC_PXA988_AIB		APBC_REG(0x03c)
+#define APBC_PXA988_SW_JTAG	APBC_REG(0x040)
+#define APBC_PXA988_TIMERS1	APBC_REG(0x044)
+#define APBC_PXA988_ONEWIRE	APBC_REG(0x048)
+#define APBC_PXA988_SSP2	APBC_REG(0x04c)
+#define APBC_PXA988_ASFAR	APBC_REG(0x050)
+#define  AKEY_ASFAR		0xbaba
+#define APBC_PXA988_ASSAR	APBC_REG(0x054)
+#define  AKEY_ASSAR		0xeb10
+#define APBC_PXA988_DROTS	APBC_REG(0x058)
+#define APBC_PXA988_I2CIO	APBC_REG(0x05c)
+#define APBC_PXA988_TWSI1	APBC_REG(0x060)
+
+#define APBC_PXA988_UART0	APBCP_REG(0x01c)
+#define APBC_PXA988_PWRTWSI	APBCP_REG(0x028)
+#define APBC_PXA988_RIPC	APBCP_REG(0x038)
+
 /* Common APB clock register bit definitions */
 #define APBC_APBCLK	(1 << 0)  /* APB Bus Clock Enable */
 #define APBC_FNCLK	(1 << 1)  /* Functional Clock Enable */
diff --git a/arch/arm/mach-mmp/include/mach/regs-apmu.h b/arch/arm/mach-mmp/include/mach/regs-apmu.h
index 8447ac6..92fc312 100644
--- a/arch/arm/mach-mmp/include/mach/regs-apmu.h
+++ b/arch/arm/mach-mmp/include/mach/regs-apmu.h
@@ -17,9 +17,24 @@
 #define APMU_REG(x)	(APMU_VIRT_BASE + (x))
 
 /* Clock Reset Control */
+#define APMU_CC_SP	APMU_REG(0x000)
+#define APMU_CC_PJ	APMU_REG(0x004)
+#define APMU_CC2_PJ	APMU_REG(0x150)
+#define APMU_CC3_PJ	APMU_REG(0x188)
+#define APMU_DM_CC_SP	APMU_REG(0x008)
+#define APMU_DM_CC_PJ	APMU_REG(0x00c)
+#define APMU_DM2_CC_PJ	APMU_REG(0x158)
+#define APMU_SP_IDLE_CFG	APMU_REG(0x014)
+#define APMU_IDLE_CFG	APMU_REG(0x018)
+
+#define APMU_CCIC_GATE	APMU_REG(0x028)
+#define APMU_CCIC2_GATE APMU_REG(0x118)
+#define APMU_ISPDXO	APMU_REG(0x038)
+#define APMU_DSI	APMU_REG(0x044)
 #define APMU_IRE	APMU_REG(0x048)
 #define APMU_LCD	APMU_REG(0x04c)
-#define APMU_CCIC	APMU_REG(0x050)
+#define APMU_CCIC_RST	APMU_REG(0x050)
+#define APMU_CCIC2_RST	APMU_REG(0x0f4)
 #define APMU_SDH0	APMU_REG(0x054)
 #define APMU_SDH1	APMU_REG(0x058)
 #define APMU_USB	APMU_REG(0x05c)
@@ -27,9 +42,85 @@
 #define APMU_DMA	APMU_REG(0x064)
 #define APMU_GEU	APMU_REG(0x068)
 #define APMU_BUS	APMU_REG(0x06c)
+#define APMU_CORE_STATUS APMU_REG(0x090)
+#define APMU_GC	APMU_REG(0x0cc)
+#define APMU_GC_PD	APMU_REG(0x0d0)
+
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
 #define APMU_SDH2	APMU_REG(0x0e8)
 #define APMU_SDH3	APMU_REG(0x0ec)
-#define APMU_ETH	APMU_REG(0x0fc)
+#define APMU_SDH4	APMU_REG(0x15c)
+#elif defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988)
+#define APMU_SDH2	APMU_REG(0x0e0)
+#endif
+
+/* pxa988 MCK4 AHB clock */
+#if defined(CONFIG_CPU_PXA988)
+#define APMU_MCK4_CTL	APMU_REG(0x0e8)
+#endif
+
+#define APMU_CCIC_DBG	APMU_REG(0x088)
+#define APMU_CCIC2_DBG	APMU_REG(0x088)
+#define APMU_SRAM_PWR_DWN	APMU_REG(0x08c)
+#define APMU_VMETA	APMU_REG(0x0A4)
+#define APMU_SMC	APMU_REG(0x0d4)
+
+#define APMU_ISPPWR	APMU_REG(0x1FC)
+#define APMU_ISPCLK	APMU_REG(0x224)
+#define APMU_ISLD_CI_CTRL       APMU_REG(0x01E0)
+
+#define APMU_CP_CCR             APMU_REG(0x0000)
+#define APMU_CCR                APMU_REG(0x0004)
+#define APMU_CP_CCSR            APMU_REG(0x0008)
+#define APMU_CCSR               APMU_REG(0x000c)
+#define APMU_SQU_CLK_GATE_CTRL	APMU_REG(0x001c)
+#define APMU_LCD_CLK_RES_CTRL   APMU_REG(0x004c)
+#define APMU_DEBUG              APMU_REG(0x0088)
+#define APMU_IMR                APMU_REG(0x0098)
+#define APMU_IRWC		APMU_REG(0x009c)
+#define APMU_ISR                APMU_REG(0x00a0)
+#define APMU_DX8_CLK_RES_CTRL   APMU_REG(0x00a4)
+#define APMU_MC_HW_SLP_TYPE     APMU_REG(0x00b0)
+#define APMU_PLL_SEL_STATUS     APMU_REG(0x00c4)
+#define APMU_SMC_CLK_RES_CTRL   APMU_REG(0x00d4)
+#define APMU_PWR_CTRL_REG		APMU_REG(0x00d8)
+#define APMU_GC_CLK_RES_CTRL	APMU_REG(0x00cc)
+#define APMU_PWR_BLK_TMR_REG	APMU_REG(0x00dc)
+#define APMU_PWR_STATUS_REG     APMU_REG(0x00f0)
+
+#define APMU_CC2R               APMU_REG(0x0100)
+#define APMU_CC2SR              APMU_REG(0x0104)
+#define APMU_TRACE              APMU_REG(0x0108)
+
+#define APMU_SLIM_CLK_RES_CTRL	APMU_REG(0x0104)
+#define APMU_FSIC3_CLK_RES_CTRL APMU_REG(0x0100)
+#define APMU_LCD2_CLK_RES_CTRL  APMU_REG(0x0110)
+
+/* coda7542 */
+#define APMU_VPU_CLK_RES_CTRL	APMU_REG(0x00a4)
+
+/* CNM clock and power on/off register*/
+#define APMU_DX8_CLK_RES_CTRL   APMU_REG(0x00a4)
+#define APMU_PWR_CTRL_REG       APMU_REG(0x00d8)
+#define APMU_PWR_BLK_TMR_REG    APMU_REG(0x00dc)
+#define APMU_PWR_STATUS_REG     APMU_REG(0x00f0)
+
+#define APMU_ISLD_CI_PDWN_CTRL		APMU_REG(0x01e0)
+#define APMU_ISLD_DSPA_PDWN_CTRL	APMU_REG(0x01e4)
+#define APMU_ISLD_BCM_PDWN_CTRL		APMU_REG(0x01e8)
+#define APMU_ISLD_LCDMIPI_PDWN_CTRL	APMU_REG(0x01ec)
+#define APMU_ISLD_VMETA_PDWN_CTRL	APMU_REG(0x01f0)
+#define APMU_ISLD_GC2000_PDWN_CTRL	APMU_REG(0x01f4)
+#define APMU_ISLD_CPUMC_PDWN_CTRL	APMU_REG(0x01f8)
+
+#define APMU_ISLD_CMEM_CLKGATE_BYPASS	(1u << 5)
+#define APMU_ISLD_CMEM_DMMYCLK_EN	(1u << 4)
+
+#define APMU_MC_PAR_CTRL		APMU_REG(0x011c)
+
+/* Debug register */
+#define APMU_DEBUG		APMU_REG(0x0088)
+#define APMU_DEBUG2		APMU_REG(0x0190)
 
 #define APMU_FNCLK_EN	(1 << 4)
 #define APMU_AXICLK_EN	(1 << 3)
@@ -48,4 +139,110 @@
 #define APMU_PXA168_SD2_WAKE_CLR	(1 << 1)
 #define APMU_PXA168_SD1_WAKE_CLR	(1 << 0)
 
+#define APMU_PXA910_KP_WAKE_CLR		(1 << 3)
+#define APMU_PXA988_KP_WAKE_CLR		(1 << 3)
+
+#define APMU_GC_156M		0x0
+#define APMU_GC_312M		0x40
+#define APMU_GC_PLL2		0x80
+#define APMU_GC_PLL2_DIV2	0xc0
+#define APMU_GC_624M		0xc0 /* added according to Aspen SW spec v2.8*/
+
+#define APMU_VMETA_CLK_RES_CTRL	APMU_VMETA
+/* VMeta Technology Power Mode */
+#define APMU_VMETA_CLK_DIV_MASK			(0xF << 16)
+#define APMU_VMETA_CLK_DIV_1			(0x1 << 16)
+#define APMU_VMETA_CLK_DIV_2                    (0x2 << 16)
+#define APMU_VMETA_CLK_DIV_4                    (0x4 << 16)
+#define APMU_VMETA_CLK_DIV_8                    (0x8 << 16)
+#define APMU_VMETA_CLK_DIV_SHIFT		16
+#define APMU_VMETA_CLK_PLL2			(0x1 << 6)
+#define APMU_VMETA_CLK_SEL_SHIFT		6
+#define APMU_VMETA_ACLK_MASK			(0x3 << 11)
+#define APMU_VMETA_ACLK_SEL_SHIFT		11
+/* VMeta Technology Power Up */
+#define APMU_VMETA_PWRUP_ON			(3 << 9)
+#define APMU_VMETA_PWRUP_SLOW_RAMP		(1 << 9)
+#define APMU_VMETA_PWRUP_MASK			(3 << 9)
+/* VMeta Technology Isolation Enable */
+#define APMU_VMETA_ISB				(1 << 8)
+/* VMeta Technology Clock Select */
+#define APMU_VMETA_CLK_SEL_MASK			(3 << 6)
+/* VMeta Technology Peripheral Clock Enable */
+#define APMU_VMETA_CLK_EN			(1 << 4)
+/* VMeta Technology AXI Clock Enable */
+#define APMU_VMETA_AXICLK_EN			(1 << 3)
+/* VMeta Technology Memory Redundancy Repair Start */
+#define APMU_VMETA_REDUN_START			(1 << 2)
+/* VMeta Technology Peripheral Reset 1 */
+#define APMU_VMETA_RST				(1 << 1)
+/* VMeta Technology AXI Reset */
+#define APMU_VMETA_AXI_RST			(1 << 0)
+#define APMU_VMETA_CLK_RES_CTRL_DFT		(APMU_VMETA_CLK_DIV_4)
+
+/* VMeta Technology Clock/Reset Control Register For MMP2 */
+/* [31:16]	Reserved */
+/* [15]		Bus Clock Source */
+#define APMU_MMP2_VMETA_ACLK_SRC		(1 << 15)
+/* [14:12]	Clock Select */
+#define APMU_MMP2_VMETA_ACLK_SEL_MASK	(7 << 12)
+#define APMU_MMP2_VMETA_ACLK_SEL_SHIFT	12
+/* [11]		Power Mode */
+#define APMU_MMP2_VMETA_PWR_CTRL		(1 << 11)
+/* [10]		Power Up */
+#define APMU_MMP2_VMETA_PWRUP			(1 << 10)
+/* [9]		Input Isolation Enable */
+#define APMU_MMP2_VMETA_INP_ISB			(1 << 9)
+/* [8]		Isolation Enable */
+#define APMU_MMP2_VMETA_ISB				(1 << 8)
+/* [7:5]	Clock Select */
+#define APMU_MMP2_VMETA_CLK_SEL_MASK	(7 << 5)
+#define APMU_MMP2_VMETA_CLK_SEL_SHIFT	5
+/* [4]		Peripheral Clock Enable */
+#define APMU_MMP2_VMETA_CLK_EN			(1 << 4)
+/* [3]		AXI Clock Enable */
+#define APMU_MMP2_VMETA_AXICLK_EN		(1 << 3)
+/* [2]		Reserved */
+/* [1]		Peripheral Reset 1 */
+#define APMU_MMP2_VMETA_RST1	(1 << 1)
+/* [0]		AXI Reset */
+#define APMU_MMP2_VMETA_AXI_RST	(1 << 0)
+
+/* USB HSIC/FSIC*/
+#define APMU_USBHSIC1   APMU_REG(0x0f8)
+#define APMU_USBHSIC2   APMU_REG(0x0fc)
+#define APMU_USBFSIC    APMU_REG(0x100)
+#define APMU_FASTENET	APMU_REG(0x210)
+
+/* Audio Island */
+#define APMU_AUDIO_CLK_RES_CTRL		APMU_REG(0x010c)
+#define APMU_AUDIO_DSA			APMU_REG(0x0164)
+#define APMU_ISLD_DSPA_CTRL		APMU_REG(0x01e4)
+#define APMU_AUDIO_SRAM_PWR		APMU_REG(0x0240)
+
+#define APMU_PJ_C0_CC4			APMU_REG(0x0248)
+#define APMU_PJ_C1_CC4			APMU_REG(0x024C)
+#define APMU_PJ_C2_CC4			APMU_REG(0x0250)
+
+/* PXA988 CA9 core idle configuration */
+#define PMU_CA9_CORE0_IDLE_CFG		APMU_REG(0x0124)
+#define PMU_CA9_CORE1_IDLE_CFG		APMU_REG(0x0128)
+
+/* PXA988 CA9 MP idle configuration */
+#define PMU_CA9MP_IDLE_CFG0		APMU_REG(0x0120)
+#define PMU_CA9MP_IDLE_CFG1		APMU_REG(0x00e4)
+
+/* PXA988 AP Clock Control Register2 */
+#define PMU_CC2_AP			APMU_REG(0x0100)
+
+#define APMU_AUDIO_PWR_UP		(3 << 9)
+#define APMU_AUDIO_PWR_DOWN		(0 << 9)
+#define APMU_AUDIO_ISO_DIS		(1 << 8)
+#define APMU_AUDIO_CLK_SEL_PLL1_DIV_2	(0 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL2_DIV_2	(1 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL2_DIV_3	(2 << 6)
+#define APMU_AUDIO_CLK_SEL_PLL1_DIV_8	(3 << 6)
+#define APMU_AUDIO_CLK_ENA		(1 << 4)
+#define APMU_AUDIO_RST_DIS		(1 << 1)
+
 #endif /* __ASM_MACH_REGS_APMU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-audio.h b/arch/arm/mach-mmp/include/mach/regs-audio.h
new file mode 100644
index 0000000..e688dec
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-audio.h
@@ -0,0 +1,138 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-audio.h
+ *
+ *   Audio Subsystem Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_AUDIO_H
+#define __ASM_MACH_REGS_AUDIO_H
+
+#include <mach/addr-map.h>
+
+#define AUD_VIRT_BASE_MMP2		(AXI_VIRT_BASE + 0xa0c00)
+#define AUD_REG(x)		(AUD_VIRT_BASE_MMP2 + (x))
+
+#define AUD_CTL			AUD_REG(0x34)
+#define AUD_PLL_CTL0		AUD_REG(0x38)
+#define AUD_PLL_CTL1		AUD_REG(0x3c)
+
+/* Audio Control Register */
+#define AUD_CTL_S2_CLK_SEL_MASK			(1 << 23)
+#define AUD_CTL_S2_CLK_SEL_I2S			(1 << 23)
+#define AUD_CTL_S2_CLK_SEL_AUDIO_PLL		(0 << 23)
+#define AUD_CTL_S2_CLK_DIV_MASK			(0x3f << 17)
+#define AUD_CTL_S2_CLK_DIV(x)			((x) << 17)
+#define AUD_CTL_S2_ENA				(1 << 16)
+
+#define AUD_CTL_S1_CLK_SEL_MASK			(1 << 7)
+#define AUD_CTL_S1_CLK_SEL_I2S			(1 << 7)
+#define AUD_CTL_S1_CLK_SEL_AUDIO_PLL		(0 << 7)
+#define AUD_CTL_S1_CLK_DIV_MASK			(0x3f << 9)
+#define AUD_CTL_S1_CLK_DIV(x)			((x) << 9)
+#define AUD_CTL_S1_ENA				(1 << 8)
+
+#define AUD_CTL_SYSCLK_DIV_MASK			(0x3f << 1)
+#define AUD_CTL_SYSCLK_DIV(x)			((x) << 1)
+#define AUD_CTL_SYSCLK_ENA			(1 << 0)
+
+/* Audio PLL Control 0 Register */
+#define AUD_PLL_CTL0_DIV_OCLK_MODULO(x)		((x) << 28)
+#define AUD_PLL_CTL0_FRACT(x)			((x) << 8)
+#define AUD_PLL_CTL0_ENA_DITHER			(1 << 7)
+#define AUD_PLL_CTL0_ICP_2UA			(0 << 5)
+#define AUD_PLL_CTL0_ICP_5UA			(1 << 5)
+#define AUD_PLL_CTL0_ICP_7UA			(2 << 5)
+#define AUD_PLL_CTL0_ICP_10UA			(3 << 5)
+#define AUD_PLL_CTL0_DIV_FBCCLK(x)		((x) << 3)
+#define AUD_PLL_CTL0_DIV_MCLK(x)		((x) << 2)
+#define AUD_PLL_CTL0_PD_OVPROT_DIS		(1 << 1)
+#define AUD_PLL_CTL0_PU				(1 << 0)
+
+/* Audio PLL Control 1 Register */
+#define AUD_PLL_CTL1_EN_VCOX2			(1 << 17)
+#define AUD_PLL_CTL1_PLL_LOCK			(1 << 16)
+#define AUD_PLL_CTL1_CLK_SEL_AUDIO_PLL		(1 << 11)
+#define AUD_PLL_CTL1_CLK_SEL_VCXO		(0 << 11)
+#define AUD_PLL_CTL1_DIV_OCLK_PATTERN(x)	((x) << 0)
+
+/*
+ * SSPA Registers
+ */
+#define SSPA_RXD		(0x00)
+#define SSPA_RXID		(0x04)
+#define SSPA_RXCTL		(0x08)
+#define SSPA_RXSP		(0x0c)
+#define SSPA_RXFIFO_UL		(0x10)
+#define SSPA_RXINT_MASK		(0x14)
+#define SSPA_RXC		(0x18)
+#define SSPA_RXFIFO_NOFS	(0x1c)
+#define SSPA_RXFIFO_SIZE	(0x20)
+
+#define SSPA_TXD		(0x80)
+#define SSPA_TXID		(0x84)
+#define SSPA_TXCTL		(0x88)
+#define SSPA_TXSP		(0x8c)
+#define SSPA_TXFIFO_LL		(0x90)
+#define SSPA_TXINT_MASK		(0x94)
+#define SSPA_TXC		(0x98)
+#define SSPA_TXFIFO_NOFS	(0x9c)
+#define SSPA_TXFIFO_SIZE	(0xa0)
+
+/* SSPA Control Register */
+#define	SSPA_CTL_XPH		(1 << 31)	/* Read Phase */
+#define	SSPA_CTL_XFIG		(1 << 15)	/* Transmit Zeros \
+							when FIFO Empty */
+#define	SSPA_CTL_JST		(1 << 3)	/* Audio Sample \
+							Justification */
+#define	SSPA_CTL_XFRLEN2_MASK	(7 << 24)
+#define	SSPA_CTL_XFRLEN2(x)	((x) << 24)	/* Transmit Frame \
+							Length in Phase 2 */
+#define	SSPA_CTL_XWDLEN2_MASK	(7 << 21)
+#define	SSPA_CTL_XWDLEN2(x)	((x) << 21)	/* Transmit Word \
+							Length in Phase 2 */
+#define	SSPA_CTL_XDATDLY(x)	((x) << 19)	/* Tansmit Data Delay */
+#define	SSPA_CTL_XSSZ2_MASK	(7 << 16)
+#define	SSPA_CTL_XSSZ2(x)	((x) << 16)	/* Transmit Sample \
+							Audio Size */
+#define	SSPA_CTL_XFRLEN1_MASK	(7 << 8)
+#define	SSPA_CTL_XFRLEN1(x)	((x) << 8)	/* Transmit Frame \
+							Length in Phase 1 */
+#define	SSPA_CTL_XWDLEN1_MASK	(7 << 5)
+#define	SSPA_CTL_XWDLEN1(x)	((x) << 5)	/* Transmit Word Length \
+							in Phase 1 */
+#define	SSPA_CTL_XSSZ1_MASK	(7 << 0)
+#define	SSPA_CTL_XSSZ1(x)	((x) << 0)	/* XSSZ1 */
+
+#define SSPA_CTL_8_BITS		(0x0)		/* Sample Size */
+#define SSPA_CTL_12_BITS	(0x1)
+#define SSPA_CTL_16_BITS	(0x2)
+#define SSPA_CTL_20_BITS	(0x3)
+#define SSPA_CTL_24_BITS	(0x4)
+#define SSPA_CTL_32_BITS	(0x5)
+
+/* SSPA Serial Port Register */
+#define	SSPA_SP_WEN		(1 << 31)	/* Write Configuration \
+								Enable */
+#define	SSPA_SP_MSL		(1 << 18)	/* Master Slave \
+							Configuration */
+#define	SSPA_SP_CLKP		(1 << 17)	/* CLKP Polarity \
+							Clock Edge Select */
+#define	SSPA_SP_FSP		(1 << 16)	/* FSP Polarity \
+							Clock Edge Select */
+#define	SSPA_SP_FFLUSH		(1 << 2)	/* FIFO Flush */
+#define	SSPA_SP_S_RST		(1 << 1)	/* Active High Reset Signal */
+#define	SSPA_SP_S_EN		(1 << 0)	/* Serial Clock \
+							Domain Enable */
+#define	SSPA_SP_FWID(x)		((x) << 20)	/* Frame-Sync Width */
+#define	SSPA_TXSP_FPER(x)	((x) << 4)	/* Frame-Sync Active */
+
+/* SSPA and sysclk pll sources */
+#define SSPA_AUDIO_PLL                          0
+#define SSPA_I2S_PLL                            1
+#define SSPA_VCXO_PLL                           2
+
+#endif /* __ASM_MACH_REGS_AUDIO_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-ciu.h b/arch/arm/mach-mmp/include/mach/regs-ciu.h
new file mode 100644
index 0000000..cddbe1d
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-ciu.h
@@ -0,0 +1,71 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-ciu.h
+ *
+ *  CPU Interface Unit Registers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_CIU_H
+#define __ASM_MACH_REGS_CIU_H
+
+#include <mach/addr-map.h>
+
+#define CIU_VIRT_BASE		(AXI_VIRT_BASE + 0x82c00)
+#define CIU_REG(x)		(CIU_VIRT_BASE + (x))
+
+#define CIU_CHIP_ID		CIU_REG(0x0000)
+#define CIU_CPU_CONF		CIU_REG(0x0008)
+#define CIU_CPU_SRAM_SPD	CIU_REG(0x0010)
+#define CIU_CPU_L2C_SRAM_SPD	CIU_REG(0x0018)
+#define CIU_MCB_CONF		CIU_REG(0x001c)
+#define CIU_SYS_BOOT_CNTRL	CIU_REG(0x0020)
+#define CIU_SW_BRANCH_ADDR	CIU_REG(0x0024)
+#define CIU_PERF_COUNT0_CNTRL	CIU_REG(0x0028)
+#define CIU_PERF_COUNT1_CNTRL	CIU_REG(0x002c)
+#define CIU_PERF_COUNT2_CNTRL	CIU_REG(0x0030)
+#define CIU_PERF_COUNT0		CIU_REG(0x0034)
+#define CIU_PERF_COUNT1		CIU_REG(0x0038)
+#define CIU_PERF_COUNT2		CIU_REG(0x003c)
+#define CIU_MC_CONF		CIU_REG(0x0040)
+#define CIU_MCB_SRAM_SPD	CIU_REG(0x0044)
+#define CIU_AXI_SRAM_SPD	CIU_REG(0x0048)
+#define CIU_DDR_ILV_CTRL	CIU_REG(0x00a0)
+#define CIU_FABRIC_CKGT_CTRL0	CIU_REG(0x0064)
+#define CIU_FABRIC_CKGT_CTRL1	CIU_REG(0x0068)
+#define CIU_FABRIC_CKGT_CTRL2	CIU_REG(0x00dc)
+
+/* This is used by pxa988 for PMU interrupt */
+#define CIU_CA9_CPU_CORE0_CONF CIU_REG(0x00d0)
+#define CIU_CA9_CPU_CORE1_CONF CIU_REG(0x00e0)
+
+/* This is used by pxa988 for warm reset */
+#define CIU_WARM_RESET_VECTOR   CIU_REG(0x00d8)
+
+/* used for set xtc */
+#define CIU_GPU_XTC_REG		CIU_REG(0x00a4)
+#define CIU_VPU_XTC_REG		CIU_REG(0x00a8)
+#define CIU_CA9_CPU_CONF_SRAM0	CIU_REG(0Xc8)
+#define CIU_CA9_CPU_CONF_SRAM1	CIU_REG(0Xcc)
+
+static __maybe_unused int ciu_ddr_ilv_on(void)
+{
+	return ((__raw_readl(CIU_DDR_ILV_CTRL) & 0x7f) != 0);
+}
+
+static __maybe_unused u32 ciu_ddr_ilv_size(void)
+{
+	u32 regval;
+	regval = __raw_readl(CIU_DDR_ILV_CTRL) & 0x7f;
+	/* there should be only 1 bit set */
+	BUG_ON(((regval - 1) & regval) != 0);
+	if ((regval & (~0x1f)) != 0)
+		return regval << 24;
+	else
+		return (regval * regval) << 12;
+}
+
+
+#endif /* __ASM_MACH_REGS_CIU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-fastenet.h b/arch/arm/mach-mmp/include/mach/regs-fastenet.h
new file mode 100644
index 0000000..6186bee
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-fastenet.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_REGS_FASTENET_H
+#define __ASM_ARCH_REGS_FASTENET_H
+
+#define MMP3_FASTENET_REGBASE			(0xd427f000)
+#define MMP3_FASTENET_REGLEN			0x600
+
+/* Duplex, half or full. */
+#define DUPLEX_HALF 0x00
+#define DUPLEX_FULL 0x01
+
+
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/regs-fuse.h b/arch/arm/mach-mmp/include/mach/regs-fuse.h
new file mode 100644
index 0000000..a704e35
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-fuse.h
@@ -0,0 +1,52 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-fuse.h
+ *
+ *   Fuse Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_FUSE_H
+#define __ASM_MACH_FUSE_H
+
+#include <mach/addr-map.h>
+
+#define WTM_PHYS_BASE	(AXI_PHYS_BASE + 0x90000)
+#define WTM_VIRT_BASE	(AXI_VIRT_BASE + 0x90000)
+#define WTM_PHYS_SIZE	(0x3004)
+
+#define MMP2_FUSE_BLK0_CFG1		(0x2904)
+#define MMP2_FUSE_BLK0_CFG2		(0x2908)
+#define MMP2_FUSE_BLK0_CFG3		(0x290C)
+#define MMP2_FUSE_BLK0_CFG4		(0x2910)
+#define MMP2_FUSE_BLK0_CFG5		(0x2914)
+#define MMP2_FUSE_BLK0_CFG6		(0x2918)
+#define MMP2_FUSE_BLK0_CFG7		(0x291C)
+#define MMP2_FUSE_BLK0_CFG8		(0x2920)
+
+#define MMP2_FUSE_BLK3_CFG1		(0x2888)
+#define MMP2_FUSE_BLK3_CFG2		(0x288C)
+#define MMP2_FUSE_BLK3_CFG3		(0x2890)
+#define MMP2_FUSE_BLK3_CFG4		(0x2894)
+#define MMP2_FUSE_BLK3_CFG5		(0x2898)
+#define MMP2_FUSE_BLK3_CFG6		(0x289C)
+#define MMP2_FUSE_BLK3_CFG7		(0x28A0)
+#define MMP2_FUSE_BLK3_CFG8		(0x29A4)
+
+#define MMP2_FUSE_BLK8_CFG1		(0x28A8)
+#define MMP2_FUSE_BLK8_CFG2		(0x28AC)
+#define MMP2_FUSE_BLK8_CFG3		(0x28B0)
+#define MMP2_FUSE_BLK8_CFG4		(0x28B4)
+#define MMP2_FUSE_BLK8_CFG5		(0x28B8)
+#define MMP2_FUSE_BLK8_CFG6		(0x28BC)
+#define MMP2_FUSE_BLK8_CFG7		(0x28C0)
+#define MMP2_FUSE_BLK8_CFG8		(0x28C4)
+
+#define MMP2_FUSE_BLK9_CFG1		(0x28C8)
+#define MMP2_FUSE_BLK9_CFG2		(0x28CC)
+#define MMP2_FUSE_BLK9_CFG3		(0x28D0)
+#define MMP2_FUSE_BLK9_CFG4		(0x28D4)
+
+#endif /* __ASM_MACH_FUSE_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-icu.h b/arch/arm/mach-mmp/include/mach/regs-icu.h
index f882d91..309afec 100644
--- a/arch/arm/mach-mmp/include/mach/regs-icu.h
+++ b/arch/arm/mach-mmp/include/mach/regs-icu.h
@@ -45,17 +45,25 @@
 #define MMP2_ICU_PJ4_FIQ_STATUS0	ICU_REG(0x140)
 #define MMP2_ICU_PJ4_FIQ_STATUS1	ICU_REG(0x144)
 
+#define ICU_DMAIRQ_MASK		ICU_REG(0x11c)
+#define ICU_DMAFIQ_MASK		ICU_REG(0x120)
+#define ICU_DMAIRQ_STATUS	ICU_REG(0x128)
+
 #define MMP2_ICU_INT4_STATUS		ICU_REG(0x150)
 #define MMP2_ICU_INT5_STATUS		ICU_REG(0x154)
 #define MMP2_ICU_INT17_STATUS		ICU_REG(0x158)
 #define MMP2_ICU_INT35_STATUS		ICU_REG(0x15c)
 #define MMP2_ICU_INT51_STATUS		ICU_REG(0x160)
+#define MMP2_ICU_INT9_STATUS		ICU_REG(0x180)
+#define MMP2_ICU_INT55_STATUS		ICU_REG(0x188)
 
 #define MMP2_ICU_INT4_MASK		ICU_REG(0x168)
 #define MMP2_ICU_INT5_MASK		ICU_REG(0x16C)
 #define MMP2_ICU_INT17_MASK		ICU_REG(0x170)
 #define MMP2_ICU_INT35_MASK		ICU_REG(0x174)
 #define MMP2_ICU_INT51_MASK		ICU_REG(0x178)
+#define MMP2_ICU_INT9_MASK		ICU_REG(0x17c)
+#define MMP2_ICU_INT55_MASK		ICU_REG(0x184)
 
 #define MMP2_ICU_SP_IRQ_SEL		ICU_REG(0x100)
 #define MMP2_ICU_PJ4_IRQ_SEL		ICU_REG(0x104)
@@ -68,4 +76,132 @@
 #define MMP2_ICU_INV_COMMTX		(1 << 2)
 #define MMP2_ICU_INV_COMMRX		(1 << 3)
 
+#if defined(CONFIG_CPU_MMP3)
+
+#define ICU1_VIRT_BASE	 (AXI_VIRT_BASE + 0x82000)
+#define ICU1_REG(x)	 (ICU1_VIRT_BASE + (x))
+#define ICU1_INT_CONF(n) ICU1_REG((n) << 2)
+
+#define ICU2_VIRT_BASE	 (AXI_VIRT_BASE + 0x84000)
+#define ICU2_REG(x)	 (ICU2_VIRT_BASE + (x))
+#define ICU2_INT_CONF(n) ICU2_REG((n) << 2)
+
+/*
++ * FIQ0 routes to SP FIQ
++ * IRQ0 routes to SP IRQ
++ * IRQ1 routes to PJ4-MP1 IRQ
++ * IRQ2 routes to PJ4-MP1 FIQ
++ * IRQ3 routes to PJ4-MP2 IRQ
++ * IRQ4 routes to PJ4-MP2 FIQ
++ * IRQ5 routes to PJ4-mm IRQ
++ * IRQ6 routes to PJ4-mm FIQ
++ */
+
+#define ICU1_INT_ROUTE_SP_IRQ_FIQ	(1 << 4)
+#define ICU1_INT_ROUTE_PJMP1_IRQ	(1 << 5)
+#define ICU1_INT_ROUTE_PJMP1_FIQ	(1 << 6)
+
+#define ICU2_INT_ROUTE_PJMP2_IRQ	(1 << 4)
+#define ICU2_INT_ROUTE_PJMP2_FIQ	(1 << 5)
+#define ICU2_INT_ROUTE_PJMM_IRQ		(1 << 6)
+#define ICU2_INT_ROUTE_PJMM_FIQ		(1 << 7)
+
+#define MMP3_ICU_IRQ_55_CONF		ICU1_REG(0x0DC)
+#define MMP3_ICU_IRQ0_SEL_INT_NUM	ICU1_REG(0x100)
+#define MMP3_ICU_IRQ1_SEL_INT_NUM	ICU1_REG(0x104)
+#define MMP3_ICU_IRQ2_SEL_INT_NUM	ICU1_REG(0x108)
+#define MMP3_ICU_GBL_IRQ0_MSK		ICU1_REG(0x10C)
+#define MMP3_ICU_GBL_IRQ1_MSK		ICU1_REG(0x110)
+#define MMP3_ICU_GBL_IRQ2_MSK		ICU1_REG(0x114)
+#define MMP3_ICU_DMA_IRQ0_MSK		ICU1_REG(0x118)
+#define MMP3_ICU_DMA_IRQ1_MSK		ICU1_REG(0x11C)
+#define MMP3_ICU_DMA_IRQ2_MSK		ICU1_REG(0x120)
+#define MMP3_ICU_DMA_IRQ0_STATUS	ICU1_REG(0x124)
+#define MMP3_ICU_DMA_IRQ1_STATUS	ICU1_REG(0x128)
+#define MMP3_ICU_DMA_IRQ2_STATUS	ICU1_REG(0x12C)
+#define MMP3_ICU_IRQ0_STATUS_0		ICU1_REG(0x130)
+#define MMP3_ICU_IRQ0_STATUS_1		ICU1_REG(0x134)
+#define MMP3_ICU_IRQ1_STATUS_0		ICU1_REG(0x138)
+#define MMP3_ICU_IRQ1_STATUS_1		ICU1_REG(0x13C)
+#define MMP3_ICU_IRQ2_STATUS_0		ICU1_REG(0x140)
+#define MMP3_ICU_IRQ2_STATUS_1		ICU1_REG(0x144)
+#define MMP3_ICU_INT_4_STATUS		ICU1_REG(0x150)
+#define MMP3_ICU_INT_5_STATUS		ICU1_REG(0x154)
+#define MMP3_ICU_INT_17_STATUS		ICU1_REG(0x158)
+#define MMP3_ICU_INT_35_STATUS		ICU1_REG(0x15C)
+#define MMP3_ICU_INT_51_STATUS		ICU1_REG(0x160)
+#define MMP3_ICU_INT_INVERT		ICU1_REG(0x164)
+#define MMP3_ICU_INT_4_MASK		ICU1_REG(0x168)
+#define MMP3_ICU_INT_5_MASK		ICU1_REG(0x16C)
+#define MMP3_ICU_INT_17_MASK		ICU1_REG(0x170)
+#define MMP3_ICU_INT_35_MASK		ICU1_REG(0x174)
+#define MMP3_ICU_INT_51_MASK		ICU1_REG(0x178)
+#define MMP3_ICU_INT_55_MASK		ICU1_REG(0x17C)
+#define MMP3_ICU_INT_57_MASK		ICU1_REG(0x180)
+#define MMP3_ICU_INT_55_STATUS		ICU1_REG(0x184)
+#define MMP3_ICU_INT_57_STATUS		ICU1_REG(0x188)
+#define MMP3_ICU_INT_6_MASK		ICU1_REG(0x1A4)
+#define MMP3_ICU_INT_8_MASK		ICU1_REG(0x1A8)
+#define MMP3_ICU_INT_18_MASK		ICU1_REG(0x1AC)
+#define MMP3_ICU_INT_30_MASK		ICU1_REG(0x1B0)
+#define MMP3_ICU_INT_42_MASK		ICU1_REG(0x1B4)
+#define MMP3_ICU_INT_58_MASK		ICU1_REG(0x1B8)
+#define MMP3_ICU_INT_6_STATUS		ICU1_REG(0x1BC)
+#define MMP3_ICU_INT_8_STATUS		ICU1_REG(0x1C0)
+#define MMP3_ICU_INT_18_STATUS		ICU1_REG(0x1C4)
+#define MMP3_ICU_INT_30_STATUS		ICU1_REG(0x1C8)
+#define MMP3_ICU_INT_42_STATUS		ICU1_REG(0x1CC)
+#define MMP3_ICU_INT_58_STATUS		ICU1_REG(0x1D0)
+
+
+#define MMP3_ICU_IRQ3_SEL_INT_NUM	ICU2_REG(0x100)
+#define MMP3_ICU_IRQ4_SEL_INT_NUM	ICU2_REG(0x104)
+#define MMP3_ICU_IRQ5_SEL_INT_NUM	ICU2_REG(0x108)
+#define MMP3_ICU_GBL_IRQ3_MSK		ICU2_REG(0x10C)
+#define MMP3_ICU_GBL_IRQ4_MSK		ICU2_REG(0x110)
+#define MMP3_ICU_GBL_IRQ5_MSK		ICU2_REG(0x114)
+#define MMP3_ICU_DMA_IRQ3_MSK		ICU2_REG(0x118)
+#define MMP3_ICU_DMA_IRQ4_MSK		ICU2_REG(0x11C)
+#define MMP3_ICU_DMA_IRQ5_MSK		ICU2_REG(0x120)
+#define MMP3_ICU_DMA_IRQ3_STATUS	ICU2_REG(0x124)
+#define MMP3_ICU_DMA_IRQ4_STATUS	ICU2_REG(0x128)
+#define MMP3_ICU_DMA_IRQ5_STATUS	ICU2_REG(0x12C)
+#define MMP3_ICU_IRQ3_STATUS_0		ICU2_REG(0x130)
+#define MMP3_ICU_IRQ3_STATUS_1		ICU2_REG(0x134)
+#define MMP3_ICU_IRQ4_STATUS_0		ICU2_REG(0x138)
+#define MMP3_ICU_IRQ4_STATUS_1		ICU2_REG(0x13C)
+#define MMP3_ICU_IRQ5_STATUS_0		ICU2_REG(0x140)
+#define MMP3_ICU_IRQ5_STATUS_1		ICU2_REG(0x144)
+#define MMP3_ICU_IRQ6_SEL_INT_NUM	ICU2_REG(0x18C)
+#define MMP3_ICU_GBL_IRQ6_MSK		ICU2_REG(0x190)
+#define MMP3_ICU_DMA_IRQ6_MSK		ICU2_REG(0x194)
+#define MMP3_ICU_DMA_IRQ6_STATUS	ICU2_REG(0x198)
+#define MMP3_ICU_IRQ6_STATUS_0		ICU2_REG(0x19C)
+#define MMP3_ICU_IRQ6_STATUS_1		ICU2_REG(0x1A0)
+
+#endif /* CONFIG_CPU_MMP3 */
+
+#if defined(CONFIG_CPU_PXA988)
+#define PXA988_ICU_CP_FIQ_NUM		ICU_REG(0x100)
+#define PXA988_ICU_CP_IRQ_NUM		ICU_REG(0x104)
+#define PXA988_ICU_A9C0_FIQ_NUM		ICU_REG(0x108)
+#define PXA988_ICU_A9C0_IRQ_NUM		ICU_REG(0x10C)
+#define PXA988_ICU_CP_GBL_INT_MSK	ICU_REG(0x110)
+#define PXA988_ICU_A9C0_GBL_INT_MSK	ICU_REG(0x114)
+#define PXA988_ICU_DMA_CP_INT_MSK	ICU_REG(0x118)
+#define PXA988_ICU_DMA_A9C0_INT_MSK	ICU_REG(0x11C)
+#define PXA988_ICU_DMA_CP_INT_STATUS	ICU_REG(0x120)
+#define PXA988_ICU_DMA_A9C0_INT_STATUS	ICU_REG(0x124)
+#define PXA988_ICU_INT_STATUS_0		ICU_REG(0x128)
+#define PXA988_ICU_INT_STATUS_1		ICU_REG(0x12C)
+#define PXA988_ICU_ARM_INT_MSK		ICU_REG(0x130)
+#define PXA988_ICU_ARM_INT_STATUS	ICU_REG(0x134)
+#define PXA988_ICU_PA_CLR		ICU_REG(0x138)
+#define PXA988_ICU_A9C1_FIQ_NUM		ICU_REG(0x13C)
+#define PXA988_ICU_A9C1_IRQ_NUM		ICU_REG(0x140)
+#define PXA988_ICU_A9C1_GBL_INT_MSK	ICU_REG(0x144)
+#define PXA988_ICU_DMA_A9C1_INT_MSK	ICU_REG(0x148)
+#define PXA988_ICU_DMA_A9C1_INT_STATUS	ICU_REG(0x14C)
+#endif /* CONFIG_CPU_PXA988 */
+
 #endif /* __ASM_MACH_ICU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-mcu.h b/arch/arm/mach-mmp/include/mach/regs-mcu.h
new file mode 100644
index 0000000..207cb9c
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-mcu.h
@@ -0,0 +1,143 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-mcu.h
+ *
+ *   Memory Control Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_MCU_H
+#define __ASM_MACH_MCU_H
+
+#include <mach/addr-map.h>
+
+#ifdef CONFIG_CPU_MMP3
+#define FIXADDR(base, offset)		((u32 *)(((u32)base)+offset))
+#define DMCU_HWTCTRL(base)		FIXADDR(base, 0x1c0)
+#define DMCU_HWTDAT0(base)		FIXADDR(base, 0x1c8)
+#define DMCU_HWTDAT1(base)		FIXADDR(base, 0x1cc)
+#else
+#define DMCU_VIRT_REG(x)		(DMCU_VIRT_BASE + (x))
+#define DMCU_PHYS_REG(x)		(DMCU_PHYS_BASE + (x))
+#define DMCU_HWTCTRL			(0x1c0)
+#define DMCU_HWTDAT0			(0x1c8)
+#define DMCU_HWTDAT1			(0x1cc)
+#endif
+#define DMCU_HWTPAUSE			(0x00010000)
+#define DMCU_HWTEND			(0x00020000)
+#define DMCU_HWTWRITE			(0x80000000)
+
+#define DMCU_CPU_ID_REV			(0x00)
+#define DMCU_STATUS			(0x04)
+#define DMCU_DRAM_STATUS		(0x08)
+
+#define DMCU_MAP_CS0			(0x10)
+#define DMCU_MAP_CS1			(0x14)
+#define DMCU_MAP_VALID			(1u << 0)
+#define DMCU_CMD_CSSEL_CS0		(1u << 24)
+#define DMCU_CMD_CSSEL_CS1		(1u << 25)
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_MAP_CS2			(0x18)
+#define DMCU_MAP_CS3			(0x1c)
+#endif
+
+#define DMCU_SDRAM_CFG0_TYPE1		(0x20)
+#define DMCU_SDRAM_CFG1_TYPE1		(0x24)
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_SDRAM_CFG2_TYPE1		(0x28)
+#define DMCU_SDRAM_CFG3_TYPE1		(0x2c)
+#endif
+
+#define DMCU_SDRAM_CFG0_TYPE2		(0x30)
+#define DMCU_SDRAM_CFG1_TYPE2		(0x34)
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_SDRAM_CFG2_TYPE2		(0x38)
+#define DMCU_SDRAM_CFG3_TYPE2		(0x3c)
+#endif
+
+#define DMCU_SDRAM_CTRL1		(0x50)
+#define DMCU_SDRAM_CTRL2		(0x54)
+#define DMCU_SDRAM_CTRL4		(0x58)
+#define DMCU_SDRAM_TYPE_MASK		(7u << 2)
+#define DMCU_SDRAM_TYPE_DDR3		(2u << 2)
+#define DMCU_SDRAM_TYPE_LPDDR2		(5u << 2)
+#define DMCU_SDRAM_CTRL4_CL_SHIFT	(13)
+#define DMCU_SDRAM_CTRL4_CL_MASK	(0xf << DMCU_SDRAM_CTRL4_CL_SHIFT)
+#define DMCU_SDRAM_CTRL6		(0x5c)
+#define DMCU_SDRAM_CTRL7		(0x60)
+#define DMCU_SDRAM_CTRL13		(0x64)
+#define DMCU_SDRAM_CTRL14		(0x68)
+#define DMCU_SDRAM_TIMING1		(0x80)
+#define DMCU_SDRAM_TIMING2		(0x84)
+#define DMCU_SDRAM_TIMING3		(0x88)
+#define DMCU_SDRAM_TIMING4		(0x8c)
+#define DMCU_SDRAM_TIMING5		(0x90)
+#define DMCU_SDRAM_TIMING6		(0x94)
+#define DMCU_SDRAM_TIMING7		(0x98)
+#define DMCU_SDRAM_TIMING8		(0x9c)
+#define DMCU_EXCLUSIVE_MONITOR_CTRL	(0x100)
+#define DMCU_DATA_COH_CTRL		(0x110)
+#define DMCU_TRUSTZONE_SEL		(0x120)
+#define DMCU_TRUSTZONE_RANGE0		(0x124)
+#define DMCU_TRUSTZONE_RANGE1		(0x128)
+#define DMCU_TRUSTZONE_PERMISSION	(0x12C)
+#define DMCU_PORT_PRIORITY		(0x140)
+#define DMCU_BQ_STARV_PREVENTION	(0x144)
+#define DMCU_RRB_STARV_PREVENTION0	(0x148)
+#define DMCU_RRB_STARV_PREVENTION1	(0x14C)
+#define DMCU_SRAM_CTRL1			(0x150)
+#define DMCU_SRAM_CTRL2			(0x154)
+#define DMCU_SRAM_CTRL3			(0x158)
+#define DMCU_USER_COMMAND0		(0x160)
+#define DMCU_USER_COMMAND1		(0x164)
+#define DMCU_MODE_RD_DATA		(0x170)
+
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_SMR1			(0x180)
+#define DMCU_SMR2			(0x184)
+#endif
+
+#define DMCU_PHY_CTRL3			(0x220)
+#define DMCU_PHY_CTRL7			(0x230)
+#define DMCU_PHY_CTRL8			(0x234)
+#define DMCU_PHY_CTRL9			(0x238)
+#define DMCU_PHY_CTRL10			(0x23c)
+#define DMCU_PHY_CTRL11			(0x240)
+
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_PHY_CTRL12			(0x244)
+#endif
+
+#define DMCU_PHY_CTRL13			(0x248)
+#define DMCU_PHY_CTRL14			(0x24c)
+#define DMCU_PHY_CTRL15			(0x250)
+#define DMCU_PHY_CTRL16			(0x254)
+#define DMCU_PHY_CTRL21			(0x258)
+#define DMCU_PHY_CTRL19			(0x280)
+#define DMCU_PHY_CTRL20			(0x284)
+#define DMCU_PHY_CTRL22			(0x288)
+#define DMCU_PHY_DQ_BYTE_SEL		(0x300)
+#define DMCU_PHY_DLL_CTRL_BYTE1		(0x304)
+#define DMCU_PHY_DLL_WL_SEL		(0x380)
+#define DMCU_PHY_DLL_WL_CTRL0		(0x384)
+#define DMCU_PHY_DLL_WL_CTRL1		(0x388)
+#define DMCU_PHY_DLL_WL_CTRL2		(0x38C)
+#define DMCU_PHY_DLL_RL_CTRL		(0x390)
+
+#ifdef CONFIG_CPU_PXA988
+#define DMCU_PHY_CTRL_TESTMODE		(0x400)
+#endif
+
+#define DMCU_TEST_MODE0			(0x410)
+#define DMCU_TEST_MODE1			(0x414)
+#define DMCU_PERF_CNT_CTRL0		(0x440)
+#define DMCU_PERF_CNT_STATUS		(0x444)
+#define DMCU_PERF_CNT_SEL		(0x448)
+#define DMCU_PERF_CNT0			(0x450)
+#define DMCU_PERF_CNT1			(0x454)
+#define DMCU_PERF_CNT2			(0x458)
+#define DMCU_PERF_CNT3			(0x45c)
+
+#endif /* __ASM_MACH_MCU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-mpmu.h b/arch/arm/mach-mmp/include/mach/regs-mpmu.h
new file mode 100644
index 0000000..43f60fc
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-mpmu.h
@@ -0,0 +1,72 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-mpmu.h
+ *
+ *   Main Power Management Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_MPMU_H
+#define __ASM_MACH_REGS_MPMU_H
+
+#include <mach/addr-map.h>
+
+#define MPMU_VIRT_BASE	(APB_VIRT_BASE + 0x50000)
+#define MPMU_REG(off)	(MPMU_VIRT_BASE + (off))
+
+#define MPMU_CPCR	MPMU_REG(0x0000)
+#define MPMU_CPSR	MPMU_REG(0x0004)
+#define MPMU_FCCR	MPMU_REG(0x0008)
+#define MPMU_POCR	MPMU_REG(0x000c)
+#define MPMU_POSR	MPMU_REG(0x0010)
+#define MPMU_SUCCR	MPMU_REG(0x0014)
+#define MPMU_VRCR	MPMU_REG(0x0018)
+#define MPMU_OHCR	MPMU_REG(0x001c)
+#define MPMU_CPRR	MPMU_REG(0x0020)
+#define MPMU_CCGR	MPMU_REG(0x0024)
+#define MPMU_GPCR	MPMU_REG(0x0030)
+#define MPMU_PLL2CR	MPMU_REG(0x0034)
+#define MPMU_PLL3CR	MPMU_REG(0x001c)
+#define MPMU_SCCR	MPMU_REG(0x0038)
+#define MPMU_ISCCRX0	MPMU_REG(0x0040)
+#define MPMU_ISCCRX1	MPMU_REG(0x0044)
+#define MPMU_CWUCRM	MPMU_REG(0x004c)
+#define MPMU_PLL1_REG1	MPMU_REG(0x0050)
+#define MPMU_PLL1_REG2	MPMU_REG(0x0054)
+#define MPMU_PLL1_SSC	MPMU_REG(0x0058)
+#define MPMU_PLL2_REG1	MPMU_REG(0x0060)
+#define MPMU_PLL2_REG2	MPMU_REG(0x0064)
+#define MPMU_PLL2_SSC	MPMU_REG(0x0068)
+#define MPMU_SD_ROT_WAKE_CLR	MPMU_REG(0x007c)
+#define MPMU_PLL2_CTRL1 MPMU_REG(0x0414)
+#define MPMU_PLL2_CTRL2 MPMU_REG(0x0418)
+
+#if defined(CONFIG_CPU_MMP3)
+#define MPMU_PLL1_CTRL  MPMU_REG(0x005c)    /* MMP3 PLL1 control reg */
+#else
+#define MPMU_PLL1_CTRL  MPMU_REG(0x0418)    /* MMP2 PLL1 control reg */
+#endif
+
+#define MPMU_TS		MPMU_REG(0x0080)
+#define MPMU_WDTPCR	MPMU_REG(0x0200)
+#define MPMU_APCR	MPMU_REG(0x1000)
+#define MPMU_APSR	MPMU_REG(0x1004)
+#define MPMU_APRR	MPMU_REG(0x1020)
+#define MPMU_ACGR	MPMU_REG(0x1024)
+#define MPMU_ARSR	MPMU_REG(0x1028)
+#define MPMU_AWUCRS	MPMU_REG(0x1048)
+#define MPMU_AWUCRM	MPMU_REG(0x104c)
+#define MPMU_HSI_CLK_RES_CTRL MPMU_REG(0x1050)
+
+/*MMP3 PLL3 registers*/
+#define PMUM_PLL3_CR	MPMU_REG(0x0050)
+#define PMUM_POSR2	MPMU_REG(0x0054)
+#define PMUM_PLL3_CTRL1	MPMU_REG(0x0058)
+#define PMUM_PLL3_CTRL2	MPMU_REG(0x0060)
+#define PMUM_PLL3_CTRL3	MPMU_REG(0x0064)
+
+#define PMUM_PLL_DIFF_CTRL	MPMU_REG(0x0068)
+
+#endif /* __ASM_MACH_REGS_APMU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-pmu.h b/arch/arm/mach-mmp/include/mach/regs-pmu.h
new file mode 100644
index 0000000..820d7c5
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-pmu.h
@@ -0,0 +1,22 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-pmu.h
+ *
+ *   Power Management Unit
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_PMU_H
+#define __ASM_MACH_REGS_PMU_H
+
+#include <mach/addr-map.h>
+
+#define PMUM_VIRT_BASE		(APB_VIRT_BASE + 0x50000)
+#define PMUM_REG(x)		(PMUM_VIRT_BASE + (x))
+
+#define PMUA_VIRT_BASE		(AXI_VIRT_BASE + 0x82800)
+#define PMUA_REG(x)		(PMUA_VIRT_BASE + (x))
+
+#endif	/* __ASM_MACH_REGS_PMU_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-rtc.h b/arch/arm/mach-mmp/include/mach/regs-rtc.h
index 5bff886..39790f9 100644
--- a/arch/arm/mach-mmp/include/mach/regs-rtc.h
+++ b/arch/arm/mach-mmp/include/mach/regs-rtc.h
@@ -1,23 +1,26 @@
 #ifndef __ASM_MACH_REGS_RTC_H
 #define __ASM_MACH_REGS_RTC_H
 
-#include <mach/addr-map.h>
-
-#define RTC_VIRT_BASE	(APB_VIRT_BASE + 0x10000)
-#define RTC_REG(x)	(*((volatile u32 __iomem *)(RTC_VIRT_BASE + (x))))
+#include <mach/hardware.h>
 
 /*
  * Real Time Clock
  */
+#define RTC_REG(offset)	(*((volatile u32 *)(rtc_base+(offset))))
 
-#define RCNR		RTC_REG(0x00)	/* RTC Count Register */
-#define RTAR		RTC_REG(0x04)	/* RTC Alarm Register */
-#define RTSR		RTC_REG(0x08)	/* RTC Status Register */
-#define RTTR		RTC_REG(0x0C)	/* RTC Timer Trim Register */
+#define RCNR		RTC_REG(0x00)  /* RTC Count Register */
+#define RTAR		RTC_REG(0x04)  /* RTC Alarm Register */
+#define RTSR		RTC_REG(0x08)  /* RTC Status Register */
+#define RTTR		RTC_REG(0x0c)  /* RTC Timer Trim Register */
+#define PIAR		RTC_REG(0x38)  /* Periodic Interrupt Alarm Register */
 
+#define RTSR_PICE	(1 << 15)	/* Periodic interrupt count enable */
+#define RTSR_PIALE	(1 << 14)	/* Periodic interrupt Alarm enable */
 #define RTSR_HZE	(1 << 3)	/* HZ interrupt enable */
 #define RTSR_ALE	(1 << 2)	/* RTC alarm interrupt enable */
 #define RTSR_HZ		(1 << 1)	/* HZ rising-edge detected */
 #define RTSR_AL		(1 << 0)	/* RTC alarm detected */
 
+extern void __iomem *rtc_base;
+
 #endif /* __ASM_MACH_REGS_RTC_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-sspa.h b/arch/arm/mach-mmp/include/mach/regs-sspa.h
new file mode 100644
index 0000000..528ebde
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-sspa.h
@@ -0,0 +1,131 @@
+#ifndef __ASM_ARCH_REGS_SSPA_H
+#define __ASM_ARCH_REGS_SSPA_H
+
+#include <mach/mmp_audisland.h>
+
+#define SSPA1_VIRT_BASE			(AUD_VIRT_BASE + 0xc00)
+#define SSPA2_VIRT_BASE			(AUD_VIRT_BASE + 0xd00)
+#define DSA_SSP_CLK_RES_CTRL		(AUD_VIRT_BASE2 + 0x30)
+#define DSA_ABU_CLK_RES_CTRL		(AUD_VIRT_BASE2 + 0x34)
+#define DSP_AUDIO_CONFIG_REG		(AUD_VIRT_BASE2 + 0x00)
+#define DSA_CORE_CLK_RES_CTRL		(AUD_VIRT_BASE2 + 0x28)
+
+#define SSPA1_REG(x)		(SSPA1_VIRT_BASE + (x))
+#define SSPA2_REG(x)		(SSPA2_VIRT_BASE + (x))
+#define DSP_AUDIO_REG(x)	(DSP_AUDIO_CONFIG_REG + (x))
+
+#define SSPA_AUD_CTRL		SSPA1_REG(0x34)
+#define SSPA_AUD_PLL_CTRL0	SSPA1_REG(0x38)
+#define SSPA_AUD_PLL_CTRL1	SSPA1_REG(0x3c)
+#define DSP_AUDIO_AUX_CORE	DSP_AUDIO_REG(0x18)
+
+/*
+ * PXA688 SSPA Serial Port Registers
+ */
+
+#define SSPA_RXD		(0x00)
+#define SSPA_RXID		(0x04)
+#define SSPA_RXCTL		(0x08)
+#define SSPA_RXSP		(0x0c)
+#define SSPA_RXFIFO_UL		(0x10)
+#define SSPA_RXINT_MASK		(0x14)
+#define SSPA_RXC		(0x18)
+#define SSPA_RXFIFO_NOFS	(0x1c)
+#define SSPA_RXFIFO_SIZE	(0x20)
+
+#define SSPA_TXD		(0x80)
+#define SSPA_TXID		(0x84)
+#define SSPA_TXCTL		(0x88)
+#define SSPA_TXSP		(0x8c)
+#define SSPA_TXFIFO_LL		(0x90)
+#define SSPA_TXINT_MASK		(0x94)
+#define SSPA_TXC		(0x98)
+#define SSPA_TXFIFO_NOFS	(0x9c)
+#define SSPA_TXFIFO_SIZE	(0xa0)
+
+/* SSPA Control Register */
+#define	SSPA_CTL_XPH		(1 << 31)	/* Read Phase */
+#define	SSPA_CTL_XFIG		(1 << 15)	/* Transmit Zeros when FIFO Empty */
+#define	SSPA_CTL_JST		(1 << 3)	/* Audio Sample Justification */
+#define	SSPA_CTL_XFRLEN2_MASK	(7 << 24)
+#define	SSPA_CTL_XFRLEN2(x)	((x) << 24)	/* Transmit Frame Length in Phase 2 */
+#define	SSPA_CTL_XWDLEN2_MASK	(7 << 21)
+#define	SSPA_CTL_XWDLEN2(x)	((x) << 21)	/* Transmit Word Length in Phase 2 */
+#define	SSPA_CTL_XDATDLY(x)	((x) << 19)	/* Tansmit Data Delay */
+#define	SSPA_CTL_XSSZ2_MASK	(7 << 16)
+#define	SSPA_CTL_XSSZ2(x)	((x) << 16)	/* Transmit Sample Audio Size */
+#define	SSPA_CTL_XFRLEN1_MASK	(7 << 8)
+#define	SSPA_CTL_XFRLEN1(x)	((x) << 8)	/* Transmit Frame Length in Phase 1 */
+#define	SSPA_CTL_XWDLEN1_MASK	(7 << 5)
+#define	SSPA_CTL_XWDLEN1(x)	((x) << 5)	/* Transmit Word Length in Phase 1 */
+#define	SSPA_CTL_XSSZ1_MASK	(7 << 0)
+#define	SSPA_CTL_XSSZ1(x)	((x) << 0)	/* XSSZ1 */
+
+#define SSPA_CTL_8_BITS		(0x0)		/* sample size */
+#define SSPA_CTL_12_BITS	(0x1)
+#define SSPA_CTL_16_BITS	(0x2)
+#define SSPA_CTL_20_BITS	(0x3)
+#define SSPA_CTL_24_BITS	(0x4)
+#define SSPA_CTL_32_BITS	(0x5)
+
+/* SSPA Serial Port Register */
+#define	SSPA_SP_WEN		(1 << 31)	/* Write Configuration Enable */
+#define	SSPA_SP_MSL		(1 << 18)	/* Master Slave Configuration */
+#define	SSPA_SP_CLKP		(1 << 17)	/* CLKP Polarity Clock Edge Select */
+#define	SSPA_SP_FSP		(1 << 16)	/* FSP Polarity Clock Edge Select */
+#define	SSPA_SP_FFLUSH		(1 << 2)	/* FIFO Flush */
+#define	SSPA_SP_S_RST		(1 << 1)	/* Active High Reset Signal */
+#define	SSPA_SP_S_EN		(1 << 0)	/* Serial Clock Domain Enable */
+#define	SSPA_SP_FWID_MASK	(0xff << 20)
+#define	SSPA_SP_FWID(x)		((x) << 20)	/* Frame-Sync Width */
+#define	SSPA_SP_FPER_MASK	(0xfff << 4)
+#define	SSPA_SP_FPER(x)		((x) << 4)	/* Frame-Sync Active */
+
+/* SSPA Audio Control Register */
+#define SSPA_AUD_CTRL_S2_CLK_SEL_MASK		(1 << 23)
+#define SSPA_AUD_CTRL_S2_CLK_SEL_I2S		(1 << 23)
+#define SSPA_AUD_CTRL_S2_CLK_SEL_AUDIO_PLL	(0 << 23)
+#define SSPA_AUD_CTRL_S2_CLK_DIV_MASK		(0x3f << 17)
+#define SSPA_AUD_CTRL_S2_CLK_DIV(x)		((x) << 17)
+#define SSPA_AUD_CTRL_S2_ENA			(1 << 16)
+#define SSPA_AUD_CTRL_S1_CLK_DIV_MASK		(0x3f << 9)
+#define SSPA_AUD_CTRL_S1_CLK_DIV(x)		((x) << 9)
+#define SSPA_AUD_CTRL_S1_ENA			(1 << 8)
+#define SSPA_AUD_CTRL_S1_CLK_SEL_MASK		(1 << 7)
+#define SSPA_AUD_CTRL_S1_CLK_SEL_I2S		(1 << 7)
+#define SSPA_AUD_CTRL_S1_CLK_SEL_AUDIO_PLL	(0 << 7)
+#define SSPA_AUD_CTRL_SYSCLK_DIV_MASK		(0x3f << 1)
+#define SSPA_AUD_CTRL_SYSCLK_DIV(x)		((x) << 1)
+#define SSPA_AUD_CTRL_SYSCLK_ENA		(1 << 0)
+
+/* SSPA Audio PLL Control 0 Register */
+#define SSPA_AUD_PLL_CTRL0_DIV_MCLK1(x) 	((x) << 31)
+#define SSPA_AUD_PLL_CTRL0_DIV_OCLK_MODULO(x)	((x) << 28)
+#define SSPA_AUD_PLL_CTRL0_FRACT(x)		((x) << 8)
+#define SSPA_AUD_PLL_CTRL0_ENA_DITHER		(1 << 7)
+#define SSPA_AUD_PLL_CTRL0_ICP_2UA		(0 << 5)
+#define SSPA_AUD_PLL_CTRL0_ICP_5UA		(1 << 5)
+#define SSPA_AUD_PLL_CTRL0_ICP_7UA		(2 << 5)
+#define SSPA_AUD_PLL_CTRL0_ICP_10UA		(3 << 5)
+#define SSPA_AUD_PLL_CTRL0_DIV_FBCCLK(x)	((x) << 3)
+#define SSPA_AUD_PLL_CTRL0_DIV_MCLK(x)		((x) << 2)
+#define SSPA_AUD_PLL_CTRL0_PD_OVPROT_DIS	(1 << 1)
+#define SSPA_AUD_PLL_CTRL0_PU			(1 << 0)
+
+/* SSPA Audio PLL Control 1 Register */
+#define SSPA_AUD_PLL_CTRL1_EN_VCOX2_MMP3	(1 << 31)
+#define SSPA_AUD_PLL_CTRL1_DIV_MCLK_MSB2(x)	((x) << 29)
+#define SSPA_AUD_PLL_CTRL1_DIV_FBCCLK_MSB(x)	((x) << 25)
+#define SSPA_AUD_PLL_CTRL1_SEL_FAST_CLK 	(1 << 24)
+/* this bit is only for MMP2, MMP3 use EN_VCXO2_MMP3 */
+#define SSPA_AUD_PLL_CTRL1_EN_VCOX2		(1 << 17)
+#define SSPA_AUD_PLL_CTRL1_PLL_LOCK		(1 << 16)
+#define SSPA_AUD_PLL_CTRL1_CLK_SEL_AUDIO_PLL	(1 << 11)
+#define SSPA_AUD_PLL_CTRL1_CLK_SEL_VCXO		(0 << 11)
+#define SSPA_AUD_PLL_CTRL1_DIV_OCLK_PATTERN(x)	((x) << 0)
+
+/* SSPA and sysclk pll sources */
+#define SSPA_AUDIO_PLL				0
+#define SSPA_I2S_PLL				1
+#define SSPA_VCXO_PLL				2
+#endif /* __ASM_ARCH_REGS_SSPA_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-timers.h b/arch/arm/mach-mmp/include/mach/regs-timers.h
index 45589fe..d86ff23 100644
--- a/arch/arm/mach-mmp/include/mach/regs-timers.h
+++ b/arch/arm/mach-mmp/include/mach/regs-timers.h
@@ -15,6 +15,7 @@
 
 #define TIMERS1_VIRT_BASE	(APB_VIRT_BASE + 0x14000)
 #define TIMERS2_VIRT_BASE	(APB_VIRT_BASE + 0x16000)
+#define CP_TIMERS2_VIRT_BASE    (APB_VIRT_BASE + 0x80000)
 
 #define TMR_CCR		(0x0000)
 #define TMR_TN_MM(n, m)	(0x0004 + ((n) << 3) + (((n) + (m)) << 2))
diff --git a/arch/arm/mach-mmp/include/mach/regs-usb.h b/arch/arm/mach-mmp/include/mach/regs-usb.h
new file mode 100644
index 0000000..84c0fe3
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-usb.h
@@ -0,0 +1,415 @@
+/*
+ * Copyright (C) 2011 Marvell International Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __ASM_ARCH_REGS_USB_H
+#define __ASM_ARCH_REGS_USB_H
+
+#ifdef CONFIG_CPU_PXA988
+/* USB DEVICE REGISTER BASE ADDRESS */
+#define PXA988_UDC_REGBASE		(0xd4208000)
+#define PXA988_UDC_CAPREGS_RANGE	(0x100)
+#define PXA988_UDC_REG_RANGE		(0x1ff)
+
+/* USB PHY REGISTER BASE ADDRESS */
+#define PXA988_UDC_PHYBASE	(0xd4207000)
+#define PXA988_UDC_PHY_RANGE	(0xff)
+
+/*
+ * PXA988 USB DEVICE PHY(UTMI) Registers
+ */
+struct pxa988_usb_phy {
+	u16 utmi_id;		/* 0x00 */
+	u16 pad0;
+	u16 utmi_pll_reg0;	/* 0x04 */
+#define PLLVDD18(x)		((x & 0x3) << 14)
+#define REFDIV(x)		((x & 0x1f) << 9)
+#define FBDIV(x)		(x & 0x1ff)
+	u16 pad1;
+	u16 utmi_pll_reg1;	/* 0x08 */
+#define PLL_READY		(0x1 << 15)
+#define PLL_CONTROL_BY_PIN	(0x1 << 14)
+#define PU_PLL			(0x1 << 13)
+#define PLL_LOCK_BYPASS		(0x1 << 12)
+#define DLL_RESET_BLK		(0x1 << 11)
+#define ICP(x)			((x & 0x7) << 8)
+#define KVCO_EXT		(0x1 << 7)
+#define KVCO(x)			((x & 0x7) << 4)
+#define CLK_BLK_EN		(0x1 << 3)
+#define VCOCAL_START		(0x1 << 2)
+#define PLLCAL12(x)		(x & 0x3)
+	u16 pad2;
+	u32 rsvd0;		/* 0x0c */
+	u16 utmi_tx_reg0;	/* 0x10 */
+#define TXDATA_BLK_EN		(0x1 << 14)
+#define RCAL_START		(0x1 << 13)
+#define EXT_HS_RCAL_EN		(0x1 << 12)
+#define EXT_FS_RCAL_EN		(0x1 << 11)
+#define IMPCAL_VTH(x)		((x & 0x7) << 8)
+#define EXT_HS_RCAL(x)		((x & 0xf) << 4)
+#define EXT_FS_RCAL(x)		(x & 0xf)
+	u16 pad3;
+	u16 utmi_tx_reg1;	/* 0x14 */
+#define TXVDD15(x)		((x & 0x3) << 10)
+#define TXVDD12(x)		((x & 0x3) << 8)
+#define LOWVDD_EN		(0x1 << 7)
+#define AMP(x)			((x & 0x7) << 4)
+#define CK60_PHSEL(x)		(x & 0xf)
+	u16 pad4;
+	u16 utmi_tx_reg2;	/* 0x18 */
+#define DRV_SLEWRATE(x)		((x & 0x3) << 10)
+#define IMP_CAL_DLY(x)		((x & 0x3) << 8)
+#define FSDRV_EN(x)		((x & 0xf) << 4)
+#define HSDEV_EN(x)		(x & 0xf)
+	u16 pad5;
+	u32 rsvd1;		/* 0x1c */
+	u16 utmi_rx_reg0;	/* 0x20 */
+#define PHASE_FREEZE_DLY	(0x1 << 15)
+#define USQ_LENGTH		(0x1 << 14)
+#define ACQ_LENGTH(x)		((x & 0x3) << 12)
+#define SQ_LENGTH(x)		((x & 0x3) << 10)
+#define DISCON_THRESH(x)	((x & 0x3) << 8)
+#define SQ_THRESH(x)		((x & 0xf) << 4)
+#define LPF_COEF(x)		((x & 0x3) << 2)
+#define INTPI(x)		(x & 0x3)
+	u16 pad6;
+	u16 utmi_rx_reg1;	/* 0x24 */
+#define EARLY_VOS_ON_EN		(0x1 << 13)
+#define RXDATA_BLOCK_EN		(0x1 << 12)
+#define EDGE_DET_EN		(0x1 << 11)
+#define CAP_SEL(x)		((x & 0x7) << 8)
+#define RXDATA_BLOCK_LENGTH(x)	((x & 0x3) << 6)
+#define EDGE_DET_SEL(x)		((x & 0x3) << 4)
+#define CDR_COEF_SEL		(0x1 << 3)
+#define CDR_FASTLOCK_EN		(0x1 << 2)
+#define S2TO3_DLY_SEL(x)	(x & 0x3)
+	u16 pad7;
+	u16 utmi_rx_reg2;	/* 0x28 */
+#define USQ_FILTER		(0x1 << 8)
+#define SQ_CM_SEL		(0x1 << 7)
+#define SAMPLER_CTRL		(0x1 << 6)
+#define SQ_BUFFER_EN		(0x1 << 5)
+#define SQ_ALWAYS_ON		(0x1 << 4)
+#define RXVDD18(x)		((x & 0x3) << 2)
+#define RXVDD12(x)		(x & 0x3)
+	u16 pad8;
+	u32 rsvd2;		/* 0x2c */
+	u16 utmi_ana_reg0;	/* 0x30 */
+#define BG_VSEL(x)		((x & 0x3) << 8)
+#define DIG_SEL(x)		((x & 0x3) << 6)
+#define TOPVDD18(x)		((x & 0x3) << 4)
+#define VDD_USB2_DIG_TOP_SEL	(0x1 << 3)
+#define IPTAT_SEL(x)		(x & 0x7)
+	u16 pad9;
+	u16 utmi_ana_reg1;	/* 0x34 */
+#define PU_ANA			(0x1 << 14)
+#define ANA_CONTROL_BY_PIN	(0x1 << 13)
+#define SEL_LPFR		(0x1 << 12)
+#define V2I_EXT			(0x1 << 11)
+#define V2I(x)			((x & 0x7) << 8)
+#define R_ROTATE_SEL		(0x1 << 7)
+#define STRESS_TEST_MODE	(0x1 << 6)
+#define TESTMON_ANA(x)		(x & 0x3f)
+	u16 pad10;
+	u32 rsvd3;		/* 0x38 */
+	u16 utmi_dig_reg0;	/* 0x3c */
+#define FIFO_UF			(0x1 << 15)
+#define FIFO_OV			(0x1 << 14)
+#define FS_EOP_MODE		(0x1 << 13)
+#define HOST_DISCON_SEL1	(0x1 << 12)
+#define HOST_DISCON_SEL0	(0x1 << 11)
+#define FORCE_END_EN		(0x1 << 10)
+#define EARLY_TX_EN		(0x1 << 9)
+#define SYNCDET_WINDOW_EN	(0x1 << 8)
+#define CLK_SUSPEND_EN		(0x1 << 7)
+#define HS_DRIBBLE_EN		(0x1 << 6)
+#define SYNC_NUM(x)		((x & 0x3) << 4)
+#define FIFO_FILL_NUM(x)	(x & 0xf)
+	u16 pad11;
+	u16 utmi_dig_reg1;	/* 0x40 */
+#define FS_RX_ERROR_MODE2	(0x1 << 15)
+#define FS_RX_ERROR_MODE1	(0x1 << 14)
+#define FS_RX_ERROR_MODE	(0x1 << 13)
+#define CLK_OUT_SEL		(0x1 << 12)
+#define EXT_TX_CLK_SEL		(0x1 << 11)
+#define ARC_DPDM_MODE		(0x1 << 10)
+#define DP_PULLDOWN		(0x1 << 9)
+#define DM_PULLDOWN		(0x1 << 8)
+#define SYNC_IGNORE_SQ		(0x1 << 7)
+#define SQ_RST_RX		(0x1 << 6)
+#define MON_SEL(x)		(x & 0x3f)
+	u16 pad12;
+	u16 utmi_dig_reg2;	/* 0x44 */
+#define PAD_STRENGTH(x)		((x & 0x1f) << 8)
+#define LONG_EOP		(0x1 << 5)
+#define NOVBUS_DPDM00		(0x1 << 4)
+#define ALIGN_FS_OUTEN		(0x1 << 2)
+#define HS_HDL_SYNC		(0x1 << 1)
+#define FS_HDL_OPMD		(0x1 << 0)
+	u16 pad13;
+	u32 rsvd4;		/* 0x48 */
+	u16 utmi_test_reg0;	/* 0x4c */
+	u16 pad14;
+	u16 utmi_test_reg1;	/* 0x50 */
+	u16 pad15;
+	u32 rsvd5;		/* 0x54 */
+	u16 utmi_charger_reg0;	/* 0x58 */
+#define ENABLE_SWITCH		(0x1 << 3)
+#define PU_CHRG_DTC		(0x1 << 2)
+#define TESTMON_CHRGDTC(x)	(x & 0x3)
+	u16 pad16;
+	u16 utmi_otg_reg;	/* 0x5c */
+	u16 pad17;
+	u16 utmi_phy_mon0;	/* 0x60 */
+	u16 pad18;
+	u16 utmi_reserve_reg0;	/* 0x64 */
+	u16 pad19;
+};
+#else /* CONFIG_CPU_PXA988 */
+
+#define PXA168_U2O_REGBASE	(0xd4208000)
+#define PXA168_U2O_PHYBASE	(0xd4207000)
+
+#define PXA168_U2H_REGBASE      (0xd4209000)
+#define PXA168_U2H_PHYBASE      (0xd4206000)
+
+#define MMP3_HSIC1_REGBASE	(0xf0001000)
+#define MMP3_HSIC1_PHYBASE	(0xf0001800)
+
+#define MMP3_HSIC2_REGBASE	(0xf0002000)
+#define MMP3_HSIC2_PHYBASE	(0xf0002800)
+
+#define MMP3_FSIC_REGBASE	(0xf0003000)
+#define MMP3_FSIC_PHYBASE	(0xf0003800)
+
+
+#define USB_REG_RANGE		(0x1ff)
+#define USB_PHY_RANGE		(0xff)
+
+/* registers */
+#define U2x_CAPREGS_OFFSET       0x100
+
+/* phy regs */
+#define UTMI_REVISION		0x0
+#define UTMI_CTRL		0x4
+#define UTMI_PLL		0x8
+#define UTMI_TX			0xc
+#define UTMI_RX			0x10
+#define UTMI_IVREF		0x14
+#define UTMI_T0			0x18
+#define UTMI_T1			0x1c
+#define UTMI_T2			0x20
+#define UTMI_T3			0x24
+#define UTMI_T4			0x28
+#define UTMI_T5			0x2c
+#define UTMI_RESERVE		0x30
+#define UTMI_USB_INT		0x34
+#define UTMI_DBG_CTL		0x38
+#define UTMI_OTG_ADDON		0x3c
+
+/* For UTMICTRL Register */
+#define UTMI_CTRL_USB_CLK_EN                    (1 << 31)
+/* pxa168 */
+#define UTMI_CTRL_SUSPEND_SET1                  (1 << 30)
+#define UTMI_CTRL_SUSPEND_SET2                  (1 << 29)
+#define UTMI_CTRL_RXBUF_PDWN                    (1 << 24)
+#define UTMI_CTRL_TXBUF_PDWN                    (1 << 11)
+
+#define UTMI_CTRL_INPKT_DELAY_SHIFT             30
+#define UTMI_CTRL_INPKT_DELAY_SOF_SHIFT		28
+#define UTMI_CTRL_PU_REF_SHIFT			20
+#define UTMI_CTRL_ARC_PULLDN_SHIFT              12
+#define UTMI_CTRL_PLL_PWR_UP_SHIFT              1
+#define UTMI_CTRL_PWR_UP_SHIFT                  0
+
+/* For UTMI_PLL Register */
+#define UTMI_PLL_PLLCALI12_SHIFT		29
+#define UTMI_PLL_PLLCALI12_MASK			(0x3 << 29)
+
+#define UTMI_PLL_PLLVDD18_SHIFT			27
+#define UTMI_PLL_PLLVDD18_MASK			(0x3 << 27)
+
+#define UTMI_PLL_PLLVDD12_SHIFT			25
+#define UTMI_PLL_PLLVDD12_MASK			(0x3 << 25)
+
+#define UTMI_PLL_CLK_BLK_EN_SHIFT               24
+#define CLK_BLK_EN                              (0x1 << 24)
+#define PLL_READY                               (0x1 << 23)
+#define KVCO_EXT                                (0x1 << 22)
+#define VCOCAL_START                            (0x1 << 21)
+
+#define UTMI_PLL_KVCO_SHIFT			15
+#define UTMI_PLL_KVCO_MASK                      (0x7 << 15)
+
+#define UTMI_PLL_ICP_SHIFT			12
+#define UTMI_PLL_ICP_MASK                       (0x7 << 12)
+
+#define UTMI_PLL_FBDIV_SHIFT                    4
+#define UTMI_PLL_FBDIV_MASK                     (0xFF << 4)
+
+#define UTMI_PLL_REFDIV_SHIFT                   0
+#define UTMI_PLL_REFDIV_MASK                    (0xF << 0)
+
+/* For UTMI_TX Register */
+#define UTMI_TX_REG_EXT_FS_RCAL_SHIFT		27
+#define UTMI_TX_REG_EXT_FS_RCAL_MASK		(0xf << 27)
+
+#define UTMI_TX_REG_EXT_FS_RCAL_EN_SHIFT	26
+#define UTMI_TX_REG_EXT_FS_RCAL_EN_MASK		(0x1 << 26)
+
+#define UTMI_TX_TXVDD12_SHIFT                   22
+#define UTMI_TX_TXVDD12_MASK                    (0x3 << 22)
+
+#define UTMI_TX_CK60_PHSEL_SHIFT                17
+#define UTMI_TX_CK60_PHSEL_MASK                 (0xf << 17)
+
+#define UTMI_TX_IMPCAL_VTH_SHIFT                14
+#define UTMI_TX_IMPCAL_VTH_MASK                 (0x7 << 14)
+
+#define REG_RCAL_START                          (0x1 << 12)
+
+#define UTMI_TX_LOW_VDD_EN_SHIFT                11
+
+#define UTMI_TX_AMP_SHIFT			0
+#define UTMI_TX_AMP_MASK			(0x7 << 0)
+
+/* For UTMI_RX Register */
+#define UTMI_REG_SQ_LENGTH_SHIFT                15
+#define UTMI_REG_SQ_LENGTH_MASK                 (0x3 << 15)
+
+#define UTMI_RX_SQ_THRESH_SHIFT                 4
+#define UTMI_RX_SQ_THRESH_MASK                  (0xf << 4)
+
+#define UTMI_OTG_ADDON_OTG_ON			(1 << 0)
+
+/* For MMP3 USB Phy */
+#define USB2_PLL_REG0		0x4
+#define USB2_PLL_REG1		0x8
+#define USB2_TX_REG0		0x10
+#define USB2_TX_REG1		0x14
+#define USB2_TX_REG2		0x18
+#define USB2_RX_REG0		0x20
+#define USB2_RX_REG1		0x24
+#define USB2_RX_REG2		0x28
+#define USB2_ANA_REG0		0x30
+#define USB2_ANA_REG1		0x34
+#define USB2_ANA_REG2		0x38
+#define USB2_DIG_REG0		0x3C
+#define USB2_DIG_REG1		0x40
+#define USB2_DIG_REG2		0x44
+#define USB2_DIG_REG3		0x48
+#define USB2_TEST_REG0		0x4C
+#define USB2_TEST_REG1		0x50
+#define USB2_TEST_REG2		0x54
+#define USB2_CHARGER_REG0	0x58
+#define USB2_OTG_REG0		0x5C
+#define USB2_PHY_MON0		0x60
+#define USB2_RESETVE_REG0	0x64
+#define USB2_ICID_REG0		0x78
+#define USB2_ICID_REG1		0x7C
+
+/* USB2_PLL_REG0 */
+/* This is for Ax stepping */
+#define USB2_PLL_FBDIV_SHIFT_MMP3		0
+#define USB2_PLL_FBDIV_MASK_MMP3		(0xFF << 0)
+
+#define USB2_PLL_REFDIV_SHIFT_MMP3		8
+#define USB2_PLL_REFDIV_MASK_MMP3		(0xF << 8)
+
+#define USB2_PLL_VDD12_SHIFT_MMP3		12
+#define USB2_PLL_VDD18_SHIFT_MMP3		14
+
+/* This is for B0 stepping */
+#define USB2_PLL_FBDIV_SHIFT_MMP3_B0		0
+#define USB2_PLL_REFDIV_SHIFT_MMP3_B0		9
+#define USB2_PLL_VDD18_SHIFT_MMP3_B0		14
+#define USB2_PLL_FBDIV_MASK_MMP3_B0		0x01FF
+#define USB2_PLL_REFDIV_MASK_MMP3_B0		0x3E00
+
+#define USB2_PLL_CAL12_SHIFT_MMP3		0
+#define USB2_PLL_CALI12_MASK_MMP3		(0x3 << 0)
+
+#define USB2_PLL_VCOCAL_START_SHIFT_MMP3	2
+
+#define USB2_PLL_KVCO_SHIFT_MMP3		4
+#define USB2_PLL_KVCO_MASK_MMP3			(0x7<<4)
+
+#define USB2_PLL_ICP_SHIFT_MMP3			8
+#define USB2_PLL_ICP_MASK_MMP3			(0x7<<8)
+
+#define USB2_PLL_LOCK_BYPASS_SHIFT_MMP3		12
+
+#define USB2_PLL_PU_PLL_SHIFT_MMP3		13
+#define USB2_PLL_PU_PLL_MASK			(0x1 << 13)
+
+#define USB2_PLL_READY_MASK_MMP3		(0x1 << 15)
+
+/* USB2_TX_REG0 */
+#define USB2_TX_IMPCAL_VTH_SHIFT_MMP3		8
+#define USB2_TX_IMPCAL_VTH_MASK_MMP3		(0x7 << 8)
+
+#define USB2_TX_RCAL_START_SHIFT_MMP3		13
+
+/* USB2_TX_REG1 */
+#define USB2_TX_CK60_PHSEL_SHIFT_MMP3		0
+#define USB2_TX_CK60_PHSEL_MASK_MMP3		(0xf << 0)
+
+#define USB2_TX_AMP_SHIFT_MMP3			4
+#define USB2_TX_AMP_MASK_MMP3			(0x7 << 4)
+
+#define USB2_TX_VDD12_SHIFT_MMP3		8
+#define USB2_TX_VDD12_MASK_MMP3			(0x3 << 8)
+
+/* USB2_TX_REG2 */
+#define USB2_TX_DRV_SLEWRATE_SHIFT		10
+
+/* USB2_RX_REG0 */
+#define USB2_RX_SQ_THRESH_SHIFT_MMP3		4
+#define USB2_RX_SQ_THRESH_MASK_MMP3		(0xf << 4)
+
+#define USB2_RX_SQ_LENGTH_SHIFT_MMP3		10
+#define USB2_RX_SQ_LENGTH_MASK_MMP3		(0x3 << 10)
+
+/* USB2_ANA_REG1*/
+#define USB2_ANA_PU_ANA_SHIFT_MMP3		14
+
+/* USB2_OTG_REG0 */
+#define USB2_OTG_PU_OTG_SHIFT_MMP3		3
+
+/* fsic registers */
+#define FSIC_MISC			0x4
+#define FSIC_INT			0x28
+#define FSIC_CTRL			0x30
+
+/* HSIC registers */
+#define HSIC_PAD_CTRL			0x4
+
+#define HSIC_CTRL			0x8
+#define HSIC_CTRL_HSIC_ENABLE		(1<<7)
+#define HSIC_CTRL_PLL_BYPASS		(1<<4)
+
+#define TEST_GRP_0			0xc
+#define TEST_GRP_1			0x10
+
+#define HSIC_INT			0x14
+#define HSIC_INT_READY_INT_EN		(1<<10)
+#define HSIC_INT_CONNECT_INT_EN		(1<<9)
+#define HSIC_INT_CORE_INT_EN		(1<<8)
+#define HSIC_INT_HS_READY		(1<<2)
+#define HSIC_INT_CONNECT		(1<<1)
+#define HSIC_INT_CORE			(1<<0)
+
+#define HSIC_CONFIG			0x18
+#define USBHSIC_CTRL			0x20
+
+#define HSIC_USB_CTRL			0x28
+#define HSIC_USB_CTRL_CLKEN		1
+#define	HSIC_USB_CLK_PHY		0x0
+#define HSIC_USB_CLK_PMU		0x1
+#endif /* CONFIG_CPU_PXA988 */
+#endif /* __ASM_ARCH_PXA_U2O_H */
diff --git a/arch/arm/mach-mmp/include/mach/regs-zsp.h b/arch/arm/mach-mmp/include/mach/regs-zsp.h
new file mode 100644
index 0000000..59f00f1
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/regs-zsp.h
@@ -0,0 +1,156 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/regs-zsp.h
+ *
+ *  Audio Accelerator Processor Registers
+ *  jgjing@marvell.com
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_REGS_ZSP_H
+#define __ASM_MACH_REGS_ZSP_H
+
+#include <mach/mmp_audisland.h>
+
+#if defined(CONFIG_CPU_MMP2)
+#define ZSP_VIRT_BASE		(AXI_VIRT_BASE + 0xA1000)
+#elif defined(CONFIG_CPU_MMP3)
+#define ZSP_VIRT_BASE		AUD_VIRT_BASE2
+#endif
+
+#define ZSP_REG(x)		(ZSP_VIRT_BASE + (x))
+
+#if defined(CONFIG_CPU_MMP2)
+#define ZSP_DTCM_START		0xc0000000
+#define ZSP_ITCM_START		0xc0040000
+#define ZSP_DATA_OFFSET		0x00020000
+
+
+#define	ZSP_CONFIG_SVTADDR	ZSP_REG(0x0000)
+#define	ZSP_CONFIG_DBG		ZSP_REG(0x0004)
+#define	ZSP_CONFIG_MEMPARAM	ZSP_REG(0x0008)
+#define	ZSP_CONFIG_REG0		ZSP_REG(0x000c)
+#define	ZSP_CONFIG_REG1		ZSP_REG(0x0010)
+#define	ZSP_CONFIG_REG2		ZSP_REG(0x0014)
+
+#define	ZSP_CONFIG_REG2_REG6	ZSP_REG(0x0018)
+
+#define	ZSP_INT_MASK0		ZSP_REG(0x0028)
+#define	ZSP_INT_MASK1		ZSP_REG(0x002c)
+#define	ZSP_STATUS_REG0		ZSP_REG(0x0200)
+#define	ZSP_STATUS_REG1		ZSP_REG(0x0204)
+#define	ZSP_STATUS_REG2		ZSP_REG(0x0208)
+#define	ZSP_INT_STATUS0		ZSP_REG(0x020c)
+#define	ZSP_INT_STATUS1		ZSP_REG(0x0210)
+
+/*
+ *	THE BIT DEFINES
+ */
+/* zsp boot vector */
+#define	ZSP_AUD_CTRL_REG_2_ZSP_SVTADDR_MSK		(0xffffff << 8)
+#define	ZSP_AUD_CTRL_REG_2_ZSP_SVTADDR_BASE		8
+/* ZSP halt */
+#define	ZSP_CONFIG_DBG_Z_HALT				(1 << 4)
+/* ZSP external breakpoint */
+#define	ZSP_CONFIG_DBG_ZEXT_BP_MSK			0xf
+#define	ZSP_CONFIG_DBG_ZEXT_BP_BASE			0
+
+/* RTC for imem/dmem */
+#define	ZSP_CONFIG_MEMPARAM_RTC_MSK		(0x3 << 2)
+#define	ZSP_CONFIG_MEMPARAM_RTC_BASE		2
+/* WTC for imem/dmem */
+#define	ZSP_CONFIG_MEMPARAM_WTC_MSK		0x3
+#define	ZSP_CONFIG_MEMPARAM_WTC_BASE		0
+
+/* ZSP DDR OK to SLEEP */
+#define	ZSP_CONFIG_REG0_ZSP_DDR_OK_TO_SLEEP 	(1 << 12)
+/* ZSP SRAM powerdown enable */
+#define	ZSP_CONFIG_REG0_ZSP_SRAM_PWRDWN_EN_I 	(1 << 11)
+/* ZSP powerdown enable */
+#define	ZSP_CONFIG_REG0_ZSP_PWRDWN_EN_I 	(1 << 10)
+/* divider reset enable */
+#define	ZSP_CONFIG_REG0_DIVIDER_RESET_EN	(1 << 9)
+/* Clock gate control */
+#define	ZSP_CONFIG_REG0_CLK_GATE_CTRL		(0x3 << 7)
+#define	ZSP_CONFIG_REG0_CLK_GATE_CTRL_BASE		7
+/* Dynamic frequency change request */
+#define	ZSP_CONFIG_REG0_DYN_FC_REQ		(1 << 6)
+/* freqeuency change request */
+#define	ZSP_CONFIG_REG0_FC_REQ			(1 << 5)
+/* Clock devider select for core clk */
+#define	ZSP_CONFIG_REG0_CORE_PCLK_DIV_N		(0x7 << 2)
+#define	ZSP_CONFIG_REG0_CORE_PCLK_DIV_N_BASE	2
+/*Bit(s) ZSPCONFIG_REG0_RSRV_1 reserved */
+/* core pll clock select 0 */
+#define	ZSP_CONFIG_REG0_CORE_PLL_SEL0         	1
+
+/* Cam enable for Audio RAM */
+#define	ZSP_CONFIG_REG1_CAMENABLE_ARAM		(1 << 16)
+/* RTC for Audio RAM */
+#define	ZSP_CONFIG_REG1_RTC_ARAM_MSK		(0x3 << 10)
+#define	ZSP_CONFIG_REG1_RTC_ARAM_BASE		10
+/* WTC for Audio RAM */
+#define	ZSP_CONFIG_REG1_WTC_ARAM_MSK		(0x3 << 8)
+#define	ZSP_CONFIG_REG1_WTC_ARAM_BASE		8
+/* powerdown for Audio RAM */
+#define	ZSP_CONFIG_REG1_PDWN1_ARAM		(1 << 7)
+/* ROM RTC REF */
+#define	ZSP_CONFIG_REG1_ROM_RTC_REF_MSK		(0x3 << 5)
+#define	ZSP_CONFIG_REG1_ROM_RTC_REF_BASE	5
+/* ROM RTC */
+#define	ZSP_CONFIG_REG1_ROM_RTC_MSK		(0x3 << 3)
+#define	ZSP_CONFIG_REG1_ROM_RTC_BASE		3
+/* Power Down BROM */
+#define	ZSP_CONFIG_REG1_PDWN_BROM		(1 << 2)
+/* ROM Wait Cycle */
+#define	ZSP_CONFIG_REG1_ROM_WAIT_CYCLE_MSK	0x3
+#define	ZSP_CONFIG_REG1_ROM_WAIT_CYCLE_BASE	0
+/*ZSP_STATUS_REG0	0x0200	ZSP STATUS REG0 */
+/* PLL_SEL */
+#define	ZSP_STATUS_REG0_PLL_SEL			(1 << 3)
+/* PCLK divider */
+#define	ZSP_STATUS_REG0_PCLK_DIV_MSK		0x7
+#define	ZSP_STATUS_REG0_PCLK_DIV_BASE		0
+/*ZSP_STATUS_REG1	0x0204	ZSP STATUS REG1 */
+/*Bit(s) ZSP_STATUS_REG1_RSRV_31_0 reserved */
+
+/*ZSP_STATUS_REG2 0x0208 ZSP STATUS REG2 */
+/*Bit(s) ZSP_STATUS_REG2_RSRV_31_1 reserved */
+/* freq change done */
+#define	ZSP_STATUS_REG2_FC_DONE			1
+/*ZSP INT_STATUS0	0x020c	ZSP INT_STATUS0 */
+/*Bit(s) ZSPINT_STATUS0_RSRV_31_13 reserved */
+
+/*ZSP INT_STATUS1 0x0210 ZSP INT_STATUS1 */
+/*Bit(s) ZSPINT_STATUS1_RSRV_31_13 reserved */
+#elif defined(CONFIG_CPU_MMP3)
+#define	ZSP_AUD_CONFIG				ZSP_REG(0x0000)
+#define	ZSP_AUX_CORE_PRID			ZSP_REG(0x0004)
+#define	ZSP_AUX_CORE_INT_ST			ZSP_REG(0x0008)
+#define	ZSP_AUD_CORE_IPC			ZSP_REG(0x000C)
+#define	ZSP_APPS_CORE_IPC			ZSP_REG(0x0010)
+#define	ZSP_AUD_INT_MSK				ZSP_REG(0x0014)
+#define	ZSP_AUD_CORE_FREQ_CHG		ZSP_REG(0x0018)
+#define	ZSP_AUD_D1D0_WAKEUP_MSK		ZSP_REG(0x001C)
+#define	ZSP_AUD_D1D0G_WAKEUP_MSK	ZSP_REG(0x0020)
+#define	ZSP_AUD_D0CG2D1_ENTRY_MSK	ZSP_REG(0x0024)
+#define	ZSP_AUD_DSA_CORE_CLK_RES	ZSP_REG(0x0028)
+#define	ZSP_AUD_DSA_APB_CLK_RES		ZSP_REG(0x002C)
+#define	ZSP_AUD_SSP_CLK_RES			ZSP_REG(0x0030)
+#define	ZSP_AUD_TIM_13M_CLK_RES		ZSP_REG(0x003C)
+#define	ZSP_AUD_TIM_32K_CLK_RES		ZSP_REG(0x0040)
+#define	ZSP_AUD_SLIM_CLK_RES		ZSP_REG(0x0044)
+#define	ZSP_XCORE_ADDR_TRANS		ZSP_REG(0x0048)
+#define	ZSP_XCORE_ADDR_TRANS_CTRL	ZSP_REG(0x004C)
+#define	ZSP_AUD_SLIM_CLK_RES_2		ZSP_REG(0x0050)
+#define	ZSP_AUD_CTRL_REG			ZSP_REG(0x0054)
+#define	ZSP_AUD_CTRL_REG_2			ZSP_REG(0x0058)
+
+#define ZSP_DTCM_START		0xC6080000
+#define ZSP_DATA_OFFSET		0x00000000
+#endif
+
+#define ZSP_BADDR_TO_PA(x)	((x)+ZSP_DTCM_START-ZSP_DATA_OFFSET)
+
+#endif /* __ASM_MACH_REGS_ZSP_H */
diff --git a/arch/arm/mach-mmp/include/mach/smp.h b/arch/arm/mach-mmp/include/mach/smp.h
new file mode 100644
index 0000000..1494186
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/smp.h
@@ -0,0 +1,15 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+#include <linux/smp.h>
+#include <asm/hardware/gic.h>
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/soc_coda7542.h b/arch/arm/mach-mmp/include/mach/soc_coda7542.h
new file mode 100644
index 0000000..627637e
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/soc_coda7542.h
@@ -0,0 +1,10 @@
+#ifndef _SOC_CODA7542_H_
+#define _SOC_CODA7542_H_
+
+#include <linux/uio_coda7542.h>
+
+#define UIO_CODA7542_NAME		"pxa-coda7542"
+
+extern void __init pxa_register_coda7542(void);
+
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/soc_vmeta.h b/arch/arm/mach-mmp/include/mach/soc_vmeta.h
new file mode 100644
index 0000000..6f063c7
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/soc_vmeta.h
@@ -0,0 +1,47 @@
+#ifndef _SOC_VMETA_H_
+#define _SOC_VMETA_H_
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+
+#include <linux/uio_driver.h>
+#include <linux/vdec_os_api.h>
+#include <linux/uio_vmeta.h>
+#include <linux/vmeta.h>
+
+#if defined(CONFIG_PXA3xx_DVFM)
+#define VMETA_DVFM_ENABLE 1
+#else
+#define VMETA_DVFM_ENABLE 0
+#endif
+
+#if VMETA_DVFM_ENABLE
+#include <linux/notifier.h>
+#include <linux/timer.h>
+#include <mach/dvfm.h>
+#endif
+
+#define UIO_VMETA_NAME		"mmp-vmeta"
+#define UIO_VMETA_BUS_IRQ_NAME  UIO_VMETA_NAME"-bus"
+
+#define VMETA_PWR_ENABLE 0x1
+#define VMETA_PWR_DISABLE 0x0
+
+struct vmeta_plat_data {
+	irqreturn_t (*bus_irq_handler)(int irq, void *dev_id);
+	int axi_clk_available;
+	int power_down_ms;
+};
+
+irqreturn_t mmp_vmeta_bus_irq_handler(int irq, void *dev_id);
+void __init mmp_set_vmeta_info(void *info);
+void __init mmp_set_devfreq_vmeta_info(void *info);
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/sram.h b/arch/arm/mach-mmp/include/mach/sram.h
index 239e0fc..0fa4784 100644
--- a/arch/arm/mach-mmp/include/mach/sram.h
+++ b/arch/arm/mach-mmp/include/mach/sram.h
@@ -1,7 +1,7 @@
 /*
  *  linux/arch/arm/mach-mmp/include/mach/sram.h
  *
- *  SRAM Memory Management
+ *  PXA688 SRAM Memory Management
  *
  *  Copyright (c) 2011 Marvell Semiconductors Inc.
  *
@@ -11,25 +11,33 @@
  *
  */
 
-#ifndef __ASM_ARCH_SRAM_H
-#define __ASM_ARCH_SRAM_H
-
-#include <linux/genalloc.h>
+#ifndef __ARCH_SRAM_H
+#define __ARCH_SRAM_H
 
 /* ARBITRARY:  SRAM allocations are multiples of this 2^N size */
-#define SRAM_GRANULARITY	512
+#define AUDIO_SRAM_GRANULARITY	1024
+#define VIDEO_SRAM_GRANULARITY	64
 
-enum sram_type {
-	MMP_SRAM_UNDEFINED = 0,
-	MMP_ASRAM,
-	MMP_ISRAM,
-};
+/*
+ * SRAM allocations return a CPU virtual address, or NULL on error.
+ * If a DMA address is requested and the SRAM supports DMA, its
+ * mapped address is also returned.
+ *
+ * Errors include SRAM memory not being available, and requesting
+ * DMA mapped SRAM on systems which don't allow that.
+ */
 
-struct sram_platdata {
+struct sram_bank {
+	struct list_head sram_list;
+	u32 step;
+	u32 sram_phys;
+	u32 sram_size;
 	char *pool_name;
-	int granularity;
+	void __iomem *sram_virt;
+	struct gen_pool *pool;
 };
 
-extern struct gen_pool *sram_get_gpool(char *pool_name);
+extern void *sram_alloc(char *name, size_t len, dma_addr_t *dma);
+extern void sram_free(char *name, void *addr, size_t len);
 
-#endif /* __ASM_ARCH_SRAM_H */
+#endif /* __ARCH_SRAM_H */
diff --git a/arch/arm/mach-mmp/include/mach/system.h b/arch/arm/mach-mmp/include/mach/system.h
new file mode 100644
index 0000000..3f25710
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/system.h
@@ -0,0 +1,27 @@
+/*
+ * linux/arch/arm/mach-mmp/include/mach/system.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_MACH_SYSTEM_H
+#define __ASM_MACH_SYSTEM_H
+
+#include <mach/cputype.h>
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+extern void (*arch_reset)(char, const char *);
+extern int (*board_reset)(char mode, const char *cmd);
+
+/* hacked i2c routine */
+extern int __raw_i2c_bus_reset(u8 bus_num);
+extern int __raw_i2c_write_reg(u8 bus_num, u8 addr, u8 reg, u8 val);
+extern int __raw_i2c_read_reg(u8 bus_num, u8 addr, u8 reg, u8 *buf, int len);
+
+#endif /* __ASM_MACH_SYSTEM_H */
diff --git a/arch/arm/mach-mmp/include/mach/timex.h b/arch/arm/mach-mmp/include/mach/timex.h
index 70c9f1d..a154d26 100644
--- a/arch/arm/mach-mmp/include/mach/timex.h
+++ b/arch/arm/mach-mmp/include/mach/timex.h
@@ -6,8 +6,21 @@
  * published by the Free Software Foundation.
  */
 
-#ifdef CONFIG_CPU_MMP2
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
 #define CLOCK_TICK_RATE		6500000
 #else
 #define CLOCK_TICK_RATE		3250000
 #endif
+
+/*
+ * Since we need to delay 3 cycle of tickes to get the update of timer
+ * we get the calculated result based on the slowest freq here, 3250000
+ * This 3.25M timer's tick happen every 0.307us, and 3 times of this value
+ * should be still smaller than 1us, so delay 1us is enough for all
+ * fast timer here
+ */
+#if (CLOCK_TICK_RATE >= 3250000)
+#define DELAY_US		1
+#else
+#error "We current don't support this CLOCK_TICK_RATE!!!"
+#endif
diff --git a/arch/arm/mach-mmp/include/mach/uio_hdmi.h b/arch/arm/mach-mmp/include/mach/uio_hdmi.h
new file mode 100644
index 0000000..2e182fa
--- /dev/null
+++ b/arch/arm/mach-mmp/include/mach/uio_hdmi.h
@@ -0,0 +1,39 @@
+/******************************************************************************
+ *
+ * Name:        uio_hdmi.h
+ * Project:     MMP
+ * Yifan Zhang
+ *
+ * Copyright (c) 2011, Marvell International Ltd (zhangyf@marvell.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ *****************************************************************************/
+
+#ifndef __UIO_HDMI_H__
+#define __UIO_HDMI_H__
+
+#define SSPA1_GET_VALUE 0
+#define HPD_PIN_READ 6
+#define EDID_NUM 1
+
+enum connect_lock {
+	UNLOCK = 0,
+	FIRST_ACCESS_LOCK,
+	SECOND_ACCESS_LOCK,
+};
+
+struct uio_hdmi_platform_data {
+	u32 itlc_reg_base;
+	u32 sspa_reg_base;
+	u32 gpio;
+	u32 edid_bus_num;
+	int (*hdmi_v5p_power)(int on);
+	int hpd_val;
+};
+
+#endif
diff --git a/arch/arm/mach-mmp/irq-mmp3.c b/arch/arm/mach-mmp/irq-mmp3.c
new file mode 100644
index 0000000..fd1f3b3
--- /dev/null
+++ b/arch/arm/mach-mmp/irq-mmp3.c
@@ -0,0 +1,243 @@
+/*
+ *  linux/arch/arm/mach-mmp/irq-mmp2.c
+ *
+ *  Generic IRQ handling, GPIO IRQ demultiplexing, etc.
+ *
+ *  Author:	Haojian Zhuang <haojian.zhuang@marvell.com>
+ *  Copyright:	Marvell International Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/hardware/gic.h>
+#include <mach/regs-icu.h>
+#include <mach/irqs.h>
+#include <plat/mfp.h>
+
+#include "common.h"
+
+struct icu_mux_irq_chip_data {
+	void __iomem	*mask;
+	void __iomem	*status;
+	unsigned int	base;
+};
+
+static DEFINE_SPINLOCK(irq_lock);
+
+static void icu_mux_mask_irq(struct irq_data *d)
+{
+	struct icu_mux_irq_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	u32 r;
+	unsigned long flags;
+
+	if (!chip_data) {
+		printk(KERN_ERR "Can not find chip data for mux irq %d\n", d->irq);
+		return;
+	}
+	spin_lock_irqsave(&irq_lock, flags);
+	r = __raw_readl(chip_data->mask) | (1 << (d->irq - chip_data->base));
+	__raw_writel(r, chip_data->mask);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+static void icu_mux_unmask_irq(struct irq_data *d)
+{
+	struct icu_mux_irq_chip_data *chip_data = irq_data_get_irq_chip_data(d);
+	u32 r;
+	unsigned long flags;
+
+	if (!chip_data) {
+		printk(KERN_ERR "Can not find chip data for mux irq %d\n", d->irq);
+		return;
+	}
+	spin_lock_irqsave(&irq_lock, flags);
+	r = __raw_readl(chip_data->mask) & ~(1 << (d->irq - chip_data->base));
+	__raw_writel(r, chip_data->mask);
+	spin_unlock_irqrestore(&irq_lock, flags);
+}
+
+#define DEFINE_ICU_MUX_IRQ(_name_, irq_base, prefix)			\
+static struct icu_mux_irq_chip_data  _name_##_icu_chip_data = {	\
+	.mask		= (void __iomem *)prefix##_MASK,		\
+	.status		= (void __iomem *)prefix##_STATUS,		\
+	.base		= irq_base,					\
+};									\
+									\
+static void _name_##_irq_demux(unsigned int irq, struct irq_desc *desc)	\
+{									\
+	unsigned long status, mask, n;					\
+	struct irq_chip *chip = irq_get_chip(irq);			\
+									\
+	chained_irq_enter(chip, desc);					\
+	mask = __raw_readl(prefix##_MASK);				\
+	while (1) {							\
+		status = __raw_readl(prefix##_STATUS) & ~mask;		\
+		if (status == 0)					\
+			break;						\
+		n = find_first_bit(&status, BITS_PER_LONG);		\
+		while (n < BITS_PER_LONG) {				\
+			generic_handle_irq(irq_base + n);		\
+			n = find_next_bit(&status, BITS_PER_LONG, n+1);	\
+		}							\
+	}								\
+	chained_irq_exit(chip, desc);					\
+}									\
+
+static struct irq_chip icu_mux_irq_chip = {
+	.name		= "icu mux",
+	.irq_mask	= icu_mux_mask_irq,
+	.irq_unmask	= icu_mux_unmask_irq,
+	.irq_disable	= icu_mux_mask_irq,
+#if CONFIG_PM
+	.irq_set_wake	= mmp3_set_wake,
+#endif
+};
+
+DEFINE_ICU_MUX_IRQ(pmic,	IRQ_MMP3_PMIC_BASE,	MMP3_ICU_INT_4);
+DEFINE_ICU_MUX_IRQ(rtc,		IRQ_MMP3_RTC_BASE,	MMP3_ICU_INT_5);
+DEFINE_ICU_MUX_IRQ(hsi3,	IRQ_MMP3_HSI3_BASE,	MMP3_ICU_INT_6);
+DEFINE_ICU_MUX_IRQ(gpu,		IRQ_MMP3_GPU_BASE,	MMP3_ICU_INT_8);
+DEFINE_ICU_MUX_IRQ(twsi,	IRQ_MMP3_TWSI_BASE,	MMP3_ICU_INT_17);
+DEFINE_ICU_MUX_IRQ(hsi2,	IRQ_MMP3_HSI2_BASE,	MMP3_ICU_INT_18);
+DEFINE_ICU_MUX_IRQ(dxo,		IRQ_MMP3_DXO_BASE,	MMP3_ICU_INT_30);
+/*DEFINE_ICU_MUX_IRQ(misc1,	IRQ_MMP3_MISC1_BASE,	MMP3_ICU_INT_35);*/
+DEFINE_ICU_MUX_IRQ(ci,		IRQ_MMP3_CI_BASE,	MMP3_ICU_INT_42);
+DEFINE_ICU_MUX_IRQ(ssp,		IRQ_MMP3_SSP_BASE,	MMP3_ICU_INT_51);
+DEFINE_ICU_MUX_IRQ(hsi1,	IRQ_MMP3_HSI1_BASE,	MMP3_ICU_INT_55);
+DEFINE_ICU_MUX_IRQ(misc2,	IRQ_MMP3_MISC2_BASE,	MMP3_ICU_INT_57);
+DEFINE_ICU_MUX_IRQ(hsi0,	IRQ_MMP3_HSI0_BASE,	MMP3_ICU_INT_58);
+
+static void init_mux_irq(struct icu_mux_irq_chip_data *chip_data,
+	int mux_irq, int mux_start, int count, irq_flow_handler_t mux_handle)
+{
+	struct irq_chip *chip;
+	int irq;
+	u32 r;
+
+	/* maks all the irqs*/
+	r = __raw_readl(chip_data->mask) | ((1 << count) - 1);
+	__raw_writel(r, chip_data->mask);
+
+	for (irq = mux_start; count > 0; irq++, count--) {
+		irq_set_chip_and_handler(irq, &icu_mux_irq_chip, handle_level_irq);
+		irq_set_chip_data(irq, chip_data);
+		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	}
+
+	chip = irq_get_chip(mux_irq);
+	irq_set_chained_handler(mux_irq, mux_handle);
+	chip->irq_unmask(irq_get_irq_data(mux_irq));
+}
+
+static void pmic_irq_ack(struct irq_data *d)
+{
+	unsigned long data;
+	if (d->irq == IRQ_MMP3_PMIC) {
+		data = mfp_read(MFP_PIN_PMIC_INT);
+		mfp_write(MFP_PIN_PMIC_INT, data | MFPR_EDGE_CLEAR);
+		mfp_write(MFP_PIN_PMIC_INT, data & (~MFPR_EDGE_CLEAR));
+	}
+}
+
+static void pmic_set_ack(int mux_irq)
+{
+	struct irq_chip *chip;
+
+	chip = irq_get_chip(mux_irq);
+	chip->irq_ack = pmic_irq_ack;
+}
+
+static void icu1_mask_irq(int irq)
+{
+	uint32_t r = __raw_readl(ICU1_INT_CONF(irq));
+
+	r &= ~ICU1_INT_ROUTE_PJMP1_IRQ;
+	r &= ~ICU1_INT_ROUTE_PJMP1_FIQ;
+	__raw_writel(r, ICU1_INT_CONF(irq));
+}
+
+static void icu2_mask_irq(int irq)
+{
+	uint32_t r = __raw_readl(ICU2_INT_CONF(irq));
+
+	r &= ~ICU2_INT_ROUTE_PJMP2_IRQ;
+	r &= ~ICU2_INT_ROUTE_PJMP2_FIQ;
+	r &= ~ICU2_INT_ROUTE_PJMM_IRQ;
+	r &= ~ICU2_INT_ROUTE_PJMM_FIQ;
+	__raw_writel(r, ICU2_INT_CONF(irq));
+}
+
+void __init mmp3_init_gic(void)
+{
+	int i;
+
+	/* disable global irq of ICU for MP1, MP2, MM*/
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ1_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ2_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ3_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ4_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ5_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ6_MSK);
+
+	/*
+	 * FIXME
+	 * It is required to unmask ICU1_INT_35_MASK_NPMUIRQ_[0-2], 24-22
+	 * bit to enable IRQ_MMP3_PMU_CPU[0-2] (via sysint[86-88])
+	 */
+	{
+		int val;
+		val = __raw_readl(MMP3_ICU_INT_35_MASK);
+		val &= ~((1<<24) | (1<<23) | (1<<22));
+		__raw_writel(val, MMP3_ICU_INT_35_MASK);
+	}
+
+
+	for (i = 0; i < 64; i++) {
+		icu1_mask_irq(i);
+		icu2_mask_irq(i);
+	}
+
+	gic_arch_extn.irq_set_wake = mmp3_set_wake;
+
+	init_mux_irq(&pmic_icu_chip_data, IRQ_MMP3_PMIC_MUX,
+			IRQ_MMP3_PMIC_BASE, 4, pmic_irq_demux);
+	init_mux_irq(&rtc_icu_chip_data, IRQ_MMP3_RTC_MUX,
+			IRQ_MMP3_RTC_BASE, 2, rtc_irq_demux);
+	init_mux_irq(&hsi3_icu_chip_data, IRQ_MMP3_HSI3_MUX,
+			IRQ_MMP3_HSI3_BASE, 3, hsi3_irq_demux);
+	init_mux_irq(&gpu_icu_chip_data, IRQ_MMP3_GPU_MUX,
+			IRQ_MMP3_GPU_BASE, 3, gpu_irq_demux);
+	init_mux_irq(&twsi_icu_chip_data, IRQ_MMP3_TWSI_MUX,
+			IRQ_MMP3_TWSI_BASE, 5, twsi_irq_demux);
+	init_mux_irq(&hsi2_icu_chip_data, IRQ_MMP3_HSI2_MUX,
+			IRQ_MMP3_HSI2_BASE, 2, hsi2_irq_demux);
+	init_mux_irq(&dxo_icu_chip_data, IRQ_MMP3_DXO_MUX,
+			IRQ_MMP3_DXO_BASE, 2, dxo_irq_demux);
+	/*init_mux_irq(&misc1_icu_chip_data, IRQ_MMP3_MISC1_MUX,
+			IRQ_MMP3_MISC1_BASE, 31, misc1_irq_demux);*/
+	init_mux_irq(&ci_icu_chip_data, IRQ_MMP3_CI_MUX,
+			IRQ_MMP3_CI_BASE, 2, ci_irq_demux);
+	init_mux_irq(&ssp_icu_chip_data, IRQ_MMP3_SSP_MUX,
+			IRQ_MMP3_SSP_BASE, 2, ssp_irq_demux);
+	init_mux_irq(&hsi1_icu_chip_data, IRQ_MMP3_HSI1_MUX,
+			IRQ_MMP3_HSI1_BASE, 4, hsi1_irq_demux);
+	init_mux_irq(&misc2_icu_chip_data, IRQ_MMP3_MISC2_MUX,
+			IRQ_MMP3_MISC2_BASE, 20, misc2_irq_demux);
+	init_mux_irq(&hsi0_icu_chip_data, IRQ_MMP3_HSI0_MUX,
+			IRQ_MMP3_HSI0_BASE, 5, hsi0_irq_demux);
+
+	/*
+	 * Note: IRQ_MMP3_PMIC requires the PMIC MFPR register
+	 * to be written to clear the interrupt.
+	 */
+	pmic_set_ack(IRQ_MMP3_PMIC);
+
+}
diff --git a/arch/arm/mach-mmp/localtimer.c b/arch/arm/mach-mmp/localtimer.c
new file mode 100644
index 0000000..2918c62
--- /dev/null
+++ b/arch/arm/mach-mmp/localtimer.c
@@ -0,0 +1,28 @@
+/*
+ *  linux/arch/arm/mach-mmp/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/irq.h>
+#include <asm/smp_twd.h>
+#include <mach/irqs.h>
+#include <asm/localtimer.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	evt->irq = IRQ_LOCALTIMER;
+	twd_timer_setup(evt);
+	return 0;
+}
diff --git a/arch/arm/mach-mmp/mmp2_sspa.c b/arch/arm/mach-mmp/mmp2_sspa.c
new file mode 100644
index 0000000..91d2f24
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp2_sspa.c
@@ -0,0 +1,219 @@
+/*
+ *  linux/arch/arm/mach-mmp/pxa688_sspa.c
+ *
+ *  based on linux/arch/arm/mach-sa1100/ssp.c by Russell King
+ *
+ *  Copyright (C) 2003 Russell King.
+ *  Copyright (C) 2003 Wolfson Microelectronics PLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  PXA2xx SSP driver.  This provides the generic core for simple
+ *  IO-based SSP applications and allows easy port setup for DMA access.
+ *
+ *  Author: Liam Girdwood <liam.girdwood@wolfsonmicro.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <plat/ssp.h>
+
+static DEFINE_MUTEX(sspa_lock);
+static LIST_HEAD(sspa_list);
+
+struct ssp_device *sspa_request(int port, const char *label)
+{
+	struct ssp_device *ssp = NULL;
+
+	mutex_lock(&sspa_lock);
+
+	list_for_each_entry(ssp, &sspa_list, node) {
+		if (ssp->port_id == port && ssp->use_count == 0) {
+			ssp->use_count++;
+			ssp->label = label;
+			break;
+		}
+	}
+
+	mutex_unlock(&sspa_lock);
+
+	if (&ssp->node == &sspa_list)
+		return NULL;
+
+	return ssp;
+}
+EXPORT_SYMBOL(sspa_request);
+
+void sspa_free(struct ssp_device *ssp)
+{
+	mutex_lock(&sspa_lock);
+	if (ssp->use_count) {
+		ssp->use_count--;
+		ssp->label = NULL;
+	} else
+		dev_err(&ssp->pdev->dev, "device already free\n");
+	mutex_unlock(&sspa_lock);
+}
+EXPORT_SYMBOL(sspa_free);
+
+static int __devinit pxa688_sspa_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct ssp_device *ssp;
+	int ret = 0;
+
+	ssp = kzalloc(sizeof(struct ssp_device), GFP_KERNEL);
+	if (ssp == NULL) {
+		dev_err(&pdev->dev, "failed to allocate memory");
+		return -ENOMEM;
+	}
+	ssp->pdev = pdev;
+
+#ifdef CONFIG_CPU_MMP2
+	ssp->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(ssp->clk))
+		dev_warn(&pdev->dev, "ssp clock is not exist\n");
+#endif
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no memory resource defined\n");
+		ret = -ENODEV;
+		goto err_free;
+	}
+
+	res = request_mem_region(res->start, res->end - res->start + 1,
+				 pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request memory resource\n");
+		ret = -EBUSY;
+		goto err_free;
+	}
+
+	ssp->phys_base = res->start;
+
+	ssp->mmio_base = ioremap(res->start, res->end - res->start + 1);
+	if (ssp->mmio_base == NULL) {
+		dev_err(&pdev->dev, "failed to ioremap() registers\n");
+		ret = -ENODEV;
+		goto err_free_mem;
+	}
+
+	ssp->irq = platform_get_irq(pdev, 0);
+	if (ssp->irq < 0) {
+		dev_err(&pdev->dev, "no IRQ resource defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP RX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+	ssp->drcmr_rx = res->start;
+
+	res = platform_get_resource(pdev, IORESOURCE_DMA, 1);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "no SSP TX DRCMR defined\n");
+		ret = -ENODEV;
+		goto err_free_io;
+	}
+	ssp->drcmr_tx = res->start;
+
+	/* PXA688 SSP ports starts from 1 and the internal pdev->id
+	 * starts from 0, do a translation here
+	 */
+	ssp->port_id = pdev->id + 1;
+	ssp->use_count = 0;
+
+	mutex_lock(&sspa_lock);
+	list_add(&ssp->node, &sspa_list);
+	mutex_unlock(&sspa_lock);
+
+	platform_set_drvdata(pdev, ssp);
+	printk(KERN_INFO "mmp2: sspa driverwas loaded\n");
+	return 0;
+
+err_free_io:
+	iounmap(ssp->mmio_base);
+err_free_mem:
+	release_mem_region(res->start, res->end - res->start + 1);
+err_free:
+	kfree(ssp);
+	return ret;
+}
+
+static int __devexit pxa688_sspa_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct ssp_device *ssp;
+
+	ssp = platform_get_drvdata(pdev);
+	if (ssp == NULL)
+		return -ENODEV;
+
+	iounmap(ssp->mmio_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+#ifdef CONFIG_CPU_MMP2
+	if (!IS_ERR(ssp->clk))
+		clk_put(ssp->clk);
+#endif
+	mutex_lock(&sspa_lock);
+	list_del(&ssp->node);
+	mutex_unlock(&sspa_lock);
+
+	kfree(ssp);
+	return 0;
+}
+
+static struct platform_driver pxa688_sspa_driver = {
+	.driver = {
+		   .name = "mmp2-sspa",
+		   },
+	.probe = pxa688_sspa_probe,
+	.remove = __devexit_p(pxa688_sspa_remove),
+};
+
+static int __init pxa_sspa_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&pxa688_sspa_driver);
+	if (ret) {
+		printk(KERN_ERR "failed to register pxa688_sspa_driver");
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit pxa_sspa_exit(void)
+{
+	platform_driver_unregister(&pxa688_sspa_driver);
+}
+
+arch_initcall(pxa_sspa_init);
+module_exit(pxa_sspa_exit);
+
+MODULE_DESCRIPTION("PXA688 SSPA driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mmp/mmp3.c b/arch/arm/mach-mmp/mmp3.c
new file mode 100644
index 0000000..2a98d4e
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp3.c
@@ -0,0 +1,1775 @@
+/*
+ * linux/arch/arm/mach-mmp/mmp3.c
+ *
+ * code name MMP3
+ *
+ * Copyright (C) 2009 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/mv_usb.h>
+#include <linux/notifier.h>
+
+#include <asm/smp_twd.h>
+#include <asm/mach/time.h>
+#include <asm/hardware/gic.h>
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/setup.h>
+
+#include <mach/addr-map.h>
+#include <mach/regs-apbc.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-pmu.h>
+#include <mach/regs-ciu.h>
+#include <mach/cputype.h>
+#include <mach/irqs.h>
+#include <mach/gpio.h>
+#include <mach/dma.h>
+#include <mach/devices.h>
+#include <mach/mmp3.h>
+#include <mach/regs-usb.h>
+#include <mach/soc_vmeta.h>
+#include <mach/mmp_dma.h>
+#include <mach/regs-zsp.h>
+#include <mach/mmp-zsp.h>
+#include <mach/regs-sspa.h>
+#include <linux/memblock.h>
+#include <mach/isp_dev.h>
+#include <mach/mv_wtm.h>
+#include <linux/platform_device.h>
+
+#include <plat/mfp.h>
+#include <plat/pmem.h>
+
+#include "common.h"
+
+unsigned int mmp_soc_stepping;
+EXPORT_SYMBOL(mmp_soc_stepping);
+unsigned int mmp_soc_profile;
+EXPORT_SYMBOL(mmp_soc_profile);
+unsigned int mmp_plat_ref_clk;
+EXPORT_SYMBOL(mmp_plat_ref_clk);
+extern void __iomem *twd_base;
+
+#define MFPR_VIRT_BASE	(APB_VIRT_BASE + 0x1e000)
+
+#define APMASK(i)	(GPIO_REGS_VIRT + BANK_OFF(i) + 0x9c)
+#define ISP_POLL_COUNT (10)
+
+#ifdef CONFIG_MMP_ZSP
+struct audio_dsp_pwr_status aud_pwr_status = {
+	0, 0, 0, 0,
+};
+#endif
+
+static struct mfp_addr_map mmp3_addr_map[] __initdata = {
+	MFP_ADDR_X(GPIO0, GPIO58, 0x54),
+	MFP_ADDR_X(GPIO59, GPIO73, 0x280),
+	MFP_ADDR_X(GPIO74, GPIO101, 0x170),
+	MFP_ADDR_X(GPIO102, GPIO103, 0x0),
+	MFP_ADDR_X(GPIO115, GPIO122, 0x260),
+	MFP_ADDR_X(GPIO124, GPIO141, 0xc),
+	MFP_ADDR_X(GPIO143, GPIO151, 0x220),
+	MFP_ADDR_X(GPIO152, GPIO153, 0x248),
+	MFP_ADDR_X(GPIO154, GPIO155, 0x254),
+
+	MFP_ADDR(GPIO142, 0x8),
+	MFP_ADDR(GPIO114, 0x164),
+	MFP_ADDR(GPIO123, 0x148),
+
+	MFP_ADDR(GPIO168, 0x1e0),
+	MFP_ADDR(GPIO167, 0x1e4),
+	MFP_ADDR(GPIO166, 0x1e8),
+	MFP_ADDR(GPIO165, 0x1ec),
+	MFP_ADDR(GPIO107, 0x1f0),
+	MFP_ADDR(GPIO106, 0x1f4),
+	MFP_ADDR(GPIO105, 0x1f8),
+	MFP_ADDR(GPIO104, 0x1fc),
+	MFP_ADDR(GPIO111, 0x200),
+	MFP_ADDR(GPIO164, 0x204),
+	MFP_ADDR(GPIO163, 0x208),
+	MFP_ADDR(GPIO162, 0x20c),
+	MFP_ADDR(GPIO161, 0x210),
+	MFP_ADDR(GPIO110, 0x214),
+	MFP_ADDR(GPIO109, 0x218),
+	MFP_ADDR(GPIO108, 0x21c),
+	MFP_ADDR(GPIO110, 0x214),
+	MFP_ADDR(GPIO112, 0x244),
+	MFP_ADDR(GPIO160, 0x250),
+	MFP_ADDR(GPIO113, 0x25c),
+	/* FIXME: Zx does not have this pin, define here will not impact */
+	MFP_ADDR(GPIO171, 0x2c8),
+
+	MFP_ADDR_X(TWSI1_SCL, TWSI1_SDA, 0x140),
+	MFP_ADDR_X(TWSI4_SCL, TWSI4_SDA, 0x2bc),
+	MFP_ADDR(PMIC_INT, 0x2c4),
+	MFP_ADDR(CLK_REQ, 0x160),
+
+	MFP_ADDR_END,
+};
+
+#ifdef CONFIG_SMP
+unsigned long c2_reserve_pa;
+#define C2_RESERVE_SIZE	(1024 * 1024)
+#endif
+unsigned long wtm_buffer;
+#define WTM_SIZE	(1024 * 1024)
+void __init mmp3_reserve(void)
+{
+	/*
+	 * reserve first page for uboot bootstrap, otherwise
+	 * unused core may run unpredictable instruction.
+	 *
+	 * NOTE: if enabled hypervisor code, then need reserve
+	 * the first 4KB from the address PLAT_PHYS_OFFSET.
+	 */
+	BUG_ON(memblock_reserve(PLAT_PHYS_OFFSET, 0x1000));
+
+	/*reserve memory for pmem*/
+	pxa_reserve_pmem_memblock();
+#ifdef CONFIG_SMP
+	c2_reserve_pa = memblock_alloc(C2_RESERVE_SIZE, PAGE_SIZE);
+	if (!c2_reserve_pa) {
+		pr_err("%s: failed to reserve memory for C2\n", __func__);
+		BUG();
+	}
+	BUG_ON(memblock_free(c2_reserve_pa, C2_RESERVE_SIZE));
+	BUG_ON(0 != memblock_remove(c2_reserve_pa, C2_RESERVE_SIZE));
+#endif
+/*	wtm_buffer = memblock_alloc(WTM_SIZE, PAGE_SIZE);
+	if (!wtm_buffer) {
+		pr_err("%s: failed to reserve memory for wtm_buffer\n", __func__);
+		BUG();
+	}
+	BUG_ON(memblock_free(wtm_buffer, WTM_SIZE));
+	BUG_ON(0 != memblock_remove(wtm_buffer, WTM_SIZE));*/
+
+}
+
+static void __init mmp3_init_gpio(void)
+{
+	int i;
+
+	/* enable GPIO clock */
+	__raw_writel(APBC_APBCLK | APBC_FNCLK, APBC_MMP2_GPIO);
+
+	/* unmask GPIO edge detection for all 6 banks -- APMASKx */
+	for (i = 0; i < 6; i++)
+		__raw_writel(0xffffffff, APMASK(i));
+
+	pxa_init_gpio(IRQ_MMP3_GPIO, 0, 167, mmp3_set_wake);
+}
+
+#ifdef CONFIG_REGDUMP
+static struct regdump_ops pmua_regdump_ops = {
+	.dev_name = "MMP3-PMUA",
+};
+
+static struct regdump_region pmua_dump_region[] = {
+	{"PMUA_CC_SP",			0x000, 4, regdump_cond_true},
+	{"PMUA_CC_PJ",			0x004, 4, regdump_cond_true},
+	{"PMUA_DM_CC_SP",		0x008, 4, regdump_cond_true},
+	{"PMUA_DM_CC_PJ",		0x00c, 4, regdump_cond_true},
+	{"PMUA_FC_TIMER",		0x010, 4, regdump_cond_true},
+	{"PMUA_SP_IDLE_CFG",		0x014, 4, regdump_cond_true},
+	{"PMUA_PJ_IDLE_CFG",		0x018, 4, regdump_cond_true},
+	{"PMUA_CCIC_CLK_GATE_CTRL",	0x028, 4, regdump_cond_true},
+	{"PMUA_FBRC1_CLK_GATE_CTRL",	0x02c, 4, regdump_cond_true},
+	{"PMUA_FBRC2_CLK_GATE_CTRL",	0x030, 4, regdump_cond_true},
+	{"PMUA_PMU_CLK_GATE_CTRL",	0x040, 4, regdump_cond_true},
+	{"PMUA_IRE_CLK_RES_CTRL",	0x048, 4, regdump_cond_true},
+	{"PMUA_DISPLAY1_CLK_RES_CTRL",	0x04c, 4, regdump_cond_true},
+	{"PMUA_CCIC_CLK_RES_CTRL",	0x050, 4, regdump_cond_true},
+	{"PMUA_SDH1_CLK_RES_CTRL",	0x054, 4, regdump_cond_true},
+	{"PMUA_SDH2_CLK_RES_CTRL",	0x058, 4, regdump_cond_true},
+	{"PMUA_USB_CLK_RES_CTRL",	0x05c, 4, regdump_cond_true},
+	{"PMUA_NF_CLK_RES_CTRL",	0x060, 4, regdump_cond_true},
+	{"PMUA_DMA_CLK_RES_CTRL",	0x064, 4, regdump_cond_true},
+	{"PMUA_WTM_CLK_RES_CTRL",	0x068, 4, regdump_cond_true},
+	{"PMUA_BUS_CLK_RES_CTRL",	0x06c, 4, regdump_cond_true},
+	{"PMUA_WAKE_CLR_MASK",		0x07c, 4, regdump_cond_true},
+	{"PMUA_PWR_STBL_TIMER",		0x084, 4, regdump_cond_true},
+	{"PMUA_SRAM_PWR_DWN",		0x08c, 4, regdump_cond_true},
+	{"PMUA_CORE_STATUS",		0x090, 4, regdump_cond_true},
+	{"PMUA_RES_FRM_SLP_CLR",	0x094, 4, regdump_cond_true},
+	{"PMUA_AP_IRWC",		0x09c, 4, regdump_cond_true},
+	{"PMUA_AP_ISR",			0x0a0, 4, regdump_cond_true},
+	{"PMUA_VMETA_CLK_RES_CTRL",	0x0a4, 4, regdump_cond_true},
+	{"PMUA_MC_HW_SLP_TYPE",		0x0b0, 4, regdump_cond_true},
+	{"PMUA_MC_SLP_REQ_PJ",		0x0b4, 4, regdump_cond_true},
+	{"PMUA_MC_SW_SLP_TYPE",		0x0c0, 4, regdump_cond_true},
+	{"PMUA_PLL_SEL_STATUS",		0x0c4, 4, regdump_cond_true},
+	{"PMUA_GC_CLK_RES_CTRL",	0x0cc, 4, regdump_cond_true},
+	{"PMUA_SMC_CLK_RES_CTRL",	0x0d4, 4, regdump_cond_true},
+	{"PMUA_GLB_CLK_CTRL",		0x0dc, 4, regdump_cond_true},
+	{"PMUA_PWR_ONOFF_CTRL",		0x0e0, 4, regdump_cond_true},
+	{"PMUA_PWR_ISL_TIMER",		0x0e4, 4, regdump_cond_true},
+	{"PMUA_SDH3_CLK_RES_CTRL",	0x0e8, 4, regdump_cond_true},
+	{"PMUA_SDH4_CLK_RES_CTRL",	0x0ec, 4, regdump_cond_true},
+	{"PMUA_CCIC2_CLK_RES_CTRL",	0x0f4, 4, regdump_cond_true},
+	{"PMUA_HSIC1_CLK_RES_CTRL",	0x0f8, 4, regdump_cond_true},
+	{"PMUA_HSIC2_CLK_RES_CTRL",	0x0fc, 4, regdump_cond_true},
+	{"PMUA_FSIC3_CLK_RES_CTRL",	0x100, 4, regdump_cond_true},
+	{"PMUA_SLIM_CLK_RES_CTRL",	0x104, 4, regdump_cond_true},
+	{"PMUA_AUDIO_CLK_RES_CTRL",	0x10c, 4, regdump_cond_true},
+	{"PMUA_DISPLAY2_CLK_RES_CTRL",	0x110, 4, regdump_cond_true},
+	{"PMUA_CCIC2_CLK_GATE_CTRL",	0x118, 4, regdump_cond_true},
+	{"PMUA_MC_PAR_CTRL",		0x11c, 4, regdump_cond_true},
+	{"PMUA_SPMI_CLK_RES_CTRL",	0x140, 4, regdump_cond_true},
+	{"PMUA_EPD_CLK_RES_CTRL",	0x144, 4, regdump_cond_true},
+	{"PMUA_USB3SS_CLK_RES_CTRL",	0x148, 4, regdump_cond_true},
+	{"PMUA_CC2_SP",			0x14c, 4, regdump_cond_true},
+	{"PMUA_CC2_PJ",			0x150, 4, regdump_cond_true},
+	{"PMUA_DM2_CC_SP",		0x154, 4, regdump_cond_true},
+	{"PMUA_DM2_CC_PJ",		0x158, 4, regdump_cond_true},
+	{"PMUA_SDH5_CLK_RES_CTRL",	0x160, 4, regdump_cond_true},
+	{"PMUA_DSA_CLK_RES_CTRL",	0x164, 4, regdump_cond_true},
+	{"IOC_CTRL",			0x184, 4, regdump_cond_true},
+	{"PMUA_CC3_PJ",			0x188, 4, regdump_cond_true},
+	{"PMUA_TPIU_CLK_RES_CTRL",	0x18c, 4, regdump_cond_true},
+	{"PMUA_DEBUG2",			0x190, 4, regdump_cond_true},
+	{"PMUA_RF1P_CTRL",		0x1c0, 4, regdump_cond_true},
+	{"PMUA_RF2P_CTRL",		0x1c4, 4, regdump_cond_true},
+	{"PMUA_SR1P_CTRL",		0x1c8, 4, regdump_cond_true},
+	{"PMUA_SR2P_CTRL",		0x1cc, 4, regdump_cond_true},
+	{"PMUA_SR1P_CTRL",		0x1c8, 4, regdump_cond_true},
+	{"PMUA_BROM_CTRL",		0x1d0, 4, regdump_cond_true},
+	{"PMUA_ISP_PWR_CTRL",		0x1fc, 4, regdump_cond_true},
+	{"PMUA_PJ_IDLE_CFG2",		0x200, 4, regdump_cond_true},
+	{"PMUA_PJ_IDLE_CFG3",		0x204, 4, regdump_cond_true},
+	{"PMUA_FASTENET_CLK_RES_CTRL",	0x210, 4, regdump_cond_true},
+	{"PMUA_ISLAND_PWR_STATUS",	0x220, 4, regdump_cond_true},
+	{"PMUA_ISP_CLK_RES_CTRL",	0x224, 4, regdump_cond_true},
+	{"PMUA_AUDIO_ISLAND_SRAM_PWR_DWN_CTRL",	0x240, 4, regdump_cond_true},
+	{"PMUA_GENERIC_CTRL",		0x244, 4, regdump_cond_true},
+	{"PMUA_PJ_C0_CC4",		0x248, 4, regdump_cond_true},
+	{"PMUA_PJ_C1_CC4",		0x24c, 4, regdump_cond_true},
+	{"PMUA_PJ_C2_CC4",		0x250, 4, regdump_cond_true},
+	{"PMUA_PJ_MP_SUBSYS_CC",	0x254, 4, regdump_cond_true},
+	{"PMUA_MC1_DOUBLER_CTRL",	0x258, 4, regdump_cond_true},
+	{"PMUA_MC2_DOUBLER_CTRL",	0x25c, 4, regdump_cond_true},
+	{"PMUA_DOUBLER_GENERIC_CTRL",	0x260, 4, regdump_cond_true},
+	{"PMUA_MC1_DOUBLER_STAT",	0x264, 4, regdump_cond_true},
+	{"PMUA_MC2_DOUBLER_STAT",	0x268, 4, regdump_cond_true},
+	{"PMUA_SDHM_DLL_CTRL0",		0x26c, 4, regdump_cond_true},
+	{"PMUA_SDHM_DLL_CTRL1",		0x270, 4, regdump_cond_true},
+	{"PMUA_SDHM_DLL_STAT0",		0x274, 4, regdump_cond_true},
+	{"PMUA_SDHM_DLL_STAT1",		0x278, 4, regdump_cond_true}
+};
+
+static void __init mmp3_init_pmua_regdump(void)
+{
+	pmua_regdump_ops.base = PMUA_VIRT_BASE;
+	pmua_regdump_ops.regions = pmua_dump_region;
+	pmua_regdump_ops.reg_nums = ARRAY_SIZE(pmua_dump_region);
+	register_regdump_ops(&pmua_regdump_ops);
+}
+#else
+static void inline  __init mmp3_init_pmua_regdump() {}
+#endif
+
+void __init mmp3_init_irq(void)
+{
+	gic_init(0, 29, (void __iomem *) GIC_DIST_VIRT_BASE, (void __iomem *) GIC_CPU_VIRT_BASE);
+
+	mmp3_init_gic();
+}
+
+#ifdef CONFIG_CACHE_L2X0
+static void mmp3_init_l2x0(void)
+{
+	void __iomem *l2x0_base = ioremap(SL2C_PHYS_BASE, SZ_4K);
+	if (IS_ERR(l2x0_base)) {
+		printk(KERN_ERR "L2 map failed %ld\n", PTR_ERR(l2x0_base));
+	} else {
+		/* Auxiliary Control:
+		   TODO: According to the manual, this register should be
+			written in secure access, we may need to move the
+			configuration in early stage of boot if TZ enabled
+
+		   [ 0.. 2]	cycles of latency of data RAM read
+		   [ 3.. 5]	cycles of latency of data RAM write
+		   [ 6.. 8]	cycles of latency of tag RAM
+		   [ 9..11]	cycles of latency of dirty RAM
+		   [12]		exclusive cache op, 0:disable,1:enable
+		   [13..16]	associativity
+		   [17..19]	way-size
+		   [20]		event monitor bus enable
+		   [21]		parity enable
+		   [22]		shared attribute override enable
+		   [23..24]	force write allocate
+				0: use AWCACHE
+				1: force no WA
+				2: force WA on
+				3: internal mapped
+		   [25]		reserved, SBO/RAO
+		   [26]		Non-secure lockdown enable
+		   [27]		Non-secure interrupt access enable
+		   [28]		data prefetch enable
+		   [29]		instruction prefetch enable
+		   [30..31]	reserved, SBZ
+		*/
+		/*
+		   forece NO WA, for A0 memory performance, bug in WA
+		   64KB way-size
+		   clear bit[16] to make sure l2x0_init call take it as 8-way
+		   Overall enabling of L2 prefetching, when enabled, the
+		   L2X0 prefetching kernel config can take effect. The feature
+		   requires both here and the config code in L2X0 driver
+		   to work.
+		*/
+		l2x0_init(l2x0_base, 0x30860000, 0xC200FFFF);
+	}
+}
+#else
+static void mmp3_init_l2x0(void) {}
+#endif
+
+#define DMCU_REG(mcu, x) (DMCU_VIRT_BASE + ((mcu) * 0x10000) + (x))
+#define DMCU0_PORT_PRIORITY_VA DMCU_REG(0, 0x140)
+#define DMCU1_PORT_PRIORITY_VA DMCU_REG(1, 0x140)
+/* raise display related DDR ports to critical with low latency requirement*/
+#define DEFAULT_DDR_PORT_PRI (0xff003030)
+
+static void mmp3_fabric_ddr_config(void)
+{
+	u32  regval;
+
+	/* fabric dynamic clock gating */
+	regval = __raw_readl(CIU_FABRIC_CKGT_CTRL0);
+	regval &= ~(0xFE00AAAA);	/* clear reserved bits */
+					/* [31:25] reserved*/
+	regval &= ~(0x1 << 24);		/*Fab11 aclk, VMETA AXI*/
+	regval &= ~(0x1 << 23);		/*Fab9 aclk, MDMA/VDMA*/
+	regval &= ~(0x7f << 16);	/*MC1x2 fabrics*/
+					/* 15, reserved*/
+	regval &= ~(0x1 << 14);		/*fabric2 aclk, LCD/FE/IRE/Fabric5*/
+					/* 13, reserved*/
+	/* disable DCG on fabric 3, JIRA:MMP3-1586 */
+	regval |= (0x1 << 12);		/*fabric3 aclk3, ISP/CCIC/Fabric4*/
+					/* 11, reserved*/
+	regval &= ~(0x1 << 10);		/*fabric1 aclk2, PJ/SP/APB/AHB*/
+					/* 9, reserved*/
+	regval &= ~(0x1 << 8);		/*fabric4 aclk, USB/SD/NFC/SMC*/
+					/* 7, reserved*/
+	regval &= ~(0x1 << 6);		/*fabric4 aclk2, USB/SD/NFC/SMC*/
+					/* 5, reserved*/
+	regval &= ~(0x1 << 4);		/*fabric10 aclk, USB/SD/NFC/SMC*/
+					/* 3, reserved*/
+	regval &= ~(0x1 << 2);		/*fabric10 aclk2, USB/SD/NFC/SMC*/
+					/* 1, reserved*/
+	regval &= ~(0x1 << 0);		/*fabric5 aclk5, HSI/SPMI/SLIMBUS0*/
+	__raw_writel(regval, CIU_FABRIC_CKGT_CTRL0);
+
+	regval = __raw_readl(CIU_FABRIC_CKGT_CTRL1);
+	regval &= ~(0xFFFFFFFC);	/* clear reserved bits */
+					/* [31:2] reserved*/
+	regval &= ~(0x1 << 1);		/*audio fabric*/
+	regval &= ~(0x1 << 0);		/*DDR P5*/
+	__raw_writel(regval, CIU_FABRIC_CKGT_CTRL1);
+
+	regval = __raw_readl(CIU_FABRIC_CKGT_CTRL2);
+	regval &= ~(0xFFFFFFFE);	/* clear reserved bits */
+					/* [31:1] reserved*/
+	regval &= ~(0x1 << 0);		/*GC Fabric*/
+	__raw_writel(regval, CIU_FABRIC_CKGT_CTRL2);
+
+	dsb();
+	pr_info("%s: 0x%08x, 0x%08x, 0x%08x\n", __func__
+		, __raw_readl(CIU_FABRIC_CKGT_CTRL0)
+		, __raw_readl(CIU_FABRIC_CKGT_CTRL1)
+		, __raw_readl(CIU_FABRIC_CKGT_CTRL2)
+		);
+
+	/* update priority*/
+	pr_info("%s: DDR interleave size %d KB\n", __func__
+		, ciu_ddr_ilv_size()/1024);
+	if (ciu_ddr_ilv_on()) {
+		__raw_writel(DEFAULT_DDR_PORT_PRI, DMCU0_PORT_PRIORITY_VA);
+		__raw_writel(DEFAULT_DDR_PORT_PRI, DMCU1_PORT_PRIORITY_VA);
+		pr_info("%s: DDR Port Priority %x, %x\n", __func__
+			, __raw_readl(DMCU0_PORT_PRIORITY_VA)
+			, __raw_readl(DMCU1_PORT_PRIORITY_VA)
+			);
+	} else {
+		__raw_writel(DEFAULT_DDR_PORT_PRI, DMCU0_PORT_PRIORITY_VA);
+		pr_info("%s: DDR Port Priority %x\n", __func__
+			, __raw_readl(DMCU0_PORT_PRIORITY_VA));
+
+		/* make sure 2nd MC is off */
+		regval = __raw_readl(APMU_BUS);
+		regval &= ~(1u << 1);
+		__raw_writel(regval, APMU_BUS);
+
+		/* force 2nd MC clock generating block to be clock gated*/
+		regval = __raw_readl(APMU_REG(0x40));
+		regval &= ~(3u << 18);
+		regval |= (1u << 18);
+		__raw_writel(regval, APMU_REG(0x40));
+	}
+
+	dsb();
+
+}
+
+static void __init mmp3_timer_init(void)
+{
+	uint32_t clk_rst;
+
+#ifdef CONFIG_LOCAL_TIMERS
+	twd_base = (void __iomem *)TWD_VIRT_BASE;
+#endif
+
+	/* this is early, we have to initialize the CCU registers by
+	 * ourselves instead of using clk_* API. Clock rate is defined
+	 * by APBC_TIMERS_FNCLKSEL and enabled free-running
+	 */
+	__raw_writel(APBC_APBCLK | APBC_RST, APBC_MMP2_TIMERS);
+
+	/* 6.5MHz, bus/functional clock enabled, release reset */
+	clk_rst = APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(1);
+	__raw_writel(clk_rst, APBC_MMP2_TIMERS);
+
+#ifdef CONFIG_SOC_LOCAL_TIMERS
+	timer_init(IRQ_MMP3_TIMER1, IRQ_MMP3_TIMER2, IRQ_MMP3_TIMER3);
+#else
+	timer_init(IRQ_MMP3_TIMER1, IRQ_MMP3_TIMER2);
+#endif
+}
+
+struct sys_timer mmp3_timer = {
+	.init   = mmp3_timer_init,
+};
+
+#define PJ4B_WCB_MIN_MSK	(0x3f)
+#define PJ4B_WCB_MIN_SHFT	(1)
+#define PJ4B_WCB_MAX_MSK	(0x3f)
+#define PJ4B_WCB_MAX_SHFT	(7)
+#define PJ4B_WCB_EVCT_MSK	(0x7fff)
+#define PJ4B_WCB_EVCT_SHFT	(13)
+#define OMITFLD			((unsigned long)-1)
+#define UPDATE_ON_VALID(lval, rval, msk, shft)		\
+	do if (rval != OMITFLD) {			\
+		lval &= ~((msk) << (shft));		\
+		lval |= (((rval) & (msk)) << (shft));	\
+	} while (0)
+
+static unsigned long pj4b_wcb_config(unsigned long min, unsigned long max,
+			unsigned long evct)
+{
+	register unsigned long regval;
+	__asm__("mrc p15, 1, %0, c15, c2, 1" : "=r" (regval));
+	UPDATE_ON_VALID(regval, min, PJ4B_WCB_MIN_MSK, PJ4B_WCB_MIN_SHFT);
+	UPDATE_ON_VALID(regval, max, PJ4B_WCB_MAX_MSK, PJ4B_WCB_MAX_SHFT);
+	UPDATE_ON_VALID(regval, evct, PJ4B_WCB_EVCT_MSK, PJ4B_WCB_EVCT_SHFT);
+	__asm__("mcr p15, 1, %0, c15, c2, 1" : : "r" (regval));
+	return regval;
+}
+
+struct platform_device mmp3_device_asoc_sspa1 = {
+	.name		= "mmp3-sspa-dai",
+	.id		= 0,
+};
+
+struct platform_device mmp3_device_asoc_sspa2 = {
+	.name		= "mmp3-sspa-dai",
+	.id		= 1,
+};
+
+struct platform_device mmp3_device_asoc_platform = {
+	.name		= "mmp3-pcm-audio",
+	.id		= -1,
+};
+
+struct platform_device mmp3_device_asoc_hdmi = {
+	.name		= "dummy-codec",
+	.id		= -1,
+};
+
+static int __init mmp3_init(void)
+{
+	/*
+	  let's make minimum WCB open entries to 2 to boost memory access
+	*/
+	pj4b_wcb_config(2, OMITFLD, OMITFLD);
+
+	mmp3_init_l2x0();
+
+	mmp3_fabric_ddr_config();
+
+	mfp_init_base(MFPR_VIRT_BASE);
+	mfp_init_addr(mmp3_addr_map);
+
+	mmp3_init_gpio();
+	mmp3_init_pmua_regdump();
+
+	pxa_init_dma(IRQ_MMP3_DMA_RIQ, 16);
+	mmp_init_dma(IRQ_MMP3_DMA_RIQ);
+
+	platform_device_register(&mmp3_device_asoc_sspa1);
+	platform_device_register(&mmp3_device_asoc_sspa2);
+	platform_device_register(&mmp3_device_asoc_platform);
+	platform_device_register(&mmp3_device_asoc_hdmi);
+
+	return 0;
+}
+
+postcore_initcall(mmp3_init);
+
+/* on-chip devices */
+MMP3_DEVICE(uart1, "pxa2xx-uart", 0, UART1, 0xd4030000, 0x30, 4, 5);
+MMP3_DEVICE(uart2, "pxa2xx-uart", 1, UART2, 0xd4017000, 0x30, 20, 21);
+MMP3_DEVICE(uart3, "pxa2xx-uart", 2, UART3, 0xd4018000, 0x30, 22, 23);
+MMP3_DEVICE(uart4, "pxa2xx-uart", 3, UART4, 0xd4016000, 0x30, 18, 19);
+MMP3_DEVICE(nand, "pxa3xx-nand", -1, NAND, 0xd4283000, 0x100, 28, 29);
+MMP3_DEVICE(sdh0, "sdhci-pxa", 0, MMC, 0xd4280000, 0x120);
+MMP3_DEVICE(sdh1, "sdhci-pxa", 1, MMC2, 0xd4280800, 0x120);
+MMP3_DEVICE(sdh2, "sdhci-pxa", 2, MMC3, 0xd4281000, 0x120);
+MMP3_DEVICE(sdh3, "sdhci-pxa", 3, MMC4, 0xd4281800, 0x120);
+MMP3_DEVICE(twsi1, "pxa2xx-i2c", 0, TWSI1, 0xd4011000, 0x70);
+MMP3_DEVICE(twsi2, "pxa2xx-i2c", 1, TWSI2, 0xd4031000, 0x70);
+MMP3_DEVICE(twsi3, "pxa2xx-i2c", 2, TWSI3, 0xd4032000, 0x70);
+MMP3_DEVICE(twsi4, "pxa2xx-i2c", 3, TWSI4, 0xd4033000, 0x70);
+MMP3_DEVICE(twsi5, "pxa2xx-i2c", 4, TWSI5, 0xd4033800, 0x70);
+MMP3_DEVICE(twsi6, "pxa2xx-i2c", 5, TWSI6, 0xd4034000, 0x70);
+MMP3_DEVICE(pwm1, "mmp2-pwm", 0, NONE, 0xd401a000, 0x10);
+MMP3_DEVICE(pwm2, "mmp2-pwm", 1, NONE, 0xd401a400, 0x10);
+MMP3_DEVICE(pwm3, "mmp2-pwm", 2, NONE, 0xd401a800, 0x10);
+MMP3_DEVICE(pwm4, "mmp2-pwm", 3, NONE, 0xd401ac00, 0x10);
+MMP3_DEVICE(keypad, "pxa27x-keypad", -1, KEYPAD, 0xd4012000, 0x4c);
+MMP3_DEVICE(fb, "pxa168-fb", 0, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(fb_ovly, "pxa168fb_ovly", 0, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(v4l2_ovly, "pxa168-v4l2_ovly", 0, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(fb_tv, "pxa168-fb", 1, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(fb_tv_ovly, "pxa168fb_ovly", 1, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(v4l2_tv_ovly, "pxa168-v4l2_ovly", 1, LCD, 0xd420b000, 0x500);
+MMP3_DEVICE(hdmi, "uio-hdmi", -1, HDMI, 0xd420b000, 0x1fff);
+MMP3_DEVICE(ddr_devfreq, "devfreq-ddr", -1, NONE, 0xd0000000, 0x1000);
+MMP3_DEVICE(sspa1, "mmp2-sspa", 0, SSPA1, 0xc0ffdc00, 0xb0, ADMA1_CH1,
+	    ADMA1_CH0);
+MMP3_DEVICE(sspa2, "mmp2-sspa", 1, SSPA2, 0xc0ffdd00, 0xb0, ADMA2_CH1,
+	    ADMA2_CH0);
+MMP3_DEVICE(ssp1, "mmp-ssp", 1, SSP1, 0xd4035000, 0x40, 6, 7);
+MMP3_DEVICE(ssp2, "mmp-ssp", 2, SSP2, 0xd4036000, 0x40, 10, 11);
+MMP3_DEVICE(ssp3, "mmp-ssp", 3, SSP3, 0xd4037000, 0x40, 12, 13);
+MMP3_DEVICE(ssp4, "mmp-ssp", 4, SSP4, 0xd4039000, 0x40, 14, 15);
+MMP3_DEVICE(thermal, "mmp-thermal", -1, THERMAL_SENSOR, 0xd403b000, 0x10);
+
+MMP3_DEVICE(audiosram, "mmp-sram", 0, NONE, 0xd1030000, 0x20000);
+MMP3_DEVICE(camera0, "mv-camera", 0, CCIC1, 0xd420a000, 0x2ff);
+MMP3_DEVICE(camera1, "mv-camera", 1, CCIC2, 0xd420a800, 0x2ff);
+MMP3_DEVICE(videosram, "mmp-sram", 1, NONE, 0xd1020000, 0x10000);
+
+void mmp3_clear_keypad_wakeup(void)
+{
+	uint32_t val;
+	uint32_t mask = (1 << 5);
+
+	/* wake event clear is needed in order to clear keypad interrupt */
+	val = __raw_readl(APMU_WAKE_CLR);
+	__raw_writel(val | mask, APMU_WAKE_CLR);
+}
+
+static struct resource mmp3_resource_rtc[] = {
+	{ 0xd4010000, 0xd40100ff, NULL, IORESOURCE_MEM, },
+	{ IRQ_MMP3_RTC, IRQ_MMP3_RTC, NULL, IORESOURCE_IRQ, },
+	{ IRQ_MMP3_RTC_ALARM, IRQ_MMP3_RTC_ALARM, NULL, IORESOURCE_IRQ, },
+};
+
+struct platform_device mmp3_device_rtc = {
+	.name           = "mmp-rtc",
+	.id             = -1,
+	.resource       = mmp3_resource_rtc,
+	.num_resources  = ARRAY_SIZE(mmp3_resource_rtc),
+};
+
+struct platform_device mmp3_device_vnc_touch = {
+	.name   = "vnc-ts",
+	.id     = -1,
+};
+
+#ifdef CONFIG_USB_SUPPORT
+static u64 usb_dma_mask = ~(u32)0;
+
+#ifdef CONFIG_USB_PXA_U2O
+struct resource mmp3_u2o_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_MMP3_USB_OTG,
+		.end	= IRQ_MMP3_USB_OTG,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_device_u2o = {
+	.name		= "pxa-u2o",
+	.id		= -1,
+	.resource	= mmp3_u2o_resources,
+	.num_resources	= ARRAY_SIZE(mmp3_u2o_resources),
+	.dev		=  {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	}
+};
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA
+#ifdef CONFIG_USB_EHCI_PXA_U2O
+struct resource mmp3_u2oehci_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_MMP3_USB_OTG,
+		.end	= IRQ_MMP3_USB_OTG,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_device_u2oehci = {
+	.name		= "pxa-u2oehci",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(mmp3_u2oehci_resources),
+	.resource	= mmp3_u2oehci_resources,
+};
+
+#ifdef CONFIG_USB_PXA_U2O_OTG
+struct resource mmp3_u2ootg_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= PXA168_U2O_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= PXA168_U2O_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= PXA168_U2O_PHYBASE,
+		.end	= PXA168_U2O_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_MMP3_USB_OTG,
+		.end	= IRQ_MMP3_USB_OTG,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_device_u2ootg = {
+	.name		= "pxa-otg",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= 0xffffffff,
+	},
+
+	.num_resources	= ARRAY_SIZE(mmp3_u2ootg_resources),
+	.resource	= mmp3_u2ootg_resources,
+};
+
+#endif	/* CONFIG_USB_PXA_U2O_OTG */
+#endif  /* CONFIG_USB_EHCI_PXA_U2O */
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_HSIC
+static struct resource mmp3_hsic1_resources[] = {
+	/* reg base */
+	[0] = {
+		.start	= MMP3_HSIC1_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= MMP3_HSIC1_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= MMP3_HSIC1_PHYBASE,
+		.end	= MMP3_HSIC1_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_MMP3_USB_HS1,
+		.end	= IRQ_MMP3_USB_HS1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_hsic1_device = {
+	.name		= "mmp3-hsic",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+
+	.num_resources	= ARRAY_SIZE(mmp3_hsic1_resources),
+	.resource	= mmp3_hsic1_resources,
+};
+
+static struct resource mmp3_hsic2_resources[] = {
+	/* reg base */
+	[0] = {
+		.start  = MMP3_HSIC2_REGBASE + U2x_CAPREGS_OFFSET,
+		.end    = MMP3_HSIC2_REGBASE + USB_REG_RANGE,
+		.flags  = IORESOURCE_MEM,
+		.name   = "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start  = MMP3_HSIC2_PHYBASE,
+		.end    = MMP3_HSIC2_PHYBASE + USB_PHY_RANGE,
+		.flags  = IORESOURCE_MEM,
+		.name   = "phyregs",
+	},
+	[2] = {
+		.start  = IRQ_MMP3_USB_HS2,
+		.end    = IRQ_MMP3_USB_HS2,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_hsic2_device = {
+	.name           = "mmp3-hsic",
+	.id             = -1,
+	.dev            = {
+		.dma_mask               = &usb_dma_mask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+	},
+
+	.num_resources  = ARRAY_SIZE(mmp3_hsic2_resources),
+	.resource       = mmp3_hsic2_resources,
+};
+
+int mmp3_hsic_private_init(struct mv_op_regs *opregs, unsigned int phyregs)
+{
+	u32 hsic_int;
+	u32 status;
+	int count;
+
+	/*disable connect irq*/
+	hsic_int = __raw_readl(phyregs + HSIC_INT);
+	hsic_int &= ~HSIC_INT_CONNECT_INT_EN;
+	__raw_writel(hsic_int, phyregs + HSIC_INT);
+
+	/* enable port power and reserved bit 25 */
+	status = __raw_readl(&opregs->portsc[0]);
+	status |= (PORTSCX_PORT_POWER) | (1 << 25);
+	/* Clear bits 30:31 for HSIC to be enabled */
+	status &= ~(0x3 << 30);
+	__raw_writel(status, &opregs->portsc[0]);
+
+	/* test mode: force enable hs */
+	status = __raw_readl(&opregs->portsc[0]);
+	status &= ~(0xf << 16);
+	status |= (0x5 << 16);
+	__raw_writel(status, &opregs->portsc[0]);
+
+	/* disable test mode */
+	status = __raw_readl(&opregs->portsc[0]);
+	status &= ~(0xf << 16);
+	__raw_writel(status, &opregs->portsc[0]);
+
+	/* check HS ready */
+	count = 0x10000;
+	do {
+		hsic_int = __raw_readl(phyregs + HSIC_INT);
+		count--;
+	} while ((count >= 0)
+		&& !(hsic_int & (HSIC_INT_HS_READY | HSIC_INT_CONNECT)));
+	if (count <= 0) {
+		pr_err("HS_READY not set: hsic_int 0x%x\n", hsic_int);
+		return -EAGAIN;
+	}
+
+	/* issue port reset */
+	status = __raw_readl(&opregs->portsc[0]);
+	status |= PORTSCX_PORT_RESET;
+	__raw_writel(status, &opregs->portsc[0]);
+
+	/* check reset done */
+	count = 0x10000;
+	do {
+		status = __raw_readl(&opregs->portsc[0]);
+		count--;
+	} while ((count >= 0) && !(status & PORTSCX_PORT_RESET));
+	if (count <= 0) {
+		pr_err("port reset not done: portsc 0x%x\n", status);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+#endif  /* CONFIG_USB_EHCI_PXA_U2H_HSIC */
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_FSIC
+static struct resource mmp3_fsic_resources[] = {
+	/* reg base */
+	[0] = {
+		.start	= MMP3_FSIC_REGBASE + U2x_CAPREGS_OFFSET,
+		.end	= MMP3_FSIC_REGBASE + USB_REG_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= MMP3_FSIC_PHYBASE,
+		.end	= MMP3_FSIC_PHYBASE + USB_PHY_RANGE,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_MMP3_USB_FS,
+		.end	= IRQ_MMP3_USB_FS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_fsic_device = {
+	.name		= "mmp3-fsic",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &usb_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+
+	.num_resources	= ARRAY_SIZE(mmp3_fsic_resources),
+	.resource	= mmp3_fsic_resources,
+};
+
+
+#endif
+
+#endif  /* CONFIG_USB_EHCI_PXA */
+#endif  /* CONFIG_USB_SUPPORT */
+#ifdef CONFIG_UIO_VMETA
+/* vmeta soc specific functions */
+void vmeta_power_switch(unsigned int enable)
+{
+	unsigned int reg_vmpwr = 0;
+	unsigned int timeout;
+
+	reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+	if (VMETA_PWR_ENABLE == enable) {
+		if (reg_vmpwr & (APMU_VMETA_PWRUP_ON|APMU_VMETA_ISB))
+			return; /*Pwr is already on*/
+
+		/* 0. reset to boot default value, source to PLL1 */
+		writel(APMU_VMETA_CLK_RES_CTRL_DFT, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 1. Turn on power switches */
+		reg_vmpwr |= APMU_VMETA_PWRUP_SLOW_RAMP;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+		udelay(10);
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_PWRUP_ON;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+		udelay(10);
+
+		/* 2. disable isolation*/
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_ISB;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 3 Assert the redundancy repair signal */
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_REDUN_START;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+		timeout = 1000;
+		do {
+			if (--timeout == 0) {
+				WARN(1, "vmeta: REDUN_START timeout!\n");
+				return;
+			}
+			udelay(10);
+			reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		} while (reg_vmpwr & APMU_VMETA_REDUN_START);
+
+		/* 4 enable dummy clock to the SRAM*/
+		reg_vmpwr = readl(APMU_ISLD_VMETA_PDWN_CTRL);
+		reg_vmpwr |= APMU_ISLD_CMEM_DMMYCLK_EN;
+		writel(reg_vmpwr, APMU_ISLD_VMETA_PDWN_CTRL);
+		udelay(250);
+		reg_vmpwr = readl(APMU_ISLD_VMETA_PDWN_CTRL);
+		reg_vmpwr &= ~APMU_ISLD_CMEM_DMMYCLK_EN;
+		writel(reg_vmpwr, APMU_ISLD_VMETA_PDWN_CTRL);
+
+		/* 5. enable vMeta AXI clock */
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_AXICLK_EN;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 6. set up vMeta if required*/
+
+		/* 7. enable vMeta clock */
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_CLK_EN;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 8. deassert AXI reset*/
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_AXI_RST;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 9. deassert vMeta reset*/
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr |= APMU_VMETA_RST;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+		udelay(10);
+
+		/* 10. gate clock */
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr &= ~APMU_VMETA_CLK_EN;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr &= ~APMU_VMETA_AXICLK_EN;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+	} else if (VMETA_PWR_DISABLE == enable) {
+		if ((reg_vmpwr & (APMU_VMETA_PWRUP_ON|APMU_VMETA_ISB)) == 0)
+			return; /*Pwr is already off*/
+
+		/* 1. isolation */
+		reg_vmpwr &= ~APMU_VMETA_ISB;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 2. reset*/
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr &= ~(APMU_VMETA_AXI_RST | APMU_VMETA_RST);
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 3. make sure clock disabled*/
+		reg_vmpwr = readl(APMU_VMETA_CLK_RES_CTRL);
+		reg_vmpwr &= ~(APMU_VMETA_CLK_EN | APMU_VMETA_AXICLK_EN);
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+
+		/* 4. turn off power */
+		reg_vmpwr &= ~APMU_VMETA_PWRUP_ON;
+		writel(reg_vmpwr, APMU_VMETA_CLK_RES_CTRL);
+	}
+}
+
+static void mmp_vmeta_unset_op_constraint_work(struct work_struct *work)
+{
+	struct vmeta_instance *vi = container_of(work, struct vmeta_instance, unset_op_work.work);
+
+	vi->vop_real = VMETA_OP_INVALID;
+	pm_qos_update_request(&vi->qos_cpufreq_min, PM_QOS_DEFAULT_VALUE);
+#if	defined(CONFIG_DDR_DEVFREQ)
+	pm_qos_update_request(&vi->qos_ddrfreq_min, PM_QOS_DEFAULT_VALUE);
+#endif
+}
+
+int vmeta_init_constraint(struct vmeta_instance *vi)
+{
+	mutex_init(&vi->op_mutex);
+	INIT_DELAYED_WORK(&vi->unset_op_work, mmp_vmeta_unset_op_constraint_work);
+	pm_qos_add_request(&vi->qos_cpufreq_min, PM_QOS_CPUFREQ_MIN,
+			PM_QOS_DEFAULT_VALUE);
+#if	defined(CONFIG_DDR_DEVFREQ)
+	pm_qos_add_request(&vi->qos_ddrfreq_min, PM_QOS_DDR_DEVFREQ_MIN,
+		PM_QOS_DEFAULT_VALUE);
+#endif
+	return 0;
+}
+
+int vmeta_clean_constraint(struct vmeta_instance *vi)
+{
+	cancel_delayed_work_sync(&vi->unset_op_work);
+	pm_qos_remove_request(&vi->qos_cpufreq_min);
+#if	defined(CONFIG_DDR_DEVFREQ)
+	pm_qos_remove_request(&vi->qos_ddrfreq_min);
+#endif
+	printk(KERN_INFO "vmeta op clean up\n");
+
+	return 0;
+}
+
+int vmeta_freq_change(struct vmeta_instance *vi, int step)
+{
+	int vop = vi->vop + step;
+
+	if (vop > VMETA_OP_MIN && vop < VMETA_OP_MAX)
+		return vop;
+	else
+		return -1;
+}
+
+int vmeta_runtime_constraint(struct vmeta_instance *vi, int on)
+{
+	int vop = vi->vop;
+
+	mutex_lock(&vi->op_mutex);
+
+	if (on) {
+		cancel_delayed_work_sync(&vi->unset_op_work);
+		if (vop < VMETA_OP_MIN || vop > VMETA_OP_MAX) {
+			vop = VMETA_OP_1080P_MAX;
+		}
+		if (vop == vi->vop_real)
+			goto out;
+
+		if (vop >= VMETA_OP_VGA && vop <= VMETA_OP_VGA_MAX) {
+			printk(KERN_DEBUG "VGA!!!\n");
+			pm_qos_update_request(&vi->qos_cpufreq_min, 200);
+#ifdef CONFIG_DDR_DEVFREQ
+			pm_qos_update_request(&vi->qos_ddrfreq_min, DDR_CONSTRAINT_LVL0);
+#endif
+		} else if (vop >= VMETA_OP_720P && vop <= VMETA_OP_720P_MAX) {
+			printk(KERN_DEBUG "720P!!!\n");
+			pm_qos_update_request(&vi->qos_cpufreq_min, 200);
+#ifdef CONFIG_DDR_DEVFREQ
+			pm_qos_update_request(&vi->qos_ddrfreq_min, DDR_CONSTRAINT_LVL0);
+#endif
+		} else { /* 1080p and default ops */
+			printk(KERN_DEBUG "1080P!!!\n");
+			pm_qos_update_request(&vi->qos_cpufreq_min, 400);
+#ifdef CONFIG_DDR_DEVFREQ
+			pm_qos_update_request(&vi->qos_ddrfreq_min, DDR_CONSTRAINT_LVL1);
+#endif
+		}
+		vi->vop_real = vop;
+		printk(KERN_DEBUG "set dvfm vop_real=%d\n", vi->vop_real);
+	} else {
+		if (!vi->plat_data->power_down_ms)
+			vi->plat_data->power_down_ms = 100;
+		schedule_delayed_work(&vi->unset_op_work, msecs_to_jiffies(vi->plat_data->power_down_ms));
+	}
+
+out:
+	mutex_unlock(&vi->op_mutex);
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_MMP_ZSP
+
+struct zsp_pwr_opt {
+	u32 core_source;
+	u32 core_devider;
+};
+
+static struct zsp_pwr_opt
+	core_clock_matrix[MMP_ZSP_CORECLKSRC_NUMBER][MMP_ZSP_SPD_NUMBER] = {
+	{ /* use PMU*/
+		{ 0, 0},	/* fast, PLL1/2 ~400/1, 400MHz */
+		{ 0, 2},	/* medium,	PLL1/2 ~400/3, 133Mhz */
+		{ 3, 2},	/* slow,  PLL1/8 ~100/3, 33MHz */
+	},
+	{ /* use Audio PLL */
+		{ 0, 0},	/* fast, /1, ~271/295MHz */
+		{ 0, 1},	/* medium, /2, 133Mhz */
+		{ 0, 7},	/* slow, /8, ~33MHz */
+	},
+};
+
+
+#define __raw_modify(addr, toclear, toset)              \
+	do {                                            \
+		volatile unsigned int tval;             \
+		tval = __raw_readl(addr);               \
+		tval &= ~toclear;                       \
+		tval |= toset;                          \
+		__raw_writel(tval, (addr));             \
+		tval = __raw_readl(addr);               \
+		udelay(100);                            \
+	} while (0)
+
+
+static void mmp_zsp_domain_on(int spd, int src, int asclk)
+{
+	int value;
+	int timeout;
+
+	/* power on audio system */
+	if (aud_pwr_status.main_pwr_cnt == 0) {
+		value = __raw_readl(APMU_AUDIO_CLK_RES_CTRL);
+		value |= (0x1 << 9);
+		__raw_writel(value, APMU_AUDIO_CLK_RES_CTRL);
+		udelay(10);
+		value |= (0x1 << 10);
+		__raw_writel(value, APMU_AUDIO_CLK_RES_CTRL);
+		udelay(10);
+
+		/* SRAM redundency repair */
+		value |= 0x4;
+		__raw_writel(value, APMU_AUDIO_CLK_RES_CTRL);
+		timeout = 30000;
+		while (timeout--) {
+			value = __raw_readl(APMU_AUDIO_CLK_RES_CTRL);
+			if ((value & 0x4) == 0)
+				break;
+			udelay(10);
+		}
+		udelay(10);
+
+		/* enable SRAM SW ENA*/
+		value = __raw_readl(APMU_AUDIO_SRAM_PWR);
+		value |= 0x5;
+		__raw_writel(value, APMU_AUDIO_SRAM_PWR);
+		udelay(10);
+		value |= 0xA;
+		__raw_writel(value, APMU_AUDIO_SRAM_PWR);
+		udelay(10);
+
+		/* memory power management */
+		value = __raw_readl(APMU_ISLD_DSPA_CTRL);
+		value &= ~0x7;
+		__raw_writel(value, APMU_ISLD_DSPA_CTRL);
+		udelay(10);
+		/* enable dummy clocks for SRAMs */
+		value = __raw_readl(APMU_ISLD_DSPA_CTRL);
+		value |= (0x1 << 4);
+		__raw_writel(value, APMU_ISLD_DSPA_CTRL);
+		udelay(300);
+		value = __raw_readl(APMU_ISLD_DSPA_CTRL);
+		value &= ~(0x1 << 4);
+		__raw_writel(value, APMU_ISLD_DSPA_CTRL);
+		udelay(10);
+
+		/* clear reset for axi and apb clocks */
+		value = readl(APMU_AUDIO_DSA);
+		value |= 0xA;
+		__raw_writel(value, APMU_AUDIO_DSA);
+		udelay(100);
+		value |= 0x5;
+		__raw_writel(value, APMU_AUDIO_DSA);
+		udelay(10);
+
+		/* release for reset */
+		value = __raw_readl(APMU_AUDIO_CLK_RES_CTRL);
+		value |= 0x12;
+		__raw_writel(value, APMU_AUDIO_CLK_RES_CTRL);
+		udelay(10);
+		/* release for isolation */
+		value |= 0x1 << 8;
+		__raw_writel(value, APMU_AUDIO_CLK_RES_CTRL);
+		udelay(100);
+	}
+	aud_pwr_status.main_pwr_cnt++;
+
+	if (aud_pwr_status.aud_dev_cnt == 0) {
+		/* SSPA1 BIT/SYSCLK */
+		/* Audio PLL is used here, no need external clock*/
+		/*_raw_writel(0xd3ee2276, MPMU_ISCCRX0);
+		__raw_writel(0xd0040040, MPMU_ISCCRX1);
+		udelay(10);
+		__raw_modify(MPMU_CCGR, 0, 0x20);*/
+	}
+	aud_pwr_status.aud_dev_cnt++;
+
+	if (aud_pwr_status.aud_pll_cnt == 0) {
+		__raw_writel(0x908A1898, SSPA_AUD_PLL_CTRL0);
+		udelay(100);
+		/* select OCLK, Slow audio PLL */
+		/*__raw_writel(0x2E000001, SSPA_AUD_PLL_CTRL1);*/
+		/* select fast audiio PLL */
+		__raw_writel(0xAF000001, SSPA_AUD_PLL_CTRL1);
+		udelay(100);
+		 __raw_writel(0x908A1899, SSPA_AUD_PLL_CTRL0);
+		udelay(100);
+
+		/* sspa_aud_pll_ctrl1[11] = 1 to choose audio PLL */
+		__raw_modify(SSPA_AUD_PLL_CTRL1, 0x0, 0x800);
+	}
+	aud_pwr_status.aud_pll_cnt++;
+
+	__raw_modify(ZSP_AUD_DSA_CORE_CLK_RES, 0x0, 0x4);
+	udelay(100);
+	/* switch to audio PLL, divide 1*/
+	__raw_modify(ZSP_AUD_DSA_CORE_CLK_RES, 0x0, 0x30);
+	__raw_modify(ZSP_AUD_CORE_FREQ_CHG, 0xE, 0x0);
+	/* enable divider*/
+	__raw_modify(ZSP_AUD_DSA_CORE_CLK_RES, 0x0, 0x8);
+	/* enabled core clock and release reset*/
+	__raw_modify(ZSP_AUD_DSA_CORE_CLK_RES, 0x4, 0x0);
+	udelay(10);
+	__raw_modify(ZSP_AUD_CORE_FREQ_CHG, 0x0, 0x1);
+	udelay(10);
+	do {
+		value = readl(ZSP_AUD_CORE_FREQ_CHG);
+		udelay(10);
+	} while ((value & 0x1) != 0);
+	__raw_modify(ZSP_AUD_DSA_CORE_CLK_RES, 0x0, 0x3);
+
+	/* timer clock, src Audio PLL, div 12 */
+	__raw_modify(ZSP_AUD_TIM_13M_CLK_RES, 0x0, 0x64);
+	udelay(10);
+	/* enable and release reset*/
+	__raw_modify(ZSP_AUD_TIM_13M_CLK_RES, 0x0, 0x3);
+
+	/* set SSPA to fast audio PLL with M/N divider */
+	__raw_modify(ZSP_AUD_SSP_CLK_RES, 0x0, 0x30000);
+	__raw_modify(ZSP_AUD_SLIM_CLK_RES, 0xFFFFFFFF, 0x00100100);
+	__raw_modify(ZSP_AUD_SLIM_CLK_RES_2, 0x3FFFFFFF, 0xC0040008);
+	__raw_modify(ZSP_AUD_SLIM_CLK_RES, 0x0, 0xE);
+
+	/* config ZSP core peripherals */
+	__raw_modify(ZSP_AUD_CTRL_REG, 0xFFFFFFF, 0x141B05);
+	udelay(100);
+	__raw_modify(ZSP_AUD_CTRL_REG, 0x0, 0x18);
+	udelay(10);
+	aud_pwr_status.zsp_cnt++;
+
+	return;
+}
+
+static void mmp_zsp_domain_halt(void)
+{
+	if (aud_pwr_status.zsp_cnt > 0) {
+		aud_pwr_status.zsp_cnt--;
+	}
+
+	if (aud_pwr_status.aud_dev_cnt > 0)
+		aud_pwr_status.aud_dev_cnt--;
+
+	if (aud_pwr_status.aud_pll_cnt > 0) {
+		aud_pwr_status.aud_pll_cnt--;
+	}
+	if (aud_pwr_status.main_pwr_cnt > 0) {
+		aud_pwr_status.main_pwr_cnt--;
+		if (aud_pwr_status.main_pwr_cnt == 0) {
+			/* enable isolation */
+			__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x100, 0);
+			/* assert AXI and peripheral reset */
+			__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x3, 0);
+			/* gate axi and peripheral clock */
+			__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x18, 0);
+
+			__raw_modify(APMU_AUDIO_DSA, 0xF, 0x0);
+			__raw_modify(APMU_AUDIO_SRAM_PWR, 0xF, 0x0);
+
+			/* power off */
+			__raw_modify(APMU_AUDIO_CLK_RES_CTRL, 0x600, 0);
+
+			aud_pwr_status.aud_dev_cnt = 0;
+			aud_pwr_status.zsp_cnt = 0;
+			aud_pwr_status.aud_pll_cnt = 0;
+		}
+	}
+
+	return;
+}
+
+static void mmp_zsp_start_core(void)
+{
+	int value;
+
+	writel(0x0000, ZSP_AUD_CTRL_REG_2);
+	udelay(5);
+
+	value = readl(ZSP_AUD_CTRL_REG);
+	value &= ~0x2;
+	writel(value, ZSP_AUD_CTRL_REG);
+	udelay(100);
+
+	/* release reset */
+	value = readl(ZSP_AUD_CTRL_REG);
+	value |= 0x2;
+	writel(value, ZSP_AUD_CTRL_REG);
+	udelay(10);
+
+}
+
+static struct mmp_zsp_platform_device mmp_zsp_op = {
+	.clkcfg = {
+		.spd	= MMP_ZSP_SPD_PERFORMACE,
+		.src	= MMP_ZSP_CORECLKSRC_AUDIOPLL,
+		.asclk	= MMP_ZSP_ASCLK_22579200,
+	},
+	.sram_size = MMP_AUDIO_RAM_SIZE,
+	.domain_halt	= mmp_zsp_domain_halt,
+	.domain_on	= mmp_zsp_domain_on,
+	.start_core	= mmp_zsp_start_core,
+	.hw_memcpy = NULL,
+};
+static struct resource mmp_zsp_resources[] = {
+	/* reg base */
+	[0] = {
+		.start	= 0xC0140000,
+		.end	= 0xC014FFFF,
+		.flags	= IORESOURCE_MEM,
+		.name	= "audio-device",
+	},
+	/* ZSP IPC base */
+	[1] = {
+		.start	= 0xC0160000,
+		.end	= 0xC016FFFF,
+		.flags	= IORESOURCE_MEM,
+		.name	= "audio-ipc1",
+	},
+	/* ZSP iTCM window */
+	[2] = {
+		.start	= 0xC6100000,
+		.end	= 0xC611FFFF,
+		.flags	= IORESOURCE_MEM,
+		.name	= "audio-itcm",
+	},
+	/* ZSP dTCM window */
+	[3] = {
+		.start	= 0xC6080000,
+		.end	= 0xC609FFFF,
+		.flags	= IORESOURCE_MEM,
+		.name	= "audio-dtcm",
+	},
+	/* Audio IPC IRQ*/
+	[4] = {
+		.start	= IRQ_MMP3_DSP_AUDIO_7,
+		.end	= IRQ_MMP3_DSP_AUDIO_7,
+		.flags	= IORESOURCE_IRQ,
+		.name	= "audio-irq",
+	},
+};
+static u64 mmp_zsp_dmamask = DMA_BIT_MASK(32);
+static struct platform_device mmp_zsp_device = {
+	.name		= "mmp-zsp",
+	.id		= -1,
+	.dev		= {
+		.dma_mask		= &mmp_zsp_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources	= ARRAY_SIZE(mmp_zsp_resources),
+	.resource	= mmp_zsp_resources,
+};
+void mmp_zsp_platform_device_init(void)
+{
+	struct platform_device *pdev = &mmp_zsp_device;
+	int ret;
+
+	if (cpu_is_mmp3()) {
+
+		ret = platform_device_add_data(pdev, &mmp_zsp_op,
+			sizeof(mmp_zsp_op));
+		if (ret) {
+			printk(KERN_ERR "zsp_device_init fail: %d\n", ret);
+			return;
+		}
+		platform_device_register(pdev);
+		printk(KERN_INFO "ZSP device registered\n");
+	} else {
+		printk(KERN_INFO "ZSP device does not exist\n");
+	}
+}
+#endif
+
+#define GC2D_CLK_DIV(n)		((n & 0xF) << 28)
+#define GC2D_CLK_DIV_MSK	GC2D_CLK_DIV(0xF)
+#define GC2D_CLK_SRC_SEL(n)	((n & 3) << 12)
+#define GC2D_CLK_SRC_SEL_MSK	GC2D_CLK_SRC_SEL(3)
+#define GC2D_AXICLK_EN		(1u << 19)
+#define GC2D_AXI_RST_N		(1u << 18)
+
+#define GC3D_CLK_DIV(n)		((n & 0xF) << 24)
+#define GC3D_CLK_DIV_MSK	GC3D_CLK_DIV(0xF)
+#define GC3D_CLK_SRC_SEL(n)	((n & 3) << 6)
+#define GC3D_CLK_SRC_SEL_MSK	GC3D_CLK_SRC_SEL(3)
+#define GC3D_ACLK_SEL(n)	((n & 3) << 4)
+#define GC3D_ACLK_SEL_MSK	GC3D_ACLK_SEL(3)
+#define GC3D_AXICLK_EN		(1u << 2)
+#define GC3D_AXI_RST_N		(1u << 0)
+
+#define GC2D3D_CLK_EN		(1u << 3)
+#define GC2D_CLK_EN		(1u << 20)
+#define GC2D3D_RST_N		(1u << 1)
+
+#define GC_PWRUP(n)		((n & 3) << 9)
+#define GC_PWRUP_MSK		GC_PWRUP(3)
+#define GC_ISB			(1u << 8)
+
+#define GC_CLK_RATE(div, src, aclk)				\
+	(GC2D_CLK_DIV(div) | GC2D_CLK_SRC_SEL(src)		\
+	| GC3D_CLK_DIV(div) | GC3D_CLK_SRC_SEL(src)		\
+	| GC3D_ACLK_SEL(aclk))
+
+#define GC_CLK_RATE_MSK						\
+	(GC2D_CLK_DIV_MSK | GC2D_CLK_SRC_SEL_MSK		\
+	| GC3D_CLK_DIV_MSK | GC3D_CLK_SRC_SEL_MSK		\
+	| GC3D_ACLK_SEL_MSK)
+
+#define GC_CLKRST_BOOT_DEFAULT GC_CLK_RATE(3, 0, 0)
+/*
+	1. Since CCIC is moved to ISPDMA power island on B0 board,
+	need additional power enabling to access CCIC
+	2.DXO and smart sensor will conflict that share this
+	PMUA_ISP_PWR_CTRL.So if one of any sensor is poweron,
+	we all can't poweroff ISP.
+*/
+#ifdef CONFIG_VIDEO_MVISP
+static u64 mmp3_dxo_dma_mask = DMA_BIT_MASK(32);
+
+static struct resource mmp3_dxoisp_resources[] = {
+	[0] = {
+		.start = 0xD4215000,
+		.end   = 0xD4215D0B,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = 0xF0200000,
+		.end   = 0xF023FFFF,
+		.flags = IORESOURCE_MEM,
+	},
+	[2] = {
+		.start = IRQ_MMP3_ISP_DMA,
+		.end   = IRQ_MMP3_ISP_DMA,
+		.flags = IORESOURCE_IRQ,
+	},
+	[3] = {
+		.start = IRQ_MMP3_DXO_ISP,
+		.end   = IRQ_MMP3_DXO_ISP,
+		.flags = IORESOURCE_IRQ,
+	},
+	[4] = {
+		.start = IRQ_MMP3_CCIC1,
+		.end   = IRQ_MMP3_CCIC1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device mmp3_device_dxoisp = {
+	.name           = "mmp3-mvisp",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &mmp3_dxo_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+	.resource       = mmp3_dxoisp_resources,
+	.num_resources  = ARRAY_SIZE(mmp3_dxoisp_resources),
+};
+
+void __init mmp3_register_dxoisp(struct mvisp_platform_data *pdata)
+{
+	int ret;
+
+	mmp3_device_dxoisp.dev.platform_data = pdata;
+
+	ret = platform_device_register(&mmp3_device_dxoisp);
+	if (ret)
+		dev_err(&(mmp3_device_dxoisp.dev),
+			"unable to register dxo device: %d\n", ret);
+}
+#endif
+
+static atomic_t isppwr_count;
+int isppwr_power_control(int on)
+{
+	int reg;
+	unsigned char count = ISP_POLL_COUNT;
+
+	if (on) {
+		if (0 == atomic_read(&isppwr_count)) {
+			/*set ISP regs to the default value*/
+			writel(0, APMU_ISPCLK);
+			writel(0, APMU_ISPPWR);
+
+			/*1. turn on the power switch*/
+			reg = readl(APMU_ISPPWR);
+			reg |= 0x1 << 9;
+			writel(reg, APMU_ISPPWR);
+			udelay(10);
+			reg |= 0x3 << 9;
+			writel(reg, APMU_ISPPWR);
+			udelay(10);
+
+			/*2. disable isp isolation*/
+			reg |= 0x1 << 8;
+			writel(reg, APMU_ISPPWR);
+
+			/*3. start memory redundacy repair*/
+			reg = readl(APMU_ISPCLK);
+			reg |= 0x1 << 2;
+			writel(reg, APMU_ISPCLK);
+			udelay(10);
+			while ((readl(APMU_ISPCLK) & (0x1 << 2)) && count--)
+				udelay(5);
+			if (readl(APMU_ISPCLK) & (0x1 << 2))
+				printk(KERN_ERR "dxoisp err in memory redundacy repair\n");
+
+			/*4. enable dummy clocks to the SRAMS*/
+			reg = readl(APMU_ISLD_CI_CTRL);
+			reg |= 0x1 << 4;
+			writel(reg, APMU_ISLD_CI_CTRL);
+			udelay(250);
+			reg &= ~(0x1 << 4);
+			writel(reg, APMU_ISLD_CI_CTRL);
+
+			/*5. enable clks*/
+			/*enable ISP AXI clock*/
+			reg = readl(APMU_ISPCLK);
+			reg |= 0x1 << 3;
+			writel(reg, APMU_ISPCLK);
+			/*clock source and clock divider */
+			reg &= ~0xF00;
+			reg |= 0x2 << 8;
+			writel(reg, APMU_ISPCLK);
+			reg &= ~0xC0;
+			reg |= 0x1 << 6;
+			writel(reg, APMU_ISPCLK);
+			/*enable ISP clk*/
+			reg |= 0x1 << 4;
+			writel(reg, APMU_ISPCLK);
+			/*enable CCIC1 AXI Arbiter clock*/
+			reg = readl(APMU_CCIC_RST);
+			reg |= 0x1 << 15;
+			writel(reg, APMU_CCIC_RST);
+
+			/*6. de-asset*/
+			/*De-Assert ISP AXI reset*/
+			reg = readl(APMU_ISPCLK);
+			reg |= 0x1 << 0;
+			writel(reg, APMU_ISPCLK);
+			/*De-Assert ISP software reset*/
+			reg |= 0x1 << 1;
+			writel(reg, APMU_ISPCLK);
+			/*De-Assert CCIC1 AXI Arbiter reset*/
+			reg = readl(APMU_CCIC_RST);
+			reg |= 0x1 << 16;
+			writel(reg, APMU_CCIC_RST);
+
+			/*7. gate clk*/
+			/*disable ccic1 AXI Arbiter Clock*/
+			reg = readl(APMU_CCIC_RST);
+			reg &= ~(0x1 << 15);
+			writel(reg, APMU_CCIC_RST);
+			/*Disable ISP AXI clock*/
+			reg = readl(APMU_ISPCLK);
+			reg &= ~(0x1 << 4);
+			writel(reg, APMU_ISPCLK);
+			/*Disable ISP clock*/
+			reg &= ~(0x1 << 3);
+			writel(reg, APMU_ISPCLK);
+		}
+
+		if (atomic_inc_return(&isppwr_count) < 1) {
+			printk(KERN_ERR "isp power on err\n");
+			return -EINVAL;
+		}
+	} else {
+		if( 1 == atomic_read(&isppwr_count)) {
+			/*enable clk for reset*/
+			reg = readl(APMU_ISPCLK);
+			reg |= 0x1 << 3;
+			writel(reg, APMU_ISPCLK);
+			reg |= 0x1 << 4;
+			writel(reg, APMU_ISPCLK);
+			reg = readl(APMU_CCIC_RST);
+			reg |= 0x1 << 15;
+			writel(reg, APMU_CCIC_RST);
+
+			/*start to power down ISP*/
+			/*1. enable isp isolation*/
+			reg = readl(APMU_ISPPWR);
+			reg &= ~(0x1 << 8);
+			writel(reg, APMU_ISPPWR);
+
+			/*2. assert*/
+			reg = readl(APMU_CCIC_RST);
+			reg &= ~(0x1 << 16);
+			writel(reg, APMU_CCIC_RST);
+			reg = readl(APMU_ISPCLK);
+			reg &= ~(0x1 << 0);
+			writel(reg, APMU_ISPCLK);
+			reg &= ~(0x1 << 1);
+			writel(reg, APMU_ISPCLK);
+
+			/*3. gate clk*/
+			reg = readl(APMU_CCIC_RST);
+			reg &= ~(0x1 << 15);
+			writel(reg, APMU_CCIC_RST);
+			reg = readl(APMU_ISPCLK);
+			reg &= ~(0x1 << 4);
+			writel(reg, APMU_ISPCLK);
+			reg &= ~(0x1 << 3);
+			writel(reg, APMU_ISPCLK);
+
+			/*4. turn off the power switch*/
+			reg = readl(APMU_ISPPWR);
+			reg &= ~(0x3 << 9);
+			writel(reg, APMU_ISPPWR);
+
+			atomic_set(&isppwr_count, 0);
+		} else if(atomic_dec_return(&isppwr_count) < 0) {
+			printk(KERN_ERR "isp power off err\n");
+			return -EINVAL;
+		}
+	}
+	return 0;
+}
+
+void gc_pwr(int power_on)
+{
+	unsigned long regval;
+	regval = __raw_readl(APMU_GC_CLK_RES_CTRL);
+	pr_err("apmu gc clk register value:%x !!!\n", regval);
+	if (power_on) {
+		//if (regval & (GC_PWRUP_MSK | GC_ISB))
+		if (regval &  GC_ISB)
+			return; /*Pwr is already on*/
+
+		pr_err("gc_pwr turning it on...\n");
+		/* 0, set to boot default value, source on PLL1*/
+		writel(GC_CLKRST_BOOT_DEFAULT, APMU_GC_CLK_RES_CTRL);
+
+		/* 1. Turn on power switches */
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval &= ~GC_PWRUP_MSK;
+		regval |= GC_PWRUP(1);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+		udelay(10);
+		regval |= GC_PWRUP(3);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+		udelay(10);
+
+		/* 2. disable isolation*/
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval |= GC_ISB;
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 3. enable SRAM dummy clock*/
+
+		regval = readl(APMU_ISLD_GC2000_PDWN_CTRL);
+		regval |= APMU_ISLD_CMEM_DMMYCLK_EN;
+		writel(regval, APMU_ISLD_GC2000_PDWN_CTRL);
+		udelay(250);
+		regval = readl(APMU_ISLD_GC2000_PDWN_CTRL);
+		regval &= ~APMU_ISLD_CMEM_DMMYCLK_EN;
+		writel(regval, APMU_ISLD_GC2000_PDWN_CTRL);
+
+		/* 4. enable AXI clocks*/
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval |= (GC3D_AXICLK_EN | GC2D_AXICLK_EN);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 5. change source if necessary*/
+
+		/* 6. enable GC clock */
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval |= GC2D3D_CLK_EN | GC2D_CLK_EN;
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 7. deassert resets*/
+		/* GC300 requires AXI reset first, not align with B0 datasheet*/
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval |= GC2D3D_RST_N;
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+		udelay(100);
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval |= (GC2D_AXI_RST_N | GC3D_AXI_RST_N);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 8 gate clock */
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval &= ~(GC2D_AXICLK_EN | GC3D_AXICLK_EN | GC2D3D_CLK_EN
+				| GC2D_CLK_EN);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+	} else {
+		//if ((regval & (GC_PWRUP_MSK | GC_ISB)) == 0)
+		if ((regval &  GC_ISB) == 0)
+			return; /*Pwr is already off*/
+
+		pr_err("gc_pwr turning it off...\n");
+		/* 1. isolation */
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval &= ~GC_ISB;
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 2. reset*/
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval &= ~(GC2D_AXI_RST_N | GC3D_AXI_RST_N | GC2D3D_RST_N);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+		/* 3. make sure clock disabled*/
+		regval = readl(APMU_GC_CLK_RES_CTRL);
+		regval &= ~(GC2D_AXICLK_EN | GC3D_AXICLK_EN | GC2D3D_CLK_EN | GC2D_CLK_EN);
+		writel(regval, APMU_GC_CLK_RES_CTRL);
+
+	}
+}
+EXPORT_SYMBOL_GPL(gc_pwr);
+
+#ifdef CONFIG_MMP3_THERMAL
+extern unsigned long read_temperature_sensor(int index);
+static int
+thermal_check(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	printk(KERN_ERR "Current Temp0: %ld Temp1: %ld Temp2 %ld\n\n",
+			read_temperature_sensor(0),
+			read_temperature_sensor(1),
+			read_temperature_sensor(2));
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_thermal_check = {
+	.notifier_call = thermal_check,
+};
+
+static int __init panic_notifier(void)
+{
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_thermal_check);
+	return 0;
+}
+
+core_initcall(panic_notifier);
+#endif
+
+static int __init use_wtm_get_fuse_profile()
+{
+	wtm_setup_remap();
+	wtm_read_profile();
+	mdelay(10);
+	mmp_plat_ref_clk = wtm_read_platform_config();
+	wtm_dump_info();
+}
+
+core_initcall(use_wtm_get_fuse_profile);
+
+
+static int __init parse_tag_profile(const struct tag *tag)
+{
+	mmp_soc_stepping = tag->u.mv_prof.soc_stepping;
+	mmp_soc_profile = tag->u.mv_prof.soc_prof;
+	if (mmp_soc_profile > 9 || mmp_soc_profile < 0)
+		mmp_soc_profile = 0;
+	return 0;
+}
+__tagtable(ATAG_PROFILE, parse_tag_profile);
diff --git a/arch/arm/mach-mmp/mmp3_coherent_fix.S b/arch/arm/mach-mmp/mmp3_coherent_fix.S
new file mode 100644
index 0000000..a0ca596
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp3_coherent_fix.S
@@ -0,0 +1,620 @@
+/*
+ *  linux/arch/arm/mach-mmp/mmp3_coherent_fix.S
+ *
+ *  Copyright (C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+#include <asm/assembler.h>
+#include <asm/unwind.h>
+
+/*
+ * sync region definition:
+ *
+ * +---------------------+
+ * | COHT_STATE_0        | -> offset 0x0
+ * +---------------------+
+ * | COHT_STATE_1        | -> offset 0x4
+ * +---------------------+
+ * | HS_REQ_0            | -> offset 0x8
+ * +---------------------+
+ * | HS_REQ_1            | -> offset 0xc
+ * +---------------------+
+ * | ...                 |
+ * +---------------------+
+ * | SEM4                | -> offset 0x20
+ * +---------------------+
+ * | ...                 |
+ * +---------------------+
+ * | MP1_C1_CFG          | -> offset 0x100
+ * +---------------------+
+ * | MP1_C2_CFG          | -> offset 0x104
+ * +---------------------+
+ * | MP2_C1_CFG          | -> offset 0x108
+ * +---------------------+
+ * | MP2_C2_CFG          | -> offset 0x10c
+ * +---------------------+
+ * | MM_C1_CFG           | -> offset 0x110
+ * +---------------------+
+ * | MM_C2_CFG           | -> offset 0x114
+ * +---------------------+
+ * | CM_CID_OFFSET       | -> offset 0x118
+ * +---------------------+
+ * | ...                 |
+ * +---------------------+
+ * | INT_STATUS_ADDR     | -> offset 0x200
+ * +---------------------+
+ * | WAKE_STATUS_ADDR    | -> offset 0x204
+ * +---------------------+
+ * | SGIR_ADDR           | -> offset 0x208
+ * +---------------------+
+ * | APMU_BASE_ADDR      | -> offset 0x20c
+ * +---------------------+
+ *
+ */
+
+#define MP1_COHT_STATE_OFFSET	0x0
+#define MP2_COHT_STATE_OFFSET	0x4
+#define MP1_HANDSHAKE_OFFSET	0x8
+#define MP2_HANDSHAKE_OFFSET	0xc
+
+#define SEM4_OFFSET		0x20
+
+#define MP1_C1_CFG_OFFSET	0x100
+#define MP1_C2_CFG_OFFSET	0x104
+#define MP2_C1_CFG_OFFSET	0x108
+#define MP2_C2_CFG_OFFSET	0x10c
+#define MM_C1_CFG_OFFSET	0x110
+#define MM_C2_CFG_OFFSET	0x114
+#define CM_CID_OFFSET		0x118
+
+#define INT_STATUS_ADDR_OFFSET	0x200
+#define WAKE_STATUS_ADDR_OFFSET	0x204
+#define SGIR_ADDR_OFFSET	0x208
+#define APMU_BASE_ADDR_OFFSET	0x20c
+
+#define APMU_PJ_C0_CC4		0x0248
+#define APMU_PJ_C1_CC4		0x024C
+#define APMU_PJ_C2_CC4		0x0250
+#define APMU_PJ_IDLE_CFG0	0x0018
+#define APMU_PJ_IDLE_CFG1	0x0200
+#define APMU_PJ_IDLE_CFG2	0x0204
+
+#define CC_OFFSET		0x300
+#define CC_ADDR_OFFSET		0x304
+#define CC2_OFFSET		0x308
+#define CC2_ADDR_OFFSET		0x30c
+#define CC3_OFFSET		0x310
+#define CC3_ADDR_OFFSET		0x314
+#define BUS_OFFSET		0x318
+#define BUS_ADDR_OFFSET		0x31c
+#define FCCR_OFFSET		0x320
+#define FCCR_ADDR_OFFSET	0x324
+
+#define DDR_FREQ_CHG_REQ2	(1 << 22)
+#define DDR_FREQ_CHG_REQ1	(1 << 25)
+#define AXI_FREQ_CHG_REQ	(1 << 26)
+#define PJ_FREQ_CHG_REQ		(1 << 24)
+
+#define DDR_FREQ_CHG_DONE2	(1 << 12)
+#define DDR_FREQ_CHG_DONE1	(1 << 4)
+#define AXI_FREQ_CHG_DONE	(1 << 5)
+#define PJ_FREQ_CHG_DONE	(1 << 3)
+
+/*
+ * registers used in the workaround flow.
+ */
+try	.req	r5		@ lock try value
+dfc	.req	r7		@ dfc trigger value
+ncb	.req	r9		@ non-cache buffer address
+cid	.req	r10		@ core id number
+pmu	.req	r11		@ APMU register address
+
+	.macro invalid_and_flush_l1_cache, rtemp
+	mov	\rtemp, #0x0
+	mcr	p15, 0, \rtemp, c8, c5, 0	@ instruction tlb
+	mcr	p15, 0, \rtemp, c8, c6, 0	@ data tlb
+	mcr	p15, 0, \rtemp, c8, c7, 0	@ unified tlb
+
+	mcr	p15, 0, \rtemp, c7, c5, 0	@ invalid I cache
+	mcr	p15, 0, \rtemp, c7, c5, 6	@ invalid branch predictor array
+	mcr	p15, 0, \rtemp, c7, c5, 4	@ instruction barrier
+	mcr	p15, 0, \rtemp, c7, c14, 0	@ flush entire d cache
+	mcr	p15, 0, \rtemp, c7, c5, 4	@ flush prefetch buffer
+	isb
+	dsb
+	.endm
+
+	.macro get_coht_val, rstate
+	cmp	cid, #0x0
+	moveq	\rstate, #MP1_COHT_STATE_OFFSET
+	movne	\rstate, #MP2_COHT_STATE_OFFSET
+	ldr	\rstate, [ncb, \rstate]
+	.endm
+
+	.macro set_coht_val, rstate, temp
+	cmp	cid, #0x0
+	moveq	\temp, #MP1_COHT_STATE_OFFSET
+	movne	\temp, #MP2_COHT_STATE_OFFSET
+	str	\rstate, [ncb, \temp]
+	.endm
+
+	.macro get_hs_val, rstate
+	cmp	cid, #0x0
+	moveq	\rstate, #MP1_HANDSHAKE_OFFSET
+	movne	\rstate, #MP2_HANDSHAKE_OFFSET
+	ldr	\rstate, [ncb, \rstate]
+	.endm
+
+	.macro set_hs_val, rstate, temp
+	cmp	cid, #0x0
+	moveq	\temp, #MP1_HANDSHAKE_OFFSET
+	movne	\temp, #MP2_HANDSHAKE_OFFSET
+	str	\rstate, [ncb, \temp]
+	.endm
+
+	.macro get_peer_core_coht_val, rstate
+	cmp	cid, #0x0
+	movne	\rstate, #MP1_COHT_STATE_OFFSET
+	moveq	\rstate, #MP2_COHT_STATE_OFFSET
+	ldr	\rstate, [ncb, \rstate]
+	.endm
+
+	.macro get_peer_core_hs_val, rstate
+	cmp	cid, #0x0
+	movne	\rstate, #MP1_HANDSHAKE_OFFSET
+	moveq	\rstate, #MP2_HANDSHAKE_OFFSET
+	ldr	\rstate, [ncb, \rstate]
+	.endm
+
+	.macro set_amp, temp
+	mrc	p15, 0, \temp, c1, c0, 1
+	bic	\temp, \temp, #(1 << 6) | (1 << 0)	@ Disable SMP/nAMP mode and
+	mcr	p15, 0, \temp, c1, c0, 1	@ TLB ops broadcasting
+	isb
+	dsb
+	.endm
+
+	.macro set_smp, temp
+	mrc	p15, 0, \temp, c1, c0, 1
+	orr	\temp, \temp, #(1 << 6) | (1 << 0)	@ Enable SMP/nAMP mode and
+	mcr	p15, 0, \temp, c1, c0, 1	@ TLB ops broadcasting
+	isb
+	dsb
+	.endm
+
+	.macro disable_fw, temp
+	mrc	p15, 0, \temp, c1, c0, 1
+	bic	\temp, \temp, #(1 << 0)		@ Disable TLB ops broadcasting
+	mcr	p15, 0, \temp, c1, c0, 1
+	isb
+	dsb
+	.endm
+
+	.macro enable_fw, temp
+	mrc	p15, 0, \temp, c1, c0, 1
+	orr	\temp, \temp, #(1 << 0)		@ Enable TLB ops broadcasting
+	mcr	p15, 0, \temp, c1, c0, 1
+	.endm
+
+	@ exclusive try lock
+	.macro  coht_trylock, temp1, temp2, rtry
+	mov	\temp1, #SEM4_OFFSET
+	add	\temp1, \temp1, ncb
+	mov	\temp2, #1
+
+	ldrex	\rtry, [\temp1]
+	cmp	\rtry, #0			@ unlocked
+	strexeq	\rtry, \temp2, [\temp1]
+	.endm
+
+	@ exclusive lock
+	.macro  coht_lock, temp1, temp2, temp3
+	mov	\temp1, #SEM4_OFFSET
+	add	\temp1, \temp1, ncb
+	mov	\temp3, #1
+1:
+	ldrex	\temp2, [\temp1]
+	cmp	\temp2, #0			@ unlocked
+	strexeq	\temp2, \temp3, [\temp1]
+	cmpeq   \temp2, #0
+	bne     1b
+	.endm
+
+	@ exclusive unlock
+	.macro  coht_unlock, temp1, temp2, temp3
+	mov	\temp1, #SEM4_OFFSET
+	add	\temp1, \temp1, ncb
+	mov	\temp3, #0
+2:
+	ldrex	\temp2, [\temp1]
+	strex	\temp2, \temp3, [\temp1]
+	cmp	\temp2, #0
+	bne	2b
+	.endm
+
+	.macro	get_cid, rcid
+	mrc	p15, 0, \rcid, c0, c0, 5	@ read core id
+	and	\rcid, \rcid, #0xf
+	.endm
+
+ENTRY(req_peer_core_dis_fw)
+	get_peer_core_coht_val r4
+	cmp	r4, #0x0
+	beq	dis_fw_done
+
+	ldr	r1, [ncb, #SGIR_ADDR_OFFSET]
+	cmp	cid, #0x0
+	moveq	r0, #0x2		@ sgi for mp2
+	movne	r0, #0x1		@ sgi for mp1
+	lsl	r0, r0, #0x10		@ left shift 16 bits
+	orr	r0, r0, #0x8		@ irq number is 8
+	str	r0, [r1]		@ send ipi
+wait_hs:
+	get_peer_core_coht_val r0
+	cmp	r0, #0x0
+	bne	wait_hs
+
+dis_fw_done:
+	mov	pc, lr
+ENDPROC(req_peer_core_dis_fw)
+
+ENTRY(req_peer_core_en_fw)
+	cmp	r4, #0x0
+	beq	en_fw_done
+wait_en_hs:
+	get_peer_core_coht_val r0
+	cmp	r0, #0x1
+	bne	wait_en_hs
+
+en_fw_done:
+	mov	pc, lr
+ENDPROC(req_peer_core_en_fw)
+
+ENTRY(mmp3_flush_l1_cache)
+	stmfd	sp!, {r0-r11, lr}
+
+	invalid_and_flush_l1_cache	r0
+
+	ldmfd	sp!, {r0-r11, lr}
+	mov	pc, lr
+ENDPROC(mmp3_flush_l1_cache)
+
+/*
+ * mmp3_trigger_dfc_ll_b0p()
+ *
+ * low level function for triggerring DFC; should forbid any snooping
+ * operation during DFC, so need set the core to AMP mode and do not
+ * access any data which stored in cache.
+ *
+ * r0 = dfc value
+ * r1 = noncache buffer base address
+ *
+ */
+ENTRY(mmp3_trigger_dfc_ll_b0p)
+	stmfd	sp!, {r4-r5, r7, r9-r11, lr}
+
+	mov	dfc, r0			@ save dfc value
+	mov	ncb, r1			@ save base addr
+	get_cid cid			@ read core id
+	ldr	pmu, [ncb, #APMU_BASE_ADDR_OFFSET] @ ampu addr
+
+	coht_lock r0, r1, r2
+	cpsid	i
+
+	ldr	r0, [ncb, #CC_OFFSET]
+	ldr	r1, [ncb, #CC_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #CC2_OFFSET]
+	ldr	r1, [ncb, #CC2_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #CC3_OFFSET]
+	ldr	r1, [ncb, #CC3_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #BUS_OFFSET]
+	ldr	r1, [ncb, #BUS_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #FCCR_OFFSET]
+	ldr	r1, [ncb, #FCCR_ADDR_OFFSET]
+	str	r0, [r1]
+
+	mov	r1, #0x0
+	tst	dfc, #PJ_FREQ_CHG_REQ
+	orrne	r1, r1, #PJ_FREQ_CHG_DONE
+	tst	dfc, #AXI_FREQ_CHG_REQ
+	orrne	r1, r1, #AXI_FREQ_CHG_DONE
+	tst	dfc, #DDR_FREQ_CHG_REQ1
+	orrne	r1, r1, #DDR_FREQ_CHG_DONE1
+	tst	dfc, #DDR_FREQ_CHG_REQ2
+	orrne	r1, r1, #DDR_FREQ_CHG_DONE2
+
+	str	dfc, [pmu, #0x4]	@ set meltres cc register
+check_dfc_finish_b0p:
+	ldr	r0, [pmu, #0xa0]
+	and	r0, r0, r1
+	cmp	r0, r1
+	bne	check_dfc_finish_b0p
+
+	cpsie	i
+	coht_unlock r0, r1, r2
+
+	mov	r0, #0x0		@ set return value
+	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}
+	mov	pc, lr
+ENDPROC(mmp3_trigger_dfc_ll_b0p)
+
+/*
+ * mmp3_trigger_dfc_ll()
+ *
+ * low level function for triggerring DFC; should forbid any snooping
+ * operation during DFC, so need set the core to AMP mode and do not
+ * access any data which stored in cache.
+ *
+ * r0 = dfc value
+ * r1 = noncache buffer base address
+ *
+ */
+ENTRY(mmp3_trigger_dfc_ll)
+	stmfd	sp!, {r4-r5, r7, r9-r11, lr}
+
+	mov	dfc, r0			@ save dfc value
+	mov	ncb, r1			@ save base addr
+	get_cid cid			@ read core id
+	ldr	pmu, [ncb, #APMU_BASE_ADDR_OFFSET] @ ampu addr
+
+	coht_lock r0, r1, r2
+	cpsid	i
+
+	ldr	r0, [ncb, #CC_OFFSET]
+	ldr	r1, [ncb, #CC_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #CC2_OFFSET]
+	ldr	r1, [ncb, #CC2_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #CC3_OFFSET]
+	ldr	r1, [ncb, #CC3_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #BUS_OFFSET]
+	ldr	r1, [ncb, #BUS_ADDR_OFFSET]
+	str	r0, [r1]
+
+	ldr	r0, [ncb, #FCCR_OFFSET]
+	ldr	r1, [ncb, #FCCR_ADDR_OFFSET]
+	str	r0, [r1]
+
+	mov	r0, #0x1		@ set handshake flag
+	set_hs_val r0, r1
+
+	disable_fw r0
+	@invalid_and_flush_l1_cache r0	@ flush L1 cache
+
+	mov	r0, #0x0		@ clear coherent state
+	set_coht_val r0, r1
+
+	bl	req_peer_core_dis_fw
+
+	set_amp	r0
+
+	mov	r1, #0x0
+	tst	dfc, #PJ_FREQ_CHG_REQ
+	orrne	r1, r1, #PJ_FREQ_CHG_DONE
+	tst	dfc, #AXI_FREQ_CHG_REQ
+	orrne	r1, r1, #AXI_FREQ_CHG_DONE
+	tst	dfc, #DDR_FREQ_CHG_REQ1
+	orrne	r1, r1, #DDR_FREQ_CHG_DONE1
+	tst	dfc, #DDR_FREQ_CHG_REQ2
+	orrne	r1, r1, #DDR_FREQ_CHG_DONE2
+
+	str	dfc, [pmu, #0x4]	@ set meltres cc register
+check_dfc_finish:
+	ldr	r0, [pmu, #0xa0]
+	and	r0, r0, r1
+	cmp	r0, r1
+	bne	check_dfc_finish
+
+	set_smp	r0
+	@invalid_and_flush_l1_cache r0
+
+	mov	r0, #0x1		@ set coherent state
+	set_coht_val r0, r1
+
+	mov	r0, #0x0		@ clear handshake flag
+	set_hs_val r0, r1
+
+	bl	req_peer_core_en_fw
+
+	cpsie	i
+	coht_unlock r0, r1, r2
+	mov	r0, #0x0		@ set return value
+
+	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}
+	mov	pc, lr
+ENDPROC(mmp3_trigger_dfc_ll)
+
+/*
+ * mmp3_coherent_handler()
+ *
+ * r0 = noncache buffer base address
+ *
+ */
+ENTRY(mmp3_coherent_handler)
+	stmfd	sp!, {r4-r5, r7, r9-r11, lr}
+
+	mov	ncb, r0			@ save base addr
+	get_cid cid			@ read core id
+
+	disable_fw r0
+	mov	r0, #0x0		@ clear coherent state
+	set_coht_val r0, r1
+
+wait_req_done:
+	get_peer_core_hs_val r0
+	cmp	r0, #0x0
+	bne	wait_req_done
+
+	enable_fw r0
+	mov	r0, #0x1		@ set coherent state
+	set_coht_val r0, r1
+
+	mov	r0, #0x0
+	ldmfd	sp!, {r4-r5, r7, r9-r11, lr}
+	mov	pc, lr
+ENDPROC(mmp3_coherent_handler)
+
+/*
+ * mmp3_enter_c2()
+ *
+ * r0 = noncache buffer base address
+ *
+ */
+ENTRY(mmp3_enter_c2)
+	stmfd	sp!, {r4-r11, lr}
+
+	mov	ncb, r0			@ save base addr
+	get_cid cid			@ read core id
+	ldr	pmu, [ncb, #APMU_BASE_ADDR_OFFSET] @ ampu addr
+
+	mov	try, #0x0
+	coht_trylock r0, r1, try
+	cmp	try, #0x0
+	bne	exit_c2
+
+	mov	r0, #0x1		@ set handshake flag
+	set_hs_val r0, r1
+
+	disable_fw r0
+	invalid_and_flush_l1_cache r0	@ flush L1 cache
+
+	mov	r0, #0x0		@ clear coherent state
+	set_coht_val r0, r1
+
+	bl	req_peer_core_dis_fw
+
+	set_amp	r0
+	mov	r0, #0x0		@ clear handshake flag
+	set_hs_val r0, r1
+
+	bl	req_peer_core_en_fw
+
+	coht_unlock r0, r1, r2
+
+run_into_c2:
+	bl	prepare_into_c2
+	wfi
+	bl	clear_exit_c2
+
+	ldr	r0, [ncb, #INT_STATUS_ADDR_OFFSET]
+	ldr	r1, [r0]
+	mov	r2, #0x400
+	sub	r2, r2, #1		@ test for irq 1023
+	and	r1, r1, r2
+	cmp	r1, r2			@ 1023 means suprious irq
+	bne	acquire_lock
+
+	ldr	r0, [ncb, #WAKE_STATUS_ADDR_OFFSET]
+	ldr	r1, [r0]
+	mov	r2, #0x1
+	lsl	r2, r2, #31
+	bic	r1, r1, r2		@ clear bit 31
+	mov	r2, #0x38
+	lsl	r2, r2, #8
+	bic	r1, r1, r2		@ clear bit 0x3800
+	cmp	r1, #0x0
+	beq	run_into_c2		@ no irq, so run into c2 again
+
+acquire_lock:
+	coht_lock r0, r1, r2
+
+	mov	r0, #0x1		@ set handshake flag
+	set_hs_val r0, r1
+
+	bl	req_peer_core_dis_fw
+
+	set_smp	r0
+	@invalid_and_flush_l1_cache r0
+
+	mov	r0, #0x1		@ set coherent state
+	set_coht_val r0, r1
+
+	mov	r0, #0x0		@ clear handshake flag
+	set_hs_val r0, r1
+
+	bl	req_peer_core_en_fw
+
+	coht_unlock r0, r1, r2
+
+exit_c2:
+	mov	r0, try
+
+	ldmfd	sp!, {r4-r11, lr}
+	mov	pc, lr
+ENDPROC(mmp3_enter_c2)
+
+prepare_into_c2:
+	cmp	cid, #0x1
+	beq	load_mp2_set		@ check is mp2
+
+	/*
+	 * note: here cannot directly use CM_CID to check
+	 * the core is mp1/mp2/mm core; should be aware there
+	 * may have two cores run into C2 at the same time,
+	 * so these two cores will set the CM_CID value and let
+	 * this value cannot be trusted. So CM_CID is only used
+	 * b/t mp1 and mm core, this is based on the assumption
+	 * of core morphing, for mp1 and mm core cannot run
+	 * at the same time.
+	 */
+	ldr	r0, [ncb, #CM_CID_OFFSET]
+	cmp	r0, #0x2
+	beq	load_mm_set		@ check is mm
+
+	mov	r1, #APMU_PJ_IDLE_CFG0	@ mp1 mk apmu
+	mov	r2, #APMU_PJ_C0_CC4	@ mp1 cc4
+	ldr	r3, [ncb, #MP1_C1_CFG_OFFSET]
+	ldr	r4, [ncb, #MP1_C2_CFG_OFFSET]
+	b	set_idle_cfg
+
+load_mp2_set:
+	mov	r1, #APMU_PJ_IDLE_CFG1	@ mp2 mk apmu
+	mov	r2, #APMU_PJ_C1_CC4	@ mp2 cc4
+	ldr	r3, [ncb, #MP2_C1_CFG_OFFSET]
+	ldr	r4, [ncb, #MP2_C2_CFG_OFFSET]
+	b	set_idle_cfg
+
+load_mm_set:
+	mov	r1, #APMU_PJ_IDLE_CFG2	@ mm mk apmu
+	mov	r2, #APMU_PJ_C2_CC4	@ mm cc4
+	ldr	r3, [ncb, #MM_C1_CFG_OFFSET]
+	ldr	r4, [ncb, #MM_C2_CFG_OFFSET]
+
+set_idle_cfg:
+	str	r4, [pmu, r1]		@ set idle config
+
+	ldr	r0, [pmu, r2]		@ mask gic
+	orr	r0, r0, #0x1
+	str	r0, [pmu, r2]
+
+	mov	pc, lr
+ENDPROC(prepare_into_c2)
+
+clear_exit_c2:				@ r0 = apmu base address
+	str	r3, [pmu, r1]		@ set idle config
+
+	ldr	r0, [pmu, r2]		@ unmask gic
+	bic	r0, r0, #0x1
+	str	r0, [pmu, r2]
+
+	mov	pc, lr
+ENDPROC(clear_exit_c2)
diff --git a/arch/arm/mach-mmp/mmp3_headsmp.S b/arch/arm/mach-mmp/mmp3_headsmp.S
new file mode 100644
index 0000000..8844a15
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp3_headsmp.S
@@ -0,0 +1,41 @@
+/*
+ *  linux/arch/arm/mach-mmp/mmp3_headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__CPUINIT
+
+/*
+ * PXA specific entry point for secondary CPUs.  This provides
+ * a "holding pen" into which all secondary cores are held until we're
+ * ready for them to initialise.
+ */
+ENTRY(mmp3_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+ENDPROC(mmp3_secondary_startup)
+
+	.align	2
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-mmp/mmp3_hotplug.c b/arch/arm/mach-mmp/mmp3_hotplug.c
new file mode 100644
index 0000000..712a4ad
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp3_hotplug.c
@@ -0,0 +1,100 @@
+/*
+ *  linux/arch/arm/mach-mmp/hotplug-mmp3.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/completion.h>
+
+#include <asm/cacheflush.h>
+#include <mach/mmp3_pm.h>
+
+extern volatile int __cpuinitdata pen_release;
+
+static DECLARE_COMPLETION(cpu_killed);
+
+static inline void __cpuinit platform_do_lowpower(unsigned int cpu)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		/*
+		 * here's the WFI
+		 */
+		mmp3_pm_enter_c2(cpu, 1);
+
+		if (pen_release == cpu) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * The trouble is, letting people know about this is not really
+		 * possible, since we are currently running incoherently, and
+		 * therefore cannot safely call printk() or anything else
+		 */
+#ifdef DEBUG
+		printk("CPU%u: spurious wakeup call\n", cpu);
+#endif
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return wait_for_completion_timeout(&cpu_killed, 5000);
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void __cpuinit platform_cpu_die(unsigned int cpu)
+{
+#ifdef DEBUG
+	unsigned int this_cpu = hard_smp_processor_id();
+
+	if (cpu != this_cpu) {
+		printk(KERN_CRIT "Eek! platform_cpu_die running on %u, should be %u\n",
+			   this_cpu, cpu);
+		BUG();
+	}
+#endif
+
+	printk(KERN_NOTICE "CPU%u: shutdown\n", cpu);
+	complete(&cpu_killed);
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	platform_do_lowpower(cpu);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-mmp/mmp_dma.c b/arch/arm/mach-mmp/mmp_dma.c
new file mode 100644
index 0000000..cf282d8
--- /dev/null
+++ b/arch/arm/mach-mmp/mmp_dma.c
@@ -0,0 +1,185 @@
+/*
+ *  linux/arch/arm/mach-pxa/mmp_dma.c
+ *
+ *  MMP DMA registration and IRQ dispatching
+ *
+ *  Mainly for Audio DMA, Memory DMA and Video DMA; Keep this driver
+ *  and later should move to use dmaengine to manage dma channels.
+ *
+ *  Author:	Nicolas Pitre
+ *  Created:	Nov 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/regs-icu.h>
+#include <mach/mmp_dma.h>
+
+struct mmp_dma_channel {
+	char *name;
+	void (*irq_handler)(int, void *);
+	void *data;
+};
+
+static struct mmp_dma_channel *mmp_dma_channels;
+static u32 mmp_reg_base_arr[DMA_CH_NUM] = {
+	MDMA1_CH0_BASE, MDMA1_CH1_BASE,
+	ADMA1_CH0_BASE, ADMA1_CH1_BASE,
+	ADMA2_CH0_BASE, ADMA2_CH1_BASE,
+	VDMA1_CH0_BASE, VDMA1_CH1_BASE,
+};
+
+u32 mmp_get_dma_reg_base(unsigned int dma_ch)
+{
+	if (dma_ch > DMA_CH_NUM)
+		return 0;
+	else
+		return mmp_reg_base_arr[dma_ch];
+}
+
+unsigned int mmp_request_dma(char *name, unsigned int dma_ch,
+		void (*irq_handler)(int, void *), void *data)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	/* basic sanity checks */
+	if (!name || !irq_handler || (dma_ch >= DMA_CH_NUM))
+		return -EINVAL;
+
+	local_irq_save(flags);
+
+	if (!mmp_dma_channels[dma_ch].name) {
+		u32 base, msk;
+
+		base = mmp_get_dma_reg_base(dma_ch);
+
+		if (dma_ch < VDMA1_CH0)
+			TDCR(base) = 0;
+		else
+			VDCR(base) = 0;
+
+		msk = __raw_readl(ICU_DMAIRQ_MASK);
+		msk &= ~(1 << (16 + dma_ch));
+		__raw_writel(msk, ICU_DMAIRQ_MASK);
+
+		mmp_dma_channels[dma_ch].name = name;
+		mmp_dma_channels[dma_ch].irq_handler = irq_handler;
+		mmp_dma_channels[dma_ch].data = data;
+		ret = dma_ch;
+	} else {
+		printk(KERN_WARNING "No more available MMP DMA "
+		       "channels for %s\n", name);
+		ret = -ENODEV;
+	}
+
+	local_irq_restore(flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(mmp_request_dma);
+
+void mmp_free_dma(unsigned int dma_ch)
+{
+	unsigned long flags;
+	u32 base, msk;
+
+	if (dma_ch >= DMA_CH_NUM) {
+		printk(KERN_CRIT
+		       "%s: trying to free an invalid channel %d\n",
+		       __func__, dma_ch);
+		return;
+	}
+
+	if (!mmp_dma_channels[dma_ch].name) {
+		printk(KERN_CRIT "%s: trying to free channel %d "
+		       "which is already freed\n", __func__, dma_ch);
+		return;
+	}
+
+	local_irq_save(flags);
+
+	base = mmp_get_dma_reg_base(dma_ch);
+
+	if (dma_ch < VDMA1_CH0)
+		TDCR(base) = 0;
+	else
+		VDCR(base) = 0;
+
+	msk = __raw_readl(ICU_DMAIRQ_MASK);
+	msk |= (1 << (16 + dma_ch));
+	__raw_writel(msk, ICU_DMAIRQ_MASK);
+
+	mmp_dma_channels[dma_ch].name = NULL;
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL(mmp_free_dma);
+
+static irqreturn_t mmp_dma_irq_handler(int irq, void *dev_id)
+{
+	int i;
+	u32 base;
+	int dint = __raw_readl(ICU_DMAIRQ_STATUS);
+
+	if ((dint & 0xff0000) == 0)
+		return IRQ_NONE;
+
+	for (i = 0; i < DMA_CH_NUM; i++) {
+		if (dint & (1 << (i + 16))) {
+			struct mmp_dma_channel *channel = &mmp_dma_channels[i];
+
+			base = mmp_get_dma_reg_base(i);
+			if (channel->name && channel->irq_handler) {
+				channel->irq_handler(i, channel->data);
+				/*note: clear irq status in the handler */
+			} else {
+				/*
+				 * IRQ for an unregistered DMA channel:
+				 * let's clear the interrupts and disable it.
+				 */
+				printk(KERN_WARNING "spurious IRQ for DMA "
+				       "channel %d\n", i);
+				if (i < VDMA1_CH0)
+					TDCR(base) = 0;
+				else
+					VDCR(base) = 0;
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+int __init mmp_init_dma(unsigned int irq)
+{
+	int ret;
+
+	mmp_dma_channels = kzalloc(sizeof(struct mmp_dma_channel) * DMA_CH_NUM,
+				   GFP_KERNEL);
+	if (!mmp_dma_channels)
+		return -ENOMEM;
+
+	ret = request_irq(irq, mmp_dma_irq_handler, IRQF_DISABLED | IRQF_SHARED,
+			  "DMA", "MMP2_DMA");
+	if (ret) {
+		printk(KERN_CRIT "Wow! Can't register IRQ for MMP DMA\n");
+		kfree(mmp_dma_channels);
+	}
+
+	return ret;
+}
diff --git a/arch/arm/mach-mmp/mv_wtm.c b/arch/arm/mach-mmp/mv_wtm.c
new file mode 100644
index 0000000..ace4012
--- /dev/null
+++ b/arch/arm/mach-mmp/mv_wtm.c
@@ -0,0 +1,280 @@
+/*
+ * (C) Copyright 2012
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <mach/mv_wtm.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <asm/memory.h>
+#include <asm/mach/map.h>
+
+struct wtm_cmd {
+    unsigned int prim_cmd_parm0;          // 0x0
+    unsigned int prim_cmd_parm1;          // 0x4
+    unsigned int prim_cmd_parm2;          // 0x8
+    unsigned int prim_cmd_parm3;          // 0xc
+    unsigned int prim_cmd_parm4;          // 0x10
+    unsigned int prim_cmd_parm5;          // 0x14
+    unsigned int prim_cmd_parm6;          // 0x18
+    unsigned int prim_cmd_parm7;          // 0x1c
+    unsigned int prim_cmd_parm8;          // 0x20
+    unsigned int prim_cmd_parm9;          // 0x24
+    unsigned int prim_cmd_parm10;         // 0x28
+    unsigned int prim_cmd_parm11;         // 0x2c
+    unsigned int prim_cmd_parm12;         // 0x30
+    unsigned int prim_cmd_parm13;         // 0x34
+    unsigned int prim_cmd_parm14;         // 0x38
+    unsigned int prim_cmd_parm15;         // 0x3c
+    unsigned int secure_processor_cmd;    // 0x40
+};
+
+/*
++ * WTM register file for host communication
++ */
+struct wtm_mail_box {
+	unsigned int prim_cmd_parm0;          // 0x0
+	unsigned int prim_cmd_parm1;          // 0x4
+	unsigned int prim_cmd_parm2;          // 0x8
+	unsigned int prim_cmd_parm3;          // 0xc
+	unsigned int prim_cmd_parm4;          // 0x10
+	unsigned int prim_cmd_parm5;          // 0x14
+	unsigned int prim_cmd_parm6;          // 0x18
+	unsigned int prim_cmd_parm7;          // 0x1c
+	unsigned int prim_cmd_parm8;          // 0x20
+	unsigned int prim_cmd_parm9;          // 0x24
+	unsigned int prim_cmd_parm10;         // 0x28
+	unsigned int prim_cmd_parm11;         // 0x2c
+	unsigned int prim_cmd_parm12;         // 0x30
+	unsigned int prim_cmd_parm13;         // 0x34
+	unsigned int prim_cmd_parm14;         // 0x38
+	unsigned int prim_cmd_parm15;         // 0x3c
+	unsigned int secure_processor_cmd;    // 0x40
+	unsigned char reserved_0x44[60];
+	unsigned int cmd_return_status;       // 0x80
+	unsigned int cmd_status_0;            // 0x84
+	unsigned int cmd_status_1;            // 0x88
+	unsigned int cmd_status_2;            // 0x8c
+	unsigned int cmd_status_3;            // 0x90
+	unsigned int cmd_status_4;            // 0x94
+	unsigned int cmd_status_5;            // 0x98
+	unsigned int cmd_status_6;            // 0x9c
+	unsigned int cmd_status_7;            // 0xa0
+	unsigned int cmd_status_8;            // 0xa4
+	unsigned int cmd_status_9;            // 0xa8
+	unsigned int cmd_status_10;           // 0xac
+	unsigned int cmd_status_11;           // 0xb0
+	unsigned int cmd_status_12;           // 0xb4
+	unsigned int cmd_status_13;           // 0xb8
+	unsigned int cmd_status_14;           // 0xbc
+	unsigned int cmd_status_15;           // 0xc0
+	unsigned int cmd_fifo_status;         // 0xc4
+	unsigned int host_interrupt_register; // 0xc8
+	unsigned int host_interrupt_mask;     // 0xcc
+	unsigned int host_exception_address;  // 0xd0
+	unsigned int sp_trust_register;       // 0xd4
+	unsigned int wtm_identification;      // 0xd8
+	unsigned int wtm_revision;            // 0xdc
+};
+
+
+#define WTM_BASE			0xD4290000
+#define WTM_GET_SOC_STEPPING		0x1007
+#define WTM_PRIM_CMD_COMPLETE_MASK	(1 << 0)
+#define WTM_GET_SOC_POWER_POINT		0x1006
+#define WTM_OTP_READ_PLATFORM_CONFIG	0x200A
+#define WTM_RESET	0x0000
+#define WTM_INIT	0x0001
+
+unsigned int mv_ack_from_wtm   = 0x0;
+unsigned int mv_profile_adjust = 0x0;
+unsigned int mv_profile	 = 0x0;
+unsigned int mv_max_freq	 = 0x0;
+unsigned int mv_ts_calibration = 0x0;
+unsigned int mv_ref_clk	= 0x0;
+unsigned int mv_stepping	 = 0x0;
+
+static volatile struct wtm_mail_box *wtm_mb = NULL;
+
+static int wtm_exe_cmd(struct wtm_cmd *cmd)
+{
+	int i;
+
+	unsigned int *pcmd = &cmd->prim_cmd_parm0;
+	volatile unsigned int *phi = &wtm_mb->prim_cmd_parm0;
+
+	for (i = 0; i <= 16; i++) {
+		*phi++ = *pcmd++;
+	}
+
+	/* try 1000 times */
+	for (i = 0; i < 10000; i++) {
+		if (wtm_mb->host_interrupt_register &
+		    WTM_PRIM_CMD_COMPLETE_MASK) {
+			/* clean interrupt */
+			wtm_mb->host_interrupt_register = 0xFFFFFFFF;
+			return wtm_mb->cmd_return_status;
+		}
+	}
+
+	/* read fail */
+	return -1;
+}
+
+
+int wtm_init(void)
+{
+	struct wtm_cmd cmd;
+	int status;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	/* valid request */
+	cmd.prim_cmd_parm0 = 0;
+	cmd.secure_processor_cmd = WTM_RESET;
+	status = wtm_exe_cmd(&cmd);
+	if (status < 0) {
+		pr_info("Bad status on reset with status %d\n", status);
+		mv_ack_from_wtm = 0;
+		goto out;
+	}
+
+	cmd.prim_cmd_parm0 = 0;
+	cmd.secure_processor_cmd = WTM_INIT;
+	status = wtm_exe_cmd(&cmd);
+	if (status != 0) {
+		pr_info("Bad status init with status %d\n", status);
+		mv_ack_from_wtm = 0;
+		goto out;
+	}
+	mv_ack_from_wtm   = 1;
+
+out:
+	return status;
+}
+
+void wtm_setup_remap(void)
+{
+
+	void *wtm_base_remap = ioremap_nocache(WTM_BASE, sizeof(struct wtm_mail_box));
+	wtm_mb = (volatile struct wtm_mail_box *)(wtm_base_remap);
+}
+
+
+int wtm_read_platform_config(void)
+{
+	struct wtm_cmd cmd;
+	int status, i;
+	memset(&cmd, 0, sizeof(cmd));
+
+	/* valid request */
+	cmd.prim_cmd_parm0 = 0xd102ff00;
+	cmd.secure_processor_cmd = WTM_OTP_READ_PLATFORM_CONFIG;
+	status = wtm_exe_cmd(&cmd);
+	if (status != 0) {
+		pr_info("Bad status from %s with %d\n", __func__, status);
+		mv_ack_from_wtm = 0;
+		goto out;
+	}
+	mv_ack_from_wtm   = 1;
+	mv_ref_clk = readl(0xfea00000 + 0x2ff00) & 0xf;
+	return mv_ref_clk;
+out:
+	return status;
+}
+
+int wtm_read_profile(void)
+{
+	struct wtm_cmd cmd;
+	int status;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	/* valid request */
+	cmd.prim_cmd_parm0 = 0;
+	cmd.secure_processor_cmd = WTM_GET_SOC_POWER_POINT;
+	status = wtm_exe_cmd(&cmd);
+	if (status < 0) {
+		mv_ack_from_wtm = 0;
+		goto out;
+	}
+
+	mv_ack_from_wtm   = 1;
+	mv_profile_adjust = wtm_mb->cmd_status_0;
+	mv_profile	    = wtm_mb->cmd_status_1;
+	mv_max_freq	    = wtm_mb->cmd_status_2;
+	mv_ts_calibration = wtm_mb->cmd_status_3;
+
+out:
+	return status;
+}
+void wtm_read_stepping(void)
+{
+	struct wtm_cmd cmd;
+	int status;
+
+	unsigned int chip_id;
+	unsigned int id;
+	unsigned int soc_stepping;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	/* valid request */
+	cmd.prim_cmd_parm0 = 0;
+	cmd.secure_processor_cmd = WTM_GET_SOC_STEPPING;
+	status = wtm_exe_cmd(&cmd);
+	if (status < 0) {
+		printk("wtm read steppping error: %d\n", status);
+	}
+
+	soc_stepping = wtm_mb->cmd_status_0;
+/*	chip_id      = __raw_readl(0xd4282c00);
+	id           = read_cpuid(CPUID_ID);*/
+	if ((chip_id & 0x00ff0000) == 0x00a00000) {
+
+		if (soc_stepping == 0x4130)
+			mv_stepping = 0xa0;
+		else if (soc_stepping == 0x4131)
+			mv_stepping = 0xa1;
+		else if (soc_stepping == 0x4132)
+			mv_stepping = 0xa2;
+	} else if ((chip_id & 0x00ff0000) == 0x00b00000) {
+		if (soc_stepping == 0x4230)
+			mv_stepping = 0xb0;
+		else
+			printk("Unknow cpu stepping!\n");
+	} else
+		printk("Unknow cpu stepping! ");
+}
+
+void wtm_dump_info(void)
+{
+	printk("----- wtm info -----\n");
+
+	if (!mv_ack_from_wtm)
+		printk("wtm has NO ack.\n");
+	else
+		printk("get ack from wtm.\n");
+
+	printk("profile_adjust = 0x%08x\n", mv_profile_adjust);
+	printk("profile        = 0x%08x\n", mv_profile);
+	printk("max_freq       = 0x%08x\n", mv_max_freq);
+	printk("ts_calibration = 0x%08x\n", mv_ts_calibration);
+	printk("stepping       = 0x%08x\n", mv_stepping);
+	printk("platform reference clock = 0x%08x\n", mv_ref_clk);
+
+	printk("-----   end    -----\n\n");
+
+	return;
+}
diff --git a/arch/arm/mach-mmp/onboard.h b/arch/arm/mach-mmp/onboard.h
new file mode 100644
index 0000000..4f22777
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard.h
@@ -0,0 +1,20 @@
+#ifndef ONBOARD_H_
+#define ONBOARD_H_
+
+void __init abilene_add_lcd_mipi(void);
+void __init yellowstone_add_lcd_mipi(void);
+void __init orchid_add_lcd_mipi(void);
+void __init mk2_add_lcd_mipi(void);
+void __init emeidkb_add_lcd_mipi(void);
+void __init emeidkb_add_lcd_mipi_tv(void);
+void __init thunderstonem_add_lcd_mipi(void);
+void __init mmp3_add_tv_out(void);
+void __init dkb_add_lcd_tpo(void);
+void __init dkb_add_lcd_truly(void);
+void __init dkb_add_lcd_sharp(void);
+void __init brownstone_add_lcd_mipi(void);
+void __init mmp2_add_tv_out(void);
+void __init emeidkb_add_lcd_pl(void);
+void __init emeidkb_add_tv_out(void);
+
+#endif /* ONBOARD_H_ */
diff --git a/arch/arm/mach-mmp/onboard/Makefile b/arch/arm/mach-mmp/onboard/Makefile
new file mode 100644
index 0000000..1a3eb18
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/Makefile
@@ -0,0 +1,4 @@
+#
+#
+obj-$(CONFIG_UIO_HDMI) += lcd_hdmi.o
+obj-$(CONFIG_MACH_QSEVEN) += lcd_mipi.o
diff --git a/arch/arm/mach-mmp/onboard/lcd_hdmi.c b/arch/arm/mach-mmp/onboard/lcd_hdmi.c
new file mode 100644
index 0000000..131e524
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/lcd_hdmi.c
@@ -0,0 +1,318 @@
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/regulator/machine.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/mmp2.h>
+#include <mach/mmp3.h>
+#include <mach/pxa168fb.h>
+
+#define TV_FB_XRES      1920
+#define TV_FB_YRES      1080
+
+static struct fb_videomode tv_video_modes[] = {
+	[0] = {
+#ifdef CONFIG_MACH_QSEVEN
+		.pixclock     = 6734,
+		.refresh      = 60,
+#else
+		/*.pixclock     = 6734,*/
+		.pixclock = 13513,
+		/*.refresh      = 60,*/
+		.refresh = 24,
+#endif
+		.xres = 1920,
+		.yres = 1080,
+		.hsync_len = 88,
+		/*.left_margin  = 88,*/
+		.left_margin = 148,
+		.right_margin = 44,
+		.vsync_len = 4,
+		.upper_margin = 36,
+		.lower_margin = 5,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[1] = {
+		.pixclock = 13149,
+		.refresh = 60,
+		.xres = 1280,
+		.yres = 720,
+		.hsync_len = 40,
+		.left_margin = 110,
+		.right_margin = 220,
+		.vsync_len = 5,
+		.upper_margin = 5,
+		.lower_margin = 20,
+		.sync = FB_SYNC_HOR_HIGH_ACT,
+	},
+	[2] = {
+		.pixclock = 37000,
+		.refresh = 60,
+		.xres = 720,
+		.yres = 480,
+		.hsync_len = 62,
+		.left_margin = 16,
+		.right_margin = 60,
+		.vsync_len = 6,
+		.upper_margin = 9,
+		.lower_margin = 30,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[3] = {
+		.pixclock = 39682,
+		.refresh = 60,
+		.xres = 640,
+		.yres = 480,
+		.hsync_len = 96,
+		.left_margin = 16,
+		.right_margin = 48,
+		.vsync_len = 2,
+		.upper_margin = 10,
+		.lower_margin = 33,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[4] = {
+		.pixclock = 37070,
+		.refresh = 60,
+		.xres = 1440,
+		.yres = 240,
+		.hsync_len = 124,
+		.left_margin = 38,
+		.right_margin = 114,
+		.vsync_len = 3,
+		.upper_margin = 4,
+		.lower_margin = 15,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[5] = {
+		.pixclock = 37036,
+		.refresh = 50,
+		.xres = 720,
+		.yres = 576,
+		.hsync_len = 64,
+		.left_margin = 12,
+		.right_margin = 68,
+		.vsync_len = 5,
+		.upper_margin = 5,
+		.lower_margin = 39,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[6] = {
+		.pixclock = 37095,
+		.refresh = 50,
+		.xres = 1440,
+		.yres = 288,
+		.hsync_len = 126,
+		.left_margin = 24,
+		.right_margin = 138,
+		.vsync_len = 3,
+		.upper_margin = 3,
+		.lower_margin = 18,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[7] = {
+		.pixclock = 18535,
+		.refresh = 60,
+		.xres = 2880,
+		.yres = 240,
+		.hsync_len = 248,
+		.left_margin = 76,
+		.right_margin = 228,
+		.vsync_len = 3,
+		.upper_margin = 4,
+		.lower_margin = 15,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[8] = {
+		.pixclock = 18500,
+		.refresh = 60,
+		.xres = 1440,
+		.yres = 480,
+		.hsync_len = 124,
+		.left_margin = 32,
+		.right_margin = 120,
+		.vsync_len = 6,
+		.upper_margin = 9,
+		.lower_margin = 30,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[9] = {
+		.pixclock = 1674,
+		.refresh = 50,
+		.xres = 2880,
+		.yres = 288,
+		.hsync_len = 252,
+		.left_margin = 48,
+		.right_margin = 276,
+		.vsync_len = 3,
+		.upper_margin = 3,
+		.lower_margin = 18,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[10] = {
+		.pixclock = 18518,
+		.refresh = 50,
+		.xres = 1440,
+		.yres = 576,
+		.hsync_len = 128,
+		.left_margin = 24,
+		.right_margin = 136,
+		.vsync_len = 5,
+		.upper_margin = 5,
+		.lower_margin = 39,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[11] = {
+		.pixclock = 9250,
+		.refresh = 60,
+		.xres = 2880,
+		.yres = 480,
+		.hsync_len = 248,
+		.left_margin = 64,
+		.right_margin = 240,
+		.vsync_len = 6,
+		.upper_margin = 9,
+		.lower_margin = 30,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+	[12] = {
+		.pixclock = 9259,
+		.refresh = 50,
+		.xres = 2880,
+		.yres = 576,
+		.hsync_len = 256,
+		.left_margin = 48,
+		.right_margin = 272,
+		.vsync_len = 5,
+		.upper_margin = 5,
+		.lower_margin = 39,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+	},
+
+};
+#ifdef CONFIG_CPU_MMP3
+static struct pxa168fb_mach_info tv_out_info = {
+	.id = "TV GFX Layer",
+	.num_modes = ARRAY_SIZE(tv_video_modes),
+	.modes = tv_video_modes,
+	.sclk_div = 0x60010005,
+	.pix_fmt = PIX_FMT_RGB565,
+	.isr_clear_mask	= LCD_ISR_CLEAR_MASK_PXA168,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 1,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+#ifdef CONFIG_MACH_QSEVEN
+	.mmap = 1,
+#else
+	.mmap = 0,
+#endif
+	.max_fb_size = TV_FB_XRES * TV_FB_YRES * 8 + 4096,
+	.phy_type = DPI,
+	.vdma_enable = 1,
+	.sram_size = 30 * 1024,
+};
+
+static struct pxa168fb_mach_info tv_out_ovly_info = {
+	.id = "TV Video Layer",
+	.num_modes = ARRAY_SIZE(tv_video_modes),
+	.modes = tv_video_modes,
+	.pix_fmt = PIX_FMT_RGB565,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 0,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+	.mmap = 0,
+	.max_fb_size = TV_FB_XRES * TV_FB_YRES * 8 + 4096,
+	.vdma_enable = 0,
+	.sram_size = 30 * 1024,
+};
+
+
+
+void __init mmp3_add_tv_out(void)
+{
+	struct pxa168fb_mach_info *fb = &tv_out_info;
+	struct pxa168fb_mach_info *ovly = &tv_out_ovly_info;
+
+	/* add frame buffer drivers */
+	mmp3_add_fb_tv(fb);
+
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_tv_ovly(ovly);
+#else
+	mmp3_add_fb_tv_ovly(ovly);
+#endif
+}
+#endif
+
+#ifdef CONFIG_CPU_MMP2
+static struct pxa168fb_mach_info mmp2_tv_hdmi_info __initdata = {
+	.id			= "GFX Layer - TV",
+	.sclk_div		= 0x5 | (1<<16) | (3<<30), /* HDMI PLL */
+	.num_modes		= ARRAY_SIZE(tv_video_modes),
+	.modes			= tv_video_modes,
+	.pix_fmt		= PIX_FMT_RGB565,
+	.isr_clear_mask	= LCD_ISR_CLEAR_MASK_PXA168,
+	/*
+	 * don't care about io_pin_allocation_mode and dumb_mode
+	 * since the hdmi monitor is hard connected with lcd tv path and hdmi output
+	 */
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes= 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena     = 0,
+	.invert_pixclock        = 0,
+	.panel_rbswap           = 1,
+	.active			= 1,
+	.spi_gpio_cs            = -1,
+	.spi_gpio_reset         = -1,
+	.mmap			= 0,
+	.max_fb_size		= 1920 * 1080 * 8 + 4096,
+	.vdma_enable		= 1,
+	.sram_size		= 30 * 1024,
+#ifdef CONFIG_PXA688_CMU
+	.ioctl			= pxa688_cmu_ioctl,
+#endif
+};
+
+static struct pxa168fb_mach_info mmp2_tv_hdmi_ovly_info __initdata = {
+	.id			= "Video Layer - TV",
+	.num_modes		= ARRAY_SIZE(tv_video_modes),
+	.modes			= tv_video_modes,
+	.pix_fmt		= PIX_FMT_RGB565,
+	.panel_rgb_reverse_lanes= 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena     = 0,
+	.invert_pixclock        = 0,
+	.panel_rbswap           = 1,
+	.spi_gpio_cs            = -1,
+	.spi_gpio_reset         = -1,
+	.mmap			= 0,
+	.max_fb_size            = 1920 * 1080 * 8 + 4096,
+	.vdma_enable		= 0,
+	.sram_size		= 30 * 1024,
+};
+
+void __init mmp2_add_tv_out(void)
+{
+	struct pxa168fb_mach_info *fb = &mmp2_tv_hdmi_info;
+	struct pxa168fb_mach_info *ovly = &mmp2_tv_hdmi_ovly_info;
+
+	/* add frame buffer drivers */
+	mmp2_add_fb_tv(fb);
+	mmp2_add_fb_tv_ovly(ovly);
+}
+#endif
diff --git a/arch/arm/mach-mmp/onboard/lcd_mipi.c b/arch/arm/mach-mmp/onboard/lcd_mipi.c
new file mode 100644
index 0000000..a2a75de
--- /dev/null
+++ b/arch/arm/mach-mmp/onboard/lcd_mipi.c
@@ -0,0 +1,2046 @@
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/regulator/machine.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/mmp2.h>
+#include <mach/mmp3.h>
+#include <mach/pxa988.h>
+#include <mach/tc35876x.h>
+#include <mach/pxa168fb.h>
+#include <mach/mmp2_plat_ver.h>
+#include <mach/regs-mcu.h>
+
+/*
+ * FIXME:add qhd_lcd to indicate if use qhd or use HVGA_VNC
+ * It will be removed by Z3.
+ */
+#define QHD_PANEL 1
+static int qhd_lcd;
+static int __init qhd_lcd_setup(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	qhd_lcd = n;
+	return 1;
+}
+__setup("qhd_lcd=", qhd_lcd_setup);
+
+static int is_qhd_lcd(void)
+{
+	return qhd_lcd;
+}
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_QSEVEN)
+static struct fb_videomode video_modes_abilene[] = {
+	[0] = {
+		/* panel refresh rate should <= 55(Hz) */
+		.pixclock = 15764,
+		.refresh = 55,
+		.xres = 1280,
+		.yres = 800,
+		.hsync_len = 2,
+		.left_margin = 64,
+		.right_margin = 64,
+		.vsync_len = 2,
+		.upper_margin = 8,
+		.lower_margin = 8,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#ifdef CONFIG_MACH_YELLOWSTONE
+static struct fb_videomode video_modes_yellowstone[] = {
+	[0] = {
+		 /* panel refresh rate should <= 55(Hz) */
+		.refresh = 55,
+		.xres = 1280,
+		.yres = 800,
+		.hsync_len = 2,
+		.left_margin = 64,
+		.right_margin = 64,
+		.vsync_len = 2,
+		.upper_margin = 8,
+		.lower_margin = 8,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#ifdef CONFIG_MACH_THUNDERSTONEM
+static struct fb_videomode video_modes_thunderstonem[] = {
+	[0] = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 768,
+		.hsync_len = 2,
+		.left_margin = 122,
+		.right_margin = 122,
+		.vsync_len = 8,
+		.upper_margin = 16,
+		.lower_margin = 16,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#ifdef CONFIG_MACH_ORCHID
+static struct fb_videomode video_modes_orchid[] = {
+	[0] = {
+		 /* panel refresh rate should <= 55(Hz) */
+		.refresh = 55,
+		.xres = 540,
+		.yres = 960,
+		.hsync_len = 2,
+		.left_margin = 50,
+		.right_margin = 70,
+		.vsync_len = 2,
+		.upper_margin = 8,
+		.lower_margin = 8,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#ifdef CONFIG_MACH_MK2
+static struct fb_videomode video_modes_mk2[] = {
+	[0] = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 768,
+		.hsync_len = 10,
+		.left_margin = 160,
+		.right_margin = 200,
+		.vsync_len = 2,
+		.upper_margin = 18,
+		.lower_margin = 18,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#ifdef CONFIG_MACH_EMEIDKB
+static struct fb_videomode video_modes_HVGA_VNC_emeidkb[] = {
+	/* lpj032l001b HVGA mode info */
+	[0] = {
+		.refresh        = 60,
+		.xres           = 320,
+		.yres           = 480,
+		.hsync_len      = 10,
+		.left_margin    = 15,
+		.right_margin   = 10,
+		.vsync_len      = 2,
+		.upper_margin   = 4,
+		.lower_margin   = 2,
+		.sync		= 0,
+	},
+};
+static struct fb_videomode video_modes_emeidkb[] = {
+	[0] = {
+		 /* panel refresh rate should <= 55(Hz) */
+		.refresh = 50,
+		.xres = 540,
+		.yres = 960,
+		.hsync_len = 2,
+		.left_margin = 50,
+		.right_margin = 70,
+		.vsync_len = 2,
+		.upper_margin = 8,
+		.lower_margin = 8,
+		.sync = FB_SYNC_VERT_HIGH_ACT | FB_SYNC_HOR_HIGH_ACT,
+		},
+};
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_QSEVEN)
+static int abilene_lvds_power(struct pxa168fb_info *fbi,
+				unsigned int spi_gpio_cs,
+				unsigned int spi_gpio_reset, int on)
+{
+	struct regulator *v_ldo10, *v_ldo19;
+	int lcd_rst_n;
+
+#ifdef CONFIG_MACH_QSEVEN
+	return 0;
+#endif
+	/*
+	 * FIXME: It is board related, baceuse zx will be replaced soon,
+	 * it is temproary distinguished by cpu
+	 */
+	lcd_rst_n = mfp_to_gpio(GPIO128_LCD_RST);
+	/* v_ldo19 AVDD_LVDS, 1.8V */
+	v_ldo19 = regulator_get(NULL, "v_ldo19");
+	/* v_ldo10, 2.8v */
+	v_ldo10 = regulator_get(NULL, "v_ldo10");
+
+	if (IS_ERR(v_ldo19) || IS_ERR(v_ldo10)) {
+		pr_err("%s regulator get error!\n", __func__);
+		v_ldo19 = NULL;
+		v_ldo10 = NULL;
+		return -EIO;
+	}
+
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", lcd_rst_n);
+		return -EIO;
+	}
+
+	if (on) {
+		/* v_ldo19 AVDD_LVDS, 1.8V */
+		regulator_set_voltage(v_ldo19, 1800000, 1800000);
+		regulator_enable(v_ldo19);
+
+		regulator_set_voltage(v_ldo10, 2800000, 2800000);
+		regulator_enable(v_ldo10);
+
+		/* release panel from reset */
+		gpio_direction_output(lcd_rst_n, 1);
+	} else {
+		/* disable v_ldo10 2.8v */
+		regulator_disable(v_ldo10);
+		regulator_put(v_ldo10);
+
+		/* disable v_ldo19 1.8v */
+		regulator_disable(v_ldo19);
+		regulator_put(v_ldo19);
+
+		gpio_direction_output(lcd_rst_n, 0);
+	}
+
+	gpio_free(lcd_rst_n);
+
+	pr_debug("%s on %d\n", __func__, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MACH_YELLOWSTONE
+static int yellowstone_lvds_power(struct pxa168fb_info *fbi,
+			     unsigned int spi_gpio_cs,
+			     unsigned int spi_gpio_reset, int on)
+{
+	struct regulator *v_lcd, *v_1p8_ana;
+	int lcd_rst_n;
+
+	/*
+	 * FIXME: It is board related, baceuse zx will be replaced soon,
+	 * it is temproary distinguished by cpu
+	 */
+	lcd_rst_n = mfp_to_gpio(GPIO128_LCD_RST);
+	/* V_1P8_ANA, AVDD_LVDS, 1.8v */
+	v_1p8_ana = regulator_get(NULL, "V_1P8_ANA");
+	/* V_LCD 3.3v */
+	v_lcd = regulator_get(NULL, "V_LCD");
+
+	if (IS_ERR(v_1p8_ana) || IS_ERR(v_lcd)) {
+		pr_err("%s regulator get error!\n", __func__);
+		v_1p8_ana = NULL;
+		v_lcd = NULL;
+		return -EIO;
+	}
+
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", lcd_rst_n);
+		return -EIO;
+	}
+
+	if (on) {
+		regulator_set_voltage(v_1p8_ana, 1800000, 1800000);
+		regulator_enable(v_1p8_ana);
+
+		regulator_set_voltage(v_lcd, 3300000, 3300000);
+		regulator_enable(v_lcd);
+
+		/* release panel from reset */
+		gpio_direction_output(lcd_rst_n, 1);
+	} else {
+		/* disable v_ldo10 3.3v */
+		regulator_disable(v_lcd);
+		regulator_put(v_lcd);
+
+		/* disable v_ldo19 1.8v */
+		regulator_disable(v_1p8_ana);
+		regulator_put(v_1p8_ana);
+
+		/* set panel reset */
+		gpio_direction_output(lcd_rst_n, 0);
+	}
+
+	gpio_free(lcd_rst_n);
+
+	pr_debug("%s on %d\n", __func__, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MACH_THUNDERSTONEM
+static int thunderstonem_lvds_power(struct pxa168fb_info *fbi,
+				unsigned int spi_gpio_cs,
+				unsigned int spi_gpio_reset, int on)
+{
+	static struct regulator *v_lcd, *v_1p8_ana, *v_3v3;
+	int lcd_rst_n, lcd_en, lcd_stby;
+
+	/*
+	 * FIXME: It is board related, baceuse zx will be replaced soon,
+	 * it is temproary distinguished by cpu
+	 */
+	lcd_rst_n = mfp_to_gpio(GPIO128_LCD_RST);
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", lcd_rst_n);
+		return -EIO;
+	}
+
+	lcd_en = mfp_to_gpio(GPIO84_GPIO);
+	if (gpio_request(lcd_en, "lcd en gpio")) {
+		pr_err("gpio %d request failed\n", lcd_en);
+		goto gpio_free_rst;
+	}
+
+	lcd_stby = mfp_to_gpio(GPIO19_GPIO);
+	if (gpio_request(lcd_stby, "lcd stby gpio")) {
+		pr_err("gpio %d request failed\n", lcd_stby);
+		goto gpio_free_en;
+	}
+
+	/* V_1P8_ANA, AVDD_LVDS, 1.8v */
+	if (!v_1p8_ana) {
+		v_1p8_ana = regulator_get(NULL, "AVDD_LVDS");
+		if (IS_ERR(v_1p8_ana)) {
+			pr_err("%s regulator get error!\n", __func__);
+			v_1p8_ana = NULL;
+			goto gpio_free_stby;
+		}
+	}
+	/* V_LCD 3.3v */
+	if (!v_lcd) {
+		v_lcd = regulator_get(NULL, "V_LCD");
+		if (IS_ERR(v_lcd)) {
+			pr_err("%s regulator get error!\n", __func__);
+			v_lcd = NULL;
+			goto gpio_free_avdd;
+		}
+	}
+	/* V_3V3, the source of LCD_VDDIO */
+	if (!v_3v3) {
+		v_3v3 = regulator_get(NULL, "V_3V3");
+		if (IS_ERR(v_3v3)) {
+			pr_err("%s regulator get error!\n", __func__);
+			v_3v3 = NULL;
+			goto gpio_free_v_lcd;
+		}
+	}
+
+
+	if (on) {
+		/* panel stanby mode exit */
+		gpio_direction_output(lcd_stby, 1);
+
+		/* panel enable */
+		regulator_enable(v_3v3);
+		gpio_direction_output(lcd_en, 1);
+
+		regulator_set_voltage(v_1p8_ana, 1800000, 1800000);
+		regulator_enable(v_1p8_ana);
+
+		regulator_set_voltage(v_lcd, 3300000, 3300000);
+		regulator_enable(v_lcd);
+
+		/* release panel from reset */
+		gpio_direction_output(lcd_rst_n, 1);
+	} else {
+		/* panel stanby mode enter */
+		gpio_direction_output(lcd_stby, 0);
+		/* panel disable */
+		gpio_direction_output(lcd_en, 0);
+		/* set panel reset */
+		gpio_direction_output(lcd_rst_n, 0);
+
+		/* disable v_3v3 */
+		regulator_disable(v_3v3);
+
+		/* disable v_ldo10 3.3v */
+		regulator_disable(v_lcd);
+
+		/* disable v_ldo19 1.8v */
+		regulator_disable(v_1p8_ana);
+	}
+
+	gpio_free(lcd_rst_n);
+	gpio_free(lcd_en);
+	gpio_free(lcd_stby);
+
+	pr_debug("%s on %d\n", __func__, on);
+	return 0;
+
+gpio_free_v_lcd:
+	regulator_put(v_lcd);
+
+gpio_free_avdd:
+	regulator_put(v_1p8_ana);
+
+gpio_free_stby:
+	gpio_free(lcd_stby);
+
+gpio_free_en:
+	gpio_free(lcd_en);
+
+gpio_free_rst:
+	gpio_free(lcd_rst_n);
+	return -EIO;
+}
+#endif
+
+#ifdef CONFIG_MACH_ORCHID
+static int orchid_lcd_power(struct pxa168fb_info *fbi,
+			     unsigned int spi_gpio_cs,
+			     unsigned int spi_gpio_reset, int on)
+{
+	static struct regulator *lcd_iovdd, *lcd_avdd;
+	int lcd_rst_n;
+
+	lcd_rst_n = mfp_to_gpio(GPIO49_LCD_RST_N);
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", lcd_rst_n);
+		return -EIO;
+	}
+
+	/* LCD_IOVDD, 1.8v */
+	if (!lcd_iovdd) {
+		lcd_iovdd = regulator_get(NULL, "V_LDO15_1V8");
+		if (IS_ERR(lcd_iovdd)) {
+			pr_err("%s regulator get error!\n", __func__);
+			lcd_iovdd = NULL;
+			goto regu_lcd_iovdd;
+		}
+	}
+
+	/* LCD_AVDD 3.1v */
+	if (!lcd_avdd) {
+		lcd_avdd = regulator_get(NULL, "V_LDO17_3V1");
+		if (IS_ERR(lcd_avdd)) {
+			pr_err("%s regulator get error!\n", __func__);
+			lcd_avdd = NULL;
+			goto regu_lcd_avdd;
+		}
+	}
+
+	if (on) {
+		regulator_set_voltage(lcd_iovdd, 1800000, 1800000);
+		regulator_enable(lcd_iovdd);
+
+		regulator_set_voltage(lcd_avdd, 3100000, 3100000);
+		regulator_enable(lcd_avdd);
+
+		mdelay(50);
+		/* release panel from reset */
+		gpio_direction_output(lcd_rst_n, 1);
+		udelay(20);
+		gpio_direction_output(lcd_rst_n, 0);
+		udelay(50);
+		gpio_direction_output(lcd_rst_n, 1);
+	} else {
+		/* disable LCD_AVDD 3.1v */
+		regulator_disable(lcd_avdd);
+
+		/* disable LCD_IOVDD 1.8v */
+		regulator_disable(lcd_iovdd);
+
+		/* set panel reset */
+		gpio_direction_output(lcd_rst_n, 0);
+	}
+
+	gpio_free(lcd_rst_n);
+	pr_debug("%s on %d\n", __func__, on);
+
+	return 0;
+
+regu_lcd_iovdd:
+	gpio_free(lcd_rst_n);
+
+regu_lcd_avdd:
+	regulator_put(lcd_iovdd);
+
+	return -EIO;
+}
+#endif
+
+#ifdef CONFIG_MACH_EMEIDKB
+static int emeidkb_lcd_power(struct pxa168fb_info *fbi,
+			     unsigned int spi_gpio_cs,
+			     unsigned int spi_gpio_reset, int on)
+{
+	static struct regulator *lcd_iovdd, *lcd_avdd;
+	int lcd_rst_n;
+
+	/* FIXME:lcd reset,use GPIO_1 as lcd reset */
+	lcd_rst_n = 1;
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", lcd_rst_n);
+		return -EIO;
+	}
+
+	/* FIXME:LCD_IOVDD, 1.8v */
+	if (!lcd_iovdd) {
+		lcd_iovdd = regulator_get(NULL, "v_ldo15");
+		if (IS_ERR(lcd_iovdd)) {
+			pr_err("%s regulator get error!\n", __func__);
+			lcd_iovdd = NULL;
+			goto regu_lcd_iovdd;
+		}
+	}
+
+	/* FIXME:LCD_AVDD 3.1v */
+	if (!lcd_avdd) {
+		lcd_avdd = regulator_get(NULL, "v_ldo8");
+		if (IS_ERR(lcd_avdd)) {
+			pr_err("%s regulator get error!\n", __func__);
+			lcd_avdd = NULL;
+			goto regu_lcd_avdd;
+		}
+	}
+
+	if (on) {
+		regulator_set_voltage(lcd_avdd, 3100000, 3100000);
+		regulator_enable(lcd_avdd);
+		mdelay(5);
+
+		regulator_set_voltage(lcd_iovdd, 1800000, 1800000);
+		regulator_enable(lcd_iovdd);
+		mdelay(15);
+
+		/* release panel from reset */
+		gpio_direction_output(lcd_rst_n, 1);
+		udelay(20);
+		gpio_direction_output(lcd_rst_n, 0);
+		udelay(50);
+		gpio_direction_output(lcd_rst_n, 1);
+		mdelay(15);
+	} else {
+		/* disable LCD_AVDD 3.1v */
+		regulator_disable(lcd_avdd);
+
+		/* disable LCD_IOVDD 1.8v */
+		regulator_disable(lcd_iovdd);
+
+		/* set panel reset */
+		gpio_direction_output(lcd_rst_n, 0);
+	}
+
+	gpio_free(lcd_rst_n);
+	pr_debug("%s on %d\n", __func__, on);
+
+	return 0;
+
+regu_lcd_avdd:
+	regulator_put(lcd_iovdd);
+
+regu_lcd_iovdd:
+	gpio_free(lcd_rst_n);
+
+	return -EIO;
+}
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_MK2) || defined(CONFIG_MACH_QSEVEN)
+static struct lvds_info lvdsinfo = {
+	.src	= LVDS_SRC_PN,
+	.fmt	= LVDS_FMT_18BIT,
+};
+
+#if defined(CONFIG_MACH_THUNDERSTONEM)
+static struct lvds_info lvdsinfo_thunderstonem = {
+    .src    = LVDS_SRC_PN,
+    .fmt    = LVDS_FMT_24BIT,
+};
+#endif
+
+static void lvds_hook(struct pxa168fb_mach_info *mi)
+{
+	mi->phy_type = LVDS;
+	mi->phy_init = pxa688_lvds_init;
+	mi->phy_info = (void *)&lvdsinfo;
+
+	mi->modes->refresh = 60;
+
+	if (machine_is_yellowstone()) {
+#ifdef CONFIG_MACH_YELLOWSTONE
+		mi->phy_info = (void *)&lvdsinfo;
+		mi->pxa168fb_lcd_power = yellowstone_lvds_power;
+#endif
+	} else if (machine_is_abilene()) {
+#ifdef CONFIG_MACH_ABILENE
+		mi->phy_info = (void *)&lvdsinfo;
+		mi->pxa168fb_lcd_power = abilene_lvds_power;
+#endif
+	} else if (machine_is_thunderstonem()) {
+#if defined(CONFIG_MACH_THUNDERSTONEM)
+		mi->pxa168fb_lcd_power = thunderstonem_lvds_power;
+		mi->phy_info = (void *)&lvdsinfo_thunderstonem;
+#endif
+	}
+}
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_MK2) || defined(CONFIG_MACH_ORCHID) \
+	|| defined(CONFIG_MACH_EMEIDKB) || defined(CONFIG_MACH_QSEVEN)
+static void dither_config(struct pxa168fb_mach_info *mi)
+{
+	struct lvds_info *lvds;
+	struct dsi_info *dsi;
+	int bpp;
+
+	if (mi->phy_type == LVDS) {
+		lvds = (struct lvds_info *)mi->phy_info;
+		bpp = (lvds->fmt == LVDS_FMT_18BIT) ? 18 : 24;
+	} else {
+		dsi = (struct dsi_info *)mi->phy_info;
+		bpp = dsi->bpp;
+	}
+
+	if (bpp < 24) {
+		mi->dither_en = 1;
+		/* dither table was related to resolution
+		 * 4x4 table could be select for all cases.
+		 * we can select 4x8 table if xres is much
+		 * bigger than yres */
+		mi->dither_table = DITHER_TBL_4X4;
+		if (bpp == 18)
+			mi->dither_mode = DITHER_MODE_RGB666;
+		else if (bpp == 16)
+			mi->dither_mode = DITHER_MODE_RGB565;
+		else
+			mi->dither_mode = DITHER_MODE_RGB444;
+	}
+}
+#endif
+
+/*
+ * dsi bpp : rgb_mode
+ *    16   : DSI_LCD_INPUT_DATA_RGB_MODE_565;
+ *    24   : DSI_LCD_INPUT_DATA_RGB_MODE_888;
+ */
+static struct dsi_info dsiinfo = {
+	.id = 1,
+	.lanes = 4,
+	.bpp = 16,
+	.rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_565,
+	.burst_mode = DSI_BURST_MODE_BURST,
+	.hbp_en = 1,
+	.hfp_en = 1,
+};
+
+#ifdef CONFIG_MACH_ORCHID
+static struct dsi_info orchid_dsiinfo = {
+	.id = 2,
+	.lanes = 2,
+	.bpp = 24,
+	.rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_888,
+	.burst_mode = DSI_BURST_MODE_BURST,
+	.hbp_en = 1,
+	.hfp_en = 1,
+};
+#endif
+
+#ifdef CONFIG_MACH_EMEIDKB
+/* emeidkb: only DSI1 and use lane0,lane1 */
+static struct dsi_info emeidkb_dsiinfo = {
+	.id = 1,
+	.lanes = 2,
+	.bpp = 24,
+	.rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_888,
+	.burst_mode = DSI_BURST_MODE_BURST,
+	.hbp_en = 1,
+	.hfp_en = 1,
+};
+#endif
+
+#ifdef CONFIG_TC35876X
+static int tc358765_reset(struct pxa168fb_info *fbi)
+{
+	int gpio;
+
+#ifdef CONFIG_MACH_BROWNSTONE
+	gpio = mfp_to_gpio(GPIO83_LCD_RST);
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_MK2) || defined(CONFIG_MACH_THUNDERSTONEM)
+	gpio = mfp_to_gpio(GPIO128_LCD_RST);
+#endif
+
+	if (gpio_request(gpio, "lcd reset gpio")) {
+		printk(KERN_INFO "gpio %d request failed\n", gpio);
+		return -1;
+	}
+
+	gpio_direction_output(gpio, 0);
+	mdelay(10);
+	gpio_direction_output(gpio, 1);
+	mdelay(4);
+
+	gpio_free(gpio);
+	return 0;
+}
+
+static void tc358765_dump(void)
+{
+#if tc358765_dump_debug
+	u32 val;
+
+	pr_info("%s\n", __func__);
+	tc35876x_read32(PPI_TX_RX_TA, &val);
+	pr_info(" - PPI_TX_RX_TA = 0x%x\n", val);
+	tc35876x_read32(PPI_LPTXTIMECNT, &val);
+	pr_info(" - PPI_LPTXTIMECNT = 0x%x\n", val);
+	tc35876x_read32(PPI_D0S_CLRSIPOCOUNT, &val);
+	pr_info(" - PPI_D0S_CLRSIPOCOUNT = 0x%x\n", val);
+	tc35876x_read32(PPI_D1S_CLRSIPOCOUNT, &val);
+	pr_info(" - PPI_D1S_CLRSIPOCOUNT = 0x%x\n", val);
+
+	tc35876x_read32(PPI_D2S_CLRSIPOCOUNT, &val);
+	pr_info(" - PPI_D2S_CLRSIPOCOUNT = 0x%x\n", val);
+	tc35876x_read32(PPI_D3S_CLRSIPOCOUNT, &val);
+	pr_info(" - PPI_D3S_CLRSIPOCOUNT = 0x%x\n", val);
+
+	tc35876x_read32(PPI_LANEENABLE, &val);
+	pr_info(" - PPI_LANEENABLE = 0x%x\n", val);
+	tc35876x_read32(DSI_LANEENABLE, &val);
+	pr_info(" - DSI_LANEENABLE = 0x%x\n", val);
+	tc35876x_read32(PPI_STARTPPI, &val);
+	pr_info(" - PPI_STARTPPI = 0x%x\n", val);
+	tc35876x_read32(DSI_STARTDSI, &val);
+	pr_info(" - DSI_STARTDSI = 0x%x\n", val);
+
+	tc35876x_read32(VPCTRL, &val);
+	pr_info(" - VPCTRL = 0x%x\n", val);
+	tc35876x_read32(HTIM1, &val);
+	pr_info(" - HTIM1 = 0x%x\n", val);
+	tc35876x_read32(HTIM2, &val);
+	pr_info(" - HTIM2 = 0x%x\n", val);
+	tc35876x_read32(VTIM1, &val);
+	pr_info(" - VTIM1 = 0x%x\n", val);
+	tc35876x_read32(VTIM2, &val);
+	pr_info(" - VTIM2 = 0x%x\n", val);
+	tc35876x_read32(VFUEN, &val);
+	pr_info(" - VFUEN = 0x%x\n", val);
+	tc35876x_read32(LVCFG, &val);
+	pr_info(" - LVCFG = 0x%x\n", val);
+
+	tc35876x_read32(DSI_INTSTAUS, &val);
+	pr_info("!! - DSI_INTSTAUS= 0x%x BEFORE\n", val);
+	tc35876x_write32(DSI_INTCLR, 0xFFFFFFFF);
+	tc35876x_read32(DSI_INTSTAUS, &val);
+	pr_info("!! - DSI_INTSTAUS= 0x%x AFTER\n", val);
+
+	tc35876x_read32(DSI_LANESTATUS0, &val);
+	pr_info(" - DSI_LANESTATUS0= 0x%x\n", val);
+	tc35876x_read32(DSIERRCNT, &val);
+	pr_info(" - DSIERRCNT= 0x%x\n", val);
+	tc35876x_read32(DSIERRCNT, &val);
+	pr_info(" - DSIERRCNT= 0x%x AGAIN\n", val);
+	tc35876x_read32(SYSSTAT, &val);
+	pr_info(" - SYSSTAT= 0x%x\n", val);
+#endif
+}
+
+static int dsi_set_tc358765(struct pxa168fb_info *fbi)
+{
+	int status;
+	struct fb_var_screeninfo *var = &(fbi->fb_info->var);
+	struct dsi_info *di = &dsiinfo;
+	u16 chip_id = 0;
+
+	status = tc35876x_read16(TC358765_CHIPID_REG, &chip_id);
+	if ((status < 0) || (chip_id != TC358765_CHIPID)) {
+		pr_err("tc35876x unavailable! chip_id %x\n", chip_id);
+		return -EIO;
+	} else
+		pr_debug("tc35876x(chip id:0x%02x) detected.\n", chip_id);
+
+	/* REG 0x13C,DAT 0x000C000F */
+	tc35876x_write32(PPI_TX_RX_TA, 0x00040004);
+	/* REG 0x114,DAT 0x0000000A */
+	tc35876x_write32(PPI_LPTXTIMECNT, 0x00000004);
+
+	/* get middle value of mim-max value
+	 * 0-0x13 for 2lanes-rgb888, 0-0x26 for 4lanes-rgb888
+	 * 0-0x21 for 2lanes-rgb565, 0-0x25 for 4lanes-rgb565
+	 */
+	if (di->lanes == 4)
+		status = 0x13;
+	else if (di->bpp == 24)
+		status = 0xa;
+	else
+		status = 0x11;
+	/* REG 0x164,DAT 0x00000005 */
+	tc35876x_write32(PPI_D0S_CLRSIPOCOUNT, status);
+	/* REG 0x168,DAT 0x00000005 */
+	tc35876x_write32(PPI_D1S_CLRSIPOCOUNT, status);
+	if (di->lanes == 4) {
+		/* REG 0x16C,DAT 0x00000005 */
+		tc35876x_write32(PPI_D2S_CLRSIPOCOUNT, status);
+		/* REG 0x170,DAT 0x00000005 */
+		tc35876x_write32(PPI_D3S_CLRSIPOCOUNT, status);
+	}
+
+	/* REG 0x134,DAT 0x00000007 */
+	tc35876x_write32(PPI_LANEENABLE, (di->lanes == 4) ? 0x1f : 0x7);
+	/* REG 0x210,DAT 0x00000007 */
+	tc35876x_write32(DSI_LANEENABLE, (di->lanes == 4) ? 0x1f : 0x7);
+
+	/* REG 0x104,DAT 0x00000001 */
+	tc35876x_write32(PPI_STARTPPI, 0x0000001);
+	/* REG 0x204,DAT 0x00000001 */
+	tc35876x_write32(DSI_STARTDSI, 0x0000001);
+
+	/* REG 0x450,DAT 0x00012020, VSDELAY = 8 pixels,
+	 * enable magic square if in_bpp == 24, out_bpp == 18 */
+	tc35876x_write32(VPCTRL, 0x00800020 | (di->bpp == 24 ? 1 : 0));
+
+	/* REG 0x454,DAT 0x00200008*/
+	tc35876x_write32(HTIM1, ((var->left_margin) << 16)
+			| var->hsync_len);
+
+	/* REG 0x45C,DAT 0x00040004*/
+	tc35876x_write32(VTIM1, ((var->upper_margin) << 16)
+			| var->vsync_len);
+
+	/* REG 0x49C,DAT 0x00000201 */
+	tc35876x_write32(LVCFG, 0x00000001);
+
+	/* dump register value */
+	tc358765_dump();
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MACH_ORCHID) || defined(CONFIG_MACH_EMEIDKB)
+static void panel_init_config(struct pxa168fb_info *fbi)
+{
+	enum dsi_packet_di data_type;
+	enum dsi_packet_dcs_id dcs;
+
+	set_dsi_low_power_mode(fbi);
+
+	data_type = DSI_DI_DCS_WRITE_N;
+	dcs = DSI_DCS_SLEEP_EXIT;
+	dsi_send_cmd(fbi, data_type, dcs, 0);
+	mdelay(200);
+
+	dcs = DSI_DCS_DISPLAY_ON;
+	dsi_send_cmd(fbi, data_type, dcs, 0);
+}
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+static int lcd_twsi5_set(int en)
+{
+	int gpio;
+	mfp_cfg_t mfp_gpio99_gpio = MFP_CFG_X(GPIO99, AF0, MEDIUM, PULL_HIGH)
+								| MFP_PULL_HIGH;
+	mfp_cfg_t mfp_gpio100_gpio = MFP_CFG_X(GPIO100, AF0, MEDIUM, PULL_HIGH)
+								| MFP_PULL_HIGH;
+	mfp_cfg_t mfp_gpio99_twsi5 = GPIO99_TWSI5_SCL;
+	mfp_cfg_t mfp_gpio100_twsi5 = GPIO100_TWSI5_SDA;
+
+	if (en) {
+		mfp_config(&mfp_gpio99_twsi5, 1);
+		mfp_config(&mfp_gpio100_twsi5, 1);
+	} else {
+		mfp_config(&mfp_gpio99_gpio, 1);
+		mfp_config(&mfp_gpio100_gpio, 1);
+
+		gpio = mfp_to_gpio(GPIO99_GPIO);
+		if (gpio_request(gpio, "gpio99")) {
+			printk(KERN_INFO "gpio %d request failed\n", gpio);
+			return -1;
+		}
+		gpio_direction_output(gpio, 0);
+		gpio_free(gpio);
+
+		gpio = mfp_to_gpio(GPIO100_GPIO);
+		if (gpio_request(gpio, "gpio100")) {
+			printk(KERN_INFO "gpio %d request failed\n", gpio);
+			return -1;
+		}
+		gpio_direction_output(gpio, 0);
+		gpio_free(gpio);
+	}
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_QSEVEN)
+static int backlight_pwm_set(int en)
+{
+	int gpio;
+	mfp_cfg_t gpio53_gpio = MFP_CFG_ALL(GPIO53, AF0,
+				MEDIUM, PULL_HIGH, PULL_HIGH);
+
+	mfp_config(&gpio53_gpio, 1);
+	gpio = mfp_to_gpio(GPIO53_GPIO);
+	if (gpio_request(gpio, "gpio53")) {
+		printk(KERN_INFO "gpio %d request failed\n", gpio);
+		return -1;
+	}
+
+	if (en)
+		gpio_direction_output(gpio, 1);
+	else
+		gpio_direction_output(gpio, 0);
+
+	gpio_free(gpio);
+	return 0;
+}
+
+static int abilene_lcd_power(struct pxa168fb_info *fbi,
+			     unsigned int spi_gpio_cs,
+			     unsigned int spi_gpio_reset, int on)
+{
+	struct regulator *v_ldo = NULL;
+	int lcd_rst_n;
+	/*
+	 * FIXME: It is board related, baceuse zx will be replaced soon,
+	 * it is temproary distinguished by cpu
+	 */
+#ifdef CONFIG_MACH_QSEVEN
+	return 0;
+#endif
+	lcd_rst_n = mfp_to_gpio(GPIO128_LCD_RST);
+
+	/* set LDOs 17 and 03 to 1.2V for MIPI Bridge */
+	if (on) {
+		/* v_ldo17 1.2v */
+		v_ldo = regulator_get(NULL, "v_ldo17");
+		if (IS_ERR(v_ldo))
+			v_ldo = NULL;
+		else {
+			regulator_enable(v_ldo);
+			regulator_set_voltage(v_ldo, 1200000, 1200000);
+			/* regulator_put(v_ldo); */
+		}
+		/* v_ldo3 1.2v */
+		v_ldo = regulator_get(NULL, "v_ldo3");
+		if (IS_ERR(v_ldo))
+			v_ldo = NULL;
+		else {
+			regulator_enable(v_ldo);
+			regulator_set_voltage(v_ldo, 1200000, 1200000);
+			/* regulator_put(v_ldo); */
+		}
+	} else {
+		/* disable v_ldo03 1.2v */
+		v_ldo = regulator_get(NULL, "v_ldo3");
+		if (IS_ERR(v_ldo))
+			v_ldo = NULL;
+		else
+			regulator_disable(v_ldo);
+		/* disable v_ldo17 1.2v */
+		v_ldo = regulator_get(NULL, "v_ldo17");
+		if (IS_ERR(v_ldo))
+			v_ldo = NULL;
+		else
+			regulator_disable(v_ldo);
+	}
+
+	/* set panel reset */
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		printk(KERN_INFO "gpio %d request failed\n", lcd_rst_n);
+		return -1;
+	}
+	if (on) {
+		gpio_direction_output(lcd_rst_n, 1);
+		/* FIXME workaround for Abilene Rev5 backlight issue */
+#ifdef CONFIG_MACH_ABILENE
+		if (machine_is_abilene() && cpu_is_mmp3_b0()) {
+			mdelay(100);
+			backlight_pwm_set(1);
+		}
+#endif
+	} else {
+		gpio_direction_output(lcd_rst_n, 0);
+		/* FIXME workaround for Abilene Rev5 backlight issue */
+#ifdef CONFIG_MACH_ABILENE
+		if (machine_is_abilene() && cpu_is_mmp3_b0())
+			backlight_pwm_set(0);
+#endif
+	}
+	gpio_free(lcd_rst_n);
+
+	printk(KERN_DEBUG "%s on %d\n", __func__, on);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_MACH_MK2
+static int  mk2_lcd_power_en(int on)
+{
+	int vlcd_3v3_en;
+
+	vlcd_3v3_en = mfp_to_gpio(GPIO152_VLCD_3V3);
+	if (gpio_request(vlcd_3v3_en, "vlcd 3v3 gpio")) {
+		pr_err("gpio %d request failed\n", vlcd_3v3_en);
+		return -EIO;
+	}
+
+	if (on)
+		gpio_direction_output(vlcd_3v3_en, 1);
+	else
+		gpio_direction_output(vlcd_3v3_en, 0);
+	gpio_free(vlcd_3v3_en);
+
+	return 0;
+}
+
+static int mk2_lcd_power(struct pxa168fb_info *fbi,
+			     unsigned int spi_gpio_cs,
+			     unsigned int spi_gpio_reset, int on)
+{
+	static struct regulator *mipi_1p2v = NULL,
+		*mipi_logic_1p2v = NULL;
+	int mipi_rst, bl_en;
+
+	/*
+	 * FIXME: It is board related, baceuse zx will be replaced soon,
+	 * it is temproary distinguished by cpu
+	 */
+	mipi_rst = mfp_to_gpio(GPIO128_LCD_RST);
+	if (gpio_request(mipi_rst, "lcd reset gpio")) {
+		pr_err("gpio %d request failed\n", mipi_rst);
+		return -EIO;
+	}
+
+	bl_en = mfp_to_gpio(GPIO17_BL_EN);
+	if (gpio_request(bl_en, "lcd bl_en gpio")) {
+		pr_err("gpio %d request failed\n", bl_en);
+		goto gpio_req_bl_en;
+	}
+
+	/* pmic_1p2v_mipi, 1.2v */
+	if (!mipi_1p2v) {
+		mipi_1p2v = regulator_get(NULL, "PMIC_LDO1");
+		if (IS_ERR(mipi_1p2v)) {
+			pr_err("%s regulator get error!\n", __func__);
+			mipi_1p2v = NULL;
+			goto regu_mipi_1p2v;
+		}
+	}
+
+	/* pmic_1p2v_mipi_logic, 1.2v */
+	if (!mipi_logic_1p2v) {
+		mipi_logic_1p2v = regulator_get(NULL, "PMIC_LDO7");
+		if (IS_ERR(mipi_logic_1p2v)) {
+			pr_err("%s regulator get error!\n", __func__);
+			mipi_logic_1p2v = NULL;
+			goto regu_mipi_logic_1p2v;
+		}
+	}
+
+	if (on) {
+		mk2_lcd_power_en(1);
+
+		regulator_set_voltage(mipi_1p2v, 1200000, 1200000);
+		regulator_enable(mipi_1p2v);
+
+		regulator_set_voltage(mipi_logic_1p2v, 1200000, 1200000);
+		regulator_enable(mipi_logic_1p2v);
+
+		/* release panel from reset */
+		gpio_direction_output(mipi_rst, 1);
+		gpio_direction_output(bl_en, 1);
+	} else {
+		gpio_direction_output(bl_en, 0);
+		/* set panel reset */
+		gpio_direction_output(mipi_rst, 0);
+
+		regulator_disable(mipi_logic_1p2v);
+
+		regulator_disable(mipi_1p2v);
+
+		mk2_lcd_power_en(0);
+	}
+
+	gpio_free(mipi_rst);
+	gpio_free(bl_en);
+	pr_debug("%s on %d\n", __func__, on);
+
+	return 0;
+
+regu_mipi_logic_1p2v:
+	regulator_put(mipi_1p2v);
+
+regu_mipi_1p2v:
+	gpio_free(bl_en);
+
+gpio_req_bl_en:
+	gpio_free(mipi_rst);
+	return -EIO;
+}
+#endif
+
+static int dsi_init(struct pxa168fb_info *fbi)
+{
+#ifdef CONFIG_PXA688_PHY
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	int ret = 0;
+
+	/* reset DSI controller */
+	dsi_reset(fbi, 1);
+	mdelay(1);
+
+	/* disable continuous clock */
+	dsi_cclk_set(fbi, 0);
+
+	/* dsi out of reset */
+	dsi_reset(fbi, 0);
+
+	/* turn on DSI continuous clock */
+	dsi_cclk_set(fbi, 1);
+
+	/* set dphy */
+	dsi_set_dphy(fbi);
+
+	/* init panel settings via dsi */
+	if (mi->phy_type == DSI)
+		mi->dsi_panel_config(fbi);
+
+	/* put all lanes to LP-11 state  */
+	dsi_lanes_enable(fbi, 0);
+	dsi_lanes_enable(fbi, 1);
+
+	/*  reset the bridge */
+	if (mi->xcvr_reset) {
+		mi->xcvr_reset(fbi);
+		mdelay(10);
+	}
+
+	/* set dsi controller */
+	dsi_set_controller(fbi);
+
+	/* set dsi to dpi conversion chip */
+	if (mi->phy_type == DSI2DPI) {
+		ret = mi->dsi2dpi_set(fbi);
+		if (ret < 0)
+			pr_err("dsi2dpi_set error!\n");
+	}
+#endif
+	return 0;
+}
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_MK2) || defined(CONFIG_MACH_ORCHID) \
+	|| defined(CONFIG_MACH_EMEIDKB) || defined(CONFIG_MACH_THUNDERSTONEM) \
+	|| defined(CONFIG_MACH_QSEVEN)
+static struct pxa168fb_mach_info mipi_lcd_info = {
+	.id = "GFX Layer",
+	.num_modes = 0,
+	.modes = NULL,
+	.sclk_div = 0xE0001108,
+	.pix_fmt = PIX_FMT_RGB565,
+	.isr_clear_mask	= LCD_ISR_CLEAR_MASK_PXA168,
+	/* don't care about io_pin_allocation_mode and dumb_mode
+	 * since the panel is hard connected with lcd panel path and
+	 * dsi1 output
+	 */
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 1,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+	.mmap = 1,
+	.vdma_enable = 1,
+	.sram_size  = 30 * 1024,
+	.max_fb_size = 3840 * 1080 * 8 + 4096,
+	.phy_type = DSI2DPI,
+	.phy_init = dsi_init,
+#ifdef CONFIG_TC35876X
+	.dsi2dpi_set = dsi_set_tc358765,
+	.xcvr_reset = tc358765_reset,
+#endif
+	.phy_info = &dsiinfo,
+	.sclk_src = 520000000,
+};
+
+static struct pxa168fb_mach_info mipi_lcd_ovly_info = {
+	.id = "Video Layer",
+	.num_modes = 0,
+	.modes = NULL,
+	.pix_fmt = PIX_FMT_RGB565,
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena = 0,
+	.invert_pixclock = 0,
+	.panel_rbswap = 0,
+	.active = 1,
+	.enable_lcd = 1,
+	.spi_gpio_cs = -1,
+	.spi_gpio_reset = -1,
+	.mmap = 0,
+	.max_fb_size = 0,
+	.vdma_enable = 0,
+	.sram_size = 30 * 1024,
+};
+
+#define     DSI1_BITCLK(div)			((div)<<8)
+#define     DSI1_BITCLK_DIV_MASK		0x00000F00
+#define     CLK_INT_DIV(div)			(div)
+#define     CLK_INT_DIV_MASK			0x000000FF
+static void calculate_dsi_clk(struct pxa168fb_mach_info *mi)
+{
+	struct dsi_info *di = (struct dsi_info *)mi->phy_info;
+	struct fb_videomode *modes = &mi->modes[0];
+	u32 total_w, total_h, pclk2bclk_rate, byteclk, bitclk,
+	    pclk_div, bitclk_div = 1;
+
+	if (!di)
+		return;
+
+	/*
+	 * When DSI is used to refresh panel, the timing configuration should
+	 * follow the rules below:
+	 * 1.Because Async fifo exists between the pixel clock and byte clock
+	 *   domain, so there is no strict ratio requirement between pix_clk
+	 *   and byte_clk, we just need to meet the following inequation to
+	 *   promise the data supply from LCD controller:
+	 *   pix_clk * (nbytes/pixel) >= byte_clk * lane_num
+	 *   (nbyte/pixel: the real byte in DSI transmission)
+	 *   a)16-bit format n = 2; b) 18-bit packed format n = 18/8 = 9/4;
+	 *   c)18-bit unpacked format  n=3; d)24-bit format  n=3;
+	 *   if lane_num = 1 or 2, we can configure pix_clk/byte_clk = 1:1 >
+	 *   lane_num/nbytes/pixel
+	 *   if lane_num = 3 or 4, we can configure pix_clk/byte_clk = 2:1 >
+	 *   lane_num/nbytes/pixel
+	 * 2.The horizontal sync for LCD is synchronized from DSI,
+	 *    so the refresh rate calculation should base on the
+	 *    configuration of DSI.
+	 *    byte_clk = (h_total * nbytes/pixel) * v_total * fps / lane_num;
+	 */
+	total_w = modes->xres + modes->left_margin +
+		 modes->right_margin + modes->hsync_len;
+	total_h = modes->yres + modes->upper_margin +
+		 modes->lower_margin + modes->vsync_len;
+
+	pclk2bclk_rate = (di->lanes > 2) ? 2 : 1;
+	byteclk = ((total_w * (di->bpp >> 3)) * total_h *
+			 modes->refresh) / di->lanes;
+	bitclk = byteclk << 3;
+
+	/* The minimum of DSI pll is 150MHz */
+	if (bitclk < 150000000)
+		bitclk_div = 150000000 / bitclk + 1;
+
+	mi->sclk_src = bitclk * bitclk_div;
+	/*
+	 * mi->sclk_src = pclk * pclk_div;
+	 * pclk / bitclk  = pclk / (8 * byteclk) = pclk2bclk_rate / 8;
+	 * pclk_div / bitclk_div = 8 / pclk2bclk_rate;
+	 */
+	pclk_div = (bitclk_div << 3) / pclk2bclk_rate;
+
+	mi->sclk_div &= ~(DSI1_BITCLK_DIV_MASK | CLK_INT_DIV_MASK);
+	mi->sclk_div |= DSI1_BITCLK(bitclk_div) | CLK_INT_DIV(pclk_div);
+}
+
+static void calculate_lvds_clk(struct pxa168fb_mach_info *mi)
+{
+	struct fb_videomode *modes = &mi->modes[0];
+	u32 total_w, total_h, pclk, div, use_pll1, calc_clk, calc_clk1;
+	u32 calc_div;
+
+	total_w = modes->xres + modes->left_margin +
+		modes->right_margin + modes->hsync_len;
+	total_h = modes->yres + modes->upper_margin +
+		modes->lower_margin + modes->vsync_len;
+
+	pclk = total_w * total_h * modes->refresh;
+
+	calc_div = 800000000 / pclk;
+	calc_clk = 800000000 / calc_div;
+	pr_info("For pclk %u\n", pclk);
+
+	if (pclk < (calc_clk - 10000000)) {
+		use_pll1 = 0;
+		pr_info("Using pll2 for LCD Controller........\n");
+	} else {
+		use_pll1 = 1;
+		pr_info("Using pll1 for LCD Controller.........\n");
+	}
+	/* use pll1 by default
+	* we could set a more flexible clocking options by selecting pll3
+	* or pll2 in else loops, right now sticking it to pll1 for qseven
+	*/
+#ifdef CONFIG_MACH_QSEVEN_0
+	use_pll1 = 1;
+#endif
+
+	if (use_pll1) {
+		/* src clock is 800MHz */
+		div = 800000000 / pclk;
+		calc_clk = 800000000 / div;
+		calc_clk1 = 800000000 / (div + 1);
+
+		if ((calc_clk - pclk) < (calc_clk1 - pclk))
+			pr_info("calculated clock final %u\n", calc_clk);
+		else {
+			pr_info("calculated clock final %u\n", calc_clk1);
+			div++;
+		}
+		mi->sclk_src = 800000000;
+		mi->sclk_div = 0x20000000 | div;
+	} else {
+		div = 1200000000 / pclk;
+		calc_clk = 1200000000 / div;
+		calc_clk1 = 1200000000 / (div + 1);
+		if ((calc_clk - pclk) < (calc_clk1 - pclk))
+			pr_info("calculated clock final %u\n", calc_clk);
+		else {
+			pr_info("calculated clock final %u\n", calc_clk1);
+			div++;
+		}
+		mi->sclk_src = 1200000000;
+		mi->sclk_div = 0x20000000 | div;
+	}
+
+	pr_info("\n%s sclk_src %d sclk_div 0x%x\n", __func__,
+			mi->sclk_src, mi->sclk_div);
+}
+
+static void calculate_lcd_sclk(struct pxa168fb_mach_info *mi)
+{
+
+	if (mi->phy_type & (DSI | DSI2DPI))
+		calculate_dsi_clk(mi);
+	else if (mi->phy_type & LVDS)
+		calculate_lvds_clk(mi);
+	else
+		return;
+}
+#endif
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_YELLOWSTONE) \
+	|| defined(CONFIG_MACH_MK2) || defined(CONFIG_MACH_ORCHID) \
+	|| defined(CONFIG_MACH_BROWNSTONE) || defined(CONFIG_MACH_THUNDERSTONEM) \
+	|| defined(CONFIG_MACH_QSEVEN)
+static void vsmooth_init(int vsmooth_ch, int filter_ch)
+{
+#ifdef CONFIG_PXA688_MISC
+	/* set TV path vertical smooth, panel2 as filter channel,
+	 * vertical smooth is disabled by default to avoid underrun
+	 * when video playback, to enable/disable graphics/video
+	 * layer vertical smooth:
+	 * echo g0/g1/v0/v1 > /sys/deivces/platform/pxa168-fb.1/misc
+	 */
+	fb_vsmooth = vsmooth_ch; fb_filter = filter_ch;
+#endif
+}
+#endif
+
+#define DDR_MEM_CTRL_BASE 0xD0000000
+#define SDRAM_CONFIG_TYPE1_CS0 0x20	/* MMP3 */
+
+#if defined(CONFIG_MACH_ABILENE) || defined(CONFIG_MACH_QSEVEN)
+void __init abilene_add_lcd_mipi(void)
+{
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL, lvds_en;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_abilene);
+	fb->modes = video_modes_abilene;
+#ifdef CONFIG_MACH_QSEVEN
+	fb->max_fb_size = 4000 * 1100 * 8 + 4096;
+#else
+	fb->max_fb_size = video_modes_abilene[0].xres *
+		video_modes_abilene[0].yres * 8 + 4096;
+#endif
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+	fb->pxa168fb_lcd_power = &abilene_lcd_power;
+
+	/* FIXME: select DSI2LVDS by default on abilene. */
+#ifdef CONFIG_MACH_QSEVEN
+	lvds_en = 1;
+#else
+	lvds_en = 0;
+#endif
+
+#ifndef CONFIG_MACH_QSEVEN
+	if (cpu_is_mmp3_b0()) {
+		if (lvds_en)
+			lvds_hook(fb);
+		dither_config(fb);
+	}
+#else
+	if (cpu_is_mmp3_b1()) {
+		if (lvds_en)
+			lvds_hook(fb);
+		dither_config(fb);
+	}
+#endif
+	if (fb->phy_type & (DSI | DSI2DPI)) {
+		dsi = (struct dsi_info *)fb->phy_info;
+		dsi->master_mode = 1;
+		dsi->hfp_en = 0;
+		if (dsi->bpp == 16)
+			video_modes_abilene[0].right_margin =
+			(dsi->lanes == 4) ? 325 : 179;
+		else if (dsi->bpp == 24)
+			video_modes_abilene[0].right_margin =
+			(dsi->lanes == 4) ? 206 : 116;
+	}
+
+	/* Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	calculate_lcd_sclk(fb);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0x30);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG_TYPE1_CS0) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+	/* add frame buffer drivers */
+	mmp3_add_fb(fb);
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_ovly(ovly);
+#else
+	mmp3_add_fb_ovly(ovly);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
+
+#ifdef CONFIG_MACH_YELLOWSTONE
+void __init yellowstone_add_lcd_mipi(void)
+{
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_yellowstone);
+	fb->modes = video_modes_yellowstone;
+	fb->max_fb_size = video_modes_yellowstone[0].xres *
+		video_modes_yellowstone[0].yres * 8 + 4096;
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+	fb->pxa168fb_lcd_power = &abilene_lcd_power;
+
+	if (cpu_is_mmp3_b0()) {
+		lvds_hook(fb);
+		dither_config(fb);
+	}
+
+	if (fb->phy_type & (DSI | DSI2DPI)) {
+		dsi = (struct dsi_info *)fb->phy_info;
+		dsi->master_mode = 1;
+		dsi->hfp_en = 0;
+		if (dsi->bpp == 16)
+			video_modes_yellowstone[0].right_margin =
+			(dsi->lanes == 4) ? 325 : 179;
+		else if (dsi->bpp == 24)
+			video_modes_yellowstone[0].right_margin =
+			(dsi->lanes == 4) ? 206 : 116;
+	}
+
+	/* Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	calculate_lcd_sclk(fb);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0x30);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG_TYPE1_CS0) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+	/* add frame buffer drivers */
+	mmp3_add_fb(fb);
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_ovly(ovly);
+#else
+	mmp3_add_fb_ovly(ovly);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
+
+#ifdef CONFIG_MACH_THUNDERSTONEM
+void __init thunderstonem_add_lcd_mipi(void)
+{
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_thunderstonem);
+	fb->modes = video_modes_thunderstonem;
+	fb->max_fb_size = video_modes_thunderstonem[0].xres *
+		video_modes_thunderstonem[0].yres * 8 + 4096;
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	lvds_hook(fb);
+
+	/* Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	calculate_lcd_sclk(fb);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0x30);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG_TYPE1_CS0) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+	/* add frame buffer drivers */
+	mmp3_add_fb(fb);
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_ovly(ovly);
+#else
+	mmp3_add_fb_ovly(ovly);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
+
+#ifdef CONFIG_MACH_ORCHID
+void __init orchid_add_lcd_mipi(void)
+{
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_orchid);
+	fb->modes = video_modes_orchid;
+	fb->max_fb_size = video_modes_orchid[0].xres *
+		video_modes_orchid[0].yres * 8 + 4096;
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	fb->phy_type = DSI;
+	fb->xcvr_reset = NULL;
+	fb->phy_info = (void *)&orchid_dsiinfo;
+	fb->dsi_panel_config = panel_init_config;
+	fb->pxa168fb_lcd_power = orchid_lcd_power;
+	dsi = (struct dsi_info *)fb->phy_info;
+	dsi->master_mode = 1;
+	dsi->hfp_en = 0;
+
+	if (cpu_is_mmp3_b0())
+		dither_config(fb);
+
+	/* Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	calculate_lcd_sclk(fb);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0x30);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG_TYPE1_CS0) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+	/* add frame buffer drivers */
+	mmp3_add_fb(fb);
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_ovly(ovly);
+#else
+	mmp3_add_fb_ovly(ovly);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
+
+#ifdef CONFIG_MACH_MK2
+void __init mk2_add_lcd_mipi(void)
+{
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL, lvds_en;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_mk2);
+	fb->modes = video_modes_mk2;
+	fb->max_fb_size = video_modes_mk2[0].xres *
+		video_modes_mk2[0].yres * 8 + 4096;
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	/* FIXME: V_LCD_3P3V enabled firstly,
+	 * there would be a blank flicker if not */
+	mk2_lcd_power_en(1);
+	fb->pxa168fb_lcd_power = mk2_lcd_power;
+
+	/* FIXME: select DSI2LVDS by default on mk2. */
+	lvds_en = 0;
+	if (cpu_is_mmp3_b0()) {
+		if (lvds_en)
+			lvds_hook(fb);
+		dither_config(fb);
+	}
+
+	if (fb->phy_type & (DSI | DSI2DPI)) {
+		dsi = (struct dsi_info *)fb->phy_info;
+		dsi->master_mode = 1;
+		dsi->hfp_en = 0;
+	}
+
+	/* Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	calculate_lcd_sclk(fb);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0x30);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG_TYPE1_CS0) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+	/* add frame buffer drivers */
+	mmp3_add_fb(fb);
+	/* add overlay driver */
+#ifdef CONFIG_PXA168_V4L2_OVERLAY
+	mmp3_add_v4l2_ovly(ovly);
+#else
+	mmp3_add_fb_ovly(ovly);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
+
+#ifdef CONFIG_MACH_EMEIDKB
+void __init emeidkb_add_lcd_mipi(void)
+{
+	unsigned int CSn_NO_COL;
+	struct dsi_info *dsi;
+
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_emeidkb);
+	if (QHD_PANEL == is_qhd_lcd())
+		fb->modes = video_modes_emeidkb;
+	else
+		fb->modes = video_modes_HVGA_VNC_emeidkb;
+	fb->max_fb_size = ALIGN(fb->modes->xres, 16) *
+		fb->modes->yres * 8 + 4096;
+
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	fb->phy_type = DSI;
+	fb->xcvr_reset = NULL;
+	fb->phy_info = (void *)&emeidkb_dsiinfo;
+	fb->dsi_panel_config = panel_init_config;
+	fb->pxa168fb_lcd_power = emeidkb_lcd_power;
+
+	/* For EMEIDKB, there is not vdma */
+	fb->vdma_enable = 0;
+	fb->sram_size = 0;
+
+	dsi = (struct dsi_info *)fb->phy_info;
+	dsi->master_mode = 1;
+	dsi->hfp_en = 0;
+
+	dither_config(fb);
+	/*
+	 * Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	if (QHD_PANEL == is_qhd_lcd())
+		calculate_lcd_sclk(fb);
+	else {
+	/*
+	 * FIXME:rewrite sclk_src, otherwise VNC will
+	 * use 520000000 as sclk_src so that clock source
+	 * will be set 624M
+	 * */
+	fb->sclk_src = 416000000;
+	/* FIXME: change pixel clk divider for HVGA for fps 60 */
+	fb->sclk_div = 0xE000141b;
+	}
+
+	/*
+	 * FIXME:EMEI dkb use display clk1 as clk source,
+	 * which is from PLL1 416MHZ. PLL3 1GHZ will be used
+	 * for cpu core,and can't be DSI clock source specially.
+	 */
+	fb->sclk_div &= 0x0fffffff;
+	fb->sclk_div |= 0x40000000;
+
+	CSn_NO_COL = __raw_readl(DMCU_VIRT_BASE + DMCU_SDRAM_CFG0_TYPE1) >> 4;
+	CSn_NO_COL &= 0xF;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		 *If DDR page size < 4KB,
+		 *select no crossing 1KB boundary check
+		 */
+		fb->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+		ovly->io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+
+	/* add frame buffer drivers */
+	pxa988_add_fb(fb);
+	/* add overlay driver */
+}
+
+#ifdef CONFIG_PXA988_LCD_PARALLEL
+void __init emeidkb_add_lcd_mipi_tv(void)
+{
+	struct pxa168fb_mach_info *fb = &mipi_lcd_info, *ovly =
+	    &mipi_lcd_ovly_info;
+
+	fb->num_modes = ARRAY_SIZE(video_modes_emeidkb);
+	fb->modes = video_modes_emeidkb;
+	fb->max_fb_size = video_modes_emeidkb[0].xres *
+		video_modes_emeidkb[0].yres * 8 + 4096;
+	ovly->num_modes = fb->num_modes;
+	ovly->modes = fb->modes;
+	ovly->max_fb_size = fb->max_fb_size;
+
+	fb->mmap = 0;
+	fb->phy_init = NULL;
+	/* remove dsi part for tv path */
+	fb->phy_type = DSI;
+	fb->xcvr_reset = NULL;
+	fb->phy_info = (void *)&emeidkb_dsiinfo;
+	fb->dsi_panel_config = NULL;
+	fb->pxa168fb_lcd_power = NULL;
+
+	/* For EMEIDKB, there is not vdma */
+	fb->vdma_enable = 0;
+	fb->sram_size = 0;
+
+	dither_config(fb);
+	/*
+	 * Re-calculate lcd clk source and divider
+	 * according to dsi lanes and output format.
+	 */
+	if (QHD_PANEL == is_qhd_lcd()) {
+		calculate_lcd_sclk(fb);
+		fb->phy_info = NULL;
+		fb->phy_type = 0;
+	} else {
+		/* FIXME:rewrite sclk_src, otherwise VNC will
+		 * use 520000000 as sclk_src so that clock source
+		 * will be set 624M */
+		fb->sclk_src = 416000000;
+		/* FIXME: change pixel clk divider for HVGA for fps 60 */
+		fb->sclk_div = 0xE000141b;
+	}
+	/*
+	 * FIXME:EMEI dkb use display clk1 as clk source,
+	 * which is from PLL1 416MHZ. PLL3 1GHZ will be used
+	 * for cpu core,and can't be DSI clock source specially.
+	 */
+	fb->sclk_div &= 0x0fffffff;
+	fb->sclk_div |= 0x40000000;
+
+	pxa988_add_fb_tv(fb);
+	pxa988_add_fb_tv_ovly(ovly);
+}
+#endif /* ONFIG_PXA988_LCD_PARALLEL */
+#endif
+
+#ifdef CONFIG_MACH_BROWNSTONE
+static struct fb_videomode video_modes_brownstone[] = {
+	[0] = {
+		.refresh	= 60,
+		.xres		= 1280,
+		.yres		= 720,
+		.hsync_len	= 2,
+		.left_margin	= 12,	/* hbp */
+		.right_margin	= 216,	/* hfp */
+		.vsync_len	= 2,
+		.upper_margin	= 10,	/* vbp */
+		.lower_margin	= 4,	/* vfp */
+		.sync		= 0,
+	},
+};
+
+static struct regulator *lcd_pwr_ldo17;
+static struct regulator *lcd_pwr_ldo3;
+static struct regulator *led_pwr_v5p;
+
+static int brownstone_lcd_power(struct pxa168fb_info *fbi,
+	unsigned int spi_gpio_cs, unsigned int spi_gpio_reset, int on)
+{
+	int lcd_rst_n = mfp_to_gpio(GPIO83_LCD_RST);
+
+	if (gpio_request(lcd_rst_n, "lcd reset gpio")) {
+		printk(KERN_INFO "gpio %d request failed\n", lcd_rst_n);
+		return -1;
+	}
+
+	if (!lcd_pwr_ldo17) {
+		lcd_pwr_ldo17 = regulator_get(NULL, "v_ldo17");
+		if (IS_ERR(lcd_pwr_ldo17)) {
+			lcd_pwr_ldo17 = NULL;
+			printk(KERN_ERR "v_ldo17 can't open!\n");
+			goto out;
+		}
+	}
+	if (!lcd_pwr_ldo3) {
+		lcd_pwr_ldo3 = regulator_get(NULL, "v_ldo3");
+		if (IS_ERR(lcd_pwr_ldo3)) {
+			lcd_pwr_ldo3 = NULL;
+			printk(KERN_ERR "v_ldo3 can't open!\n");
+			goto out1;
+		}
+	}
+	if (!led_pwr_v5p) {
+		led_pwr_v5p = regulator_get(NULL, "v_5vp");
+		if (IS_ERR(led_pwr_v5p)) {
+			led_pwr_v5p = NULL;
+			printk(KERN_ERR "v_5vp can't open!\n");
+			goto out2;
+		}
+	}
+
+	if (on) {
+		/* enable regulator LDO17 to power VDDC and VDD_LVDS*_12 */
+		regulator_set_voltage(lcd_pwr_ldo17, 1200000, 1200000);
+		regulator_enable(lcd_pwr_ldo17);
+
+		/* enable LDO3 to power AVDD12_DSI */
+		regulator_set_voltage(lcd_pwr_ldo3, 1200000, 1200000);
+		regulator_enable(lcd_pwr_ldo3);
+
+		/* release reset */
+		gpio_direction_output(lcd_rst_n, 1);
+
+		/* enable 5V power supply */
+		regulator_enable(led_pwr_v5p);
+
+		/* config mfp GPIO99/GPIO100 as twsi5 */
+		lcd_twsi5_set(1);
+	} else {
+		/* config mfp GPIO99/GPIO100 as normal gpio */
+		lcd_twsi5_set(0);
+
+		/* disable 5V power supply */
+		regulator_disable(led_pwr_v5p);
+
+		/* keep reset */
+		gpio_direction_output(lcd_rst_n, 0);
+
+		/* disable AVDD12_DSI voltage */
+		regulator_disable(lcd_pwr_ldo3);
+
+		/* disable regulator LDO17 */
+		regulator_disable(lcd_pwr_ldo17);
+	}
+
+	gpio_free(lcd_rst_n);
+
+	pr_debug("%s on %d\n", __func__, on);
+	return 0;
+
+out2:
+	regulator_disable(lcd_pwr_ldo3);
+	regulator_put(lcd_pwr_ldo3);
+	lcd_pwr_ldo3 = NULL;
+out1:
+	regulator_disable(lcd_pwr_ldo17);
+	regulator_put(lcd_pwr_ldo17);
+	lcd_pwr_ldo17 = NULL;
+out:
+	gpio_free(lcd_rst_n);
+	return -EIO;
+}
+
+#define LCD_ISR_CLEAR_MASK_PXA168   0xffffffff
+
+static struct pxa168fb_mach_info mmp2_mipi_lcd_info __initdata = {
+	.id			= "GFX Layer",
+	.sclk_src		= 260000000,	/* 266MHz */
+	.sclk_div		= 0x40000108,
+	.num_modes		= ARRAY_SIZE(video_modes_brownstone),
+	.modes			= video_modes_brownstone,
+	.pix_fmt		= PIX_FMT_RGB565,
+	.isr_clear_mask	= LCD_ISR_CLEAR_MASK_PXA168,
+	/*
+	 * don't care about io_pin_allocation_mode and dumb_mode
+	 * since the panel is hard connected with lcd panel path and dsi1 output
+	 */
+	.io_pad_ctrl = CFG_CYC_BURST_LEN16,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena     = 0,
+	.invert_pixclock        = 0,
+	.panel_rbswap           = 0,
+	.active			= 1,
+	.spi_gpio_cs            = -1,
+	.spi_gpio_reset         = -1,
+	.mmap			= 1,
+	.max_fb_size		= 1280 * 720 * 8 + 4096,
+	.vdma_enable		= 1,
+	.sram_size		= 30 * 1024,
+	.phy_type		= DSI2DPI,
+	.phy_init		= dsi_init,
+#ifdef CONFIG_TC35876X
+	.dsi2dpi_set		= dsi_set_tc358765,
+	.xcvr_reset		= tc358765_reset,
+#else
+#error Please select CONFIG_TC35876X in menuconfig to enable DSI bridge
+#endif
+	.phy_info		= &dsiinfo,
+	.pxa168fb_lcd_power     = &brownstone_lcd_power,
+#ifdef CONFIG_PXA688_CMU
+	.cmu_cal = {{-1, 47, 2, 2},
+		{44, 92, 25, 25},
+		{0, 0, 0, 0}
+	},
+	.cmu_cal_letter_box = {{48, 47, 2, 2},
+		{93, 92, 25, 25},
+		{0, 0, 0, 0}
+	},
+	.ioctl			= pxa688_cmu_ioctl,
+#endif
+};
+
+static struct pxa168fb_mach_info mmp2_mipi_lcd_ovly_info __initdata = {
+	.id			= "Video Layer",
+	.num_modes		= ARRAY_SIZE(video_modes_brownstone),
+	.modes			= video_modes_brownstone,
+	.pix_fmt		= PIX_FMT_RGB565,
+	.panel_rgb_reverse_lanes = 0,
+	.invert_composite_blank = 0,
+	.invert_pix_val_ena     = 0,
+	.invert_pixclock        = 0,
+	.panel_rbswap           = 0,
+	.spi_gpio_cs            = -1,
+	.spi_gpio_reset         = -1,
+	.mmap			= 0,
+	.max_fb_size            = 1280 * 720 * 8 + 4096,
+	.vdma_enable		= 0,
+	.sram_size		= 30 * 1024,
+};
+
+
+#define SDRAM_CONFIG0_TYPE1 0x0020	/* MMP2 */
+
+void __init brownstone_add_lcd_mipi(void)
+{
+	struct dsi_info *dsi = &dsiinfo;
+	unsigned char __iomem *dmc_membase;
+	unsigned int CSn_NO_COL;
+	struct pxa168fb_mach_info *mi;
+
+	if (board_is_mmp2_brownstone_rev5()) {
+		video_modes_brownstone[0].yres = 800;
+		video_modes_brownstone[0].lower_margin = 35;
+		video_modes_brownstone[0].upper_margin = 15;
+
+		mi = &mmp2_mipi_lcd_info;
+		mi->max_fb_size = video_modes_brownstone[0].xres *
+		video_modes_brownstone[0].yres * 8 + 4096;
+		mi = &mmp2_mipi_lcd_ovly_info;
+		mi->max_fb_size = video_modes_brownstone[0].xres *
+		video_modes_brownstone[0].yres * 8 + 4096;
+	}
+
+	/*FIXME: set 24bpp output by default for mmp2 */
+	dsi->bpp = 24;
+
+	if (dsi->bpp == 24) {
+		mmp2_mipi_lcd_info.sclk_src = 800000000 / (dsi->lanes / 2);
+		dsi->rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_888;
+	} else {
+		mmp2_mipi_lcd_info.sclk_src = 520000000 / (dsi->lanes / 2);
+		dsi->rgb_mode = DSI_LCD_INPUT_DATA_RGB_MODE_565;
+		video_modes_brownstone[0].right_margin = (dsi->lanes == 4) ? 315 : 178;
+	}
+	mmp2_mipi_lcd_info.sclk_div = 0x40000100 | ((dsi->lanes == 4) ? 4 : 8);
+
+	dmc_membase = ioremap(DDR_MEM_CTRL_BASE, 0xfff);
+	CSn_NO_COL = __raw_readl(dmc_membase + SDRAM_CONFIG0_TYPE1) >> 4;
+	CSn_NO_COL &= 0xf;
+	if (CSn_NO_COL <= 0x2) {
+		/*
+		*if DDR page size < 4KB, select no crossing 1KB boundary check
+		*/
+		mmp2_mipi_lcd_info.io_pad_ctrl |= CFG_BOUNDARY_1KB;
+	}
+	iounmap(dmc_membase);
+
+#ifdef CONFIG_FB_PXA168
+	/* lcd */
+	mmp2_add_fb(&mmp2_mipi_lcd_info);
+	mmp2_add_fb_ovly(&mmp2_mipi_lcd_ovly_info);
+#endif
+	vsmooth_init(1, 2);
+}
+#endif
diff --git a/arch/arm/mach-mmp/platsmp.c b/arch/arm/mach-mmp/platsmp.c
new file mode 100644
index 0000000..2eca3c4
--- /dev/null
+++ b/arch/arm/mach-mmp/platsmp.c
@@ -0,0 +1,179 @@
+/*
+ *  linux/arch/arm/mach-mmp/platsmp.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+#include <asm/mach-types.h>
+#include <asm/localtimer.h>
+#include <asm/smp_scu.h>
+
+#include <mach/addr-map.h>
+
+#include "platsmp.h"
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void __cpuinit write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+void __iomem *pxa_scu_base_addr(void)
+{
+	return (void __iomem *)SCU_VIRT_BASE;
+}
+
+static inline unsigned int get_core_count(void)
+{
+	void __iomem *scu_base = pxa_scu_base_addr();
+	if (scu_base)
+		return scu_get_core_count(scu_base);
+	return 1;
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Avoid timer calibration on slave cpus. Use the value calibrated
+	 * on master cpu. Referenced from tegra3
+	 */
+	preset_lpj = loops_per_jiffy;
+
+	/*
+	 * set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * The secondary processor is waiting to be released from
+	 * the holding pen - release it, then wait for it to flag
+	 * that it has been released by resetting pen_release.
+	 *
+	 * Note that "pen_release" is the hardware CPU ID, whereas
+	 * "cpu" is Linux's internal ID.
+	 */
+	write_pen_release(cpu);
+
+	/* reset the cpu, let it branch to the kernel entry */
+	pxa_cpu_reset(cpu);
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+
+#ifdef CONFIG_CPU_PXA988
+#define IPCC_VIRT_BASE	(APB_VIRT_BASE + 0x1D800)
+void pxa988_gic_raise_softirq(const struct cpumask *mask, unsigned int irq)
+{
+	/*
+	 * WORKAROUND: "Trigger IPC interrupt to wake cores when sending IPI"
+	 * Trigger IPC GP_INT to generate IRQ19 as wake up source inside the
+	 * ICU to wake up the cores when sending IPI.
+	 */
+	gic_raise_softirq(mask, irq);
+	__raw_writel(0x400, IPCC_VIRT_BASE + 0x8); /* IPC_ISRW */
+}
+#endif
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	unsigned int i, ncores = get_core_count();
+
+	for (i = 0; i < ncores; i++)
+		set_cpu_possible(i, true);
+
+#ifdef CONFIG_CPU_PXA988
+	set_smp_cross_call(pxa988_gic_raise_softirq);
+#else
+	set_smp_cross_call(gic_raise_softirq);
+#endif
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	int i;
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	for (i = 0; i < max_cpus; i++)
+		set_cpu_present(i, true);
+
+	scu_enable(pxa_scu_base_addr());
+
+	pxa_cpu_reset_handler_init();
+}
diff --git a/arch/arm/mach-mmp/platsmp.h b/arch/arm/mach-mmp/platsmp.h
new file mode 100644
index 0000000..c7eb05b
--- /dev/null
+++ b/arch/arm/mach-mmp/platsmp.h
@@ -0,0 +1,19 @@
+/*
+ * linux/arch/arm/mach-mmp/platsmp.h
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __PLATSMP_H__
+#define __PLATSMP_H__
+
+extern void pxa_cpu_reset(u32 cpu);
+extern void __init pxa_cpu_reset_handler_init(void);
+
+#endif /* __PLATSMP_H__ */
diff --git a/arch/arm/mach-mmp/pm-hotplug.c b/arch/arm/mach-mmp/pm-hotplug.c
new file mode 100644
index 0000000..7798024
--- /dev/null
+++ b/arch/arm/mach-mmp/pm-hotplug.c
@@ -0,0 +1,453 @@
+/*
+ * linux/arch/arm/mach-mmp/pm-hotplug.c
+ *
+ * Based on S5PV310 - Dynamic CPU hotpluging
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/serial_core.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <linux/percpu.h>
+#include <linux/ktime.h>
+#include <linux/tick.h>
+#include <linux/kernel_stat.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+#include <linux/reboot.h>
+#include <linux/gpio.h>
+#include <linux/cpufreq.h>
+#include <linux/pm_qos_params.h>
+
+#ifdef CONFIG_CORE_MORPHING
+#include <mach/mmp_cm.h>
+#endif
+
+#define CPUMON 1
+
+#define CHECK_DELAY	(.5*HZ)
+#define TRANS_LOAD_L	20
+#define TRANS_LOAD_H	(TRANS_LOAD_L*3)
+
+#define cputime64_add(__a, __b)         ((__a) + (__b))
+#define cputime64_sub(__a, __b)         ((__a) - (__b))
+
+enum HP_STATE {
+	HOTPLUG_PROFILING = 0,
+	HOTPLUG_UP,
+	HOTPLUG_DOWN,
+};
+
+static u32 hotplug_state = HOTPLUG_PROFILING;
+
+static struct workqueue_struct *hotplug_wq;
+
+static struct delayed_work hotplug_work;
+
+static unsigned int hotpluging_rate = CHECK_DELAY;
+static unsigned int hp_lock;
+static unsigned int trans_load_l = TRANS_LOAD_L;
+static unsigned int trans_load_h = TRANS_LOAD_H;
+static unsigned int bound_freq = 400 * 1000;
+
+struct cpu_time_info {
+	cputime64_t prev_cpu_idle;
+	cputime64_t prev_cpu_wall;
+	unsigned int load;
+};
+
+static DEFINE_PER_CPU(struct cpu_time_info, hotplug_cpu_time);
+
+/* mutex can be used since hotplug_timer does not run in
+   timer(softirq) context but in process context */
+static DEFINE_MUTEX(hotplug_lock);
+
+static void hotplug_timer(struct work_struct *work)
+{
+	unsigned int i, avg_load = 0, load = 0;
+	unsigned int cur_freq;
+
+	mutex_lock(&hotplug_lock);
+
+	/* force hotplug core 2 */
+	if (hotplug_state == HOTPLUG_DOWN) {
+		if (cpu_online(1) == 1)
+			cpu_down(1);
+		goto unlock;
+	}
+
+	/* force plug in core 2 */
+	if (hotplug_state == HOTPLUG_UP) {
+		if (cpu_online(1) == 0)
+			cpu_up(1);
+		goto unlock;
+	}
+
+	if (hp_lock == 1)
+		goto unlock;
+
+	for_each_online_cpu(i) {
+		struct cpu_time_info *tmp_info;
+		cputime64_t cur_wall_time, cur_idle_time;
+		unsigned int idle_time, wall_time;
+
+		tmp_info = &per_cpu(hotplug_cpu_time, i);
+
+		cur_idle_time = get_cpu_idle_time_us(i, &cur_wall_time);
+
+		idle_time = (unsigned int)cputime64_sub(cur_idle_time,
+							tmp_info->prev_cpu_idle);
+		tmp_info->prev_cpu_idle = cur_idle_time;
+
+		wall_time = (unsigned int)cputime64_sub(cur_wall_time,
+							tmp_info->prev_cpu_wall);
+		tmp_info->prev_cpu_wall = cur_wall_time;
+
+		if (wall_time < idle_time)
+			goto no_hotplug;
+
+		tmp_info->load = 100 * (wall_time - idle_time) / wall_time;
+
+		load += tmp_info->load;
+	}
+
+	avg_load = load / num_online_cpus();
+
+	cur_freq = cpufreq_get(0);
+
+	if (((avg_load < trans_load_l) && (cur_freq <= bound_freq)) &&
+	    (cpu_online(1) == 1)) {
+		printk(KERN_INFO "cpu1 turning off!\n");
+		cpu_down(1);
+#if CPUMON
+		printk(KERN_INFO "CPUMON D %d\n", avg_load);
+#endif
+		pr_info("cpu1 off end!\n");
+		hotpluging_rate = CHECK_DELAY;
+	} else if (((avg_load > trans_load_h) && (cur_freq >= bound_freq)) &&
+		   (cpu_online(1) == 0)) {
+		pr_info("cpu1 turning on!\n");
+		cpu_up(1);
+#if CPUMON
+		printk(KERN_INFO "CPUMON U %d\n", avg_load);
+#endif
+		printk(KERN_INFO "cpu1 on end!\n");
+		hotpluging_rate = CHECK_DELAY * 4;
+	}
+
+no_hotplug:
+	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, hotpluging_rate);
+
+unlock:
+	mutex_unlock(&hotplug_lock);
+}
+
+static int mmp_pm_hotplug_notifier_event(struct notifier_block *this,
+					     unsigned long event, void *ptr)
+{
+	static unsigned hp_lock_saved;
+
+	switch (event) {
+	case PM_SUSPEND_PREPARE:
+		mutex_lock(&hotplug_lock);
+		hp_lock_saved = hp_lock;
+		hp_lock = 1;
+		pr_info("%s: saving pm_hotplug lock %x\n",
+			__func__, hp_lock_saved);
+		mutex_unlock(&hotplug_lock);
+		return NOTIFY_OK;
+	case PM_POST_RESTORE:
+	case PM_POST_SUSPEND:
+		mutex_lock(&hotplug_lock);
+		pr_info("%s: restoring pm_hotplug lock %x\n",
+			__func__, hp_lock_saved);
+		hp_lock = hp_lock_saved;
+		mutex_unlock(&hotplug_lock);
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block mmp_pm_hotplug_notifier = {
+	.notifier_call = mmp_pm_hotplug_notifier_event,
+};
+
+static int hotplug_reboot_notifier_call(struct notifier_block *this,
+					unsigned long code, void *_cmd)
+{
+	mutex_lock(&hotplug_lock);
+	pr_err("%s: disabling pm hotplug\n", __func__);
+	hp_lock = 1;
+	mutex_unlock(&hotplug_lock);
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block hotplug_reboot_notifier = {
+	.notifier_call = hotplug_reboot_notifier_call,
+};
+
+static int disable_hotplug_notify(struct notifier_block *nb,
+				  unsigned long n, void *p)
+{
+	unsigned int disable;
+
+	disable = pm_qos_request(PM_QOS_DISABLE_HP);
+
+	mutex_lock(&hotplug_lock);
+	hp_lock = disable ? 1 : 0;
+	mutex_unlock(&hotplug_lock);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block disable_hotplug_notifier = {
+	.notifier_call = disable_hotplug_notify,
+};
+
+static int hotplug_constraint_notify(struct notifier_block *nb,
+				  unsigned long n, void *p)
+{
+	unsigned int min_cpus, max_cpus;
+
+	min_cpus = pm_qos_request(PM_QOS_MIN_ONLINE_CPUS);
+	max_cpus = pm_qos_request(PM_QOS_MAX_ONLINE_CPUS);
+	if (min_cpus < max_cpus)
+		hotplug_state = HOTPLUG_PROFILING;
+	else if ((min_cpus == max_cpus) && (max_cpus == 1))
+		hotplug_state = HOTPLUG_DOWN;
+	else if ((min_cpus == max_cpus) && (min_cpus == 2))
+		hotplug_state = HOTPLUG_UP;
+	else
+		BUG();
+
+	if (num_online_cpus() != n) {
+		flush_delayed_work(&hotplug_work);
+		queue_delayed_work_on(0, hotplug_wq, &hotplug_work, CHECK_DELAY);
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block hotplug_constraint_notifier = {
+	.notifier_call = hotplug_constraint_notify,
+};
+
+static struct kobject hotplug_kobj;
+struct pm_qos_request_list min_cpu_req;
+struct pm_qos_request_list max_cpu_req;
+
+static u32 parse_arg(const char *buf, size_t count)
+{
+	char *token, *s;
+	char str[128];
+
+	memcpy(str, buf, count);
+	s = str;
+	token = strsep(&s, " \t\n");
+	return simple_strtol(token, NULL, 0);
+}
+
+static int loadh_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", trans_load_h);
+}
+static int loadh_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int loadh_tmp;
+	if (!sscanf(buf, "%d", &loadh_tmp))
+		return -EINVAL;
+	trans_load_h = loadh_tmp;
+	return count;
+
+}
+static DEVICE_ATTR(loadh, S_IRUGO | S_IWUSR, loadh_get, loadh_set);
+
+static int loadl_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", trans_load_l);
+}
+static int loadl_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int loadl_tmp;
+	if (!sscanf(buf, "%d", &loadl_tmp))
+		return -EINVAL;
+	trans_load_l = loadl_tmp;
+	return count;
+}
+static DEVICE_ATTR(loadl, S_IRUGO | S_IWUSR, loadl_get, loadl_set);
+
+static int bound_freq_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", bound_freq);
+}
+static int bound_freq_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	int freq_tmp;
+	if (!sscanf(buf, "%d", &freq_tmp))
+		return -EINVAL;
+	bound_freq = freq_tmp;
+	return count;
+}
+static DEVICE_ATTR(bound_freq, S_IRUGO | S_IWUSR, bound_freq_get,
+		bound_freq_set);
+
+
+static int lock_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", hp_lock);
+}
+
+static int lock_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	u32 val;
+	int restart_hp = 0;
+
+	val = parse_arg(buf, count);
+
+	mutex_lock(&hotplug_lock);
+	/* we want to re-enable governor */
+	if ((1 == hp_lock) && (0 == val))
+		restart_hp = 1;
+	hp_lock = val ? 1 : 0;
+	mutex_unlock(&hotplug_lock);
+
+	if (restart_hp) {
+		flush_delayed_work(&hotplug_work);
+		queue_delayed_work_on(0, hotplug_wq, &hotplug_work,
+				CHECK_DELAY);
+	}
+	return count;
+}
+static DEVICE_ATTR(lock, S_IRUGO | S_IWUSR, lock_get, lock_set);
+
+static int min_cpus_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", pm_qos_request(PM_QOS_MIN_ONLINE_CPUS));
+}
+
+static int min_cpus_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	u32 max_cpus, val;
+
+	val = parse_arg(buf, count);
+	max_cpus = pm_qos_request(PM_QOS_MAX_ONLINE_CPUS);
+	max_cpus = min(max_cpus, (u32)NR_CPUS);
+	if (val < 1 || val > max_cpus) {
+		printk(KERN_INFO "out of scope, will be 1 ~ %d\n", max_cpus);
+		return -EINVAL;
+	}
+
+	pm_qos_update_request(&min_cpu_req, (s32)val);
+	return count;
+}
+static DEVICE_ATTR(min_cpus, S_IRUGO | S_IWUSR, min_cpus_get, min_cpus_set);
+
+static int max_cpus_get(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d\n", pm_qos_request(PM_QOS_MAX_ONLINE_CPUS));
+}
+
+static int max_cpus_set(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	u32 min_cpus, val;
+
+	val = parse_arg(buf, count);
+	min_cpus = pm_qos_request(PM_QOS_MIN_ONLINE_CPUS);
+	if (val < min_cpus || val > NR_CPUS) {
+		printk(KERN_INFO "out of scope, will be %d ~ %d\n",
+			min_cpus, NR_CPUS);
+		return -EINVAL;
+	}
+
+	pm_qos_update_request(&max_cpu_req, (s32)val);
+	return count;
+}
+
+static DEVICE_ATTR(max_cpus, S_IRUGO | S_IWUSR, max_cpus_get, max_cpus_set);
+
+static struct attribute *hotplug_attributes[] = {
+	&dev_attr_lock.attr,
+	&dev_attr_min_cpus.attr,
+	&dev_attr_max_cpus.attr,
+	&dev_attr_loadh.attr,
+	&dev_attr_loadl.attr,
+	&dev_attr_bound_freq.attr,
+	NULL,
+};
+
+static struct kobj_type hotplug_dir_ktype = {
+	.sysfs_ops	= &kobj_sysfs_ops,
+	.default_attrs	= hotplug_attributes,
+};
+
+static int __init mmp_pm_hotplug_init(void)
+{
+#ifdef CONFIG_CORE_MORPHING
+	/*
+	 * add constraint for core morphing, also enable core
+	 * morphing so that if hp and dfc release the constraint,
+	 * then the core morphing module can automatically
+	 * swap to mm core.
+	 */
+	cm_vote_mp1();
+	cm_enable();
+#endif
+	printk(KERN_INFO "mmp PM-hotplug init function\n");
+	hotplug_wq = create_singlethread_workqueue("dynamic hotplug");
+	if (!hotplug_wq) {
+		printk(KERN_ERR "Creation of hotplug work failed\n");
+		return -EFAULT;
+	}
+
+	INIT_DELAYED_WORK_DEFERRABLE(&hotplug_work, hotplug_timer);
+
+	queue_delayed_work_on(0, hotplug_wq, &hotplug_work, 60 * HZ);
+
+	register_pm_notifier(&mmp_pm_hotplug_notifier);
+	register_reboot_notifier(&hotplug_reboot_notifier);
+
+	pm_qos_add_request(&min_cpu_req, PM_QOS_MIN_ONLINE_CPUS,
+			   PM_QOS_DEFAULT_VALUE);
+	pm_qos_add_request(&max_cpu_req, PM_QOS_MAX_ONLINE_CPUS,
+			   NR_CPUS);
+
+	if (pm_qos_add_notifier(PM_QOS_MIN_ONLINE_CPUS,
+				&hotplug_constraint_notifier))
+		pr_err("%s: Failed to register min cpus PM QoS notifier\n",
+			__func__);
+
+	if (pm_qos_add_notifier(PM_QOS_MAX_ONLINE_CPUS,
+				&hotplug_constraint_notifier))
+		pr_err("%s: Failed to register max cpus PM QoS notifier\n",
+			__func__);
+
+	if (pm_qos_add_notifier(PM_QOS_DISABLE_HP,
+				&disable_hotplug_notifier))
+		pr_err("%s: Failed to register disable hp PM QoS notifier\n",
+			__func__);
+
+	return 0;
+}
+
+late_initcall(mmp_pm_hotplug_init);
diff --git a/arch/arm/mach-mmp/pm-mmp3.c b/arch/arm/mach-mmp/pm-mmp3.c
new file mode 100644
index 0000000..c929721
--- /dev/null
+++ b/arch/arm/mach-mmp/pm-mmp3.c
@@ -0,0 +1,2297 @@
+/*
+ * linux/arch/arm/mach-mmp/pm-mmp3.c
+ *
+ *
+ * Copyright (C) 2011 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mutex.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/clocksource.h>
+#include <linux/time.h>
+#include <linux/cpu.h>
+#include <plat/clock.h>
+#include <asm/mach/map.h>
+#include <asm/proc-fns.h>
+#include <asm/cacheflush.h>
+#include <mach/hardware.h>
+#include <mach/addr-map.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-ciu.h>
+#include <mach/regs-icu.h>
+#include <mach/regs-mcu.h>
+#include <mach/system.h>
+#include <linux/fb.h>
+#ifdef CONFIG_TRACEPOINTS
+#define CREATE_TRACE_POINTS
+#endif
+#include <mach/mmp3_pm.h>
+#include <mach/smp.h>
+#include <mach/mmp_cm.h>
+
+static DEFINE_SPINLOCK(dfcsch_lock);
+atomic_t mmp3_fb_is_suspended = ATOMIC_INIT(0);
+
+static inline int mmp3_smpid(void)
+{
+#ifdef CONFIG_CORE_MORPHING
+	/*
+	 * after set morph bit, mm core will return back core id
+	 * is 0 from CP15 CPUID register; so need check core
+	 * morphing's module and get the active id number.
+	 *
+	 * if core is mm core, the need force to return core id = 2.
+	 * so idle functions can set idle_cfg and cc4 registers for
+	 * mm core correctly.
+	 */
+	if (cm_get_active_core_id() == MMP_CM_CPU_ID_MM)
+		return 2;
+#endif
+
+	return hard_smp_processor_id();
+}
+
+#ifdef CONFIG_SMP
+enum ipi_msg_type {
+	IPI_TIMER = 2,
+	IPI_RESCHEDULE,
+	IPI_CALL_FUNC,
+	IPI_CALL_FUNC_SINGLE,
+	IPI_CPU_STOP,
+	IPI_CPU_BACKTRACE,
+	IPI_CPU_SYNC_COHERENCY,
+};
+
+#define MP1_COHT_STATE_OFFSET	0x0
+#define MP2_COHT_STATE_OFFSET	0x4
+#define MP1_HANDSHAKE_OFFSET	0x8
+#define MP2_HANDSHAKE_OFFSET	0xc
+
+#define SEM4_OFFSET		0x20
+
+#define MP1_C1_CFG_OFFSET	0x100
+#define MP1_C2_CFG_OFFSET	0x104
+#define MP2_C1_CFG_OFFSET	0x108
+#define MP2_C2_CFG_OFFSET	0x10c
+#define MM_C1_CFG_OFFSET	0x110
+#define MM_C2_CFG_OFFSET	0x114
+#define CM_CID_OFFSET		0x118
+
+#define INT_STATUS_ADDR_OFFSET	0x200
+#define WAKE_STATUS_ADDR_OFFSET	0x204
+#define SGIR_ADDR_OFFSET	0x208
+#define APMU_BASE_ADDR_OFFSET	0x20c
+
+#define CC_OFFSET		0x300
+#define CC_ADDR_OFFSET		0x304
+#define CC2_OFFSET		0x308
+#define CC2_ADDR_OFFSET		0x30c
+#define CC3_OFFSET		0x310
+#define CC3_ADDR_OFFSET		0x314
+#define BUS_OFFSET		0x318
+#define BUS_ADDR_OFFSET		0x31c
+#define FCCR_OFFSET		0x320
+#define FCCR_ADDR_OFFSET	0x324
+
+static u32 num_cpus;
+static char *sync_buf;
+static volatile int *coherent_state;
+
+extern int mmp3_trigger_dfc_ll(u32 dfc_val, u32 buf_base);
+extern int mmp3_trigger_dfc_ll_b0p(u32 dfc_val, u32 buf_base);
+extern int mmp3_coherent_handler(u32 buf_base);
+extern int mmp3_enter_c2(u32 buf_base);
+
+static inline u32 cyc2us(u32 cycle)
+{
+	return (cycle >> 2) + (cycle >> 5) + (cycle >> 6)
+		+ (cycle >> 7) + (cycle >> 9) + (cycle >> 10);
+}
+
+static inline u32 read_timestamp(void)
+{
+	unsigned long r1, r2;
+	__asm__ __volatile__ ("mrrc p15, 0, %0, %1, c14"
+		: "=r" (r1), "=r" (r2) : : "cc");
+	return r1;
+}
+
+static void set_sync_buf(u32 offset, u32 val)
+{
+	u32 *data;
+
+	data = (u32 *)(sync_buf + offset);
+	*data = val;
+	return;
+}
+
+static u32 get_sync_buf(u32 offset)
+{
+	return *(u32 *)(sync_buf + offset);
+}
+
+void handle_coherency_maint_req(void *p)
+{
+	mmp3_coherent_handler((u32)sync_buf);
+}
+
+static void do_nothing(void *unused)
+{
+	int cpu = smp_processor_id();
+	printk(KERN_INFO "%s: cpu %d\n", __func__, cpu);
+}
+
+static atomic_t glb_hp_lock = ATOMIC_INIT(0);
+
+static int __cpuinit mmp3_pm_cpu_callback(struct notifier_block *nfb,
+				     unsigned long action, void *hcpu)
+{
+	int err = 0;
+
+	spin_lock(&dfcsch_lock);
+	switch (action) {
+	case CPU_UP_PREPARE:
+	case CPU_UP_PREPARE_FROZEN:
+		cm_vote_mp1();
+		atomic_inc(&glb_hp_lock);
+		smp_mb();
+		break;
+	case CPU_ONLINE:
+	case CPU_ONLINE_FROZEN:
+		while(!(readl(APMU_CORE_STATUS) & 0x200))
+			nop();
+		atomic_dec(&glb_hp_lock);
+		smp_mb();
+		break;
+	case CPU_UP_CANCELED:
+	case CPU_UP_CANCELED_FROZEN:
+		atomic_dec(&glb_hp_lock);
+		cm_cancel_vote_mp1();
+		break;
+#ifdef CONFIG_HOTPLUG_CPU
+	case CPU_DOWN_PREPARE:
+	case CPU_DOWN_PREPARE_FROZEN:
+		atomic_inc(&glb_hp_lock);
+		smp_mb();
+		/* kick all the CPUs so that they exit out of pm_idle */
+		smp_call_function(do_nothing, NULL, 1);
+		break;
+	case CPU_DOWN_FAILED:
+	case CPU_DOWN_FAILED_FROZEN:
+		atomic_dec(&glb_hp_lock);
+		break;
+	case CPU_DEAD:
+	case CPU_DEAD_FROZEN:
+		while(readl(APMU_CORE_STATUS) & 0x200)
+			nop();
+		atomic_dec(&glb_hp_lock);
+		smp_mb();
+		cm_cancel_vote_mp1();
+		break;
+#endif
+	}
+	spin_unlock(&dfcsch_lock);
+	return notifier_from_errno(err);
+}
+
+static struct notifier_block __cpuinitdata mmp3_pm_cpu_notifier = {
+	&mmp3_pm_cpu_callback, NULL, 0
+};
+#endif
+
+#define pm_print(args...) printk(args)
+
+/* Dynamic Frequency Change Part */
+enum {
+	MMP3_FREQ_OP_GET	= 0,
+	MMP3_FREQ_OP_UPDATE	= 1,
+	MMP3_FREQ_OP_SHOW	= 2,
+
+	MMP3_FREQ_PH_D_BY_4	= 1,
+	MMP3_FREQ_PH_D_BY_6	= 2,
+	MMP3_FREQ_PH_D_BY_8	= 3,
+	MMP3_FREQ_PH_D_BY_10	= 4,
+	MMP3_FREQ_PH_D_BY_12	= 5,
+	MMP3_FREQ_PH_D_BY_14	= 6,
+	MMP3_FREQ_PH_D_BY_15	= 7,
+
+	MMP3_FREQCH_VOLTING	= (1u << 27),
+	MMP3_FREQCH_CORE	= (1u << 24),
+	MMP3_FREQCH_DRAM_CH1	= (8u << 22),
+	MMP3_FREQCH_DRAM_CH2	= (1u << 22),
+	MMP3_FREQCH_DRAM	= MMP3_FREQCH_DRAM_CH1 | MMP3_FREQCH_DRAM_CH2,
+	MMP3_FREQCH_AXI		= (1u << 26),
+
+};
+
+#define FIELD2DIV(x) ((x) + 1)
+#define GET_FIELD(val, shft, bits) (((val) >> (shft)) & ((1u << (bits)) - 1))
+#define MAK_FIELD(val, shft, bits) (((val) & ((1u << (bits)) - 1)) << (shft))
+#define MOD_FIELD(old, fld, shft, bits) \
+	(((old) & ~(MAK_FIELD(-1, shft, bits))) | MAK_FIELD(fld, shft, bits))
+
+/* FCCR 29-31 */
+#define MMP3_FREQ_PSRC_SET(old, fld) MOD_FIELD(old, fld, 29, 3)
+/* FCCR 29-31 */
+#define MMP3_FREQ_PSRC_GET(val) GET_FIELD(val, 3, 3)
+/* FCCR 23-25 */
+#define MMP3_FREQ_DSRC_SET(old, fld) MOD_FIELD(old, fld, 23, 3)
+/* FCCR 23-25 */
+#define MMP3_FREQ_DSRC_GET(val) GET_FIELD(val, 6, 3)
+/* BUS_CLKRST 6-8 */
+#define MMP3_FREQ_ASRC_SET(old, fld) MOD_FIELD(old, fld, 6, 3)
+/* BUS_CLKRST 6-8*/
+#define MMP3_FREQ_ASRC_GET(val) GET_FIELD(val, 9, 3)
+/* BUS_CLKRST 9-11 */
+#define MMP3_FREQ_DSRC2_SET(old, fld) MOD_FIELD(old, fld, 9, 3)
+/* BUS_CLKRST 9-11*/
+#define MMP3_FREQ_DSRC2_GET(val) GET_FIELD(val, 9, 3)
+/* CC 3-5 */
+#define MMP3_FREQ_AT_SET(old, fld) MOD_FIELD(old, fld, 3, 3)
+/* DM_CC 3-5 */
+#define MMP3_FREQ_AT_GET(val) GET_FIELD(val, 3, 3)
+/* CC 9-11 */
+#define MMP3_FREQ_PH_SET(old, fld) MOD_FIELD(old, fld, 9, 3)
+/* DM2_CC 25-27 */
+#define MMP3_FREQ_PH_GET(val) GET_FIELD(val, 25, 3)
+/* CC 0-2 */
+#define MMP3_FREQ_PJ_SET(old, fld) MOD_FIELD(old, fld, 0, 3)
+/* DM_CC 0-2 */
+#define MMP3_FREQ_PJ_GET(val) GET_FIELD(val, 0, 3)
+/* CC2 17-20 */
+#define MMP3_FREQ_MM_SET(old, fld) MOD_FIELD(old, fld, 17, 4)
+/* DM2_CC 17-20 */
+#define MMP3_FREQ_MM_GET(val) GET_FIELD(val, 17, 4)
+/* CC2 9-12 */
+#define MMP3_FREQ_MP1_SET(old, fld) MOD_FIELD(old, fld, 9, 4)
+/* DM2_CC 9-12 */
+#define MMP3_FREQ_MP1_GET(val) GET_FIELD(val, 9, 4)
+/* CC2 13-16 */
+#define MMP3_FREQ_MP2_SET(old, fld) MOD_FIELD(old, fld, 13, 4)
+/* DM2_CC 13-16 */
+#define MMP3_FREQ_MP2_GET(val) GET_FIELD(val, 13, 4)
+/* CC2 21-24 */
+#define MMP3_FREQ_ACLK_SET(old, fld) MOD_FIELD(old, fld, 21, 4)
+/* DM2_CC 21-24 */
+#define MMP3_FREQ_ACLK_GET(val) GET_FIELD(val, 21, 4)
+/* CC 12-14 */
+#define MMP3_FREQ_DDR1_SET(old, fld) MOD_FIELD(old, fld, 12, 3)
+/* DM_CC 12-14 */
+#define MMP3_FREQ_DDR1_GET(val) GET_FIELD(val, 12, 3)
+/* CC3 17-19 */
+#define MMP3_FREQ_DDR2_SET(old, fld) MOD_FIELD(old, fld, 17, 3)
+/* DM_CC 9-11 */
+#define MMP3_FREQ_DDR2_GET(val) GET_FIELD(val, 9, 3)
+/* CC 15-17 */
+#define MMP3_FREQ_AXI1_SET(old, fld) MOD_FIELD(old, fld, 15, 3)
+/* DM_CC 15-17 */
+#define MMP3_FREQ_AXI1_GET(val) GET_FIELD(val, 15, 3)
+/* CC2 0-2 */
+#define MMP3_FREQ_AXI2_SET(old, fld) MOD_FIELD(old, fld, 0, 3)
+/* DM2_CC 0-2 */
+#define MMP3_FREQ_AXI2_GET(val) GET_FIELD(val, 0, 3)
+/* DOUBLER_GENERIC_CTRL 2-3 */
+#define MMP3_FREQ_DDR1_DBBYPASS_GET(val) GET_FIELD(val, 2, 1)
+#define MMP3_FREQ_DDR2_DBBYPASS_GET(val) GET_FIELD(val, 3, 1)
+
+#define MMP3_PROTECT_CC(x) (((x) & 0x0003fe3f) | 0x00bc0000)
+#define MMP3_PROTECT_CC2(x) ((x) & 0xfffffe07)
+#define MMP3_PROTECT_CC3(x) ((x) & 0x0effff1f)
+#define MMP3_PROTECT_BUSCLKRST(x) ((x) & 0x0000ffc3)
+#define MMP3_PROTECT_FCCR(x) ((x) & 0xff83ffff)
+
+struct mmp3_fc_source {
+	char *name;
+	u32 frequency;
+	struct clk *source;
+};
+
+struct mmp3_freq_plan {
+	union {
+		struct {
+			u32 op:4;
+			u32 psrc:3;
+			u32 pj_d:3;
+			u32 mp1_d:4;
+			u32 mp2_d:4;
+			u32 mm_d:4;
+			u32 aclk_d:4;
+			u32 ph_d:3;
+			u32 at_d:3;
+		};
+		u32 val;
+	} core;
+	union {
+		struct {
+			u32 op:4;
+			u32 dsrc:3;
+			u32 mode4x:1;
+			u32 pre_d:3;
+			struct dmc_timing_entry *timing;
+		};
+		u32 val;
+	} dram;
+	union {
+		struct {
+			u32 op:4;
+			u32 asrc:3;
+			u32 aclk1_d:3;
+			u32 aclk2_d:3;
+		};
+		u32 val;
+	} axi;
+	u32 khz[MMP3_CLK_TOP_NUM];
+};
+
+struct mmp3_pmu {
+	u32 *fccr;
+	u32 *cc;
+	u32 *cc2;
+	u32 *cc3;
+	u32 *dbc;
+	u32 *db[2];
+	u32 *bus;
+	u32 *dm_cc;
+	u32 *dm2_cc;
+	u32 *pll_sel_status;
+	u32 *mc_interleave;
+	u32 *mc_slp_req;
+	u32 *mc_par_ctrl;
+	u32 *swstat;
+	u32 *dmcu[2];
+
+	u32 ddrdfc_trigger;
+	u32 swstat_store;
+	spinlock_t mmp3_fc_spin;
+	struct mutex mmp3_fc_lock;
+	struct mmp3_fc_source *sources;
+	struct mmp3_freq_plan *pps;
+	int ppscnt;
+	void (*setrate)(struct mmp3_pmu *pmu, int id, u32 khz);
+	u32 pp_lowbar[MMP3_CLK_TOP_NUM];
+	int pp_curr;
+	struct mmp3_freq_plan pl_curr;
+
+	u32 trigge_stat[MMP3_CLK_TOP_NUM];
+	u32 source_status[MMP3_CLK_TOP_NUM];
+};
+
+static struct mmp3_fc_source mmp3_fccs[] = {
+	[0] = {
+		.name = "pll1_d_2",
+	},
+	[1] = {
+		.name = "pll1",
+	},
+	[2] = {
+		.name = "pll2",
+	},
+	[3] = {
+		.name = "pll1_clkoutp",
+	},
+	[4] = {
+		.name = "vctcxo",
+	},
+};
+
+static inline void mmp3_fccs_enable(int idx)
+{
+	clk_enable(mmp3_fccs[idx].source);
+}
+
+static inline void mmp3_fccs_disable(int idx)
+{
+	clk_disable(mmp3_fccs[idx].source);
+}
+
+static inline u32 mmp3_fccs_speed(int idx)
+{
+	return mmp3_fccs[idx].frequency;
+}
+
+#define MMP3_TEST_PP 0
+#define MMP3_PP_TABLE_DIFF_BYIDX 0
+
+static struct mmp3_freq_plan mmp3_pps[] = {
+	/* DDR will be fixed upon platform init according to DDR module */
+#if MMP3_TEST_PP
+	{
+		.core = {{MMP3_FREQ_OP_GET, 4, 0, 0, 0, 0, 0, 1, 1},},
+		.axi  = {{MMP3_FREQ_OP_GET, 0, 7, 7},},	/* 50/50 */
+	},
+	{
+		.core = {{MMP3_FREQ_OP_GET, 0, 7, 0, 0, 0, 0, 1, 2},},/*50*/
+		.axi  = {{MMP3_FREQ_OP_GET, 0, 3, 3},},	/* 100/100 */
+	},
+#endif
+	{
+		.core = {{MMP3_FREQ_OP_GET, 0, 3, 0, 0, 0, 0, 3, 3},},/*100*/
+		.axi  = {{MMP3_FREQ_OP_GET, 0, 3, 3},},	/* 100/100 */
+	},
+	{
+		.core = {{MMP3_FREQ_OP_GET, 0, 1, 0, 0, 0, 0, 1, 1},},/*200*/
+		.axi  = {{MMP3_FREQ_OP_GET, 0, 1, 3},},	/* 200/100 */
+	},
+	{
+		.core = {{MMP3_FREQ_OP_GET, 1, 1, 0, 0, 0, 0, 1, 1},},/*400*/
+		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
+	},
+	{
+		.core = {{MMP3_FREQ_OP_GET, 1, 0, 0, 0, 1, 1, 1, 1},},/*800*/
+		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
+	},
+	{
+		.core = {{MMP3_FREQ_OP_GET, 3, 0, 0, 0, 1, 1, 2, 2},},/*1066*/
+		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
+	},
+#if MMP3_TEST_PP_2GHZ
+	{
+		.core = {{MMP3_FREQ_OP_GET, 2, 0, 0, 0, 1, 1, 2, 2},},/*1200*/
+		.axi  = {{MMP3_FREQ_OP_GET, 1, 1, 3},},	/* 400/200 */
+	},
+#endif
+};
+
+static struct mmp3_pmu mmp3_pmu_config = {
+	.fccr = (u32 *)MPMU_FCCR,
+	.cc = (u32 *)APMU_REG(0x4),
+	.cc2 = (u32 *)APMU_REG(0x150),
+	.cc3 = (u32 *)APMU_REG(0x188),
+	.bus = (u32 *)APMU_REG(0x6c),
+	.db = {
+		[0] = (u32 *)APMU_REG(0x258),
+		[1] = (u32 *)APMU_REG(0x25c),
+	},
+	.dbc = (u32 *)APMU_REG(0x260),
+	.dm_cc = (u32 *)APMU_REG(0xc),
+	.dm2_cc = (u32 *)APMU_REG(0x158),
+	.pll_sel_status = (u32 *)APMU_REG(0xc4),
+	.mc_interleave = (u32 *)CIU_REG(0xa0),
+	.mc_slp_req = (u32 *)APMU_REG(0xb4),
+	.mc_par_ctrl = (u32 *)APMU_REG(0x11c),
+	.dmcu = {
+		[0] = (u32 *)(DMCU_VIRT_BASE + 0x0),
+		[1] = (u32 *)(DMCU_VIRT_BASE + 0x10000),
+	},
+
+	.sources = mmp3_fccs,
+	.pps = mmp3_pps,
+	.ppscnt = ARRAY_SIZE(mmp3_pps),
+};
+
+/* low power mode Part */
+struct mmp3_cpu_idle_config {
+	u32 idle_config_valid_mask;
+	u32 idle_config_keep_mask;
+	u32 *idle_config;
+	u32 *wake_status;
+	u32 *intr_status;
+	u32 *freq_status;
+};
+#define INTR_STAT ((u32 *)(GIC_CPU_VIRT_BASE + 0x18))
+#define WAKE_STAT ((u32 *)(MPMU_AWUCRS))
+#define MK_APMU_REG_VADDR(x) ((u32 *)APMU_REG(x))
+static struct mmp3_percpu_config {
+	struct mmp3_cpu_idle_config cic;
+} mmp3_percpu[] = {
+	[0] = {
+		.cic = {
+			.idle_config_valid_mask = 0x000000e2,
+			.idle_config_keep_mask = 0x0deffc1d,
+			.idle_config = MK_APMU_REG_VADDR(0x18),
+			.wake_status = WAKE_STAT,
+			.intr_status = INTR_STAT,
+			.freq_status = &(mmp3_pmu_config.swstat_store),
+		},
+	},
+	[1] = {
+		.cic = {
+			.idle_config_valid_mask = 0x00000062,
+			.idle_config_keep_mask = 0x0deffc1d,
+			.idle_config = MK_APMU_REG_VADDR(0x200),
+			.wake_status = WAKE_STAT,
+			.intr_status = INTR_STAT,
+			.freq_status = &(mmp3_pmu_config.swstat_store),
+		},
+	},
+	[2] = {
+		.cic = {
+			.idle_config_valid_mask = 0x00000062,
+			.idle_config_keep_mask = 0x0deffc1d,
+			.idle_config = MK_APMU_REG_VADDR(0x204),
+			.wake_status = WAKE_STAT,
+			.intr_status = INTR_STAT,
+			.freq_status = &(mmp3_pmu_config.swstat_store),
+		},
+	},
+};
+
+/* DFC related functions */
+static void mmp3_freq_plan_cal(struct mmp3_pmu *pmu,
+					struct mmp3_freq_plan *pl)
+{
+	u32 basefreq;
+	basefreq = pmu->sources[pl->core.psrc].frequency;
+	basefreq = basefreq / FIELD2DIV(pl->core.pj_d);
+	pl->khz[MMP3_CLK_MP1] = basefreq / FIELD2DIV(pl->core.mp1_d);
+	pl->khz[MMP3_CLK_MP2] = basefreq / FIELD2DIV(pl->core.mp2_d);
+	pl->khz[MMP3_CLK_MM] = basefreq / FIELD2DIV(pl->core.mm_d);
+	pl->khz[MMP3_CLK_ACLK] = basefreq / FIELD2DIV(pl->core.aclk_d);
+
+	basefreq = pmu->sources[pl->dram.dsrc].frequency;
+	pl->khz[MMP3_CLK_DDR_1] = basefreq / FIELD2DIV(pl->dram.pre_d);
+	pl->khz[MMP3_CLK_DDR_2] = basefreq / FIELD2DIV(pl->dram.pre_d);
+	if (pl->dram.mode4x) {
+		pl->khz[MMP3_CLK_DDR_1] *= 4;
+		pl->khz[MMP3_CLK_DDR_2] *= 4;
+	}
+
+	basefreq = pmu->sources[pl->axi.asrc].frequency;
+	pl->khz[MMP3_CLK_AXI_1] = basefreq / FIELD2DIV(pl->axi.aclk1_d);
+	pl->khz[MMP3_CLK_AXI_2] = basefreq / FIELD2DIV(pl->axi.aclk2_d);
+}
+
+static void mmp3_freq_plan_print(struct mmp3_pmu *pmu,
+	struct mmp3_freq_plan *pl, char * tag, u32 tmr)
+{
+	int proid = mmp3_smpid();
+	tmr = cyc2us(tmr);
+	if (pl->core.op == MMP3_FREQ_OP_SHOW) {
+		pm_print("%s<PM:%d>:CPU@[%12s]|"
+				"MM: %7d|MP1:%7d|MP2:%7d|FAB:%7d|"
+				"%2d us|%d\n"
+			, tag
+			, proid
+			, pmu->sources[pl->core.psrc].name
+			, pl->khz[MMP3_CLK_MM]
+			, pl->khz[MMP3_CLK_MP1]
+			, pl->khz[MMP3_CLK_MP2]
+			, pl->khz[MMP3_CLK_ACLK]
+			, tmr
+			, pmu->trigge_stat[MMP3_CLK_MP1]
+			);
+	}
+	if (pl->dram.op == MMP3_FREQ_OP_SHOW) {
+		pm_print("%s<PM:%d>:DDR@[%12s]|CH1:%7d (x%d mode)  |"
+				"CH2:%7d (x%d mode)  |"
+				"%2d us|%d\n"
+			, tag
+			, proid
+			, pmu->sources[pl->dram.dsrc].name
+			, pl->khz[MMP3_CLK_DDR_1]
+			, (pl->dram.mode4x) ? 4 : 2
+			, pl->khz[MMP3_CLK_DDR_2]
+			, (pl->dram.mode4x) ? 4 : 2
+			, tmr
+			, pmu->trigge_stat[MMP3_CLK_DDR_1]
+			);
+	}
+	if (pl->axi.op == MMP3_FREQ_OP_SHOW) {
+		pm_print("%s<PM:%d>:AXI@[%12s]|A1: %7d|A2: %7d|"
+				"           |           |"
+				"%2d us|%d\n"
+			, tag
+			, proid
+			, pmu->sources[pl->axi.asrc].name
+			, pl->khz[MMP3_CLK_AXI_1]
+			, pl->khz[MMP3_CLK_AXI_2]
+			, tmr
+			, pmu->trigge_stat[MMP3_CLK_AXI_1]
+			);
+	}
+}
+#define mmp3_freq_plan_print_info(pmu, pl, tmr) \
+	mmp3_freq_plan_print(pmu, pl, KERN_INFO, tmr)
+#define mmp3_freq_plan_print_dbg(pmu, pl, tmr) \
+	mmp3_freq_plan_print(pmu, pl, KERN_DEBUG, tmr)
+
+static void mmp3_clear_PJ_RD_STATUS(struct mmp3_pmu *pmu)
+{
+	u32 val;
+	__raw_readl(pmu->cc);
+	val = __raw_readl(pmu->cc);
+	val = MMP3_PROTECT_CC(val); /* set reserved, SB0, SB1, bits*/
+	val = val | (1u << 31);
+	__raw_writel(val, pmu->cc);
+	val = val & (~(1u << 31));
+	__raw_writel(val, pmu->cc);
+}
+
+static int mmp3_fb_notifier_callback(struct notifier_block *self,
+		unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+
+	if ((event == FB_EVENT_SUSPEND) || ((event == FB_EVENT_BLANK) &&
+			(*(int *)evdata->data != FB_BLANK_UNBLANK)))
+		atomic_set(&mmp3_fb_is_suspended, 1);
+	else if ((event == FB_EVENT_RESUME) || ((event == FB_EVENT_BLANK) &&
+			(*(int *)evdata->data == FB_BLANK_UNBLANK)))
+		atomic_set(&mmp3_fb_is_suspended, 0);
+
+	return 0;
+}
+
+static struct notifier_block mmp3_fb_notif = {
+	.notifier_call = mmp3_fb_notifier_callback,
+};
+
+
+static void mmp3_get_freq_plan(struct mmp3_pmu *pmu,
+				struct mmp3_freq_plan *pl, bool crs)
+{
+	u32 val;
+	/* pll_sel_status */
+	val = __raw_readl(pmu->pll_sel_status);
+	pl->core.psrc = MMP3_FREQ_PSRC_GET(val);
+	pl->dram.dsrc = MMP3_FREQ_DSRC_GET(val);
+	pl->axi.asrc = MMP3_FREQ_ASRC_GET(val);
+	/* dm_cc */
+	val = __raw_readl(pmu->dm_cc);
+	pl->core.at_d = MMP3_FREQ_AT_GET(val);
+	pl->core.pj_d = MMP3_FREQ_PJ_GET(val);
+	pl->dram.pre_d = MMP3_FREQ_DDR1_GET(val);
+	pl->axi.aclk1_d = MMP3_FREQ_AXI1_GET(val);
+	/* dm2_cc */
+	val = __raw_readl(pmu->dm2_cc);
+	pl->core.ph_d = MMP3_FREQ_PH_GET(val);
+	pl->core.aclk_d = MMP3_FREQ_ACLK_GET(val);
+	pl->core.mm_d = MMP3_FREQ_MM_GET(val);
+	pl->core.mp1_d = MMP3_FREQ_MP1_GET(val);
+	pl->core.mp2_d = MMP3_FREQ_MP2_GET(val);
+	pl->axi.aclk2_d = MMP3_FREQ_AXI2_GET(val);
+	/* doubler */
+	val = __raw_readl(pmu->dbc);
+	pl->dram.mode4x = (MMP3_FREQ_DDR1_DBBYPASS_GET(val) != 0) ? 0 : 1;
+
+	if (crs)
+		mmp3_clear_PJ_RD_STATUS(pmu);
+
+	mmp3_freq_plan_cal(pmu, pl);
+}
+
+#define NONEOP_MASK (~(0xf))
+#define EXTRACTDIV(val) ((val) & NONEOP_MASK)
+static u32 mmp3_compare_freq_plan(struct mmp3_freq_plan *p1,
+					struct mmp3_freq_plan *p2)
+{
+	u32 mark = 0;
+	if ((EXTRACTDIV(p1->core.val) != EXTRACTDIV(p2->core.val))) {
+		printk(KERN_WARNING "<PM> CORE not same: 0x%08x != 0x%08x\n",
+			p1->core.val, p2->core.val);
+		mark |= TRACE_DFC_MARKER_CORE;
+	}
+	if ((EXTRACTDIV(p1->dram.val) != EXTRACTDIV(p2->dram.val))) {
+		printk(KERN_WARNING "<PM> DRAM not same: 0x%08x != 0x%08x\n",
+			p1->dram.val, p2->dram.val);
+		mark |= TRACE_DFC_MARKER_DRAM;
+	}
+	if ((EXTRACTDIV(p1->axi.val) != EXTRACTDIV(p2->axi.val))) {
+		printk(KERN_WARNING "<PM> AXI not same: 0x%08x != 0x%08x\n",
+			p1->axi.val, p2->axi.val);
+		mark |= TRACE_DFC_MARKER_AXI;
+	}
+	return mark;
+}
+
+static void mmp3_dpll_off(struct mmp3_pmu *pmu, u32 idx)
+{
+	u32 regval;
+	if (idx > 1) {
+		pr_err("<PM> %s: invalid doubler index %d\n"
+				, __func__, idx);
+		return;
+	}
+	writel(0, pmu->db[idx]);
+	udelay(5);
+
+	/* set bypass mode */
+	regval = readl(pmu->dbc);
+	regval |= (1u << (2 + idx));
+	writel(regval, pmu->dbc);
+}
+
+static u32 mmp3_dpll_on(struct mmp3_pmu *pmu, u32 idx,
+				u32 mode4x, u32 srckhz)
+{
+	static const u32 ICP = 0x7; /* 42.5uA */
+	static const u32 CTUNE = 0x2; /* 2 unit cap loading */
+	static const u32 VDDL = 0x4; /* 0.9v */
+	static const u32 VREG_IVREF = 0x0;
+	static const u32 VDDM = 0x1;
+	u32 outkhz, refdiv, fbdiv, vco_pre_div, kvco, regval;
+
+	if (idx > 1) {
+		pr_err("<PM> %s: invalid doubler index %d\n"
+				, __func__, idx);
+		return 0;
+	}
+
+	if ((srckhz < 100000) || (srckhz > 600000)) {
+		pr_err("<PM> %s: invalid source freq %dkhz\n"
+				, __func__, srckhz);
+		return 0; /* invalid */
+	}
+
+	refdiv = srckhz / 100000;
+	fbdiv = refdiv * 4;
+	vco_pre_div = 1;
+	while (fbdiv < 9) {
+		fbdiv *= 2;
+		vco_pre_div *= 2;
+	}
+	outkhz = (srckhz / refdiv) * fbdiv;
+
+	if ((outkhz < 1200000) || (outkhz > 2400000)) {
+		pr_err("<PM> %s: invalid target VCO freq %dkhz\n"
+				, __func__, outkhz);
+		return 0; /* out of range */
+	}
+
+	kvco = ((outkhz - 1200000) / 200000) + 1;
+
+	regval = (mode4x == 0) ? 0 : (1u << 31); /* 4x mode */
+	regval |= vco_pre_div << 29;
+	regval |= CTUNE << 27;
+	regval |= kvco << 24;
+	regval |= ICP << 20;
+	regval |= VREG_IVREF << 18;
+	regval |= VDDL << 14;
+	regval |= VDDM << 12;
+	regval |= fbdiv << 7;
+	regval |= refdiv << 2;
+
+	writel(regval, pmu->db[idx]);
+	udelay(5);
+
+	regval = readl(pmu->db[idx]);
+	regval |= (1u << 1); /* power up */
+	writel(regval, pmu->db[idx]);
+	udelay(5);
+
+	/* set bypass mode */
+	regval = readl(pmu->dbc);
+	regval &= ~(1u << (2 + idx));
+	writel(regval, pmu->dbc);
+
+	return outkhz;
+}
+
+static void mmp3_update_freq_plan(struct mmp3_pmu *pmu,
+				struct mmp3_freq_plan *pl)
+{
+	u32 val;
+
+	/* cc */
+	val = __raw_readl(pmu->cc);
+	val = MMP3_PROTECT_CC(val);	/*
+					 * clear trigger bits
+					 * clear read ignor and SB0 bits
+					 * set SB1 bits
+					 */
+	val = MMP3_FREQ_PJ_SET(val, pl->core.pj_d);
+	val = MMP3_FREQ_AT_SET(val, pl->core.at_d);
+	val = MMP3_FREQ_PH_SET(val, pl->core.ph_d);
+	val = MMP3_FREQ_DDR1_SET(val, pl->dram.pre_d);
+	val = MMP3_FREQ_AXI1_SET(val, pl->axi.aclk1_d);
+
+	set_sync_buf(CC_OFFSET, (u32)val);
+	set_sync_buf(CC_ADDR_OFFSET, (u32)pmu->cc);
+
+	/* cc2 */
+	val = __raw_readl(pmu->cc2);
+	val = MMP3_PROTECT_CC2(val); /* clear SB0 bits */
+	val = MMP3_FREQ_ACLK_SET(val, pl->core.aclk_d);
+	val = MMP3_FREQ_MM_SET(val, pl->core.mm_d);
+	val = MMP3_FREQ_MP1_SET(val, pl->core.mp1_d);
+	val = MMP3_FREQ_MP2_SET(val, pl->core.mp2_d);
+	val = MMP3_FREQ_AXI2_SET(val, pl->axi.aclk2_d);
+
+	set_sync_buf(CC2_OFFSET, (u32)val);
+	set_sync_buf(CC2_ADDR_OFFSET, (u32)pmu->cc2);
+
+	/* cc3 */
+	val = __raw_readl(pmu->cc3);
+	val = MMP3_PROTECT_CC3(val); /* clear SB0 bits */
+	val = MMP3_FREQ_DDR2_SET(val, pl->dram.pre_d);
+
+	set_sync_buf(CC3_OFFSET, (u32)val);
+	set_sync_buf(CC3_ADDR_OFFSET, (u32)pmu->cc3);
+
+	/* bus clkrst*/
+	val = __raw_readl(pmu->bus);
+	val = MMP3_PROTECT_BUSCLKRST(val); /* clear SB0 bits */
+	val = MMP3_FREQ_ASRC_SET(val, pl->axi.asrc);
+	val = MMP3_FREQ_DSRC2_SET(val, pl->dram.dsrc); /* always same as ch1 */
+
+	set_sync_buf(BUS_OFFSET, (u32)val);
+	set_sync_buf(BUS_ADDR_OFFSET, (u32)pmu->bus);
+
+	/* fccr */
+	val = __raw_readl(pmu->fccr);
+	val = MMP3_PROTECT_FCCR(val); /* clear SB0 bits */
+	val = MMP3_FREQ_PSRC_SET(val, pl->core.psrc);
+	val = MMP3_FREQ_DSRC_SET(val, pl->dram.dsrc);
+
+	set_sync_buf(FCCR_OFFSET, (u32)val);
+	set_sync_buf(FCCR_ADDR_OFFSET, (u32)pmu->fccr);
+}
+
+struct ddrdfc_param {
+	u32 oldkhz;
+	u32 newkhz;
+	u32 newcas;
+	u32 newtiming_cnt;
+	struct dmc_regtable_entry *newtiming;
+	u32 phytuning_cnt;
+	struct dmc_regtable_entry *phytuning;
+	u32 rl_cnt;
+	struct dmc_regtable_entry *rl;
+	u32 wl_cnt;
+	struct dmc_regtable_entry *wl;
+};
+
+#define COMMON_DEF(param)						\
+	u32 tmpvalue, tab, ent, map;					\
+	u32 *base = (u32 *)param;					\
+	do {								\
+		tab = 0;						\
+		ent = 0;						\
+		map = 0;						\
+		if (__raw_readl(FIXADDR(base, DMCU_MAP_CS0))		\
+					& DMCU_MAP_VALID)		\
+			map |= DMCU_CMD_CSSEL_CS0;			\
+		if (__raw_readl(FIXADDR(base, DMCU_MAP_CS1))		\
+					& DMCU_MAP_VALID)		\
+			map |= DMCU_CMD_CSSEL_CS1;			\
+	} while (0)
+
+#define BEGIN_TABLE(tabidx)						\
+	do {								\
+		tab = tabidx;						\
+		ent = 0;						\
+	} while (0)
+
+#define UPDATE_REG(val, reg)						\
+	do {								\
+		__raw_writel(val, reg);					\
+		/*printk(KERN_INFO" %08x ==> [%p]\n", val, reg);*/	\
+	} while (0)
+
+#define INSERT_ENTRY_EX(reg, b2c, b2s, pause, last)			\
+	do {								\
+		if (ent >= 32) {					\
+			pr_err("INSERT_ENTRY_EX too much entry\n");	\
+		}							\
+		if (b2c == 0xFFFFFFFF) {				\
+			tmpvalue = b2s;					\
+		} else {						\
+			tmpvalue = __raw_readl(FIXADDR(base, reg));	\
+			tmpvalue = (((tmpvalue) & (~(b2c))) | (b2s));	\
+		}							\
+		UPDATE_REG(tmpvalue, DMCU_HWTDAT0(base));		\
+		tmpvalue = reg;						\
+		if (pause)						\
+			tmpvalue |= DMCU_HWTPAUSE;			\
+		if (last)						\
+			tmpvalue |= DMCU_HWTEND;			\
+		UPDATE_REG(tmpvalue, DMCU_HWTDAT1(base));		\
+		tmpvalue = (((tab << 5) + ent) & 0x7f) | DMCU_HWTWRITE;	\
+		UPDATE_REG(tmpvalue, DMCU_HWTCTRL(base));		\
+		ent++;							\
+	} while (0)
+
+#define INSERT_ENTRIES(entries, entcount, pause, last)			\
+	do {								\
+		u32 li;							\
+		for (li = 0; li < entcount; li++) {			\
+			if ((li + 1) == entcount) {			\
+				INSERT_ENTRY_EX(entries[li].reg,	\
+						entries[li].b2c,	\
+						entries[li].b2s,	\
+						pause, last);		\
+			} else {					\
+				INSERT_ENTRY_EX(entries[li].reg,	\
+						entries[li].b2c,	\
+						entries[li].b2s,	\
+						0, 0);			\
+			}						\
+		}							\
+	} while (0)
+
+#define INSERT_ENTRY(reg, b2c, b2s) INSERT_ENTRY_EX(reg, b2c, b2s, 0, 0)
+#define PAUSE_ENTRY(reg, b2c, b2s) INSERT_ENTRY_EX(reg, b2c, b2s, 1, 0)
+#define LAST_ENTRY(reg, b2c, b2s) INSERT_ENTRY_EX(reg, b2c, b2s, 1, 1)
+#define ALLBITS (0xFFFFFFFF)
+#define NONBITS (0x00000000)
+
+#define USE_PHYTUNING 0
+#define USE_RL 0
+#define USE_WL 0
+
+static void mmp3_ddrhwt_lpddr2_h2l(u32 *dmcu, struct ddrdfc_param *param,
+				u32 table_index)
+{
+	COMMON_DEF(dmcu);
+	/*
+	 * 1 PMU asserts 'mc_sleep_req' on type 'mc_sleep_type'; MC4 enters
+	 *    self-refresh mode and hold scheduler for DDR access
+	 * 2 Frequency change
+	 *
+	 * Step 1-2 should be triggered by PMU upon DDR change request
+	 *
+	 * Step 3-6 programmed in the 1st table
+	 */
+	BEGIN_TABLE(table_index);
+	/* Halt MC4 scheduler*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* 3 update timing, we use the boot timing which is for high clock */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL4, 0, 0);
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 0, 0);
+#if USE_PHYTUNING
+	INSERT_ENTRIES(param->phytuning, param->phytuning_cnt, 0, 0);
+#endif
+
+	/* 4 reset master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* 5 update master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* 6. synchronize 2x clock */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/*
+	 * 7 wake up SDRAM; when first table done (acked) PMU will de-assert
+	 *    mc_sleep_req to wake up SDRAM from self-refresh
+	 *
+	 * 8 update SDRAM mode register, programmed in 2nd table
+	 */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL1, 0x40, 0x40);
+	/* 9 do a long ZQ Cal */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x1000));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20001));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20002));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20003));
+	/* resume scheduler*/
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0);
+}
+
+static void mmp3_ddrhwt_lpddr2_l2h(u32 *dmcu, struct ddrdfc_param *param,
+				u32 table_index)
+{
+	COMMON_DEF(dmcu);
+	/*
+	 * 1 PMU asserts 'mc_sleep_req' on type 'mc_sleep_type'; MC4 enters
+	 *    self-refresh mode and hold scheduler for DDR access
+	 *
+	 * 2 update timing, programmed in 1st table
+	 *    we just use the boot timing which is for high clock, no change
+	 */
+	BEGIN_TABLE(table_index);
+	/* Halt MC4 scheduler*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* Update CAS*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL4, 0, 0);
+#if USE_PHYTUNING
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 0, 0);
+	INSERT_ENTRIES(param->phytuning, param->phytuning_cnt, 1, 0);
+#else
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 1, 0);
+#endif
+	/*
+	 * 3 Frequency change upon 1st table done
+	 *
+	 * Step 4-6 programmed in the 2nd table
+	 */
+	/* 4 reset master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* 5 update master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* 6. synchronize 2x clock */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/*
+	 * 7 wake up SDRAM; when first table done (acked) PMU will de-assert
+	 *    mc_sleep_req to wake up SDRAM from self-refresh
+	 *
+	 * 8 update SDRAM mode register, programmed in 2nd table
+	 */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL1, 0x40, 0x40);
+	/* 9 do a long ZQ Cal */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x1000));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20001));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20002));
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, (map | 0x20003));
+	/* resume scheduler*/
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0);
+}
+
+static void mmp3_ddrhwt_ddr3_h2l(u32 *dmcu, struct ddrdfc_param *param,
+				u32 table_index)
+{
+	COMMON_DEF(dmcu);
+	/*
+	 * 1 Halt MC4 and disable SDRAM DLL, programmed in 1st table
+	 */
+	BEGIN_TABLE(table_index);
+	/* Halt MC4 scheduler*/
+	PAUSE_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/*
+	 * 2 PMU asserts 'mc_sleep_req' on type 'mc_sleep_type'; MC4 enters
+	 *    self-refresh mode and hold scheduler for DDR access
+	 * 3 Frequency change
+	 *
+	 * Step 4-7 programmed in the 2nd table
+	 */
+	/* 4 update timing, do phy tuning*/
+	/* Update CAS*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL4, 0, 0);
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 0, 0);
+#if USE_PHYTUNING
+	INSERT_ENTRIES(param->phytuning, param->phytuning_cnt, 0, 0);
+#endif
+#if USE_RL
+	INSERT_ENTRIES(param->rl, param->rl_cnt, 0, 0);
+#endif
+#if USE_WL
+	INSERT_ENTRIES(param->wl, param->wl_cnt, 0, 0);
+#endif
+	/* 5 reset master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* 6 update master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* 7. synchronize 2x clock */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/*
+	 * 8 wake up SDRAM; when first table done (acked) PMU will de-assert
+	 *    mc_sleep_req to wake up SDRAM from self-refresh
+	 *
+	 * 9 update SDRAM mode register and do ZQ Cal, programmed in 3nd table
+	 */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* 9.1 reset SDRAM DLL */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL1, 0x40, NONBITS);
+	/* 9.2 update mode register, LMR0/LMR2 */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x100));
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x400));
+	/* 9.3 do a long ZQ Cal */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x1000));
+	/* resume scheduler*/
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0);
+}
+
+static void mmp3_ddrhwt_ddr3_l2h(u32 *dmcu, struct ddrdfc_param *param,
+				u32 table_index)
+{
+	COMMON_DEF(dmcu);
+	/*
+	 * 1 PMU asserts 'mc_sleep_req' on type 'mc_sleep_type'; MC4 enters
+	 *    self-refresh mode and hold scheduler for DDR access
+	 *
+	 * 2 update timing, programmed in 1st table
+	 *    we just use the boot timing which is for high clock, no change
+	 */
+	BEGIN_TABLE(table_index);
+	/* Halt MC4 scheduler*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* Update CAS*/
+	INSERT_ENTRY(DMCU_SDRAM_CTRL4, 0, 0);
+#if USE_PHYTUNING
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 0, 0);
+	INSERT_ENTRIES(param->phytuning, param->phytuning_cnt, 1, 0);
+#else
+	INSERT_ENTRIES(param->newtiming, param->newtiming_cnt, 1, 0);
+#endif
+#if USE_RL
+	INSERT_ENTRIES(param->rl, param->rl_cnt, 0, 0);
+#endif
+#if USE_WL
+	INSERT_ENTRIES(param->wl, param->wl_cnt, 0, 0);
+#endif
+	/*
+	 * 3 Frequency change
+	 *
+	 * Step 4-6 programmed in the 2nd table
+	 */
+	/* 4 reset master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* 5 update master DLL */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* 6. synchronize 2x clock */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/*
+	 * 7 wake up SDRAM; when first table done (acked) PMU will de-assert
+	 *    mc_sleep_req to wake up SDRAM from self-refresh
+	 *
+	 * 8 enable and reset SDRAM DLL
+	 * 9 do ZQ Cal
+	 * 10 unhalt MC4 scheduler
+	 * 8-10 programmed in 3nd table
+	 */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* 8.1 reset SDRAM DLL */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL1, 0x40, 0x40);
+	/* 8.3 update mode register, LMR0/LMR2 */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x100));
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x400));
+	/* 9 do a long ZQ Cal */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, (map | 0x1000));
+	/* resume scheduler*/
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0);
+}
+
+static void mmp3_udpate_ddr_parameter_table(struct mmp3_pmu *pmu,
+						struct mmp3_freq_plan *pl)
+{
+	u32 *base;
+	u32 type, index, bit, tmpval, l2h, tabidx;
+	struct ddrdfc_param param;
+
+	mmp3_freq_plan_cal(pmu, pl);
+	tabidx = 0; /* only use table 0*/
+	UPDATE_REG((tabidx << 5) | (tabidx << 8) | 0x4, pmu->mc_par_ctrl);
+	for (index = 0; index < 2; index++) {
+		base = pmu->dmcu[index];
+		bit = 4 + index * 2;
+
+		if ((((pmu->ddrdfc_trigger & MMP3_FREQCH_DRAM_CH1) == 0)
+				&& (index == 0))
+			|| (((pmu->ddrdfc_trigger & MMP3_FREQCH_DRAM_CH2) == 0)
+				&& (index == 1))) {
+			/* no change to current channel, bypass configuration*/
+			continue;
+		}
+
+		param.oldkhz = pmu->pl_curr.khz[MMP3_CLK_DDR_1 + index];
+		param.newkhz = pl->khz[MMP3_CLK_DDR_1 + index];
+		if (param.oldkhz < param.newkhz)
+			l2h = 1;
+		else
+			l2h = 0;
+
+		type = __raw_readl(FIXADDR(base, DMCU_SDRAM_CTRL4))
+						& DMCU_SDRAM_TYPE_MASK;
+		tmpval = __raw_readl(pmu->mc_slp_req) & ~(3u << bit);
+		param.newcas = pl->dram.timing->cas;
+		param.newtiming = pl->dram.timing->table[DMCRT_TM].entry;
+		param.newtiming_cnt = pl->dram.timing->table[DMCRT_TM].count;
+#if USE_PHYTUNING
+		param.phytuning = pl->dram.timing->table[DMCRT_PH].entry;
+		param.phytuning_cnt = pl->dram.timing->table[DMCRT_PH].count;
+#endif
+#if USE_WL
+		param.wl = pl->dram.timing->table[DMCRT_WL].entry;
+		param.wl_cnt = pl->dram.timing->table[DMCRT_WL].count;
+#endif
+#if USE_RL
+		param.rl = pl->dram.timing->table[DMCRT_RL].entry;
+		param.rl_cnt = pl->dram.timing->table[DMCRT_RL].count;
+#endif
+		switch (type) {
+		case DMCU_SDRAM_TYPE_DDR3:
+			if (l2h) {
+				tmpval |=  (3u << bit);
+				UPDATE_REG(tmpval, pmu->mc_slp_req);
+				mmp3_ddrhwt_ddr3_l2h(base, &param, tabidx);
+			} else {
+				tmpval |=  (2u << bit);
+				UPDATE_REG(tmpval, pmu->mc_slp_req);
+				mmp3_ddrhwt_ddr3_h2l(base, &param, tabidx);
+			}
+			break;
+		case DMCU_SDRAM_TYPE_LPDDR2:
+			if (l2h) {
+				tmpval |= (1u << bit);
+				UPDATE_REG(tmpval, pmu->mc_slp_req);
+				mmp3_ddrhwt_lpddr2_l2h(base, &param, tabidx);
+			} else {
+				tmpval |= (0u << bit);
+				UPDATE_REG(tmpval, pmu->mc_slp_req);
+				mmp3_ddrhwt_lpddr2_h2l(base, &param, tabidx);
+			}
+			break;
+		default:
+			pr_err("<PM> unsupported DDR type in DFC\n");
+			break;
+		}
+	}
+}
+
+static u32 mmp3_prepare_freqch(struct mmp3_pmu *pmu,
+	struct mmp3_freq_plan *pl, union trace_dfc_log *logentry)
+{
+	u32 change, retry;
+	struct mmp3_freq_plan curpl;
+
+	/* obtain FC onwership, should always pass */
+	retry = 1000;
+	while ((__raw_readl(pmu->dm_cc) & (1u << 24)) != 0) {
+		retry--;
+		if (retry <= 0) {
+			pr_err("<PM> Cannot gain owner of PMU DFC\n");
+			return 0;
+		}
+	}
+
+	/* now get old configuration to see if change is necessary */
+	memcpy(&curpl, pl, sizeof(curpl));
+	mmp3_get_freq_plan(pmu, &curpl, false);
+
+	logentry->marker = 0;
+	change = 0;
+	pmu->pl_curr.core.op = MMP3_FREQ_OP_GET;
+	pmu->pl_curr.dram.op = MMP3_FREQ_OP_GET;
+	pmu->pl_curr.axi.op = MMP3_FREQ_OP_GET;
+	pmu->source_status[MMP3_CLK_MP1] = 0;
+	pmu->source_status[MMP3_CLK_AXI_1] = 0;
+	pmu->source_status[MMP3_CLK_DDR_1] = 0;
+	if (curpl.core.val != pl->core.val) {
+		if (pl->core.op == MMP3_FREQ_OP_UPDATE) {
+			pmu->pl_curr.core.op = MMP3_FREQ_OP_SHOW;
+			change |= MMP3_FREQCH_CORE;
+			logentry->marker |= TRACE_DFC_MARKER_CORE;
+			logentry->pp_core = (unsigned char) pmu->pp_curr;
+			pmu->trigge_stat[MMP3_CLK_MP1]++;
+			if (pmu->pl_curr.core.psrc != pl->core.psrc) {
+				pmu->source_status[MMP3_CLK_MP1] =
+					0x80000000 | pmu->pl_curr.core.psrc;
+				/* make sure target source enabled*/
+				mmp3_fccs_enable(pl->core.psrc);
+			}
+		} else
+			pl->core.val = curpl.core.val;
+	}
+	if (curpl.axi.val != pl->axi.val) {
+		if (pl->axi.op == MMP3_FREQ_OP_UPDATE) {
+			pmu->pl_curr.axi.op = MMP3_FREQ_OP_SHOW;
+			change |= MMP3_FREQCH_AXI;
+			logentry->marker |= TRACE_DFC_MARKER_AXI;
+			logentry->pp_axi = (unsigned char) pmu->pp_curr;
+			pmu->trigge_stat[MMP3_CLK_AXI_1]++;
+			if (pmu->pl_curr.axi.asrc != pl->axi.asrc) {
+				pmu->source_status[MMP3_CLK_AXI_1] =
+					0x80000000 | pmu->pl_curr.axi.asrc;
+				/* make sure target source enabled*/
+				mmp3_fccs_enable(pl->axi.asrc);
+			}
+		} else
+			pl->axi.val = curpl.axi.val;
+	}
+	if (curpl.dram.val != pl->dram.val) {
+		if (pl->dram.op == MMP3_FREQ_OP_UPDATE) {
+			pmu->pl_curr.dram.op = MMP3_FREQ_OP_SHOW;
+
+			change |= pmu->ddrdfc_trigger;
+			logentry->marker |= TRACE_DFC_MARKER_DRAM;
+			logentry->pp_dram = (unsigned char) pmu->pp_curr;
+			pmu->trigge_stat[MMP3_CLK_DDR_1]++;
+			if (pmu->pl_curr.dram.dsrc != pl->dram.dsrc) {
+				pmu->source_status[MMP3_CLK_DDR_1] =
+					0x80000000 | pmu->pl_curr.dram.dsrc;
+				/* make sure target source enabled*/
+				mmp3_fccs_enable(pl->dram.dsrc);
+			}
+			if (pmu->pl_curr.dram.mode4x != pl->dram.mode4x) {
+				u32 speed = mmp3_fccs_speed(pl->dram.dsrc);
+				speed = speed / FIELD2DIV(pl->dram.pre_d);
+				if (pl->dram.mode4x) {
+					/* need to program doubler */
+					mmp3_dpll_on(pmu, 0, 1, speed);
+					if (pmu->ddrdfc_trigger
+						& MMP3_FREQCH_DRAM_CH2) {
+						mmp3_dpll_on(pmu, 1, 1, speed);
+					}
+				} else {
+					/* doubler support program in place */
+					mmp3_dpll_off(pmu, 0);
+					if (pmu->ddrdfc_trigger
+						& MMP3_FREQCH_DRAM_CH2) {
+						mmp3_dpll_off(pmu, 1);
+					}
+				}
+			}
+		} else
+			pl->dram.val = curpl.dram.val;
+	}
+
+	mmp3_freq_plan_print_dbg(pmu, &pmu->pl_curr, 0);
+
+	if (change != 0) {
+		/* change required */
+		mmp3_update_freq_plan(pmu, pl);
+
+		/* Update DDR register table*/
+		if (change & MMP3_FREQCH_DRAM) {
+			if (pl->dram.timing != NULL) {
+				/* timing parameter provided, apply it */
+				mmp3_udpate_ddr_parameter_table(pmu, pl);
+			} else {
+				pr_err("<PM> DRAM TIMING update not valid, "
+					"DFC abort!!\n");
+				change &= ~MMP3_FREQCH_DRAM;
+			}
+		}
+
+	} else {
+		/* no change, need to clear PJ_RD_STATUS */
+		mmp3_clear_PJ_RD_STATUS(pmu);
+	}
+
+	return change;
+}
+
+static void mmp3_dfc_trigger(struct mmp3_pmu *pmu, struct mmp3_freq_plan *pl,
+	union trace_dfc_log *logentry, u32 change, u32 *time, u32*same)
+{
+	u32 samex, timex;
+	u32 dfc_val;
+	int done = 0, wait = 0, ret = 0;
+	int try;
+	int old, new;
+
+	old = pmu->pl_curr.khz[MMP3_CLK_MP1];
+	new = pl->khz[MMP3_CLK_MP1];
+
+	if (change == 0)
+		return;
+
+	timex = read_timestamp();
+
+	BUG_ON(irqs_disabled());
+
+	/* compose trigger val */
+	dfc_val = get_sync_buf(CC_OFFSET);
+	dfc_val = MMP3_PROTECT_CC(dfc_val); /* set reserved */
+	dfc_val = dfc_val | change | (MMP3_FREQCH_VOLTING);
+
+#define DDR_FREQ_CHG_DONE2	(1 << 12)
+#define DDR_FREQ_CHG_DONE1	(1 << 4)
+#define AXI_FREQ_CHG_DONE	(1 << 5)
+#define PJ_FREQ_CHG_DONE	(1 << 3)
+
+	if (change & MMP3_FREQCH_CORE)
+		wait |= PJ_FREQ_CHG_DONE;
+	if (change & MMP3_FREQCH_AXI)
+		wait |= AXI_FREQ_CHG_DONE;
+	if (change & MMP3_FREQCH_DRAM_CH1)
+		wait |= DDR_FREQ_CHG_DONE1;
+	if (change & MMP3_FREQCH_DRAM_CH2)
+		wait |= DDR_FREQ_CHG_DONE2;
+
+	if (change & MMP3_FREQCH_CORE) {
+		if ((old < new) && (new > 400000) && (old <= 400000))
+			cm_vote_mp1();
+	}
+
+	writel(wait, APMU_IMR);		/* unmask according irqs */
+	writel(0x0, APMU_ISR);		/* clear status */
+
+	/* if (change & (MMP3_FREQCH_CORE | MMP3_FREQCH_DRAM)) { */
+	if(true){
+			ret = mmp3_trigger_dfc_ll(dfc_val, (u32)sync_buf);
+	} else {
+		local_irq_disable();
+		writel(get_sync_buf(CC_OFFSET), pmu->cc);
+		writel(get_sync_buf(CC2_OFFSET), pmu->cc2);
+		writel(get_sync_buf(CC3_OFFSET), pmu->cc3);
+		writel(get_sync_buf(BUS_OFFSET), pmu->bus);
+		writel(get_sync_buf(FCCR_OFFSET), pmu->fccr);
+		writel(dfc_val, pmu->cc);
+
+		for (try = 0; try < 1000; try++) {
+			done = readl(APMU_ISR);
+			done &= wait;
+			if (done == wait)
+				break;
+		}
+
+		if (try >= 1000)
+			printk(KERN_ERR "%s: done %x wait %x\n", __func__, done, wait);
+		local_irq_enable();
+	}
+
+	/* clear dfc irq status */
+	writel(0x1fff, APMU_ISR);
+
+	timex = read_timestamp() - timex;
+
+	if (ret) {
+		printk(KERN_WARNING "%s: failed acquire lock\n", __func__);
+		return;
+	}
+
+	if (change & MMP3_FREQCH_CORE) {
+		if ((old > new) && (new <= 400000) && (old > 400000))
+			cm_cancel_vote_mp1();
+	}
+
+	/* now read back current frequency settings, for query*/
+	mmp3_get_freq_plan(pmu, &pmu->pl_curr, true);
+
+	samex = mmp3_compare_freq_plan(&pmu->pl_curr, pl);
+
+	if (samex != 0)
+		logentry->marker |= TRACE_DFC_MARKER_ERR;
+#if MMP3_PP_TABLE_DIFF_BYIDX
+	else {
+		int c;
+		/* patch the calculation */
+		if ((change & MMP3_FREQCH_CORE) != 0) {
+			for (c = MMP3_CLK_MP1; c <= MMP3_CLK_ACLK; c++) {
+				pmu->pl_curr.khz[c]
+					= pmu->pps[pmu->pp_curr].khz[c];
+			}
+		}
+		if ((change & MMP3_FREQCH_AXI) != 0) {
+			for (c = MMP3_CLK_AXI_1; c <= MMP3_CLK_AXI_2; c++) {
+				pmu->pl_curr.khz[c]
+					= pmu->pps[pmu->pp_curr].khz[c];
+			}
+		}
+		if ((change & MMP3_FREQCH_DRAM) != 0) {
+			for (c = MMP3_CLK_DDR_1; c <= MMP3_CLK_DDR_2; c++) {
+				pmu->pl_curr.khz[c]
+					= pmu->pps[pmu->pp_curr].khz[c];
+			}
+		}
+	}
+#endif
+
+	trace_dfc(logentry);
+
+	if (time != NULL)
+		*time = timex;
+	if (same != NULL)
+		*same = samex;
+
+	/* done, PJ_RD_STATUS should have been cleared by HW*/
+}
+
+#define GETSRC(x) ((x) & 0x7)
+static void mmp3_dfc_postchange(struct mmp3_pmu *pmu, struct mmp3_freq_plan *pl,
+	union trace_dfc_log *logentry, u32 time, u32 same)
+{
+	int oldsrc;
+
+	if (same != 0) {
+		/* usually should not be here, log a message here */
+		printk(KERN_WARNING "<PM> DFC result is not the requested one\n");
+		printk(KERN_WARNING "<PM> CORE STATUS%08x\n", readl(APMU_CORE_STATUS));
+		printk(KERN_WARNING "<PM> CC %08x CC2 %08x CC3 %08x BUS %08x\n",
+			readl(APMU_CC_PJ),  readl(APMU_CC2_PJ),
+			readl(APMU_CC3_PJ), readl(APMU_BUS));
+		printk(KERN_WARNING "<PM> DM_CC %08x DM_CC2 %08x FCCR %08x\n",
+			readl(APMU_DM_CC_PJ), readl(APMU_DM2_CC_PJ), readl(MPMU_FCCR));
+
+		mmp3_freq_plan_print_info(pmu, &pmu->pl_curr, time);
+	} else {
+		mmp3_freq_plan_print_dbg(pmu, &pmu->pl_curr, time);
+	}
+
+	/* post clock source settings */
+	if (pmu->source_status[MMP3_CLK_MP1] != 0) {
+		oldsrc = GETSRC(pmu->source_status[MMP3_CLK_MP1]);
+		if (oldsrc == pmu->pl_curr.core.psrc) {
+			/*
+			 * source not updated, fc fail, disable previously
+			 * enabled source
+			 */
+			mmp3_fccs_disable(pl->core.psrc);
+		} else {
+			/* updated, old source can be disabled */
+			mmp3_fccs_disable(oldsrc);
+		}
+	}
+	if (pmu->source_status[MMP3_CLK_DDR_1] != 0) {
+		oldsrc = GETSRC(pmu->source_status[MMP3_CLK_DDR_1]);
+		if (oldsrc == pmu->pl_curr.dram.dsrc) {
+			/*
+			 * source not updated, fc fail, disable previously
+			 * enabled source
+			 */
+			mmp3_fccs_disable(pl->dram.dsrc);
+		} else {
+			/* updated, old source can be disabled */
+			mmp3_fccs_disable(oldsrc);
+		}
+	}
+	if (pmu->source_status[MMP3_CLK_AXI_1] != 0) {
+		oldsrc = GETSRC(pmu->source_status[MMP3_CLK_AXI_1]);
+		if (oldsrc == pmu->pl_curr.axi.asrc) {
+			/*
+			 * source not updated, fc fail, disable previously
+			 * enabled source
+			 */
+			mmp3_fccs_disable(pl->axi.asrc);
+		} else {
+			/* updated, old source can be disabled */
+			mmp3_fccs_disable(oldsrc);
+		}
+	}
+
+}
+
+struct dfc_schedule {
+	void (*trigger)(struct mmp3_pmu *pmu, struct mmp3_freq_plan *pl,
+			union trace_dfc_log *logentry, u32 change,
+			u32 *time, u32 *same);
+	struct mmp3_pmu *pmu;
+	struct mmp3_freq_plan *pl;
+	union trace_dfc_log *logentry;
+	u32 change;
+	u32 time;
+	u32 same;
+	struct completion comp;
+};
+
+static struct dfc_schedule *dfcsch;
+static int dfcsch_active;
+static void __maybe_unused trigger_scheduler(u32 flag)
+{
+	unsigned long savedflags;
+
+	spin_lock_irqsave(&dfcsch_lock, savedflags);
+	if (flag == 0x80000000)
+		dfcsch_active = 0;
+	else
+		dfcsch_active = 1;
+
+	if (dfcsch != NULL) {
+		dfcsch->trigger(dfcsch->pmu, dfcsch->pl, dfcsch->logentry,
+				dfcsch->change, &dfcsch->time, &dfcsch->same);
+		complete(&dfcsch->comp);
+		dfcsch = NULL;
+	}
+	spin_unlock_irqrestore(&dfcsch_lock, savedflags);
+}
+
+static void mmp3_schedule_freqch_loose(struct mmp3_pmu *pmu,
+			struct mmp3_freq_plan *pl)
+{
+	union trace_dfc_log logentry;
+	u32 change, time, same;
+
+	spin_lock(&dfcsch_lock);
+
+	if (atomic_read(&glb_hp_lock)) {
+		spin_unlock(&dfcsch_lock);
+		return;
+	}
+
+	change = mmp3_prepare_freqch(pmu, pl, &logentry);
+	if (change == 0) {
+		spin_unlock(&dfcsch_lock);
+		return;
+	}
+
+	time = 0;
+	same = 0;
+	__raw_writel(1, pmu->swstat);
+
+	if (dfcsch_active && (pl->dram.op == MMP3_FREQ_OP_UPDATE)) {
+		struct dfc_schedule sch;
+		int ret;
+		sch.trigger = mmp3_dfc_trigger;
+		sch.pmu = pmu;
+		sch.pl = pl;
+		sch.logentry = &logentry;
+		sch.change = change;
+		sch.time = 0;
+		sch.same = 0;
+		init_completion(&sch.comp);
+		dfcsch = &sch;
+		spin_unlock(&dfcsch_lock);
+		ret = wait_for_completion_timeout(&sch.comp,
+						msecs_to_jiffies(500));
+		time = sch.time;
+		same = sch.same;
+		if (ret <= 0) {
+			/* timeout, which indicates that the trigger
+			 * is not triggering any more
+			 */
+			spin_lock(&dfcsch_lock);
+			if (dfcsch != NULL) {
+				dfcsch_active = 0;
+				dfcsch = NULL;
+				mmp3_dfc_trigger(pmu, pl, &logentry,
+							change, &time, &same);
+			}
+			spin_unlock(&dfcsch_lock);
+		}
+	} else {
+		mmp3_dfc_trigger(pmu, pl, &logentry, change, &time, &same);
+		spin_unlock(&dfcsch_lock);
+	}
+
+	mmp3_dfc_postchange(pmu, pl, &logentry, time, same);
+
+	__raw_writel(0, pmu->swstat);
+}
+
+static int mmp3_pp_find_bound(struct mmp3_pmu *pmu, int id, u32 khz)
+{
+	int i;
+	for (i = 0; i < pmu->ppscnt; i++) {
+		if (pmu->pps[i].khz[id] >= khz)
+			return i;
+	}
+	return -1;
+}
+
+static int mmp3_find_lowbar(struct mmp3_pmu *pmu, int start, int end)
+{
+	int i, lowbar;
+	lowbar = 0;
+	for (i = start; i <= end; i++) {
+		if (lowbar < pmu->pp_lowbar[i])
+			lowbar = pmu->pp_lowbar[i];
+	}
+	return lowbar;
+}
+
+/*
+ * This function implements the modle of change to lowest PP that can
+ * satisfy the request from core, ddr and axi.
+ * Lowbar means the low point of PP that meets everyone's reqirement
+ */
+static void mmp3_clk_setrate_lowbar(struct mmp3_pmu *pmu, int id, u32 khz)
+{
+	struct mmp3_freq_plan pl;
+	int ppidx;
+
+	ppidx = mmp3_pp_find_bound(pmu, id, khz);
+	if (ppidx < 0)
+		return;
+
+	mutex_lock(&(pmu->mmp3_fc_lock));
+	pmu->pp_lowbar[id] = ppidx;
+	ppidx = mmp3_find_lowbar(pmu, 0, ARRAY_SIZE(pmu->pp_lowbar) - 1);
+	if (pmu->pp_curr != ppidx) {
+		pmu->pp_curr = ppidx;
+		memcpy(&pl, &pmu->pps[ppidx], sizeof(pl));
+		/*
+		 * operation default to MMP3_FREQ_OP_GET
+		 * here assume every change, mmp3_do_freqch will omit
+		 * unnecessary part
+		 */
+		pl.core.op = MMP3_FREQ_OP_UPDATE;
+		pl.dram.op = MMP3_FREQ_OP_UPDATE;
+		pl.axi.op = MMP3_FREQ_OP_UPDATE;
+		mmp3_schedule_freqch_loose(pmu, &pl);
+	}
+	mutex_unlock(&(pmu->mmp3_fc_lock));
+}
+
+/*
+ * This function implements the modle of change core, ddr and axi frequency
+ * indenpendently. Lowbar modle still utilized in each domain, since in one
+ * domain, all individuals share the same clock source. For example when change
+ * CPU clock, the choose from the part of the PP table of the lowest one
+ * that can meets every core's requirements.
+ */
+static void mmp3_clk_setrate_localized(struct mmp3_pmu *pmu, int id, u32 khz)
+{
+	struct mmp3_freq_plan pl;
+	int ppidx;
+
+	ppidx = mmp3_pp_find_bound(pmu, id, khz);
+	if (ppidx < 0)
+		return;
+
+	mutex_lock(&(pmu->mmp3_fc_lock));
+	pmu->pp_lowbar[id] = ppidx;
+
+	if (id <= MMP3_CLK_ACLK) {
+		/* change MP */
+		ppidx = mmp3_find_lowbar(pmu, MMP3_CLK_MP1, MMP3_CLK_ACLK);
+		pmu->pp_curr = ppidx;
+		memcpy(&pl, &pmu->pps[ppidx], sizeof(pl));
+		pl.core.op = MMP3_FREQ_OP_UPDATE;
+	} else if (id <= MMP3_CLK_DDR_2) {
+		/* change DDR */
+		ppidx = mmp3_find_lowbar(pmu, MMP3_CLK_DDR_1, MMP3_CLK_DDR_2);
+		pmu->pp_curr = ppidx;
+		memcpy(&pl, &pmu->pps[ppidx], sizeof(pl));
+		pl.dram.op = MMP3_FREQ_OP_UPDATE;
+	} else if (id <= MMP3_CLK_AXI_2) {
+		/* change AXI */
+		ppidx = mmp3_find_lowbar(pmu, MMP3_CLK_AXI_1, MMP3_CLK_AXI_2);
+		pmu->pp_curr = ppidx;
+		memcpy(&pl, &pmu->pps[ppidx], sizeof(pl));
+		pl.axi.op = MMP3_FREQ_OP_UPDATE;
+	}
+	mmp3_schedule_freqch_loose(pmu, &pl);
+	mutex_unlock(&(pmu->mmp3_fc_lock));
+}
+
+/*
+ *    This function is not currently used by anyone, but it is an interface
+ * that can trigger combined CORE/DDR/AXI change to a PP. It is now mainly for
+ * debugging and testing purpose. In the future it might be used in some
+ * special scenario where we need to quickly switch to a certain PP in kernel
+ * directly without going through upper level policy makers.
+ */
+void mmp3_apply_pp(int ppidx)
+{
+	struct mmp3_freq_plan pl;
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	if (ppidx < pmu->ppscnt) {
+		memcpy(&pl, &pmu->pps[ppidx], sizeof(pl));
+		pl.core.op = MMP3_FREQ_OP_UPDATE;
+		pl.dram.op = MMP3_FREQ_OP_UPDATE;
+		pl.axi.op = MMP3_FREQ_OP_UPDATE;
+		mutex_lock(&(pmu->mmp3_fc_lock));
+		mmp3_schedule_freqch_loose(pmu, &pl);
+		mutex_unlock(&(pmu->mmp3_fc_lock));
+	}
+}
+EXPORT_SYMBOL_GPL(mmp3_apply_pp);
+
+void mmp3_setfreq(int clkid, unsigned long khz)
+{
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	if (clkid < ARRAY_SIZE(pmu->pps[0].khz)) {
+		if (pmu->setrate)
+			pmu->setrate(pmu, clkid, khz);
+	}
+}
+EXPORT_SYMBOL_GPL(mmp3_setfreq);
+
+unsigned long mmp3_getfreq(int clkid)
+{
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	if (clkid < ARRAY_SIZE(pmu->pps[0].khz))
+		return pmu->pl_curr.khz[clkid];
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mmp3_getfreq);
+
+int mmp3_get_pp_number(void)
+{
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	return pmu->ppscnt;
+}
+EXPORT_SYMBOL_GPL(mmp3_get_pp_number);
+
+unsigned long mmp3_get_pp_freq(int ppidx, int clkid)
+{
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	if ((ppidx >= pmu->ppscnt) ||
+		(clkid >= ARRAY_SIZE(pmu->pps[ppidx].khz)))
+		return 0;
+	return pmu->pps[ppidx].khz[clkid];
+}
+EXPORT_SYMBOL_GPL(mmp3_get_pp_freq);
+
+void mmp3_pm_update_dram_timing_table(int count, struct dmc_timing_entry *tab)
+{
+	int i, j = 0;
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+	printk(KERN_INFO"<PM> Fixup DDR Frequency Table parameters:\n");
+	for (i = 0; i < pmu->ppscnt; i++) {
+		if (i < count)
+			j = i;
+		pmu->pps[i].dram.op = MMP3_FREQ_OP_GET;
+		pmu->pps[i].dram.dsrc = tab[j].dsrc;
+		pmu->pps[i].dram.mode4x = tab[j].mode4x;
+		pmu->pps[i].dram.pre_d = tab[j].pre_d;
+		pmu->pps[i].dram.timing = &tab[j];
+		printk(KERN_INFO"<PM> [%d]: src:%d-mode:%d-pre_d:%d\n"
+				, i
+				, pmu->pps[i].dram.dsrc
+				, pmu->pps[i].dram.mode4x
+				, pmu->pps[i].dram.pre_d
+				);
+		mmp3_freq_plan_cal(pmu, &(pmu->pps[i]));
+	}
+
+#if MMP3_PP_TABLE_DIFF_BYIDX
+	/* process same speed, assume khz goes up only and real diff is big */
+	for (j = 0; j < ARRAY_SIZE(pmu->pps[0].khz); j++) {
+		u32 curkhz = pmu->pps[0].khz[j];
+		for (i = 1; i < pmu->ppscnt; i++) {
+			if (curkhz == pmu->pps[i].khz[j])
+				pmu->pps[i].khz[j] += i;
+			else
+				curkhz = pmu->pps[i].khz[j];
+		}
+	}
+#endif
+
+}
+EXPORT_SYMBOL_GPL(mmp3_pm_update_dram_timing_table);
+
+/* Low Power IDLE related function */
+static inline void mmp3_mod_idle_config(struct mmp3_cpu_idle_config *cic,
+			u32 target_value) {
+	u32 the_value;
+	the_value = readl(cic->idle_config);
+	the_value &= cic->idle_config_keep_mask;
+	the_value |= (target_value & cic->idle_config_valid_mask);
+	writel(the_value, cic->idle_config);
+}
+
+/*#define MMP3_WAKE_ON_DVM*/
+#define MMP3_PM_C1_INCG 0x0
+#define MMP3_PM_C1_EXCG 0x2
+#define MMP3_PM_C2_LPPD 0x62
+#define MMP3_PM_C2_L1_L2_PWD 0x820004e2
+#define MMP3_PM_C2_L1_PWD 0x82000462
+#define MMP3_PM_C2_L1_RETENT_L2_PWD 0x800004a2
+#define MMP3_PM_C2_MPPD 0x72
+#define MMP3_PM_D2_L2_PWD 0x00000462
+
+void mmp3_pm_enter_idle(int cpu)
+{
+	register u32 reg;
+	u32 state = MMP3_PM_C1_INCG;
+	struct mmp3_cpu_idle_config *cic;
+
+	cic = &(mmp3_percpu[mmp3_smpid()].cic);
+
+	mmp3_mod_idle_config(cic, state);
+	/* no DFC in process*/
+	trace_idle_entry(state);
+
+	/* need to make sure this configuration is on every core */
+	__asm__ volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (reg));
+#if defined(MMP3_WAKE_ON_DVM)
+	/* enable DVM wake up for software check */
+	reg &= ~(1 << 22);
+#else
+	/* disable DVM wake up for software check */
+	reg |= (1 << 22);
+#endif
+	__asm__ volatile ("mcr p15, 1, %0, c15, c1, 0" : : "r" (reg));
+
+#if defined(CONFIG_SMP) && defined(MMP3_WAKE_ON_DVM) && defined(CONFIG_ARM_GIC)
+	while (1) {
+		__asm__ __volatile__ ("wfi");
+		if ((__raw_readl(cic->intr_status) & 0x3ff) != 1023)
+			break; /* real wake up, break loop to handle*/
+	}
+#else
+	arch_idle();
+#endif
+
+	trace_idle_exit(__raw_readl(cic->wake_status));
+}
+
+void mmp3_pm_enter_c2(int cpu, int hpg)
+{
+	u32 state = MMP3_PM_C2_L1_PWD;
+	struct mmp3_cpu_idle_config *cic;
+	int core_id = mmp3_smpid();
+	u32 c1_cfg, c2_cfg;
+
+	if (atomic_read(&glb_hp_lock) && !hpg)
+		return;
+
+	trace_idle_entry(state);
+
+	cic = &(mmp3_percpu[core_id].cic);
+
+	c2_cfg  = readl(cic->idle_config);
+	c2_cfg &= cic->idle_config_keep_mask;
+	c2_cfg |= (MMP3_PM_C2_L1_PWD & cic->idle_config_valid_mask);
+
+	c1_cfg  = readl(cic->idle_config);
+	c1_cfg &= cic->idle_config_keep_mask;
+	c1_cfg |= (MMP3_PM_C1_INCG & cic->idle_config_valid_mask);
+
+	if (core_id == 0 || core_id == 2)
+		set_sync_buf(CM_CID_OFFSET, core_id);
+
+	if (core_id == 0) {
+		set_sync_buf(MP1_C1_CFG_OFFSET, c1_cfg);
+		set_sync_buf(MP1_C2_CFG_OFFSET, c2_cfg);
+	} else if (core_id == 1) {
+		set_sync_buf(MP2_C1_CFG_OFFSET, c1_cfg);
+		set_sync_buf(MP2_C2_CFG_OFFSET, c2_cfg);
+	} else if (core_id == 2) {
+		set_sync_buf(MM_C1_CFG_OFFSET, c1_cfg);
+		set_sync_buf(MM_C2_CFG_OFFSET, c2_cfg);
+	}
+
+	mmp3_enter_c2((u32)sync_buf);
+
+	/* disable global irq of ICU for MP1, MP2, MM*/
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ1_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ2_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ3_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ4_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ5_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ6_MSK);
+
+	trace_idle_exit(__raw_readl(cic->wake_status));
+}
+
+
+static void mmp3_do_idle(void)
+{
+	if (!need_resched())
+		mmp3_pm_enter_idle(smp_processor_id());
+	local_irq_enable();
+}
+
+static void program_ddr3_calibration_cmd_b0(unsigned int dmcu, unsigned int tabidx)
+{
+	COMMON_DEF(dmcu);
+	BEGIN_TABLE(tabidx);
+
+	/* make sure that Mck4 is halt for any read\write commands */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* PHY DLL reset */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* PHY DLL Update */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* Sync 2x clock (EOP) */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/* Reset DLL */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL1, 0, 0x40);
+	/* Send LMR0 DLL */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, 0x03000100);
+	/* Send LMR2 DLL */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, 0x03000400);
+	/* ZQ Calibration */
+	INSERT_ENTRY(DMCU_USER_COMMAND0, ALLBITS, 0x03001000);
+	/* resume scheduler */
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x0);
+}
+
+static void program_lpddr2_calibration_cmd_b0(unsigned int dmcu, unsigned int tabidx)
+{
+	COMMON_DEF(dmcu);
+	BEGIN_TABLE(tabidx);
+
+	/* make sure that Mck4 is halt for any read\write commands */
+	INSERT_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x2);
+	/* PHY DLL reset */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x20000000);
+	/* PHY DLL Update */
+	INSERT_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x40000000);
+	/* Sync 2x clock (EOP) */
+	PAUSE_ENTRY(DMCU_PHY_CTRL14, ALLBITS, 0x80000000);
+
+	/* MR 1 */
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, 0x03020001);
+	/* MR 2 */
+	INSERT_ENTRY(DMCU_USER_COMMAND1, ALLBITS, 0x03020002);
+	/* resume scheduler */
+	LAST_ENTRY(DMCU_SDRAM_CTRL14, ALLBITS, 0x0);
+}
+
+static void program_dll_table_b0(unsigned int dmcu, unsigned int tabidx)
+{
+	u32 mc_parctr;
+	unsigned int ddr_type;
+
+	ddr_type = (__raw_readl(dmcu + 0x58) & 0x1C) >> 2;
+	if (ddr_type == 0x2)
+		program_ddr3_calibration_cmd_b0(dmcu, tabidx);
+	else
+		program_lpddr2_calibration_cmd_b0(dmcu, tabidx);
+
+	mc_parctr = __raw_readl(APMU_MC_PAR_CTRL) & ~(0x4);
+	if (dmcu == (u32)mmp3_pmu_config.dmcu[0]) {
+		mc_parctr &= ~(0x7 << 5);
+		mc_parctr |= (tabidx << 5);
+	} else {
+		mc_parctr &= ~(0x7 << 8);
+		mc_parctr |= (tabidx << 8);
+	}
+	__raw_writel(mc_parctr, APMU_MC_PAR_CTRL);
+}
+
+static u32 ccic, gc, vmeta, audio_clk, apcr;
+void mmp3_set_wakeup_src(void)
+{
+	int val = 0;
+
+	/* enable wakeup 7 as wakeup input source */
+	val |= (1 << 7);
+	/* enable rtc as wakeup input source */
+	val |= ((1 << 17) | (1 << 4));
+	/* enable gpio as wakeup input source */
+	val |= (1 << 2);
+	__raw_writel(val, MPMU_AWUCRM);
+}
+
+static void d2(void)
+{
+	u32 reg;
+	u32 tmp_gc;
+	/* walk around for B0: program dll table before entering D2 */
+	program_dll_table_b0((u32)mmp3_pmu_config.dmcu[0], 0);
+
+	reg = __raw_readl(APMU_BUS);
+	if (reg & (1 << 1))
+		/* prgram dll table for MC2 only when it is released from reset */
+		program_dll_table_b0((u32)mmp3_pmu_config.dmcu[1], 0);
+	else
+		/* make the wake up state machine do not wait for ack from MC2 idle */
+		__raw_writel(__raw_readl(APMU_DEBUG2) | (1 << 1), APMU_DEBUG2);
+
+	ccic = __raw_readl(APMU_CCIC_RST);
+	gc = __raw_readl(APMU_GC);
+	tmp_gc = gc & 0x600 ;
+	vmeta = __raw_readl(APMU_VMETA);
+	/* Disable power to other power islands: ISP, GC and VMeta */
+	__raw_writel(0x00, APMU_CCIC_RST);
+	/*__raw_writel(0x00, APMU_GC);*/
+	__raw_writel(tmp_gc, APMU_GC);
+	__raw_writel(0x00, APMU_VMETA);
+
+	/* Disable power to Audio island */
+	audio_clk = __raw_readl(APMU_AUDIO_CLK_RES_CTRL);
+	__raw_writel(0x00, APMU_AUDIO_CLK_RES_CTRL);
+
+	reg = __raw_readl(APMU_AUDIO_SRAM_PWR);
+	reg |= (0x3 << 6);
+	reg |= (0x3 << 8);
+	reg |= (0x3 << 10);
+	__raw_writel(reg, APMU_AUDIO_SRAM_PWR);
+
+	/* Dragonite power control */
+	__raw_writel(0xbe086000, MPMU_CPCR);
+
+	apcr = __raw_readl(MPMU_APCR);
+	/* PJ power control, wake up port 2(gpio),4(rtc),7(pmic) enabled*/
+	__raw_writel(__raw_readl(MPMU_APCR) | (1 << 31) | (1 << 27) |
+			(1 << 26) | (1 << 20) | (1 << 22) | (1 << 23) |
+			(1 << 19) | (1 << 16) | (1 << 17) | (1 << 25),
+			MPMU_APCR);
+}
+
+extern void l2x0_enable(void);
+void mmp3_pm_enter_d2(void)
+{
+	struct mmp3_cpu_idle_config *cic;
+	int core_id = mmp3_smpid();
+	u32 the_value;
+	/*register u32 reg;*/
+
+	cic = &(mmp3_percpu[core_id].cic);
+
+	d2();
+	mmp3_mod_idle_config(cic, MMP3_PM_D2_L2_PWD);
+
+	/* d2 workaround: shut down AT clock by setting bit [31]
+	 * of PMUA_PJ_IDLE_CONFIG */
+	the_value = readl(cic->idle_config);
+	the_value &= ~(1 << 31);
+	writel(the_value, cic->idle_config);
+
+	mmp3_set_wakeup_src();
+
+	/* workaround: keep SL2 power off */
+	__raw_writel(__raw_readl(0xfe282a48) & ~(1 << 15), 0xfe282a48);
+	__raw_writel(__raw_readl(0xfe282a4c) & ~(1 << 15), 0xfe282a4c);
+	__raw_writel(__raw_readl(0xfe282a50) & ~(1 << 15), 0xfe282a50);
+
+	printk("before suspend\n");
+
+	/* d2 workaround: enable RTC & PMIC & GPIO ICU wake up */
+	__raw_writel(0x2f, ICU1_REG(0x10));
+	__raw_writel(0x2f, ICU1_REG(0x14));
+	__raw_writel(0x2f, ICU1_REG(0xc4));
+
+	/* disable automatic pad calibration */
+	__raw_writel(__raw_readl(0xfe50023c) & ~(1 << 16), 0xfe50023c);
+
+	flush_cache_all();
+	dsb();
+	/* flush outer cache */
+	outer_flush_all();
+	dsb();
+
+	/* L2 cache operation before D2 */
+	outer_flush_all();
+	dsb();
+	/* outer_disable(); commented by czm */
+
+	__asm__ __volatile__ ("wfi");
+
+	/* L2 cache operation after D2 */
+	outer_inv_all();
+	dsb();
+	/* l2x0_enable();  commented by czm */
+
+	/* enable automatic pad calibration */
+	__raw_writel(__raw_readl(0xfe50023c) | (1 << 16), 0xfe50023c);
+
+	__raw_writel(0x0, ICU1_REG(0x10));
+	__raw_writel(0x0, ICU1_REG(0x14));
+	__raw_writel(0x0, ICU1_REG(0xc4));
+
+	printk("after resume\n");
+
+	/* disable global irq of ICU for MP1, MP2, MM*/
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ1_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ2_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ3_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ4_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ5_MSK);
+	__raw_writel(0x1, MMP3_ICU_GBL_IRQ6_MSK);
+
+	__raw_writel(apcr, MPMU_APCR);
+
+	/* resotre audio clocks otherwise will hang later */
+	__raw_writel(audio_clk, APMU_AUDIO_CLK_RES_CTRL);
+
+	__raw_writel(ccic, APMU_CCIC_RST);
+	__raw_writel(gc, APMU_GC);
+	__raw_writel(vmeta, APMU_VMETA);
+
+	mmp3_mod_idle_config(cic, MMP3_PM_C1_INCG);
+}
+
+#ifdef CONFIG_SMP
+extern unsigned long c2_reserve_pa;
+#define C2_RESERVE_SIZE	(1024 * 1024)
+#endif
+
+static int __init mmp3_pm_init(void)
+{
+	int i, j;
+	u32 ddrt;
+	struct mmp3_pmu *pmu = &mmp3_pmu_config;
+
+#ifdef CONFIG_SMP
+	/* FIXME: Here we assume all cores will be on before here! */
+	num_cpus = num_online_cpus();
+#endif
+
+	pmu->swstat_store = 0;
+	pmu->swstat = &(pmu->swstat_store);
+	spin_lock_init(&(pmu->mmp3_fc_spin));
+	mutex_init(&(pmu->mmp3_fc_lock));
+
+#ifdef CONFIG_SMP
+	sync_buf = __arm_ioremap(c2_reserve_pa, PAGE_SIZE, MT_UNCACHED);
+	if (sync_buf == NULL) {
+		pr_err("%s: failed to remap memory for C2\n", __func__);
+		BUG();
+	}
+
+	memset(sync_buf, 0x0, PAGE_SIZE);
+
+	set_sync_buf(INT_STATUS_ADDR_OFFSET, (u32)INTR_STAT);
+	set_sync_buf(WAKE_STATUS_ADDR_OFFSET, (u32)WAKE_STAT);
+	set_sync_buf(SGIR_ADDR_OFFSET, (u32)(GIC_DIST_VIRT_BASE + GIC_DIST_SOFTINT));
+	set_sync_buf(APMU_BASE_ADDR_OFFSET, APMU_VIRT_BASE);
+
+	coherent_state = (unsigned int *)sync_buf;
+	/* we are at coherent state */
+	for (i = 0; i < num_cpus; i++)
+		coherent_state[i] = 1;
+#endif
+
+	for (j = 0; j < ARRAY_SIZE(mmp3_fccs); j++) {
+		mmp3_fccs[j].source =
+			clk_get(NULL, mmp3_fccs[j].name);
+		if (mmp3_fccs[j].source != NULL) {
+			mmp3_fccs[j].frequency =
+				clk_get_rate(mmp3_fccs[j].source) / 1000;
+		} else {
+			panic("mmp3_pm_init: invalid source %s\n",
+				mmp3_fccs[j].name);
+			return -1;
+		}
+	}
+
+	/* 1. set bit[0] to ignore SP idle status for DFC
+	 * 2. set bit[1] to mask the Moltres halt ack to DFC state machine
+	 */
+	__raw_writel(0x00000001, APMU_DEBUG);
+	__raw_writel(0x0, APMU_DEBUG2);
+
+	/* unmask and clear all dfc irqs */
+	writel(0x0, APMU_IRWC);
+	writel(0x0, APMU_IMR);
+
+	pm_idle = mmp3_do_idle;
+
+	/* vote SPSD*/
+	__raw_writel(__raw_readl(MPMU_APCR) | (1u << 28), MPMU_APCR);
+
+	/* fix DDR settings according to DDR module */
+	ddrt = (__raw_readl(pmu->mc_interleave) & (0x7f << 0));
+	if (ddrt == 0) {
+		pmu->ddrdfc_trigger = MMP3_FREQCH_DRAM_CH1;
+		printk(KERN_INFO "Dual MC disabled\n");
+	} else {
+		pmu->ddrdfc_trigger = MMP3_FREQCH_DRAM;
+		printk(KERN_INFO "Dual MC enabled, config 0x%x\n", ddrt);
+	}
+
+	for (i = 0; i < pmu->ppscnt; i++)
+		mmp3_freq_plan_cal(pmu, &(pmu->pps[i]));
+
+#if MMP3_PP_TABLE_DIFF_BYIDX
+	/* process same speed, assume khz goes up only and real diff is big */
+	for (j = 0; j < ARRAY_SIZE(pmu->pps[0].khz); j++) {
+		u32 curkhz = pmu->pps[0].khz[j];
+		for (i = 1; i < pmu->ppscnt; i++) {
+			if (curkhz == pmu->pps[i].khz[j])
+				pmu->pps[i].khz[j] += i;
+			else
+				curkhz = pmu->pps[i].khz[j];
+		}
+	}
+#endif
+
+	if (0)
+		pmu->setrate = mmp3_clk_setrate_lowbar;
+	else
+		pmu->setrate = mmp3_clk_setrate_localized;
+
+	mmp3_get_freq_plan(pmu, &pmu->pl_curr, true);
+	pmu->pl_curr.core.op = MMP3_FREQ_OP_SHOW;
+	pmu->pl_curr.dram.op = MMP3_FREQ_OP_SHOW;
+	pmu->pl_curr.axi.op = MMP3_FREQ_OP_SHOW;
+	mmp3_freq_plan_print_info(pmu, &pmu->pl_curr, 0);
+
+	/* set default ddr table */
+	for (j = 0; j < pmu->ppscnt; j++) {
+		pmu->pps[j].dram.op = MMP3_FREQ_OP_GET;
+		pmu->pps[j].dram.dsrc = pmu->pl_curr.dram.dsrc;
+		pmu->pps[j].dram.pre_d = pmu->pl_curr.dram.pre_d;
+		pmu->pps[j].dram.mode4x = pmu->pl_curr.dram.mode4x;
+	}
+
+	/* now let's hold source reference */
+	mmp3_fccs_enable(pmu->pl_curr.core.psrc);
+	mmp3_fccs_enable(pmu->pl_curr.dram.dsrc);
+	mmp3_fccs_enable(pmu->pl_curr.axi.asrc);
+
+	dfcsch = NULL;
+	dfcsch_active = 0;
+
+	register_cpu_notifier(&mmp3_pm_cpu_notifier);
+
+	mmp3_setfreq(MMP3_CLK_AXI_1, 250000); /* lower default fabric speed*/
+
+	/* register fb notifier */
+	fb_register_client(&mmp3_fb_notif);
+
+	return 0;
+}
+
+postcore_initcall(mmp3_pm_init);
diff --git a/arch/arm/mach-mmp/pmu.c b/arch/arm/mach-mmp/pmu.c
new file mode 100644
index 0000000..fdd4c17
--- /dev/null
+++ b/arch/arm/mach-mmp/pmu.c
@@ -0,0 +1,174 @@
+/*
+ * PMU IRQ registration for MMP PMU families.
+ *
+ * (C) Copyright 2011 Marvell International Ltd.
+ * All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <asm/pmu.h>
+#include <asm/io.h>
+#include <mach/addr-map.h>
+#include <mach/cputype.h>
+#include <mach/irqs.h>
+#include <mach/regs-ciu.h>
+
+#define CORESIGHT_VIRT_BASE	(APB_VIRT_BASE + 0x100000)
+#define CTI_CORE0_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x18000)
+#define CTI_CORE1_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x19000)
+#define CTI_SOC_VIRT_BASE	(CORESIGHT_VIRT_BASE + 0x6000)
+
+#define CTI_CTRL		0x0
+#define CTI_EN_MASK		0x0F
+#define CTI_EN_IN0		0x20
+#define CTI_EN_IN1		0x24
+#define CTI_EN_IN2		0x28
+#define CTI_EN_IN3		0x2C
+#define CTI_EN_IN4		0x30
+#define CTI_EN_IN5		0x34
+#define CTI_EN_IN6		0x38
+#define CTI_EN_IN7		0x3C
+#define CTI_EN_OUT0		0xA0
+#define CTI_EN_OUT1		0xA4
+#define CTI_EN_OUT2		0xA8
+#define CTI_EN_OUT3		0xAC
+#define CTI_EN_OUT4		0xB0
+#define CTI_EN_OUT5		0xB4
+#define CTI_EN_OUT6		0xB8
+#define CTI_EN_OUT7		0xBC
+#define CTI_LOCK		0xFB0
+
+
+/* NOTE: Order fixed as mp1/mp2/mm core id = 0, 1, 2 */
+static struct resource pmu_resource_mmp3[] = {
+	/* MP1 = 0 */
+	{
+		.start	= IRQ_MMP3_PMU_INT0,
+		.end	= IRQ_MMP3_PMU_INT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* MP2 = 1*/
+	{
+		.start	= IRQ_MMP3_PMU_INT1,
+		.end	= IRQ_MMP3_PMU_INT1,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* mm  = 2*/
+	{
+		.start	= IRQ_MMP3_PMU_INT2,
+		.end	= IRQ_MMP3_PMU_INT2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource pmu_resource_pxa988[] = {
+	/* core0 */
+	{
+		.start	= IRQ_PXA988_CORESIGHT,
+		.end	= IRQ_PXA988_CORESIGHT,
+		.flags	= IORESOURCE_IRQ,
+	},
+	/* core1*/
+	{
+		.start	= IRQ_PXA988_CORESIGHT2,
+		.end	= IRQ_PXA988_CORESIGHT2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+
+static struct platform_device pmu_device = {
+	.name		= "arm-pmu",
+	.id		= ARM_PMU_DEVICE_CPU,
+};
+
+static void __init pxa988_cti_init(void)
+{
+	u32 tmp;
+
+	/* enable access CTI registers for core0 */
+	tmp = __raw_readl(CIU_CA9_CPU_CORE0_CONF);
+	tmp |= 0x100000;
+	__raw_writel(tmp, CIU_CA9_CPU_CORE0_CONF);
+
+	/* enable access CTI registers for core1 */
+	tmp = __raw_readl(CIU_CA9_CPU_CORE1_CONF);
+	tmp |= 0x100000;
+	__raw_writel(tmp, CIU_CA9_CPU_CORE1_CONF);
+
+	/* enable the write access to CTI0 & CTI1 */
+	__raw_writel(0xC5ACCE55, CTI_CORE0_VIRT_BASE + CTI_LOCK);
+	__raw_writel(0xC5ACCE55, CTI_CORE1_VIRT_BASE + CTI_LOCK);
+
+	/* enable the write access to SOC CTI */
+	__raw_writel(0xC5ACCE55, CTI_SOC_VIRT_BASE + CTI_LOCK);
+
+	/* enable CTI for core0 & core1*/
+	__raw_writel(0x1, CTI_CORE0_VIRT_BASE + CTI_CTRL);
+	__raw_writel(0x1, CTI_CORE1_VIRT_BASE + CTI_CTRL);
+
+	/* enable CTI for SOC */
+	__raw_writel(0x1, CTI_SOC_VIRT_BASE + CTI_CTRL);
+
+	/*
+	 * enable core0 CTI triger in1 from PMU0 irq to CTM channel 0
+	 * and enable the CTM channel 0 route to core0 CTI trigger out 6
+	 */
+	tmp = __raw_readl(CTI_CORE0_VIRT_BASE + CTI_EN_IN1);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x1;
+	__raw_writel(tmp, CTI_CORE0_VIRT_BASE + CTI_EN_IN1);
+
+	tmp = __raw_readl(CTI_CORE0_VIRT_BASE + CTI_EN_OUT6);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x1;
+	__raw_writel(tmp, CTI_CORE0_VIRT_BASE + CTI_EN_OUT6);
+
+	/*
+	 * enable core1 CTI triger in1 from PMU1 irq to CTM channel 1
+	 * and enable the CTM channel 1 route to core1 CTI trigger out 6
+	 */
+	tmp = __raw_readl(CTI_CORE1_VIRT_BASE + CTI_EN_IN1);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x2;
+	__raw_writel(tmp, CTI_CORE1_VIRT_BASE + CTI_EN_IN1);
+
+	tmp = __raw_readl(CTI_CORE1_VIRT_BASE + CTI_EN_OUT6);
+	tmp &= ~CTI_EN_MASK;
+	tmp |= 0x2;
+	__raw_writel(tmp, CTI_CORE1_VIRT_BASE + CTI_EN_OUT6);
+
+	/* disable the write access to SOC CTI */
+	__raw_writel(0x55AA55AA, CTI_SOC_VIRT_BASE + CTI_LOCK);
+
+	/* disable the write access to CTI0 & CTI1 */
+	__raw_writel(0x55AA55AA, CTI_CORE0_VIRT_BASE + CTI_LOCK);
+	__raw_writel(0x55AA55AA, CTI_CORE1_VIRT_BASE + CTI_LOCK);
+}
+
+static int __init pxa_pmu_init(void)
+{
+	if (cpu_is_mmp3()) {
+		pmu_device.resource = pmu_resource_mmp3;
+		pmu_device.num_resources = ARRAY_SIZE(pmu_resource_mmp3);
+	} else if (cpu_is_pxa988()) {
+		pmu_device.resource = pmu_resource_pxa988;
+		pmu_device.num_resources = ARRAY_SIZE(pmu_resource_pxa988);
+
+		/* Need to init CTI irq line */
+		pxa988_cti_init();
+	} else {
+		printk(KERN_WARNING "unsupported Soc for PMU");
+		return -EIO;
+	}
+
+	platform_device_register(&pmu_device);
+	return 0;
+}
+arch_initcall(pxa_pmu_init);
diff --git a/arch/arm/mach-mmp/qseven.c b/arch/arm/mach-mmp/qseven.c
new file mode 100644
index 0000000..6bea051c
--- /dev/null
+++ b/arch/arm/mach-mmp/qseven.c
@@ -0,0 +1,1001 @@
+/*
+ *  linux/arch/arm/mach-mmp/qseven.c
+ *  Dipen Patel, dpatel@marvell.com
+ *  Derived from abilene.c
+ *  Support for the Marvell MMP3 Qseven Platform.
+ *
+ *  Copyright (C) 2009-2010 Marvell International Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/smc91x.h>
+
+#include <linux/regulator/88pm867.h>
+#include <linux/i2c/tsc2007.h>
+#include <linux/mmc/sdhci.h>
+
+#include <linux/pwm_backlight.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/fixed.h>
+#if defined(CONFIG_SENSORS_LSM303DLHC_ACC) || \
+	defined(CONFIG_SENSORS_LSM303DLHC_MAG)
+#include <linux/i2c/lsm303dlhc.h>
+#endif
+#if defined(CONFIG_SENSORS_L3G4200D_GYR)
+#include <linux/i2c/l3g4200d.h>
+#endif
+#if defined(CONFIG_SPI_PXA2XX)
+#include <linux/spi/spi.h>
+#include <linux/spi/pxa2xx_spi.h>
+#include <linux/spi/ntrig_spi.h>
+#endif
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/setup.h>
+#include <mach/addr-map.h>
+#include <mach/mfp-mmp2.h>
+#include <mach/mmp3.h>
+#include <mach/irqs.h>
+#include <mach/regs-mpmu.h>
+#include <mach/soc_vmeta.h>
+#include <mach/hsi_dev.h>
+#include <plat/pmem.h>
+#include <plat/usb.h>
+#include <mach/sram.h>
+#include <mach/uio_hdmi.h>
+#include <media/soc_camera.h>
+#include <mach/mmp3_pm.h>
+#include <mach/gpio.h>
+#include <mach/regs-fastenet.h>
+#include <linux/pxa168_eth.h>
+
+#include "common.h"
+#include "onboard.h"
+
+#define QSEVEN_NR_IRQS		(IRQ_BOARD_START + 64)
+extern unsigned int mmp_plat_ref_clk;
+
+static unsigned long qseven_pin_config[] __initdata = {
+	/* UART3 */
+	GPIO51_UART3_RXD,
+	GPIO52_UART3_TXD,
+
+	/* TWSI5 not connected in rev 1 carrier board*/
+	GPIO99_TWSI5_SCL,
+	GPIO100_TWSI5_SDA,
+
+	/* TWSI6 for HDMI */
+	GPIO97_TWSI6_SCL,
+	GPIO98_TWSI6_SDA,
+
+	/* TWSI2 for camera */
+	GPIO55_TWSI2_SCL,
+	GPIO56_TWSI2_SDA,
+	GPIO73_CAM_MCLK,
+	GPIO72_GPIO,
+
+	/* TWSI3 for audio codec on carrier card rev 2*/
+	GPIO95_TWSI3_SCL,
+	GPIO96_TWSI3_SDA,
+	HDA_RST_N_GPIO_79, /*Not connected in carrier rev 1 board*/
+
+	/* TWSI4 touch controller on carrier card*/
+	TWSI4_SCL,
+	TWSI4_SDA,
+	TSI_INT_N, /*also smb_int_n in the card schema*/
+
+	/*PWM3*/
+	GPIO53_PWM3,
+	/*PWM4 for Q7 board rev 1, not connected anywhere*/
+	GPIO54_PWM4,
+
+	/* SSPA1 (I2S) */
+	GPIO25_I2S_BITCLK,
+	GPIO26_I2S_SYNC,
+	GPIO27_I2S_DATA_OUT,
+	GPIO28_I2S_SDATA_IN,
+
+	/*ULPI QSEVEN rev 1*/
+	ULPI_DATA_0_GPIO_66,
+	ULPI_DATA_1_GPIO_65,
+	ULPI_DATA_2_GPIO_64,
+	ULPI_DATA_3_GPIO_63,
+	ULPI_DATA_4_GPIO_62,
+	ULPI_DATA_5_GPIO_61,
+	ULPI_DATA_6_GPIO_60,
+	ULPI_DATA_7_GPIO_59,
+	ULPI_RST_N_GPIO_71,
+	ULPI_CLK_GPIO_70,
+	ULPI_DIR_GPIO_69,
+	ULPI_NXT_GPIO_68,
+	ULPI_STP_GPIO_67,
+
+	/* SSP1 FOR NOR FLASH, NOT POPULTAED*/
+	SSP1_RXD_GPIO_43,
+	SSP1_TXD_GPIO_44,
+	SSP1_CLK_GPIO_45,
+	SSP1_FRM_GPIO_46,
+
+	/* SSP3 FOR CAN*/
+	GPIO74_SSP_CLK,
+	GPIO75_SSP_FRM,
+	GPIO76_SSP_TXD,
+	GPIO77_SSP_RXD,
+
+	/*Power button not connected in rev 1 carrier board*/
+	GPIO80_GPIO,
+	/*HDMI_HPD_N for hdmi detect, y no hdmi_cec*/
+	GPIO81_GPIO,
+	GPIO82_GPIO,
+	GPIO83_GPIO,
+
+	/*LED*/
+	GPIO84_GPIO,
+	GPIO85_GPIO,
+	GPIO86_GPIO,
+	GPIO87_GPIO,
+
+};
+
+static unsigned long mmc1_pin_config[] __initdata = {
+	GPIO131_MMC1_DAT3,
+	GPIO132_MMC1_DAT2,
+	GPIO133_MMC1_DAT1,
+	GPIO134_MMC1_DAT0,
+	GPIO136_MMC1_CMD,
+	GPIO135_MMC1_CLK,
+	GPIO140_MMC1_CD | MFP_PULL_HIGH,
+	GPIO141_MMC1_WP | MFP_PULL_HIGH,
+	GPIO137_GPIO, /*drive low to enable power to card*/
+};
+
+/* MMC2 is used for WIB card */
+static unsigned long mmc2_pin_config[] __initdata = {
+	GPIO37_MMC2_DAT3,
+	GPIO38_MMC2_DAT2,
+	GPIO39_MMC2_DAT1,
+	GPIO40_MMC2_DAT0,
+	GPIO41_MMC2_CMD,
+	GPIO42_MMC2_CLK,
+
+	/* GPIO used for power */
+	/*GPIO57_GPIO | MFP_LPM_DRIVE_HIGH,  WLAN_PD_N */
+#ifdef CONFIG_SD8XXX_RFKILL
+	GPIO57_GPIO | MFP_LPM_DRIVE_LOW,
+#else
+	GPIO57_GPIO | MFP_LPM_DRIVE_HIGH,
+#endif
+	WIFI_32K_CLK_OUT,
+};
+
+static unsigned long mmc3_pin_config[] __initdata = {
+	GPIO108_MMC3_DAT7,
+	GPIO109_MMC3_DAT6,
+	GPIO161_MMC3_DAT5,
+	GPIO163_MMC3_DAT4,
+	GPIO111_MMC3_DAT3,
+	GPIO110_MMC3_DAT2,
+	GPIO162_MMC3_DAT1,
+	GPIO164_MMC3_DAT0,
+	GPIO145_MMC3_CMD,
+	GPIO146_MMC3_CLK,
+};
+
+static struct sram_bank mmp3_audiosram_info = {
+	.pool_name = "audio sram",
+	.step = AUDIO_SRAM_GRANULARITY,
+};
+
+static struct sram_bank mmp3_videosram_info = {
+	.pool_name = "mmp-videosram",
+	.step = VIDEO_SRAM_GRANULARITY,
+};
+
+#if defined(CONFIG_DDR_DEVFREQ)
+struct devfreq_frequency_table *mmp3_ddr_freq_table;
+struct devfreq_pm_qos_table ddr_freq_qos_table[] = {
+	{
+		.freq = 533333,
+		.qos_value = DDR_CONSTRAINT_LVL0,
+	},
+	{
+		.freq = 800000,
+		.qos_value = DDR_CONSTRAINT_LVL1,
+	},
+	{
+		.freq = 1066666,
+		.qos_value = DDR_CONSTRAINT_LVL2,
+	},
+	{0, 0},
+};
+
+static struct devfreq_platform_data ddr_info = {
+	.clk_name = "ddr",
+	.interleave_is_on = 1,
+};
+
+
+static void ddr_devfreq_init(void)
+{
+	u32 i = 0;
+	u32 ddr_freq_num = mmp3_get_pp_number();
+
+	mmp3_ddr_freq_table = kmalloc(sizeof(struct devfreq_frequency_table) * \
+					(ddr_freq_num + 1), GFP_KERNEL);
+
+	if (!mmp3_ddr_freq_table)
+		return;
+
+	for (i = 0; i < ddr_freq_num; i++) {
+		mmp3_ddr_freq_table[i].index = i;
+		mmp3_ddr_freq_table[i].frequency = mmp3_get_pp_freq(i, MMP3_CLK_DDR_1);
+	}
+	mmp3_ddr_freq_table[i].index = i;
+	mmp3_ddr_freq_table[i].frequency = DEVFREQ_TABLE_END;
+
+
+	ddr_info.freq_table = mmp3_ddr_freq_table;
+	ddr_info.hw_base[0] = DMCU_VIRT_BASE;
+	ddr_info.hw_base[1] = DMCU_VIRT_BASE + 0x10000;
+	ddr_info.qos_list = ddr_freq_qos_table;
+
+}
+#endif
+
+#ifdef CONFIG_UIO_VMETA
+static struct vmeta_plat_data mmp_vmeta_plat_data = {
+	.bus_irq_handler = NULL,
+	.axi_clk_available = 0,
+	.power_down_ms = 100,
+};
+
+static void __init mmp_init_vmeta(void)
+{
+	mmp_set_vmeta_info(&mmp_vmeta_plat_data);
+}
+#endif
+
+#ifdef CONFIG_VMETA_DEVFREQ
+extern int set_vmeta_freqs_table(struct devfreq *devfreq);
+static struct devfreq_platform_data devfreq_vmeta_pdata = {
+	.clk_name = "VMETA_CLK",
+	.setup_freq_table = set_vmeta_freqs_table,
+};
+
+static void __init mmp_init_devfreq_vmeta(void)
+{
+	mmp_set_devfreq_vmeta_info(&devfreq_vmeta_pdata);
+}
+#endif
+
+static struct pxa27x_keypad_platform_data mmp3_keypad_info = {
+	.direct_key_map = {
+		KEY_BACK,
+		KEY_MENU,
+		KEY_HOME,
+		KEY_SEARCH,
+		KEY_VOLUMEUP,
+		KEY_VOLUMEDOWN,
+	},
+	.direct_key_num = 6,
+	.debounce_interval = 30,
+	.active_low = 1,
+};
+
+#if defined(CONFIG_TOUCHSCREEN_TSC2007)
+static int tsc2007_init_gpio_irq(void)
+{
+	int gpio = mfp_to_gpio(TSI_INT_N);
+
+	if (gpio_request(gpio, "TSC2007 GPIO irq")) {
+			pr_err("gpio %d request failed\n", gpio);
+			return -1;
+	}
+	gpio_direction_input(gpio);
+	mdelay(100);
+	gpio_free(gpio);
+	return 0;
+}
+
+static int tsc_2007_pen_state(void)
+{
+	int temp = mfp_to_gpio(TSI_INT_N);
+	int value;
+	if (gpio_request(temp, "TSC2007 GPIO")) {
+			pr_err("gpio %d request failed\n", temp);
+			return -1;
+	}
+	gpio_direction_input(temp);
+	value = gpio_get_value(temp);
+	gpio_free(temp);
+	return !value;
+}
+
+struct tsc2007_platform_data tsc_2007_data = {
+	.model			= 2007,
+	.x_plate_ohms		= 180,
+	.init_platform_hw = NULL,
+	.get_pendown_state = tsc_2007_pen_state,
+	.clear_penirq = NULL,
+	.exit_platform_hw = NULL,
+	.poll_delay = 1,
+	.poll_period = 1,
+
+};
+#endif
+#ifdef CONFIG_PXA168_ETH
+static struct resource mmp3_fastenet_resources[] = {
+	[0] = {
+		.start  = MMP3_FASTENET_REGBASE,
+		.end    = MMP3_FASTENET_REGBASE + MMP3_FASTENET_REGLEN,
+		.flags  = IORESOURCE_MEM,
+		},
+	[1] = {
+		.start  = IRQ_MMP3_ETHER,
+		.end    = IRQ_MMP3_ETHER,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct pxa168_eth_platform_data mmp3_fastenet_platdata = {
+		/*
+		 *   If you want to use auto-negotiate,
+		 * please set them to 0 or don't set them.
+		 */
+		.speed	= 0,
+		.duplex	= 0,
+};
+
+static struct platform_device mmp3_fastenet = {
+	.name		= "pxa168-eth",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(mmp3_fastenet_resources),
+	.resource	= mmp3_fastenet_resources,
+	.dev		= {
+		.platform_data = &mmp3_fastenet_platdata,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+};
+#endif
+
+static struct i2c_board_info qseven_twsi4_info[] = {
+#if defined(CONFIG_TOUCHSCREEN_TSC2007)
+	{
+		.type		= "tsc2007",
+		.addr		= (0x90>>1),
+		.irq		= IRQ_GPIO(mfp_to_gpio(TSI_INT_N)),
+		.platform_data	= &tsc_2007_data,
+	},
+#endif
+};
+
+static struct i2c_board_info qseven_twsi3_info[] = {
+	{
+	 .type = "wm8731",
+	 .addr = 0x1a,
+	},
+};
+/*FIXME*/
+static struct i2c_board_info qseven_twsi2_info[] = {
+	{
+	},
+};
+static struct i2c_board_info qseven_twsi6_info[] = {
+	{
+	},
+};
+#ifdef CONFIG_REGULATOR_88PM867
+
+#define PMIC_POWER_MAX MAR88PM867_VREG_MAX
+static struct regulator_consumer_supply qseven_power_supply[PMIC_POWER_MAX];
+static struct regulator_init_data pmic_regulator_data[PMIC_POWER_MAX];
+
+#define REG_SUPPLY_INIT(_id, _name, _dev_name) \
+{						\
+	qseven_power_supply[_id].supply =  _name;  \
+	qseven_power_supply[_id].dev_name = _dev_name; \
+}
+
+#define PMIC_REG_INIT(_id, _name, _min, _max, _always, _boot, _supply, _num) \
+{		\
+	pmic_regulator_data[_id].constraints.name = __stringify(_name);        \
+	pmic_regulator_data[_id].constraints.min_uV = _min;    \
+	pmic_regulator_data[_id].constraints.max_uV     = _max;       \
+	pmic_regulator_data[_id].constraints.always_on = _always; \
+	pmic_regulator_data[_id].constraints.boot_on = _boot; \
+	pmic_regulator_data[_id].constraints.valid_ops_mask =  \
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_STATUS; \
+	pmic_regulator_data[_id].constraints.valid_modes_mask = \
+			REGULATOR_MODE_NORMAL; \
+	pmic_regulator_data[_id].consumer_supplies = _supply; \
+	pmic_regulator_data[_id].num_consumer_supplies = _num;	\
+}
+
+static void qseven_power_supply_init(void)
+{
+	REG_SUPPLY_INIT(MAR88PM867_ID_SD0, "vcc_main", NULL);
+	PMIC_REG_INIT(MAR88PM867_ID_SD0, SD0, 775000, 1400000, 1, 1,
+		&qseven_power_supply[MAR88PM867_ID_SD0], 1);
+}
+
+static struct mar88pm867_platform_data qseven_mar88pm867_pdata = {
+	.regulator = pmic_regulator_data,
+	.buck_id = MAR88PM867_ID_SD0,
+};
+
+static struct i2c_board_info qseven_twsi1_mar88pm867_info[] = {
+	{
+		.type		= "mar88pm867",
+		.addr		= (0x32>>1),
+		.platform_data	= &qseven_mar88pm867_pdata,
+	},
+	{
+		.type		= "eeprom_34aa02t-i",
+		.addr		= (0xa0>>1),
+	},
+};
+
+static struct regulator_consumer_supply qseven_fixed_regulator_supply[] = {
+	[0] = {
+		.supply = "v_1p8",
+		},
+};
+
+struct regulator_init_data qseven_fixed_regulator_init_data[] = {
+	[0] = {
+		.constraints = {
+				.name = "88pm867-v_1p8",
+				.always_on = 1,
+				.boot_on = 1,
+				},
+		.num_consumer_supplies = 1,
+		.consumer_supplies = &qseven_fixed_regulator_supply[0],
+		},
+};
+
+struct fixed_voltage_config qseven_fixed_pdata[] = {
+	[0] = {
+		.supply_name = "v_1p8",
+		.microvolts = 1800000,
+		.gpio = -EINVAL,
+		.enabled_at_boot = 1,
+		.init_data = &qseven_fixed_regulator_init_data[0],
+		},
+};
+
+static struct platform_device fixed_device[] = {
+	[0] = {
+		.name = "reg-fixed-voltage",
+		.id = 0,
+		.dev = {
+			.platform_data = &qseven_fixed_pdata[0],
+			},
+		.num_resources = 0,
+		},
+};
+
+static struct platform_device *fixed_rdev[] __initdata = {
+	&fixed_device[0],
+};
+
+static void qseven_regulators(void)
+{
+	platform_add_devices(fixed_rdev, ARRAY_SIZE(fixed_rdev));
+}
+
+#endif /*CONFIG_REGULATOR_88PM867*/
+
+
+static int qseven_pwm_init(struct device *dev)
+{
+	int lvds_blen, lvds_pplen;
+	if (!cpu_is_mmp3_b1())/*replaced with b1*/
+		return 0;
+
+	lvds_blen = mfp_to_gpio(MFP_PIN_GPIO82);
+	lvds_pplen = mfp_to_gpio(MFP_PIN_GPIO83);
+
+	if (gpio_request(lvds_blen, "backlight enable")) {
+		printk(KERN_INFO "gpio %d request failed\n", lvds_blen);
+		return -1;
+	}
+	if (gpio_request(lvds_pplen, "lvds pplen")) {
+		printk(KERN_INFO "gpio %d request failed\n", lvds_pplen);
+		return -1;
+	}
+
+	gpio_direction_output(lvds_blen, 1);
+	gpio_free(lvds_blen);
+
+	gpio_direction_output(lvds_pplen, 1);
+	gpio_free(lvds_pplen);
+
+	return 0;
+}
+
+static struct platform_pwm_backlight_data qseven_lcd_backlight_data = {
+	/* primary backlight */
+	.pwm_id = 2,
+	.max_brightness = 100,
+	.dft_brightness = 50,
+	.pwm_period_ns = 2000000,
+	.init = qseven_pwm_init,
+};
+
+static struct platform_device qseven_lcd_backlight_devices = {
+	.name = "pwm-backlight",
+	.id = 2,
+	.dev = {
+		.platform_data = &qseven_lcd_backlight_data,
+	},
+};
+
+#ifdef CONFIG_MMC_SDHCI_PXAV3
+#include <linux/mmc/host.h>
+
+#ifdef CONFIG_SD8XXX_RFKILL
+/*
+ * during wifi enabled, power should always on and 8787 should always
+ * released from reset. 8787 handle power management by itself.
+*/
+static unsigned long wifi_pin_config_on[] = {
+	GPIO57_GPIO | MFP_LPM_DRIVE_HIGH,
+};
+static unsigned long wifi_pin_config_off[] = {
+	GPIO57_GPIO | MFP_LPM_DRIVE_LOW,
+};
+static void mmp3_8787_set_power(unsigned int on)
+{
+	static int f_enabled = 0;
+	if (on) {
+		f_enabled = 1;
+		pr_info("Turning wifi on\n");
+		mfp_config(ARRAY_AND_SIZE(wifi_pin_config_on));
+	}
+	if ((!on)) {
+		pr_info("Turning wifi off\n");
+		mfp_config(ARRAY_AND_SIZE(wifi_pin_config_off));
+		f_enabled = 0;
+	}
+}
+static void mmp3_8787_set_power_1(unsigned int on)
+{
+	int wlan_pd_n = mfp_to_gpio(MFP_PIN_GPIO57);
+	if (gpio_request(wlan_pd_n, "wifi card power")) {
+		printk(KERN_INFO "gpio %d request failed\n", wlan_pd_n);
+		return -1;
+	}
+	if (on) {
+		pr_info("Turning wifi on\n");
+		gpio_direction_output(wlan_pd_n, 1);
+		gpio_free(wlan_pd_n);
+	} else {
+		pr_info("Turning wifi off\n");
+		gpio_direction_output(wlan_pd_n, 0);
+		gpio_free(wlan_pd_n);
+	}
+	mdelay(100);
+	return 0;
+}
+#endif
+
+static struct sdhci_pxa_platdata mmp3_sdh_platdata_mmc0 = {
+	.clk_delay_cycles	= 0x1F,
+};
+
+static struct sdhci_pxa_platdata mmp3_sdh_platdata_mmc1 = {
+	.flags          = PXA_FLAG_CARD_PERMANENT,
+	.pm_caps	= MMC_PM_KEEP_POWER,
+};
+
+static struct sdhci_pxa_platdata mmp3_sdh_platdata_mmc2 = {
+	.flags		= PXA_FLAG_SD_8_BIT_CAPABLE_SLOT,
+};
+
+static int __init qseven_init_mmc(void)
+{
+	int sd_power_gpio = mfp_to_gpio(MFP_PIN_GPIO137);
+	int wlan_pd_n = mfp_to_gpio(MFP_PIN_GPIO57);
+#ifdef CONFIG_SD8XXX_RFKILL
+	add_sd8x_rfkill_device(wlan_pd_n, NULL,\
+			&mmp3_sdh_platdata_mmc1.pmmc, mmp3_8787_set_power);
+#endif
+	if (gpio_request(sd_power_gpio, "sd card power")) {
+		printk(KERN_INFO "gpio %d request failed\n", sd_power_gpio);
+		return -1;
+	}
+
+	gpio_direction_output(sd_power_gpio, 0);
+	gpio_free(sd_power_gpio);
+
+	mfp_config(ARRAY_AND_SIZE(mmc3_pin_config));
+	mmp3_add_sdh(2, &mmp3_sdh_platdata_mmc2); /* eMMC */
+
+	mfp_config(ARRAY_AND_SIZE(mmc1_pin_config));
+	if (cpu_is_mmp3_b1())/*replaced with b1*/
+		mmp3_sdh_platdata_mmc0.quirks =
+					SDHCI_QUIRK_INVERTED_WRITE_PROTECT;
+	mmp3_add_sdh(0, &mmp3_sdh_platdata_mmc0); /* SD/MMC */
+
+	/* SDIO for WIFI card */
+	mfp_config(ARRAY_AND_SIZE(mmc2_pin_config));
+	mmp3_add_sdh(1, &mmp3_sdh_platdata_mmc1);
+
+	if (gpio_request(wlan_pd_n, "wifi card power")) {
+		printk(KERN_INFO "gpio %d request failed\n", wlan_pd_n);
+		return -1;
+	}
+	gpio_direction_output(wlan_pd_n, 0);
+	mdelay(100);
+	gpio_direction_output(wlan_pd_n, 1);
+	gpio_free(wlan_pd_n);
+	return 0;
+}
+#endif /* CONFIG_MMC_SDHCI_PXAV3 */
+
+
+#ifdef CONFIG_USB_SUPPORT
+
+#if defined(CONFIG_USB_PXA_U2O) || defined(CONFIG_USB_EHCI_PXA_U2O)
+
+static char *mmp3_usb_clock_name[] = {
+	[0] = "U2OCLK",
+};
+
+static struct mv_usb_platform_data mmp3_usb_pdata = {
+	.clknum		= 1,
+	.clkname	= mmp3_usb_clock_name,
+	.vbus		= NULL,
+	.mode		= MV_USB_MODE_OTG,
+	.phy_init	= pxa_usb_phy_init,
+	.phy_deinit	= pxa_usb_phy_deinit,
+};
+#endif /*CONFIG_USB_PXA_U20*/
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_FSIC /*Support for ulpi*/
+static int mmp3_fsic_ulpi_phy_reset(void)
+{
+	int usb_ulpi = mfp_to_gpio(ULPI_RST_N_GPIO_71);
+	if (gpio_request(usb_ulpi, "ulpi reset")) {
+		printk(KERN_INFO "gpio %d request failed\n", usb_ulpi);
+		return -1;
+	}
+
+	gpio_direction_output(usb_ulpi, 0);
+	mdelay(100);
+	gpio_direction_output(usb_ulpi, 1);
+	mdelay(50);
+	gpio_free(usb_ulpi);
+	return 0;
+}
+
+static char *mmp3_fsic_clock_name[] = {
+	[0] = "U2OCLK",
+	[1] = "FSICCLK",
+};
+
+static struct mv_usb_platform_data mmp3_fsic_pdata = {
+	.clknum		= 2,
+	.clkname	= mmp3_fsic_clock_name,
+	.vbus		= NULL,
+	.mode		= MV_USB_MODE_HOST,
+	.phy_init	= mmp3_fsic_phy_init,
+	.p_init		= mmp3_fsic_p_init,
+};
+
+#endif
+#endif
+
+#ifdef CONFIG_UIO_HDMI
+static struct uio_hdmi_platform_data mmp3_hdmi_info __initdata = {
+	.sspa_reg_base = 0xD42A0C00,
+	/* Fix me: gpio 81 lpm pull ? */
+	.gpio = mfp_to_gpio(GPIO81_GPIO),
+	.edid_bus_num = 6,
+};
+#endif
+
+#define DMCU_SDRAM_TIMING1 0x80
+#define DMCU_SDRAM_TIMING2 0x84
+#define DMCU_SDRAM_TIMING3 0x88
+#define DMCU_SDRAM_TIMING4 0x8c
+#define DMCU_SDRAM_TIMING5 0x90
+#define DMCU_SDRAM_TIMING6 0x94
+#define DMCU_SDRAM_TIMING7 0x98
+#define DMCU_PHY_CTRL3 0x220
+#define DMCU_PHY_DQ_BYTE_SEL 0x300
+#define DMCU_PHY_DLL_CTRL_BYTE1 0x304
+#define DMCU_PHY_DLL_WL_SEL 0x380
+#define DMCU_PHY_DLL_WL_CTRL0 0x384
+#define ALLBITS (0xFFFFFFFF)
+
+static struct dmc_regtable_entry khx1600c9s3k_2x133mhz[] = {
+	{DMCU_SDRAM_TIMING1, ALLBITS, 0x911400CA},
+	{DMCU_SDRAM_TIMING2, ALLBITS, 0x64660684},
+	{DMCU_SDRAM_TIMING3, ALLBITS, 0xC2006C53},
+	{DMCU_SDRAM_TIMING4, ALLBITS, 0x44F8A187},
+	{DMCU_SDRAM_TIMING5, ALLBITS, 0x000E2101},
+	{DMCU_SDRAM_TIMING6, ALLBITS, 0x04040200},
+	{DMCU_SDRAM_TIMING7, ALLBITS, 0x00008801},
+};
+static struct dmc_regtable_entry khx1600c9s3k_2x177mhz[] = {
+	{DMCU_SDRAM_TIMING1, ALLBITS, 0x911400CA},
+	{DMCU_SDRAM_TIMING2, ALLBITS, 0x64660684},
+	{DMCU_SDRAM_TIMING3, ALLBITS, 0xC2006C53},
+	{DMCU_SDRAM_TIMING4, ALLBITS, 0x44F8A187},
+	{DMCU_SDRAM_TIMING5, ALLBITS, 0x000E2101},
+	{DMCU_SDRAM_TIMING6, ALLBITS, 0x04040200},
+	{DMCU_SDRAM_TIMING7, ALLBITS, 0x00008801},
+};
+static struct dmc_regtable_entry khx1600c9s3k_2x266mhz[] = {
+	{DMCU_SDRAM_TIMING1, ALLBITS, 0x911400CA},
+	{DMCU_SDRAM_TIMING2, ALLBITS, 0x64660684},
+	{DMCU_SDRAM_TIMING3, ALLBITS, 0xC2006C53},
+	{DMCU_SDRAM_TIMING4, ALLBITS, 0x44F8A187},
+	{DMCU_SDRAM_TIMING5, ALLBITS, 0x000E2101},
+	{DMCU_SDRAM_TIMING6, ALLBITS, 0x04040200},
+	{DMCU_SDRAM_TIMING7, ALLBITS, 0x00008801},
+};
+static struct dmc_regtable_entry khx1600c9s3k_2x400mhz[] = {
+	{DMCU_SDRAM_TIMING1, ALLBITS, 0x911400CA},
+	{DMCU_SDRAM_TIMING2, ALLBITS, 0x64660684},
+	{DMCU_SDRAM_TIMING3, ALLBITS, 0xC2006C53},
+	{DMCU_SDRAM_TIMING4, ALLBITS, 0x44F8A187},
+	{DMCU_SDRAM_TIMING5, ALLBITS, 0x000E2101},
+	{DMCU_SDRAM_TIMING6, ALLBITS, 0x04040200},
+	{DMCU_SDRAM_TIMING7, ALLBITS, 0x00008801},
+};
+static struct dmc_regtable_entry khx1600c9s3k_2x533mhz[] = {
+	{DMCU_SDRAM_TIMING1, ALLBITS, 0x911A00CA},
+	{DMCU_SDRAM_TIMING2, ALLBITS, 0x848808B4},
+	{DMCU_SDRAM_TIMING3, ALLBITS, 0xC200906C},
+	{DMCU_SDRAM_TIMING4, ALLBITS, 0x4698DA09},
+	{DMCU_SDRAM_TIMING5, ALLBITS, 0x00132161},
+	{DMCU_SDRAM_TIMING6, ALLBITS, 0x04040200},
+	{DMCU_SDRAM_TIMING7, ALLBITS, 0x00008801},
+};
+
+static struct dmc_regtable_entry khx1600c9s3k_phy[] = {
+	{DMCU_PHY_DQ_BYTE_SEL, ALLBITS, 0x00000000},
+	{DMCU_PHY_DLL_CTRL_BYTE1, ALLBITS, 0x00002100},
+	{DMCU_PHY_DQ_BYTE_SEL, ALLBITS, 0x00000001},
+	{DMCU_PHY_DLL_CTRL_BYTE1, ALLBITS, 0x00002100},
+	{DMCU_PHY_DQ_BYTE_SEL, ALLBITS, 0x00000002},
+	{DMCU_PHY_DLL_CTRL_BYTE1, ALLBITS, 0x00002100},
+	{DMCU_PHY_DQ_BYTE_SEL, ALLBITS, 0x00000003},
+	{DMCU_PHY_DLL_CTRL_BYTE1, ALLBITS, 0x00002100},
+	{DMCU_PHY_CTRL3, ALLBITS, 0x20004044},
+};
+
+static struct dmc_regtable_entry khx1600c9s3k_wl[] = {
+	{DMCU_PHY_DLL_WL_SEL, ALLBITS, 0x00000100},
+	{DMCU_PHY_DLL_WL_CTRL0, ALLBITS, 0x00040004},
+	{DMCU_PHY_DLL_WL_SEL, ALLBITS, 0x00000101},
+	{DMCU_PHY_DLL_WL_CTRL0, ALLBITS, 0x00040004},
+	{DMCU_PHY_DLL_WL_SEL, ALLBITS, 0x00000102},
+	{DMCU_PHY_DLL_WL_CTRL0, ALLBITS, 0x00080008},
+	{DMCU_PHY_DLL_WL_SEL, ALLBITS, 0x00000103},
+	{DMCU_PHY_DLL_WL_CTRL0, ALLBITS, 0x00080008},
+
+};
+static struct dmc_timing_entry khx1600c9s3k_table[] = {
+	{
+		.dsrc = 3,
+		.mode4x = 0,
+		.pre_d = 3,
+		.cas = 0x000c800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x133mhz),
+		},
+	},
+
+	{
+		.dsrc = 3,
+		.mode4x = 0,
+		.pre_d = 2,
+		.cas = 0x000c800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x177mhz),
+		},
+	},
+
+	{
+		.dsrc = 3,
+		.mode4x = 0,
+		.pre_d = 1,
+		.cas = 0x000c800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x266mhz),
+		},
+	},
+	{
+		.dsrc = 1,
+		.mode4x = 0,
+		.pre_d = 0,
+		.cas = 0x000c800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x400mhz),
+			DEF_DMC_TAB_ENTRY(DMCRT_PH, khx1600c9s3k_phy),
+			DEF_DMC_TAB_ENTRY(DMCRT_WL, khx1600c9s3k_wl),
+		},
+	},
+	{
+		.dsrc = 3,
+		.mode4x = 0,
+		.pre_d = 0,
+		.cas = 0x000c800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x533mhz),
+			DEF_DMC_TAB_ENTRY(DMCRT_PH, khx1600c9s3k_phy),
+			DEF_DMC_TAB_ENTRY(DMCRT_WL, khx1600c9s3k_wl),
+		},
+	},
+/*	{
+		.dsrc = 2,
+		.mode4x = 0,
+		.pre_d = 0,
+		.cas = 0x0008800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_2x600mhz),
+			DEF_DMC_TAB_ENTRY(DMCRT_PH, khx1600c9s3k_phy),
+			DEF_DMC_TAB_ENTRY(DMCRT_WL, khx1600c9s3k_wl),
+		},
+	},
+	{
+		.dsrc = 0,
+		.mode4x = 1,
+		.pre_d = 0,
+		.cas = 0x0008800,
+		.table = {
+			DEF_DMC_TAB_ENTRY(DMCRT_TM, khx1600c9s3k_4x400mhz),
+			DEF_DMC_TAB_ENTRY(DMCRT_PH, khx1600c9s3k_phy),
+			DEF_DMC_TAB_ENTRY(DMCRT_WL, khx1600c9s3k_wl),
+		},
+	},
+*/
+};
+
+static void set_ddr_dll(u32 val)
+{
+#ifdef CONFIG_DDR_DEVFREQ
+	if (val <= 0xf) {
+		tmp = readl(ddr_info.hw_base[0] + 0x248);
+		writel((tmp & ~(0xf << 28)) | (val << 28), \
+			ddr_info.hw_base[0] + 0x248);
+	} else {
+		pr_err("dll timer should be lower than 0xf\n");
+	}
+#endif
+}
+
+static void qseven_update_ddr_info(void)
+{
+	mmp3_pm_update_dram_timing_table(ARRAY_SIZE(khx1600c9s3k_table),
+						khx1600c9s3k_table);
+}
+
+static void __init qseven_init(void)
+{
+	mfp_config(ARRAY_AND_SIZE(qseven_pin_config));
+	qseven_update_ddr_info();
+
+	/* on-chip devices */
+	mmp3_add_uart(3);
+	mmp3_add_twsi(2, NULL, ARRAY_AND_SIZE(qseven_twsi2_info));
+	mmp3_add_twsi(6, NULL, ARRAY_AND_SIZE(qseven_twsi6_info));
+#ifdef CONFIG_REGULATOR_88PM867
+	qseven_power_supply_init();
+	mmp3_add_twsi(1, NULL, ARRAY_AND_SIZE(qseven_twsi1_mar88pm867_info));
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_TSC2007)
+	tsc2007_init_gpio_irq();
+#endif
+
+	mmp3_add_twsi(4, NULL, ARRAY_AND_SIZE(qseven_twsi4_info));
+
+	mmp3_add_keypad(&mmp3_keypad_info);
+
+	mmp3_add_videosram(&mmp3_videosram_info);
+
+#ifdef CONFIG_FB_PXA168
+	abilene_add_lcd_mipi(); /* will keep same name */
+	mmp3_add_tv_out();
+#endif
+
+#ifdef CONFIG_UIO_HDMI
+	mmp3_add_hdmi(&mmp3_hdmi_info);
+#endif
+
+#if defined(CONFIG_DDR_DEVFREQ)
+	ddr_devfreq_init();
+	mmp3_add_ddr_devfreq(&ddr_info);
+#endif
+	/* Change DLL reset timer to 256 cycles
+	set_ddr_dll(2);*/
+
+	/* backlight */
+	mmp3_add_pwm(3);
+	platform_device_register(&qseven_lcd_backlight_devices);
+	mmp3_add_thermal();
+
+#ifdef CONFIG_ANDROID_PMEM
+	pxa_add_pmem();
+#endif
+
+#ifdef CONFIG_UIO_VMETA
+	mmp_init_vmeta();
+#endif
+
+#ifdef CONFIG_VMETA_DEVFREQ
+	mmp_init_devfreq_vmeta();
+#endif
+
+#ifdef CONFIG_MMC_SDHCI_PXAV3
+	qseven_init_mmc();
+#endif /* CONFIG_MMC_SDHCI_PXAV3 */
+
+	platform_device_register(&mmp3_device_rtc);
+
+	/* audio sspa support */
+	mmp3_add_twsi(3, NULL, ARRAY_AND_SIZE(qseven_twsi3_info));
+	mmp3_add_sspa(1);
+	mmp3_add_sspa(2);
+	mmp3_add_audiosram(&mmp3_audiosram_info);
+
+	/* sensor ov5642 and ccic support */
+
+#ifdef CONFIG_USB_PXA_U2O
+	mmp3_device_u2o.dev.platform_data = (void *)&mmp3_usb_pdata;
+	platform_device_register(&mmp3_device_u2o);
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA_U2O
+	mmp3_device_u2oehci.dev.platform_data = (void *)&mmp3_usb_pdata;
+	platform_device_register(&mmp3_device_u2oehci);
+
+#ifdef CONFIG_USB_PXA_U2O_OTG
+	mmp3_device_u2ootg.dev.platform_data = (void *)&mmp3_usb_pdata;
+	platform_device_register(&mmp3_device_u2ootg);
+#endif
+#endif
+
+#ifdef CONFIG_USB_EHCI_PXA_U2H_FSIC
+	mmp3_fsic_ulpi_phy_reset();
+	mmp3_fsic_device.dev.platform_data = (void *)&mmp3_fsic_pdata;
+	platform_device_register(&mmp3_fsic_device);
+#endif
+
+	if (mmp_plat_ref_clk == 0x3) {
+		#ifdef CONFIG_PXA168_ETH
+		pr_info("Ethernet platform registration...\n");
+		platform_device_register(&mmp3_fastenet);
+		#endif
+	}
+#ifdef CONFIG_REGULATOR_88PM867
+	qseven_regulators();
+#endif
+	pxa_u3d_phy_disable();
+}
+
+MACHINE_START(QSEVEN, "Qseven")
+	.map_io		= mmp_map_io,
+	.nr_irqs	= QSEVEN_NR_IRQS,
+	.init_irq	= mmp3_init_irq,
+	.timer		= &mmp3_timer,
+	.reserve	= mmp3_reserve,
+	.init_machine	= qseven_init,
+MACHINE_END
diff --git a/arch/arm/mach-mmp/reset-mmp3.c b/arch/arm/mach-mmp/reset-mmp3.c
new file mode 100644
index 0000000..75f31f9
--- /dev/null
+++ b/arch/arm/mach-mmp/reset-mmp3.c
@@ -0,0 +1,46 @@
+/*
+ * linux/arch/arm/mach-mmp/reset-mmp3.c
+ *
+ * Author:	Neil Zhang <zhangwm@marvell.com>
+ * Copyright:	(C) 2012 Marvell International Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/smp.h>
+
+#include <asm/hardware/gic.h>
+#include <asm/unified.h>
+#include <asm/io.h>
+
+#include <mach/addr-map.h>
+
+
+#define SW_BRANCH_VIRT_ADDR	(AXI_VIRT_BASE + 0x82c24)
+
+extern void mmp3_secondary_startup(void);
+
+void pxa_cpu_reset(u32 cpu)
+{
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	gic_raise_softirq(cpumask_of(cpu), 1);
+}
+
+void __init pxa_cpu_reset_handler_init(void)
+{
+	/*
+	 * Write the address of secondary startup into the system-wide
+	 * flags register. The BootMonitor waits for this register to
+	 * become non-zero.
+	 */
+	__raw_writel(virt_to_phys(mmp3_secondary_startup),
+			(void __iomem *)SW_BRANCH_VIRT_ADDR);
+}
diff --git a/arch/arm/mach-mmp/reset.c b/arch/arm/mach-mmp/reset.c
new file mode 100644
index 0000000..08f3fc5
--- /dev/null
+++ b/arch/arm/mach-mmp/reset.c
@@ -0,0 +1,410 @@
+/*
+ *  linux/arch/arm/mach-mmp/reset.c
+ *
+ *  Copyright (C) 2009-2011 Marvell International Ltd.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  publishhed by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/io.h>
+#include <mach/regs-mpmu.h>
+#include <mach/regs-timers.h>
+#include <mach/cputype.h>
+#include <linux/delay.h>
+#include <linux/mfd/88pm860x.h>
+
+/* Raw i2c operations __ONLY__ can be used for reboot routine */
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)	\
+		|| defined(CONFIG_CPU_PXA910) || defined(CONFIG_CPU_PXA988)
+
+#if defined(CONFIG_CPU_MMP2) || defined(CONFIG_CPU_MMP3)
+#define MAX_BUS_NUM	6
+static const u32 i2c_reg_idbr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x08,
+	APB_VIRT_BASE + 0x31000 + 0x08,
+	APB_VIRT_BASE + 0x32000 + 0x08,
+	APB_VIRT_BASE + 0x33000 + 0x08,
+	APB_VIRT_BASE + 0x33800 + 0x08,
+	APB_VIRT_BASE + 0x34000 + 0x08,
+};
+static const u32 i2c_reg_icr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x10,
+	APB_VIRT_BASE + 0x31000 + 0x10,
+	APB_VIRT_BASE + 0x32000 + 0x10,
+	APB_VIRT_BASE + 0x33000 + 0x10,
+	APB_VIRT_BASE + 0x33800 + 0x10,
+	APB_VIRT_BASE + 0x34000 + 0x10,
+};
+static const u32 i2c_reg_isr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x18,
+	APB_VIRT_BASE + 0x31000 + 0x18,
+	APB_VIRT_BASE + 0x32000 + 0x18,
+	APB_VIRT_BASE + 0x33000 + 0x18,
+	APB_VIRT_BASE + 0x33800 + 0x18,
+	APB_VIRT_BASE + 0x34000 + 0x18,
+};
+#endif
+
+#if defined(CONFIG_CPU_PXA910)
+#define MAX_BUS_NUM	2
+static const u32 i2c_reg_idbr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x08,
+	APB_VIRT_BASE + 0x37000 + 0x08,
+};
+static const u32 i2c_reg_icr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x10,
+	APB_VIRT_BASE + 0x37000 + 0x10,
+};
+static const u32 i2c_reg_isr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x18,
+	APB_VIRT_BASE + 0x37000 + 0x18,
+};
+#endif
+
+#if defined(CONFIG_CPU_PXA988)
+#define MAX_BUS_NUM	3
+static const u32 i2c_reg_idbr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x08,
+	APB_VIRT_BASE + 0x10800 + 0x08,
+	APB_VIRT_BASE + 0x37000 + 0x08,
+};
+static const u32 i2c_reg_icr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x10,
+	APB_VIRT_BASE + 0x10800 + 0x10,
+	APB_VIRT_BASE + 0x37000 + 0x10,
+};
+static const u32 i2c_reg_isr[MAX_BUS_NUM] = {
+	APB_VIRT_BASE + 0x11000 + 0x18,
+	APB_VIRT_BASE + 0x10800 + 0x18,
+	APB_VIRT_BASE + 0x37000 + 0x18,
+};
+#endif
+
+/* Control register bits */
+#define ICR_START	(1 << 0)
+#define ICR_STOP	(1 << 1)
+#define ICR_ACKNAK	(1 << 2)
+#define ICR_TB		(1 << 3)
+#define ICR_ALDIE	(1 << 12)
+/* Status register bits */
+#define ISR_ACKNAK	(1 << 1)
+#define ISR_IBB		(1 << 3)
+#define ISR_ITE		(1 << 6)
+#define ISR_IRF		(1 << 7)
+
+static int i2c_isr_set_cleared(u32 reg_isr, u32 set, u32 cleared)
+{
+	int isr, timeout = 1000;
+	do {
+		udelay(10);
+		isr = readl(reg_isr);
+		if (timeout-- < 0)
+			return 0;
+	} while (((isr & set) != set) ||
+			((isr & cleared) != 0));
+	return 1;
+}
+
+int __raw_i2c_bus_reset(u8 bus_num)
+{
+	u32 reg_icr;
+	if (bus_num == 0 || bus_num > MAX_BUS_NUM) {
+		pr_err("%s: bus_num if out of range!\n", __func__);
+		return -1;
+	}
+	reg_icr = i2c_reg_icr[bus_num - 1];
+	writel(0x4060, reg_icr);
+	udelay(500);
+	writel(0x60, reg_icr);
+	udelay(500);
+	return 0;
+}
+
+int __raw_i2c_write_reg(u8 bus_num, u8 addr, u8 reg, u8 val)
+{
+	u32 reg_idbr, reg_icr, reg_isr;
+	if (bus_num == 0 || bus_num > MAX_BUS_NUM) {
+		pr_err("%s: bus_num if out of range!\n", __func__);
+		return -1;
+	}
+	reg_idbr = i2c_reg_idbr[bus_num - 1];
+	reg_icr = i2c_reg_icr[bus_num - 1];
+	reg_isr = i2c_reg_isr[bus_num - 1];
+	/* Is bus busy? */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_IBB)) {
+		pr_err("%s: bus is busy!\n", __func__);
+		return -1;
+	}
+	/* -----1. Send chip addr -------  */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write chip addr */
+	writel((addr << 1), reg_idbr);
+	/* Send start bit */
+	writel(readl(reg_icr) | ICR_START, reg_icr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+	/* -----2. Send reg addr ------ */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write reg addr */
+	writel(reg, reg_idbr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+	/* -----3. Send val ------ */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write val */
+	writel(val, reg_idbr);
+	/* Send Stop bit */
+	writel(readl(reg_icr) | ICR_STOP, reg_icr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+
+	return 0;
+}
+
+int __raw_i2c_read_reg(u8 bus_num, u8 addr, u8 reg, u8 *buf, int len)
+{
+	u32 reg_idbr, reg_icr, reg_isr;
+	if (bus_num == 0 || bus_num > MAX_BUS_NUM) {
+		pr_err("%s: bus_num if out of range!\n", __func__);
+		return -1;
+	}
+	reg_idbr = i2c_reg_idbr[bus_num - 1];
+	reg_icr = i2c_reg_icr[bus_num - 1];
+	reg_isr = i2c_reg_isr[bus_num - 1];
+	/* Is bus busy? */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_IBB)) {
+		pr_err("%s: bus is busy!\n", __func__);
+		return -1;
+	}
+	/* -----1. Send chip addr -------  */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write chip addr */
+	writel((addr << 1), reg_idbr);
+	/* Send start bit */
+	writel(readl(reg_icr) | ICR_START, reg_icr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+	/* -----2. Send reg addr ------ */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write reg addr */
+	writel(reg, reg_idbr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+	/* -----3. Start read sequence -------  */
+	/* Clear START and STOP bits */
+	writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+	writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+	/* Write chip addr: R/nW=1 */
+	writel((addr << 1) | 0x1, reg_idbr);
+	/* Send start bit */
+	writel(readl(reg_icr) | ICR_START, reg_icr);
+	/* Clear ALDIE */
+	writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+	/* Transfer, send a byte */
+	writel(readl(reg_icr) | ICR_TB, reg_icr);
+	/* Transmit empty? */
+	if (!i2c_isr_set_cleared(reg_isr, ISR_ITE, 0))
+		return -1;
+	/* Clear ITE: W1C */
+	writel(readl(reg_isr) | ISR_ITE, reg_isr);
+	/* Wait for ACK */
+	if (!i2c_isr_set_cleared(reg_isr, 0, ISR_ACKNAK))
+		return -1;
+	while (len--) {
+		/* Clear START and STOP bits */
+		writel(readl(reg_icr) & ~(ICR_START), reg_icr);
+		writel(readl(reg_icr) & ~(ICR_STOP), reg_icr);
+		if (len == 0)
+			/* Send NACK */
+			writel(readl(reg_icr) | ICR_ACKNAK, reg_icr);
+		else
+			/* Send ACK */
+			writel(readl(reg_icr) & ~ICR_ACKNAK, reg_icr);
+		/* Clear ALDIE */
+		writel(readl(reg_icr) & ~(ICR_ALDIE), reg_icr);
+		/* Transfer, receive a byte */
+		writel(readl(reg_icr) | ICR_TB, reg_icr);
+		/* Receive register full? */
+		if (!i2c_isr_set_cleared(reg_isr, ISR_IRF, 0))
+			return -1;
+		*buf = readl(reg_idbr);
+		buf++;
+		/* Clear ITE: W1C */
+		writel(readl(reg_isr) | ISR_IRF, reg_isr);
+	}
+	return 0;
+}
+#endif
+
+#define REG_RTC_BR0	(APB_VIRT_BASE + 0x010014)
+
+#define MPMU_APRR_WDTR	(1<<4)
+#define MPMU_APRR_CPR	(1<<0)
+#define MPMU_CPRR_DSPR	(1<<2)
+#define MPMU_CPRR_BBR	(1<<3)
+
+/* Using watchdog reset */
+static void do_wdt_reset(const char *cmd)
+{
+	u32 reg, backup;
+	u32 watchdog_virt_base;
+	int i;
+	int match = 0, count = 0;
+
+	if (cpu_is_pxa910_family() || cpu_is_pxa920_family())
+		watchdog_virt_base = CP_TIMERS2_VIRT_BASE;
+	else if (cpu_is_pxa168())
+		watchdog_virt_base = TIMERS1_VIRT_BASE;
+	else
+		return;
+
+	/* reset/enable WDT clock */
+	writel(0x7, MPMU_WDTPCR);
+	readl(MPMU_WDTPCR);
+	writel(0x3, MPMU_WDTPCR);
+	readl(MPMU_WDTPCR);
+
+	if (cpu_is_pxa910_family() || cpu_is_pxa920_family()) {
+		if (cmd && !strcmp(cmd, "recovery")) {
+			for (i = 0, backup = 0; i < 4; i++) {
+				backup <<= 8;
+				backup |= *(cmd + i);
+			}
+			do {
+				writel(backup, REG_RTC_BR0);
+			} while (readl(REG_RTC_BR0) != backup);
+		}
+	}
+
+	/* enable WDT reset */
+	writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+	writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+	writel(0x3, watchdog_virt_base + TMR_WMER);
+
+	if (cpu_is_pxa910_family() || cpu_is_pxa920_family()) {
+		/*hold CP first */
+		reg = readl(MPMU_APRR) | MPMU_APRR_CPR;
+		writel(reg, MPMU_APRR);
+		udelay(10);
+		/*CP reset MSA */
+		reg = readl(MPMU_CPRR) | MPMU_CPRR_DSPR | MPMU_CPRR_BBR;
+		writel(reg, MPMU_CPRR);
+		udelay(10);
+	}
+	/* negate hardware reset to the WDT after system reset */
+	reg = readl(MPMU_APRR) | MPMU_APRR_WDTR;
+	writel(reg, MPMU_APRR);
+
+	/* clear previous WDT status */
+	writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+	writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+	writel(0, watchdog_virt_base + TMR_WSR);
+
+	match = readl(watchdog_virt_base + TMR_WMR);
+	count = readl(watchdog_virt_base + TMR_WVR);
+
+	if (match - count > 0x20) {
+		/* set match counter */
+		writel(0xbaba, watchdog_virt_base + TMR_WFAR);
+		writel(0xeb10, watchdog_virt_base + TMR_WSAR);
+		writel(0x20 + count, watchdog_virt_base + TMR_WMR);
+	}
+}
+
+int pxa_board_reset(char mode, const char *cmd)
+{
+	return 0;
+}
+
+int (*board_reset)(char mode, const char *cmd) = pxa_board_reset;
+EXPORT_SYMBOL(board_reset);
+
+static void mmp_arch_reset(char mode, const char *cmd)
+{
+	if (board_reset(mode, cmd))
+		return;
+
+	if ((!cpu_is_pxa910_family()) && (!cpu_is_pxa920_family()) && (!cpu_is_pxa168()))
+		return;
+
+	switch (mode) {
+	case 's':
+		/* Jump into ROM at address 0 */
+		cpu_reset(0);
+		break;
+	case 'w':
+	default:
+		do_wdt_reset(cmd);
+		break;
+	}
+}
+
+/*
+ * Reset the system. It is called by machine_restart().
+ */
+void (*arch_reset)(char, const char *) = mmp_arch_reset;
diff --git a/arch/arm/mach-mmp/soc_time.c b/arch/arm/mach-mmp/soc_time.c
new file mode 100644
index 0000000..5f16e2d
--- /dev/null
+++ b/arch/arm/mach-mmp/soc_time.c
@@ -0,0 +1,390 @@
+/*
+ * linux/arch/arm/mach-mmp/time.c
+ *
+ *   Support for clocksource and clockevents
+ *
+ * Copyright (C) 2008 Marvell International Ltd.
+ * All rights reserved.
+ *
+ *   2008-04-11: Jason Chagas <Jason.chagas@marvell.com>
+ *   2008-10-08: Bin Yang <bin.yang@marvell.com>
+ *
+ * The timers module actually includes three timers, each timer with upto
+ * three match comparators. Timer #0 is used here in free-running mode as
+ * the clock source, and match comparator #1 used as clock event device.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/clockchips.h>
+
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+#include <linux/cnt32_to_63.h>
+
+#include <mach/addr-map.h>
+#include <mach/regs-timers.h>
+#include <mach/regs-apbc.h>
+#include <mach/regs-mpmu.h>
+#include <mach/irqs.h>
+#include <mach/cputype.h>
+#include <asm/sched_clock.h>
+#include <asm/mach/time.h>
+
+#include <asm/localtimer.h>
+
+#include "clock.h"
+
+#define GEN_TMR_REG_BASE0 (APB_VIRT_BASE + 0x80000)
+#define GEN_TMR_CFG (GEN_TMR_REG_BASE0 + 0xB0)
+
+#define TIMERS_VIRT_BASE	TIMERS1_VIRT_BASE
+
+#define MAX_DELTA		(0xfffffffe)
+#define MIN_DELTA		(32)
+
+#define US2CYC_SCALE_FACTOR	10
+static inline cycle_t timer_read(int counter);
+static unsigned long us2cyc_scale;
+static DEFINE_SPINLOCK(timer_lock);
+
+static int irq_timer0, irq_timer1;
+
+static void __init set_us2cyc_scale(unsigned long cyc_rate)
+{
+	unsigned long long v = (unsigned long long)cyc_rate <<
+				US2CYC_SCALE_FACTOR;
+	do_div(v, USEC_PER_SEC);
+	us2cyc_scale = v;
+}
+
+unsigned long us2cyc(unsigned long usecs)
+{
+	return ((unsigned long long)usecs * us2cyc_scale) >>
+				US2CYC_SCALE_FACTOR;
+}
+
+static int timer_set_next_event(unsigned long delta,
+				struct clock_event_device *dev)
+{
+	unsigned long flags;
+	uint32_t cer, reg;
+	unsigned int timer, i;
+
+	spin_lock_irqsave(&timer_lock, flags);
+
+	if (delta < MIN_DELTA)
+		delta = MIN_DELTA;
+
+	if (dev->irq == irq_timer0)
+		timer = 0;
+	else if (dev->irq == irq_timer1)
+		timer = 1;
+	else
+		timer = 2;
+
+	cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+
+	/* set preloader reg value */
+	__raw_writel(0, TIMERS_VIRT_BASE + TMR_PLVR(timer));
+	/* disable clk counter */
+	__raw_writel(cer & ~(1<<timer), TIMERS_VIRT_BASE + TMR_CER);
+	/* clear pending interrupt status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(timer));
+	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_ICR(timer));
+	reg = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
+	reg = reg & 0x6f;
+	reg = reg & ~(0x3 << (timer << 1));
+	__raw_writel(reg, TIMERS_VIRT_BASE + TMR_CCR);
+
+	/*
+	 * If camera source is 13M, then 2 cycle is 155ns. For
+	 * 806M cpu, a nop operation takes 4/806 * 10 ^ 9 = 5ns.
+	 * So the circulate count is 155/5 = 31. Use 100 for safe.
+	 * */
+	for (i = 0; i < 100; i++)
+		__asm__ __volatile__("nop");
+	/* set delta value */
+	__raw_writel(delta - 2, TIMERS_VIRT_BASE + TMR_TN_MM(timer,0));
+
+	reg = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
+	reg = reg & 0x6f;
+	reg |= (0x1 << (timer << 1));
+	__raw_writel(reg, TIMERS_VIRT_BASE + TMR_CCR);
+	/* enable interrupt, timer counter */
+	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_IER(timer));
+	__raw_writel(cer | (1<<timer), TIMERS_VIRT_BASE + TMR_CER);
+
+	spin_unlock_irqrestore(&timer_lock, flags);
+	return 0;
+}
+
+static void timer_set_mode(enum clock_event_mode mode,
+			   struct clock_event_device *dev)
+{
+	unsigned long flags;
+	unsigned long cer;
+	int irq = dev->irq;
+	int timer;
+
+	if (irq == irq_timer0)
+		timer = 0;
+	else if (irq == irq_timer1)
+		timer = 1;
+	else
+		timer = 2;
+
+	spin_lock_irqsave(&timer_lock, flags);
+
+	switch (mode) {
+	case CLOCK_EVT_MODE_ONESHOT:
+		cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+		__raw_writel(cer | (0x1 << timer), TIMERS_VIRT_BASE + TMR_CER);
+
+		/* disable the matching interrupt */
+		__raw_writel(0x00, TIMERS_VIRT_BASE + TMR_IER(timer));
+		break;
+	case CLOCK_EVT_MODE_SHUTDOWN:
+	case CLOCK_EVT_MODE_UNUSED:
+		cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+		__raw_writel(cer & ~(0x1 << timer), TIMERS_VIRT_BASE + TMR_CER);
+		break;
+	case CLOCK_EVT_MODE_RESUME:
+		cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+		__raw_writel(cer | (0x1 << timer), TIMERS_VIRT_BASE + TMR_CER);
+		break;
+	case CLOCK_EVT_MODE_PERIODIC:
+		break;
+	}
+
+	spin_unlock_irqrestore(&timer_lock, flags);
+	return;
+}
+
+static struct clock_event_device ckevt0 = {
+	.name		= "clockevent0",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.rating		= 200,
+	.set_next_event	= timer_set_next_event,
+	.set_mode	= timer_set_mode,
+};
+
+static struct clock_event_device ckevt1 = {
+	.name		= "clockevent1",
+	.features	= CLOCK_EVT_FEAT_ONESHOT,
+	.rating		= 200,
+	.set_next_event	= timer_set_next_event,
+	.set_mode	= timer_set_mode,
+};
+
+static irqreturn_t timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *c = dev_id;
+	int timer;
+
+	if (irq == irq_timer0)
+		timer = 0;
+	else if (irq == irq_timer1)
+		timer = 1;
+	else
+		timer = 2;
+
+	/* disable and clear pending interrupt status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(timer));
+	__raw_writel(0x1, TIMERS_VIRT_BASE + TMR_ICR(timer));
+	c->event_handler(c);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction timer0_irq = {
+	.name		= "timer0",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= timer_interrupt,
+};
+
+static struct irqaction timer1_irq = {
+	.name		= "timer1",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= timer_interrupt,
+};
+
+cycle_t timer_read(int counter)
+{
+	volatile int delay __maybe_unused = 2;
+	unsigned long flags;
+	volatile uint32_t val = 0;
+#ifdef CONFIG_PXA_32KTIMER
+	volatile uint32_t val2 = 0;
+#endif
+
+	local_irq_save(flags);
+
+#ifdef CONFIG_PXA_32KTIMER
+	/* 32KHz timer */
+	do {
+		val = __raw_readl(TIMERS_VIRT_BASE + TMR_CR(counter));
+		val2 = __raw_readl(TIMERS_VIRT_BASE + TMR_CR(counter));
+	} while (val2 != val);
+#else
+	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(counter));
+	while (delay--) {
+		val = __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(counter));
+	}
+	val = __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(counter));
+#endif
+	local_irq_restore(flags);
+
+	return val;
+}
+
+static u32 notrace soc_read_timer(void)
+{
+	return timer_read(2);
+}
+
+static cycle_t soc_clksrc_read(struct clocksource *cs)
+{
+	return timer_read(2);
+}
+
+static struct clocksource cksrc = {
+	.name		= "soc_clock",
+	.rating		= 200,
+	.read		= soc_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void __init timer_config(void)
+{
+	unsigned long ccr = __raw_readl(TIMERS_VIRT_BASE + TMR_CCR);
+	unsigned long cer = __raw_readl(TIMERS_VIRT_BASE + TMR_CER);
+	unsigned long cmr = __raw_readl(TIMERS_VIRT_BASE + TMR_CMR);
+
+	/* disable Timer 0 & 1 */
+	__raw_writel(cer & ~0x7, TIMERS_VIRT_BASE + TMR_CER);
+
+	/* clock frequency from clock/reset control register for Timer 0 */
+	ccr &= ~0x7f;
+#ifdef CONFIG_PXA_32KTIMER
+	ccr |= TMR_CCR_CS_0(1) | TMR_CCR_CS_1(1) | TMR_CCR_CS_2(2);
+#else
+	ccr |= TMR_CCR_CS_0(0) | TMR_CCR_CS_1(0) | TMR_CCR_CS_2(0);
+#endif
+	__raw_writel(ccr, TIMERS_VIRT_BASE + TMR_CCR);
+
+	/* free-running mode for Timer 0 & 1 */
+	__raw_writel(cmr | 0x07, TIMERS_VIRT_BASE + TMR_CMR);
+
+	/* Timer 0 */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(0)); /* free-running */
+	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(0));  /* clear status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(0));  /* disable int */
+
+	/* Timer 1 */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(1)); /* free-running */
+	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(1));  /* clear status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(1));  /* disable int */
+
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_PLCR(2)); /* free-running */
+	__raw_writel(0x7, TIMERS_VIRT_BASE + TMR_ICR(2));  /* clear status */
+	__raw_writel(0x0, TIMERS_VIRT_BASE + TMR_IER(2));  /* disable int */
+
+	/* enable Timer 2 for clock source */
+	__raw_writel(cer | 0x4, TIMERS_VIRT_BASE + TMR_CER);
+}
+
+static void generic_timer_access(void)
+{
+	__raw_writel(0xbaba, CP_TIMERS2_VIRT_BASE + TMR_WFAR);
+	__raw_writel(0xeb10, CP_TIMERS2_VIRT_BASE + TMR_WSAR);
+}
+
+static void generic_timer_config(void)
+{
+	unsigned int value;
+
+	__raw_writel(0x10, MPMU_CPRR);
+	/* set the clock select as 3.25M */
+	generic_timer_access();
+	value = __raw_readl(GEN_TMR_CFG);
+	value &= ~(0x3 << 4);
+	generic_timer_access();
+	__raw_writel(value, GEN_TMR_CFG);
+
+	/* set the count enable */
+	generic_timer_access();
+	value = __raw_readl(GEN_TMR_CFG);
+	value |= 0x3;
+	generic_timer_access();
+	__raw_writel(value, GEN_TMR_CFG);
+}
+
+static inline void
+clocksource_calc_mult_shift(struct clocksource *cs, u32 freq, u32 minsec)
+{
+	return clocks_calc_mult_shift(&cs->mult, &cs->shift, freq,
+		NSEC_PER_SEC, minsec);
+}
+
+void __init timer_init(int irq0, int irq1, int irq2)
+{
+	timer_config();
+
+#ifdef CONFIG_PXA_32KTIMER
+	setup_sched_clock(soc_read_timer, 32, 32768);
+	clocksource_calc_mult_shift(&cksrc, 32768, 4);
+	clockevents_calc_mult_shift(&ckevt0, 32768, 4);
+	clockevents_calc_mult_shift(&ckevt1, 32768, 4);
+#else
+	setup_sched_clock(soc_read_timer, 32, CLOCK_TICK_RATE);
+	clocksource_calc_mult_shift(&cksrc, CLOCK_TICK_RATE, 4);
+	clockevents_calc_mult_shift(&ckevt0, CLOCK_TICK_RATE, 4);
+	clockevents_calc_mult_shift(&ckevt1, CLOCK_TICK_RATE, 4);
+#endif
+
+	generic_timer_config();
+	set_us2cyc_scale(CLOCK_TICK_RATE / 2);	/* use generic timer */
+
+	clocksource_register(&cksrc);
+
+	ckevt0.irq = irq_timer0 = irq0;
+	ckevt1.irq = irq_timer1 = irq1;
+
+	ckevt0.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt0);
+	ckevt0.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt0);
+	ckevt0.cpumask = cpumask_of(1);
+
+	ckevt1.max_delta_ns = clockevent_delta2ns(MAX_DELTA, &ckevt1);
+	ckevt1.min_delta_ns = clockevent_delta2ns(MIN_DELTA, &ckevt1);
+	ckevt1.cpumask = cpumask_of(0);
+
+	timer1_irq.dev_id = &ckevt1;
+	setup_irq(irq1, &timer1_irq);
+	irq_set_affinity(irq1, cpumask_of(0));
+	clockevents_register_device(&ckevt1);
+	return;
+}
+
+int local_timer_setup(struct clock_event_device *evt)
+{
+	unsigned int cpu = smp_processor_id();
+
+	if (cpu != 0) {
+		memcpy(evt, &ckevt0, sizeof(struct clock_event_device));
+
+		clockevents_register_device(evt);
+		timer0_irq.dev_id = evt;
+		irq_set_affinity(evt->irq, cpumask_of(cpu));
+		setup_irq(evt->irq, &timer0_irq);
+	}
+
+	return 0;
+}
diff --git a/arch/arm/mach-mmp/sram.c b/arch/arm/mach-mmp/sram.c
index 4304f95..486bd9d 100644
--- a/arch/arm/mach-mmp/sram.c
+++ b/arch/arm/mach-mmp/sram.c
@@ -6,7 +6,7 @@
  *  Copyright (c) 2011 Marvell Semiconductors Inc.
  *  All Rights Reserved
  *
- *  Add for mmp sram support - Leo Yan <leoy@marvell.com>
+ *  Add for mmp2 audio sram support - Leo Yan <leoy@marvell.com>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License version 2 as
@@ -19,61 +19,98 @@
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/err.h>
-#include <linux/slab.h>
 #include <linux/genalloc.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
 
 #include <mach/sram.h>
 
-struct sram_bank_info {
-	char *pool_name;
-	struct gen_pool *gpool;
-	int granularity;
-
-	phys_addr_t sram_phys;
-	void __iomem *sram_virt;
-	u32 sram_size;
-
-	struct list_head node;
-};
-
 static DEFINE_MUTEX(sram_lock);
-static LIST_HEAD(sram_bank_list);
+static LIST_HEAD(sram_list);
 
-struct gen_pool *sram_get_gpool(char *pool_name)
+static struct sram_bank *sram_get_avail(char *pool_name)
 {
-	struct sram_bank_info *info = NULL;
-
-	if (!pool_name)
-		return NULL;
+	struct sram_bank *sram_bank_slot;
 
 	mutex_lock(&sram_lock);
+	if (list_empty(&sram_list)) {
+		pr_err("no available sram\n");
+		mutex_unlock(&sram_lock);
+		return NULL;
+	}
 
-	list_for_each_entry(info, &sram_bank_list, node)
-		if (!strcmp(pool_name, info->pool_name))
+	list_for_each_entry(sram_bank_slot, &sram_list,
+			    sram_list) {
+		if (memcmp(sram_bank_slot->pool_name, pool_name, 10) == 0)
 			break;
+	}
+
+	if (&sram_bank_slot->sram_list == &sram_list) {
+		pr_err("no matched sram found\n");
+		mutex_unlock(&sram_lock);
+		return NULL;
+	}
 
 	mutex_unlock(&sram_lock);
+	return sram_bank_slot;
+}
+
+void *sram_alloc(char *pool_name, size_t len, dma_addr_t * dma)
+{
+	unsigned long vaddr;
+	struct sram_bank *sram_bank_slot;
+	dma_addr_t dma_base;
 
-	if (&info->node == &sram_bank_list)
+	sram_bank_slot = sram_get_avail(pool_name);
+	if (sram_bank_slot == NULL) {
+		pr_err("failed to alloc sram\n");
 		return NULL;
+	}
+
+	dma_base = (dma_addr_t) sram_bank_slot->sram_phys;
 
-	return info->gpool;
+	if (dma)
+		*dma = 0;
+	if (!sram_bank_slot->pool || (dma && !dma_base))
+		return NULL;
+
+	vaddr = gen_pool_alloc(sram_bank_slot->pool, len);
+	if (!vaddr)
+		return NULL;
+
+	if (dma)
+		*dma = dma_base + (vaddr -
+				(unsigned long)sram_bank_slot->sram_virt);
+	return (void *)vaddr;
 }
-EXPORT_SYMBOL(sram_get_gpool);
+EXPORT_SYMBOL(sram_alloc);
+
+void sram_free(char *pool_name, void *addr, size_t len)
+{
+	struct sram_bank *sram_bank_slot;
+
+	sram_bank_slot = sram_get_avail(pool_name);
+	if (sram_bank_slot == NULL) {
+		pr_err("failed to free sram\n");
+		return;
+	}
+
+	gen_pool_free(sram_bank_slot->pool, (unsigned long)addr, len);
+}
+EXPORT_SYMBOL(sram_free);
 
 static int __devinit sram_probe(struct platform_device *pdev)
 {
-	struct sram_platdata *pdata = pdev->dev.platform_data;
-	struct sram_bank_info *info;
 	struct resource *res;
+	struct sram_bank *sram_bank_slot;
 	int ret = 0;
 
-	if (!pdata && !pdata->pool_name)
-		return -ENODEV;
-
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (!info)
-		return -ENOMEM;
+	sram_bank_slot = pdev->dev.platform_data;
+	if (sram_bank_slot == NULL) {
+		dev_err(&pdev->dev, "no platform data defined\n");
+		return -EINVAL;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
@@ -81,25 +118,21 @@ static int __devinit sram_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto out;
 	}
+	sram_bank_slot->sram_phys = res->start;
+	sram_bank_slot->sram_size = res->end - res->start + 1;
+	sram_bank_slot->sram_virt =
+	    ioremap(sram_bank_slot->sram_phys, sram_bank_slot->sram_size);
 
-	if (!resource_size(res))
-		return 0;
-
-	info->sram_phys   = (phys_addr_t)res->start;
-	info->sram_size   = resource_size(res);
-	info->sram_virt   = ioremap(info->sram_phys, info->sram_size);
-	info->pool_name	  = kstrdup(pdata->pool_name, GFP_KERNEL);
-	info->granularity = pdata->granularity;
-
-	info->gpool = gen_pool_create(ilog2(info->granularity), -1);
-	if (!info->gpool) {
+	sram_bank_slot->pool = gen_pool_create(ilog2(sram_bank_slot->step), -1);
+	if (!sram_bank_slot->pool) {
 		dev_err(&pdev->dev, "create pool failed\n");
 		ret = -ENOMEM;
 		goto create_pool_err;
 	}
 
-	ret = gen_pool_add_virt(info->gpool, (unsigned long)info->sram_virt,
-				info->sram_phys, info->sram_size, -1);
+	ret = gen_pool_add(sram_bank_slot->pool,
+			 (unsigned long)sram_bank_slot->sram_virt,
+			 sram_bank_slot->sram_size, -1);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "add new chunk failed\n");
 		ret = -ENOMEM;
@@ -107,62 +140,52 @@ static int __devinit sram_probe(struct platform_device *pdev)
 	}
 
 	mutex_lock(&sram_lock);
-	list_add(&info->node, &sram_bank_list);
+	list_add(&sram_bank_slot->sram_list, &sram_list);
 	mutex_unlock(&sram_lock);
 
-	platform_set_drvdata(pdev, info);
-
-	dev_info(&pdev->dev, "initialized\n");
 	return 0;
 
 add_chunk_err:
-	gen_pool_destroy(info->gpool);
+	gen_pool_destroy(sram_bank_slot->pool);
 create_pool_err:
-	iounmap(info->sram_virt);
-	kfree(info->pool_name);
+	iounmap(sram_bank_slot->sram_virt);
 out:
-	kfree(info);
 	return ret;
 }
 
 static int __devexit sram_remove(struct platform_device *pdev)
 {
-	struct sram_bank_info *info;
-
-	info = platform_get_drvdata(pdev);
-	if (info == NULL)
-		return -ENODEV;
+	struct sram_bank *sram_bank_slot = pdev->dev.platform_data;
+	if (sram_bank_slot == NULL) {
+		dev_err(&pdev->dev, "no platform data defined\n");
+		return -EINVAL;
+	}
 
-	mutex_lock(&sram_lock);
-	list_del(&info->node);
-	mutex_unlock(&sram_lock);
+	gen_pool_destroy(sram_bank_slot->pool);
+	iounmap(sram_bank_slot->sram_virt);
+	list_del(&sram_bank_slot->sram_list);
 
-	gen_pool_destroy(info->gpool);
-	iounmap(info->sram_virt);
-	kfree(info->pool_name);
-	kfree(info);
 	return 0;
 }
 
-static const struct platform_device_id sram_id_table[] = {
-	{ "asram", MMP_ASRAM },
-	{ "isram", MMP_ISRAM },
-	{ }
-};
-
 static struct platform_driver sram_driver = {
-	.probe		= sram_probe,
-	.remove		= sram_remove,
-	.driver		= {
-		.name	= "mmp-sram",
-	},
-	.id_table	= sram_id_table,
+	.probe = sram_probe,
+	.remove = sram_remove,
+	.driver = {
+		   .name = "mmp-sram",
+		   },
 };
 
 static int __init sram_init(void)
 {
 	return platform_driver_register(&sram_driver);
 }
-core_initcall(sram_init);
 
+static void __exit sram_exit(void)
+{
+	platform_driver_unregister(&sram_driver);
+}
+
+module_init(sram_init);
+module_exit(sram_exit);
 MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mmp/suspend.c b/arch/arm/mach-mmp/suspend.c
new file mode 100644
index 0000000..dd117d0
--- /dev/null
+++ b/arch/arm/mach-mmp/suspend.c
@@ -0,0 +1,119 @@
+#undef DEBUG
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/suspend.h>
+#include <linux/cpuidle.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/pm_qos_params.h>
+
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+#include <mach/addr-map.h>
+#include <mach/regs-apmu.h>
+#include <mach/regs-mpmu.h>
+#include <mach/mmp3_pm.h>
+#include <mach/system.h>
+
+static unsigned long pm_state;
+static struct pm_qos_request_list cpu_max_num_req;
+
+int mmp3_set_wake(struct irq_data *data, unsigned int on)
+{
+	unsigned int irq = data->irq;
+	struct irq_desc *desc = irq_to_desc(irq);
+
+	if (unlikely(irq >= nr_irqs)) {
+		pr_err("IRQ nubmers are out of boundary!\n");
+		return -EINVAL;
+	}
+
+	if (on) {
+		if (desc->action)
+			desc->action->flags |= IRQF_NO_SUSPEND;
+	} else {
+		if (desc->action)
+			desc->action->flags &= ~IRQF_NO_SUSPEND;
+	}
+
+	/*
+	 * TODO: Setup wakeup source. Will do it when wakeup is
+	 * ready in hardware side.
+	 */
+
+	return 0;
+}
+
+static int mmp3_pm_enter(suspend_state_t state)
+{
+	/*
+	 * TODO: If any wakeup source uses thread to handle its interrupt,
+	 * make sure the interrupt is enabled here.
+	 */
+
+	mmp3_pm_enter_d2();
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mmp3_pm_prepare(void)
+{
+	pm_qos_update_request(&cpu_max_num_req, 1);
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mmp3_pm_finish(void)
+{
+	pm_qos_update_request(&cpu_max_num_req, PM_QOS_DEFAULT_VALUE);
+	pm_state = PM_SUSPEND_ON;
+}
+
+static void mmp3_pm_wake(void)
+{
+	return;
+}
+
+static int mmp3_pm_valid(suspend_state_t state)
+{
+	int ret = 1;
+
+	if (state == PM_SUSPEND_STANDBY) {
+		pm_state = PM_SUSPEND_STANDBY;
+	} else if (state == PM_SUSPEND_MEM) {
+		pm_state = PM_SUSPEND_MEM;
+	} else {
+		ret = 0;
+	}
+	return ret;
+}
+
+/*
+ * Set to PM_DISK_FIRMWARE so we can quickly veto suspend-to-disk.
+ */
+static struct platform_suspend_ops mmp3_pm_ops = {
+	.valid		= mmp3_pm_valid,
+	.prepare	= mmp3_pm_prepare,
+	.enter		= mmp3_pm_enter,
+	.finish		= mmp3_pm_finish,
+	.wake		= mmp3_pm_wake,
+};
+
+static int __init mmp3_suspend_init(void)
+{
+	suspend_set_ops(&mmp3_pm_ops);
+	pm_qos_add_request(&cpu_max_num_req, PM_QOS_MAX_ONLINE_CPUS, PM_QOS_DEFAULT_VALUE);
+	return 0;
+}
+
+late_initcall(mmp3_suspend_init);
+
-- 
1.7.5.4

