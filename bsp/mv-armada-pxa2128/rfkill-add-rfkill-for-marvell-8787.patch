From 16269ecaaca986f76844aa74f46d8288af7b2518 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Wed, 21 Aug 2013 14:49:37 +0800
Subject: [PATCH 2/2] rfkill: add rfkill for marvell 8787

Original patches come from M5.3.12.5.4_sources, which version is
3.0.31.

Singed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mmp/qseven.c  |    1 +
 drivers/misc/Kconfig        |   12 ++
 drivers/misc/Makefile       |    1 +
 drivers/misc/sd8x_rfkill.c  |  351 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/sd8x_rfkill.h |   52 +++++++
 5 files changed, 417 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/sd8x_rfkill.c
 create mode 100644 include/linux/sd8x_rfkill.h

diff --git a/arch/arm/mach-mmp/qseven.c b/arch/arm/mach-mmp/qseven.c
index ad7064c..ac3aae6 100644
--- a/arch/arm/mach-mmp/qseven.c
+++ b/arch/arm/mach-mmp/qseven.c
@@ -23,6 +23,7 @@
 
 #include <linux/regulator/88pm867.h>
 #include <linux/i2c/tsc2007.h>
+#include <linux/sd8x_rfkill.h>
 #include <linux/mmc/sdhci.h>
 
 #include <linux/pwm_backlight.h>
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index f8bc730..9389648 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -513,6 +513,18 @@ config MAX8997_MUIC
 config ARM_CCI
 	bool "ARM CCI driver support"
 
+config SD8XXX_RFKILL
+        tristate "Rfkill power control for Marvell sd8xxx wlan/bt"
+        depends on MMC_SDHCI_PXAV2 || MMC_SDHCI_PXAV3 || MMC_SDHCI_PXAV2_TAVOR
+        select RFKILL
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	select WEXT_SPY
+        default n
+        ---help---
+         Creates an rfkill entry in sysfs for power control of Marvell
+         sd8xxx wlan/bt chips.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 19f55b7..2abdda9 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -52,3 +52,4 @@ obj-$(CONFIG_MAX8997_MUIC)	+= max8997-muic.o
 obj-$(CONFIG_ARM_CCI)		+= arm-cci.o
 obj-$(CONFIG_ARCH_VEXPRESS)	+= vexpress/
 obj-$(CONFIG_ANDROID_PMEM)	+= pmem.o
+obj-$(CONFIG_SD8XXX_RFKILL)     += sd8x_rfkill.o
diff --git a/drivers/misc/sd8x_rfkill.c b/drivers/misc/sd8x_rfkill.c
new file mode 100644
index 0000000..fbbdb6f
--- /dev/null
+++ b/drivers/misc/sd8x_rfkill.c
@@ -0,0 +1,351 @@
+/*
+ * rfkill power contorl for Marvell sd8xxx wlan/bt
+ *
+ * Copyright (C) 2009 Marvell, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdhci.h>
+#include <linux/clk.h>
+#include <linux/sd8x_rfkill.h>
+#include <linux/platform_data/pxa_sdhci.h>
+#include <mach/gpio.h>
+#define SD8X_DEV_NAME "sd8x-rfkill"
+
+struct sd8x_rfkill_data {
+	enum rfkill_type type;
+	bool blocked;
+	struct sd8x_rfkill_platform_data *pdata;
+};
+static struct sd8x_rfkill_data *local_sd8x_data;
+
+int add_sd8x_rfkill_device(int gpio_power_down, int gpio_reset,
+			   struct mmc_host ***pmmc,
+			   rfkill_plat_set_power set_power)
+{
+	int ret;
+	struct platform_device *pdev = NULL;
+	struct sd8x_rfkill_platform_data *pdata = NULL;
+
+	pdata = kzalloc(sizeof(struct sd8x_rfkill_platform_data), GFP_KERNEL);
+	if (!pdata) {
+		printk(KERN_CRIT "no memory\n");
+		goto err_out;
+	}
+	pdata->gpio_power_down = gpio_power_down;
+	pdata->gpio_reset = gpio_reset;
+
+	pdev = kzalloc(sizeof(struct platform_device), GFP_KERNEL);
+	if (!pdev) {
+		printk(KERN_CRIT "no memory\n");
+		goto err_out;
+	}
+	pdev->name = SD8X_DEV_NAME;
+	pdev->id = -1, pdev->dev.platform_data = pdata;
+
+	ret = platform_device_register(pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register device: %d\n", ret);
+		goto err_out;
+	}
+	*pmmc = &(pdata->mmc);
+	pdata->set_power = set_power;
+	return 0;
+
+err_out:
+	if (pdata)
+		kfree(pdata);
+	if (pdev)
+		kfree(pdev);
+	pr_debug("%s: error\n", __func__);
+	return -1;
+}
+
+EXPORT_SYMBOL(add_sd8x_rfkill_device);
+
+static int sd8x_power_on(struct sd8x_rfkill_platform_data *pdata, int on)
+{
+	int gpio_power_down = pdata->gpio_power_down;
+	int gpio_reset = pdata->gpio_reset;
+
+	pr_debug("%s: on=%d\n", __func__, on);
+	if (gpio_power_down
+	    && gpio_request(gpio_power_down, "sd8xxx power down")) {
+		printk(KERN_INFO "gpio %d request failed\n", gpio_power_down);
+		return -1;
+	}
+
+	if (gpio_reset && gpio_request(gpio_reset, "sd8xxx reset")) {
+		printk(KERN_INFO "gpio %d request failed\n", gpio_reset);
+		gpio_free(gpio_power_down);
+		return -1;
+	}
+
+	if (on) {
+		if (gpio_power_down)
+			gpio_direction_output(gpio_power_down, 1);
+
+		if (gpio_reset) {
+			gpio_direction_output(gpio_reset, 0);
+			msleep(1);
+			gpio_direction_output(gpio_reset, 1);
+		}
+	} else {
+		if (gpio_power_down)
+			gpio_direction_output(gpio_power_down, 0);
+	}
+
+	if (gpio_power_down)
+		gpio_free(gpio_power_down);
+	if (gpio_reset)
+		gpio_free(gpio_reset);
+	return 0;
+}
+
+unsigned long mmc_detect_change_sync(struct mmc_host *host,
+					    unsigned long delay,
+					    unsigned long timeout);
+static int sd8x_set_block(void *data, bool blocked)
+{
+	bool pre_blocked;
+	int ret = 0;
+	int on = 0;
+	struct sd8x_rfkill_data *sd8x_data = (struct sd8x_rfkill_data *)data;
+	struct sd8x_rfkill_platform_data *pdata = sd8x_data->pdata;
+	struct sdhci_host *host = mmc_priv(pdata->mmc);
+
+	if (!pdata->wlan_rfkill) {
+		if (sd8x_data->pdata->set_power)
+			sd8x_data->pdata->set_power(0);
+		ret = sd8x_power_on(sd8x_data->pdata, 0);
+		return 0;
+	}
+	pre_blocked = sd8x_data->blocked;
+
+	pr_debug
+	    ("%s: try to set block state of type(%d) as %d, pre_blocked=%d\n",
+	     __func__, sd8x_data->type, blocked, pre_blocked);
+	if (!blocked && pre_blocked)
+		on = 1;
+	else if (blocked && !pre_blocked)
+		on = 0;
+	else
+		return 0;
+
+       /* for ON, enable mmc controller clock source 1st if it is gated
+		after controller probe ends; for OFF, no action here since the clock
+		should be already on */
+       if (on && host->clk) {
+               clk_enable(host->clk);
+               mdelay(1);
+       }
+	if (pdata->set_power)
+		pdata->set_power(on);
+	ret = sd8x_power_on(pdata, on);
+
+	if (ret)
+		goto out;
+
+	if (pdata->mmc) {
+		int retry = 5;
+		unsigned long timeout_secs = 5;
+		unsigned long timeout = msecs_to_jiffies(timeout_secs * 1000);
+
+		while (retry) {
+			if (0 == mmc_detect_change_sync(pdata->mmc,
+							msecs_to_jiffies(10),
+							timeout)) {
+				printk(KERN_WARNING
+				       "mmc detect has taken %u ms, "
+				       "something wrong\n",
+				       jiffies_to_msecs(timeout));
+			}
+			if ((on && (pdata->mmc->card))
+			    || (!on && !(pdata->mmc->card)))
+				break;
+
+			printk(KERN_INFO "Retry mmc detection\n");
+
+			retry--;
+			ret = sd8x_power_on(pdata, on);
+			if (ret)
+				goto out;
+		}
+		if (!retry) {
+			ret = -1;
+			printk(KERN_INFO "rfkill fails to wait mmc device %s\n",
+			       on ? "up" : "down");
+		}
+	} else
+		printk(KERN_DEBUG "rfkill is not linked with mmc_host\n");
+
+out:
+	if (!ret) {
+		sd8x_data->blocked = blocked;
+
+		/* for OFF, disable the clock source here */
+		if(!on && host->clk)
+			clk_disable(host->clk);
+	}
+	else if (on) {
+		if (pdata->set_power)
+			pdata->set_power(0);
+		sd8x_power_on(pdata, 0);
+		if(host->clk)
+			clk_disable(host->clk);
+	}
+
+	return ret;
+}
+
+static struct rfkill *sd8x_rfkill_register(struct device *parent,
+					   enum rfkill_type type, char *name,
+					   struct sd8x_rfkill_platform_data
+					   *pdata)
+{
+	int err;
+	struct rfkill *dev = NULL;
+	struct rfkill_ops *ops = NULL;
+
+	ops = kzalloc(sizeof(struct rfkill_ops), GFP_KERNEL);
+	if (!ops)
+		goto err_out;
+	ops->set_block = sd8x_set_block;
+
+	local_sd8x_data->type = type;
+	local_sd8x_data->blocked = true;
+	local_sd8x_data->pdata = pdata;
+
+	dev = rfkill_alloc(name, parent, type, ops, local_sd8x_data);
+	if (!dev)
+		goto err_out;
+
+	/* init device software states, and block it by default */
+	rfkill_init_sw_state(dev, false);
+
+	err = rfkill_register(dev);
+	if (err)
+		goto err_out;
+
+	return dev;
+
+err_out:
+	if (ops)
+		kfree(ops);
+	if (dev)
+		rfkill_destroy(dev);
+	return 0;
+}
+
+static void sd8x_rfkill_free(struct sd8x_rfkill_platform_data *pdata)
+{
+	if (pdata->wlan_rfkill) {
+		rfkill_unregister(pdata->wlan_rfkill);
+		rfkill_destroy(pdata->wlan_rfkill);
+	}
+
+	kfree(local_sd8x_data);
+}
+
+static int sd8x_rfkill_probe(struct platform_device *pdev)
+{
+	struct rfkill *rfkill = NULL;
+	struct sd8x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+
+	struct sd8x_rfkill_data *data = NULL;
+
+	data = kzalloc(sizeof(struct sd8x_rfkill_data), GFP_KERNEL);
+	if (!data)
+		goto err_out;
+	local_sd8x_data = data;
+
+	rfkill = sd8x_rfkill_register(&pdev->dev,
+				      RFKILL_TYPE_WLAN, "sd8xxx-wlan", pdata);
+	if (IS_ERR(rfkill))
+		goto err_out;
+	pdata->wlan_rfkill = rfkill;
+	sd8x_power_on(pdata, 1);
+	return 0;
+
+err_out:
+	sd8x_rfkill_free(pdata);
+	return -1;
+}
+
+static int sd8x_rfkill_remove(struct platform_device *pdev)
+{
+	struct sd8x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+
+	sd8x_rfkill_free(pdata);
+
+	return 0;
+}
+
+static int sd8x_rfkill_suspend(struct platform_device *pdev,
+			       pm_message_t pm_state)
+{
+	struct sd8x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+	if (pdata->set_power)
+		pdata->set_power(0);
+	sd8x_power_on(pdata, 0);
+	return 0;
+}
+
+static int sd8x_rfkill_resume(struct platform_device *pdev)
+{
+	struct sd8x_rfkill_platform_data *pdata = pdev->dev.platform_data;
+	if (pdata->set_power)
+		pdata->set_power(1);
+	sd8x_power_on(pdata, 0);
+	sd8x_power_on(pdata, 1);
+	return 0;
+}
+
+static struct platform_driver sd8x_rfkill_platform_driver = {
+	.probe = sd8x_rfkill_probe,
+	.remove = sd8x_rfkill_remove,
+	.driver = {
+		   .name = SD8X_DEV_NAME,
+		   .owner = THIS_MODULE,
+		   },
+	.suspend = sd8x_rfkill_suspend,
+	.resume = sd8x_rfkill_resume,
+};
+
+static int __init sd8x_rfkill_init(void)
+{
+	return platform_driver_register(&sd8x_rfkill_platform_driver);
+}
+
+static void __exit sd8x_rfkill_exit(void)
+{
+	platform_driver_unregister(&sd8x_rfkill_platform_driver);
+}
+
+module_init(sd8x_rfkill_init);
+module_exit(sd8x_rfkill_exit);
+
+MODULE_ALIAS("platform:sd8x_rfkill");
+MODULE_DESCRIPTION("sd8x_rfkill");
+MODULE_AUTHOR("Marvell");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/sd8x_rfkill.h b/include/linux/sd8x_rfkill.h
new file mode 100644
index 0000000..3a76c48
--- /dev/null
+++ b/include/linux/sd8x_rfkill.h
@@ -0,0 +1,52 @@
+/*
+ * rfkill power contorl for Marvell sd8xxx wlan/bt
+ *
+ * Copyright (C) 2009 Marvell, Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _LINUX_SD8X_RFKILL_H
+#define _LINUX_SD8X_RFKILL_H
+
+#include <linux/rfkill.h>
+#include <linux/mmc/mmc.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+
+typedef void (*rfkill_plat_set_power) (unsigned int);
+
+struct sd8x_rfkill_platform_data {
+	int gpio_power_down;
+	int gpio_reset;
+
+	struct rfkill *wlan_rfkill;
+	struct rfkill *bt_rfkill;
+	struct rfkill *fm_rfkill;
+
+	/*for issue mmc card_detection interrupt */
+	struct mmc_host *mmc;
+
+	/* for platform specific power on sequence */
+	rfkill_plat_set_power set_power;
+};
+
+int sd8x_sdh_init(struct device *dev, irq_handler_t detect_irq, void *data);
+
+int add_sd8x_rfkill_device(int gpio_power_down, int gpio_reset,
+			   struct mmc_host ***pmmc,
+			   rfkill_plat_set_power set_power);
+#endif
-- 
1.7.5.4

