From 3c27df04cc62e3dcc01cbfbf987aaa09aa37d046 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 25 Dec 2008 18:25:33 +0800
Subject: [PATCH] Support mv64460 Timer Platform Driver

Add MV64X60 (Marvell Discovery III) Timer Support

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/misc/Kconfig         |    7 +
 drivers/misc/Makefile        |    1 +
 drivers/misc/mv64460_timer.c |  309 ++++++++++++++++++++++++++++++++++++++++++
 drivers/misc/mv64460_timer.h |   27 ++++
 4 files changed, 344 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/mv64460_timer.c
 create mode 100644 drivers/misc/mv64460_timer.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index f0202ee..e332c69 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -488,4 +488,11 @@ config SGI_GRU_DEBUG
 	This option enables addition debugging code for the SGI GRU driver. If
 	you are unsure, say N.
 
+config MV64X60_TIMER
+        bool "MV64X60 (Marvell Discovery III) Timer Support"
+        depends on MV64X60
+        default y
+        help
+          This option enables the marvell timers support.
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index b6167e7..4755564 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -31,3 +31,4 @@ obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
 obj-$(CONFIG_HP_ILO)		+= hpilo.o
+obj-$(CONFIG_MV64X60_TIMER)     += mv64460_timer.o
diff --git a/drivers/misc/mv64460_timer.c b/drivers/misc/mv64460_timer.c
new file mode 100644
index 0000000..4bed496
--- /dev/null
+++ b/drivers/misc/mv64460_timer.c
@@ -0,0 +1,309 @@
+/*
+ * drivers/misc/mv64460_timer.c
+ *
+ * marvell (mv64460) programmable timers API.
+ *
+ * Author:  Majid Khan M Z, (amm117@motorola.com).
+ * Copyright 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ * 
+ * Change log:
+ * 	* v1.1 Use platform device and driver mechanism to replace the original
+ * 		Tiejun Chen (tiejun.chen@windriver.com)
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/types.h> 
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/mv643xx.h>
+#include "mv64460_timer.h"
+#include <asm/machdep.h>
+#include <linux/platform_device.h>
+
+#define BIT0	0x00000001
+#define BIT1	0x00000002
+#define BIT2	0x00000004
+#define BIT3	0x00000008
+
+		/* Marvell timer control register for timer 0 */
+#define MV64X60_TC_EN		BIT0
+#define MV64X60_TC_MODE 	BIT1
+#define MV64X60_TC_TRIG		BIT2
+#define MV64X60_TC_WIDTH	BIT3
+#define MV64X60_TC_RES		0xf0
+
+#define DRV_NAME "mv64x60_timer"
+#define DRV_VERSION "1.1"
+
+/* The default hwirq */
+static int mv64x60_timer_irq[4];
+
+struct mv64x60_timer_t {
+	mv64x60_timer_f func;
+	void *func_data;
+	int started;
+	int periodic; /* 1 for periodic and 0 for one shot timer */
+	unsigned long period;
+};
+
+static struct mv64x60_timer_t mv64x60_timer[4];
+static spinlock_t mv64x60_timer_lock = SPIN_LOCK_UNLOCKED;
+static unsigned long mv64x60_bus_clk_tick = 133;	/*number of ticks per microseconds*/
+void __iomem *reg_ofset;
+
+int mv64x60_timer_stop(int timer_number)
+{
+	unsigned long flags;
+	unsigned int temp;
+
+	if(timer_number < 0 || timer_number > 3)
+		return (-EINVAL);
+
+	spin_lock_irqsave(&mv64x60_timer_lock, flags);
+
+	temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL);
+	temp |= ~(MV64X60_TC_EN << (timer_number * 8));
+	out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL, temp);
+
+	mv64x60_timer[timer_number].func = NULL;
+	mv64x60_timer[timer_number].func_data = NULL;
+	mv64x60_timer[timer_number].started = 0;
+	mv64x60_timer[timer_number].periodic = 0;
+	mv64x60_timer[timer_number].period = 0;
+	spin_unlock_irqrestore(&mv64x60_timer_lock, flags);
+
+	return (0);
+}
+EXPORT_SYMBOL(mv64x60_timer_stop);
+
+int mv64x60_timer_start(int timer_number, unsigned long microseconds, mv64x60_timer_f func, void *func_data, int periodic)
+{
+	unsigned long flags;
+	unsigned int temp;
+	
+	if(timer_number < 0 || timer_number > 3)
+		return (-EINVAL);
+	if(func == NULL)
+		return (-EINVAL);
+	if(mv64x60_timer[timer_number].started == 1)
+		return (-EBUSY);
+
+	printk(KERN_INFO "mv64x60_timer_start: number %d micoroseconds 0x%lx periodic %d\n", timer_number, microseconds, periodic);
+	
+	if(microseconds > (0xffffffff/mv64x60_bus_clk_tick) || microseconds <= 0)
+		return (-EINVAL);
+
+	spin_lock_irqsave(&mv64x60_timer_lock, flags);
+
+	mv64x60_timer[timer_number].started = 1;
+       	mv64x60_timer[timer_number].func = func;
+	mv64x60_timer[timer_number].func_data = func_data;
+       	mv64x60_timer[timer_number].periodic = periodic;
+       	mv64x60_timer[timer_number].period = microseconds;
+
+	out_le32(reg_ofset + ( MV64340_TIMER_COUNTER0 + (timer_number * 4)), (microseconds * mv64x60_bus_clk_tick));
+
+	temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL);
+	temp |= (MV64X60_TC_EN << (timer_number * 8));
+	out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL, temp);
+
+	spin_unlock_irqrestore(&mv64x60_timer_lock, flags);
+
+	return (0);
+	
+}
+EXPORT_SYMBOL(mv64x60_timer_start);
+
+irqreturn_t mv64x60_timer_int_handler (int irq, void *data)
+{
+	struct mv64x60_timer_t *info = data;
+	mv64x60_timer_f func;
+	void *func_data;
+	int timer_number;
+	unsigned int caused_val;
+	unsigned int temp;
+
+	caused_val = (in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE)) & 0xf;
+	switch(caused_val) {
+		case BIT0:
+			timer_number = 0;
+			info = &mv64x60_timer[timer_number];
+			func_data = info->func_data;
+			func = info->func;
+
+			temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE);
+			temp &= ~BIT0;
+			out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE, temp);
+
+			if(info->func)
+				func(func_data);
+			if(!info->periodic) 
+				mv64x60_timer_stop(timer_number);
+			break;
+		case BIT1:
+			timer_number = 1;
+			info = &mv64x60_timer[timer_number];
+			func_data = info->func_data;
+			func = info->func;
+
+			temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE);
+			temp &= ~BIT1;
+			out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE, temp);
+
+			if(info->func)
+				func(func_data);
+			if(!info->periodic) 
+				mv64x60_timer_stop(timer_number);
+			break;
+		case BIT2:
+			timer_number = 2;
+			info = &mv64x60_timer[timer_number];
+			func_data = info->func_data;
+			func = info->func;
+
+			temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE);
+			temp &= ~BIT2;
+			out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE, temp);
+
+			if(info->func)
+				func(func_data);
+			if(!info->periodic)
+				mv64x60_timer_stop(timer_number);
+			break;
+		case BIT3:
+			timer_number = 3;
+			info = &mv64x60_timer[timer_number];
+			func_data = info->func_data;
+			func = info->func;
+
+			temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE);
+			temp &= ~BIT3;
+			out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_CAUSE, temp);
+
+			if(info->func)
+				func(func_data);
+			if(!info->periodic)
+				mv64x60_timer_stop(timer_number);
+			break;
+		default:
+			return (IRQ_NONE);
+	}
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PROC_FS
+static int mv64x60_timer_proc_read(char *buf, char **start, off_t off, int len, int *eof, void *data)
+{
+	int i;
+	len = 0;
+	len += sprintf(buf+len, "\nTimer	Active	periodic	period(microseconds)\n");
+	len += sprintf(buf+len,   "_____	______	________	_____________________");
+	for(i = 0; i <= 3; i++) {
+		len += sprintf(len+buf, "\n#%d	%c	%c	%ld\n", i+1, (mv64x60_timer[i].started) ? 'y' : 'n', 
+				(mv64x60_timer[i].periodic) ? 'y' : 'n', (mv64x60_timer[i].periodic == 1) ? mv64x60_timer[i].period : 0);
+	}
+	return (len);
+}
+#endif
+
+static int __devinit
+mv64xxx_timer_probe(struct platform_device *pd)
+{
+	unsigned int temp;
+	int size;
+	static int next = 0;
+	void __iomem *reg_base;
+	struct resource	*r0 = platform_get_resource(pd, IORESOURCE_MEM, 0);
+	struct resource	*r1 = platform_get_resource(pd, IORESOURCE_IRQ, 0);
+
+	if (!r0 || !r1)
+		return -ENODEV;
+
+	printk(KERN_INFO DRV_NAME " version " DRV_VERSION "\n");
+
+	/* I/O map only for the first probing timer */
+	if (!next) {
+		size = r0->end - r0->start + 1;
+		reg_base = ioremap(r0->start, size);
+		reg_ofset = reg_base - MV64340_TIMER_COUNTER0; 
+
+		out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL, 0);
+
+#ifdef CONFIG_PROC_FS
+		create_proc_read_entry("mv64x60_timers", 0, NULL, mv64x60_timer_proc_read, NULL);
+#endif
+	}
+
+	mv64x60_timer[next].func = NULL;
+	mv64x60_timer[next].func_data = NULL;
+	mv64x60_timer[next].started = 0;
+	mv64x60_timer[next].periodic = 0;
+	mv64x60_timer[next].period = 0;
+	mv64x60_timer_irq[next] = r1->start;
+
+	temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL);
+	temp |= (MV64X60_TC_MODE << (next * 8));
+	out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_CONTROL, temp);
+
+	temp = in_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_MASK);
+	temp |= (1 << next);
+	out_le32(reg_ofset + MV64340_TIMER_COUNTER_0_3_INTERRUPT_MASK, temp);
+
+	if(request_irq(mv64x60_timer_irq[next], mv64x60_timer_int_handler, (IRQF_DISABLED|IRQF_SHARED), "MV64x60_Timer", &mv64x60_timer[next])) {
+		printk("can't register irq: %d.\n", mv64x60_timer_irq[next] );
+		return (-EIO);
+	}
+
+	next++;
+
+	return 0;
+}
+
+static int __devexit
+mv64xxx_timer_remove(struct platform_device *dev)
+{
+	int i;
+
+	for(i = 0; i <= 3; i++) {
+		mv64x60_timer_stop(i);
+		free_irq(mv64x60_timer_irq[i], &mv64x60_timer[i]);
+	}
+
+	return 0;
+}
+
+static struct platform_driver mv64xxx_timer_driver = {
+	.probe	= mv64xxx_timer_probe,
+	.remove	= mv64xxx_timer_remove,
+	.driver	= {
+		.owner	= THIS_MODULE,
+		.name	= "MV64X60-Timer",
+	},
+};
+
+static int __init
+mv64xxx_timer_init(void)
+{
+	return(platform_driver_register(&mv64xxx_timer_driver));
+}
+
+static void __exit mv64xxx_timer_exit(void)
+{
+	platform_driver_unregister(&mv64xxx_timer_driver);
+}
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Majid Khan M Z <amm117@motorola.com>");
+MODULE_DESCRIPTION("Marvell(MV64x60) timer driver");
+
+module_init(mv64xxx_timer_init);
+module_exit(mv64xxx_timer_exit);
+
diff --git a/drivers/misc/mv64460_timer.h b/drivers/misc/mv64460_timer.h
new file mode 100644
index 0000000..0c54b10
--- /dev/null
+++ b/drivers/misc/mv64460_timer.h
@@ -0,0 +1,27 @@
+/*
+ * drivers/misc/mv64460_timer.h
+ * programmable marvell timers API.
+ *
+ * Author:  Majid Khan M Z, (amm117@motorola.com).
+ * Copyright 
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+
+#ifndef MV64x60_TIMER_H
+#define MV64x60_TIMER_H
+
+typedef void(*mv64x60_timer_f) (void *data);
+
+/* start timer function, func will get called after timer interrupt and its called from interrupt context*/
+int mv64x60_timer_start(int timer_number, unsigned long microseconds, mv64x60_timer_f func, void *data, int periodic);
+
+/* stop a timer*/
+int mv64x60_timer_stop(int timer_number);
+
+#endif /*MV64x60_TIMER_H*/
-- 
1.6.0.3

