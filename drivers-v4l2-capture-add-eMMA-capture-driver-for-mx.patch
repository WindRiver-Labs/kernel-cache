From ef2f76389c993cc7b0cfa7dae25976902efb9744 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Thu, 4 Feb 2010 19:11:22 +0800
Subject: [PATCH] drivers/v4l2/capture: add eMMA capture driver for mx27 platforms

On mx27 platforms, the multimedia accelerator is eMMA rather IPU.
So add eMMA capture drivers.

Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 drivers/media/video/Makefile                       |    1 +
 drivers/media/video/mxc/capture/Kconfig            |    6 +
 drivers/media/video/mxc/capture/Makefile           |    5 +
 .../media/video/mxc/capture/emma_v4l2_capture.c    | 2079 ++++++++++++++++++++
 drivers/media/video/mxc/capture/mx27_csi.c         |  315 +++
 drivers/media/video/mxc/capture/mx27_csi.h         |  167 ++
 drivers/media/video/mxc/capture/mx27_prp.h         |  310 +++
 drivers/media/video/mxc/capture/mx27_prphw.c       | 1099 +++++++++++
 drivers/media/video/mxc/capture/mx27_prpsw.c       | 1014 ++++++++++
 9 files changed, 4996 insertions(+), 0 deletions(-)
 create mode 100644 drivers/media/video/mxc/capture/emma_v4l2_capture.c
 create mode 100644 drivers/media/video/mxc/capture/mx27_csi.c
 create mode 100644 drivers/media/video/mxc/capture/mx27_csi.h
 create mode 100644 drivers/media/video/mxc/capture/mx27_prp.h
 create mode 100644 drivers/media/video/mxc/capture/mx27_prphw.c
 create mode 100644 drivers/media/video/mxc/capture/mx27_prpsw.c

diff --git a/drivers/media/video/Makefile b/drivers/media/video/Makefile
index 64c1a72..d8ec1f9 100644
--- a/drivers/media/video/Makefile
+++ b/drivers/media/video/Makefile
@@ -66,6 +66,7 @@ obj-$(CONFIG_VIDEO_MXC_IPU_OUTPUT) += mxc/output/
 obj-$(CONFIG_VIDEO_CPIA) += cpia.o
 obj-$(CONFIG_VIDEO_CPIA_PP) += cpia_pp.o
 obj-$(CONFIG_VIDEO_CPIA_USB) += cpia_usb.o
+obj-$(CONFIG_VIDEO_MXC_EMMA_CAMERA) += mxc/capture/
 obj-$(CONFIG_VIDEO_MEYE) += meye.o
 obj-$(CONFIG_VIDEO_SAA7134) += saa7134/
 obj-$(CONFIG_VIDEO_CX88) += cx88/
diff --git a/drivers/media/video/mxc/capture/Kconfig b/drivers/media/video/mxc/capture/Kconfig
index e9faafc..5cfab43 100644
--- a/drivers/media/video/mxc/capture/Kconfig
+++ b/drivers/media/video/mxc/capture/Kconfig
@@ -38,6 +38,12 @@ config MXC_IPU_PRP_ENC
 		Preprocessing image from smart sensor for encoder.
 		CSI -> IC (PRP ENC) -> MEM
 
+config VIDEO_MXC_EMMA_CAMERA
+	tristate "MX27 eMMA support"
+	depends on VIDEO_MXC_CAMERA && MACH_MX27
+	select VIDEO_MXC_OPL
+	default y
+
 endmenu
 
 endif
diff --git a/drivers/media/video/mxc/capture/Makefile b/drivers/media/video/mxc/capture/Makefile
index ec4ab28..de2c8ba 100644
--- a/drivers/media/video/mxc/capture/Makefile
+++ b/drivers/media/video/mxc/capture/Makefile
@@ -1,3 +1,8 @@
+ifeq ($(CONFIG_VIDEO_MXC_EMMA_CAMERA),y)
+	mx27_capture-objs := mx27_prphw.o mx27_prpsw.o emma_v4l2_capture.o
+	obj-$(CONFIG_VIDEO_MXC_EMMA_CAMERA) += mx27_csi.o mx27_capture.o
+endif
+
 ifeq ($(CONFIG_VIDEO_MXC_IPU_CAMERA),y)
 	obj-$(CONFIG_VIDEO_MXC_CAMERA) += mxc_v4l2_capture.o
 	obj-$(CONFIG_MXC_IPU_PRP_VF_ADC) += ipu_prp_vf_adc.o
diff --git a/drivers/media/video/mxc/capture/emma_v4l2_capture.c b/drivers/media/video/mxc/capture/emma_v4l2_capture.c
new file mode 100644
index 0000000..96a4990
--- /dev/null
+++ b/drivers/media/video/mxc/capture/emma_v4l2_capture.c
@@ -0,0 +1,2079 @@
+/*
+ * Copyright 2004-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_v4l2_capture.c
+ *
+ * @brief MX27 Video For Linux 2 driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/pagemap.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/semaphore.h>
+#include <linux/version.h>
+#include <media/v4l2-dev.h>
+#include <media/v4l2-ioctl.h>
+#include <mach/imx_cam.h>
+
+#include "mxc_v4l2_capture.h"
+#include "mx27_prp.h"
+#include "mx27_csi.h"
+
+static int csi_mclk_flag_backup;
+static int video_nr = -1;
+static cam_data *g_cam;
+
+/*!
+ * Free frame buffers
+ *
+ * @param cam      Structure cam_data *
+ *
+ * @return status  0 success.
+ */
+static int mxc_free_frame_buf(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < FRAME_NUM; i++) {
+		if (cam->frame[i].vaddress != 0) {
+			dma_free_coherent(0,
+					  cam->frame[i].buffer.length,
+					  cam->frame[i].vaddress,
+					  cam->frame[i].paddress);
+			cam->frame[i].vaddress = 0;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * Allocate frame buffers
+ *
+ * @param cam      Structure cam_data *
+ *
+ * @param count    int number of buffer need to allocated
+ *
+ * @return status  -0 Successfully allocated a buffer, -ENOBUFS	failed.
+ */
+static int mxc_allocate_frame_buf(cam_data *cam, int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		cam->frame[i].vaddress =
+			dma_alloc_coherent(0,
+					PAGE_ALIGN(cam->v2f. fmt.pix.sizeimage),
+					   &cam->frame[i].paddress,
+					   GFP_DMA | GFP_KERNEL);
+		if (cam->frame[i].vaddress == 0) {
+			pr_debug("mxc_allocate_frame_buf failed.\n");
+			mxc_free_frame_buf(cam);
+			return -ENOBUFS;
+		}
+		cam->frame[i].buffer.index = i;
+		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
+		cam->frame[i].buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+		cam->frame[i].buffer.length =
+		    PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage);
+		cam->frame[i].buffer.memory = V4L2_MEMORY_MMAP;
+		cam->frame[i].buffer.m.offset = cam->frame[i].paddress;
+		cam->frame[i].index = i;
+	}
+
+	return 0;
+}
+
+/*!
+ * Free frame buffers status
+ *
+ * @param cam    Structure cam_data *
+ *
+ * @return none
+ */
+static void mxc_free_frames(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < FRAME_NUM; i++)
+		cam->frame[i].buffer.flags = V4L2_BUF_FLAG_MAPPED;
+
+	cam->enc_counter = 0;
+	cam->skip_frame = 0;
+	INIT_LIST_HEAD(&cam->ready_q);
+	INIT_LIST_HEAD(&cam->working_q);
+	INIT_LIST_HEAD(&cam->done_q);
+}
+
+/*!
+ * Return the buffer status
+ *
+ * @param cam 	   Structure cam_data *
+ * @param buf      Structure v4l2_buffer *
+ *
+ * @return status  0 success, EINVAL failed.
+ */
+static int mxc_v4l2_buffer_status(cam_data *cam, struct v4l2_buffer *buf)
+{
+	/* check range */
+	if (buf->index < 0 || buf->index >= FRAME_NUM) {
+		pr_debug("mxc_v4l2_buffer_status buffers not allocated\n");
+		return -EINVAL;
+	}
+
+	memcpy(buf, &(cam->frame[buf->index].buffer), sizeof(*buf));
+	return 0;
+}
+
+/*!
+ * start the encoder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_streamon(cam_data *cam)
+{
+	struct mxc_v4l_frame *frame;
+	int err = 0;
+
+	if (!cam)
+		return -EIO;
+
+	if (list_empty(&cam->ready_q)) {
+		printk(KERN_ERR "mxc_streamon buffer not been queued yet\n");
+		return -EINVAL;
+	}
+
+	cam->capture_pid = current->pid;
+
+	if (cam->enc_enable) {
+		err = cam->enc_enable(cam);
+		if (err != 0)
+			return err;
+	}
+
+	cam->ping_pong_csi = 0;
+	if (cam->enc_update_eba) {
+		frame =
+		    list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&frame->queue, &cam->working_q);
+		err = cam->enc_update_eba(frame->paddress, &cam->ping_pong_csi);
+
+		frame =
+		    list_entry(cam->ready_q.next, struct mxc_v4l_frame, queue);
+		list_del(cam->ready_q.next);
+		list_add_tail(&frame->queue, &cam->working_q);
+		err |=
+		    cam->enc_update_eba(frame->paddress, &cam->ping_pong_csi);
+	} else {
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+/*!
+ * Shut down the encoder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int mxc_streamoff(cam_data *cam)
+{
+	int err = 0;
+
+	if (!cam)
+		return -EIO;
+
+	if (cam->enc_disable)
+		err = cam->enc_disable(cam);
+
+	mxc_free_frames(cam);
+	return err;
+}
+
+/*!
+ * Valid whether the palette is supported
+ *
+ * @param palette pixel format
+ *
+ * @return 0 if failed
+ */
+static inline int valid_mode(u32 palette)
+{
+	/*
+	 * MX27 PrP channel 2 supports YUV444, but YUV444 is not
+	 * defined by V4L2 :(
+	 */
+	return (palette == V4L2_PIX_FMT_YUYV) ||
+		(palette == V4L2_PIX_FMT_YUV420);
+}
+
+/*!
+ * Valid and adjust the overlay window size, position
+ *
+ * @param cam      structure cam_data *
+ * @param win      struct v4l2_window  *
+ *
+ * @return 0
+ */
+static int verify_preview(cam_data *cam, struct v4l2_window *win)
+{
+	if (cam->output >= num_registered_fb) {
+		pr_debug("verify_preview No matched.\n");
+		return -1;
+	}
+	cam->overlay_fb = (struct fb_info *)registered_fb[cam->output];
+
+	/* TODO: suppose 16bpp, 4 bytes alignment */
+	win->w.left &= ~0x1;
+
+	if (win->w.width + win->w.left > cam->overlay_fb->var.xres)
+		win->w.width = cam->overlay_fb->var.xres - win->w.left;
+	if (win->w.height + win->w.top > cam->overlay_fb->var.yres)
+		win->w.height = cam->overlay_fb->var.yres - win->w.top;
+
+	/*
+	 * TODO: suppose 16bpp. Rounded down to a multiple of 2 pixels for
+	 * width according to PrP limitations.
+	 */
+	if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT))
+		win->w.height &= ~0x1;
+	else
+		win->w.width &= ~0x1;
+
+	return 0;
+}
+
+/*!
+ * start the viewfinder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int start_preview(cam_data *cam)
+{
+	int err = 0;
+
+	err = prp_vf_select(cam);
+	if (err != 0)
+		return err;
+
+	cam->overlay_pid = current->pid;
+	err = cam->vf_start_sdc(cam);
+
+	return err;
+}
+
+/*!
+ * shut down the viewfinder job
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static int stop_preview(cam_data *cam)
+{
+	int err = 0;
+
+	err = prp_vf_deselect(cam);
+	return err;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_g_fmt function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param f           structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_g_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	int retval = 0;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		f->fmt.pix.width = cam->v2f.fmt.pix.width;
+		f->fmt.pix.height = cam->v2f.fmt.pix.height;
+		f->fmt.pix.sizeimage = cam->v2f.fmt.pix.sizeimage;
+		f->fmt.pix.pixelformat = cam->v2f.fmt.pix.pixelformat;
+		f->fmt.pix.bytesperline = cam->v2f.fmt.pix.bytesperline;
+		f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
+		retval = 0;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		f->fmt.win = cam->win;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_s_fmt function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param f           structure v4l2_format *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_s_fmt(cam_data *cam, struct v4l2_format *f)
+{
+	int retval = 0;
+	int size = 0;
+	int bytesperline = 0;
+
+	switch (f->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (!valid_mode(f->fmt.pix.pixelformat)) {
+			pr_debug("mxc_v4l2_s_fmt: format not supported\n");
+			retval = -EINVAL;
+		}
+
+		if (cam->rotation != V4L2_MXC_ROTATE_NONE)
+			pr_debug("mxc_v4l2_s_fmt: capture rotation ignored\n");
+
+		switch (f->fmt.pix.pixelformat) {
+		case V4L2_PIX_FMT_YUYV:
+			f->fmt.pix.width &= ~0x1;	/* Multiple of 2 */
+			size = f->fmt.pix.width * f->fmt.pix.height * 2;
+			bytesperline = f->fmt.pix.width * 2;
+			break;
+		case V4L2_PIX_FMT_YUV420:
+			f->fmt.pix.width &= ~0x7;	/* Multiple of 8 */
+			f->fmt.pix.height &= ~0x1;	/* Multiple of 2 */
+			size = f->fmt.pix.width * f->fmt.pix.height * 3 / 2;
+			bytesperline = f->fmt.pix.width * 3 / 2;
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		if (f->fmt.pix.bytesperline < bytesperline)
+			f->fmt.pix.bytesperline = bytesperline;
+		else
+			bytesperline = f->fmt.pix.bytesperline;
+
+		if (f->fmt.pix.sizeimage > size) {
+			pr_debug("mxc_v4l2_s_fmt: sizeimage bigger than"
+				 " needed.\n");
+			size = f->fmt.pix.sizeimage;
+		}
+		f->fmt.pix.sizeimage = size;
+
+		cam->v2f.fmt.pix.sizeimage = size;
+		cam->v2f.fmt.pix.bytesperline = bytesperline;
+		cam->v2f.fmt.pix.width = f->fmt.pix.width;
+		cam->v2f.fmt.pix.height = f->fmt.pix.height;
+		cam->v2f.fmt.pix.pixelformat = f->fmt.pix.pixelformat;
+		retval = 0;
+		break;
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		retval = verify_preview(cam, &f->fmt.win);
+		cam->win = f->fmt.win;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*!
+ * get control param
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_get_v42l_control(cam_data *cam, struct v4l2_control *c)
+{
+	int status = 0;
+
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_VFLIP:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_MXC_ROT:
+		c->value = cam->rotation;
+		break;
+	case V4L2_CID_BRIGHTNESS:
+		c->value = cam->bright;
+		break;
+	case V4L2_CID_HUE:
+		c->value = cam->hue;
+		break;
+	case V4L2_CID_CONTRAST:
+		c->value = cam->contrast;
+		break;
+	case V4L2_CID_SATURATION:
+		c->value = cam->saturation;
+		break;
+	case V4L2_CID_RED_BALANCE:
+		c->value = cam->red;
+		break;
+	case V4L2_CID_BLUE_BALANCE:
+		c->value = cam->blue;
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		c->value = cam->ae_mode;
+		break;
+	default:
+		status = -EINVAL;
+	}
+	return status;
+}
+
+/*!
+ * V4L2 - set_control function
+ * V4L2_CID_MXC_ROT is the extention for rotation/mirroring.
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param c           structure v4l2_control *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_set_v42l_control(cam_data *cam, struct v4l2_control *c)
+{
+	switch (c->id) {
+	case V4L2_CID_HFLIP:
+		if (c->value == 1) {
+			if ((cam->rotation != V4L2_MXC_ROTATE_VERT_FLIP) &&
+			    (cam->rotation != V4L2_MXC_ROTATE_180))
+				cam->rotation = V4L2_MXC_ROTATE_HORIZ_FLIP;
+			else
+				cam->rotation = V4L2_MXC_ROTATE_180;
+		} else {
+			if (cam->rotation == V4L2_MXC_ROTATE_HORIZ_FLIP)
+				cam->rotation = V4L2_MXC_ROTATE_NONE;
+			else if (cam->rotation == V4L2_MXC_ROTATE_180)
+				cam->rotation = V4L2_MXC_ROTATE_VERT_FLIP;
+		}
+		break;
+	case V4L2_CID_VFLIP:
+		if (c->value == 1) {
+			if ((cam->rotation != V4L2_MXC_ROTATE_HORIZ_FLIP) &&
+			    (cam->rotation != V4L2_MXC_ROTATE_180))
+				cam->rotation = V4L2_MXC_ROTATE_VERT_FLIP;
+			else
+				cam->rotation = V4L2_MXC_ROTATE_180;
+		} else {
+			if (cam->rotation == V4L2_MXC_ROTATE_VERT_FLIP)
+				cam->rotation = V4L2_MXC_ROTATE_NONE;
+			if (cam->rotation == V4L2_MXC_ROTATE_180)
+				cam->rotation = V4L2_MXC_ROTATE_HORIZ_FLIP;
+		}
+		break;
+	case V4L2_CID_MXC_ROT:
+		switch (c->value) {
+		case V4L2_MXC_ROTATE_NONE:
+		case V4L2_MXC_ROTATE_VERT_FLIP:
+		case V4L2_MXC_ROTATE_HORIZ_FLIP:
+		case V4L2_MXC_ROTATE_180:
+		case V4L2_MXC_ROTATE_90_RIGHT:
+		case V4L2_MXC_ROTATE_90_RIGHT_VFLIP:
+		case V4L2_MXC_ROTATE_90_RIGHT_HFLIP:
+		case V4L2_MXC_ROTATE_90_LEFT:
+			cam->rotation = c->value;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_HUE:
+		cam->hue = c->value;
+		break;
+	case V4L2_CID_CONTRAST:
+		cam->contrast = c->value;
+		break;
+	case V4L2_CID_BRIGHTNESS:
+		cam->bright = c->value;
+	case V4L2_CID_SATURATION:
+		cam->saturation = c->value;
+	case V4L2_CID_RED_BALANCE:
+		cam->red = c->value;
+	case V4L2_CID_BLUE_BALANCE:
+		cam->blue = c->value;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		cam->cam_sensor->set_color(cam->bright, cam->saturation,
+					   cam->red, cam->green, cam->blue);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_BLACK_LEVEL:
+		cam->ae_mode = c->value & 0x03;
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		if (cam->cam_sensor->set_ae_mode)
+			cam->cam_sensor->set_ae_mode(cam->ae_mode);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		break;
+	case V4L2_CID_MXC_FLASH:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*!
+ * V4L2 - mxc_v4l2_s_param function
+ *
+ * @param cam         structure cam_data *
+ *
+ * @param parm        structure v4l2_streamparm *
+ *
+ * @return  status    0 success, EINVAL failed
+ */
+static int mxc_v4l2_s_param(cam_data *cam, struct v4l2_streamparm *parm)
+{
+	sensor_interface *param;
+	csi_signal_cfg_t csi_param;
+
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+		pr_debug("mxc_v4l2_s_param invalid type\n");
+		return -EINVAL;
+	}
+
+	if (parm->parm.capture.timeperframe.denominator >
+	    cam->standard.frameperiod.denominator) {
+		pr_debug("mxc_v4l2_s_param frame rate %d larger "
+			 "than standard supported %d\n",
+			 parm->parm.capture.timeperframe.denominator,
+			 cam->standard.frameperiod.denominator);
+		return -EINVAL;
+	}
+
+	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+
+	csi_enable_mclk(CSI_MCLK_I2C, true, true);
+	param = cam->cam_sensor->config
+	    (&parm->parm.capture.timeperframe.denominator,
+	     parm->parm.capture.capturemode);
+	csi_enable_mclk(CSI_MCLK_I2C, false, false);
+
+	cam->streamparm.parm.capture.timeperframe =
+	    parm->parm.capture.timeperframe;
+
+	if ((parm->parm.capture.capturemode != 0) &&
+	    (parm->parm.capture.capturemode != V4L2_MODE_HIGHQUALITY)) {
+		pr_debug("mxc_v4l2_s_param frame un-supported capture mode\n");
+		return -EINVAL;
+	}
+
+	if (parm->parm.capture.capturemode ==
+	    cam->streamparm.parm.capture.capturemode) {
+		return 0;
+	}
+
+	/* resolution changed, so need to re-program the CSI */
+	csi_param.sens_clksrc = 0;
+	csi_param.clk_mode = param->clk_mode;
+	csi_param.pixclk_pol = param->pixclk_pol;
+	csi_param.data_width = param->data_width;
+	csi_param.data_pol = param->data_pol;
+	csi_param.ext_vsync = param->ext_vsync;
+	csi_param.Vsync_pol = param->Vsync_pol;
+	csi_param.Hsync_pol = param->Hsync_pol;
+	csi_init_interface(param->width, param->height, param->pixel_fmt,
+			   csi_param);
+
+	if (parm->parm.capture.capturemode != V4L2_MODE_HIGHQUALITY) {
+		cam->streamparm.parm.capture.capturemode = 0;
+	} else {
+		cam->streamparm.parm.capture.capturemode =
+		    V4L2_MODE_HIGHQUALITY;
+		cam->streamparm.parm.capture.extendedmode =
+		    parm->parm.capture.extendedmode;
+		cam->streamparm.parm.capture.readbuffers = 1;
+	}
+	return 0;
+}
+
+/*!
+ * Dequeue one V4L capture buffer
+ *
+ * @param cam         structure cam_data *
+ * @param buf         structure v4l2_buffer *
+ *
+ * @return  status    0 success, EINVAL invalid frame number,
+ *                    ETIME timeout, ERESTARTSYS interrupted by user
+ */
+static int mxc_v4l_dqueue(cam_data *cam, struct v4l2_buffer *buf)
+{
+	int retval = 0;
+	struct mxc_v4l_frame *frame;
+
+	if (!wait_event_interruptible_timeout(cam->enc_queue,
+					      cam->enc_counter != 0, 10 * HZ)) {
+		printk(KERN_ERR "mxc_v4l_dqueue timeout enc_counter %x\n",
+		       cam->enc_counter);
+		return -ETIME;
+	} else if (signal_pending(current)) {
+		printk(KERN_ERR "mxc_v4l_dqueue() interrupt received\n");
+		return -ERESTARTSYS;
+	}
+
+	cam->enc_counter--;
+
+	frame = list_entry(cam->done_q.next, struct mxc_v4l_frame, queue);
+	list_del(cam->done_q.next);
+	if (frame->buffer.flags & V4L2_BUF_FLAG_DONE) {
+		frame->buffer.flags &= ~V4L2_BUF_FLAG_DONE;
+	} else if (frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+		printk(KERN_ERR "VIDIOC_DQBUF: Buffer not filled.\n");
+		frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+		retval = -EINVAL;
+	} else if ((frame->buffer.flags & 0x7) == V4L2_BUF_FLAG_MAPPED) {
+		printk(KERN_ERR "VIDIOC_DQBUF: Buffer not queued.\n");
+		retval = -EINVAL;
+	}
+
+	buf->bytesused = cam->v2f.fmt.pix.sizeimage;
+	buf->index = frame->index;
+	buf->flags = frame->buffer.flags;
+
+	return retval;
+}
+
+/*!
+ * V4L interface - open function
+ *
+ * @param inode        structure inode *
+ * @param file         structure file *
+ *
+ * @return  status    0 success, ENODEV invalid device instance,
+ *                    ENODEV timeout, ERESTARTSYS interrupted by user
+ */
+static int mxc_v4l_open(struct inode *inode, struct file *file)
+{
+	sensor_interface *param;
+	csi_signal_cfg_t csi_param;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = video_get_drvdata(dev);
+	int err = 0;
+
+	if (!cam) {
+		pr_info("Internal error, cam_data not found!\n");
+		return -ENODEV;
+	}
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	if (signal_pending(current))
+		goto oops;
+
+	if (cam->open_count++ == 0) {
+		wait_event_interruptible(cam->power_queue,
+					 cam->low_power == false);
+
+		err = prp_enc_select(cam);
+
+		cam->enc_counter = 0;
+		cam->skip_frame = 0;
+		INIT_LIST_HEAD(&cam->ready_q);
+		INIT_LIST_HEAD(&cam->working_q);
+		INIT_LIST_HEAD(&cam->done_q);
+
+		csi_enable_mclk(CSI_MCLK_I2C, true, true);
+		param = cam->cam_sensor->reset();
+		if (param == NULL) {
+			cam->open_count--;
+			csi_enable_mclk(CSI_MCLK_I2C, false, false);
+			err = -ENODEV;
+			goto oops;
+		}
+		csi_param.sens_clksrc = 0;
+		csi_param.clk_mode = param->clk_mode;
+		csi_param.pixclk_pol = param->pixclk_pol;
+		csi_param.data_width = param->data_width;
+		csi_param.data_pol = param->data_pol;
+		csi_param.ext_vsync = param->ext_vsync;
+		csi_param.Vsync_pol = param->Vsync_pol;
+		csi_param.Hsync_pol = param->Hsync_pol;
+		csi_init_interface(param->width, param->height,
+				   param->pixel_fmt, csi_param);
+		cam->cam_sensor->get_color(&cam->bright, &cam->saturation,
+					   &cam->red, &cam->green, &cam->blue);
+		if (cam->cam_sensor->get_ae_mode)
+			cam->cam_sensor->get_ae_mode(&cam->ae_mode);
+		csi_enable_mclk(CSI_MCLK_I2C, false, false);
+		prp_init(cam);
+
+	}
+
+	file->private_data = dev;
+oops:
+	up(&cam->busy_lock);
+	return err;
+}
+
+/*!
+ * V4L interface - close function
+ *
+ * @param inode    struct inode *
+ * @param file     struct file *
+ *
+ * @return         0 success
+ */
+static int mxc_v4l_close(struct inode *inode, struct file *file)
+{
+	struct video_device *dev = video_devdata(file);
+	int err = 0;
+	cam_data *cam = video_get_drvdata(dev);
+
+	/* for the case somebody hit the ctrl C */
+	if (cam->overlay_pid == current->pid) {
+		err = stop_preview(cam);
+		cam->overlay_on = false;
+	}
+	if (cam->capture_pid == current->pid) {
+		err |= mxc_streamoff(cam);
+		cam->capture_on = false;
+		wake_up_interruptible(&cam->enc_queue);
+	}
+
+	if (--cam->open_count == 0) {
+		wait_event_interruptible(cam->power_queue,
+					 cam->low_power == false);
+		pr_debug("mxc_v4l_close: release resource\n");
+
+		err |= prp_enc_deselect(cam);
+
+		mxc_free_frame_buf(cam);
+		file->private_data = NULL;
+
+		/* capture off */
+		wake_up_interruptible(&cam->enc_queue);
+		mxc_free_frames(cam);
+		cam->enc_counter++;
+		prp_exit(cam);
+	}
+
+	return err;
+}
+
+#ifdef CONFIG_VIDEO_MXC_CSI_DMA
+#include <mach/dma.h>
+
+#define CSI_DMA_STATUS_IDLE	0	/* DMA is not started */
+#define CSI_DMA_STATUS_WORKING	1	/* DMA is transfering the data */
+#define CSI_DMA_STATUS_DONE	2	/* One frame completes successfully */
+#define CSI_DMA_STATUS_ERROR	3	/* Error occurs during the DMA */
+
+/*
+ * Sometimes the start of the DMA is not synchronized with the CSI
+ * SOF (Start of Frame) interrupt which will lead to incorrect
+ * captured image. In this case the driver will re-try capturing
+ * another frame. The following macro defines the maximum re-try
+ * times.
+ */
+#define CSI_DMA_RETRY		8
+
+/*
+ * Size of the physical contiguous memory area used to hold image data
+ * transfered by DMA. It can be less than the size of the image data.
+ */
+#define CSI_MEM_SIZE		(1024 * 600)
+
+/* Number of bytes for one DMA transfer */
+#define CSI_DMA_LENGTH		(1024 * 200)
+
+static int g_dma_channel;
+static int g_dma_status = CSI_DMA_STATUS_DONE;
+static volatile int g_dma_completed;	/* number of completed DMA transfers */
+static volatile int g_dma_copied;	/* number of copied DMA transfers */
+static struct tasklet_struct g_dma_tasklet;
+static char *g_user_buf;	/* represents the buf passed by read() */
+static int g_user_count;	/* represents the count passed by read() */
+
+/*!
+ * @brief setup the DMA to transfer data
+ *	  There may be more than one DMA to transfer the whole image. Those
+ *	  DMAs work like chain. This function is used to setup the DMA in
+ *	  case there is enough space to hold the data.
+ * @param	data	pointer to the cam structure
+ */
+static void mxc_csi_dma_chaining(void *data)
+{
+	cam_data *cam = (cam_data *) data;
+	int count, chained = 0;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+	mxc_dma_requestbuf_t dma_request;
+
+	while (chained * CSI_DMA_LENGTH < g_user_count) {
+		/*
+		 * Calculate how many bytes the DMA should transfer. It may
+		 * be less than CSI_DMA_LENGTH if the DMA is the last one.
+		 */
+		if ((chained + 1) * CSI_DMA_LENGTH > g_user_count)
+			count = g_user_count - chained * CSI_DMA_LENGTH;
+		else
+			count = CSI_DMA_LENGTH;
+		pr_debug("%s() DMA chained count = %d\n", __func__, count);
+
+		/* Config DMA */
+		memset(&dma_request, 0, sizeof(mxc_dma_requestbuf_t));
+		dma_request.dst_addr = cam->still_buf
+		    + (chained % max_dma) * CSI_DMA_LENGTH;
+		dma_request.src_addr = (dma_addr_t) CSI_CSIRXFIFO_PHYADDR;
+		dma_request.num_of_bytes = count;
+		mxc_dma_config(g_dma_channel, &dma_request, 1,
+			       MXC_DMA_MODE_READ);
+
+		chained++;
+	}
+}
+
+/*!
+ * @brief Copy image data from physical contiguous memory to user space buffer
+ *	  Once the data are copied, there will be more spare space in the
+ *	  physical contiguous memory to receive data from DMA.
+ * @param	data	pointer to the cam structure
+ */
+static void mxc_csi_dma_task(unsigned long data)
+{
+	cam_data *cam = (cam_data *) data;
+	int count;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+
+	while (g_dma_copied < g_dma_completed) {
+		/*
+		 * Calculate how many bytes the DMA has transfered. It may
+		 * be less than CSI_DMA_LENGTH if the DMA is the last one.
+		 */
+		if ((g_dma_copied + 1) * CSI_DMA_LENGTH > g_user_count)
+			count = g_user_count - g_dma_copied * CSI_DMA_LENGTH;
+		else
+			count = CSI_DMA_LENGTH;
+		if (copy_to_user(g_user_buf + g_dma_copied * CSI_DMA_LENGTH,
+				 cam->still_buf_vaddr + (g_dma_copied % max_dma)
+				 * CSI_DMA_LENGTH, count))
+			pr_debug("Warning: some bytes not copied\n");
+
+		g_dma_copied++;
+	}
+
+	/* If the whole image has been captured */
+	if (g_dma_copied * CSI_DMA_LENGTH >= g_user_count) {
+		cam->still_counter++;
+		wake_up_interruptible(&cam->still_queue);
+	}
+
+	pr_debug("%s() DMA completed = %d copied = %d\n",
+		 __func__, g_dma_completed, g_dma_copied);
+}
+
+/*!
+ * @brief DMA interrupt callback function
+ * @param	data	pointer to the cam structure
+ * @param	error	DMA error flag
+ * @param	count	number of bytes transfered by the DMA
+ */
+static void mxc_csi_dma_callback(void *data, int error, unsigned int count)
+{
+	cam_data *cam = (cam_data *) data;
+	int max_dma = CSI_MEM_SIZE / CSI_DMA_LENGTH;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&cam->int_lock, lock_flags);
+
+	g_dma_completed++;
+
+	if (error != MXC_DMA_DONE) {
+		g_dma_status = CSI_DMA_STATUS_ERROR;
+		pr_debug("%s() DMA error\n", __func__);
+	}
+
+	/* If the whole image has been captured */
+	if ((g_dma_status != CSI_DMA_STATUS_ERROR)
+	    && (g_dma_completed * CSI_DMA_LENGTH >= g_user_count))
+		g_dma_status = CSI_DMA_STATUS_DONE;
+
+	if ((g_dma_status == CSI_DMA_STATUS_WORKING) &&
+	    (g_dma_completed >= g_dma_copied + max_dma)) {
+		g_dma_status = CSI_DMA_STATUS_ERROR;
+		pr_debug("%s() Previous buffer over written\n", __func__);
+	}
+
+	/* Schedule the tasklet */
+	tasklet_schedule(&g_dma_tasklet);
+
+	spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+
+	pr_debug("%s() count = %d bytes\n", __func__, count);
+}
+
+/*!
+ * @brief CSI interrupt callback function
+ * @param	data	pointer to the cam structure
+ * @param	status	CSI interrupt status
+ */
+static void mxc_csi_irq_callback(void *data, unsigned long status)
+{
+	cam_data *cam = (cam_data *) data;
+	unsigned long lock_flags;
+
+	spin_lock_irqsave(&cam->int_lock, lock_flags);
+
+	/* Wait for SOF (Start of Frame) interrupt to sync the image */
+	if (status & BIT_SOF_INT) {
+		if (g_dma_status == CSI_DMA_STATUS_IDLE) {
+			/* Start DMA transfer to capture image */
+			mxc_dma_enable(g_dma_channel);
+			g_dma_status = CSI_DMA_STATUS_WORKING;
+			pr_debug("%s() DMA started.\n", __func__);
+		} else if (g_dma_status == CSI_DMA_STATUS_WORKING) {
+			/*
+			 * Another SOF occurs during DMA transfer. In this
+			 * case the image is not synchronized so need to
+			 * report error and probably try again.
+			 */
+			g_dma_status = CSI_DMA_STATUS_ERROR;
+			pr_debug("%s() Image is not synchronized with DMA - "
+				 "SOF before DMA completes\n", __func__);
+		}
+	}
+
+	spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+
+	pr_debug("%s() g_dma_status = %d\n", __func__, g_dma_status);
+}
+
+/*!
+ * V4L interface - read function
+ *
+ * @param file       struct file *
+ * @param read buf   char *
+ * @param count      size_t
+ * @param ppos       structure loff_t *
+ *
+ * @return           bytes read
+ */
+static ssize_t
+mxc_v4l_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	int err = 0;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = video_get_drvdata(dev);
+	int retry = CSI_DMA_RETRY;
+
+	g_user_buf = buf;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	/* Video capture and still image capture are exclusive */
+	if (cam->capture_on == true) {
+		err = -EBUSY;
+		goto exit0;
+	}
+
+	/* The CSI-DMA can not do CSC */
+	if (cam->v2f.fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) {
+		pr_info("mxc_v4l_read support YUYV pixel format only\n");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	/* The CSI-DMA can not do resize or crop */
+	if ((cam->v2f.fmt.pix.width != cam->crop_bounds.width)
+	    || (cam->v2f.fmt.pix.height != cam->crop_bounds.height)) {
+		pr_info("mxc_v4l_read resize is not supported\n");
+		pr_info("supported image size width = %d height = %d\n",
+			cam->crop_bounds.width, cam->crop_bounds.height);
+		err = -EINVAL;
+		goto exit0;
+	}
+	if ((cam->crop_current.left != cam->crop_bounds.left)
+	    || (cam->crop_current.width != cam->crop_bounds.width)
+	    || (cam->crop_current.top != cam->crop_bounds.top)
+	    || (cam->crop_current.height != cam->crop_bounds.height)) {
+		pr_info("mxc_v4l_read cropping is not supported\n");
+		err = -EINVAL;
+		goto exit0;
+	}
+
+	cam->still_buf_vaddr = dma_alloc_coherent(0,
+						  PAGE_ALIGN(CSI_MEM_SIZE),
+						  &cam->still_buf,
+						  GFP_DMA | GFP_KERNEL);
+
+	if (!cam->still_buf_vaddr) {
+		pr_info("mxc_v4l_read failed at allocate still_buf\n");
+		err = -ENOBUFS;
+		goto exit0;
+	}
+
+	/* Initialize DMA */
+	g_dma_channel = mxc_dma_request(MXC_DMA_CSI_RX, "CSI RX DMA");
+	if (g_dma_channel < 0) {
+		pr_debug("mxc_v4l_read failed to request DMA channel\n");
+		err = -EIO;
+		goto exit1;
+	}
+
+	err = mxc_dma_callback_set(g_dma_channel,
+				   (mxc_dma_callback_t) mxc_csi_dma_callback,
+				   (void *)cam);
+	if (err != 0) {
+		pr_debug("mxc_v4l_read failed to set DMA callback\n");
+		err = -EIO;
+		goto exit2;
+	}
+
+	g_user_buf = buf;
+	if (cam->v2f.fmt.pix.sizeimage < count)
+		g_user_count = cam->v2f.fmt.pix.sizeimage;
+	else
+		g_user_count = count & ~0x3;
+
+	tasklet_init(&g_dma_tasklet, mxc_csi_dma_task, (unsigned long)cam);
+	g_dma_status = CSI_DMA_STATUS_DONE;
+	csi_set_callback(mxc_csi_irq_callback, cam);
+	csi_enable_prpif(0);
+
+	/* clear current SOF first */
+	csi_clear_status(BIT_SOF_INT);
+	csi_enable_mclk(CSI_MCLK_RAW, true, true);
+
+	do {
+		g_dma_completed = g_dma_copied = 0;
+		mxc_csi_dma_chaining(cam);
+		cam->still_counter = 0;
+		g_dma_status = CSI_DMA_STATUS_IDLE;
+
+		if (!wait_event_interruptible_timeout(cam->still_queue,
+						      cam->still_counter != 0,
+						      10 * HZ)) {
+			pr_info("mxc_v4l_read timeout counter %x\n",
+				cam->still_counter);
+			err = -ETIME;
+			goto exit3;
+		}
+
+		if (g_dma_status == CSI_DMA_STATUS_DONE)
+			break;
+
+		if (retry-- == 0)
+			break;
+
+		pr_debug("Now retry image capture\n");
+	} while (1);
+
+	if (g_dma_status != CSI_DMA_STATUS_DONE)
+		err = -EIO;
+
+exit3:
+	csi_enable_prpif(1);
+	g_dma_status = CSI_DMA_STATUS_DONE;
+	csi_set_callback(0, 0);
+	csi_enable_mclk(CSI_MCLK_RAW, false, false);
+	tasklet_kill(&g_dma_tasklet);
+
+exit2:
+	mxc_dma_free(g_dma_channel);
+
+exit1:
+	dma_free_coherent(0, PAGE_ALIGN(CSI_MEM_SIZE),
+			  cam->still_buf_vaddr, cam->still_buf);
+	cam->still_buf = 0;
+
+exit0:
+	up(&cam->busy_lock);
+	if (err < 0)
+		return err;
+	else
+		return g_user_count;
+}
+#else
+/*!
+ * V4L interface - read function
+ *
+ * @param file       struct file *
+ * @param read buf   char *
+ * @param count      size_t
+ * @param ppos       structure loff_t *
+ *
+ * @return           bytes read
+ */
+static ssize_t
+mxc_v4l_read(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	int err = 0;
+	u8 *v_address;
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = video_get_drvdata(dev);
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	/* Video capture and still image capture are exclusive */
+	if (cam->capture_on == true) {
+		err = -EBUSY;
+		goto exit0;
+	}
+
+	v_address = dma_alloc_coherent(0,
+				       PAGE_ALIGN(cam->v2f.fmt.pix.sizeimage),
+				       &cam->still_buf, GFP_DMA | GFP_KERNEL);
+
+	if (!v_address) {
+		pr_info("mxc_v4l_read failed at allocate still_buf\n");
+		err = -ENOBUFS;
+		goto exit0;
+	}
+
+	if (prp_still_select(cam)) {
+		err = -EIO;
+		goto exit1;
+	}
+
+	cam->still_counter = 0;
+	if (cam->csi_start(cam)) {
+		err = -EIO;
+		goto exit2;
+	}
+
+	if (!wait_event_interruptible_timeout(cam->still_queue,
+					      cam->still_counter != 0,
+					      10 * HZ)) {
+		pr_info("mxc_v4l_read timeout counter %x\n",
+			cam->still_counter);
+		err = -ETIME;
+		goto exit2;
+	}
+	err = copy_to_user(buf, v_address, cam->v2f.fmt.pix.sizeimage);
+
+exit2:
+	prp_still_deselect(cam);
+
+exit1:
+	dma_free_coherent(0, cam->v2f.fmt.pix.sizeimage, v_address,
+			  cam->still_buf);
+	cam->still_buf = 0;
+
+exit0:
+	up(&cam->busy_lock);
+	if (err < 0)
+		return err;
+	else
+		return cam->v2f.fmt.pix.sizeimage - err;
+}
+#endif				/* CONFIG_VIDEO_MXC_CSI_DMA */
+
+/*!
+ * V4L interface - ioctl function
+ *
+ * @param inode      struct inode *
+ *
+ * @param file       struct file *
+ *
+ * @param ioctlnr    unsigned int
+ *
+ * @param arg        void *
+ *
+ * @return           0 success, ENODEV for invalid device instance,
+ *                   -1 for other errors.
+ */
+static int
+mxc_v4l_do_ioctl(struct inode *inode, struct file *file,
+		 unsigned int ioctlnr, void *arg)
+{
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = video_get_drvdata(dev);
+	int retval = 0;
+	unsigned long lock_flags;
+
+	if (!cam)
+		return -EBADF;
+
+	wait_event_interruptible(cam->power_queue, cam->low_power == false);
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&cam->busy_lock))
+		return -EBUSY;
+
+	switch (ioctlnr) {
+		/*!
+		 * V4l2 VIDIOC_QUERYCAP ioctl
+		 */
+	case VIDIOC_QUERYCAP:{
+			struct v4l2_capability *cap = arg;
+			strcpy(cap->driver, "mxc_v4l2");
+			cap->version = KERNEL_VERSION(0, 1, 11);
+			cap->capabilities = V4L2_CAP_VIDEO_CAPTURE |
+			    V4L2_CAP_VIDEO_OVERLAY | V4L2_CAP_STREAMING
+			    | V4L2_CAP_READWRITE;
+			cap->card[0] = '\0';
+			cap->bus_info[0] = '\0';
+			retval = 0;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_FMT ioctl
+		 */
+	case VIDIOC_G_FMT:{
+			struct v4l2_format *gf = arg;
+			retval = mxc_v4l2_g_fmt(cam, gf);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_FMT ioctl
+		 */
+	case VIDIOC_S_FMT:{
+			struct v4l2_format *sf = arg;
+			retval = mxc_v4l2_s_fmt(cam, sf);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_REQBUFS ioctl
+		 */
+	case VIDIOC_REQBUFS:{
+			struct v4l2_requestbuffers *req = arg;
+			if (req->count > FRAME_NUM) {
+				pr_info("VIDIOC_REQBUFS: not enough buffer\n");
+				req->count = FRAME_NUM;
+			}
+
+			if ((req->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) ||
+			    (req->memory != V4L2_MEMORY_MMAP)) {
+				pr_debug("VIDIOC_REQBUFS: wrong buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+
+			mxc_streamoff(cam);
+			mxc_free_frame_buf(cam);
+
+			retval = mxc_allocate_frame_buf(cam, req->count);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_QUERYBUF ioctl
+		 */
+	case VIDIOC_QUERYBUF:{
+			struct v4l2_buffer *buf = arg;
+			int index = buf->index;
+
+			if (buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				pr_debug
+				    ("VIDIOC_QUERYBUFS: wrong buffer type\n");
+				retval = -EINVAL;
+				break;
+			}
+
+			memset(buf, 0, sizeof(buf));
+			buf->index = index;
+
+			down(&cam->param_lock);
+			retval = mxc_v4l2_buffer_status(cam, buf);
+			up(&cam->param_lock);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_QBUF ioctl
+		 */
+	case VIDIOC_QBUF:{
+			struct v4l2_buffer *buf = arg;
+			int index = buf->index;
+
+			pr_debug("VIDIOC_QBUF: %d\n", buf->index);
+
+			spin_lock_irqsave(&cam->int_lock, lock_flags);
+			if ((cam->frame[index].buffer.flags & 0x7) ==
+			    V4L2_BUF_FLAG_MAPPED) {
+				cam->frame[index].buffer.flags |=
+				    V4L2_BUF_FLAG_QUEUED;
+				if (cam->skip_frame > 0) {
+					list_add_tail(&cam->frame[index].queue,
+						      &cam->working_q);
+					retval =
+					    cam->enc_update_eba(cam->
+								frame[index].
+								paddress,
+								&cam->
+								ping_pong_csi);
+					cam->skip_frame = 0;
+				} else {
+					list_add_tail(&cam->frame[index].queue,
+						      &cam->ready_q);
+				}
+			} else if (cam->frame[index].buffer.flags &
+				   V4L2_BUF_FLAG_QUEUED) {
+				pr_debug
+				    ("VIDIOC_QBUF: buffer already queued\n");
+			} else if (cam->frame[index].buffer.
+				   flags & V4L2_BUF_FLAG_DONE) {
+				pr_debug
+				    ("VIDIOC_QBUF: overwrite done buffer.\n");
+				cam->frame[index].buffer.flags &=
+				    ~V4L2_BUF_FLAG_DONE;
+				cam->frame[index].buffer.flags |=
+				    V4L2_BUF_FLAG_QUEUED;
+			}
+			buf->flags = cam->frame[index].buffer.flags;
+			spin_unlock_irqrestore(&cam->int_lock, lock_flags);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_DQBUF ioctl
+		 */
+	case VIDIOC_DQBUF:{
+			struct v4l2_buffer *buf = arg;
+
+			retval = mxc_v4l_dqueue(cam, buf);
+
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_STREAMON ioctl
+		 */
+	case VIDIOC_STREAMON:{
+			cam->capture_on = true;
+			retval = mxc_streamon(cam);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_STREAMOFF ioctl
+		 */
+	case VIDIOC_STREAMOFF:{
+			retval = mxc_streamoff(cam);
+			cam->capture_on = false;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_CTRL ioctl
+		 */
+	case VIDIOC_G_CTRL:{
+			retval = mxc_get_v42l_control(cam, arg);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_CTRL ioctl
+		 */
+	case VIDIOC_S_CTRL:{
+			retval = mxc_set_v42l_control(cam, arg);
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_CROPCAP ioctl
+		 */
+	case VIDIOC_CROPCAP:{
+			struct v4l2_cropcap *cap = arg;
+
+			if (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    cap->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+			cap->bounds = cam->crop_bounds;
+			cap->defrect = cam->crop_defrect;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_CROP ioctl
+		 */
+	case VIDIOC_G_CROP:{
+			struct v4l2_crop *crop = arg;
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+			crop->c = cam->crop_current;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_CROP ioctl
+		 */
+	case VIDIOC_S_CROP:{
+			struct v4l2_crop *crop = arg;
+			struct v4l2_rect *b = &cam->crop_bounds;
+			int i;
+
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+			    crop->type != V4L2_BUF_TYPE_VIDEO_OVERLAY) {
+				retval = -EINVAL;
+				break;
+			}
+
+			crop->c.top = (crop->c.top < b->top) ? b->top
+			    : crop->c.top;
+			if (crop->c.top > b->top + b->height)
+				crop->c.top = b->top + b->height - 1;
+			if (crop->c.height > b->top + b->height - crop->c.top)
+				crop->c.height =
+				    b->top + b->height - crop->c.top;
+
+			crop->c.left = (crop->c.left < b->left) ? b->left
+			    : crop->c.left;
+			if (crop->c.left > b->left + b->width)
+				crop->c.left = b->left + b->width - 1;
+			if (crop->c.width > b->left - crop->c.left + b->width)
+				crop->c.width =
+				    b->left - crop->c.left + b->width;
+
+			crop->c.width &= ~0x1;
+
+			/*
+			 * MX27 PrP limitation:
+			 * The right spare space (CSI_FRAME_X_SIZE
+			 *  - SOURCE_LINE_STRIDE - PICTURE_X_SIZE)) must be
+			 * multiple of 32.
+			 * So we tune the crop->c.left value to the closest
+			 * desired cropping value and meet the PrP requirement.
+			 */
+			i = ((b->left + b->width)
+			     - (crop->c.left + crop->c.width)) % 32;
+			if (i <= 16) {
+				if (crop->c.left + crop->c.width + i
+				    <= b->left + b->width)
+					crop->c.left += i;
+				else if (crop->c.left - (32 - i) >= b->left)
+					crop->c.left -= 32 - i;
+				else {
+					retval = -EINVAL;
+					break;
+				}
+			} else {
+				if (crop->c.left - (32 - i) >= b->left)
+					crop->c.left -= 32 - i;
+				else if (crop->c.left + crop->c.width + i
+					 <= b->left + b->width)
+					crop->c.left += i;
+				else {
+					retval = -EINVAL;
+					break;
+				}
+			}
+
+			cam->crop_current = crop->c;
+
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_OVERLAY ioctl
+		 */
+	case VIDIOC_OVERLAY:{
+			int *on = arg;
+			if (*on) {
+				cam->overlay_on = true;
+				retval = start_preview(cam);
+			}
+			if (!*on) {
+				retval = stop_preview(cam);
+				cam->overlay_on = false;
+			}
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_G_FBUF ioctl
+		 */
+	case VIDIOC_G_FBUF:{
+			struct v4l2_framebuffer *fb = arg;
+			struct fb_var_screeninfo *var;
+
+			if (cam->output >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			var = &registered_fb[cam->output]->var;
+			cam->v4l2_fb.fmt.width = var->xres;
+			cam->v4l2_fb.fmt.height = var->yres;
+			cam->v4l2_fb.fmt.bytesperline =
+			    var->xres_virtual * var->bits_per_pixel;
+			cam->v4l2_fb.fmt.colorspace = V4L2_COLORSPACE_SRGB;
+			*fb = cam->v4l2_fb;
+			break;
+		}
+
+		/*!
+		 * V4l2 VIDIOC_S_FBUF ioctl
+		 */
+	case VIDIOC_S_FBUF:{
+			struct v4l2_framebuffer *fb = arg;
+			cam->v4l2_fb.flags = fb->flags;
+			cam->v4l2_fb.fmt.pixelformat = fb->fmt.pixelformat;
+			break;
+		}
+
+	case VIDIOC_G_PARM:{
+			struct v4l2_streamparm *parm = arg;
+			if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				pr_debug("VIDIOC_G_PARM invalid type\n");
+				retval = -EINVAL;
+				break;
+			}
+			parm->parm.capture = cam->streamparm.parm.capture;
+			break;
+		}
+	case VIDIOC_S_PARM:{
+			struct v4l2_streamparm *parm = arg;
+			retval = mxc_v4l2_s_param(cam, parm);
+			break;
+		}
+
+		/* linux v4l2 bug, kernel c0485619 user c0405619 */
+	case VIDIOC_ENUMSTD:{
+			struct v4l2_standard *e = arg;
+			*e = cam->standard;
+			pr_debug("VIDIOC_ENUMSTD call\n");
+			retval = 0;
+			break;
+		}
+
+	case VIDIOC_G_STD:{
+			v4l2_std_id *e = arg;
+			*e = cam->standard.id;
+			break;
+		}
+
+	case VIDIOC_S_STD:{
+			break;
+		}
+
+	case VIDIOC_ENUMOUTPUT:
+		{
+			struct v4l2_output *output = arg;
+
+			if (output->index >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			strncpy(output->name,
+				registered_fb[output->index]->fix.id, 31);
+			output->type = V4L2_OUTPUT_TYPE_ANALOG;
+			output->audioset = 0;
+			output->modulator = 0;
+			output->std = V4L2_STD_UNKNOWN;
+
+			break;
+		}
+	case VIDIOC_G_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			*p_output_num = cam->output;
+			break;
+		}
+	case VIDIOC_S_OUTPUT:
+		{
+			int *p_output_num = arg;
+
+			if (*p_output_num >= num_registered_fb) {
+				retval = -EINVAL;
+				break;
+			}
+
+			cam->output = *p_output_num;
+			break;
+		}
+
+	case VIDIOC_ENUM_FMT:
+	case VIDIOC_TRY_FMT:
+	case VIDIOC_QUERYCTRL:
+	case VIDIOC_ENUMINPUT:
+	case VIDIOC_G_INPUT:
+	case VIDIOC_S_INPUT:
+	case VIDIOC_G_TUNER:
+	case VIDIOC_S_TUNER:
+	case VIDIOC_G_FREQUENCY:
+	case VIDIOC_S_FREQUENCY:
+	default:
+		retval = -EINVAL;
+		break;
+	}
+
+	up(&cam->busy_lock);
+	return retval;
+}
+
+/*
+ * V4L interface - ioctl function
+ *
+ * @return  None
+ */
+static int
+mxc_v4l_ioctl(struct inode *inode, struct file *file,
+	      unsigned int cmd, unsigned long arg)
+{
+	return video_usercopy(inode, file, cmd, arg, mxc_v4l_do_ioctl);
+}
+
+/*!
+ * V4L interface - mmap function
+ *
+ * @param file        structure file *
+ *
+ * @param vma         structure vm_area_struct *
+ *
+ * @return status     0 Success, EINTR busy lock error, ENOBUFS remap_page error
+ */
+static int mxc_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct video_device *dev = video_devdata(file);
+	unsigned long size;
+	int res = 0;
+	cam_data *cam = video_get_drvdata(dev);
+
+	pr_debug("pgoff=0x%lx, start=0x%lx, end=0x%lx\n",
+		 vma->vm_pgoff, vma->vm_start, vma->vm_end);
+
+	/* make this _really_ smp-safe */
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	size = vma->vm_end - vma->vm_start;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	if (remap_pfn_range(vma, vma->vm_start,
+			    vma->vm_pgoff, size, vma->vm_page_prot)) {
+		pr_debug("mxc_mmap: remap_pfn_range failed\n");
+		res = -ENOBUFS;
+		goto mxc_mmap_exit;
+	}
+
+	vma->vm_flags &= ~VM_IO;	/* using shared anonymous pages */
+
+mxc_mmap_exit:
+	up(&cam->busy_lock);
+	return res;
+}
+
+/*!
+ * V4L interface - poll function
+ *
+ * @param file       structure file *
+ *
+ * @param wait       structure poll_table *
+ *
+ * @return  status   POLLIN | POLLRDNORM
+ */
+static unsigned int mxc_poll(struct file *file, poll_table *wait)
+{
+	struct video_device *dev = video_devdata(file);
+	cam_data *cam = video_get_drvdata(dev);
+	wait_queue_head_t *queue = NULL;
+	int res = POLLIN | POLLRDNORM;
+
+	if (down_interruptible(&cam->busy_lock))
+		return -EINTR;
+
+	queue = &cam->enc_queue;
+	poll_wait(file, queue, wait);
+
+	up(&cam->busy_lock);
+	return res;
+}
+
+static struct
+file_operations mxc_v4l_fops = {
+	.owner = THIS_MODULE,
+	.open = mxc_v4l_open,
+	.release = mxc_v4l_close,
+	.read = mxc_v4l_read,
+	.ioctl = mxc_v4l_ioctl,
+	.mmap = mxc_mmap,
+	.poll = mxc_poll,
+};
+
+static struct video_device mxc_v4l_template = {
+	.name = "Mxc Camera",
+	.vfl_type = VID_TYPE_CAPTURE,
+	.fops = &mxc_v4l_fops,
+	.release = video_device_release,
+};
+
+extern struct camera_sensor camera_sensor_if;
+
+/*!
+* Camera V4l2 callback function.
+*
+* @return status
+*/
+static void camera_callback(u32 mask, void *dev)
+{
+	struct mxc_v4l_frame *done_frame;
+	struct mxc_v4l_frame *ready_frame;
+
+	cam_data *cam = (cam_data *) dev;
+	if (cam == NULL)
+		return;
+
+	if (list_empty(&cam->working_q)) {
+		printk(KERN_ERR "camera_callback: working queue empty\n");
+		return;
+	}
+
+	done_frame =
+	    list_entry(cam->working_q.next, struct mxc_v4l_frame, queue);
+	if (done_frame->buffer.flags & V4L2_BUF_FLAG_QUEUED) {
+		done_frame->buffer.flags |= V4L2_BUF_FLAG_DONE;
+		done_frame->buffer.flags &= ~V4L2_BUF_FLAG_QUEUED;
+
+		if (list_empty(&cam->ready_q)) {
+			cam->skip_frame++;
+		} else {
+			ready_frame =
+			    list_entry(cam->ready_q.next, struct mxc_v4l_frame,
+				       queue);
+			list_del(cam->ready_q.next);
+			list_add_tail(&ready_frame->queue, &cam->working_q);
+			cam->enc_update_eba(ready_frame->paddress,
+					    &cam->ping_pong_csi);
+		}
+
+		/* Added to the done queue */
+		list_del(cam->working_q.next);
+		list_add_tail(&done_frame->queue, &cam->done_q);
+
+		/* Wake up the queue */
+		cam->enc_counter++;
+		wake_up_interruptible(&cam->enc_queue);
+	} else {
+		printk(KERN_ERR "camera_callback :buffer not queued\n");
+	}
+}
+
+/*!
+ * initialize cam_data structure
+ *
+ * @param cam      structure cam_data *
+ *
+ * @return status  0 Success
+ */
+static void init_camera_struct(cam_data *cam)
+{
+	int i;
+
+	/* Default everything to 0 */
+	memset(cam, 0, sizeof(cam_data));
+
+	init_MUTEX(&cam->param_lock);
+	init_MUTEX(&cam->busy_lock);
+
+	cam->video_dev = video_device_alloc();
+	if (cam->video_dev == NULL)
+		return;
+
+	*(cam->video_dev) = mxc_v4l_template;
+
+	video_set_drvdata(cam->video_dev, cam);
+
+	cam->video_dev->minor = -1;
+
+	for (i = 0; i < FRAME_NUM; i++) {
+		cam->frame[i].width = 0;
+		cam->frame[i].height = 0;
+		cam->frame[i].paddress = 0;
+	}
+
+	init_waitqueue_head(&cam->enc_queue);
+	init_waitqueue_head(&cam->still_queue);
+
+	/* setup cropping */
+	cam->crop_bounds.left = 0;
+	cam->crop_bounds.width = 640;
+	cam->crop_bounds.top = 0;
+	cam->crop_bounds.height = 480;
+	cam->crop_current = cam->crop_defrect = cam->crop_bounds;
+	cam->streamparm.parm.capture.capturemode = 0;
+
+	cam->standard.index = 0;
+	cam->standard.id = V4L2_STD_UNKNOWN;
+	cam->standard.frameperiod.denominator = 30;
+	cam->standard.frameperiod.numerator = 1;
+	cam->standard.framelines = 480;
+	cam->streamparm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	cam->streamparm.parm.capture.timeperframe = cam->standard.frameperiod;
+	cam->streamparm.parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
+	cam->overlay_on = false;
+	cam->capture_on = false;
+	cam->skip_frame = 0;
+	cam->v4l2_fb.capability = V4L2_FBUF_CAP_EXTERNOVERLAY;
+	cam->v4l2_fb.flags = V4L2_FBUF_FLAG_PRIMARY;
+
+	cam->v2f.fmt.pix.sizeimage = 352 * 288 * 3 / 2;
+	cam->v2f.fmt.pix.bytesperline = 288 * 3 / 2;
+	cam->v2f.fmt.pix.width = 288;
+	cam->v2f.fmt.pix.height = 352;
+	cam->v2f.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV420;
+	cam->win.w.width = 160;
+	cam->win.w.height = 160;
+	cam->win.w.left = 0;
+	cam->win.w.top = 0;
+
+	cam->cam_sensor = &camera_sensor_if;
+	cam->enc_callback = camera_callback;
+
+	init_waitqueue_head(&cam->power_queue);
+	cam->int_lock = __SPIN_LOCK_UNLOCKED(cam->int_lock);
+	spin_lock_init(&cam->int_lock);
+}
+
+extern void gpio_sensor_active(void);
+extern void gpio_sensor_inactive(void);
+
+/*!
+ * camera_power function
+ *    Turn Sensor power On/Off
+ *
+ * @param       cameraOn      true to turn camera on, otherwise shut down
+ *
+ * @return status
+ */
+static u8 camera_power(bool cameraOn)
+{
+	if (cameraOn == true) {
+		gpio_sensor_active();
+		csi_enable_mclk(csi_mclk_flag_backup, true, true);
+	} else {
+		csi_mclk_flag_backup = csi_read_mclk_flag();
+		csi_enable_mclk(csi_mclk_flag_backup, false, false);
+		gpio_sensor_inactive();
+	}
+	return 0;
+}
+
+static int mxc_v4l2_probe(struct platform_device *pdev)
+{
+	struct mx27_camera_platform_data *pcdev;
+	int err = 0;
+
+	dev_info(&pdev->dev, "initialising\n");
+
+	pcdev = pdev->dev.platform_data;
+
+	err = pcdev->init(pdev);
+	if (err) {
+		pr_err("Camera platform init failed \n");
+		return err;
+	}
+	platform_set_drvdata(pdev, g_cam);
+
+	return 0;
+}
+
+static int mxc_v4l2_remove(struct platform_device *pdev)
+{
+	struct mx27_camera_platform_data *pcdev;
+	int err = 0;
+
+	dev_info(&pdev->dev, "Deinitialising\n");
+
+	pcdev = pdev->dev.platform_data;
+
+	err = pcdev->exit(pdev);
+	if (err) {
+		pr_err("Camera platform Deinit failed \n");
+		return err;
+	}
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+/*!
+ * This function is called to put the sensor in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure used to give information on which I2C
+ *                to suspend
+ * @param   state the power state the device is entering
+ *
+ * @return  The function returns 0 on success and -1 on failure.
+ */
+static int mxc_v4l2_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	cam_data *cam = platform_get_drvdata(pdev);
+
+	if (cam == NULL)
+		return -1;
+
+	cam->low_power = true;
+
+	if (cam->overlay_on == true)
+		stop_preview(cam);
+	if ((cam->capture_on == true) && cam->enc_disable)
+		cam->enc_disable(cam);
+
+	camera_power(false);
+
+	return 0;
+}
+
+/*!
+ * This function is called to bring the sensor back from a low power state.Refer
+ * to the document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   pdev  the device structure
+ *
+ * @return  The function returns 0 on success and -1 on failure
+ */
+static int mxc_v4l2_resume(struct platform_device *pdev)
+{
+	cam_data *cam = platform_get_drvdata(pdev);
+
+	if (cam == NULL)
+		return -1;
+
+	cam->low_power = false;
+	wake_up_interruptible(&cam->power_queue);
+
+	if (cam->overlay_on == true)
+		start_preview(cam);
+	if (cam->capture_on == true)
+		mxc_streamon(cam);
+	camera_power(true);
+
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxc_v4l2_driver = {
+	.driver = {
+		   .name = "mx27-camera",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = mxc_v4l2_probe,
+	.remove = mxc_v4l2_remove,
+	.suspend = mxc_v4l2_suspend,
+	.resume = mxc_v4l2_resume,
+	.shutdown = NULL,
+};
+
+/*!
+ * Entry point for the V4L2
+ *
+ * @return  Error code indicating success or failure
+ */
+static __init int camera_init(void)
+{
+	u8 err = 0;
+	cam_data *cam;
+
+	g_cam = kmalloc(sizeof(cam_data), GFP_KERNEL);
+	if (g_cam == NULL) {
+		pr_debug("failed to mxc_v4l_register_camera\n");
+		return -1;
+	}
+
+	cam = g_cam;
+	init_camera_struct(cam);
+
+	/* Register the device driver structure. */
+	err = platform_driver_register(&mxc_v4l2_driver);
+	if (err != 0) {
+		pr_debug("camera_init: driver_register failed.\n");
+		video_device_release(cam->video_dev);
+		kfree(cam);
+		g_cam = NULL;
+		return err;
+	}
+
+	/* register v4l device */
+	if (video_register_device(cam->video_dev, VFL_TYPE_GRABBER, video_nr)
+	    == -1) {
+		platform_driver_unregister(&mxc_v4l2_driver);
+
+		video_device_release(cam->video_dev);
+		kfree(cam);
+		g_cam = NULL;
+		pr_debug("video_register_device failed\n");
+		return -1;
+	}
+
+	return err;
+}
+
+/*!
+ * Exit and cleanup for the V4L2
+ *
+ */
+static void __exit camera_exit(void)
+{
+	pr_debug("unregistering video\n");
+
+	video_unregister_device(g_cam->video_dev);
+
+	platform_driver_unregister(&mxc_v4l2_driver);
+
+	if (g_cam->open_count) {
+		pr_debug("camera open -- setting ops to NULL\n");
+	} else {
+		pr_debug("freeing camera\n");
+		mxc_free_frame_buf(g_cam);
+		kfree(g_cam);
+		g_cam = NULL;
+	}
+}
+
+module_init(camera_init);
+module_exit(camera_exit);
+
+module_param(video_nr, int, 0444);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("V4L2 capture driver for Mxc based cameras");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
diff --git a/drivers/media/video/mxc/capture/mx27_csi.c b/drivers/media/video/mxc/capture/mx27_csi.c
new file mode 100644
index 0000000..12fb9f0
--- /dev/null
+++ b/drivers/media/video/mxc/capture/mx27_csi.c
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_csi.c
+ *
+ * @brief CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+
+#include "mx27_csi.h"
+
+static csi_config_t g_csi_cfg;	/* csi hardware configuration */
+static bool gcsi_mclk_on;
+static csi_irq_callback_t g_callback;
+static void *g_callback_data;
+static struct clk csi_mclk;
+
+static irqreturn_t csi_irq_handler(int irq, void *data)
+{
+	unsigned long status = __raw_readl(CSI_CSISR);
+
+	__raw_writel(status, CSI_CSISR);
+	if (g_callback)
+		g_callback(g_callback_data, status);
+
+	pr_debug("CSI status = 0x%08lX\n", status);
+
+	return IRQ_HANDLED;
+}
+
+static void csihw_set_config(csi_config_t *cfg)
+{
+	unsigned val = 0;
+
+	/* control reg 1 */
+	val |= cfg->swap16_en ? BIT_SWAP16_EN : 0;
+	val |= cfg->ext_vsync ? BIT_EXT_VSYNC : 0;
+	val |= cfg->eof_int_en ? BIT_EOF_INT_EN : 0;
+	val |= cfg->prp_if_en ? BIT_PRP_IF_EN : 0;
+	val |= cfg->ccir_mode ? BIT_CCIR_MODE : 0;
+	val |= cfg->cof_int_en ? BIT_COF_INT_EN : 0;
+	val |= cfg->sf_or_inten ? BIT_SF_OR_INTEN : 0;
+	val |= cfg->rf_or_inten ? BIT_RF_OR_INTEN : 0;
+	val |= cfg->statff_level << SHIFT_STATFF_LEVEL;
+	val |= cfg->staff_inten ? BIT_STATFF_INTEN : 0;
+	val |= cfg->rxff_level << SHIFT_RXFF_LEVEL;
+	val |= cfg->rxff_inten ? BIT_RXFF_INTEN : 0;
+	val |= cfg->sof_pol ? BIT_SOF_POL : 0;
+	val |= cfg->sof_inten ? BIT_SOF_INTEN : 0;
+	val |= cfg->mclkdiv << SHIFT_MCLKDIV;
+	val |= cfg->hsync_pol ? BIT_HSYNC_POL : 0;
+	val |= cfg->ccir_en ? BIT_CCIR_EN : 0;
+	val |= cfg->mclken ? BIT_MCLKEN : 0;
+	val |= cfg->fcc ? BIT_FCC : 0;
+	val |= cfg->pack_dir ? BIT_PACK_DIR : 0;
+	val |= cfg->gclk_mode ? BIT_GCLK_MODE : 0;
+	val |= cfg->inv_data ? BIT_INV_DATA : 0;
+	val |= cfg->inv_pclk ? BIT_INV_PCLK : 0;
+	val |= cfg->redge ? BIT_REDGE : 0;
+
+	__raw_writel(val, CSI_CSICR1);
+
+	/* control reg 3 */
+	val = 0x0;
+	val |= cfg->csi_sup ? BIT_CSI_SUP : 0;
+	val |= cfg->zero_pack_en ? BIT_ZERO_PACK_EN : 0;
+	val |= cfg->ecc_int_en ? BIT_ECC_INT_EN : 0;
+	val |= cfg->ecc_auto_en ? BIT_ECC_AUTO_EN : 0;
+
+	__raw_writel(val, CSI_CSICR3);
+
+	/* rxfifo counter */
+	__raw_writel(cfg->rxcnt, CSI_CSIRXCNT);
+
+	/* update global config */
+	memcpy(&g_csi_cfg, cfg, sizeof(csi_config_t));
+}
+
+static void csihw_reset_frame_count(void)
+{
+	__raw_writel(__raw_readl(CSI_CSICR3) | BIT_FRMCNT_RST, CSI_CSICR3);
+}
+
+static void csihw_reset(void)
+{
+	csihw_reset_frame_count();
+	__raw_writel(CSICR1_RESET_VAL, CSI_CSICR1);
+	__raw_writel(CSICR2_RESET_VAL, CSI_CSICR2);
+	__raw_writel(CSICR3_RESET_VAL, CSI_CSICR3);
+}
+
+/*!
+ * csi_init_interface
+ *    Sets initial values for the CSI registers.
+ *    The width and height of the sensor and the actual frame size will be
+ *    set to the same values.
+ * @param       width        Sensor width
+ * @param       height       Sensor height
+ * @param       pixel_fmt    pixel format
+ * @param       sig          csi_signal_cfg_t
+ *
+ * @return      0 for success, -EINVAL for error
+ */
+int32_t csi_init_interface(uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt, csi_signal_cfg_t sig)
+{
+	csi_config_t cfg;
+
+	/* Set the CSI_SENS_CONF register remaining fields */
+	cfg.swap16_en = 1;
+	cfg.ext_vsync = sig.ext_vsync;
+	cfg.eof_int_en = 0;
+	cfg.prp_if_en = 1;
+	cfg.ccir_mode = 0;
+	cfg.cof_int_en = 0;
+	cfg.sf_or_inten = 0;
+	cfg.rf_or_inten = 0;
+	cfg.statff_level = 0;
+	cfg.staff_inten = 0;
+	cfg.rxff_level = 2;
+	cfg.rxff_inten = 0;
+	cfg.sof_pol = 1;
+	cfg.sof_inten = 0;
+	cfg.mclkdiv = 0;
+	cfg.hsync_pol = 1;
+	cfg.ccir_en = 0;
+	cfg.mclken = gcsi_mclk_on ? 1 : 0;
+	cfg.fcc = 1;
+	cfg.pack_dir = 0;
+	cfg.gclk_mode = 1;
+	cfg.inv_data = sig.data_pol;
+	cfg.inv_pclk = sig.pixclk_pol;
+	cfg.redge = 1;
+	cfg.csicnt1_rsv = 0;
+
+	/* control reg 3 */
+	cfg.frmcnt = 0;
+	cfg.frame_reset = 0;
+	cfg.csi_sup = 0;
+	cfg.zero_pack_en = 0;
+	cfg.ecc_int_en = 0;
+	cfg.ecc_auto_en = 0;
+
+	csihw_set_config(&cfg);
+
+	return 0;
+}
+EXPORT_SYMBOL(csi_init_interface);
+
+/*!
+ * csi_enable_prpif
+ *    Enable or disable CSI-PrP interface
+ * @param       enable        Non-zero to enable, zero to disable
+ */
+void csi_enable_prpif(uint32_t enable)
+{
+	if (enable) {
+		g_csi_cfg.prp_if_en = 1;
+		g_csi_cfg.sof_inten = 0;
+		g_csi_cfg.pack_dir = 0;
+	} else {
+		g_csi_cfg.prp_if_en = 0;
+		g_csi_cfg.sof_inten = 1;
+		g_csi_cfg.pack_dir = 1;
+	}
+
+	csihw_set_config(&g_csi_cfg);
+}
+EXPORT_SYMBOL(csi_enable_prpif);
+
+/*!
+ * csi_enable_mclk
+ *
+ * @param       src         enum define which source to control the clk
+ *                          CSI_MCLK_VF CSI_MCLK_ENC CSI_MCLK_RAW CSI_MCLK_I2C
+ * @param       flag        true to enable mclk, false to disable mclk
+ * @param       wait        true to wait 100ms make clock stable, false not wait
+ *
+ * @return      0 for success
+ */
+int32_t csi_enable_mclk(int src, bool flag, bool wait)
+{
+	if (flag == true) {
+		clk_enable(&csi_mclk);
+		if (wait == true)
+			msleep(10);
+		pr_debug("Enable csi clock from source %d\n", src);
+		gcsi_mclk_on = true;
+	} else {
+		clk_disable(&csi_mclk);
+		pr_debug("Disable csi clock from source %d\n", src);
+		gcsi_mclk_on = false;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(csi_enable_mclk);
+
+/*!
+ * csi_read_mclk_flag
+ *
+ * @return  gcsi_mclk_source
+ */
+int csi_read_mclk_flag(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(csi_read_mclk_flag);
+
+void csi_set_callback(csi_irq_callback_t callback, void *data)
+{
+	g_callback = callback;
+	g_callback_data = data;
+}
+EXPORT_SYMBOL(csi_set_callback);
+
+static unsigned long _mclk_round_rate(struct clk *clk, unsigned long rate)
+{
+	/* Keep CSI divider and change parent clock */
+	if (clk->parent->round_rate)
+		return clk->parent->round_rate(clk->parent, rate * 2);
+
+	return 0;
+}
+
+static int _mclk_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret = -EINVAL;
+
+	/* Keep CSI divider and change parent clock */
+	if (clk->parent->set_rate)
+		ret = clk->parent->set_rate(clk->parent, rate);
+
+	return ret;
+}
+
+static int _mclk_enable(struct clk *clk)
+{
+	__raw_writel(__raw_readl(CSI_CSICR1) | BIT_MCLKEN, CSI_CSICR1);
+	return 0;
+}
+
+static void _mclk_disable(struct clk *clk)
+{
+	__raw_writel(__raw_readl(CSI_CSICR1) & ~BIT_MCLKEN, CSI_CSICR1);
+}
+
+static struct clk csi_mclk = {
+	.name = "csi_clk",
+	.round_rate = _mclk_round_rate,
+	.set_rate = _mclk_set_rate,
+	.enable = _mclk_enable,
+	.disable = _mclk_disable,
+};
+
+int32_t __init csi_init_module(void)
+{
+	int ret = 0;
+	struct clk *per_clk;
+
+	per_clk = clk_get(NULL, "csi_perclk");
+	if (IS_ERR(per_clk))
+		return PTR_ERR(per_clk);
+	clk_put(per_clk);
+	csi_mclk.parent = per_clk;
+	clk_register(&csi_mclk);
+	clk_enable(per_clk);
+	csihw_reset();
+
+	/* interrupt enable */
+	ret = request_irq(MXC_INT_CSI, csi_irq_handler, 0, "csi", 0);
+	if (ret)
+		pr_debug("CSI error: irq request fail\n");
+
+	return ret;
+}
+
+void __exit csi_cleanup_module(void)
+{
+	/* free irq */
+	free_irq(MXC_INT_CSI, 0);
+
+	clk_disable(&csi_mclk);
+}
+
+module_init(csi_init_module);
+module_exit(csi_cleanup_module);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX27 CSI driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/video/mxc/capture/mx27_csi.h b/drivers/media/video/mxc/capture/mx27_csi.h
new file mode 100644
index 0000000..d76f693
--- /dev/null
+++ b/drivers/media/video/mxc/capture/mx27_csi.h
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2005-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_csi.h
+ *
+ * @brief CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+
+#ifndef MX27_CSI_H
+#define MX27_CSI_H
+
+#include <linux/io.h>
+
+/* reset values */
+#define CSICR1_RESET_VAL	0x40000800
+#define CSICR2_RESET_VAL	0x0
+#define CSICR3_RESET_VAL	0x0
+
+/* csi control reg 1 */
+#define BIT_SWAP16_EN		(0x1 << 31)
+#define BIT_EXT_VSYNC		(0x1 << 30)
+#define BIT_EOF_INT_EN		(0x1 << 29)
+#define BIT_PRP_IF_EN		(0x1 << 28)
+#define BIT_CCIR_MODE		(0x1 << 27)
+#define BIT_COF_INT_EN		(0x1 << 26)
+#define BIT_SF_OR_INTEN		(0x1 << 25)
+#define BIT_RF_OR_INTEN		(0x1 << 24)
+#define BIT_STATFF_LEVEL	(0x3 << 22)
+#define BIT_STATFF_INTEN	(0x1 << 21)
+#define BIT_RXFF_LEVEL		(0x3 << 19)
+#define BIT_RXFF_INTEN		(0x1 << 18)
+#define BIT_SOF_POL		(0x1 << 17)
+#define BIT_SOF_INTEN		(0x1 << 16)
+#define BIT_MCLKDIV		(0xF << 12)
+#define BIT_HSYNC_POL		(0x1 << 11)
+#define BIT_CCIR_EN		(0x1 << 10)
+#define BIT_MCLKEN		(0x1 << 9)
+#define BIT_FCC			(0x1 << 8)
+#define BIT_PACK_DIR		(0x1 << 7)
+#define BIT_CLR_STATFIFO	(0x1 << 6)
+#define BIT_CLR_RXFIFO		(0x1 << 5)
+#define BIT_GCLK_MODE		(0x1 << 4)
+#define BIT_INV_DATA		(0x1 << 3)
+#define BIT_INV_PCLK		(0x1 << 2)
+#define BIT_REDGE		(0x1 << 1)
+
+#define SHIFT_STATFF_LEVEL	22
+#define SHIFT_RXFF_LEVEL	19
+#define SHIFT_MCLKDIV		12
+
+/* control reg 3 */
+#define BIT_FRMCNT		(0xFFFF << 16)
+#define BIT_FRMCNT_RST		(0x1 << 15)
+#define BIT_CSI_SUP		(0x1 << 3)
+#define BIT_ZERO_PACK_EN	(0x1 << 2)
+#define BIT_ECC_INT_EN		(0x1 << 1)
+#define BIT_ECC_AUTO_EN		(0x1)
+
+#define SHIFT_FRMCNT		16
+
+/* csi status reg */
+#define BIT_SFF_OR_INT		(0x1 << 25)
+#define BIT_RFF_OR_INT		(0x1 << 24)
+#define BIT_STATFF_INT		(0x1 << 21)
+#define BIT_RXFF_INT		(0x1 << 18)
+#define BIT_EOF_INT		(0x1 << 17)
+#define BIT_SOF_INT		(0x1 << 16)
+#define BIT_F2_INT		(0x1 << 15)
+#define BIT_F1_INT		(0x1 << 14)
+#define BIT_COF_INT		(0x1 << 13)
+#define BIT_ECC_INT		(0x1 << 1)
+#define BIT_DRDY		(0x1 << 0)
+
+#define CSI_MCLK_VF		1
+#define CSI_MCLK_ENC		2
+#define CSI_MCLK_RAW		4
+#define CSI_MCLK_I2C		8
+
+#define CSI_CSICR1		(IO_ADDRESS(CSI_BASE_ADDR))
+#define CSI_CSICR2		(IO_ADDRESS(CSI_BASE_ADDR + 0x4))
+#define CSI_CSISR		(IO_ADDRESS(CSI_BASE_ADDR + 0x8))
+#define CSI_STATFIFO		(IO_ADDRESS(CSI_BASE_ADDR + 0xC))
+#define CSI_CSIRXFIFO		(IO_ADDRESS(CSI_BASE_ADDR + 0x10))
+#define CSI_CSIRXCNT		(IO_ADDRESS(CSI_BASE_ADDR + 0x14))
+#define CSI_CSICR3		(IO_ADDRESS(CSI_BASE_ADDR + 0x1C))
+
+#define CSI_CSIRXFIFO_PHYADDR	(CSI_BASE_ADDR + 0x10)
+
+static inline void csi_clear_status(unsigned long status)
+{
+	__raw_writel(status, CSI_CSISR);
+}
+
+typedef struct {
+	unsigned data_width:3;
+	unsigned clk_mode:2;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+} csi_signal_cfg_t;
+
+typedef struct {
+	/* control reg 1 */
+	unsigned int swap16_en:1;
+	unsigned int ext_vsync:1;
+	unsigned int eof_int_en:1;
+	unsigned int prp_if_en:1;
+	unsigned int ccir_mode:1;
+	unsigned int cof_int_en:1;
+	unsigned int sf_or_inten:1;
+	unsigned int rf_or_inten:1;
+	unsigned int statff_level:2;
+	unsigned int staff_inten:1;
+	unsigned int rxff_level:2;
+	unsigned int rxff_inten:1;
+	unsigned int sof_pol:1;
+	unsigned int sof_inten:1;
+	unsigned int mclkdiv:4;
+	unsigned int hsync_pol:1;
+	unsigned int ccir_en:1;
+	unsigned int mclken:1;
+	unsigned int fcc:1;
+	unsigned int pack_dir:1;
+	unsigned int gclk_mode:1;
+	unsigned int inv_data:1;
+	unsigned int inv_pclk:1;
+	unsigned int redge:1;
+	unsigned int csicnt1_rsv:1;
+
+	/* control reg 3 */
+	unsigned int frmcnt:16;
+	unsigned int frame_reset:1;
+	unsigned int csi_sup:1;
+	unsigned int zero_pack_en:1;
+	unsigned int ecc_int_en:1;
+	unsigned int ecc_auto_en:1;
+
+	/* fifo counter */
+	unsigned int rxcnt;
+} csi_config_t;
+
+typedef void (*csi_irq_callback_t) (void *data, unsigned long status);
+
+int32_t csi_enable_mclk(int src, bool flag, bool wait);
+int32_t csi_init_interface(uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt, csi_signal_cfg_t sig);
+int csi_read_mclk_flag(void);
+void csi_set_callback(csi_irq_callback_t callback, void *data);
+void csi_enable_prpif(uint32_t enable);
+
+#endif
diff --git a/drivers/media/video/mxc/capture/mx27_prp.h b/drivers/media/video/mxc/capture/mx27_prp.h
new file mode 100644
index 0000000..d905df2
--- /dev/null
+++ b/drivers/media/video/mxc/capture/mx27_prp.h
@@ -0,0 +1,310 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prp.h
+ *
+ * @brief Header file for MX27 V4L2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#ifndef __MX27_PRP_H__
+#define __MX27_PRP_H__
+
+#define PRP_REG(ofs)	(IO_ADDRESS(EMMA_PRP_BASE_ADDR) + ofs)
+
+/* Register definitions of PrP */
+#define PRP_CNTL			PRP_REG(0x00)
+#define PRP_INTRCNTL	 		PRP_REG(0x04)
+#define PRP_INTRSTATUS			PRP_REG(0x08)
+#define PRP_SOURCE_Y_PTR		PRP_REG(0x0C)
+#define PRP_SOURCE_CB_PTR		PRP_REG(0x10)
+#define PRP_SOURCE_CR_PTR		PRP_REG(0x14)
+#define PRP_DEST_RGB1_PTR		PRP_REG(0x18)
+#define PRP_DEST_RGB2_PTR		PRP_REG(0x1C)
+#define PRP_DEST_Y_PTR			PRP_REG(0x20)
+#define PRP_DEST_CB_PTR			PRP_REG(0x24)
+#define PRP_DEST_CR_PTR			PRP_REG(0x28)
+#define PRP_SOURCE_FRAME_SIZE  		PRP_REG(0x2C)
+#define PRP_CH1_LINE_STRIDE		PRP_REG(0x30)
+#define PRP_SRC_PIXEL_FORMAT_CNTL	PRP_REG(0x34)
+#define PRP_CH1_PIXEL_FORMAT_CNTL	PRP_REG(0x38)
+#define PRP_CH1_OUT_IMAGE_SIZE		PRP_REG(0x3C)
+#define PRP_CH2_OUT_IMAGE_SIZE		PRP_REG(0x40)
+#define PRP_SOURCE_LINE_STRIDE		PRP_REG(0x44)
+#define PRP_CSC_COEF_012		PRP_REG(0x48)
+#define PRP_CSC_COEF_345		PRP_REG(0x4C)
+#define PRP_CSC_COEF_678		PRP_REG(0x50)
+#define PRP_CH1_RZ_HORI_COEF1		PRP_REG(0x54)
+#define PRP_CH1_RZ_HORI_COEF2		PRP_REG(0x58)
+#define PRP_CH1_RZ_HORI_VALID		PRP_REG(0x5C)
+#define PRP_CH1_RZ_VERT_COEF1		PRP_REG(0x60)
+#define PRP_CH1_RZ_VERT_COEF2		PRP_REG(0x64)
+#define PRP_CH1_RZ_VERT_VALID		PRP_REG(0x68)
+#define PRP_CH2_RZ_HORI_COEF1		PRP_REG(0x6C)
+#define PRP_CH2_RZ_HORI_COEF2		PRP_REG(0x70)
+#define PRP_CH2_RZ_HORI_VALID		PRP_REG(0x74)
+#define PRP_CH2_RZ_VERT_COEF1		PRP_REG(0x78)
+#define PRP_CH2_RZ_VERT_COEF2		PRP_REG(0x7C)
+#define PRP_CH2_RZ_VERT_VALID		PRP_REG(0x80)
+
+#define B_SET(b)			(1 << (b))
+
+/* Bit definitions for PrP control register */
+#define PRP_CNTL_RSTVAL			0x28
+#define PRP_CNTL_CH1EN			B_SET(0)
+#define PRP_CNTL_CH2EN			B_SET(1)
+#define PRP_CNTL_CSI			B_SET(2)
+#define PRP_CNTL_IN_32			B_SET(3)
+#define PRP_CNTL_IN_RGB			B_SET(4)
+#define PRP_CNTL_IN_YUV420		0
+#define PRP_CNTL_IN_YUV422		PRP_CNTL_IN_32
+#define PRP_CNTL_IN_RGB16		PRP_CNTL_IN_RGB
+#define PRP_CNTL_IN_RGB32		(PRP_CNTL_IN_RGB | PRP_CNTL_IN_32)
+#define PRP_CNTL_CH1_RGB8		0
+#define PRP_CNTL_CH1_RGB16		B_SET(5)
+#define PRP_CNTL_CH1_RGB32		B_SET(6)
+#define PRP_CNTL_CH1_YUV422		(B_SET(5) | B_SET(6))
+#define PRP_CNTL_CH2_YUV420		0
+#define PRP_CNTL_CH2_YUV422		B_SET(7)
+#define PRP_CNTL_CH2_YUV444		B_SET(8)
+#define PRP_CNTL_CH1_LOOP		B_SET(9)
+#define PRP_CNTL_CH2_LOOP		B_SET(10)
+#define PRP_CNTL_AUTODROP		B_SET(11)
+#define PRP_CNTL_RST			B_SET(12)
+#define PRP_CNTL_CNTREN			B_SET(13)
+#define PRP_CNTL_WINEN			B_SET(14)
+#define PRP_CNTL_UNCHAIN		B_SET(15)
+#define PRP_CNTL_IN_SKIP_NONE		0
+#define PRP_CNTL_IN_SKIP_1_2		B_SET(16)
+#define PRP_CNTL_IN_SKIP_1_3		B_SET(17)
+#define PRP_CNTL_IN_SKIP_2_3		(B_SET(16) | B_SET(17))
+#define PRP_CNTL_IN_SKIP_1_4		B_SET(18)
+#define PRP_CNTL_IN_SKIP_3_4		(B_SET(16) | B_SET(18))
+#define PRP_CNTL_IN_SKIP_2_5		(B_SET(17) | B_SET(18))
+#define PRP_CNTL_IN_SKIP_3_5		(B_SET(16) | B_SET(17) | B_SET(18))
+#define PRP_CNTL_CH1_SKIP_NONE		0
+#define PRP_CNTL_CH1_SKIP_1_2		B_SET(19)
+#define PRP_CNTL_CH1_SKIP_1_3		B_SET(20)
+#define PRP_CNTL_CH1_SKIP_2_3		(B_SET(19) | B_SET(20))
+#define PRP_CNTL_CH1_SKIP_1_4		B_SET(21)
+#define PRP_CNTL_CH1_SKIP_3_4		(B_SET(19) | B_SET(21))
+#define PRP_CNTL_CH1_SKIP_2_5		(B_SET(20) | B_SET(21))
+#define PRP_CNTL_CH1_SKIP_3_5		(B_SET(19) | B_SET(20) | B_SET(21))
+#define PRP_CNTL_CH2_SKIP_NONE		0
+#define PRP_CNTL_CH2_SKIP_1_2		B_SET(22)
+#define PRP_CNTL_CH2_SKIP_1_3		B_SET(23)
+#define PRP_CNTL_CH2_SKIP_2_3		(B_SET(22) | B_SET(23))
+#define PRP_CNTL_CH2_SKIP_1_4		B_SET(24)
+#define PRP_CNTL_CH2_SKIP_3_4		(B_SET(22) | B_SET(24))
+#define PRP_CNTL_CH2_SKIP_2_5		(B_SET(23) | B_SET(24))
+#define PRP_CNTL_CH2_SKIP_3_5		(B_SET(22) | B_SET(23) | B_SET(24))
+#define PRP_CNTL_FIFO_I128		0
+#define PRP_CNTL_FIFO_I96		B_SET(25)
+#define PRP_CNTL_FIFO_I64		B_SET(26)
+#define PRP_CNTL_FIFO_I32		(B_SET(25) | B_SET(26))
+#define PRP_CNTL_FIFO_O64		0
+#define PRP_CNTL_FIFO_O48		B_SET(27)
+#define PRP_CNTL_FIFO_O32		B_SET(28)
+#define PRP_CNTL_FIFO_O16		(B_SET(27) | B_SET(28))
+#define PRP_CNTL_CH2B1			B_SET(29)
+#define PRP_CNTL_CH2B2			B_SET(30)
+#define PRP_CNTL_CH2_FLOWEN		B_SET(31)
+
+/* Bit definitions for PrP interrupt control register */
+#define PRP_INTRCNTL_RDERR		B_SET(0)
+#define PRP_INTRCNTL_CH1WERR		B_SET(1)
+#define PRP_INTRCNTL_CH2WERR		B_SET(2)
+#define PRP_INTRCNTL_CH1FC		B_SET(3)
+#define PRP_INTRCNTL_CH2FC		B_SET(5)
+#define PRP_INTRCNTL_LBOVF		B_SET(7)
+#define PRP_INTRCNTL_CH2OVF		B_SET(8)
+
+/* Bit definitions for PrP interrupt status register */
+#define PRP_INTRSTAT_RDERR		B_SET(0)
+#define PRP_INTRSTAT_CH1WERR		B_SET(1)
+#define PRP_INTRSTAT_CH2WERR		B_SET(2)
+#define PRP_INTRSTAT_CH2BUF2		B_SET(3)
+#define PRP_INTRSTAT_CH2BUF1		B_SET(4)
+#define PRP_INTRSTAT_CH1BUF2		B_SET(5)
+#define PRP_INTRSTAT_CH1BUF1		B_SET(6)
+#define PRP_INTRSTAT_LBOVF		B_SET(7)
+#define PRP_INTRSTAT_CH2OVF		B_SET(8)
+
+#define PRP_CHANNEL_1		0x1
+#define PRP_CHANNEL_2		0x2
+
+/* PRP-CSI config */
+#define PRP_CSI_EN		0x80
+#define PRP_CSI_LOOP		(0x40 | PRP_CSI_EN)
+#define PRP_CSI_IRQ_FRM		(0x08 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_CH1ERR	(0x10 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_CH2ERR	(0x20 | PRP_CSI_LOOP)
+#define PRP_CSI_IRQ_ALL		(0x38 | PRP_CSI_LOOP)
+#define PRP_CSI_SKIP_NONE	0
+#define PRP_CSI_SKIP_1OF2	1
+#define PRP_CSI_SKIP_1OF3	2
+#define PRP_CSI_SKIP_2OF3	3
+#define PRP_CSI_SKIP_1OF4	4
+#define PRP_CSI_SKIP_3OF4	5
+#define PRP_CSI_SKIP_2OF5	6
+#define PRP_CSI_SKIP_4OF5	7
+
+#define PRP_PIXIN_RGB565	0x2CA00565
+#define PRP_PIXIN_RGB888	0x41000888
+#define PRP_PIXIN_YUV420	0
+#define PRP_PIXIN_YUYV		0x22000888
+#define PRP_PIXIN_YVYU		0x20100888
+#define PRP_PIXIN_UYVY		0x03080888
+#define PRP_PIXIN_VYUY		0x01180888
+#define PRP_PIXIN_YUV422	0x62080888
+
+#define PRP_PIX1_RGB332		0x14400322
+#define PRP_PIX1_RGB565		0x2CA00565
+#define PRP_PIX1_RGB888		0x41000888
+#define PRP_PIX1_YUYV		0x62000888
+#define PRP_PIX1_YVYU		0x60100888
+#define PRP_PIX1_UYVY		0x43080888
+#define PRP_PIX1_VYUY		0x41180888
+#define PRP_PIX1_UNUSED		0
+
+#define PRP_PIX2_YUV420		0
+#define PRP_PIX2_YUV422		1
+#define PRP_PIX2_YUV444		4
+#define PRP_PIX2_UNUSED		8
+
+#define PRP_ALGO_WIDTH_ANY	0
+#define PRP_ALGO_HEIGHT_ANY	0
+#define PRP_ALGO_WIDTH_BIL	1
+#define PRP_ALGO_WIDTH_AVG	2
+#define PRP_ALGO_HEIGHT_BIL	4
+#define PRP_ALGO_HEIGHT_AVG	8
+#define PRP_ALGO_BYPASS		0x10
+
+typedef struct _emma_prp_ratio {
+	unsigned short num;
+	unsigned short den;
+} emma_prp_ratio;
+
+/*
+ * The following definitions are for resizing. Definition values must not
+ * be changed otherwise decision logic will be wrong.
+ */
+#define SCALE_RETRY	16	/* retry times if ratio is not supported */
+
+#define BC_COEF		3
+#define MAX_TBL		20
+#define SZ_COEF		(1 << BC_COEF)
+
+#define ALGO_AUTO	0
+#define ALGO_BIL	1
+#define ALGO_AVG	2
+
+typedef struct {
+	char tbl[20];		/* table entries */
+	char len;		/* table length used */
+	char algo;		/* ALGO_xxx */
+	char ratio[20];		/* ratios used */
+} scale_t;
+
+/*
+ * structure for prp scaling.
+ * algorithm - bilinear or averaging for each axis
+ * PRP_ALGO_WIDTH_x | PRP_ALGO_HEIGHT_x | PRP_ALGO_BYPASS
+ * PRP_ALGO_BYPASS - Ch1 will not use Ch2 scaling with this flag
+ */
+typedef struct _emma_prp_scale {
+	unsigned char algo;
+	emma_prp_ratio width;
+	emma_prp_ratio height;
+} emma_prp_scale;
+
+typedef struct emma_prp_cfg {
+	unsigned int in_pix;	/* PRP_PIXIN_xxx */
+	unsigned short in_width;	/* image width, 32 - 2044 */
+	unsigned short in_height;	/* image height, 32 - 2044 */
+	unsigned char in_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+	unsigned short in_line_stride;	/* in_line_stride and in_line_skip */
+	unsigned short in_line_skip;	/* allow cropping from CSI */
+	unsigned int in_ptr;	/* bus address */
+	/*
+	 * in_csc[9] = 1 -> Y-16
+	 * if in_csc[1..9] == 0
+	 *      in_csc[0] represents YUV range 0-3 = A0,A1,B0,B1;
+	 * else
+	 *      in_csc[0..9] represents either format
+	 */
+	unsigned short in_csc[10];
+
+	unsigned char ch2_pix;	/* PRP_PIX2_xxx */
+	emma_prp_scale ch2_scale;	/* resizing paramters */
+	unsigned short ch2_width;	/* 4-2044, 0 = scaled */
+	unsigned short ch2_height;	/* 4-2044, 0 = scaled */
+	unsigned int ch2_ptr;	/* bus addr */
+	unsigned int ch2_ptr2;	/* bus addr for 2nd buf (loop mode) */
+	unsigned char ch2_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+
+	unsigned int ch1_pix;	/* PRP_PIX1_xxx */
+	emma_prp_scale ch1_scale;	/* resizing parameters */
+	unsigned short ch1_width;	/* 4-2044, 0 = scaled */
+	unsigned short ch1_height;	/* 4-2044, 0 = scaled */
+	unsigned short ch1_stride;	/* 4-4088, 0 = ch1_width */
+	unsigned int ch1_ptr;	/* bus addr */
+	unsigned int ch1_ptr2;	/* bus addr for 2nd buf (loop mode) */
+	unsigned char ch1_csi;	/* PRP_CSI_SKIP_x | PRP_CSI_LOOP */
+
+	/*
+	 * channel resizing coefficients
+	 * scale[0] for channel 1 width
+	 * scale[1] for channel 1 height
+	 * scale[2] for channel 2 width
+	 * scale[3] for channel 2 height
+	 */
+	scale_t scale[4];
+} emma_prp_cfg;
+
+int prphw_reset(void);
+int prphw_enable(int channel);
+int prphw_disable(int channel);
+int prphw_inptr(emma_prp_cfg *);
+int prphw_ch1ptr(emma_prp_cfg *);
+int prphw_ch1ptr2(emma_prp_cfg *);
+int prphw_ch2ptr(emma_prp_cfg *);
+int prphw_ch2ptr2(emma_prp_cfg *);
+int prphw_cfg(emma_prp_cfg *);
+int prphw_isr(void);
+void prphw_init(void);
+void prphw_exit(void);
+
+/*
+ * scale	out	coefficient table
+ * din		in	scale numerator
+ * dout		in	scale denominator
+ * inv		in	pre-scale dimension
+ * vout		in/out	post-scale output dimension
+ * pout		out	post-scale internal dimension [opt]
+ * retry	in	retry times (round the output length) when need
+ */
+int prp_scale(scale_t *pscale, int din, int dout, int inv,
+	      unsigned short *vout, unsigned short *pout, int retry);
+
+int prp_init(void *dev_id);
+void prp_exit(void *dev_id);
+int prp_enc_select(void *data);
+int prp_enc_deselect(void *data);
+int prp_vf_select(void *data);
+int prp_vf_deselect(void *data);
+int prp_still_select(void *data);
+int prp_still_deselect(void *data);
+
+#endif				/* __MX27_PRP_H__ */
diff --git a/drivers/media/video/mxc/capture/mx27_prphw.c b/drivers/media/video/mxc/capture/mx27_prphw.c
new file mode 100644
index 0000000..b8acb79
--- /dev/null
+++ b/drivers/media/video/mxc/capture/mx27_prphw.c
@@ -0,0 +1,1099 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prphw.c
+ *
+ * @brief MX27 Video For Linux 2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+
+#include "mx27_prp.h"
+
+#define PRP_MIN_IN_WIDTH	32
+#define PRP_MAX_IN_WIDTH	2044
+#define PRP_MIN_IN_HEIGHT	32
+#define PRP_MAX_IN_HEIGHT	2044
+
+typedef struct _coeff_t {
+	unsigned long coeff[2];
+	unsigned long cntl;
+} coeff_t[2][2];
+
+static coeff_t *PRP_RSZ_COEFF = (coeff_t *) PRP_CH1_RZ_HORI_COEF1;
+
+static unsigned char scale_get(scale_t *t,
+			       unsigned char *i, unsigned char *out);
+static int gcd(int x, int y);
+static int ratio(int x, int y, int *den);
+static int prp_scale_bilinear(scale_t *t, int coeff, int base, int nxt);
+static int prp_scale_ave(scale_t *t, unsigned char base);
+static int ave_scale(scale_t *t, int inv, int outv);
+static int scale(scale_t *t, int inv, int outv);
+
+/*!
+ * @param t	table
+ * @param i	table index
+ * @param out	bilinear	# input pixels to advance
+ *		average		whether result is ready for output
+ * @return	coefficient
+*/
+static unsigned char scale_get(scale_t *t, unsigned char *i,
+			       unsigned char *out)
+{
+	unsigned char c;
+
+	c = t->tbl[*i];
+	(*i)++;
+	*i %= t->len;
+
+	if (out) {
+		if (t->algo == ALGO_BIL) {
+			for ((*out) = 1;
+			     (*i) && ((*i) < t->len) && !t->tbl[(*i)]; (*i)++) {
+				(*out)++;
+			}
+			if ((*i) == t->len)
+				(*i) = 0;
+		} else
+			*out = c >> BC_COEF;
+	}
+
+	c &= SZ_COEF - 1;
+
+	if (c == SZ_COEF - 1)
+		c = SZ_COEF;
+
+	return c;
+}
+
+/*!
+ * @brief Get maximum common divisor.
+ * @param x	First input value
+ * @param y	Second input value
+ * @return	Maximum common divisor of x and y
+ */
+static int gcd(int x, int y)
+{
+	int k;
+
+	if (x < y) {
+		k = x;
+		x = y;
+		y = k;
+	}
+
+	while ((k = x % y)) {
+		x = y;
+		y = k;
+	}
+
+	return y;
+}
+
+/*!
+ * @brief Get ratio.
+ * @param x	First input value
+ * @param y	Second input value
+ * @param den	Denominator of the ratio (corresponding to y)
+ * @return	Numerator of the ratio (corresponding to x)
+ */
+static int ratio(int x, int y, int *den)
+{
+	int g;
+
+	if (!x || !y)
+		return 0;
+
+	g = gcd(x, y);
+	*den = y / g;
+
+	return x / g;
+}
+
+/*!
+ * @brief Build PrP coefficient entry based on bilinear algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param coeff	The weighting coefficient
+ * @param base	The base of the coefficient
+ * @param nxt	Number of pixels to be read
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int prp_scale_bilinear(scale_t *t, int coeff, int base, int nxt)
+{
+	int i;
+
+	if (t->len >= sizeof(t->tbl))
+		return -1;
+
+	coeff = ((coeff << BC_COEF) + (base >> 1)) / base;
+	if (coeff >= SZ_COEF - 1)
+		coeff--;
+
+	coeff |= SZ_COEF;
+	t->tbl[(int)t->len++] = (unsigned char)coeff;
+
+	for (i = 1; i < nxt; i++) {
+		if (t->len >= MAX_TBL)
+			return -1;
+
+		t->tbl[(int)t->len++] = 0;
+	}
+
+	return t->len;
+}
+
+#define _bary(name)	static const unsigned char name[]
+
+_bary(c1) = {
+7};
+
+_bary(c2) = {
+4, 4};
+
+_bary(c3) = {
+2, 4, 2};
+
+_bary(c4) = {
+2, 2, 2, 2};
+
+_bary(c5) = {
+1, 2, 2, 2, 1};
+
+_bary(c6) = {
+1, 1, 2, 2, 1, 1};
+
+_bary(c7) = {
+1, 1, 1, 2, 1, 1, 1};
+
+_bary(c8) = {
+1, 1, 1, 1, 1, 1, 1, 1};
+
+_bary(c9) = {
+1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+_bary(c10) = {
+0, 1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+_bary(c11) = {
+0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0};
+
+_bary(c12) = {
+0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0};
+
+_bary(c13) = {
+0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0};
+
+_bary(c14) = {
+0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0};
+
+_bary(c15) = {
+0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0};
+
+_bary(c16) = {
+1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
+
+_bary(c17) = {
+0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
+
+_bary(c18) = {
+0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0};
+
+_bary(c19) = {
+0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0};
+
+_bary(c20) = {
+0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0};
+
+static const unsigned char *ave_coeff[] = {
+	c1, c2, c3, c4, c5, c6, c7, c8, c9, c10,
+	c11, c12, c13, c14, c15, c16, c17, c18, c19, c20
+};
+
+/*!
+ * @brief Build PrP coefficient table based on average algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param base	The base of the coefficient
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int prp_scale_ave(scale_t *t, unsigned char base)
+{
+	if (t->len + base > sizeof(t->tbl))
+		return -1;
+
+	memcpy(&t->tbl[(int)t->len], ave_coeff[(int)base - 1], base);
+	t->len = (unsigned char)(t->len + base);
+	t->tbl[t->len - 1] |= SZ_COEF;
+
+	return t->len;
+}
+
+/*!
+ * @brief Build PrP coefficient table based on average algorithm
+ *
+ * @param t	The pointer to scale_t structure
+ * @param inv	Input resolution
+ * @param outv	Output resolution
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int ave_scale(scale_t *t, int inv, int outv)
+{
+	int ratio_count;
+
+	ratio_count = 0;
+	if (outv != 1) {
+		unsigned char a[20];
+		int v;
+
+		/* split n:m into multiple n[i]:1 */
+		for (v = 0; v < outv; v++)
+			a[v] = (unsigned char)(inv / outv);
+
+		inv %= outv;
+		if (inv) {
+			/* find start of next layer */
+			v = (outv - inv) >> 1;
+			inv += v;
+			for (; v < inv; v++)
+				a[v]++;
+		}
+
+		for (v = 0; v < outv; v++) {
+			if (prp_scale_ave(t, a[v]) < 0)
+				return -1;
+
+			t->ratio[ratio_count] = a[v];
+			ratio_count++;
+		}
+	} else if (prp_scale_ave(t, inv) < 0) {
+		return -1;
+	} else {
+		t->ratio[ratio_count++] = (char)inv;
+		ratio_count++;
+	}
+
+	return t->len;
+}
+
+/*!
+ * @brief Build PrP coefficient table
+ *
+ * @param t	The pointer to scale_t structure
+ * @param inv	input resolution reduced ratio
+ * @param outv	output resolution reduced ratio
+ *
+ * @return	The length of current coefficient table on success
+ *		-1 on failure
+ */
+static int scale(scale_t *t, int inv, int outv)
+{
+	int v;			/* overflow counter */
+	int coeff, nxt;		/* table output */
+
+	t->len = 0;
+	if (t->algo == ALGO_AUTO) {
+		/* automatic choice - bilinear for shrinking less than 2:1 */
+		t->algo = ((outv != inv) && ((2 * outv) > inv)) ?
+		    ALGO_BIL : ALGO_AVG;
+	}
+
+	/* 1:1 resize must use averaging, bilinear will hang */
+	if ((inv == outv) && (t->algo == ALGO_BIL)) {
+		pr_debug("Warning: 1:1 resize must use averaging algo\n");
+		t->algo = ALGO_AVG;
+	}
+
+	memset(t->tbl, 0, sizeof(t->tbl));
+	if (t->algo == ALGO_BIL) {
+		t->ratio[0] = (char)inv;
+		t->ratio[1] = (char)outv;
+	} else
+		memset(t->ratio, 0, sizeof(t->ratio));
+
+	if (inv == outv) {
+		/* force scaling */
+		t->ratio[0] = 1;
+		if (t->algo == ALGO_BIL)
+			t->ratio[1] = 1;
+
+		return prp_scale_ave(t, 1);
+	}
+
+	if (inv < outv) {
+		pr_debug("Upscaling not supported %d:%d\n", inv, outv);
+		return -1;
+	}
+
+	if (t->algo != ALGO_BIL)
+		return ave_scale(t, inv, outv);
+
+	v = 0;
+	if (inv >= 2 * outv) {
+		/* downscale: >=2:1 bilinear approximation */
+		coeff = inv - 2 * outv;
+		v = 0;
+		nxt = 0;
+		do {
+			v += coeff;
+			nxt = 2;
+			while (v >= outv) {
+				v -= outv;
+				nxt++;
+			}
+
+			if (prp_scale_bilinear(t, 1, 2, nxt) < 0)
+				return -1;
+		} while (v);
+	} else {
+		/* downscale: bilinear */
+		int in_pos_inc = 2 * outv;
+		int out_pos = inv;
+		int out_pos_inc = 2 * inv;
+		int init_carry = inv - outv;
+		int carry = init_carry;
+
+		v = outv + in_pos_inc;
+		do {
+			coeff = v - out_pos;
+			out_pos += out_pos_inc;
+			carry += out_pos_inc;
+			for (nxt = 0; v < out_pos; nxt++) {
+				v += in_pos_inc;
+				carry -= in_pos_inc;
+			}
+			if (prp_scale_bilinear(t, coeff, in_pos_inc, nxt) < 0)
+				return -1;
+		} while (carry != init_carry);
+	}
+	return t->len;
+}
+
+/*!
+ * @brief Build PrP coefficient table
+ *
+ * @param pscale	The pointer to scale_t structure which holdes
+ * 			coefficient tables
+ * @param din		Scale ratio numerator
+ * @param dout		Scale ratio denominator
+ * @param inv		Input resolution
+ * @param vout		Output resolution
+ * @param pout		Internal output resolution
+ * @param retry		Retry times (round the output length) when need
+ *
+ * @return		Zero on success, others on failure
+ */
+int prp_scale(scale_t *pscale, int din, int dout, int inv,
+	      unsigned short *vout, unsigned short *pout, int retry)
+{
+	int num;
+	int den;
+	unsigned short outv;
+
+	/* auto-generation of values */
+	if (!(dout && din)) {
+		if (!*vout)
+			dout = din = 1;
+		else {
+			din = inv;
+			dout = *vout;
+		}
+	}
+
+	if (din < dout) {
+		pr_debug("Scale err, unsupported ratio %d : %d\n", din, dout);
+		return -1;
+	}
+
+lp_retry:
+	num = ratio(din, dout, &den);
+	if (!num) {
+		pr_debug("Scale err, unsupported ratio %d : %d\n", din, dout);
+		return -1;
+	}
+
+	if (num > MAX_TBL || scale(pscale, num, den) < 0) {
+		dout++;
+		if (retry--)
+			goto lp_retry;
+
+		pr_debug("Scale err, unsupported ratio %d : %d\n", num, den);
+		return -1;
+	}
+
+	if (pscale->algo == ALGO_BIL) {
+		unsigned char i, j, k;
+
+		outv =
+		    (unsigned short)(inv / pscale->ratio[0] * pscale->ratio[1]);
+		inv %= pscale->ratio[0];
+		for (i = j = 0; inv > 0; j++) {
+			unsigned char nxt;
+
+			k = scale_get(pscale, &i, &nxt);
+			if (inv == 1 && k < SZ_COEF) {
+				/* needs 2 pixels for this output */
+				break;
+			}
+			inv -= nxt;
+		}
+		outv = outv + j;
+	} else {
+		unsigned char i, tot;
+
+		for (tot = i = 0; pscale->ratio[i]; i++)
+			tot = tot + pscale->ratio[i];
+
+		outv = (unsigned short)(inv / tot) * i;
+		inv %= tot;
+		for (i = 0; inv > 0; i++, outv++)
+			inv -= pscale->ratio[i];
+	}
+
+	if (!(*vout) || ((*vout) > outv))
+		*vout = outv;
+
+	if (pout)
+		*pout = outv;
+
+	return 0;
+}
+
+/*!
+ * @brief Reset PrP block
+ */
+int prphw_reset(void)
+{
+	unsigned long val;
+	unsigned long flag;
+	int i;
+
+	flag = PRP_CNTL_RST;
+	val = PRP_CNTL_RSTVAL;
+
+	__raw_writel(flag, PRP_CNTL);
+
+	/* timeout */
+	for (i = 0; i < 1000; i++) {
+		if (!(__raw_readl(PRP_CNTL) & flag)) {
+			pr_debug("PrP reset over\n");
+			break;
+		}
+		msleep(1);
+	}
+
+	/* verify reset value */
+	if (__raw_readl(PRP_CNTL) != val) {
+		pr_info("PrP reset err, val = 0x%08X\n", __raw_readl(PRP_CNTL));
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Enable PrP channel.
+ * @param channel	Channel number to be enabled
+ * @return		Zero on success, others on failure
+ */
+int prphw_enable(int channel)
+{
+	unsigned long val;
+
+	val = __raw_readl(PRP_CNTL);
+	if (channel & PRP_CHANNEL_1)
+		val |= PRP_CNTL_CH1EN;
+	if (channel & PRP_CHANNEL_2)
+		val |= (PRP_CNTL_CH2EN | PRP_CNTL_CH2_FLOWEN);
+
+	__raw_writel(val, PRP_CNTL);
+
+	return 0;
+}
+
+/*!
+ * @brief Disable PrP channel.
+ * @param channel	Channel number to be disable
+ * @return		Zero on success, others on failure
+ */
+int prphw_disable(int channel)
+{
+	unsigned long val;
+
+	val = __raw_readl(PRP_CNTL);
+	if (channel & PRP_CHANNEL_1)
+		val &= ~PRP_CNTL_CH1EN;
+	if (channel & PRP_CHANNEL_2)
+		val &= ~(PRP_CNTL_CH2EN | PRP_CNTL_CH2_FLOWEN);
+
+	__raw_writel(val, PRP_CNTL);
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP input buffer address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_inptr(emma_prp_cfg *cfg)
+{
+	if (cfg->in_csi & PRP_CSI_EN)
+		return -1;
+
+	__raw_writel(cfg->in_ptr, PRP_SOURCE_Y_PTR);
+	if (cfg->in_pix == PRP_PIXIN_YUV420) {
+		u32 size;
+
+		size = cfg->in_line_stride * cfg->in_height;
+		__raw_writel(cfg->in_ptr + size, PRP_SOURCE_CB_PTR);
+		__raw_writel(cfg->in_ptr + size + (size >> 2),
+			     PRP_SOURCE_CR_PTR);
+	}
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 1 output buffer 1 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch1ptr(emma_prp_cfg *cfg)
+{
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED)
+		return -1;
+
+	__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB1_PTR);
+
+	/* support double buffer in loop mode only */
+	if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+		if (cfg->ch1_ptr2)
+			__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+		else
+			__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB2_PTR);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 1 output buffer 2 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch1ptr2(emma_prp_cfg *cfg)
+{
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED ||
+	    (cfg->in_csi & PRP_CSI_LOOP) != PRP_CSI_LOOP)
+		return -1;
+
+	if (cfg->ch1_ptr2)
+		__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+	else
+		return -1;
+
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 2 output buffer 1 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch2ptr(emma_prp_cfg *cfg)
+{
+	u32 size;
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED)
+		return -1;
+
+	__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr + size, PRP_DEST_CB_PTR);
+		__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+			     PRP_DEST_CR_PTR);
+	}
+
+	__raw_writel(__raw_readl(PRP_CNTL) | PRP_CNTL_CH2B1, PRP_CNTL);
+	return 0;
+}
+
+/*!
+ * @brief Set PrP channel 2 output buffer 2 address.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_ch2ptr2(emma_prp_cfg *cfg)
+{
+	u32 size;
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED ||
+	    (cfg->in_csi & PRP_CSI_LOOP) != PRP_CSI_LOOP)
+		return -1;
+
+	__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr2 + size, PRP_SOURCE_CB_PTR);
+		__raw_writel(cfg->ch2_ptr2 + size + (size >> 2),
+			     PRP_SOURCE_CR_PTR);
+	}
+
+	__raw_writel(__raw_readl(PRP_CNTL) | PRP_CNTL_CH2B2, PRP_CNTL);
+	return 0;
+}
+
+/*!
+ * @brief Build CSC table
+ * @param csc	CSC table
+ *		in	csc[0]=index		0..3 : A.1 A.0 B.1 B.0
+ *			csc[1]=direction	0 : YUV2RGB  1 : RGB2YUV
+ *		out	csc[0..4] are coefficients c[9] is offset
+ *			csc[0..8] are coefficients c[9] is offset
+ */
+void csc_tbl(short csc[10])
+{
+	static const unsigned short _r2y[][9] = {
+		{0x4D, 0x4B, 0x3A, 0x57, 0x55, 0x40, 0x40, 0x6B, 0x29},
+		{0x42, 0x41, 0x32, 0x4C, 0x4A, 0x38, 0x38, 0x5E, 0x24},
+		{0x36, 0x5C, 0x25, 0x3B, 0x63, 0x40, 0x40, 0x74, 0x18},
+		{0x2F, 0x4F, 0x20, 0x34, 0x57, 0x38, 0x38, 0x66, 0x15},
+	};
+	static const unsigned short _y2r[][5] = {
+		{0x80, 0xb4, 0x2c, 0x5b, 0x0e4},
+		{0x95, 0xcc, 0x32, 0x68, 0x104},
+		{0x80, 0xca, 0x18, 0x3c, 0x0ec},
+		{0x95, 0xe5, 0x1b, 0x44, 0x1e0},
+	};
+	unsigned short *_csc;
+	int _csclen;
+
+	csc[9] = csc[0] & 1;
+	_csclen = csc[0] & 3;
+
+	if (csc[1]) {
+		_csc = (unsigned short *)_r2y[_csclen];
+		_csclen = sizeof(_r2y[0]);
+	} else {
+		_csc = (unsigned short *)_y2r[_csclen];
+		_csclen = sizeof(_y2r[0]);
+		memset(csc + 5, 0, sizeof(short) * 4);
+	}
+	memcpy(csc, _csc, _csclen);
+}
+
+/*!
+ * @brief Setup PrP resize coefficient registers
+ *
+ * @param ch	PrP channel number
+ * @param dir	Direction, 0 - horizontal, 1 - vertical
+ * @param scale	The pointer to scale_t structure
+ */
+static void prp_set_scaler(int ch, int dir, scale_t *scale)
+{
+	int i;
+	unsigned int coeff[2];
+	unsigned int valid;
+
+	for (coeff[0] = coeff[1] = valid = 0, i = 19; i >= 0; i--) {
+		int j;
+
+		j = i > 9 ? 1 : 0;
+		coeff[j] = (coeff[j] << BC_COEF) |
+		    (scale->tbl[i] & (SZ_COEF - 1));
+
+		if (i == 5 || i == 15)
+			coeff[j] <<= 1;
+
+		valid = (valid << 1) | (scale->tbl[i] >> BC_COEF);
+	}
+
+	valid |= (scale->len << 24) | ((2 - scale->algo) << 31);
+
+	for (i = 0; i < 2; i++)
+		(*PRP_RSZ_COEFF)[1 - ch][dir].coeff[i] = coeff[i];
+
+	(*PRP_RSZ_COEFF)[1 - ch][dir].cntl = valid;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to input.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_input_cfg(emma_prp_cfg *cfg, unsigned long *prp_cntl)
+{
+	unsigned long mask;
+
+	switch (cfg->in_pix) {
+	case PRP_PIXIN_YUV420:
+		*prp_cntl |= PRP_CNTL_IN_YUV420;
+		mask = 0x7;
+		break;
+	case PRP_PIXIN_YUYV:
+	case PRP_PIXIN_YVYU:
+	case PRP_PIXIN_UYVY:
+	case PRP_PIXIN_VYUY:
+		*prp_cntl |= PRP_CNTL_IN_YUV422;
+		mask = 0x1;
+		break;
+	case PRP_PIXIN_RGB565:
+		*prp_cntl |= PRP_CNTL_IN_RGB16;
+		mask = 0x1;
+		break;
+	case PRP_PIXIN_RGB888:
+		*prp_cntl |= PRP_CNTL_IN_RGB32;
+		mask = 0;
+		break;
+	default:
+		pr_debug("Unsupported input pix format 0x%08X\n", cfg->in_pix);
+		return -1;
+	}
+
+	/* align the input image width */
+	if (cfg->in_width & mask) {
+		pr_debug("in_width misaligned. in_width=%d\n", cfg->in_width);
+		return -1;
+	}
+
+	if ((cfg->in_width < PRP_MIN_IN_WIDTH)
+	    || (cfg->in_width > PRP_MAX_IN_WIDTH)) {
+		pr_debug("Unsupported input width %d\n", cfg->in_width);
+		return -1;
+	}
+
+	cfg->in_height &= ~1;	/* truncate to make even */
+
+	if ((cfg->in_height < PRP_MIN_IN_HEIGHT)
+	    || (cfg->in_height > PRP_MAX_IN_HEIGHT)) {
+		pr_debug("Unsupported input height %d\n", cfg->in_height);
+		return -1;
+	}
+
+	if (!(cfg->in_csi & PRP_CSI_EN))
+		if (!cfg->in_line_stride)
+			cfg->in_line_stride = cfg->in_width;
+
+	__raw_writel(cfg->in_pix, PRP_SRC_PIXEL_FORMAT_CNTL);
+	__raw_writel((cfg->in_width << 16) | cfg->in_height,
+		     PRP_SOURCE_FRAME_SIZE);
+	__raw_writel((cfg->in_line_skip << 16) | cfg->in_line_stride,
+		     PRP_SOURCE_LINE_STRIDE);
+
+	if (!(cfg->in_csi & PRP_CSI_EN)) {
+		__raw_writel(cfg->in_ptr, PRP_SOURCE_Y_PTR);
+		if (cfg->in_pix == PRP_PIXIN_YUV420) {
+			unsigned int size;
+
+			size = cfg->in_line_stride * cfg->in_height;
+			__raw_writel(cfg->in_ptr + size, PRP_SOURCE_CB_PTR);
+			__raw_writel(cfg->in_ptr + size + (size >> 2),
+				     PRP_SOURCE_CR_PTR);
+		}
+	}
+
+	/* always cropping */
+	*prp_cntl |= PRP_CNTL_WINEN;
+
+	/* color space conversion */
+	if (!cfg->in_csc[1]) {
+		if (cfg->in_csc[0] > 3) {
+			pr_debug("in_csc invalid 0x%X\n", cfg->in_csc[0]);
+			return -1;
+		}
+		if ((cfg->in_pix == PRP_PIXIN_RGB565)
+		    || (cfg->in_pix == PRP_PIXIN_RGB888))
+			cfg->in_csc[1] = 1;
+		else
+			cfg->in_csc[0] = 0;
+		csc_tbl(cfg->in_csc);
+	}
+
+	__raw_writel((cfg->in_csc[0] << 21) | (cfg->in_csc[1] << 11)
+		     | cfg->in_csc[2], PRP_CSC_COEF_012);
+	__raw_writel((cfg->in_csc[3] << 21) | (cfg->in_csc[4] << 11)
+		     | cfg->in_csc[5], PRP_CSC_COEF_345);
+	__raw_writel((cfg->in_csc[6] << 21) | (cfg->in_csc[7] << 11)
+		     | cfg->in_csc[8] | (cfg->in_csc[9] << 31),
+		     PRP_CSC_COEF_678);
+
+	if (cfg->in_csi & PRP_CSI_EN) {
+		*prp_cntl |= PRP_CNTL_CSI;
+
+		/* loop mode enable, ch1 ch2 together */
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP)
+			*prp_cntl |= (PRP_CNTL_CH1_LOOP | PRP_CNTL_CH2_LOOP);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to channel 2.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_ch2_cfg(emma_prp_cfg *cfg, unsigned long *prp_cntl)
+{
+	switch (cfg->ch2_pix) {
+	case PRP_PIX2_YUV420:
+		*prp_cntl |= PRP_CNTL_CH2_YUV420;
+		break;
+	case PRP_PIX2_YUV422:
+		*prp_cntl |= PRP_CNTL_CH2_YUV422;
+		break;
+	case PRP_PIX2_YUV444:
+		*prp_cntl |= PRP_CNTL_CH2_YUV444;
+		break;
+	case PRP_PIX2_UNUSED:
+		return 0;
+	default:
+		pr_debug("Unsupported channel 2 pix format 0x%08X\n",
+			 cfg->ch2_pix);
+		return -1;
+	}
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		cfg->ch2_height &= ~1;	/* ensure U/V presence */
+		cfg->ch2_width &= ~7;	/* ensure U/V word aligned */
+	} else if (cfg->ch2_pix == PRP_PIX2_YUV422) {
+		cfg->ch2_width &= ~1;	/* word aligned */
+	}
+
+	__raw_writel((cfg->ch2_width << 16) | cfg->ch2_height,
+		     PRP_CH2_OUT_IMAGE_SIZE);
+
+	if (cfg->ch2_pix == PRP_PIX2_YUV420) {
+		u32 size;
+
+		/* Luminanance band start address */
+		__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2)
+				__raw_writel(cfg->ch2_ptr, PRP_SOURCE_Y_PTR);
+			else
+				__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+		}
+
+		/* Cb and Cr band start address */
+		size = cfg->ch2_width * cfg->ch2_height;
+		__raw_writel(cfg->ch2_ptr + size, PRP_DEST_CB_PTR);
+		__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+			     PRP_DEST_CR_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2) {
+				__raw_writel(cfg->ch2_ptr + size,
+					     PRP_SOURCE_CB_PTR);
+				__raw_writel(cfg->ch2_ptr + size + (size >> 2),
+					     PRP_SOURCE_CR_PTR);
+			} else {
+				__raw_writel(cfg->ch2_ptr2 + size,
+					     PRP_SOURCE_CB_PTR);
+				__raw_writel(cfg->ch2_ptr2 + size + (size >> 2),
+					     PRP_SOURCE_CR_PTR);
+			}
+		}
+	} else {		/* Pixel interleaved YUV422 or YUV444 */
+		__raw_writel(cfg->ch2_ptr, PRP_DEST_Y_PTR);
+
+		if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+			if (!cfg->ch2_ptr2)
+				__raw_writel(cfg->ch2_ptr, PRP_SOURCE_Y_PTR);
+			else
+				__raw_writel(cfg->ch2_ptr2, PRP_SOURCE_Y_PTR);
+		}
+	}
+	*prp_cntl |= PRP_CNTL_CH2B1 | PRP_CNTL_CH2B2;
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers relevant to channel 1.
+ * @param cfg		Pointer to PrP configuration parameter
+ * @param prp_cntl	Holds the value for PrP control register
+ * @return		Zero on success, others on failure
+ */
+static int prphw_ch1_cfg(emma_prp_cfg *cfg, unsigned long *prp_cntl)
+{
+	int ch1_bpp = 0;
+
+	switch (cfg->ch1_pix) {
+	case PRP_PIX1_RGB332:
+		*prp_cntl |= PRP_CNTL_CH1_RGB8;
+		ch1_bpp = 1;
+		break;
+	case PRP_PIX1_RGB565:
+		*prp_cntl |= PRP_CNTL_CH1_RGB16;
+		ch1_bpp = 2;
+		break;
+	case PRP_PIX1_RGB888:
+		*prp_cntl |= PRP_CNTL_CH1_RGB32;
+		ch1_bpp = 4;
+		break;
+	case PRP_PIX1_YUYV:
+	case PRP_PIX1_YVYU:
+	case PRP_PIX1_UYVY:
+	case PRP_PIX1_VYUY:
+		*prp_cntl |= PRP_CNTL_CH1_YUV422;
+		ch1_bpp = 2;
+		break;
+	case PRP_PIX1_UNUSED:
+		return 0;
+	default:
+		pr_debug("Unsupported channel 1 pix format 0x%08X\n",
+			 cfg->ch1_pix);
+		return -1;
+	}
+
+	/* parallel or cascade resize */
+	if (cfg->ch1_scale.algo & PRP_ALGO_BYPASS)
+		*prp_cntl |= PRP_CNTL_UNCHAIN;
+
+	/* word align */
+	if (ch1_bpp == 2)
+		cfg->ch1_width &= ~1;
+	else if (ch1_bpp == 1)
+		cfg->ch1_width &= ~3;
+
+	if (!cfg->ch1_stride)
+		cfg->ch1_stride = cfg->ch1_width;
+
+	__raw_writel(cfg->ch1_pix, PRP_CH1_PIXEL_FORMAT_CNTL);
+	__raw_writel((cfg->ch1_width << 16) | cfg->ch1_height,
+		     PRP_CH1_OUT_IMAGE_SIZE);
+	__raw_writel(cfg->ch1_stride * ch1_bpp, PRP_CH1_LINE_STRIDE);
+	__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB1_PTR);
+
+	/* double buffer for loop mode */
+	if ((cfg->in_csi & PRP_CSI_LOOP) == PRP_CSI_LOOP) {
+		if (cfg->ch1_ptr2)
+			__raw_writel(cfg->ch1_ptr2, PRP_DEST_RGB2_PTR);
+		else
+			__raw_writel(cfg->ch1_ptr, PRP_DEST_RGB2_PTR);
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP registers.
+ * @param cfg	Pointer to PrP configuration parameter
+ * @return	Zero on success, others on failure
+ */
+int prphw_cfg(emma_prp_cfg *cfg)
+{
+	unsigned long prp_cntl = 0;
+	unsigned long val;
+
+	/* input pixel format checking */
+	if (prphw_input_cfg(cfg, &prp_cntl))
+		return -1;
+
+	if (prphw_ch2_cfg(cfg, &prp_cntl))
+		return -1;
+
+	if (prphw_ch1_cfg(cfg, &prp_cntl))
+		return -1;
+
+	/* register setting */
+	__raw_writel(prp_cntl, PRP_CNTL);
+
+	/* interrupt configuration */
+	val = PRP_INTRCNTL_RDERR | PRP_INTRCNTL_LBOVF;
+	if (cfg->ch1_pix != PRP_PIX1_UNUSED)
+		val |= PRP_INTRCNTL_CH1FC | PRP_INTRCNTL_CH1WERR;
+	if (cfg->ch2_pix != PRP_PIX2_UNUSED)
+		val |=
+		    PRP_INTRCNTL_CH2FC | PRP_INTRCNTL_CH2WERR |
+		    PRP_INTRCNTL_CH2OVF;
+	__raw_writel(val, PRP_INTRCNTL);
+
+	prp_set_scaler(1, 0, &cfg->scale[0]);	/* Channel 1 width */
+	prp_set_scaler(1, 1, &cfg->scale[1]);	/* Channel 1 height */
+	prp_set_scaler(0, 0, &cfg->scale[2]);	/* Channel 2 width */
+	prp_set_scaler(0, 1, &cfg->scale[3]);	/* Channel 2 height */
+
+	return 0;
+}
+
+/*!
+ * @brief Check PrP interrupt status.
+ * @return	PrP interrupt status
+ */
+int prphw_isr(void)
+{
+	int status;
+
+	status = __raw_readl(PRP_INTRSTATUS) & 0x1FF;
+
+	if (status & (PRP_INTRSTAT_RDERR | PRP_INTRSTAT_CH1WERR |
+		      PRP_INTRSTAT_CH2WERR))
+		pr_debug("isr bus error. status= 0x%08X\n", status);
+	else if (status & PRP_INTRSTAT_CH2OVF)
+		pr_debug("isr ch 2 buffer overflow. status= 0x%08X\n", status);
+	else if (status & PRP_INTRSTAT_LBOVF)
+		pr_debug("isr line buffer overflow. status= 0x%08X\n", status);
+
+	/* silicon bug?? enable bit does not self clear? */
+	if (!(__raw_readl(PRP_CNTL) & PRP_CNTL_CH1_LOOP))
+		__raw_writel(__raw_readl(PRP_CNTL) & (~PRP_CNTL_CH1EN),
+			     PRP_CNTL);
+	if (!(__raw_readl(PRP_CNTL) & PRP_CNTL_CH2_LOOP))
+		__raw_writel(__raw_readl(PRP_CNTL) & (~PRP_CNTL_CH2EN),
+			     PRP_CNTL);
+
+	__raw_writel(status, PRP_INTRSTATUS);	/* clr irq */
+
+	return status;
+}
+
+static struct clk *emma_clk;
+
+/*!
+ * @brief  PrP module clock enable
+ */
+void prphw_init(void)
+{
+	emma_clk = clk_get(NULL, "emma_clk");
+	clk_enable(emma_clk);
+}
+
+/*!
+ * @brief PrP module clock disable
+ */
+void prphw_exit(void)
+{
+	clk_disable(emma_clk);
+	clk_put(emma_clk);
+}
diff --git a/drivers/media/video/mxc/capture/mx27_prpsw.c b/drivers/media/video/mxc/capture/mx27_prpsw.c
new file mode 100644
index 0000000..e56a6b0
--- /dev/null
+++ b/drivers/media/video/mxc/capture/mx27_prpsw.c
@@ -0,0 +1,1014 @@
+/*
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mx27_prpsw.c
+ *
+ * @brief MX27 Video For Linux 2 capture driver
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/fb.h>
+#include <linux/pci.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mxc_v4l2_capture.h"
+#include "mx27_prp.h"
+#include "mx27_csi.h"
+#include "../opl/opl.h"
+
+#define MEAN_COEF	(SZ_COEF >> 1)
+
+static char prp_dev[] = "emma_prp";
+static int g_still_on;
+static emma_prp_cfg g_prp_cfg;
+static int g_vfbuf, g_rotbuf;
+static struct tasklet_struct prp_vf_tasklet;
+
+/*
+ * The following variables represents the virtual address for the cacheable
+ * buffers accessed by SW rotation/mirroring. The rotation/mirroring in
+ * cacheable buffers has significant performance improvement than it in
+ * non-cacheable buffers.
+ */
+static char *g_vaddr_vfbuf[2] = { 0, 0 };
+static char *g_vaddr_rotbuf[2] = { 0, 0 };
+static char *g_vaddr_fb;
+
+static int set_ch1_addr(emma_prp_cfg *cfg, cam_data *cam);
+static int prp_v4l2_cfg(emma_prp_cfg *cfg, cam_data *cam);
+static int prp_vf_mem_alloc(cam_data *cam);
+static void prp_vf_mem_free(cam_data *cam);
+static int prp_rot_mem_alloc(cam_data *cam);
+static void prp_rot_mem_free(cam_data *cam);
+static int prp_enc_update_eba(u32 eba, int *buffer_num);
+static int prp_enc_enable(void *private);
+static int prp_enc_disable(void *private);
+static int prp_vf_start(void *private);
+static int prp_vf_stop(void *private);
+static int prp_still_start(void *private);
+static int prp_still_stop(void *private);
+static irqreturn_t prp_isr(int irq, void *dev_id);
+static void rotation(unsigned long private);
+static int prp_resize_check_ch1(emma_prp_cfg *cfg);
+static int prp_resize_check_ch2(emma_prp_cfg *cfg);
+
+#define PRP_DUMP(val)	pr_debug("%s\t = 0x%08X\t%d\n", #val, val, val)
+
+/*!
+ * @brief Dump PrP configuration parameters.
+ * @param cfg	The pointer to PrP configuration parameter
+ */
+static void prp_cfg_dump(emma_prp_cfg *cfg)
+{
+	PRP_DUMP(cfg->in_pix);
+	PRP_DUMP(cfg->in_width);
+	PRP_DUMP(cfg->in_height);
+	PRP_DUMP(cfg->in_csi);
+	PRP_DUMP(cfg->in_line_stride);
+	PRP_DUMP(cfg->in_line_skip);
+	PRP_DUMP(cfg->in_ptr);
+
+	PRP_DUMP(cfg->ch1_pix);
+	PRP_DUMP(cfg->ch1_width);
+	PRP_DUMP(cfg->ch1_height);
+	PRP_DUMP(cfg->ch1_scale.algo);
+	PRP_DUMP(cfg->ch1_scale.width.num);
+	PRP_DUMP(cfg->ch1_scale.width.den);
+	PRP_DUMP(cfg->ch1_scale.height.num);
+	PRP_DUMP(cfg->ch1_scale.height.den);
+	PRP_DUMP(cfg->ch1_stride);
+	PRP_DUMP(cfg->ch1_ptr);
+	PRP_DUMP(cfg->ch1_ptr2);
+	PRP_DUMP(cfg->ch1_csi);
+
+	PRP_DUMP(cfg->ch2_pix);
+	PRP_DUMP(cfg->ch2_width);
+	PRP_DUMP(cfg->ch2_height);
+	PRP_DUMP(cfg->ch2_scale.algo);
+	PRP_DUMP(cfg->ch2_scale.width.num);
+	PRP_DUMP(cfg->ch2_scale.width.den);
+	PRP_DUMP(cfg->ch2_scale.height.num);
+	PRP_DUMP(cfg->ch2_scale.height.den);
+	PRP_DUMP(cfg->ch2_ptr);
+	PRP_DUMP(cfg->ch2_ptr2);
+	PRP_DUMP(cfg->ch2_csi);
+}
+
+/*!
+ * @brief Set PrP channel 1 output address.
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int set_ch1_addr(emma_prp_cfg *cfg, cam_data *cam)
+{
+	if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+		cfg->ch1_ptr = (unsigned int)cam->rot_vf_bufs[0];
+		cfg->ch1_ptr2 = (unsigned int)cam->rot_vf_bufs[1];
+		if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT))
+			cfg->ch1_stride = cam->win.w.height;
+		else
+			cfg->ch1_stride = cam->win.w.width;
+
+		if (cam->v4l2_fb.flags != V4L2_FBUF_FLAG_OVERLAY) {
+			struct fb_info *fb = cam->overlay_fb;
+			if (!fb)
+				return -1;
+			if (g_vaddr_fb)
+				iounmap(g_vaddr_fb);
+			g_vaddr_fb = ioremap_cached(fb->fix.smem_start,
+						    fb->fix.smem_len);
+			if (!g_vaddr_fb)
+				return -1;
+		}
+	} else if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		cfg->ch1_ptr = (unsigned int)cam->vf_bufs[0];
+		cfg->ch1_ptr2 = (unsigned int)cam->vf_bufs[1];
+		cfg->ch1_stride = cam->win.w.width;
+	} else {
+		struct fb_info *fb = cam->overlay_fb;
+
+		if (!fb)
+			return -1;
+
+		cfg->ch1_ptr = fb->fix.smem_start;
+		cfg->ch1_ptr += cam->win.w.top * fb->var.xres_virtual
+		    * (fb->var.bits_per_pixel >> 3)
+		    + cam->win.w.left * (fb->var.bits_per_pixel >> 3);
+		cfg->ch1_ptr2 = cfg->ch1_ptr;
+		cfg->ch1_stride = fb->var.xres_virtual;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup PrP configuration parameters.
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_v4l2_cfg(emma_prp_cfg *cfg, cam_data *cam)
+{
+	cfg->in_pix = PRP_PIXIN_YUYV;
+	cfg->in_width = cam->crop_current.width;
+	cfg->in_height = cam->crop_current.height;
+	cfg->in_line_stride = cam->crop_current.left;
+	cfg->in_line_skip = cam->crop_current.top;
+	cfg->in_ptr = 0;
+	cfg->in_csi = PRP_CSI_LOOP;
+	memset(cfg->in_csc, 0, sizeof(cfg->in_csc));
+
+	if (cam->overlay_on) {
+		/* Convert V4L2 pixel format to PrP pixel format */
+		switch (cam->v4l2_fb.fmt.pixelformat) {
+		case V4L2_PIX_FMT_RGB332:
+			cfg->ch1_pix = PRP_PIX1_RGB332;
+			break;
+		case V4L2_PIX_FMT_RGB32:
+		case V4L2_PIX_FMT_BGR32:
+			cfg->ch1_pix = PRP_PIX1_RGB888;
+			break;
+		case V4L2_PIX_FMT_YUYV:
+			cfg->ch1_pix = PRP_PIX1_YUYV;
+			break;
+		case V4L2_PIX_FMT_UYVY:
+			cfg->ch1_pix = PRP_PIX1_UYVY;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+		default:
+			cfg->ch1_pix = PRP_PIX1_RGB565;
+			break;
+		}
+		if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+		    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT)) {
+			cfg->ch1_width = cam->win.w.height;
+			cfg->ch1_height = cam->win.w.width;
+		} else {
+			cfg->ch1_width = cam->win.w.width;
+			cfg->ch1_height = cam->win.w.height;
+		}
+
+		if (set_ch1_addr(cfg, cam))
+			return -1;
+	} else {
+		cfg->ch1_pix = PRP_PIX1_UNUSED;
+		cfg->ch1_width = cfg->in_width;
+		cfg->ch1_height = cfg->in_height;
+	}
+	cfg->ch1_scale.algo = 0;
+	cfg->ch1_scale.width.num = cfg->in_width;
+	cfg->ch1_scale.width.den = cfg->ch1_width;
+	cfg->ch1_scale.height.num = cfg->in_height;
+	cfg->ch1_scale.height.den = cfg->ch1_height;
+	cfg->ch1_csi = PRP_CSI_EN;
+
+	if (cam->capture_on || g_still_on) {
+		switch (cam->v2f.fmt.pix.pixelformat) {
+		case V4L2_PIX_FMT_YUYV:
+			cfg->ch2_pix = PRP_PIX2_YUV422;
+			break;
+		case V4L2_PIX_FMT_YUV420:
+			cfg->ch2_pix = PRP_PIX2_YUV420;
+			break;
+			/*
+			 * YUV444 is not defined by V4L2.
+			 * We support it in default case.
+			 */
+		default:
+			cfg->ch2_pix = PRP_PIX2_YUV444;
+			break;
+		}
+		cfg->ch2_width = cam->v2f.fmt.pix.width;
+		cfg->ch2_height = cam->v2f.fmt.pix.height;
+	} else {
+		cfg->ch2_pix = PRP_PIX2_UNUSED;
+		cfg->ch2_width = cfg->in_width;
+		cfg->ch2_height = cfg->in_height;
+	}
+	cfg->ch2_scale.algo = 0;
+	cfg->ch2_scale.width.num = cfg->in_width;
+	cfg->ch2_scale.width.den = cfg->ch2_width;
+	cfg->ch2_scale.height.num = cfg->in_height;
+	cfg->ch2_scale.height.den = cfg->ch2_height;
+	cfg->ch2_csi = PRP_CSI_EN;
+
+	memset(cfg->scale, 0, sizeof(cfg->scale));
+	cfg->scale[0].algo = cfg->ch1_scale.algo & 3;
+	cfg->scale[1].algo = (cfg->ch1_scale.algo >> 2) & 3;
+	cfg->scale[2].algo = cfg->ch2_scale.algo & 3;
+	cfg->scale[3].algo = (cfg->ch2_scale.algo >> 2) & 3;
+
+	prp_cfg_dump(cfg);
+
+	if (prp_resize_check_ch2(cfg))
+		return -1;
+
+	if (prp_resize_check_ch1(cfg))
+		return -1;
+
+	return 0;
+}
+
+/*!
+ * @brief PrP interrupt handler
+ */
+static irqreturn_t prp_isr(int irq, void *dev_id)
+{
+	int status;
+	cam_data *cam = (cam_data *) dev_id;
+
+	status = prphw_isr();
+
+	if (g_still_on && (status & PRP_INTRSTAT_CH2BUF1)) {
+		prp_still_stop(cam);
+		cam->still_counter++;
+		wake_up_interruptible(&cam->still_queue);
+		/*
+		 * Still & video capture use the same PrP channel 2.
+		 * They are execlusive.
+		 */
+	} else if (cam->capture_on) {
+		if (status & (PRP_INTRSTAT_CH2BUF1 | PRP_INTRSTAT_CH2BUF2))
+			cam->enc_callback(0, cam);
+	}
+	if (cam->overlay_on
+	    && (status & (PRP_INTRSTAT_CH1BUF1 | PRP_INTRSTAT_CH1BUF2))) {
+		if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+			g_rotbuf = (status & PRP_INTRSTAT_CH1BUF1) ? 0 : 1;
+			tasklet_schedule(&prp_vf_tasklet);
+		} else if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+			/*
+			  TODO: add graphic window operation in future.
+			 */
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * @brief PrP initialization.
+ * @param dev_id	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_init(void *dev_id)
+{
+	enable_irq(MXC_INT_EMMAPRP);
+	if (request_irq(MXC_INT_EMMAPRP, prp_isr, 0, prp_dev, dev_id))
+		return -1;
+	prphw_init();
+
+	return 0;
+}
+
+/*!
+ * @brief PrP initialization.
+ * @param dev_id	Pointer to cam_data structure
+ */
+void prp_exit(void *dev_id)
+{
+	prphw_exit();
+	disable_irq(MXC_INT_EMMAPRP);
+	free_irq(MXC_INT_EMMAPRP, dev_id);
+}
+
+/*!
+ * @brief Update PrP channel 2 output buffer address.
+ * @param eba		Physical address for PrP output buffer
+ * @param buffer_num	The PrP channel 2 buffer number to be updated
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_update_eba(u32 eba, int *buffer_num)
+{
+	if (*buffer_num) {
+		g_prp_cfg.ch2_ptr2 = eba;
+		prphw_ch2ptr2(&g_prp_cfg);
+		*buffer_num = 0;
+	} else {
+		g_prp_cfg.ch2_ptr = eba;
+		prphw_ch2ptr(&g_prp_cfg);
+		*buffer_num = 1;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Enable PrP for encoding.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_enable(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam))
+		return -1;
+
+	csi_enable_mclk(CSI_MCLK_ENC, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg))
+		return -1;
+
+	prphw_enable(cam->overlay_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_2);
+
+	return 0;
+}
+
+/*!
+ * @brief Disable PrP for encoding.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_enc_disable(void *private)
+{
+	prphw_disable(PRP_CHANNEL_2);
+	csi_enable_mclk(CSI_MCLK_ENC, false, false);
+
+	return 0;
+}
+
+/*!
+ * @brief Setup encoding functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_enc_select(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->enc_update_eba = prp_enc_update_eba;
+		cam->enc_enable = prp_enc_enable;
+		cam->enc_disable = prp_enc_disable;
+	} else
+		ret = -EIO;
+
+	return ret;
+}
+
+/*!
+ * @brief Uninstall encoding functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_enc_deselect(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	ret = prp_enc_disable(private);
+
+	if (cam) {
+		cam->enc_update_eba = NULL;
+		cam->enc_enable = NULL;
+		cam->enc_disable = NULL;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Allocate memory for overlay.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_vf_mem_alloc(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		cam->vf_bufs_size[i] = cam->win.w.width * cam->win.w.height * 2;
+		cam->vf_bufs_vaddr[i] = dma_alloc_coherent(0,
+							   cam->vf_bufs_size[i],
+							   &cam->vf_bufs[i],
+							   GFP_DMA |
+							   GFP_KERNEL);
+		if (!cam->vf_bufs_vaddr[i]) {
+			pr_debug("Failed to alloc memory for vf.\n");
+			prp_vf_mem_free(cam);
+			return -1;
+		}
+
+		g_vaddr_vfbuf[i] =
+		    ioremap_cached(cam->vf_bufs[i], cam->vf_bufs_size[i]);
+		if (!g_vaddr_vfbuf[i]) {
+			pr_debug("Failed to ioremap_cached() for vf.\n");
+			prp_vf_mem_free(cam);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Free memory for overlay.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static void prp_vf_mem_free(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (cam->vf_bufs_vaddr[i]) {
+			dma_free_coherent(0,
+					  cam->vf_bufs_size[i],
+					  cam->vf_bufs_vaddr[i],
+					  cam->vf_bufs[i]);
+		}
+		cam->vf_bufs[i] = 0;
+		cam->vf_bufs_vaddr[i] = 0;
+		cam->vf_bufs_size[i] = 0;
+		if (g_vaddr_vfbuf[i]) {
+			iounmap(g_vaddr_vfbuf[i]);
+			g_vaddr_vfbuf[i] = 0;
+		}
+	}
+}
+
+/*!
+ * @brief Allocate intermediate memory for overlay rotation/mirroring.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_rot_mem_alloc(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		cam->rot_vf_buf_size[i] =
+		    cam->win.w.width * cam->win.w.height * 2;
+		cam->rot_vf_bufs_vaddr[i] =
+		    dma_alloc_coherent(0, cam->rot_vf_buf_size[i],
+				       &cam->rot_vf_bufs[i],
+				       GFP_DMA | GFP_KERNEL);
+		if (!cam->rot_vf_bufs_vaddr[i]) {
+			pr_debug("Failed to alloc memory for vf rotation.\n");
+			prp_rot_mem_free(cam);
+			return -1;
+		}
+
+		g_vaddr_rotbuf[i] =
+		    ioremap_cached(cam->rot_vf_bufs[i],
+				   cam->rot_vf_buf_size[i]);
+		if (!g_vaddr_rotbuf[i]) {
+			pr_debug
+			    ("Failed to ioremap_cached() for rotation buffer.\n");
+			prp_rot_mem_free(cam);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Free intermedaite memory for overlay rotation/mirroring.
+ * @param cam	Pointer to cam_data structure
+ * @return	Zero on success, others on failure
+ */
+static void prp_rot_mem_free(cam_data *cam)
+{
+	int i;
+
+	for (i = 0; i < 2; i++) {
+		if (cam->rot_vf_bufs_vaddr[i]) {
+			dma_free_coherent(0,
+					  cam->rot_vf_buf_size[i],
+					  cam->rot_vf_bufs_vaddr[i],
+					  cam->rot_vf_bufs[i]);
+		}
+		cam->rot_vf_bufs[i] = 0;
+		cam->rot_vf_bufs_vaddr[i] = 0;
+		cam->rot_vf_buf_size[i] = 0;
+		if (g_vaddr_rotbuf[i]) {
+			iounmap(g_vaddr_rotbuf[i]);
+			g_vaddr_rotbuf[i] = 0;
+		}
+	}
+}
+
+/*!
+ * @brief Start overlay (view finder).
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_vf_start(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		prp_vf_mem_free(cam);
+		if (prp_vf_mem_alloc(cam)) {
+			pr_info("Error to allocate vf buffer\n");
+			return -ENOMEM;
+		}
+	}
+
+	if (cam->rotation != V4L2_MXC_ROTATE_NONE) {
+		prp_rot_mem_free(cam);
+		if (prp_rot_mem_alloc(cam)) {
+			pr_info("Error to allocate rotation buffer\n");
+			prp_vf_mem_free(cam);
+			return -ENOMEM;
+		}
+	}
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam)) {
+		prp_vf_mem_free(cam);
+		prp_rot_mem_free(cam);
+		return -1;
+	}
+
+	csi_enable_mclk(CSI_MCLK_VF, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg)) {
+		prp_vf_mem_free(cam);
+		prp_rot_mem_free(cam);
+		return -1;
+	}
+	g_vfbuf = g_rotbuf = 0;
+	tasklet_init(&prp_vf_tasklet, rotation, (unsigned long)private);
+
+	prphw_enable(cam->capture_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_1);
+
+	return 0;
+}
+
+/*!
+ * @brief Stop overlay (view finder).
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_vf_stop(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	prphw_disable(PRP_CHANNEL_1);
+
+	csi_enable_mclk(CSI_MCLK_VF, false, false);
+	tasklet_kill(&prp_vf_tasklet);
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		/*
+		  TODO: add disable graphic window in future.
+		 */
+		prp_vf_mem_free(cam);
+	}
+	prp_rot_mem_free(cam);
+	if (g_vaddr_fb) {
+		iounmap(g_vaddr_fb);
+		g_vaddr_fb = 0;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Setup overlay functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_vf_select(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->vf_start_sdc = prp_vf_start;
+		cam->vf_stop_sdc = prp_vf_stop;
+		cam->overlay_active = false;
+	} else
+		ret = -EIO;
+
+	return ret;
+}
+
+/*!
+ * @brief Uninstall overlay functions.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_vf_deselect(void *private)
+{
+	int ret = 0;
+	cam_data *cam = (cam_data *) private;
+
+	ret = prp_vf_stop(private);
+
+	if (cam) {
+		cam->vf_start_sdc = NULL;
+		cam->vf_stop_sdc = NULL;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Start still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_still_start(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	g_still_on = 1;
+	g_prp_cfg.ch2_ptr = (unsigned int)cam->still_buf;
+	g_prp_cfg.ch2_ptr2 = 0;
+
+	if (prp_v4l2_cfg(&g_prp_cfg, cam))
+		return -1;
+
+	csi_enable_mclk(CSI_MCLK_RAW, true, true);
+	prphw_reset();
+
+	if (prphw_cfg(&g_prp_cfg)) {
+		g_still_on = 0;
+		return -1;
+	}
+
+	prphw_enable(cam->overlay_on ? (PRP_CHANNEL_1 | PRP_CHANNEL_2)
+		     : PRP_CHANNEL_2);
+
+	return 0;
+}
+
+/*!
+ * @brief Stop still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+static int prp_still_stop(void *private)
+{
+	prphw_disable(PRP_CHANNEL_2);
+
+	csi_enable_mclk(CSI_MCLK_RAW, false, false);
+
+	g_still_on = 0;
+
+	return 0;
+}
+
+/*!
+ * @brief Setup functions for still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_still_select(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+
+	if (cam) {
+		cam->csi_start = prp_still_start;
+		cam->csi_stop = prp_still_stop;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Uninstall functions for still picture capture.
+ * @param private	Pointer to cam_data structure
+ * @return		Zero on success, others on failure
+ */
+int prp_still_deselect(void *private)
+{
+	cam_data *cam = (cam_data *) private;
+	int err = 0;
+
+	err = prp_still_stop(cam);
+
+	if (cam) {
+		cam->csi_start = NULL;
+		cam->csi_stop = NULL;
+	}
+
+	return err;
+}
+
+/*!
+ * @brief Perform software rotation or mirroring
+ * @param private	Argument passed to the tasklet
+ */
+static void rotation(unsigned long private)
+{
+	char *src, *dst;
+	int width, height, s_stride, d_stride;
+	int size;
+	cam_data *cam = (cam_data *) private;
+
+	src = g_vaddr_rotbuf[g_rotbuf];
+	size = cam->rot_vf_buf_size[g_rotbuf];
+
+	if ((cam->rotation == V4L2_MXC_ROTATE_90_RIGHT)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_VFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_RIGHT_HFLIP)
+	    || (cam->rotation == V4L2_MXC_ROTATE_90_LEFT)) {
+		width = cam->win.w.height;
+		height = cam->win.w.width;
+		s_stride = cam->win.w.height << 1;
+	} else {
+		width = cam->win.w.width;
+		height = cam->win.w.height;
+		s_stride = cam->win.w.width << 1;
+	}
+
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		dst = g_vaddr_vfbuf[g_vfbuf];
+		d_stride = cam->win.w.width << 1;
+	} else {		/* The destination is the framebuffer */
+		struct fb_info *fb = cam->overlay_fb;
+		if (!fb)
+			return;
+		dst = g_vaddr_fb;
+		dst += cam->win.w.top * fb->var.xres_virtual
+		    * (fb->var.bits_per_pixel >> 3)
+		    + cam->win.w.left * (fb->var.bits_per_pixel >> 3);
+		d_stride = fb->var.xres_virtual << 1;
+	}
+
+	/*
+	 * Invalidate the data in cache before performing the SW rotaion
+	 * or mirroring in case the image size is less than QVGA. For image
+	 * larger than QVGA it is not invalidated becase the invalidation
+	 * will consume much time while we don't see any artifacts on the
+	 * output if we don't perform invalidation for them.
+	 * Similarly we don't flush the data after SW rotation/mirroring.
+	 */
+	if (size < 320 * 240 * 2)
+		dmac_inv_range(src, src + size);
+	switch (cam->rotation) {
+	case V4L2_MXC_ROTATE_VERT_FLIP:
+		opl_vmirror_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_HORIZ_FLIP:
+		opl_hmirror_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_180:
+		opl_rotate180_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT:
+		opl_rotate90_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT_VFLIP:
+		opl_rotate90_vmirror_u16(src, s_stride, width, height, dst,
+					 d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_RIGHT_HFLIP:
+		/* ROTATE_90_RIGHT_HFLIP = ROTATE_270_RIGHT_VFLIP */
+		opl_rotate270_vmirror_u16(src, s_stride, width, height, dst,
+					  d_stride);
+		break;
+	case V4L2_MXC_ROTATE_90_LEFT:
+		opl_rotate270_u16(src, s_stride, width, height, dst, d_stride);
+		break;
+	default:
+		return;
+	}
+
+	/* Config and display the graphic window */
+	if (cam->v4l2_fb.flags == V4L2_FBUF_FLAG_OVERLAY) {
+		/*
+		  TODO: add config display window here in future.
+		 */
+		g_vfbuf = g_vfbuf ? 0 : 1;
+	}
+}
+
+/*
+ * @brief Check if the resize ratio is supported based on the input and output
+ *        dimension
+ * @param	input	input dimension
+ * @param	output	output dimension
+ * @return	output dimension (should equal the parameter *output*)
+ * 		-1 on failure
+ */
+static int check_simple(scale_t *scale, int input, int output)
+{
+	unsigned short int_out;	/* PrP internel width or height */
+	unsigned short orig_out = output;
+
+	if (prp_scale(scale, input, output, input, &orig_out, &int_out, 0))
+		return -1;	/* resize failed */
+	else
+		return int_out;
+}
+
+/*
+ * @brief Check if the resize ratio is supported based on the input and output
+ *        dimension
+ * @param	input	input dimension
+ * @param	output	output dimension
+ * @return	output dimension, may be rounded.
+ * 		-1 on failure
+ */
+static int check_simple_retry(scale_t *scale, int input, int output)
+{
+	unsigned short int_out;	/* PrP internel width or height */
+	unsigned short orig_out = output;
+
+	if (prp_scale(scale, input, output, input, &orig_out, &int_out,
+		      SCALE_RETRY))
+		return -1;	/* resize failed */
+	else
+		return int_out;
+}
+
+/*!
+ * @brief Check if the resize ratio is supported by PrP channel 1
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_resize_check_ch1(emma_prp_cfg *cfg)
+{
+	int in_w, in_h, ch1_w, ch1_h, ch2_w, ch2_h, w, h;
+	scale_t *pscale = &cfg->scale[0];	/* Ch1 width resize coeff */
+
+	if (cfg->ch1_pix == PRP_PIX1_UNUSED)
+		return 0;
+
+	in_w = cfg->in_width;
+	in_h = cfg->in_height;
+	ch1_w = cfg->ch1_width;
+	ch1_h = cfg->ch1_height;
+	ch2_w = cfg->ch2_width;
+	ch2_h = cfg->ch2_height;
+
+	/*
+	 * For channel 1, try parallel resize first. If the resize
+	 * ratio is not exactly supported, try cascade resize. If it
+	 * still fails, use parallel resize but with rounded value.
+	 */
+	w = check_simple(pscale, in_w, ch1_w);
+	h = check_simple(pscale + 1, in_h, ch1_h);
+	if ((w == ch1_w) && (h == ch1_h))
+		goto exit_parallel;
+
+	if (cfg->ch2_pix != PRP_PIX2_UNUSED) {
+		/*
+		 * Channel 2 is already used. The pscale is still pointing
+		 * to ch1 resize coeff for temporary use.
+		 */
+		w = check_simple(pscale, in_w, ch2_w);
+		h = check_simple(pscale + 1, in_h, ch2_h);
+		if ((w == ch2_w) && (h == ch2_h)) {
+			/* Try cascade resize now */
+			w = check_simple(pscale, ch2_w, ch1_w);
+			h = check_simple(pscale + 1, ch2_h, ch1_h);
+			if ((w == ch1_w) && (h == ch1_h))
+				goto exit_cascade;
+		}
+	} else {
+		/*
+		 * Try cascade resize for width, width is multiple of 2.
+		 * Channel 2 is not used. So we have more values to pick
+		 * for channel 2 resize.
+		 */
+		for (w = in_w - 2; w > ch1_w; w -= 2) {
+			/* Ch2 width resize */
+			if (check_simple(pscale + 2, in_w, w) != w)
+				continue;
+			/* Ch1 width resize */
+			if (check_simple(pscale, w, ch1_w) != ch1_w)
+				continue;
+			break;
+		}
+		ch2_w = w;
+		if (ch2_w > ch1_w) {
+			/* try cascade resize for height */
+			for (h = in_h - 1; h > ch1_h; h--) {
+				/* Ch2 height resize */
+				if (check_simple(pscale + 3, in_h, h) != h)
+					continue;
+				/* Ch1 height resize */
+				if (check_simple(pscale + 1, h, ch1_h) != ch1_h)
+					continue;
+				break;
+			}
+			ch2_h = h;
+			if (ch2_h > ch1_h)
+				goto exit_cascade;
+		}
+	}
+
+	/* Have to try parallel resize again and round the dimensions */
+	w = check_simple_retry(pscale, in_w, ch1_w);
+	h = check_simple_retry(pscale + 1, in_h, ch1_h);
+	if ((w != -1) && (h != -1))
+		goto exit_parallel;
+
+	pr_debug("Ch1 resize error.\n");
+	return -1;
+
+exit_parallel:
+	cfg->ch1_scale.algo |= PRP_ALGO_BYPASS;
+	pr_debug("ch1 parallel resize.\n");
+	pr_debug("original width = %d internel width = %d\n", ch1_w, w);
+	pr_debug("original height = %d internel height = %d\n", ch1_h, h);
+	return 0;
+
+exit_cascade:
+	cfg->ch1_scale.algo &= ~PRP_ALGO_BYPASS;
+	pr_debug("ch1 cascade resize.\n");
+	pr_debug("[width] in : ch2 : ch1=%d : %d : %d\n", in_w, ch2_w, ch1_w);
+	pr_debug("[height] in : ch2 : ch1=%d : %d : %d\n", in_h, ch2_h, ch1_h);
+	return 0;
+}
+
+/*!
+ * @brief Check if the resize ratio is supported by PrP channel 2
+ * @param cfg	Pointer to emma_prp_cfg structure
+ * @return	Zero on success, others on failure
+ */
+static int prp_resize_check_ch2(emma_prp_cfg *cfg)
+{
+	int w, h;
+	scale_t *pscale = &cfg->scale[2];	/* Ch2 width resize coeff */
+
+	if (cfg->ch2_pix == PRP_PIX2_UNUSED)
+		return 0;
+
+	w = check_simple_retry(pscale, cfg->in_width, cfg->ch2_width);
+	h = check_simple_retry(pscale + 1, cfg->in_height, cfg->ch2_height);
+	if ((w != -1) && (h != -1)) {
+		pr_debug("Ch2 resize.\n");
+		pr_debug("Original width = %d internel width = %d\n",
+			 cfg->ch2_width, w);
+		pr_debug("Original height = %d internel height = %d\n",
+			 cfg->ch2_height, h);
+		return 0;
+	} else {
+		pr_debug("Ch2 resize error.\n");
+		return -1;
+	}
+}
-- 
1.6.0.4

