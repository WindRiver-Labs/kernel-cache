From 50894754091a4d9218b258f16990e1ffbc637871 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 1 Dec 2008 13:07:59 +0800
Subject: [PATCH] fix support for SMTC on Malta 34Kc

Although current kernel can support SMTC on Malta 34Kc after overcoming
the introduction of dyntick, there are still two issues to be fixed as
the following:

a) CPU name is NULL on SMTC
For SMTC the kernel probes CPU name only one time so we have to provide
others cpu (TC) name.

b) Kernel panic while executing init
The 34kc supports using r4k_wait_irqoff. If one TC, which is configured not
to handle the interrupt, executes wait to enter idle. When it reworks by
IPI we need to force exit from the wait and do a direct post of the IPI. But
the original condition judging whether the TC enters wait section is imprecise:
=====
void r4k_wait_irqoff(void)
{
        local_irq_disable();
        if (!need_resched())
                __asm__("       .set    push            \n"
                        "       .set    mips3           \n"
                        "       wait                    \n"
                        "       .set    pop             \n");
        local_irq_enable();
        __asm__("       .globl __pastwait       \n"
                "__pastwait:                    \n");
        return;
}
=====
        if (cpu_wait == r4k_wait_irqoff) {
                tcrestart = read_tc_c0_tcrestart();
                if (tcrestart >= (unsigned long)r4k_wait_irqoff
                    && tcrestart < (unsigned long)__pastwait) {
                        write_tc_c0_tcrestart(__pastwait);
                        tcstatus &= ~TCSTATUS_IXMT;
                        write_tc_c0_tcstatus(tcstatus);
                        goto postdirect;
                }
        }
=====

Obviously, if the TC enter r4k_wait_irqoff and just disable local irq it
receive the interrupt and has to exit immediately without enabling local irq!
So we should handle this precisely only the TC enter the real wait section
within __startwait and __endwait:
=====
void r4k_wait_irqoff(void)
{
	local_irq_disable();
	if (!need_resched())
		__asm__(" 	.globl __startwait	\n"
			"__startwait:			\n"
			"	.set	push		\n"
			"	.set	mips3		\n"
			"	wait			\n"
			"	.set	pop		\n"
			" 	.globl __pastwait	\n"
			"__pastwait:			\n");
	local_irq_enable();
	return;
}

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/mips/kernel/cpu-probe.c |   22 ++++++++++++++++++----
 arch/mips/kernel/smtc.c      |    4 ++--
 2 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index b80954d..38f0d0b 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -59,13 +59,15 @@ void r4k_wait_irqoff(void)
 {
 	local_irq_disable();
 	if (!need_resched())
-		__asm__("	.set	push		\n"
+		__asm__(" 	.globl __startwait	\n"
+			"__startwait:			\n"
+			"	.set	push		\n"
 			"	.set	mips3		\n"
 			"	wait			\n"
-			"	.set	pop		\n");
+			"	.set	pop		\n"
+			" 	.globl __pastwait	\n"
+			"__pastwait:			\n");
 	local_irq_enable();
-	__asm__(" 	.globl __pastwait	\n"
-		"__pastwait:			\n");
 	return;
 }
 
@@ -901,6 +903,9 @@ __cpuinit void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int cpu = smp_processor_id();
+#ifdef CONFIG_MIPS_MT_SMTC
+	unsigned int i = 0;
+#endif
 
 	c->processor_id	= PRID_IMP_UNKNOWN;
 	c->fpu_id	= FPIR_IMP_NONE;
@@ -952,7 +957,16 @@ __cpuinit void cpu_probe(void)
 		}
 	}
 
+#ifdef CONFIG_MIPS_MT_SMTC
+	/* 
+ 	 * The SMTC kernel probes only one time so it's necessary to provide
+ 	 * others cpu name here.
+ 	 */
+	for (i = 0; i < NR_CPUS;i++)
+		__cpu_name[cpu + i] = cpu_to_name(c);
+#else
 	__cpu_name[cpu] = cpu_to_name(c);
+#endif
 
 	if (cpu_has_mips_r2)
 		c->srsets = ((read_c0_srsctl() >> 26) & 0x0f) + 1;
diff --git a/arch/mips/kernel/smtc.c b/arch/mips/kernel/smtc.c
index 1f764a3..1e1ff07 100644
--- a/arch/mips/kernel/smtc.c
+++ b/arch/mips/kernel/smtc.c
@@ -795,7 +795,7 @@ void smtc_send_ipi(int cpu, int type, unsigned int action)
 	unsigned long flags;
 	int mtflags;
 	unsigned long tcrestart;
-	extern void r4k_wait_irqoff(void), __pastwait(void);
+	extern void r4k_wait_irqoff(void), __startwait(void), __pastwait(void);
 	int set_resched_flag = (type == LINUX_SMP_IPI &&
 				action == SMP_RESCHEDULE_YOURSELF);
 
@@ -851,7 +851,7 @@ void smtc_send_ipi(int cpu, int type, unsigned int action)
 			 */
 			if (cpu_wait == r4k_wait_irqoff) {
 				tcrestart = read_tc_c0_tcrestart();
-				if (tcrestart >= (unsigned long)r4k_wait_irqoff
+				if (tcrestart >= (unsigned long)__startwait
 				    && tcrestart < (unsigned long)__pastwait) {
 					write_tc_c0_tcrestart(__pastwait);
 					tcstatus &= ~TCSTATUS_IXMT;
-- 
1.7.0

