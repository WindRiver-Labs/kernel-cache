From 65afb91b368bd4ad7fa26f927d044da4fab365b2 Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf@linux-mips.org>
Date: Sat, 24 Jan 2009 18:47:32 +0000
Subject: [PATCH 022/117] MIPS: Fix oops in r4k_dma_cache_inv

commit 65afb91b368bd4ad7fa26f927d044da4fab365b2 from linux-mips

The recent fix "MIPS: Avoid destructive invalidation on partial cachelines."
resulted potentially in an address error.

The reason for this is that there is no clearly documented alignment
requirement for the cache instruction on MIPS processors.  Some even
document that a cache instruction cannot result result in an address
error and some processors, among them the RM5200 and RM7000 QED
processors will throw a an address error for cache hit ops with
insufficient alignment - whatever the exact alignment requirement is.

Credits to Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp> for providing a
similar patch.

Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
(cherry picked from commit 83ef82f4ada115c45ed967698ba16bc70f676e2e)
---
 arch/mips/mm/c-r4k.c |   23 +++++++++++++++++++----
 1 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index 56290a7..c43f4b2 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -619,8 +619,20 @@ static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 		if (size >= scache_size)
 			r4k_blast_scache();
 		else {
-			cache_op(Hit_Writeback_Inv_SD, addr);
-			cache_op(Hit_Writeback_Inv_SD, addr + size - 1);
+			unsigned long lsize = cpu_scache_line_size();
+			unsigned long almask = ~(lsize - 1);
+
+			/*
+			 * There is no clearly documented alignment requirement
+			 * for the cache instruction on MIPS processors and
+			 * some processors, among them the RM5200 and RM7000
+			 * QED processors will throw an address error for cache
+			 * hit ops with insufficient alignment.  Solved by
+			 * aligning the address to cache line size.
+			 */
+			cache_op(Hit_Writeback_Inv_SD, addr & almask);
+			cache_op(Hit_Writeback_Inv_SD,
+				 (addr + size - 1) & almask);
 			blast_inv_scache_range(addr, addr + size);
 		}
 		return;
@@ -629,9 +641,12 @@ static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
 		r4k_blast_dcache();
 	} else {
+		unsigned long lsize = cpu_dcache_line_size();
+		unsigned long almask = ~(lsize - 1);
+
 		R4600_HIT_CACHEOP_WAR_IMPL;
-		cache_op(Hit_Writeback_Inv_D, addr);
-		cache_op(Hit_Writeback_Inv_D, addr + size - 1);
+		cache_op(Hit_Writeback_Inv_D, addr & almask);
+		cache_op(Hit_Writeback_Inv_D, (addr + size - 1)  & almask);
 		blast_inv_dcache_range(addr, addr + size);
 	}
 
-- 
1.7.0

