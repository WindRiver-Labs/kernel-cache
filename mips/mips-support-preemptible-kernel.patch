From 4fdb2343a550a7f3587d594b75aa1a38c67338ca Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 19 Sep 2008 15:13:56 +0800
Subject: [PATCH] mips support preemptible kernel

Some warning message result from calling function, smp_processor_id(),
if enable preempt option. So we should do explicitly somewhere when running
preemptible kernel, especially for some cache operation.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/mips/kernel/proc.c |    5 ++++-
 arch/mips/mm/c-r4k.c    |    8 ++++----
 2 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index 98b38f6..72382aa 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -23,6 +23,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	unsigned int version = cpu_data[n].processor_id;
 	unsigned int fp_vers = cpu_data[n].fpu_id;
 	char fmt [64];
+	int cpu;
 
 #ifdef CONFIG_SMP
 	if (!cpu_isset(n, cpu_online_map))
@@ -38,9 +39,11 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	seq_printf(m, "processor\t\t: %ld\n", n);
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
 	        cpu_data[n].options & MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
-	seq_printf(m, fmt, __cpu_name[n],
+	cpu = get_cpu();
+	seq_printf(m, fmt, __cpu_name[cpu],
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
+	put_cpu();
 	seq_printf(m, "BogoMIPS\t\t: %lu.%02lu\n",
 	              cpu_data[n].udelay_val / (500000/HZ),
 	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index 6e99665..b8317c6 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -370,12 +370,12 @@ static inline int has_valid_asid(const struct mm_struct *mm)
 
 static void r4k__flush_cache_vmap(void)
 {
-	r4k_blast_dcache();
+	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
 }
 
 static void r4k__flush_cache_vunmap(void)
 {
-	r4k_blast_dcache();
+	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
 }
 
 static inline void local_r4k_flush_cache_range(void * args)
@@ -601,7 +601,7 @@ static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 	 * explicitly
 	 */
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_blast_dcache();
+		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
@@ -624,7 +624,7 @@ static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 	}
 
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_blast_dcache();
+		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_inv_dcache_range(addr, addr + size);
-- 
1.5.5.1

