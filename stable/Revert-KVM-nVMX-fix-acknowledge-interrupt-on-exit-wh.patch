From 896b28941589da21f2f9f3ec81e57b8e207ac816 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 28 Jan 2015 10:34:41 -0500
Subject: [PATCH] Revert "KVM: nVMX: fix "acknowledge interrupt on exit" when
 APICv is in use"

This reverts commit d175e30c03decba32c5373379f5bab065267a074.

It was a stable backport, but the "Fixes:" tag shows it was only
required for 3.16 and newer.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/x86/kvm/irq.c   |  2 +-
 arch/x86/kvm/lapic.c | 52 +++++++++++++---------------------------------------
 2 files changed, 14 insertions(+), 40 deletions(-)

diff --git a/arch/x86/kvm/irq.c b/arch/x86/kvm/irq.c
index 3ec38cb56bd5..484bc874688b 100644
--- a/arch/x86/kvm/irq.c
+++ b/arch/x86/kvm/irq.c
@@ -108,7 +108,7 @@ int kvm_cpu_get_interrupt(struct kvm_vcpu *v)
 
 	vector = kvm_cpu_get_extint(v);
 
-	if (vector != -1)
+	if (kvm_apic_vid_enabled(v->kvm) || vector != -1)
 		return vector;			/* PIC */
 
 	return kvm_get_apic_interrupt(v);	/* APIC */
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index 681e4e251f00..279d093524b4 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -362,46 +362,25 @@ static inline int apic_find_highest_irr(struct kvm_lapic *apic)
 
 static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)
 {
-	struct kvm_vcpu *vcpu;
-
-	vcpu = apic->vcpu;
-
+	apic->irr_pending = false;
 	apic_clear_vector(vec, apic->regs + APIC_IRR);
-	if (unlikely(kvm_apic_vid_enabled(vcpu->kvm)))
-		/* try to update RVI */
-		kvm_make_request(KVM_REQ_EVENT, vcpu);
-	else {
-		vec = apic_search_irr(apic);
-		apic->irr_pending = (vec != -1);
-	}
+	if (apic_search_irr(apic) != -1)
+		apic->irr_pending = true;
 }
 
 static inline void apic_set_isr(int vec, struct kvm_lapic *apic)
 {
-	struct kvm_vcpu *vcpu;
-
-	if (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))
-		return;
-
-	vcpu = apic->vcpu;
+	/* Note that we never get here with APIC virtualization enabled.  */
 
+	if (!__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))
+		++apic->isr_count;
+	BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
 	/*
-	 * With APIC virtualization enabled, all caching is disabled
-	 * because the processor can modify ISR under the hood.  Instead
-	 * just set SVI.
+	 * ISR (in service register) bit is set when injecting an interrupt.
+	 * The highest vector is injected. Thus the latest bit set matches
+	 * the highest bit in ISR.
 	 */
-	if (unlikely(kvm_apic_vid_enabled(vcpu->kvm)))
-		kvm_x86_ops->hwapic_isr_update(vcpu->kvm, vec);
-	else {
-		++apic->isr_count;
-		BUG_ON(apic->isr_count > MAX_APIC_VECTOR);
-		/*
-		 * ISR (in service register) bit is set when injecting an interrupt.
-		 * The highest vector is injected. Thus the latest bit set matches
-		 * the highest bit in ISR.
-		 */
-		apic->highest_isr_cache = vec;
-	}
+	apic->highest_isr_cache = vec;
 }
 
 static inline int apic_find_highest_isr(struct kvm_lapic *apic)
@@ -1662,16 +1641,11 @@ int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)
 	int vector = kvm_apic_has_interrupt(vcpu);
 	struct kvm_lapic *apic = vcpu->arch.apic;
 
+	/* Note that we never get here with APIC virtualization enabled.  */
+
 	if (vector == -1)
 		return -1;
 
-	/*
-	 * We get here even with APIC virtualization enabled, if doing
-	 * nested virtualization and L1 runs with the "acknowledge interrupt
-	 * on exit" mode.  Then we cannot inject the interrupt via RVI,
-	 * because the process would deliver it through the IDT.
-	 */
-
 	apic_set_isr(vector, apic);
 	apic_update_ppr(apic);
 	apic_clear_irr(vector, apic);
-- 
2.2.1

