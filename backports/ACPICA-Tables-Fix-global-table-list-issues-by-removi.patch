From 90229b5824881df098068cffb79a7695e8bb0b70 Mon Sep 17 00:00:00 2001
From: Lv Zheng <lv.zheng@intel.com>
Date: Tue, 25 Aug 2015 10:29:01 +0800
Subject: [PATCH 113/133] ACPICA: Tables: Fix global table list issues by
 removing fixed table indexes

commit 8ec3f459073e67e5c6d78507dec693064b3040a2 upstream.

ACPICA commit c0b38b4c3982c2336ee92a2a14716107248bd941

The fixed table indexes leave holes in the global table list:
 1. One hole can be seen when there is only 1 FACS provided by the BIOS.
 2. Tow holes can be seen when it is a reduced hardware platform.
The holes do not break OSPMs but have broken ACPI debugger "tables"
command.

Also the "fixed table indexes" mechanism may make the descriptors of the
standard tables installed earlier than DSDT to be overwritten by the
descriptors of the fixed tables. For example, FACP disappears from the
global table list after DSDT is installed.

This patch fixes all above issues by removing the "fixed table indexes"
mechanism which is too complicated to be maintained in a regression safe
manner. After removal, the table loader will determine the indexes of the
fixed tables. Lv Zheng.

Link: https://github.com/acpica/acpica/commit/c0b38b4c
Signed-off-by: Lv Zheng <lv.zheng@intel.com>
Signed-off-by: Bob Moore <robert.moore@intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/acpi/acpica/acglobal.h |  3 +++
 drivers/acpi/acpica/aclocal.h  |  6 ++----
 drivers/acpi/acpica/actables.h |  7 +++----
 drivers/acpi/acpica/tbfadt.c   |  6 +++---
 drivers/acpi/acpica/tbinstal.c | 40 +++++++++++++++++++++-------------------
 drivers/acpi/acpica/tbutils.c  | 37 ++++++++++++++-----------------------
 drivers/acpi/acpica/tbxfload.c | 10 +++++-----
 7 files changed, 51 insertions(+), 58 deletions(-)

diff --git a/drivers/acpi/acpica/acglobal.h b/drivers/acpi/acpica/acglobal.h
index 1283b19..e78667e 100644
--- a/drivers/acpi/acpica/acglobal.h
+++ b/drivers/acpi/acpica/acglobal.h
@@ -58,6 +58,9 @@ ACPI_GLOBAL(struct acpi_table_list, acpi_gbl_root_table_list);
 
 ACPI_GLOBAL(struct acpi_table_header *, acpi_gbl_DSDT);
 ACPI_GLOBAL(struct acpi_table_header, acpi_gbl_original_dsdt_header);
+ACPI_INIT_GLOBAL(u32, acpi_gbl_dsdt_index, ACPI_INVALID_TABLE_INDEX);
+ACPI_INIT_GLOBAL(u32, acpi_gbl_facs_index, ACPI_INVALID_TABLE_INDEX);
+ACPI_INIT_GLOBAL(u32, acpi_gbl_xfacs_index, ACPI_INVALID_TABLE_INDEX);
 
 #if (!ACPI_REDUCED_HARDWARE)
 ACPI_GLOBAL(struct acpi_table_facs *, acpi_gbl_FACS);
diff --git a/drivers/acpi/acpica/aclocal.h b/drivers/acpi/acpica/aclocal.h
index a6b6887..92cbaee 100644
--- a/drivers/acpi/acpica/aclocal.h
+++ b/drivers/acpi/acpica/aclocal.h
@@ -213,11 +213,9 @@ struct acpi_table_list {
 #define ACPI_ROOT_ORIGIN_ALLOCATED      (1)
 #define ACPI_ROOT_ALLOW_RESIZE          (2)
 
-/* Predefined (fixed) table indexes */
+/* Predefined table indexes */
 
-#define ACPI_TABLE_INDEX_DSDT           (0)
-#define ACPI_TABLE_INDEX_FACS           (1)
-#define ACPI_TABLE_INDEX_X_FACS         (2)
+#define ACPI_INVALID_TABLE_INDEX        (0xFFFFFFFF)
 
 struct acpi_find_context {
 	char *search_for;
diff --git a/drivers/acpi/acpica/actables.h b/drivers/acpi/acpica/actables.h
index 58497b7..ab7f3a0 100644
--- a/drivers/acpi/acpica/actables.h
+++ b/drivers/acpi/acpica/actables.h
@@ -154,13 +154,12 @@ void acpi_tb_check_dsdt_header(void);
 struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index);
 
 void
-acpi_tb_install_table_with_override(u32 table_index,
-				    struct acpi_table_desc *new_table_desc,
-				    u8 override);
+acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
+				    u8 override, u32 *table_index);
 
 acpi_status
 acpi_tb_install_fixed_table(acpi_physical_address address,
-			    char *signature, u32 table_index);
+			    char *signature, u32 *table_index);
 
 acpi_status acpi_tb_parse_root_table(acpi_physical_address rsdp_address);
 
diff --git a/drivers/acpi/acpica/tbfadt.c b/drivers/acpi/acpica/tbfadt.c
index 6253001..455a070 100644
--- a/drivers/acpi/acpica/tbfadt.c
+++ b/drivers/acpi/acpica/tbfadt.c
@@ -345,7 +345,7 @@ void acpi_tb_parse_fadt(u32 table_index)
 	/* Obtain the DSDT and FACS tables via their addresses within the FADT */
 
 	acpi_tb_install_fixed_table((acpi_physical_address) acpi_gbl_FADT.Xdsdt,
-				    ACPI_SIG_DSDT, ACPI_TABLE_INDEX_DSDT);
+				    ACPI_SIG_DSDT, &acpi_gbl_dsdt_index);
 
 	/* If Hardware Reduced flag is set, there is no FACS */
 
@@ -354,13 +354,13 @@ void acpi_tb_parse_fadt(u32 table_index)
 			acpi_tb_install_fixed_table((acpi_physical_address)
 						    acpi_gbl_FADT.facs,
 						    ACPI_SIG_FACS,
-						    ACPI_TABLE_INDEX_FACS);
+						    &acpi_gbl_facs_index);
 		}
 		if (acpi_gbl_FADT.Xfacs) {
 			acpi_tb_install_fixed_table((acpi_physical_address)
 						    acpi_gbl_FADT.Xfacs,
 						    ACPI_SIG_FACS,
-						    ACPI_TABLE_INDEX_X_FACS);
+						    &acpi_gbl_xfacs_index);
 		}
 	}
 }
diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c
index 15ea98e..6319b42 100644
--- a/drivers/acpi/acpica/tbinstal.c
+++ b/drivers/acpi/acpica/tbinstal.c
@@ -100,9 +100,9 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
  *
  * FUNCTION:    acpi_tb_install_table_with_override
  *
- * PARAMETERS:  table_index             - Index into root table array
- *              new_table_desc          - New table descriptor to install
+ * PARAMETERS:  new_table_desc          - New table descriptor to install
  *              override                - Whether override should be performed
+ *              table_index             - Where the table index is returned
  *
  * RETURN:      None
  *
@@ -114,12 +114,14 @@ acpi_tb_compare_tables(struct acpi_table_desc *table_desc, u32 table_index)
  ******************************************************************************/
 
 void
-acpi_tb_install_table_with_override(u32 table_index,
-				    struct acpi_table_desc *new_table_desc,
-				    u8 override)
+acpi_tb_install_table_with_override(struct acpi_table_desc *new_table_desc,
+				    u8 override, u32 *table_index)
 {
+	u32 i;
+	acpi_status status;
 
-	if (table_index >= acpi_gbl_root_table_list.current_table_count) {
+	status = acpi_tb_get_next_table_descriptor(&i, NULL);
+	if (ACPI_FAILURE(status)) {
 		return;
 	}
 
@@ -134,8 +136,7 @@ acpi_tb_install_table_with_override(u32 table_index,
 		acpi_tb_override_table(new_table_desc);
 	}
 
-	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
-				      tables[table_index],
+	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.tables[i],
 				      new_table_desc->address,
 				      new_table_desc->flags,
 				      new_table_desc->pointer);
@@ -143,9 +144,13 @@ acpi_tb_install_table_with_override(u32 table_index,
 	acpi_tb_print_table_header(new_table_desc->address,
 				   new_table_desc->pointer);
 
+	/* This synchronizes acpi_gbl_dsdt_index */
+
+	*table_index = i;
+
 	/* Set the global integer width (based upon revision of the DSDT) */
 
-	if (table_index == ACPI_TABLE_INDEX_DSDT) {
+	if (i == acpi_gbl_dsdt_index) {
 		acpi_ut_set_integer_width(new_table_desc->pointer->revision);
 	}
 }
@@ -157,7 +162,7 @@ acpi_tb_install_table_with_override(u32 table_index,
  * PARAMETERS:  address                 - Physical address of DSDT or FACS
  *              signature               - Table signature, NULL if no need to
  *                                        match
- *              table_index             - Index into root table array
+ *              table_index             - Where the table index is returned
  *
  * RETURN:      Status
  *
@@ -168,7 +173,7 @@ acpi_tb_install_table_with_override(u32 table_index,
 
 acpi_status
 acpi_tb_install_fixed_table(acpi_physical_address address,
-			    char *signature, u32 table_index)
+			    char *signature, u32 *table_index)
 {
 	struct acpi_table_desc new_table_desc;
 	acpi_status status;
@@ -200,7 +205,9 @@ acpi_tb_install_fixed_table(acpi_physical_address address,
 		goto release_and_exit;
 	}
 
-	acpi_tb_install_table_with_override(table_index, &new_table_desc, TRUE);
+	/* Add the table to the global root table list */
+
+	acpi_tb_install_table_with_override(&new_table_desc, TRUE, table_index);
 
 release_and_exit:
 
@@ -355,13 +362,8 @@ acpi_tb_install_standard_table(acpi_physical_address address,
 
 	/* Add the table to the global root table list */
 
-	status = acpi_tb_get_next_table_descriptor(&i, NULL);
-	if (ACPI_FAILURE(status)) {
-		goto release_and_exit;
-	}
-
-	*table_index = i;
-	acpi_tb_install_table_with_override(i, &new_table_desc, override);
+	acpi_tb_install_table_with_override(&new_table_desc, override,
+					    table_index);
 
 release_and_exit:
 
diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c
index db7f2aa..b1d500e 100644
--- a/drivers/acpi/acpica/tbutils.c
+++ b/drivers/acpi/acpica/tbutils.c
@@ -74,22 +74,20 @@ acpi_status acpi_tb_initialize_facs(void)
 	if (acpi_gbl_reduced_hardware) {
 		acpi_gbl_FACS = NULL;
 		return (AE_OK);
-	}
-
-	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,
-				      ACPI_CAST_INDIRECT_PTR(struct
-							     acpi_table_header,
-							     &acpi_gbl_facs32));
-	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_X_FACS,
-				      ACPI_CAST_INDIRECT_PTR(struct
-							     acpi_table_header,
-							     &acpi_gbl_facs64));
-
-	if (acpi_gbl_facs64
-	    && (!acpi_gbl_facs32 || !acpi_gbl_use32_bit_facs_addresses)) {
-		acpi_gbl_FACS = acpi_gbl_facs64;
-	} else if (acpi_gbl_facs32) {
+	} else if (acpi_gbl_FADT.Xfacs &&
+		   (!acpi_gbl_FADT.facs
+		    || !acpi_gbl_use32_bit_facs_addresses)) {
+		(void)acpi_get_table_by_index(acpi_gbl_xfacs_index,
+					      ACPI_CAST_INDIRECT_PTR(struct
+								     acpi_table_header,
+								     &acpi_gbl_facs32));
 		acpi_gbl_FACS = acpi_gbl_facs32;
+	} else if (acpi_gbl_FADT.facs) {
+		(void)acpi_get_table_by_index(acpi_gbl_facs_index,
+					      ACPI_CAST_INDIRECT_PTR(struct
+								     acpi_table_header,
+								     &acpi_gbl_facs64));
+		acpi_gbl_FACS = acpi_gbl_facs64;
 	}
 
 	/* If there is no FACS, just continue. There was already an error msg */
@@ -192,7 +190,7 @@ struct acpi_table_header *acpi_tb_copy_dsdt(u32 table_index)
 	acpi_tb_uninstall_table(table_desc);
 
 	acpi_tb_init_table_descriptor(&acpi_gbl_root_table_list.
-				      tables[ACPI_TABLE_INDEX_DSDT],
+				      tables[acpi_gbl_dsdt_index],
 				      ACPI_PTR_TO_PHYSADDR(new_table),
 				      ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL,
 				      new_table);
@@ -369,13 +367,6 @@ acpi_status __init acpi_tb_parse_root_table(acpi_physical_address rsdp_address)
 			    table_entry_size);
 	table_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));
 
-	/*
-	 * First three entries in the table array are reserved for the DSDT
-	 * and 32bit/64bit FACS, which are not actually present in the
-	 * RSDT/XSDT - they come from the FADT
-	 */
-	acpi_gbl_root_table_list.current_table_count = 3;
-
 	/* Initialize the root table array from the RSDT/XSDT */
 
 	for (i = 0; i < table_count; i++) {
diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c
index 6cbb2f7..fb4d4e6 100644
--- a/drivers/acpi/acpica/tbxfload.c
+++ b/drivers/acpi/acpica/tbxfload.c
@@ -116,12 +116,12 @@ static acpi_status acpi_tb_load_namespace(void)
 	if (!acpi_gbl_root_table_list.current_table_count ||
 	    !ACPI_COMPARE_NAME(&
 			       (acpi_gbl_root_table_list.
-				tables[ACPI_TABLE_INDEX_DSDT].signature),
+				tables[acpi_gbl_dsdt_index].signature),
 			       ACPI_SIG_DSDT)
 	    ||
 	    ACPI_FAILURE(acpi_tb_validate_table
 			 (&acpi_gbl_root_table_list.
-			  tables[ACPI_TABLE_INDEX_DSDT]))) {
+			  tables[acpi_gbl_dsdt_index]))) {
 		status = AE_NO_ACPI_TABLES;
 		goto unlock_and_exit;
 	}
@@ -133,7 +133,7 @@ static acpi_status acpi_tb_load_namespace(void)
 	 * .Pointer field is not validated until after call to acpi_tb_validate_table.
 	 */
 	acpi_gbl_DSDT =
-	    acpi_gbl_root_table_list.tables[ACPI_TABLE_INDEX_DSDT].pointer;
+	    acpi_gbl_root_table_list.tables[acpi_gbl_dsdt_index].pointer;
 
 	/*
 	 * Optionally copy the entire DSDT to local memory (instead of simply
@@ -142,7 +142,7 @@ static acpi_status acpi_tb_load_namespace(void)
 	 * the DSDT.
 	 */
 	if (acpi_gbl_copy_dsdt_locally) {
-		new_dsdt = acpi_tb_copy_dsdt(ACPI_TABLE_INDEX_DSDT);
+		new_dsdt = acpi_tb_copy_dsdt(acpi_gbl_dsdt_index);
 		if (new_dsdt) {
 			acpi_gbl_DSDT = new_dsdt;
 		}
@@ -159,7 +159,7 @@ static acpi_status acpi_tb_load_namespace(void)
 
 	/* Load and parse tables */
 
-	status = acpi_ns_load_table(ACPI_TABLE_INDEX_DSDT, acpi_gbl_root_node);
+	status = acpi_ns_load_table(acpi_gbl_dsdt_index, acpi_gbl_root_node);
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status, "[DSDT] table load failed"));
 		tables_failed++;
-- 
2.0.2

