From 60503c9ac1a2d6a67be882335ffffbb51060581e Mon Sep 17 00:00:00 2001
From: Lv Zheng <lv.zheng@intel.com>
Date: Thu, 23 Jul 2015 12:52:11 +0800
Subject: [PATCH 078/133] ACPICA: Parser: Cleanup aml_offset in struct
 acpi_walk_state

commit 83482f758b0d2d6a20a10be88399da44aa186aed upstream.

ACPICA commit d254405814495058276c0c2f9d96794d15a6c91c

This patch converts aml_offset in struct acpi_walk_state to AML address.

AML offset is actually only used by the debugger, using AML address is more
direct and efficient during the parsing stage so that we don't need to
calculate it during the parsing stage.

On the other hand, we can see several issues in the current parser logic
around the aml_offset:
1. union acpi_operand_object.Common.aml_offset is redundantly assigned in
   acpi_ps_parse_loop().
2. aml_offset is not an indication of the offset from the table header but
   the offset from the entry of a list of objects. Sometimes, it indicates
   an entry for a Method/Package/Buffer, which makes it difficult to be
   reversely calculated to a table header offset.
3. When being used with method tracers (for example, Linux function trace),
   it's better to have AML address logged instead of the AML offset because
   the address is the only attribute that can uniquely identify the opcode.
This patch is required to solve the above issues. Lv Zheng.

Link: https://github.com/acpica/acpica/commit/d2544058
Signed-off-by: Lv Zheng <lv.zheng@intel.com>
Signed-off-by: Bob Moore <robert.moore@intel.com>
Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
Signed-off-by: Pengyu Ma <pengyu.ma@windriver.com>
---
 drivers/acpi/acpica/acstruct.h |  2 +-
 drivers/acpi/acpica/dsmethod.c |  9 +++++++--
 drivers/acpi/acpica/psloop.c   | 15 +++++++++------
 drivers/acpi/acpica/psobject.c | 15 +++++++++------
 4 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/drivers/acpi/acpica/acstruct.h b/drivers/acpi/acpica/acstruct.h
index 44997ca..f9992dc 100644
--- a/drivers/acpi/acpica/acstruct.h
+++ b/drivers/acpi/acpica/acstruct.h
@@ -85,7 +85,7 @@ struct acpi_walk_state {
 	u8 namespace_override;	/* Override existing objects */
 	u8 result_size;		/* Total elements for the result stack */
 	u8 result_count;	/* Current number of occupied elements of result stack */
-	u32 aml_offset;
+	u8 *aml;
 	u32 arg_types;
 	u32 method_breakpoint;	/* For single stepping */
 	u32 user_breakpoint;	/* User AML breakpoint */
diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c
index 85bb951..bf8c16e 100644
--- a/drivers/acpi/acpica/dsmethod.c
+++ b/drivers/acpi/acpica/dsmethod.c
@@ -214,6 +214,8 @@ acpi_ds_detect_named_opcodes(struct acpi_walk_state *walk_state,
 acpi_status
 acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 {
+	u32 aml_offset;
+
 	ACPI_FUNCTION_ENTRY();
 
 	/* Ignore AE_OK and control exception codes */
@@ -234,13 +236,16 @@ acpi_ds_method_error(acpi_status status, struct acpi_walk_state * walk_state)
 		 * Handler can map the exception code to anything it wants, including
 		 * AE_OK, in which case the executing method will not be aborted.
 		 */
+		aml_offset = (u32)ACPI_PTR_DIFF(walk_state->aml,
+						walk_state->parser_state.
+						aml_start);
+
 		status = acpi_gbl_exception_handler(status,
 						    walk_state->method_node ?
 						    walk_state->method_node->
 						    name.integer : 0,
 						    walk_state->opcode,
-						    walk_state->aml_offset,
-						    NULL);
+						    aml_offset, NULL);
 		acpi_ex_enter_interpreter();
 	}
 
diff --git a/drivers/acpi/acpica/psloop.c b/drivers/acpi/acpica/psloop.c
index 6136458..ce66e73 100644
--- a/drivers/acpi/acpica/psloop.c
+++ b/drivers/acpi/acpica/psloop.c
@@ -125,10 +125,7 @@ acpi_ps_get_arguments(struct acpi_walk_state *walk_state,
 		 */
 		while (GET_CURRENT_ARG_TYPE(walk_state->arg_types)
 		       && !walk_state->arg_count) {
-			walk_state->aml_offset =
-			    (u32)ACPI_PTR_DIFF(walk_state->parser_state.aml,
-					       walk_state->parser_state.
-					       aml_start);
+			walk_state->aml = walk_state->parser_state.aml;
 
 			status =
 			    acpi_ps_get_next_arg(walk_state,
@@ -140,7 +137,10 @@ acpi_ps_get_arguments(struct acpi_walk_state *walk_state,
 			}
 
 			if (arg) {
-				arg->common.aml_offset = walk_state->aml_offset;
+				arg->common.aml_offset =
+				    (u32)ACPI_PTR_DIFF(walk_state->aml,
+						       walk_state->parser_state.
+						       aml_start);
 				acpi_ps_append_arg(op, arg);
 			}
 
@@ -494,7 +494,10 @@ acpi_status acpi_ps_parse_loop(struct acpi_walk_state *walk_state)
 				continue;
 			}
 
-			op->common.aml_offset = walk_state->aml_offset;
+			op->common.aml_offset =
+			    (u32)ACPI_PTR_DIFF(walk_state->aml,
+					       walk_state->parser_state.
+					       aml_start);
 
 			if (walk_state->op_info) {
 				ACPI_DEBUG_PRINT((ACPI_DB_PARSE,
diff --git a/drivers/acpi/acpica/psobject.c b/drivers/acpi/acpica/psobject.c
index 2f5ddd8..6ba3bb7 100644
--- a/drivers/acpi/acpica/psobject.c
+++ b/drivers/acpi/acpica/psobject.c
@@ -66,12 +66,11 @@ static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state);
 
 static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)
 {
+	u32 aml_offset;
 
 	ACPI_FUNCTION_TRACE_PTR(ps_get_aml_opcode, walk_state);
 
-	walk_state->aml_offset =
-	    (u32)ACPI_PTR_DIFF(walk_state->parser_state.aml,
-			       walk_state->parser_state.aml_start);
+	walk_state->aml = walk_state->parser_state.aml;
 	walk_state->opcode = acpi_ps_peek_opcode(&(walk_state->parser_state));
 
 	/*
@@ -98,10 +97,14 @@ static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)
 		/* The opcode is unrecognized. Complain and skip unknown opcodes */
 
 		if (walk_state->pass_number == 2) {
+			aml_offset = (u32)ACPI_PTR_DIFF(walk_state->aml,
+							walk_state->
+							parser_state.aml_start);
+
 			ACPI_ERROR((AE_INFO,
 				    "Unknown opcode 0x%.2X at table offset 0x%.4X, ignoring",
 				    walk_state->opcode,
-				    (u32)(walk_state->aml_offset +
+				    (u32)(aml_offset +
 					  sizeof(struct acpi_table_header))));
 
 			ACPI_DUMP_BUFFER((walk_state->parser_state.aml - 16),
@@ -115,14 +118,14 @@ static acpi_status acpi_ps_get_aml_opcode(struct acpi_walk_state *walk_state)
 			acpi_os_printf
 			    ("/*\nError: Unknown opcode 0x%.2X at table offset 0x%.4X, context:\n",
 			     walk_state->opcode,
-			     (u32)(walk_state->aml_offset +
+			     (u32)(aml_offset +
 				   sizeof(struct acpi_table_header)));
 
 			/* Dump the context surrounding the invalid opcode */
 
 			acpi_ut_dump_buffer(((u8 *)walk_state->parser_state.
 					     aml - 16), 48, DB_BYTE_DISPLAY,
-					    (walk_state->aml_offset +
+					    (aml_offset +
 					     sizeof(struct acpi_table_header) -
 					     16));
 			acpi_os_printf(" */\n");
-- 
2.0.2

