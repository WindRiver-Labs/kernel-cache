From 20c52294a2082f7040e1d29484f33e8cb04c8e47 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 1 Dec 2009 21:12:18 -0500
Subject: [PATCH 01/43] vbi: whitespace cleanup; no real changes here

wrhv had a lot of lines with eight space tabs, hence why it
changes so much.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |   48 +-
 arch/powerpc/kernel/vbi/wrhv.c      |  868 +++++++++++++++++------------------
 include/vbi/compat.h                |   16 +-
 3 files changed, 465 insertions(+), 467 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index ab18d7d..5969e91 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -121,14 +121,14 @@
 #define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
 #define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
 #define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
-#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
-#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
-#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
-#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
-#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
-#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
-#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
-#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_DBSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
 #define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
 #define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
 #define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
@@ -154,10 +154,10 @@
 #ifndef _ASMLANGUAGE
 
 #define VB_STATUS_REGS_ACCESS(base, field)	\
-	base->vbStatusRegs.field		
+	base->vbStatusRegs.field
 
 #define VB_CONTROL_REGS_ACCESS(base, field)	\
-	base->vbControlRegs.field		
+	base->vbControlRegs.field
 
 /*
  * vb_arch_ctrl_regs - Virtual core PPC control structure
@@ -170,7 +170,7 @@
  *        _______________
  *       |       PC      |
  *       |---------------|
- *       |       MSR     |	
+ *       |       MSR     |
  *       |---------------|
  *       |       CR      |
  *       |---------------|
@@ -257,7 +257,7 @@ struct vb_arch_ctrl_regs
  *        _______________   ---------------------------
  *       |    SRR0       |
  *       |---------------|
- *       |    SRR1       |   Registers save by WRHV	
+ *       |    SRR1       |   Registers save by WRHV
  *       |---------------|   before injecting an exception/interrupt
  *       |    CR         |
  *       |---------------|
@@ -267,7 +267,7 @@ struct vb_arch_ctrl_regs
  *       |---------------|
  *       |    r4         |
  *       |---------------|   ---------------------------
- *       |    mcsrr0     |	
+ *       |    mcsrr0     |
  *       |---------------|  Registers saved duing exception handling
  *       |    mcssr1     |
  *       |---------------|
@@ -397,7 +397,7 @@ typedef HREG_SET VBI_HREG_SET;
  * It also defined the size of the excVectorTable size
  * VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000
  */
-#define VBI_ARCH_MAX_EXC_OFFSETS	64	
+#define VBI_ARCH_MAX_EXC_OFFSETS	64
 
 typedef struct
 {
@@ -422,14 +422,14 @@ typedef struct
 	{
 		struct
 		{
-			uint32_t bus;		
+			uint32_t bus;
 			uint32_t phyAddr;
 			uint32_t regNum;
 			uint32_t page;
 		} mdioRead;
 		struct
 		{
-			uint32_t bus;		
+			uint32_t bus;
 			uint32_t phyAddr;
 			uint32_t regNum;
 			uint32_t page;
@@ -438,18 +438,18 @@ typedef struct
 #if 0 /* not supported for now */
 		struct
 		{
-			uint32_t bus;		
+			uint32_t bus;
 			uint32_t vbIntNum;
 			HY_CTX *pCtx;
 		} mdioIntEnable;
 		struct
 		{
-			uint32_t bus;	
+			uint32_t bus;
 			uint32_t vbIntNum;
 			HY_CTX *pCtx;
 		} mdioIntDisable;
 #endif
-	} arg;				
+	} arg;
 } VBI_BSP_MSG;
 
 typedef struct
@@ -527,7 +527,7 @@ typedef struct
 	lis reg2, HIADJ(wrhvVbControl);			\
 	lwz reg2, LO(wrhvVbControl)(reg2);		\
 	lwz reg0, VB_CONTROL_INT_DISABLE(reg2);		\
-	stw reg1, VB_CONTROL_INT_DISABLE(reg2)		
+	stw reg1, VB_CONTROL_INT_DISABLE(reg2)
 
 /*
  * VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
@@ -599,7 +599,7 @@ endIntVcoreLock:
 
 #define VBI_INT_VCORE_STATE_GET(reg0)		\
 	VBI_CNTRL_ADDR_GET(reg0);		\
-	lwz reg0, VB_CONTROL_INT_DISABLE(reg0);		
+	lwz reg0, VB_CONTROL_INT_DISABLE(reg0);
 
 /*
  * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
@@ -613,7 +613,7 @@ endIntVcoreLock:
 
 #define VBI_CONFIG_ADDR_GET(reg)		\
 	lis reg, HIADJ(wrhvVbConfig);		\
-	lwz reg, LO(wrhvVbConfig)(reg)	
+	lwz reg, LO(wrhvVbConfig)(reg)
 
 /*
  * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
@@ -625,7 +625,7 @@ endIntVcoreLock:
 
 #define VBI_CNTRL_ADDR_GET(reg)			\
 	lis reg, HIADJ(wrhvVbControl);		\
-	lwz reg, LO(wrhvVbControl)(reg) 	
+	lwz reg, LO(wrhvVbControl)(reg)
 
 /*
  * VBI_STATUS_ADDR_GET - Get virtual core status structure address
@@ -654,7 +654,7 @@ endIntVcoreLock:
 
 #define VBI_STATUS_ADDR_GET(reg)		    \
 	lis reg, HIADJ(wrhvVbStatus);		    \
-	lwz reg, LO(wrhvVbStatus)(reg)	
+	lwz reg, LO(wrhvVbStatus)(reg)
 
 #endif /*_ASMLANGUAGE */
 
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index f71e124..6b5569d 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -45,7 +45,7 @@
 #include <linux/mutex.h>
 #include <linux/bootmem.h>
 #include <linux/pci.h>
-#include <linux/debugfs.h> 
+#include <linux/debugfs.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -172,7 +172,7 @@ void wrhv_mapping(void)
 	/* map in vbConfig address */
 
 	/*
-         * WRHV vb_config should really add a length field for each
+	 * WRHV vb_config should really add a length field for each
 	 * of the objected we mapped.  As the sizes are WRHV
 	 * implementation AND worse, configuration dependent.
 	 *
@@ -247,7 +247,7 @@ void wrhv_restart(void)
 		VBI_VBMGMT_RESET_CLEAR
 		);
 
-	if (unlikely(ret != 0)) 
+	if (unlikely(ret != 0))
 		printk(KERN_ERR "WRHV: reboot failed. \n");
 
 	while (1);
@@ -259,7 +259,7 @@ void __init wrhv_calibrate_decr(void)
 	ppc_tb_freq = wrhv_cpu_freq / 8;
 	printk(KERN_DEBUG "WRHV-TIME: wrhv_cpu_freq=%lu  ppc_tb_freq =%lu\n",
 			wrhv_cpu_freq, ppc_tb_freq);
-	
+
 }
 
 void __init wrhv_time_init(void)
@@ -328,90 +328,90 @@ extern void set_ppc_spurious_interrupts(int value);
 
 void wrhv_do_IRQ(struct pt_regs *regs)
 {
-        struct pt_regs *old_regs = set_irq_regs(regs);
-        unsigned int irq;
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	unsigned int irq;
 #ifdef CONFIG_IRQSTACKS
-        struct thread_info *curtp, *irqtp;
+	struct thread_info *curtp, *irqtp;
 #endif
 
-        irq_enter();
+	irq_enter();
 
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
-        /* Debugging check for stack overflow: is there less than 2KB free? */
-        {
-                long sp;
-
-                sp = __get_SP() & (THREAD_SIZE-1);
-
-                if (unlikely(sp < (sizeof(struct thread_info) + 2048))) {
-                        printk("do_IRQ: stack overflow: %ld\n",
-                                sp - sizeof(struct thread_info));
-                        dump_stack();
-                }
-        }
+	/* Debugging check for stack overflow: is there less than 2KB free? */
+	{
+		long sp;
+
+		sp = __get_SP() & (THREAD_SIZE-1);
+
+		if (unlikely(sp < (sizeof(struct thread_info) + 2048))) {
+			printk("do_IRQ: stack overflow: %ld\n",
+				sp - sizeof(struct thread_info));
+			dump_stack();
+		}
+	}
 #endif
 
-        /*
-         * Every platform is required to implement ppc_md.get_irq.
-         * This function will either return an irq number or NO_IRQ to
-         * indicate there are no more pending.
-         * The value NO_IRQ_IGNORE is for buggy hardware and means that this
-         * IRQ has already been handled. -- Tom
-         */
+	/*
+	 * Every platform is required to implement ppc_md.get_irq.
+	 * This function will either return an irq number or NO_IRQ to
+	 * indicate there are no more pending.
+	 * The value NO_IRQ_IGNORE is for buggy hardware and means that this
+	 * IRQ has already been handled. -- Tom
+	 */
 check_again:
-        irq = ppc_md.get_irq();
+	irq = ppc_md.get_irq();
 
-        if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
+	if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
 #ifdef CONFIG_IRQSTACKS
-                /* Switch to the irq stack to handle this */
-                curtp = current_thread_info();
-                irqtp = hardirq_ctx[smp_processor_id()];
-                if (curtp != irqtp) {
-                        struct irq_desc *desc = irq_desc + irq;
-                        void *handler = desc->handle_irq;
-                        unsigned long saved_sp_limit = current->thread.ksp_limit;
-                        if (handler == NULL)
-                                handler = &__do_IRQ;
-                        irqtp->task = curtp->task;
-                        irqtp->flags = 0;
-
-                        /* Copy the softirq bits in preempt_count so that the
-                         * softirq checks work in the hardirq context.
-                         */
-                        irqtp->preempt_count =
-                                (irqtp->preempt_count & ~SOFTIRQ_MASK) |
-                                (curtp->preempt_count & SOFTIRQ_MASK);
-
-                        current->thread.ksp_limit = (unsigned long)irqtp +
-                                _ALIGN_UP(sizeof(struct thread_info), 16);
-  			call_handle_irq(irq, desc, irqtp, handler);
-                        current->thread.ksp_limit = saved_sp_limit;
-                        irqtp->task = NULL;
-
-
-                        /* Set any flag that may have been set on the
-                         * alternate stack
-                         */
-                        if (irqtp->flags)
-                                set_bits(irqtp->flags, &curtp->flags);
-                } else
+		/* Switch to the irq stack to handle this */
+		curtp = current_thread_info();
+		irqtp = hardirq_ctx[smp_processor_id()];
+		if (curtp != irqtp) {
+			struct irq_desc *desc = irq_desc + irq;
+			void *handler = desc->handle_irq;
+			unsigned long saved_sp_limit = current->thread.ksp_limit;
+			if (handler == NULL)
+				handler = &__do_IRQ;
+			irqtp->task = curtp->task;
+			irqtp->flags = 0;
+
+			/* Copy the softirq bits in preempt_count so that the
+			 * softirq checks work in the hardirq context.
+			 */
+			irqtp->preempt_count =
+				(irqtp->preempt_count & ~SOFTIRQ_MASK) |
+				(curtp->preempt_count & SOFTIRQ_MASK);
+
+			current->thread.ksp_limit = (unsigned long)irqtp +
+				_ALIGN_UP(sizeof(struct thread_info), 16);
+			call_handle_irq(irq, desc, irqtp, handler);
+			current->thread.ksp_limit = saved_sp_limit;
+			irqtp->task = NULL;
+
+
+			/* Set any flag that may have been set on the
+			 * alternate stack
+			 */
+			if (irqtp->flags)
+				set_bits(irqtp->flags, &curtp->flags);
+		} else
 #endif
-                        generic_handle_irq(irq);
-                goto check_again;
-        } else if (irq != NO_IRQ_IGNORE)
-                /* That's not SMP safe ... but who cares ? */
-                set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
+			generic_handle_irq(irq);
+		goto check_again;
+	} else if (irq != NO_IRQ_IGNORE)
+		/* That's not SMP safe ... but who cares ? */
+		set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
 
-        irq_exit();
-        set_irq_regs(old_regs);
+	irq_exit();
+	set_irq_regs(old_regs);
 
 #ifdef CONFIG_PPC_ISERIES
-        if (firmware_has_feature(FW_FEATURE_ISERIES) &&
-                        get_lppaca()->int_dword.fields.decr_int) {
-                get_lppaca()->int_dword.fields.decr_int = 0;
-                /* Signal a fake decrementer interrupt */
-                timer_interrupt(regs);
-        }
+	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
+			get_lppaca()->int_dword.fields.decr_int) {
+		get_lppaca()->int_dword.fields.decr_int = 0;
+		/* Signal a fake decrementer interrupt */
+		timer_interrupt(regs);
+	}
 #endif
 }
 
@@ -419,11 +419,11 @@ unsigned int wrhv_irq_of_parse_and_map(struct device_node *dev, int index)
 {
 	int irq;
 
-        irq = vbi_find_irq(dev->full_name, VB_INPUT_INT);
-        if (irq == VBI_INVALID_IRQ)
-                return NO_IRQ;
+	irq = vbi_find_irq(dev->full_name, VB_INPUT_INT);
+	if (irq == VBI_INVALID_IRQ)
+		return NO_IRQ;
 
-        return irq;
+	return irq;
 }
 
 unsigned int wrhv_get_pvr(void)
@@ -437,21 +437,21 @@ unsigned int wrhv_get_pvr(void)
 /* arch/powerpc/kernel/time.c */
 #define HWTIMER_USE_JIFFY 1
 static void wrhv_set_mode(enum clock_event_mode mode,
-                                 struct clock_event_device *dev)
+				 struct clock_event_device *dev)
 {
-        return;
+	return;
 }
 
 static int wrhv_set_next_event(unsigned long evt,
-                                      struct clock_event_device *dev)
+				      struct clock_event_device *dev)
 {
-        return 0;
+	return 0;
 }
 static struct clock_event_device wrhv_clockevent = {
-       .name           = "wrhv",
-       .shift          = 32,
-       .irq            = 0,
-       .mult           = 1,     /* To be filled in */
+       .name	   = "wrhv",
+       .shift	  = 32,
+       .irq	    = 0,
+       .mult	   = 1,     /* To be filled in */
        .set_mode       = wrhv_set_mode,
        .set_next_event = wrhv_set_next_event,
        .features       = CLOCK_EVT_FEAT_ONESHOT,
@@ -510,15 +510,14 @@ void __init wrhv_time_init_cont(void)
 
 
 /* arch/powerpc/mm/fault.c */
-void wrhv_vmmu_restore (void)
+void wrhv_vmmu_restore(void)
 {
 	/*
-	 * this function is called by the end of page fault handling to reinstall
-	 * the vmmu
+	 * called by the end of page fault handling to reinstall the vmmu
 	 */
-        wrhvControl->vmmu0 = wrhvStatus->vmmu0;
-        wrhvControl->vmmu1 = wrhvStatus->vmmu1;
-        return;
+	wrhvControl->vmmu0 = wrhvStatus->vmmu0;
+	wrhvControl->vmmu1 = wrhvStatus->vmmu1;
+	return;
 }
 
 /* arch/powerpc/mm/fsl_booke_mmu.c */
@@ -535,76 +534,77 @@ unsigned long __init wrhv_mmu_mapin_ram(void)
 /* arch/powerpc/mm/init_32.c */
 void wrhv_MMU_setup(void)
 {
-        __map_without_bats = 1;
+	__map_without_bats = 1;
 
 #ifdef CONFIG_DEBUG_PAGEALLOC
-        __map_without_bats = 1;
-        __map_without_ltlbs = 1;
+	__map_without_bats = 1;
+	__map_without_ltlbs = 1;
 #endif
 }
 
 void __init wrhv_MMU_init(void)
 {
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:enter", 0x111);
+	if (ppc_md.progress)
+		ppc_md.progress("MMU:enter", 0x111);
 
-        /* parse args from command line */
-        wrhv_MMU_setup();
+	/* parse args from command line */
+	wrhv_MMU_setup();
 
-        if (lmb.memory.cnt > 1) {
-                lmb.memory.cnt = 1;
-                lmb_analyze();
-                printk(KERN_WARNING "Only using first contiguous memory region");
-        }
+	if (lmb.memory.cnt > 1) {
+		lmb.memory.cnt = 1;
+		lmb_analyze();
+		printk(KERN_WARNING "Only using first contiguous memory region");
+	}
 
-        total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
-        lowmem_end_addr = memstart_addr + total_lowmem;
+	total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
+	lowmem_end_addr = memstart_addr + total_lowmem;
 
-        if (total_lowmem > __max_low_memory) {
-                total_lowmem = __max_low_memory;
-                lowmem_end_addr = memstart_addr + total_lowmem;
+	if (total_lowmem > __max_low_memory) {
+		total_lowmem = __max_low_memory;
+		lowmem_end_addr = memstart_addr + total_lowmem;
 #ifndef CONFIG_HIGHMEM
-                total_memory = total_lowmem;
-                lmb_enforce_memory_limit(lowmem_end_addr);
-                lmb_analyze();
+		total_memory = total_lowmem;
+		lmb_enforce_memory_limit(lowmem_end_addr);
+		lmb_analyze();
 #endif /* CONFIG_HIGHMEM */
-        }
+	}
 
-        /* Initialize the MMU hardware */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:hw init", 0x300);
-        MMU_init_hw();
+	/* Initialize the MMU hardware */
+	if (ppc_md.progress)
+		ppc_md.progress("MMU:hw init", 0x300);
+	MMU_init_hw();
 
-        /* Map in all of RAM starting at KERNELBASE */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:mapin", 0x301);
-        mapin_ram();
+	/* Map in all of RAM starting at KERNELBASE */
+	if (ppc_md.progress)
+		ppc_md.progress("MMU:mapin", 0x301);
+	mapin_ram();
 #ifdef CONFIG_HIGHMEM
-        ioremap_base = PKMAP_BASE;
+	ioremap_base = PKMAP_BASE;
 #else
-        ioremap_base = 0xfe000000UL;    /* for now, could be 0xfffff000 */
+	ioremap_base = 0xfe000000UL;    /* for now, could be 0xfffff000 */
 #endif /* CONFIG_HIGHMEM */
-        ioremap_bot = ioremap_base;
+	ioremap_bot = ioremap_base;
 
-        /* Map in I/O resources */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:setio", 0x302);
+	/* Map in I/O resources */
+	if (ppc_md.progress)
+		ppc_md.progress("MMU:setio", 0x302);
 
-        /* Initialize the context management stuff */
-        mmu_context_init();
+	/* Initialize the context management stuff */
+	mmu_context_init();
 
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:exit", 0x211);
+	if (ppc_md.progress)
+		ppc_md.progress("MMU:exit", 0x211);
 
-        /* From now on, btext is no longer BAT mapped if it was at all */
+	/* From now on, btext is no longer BAT mapped if it was at all */
 #ifdef CONFIG_BOOTX_TEXT
-        btext_unmap();
+	btext_unmap();
 #endif
 
-        /* we enables the mmu here without having to do this from the caller
-         * (which is in assembly world)
-         */
-        vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+	/*
+	 * we enable the mmu here without having to do this from the caller
+	 * (which is in assembly world)
+	 */
+	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
 }
 
 
@@ -615,328 +615,326 @@ extern const char * get_gfar_err_intr(void);
 
 int __init wrhv_gfar_of_init(void)
 {
-        struct device_node *np;
-        unsigned int i;
-        struct platform_device *gfar_dev;
-        struct resource res;
-        int ret;
-
-        for (np = NULL, i = 0;
-             (np = of_find_compatible_node(np, "network", "gianfar")) != NULL;
-             i++) {
-                struct resource r[4];
-                struct device_node *phy, *mdio;
-                struct gianfar_platform_data gfar_data;
-                const unsigned int *id;
-                const char *model;
-                const char *ctype;
-                const void *mac_addr;
-                const phandle *ph;
-                int n_res = 2;
-
-                if (!of_device_is_available(np))
-                        continue;
-
-                memset(r, 0, sizeof(r));
-                memset(&gfar_data, 0, sizeof(gfar_data));
-
-                ret = of_address_to_resource(np, 0, &r[0]);
-                if (ret)
-                        goto err;
-
-                of_irq_to_resource(np, 0, &r[1]);
-
-                model = of_get_property(np, "model", NULL);
-
-                /* If we aren't the FEC we have multiple interrupts */
-                if (model && strcasecmp(model, "FEC")) {
-                        int vector;
-                        char eTsec_tx[10];
-                        char eTsec_rx[10];
-                        char eTsec_err[10];
-
-                        sprintf(eTsec_tx,"etsec%d_tx", i+1);
-                        sprintf(eTsec_rx,"etsec%d_rx", i+1);
-                        sprintf(eTsec_err,"etsec%d_err", i+1);
-
-                        r[1].name = get_gfar_tx_intr();
-                        vector = vbi_find_irq(eTsec_tx, VB_INPUT_INT);
-                        r[1].start = vector;
-                        r[1].end = vector;
-                        r[1].flags = IORESOURCE_IRQ;
-
-                        r[2].name = get_gfar_rx_intr();
-                        vector = vbi_find_irq(eTsec_rx, VB_INPUT_INT);
-                        r[2].start = vector;
-                        r[2].end = vector;
-                        r[2].flags = IORESOURCE_IRQ;
-
-                        r[3].name = get_gfar_err_intr();
-                        vector = vbi_find_irq(eTsec_err, VB_INPUT_INT);
-                        r[3].start = vector;
+	struct device_node *np;
+	unsigned int i;
+	struct platform_device *gfar_dev;
+	struct resource res;
+	int ret;
+
+	for (np = NULL, i = 0;
+	     (np = of_find_compatible_node(np, "network", "gianfar")) != NULL;
+	     i++) {
+		struct resource r[4];
+		struct device_node *phy, *mdio;
+		struct gianfar_platform_data gfar_data;
+		const unsigned int *id;
+		const char *model;
+		const char *ctype;
+		const void *mac_addr;
+		const phandle *ph;
+		int n_res = 2;
+
+		if (!of_device_is_available(np))
+			continue;
+
+		memset(r, 0, sizeof(r));
+		memset(&gfar_data, 0, sizeof(gfar_data));
+
+		ret = of_address_to_resource(np, 0, &r[0]);
+		if (ret)
+			goto err;
+
+		of_irq_to_resource(np, 0, &r[1]);
+
+		model = of_get_property(np, "model", NULL);
+
+		/* If we aren't the FEC we have multiple interrupts */
+		if (model && strcasecmp(model, "FEC")) {
+			int vector;
+			char eTsec_tx[10];
+			char eTsec_rx[10];
+			char eTsec_err[10];
+
+			sprintf(eTsec_tx,"etsec%d_tx", i+1);
+			sprintf(eTsec_rx,"etsec%d_rx", i+1);
+			sprintf(eTsec_err,"etsec%d_err", i+1);
+
+			r[1].name = get_gfar_tx_intr();
+			vector = vbi_find_irq(eTsec_tx, VB_INPUT_INT);
+			r[1].start = vector;
+			r[1].end = vector;
+			r[1].flags = IORESOURCE_IRQ;
+
+			r[2].name = get_gfar_rx_intr();
+			vector = vbi_find_irq(eTsec_rx, VB_INPUT_INT);
+			r[2].start = vector;
+			r[2].end = vector;
+			r[2].flags = IORESOURCE_IRQ;
+
+			r[3].name = get_gfar_err_intr();
+			vector = vbi_find_irq(eTsec_err, VB_INPUT_INT);
+			r[3].start = vector;
 			r[3].end = vector;
-                        r[3].flags = IORESOURCE_IRQ;
-                        n_res += 2;
-                }
-
-                gfar_dev =
-                    platform_device_register_simple("fsl-gianfar", i, &r[0],
-                                                    n_res);
-
-                if (IS_ERR(gfar_dev)) {
-                        ret = PTR_ERR(gfar_dev);
-                        goto err;
-                }
-
-                mac_addr = of_get_mac_address(np);
-                if (mac_addr)
-                        memcpy(gfar_data.mac_addr, mac_addr, 6);
-
-                if (model && !strcasecmp(model, "TSEC"))
-                        gfar_data.device_flags =
-                            FSL_GIANFAR_DEV_HAS_GIGABIT |
-                            FSL_GIANFAR_DEV_HAS_COALESCE |
-                            FSL_GIANFAR_DEV_HAS_RMON |
-                            FSL_GIANFAR_DEV_HAS_MULTI_INTR;
-                if (model && !strcasecmp(model, "eTSEC"))
-                        gfar_data.device_flags =
-                            FSL_GIANFAR_DEV_HAS_GIGABIT |
-                            FSL_GIANFAR_DEV_HAS_COALESCE |
-                            FSL_GIANFAR_DEV_HAS_RMON |
-                            FSL_GIANFAR_DEV_HAS_MULTI_INTR |
-                            FSL_GIANFAR_DEV_HAS_CSUM |
-                            FSL_GIANFAR_DEV_HAS_VLAN |
-                            FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
-
-                ctype = of_get_property(np, "phy-connection-type", NULL);
-
-                /* We only care about rgmii-id.  The rest are autodetected */
-                if (ctype && !strcmp(ctype, "rgmii-id"))
-                        gfar_data.interface = PHY_INTERFACE_MODE_RGMII_ID;
-                else
-                        gfar_data.interface = PHY_INTERFACE_MODE_MII;
-
-                if (of_get_property(np, "fsl,magic-packet", NULL))
-                        gfar_data.device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
-
-                ph = of_get_property(np, "phy-handle", NULL);
+			r[3].flags = IORESOURCE_IRQ;
+			n_res += 2;
+		}
+
+		gfar_dev =
+		    platform_device_register_simple("fsl-gianfar", i, &r[0],
+						    n_res);
+
+		if (IS_ERR(gfar_dev)) {
+			ret = PTR_ERR(gfar_dev);
+			goto err;
+		}
+
+		mac_addr = of_get_mac_address(np);
+		if (mac_addr)
+			memcpy(gfar_data.mac_addr, mac_addr, 6);
+
+		if (model && !strcasecmp(model, "TSEC"))
+			gfar_data.device_flags =
+			    FSL_GIANFAR_DEV_HAS_GIGABIT |
+			    FSL_GIANFAR_DEV_HAS_COALESCE |
+			    FSL_GIANFAR_DEV_HAS_RMON |
+			    FSL_GIANFAR_DEV_HAS_MULTI_INTR;
+		if (model && !strcasecmp(model, "eTSEC"))
+			gfar_data.device_flags =
+			    FSL_GIANFAR_DEV_HAS_GIGABIT |
+			    FSL_GIANFAR_DEV_HAS_COALESCE |
+			    FSL_GIANFAR_DEV_HAS_RMON |
+			    FSL_GIANFAR_DEV_HAS_MULTI_INTR |
+			    FSL_GIANFAR_DEV_HAS_CSUM |
+			    FSL_GIANFAR_DEV_HAS_VLAN |
+			    FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
+
+		ctype = of_get_property(np, "phy-connection-type", NULL);
+
+		/* We only care about rgmii-id.  The rest are autodetected */
+		if (ctype && !strcmp(ctype, "rgmii-id"))
+			gfar_data.interface = PHY_INTERFACE_MODE_RGMII_ID;
+		else
+			gfar_data.interface = PHY_INTERFACE_MODE_MII;
+
+		if (of_get_property(np, "fsl,magic-packet", NULL))
+			gfar_data.device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
+
+		ph = of_get_property(np, "phy-handle", NULL);
 		if (ph == NULL) {
-                        u32 *fixed_link;
-
-                        fixed_link = (u32 *)of_get_property(np, "fixed-link",
-                                                           NULL);
-                        if (!fixed_link) {
-                                ret = -ENODEV;
-                                goto unreg;
-                        }
-
-                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "0");
-                        gfar_data.phy_id = fixed_link[0];
-                } else {
-                        phy = of_find_node_by_phandle(*ph);
-
-                        if (phy == NULL) {
-                                ret = -ENODEV;
-                                goto unreg;
-                        }
-
-                        mdio = of_get_parent(phy);
-
-                        id = of_get_property(phy, "reg", NULL);
-                        ret = of_address_to_resource(mdio, 0, &res);
-                        if (ret) {
-                                of_node_put(phy);
-                                of_node_put(mdio);
-                                goto unreg;
-                        }
-
-                        gfar_data.phy_id = *id;
-                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "%llx",
-                                 (unsigned long long)res.start&0xfffff);
-
-                        of_node_put(phy);
-                        of_node_put(mdio);
-                }
-
-                ret =
-                    platform_device_add_data(gfar_dev, &gfar_data,
-                                             sizeof(struct
-                                                    gianfar_platform_data));
-                if (ret)
-                        goto unreg;
-        }
-
-        return 0;
+			u32 *fixed_link;
+
+			fixed_link = (u32 *)of_get_property(np, "fixed-link",
+							   NULL);
+			if (!fixed_link) {
+				ret = -ENODEV;
+				goto unreg;
+			}
+
+			snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "0");
+			gfar_data.phy_id = fixed_link[0];
+		} else {
+			phy = of_find_node_by_phandle(*ph);
+
+			if (phy == NULL) {
+				ret = -ENODEV;
+				goto unreg;
+			}
+
+			mdio = of_get_parent(phy);
+
+			id = of_get_property(phy, "reg", NULL);
+			ret = of_address_to_resource(mdio, 0, &res);
+			if (ret) {
+				of_node_put(phy);
+				of_node_put(mdio);
+				goto unreg;
+			}
+
+			gfar_data.phy_id = *id;
+			snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "%llx",
+				 (unsigned long long)res.start&0xfffff);
+
+			of_node_put(phy);
+			of_node_put(mdio);
+		}
+
+		ret = platform_device_add_data(gfar_dev, &gfar_data,
+					sizeof(struct gianfar_platform_data));
+		if (ret)
+			goto unreg;
+	}
+
+	return 0;
 
 unreg:
-        platform_device_unregister(gfar_dev);
+	platform_device_unregister(gfar_dev);
 err:
-        return ret;
+	return ret;
 }
 
 /* arch/powerpc/mm/mem.c */
 extern void __flush_dcache_icache_phys(unsigned long physaddr);
 void wrhv_flush_dcache_page(struct page *page)
 {
-        if (cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
-                return;
-        /* avoid an atomic op if possible */
-        if (test_bit(PG_arch_1, &page->flags))
-                clear_bit(PG_arch_1, &page->flags);
-        __flush_dcache_icache_phys(page_to_pfn(page) << PAGE_SHIFT);
+	if (cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
+		return;
+	/* avoid an atomic op if possible */
+	if (test_bit(PG_arch_1, &page->flags))
+		clear_bit(PG_arch_1, &page->flags);
+	__flush_dcache_icache_phys(page_to_pfn(page) << PAGE_SHIFT);
 }
 
 void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
-                      pte_t pte)
+		      pte_t pte)
 {
-        unsigned long pfn = pte_pfn(pte);
+	unsigned long pfn = pte_pfn(pte);
 
-        /* handle i-cache coherency */
-        if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE) &&
-            !cpu_has_feature(CPU_FTR_NOEXECUTE) &&
-            pfn_valid(pfn)) {
-                struct page *page = pfn_to_page(pfn);
+	/* handle i-cache coherency */
+	if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE) &&
+	    !cpu_has_feature(CPU_FTR_NOEXECUTE) &&
+	    pfn_valid(pfn)) {
+		struct page *page = pfn_to_page(pfn);
 #ifdef CONFIG_8xx
-                /* On 8xx, cache control instructions (particularly
-                 * "dcbst" from flush_dcache_icache) fault as write
-                 * operation if there is an unpopulated TLB entry
-                 * for the address in question. To workaround that,
-                 * we invalidate the TLB here, thus avoiding dcbst
-                 * misbehaviour.
-                 */
-                _tlbie(address, 0 /* 8xx doesn't care about PID */);
+		/* On 8xx, cache control instructions (particularly
+		 * "dcbst" from flush_dcache_icache) fault as write
+		 * operation if there is an unpopulated TLB entry
+		 * for the address in question. To workaround that,
+		 * we invalidate the TLB here, thus avoiding dcbst
+		 * misbehaviour.
+		 */
+		_tlbie(address, 0 /* 8xx doesn't care about PID */);
 #endif
-                /* The _PAGE_USER test should really be _PAGE_EXEC, but
-                 * older glibc versions execute some code from no-exec
-                 * pages, which for now we are supporting.  If exec-only
-                 * pages are ever implemented, this will have to change.
-                 */
-                if (!PageReserved(page) && (pte_val(pte) & _PAGE_USER)
-                    && !test_bit(PG_arch_1, &page->flags)) {
-                        if (vma->vm_mm == current->active_mm) {
-                                __flush_dcache_icache((void *) address);
-                        } else
-                                flush_dcache_icache_page(page);
-                        set_bit(PG_arch_1, &page->flags);
-                }
-        }
+		/* The _PAGE_USER test should really be _PAGE_EXEC, but
+		 * older glibc versions execute some code from no-exec
+		 * pages, which for now we are supporting.  If exec-only
+		 * pages are ever implemented, this will have to change.
+		 */
+		if (!PageReserved(page) && (pte_val(pte) & _PAGE_USER)
+		    && !test_bit(PG_arch_1, &page->flags)) {
+			if (vma->vm_mm == current->active_mm) {
+				__flush_dcache_icache((void *) address);
+			} else
+				flush_dcache_icache_page(page);
+			set_bit(PG_arch_1, &page->flags);
+		}
+	}
 }
 
 /* arch/powerpc/mm/mmu_context_32.c */
 void set_context(unsigned long contextId, pgd_t * pgd)
 {
 
-        pgd_t * kpdStart, *kpdEnd, *updStart;
-        /* we attach (copy) kernel page mapping to the user page table
-         * Note, we only copy the L1 entrys to user L1 pageTable,
-         * then letting L1 share the same L2 page table
-         */
+	pgd_t * kpdStart, *kpdEnd, *updStart;
+	/* we attach (copy) kernel page mapping to the user page table
+	 * Note, we only copy the L1 entrys to user L1 pageTable,
+	 * then letting L1 share the same L2 page table
+	 */
 
-        kpdStart = pgd_offset_k(KERNELBASE);
-        kpdEnd =   pgd_offset_k(0xffffffff);
+	kpdStart = pgd_offset_k(KERNELBASE);
+	kpdEnd =   pgd_offset_k(0xffffffff);
 
-        updStart = pgd + pgd_index(KERNELBASE);
+	updStart = pgd + pgd_index(KERNELBASE);
 
-        memcpy(updStart, kpdStart, (kpdEnd - kpdStart + 1) * sizeof (pgd_t));
+	memcpy(updStart, kpdStart, (kpdEnd - kpdStart + 1) * sizeof (pgd_t));
 
-        /* in linux context, page table entry is not set up yet */
-        vb_context_mmu_on(contextId, pgd, PAGE_SIZE, 0);
+	/* in linux context, page table entry is not set up yet */
+	vb_context_mmu_on(contextId, pgd, PAGE_SIZE, 0);
 }
 
 /* arch/powerpc/mm/pgtable_32.c */
 int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
 {
-        pmd_t *pd;
-        pte_t *pg;
-        int err = -ENOMEM;
-
-        /* Use upper 10 bits of VA to index the first level map */
-        pd = pmd_offset(pud_offset(pgd_offset_k(va), va), va);
-        /* Use middle 10 bits of VA to index the second-level map */
-        pg = pte_alloc_kernel(pd, va);
-        if (pg != 0) {
-                err = 0;
-                /* The PTE should never be already set nor present in the
-                 * hash table
-                 */
-                BUG_ON(pte_val(*pg) & (_PAGE_PRESENT | _PAGE_HASHPTE));
-                set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
-                                                     __pgprot(flags)));
-        }
-        if (mem_init_done)
-                flush_HPTE(0, va, pmd_val(*pmd));
-        return err;
+	pmd_t *pd;
+	pte_t *pg;
+	int err = -ENOMEM;
+
+	/* Use upper 10 bits of VA to index the first level map */
+	pd = pmd_offset(pud_offset(pgd_offset_k(va), va), va);
+	/* Use middle 10 bits of VA to index the second-level map */
+	pg = pte_alloc_kernel(pd, va);
+	if (pg != 0) {
+		err = 0;
+		/* The PTE should never be already set nor present in the
+		 * hash table
+		 */
+		BUG_ON(pte_val(*pg) & (_PAGE_PRESENT | _PAGE_HASHPTE));
+		set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
+						     __pgprot(flags)));
+	}
+	if (mem_init_done)
+		flush_HPTE(0, va, pmd_val(*pmd));
+	return err;
 }
 
 
 /* arch/powerpc/kernel/traps.c */
 void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_status)
 {
-        debug_status = wrhvControl->vbControlRegs.dbsr;
-        wrhvControl->vbControlRegs.emsr &= ~MSR_DE;
-        
+	debug_status = wrhvControl->vbControlRegs.dbsr;
+	wrhvControl->vbControlRegs.emsr &= ~MSR_DE;
+
 	if (debug_status & DBSR_IC) {   /* instruction completion */
-                regs->msr &= ~MSR_DE;
-                if (notify_die(DIE_SSTEP, "single_step", regs, 5,
-                               5, SIGTRAP) == NOTIFY_STOP) {
-                        return;
-                }
-
-                if (debugger_sstep(regs))
-                        return;
-
-                if (user_mode(regs)) {
-                        current->thread.dbcr0 &= ~DBCR0_IC;
-                }
-
-                _exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);
-        } else if (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {
-                regs->msr &= ~MSR_DE;
-
-                if (user_mode(regs)) {
-                        current->thread.dbcr0 &= ~(DBSR_DAC1R | DBSR_DAC1W |
-                                                                DBCR0_IDM);
-                } else {
-                        /* Disable DAC interupts */
-                        mtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~(DBSR_DAC1R |
-                                                DBSR_DAC1W | DBCR0_IDM));
-
-                        /* Clear the DAC event */
-                        mtspr(SPRN_DBSR, (DBSR_DAC1R | DBSR_DAC1W));
-                }
-                /* Setup and send the trap to the handler */
-                do_dabr(regs, mfspr(SPRN_DAC1), debug_status);
-        }
+		regs->msr &= ~MSR_DE;
+		if (notify_die(DIE_SSTEP, "single_step", regs, 5,
+			       5, SIGTRAP) == NOTIFY_STOP) {
+			return;
+		}
+
+		if (debugger_sstep(regs))
+			return;
+
+		if (user_mode(regs)) {
+			current->thread.dbcr0 &= ~DBCR0_IC;
+		}
+
+		_exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);
+	} else if (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {
+		regs->msr &= ~MSR_DE;
+
+		if (user_mode(regs)) {
+			current->thread.dbcr0 &= ~(DBSR_DAC1R | DBSR_DAC1W |
+								DBCR0_IDM);
+		} else {
+			/* Disable DAC interupts */
+			mtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~(DBSR_DAC1R |
+						DBSR_DAC1W | DBCR0_IDM));
+
+			/* Clear the DAC event */
+			mtspr(SPRN_DBSR, (DBSR_DAC1R | DBSR_DAC1W));
+		}
+		/* Setup and send the trap to the handler */
+		do_dabr(regs, mfspr(SPRN_DAC1), debug_status);
+	}
 }
 
 /* arch/powerpc/kernel/kgdb.c */
 int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
-                               char *remcom_in_buffer, char *remcom_out_buffer,
-                               struct pt_regs *linux_regs)
+			       char *remcom_in_buffer, char *remcom_out_buffer,
+			       struct pt_regs *linux_regs)
 {
-        char *ptr = &remcom_in_buffer[1];
-        unsigned long addr; 
-
-        switch (remcom_in_buffer[0]) {
-                /*
-                 * sAA..AA   Step one instruction from AA..AA
-                 * This will return an error to gdb ..
-                 */
-        case 's':
-        case 'c':
-                /* handle the optional parameter */
-                if (kgdb_hex2long(&ptr, &addr))
-                        linux_regs->nip = addr;
-
-                atomic_set(&kgdb_cpu_doing_single_step, -1);
-                /* set the trace bit if we're stepping */
-                if (remcom_in_buffer[0] == 's') {
+	char *ptr = &remcom_in_buffer[1];
+	unsigned long addr;
+
+	switch (remcom_in_buffer[0]) {
+		/*
+		 * sAA..AA   Step one instruction from AA..AA
+		 * This will return an error to gdb ..
+		 */
+	case 's':
+	case 'c':
+		/* handle the optional parameter */
+		if (kgdb_hex2long(&ptr, &addr))
+			linux_regs->nip = addr;
+
+		atomic_set(&kgdb_cpu_doing_single_step, -1);
+		/* set the trace bit if we're stepping */
+		if (remcom_in_buffer[0] == 's') {
 #if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
 			/*
 			 * Set hypervisor DBCR0_IC single step and
 			 * DBCR0_IDM internal debug mode.
 			 */
-                        wrhvControl->vbControlRegs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
+			wrhvControl->vbControlRegs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
 
 			/*
 			 * Set Debug Enable bit in hypervisor's emulated MSR which
@@ -944,16 +942,16 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 			 */
 			wrhvControl->vbControlRegs.emsr |= MSR_DE;
 #else
-                        linux_regs->msr |= MSR_SE;
+			linux_regs->msr |= MSR_SE;
 #endif
-                        kgdb_single_step = 1;
-                        atomic_set(&kgdb_cpu_doing_single_step,
-                                   raw_smp_processor_id());
-                }
-                return 0;
-        }
-
-        return -1;
+			kgdb_single_step = 1;
+			atomic_set(&kgdb_cpu_doing_single_step,
+				   raw_smp_processor_id());
+		}
+		return 0;
+	}
+
+	return -1;
 }
 
 int wrhv_ppc_cpu_freq(void)
@@ -978,26 +976,26 @@ void wrhv_init(void)
 	pv_time_ops.timer_interrupt = wrhv_hw_timer_interrupt;
 	pv_time_ops.clocksource_init = wrhv_clocksource_init;
 
-        pv_irq_ops.do_IRQ = wrhv_do_IRQ;
-        pv_irq_ops.irq_of_parse_and_map =
+	pv_irq_ops.do_IRQ = wrhv_do_IRQ;
+	pv_irq_ops.irq_of_parse_and_map =
 			wrhv_irq_of_parse_and_map;
 
 	pv_cpu_ops.get_pvr = wrhv_get_pvr;
 	pv_cpu_ops.gfar_of_init =  wrhv_gfar_of_init;
-        pv_cpu_ops.DebugException = wrhv_DebugException;
-        pv_cpu_ops.kgdb_arch_handle_exception = 
-                wrhv_kgdb_arch_handle_exception;
+	pv_cpu_ops.DebugException = wrhv_DebugException;
+	pv_cpu_ops.kgdb_arch_handle_exception =
+		wrhv_kgdb_arch_handle_exception;
 	pv_cpu_ops.ppc_proc_freq =
 		wrhv_ppc_cpu_freq;
 
 	pv_mmu_ops.vmmu_restore = wrhv_vmmu_restore;
-        pv_mmu_ops.MMU_init_hw = wrhv_MMU_init_hw;
-        pv_mmu_ops.mmu_mapin_ram = wrhv_mmu_mapin_ram;
-        pv_mmu_ops.MMU_setup = wrhv_MMU_setup;
-        pv_mmu_ops.MMU_init = wrhv_MMU_init;
-        pv_mmu_ops.flush_dcache_page = wrhv_flush_dcache_page;
-        pv_mmu_ops.update_mmu_cache = wrhv_update_mmu_cache;
-        pv_mmu_ops.map_page = wrhv_map_page;
+	pv_mmu_ops.MMU_init_hw = wrhv_MMU_init_hw;
+	pv_mmu_ops.mmu_mapin_ram = wrhv_mmu_mapin_ram;
+	pv_mmu_ops.MMU_setup = wrhv_MMU_setup;
+	pv_mmu_ops.MMU_init = wrhv_MMU_init;
+	pv_mmu_ops.flush_dcache_page = wrhv_flush_dcache_page;
+	pv_mmu_ops.update_mmu_cache = wrhv_update_mmu_cache;
+	pv_mmu_ops.map_page = wrhv_map_page;
 	pv_mmu_ops.early_init_dt_scan_memory =
 		wrhv_early_init_dt_scan_memory;
 
@@ -1009,7 +1007,7 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	int irq;
 	u8  pin;
 	char VectorName[8];
-	
+
 	pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
 
 	switch (dev->bus->number) {
@@ -1033,11 +1031,11 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	default:
 		break;
 	}
-	
+
 	dev->irq = irq;
-        printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d\n",
-                dev->bus->number, dev->class, dev->irq);
-	
+	printk("WRHV-PCI: BUS NO:%x CLASS:%x IRQ%d\n",
+		dev->bus->number, dev->class, dev->irq);
+
 	return irq;
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index a069ad1..23b060d 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -53,15 +53,15 @@
 #define memoryAliasAddress	mem_alias_addr
 #define physicalMemorySize	phys_mem_size
 
-#define numInt		num_int
-#define numSm		num_sm
-#define numMem		num_mem
-
-#define intPending	int_pend
-#define resetPC		reset_pc
-#define bootCount	boot_count
-#define boardName	board_name
-#define boardType	board_type
+#define numInt			num_int
+#define numSm			num_sm
+#define numMem			num_mem
+
+#define intPending		int_pend
+#define resetPC			reset_pc
+#define bootCount		boot_count
+#define boardName		board_name
+#define boardType		board_type
 
 #define tickTimerFrequency	tick_freq
 #define tickCount		tick_count
-- 
1.6.5.2

