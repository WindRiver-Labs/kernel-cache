diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 8cc688a..6ad1f73 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -438,6 +438,7 @@ source "arch/x86/lguest/Kconfig"
 
 config PARAVIRT
 	bool "Enable paravirtualization code"
+	default y
 	depends on !X86_VOYAGER
 	help
 	  This changes the kernel so it can modify itself when it is run
diff --git a/arch/x86/kernel/cpu/mcheck/non-fatal.c b/arch/x86/kernel/cpu/mcheck/non-fatal.c
index cc1fccd..5583677 100644
--- a/arch/x86/kernel/cpu/mcheck/non-fatal.c
+++ b/arch/x86/kernel/cpu/mcheck/non-fatal.c
@@ -67,6 +67,9 @@ static int __init init_nonfatal_mce_checker(void)
 {
 	struct cpuinfo_x86 *c = &boot_cpu_data;
 
+	if (mce_disabled == 1)
+		return -ENODEV;
+
 	/* Check for MCE support */
 	if (!cpu_has(c, X86_FEATURE_MCE))
 		return -ENODEV;
diff --git a/arch/x86/kernel/i8237.c b/arch/x86/kernel/i8237.c
index dbd6c1d..3fbf38c 100644
--- a/arch/x86/kernel/i8237.c
+++ b/arch/x86/kernel/i8237.c
@@ -63,9 +63,15 @@ static struct sys_device device_i8237A = {
 
 static int __init i8237A_init_sysfs(void)
 {
-	int error = sysdev_class_register(&i8237_sysdev_class);
+	int error = -ENOSYS;
+
+	if (paravirt_enabled())
+		goto done;
+
+	error = sysdev_class_register(&i8237_sysdev_class);
 	if (!error)
 		error = sysdev_register(&device_i8237A);
+done:
 	return error;
 }
 
diff --git a/arch/x86/kernel/i8253.c b/arch/x86/kernel/i8253.c
index c1b5e3e..7471305 100644
--- a/arch/x86/kernel/i8253.c
+++ b/arch/x86/kernel/i8253.c
@@ -214,6 +214,9 @@ static void pit_disable_clocksource(void)
 
 static int __init init_pit_clocksource(void)
 {
+	if (paravirt_enabled())
+		return 0;
+
 	 /*
 	  * Several reasons not to register PIT as a clocksource:
 	  *
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index dc92b49..bd18e15 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -274,9 +274,15 @@ static struct sys_device device_i8259A = {
 
 static int __init i8259A_init_sysfs(void)
 {
-	int error = sysdev_class_register(&i8259_sysdev_class);
+	int error = -ENOSYS;
+
+	if (paravirt_enabled())
+		goto done;
+
+	error = sysdev_class_register(&i8259_sysdev_class);
 	if (!error)
 		error = sysdev_register(&device_i8259A);
+done:
 	return error;
 }
 
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 8d5feb2..814f7f9 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -102,6 +102,7 @@
 #include <asm/percpu.h>
 #include <asm/topology.h>
 #include <asm/apicdef.h>
+#include <asm/wrhv.h>
 #ifdef CONFIG_X86_64
 #include <asm/numa_64.h>
 #endif
@@ -250,13 +251,15 @@ static inline void copy_edd(void)
 
 #ifdef CONFIG_BLK_DEV_INITRD
 
+#ifdef CONFIG_X86_32
+
 #define MAX_MAP_CHUNK	(NR_FIX_BTMAPS << PAGE_SHIFT)
 static void __init relocate_initrd(void)
 {
 
 	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
-	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
+	u64 end_of_lowmem = max_low_pfn << PAGE_SHIFT;
 	u64 ramdisk_here;
 	unsigned long slop, clen, mapaddr;
 	char *p, *q;
@@ -313,12 +316,14 @@ static void __init relocate_initrd(void)
 		ramdisk_here, ramdisk_here + ramdisk_size - 1);
 }
 
+#endif
+
 static void __init reserve_initrd(void)
 {
 	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
 	u64 ramdisk_end   = ramdisk_image + ramdisk_size;
-	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
+	u64 end_of_lowmem = max_low_pfn << PAGE_SHIFT;
 
 	if (!boot_params.hdr.type_of_loader ||
 	    !ramdisk_image || !ramdisk_size)
@@ -348,7 +353,14 @@ static void __init reserve_initrd(void)
 		return;
 	}
 
+#ifdef CONFIG_X86_32
 	relocate_initrd();
+#else
+	printk(KERN_ERR "initrd extends beyond end of memory "
+              "(0x%08llx > 0x%08llx)\ndisabling initrd\n",
+              ramdisk_end, end_of_lowmem);
+	initrd_start = 0;
+#endif
 
 	free_early(ramdisk_image, ramdisk_end);
 }
@@ -617,6 +629,7 @@ static struct dmi_system_id __initdata bad_bios_dmi_table[] = {
 
 void __init setup_arch(char **cmdline_p)
 {
+	wrhv_boot_config();
 #ifdef CONFIG_X86_32
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
 	visws_early_detect();
@@ -696,6 +710,8 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
 
+	wrhv_init();
+
 	parse_early_param();
 
 #ifdef CONFIG_X86_64
@@ -902,6 +918,8 @@ void __init setup_arch(char **cmdline_p)
 
 	e820_setup_gap();
 
+	wrhv_calibrate_smp_cpus();
+
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
