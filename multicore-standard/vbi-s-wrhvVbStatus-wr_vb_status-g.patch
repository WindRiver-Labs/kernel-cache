From 38d2a89b051400ad10806467148bc3c5f7614f3e Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 1 Dec 2009 21:07:56 -0500
Subject: [PATCH 02/43] vbi: s/wrhvVbStatus/wr_vb_status/g

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |   12 ++++++------
 arch/powerpc/kernel/vbi/syscalls.S  |    4 ++--
 include/vbi/compat.h                |    2 ++
 include/vbi/interface.h             |    2 +-
 include/vbi/vbi.h                   |    4 ++--
 kernel/vbi/lib.c                    |    6 +++---
 kernel/vbi/wrhv.c                   |    4 ++--
 7 files changed, 18 insertions(+), 16 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 5969e91..3a8b408 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -536,7 +536,7 @@ typedef struct
  * enables the interrupts by clearing to zero the value in the core's control
  * structure and and makes a fast hypercall if need be. A hypercall is made only
  * if found that interrupts are pending. The pending interrupts are checked by
- * reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+ * reading the wr_vb_status structure at offset VB_STATUS_INT_PENDING. A
  * positive integer greater than zero indicates that interrupts are pending
  * which causes this macro to make a hypercall in order to drain the pending
  * interrupts. This macro expects two general purpose registers. The first
@@ -551,7 +551,7 @@ typedef struct
  *	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
  *
  * checkstatus:
- *	load address of wrhvVbStatus in reg0
+ *	load address of wr_vb_status in reg0
  *	load VB_STATUS_INT_PENDING(reg0) in reg1
  *	check if reg1 is equal to zero
  *	if true return
@@ -566,8 +566,8 @@ typedef struct
 	li	reg1, 0;					\
 	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
 checkIntVcorePending:						\
-	lis	reg0, HIADJ(wrhvVbStatus);			\
-	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
+	lis	reg0, HIADJ(wr_vb_status);			\
+	lwz	reg0, LO(wr_vb_status)(reg0);			\
 	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
 								\
 	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
@@ -653,8 +653,8 @@ endIntVcoreLock:
  */
 
 #define VBI_STATUS_ADDR_GET(reg)		    \
-	lis reg, HIADJ(wrhvVbStatus);		    \
-	lwz reg, LO(wrhvVbStatus)(reg)
+	lis reg, HIADJ(wr_vb_status);		    \
+	lwz reg, LO(wr_vb_status)(reg)
 
 #endif /*_ASMLANGUAGE */
 
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index e43274d..a826257 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -418,8 +418,8 @@ FUNC_LABEL(vbi_vcore_irq_unlock)
 	stw	p1, VB_CONTROL_INT_DISABLE(p0)
 #endif
 tryAgain:
-	lis	p0, HIADJ(wrhvVbStatus)
-	lwz	p0, LO(wrhvVbStatus)(p0)
+	lis	p0, HIADJ(wr_vb_status)
+	lwz	p0, LO(wr_vb_status)(p0)
 	lwz	p1, VB_STATUS_INT_PENDING(p0)
 
 	/* Perform System Call to re-enable ints if ints pending */
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index 23b060d..7de042b 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -49,6 +49,8 @@
 /*
  * struct fields and similar
  */
+#define wrhvVbStatus		wr_vb_status
+
 #define memoryAliasSize		mem_alias_size
 #define memoryAliasAddress	mem_alias_addr
 #define physicalMemorySize	phys_mem_size
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 684fbcd..11dea33 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -59,7 +59,7 @@ information.
 
 Once the VBI library is initialized the virtual board should employ the
 provided macros in order to access the fieds in wrhVbConfig,
-wrhvVbStatus and wrhvVbControl data structures. Accessing these
+wr_vb_status and wrhvVbControl data structures. Accessing these
 structures via the VBI function guaranties source level compatibily
 between VBI versions.
 
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index d04734d..cfd586f 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -125,7 +125,7 @@ various data structures.
  * RETURNS: virtual core configuration structure base address
  *
  */
-#define VBI_STATUS_ADDR_GET()       (wrhvVbStatus)
+#define VBI_STATUS_ADDR_GET()       (wr_vb_status)
 
 /*
  *
@@ -519,7 +519,7 @@ struct vbi_clk_hook
 /* externs */
 
 extern struct vb_config *wrhvVbConfig;
-extern struct vb_status *wrhvVbStatus;
+extern struct vb_status *wr_vb_status;
 extern struct vb_control *wrhvVbControl;
 extern int32_t wrhvVbIntNested;
 extern void vbi_init(struct vb_config *config);
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index bc35e8d..6b84a2e 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -110,7 +110,7 @@ EXPORT_SYMBOL(wrhvVbConfig);
 
 struct vb_control *wrhvVbControl;/* The address of the core's Control area */
 
-struct vb_status *wrhvVbStatus;	/* The address of the core's Status area */
+struct vb_status *wr_vb_status;	/* The address of the core's Status area */
 
 int32_t wrhvVbIntNested;	/* Used by VBI IRQ/exception management */
 
@@ -128,7 +128,7 @@ int32_t wrhvVbIntNested;	/* Used by VBI IRQ/exception management */
  * reference.
  *
  * Configuration page base address is stored in wrhvVbConfig
- * Status page base address is stored in wrhvVbStatus
+ * Status page base address is stored in wr_vb_status
  * Control page base address is stored in wrhvVbControl
  *
  * The user must ensure that this memory regions are mapped if the MMU is
@@ -195,6 +195,6 @@ void vbi_init(struct vb_config *config)
 #endif
 	wrhvVbConfig = config;
 	wrhvVbControl = wrhvVbConfig->vbControl;
-	wrhvVbStatus = wrhvVbConfig->vbStatus;
+	wr_vb_status = wrhvVbConfig->vbStatus;
 
 }
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index 1dcada3..4f758d7 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -152,10 +152,10 @@ irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
 	int lost_jiffies = 0;
 	struct pt_regs *regs = get_irq_regs();
 
-	ticks = wrhvVbStatus->tick_count;
+	ticks = wr_vb_status->tick_count;
 	ticks -= mark_offset;
 	lost_jiffies = ticks - 1;
-	mark_offset = wrhvVbStatus->tick_count;
+	mark_offset = wr_vb_status->tick_count;
 
 	do {
 		do_timer(1);
-- 
1.6.5.2

