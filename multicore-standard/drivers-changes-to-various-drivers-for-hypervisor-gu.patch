From 18412fd9db57a3927a15299185f99ad23abe5b23 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:23:11 -0400
Subject: [PATCH] drivers: changes to various drivers for hypervisor/guest

There are a couple specific drivers that unfortunately require
code changes to their specific support in order to be used
in a guest mode.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 drivers/net/gianfar.c         |   22 ++++++++++++++++++++++
 drivers/serial/8250.c         |    4 ++++
 drivers/serial/serial_core.c  |    9 +++++++++
 drivers/usb/host/pci-quirks.c |    3 +++
 4 files changed, 38 insertions(+), 0 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index c9e6a5d..d7419e9 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -142,6 +142,11 @@ static void gfar_set_mac_for_addr(struct net_device *dev, int num, u8 *addr);
 
 extern const struct ethtool_ops gfar_ethtool_ops;
 
+#ifdef CONFIG_WRHV
+extern int wrhv_pci_devfn;
+extern char wrhv_macaddr[MAC_ADDR_LEN];
+#endif
+
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
@@ -173,6 +178,18 @@ static int gfar_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
+#ifdef CONFIG_WRHV
+	/* Get phy ID from commandline wrhv_pci_devfn.
+	 * wrhv_pci_devfn can be set to the following number:
+	 * 0 - Ethernet 0
+	 * 1 - Ethernet 1
+	 * 2 - Ethernet 2
+	 * 3 - Ethernet 3
+	 */
+	if (einfo->phy_id != wrhv_pci_devfn)
+		return -ENODEV;
+#endif
+
 	/* Create an ethernet device instance */
 	dev = alloc_etherdev(sizeof (*priv));
 
@@ -243,7 +260,12 @@ static int gfar_probe(struct platform_device *pdev)
 	gfar_write(&priv->regs->ecntrl, ECNTRL_INIT_SETTINGS);
 
 	/* Copy the station address into the dev structure, */
+#ifndef CONFIG_WRHV
 	memcpy(dev->dev_addr, einfo->mac_addr, MAC_ADDR_LEN);
+#else
+	/* Get MAC address from commandline wrhv_macaddr */
+	memcpy(dev->dev_addr, wrhv_macaddr, MAC_ADDR_LEN);
+#endif
 
 	/* Set the dev->base_addr to the gfar reg region */
 	dev->base_addr = (unsigned long) (priv->regs);
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 537a245..1335654 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -2255,7 +2255,11 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
 		serial_outp(up, UART_LCR, 0xe0);
 	} else {
+#if defined(CONFIG_WRHV) && defined(CONFIG_PPC)
+		/* skip DLAB on WRHV + PPC */
+#else
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+#endif
 	}
 
 	serial_dl_write(up, quot);
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 7547e94..4784808 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2492,6 +2492,15 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 		lockdep_set_class(&port->lock, &port_lock_key);
 	}
 
+#ifdef CONFIG_WRHV
+#define __MIPC_MSD_MAJOR	236
+	if (!uart_console(port) && (drv->major != __MIPC_MSD_MAJOR)) {
+		ret = -EBUSY;
+		goto out;
+	}
+#undef __MIPC_MSD_MAJOR
+#endif
+
 	uart_configure_port(drv, state, port);
 
 	/*
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 5ef25db..055a17e 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -354,6 +354,9 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 
 static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 {
+	if (paravirt_enabled())
+		return;
+
 	if (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)
 		quirk_usb_handoff_uhci(pdev);
 	else if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)
-- 
1.6.5.2

