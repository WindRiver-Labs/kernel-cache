From 604fb5b68cec20e7e4008ee03f5812c6927008e2 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 15 Oct 2009 17:06:09 -0400
Subject: [PATCH 20/27] vbi: relocate vmmu.h to be with other vbi includes

This kills off the last of the random stuff located in the
include/vbi/support/* dir.

 renamed:    include/vbi/support/sys/vmmu.h -> include/vbi/vmmu.h

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/pv_pgtable-ppc32.h |    2 +-
 arch/powerpc/kernel/head_wrhv.S             |    2 +-
 arch/powerpc/kernel/vbi/util.c              |    2 +-
 arch/powerpc/kernel/vbi/vmmu_display.c      |    2 +-
 include/vbi/support/sys/vmmu.h              |  302 ---------------------------
 include/vbi/vmmu.h                          |  302 +++++++++++++++++++++++++++
 6 files changed, 306 insertions(+), 306 deletions(-)
 delete mode 100644 include/vbi/support/sys/vmmu.h
 create mode 100644 include/vbi/vmmu.h

diff --git a/arch/powerpc/include/asm/pv_pgtable-ppc32.h b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
index 3a03f86..850cdf5 100644
--- a/arch/powerpc/include/asm/pv_pgtable-ppc32.h
+++ b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
@@ -7,7 +7,7 @@
 #define set_pte_at native_set_pte_at
 
 #if defined(CONFIG_WRHV)
-#include <vbi/support/sys/vmmu.h>
+#include <vbi/vmmu.h>
 #include <vbi/interface.h>
 
 /* redefine wrhv paravirtual operations */
diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index ea8655a..fe52654 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -45,7 +45,7 @@
 #include "head_booke.h"
 #include "head_wrhv.h"
 #include <vbi/interface.h>
-#include <vbi/support/sys/vmmu.h>
+#include <vbi/vmmu.h>
 #include <vbi/syscalls.h>
 
 /* As with the other PowerPC ports, it is expected that when code
diff --git a/arch/powerpc/kernel/vbi/util.c b/arch/powerpc/kernel/vbi/util.c
index 1f46f86..a8bfc20 100644
--- a/arch/powerpc/kernel/vbi/util.c
+++ b/arch/powerpc/kernel/vbi/util.c
@@ -24,7 +24,7 @@ para-virtualize linux, therefore, may need some tweaks to be generic.
 #include <asm/page.h>
 #include <linux/module.h>
 #include <vbi/interface.h>
-#include <vbi/support/sys/vmmu.h>
+#include <vbi/vmmu.h>
 #include <vbi/syscall.h>
 
 
diff --git a/arch/powerpc/kernel/vbi/vmmu_display.c b/arch/powerpc/kernel/vbi/vmmu_display.c
index 237797a..669fece 100644
--- a/arch/powerpc/kernel/vbi/vmmu_display.c
+++ b/arch/powerpc/kernel/vbi/vmmu_display.c
@@ -21,7 +21,7 @@ This module displays the contents of a VMMU page table
 
 #include <linux/kernel.h>
 #include <vbi/interface.h>
-#include <vbi/support/sys/vmmu.h>
+#include <vbi/vmmu.h>
 
 #define __va(paddr) (((unsigned long )(paddr))+0xC0000000)
 #define __pa(vaddr) (((unsigned long )(vaddr))-0xC0000000)
diff --git a/include/vbi/support/sys/vmmu.h b/include/vbi/support/sys/vmmu.h
deleted file mode 100644
index 6ecd491..0000000
--- a/include/vbi/support/sys/vmmu.h
+++ /dev/null
@@ -1,302 +0,0 @@
-/* sys/vmmu.h - hypervisor virtual MMU structure definitions */
-
-/* Copyright 2007 Wind River Systems, Inc. */
-
-/*
-modification history
---------------------
-01e,12dec08,md   rename header files
-01d,21aug07,md   removed vxWorks.h
-01c,16may07,md   update defines and comments to match structure layout
-01b,24apr07,md   adjust fields to better match e500 pte
-01a,19apr07,md   written
-*/
-
-#ifndef __INCvmmuh
-#define __INCvmmuh
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/*
-
-The vmmu virtual address space is restricted to 32 bits and is decoded using
-a level-1/level-2 page table.  The virtual address is decoded as follows:
-
-
-                          32-bit Virtual Address
-        +---------------------------------------------------------+
-        |      L1 offset       | L2 offset |    Page offset       |
-        +---------------------------------------------------------+
-		11 bits           9 bits           12 bits
-                  |                 |
-                  |                 |
-    +-------------+                 |
-    |                               |
-    |                               |
-    |           L1 Table            |            L2 Table
-    |    2047 +----------+          |      511 +----------+
-    |         |          |          |          |          |
-    |         |          |          |          |          |
-    |         |          |          |          |----------|
-    |         |          |          |   +----->|    PTE   | 8 byte PTE
-    |         |          |          |   |      |----------|
-    |         |          |          |   |      |          |
-    |         |----------| 20 bits  |   |      |          |
-    +-------->|  L2 ptr  |----------+---+      |          |
-              |----------|                     |          |
-              |          |                     |          |
-              |          |                     |          |
-            0 +----------+                   0 +----------+
-               2 page (8KB)                    1 page (4KB)
-             2048 L2 pointers                 512 PTE entries
-
-
-
-Each page table entry is 8 bytes (2 words) and uses the following format:
-
-
-word 0 (32-bits):
-	
-	  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
-	                                  6 7 8 9 0 1 2 3               
-	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-	 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
-	 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
-	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-
-		V          - valid bit
-		Hypervisor - reserved for use by hypervisor
-		U0-U7      - user defined attributes
-		ERPN       - extended real page number bits
-		ATTR       - page attributes
-
-
-word 1 (32-bits):
-
-	  0                                19 20      23 2 2 2 2 2 2 3 3
-	                                                 4 5 6 7 8 9 0 1
-	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-	 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
-	 |                                   |          | | |X|X|W|W|R|R|
-	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-
-		RPN        - real page number
-		R          - page referenced bit
-		C          - page changed bit
-		SX,SW,SR   - supervisor mode protection bits
-		UX,UW,UR   - user mode protection bits
-	
-*/
-
-#ifndef	_ASMLANGUAGE
-
-/* Page Table Entry Definition */
-
-typedef union vmmu_pte		/* vmmu pte format */
-    {
-    struct			/* Bit field description */
-	{
-	/* word 0 */
-
-	u_int v:1;		/* valid bit */
-	u_int hy:7;		/* reserved for use by hypervisor */
-	u_int rsvd1:8;		/* reserved */
-	u_int u0:1;		/* user attribute 0 */
-	u_int u1:1;		/* user attribute 1 */
-	u_int u2:1;		/* user attribute 2 */
-	u_int u3:1;		/* user attribute 3 */
-	u_int u4:1;		/* user attribute 4 */
-	u_int u5:1;		/* user attribute 5 */
-	u_int u6:1;		/* user attribute 6 */
-	u_int u7:1;		/* user attribute 7 */
-	u_int erpn:3;		/* extended real page number bits */
-	u_int w:1;		/* write thru/back */
-	u_int i:1;		/* cache inhibited */
-	u_int m:1;		/* memory coherent */
-	u_int g:1;		/* memory guarded  */
-	u_int e:1;		/* little endian bit */
-
-	/* word 1 */
-
-	u_int rpn:20;		/* real page number */
-	u_int rsvd2:4;		/* reserved */
-	u_int r:1;		/* page referenced bit */
-	u_int c:1;		/* page changed bit */
-	u_int ux:1;		/* user execute protection */
-	u_int sx:1;		/* supervisor execute protection */
-	u_int uw:1;		/* user write protection */
-	u_int sw:1;		/* supervisor write protection */
-	u_int ur:1;		/* user read protection */
-	u_int sr:1;		/* supervisor read protection */
-	} field;
-
-    struct 
-	{
-	u_int word0;		/* word 0 */
-	u_int word1;		/* word 1 */
-	} words;
-    } VMMU_PTE;
-
-/* Effective Address Definition */
-
-typedef union vmmuEffectiveAddr /* effective Address structure */
-    {
-    struct
-        {
-        u_int l1index:11;	/* Level 1 Index (2K) */
-        u_int l2index:9;	/* Level 2 Index (512) */
-        u_int po:12;		/* Page Offset (4K) */
-        } field;
-    void * addr;
-    } VMMU_EFFECTIVE_ADDR;
-
-/* Real Address Definition */
-
-typedef union vmmuRealAddress	/* Real Address Structure */
-    {
-    struct                      /* Bit field description */
-        {
-        u_int rpn:20;           /* Real Page Number */
-        u_int po:12;            /* Page Offset */
-        }field;
-    void * realAddr;            /* Real Address */
-    } VMMU_REAL_ADDRESS;
-
-/* Level-1 descriptor definition */
-
-typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
-    {
-    struct                      /* Bit field desciption */
-        {
-        u_int l2ba:20;          /* Level 2 table Base Address */
-        u_int reserved:10;      /* Reserved */
-        u_int b:1;              /* Block translation */
-        u_int v:1;              /* Segment Valid bit */
-        } field;
-    u_int l1desc;               /* Level 1 descriptor */
-    } VMMU_LEVEL_1_DESC;
-
-/* Level-2 descriptor definition */
-
-typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
-    {
-    VMMU_PTE pte;		/* a full PTE entry */
-    } VMMU_LEVEL_2_DESC;
-
-/* Level-2 table pointer definition */
-
-typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
-    {
-    struct                      /* Bit field description */
-        {
-        u_int l2tb:20;          /* Level 2 Table Base */
-        u_int l2index:9;	/* Level 2 table Index */
-        u_int reserved:3;       /* Reserved */
-        } field;
-    VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
-    } VMMU_LEVEL_2_TBL_PTR;
-
-
-/* VMMU configuration system call paramter */
-
-typedef struct vmmuConfig
-    {
-    VMMU_LEVEL_1_DESC *addr;
-    u_int	  pageSize;
-    u_int	  contextId;
-    u_int	  vmmuNum;
-    } VMMU_CONFIG;
-
-#endif /* _ASMLANGUAGE */
-
-#ifndef	VMMU_PAGE_SIZE
-#define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
-#define	VMMU_RPN_SHIFT	12
-#endif
-#define	NVPAGES(x)		((x)/VMMU_PAGE_SIZE)
-
-/* VMMU protection attributes */
-
-#define	VMMU_PROT_SUPV_READ	0x00000001	/* supervisor read allowed    */
-#define	VMMU_PROT_USER_READ	0x00000002	/* user read allowed	      */
-#define	VMMU_PROT_SUPV_WRITE	0x00000004	/* supervisor write allowed   */
-#define	VMMU_PROT_USER_WRITE	0x00000008	/* user write allowed	      */
-#define	VMMU_PROT_SUPV_EXECUTE	0x00000010	/* supervisor execute allowed */
-#define	VMMU_PROT_USER_EXECUTE	0x00000020	/* user execute allowed	      */
-
-
-#define	VMMU_PROT_USER_RWX	VMMU_PROT_USER_READ | \
-				VMMU_PROT_USER_WRITE | \
-				VMMU_PROT_USER_EXECUTE \
-
-#define	VMMU_PROT_USER_RW	VMMU_PROT_USER_READ | \
-				VMMU_PROT_USER_WRITE
-
-#define	VMMU_PROT_USER_RX	VMMU_PROT_USER_READ | \
-				VMMU_PROT_USER_EXECUTE
-
-#define	VMMU_PROT_SUPV_RWX	VMMU_PROT_SUPV_READ | \
-				VMMU_PROT_SUPV_WRITE | \
-				VMMU_PROT_SUPV_EXECUTE \
-
-#define	VMMU_PROT_SUPV_RW	VMMU_PROT_SUPV_READ | \
-				VMMU_PROT_SUPV_WRITE
-
-#define	VMMU_PROT_SUPV_RX	VMMU_PROT_SUPV_READ | \
-				VMMU_PROT_SUPV_EXECUTE
-
-/* VMMU cache attributes */
-
-#define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
-#define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
-#define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
-#define	VMMU_CACHE_INHIBIT	0x00000008	/* cache inhibit 	*/
-#define	VMMU_CACHE_WRITETHROUGH	0x00000010	/* cache write through	*/
-#define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
-
-/* VMMU page table structure */
-
-#define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
-#define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
-#define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
-#define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
-
-/* address to level-1 table offset */
-
-#define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
-
-/* address to level-2 table offset */
-
-#define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
-
-/* offset within page */
-
-#define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
-
-/* address to logical block number */
-
-#define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
-#define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
-
-/* bit masks for PTE fields */
-
-/* word 0 */
-
-#define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
-#define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
-#define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
-
-/* word 1 */
-
-#define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
-#define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
-#define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
-#define	VMMU_PTE_RPN_MASK	0xfffff000	/* real page number */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif  /* __INCvmmuh */
diff --git a/include/vbi/vmmu.h b/include/vbi/vmmu.h
new file mode 100644
index 0000000..6ecd491
--- /dev/null
+++ b/include/vbi/vmmu.h
@@ -0,0 +1,302 @@
+/* sys/vmmu.h - hypervisor virtual MMU structure definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01e,12dec08,md   rename header files
+01d,21aug07,md   removed vxWorks.h
+01c,16may07,md   update defines and comments to match structure layout
+01b,24apr07,md   adjust fields to better match e500 pte
+01a,19apr07,md   written
+*/
+
+#ifndef __INCvmmuh
+#define __INCvmmuh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+
+The vmmu virtual address space is restricted to 32 bits and is decoded using
+a level-1/level-2 page table.  The virtual address is decoded as follows:
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+		11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+
+
+Each page table entry is 8 bytes (2 words) and uses the following format:
+
+
+word 0 (32-bits):
+	
+	  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+	                                  6 7 8 9 0 1 2 3               
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+	 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+	 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+		V          - valid bit
+		Hypervisor - reserved for use by hypervisor
+		U0-U7      - user defined attributes
+		ERPN       - extended real page number bits
+		ATTR       - page attributes
+
+
+word 1 (32-bits):
+
+	  0                                19 20      23 2 2 2 2 2 2 3 3
+	                                                 4 5 6 7 8 9 0 1
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+	 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+	 |                                   |          | | |X|X|W|W|R|R|
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+		RPN        - real page number
+		R          - page referenced bit
+		C          - page changed bit
+		SX,SW,SR   - supervisor mode protection bits
+		UX,UW,UR   - user mode protection bits
+	
+*/
+
+#ifndef	_ASMLANGUAGE
+
+/* Page Table Entry Definition */
+
+typedef union vmmu_pte		/* vmmu pte format */
+    {
+    struct			/* Bit field description */
+	{
+	/* word 0 */
+
+	u_int v:1;		/* valid bit */
+	u_int hy:7;		/* reserved for use by hypervisor */
+	u_int rsvd1:8;		/* reserved */
+	u_int u0:1;		/* user attribute 0 */
+	u_int u1:1;		/* user attribute 1 */
+	u_int u2:1;		/* user attribute 2 */
+	u_int u3:1;		/* user attribute 3 */
+	u_int u4:1;		/* user attribute 4 */
+	u_int u5:1;		/* user attribute 5 */
+	u_int u6:1;		/* user attribute 6 */
+	u_int u7:1;		/* user attribute 7 */
+	u_int erpn:3;		/* extended real page number bits */
+	u_int w:1;		/* write thru/back */
+	u_int i:1;		/* cache inhibited */
+	u_int m:1;		/* memory coherent */
+	u_int g:1;		/* memory guarded  */
+	u_int e:1;		/* little endian bit */
+
+	/* word 1 */
+
+	u_int rpn:20;		/* real page number */
+	u_int rsvd2:4;		/* reserved */
+	u_int r:1;		/* page referenced bit */
+	u_int c:1;		/* page changed bit */
+	u_int ux:1;		/* user execute protection */
+	u_int sx:1;		/* supervisor execute protection */
+	u_int uw:1;		/* user write protection */
+	u_int sw:1;		/* supervisor write protection */
+	u_int ur:1;		/* user read protection */
+	u_int sr:1;		/* supervisor read protection */
+	} field;
+
+    struct 
+	{
+	u_int word0;		/* word 0 */
+	u_int word1;		/* word 1 */
+	} words;
+    } VMMU_PTE;
+
+/* Effective Address Definition */
+
+typedef union vmmuEffectiveAddr /* effective Address structure */
+    {
+    struct
+        {
+        u_int l1index:11;	/* Level 1 Index (2K) */
+        u_int l2index:9;	/* Level 2 Index (512) */
+        u_int po:12;		/* Page Offset (4K) */
+        } field;
+    void * addr;
+    } VMMU_EFFECTIVE_ADDR;
+
+/* Real Address Definition */
+
+typedef union vmmuRealAddress	/* Real Address Structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int rpn:20;           /* Real Page Number */
+        u_int po:12;            /* Page Offset */
+        }field;
+    void * realAddr;            /* Real Address */
+    } VMMU_REAL_ADDRESS;
+
+/* Level-1 descriptor definition */
+
+typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
+    {
+    struct                      /* Bit field desciption */
+        {
+        u_int l2ba:20;          /* Level 2 table Base Address */
+        u_int reserved:10;      /* Reserved */
+        u_int b:1;              /* Block translation */
+        u_int v:1;              /* Segment Valid bit */
+        } field;
+    u_int l1desc;               /* Level 1 descriptor */
+    } VMMU_LEVEL_1_DESC;
+
+/* Level-2 descriptor definition */
+
+typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
+    {
+    VMMU_PTE pte;		/* a full PTE entry */
+    } VMMU_LEVEL_2_DESC;
+
+/* Level-2 table pointer definition */
+
+typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int l2tb:20;          /* Level 2 Table Base */
+        u_int l2index:9;	/* Level 2 table Index */
+        u_int reserved:3;       /* Reserved */
+        } field;
+    VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
+    } VMMU_LEVEL_2_TBL_PTR;
+
+
+/* VMMU configuration system call paramter */
+
+typedef struct vmmuConfig
+    {
+    VMMU_LEVEL_1_DESC *addr;
+    u_int	  pageSize;
+    u_int	  contextId;
+    u_int	  vmmuNum;
+    } VMMU_CONFIG;
+
+#endif /* _ASMLANGUAGE */
+
+#ifndef	VMMU_PAGE_SIZE
+#define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
+#define	VMMU_RPN_SHIFT	12
+#endif
+#define	NVPAGES(x)		((x)/VMMU_PAGE_SIZE)
+
+/* VMMU protection attributes */
+
+#define	VMMU_PROT_SUPV_READ	0x00000001	/* supervisor read allowed    */
+#define	VMMU_PROT_USER_READ	0x00000002	/* user read allowed	      */
+#define	VMMU_PROT_SUPV_WRITE	0x00000004	/* supervisor write allowed   */
+#define	VMMU_PROT_USER_WRITE	0x00000008	/* user write allowed	      */
+#define	VMMU_PROT_SUPV_EXECUTE	0x00000010	/* supervisor execute allowed */
+#define	VMMU_PROT_USER_EXECUTE	0x00000020	/* user execute allowed	      */
+
+
+#define	VMMU_PROT_USER_RWX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE | \
+				VMMU_PROT_USER_EXECUTE \
+
+#define	VMMU_PROT_USER_RW	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE
+
+#define	VMMU_PROT_USER_RX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_EXECUTE
+
+#define	VMMU_PROT_SUPV_RWX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE | \
+				VMMU_PROT_SUPV_EXECUTE \
+
+#define	VMMU_PROT_SUPV_RW	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE
+
+#define	VMMU_PROT_SUPV_RX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_EXECUTE
+
+/* VMMU cache attributes */
+
+#define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
+#define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
+#define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
+#define	VMMU_CACHE_INHIBIT	0x00000008	/* cache inhibit 	*/
+#define	VMMU_CACHE_WRITETHROUGH	0x00000010	/* cache write through	*/
+#define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
+
+/* VMMU page table structure */
+
+#define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
+#define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
+#define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
+#define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
+
+/* address to level-1 table offset */
+
+#define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
+
+/* address to level-2 table offset */
+
+#define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
+
+/* offset within page */
+
+#define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
+
+/* address to logical block number */
+
+#define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
+#define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
+
+/* bit masks for PTE fields */
+
+/* word 0 */
+
+#define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
+#define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
+#define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
+
+/* word 1 */
+
+#define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
+#define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
+#define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
+#define	VMMU_PTE_RPN_MASK	0xfffff000	/* real page number */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvmmuh */
-- 
1.6.3.3

