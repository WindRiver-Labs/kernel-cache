From 8153b059732dfc57677492a12ca72e59d7417354 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 14 Oct 2009 20:30:24 -0400
Subject: [PATCH 13/23] vbi/vbInterface.h --> vbi/interface.h

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/pv_hw_irq.h        |    2 +-
 arch/powerpc/include/asm/pv_pgtable-ppc32.h |    2 +-
 arch/powerpc/include/asm/reg_wrhv.h         |    2 +-
 arch/powerpc/kernel/head_wrhv.S             |    2 +-
 arch/powerpc/kernel/vbiUtil.c               |    2 +-
 arch/powerpc/kernel/vmmuDisplay.c           |    2 +-
 arch/powerpc/kernel/wrhv.c                  |    2 +-
 arch/powerpc/kernel/wrhv_entry_32.S         |    2 +-
 arch/powerpc/kernel/wrhv_misc_32.S          |    2 +-
 arch/x86/kernel/asm-offsets_32.c            |    2 +-
 arch/x86/kernel/head_32.S                   |    2 +-
 arch/x86/kernel/pci-dma.c                   |    2 +-
 arch/x86/kernel/pci-nommu.c                 |    2 +-
 arch/x86/kernel/vbiIntController.c          |    2 +-
 include/asm-x86/dma-mapping.h               |    2 +-
 include/vbi/interface.h                     |  836 +++++++++++++++++++++++++++
 include/vbi/support/sys/x86/arch.h          |    4 +-
 include/vbi/vbInterface.h                   |  836 ---------------------------
 include/vbi/vbi.h                           |    6 +-
 kernel/dma-coherent.c                       |    2 +-
 kernel/vbi/lib.c                            |    4 +-
 21 files changed, 859 insertions(+), 859 deletions(-)
 create mode 100644 include/vbi/interface.h
 delete mode 100644 include/vbi/vbInterface.h

diff --git a/arch/powerpc/include/asm/pv_hw_irq.h b/arch/powerpc/include/asm/pv_hw_irq.h
index 4cdcd5a..184631e 100644
--- a/arch/powerpc/include/asm/pv_hw_irq.h
+++ b/arch/powerpc/include/asm/pv_hw_irq.h
@@ -17,7 +17,7 @@
 
 /* Hypervisor specific irq implementation */
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 extern void wrhv_int_lock(void);
 extern void wrhv_int_unlock(int lvl);
 extern int wrhv_int_lvl_get (void);
diff --git a/arch/powerpc/include/asm/pv_pgtable-ppc32.h b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
index e61758d..3a03f86 100644
--- a/arch/powerpc/include/asm/pv_pgtable-ppc32.h
+++ b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
@@ -8,7 +8,7 @@
 
 #if defined(CONFIG_WRHV)
 #include <vbi/support/sys/vmmu.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 
 /* redefine wrhv paravirtual operations */
 #undef set_pte_at
diff --git a/arch/powerpc/include/asm/reg_wrhv.h b/arch/powerpc/include/asm/reg_wrhv.h
index c26a313..f071b0e 100644
--- a/arch/powerpc/include/asm/reg_wrhv.h
+++ b/arch/powerpc/include/asm/reg_wrhv.h
@@ -24,7 +24,7 @@
 
 #include <linux/stringify.h>
 #include <asm/cputable.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 
 /* macro used in on entry_32.S */
 #define PARAVIRT_ENABLE_MSR_EE      WRHV_INT_UNLOCK(r10,r11)
diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index 0a45140..ea8655a 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -44,7 +44,7 @@
 #include <asm/cache.h>
 #include "head_booke.h"
 #include "head_wrhv.h"
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/support/sys/vmmu.h>
 #include <vbi/syscalls.h>
 
diff --git a/arch/powerpc/kernel/vbiUtil.c b/arch/powerpc/kernel/vbiUtil.c
index 14a74f2..1f46f86 100644
--- a/arch/powerpc/kernel/vbiUtil.c
+++ b/arch/powerpc/kernel/vbiUtil.c
@@ -23,7 +23,7 @@ para-virtualize linux, therefore, may need some tweaks to be generic.
 
 #include <asm/page.h>
 #include <linux/module.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/support/sys/vmmu.h>
 #include <vbi/syscall.h>
 
diff --git a/arch/powerpc/kernel/vmmuDisplay.c b/arch/powerpc/kernel/vmmuDisplay.c
index a3f218c..237797a 100644
--- a/arch/powerpc/kernel/vmmuDisplay.c
+++ b/arch/powerpc/kernel/vmmuDisplay.c
@@ -20,7 +20,7 @@ This module displays the contents of a VMMU page table
 */
 
 #include <linux/kernel.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/support/sys/vmmu.h>
 
 #define __va(paddr) (((unsigned long )(paddr))+0xC0000000)
diff --git a/arch/powerpc/kernel/wrhv.c b/arch/powerpc/kernel/wrhv.c
index 7ed0f42..7b020a7 100644
--- a/arch/powerpc/kernel/wrhv.c
+++ b/arch/powerpc/kernel/wrhv.c
@@ -18,7 +18,7 @@
 #include <linux/profile.h>
 #include <linux/wrhv.h>
 #include <linux/interrupt.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/interrupt.h>
 #include <vbi/errors.h>
 
diff --git a/arch/powerpc/kernel/wrhv_entry_32.S b/arch/powerpc/kernel/wrhv_entry_32.S
index b3c8030..061c067 100644
--- a/arch/powerpc/kernel/wrhv_entry_32.S
+++ b/arch/powerpc/kernel/wrhv_entry_32.S
@@ -35,7 +35,7 @@
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <asm/vbiPpcArch.h>
 #include <vbi/syscalls.h>
 #endif /* CONFIG_WRHV */
diff --git a/arch/powerpc/kernel/wrhv_misc_32.S b/arch/powerpc/kernel/wrhv_misc_32.S
index 62b6486..c571805 100644
--- a/arch/powerpc/kernel/wrhv_misc_32.S
+++ b/arch/powerpc/kernel/wrhv_misc_32.S
@@ -29,7 +29,7 @@
 #include <asm/asm-offsets.h>
 #include <asm/processor.h>
 #include <asm/kexec.h>
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/syscalls.h>
 
 	.text
diff --git a/arch/x86/kernel/asm-offsets_32.c b/arch/x86/kernel/asm-offsets_32.c
index c6cc239..b5d6370 100644
--- a/arch/x86/kernel/asm-offsets_32.c
+++ b/arch/x86/kernel/asm-offsets_32.c
@@ -22,7 +22,7 @@
 #include <xen/interface/xen.h>
 
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #endif
 
 #include <linux/lguest.h>
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index 4e8fbf6..2331e79 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -19,7 +19,7 @@
 #include <asm/asm-offsets.h>
 #include <asm/setup.h>
 #include <asm/processor-flags.h>
-// #include <vbi/vbInterface.h>
+// #include <vbi/interface.h>
 
 #define WRHV_COREID_OFFSET	0x98
 #define VB_MAX_BOOTLINE_LENGTH   256
diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c
index 04c52af..8ed9bfd 100644
--- a/arch/x86/kernel/pci-dma.c
+++ b/arch/x86/kernel/pci-dma.c
@@ -4,7 +4,7 @@
 #include <linux/pci.h>
 
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/vbi.h>
 #endif
 
diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c
index 6d4fe81..ea0351c 100644
--- a/arch/x86/kernel/pci-nommu.c
+++ b/arch/x86/kernel/pci-nommu.c
@@ -8,7 +8,7 @@
 #include <linux/scatterlist.h>
 
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/vbi.h>
 #endif
 
diff --git a/arch/x86/kernel/vbiIntController.c b/arch/x86/kernel/vbiIntController.c
index 59f93d4..3479167 100644
--- a/arch/x86/kernel/vbiIntController.c
+++ b/arch/x86/kernel/vbiIntController.c
@@ -26,7 +26,7 @@ modification history
 #define DEBUGM(x)
 #endif
 
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/vbInterrupt.h>
 
 #include <linux/string.h>
diff --git a/include/asm-x86/dma-mapping.h b/include/asm-x86/dma-mapping.h
index 968e65c..b14b7ab 100644
--- a/include/asm-x86/dma-mapping.h
+++ b/include/asm-x86/dma-mapping.h
@@ -11,7 +11,7 @@
 #include <asm/swiotlb.h>
 
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #include <vbi/vbi.h>
 #endif
 
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
new file mode 100644
index 0000000..dc26c4a
--- /dev/null
+++ b/include/vbi/interface.h
@@ -0,0 +1,836 @@
+/* interface.h - virtual board interface header file */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02r,09sep09,mmi  include vbi types header file
+02q,28aug09,mmi  use a different wrapper header arch.h for VBI and HV
+02p,26aug09,mmi  fix WIND00178026: update copyright dates
+02o,06aug09,dtr  Modify status intPending to intPendingType as per docs.
+02n,03jul09,mmi  rename version flags
+02m,16jun09,mmi  make vioapic field a pointer, move bootCount field to VB_STATUS
+02l,08jun09,mmi  fix apigen syntax
+02k,08jun09,mmi  update descriptions
+02j,22may09,md   adjust fields for 64-bit
+02i,22may09,mpk  use exception Stack for running Privileged VBI calls
+02h,14may09,md   add per-core private memory page
+02g,18may09,mpk  64-bit hypervisor, 32-bit Virtual Board
+02f,29apr09,mpk  move syscalls.h include to vbi.h
+02e,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02d,21apr09,md   add SMP guest information
+02d,17apr09,mpk  64-bit hypervisor, and supervisor vbi calls
+02c,29jan09,dtr  Fix reg offset macros.
+02b,28jan09,mmi  merge arch registers in vb status struct, use arch specific
+		 define for vioapic size, put regs struct at the beginning
+02a,22jan09,mmi  add ctypes.h
+01z,22jan09,mmi  abstract arch specific registers
+01y,23dec08,mmi  move vb function prototypes to vbMgr.h
+01x,14dec08,mmi  define VB_PRINTF to printf for vxWorks
+01w,12dec08,mmi  replace RAZOR name reference to WRHV
+01v,11dec08,mmi  use typedef instead of native types
+01u,02dec08,mmi  remove obsolete API definitions
+01t,19nov08,dtr  Remove interrupt controller.
+01s,03oct08,dbt  Added tickCount to VB_STATUS.
+01r,01aug08,md   add tracking of region data type
+01q,19may08,gws  add virtual IO APIC
+01p,23nov07,foo  add boot defines
+01o,08nov07,md   add bootline support
+01n,09nov07,foo  remove includes
+01m,25oct07,foo  updated for hardware interrupts
+01l,09oct07,md   add emulated srr1 register
+01k,04oct07,md   include sys/cpu_types.h
+01j,11sep07,md   added emulated MSR register for PPC
+01i,23aug07,md   added vmmu and PPC volatile regs to control page
+01h,25jul07,md   added memory aliasing information
+01g,29may07,ymz  added port support.
+01f,25may07,foo  updated for inter-board interrupts
+01e,17may07,foo  updated for improved interrupt delivery
+01d,23apr07,foo  added fields for user mode virtual boards and interrupts
+01c,16mar07,foo  renamed RAZOR_CPU to CPU 
+01b,16mar07,foo  update for generalized interface and interrupt delivery
+01a,15feb07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module defines the data structures used for information flow between
+wind river Hypervisor and a Virtual Board. There are three structures employed
+for this purpose: 
+\ms
+\m - 
+ configuration 
+\m - 
+ status 
+\m -
+ control
+\me
+
+The configuration structure is the first data exchanged between a given virtual 
+board and Hypervisor kernel. The pointers to the status and control structures are
+derived from the configuration structure. It contains pointers to the status, 
+control and other information about resources assigned to a virtual board. 
+The configuration data is shared accross the cores in the same virtual board unlike
+the data in the control and status structure which may be different for each core.
+The information in the configuration structure is static in the sense that the data
+it contains remain unmodified at least during the life of a boot cycle.
+
+The status structure is used to inform a virtual core at runtime about the state it
+is excecuting (interrupts, vmmu, elapsed time etc...). 
+
+The control structure is put in place as a fast method to pass information from
+the VB to Hypervisor or vis-versa. For examples during a virtual board context
+switch the control structure allows to store the incoming virtual board context
+setting before the virtual board sends a Hypercall using VBI_CTX_LOAD().
+
+Hypervisor passes (as parameter) a pointer of the configuration structure to the 
+entry function of the virtual core and a boot option flag. 
+
+The VBI library provides a initialization function vbiInit() to ensures that 
+Hypervisor version number is compatible with the VBI library in use. If the versions
+match then the configuration, status and control pointers are stored respectively to
+wrhvVbConfig, wrhvStatus and wrhvVbControl. 
+
+Therefore a virtual board must always call vbiInit() before accessing any data
+provided by Hypervisor nor send a hypercall to it. Refer to to vbiInit() description in the VBI API description document for more information. 
+
+Once the VBI library is initialized the virtual board should employ the provided 
+macros in order to access the fieds in wrhVbConfig, wrhvVbStatus and wrhvVbControl
+data structures. Accessing these structures via the VBI function guaranties source
+level compatibily between VBI versions.
+
+A guest OS should port vbiInit(), the access macros along with the necessary header
+files where the data structrures layout is defined.
+ To be aware:
+\ms
+\m -
+ Changing the order of the field this structure may have serious impact on the
+ integrity of the system. It exists hand crafted macros to match the C
+ structures offset. Therefore any change should be reflected in the macros
+ 
+\m -
+ When a virtual core boots the VMMU is not enbled but a programmer may choose
+ to turn-on the VMMU. In that scenario proper care must be taken to ensure that
+ the address where the control, status or configureation structure is reflected
+ in the VMMU mapping. Technically these area should be treated as I/O region
+ therefore it is encouraged that they are identity mapped.  
+\me
+
+\APPEND vbi/vbi.h
+
+*/
+
+#ifndef __INCvbInterfaceh
+#define __INCvbInterfaceh
+
+#ifdef CONFIG_WRHV
+#include "vbi/types.h"
+#include "vbi/arch.h"
+#else
+#include <vbi/types.h>
+#include <vbi/arch.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* VB versioning information */
+
+#define	VBI_VERSION_MAJOR	2	/* major version */
+#define	VBI_VERSION_MINOR	0	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+/* macro to align guest fields for a 64-bit hypervisor */
+
+#if defined(LP64)
+# define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			   __attribute__(( aligned(8) )) \
+			   decl_var
+#else
+# if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    decl_var; \
+			    uint32_t pad_var
+# else
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    uint32_t pad_var; \
+			    decl_var
+# endif
+#endif
+
+#ifdef PRJ_BUILD
+# define VB_PRINTF(fmt, args...)    printf(fmt, ##args)
+#else
+# define VB_PRINTF(fmt, args...)    kprintf(fmt, ##args)
+#endif
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+# define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
+#else
+# define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+
+/* Configuration Filename for the hypervisor this must not change */
+
+#define VB_WRHV_CONFIGURATION_FILE "wrhvConfig.xml"
+
+/* Hard limits for now */
+
+#define VB_MAX_VIRTUAL_BOARDS    1024
+#define VB_MAX_BUSES             1024
+
+#define VB_MAX_CORES     	 8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+
+#define VB_MAX_WRHV_NAME_LENGTH 64
+
+#ifndef	_ASMLANGUAGE
+typedef int8_t VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
+
+#define VB_MAX_BOOTLINE_LENGTH   256
+
+/* Virtual board timestamp is 64 bits */
+
+typedef uint64_t VB_TIMESTAMP;
+#endif
+
+/* Virtual Interrupt Controller definitions --------------------------- */
+
+/* 32 is chosen as the maximum number of interrupt sources allowed.
+ * care must be taken if this is changed, since some algorithms and
+ * data structures will require modifications and become more complex
+ */
+
+#define VB_MAX_INTERRUPTS     32
+
+/* The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+
+#define VB_MAX_INTERRUPT_DATA 16
+
+/* Structure offsets for assembler */
+
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+# define VB_CONTROL_REG_STRUCT_END 0
+#endif
+
+# define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#else
+# define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+/* Assembler offsets for VB_STATUS */
+
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+# define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#else
+# define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Assembler offsets for VB_CONFIG */
+
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+# define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+# define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+# define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+# define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#else
+# define VB_CONFIG_VBSTATUS		((2+0) * 8)
+# define VB_CONFIG_VBCONTROL		((2+1) * 8)
+# define VB_CONFIG_SMINFO		((2+2) * 8)
+# define VB_CONFIG_MEMINFO		((2+3) * 8)
+# define VB_CONFIG_INTINFO		((2+4) * 8)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Defines for vbIntInfo intDirection field */
+
+#define VB_INPUT_INT  1
+#define VB_OUTPUT_INT 2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by Razor
+ */
+
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+#ifndef VB_VIOAPIC_ENTRIES_SIZE
+#define VB_VIOAPIC_ENTRIES_SIZE 64
+#endif
+
+#ifndef	_ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_CONTROL - Virtual board cores control structure 
+*
+* VB_CONTROL is a data type that defines a virtual core's control structure.
+* This is called the control structure because a core uses to modify it's 
+* state. The code running in the context of a virtual core puts the desired
+* setting in this control and passes to Hypervisor via the Hypercall mechanism.
+* It is suggested to use the provided APIs for manipulating the virtual core
+* control structure instead of directly accessing it's members. 
+* Typically use cases for this structure are for following:
+*\ms
+*\m - 
+* During context switch for setting the incoming context's register state.
+* For more information about this refer to VBI_CTX_LOAD() description in the
+* architecture supplement API documentation.
+*\m -
+* Locking/unlocking the virtual core interrupts.
+*\m -
+* Loading the VMMU configuration data.
+*\m -
+* VIOAPIC configuration registers.
+* 
+*\me   
+* The control structure definition is generic accross the various architecture
+* flavours supported by Hypervisor with the exception of the emulated registers. 
+* There is an architecture specific extention available via a pointer of type 
+* VB_ARCH_STATUS_REGS to accomodate the registers unique for a given hardware
+* platform.
+* However that does imply that other fields defined in this structure are used
+* in every architecture. A field is considered generic if it is usefull at least to
+* two CPU families but not necessary to all CPUs.
+* The VIOAPIC is the only field that is meaning full accross all architectures.
+* Note that some architectures like Intel with VT technology don't require emulated
+* registers. The pointer of emulated registers is included only if 
+*_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
+* with read/write access attribute for the purpose of serving as duplex 
+* communication channel between Hypervisor and a virtual core. This mechanism
+* is fall back when it is not possible to use registers for transmitting data
+* from the virtual core to Hypervisor or vis-versa. More information about 
+* VB_ARCH_CONTROL_REGS may be found in the architecture supplement document.
+*
+* 
+* Control structure graphical illustration
+*\cs
+*    ______________
+*   |              |
+*   |              |<------- 64bits - pointer to arch specific registers 
+*   |              |          (See architecture supplement documentation)         
+*   |--------------|
+*   |              |<------- 32bits -  interrupt state flag
+*   |--------------|
+*   |              |<------- 32bits - virtual core to be loaded context's 
+*   |--------------|                  interrupt state    
+*   |              | 
+*   |              |<------- 64bits - pointer to VMMU configuration
+*   |--------------|
+*   |              |<------- 64bits - pointer to additional VMMU 
+*   |              |                  configuration (reserved for enhancement)  
+*   |--------------|
+*   |              | <------ 64bits - VIOAPIC information header (internal use only)
+*   |              |
+*   |--------------|
+*   |		   |
+*   |              |<------- Nbytes - VIOAPIC redirection table    
+*   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE   
+*   |              |
+*   |--------------|<------- 32bits - Pending interrupt vector number  
+*   |______________|            
+*\ce
+*
+* SYNOPSIS
+*
+* Virtual core's control C data structure type definition
+*\cs
+* typedef struct vbControl {
+*
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbControlRegs.
+*     @/
+*
+*#ifdef  _WRHV_ARCH_HAS_CTRL_REGS         
+*    VB_ALIGN_FIELD_64 (VB_ARCH_CONTROL_REGS  * vbControlRegs, pad1);
+*#endif
+*
+*   /@  0: -1 => Disable all interrupts					@/
+*
+*    uint32_t	intDisable;	
+*
+*   /@ 
+*    @ future interrupt state of a context to be loaded in 
+*    @ vbControl->intDisable after a context switch	    
+*    @/
+*
+*    uint32_t	newIntDisable;	
+*
+*   /@  2: VMMU 0 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*
+*   /@  3: VMMU 1 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*   /@ Virtual I/O APIC							@/
+*
+*    VB_ALIGN_FIELD_64 (uint32_t    vIoapicRegisters[VB_VIOAPIC_SIZE], pad4);
+*
+*   /@ actual virtual interrupt pending					@/
+*
+*    uint32_t	intPending;
+*
+*   } VB_CONTROL;
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*
+* INTERNAL
+* warning!!!!!!!
+* 1. Any modification of this structure field should be reflected in the
+* description.
+* 2. Make sure that VIOAPIC_SIZE is used in the structure
+* 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
+*     the code
+*\COMMAND 
+*/
+
+typedef struct vbControl {
+
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	      
+    VB_ARCH_CONTROL_REGS  vbControlRegs;
+#endif
+
+    uint32_t	intDisable;	/*  0: -1 => Disable all interrupts */
+    uint32_t	newIntDisable;	/*  1: New value for vbControl->intDisable */
+
+				/*  2: VMMU 0 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+
+				/*  3: VMMU 1 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    uint32_t	intLevelDisable;/* interrupt level enabling */
+
+    /* Virtual I/O APIC */
+
+    VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
+
+    /* actual virtual interrupt pending */
+
+    uint32_t	intPending;
+
+} VB_CONTROL;
+
+
+/*******************************************************************************
+*
+* VB_STATUS - Virtual board's core status structure
+*
+* VB_STATUS is a C data type structure that provides the definition of an area
+* where the state of a given core is posted by Hypervisor before a virtual core is 
+* scheduled to run. The fields of this structure are architecture agnostic. 
+* A pointer is provided to accomodate anything that is specific to the underlying
+* hardware. The architecture specific structure is included only if 
+* _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type  VB_STATUS_ARCH_REGS
+* holding the architecture dependent registers is defined by a file pulled
+* vbi/arch.h at compile type according to CPU value.
+* The definition of VB_ARCH_STATUS_REGS can be found in the architecture
+* supplement documentation.
+* The purpose of this structure is to inform a virtual core at runtime the
+* status of a core's time variant data such as:
+*\ms
+*\m - 
+* Interrupts state
+*\ms
+*\m *
+* current interrupt state
+*\m *
+* previous interrupt state if the core is in an ISR context
+*\m *
+* The pending vector number if any
+*\me
+*\m -
+* A free running clock timestamp
+*\m -
+* Virtual core elapsed timer ticks
+*\m -
+* Current VMMU configuration
+*\me
+*  
+* SYNOPSIS
+*
+* Control structure graphical illustration
+*\cs
+*        _______________   
+*       |		|	
+*       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
+*       |		|		structure pointer
+*       |---------------|
+*       |		|<-------32bits - intPending; pending vector number
+*       |---------------|
+*       |///////////////|<-------32bits - Reserved for future enhencements
+*       |---------------|
+*       |		|<-------64bits - timeStamp; free running clock ticks
+*       |		|
+*       |---------------|
+*       |		|<-------32bits - oldIntDisable; interrupt state before
+*       |---------------|		   an interrupt was injected
+*       |		|<-------32bits - 
+*       |---------------|
+*       |		|
+*       |		|<-------64bits - vmmu0; current VMMU configuration
+*       |---------------|
+*       |		|<-------64bits - vmmu1; reserved for future use
+*       |		|
+*       |---------------|
+*       |		|<-------64bits - tickCount; elapsed virtual core ticks
+*       |		|
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbStatus {
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbStatusRegs
+*     @/
+*
+* #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+*    VB_ALIGN_FIELD_64 (VB_ARCH_STATUS_REGS  vbStatusRegs, pad1);
+* #endif
+*
+*    /@ Bits indicating which interrupts are pending			    @/
+*
+*    uint64_t	intPendingType;
+*
+*    /@ reserved field for future use, required for timeStamp alignment	    @/
+*
+*    uint32_t	reserved1;
+*
+*    /@ Timestamp when last interrupt was delivered			    @/
+*
+*    VB_TIMESTAMP timeStamp;  
+*
+*    /@ 
+*     @ Interrupt registers when the hypervisor interrupts a virtual board, 
+*     @ it saves the following information here for use by the virtual board.
+*     @/
+*
+*    /@ value of control->intDisable at time of the interrupt.
+*     @ control->intDisable is set to -1 by WRHV at the time of delivery of
+*     @ the interrupt
+*     @/
+*
+*    uint32_t	oldIntDisable; 
+*
+*    /@ VMMU tables which were active when an MMU exception occurred	    @/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*    /@ VB wall clock time expressed in the VB clock frequency  @/
+*
+*    uint64_t tickCount;
+*
+* } VB_STATUS;
+*\ce
+*
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+* INTERNAL
+* Make sure that intPendingType modification is reflected in the code
+*
+*\COMMAND
+*/
+
+typedef struct vbStatus {
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    VB_ARCH_STATUS_REGS  vbStatusRegs;
+#endif
+
+    /* Bits indicating which interrupts are pending */
+
+    uint32_t	intPendingType;
+
+    /* reserved field for future use, required for timeStamp alignment */
+
+    uint32_t	reserved1;
+
+    /* Timestamp when last interrupt was delivered */
+
+    VB_TIMESTAMP timeStamp;  
+
+    /* Interrupt registers
+     *
+     * When the hypervisor interrupts a virtual board, it saves the following
+     * information here for use by the virtual board.
+     */
+
+    /* value of control->intDisable at time of the interrupt.
+     * control->intDisable is set to -1 by WRHV at the time of delivery of
+     * the interrupt
+     */
+
+    uint32_t	oldIntDisable; 
+
+    /* VMMU tables which were active when an MMU exception occurred */
+
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    /* Virtual Board clock tick count */
+
+    uint64_t tickCount;
+
+    /* number of times this core has booted */
+
+    uint32_t	 bootCount;	 
+
+    /* initial program load flag */
+
+    uint32_t	 ipl;	 
+
+    /* The simulatror flag  */
+
+    uint32_t	 sim;	 
+
+} VB_STATUS;
+
+/*
+ * ----------------------- Virtual BOARD STATUS PAGE -----------------------
+ *
+ * Read only page used to provide static configuration to the Virtual Board
+ *
+ */
+
+/* Configuration information for interrupts */
+
+typedef struct vbIntInfo {
+    VB_WRHV_NAME intName;	/* the name of this interrupt */
+    uint16_t	 intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
+    uint16_t	 intNumber;	/* the local VB interrupt number */
+    uint32_t	 intCore;	/* the receiving core for this incomming int */
+} VB_INT_INFO;
+
+/* Information about a shared memory region */
+
+typedef struct vbSmInfo {
+    VB_WRHV_NAME name;		/* the name of the shared memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    uint32_t	 type;		/* shared memory type field */
+				/* id's of connected boards */
+    VB_ALIGN_FIELD_64 (void *boardIds, pad2);
+} VB_SM_INFO;
+
+/* Information for the memory map info */
+
+typedef struct vbMemInfo {
+    VB_WRHV_NAME name;		/* the name of the memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    VB_WRHV_NAME type;		/* the type of the region */
+} VB_MEM_INFO;
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+
+typedef struct vbConfig {
+
+    /* 
+     *  structure versioning information
+     *  --------------------------------
+     */
+
+    uint32_t major;	/* major revision number */
+    uint32_t minor;	/* minor revision number */
+    uint32_t maint;	/* maintenance revision number */
+    uint32_t pad;
+
+    /* 
+     *  pointers to secondary configuration structures
+     *  ----------------------------------------------
+     */
+
+    /* read-only status information */
+
+    VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
+
+    /* read-write control information */
+
+    VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
+
+    /* shared memory information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
+
+    /* memory regions information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
+
+    /* information about incoming and outgoing interrupt connections */
+
+    VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
+
+    /* 
+     *  general board specific configuration information
+     *  ------------------------------------------------
+     */
+
+    uint32_t	 pid;		 /* hypervisor context id */
+    vbiVb_t	 boardID;	 /* board ID from the XML configuration */
+
+    int32_t	 supervisoryMode;/* board is running in privileged mode */
+
+    VB_WRHV_NAME boardName;	 /* the name of this board */
+    uint32_t	 boardType;	 /* the type of this board */
+    uint32_t	 bootCount;	 /* number of times this core has booted */
+
+				 /* entry point for this VB */
+    VB_ALIGN_FIELD_64 (void *resetPC, pad6);
+
+    /* 
+     *  virtual core specific information
+     *  ---------------------------------
+     */
+
+    uint32_t  coreId;		  /* virtual core cpu id */
+    uint32_t  numCores;		  /* number of virtual cores */
+    uint32_t  corePrivateSize;	  /* size of core private memory */
+				  /* pointer to core private memory */
+    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+
+    /* 
+     *  main memory configuration settings 
+     *  ----------------------------------
+     */
+
+    uint32_t  physicalMemorySize; /* the vbPhysical size of RAM */
+    uint32_t  memoryAliasAddress; /* address to which memory is aliased */
+    uint32_t  memoryAliasSize;	  /* size of aliases memory */
+    uint32_t  numMem;		  /* number of memory regions */
+
+    /* 
+     *  shared memory configuration settings
+     *  ------------------------------------
+     */
+
+    /* number of shared memory regions */
+
+    uint32_t  numSm;
+
+    /* shared memory state information */
+
+    VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
+
+    /* 
+     *  clock and interrupt configuration
+     *  ---------------------------------
+     */
+
+    /* the frequency of the periodic tick interrupt */
+
+    uint32_t  tickTimerFrequency;	/* ticks per second */
+
+    /* the frequency of the timestamp */
+
+    uint32_t  timeStampFrequency;	/* ticks per second */
+
+    /* number of interrupts connected to this board */
+
+    uint32_t  numInts;
+
+    /* 
+     *  misc settings
+     *  -------------
+     */
+
+    /* OS specific boot line */
+
+    char      bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+    /* spare 32-bit fields for future use */
+
+    uint32_t	spare32[16];
+
+    /* spare 64-bit fields for future use */
+
+    uint64_t	spare64[16];
+
+    /* direct function call interface table */
+
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+    VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
+    VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
+#endif
+
+} VB_CONFIG;
+
+#ifndef __INCvxWorksh 
+extern int kprintf (const char *, ...);
+#else
+extern int printf (const char *, ...);
+#endif 
+
+#endif /*_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbInterfaceh */
diff --git a/include/vbi/support/sys/x86/arch.h b/include/vbi/support/sys/x86/arch.h
index 6365b29..a807015 100644
--- a/include/vbi/support/sys/x86/arch.h
+++ b/include/vbi/support/sys/x86/arch.h
@@ -12,7 +12,7 @@
 modification history
 --------------------
 02w,24sep09,mmi  add virtual interrupts
-02v,01sep09,mmi  include vbInterface.h
+02v,01sep09,mmi  include interface.h
 02u,19aug09,md   add VBI register load/save region
 02t,28jul09,mpk  add cache align size
 02s,18jun09,dtr  Move excMgrId def here.
@@ -70,7 +70,7 @@ modification history
 
 #include <sys/regs.h>
 #include <sys/x86/vmx.h>
-#include <vbInterface.h>
+#include <interface.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/include/vbi/vbInterface.h b/include/vbi/vbInterface.h
deleted file mode 100644
index 6780e1a..0000000
--- a/include/vbi/vbInterface.h
+++ /dev/null
@@ -1,836 +0,0 @@
-/* vbInterface.h - virtual board interface header file */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-02r,09sep09,mmi  include vbi types header file
-02q,28aug09,mmi  use a different wrapper header arch.h for VBI and HV
-02p,26aug09,mmi  fix WIND00178026: update copyright dates
-02o,06aug09,dtr  Modify status intPending to intPendingType as per docs.
-02n,03jul09,mmi  rename version flags
-02m,16jun09,mmi  make vioapic field a pointer, move bootCount field to VB_STATUS
-02l,08jun09,mmi  fix apigen syntax
-02k,08jun09,mmi  update descriptions
-02j,22may09,md   adjust fields for 64-bit
-02i,22may09,mpk  use exception Stack for running Privileged VBI calls
-02h,14may09,md   add per-core private memory page
-02g,18may09,mpk  64-bit hypervisor, 32-bit Virtual Board
-02f,29apr09,mpk  move syscalls.h include to vbi.h
-02e,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
-02d,21apr09,md   add SMP guest information
-02d,17apr09,mpk  64-bit hypervisor, and supervisor vbi calls
-02c,29jan09,dtr  Fix reg offset macros.
-02b,28jan09,mmi  merge arch registers in vb status struct, use arch specific
-		 define for vioapic size, put regs struct at the beginning
-02a,22jan09,mmi  add ctypes.h
-01z,22jan09,mmi  abstract arch specific registers
-01y,23dec08,mmi  move vb function prototypes to vbMgr.h
-01x,14dec08,mmi  define VB_PRINTF to printf for vxWorks
-01w,12dec08,mmi  replace RAZOR name reference to WRHV
-01v,11dec08,mmi  use typedef instead of native types
-01u,02dec08,mmi  remove obsolete API definitions
-01t,19nov08,dtr  Remove interrupt controller.
-01s,03oct08,dbt  Added tickCount to VB_STATUS.
-01r,01aug08,md   add tracking of region data type
-01q,19may08,gws  add virtual IO APIC
-01p,23nov07,foo  add boot defines
-01o,08nov07,md   add bootline support
-01n,09nov07,foo  remove includes
-01m,25oct07,foo  updated for hardware interrupts
-01l,09oct07,md   add emulated srr1 register
-01k,04oct07,md   include sys/cpu_types.h
-01j,11sep07,md   added emulated MSR register for PPC
-01i,23aug07,md   added vmmu and PPC volatile regs to control page
-01h,25jul07,md   added memory aliasing information
-01g,29may07,ymz  added port support.
-01f,25may07,foo  updated for inter-board interrupts
-01e,17may07,foo  updated for improved interrupt delivery
-01d,23apr07,foo  added fields for user mode virtual boards and interrupts
-01c,16mar07,foo  renamed RAZOR_CPU to CPU 
-01b,16mar07,foo  update for generalized interface and interrupt delivery
-01a,15feb07,foo  written
-*/
-
-/*
-DESCRIPTION
-This module defines the data structures used for information flow between
-wind river Hypervisor and a Virtual Board. There are three structures employed
-for this purpose: 
-\ms
-\m - 
- configuration 
-\m - 
- status 
-\m -
- control
-\me
-
-The configuration structure is the first data exchanged between a given virtual 
-board and Hypervisor kernel. The pointers to the status and control structures are
-derived from the configuration structure. It contains pointers to the status, 
-control and other information about resources assigned to a virtual board. 
-The configuration data is shared accross the cores in the same virtual board unlike
-the data in the control and status structure which may be different for each core.
-The information in the configuration structure is static in the sense that the data
-it contains remain unmodified at least during the life of a boot cycle.
-
-The status structure is used to inform a virtual core at runtime about the state it
-is excecuting (interrupts, vmmu, elapsed time etc...). 
-
-The control structure is put in place as a fast method to pass information from
-the VB to Hypervisor or vis-versa. For examples during a virtual board context
-switch the control structure allows to store the incoming virtual board context
-setting before the virtual board sends a Hypercall using VBI_CTX_LOAD().
-
-Hypervisor passes (as parameter) a pointer of the configuration structure to the 
-entry function of the virtual core and a boot option flag. 
-
-The VBI library provides a initialization function vbiInit() to ensures that 
-Hypervisor version number is compatible with the VBI library in use. If the versions
-match then the configuration, status and control pointers are stored respectively to
-wrhvVbConfig, wrhvStatus and wrhvVbControl. 
-
-Therefore a virtual board must always call vbiInit() before accessing any data
-provided by Hypervisor nor send a hypercall to it. Refer to to vbiInit() description in the VBI API description document for more information. 
-
-Once the VBI library is initialized the virtual board should employ the provided 
-macros in order to access the fieds in wrhVbConfig, wrhvVbStatus and wrhvVbControl
-data structures. Accessing these structures via the VBI function guaranties source
-level compatibily between VBI versions.
-
-A guest OS should port vbiInit(), the access macros along with the necessary header
-files where the data structrures layout is defined.
- To be aware:
-\ms
-\m -
- Changing the order of the field this structure may have serious impact on the
- integrity of the system. It exists hand crafted macros to match the C
- structures offset. Therefore any change should be reflected in the macros
- 
-\m -
- When a virtual core boots the VMMU is not enbled but a programmer may choose
- to turn-on the VMMU. In that scenario proper care must be taken to ensure that
- the address where the control, status or configureation structure is reflected
- in the VMMU mapping. Technically these area should be treated as I/O region
- therefore it is encouraged that they are identity mapped.  
-\me
-
-\APPEND vbi/vbi.h
-
-*/
-
-#ifndef __INCvbInterfaceh
-#define __INCvbInterfaceh
-
-#ifdef CONFIG_WRHV
-#include "vbi/types.h"
-#include "vbi/arch.h"
-#else
-#include <vbi/types.h>
-#include <vbi/arch.h>
-#endif /* CONFIG_WRHV */
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/* VB versioning information */
-
-#define	VBI_VERSION_MAJOR	2	/* major version */
-#define	VBI_VERSION_MINOR	0	/* minor version */
-#define	VBI_VERSION_MAINT	0	/* maintenance version */
-
-/* macro to align guest fields for a 64-bit hypervisor */
-
-#if defined(LP64)
-# define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			   __attribute__(( aligned(8) )) \
-			   decl_var
-#else
-# if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
-#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			    __attribute__(( aligned(8) )) \
-			    decl_var; \
-			    uint32_t pad_var
-# else
-#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
-			    __attribute__(( aligned(8) )) \
-			    uint32_t pad_var; \
-			    decl_var
-# endif
-#endif
-
-#ifdef PRJ_BUILD
-# define VB_PRINTF(fmt, args...)    printf(fmt, ##args)
-#else
-# define VB_PRINTF(fmt, args...)    kprintf(fmt, ##args)
-#endif
-
-#undef VB_DEBUG  /* define it to turn on debugging */
-#ifdef VB_DEBUG
-# define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
-#else
-# define VB_DEBUG_MSG(fmt, args...)
-#endif
-
-
-/* Configuration Filename for the hypervisor this must not change */
-
-#define VB_WRHV_CONFIGURATION_FILE "wrhvConfig.xml"
-
-/* Hard limits for now */
-
-#define VB_MAX_VIRTUAL_BOARDS    1024
-#define VB_MAX_BUSES             1024
-
-#define VB_MAX_CORES     	 8
-
-/* Type definitions for all name identifer strings in the hypervisor */
-
-#define VB_MAX_WRHV_NAME_LENGTH 64
-
-#ifndef	_ASMLANGUAGE
-typedef int8_t VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
-
-#define VB_MAX_BOOTLINE_LENGTH   256
-
-/* Virtual board timestamp is 64 bits */
-
-typedef uint64_t VB_TIMESTAMP;
-#endif
-
-/* Virtual Interrupt Controller definitions --------------------------- */
-
-/* 32 is chosen as the maximum number of interrupt sources allowed.
- * care must be taken if this is changed, since some algorithms and
- * data structures will require modifications and become more complex
- */
-
-#define VB_MAX_INTERRUPTS     32
-
-/* The maximum number of associated data stored with each interrupt.
- * This can be modified without any impacts, tho it should not be
- * set to 0
- */
-
-#define VB_MAX_INTERRUPT_DATA 16
-
-/* Structure offsets for assembler */
-
-#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
-# define VB_CONTROL_REG_STRUCT_END 0
-#endif
-
-# define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
-#else
-# define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
-#endif /* __VBI_BYTE_ORDER */
-
-/* Bit Mask definitions for VB_STATUS_INT_PENDING */
-
-#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
-#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
-
-/* Assembler offsets for VB_STATUS */
-
-#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
-# define VB_STATUS_REG_STRUCT_END	0
-#endif
-
-#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
-#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
-#else
-# define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
-#endif /* __VBI_BYTE_ORDER */
-
-/* Assembler offsets for VB_CONFIG */
-
-#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
-# define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
-# define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
-# define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
-# define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
-#else
-# define VB_CONFIG_VBSTATUS		((2+0) * 8)
-# define VB_CONFIG_VBCONTROL		((2+1) * 8)
-# define VB_CONFIG_SMINFO		((2+2) * 8)
-# define VB_CONFIG_MEMINFO		((2+3) * 8)
-# define VB_CONFIG_INTINFO		((2+4) * 8)
-#endif /* __VBI_BYTE_ORDER */
-
-/* Defines for vbIntInfo intDirection field */
-
-#define VB_INPUT_INT  1
-#define VB_OUTPUT_INT 2
-
-/*
- * Defines for the second parameter passed to the startup program
- * in a virtual board by Razor
- */
-
-#define VB_BOOT_COLD	1
-#define VB_BOOT_WARM	2
-#define VB_BOOT_RESTART	3
-
-#ifndef VB_VIOAPIC_ENTRIES_SIZE
-#define VB_VIOAPIC_ENTRIES_SIZE 64
-#endif
-
-#ifndef	_ASMLANGUAGE
-
-/*******************************************************************************
-*
-* VB_CONTROL - Virtual board cores control structure 
-*
-* VB_CONTROL is a data type that defines a virtual core's control structure.
-* This is called the control structure because a core uses to modify it's 
-* state. The code running in the context of a virtual core puts the desired
-* setting in this control and passes to Hypervisor via the Hypercall mechanism.
-* It is suggested to use the provided APIs for manipulating the virtual core
-* control structure instead of directly accessing it's members. 
-* Typically use cases for this structure are for following:
-*\ms
-*\m - 
-* During context switch for setting the incoming context's register state.
-* For more information about this refer to VBI_CTX_LOAD() description in the
-* architecture supplement API documentation.
-*\m -
-* Locking/unlocking the virtual core interrupts.
-*\m -
-* Loading the VMMU configuration data.
-*\m -
-* VIOAPIC configuration registers.
-* 
-*\me   
-* The control structure definition is generic accross the various architecture
-* flavours supported by Hypervisor with the exception of the emulated registers. 
-* There is an architecture specific extention available via a pointer of type 
-* VB_ARCH_STATUS_REGS to accomodate the registers unique for a given hardware
-* platform.
-* However that does imply that other fields defined in this structure are used
-* in every architecture. A field is considered generic if it is usefull at least to
-* two CPU families but not necessary to all CPUs.
-* The VIOAPIC is the only field that is meaning full accross all architectures.
-* Note that some architectures like Intel with VT technology don't require emulated
-* registers. The pointer of emulated registers is included only if 
-*_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
-* with read/write access attribute for the purpose of serving as duplex 
-* communication channel between Hypervisor and a virtual core. This mechanism
-* is fall back when it is not possible to use registers for transmitting data
-* from the virtual core to Hypervisor or vis-versa. More information about 
-* VB_ARCH_CONTROL_REGS may be found in the architecture supplement document.
-*
-* 
-* Control structure graphical illustration
-*\cs
-*    ______________
-*   |              |
-*   |              |<------- 64bits - pointer to arch specific registers 
-*   |              |          (See architecture supplement documentation)         
-*   |--------------|
-*   |              |<------- 32bits -  interrupt state flag
-*   |--------------|
-*   |              |<------- 32bits - virtual core to be loaded context's 
-*   |--------------|                  interrupt state    
-*   |              | 
-*   |              |<------- 64bits - pointer to VMMU configuration
-*   |--------------|
-*   |              |<------- 64bits - pointer to additional VMMU 
-*   |              |                  configuration (reserved for enhancement)  
-*   |--------------|
-*   |              | <------ 64bits - VIOAPIC information header (internal use only)
-*   |              |
-*   |--------------|
-*   |		   |
-*   |              |<------- Nbytes - VIOAPIC redirection table    
-*   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE   
-*   |              |
-*   |--------------|<------- 32bits - Pending interrupt vector number  
-*   |______________|            
-*\ce
-*
-* SYNOPSIS
-*
-* Virtual core's control C data structure type definition
-*\cs
-* typedef struct vbControl {
-*
-*    /@
-*     @ Some architecture like Intel with hardware virtualization support don't
-*     @ make use vbControlRegs.
-*     @/
-*
-*#ifdef  _WRHV_ARCH_HAS_CTRL_REGS         
-*    VB_ALIGN_FIELD_64 (VB_ARCH_CONTROL_REGS  * vbControlRegs, pad1);
-*#endif
-*
-*   /@  0: -1 => Disable all interrupts					@/
-*
-*    uint32_t	intDisable;	
-*
-*   /@ 
-*    @ future interrupt state of a context to be loaded in 
-*    @ vbControl->intDisable after a context switch	    
-*    @/
-*
-*    uint32_t	newIntDisable;	
-*
-*   /@  2: VMMU 0 table for context switch				@/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
-*
-*   /@  3: VMMU 1 table for context switch				@/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
-*
-*   /@ Virtual I/O APIC							@/
-*
-*    VB_ALIGN_FIELD_64 (uint32_t    vIoapicRegisters[VB_VIOAPIC_SIZE], pad4);
-*
-*   /@ actual virtual interrupt pending					@/
-*
-*    uint32_t	intPending;
-*
-*   } VB_CONTROL;
-*\ce
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-*
-* INTERNAL
-* warning!!!!!!!
-* 1. Any modification of this structure field should be reflected in the
-* description.
-* 2. Make sure that VIOAPIC_SIZE is used in the structure
-* 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
-*     the code
-*\COMMAND 
-*/
-
-typedef struct vbControl {
-
-#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	      
-    VB_ARCH_CONTROL_REGS  vbControlRegs;
-#endif
-
-    uint32_t	intDisable;	/*  0: -1 => Disable all interrupts */
-    uint32_t	newIntDisable;	/*  1: New value for vbControl->intDisable */
-
-				/*  2: VMMU 0 table for context switch */
-    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
-
-				/*  3: VMMU 1 table for context switch */
-    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
-
-    uint32_t	intLevelDisable;/* interrupt level enabling */
-
-    /* Virtual I/O APIC */
-
-    VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
-
-    /* actual virtual interrupt pending */
-
-    uint32_t	intPending;
-
-} VB_CONTROL;
-
-
-/*******************************************************************************
-*
-* VB_STATUS - Virtual board's core status structure
-*
-* VB_STATUS is a C data type structure that provides the definition of an area
-* where the state of a given core is posted by Hypervisor before a virtual core is 
-* scheduled to run. The fields of this structure are architecture agnostic. 
-* A pointer is provided to accomodate anything that is specific to the underlying
-* hardware. The architecture specific structure is included only if 
-* _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type  VB_STATUS_ARCH_REGS
-* holding the architecture dependent registers is defined by a file pulled
-* vbi/arch.h at compile type according to CPU value.
-* The definition of VB_ARCH_STATUS_REGS can be found in the architecture
-* supplement documentation.
-* The purpose of this structure is to inform a virtual core at runtime the
-* status of a core's time variant data such as:
-*\ms
-*\m - 
-* Interrupts state
-*\ms
-*\m *
-* current interrupt state
-*\m *
-* previous interrupt state if the core is in an ISR context
-*\m *
-* The pending vector number if any
-*\me
-*\m -
-* A free running clock timestamp
-*\m -
-* Virtual core elapsed timer ticks
-*\m -
-* Current VMMU configuration
-*\me
-*  
-* SYNOPSIS
-*
-* Control structure graphical illustration
-*\cs
-*        _______________   
-*       |		|	
-*       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
-*       |		|		structure pointer
-*       |---------------|
-*       |		|<-------32bits - intPending; pending vector number
-*       |---------------|
-*       |///////////////|<-------32bits - Reserved for future enhencements
-*       |---------------|
-*       |		|<-------64bits - timeStamp; free running clock ticks
-*       |		|
-*       |---------------|
-*       |		|<-------32bits - oldIntDisable; interrupt state before
-*       |---------------|		   an interrupt was injected
-*       |		|<-------32bits - 
-*       |---------------|
-*       |		|
-*       |		|<-------64bits - vmmu0; current VMMU configuration
-*       |---------------|
-*       |		|<-------64bits - vmmu1; reserved for future use
-*       |		|
-*       |---------------|
-*       |		|<-------64bits - tickCount; elapsed virtual core ticks
-*       |		|
-*       |---------------|
-*
-*\ce
-*
-* Virtual core's status C data structure type definition
-*
-*\cs
-* VB_STATUS structure definition
-*
-* typedef struct vbStatus {
-*    /@
-*     @ Some architecture like Intel with hardware virtualization support don't
-*     @ make use vbStatusRegs
-*     @/
-*
-* #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-*    VB_ALIGN_FIELD_64 (VB_ARCH_STATUS_REGS  vbStatusRegs, pad1);
-* #endif
-*
-*    /@ Bits indicating which interrupts are pending			    @/
-*
-*    uint64_t	intPendingType;
-*
-*    /@ reserved field for future use, required for timeStamp alignment	    @/
-*
-*    uint32_t	reserved1;
-*
-*    /@ Timestamp when last interrupt was delivered			    @/
-*
-*    VB_TIMESTAMP timeStamp;  
-*
-*    /@ 
-*     @ Interrupt registers when the hypervisor interrupts a virtual board, 
-*     @ it saves the following information here for use by the virtual board.
-*     @/
-*
-*    /@ value of control->intDisable at time of the interrupt.
-*     @ control->intDisable is set to -1 by WRHV at the time of delivery of
-*     @ the interrupt
-*     @/
-*
-*    uint32_t	oldIntDisable; 
-*
-*    /@ VMMU tables which were active when an MMU exception occurred	    @/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
-*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
-*
-*    /@ VB wall clock time expressed in the VB clock frequency  @/
-*
-*    uint64_t tickCount;
-*
-* } VB_STATUS;
-*\ce
-*
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-* INTERNAL
-* Make sure that intPendingType modification is reflected in the code
-*
-*\COMMAND
-*/
-
-typedef struct vbStatus {
-
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    VB_ARCH_STATUS_REGS  vbStatusRegs;
-#endif
-
-    /* Bits indicating which interrupts are pending */
-
-    uint32_t	intPendingType;
-
-    /* reserved field for future use, required for timeStamp alignment */
-
-    uint32_t	reserved1;
-
-    /* Timestamp when last interrupt was delivered */
-
-    VB_TIMESTAMP timeStamp;  
-
-    /* Interrupt registers
-     *
-     * When the hypervisor interrupts a virtual board, it saves the following
-     * information here for use by the virtual board.
-     */
-
-    /* value of control->intDisable at time of the interrupt.
-     * control->intDisable is set to -1 by WRHV at the time of delivery of
-     * the interrupt
-     */
-
-    uint32_t	oldIntDisable; 
-
-    /* VMMU tables which were active when an MMU exception occurred */
-
-    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
-    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
-
-    /* Virtual Board clock tick count */
-
-    uint64_t tickCount;
-
-    /* number of times this core has booted */
-
-    uint32_t	 bootCount;	 
-
-    /* initial program load flag */
-
-    uint32_t	 ipl;	 
-
-    /* The simulatror flag  */
-
-    uint32_t	 sim;	 
-
-} VB_STATUS;
-
-/*
- * ----------------------- Virtual BOARD STATUS PAGE -----------------------
- *
- * Read only page used to provide static configuration to the Virtual Board
- *
- */
-
-/* Configuration information for interrupts */
-
-typedef struct vbIntInfo {
-    VB_WRHV_NAME intName;	/* the name of this interrupt */
-    uint16_t	 intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
-    uint16_t	 intNumber;	/* the local VB interrupt number */
-    uint32_t	 intCore;	/* the receiving core for this incomming int */
-} VB_INT_INFO;
-
-/* Information about a shared memory region */
-
-typedef struct vbSmInfo {
-    VB_WRHV_NAME name;		/* the name of the shared memory region */
-				/* the vbphysical address of the region */
-    VB_ALIGN_FIELD_64 (void *addr, pad1);
-    uint32_t	 length;	/* the length in bytes of the region */
-    uint32_t	 attr;		/* the MMU attributes of the region */
-    uint32_t	 type;		/* shared memory type field */
-				/* id's of connected boards */
-    VB_ALIGN_FIELD_64 (void *boardIds, pad2);
-} VB_SM_INFO;
-
-/* Information for the memory map info */
-
-typedef struct vbMemInfo {
-    VB_WRHV_NAME name;		/* the name of the memory region */
-				/* the vbphysical address of the region */
-    VB_ALIGN_FIELD_64 (void *addr, pad1);
-    uint32_t	 length;	/* the length in bytes of the region */
-    uint32_t	 attr;		/* the MMU attributes of the region */
-    VB_WRHV_NAME type;		/* the type of the region */
-} VB_MEM_INFO;
-
-
-/*
- * Fixed information about the configuration of a Virtual Board as seen by
- * the Virtual Board itself.  The address of this structure is passed as the
- * first parameter to the virtual board when it is started at its entry point.
- */
-
-typedef struct vbConfig {
-
-    /* 
-     *  structure versioning information
-     *  --------------------------------
-     */
-
-    uint32_t major;	/* major revision number */
-    uint32_t minor;	/* minor revision number */
-    uint32_t maint;	/* maintenance revision number */
-    uint32_t pad;
-
-    /* 
-     *  pointers to secondary configuration structures
-     *  ----------------------------------------------
-     */
-
-    /* read-only status information */
-
-    VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
-
-    /* read-write control information */
-
-    VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
-
-    /* shared memory information (memory map) */
-
-    VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
-
-    /* memory regions information (memory map) */
-
-    VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
-
-    /* information about incoming and outgoing interrupt connections */
-
-    VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
-
-    /* 
-     *  general board specific configuration information
-     *  ------------------------------------------------
-     */
-
-    uint32_t	 pid;		 /* hypervisor context id */
-    vbiVb_t	 boardID;	 /* board ID from the XML configuration */
-
-    int32_t	 supervisoryMode;/* board is running in privileged mode */
-
-    VB_WRHV_NAME boardName;	 /* the name of this board */
-    uint32_t	 boardType;	 /* the type of this board */
-    uint32_t	 bootCount;	 /* number of times this core has booted */
-
-				 /* entry point for this VB */
-    VB_ALIGN_FIELD_64 (void *resetPC, pad6);
-
-    /* 
-     *  virtual core specific information
-     *  ---------------------------------
-     */
-
-    uint32_t  coreId;		  /* virtual core cpu id */
-    uint32_t  numCores;		  /* number of virtual cores */
-    uint32_t  corePrivateSize;	  /* size of core private memory */
-				  /* pointer to core private memory */
-    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
-
-    /* 
-     *  main memory configuration settings 
-     *  ----------------------------------
-     */
-
-    uint32_t  physicalMemorySize; /* the vbPhysical size of RAM */
-    uint32_t  memoryAliasAddress; /* address to which memory is aliased */
-    uint32_t  memoryAliasSize;	  /* size of aliases memory */
-    uint32_t  numMem;		  /* number of memory regions */
-
-    /* 
-     *  shared memory configuration settings
-     *  ------------------------------------
-     */
-
-    /* number of shared memory regions */
-
-    uint32_t  numSm;
-
-    /* shared memory state information */
-
-    VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
-
-    /* 
-     *  clock and interrupt configuration
-     *  ---------------------------------
-     */
-
-    /* the frequency of the periodic tick interrupt */
-
-    uint32_t  tickTimerFrequency;	/* ticks per second */
-
-    /* the frequency of the timestamp */
-
-    uint32_t  timeStampFrequency;	/* ticks per second */
-
-    /* number of interrupts connected to this board */
-
-    uint32_t  numInts;
-
-    /* 
-     *  misc settings
-     *  -------------
-     */
-
-    /* OS specific boot line */
-
-    char      bootLine[VB_MAX_BOOTLINE_LENGTH];
-
-    /* spare 32-bit fields for future use */
-
-    uint32_t	spare32[16];
-
-    /* spare 64-bit fields for future use */
-
-    uint64_t	spare64[16];
-
-    /* direct function call interface table */
-
-#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
-    VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
-    VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
-#endif
-
-} VB_CONFIG;
-
-#ifndef __INCvxWorksh 
-extern int kprintf (const char *, ...);
-#else
-extern int printf (const char *, ...);
-#endif 
-
-#endif /*_ASMLANGUAGE */
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif  /* __INCvbInterfaceh */
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index 5335438..37a6d1b 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -32,7 +32,7 @@ modification history
 01k,23jan09,mmi  add vbiMsg.h
 01j,23dec08,mmi  fix vbiVioapicIntSend() prototype, added show routines
 01i,19dec08,mmi  add VBI show routine function prototypes
-01h,14dec08,mmi  move printing function prototypes to vbInterface.h
+01h,14dec08,mmi  move printing function prototypes to interface.h
 01g,13dec08,mmi  change vbiSyscalls.h to syscall.h
 01f,12dec08,mmi  rename RAZOR to WRHV
 01e,11dec08,mmi  replace razor with wrhv prefix, add access macros, moved
@@ -51,7 +51,7 @@ modification history
 #include "vbi/types.h"
 #include "vbi/version.h"
 #include "vbi/arch.h"
-#include "vbInterface.h"
+#include "vbi/interface.h"
 #include "vbi/syscall.h"
 #include "vbi/interrupt.h"
 #include "vbi/shmem.h"
@@ -61,7 +61,7 @@ modification history
 #include <vbi/types.h>
 #include <vbi/version.h>
 #include <vbi/arch.h>
-#include <vbInterface.h>
+#include <vbi/interface.h>
 #include <syscall.h>
 #include <vbi/interrupt.h>
 #include <vbi/shmem.h>
diff --git a/kernel/dma-coherent.c b/kernel/dma-coherent.c
index 8d7878f..6f12a97 100644
--- a/kernel/dma-coherent.c
+++ b/kernel/dma-coherent.c
@@ -6,7 +6,7 @@
 #include <linux/dma-mapping.h>
 
 #ifdef CONFIG_WRHV
-#include <vbi/vbInterface.h>
+#include <vbi/interface.h>
 #endif
 
 struct dma_coherent_mem {
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index 8c0f6fb..9773564 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -19,7 +19,7 @@ modification history
 01l,17jul09,mmi  fix description
 01k,16jul09,mpk  update VBI with mips64 support information
 01j,03jul09,mmi  add vbiInterrupt to docs
-01i,12jun09,mmi  append vbInterface.h for apigen
+01i,12jun09,mmi  append interface.h for apigen
 01h,09jun09,mmi  put back wrhvVbIntNested
 01g,25may09,mmi  Update API descriptions
 01f,12may09,mmi  fix apigen errors and update for VBI 2.0
@@ -149,7 +149,7 @@ INCLUDE FILES:  include/vbi/vbi.h
 \APPEND  vbiShow.c
 \APPEND  vbiNs.c
 \APPEND  vbiMsg.c
-\APPEND  ../include/vbInterface.h
+\APPEND  ../include/interface.h
 */
 
 #ifdef CONFIG_WRHV
-- 
1.6.3.3

