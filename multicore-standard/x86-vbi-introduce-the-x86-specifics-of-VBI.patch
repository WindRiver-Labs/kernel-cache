From 5caac8defd4ea44e6b38522b75673207368fb79b Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:06:38 -0400
Subject: [PATCH 02/20] x86 vbi: introduce the x86 specifics of VBI

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/x86/kernel/vbiIntController.c |  116 +++
 arch/x86/kernel/vbiSyscalls.S      | 1180 ++++++++++++++++++++++
 include/asm-x86/vbiX86Arch.h       |  192 ++++
 include/vbi/support/sys/x86/arch.h |  763 ++++++++++++++
 include/vbi/support/sys/x86/asm.h  |  147 +++
 include/vbi/support/sys/x86/regs.h | 1957 ++++++++++++++++++++++++++++++++++++
 include/vbi/x86/regs.h             | 1954 +++++++++++++++++++++++++++++++++++
 include/vbi/x86/vbiX86Arch.h       |  194 ++++
 8 files changed, 6503 insertions(+), 0 deletions(-)
 create mode 100644 arch/x86/kernel/vbiIntController.c
 create mode 100644 arch/x86/kernel/vbiSyscalls.S
 create mode 100644 include/asm-x86/vbiX86Arch.h
 create mode 100644 include/vbi/support/sys/x86/arch.h
 create mode 100644 include/vbi/support/sys/x86/asm.h
 create mode 100644 include/vbi/support/sys/x86/regs.h
 create mode 100644 include/vbi/x86/regs.h
 create mode 100644 include/vbi/x86/vbiX86Arch.h

diff --git a/arch/x86/kernel/vbiIntController.c b/arch/x86/kernel/vbiIntController.c
new file mode 100644
index 0000000..59f93d4
--- /dev/null
+++ b/arch/x86/kernel/vbiIntController.c
@@ -0,0 +1,116 @@
+/* vbiIntController.c - virtual interrupt controller device */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,25oct07,foo  update for real hardware interrupt implementation
+01a,09may07,foo  written
+*/
+
+/*
+ * This module contains the code for accessing and controlling the
+ * virtual interrupt controller as presented to a Virtual Board.
+ */
+/* #define DEBUG 1 */
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#include <vbi/vbInterface.h>
+#include <vbi/vbInterrupt.h>
+
+#include <linux/string.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/module.h>
+
+typedef irqreturn_t (*IRQHANDLER) (unsigned int a, ...);
+
+/* Type for storing interrupt handlers provided by the application */
+typedef struct vbiIntControllerHandler
+    {
+    IRQHANDLER handler;  /* The handler to call for the interrupt */
+    void *        param;    /* The parameter to be passed first */
+    } VBI_INT_CONTROLLER_HANDLER;
+
+/* Storage for interrupt handlers */
+VBI_INT_CONTROLLER_HANDLER vbiIntControllerHandlers[VB_MAX_INTERRUPTS];
+
+#define CALL_INT_HANDLER() handle_simple_irq(vector, &irq_desc[vector])
+#define HANDLERFUNCPTR irqreturn_t(*handler)()
+
+void vbiIntControllerHandle(void);
+
+/******************************************************************************
+*
+* vbiIntControllerConnect - connect to a specific vector in the virtual controller
+*
+* RETURNS: None
+*
+*/
+void vbiIntControllerConnect
+    (
+    int vector,
+    VOIDFUNCPTR handler,
+    void * param
+    )
+{
+}
+EXPORT_SYMBOL(vbiIntControllerConnect);
+
+/******************************************************************************
+*
+* vbiIntControllerFindVector - determine the interrupt vector for a specified
+*                              interrupt
+*
+* RETURNS: None
+*
+*/
+void vbiIntControllerFindVector
+    (
+    char * intName,        /* String name of the interrupt */
+    int    inputInterrupt, /* Input vector = 1, Output vector = 0 */
+    int *  vector          /* vector number returned here, -1 if not found */
+    )
+    {
+    VB_INT_INFO * info = wrhvConfig->interruptConfiguration;
+    int           num  = wrhvConfig->numInts;
+    int           i;
+
+    *vector = -1;
+    for (i = 0; i < num; i++, info++)
+        {
+        if (inputInterrupt)
+            {
+            if (info->intDirection != VB_INPUT_INT)
+                {
+                continue;
+                }
+            }
+        else
+            {
+            if (info->intDirection == VB_INPUT_INT)
+                {
+                continue;
+                }
+            }
+        if (!strncmp (intName, info->intName, VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *vector = info->intNumber;
+            return;
+            }
+        }
+
+    }
+EXPORT_SYMBOL(vbiIntControllerFindVector);
diff --git a/arch/x86/kernel/vbiSyscalls.S b/arch/x86/kernel/vbiSyscalls.S
new file mode 100644
index 0000000..355fd41
--- /dev/null
+++ b/arch/x86/kernel/vbiSyscalls.S
@@ -0,0 +1,1180 @@
+/* vbiSyscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01s,25aug09,mmi  remove bspIoctl
+01r,13aug09,dtr  Update to vbiHyIoctl.
+01q,06jul09,mmi  added vbi 2.0 vbMgmt api, interrupt redirect op,
+		 registers read/write, memory read/write, 
+01p,02jul09,mmi  add interrupt send syscall stub
+01o,27jun09,mmi  fix stack adjustment for vbiReply
+01n,23jun09,mmi  add vbi 2.0 API's
+01m,18jun09,mmi  changed vbiIntVCoreUnlock not expect a flag
+01l,12jun09,mmi  introduce vbiIntVCoreLock/Unlock APIs
+01k,26feb09,mmi  add name service hypercall
+01j,12feb09,mmi  update API descriptions, descriptions, fix vbiReply #arg pushed
+		 to the stack 
+01i,08feb09,mmi  fix vbiIntEnable/vbiIntDisable routines, remove vbiInt
+01h,23jan09,mmi  update vbiSend/vbiReceive and vbiReply comments
+01g,05dec08,mes  Replaced vbiShelf with vbiVbMgmt
+01f,02dec08,mmi  remove obsolete API's
+01e,20nov08,mmi  adopt vbi naming
+01d,04sep08,dcc  modified vdkInt() to call vdkIoapicIoctl()
+01c,19may08,gws  add vdkIoapicIoctl
+01b,18apr08,md   add extra arg to vdkHyIoctl
+01a,03mar08,md   written
+*/
+
+/*
+DESCRIPTION
+
+This file implements the hypervisor system call stubs for the Razor hypervisor.
+
+*/
+
+#define _ASMLANGUAGE
+
+#include <vbi/sys/vbiSyscall.h>
+#define EFLAGS_IF	0x200
+
+	/* globals */
+	.globl vbiDebugShellStart
+	.globl vbiVbMemoryWrite
+	.globl vbiVbMemoryRead
+	.globl vbiIoapicOp
+	.globl vbiIoapicIoctl
+	.globl vbiHyIoctl
+	.globl vbiCtxctl
+	.globl vbiSend
+	.globl vbiReceive
+	.globl vbiReply
+	.globl vbiTlbFlush
+	.globl vbiPanic
+	.globl vbiPs
+	.globl vbiKputs
+	.globl vbiKputc
+	.globl vbiIntVCoreUnlock
+	.globl vbiIntVCoreLock
+	.globl vbiVbMgmt
+	.globl vbiMemAttrSet
+	.globl vbiMemAttrGet
+	.globl vbiNsOp
+	.globl vbiVbReset
+	.globl vbiVbRestart
+	.globl vbiVbResume
+	.globl vbiVbSuspend
+	.globl vbiVcoreIntRed_op 
+	.globl vbiVbRegisterRead 
+	.globl vbiVbRegisterWrite 
+	.globl vbiVtlbOp
+	.text
+	.balign 16
+
+#define VBI_STACK_FRAME_SIZE	4
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiSend:
+	movl    $VBI_SYS_send,%eax		/* system call number */
+	push	$7				/* number of arguments */
+	vmcall
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+	ret
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiReceive:
+	movl    $VBI_SYS_receive,%eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t   id,    /@ context id to reply the message to @/
+*    void *       buff,  /@ pointer to reply message  @/
+*    size_t       len,   /@ length of message to reply   @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+vbiReply:
+	movl    $VBI_SYS_reply,%eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiKputs - print a string on the kernel console
+*
+* This system call sends the specified string to the system console.
+*
+* C interface:
+*
+*   vbiKputs (char *s)		/@ pointer to string			@/
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiKputs:
+	movl    $VBI_SYS_kputs,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiKputc - print a character on the kernel console
+*
+* This system call sends the specified character to the system console.
+*
+* C interface:
+*
+*   vbiKputc (char c)		/@ character to print			@/
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiKputc:
+	movl    $VBI_SYS_kputc,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiPanic - panic the system and halt all activity
+*
+* This system call causes the hypervisor to enter a panic state and display
+* various pieces of information on the system console.  The hypervisor
+* then enters an idle state and stops all CPU processing.
+*
+* C interface:
+*
+*   vbiPanic (char *msg)	/@ message string to print on console	@/
+*
+* Returns: does not return
+*
+*/
+
+vbiPanic:
+	movl    $VBI_SYS_panic,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiPs - display the list of contexts on the console
+*
+* This system call sends a "ps" like output of the hypervisor contexts to
+* the system console.
+*
+* C interface:
+*
+*   vbiPs (void)
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiPs:
+	movl    $VBI_SYS_ps,%eax		/* system call number */
+	push	$0				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiIntVCoreUnlock - Re-enable interrupts in the virtual board
+*
+* This call re-enables interrupts in the virtual board, and calls
+* Razor if interrupts are pending.  The value level is the value returned
+* by the corresponding 	
+*
+* C interface:
+*
+*   vbiIntVCoreUnlock (void)
+*
+* Returns: does not return
+*
+*/
+
+vbiIntVCoreUnlock:
+	sti				/* UNLOCK INTERRUPTS */
+	ret
+
+/******************************************************************************
+*
+* vbiIntVCoreLock - Disable interrupts in the virtual core
+*
+* This call disables interrupts in the virtual board.
+*
+* C interface:
+*
+*   int vbiIntVCoreLock (void)
+*
+* Returns: the old value of the interrupt disable 
+*
+*/
+
+vbiIntVCoreLock:
+    pushf				/* push EFLAGS on stack */
+    popl	%eax			/* get EFLAGS in EAX */
+    andl	$EFLAGS_IF,%eax		/* mask it with IF bit */
+    cli				/* LOCK INTERRUPTS */
+    ret
+
+/******************************************************************************
+*
+* vbiVbMgmt - virtual board management
+* 
+* This routine executes the specified command on a given virtual board. The
+* possible commands are:
+* 
+* VBI_VBMGMT_ATTACH 
+* Attach the requesting Virtual Board to the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_DETACH
+* Detatch the requesting Virtual Board from the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_SUSPEND
+* Suspends target Virtual Board from operation.  Fails if Virtual Board
+* has already been suspended
+*
+* VBI_VBMGMT_RESET
+* Resume a target virtual board.  Fails if a Virtual Board has not been
+* suspended. Currently no options are supported
+*
+* VBI_VBMGMT_RESUME
+* Restarts a target Virtual Board which has Preload=0 set in the xml file.
+* Fails if Virtual Board is preloaded (Preload=1)
+*
+*
+* The fourth argument to this routine specifies an flag that must be defined
+* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+* The possible flgas are:
+*   VBI_VTLB_OP_UPDATE_PMD	
+*   VBI_VTLB_OP_UPDATE_PTE	
+*   VBI_VTLB_OP_DELETE_PMD	
+*   VBI_VTLB_OP_SET_PTE_AT	
+*   VBI_VTLB_OP_SET_PTE	
+*   VBI_VTLB_OP_FLUSH_OPS	
+*   VBI_VTLB_OP_INIT	
+*
+* int32_t vbiVbMgmt 
+*    (
+*    uint32_t	cmd,	    /@ attach, detach, suspend, reset or resume @/
+*    uint32_t	handle,    /@ the operation target board handle @/
+*    int32_t	*outError,  /@ where to set error : OK or error flag @/ 
+*    uint32_t	flags,	    /@ options required by the cmd executed @/
+*    void *ctl		    /@ memory / registers data		    @/ 
+*    )
+*
+* RETURNS: OK or error in case of failure
+*/
+
+vbiVbMgmt:
+	movl    $VBI_SYS_vbMgmt,%eax		/* system call number */
+	push	$5				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service.
+*
+* SYNOPSIS
+*\cs
+*
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+vbiVbSuspend:
+	movl    $VBI_SYS_vbSuspend,%eax		/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target core(s)
+* program counter to it's ENTRY function. The ENTRY function is determined based on
+* the loaded binary image. A core does not execute beyond it's ENTRY function
+* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
+* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+* the third argument to this routine.
+* The hypercall sends a message to a manager that provides VB managment services.
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset is not
+* determined. The second argument identifies the cores to perform the operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest OS's
+* responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
+*    vbiCore_t     core,            /@ Core within the VB           @/
+*    uint32_t     options   /@ reload , start options       @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*/
+
+vbiVbReset:
+        movl    $VBI_SYS_vbReset,%eax            /* system call number */
+        push    $3                              /* number of arguments */
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to restart.
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+vbiVbRestart:
+        movl    $VBI_SYS_vbRestart,%eax            /* system call number */
+        push    $3                              /* number of arguments */
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*/
+
+vbiVbResume:
+        movl    $VBI_SYS_vbResume,%eax            /* system call number	*/
+        push    $2                              /* number of arguments	*/
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/******************************************************************************
+*
+* vbiHyIoctl - hypervisor ioctl call
+*
+* This system call interfaces to the general purpose hypervisor ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_HYIOCTL_GETPID
+*     VBI_HYIOCTL_GETPRIORITY
+*     VBI_HYIOCTL_GETSTATS
+*     VBI_HYIOCTL_PADDR
+*		
+* C interface:
+*
+*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*               void *arg1,         /@ address of information @/
+*               void *arg2,         /@ address of information @/
+*               void *arg3,         /@ address of information @/
+*               void *arg4)         /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiHyIoctl:
+	movl    $VBI_SYS_hyIoctl,%eax		/* system call number */
+	push	$5				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiIoapicIoctl - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*                   unsigned arg1,      /@ address of information @/
+*                   unsigned arg2)      /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiIoapicIoctl:
+	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiIoapicOp - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC.
+*
+* function.
+*
+* Possible commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*
+* C interface:
+*
+*   vbiIoapicOp	    (uint32_t cmd,      /@ the operation command     @/
+*                   vbiIrq_t irq,       /@ irq number                @/
+*                   uint32_t filter,    /@ filter                    @/
+*                   vbiVb_t  vbId,      /@ target vb id              @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiIoapicOp:
+	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiCtxctl - hypervisor context control call
+*
+* This system call interfaces to the general purpose hypervisor context
+* control function.
+*
+* Possbile operations:
+*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+*
+* C interface:
+*
+*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
+*		 void *arg)		 /@ address of argument @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiCtxctl:
+	movl    $VBI_SYS_ctxctl,%eax		/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+vbiMmuAttrSet:
+	movl    $VBI_SYS_mmu_attr_set,%eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+vbiMmuAttrGet:
+	movl    $VBI_SYS_mmu_attr_get,%eax	/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiNsOp - virtua board name service call
+*
+* This system call interfaces to the virtual board
+*
+* commands:
+*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+*				
+* C interface:
+*
+*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
+*	    char * name,		    /@ the service name		@/
+*	    uint32_t revision,	    /@ service revision		@/
+*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
+*	  )
+*
+* Returns: OK or ERROR in case of failure
+*
+*/
+
+vbiNsOp:
+	movl    $VBI_SYS_ns_op, %eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+vbiVbMemoryWrite:
+	movl    $VBI_SYS_memWrite_op, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+vbiVbMemoryRead:
+	movl    $VBI_SYS_memRead_op, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running.
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          )
+*
+*\ce
+*
+* RETURNS: N/A
+*
+*
+* SEE ALSO: 
+*/
+
+vbiDebugShellStart:
+
+	movl    $VBI_SYS_dbgShStart, %eax	/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* SYNOPSIS
+* VBI X86 Architecture Supplements
+*\cs
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*\sh VB_ARCH_CONTROL_REGS definition
+*
+*The control registers type used for vbiVbRegister[Read:write] API's
+*
+*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
+*    {
+*    uint32_t  edi;		/@ 00: general register		@/
+*    uint32_t  esi;		/@ 04: general register		@/
+*    uint32_t  ebp;		/@ 08: frame pointer register	@/
+*    uint32_t  esp;		/@ 0C: stack pointer register	@/
+*    uint32_t  ebx;		/@ 10: general register		@/
+*    uint32_t  edx;		/@ 14: general register		@/
+*    uint32_t  ecx;		/@ 18: general register		@/
+*    uint32_t  eax;		/@ 1C: general register		@/
+*    uint32_t  eflags;		/@ 20: status register		@/
+*    INSTR *pc;			/@ 24: program counter		@/
+*    uint32_t  cr0;		/@ 28: control register 0	@/
+*    uint32_t  cr2;		/@ 2C: control register 2	@/
+*    uint32_t  cr3;		/@ 30: control register 3	@/
+*    uint32_t  cr4;		/@ 34: control register 4	@/
+*    uint32_t  cs;		/@ 28: code segment		@/
+*    uint32_t  ds;		/@ 3C: data segment		@/
+*    uint32_t  ss;		/@ 40: stack segment		@/
+*    uint32_t  es;		/@ 44: E segment		@/
+*    uint32_t  fs;		/@ 48: F segment		@/
+*    uint32_t  gs;		/@ 4C: G segment		@/
+*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
+*    } VB_ARCH_CONTROL_REGS;
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES:
+*
+* SEE ALSO: 
+*/
+
+vbiVbRegisterRead:
+
+	movl    $VBI_SYS_RegsRead_op, %eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+* VBI X86 Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*
+*\sh VB_ARCH_CONTROL_REGS definition
+*
+*The control registers type used for vbiVbRegister[Read:write] API's
+*
+*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
+*    {
+*    uint32_t  edi;		/@ 00: general register		@/
+*    uint32_t  esi;		/@ 04: general register		@/
+*    uint32_t  ebp;		/@ 08: frame pointer register	@/
+*    uint32_t  esp;		/@ 0C: stack pointer register	@/
+*    uint32_t  ebx;		/@ 10: general register		@/
+*    uint32_t  edx;		/@ 14: general register		@/
+*    uint32_t  ecx;		/@ 18: general register		@/
+*    uint32_t  eax;		/@ 1C: general register		@/
+*    uint32_t  eflags;		/@ 20: status register		@/
+*    INSTR *pc;			/@ 24: program counter		@/
+*    uint32_t  cr0;		/@ 28: control register 0	@/
+*    uint32_t  cr2;		/@ 2C: control register 2	@/
+*    uint32_t  cr3;		/@ 30: control register 3	@/
+*    uint32_t  cr4;		/@ 34: control register 4	@/
+*    uint32_t  cs;		/@ 28: code segment		@/
+*    uint32_t  ds;		/@ 3C: data segment		@/
+*    uint32_t  ss;		/@ 40: stack segment		@/
+*    uint32_t  es;		/@ 44: E segment		@/
+*    uint32_t  fs;		/@ 48: F segment		@/
+*    uint32_t  gs;		/@ 4C: G segment		@/
+*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: 
+*/
+
+vbiVbRegisterWrite:
+	movl    $VBI_SYS_RegsWrite_op, %eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVcoreIntRed_op - redirect an irq to another vcore
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVcoreIntRed_op 
+*	(
+*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
+*	vbiCore_t		core	/@ destination vcore		 @/
+*	)
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: vbiVioapicIntRedirect()
+* 
+*\NOMANUAL
+*/
+vbiVcoreIntRed_op:
+
+	movl    $VBI_SYS_intRedirect, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiVtlbOp - execute a specified VTLB operation
+*
+* This system call executed the specified VTLB operation
+*
+* C interface:
+*
+*   vbiVtlbOp (
+*            unsigned int op,          /@ VTLB operation @/
+*            unsigned long arg1,       /@ VTLB operation argument 1 @/
+*            unsigned long arg2,       /@ VTLB operation argument 2 @/
+*            unsigned long arg3                /@ VTLB operation argument 3 @/
+*            )
+*
+* Returns: OK or ERROR
+*/
+
+vbiVtlbOp:
+	movl    $VBI_SYS_vtlb_op, %eax          /* system call number */
+	pushl   $4                              /* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
diff --git a/include/asm-x86/vbiX86Arch.h b/include/asm-x86/vbiX86Arch.h
new file mode 100644
index 0000000..4cc6e41
--- /dev/null
+++ b/include/asm-x86/vbiX86Arch.h
@@ -0,0 +1,192 @@
+/* vbiX86Arch.h - x86 architecture specific definitions */
+
+/* Copyright 2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01h,26aug09,mmi  fix WIND00178026: update file name
+01g,17aug09,md   fix comments
+01f,14aug09,md   update to match hypervisor version
+01e,28jul09,mpk  add hardware register set to vbi
+01d,08jun09,md   add define for maximum number of cores
+01c,25may09,md   add byte order define
+01b,06feb09,mmi  add MAX interrupts definition
+01a,14jan09,mmi  created
+*/
+
+#ifndef __INCvbiX86Archh
+#define __INCvbiX86Archh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_HREG_SET - hardware register set, for read/write
+*
+* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
+* another VB
+* 
+* SYNOPSIS
+*
+* VB hardware register set C data structure type definition
+*
+*\cs
+*     typedef struct		/@ VB_REG_SET - used for sys_regsRead/Write @/
+*         {
+*         uint32_t  eax;	/@ 00: general register		@/
+*         uint32_t  ebx;	/@ 04: general register		@/
+*         uint32_t  ecx;	/@ 08: general register		@/
+*         uint32_t  edx;	/@ 0C: general register		@/
+*         uint32_t  esi;	/@ 10: general register		@/
+*         uint32_t  edi;	/@ 14: general register		@/
+*         uint32_t  eip;	/@ 18: program counter		@/
+*         uint32_t  ebp;	/@ 1C: frame pointer register	@/
+*         uint32_t  esp;	/@ 20: stack pointer register	@/
+*         uint32_t  eflags;	/@ 24: status register		@/
+*         uint32_t  cr0;	/@ 28: control register 0	@/
+*         uint32_t  cr3;	/@ 2C: control register 3	@/
+*         uint32_t  cr4;	/@ 30: control register 4	@/
+*         uint32_t  idtr;	/@ 34: IDT task register	@/
+*         uint32_t  gdtr;	/@ 38: GDT task register	@/
+*         uint32_t  ldtr;	/@ 3C: LDT task register	@/
+*         uint32_t  cs;		/@ 40: code segment		@/
+*         uint32_t  ss;		/@ 44: stack segment		@/
+*         uint32_t  ds;		/@ 48: data segment		@/
+*         uint32_t  es;		/@ 4C: E segment		@/
+*         uint32_t  fs;		/@ 50: F segment		@/
+*         uint32_t  gs;		/@ 54: G segment		@/
+*         uint32_t  tr;		/@ 58: task register		@/
+*         } VB_HREG_SET;
+*
+*\ce
+* SEE ALSO: NONE
+* 
+*/
+
+typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
+    {
+    uint32_t  eax;		/* 00: general register		*/
+    uint32_t  ebx;		/* 04: general register		*/
+    uint32_t  ecx;		/* 08: general register		*/
+    uint32_t  edx;		/* 0C: general register		*/
+    uint32_t  esi;		/* 10: general register		*/
+    uint32_t  edi;		/* 14: general register		*/
+    uint32_t  eip;		/* 18: program counter		*/
+    uint32_t  ebp;		/* 1C: frame pointer register	*/
+    uint32_t  esp;		/* 20: stack pointer register	*/
+    uint32_t  eflags;		/* 24: status register		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr3;		/* 2C: control register 3	*/
+    uint32_t  cr4;		/* 30: control register 4	*/
+    uint32_t  idtr;		/* 34: IDT task register	*/
+    uint32_t  gdtr;		/* 38: GDT task register	*/
+    uint32_t  ldtr;		/* 3C: LDT task register	*/
+    uint32_t  cs;		/* 40: code segment		*/
+    uint32_t  ss;		/* 44: stack segment		*/
+    uint32_t  ds;		/* 48: data segment		*/
+    uint32_t  es;		/* 4C: E segment		*/
+    uint32_t  fs;		/* 50: F segment		*/
+    uint32_t  gs;		/* 54: G segment		*/
+    uint32_t  tr;		/* 58: task register		*/
+    } VB_HREG_SET;
+#endif /* _ASMLANGUAGE */
+
+/* x86 uses little endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
+
+#define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_ARCH_EXC_TABLE_SIZE     32
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)            
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+#define VBI_IN_DIVIDE_ERROR		 0
+#define VBI_IN_DEBUG			 1
+#define VBI_IN_NON_MASKABLE		 2
+#define VBI_IN_BREAKPOINT		 3
+#define VBI_IN_OVERFLOW			 4
+#define VBI_IN_BOUND			 5
+#define VBI_IN_INVALID_OPCODE		 6
+#define VBI_IN_NO_DEVICE		 7
+#define VBI_IN_DOUBLE_FAULT		 8
+#define VBI_IN_CP_OVERRUN		 9
+#define VBI_IN_INVALID_TSS		10
+#define VBI_IN_NO_SEGMENT		11
+#define VBI_IN_STACK_FAULT		12
+#define VBI_IN_PROTECTION_FAULT		13
+#define VBI_IN_PAGE_FAULT		14
+#define VBI_IN_RESERVED			15
+#define VBI_IN_CP_ERROR			16
+#define VBI_IN_ALIGNMENT		17
+#define VBI_IN_MACHINE_CHECK		18
+#define VBI_IN_SIMD			19
+
+/* 19-31 Intel reserved exceptions  */
+
+/* 32-255 user defined exceptions  */
+
+#define VBI_IN_EXT_IRQ_BASE		32	/* local timer interrupt */
+
+#define VBI_IN_EXT_IRQ0			(VBI_IN_EXT_IRQ_BASE + 0)	
+#define VBI_IN_EXT_IRQ1			(VBI_IN_EXT_IRQ_BASE + 1)	
+#define VBI_IN_EXT_IRQ2			(VBI_IN_EXT_IRQ_BASE + 2)	
+#define VBI_IN_EXT_IRQ3 		(VBI_IN_EXT_IRQ_BASE + 3)	
+#define VBI_IN_EXT_IRQ4			(VBI_IN_EXT_IRQ_BASE + 4)	
+#define VBI_IN_EXT_IRQ5			(VBI_IN_EXT_IRQ_BASE + 5)	
+#define VBI_IN_EXT_IRQ6			(VBI_IN_EXT_IRQ_BASE + 6)	
+#define VBI_IN_EXT_IRQ7			(VBI_IN_EXT_IRQ_BASE + 7)	
+#define VBI_IN_EXT_IRQ8			(VBI_IN_EXT_IRQ_BASE + 8)	
+#define VBI_IN_EXT_IRQ9			(VBI_IN_EXT_IRQ_BASE + 9)	
+#define VBI_IN_EXT_IRQ10		(VBI_IN_EXT_IRQ_BASE + 10)	
+#define VBI_IN_EXT_IRQ11		(VBI_IN_EXT_IRQ_BASE + 11)	
+#define VBI_IN_EXT_IRQ12		(VBI_IN_EXT_IRQ_BASE + 12)	
+#define VBI_IN_EXT_IRQ13		(VBI_IN_EXT_IRQ_BASE + 13)	
+#define VBI_IN_EXT_IRQ14		(VBI_IN_EXT_IRQ_BASE + 14)	
+#define VBI_IN_EXT_IRQ15		(VBI_IN_EXT_IRQ_BASE + 15)	
+#define VBI_IN_EXT_IRQ16		(VBI_IN_EXT_IRQ_BASE + 16)	
+#define VBI_IN_EXT_IRQ17		(VBI_IN_EXT_IRQ_BASE + 17)	
+#define VBI_IN_EXT_IRQ18		(VBI_IN_EXT_IRQ_BASE + 18)	
+#define VBI_IN_EXT_IRQ19		(VBI_IN_EXT_IRQ_BASE + 19)	
+#define VBI_IN_EXT_IRQ20		(VBI_IN_EXT_IRQ_BASE + 20)	
+#define VBI_IN_EXT_IRQ21		(VBI_IN_EXT_IRQ_BASE + 21)	
+#define VBI_IN_EXT_IRQ22		(VBI_IN_EXT_IRQ_BASE + 22)	
+#define VBI_IN_EXT_IRQ23		(VBI_IN_EXT_IRQ_BASE + 23)	
+#define VBI_IN_EXT_IRQ24		(VBI_IN_EXT_IRQ_BASE + 24)	
+#define VBI_IN_EXT_IRQ25		(VBI_IN_EXT_IRQ_BASE + 25)	
+#define VBI_IN_EXT_IRQ26		(VBI_IN_EXT_IRQ_BASE + 26)	
+#define VBI_IN_EXT_IRQ27		(VBI_IN_EXT_IRQ_BASE + 27)	
+#define VBI_IN_EXT_IRQ28		(VBI_IN_EXT_IRQ_BASE + 28)	
+#define VBI_IN_EXT_IRQ29		(VBI_IN_EXT_IRQ_BASE + 29)	
+#define VBI_IN_EXT_IRQ30		(VBI_IN_EXT_IRQ_BASE + 30)	
+#define VBI_IN_EXT_IRQ31		(VBI_IN_EXT_IRQ_BASE + 31)	
+#define VBI_IN_EXT_IRQ32		(VBI_IN_EXT_IRQ_BASE + 32)	
+#define VBI_IN_EXT_IRQ33		(VBI_IN_EXT_IRQ_BASE + 33)	
+#define VBI_IN_EXT_IRQ34		(VBI_IN_EXT_IRQ_BASE + 34)	
+#define VBI_IN_EXT_IRQ35		(VBI_IN_EXT_IRQ_BASE + 35)	
+#define VBI_IN_EXT_IRQ36		(VBI_IN_EXT_IRQ_BASE + 36)	
+#define VBI_IN_EXT_IRQ37		(VBI_IN_EXT_IRQ_BASE + 37)	
+#define VBI_IN_EXT_IRQ38		(VBI_IN_EXT_IRQ_BASE + 38)	
+#define VBI_IN_EXT_IRQ39		(VBI_IN_EXT_IRQ_BASE + 39)	
+#define VBI_IN_EXT_IRQ40		(VBI_IN_EXT_IRQ_BASE + 40)	
+#define VBI_IN_EXT_IRQ41		(VBI_IN_EXT_IRQ_BASE + 41)	
+#define VBI_IN_EXT_IRQ42		(VBI_IN_EXT_IRQ_BASE + 42)	
+#define VBI_IN_EXT_IRQ43		(VBI_IN_EXT_IRQ_BASE + 43)	
+#define VBI_IN_EXT_IRQ44		(VBI_IN_EXT_IRQ_BASE + 44)	
+#define VBI_IN_EXT_IRQ45		(VBI_IN_EXT_IRQ_BASE + 45)	
+#define VBI_IN_EXT_IRQ46		(VBI_IN_EXT_IRQ_BASE + 46)	
+#define VBI_IN_EXT_IRQ47		(VBI_IN_EXT_IRQ_BASE + 47)	
+
+/* timer vector */
+
+#define VBI_CLOCK_TIMER_VECTOR		(0)
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)    
+#ifdef __cplusplus
+}
+#endif
+#endif /* __INCVbiX86Archh */
diff --git a/include/vbi/support/sys/x86/arch.h b/include/vbi/support/sys/x86/arch.h
new file mode 100644
index 0000000..6365b29
--- /dev/null
+++ b/include/vbi/support/sys/x86/arch.h
@@ -0,0 +1,763 @@
+/* sys/x86/arch.h - x86 architecture specific definitions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02w,24sep09,mmi  add virtual interrupts
+02v,01sep09,mmi  include vbInterface.h
+02u,19aug09,md   add VBI register load/save region
+02t,28jul09,mpk  add cache align size
+02s,18jun09,dtr  Move excMgrId def here.
+02r,11jun09,md   add MSI interrupt space
+02q,09jun09,md   add support for additional I/O APICs
+02p,16jul09,dbt  Added vmx_cr4 registery in ARCH_INFO structure.
+02o,13jul09,dbt  Added x86Vb32IdtXxx() API prototypes.
+02n,10jul09,dbt  Added information about guest MMU mode (32 bits, 64bits,...).
+02m,03jul09,dbt  Added HY_TSS_GDT_ENTRY_SIZE macro.
+02l,30jun09,dbt  64-bits support.
+		 Added support for 32-bits VB GDT
+02k,25jun09,dbt  Updated bitClear prototype.
+02j,19jun09,dbt  Updated idtIntGateCreate() prototype for 64 bits support.
+02m,14jul09,rdd  VT-d integration
+02i,20may09,md   add byte order define
+02h,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02g,20apr09,mpk  context vaddr start
+02f,09mar09,md   add test and set function
+02e,13feb09,md   add per-cpu hypervisor TSS
+02d,20jan09,mmi  add VIOAPIC entries size
+02c,15jan09,md   add configuration options
+02b,20nov08,dtr  Remove vIoapic entries in ARCH_INFO.
+02a,18nov08,dbt  Added MSR area.
+01z,12nov08,md   fix isCpuCorePresent macro
+01y,28oct08,dbt  Added vtlbInit() prototype. Added vtlb_desc structure to
+                 ARCH_INFO.
+01x,27oct08,md   re-work multi-core ipi
+01w,17oct08,md   add ipi interrupt vector definitions
+01v,22sep08,md   add interrupt statistics
+01u,03sep08,md   update CPU_MAPPING to indicate if core is present
+01t,31jul08,md   add vmcs bitmap pointers
+01s,17jul08,md   add cpu mapping table
+01r,20may08,md   add multi-core support
+01q,19may08,gws  replace interrupt queues
+01p,23apr08,gws  macro rename
+01o,17apr08,gws  add macros for int vectors
+01n,14apr08,md   re-work interrupt delivery
+01m,27mar08,md   add pointer to queued interrupts
+01l,17mar08,md   add arch specific stats
+01k,07mar08,md   add cached copies of CR0 and CR3
+01j,04mar08,md   add FRAMEBASESZ
+01i,26feb08,md   add APIC timer interrupt
+01h,19feb08,md   add VT-x register save area
+01g,28jan08,md   add VT-x support
+01f,05oct07,md   add network/host translation functions
+01e,05sep07,md   clean up
+01d,30aug07,md   added IDT and syscall transition defines
+01c,31jul07,md   added gdtInit() and gdtTssCreate() prototypes
+01b,27jul07,md   added struct arch_info
+01a,06jul07,md   written.
+*/
+
+#ifndef __INCx86Archh
+#define __INCx86Archh
+
+#include <sys/regs.h>
+#include <sys/x86/vmx.h>
+#include <vbInterface.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LP64
+#define _WRS_PORTABLE_bLib
+#define _WRS_BLIB_ALIGNMENT     1       /* 2 byte alignment mask */
+#endif
+
+/* x86 uses little endian byte ordering */
+
+#define	__BYTE_ORDER	__LITTLE_ENDIAN
+
+/* maximum number of cpu's supported */
+
+#if defined(WRHV_INCLUDE_MULTI_CORE)
+# define HY_MAX_CPU		16
+#else
+# define HY_MAX_CPU		1
+#endif
+
+/* boot processor number */
+
+#define	HY_BOOT_CPU		0
+
+/* attribute declaration for cpu specific variable */
+
+#define	CPU_PRIVATE	__attribute__((__section__(".cpu_private")))
+
+/* interrupt related defines */
+
+#define	X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define X86_MAX_INTERRUPTS      (X86_MAX_VECTORS - X86_INT_VECTOR_BASE)
+#define INT_QUEUE_DEPTH	5	/* per interrupt source */
+#define NUM_WDS_PER_ISR		(256 / 32)
+#define INT_QUEUE_OPTIMIZE
+#define ARCH_RESERVED_VECTORS   0x20
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#ifndef	_ASMLANGUAGE
+
+typedef long ptrdiff_t;
+
+/* per context interrupt statistics */
+
+typedef struct arch_int_stats {
+    uint32_t  intDeliverCount;		/* interrupt delivery count	   */
+    uint32_t  intAckCount;		/* interrupt acknowledge count	   */
+    } ARCH_INT_STATS;
+
+/* per context architecture specific statistics */
+
+typedef struct arch_stats {
+    uint32_t  VMexitCount[NUM_VM_EXITS]; /* per vm-exit count		   */
+    uint32_t  VMexitUnhandled;		 /* number of unhandled exits	   */
+					 /* interrupt stats		   */
+    ARCH_INT_STATS interrupt[X86_MAX_VECTORS];
+    } ARCH_STATS;
+
+/* queued interrupt information */
+
+typedef struct arch_int {
+    uint32_t	     intNum;	 	/* interrupt number to deliver	   */
+    uint32_t	     errorCode;	 	/* exrror code to push on stack	   */
+    struct arch_int *next;		/* pointer to next interrupt	   */
+    } ARCH_INT;
+
+/* Guest MMU mode */
+
+typedef enum arch_mmu_mmode
+    {
+    MMU32,			/* 32-bit MMU				*/
+    MMU32_PAE,			/* 32-bit MMU with PAE support		*/
+    MMU64			/* 64-bit MMU				*/
+    } ARCH_MMU_MODE;
+
+/* per context architecture specific information */
+
+typedef struct arch_info {
+    void       *vmcs;		/* pointer to VT-x VMCS data region	*/
+    ARCH_STATS *stats;		/* architecture specific statistics	*/
+    void       *ioBitmapA;	/* pointer to VMCS I/O bitmap A	   	*/
+    void       *ioBitmapB;	/* pointer to VMCS I/O bitmap B	   	*/
+
+    /* The portion of HREG_SET that is not saved in the VMCS: */
+
+#ifdef LP64
+    _RType	vmx_rax;	/* general register			*/
+    _RType	vmx_rbx;	/* general register			*/
+    _RType	vmx_rcx;	/* general register			*/
+    _RType	vmx_rdx;	/* general register			*/
+    _RType	vmx_rsp;	/* stack pointer register		*/
+    _RType	vmx_rbp;	/* frame pointer register		*/
+    _RType	vmx_rsi;	/* general register			*/
+    _RType	vmx_rdi;	/* general register			*/
+    _RType	vmx_r8;		/* general register			*/
+    _RType	vmx_r9;		/* general register			*/
+    _RType	vmx_r10;	/* general register			*/
+    _RType	vmx_r11;	/* general register			*/
+    _RType	vmx_r12;	/* general register			*/
+    _RType	vmx_r13;	/* general register			*/
+    _RType	vmx_r14;	/* general register			*/
+    _RType	vmx_r15;	/* general register			*/
+    _RType	vmx_cr0;	/* control register 0			*/
+    _RType	vmx_cr3;	/* control register 3			*/
+    _RType	vmx_cr4;	/* control register 4			*/
+#else
+    size_t	tssIndex;	/* entry this tss is using in the GDT  	*/
+    TSS	       *tss;		/* pointer to task state segment struct	*/
+    _RType	vmx_eax;	/* VMX saved general register		*/
+    _RType	vmx_ebx;	/* VMX saved general register		*/
+    _RType	vmx_ecx;	/* VMX saved general register		*/
+    _RType	vmx_edx;	/* VMX saved general register		*/
+    _RType	vmx_edi;	/* VMX saved general register		*/
+    _RType	vmx_esi;	/* VMX saved general register		*/
+    _RType	vmx_ebp;	/* VMX saved frame pointer register	*/
+    _RType	vmx_cr0;	/* VMX cached CR0 register value	*/
+    _RType	vmx_cr3;	/* VMX saved CR3 (page table) register	*/
+    _RType	vmx_cr4;	/* VMX cached CR0 register value */
+#endif
+
+    /* Intel VT-d IOMMU domain attributes */
+
+    uint32_t   iommu_domid;
+    uint32_t   iommu_transtype;
+    uint32_t   iommu_agaw;
+    void       *pageroot_maddr;
+
+    /* MSR management */
+
+    void       *msrBitmap;	/* pointer to VMCS MSR bitmap		*/
+    void       *msrEntries;	/* pointer to VM MSR load/save area	*/
+    void       *msrHostEntries;	/* pointer to Host MSR load area	*/
+    uint32_t	msrMaxEntries;	/* maximum number of MSR entries	*/
+    uint32_t	msrMaxHostEntries;/* maximum number of Host MSR entries	*/
+
+    uint32_t	archFlags;	/* 30: arch specific flags		*/
+    uint32_t	idtVector;	/* 34: IDT vectoring information	*/
+    uint32_t	idtCode;	/* 38: IDT vectoring error code		*/
+
+    /* VTLB stuff */
+
+    struct vtlb_desc *	pVtlbDesc;	/* VTLB context descriptor	*/
+    ARCH_MMU_MODE	mmuMode;	/* Guest MMU mode */
+
+    /* VBI interface register read/write cache area */
+
+    uint32_t	  vbiRegsValid;	/* registers values have been set	*/
+    VBI_HREG_SET  vbiRegs;	/* register values set by VBI API	*/
+
+    } ARCH_INFO;
+
+/* information for per-core architecture mapping */
+
+typedef struct cpu_core_mapping {
+    uint32_t present;
+    uint32_t apicId;
+} CPU_CORE_MAPPING;
+
+struct hy_ctx;
+
+/* arch specific functions */
+
+extern void gdtInit (void *addr);
+extern int  gdtTssCreate (uint32_t gdtNumber, TSS *pTss, uint32_t tssSize,
+			  uint32_t priv);
+extern int  gdtCallCreate (uint32_t gdtNumber, void *addr, uint32_t priv);
+extern int  gdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
+
+extern void idtInit (void *addr);
+extern int  idtTaskGateCreate (uint32_t idtNumber, uint32_t gdtEntry,
+			       uint32_t priv);
+extern int  idtIntGateCreate (uint32_t idtNumber, void *addr, uint32_t priv);
+
+extern void bitSet (void *addr, unsigned long position);
+extern void bitClear (void *addr, unsigned long position);
+extern void vtlbInit (struct hy_ctx * ctx);
+extern int  vtlbMmuOp (uint32_t op, uint32_t arg1,
+		       uint32_t arg2, uint32_t arg3);
+extern uint32_t testAndSet (void *addr);
+extern int	x86Guest32GdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
+extern void *	x86Guest32GdtAddrGet (void);
+extern size_t	x86Guest32GdtSizeGet (void);
+extern size_t	x86Guest32GdtLimitGet (void);
+extern void *	x86Guest32IdtAddrGet (void);
+extern size_t	x86Guest32IdtSizeGet (void);
+extern size_t	x86Guest32IdtLimitGet (void);
+
+/* arch specific globals */
+
+extern CPU_CORE_MAPPING cpuCoreMapping[HY_MAX_CPU];
+extern ARCH_INT_STATS   cpuIntStats[HY_MAX_CPU][X86_MAX_VECTORS];
+CPU_PRIVATE extern ctx_t excMgrId;	/* exception mananger */
+
+#endif	/* _ASMLANGUAGE */
+
+/* struct arch_info offsets */
+
+#ifdef LP64
+#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer	       */
+#define CTX_ARCH_STATS_OFF	8   /* offset to ARCH_STATS	       */
+#define CTX_ARCH_IO_A_OFF	16  /* offset to *ioBitmapA	       */
+#define CTX_ARCH_IO_B_OFF	24  /* offset to *ioBitmapB	       */
+#define	CTX_ARCH_VRAX_OFF	32  /* offset to vmx RAX register save */
+#define	CTX_ARCH_VRBX_OFF	40  /* offset to vmx RBX register save */
+#define	CTX_ARCH_VRCX_OFF	48  /* offset to vmx RCX register save */
+#define	CTX_ARCH_VRDX_OFF	56  /* offset to vmx RDX register save */
+#define	CTX_ARCH_VRSP_OFF	64  /* offset to vmx RSP register save */
+#define	CTX_ARCH_VRBP_OFF	72  /* offset to vmx RBP register save */
+#define	CTX_ARCH_VRSI_OFF	80  /* offset to vmx RSI register save */
+#define	CTX_ARCH_VRDI_OFF	88  /* offset to vmx RDI register save */
+#define	CTX_ARCH_VR8_OFF	96  /* offset to vmx R8; register save */
+#define	CTX_ARCH_VR9_OFF	104 /* offset to vmx R9; register save */
+#define	CTX_ARCH_VR10_OFF	112 /* offset to vmx R10 register save */
+#define	CTX_ARCH_VR11_OFF	120 /* offset to vmx R11 register save */
+#define	CTX_ARCH_VR12_OFF	128 /* offset to vmx R12 register save */
+#define	CTX_ARCH_VR13_OFF	136 /* offset to vmx R13 register save */
+#define	CTX_ARCH_VR14_OFF	144 /* offset to vmx R14 register save */
+#define	CTX_ARCH_VR15_OFF	152 /* offset to vmx R15 register save */
+#define	CTX_ARCH_VCR0_OFF	160 /* offset to vmx CR0 register save */
+#define	CTX_ARCH_VCR3_OFF	168 /* offset to vmx CR3 register save */
+#define	CTX_ARCH_VCR4_OFF	176 /* offset to vmx CR4 register save */
+#define	CTX_ARCH_MSRBMP_OFF	184 /* offset to VMCS MSR bitmap       */
+#define	CTX_ARCH_MSRENT_OFF	192 /* offset to VM MSR load/save area */
+#define	CTX_ARCH_MSRHENT_OFF	200 /* offset to Host MSR load area    */
+#define	CTX_ARCH_MSRMAXENT_OFF	208 /* offset to maxnum MSR entries    */
+#define	CTX_ARCH_MSRMAXHENT_OFF	216 /* offset to maxnum Host MSR ents  */
+#define	CTX_ARCH_ARCHFLAGS_OFF	224 /* offset to arch specific flags   */
+#define	CTX_ARCH_IDTVECT_OFF	228 /* offset to IDT vector	       */
+#define	CTX_ARCH_IDTCODE_OFF	232 /* offset to IDT error code	       */
+#else
+#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer		*/
+#define CTX_ARCH_STATS_OFF	4   /* offset to ARCH_STATS		*/
+#define CTX_ARCH_IO_A_OFF	8   /* offset to *ioBitmapA		*/
+#define CTX_ARCH_IO_B_OFF	12  /* offset to *ioBitmapB		*/
+#define	CTX_ARCH_TINDEX_OFF	16  /* offset to tss index		*/
+#define	CTX_ARCH_TSS_OFF	20  /* offset to tss pointer		*/
+#define	CTX_ARCH_VEAX_OFF	24  /* offset to vmx EAX register save	*/
+#define	CTX_ARCH_VEBX_OFF	28  /* offset to vmx EBX register save	*/
+#define	CTX_ARCH_VECX_OFF	32  /* offset to vmx ECX register save	*/
+#define	CTX_ARCH_VEDX_OFF	36  /* offset to vmx EDX register save	*/
+#define	CTX_ARCH_VEDI_OFF	40  /* offset to vmx EDI register save	*/
+#define	CTX_ARCH_VESI_OFF	44  /* offset to vmx ESI register save	*/
+#define	CTX_ARCH_VEBP_OFF	48  /* offset to vmx EBP register save	*/
+#define	CTX_ARCH_VCR0_OFF	52  /* offset to vmx CR0 register save	*/
+#define	CTX_ARCH_VCR3_OFF	56  /* offset to vmx CR3 register save	*/
+#define	CTX_ARCH_VCR4_OFF	60  /* offset to vmx CR4 register save	*/
+#define	CTX_ARCH_MSRBMP_OFF	64  /* offset to VMCS MSR bitmap        */
+#define	CTX_ARCH_MSRENT_OFF	68  /* offset to VM MSR load/save area  */
+#define	CTX_ARCH_MSRHENT_OFF	72  /* offset to Host MSR load area     */
+#define	CTX_ARCH_MSRMAXENT_OFF	76  /* offset to maxnum MSR entries     */
+#define	CTX_ARCH_MSRMAXHENT_OFF	80  /* offset to maxnum Host MSR ents   */
+#define	CTX_ARCH_ARCHFLAGS_OFF	84  /* offset to arch specific flags    */
+#define	CTX_ARCH_IDTVECT_OFF	88  /* offset to IDT vector	        */
+#define	CTX_ARCH_IDTCODE_OFF	92  /* offset to IDT error code	        */
+#endif /* LP64 */
+
+/* arch specific flags */
+
+#define	ARCH_FLAG_INTRUN	0x01	/* interrupts running 		*/
+#define	ARCH_FLAG_IWIN		0x02	/* interrupt window exiting on	*/
+
+/* macros to locate stack boundaries (stacks grow down in x86) */
+
+#define	STACK_START_ADDR(begin, size)	((begin) + (size) - sizeof(int))
+#define	STACK_END_ADDR(begin, size)	(begin)
+
+#define	FRAMEBASESZ	8		/* minimum stack frame size */
+
+
+/* maximum number of entries in the GDT table */
+
+#define GDT_MAX_ENTRIES	64
+
+/* maximum number of entries in the IDT table */
+
+#define IDT_MAX_ENTRIES	256
+
+/* maximum number of entries in the TSS table */
+
+					/* maximum number of TSS structs    */
+#define TSS_MAX_ENTRIES		(32 + HY_MAX_CPU)
+#define TSS_HYPERVISOR_ENTRY	0	/* TSS entry used by the hypervisor */
+					/* first entry which we can use     */
+#define TSS_FIRST_CTX_ENTRY	HY_MAX_CPU
+
+/* GDT assignments */
+
+#define	CS_SYS_GDT_ENTRY	1	/* entry  1: code for the supervisor */
+#define	DS_SYS_GDT_ENTRY	2	/* entry  2: data for the supervisor */
+#define	CS_EXC_GDT_ENTRY	3	/* entry  3: code for exceptions     */
+#define	CS_INT_GDT_ENTRY	4	/* entry  4: code for interrupts     */
+#define	CS_CTX_GDT_ENTRY	5	/* entry  5: code for the user task  */
+#define	DS_CTX_GDT_ENTRY	6	/* entry  6: data for the user task  */
+#define	HY_TSS_GDT_ENTRY	7	/* entry  7: task state (hypervisor) */
+					/* entry  7+cpu: system call gate    */
+
+#ifdef	LP64
+/* In 64 bits mode, a system segment entry requires to GDT entry slots */
+
+#define	HY_SYS_SEG_ENTRY_SIZE	2
+#else	/* LP64 */
+#define	HY_SYS_SEG_ENTRY_SIZE	1
+#endif	/* LP64 */
+
+#define	HY_SYSCALL_GDT_ENTRY	(HY_TSS_GDT_ENTRY + \
+					(HY_SYS_SEG_ENTRY_SIZE * HY_MAX_CPU))
+					/* first entry we can use for TSS's  */
+#define	CTX_FIRST_GDT_ENTRY     (HY_SYSCALL_GDT_ENTRY + HY_SYS_SEG_ENTRY_SIZE)
+
+/*
+ * Context memory layout:
+ *
+ *         +---------------+ 0xFFFFFFFF
+ *         |               |
+ *         |               |
+ *         |    unused     |
+ *         |               |
+ *         +---------------+ 0xFFC0B000
+ *         |   Transition  |
+ *         |     Stack     |
+ *         +---------------+ 0xFFC0A000 (supv R/W)
+ *         |    System     |
+ *         |    Control    |
+ *         +---------------+ 0xFFC09000 (supv R/O)
+ *         |   Transition  |
+ *         |      Stub     |
+ *         | (syscall and  |
+ *         |  exceptions)  |
+ *         +---------------+ 0xFFC08000 (supv R/O)
+ *         |               |
+ *         |      TSS      |
+ *         |   Structures  |
+ *         |               |
+ *         +---------------+ 0xFFC02000 (supv R/O)
+ *         |               |
+ *         |      IDT      |
+ *         |               |
+ *         +---------------+ 0xFFC01000 (user R/O)
+ *         |               |
+ *         |      GDT      |
+ *         |               | 0xFFFC0000 (user R/O)
+ *         +---------------+
+ *         |               | 0xFFFBFFFF
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |    Context    |
+ *         |    Memory     |
+ *         |    Space      |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         +---------------+ 0x00000000
+ *
+ */
+
+/* maximum address useable by a VM context */
+
+#define	CTX_VADDR_MAX	0xFFFFFFFF - 0x00400000
+
+/*
+ * virtual address at which the GDT is mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_GDT	0xFFC00000
+
+/*
+ * virtual address at which the IDT is mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_IDT	0xFFC01000
+
+/*
+ * virtual address at which the TSS's are mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_TSS	0xFFC02000
+
+#if	!defined(USE_VTX)
+/* virtual address of the system call and exception stubs */
+
+#define	CTX_VADDR_STUBS	  0xFFC08000
+
+/* virtual address of the hypervisor x86 control page */
+
+#define	CTX_VADDR_SYSCTL  0xFFC09000
+
+/* virtual address of the system call stub */
+
+#define	CTX_VADDR_SYSCALL CTX_VADDR_STUBS
+#endif	/* USE_VTX */
+
+/*
+ * virtual address of the transition stack (not used for Hypervisor 
+ * memory context)
+ */
+
+#define	CTX_VADDR_TSTACK  0xFFC0A000
+
+/* hypervisor per-cpu storage area */
+
+#define	HY_VADDR_CPU_MEM	0xFF800000
+#define	HY_CPU_MEM_PAGES	8
+
+/* Maximum cache line size for the cpu */
+
+#define	_CPU_CACHE_ALIGN_SHIFT	5
+#undef	_CPU_CACHE_ALIGN_SIZE
+#define	_CPU_CACHE_ALIGN_SIZE	32
+
+/* Core interrupt vector assignments: */
+
+/* level 0:    0-15  (Intel assigned exception vectors) */
+/* level 1:   16-31  (Intel assigned exception vectors) */
+
+#define IN_DIVIDE_ERROR			 0
+#define IN_DEBUG			 1
+#define IN_NON_MASKABLE			 2
+#define IN_BREAKPOINT			 3
+#define IN_OVERFLOW			 4
+#define IN_BOUND			 5
+#define IN_INVALID_OPCODE		 6
+#define IN_NO_DEVICE			 7
+#define IN_DOUBLE_FAULT			 8
+#define IN_CP_OVERRUN			 9
+#define IN_INVALID_TSS			10
+#define IN_NO_SEGMENT			11
+#define IN_STACK_FAULT			12
+#define IN_PROTECTION_FAULT		13
+#define IN_PAGE_FAULT			14
+#define IN_RESERVED			15
+#define IN_CP_ERROR			16
+#define IN_ALIGNMENT			17
+#define IN_MACHINE_CHECK		18
+#define IN_SIMD				19
+
+/* level 2:   32-47  */
+/* level 3:   48-63  */
+
+#define IN_APIC_TIMER			32	/* local timer interrupt */
+
+#define X86_INT_VECTOR_BASE		40	/* IRQ vectors, 40-63 */
+
+/* Interrupt controller IRQ's */
+
+/* first I/O APIC (40-63) */
+
+#define	X86_IOAPIC0_VECTOR_BASE		 X86_INT_VECTOR_BASE
+
+#define IN_EXT_IRQ0			X86_IOAPIC0_VECTOR_BASE + 0
+#define IN_EXT_IRQ1			X86_IOAPIC0_VECTOR_BASE + 1
+#define IN_EXT_IRQ2			X86_IOAPIC0_VECTOR_BASE + 2
+#define IN_EXT_IRQ3			X86_IOAPIC0_VECTOR_BASE + 3
+#define IN_EXT_IRQ4			X86_IOAPIC0_VECTOR_BASE + 4
+#define IN_EXT_IRQ5			X86_IOAPIC0_VECTOR_BASE + 5
+#define IN_EXT_IRQ6			X86_IOAPIC0_VECTOR_BASE + 6
+#define IN_EXT_IRQ7			X86_IOAPIC0_VECTOR_BASE + 7
+#define IN_EXT_IRQ8			X86_IOAPIC0_VECTOR_BASE + 8
+#define IN_EXT_IRQ9			X86_IOAPIC0_VECTOR_BASE + 9
+#define IN_EXT_IRQ10			X86_IOAPIC0_VECTOR_BASE + 10
+#define IN_EXT_IRQ11			X86_IOAPIC0_VECTOR_BASE + 11
+#define IN_EXT_IRQ12			X86_IOAPIC0_VECTOR_BASE + 12
+#define IN_EXT_IRQ13			X86_IOAPIC0_VECTOR_BASE + 13
+#define IN_EXT_IRQ14			X86_IOAPIC0_VECTOR_BASE + 14
+#define IN_EXT_IRQ15			X86_IOAPIC0_VECTOR_BASE + 15
+#define IN_EXT_IRQ16			X86_IOAPIC0_VECTOR_BASE + 16
+#define IN_EXT_IRQ17			X86_IOAPIC0_VECTOR_BASE + 17
+#define IN_EXT_IRQ18			X86_IOAPIC0_VECTOR_BASE + 18
+#define IN_EXT_IRQ19			X86_IOAPIC0_VECTOR_BASE + 19
+#define IN_EXT_IRQ20			X86_IOAPIC0_VECTOR_BASE + 20
+#define IN_EXT_IRQ21			X86_IOAPIC0_VECTOR_BASE + 21
+#define IN_EXT_IRQ22			X86_IOAPIC0_VECTOR_BASE + 22
+#define IN_EXT_IRQ23			X86_IOAPIC0_VECTOR_BASE + 23
+
+/* level 4:   64-79  */
+/* level 5:   80-95  */
+
+/* second I/O APIC (64-87) */
+
+#define	X86_IOAPIC1_VECTOR_BASE		(X86_INT_VECTOR_BASE + 24)
+
+#define IN_EXT_IRQ24			X86_IOAPIC1_VECTOR_BASE + 0
+#define IN_EXT_IRQ25			X86_IOAPIC1_VECTOR_BASE + 1
+#define IN_EXT_IRQ26			X86_IOAPIC1_VECTOR_BASE + 2
+#define IN_EXT_IRQ27			X86_IOAPIC1_VECTOR_BASE + 3
+#define IN_EXT_IRQ28			X86_IOAPIC1_VECTOR_BASE + 4
+#define IN_EXT_IRQ29			X86_IOAPIC1_VECTOR_BASE + 5
+#define IN_EXT_IRQ30			X86_IOAPIC1_VECTOR_BASE + 6
+#define IN_EXT_IRQ31			X86_IOAPIC1_VECTOR_BASE + 7
+#define IN_EXT_IRQ32			X86_IOAPIC1_VECTOR_BASE + 8
+#define IN_EXT_IRQ33			X86_IOAPIC1_VECTOR_BASE + 9
+#define IN_EXT_IRQ34			X86_IOAPIC1_VECTOR_BASE + 10
+#define IN_EXT_IRQ35			X86_IOAPIC1_VECTOR_BASE + 11
+#define IN_EXT_IRQ36			X86_IOAPIC1_VECTOR_BASE + 12
+#define IN_EXT_IRQ37			X86_IOAPIC1_VECTOR_BASE + 13
+#define IN_EXT_IRQ38			X86_IOAPIC1_VECTOR_BASE + 14
+#define IN_EXT_IRQ39			X86_IOAPIC1_VECTOR_BASE + 15
+#define IN_EXT_IRQ40			X86_IOAPIC1_VECTOR_BASE + 16
+#define IN_EXT_IRQ41			X86_IOAPIC1_VECTOR_BASE + 17
+#define IN_EXT_IRQ42			X86_IOAPIC1_VECTOR_BASE + 18
+#define IN_EXT_IRQ43			X86_IOAPIC1_VECTOR_BASE + 19
+#define IN_EXT_IRQ44			X86_IOAPIC1_VECTOR_BASE + 20
+#define IN_EXT_IRQ45			X86_IOAPIC1_VECTOR_BASE + 21
+#define IN_EXT_IRQ46			X86_IOAPIC1_VECTOR_BASE + 22
+#define IN_EXT_IRQ47			X86_IOAPIC1_VECTOR_BASE + 23
+
+/* level 6:   96-111 */
+
+/* third I/O APIC (88-111) */
+
+#define	X86_IOAPIC2_VECTOR_BASE		(X86_INT_VECTOR_BASE + 48)
+
+#define IN_EXT_IRQ48			X86_IOAPIC2_VECTOR_BASE + 0
+#define IN_EXT_IRQ49			X86_IOAPIC2_VECTOR_BASE + 1
+#define IN_EXT_IRQ50			X86_IOAPIC2_VECTOR_BASE + 2
+#define IN_EXT_IRQ51			X86_IOAPIC2_VECTOR_BASE + 3
+#define IN_EXT_IRQ52			X86_IOAPIC2_VECTOR_BASE + 4
+#define IN_EXT_IRQ53			X86_IOAPIC2_VECTOR_BASE + 5
+#define IN_EXT_IRQ54			X86_IOAPIC2_VECTOR_BASE + 6
+#define IN_EXT_IRQ55			X86_IOAPIC2_VECTOR_BASE + 7
+#define IN_EXT_IRQ56			X86_IOAPIC2_VECTOR_BASE + 8
+#define IN_EXT_IRQ57			X86_IOAPIC2_VECTOR_BASE + 9
+#define IN_EXT_IRQ58			X86_IOAPIC2_VECTOR_BASE + 10
+#define IN_EXT_IRQ59			X86_IOAPIC2_VECTOR_BASE + 11
+#define IN_EXT_IRQ60			X86_IOAPIC2_VECTOR_BASE + 12
+#define IN_EXT_IRQ61			X86_IOAPIC2_VECTOR_BASE + 13
+#define IN_EXT_IRQ62			X86_IOAPIC2_VECTOR_BASE + 14
+#define IN_EXT_IRQ63			X86_IOAPIC2_VECTOR_BASE + 15
+#define IN_EXT_IRQ64			X86_IOAPIC2_VECTOR_BASE + 16
+#define IN_EXT_IRQ65			X86_IOAPIC2_VECTOR_BASE + 17
+#define IN_EXT_IRQ66			X86_IOAPIC2_VECTOR_BASE + 18
+#define IN_EXT_IRQ67			X86_IOAPIC2_VECTOR_BASE + 19
+#define IN_EXT_IRQ68			X86_IOAPIC2_VECTOR_BASE + 20
+#define IN_EXT_IRQ69			X86_IOAPIC2_VECTOR_BASE + 21
+#define IN_EXT_IRQ70			X86_IOAPIC2_VECTOR_BASE + 22
+#define IN_EXT_IRQ71			X86_IOAPIC2_VECTOR_BASE + 23
+
+/* level 7:  112-127 */
+/* level 8:  128-143 */
+
+/* fourth I/O APIC (112-135) */
+
+#define	X86_IOAPIC3_VECTOR_BASE		(X86_INT_VECTOR_BASE + 72)
+
+#define IN_EXT_IRQ72			X86_IOAPIC3_VECTOR_BASE + 0
+#define IN_EXT_IRQ73			X86_IOAPIC3_VECTOR_BASE + 1
+#define IN_EXT_IRQ74			X86_IOAPIC3_VECTOR_BASE + 2
+#define IN_EXT_IRQ75			X86_IOAPIC3_VECTOR_BASE + 3
+#define IN_EXT_IRQ76			X86_IOAPIC3_VECTOR_BASE + 4
+#define IN_EXT_IRQ77			X86_IOAPIC3_VECTOR_BASE + 5
+#define IN_EXT_IRQ78			X86_IOAPIC3_VECTOR_BASE + 6
+#define IN_EXT_IRQ79			X86_IOAPIC3_VECTOR_BASE + 7
+#define IN_EXT_IRQ80			X86_IOAPIC3_VECTOR_BASE + 8
+#define IN_EXT_IRQ81			X86_IOAPIC3_VECTOR_BASE + 9
+#define IN_EXT_IRQ82			X86_IOAPIC3_VECTOR_BASE + 10
+#define IN_EXT_IRQ83			X86_IOAPIC3_VECTOR_BASE + 11
+#define IN_EXT_IRQ84			X86_IOAPIC3_VECTOR_BASE + 12
+#define IN_EXT_IRQ85			X86_IOAPIC3_VECTOR_BASE + 13
+#define IN_EXT_IRQ86			X86_IOAPIC3_VECTOR_BASE + 14
+#define IN_EXT_IRQ87			X86_IOAPIC3_VECTOR_BASE + 15
+#define IN_EXT_IRQ88			X86_IOAPIC3_VECTOR_BASE + 16
+#define IN_EXT_IRQ89			X86_IOAPIC3_VECTOR_BASE + 17
+#define IN_EXT_IRQ90			X86_IOAPIC3_VECTOR_BASE + 18
+#define IN_EXT_IRQ91			X86_IOAPIC3_VECTOR_BASE + 19
+#define IN_EXT_IRQ92			X86_IOAPIC3_VECTOR_BASE + 20
+#define IN_EXT_IRQ93			X86_IOAPIC3_VECTOR_BASE + 21
+#define IN_EXT_IRQ94			X86_IOAPIC3_VECTOR_BASE + 22
+#define IN_EXT_IRQ95			X86_IOAPIC3_VECTOR_BASE + 23
+
+/* level 9:  144-159 */
+/* level 10: 160-175 */
+
+#define IN_MSI_START			144	/* first MSI interrupt */
+#define IN_MSI_END			175	/* last MSI interrupt */
+#define IN_MSI_VTD_IRQ                  IN_MSI_END /*JWU vtd fault reporting vector */
+
+/* level 11: 176-191 */
+/* level 12: 192-207 */
+
+#define IN_IGNORE			192	/* all interrupts to ignore */
+
+/* level 13: 208-223 */
+/* level 14: 224-239 */
+
+#define IN_IPI_CORE0			224	/* cross-call start, core 0 */
+#define IN_IPI_CORE1			225	/* cross-call start, core 1 */
+#define IN_IPI_CORE2			226	/* cross-call start, core 2 */
+#define IN_IPI_CORE3			227	/* cross-call start, core 3 */
+#define IN_IPI_CORE4			228	/* cross-call start, core 4 */
+#define IN_IPI_CORE5			229	/* cross-call start, core 5 */
+#define IN_IPI_CORE6			230	/* cross-call start, core 6 */
+#define IN_IPI_CORE7			231	/* cross-call start, core 7 */
+#define IN_IPI_CORE8			232	/* cross-call start, core 8 */
+#define IN_IPI_CORE9			233	/* cross-call start, core 9 */
+#define IN_IPI_CORE10			234	/* cross-call start, core 10 */
+#define IN_IPI_CORE11			235	/* cross-call start, core 11 */
+#define IN_IPI_CORE12			236	/* cross-call start, core 12 */
+#define IN_IPI_CORE13			237	/* cross-call start, core 13 */
+#define IN_IPI_CORE14			238	/* cross-call start, core 14 */
+#define IN_IPI_CORE15			239	/* cross-call start, core 15 */
+
+/* level 15: 240-255 */
+
+#define IN_IPI_DONE_CORE0		240	/* cross-call done, core 0 */
+#define IN_IPI_DONE_CORE1		241	/* cross-call done, core 1 */
+#define IN_IPI_DONE_CORE2		242	/* cross-call done, core 2 */
+#define IN_IPI_DONE_CORE3		243	/* cross-call done, core 3 */
+#define IN_IPI_DONE_CORE4		244	/* cross-call done, core 4 */
+#define IN_IPI_DONE_CORE5		245	/* cross-call done, core 5 */
+#define IN_IPI_DONE_CORE6		246	/* cross-call done, core 6 */
+#define IN_IPI_DONE_CORE7		247	/* cross-call done, core 7 */
+#define IN_IPI_DONE_CORE8		248	/* cross-call done, core 8 */
+#define IN_IPI_DONE_CORE9		249	/* cross-call done, core 9 */
+#define IN_IPI_DONE_CORE10		250	/* cross-call done, core 10 */
+#define IN_IPI_DONE_CORE11		251	/* cross-call done, core 11 */
+#define IN_IPI_DONE_CORE12		252	/* cross-call done, core 12 */
+#define IN_IPI_DONE_CORE13		253	/* cross-call done, core 13 */
+#define IN_IPI_DONE_CORE14		254	/* cross-call done, core 14 */
+#define IN_IPI_DONE_CORE15		255	/* cross-call done, core 15 */
+
+#define OUT_VIRTUAL_IRQ_START		300	/* base of virtual devices IRQ's */
+
+/* VT-x defines */
+
+#define	VMXON_REGION_NPAGES	1	/* number of 4KB pages for VMXON */
+#define	VMCS_REGION_NPAGES	1	/* number of 4KB pages for VMCS */
+
+/* network <-> host translations (for use by romfs) */
+
+#define ntohl(x)        ((((x) & 0x000000ff) << 24) | \
+                         (((x) & 0x0000ff00) <<  8) | \
+                         (((x) & 0x00ff0000) >>  8) | \
+                         (((x) & 0xff000000) >> 24))
+
+#define htonl(x)        ((((x) & 0x000000ff) << 24) | \
+                         (((x) & 0x0000ff00) <<  8) | \
+                         (((x) & 0x00ff0000) >>  8) | \
+                         (((x) & 0xff000000) >> 24))
+
+#define ntohs(x)        ((((x) & 0x00ff) << 8) | \
+                         (((x) & 0xff00) >> 8))
+
+#define htons(x)        ((((x) & 0x00ff) << 8) | \
+                         (((x) & 0xff00) >> 8))
+
+/* context virtual address start for the VB */
+
+#define CTX_VADDR_START 		0x0
+#define ARCH_VB_VMEM_ALIGN 		0x0
+#define ARCH_SUPERVISOR_SUPPORTED 	0
+
+/* macros for cpu core information */
+
+#define isCpuCoreAlive(x)\
+			(cpu_state[x].state == CPU_STATE_ONLINE ? 1 : 0)
+
+#define isCpuCorePresent(x)\
+			((x) < HY_MAX_CPU ? \
+			(cpuCoreMapping[x].present ? isCpuCoreAlive(x) : 0) : 0)
+
+/* macro which maps the numerical core id to the arch specific id */
+
+#define cpuCoreId(x)	     cpuCoreMapping[x].apicId
+
+/* macro which determines which interrupt to use when sending to core "x" */
+
+#define cpuCoreIpiNum(x)     (IN_IPI_CORE0 + cpuId)
+
+/* macro which determines which interrupt to use when done core "x" requests */
+
+#define cpuCoreIpiDoneNum(x) (IN_IPI_DONE_CORE0 + cpuId)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCx86Archh */
diff --git a/include/vbi/support/sys/x86/asm.h b/include/vbi/support/sys/x86/asm.h
new file mode 100644
index 0000000..c550441
--- /dev/null
+++ b/include/vbi/support/sys/x86/asm.h
@@ -0,0 +1,147 @@
+/* sys/x86/asm.h - x86 tool dependent headers */
+
+/*
+ * Copyright 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,06aug09,md   add 64-bit support
+01a,04oct07,md   written from VxWorks asmI86.h version 01n
+*/
+
+#ifndef __INCsysX86Asmh
+#define __INCsysX86Asmh
+
+/*
+ * The following definitions are used for symbol name compatibility.
+ * 
+ * When #if 1, sources are assembled assuming the compiler
+ * you are using does not generate global symbols prefixed by "_".
+ * (e.g. elf/dwarf)
+ * 
+ * When #if 0, sources are assembled assuming the compiler
+ * you are using generates global symbols prefixed by "_".
+ * (e.g. coff/stabs)
+ */
+
+#if	TRUE
+#define FUNC(sym)		sym
+#define FUNC_LABEL(sym)		sym:
+#else
+#define FUNC(sym)		_##sym
+#define FUNC_LABEL(sym)		_##sym:
+#endif
+
+#define VAR(sym)		FUNC(sym)
+
+/*
+ * These macros are used to declare assembly language symbols that need
+ * to be typed properly(func or data) to be visible to the OMF tool.  
+ * So that the build tool could mark them as an entry point to be linked
+ * correctly.  This is an elfism. Use #if 0 for a.out.
+ */
+
+#if	TRUE
+#define GTEXT(sym) FUNC(sym) ;  .type   FUNC(sym),@function
+#define GDATA(sym) FUNC(sym) ;  .type   FUNC(sym),@object
+#else
+#define GTEXT(sym) FUNC(sym)
+#define GDATA(sym) FUNC(sym)
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LP64
+/* x86-64 ABI */
+#define INTARG1_64 %rdi
+#define INTARG2_64 %rsi
+#define INTARG3_64 %rdx
+#define INTARG4_64 %rcx
+#define INTARG5_64 %r8
+#define INTARG6_64 %r9
+
+#define INTARG1_32 %edi
+#define INTARG2_32 %esi
+#define INTARG3_32 %edx
+#define INTARG4_32 %ecx
+#define INTARG5_32 %r8d
+#define INTARG6_32 %r9d
+
+#define INTARG1_16 %di
+#define INTARG2_16 %si
+#define INTARG3_16 %dx
+#define INTARG4_16 %cx
+
+#define INTRET1	%rax
+#define INTRET2	%rdx
+
+/* these should not be used by x86-64 ABI-compliant code */
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG2		8
+#define SP_ARG3		12
+
+#else
+/* fp offsets to arguments */
+
+#define ARG1	8
+#define ARG1W	10
+#define ARG2	12
+#define ARG2W	14
+#define ARG3	16
+#define ARG3W	18
+#define ARG4	20
+#define ARG5	24
+#define ARG6	28
+#define ARG7	32
+#define ARG8	36
+#define ARG9	40
+#define ARG10	44
+#define ARG11	48
+#define ARG12	52
+
+#define DARG1	8		/* double arguments */
+#define	DARG1L	12
+#define DARG2	16
+#define DARG2L	20
+#define DARG3	24
+#define DARG3L	28
+#define DARG4	32
+#define DARG4L	36
+
+/* sp offsets to arguments */
+
+#define SP_ARG0		0
+#define SP_ARG1		4
+#define SP_ARG1W	6
+#define SP_ARG2		8
+#define SP_ARG2W	10
+#define SP_ARG3		12
+#define SP_ARG3W	14
+#define SP_ARG4		16
+#define SP_ARG5		20
+#define SP_ARG6		24
+#define SP_ARG7		28
+#define SP_ARG8		32
+#define SP_ARG9		36
+#define SP_ARG10	40
+#define SP_ARG11	44
+#define SP_ARG12	48
+#endif
+
+#define _WRS_ASM(x) __asm volatile (x)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCsysX86Asmh */
diff --git a/include/vbi/support/sys/x86/regs.h b/include/vbi/support/sys/x86/regs.h
new file mode 100644
index 0000000..89264ac
--- /dev/null
+++ b/include/vbi/support/sys/x86/regs.h
@@ -0,0 +1,1957 @@
+/* sys/x86/regs.h - x86 cpu registers */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute or otherwise make use of this software
+ * may be licensed only pursuant to the terms of an applicable Wind River
+ * license agreement. 
+*/
+
+/*
+modification history
+--------------------
+01z,14sep09,md   add new processor bit definition
+01y,31aug09,mmi  move VBI_HREG_SET to vbiX86Arch.h
+01x,14aug09,md   adjust VBI_HREG_SET
+01w,29jul09,mpk  add VBI_HREG_SET for supporting register read, write
+01v,16jul09,dbt  fixed registers offset
+01u,17jun09,dbt  added 64-bit support, clean up IDT support
+01t,26sep08,md   add IDT entry definitions
+01s,18aug08,md   add new cpuid features
+01r,07aug08,md   add cpuid cache query defines
+01q,30jul08,md   add cpuid signature defines
+01p,18jun08,md   add VT-x2 MSR's
+01o,24mar08,md   add IA32_PERF_STAT MSR and MSR_FSB_FREQ
+01n,14mar08,md   add x86GetCpuid
+01m,12mar08,md   add MSR_VMX_PROCBASED_CTLS2_MSR
+01l,22feb08,md   add APIC support
+01k,15feb08,md   add some VT-x specific SPR's
+01j,04feb08,md   add additional register get functions
+01i,21jan08,md   add vt defines
+01h,03oct07,md   renamed REG_SET to HREG_SET
+01g,02sep07,md   added IDT definitions
+01f,30aug07,md   added call gate specifications
+01e,08aug07,md   add defines for segment priv levels
+01d,07aug07,md   changed use of u_int to uint32_t
+01c,31jul07,md   added additional GDT definitions
+01b,25jul07,md   added cr registers to REG_SET, added GDT & GDTR struct
+01a,16jul07,md   written based on VxWorks 01w version
+*/
+
+#ifndef	__INCx86regsh
+#define	__INCx86regsh
+
+#ifdef CONFIG_WRHV
+#else
+#include <sys/types.h>
+#endif /* CONFIG_WRHV */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IO_BMAP_SIZE	32	/* IO bitmap for port 0x000 - 0x3ff */
+
+#ifndef	_ASMLANGUAGE
+
+#ifdef LP64
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    _RType   rax;		/* 00: general register		*/
+    _RType   rbx;		/* 08: general register		*/
+    _RType   rcx;		/* 10: general register		*/
+    _RType   rdx;		/* 18: general register		*/
+    _RType   rsp;		/* 20: stack pointer register	*/
+    _RType   rbp;		/* 28: frame pointer register	*/
+    _RType   rsi;		/* 30: general register		*/
+    _RType   rdi;		/* 38: general register		*/
+    _RType   r8;	 	/* 40: general register		*/
+    _RType   r9;	 	/* 48: general register		*/
+    _RType   r10;		/* 50: general register		*/
+    _RType   r11;		/* 58: general register		*/
+    _RType   r12;		/* 60: general register		*/
+    _RType   r13;		/* 68: general register		*/
+    _RType   r14;		/* 70: general register		*/
+    _RType   r15;		/* 78: general register		*/
+    INSTR   *pc;		/* 80: program counter		*/
+    _RType   flags;		/* 88: status register		*/
+    _RType   cr0;		/* 90: control register 0	*/
+    _RType   cr2;		/* 98: control register 2	*/
+    _RType   cr3;		/* 100: control register 3	*/
+    _RType   cr4;		/* 108: control register 4	*/
+    uint64_t tsp;		/* 110: transition stack pointer*/
+    uint16_t cs;		/* 118: code segment		*/
+    uint16_t ds;		/* 11A: data segment		*/
+    uint16_t ss;		/* 11C: stack segment		*/
+    uint16_t es;		/* 11E: E segment		*/
+    uint16_t fs;		/* 120: F segment		*/
+    uint16_t gs;		/* 122: G segment		*/
+    /* xxx(gws): excluding FP support */
+    } HREG_SET;
+#else
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    uint32_t  edi;		/* 00: general register		*/
+    uint32_t  esi;		/* 04: general register		*/
+    uint32_t  ebp;		/* 08: frame pointer register	*/
+    uint32_t  esp;		/* 0C: stack pointer register	*/
+    uint32_t  ebx;		/* 10: general register		*/
+    uint32_t  edx;		/* 14: general register		*/
+    uint32_t  ecx;		/* 18: general register		*/
+    uint32_t  eax;		/* 1C: general register		*/
+    uint32_t  flags;		/* 20: status register		*/
+    INSTR    *pc;		/* 24: program counter		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr2;		/* 2C: control register 2	*/
+    uint32_t  cr3;		/* 30: control register 3	*/
+    uint32_t  cr4;		/* 34: control register 4	*/
+    uint32_t  cs;		/* 28: code segment		*/
+    uint32_t  ds;		/* 3C: data segment		*/
+    uint32_t  ss;		/* 40: stack segment		*/
+    uint32_t  es;		/* 44: E segment		*/
+    uint32_t  fs;		/* 48: F segment		*/
+    uint32_t  gs;		/* 4C: G segment		*/
+    uint32_t  tsp;		/* 50: transition stack pointer	*/
+    } HREG_SET;
+#endif
+
+typedef struct cpuid		/* CPUID - 80x86 cpuid version/feature */
+    {
+    int highestValue;		/* EAX=0: highest integer value */
+    int vendorId[3];		/* EAX=0: vendor identification string */
+    int signature;		/* EAX=1: processor signature */
+    int featuresEbx;		/* EAX=1: feature flags EBX */
+    int featuresEcx;		/* EAX=1: feature flags ECX */
+    int featuresEdx;		/* EAX=1: feature flags EDX */
+    int cacheEax;		/* EAX=2: config parameters EAX */
+    int cacheEbx;		/* EAX=2: config parameters EBX */
+    int cacheEcx;		/* EAX=2: config parameters ECX */
+    int cacheEdx;		/* EAX=2: config parameters EDX */
+    int serialNo64[2];		/* EAX=3: lower 64 of 96 bit serial no */
+    int brandString[12];	/* EAX=0x8000000[234]: brand strings */
+    } CPUID;
+
+
+/* CPUID fields in the EAX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t stepid:4;	/* processor stepping id mask	*/
+	uint32_t model:4;	/* processor model mask		*/
+	uint32_t family:4;	/* processor family mask	*/
+	uint32_t type:2;	/* processor type mask		*/
+	uint32_t reserved1:2;
+	uint32_t modelExt:4;	/* processor extended model mask */
+	uint32_t familyExt:8;	/* processor extended family mask */
+	uint32_t reserved2:4;
+	} field;
+    uint32_t value;
+    } CPUID_VERSION;
+
+#define CPUID_TYPE_ORIG		 0	/* type: original OEM		*/
+#define CPUID_TYPE_OVERD	 1	/* type: overdrive		*/
+#define CPUID_TYPE_DUAL		 2	/* type: dual			*/
+
+#define CPUID_FAMILY_486	 4	/* family: 486			*/
+#define CPUID_FAMILY_PENTIUM	 5	/* family: Pentium		*/
+#define CPUID_FAMILY_PENTIUMPRO  6	/* family: Pentium PRO		*/
+#define CPUID_FAMILY_EXTENDED	15	/* family: Extended		*/
+#define CPUID_FAMILY_PENTIUM4	 0	/* extended family: PENTIUM4	*/
+
+/* Pentium PRO family models */
+
+#define CPUID_MODEL_PPRO 	 1 	/* model: Pentium Pro		*/
+#define CPUID_MODEL_P2_OVER 	 2 	/* model: Pentium II Overdrive	*/
+#define CPUID_MODEL_P2_03 	 3 	/* model: Pentium II, model 03	*/
+#define CPUID_MODEL_P2_05 	 5 	/* model: Pentium II, model 05	*/
+#define CPUID_MODEL_CELERON_06 	 6 	/* model: Celeron, model 06	*/
+#define CPUID_MODEL_P3_07 	 7 	/* model: Pentium III, model 07	*/
+#define CPUID_MODEL_CORE2_E 	 7 	/* model: Core2 Extreme		*/
+#define CPUID_MODEL_P3_08 	 8 	/* model: Pentium III, model 08	*/
+#define CPUID_MODEL_PENTIUM_M 	 9 	/* model: Pentium M		*/
+#define CPUID_MODEL_P3_XEON	10 	/* model: Pentium III Xeon 	*/
+#define CPUID_MODEL_P3_0B 	11 	/* model: Pentium III, model 0B	*/
+#define CPUID_MODEL_PENTIUMM_0D	13 	/* model: Pentium M, model 0D	*/
+#define CPUID_MODEL_CORE 	14 	/* model: Core Duo/Solo		*/
+#define CPUID_MODEL_CORE2	15	/* model: Core2 Duo/Quad/Xeon	*/
+
+
+/* CPUID fields in the EBX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t brand:8;	/* Brand index			*/
+	uint32_t flushSize:8;	/* CLFLUSH line size		*/
+	uint32_t nproc:8;	/* number of local processors	*/
+	uint32_t apicId:8;	/* local APIC id		*/
+	} field;
+    uint32_t value;
+    } CPUID_INFO;
+
+/* CPUID fields in the EDX register when EAX=1 */
+
+/* CPUID: feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t fpu:1;		/* FPU on chip			*/
+	uint32_t vme:1;		/* virtual 8086 mode enhancement*/
+	uint32_t de:1;		/* debugging extensions		*/
+	uint32_t pse:1;		/* page size extension		*/
+	uint32_t tsc:1;		/* time stamp counter		*/
+	uint32_t msr:1;		/* RDMSR and WRMSR support	*/
+	uint32_t pae:1;		/* physical address extensions	*/
+	uint32_t mce:1;		/* machine check exception	*/
+	uint32_t cx8:1;		/* CMPXCHG8 inst		*/
+	uint32_t apic:1;	/* APIC on chip			*/
+	uint32_t reserved1:1;
+	uint32_t sep:1;		/* SEP, Fast System Call	*/
+	uint32_t mtrr:1;	/* MTRR				*/
+	uint32_t pge:1;		/* PTE global bit		*/
+	uint32_t mca:1;		/* machine check arch.		*/
+	uint32_t cmov:1;	/* cond. move/cmp. inst		*/
+	uint32_t pat:1;		/* page attribute table		*/
+	uint32_t pse36:1;	/* 36 bit page size extension	*/
+	uint32_t psnum:1;	/* processor serial number	*/
+	uint32_t clflush:1;	/* CLFLUSH inst supported	*/
+	uint32_t reserved2:1;
+	uint32_t dts:1;		/* Debug Store			*/
+	uint32_t acpi:1;	/* TM and SCC supported		*/
+	uint32_t mmx:1;		/* MMX technology supported	*/
+	uint32_t fxsr:1;	/* fast FP save and restore	*/
+	uint32_t sse:1;		/* SSE supported		*/
+	uint32_t sse2:1;	/* SSE2 supported		*/
+	uint32_t ss:1;		/* Self Snoop supported		*/
+	uint32_t htt:1;		/* Hyper Threading Technology   */
+	uint32_t tm:1;		/* Thermal Monitor supported	*/
+	uint32_t ia64:1;	/* IA64 Capabilities		*/
+	uint32_t pbe:1;		/* Pend break enable		*/
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES;
+
+
+/* fields in the ECX register when EAX=1 */
+
+/* CPUID: extended feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t sse3:1;	/* SSE3 Extensions		*/
+	uint32_t reserved1:1;
+	uint32_t dtes64:1;	/* 64-bit Debug Store		*/
+	uint32_t mon:1;		/* Monitor/wait			*/
+	uint32_t ds_cpl:1;	/* CPL qualified Debug Store	*/
+	uint32_t vmx:1;		/* Virtual Machine Technology	*/
+	uint32_t smx:1;		/* Safer Mode Extensions	*/
+	uint32_t est:1;		/* Enhanced Speedstep Technology*/
+	uint32_t tm2:1;		/* Thermal Monitor 2 supported	*/
+	uint32_t ssse3:1;	/* SSSE3 Extensions		*/
+	uint32_t cid:1;		/* L1 context ID		*/
+	uint32_t reserved2:2;
+	uint32_t cx16:1;	/* CMPXCHG16B			*/
+	uint32_t xtpr:1;	/* Update control		*/
+	uint32_t pdcm:1;	/* Performance/Debug capability	*/
+	uint32_t reserved3:2;
+	uint32_t dca:1;		/* Direct Cache Access		*/
+	uint32_t sse41:1;	/* SIMD Extensions 4.1		*/
+	uint32_t sse42:1;	/* SIMD Extensions 4.2		*/
+	uint32_t x2apic:1;	/* x2APIC supported		*/
+	uint32_t movbe:1;	/* MOVBE instruction supported	*/
+	uint32_t popcnt:1;	/* POPCNT instruction supported	*/
+	uint32_t reserved4:1;
+	uint32_t aes:1;		/* AES instruction supported	*/
+	uint32_t xsave:1;	/* XSAVE states supported	*/
+	uint32_t osxsave:1;	/* extended state management	*/
+	uint32_t reserved5:4;
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES_EXT;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=4 */
+
+/* CPUID: deterministic cache parameters definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t type:5;	/* Cache type			*/
+	uint32_t level:3;	/* Cache level			*/
+	uint32_t self_init:1;	/* Self initialising cache	*/
+	uint32_t associative:1;	/* Fully associate cache	*/
+	uint32_t reserved1:4;
+	uint32_t threads:12;	/* Max threads sharing cache	*/
+	uint32_t proc:6;	/* Max processor cores per pkg	*/
+
+	/* EBX */
+
+	uint32_t cline_size:12;	/* Coherency line size		*/
+	uint32_t pline_size:10;	/* Physical line size		*/
+	uint32_t way:10;	/* Ways of associativity	*/
+
+	/* ECX */
+
+	uint32_t sets:32;	/* Number of sets		*/
+
+	/* EDX */
+
+	uint32_t stride:10;	/* Prefetch stride		*/
+	uint32_t reserved2:22;
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_CACHE;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=11 */
+
+/* CPUID: x2APIC features / processor topology parameter definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t apic_r_shift:5; /* number of bits to shift right */
+	uint32_t reserved1:27;
+
+	/* EBX */
+
+	uint32_t logical_proc:16; /* number of logical processor  */
+	uint32_t reserved2:16;
+
+	/* ECX */
+
+	uint32_t level:8;	 /* level number		   */
+	uint32_t type:8;	 /* level type			   */
+	uint32_t reserved3:16;
+
+	/* EDX */
+
+	uint32_t ext_apic_id;	/* extended APIC id		    */
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_X2APIC;
+
+/* MSR_VMX_EPT_VPID_CAP: EPT and VPID Capabilities MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t rwx_support:3;	/* R W X support	*/
+	uint32_t gaw_support:5;	/* GAW support		*/
+	uint32_t emt_support:8;	/* EMT support		*/
+	uint32_t sp_support:4;	/* SP support		*/
+	uint32_t invept:1;	/* INVEPT supported	*/
+	uint32_t reserved1:3;
+	uint32_t invept_cap:8;	/* INVEPT capabilities	*/
+	uint32_t invpid:1;	/* INVPID supported	*/
+	uint32_t reserved2:7;
+	uint32_t invpid_cap:8;	/* INVPID capabilities	*/
+	uint32_t reserved3:16;
+	} field;
+    uint64_t value;
+    } EPT_VPID_CAP_MSR;
+
+typedef struct mtrr_fix		/* MTRR - fixed range register */
+    {
+    char type[8];
+    } MTRR_FIX;
+
+typedef struct mtrr_var		/* MTRR - variable range register */
+    {
+    long long int base;
+    long long int mask;
+    } MTRR_VAR;
+
+typedef struct mtrr		/* MTRR */
+    {
+    int cap[2];			/* MTRR cap register */
+    int deftype[2];		/* MTRR defType register */
+    MTRR_FIX fix[11];		/* MTRR fixed range registers */
+    MTRR_VAR var[8];		/* MTRR variable range registers */
+    } MTRR;
+
+typedef MTRR *		MTRR_ID;
+
+/*
+ * Structure of a global descriptor table (GDT) entry
+ * (common to 32 & 64 bits)
+ */
+
+typedef struct gdt_entry
+    {
+    uint16_t	limit00;	/* limit: xffff			*/
+    uint16_t	base00;		/* base : xxxx0000		*/
+    uint8_t	base01;		/* base : xx00xxxx		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint8_t	limit01:4;	/* limit: fxxxx			*/
+    uint8_t	free:1;		/* free bit			*/
+    uint8_t	l:1;		/* 64-bit code segment		*/
+    uint8_t	d_b:1;		/* access 0=16-bit 1=32-bit	*/
+    uint8_t	g:1;		/* page granularity		*/
+    uint8_t	base02;		/* base : 00xxxxxx		*/
+    } GDT_ENTRY;
+
+/* Structure of global descriptor table call entry in 32-bits mode */
+
+typedef struct gdt32_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	nparam:5;	/* number of parameters		*/
+    uint8_t	res1:3;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } GDT32_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 32-bits mode */
+
+typedef struct idt32_entry
+    {
+    uint16_t	offset00;	/* offset : xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes) */
+    uint8_t	type:5;		/* Code e/r,			*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } IDT32_ENTRY;
+
+#ifdef	LP64
+/* Structure of global descriptor table call entry in 64-bits mode */
+
+typedef struct gdt64_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } GDT64_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 64-bits mode */
+
+typedef struct idt64_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	ist:3;		/* interrupt stack table	*/
+    uint8_t	res1:5;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	res2:1;		/* reserved (zeroes)		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } IDT64_ENTRY;
+
+#define	GDT_CALL_ENTRY		GDT64_CALL_ENTRY
+#define	IDT_ENTRY		IDT64_ENTRY
+#else
+#define	GDT_CALL_ENTRY		GDT32_CALL_ENTRY
+#define	IDT_ENTRY		IDT32_ENTRY
+#endif	/* LP64 */
+
+
+#define	GDT_BASE00_SHIFT	00
+#define	GDT_BASE01_SHIFT	16
+#define	GDT_BASE02_SHIFT	24
+#define	GDT_BASE00_MASK		0x0000ffff
+#define	GDT_BASE01_MASK		0x00ff0000
+#define	GDT_BASE02_MASK		0xff000000
+
+#define	GDT_LIMIT00_SHIFT	00
+#define	GDT_LIMIT01_SHIFT	16
+#define	GDT_LIMIT00_MASK	0x0ffff
+#define	GDT_LIMIT01_MASK	0xf0000
+
+#define	GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
+			 (p->base01 << GDT_BASE01_SHIFT) | p->base00)
+#define	GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
+
+#define GDT_LIMIT00(v)	(((v) & GDT_LIMIT00_MASK) >> GDT_LIMIT00_SHIFT)
+#define GDT_LIMIT01(v)	(((v) & GDT_LIMIT01_MASK) >> GDT_LIMIT01_SHIFT)
+
+#define GDT_BASE00(v)	(((v) & GDT_BASE00_MASK) >> GDT_BASE00_SHIFT)
+#define GDT_BASE01(v)	(((v) & GDT_BASE01_MASK) >> GDT_BASE01_SHIFT)
+#define GDT_BASE02(v)	(((v) & GDT_BASE02_MASK) >> GDT_BASE02_SHIFT)
+
+/* GDT call entry macros */
+
+#define	GDT32_OFFSET00_SHIFT	00
+#define	GDT32_OFFSET01_SHIFT	16
+#define	GDT32_OFFSET00_MASK	0x0000ffff
+#define	GDT32_OFFSET01_MASK	0xffff0000
+
+#define	GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT32_OFFSET00(v)	(((v) & GDT32_OFFSET00_MASK) >> \
+				 GDT32_OFFSET00_SHIFT)
+#define GDT32_OFFSET01(v)	(((v) & GDT32_OFFSET01_MASK) >> \
+				 GDT32_OFFSET01_SHIFT)
+
+#ifdef	LP64
+#define	GDT64_OFFSET00_SHIFT	00
+#define	GDT64_OFFSET01_SHIFT	16
+#define	GDT64_OFFSET02_SHIFT	32
+#define	GDT64_OFFSET00_MASK	0x000000000000ffff
+#define	GDT64_OFFSET01_MASK	0x00000000ffff0000
+
+#define	GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
+					GDT64_OFFSET02_SHIFT) | \
+				 (p->offset01 << GDT64_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT64_OFFSET00(v)	((uint16_t)((((v) & GDT64_OFFSET00_MASK) >> \
+					    GDT64_OFFSET00_SHIFT)))
+#define GDT64_OFFSET01(v)	((uint16_t)((((v) & GDT64_OFFSET01_MASK) >> \
+					    GDT64_OFFSET01_SHIFT)))
+#define GDT64_OFFSET02(v)	((uint32_t)(((v) >> GDT64_OFFSET02_SHIFT)))
+
+#define	GDT_OFFSET		GDT64_OFFSET
+#define	GDT_OFFSET00		GDT64_OFFSET00
+#define	GDT_OFFSET01		GDT64_OFFSET01
+#define	GDT_OFFSET02		GDT64_OFFSET02
+#else	/* LP64 */
+#define	GDT_OFFSET		GDT32_OFFSET
+#define	GDT_OFFSET00		GDT32_OFFSET00
+#define	GDT_OFFSET01		GDT32_OFFSET01
+#endif
+
+/* IDT aliases */
+
+#define	IDT32_OFFSET(x)		GDT32_OFFSET(x)
+#define	IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
+#define	IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
+
+#ifdef	LP64
+#define	IDT64_OFFSET(x)		GDT64_OFFSET(x)
+#define	IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
+#define	IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
+#define	IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
+
+#define	IDT_OFFSET		IDT64_OFFSET
+#define	IDT_OFFSET00		IDT64_OFFSET00
+#define	IDT_OFFSET01		IDT64_OFFSET01
+#define	IDT_OFFSET02		IDT64_OFFSET02
+#else	/* LP64 */
+#define	IDT_OFFSET		IDT32_OFFSET
+#define	IDT_OFFSET00		IDT32_OFFSET00
+#define	IDT_OFFSET01		IDT32_OFFSET01
+#define	IDT_OFFSET02		IDT32_OFFSET02
+#endif	/* LP64 */
+
+/* GDT data segment types */
+
+#define	GDT_TYPE_RO		0	/* read-only			   */
+#define	GDT_TYPE_RO_A		1	/* read-only accessed		   */
+#define	GDT_TYPE_RW		2	/* read-write			   */
+#define	GDT_TYPE_RW_A		3	/* read-write accessed		   */
+#define	GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
+#define	GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
+#define	GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
+#define	GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
+#define	GDT_TYPE_EX		8	/* execute			   */
+#define	GDT_TYPE_EX_A		9	/* execute accessed		   */
+#define	GDT_TYPE_EX_RO		10	/* execute read-only		   */
+#define	GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
+#define	GDT_TYPE_EX_CF		12	/* execute conforming		   */
+#define	GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
+#define	GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
+#define	GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
+
+/* GDT system segment types */
+
+#ifndef	LP64
+#define	GDT_TYPE_SYS_RES0	0	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT_TYPE_SYS_RES1	8	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_RES2	10	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT_TYPE_SYS_RES3	13	/* reserved			   */
+#define	GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#else	/* !LP64 */
+#define	GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS64_A	9	/* 64 bit TSS (available)	   */
+#define GDT_TYPE_SYS_TSS64_B	11	/* 64 bit TSS (busy)	           */
+#define	GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
+#define	GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
+#endif	/* !LP64 */
+/* GDT segment status */
+
+#define	GDT_SEG_INVALID		0	/* segment is not present	   */
+#define	GDT_SEG_VALID		1	/* segment is present		   */
+
+/* GDT segment type */
+
+#define	GDT_SEG_SYSTEM		0	/* system type segment 		   */
+#define	GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* GDT access types */
+
+#define	GDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	GDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* GDT access types */
+
+#define	GDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* GDT access types */
+
+#define GDT_64_CODE_SEGMENT	1	/* 64-bit code segment		   */
+#define GDT_COMP_CODE_SEGMENT	0	/* compatible mode code segment	   */
+
+/* GDT privilidge level */
+
+#define	GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
+#define	GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* IDT segment types */
+
+#define	IDT_TYPE_RES0		0	/* reserved			   */
+#define	IDT_TYPE_RES1		1	/* reserved			   */
+#define	IDT_TYPE_RES2		2	/* reserved			   */
+#define	IDT_TYPE_RES3		3	/* reserved			   */
+#define	IDT_TYPE_RES4		4	/* reserved			   */
+#define	IDT_TYPE_TGATE		5	/* task gate			   */
+#define	IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
+#define	IDT_TYPE_RES8		8	/* reserved			   */
+#define	IDT_TYPE_RES9		9	/* reserved			   */
+#define	IDT_TYPE_RES10		10	/* reserved			   */
+#define	IDT_TYPE_RES11		11	/* reserved			   */
+#define	IDT_TYPE_RES12		12	/* reserved			   */
+#define	IDT_TYPE_RES13		13	/* reserved			   */
+#define	IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
+
+/* IDT segment status */
+
+#define	IDT_SEG_INVALID		0	/* segment is not present	   */
+#define	IDT_SEG_VALID		1	/* segment is present		   */
+
+/* IDT segment type */
+
+#define	IDT_SEG_SYSTEM		0	/* system type segment 		   */
+#define	IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* IDT access types */
+
+#define	IDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	IDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* IDT access types */
+
+#define	IDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* IDT privilidge level */
+
+#define	IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* structure of the global descriptor table register (GDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct 
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } GDTR32;
+
+#define	GDTR32_ADDR00_SHIFT	00
+#define	GDTR32_ADDR01_SHIFT	16
+#define	GDTR32_ADDR00_MASK	0x0000ffff
+#define	GDTR32_ADDR01_MASK	0xffff0000
+
+#define	GDTR32_ADDR(reg)	((reg.field.addr1 << GDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct 
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } GDTR64;
+
+#define	GDTR64_ADDR00_SHIFT	00
+#define	GDTR64_ADDR01_SHIFT	16	
+#define	GDTR64_ADDR02_SHIFT	32	
+#define	GDTR64_ADDR03_SHIFT	48	
+#define	GDTR64_ADDR00_MASK	0x000000000000ffff
+#define	GDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	GDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	GDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	GDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					GDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+				 	GDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+				 	GDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	GDTR			GDTR64
+#define	GDTR_ADDR00_SHIFT	GDTR64_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR64_ADDR01_SHIFT
+#define	GDTR_ADDR02_SHIFT	GDTR64_ADDR02_SHIFT
+#define	GDTR_ADDR03_SHIFT	GDTR64_ADDR03_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR64_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR64_ADDR01_MASK
+#define	GDTR_ADDR02_MASK	GDTR64_ADDR02_MASK
+#define	GDTR_ADDR03_MASK	GDTR64_ADDR03_MASK
+#define	GDTR_ADDR		GDTR64_ADDR
+#define	GDTR_LIMIT		GDTR64_LIMIT
+#else	/* LP64 */
+#define	GDTR			GDTR32
+#define	GDTR_ADDR00_SHIFT	GDTR32_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR32_ADDR01_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR32_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR32_ADDR01_MASK
+#define	GDTR_ADDR		GDTR32_ADDR
+#define	GDTR_LIMIT		GDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the interrupt descriptor table register (IDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct 
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } IDTR32;
+
+#define	IDTR32_ADDR00_SHIFT	00
+#define	IDTR32_ADDR01_SHIFT	16
+#define	IDTR32_ADDR00_MASK	0x0000ffff
+#define	IDTR32_ADDR01_MASK	0xffff0000
+
+#define	IDTR32_ADDR(reg)	((reg.field.addr1 << IDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct 
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } IDTR64;
+
+#define	IDTR64_ADDR00_SHIFT	00
+#define	IDTR64_ADDR01_SHIFT	16	
+#define	IDTR64_ADDR02_SHIFT	32	
+#define	IDTR64_ADDR03_SHIFT	48	
+#define	IDTR64_ADDR00_MASK	0x000000000000ffff
+#define	IDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	IDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	IDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	IDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					IDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+				 	IDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+				 	IDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	IDTR			IDTR64
+#define	IDTR_ADDR00_SHIFT	IDTR64_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR64_ADDR01_SHIFT
+#define	IDTR_ADDR02_SHIFT	IDTR64_ADDR02_SHIFT
+#define	IDTR_ADDR03_SHIFT	IDTR64_ADDR03_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR64_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR64_ADDR01_MASK
+#define	IDTR_ADDR02_MASK	IDTR64_ADDR02_MASK
+#define	IDTR_ADDR03_MASK	IDTR64_ADDR03_MASK
+#define	IDTR_ADDR		IDTR64_ADDR
+#define	IDTR_LIMIT		IDTR64_LIMIT
+#else	/* LP64 */
+#define	IDTR			IDTR32
+#define	IDTR_ADDR00_SHIFT	IDTR32_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR32_ADDR01_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR32_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR32_ADDR01_MASK
+#define	IDTR_ADDR		IDTR32_ADDR
+#define	IDTR_LIMIT		IDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the local descriptor table register (LDTR) */
+
+typedef uint32_t LDTR;
+
+/* x86 Task State Segment (TSS) */
+
+typedef struct tss
+    {
+#ifdef LP64
+    uint32_t  reserved0;	/* reserved */
+    uint64_t  rsp0;		/* privilege level 0 SP */
+    uint64_t  rsp1;		/* privilege level 1 SP */
+    uint64_t  rsp2;		/* privilege level 2 SP */
+    uint64_t  reserved1;	/* reserved */
+    uint64_t  ist1;		/* interrupt stack table ptr */
+    uint64_t  ist2;		/* interrupt stack table ptr */
+    uint64_t  ist3;		/* interrupt stack table ptr */
+    uint64_t  ist4;		/* interrupt stack table ptr */
+    uint64_t  ist5;		/* interrupt stack table ptr */
+    uint64_t  ist6;		/* interrupt stack table ptr */
+    uint64_t  ist7;		/* interrupt stack table ptr */
+    uint64_t  reserved2;	/* reserved */
+    uint16_t  reserved3;	/* reserved */
+    uint16_t  iomapb;		/* IO map base offset */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+#else
+    uint16_t  link;		/* link to previous task */
+    uint16_t  reserved0;	/* reserved */
+    uint32_t  esp0;		/* privilege level 0 SP */
+    uint16_t  ss0;		/*   ''              SS */
+    uint16_t  reserved1;	/* reserved */
+    uint32_t  esp1;		/* privilege level 1 SP */
+    uint16_t  ss1;		/*   ''              SS */
+    uint16_t  reserved3;	/* reserved */
+    uint32_t  esp2;		/* privilege level 2 SP */
+    uint16_t  ss2;		/*   ''              SS */
+    uint16_t  reserved4;	/* reserved */
+    uint32_t  cr3;		/* control register CR3 */
+    INSTR    *eip;		/* program counter  EIP */
+    uint32_t  eflags;		/* status register  EFLAGS */
+    uint32_t  eax;		/* general register EAX */
+    uint32_t  ecx;		/* general register ECX */
+    uint32_t  edx;		/* general register EDX */
+    uint32_t  ebx;		/* general register EBX */
+    uint32_t  esp;		/* stack pointer register ESP */
+    uint32_t  ebp;		/* frame pointer register EBP */
+    uint32_t  esi;		/* general register ESI */
+    uint32_t  edi;		/* general register EDI */
+    uint16_t  es;		/* segment selector ES */
+    uint16_t  reserved5;	/* reserved */
+    uint16_t  cs;		/* segment selector CS */
+    uint16_t  reserved6;	/* reserved */
+    uint16_t  ss;		/* segment selector SS */
+    uint16_t  reserved7;	/* reserved */
+    uint16_t  ds;		/* segment selector DS */
+    uint16_t  reserved8;	/* reserved */
+    uint16_t  fs;		/* segment selector FS */
+    uint16_t  reserved9;	/* reserved */
+    uint16_t  gs;		/* segment selector GS */
+    uint16_t  reserved10;	/* reserved */
+    uint16_t  ldt;		/* segment selector LDT */
+    uint16_t  reserved11;	/* reserved */
+    uint16_t  tflag;		/* debug trap flag T */
+    uint16_t  iomapb;		/* IO map base address */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+    uint32_t  reserved12;	/* TSS selector */
+    uint32_t  reserved13;
+    uint32_t  reserved14;
+    uint32_t  reserved15;
+    uint32_t  reserved16;
+    uint32_t  reserved17;
+    uint32_t  reserved18;
+    uint32_t  reserved19;
+#endif
+    } TSS;
+
+typedef struct segdesc		/* segment descriptor */
+    {
+    uint16_t	limitLW;	/* limit 15:00			*/
+    uint16_t	baseLW;		/* base address 15:00		*/
+    uint8_t	baseMB;		/* base address 23:16		*/
+    uint8_t	type;		/* P, DPL, S, Type		*/
+    uint8_t	limitUB;	/* G, DB, 0, AVL, limit 23:16	*/
+    uint8_t	baseUB;		/* base address 31:24		*/
+    } SEGDESC;
+
+typedef struct taskGate		/* task gate */
+    {
+    uint16_t    reserved1;	/* reserved1 15:00		*/
+    uint16_t    segment;	/* TSS segment selector 31:16	*/
+    uint16_t	reserved2:8;	/* reserved2 07:00		*/
+    uint8_t	type:5;		/* Type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    reserved3;      /* reserved3 31:16		*/
+    } TGATE_DESC;
+
+typedef struct callGate		/* call gate */
+    {
+    uint16_t	offsetLo;
+    uint16_t	selector;
+    uint8_t 	params;
+    uint8_t 	type;
+    uint16_t	offsetHi;
+   } CGATE_DESC;
+
+typedef struct intGate		/* interrupt gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } IGATE_DESC;
+
+#define	IGATE_OFFSET00_SHIFT	00
+#define	IGATE_OFFSET01_SHIFT	16
+#define	IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+
+typedef struct trapGate		/* trap gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } TRGATE_DESC;
+
+#define	TRGATE_OFFSET00_SHIFT	00
+#define	TRGATE_OFFSET01_SHIFT	16
+#define	TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+/* convenience structure to access 32-bit fields of a 64-bit MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t low;		/* low 32-bits of value */
+	uint32_t high;		/* high 32-bits of value */
+	} field;
+    uint64_t word;		/* 64-bit MSR value */
+    } MSR_VALUE;
+ 
+/* some common names for registers */
+
+#define fpReg		ebp	/* frame pointer */
+#define	spReg		esp	/* stack pointer */
+#define reg_pc		pc	/* program counter */
+#define reg_sp		spReg	/* stack pointer */
+#define reg_fp		fpReg	/* frame pointer */
+
+#define  G_REG_BASE	0x00	/* data reg's base offset to HREG_SET */
+#define  G_REG_OFFSET(n)	(G_REG_BASE + (n)*sizeof(uint32_t))
+#define  SR_OFFSET		G_REG_OFFSET(GREG_NUM)
+#define  PC_OFFSET		(SR_OFFSET + sizeof(uint32_t))
+
+/* register access functions */
+
+extern _RType	x86CR0Get (void);
+extern void	x86CR0Set (_RType value);
+extern _RType	x86CR2Get (void);
+extern void	x86CR2Set (_RType value);
+extern _RType	x86CR3Get (void);
+extern void	x86CR3Set (_RType value);
+extern _RType	x86CR4Get (void);
+extern void	x86CR4Set (_RType value);
+extern void	x86GdtrGet (GDTR *value);
+extern void	x86GdtrSet (GDTR *value);
+extern void	x86IdtrGet (IDTR *value);
+extern void	x86IdtrSet (IDTR *value);
+extern void	x86LdtrGet (LDTR *value);
+extern void	x86LdtrSet (LDTR *value);
+extern _RType	x86TrGet (void);
+extern void	x86TrSet (_RType value);
+extern void	x86MsrGet (uint32_t addr, uint64_t *value);
+extern void	x86MsrSet (uint32_t addr, uint64_t *value);
+extern _RType	x86FlagsGet (void);
+extern _RType	x86CsGet (void);
+extern _RType	x86SsGet (void);
+extern _RType	x86DsGet (void);
+extern _RType	x86EsGet (void);
+extern _RType	x86FsGet (void);
+extern _RType	x86GsGet (void);
+extern void	x86TscGet (uint64_t *value);
+extern void	x86GetCpuid (uint32_t operation,
+			     uint32_t *eaxValue, uint32_t *ebxValue,
+			     uint32_t *ecxValue, uint32_t *edxValue);
+
+#endif	/* _ASMLANGUAGE */
+
+/* CPU FAMILY & FPU type */
+
+#define X86CPU_386	  0	/* CPU FAMILY: 80386		*/
+#define X86CPU_486	  1	/* CPU FAMILY: 80486		*/
+#define X86CPU_PENTIUM	  2	/* CPU FAMILY: Pentium/P5	*/
+#define X86CPU_NS486	  3	/* CPU FAMILY: NS486		*/
+#define X86CPU_PENTIUMPRO 4	/* CPU FAMILY: Pentiumpro/P6	*/
+#define X86CPU_PENTIUM4   5	/* CPU FAMILY: Pentium4/P7      */
+#define X86FPU_387	  1	/* FPU: 80387			*/
+#define X86FPU_487	  2	/* FPU: 80487			*/
+
+/* offset to registers in HREG_SET */
+
+#ifdef LP64
+#define HREG_RAX		0x00
+#define HREG_RBX		0x08
+#define HREG_RCX		0x10
+#define HREG_RDX		0x18
+#define HREG_RSP		0x20
+#define HREG_RBP		0x28
+#define HREG_RSI		0x30
+#define HREG_RDI		0x38
+#define HREG_R8			0x40
+#define HREG_R9			0x48
+#define HREG_R10		0x50
+#define HREG_R11		0x58
+#define HREG_R12		0x60
+#define HREG_R13		0x68
+#define HREG_R14		0x70
+#define HREG_R15		0x78
+#define HREG_PC			0x80
+#define HREG_RFLAGS		0x88
+#define HREG_CR0		0x90
+#define HREG_CR2		0x98
+#define HREG_CR3		0xa0
+#define HREG_CR4		0xa8
+#define HREG_TSP		0xb0
+#define HREG_CS			0xb8
+#define HREG_DS			0xba
+#define HREG_SS			0xbc
+#define HREG_ES			0xbe
+#define HREG_FS			0xc0
+#define HREG_GS			0xc2
+#else
+#define HREG_EDI		0x00
+#define HREG_ESI		0x04
+#define HREG_EBP		0x08
+#define HREG_ESP		0x0c
+#define HREG_EBX		0x10
+#define HREG_EDX		0x14
+#define HREG_ECX		0x18
+#define HREG_EAX		0x1c
+#define HREG_EFLAGS		0x20
+#define HREG_PC			0x24
+#define HREG_CR0		0x28
+#define HREG_CR2		0x2C
+#define HREG_CR3		0x30
+#define HREG_CR4		0x34
+#define HREG_CS			0x38
+#define HREG_DS			0x3C
+#define HREG_SS			0x40
+#define HREG_ES			0x44
+#define HREG_FS			0x48
+#define HREG_GS			0x4C
+#define HREG_TSP		0x50
+#endif /* LP64 */
+
+/* bits on EFLAGS */
+
+#define	EFLAGS_EMPTY	0x00000020	/* empty eflags */
+#define	EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
+#define	EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
+#define	EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
+
+#define	EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
+#define	EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
+#define	EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
+#define	EFLAGS_ZF	0x00000040	/* ZF(sero flag) bit */
+#define	EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
+#define	EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
+#define	EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
+#define	EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
+#define	EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
+#define	EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
+#define	EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
+#define	EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
+#define	EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
+#define	EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
+#define	EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
+
+/* control and test registers */
+
+#define CR0		1
+#define CR1		2
+#define CR2		3
+#define CR3		4
+#define TR3		5
+#define TR4		6
+#define TR5		7
+#define TR6		8
+#define TR7		9
+
+/* bits on CR0 */
+
+#define CR0_PE		0x00000001	/* protection enable */
+#define CR0_MP		0x00000002	/* math present */
+#define CR0_EM		0x00000004	/* emulation */
+#define CR0_TS		0x00000008	/* task switch */
+#define CR0_ET		0x00000010	/* extension type */
+#define CR0_NE		0x00000020	/* numeric error */
+#define CR0_WP		0x00010000	/* write protect */
+#define CR0_AM		0x00040000	/* alignment mask */
+#define CR0_NW		0x20000000	/* not write through */
+#define CR0_CD		0x40000000	/* cache disable */
+#define CR0_PG		0x80000000	/* paging */
+#define CR0_NW_NOT	0xdfffffff	/* write through */
+#define CR0_CD_NOT	0xbfffffff	/* cache disable */
+
+/* bits on CR4 */
+
+#define CR4_VME		0x00000001	/* virtual-8086 mode extensions */
+#define CR4_PVI		0x00000002	/* protected-mode virtual interrupts */
+#define CR4_TSD		0x00000004	/* timestamp disable */
+#define CR4_DE		0x00000008	/* debugging extensions */
+#define CR4_PSE		0x00000010	/* page size extensions */
+#define CR4_PAE		0x00000020	/* physical address extension */
+#define CR4_MCE		0x00000040	/* machine check enable */
+#define CR4_PGE		0x00000080	/* page global enable */
+#define CR4_PCE		0x00000100	/* performance-monitoring enable */
+#define CR4_OSFXSR	0x00000200	/* use fxsave/fxrstor instructions */
+#define CR4_OSXMMEXCEPT	0x00000400	/* streaming SIMD exception */
+#define CR4_VMXE	0x00002000	/* virtual machine extensions */
+
+/* CPUID: signature bit definitions */
+
+#define CPUID_STEPID	0x0000000f	/* processor stepping id mask	*/
+#define CPUID_MODEL	0x000000f0	/* processor model mask		*/
+#define CPUID_FAMILY	0x00000f00	/* processor family mask	*/
+#define CPUID_TYPE	0x00003000	/* processor type mask		*/
+#define CPUID_EXT_MODEL	0x000f0000	/* processor extended model mask */
+#define CPUID_EXT_FAMILY 0x0ff00000	/* processor extended family mask */
+#define CPUID_486	0x00000400	/* family: 486			*/
+#define CPUID_PENTIUM	0x00000500	/* family: Pentium		*/
+#define CPUID_PENTIUMPRO 0x00000600	/* family: Pentium PRO		*/
+#define CPUID_EXTENDED	0x00000f00	/* family: Extended		*/
+#define CPUID_PENTIUM4	0x00000000	/* extended family: PENTIUM4	*/
+#define CPUID_ORIG      0x00000000	/* type: original OEM		*/
+#define CPUID_OVERD     0x00001000	/* type: overdrive		*/
+#define CPUID_DUAL      0x00002000	/* type: dual			*/
+#define CPUID_CHUNKS	0x0000ff00	/* bytes flushed by CLFLUSH mask */
+
+/* CPUID: feature bit definitions (EDX) */
+
+#define CPUID_FPU	0x00000001	/* FPU on chip			*/
+#define CPUID_VME	0x00000002	/* virtual 8086 mode enhancement*/
+#define CPUID_DE	0x00000004	/* debugging extensions		*/
+#define CPUID_PSE	0x00000008	/* page size extension		*/
+#define CPUID_TSC	0x00000010	/* time stamp counter		*/
+#define CPUID_MSR	0x00000020	/* RDMSR and WRMSR support	*/
+#define CPUID_PAE	0x00000040	/* physical address extensions	*/
+#define CPUID_MCE	0x00000080	/* machine check exception	*/
+#define CPUID_CXS	0x00000100	/* CMPXCHG8 inst		*/
+#define CPUID_APIC	0x00000200	/* APIC on chip			*/
+#define CPUID_SEP	0x00000800	/* SEP, Fast System Call	*/
+#define CPUID_MTRR	0x00001000	/* MTRR				*/
+#define CPUID_PGE	0x00002000	/* PTE global bit		*/
+#define CPUID_MCA	0x00004000	/* machine check arch.		*/
+#define CPUID_CMOV	0x00008000	/* cond. move/cmp. inst		*/
+#define CPUID_PAT	0x00010000	/* page attribute table		*/
+#define CPUID_PSE36	0x00020000	/* 36 bit page size extension	*/
+#define CPUID_PSNUM	0x00040000	/* processor serial number	*/
+#define CPUID_CLFLUSH	0x00080000	/* CLFLUSH inst supported	*/
+#define CPUID_DTS	0x00200000	/* Debug Store			*/
+#define CPUID_ACPI	0x00400000	/* TM and SCC supported		*/
+#define CPUID_MMX	0x00800000	/* MMX technology supported	*/
+#define CPUID_FXSR	0x01000000	/* fast FP save and restore	*/
+#define CPUID_SSE	0x02000000	/* SSE supported		*/
+#define CPUID_SSE2	0x04000000	/* SSE2 supported		*/
+#define CPUID_SS	0x08000000	/* Self Snoop supported		*/
+#define CPUID_HTT	0x10000000	/* Hyper Threading Technology   */
+#define CPUID_TM	0x20000000	/* Thermal Monitor supported	*/
+#define CPUID_IA64	0x40000000	/* IA64 Capabilities		*/
+#define CPUID_PBE	0x80000000	/* Pending Break Enable		*/
+
+/* CPUID: extended feature bit definitions (ECX) */
+
+#define CPUID_GV3	0x00000080	/* Geyserville 3 supported	*/
+
+#define CPUID_SSE3	0x00000001	/* SSE3 Extensions		*/
+#define CPUID_MULDQ	0x00000002	/* support PCLMULDQ instruction	*/
+#define CPUID_DTES64	0x00000004	/* 64-bit Debug Store		*/
+#define CPUID_MON	0x00000008	/* Monitor/wait			*/
+#define CPUID_DS_CPL	0x00000010	/* CPL qualified Debug Store	*/
+#define CPUID_VMX	0x00000020	/* Virtual Machine Technology	*/
+#define CPUID_SMX	0x00000040	/* Safer Mode Extensions	*/
+#define CPUID_EST	0x00000080	/* Enhanced Speedstep Technology*/
+#define CPUID_TM2	0x00000100	/* Thermal Monitor 2 supported	*/
+#define CPUID_SSSE3	0x00000200	/* SSSE3 Extensions		*/
+#define CPUID_CID	0x00000400	/* L1 context ID		*/
+#define CPUID_CX16	0x00002000	/* CMPXCHG16B			*/
+#define CPUID_XTPR	0x00004000	/* Update control		*/
+#define CPUID_PDCM	0x00008000	/* Performance/Debug capability	*/
+#define CPUID_DCA	0x00040000	/* Direct Cache Access		*/
+#define CPUID_SSE41	0x00080000	/* SIMD Extensions 4.1		*/
+#define CPUID_SSE42	0x00100000	/* SIMD Extensions 4.2		*/
+#define CPUID_x2APIC	0x00200000	/* x2APIC supported		*/
+#define CPUID_MOVBE	0x00400000	/* MOVBE instruction supported	*/
+#define CPUID_POPCNT	0x00800000	/* POPCNT instruction supported	*/
+#define CPUID_AES	0x02000000	/* AES instruction supported	*/
+#define CPUID_XSAVE	0x04000000	/* XSAVE states supported	*/
+#define CPUID_OSXSAVE	0x08000000	/* extended state management	*/
+
+/* CPUID: offset in CPUID structure */
+
+#define CPUID_HIGHVALUE		0	/* offset to highestValue	*/
+#define CPUID_VENDORID		4	/* offset to vendorId		*/
+#define CPUID_SIGNATURE		16	/* offset to signature		*/
+#define CPUID_FEATURES_EBX	20	/* offset to featuresEbx	*/
+#define CPUID_FEATURES_ECX	24	/* offset to featuresEcx	*/
+#define CPUID_FEATURES_EDX	28	/* offset to featuresEdx	*/
+#define CPUID_CACHE_EAX		32	/* offset to cacheEax		*/
+#define CPUID_CACHE_EBX		36	/* offset to cacheEbx		*/
+#define CPUID_CACHE_ECX		40	/* offset to cacheEcx		*/
+#define CPUID_CACHE_EDX		44	/* offset to cacheEdx		*/
+#define CPUID_SERIALNO		48	/* offset to serialNo64		*/
+#define CPUID_BRAND_STR		56	/* offset to brandString[0]	*/
+
+/* MSR_VMX_EPT_VPID_CAP: EOT abd VPID capabilities */
+
+#define	EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
+#define	EPT_VPID_RWX_W_ONLY	1	/* write only supported */
+#define	EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
+
+#define	EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
+#define	EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
+#define	EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
+#define	EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
+#define	EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
+
+#define	EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
+#define	EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
+#define	EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
+#define	EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
+#define	EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
+
+#define	EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVEPT_CTX	0x02	/* context sync */
+#define	EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
+
+#define	EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
+#define	EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
+#define	EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
+
+#define	EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
+#define	EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
+#define	EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
+#define	EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
+
+/* MSR, Model Specific Registers */
+
+/* MSR, P5 only */
+
+#define MSR_P5_MC_ADDR		0x0000
+#define MSR_P5_MC_TYPE		0x0001
+#define MSR_TSC			0x0010
+#define MSR_CESR                0x0011
+#define MSR_CTR0                0x0012
+#define MSR_CTR1                0x0013
+
+/* MSR, P5 and P6 */
+
+#define MSR_APICBASE		0x001b
+#define MSR_EBL_CR_POWERON	0x002a
+#define MSR_TEST_CTL		0x0033
+#define MSR_BIOS_UPDT_TRIG	0x0079
+#define MSR_BBL_CR_D0		0x0088	/* P6 only */
+#define MSR_BBL_CR_D1		0x0089	/* P6 only */
+#define MSR_BBL_CR_D2		0x008a	/* P6 only */
+#define MSR_BIOS_SIGN		0x008b
+#define MSR_PERFCTR0		0x00c1
+#define MSR_PERFCTR1		0x00c2
+#define MSR_MTRR_CAP		0x00fe
+#define MSR_BBL_CR_ADDR		0x0116	/* P6 only */
+#define MSR_BBL_CR_DECC		0x0118	/* P6 only */
+#define MSR_BBL_CR_CTL		0x0119	/* P6 only */
+#define MSR_BBL_CR_TRIG		0x011a	/* P6 only */
+#define MSR_BBL_CR_BUSY		0x011b	/* P6 only */
+#define MSR_BBL_CR_CTL3		0x011e	/* P6 only */
+#define MSR_SYSENTER_CS		0x0174	/* P6 + SEP only */
+#define MSR_SYSENTER_ESP	0x0175	/* P6 + SEP only */
+#define MSR_SYSENTER_EIP	0x0176	/* P6 + SEP only */
+#define MSR_MCG_CAP		0x0179
+#define MSR_MCG_STATUS		0x017a
+#define MSR_MCG_CTL		0x017b
+#define MSR_EVNTSEL0		0x0186
+#define MSR_EVNTSEL1		0x0187
+#define MSR_DEBUGCTLMSR		0x01d9
+#define MSR_LASTBRANCH_FROMIP	0x01db
+#define MSR_LASTBRANCH_TOIP	0x01dc
+#define MSR_LASTINT_FROMIP	0x01dd
+#define MSR_LASTINT_TOIP	0x01de
+#define MSR_ROB_CR_BKUPTMPDR6	0x01e0
+#define MSR_MTRR_PHYS_BASE0	0x0200
+#define MSR_MTRR_PHYS_MASK0	0x0201
+#define MSR_MTRR_PHYS_BASE1	0x0202
+#define MSR_MTRR_PHYS_MASK1	0x0203
+#define MSR_MTRR_PHYS_BASE2	0x0204
+#define MSR_MTRR_PHYS_MASK2	0x0205
+#define MSR_MTRR_PHYS_BASE3	0x0206
+#define MSR_MTRR_PHYS_MASK3	0x0207
+#define MSR_MTRR_PHYS_BASE4	0x0208
+#define MSR_MTRR_PHYS_MASK4	0x0209
+#define MSR_MTRR_PHYS_BASE5	0x020a
+#define MSR_MTRR_PHYS_MASK5	0x020b
+#define MSR_MTRR_PHYS_BASE6	0x020c
+#define MSR_MTRR_PHYS_MASK6	0x020d
+#define MSR_MTRR_PHYS_BASE7	0x020e
+#define MSR_MTRR_PHYS_MASK7	0x020f
+#define MSR_MTRR_FIX_00000	0x0250
+#define MSR_MTRR_FIX_80000	0x0258
+#define MSR_MTRR_FIX_A0000	0x0259
+#define MSR_MTRR_FIX_C0000	0x0268
+#define MSR_MTRR_FIX_C8000	0x0269
+#define MSR_MTRR_FIX_D0000	0x026a
+#define MSR_MTRR_FIX_D8000	0x026b
+#define MSR_MTRR_FIX_E0000	0x026c
+#define MSR_MTRR_FIX_E8000	0x026d
+#define MSR_MTRR_FIX_F0000	0x026e
+#define MSR_MTRR_FIX_F8000	0x026f
+#define MSR_MTRR_DEFTYPE	0x02ff
+#define MSR_MC0_CTL		0x0400
+#define MSR_MC0_STATUS		0x0401
+#define MSR_MC0_ADDR		0x0402
+#define MSR_MC0_MISC		0x0403
+#define MSR_MC1_CTL		0x0404
+#define MSR_MC1_STATUS		0x0405
+#define MSR_MC1_ADDR		0x0406
+#define MSR_MC1_MISC		0x0407
+#define MSR_MC2_CTL		0x0408
+#define MSR_MC2_STATUS		0x0409
+#define MSR_MC2_ADDR		0x040a
+#define MSR_MC2_MISC		0x040b
+#define MSR_MC4_CTL		0x040c
+#define MSR_MC4_STATUS		0x040d
+#define MSR_MC4_ADDR		0x040e
+#define MSR_MC4_MISC		0x040f
+#define MSR_MC3_CTL		0x0410
+#define MSR_MC3_STATUS		0x0411
+#define MSR_MC3_ADDR		0x0412
+#define MSR_MC3_MISC		0x0413
+
+/* MSR, Core2 */
+
+#define	MSR_FSB_FREQ		0x00cd
+
+/* MSR, VMX specific */
+
+#define	MSR_VMX_FEATURE			0x003A
+#define	MSR_VMX_BASIC			0x0480
+#define MSR_VMX_PINBASED_CTLS_MSR	0x0481
+#define MSR_VMX_PROCBASED_CTLS_MSR	0x0482
+#define MSR_VMX_EXIT_CTLS_MSR		0x0483
+#define MSR_VMX_ENTRY_CTLS_MSR		0x0484
+#define MSR_VMX_MISC_MSR		0x0485
+#define MSR_VMX_CR0_FIXED0		0x0486
+#define MSR_VMX_CR0_FIXED1		0x0487
+#define MSR_VMX_CR4_FIXED0		0x0488
+#define MSR_VMX_CR4_FIXED1		0x0489
+#define MSR_VMX_PROCBASED_CTLS2_MSR	0x048B
+#define MSR_VMX_EPT_VPID_CAP		0x048C
+
+/* MSR, Architectural MSRs (common MSRs in IA32) */
+
+#define	IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
+#define	IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
+#define	IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
+#define	IA32_PLATFORM_ID	0x0017			/* P6 */
+#define	IA32_APIC_BASE		MSR_APICBASE		/* P6 */
+#define	IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
+#define	IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
+#define	IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
+#define	IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
+#define	IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
+#define	IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
+#define	IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
+#define	IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
+#define	IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
+#define	IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
+#define	IA32_MCG_EAX		0x0180			/* Pentium4 */
+#define	IA32_MCG_EBX		0x0181			/* Pentium4 */
+#define	IA32_MCG_ECX		0x0182			/* Pentium4 */
+#define	IA32_MCG_EDX		0x0183			/* Pentium4 */
+#define	IA32_MCG_ESI		0x0184			/* Pentium4 */
+#define	IA32_MCG_EDI		0x0185			/* Pentium4 */
+#define	IA32_MCG_EBP		0x0186			/* Pentium4 */
+#define	IA32_MCG_ESP		0x0187			/* Pentium4 */
+#define	IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
+#define	IA32_MCG_EIP		0x0189			/* Pentium4 */
+#define	IA32_MCG_MISC		0x018a			/* Pentium4 */
+#define	IA32_THERM_CONTROL	0x019a			/* Pentium4 */
+#define	IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
+#define	IA32_THERM_STATUS	0x019c			/* Pentium4 */
+#define	IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
+#define	IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
+#define	IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
+#define	IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
+#define	IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
+#define	IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
+#define	IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
+#define	IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
+#define	IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
+#define	IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
+#define	IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
+#define	IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
+#define	IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
+#define	IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
+#define	IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
+#define	IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
+#define	IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
+#define	IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
+#define	IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
+#define	IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
+#define	IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
+#define	IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
+#define	IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
+#define	IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
+#define	IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
+#define	IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
+#define	IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
+#define	IA32_CR_PAT		0x0277			/* P6 */
+#define	IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
+#define	IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
+#define	IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
+#define	IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
+#define	IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
+#define	IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
+#define	IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
+#define	IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
+#define	IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
+#define	IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
+#define	IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
+#define	IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
+#define	IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
+#define	IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
+#define	IA32_MC3_CTL		0x040c			/* P6, addr changed */
+#define	IA32_MC3_STATUS		0x040d			/* P6, addr changed */
+#define	IA32_MC3_ADDR		0x040e			/* P6, addr changed */
+#define	IA32_MC3_MISC		0x040f			/* P6, addr changed */
+#define	IA32_DS_AREA		0x0600			/* Pentium4 */
+#define	IA32_PERF_STAT		0x0198			/* Core2 */ 
+#define	IA32_EFER		0xc0000080		/* Core2 - extended feature */ 
+
+/* MSR, IA32_DEBUGCTL, in Pentium4, bits */
+
+#define	DBG_P7_LBR		0x00000001
+#define	DBG_P7_BTF		0x00000002
+#define	DBG_P7_TR		0x00000004
+#define	DBG_P7_BTS		0x00000008
+#define	DBG_P7_BTINT		0x00000010
+
+/* MSR, IA32_DEBUGCTL, in P6, bits */
+
+#define	DBG_P6_LBR		0x00000001
+#define	DBG_P6_BTF		0x00000002
+#define	DBG_P6_PB0		0x00000004
+#define	DBG_P6_PB1		0x00000008
+#define	DBG_P6_PB2		0x00000010
+#define	DBG_P6_PB3		0x00000020
+#define	DBG_P6_TR		0x00000040
+
+/* MSR, MSR_LASTBRANCH_TOS, in Pentium4, bits */
+
+#define	TOS_MASK		0x00000003
+
+/* MSR, IA32_MISC_ENABLE bits */
+
+#define	MSC_FAST_STRING_ENABLE	0x00000001
+#define	MSC_FOPCODE_ENABLE	0x00000004
+#define	MSC_THERMAL_MON_ENABLE	0x00000008
+#define	MSC_SPLIT_LOCK_DISABLE	0x00000010
+#define	MSC_PMON_AVAILABLE	0x00000080
+#define	MSC_BTS_UNAVAILABLE	0x00000800
+#define	MSC_PEBS_UNAVAILABLE	0x00001000
+#define	MSC_GV1_EN		0x00008000
+#define	MSC_GV3_EN		0x00010000
+#define	MSC_GV_SEL_LOCK		0x00100000
+#define	MSC_LEAF_REPORTING	0x00400000
+
+/* MSR, IA32_PEBS_ENABLE bits */
+
+#define	PEBS_METRICS		0x00001fff
+#define	PEBS_UOP_TAG		0x01000000
+#define	PEBS_ENABLE		0x02000000
+
+/* MSR, IA32_PLATFORM_ID bits (upper 32) */
+
+#define	PFM_PLATFORM_ID		0x001c0000
+#define	PFM_MOBILE_GV		0x00040000
+
+/* MSR, IA32_PLATFORM_ID bits (lower 32) */
+
+#define	PFM_MAX_VID		0x0000003f
+#define	PFM_MAX_FREQ		0x00000f80
+#define	PFM_RATIO_LOCKED	0x00008000
+#define	PFM_GV3_TM_DISABLED	0x00010000
+#define	PFM_GV3_DISABLED	0x00020000
+#define	PFM_GV1_DISABLED	0x00040000
+#define	PFM_TM_DISABLED		0x00080000
+#define	PFM_L2_CACHE_SIZE	0x06000000
+#define	PFM_SAMPLE		0x08000000
+
+/* MSR, IA32_THERM_CONTROL bits */
+
+#define	THERM_DUTY_CYCLE	0x0000000e
+#define	THERM_TCC_EN		0x00000010
+
+/* MSR, IA32_THERM_STATUS bits */
+
+#define	THERM_HOT_NOW		0x00000001
+#define	THERM_HOT_LOG		0x00000002
+
+/* MSR, IA32_THERM_INTERRUPT bits */
+
+#define	THERM_HOT_INT_EN	0x00000001
+#define	THERM_COLD_INT_EN	0x00000002
+
+/* PMC, Performance Monitoring Event Select MSR bits */
+
+/* P5 specific */
+
+#define P5PMC_PC                0x00000200
+#define P5PMC_CC_DISABLE        0x00000000
+#define P5PMC_CC_EVT_CPL012     0x00000040
+#define P5PMC_CC_EVT_CPL3       0x00000080
+#define P5PMC_CC_EVT            0x000000C0
+#define P5PMC_CC_CLK_CPL012     0x00000140
+#define P5PMC_CC_CLK_CPL3       0x00000180
+#define P5PMC_CC_CLK            0x000001C0
+
+/* P6 specific */
+
+#define PMC_USR               0x00010000
+#define PMC_OS                0x00020000
+#define PMC_E                 0x00040000
+#define PMC_PC                0x00080000
+#define PMC_INT               0x00100000
+#define PMC_EN                0x00400000
+#define PMC_INV               0x00800000
+
+/* MSR, MSR_VMX_ENTRY_CTLS bits */
+
+#define VMX_ENTRY_CTLS_IA32e		0x00000200
+#define VMX_ENTRY_CTLS_SMM		0x00000400
+#define VMX_ENTRY_CTLS_DUAL		0x00000800
+
+/* MSR, MSR_VMX_EXIT_CTLS_MSR bits */
+
+#define VMX_EXIT_CTLS_64BIT		0x00000200
+#define VMX_EXIT_CTLS_IACK		0x00008000
+
+/* MSR, IA32_EFER bits */
+
+#define EFER_SCE 	0x00000001 	/* SYSCALL/SYSRET (bit 0) */
+#define EFER_LME 	0x00000100  	/* Long mode enable (bit 8) */
+#define EFER_LMA	0x00000400 	/* Long mode active (r/o) 10 */
+#define EFER_NX 	0x00000800 	/* No execute enable (bit 11) */
+
+/* PMC, Performance Monitoring Events */
+
+/* P5 PMC event list */
+
+#define P5PMC_DATA_RD			0x00
+#define P5PMC_DATA_WR			0x01
+#define P5PMC_DATA_TBL_MISS		0x02
+#define P5PMC_DATA_RD_MISS		0x03
+#define P5PMC_DATA_WR_MISS		0x04
+#define P5PMC_WR_HIT_M_E_STATE_LINE	0x05
+#define P5PMC_DCACHE_WR_BACK		0x06
+#define P5PMC_EXT_SNOOPS		0x07
+#define P5PMC_EXT_DCACHE_SNOOPS_HIT	0x08
+#define P5PMC_MEM_ACCESS_BOTH_PIPES	0x09
+#define P5PMC_BANK_CONFLICT		0x0A
+#define P5PMC_MISC_DMEM_IO_REF		0x0B
+#define P5PMC_CODE_RD			0x0C
+#define P5PMC_CODE_TBL_MISS		0x0D
+#define P5PMC_CODE_CACHE_MISS		0x0E
+#define P5PMC_SEGMENT_REG_LOAD		0x0F
+#define P5PMC_BRANCH			0x12
+#define P5PMC_BTB_HIT			0x13
+#define P5PMC_TAKEN_BRANCH_BTB_HIT	0x14
+#define P5PMC_PIPELINE_FLUSH		0x15
+#define P5PMC_INST_EXECUTED		0x16
+#define P5PMC_INST_EXECUTED_VPIPE	0x17
+#define P5PMC_BUS_CYC_DURATION		0x18
+#define P5PMC_WR_BUF_FULL_STALL_DURATION 0x19
+#define P5PMC_WAIT_MEM_RD_STALL_DURATION 0x1A
+#define P5PMC_STALL_ON_WR_M_E_STATE_LINE 0x1B
+#define P5PMC_LOCKED_BUS_CYC		0x1C
+#define P5PMC_IO_RD_WR_CYC		0x1D
+#define P5PMC_NONCACHE_MEM_RD		0x1E
+#define P5PMC_PIPELINE_AGI_STALL	0x1F
+#define P5PMC_FLOPS			0x22
+#define P5PMC_BK_MATCH_DR0		0x23
+#define P5PMC_BK_MATCH_DR1		0x24
+#define P5PMC_BK_MATCH_DR2		0x25
+#define P5PMC_BK_MATCH_DR3		0x26
+#define P5PMC_HW_INT			0x27
+#define P5PMC_DATA_RD_WR		0x28
+#define P5PMC_DATA_RD_WR_MISS		0x29
+#define P5PMC_BUS_OWNER_LATENCY		0x2A
+#define P5PMC_BUS_OWNER_TRANSFER	0x2A
+#define P5PMC_MMX_INST_UPIPE		0x2B
+#define P5PMC_MMX_INST_VPIPE		0x2B
+#define P5PMC_CACHE_M_LINE_SHARE	0x2C
+#define P5PMC_CACHE_LINE_SHARE		0x2C
+#define P5PMC_EMMS_INTS_EXECUTED	0x2D
+#define P5PMC_TRANS_MMX_FP_INST		0x2D
+#define P5PMC_BUS_UTIL_PROCESSOR_ACT	0x2D
+#define P5PMC_WR_NOCACHEABLE_MEM	0x2E
+#define P5PMC_SATURATING_MMX_INST	0x2F
+#define P5PMC_SATURATION_PERFORMED	0x2F
+#define P5PMC_NUM_CYC_NOT_HALT_STATE	0x30
+#define P5PMC_DCACHE_TLB_MISS_STALL_DUR	0x30
+#define P5PMC_MMX_INST_DATA_RD		0x31
+#define P5PMC_MMX_INST_DATA_RD_MISS	0x31
+#define P5PMC_FP_STALL_DUR		0x32
+#define P5PMC_TAKEN_BRANCH		0x32
+#define P5PMC_D1_STARV_FIFO_EMPTY	0x33
+#define P5PMC_D1_STARV_ONE_INST_FIFO	0x33
+#define P5PMC_MMX_INST_DATA_WR		0x34
+#define P5PMC_MMX_INST_DATA_WR_MISS	0x34
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC	0x35
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC_WB 0x35
+#define P5PMC_MISALIGN_DMEM_REF_MMX 	0x36
+#define P5PMC_PL_STALL_MMX_DMEM_RD 	0x36
+#define P5PMC_MISPREDIC_UNPREDIC_RET 	0x37
+#define P5PMC_PREDICED_RETURN 		0x37
+#define P5PMC_MMX_MUL_UNIT_INTERLOCK 	0x38
+#define P5PMC_MOVD_MOVQ_STALL_PREV_MMX 	0x38
+#define P5PMC_RETURN 			0x39
+#define P5PMC_BTB_FALSE_ENTRY		0x3A
+#define P5PMC_BTB_MISS_PREDIC_NOT_TAKEN_BR 0x3A
+#define P5PMC_FULL_WR_BUF_STALL_MMX 	0x3B
+#define P5PMC_STALL_MMX_WR_E_M_STATE_LINE 0x3B
+
+/* P6 PMC event list */
+
+#define	PMC_DATA_MEM_REFS		0x43
+#define	PMC_DCU_LINES_IN		0x45
+#define	PMC_DCU_M_LINES_IN		0x46
+#define	PMC_DCU_M_LINES_OUT		0x47
+#define	PMC_DCU_MISS_OUTSTANDING	0x48
+#define	PMC_IFU_IFETCH			0x80
+#define	PMC_IFU_IFETCH_MISS		0x81
+#define	PMC_ITLB_MISS			0x85
+#define	PMC_IFU_MEM_STALL		0x86
+#define	PMC_IDL_STALL			0x87
+#define	PMC_L2_IFETCH			0x28
+#define	PMC_L2_LD			0x29
+#define	PMC_L2_ST			0x2a
+#define	PMC_L2_LINES_IN			0x24
+#define	PMC_L2_LINES_OUT		0x26
+#define	PMC_L2_M_LINES_INM		0x25
+#define	PMC_L2_M_LINES_OUTM		0x27
+#define	PMC_L2_RQSTS			0x2e
+#define	PMC_L2_ADS			0x21
+#define	PMC_L2_DBUS_BUSY		0x22
+#define	PMC_L2_DBUS_BUSY_RD		0x23
+#define	PMC_BUS_DRDY_CLOCKS		0x62
+#define	PMC_BUS_LOCK_CLOCKS		0x63
+#define	PMC_BUS_REQ_OUTSTANDING		0x60
+#define	PMC_BUS_TRAN_BRD		0x65
+#define	PMC_BUS_TRAN_RFO		0x66
+#define	PMC_BUS_TRANS_WB		0x67
+#define	PMC_BUS_TRAN_IFETCH		0x68
+#define	PMC_BUS_TRAN_INVAL		0x69
+#define	PMC_BUS_TRAN_PWR		0x6a
+#define	PMC_BUS_TRANS_P			0x6b
+#define	PMC_BUS_TRANS_IO		0x6c
+#define	PMC_BUS_TRAN_DEF		0x6d
+#define	PMC_BUS_TRAN_BURST		0x6e
+#define	PMC_BUS_TRAN_ANY		0x70
+#define	PMC_BUS_TRAN_MEM		0x6f
+#define	PMC_BUS_DATA_RCV		0x64
+#define	PMC_BUS_BNR_DRV			0x61
+#define	PMC_BUS_HIT_DRV			0x7a
+#define	PMC_BUS_HITM_DRV		0x7b
+#define	PMC_BUS_SNOOP_STALL		0x7e
+#define	PMC_FLOPS			0xc1
+#define	PMC_FP_COMP_OPS_EXE		0x10
+#define	PMC_FP_ASSIST			0x11
+#define	PMC_MUL				0x12
+#define	PMC_DIV				0x13
+#define	PMC_CYCLES_DIV_BUSY		0x14
+#define	PMC_LD_BLOCKS			0x03
+#define	PMC_SB_DRAINS			0x04
+#define	PMC_MISALIGN_MEM_REF		0x05
+#define	PMC_INST_RETIRED		0xc0
+#define	PMC_UOPS_RETIRED		0xc2
+#define	PMC_INST_DECODER		0xd0
+#define	PMC_HW_INT_RX			0xc8
+#define	PMC_CYCLES_INT_MASKED		0xc6
+#define	PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
+#define	PMC_BR_INST_RETIRED		0xc4
+#define	PMC_BR_MISS_PRED_RETIRED	0xc5
+#define	PMC_BR_TAKEN_RETIRED		0xc9
+#define	PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
+#define	PMC_BR_INST_DECODED		0xe0
+#define	PMC_BTB_MISSES			0xe2
+#define	PMC_BR_BOGUS			0xe4
+#define	PMC_BACLEARS			0xe6
+#define	PMC_RESOURCE_STALLS		0xa2
+#define	PMC_PARTIAL_RAT_STALLS		0xd2
+#define	PMC_SEGMENT_REG_LOADS		0x06
+#define	PMC_CPU_CLK_UNHALTED		0x79
+#define	PMC_UMASK_00			0x00
+#define	PMC_UMASK_0F			0x0f
+#define	PMC_UMASK_SELF			0x00
+#define	PMC_UMASK_ANY			0x20
+
+/* MTRR related defines */
+
+#define MTRR_UC				0x00
+#define MTRR_WC				0x01
+#define MTRR_WT				0x04
+#define MTRR_WP				0x05
+#define MTRR_WB				0x06
+#define MTRR_E				0x00000800
+#define MTRR_FE				0x00000400
+#define MTRR_VCNT			0x000000FF
+#define MTRR_FIX_SUPPORT		0x00000100
+#define MTRR_WC_SUPPORT			0x00000400
+
+/* MCA related defines */
+
+#define	MCG_CTL_P			0x00000100
+#define	MCG_COUNT			0x000000ff
+#define	MCG_MCIP			0x00000004
+#define	MCG_EIPV			0x00000002
+#define	MCG_RIPV			0x00000001
+#define	MCI_VAL				0x80000000
+#define	MCI_OVER			0x40000000
+#define	MCI_UC				0x20000000
+#define	MCI_EN				0x10000000
+#define	MCI_MISCV			0x08000000
+#define	MCI_ADDRV			0x04000000
+#define	MCI_PCC				0x02000000
+
+/* segment descriptor: types for application code, data segment */
+
+#define	SEG_DATA_RO_U		0x00000000	/* read only */
+#define	SEG_DATA_RW_U		0x00000200	/* read write */
+#define	SEG_DATA_RO_D		0x00000400	/* read only expand down */
+#define	SEG_DATA_RW_D		0x00000600	/* read write expand down */
+#define	SEG_CODE_EO		0x00000800	/* exec only */
+#define	SEG_CODE_ER		0x00000a00	/* exec read */
+#define	SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
+#define	SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
+
+/* segment descriptor: types for system segment and gate */
+
+#define SEG_LDT			0x00000200	/* LDT */
+#define TASK_GATE		0x00000500	/* Task Gate */
+#define TSS32			0x00000900	/* 32 bit TSS (available) */
+#define CALL_GATE32		0x00000c00	/* 32 bit CALL gate */
+#define INT_GATE32		0x00000e00	/* 32 bit INT  gate */
+#define TRAP_GATE32		0x00000f00	/* 32 bit TRAP gate */
+
+/* segment descriptor: descriptor type */
+
+#define SYS_DESC		0x00000000	/* system descriptors */
+#define APP_DESC		0x00001000	/* application descriptors */
+
+/* segment descriptor: privilege level */
+
+#define DPL0			0x00000000	/* privilege level 0 */
+#define DPL1			0x00002000	/* privilege level 1 */
+#define DPL2			0x00004000	/* privilege level 2 */
+#define DPL3			0x00006000	/* privilege level 3 */
+
+/* segment descriptor: privilege level */
+
+#define SEG_P			0x00008000	/* present */
+
+/* segment descriptor: default operation size */
+
+#define DB_16			0x00000000	/* 16 bit segment */
+#define DB_32			0x00400000	/* 32 bit segment */
+
+/* segment descriptor: granularity */
+
+#define G_BYTE			0x00000000	/* byte granularity */
+#define G_4K			0x00800000	/* 4K byte granularity */
+
+/* segment descriptor: mask bits for attribute */
+
+#define SEG_ATTR_MASK		0x00f0ff00	/* mask bits */
+
+/* segment descriptor: pSegdesc->type: present and busy bit */
+
+#define SEG_PRESENT		0x80		/* present bit */
+#define SEG_BUSY		0x02		/* busy bit */
+
+/* segment register requested privilege levels */
+
+#define	SEG_RPL_RING_0		0x0
+#define	SEG_RPL_RING_1		0x1
+#define	SEG_RPL_RING_2		0x2
+#define	SEG_RPL_RING_3		0x3
+#define	SEG_RPL_MASK		0x3
+
+/* IDT related macros */
+
+#define IDT_TASK_GATE 		0x0000e500 	/* task gate: P=1, DPL=3, task id */
+
+#define IDT_TRAP_GATE 		0x0000ef00 	/* trap gate: P=1, DPL=3, trap id */
+#define IDT_INT_GATE  		0x0000ee00 	/* int gate: P=1, DPL=3, int id */
+
+/* TSS related macros */
+
+#define TSS_LINK		  0	/* offset: link to previous task */
+#define TSS_ESP0		  4	/* offset: privilege level 0 SP */
+#define TSS_SS0	  		  8	/* offset:   ''              SS */
+#define TSS_ESP1		 12	/* offset: privilege level 1 SP */
+#define TSS_SS1	 		 16	/* offset:   ''              SS */
+#define TSS_ESP2		 20	/* offset: privilege level 2 SP */
+#define TSS_SS2			 24	/* offset:   ''              SS */
+#define TSS_CR3			 28	/* offset: control register CR3 */
+#define TSS_EIP			 32	/* offset: program counter  EIP */
+#define TSS_EFLAGS		 36	/* offset: status register  EFLAGS */
+#define TSS_EAX			 40	/* offset: general register EAX */
+#define TSS_ECX			 44	/* offset: general register ECX */
+#define TSS_EDX			 48	/* offset: general register EDX */
+#define TSS_EBX			 52	/* offset: general register EBX */
+#define TSS_ESP			 56	/* offset: stack pointer ESP */
+#define TSS_EBP			 60	/* offset: frame pointer EBP */
+#define TSS_ESI			 64	/* offset: general register ESI */
+#define TSS_EDI			 68	/* offset: general register EDI */
+#define TSS_ES			 72	/* offset: segment selector ES */
+#define TSS_CS			 76	/* offset: segment selector CS */
+#define TSS_SS			 80	/* offset: segment selector SS */
+#define TSS_DS			 84	/* offset: segment selector DS */
+#define TSS_FS			 88	/* offset: segment selector FS */
+#define TSS_GS			 92	/* offset: segment selector GS */
+#define TSS_LDT			 96	/* offset: segment selector LDT */
+#define TSS_TFLAG		100	/* offset: debug trap flag T */
+#define TSS_IOMAPB		102	/* offset: IO map base address */
+#define TSS_IOBMAP		104	/* offset: IO bit map array */
+
+#define TSS_BUSY_MASK	0xfffffdff	/* TSS descriptor BUSY bit mask */
+
+/* VMX realted defines */
+
+#define	VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
+#define	VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
+
+/* inline version of intLock()/intUnlock() : used in mmuI86Lib.c */
+
+#define INT_LOCK(oldLevel) \
+    WRS_ASM ("pushf ; popl %0 ; andl $0x00000200, %0 ; cli" \
+    : "=rm" (oldLevel) : /* no input */ : "memory")
+
+#define INT_UNLOCK(oldLevel) \
+    WRS_ASM ("testl $0x00000200, %0 ; jz 0f ; sti ; 0:" \
+    : /* no output */ : "rm" (oldLevel) : "memory")
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __INCx86regsh */
diff --git a/include/vbi/x86/regs.h b/include/vbi/x86/regs.h
new file mode 100644
index 0000000..cf808b4
--- /dev/null
+++ b/include/vbi/x86/regs.h
@@ -0,0 +1,1954 @@
+/* sys/x86/regs.h - x86 cpu registers */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute or otherwise make use of this software
+ * may be licensed only pursuant to the terms of an applicable Wind River
+ * license agreement. 
+*/
+
+/*
+modification history
+--------------------
+01z,14sep09,md   add new processor bit definition
+01y,31aug09,mmi  move VBI_HREG_SET to vbiX86Arch.h
+01x,14aug09,md   adjust VBI_HREG_SET
+01w,29jul09,mpk  add VBI_HREG_SET for supporting register read, write
+01v,16jul09,dbt  fixed registers offset
+01u,17jun09,dbt  added 64-bit support, clean up IDT support
+01t,26sep08,md   add IDT entry definitions
+01s,18aug08,md   add new cpuid features
+01r,07aug08,md   add cpuid cache query defines
+01q,30jul08,md   add cpuid signature defines
+01p,18jun08,md   add VT-x2 MSR's
+01o,24mar08,md   add IA32_PERF_STAT MSR and MSR_FSB_FREQ
+01n,14mar08,md   add x86GetCpuid
+01m,12mar08,md   add MSR_VMX_PROCBASED_CTLS2_MSR
+01l,22feb08,md   add APIC support
+01k,15feb08,md   add some VT-x specific SPR's
+01j,04feb08,md   add additional register get functions
+01i,21jan08,md   add vt defines
+01h,03oct07,md   renamed REG_SET to HREG_SET
+01g,02sep07,md   added IDT definitions
+01f,30aug07,md   added call gate specifications
+01e,08aug07,md   add defines for segment priv levels
+01d,07aug07,md   changed use of u_int to uint32_t
+01c,31jul07,md   added additional GDT definitions
+01b,25jul07,md   added cr registers to REG_SET, added GDT & GDTR struct
+01a,16jul07,md   written based on VxWorks 01w version
+*/
+
+#ifndef	__INCx86regsh
+#define	__INCx86regsh
+
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IO_BMAP_SIZE	32	/* IO bitmap for port 0x000 - 0x3ff */
+
+#ifndef	_ASMLANGUAGE
+
+#ifdef LP64
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    _RType   rax;		/* 00: general register		*/
+    _RType   rbx;		/* 08: general register		*/
+    _RType   rcx;		/* 10: general register		*/
+    _RType   rdx;		/* 18: general register		*/
+    _RType   rsp;		/* 20: stack pointer register	*/
+    _RType   rbp;		/* 28: frame pointer register	*/
+    _RType   rsi;		/* 30: general register		*/
+    _RType   rdi;		/* 38: general register		*/
+    _RType   r8;	 	/* 40: general register		*/
+    _RType   r9;	 	/* 48: general register		*/
+    _RType   r10;		/* 50: general register		*/
+    _RType   r11;		/* 58: general register		*/
+    _RType   r12;		/* 60: general register		*/
+    _RType   r13;		/* 68: general register		*/
+    _RType   r14;		/* 70: general register		*/
+    _RType   r15;		/* 78: general register		*/
+    INSTR   *pc;		/* 80: program counter		*/
+    _RType   flags;		/* 88: status register		*/
+    _RType   cr0;		/* 90: control register 0	*/
+    _RType   cr2;		/* 98: control register 2	*/
+    _RType   cr3;		/* 100: control register 3	*/
+    _RType   cr4;		/* 108: control register 4	*/
+    uint64_t tsp;		/* 110: transition stack pointer*/
+    uint16_t cs;		/* 118: code segment		*/
+    uint16_t ds;		/* 11A: data segment		*/
+    uint16_t ss;		/* 11C: stack segment		*/
+    uint16_t es;		/* 11E: E segment		*/
+    uint16_t fs;		/* 120: F segment		*/
+    uint16_t gs;		/* 122: G segment		*/
+    /* xxx(gws): excluding FP support */
+    } HREG_SET;
+#else
+typedef struct			/* REG_SET - x86 register set	*/
+    {
+    uint32_t  edi;		/* 00: general register		*/
+    uint32_t  esi;		/* 04: general register		*/
+    uint32_t  ebp;		/* 08: frame pointer register	*/
+    uint32_t  esp;		/* 0C: stack pointer register	*/
+    uint32_t  ebx;		/* 10: general register		*/
+    uint32_t  edx;		/* 14: general register		*/
+    uint32_t  ecx;		/* 18: general register		*/
+    uint32_t  eax;		/* 1C: general register		*/
+    uint32_t  flags;		/* 20: status register		*/
+    INSTR    *pc;		/* 24: program counter		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr2;		/* 2C: control register 2	*/
+    uint32_t  cr3;		/* 30: control register 3	*/
+    uint32_t  cr4;		/* 34: control register 4	*/
+    uint32_t  cs;		/* 28: code segment		*/
+    uint32_t  ds;		/* 3C: data segment		*/
+    uint32_t  ss;		/* 40: stack segment		*/
+    uint32_t  es;		/* 44: E segment		*/
+    uint32_t  fs;		/* 48: F segment		*/
+    uint32_t  gs;		/* 4C: G segment		*/
+    uint32_t  tsp;		/* 50: transition stack pointer	*/
+    } HREG_SET;
+#endif
+
+typedef struct cpuid		/* CPUID - 80x86 cpuid version/feature */
+    {
+    int highestValue;		/* EAX=0: highest integer value */
+    int vendorId[3];		/* EAX=0: vendor identification string */
+    int signature;		/* EAX=1: processor signature */
+    int featuresEbx;		/* EAX=1: feature flags EBX */
+    int featuresEcx;		/* EAX=1: feature flags ECX */
+    int featuresEdx;		/* EAX=1: feature flags EDX */
+    int cacheEax;		/* EAX=2: config parameters EAX */
+    int cacheEbx;		/* EAX=2: config parameters EBX */
+    int cacheEcx;		/* EAX=2: config parameters ECX */
+    int cacheEdx;		/* EAX=2: config parameters EDX */
+    int serialNo64[2];		/* EAX=3: lower 64 of 96 bit serial no */
+    int brandString[12];	/* EAX=0x8000000[234]: brand strings */
+    } CPUID;
+
+
+/* CPUID fields in the EAX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t stepid:4;	/* processor stepping id mask	*/
+	uint32_t model:4;	/* processor model mask		*/
+	uint32_t family:4;	/* processor family mask	*/
+	uint32_t type:2;	/* processor type mask		*/
+	uint32_t reserved1:2;
+	uint32_t modelExt:4;	/* processor extended model mask */
+	uint32_t familyExt:8;	/* processor extended family mask */
+	uint32_t reserved2:4;
+	} field;
+    uint32_t value;
+    } CPUID_VERSION;
+
+#define CPUID_TYPE_ORIG		 0	/* type: original OEM		*/
+#define CPUID_TYPE_OVERD	 1	/* type: overdrive		*/
+#define CPUID_TYPE_DUAL		 2	/* type: dual			*/
+
+#define CPUID_FAMILY_486	 4	/* family: 486			*/
+#define CPUID_FAMILY_PENTIUM	 5	/* family: Pentium		*/
+#define CPUID_FAMILY_PENTIUMPRO  6	/* family: Pentium PRO		*/
+#define CPUID_FAMILY_EXTENDED	15	/* family: Extended		*/
+#define CPUID_FAMILY_PENTIUM4	 0	/* extended family: PENTIUM4	*/
+
+/* Pentium PRO family models */
+
+#define CPUID_MODEL_PPRO 	 1 	/* model: Pentium Pro		*/
+#define CPUID_MODEL_P2_OVER 	 2 	/* model: Pentium II Overdrive	*/
+#define CPUID_MODEL_P2_03 	 3 	/* model: Pentium II, model 03	*/
+#define CPUID_MODEL_P2_05 	 5 	/* model: Pentium II, model 05	*/
+#define CPUID_MODEL_CELERON_06 	 6 	/* model: Celeron, model 06	*/
+#define CPUID_MODEL_P3_07 	 7 	/* model: Pentium III, model 07	*/
+#define CPUID_MODEL_CORE2_E 	 7 	/* model: Core2 Extreme		*/
+#define CPUID_MODEL_P3_08 	 8 	/* model: Pentium III, model 08	*/
+#define CPUID_MODEL_PENTIUM_M 	 9 	/* model: Pentium M		*/
+#define CPUID_MODEL_P3_XEON	10 	/* model: Pentium III Xeon 	*/
+#define CPUID_MODEL_P3_0B 	11 	/* model: Pentium III, model 0B	*/
+#define CPUID_MODEL_PENTIUMM_0D	13 	/* model: Pentium M, model 0D	*/
+#define CPUID_MODEL_CORE 	14 	/* model: Core Duo/Solo		*/
+#define CPUID_MODEL_CORE2	15	/* model: Core2 Duo/Quad/Xeon	*/
+
+
+/* CPUID fields in the EBX register when EAX=1 */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t brand:8;	/* Brand index			*/
+	uint32_t flushSize:8;	/* CLFLUSH line size		*/
+	uint32_t nproc:8;	/* number of local processors	*/
+	uint32_t apicId:8;	/* local APIC id		*/
+	} field;
+    uint32_t value;
+    } CPUID_INFO;
+
+/* CPUID fields in the EDX register when EAX=1 */
+
+/* CPUID: feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t fpu:1;		/* FPU on chip			*/
+	uint32_t vme:1;		/* virtual 8086 mode enhancement*/
+	uint32_t de:1;		/* debugging extensions		*/
+	uint32_t pse:1;		/* page size extension		*/
+	uint32_t tsc:1;		/* time stamp counter		*/
+	uint32_t msr:1;		/* RDMSR and WRMSR support	*/
+	uint32_t pae:1;		/* physical address extensions	*/
+	uint32_t mce:1;		/* machine check exception	*/
+	uint32_t cx8:1;		/* CMPXCHG8 inst		*/
+	uint32_t apic:1;	/* APIC on chip			*/
+	uint32_t reserved1:1;
+	uint32_t sep:1;		/* SEP, Fast System Call	*/
+	uint32_t mtrr:1;	/* MTRR				*/
+	uint32_t pge:1;		/* PTE global bit		*/
+	uint32_t mca:1;		/* machine check arch.		*/
+	uint32_t cmov:1;	/* cond. move/cmp. inst		*/
+	uint32_t pat:1;		/* page attribute table		*/
+	uint32_t pse36:1;	/* 36 bit page size extension	*/
+	uint32_t psnum:1;	/* processor serial number	*/
+	uint32_t clflush:1;	/* CLFLUSH inst supported	*/
+	uint32_t reserved2:1;
+	uint32_t dts:1;		/* Debug Store			*/
+	uint32_t acpi:1;	/* TM and SCC supported		*/
+	uint32_t mmx:1;		/* MMX technology supported	*/
+	uint32_t fxsr:1;	/* fast FP save and restore	*/
+	uint32_t sse:1;		/* SSE supported		*/
+	uint32_t sse2:1;	/* SSE2 supported		*/
+	uint32_t ss:1;		/* Self Snoop supported		*/
+	uint32_t htt:1;		/* Hyper Threading Technology   */
+	uint32_t tm:1;		/* Thermal Monitor supported	*/
+	uint32_t ia64:1;	/* IA64 Capabilities		*/
+	uint32_t pbe:1;		/* Pend break enable		*/
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES;
+
+
+/* fields in the ECX register when EAX=1 */
+
+/* CPUID: extended feature bit definitions */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t sse3:1;	/* SSE3 Extensions		*/
+	uint32_t reserved1:1;
+	uint32_t dtes64:1;	/* 64-bit Debug Store		*/
+	uint32_t mon:1;		/* Monitor/wait			*/
+	uint32_t ds_cpl:1;	/* CPL qualified Debug Store	*/
+	uint32_t vmx:1;		/* Virtual Machine Technology	*/
+	uint32_t smx:1;		/* Safer Mode Extensions	*/
+	uint32_t est:1;		/* Enhanced Speedstep Technology*/
+	uint32_t tm2:1;		/* Thermal Monitor 2 supported	*/
+	uint32_t ssse3:1;	/* SSSE3 Extensions		*/
+	uint32_t cid:1;		/* L1 context ID		*/
+	uint32_t reserved2:2;
+	uint32_t cx16:1;	/* CMPXCHG16B			*/
+	uint32_t xtpr:1;	/* Update control		*/
+	uint32_t pdcm:1;	/* Performance/Debug capability	*/
+	uint32_t reserved3:2;
+	uint32_t dca:1;		/* Direct Cache Access		*/
+	uint32_t sse41:1;	/* SIMD Extensions 4.1		*/
+	uint32_t sse42:1;	/* SIMD Extensions 4.2		*/
+	uint32_t x2apic:1;	/* x2APIC supported		*/
+	uint32_t movbe:1;	/* MOVBE instruction supported	*/
+	uint32_t popcnt:1;	/* POPCNT instruction supported	*/
+	uint32_t reserved4:1;
+	uint32_t aes:1;		/* AES instruction supported	*/
+	uint32_t xsave:1;	/* XSAVE states supported	*/
+	uint32_t osxsave:1;	/* extended state management	*/
+	uint32_t reserved5:4;
+	} field;
+    uint32_t value;
+    } CPUID_FEATURES_EXT;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=4 */
+
+/* CPUID: deterministic cache parameters definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t type:5;	/* Cache type			*/
+	uint32_t level:3;	/* Cache level			*/
+	uint32_t self_init:1;	/* Self initialising cache	*/
+	uint32_t associative:1;	/* Fully associate cache	*/
+	uint32_t reserved1:4;
+	uint32_t threads:12;	/* Max threads sharing cache	*/
+	uint32_t proc:6;	/* Max processor cores per pkg	*/
+
+	/* EBX */
+
+	uint32_t cline_size:12;	/* Coherency line size		*/
+	uint32_t pline_size:10;	/* Physical line size		*/
+	uint32_t way:10;	/* Ways of associativity	*/
+
+	/* ECX */
+
+	uint32_t sets:32;	/* Number of sets		*/
+
+	/* EDX */
+
+	uint32_t stride:10;	/* Prefetch stride		*/
+	uint32_t reserved2:22;
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_CACHE;
+
+/* fields in the EAX/EBX/ECX/EDX register when EAX=11 */
+
+/* CPUID: x2APIC features / processor topology parameter definitions */
+
+typedef union
+    {
+    struct
+	{
+	/* EAX */
+
+	uint32_t apic_r_shift:5; /* number of bits to shift right */
+	uint32_t reserved1:27;
+
+	/* EBX */
+
+	uint32_t logical_proc:16; /* number of logical processor  */
+	uint32_t reserved2:16;
+
+	/* ECX */
+
+	uint32_t level:8;	 /* level number		   */
+	uint32_t type:8;	 /* level type			   */
+	uint32_t reserved3:16;
+
+	/* EDX */
+
+	uint32_t ext_apic_id;	/* extended APIC id		    */
+
+	} field;
+    struct
+	{
+	uint32_t eax;
+	uint32_t ebx;
+	uint32_t ecx;
+	uint32_t edx;
+	} value;
+    } CPUID_X2APIC;
+
+/* MSR_VMX_EPT_VPID_CAP: EPT and VPID Capabilities MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t rwx_support:3;	/* R W X support	*/
+	uint32_t gaw_support:5;	/* GAW support		*/
+	uint32_t emt_support:8;	/* EMT support		*/
+	uint32_t sp_support:4;	/* SP support		*/
+	uint32_t invept:1;	/* INVEPT supported	*/
+	uint32_t reserved1:3;
+	uint32_t invept_cap:8;	/* INVEPT capabilities	*/
+	uint32_t invpid:1;	/* INVPID supported	*/
+	uint32_t reserved2:7;
+	uint32_t invpid_cap:8;	/* INVPID capabilities	*/
+	uint32_t reserved3:16;
+	} field;
+    uint64_t value;
+    } EPT_VPID_CAP_MSR;
+
+typedef struct mtrr_fix		/* MTRR - fixed range register */
+    {
+    char type[8];
+    } MTRR_FIX;
+
+typedef struct mtrr_var		/* MTRR - variable range register */
+    {
+    long long int base;
+    long long int mask;
+    } MTRR_VAR;
+
+typedef struct mtrr		/* MTRR */
+    {
+    int cap[2];			/* MTRR cap register */
+    int deftype[2];		/* MTRR defType register */
+    MTRR_FIX fix[11];		/* MTRR fixed range registers */
+    MTRR_VAR var[8];		/* MTRR variable range registers */
+    } MTRR;
+
+typedef MTRR *		MTRR_ID;
+
+/*
+ * Structure of a global descriptor table (GDT) entry
+ * (common to 32 & 64 bits)
+ */
+
+typedef struct gdt_entry
+    {
+    uint16_t	limit00;	/* limit: xffff			*/
+    uint16_t	base00;		/* base : xxxx0000		*/
+    uint8_t	base01;		/* base : xx00xxxx		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint8_t	limit01:4;	/* limit: fxxxx			*/
+    uint8_t	free:1;		/* free bit			*/
+    uint8_t	l:1;		/* 64-bit code segment		*/
+    uint8_t	d_b:1;		/* access 0=16-bit 1=32-bit	*/
+    uint8_t	g:1;		/* page granularity		*/
+    uint8_t	base02;		/* base : 00xxxxxx		*/
+    } GDT_ENTRY;
+
+/* Structure of global descriptor table call entry in 32-bits mode */
+
+typedef struct gdt32_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	nparam:5;	/* number of parameters		*/
+    uint8_t	res1:3;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } GDT32_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 32-bits mode */
+
+typedef struct idt32_entry
+    {
+    uint16_t	offset00;	/* offset : xxxxffff		*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes) */
+    uint8_t	type:5;		/* Code e/r,			*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: ffffxxxx		*/
+    } IDT32_ENTRY;
+
+#ifdef	LP64
+/* Structure of global descriptor table call entry in 64-bits mode */
+
+typedef struct gdt64_call_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	res1;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	sys:1;		/* 0 = system segment		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } GDT64_CALL_ENTRY;
+
+/* Structure of interrupt descriptor table (IDT) entry in 64-bits mode */
+
+typedef struct idt64_entry
+    {
+    uint16_t	offset00;	/* offset: xxxxxxxxxxxxffff	*/
+    uint16_t	segment;	/* segment selector		*/
+    uint8_t	ist:3;		/* interrupt stack table	*/
+    uint8_t	res1:5;		/* reserved (zeroes)		*/
+    uint8_t	type:4;		/* Code e/r,			*/
+    uint8_t	res2:1;		/* reserved (zeroes)		*/
+    uint8_t	dpl:2;		/* descriptor priv level	*/
+    uint8_t	p:1;		/* present			*/
+    uint16_t	offset01;	/* offset: xxxxxxxxffffxxxx	*/
+    uint32_t	offset02;	/* offset: ffffffffxxxxxxxx	*/
+    uint32_t	res3;		/* reserved */
+    } IDT64_ENTRY;
+
+#define	GDT_CALL_ENTRY		GDT64_CALL_ENTRY
+#define	IDT_ENTRY		IDT64_ENTRY
+#else
+#define	GDT_CALL_ENTRY		GDT32_CALL_ENTRY
+#define	IDT_ENTRY		IDT32_ENTRY
+#endif	/* LP64 */
+
+
+#define	GDT_BASE00_SHIFT	00
+#define	GDT_BASE01_SHIFT	16
+#define	GDT_BASE02_SHIFT	24
+#define	GDT_BASE00_MASK		0x0000ffff
+#define	GDT_BASE01_MASK		0x00ff0000
+#define	GDT_BASE02_MASK		0xff000000
+
+#define	GDT_LIMIT00_SHIFT	00
+#define	GDT_LIMIT01_SHIFT	16
+#define	GDT_LIMIT00_MASK	0x0ffff
+#define	GDT_LIMIT01_MASK	0xf0000
+
+#define	GDT_BASE(p)	((p->base02 << GDT_BASE02_SHIFT) | \
+			 (p->base01 << GDT_BASE01_SHIFT) | p->base00)
+#define	GDT_LIMIT(p)	((p->limit01 << GDT_LIMIT01_SHIFT) | p->limit00)
+
+#define GDT_LIMIT00(v)	(((v) & GDT_LIMIT00_MASK) >> GDT_LIMIT00_SHIFT)
+#define GDT_LIMIT01(v)	(((v) & GDT_LIMIT01_MASK) >> GDT_LIMIT01_SHIFT)
+
+#define GDT_BASE00(v)	(((v) & GDT_BASE00_MASK) >> GDT_BASE00_SHIFT)
+#define GDT_BASE01(v)	(((v) & GDT_BASE01_MASK) >> GDT_BASE01_SHIFT)
+#define GDT_BASE02(v)	(((v) & GDT_BASE02_MASK) >> GDT_BASE02_SHIFT)
+
+/* GDT call entry macros */
+
+#define	GDT32_OFFSET00_SHIFT	00
+#define	GDT32_OFFSET01_SHIFT	16
+#define	GDT32_OFFSET00_MASK	0x0000ffff
+#define	GDT32_OFFSET01_MASK	0xffff0000
+
+#define	GDT32_OFFSET(p)		((p->offset01 << GDT32_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT32_OFFSET00(v)	(((v) & GDT32_OFFSET00_MASK) >> \
+				 GDT32_OFFSET00_SHIFT)
+#define GDT32_OFFSET01(v)	(((v) & GDT32_OFFSET01_MASK) >> \
+				 GDT32_OFFSET01_SHIFT)
+
+#ifdef	LP64
+#define	GDT64_OFFSET00_SHIFT	00
+#define	GDT64_OFFSET01_SHIFT	16
+#define	GDT64_OFFSET02_SHIFT	32
+#define	GDT64_OFFSET00_MASK	0x000000000000ffff
+#define	GDT64_OFFSET01_MASK	0x00000000ffff0000
+
+#define	GDT64_OFFSET(p)		((((uint64_t) p->offset02) << \
+					GDT64_OFFSET02_SHIFT) | \
+				 (p->offset01 << GDT64_OFFSET01_SHIFT) | \
+				 p->offset00)
+#define GDT64_OFFSET00(v)	((uint16_t)((((v) & GDT64_OFFSET00_MASK) >> \
+					    GDT64_OFFSET00_SHIFT)))
+#define GDT64_OFFSET01(v)	((uint16_t)((((v) & GDT64_OFFSET01_MASK) >> \
+					    GDT64_OFFSET01_SHIFT)))
+#define GDT64_OFFSET02(v)	((uint32_t)(((v) >> GDT64_OFFSET02_SHIFT)))
+
+#define	GDT_OFFSET		GDT64_OFFSET
+#define	GDT_OFFSET00		GDT64_OFFSET00
+#define	GDT_OFFSET01		GDT64_OFFSET01
+#define	GDT_OFFSET02		GDT64_OFFSET02
+#else	/* LP64 */
+#define	GDT_OFFSET		GDT32_OFFSET
+#define	GDT_OFFSET00		GDT32_OFFSET00
+#define	GDT_OFFSET01		GDT32_OFFSET01
+#endif
+
+/* IDT aliases */
+
+#define	IDT32_OFFSET(x)		GDT32_OFFSET(x)
+#define	IDT32_OFFSET00(x)	GDT32_OFFSET00(x)
+#define	IDT32_OFFSET01(x)	GDT32_OFFSET01(x)
+
+#ifdef	LP64
+#define	IDT64_OFFSET(x)		GDT64_OFFSET(x)
+#define	IDT64_OFFSET00(x)	GDT64_OFFSET00(x)
+#define	IDT64_OFFSET01(x)	GDT64_OFFSET01(x)
+#define	IDT64_OFFSET02(x)	GDT64_OFFSET02(x)
+
+#define	IDT_OFFSET		IDT64_OFFSET
+#define	IDT_OFFSET00		IDT64_OFFSET00
+#define	IDT_OFFSET01		IDT64_OFFSET01
+#define	IDT_OFFSET02		IDT64_OFFSET02
+#else	/* LP64 */
+#define	IDT_OFFSET		IDT32_OFFSET
+#define	IDT_OFFSET00		IDT32_OFFSET00
+#define	IDT_OFFSET01		IDT32_OFFSET01
+#define	IDT_OFFSET02		IDT32_OFFSET02
+#endif	/* LP64 */
+
+/* GDT data segment types */
+
+#define	GDT_TYPE_RO		0	/* read-only			   */
+#define	GDT_TYPE_RO_A		1	/* read-only accessed		   */
+#define	GDT_TYPE_RW		2	/* read-write			   */
+#define	GDT_TYPE_RW_A		3	/* read-write accessed		   */
+#define	GDT_TYPE_RO_DOWN	4	/* read-only expand-down	   */
+#define	GDT_TYPE_RO_DOWN_A	5	/* read-only expand-down accessed  */
+#define	GDT_TYPE_RW_DOWN	6	/* read-write expand-down	   */
+#define	GDT_TYPE_RW_DOWN_A	7	/* read-write expand-down accessed */
+#define	GDT_TYPE_EX		8	/* execute			   */
+#define	GDT_TYPE_EX_A		9	/* execute accessed		   */
+#define	GDT_TYPE_EX_RO		10	/* execute read-only		   */
+#define	GDT_TYPE_EX_RO_A	11	/* execute read-only accessed	   */
+#define	GDT_TYPE_EX_CF		12	/* execute conforming		   */
+#define	GDT_TYPE_EX_CF_A	13	/* execute conforming accessed	   */
+#define	GDT_TYPE_EX_RO_CF	14	/* execute read-only conforming	   */
+#define	GDT_TYPE_EX_RO_CF_A	15	/* execute r/o conforming accessed */
+
+/* GDT system segment types */
+
+#ifndef	LP64
+#define	GDT_TYPE_SYS_RES0	0	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT_TYPE_SYS_RES1	8	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT_TYPE_SYS_RES2	10	/* reserved			   */
+#define	GDT_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT_TYPE_SYS_RES3	13	/* reserved			   */
+#define	GDT_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+#else	/* !LP64 */
+#define	GDT32_TYPE_SYS_TSS16_A	1	/* 16-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define	GDT32_TYPE_SYS_TSS16_B	3	/* 16-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL16	4	/* 16-bit call gate		   */
+#define	GDT32_TYPE_SYS_TGATE	5	/* task gate			   */
+#define	GDT32_TYPE_SYS_IGATE16	6	/* 16-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE16	7	/* 16-bit trap gate		   */
+#define	GDT32_TYPE_SYS_TSS32_A	9	/* 32-bit TSS (available)	   */
+#define	GDT32_TYPE_SYS_TSS32_B	11	/* 32-bit TSS (busy)		   */
+#define	GDT32_TYPE_SYS_CALL32	12	/* 32-bit call gate		   */
+#define	GDT32_TYPE_SYS_IGATE32	14	/* 32-bit interrupt gate	   */
+#define	GDT32_TYPE_SYS_TGATE32	15	/* 32-bit trap gate		   */
+
+#define GDT_TYPE_SYS_LDT	2	/* local descriptor table	   */
+#define GDT_TYPE_SYS_TSS64_A	9	/* 64 bit TSS (available)	   */
+#define GDT_TYPE_SYS_TSS64_B	11	/* 64 bit TSS (busy)	           */
+#define	GDT_TYPE_SYS_CALL64	12	/* 64-bit call gate		   */
+#define	GDT_TYPE_SYS_IGATE64	14	/* 64-bit interrupt gate	   */
+#define	GDT_TYPE_SYS_TGATE63	15	/* 64-bit trap gate		   */
+#endif	/* !LP64 */
+/* GDT segment status */
+
+#define	GDT_SEG_INVALID		0	/* segment is not present	   */
+#define	GDT_SEG_VALID		1	/* segment is present		   */
+
+/* GDT segment type */
+
+#define	GDT_SEG_SYSTEM		0	/* system type segment 		   */
+#define	GDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* GDT access types */
+
+#define	GDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	GDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* GDT access types */
+
+#define	GDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	GDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* GDT access types */
+
+#define GDT_64_CODE_SEGMENT	1	/* 64-bit code segment		   */
+#define GDT_COMP_CODE_SEGMENT	0	/* compatible mode code segment	   */
+
+/* GDT privilidge level */
+
+#define	GDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	GDT_PRIV_RING_1		1	/* ring 1 priv level		   */
+#define	GDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	GDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* IDT segment types */
+
+#define	IDT_TYPE_RES0		0	/* reserved			   */
+#define	IDT_TYPE_RES1		1	/* reserved			   */
+#define	IDT_TYPE_RES2		2	/* reserved			   */
+#define	IDT_TYPE_RES3		3	/* reserved			   */
+#define	IDT_TYPE_RES4		4	/* reserved			   */
+#define	IDT_TYPE_TGATE		5	/* task gate			   */
+#define	IDT_TYPE_IGATE_16	6	/* 16-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE_16	7	/* 16-bit trap gate		   */
+#define	IDT_TYPE_RES8		8	/* reserved			   */
+#define	IDT_TYPE_RES9		9	/* reserved			   */
+#define	IDT_TYPE_RES10		10	/* reserved			   */
+#define	IDT_TYPE_RES11		11	/* reserved			   */
+#define	IDT_TYPE_RES12		12	/* reserved			   */
+#define	IDT_TYPE_RES13		13	/* reserved			   */
+#define	IDT_TYPE_IGATE		14	/* 32-bit interrupt gate	   */
+#define	IDT_TYPE_TRGATE		15	/* 32-bit trap gate		   */
+
+/* IDT segment status */
+
+#define	IDT_SEG_INVALID		0	/* segment is not present	   */
+#define	IDT_SEG_VALID		1	/* segment is present		   */
+
+/* IDT segment type */
+
+#define	IDT_SEG_SYSTEM		0	/* system type segment 		   */
+#define	IDT_SEG_CODE_DATA	1	/* code/data type segment	   */
+
+/* IDT access types */
+
+#define	IDT_ACCESS_16		0	/* 16-bit access to memory	   */
+#define	IDT_ACCESS_32		1	/* 32-bit access to memory	   */
+
+/* IDT access types */
+
+#define	IDT_GRAN_BYTE		0	/* byte size page granularity	   */
+#define	IDT_GRAN_4KB_PAGE	1	/* 4KB size page granularity	   */
+
+/* IDT privilidge level */
+
+#define	IDT_PRIV_RING_0		0	/* ring 0 priv level		   */
+#define	IDT_PRIV_RING_1		1	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_2		2	/* ring 2 priv level		   */
+#define	IDT_PRIV_RING_3		3	/* ring 3 priv level		   */
+
+/* structure of the global descriptor table register (GDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct 
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } GDTR32;
+
+#define	GDTR32_ADDR00_SHIFT	00
+#define	GDTR32_ADDR01_SHIFT	16
+#define	GDTR32_ADDR00_MASK	0x0000ffff
+#define	GDTR32_ADDR01_MASK	0xffff0000
+
+#define	GDTR32_ADDR(reg)	((reg.field.addr1 << GDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the GDT */
+	uint16_t addr0;		/* address of GDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct 
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } GDTR64;
+
+#define	GDTR64_ADDR00_SHIFT	00
+#define	GDTR64_ADDR01_SHIFT	16	
+#define	GDTR64_ADDR02_SHIFT	32	
+#define	GDTR64_ADDR03_SHIFT	48	
+#define	GDTR64_ADDR00_MASK	0x000000000000ffff
+#define	GDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	GDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	GDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	GDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					GDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+				 	GDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+				 	GDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	GDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	GDTR			GDTR64
+#define	GDTR_ADDR00_SHIFT	GDTR64_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR64_ADDR01_SHIFT
+#define	GDTR_ADDR02_SHIFT	GDTR64_ADDR02_SHIFT
+#define	GDTR_ADDR03_SHIFT	GDTR64_ADDR03_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR64_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR64_ADDR01_MASK
+#define	GDTR_ADDR02_MASK	GDTR64_ADDR02_MASK
+#define	GDTR_ADDR03_MASK	GDTR64_ADDR03_MASK
+#define	GDTR_ADDR		GDTR64_ADDR
+#define	GDTR_LIMIT		GDTR64_LIMIT
+#else	/* LP64 */
+#define	GDTR			GDTR32
+#define	GDTR_ADDR00_SHIFT	GDTR32_ADDR00_SHIFT
+#define	GDTR_ADDR01_SHIFT	GDTR32_ADDR01_SHIFT
+#define	GDTR_ADDR00_MASK	GDTR32_ADDR00_MASK
+#define	GDTR_ADDR01_MASK	GDTR32_ADDR01_MASK
+#define	GDTR_ADDR		GDTR32_ADDR
+#define	GDTR_LIMIT		GDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the interrupt descriptor table register (IDTR) */
+
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t padding;
+	} field;
+    struct 
+	{
+	uint64_t word0;		/* word 0 */
+	} words;
+    } IDTR32;
+
+#define	IDTR32_ADDR00_SHIFT	00
+#define	IDTR32_ADDR01_SHIFT	16
+#define	IDTR32_ADDR00_MASK	0x0000ffff
+#define	IDTR32_ADDR01_MASK	0xffff0000
+
+#define	IDTR32_ADDR(reg)	((reg.field.addr1 << IDTR32_ADDR01_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR32_LIMIT(reg)	(reg.field.limit)
+
+#ifdef	LP64
+typedef union
+    {
+    struct
+	{
+	uint16_t limit;		/* maximum size of the IDT */
+	uint16_t addr0;		/* address of IDT table */
+	uint16_t addr1;
+	uint16_t addr2;
+	uint16_t addr3;
+	uint16_t padding[3];
+	} field;
+    struct 
+	{
+	uint64_t word[2];		/* word 0 */
+	} words;
+    } IDTR64;
+
+#define	IDTR64_ADDR00_SHIFT	00
+#define	IDTR64_ADDR01_SHIFT	16	
+#define	IDTR64_ADDR02_SHIFT	32	
+#define	IDTR64_ADDR03_SHIFT	48	
+#define	IDTR64_ADDR00_MASK	0x000000000000ffff
+#define	IDTR64_ADDR01_MASK	0x00000000ffff0000
+#define	IDTR64_ADDR02_MASK	0x0000ffff00000000
+#define	IDTR64_ADDR03_MASK	0xffff000000000000
+
+#define	IDTR64_ADDR(reg)	(((uint64_t)reg.field.addr1 << \
+					IDTR64_ADDR01_SHIFT) | \
+				 ((uint64_t)reg.field.addr2 << \
+				 	IDTR64_ADDR02_SHIFT) | \
+				 ((uint64_t)reg.field.addr3 << \
+				 	IDTR64_ADDR03_SHIFT) | \
+				 reg.field.addr0)
+#define	IDTR64_LIMIT(reg)	(reg.field.limit)
+
+#define	IDTR			IDTR64
+#define	IDTR_ADDR00_SHIFT	IDTR64_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR64_ADDR01_SHIFT
+#define	IDTR_ADDR02_SHIFT	IDTR64_ADDR02_SHIFT
+#define	IDTR_ADDR03_SHIFT	IDTR64_ADDR03_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR64_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR64_ADDR01_MASK
+#define	IDTR_ADDR02_MASK	IDTR64_ADDR02_MASK
+#define	IDTR_ADDR03_MASK	IDTR64_ADDR03_MASK
+#define	IDTR_ADDR		IDTR64_ADDR
+#define	IDTR_LIMIT		IDTR64_LIMIT
+#else	/* LP64 */
+#define	IDTR			IDTR32
+#define	IDTR_ADDR00_SHIFT	IDTR32_ADDR00_SHIFT
+#define	IDTR_ADDR01_SHIFT	IDTR32_ADDR01_SHIFT
+#define	IDTR_ADDR00_MASK	IDTR32_ADDR00_MASK
+#define	IDTR_ADDR01_MASK	IDTR32_ADDR01_MASK
+#define	IDTR_ADDR		IDTR32_ADDR
+#define	IDTR_LIMIT		IDTR32_LIMIT
+#endif	/* LP64 */
+
+/* structure of the local descriptor table register (LDTR) */
+
+typedef uint32_t LDTR;
+
+/* x86 Task State Segment (TSS) */
+
+typedef struct tss
+    {
+#ifdef LP64
+    uint32_t  reserved0;	/* reserved */
+    uint64_t  rsp0;		/* privilege level 0 SP */
+    uint64_t  rsp1;		/* privilege level 1 SP */
+    uint64_t  rsp2;		/* privilege level 2 SP */
+    uint64_t  reserved1;	/* reserved */
+    uint64_t  ist1;		/* interrupt stack table ptr */
+    uint64_t  ist2;		/* interrupt stack table ptr */
+    uint64_t  ist3;		/* interrupt stack table ptr */
+    uint64_t  ist4;		/* interrupt stack table ptr */
+    uint64_t  ist5;		/* interrupt stack table ptr */
+    uint64_t  ist6;		/* interrupt stack table ptr */
+    uint64_t  ist7;		/* interrupt stack table ptr */
+    uint64_t  reserved2;	/* reserved */
+    uint16_t  reserved3;	/* reserved */
+    uint16_t  iomapb;		/* IO map base offset */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+#else
+    uint16_t  link;		/* link to previous task */
+    uint16_t  reserved0;	/* reserved */
+    uint32_t  esp0;		/* privilege level 0 SP */
+    uint16_t  ss0;		/*   ''              SS */
+    uint16_t  reserved1;	/* reserved */
+    uint32_t  esp1;		/* privilege level 1 SP */
+    uint16_t  ss1;		/*   ''              SS */
+    uint16_t  reserved3;	/* reserved */
+    uint32_t  esp2;		/* privilege level 2 SP */
+    uint16_t  ss2;		/*   ''              SS */
+    uint16_t  reserved4;	/* reserved */
+    uint32_t  cr3;		/* control register CR3 */
+    INSTR    *eip;		/* program counter  EIP */
+    uint32_t  eflags;		/* status register  EFLAGS */
+    uint32_t  eax;		/* general register EAX */
+    uint32_t  ecx;		/* general register ECX */
+    uint32_t  edx;		/* general register EDX */
+    uint32_t  ebx;		/* general register EBX */
+    uint32_t  esp;		/* stack pointer register ESP */
+    uint32_t  ebp;		/* frame pointer register EBP */
+    uint32_t  esi;		/* general register ESI */
+    uint32_t  edi;		/* general register EDI */
+    uint16_t  es;		/* segment selector ES */
+    uint16_t  reserved5;	/* reserved */
+    uint16_t  cs;		/* segment selector CS */
+    uint16_t  reserved6;	/* reserved */
+    uint16_t  ss;		/* segment selector SS */
+    uint16_t  reserved7;	/* reserved */
+    uint16_t  ds;		/* segment selector DS */
+    uint16_t  reserved8;	/* reserved */
+    uint16_t  fs;		/* segment selector FS */
+    uint16_t  reserved9;	/* reserved */
+    uint16_t  gs;		/* segment selector GS */
+    uint16_t  reserved10;	/* reserved */
+    uint16_t  ldt;		/* segment selector LDT */
+    uint16_t  reserved11;	/* reserved */
+    uint16_t  tflag;		/* debug trap flag T */
+    uint16_t  iomapb;		/* IO map base address */
+    uint32_t  iobmap[IO_BMAP_SIZE + 1];
+    uint32_t  reserved12;	/* TSS selector */
+    uint32_t  reserved13;
+    uint32_t  reserved14;
+    uint32_t  reserved15;
+    uint32_t  reserved16;
+    uint32_t  reserved17;
+    uint32_t  reserved18;
+    uint32_t  reserved19;
+#endif
+    } TSS;
+
+typedef struct segdesc		/* segment descriptor */
+    {
+    uint16_t	limitLW;	/* limit 15:00			*/
+    uint16_t	baseLW;		/* base address 15:00		*/
+    uint8_t	baseMB;		/* base address 23:16		*/
+    uint8_t	type;		/* P, DPL, S, Type		*/
+    uint8_t	limitUB;	/* G, DB, 0, AVL, limit 23:16	*/
+    uint8_t	baseUB;		/* base address 31:24		*/
+    } SEGDESC;
+
+typedef struct taskGate		/* task gate */
+    {
+    uint16_t    reserved1;	/* reserved1 15:00		*/
+    uint16_t    segment;	/* TSS segment selector 31:16	*/
+    uint16_t	reserved2:8;	/* reserved2 07:00		*/
+    uint8_t	type:5;		/* Type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    reserved3;      /* reserved3 31:16		*/
+    } TGATE_DESC;
+
+typedef struct callGate		/* call gate */
+    {
+    uint16_t	offsetLo;
+    uint16_t	selector;
+    uint8_t 	params;
+    uint8_t 	type;
+    uint16_t	offsetHi;
+   } CGATE_DESC;
+
+typedef struct intGate		/* interrupt gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } IGATE_DESC;
+
+#define	IGATE_OFFSET00_SHIFT	00
+#define	IGATE_OFFSET01_SHIFT	16
+#define	IGATE_OFFSET(p)	((p->offsetHi << IGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+
+typedef struct trapGate		/* trap gate */
+    {
+    uint16_t    offsetLo;	/* offset 15:00			*/
+    uint16_t    segment;	/* segment selector 31:16	*/
+    uint8_t	reserved:5;	/* reserved2 04:00		*/
+    uint8_t	zero:3;		/* zeros 07:05			*/
+    uint8_t	type:5;		/* type 12:08			*/
+    uint8_t	dpl:2;		/* DPL 14:13			*/
+    uint8_t	p:1;		/* present 15:15		*/
+    uint16_t    offsetHi;	/* offset 31:16			*/
+    } TRGATE_DESC;
+
+#define	TRGATE_OFFSET00_SHIFT	00
+#define	TRGATE_OFFSET01_SHIFT	16
+#define	TRGATE_OFFSET(p) ((p->offsetHi << TRGATE_OFFSET01_SHIFT) | p->offsetLo)
+
+/* convenience structure to access 32-bit fields of a 64-bit MSR */
+
+typedef union
+    {
+    struct
+	{
+	uint32_t low;		/* low 32-bits of value */
+	uint32_t high;		/* high 32-bits of value */
+	} field;
+    uint64_t word;		/* 64-bit MSR value */
+    } MSR_VALUE;
+ 
+/* some common names for registers */
+
+#define fpReg		ebp	/* frame pointer */
+#define	spReg		esp	/* stack pointer */
+#define reg_pc		pc	/* program counter */
+#define reg_sp		spReg	/* stack pointer */
+#define reg_fp		fpReg	/* frame pointer */
+
+#define  G_REG_BASE	0x00	/* data reg's base offset to HREG_SET */
+#define  G_REG_OFFSET(n)	(G_REG_BASE + (n)*sizeof(uint32_t))
+#define  SR_OFFSET		G_REG_OFFSET(GREG_NUM)
+#define  PC_OFFSET		(SR_OFFSET + sizeof(uint32_t))
+
+/* register access functions */
+
+extern _RType	x86CR0Get (void);
+extern void	x86CR0Set (_RType value);
+extern _RType	x86CR2Get (void);
+extern void	x86CR2Set (_RType value);
+extern _RType	x86CR3Get (void);
+extern void	x86CR3Set (_RType value);
+extern _RType	x86CR4Get (void);
+extern void	x86CR4Set (_RType value);
+extern void	x86GdtrGet (GDTR *value);
+extern void	x86GdtrSet (GDTR *value);
+extern void	x86IdtrGet (IDTR *value);
+extern void	x86IdtrSet (IDTR *value);
+extern void	x86LdtrGet (LDTR *value);
+extern void	x86LdtrSet (LDTR *value);
+extern _RType	x86TrGet (void);
+extern void	x86TrSet (_RType value);
+extern void	x86MsrGet (uint32_t addr, uint64_t *value);
+extern void	x86MsrSet (uint32_t addr, uint64_t *value);
+extern _RType	x86FlagsGet (void);
+extern _RType	x86CsGet (void);
+extern _RType	x86SsGet (void);
+extern _RType	x86DsGet (void);
+extern _RType	x86EsGet (void);
+extern _RType	x86FsGet (void);
+extern _RType	x86GsGet (void);
+extern void	x86TscGet (uint64_t *value);
+extern void	x86GetCpuid (uint32_t operation,
+			     uint32_t *eaxValue, uint32_t *ebxValue,
+			     uint32_t *ecxValue, uint32_t *edxValue);
+
+#endif	/* _ASMLANGUAGE */
+
+/* CPU FAMILY & FPU type */
+
+#define X86CPU_386	  0	/* CPU FAMILY: 80386		*/
+#define X86CPU_486	  1	/* CPU FAMILY: 80486		*/
+#define X86CPU_PENTIUM	  2	/* CPU FAMILY: Pentium/P5	*/
+#define X86CPU_NS486	  3	/* CPU FAMILY: NS486		*/
+#define X86CPU_PENTIUMPRO 4	/* CPU FAMILY: Pentiumpro/P6	*/
+#define X86CPU_PENTIUM4   5	/* CPU FAMILY: Pentium4/P7      */
+#define X86FPU_387	  1	/* FPU: 80387			*/
+#define X86FPU_487	  2	/* FPU: 80487			*/
+
+/* offset to registers in HREG_SET */
+
+#ifdef LP64
+#define HREG_RAX		0x00
+#define HREG_RBX		0x08
+#define HREG_RCX		0x10
+#define HREG_RDX		0x18
+#define HREG_RSP		0x20
+#define HREG_RBP		0x28
+#define HREG_RSI		0x30
+#define HREG_RDI		0x38
+#define HREG_R8			0x40
+#define HREG_R9			0x48
+#define HREG_R10		0x50
+#define HREG_R11		0x58
+#define HREG_R12		0x60
+#define HREG_R13		0x68
+#define HREG_R14		0x70
+#define HREG_R15		0x78
+#define HREG_PC			0x80
+#define HREG_RFLAGS		0x88
+#define HREG_CR0		0x90
+#define HREG_CR2		0x98
+#define HREG_CR3		0xa0
+#define HREG_CR4		0xa8
+#define HREG_TSP		0xb0
+#define HREG_CS			0xb8
+#define HREG_DS			0xba
+#define HREG_SS			0xbc
+#define HREG_ES			0xbe
+#define HREG_FS			0xc0
+#define HREG_GS			0xc2
+#else
+#define HREG_EDI		0x00
+#define HREG_ESI		0x04
+#define HREG_EBP		0x08
+#define HREG_ESP		0x0c
+#define HREG_EBX		0x10
+#define HREG_EDX		0x14
+#define HREG_ECX		0x18
+#define HREG_EAX		0x1c
+#define HREG_EFLAGS		0x20
+#define HREG_PC			0x24
+#define HREG_CR0		0x28
+#define HREG_CR2		0x2C
+#define HREG_CR3		0x30
+#define HREG_CR4		0x34
+#define HREG_CS			0x38
+#define HREG_DS			0x3C
+#define HREG_SS			0x40
+#define HREG_ES			0x44
+#define HREG_FS			0x48
+#define HREG_GS			0x4C
+#define HREG_TSP		0x50
+#endif /* LP64 */
+
+/* bits on EFLAGS */
+
+#define	EFLAGS_EMPTY	0x00000020	/* empty eflags */
+#define	EFLAGS_BRANDNEW	0x00000200	/* brand new EFLAGS */
+#define	EFLAGS_N_MASK	0xffffbfff	/* N(nested task flag) bit mask */
+#define	EFLAGS_TF_MASK	0xfffffeff	/* TF(trap flag) bit mask */
+
+#define	EFLAGS_CF	0x00000001	/* CF(carry flag) bit */
+#define	EFLAGS_PF	0x00000004	/* PF(parity flag) bit */
+#define	EFLAGS_AF	0x00000010	/* AF(borrow flag) bit */
+#define	EFLAGS_ZF	0x00000040	/* ZF(sero flag) bit */
+#define	EFLAGS_SF	0x00000080	/* AF(sign flag) bit */
+#define	EFLAGS_TF	0x00000100	/* TF(trap flag) bit */
+#define	EFLAGS_IF	0x00000200	/* IF(interrupt enable flag) bit */
+#define	EFLAGS_IOPL	0x00003000	/* IOPL(IO privilege level) bits */
+#define	EFLAGS_NT	0x00004000	/* NT(nested task flag) bit */
+#define	EFLAGS_RF	0x00010000	/* RF(resume flag) bit */
+#define	EFLAGS_VM	0x00020000	/* VM(virtual 8086 mode) bit */
+#define	EFLAGS_AC	0x00040000	/* AC(alignment check) bit */
+#define	EFLAGS_VIF	0x00080000	/* VIF(virtual int flag) bit */
+#define	EFLAGS_VIP	0x00100000	/* VIP(virtual int pending) bit */
+#define	EFLAGS_ID	0x00200000	/* ID(identification flag) bit */
+
+/* control and test registers */
+
+#define CR0		1
+#define CR1		2
+#define CR2		3
+#define CR3		4
+#define TR3		5
+#define TR4		6
+#define TR5		7
+#define TR6		8
+#define TR7		9
+
+/* bits on CR0 */
+
+#define CR0_PE		0x00000001	/* protection enable */
+#define CR0_MP		0x00000002	/* math present */
+#define CR0_EM		0x00000004	/* emulation */
+#define CR0_TS		0x00000008	/* task switch */
+#define CR0_ET		0x00000010	/* extension type */
+#define CR0_NE		0x00000020	/* numeric error */
+#define CR0_WP		0x00010000	/* write protect */
+#define CR0_AM		0x00040000	/* alignment mask */
+#define CR0_NW		0x20000000	/* not write through */
+#define CR0_CD		0x40000000	/* cache disable */
+#define CR0_PG		0x80000000	/* paging */
+#define CR0_NW_NOT	0xdfffffff	/* write through */
+#define CR0_CD_NOT	0xbfffffff	/* cache disable */
+
+/* bits on CR4 */
+
+#define CR4_VME		0x00000001	/* virtual-8086 mode extensions */
+#define CR4_PVI		0x00000002	/* protected-mode virtual interrupts */
+#define CR4_TSD		0x00000004	/* timestamp disable */
+#define CR4_DE		0x00000008	/* debugging extensions */
+#define CR4_PSE		0x00000010	/* page size extensions */
+#define CR4_PAE		0x00000020	/* physical address extension */
+#define CR4_MCE		0x00000040	/* machine check enable */
+#define CR4_PGE		0x00000080	/* page global enable */
+#define CR4_PCE		0x00000100	/* performance-monitoring enable */
+#define CR4_OSFXSR	0x00000200	/* use fxsave/fxrstor instructions */
+#define CR4_OSXMMEXCEPT	0x00000400	/* streaming SIMD exception */
+#define CR4_VMXE	0x00002000	/* virtual machine extensions */
+
+/* CPUID: signature bit definitions */
+
+#define CPUID_STEPID	0x0000000f	/* processor stepping id mask	*/
+#define CPUID_MODEL	0x000000f0	/* processor model mask		*/
+#define CPUID_FAMILY	0x00000f00	/* processor family mask	*/
+#define CPUID_TYPE	0x00003000	/* processor type mask		*/
+#define CPUID_EXT_MODEL	0x000f0000	/* processor extended model mask */
+#define CPUID_EXT_FAMILY 0x0ff00000	/* processor extended family mask */
+#define CPUID_486	0x00000400	/* family: 486			*/
+#define CPUID_PENTIUM	0x00000500	/* family: Pentium		*/
+#define CPUID_PENTIUMPRO 0x00000600	/* family: Pentium PRO		*/
+#define CPUID_EXTENDED	0x00000f00	/* family: Extended		*/
+#define CPUID_PENTIUM4	0x00000000	/* extended family: PENTIUM4	*/
+#define CPUID_ORIG      0x00000000	/* type: original OEM		*/
+#define CPUID_OVERD     0x00001000	/* type: overdrive		*/
+#define CPUID_DUAL      0x00002000	/* type: dual			*/
+#define CPUID_CHUNKS	0x0000ff00	/* bytes flushed by CLFLUSH mask */
+
+/* CPUID: feature bit definitions (EDX) */
+
+#define CPUID_FPU	0x00000001	/* FPU on chip			*/
+#define CPUID_VME	0x00000002	/* virtual 8086 mode enhancement*/
+#define CPUID_DE	0x00000004	/* debugging extensions		*/
+#define CPUID_PSE	0x00000008	/* page size extension		*/
+#define CPUID_TSC	0x00000010	/* time stamp counter		*/
+#define CPUID_MSR	0x00000020	/* RDMSR and WRMSR support	*/
+#define CPUID_PAE	0x00000040	/* physical address extensions	*/
+#define CPUID_MCE	0x00000080	/* machine check exception	*/
+#define CPUID_CXS	0x00000100	/* CMPXCHG8 inst		*/
+#define CPUID_APIC	0x00000200	/* APIC on chip			*/
+#define CPUID_SEP	0x00000800	/* SEP, Fast System Call	*/
+#define CPUID_MTRR	0x00001000	/* MTRR				*/
+#define CPUID_PGE	0x00002000	/* PTE global bit		*/
+#define CPUID_MCA	0x00004000	/* machine check arch.		*/
+#define CPUID_CMOV	0x00008000	/* cond. move/cmp. inst		*/
+#define CPUID_PAT	0x00010000	/* page attribute table		*/
+#define CPUID_PSE36	0x00020000	/* 36 bit page size extension	*/
+#define CPUID_PSNUM	0x00040000	/* processor serial number	*/
+#define CPUID_CLFLUSH	0x00080000	/* CLFLUSH inst supported	*/
+#define CPUID_DTS	0x00200000	/* Debug Store			*/
+#define CPUID_ACPI	0x00400000	/* TM and SCC supported		*/
+#define CPUID_MMX	0x00800000	/* MMX technology supported	*/
+#define CPUID_FXSR	0x01000000	/* fast FP save and restore	*/
+#define CPUID_SSE	0x02000000	/* SSE supported		*/
+#define CPUID_SSE2	0x04000000	/* SSE2 supported		*/
+#define CPUID_SS	0x08000000	/* Self Snoop supported		*/
+#define CPUID_HTT	0x10000000	/* Hyper Threading Technology   */
+#define CPUID_TM	0x20000000	/* Thermal Monitor supported	*/
+#define CPUID_IA64	0x40000000	/* IA64 Capabilities		*/
+#define CPUID_PBE	0x80000000	/* Pending Break Enable		*/
+
+/* CPUID: extended feature bit definitions (ECX) */
+
+#define CPUID_GV3	0x00000080	/* Geyserville 3 supported	*/
+
+#define CPUID_SSE3	0x00000001	/* SSE3 Extensions		*/
+#define CPUID_MULDQ	0x00000002	/* support PCLMULDQ instruction	*/
+#define CPUID_DTES64	0x00000004	/* 64-bit Debug Store		*/
+#define CPUID_MON	0x00000008	/* Monitor/wait			*/
+#define CPUID_DS_CPL	0x00000010	/* CPL qualified Debug Store	*/
+#define CPUID_VMX	0x00000020	/* Virtual Machine Technology	*/
+#define CPUID_SMX	0x00000040	/* Safer Mode Extensions	*/
+#define CPUID_EST	0x00000080	/* Enhanced Speedstep Technology*/
+#define CPUID_TM2	0x00000100	/* Thermal Monitor 2 supported	*/
+#define CPUID_SSSE3	0x00000200	/* SSSE3 Extensions		*/
+#define CPUID_CID	0x00000400	/* L1 context ID		*/
+#define CPUID_CX16	0x00002000	/* CMPXCHG16B			*/
+#define CPUID_XTPR	0x00004000	/* Update control		*/
+#define CPUID_PDCM	0x00008000	/* Performance/Debug capability	*/
+#define CPUID_DCA	0x00040000	/* Direct Cache Access		*/
+#define CPUID_SSE41	0x00080000	/* SIMD Extensions 4.1		*/
+#define CPUID_SSE42	0x00100000	/* SIMD Extensions 4.2		*/
+#define CPUID_x2APIC	0x00200000	/* x2APIC supported		*/
+#define CPUID_MOVBE	0x00400000	/* MOVBE instruction supported	*/
+#define CPUID_POPCNT	0x00800000	/* POPCNT instruction supported	*/
+#define CPUID_AES	0x02000000	/* AES instruction supported	*/
+#define CPUID_XSAVE	0x04000000	/* XSAVE states supported	*/
+#define CPUID_OSXSAVE	0x08000000	/* extended state management	*/
+
+/* CPUID: offset in CPUID structure */
+
+#define CPUID_HIGHVALUE		0	/* offset to highestValue	*/
+#define CPUID_VENDORID		4	/* offset to vendorId		*/
+#define CPUID_SIGNATURE		16	/* offset to signature		*/
+#define CPUID_FEATURES_EBX	20	/* offset to featuresEbx	*/
+#define CPUID_FEATURES_ECX	24	/* offset to featuresEcx	*/
+#define CPUID_FEATURES_EDX	28	/* offset to featuresEdx	*/
+#define CPUID_CACHE_EAX		32	/* offset to cacheEax		*/
+#define CPUID_CACHE_EBX		36	/* offset to cacheEbx		*/
+#define CPUID_CACHE_ECX		40	/* offset to cacheEcx		*/
+#define CPUID_CACHE_EDX		44	/* offset to cacheEdx		*/
+#define CPUID_SERIALNO		48	/* offset to serialNo64		*/
+#define CPUID_BRAND_STR		56	/* offset to brandString[0]	*/
+
+/* MSR_VMX_EPT_VPID_CAP: EOT abd VPID capabilities */
+
+#define	EPT_VPID_RWX_X_ONLY	0	/* execute only supported */
+#define	EPT_VPID_RWX_W_ONLY	1	/* write only supported */
+#define	EPT_VPID_RWX_XW_ONLY	2	/* execute and write supported */
+
+#define	EPT_VPID_GAW_21BITS	0x01	/* guest address width: 21-bits */
+#define	EPT_VPID_GAW_30BITS	0x02	/* guest address width: 30-bits */
+#define	EPT_VPID_GAW_39BITS	0x04	/* guest address width: 39-bits */
+#define	EPT_VPID_GAW_48BITS	0x08	/* guest address width: 48-bits */
+#define	EPT_VPID_GAW_57BITS	0x10	/* guest address width: 57-bits */
+
+#define	EPT_VPID_EMT_UC		0x01	/* EMT memory: uncached memory */
+#define	EPT_VPID_EMT_WC		0x02	/* EMT memory: write cache memory */
+#define	EPT_VPID_EMT_WT		0x10	/* EMT memory: write through memory */
+#define	EPT_VPID_EMT_WP		0x20	/* EMT memory: write protect memory */
+#define	EPT_VPID_EMT_WB		0x40	/* EMT memory: write back memory */
+
+#define	EPT_VPID_INVEPT_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVEPT_CTX	0x02	/* context sync */
+#define	EPT_VPID_INVEPT_GLOBAL	0x08	/* global sync */
+
+#define	EPT_VPID_INVVPID_INDV	0x01	/* individual address sync */
+#define	EPT_VPID_INVVPID_CTX_1	0x02	/* single-context sync */
+#define	EPT_VPID_INVVPID_CTX_A	0x08	/* all context sync */
+#define	EPT_VPID_INVVPID_CTX_G	0x20	/* single context sync, keep global */
+
+#define	EPT_VPID_SP_2MB		0x01	/* super page support: 2MB */
+#define	EPT_VPID_SP_1GB		0x02	/* super page support: 1GB */
+#define	EPT_VPID_SP_512GB	0x04	/* super page support: 512GB */
+#define	EPT_VPID_SP_256TB	0x08	/* super page support: 256TB */
+
+/* MSR, Model Specific Registers */
+
+/* MSR, P5 only */
+
+#define MSR_P5_MC_ADDR		0x0000
+#define MSR_P5_MC_TYPE		0x0001
+#define MSR_TSC			0x0010
+#define MSR_CESR                0x0011
+#define MSR_CTR0                0x0012
+#define MSR_CTR1                0x0013
+
+/* MSR, P5 and P6 */
+
+#define MSR_APICBASE		0x001b
+#define MSR_EBL_CR_POWERON	0x002a
+#define MSR_TEST_CTL		0x0033
+#define MSR_BIOS_UPDT_TRIG	0x0079
+#define MSR_BBL_CR_D0		0x0088	/* P6 only */
+#define MSR_BBL_CR_D1		0x0089	/* P6 only */
+#define MSR_BBL_CR_D2		0x008a	/* P6 only */
+#define MSR_BIOS_SIGN		0x008b
+#define MSR_PERFCTR0		0x00c1
+#define MSR_PERFCTR1		0x00c2
+#define MSR_MTRR_CAP		0x00fe
+#define MSR_BBL_CR_ADDR		0x0116	/* P6 only */
+#define MSR_BBL_CR_DECC		0x0118	/* P6 only */
+#define MSR_BBL_CR_CTL		0x0119	/* P6 only */
+#define MSR_BBL_CR_TRIG		0x011a	/* P6 only */
+#define MSR_BBL_CR_BUSY		0x011b	/* P6 only */
+#define MSR_BBL_CR_CTL3		0x011e	/* P6 only */
+#define MSR_SYSENTER_CS		0x0174	/* P6 + SEP only */
+#define MSR_SYSENTER_ESP	0x0175	/* P6 + SEP only */
+#define MSR_SYSENTER_EIP	0x0176	/* P6 + SEP only */
+#define MSR_MCG_CAP		0x0179
+#define MSR_MCG_STATUS		0x017a
+#define MSR_MCG_CTL		0x017b
+#define MSR_EVNTSEL0		0x0186
+#define MSR_EVNTSEL1		0x0187
+#define MSR_DEBUGCTLMSR		0x01d9
+#define MSR_LASTBRANCH_FROMIP	0x01db
+#define MSR_LASTBRANCH_TOIP	0x01dc
+#define MSR_LASTINT_FROMIP	0x01dd
+#define MSR_LASTINT_TOIP	0x01de
+#define MSR_ROB_CR_BKUPTMPDR6	0x01e0
+#define MSR_MTRR_PHYS_BASE0	0x0200
+#define MSR_MTRR_PHYS_MASK0	0x0201
+#define MSR_MTRR_PHYS_BASE1	0x0202
+#define MSR_MTRR_PHYS_MASK1	0x0203
+#define MSR_MTRR_PHYS_BASE2	0x0204
+#define MSR_MTRR_PHYS_MASK2	0x0205
+#define MSR_MTRR_PHYS_BASE3	0x0206
+#define MSR_MTRR_PHYS_MASK3	0x0207
+#define MSR_MTRR_PHYS_BASE4	0x0208
+#define MSR_MTRR_PHYS_MASK4	0x0209
+#define MSR_MTRR_PHYS_BASE5	0x020a
+#define MSR_MTRR_PHYS_MASK5	0x020b
+#define MSR_MTRR_PHYS_BASE6	0x020c
+#define MSR_MTRR_PHYS_MASK6	0x020d
+#define MSR_MTRR_PHYS_BASE7	0x020e
+#define MSR_MTRR_PHYS_MASK7	0x020f
+#define MSR_MTRR_FIX_00000	0x0250
+#define MSR_MTRR_FIX_80000	0x0258
+#define MSR_MTRR_FIX_A0000	0x0259
+#define MSR_MTRR_FIX_C0000	0x0268
+#define MSR_MTRR_FIX_C8000	0x0269
+#define MSR_MTRR_FIX_D0000	0x026a
+#define MSR_MTRR_FIX_D8000	0x026b
+#define MSR_MTRR_FIX_E0000	0x026c
+#define MSR_MTRR_FIX_E8000	0x026d
+#define MSR_MTRR_FIX_F0000	0x026e
+#define MSR_MTRR_FIX_F8000	0x026f
+#define MSR_MTRR_DEFTYPE	0x02ff
+#define MSR_MC0_CTL		0x0400
+#define MSR_MC0_STATUS		0x0401
+#define MSR_MC0_ADDR		0x0402
+#define MSR_MC0_MISC		0x0403
+#define MSR_MC1_CTL		0x0404
+#define MSR_MC1_STATUS		0x0405
+#define MSR_MC1_ADDR		0x0406
+#define MSR_MC1_MISC		0x0407
+#define MSR_MC2_CTL		0x0408
+#define MSR_MC2_STATUS		0x0409
+#define MSR_MC2_ADDR		0x040a
+#define MSR_MC2_MISC		0x040b
+#define MSR_MC4_CTL		0x040c
+#define MSR_MC4_STATUS		0x040d
+#define MSR_MC4_ADDR		0x040e
+#define MSR_MC4_MISC		0x040f
+#define MSR_MC3_CTL		0x0410
+#define MSR_MC3_STATUS		0x0411
+#define MSR_MC3_ADDR		0x0412
+#define MSR_MC3_MISC		0x0413
+
+/* MSR, Core2 */
+
+#define	MSR_FSB_FREQ		0x00cd
+
+/* MSR, VMX specific */
+
+#define	MSR_VMX_FEATURE			0x003A
+#define	MSR_VMX_BASIC			0x0480
+#define MSR_VMX_PINBASED_CTLS_MSR	0x0481
+#define MSR_VMX_PROCBASED_CTLS_MSR	0x0482
+#define MSR_VMX_EXIT_CTLS_MSR		0x0483
+#define MSR_VMX_ENTRY_CTLS_MSR		0x0484
+#define MSR_VMX_MISC_MSR		0x0485
+#define MSR_VMX_CR0_FIXED0		0x0486
+#define MSR_VMX_CR0_FIXED1		0x0487
+#define MSR_VMX_CR4_FIXED0		0x0488
+#define MSR_VMX_CR4_FIXED1		0x0489
+#define MSR_VMX_PROCBASED_CTLS2_MSR	0x048B
+#define MSR_VMX_EPT_VPID_CAP		0x048C
+
+/* MSR, Architectural MSRs (common MSRs in IA32) */
+
+#define	IA32_P5_MC_ADDR		MSR_P5_MC_ADDR		/* P5 */
+#define	IA32_P5_MC_TYPE		MSR_P5_MC_TYPE		/* P5 */
+#define	IA32_TIME_STAMP_COUNTER	MSR_TSC			/* P5 */
+#define	IA32_PLATFORM_ID	0x0017			/* P6 */
+#define	IA32_APIC_BASE		MSR_APICBASE		/* P6 */
+#define	IA32_BIOS_UPDT_TRIG	MSR_BIOS_UPDT_TRIG	/* P6 */
+#define	IA32_BIOS_SIGN_ID	MSR_BIOS_SIGN		/* P6 */
+#define	IA32_MTRRCAP		MSR_MTRR_CAP		/* P6 */
+#define	IA32_MISC_CTL		MSR_BBL_CR_CTL		/* P6 */
+#define	IA32_SYSENTER_CS	MSR_SYSENTER_CS		/* P6 */
+#define	IA32_SYSENTER_ESP	MSR_SYSENTER_ESP	/* P6 */
+#define	IA32_SYSENTER_EIP	MSR_SYSENTER_EIP	/* P6 */
+#define	IA32_MCG_CAP		MSR_MCG_CAP		/* P6 */
+#define	IA32_MCG_STATUS		MSR_MCG_STATUS		/* P6 */
+#define	IA32_MCG_CTL		MSR_MCG_CTL		/* P6 */
+#define	IA32_MCG_EAX		0x0180			/* Pentium4 */
+#define	IA32_MCG_EBX		0x0181			/* Pentium4 */
+#define	IA32_MCG_ECX		0x0182			/* Pentium4 */
+#define	IA32_MCG_EDX		0x0183			/* Pentium4 */
+#define	IA32_MCG_ESI		0x0184			/* Pentium4 */
+#define	IA32_MCG_EDI		0x0185			/* Pentium4 */
+#define	IA32_MCG_EBP		0x0186			/* Pentium4 */
+#define	IA32_MCG_ESP		0x0187			/* Pentium4 */
+#define	IA32_MCG_EFLAGS		0x0188			/* Pentium4 */
+#define	IA32_MCG_EIP		0x0189			/* Pentium4 */
+#define	IA32_MCG_MISC		0x018a			/* Pentium4 */
+#define	IA32_THERM_CONTROL	0x019a			/* Pentium4 */
+#define	IA32_THERM_INTERRUPT	0x019b			/* Pentium4 */
+#define	IA32_THERM_STATUS	0x019c			/* Pentium4 */
+#define	IA32_MISC_ENABLE	0x01a0			/* Pentium4 */
+#define	IA32_DEBUGCTL		MSR_DEBUGCTLMSR		/* P6 */
+#define	IA32_MTRR_PHYSBASE0	MSR_MTRR_PHYS_BASE0	/* P6 */
+#define	IA32_MTRR_PHYSMASK0	MSR_MTRR_PHYS_MASK0	/* P6 */
+#define	IA32_MTRR_PHYSBASE1	MSR_MTRR_PHYS_BASE1	/* P6 */
+#define	IA32_MTRR_PHYSMASK1	MSR_MTRR_PHYS_MASK1	/* P6 */
+#define	IA32_MTRR_PHYSBASE2	MSR_MTRR_PHYS_BASE2	/* P6 */
+#define	IA32_MTRR_PHYSMASK2	MSR_MTRR_PHYS_MASK2	/* P6 */
+#define	IA32_MTRR_PHYSBASE3	MSR_MTRR_PHYS_BASE3	/* P6 */
+#define	IA32_MTRR_PHYSMASK3	MSR_MTRR_PHYS_MASK3	/* P6 */
+#define	IA32_MTRR_PHYSBASE4	MSR_MTRR_PHYS_BASE4	/* P6 */
+#define	IA32_MTRR_PHYSMASK4	MSR_MTRR_PHYS_MASK4	/* P6 */
+#define	IA32_MTRR_PHYSBASE5	MSR_MTRR_PHYS_BASE5	/* P6 */
+#define	IA32_MTRR_PHYSMASK5	MSR_MTRR_PHYS_MASK5	/* P6 */
+#define	IA32_MTRR_PHYSBASE6	MSR_MTRR_PHYS_BASE6	/* P6 */
+#define	IA32_MTRR_PHYSMASK6	MSR_MTRR_PHYS_MASK6	/* P6 */
+#define	IA32_MTRR_PHYSBASE7	MSR_MTRR_PHYS_BASE7	/* P6 */
+#define	IA32_MTRR_PHYSMASK7	MSR_MTRR_PHYS_MASK7	/* P6 */
+#define	IA32_MTRR_FIX64K_00000	MSR_MTRR_FIX_00000	/* P6 */
+#define	IA32_MTRR_FIX16K_80000	MSR_MTRR_FIX_80000	/* P6 */
+#define	IA32_MTRR_FIX16K_A0000	MSR_MTRR_FIX_A0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C0000	MSR_MTRR_FIX_C0000	/* P6 */
+#define	IA32_MTRR_FIX4K_C8000	MSR_MTRR_FIX_C8000	/* P6 */
+#define	IA32_MTRR_FIX4K_D0000	MSR_MTRR_FIX_D0000	/* P6 */
+#define	IA32_MTRR_FIX4K_D8000	MSR_MTRR_FIX_D8000	/* P6 */
+#define	IA32_MTRR_FIX4K_E0000	MSR_MTRR_FIX_E0000	/* P6 */
+#define	IA32_MTRR_FIX4K_E8000	MSR_MTRR_FIX_E8000	/* P6 */
+#define	IA32_MTRR_FIX4K_F0000	MSR_MTRR_FIX_F0000	/* P6 */
+#define	IA32_MTRR_FIX4K_F8000	MSR_MTRR_FIX_F8000	/* P6 */
+#define	IA32_CR_PAT		0x0277			/* P6 */
+#define	IA32_MTRR_DEF_TYPE	MSR_MTRR_DEFTYPE	/* P6 */
+#define	IA32_PEBS_ENABLE	0x03f1			/* Pentium4 */
+#define	IA32_MC0_CTL		MSR_MC0_CTL		/* P6 */
+#define	IA32_MC0_STATUS		MSR_MC0_STATUS		/* P6 */
+#define	IA32_MC0_ADDR		MSR_MC0_ADDR		/* P6 */
+#define	IA32_MC0_MISC		MSR_MC0_MISC		/* P6 */
+#define	IA32_MC1_CTL		MSR_MC1_CTL		/* P6 */
+#define	IA32_MC1_STATUS		MSR_MC1_STATUS		/* P6 */
+#define	IA32_MC1_ADDR		MSR_MC1_ADDR		/* P6 */
+#define	IA32_MC1_MISC		MSR_MC1_MISC		/* P6 */
+#define	IA32_MC2_CTL		MSR_MC2_CTL		/* P6 */
+#define	IA32_MC2_STATUS		MSR_MC2_STATUS		/* P6 */
+#define	IA32_MC2_ADDR		MSR_MC2_ADDR		/* P6 */
+#define	IA32_MC2_MISC		MSR_MC2_MISC		/* P6 */
+#define	IA32_MC3_CTL		0x040c			/* P6, addr changed */
+#define	IA32_MC3_STATUS		0x040d			/* P6, addr changed */
+#define	IA32_MC3_ADDR		0x040e			/* P6, addr changed */
+#define	IA32_MC3_MISC		0x040f			/* P6, addr changed */
+#define	IA32_DS_AREA		0x0600			/* Pentium4 */
+#define	IA32_PERF_STAT		0x0198			/* Core2 */ 
+#define	IA32_EFER		0xc0000080		/* Core2 - extended feature */ 
+
+/* MSR, IA32_DEBUGCTL, in Pentium4, bits */
+
+#define	DBG_P7_LBR		0x00000001
+#define	DBG_P7_BTF		0x00000002
+#define	DBG_P7_TR		0x00000004
+#define	DBG_P7_BTS		0x00000008
+#define	DBG_P7_BTINT		0x00000010
+
+/* MSR, IA32_DEBUGCTL, in P6, bits */
+
+#define	DBG_P6_LBR		0x00000001
+#define	DBG_P6_BTF		0x00000002
+#define	DBG_P6_PB0		0x00000004
+#define	DBG_P6_PB1		0x00000008
+#define	DBG_P6_PB2		0x00000010
+#define	DBG_P6_PB3		0x00000020
+#define	DBG_P6_TR		0x00000040
+
+/* MSR, MSR_LASTBRANCH_TOS, in Pentium4, bits */
+
+#define	TOS_MASK		0x00000003
+
+/* MSR, IA32_MISC_ENABLE bits */
+
+#define	MSC_FAST_STRING_ENABLE	0x00000001
+#define	MSC_FOPCODE_ENABLE	0x00000004
+#define	MSC_THERMAL_MON_ENABLE	0x00000008
+#define	MSC_SPLIT_LOCK_DISABLE	0x00000010
+#define	MSC_PMON_AVAILABLE	0x00000080
+#define	MSC_BTS_UNAVAILABLE	0x00000800
+#define	MSC_PEBS_UNAVAILABLE	0x00001000
+#define	MSC_GV1_EN		0x00008000
+#define	MSC_GV3_EN		0x00010000
+#define	MSC_GV_SEL_LOCK		0x00100000
+#define	MSC_LEAF_REPORTING	0x00400000
+
+/* MSR, IA32_PEBS_ENABLE bits */
+
+#define	PEBS_METRICS		0x00001fff
+#define	PEBS_UOP_TAG		0x01000000
+#define	PEBS_ENABLE		0x02000000
+
+/* MSR, IA32_PLATFORM_ID bits (upper 32) */
+
+#define	PFM_PLATFORM_ID		0x001c0000
+#define	PFM_MOBILE_GV		0x00040000
+
+/* MSR, IA32_PLATFORM_ID bits (lower 32) */
+
+#define	PFM_MAX_VID		0x0000003f
+#define	PFM_MAX_FREQ		0x00000f80
+#define	PFM_RATIO_LOCKED	0x00008000
+#define	PFM_GV3_TM_DISABLED	0x00010000
+#define	PFM_GV3_DISABLED	0x00020000
+#define	PFM_GV1_DISABLED	0x00040000
+#define	PFM_TM_DISABLED		0x00080000
+#define	PFM_L2_CACHE_SIZE	0x06000000
+#define	PFM_SAMPLE		0x08000000
+
+/* MSR, IA32_THERM_CONTROL bits */
+
+#define	THERM_DUTY_CYCLE	0x0000000e
+#define	THERM_TCC_EN		0x00000010
+
+/* MSR, IA32_THERM_STATUS bits */
+
+#define	THERM_HOT_NOW		0x00000001
+#define	THERM_HOT_LOG		0x00000002
+
+/* MSR, IA32_THERM_INTERRUPT bits */
+
+#define	THERM_HOT_INT_EN	0x00000001
+#define	THERM_COLD_INT_EN	0x00000002
+
+/* PMC, Performance Monitoring Event Select MSR bits */
+
+/* P5 specific */
+
+#define P5PMC_PC                0x00000200
+#define P5PMC_CC_DISABLE        0x00000000
+#define P5PMC_CC_EVT_CPL012     0x00000040
+#define P5PMC_CC_EVT_CPL3       0x00000080
+#define P5PMC_CC_EVT            0x000000C0
+#define P5PMC_CC_CLK_CPL012     0x00000140
+#define P5PMC_CC_CLK_CPL3       0x00000180
+#define P5PMC_CC_CLK            0x000001C0
+
+/* P6 specific */
+
+#define PMC_USR               0x00010000
+#define PMC_OS                0x00020000
+#define PMC_E                 0x00040000
+#define PMC_PC                0x00080000
+#define PMC_INT               0x00100000
+#define PMC_EN                0x00400000
+#define PMC_INV               0x00800000
+
+/* MSR, MSR_VMX_ENTRY_CTLS bits */
+
+#define VMX_ENTRY_CTLS_IA32e		0x00000200
+#define VMX_ENTRY_CTLS_SMM		0x00000400
+#define VMX_ENTRY_CTLS_DUAL		0x00000800
+
+/* MSR, MSR_VMX_EXIT_CTLS_MSR bits */
+
+#define VMX_EXIT_CTLS_64BIT		0x00000200
+#define VMX_EXIT_CTLS_IACK		0x00008000
+
+/* MSR, IA32_EFER bits */
+
+#define EFER_SCE 	0x00000001 	/* SYSCALL/SYSRET (bit 0) */
+#define EFER_LME 	0x00000100  	/* Long mode enable (bit 8) */
+#define EFER_LMA	0x00000400 	/* Long mode active (r/o) 10 */
+#define EFER_NX 	0x00000800 	/* No execute enable (bit 11) */
+
+/* PMC, Performance Monitoring Events */
+
+/* P5 PMC event list */
+
+#define P5PMC_DATA_RD			0x00
+#define P5PMC_DATA_WR			0x01
+#define P5PMC_DATA_TBL_MISS		0x02
+#define P5PMC_DATA_RD_MISS		0x03
+#define P5PMC_DATA_WR_MISS		0x04
+#define P5PMC_WR_HIT_M_E_STATE_LINE	0x05
+#define P5PMC_DCACHE_WR_BACK		0x06
+#define P5PMC_EXT_SNOOPS		0x07
+#define P5PMC_EXT_DCACHE_SNOOPS_HIT	0x08
+#define P5PMC_MEM_ACCESS_BOTH_PIPES	0x09
+#define P5PMC_BANK_CONFLICT		0x0A
+#define P5PMC_MISC_DMEM_IO_REF		0x0B
+#define P5PMC_CODE_RD			0x0C
+#define P5PMC_CODE_TBL_MISS		0x0D
+#define P5PMC_CODE_CACHE_MISS		0x0E
+#define P5PMC_SEGMENT_REG_LOAD		0x0F
+#define P5PMC_BRANCH			0x12
+#define P5PMC_BTB_HIT			0x13
+#define P5PMC_TAKEN_BRANCH_BTB_HIT	0x14
+#define P5PMC_PIPELINE_FLUSH		0x15
+#define P5PMC_INST_EXECUTED		0x16
+#define P5PMC_INST_EXECUTED_VPIPE	0x17
+#define P5PMC_BUS_CYC_DURATION		0x18
+#define P5PMC_WR_BUF_FULL_STALL_DURATION 0x19
+#define P5PMC_WAIT_MEM_RD_STALL_DURATION 0x1A
+#define P5PMC_STALL_ON_WR_M_E_STATE_LINE 0x1B
+#define P5PMC_LOCKED_BUS_CYC		0x1C
+#define P5PMC_IO_RD_WR_CYC		0x1D
+#define P5PMC_NONCACHE_MEM_RD		0x1E
+#define P5PMC_PIPELINE_AGI_STALL	0x1F
+#define P5PMC_FLOPS			0x22
+#define P5PMC_BK_MATCH_DR0		0x23
+#define P5PMC_BK_MATCH_DR1		0x24
+#define P5PMC_BK_MATCH_DR2		0x25
+#define P5PMC_BK_MATCH_DR3		0x26
+#define P5PMC_HW_INT			0x27
+#define P5PMC_DATA_RD_WR		0x28
+#define P5PMC_DATA_RD_WR_MISS		0x29
+#define P5PMC_BUS_OWNER_LATENCY		0x2A
+#define P5PMC_BUS_OWNER_TRANSFER	0x2A
+#define P5PMC_MMX_INST_UPIPE		0x2B
+#define P5PMC_MMX_INST_VPIPE		0x2B
+#define P5PMC_CACHE_M_LINE_SHARE	0x2C
+#define P5PMC_CACHE_LINE_SHARE		0x2C
+#define P5PMC_EMMS_INTS_EXECUTED	0x2D
+#define P5PMC_TRANS_MMX_FP_INST		0x2D
+#define P5PMC_BUS_UTIL_PROCESSOR_ACT	0x2D
+#define P5PMC_WR_NOCACHEABLE_MEM	0x2E
+#define P5PMC_SATURATING_MMX_INST	0x2F
+#define P5PMC_SATURATION_PERFORMED	0x2F
+#define P5PMC_NUM_CYC_NOT_HALT_STATE	0x30
+#define P5PMC_DCACHE_TLB_MISS_STALL_DUR	0x30
+#define P5PMC_MMX_INST_DATA_RD		0x31
+#define P5PMC_MMX_INST_DATA_RD_MISS	0x31
+#define P5PMC_FP_STALL_DUR		0x32
+#define P5PMC_TAKEN_BRANCH		0x32
+#define P5PMC_D1_STARV_FIFO_EMPTY	0x33
+#define P5PMC_D1_STARV_ONE_INST_FIFO	0x33
+#define P5PMC_MMX_INST_DATA_WR		0x34
+#define P5PMC_MMX_INST_DATA_WR_MISS	0x34
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC	0x35
+#define P5PMC_PL_FLUSH_WRONG_BR_PREDIC_WB 0x35
+#define P5PMC_MISALIGN_DMEM_REF_MMX 	0x36
+#define P5PMC_PL_STALL_MMX_DMEM_RD 	0x36
+#define P5PMC_MISPREDIC_UNPREDIC_RET 	0x37
+#define P5PMC_PREDICED_RETURN 		0x37
+#define P5PMC_MMX_MUL_UNIT_INTERLOCK 	0x38
+#define P5PMC_MOVD_MOVQ_STALL_PREV_MMX 	0x38
+#define P5PMC_RETURN 			0x39
+#define P5PMC_BTB_FALSE_ENTRY		0x3A
+#define P5PMC_BTB_MISS_PREDIC_NOT_TAKEN_BR 0x3A
+#define P5PMC_FULL_WR_BUF_STALL_MMX 	0x3B
+#define P5PMC_STALL_MMX_WR_E_M_STATE_LINE 0x3B
+
+/* P6 PMC event list */
+
+#define	PMC_DATA_MEM_REFS		0x43
+#define	PMC_DCU_LINES_IN		0x45
+#define	PMC_DCU_M_LINES_IN		0x46
+#define	PMC_DCU_M_LINES_OUT		0x47
+#define	PMC_DCU_MISS_OUTSTANDING	0x48
+#define	PMC_IFU_IFETCH			0x80
+#define	PMC_IFU_IFETCH_MISS		0x81
+#define	PMC_ITLB_MISS			0x85
+#define	PMC_IFU_MEM_STALL		0x86
+#define	PMC_IDL_STALL			0x87
+#define	PMC_L2_IFETCH			0x28
+#define	PMC_L2_LD			0x29
+#define	PMC_L2_ST			0x2a
+#define	PMC_L2_LINES_IN			0x24
+#define	PMC_L2_LINES_OUT		0x26
+#define	PMC_L2_M_LINES_INM		0x25
+#define	PMC_L2_M_LINES_OUTM		0x27
+#define	PMC_L2_RQSTS			0x2e
+#define	PMC_L2_ADS			0x21
+#define	PMC_L2_DBUS_BUSY		0x22
+#define	PMC_L2_DBUS_BUSY_RD		0x23
+#define	PMC_BUS_DRDY_CLOCKS		0x62
+#define	PMC_BUS_LOCK_CLOCKS		0x63
+#define	PMC_BUS_REQ_OUTSTANDING		0x60
+#define	PMC_BUS_TRAN_BRD		0x65
+#define	PMC_BUS_TRAN_RFO		0x66
+#define	PMC_BUS_TRANS_WB		0x67
+#define	PMC_BUS_TRAN_IFETCH		0x68
+#define	PMC_BUS_TRAN_INVAL		0x69
+#define	PMC_BUS_TRAN_PWR		0x6a
+#define	PMC_BUS_TRANS_P			0x6b
+#define	PMC_BUS_TRANS_IO		0x6c
+#define	PMC_BUS_TRAN_DEF		0x6d
+#define	PMC_BUS_TRAN_BURST		0x6e
+#define	PMC_BUS_TRAN_ANY		0x70
+#define	PMC_BUS_TRAN_MEM		0x6f
+#define	PMC_BUS_DATA_RCV		0x64
+#define	PMC_BUS_BNR_DRV			0x61
+#define	PMC_BUS_HIT_DRV			0x7a
+#define	PMC_BUS_HITM_DRV		0x7b
+#define	PMC_BUS_SNOOP_STALL		0x7e
+#define	PMC_FLOPS			0xc1
+#define	PMC_FP_COMP_OPS_EXE		0x10
+#define	PMC_FP_ASSIST			0x11
+#define	PMC_MUL				0x12
+#define	PMC_DIV				0x13
+#define	PMC_CYCLES_DIV_BUSY		0x14
+#define	PMC_LD_BLOCKS			0x03
+#define	PMC_SB_DRAINS			0x04
+#define	PMC_MISALIGN_MEM_REF		0x05
+#define	PMC_INST_RETIRED		0xc0
+#define	PMC_UOPS_RETIRED		0xc2
+#define	PMC_INST_DECODER		0xd0
+#define	PMC_HW_INT_RX			0xc8
+#define	PMC_CYCLES_INT_MASKED		0xc6
+#define	PMC_CYCLES_INT_PENDING_AND_MASKED 0xc7
+#define	PMC_BR_INST_RETIRED		0xc4
+#define	PMC_BR_MISS_PRED_RETIRED	0xc5
+#define	PMC_BR_TAKEN_RETIRED		0xc9
+#define	PMC_BR_MISS_PRED_TAKEN_RETIRED	0xca
+#define	PMC_BR_INST_DECODED		0xe0
+#define	PMC_BTB_MISSES			0xe2
+#define	PMC_BR_BOGUS			0xe4
+#define	PMC_BACLEARS			0xe6
+#define	PMC_RESOURCE_STALLS		0xa2
+#define	PMC_PARTIAL_RAT_STALLS		0xd2
+#define	PMC_SEGMENT_REG_LOADS		0x06
+#define	PMC_CPU_CLK_UNHALTED		0x79
+#define	PMC_UMASK_00			0x00
+#define	PMC_UMASK_0F			0x0f
+#define	PMC_UMASK_SELF			0x00
+#define	PMC_UMASK_ANY			0x20
+
+/* MTRR related defines */
+
+#define MTRR_UC				0x00
+#define MTRR_WC				0x01
+#define MTRR_WT				0x04
+#define MTRR_WP				0x05
+#define MTRR_WB				0x06
+#define MTRR_E				0x00000800
+#define MTRR_FE				0x00000400
+#define MTRR_VCNT			0x000000FF
+#define MTRR_FIX_SUPPORT		0x00000100
+#define MTRR_WC_SUPPORT			0x00000400
+
+/* MCA related defines */
+
+#define	MCG_CTL_P			0x00000100
+#define	MCG_COUNT			0x000000ff
+#define	MCG_MCIP			0x00000004
+#define	MCG_EIPV			0x00000002
+#define	MCG_RIPV			0x00000001
+#define	MCI_VAL				0x80000000
+#define	MCI_OVER			0x40000000
+#define	MCI_UC				0x20000000
+#define	MCI_EN				0x10000000
+#define	MCI_MISCV			0x08000000
+#define	MCI_ADDRV			0x04000000
+#define	MCI_PCC				0x02000000
+
+/* segment descriptor: types for application code, data segment */
+
+#define	SEG_DATA_RO_U		0x00000000	/* read only */
+#define	SEG_DATA_RW_U		0x00000200	/* read write */
+#define	SEG_DATA_RO_D		0x00000400	/* read only expand down */
+#define	SEG_DATA_RW_D		0x00000600	/* read write expand down */
+#define	SEG_CODE_EO		0x00000800	/* exec only */
+#define	SEG_CODE_ER		0x00000a00	/* exec read */
+#define	SEG_CODE_EO_C		0x00000c00	/* exec only conform. */
+#define	SEG_CODE_ERO_C		0x00000e00	/* exec read only conform. */
+
+/* segment descriptor: types for system segment and gate */
+
+#define SEG_LDT			0x00000200	/* LDT */
+#define TASK_GATE		0x00000500	/* Task Gate */
+#define TSS32			0x00000900	/* 32 bit TSS (available) */
+#define CALL_GATE32		0x00000c00	/* 32 bit CALL gate */
+#define INT_GATE32		0x00000e00	/* 32 bit INT  gate */
+#define TRAP_GATE32		0x00000f00	/* 32 bit TRAP gate */
+
+/* segment descriptor: descriptor type */
+
+#define SYS_DESC		0x00000000	/* system descriptors */
+#define APP_DESC		0x00001000	/* application descriptors */
+
+/* segment descriptor: privilege level */
+
+#define DPL0			0x00000000	/* privilege level 0 */
+#define DPL1			0x00002000	/* privilege level 1 */
+#define DPL2			0x00004000	/* privilege level 2 */
+#define DPL3			0x00006000	/* privilege level 3 */
+
+/* segment descriptor: privilege level */
+
+#define SEG_P			0x00008000	/* present */
+
+/* segment descriptor: default operation size */
+
+#define DB_16			0x00000000	/* 16 bit segment */
+#define DB_32			0x00400000	/* 32 bit segment */
+
+/* segment descriptor: granularity */
+
+#define G_BYTE			0x00000000	/* byte granularity */
+#define G_4K			0x00800000	/* 4K byte granularity */
+
+/* segment descriptor: mask bits for attribute */
+
+#define SEG_ATTR_MASK		0x00f0ff00	/* mask bits */
+
+/* segment descriptor: pSegdesc->type: present and busy bit */
+
+#define SEG_PRESENT		0x80		/* present bit */
+#define SEG_BUSY		0x02		/* busy bit */
+
+/* segment register requested privilege levels */
+
+#define	SEG_RPL_RING_0		0x0
+#define	SEG_RPL_RING_1		0x1
+#define	SEG_RPL_RING_2		0x2
+#define	SEG_RPL_RING_3		0x3
+#define	SEG_RPL_MASK		0x3
+
+/* IDT related macros */
+
+#define IDT_TASK_GATE 		0x0000e500 	/* task gate: P=1, DPL=3, task id */
+
+#define IDT_TRAP_GATE 		0x0000ef00 	/* trap gate: P=1, DPL=3, trap id */
+#define IDT_INT_GATE  		0x0000ee00 	/* int gate: P=1, DPL=3, int id */
+
+/* TSS related macros */
+
+#define TSS_LINK		  0	/* offset: link to previous task */
+#define TSS_ESP0		  4	/* offset: privilege level 0 SP */
+#define TSS_SS0	  		  8	/* offset:   ''              SS */
+#define TSS_ESP1		 12	/* offset: privilege level 1 SP */
+#define TSS_SS1	 		 16	/* offset:   ''              SS */
+#define TSS_ESP2		 20	/* offset: privilege level 2 SP */
+#define TSS_SS2			 24	/* offset:   ''              SS */
+#define TSS_CR3			 28	/* offset: control register CR3 */
+#define TSS_EIP			 32	/* offset: program counter  EIP */
+#define TSS_EFLAGS		 36	/* offset: status register  EFLAGS */
+#define TSS_EAX			 40	/* offset: general register EAX */
+#define TSS_ECX			 44	/* offset: general register ECX */
+#define TSS_EDX			 48	/* offset: general register EDX */
+#define TSS_EBX			 52	/* offset: general register EBX */
+#define TSS_ESP			 56	/* offset: stack pointer ESP */
+#define TSS_EBP			 60	/* offset: frame pointer EBP */
+#define TSS_ESI			 64	/* offset: general register ESI */
+#define TSS_EDI			 68	/* offset: general register EDI */
+#define TSS_ES			 72	/* offset: segment selector ES */
+#define TSS_CS			 76	/* offset: segment selector CS */
+#define TSS_SS			 80	/* offset: segment selector SS */
+#define TSS_DS			 84	/* offset: segment selector DS */
+#define TSS_FS			 88	/* offset: segment selector FS */
+#define TSS_GS			 92	/* offset: segment selector GS */
+#define TSS_LDT			 96	/* offset: segment selector LDT */
+#define TSS_TFLAG		100	/* offset: debug trap flag T */
+#define TSS_IOMAPB		102	/* offset: IO map base address */
+#define TSS_IOBMAP		104	/* offset: IO bit map array */
+
+#define TSS_BUSY_MASK	0xfffffdff	/* TSS descriptor BUSY bit mask */
+
+/* VMX realted defines */
+
+#define	VMX_MEMORY_TYPE_UC	0	/* Strong uncacheable (UC) */
+#define	VMX_MEMORY_TYPE_WB	6	/* Write back (WB) */
+
+/* inline version of intLock()/intUnlock() : used in mmuI86Lib.c */
+
+#define INT_LOCK(oldLevel) \
+    WRS_ASM ("pushf ; popl %0 ; andl $0x00000200, %0 ; cli" \
+    : "=rm" (oldLevel) : /* no input */ : "memory")
+
+#define INT_UNLOCK(oldLevel) \
+    WRS_ASM ("testl $0x00000200, %0 ; jz 0f ; sti ; 0:" \
+    : /* no output */ : "rm" (oldLevel) : "memory")
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __INCx86regsh */
diff --git a/include/vbi/x86/vbiX86Arch.h b/include/vbi/x86/vbiX86Arch.h
new file mode 100644
index 0000000..72421b3
--- /dev/null
+++ b/include/vbi/x86/vbiX86Arch.h
@@ -0,0 +1,194 @@
+/* vbiX86Arch.h - x86 architecture specific definitions */
+
+/* Copyright 2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01i,31aug09,mmi  move VBI_HREG_SET to vbiX86Arch.h
+01h,26aug09,mmi  fix WIND00178026: update file name
+01g,17aug09,md   fix comments
+01f,14aug09,md   update to match hypervisor version
+01e,28jul09,mpk  add hardware register set to vbi
+01d,08jun09,md   add define for maximum number of cores
+01c,25may09,md   add byte order define
+01b,06feb09,mmi  add MAX interrupts definition
+01a,14jan09,mmi  created
+*/
+
+#ifndef __INCvbiX86Archh
+#define __INCvbiX86Archh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_HREG_SET - hardware register set, for read/write
+*
+* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
+* another VB
+* 
+* SYNOPSIS
+*
+* VB hardware register set C data structure type definition
+*
+*\cs
+*     typedef struct		/@ VB_REG_SET - used for sys_regsRead/Write @/
+*         {
+*         uint32_t  eax;	/@ 00: general register		@/
+*         uint32_t  ebx;	/@ 04: general register		@/
+*         uint32_t  ecx;	/@ 08: general register		@/
+*         uint32_t  edx;	/@ 0C: general register		@/
+*         uint32_t  esi;	/@ 10: general register		@/
+*         uint32_t  edi;	/@ 14: general register		@/
+*         uint32_t  eip;	/@ 18: program counter		@/
+*         uint32_t  ebp;	/@ 1C: frame pointer register	@/
+*         uint32_t  esp;	/@ 20: stack pointer register	@/
+*         uint32_t  eflags;	/@ 24: status register		@/
+*         uint32_t  cr0;	/@ 28: control register 0	@/
+*         uint32_t  cr3;	/@ 2C: control register 3	@/
+*         uint32_t  cr4;	/@ 30: control register 4	@/
+*         uint32_t  idtr;	/@ 34: IDT task register	@/
+*         uint32_t  gdtr;	/@ 38: GDT task register	@/
+*         uint32_t  ldtr;	/@ 3C: LDT task register	@/
+*         uint32_t  cs;		/@ 40: code segment		@/
+*         uint32_t  ss;		/@ 44: stack segment		@/
+*         uint32_t  ds;		/@ 48: data segment		@/
+*         uint32_t  es;		/@ 4C: E segment		@/
+*         uint32_t  fs;		/@ 50: F segment		@/
+*         uint32_t  gs;		/@ 54: G segment		@/
+*         uint32_t  tr;		/@ 58: task register		@/
+*         } VB_HREG_SET;
+*
+*\ce
+* SEE ALSO: NONE
+* 
+*/
+
+typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
+    {
+    uint32_t  eax;		/* 00: general register		*/
+    uint32_t  ebx;		/* 04: general register		*/
+    uint32_t  ecx;		/* 08: general register		*/
+    uint32_t  edx;		/* 0C: general register		*/
+    uint32_t  esi;		/* 10: general register		*/
+    uint32_t  edi;		/* 14: general register		*/
+    uint32_t  eip;		/* 18: program counter		*/
+    uint32_t  ebp;		/* 1C: frame pointer register	*/
+    uint32_t  esp;		/* 20: stack pointer register	*/
+    uint32_t  eflags;		/* 24: status register		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr3;		/* 2C: control register 3	*/
+    uint32_t  cr4;		/* 30: control register 4	*/
+    uint32_t  idtr;		/* 34: IDT task register	*/
+    uint32_t  gdtr;		/* 38: GDT task register	*/
+    uint32_t  ldtr;		/* 3C: LDT task register	*/
+    uint32_t  cs;		/* 40: code segment		*/
+    uint32_t  ss;		/* 44: stack segment		*/
+    uint32_t  ds;		/* 48: data segment		*/
+    uint32_t  es;		/* 4C: E segment		*/
+    uint32_t  fs;		/* 50: F segment		*/
+    uint32_t  gs;		/* 54: G segment		*/
+    uint32_t  tr;		/* 58: task register		*/
+    } VBI_HREG_SET;
+
+#endif /* _ASMLANGUAGE */
+
+/* x86 uses little endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
+
+#define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_ARCH_EXC_TABLE_SIZE     32
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)            
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+#define VBI_IN_DIVIDE_ERROR		 0
+#define VBI_IN_DEBUG			 1
+#define VBI_IN_NON_MASKABLE		 2
+#define VBI_IN_BREAKPOINT		 3
+#define VBI_IN_OVERFLOW			 4
+#define VBI_IN_BOUND			 5
+#define VBI_IN_INVALID_OPCODE		 6
+#define VBI_IN_NO_DEVICE		 7
+#define VBI_IN_DOUBLE_FAULT		 8
+#define VBI_IN_CP_OVERRUN		 9
+#define VBI_IN_INVALID_TSS		10
+#define VBI_IN_NO_SEGMENT		11
+#define VBI_IN_STACK_FAULT		12
+#define VBI_IN_PROTECTION_FAULT		13
+#define VBI_IN_PAGE_FAULT		14
+#define VBI_IN_RESERVED			15
+#define VBI_IN_CP_ERROR			16
+#define VBI_IN_ALIGNMENT		17
+#define VBI_IN_MACHINE_CHECK		18
+#define VBI_IN_SIMD			19
+
+/* 19-31 Intel reserved exceptions  */
+
+/* 32-255 user defined exceptions  */
+
+#define VBI_IN_EXT_IRQ_BASE		32	/* local timer interrupt */
+
+#define VBI_IN_EXT_IRQ0			(VBI_IN_EXT_IRQ_BASE + 0)	
+#define VBI_IN_EXT_IRQ1			(VBI_IN_EXT_IRQ_BASE + 1)	
+#define VBI_IN_EXT_IRQ2			(VBI_IN_EXT_IRQ_BASE + 2)	
+#define VBI_IN_EXT_IRQ3 		(VBI_IN_EXT_IRQ_BASE + 3)	
+#define VBI_IN_EXT_IRQ4			(VBI_IN_EXT_IRQ_BASE + 4)	
+#define VBI_IN_EXT_IRQ5			(VBI_IN_EXT_IRQ_BASE + 5)	
+#define VBI_IN_EXT_IRQ6			(VBI_IN_EXT_IRQ_BASE + 6)	
+#define VBI_IN_EXT_IRQ7			(VBI_IN_EXT_IRQ_BASE + 7)	
+#define VBI_IN_EXT_IRQ8			(VBI_IN_EXT_IRQ_BASE + 8)	
+#define VBI_IN_EXT_IRQ9			(VBI_IN_EXT_IRQ_BASE + 9)	
+#define VBI_IN_EXT_IRQ10		(VBI_IN_EXT_IRQ_BASE + 10)	
+#define VBI_IN_EXT_IRQ11		(VBI_IN_EXT_IRQ_BASE + 11)	
+#define VBI_IN_EXT_IRQ12		(VBI_IN_EXT_IRQ_BASE + 12)	
+#define VBI_IN_EXT_IRQ13		(VBI_IN_EXT_IRQ_BASE + 13)	
+#define VBI_IN_EXT_IRQ14		(VBI_IN_EXT_IRQ_BASE + 14)	
+#define VBI_IN_EXT_IRQ15		(VBI_IN_EXT_IRQ_BASE + 15)	
+#define VBI_IN_EXT_IRQ16		(VBI_IN_EXT_IRQ_BASE + 16)	
+#define VBI_IN_EXT_IRQ17		(VBI_IN_EXT_IRQ_BASE + 17)	
+#define VBI_IN_EXT_IRQ18		(VBI_IN_EXT_IRQ_BASE + 18)	
+#define VBI_IN_EXT_IRQ19		(VBI_IN_EXT_IRQ_BASE + 19)	
+#define VBI_IN_EXT_IRQ20		(VBI_IN_EXT_IRQ_BASE + 20)	
+#define VBI_IN_EXT_IRQ21		(VBI_IN_EXT_IRQ_BASE + 21)	
+#define VBI_IN_EXT_IRQ22		(VBI_IN_EXT_IRQ_BASE + 22)	
+#define VBI_IN_EXT_IRQ23		(VBI_IN_EXT_IRQ_BASE + 23)	
+#define VBI_IN_EXT_IRQ24		(VBI_IN_EXT_IRQ_BASE + 24)	
+#define VBI_IN_EXT_IRQ25		(VBI_IN_EXT_IRQ_BASE + 25)	
+#define VBI_IN_EXT_IRQ26		(VBI_IN_EXT_IRQ_BASE + 26)	
+#define VBI_IN_EXT_IRQ27		(VBI_IN_EXT_IRQ_BASE + 27)	
+#define VBI_IN_EXT_IRQ28		(VBI_IN_EXT_IRQ_BASE + 28)	
+#define VBI_IN_EXT_IRQ29		(VBI_IN_EXT_IRQ_BASE + 29)	
+#define VBI_IN_EXT_IRQ30		(VBI_IN_EXT_IRQ_BASE + 30)	
+#define VBI_IN_EXT_IRQ31		(VBI_IN_EXT_IRQ_BASE + 31)	
+#define VBI_IN_EXT_IRQ32		(VBI_IN_EXT_IRQ_BASE + 32)	
+#define VBI_IN_EXT_IRQ33		(VBI_IN_EXT_IRQ_BASE + 33)	
+#define VBI_IN_EXT_IRQ34		(VBI_IN_EXT_IRQ_BASE + 34)	
+#define VBI_IN_EXT_IRQ35		(VBI_IN_EXT_IRQ_BASE + 35)	
+#define VBI_IN_EXT_IRQ36		(VBI_IN_EXT_IRQ_BASE + 36)	
+#define VBI_IN_EXT_IRQ37		(VBI_IN_EXT_IRQ_BASE + 37)	
+#define VBI_IN_EXT_IRQ38		(VBI_IN_EXT_IRQ_BASE + 38)	
+#define VBI_IN_EXT_IRQ39		(VBI_IN_EXT_IRQ_BASE + 39)	
+#define VBI_IN_EXT_IRQ40		(VBI_IN_EXT_IRQ_BASE + 40)	
+#define VBI_IN_EXT_IRQ41		(VBI_IN_EXT_IRQ_BASE + 41)	
+#define VBI_IN_EXT_IRQ42		(VBI_IN_EXT_IRQ_BASE + 42)	
+#define VBI_IN_EXT_IRQ43		(VBI_IN_EXT_IRQ_BASE + 43)	
+#define VBI_IN_EXT_IRQ44		(VBI_IN_EXT_IRQ_BASE + 44)	
+#define VBI_IN_EXT_IRQ45		(VBI_IN_EXT_IRQ_BASE + 45)	
+#define VBI_IN_EXT_IRQ46		(VBI_IN_EXT_IRQ_BASE + 46)	
+#define VBI_IN_EXT_IRQ47		(VBI_IN_EXT_IRQ_BASE + 47)	
+
+/* timer vector */
+
+#define VBI_CLOCK_TIMER_VECTOR		(0)
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)    
+#ifdef __cplusplus
+}
+#endif
+#endif /* __INCVbiX86Archh */
-- 
1.6.5.rc1

