From b119490328f0d58c46be3cdbe669c5ac47430100 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 22 Mar 2010 15:49:14 -0400
Subject: [PATCH] MILS: powerpc updates

Integration of the powerpc updates to the shim layer
from KeithB in order to support powerpc.  This will be
merged into the shim layer commit at the next rebase.

Also folded in are:

MILS: add in new syscalls for x86
MILS: clean up x86 syscall declarations
fix demux of MILS syscalls
MILS: fix compile warning on missing VBI 2.0 structs
vdk_port: add struct PortConfig
vdk_port: tag as GPL
more compat definitions for MILS
MILS: fix port status and port config in interface struct.
MILS: namelen sync, fix proto definitions.
MILS: relocate reboot stub to where it is used

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h        |    1 +
 arch/powerpc/kernel/vbi/vdk_syscalls.S |  292 +++++++++++++++++++++++--------
 arch/powerpc/kernel/vbi/wrhv.c         |   46 +++++-
 arch/x86/kernel/vbi/vdk_syscalls.S     |  132 ++++++++++++++-
 include/vbi/compat.h                   |    7 +-
 include/vbi/syscall.h                  |    2 +-
 include/vbi/vdk_interface.h            |   16 +-
 include/vbi/vdk_port.h                 |   41 ++++-
 include/vbi/vdk_syscalls.h             |   16 ++-
 9 files changed, 449 insertions(+), 104 deletions(-)

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 6495671..996d85b 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -25,6 +25,7 @@ extern void wrhv_init_irq(void);
 extern void __init wrhv_calibrate_decr(void);
 extern void __init wrhv_time_init(void);
 extern int __init wrhv_earlycon_setup(void);
+extern int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags);
 #ifdef CONFIG_PCI
 extern int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev);
 #endif
diff --git a/arch/powerpc/kernel/vbi/vdk_syscalls.S b/arch/powerpc/kernel/vbi/vdk_syscalls.S
index 974af7e..df4141a 100644
--- a/arch/powerpc/kernel/vbi/vdk_syscalls.S
+++ b/arch/powerpc/kernel/vbi/vdk_syscalls.S
@@ -22,6 +22,7 @@
 #include <asm/cputable.h>
 #include <asm/asm-offsets.h>
 #include <asm/cache.h>
+#include <asm/vbi.h>
 #include <vbi/vdk_syscalls.h>
 
 #ifdef CONFIG_PPC85xx_VT_MODE   /* not currently implemented */
@@ -30,19 +31,25 @@
 #define HCALL sc
 #endif
 
+#ifdef CONFIG_PPC85xx_VT_MODE	/* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
 
-#define FUNC_LABEL(func) _GLOBAL(func)
-#define FUNC_EXPORT(func)
-#define FUNC_END(func)
-#define _WRS_TEXT_SEG_START
-#define HI(sym) sym@h
-#define HIADJ(sym) sym@ha
-#define LO(sym) sym@l
+FUNC_EXPORT(vbi_virt_to_phys)
+FUNC_EXPORT(vbi_enable_vmmu)
+FUNC_EXPORT(vbi_config_vmmu)
+FUNC_EXPORT(vbi_flush_dcache)
+FUNC_EXPORT(vbi_flush_icache)
+FUNC_EXPORT(vbi_exec_vec_base_addr_set)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_int_controller_done)
 
 _WRS_TEXT_SEG_START
 
 #define vbi_hcall(name, call)		\
-FUNC_EXPORT(name)			\
 FUNC_LABEL(name)			\
 	lis r0, HI(VBI_SYS_##call);	\
 	ori r0, r0, LO(VBI_SYS_##call);	\
@@ -52,97 +59,230 @@ FUNC_END(name)
 
 
 /*
-*
-* vbi_flush_icache - flush the instruction cache
-*
-* This system call flushes the instruction cache for the specified address
-* range.
-*
-*/
-
+ * vbi_flush_icache - flush the instruction cache
+ *
+ * This system call flushes the instruction cache for the specified address
+ * range.
+ *
+ */
 vbi_hcall(vbi_flush_icache,icache_flush)
 
 /*
-*
-* vbi_flush_dcache - flush the data cache
-*
-* This system call flushes the data cache for the specified address range.
-*
-*/
-
+ * vbi_flush_dcache - flush the data cache
+ *
+ * This system call flushes the data cache for the specified address range.
+ *
+ */
 vbi_hcall(vbi_flush_dcache,dcache_flush)
 
 /*
-*
-* vbi_vmmu_config - configure the hypervisor virtual MMU
-*
-* This system call configures the context's virtual MMU within the hypervisor.
-*
-*/
-
+ * vbi_vmmu_config - configure the hypervisor virtual MMU
+ *
+ * This system call configures the context's virtual MMU within the hypervisor.
+ *
+ */
 vbi_hcall(vbi_config_vmmu,vmmu_config)
 
 /*
-*
-* vbi_vmmu_enable - enables the virtual MMU
-*
-* This system call enables a context's virtual MMU.
-*
-*/
-
+ * vbi_vmmu_enable - enables the virtual MMU
+ *
+ * This system call enables a context's virtual MMU.
+ *
+ */
 vbi_hcall(vbi_enable_vmmu,vmmu_enable)
 
 /*
-*
-* vbi_vmmu_disable - disable the virtual MMU
-*
-* This system call disables a context's virtual MMU.
-*
-*/
-
+ * vbi_vmmu_disable - disable the virtual MMU
+ *
+ * This system call disables a context's virtual MMU.
+ *
+ */
 vbi_hcall(vbi_disable_vmmu,vmmu_disable)
 
 /*
-*
-* vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
-*
-* This system call loads the TLB entries for the specified address range into
-* the virtual MMU.
-*
-*/
-
+ * vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
+ *
+ * This system call loads the TLB entries for the specified address range into
+ * the virtual MMU.
+ *
+ */
 vbi_hcall(vbi_tlb_load_vmmu,vmmu_tlbload)
 
 /*
-*
-* vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
-*
-* This system call flushes the TLB entries for the specified address range
-* from the virtual MMU.
-*
-*/
-
+ * vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
+ *
+ * This system call flushes the TLB entries for the specified address range
+ * from the virtual MMU.
+ *
+ */
 vbi_hcall(vbi_tlb_flush_vmmu,vmmu_tlbflush)
 
 /*
-*
-* vbiExcVecBaseSet - set current partition exception vector base address
-*
-* This system call sets the calling partition exception vector base address.
-*
-*/
-
+ * vbiExcVecBaseSet - set current partition exception vector base address
+ *
+ * This system call sets the calling partition exception vector base address.
+ *
+ */
 vbi_hcall(vbi_exec_vec_base_addr_set,excVecBaseSet)
 
 /*
-*
-* vbi_virt_to_phys - convert a guest OS address to a physical address
-*
-* This system call converts a guest OS address to a physical address
-*
-* HAE API vbiPaddr uses this system call.
-*
-*/
-
+ * vbi_virt_to_phys - convert a guest OS address to a physical address
+ *
+ * This system call converts a guest OS address to a physical address
+ *
+ * HAE API vbiPaddr uses this system call.
+ *
+ */
 vbi_hcall(vbi_virt_to_phys,virtToPhys)
 
+
+/*
+ * vbi_int_controller_done - signal completion of processing by virtual
+ * int controller
+ *
+ * This system notifies the hypervisor that the virtual interrupt controller
+ * in the virtual board has finished procssing the information in the
+ * virtual interrupt controller registers, and requires a refresh.
+ *
+ */
+vbi_hcall(vbi_int_controller_done,int_controller_done)
+
+
+/*
+ * vbi_vcore_irq_lock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_lock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	0
+#else
+	li	p1, -1
+	lis	p2, HIADJ(wr_vb_control)
+	lwz	p2, LO(wr_vb_control)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+#endif
+	blr
+FUNC_END(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+
+/*
+ * vbi_vcore_irq_unlock - unlock interrupts for running core
+ *
+ * This routine enables interrupts and makes a fast hypercall if pending
+ * interrupts are detected for the calling core. This is a C wrapper function
+ * for the assembly MACRO VBI_INT_VCORE_UNLOCK().
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_unlock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	1
+#else
+	lis	p0, HIADJ(wr_vb_control)
+	lwz	p0, LO(wr_vb_control)(p0)
+	li	p1, 0
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+#endif
+tryAgain:
+	lis	p0, HIADJ(wr_vb_status)
+	lwz	p0, LO(wr_vb_status)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis r0, HI(VBI_SYS_int_enable)
+	ori r0, r0, LO(VBI_SYS_int_enable)
+	HCALL
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+
+/*
+ * The following calls are MILS extensions outside of the normal
+ * VBI 2.0 list of syscalls.
+ */
+
+/*
+ * vdk_sec_audit_event_inject - Inject a Security Audit event
+ *
+ * This system call forces injection of a security audit event.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_inject,secAuditEventInject)
+
+
+/*
+ * vdk_sec_audit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_collect,secAuditEventCollect)
+
+
+/*
+ * vdk_safe_crit_event_inject - Inject a Safety Critical event
+ *
+ * This system call forces injection of a Safety Critical event.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_inject,safeCritEventInject)
+
+
+/*
+ * vdk_safe_crit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_collect,safeCritEventCollect)
+
+
+/*
+ * vdk_schedule_name_to_id - return the schedule ID of the schedule <name>
+ *
+ * This system call returns the schedule ID given the schedule name
+ *
+ */
+vbi_hcall(vdk_schedule_name_to_id,scheduleNameToId)
+
+
+/*
+ * vdk_schedule_set - set the current schedule to schedule <name>
+ *
+ * This system call sets schedule <name> to current schedule
+ *
+ */
+vbi_hcall(vdk_schedule_set,scheduleSet)
+
+/*
+ * vdk_port_send - send message to a port
+ *
+ * This system call sends messages to the specified port
+ *
+ */
+vbi_hcall(vdk_port_send,portSend)
+
+/*
+ * vdk_port_get_recv_buf - receive from a port
+ *
+ * This system call gets a buffer from the specified port
+ *
+ */
+vbi_hcall(vdk_port_get_recv_buf,portGetRecvBuf)
+
+/*
+ * vdk_port_buf_release - release a buffer from a port
+ *
+ * This system call releases the specified buffer(s) from the specified port
+ *
+ */
+vbi_hcall(vdk_port_buf_release,portBufRelease)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index d5bcced..2375f6c 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -122,6 +122,7 @@ struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
 struct vb_control *wr_control;
 struct vb_status *wr_status;
 EXPORT_SYMBOL(wr_config);
+EXPORT_SYMBOL(wr_status);
 
 void wrhv_mapping(void);
 void mpc85xx_power_down(void);
@@ -175,7 +176,15 @@ static inline void put_dbcr(uint32_t reg)
 {
 	return;
 }
+
+static inline int32_t vbi_vb_reset(uint32_t id, int32_t core, uint32_t options)
+{
+	printk(KERN_INFO "MILS: guest reboot not supported by hypervisor\n");
+	return -1;
+}
+
 #else	/* !MILS */
+
 static inline uint32_t get_emsr(void)
 {
 	return VBI_CNTRL_ADDR_GET()->vb_control_regs.emsr;
@@ -326,7 +335,25 @@ void wrhv_mapping(void)
 			 (unsigned long)wr_config->
 			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
 
-	return;
+#ifdef CONFIG_WRHV_MILS
+	if (wr_config->memoryRegionsConfigAddress != 0) {
+		map_page((unsigned long)wr_config->memoryRegionsConfigAddress,
+			(unsigned long)wr_config->memoryRegionsConfigAddress,
+			_PAGE_RAM);
+	}
+	if (wr_config->interruptConfiguration != 0) {
+		map_page((unsigned long)wr_config->interruptConfiguration,
+			(unsigned long)wr_config->interruptConfiguration,
+			_PAGE_RAM);
+	}
+	if (wr_config->vb_status->vbInterruptController != 0) {
+		map_page((unsigned long)wr_config->vb_status->vbInterruptController,
+			(unsigned long)wr_config->vb_status->vbInterruptController,
+			_PAGE_RAM);
+	}
+#endif
+ 
+ 	return;
 }
 
 unsigned long __init wrhv_find_end_of_memory(void)
@@ -1009,6 +1036,7 @@ int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
 		flush_HPTE(0, va, pmd_val(*pmd));
 	return err;
 }
+EXPORT_SYMBOL(wrhv_map_page);
 
 void __iomem *
 wrhv___ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)
@@ -1309,3 +1337,19 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	return irq;
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
+
+#if 0 // def CONFIG_WRHV_MILS
+EXPORT_SYMBOL(vbi_vcore_irq_lock);
+EXPORT_SYMBOL(vbi_vcore_irq_unlock);
+EXPORT_SYMBOL(vbi_int_controller_done);
+
+EXPORT_SYMBOL(vdk_port_send);
+EXPORT_SYMBOL(vdk_port_get_recv_buf);
+EXPORT_SYMBOL(vdk_port_buf_release);
+EXPORT_SYMBOL(vdk_schedule_name_to_id);
+EXPORT_SYMBOL(vdk_schedule_set);
+EXPORT_SYMBOL(vdk_sec_audit_event_inject);
+EXPORT_SYMBOL(vdk_sec_audit_event_collect);
+EXPORT_SYMBOL(vdk_safe_crit_event_inject);
+EXPORT_SYMBOL(vdk_safe_crit_event_collect);
+#endif
diff --git a/arch/x86/kernel/vbi/vdk_syscalls.S b/arch/x86/kernel/vbi/vdk_syscalls.S
index 274594b..816b927 100644
--- a/arch/x86/kernel/vbi/vdk_syscalls.S
+++ b/arch/x86/kernel/vbi/vdk_syscalls.S
@@ -20,16 +20,132 @@
 #include <asm/vbi.h>
 #include <vbi/syscall.h>
 
-/* globals */
-.globl vdk_virt_to_phys
 .text
 .balign 16
 
 #define VBI_STACK_FRAME_SIZE	4
 
-vdk_virt_to_phys:
-        movl $VDK_SYS_virtToPhys, %eax
-        push $2
-        vmcall
-        addl $VBI_STACK_FRAME_SIZE, %esp
-        ret
+#define vdk_hcall(name, call, args)		\
+.globl name;					\
+name:						\
+	movl $VBI_SYS_##call,%eax;		\
+	push $##args;				\
+	vmcall;					\
+	addl $VBI_STACK_FRAME_SIZE, %esp;	\
+	ret
+
+/*
+ * vdk_virt_to_phys - translate a virtual address to physical
+ */
+vdk_hcall(vdk_virt_to_phys, virtToPhys, 2)
+
+/*
+ *
+ * vbi_int_controller_done - signal completion of processing by virtual int controller
+ *
+ * This system notifies the hypervisor that the virtual interrupt controller
+ * in the virtual board has finished procssing the information in the
+ * virtual interrupt controller registers, and requires a refresh.
+ *
+ */
+vdk_hcall(vbi_int_controller_done, int_controller_done, 0)
+
+/*
+ * The following are MILS extensions that are not present
+ * in the standard VBI 2.0 syscall list.
+ */
+
+/*
+ *
+ * vdk_port_buf_release - release a buffer from a port
+ *
+ * This system call releases the specified buffer(s) from the specified port
+ *
+ */
+vdk_hcall(vdk_port_buf_release, portBufRelease, 3)
+
+/*
+ *
+ * vdk_schedule_name_to_id - return the schedule ID of the schedule <name>
+ *
+ * This system call returns the schedule ID given the schedule name
+ *
+ */
+vdk_hcall(vdk_schedule_name_to_id, scheduleNameToId, 2)
+
+/*
+ *
+ * vdk_schedule_set - set the current schedule to schedule <name>
+ *
+ * This system call sets schedule <name> to current schedule
+ *
+ */
+vdk_hcall(vdk_schedule_set, scheduleSet, 2)
+
+/*
+ *
+ * vdk_sec_audit_event_inject - inject a security Audit event
+ *
+ */
+vdk_hcall(vdk_sec_audit_event_inject, secAuditEventInject, 3)
+
+/*
+ *
+ * vdk_sec_audit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vdk_hcall(vdk_sec_audit_event_collect, secAuditEventCollect, 3)
+
+/*
+ *
+ * vdk_safe_crit_event_inject - Inject a Safety Critical event
+ *
+ * This system call forces injection of a Safety Critical event.
+ *
+ */
+vdk_hcall(vdk_safe_crit_event_inject, safeCritEventInject, 1)
+
+/*
+ *
+ * vdk_safe_crit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vdk_hcall(vdk_safe_crit_event_collect, safeCritEventCollect, 3)
+
+/*
+ *
+ * vdk_port_send - send message to a port
+ *
+ * This system call sends messages to the specified port
+ *
+ */
+vdk_hcall(vdk_port_send, portSend, 5)
+
+/*
+ *
+ * vdk_port_get_recv_buf - receive from a port
+ *
+ * This system call gets a buffer from the specified port
+ *
+ */
+vdk_hcall(vdk_port_get_recv_buf, portGetRecvBuf, 2)
+
+/*
+ *
+ * vdk_bsp_ioctl - bsp ioctl call
+ *
+ * This system call interfaces to the Board Support Package
+ * I/O drivers etc
+ *
+ * Knwon BSP ioctl commands:
+ *       VDK_BSPIOCTL_ENABLE_INT   /@ Enable HW interrupt @/
+ *       VDK_BSPIOCTL_DISABLE_INT  /@ Disable HW interrupt@/
+ *       VDK_BSPIOCTL_RESET        /@ Reset HW device     @/
+ *
+ */
+vdk_hcall(vdk_bsp_ioctl, bspIoctl, 8)
+
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index af32025..95e6c6d 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -233,6 +233,11 @@
 #define vdkPortBufRelease	vdk_port_buf_release
 #define vdkScheduleSet		vdk_schedule_set
 #define vdkScheduleNameToId	vdk_schedule_name_to_id
-#endif
+
+#define PORT_BUF_CTRL_DESC	struct portBufCtrlDesc
+#define PORT_STATUS		struct portStatus
+#define PORT_HY_INFO		struct portHyInfo
+
+#endif	/* MILS */
 
 #endif  /* _VBI_COMPAT_H */
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index a697305..f70ace2 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -14,10 +14,10 @@
  *
  */
 
-#ifndef _VBI_SYSCALL_H
 #ifdef CONFIG_WRHV_MILS
 #include <vbi/vdk_syscalls.h>
 #else
+#ifndef _VBI_SYSCALL_H
 #define _VBI_SYSCALL_H
 #include <linux/linkage.h>
 #include <vbi/types.h>
diff --git a/include/vbi/vdk_interface.h b/include/vbi/vdk_interface.h
index 021b431..73798c2 100644
--- a/include/vbi/vdk_interface.h
+++ b/include/vbi/vdk_interface.h
@@ -160,7 +160,6 @@
 typedef char VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
 
 #define VB_MAX_EXCEPTION_TYPES	32
-#define MAX_NAME_LENGTH 80
 
 struct vb_log_cfg
 {
@@ -292,7 +291,7 @@ struct vb_status
     /* Location in vbPhyscial memory of the virtual interrupt controller */
 
     struct vbInterruptController *vbInterruptController;  /* 10: */
-    struct vb_port_status *portStatus;             /* 11: port status */
+    struct portStatus *portStatus;             /* 11: port status */
 
     struct vb_log_status secAuditLogStatus; /* 12-16: Security Audit Event log status */
     struct vb_log_status safetyLogStatus;   /* 17-21: Safety Critical Event log status */
@@ -478,7 +477,13 @@ struct vb_config
     unsigned int  cacheMode;
 
     unsigned int      numPorts;  /* number of ports defined for the VB */
-    struct vbPortInfo *portInfo;  /* port configuration and status */
+    /*
+     * MILS vbInterface.h has the following:
+     *		typedef struct portConfig VB_PORT_INFO
+     *			... and later...
+     *		VB_PORT_INFO * portInfo; 
+     */
+    struct portConfig *portInfo;  /* port configuration and status */
 
     struct vb_log_cfg secAuditLogCfg;
     struct vb_log_cfg safetyLogCfg;
@@ -569,11 +574,6 @@ static inline int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr)
 
 extern int vb_context_mmu_on(int pid, void * pgtable, int pagesize, int debug);
 
-static inline int32_t vbi_vb_reset(uint32_t id, int32_t core, uint32_t options)
-{
-	return -1;
-}
-
 #endif /*_ASMLANGUAGE */
 #endif  /* _VDK_INTERFACE_H */
 
diff --git a/include/vbi/vdk_port.h b/include/vbi/vdk_port.h
index 96e225a..2621ff7 100644
--- a/include/vbi/vdk_port.h
+++ b/include/vbi/vdk_port.h
@@ -1,11 +1,17 @@
-/* vdk_port.h - port facility header file */
-
 /*
+ * vdk_interface.h - virtual board interface header file
+ *
  * Copyright (c) 2008-2010 Wind River Systems, Inc.
  *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
  */
 
 #ifndef _VDK_PORT_H
@@ -47,6 +53,31 @@ typedef enum                            /* queuing port protocol     */
 #define PORT_Q_AVAILABLE			4
 #define PORT_Q_DEST_UNAVAILABLE			9
 
+#define MAX_NAME_LENGTH 30
+
+struct portConfig
+{
+	unsigned long id;		/* unique port ID                   */
+	unsigned char *buf;		/* port payload buffer vaddr        */
+	unsigned long bufAttr;		/* port payload buffer attribute    */
+	char name[MAX_NAME_LENGTH];	/* port name                        */
+	unsigned long vbId;		/* parent vb                        */
+	unsigned long moduleId;		/* parent module                    */
+	unsigned long inChannel;	/* in channel                       */
+	unsigned long outChannel;	/* out channel                      */
+	PORT_DIRECTION_TYPE direction;	/* SOURCE or DESTINATION            */
+	PORT_MODE_TYPE mode;		/* QUEUING or SAMPLING              */
+	PORT_PROTOCOL_TYPE protocol;	/* RECEIVER_DISCARD or SENDER_BLOCK */
+	unsigned long msgSize;		/* max. message size (PAGE_ALIGNED) */
+	unsigned long numMsgs;		/* max. capacity for queuing ports  */
+};
+
+struct partPortConfig
+{
+	unsigned long numPorts;
+	struct portConfig portInfo[];
+};
+
 struct portStatus				/* port runtime status        */
 {
 	unsigned char *sBuf;			/* SIPC buffer                */
diff --git a/include/vbi/vdk_syscalls.h b/include/vbi/vdk_syscalls.h
index ab95eb5..d4a2a06 100644
--- a/include/vbi/vdk_syscalls.h
+++ b/include/vbi/vdk_syscalls.h
@@ -231,8 +231,6 @@ have mapped a NULL / no-op to HY_SYSCALL(23) */
 /* Breaks MILS security model */
 #define VBI_SYS_RegsRead_op     VDK_SYS_NULL  /* regs service operation */
 
-#define VDK_SYS_virtToPhys      HY_SYSCALL(1)
-
 /* VTLB operation command and flags (intel-vt specific) */
 #define VBI_VTLB_OP_UPDATE_PMD		0
 #define VBI_VTLB_OP_UPDATE_PTE		0
@@ -387,6 +385,16 @@ struct vbi_vtlb_control
 	struct vbi_vtlb_cr3_cache cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES];
 };
 
+struct vbi_msg_ctl
+{
+	/* Unused by MILS */
+};
+
+struct vbi_msg_info
+{
+	/* Unused by MILS */
+};
+
 /*
  * Control structure used by vbi_vb_mgmt for commands memory read, memory write,
  *  register read, and register write.
@@ -429,8 +437,8 @@ extern int vbi_disable_vmmu (unsigned vmmu_num);
 
 extern asmlinkage int vbi_virt_to_phys (void * pVirtAddr, void *pPaddr);
 extern asmlinkage int vbi_int_controller_done(unsigned level);
-extern asmlinkage void vbi_vcore_irq_lock(void);
-extern asmlinkage int32_t vbi_vcore_irq_unlock(void);
+extern asmlinkage int32_t vbi_vcore_irq_lock(void);
+extern asmlinkage void vbi_vcore_irq_unlock(void);
 
 static inline int32_t vbi_hy_ioctl(unsigned ioctl, void *arg1, void *arg2, \
 		void *arg3, void *arg4)
-- 
1.7.0

