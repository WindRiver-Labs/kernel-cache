From 92cd25d694a6cfebda664f5d6035fd0a70f9c9a1 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 27 Oct 2009 00:30:25 -0400
Subject: [PATCH 2/2] vbi ppc: clean up syscall file

This is a cosmetic update, but the important thing that it does
is reinforce the need/ability to coalesce all the syscall defines
into a simple table form.  With all the extra fluff gone, it is
clear that most of them are the same.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/vbi/syscalls.S | 2015 +++++++++++-------------------------
 1 files changed, 623 insertions(+), 1392 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index 328d9e4..db4ea85 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -19,746 +19,420 @@
 #include <vbi/vbi.h>
 #include <asm/vbi.h>
 
-#define HCALL sc
+/* globals */
+
+FUNC_EXPORT(vbiVcoreIntRed_op)
+FUNC_EXPORT(vbiDebugShellStart)
+FUNC_EXPORT(vbiVbMemoryRead)
+FUNC_EXPORT(vbiVbMemoryWrite)
+FUNC_EXPORT(vbiVbRegisterRead)
+FUNC_EXPORT(vbiVbRegisterWrite)
+FUNC_EXPORT(vbiIoapicOp)
+FUNC_EXPORT(vbiIoapicIoctl)
+FUNC_EXPORT(vbiHyIoctl)
+FUNC_EXPORT(vbiCtxctl)
+FUNC_EXPORT(vbiSend)
+FUNC_EXPORT(vbiReceiveOp)
+FUNC_EXPORT(vbiReply)
+FUNC_EXPORT(vbiIcacheFlush)
+FUNC_EXPORT(vbiDcacheFlush)
+FUNC_EXPORT(vbiCacheTextUpdate)
+FUNC_EXPORT(vbiTlbFlush)
+FUNC_EXPORT(vbiPanic)
+FUNC_EXPORT(vbiPs)
+FUNC_EXPORT(vbiKputs)
+FUNC_EXPORT(vbiKputc)
+FUNC_EXPORT(vbiIntVCoreUnlock)
+FUNC_EXPORT(vbiIntVCoreLock)
+FUNC_EXPORT(vbiExcBaseSet)
+FUNC_EXPORT(vbiExcOffsetsSet)
+FUNC_EXPORT(vbiExcOffsetsGet)
+FUNC_EXPORT(vbiMemAttrSet)
+FUNC_EXPORT(vbiMemAttrGet)
+FUNC_EXPORT(vbiVmmuConfig)
+FUNC_EXPORT(vbiVmmuEnable)
+FUNC_EXPORT(vbiVmmuDisable)
+FUNC_EXPORT(vbiVmmuTlbLoad)
+FUNC_EXPORT(vbiVmmuTlbFlush)
+FUNC_EXPORT(vbiVbMgmt)
+FUNC_EXPORT(vbiNsOp)
+FUNC_EXPORT(vbiVbSuspend)
+FUNC_EXPORT(vbiVbReset)
+FUNC_EXPORT(vbiVbRestart)
+FUNC_EXPORT(vbiVbResume)
+
+_WRS_TEXT_SEG_START
 
-	/* globals */
-
-	FUNC_EXPORT(vbiVcoreIntRed_op)
-	FUNC_EXPORT(vbiDebugShellStart)
-	FUNC_EXPORT(vbiVbMemoryRead)
-	FUNC_EXPORT(vbiVbMemoryWrite)
-	FUNC_EXPORT(vbiVbRegisterRead)
-	FUNC_EXPORT(vbiVbRegisterWrite)
-	FUNC_EXPORT(vbiIoapicOp)
-	FUNC_EXPORT(vbiIoapicIoctl)
-	FUNC_EXPORT(vbiHyIoctl)
-	FUNC_EXPORT(vbiCtxctl)
-	FUNC_EXPORT(vbiSend)
-	FUNC_EXPORT(vbiReceiveOp)
-	FUNC_EXPORT(vbiReply)
-	FUNC_EXPORT(vbiIcacheFlush)
-	FUNC_EXPORT(vbiDcacheFlush)
-	FUNC_EXPORT(vbiCacheTextUpdate)
-	FUNC_EXPORT(vbiTlbFlush)
-	FUNC_EXPORT(vbiPanic)
-	FUNC_EXPORT(vbiPs)
-	FUNC_EXPORT(vbiKputs)
-	FUNC_EXPORT(vbiKputc)
-	FUNC_EXPORT(vbiIntVCoreUnlock)
-	FUNC_EXPORT(vbiIntVCoreLock)
-	FUNC_EXPORT(vbiExcBaseSet)
-	FUNC_EXPORT(vbiExcOffsetsSet)
-	FUNC_EXPORT(vbiExcOffsetsGet)
-	FUNC_EXPORT(vbiMemAttrSet)
-	FUNC_EXPORT(vbiMemAttrGet)
-	FUNC_EXPORT(vbiVmmuConfig)
-	FUNC_EXPORT(vbiVmmuEnable)
-	FUNC_EXPORT(vbiVmmuDisable)
-	FUNC_EXPORT(vbiVmmuTlbLoad)
-	FUNC_EXPORT(vbiVmmuTlbFlush)
-	FUNC_EXPORT(vbiVbMgmt)
-	FUNC_EXPORT(vbiNsOp)
-	FUNC_EXPORT(vbiVbSuspend)
-	FUNC_EXPORT(vbiVbReset)
-	FUNC_EXPORT(vbiVbRestart)
-	FUNC_EXPORT(vbiVbResume)
-
-	_WRS_TEXT_SEG_START
-
-/******************************************************************************
-*
-* sys_vbMgmt - virtual board management
-* 
-* This routine executes the specified command on a given virtual board. The
-* possible commands are:
-* 
-* VBI_VBMGMT_ATTACH 
-* Attach the requesting Virtual Board to the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_DETACH
-* Detatch the requesting Virtual Board from the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_SUSPEND
-* Suspends target Virtual Board from operation.  Fails if Virtual Board
-* has already been suspended
-*
-* VBI_VBMGMT_RESET
-* Resume a target virtual board.  Fails if a Virtual Board has not been
-* suspended. Currently no options are supported
-*
-* VBI_VBMGMT_RESUME
-* Restarts a target Virtual Board which has Preload=0 set in the xml file.
-* Fails if Virtual Board is preloaded (Preload=1)
-*
-* The fourth argument to this routine specifies an flag that must be defined
-* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
-* The possible flgas are:
-*   VBI_VTLB_OP_UPDATE_PMD	
-*   VBI_VTLB_OP_UPDATE_PTE	
-*   VBI_VTLB_OP_DELETE_PMD	
-*   VBI_VTLB_OP_SET_PTE_AT	
-*   VBI_VTLB_OP_SET_PTE	
-*   VBI_VTLB_OP_FLUSH_OPS	
-*   VBI_VTLB_OP_INIT	
-* 
-* RETURNS: OK or error in case of failure
-* 
-*
-* int32_t sys_vbMgmt 
-*    (
-*    uint32_t cmd,	/@ attach, detach, suspend, reset or resume @/
-*    uint32_t boardId,	/@ the operation target board id @/
-*    int32_t *outError, /@ where to set error : OK or error flag @/ 
-*    uint32_t flags	/@ options required by the cmd executed @/
-*    )
-*/
+/*
+ * FIXME: condense syscalls into a table, remove repitition
+ */
 
+/*
+ * sys_vbMgmt - virtual board management
+ *
+ * This routine executes the specified command on a given virtual board. The
+ * possible commands are:
+ *
+ * VBI_VBMGMT_ATTACH
+ * Attach the requesting Virtual Board to the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_DETACH
+ * Detatch the requesting Virtual Board from the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_SUSPEND
+ * Suspends target Virtual Board from operation.  Fails if Virtual Board
+ * has already been suspended
+ *
+ * VBI_VBMGMT_RESET
+ * Resume a target virtual board.  Fails if a Virtual Board has not been
+ * suspended. Currently no options are supported
+ *
+ * VBI_VBMGMT_RESUME
+ * Restarts a target Virtual Board which has Preload=0 set in the xml file.
+ * Fails if Virtual Board is preloaded (Preload=1)
+ *
+ * The fourth argument to this routine specifies an flag that must be defined
+ * when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+ * The possible flgas are:
+ *   VBI_VTLB_OP_UPDATE_PMD
+ *   VBI_VTLB_OP_UPDATE_PTE
+ *   VBI_VTLB_OP_DELETE_PMD
+ *   VBI_VTLB_OP_SET_PTE_AT
+ *   VBI_VTLB_OP_SET_PTE
+ *   VBI_VTLB_OP_FLUSH_OPS
+ *   VBI_VTLB_OP_INIT
+ *
+ */
 FUNC_LABEL(vbiVbMgmt)
-        lis     r0, HI(VBI_SYS_vbMgmt)
-        ori     r0, r0, LO(VBI_SYS_vbMgmt)
-        HCALL
+        lis r0, HI(VBI_SYS_vbMgmt)
+        ori r0, r0, LO(VBI_SYS_vbMgmt)
+        sc
         blr
 FUNC_END(vbiVbMgmt)
 
 
-/*******************************************************************************
-*
-* vbiVbSuspend - Suspend a virtual board's core
-*
-* This routine makes a hypercall in order to suspend one or more cores that
-* exist within the specified virtual board. The target core(s) enter HALT state
-* until vbiVbResume() is called change the state of the core(s). This function
-* will return only after all victim cores are suspended unless the opration
-* fails to complete. The second argument passed to this function specifies one
-* or more target cores. For suspending every core within the specified VB the
-* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
-* requesting the suspension may also be included in the list to be suspended.
-* To suspend everyone but the recipient then the second argument passed to this
-* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
-* should be a valid core number within the VB. This hypercall sends a message
-* to a given hypervisor manager that provides virtual board managment service.
-*
-* SYNOPSIS
-*
-*
-*
-* vbiStatus_t vbiVbSuspend
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbReset(), vbiVbRestart()
-*/
-
+/*
+ * vbiVbSuspend - Suspend a virtual board's core
+ *
+ * This routine makes a hypercall in order to suspend one or more cores that
+ * exist within the specified virtual board. The target core(s) enter HALT
+ * state until vbiVbResume() is called change the state of the core(s). This
+ * function will return only after all victim cores are suspended unless the
+ * opration fails to complete. The second argument passed to this function
+ * specifies one or more target cores. For suspending every core within the
+ * specified VB the second argument must be set to VBI_VB_CORES_ALL. This
+ * implies that the core requesting the suspension may also be included in the
+ * list to be suspended.  To suspend everyone but the recipient then the second
+ * argument passed to this function should be set to VBI_VB_CORES_OTHERS.
+ * Otherwise the second argument should be a valid core number within the VB.
+ * This hypercall sends a message to a given hypervisor manager that provides
+ * virtual board managment service.
+ *
+ */
 FUNC_LABEL(vbiVbSuspend)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-	
-        lis     r0, HI(VBI_SYS_vbSuspend)
-        ori     r0, r0, LO(VBI_SYS_vbSuspend)
-        HCALL
+        lis r0, HI(VBI_SYS_vbSuspend)
+        ori r0, r0, LO(VBI_SYS_vbSuspend)
+        sc
         blr
 FUNC_END(vbiVbSuspend)
 
-/*******************************************************************************
-*
-* vbiVbReset - Reset a virtual board's core
-*
-* This routine makes a hypercall in order to reset one or more cores that exist
-* within the specified virtual board. Calling this function puts the target
-* core(s) program counter to it's ENTRY function. The ENTRY function is 
-* determined based on the loaded binary image. A core does not execute beyond
-* it's ENTRY function unless vbiVbRestart() is explitly called. 
-* Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
-* option is set in the flag passed as the third argument to this routine.
-* The hypercall sends a message to a manager that provides VB managment 
-* services. 
-* This function will return only after all victim cores are reset unless the
-* operation fails to complete. The order of which the victim cores are reset
-* is not determined. The second argument identifies the cores to perform the
-* operation on.
-* The value of the second argument should be set to one of the following:
-*
-*
-*
-* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*
-* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*
-* A valid core number: Reset the specified core that exist within the Virtual
-* Board.
-*
-*
-* The third argument argument passed to this function specifies options that are
-* applicable only when the second argument is VBI_VB_CORES_ALL. The options
-* may be
-* one of the following or a combination:
-*
-*
-* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
-*
-* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
-*
-*
-*
-* IMPORTANT:
-* If a user chooses to restart core without reloading the executable image then
-* the data section must be restored to prevent critical errors. It is the guest
-* OS's responsibility to clear the bss data sections in such scenario.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbReset
-*    (
-*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
-*    vbiCore_t     core,            /@ Core within the VB           @/
-*    uint32_t     options   /@ reload , start options       @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
-*/
-
+/*
+ * vbiVbReset - Reset a virtual board's core
+ *
+ * This routine makes a hypercall in order to reset one or more cores that
+ * exist within the specified virtual board. Calling this function puts the
+ * target core(s) program counter to it's ENTRY function. The ENTRY function is
+ * determined based on the loaded binary image. A core does not execute beyond
+ * it's ENTRY function unless vbiVbRestart() is explitly called.  Except for
+ * core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0 option is
+ * set in the flag passed as the third argument to this routine.  The hypercall
+ * sends a message to a manager that provides VB managment services.  This
+ * function will return only after all victim cores are reset unless the
+ * operation fails to complete. The order of which the victim cores are reset
+ * is not determined. The second argument identifies the cores to perform the
+ * operation on.  The value of the second argument should be set to one of the
+ * following:
+ *
+ * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+ *
+ * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+ *
+ * A valid core number: Reset the specified core that exist within the Virtual
+ * Board.
+ *
+ * The third argument argument passed to this function specifies options that
+ * are applicable only when the second argument is VBI_VB_CORES_ALL. The
+ * options may be one of the following or a combination:
+ *
+ *
+ * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+ *
+ * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+ *
+ * IMPORTANT: If a user chooses to restart core without reloading the
+ * executable image then the data section must be restored to prevent critical
+ * errors. It is the guest OS's responsibility to clear the bss data sections
+ * in such scenario.
+ *
+ */
 FUNC_LABEL(vbiVbReset)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 * r5 - options
-	 */
-
-        lis     r0, HI(VBI_SYS_vbReset)
-        ori     r0, r0, LO(VBI_SYS_vbReset)
-        HCALL
+        lis r0, HI(VBI_SYS_vbReset)
+        ori r0, r0, LO(VBI_SYS_vbReset)
+        sc
         blr
 FUNC_END(vbiVbReset)
 
-
-/*******************************************************************************
-*
-* vbiVbRestart - Restart a virtual board's core
-*
-* This routine makes a hypercall in order to restart a virtual cores from reset.
-* It's called to start running a core or cores that were previously reset by
-* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
-* function retrieved from the corresponding binary image.
-* This function will return only after  all cores are out of reset unless the
-* operation fails to complete.  The second argument represents the cores to
-* restart.
-* For restarting every core in reset mode within the specified VB the second
-* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
-* VB then the core number must be passed in the second argument.
-*
-* This hypercall sends a message to a manager that provides VB managment
-* services.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbRestart
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
-*/
-
+/*
+ * vbiVbRestart - Restart a virtual board's core
+ *
+ * This routine makes a hypercall in order to restart a virtual cores from
+ * reset.  It's called to start running a core or cores that were previously
+ * reset by calling vbiVbReset(). The target core(s) start(s) executing from
+ * the ENTRY function retrieved from the corresponding binary image.  This
+ * function will return only after  all cores are out of reset unless the
+ * operation fails to complete.  The second argument represents the cores to
+ * restart.  For restarting every core in reset mode within the specified VB
+ * the second argument is set to VBI_VB_CORES_ALL. To restart a specific core
+ * within the VB then the core number must be passed in the second argument.
+ *
+ * This hypercall sends a message to a manager that provides VB managment
+ * services.
+ *
+ */
 FUNC_LABEL(vbiVbRestart)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-
-        lis     r0, HI(VBI_SYS_vbRestart)
-        ori     r0, r0, LO(VBI_SYS_vbRestart)
-        HCALL
+        lis r0, HI(VBI_SYS_vbRestart)
+        ori r0, r0, LO(VBI_SYS_vbRestart)
+        sc
         blr
 FUNC_END(vbiVbRestart)
 
-/*******************************************************************************
-*
-* vbiVbResume - Resume a virtual board's core
-*
-* This routine makes a hypercall in order to resume one or cores within
-* the specified virtual board. It reactivates a cores or cores that were
-* previously suspended by calling vbiVbResume(). This function will return only
-* after all victim cores are resumed unless the operation fails. The order of
-* which the cores are resumed is not determined. The second argument may a
-* magic number instead of a valid core number to indicate that the operation
-* is intended for more than one core. For resuming every core within the
-* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
-* This implies to resume every core within the specified VB. Using this option
-* when some of the cores within the VB are already running is not considered
-* as programming error.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbResume
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend()
-*/
-
+/*
+ *
+ * vbiVbResume - Resume a virtual board's core
+ *
+ * This routine makes a hypercall in order to resume one or cores within the
+ * specified virtual board. It reactivates a cores or cores that were
+ * previously suspended by calling vbiVbResume(). This function will return
+ * only after all victim cores are resumed unless the operation fails. The
+ * order of which the cores are resumed is not determined. The second argument
+ * may a magic number instead of a valid core number to indicate that the
+ * operation is intended for more than one core. For resuming every core within
+ * the specified VB then the second argument is set to be equal to
+ * VBI_VB_RESUME_ALL.  This implies to resume every core within the specified
+ * VB. Using this option when some of the cores within the VB are already
+ * running is not considered as programming error.
+ *
+ */
 FUNC_LABEL(vbiVbResume)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-
-        lis     r0, HI(VBI_SYS_vbResume)
-        ori     r0, r0, LO(VBI_SYS_vbResume)
-        HCALL
+        lis r0, HI(VBI_SYS_vbResume)
+        ori r0, r0, LO(VBI_SYS_vbResume)
+        sc
         blr
 FUNC_END(vbiVbResume)
 
-/*******************************************************************************
-*
-* vbiSend - Send a message to another context
-*
-* This routine makes a hypercall to send a message to the specified context and
-* waits for a reply.  The caller will block until the sender replies to the sent
-* message.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiSend
-*    (
-*    vbiCtx_t     id,    /@ context id to send the message to @/
-*    void *       smsg,  /@ pointer to message to send        @/
-*    size_t       slen,  /@ length of message to send         @/
-*    void *       rmsg,  /@ pointer to receive message buffer @/
-*    size_t       rlen,  /@ length of receive message         @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiReceive(), vbiReply(), WRHV  messaging user's guide
-*/
-
+/*
+ *
+ * vbiSend - Send a message to another context
+ *
+ * This routine makes a hypercall to send a message to the specified context
+ * and waits for a reply.  The caller will block until the sender replies to
+ * the sent message.
+ *
+ */
 FUNC_LABEL(vbiSend)
-
-	/*
-	 * r3 - ctx id
-	 * r4 - smsg pointer 
-	 * r5 - size of smsg 
-	 * r6 - rmsg pointer
-	 * r7 - rmsg length
-	 * r8 - info pointer
-	 * r9 - ctl pointer
-	 */
-
-	lis	r0, HI(VBI_SYS_send)
-	ori	r0, r0, LO(VBI_SYS_send)
-	HCALL
+	lis r0, HI(VBI_SYS_send)
+	ori r0, r0, LO(VBI_SYS_send)
+	sc
 	blr
 FUNC_END(vbiSend)
 
-/*******************************************************************************
-*
-* vbiReceiveOp - Receive a message from another context
-*
-* This routine makes a hypercall and waits for a message to be received from
-* another context. It blocks until a message is received.
-*
-* SYNOPSIS
-*
-*
-* vbiCtx_t vbiReceiveOp
-*    (
-*    void *       smsg,  /@ pointer to message to receive  @/
-*    size_t       len,   /@ length of message to receive   @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*
-*
-* RETURNS: sender context Id or an error number in case of failure
-*
-*
-*
-*vbiSend(), vbiReply(), WRHV  messaging user's guide
-*/
-
+/*
+ * vbiReceiveOp - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received.
+ *
+ */
 FUNC_LABEL(vbiReceiveOp)
-
-	/*
-	 * r3 - smsg pointer 
-	 * r4 - size of smsg 
-	 * r5 - info pointer
-	 * r6 - ctl pointer
-	 */
-
-	lis	r0, HI(VBI_SYS_receive)
-	ori	r0, r0, LO(VBI_SYS_receive)
-	HCALL
+	lis r0, HI(VBI_SYS_receive)
+	ori r0, r0, LO(VBI_SYS_receive)
+	sc
 	blr
 FUNC_END(vbiReceiveOp)
 
-/*******************************************************************************
-*
-* vbiReply - Reply to message received from another context
-*
-* This routine makes a hypercall in order to reply to a message received from
-* another context. A message is received from remote context by calling
-* vbiReceive(). The reply will unblock the recipient which may preempt
-* the caller.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiReply
-*    (
-*    vbiCtx_t	    id,    /@ context id to reply the message to    @/
-*    void *	    buff,  /@ pointer to reply message		    @/
-*    size_t	    len,   /@ length of message to reply	    @/
-*    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiSend(), vbiReceive(), WRHV  messaging user's guide
-*/
-
+/*
+ * vbiReply - Reply to message received from another context
+ *
+ * This routine makes a hypercall in order to reply to a message received from
+ * another context. A message is received from remote context by calling
+ * vbiReceive(). The reply will unblock the recipient which may preempt
+ * the caller.
+ *
+ */
 FUNC_LABEL(vbiReply)
-	lis	r0, HI(VBI_SYS_reply)
-	ori	r0, r0, LO(VBI_SYS_reply)
-	HCALL
+	lis r0, HI(VBI_SYS_reply)
+	ori r0, r0, LO(VBI_SYS_reply)
+	sc
 	blr
 FUNC_END(vbiReply)
 
-/*******************************************************************************
-*
-* vbiKputs - print a string on the hypervisor kernel console
-*
-* This routine makes a hypercall and prints a string of characters to to
-* hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiKputc() 
-*/
-
+/*
+ *
+ * vbiKputs - print a string on the hypervisor kernel console
+ *
+ * This routine makes a hypercall and prints a string of characters to to
+ * hypervisor console.
+ *
+ */
 FUNC_LABEL(vbiKputs)
-	lis	r0, HI(VBI_SYS_kputs)
-	ori	r0, r0, LO(VBI_SYS_kputs)
-	HCALL
+	lis r0, HI(VBI_SYS_kputs)
+	ori r0, r0, LO(VBI_SYS_kputs)
+	sc
 	blr
 FUNC_END(vbiKputs)
 
-/*******************************************************************************
-*
-* vbiKputc - print a character on the hypervisor kernel console
-*
-* This routine makes a hypercall in order to print the specified character to
-* hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiKputc (int c) /@ character to print @/
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiKputs()
-*/
-
+/*
+ *
+ * vbiKputc - print a character on the hypervisor kernel console
+ *
+ * This routine makes a hypercall in order to print the specified character to
+ * hypervisor console.
+ *
+ */
 FUNC_LABEL(vbiKputc)
-	lis	r0, HI(VBI_SYS_kputc)
-	ori	r0, r0, LO(VBI_SYS_kputc)
-	HCALL
+	lis r0, HI(VBI_SYS_kputc)
+	ori r0, r0, LO(VBI_SYS_kputc)
+	sc
 	blr
 FUNC_END(vbiKputc)
 
-/*******************************************************************************
-*
-* vbiPanic - halt the system and dump debug info 
-*
-* This routine makes a hypercall in order to halt the system and display debug
-* information on hypervisor console. If hypervisor is configured with
-* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
-* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
-* the offending cores registers dump is displayed on hypervisor console. If
-* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
-* the debug manager.
-*
-*
-* SYNOPSIS
-*
-* 
-* void vbiPanic (const char *msg) /@ pointer to message to print @/
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*/
-
+/*
+ * vbiPanic - halt the system and dump debug info
+ *
+ * This routine makes a hypercall in order to halt the system and display debug
+ * information on hypervisor console. If hypervisor is configured with
+ * WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to
+ * hypervisor console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO
+ * component the offending cores registers dump is displayed on hypervisor
+ * console. If hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message
+ * is sent to the the debug manager.
+ *
+ */
 FUNC_LABEL(vbiPanic)
-	lis	r0, HI(VBI_SYS_panic)
-	ori	r0, r0, LO(VBI_SYS_panic)
-	HCALL
+	lis r0, HI(VBI_SYS_panic)
+	ori r0, r0, LO(VBI_SYS_panic)
+	sc
 	blr
 FUNC_END(vbiPanic)
 
-/*******************************************************************************
-*
-* vbiDebugShellStart - start the hypervisor debug shell
-*
-* This routine sends a message to the hypervisor debug shell manager in order to
-* start the WRHV shell program. The shell program spins therefore does not share
-* the processor with any other WRHV context. By default a caller of this routine 
-* is detached to allow the caling core to continue executing (as long as the are not
-* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
-* specified to force the caller virtual board core to block while the shell program
-* is running. 
-*
-* SYNOPSIS
-*
-*
-* void vbiDebugShellStart 
-*          (
-*          uint32_t  flags /@ detach by default @/
-*          ) 
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*/
+/*
+ * vbiDebugShellStart - start the hypervisor debug shell
+ *
+ * This routine sends a message to the hypervisor debug shell manager in order
+ * to start the WRHV shell program. The shell program spins therefore does not
+ * share the processor with any other WRHV context. By default a caller of this
+ * routine is detached to allow the caling core to continue executing (as long
+ * as the are not scheduled to run on the same processor). An optional flag
+ * VBI_SHELL_ATTACH can be specified to force the caller virtual board core to
+ * block while the shell program is running.
+ *
+ */
 
 FUNC_LABEL(vbiDebugShellStart)
 
 	/* r3 - flags for attachement behaviour */
 
-	lis	r0, HI(VBI_SYS_dbgShStart)
-	ori	r0, r0, LO(VBI_SYS_dbgShStart)
-	HCALL
+	lis r0, HI(VBI_SYS_dbgShStart)
+	ori r0, r0, LO(VBI_SYS_dbgShStart)
+	sc
 	blr
 FUNC_END(vbiDebugShellStart)
 
-/*******************************************************************************
-*
-* vbiIcacheFlush - flush the instruction cache
-*
-* This routine makes a hypercall to flush the instruction cache of the calling
-* core for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiIcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the instruction cache to flush @/
-*	    size_t len  /@ length of memory to flush @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiDcacheFlush()
-*/
-
+/*
+ *
+ * vbiIcacheFlush - flush the instruction cache
+ *
+ * This routine makes a hypercall to flush the instruction cache of the calling
+ * core for the specified address range.
+ *
+ */
 FUNC_LABEL(vbiIcacheFlush)
-	lis	r0, HI(VBI_SYS_icache_flush)
-	ori	r0, r0, LO(VBI_SYS_icache_flush)
-	HCALL
+	lis r0, HI(VBI_SYS_icache_flush)
+	ori r0, r0, LO(VBI_SYS_icache_flush)
+	sc
 	blr
 FUNC_END(vbiIcacheFlush)
 
-/*******************************************************************************
-*
-* vbiDcacheFlush - flush the specified Data cache
-*
-* This routine makes a hypercall to flush the data cache of the calling core
-* for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiDcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the data cache to flush @/
-*	    size_t len  /@ length of memory to flush                   @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiTlbFlush(), vbiIcacheFlush()
-*/
-
+/*
+ * vbiDcacheFlush - flush the specified Data cache
+ *
+ * This routine makes a hypercall to flush the data cache of the calling core
+ * for the specified address range.
+ *
+ */
 FUNC_LABEL(vbiDcacheFlush)
-	lis	r0, HI(VBI_SYS_dcache_flush)
-	ori	r0, r0, LO(VBI_SYS_dcache_flush)
-	HCALL
+	lis r0, HI(VBI_SYS_dcache_flush)
+	ori r0, r0, LO(VBI_SYS_dcache_flush)
+	sc
 	blr
 FUNC_END(vbiDcacheFlush)
 
-
-/******************************************************************************
-*
-* vbiTlbFlush - flush an MMU TLB entry
-*
-* This system call flushes the TLB associated with the specified context id 
-*
-* C interface:
-*
-*   vbiTlbFlush (unsigned int id) /@ the entry to flush @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ *
+ * vbiTlbFlush - flush an MMU TLB entry
+ *
+ * This system call flushes the TLB associated with the specified context id
+ *
+ */
 FUNC_LABEL(vbiTlbFlush)
-	lis	r0, HI(VBI_SYS_tlb_flush)
-	ori	r0, r0, LO(VBI_SYS_tlb_flush)
-	HCALL
+	lis r0, HI(VBI_SYS_tlb_flush)
+	ori r0, r0, LO(VBI_SYS_tlb_flush)
+	sc
 	blr
 FUNC_END(vbiTlbFlush)
 
-/*******************************************************************************
-*
-* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
-*
-* This routine enables interrupts and makes a fast hypercall if pending
-* interrupts are detected for the calling core. This is a C wrapper function for
-* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* void vbiIntVCoreUnlock (void)
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
+/*
+ * vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+ *
+ * This routine enables interrupts and makes a fast hypercall if pending
+ * interrupts are detected for the calling core. This is a C wrapper function
+ * for the assembly MACRO VBI_INT_VCORE_UNLOCK().
+ *
+ */
 FUNC_LABEL(vbiIntVCoreUnlock)
-	
+
 	lis	p0, HIADJ(wrhvVbControl)
 	lwz	p0, LO(wrhvVbControl)(p0)
 	stw	p1, VB_CONTROL_INT_DISABLE(p0)
-	
-tryAgain:		
+
+tryAgain:
 	lis	p0, HIADJ(wrhvVbStatus)
 	lwz	p0, LO(wrhvVbStatus)(p0)
 	lwz	p1, VB_STATUS_INT_PENDING(p0)
-	
+
 	/* Perform System Call to re-enable ints if ints pending */
 	cmplwi  p1, 0
 	beq     0f
 
-	lis	r0, HI(VBI_SYS_int_enable)
-	ori	r0, r0, LO(VBI_SYS_int_enable)
-	HCALL
+	lis r0, HI(VBI_SYS_int_enable)
+	ori r0, r0, LO(VBI_SYS_int_enable)
+	sc
 	b	tryAgain
 0:
 	blr
 FUNC_END(vbiIntVCoreUnlock)
 
- /*******************************************************************************   
+/*
  *
  * vbiIntVCoreLock - lock interrupts
  *
- * This routine locks interrupts for the calling core. This is a C wrapper 
+ * This routine locks interrupts for the calling core. This is a C wrapper
  * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
  * and returns the previous state of interrupts.
  *
- * SYNOPSIS
- *\cs
- * 
- * VBI PPC Architecture Supplements
- *
- * vbiIntState_t vbiIntVCoreLock (void)
- *
- *\ce
- *
- * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
- *
- * ERROR CODES: N/A
- *
- * SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
- *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
  */
-
 FUNC_LABEL(vbiIntVCoreLock)
 	li	p1, -1
 	lis	p2, HIADJ(wrhvVbControl)
@@ -768,852 +442,409 @@ FUNC_LABEL(vbiIntVCoreLock)
 	blr
 FUNC_END(vbiIntVCoreLock)
 
-/*******************************************************************************
-*
-* vbiIntVCoreStateGet - Get interrupts state for running core
-*
-* This routine returns the interrupts state for the calling core. This is C 
-* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
-* returns TRUE if interrupts are locked otherwise FALSE.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntStatus_t vbiIntVCoreStateGet (void)
-*
-*
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
+/*
+ *
+ * vbiIntVCoreStateGet - Get interrupts state for running core
+ *
+ * This routine returns the interrupts state for the calling core. This is C
+ * wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+ * returns TRUE if interrupts are locked otherwise FALSE.
+ *
+ */
 FUNC_LABEL(vbiIntVCoreStateGet)
-    lis	p2, HIADJ(wrhvVbControl)
-    lwz	p2, LO(wrhvVbControl)(p2)
-    lwz	p0, VB_CONTROL_INT_DISABLE(p2)
-    blr
+	lis	p2, HIADJ(wrhvVbControl)
+	lwz	p2, LO(wrhvVbControl)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	blr
 FUNC_END(vbiIntVCoreStateGet)
 
-/*******************************************************************************
-*
-* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
-*
-* This routine changes the exceptions vector table base address for the active
-* virtual core. By default the base address of the exception table is at address
-* 0x0.
-* If the guest OS programmer wishes to move this address then this function must
-* be called to inform hypervisor. This function must be called with interrupts
-* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcBaseSet 
-*	    (
-*	    void * excTblBase /@ New exception table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
+/*
+ * vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+ *
+ * This routine changes the exceptions vector table base address for the active
+ * virtual core. By default the base address of the exception table is at
+ * address 0x0.  If the guest OS programmer wishes to move this address then
+ * this function must be called to inform hypervisor. This function must be
+ * called with interrupts disabled to prevent hypervisor to deliver interrupts
+ * to an incorrect table.
+ *
+ */
 FUNC_LABEL(vbiExcBaseSet)
-
-	/* 
-	 * r3 has the base address to set; make sure it is aligned  
-	 * align to 32 bytes  
-	 */	    
-
+	/*
+	 * r3 has the base address to set; make sure it is aligned
+	 * align to 32 bytes
+	 */
 	andi. r4, r3, 31
 	cmpwi r4, 0
 	bne- baseAlignError
 
 	/* set command for the ioctl */
-
 	mr      r4, r3
 	li	r3, VBI_HYIOCTL_EXCBASE
-	
-	/* set the hypercall number */
 
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
 	blr
 baseAlignError:
 	li r3, VBI_EXCBASE_SET_ERROR
-	blr	
+	blr
 
 FUNC_END(vbiExcBaseSet)
 
-/*******************************************************************************
-*
-* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
-*
-* This routine changes the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* If the guest OS programmer wishes to move these address then this function 
-* must be called to inform hypervisor. This function must be called with 
-* interrupts disabled to prevent hypervisor to deliver interrupts to an 
-* incorrect exception offset. The table is not validated by the hypervisor so
-* it must be complete and functional otherwize the VB will not behave as 
-* expected.
-* For SMP systems it is recommended this API be called for each core as it is
-* started up and before it's added to the scheduler for the guest OS.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsSet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiExcOffsetsGet
-*/
-
+/*
+ * vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
+ *
+ * This routine changes the exceptions vector table offset addresses for the
+ * active virtual core. By default they follow the standard PPC exception
+ * offsets. vbiExcOffsetsGet will provide the offsets being used for the
+ * virtual board. The offset table uses an index based on IVOR number.
+ * If the guest OS programmer wishes to move these address then this function
+ * must be called to inform hypervisor. This function must be called with
+ * interrupts disabled to prevent hypervisor to deliver interrupts to an
+ * incorrect exception offset. The table is not validated by the hypervisor so
+ * it must be complete and functional otherwize the VB will not behave as
+ * expected.
+ * For SMP systems it is recommended this API be called for each core as it is
+ * started up and before it's added to the scheduler for the guest OS.
+ *
+ */
 FUNC_LABEL(vbiExcOffsetsSet)
 	/* set command for the ioctl */
 	mr      r4, r3
 	li	r3, VBI_HYIOCTL_EXCOFFSETS_SET
-	
-	/* set the hypercall number */
 
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
 	blr
 FUNC_END(vbiExcOffsetsSet)
 
-/*******************************************************************************
-*
-* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
-*
-* This routine gets the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsGet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiExcOffsetsSet
-*/
-
+/*
+ * vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
+ *
+ * This routine gets the exceptions vector table offset addresses for the
+ * active virtual core. By default they follow the standard PPC exception
+ * offsets. vbiExcOffsetsSet will enable the offsets to be changed for the
+ * virtual board. The offset table uses an index based on IVOR number.
+ *
+ */
 FUNC_LABEL(vbiExcOffsetsGet)
 	/* set command for the ioctl */
 	mr      r4, r3
 	li	r3, VBI_HYIOCTL_EXCOFFSETS_GET
-	
-	/* set the hypercall number */
 
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
+	/* set the hypercall number */
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
 	blr
 FUNC_END(vbiExcOffsetsGet)
 
-/*******************************************************************************
-*
-* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
-*
-* This routine makes a hypercall to flush the data cache then invalidates the
-* instruction cache of the calling core for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiCacheTextUpdate 
-*	    (
-*	    void * addr /@ starting address to perform textUpdate operation @/
-*	    size_t len  /@ length of memory in bytes			    @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiDcacheFlush(), vbiIcacheFlush()
-*/
-
+/*
+ * vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+ *
+ * This routine makes a hypercall to flush the data cache then invalidates the
+ * instruction cache of the calling core for the specified address range.
+ *
+ */
 FUNC_LABEL(vbiCacheTextUpdate)
-	lis	r0, HI(VBI_SYS_cache_text_update)
-	ori	r0, r0, LO(VBI_SYS_cache_text_update)
-	HCALL
+	lis r0, HI(VBI_SYS_cache_text_update)
+	ori r0, r0, LO(VBI_SYS_cache_text_update)
+	sc
 	blr
 FUNC_END(vbiCacheTextUpdate)
 
-/******************************************************************************
-*
-* vbiVmmuConfig - configure the hypervisor virtual MMU
-*
-* This system call configures the context's virtual MMU within the hypervisor.
-*
-* C interface:
-*
-*   vbiVmmuConfig (VMMU_CONFIG *config) /@ The vmmu configuration @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiVmmuConfig - configure the hypervisor virtual MMU
+ *
+ * This system call configures the context's virtual MMU within the hypervisor.
+ *
+ */
 FUNC_LABEL(vbiVmmuConfig)
-	lis	r0, HI(VBI_SYS_vmmu_config)
-	ori	r0, r0, LO(VBI_SYS_vmmu_config)
-	HCALL
+	lis r0, HI(VBI_SYS_vmmu_config)
+	ori r0, r0, LO(VBI_SYS_vmmu_config)
+	sc
 	blr
 FUNC_END(vbiVmmuConfig)
 
-
-/******************************************************************************
-*
-* vbiVmmuEnable - enables the virtual MMU
-*
-* This system call enables a context's virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuEnable (unsigned int vmmu_num) /@ Enable the specified VMMU @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiVmmuEnable - enables the virtual MMU
+ *
+ * This system call enables a context's virtual MMU.
+ *
+ */
 FUNC_LABEL(vbiVmmuEnable)
-	lis	r0, HI(VBI_SYS_vmmu_enable)
-	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
-	HCALL
+	lis r0, HI(VBI_SYS_vmmu_enable)
+	ori r0, r0, LO(VBI_SYS_vmmu_enable)
+	sc
 	blr
 FUNC_END(vbiVmmuEnable)
 
-
-/******************************************************************************
-*
-* vbiVmmuDisable - disable the virtual MMU
-*
-* This system call disables a context's virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuDisable (unsigned int vmmu_num) /@ Disable the specified VMMU @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiVmmuDisable - disable the virtual MMU
+ *
+ * This system call disables a context's virtual MMU.
+ *
+ */
 FUNC_LABEL(vbiVmmuDisable)
-	lis	r0, HI(VBI_SYS_vmmu_disable)
-	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
-	HCALL
+	lis r0, HI(VBI_SYS_vmmu_disable)
+	ori r0, r0, LO(VBI_SYS_vmmu_disable)
+	sc
 	blr
 FUNC_END(vbiVmmuDisable)
 
-
-/******************************************************************************
-*
-* vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
-*
-* This system call loads the TLB entries for the specified address range into
-* the virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuTlbLoad (VMMU_CONFIG *config, /@ The VMMU being used @/
-*                   void *addr,		 /@ Starting address    @/
-*                   unsigned int len)    /@ length              @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ *
+ * vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
+ *
+ * This system call loads the TLB entries for the specified address range into
+ * the virtual MMU.
+ *
+ */
 FUNC_LABEL(vbiVmmuTlbLoad)
-	lis	r0, HI(VBI_SYS_vmmu_tlbload)
-	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
-	HCALL
+	lis r0, HI(VBI_SYS_vmmu_tlbload)
+	ori r0, r0, LO(VBI_SYS_vmmu_tlbload)
+	sc
 	blr
 FUNC_END(vbiVmmuTlbLoad)
 
 
-/******************************************************************************
-*
-* vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
-*
-* This system call flushes the TLB entries for the specified address range
-* from the virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuTlbFlush (VMMU_CONFIG *config, /@ The VMMU configuration to use @/
-*		     void *addr,          /@ Starting address              @/
-*		     unsigned int len)    /@ length                        @/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ *
+ * vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
+ *
+ * This system call flushes the TLB entries for the specified address range
+ * from the virtual MMU.
+ *
+ */
 FUNC_LABEL(vbiVmmuTlbFlush)
-	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
-	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
-	HCALL
+	lis r0, HI(VBI_SYS_vmmu_tlbflush)
+	ori r0, r0, LO(VBI_SYS_vmmu_tlbflush)
+	sc
 	blr
 FUNC_END(vbiVmmuTlbFlush)
 
 
-/******************************************************************************
-*
-* vbiHyIoctl - hypervisor ioctl call
-*
-* This system call interfaces to the general purpose hypervisor ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_HYIOCTL_GETPID
-*     VBI_HYIOCTL_GETPRIORITY
-*     VBI_HYIOCTL_PSDISPLAY
-*     VBI_HYIOCTL_GETSTATS
-*     VBI_HYIOCTL_EXCBASE
-*		
-* C interface:
-*
-*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*               void *arg)          /@ address of information @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ *
+ * vbiHyIoctl - hypervisor ioctl call
+ *
+ * This system call interfaces to the general purpose hypervisor ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_HYIOCTL_GETPID
+ *     VBI_HYIOCTL_GETPRIORITY
+ *     VBI_HYIOCTL_PSDISPLAY
+ *     VBI_HYIOCTL_GETSTATS
+ *     VBI_HYIOCTL_EXCBASE
+ *
+ */
 FUNC_LABEL(vbiHyIoctl)
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
+	lis r0, HI(VBI_SYS_hyIoctl)
+	ori r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
 	blr
 FUNC_END(vbiHyIoctl)
 
-/******************************************************************************
-*
-* vbiCtxctl - hypervisor context control call
-*
-* This system call interfaces to the general purpose hypervisor context
-* control function.
-*
-* Possbile operations:
-*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
-*
-* C interface:
-*
-*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
-*		 void *arg)		 /@ address of argument @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ *
+ * vbiCtxctl - hypervisor context control call
+ *
+ * This system call interfaces to the general purpose hypervisor context
+ * control function.
+ *
+ * Possbile operations:
+ *	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+ *
+ */
 FUNC_LABEL(vbiCtxctl)
-	lis	r0, HI(VBI_SYS_ctxctl)
-	ori	r0, r0, LO(VBI_SYS_ctxctl)
-	HCALL
+	lis r0, HI(VBI_SYS_ctxctl)
+	ori r0, r0, LO(VBI_SYS_ctxctl)
+	sc
 	blr
 FUNC_END(vbiCtxctl)
 
-/*******************************************************************************
-*
-* vbiMemAttrSet - Set protection for a page of memory
-*
-* This routine makes a hypercall to set the MMU attribures for the specified
-* memory range. The possible attributes one or a combinarion of the following:
-* 
-* VBI_MMU_PROT_READ -  allow supervisor and user read
-* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
-* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrSet 
-*		(
-*		void	 *gaddr,	/@ Address of page to change attr   @/
-*		size_t   length,	/@ length of address		    @/
-*		uint32_t attr		/@ mmu attributes to set	    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
+/*
+ *
+ * vbiMemAttrSet - Set protection for a page of memory
+ *
+ * This routine makes a hypercall to set the MMU attribures for the specified
+ * memory range. The possible attributes one or a combinarion of the following:
+ *
+ * VBI_MMU_PROT_READ -  allow supervisor and user read
+ * VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+ * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+ *
+ */
 FUNC_LABEL(vbiMemAttrSet)
-	lis	r0, HI(VBI_SYS_mmu_attr_set)
-	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
-	HCALL
+	lis r0, HI(VBI_SYS_mmu_attr_set)
+	ori r0, r0, LO(VBI_SYS_mmu_attr_set)
+	sc
 	blr
 FUNC_END(vbiMemAttrSet)
 
-/******************************************************************************
-*
-* vbiMemAttrGet - Get MMU page protections
-*
-* This routine makes a hypercall to retrieve the MMU attributes associated for
-* the page where the specified address is mapped. This is not the VMMU
-* attributes. A guest OS has direct access to the mapping table of its VMMU
-* therefore a hypercall is not necessary.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrGet 
-*		(
-*		void	 *gaddr		/@ Address of page to change attr   @/
-*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
+/*
+ * vbiMemAttrGet - Get MMU page protections
+ *
+ * This routine makes a hypercall to retrieve the MMU attributes associated for
+ * the page where the specified address is mapped. This is not the VMMU
+ * attributes. A guest OS has direct access to the mapping table of its VMMU
+ * therefore a hypercall is not necessary.
+ *
+ */
 FUNC_LABEL(vbiMemAttrGet)
-	lis	r0, HI(VBI_SYS_mmu_attr_get)
-	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
-	HCALL
+	lis r0, HI(VBI_SYS_mmu_attr_get)
+	ori r0, r0, LO(VBI_SYS_mmu_attr_get)
+	sc
 	blr
 FUNC_END(vbiMemAttrGet)
 
-/******************************************************************************
-*
-* vbiIoapicIoctl - virtual IO APIC ioctl call
-*
-* This system call interfaces to the virtual IO APIC ioctl
-* function. For PPC this is a nop routine for now.
-*
-* Possible ioctl commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*		
-* C interface:
-*
-*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*                   unsigned arg1,      /@ address of information @/
-*                   unsigned arg2)      /@ address of information @/
-*
-* Returns: OK
-*
-*/
-
+/*
+ * vbiIoapicIoctl - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function. For PPC this is a nop routine for now.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ */
 FUNC_LABEL(vbiIoapicIoctl)
-	lis   r0, HI(VBI_SYS_vIoapicIoctl)
-	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	HCALL
+	lis r0, HI(VBI_SYS_vIoapicIoctl)
+	ori r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
 	blr
 FUNC_END(vbiIoapicIoctl)
 
-/******************************************************************************
-*
-* vbiNsOp - virtua board name service call
-*
-* This system call interfaces to the virtual board
-*
-* commands:
-*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
-*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
-*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
-*				
-* C interface:
-*
-*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
-*	    char * name,		    /@ the service name		@/
-*	    uint32_t revision,	    /@ service revision		@/
-*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
-*	  )
-*
-* Returns: OK or ERROR in case of failure
-*
-*/
-
+/*
+ *
+ * vbiNsOp - virtua board name service call
+ *
+ * This system call interfaces to the virtual board
+ *
+ * commands:
+ *	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+ *	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+ *	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+ *
+ */
 FUNC_LABEL(vbiNsOp)
-	lis   r0, HI(VBI_SYS_ns_op)
-	ori	r0, r0, LO(VBI_SYS_ns_op)
-	HCALL
+	lis r0, HI(VBI_SYS_ns_op)
+	ori r0, r0, LO(VBI_SYS_ns_op)
+	sc
 	blr
 FUNC_END(vbiNsOp)
 
-/*******************************************************************************
-*
-* vbiVbMemoryRead - Read a virtual board's memory
-*
-* This routine makes a hypercall to read a remote board's memory. The memory control
-* structure contains information about the target memory to read and the destination
-* buffer that hypervisor must populate with the data read. This routine is used
-* to copy data from a remote VB. It is the user's responsability to ensure that
-* the memory read is accessed orthogonally.
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-*
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	    @/
-*   void	*pAddress;	    /@ address of calling context	    @/
-*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
-*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
-*   uint32_t	reserved;	    /@ reserved for future use		    @/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryRead 
-*	(
-*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
-*	vbiVb_t	    targetBoard	    /@ target board				@/
-*	)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbMemoryRead - Read a virtual board's memory
+ *
+ * This routine makes a hypercall to read a remote board's memory. The memory
+ * control structure contains information about the target memory to read and
+ * the destination buffer that hypervisor must populate with the data read.
+ * This routine is used to copy data from a remote VB. It is the user's
+ * responsability to ensure that the memory read is accessed orthogonally.  The
+ * sizeIn parameter specifies the number of bytes desired to be copied.  The
+ * sizeOut parameter indicates the number of bytes successfully copied.  A user
+ * may set the sizeOut parameter to zero if the output size is not of interest
+ * otherwise to a value different than zero.
+ *
+ */
 FUNC_LABEL(vbiVbMemoryRead)
-	lis   r0, HI(VBI_SYS_memRead_op)
-	ori	r0, r0, LO(VBI_SYS_memRead_op)
-	HCALL
+	lis r0, HI(VBI_SYS_memRead_op)
+	ori r0, r0, LO(VBI_SYS_memRead_op)
+	sc
 	blr
 FUNC_END(vbiVbMemoryRead)
 
-/*******************************************************************************
-*
-* vbiVbMemoryWrite - copy data to a remote board's memory
-*
-* This routine makes a hypercall to copy to a remote board memory. If the
-* VBI_DCACHE_FLUSH is set in the control memory control structure then this
-* routine flushes the data caches lines corresponding to the range of memory
-* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
-* cache lines corresponding to the range of address is invalidated after the
-* memory is copied. Invalidating the instruction is required if data containing
-* is updated since the instruction cache is not aware of the content in data
-* cache. Therefore flushing the data cache ensures that memory contains the
-* updated data and invalidating the instruction cache ensures that the stale
-* values in the instruction cache is thrown away. 
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-* 
-* 
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	@/
-*   void	*pAddress;	    /@ address of calling context	@/
-*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
-*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
-*   uint32_t	flags;		    /@ data/instruction flush option	@/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryWrite 
-*	(
-*	VBI_MEM_CTL	*memCtl, 
-*	vbiVb_t		targetBoard 
-*	)
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbMemoryWrite - copy data to a remote board's memory
+ *
+ * This routine makes a hypercall to copy to a remote board memory. If the
+ * VBI_DCACHE_FLUSH is set in the control memory control structure then this
+ * routine flushes the data caches lines corresponding to the range of memory
+ * specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+ * cache lines corresponding to the range of address is invalidated after the
+ * memory is copied. Invalidating the instruction is required if data
+ * containing is updated since the instruction cache is not aware of the
+ * content in data cache. Therefore flushing the data cache ensures that memory
+ * contains the updated data and invalidating the instruction cache ensures
+ * that the stale values in the instruction cache is thrown away.  The sizeIn
+ * parameter specifies the number of bytes desired to be copied.  The sizeOut
+ * parameter indicates the number of bytes successfully copied.  A user may set
+ * the sizeOut parameter to zero if the output size is not of interest
+ * otherwise to a value different than zero.
+ *
+ */
 FUNC_LABEL(vbiVbMemoryWrite)
-	lis	r0, HI(VBI_SYS_memWrite_op)
-	ori	r0, r0, LO(VBI_SYS_memWrite_op)
-	HCALL
+	lis r0, HI(VBI_SYS_memWrite_op)
+	ori r0, r0, LO(VBI_SYS_memWrite_op)
+	sc
 	blr
 FUNC_END(vbiVbMemoryWrite)
 
-/******************************************************************************
-*
-* vbiIoapicOp - virtual IO APIC operation
-*
-* This system call interfaces to the virtual IO APIC ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*		
-* C interface:
-*
-*   vbiIoapicOp (unsigned int ioctl,	/@ the ioctl command      @/
-*                vbiIrq_t irq,		/@ address of information @/
-*                uint32_t filter),      /@ address of information @/
-*                vbiVb_t vbId)		/@ address of information @/
-*
-* Returns: OK
-*
-*/
-
+/*
+ * vbiIoapicOp - virtual IO APIC operation
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ */
 FUNC_LABEL(vbiIoapicOp)
-	lis   r0, HI(VBI_SYS_vIoapicIoctl)
-	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	HCALL
+	lis r0, HI(VBI_SYS_vIoapicIoctl)
+	ori r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
 	blr
 FUNC_END(vbiIoapicOp)
 
-/*******************************************************************************
-*
-* vbiVbRegisterRead - Read a remote core's registers
-*
-* This routine makes a hypercall to read a remote core's registers. The register
-* control structure contains information about the registers to read and the
-* destination buffers to store them.
-* 
-* SYNOPSIS
-*
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiVbRegisterRead 
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
-*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
-*	vbiCore_t   core		    /@ core within the target VB    @/
-*	)
-*
-* typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
-*
-*    uint32_t srr0;		/@  0: PC				    @/
-*    uint32_t srr1;		/@  1: MSR				    @/
-*    uint32_t cr;		/@  2: condition registers		    @/
-*    uint32_t r0;		/@  3: General register R0		    @/
-*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;		/@  5: General register R2		    @/
-*    uint32_t r3;		/@  6: General register R3		    @/
-*    uint32_t r4;		/@  7: General register R4		    @/
-*    uint32_t r5;		/@  8: General register R5		    @/
-*    uint32_t r6;		/@  9: General register R6		    @/
-*    uint32_t r7;		/@ 10: General register R7		    @/
-*    uint32_t r8;		/@ 11: General register R8		    @/
-*    uint32_t r9;		/@ 12: General register R9		    @/
-*    uint32_t r10;		/@ 13: General register R10		    @/
-*    uint32_t r11;		/@ 14: General register R11		    @/
-*    uint32_t r12;		/@ 15: General register R12		    @/
-*    uint32_t r13;		/@ 16: General register R13		    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2			    @/
-*
-*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
-*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
-*
-*    /@ data address compare registers DAC1-DAC2.			    @/
-*
-*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
-*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
-*
-*    /@ reserved fields for future use					    @/
-*
-*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbRegisterRead - Read a remote core's registers
+ *
+ * This routine makes a hypercall to read a remote core's registers. The
+ * register control structure contains information about the registers to read
+ * and the destination buffers to store them.
+ *
+ */
 FUNC_LABEL(vbiVbRegisterRead)
-	lis   r0, HI(VBI_SYS_RegsRead_op)
-	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
-	HCALL
+	lis r0, HI(VBI_SYS_RegsRead_op)
+	ori r0, r0, LO(VBI_SYS_RegsRead_op)
+	sc
 	blr
 FUNC_END(vbiVbRegisterRead)
 
-/*******************************************************************************
-*
-* vbiVbRegisterWrite - write to a remote core's registers
-*
-* This routine makes a hypercall to write to a remote core's registers. The
-* register control structure contains the set of registers to write. 
-* The user must ensure to read first the destination core's registers using
-* vbiVbRegisterRead() then write back the modified set of registers in the 
-* registers control structure.
-* 
-*
-*typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
-*
-*    uint32_t srr0;		/@  0: PC				    @/
-*    uint32_t srr1;		/@  1: MSR				    @/
-*    uint32_t cr;		/@  2: condition registers		    @/
-*    uint32_t r0;		/@  3: General register R0		    @/
-*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;		/@  5: General register R2		    @/
-*    uint32_t r3;		/@  6: General register R3		    @/
-*    uint32_t r4;		/@  7: General register R4		    @/
-*    uint32_t r5;		/@  8: General register R5		    @/
-*    uint32_t r6;		/@  9: General register R6		    @/
-*    uint32_t r7;		/@ 10: General register R7		    @/
-*    uint32_t r8;		/@ 11: General register R8		    @/
-*    uint32_t r9;		/@ 12: General register R9		    @/
-*    uint32_t r10;		/@ 13: General register R10		    @/
-*    uint32_t r11;		/@ 14: General register R11		    @/
-*    uint32_t r12;		/@ 15: General register R12		    @/
-*    uint32_t r13;		/@ 16: General register R13		    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2			    @/
-*
-*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
-*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
-*
-*    /@ data address compare registers DAC1-DAC2.			    @/
-*
-*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
-*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
-*
-*    /@ reserved fields for future use					    @/
-*
-*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-* 
-* VBI PPC Architecture Supplements
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVbRegisterWrite
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
-*	vbiVb_t			targetBoard,	/@ The target board		 @/
-*	vbiCore_t		core		/@ The target core within the VB @/
-*	)
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbRegisterWrite - write to a remote core's registers
+ *
+ * This routine makes a hypercall to write to a remote core's registers. The
+ * register control structure contains the set of registers to write.
+ * The user must ensure to read first the destination core's registers using
+ * vbiVbRegisterRead() then write back the modified set of registers in the
+ * registers control structure.
+ *
+ */
 FUNC_LABEL(vbiVbRegisterWrite)
-	lis   r0, HI(VBI_SYS_RegsWrite_op)
-	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
-	HCALL
+	lis r0, HI(VBI_SYS_RegsWrite_op)
+	ori r0, r0, LO(VBI_SYS_RegsWrite_op)
+	sc
 	blr
 FUNC_END(vbiVbRegisterWrite)
 
-
-/*******************************************************************************
-*
-* vbiVcoreIntRed_op - redirect an irq to another vcore
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVcoreIntRed_op 
-*	(
-*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
-*	vbiCore_t		core	/@ destination vcore		 @/
-*	)
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: 
-*
-*vbiVioapicIntRedirect()
-* 
-*
-*/
-
+/*
+ * vbiVcoreIntRed_op - redirect an irq to another vcore
+ */
 FUNC_LABEL(vbiVcoreIntRed_op)
-	lis   r0, HI(VBI_SYS_intRedirect)
-	ori	r0, r0, LO(VBI_SYS_intRedirect)
-	HCALL
+	lis r0, HI(VBI_SYS_intRedirect)
+	ori r0, r0, LO(VBI_SYS_intRedirect)
+	sc
 	blr
 FUNC_END(vbiVcoreIntRed_op)
-- 
1.6.5.2

