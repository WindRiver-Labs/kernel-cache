From 7e2402117fddd9b3372d27691890935f696e292a Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Tue, 2 Feb 2010 16:25:45 -0800
Subject: [PATCH] x86 - Add support for PCI shared interrupts and USB.

Since we drive the USB hardware directly from Linux,
we need any quirks to be applied before the driver
initializes.

Also, USB hardware shares interrupts.  Support is
added via a new bootarg, namely "shared_interrupts" which
allows more than one PCI device to use an irq.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c    |   70 +++++++++++++++++++++++++++++++++++++++-
 drivers/usb/host/pci-quirks.c |    3 +-
 include/linux/wrhv.h          |   14 +++++++-
 kernel/vbi/wrhv.c             |   15 +++++++++
 4 files changed, 97 insertions(+), 5 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 9c901ae..a6614eb 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -38,6 +38,8 @@
 #define WRHV_RESERVED_PAGES	16
 #define WRHV_RESERVED_TOP	(WRHV_RESERVED_PAGES * PAGE_SIZE)
 
+#define WRHV_BOOTARG_BUF_SIZE	256
+
 /* Copied over during early bootstrap */
 struct vb_config __wr_config = { .pid = -1 };
 struct vb_config *_wr_config; /* Pointer passed from hypervisor */
@@ -308,6 +310,48 @@ static int __init wrhv_check_kgdboe(char *str)
 }
 early_param("kgdboe", wrhv_check_kgdboe);
 
+static char *shared_interrupts_list;
+static int __init wrhv_check_shared_interrupts(char *str)
+{
+	shared_interrupts_list = str;
+	return 0;
+}
+early_param("shared_interrupts", wrhv_check_shared_interrupts);
+
+int find_shared_interrupt(char *devfn)
+{
+	char	shared_interrupts[WRHV_BOOTARG_BUF_SIZE];
+	char	devfn_list[WRHV_BOOTARG_BUF_SIZE];
+	char	*current_tok, *devfn_tok;
+	char	*position, *devfn_pos;
+	int	intr_num;
+
+	if (shared_interrupts_list == NULL)
+		return -1;
+
+	strncpy(shared_interrupts, shared_interrupts_list,
+		WRHV_BOOTARG_BUF_SIZE-1);
+	shared_interrupts[WRHV_BOOTARG_BUF_SIZE-1] = '\0'; /* be safe */
+	position = shared_interrupts;
+	/* crack by ':' first */
+	while ((current_tok = strsep(&position, ":"))) {
+		/* crack by '@' second */
+		if (sscanf(current_tok, "%x@%s", &intr_num, devfn_list) != 2)
+			return -1; /* broken list */
+
+		/* crack by ',' third */
+		devfn_pos = devfn_list;
+		while ((devfn_tok = strsep(&devfn_pos, ","))) {
+			if (strcmp(devfn_tok, devfn) == 0) {
+				/* We have a match! */
+				return intr_num;
+			}
+		}
+	}
+	/* Didn't find it */
+	return -1;
+}
+
 static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 {
 	int irq;
@@ -330,6 +374,16 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 	case PCI_BASE_CLASS_DISPLAY:
 		devclass = "VGA";
 		break;
+
+	case PCI_BASE_CLASS_SERIAL:
+		/* Look at the upper byte of the class to see if the
+		   device is usb.
+		*/
+		if ((dev->class >> 8) == PCI_CLASS_SERIAL_USB) {
+			devclass = "USB";
+			break;
+		}
+
 	default:
 		skip_assign_irq = 1;
 		irq = dev->irq;
@@ -337,8 +391,20 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 	}
 
 	if (!skip_assign_irq) {
-		snprintf(devname, sizeof devname, "pci%s_%x:%x",
-			devclass, dev->bus->number, dev->devfn);
+		int sharedint;
+
+		/* See if a shared interrupt first */
+		snprintf(devname, sizeof devname, "%x-%x",
+			dev->bus->number, dev->devfn);
+		sharedint = find_shared_interrupt(devname);
+		if (sharedint < 0) {
+			/* Not found as a shared int, look it up directly */
+			snprintf(devname, sizeof devname, "pci%s_%x:%x",
+				devclass, dev->bus->number, dev->devfn);
+		} else {
+			snprintf(devname, sizeof devname, "pciSharedInt_%x",
+				sharedint);
+		}
 		irq = vbi_find_irq(devname, 1);
 		if (irq == VBI_INVALID_IRQ)
 			irq = WRHV_POLL_IRQ;
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 055a17e..c571296 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -14,6 +14,7 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/acpi.h>
+#include <linux/wrhv.h>
 #include "pci-quirks.h"
 
 
@@ -354,7 +355,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 
 static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 {
-	if (paravirt_enabled())
+	if (paravirt_skip_usb_quirks())
 		return;
 
 	if (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)
diff --git a/include/linux/wrhv.h b/include/linux/wrhv.h
index 885269d..9c88269 100644
--- a/include/linux/wrhv.h
+++ b/include/linux/wrhv.h
@@ -15,7 +15,10 @@
 #ifndef __LINUX_WRHV_H
 #define __LINUX_WRHV_H
 
+#include <linux/irqreturn.h>
+
 #ifdef CONFIG_WRHV
+extern int paravirt_skip_usb_quirks(void);
 extern irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id);
 extern unsigned long wrhv_calculate_cpu_khz(void);
 extern struct irq_chip wrhv_irq_chip;
@@ -86,7 +89,14 @@ typedef union {
 	uint32_t value;
 } VIOAPIC_REDIR_LOW;
 
-#else
-#endif
+#else  /* Not WRHV */
+
+/* Skip quirks if paravirtualization is on */
+static inline int paravirt_skip_usb_quirks(void)
+{
+	return paravirt_enabled();
+}
+
+#endif /* CONFIG_WRHV */
 
 #endif	/* __LINUX_WRHV_H */
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index 59fa6a7..b2ed761 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -172,3 +172,18 @@ irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
 		account_steal_time(NULL, jiffies_to_cputime(lost_jiffies));
 	return IRQ_HANDLED;
 }
+
+int paravirt_skip_usb_quirks(void)
+{
+	/*	Because we are driving the USB hardware directly in Linux,
+		we need the quirk fixes to apply.  Xen and kvm don't want
+		to run the quirk fixes because they don't run through the
+		bios as part of startup.  The host OS in that case has
+		already dealt with usb initialization and has already
+		worked around the quirks.  In our case, we come up in the
+		bios, eat the bios usb pollution, run the hypervisor
+		(which doesn't touch the usb), then it is up to us to deal
+		with the usb quirk fixups (more or less bios cleanup).
+	*/
+	return 0;
+}
-- 
1.6.5.2

