From 7e2402117fddd9b3372d27691890935f696e292a Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Tue, 2 Feb 2010 16:25:45 -0800
Subject: [PATCH] x86 - Add support for PCI shared interrupts and USB.

USB hardware shares interrupts.  Support is
added via a new bootarg, namely "shared_interrupts" which
allows more than one PCI device to use an irq.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c    |   70 +++++++++++++++++++++++++++++++++++++++-
 include/linux/wrhv.h          |   14 +++++++-
 kernel/vbi/wrhv.c             |   15 +++++++++

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 9c901ae..a6614eb 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -38,6 +38,8 @@
 #define WRHV_RESERVED_PAGES	16
 #define WRHV_RESERVED_TOP	(WRHV_RESERVED_PAGES * PAGE_SIZE)
 
+#define WRHV_BOOTARG_BUF_SIZE	256
+
 /* Copied over during early bootstrap */
 struct vb_config __wr_config = { .pid = -1 };
 struct vb_config *_wr_config; /* Pointer passed from hypervisor */
@@ -308,6 +310,48 @@ static int __init wrhv_check_kgdboe(char *str)
 }
 early_param("kgdboe", wrhv_check_kgdboe);
 
+static char *shared_interrupts_list;
+static int __init wrhv_check_shared_interrupts(char *str)
+{
+	shared_interrupts_list = str;
+	return 0;
+}
+early_param("shared_interrupts", wrhv_check_shared_interrupts);
+
+int find_shared_interrupt(char *devfn)
+{
+	char	shared_interrupts[WRHV_BOOTARG_BUF_SIZE];
+	char	devfn_list[WRHV_BOOTARG_BUF_SIZE];
+	char	*current_tok, *devfn_tok;
+	char	*position, *devfn_pos;
+	int	intr_num;
+
+	if (shared_interrupts_list == NULL)
+		return -1;
+
+	strncpy(shared_interrupts, shared_interrupts_list,
+		WRHV_BOOTARG_BUF_SIZE-1);
+	shared_interrupts[WRHV_BOOTARG_BUF_SIZE-1] = '\0'; /* be safe */
+	position = shared_interrupts;
+	/* crack by ':' first */
+	while ((current_tok = strsep(&position, ":"))) {
+		/* crack by '@' second */
+		if (sscanf(current_tok, "%x@%s", &intr_num, devfn_list) != 2)
+			return -1; /* broken list */
+
+		/* crack by ',' third */
+		devfn_pos = devfn_list;
+		while ((devfn_tok = strsep(&devfn_pos, ","))) {
+			if (strcmp(devfn_tok, devfn) == 0) {
+				/* We have a match! */
+				return intr_num;
+			}
+		}
+	}
+	/* Didn't find it */
+	return -1;
+}
+
 static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 {
 	int irq;
@@ -330,6 +374,16 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 	case PCI_BASE_CLASS_DISPLAY:
 		devclass = "VGA";
 		break;
+
+	case PCI_BASE_CLASS_SERIAL:
+		/* Look at the upper byte of the class to see if the
+		   device is usb.
+		*/
+		if ((dev->class >> 8) == PCI_CLASS_SERIAL_USB) {
+			devclass = "USB";
+			break;
+		}
+
 	default:
 		skip_assign_irq = 1;
 		irq = dev->irq;
@@ -337,8 +391,20 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 	}
 
 	if (!skip_assign_irq) {
-		snprintf(devname, sizeof devname, "pci%s_%x:%x",
-			devclass, dev->bus->number, dev->devfn);
+		int sharedint;
+
+		/* See if a shared interrupt first */
+		snprintf(devname, sizeof devname, "%x-%x",
+			dev->bus->number, dev->devfn);
+		sharedint = find_shared_interrupt(devname);
+		if (sharedint < 0) {
+			/* Not found as a shared int, look it up directly */
+			snprintf(devname, sizeof devname, "pci%s_%x:%x",
+				devclass, dev->bus->number, dev->devfn);
+		} else {
+			snprintf(devname, sizeof devname, "pciSharedInt_%x",
+				sharedint);
+		}
 		irq = vbi_find_irq(devname, 1);
 		if (irq == VBI_INVALID_IRQ)
 			irq = WRHV_POLL_IRQ;
-- 
1.6.5.2

