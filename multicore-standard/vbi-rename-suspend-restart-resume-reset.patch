From eaf5e3c2aa6244e43db8d8417bcf75daeea89148 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Tue, 17 Nov 2009 16:19:07 -0500
Subject: [PATCH 13/80] vbi: rename suspend, restart, resume, reset

for i in `git grep -l vbiVbSuspend `  ; do echo $i ; mv $i $i~ ; cat $i~ |sed 's/vbiVbSuspend/vbi_vb_suspend/g' > $i ; done

for i in `git grep -l vbiVbResume `  ; do echo $i ; mv $i $i~ ; cat $i~ |sed 's/vbiVbResume/vbi_vb_resume/g' > $i ; done

for i in `git grep -l vbiVbRestart `  ; do echo $i ; mv $i $i~ ; cat $i~ |sed 's/vbiVbRestart/vbi_vb_restart/g' > $i ; done

for i in `git grep -l vbiVbReset `  ; do echo $i ; mv $i $i~ ; cat $i~ |sed 's/vbiVbReset/vbi_vb_reset/g' > $i ; done

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/vbi/syscalls.S |   40 ++++++++++++++++++------------------
 arch/powerpc/kernel/vbi/wrhv.c     |    2 +-
 arch/x86/kernel/vbi/syscalls.S     |   32 ++++++++++++++--------------
 arch/x86/kernel/vbi/wrhv.c         |    4 +-
 include/vbi/syscall.h              |    8 +++---
 5 files changed, 43 insertions(+), 43 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index 0806de3..daea4ac 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -63,10 +63,10 @@ FUNC_EXPORT(vbiVmmuTlbLoad)
 FUNC_EXPORT(vbiVmmuTlbFlush)
 FUNC_EXPORT(vbiVbMgmt)
 FUNC_EXPORT(vbiNsOp)
-FUNC_EXPORT(vbiVbSuspend)
-FUNC_EXPORT(vbiVbReset)
-FUNC_EXPORT(vbiVbRestart)
-FUNC_EXPORT(vbiVbResume)
+FUNC_EXPORT(vbi_vb_suspend)
+FUNC_EXPORT(vbi_vb_reset)
+FUNC_EXPORT(vbi_vb_restart)
+FUNC_EXPORT(vbi_vb_resume)
 
 _WRS_TEXT_SEG_START
 
@@ -121,11 +121,11 @@ FUNC_END(vbiVbMgmt)
 
 
 /*
- * vbiVbSuspend - Suspend a virtual board's core
+ * vbi_vb_suspend - Suspend a virtual board's core
  *
  * This routine makes a hypercall in order to suspend one or more cores that
  * exist within the specified virtual board. The target core(s) enter HALT
- * state until vbiVbResume() is called change the state of the core(s). This
+ * state until vbi_vb_resume() is called change the state of the core(s). This
  * function will return only after all victim cores are suspended unless the
  * opration fails to complete. The second argument passed to this function
  * specifies one or more target cores. For suspending every core within the
@@ -138,21 +138,21 @@ FUNC_END(vbiVbMgmt)
  * virtual board managment service.
  *
  */
-FUNC_LABEL(vbiVbSuspend)
+FUNC_LABEL(vbi_vb_suspend)
         lis r0, HI(VBI_SYS_vbSuspend)
         ori r0, r0, LO(VBI_SYS_vbSuspend)
         HCALL
         blr
-FUNC_END(vbiVbSuspend)
+FUNC_END(vbi_vb_suspend)
 
 /*
- * vbiVbReset - Reset a virtual board's core
+ * vbi_vb_reset - Reset a virtual board's core
  *
  * This routine makes a hypercall in order to reset one or more cores that
  * exist within the specified virtual board. Calling this function puts the
  * target core(s) program counter to it's ENTRY function. The ENTRY function is
  * determined based on the loaded binary image. A core does not execute beyond
- * it's ENTRY function unless vbiVbRestart() is explitly called.  Except for
+ * it's ENTRY function unless vbi_vb_restart() is explitly called.  Except for
  * core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0 option is
  * set in the flag passed as the third argument to this routine.  The hypercall
  * sends a message to a manager that provides VB managment services.  This
@@ -184,19 +184,19 @@ FUNC_END(vbiVbSuspend)
  * in such scenario.
  *
  */
-FUNC_LABEL(vbiVbReset)
+FUNC_LABEL(vbi_vb_reset)
         lis r0, HI(VBI_SYS_vbReset)
         ori r0, r0, LO(VBI_SYS_vbReset)
         HCALL
         blr
-FUNC_END(vbiVbReset)
+FUNC_END(vbi_vb_reset)
 
 /*
- * vbiVbRestart - Restart a virtual board's core
+ * vbi_vb_restart - Restart a virtual board's core
  *
  * This routine makes a hypercall in order to restart a virtual cores from
  * reset.  It's called to start running a core or cores that were previously
- * reset by calling vbiVbReset(). The target core(s) start(s) executing from
+ * reset by calling vbi_vb_reset(). The target core(s) start(s) executing from
  * the ENTRY function retrieved from the corresponding binary image.  This
  * function will return only after  all cores are out of reset unless the
  * operation fails to complete.  The second argument represents the cores to
@@ -208,20 +208,20 @@ FUNC_END(vbiVbReset)
  * services.
  *
  */
-FUNC_LABEL(vbiVbRestart)
+FUNC_LABEL(vbi_vb_restart)
         lis r0, HI(VBI_SYS_vbRestart)
         ori r0, r0, LO(VBI_SYS_vbRestart)
         HCALL
         blr
-FUNC_END(vbiVbRestart)
+FUNC_END(vbi_vb_restart)
 
 /*
  *
- * vbiVbResume - Resume a virtual board's core
+ * vbi_vb_resume - Resume a virtual board's core
  *
  * This routine makes a hypercall in order to resume one or cores within the
  * specified virtual board. It reactivates a cores or cores that were
- * previously suspended by calling vbiVbResume(). This function will return
+ * previously suspended by calling vbi_vb_resume(). This function will return
  * only after all victim cores are resumed unless the operation fails. The
  * order of which the cores are resumed is not determined. The second argument
  * may a magic number instead of a valid core number to indicate that the
@@ -232,12 +232,12 @@ FUNC_END(vbiVbRestart)
  * running is not considered as programming error.
  *
  */
-FUNC_LABEL(vbiVbResume)
+FUNC_LABEL(vbi_vb_resume)
         lis r0, HI(VBI_SYS_vbResume)
         ori r0, r0, LO(VBI_SYS_vbResume)
         HCALL
         blr
-FUNC_END(vbiVbResume)
+FUNC_END(vbi_vb_resume)
 
 /*
  *
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 5b1943d..22636ae 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -241,7 +241,7 @@ void wrhv_restart(void)
 	int ret;
 	printk(KERN_INFO "WRHV: rebooting \n");
 
-	ret = vbiVbReset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
+	ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
 		VBI_VBMGMT_RESET_AND_START_CORE0 |
 		VBI_VBMGMT_RESET_DOWNLOAD |
 		VBI_VBMGMT_RESET_CLEAR
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index 25e82d3..13c67a1 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -46,10 +46,10 @@
 .globl vbiMemAttrSet
 .globl vbiMemAttrGet
 .globl vbiNsOp
-.globl vbiVbReset
-.globl vbiVbRestart
-.globl vbiVbResume
-.globl vbiVbSuspend
+.globl vbi_vb_reset
+.globl vbi_vb_restart
+.globl vbi_vb_resume
+.globl vbi_vb_suspend
 .globl vbiVcoreIntRed_op 
 .globl vbi_vb_read_reg 
 .globl vbi_vb_write_reg 
@@ -252,11 +252,11 @@ vbiVbMgmt:
 	ret
 
 /*
- * vbiVbSuspend - Suspend a virtual board's core
+ * vbi_vb_suspend - Suspend a virtual board's core
  *
  * This routine makes a hypercall in order to suspend one or more cores
  * that exist within the specified virtual board. The target core(s)
- * enter HALT state until vbiVbResume() is called change the state of
+ * enter HALT state until vbi_vb_resume() is called change the state of
  * the core(s). This function will return only after all victim cores
  * are suspended unless the opration fails to complete. The second
  * argument passed to this function specifies one or more target cores.
@@ -272,7 +272,7 @@ vbiVbMgmt:
  * RETURNS: OK or an error number in case of failure
  *
  */
-vbiVbSuspend:
+vbi_vb_suspend:
 	movl $VBI_SYS_vbSuspend,%eax
 	push $2
 	vmcall
@@ -280,13 +280,13 @@ vbiVbSuspend:
 	ret
 
 /*
- * vbiVbReset - Reset a virtual board's core
+ * vbi_vb_reset - Reset a virtual board's core
  *
  * This routine makes a hypercall in order to reset one or more cores
  * that exist within the specified virtual board. Calling this function
  * puts the target core(s) program counter to it's ENTRY function. The
  * ENTRY function is determined based on the loaded binary image. A core
- * does not execute beyond it's ENTRY function unless vbiVbRestart() is
+ * does not execute beyond it's ENTRY function unless vbi_vb_restart() is
  * explitly called. Except for core0 within the target VB where
  * VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
  * the third argument to this routine.  The hypercall sends a message to
@@ -324,7 +324,7 @@ vbiVbSuspend:
  * RETURNS: OK or an error number in case of failure
  *
  */
-vbiVbReset:
+vbi_vb_reset:
         movl $VBI_SYS_vbReset,%eax
         push $3
         vmcall
@@ -332,11 +332,11 @@ vbiVbReset:
         ret
 
 /*
- * vbiVbRestart - Restart a virtual board's core
+ * vbi_vb_restart - Restart a virtual board's core
  *
  * This routine makes a hypercall in order to restart a virtual cores
  * from reset.  It's called to start running a core or cores that were
- * previously reset by calling vbiVbReset(). The target core(s) start(s)
+ * previously reset by calling vbi_vb_reset(). The target core(s) start(s)
  * executing from the ENTRY function retrieved from the corresponding
  * binary image.  This function will return only after  all cores are
  * out of reset unless the operation fails to complete.  The second
@@ -351,7 +351,7 @@ vbiVbReset:
  * RETURNS: OK or an error number in case of failure
  *
  */
-vbiVbRestart:
+vbi_vb_restart:
         movl $VBI_SYS_vbRestart,%eax
         push $3
         vmcall
@@ -359,11 +359,11 @@ vbiVbRestart:
         ret
 
 /*
- * vbiVbResume - Resume a virtual board's core
+ * vbi_vb_resume - Resume a virtual board's core
  *
  * This routine makes a hypercall in order to resume one or cores within
  * the specified virtual board. It reactivates a cores or cores that
- * were previously suspended by calling vbiVbResume(). This function
+ * were previously suspended by calling vbi_vb_resume(). This function
  * will return only after all victim cores are resumed unless the
  * operation fails. The order of which the cores are resumed is not
  * determined. The second argument may a magic number instead of a valid
@@ -377,7 +377,7 @@ vbiVbRestart:
  * RETURNS: OK or an error number in case of failure
  *
  */
-vbiVbResume:
+vbi_vb_resume:
         movl $VBI_SYS_vbResume,%eax
         push $2
         vmcall
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index dac8372..84f9ce2 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -1034,7 +1034,7 @@ static void __cpuinit wrhv_smp_start_cpu(void)
 
 static int __cpuinit wrhv_wakeup_secondary_cpu(int core)
 {
-	return vbiVbResume(VBI_BOARD_ID_GET(), core);
+	return vbi_vb_resume(VBI_BOARD_ID_GET(), core);
 }
 
 static int __cpuinit wrhv_do_boot_cpu(int cpu)
@@ -1238,7 +1238,7 @@ void wrhv_restart(void)
 	int ret;
 	printk(KERN_INFO "WRHV: rebooting \n");
 
-	ret = vbiVbReset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
+	ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
 		VBI_VBMGMT_RESET_AND_START_CORE0 |
 		VBI_VBMGMT_RESET_DOWNLOAD |
 		VBI_VBMGMT_RESET_CLEAR
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index acc40d3..12c713f 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -138,10 +138,10 @@ extern vbiStatus_t vbiCacheTextUpdate(void *saddr, size_t size);
 extern vbiStatus_t  vbiExcBaseSet(void * excTblBase);
 
 /* virtual board management API's */
-extern asmlinkage vbiStatus_t vbiVbSuspend(vbiVb_t id, vbiCore_t core);
-extern asmlinkage vbiStatus_t vbiVbReset(vbiVb_t id, vbiCore_t core, uint32_t options);
-extern asmlinkage vbiStatus_t vbiVbRestart(vbiVb_t id, vbiCore_t core);
-extern asmlinkage vbiStatus_t vbiVbResume(vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbi_vb_suspend(vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbi_vb_reset(vbiVb_t id, vbiCore_t core, uint32_t options);
+extern asmlinkage vbiStatus_t vbi_vb_restart(vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbi_vb_resume(vbiVb_t id, vbiCore_t core);
 
 /* read remote vb's memory */
 extern asmlinkage vbiStatus_t vbi_vb_read_mem(VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
-- 
1.6.5.2

