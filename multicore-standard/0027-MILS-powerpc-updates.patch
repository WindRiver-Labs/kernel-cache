From fc4fcb2eb3975e8c368e83b89714307986e4cbad Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 22 Mar 2010 15:49:14 -0400
Subject: [PATCH] MILS: powerpc updates

Integration of the powerpc updates to the shim layer
from KeithB in order to support powerpc.  This will be
merged into the shim layer commit at the next rebase.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h            |    1 +
 arch/powerpc/kernel/vbi/vdk_syscalls.S     |  292 ++++++++++++++++++++-------
 arch/powerpc/kernel/vbi/wrhv.c             |   38 ++++-
 arch/powerpc/platforms/85xx/wrhv_sbc8548.c |    8 +-
 4 files changed, 260 insertions(+), 79 deletions(-)

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 6495671..996d85b 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -25,6 +25,7 @@ extern void wrhv_init_irq(void);
 extern void __init wrhv_calibrate_decr(void);
 extern void __init wrhv_time_init(void);
 extern int __init wrhv_earlycon_setup(void);
+extern int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags);
 #ifdef CONFIG_PCI
 extern int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev);
 #endif
diff --git a/arch/powerpc/kernel/vbi/vdk_syscalls.S b/arch/powerpc/kernel/vbi/vdk_syscalls.S
index 974af7e..df4141a 100644
--- a/arch/powerpc/kernel/vbi/vdk_syscalls.S
+++ b/arch/powerpc/kernel/vbi/vdk_syscalls.S
@@ -22,6 +22,7 @@
 #include <asm/cputable.h>
 #include <asm/asm-offsets.h>
 #include <asm/cache.h>
+#include <asm/vbi.h>
 #include <vbi/vdk_syscalls.h>
 
 #ifdef CONFIG_PPC85xx_VT_MODE   /* not currently implemented */
@@ -30,19 +31,25 @@
 #define HCALL sc
 #endif
 
+#ifdef CONFIG_PPC85xx_VT_MODE	/* not currently implemented */
+#define HCALL sc 1
+#else
+#define HCALL sc
+#endif
 
-#define FUNC_LABEL(func) _GLOBAL(func)
-#define FUNC_EXPORT(func)
-#define FUNC_END(func)
-#define _WRS_TEXT_SEG_START
-#define HI(sym) sym@h
-#define HIADJ(sym) sym@ha
-#define LO(sym) sym@l
+FUNC_EXPORT(vbi_virt_to_phys)
+FUNC_EXPORT(vbi_enable_vmmu)
+FUNC_EXPORT(vbi_config_vmmu)
+FUNC_EXPORT(vbi_flush_dcache)
+FUNC_EXPORT(vbi_flush_icache)
+FUNC_EXPORT(vbi_exec_vec_base_addr_set)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_int_controller_done)
 
 _WRS_TEXT_SEG_START
 
 #define vbi_hcall(name, call)		\
-FUNC_EXPORT(name)			\
 FUNC_LABEL(name)			\
 	lis r0, HI(VBI_SYS_##call);	\
 	ori r0, r0, LO(VBI_SYS_##call);	\
@@ -52,97 +59,230 @@ FUNC_END(name)
 
 
 /*
-*
-* vbi_flush_icache - flush the instruction cache
-*
-* This system call flushes the instruction cache for the specified address
-* range.
-*
-*/
-
+ * vbi_flush_icache - flush the instruction cache
+ *
+ * This system call flushes the instruction cache for the specified address
+ * range.
+ *
+ */
 vbi_hcall(vbi_flush_icache,icache_flush)
 
 /*
-*
-* vbi_flush_dcache - flush the data cache
-*
-* This system call flushes the data cache for the specified address range.
-*
-*/
-
+ * vbi_flush_dcache - flush the data cache
+ *
+ * This system call flushes the data cache for the specified address range.
+ *
+ */
 vbi_hcall(vbi_flush_dcache,dcache_flush)
 
 /*
-*
-* vbi_vmmu_config - configure the hypervisor virtual MMU
-*
-* This system call configures the context's virtual MMU within the hypervisor.
-*
-*/
-
+ * vbi_vmmu_config - configure the hypervisor virtual MMU
+ *
+ * This system call configures the context's virtual MMU within the hypervisor.
+ *
+ */
 vbi_hcall(vbi_config_vmmu,vmmu_config)
 
 /*
-*
-* vbi_vmmu_enable - enables the virtual MMU
-*
-* This system call enables a context's virtual MMU.
-*
-*/
-
+ * vbi_vmmu_enable - enables the virtual MMU
+ *
+ * This system call enables a context's virtual MMU.
+ *
+ */
 vbi_hcall(vbi_enable_vmmu,vmmu_enable)
 
 /*
-*
-* vbi_vmmu_disable - disable the virtual MMU
-*
-* This system call disables a context's virtual MMU.
-*
-*/
-
+ * vbi_vmmu_disable - disable the virtual MMU
+ *
+ * This system call disables a context's virtual MMU.
+ *
+ */
 vbi_hcall(vbi_disable_vmmu,vmmu_disable)
 
 /*
-*
-* vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
-*
-* This system call loads the TLB entries for the specified address range into
-* the virtual MMU.
-*
-*/
-
+ * vbi_vmmu_tlb_load - load a TLB entry into the virtual MMU
+ *
+ * This system call loads the TLB entries for the specified address range into
+ * the virtual MMU.
+ *
+ */
 vbi_hcall(vbi_tlb_load_vmmu,vmmu_tlbload)
 
 /*
-*
-* vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
-*
-* This system call flushes the TLB entries for the specified address range
-* from the virtual MMU.
-*
-*/
-
+ * vbi_vmmu_tlb_flush - load a TLB entry into the virtual MMU
+ *
+ * This system call flushes the TLB entries for the specified address range
+ * from the virtual MMU.
+ *
+ */
 vbi_hcall(vbi_tlb_flush_vmmu,vmmu_tlbflush)
 
 /*
-*
-* vbiExcVecBaseSet - set current partition exception vector base address
-*
-* This system call sets the calling partition exception vector base address.
-*
-*/
-
+ * vbiExcVecBaseSet - set current partition exception vector base address
+ *
+ * This system call sets the calling partition exception vector base address.
+ *
+ */
 vbi_hcall(vbi_exec_vec_base_addr_set,excVecBaseSet)
 
 /*
-*
-* vbi_virt_to_phys - convert a guest OS address to a physical address
-*
-* This system call converts a guest OS address to a physical address
-*
-* HAE API vbiPaddr uses this system call.
-*
-*/
-
+ * vbi_virt_to_phys - convert a guest OS address to a physical address
+ *
+ * This system call converts a guest OS address to a physical address
+ *
+ * HAE API vbiPaddr uses this system call.
+ *
+ */
 vbi_hcall(vbi_virt_to_phys,virtToPhys)
 
+
+/*
+ * vbi_int_controller_done - signal completion of processing by virtual
+ * int controller
+ *
+ * This system notifies the hypervisor that the virtual interrupt controller
+ * in the virtual board has finished procssing the information in the
+ * virtual interrupt controller registers, and requires a refresh.
+ *
+ */
+vbi_hcall(vbi_int_controller_done,int_controller_done)
+
+
+/*
+ * vbi_vcore_irq_lock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_lock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	0
+#else
+	li	p1, -1
+	lis	p2, HIADJ(wr_vb_control)
+	lwz	p2, LO(wr_vb_control)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+#endif
+	blr
+FUNC_END(vbi_vcore_irq_lock)
+FUNC_EXPORT(vbi_vcore_irq_lock)
+
+/*
+ * vbi_vcore_irq_unlock - unlock interrupts for running core
+ *
+ * This routine enables interrupts and makes a fast hypercall if pending
+ * interrupts are detected for the calling core. This is a C wrapper function
+ * for the assembly MACRO VBI_INT_VCORE_UNLOCK().
+ *
+ */
+FUNC_LABEL(vbi_vcore_irq_unlock)
+#ifdef CONFIG_PPC85xx_VT_MODE
+	wrteei	1
+#else
+	lis	p0, HIADJ(wr_vb_control)
+	lwz	p0, LO(wr_vb_control)(p0)
+	li	p1, 0
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+#endif
+tryAgain:
+	lis	p0, HIADJ(wr_vb_status)
+	lwz	p0, LO(wr_vb_status)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis r0, HI(VBI_SYS_int_enable)
+	ori r0, r0, LO(VBI_SYS_int_enable)
+	HCALL
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbi_vcore_irq_unlock)
+FUNC_EXPORT(vbi_vcore_irq_unlock)
+
+/*
+ * The following calls are MILS extensions outside of the normal
+ * VBI 2.0 list of syscalls.
+ */
+
+/*
+ * vdk_sec_audit_event_inject - Inject a Security Audit event
+ *
+ * This system call forces injection of a security audit event.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_inject,secAuditEventInject)
+
+
+/*
+ * vdk_sec_audit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_sec_audit_event_collect,secAuditEventCollect)
+
+
+/*
+ * vdk_safe_crit_event_inject - Inject a Safety Critical event
+ *
+ * This system call forces injection of a Safety Critical event.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_inject,safeCritEventInject)
+
+
+/*
+ * vdk_safe_crit_event_collect - Collect Security Audit events
+ *
+ * This system call collects security audit events from a VB log.
+ *
+ */
+vbi_hcall(vdk_safe_crit_event_collect,safeCritEventCollect)
+
+
+/*
+ * vdk_schedule_name_to_id - return the schedule ID of the schedule <name>
+ *
+ * This system call returns the schedule ID given the schedule name
+ *
+ */
+vbi_hcall(vdk_schedule_name_to_id,scheduleNameToId)
+
+
+/*
+ * vdk_schedule_set - set the current schedule to schedule <name>
+ *
+ * This system call sets schedule <name> to current schedule
+ *
+ */
+vbi_hcall(vdk_schedule_set,scheduleSet)
+
+/*
+ * vdk_port_send - send message to a port
+ *
+ * This system call sends messages to the specified port
+ *
+ */
+vbi_hcall(vdk_port_send,portSend)
+
+/*
+ * vdk_port_get_recv_buf - receive from a port
+ *
+ * This system call gets a buffer from the specified port
+ *
+ */
+vbi_hcall(vdk_port_get_recv_buf,portGetRecvBuf)
+
+/*
+ * vdk_port_buf_release - release a buffer from a port
+ *
+ * This system call releases the specified buffer(s) from the specified port
+ *
+ */
+vbi_hcall(vdk_port_buf_release,portBufRelease)
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index d5bcced..487e484 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -122,6 +122,7 @@ struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
 struct vb_control *wr_control;
 struct vb_status *wr_status;
 EXPORT_SYMBOL(wr_config);
+EXPORT_SYMBOL(wr_status);
 
 void wrhv_mapping(void);
 void mpc85xx_power_down(void);
@@ -326,7 +327,25 @@ void wrhv_mapping(void)
 			 (unsigned long)wr_config->
 			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
 
-	return;
+#ifdef CONFIG_WRHV_MILS
+	if (wr_config->memoryRegionsConfigAddress != 0) {
+		map_page((unsigned long)wr_config->memoryRegionsConfigAddress,
+			(unsigned long)wr_config->memoryRegionsConfigAddress,
+			_PAGE_RAM);
+	}
+	if (wr_config->interruptConfiguration != 0) {
+		map_page((unsigned long)wr_config->interruptConfiguration,
+			(unsigned long)wr_config->interruptConfiguration,
+			_PAGE_RAM);
+	}
+	if (wr_config->vb_status->vbInterruptController != 0) {
+		map_page((unsigned long)wr_config->vb_status->vbInterruptController,
+			(unsigned long)wr_config->vb_status->vbInterruptController,
+			_PAGE_RAM);
+	}
+#endif
+ 
+ 	return;
 }
 
 unsigned long __init wrhv_find_end_of_memory(void)
@@ -1009,6 +1028,7 @@ int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
 		flush_HPTE(0, va, pmd_val(*pmd));
 	return err;
 }
+EXPORT_SYMBOL(wrhv_map_page);
 
 void __iomem *
 wrhv___ioremap(phys_addr_t addr, unsigned long size, unsigned long flags)
@@ -1309,3 +1329,19 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 	return irq;
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
+
+#if 0 // def CONFIG_WRHV_MILS
+EXPORT_SYMBOL(vbi_vcore_irq_lock);
+EXPORT_SYMBOL(vbi_vcore_irq_unlock);
+EXPORT_SYMBOL(vbi_int_controller_done);
+
+EXPORT_SYMBOL(vdk_port_send);
+EXPORT_SYMBOL(vdk_port_get_recv_buf);
+EXPORT_SYMBOL(vdk_port_buf_release);
+EXPORT_SYMBOL(vdk_schedule_name_to_id);
+EXPORT_SYMBOL(vdk_schedule_set);
+EXPORT_SYMBOL(vdk_sec_audit_event_inject);
+EXPORT_SYMBOL(vdk_sec_audit_event_collect);
+EXPORT_SYMBOL(vdk_safe_crit_event_inject);
+EXPORT_SYMBOL(vdk_safe_crit_event_collect);
+#endif
diff --git a/arch/powerpc/platforms/85xx/wrhv_sbc8548.c b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
index f91a3fa..250cab1 100644
--- a/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
+++ b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
@@ -148,13 +148,17 @@ static int __init sbc8548_probe(void)
         return of_flat_dt_is_compatible(root, "SBC8548");
 }
 
+#ifdef CONFIG_WRHV_MILS
+extern unsigned int vdk_int_controller_get_irq(void);
+#endif
+
 define_machine(sbc8548) {
 	.name		= "WRHV_SBC8548",
 	.probe		= sbc8548_probe,
 	.setup_arch	= sbc8548_setup_arch,
 #ifdef CONFIG_WRHV_MILS
-	.init_IRQ	= mils_pic_init,
-	.get_irq	= mils_vioapic_get_irq,
+	.init_IRQ	= wrhv_init_irq,
+	.get_irq	= vdk_int_controller_get_irq,
 #else
 	.init_IRQ	= sbc8548_pic_init,
 	.get_irq	= wrhv_vioapic_get_irq,
-- 
1.7.0

