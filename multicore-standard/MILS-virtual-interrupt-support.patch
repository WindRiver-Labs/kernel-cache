From 12fbc6c8adf63216d280f22d5f50a94cfaae416a Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Mon, 22 Mar 2010 14:44:22 -0400
Subject: [PATCH] MILS: virtual interrupt support.

Signed-off-by: Keith Backensto <keith.backensto@windriver.com>
---
 arch/powerpc/platforms/85xx/wrhv_sbc8548.c |    4 +-
 include/vbi/interrupt.h                    |   27 +++-
 kernel/vbi/Makefile                        |    6 +-
 kernel/vbi/vdk_interrupt.c                 |  254 ++++++++++++++++++++++++++++
 4 files changed, 279 insertions(+), 12 deletions(-)
 create mode 100644 kernel/vbi/vdk_interrupt.c

diff --git a/arch/powerpc/platforms/85xx/wrhv_sbc8548.c b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
index f91a3fa..b09609d 100644
--- a/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
+++ b/arch/powerpc/platforms/85xx/wrhv_sbc8548.c
@@ -153,8 +153,8 @@ define_machine(sbc8548) {
 	.probe		= sbc8548_probe,
 	.setup_arch	= sbc8548_setup_arch,
 #ifdef CONFIG_WRHV_MILS
-	.init_IRQ	= mils_pic_init,
-	.get_irq	= mils_vioapic_get_irq,
+	.init_IRQ	= wrhv_init_irq,
+	.get_irq	= vdk_int_controller_get_irq,
 #else
 	.init_IRQ	= sbc8548_pic_init,
 	.get_irq	= wrhv_vioapic_get_irq,
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
index bbaa835..d255db1 100644
--- a/include/vbi/interrupt.h
+++ b/include/vbi/interrupt.h
@@ -27,15 +27,28 @@ interrupts configuration data.
 #ifndef	_ASMLANGUAGE
 
 #ifdef CONFIG_WRHV_MILS
-#include <vbi/errors.h>
-static inline uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
-{
-	return VBI_INVALID_IRQ;
-}
-#else
-extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+#include <linux/interrupt.h>
+
+/* Flags for use with vdkIntControllerVectorFind */
+#define VDK_INT_CONTROLLER_FIND_INPUT_INT  1
+#define VDK_INT_CONTROLLER_FIND_OUTPUT_INT 0
+
+#define VDK_SCHED_START_INT_NAME "vbScheduleStartInt"
+
+extern void vdkIntControllerInit(void);
+extern irqreturn_t vdkIntControllerHandle(int irq, void *dev_id);
+extern void vdkIntControllerConnect(int vector,
+                                     void (* handler)(void *, void *),
+                                     void *param);
+extern void vdkIntControllerDisconnect(int vector);
+extern void vdkIntControllerFindVector(char *intName, int inputInterrupt,
+                                        int *vector);
+extern unsigned int vdk_int_controller_get_irq(void);
+
 #endif /* CONFIG_WRHV_MILS */
 
+extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+
 #endif /* _ASMLANGUAGE */
 
 #endif  /* _VBI_INTERRUPT_H */
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index b3ad2af..595044e 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -2,10 +2,10 @@
 # Makefile for the vbi goodies.
 #
 
-obj-y := wrhv.o paddr.o lib.o shmem.o show.o version.o
+obj-y := wrhv.o paddr.o lib.o shmem.o show.o version.o interrupt.o
 ifeq ($(CONFIG_WRHV_MILS),y)
-# No MILS specific files needed
+obj-y += vdk_interrupt.o
 else
-obj-y += io_apic.o interrupt.o idle.o msg.o ns.o
+obj-y += io_apic.o idle.o msg.o ns.o
 endif
 
diff --git a/kernel/vbi/vdk_interrupt.c b/kernel/vbi/vdk_interrupt.c
new file mode 100644
index 0000000..75f2a91
--- /dev/null
+++ b/kernel/vbi/vdk_interrupt.c
@@ -0,0 +1,254 @@
+/*
+ * vdk_interrupt.c - virtual interrupt controller device 
+ *
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+/*
+ * This file contains the code for accessing and controlling the 
+ * virtual interrupt controller as presented to a virtual board.
+ *
+ * This particular version is only used by MILS.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+
+#include <vbi/syscall.h>
+#include <vbi/vdk_interface.h>
+#include <vbi/interrupt.h>
+
+#ifdef DEBUG
+#define dprintk(args...)	printk(KERN_DEBUG, ## args)
+#else
+#define dprintk(args...)	do ; while (0)
+#endif
+
+#define VDK_BSPIOCTL_ENABLE_INT  1      /* Enable a device interrupt */
+#define VDK_BSPIOCTL_DISABLE_INT 2      /* Disable a device interrupt */
+#define VDK_BSPIOCTL_RESET       3      /* Reset a device */
+#define VDK_BSPIOCTL_INT_CONNECT 4      /* Connect to the hardware int */
+
+/* Type for storing interrupt handlers provided by the application */
+struct vdkIntControllerHandler
+{
+	void (*handler)(void *, void *);/* The handler to call for the IRQ */
+	void *param;			/* The parameter to be passed first */
+};
+
+/* Storage for interrupt handlers */
+struct vdkIntControllerHandler vdkIntControllerHandlers[VB_MAX_INTERRUPTS];
+
+#ifdef CONFIG_X86
+static struct irqaction wrhv_ext_irq = {
+	.handler = vdkIntControllerHandle,
+	.flags = IRQF_DISABLED | IRQF_NOBALANCING,
+	.mask = CPU_MASK_NONE,
+	.name = "mils",
+};
+#endif
+
+/*
+ *
+ * vdkIntControllerInit - initialize the virtual interrupter device handler  
+ *
+ * This function should be called before using the virtual interrupt functions.
+ *
+ *
+ */
+void vdkIntControllerInit(void)
+{
+	int i;
+
+	for (i = 0; i < VB_MAX_INTERRUPTS; i++) {
+		vdkIntControllerHandlers[i].handler = NULL;
+		vdkIntControllerHandlers[i].param = NULL;
+	}
+
+#ifdef CONFIG_X86
+	setup_irq(VDK_EXT_INT_VEC - VBI_IN_EXT_IRQ_BASE, &wrhv_ext_irq);
+#endif
+}
+
+
+/*
+ *
+ * vdkIntControllerHandle - the virtual interrupter device handler  
+ *
+ * This function should be installed by the OS as the handler for 
+ * external interrupts
+ *
+ * This handler demuxes the external interrupt, (the 32 interrupt sources)
+ * and calls a handler passing it the configured parameter, and the address
+ * of the interrupt information for that level. (VB_INTERRUPT_LEVEL)
+ *
+ * EXAMPLES:
+ * 
+ *     /@ Install virtual interrupt controller on PowerPc interrupt @/
+ *     vdkExcHandlerInstall (0x500, vdkIntControllerHandle);
+ *
+ */
+irqreturn_t vdkIntControllerHandle(int irq, void *dev_id)
+{
+	volatile struct vbInterruptController *intCntrl = wr_status->vbInterruptController;
+	int level;
+	int vector;
+	int pending;
+
+	level = wr_config->vb_control->irq_disable;
+	wr_config->vb_control->irq_disable = -1;
+	pending = intCntrl->intPending;
+	dprintk("VDKINT: board %s pending 0x%x\n", wr_config->boardName, pending);
+	do {
+		while (pending) {
+			dprintk("pending %d\n", pending);
+			vector = 32 - ffs(pending);
+	        	dprintk("got int %d\n", vector);
+			if (vdkIntControllerHandlers[vector].handler) {
+				(*vdkIntControllerHandlers[vector].handler)(
+					vdkIntControllerHandlers[vector].param,
+					(void *)&intCntrl->intLevel[vector]);
+			}
+			pending &= ~(1 << (31 - vector));
+		}
+
+		/* Finished processing ALL interrupts, refresh int controller */
+		vbi_int_controller_done(0);
+
+		pending = intCntrl->intPending;
+		dprintk("new pending 0x%x\n", pending);
+
+	} while (pending);
+
+	dprintk("int done\n");
+
+	wr_config->vb_control->irq_disable = level;
+
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(vdkIntControllerHandle);
+
+
+/*
+ * vdkIntControllerConnect
+ *    - connect to a specific vector in the virtual controller
+ *
+ * This function installs a 'C' interrupt handler to be called when one of
+ * the 32 interrupts in the virtual interrupt controller is asserted.  Vector
+ * 0 is the highest priority.  The handler is called with the provided parameter
+ * and with the address of the interrupt vectors controllers vector information.
+ *
+ * EXAMPLES:
+ *
+ *    extern void myHandler (void * myParam, VB_INTERRUPT_LEVEL * pLevelInfo);
+ *    ...
+ *    vdkIntControllerConnect (2, myHandler);
+ *
+ */
+void vdkIntControllerConnect(int vector, void (*handler)(void *, void *),
+	void *param)
+{
+
+	if ((unsigned int)vector < VB_MAX_INTERRUPTS) {
+		vbi_vcore_irq_lock();
+		vdkIntControllerHandlers[vector].handler = handler;
+		vdkIntControllerHandlers[vector].param = param;
+		vbi_vcore_irq_unlock();
+	}
+}
+EXPORT_SYMBOL(vdkIntControllerConnect);
+
+
+/*
+ * vdkIntControllerDisconnect
+ *    - disconnect from a specific vector in the virtual controller
+ *
+ */
+void vdkIntControllerDisconnect(int vector)
+{
+
+	if ((unsigned int)vector < VB_MAX_INTERRUPTS) {
+		vbi_vcore_irq_lock();
+		vdkIntControllerHandlers[vector].handler = NULL;
+		vdkIntControllerHandlers[vector].param = NULL;
+		vbi_vcore_irq_unlock();
+	}
+}
+EXPORT_SYMBOL(vdkIntControllerDisconnect);
+
+
+/*
+ *
+ * vdkIntControllerFindVector - determine the interrupt vector for a specified
+ *                              interrupt
+ *
+ * This function finds the interrupt vector number of a named interrupt from
+ * the virtual board configuration information.
+ * 
+ * The type of vector is either input or output.  Defines are provided
+ * in vbi/interrupt.h to manage this.
+ *
+ * EXAMPLES:
+ *
+ *    vdkIntControllerFindVector ("fred", VDK_INT_CONTROLLER_FIND_INPUT_INT,
+ *                                &fredIntVector);
+ */
+void vdkIntControllerFindVector(char *irq_name, int inputInterrupt, int *vector)
+{
+	struct vb_int_info *info = wr_config->interruptConfiguration;
+	int num  = wr_config->num_ints;
+	int i;
+
+	*vector = -1;
+	for (i = 0; i < num; i++, info++) {
+		if (inputInterrupt) {
+			if (info->irq_dir != VB_INPUT_INT)
+				continue;
+		} else {
+			if (info->irq_dir == VB_INPUT_INT)
+				continue;
+		}
+		if (!strncmp(irq_name, info->irq_name, VB_MAX_WRHV_NAME_LENGTH)) {
+	        	*vector = info->irq_num;
+	        	return;
+	        }
+	}
+
+}
+EXPORT_SYMBOL(vdkIntControllerFindVector);
+
+unsigned int vdk_int_controller_get_irq(void)
+{
+	    unsigned int map, irq;
+	    volatile struct vbInterruptController *int_ctrl;
+
+	    int_ctrl = wr_status->vbInterruptController;
+retry:  
+	    map = int_ctrl->intPending;
+
+	    if (!map) {
+	            irq = NO_IRQ_IGNORE;
+	            vbi_int_controller_done(0);
+	            if (int_ctrl->intPending)
+	                    goto retry;
+	    } else {
+	            irq = 32 - ffs(map);
+	            map &= ~(1 << (31 - irq));
+	            int_ctrl->intPending = map;
+	    }
+	    return irq;
+}
-- 
1.7.0

