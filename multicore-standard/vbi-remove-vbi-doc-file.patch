From b3e7bb834cc5213f75c2dd5694a230dfe8575c0e Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 22 Oct 2009 14:10:27 -0400
Subject: [PATCH 3/8] vbi: remove vbi doc file

These files were originally presented as C files but there isn't
any code in it that really is compiled.  We don't want to maintain
the ABI doc within the kernel, esp. if we are cleaning up the
function call names and stuff which would make this information
out of date.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/vbi/ppc_doc.txt |  682 -----------------------------------
 kernel/vbi/vmmu_doc.txt             |  245 -------------
 2 files changed, 0 insertions(+), 927 deletions(-)
 delete mode 100644 arch/powerpc/kernel/vbi/ppc_doc.txt
 delete mode 100644 kernel/vbi/vmmu_doc.txt

diff --git a/arch/powerpc/kernel/vbi/ppc_doc.txt b/arch/powerpc/kernel/vbi/ppc_doc.txt
deleted file mode 100644
index dda0448..0000000
--- a/arch/powerpc/kernel/vbi/ppc_doc.txt
+++ /dev/null
@@ -1,682 +0,0 @@
-/*
- * ppc_doc.txt - Virtual Board Interface APIs supplement for PPC
- *
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- * See the GNU General Public License for more details.
- *
- */
-
-/*
-DESCRIPTION
-The module contains the VBI PowerPc architecture supplement. The APIs described
-below are either available only for PPC platforms or their behaviour is architecture
-dependant.
-
-\sh HYPERCALLS
-This file implements the APIs to make hypercalls to perform operations that require
-hypervisor assistant. A hypercall is based on system call trap that jumps to
-hypervisor exception handler. Some operations that are time critical are implemented
-using a mechanism referred as "fast hypercall". A fast hypercall is identical to a
-regular hypercall except that the system call handler is hand crafted to avoid the
-need of an exception stack.  In some instances they a hypercall may not even return
-(eg. context loading). 
-
-All hypercalls preserve the following registers:
-\ms 
-\m -
-	SRR0 (PC)
-\m -
-	CR (condition register)
-\m -
-	SRR1 (MSR)
-\m -
-	sp (stack pointer)
-\m -
-	lr (link register)
-\m -
-	r2 (sdata2 pointer)
-\m -
-	r13 (sdata pointer)
-\m -
-	r14-r32 (global registers)
-\me
-
-
-\sh FAST HYPERCALLS
-Following is the list of APIs that utilize fast hypercalls mechanism. 
-\ms
-\m - 
-void VBI_CTX_LOAD(void):
-This is a assembly MACRO that may be used by a guest OS to switch to a new context.
-The guest sets the register sets to be loaded in the VB control structures and calls
-this MACRO to make the hypercall.
-\m -
-vbiStatus_t vbiICacheFlush():
-This routine flushes the instruction cache for the calling core.
-\m -
-This routine flushes the data cache for the calling core.
-vbiStatus_t vbiDCacheFlush():
-\m -
-vbiStatus_t vbiIntVCoreUnlock():
-This routine unlocks interrupts for the calling core. For optimization purpose a 
-hypercall is made only if interrupts were queue while locked.
-\me
-
-\sh ACCESSING WRHV BSP DEVICES
-
-Devices that are shared between the different guests are managed by WRHV
-hyperkernel. These devices manager accepts request submitted using vbiSend().
-The guest finds the server handle by using vbiNsLookup (), initializes the
-predefined input/output message buffers then invokes vbiSend() to transmit the
-request. The input message buffer type is VBI_BSP_MSG. The reply message buffer
-type is VBI_BSP_MSG_REPLY. The request type in the input message is based on
-the nature of the request which can be one of the following types:
-\ms 
-\m - VBI_MDIO_READ for reading an MDIO register
-\m - VBI_MDIO_WRITE for modifying an MDIO register
-\m - VBI_BSP_CLK_FREQ  for reading the BSP clok frequency
-\me
-
-\cs
-\sh BSP MESSAGES BUFFER FORMAT
-
-/@ Input message format @/
-
-typedef struct vbiBspMsg
-    {
-    MSG_HEADER hdr;                     /@ message header @/
-    uint32_t   request;                 /@ request type @/
-
-    union
-        {
-        struct
-            {
-            uint32_t bus;
-            uint32_t phyAddr;
-            uint32_t regNum;
-            uint32_t page;
-            } mdioRead;
-        struct
-            {
-            uint32_t bus;
-            uint32_t phyAddr;
-            uint32_t regNum;
-            uint32_t page;
-            uint32_t dataVal;
-            } mdioWrite;
-        } arg;
-
-    } VBI_BSP_MSG;
-
-/@ Output message format @/
-
-typedef struct
-    {
-    MSG_HEADER hdr;                     /@ message header 	    @/
-    uint32_t   status;                  /@ request completion status @/
-    uint32_t   dataVal;
-    } VBI_BSP_MSG_REPLY;
-
-/@Generic message header @/
-
-typedef struct msg_header {
-    uint32_t msgId;     /@ message type identification @/
-    uint32_t msgArg;    /@ argument associated with message type @/
-} MSG_HEADER;
-
-\ce
-
-\sh Example
-\cs
-        VBI_BSP_MSG             inMsg; /@ input message buffer  @/
-        VBI_BSP_MSG_REPLY       reply; /@ output message buffer @/
-        VBI_NS_HANDLE		serviceHandle;
-        vbiStatus_t		rc;
-
-	/@ 
-	 @ What is the request type ?
-         @ VBI_MDIO_READ, VBI_MDIO_READ or VBI_BSP_CLK_FREQ
-	 @    
-	 @/
-
-        mdioMsg.request = <request type>; 
-	
-	/@ 
-         @ The input message structure is populated according to the type
-	 @ request specified. For example for writting to a phy the user
-	 @ must specify the bus, phy addr, reg number, and the input 
-	 @ value. See the union used for the inMsg type. 
-         @ The example is for writting a value to a phy register.
-         @/
-
-	/@ bus number    @/
-        
-	*((uint32_t*)&inMsg.arg.mdioRead.bus) = <phyBusNumber>;   
-	
-	/@ the phy address @/
-
-        *((uint32_t*)&inMsg.arg.mdioRead.phyAddr) = <phyaddr>;  
-	
-	/@ the register number @/
-
-        *((uint32_t*)&inMsg.arg.mdioRead.regNum) = <regNum>;	
-
-	/@ Find the destination server to send the message to @/
-
-        rc = vbiNsLookup ("bspServer", 0, &serviceHandle);
-
-        if (rc != OK)
-            kprintf ("vbiSend returned error\n");
-
-        rc = vbiSend (serviceHandle, &inMsg,
-                sizeof(inMsg), &reply, sizeof(reply), NULL, NULL);
-
-        kprintf ("replied value 0x%d\n", reply.dataVal);
-\ce
-\APPEND ../../../vbi/include/ppc/vbiPpcArch.h
-*/
-
-/*******************************************************************************
-*
-* VBI_CTX_LOAD - Load a guest context
-*
-* This routine is implemented as an assembly MACRO since it's callers can't
-* reference C functions. This MACRO  makes a hypercall to load a context for a guest
-* OS. The guest OS running on the core is expected to store a set of registers that
-* represent the new context to load in the it's control structure then call 
-* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
-* loaded from the control structure:
-*
-*
-*
-* VB_CONTROL_SRR0	     ------->  SRR0
-*
-* VB_CONTROL_SRR1	     -------> SRR1 
-*
-* VB_CONTROL_CR		     -------> CR
-*
-* VB_CONTROL_R0		     -------> R0
-*
-* VB_CONTROL_EMSR	     -------> MSR 
-*
-* VB_CONTROL_DBCR0	     -------> DBCR0 
-*
-* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
-* If interrupts are being reenabled then we ensure that any pending interrupts are
-* delivered before the new context is actived.
-*
-* Note that registers that are not saved by Hypervisor must be loaded by the guest
-* OS.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* void  VBI_CTX_LOAD () 
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
-*           VBI_INT_VCORE_STATE_GET()
-*/
-
-
-/*******************************************************************************
-*
-* vbiIcacheFlush - flush the instruction cache
-*
-* This routine makes a hypercall to flush the instruction cache of the calling
-* core for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiIcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the instruction cache to flush @/
-*	    size_t len  /@ length of memory to flush @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiDcacheFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiDcacheFlush - flush the specified Data cache
-*
-* This routine makes a hypercall to flush the data cache of the calling core
-* for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiDcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the data cache to flush @/
-*	    size_t len  /@ length of memory to flush                   @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiTlbFlush(), vbiIcacheFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
-*
-* This routine makes a hypercall to flush the data cache then invalidates the
-* instruction cache of the calling core for the specified address range.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiCacheTextUpdate 
-*	    (
-*	    void * addr /@ starting address to perform textUpdate operation @/
-*	    size_t len  /@ length of memory in bytes			    @/
-*	    ) 
-*
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*vbiDcacheFlush(), vbiIcacheFlush()
-*/
-
-/******************************************************************************
-*
-* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
-*
-* This MACRO disables the currently running core interrupts and returns the
-* previous interrupts state. The interrupt status field in wrhvVbControl
-* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
-* interrupts state is loaded to the register passed in as the first argument to
-* this MACRO. 
-* A hypercall is not needed to perform this operation. 
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
-*	{
-*	load -1 to reg1
-*	load wrhvVbControl address to reg2
-*       read the previous value and store in reg0
-*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
-*	}
-*
-*
-* RETURNS: TRUE is interrupts were locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
-*
-* This MACRO is implemented in assembly to enable a core's interrupts. It
-* enables the interrupts by clearing to zero the value in the core's control
-* structure and and makes a fast hypercall if need be. A hypercall is made only
-* if found that interrupts are pending. The pending interrupts are checked by
-* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
-* positive integer greater than zero indicates that interrupts are pending
-* which causes this macro to make a hypercall in order to drain the pending
-* interrupts. This MACRO expects two general purpose registers. The first 
-* register is used to load the value to store and the second is used for
-* holding the destination address of the control or status structure.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
-*	{
-*	load "0" to reg1
-*	load address of wrhvVbControl in reg0 
-*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
-*
-* checkStatus:
-*	load address of wrhvVbStatus in reg0
-*       load VB_STATUS_INT_PENDING(reg0) in reg1
-*       check if reg1 is equal to zero
-*       if true return
-*	otherwise send an hypercall 
-*       go to checkStatus
-*	}
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_STATE_GET - Get interrupts state
-*
-* This MACRO is implemented in assembly to read the interrupt state of the
-* currently running core. It relies on a passed in general purpose register
-* to store the current state of interrupts. The status is -1 if locked
-* otherwise 0.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_STATE_GET (reg0)
-*	{
-*       Load the interrupt status from wrhvVbControl to reg0
-*	}
-*
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreLock - lock interrupts
-*
-* This routine locks interrupts for the calling core. This is a C wrapper 
-* function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
-* and returns the previous state of interrupts.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntState_t vbiIntVCoreLock (void)
-*
-*
-*
-* RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
-*
-* This routine enables interrupts and makes a fast hypercall if pending
-* interrupts are detected for the calling core. This is a C wrapper function for
-* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* void vbiIntVCoreUnlock (void)
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreStateGet - Get interrupts state for running core
-*
-* This routine returns the interrupts state for the calling core. This is C 
-* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
-* returns TRUE if interrupts are locked otherwise FALSE.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntStatus_t vbiIntVCoreStateGet (void)
-*
-*
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
-*
-* This routine changes the exceptions vector table base address for the active
-* virtual core. By default the base address of the exception table is at address
-* 0x0.
-* If the guest OS programmer wishes to move this address then this function must
-* be called to inform hypervisor. This function must be called with interrupts
-* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcBaseSet 
-*	    (
-*	    void * excTblBase /@ New exception table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVbRegisterRead - Read a remote core's registers
-*
-* This routine makes a hypercall to read a remote core's registers. The register
-* control structure contains information about the registers to read and the
-* destination buffers to store them.
-* 
-* It is possible to read registers while the target VB's core is still running
-* it doesnt have to be suspended before reading the registers.
-* 
-* SYNOPSIS
-*
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiVbRegisterRead 
-*	(
-*	VB_HREG_SET	*regCtl,	    /@ Registers read - OUT	    @/
-*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
-*	vbiCore_t   core		    /@ core within the target VB    @/
-*	)
-*
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VB_HREG_SET;
-* 
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
-/*******************************************************************************
-*
-* vbiVbRegisterWrite - write to a remote core's registers
-*
-* This routine makes a hypercall to write to a remote core's registers. The
-* register control structure contains the set of registers to write. 
-* The user must ensure to read first the destination core's registers using
-* vbiVbRegisterRead() then write back the modified set of registers in the 
-* registers control structure.
-* 
-* Target VB's core has to be suspended before writing the registers. If it
-* is still running, vbiVbRegisterWrite call will fail.
-* 
-*
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VB_HREG_SET;
-* 
-* 
-* VBI PPC Architecture Supplements
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVbRegisterWrite
-*	(
-*	VB_HREG_SET		*regCtl,	/@ registers to write - IN	 @/
-*	vbiVb_t			targetBoard,	/@ The target board		 @/
-*	vbiCore_t		core		/@ The target core within the VB @/
-*	)
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
-/*******************************************************************************
-*
-* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
-*
-* This routine changes the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* If the guest OS programmer wishes to move these address then this function 
-* must be called to inform hypervisor. This function must be called with 
-* interrupts disabled to prevent hypervisor to deliver interrupts to an 
-* incorrect exception offset. The table is not validated by the hypervisor so
-* it must be complete and functional otherwize the VB will not behave as 
-* expected.
-* For SMP systems it is recommended this API be called for each core as it is
-* started up and before it's added to the scheduler for the guest OS.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsSet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiExcOffsetsGet
-*/
-
-/*******************************************************************************
-*
-* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
-*
-* This routine gets the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* 
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsGet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-*vbiExcOffsetsSet
-*/
diff --git a/kernel/vbi/vmmu_doc.txt b/kernel/vbi/vmmu_doc.txt
deleted file mode 100644
index d9460ce..0000000
--- a/kernel/vbi/vmmu_doc.txt
+++ /dev/null
@@ -1,245 +0,0 @@
-/* vbiVmmuDoc.c - Virtual Board Interface VMMU APIs */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind RIver License agreement.
- */
-
-/*
-modification history
---------------------
-01b,03jul09,mmi  fix vbiVmmuEnable/Disable
-01a,31may09,mmi written
-*/
-
-/*
-DESCRIPTION
-The module contains the VBI VMMU supplement.
-The VMMU configuration structure is an essential data type to understand this
-module. It is the descriptor for an VMMU context with the following info:
-
-\ms
-\m -
- The VMMU page table base address 
-\m - 
- The VMMU pages
-\m -
- The page size granularity 
-\me 
-
- VMMU_CONFIG definition:
-
- typedef struct vmmuConfig
-    {
-    VMMU_LEVEL_1_DESC *addr;
-    size_t         pageSize;
-    uint32_t       reserved;
-    uint32_t       vmmu_num;
-    } VMMU_CONFIG;
-
- The vmmu virtual address space is restricted to 32 bits and is decoded using
- a level-1/level-2 page table.  The virtual address is decoded as follows:
-\cs
-
-
-
-                          32-bit Virtual Address
-        +---------------------------------------------------------+
-        |      L1 offset       | L2 offset |    Page offset       |
-        +---------------------------------------------------------+
-                11 bits           9 bits           12 bits
-                  |                 |
-                  |                 |
-    +-------------+                 |
-    |                               |
-    |                               |
-    |           L1 Table            |            L2 Table
-    |    2047 +----------+          |      511 +----------+
-    |         |          |          |          |          |
-    |         |          |          |          |          |
-    |         |          |          |          |----------|
-    |         |          |          |   +----->|    PTE   | 8 byte PTE
-    |         |          |          |   |      |----------|
-    |         |          |          |   |      |          |
-    |         |----------| 20 bits  |   |      |          |
-    +-------->|  L2 ptr  |----------+---+      |          |
-              |----------|                     |          |
-              |          |                     |          |
-              |          |                     |          |
-            0 +----------+                   0 +----------+
-               2 page (8KB)                    1 page (4KB)
-             2048 L2 pointers                 512 PTE entries
-
- Each page table entry is 8 bytes (2 words) and uses the following format:
-
- word 0 (32-bits):
-          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
-                                          6 7 8 9 0 1 2 3
-         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
-         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
-         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-
-                V          - valid bit
-                Hypervisor - reserved for use by hypervisor
-                U0-U7      - user defined attributes
-                ERPN       - extended real page number bits
-                ATTR       - page attributes
-
- word 1 (32-bits):
-
-          0                                19 20      23 2 2 2 2 2 2 3 3
-                                                         4 5 6 7 8 9 0 1
-         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
-         |                                   |          | | |X|X|W|W|R|R|
-         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-
-                RPN        - real page number
-                R          - page referenced bit
-                C          - page changed bit
-                SX,SW,SR   - supervisor mode protection bits
-                UX,UW,UR   - user mode protection bits
-\ce
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-*/
-
-
-/*******************************************************************************
-*
-* vbiVmmuConfig - configure the hypervisor virtual MMU
-*
-* This makes a hypercall in order to register a context's  virtual MMU within
-* the hypervisor using a fast hypercall. To enable the newly configured VMMU the
-* user must vbiVmmuEnable(). This funtion takes a pointer to a VMMU
-* configuration structure. 
-* Whenever the VMMU state is changed, the vbiVmmuConfig() operation will flush
-* the TLB entries to ensure consistency between the processor and the page tables.
-* 
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVmmuConfig (VMMU_CONFIG * pVmmuConfig) /@ config pointer @/
-*
-*
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuEnable(), vbiVmmuDisable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuEnable - Enable virtual MMU
-*
-* This routines enables the context's virtual MMU within the hypervisor using a
-* fast hypercall. Before calling this routine one must ensure to configure the
-* VMMU page table, map all necessary memory regions, initialize the VMMU
-* configuration and register it by calling vbiVmmuConfig(). Once the VMMU
-* is enabled any memory access is translated via the VMMU page tables. The
-* argument passed to this routine is the VMMU index. Currently hypervisor
-* supports only one VMMU therefore the index is always zero.
-*
-* Special care must taken to ensure that the executed code and data regions
-* accessed are mapped. It is suggested that any data regions shared with 
-* Hypervisor is idendity mapped (flat mapping or 1-1 translation).
-* 
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVmmuEnable (vbiVmmuIndex_t vmmuIndex) /@ vmmu Handle @/
-*
-*
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuDisable - Disable VMMU for running core
-*
-* This routines disables the core's VMMU within the hypervisor using a 
-* hypercall. The argument passed to this routine is the VMMU index. Currently
-* hypervisor supports only one VMMU therefore the index is always zero. 
-*
-* This is equivalent to calling vbiVmmuConfig(vbiVmmuIndex_t, NULL). 
-*
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVmmuDisable (VBI_VMMU_HANDLE vmmuHandle) /@ vmmu handle @/
-*
-*
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuTlbFlush - Flush TLB entries for a range of address
-*
-* This routine flushes the TLB entries for the specified address range from 
-* the virtual MMU.
-* The vbVmmuTlbFlush function is used to ensure that any VMMU translations for
-* the specified address range are cleared from the processor.s TLB cache.
-* All page translations starting at address for a length of length bytes in the
-* specified vmmu context will be cleared from the TLB cache
-*
-* SYNOPSIS
-*
-* 
-*
-* vbiStatus_t vbiVmmuTlbFlush
-*		( 
-*		VMMU_CONFIG *config,	/@ The VMMU configuration to use @/
-*		void	    *addr,	/@ Starting address              @/
-*		size_t	    len)	/@ length                        @/
-*		)
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuEnable()
-*/
-- 
1.6.5.rc3

