From cb71f87967dcb8e1872d57985a1030d259fa12d9 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 14 Oct 2009 19:09:38 -0400
Subject: [PATCH 02/27] vbi: relocate core kernel files to their own home

Put all the vbi files in their own dir and get rid of
the annoying vbi prefix, along with the cAmElCaSe.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 kernel/Makefile         |    4 +-
 kernel/vbi/Makefile     |    6 +
 kernel/vbi/idle.c       |   72 ++++
 kernel/vbi/interrupt.c  |  102 ++++++
 kernel/vbi/io_apic.c    |  620 +++++++++++++++++++++++++++++++++
 kernel/vbi/lib.c        |  872 +++++++++++++++++++++++++++++++++++++++++++++++
 kernel/vbi/msg.c        |  153 +++++++++
 kernel/vbi/ns.c         |  173 ++++++++++
 kernel/vbi/paddr.c      |  119 +++++++
 kernel/vbi/shmem.c      |  220 ++++++++++++
 kernel/vbi/show.c       |  327 ++++++++++++++++++
 kernel/vbi/version.c    |   56 +++
 kernel/vbi/vmmu_doc.txt |  245 +++++++++++++
 kernel/vbi/wrhv.c       |  137 ++++++++
 kernel/vbiIdle.c        |   72 ----
 kernel/vbiInterrupt.c   |  102 ------
 kernel/vbiLib.c         |  872 -----------------------------------------------
 kernel/vbiMsg.c         |  153 ---------
 kernel/vbiNs.c          |  173 ----------
 kernel/vbiPaddr.c       |  119 -------
 kernel/vbiShmem.c       |  220 ------------
 kernel/vbiShow.c        |  327 ------------------
 kernel/vbiVersion.c     |   56 ---
 kernel/vbiVioApic.c     |  620 ---------------------------------
 kernel/vbiVmmuDoc.c     |  245 -------------
 kernel/wrhv.c           |  137 --------
 26 files changed, 3103 insertions(+), 3099 deletions(-)
 create mode 100644 kernel/vbi/Makefile
 create mode 100644 kernel/vbi/idle.c
 create mode 100644 kernel/vbi/interrupt.c
 create mode 100644 kernel/vbi/io_apic.c
 create mode 100644 kernel/vbi/lib.c
 create mode 100644 kernel/vbi/msg.c
 create mode 100644 kernel/vbi/ns.c
 create mode 100644 kernel/vbi/paddr.c
 create mode 100644 kernel/vbi/shmem.c
 create mode 100644 kernel/vbi/show.c
 create mode 100644 kernel/vbi/version.c
 create mode 100644 kernel/vbi/vmmu_doc.txt
 create mode 100644 kernel/vbi/wrhv.c
 delete mode 100644 kernel/vbiIdle.c
 delete mode 100644 kernel/vbiInterrupt.c
 delete mode 100644 kernel/vbiLib.c
 delete mode 100644 kernel/vbiMsg.c
 delete mode 100644 kernel/vbiNs.c
 delete mode 100644 kernel/vbiPaddr.c
 delete mode 100644 kernel/vbiShmem.c
 delete mode 100644 kernel/vbiShow.c
 delete mode 100644 kernel/vbiVersion.c
 delete mode 100644 kernel/vbiVioApic.c
 delete mode 100644 kernel/vbiVmmuDoc.c
 delete mode 100644 kernel/wrhv.c

diff --git a/kernel/Makefile b/kernel/Makefile
index fd0a1f2..c723c24 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -35,9 +35,7 @@ obj-$(CONFIG_FUTEX) += futex.o
 ifeq ($(CONFIG_COMPAT),y)
 obj-$(CONFIG_FUTEX) += futex_compat.o
 endif
-obj-$(CONFIG_WRHV) += vbiShmem.o wrhv.o vbiInterrupt.o vbiPaddr.o vbiIdle.o \
-			vbiVioApic.o vbiLib.o vbiVersion.o vbiMsg.o vbiNs.o \
-			vbiShow.o vbiVmmuDoc.o
+obj-$(CONFIG_WRHV) += vbi/
 obj-$(CONFIG_RT_MUTEXES) += rtmutex.o
 obj-$(CONFIG_DEBUG_RT_MUTEXES) += rtmutex-debug.o
 obj-$(CONFIG_RT_MUTEX_TESTER) += rtmutex-tester.o
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
new file mode 100644
index 0000000..2d0af85
--- /dev/null
+++ b/kernel/vbi/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the vbi goodies.
+#
+
+obj-y     = shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
+	    version.o msg.o ns.o show.o
diff --git a/kernel/vbi/idle.c b/kernel/vbi/idle.c
new file mode 100644
index 0000000..f41f4dd
--- /dev/null
+++ b/kernel/vbi/idle.c
@@ -0,0 +1,72 @@
+/* vbiIdle.c - context idle code */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01h,26aug09,mmi  fix WIND00178026: update copyright
+01g,25may09,mmi  introduce a new type vbiTicks_t
+01f,15may09,mmi  fix apigen errors
+01e,11dec08,mmi  alwasy include vbi.h
+01d,19nov08,mmi  adopt new naming convention vbi...
+01c,02jul08,md   fix parameter ordering
+01b,21nov07,foo  idle parameter
+01a,04jun07,md   written
+*/
+
+/*
+DESCRIPTION
+This module provides an interface to put the currently running virtual board
+into the idle state.
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiIdle - inform the hypervisor scheduler that the virtual board is idle
+*
+* This function informs the hypervisor that the virtual board core's is idle and
+* also provides a timeout at which it needs to be made ready to run again. This
+* routine halts the active core untill the specified timeout expires or and an
+* asynchronous event like a interrupt is delivered to the calling core. An zero
+* timeout means to halt the core indefinetly until an asynchronous event occurs.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiIdle (vbiTicks_t timeout)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void vbiIdle
+    (
+    uint64_t timeStamp /* Time at which to wake up */
+    )
+    {
+    uint32_t tickCount = timeStamp & 0xFFFFFFFF;
+
+    /* use the hypervisor system call to go into the idle state */
+
+    vbiCtxctl (VBI_CTXCTL_IDLE, tickCount, 0);
+    }
diff --git a/kernel/vbi/interrupt.c b/kernel/vbi/interrupt.c
new file mode 100644
index 0000000..24fecd3
--- /dev/null
+++ b/kernel/vbi/interrupt.c
@@ -0,0 +1,102 @@
+/* vbiInterrupt.c - virtual board interrupt configuration utility */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01m,03sep09,mmi  fix depency to vba library for comparing strings
+01l,26aug09,mmi  fix WIND00178026: update copyright
+01k,03jul09,mmi  update description
+01j,19jun09,mmi  revert to previous name for this file
+01i,26feb09,mmi  change vbiIntVecFind definition to return vector
+01h,17dec08,mmi  rename vbiIntCtrlFindVector with vbiIntVecFind
+01g,13dec08,mmi  remove razorVxWorks.h 
+01f,21nov08,mmi  include vbi.h instead of vdk.h
+01e,19nov08,mmi  change API's names to vbiXXX and miscl. cleanup
+01d,10sep08,md   fix vbiIntCtlrConnect parameters
+01c,23nov07,foo  fix includes
+01b,25oct07,foo  update for real hardware interrupt implementation
+01a,09may07,foo  written
+*/
+
+/*
+ * This module contains the code for accessing the the interrupts configuration
+ * of the virtual board.
+ */
+
+/*#define DEBUG 1*/
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#ifdef CONFIG_WRHV
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#include <linux/module.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiIntVecFind - determine the irq for a specified name
+*
+* This function finds the irq number of a named interrupt from  the virtual
+* board configuration information.
+* 
+* The <intDirection> is either input or output. VB_INPUT_INT for input,
+* VB_OUTPUT_INT for output.
+*
+* EXAMPLES:
+* \cs
+*     fredIntVector = vbiIntVecFind ("fred", VB_INPUT_INT);
+* \ce
+*
+* RETURNS: vector number, VBI_INVALID_IRQ if not found
+*
+*/
+
+vbiIrq_t vbiIntVecFind
+    (
+    char *  intName,		/* string name of the interrupt */
+    int32_t  intDirection 	/* interrupt direction */
+    )
+    {
+    VB_CONFIG *   config = VBI_CONFIG_ADDR_GET();
+    VB_INT_INFO * info = config->interruptConfiguration;
+    int32_t       num  = config->numInts;
+    int32_t       i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (intDirection != (int32_t)(info->intDirection))
+            continue;
+
+        if (!_vbiStrncmp ((char *)intName, (char *)info->intName,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+
+            /* Found */
+
+            return (int32_t)info->intNumber;
+            }
+        }
+
+    return (VBI_INVALID_IRQ); /* no match */
+    }
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiIntVecFind);
+#endif /* CONFIG_WRHV */
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
new file mode 100644
index 0000000..7f74919
--- /dev/null
+++ b/kernel/vbi/io_apic.c
@@ -0,0 +1,620 @@
+/* vbiVioapic.c - Virtual IO APIC library */
+
+/*
+ * Copyright (c) 2008-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01o,26aug09,mmi  fix WIND00178023: vioapic unmask routine
+01n,13aug09,dtr  Update vbiVioapicIntAck docs and API.
+01m,18jul09,mmi  remove X86 from unmask
+01l,07jul09,mmi  turn off debugging by default
+01k,02jul09,mmi  update send api
+01j,16jun09,mmi  create vioapic structure
+01i,09jun09,mmi  update macros to access config structure
+01h,29mar09,mmi  set MASK properly
+01g,09apr09,mpk  hypervisor 64 bit changes to support mips cavium-octeon bsp
+01f,19mar09,mes  Fixed return values of VBI functions
+01e,24feb09,mmi  include vbiSyscall.h
+01d,22dec09,mmi  fix send function proto
+01c,13dec08,mmi  define structures locally
+01b,11dec08,mmi  replace razor with wrhvVb
+01a,10dec08,mmi created base on x86 version
+*/
+
+/* 
+DESCRIPTION 
+
+This module implements the Virtual IO APIC library
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#define kprintf printk
+#else
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/* globals */
+
+/* externs */
+
+/* defines */
+
+/* APIC register get/set macros  Accesses are double words using an
+ * indirect addressing scheme.
+ * Redirection table entry bits: lower 32 bit 
+ */
+
+/* IO APIC Register Offset */
+
+#define VIOAPIC_REG_ID		0x00	/* IOAPIC ID */
+#define VIOAPIC_REG_VERS	0x01	/* IOAPIC Version */
+#define VIOAPIC_REG_ARB		0x02	/* IOAPIC Arbitration ID */
+#define VIOAPIC_REG_BOOT	0x03	/* IOAPIC Boot Configuration */
+#define VIOAPIC_REG_REDTBL	0x10	/* Redirection Table (24 * 64bit) */
+/* Redirection table entry size per IO APIC */
+
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	128
+
+#ifndef OK
+#define OK  (0)
+#endif
+
+#if 0
+#define DEBUG
+#endif
+
+#ifdef DEBUG
+#define DEBUGM(fmt, arg...) kprintf(fmt, ##arg)
+#else
+#define DEBUGM(fmt, arg...)
+#endif
+/* IO APIC register get/set macros */
+/* Accesses are double words using an
+ * indirect addressing scheme.
+ */
+
+#define	VIOAPIC_REG_GET(base, offset)		\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))))
+
+#define	VIOAPIC_REG_SET(base, offset, value)	\
+	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))) = \
+	(value))
+
+/* data structures */
+
+/* IO APIC ID register */
+typedef union {
+    struct {
+	uint32_t reserved1:24;	/* reserved bits */
+	uint32_t IOAPIC_id:4;	/* apic id */
+	uint32_t reserved2:4;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_ID;
+
+
+/* IO APIC Version Register */
+
+typedef union {
+    struct {
+	uint32_t version:8;		/* version identifier */
+	uint32_t reserved1:8;		/* reserved bits */
+	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
+					 * number of IRQ pins - 1 */
+	uint32_t reserved2:8;		/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_VERSION;
+
+/* Virtual IO APIC redirection table entry. Split into high/low 32 */
+
+typedef union {
+    struct {
+	uint32_t reserved:24;	/* reserved bits */
+	uint32_t destination:8;	/* destination field */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_HIGH;
+
+typedef union {
+    struct {
+	uint32_t vector:8;	/* vector number */
+	uint32_t deliveryMode:3;/* delivery mode:
+				 * fixed, lowest, SMI, reserved, NMI, 
+				 * INIT, reserved, extInt */
+	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
+	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+	uint32_t polarity:1;	/* polarity: 0=high active */
+	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
+				 * accepts level, 0 after EOI */
+	uint32_t trigger:1;	/* 0=edge, 1=level */
+	uint32_t mask:1;	/* 1=masked */
+	uint32_t reserved:15;	/* reserved bits */
+    } field;
+
+    uint32_t value;
+} VIOAPIC_REDIR_LOW;
+
+typedef struct vioapicEntry
+    {
+    VIOAPIC_REDIR_LOW   vioapicLow;
+    VIOAPIC_REDIR_HIGH  vioapicHigh;
+
+    } VIOAPIC_ENTRY;
+
+typedef struct vioapic
+    {
+    VIOAPIC_ID      id;
+    VIOAPIC_VERSION version;
+    uint32_t        arb;
+    uint32_t        boot;
+    uint32_t        reserved[6];
+    VIOAPIC_ENTRY   entry [128];
+    } VIOAPIC;
+
+/* forward declarations */
+
+/*******************************************************************************
+ *
+ * vbiVioapicAddrGet - Get VIOAPIC base address
+ *
+ * This routine gets the base address of the VIOAPIC specified in the VB
+ * control structure.
+ * 
+ * RETURNS: the base address of the VB VIOAPIC base address
+ *
+ * \NOMANUAL
+ */
+
+void * vbiVioapicAddrGet(void)
+    {
+    return(VBI_VIOAPIC_BASE_GET());
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicVectorSet - Set a vector for the specified irq entry
+*
+* This routine sets a vector for the specified entry in the VIOAPIC redirection
+* table. The previous entry in the table is trashed. Before setting the new
+* vector in the entry the user can obtain the previous entry by calling 
+* vbiVioapicVectorGet(). The first argument passed to this function represent
+* the index to the VIOAPIC redirection table. The second argument is the vector
+* to set in the specified entry. 
+* For Intel architectures when an interrupt is raised the vector determines the
+* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
+*
+* This routine is currently not supported for PPC.  
+*
+* SYNOPSIS
+*\cs
+* 
+*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+vbiStatus_t vbiVioapicVectorSet
+    (
+    vbiIrq_t	irq,	/* descriptor table index */
+    vbiVector_t vector	/* the vector to set in the entry */
+    )
+    {
+    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq	*/
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
+    VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase, 
+		 &(pVioapic->entry[irq].value));
+
+    /* Set the vector at the vioapic entry */
+
+    pVioapic->entry[irq].vioapicLow.field.vector = vector;
+
+    return (OK);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicVectorGet - Get a vector in the specified irq entry
+*
+* This routine gets a vector for the specified entry in the VIOAPIC table in
+* VIOAPIC redirection table. It may be used for saving the previous entry
+* before setting a new vector in the specified entry. This takes as an argument
+* the irq number that corresponds to the redirection table offset. 
+*
+* This routine is currently not supported for PPC 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: vector number or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+vbiVector_t vbiVioapicVectorGet
+    (
+    vbiIrq_t	irq	/* descriptor table index */
+    )
+    {
+    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+    vbiVector_t		vector;
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq	*/
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorGet: base @ 0x%x\n", vioapicBase);
+
+    /* Set the vector at the vioapic entry */
+
+    vector = pVioapic->entry[irq].vioapicLow.field.vector;
+
+    VB_DEBUG_MSG ("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
+
+    return (vector);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
+*
+* This routine enables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC redirection table. This routine makes a hypercall in order to
+* deliver pending interrupts that might be queued while the irq was masked.
+* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+* masked. Then clears the mask bit in the VIOAPIC redirection table for the
+* specified IRQ directed to the calling virtual Core.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntUnmask 
+    (
+    vbiIrq_t irq
+    )
+    {
+    volatile VIOAPIC *   pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* validate the irq number  */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    /* enable interrupt on VB */
+
+    return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
+    
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiVioapicIntUnmask);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiVioapicIntMask - Mask an irq 
+*
+* This routine disables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+* VIOAPIC redirection table is set to 1. After calling this function hypervisor
+* will deliver this IRQ only if this IRQ is enabled by calling
+* vbiVioapicIntUnmask(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntMask
+    (
+    vbiIrq_t irq
+    )
+    {
+    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+
+    /* check for null pointer */
+
+    if (pVioapic == NULL)
+	return (VBI_VIOAPIC_NULL);
+
+    /* check argument */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return ERROR;
+
+    /* set the mask bit */
+
+    pVioapic->entry[irq].vioapicLow.field.mask = 1;
+
+    return (OK);
+
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntAck - Acknowledge an irq 
+*
+* This routine acknowledges the specified IRQ for the running core. Calling 
+* this routine causes Hypervisor to purge any pending interrupt that arrived
+* while the acknowledgement was pending. When a virual board receives an interrupt
+* it must call this function. Otherwise Hypervisor will block subsequent interrupt
+* for the same IRQ. Exceptions are not required to be acknowledged.
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntAck
+    (
+    vbiIrq_t    irq   /* table entry to modify (0-23) */
+    )
+    {
+    /* check argument */
+
+    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
+        return VBI_VIOAPIC_IRQ_OUTBOUND;
+
+    return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicIntSend - Send an interrupt
+*
+* This routine makes a hypercall to trigger an IRQ to one or more virtual board
+* that are connected to the line. The first argument passed to this function
+* specifies the IRQ number. The second argument specifies the filter to apply
+* to the list of virtual  boards connected to the IRQ. The third argument is
+* applicable only when VIOAPIC_SEND_UNICAST filter is specified.
+*
+* In a SMP system a virtual board may have more than one core. If an IRQ is
+* sent to such system hypervisor will deliver the interrupt to the core that
+* was configured to receive the IRQ. The configuration is provided in the board
+* XML configuration file as the example shown below. 
+*
+*\cs
+*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
+*\ce
+*
+* The Vector number is not required to be specified in the XML. If not specified
+* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
+* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
+* 
+* The possible values for the filter (second argument) may be:
+*
+*\ms
+*\m -
+* VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
+*                         IRQ include the sender board.
+*\m -
+* VIOAPIC_SEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
+*                         excluding the sender board
+*\m -
+* VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
+*		          will be delivered only if the destination board is
+*                         connected to this IRQ 
+*			  
+*\m -
+* VIOAPIC_SEND_NONE	- Ignore this call.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntSend 
+*             (
+*             vbiIrq_t irq, 
+*             uint32_t filter,
+*             vbiVb_t target 
+*             )
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
+*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
+*
+* INTERNAL
+* Important!! ignore filter and target arguments for now.
+*/
+
+vbiStatus_t vbiVioapicIntSend
+    (
+    vbiIrq_t    irq,		/* irq number			*/
+    uint32_t	filter,		/* destination filter		*/
+    vbiVb_t	target		/* vb id if filter is unicast	*/
+    )
+    {
+    return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiVioapicIntSend);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiVioapicIntRedirect - Redirect an irq to another core
+*
+* This routine makes a hypercall to redirect an irq from one core to another
+* within the same virtual board. 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+vbiStatus_t vbiVioapicIntRedirect 
+    (
+    vbiIrq_t    irq,		/* irq number			*/
+    vbiCore_t	core		/* vb id if filter is unicast	*/
+    )
+    {
+
+    /* call interrupt redirect operator */
+
+    return (vbiVcoreIntRed_op(irq, core));
+    }
+
+/*******************************************************************************
+*
+* vbiVioapicDisplay - display the virtual I/O APIC table
+*
+* \NOMANUAL
+*/
+
+void vbiVioapicDisplay (void)
+{
+    VIOAPIC_REDIR_LOW	regIoApicRedirLow;
+    VIOAPIC_REDIR_HIGH	regIoApicRedirHigh;
+    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
+    uint32_t i;
+
+    static const char * deliveryModes[] = 
+        {" Fixed",	/* 0 */
+	 "Lowest",	/* 1 */
+	 "   SMI",	/* 2 */
+	 "  rsvd",	/* 3 */
+	 "   NMI",	/* 4 */
+	 "  INIT",	/* 5 */
+	 "  rsvd",	/* 6 */
+	 "ExtINT"};	/* 7 */
+
+    /* get the general virtual I/O APIC info */
+
+    VB_PRINTF ("Virtual I/O APIC:\n");
+    VB_PRINTF ("  Base address: 0x%p\n", pVioapic);
+    VB_PRINTF ("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
+    VB_PRINTF ("  version:     %d\n", pVioapic->version.field.version);
+    VB_PRINTF ("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
+
+    /* dump the virtual I/O APIC table */
+
+    VB_PRINTF ("\nRedirection Table:\n");
+    VB_PRINTF ("Entry Vector Mask Status Trig"
+		"  Pol IRR DeliverMode Destination\n");
+    VB_PRINTF (
+	"----- ------ ---- ------ ----- --- --- ----------- -----------\n");
+
+    for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
+
+	regIoApicRedirLow  = pVioapic->entry[i].vioapicLow;
+	regIoApicRedirHigh = pVioapic->entry[i].vioapicHigh;
+
+	VB_PRINTF (" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
+                i,
+                regIoApicRedirLow.field.vector,
+                regIoApicRedirLow.field.mask ? "MASK" : "none",
+                regIoApicRedirLow.field.delivStatus ? "PEND" : "idle",
+                regIoApicRedirLow.field.trigger ? "level" : "edge",
+                regIoApicRedirLow.field.polarity ? "lo" : "hi",
+                regIoApicRedirLow.field.irr,
+                deliveryModes[regIoApicRedirLow.field.deliveryMode],
+                regIoApicRedirLow.field.destMode ? "Set: " : "ID: ",
+                regIoApicRedirHigh.field.destination);
+    }
+    VB_PRINTF ("\n");
+}
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
new file mode 100644
index 0000000..8c0f6fb
--- /dev/null
+++ b/kernel/vbi/lib.c
@@ -0,0 +1,872 @@
+/* vbiLib.c - virtual Board Interface Library */
+
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01p,02sep09,mmi  mov message API descriptions to vbiMsg.c
+01o,15aug09,rdd  Fixing typo breaking file
+01n,14aug09,mpk  update vbi documentation
+01m,18jul09,mmi  remove flags
+01l,17jul09,mmi  fix description
+01k,16jul09,mpk  update VBI with mips64 support information
+01j,03jul09,mmi  add vbiInterrupt to docs
+01i,12jun09,mmi  append vbInterface.h for apigen
+01h,09jun09,mmi  put back wrhvVbIntNested
+01g,25may09,mmi  Update API descriptions
+01f,12may09,mmi  fix apigen errors and update for VBI 2.0
+01e,11dec08,mmi  replace razor with wrhv prefix
+01d,20nov08,mmi  adopt vbi naming convention
+01c,30sep08,md   update docs
+01b,28nov07,foo  vdk doc
+01a,20nov07,foo  written
+*/
+
+/*
+
+DESCRIPTION
+The vbi library (Virtual board interface) provides support functionality for
+software developers who are writing Virtual board applications, or as a guide to
+developers porting an operating system to the virtual board environment.
+This file contains the generic API that architecture independent. Separate
+documents are provided as supplement for APIs tied to a particular hardware
+architecture platform. 
+
+A given system may be composed of multiple VB where each VB may contain multiple
+Cores. During system bring-up stage hypervisor VB manager allocates resources
+specified in the XML configuration file for the each VB and initializes the
+configuration structure. Then the cores are launched starting at the entry point
+specified in the guest payload image. Hypervisor passes a pointer of the
+configuration page and a 32bit flag that holds the boot options of the core.
+These parameters are passed via stack or registers based on the underlying
+architecture platform.
+
+
+figure 1.1: A simplified overview diagram of a hypervisor system.
+
+\cs
+                           ________Hypercalls___||_______
+       Virtual board 0    |                     ||       |
+     _____________________V___                  ||       |
+    |    _____         _____  |\                ||       |
+    |   |Core |       |Core | | \     shared    ||    ___V____
+    |   | 0   |       | n   | |  \    pages     ||   |        |
+    |   |_____|       |_____| |   \   ______    ||   |        |
+    |_________________________|    \ |______|   ||   |        |
+                         ^           |______|--------|  H     |
+                         |           |______|   ||   |  Y     |
+                .        | interrupts           ||   |  P     |
+                .         ---------------------------|  E     |
+                .        |                      ||   |  R     |
+       Virtual board N   |           ______     ||   |  V     |
+     ____________________V____      |______|    ||   |  I     |
+    |    _____         _____  |    /|______|----||---|  S     |
+    |   |Core |       |Core | |   / |______|    ||   |  O     |
+    |   | 0   |       | n   | |  /              ||   |  R     |
+    |   |_____|       |_____| | /               ||   |________|
+    |_________________________|/                ||        ^
+                          ^                     ||        |
+                          |                     ||        |
+                          |_____________________||________|
+                                                ||
+
+                                                ^
+                                                |   
+                                             guest/hypervisor
+                                              speration line
+
+\ce
+
+
+
+
+Once the guest starts running it must call vbiInit() with the save parameters
+passed to it's entry routine which is the base address of the configuration.
+page. This routine retrieves the control and status page page pointers and
+saves them in the corresponding global variables.
+
+If the VMMU is turned on care must be taken to ensure that the memory regions
+below are mapped via the VMMU. It is suggested to treat these regions as
+devices regions where the mapping is flat and the cache attribute is guarded.
+
+A virtual board core is presented by hypervisor with 3 memory areas:
+
+\ml
+\m 1.
+Virtual Board Configuration Area
+
+This write protected memory area provides fixed configuration information to
+the virtual board.  The address of this is kept in the global variable
+wrhvConfig.  The address of this area is passed to the virtual board as the
+first parameter when the virtual board is started running at it's boot location.
+
+\m 2.
+Virtual Board Status Area
+
+This write protected memory area provides data to the virtual board that 
+changes due to run-time activity, such as registers saved due to an 
+interrupt, timestamps, virtual interrupts etc.  The address of this is
+kept in the global variable wrhvStatus.
+
+\m 3.
+Virtual Board Control Area
+
+This writable memory area is used by the virtual board to communicate 
+information to the hypervisor, where they cannot be passed in a faster manner.
+The address of this area is kept in the global variable wrhvControl.
+
+\me
+
+GLOBAL VARIABLES
+
+\cs
+VB_CONFIG *  wrhvVbConfig; /@ The address of the cores Configuration area
+                            * This value is passed to the core as the first 
+                            * parameter upon startup
+                            @/
+
+VB_CONTROL * wrhvVbControl;/@ The address of the core's Control area @/
+
+VB_STATUS *  wrhvVbStatus;  /@ The address of the core's Status area @/
+
+
+\ce
+
+INCLUDE FILES:  include/vbi/vbi.h
+
+\APPEND  vbiInterrupt.c
+\APPEND  vbiShmem.c
+\APPEND  vbiIdle.c
+\APPEND  vbiPaddr.c
+\APPEND  vbiShow.c
+\APPEND  vbiNs.c
+\APPEND  vbiMsg.c
+\APPEND  ../include/vbInterface.h
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+VB_CONFIG *  wrhvVbConfig;  /* The address of the core's Config area
+                            * This value is passed to the virtual board
+                            * as the first parameter upon startup
+                            */
+
+VB_CONTROL * wrhvVbControl; /* The address of the core's Control area */
+
+VB_STATUS *  wrhvVbStatus;  /* The address of the core's Status area */
+
+int32_t       wrhvVbIntNested; /* Used by VBI interrupt/exception management */
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(wrhvVbConfig);
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+* vbiInit - Initialize support for vbi library functions
+*
+* This routine initializes the vbi library 
+*
+* The routine should be called before accessing the virtual board configuration
+* data or making any hypercall. The parameters passed to this function should be
+* same as the boot parameters passed to the first executing program in the
+* running core by hypervisor which is a pointer to the core configuration
+* address. This routine retrieves the status and control page from the 
+* configuration page and initializes the following global variables for future
+* reference.
+*\ms
+*\m - Configuration page base address is stored in wrhvVbConfig
+*\m - Status page base address is stored in wrhvVbStatus
+*\m - Control page base address is stored in wrhvVbControl
+*
+* The user must ensure that this memory regions are mapped if the MMU is
+* turn-on.
+* A good practice would be to map these regions as devices meaning 1-1 
+* translation.
+*\me
+*\ce
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* void vbiInit
+*    (
+*    VB_CONFIG	*config		/@ Address of the VB config area    @/
+*    )
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+void vbiInit
+    (
+    VB_CONFIG *	config   /* Address of the VB config area */
+    )
+    {
+
+    /* 
+     * validate the vbi version; minor and maintenance should be backward
+     * compatible.
+     */
+
+    if (config->major < vbiVersionMajor )
+	{ 
+	vbiPanic("Invalid vbi version");
+	}	
+    
+    /* Init global variables for config, status and control structures */
+
+    wrhvVbConfig    = config;
+    wrhvVbControl   = wrhvVbConfig->vbControl;
+    wrhvVbStatus    = wrhvVbConfig->vbStatus;
+   
+    }
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service. 
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target core(s)
+* program counter to it's ENTRY function. The ENTRY function is determined based on
+* the loaded binary image. A core does not execute beyond it's ENTRY function
+* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
+* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+* the third argument to this routine.  
+* The hypercall sends a message to a manager that provides VB managment services.
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset is not
+* determined. The second argument identifies the cores to perform the operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images	
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest OS's
+* responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,	    /@ Id of the VB to suspend	    @/
+*    vbiCore_t     core,	    /@ Core within the VB	    @/
+*    uint32_t     options   /@ reload , start options	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
+*/
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to restart. 
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services. 
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were 
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_CORES_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: 
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend() 
+*/
+
+/*******************************************************************************
+*
+* vbiKputs - print a string on the hypervisor kernel console
+*
+* This routine makes a hypercall and prints a string of characters to to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputc() 
+*/
+
+/*******************************************************************************
+*
+* vbiKputc - print a character on the hypervisor kernel console
+*
+* This routine makes a hypercall in order to print the specified character to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputc (int c) /@ character to print @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputs()
+*/
+
+/*******************************************************************************
+*
+* vbiPanic - halt the system and dump debug info 
+*
+* This routine makes a hypercall in order to halt the system and display debug
+* information on hypervisor console. If hypervisor is configured with
+* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
+* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
+* the offending cores registers dump is displayed on hypervisor console. If
+* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
+* the debug manager.
+*
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiPanic (const char *msg) /@ pointer to message to print @/
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine 
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running. 
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart 
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          ) 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicVectorSet - Set a vector for the specified irq entry
+*
+* This routine sets a vector for the specified entry in the VIOAPIC redirection
+* table. The previous entry in the table is trashed. Before setting the new
+* vector in the entry the user can obtain the previous entry by calling 
+* vbiVioapicVectorGet(). The first argument passed to this function represent
+* the index to the VIOAPIC redirection table. The second argument is the vector
+* to set in the specified entry. 
+* For Intel architectures when an interrupt is raised the vector determines the
+* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
+*
+* This routine is currently not supported for PPC.  
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicVectorGet - Get a vector in the specified irq entry
+*
+* This routine gets a vector for the specified entry in the VIOAPIC table in
+* VIOAPIC redirection table. It may be used for saving the previous entry
+* before setting a new vector in the specified entry. This takes as an argument
+* the irq number that corresponds to the redirection table offset. 
+*
+* This routine is currently not supported for PPC 
+* This routine is currently not supported for MIPS.  
+* 
+* SYNOPSIS
+*\cs
+* 
+* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: vector number or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntMask - Mask an irq 
+*
+* This routine disables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
+* VIOAPIC redirection table is set to 1. After calling this function hypervisor
+* will deliver this IRQ only if this IRQ is enabled by calling
+* vbiVioapicIntUnmask(). 
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
+*
+* This routine enables the interrupt vector that matches the specified IRQ at
+* the VIOAPIC redirection table. This routine makes a hypercall in order to
+* deliver pending interrupts that might be queued while the irq was masked.
+* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
+* masked. Then clears the mask bit in the VIOAPIC redirection table for the
+* specified IRQ directed to the calling virtual Core.
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntSend - Send an interrupt
+*
+* This routine makes a hypercall to trigger an IRQ to one or more virtual board
+* that are connected to the line. The first argument passed to this function
+* specifies the IRQ number. The second argument specifies the filter to apply
+* to the list of virtual  boards connected to the IRQ. The third argument is
+* applicable only when VBI_IOAPICSEND_UNICAST filter is specified.
+*
+* In a SMP system a virtual board may have more than one core. If an IRQ is
+* sent to such system hypervisor will deliver the interrupt to the core that
+* was configured to receive the IRQ. The configuration is provided in the board
+* XML configuration file as the example shown below. 
+*
+*\cs
+*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
+*\ce
+*
+* The Vector number is not required to be specified in the XML. If not specified
+* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
+* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
+* 
+* The possible values for the filter (second argument) may be:
+*
+*\ms
+*\m -
+* VBI_IOAPICSEND_ALL	- Send to the group of virtual boards connected to this
+*                         IRQ include the sender board.
+*\m -
+* VBI_IOAPICSEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
+*                         excluding the sender board
+*\m -
+* VBI_IOAPICSEND_UNICAST	- Send an interrupt to the specified virtual board. This
+*		          will be delivered only if the destination board is
+*                         connected to this IRQ 
+*			  
+*\m -
+* VBI_IOAPICSEND_NONE	- Ignore this call.
+*
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVioapicIntSend 
+*             (
+*             vbiIrq_t irq, 
+*             uint32_t filter,
+*             vbiVb_t target 
+*             )
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
+*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntAck - Acknowledge an irq 
+*
+* This routine acknowledges the specified IRQ for the running core. Calling 
+* this routine causes Hypervisor to purge any pending interrupt that arrived
+* while the acknowledgement was pending. When a virual board receives an interrupt
+* it must call this function. Otherwise Hypervisor will block subsequent interrupt
+* for the same IRQ. Exceptions are not required to be acknowledged.
+*
+* This routine is currently not supported for MIPS.  
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVioapicIntRedirect - Redirect an irq to another core
+*
+* This routine makes a hypercall to redirect an irq from one core to another
+* within the same virtual board. 
+*
+* This routine is currently not supported for MIPS.   
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI X86 Architecture Supplements
+*
+* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
+*/
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
new file mode 100644
index 0000000..2104db6
--- /dev/null
+++ b/kernel/vbi/msg.c
@@ -0,0 +1,153 @@
+/* vbiMsg.c - vbi Message library */
+
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,08sep09,mmi  update comments
+01a,2sep09,mmi written
+*/
+
+/*
+
+DESCRIPTION
+VBI message library routines.
+
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+#define DEBUGM(fmt, args...) 
+#define _DEBUGM(fmt, args...) kprintf(fmt, ##args)
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received. This operation may
+* be aborted if an interrupt is delivered to the waiting Virtual board. If the
+* "flags" field in the control structure passed to this function is set to be 
+* VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
+* aborted before the expected message was received successfully.   
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*	   OK - in case of success
+*	   ERROR - in case of error	    
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiStatus_t vbiReceive
+    (
+    void		*rmsg, /* pointer to message to receive  */
+    uint32_t		rlen,  /* length of message to receive   */
+    VBI_MSG_INFO	*info, /* status info structure pointer  */
+    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
+    )                                   
+    { 
+    vbiStatus_t retVal;
+
+    while (1)
+	{
+	retVal = vbiReceiveOp(rmsg, rlen, info, ctl);
+
+        /* if retry flag set, continue */
+
+	if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
+	    break;
+
+        /* if retry flag is set _AND_ msg was aborted, retry */
+	if (info->error != VBI_MSG_ERROR_ABORTED)
+	    break;
+	
+	DEBUGM("%s aborted, retrying \n", __FUNCTION__);
+
+	}
+    return retVal;
+    }
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t   id,    /@ context id to reply the message to @/
+*    void *       buff,  /@ pointer to reply message  @/
+*    size_t       len,   /@ length of message to reply   @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
new file mode 100644
index 0000000..4353a07
--- /dev/null
+++ b/kernel/vbi/ns.c
@@ -0,0 +1,173 @@
+/* wrhvNs.c - hypervisor naming service, client side interface */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01g,18jul09,mmi  fix return types in vbNsXX() definition and comments
+01f,06jul09,mmi  add vbiPrv.h
+01e,21may09,mmi  update api descriptions
+01d,11dec08,md   rename header files
+01c,11dec08,md   rename of ns header files
+01b,19nov08,md   change in message passing API
+01a,03nov08,md   written
+*/
+
+/*
+DESCRIPTION
+
+This module implements a the client side of a simple naming service for the
+internal thread managers of the hypervisor.
+
+The interfaces formulate a message request and send it to the naming service
+for processing.
+
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/string.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+
+/* enable/disable debugging */
+
+/*
+ * #define DEBUG  define DEBUG to turn on debugging 
+ */
+
+#ifdef DEBUG
+#define DEBUGM(fmt, args...)    kprintf(fmt, ##args)
+#else
+#define DEBUGM(fmt, args...)   
+#endif
+
+/*******************************************************************************
+*
+* vbiNsRegister - register a service with the naming system
+*
+* This routine registers us as the provider of the specified service.
+* A message for the request is formulated and sent off to the name service
+* manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsRegister 
+*    (
+*    char    *name,		/@ name of service we're registering	@/
+*    uint32_t revision		/@ version of service			@/
+*    )
+*\ce                                                                 
+* RETURNS: OK, or errno if unable to register the service
+*
+* SEE ALSO: vbiNsLookup(), vbiNsUnregister()
+*
+*/
+
+vbiStatus_t vbiNsRegister
+    (
+    char    *name,	/* name of service we're registering */
+    uint32_t revision	/* version of service */
+    )
+    {
+
+    /* sanity check */
+
+    if (name == NULL)
+	return ERROR;
+
+    return (vbiNsOp (VBI_NS_REGISTER, name, revision, NULL));
+    }
+
+/*******************************************************************************
+*
+* vbiNsUnegister - un-register a service with the naming system
+*
+* This routine removes us as the provider of the specified service.
+* A message for the request is formulated and sent off to the name service
+* manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsUnregister 
+*    (
+*    char    *name,		/@ name of service we're unregistering	@/
+*    uint32_t revision		/@ version of service			@/
+*    )
+*\ce                                                                 
+*
+* RETURNS: OK, or errno if unable to un-register the service
+*
+* SEE ALSO: vbiNsLookup(), vbiNsRegister()
+*
+*/
+
+vbiStatus_t vbiNsUnregister
+    (
+    char    *name,	/* name of service we're un-registering */
+    uint32_t revision	/* version of service */
+    )
+    {
+
+    /* sanity check */
+
+    if (name == NULL)
+	return ERROR;
+    
+    return (vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL));
+    }
+
+/*******************************************************************************
+*
+* vbiNsLookup - look up a service provider using the naming system
+*
+* This routine uses the naming system to look up the context id of the
+* provider of the specified service.  A message for the request is
+* formulated and sent off to the name service manager for processing.
+*
+* SYNOPSIS
+*\cs
+* C FUNCTION
+* vbiStatus_t vbiNsLookup 
+*    (
+*    char    *name,		/@ name of service we're unregistering	@/
+*    uint32_t revision		/@ version of service			@/
+*    VBI_NS_HANDLE *handle	/@ handle of service provider		@/
+*    )
+*
+* RETURNS: 
+*   ERROR is case of failure
+*
+* SEE ALSO: vbiNsRegister(), vbiNsUnregister()
+*
+*/
+
+vbiStatus_t vbiNsLookup
+    (
+    char     *name,	    /* name of service we're un-registering */
+    uint32_t  revision,	    /* version of service			*/
+    VBI_NS_HANDLE *handle   /* handle of service provider		*/
+    )
+    {
+    
+    /* sanity check */
+
+    if (name == NULL || handle == NULL)
+	return ERROR;
+
+    return (vbiNsOp (VBI_NS_LOOKUP , name, revision, handle));
+    }
diff --git a/kernel/vbi/paddr.c b/kernel/vbi/paddr.c
new file mode 100644
index 0000000..44145a3
--- /dev/null
+++ b/kernel/vbi/paddr.c
@@ -0,0 +1,119 @@
+/* vbiPaddr.c - translate virtual address to a physical address */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01h,12aug09,dtr  Add vbiGuestDmaAddrGet and change name of vbiVirtToPhys to be
+                 vbiGuestPhysToPhys.
+01g,09jun09,mmi  rename physAddr_t to vbiPhysAddr_t
+01f,25may09,mmi  fix function prototype to use  physAddr_t for the physical
+                 address
+01e,15may09,mmi  fix apigen errors
+01d,23jan09,mmi  fix included header file
+01c,13dec08,mmi  replace vbiSyscalls.h with vbiSyscall.h
+01b,19nov08,mmi  introduced the VBI terminology
+01a,18apr08,md   written
+*/
+
+/*
+DESCRIPTION
+These modules provide interfaces to translate the current context's guest
+physical address into the physical machine address. vbiGuestDmaAddrGet is 
+specifically for a guest wanting an address that can be used by a DMA device.
+vbiGuestPhysToPhysAddr is used to return an absolute physical address to used 
+perhaps to communicate with the hypervisor itself maybe buffer pointers.
+*/
+
+/* includes */
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+
+/*******************************************************************************
+*
+* vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical 
+*                          address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address to physical address. This may be required for quick buffer 
+* transfer that requires the physical address of a memory region. The 
+* hypervisor may be running with > 4GB memory so the phys address is always 
+* 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestPhysToPhysAddr 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestPhysToPhysAddr
+    (
+    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 ));
+    }
+
+/*******************************************************************************
+*
+* vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address  to a physical address. This may be required for a device 
+* driver that requires the address it can use for DMA. The hypervisor may be 
+* running with > 4GB memory so the phys address is always 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestDmaAddrGet 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestDmaAddrGet
+    (
+    vbiGuestPhysAddr_t gaddr,	/* virtual address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0));
+    }
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
new file mode 100644
index 0000000..f2eb7a3
--- /dev/null
+++ b/kernel/vbi/shmem.c
@@ -0,0 +1,220 @@
+/* vbiShmem.c - shared memory utility functions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01m,03sep09,mmi  use _vbiStrncmp() for comparing strings
+01l,26aug09,mmi  fix WIND00178026: update copyright date
+01k,14jul09,mmi  fix private memory base get
+01j,03jul09,mmi  add private memory utility function
+01i,25may09,mmi  introduce vbiAttr_t for memory region attributes
+01h,22may09,mmi  revert to previous type function argument
+01g,15may09,mmi  fix apigen errors
+01f,17dec08,mmi  Use the correct number of memory region
+01e,12dec08,mmi  replace VB_MAX_RAZOR with VB_MAX_WRHV
+01d,11dec08,mmi  include vbi.h by default
+01c,19nov08,mmi  removed duplicate definition and rename functions to vbiXXX
+01b,23nov07,foo  fix includes
+01a,09may07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module contains the code for retriving the memory regions assigned to
+a virtual board. The information is passed in to the virtual board via the
+configuration structure. There is a descriptor table for each type of memory.
+
+\sh MEMORY TYPES
+\ms
+\m -
+There is a memory memory region assigned only to each board which can be
+retrieved by calling vbiMemRegionFind().
+\m -
+There is a shared memory which may be shared with other boards in the
+system. The shared memory can be retrieved by using vbiShmemRegionFind()
+
+\m -
+Each core in the system is assigned a private memory region. The base address
+and the length of this region may obtained by calling vbiCorePrvMemFind ()
+Alternatively the following macros can be used to obtained similar information
+    - 
+    -
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/module.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiPrv.h>
+#else
+#include <string.h>
+#include <vbi.h>
+#include <vbiPrv.h>
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiShmemRegionFind - locate the shared memory parameters for a given region
+*
+* This function finds the shared memory region associated with the name 
+* specified. The first argument to this function indicates the name of the
+* shared to find. If this region exists in the list of configured regions the
+* address, length and MMU attributes are set in the pointers passed in as 
+* arguments.
+* 
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiShmemRegionFind
+*   (
+*   const char *    smName,	/@ String name of the region    @/
+*   void * *	    addr,	/@ Location - OUT		@/
+*   size_t *	    length,	/@ Length - OUT			@/
+*   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an errror number in case of failure
+*
+* ERRNO:                                
+*
+* SEE ALSO: vbiMemRegionFind() 
+*/
+
+vbiStatus_t vbiShmemRegionFind
+    (
+    int8_t *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    )
+    {
+    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
+    VB_SM_INFO * info = config->sharedMemoryRegionsConfigAddress;
+    int32_t          num  = config->numSm;
+    int32_t          i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!_vbiStrncmp ((char *)smName, (char *)info->name, 
+	    VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return (OK);
+            }
+        }
+    *addr = 0;
+    return (VBI_INVALID_SHMEM);
+    }
+
+#ifdef CONFIG_WRHV
+EXPORT_SYMBOL(vbiShmemRegionFind);
+#endif /* CONFIG_WRHV */
+
+/******************************************************************************
+*
+* vbiMemRegionFind - locate the memory parameters for a given region
+*
+* This function finds the memory region associated with the name specified. 
+* The first argument to this function indicates the name of the memory to find
+* If this region exists in the list of configured regions the address, 
+* length and MMU attributes are set in the pointers passed in as
+* arguments.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemRegionFind
+*   (
+*   const char *    name,   /@ String name of the region    @/
+*   void * *	    addr,   /@ Location - OUT		    @/
+*   size_t *	    length, /@ Length - OUT		    @/
+*   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiMemRegionFind
+    (
+    int8_t   *	    name,	/* String name of the region  */
+    void   * *	    addr,	/* Location - OUT		    */
+    uint32_t    *length,	/* Length - OUT		    */
+    uint32_t *	    attr	/* MMU Attributes - OUT	    */
+    )
+    {
+    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
+    VB_MEM_INFO * info = config->memoryRegionsConfigAddress;
+    int32_t      num  = config->numMem;
+    int32_t      i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!_vbiStrncmp ((char *)name, (char *)info->name,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return (OK);
+            }
+        }
+    *addr = 0;
+
+    return (VBI_INVALID_SHMEM);
+    
+    }
+
+/******************************************************************************
+*
+* vbiCorePrvMemFind - locate the private memory for a core
+*
+* This function gets the base address of the private memory region assigned to
+* the running core. 
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiCorePrvMemFind 
+*   (
+*   void * *    addr,	    /@ Location - OUT		    @/
+*   size_t *	length	    /@ Length - OUT		    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiCorePrvMemFind 
+    (
+    void * *       addr,      /* Location - OUT */
+    size_t *     length       /* Length - OUT */
+    )
+    {
+
+    *addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
+    *length = VBI_VCORE_PRIVMEM_SIZE_GET();
+    
+    return (OK);
+    }
+
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
new file mode 100644
index 0000000..c0a7111
--- /dev/null
+++ b/kernel/vbi/show.c
@@ -0,0 +1,327 @@
+/* vbiShow.c - virtual board data show functions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01l,06aug09,dtr  Modify status intPending to intPendingType.
+01k,04jun09,md   add core number to interrupt display
+01j,25may09,mmi  vbiShow should be the only published API
+01i,20may09,mmi  update function headers
+01h,29apr09,mpk  add Privileged OS VBI support
+01g,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+01f,17apr09,mpk  supervisor VBI calls
+01e,11mar09,mmi  fix defect WIND00158420
+01d,22jan09,mmi  call show routines only if available
+01c,23dec08,mmi  call show routines for access registers
+01b,23dec08,mmi  make vbiMemoryShow non-static
+01a,19dec08,mmi  created based on vbShow version 01j
+*/
+
+/*
+DESCRIPTION
+
+The Virtual Board show functions display virtual board status,
+control and configuration data structures.
+
+*/
+
+#ifdef CONFIG_WRHV
+#define LONG_FMT "0x%lx"
+#define kprintf printk
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#else
+#include <vbi.h>
+#endif /* CONFIG_WRHV */
+
+/*******************************************************************************
+*
+* vbiSharedMemoryShow - print information about the shared memory configuration
+*
+* This routine traverse the array of shared memories descriptor for a given board
+* and displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiSharedMemoryShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+* \NOMANUAL
+*/
+
+void vbiSharedMemoryShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_SM_INFO * p = config->sharedMemoryRegionsConfigAddress;
+    int          numSm = config->numSm;
+    void *       pState = config->sharedMemoryRegionsStateAddress;
+    int          i;
+
+    VB_PRINTF("%d Shared memory regions, Config at 0x%x:\n", numSm, p);
+
+    /* dump shared memory info if we have any attached */
+
+    for (i=0; i < numSm; i++,p++)
+        {
+	VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x)\n",
+		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
+		p->attr);
+        }
+
+    VB_PRINTF("Shared memory State at 0x%x:\n", pState);
+
+
+    }
+
+/*******************************************************************************
+*
+* vbiMemoryShow - print information about a board's  memory configuration
+*
+* This routine traverse the array of memory regions descriptor for a given board
+* and displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiSharedMemoryShow (void)
+*
+*\ce
+*
+* RETURNS: returns OK or errno in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiMemoryShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_MEM_INFO * p = config->memoryRegionsConfigAddress;
+    int          numSm = config->numMem;
+    int          i;
+
+    VB_PRINTF ("%d memory regions, Config at 0x%x:\n", numSm, p);
+
+    /* dump shared memory info if we have any attached */
+
+    for (i=0; i < numSm; i++,p++)
+        {
+	VB_PRINTF ("%8s: 0x%08x -> 0x%08x  (attr: 0x%x) (type: %s)\n",
+		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
+                p->attr, p->type);
+        }
+    }
+
+/*******************************************************************************
+*
+* vbiInterruptsShow - print information about a board's interrupts configuration
+*
+* This routine traverse the interrupts descriptors table for a given board and
+* displays the information on hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiInterruptsShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*\NOMANUAL
+*
+*/
+
+static void vbiInterruptsShow
+    (
+    VB_CONFIG * config
+    )
+    {
+    VB_INT_INFO * p = config->interruptConfiguration;
+    int           numInt = config->numInts;
+    int           i;
+
+    VB_PRINTF ("%d interrupt configurations, Config at 0x%x\n", numInt, p);
+
+    for (i = 0; i < numInt; i++, p++)
+        {
+	if (p->intDirection == VB_INPUT_INT)
+	    {
+	    VB_PRINTF ("%8s: Direction: In, Vector Number: %d, Core: %d\n",
+                p->intName, p->intNumber, p->intCore);
+	    }
+	else
+	    {
+	    VB_PRINTF ("%8s: Direction: Out, Vector Number: %d\n",
+                p->intName, p->intNumber);
+	    }
+        }
+    }
+
+/*******************************************************************************
+*
+* vbiStatusShow - print information about a board's status structures
+*
+* This routine displays information in the status structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiStatusShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiStatusShow
+    (
+    VB_STATUS *p
+    )
+    {
+
+    VB_PRINTF ("VB status: 0x%x\n", p);
+
+    VB_PRINTF ("  Pending interrupts: 0x%08x\n", p->intPendingType);
+    VB_PRINTF ("  timestamp:          %lld\n", p->timeStamp);
+    VB_PRINTF ("  old int disable:    0x%08x\n", p->oldIntDisable);
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    vbiStsRegsDisplay ();
+#endif
+    }
+
+/*******************************************************************************
+*
+* vbiControlShow - print information about a board's control structures
+*
+* This routine displays information in the control structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiControlShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*\NOMANUAL
+*/
+
+void vbiControlShow
+    (
+    VB_CONTROL * p
+    )
+    {
+    int i;
+
+    VB_PRINTF ("VB control data: 0x%x\n", p);
+
+    VB_PRINTF ("  Disable interrupts:  0x%08x\n", p->intDisable);
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    vbiCtrlRegsDisplay (); 
+#endif
+
+    VB_PRINTF ("  Disabled interrupts:");
+    for (i=0; i < VB_MAX_INTERRUPTS; i++)
+        {
+	if ((p->intLevelDisable & (1 << (32 - i))) != 0)
+            {
+	    VB_PRINTF (" %d", i);
+            }
+        }
+    VB_PRINTF ("\n");
+    }
+
+/*******************************************************************************
+*
+* vbiConfigShow - print information about a board's config structures
+*
+* This routine displays information in the config structure for a given board.
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiConfigShow (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*
+*/
+
+void vbiConfigShow
+    (
+    VB_CONFIG * p
+    )
+    {
+
+    VB_PRINTF ("VB config data: 0x%x\n", p);
+
+    VB_PRINTF ("pid:                %d\n",	    p->pid);
+    VB_PRINTF ("Board ID:           %d\n",	    p->boardID);
+
+    VB_PRINTF ("Status Address:     " LONG_FMT "\n", p->vbStatus);
+    VB_PRINTF ("Control Address:    " LONG_FMT "\n", p->vbControl);
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+    VB_PRINTF ("Syscall Table Address:    " LONG_FMT "\n", p->vbSyscallTable);
+#endif
+    VB_PRINTF ("SupervisoryMode:    %d\n",	    p->supervisoryMode);
+
+    VB_PRINTF ("Board Name:         %s\n",	    p->boardName);
+    VB_PRINTF ("Board Type:         %d\n",	    p->boardType);
+    VB_PRINTF ("Physical Memory:    %d\n",     p->physicalMemorySize);
+    VB_PRINTF ("Memory Alias Addr:  0x%08x\n", p->memoryAliasAddress);
+    VB_PRINTF ("Memory Alias Size:  %u\n",     p->memoryAliasSize);
+    VB_PRINTF ("Reset PC:           0x%08x\n", p->resetPC);
+
+    VB_PRINTF ("Timer Frequency:     %d/sec\n",	    p->tickTimerFrequency);
+    VB_PRINTF ("TimeStamp Frequency: %dULL/sec\n",	    p->timeStampFrequency);
+
+    VB_PRINTF ("numInts:             %d\n",	    p->numInts);
+
+    vbiMemoryShow (p);
+    vbiSharedMemoryShow (p);
+    vbiInterruptsShow (p);
+
+    }
diff --git a/kernel/vbi/version.c b/kernel/vbi/version.c
new file mode 100644
index 0000000..74a838d
--- /dev/null
+++ b/kernel/vbi/version.c
@@ -0,0 +1,56 @@
+/* vbiVersion.c - creation version/date/time module */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River License agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,03jul09,mmi  rename VB_VERSION_XX
+01a,16apr09,mmi  written 
+*/
+
+/*
+This module is always built with each executable image.  It provides
+the VBI version id, and the time and date it was built.
+
+The date stamp may be overriden by defining VBI_RUNTIME_CREATION_DATE. This
+will be primarily used by guest OS's that use VBI.
+
+The ANSI predefined macros __DATE__ and __TIME__ are used to provide
+the date/time information.  ANSI compliant compilers are required for
+building all hypervisor executables.
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/types.h>
+#include <vbi/vbi.h>
+#include <vbi/vbiVersion.h>
+#else
+#include <vbi.h>
+#include <vbiVersion.h>
+#endif /* CONFIG_WRHV */
+
+/* numerical values for vbi version */
+
+const uint32_t vbiVersionMajor = VBI_VERSION_MAJOR;
+const uint32_t vbiVersionMinor = VBI_VERSION_MINOR;
+const uint32_t vbiVersionMaint = VBI_VERSION_MAINT;
+
+/* string identifiers for vbi version */
+
+const char *vbiRuntimeName       = VBI_RUNTIME_NAME;
+const char *vbiRuntimeVersion    = VBI_RUNTIME_VERSION;
+const char *vbiVersion		 = VBI_VERSION;
+
+#ifdef VBI_RUNTIME_CREATION_DATE
+const char *vbiCreationDate = VBI_RUNTIME_CREATION_DATE;
+#else
+const char *vbiCreationDate = __DATE__ ", " __TIME__;
+#endif
+
diff --git a/kernel/vbi/vmmu_doc.txt b/kernel/vbi/vmmu_doc.txt
new file mode 100644
index 0000000..07ed871
--- /dev/null
+++ b/kernel/vbi/vmmu_doc.txt
@@ -0,0 +1,245 @@
+/* vbiVmmuDoc.c - Virtual Board Interface VMMU APIs */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind RIver License agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,03jul09,mmi  fix vbiVmmuEnable/Disable
+01a,31may09,mmi written
+*/
+
+/*
+DESCRIPTION
+The module contains the VBI VMMU supplement.
+The VMMU configuration structure is an essential data type to understand this
+module. It is the descriptor for an VMMU context with the following info:
+
+\ms
+\m -
+ The VMMU page table base address 
+\m - 
+ The VMMU pages
+\m -
+ The page size granularity 
+\me 
+
+ VMMU_CONFIG definition:
+
+ typedef struct vmmuConfig
+    {
+    VMMU_LEVEL_1_DESC *addr;
+    size_t         pageSize;
+    uint32_t       reserved;
+    uint32_t       vmmu_num;
+    } VMMU_CONFIG;
+
+ The vmmu virtual address space is restricted to 32 bits and is decoded using
+ a level-1/level-2 page table.  The virtual address is decoded as follows:
+\cs
+
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+                11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+ Each page table entry is 8 bytes (2 words) and uses the following format:
+
+ word 0 (32-bits):
+          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+                                          6 7 8 9 0 1 2 3
+         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+                V          - valid bit
+                Hypervisor - reserved for use by hypervisor
+                U0-U7      - user defined attributes
+                ERPN       - extended real page number bits
+                ATTR       - page attributes
+
+ word 1 (32-bits):
+
+          0                                19 20      23 2 2 2 2 2 2 3 3
+                                                         4 5 6 7 8 9 0 1
+         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+         |                                   |          | | |X|X|W|W|R|R|
+         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+                RPN        - real page number
+                R          - page referenced bit
+                C          - page changed bit
+                SX,SW,SR   - supervisor mode protection bits
+                UX,UW,UR   - user mode protection bits
+\ce
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+*/
+
+
+/*******************************************************************************
+*
+* vbiVmmuConfig - configure the hypervisor virtual MMU
+*
+* This makes a hypercall in order to register a context's  virtual MMU within
+* the hypervisor using a fast hypercall. To enable the newly configured VMMU the
+* user must vbiVmmuEnable(). This funtion takes a pointer to a VMMU
+* configuration structure. 
+* Whenever the VMMU state is changed, the vbiVmmuConfig() operation will flush
+* the TLB entries to ensure consistency between the processor and the page tables.
+* 
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuConfig (VMMU_CONFIG * pVmmuConfig) /@ config pointer @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuEnable(), vbiVmmuDisable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuEnable - Enable virtual MMU
+*
+* This routines enables the context's virtual MMU within the hypervisor using a
+* fast hypercall. Before calling this routine one must ensure to configure the
+* VMMU page table, map all necessary memory regions, initialize the VMMU
+* configuration and register it by calling vbiVmmuConfig(). Once the VMMU
+* is enabled any memory access is translated via the VMMU page tables. The
+* argument passed to this routine is the VMMU index. Currently hypervisor
+* supports only one VMMU therefore the index is always zero.
+*
+* Special care must taken to ensure that the executed code and data regions
+* accessed are mapped. It is suggested that any data regions shared with 
+* Hypervisor is idendity mapped (flat mapping or 1-1 translation).
+* 
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuEnable (vbiVmmuIndex_t vmmuIndex) /@ vmmu Handle @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuDisable - Disable VMMU for running core
+*
+* This routines disables the core's VMMU within the hypervisor using a 
+* hypercall. The argument passed to this routine is the VMMU index. Currently
+* hypervisor supports only one VMMU therefore the index is always zero. 
+*
+* This is equivalent to calling vbiVmmuConfig(vbiVmmuIndex_t, NULL). 
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuDisable (VBI_VMMU_HANDLE vmmuHandle) /@ vmmu handle @/
+*
+*\ce
+*
+* RETURNS: returns OK or error in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuTlbFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiVmmuTlbFlush - Flush TLB entries for a range of address
+*
+* This routine flushes the TLB entries for the specified address range from 
+* the virtual MMU.
+* The vbVmmuTlbFlush function is used to ensure that any VMMU translations for
+* the specified address range are cleared from the processor.s TLB cache.
+* All page translations starting at address for a length of length bytes in the
+* specified vmmu context will be cleared from the TLB cache
+*
+* SYNOPSIS
+*\cs
+* 
+*
+* vbiStatus_t vbiVmmuTlbFlush
+*		( 
+*		VMMU_CONFIG *config,	/@ The VMMU configuration to use @/
+*		void	    *addr,	/@ Starting address              @/
+*		size_t	    len)	/@ length                        @/
+*		)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuEnable()
+*/
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
new file mode 100644
index 0000000..ae88409
--- /dev/null
+++ b/kernel/vbi/wrhv.c
@@ -0,0 +1,137 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2008 Wind River Systems, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/kernel_stat.h>
+#include <linux/wrhv.h>
+#include <linux/sched.h>
+#include <vbi/vbi.h>
+
+#define VIOAPIC_BASE_ADDR      (&wrhvVbControl->vIoapic)
+
+static uint32_t vioapic_reg_read(uint8_t offset)
+{
+	uint32_t reg;
+	reg = VIOAPIC_REG_GET(VIOAPIC_BASE_ADDR, offset);
+	return reg;
+}
+
+static void vioapic_reg_write(uint8_t  offset, uint32_t value)
+{
+	VIOAPIC_REG_SET(VIOAPIC_BASE_ADDR, offset, value);
+}
+
+static void wrhv_enable_vector(unsigned int vector)
+{
+	uint32_t curr, offset;
+
+	offset = VIOAPIC_REG_REDTBL + vector*2;
+	curr = vioapic_reg_read(offset);
+	curr &= ~VIOAPIC_INT_MASK;
+	vioapic_reg_write(offset, curr);
+}
+
+static void wrhv_disable_vector(unsigned int vector)
+{
+	uint32_t curr, offset;
+
+	offset = VIOAPIC_REG_REDTBL + vector*2;
+	curr = vioapic_reg_read(offset);
+	curr |= VIOAPIC_INT_MASK;
+	vioapic_reg_write(offset, curr);
+}
+
+static void wrhv_enable_irq(unsigned int irq)
+{
+	vbiVioapicIntUnmask(irq);
+}
+
+static void wrhv_disable_irq(unsigned int irq)
+{
+	vbiVioapicIntMask(irq);
+}
+
+static void wrhv_ack_irq(unsigned int irq)
+{
+	vbiVioapicIntAck(irq);
+}
+
+static void wrhv_maskack_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbiVioapicIntMask(irq);
+	vbiVioapicIntAck(irq);
+}
+
+static void wrhv_mask_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbiVioapicIntMask(irq);
+}
+
+static void wrhv_unmask_irq(unsigned int irq)
+{
+	if (irq != 0)
+		vbiVioapicIntUnmask(irq);
+}
+
+struct irq_chip wrhv_irq_chip = {
+	.name		= "WRHV-PIC",
+	.mask		= wrhv_mask_irq,
+	.ack		= wrhv_ack_irq,
+#ifndef CONFIG_X86
+	.disable	= wrhv_disable_irq,
+	.enable		= wrhv_enable_irq,
+#endif
+	.unmask		= wrhv_unmask_irq,
+	.mask_ack	= wrhv_maskack_irq,
+	.eoi		= wrhv_ack_irq,
+};
+
+unsigned long wrhv_calculate_cpu_khz(void)
+{
+	printk(KERN_DEBUG "WRHV: Timestamp Frequency %u Hz\n",
+		wrhvVbConfig->timeStampFrequency);
+	return wrhvVbConfig->timeStampFrequency / 1000;
+}
+
+irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
+{
+	static long long mark_offset;
+	long long ticks;
+	int lost_jiffies = 0;
+	struct pt_regs *regs = get_irq_regs();
+
+	ticks = wrhvVbStatus->tickCount;
+	ticks -= mark_offset;
+	lost_jiffies = ticks - 1;
+	mark_offset = wrhvVbStatus->tickCount;
+
+	do {
+		do_timer(1);
+		update_process_times(user_mode(regs));
+		profile_tick(CPU_PROFILING);
+		if (lost_jiffies > (2*HZ)) {
+			printk(KERN_DEBUG "Time falling behind %d jiffies\n", lost_jiffies);
+			break;
+		}
+	} while (--ticks > 0);
+
+	if (lost_jiffies)
+		account_steal_time(NULL, jiffies_to_cputime(lost_jiffies));
+	return IRQ_HANDLED;
+}
diff --git a/kernel/vbiIdle.c b/kernel/vbiIdle.c
deleted file mode 100644
index f41f4dd..0000000
--- a/kernel/vbiIdle.c
+++ /dev/null
@@ -1,72 +0,0 @@
-/* vbiIdle.c - context idle code */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01h,26aug09,mmi  fix WIND00178026: update copyright
-01g,25may09,mmi  introduce a new type vbiTicks_t
-01f,15may09,mmi  fix apigen errors
-01e,11dec08,mmi  alwasy include vbi.h
-01d,19nov08,mmi  adopt new naming convention vbi...
-01c,02jul08,md   fix parameter ordering
-01b,21nov07,foo  idle parameter
-01a,04jun07,md   written
-*/
-
-/*
-DESCRIPTION
-This module provides an interface to put the currently running virtual board
-into the idle state.
-*/
-
-/* includes */
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <vbi/vbi.h>
-#else
-#include <vbi.h>
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiIdle - inform the hypervisor scheduler that the virtual board is idle
-*
-* This function informs the hypervisor that the virtual board core's is idle and
-* also provides a timeout at which it needs to be made ready to run again. This
-* routine halts the active core untill the specified timeout expires or and an
-* asynchronous event like a interrupt is delivered to the calling core. An zero
-* timeout means to halt the core indefinetly until an asynchronous event occurs.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiIdle (vbiTicks_t timeout)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-void vbiIdle
-    (
-    uint64_t timeStamp /* Time at which to wake up */
-    )
-    {
-    uint32_t tickCount = timeStamp & 0xFFFFFFFF;
-
-    /* use the hypervisor system call to go into the idle state */
-
-    vbiCtxctl (VBI_CTXCTL_IDLE, tickCount, 0);
-    }
diff --git a/kernel/vbiInterrupt.c b/kernel/vbiInterrupt.c
deleted file mode 100644
index 24fecd3..0000000
--- a/kernel/vbiInterrupt.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/* vbiInterrupt.c - virtual board interrupt configuration utility */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01m,03sep09,mmi  fix depency to vba library for comparing strings
-01l,26aug09,mmi  fix WIND00178026: update copyright
-01k,03jul09,mmi  update description
-01j,19jun09,mmi  revert to previous name for this file
-01i,26feb09,mmi  change vbiIntVecFind definition to return vector
-01h,17dec08,mmi  rename vbiIntCtrlFindVector with vbiIntVecFind
-01g,13dec08,mmi  remove razorVxWorks.h 
-01f,21nov08,mmi  include vbi.h instead of vdk.h
-01e,19nov08,mmi  change API's names to vbiXXX and miscl. cleanup
-01d,10sep08,md   fix vbiIntCtlrConnect parameters
-01c,23nov07,foo  fix includes
-01b,25oct07,foo  update for real hardware interrupt implementation
-01a,09may07,foo  written
-*/
-
-/*
- * This module contains the code for accessing the the interrupts configuration
- * of the virtual board.
- */
-
-/*#define DEBUG 1*/
-#ifdef DEBUG
-#define DEBUGM(x) x
-#else
-#define DEBUGM(x)
-#endif
-
-#ifdef CONFIG_WRHV
-#include <linux/string.h>
-#include <vbi/vbi.h>
-#include <linux/types.h>
-#include <vbi/vbiPrv.h>
-#include <linux/module.h>
-#else
-#include <string.h>
-#include <vbi.h>
-#include <vbiPrv.h>
-#endif /* CONFIG_WRHV */
-
-/******************************************************************************
-*
-* vbiIntVecFind - determine the irq for a specified name
-*
-* This function finds the irq number of a named interrupt from  the virtual
-* board configuration information.
-* 
-* The <intDirection> is either input or output. VB_INPUT_INT for input,
-* VB_OUTPUT_INT for output.
-*
-* EXAMPLES:
-* \cs
-*     fredIntVector = vbiIntVecFind ("fred", VB_INPUT_INT);
-* \ce
-*
-* RETURNS: vector number, VBI_INVALID_IRQ if not found
-*
-*/
-
-vbiIrq_t vbiIntVecFind
-    (
-    char *  intName,		/* string name of the interrupt */
-    int32_t  intDirection 	/* interrupt direction */
-    )
-    {
-    VB_CONFIG *   config = VBI_CONFIG_ADDR_GET();
-    VB_INT_INFO * info = config->interruptConfiguration;
-    int32_t       num  = config->numInts;
-    int32_t       i;
-
-    for (i = 0; i < num; i++, info++)
-        {
-        if (intDirection != (int32_t)(info->intDirection))
-            continue;
-
-        if (!_vbiStrncmp ((char *)intName, (char *)info->intName,
-            VB_MAX_WRHV_NAME_LENGTH))
-            {
-
-            /* Found */
-
-            return (int32_t)info->intNumber;
-            }
-        }
-
-    return (VBI_INVALID_IRQ); /* no match */
-    }
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(vbiIntVecFind);
-#endif /* CONFIG_WRHV */
diff --git a/kernel/vbiLib.c b/kernel/vbiLib.c
deleted file mode 100644
index 8c0f6fb..0000000
--- a/kernel/vbiLib.c
+++ /dev/null
@@ -1,872 +0,0 @@
-/* vbiLib.c - virtual Board Interface Library */
-
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01p,02sep09,mmi  mov message API descriptions to vbiMsg.c
-01o,15aug09,rdd  Fixing typo breaking file
-01n,14aug09,mpk  update vbi documentation
-01m,18jul09,mmi  remove flags
-01l,17jul09,mmi  fix description
-01k,16jul09,mpk  update VBI with mips64 support information
-01j,03jul09,mmi  add vbiInterrupt to docs
-01i,12jun09,mmi  append vbInterface.h for apigen
-01h,09jun09,mmi  put back wrhvVbIntNested
-01g,25may09,mmi  Update API descriptions
-01f,12may09,mmi  fix apigen errors and update for VBI 2.0
-01e,11dec08,mmi  replace razor with wrhv prefix
-01d,20nov08,mmi  adopt vbi naming convention
-01c,30sep08,md   update docs
-01b,28nov07,foo  vdk doc
-01a,20nov07,foo  written
-*/
-
-/*
-
-DESCRIPTION
-The vbi library (Virtual board interface) provides support functionality for
-software developers who are writing Virtual board applications, or as a guide to
-developers porting an operating system to the virtual board environment.
-This file contains the generic API that architecture independent. Separate
-documents are provided as supplement for APIs tied to a particular hardware
-architecture platform. 
-
-A given system may be composed of multiple VB where each VB may contain multiple
-Cores. During system bring-up stage hypervisor VB manager allocates resources
-specified in the XML configuration file for the each VB and initializes the
-configuration structure. Then the cores are launched starting at the entry point
-specified in the guest payload image. Hypervisor passes a pointer of the
-configuration page and a 32bit flag that holds the boot options of the core.
-These parameters are passed via stack or registers based on the underlying
-architecture platform.
-
-
-figure 1.1: A simplified overview diagram of a hypervisor system.
-
-\cs
-                           ________Hypercalls___||_______
-       Virtual board 0    |                     ||       |
-     _____________________V___                  ||       |
-    |    _____         _____  |\                ||       |
-    |   |Core |       |Core | | \     shared    ||    ___V____
-    |   | 0   |       | n   | |  \    pages     ||   |        |
-    |   |_____|       |_____| |   \   ______    ||   |        |
-    |_________________________|    \ |______|   ||   |        |
-                         ^           |______|--------|  H     |
-                         |           |______|   ||   |  Y     |
-                .        | interrupts           ||   |  P     |
-                .         ---------------------------|  E     |
-                .        |                      ||   |  R     |
-       Virtual board N   |           ______     ||   |  V     |
-     ____________________V____      |______|    ||   |  I     |
-    |    _____         _____  |    /|______|----||---|  S     |
-    |   |Core |       |Core | |   / |______|    ||   |  O     |
-    |   | 0   |       | n   | |  /              ||   |  R     |
-    |   |_____|       |_____| | /               ||   |________|
-    |_________________________|/                ||        ^
-                          ^                     ||        |
-                          |                     ||        |
-                          |_____________________||________|
-                                                ||
-
-                                                ^
-                                                |   
-                                             guest/hypervisor
-                                              speration line
-
-\ce
-
-
-
-
-Once the guest starts running it must call vbiInit() with the save parameters
-passed to it's entry routine which is the base address of the configuration.
-page. This routine retrieves the control and status page page pointers and
-saves them in the corresponding global variables.
-
-If the VMMU is turned on care must be taken to ensure that the memory regions
-below are mapped via the VMMU. It is suggested to treat these regions as
-devices regions where the mapping is flat and the cache attribute is guarded.
-
-A virtual board core is presented by hypervisor with 3 memory areas:
-
-\ml
-\m 1.
-Virtual Board Configuration Area
-
-This write protected memory area provides fixed configuration information to
-the virtual board.  The address of this is kept in the global variable
-wrhvConfig.  The address of this area is passed to the virtual board as the
-first parameter when the virtual board is started running at it's boot location.
-
-\m 2.
-Virtual Board Status Area
-
-This write protected memory area provides data to the virtual board that 
-changes due to run-time activity, such as registers saved due to an 
-interrupt, timestamps, virtual interrupts etc.  The address of this is
-kept in the global variable wrhvStatus.
-
-\m 3.
-Virtual Board Control Area
-
-This writable memory area is used by the virtual board to communicate 
-information to the hypervisor, where they cannot be passed in a faster manner.
-The address of this area is kept in the global variable wrhvControl.
-
-\me
-
-GLOBAL VARIABLES
-
-\cs
-VB_CONFIG *  wrhvVbConfig; /@ The address of the cores Configuration area
-                            * This value is passed to the core as the first 
-                            * parameter upon startup
-                            @/
-
-VB_CONTROL * wrhvVbControl;/@ The address of the core's Control area @/
-
-VB_STATUS *  wrhvVbStatus;  /@ The address of the core's Status area @/
-
-
-\ce
-
-INCLUDE FILES:  include/vbi/vbi.h
-
-\APPEND  vbiInterrupt.c
-\APPEND  vbiShmem.c
-\APPEND  vbiIdle.c
-\APPEND  vbiPaddr.c
-\APPEND  vbiShow.c
-\APPEND  vbiNs.c
-\APPEND  vbiMsg.c
-\APPEND  ../include/vbInterface.h
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <linux/module.h>
-#include <vbi/vbi.h>
-#else
-#include <vbi.h>
-#endif /* CONFIG_WRHV */
-
-VB_CONFIG *  wrhvVbConfig;  /* The address of the core's Config area
-                            * This value is passed to the virtual board
-                            * as the first parameter upon startup
-                            */
-
-VB_CONTROL * wrhvVbControl; /* The address of the core's Control area */
-
-VB_STATUS *  wrhvVbStatus;  /* The address of the core's Status area */
-
-int32_t       wrhvVbIntNested; /* Used by VBI interrupt/exception management */
-
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(wrhvVbConfig);
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-* vbiInit - Initialize support for vbi library functions
-*
-* This routine initializes the vbi library 
-*
-* The routine should be called before accessing the virtual board configuration
-* data or making any hypercall. The parameters passed to this function should be
-* same as the boot parameters passed to the first executing program in the
-* running core by hypervisor which is a pointer to the core configuration
-* address. This routine retrieves the status and control page from the 
-* configuration page and initializes the following global variables for future
-* reference.
-*\ms
-*\m - Configuration page base address is stored in wrhvVbConfig
-*\m - Status page base address is stored in wrhvVbStatus
-*\m - Control page base address is stored in wrhvVbControl
-*
-* The user must ensure that this memory regions are mapped if the MMU is
-* turn-on.
-* A good practice would be to map these regions as devices meaning 1-1 
-* translation.
-*\me
-*\ce
-* SYNOPSIS
-*\cs
-* C FUNCTION
-* void vbiInit
-*    (
-*    VB_CONFIG	*config		/@ Address of the VB config area    @/
-*    )
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-void vbiInit
-    (
-    VB_CONFIG *	config   /* Address of the VB config area */
-    )
-    {
-
-    /* 
-     * validate the vbi version; minor and maintenance should be backward
-     * compatible.
-     */
-
-    if (config->major < vbiVersionMajor )
-	{ 
-	vbiPanic("Invalid vbi version");
-	}	
-    
-    /* Init global variables for config, status and control structures */
-
-    wrhvVbConfig    = config;
-    wrhvVbControl   = wrhvVbConfig->vbControl;
-    wrhvVbStatus    = wrhvVbConfig->vbStatus;
-   
-    }
-
-/*******************************************************************************
-*
-* vbiVbSuspend - Suspend a virtual board's core
-*
-* This routine makes a hypercall in order to suspend one or more cores that
-* exist within the specified virtual board. The target core(s) enter HALT state
-* until vbiVbResume() is called change the state of the core(s). This function
-* will return only after all victim cores are suspended unless the opration
-* fails to complete. The second argument passed to this function specifies one
-* or more target cores. For suspending every core within the specified VB the
-* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
-* requesting the suspension may also be included in the list to be suspended.
-* To suspend everyone but the recipient then the second argument passed to this
-* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
-* should be a valid core number within the VB. This hypercall sends a message
-* to a given hypervisor manager that provides virtual board managment service. 
-*
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVbSuspend
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: 
-*
-* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
-*/
-
-/*******************************************************************************
-*
-* vbiVbReset - Reset a virtual board's core
-*
-* This routine makes a hypercall in order to reset one or more cores that exist
-* within the specified virtual board. Calling this function puts the target core(s)
-* program counter to it's ENTRY function. The ENTRY function is determined based on
-* the loaded binary image. A core does not execute beyond it's ENTRY function
-* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
-* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
-* the third argument to this routine.  
-* The hypercall sends a message to a manager that provides VB managment services.
-* This function will return only after all victim cores are reset unless the
-* operation fails to complete. The order of which the victim cores are reset is not
-* determined. The second argument identifies the cores to perform the operation on.
-* The value of the second argument should be set to one of the following:
-*
-*\ms
-*\m -
-* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*\m -
-* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*\m -
-* A valid core number: Reset the specified core that exist within the Virtual Board.
-*\me
-*
-* The third argument argument passed to this function specifies options that are
-* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
-* one of the following or a combination:
-*
-*\ms
-*\m -
-* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images	
-*\m -
-* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
-*\me
-*
-*
-* IMPORTANT:
-* If a user chooses to restart core without reloading the executable image then
-* the data section must be restored to prevent critical errors. It is the guest OS's
-* responsibility to clear the bss data sections in such scenario.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbReset
-*    (
-*    vbiVb_t      id,	    /@ Id of the VB to suspend	    @/
-*    vbiCore_t     core,	    /@ Core within the VB	    @/
-*    uint32_t     options   /@ reload , start options	    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: 
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
-*/
-
-/*******************************************************************************
-*
-* vbiVbRestart - Restart a virtual board's core
-*
-* This routine makes a hypercall in order to restart a virtual cores from reset.
-* It's called to start running a core or cores that were previously reset by
-* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
-* function retrieved from the corresponding binary image.
-* This function will return only after  all cores are out of reset unless the
-* operation fails to complete.  The second argument represents the cores to restart. 
-* For restarting every core in reset mode within the specified VB the second
-* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
-* VB then the core number must be passed in the second argument.
-*
-* This hypercall sends a message to a manager that provides VB managment
-* services. 
-* 
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbRestart
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: 
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
-*/
-
-/*******************************************************************************
-*
-* vbiVbResume - Resume a virtual board's core
-*
-* This routine makes a hypercall in order to resume one or cores within
-* the specified virtual board. It reactivates a cores or cores that were 
-* previously suspended by calling vbiVbResume(). This function will return only
-* after all victim cores are resumed unless the operation fails. The order of
-* which the cores are resumed is not determined. The second argument may a
-* magic number instead of a valid core number to indicate that the operation
-* is intended for more than one core. For resuming every core within the
-* specified VB then the second argument is set to be equal to VBI_VB_CORES_ALL.
-* This implies to resume every core within the specified VB. Using this option
-* when some of the cores within the VB are already running is not considered
-* as programming error.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbResume
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB		@/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: 
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend() 
-*/
-
-/*******************************************************************************
-*
-* vbiKputs - print a string on the hypervisor kernel console
-*
-* This routine makes a hypercall and prints a string of characters to to
-* hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiKputc() 
-*/
-
-/*******************************************************************************
-*
-* vbiKputc - print a character on the hypervisor kernel console
-*
-* This routine makes a hypercall in order to print the specified character to
-* hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiKputc (int c) /@ character to print @/
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiKputs()
-*/
-
-/*******************************************************************************
-*
-* vbiPanic - halt the system and dump debug info 
-*
-* This routine makes a hypercall in order to halt the system and display debug
-* information on hypervisor console. If hypervisor is configured with
-* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
-* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
-* the offending cores registers dump is displayed on hypervisor console. If
-* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
-* the debug manager.
-*
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiPanic (const char *msg) /@ pointer to message to print @/
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-/*******************************************************************************
-*
-* vbiDebugShellStart - start the hypervisor debug shell
-*
-* This routine sends a message to the hypervisor debug shell manager in order to
-* start the WRHV shell program. The shell program spins therefore does not share
-* the processor with any other WRHV context. By default a caller of this routine 
-* is detached to allow the caling core to continue executing (as long as the are not
-* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
-* specified to force the caller virtual board core to block while the shell program
-* is running. 
-*
-* SYNOPSIS
-*\cs
-*
-* void vbiDebugShellStart 
-*          (
-*          uint32_t  flags /@ detach by default @/
-*          ) 
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*/
-
-/*******************************************************************************
-*
-* vbiVbMemoryRead - Read a virtual board's memory
-*
-* This routine makes a hypercall to read a remote board's memory. The memory control
-* structure contains information about the target memory to read and the destination
-* buffer that hypervisor must populate with the data read. This routine is used
-* to copy data from a remote VB. It is the user's responsability to ensure that
-* the memory read is accessed orthogonally.
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-*
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	    @/
-*   void	*pAddress;	    /@ address of calling context	    @/
-*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
-*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
-*   uint32_t	reserved;	    /@ reserved for future use		    @/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbMemoryRead 
-*	(
-*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
-*	vbiVb_t	    targetBoard	    /@ target board				@/
-*	)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-/*******************************************************************************
-*
-* vbiVbMemoryWrite - copy data to a remote board's memory
-*
-* This routine makes a hypercall to copy to a remote board memory. If the
-* VBI_DCACHE_FLUSH is set in the control memory control structure then this
-* routine flushes the data caches lines corresponding to the range of memory
-* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
-* cache lines corresponding to the range of address is invalidated after the
-* memory is copied. Invalidating the instruction is required if data containing
-* is updated since the instruction cache is not aware of the content in data
-* cache. Therefore flushing the data cache ensures that memory contains the
-* updated data and invalidating the instruction cache ensures that the stale
-* values in the instruction cache is thrown away. 
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-* 
-* 
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	@/
-*   void	*pAddress;	    /@ address of calling context	@/
-*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
-*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
-*   uint32_t	flags;		    /@ data/instruction flush option	@/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbMemoryWrite 
-*	(
-*	VBI_MEM_CTL	*memCtl, 
-*	vbiVb_t		targetBoard 
-*	)
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-/*******************************************************************************
-*
-* vbiMemAttrSet - Set protection for a page of memory
-*
-* This routine makes a hypercall to set the MMU attribures for the specified
-* memory range. The possible attributes one or a combinarion of the following:
-* 
-* VBI_MMU_PROT_READ -  allow supervisor and user read
-* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
-* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiMemAttrSet 
-*		(
-*		void	 *gaddr,	/@ Address of page to change attr   @/
-*		size_t   length,	/@ length of address		    @/
-*		uint32_t attr		/@ mmu attributes to set	    @/
-*		)
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-/******************************************************************************
-*
-* vbiMemAttrGet - Get MMU page protections
-*
-* This routine makes a hypercall to retrieve the MMU attributes associated for
-* the page where the specified address is mapped. This is not the VMMU
-* attributes. A guest OS has direct access to the mapping table of its VMMU
-* therefore a hypercall is not necessary.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiMemAttrGet 
-*		(
-*		void	 *gaddr		/@ Address of page to change attr   @/
-*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
-*		)
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicVectorSet - Set a vector for the specified irq entry
-*
-* This routine sets a vector for the specified entry in the VIOAPIC redirection
-* table. The previous entry in the table is trashed. Before setting the new
-* vector in the entry the user can obtain the previous entry by calling 
-* vbiVioapicVectorGet(). The first argument passed to this function represent
-* the index to the VIOAPIC redirection table. The second argument is the vector
-* to set in the specified entry. 
-* For Intel architectures when an interrupt is raised the vector determines the
-* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
-*
-* This routine is currently not supported for PPC.  
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*\cs
-* 
-*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicVectorGet - Get a vector in the specified irq entry
-*
-* This routine gets a vector for the specified entry in the VIOAPIC table in
-* VIOAPIC redirection table. It may be used for saving the previous entry
-* before setting a new vector in the specified entry. This takes as an argument
-* the irq number that corresponds to the redirection table offset. 
-*
-* This routine is currently not supported for PPC 
-* This routine is currently not supported for MIPS.  
-* 
-* SYNOPSIS
-*\cs
-* 
-* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: vector number or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntMask - Mask an irq 
-*
-* This routine disables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
-* VIOAPIC redirection table is set to 1. After calling this function hypervisor
-* will deliver this IRQ only if this IRQ is enabled by calling
-* vbiVioapicIntUnmask(). 
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
-*
-* This routine enables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC redirection table. This routine makes a hypercall in order to
-* deliver pending interrupts that might be queued while the irq was masked.
-* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
-* masked. Then clears the mask bit in the VIOAPIC redirection table for the
-* specified IRQ directed to the calling virtual Core.
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntSend - Send an interrupt
-*
-* This routine makes a hypercall to trigger an IRQ to one or more virtual board
-* that are connected to the line. The first argument passed to this function
-* specifies the IRQ number. The second argument specifies the filter to apply
-* to the list of virtual  boards connected to the IRQ. The third argument is
-* applicable only when VBI_IOAPICSEND_UNICAST filter is specified.
-*
-* In a SMP system a virtual board may have more than one core. If an IRQ is
-* sent to such system hypervisor will deliver the interrupt to the core that
-* was configured to receive the IRQ. The configuration is provided in the board
-* XML configuration file as the example shown below. 
-*
-*\cs
-*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*\ce
-*
-* The Vector number is not required to be specified in the XML. If not specified
-* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
-* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
-* 
-* The possible values for the filter (second argument) may be:
-*
-*\ms
-*\m -
-* VBI_IOAPICSEND_ALL	- Send to the group of virtual boards connected to this
-*                         IRQ include the sender board.
-*\m -
-* VBI_IOAPICSEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
-*                         excluding the sender board
-*\m -
-* VBI_IOAPICSEND_UNICAST	- Send an interrupt to the specified virtual board. This
-*		          will be delivered only if the destination board is
-*                         connected to this IRQ 
-*			  
-*\m -
-* VBI_IOAPICSEND_NONE	- Ignore this call.
-*
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntSend 
-*             (
-*             vbiIrq_t irq, 
-*             uint32_t filter,
-*             vbiVb_t target 
-*             )
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
-*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntAck - Acknowledge an irq 
-*
-* This routine acknowledges the specified IRQ for the running core. Calling 
-* this routine causes Hypervisor to purge any pending interrupt that arrived
-* while the acknowledgement was pending. When a virual board receives an interrupt
-* it must call this function. Otherwise Hypervisor will block subsequent interrupt
-* for the same IRQ. Exceptions are not required to be acknowledged.
-*
-* This routine is currently not supported for MIPS.  
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVioapicIntRedirect - Redirect an irq to another core
-*
-* This routine makes a hypercall to redirect an irq from one core to another
-* within the same virtual board. 
-*
-* This routine is currently not supported for MIPS.   
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
diff --git a/kernel/vbiMsg.c b/kernel/vbiMsg.c
deleted file mode 100644
index 2104db6..0000000
--- a/kernel/vbiMsg.c
+++ /dev/null
@@ -1,153 +0,0 @@
-/* vbiMsg.c - vbi Message library */
-
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01b,08sep09,mmi  update comments
-01a,2sep09,mmi written
-*/
-
-/*
-
-DESCRIPTION
-VBI message library routines.
-
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <vbi/vbiPrv.h>
-#else
-#include <vbi.h>
-#include <vbiPrv.h>
-#endif /* CONFIG_WRHV */
-
-#define DEBUGM(fmt, args...) 
-#define _DEBUGM(fmt, args...) kprintf(fmt, ##args)
-
-/*******************************************************************************
-*
-* vbiReceive - Receive a message from another context
-*
-* This routine makes a hypercall and waits for a message to be received from
-* another context. It blocks until a message is received. This operation may
-* be aborted if an interrupt is delivered to the waiting Virtual board. If the
-* "flags" field in the control structure passed to this function is set to be 
-* VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
-* aborted before the expected message was received successfully.   
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiCtx_t vbiReceive
-*    (
-*    void *       smsg,  /@ pointer to message to receive  @/
-*    size_t       len,   /@ length of message to receive   @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*\ce
-*
-* RETURNS: sender context Id or an error number in case of failure
-*	   OK - in case of success
-*	   ERROR - in case of error	    
-* ERRNO: N/A
-*
-* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
-*/
-
-vbiStatus_t vbiReceive
-    (
-    void		*rmsg, /* pointer to message to receive  */
-    uint32_t		rlen,  /* length of message to receive   */
-    VBI_MSG_INFO	*info, /* status info structure pointer  */
-    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
-    )                                   
-    { 
-    vbiStatus_t retVal;
-
-    while (1)
-	{
-	retVal = vbiReceiveOp(rmsg, rlen, info, ctl);
-
-        /* if retry flag set, continue */
-
-	if ((ctl->flags & VBI_MSG_CTL_FLAG_RETRY) != VBI_MSG_CTL_FLAG_RETRY)
-	    break;
-
-        /* if retry flag is set _AND_ msg was aborted, retry */
-	if (info->error != VBI_MSG_ERROR_ABORTED)
-	    break;
-	
-	DEBUGM("%s aborted, retrying \n", __FUNCTION__);
-
-	}
-    return retVal;
-    }
-
-/*******************************************************************************
-*
-* vbiReply - Reply to message received from another context
-*
-* This routine makes a hypercall in order to reply to a message received from
-* another context. A message is received from remote context by calling
-* vbiReceive(). The reply will unblock the recipient which may preempt
-* the caller.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiReply
-*    (
-*    vbiCtx_t   id,    /@ context id to reply the message to @/
-*    void *       buff,  /@ pointer to reply message  @/
-*    size_t       len,   /@ length of message to reply   @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
-*/
-
-/*******************************************************************************
-*
-* vbiSend - Send a message to another context
-*
-* This routine makes a hypercall to send a message to the specified context and
-* waits for a reply.  The caller will block until the sender replies to the sent
-* message.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiSend
-*    (
-*    vbiCtx_t     id,    /@ context id to send the message to @/
-*    void *       smsg,  /@ pointer to message to send        @/
-*    size_t       slen,  /@ length of message to send         @/
-*    void *       rmsg,  /@ pointer to receive message buffer @/
-*    size_t       rlen,  /@ length of receive message         @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
-*/
diff --git a/kernel/vbiNs.c b/kernel/vbiNs.c
deleted file mode 100644
index 4353a07..0000000
--- a/kernel/vbiNs.c
+++ /dev/null
@@ -1,173 +0,0 @@
-/* wrhvNs.c - hypervisor naming service, client side interface */
-
-/*
- * Copyright (c) 2008 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01g,18jul09,mmi  fix return types in vbNsXX() definition and comments
-01f,06jul09,mmi  add vbiPrv.h
-01e,21may09,mmi  update api descriptions
-01d,11dec08,md   rename header files
-01c,11dec08,md   rename of ns header files
-01b,19nov08,md   change in message passing API
-01a,03nov08,md   written
-*/
-
-/*
-DESCRIPTION
-
-This module implements a the client side of a simple naming service for the
-internal thread managers of the hypervisor.
-
-The interfaces formulate a message request and send it to the naming service
-for processing.
-
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/string.h>
-#include <vbi/vbi.h>
-#include <vbi/vbiPrv.h>
-#else
-#include <string.h>
-#include <vbi.h>
-#include <vbiPrv.h>
-#endif /* CONFIG_WRHV */
-
-
-/* enable/disable debugging */
-
-/*
- * #define DEBUG  define DEBUG to turn on debugging 
- */
-
-#ifdef DEBUG
-#define DEBUGM(fmt, args...)    kprintf(fmt, ##args)
-#else
-#define DEBUGM(fmt, args...)   
-#endif
-
-/*******************************************************************************
-*
-* vbiNsRegister - register a service with the naming system
-*
-* This routine registers us as the provider of the specified service.
-* A message for the request is formulated and sent off to the name service
-* manager for processing.
-*
-* SYNOPSIS
-*\cs
-* C FUNCTION
-* vbiStatus_t vbiNsRegister 
-*    (
-*    char    *name,		/@ name of service we're registering	@/
-*    uint32_t revision		/@ version of service			@/
-*    )
-*\ce                                                                 
-* RETURNS: OK, or errno if unable to register the service
-*
-* SEE ALSO: vbiNsLookup(), vbiNsUnregister()
-*
-*/
-
-vbiStatus_t vbiNsRegister
-    (
-    char    *name,	/* name of service we're registering */
-    uint32_t revision	/* version of service */
-    )
-    {
-
-    /* sanity check */
-
-    if (name == NULL)
-	return ERROR;
-
-    return (vbiNsOp (VBI_NS_REGISTER, name, revision, NULL));
-    }
-
-/*******************************************************************************
-*
-* vbiNsUnegister - un-register a service with the naming system
-*
-* This routine removes us as the provider of the specified service.
-* A message for the request is formulated and sent off to the name service
-* manager for processing.
-*
-* SYNOPSIS
-*\cs
-* C FUNCTION
-* vbiStatus_t vbiNsUnregister 
-*    (
-*    char    *name,		/@ name of service we're unregistering	@/
-*    uint32_t revision		/@ version of service			@/
-*    )
-*\ce                                                                 
-*
-* RETURNS: OK, or errno if unable to un-register the service
-*
-* SEE ALSO: vbiNsLookup(), vbiNsRegister()
-*
-*/
-
-vbiStatus_t vbiNsUnregister
-    (
-    char    *name,	/* name of service we're un-registering */
-    uint32_t revision	/* version of service */
-    )
-    {
-
-    /* sanity check */
-
-    if (name == NULL)
-	return ERROR;
-    
-    return (vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL));
-    }
-
-/*******************************************************************************
-*
-* vbiNsLookup - look up a service provider using the naming system
-*
-* This routine uses the naming system to look up the context id of the
-* provider of the specified service.  A message for the request is
-* formulated and sent off to the name service manager for processing.
-*
-* SYNOPSIS
-*\cs
-* C FUNCTION
-* vbiStatus_t vbiNsLookup 
-*    (
-*    char    *name,		/@ name of service we're unregistering	@/
-*    uint32_t revision		/@ version of service			@/
-*    VBI_NS_HANDLE *handle	/@ handle of service provider		@/
-*    )
-*
-* RETURNS: 
-*   ERROR is case of failure
-*
-* SEE ALSO: vbiNsRegister(), vbiNsUnregister()
-*
-*/
-
-vbiStatus_t vbiNsLookup
-    (
-    char     *name,	    /* name of service we're un-registering */
-    uint32_t  revision,	    /* version of service			*/
-    VBI_NS_HANDLE *handle   /* handle of service provider		*/
-    )
-    {
-    
-    /* sanity check */
-
-    if (name == NULL || handle == NULL)
-	return ERROR;
-
-    return (vbiNsOp (VBI_NS_LOOKUP , name, revision, handle));
-    }
diff --git a/kernel/vbiPaddr.c b/kernel/vbiPaddr.c
deleted file mode 100644
index 44145a3..0000000
--- a/kernel/vbiPaddr.c
+++ /dev/null
@@ -1,119 +0,0 @@
-/* vbiPaddr.c - translate virtual address to a physical address */
-
-/*
- * Copyright (c) 2008 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01h,12aug09,dtr  Add vbiGuestDmaAddrGet and change name of vbiVirtToPhys to be
-                 vbiGuestPhysToPhys.
-01g,09jun09,mmi  rename physAddr_t to vbiPhysAddr_t
-01f,25may09,mmi  fix function prototype to use  physAddr_t for the physical
-                 address
-01e,15may09,mmi  fix apigen errors
-01d,23jan09,mmi  fix included header file
-01c,13dec08,mmi  replace vbiSyscalls.h with vbiSyscall.h
-01b,19nov08,mmi  introduced the VBI terminology
-01a,18apr08,md   written
-*/
-
-/*
-DESCRIPTION
-These modules provide interfaces to translate the current context's guest
-physical address into the physical machine address. vbiGuestDmaAddrGet is 
-specifically for a guest wanting an address that can be used by a DMA device.
-vbiGuestPhysToPhysAddr is used to return an absolute physical address to used 
-perhaps to communicate with the hypervisor itself maybe buffer pointers.
-*/
-
-/* includes */
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <vbi/vbiPrv.h>
-#else
-#include <vbi.h>
-#endif /* CONFIG_WRHV */
-
-
-/*******************************************************************************
-*
-* vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical 
-*                          address
-*
-* This function makes a hypervisor call to translate the specified guest 
-* physical address to physical address. This may be required for quick buffer 
-* transfer that requires the physical address of a memory region. The 
-* hypervisor may be running with > 4GB memory so the phys address is always 
-* 64-bit.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiGuestPhysToPhysAddr 
-*		(
-*		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
-*		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
-*               )
-*\ce
-*
-* RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
-* populated by the hypervisor with the required physical address (64-bit)
-*
-* ERRNO: N/A
-*
-*/
-vbiStatus_t vbiGuestPhysToPhysAddr
-    (
-    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    )
-    {
-
-    /* use the hypervisor ioctl system call to do the translation */
-
-    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 ));
-    }
-
-/*******************************************************************************
-*
-* vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
-*
-* This function makes a hypervisor call to translate the specified guest 
-* physical address  to a physical address. This may be required for a device 
-* driver that requires the address it can use for DMA. The hypervisor may be 
-* running with > 4GB memory so the phys address is always 64-bit.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiGuestDmaAddrGet 
-*		(
-*		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
-*		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
-*               )
-*\ce
-*
-* RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
-* populated by the hypervisor with the required physical address (64-bit)
-*
-* ERRNO: N/A
-*
-*/
-vbiStatus_t vbiGuestDmaAddrGet
-    (
-    vbiGuestPhysAddr_t gaddr,	/* virtual address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    )
-    {
-
-    /* use the hypervisor ioctl system call to do the translation */
-
-    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0));
-    }
diff --git a/kernel/vbiShmem.c b/kernel/vbiShmem.c
deleted file mode 100644
index f2eb7a3..0000000
--- a/kernel/vbiShmem.c
+++ /dev/null
@@ -1,220 +0,0 @@
-/* vbiShmem.c - shared memory utility functions */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01m,03sep09,mmi  use _vbiStrncmp() for comparing strings
-01l,26aug09,mmi  fix WIND00178026: update copyright date
-01k,14jul09,mmi  fix private memory base get
-01j,03jul09,mmi  add private memory utility function
-01i,25may09,mmi  introduce vbiAttr_t for memory region attributes
-01h,22may09,mmi  revert to previous type function argument
-01g,15may09,mmi  fix apigen errors
-01f,17dec08,mmi  Use the correct number of memory region
-01e,12dec08,mmi  replace VB_MAX_RAZOR with VB_MAX_WRHV
-01d,11dec08,mmi  include vbi.h by default
-01c,19nov08,mmi  removed duplicate definition and rename functions to vbiXXX
-01b,23nov07,foo  fix includes
-01a,09may07,foo  written
-*/
-
-/*
-DESCRIPTION
-This module contains the code for retriving the memory regions assigned to
-a virtual board. The information is passed in to the virtual board via the
-configuration structure. There is a descriptor table for each type of memory.
-
-\sh MEMORY TYPES
-\ms
-\m -
-There is a memory memory region assigned only to each board which can be
-retrieved by calling vbiMemRegionFind().
-\m -
-There is a shared memory which may be shared with other boards in the
-system. The shared memory can be retrieved by using vbiShmemRegionFind()
-
-\m -
-Each core in the system is assigned a private memory region. The base address
-and the length of this region may obtained by calling vbiCorePrvMemFind ()
-Alternatively the following macros can be used to obtained similar information
-    - 
-    -
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <linux/string.h>
-#include <linux/module.h>
-#include <vbi/vbi.h>
-#include <vbi/vbiPrv.h>
-#else
-#include <string.h>
-#include <vbi.h>
-#include <vbiPrv.h>
-#endif /* CONFIG_WRHV */
-
-/******************************************************************************
-*
-* vbiShmemRegionFind - locate the shared memory parameters for a given region
-*
-* This function finds the shared memory region associated with the name 
-* specified. The first argument to this function indicates the name of the
-* shared to find. If this region exists in the list of configured regions the
-* address, length and MMU attributes are set in the pointers passed in as 
-* arguments.
-* 
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiShmemRegionFind
-*   (
-*   const char *    smName,	/@ String name of the region    @/
-*   void * *	    addr,	/@ Location - OUT		@/
-*   size_t *	    length,	/@ Length - OUT			@/
-*   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
-*    )
-*\ce
-*
-* RETURNS: OK or an errror number in case of failure
-*
-* ERRNO:                                
-*
-* SEE ALSO: vbiMemRegionFind() 
-*/
-
-vbiStatus_t vbiShmemRegionFind
-    (
-    int8_t *         smName,      /* String name of the region */
-    void * *       addr,        /* Location - OUT */
-    uint32_t * length,      /* Length - OUT */
-    uint32_t * attr         /* MMU Attributes - OUT */
-    )
-    {
-    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
-    VB_SM_INFO * info = config->sharedMemoryRegionsConfigAddress;
-    int32_t          num  = config->numSm;
-    int32_t          i;
-
-    for (i = 0; i < num; i++, info++)
-        {
-        if (!_vbiStrncmp ((char *)smName, (char *)info->name, 
-	    VB_MAX_WRHV_NAME_LENGTH))
-            {
-            /* Found */
-            *addr   = info->addr;
-            *length = info->length;
-            *attr   = info->attr;
-            return (OK);
-            }
-        }
-    *addr = 0;
-    return (VBI_INVALID_SHMEM);
-    }
-
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(vbiShmemRegionFind);
-#endif /* CONFIG_WRHV */
-
-/******************************************************************************
-*
-* vbiMemRegionFind - locate the memory parameters for a given region
-*
-* This function finds the memory region associated with the name specified. 
-* The first argument to this function indicates the name of the memory to find
-* If this region exists in the list of configured regions the address, 
-* length and MMU attributes are set in the pointers passed in as
-* arguments.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiMemRegionFind
-*   (
-*   const char *    name,   /@ String name of the region    @/
-*   void * *	    addr,   /@ Location - OUT		    @/
-*   size_t *	    length, /@ Length - OUT		    @/
-*   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* RETURNS: None
-*
-*/
-
-vbiStatus_t vbiMemRegionFind
-    (
-    int8_t   *	    name,	/* String name of the region  */
-    void   * *	    addr,	/* Location - OUT		    */
-    uint32_t    *length,	/* Length - OUT		    */
-    uint32_t *	    attr	/* MMU Attributes - OUT	    */
-    )
-    {
-    VB_CONFIG *  config = VBI_CONFIG_ADDR_GET();
-    VB_MEM_INFO * info = config->memoryRegionsConfigAddress;
-    int32_t      num  = config->numMem;
-    int32_t      i;
-
-    for (i = 0; i < num; i++, info++)
-        {
-        if (!_vbiStrncmp ((char *)name, (char *)info->name,
-            VB_MAX_WRHV_NAME_LENGTH))
-            {
-            /* Found */
-            *addr   = info->addr;
-            *length = info->length;
-            *attr   = info->attr;
-            return (OK);
-            }
-        }
-    *addr = 0;
-
-    return (VBI_INVALID_SHMEM);
-    
-    }
-
-/******************************************************************************
-*
-* vbiCorePrvMemFind - locate the private memory for a core
-*
-* This function gets the base address of the private memory region assigned to
-* the running core. 
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiCorePrvMemFind 
-*   (
-*   void * *    addr,	    /@ Location - OUT		    @/
-*   size_t *	length	    /@ Length - OUT		    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* RETURNS: None
-*
-*/
-
-vbiStatus_t vbiCorePrvMemFind 
-    (
-    void * *       addr,      /* Location - OUT */
-    size_t *     length       /* Length - OUT */
-    )
-    {
-
-    *addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
-    *length = VBI_VCORE_PRIVMEM_SIZE_GET();
-    
-    return (OK);
-    }
-
diff --git a/kernel/vbiShow.c b/kernel/vbiShow.c
deleted file mode 100644
index c0a7111..0000000
--- a/kernel/vbiShow.c
+++ /dev/null
@@ -1,327 +0,0 @@
-/* vbiShow.c - virtual board data show functions */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01l,06aug09,dtr  Modify status intPending to intPendingType.
-01k,04jun09,md   add core number to interrupt display
-01j,25may09,mmi  vbiShow should be the only published API
-01i,20may09,mmi  update function headers
-01h,29apr09,mpk  add Privileged OS VBI support
-01g,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
-01f,17apr09,mpk  supervisor VBI calls
-01e,11mar09,mmi  fix defect WIND00158420
-01d,22jan09,mmi  call show routines only if available
-01c,23dec08,mmi  call show routines for access registers
-01b,23dec08,mmi  make vbiMemoryShow non-static
-01a,19dec08,mmi  created based on vbShow version 01j
-*/
-
-/*
-DESCRIPTION
-
-The Virtual Board show functions display virtual board status,
-control and configuration data structures.
-
-*/
-
-#ifdef CONFIG_WRHV
-#define LONG_FMT "0x%lx"
-#define kprintf printk
-#include <linux/types.h>
-#include <vbi/vbi.h>
-#else
-#include <vbi.h>
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiSharedMemoryShow - print information about the shared memory configuration
-*
-* This routine traverse the array of shared memories descriptor for a given board
-* and displays the information on hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiSharedMemoryShow (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-* \NOMANUAL
-*/
-
-void vbiSharedMemoryShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_SM_INFO * p = config->sharedMemoryRegionsConfigAddress;
-    int          numSm = config->numSm;
-    void *       pState = config->sharedMemoryRegionsStateAddress;
-    int          i;
-
-    VB_PRINTF("%d Shared memory regions, Config at 0x%x:\n", numSm, p);
-
-    /* dump shared memory info if we have any attached */
-
-    for (i=0; i < numSm; i++,p++)
-        {
-	VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x)\n",
-		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
-		p->attr);
-        }
-
-    VB_PRINTF("Shared memory State at 0x%x:\n", pState);
-
-
-    }
-
-/*******************************************************************************
-*
-* vbiMemoryShow - print information about a board's  memory configuration
-*
-* This routine traverse the array of memory regions descriptor for a given board
-* and displays the information on hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiSharedMemoryShow (void)
-*
-*\ce
-*
-* RETURNS: returns OK or errno in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*
-*\NOMANUAL
-*/
-
-void vbiMemoryShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_MEM_INFO * p = config->memoryRegionsConfigAddress;
-    int          numSm = config->numMem;
-    int          i;
-
-    VB_PRINTF ("%d memory regions, Config at 0x%x:\n", numSm, p);
-
-    /* dump shared memory info if we have any attached */
-
-    for (i=0; i < numSm; i++,p++)
-        {
-	VB_PRINTF ("%8s: 0x%08x -> 0x%08x  (attr: 0x%x) (type: %s)\n",
-		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
-                p->attr, p->type);
-        }
-    }
-
-/*******************************************************************************
-*
-* vbiInterruptsShow - print information about a board's interrupts configuration
-*
-* This routine traverse the interrupts descriptors table for a given board and
-* displays the information on hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiInterruptsShow (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*\NOMANUAL
-*
-*/
-
-static void vbiInterruptsShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_INT_INFO * p = config->interruptConfiguration;
-    int           numInt = config->numInts;
-    int           i;
-
-    VB_PRINTF ("%d interrupt configurations, Config at 0x%x\n", numInt, p);
-
-    for (i = 0; i < numInt; i++, p++)
-        {
-	if (p->intDirection == VB_INPUT_INT)
-	    {
-	    VB_PRINTF ("%8s: Direction: In, Vector Number: %d, Core: %d\n",
-                p->intName, p->intNumber, p->intCore);
-	    }
-	else
-	    {
-	    VB_PRINTF ("%8s: Direction: Out, Vector Number: %d\n",
-                p->intName, p->intNumber);
-	    }
-        }
-    }
-
-/*******************************************************************************
-*
-* vbiStatusShow - print information about a board's status structures
-*
-* This routine displays information in the status structure for a given board.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiStatusShow (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*
-*\NOMANUAL
-*/
-
-void vbiStatusShow
-    (
-    VB_STATUS *p
-    )
-    {
-
-    VB_PRINTF ("VB status: 0x%x\n", p);
-
-    VB_PRINTF ("  Pending interrupts: 0x%08x\n", p->intPendingType);
-    VB_PRINTF ("  timestamp:          %lld\n", p->timeStamp);
-    VB_PRINTF ("  old int disable:    0x%08x\n", p->oldIntDisable);
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiStsRegsDisplay ();
-#endif
-    }
-
-/*******************************************************************************
-*
-* vbiControlShow - print information about a board's control structures
-*
-* This routine displays information in the control structure for a given board.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiControlShow (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*
-*\NOMANUAL
-*/
-
-void vbiControlShow
-    (
-    VB_CONTROL * p
-    )
-    {
-    int i;
-
-    VB_PRINTF ("VB control data: 0x%x\n", p);
-
-    VB_PRINTF ("  Disable interrupts:  0x%08x\n", p->intDisable);
-
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiCtrlRegsDisplay (); 
-#endif
-
-    VB_PRINTF ("  Disabled interrupts:");
-    for (i=0; i < VB_MAX_INTERRUPTS; i++)
-        {
-	if ((p->intLevelDisable & (1 << (32 - i))) != 0)
-            {
-	    VB_PRINTF (" %d", i);
-            }
-        }
-    VB_PRINTF ("\n");
-    }
-
-/*******************************************************************************
-*
-* vbiConfigShow - print information about a board's config structures
-*
-* This routine displays information in the config structure for a given board.
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiConfigShow (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*
-*/
-
-void vbiConfigShow
-    (
-    VB_CONFIG * p
-    )
-    {
-
-    VB_PRINTF ("VB config data: 0x%x\n", p);
-
-    VB_PRINTF ("pid:                %d\n",	    p->pid);
-    VB_PRINTF ("Board ID:           %d\n",	    p->boardID);
-
-    VB_PRINTF ("Status Address:     " LONG_FMT "\n", p->vbStatus);
-    VB_PRINTF ("Control Address:    " LONG_FMT "\n", p->vbControl);
-#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
-    VB_PRINTF ("Syscall Table Address:    " LONG_FMT "\n", p->vbSyscallTable);
-#endif
-    VB_PRINTF ("SupervisoryMode:    %d\n",	    p->supervisoryMode);
-
-    VB_PRINTF ("Board Name:         %s\n",	    p->boardName);
-    VB_PRINTF ("Board Type:         %d\n",	    p->boardType);
-    VB_PRINTF ("Physical Memory:    %d\n",     p->physicalMemorySize);
-    VB_PRINTF ("Memory Alias Addr:  0x%08x\n", p->memoryAliasAddress);
-    VB_PRINTF ("Memory Alias Size:  %u\n",     p->memoryAliasSize);
-    VB_PRINTF ("Reset PC:           0x%08x\n", p->resetPC);
-
-    VB_PRINTF ("Timer Frequency:     %d/sec\n",	    p->tickTimerFrequency);
-    VB_PRINTF ("TimeStamp Frequency: %dULL/sec\n",	    p->timeStampFrequency);
-
-    VB_PRINTF ("numInts:             %d\n",	    p->numInts);
-
-    vbiMemoryShow (p);
-    vbiSharedMemoryShow (p);
-    vbiInterruptsShow (p);
-
-    }
diff --git a/kernel/vbiVersion.c b/kernel/vbiVersion.c
deleted file mode 100644
index 74a838d..0000000
--- a/kernel/vbiVersion.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/* vbiVersion.c - creation version/date/time module */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River License agreement.
- */
-
-/*
-modification history
---------------------
-01b,03jul09,mmi  rename VB_VERSION_XX
-01a,16apr09,mmi  written 
-*/
-
-/*
-This module is always built with each executable image.  It provides
-the VBI version id, and the time and date it was built.
-
-The date stamp may be overriden by defining VBI_RUNTIME_CREATION_DATE. This
-will be primarily used by guest OS's that use VBI.
-
-The ANSI predefined macros __DATE__ and __TIME__ are used to provide
-the date/time information.  ANSI compliant compilers are required for
-building all hypervisor executables.
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <vbi/vbi.h>
-#include <vbi/vbiVersion.h>
-#else
-#include <vbi.h>
-#include <vbiVersion.h>
-#endif /* CONFIG_WRHV */
-
-/* numerical values for vbi version */
-
-const uint32_t vbiVersionMajor = VBI_VERSION_MAJOR;
-const uint32_t vbiVersionMinor = VBI_VERSION_MINOR;
-const uint32_t vbiVersionMaint = VBI_VERSION_MAINT;
-
-/* string identifiers for vbi version */
-
-const char *vbiRuntimeName       = VBI_RUNTIME_NAME;
-const char *vbiRuntimeVersion    = VBI_RUNTIME_VERSION;
-const char *vbiVersion		 = VBI_VERSION;
-
-#ifdef VBI_RUNTIME_CREATION_DATE
-const char *vbiCreationDate = VBI_RUNTIME_CREATION_DATE;
-#else
-const char *vbiCreationDate = __DATE__ ", " __TIME__;
-#endif
-
diff --git a/kernel/vbiVioApic.c b/kernel/vbiVioApic.c
deleted file mode 100644
index 7f74919..0000000
--- a/kernel/vbiVioApic.c
+++ /dev/null
@@ -1,620 +0,0 @@
-/* vbiVioapic.c - Virtual IO APIC library */
-
-/*
- * Copyright (c) 2008-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01o,26aug09,mmi  fix WIND00178023: vioapic unmask routine
-01n,13aug09,dtr  Update vbiVioapicIntAck docs and API.
-01m,18jul09,mmi  remove X86 from unmask
-01l,07jul09,mmi  turn off debugging by default
-01k,02jul09,mmi  update send api
-01j,16jun09,mmi  create vioapic structure
-01i,09jun09,mmi  update macros to access config structure
-01h,29mar09,mmi  set MASK properly
-01g,09apr09,mpk  hypervisor 64 bit changes to support mips cavium-octeon bsp
-01f,19mar09,mes  Fixed return values of VBI functions
-01e,24feb09,mmi  include vbiSyscall.h
-01d,22dec09,mmi  fix send function proto
-01c,13dec08,mmi  define structures locally
-01b,11dec08,mmi  replace razor with wrhvVb
-01a,10dec08,mmi created base on x86 version
-*/
-
-/* 
-DESCRIPTION 
-
-This module implements the Virtual IO APIC library
-*/
-
-/* includes */
-
-#ifdef CONFIG_WRHV
-#include <linux/types.h>
-#include <linux/module.h>
-#include <vbi/vbi.h>
-#include <vbi/vbiPrv.h>
-#define kprintf printk
-#else
-#include <vbi.h>
-#include <vbiPrv.h>
-#endif /* CONFIG_WRHV */
-
-/* globals */
-
-/* externs */
-
-/* defines */
-
-/* APIC register get/set macros  Accesses are double words using an
- * indirect addressing scheme.
- * Redirection table entry bits: lower 32 bit 
- */
-
-/* IO APIC Register Offset */
-
-#define VIOAPIC_REG_ID		0x00	/* IOAPIC ID */
-#define VIOAPIC_REG_VERS	0x01	/* IOAPIC Version */
-#define VIOAPIC_REG_ARB		0x02	/* IOAPIC Arbitration ID */
-#define VIOAPIC_REG_BOOT	0x03	/* IOAPIC Boot Configuration */
-#define VIOAPIC_REG_REDTBL	0x10	/* Redirection Table (24 * 64bit) */
-/* Redirection table entry size per IO APIC */
-
-#define VIOAPIC_MAX_REDTABLE_ENTRIES	128
-
-#ifndef OK
-#define OK  (0)
-#endif
-
-#if 0
-#define DEBUG
-#endif
-
-#ifdef DEBUG
-#define DEBUGM(fmt, arg...) kprintf(fmt, ##arg)
-#else
-#define DEBUGM(fmt, arg...)
-#endif
-/* IO APIC register get/set macros */
-/* Accesses are double words using an
- * indirect addressing scheme.
- */
-
-#define	VIOAPIC_REG_GET(base, offset)		\
-	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))))
-
-#define	VIOAPIC_REG_SET(base, offset, value)	\
-	(*((volatile uint32_t *)(((unsigned long *)(base)) + (offset))) = \
-	(value))
-
-/* data structures */
-
-/* IO APIC ID register */
-typedef union {
-    struct {
-	uint32_t reserved1:24;	/* reserved bits */
-	uint32_t IOAPIC_id:4;	/* apic id */
-	uint32_t reserved2:4;	/* reserved bits */
-    } field;
-
-    uint32_t value;
-} VIOAPIC_ID;
-
-
-/* IO APIC Version Register */
-
-typedef union {
-    struct {
-	uint32_t version:8;		/* version identifier */
-	uint32_t reserved1:8;		/* reserved bits */
-	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
-					 * number of IRQ pins - 1 */
-	uint32_t reserved2:8;		/* reserved bits */
-    } field;
-
-    uint32_t value;
-} VIOAPIC_VERSION;
-
-/* Virtual IO APIC redirection table entry. Split into high/low 32 */
-
-typedef union {
-    struct {
-	uint32_t reserved:24;	/* reserved bits */
-	uint32_t destination:8;	/* destination field */
-    } field;
-
-    uint32_t value;
-} VIOAPIC_REDIR_HIGH;
-
-typedef union {
-    struct {
-	uint32_t vector:8;	/* vector number */
-	uint32_t deliveryMode:3;/* delivery mode:
-				 * fixed, lowest, SMI, reserved, NMI, 
-				 * INIT, reserved, extInt */
-	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
-	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
-	uint32_t polarity:1;	/* polarity: 0=high active */
-	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
-				 * accepts level, 0 after EOI */
-	uint32_t trigger:1;	/* 0=edge, 1=level */
-	uint32_t mask:1;	/* 1=masked */
-	uint32_t reserved:15;	/* reserved bits */
-    } field;
-
-    uint32_t value;
-} VIOAPIC_REDIR_LOW;
-
-typedef struct vioapicEntry
-    {
-    VIOAPIC_REDIR_LOW   vioapicLow;
-    VIOAPIC_REDIR_HIGH  vioapicHigh;
-
-    } VIOAPIC_ENTRY;
-
-typedef struct vioapic
-    {
-    VIOAPIC_ID      id;
-    VIOAPIC_VERSION version;
-    uint32_t        arb;
-    uint32_t        boot;
-    uint32_t        reserved[6];
-    VIOAPIC_ENTRY   entry [128];
-    } VIOAPIC;
-
-/* forward declarations */
-
-/*******************************************************************************
- *
- * vbiVioapicAddrGet - Get VIOAPIC base address
- *
- * This routine gets the base address of the VIOAPIC specified in the VB
- * control structure.
- * 
- * RETURNS: the base address of the VB VIOAPIC base address
- *
- * \NOMANUAL
- */
-
-void * vbiVioapicAddrGet(void)
-    {
-    return(VBI_VIOAPIC_BASE_GET());
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicVectorSet - Set a vector for the specified irq entry
-*
-* This routine sets a vector for the specified entry in the VIOAPIC redirection
-* table. The previous entry in the table is trashed. Before setting the new
-* vector in the entry the user can obtain the previous entry by calling 
-* vbiVioapicVectorGet(). The first argument passed to this function represent
-* the index to the VIOAPIC redirection table. The second argument is the vector
-* to set in the specified entry. 
-* For Intel architectures when an interrupt is raised the vector determines the
-* Interrupt descriptor table (IDT) entry where the IRQ is delivered. 
-*
-* This routine is currently not supported for PPC.  
-*
-* SYNOPSIS
-*\cs
-* 
-*  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-vbiStatus_t vbiVioapicVectorSet
-    (
-    vbiIrq_t	irq,	/* descriptor table index */
-    vbiVector_t vector	/* the vector to set in the entry */
-    )
-    {
-    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq	*/
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
-    VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase, 
-		 &(pVioapic->entry[irq].value));
-
-    /* Set the vector at the vioapic entry */
-
-    pVioapic->entry[irq].vioapicLow.field.vector = vector;
-
-    return (OK);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicVectorGet - Get a vector in the specified irq entry
-*
-* This routine gets a vector for the specified entry in the VIOAPIC table in
-* VIOAPIC redirection table. It may be used for saving the previous entry
-* before setting a new vector in the specified entry. This takes as an argument
-* the irq number that corresponds to the redirection table offset. 
-*
-* This routine is currently not supported for PPC 
-* 
-* SYNOPSIS
-*\cs
-* 
-* vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: vector number or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
-*/
-
-vbiVector_t vbiVioapicVectorGet
-    (
-    vbiIrq_t	irq	/* descriptor table index */
-    )
-    {
-    volatile VIOAPIC *  pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-    vbiVector_t		vector;
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq	*/
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorGet: base @ 0x%x\n", vioapicBase);
-
-    /* Set the vector at the vioapic entry */
-
-    vector = pVioapic->entry[irq].vioapicLow.field.vector;
-
-    VB_DEBUG_MSG ("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
-
-    return (vector);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntUnmask - Unmask an irq for a virtual board 
-*
-* This routine enables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC redirection table. This routine makes a hypercall in order to
-* deliver pending interrupts that might be queued while the irq was masked.
-* Hypervisor delivers any pending IRQ that may have occurred while the IRQ was
-* masked. Then clears the mask bit in the VIOAPIC redirection table for the
-* specified IRQ directed to the calling virtual Core.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntUnmask 
-    (
-    vbiIrq_t irq
-    )
-    {
-    volatile VIOAPIC *   pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    DEBUGM("VIOAPIC base: 0x%x \n", pVioapic);
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* validate the irq number  */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    /* enable interrupt on VB */
-
-    return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
-    
-    }
-
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(vbiVioapicIntUnmask);
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiVioapicIntMask - Mask an irq 
-*
-* This routine disables the interrupt vector that matches the specified IRQ at
-* the VIOAPIC for the running core. The mask bit for the IRQ entry in the
-* VIOAPIC redirection table is set to 1. After calling this function hypervisor
-* will deliver this IRQ only if this IRQ is enabled by calling
-* vbiVioapicIntUnmask(). 
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntMask
-    (
-    vbiIrq_t irq
-    )
-    {
-    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-
-    /* check for null pointer */
-
-    if (pVioapic == NULL)
-	return (VBI_VIOAPIC_NULL);
-
-    /* check argument */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return ERROR;
-
-    /* set the mask bit */
-
-    pVioapic->entry[irq].vioapicLow.field.mask = 1;
-
-    return (OK);
-
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntAck - Acknowledge an irq 
-*
-* This routine acknowledges the specified IRQ for the running core. Calling 
-* this routine causes Hypervisor to purge any pending interrupt that arrived
-* while the acknowledgement was pending. When a virual board receives an interrupt
-* it must call this function. Otherwise Hypervisor will block subsequent interrupt
-* for the same IRQ. Exceptions are not required to be acknowledged.
-*
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntAck
-    (
-    vbiIrq_t    irq   /* table entry to modify (0-23) */
-    )
-    {
-    /* check argument */
-
-    if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
-        return VBI_VIOAPIC_IRQ_OUTBOUND;
-
-    return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicIntSend - Send an interrupt
-*
-* This routine makes a hypercall to trigger an IRQ to one or more virtual board
-* that are connected to the line. The first argument passed to this function
-* specifies the IRQ number. The second argument specifies the filter to apply
-* to the list of virtual  boards connected to the IRQ. The third argument is
-* applicable only when VIOAPIC_SEND_UNICAST filter is specified.
-*
-* In a SMP system a virtual board may have more than one core. If an IRQ is
-* sent to such system hypervisor will deliver the interrupt to the core that
-* was configured to receive the IRQ. The configuration is provided in the board
-* XML configuration file as the example shown below. 
-*
-*\cs
-*  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*\ce
-*
-* The Vector number is not required to be specified in the XML. If not specified
-* the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
-* number assigned to an IRQ by calling vbiIntVecFind("VECTOR_NAME").  
-* 
-* The possible values for the filter (second argument) may be:
-*
-*\ms
-*\m -
-* VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
-*                         IRQ include the sender board.
-*\m -
-* VIOAPIC_SEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
-*                         excluding the sender board
-*\m -
-* VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
-*		          will be delivered only if the destination board is
-*                         connected to this IRQ 
-*			  
-*\m -
-* VIOAPIC_SEND_NONE	- Ignore this call.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntSend 
-*             (
-*             vbiIrq_t irq, 
-*             uint32_t filter,
-*             vbiVb_t target 
-*             )
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
-*	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
-*
-* INTERNAL
-* Important!! ignore filter and target arguments for now.
-*/
-
-vbiStatus_t vbiVioapicIntSend
-    (
-    vbiIrq_t    irq,		/* irq number			*/
-    uint32_t	filter,		/* destination filter		*/
-    vbiVb_t	target		/* vb id if filter is unicast	*/
-    )
-    {
-    return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
-    }
-
-#ifdef CONFIG_WRHV
-EXPORT_SYMBOL(vbiVioapicIntSend);
-#endif /* CONFIG_WRHV */
-
-/*******************************************************************************
-*
-* vbiVioapicIntRedirect - Redirect an irq to another core
-*
-* This routine makes a hypercall to redirect an irq from one core to another
-* within the same virtual board. 
-* 
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
-*           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
-*/
-
-vbiStatus_t vbiVioapicIntRedirect 
-    (
-    vbiIrq_t    irq,		/* irq number			*/
-    vbiCore_t	core		/* vb id if filter is unicast	*/
-    )
-    {
-
-    /* call interrupt redirect operator */
-
-    return (vbiVcoreIntRed_op(irq, core));
-    }
-
-/*******************************************************************************
-*
-* vbiVioapicDisplay - display the virtual I/O APIC table
-*
-* \NOMANUAL
-*/
-
-void vbiVioapicDisplay (void)
-{
-    VIOAPIC_REDIR_LOW	regIoApicRedirLow;
-    VIOAPIC_REDIR_HIGH	regIoApicRedirHigh;
-    volatile VIOAPIC   * pVioapic = (volatile VIOAPIC *)VBI_VIOAPIC_BASE_GET();
-    uint32_t i;
-
-    static const char * deliveryModes[] = 
-        {" Fixed",	/* 0 */
-	 "Lowest",	/* 1 */
-	 "   SMI",	/* 2 */
-	 "  rsvd",	/* 3 */
-	 "   NMI",	/* 4 */
-	 "  INIT",	/* 5 */
-	 "  rsvd",	/* 6 */
-	 "ExtINT"};	/* 7 */
-
-    /* get the general virtual I/O APIC info */
-
-    VB_PRINTF ("Virtual I/O APIC:\n");
-    VB_PRINTF ("  Base address: 0x%p\n", pVioapic);
-    VB_PRINTF ("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
-    VB_PRINTF ("  version:     %d\n", pVioapic->version.field.version);
-    VB_PRINTF ("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
-
-    /* dump the virtual I/O APIC table */
-
-    VB_PRINTF ("\nRedirection Table:\n");
-    VB_PRINTF ("Entry Vector Mask Status Trig"
-		"  Pol IRR DeliverMode Destination\n");
-    VB_PRINTF (
-	"----- ------ ---- ------ ----- --- --- ----------- -----------\n");
-
-    for (i=0; i < VIOAPIC_MAX_REDTABLE_ENTRIES; i++) {
-
-	regIoApicRedirLow  = pVioapic->entry[i].vioapicLow;
-	regIoApicRedirHigh = pVioapic->entry[i].vioapicHigh;
-
-	VB_PRINTF (" %3.3d   %3.3d   %4s %6s %5s %3s  %1d     %6s   %6s %d\n",
-                i,
-                regIoApicRedirLow.field.vector,
-                regIoApicRedirLow.field.mask ? "MASK" : "none",
-                regIoApicRedirLow.field.delivStatus ? "PEND" : "idle",
-                regIoApicRedirLow.field.trigger ? "level" : "edge",
-                regIoApicRedirLow.field.polarity ? "lo" : "hi",
-                regIoApicRedirLow.field.irr,
-                deliveryModes[regIoApicRedirLow.field.deliveryMode],
-                regIoApicRedirLow.field.destMode ? "Set: " : "ID: ",
-                regIoApicRedirHigh.field.destination);
-    }
-    VB_PRINTF ("\n");
-}
diff --git a/kernel/vbiVmmuDoc.c b/kernel/vbiVmmuDoc.c
deleted file mode 100644
index 07ed871..0000000
--- a/kernel/vbiVmmuDoc.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/* vbiVmmuDoc.c - Virtual Board Interface VMMU APIs */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind RIver License agreement.
- */
-
-/*
-modification history
---------------------
-01b,03jul09,mmi  fix vbiVmmuEnable/Disable
-01a,31may09,mmi written
-*/
-
-/*
-DESCRIPTION
-The module contains the VBI VMMU supplement.
-The VMMU configuration structure is an essential data type to understand this
-module. It is the descriptor for an VMMU context with the following info:
-
-\ms
-\m -
- The VMMU page table base address 
-\m - 
- The VMMU pages
-\m -
- The page size granularity 
-\me 
-
- VMMU_CONFIG definition:
-
- typedef struct vmmuConfig
-    {
-    VMMU_LEVEL_1_DESC *addr;
-    size_t         pageSize;
-    uint32_t       reserved;
-    uint32_t       vmmu_num;
-    } VMMU_CONFIG;
-
- The vmmu virtual address space is restricted to 32 bits and is decoded using
- a level-1/level-2 page table.  The virtual address is decoded as follows:
-\cs
-
-
-
-                          32-bit Virtual Address
-        +---------------------------------------------------------+
-        |      L1 offset       | L2 offset |    Page offset       |
-        +---------------------------------------------------------+
-                11 bits           9 bits           12 bits
-                  |                 |
-                  |                 |
-    +-------------+                 |
-    |                               |
-    |                               |
-    |           L1 Table            |            L2 Table
-    |    2047 +----------+          |      511 +----------+
-    |         |          |          |          |          |
-    |         |          |          |          |          |
-    |         |          |          |          |----------|
-    |         |          |          |   +----->|    PTE   | 8 byte PTE
-    |         |          |          |   |      |----------|
-    |         |          |          |   |      |          |
-    |         |----------| 20 bits  |   |      |          |
-    +-------->|  L2 ptr  |----------+---+      |          |
-              |----------|                     |          |
-              |          |                     |          |
-              |          |                     |          |
-            0 +----------+                   0 +----------+
-               2 page (8KB)                    1 page (4KB)
-             2048 L2 pointers                 512 PTE entries
-
- Each page table entry is 8 bytes (2 words) and uses the following format:
-
- word 0 (32-bits):
-          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
-                                          6 7 8 9 0 1 2 3
-         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
-         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
-         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-
-                V          - valid bit
-                Hypervisor - reserved for use by hypervisor
-                U0-U7      - user defined attributes
-                ERPN       - extended real page number bits
-                ATTR       - page attributes
-
- word 1 (32-bits):
-
-          0                                19 20      23 2 2 2 2 2 2 3 3
-                                                         4 5 6 7 8 9 0 1
-         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
-         |                                   |          | | |X|X|W|W|R|R|
-         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-
-                RPN        - real page number
-                R          - page referenced bit
-                C          - page changed bit
-                SX,SW,SR   - supervisor mode protection bits
-                UX,UW,UR   - user mode protection bits
-\ce
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-*/
-
-
-/*******************************************************************************
-*
-* vbiVmmuConfig - configure the hypervisor virtual MMU
-*
-* This makes a hypercall in order to register a context's  virtual MMU within
-* the hypervisor using a fast hypercall. To enable the newly configured VMMU the
-* user must vbiVmmuEnable(). This funtion takes a pointer to a VMMU
-* configuration structure. 
-* Whenever the VMMU state is changed, the vbiVmmuConfig() operation will flush
-* the TLB entries to ensure consistency between the processor and the page tables.
-* 
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVmmuConfig (VMMU_CONFIG * pVmmuConfig) /@ config pointer @/
-*
-*\ce
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuEnable(), vbiVmmuDisable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuEnable - Enable virtual MMU
-*
-* This routines enables the context's virtual MMU within the hypervisor using a
-* fast hypercall. Before calling this routine one must ensure to configure the
-* VMMU page table, map all necessary memory regions, initialize the VMMU
-* configuration and register it by calling vbiVmmuConfig(). Once the VMMU
-* is enabled any memory access is translated via the VMMU page tables. The
-* argument passed to this routine is the VMMU index. Currently hypervisor
-* supports only one VMMU therefore the index is always zero.
-*
-* Special care must taken to ensure that the executed code and data regions
-* accessed are mapped. It is suggested that any data regions shared with 
-* Hypervisor is idendity mapped (flat mapping or 1-1 translation).
-* 
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVmmuEnable (vbiVmmuIndex_t vmmuIndex) /@ vmmu Handle @/
-*
-*\ce
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuDisable - Disable VMMU for running core
-*
-* This routines disables the core's VMMU within the hypervisor using a 
-* hypercall. The argument passed to this routine is the VMMU index. Currently
-* hypervisor supports only one VMMU therefore the index is always zero. 
-*
-* This is equivalent to calling vbiVmmuConfig(vbiVmmuIndex_t, NULL). 
-*
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVmmuDisable (VBI_VMMU_HANDLE vmmuHandle) /@ vmmu handle @/
-*
-*\ce
-*
-* RETURNS: returns OK or error in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuTlbFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiVmmuTlbFlush - Flush TLB entries for a range of address
-*
-* This routine flushes the TLB entries for the specified address range from 
-* the virtual MMU.
-* The vbVmmuTlbFlush function is used to ensure that any VMMU translations for
-* the specified address range are cleared from the processor.s TLB cache.
-* All page translations starting at address for a length of length bytes in the
-* specified vmmu context will be cleared from the TLB cache
-*
-* SYNOPSIS
-*\cs
-* 
-*
-* vbiStatus_t vbiVmmuTlbFlush
-*		( 
-*		VMMU_CONFIG *config,	/@ The VMMU configuration to use @/
-*		void	    *addr,	/@ Starting address              @/
-*		size_t	    len)	/@ length                        @/
-*		)
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuDisable(), vbiVmmuEnable()
-*/
diff --git a/kernel/wrhv.c b/kernel/wrhv.c
deleted file mode 100644
index ae88409..0000000
--- a/kernel/wrhv.c
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2, or (at your option) any
- *  later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  Copyright (C) 2008 Wind River Systems, Inc.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/profile.h>
-#include <linux/kernel_stat.h>
-#include <linux/wrhv.h>
-#include <linux/sched.h>
-#include <vbi/vbi.h>
-
-#define VIOAPIC_BASE_ADDR      (&wrhvVbControl->vIoapic)
-
-static uint32_t vioapic_reg_read(uint8_t offset)
-{
-	uint32_t reg;
-	reg = VIOAPIC_REG_GET(VIOAPIC_BASE_ADDR, offset);
-	return reg;
-}
-
-static void vioapic_reg_write(uint8_t  offset, uint32_t value)
-{
-	VIOAPIC_REG_SET(VIOAPIC_BASE_ADDR, offset, value);
-}
-
-static void wrhv_enable_vector(unsigned int vector)
-{
-	uint32_t curr, offset;
-
-	offset = VIOAPIC_REG_REDTBL + vector*2;
-	curr = vioapic_reg_read(offset);
-	curr &= ~VIOAPIC_INT_MASK;
-	vioapic_reg_write(offset, curr);
-}
-
-static void wrhv_disable_vector(unsigned int vector)
-{
-	uint32_t curr, offset;
-
-	offset = VIOAPIC_REG_REDTBL + vector*2;
-	curr = vioapic_reg_read(offset);
-	curr |= VIOAPIC_INT_MASK;
-	vioapic_reg_write(offset, curr);
-}
-
-static void wrhv_enable_irq(unsigned int irq)
-{
-	vbiVioapicIntUnmask(irq);
-}
-
-static void wrhv_disable_irq(unsigned int irq)
-{
-	vbiVioapicIntMask(irq);
-}
-
-static void wrhv_ack_irq(unsigned int irq)
-{
-	vbiVioapicIntAck(irq);
-}
-
-static void wrhv_maskack_irq(unsigned int irq)
-{
-	if (irq != 0)
-		vbiVioapicIntMask(irq);
-	vbiVioapicIntAck(irq);
-}
-
-static void wrhv_mask_irq(unsigned int irq)
-{
-	if (irq != 0)
-		vbiVioapicIntMask(irq);
-}
-
-static void wrhv_unmask_irq(unsigned int irq)
-{
-	if (irq != 0)
-		vbiVioapicIntUnmask(irq);
-}
-
-struct irq_chip wrhv_irq_chip = {
-	.name		= "WRHV-PIC",
-	.mask		= wrhv_mask_irq,
-	.ack		= wrhv_ack_irq,
-#ifndef CONFIG_X86
-	.disable	= wrhv_disable_irq,
-	.enable		= wrhv_enable_irq,
-#endif
-	.unmask		= wrhv_unmask_irq,
-	.mask_ack	= wrhv_maskack_irq,
-	.eoi		= wrhv_ack_irq,
-};
-
-unsigned long wrhv_calculate_cpu_khz(void)
-{
-	printk(KERN_DEBUG "WRHV: Timestamp Frequency %u Hz\n",
-		wrhvVbConfig->timeStampFrequency);
-	return wrhvVbConfig->timeStampFrequency / 1000;
-}
-
-irqreturn_t __weak wrhv_timer_interrupt(int irq, void *dev_id)
-{
-	static long long mark_offset;
-	long long ticks;
-	int lost_jiffies = 0;
-	struct pt_regs *regs = get_irq_regs();
-
-	ticks = wrhvVbStatus->tickCount;
-	ticks -= mark_offset;
-	lost_jiffies = ticks - 1;
-	mark_offset = wrhvVbStatus->tickCount;
-
-	do {
-		do_timer(1);
-		update_process_times(user_mode(regs));
-		profile_tick(CPU_PROFILING);
-		if (lost_jiffies > (2*HZ)) {
-			printk(KERN_DEBUG "Time falling behind %d jiffies\n", lost_jiffies);
-			break;
-		}
-	} while (--ticks > 0);
-
-	if (lost_jiffies)
-		account_steal_time(NULL, jiffies_to_cputime(lost_jiffies));
-	return IRQ_HANDLED;
-}
-- 
1.6.3.3

