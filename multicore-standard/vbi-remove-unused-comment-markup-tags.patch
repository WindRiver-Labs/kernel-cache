From 4cb3098282570b27170cf2d06bd68ab51382502e Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 22 Oct 2009 10:53:54 -0400
Subject: [PATCH] vbi: remove unused comment markup tags

There are random meaningless tags spread through the comments
in the vbi import.  They have no relevance from a linux point
of view and are just distracting, so zap them and any other
associated useless stuff.

This is purely cosmetic.  No compiled code changes here.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |  106 ++++++++--------
 arch/powerpc/kernel/vbi/ppc_doc.txt |  110 ++++++++--------
 arch/powerpc/kernel/vbi/syscalls.S  |  190 ++++++++++++++--------------
 arch/x86/kernel/vbi/syscalls.S      |  118 +++++++++---------
 include/asm-x86/arch_vbi.h          |    4 +-
 include/vbi/interface.h             |   42 +++---
 include/vbi/vbi.h                   |  242 +++++++++++++++++-----------------
 kernel/vbi/idle.c                   |    6 +-
 kernel/vbi/io_apic.c                |   42 +++---
 kernel/vbi/lib.c                    |  170 ++++++++++++------------
 kernel/vbi/msg.c                    |   18 ++--
 kernel/vbi/ns.c                     |   12 +-
 kernel/vbi/paddr.c                  |   12 +-
 kernel/vbi/shmem.c                  |   14 +-
 kernel/vbi/show.c                   |   56 ++++----
 kernel/vbi/vmmu_doc.txt             |   16 +-
 16 files changed, 579 insertions(+), 579 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index e3c7800..f58b600 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -191,7 +191,7 @@ extern "C" {
 * SYNOPSIS
 *
 * PPC Control structure graphical illustration
-*\cs
+*
 *        _______________   
 *       |       PC      |   
 *       |---------------|
@@ -217,11 +217,11 @@ extern "C" {
 *       |reserved[0:9]  |
 *       |---------------|
 *
-*\ce
+*
 *
 * Virtual core's control C data structure type definition
 *
-*\cs
+*
 * VB_STATUS structure definition
 *
 * typedef struct vbArchControlRegs
@@ -276,10 +276,10 @@ extern "C" {
 *    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
 *    } VB_ARCH_CONTROL_REGS;
 *
-*\ce
 *
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-*\COMMAND
+*
+*VB_ARCH_CONTROL_REGS, architecture supplement document 
+*
 */
 
 typedef struct vbArchControlRegs
@@ -343,7 +343,7 @@ typedef struct vbArchControlRegs
 * SYNOPSIS
 *
 * PPC Status structure graphical illustration
-*\cs
+*
 *        _______________   ---------------------------
 *       |    SRR0       |   
 *       |---------------|
@@ -396,11 +396,11 @@ typedef struct vbArchControlRegs
 *       | reserved[0:8] | 9x 32bit
 *       |---------------|
 *
-*\ce
+*
 *
 * Virtual core's status C data structure type definition
 *
-*\cs
+*
 * VB_ARCH_STATUS_REGS structure definition
 *
 * typedef struct archStatusRegs
@@ -453,10 +453,10 @@ typedef struct vbArchControlRegs
 *    } VB_ARCH_STATUS_REGS; 
 *
 *
-*\ce
 *
-* SEE ALSO: VB_STATUS 
-*\COMMAND
+*
+*VB_STATUS 
+*
 */
 
 typedef struct archStatusRegs
@@ -525,7 +525,7 @@ typedef struct archStatusRegs
 *
 * VB hardware register set C data structure type definition
 *
-*\cs
+*
 *
 * typedef struct
 *     {
@@ -541,8 +541,8 @@ typedef struct archStatusRegs
 *     } VBI_HREG_SET;
 * 
 *
-*\ce
-* SEE ALSO: NONE
+*
+*NONE
 * 
 */
 
@@ -656,20 +656,20 @@ typedef struct
 * VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
 * loaded from the control structure:
 *
-*\ms
-*\m 1 -
+*
+*
 * VB_CONTROL_SRR0	     ------->  SRR0
-*\m 2 -
+*
 * VB_CONTROL_SRR1	     -------> SRR1 
-*\m 3 -
+*
 * VB_CONTROL_CR		     -------> CR
-*\m 4 -
+*
 * VB_CONTROL_R0		     -------> R0
-*\m 5 -
+*
 * VB_CONTROL_EMSR	     -------> MSR 
-*\m 6 -
+*
 * VB_CONTROL_DBCR0	     -------> DBCR0 
-*\m 7 -
+*
 * VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
 * If interrupts are being reenabled then we ensure that any pending interrupts are
 * delivered before the new context is actived.
@@ -678,19 +678,19 @@ typedef struct
 * OS.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * void  VBI_CTX_LOAD () 
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
 *           VBI_INT_VCORE_STATE_GET()
 */
 
@@ -711,7 +711,7 @@ typedef struct
 * A hypercall is not needed to perform this operation. 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -722,13 +722,13 @@ typedef struct
 *       read the previous value and store in reg0
 *	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
 *	}
-*\ce
+*
 *
 * RETURNS: TRUE is interrupts were locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
 */
 #define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
@@ -754,7 +754,7 @@ typedef struct
 * holding the destination address of the control or status structure.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -772,13 +772,13 @@ typedef struct
 *	otherwise send an hypercall 
 *       go to checkStatus
 *	}
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
 */
 #define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
@@ -809,7 +809,7 @@ endIntVcoreLock:
 * otherwise 0.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -817,13 +817,13 @@ endIntVcoreLock:
 *	{
 *       Load the interrupt status from wrhvVbControl to reg0
 *	}
-*\ce
+*
 *
 * RETURNS: TRUE if interrupts are locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
 */
 
@@ -840,19 +840,19 @@ endIntVcoreLock:
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro for PPC assembly code
+*
+*
 *
 * VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: virtual core configuration structure base address
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_CONFIG_ADDR_GET(reg)		    \
@@ -868,19 +868,19 @@ endIntVcoreLock:
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_CNTRL_ADDR_GET(reg)			    \
@@ -897,33 +897,33 @@ endIntVcoreLock:
 * virtual board time variant data that may be updated during hypervisor context
 * Switch. Typical that are available in the status structure are:
 *
-*\ms
-*\m - 
+*
+* 
 *Timer tick counter
-*\m -
+*
 *Pending interrupt state
-*\m -
+*
 *The interrupt state before this core was schedule
-*\m -
+*
 *VMMU configuration
-*\m -
+*
 *Virtual core registers state
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VB_STATUS * VBI_STATUS_ADDR_GET(void)
 *
-*\ce
+*
 *
 * RETURNS: virtual core configuration structure base address
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_STATUS_ADDR_GET(reg)			    \
diff --git a/arch/powerpc/kernel/vbi/ppc_doc.txt b/arch/powerpc/kernel/vbi/ppc_doc.txt
index 67ad2b4..dda0448 100644
--- a/arch/powerpc/kernel/vbi/ppc_doc.txt
+++ b/arch/powerpc/kernel/vbi/ppc_doc.txt
@@ -195,20 +195,20 @@ typedef struct msg_header {
 * VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
 * loaded from the control structure:
 *
-*\ms
-*\m 1 -
+*
+*
 * VB_CONTROL_SRR0	     ------->  SRR0
-*\m 2 -
+*
 * VB_CONTROL_SRR1	     -------> SRR1 
-*\m 3 -
+*
 * VB_CONTROL_CR		     -------> CR
-*\m 4 -
+*
 * VB_CONTROL_R0		     -------> R0
-*\m 5 -
+*
 * VB_CONTROL_EMSR	     -------> MSR 
-*\m 6 -
+*
 * VB_CONTROL_DBCR0	     -------> DBCR0 
-*\m 7 -
+*
 * VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
 * If interrupts are being reenabled then we ensure that any pending interrupts are
 * delivered before the new context is actived.
@@ -217,19 +217,19 @@ typedef struct msg_header {
 * OS.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * void  VBI_CTX_LOAD () 
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
 *           VBI_INT_VCORE_STATE_GET()
 */
 
@@ -242,7 +242,7 @@ typedef struct msg_header {
 * core for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -252,13 +252,13 @@ typedef struct msg_header {
 *	    size_t len  /@ length of memory to flush @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiDcacheFlush()
+*vbiDcacheFlush()
 */
 
 /*******************************************************************************
@@ -269,7 +269,7 @@ typedef struct msg_header {
 * for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -279,13 +279,13 @@ typedef struct msg_header {
 *	    size_t len  /@ length of memory to flush                   @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*vbiTlbFlush(), vbiIcacheFlush()
 */
 
 /*******************************************************************************
@@ -296,7 +296,7 @@ typedef struct msg_header {
 * instruction cache of the calling core for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -306,13 +306,13 @@ typedef struct msg_header {
 *	    size_t len  /@ length of memory in bytes			    @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*vbiDcacheFlush(), vbiIcacheFlush()
 */
 
 /******************************************************************************
@@ -327,7 +327,7 @@ typedef struct msg_header {
 * A hypercall is not needed to perform this operation. 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -338,13 +338,13 @@ typedef struct msg_header {
 *       read the previous value and store in reg0
 *	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
 *	}
-*\ce
+*
 *
 * RETURNS: TRUE is interrupts were locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
 */
 
@@ -364,7 +364,7 @@ typedef struct msg_header {
 * holding the destination address of the control or status structure.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -382,13 +382,13 @@ typedef struct msg_header {
 *	otherwise send an hypercall 
 *       go to checkStatus
 *	}
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
 */
 
@@ -402,7 +402,7 @@ typedef struct msg_header {
 * otherwise 0.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -410,13 +410,13 @@ typedef struct msg_header {
 *	{
 *       Load the interrupt status from wrhvVbControl to reg0
 *	}
-*\ce
+*
 *
 * RETURNS: TRUE if interrupts are locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
 *	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
 */
 
@@ -429,19 +429,19 @@ typedef struct msg_header {
 * and returns the previous state of interrupts.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * vbiIntState_t vbiIntVCoreLock (void)
 *
-*\ce
+*
 *
 * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
 *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
 */
 
@@ -454,19 +454,19 @@ typedef struct msg_header {
 * the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * void vbiIntVCoreUnlock (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
 *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
 */
 
@@ -479,19 +479,19 @@ typedef struct msg_header {
 * returns TRUE if interrupts are locked otherwise FALSE.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * vbiIntStatus_t vbiIntVCoreStateGet (void)
 *
-*\ce
+*
 *
 * RETURNS: TRUE if interrupts are locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
 *	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
 */
 
@@ -507,7 +507,7 @@ typedef struct msg_header {
 * disabled to prevent hypervisor to deliver interrupts to an incorrect table.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -516,13 +516,13 @@ typedef struct msg_header {
 *	    void * excTblBase /@ New exception table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
 *	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
 */
 
@@ -538,7 +538,7 @@ typedef struct msg_header {
 * it doesnt have to be suspended before reading the registers.
 * 
 * SYNOPSIS
-*\cs
+*
 * VBI PPC Architecture Supplements
 *
 * vbiStatus_t vbiVbRegisterRead 
@@ -561,13 +561,13 @@ typedef struct msg_header {
 *     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
 *     } VB_HREG_SET;
 * 
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 /*******************************************************************************
@@ -583,7 +583,7 @@ typedef struct msg_header {
 * Target VB's core has to be suspended before writing the registers. If it
 * is still running, vbiVbRegisterWrite call will fail.
 * 
-*\cs
+*
 * typedef struct
 *     {
 *     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
@@ -597,24 +597,24 @@ typedef struct msg_header {
 *     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
 *     } VB_HREG_SET;
 * 
-*\ce 
+* 
 * VBI PPC Architecture Supplements
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVbRegisterWrite
 *	(
 *	VB_HREG_SET		*regCtl,	/@ registers to write - IN	 @/
 *	vbiVb_t			targetBoard,	/@ The target board		 @/
 *	vbiCore_t		core		/@ The target core within the VB @/
 *	)
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 /*******************************************************************************
@@ -635,7 +635,7 @@ typedef struct msg_header {
 * started up and before it's added to the scheduler for the guest OS.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -644,13 +644,13 @@ typedef struct msg_header {
 *	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiExcOffsetsGet
+*vbiExcOffsetsGet
 */
 
 /*******************************************************************************
@@ -663,7 +663,7 @@ typedef struct msg_header {
 * virtual board. The offset table uses an index based on IVOR number.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -672,11 +672,11 @@ typedef struct msg_header {
 *	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiExcOffsetsSet
+*vbiExcOffsetsSet
 */
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index e4bc2f8..2209aaf 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -146,7 +146,7 @@ FUNC_END(vbiVbMgmt)
 * to a given hypervisor manager that provides virtual board managment service.
 *
 * SYNOPSIS
-*\cs
+*
 *
 *
 * vbiStatus_t vbiVbSuspend
@@ -154,13 +154,13 @@ FUNC_END(vbiVbMgmt)
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*
+*vbiVbResume(), vbiVbReset(), vbiVbRestart()
 */
 
 FUNC_LABEL(vbiVbSuspend)
@@ -195,12 +195,12 @@ FUNC_END(vbiVbSuspend)
 * operation on.
 * The value of the second argument should be set to one of the following:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*\m -
+*
 * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*\m -
+*
 * A valid core number: Reset the specified core that exist within the Virtual
 * Board.
 *\me
@@ -210,10 +210,10 @@ FUNC_END(vbiVbSuspend)
 * may be
 * one of the following or a combination:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
-*\m -
+*
 * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
 *\me
 *
@@ -224,7 +224,7 @@ FUNC_END(vbiVbSuspend)
 * OS's responsibility to clear the bss data sections in such scenario.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbReset
 *    (
@@ -232,13 +232,13 @@ FUNC_END(vbiVbSuspend)
 *    vbiCore_t     core,            /@ Core within the VB           @/
 *    uint32_t     options   /@ reload , start options       @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
 */
 
 FUNC_LABEL(vbiVbReset)
@@ -275,20 +275,20 @@ FUNC_END(vbiVbReset)
 * services.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbRestart
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
 */
 
 FUNC_LABEL(vbiVbRestart)
@@ -321,20 +321,20 @@ FUNC_END(vbiVbRestart)
 * as programming error.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbResume
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*
+*vbiVbResume(), vbiVbSuspend()
 */
 
 FUNC_LABEL(vbiVbResume)
@@ -359,7 +359,7 @@ FUNC_END(vbiVbResume)
 * message.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiSend
 *    (
@@ -371,13 +371,13 @@ FUNC_END(vbiVbResume)
 *    VBI_MSG_INFO *info  /@ status info structure pointer     @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*
+*vbiReceive(), vbiReply(), WRHV  messaging user's guide
 */
 
 FUNC_LABEL(vbiSend)
@@ -406,7 +406,7 @@ FUNC_END(vbiSend)
 * another context. It blocks until a message is received.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiCtx_t vbiReceiveOp
 *    (
@@ -415,13 +415,13 @@ FUNC_END(vbiSend)
 *    VBI_MSG_INFO *info  /@ status info structure pointer  @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
 *    )
-*\ce
+*
 *
 * RETURNS: sender context Id or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*
+*vbiSend(), vbiReply(), WRHV  messaging user's guide
 */
 
 FUNC_LABEL(vbiReceiveOp)
@@ -449,7 +449,7 @@ FUNC_END(vbiReceiveOp)
 * the caller.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiReply
 *    (
@@ -458,13 +458,13 @@ FUNC_END(vbiReceiveOp)
 *    size_t	    len,   /@ length of message to reply	    @/
 *    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*
+*vbiSend(), vbiReceive(), WRHV  messaging user's guide
 */
 
 FUNC_LABEL(vbiReply)
@@ -482,17 +482,17 @@ FUNC_END(vbiReply)
 * hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiKputs (const char *s) /@ string to display @/
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiKputc() 
+*
+*vbiKputc() 
 */
 
 FUNC_LABEL(vbiKputs)
@@ -510,17 +510,17 @@ FUNC_END(vbiKputs)
 * hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiKputc (int c) /@ character to print @/
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiKputs()
+*
+*vbiKputs()
 */
 
 FUNC_LABEL(vbiKputc)
@@ -544,15 +544,15 @@ FUNC_END(vbiKputc)
 *
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiPanic (const char *msg) /@ pointer to message to print @/
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
+*
 *
 */
 
@@ -576,20 +576,20 @@ FUNC_END(vbiPanic)
 * is running. 
 *
 * SYNOPSIS
-*\cs
+*
 *
 * void vbiDebugShellStart 
 *          (
 *          uint32_t  flags /@ detach by default @/
 *          ) 
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
+*
+*
 */
 
 FUNC_LABEL(vbiDebugShellStart)
@@ -610,7 +610,7 @@ FUNC_END(vbiDebugShellStart)
 * core for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -620,13 +620,13 @@ FUNC_END(vbiDebugShellStart)
 *	    size_t len  /@ length of memory to flush @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiDcacheFlush()
+*vbiDcacheFlush()
 */
 
 FUNC_LABEL(vbiIcacheFlush)
@@ -644,7 +644,7 @@ FUNC_END(vbiIcacheFlush)
 * for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -654,13 +654,13 @@ FUNC_END(vbiIcacheFlush)
 *	    size_t len  /@ length of memory to flush                   @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*vbiTlbFlush(), vbiIcacheFlush()
 */
 
 FUNC_LABEL(vbiDcacheFlush)
@@ -701,19 +701,19 @@ FUNC_END(vbiTlbFlush)
 * the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * void vbiIntVCoreUnlock (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
 *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
 */
 
@@ -783,19 +783,19 @@ FUNC_END(vbiIntVCoreLock)
 * returns TRUE if interrupts are locked otherwise FALSE.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
 * vbiIntStatus_t vbiIntVCoreStateGet (void)
 *
-*\ce
+*
 *
 * RETURNS: TRUE if interrupts are locked otherwise FALSE
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
 *	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
 */
 
@@ -818,7 +818,7 @@ FUNC_END(vbiIntVCoreStateGet)
 * disabled to prevent hypervisor to deliver interrupts to an incorrect table.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -827,13 +827,13 @@ FUNC_END(vbiIntVCoreStateGet)
 *	    void * excTblBase /@ New exception table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
 *	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
 */
 
@@ -883,7 +883,7 @@ FUNC_END(vbiExcBaseSet)
 * started up and before it's added to the scheduler for the guest OS.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -892,13 +892,13 @@ FUNC_END(vbiExcBaseSet)
 *	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiExcOffsetsGet
+*vbiExcOffsetsGet
 */
 
 FUNC_LABEL(vbiExcOffsetsSet)
@@ -924,7 +924,7 @@ FUNC_END(vbiExcOffsetsSet)
 * virtual board. The offset table uses an index based on IVOR number.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -933,13 +933,13 @@ FUNC_END(vbiExcOffsetsSet)
 *	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
 *	    )
 *
-*\ce
+*
 *
 * RETURNS: OK or error number if operation fails to complete 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiExcOffsetsSet
+*vbiExcOffsetsSet
 */
 
 FUNC_LABEL(vbiExcOffsetsGet)
@@ -963,7 +963,7 @@ FUNC_END(vbiExcOffsetsGet)
 * instruction cache of the calling core for the specified address range.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI PPC Architecture Supplements
 *
@@ -973,13 +973,13 @@ FUNC_END(vbiExcOffsetsGet)
 *	    size_t len  /@ length of memory in bytes			    @/
 *	    ) 
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*vbiDcacheFlush(), vbiIcacheFlush()
 */
 
 FUNC_LABEL(vbiCacheTextUpdate)
@@ -1173,7 +1173,7 @@ FUNC_END(vbiCtxctl)
 * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrSet 
 *		(
@@ -1181,7 +1181,7 @@ FUNC_END(vbiCtxctl)
 *		size_t   length,	/@ length of address		    @/
 *		uint32_t attr		/@ mmu attributes to set	    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -1206,14 +1206,14 @@ FUNC_END(vbiMemAttrSet)
 * therefore a hypercall is not necessary.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrGet 
 *		(
 *		void	 *gaddr		/@ Address of page to change attr   @/
 *		uint32_t *attr		/@ OUT - returned mmu attributes    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -1311,7 +1311,7 @@ FUNC_END(vbiNsOp)
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryRead 
 *	(
@@ -1319,13 +1319,13 @@ FUNC_END(vbiNsOp)
 *	vbiVb_t	    targetBoard	    /@ target board				@/
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 FUNC_LABEL(vbiVbMemoryRead)
@@ -1365,7 +1365,7 @@ FUNC_END(vbiVbMemoryRead)
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryWrite 
 *	(
@@ -1373,13 +1373,13 @@ FUNC_END(vbiVbMemoryRead)
 *	vbiVb_t		targetBoard 
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 FUNC_LABEL(vbiVbMemoryWrite)
@@ -1428,7 +1428,7 @@ FUNC_END(vbiIoapicOp)
 * destination buffers to store them.
 * 
 * SYNOPSIS
-*\cs
+*
 * VBI PPC Architecture Supplements
 *
 * vbiStatus_t vbiVbRegisterRead 
@@ -1490,13 +1490,13 @@ FUNC_END(vbiIoapicOp)
 *    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
 *    } VB_ARCH_CONTROL_REGS;
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 FUNC_LABEL(vbiVbRegisterRead)
@@ -1516,7 +1516,7 @@ FUNC_END(vbiVbRegisterRead)
 * vbiVbRegisterRead() then write back the modified set of registers in the 
 * registers control structure.
 * 
-*\cs
+*
 *typedef struct vbArchControlRegs
 *    {
 *
@@ -1568,24 +1568,24 @@ FUNC_END(vbiVbRegisterRead)
 *
 *    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
 *    } VB_ARCH_CONTROL_REGS;
-*\ce 
+* 
 * VBI PPC Architecture Supplements
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVbRegisterWrite
 *	(
 *	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
 *	vbiVb_t			targetBoard,	/@ The target board		 @/
 *	vbiCore_t		core		/@ The target core within the VB @/
 *	)
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 FUNC_LABEL(vbiVbRegisterWrite)
@@ -1601,7 +1601,7 @@ FUNC_END(vbiVbRegisterWrite)
 * vbiVcoreIntRed_op - redirect an irq to another vcore
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVcoreIntRed_op 
 *	(
 *	vbiIrq_t		irq,	/@ irq number to redirect	 @/
@@ -1612,9 +1612,9 @@ FUNC_END(vbiVbRegisterWrite)
 *
 * ERROR CODES: 
 *
-* SEE ALSO: vbiVioapicIntRedirect()
+*vbiVioapicIntRedirect()
 * 
-*\NOMANUAL
+*
 */
 
 FUNC_LABEL(vbiVcoreIntRed_op)
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index 7a04594..afe22d8 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -70,7 +70,7 @@
 * message.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiSend
 *    (
@@ -82,13 +82,13 @@
 *    VBI_MSG_INFO *info  /@ status info structure pointer     @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*
+*vbiReceive(), vbiReply(), WRHV  messaging user's guide
 */
 
 vbiSend:
@@ -106,7 +106,7 @@ vbiSend:
 * another context. It blocks until a message is received.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiCtx_t vbiReceiveOp
 *    (
@@ -115,13 +115,13 @@ vbiSend:
 *    VBI_MSG_INFO *info  /@ status info structure pointer  @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
 *    )
-*\ce
+*
 *
 * RETURNS: sender context Id or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*
+*vbiSend(), vbiReply(), WRHV  messaging user's guide
 */
 
 vbiReceiveOp:
@@ -144,7 +144,7 @@ vbiReceiveOp:
 * the caller.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiReply
 *    (
@@ -153,13 +153,13 @@ vbiReceiveOp:
 *    size_t       len,   /@ length of message to reply   @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*
+*vbiSend(), vbiReceive(), WRHV  messaging user's guide
 */
 
 vbiReply:
@@ -396,7 +396,7 @@ vbiVbMgmt:
 * to a given hypervisor manager that provides virtual board managment service.
 *
 * SYNOPSIS
-*\cs
+*
 *
 *
 * vbiStatus_t vbiVbSuspend
@@ -404,13 +404,13 @@ vbiVbMgmt:
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*
+*vbiVbResume(), vbiVbReset(), vbiVbRestart()
 */
 
 vbiVbSuspend:
@@ -440,12 +440,12 @@ vbiVbSuspend:
 * determined. The second argument identifies the cores to perform the operation on.
 * The value of the second argument should be set to one of the following:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*\m -
+*
 * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*\m -
+*
 * A valid core number: Reset the specified core that exist within the Virtual Board.
 *\me
 *
@@ -453,10 +453,10 @@ vbiVbSuspend:
 * applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
 * one of the following or a combination:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
-*\m -
+*
 * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
 *\me
 *
@@ -467,7 +467,7 @@ vbiVbSuspend:
 * responsibility to clear the bss data sections in such scenario.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbReset
 *    (
@@ -475,13 +475,13 @@ vbiVbSuspend:
 *    vbiCore_t     core,            /@ Core within the VB           @/
 *    uint32_t     options   /@ reload , start options       @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
 */
 
 vbiVbReset:
@@ -512,20 +512,20 @@ vbiVbReset:
 * services.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbRestart
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
 */
 
 vbiVbRestart:
@@ -555,20 +555,20 @@ vbiVbRestart:
 * as programming error.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiVbResume
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB         @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO:
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*
+*vbiVbResume(), vbiVbSuspend()
 */
 
 vbiVbResume:
@@ -724,7 +724,7 @@ vbiCtxctl:
 * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrSet 
 *		(
@@ -732,7 +732,7 @@ vbiCtxctl:
 *		size_t   length,	/@ length of address		    @/
 *		uint32_t attr		/@ mmu attributes to set	    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -760,14 +760,14 @@ vbiMmuAttrSet:
 * therefore a hypercall is not necessary.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrGet 
 *		(
 *		void	 *gaddr		/@ Address of page to change attr   @/
 *		uint32_t *attr		/@ OUT - returned mmu attributes    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -849,7 +849,7 @@ vbiNsOp:
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryWrite 
 *	(
@@ -857,13 +857,13 @@ vbiNsOp:
 *	vbiVb_t		targetBoard 
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 vbiVbMemoryWrite:
@@ -900,7 +900,7 @@ vbiVbMemoryWrite:
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryRead 
 *	(
@@ -908,13 +908,13 @@ vbiVbMemoryWrite:
 *	vbiVb_t	    targetBoard	    /@ target board				@/
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 vbiVbMemoryRead:
@@ -940,19 +940,19 @@ vbiVbMemoryRead:
 * is running.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * void vbiDebugShellStart
 *          (
 *          uint32_t  flags /@ detach by default @/
 *          )
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 *
-* SEE ALSO: 
+*
 */
 
 vbiDebugShellStart:
@@ -977,7 +977,7 @@ vbiDebugShellStart:
 * 
 * SYNOPSIS
 * VBI X86 Architecture Supplements
-*\cs
+*
 * vbiStatus_t vbiVbRegisterRead 
 *	(
 *	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
@@ -1012,13 +1012,13 @@ vbiDebugShellStart:
 *    uint32_t  gs;		/@ 4C: G segment		@/
 *    uint32_t  tsp;		/@ 50: transition stack pointer	@/
 *    } VB_ARCH_CONTROL_REGS;
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES:
 *
-* SEE ALSO: 
+*
 */
 
 vbiVbRegisterRead:
@@ -1045,7 +1045,7 @@ vbiVbRegisterRead:
 * VBI X86 Architecture Supplements
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVbRegisterWrite
 *	(
 *	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
@@ -1082,13 +1082,13 @@ vbiVbRegisterRead:
 *    uint32_t  tsp;		/@ 50: transition stack pointer	@/
 *    } VB_ARCH_CONTROL_REGS;
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: 
 *
-* SEE ALSO: 
+*
 */
 
 vbiVbRegisterWrite:
@@ -1106,7 +1106,7 @@ vbiVbRegisterWrite:
 * vbiVcoreIntRed_op - redirect an irq to another vcore
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVcoreIntRed_op 
 *	(
 *	vbiIrq_t		irq,	/@ irq number to redirect	 @/
@@ -1117,9 +1117,9 @@ vbiVbRegisterWrite:
 *
 * ERROR CODES: 
 *
-* SEE ALSO: vbiVioapicIntRedirect()
+*vbiVioapicIntRedirect()
 * 
-*\NOMANUAL
+*
 */
 vbiVcoreIntRed_op:
 
@@ -1148,14 +1148,14 @@ vbiVcoreIntRed_op:
 *   VBI_VTLB_OP_INIT	
 *
 * SYNOPSIS
-*\cs
+*
 * vbiStatus_t vbiVtlbOp (
 *            unsigned int op,          /@ VTLB operation @/
 *            unsigned long arg1,       /@ VTLB operation argument 1 @/
 *            unsigned long arg2,       /@ VTLB operation argument 2 @/
 *            unsigned long arg3        /@ VTLB operation argument 3 @/
 *            )
-*\ce
+*
 *
 * Returns: OK or ERROR if the VTLB operation has failed
 */
diff --git a/include/asm-x86/arch_vbi.h b/include/asm-x86/arch_vbi.h
index 72421b3..8b63a6a 100644
--- a/include/asm-x86/arch_vbi.h
+++ b/include/asm-x86/arch_vbi.h
@@ -36,7 +36,7 @@ extern "C" {
 *
 * VB hardware register set C data structure type definition
 *
-*\cs
+*
 *     typedef struct		/@ VB_REG_SET - used for sys_regsRead/Write @/
 *         {
 *         uint32_t  eax;	/@ 00: general register		@/
@@ -64,7 +64,7 @@ extern "C" {
 *         uint32_t  tr;		/@ 58: task register		@/
 *         } VB_HREG_SET;
 *
-*\ce
+*
 * SEE ALSO: NONE
 * 
 */
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 7d34fb8..a33bdc6 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -264,16 +264,16 @@ typedef uint64_t VB_TIMESTAMP;
 * It is suggested to use the provided APIs for manipulating the virtual core
 * control structure instead of directly accessing it's members. 
 * Typically use cases for this structure are for following:
-*\ms
-*\m - 
+*
+* 
 * During context switch for setting the incoming context's register state.
 * For more information about this refer to VBI_CTX_LOAD() description in the
 * architecture supplement API documentation.
-*\m -
+*
 * Locking/unlocking the virtual core interrupts.
-*\m -
+*
 * Loading the VMMU configuration data.
-*\m -
+*
 * VIOAPIC configuration registers.
 * 
 *\me   
@@ -297,7 +297,7 @@ typedef uint64_t VB_TIMESTAMP;
 *
 * 
 * Control structure graphical illustration
-*\cs
+*
 *    ______________
 *   |              |
 *   |              |<------- 64bits - pointer to arch specific registers 
@@ -322,12 +322,12 @@ typedef uint64_t VB_TIMESTAMP;
 *   |              |
 *   |--------------|<------- 32bits - Pending interrupt vector number  
 *   |______________|            
-*\ce
+*
 *
 * SYNOPSIS
 *
 * Virtual core's control C data structure type definition
-*\cs
+*
 * typedef struct vbControl {
 *
 *    /@
@@ -367,7 +367,7 @@ typedef uint64_t VB_TIMESTAMP;
 *    uint32_t	intPending;
 *
 *   } VB_CONTROL;
-*\ce
+*
 *
 * SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
 *
@@ -378,7 +378,7 @@ typedef uint64_t VB_TIMESTAMP;
 * 2. Make sure that VIOAPIC_SIZE is used in the structure
 * 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
 *     the code
-*\COMMAND 
+* 
 */
 
 typedef struct vbControl {
@@ -425,10 +425,10 @@ typedef struct vbControl {
 * supplement documentation.
 * The purpose of this structure is to inform a virtual core at runtime the
 * status of a core's time variant data such as:
-*\ms
-*\m - 
+*
+* 
 * Interrupts state
-*\ms
+*
 *\m *
 * current interrupt state
 *\m *
@@ -436,18 +436,18 @@ typedef struct vbControl {
 *\m *
 * The pending vector number if any
 *\me
-*\m -
+*
 * A free running clock timestamp
-*\m -
+*
 * Virtual core elapsed timer ticks
-*\m -
+*
 * Current VMMU configuration
 *\me
 *  
 * SYNOPSIS
 *
 * Control structure graphical illustration
-*\cs
+*
 *        _______________   
 *       |		|	
 *       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
@@ -474,11 +474,11 @@ typedef struct vbControl {
 *       |		|
 *       |---------------|
 *
-*\ce
+*
 *
 * Virtual core's status C data structure type definition
 *
-*\cs
+*
 * VB_STATUS structure definition
 *
 * typedef struct vbStatus {
@@ -525,14 +525,14 @@ typedef struct vbControl {
 *    uint64_t tickCount;
 *
 * } VB_STATUS;
-*\ce
+*
 *
 *
 * SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
 * INTERNAL
 * Make sure that intPendingType modification is reflected in the code
 *
-*\COMMAND
+*
 */
 
 typedef struct vbStatus {
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index 98277d1..9e7f1d1 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -45,19 +45,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_CNTRL_ADDR_GET()        (wrhvVbControl)
@@ -87,36 +87,36 @@ various data structures.
 * information.
 *
 * API's for controlling the VIOAPIC:
-*\ms
-*\m - 
+*
+* 
 * vbiVioapicIntSend()
-*\m - 
+* 
 * vbiVioapicVectorSet()
-*\m - 
+* 
 * vbiVioapicVectorGet()
-*\m - 
+* 
 * vbiVioapicIntAck()
-*\m - 
+* 
 * vbiVioapicIntMask()
-*\m - 
+* 
 * vbiVioapicIntUnmask()
 *\me
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * void * VBI_VIOAPIC_BASE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiIoapicIntUnmask(), vbiVioapicVectorGet(), vbiIoapicIntMask(), 
+*vbiIoapicIntUnmask(), vbiVioapicVectorGet(), vbiIoapicIntMask(), 
 *           vbiIoapicIntSend(), vbiIoapicIntRedirect(), vbiIoapicIntAck(),
 *	    VBI User's Guide
 */
@@ -142,33 +142,33 @@ various data structures.
 * virtual board time variant data that may be updated during hypervisor context
 * Switch. Typical that are available in the status structure are:
 *
-*\ms
-*\m - 
+*
+* 
 *Timer tick counter
-*\m -
+*
 *Pending interrupt state
-*\m -
+*
 *The interrupt state before this core was schedule
-*\m -
+*
 *VMMU configuration
-*\m -
+*
 *Virtual core registers state
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VB_STATUS * VBI_STATUS_ADDR_GET(void)
 *
-*\ce
+*
 *
 * RETURNS: virtual core configuration structure base address
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_STATUS_ADDR_GET()       (wrhvVbStatus)
@@ -181,19 +181,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiVector_t VBI_INT_VCORE_PENDING (void)
 *
-*\ce
+*
 *
 * RETURNS: VB Interrupt Vector or 0xffff (PowerPC) Not applicable for X86
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
 *              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
 */
 
@@ -209,20 +209,20 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiVector_t VBI_INT_VCORE_PENDING_TYPE_GET(void)
 *
-*\ce
+*
 *
 * RETURNS: 2 for timer interrupt, 1 for other external interrupts or
 *	    0 if none is pending
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
 *              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
 */
 
@@ -241,19 +241,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * bool VBI_INT_VCORE_PREVSTATE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: TRUE if locked otherwise FALSE
 *
 * ERROR CODES: 
 *
-* SEE ALSO: VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
+*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
 *              VBI_INT_VCORE_UNLOCK()
 */
 
@@ -275,12 +275,12 @@ various data structures.
 * This macro gets the core's VMMU configuration structure address. The VMMU
 * structure is a descriptor of the VMMU context with the following info:
 *
-*\ms
-*\m -
+*
+*
 * The VMMU page table base address 
-*\m - 
+* 
 * The VMMU pages
-*\m -
+*
 * The page size granularity 
 *\me 
 *
@@ -296,7 +296,7 @@ various data structures.
 *
 * The vmmu virtual address space is restricted to 32 bits and is decoded using
 * a level-1/level-2 page table.  The virtual address is decoded as follows:
-*\cs
+*
 *
 *
 *
@@ -362,23 +362,23 @@ various data structures.
 *                C          - page changed bit
 *                SX,SW,SR   - supervisor mode protection bits
 *                UX,UW,UR   - user mode protection bits
-*\ce
+*
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VMMU_CONFIG * VBI_VMMU_CONFIG_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: A pointer to the cores VMMU_CONFIG structure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuDisable(),
+*vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuDisable(),
 *           vbiVmmuTlbFlush(), vbiVmmuTlbLoad()
 */
 
@@ -399,19 +399,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiTicks_t VBI_TICKS_COUNT_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: count number of elapsed ticks for a VB
 *
 * ERROR CODES: 
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_TICK_COUNT_GET()             \
@@ -426,19 +426,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: virtual core configuration structure base address
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_CONFIG_ADDR_GET()       (wrhvVbConfig)
@@ -451,19 +451,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiCtx_t VBI_CONTEXT_ID_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: virtual core context id
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_CONTEXT_ID_GET()             \
@@ -479,19 +479,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiVb_t VBI_BOARD_ID_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: virtual board id;
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_BOARD_ID_GET()               \
@@ -507,19 +507,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * uint32_t VBI_VCORES_COUNT_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: number of cores in a virtual board
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: VBI_VCORE_ID_GET()
+*VBI_VCORE_ID_GET()
 */
 
 #define VBI_VCORES_COUNT_GET()               \
@@ -534,19 +534,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * vbiCore_t VBI_CORE_ID_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: the running core id
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_VCORE_ID_GET()			\
@@ -560,19 +560,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * size_t VBI_VCORE_PRIVMEM_SIZE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: size in bytes of the core's private memory
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiCorePrvMemFind 
+*vbiCorePrvMemFind 
 */
 
 #define VBI_VCORE_PRIVMEM_SIZE_GET()               \
@@ -587,19 +587,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * void * VBI_VCORE_PRIVMEM_BASE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: a pointer to the core's private memory
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiCorePrvMemFind 
+*vbiCorePrvMemFind 
 */
 
 #define VBI_VCORE_PRIVMEM_BASE_GET()               \
@@ -616,20 +616,20 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-*  C Preprocessor Macro
+*
+*
 *
 * uint32_t VBI_PRV_MODE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: 1 if core has supervisor privilege otherwise 0
 *
 * ERROR CODES: N/A
 * 
-* SEE ALSO: 
-*\NOMANUAL
+*
+*
 */
 
 #define VBI_PRIV_MODE_GET()			    \
@@ -644,19 +644,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * char * VBI_BOARD_NAME (void)
 *
-*\ce
+*
 *
 * RETURNS: a string representing the board name
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_BOARD_NAME_GET()			    \
@@ -675,19 +675,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * uint32_t VBI_BOOT_COUNT (void)
 *
-*\ce
+*
 *
 * RETURNS: a positive number greater than 0
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_BOOT_COUNT_GET()			    \
@@ -706,30 +706,30 @@ various data structures.
 *
 * The size returned by this macro does not include the following:
 *
-*\ms
-*\m -
+*
+*
 * Private memory of each core attached to this virtual board
-*\m -
+*
 * The regions that contain the configuration, status and control structures
-*\m -
+*
 * The shared memory with other boards
 *\me
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * size_t VBI_MEM_SIZE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: The size of memory in bytes for virtual board 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_MEM_SIZE_GET()			    \
@@ -743,20 +743,20 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * size_t VBI_MEM_ALIAS_SIZE_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: The aliased memory size.
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
-*\NOMANUAL
+*
+*
 */
 
 #define VBI_MEM_ALIAS_SIZE_GET()		    \
@@ -776,19 +776,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * void * VBI_MEM_ALIAS_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: The base address of ram alias address 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_MEM_ALIAS_ADDR_GET()			    \
@@ -807,19 +807,19 @@ various data structures.
 * 
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * void * VBI_MEM_ENTRY_RTN(void)
 *
-*\ce
+*
 *
 * RETURNS: The entry point function of a virtual core 
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_ENTRY_RTN_GET()			    \
@@ -839,19 +839,19 @@ various data structures.
 *
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * vbiTicks_t VBI_TICK_TIMER_FREQ_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: The number of ticks per second
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_TICK_TIMER_FREQ_GET()		        \
@@ -874,19 +874,19 @@ various data structures.
 * 
 * SYNOPSIS
 *
-*\cs
 *
-* C Preprocessor Macro
+*
+*
 *
 * const char * VBI_BOOTLINE_ADDR_GET (void)
 *
-*\ce
+*
 *
 * RETURNS: The address of the bootline parameters.
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 #define VBI_BOOTLINE_ADDR_GET()				\
diff --git a/kernel/vbi/idle.c b/kernel/vbi/idle.c
index de9781f..07f146c 100644
--- a/kernel/vbi/idle.c
+++ b/kernel/vbi/idle.c
@@ -39,15 +39,15 @@ into the idle state.
 * timeout means to halt the core indefinetly until an asynchronous event occurs.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiIdle (vbiTicks_t timeout)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
+*
 *
 */
 
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
index 4bcab59..c662a16 100644
--- a/kernel/vbi/io_apic.c
+++ b/kernel/vbi/io_apic.c
@@ -182,11 +182,11 @@ void * vbiVioapicAddrGet(void)
 * This routine is currently not supported for PPC.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -238,11 +238,11 @@ vbiStatus_t vbiVioapicVectorSet
 * This routine is currently not supported for PPC 
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: vector number or error number in case of failure
 *
@@ -294,11 +294,11 @@ vbiVector_t vbiVioapicVectorGet
 * specified IRQ directed to the calling virtual Core.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
@@ -348,11 +348,11 @@ EXPORT_SYMBOL(vbiVioapicIntUnmask);
 * vbiVioapicIntUnmask(). 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
@@ -398,12 +398,12 @@ vbiStatus_t vbiVioapicIntMask
 * for the same IRQ. Exceptions are not required to be acknowledged.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
@@ -441,9 +441,9 @@ vbiStatus_t vbiVioapicIntAck
 * was configured to receive the IRQ. The configuration is provided in the board
 * XML configuration file as the example shown below. 
 *
-*\cs
+*
 *  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*\ce
+*
 *
 * The Vector number is not required to be specified in the XML. If not specified
 * the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
@@ -451,23 +451,23 @@ vbiStatus_t vbiVioapicIntAck
 * 
 * The possible values for the filter (second argument) may be:
 *
-*\ms
-*\m -
+*
+*
 * VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
 *                         IRQ include the sender board.
-*\m -
+*
 * VIOAPIC_SEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
 *                         excluding the sender board
-*\m -
+*
 * VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
 *		          will be delivered only if the destination board is
 *                         connected to this IRQ 
 *			  
-*\m -
+*
 * VIOAPIC_SEND_NONE	- Ignore this call.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntSend 
 *             (
@@ -476,7 +476,7 @@ vbiStatus_t vbiVioapicIntAck
 *             vbiVb_t target 
 *             )
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
@@ -511,11 +511,11 @@ EXPORT_SYMBOL(vbiVioapicIntSend);
 * within the same virtual board. 
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index 180c060..91f8fbf 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -171,29 +171,29 @@ EXPORT_SYMBOL(wrhvVbConfig);
 * address. This routine retrieves the status and control page from the 
 * configuration page and initializes the following global variables for future
 * reference.
-*\ms
-*\m - Configuration page base address is stored in wrhvVbConfig
-*\m - Status page base address is stored in wrhvVbStatus
-*\m - Control page base address is stored in wrhvVbControl
+*
+* Configuration page base address is stored in wrhvVbConfig
+* Status page base address is stored in wrhvVbStatus
+* Control page base address is stored in wrhvVbControl
 *
 * The user must ensure that this memory regions are mapped if the MMU is
 * turn-on.
 * A good practice would be to map these regions as devices meaning 1-1 
 * translation.
 *\me
-*\ce
+*
 * SYNOPSIS
-*\cs
-* C FUNCTION
+*
+*
 * void vbiInit
 *    (
 *    VB_CONFIG	*config		/@ Address of the VB config area    @/
 *    )
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
+*
 *
 */
 
@@ -239,7 +239,7 @@ void vbiInit
 * to a given hypervisor manager that provides virtual board managment service. 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVbSuspend
@@ -247,13 +247,13 @@ void vbiInit
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB		@/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: 
 *
-* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*
+*vbiVbResume(), vbiVbReset(), vbiVbRestart()
 */
 
 /*******************************************************************************
@@ -273,12 +273,12 @@ void vbiInit
 * determined. The second argument identifies the cores to perform the operation on.
 * The value of the second argument should be set to one of the following:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*\m -
+*
 * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*\m -
+*
 * A valid core number: Reset the specified core that exist within the Virtual Board.
 *\me
 *
@@ -286,10 +286,10 @@ void vbiInit
 * applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
 * one of the following or a combination:
 *
-*\ms
-*\m -
+*
+*
 * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images	
-*\m -
+*
 * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
 *\me
 *
@@ -300,7 +300,7 @@ void vbiInit
 * responsibility to clear the bss data sections in such scenario.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbReset
 *    (
@@ -308,13 +308,13 @@ void vbiInit
 *    vbiCore_t     core,	    /@ Core within the VB	    @/
 *    uint32_t     options   /@ reload , start options	    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: 
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbRestart() 
 */
 
 /*******************************************************************************
@@ -335,20 +335,20 @@ void vbiInit
 * services. 
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbRestart
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB		@/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: 
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*
+*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
 */
 
 /*******************************************************************************
@@ -368,20 +368,20 @@ void vbiInit
 * as programming error.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbResume
 *    (
 *    vbiVb_t      id,    /@ Id of the VB to suspend     @/
 *    vbiCore_t     core   /@ Core within the VB		@/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: 
 *
-* SEE ALSO: vbiVbResume(), vbiVbSuspend() 
+*
+*vbiVbResume(), vbiVbSuspend() 
 */
 
 /*******************************************************************************
@@ -392,17 +392,17 @@ void vbiInit
 * hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiKputs (const char *s) /@ string to display @/
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiKputc() 
+*
+*vbiKputc() 
 */
 
 /*******************************************************************************
@@ -413,17 +413,17 @@ void vbiInit
 * hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiKputc (int c) /@ character to print @/
 *
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: vbiKputs()
+*
+*vbiKputs()
 */
 
 /*******************************************************************************
@@ -440,15 +440,15 @@ void vbiInit
 *
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiPanic (const char *msg) /@ pointer to message to print @/
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
+*
 *
 */
 
@@ -465,20 +465,20 @@ void vbiInit
 * is running. 
 *
 * SYNOPSIS
-*\cs
+*
 *
 * void vbiDebugShellStart 
 *          (
 *          uint32_t  flags /@ detach by default @/
 *          ) 
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
+*
+*
 */
 
 /*******************************************************************************
@@ -505,7 +505,7 @@ void vbiInit
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryRead 
 *	(
@@ -513,13 +513,13 @@ void vbiInit
 *	vbiVb_t	    targetBoard	    /@ target board				@/
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 /*******************************************************************************
@@ -552,7 +552,7 @@ void vbiInit
 *    } VBI_MEM_CTL;
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVbMemoryWrite 
 *	(
@@ -560,13 +560,13 @@ void vbiInit
 *	vbiVb_t		targetBoard 
 *	)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: 
+*
 */
 
 /*******************************************************************************
@@ -581,7 +581,7 @@ void vbiInit
 * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrSet 
 *		(
@@ -589,7 +589,7 @@ void vbiInit
 *		size_t   length,	/@ length of address		    @/
 *		uint32_t attr		/@ mmu attributes to set	    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -607,14 +607,14 @@ void vbiInit
 * therefore a hypercall is not necessary.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemAttrGet 
 *		(
 *		void	 *gaddr		/@ Address of page to change attr   @/
 *		uint32_t *attr		/@ OUT - returned mmu attributes    @/
 *		)
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
@@ -639,17 +639,17 @@ void vbiInit
 * This routine is currently not supported for MIPS.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *  vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
 *
-*\ce
+*
 *
 * RETURNS: OK or error number in case of failure
 *
 * ERROR CODES: VBI_VIOAPIC_NULL, VBI_VIOAPIC_IRQ_OUTBOUND
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
+*vbiVioapicIntUnmask(), vbiVioapicVectorGet(), vbiVioapicIntMask() 
 *           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
 */
 
@@ -666,17 +666,17 @@ void vbiInit
 * This routine is currently not supported for MIPS.  
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: vector number or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
 *           vbiVioapicIntSend(), vbiVioapicIntRedirect(), vbiVioapicIntAck()
 */
 
@@ -693,17 +693,17 @@ void vbiInit
 * This routine is currently not supported for MIPS.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
+*vbiVioapicIntUnmask(), vbiExcBaseSet(), vbiVioapicIntAck(),
 *	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
 */
 
@@ -721,19 +721,19 @@ void vbiInit
 * This routine is currently not supported for MIPS.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI X86 Architecture Supplements
 *
 * vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t  irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
+*vbiVioapicIntMask(), vbiVioapicVectorSet(), vbiVioapicIntRedirect() 
 *           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
 */
 
@@ -752,9 +752,9 @@ void vbiInit
 * was configured to receive the IRQ. The configuration is provided in the board
 * XML configuration file as the example shown below. 
 *
-*\cs
+*
 *  <In Name="IRQ_NAME" Vector="Vector Number" Core= "1" />.  
-*\ce
+*
 *
 * The Vector number is not required to be specified in the XML. If not specified
 * the VB manager assignes a vector to an IRQ. The Guest OS can obtain the vector
@@ -762,26 +762,26 @@ void vbiInit
 * 
 * The possible values for the filter (second argument) may be:
 *
-*\ms
-*\m -
+*
+*
 * VBI_IOAPICSEND_ALL	- Send to the group of virtual boards connected to this
 *                         IRQ include the sender board.
-*\m -
+*
 * VBI_IOAPICSEND_OTHERS   - Send to the group of virtual boards connected to this IRQ
 *                         excluding the sender board
-*\m -
+*
 * VBI_IOAPICSEND_UNICAST	- Send an interrupt to the specified virtual board. This
 *		          will be delivered only if the destination board is
 *                         connected to this IRQ 
 *			  
-*\m -
+*
 * VBI_IOAPICSEND_NONE	- Ignore this call.
 *
 *
 * This routine is currently not supported for MIPS.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiVioapicIntSend 
 *             (
@@ -790,13 +790,13 @@ void vbiInit
 *             vbiVb_t target 
 *             )
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
+*vbiVioapicIntUnmask(), vbiVioapicIntMask(), vbiExcBaseSet(),
 *	    vbiVioapicIntAck(), vbiVioapicIntRedirect()
 */
 
@@ -813,19 +813,19 @@ void vbiInit
 * This routine is currently not supported for MIPS.  
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI X86 Architecture Supplements
 *
 * vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
 *           vbiVioapicIntVectorGet(), vbiVioapicIntRedirect(), vbiVioapicIntSend()
 */
 
@@ -839,18 +839,18 @@ void vbiInit
 * This routine is currently not supported for MIPS.   
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * VBI X86 Architecture Supplements
 *
 * vbiStatus_t vbiVioapicIntRedirect (vbiIrq_t irq, vbiCore_t Core)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or an error number in case of failure
 *
 * ERROR CODES: N/A
 *
-* SEE ALSO: vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
+*vbiVioapicIntUnmask(), vbiVioapicVectorSet(), vbiVioapicIntMask() 
 *           vbiVioapicIntVectorGet(), vbiVioapicIntAck(), vbiVioapicIntSend()
 */
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
index 59ec876..6c55be0 100644
--- a/kernel/vbi/msg.c
+++ b/kernel/vbi/msg.c
@@ -37,7 +37,7 @@
 * aborted before the expected message was received successfully.   
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiCtx_t vbiReceive
 *    (
@@ -46,12 +46,12 @@
 *    VBI_MSG_INFO *info  /@ status info structure pointer  @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
 *    )
-*\ce
+*
 *
 * RETURNS: sender context Id or an error number in case of failure
 *	   OK - in case of success
 *	   ERROR - in case of error	    
-* ERRNO: N/A
+*
 *
 * SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
 */
@@ -95,7 +95,7 @@ vbiStatus_t vbiReceive
 * the caller.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiReply
 *    (
@@ -104,11 +104,11 @@ vbiStatus_t vbiReceive
 *    size_t       len,   /@ length of message to reply   @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
+*
 *
 * SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
 */
@@ -122,7 +122,7 @@ vbiStatus_t vbiReceive
 * message.
 *
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiSend
 *    (
@@ -134,11 +134,11 @@ vbiStatus_t vbiReceive
 *    VBI_MSG_INFO *info  /@ status info structure pointer     @/
 *    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
-* ERRNO: N/A
+*
 *
 * SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
 */
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
index dcb55b0..8cc8fee 100644
--- a/kernel/vbi/ns.c
+++ b/kernel/vbi/ns.c
@@ -57,8 +57,8 @@ for processing.
 * manager for processing.
 *
 * SYNOPSIS
-*\cs
-* C FUNCTION
+*
+*
 * vbiStatus_t vbiNsRegister 
 *    (
 *    char    *name,		/@ name of service we're registering	@/
@@ -95,8 +95,8 @@ vbiStatus_t vbiNsRegister
 * manager for processing.
 *
 * SYNOPSIS
-*\cs
-* C FUNCTION
+*
+*
 * vbiStatus_t vbiNsUnregister 
 *    (
 *    char    *name,		/@ name of service we're unregistering	@/
@@ -134,8 +134,8 @@ vbiStatus_t vbiNsUnregister
 * formulated and sent off to the name service manager for processing.
 *
 * SYNOPSIS
-*\cs
-* C FUNCTION
+*
+*
 * vbiStatus_t vbiNsLookup 
 *    (
 *    char    *name,		/@ name of service we're unregistering	@/
diff --git a/kernel/vbi/paddr.c b/kernel/vbi/paddr.c
index d970f06..b0effbc 100644
--- a/kernel/vbi/paddr.c
+++ b/kernel/vbi/paddr.c
@@ -45,19 +45,19 @@ perhaps to communicate with the hypervisor itself maybe buffer pointers.
 * 64-bit.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiGuestPhysToPhysAddr 
 *		(
 *		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
 *		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
 *               )
-*\ce
+*
 *
 * RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
 * populated by the hypervisor with the required physical address (64-bit)
 *
-* ERRNO: N/A
+*
 *
 */
 vbiStatus_t vbiGuestPhysToPhysAddr
@@ -82,19 +82,19 @@ vbiStatus_t vbiGuestPhysToPhysAddr
 * running with > 4GB memory so the phys address is always 64-bit.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiGuestDmaAddrGet 
 *		(
 *		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
 *		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
 *               )
-*\ce
+*
 *
 * RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
 * populated by the hypervisor with the required physical address (64-bit)
 *
-* ERRNO: N/A
+*
 *
 */
 vbiStatus_t vbiGuestDmaAddrGet
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
index 5f7b990..f6ebea8 100644
--- a/kernel/vbi/shmem.c
+++ b/kernel/vbi/shmem.c
@@ -60,7 +60,7 @@ Alternatively the following macros can be used to obtained similar information
 * arguments.
 * 
 * SYNOPSIS
-*\cs
+*
 *
 * vbiStatus_t vbiShmemRegionFind
 *   (
@@ -69,11 +69,11 @@ Alternatively the following macros can be used to obtained similar information
 *   size_t *	    length,	/@ Length - OUT			@/
 *   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an errror number in case of failure
 *
-* ERRNO:                                
+*
 *
 * SEE ALSO: vbiMemRegionFind() 
 */
@@ -122,7 +122,7 @@ EXPORT_SYMBOL(vbiShmemRegionFind);
 * arguments.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiMemRegionFind
 *   (
@@ -131,7 +131,7 @@ EXPORT_SYMBOL(vbiShmemRegionFind);
 *   size_t *	    length, /@ Length - OUT		    @/
 *   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
@@ -178,14 +178,14 @@ vbiStatus_t vbiMemRegionFind
 * the running core. 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * vbiStatus_t vbiCorePrvMemFind 
 *   (
 *   void * *    addr,	    /@ Location - OUT		    @/
 *   size_t *	length	    /@ Length - OUT		    @/
 *    )
-*\ce
+*
 *
 * RETURNS: OK or an error number in case of failure
 *
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
index 36388ff..002658f 100644
--- a/kernel/vbi/show.c
+++ b/kernel/vbi/show.c
@@ -39,17 +39,17 @@ control and configuration data structures.
 * and displays the information on hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiSharedMemoryShow (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
+*
+*
 * \NOMANUAL
 */
 
@@ -87,19 +87,19 @@ void vbiSharedMemoryShow
 * and displays the information on hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiSharedMemoryShow (void)
 *
-*\ce
+*
 *
 * RETURNS: returns OK or errno in case of failure
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
 *
-*\NOMANUAL
+*
+*
+*
 */
 
 void vbiMemoryShow
@@ -131,18 +131,18 @@ void vbiMemoryShow
 * displays the information on hypervisor console.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiInterruptsShow (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
-*\NOMANUAL
+*
+*
+*
 *
 */
 
@@ -179,19 +179,19 @@ static void vbiInterruptsShow
 * This routine displays information in the status structure for a given board.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiStatusShow (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
 *
-*\NOMANUAL
+*
+*
+*
 */
 
 void vbiStatusShow
@@ -217,19 +217,19 @@ void vbiStatusShow
 * This routine displays information in the control structure for a given board.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiControlShow (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
 *
-*\NOMANUAL
+*
+*
+*
 */
 
 void vbiControlShow
@@ -265,17 +265,17 @@ void vbiControlShow
 * This routine displays information in the config structure for a given board.
 *
 * SYNOPSIS
-*\cs
+*
 * 
 * void vbiConfigShow (void)
 *
-*\ce
+*
 *
 * RETURNS: N/A
 *
-* ERRNO: N/A
 *
-* SEE ALSO: 
+*
+*
 *
 */
 
diff --git a/kernel/vbi/vmmu_doc.txt b/kernel/vbi/vmmu_doc.txt
index 07ed871..d9460ce 100644
--- a/kernel/vbi/vmmu_doc.txt
+++ b/kernel/vbi/vmmu_doc.txt
@@ -144,12 +144,12 @@ module. It is the descriptor for an VMMU context with the following info:
 * the TLB entries to ensure consistency between the processor and the page tables.
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVmmuConfig (VMMU_CONFIG * pVmmuConfig) /@ config pointer @/
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error in case of failure
 *
@@ -175,12 +175,12 @@ module. It is the descriptor for an VMMU context with the following info:
 * Hypervisor is idendity mapped (flat mapping or 1-1 translation).
 * 
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVmmuEnable (vbiVmmuIndex_t vmmuIndex) /@ vmmu Handle @/
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error in case of failure
 *
@@ -200,12 +200,12 @@ module. It is the descriptor for an VMMU context with the following info:
 * This is equivalent to calling vbiVmmuConfig(vbiVmmuIndex_t, NULL). 
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVmmuDisable (VBI_VMMU_HANDLE vmmuHandle) /@ vmmu handle @/
 *
-*\ce
+*
 *
 * RETURNS: returns OK or error in case of failure
 *
@@ -226,7 +226,7 @@ module. It is the descriptor for an VMMU context with the following info:
 * specified vmmu context will be cleared from the TLB cache
 *
 * SYNOPSIS
-*\cs
+*
 * 
 *
 * vbiStatus_t vbiVmmuTlbFlush
@@ -235,7 +235,7 @@ module. It is the descriptor for an VMMU context with the following info:
 *		void	    *addr,	/@ Starting address              @/
 *		size_t	    len)	/@ length                        @/
 *		)
-*\ce
+*
 *
 * RETURNS: returns OK or error number in case of failure
 *
-- 
1.6.5.rc3

