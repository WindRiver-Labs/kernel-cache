From 338dbb729dbec1aa637a98e9b7d066343ae6686f Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Tue, 13 Oct 2009 09:37:36 +0800
Subject: [PATCH] x86: misc code cleans

o remove useless unmask setting for irq 7, which should be used for
WRHV_POLL_IRQ. And seems we do not need kgdboe kernel option to get
kgdboe functioning. So we may clean up related code later.

o the vtlb_ops_ix can be clean to zero by hypervisor, so we just
need to increase the index and save useless '%' operation

o add wmb() to make sure cached ops can be handled by hypervisor
properly

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/x86/kernel/wrhv.c |   11 ++++-------
 1 files changed, 4 insertions(+), 7 deletions(-)

diff --git a/arch/x86/kernel/wrhv.c b/arch/x86/kernel/wrhv.c
index 9ea3182..7a3fedf 100644
--- a/arch/x86/kernel/wrhv.c
+++ b/arch/x86/kernel/wrhv.c
@@ -157,8 +157,6 @@ void __init wrhv_init_IRQ(void)
 
 	irq_ctx_init(smp_processor_id());
 
-	irq_desc[7].chip->unmask(7);
-
 	wrhv_umask_ext_int();
 
 	/* race during reboot might have left a timer interrupt
@@ -358,8 +356,7 @@ static void __devinit pci_fixup_wrhv(struct pci_dev *dev)
 		irq = vbiIntVecFind(devname, 1);
 		if (irq == VBI_INVALID_IRQ)
 			irq = WRHV_POLL_IRQ;
-		else
-			vbiVioapicIntUnmask(irq);
+		vbiIoapicIoctl(VBI_IOAPICIOCTL_UNMASK, irq, 0);
 	}
 
 	dev->irq = irq;
@@ -535,7 +532,7 @@ static void wrhv_vtlb_op (unsigned int op, unsigned long arg1, unsigned long arg
 		VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops[i].arg1 = arg1;
 		VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops[i].arg2 = arg2;
 		VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops[i].arg3 = arg3;
-
+		wmb();
 		/*
 		 * If the buffer is full, flush it. Index will be automatically
 		 * updated by the hypervisor.
@@ -544,8 +541,8 @@ static void wrhv_vtlb_op (unsigned int op, unsigned long arg1, unsigned long arg
 		if (VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops_ix == (VBI_VTLB_OP_MAX_OPS - 1))
 			vbiVtlbOp (VBI_VTLB_OP_FLUSH_OPS, 0, 0, 0);
 		else
-			VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops_ix =
-					(VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops_ix + 1) % VBI_VTLB_OP_MAX_OPS;
+			VTLB_GET_CPU_VAR(vtlb_ctrl).vtlb_ops_ix += 1;
+
 		local_irq_restore(flags);
 	}
 }
-- 
1.6.3.3

