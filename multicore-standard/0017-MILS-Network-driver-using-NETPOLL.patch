From b8f3458b7bdff329cb2b6881c34a9d53cda37bde Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Fri, 26 Feb 2010 23:45:35 -0500
Subject: [PATCH] [MILS] Network driver using NETPOLL

It is assumed that the given driver is capable of utilizing
netpoll.  If this is possible then within the hypervisor
decrementer we call the netpoll method for the associated
network driver.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/kernel/vbi/wrhv.c |   56 ++++++++++++++++++++++++++++++++++++++++
 drivers/net/gianfar.c          |   11 ++++++++
 net/core/dev.c                 |   12 ++++++++
 3 files changed, 79 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index ed07197..8ef2a5d 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -90,6 +90,7 @@
 
 #include <linux/major.h>
 #include <linux/device.h>
+#include <linux/netdevice.h>
 #include <linux/platform_device.h>
 #include <linux/of_platform.h>
 #include <linux/phy.h>
@@ -191,6 +192,44 @@ static int __init wrhv_macaddr_setup(char *str)
 
 __setup("wrhv_macaddr=", wrhv_macaddr_setup);
 
+#ifdef CONFIG_WRHV_MILS
+struct mils_net {
+	struct net_device *data;
+	struct list_head list;
+};
+
+static LIST_HEAD(mils_net_list);
+static spinlock_t mils_list_lock = SPIN_LOCK_UNLOCKED;
+
+void wrhv_netpoll_enable(struct net_device *val)
+{
+	struct mils_net *element = (struct mils_net *)kmalloc(sizeof(struct \
+		 mils_net), GFP_KERNEL);
+
+	element->data = (void *)val;
+	list_add(&element->list, &mils_net_list);
+}
+EXPORT_SYMBOL(wrhv_netpoll_enable);
+
+void wrhv_netpoll_disable(struct net_device *val)
+{
+	struct list_head *pos;
+	struct mils_net *mnet;
+
+	spin_lock(&mils_list_lock);
+	list_for_each(pos, &mils_net_list) {
+		mnet = list_entry(pos, struct mils_net, list);
+		if (mnet->data == val) {
+			list_del(&(mnet->list));
+			spin_unlock(&mils_list_lock);
+			return;
+		}
+	}
+	spin_unlock(&mils_list_lock);
+}
+EXPORT_SYMBOL(wrhv_netpoll_disable);
+#endif
+
 void wrhv_mapping(void)
 {
 	/* map in vbConfig address */
@@ -487,6 +526,9 @@ static struct clock_event_device wrhv_clockevent = {
 void wrhv_hw_timer_interrupt(struct pt_regs * regs)
 {
 	struct pt_regs *old_regs;
+#ifdef CONFIG_WRHV_MILS
+	struct mils_net *mnptr = NULL;
+#endif
 
 	if (atomic_read(&ppc_n_lost_interrupts) != 0)
 		do_IRQ(regs);
@@ -515,6 +557,20 @@ void wrhv_hw_timer_interrupt(struct pt_regs * regs)
 	set_irq_regs(old_regs);
 
 	trace_trap_exit();
+
+#ifdef CONFIG_WRHV_MILS
+	spin_lock(&mils_list_lock);
+	list_for_each_entry (mnptr, &mils_net_list, list)
+	{
+		if (mnptr->data != NULL) {
+			if (mnptr->data->poll_controller != NULL)
+			{
+				mnptr->data->poll_controller(mnptr->data);
+			}
+		}
+	}
+	spin_unlock(&mils_list_lock);
+#endif
 }
 
 void __init wrhv_clocksource_init(void)
diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index d7419e9..6e25c7d 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -711,6 +711,11 @@ void stop_gfar(struct net_device *dev)
 	spin_unlock(&priv->rxlock);
 	spin_unlock_irqrestore(&priv->txlock, flags);
 
+#ifdef CONFIG_WRHV_MILS
+	if (priv->interruptTransmit <= -1)
+		goto skip_free_irq;
+#endif
+
 	/* Free the IRQs */
 	if (priv->einfo->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
 		free_irq(priv->interruptError, dev);
@@ -720,6 +725,7 @@ void stop_gfar(struct net_device *dev)
  		free_irq(priv->interruptTransmit, dev);
 	}
 
+skip_free_irq:
 	free_skb_resources(priv);
 
 	dma_free_coherent(&dev->dev,
@@ -927,6 +933,10 @@ int startup_gfar(struct net_device *dev)
 
 	/* If the device has multiple interrupts, register for
 	 * them.  Otherwise, only register for the one */
+#ifdef CONFIG_WRHV_MILS
+	if (priv->interruptTransmit <= -1)
+		goto skip_request_irq;
+#endif
 	if (priv->einfo->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
 		/* Install our interrupt handlers for Error,
 		 * Transmit, and Receive */
@@ -972,6 +982,7 @@ int startup_gfar(struct net_device *dev)
 		}
 	}
 
+skip_request_irq:
 	phy_start(priv->phydev);
 
 	/* Configure the coalescing support */
diff --git a/net/core/dev.c b/net/core/dev.c
index 01ae913..3eda434 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -131,6 +131,12 @@
 
 #include "net-sysfs.h"
 
+#ifdef CONFIG_WRHV_MILS
+extern void wrhv_netpoll_enable(struct net_device *dev);
+extern void wrhv_netpoll_disable(struct net_device *dev);
+#endif
+
+
 /*
  *	The list of packet types we will receive (as opposed to discard)
  *	and the routines to invoke.
@@ -1089,6 +1095,9 @@ int dev_open(struct net_device *dev)
 		 *	... and announce new interface.
 		 */
 		call_netdevice_notifiers(NETDEV_UP, dev);
+#ifdef CONFIG_WRHV_MILS
+		wrhv_netpoll_enable(dev);
+#endif
 	}
 
 	return ret;
@@ -1150,6 +1159,9 @@ int dev_close(struct net_device *dev)
 	 * Tell people we are down
 	 */
 	call_netdevice_notifiers(NETDEV_DOWN, dev);
+#ifdef CONFIG_WRHV_MILS
+	wrhv_netpoll_disable(dev);
+#endif
 
 	return 0;
 }
-- 
1.7.0

