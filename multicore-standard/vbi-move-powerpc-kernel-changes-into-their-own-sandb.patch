From e3613a4cec67fd79168be3350104cf99d0667f3c Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 15 Oct 2009 15:23:55 -0400
Subject: [PATCH 14/23] vbi: move powerpc kernel changes into their own sandbox

       modified:   Makefile
       new file:   vbi/Makefile
       renamed:    vbiPpcDoc.c -> vbi/ppc_doc.txt
       renamed:    vbiPpcShow.c -> vbi/show.c
       renamed:    vbiSyscalls.S -> vbi/syscalls.S
       renamed:    vbiUtil.c -> vbi/util.c
       renamed:    vmmuDisplay.c -> vbi/vmmu_display.c
       renamed:    wrhv.c -> vbi/wrhv.c

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/Makefile           |    3 +-
 arch/powerpc/kernel/vbi/Makefile       |    5 +
 arch/powerpc/kernel/vbi/ppc_doc.txt    |  691 +++++++++++++
 arch/powerpc/kernel/vbi/show.c         |  102 ++
 arch/powerpc/kernel/vbi/syscalls.S     | 1669 ++++++++++++++++++++++++++++++++
 arch/powerpc/kernel/vbi/util.c         |  144 +++
 arch/powerpc/kernel/vbi/vmmu_display.c |  166 ++++
 arch/powerpc/kernel/vbi/wrhv.c         |  956 ++++++++++++++++++
 arch/powerpc/kernel/vbiPpcDoc.c        |  691 -------------
 arch/powerpc/kernel/vbiPpcShow.c       |  102 --
 arch/powerpc/kernel/vbiSyscalls.S      | 1669 --------------------------------
 arch/powerpc/kernel/vbiUtil.c          |  144 ---
 arch/powerpc/kernel/vmmuDisplay.c      |  166 ----
 arch/powerpc/kernel/wrhv.c             |  956 ------------------
 14 files changed, 3734 insertions(+), 3730 deletions(-)
 create mode 100644 arch/powerpc/kernel/vbi/Makefile
 create mode 100644 arch/powerpc/kernel/vbi/ppc_doc.txt
 create mode 100644 arch/powerpc/kernel/vbi/show.c
 create mode 100644 arch/powerpc/kernel/vbi/syscalls.S
 create mode 100644 arch/powerpc/kernel/vbi/util.c
 create mode 100644 arch/powerpc/kernel/vbi/vmmu_display.c
 create mode 100644 arch/powerpc/kernel/vbi/wrhv.c
 delete mode 100644 arch/powerpc/kernel/vbiPpcDoc.c
 delete mode 100644 arch/powerpc/kernel/vbiPpcShow.c
 delete mode 100644 arch/powerpc/kernel/vbiSyscalls.S
 delete mode 100644 arch/powerpc/kernel/vbiUtil.c
 delete mode 100644 arch/powerpc/kernel/vmmuDisplay.c
 delete mode 100644 arch/powerpc/kernel/wrhv.c

diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index 39af9b7..8cf4622 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -112,8 +112,7 @@ obj-$(CONFIG_8XX_MINIMAL_FPEMU) += softemu8xx.o
 
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o
 
-obj-$(CONFIG_WRHV)		+= vbiSyscalls.o vbiUtil.o wrhv.o \
-				   vmmuDisplay.o vbiPpcDoc.o vbiPpcShow.o
+obj-$(CONFIG_WRHV)		+= vbi/
 
 obj-$(CONFIG_PARAVIRT)         += paravirt.o
 
diff --git a/arch/powerpc/kernel/vbi/Makefile b/arch/powerpc/kernel/vbi/Makefile
new file mode 100644
index 0000000..daac59f
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the vbi ppc.
+#
+
+obj-y		+= syscalls.o util.o wrhv.o vmmu_display.o show.o
diff --git a/arch/powerpc/kernel/vbi/ppc_doc.txt b/arch/powerpc/kernel/vbi/ppc_doc.txt
new file mode 100644
index 0000000..b688a33
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/ppc_doc.txt
@@ -0,0 +1,691 @@
+/* ppc_doc.txt - Virtual Board Interface APIs supplement for PPC */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind RIver License agreement.
+ */
+
+/*
+modification history
+--------------------
+01j,24sep09,mpk  updates docs for vbiVbRegisterRead
+01i,10sep09,mmi  update ppc header file path
+01h,10sep09,mmi  update ppc docs
+01g,31jul09,mpk  update comments for vbiVbRegisterRead, vbiVbRegisterWrite
+01f,18jul09,mmi  fix example for mdio
+01e,18jul09,mmi  update info about sending message to bspserver
+01d,07jul09,mmi  fix int lock macro comments
+01c,12jun09,mmi  remove vioapic from here
+01b,26may09,mmi  ensure that vbiIntCoreLock returns the previous state
+01a,12may09,mmi written
+*/
+
+/*
+DESCRIPTION
+The module contains the VBI PowerPc architecture supplement. The APIs described
+below are either available only for PPC platforms or their behaviour is architecture
+dependant.
+
+\sh HYPERCALLS
+This file implements the APIs to make hypercalls to perform operations that require
+hypervisor assistant. A hypercall is based on system call trap that jumps to
+hypervisor exception handler. Some operations that are time critical are implemented
+using a mechanism referred as "fast hypercall". A fast hypercall is identical to a
+regular hypercall except that the system call handler is hand crafted to avoid the
+need of an exception stack.  In some instances they a hypercall may not even return
+(eg. context loading). 
+
+All hypercalls preserve the following registers:
+\ms 
+\m -
+	SRR0 (PC)
+\m -
+	CR (condition register)
+\m -
+	SRR1 (MSR)
+\m -
+	sp (stack pointer)
+\m -
+	lr (link register)
+\m -
+	r2 (sdata2 pointer)
+\m -
+	r13 (sdata pointer)
+\m -
+	r14-r32 (global registers)
+\me
+
+
+\sh FAST HYPERCALLS
+Following is the list of APIs that utilize fast hypercalls mechanism. 
+\ms
+\m - 
+void VBI_CTX_LOAD(void):
+This is a assembly MACRO that may be used by a guest OS to switch to a new context.
+The guest sets the register sets to be loaded in the VB control structures and calls
+this MACRO to make the hypercall.
+\m -
+vbiStatus_t vbiICacheFlush():
+This routine flushes the instruction cache for the calling core.
+\m -
+This routine flushes the data cache for the calling core.
+vbiStatus_t vbiDCacheFlush():
+\m -
+vbiStatus_t vbiIntVCoreUnlock():
+This routine unlocks interrupts for the calling core. For optimization purpose a 
+hypercall is made only if interrupts were queue while locked.
+\me
+
+\sh ACCESSING WRHV BSP DEVICES
+
+Devices that are shared between the different guests are managed by WRHV
+hyperkernel. These devices manager accepts request submitted using vbiSend().
+The guest finds the server handle by using vbiNsLookup (), initializes the
+predefined input/output message buffers then invokes vbiSend() to transmit the
+request. The input message buffer type is VBI_BSP_MSG. The reply message buffer
+type is VBI_BSP_MSG_REPLY. The request type in the input message is based on
+the nature of the request which can be one of the following types:
+\ms 
+\m - VBI_MDIO_READ for reading an MDIO register
+\m - VBI_MDIO_WRITE for modifying an MDIO register
+\m - VBI_BSP_CLK_FREQ  for reading the BSP clok frequency
+\me
+
+\cs
+\sh BSP MESSAGES BUFFER FORMAT
+
+/@ Input message format @/
+
+typedef struct vbiBspMsg
+    {
+    MSG_HEADER hdr;                     /@ message header @/
+    uint32_t   request;                 /@ request type @/
+
+    union
+        {
+        struct
+            {
+            uint32_t bus;
+            uint32_t phyAddr;
+            uint32_t regNum;
+            uint32_t page;
+            } mdioRead;
+        struct
+            {
+            uint32_t bus;
+            uint32_t phyAddr;
+            uint32_t regNum;
+            uint32_t page;
+            uint32_t dataVal;
+            } mdioWrite;
+        } arg;
+
+    } VBI_BSP_MSG;
+
+/@ Output message format @/
+
+typedef struct
+    {
+    MSG_HEADER hdr;                     /@ message header 	    @/
+    uint32_t   status;                  /@ request completion status @/
+    uint32_t   dataVal;
+    } VBI_BSP_MSG_REPLY;
+
+/@Generic message header @/
+
+typedef struct msg_header {
+    uint32_t msgId;     /@ message type identification @/
+    uint32_t msgArg;    /@ argument associated with message type @/
+} MSG_HEADER;
+
+\ce
+
+\sh Example
+\cs
+        VBI_BSP_MSG             inMsg; /@ input message buffer  @/
+        VBI_BSP_MSG_REPLY       reply; /@ output message buffer @/
+        VBI_NS_HANDLE		serviceHandle;
+        vbiStatus_t		rc;
+
+	/@ 
+	 @ What is the request type ?
+         @ VBI_MDIO_READ, VBI_MDIO_READ or VBI_BSP_CLK_FREQ
+	 @    
+	 @/
+
+        mdioMsg.request = <request type>; 
+	
+	/@ 
+         @ The input message structure is populated according to the type
+	 @ request specified. For example for writting to a phy the user
+	 @ must specify the bus, phy addr, reg number, and the input 
+	 @ value. See the union used for the inMsg type. 
+         @ The example is for writting a value to a phy register.
+         @/
+
+	/@ bus number    @/
+        
+	*((uint32_t*)&inMsg.arg.mdioRead.bus) = <phyBusNumber>;   
+	
+	/@ the phy address @/
+
+        *((uint32_t*)&inMsg.arg.mdioRead.phyAddr) = <phyaddr>;  
+	
+	/@ the register number @/
+
+        *((uint32_t*)&inMsg.arg.mdioRead.regNum) = <regNum>;	
+
+	/@ Find the destination server to send the message to @/
+
+        rc = vbiNsLookup ("bspServer", 0, &serviceHandle);
+
+        if (rc != OK)
+            kprintf ("vbiSend returned error\n");
+
+        rc = vbiSend (serviceHandle, &inMsg,
+                sizeof(inMsg), &reply, sizeof(reply), NULL, NULL);
+
+        kprintf ("replied value 0x%d\n", reply.dataVal);
+\ce
+\APPEND ../../../vbi/include/ppc/vbiPpcArch.h
+*/
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+
+/*******************************************************************************
+*
+* vbiIcacheFlush - flush the instruction cache
+*
+* This routine makes a hypercall to flush the instruction cache of the calling
+* core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiIcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the instruction cache to flush @/
+*	    size_t len  /@ length of memory to flush @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiDcacheFlush - flush the specified Data cache
+*
+* This routine makes a hypercall to flush the data cache of the calling core
+* for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiDcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the data cache to flush @/
+*	    size_t len  /@ length of memory to flush                   @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+*
+* This routine makes a hypercall to flush the data cache then invalidates the
+* instruction cache of the calling core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiCacheTextUpdate 
+*	    (
+*	    void * addr /@ starting address to perform textUpdate operation @/
+*	    size_t len  /@ length of memory in bytes			    @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*/
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreLock - lock interrupts
+*
+* This routine locks interrupts for the calling core. This is a C wrapper 
+* function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+* and returns the previous state of interrupts.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntState_t vbiIntVCoreLock (void)
+*
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+*
+* This routine enables interrupts and makes a fast hypercall if pending
+* interrupts are detected for the calling core. This is a C wrapper function for
+* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void vbiIntVCoreUnlock (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreStateGet - Get interrupts state for running core
+*
+* This routine returns the interrupts state for the calling core. This is C 
+* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+* returns TRUE if interrupts are locked otherwise FALSE.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntStatus_t vbiIntVCoreStateGet (void)
+*
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+*
+* This routine changes the exceptions vector table base address for the active
+* virtual core. By default the base address of the exception table is at address
+* 0x0.
+* If the guest OS programmer wishes to move this address then this function must
+* be called to inform hypervisor. This function must be called with interrupts
+* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcBaseSet 
+*	    (
+*	    void * excTblBase /@ New exception table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* It is possible to read registers while the target VB's core is still running
+* it doesnt have to be suspended before reading the registers.
+* 
+* SYNOPSIS
+*\cs
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_HREG_SET	*regCtl,	    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VB_HREG_SET;
+* 
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+* Target VB's core has to be suspended before writing the registers. If it
+* is still running, vbiVbRegisterWrite call will fail.
+* 
+*\cs
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VB_HREG_SET;
+* 
+*\ce 
+* VBI PPC Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_HREG_SET		*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
+*
+* This routine changes the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* If the guest OS programmer wishes to move these address then this function 
+* must be called to inform hypervisor. This function must be called with 
+* interrupts disabled to prevent hypervisor to deliver interrupts to an 
+* incorrect exception offset. The table is not validated by the hypervisor so
+* it must be complete and functional otherwize the VB will not behave as 
+* expected.
+* For SMP systems it is recommended this API be called for each core as it is
+* started up and before it's added to the scheduler for the guest OS.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsSet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsGet
+*/
+
+/*******************************************************************************
+*
+* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
+*
+* This routine gets the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsGet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsSet
+*/
diff --git a/arch/powerpc/kernel/vbi/show.c b/arch/powerpc/kernel/vbi/show.c
new file mode 100644
index 0000000..db61a75
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/show.c
@@ -0,0 +1,102 @@
+/* vbiPpcShow.c - vbi PowerPC show routines */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01d,15jun09,mmi  update vb regs
+01c,07feb09,mmi  fix build errors
+01b,22jan09,mmi  change vbCtrlRegsDisplay to vbiCrlRegsDisplay()
+01a,22jan09,mmi created
+*/
+
+/*
+This module provides the PowerPC show routines for the Virtual Board running
+on Wind River hypervisor.
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/kernel.h>
+#include <vbi/vbi.h>
+#define kprintf printk
+#else
+#include <vbi.h>
+#endif
+
+/*******************************************************************************
+*
+* vbiStsRegsDisplay - display registers from a EREG_SET
+*
+* This routine display the contents of the PowerPC emulated status registers
+* structure on the console.
+*
+*/
+
+void vbiStsRegsDisplay ()
+    {
+    VB_STATUS *p = VBI_STATUS_ADDR_GET();
+
+#if CPU == PPC85XX /* don't know how to handle cpu variant */
+    VB_PRINTF ("  srr0/srr1:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, srr0) ,
+		VB_STATUS_REGS_ACCESS (p, srr1));
+
+    VB_PRINTF ("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, mcsrr0) ,
+		VB_STATUS_REGS_ACCESS (p, mcsrr1));
+
+    VB_PRINTF ("  mcsr/mcar:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, mcsr) ,
+		VB_STATUS_REGS_ACCESS (p, mcar));
+
+    VB_PRINTF ("  dear/esr:           0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, dear) , 
+		VB_STATUS_REGS_ACCESS (p, esr));
+
+    VB_PRINTF ("  svr/pvr:            0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, svr) ,
+		VB_STATUS_REGS_ACCESS (p, pvr));
+
+    VB_PRINTF ("  hid0/hid1:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, hid0) ,
+		VB_STATUS_REGS_ACCESS (p, hid1));
+
+    VB_PRINTF ("  l1csr0/l1csr1:      0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, l1csr0) ,
+		VB_STATUS_REGS_ACCESS (p, l1csr1));
+
+    VB_PRINTF ("  bucsr:              0x%08x\n",  
+		VB_STATUS_REGS_ACCESS (p, bucsr));
+#endif
+    }
+
+/*******************************************************************************
+*
+* vbiCtrlRegsDisplay - display registers from a EREG_SET
+*
+* This routine display the contents of the PowerPC emulated status registers
+* structure on the console.
+*
+*/
+
+void vbiCtrlRegsDisplay (void)
+    {
+    VB_CONTROL * p = VBI_CNTRL_ADDR_GET();
+
+#if CPU == PPC85XX /* don't know how to handler cpu variant */
+    VB_PRINTF ("  srr0/srr1:           0x%08x 0x%08x\n", 
+		VB_CONTROL_REGS_ACCESS (p, srr0),  
+		VB_CONTROL_REGS_ACCESS (p, srr1));
+
+    VB_PRINTF ("  cr/r0:               0x%08x 0x%08x\n", 
+		VB_CONTROL_REGS_ACCESS (p, cr), 
+		VB_CONTROL_REGS_ACCESS (p, r0));
+#endif
+    }
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
new file mode 100644
index 0000000..a8fd6a7
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -0,0 +1,1669 @@
+/* vbiSyscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02j,03sep09,dtr  Fixed vbExcBaseSet.Added vbiExcOffsetsSet/Get.
+02i,02sep09,mmi  rename vbiReceive to vbiReceiveOp
+02h,27aug09,mmi  fix defect WIND00178035
+02g,06jul09,mmi  update vb mangement syscall numbers, memory read/write,
+		 registers read/write, interrupt direct op, debug shell start
+02f,26jun09,mmi  add vbiIoapicOp
+02e,23jun09,mmi  add vbi 2.0 apis
+02d,11jun09,mmi  update interrupts apis according to vbi2.0
+02c,10jun09,mmi  remove VxWorks consideration
+02b,28feb09,mmi  add vbiNsOp
+02a,09feb09,mmi  add vbMgmt API
+01z,27jan09,mmi  include vbi.h header file
+01y,23jan09,mmi  update vbiSyscall prototype in comments
+01x,18jan09,mmi  fix vbiIoapicIoctl, remove vbiShelf
+01w,12dec08,md   rename header files
+01v,11dec08,mmi  change name of VB structure pointers
+01u,02dec08,mmi  remove obsolete API's
+01t,19nov08,mmi  adopt new naming convention for vbi API's
+01s,04sep08,dcc  added vdkIoapicIoctl
+01r,20jun08,md   fix header file inclusion
+01q,19jun08,md   change VxWorks define
+01p,28nov07,foo  vdk doc
+01o,21nov07,md   include VxWorks header files if being compiled in a project
+01o,21nov07,foo  vdk interrupts
+01n,25oct07,foo  added vdkIntControllerDone, vdkIntEnable, vdkShelf	
+01m,05oct07,md   remove vxworks header files
+01l,10sep07,md   re-number hypervisor system calls
+01k,05jul07,foo  added vdkBspIoctl	
+01j,04jun07,md   added vdkHyCtxctl, vdkMmuPageProtect and vdkMmuPageUnprotect
+01i,24may07,ymz  added port system calls.
+01h,18may07,md   added vdkHyIoctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed syscalls to start with vdk
+01e,10apr07,md   split kprintf into kputs and kputc
+01d,02apr07,md   header file re-org
+01c,19mar07,foo	 fix macro names
+01b,15mar07,md   added hyInt, hyIntDone
+01a,11mar07,md   written
+*/
+
+/*
+DESCRIPTION
+
+This file implements the hypervisor system call stubs for the hypervisor.
+
+*/
+
+#define _ASMLANGUAGE
+
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#include <vbi/support/asm.h>
+#else
+#include <vbi.h>
+#include <asm.h>
+#endif /* CONFIG_WRHV */
+
+#define HCALL sc
+
+	/* globals */
+
+	FUNC_EXPORT(vbiVcoreIntRed_op)
+	FUNC_EXPORT(vbiDebugShellStart)
+	FUNC_EXPORT(vbiVbMemoryRead)
+	FUNC_EXPORT(vbiVbMemoryWrite)
+	FUNC_EXPORT(vbiVbRegisterRead)
+	FUNC_EXPORT(vbiVbRegisterWrite)
+	FUNC_EXPORT(vbiIoapicOp)
+	FUNC_EXPORT(vbiIoapicIoctl)
+	FUNC_EXPORT(vbiHyIoctl)
+	FUNC_EXPORT(vbiCtxctl)
+	FUNC_EXPORT(vbiSend)
+	FUNC_EXPORT(vbiReceiveOp)
+	FUNC_EXPORT(vbiReply)
+	FUNC_EXPORT(vbiIcacheFlush)
+	FUNC_EXPORT(vbiDcacheFlush)
+	FUNC_EXPORT(vbiCacheTextUpdate)
+	FUNC_EXPORT(vbiTlbFlush)
+	FUNC_EXPORT(vbiPanic)
+	FUNC_EXPORT(vbiPs)
+	FUNC_EXPORT(vbiKputs)
+	FUNC_EXPORT(vbiKputc)
+	FUNC_EXPORT(vbiIntVCoreUnlock)
+	FUNC_EXPORT(vbiIntVCoreLock)
+	FUNC_EXPORT(vbiExcBaseSet)
+	FUNC_EXPORT(vbiExcOffsetsSet)
+	FUNC_EXPORT(vbiExcOffsetsGet)
+	FUNC_EXPORT(vbiMemAttrSet)
+	FUNC_EXPORT(vbiMemAttrGet)
+	FUNC_EXPORT(vbiVmmuConfig)
+	FUNC_EXPORT(vbiVmmuEnable)
+	FUNC_EXPORT(vbiVmmuDisable)
+	FUNC_EXPORT(vbiVmmuTlbLoad)
+	FUNC_EXPORT(vbiVmmuTlbFlush)
+	FUNC_EXPORT(vbiVbMgmt)
+	FUNC_EXPORT(vbiNsOp)
+	FUNC_EXPORT(vbiVbSuspend)
+	FUNC_EXPORT(vbiVbReset)
+	FUNC_EXPORT(vbiVbRestart)
+	FUNC_EXPORT(vbiVbResume)
+
+	_WRS_TEXT_SEG_START
+
+/******************************************************************************
+*
+* sys_vbMgmt - virtual board management
+* 
+* This routine executes the specified command on a given virtual board. The
+* possible commands are:
+* 
+* VBI_VBMGMT_ATTACH 
+* Attach the requesting Virtual Board to the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_DETACH
+* Detatch the requesting Virtual Board from the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_SUSPEND
+* Suspends target Virtual Board from operation.  Fails if Virtual Board
+* has already been suspended
+*
+* VBI_VBMGMT_RESET
+* Resume a target virtual board.  Fails if a Virtual Board has not been
+* suspended. Currently no options are supported
+*
+* VBI_VBMGMT_RESUME
+* Restarts a target Virtual Board which has Preload=0 set in the xml file.
+* Fails if Virtual Board is preloaded (Preload=1)
+*
+* The fourth argument to this routine specifies an flag that must be defined
+* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+* The possible flgas are:
+*   VBI_VTLB_OP_UPDATE_PMD	
+*   VBI_VTLB_OP_UPDATE_PTE	
+*   VBI_VTLB_OP_DELETE_PMD	
+*   VBI_VTLB_OP_SET_PTE_AT	
+*   VBI_VTLB_OP_SET_PTE	
+*   VBI_VTLB_OP_FLUSH_OPS	
+*   VBI_VTLB_OP_INIT	
+* 
+* RETURNS: OK or error in case of failure
+* 
+*
+* int32_t sys_vbMgmt 
+*    (
+*    uint32_t cmd,	/@ attach, detach, suspend, reset or resume @/
+*    uint32_t boardId,	/@ the operation target board id @/
+*    int32_t *outError, /@ where to set error : OK or error flag @/ 
+*    uint32_t flags	/@ options required by the cmd executed @/
+*    )
+*/
+
+FUNC_LABEL(vbiVbMgmt)
+        lis     r0, HI(VBI_SYS_vbMgmt)
+        ori     r0, r0, LO(VBI_SYS_vbMgmt)
+        HCALL
+        blr
+FUNC_END(vbiVbMgmt)
+
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service.
+*
+* SYNOPSIS
+*\cs
+*
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbSuspend)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+	
+        lis     r0, HI(VBI_SYS_vbSuspend)
+        ori     r0, r0, LO(VBI_SYS_vbSuspend)
+        HCALL
+        blr
+FUNC_END(vbiVbSuspend)
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target
+* core(s) program counter to it's ENTRY function. The ENTRY function is 
+* determined based on the loaded binary image. A core does not execute beyond
+* it's ENTRY function unless vbiVbRestart() is explitly called. 
+* Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
+* option is set in the flag passed as the third argument to this routine.
+* The hypercall sends a message to a manager that provides VB managment 
+* services. 
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset
+* is not determined. The second argument identifies the cores to perform the
+* operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual
+* Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options
+* may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest
+* OS's responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
+*    vbiCore_t     core,            /@ Core within the VB           @/
+*    uint32_t     options   /@ reload , start options       @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbReset)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 * r5 - options
+	 */
+
+        lis     r0, HI(VBI_SYS_vbReset)
+        ori     r0, r0, LO(VBI_SYS_vbReset)
+        HCALL
+        blr
+FUNC_END(vbiVbReset)
+
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to
+* restart.
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+FUNC_LABEL(vbiVbRestart)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbRestart)
+        ori     r0, r0, LO(VBI_SYS_vbRestart)
+        HCALL
+        blr
+FUNC_END(vbiVbRestart)
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*/
+
+FUNC_LABEL(vbiVbResume)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbResume)
+        ori     r0, r0, LO(VBI_SYS_vbResume)
+        HCALL
+        blr
+FUNC_END(vbiVbResume)
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiSend)
+
+	/*
+	 * r3 - ctx id
+	 * r4 - smsg pointer 
+	 * r5 - size of smsg 
+	 * r6 - rmsg pointer
+	 * r7 - rmsg length
+	 * r8 - info pointer
+	 * r9 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_send)
+	ori	r0, r0, LO(VBI_SYS_send)
+	HCALL
+	blr
+FUNC_END(vbiSend)
+
+/*******************************************************************************
+*
+* vbiReceiveOp - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiCtx_t vbiReceiveOp
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReceiveOp)
+
+	/*
+	 * r3 - smsg pointer 
+	 * r4 - size of smsg 
+	 * r5 - info pointer
+	 * r6 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_receive)
+	ori	r0, r0, LO(VBI_SYS_receive)
+	HCALL
+	blr
+FUNC_END(vbiReceiveOp)
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t	    id,    /@ context id to reply the message to    @/
+*    void *	    buff,  /@ pointer to reply message		    @/
+*    size_t	    len,   /@ length of message to reply	    @/
+*    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReply)
+	lis	r0, HI(VBI_SYS_reply)
+	ori	r0, r0, LO(VBI_SYS_reply)
+	HCALL
+	blr
+FUNC_END(vbiReply)
+
+/*******************************************************************************
+*
+* vbiKputs - print a string on the hypervisor kernel console
+*
+* This routine makes a hypercall and prints a string of characters to to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputc() 
+*/
+
+FUNC_LABEL(vbiKputs)
+	lis	r0, HI(VBI_SYS_kputs)
+	ori	r0, r0, LO(VBI_SYS_kputs)
+	HCALL
+	blr
+FUNC_END(vbiKputs)
+
+/*******************************************************************************
+*
+* vbiKputc - print a character on the hypervisor kernel console
+*
+* This routine makes a hypercall in order to print the specified character to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputc (int c) /@ character to print @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputs()
+*/
+
+FUNC_LABEL(vbiKputc)
+	lis	r0, HI(VBI_SYS_kputc)
+	ori	r0, r0, LO(VBI_SYS_kputc)
+	HCALL
+	blr
+FUNC_END(vbiKputc)
+
+/*******************************************************************************
+*
+* vbiPanic - halt the system and dump debug info 
+*
+* This routine makes a hypercall in order to halt the system and display debug
+* information on hypervisor console. If hypervisor is configured with
+* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
+* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
+* the offending cores registers dump is displayed on hypervisor console. If
+* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
+* the debug manager.
+*
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiPanic (const char *msg) /@ pointer to message to print @/
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+FUNC_LABEL(vbiPanic)
+	lis	r0, HI(VBI_SYS_panic)
+	ori	r0, r0, LO(VBI_SYS_panic)
+	HCALL
+	blr
+FUNC_END(vbiPanic)
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine 
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running. 
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart 
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          ) 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiDebugShellStart)
+
+	/* r3 - flags for attachement behaviour */
+
+	lis	r0, HI(VBI_SYS_dbgShStart)
+	ori	r0, r0, LO(VBI_SYS_dbgShStart)
+	HCALL
+	blr
+FUNC_END(vbiDebugShellStart)
+
+/*******************************************************************************
+*
+* vbiIcacheFlush - flush the instruction cache
+*
+* This routine makes a hypercall to flush the instruction cache of the calling
+* core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiIcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the instruction cache to flush @/
+*	    size_t len  /@ length of memory to flush @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush()
+*/
+
+FUNC_LABEL(vbiIcacheFlush)
+	lis	r0, HI(VBI_SYS_icache_flush)
+	ori	r0, r0, LO(VBI_SYS_icache_flush)
+	HCALL
+	blr
+FUNC_END(vbiIcacheFlush)
+
+/*******************************************************************************
+*
+* vbiDcacheFlush - flush the specified Data cache
+*
+* This routine makes a hypercall to flush the data cache of the calling core
+* for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiDcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the data cache to flush @/
+*	    size_t len  /@ length of memory to flush                   @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiDcacheFlush)
+	lis	r0, HI(VBI_SYS_dcache_flush)
+	ori	r0, r0, LO(VBI_SYS_dcache_flush)
+	HCALL
+	blr
+FUNC_END(vbiDcacheFlush)
+
+
+/******************************************************************************
+*
+* vbiTlbFlush - flush an MMU TLB entry
+*
+* This system call flushes the TLB associated with the specified context id 
+*
+* C interface:
+*
+*   vbiTlbFlush (unsigned int id) /@ the entry to flush @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiTlbFlush)
+	lis	r0, HI(VBI_SYS_tlb_flush)
+	ori	r0, r0, LO(VBI_SYS_tlb_flush)
+	HCALL
+	blr
+FUNC_END(vbiTlbFlush)
+
+/*******************************************************************************
+*
+* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+*
+* This routine enables interrupts and makes a fast hypercall if pending
+* interrupts are detected for the calling core. This is a C wrapper function for
+* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void vbiIntVCoreUnlock (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreUnlock)
+	
+	lis	p0, HIADJ(wrhvVbControl)
+	lwz	p0, LO(wrhvVbControl)(p0)
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+	
+tryAgain:		
+	lis	p0, HIADJ(wrhvVbStatus)
+	lwz	p0, LO(wrhvVbStatus)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+	
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis	r0, HI(VBI_SYS_int_enable)
+	ori	r0, r0, LO(VBI_SYS_int_enable)
+	HCALL
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbiIntVCoreUnlock)
+
+ /*******************************************************************************   
+ *
+ * vbiIntVCoreLock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper 
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ * SYNOPSIS
+ *\cs
+ * 
+ * VBI PPC Architecture Supplements
+ *
+ * vbiIntState_t vbiIntVCoreLock (void)
+ *
+ *\ce
+ *
+ * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
+ *
+ * ERROR CODES: N/A
+ *
+ * SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+ *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+ */
+
+FUNC_LABEL(vbiIntVCoreLock)
+	li	p1, -1
+	lis	p2, HIADJ(wrhvVbControl)
+	lwz	p2, LO(wrhvVbControl)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+	blr
+FUNC_END(vbiIntVCoreLock)
+
+/*******************************************************************************
+*
+* vbiIntVCoreStateGet - Get interrupts state for running core
+*
+* This routine returns the interrupts state for the calling core. This is C 
+* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+* returns TRUE if interrupts are locked otherwise FALSE.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntStatus_t vbiIntVCoreStateGet (void)
+*
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreStateGet)
+    lis	p2, HIADJ(wrhvVbControl)
+    lwz	p2, LO(wrhvVbControl)(p2)
+    lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+    blr
+FUNC_END(vbiIntVCoreStateGet)
+
+/*******************************************************************************
+*
+* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+*
+* This routine changes the exceptions vector table base address for the active
+* virtual core. By default the base address of the exception table is at address
+* 0x0.
+* If the guest OS programmer wishes to move this address then this function must
+* be called to inform hypervisor. This function must be called with interrupts
+* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcBaseSet 
+*	    (
+*	    void * excTblBase /@ New exception table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+FUNC_LABEL(vbiExcBaseSet)
+
+	/* 
+	 * r3 has the base address to set; make sure it is aligned  
+	 * align to 32 bytes  
+	 */	    
+
+	andi. r4, r3, 31
+	cmpwi r4, 0
+	bne- baseAlignError
+
+	/* set command for the ioctl */
+
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCBASE
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+baseAlignError:
+	li r3, VBI_EXCBASE_SET_ERROR
+	blr	
+
+FUNC_END(vbiExcBaseSet)
+
+/*******************************************************************************
+*
+* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
+*
+* This routine changes the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* If the guest OS programmer wishes to move these address then this function 
+* must be called to inform hypervisor. This function must be called with 
+* interrupts disabled to prevent hypervisor to deliver interrupts to an 
+* incorrect exception offset. The table is not validated by the hypervisor so
+* it must be complete and functional otherwize the VB will not behave as 
+* expected.
+* For SMP systems it is recommended this API be called for each core as it is
+* started up and before it's added to the scheduler for the guest OS.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsSet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsGet
+*/
+
+FUNC_LABEL(vbiExcOffsetsSet)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_SET
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbiExcOffsetsSet)
+
+/*******************************************************************************
+*
+* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
+*
+* This routine gets the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsGet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsSet
+*/
+
+FUNC_LABEL(vbiExcOffsetsGet)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_GET
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbiExcOffsetsGet)
+
+/*******************************************************************************
+*
+* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+*
+* This routine makes a hypercall to flush the data cache then invalidates the
+* instruction cache of the calling core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiCacheTextUpdate 
+*	    (
+*	    void * addr /@ starting address to perform textUpdate operation @/
+*	    size_t len  /@ length of memory in bytes			    @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiCacheTextUpdate)
+	lis	r0, HI(VBI_SYS_cache_text_update)
+	ori	r0, r0, LO(VBI_SYS_cache_text_update)
+	HCALL
+	blr
+FUNC_END(vbiCacheTextUpdate)
+
+/******************************************************************************
+*
+* vbiVmmuConfig - configure the hypervisor virtual MMU
+*
+* This system call configures the context's virtual MMU within the hypervisor.
+*
+* C interface:
+*
+*   vbiVmmuConfig (VMMU_CONFIG *config) /@ The vmmu configuration @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuConfig)
+	lis	r0, HI(VBI_SYS_vmmu_config)
+	ori	r0, r0, LO(VBI_SYS_vmmu_config)
+	HCALL
+	blr
+FUNC_END(vbiVmmuConfig)
+
+
+/******************************************************************************
+*
+* vbiVmmuEnable - enables the virtual MMU
+*
+* This system call enables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuEnable (unsigned int vmmu_num) /@ Enable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuEnable)
+	lis	r0, HI(VBI_SYS_vmmu_enable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
+	HCALL
+	blr
+FUNC_END(vbiVmmuEnable)
+
+
+/******************************************************************************
+*
+* vbiVmmuDisable - disable the virtual MMU
+*
+* This system call disables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuDisable (unsigned int vmmu_num) /@ Disable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuDisable)
+	lis	r0, HI(VBI_SYS_vmmu_disable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
+	HCALL
+	blr
+FUNC_END(vbiVmmuDisable)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
+*
+* This system call loads the TLB entries for the specified address range into
+* the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbLoad (VMMU_CONFIG *config, /@ The VMMU being used @/
+*                   void *addr,		 /@ Starting address    @/
+*                   unsigned int len)    /@ length              @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbLoad)
+	lis	r0, HI(VBI_SYS_vmmu_tlbload)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
+	HCALL
+	blr
+FUNC_END(vbiVmmuTlbLoad)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
+*
+* This system call flushes the TLB entries for the specified address range
+* from the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbFlush (VMMU_CONFIG *config, /@ The VMMU configuration to use @/
+*		     void *addr,          /@ Starting address              @/
+*		     unsigned int len)    /@ length                        @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbFlush)
+	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
+	HCALL
+	blr
+FUNC_END(vbiVmmuTlbFlush)
+
+
+/******************************************************************************
+*
+* vbiHyIoctl - hypervisor ioctl call
+*
+* This system call interfaces to the general purpose hypervisor ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_HYIOCTL_GETPID
+*     VBI_HYIOCTL_GETPRIORITY
+*     VBI_HYIOCTL_PSDISPLAY
+*     VBI_HYIOCTL_GETSTATS
+*     VBI_HYIOCTL_EXCBASE
+*		
+* C interface:
+*
+*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*               void *arg)          /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiHyIoctl)
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbiHyIoctl)
+
+/******************************************************************************
+*
+* vbiCtxctl - hypervisor context control call
+*
+* This system call interfaces to the general purpose hypervisor context
+* control function.
+*
+* Possbile operations:
+*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+*
+* C interface:
+*
+*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
+*		 void *arg)		 /@ address of argument @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiCtxctl)
+	lis	r0, HI(VBI_SYS_ctxctl)
+	ori	r0, r0, LO(VBI_SYS_ctxctl)
+	HCALL
+	blr
+FUNC_END(vbiCtxctl)
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrSet)
+	lis	r0, HI(VBI_SYS_mmu_attr_set)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
+	HCALL
+	blr
+FUNC_END(vbiMemAttrSet)
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrGet)
+	lis	r0, HI(VBI_SYS_mmu_attr_get)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
+	HCALL
+	blr
+FUNC_END(vbiMemAttrGet)
+
+/******************************************************************************
+*
+* vbiIoapicIoctl - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function. For PPC this is a nop routine for now.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*                   unsigned arg1,      /@ address of information @/
+*                   unsigned arg2)      /@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicIoctl)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	HCALL
+	blr
+FUNC_END(vbiIoapicIoctl)
+
+/******************************************************************************
+*
+* vbiNsOp - virtua board name service call
+*
+* This system call interfaces to the virtual board
+*
+* commands:
+*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+*				
+* C interface:
+*
+*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
+*	    char * name,		    /@ the service name		@/
+*	    uint32_t revision,	    /@ service revision		@/
+*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
+*	  )
+*
+* Returns: OK or ERROR in case of failure
+*
+*/
+
+FUNC_LABEL(vbiNsOp)
+	lis   r0, HI(VBI_SYS_ns_op)
+	ori	r0, r0, LO(VBI_SYS_ns_op)
+	HCALL
+	blr
+FUNC_END(vbiNsOp)
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryRead)
+	lis   r0, HI(VBI_SYS_memRead_op)
+	ori	r0, r0, LO(VBI_SYS_memRead_op)
+	HCALL
+	blr
+FUNC_END(vbiVbMemoryRead)
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryWrite)
+	lis	r0, HI(VBI_SYS_memWrite_op)
+	ori	r0, r0, LO(VBI_SYS_memWrite_op)
+	HCALL
+	blr
+FUNC_END(vbiVbMemoryWrite)
+
+/******************************************************************************
+*
+* vbiIoapicOp - virtual IO APIC operation
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicOp (unsigned int ioctl,	/@ the ioctl command      @/
+*                vbiIrq_t irq,		/@ address of information @/
+*                uint32_t filter),      /@ address of information @/
+*                vbiVb_t vbId)		/@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicOp)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	HCALL
+	blr
+FUNC_END(vbiIoapicOp)
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* SYNOPSIS
+*\cs
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterRead)
+	lis   r0, HI(VBI_SYS_RegsRead_op)
+	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
+	HCALL
+	blr
+FUNC_END(vbiVbRegisterRead)
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+*\cs
+*typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*\ce 
+* VBI PPC Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterWrite)
+	lis   r0, HI(VBI_SYS_RegsWrite_op)
+	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
+	HCALL
+	blr
+FUNC_END(vbiVbRegisterWrite)
+
+
+/*******************************************************************************
+*
+* vbiVcoreIntRed_op - redirect an irq to another vcore
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVcoreIntRed_op 
+*	(
+*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
+*	vbiCore_t		core	/@ destination vcore		 @/
+*	)
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: vbiVioapicIntRedirect()
+* 
+*\NOMANUAL
+*/
+
+FUNC_LABEL(vbiVcoreIntRed_op)
+	lis   r0, HI(VBI_SYS_intRedirect)
+	ori	r0, r0, LO(VBI_SYS_intRedirect)
+	HCALL
+	blr
+FUNC_END(vbiVcoreIntRed_op)
diff --git a/arch/powerpc/kernel/vbi/util.c b/arch/powerpc/kernel/vbi/util.c
new file mode 100644
index 0000000..1f46f86
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/util.c
@@ -0,0 +1,144 @@
+/* vbi/vbiUtil.c - utilities routines for guest OS para-virtualization */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01a,17jul07, ymz written
+02a,08nov07, mb  moved wrhv_int_lock and friends from init/main.c; formatting fixes
+*/
+
+/*
+This module implements a library which is handy for para-virtualized
+guest os to use. The routines are developed based on the need while
+para-virtualize linux, therefore, may need some tweaks to be generic.
+*/
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <vbi/interface.h>
+#include <vbi/support/sys/vmmu.h>
+#include <vbi/syscall.h>
+
+
+/* defines */
+
+/* globals */
+
+/*
+ * wrhvConfig is initialized as part of the guest os init, before os turns on
+ * MMU. For paravirualized linux, it is initialized in plaform_init().
+ */
+
+extern VB_CONFIG *wrhvConfig;
+extern VB_STATUS *wrhvStatus;
+extern VB_CONTROL *wrhvControl;
+
+/* local */
+
+/* extern */
+extern void pteAttrSet(VMMU_PTE * pte, u_int attr);
+extern void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon);
+
+/* forward declarations */
+
+unsigned int vb_memsize_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig) {
+		/* vb_memsize_get should not be called before wrhvConfig is init,
+		 * REALLY
+		 */
+		return 0;
+	}
+
+	return (((VB_CONFIG *) wrhvConfig)->physicalMemorySize);
+}
+
+unsigned int vb_context_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig)
+		return 0xdeadbee0;
+	return (((VB_CONFIG *) wrhvConfig)->pid);
+}
+
+void vb_pte_set(void *pPte, unsigned long paddr, int protval)
+{
+
+	/* caller has guaranteed pPte != NULL */
+
+	*(uint *) pPte = (uint) VMMU_PTE_VALID_MASK;
+
+	/* linux uses more than the permission bits, in word1 of PTE */
+
+	*((uint *) ((uint *) pPte) + 1) = (((u_int) paddr & VMMU_PTE_RPN_MASK) | (protval & 0xfff));
+
+	return;
+}
+
+/*
+ * turn on mmu for the particular context
+ *
+ * note, caller must make sure, context switch inside the guest OS must
+ * not happen during this call.
+ */
+
+int vb_context_mmu_on(int pid,	/* context id */
+		      void *pgtable,	/* level 1 page table */
+		      int pagesize, int debug)
+{
+	static VMMU_CONFIG vmmu_cfg;
+
+	if ((VB_CONFIG *) - 1 == wrhvConfig || NULL == pgtable || pagesize <= 0)
+		return -1;
+
+	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
+	vmmu_cfg.pageSize = pagesize;
+	vmmu_cfg.contextId = pid;
+	vmmu_cfg.vmmuNum = 0;	/* only vmmu 0 is support for the time being */
+
+	if ((vbiVmmuConfig(&vmmu_cfg)) != 0)
+		return -1;
+
+	if (debug) {
+		printk("L1 page table address %p\n", pgtable);
+		vmmuPageTableDisplay(pgtable, 0);
+		printk("End of page table display \n");
+	}
+
+	vbiVmmuEnable(vmmu_cfg.vmmuNum);
+
+	return 0;
+}
+
+void vb__flush_dcache_icache(void *start)
+{
+	vbiIcacheFlush(start, 4096);
+	vbiDcacheFlush(start, 4096);
+}
+
+void vb_flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	vbiDcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_icache_range(unsigned long start, unsigned long stop)
+{
+	vbiIcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_dcache_icache_phys(unsigned long physaddr)
+{
+	vbiIcacheFlush((void *) physaddr, 4096);
+	vbiDcacheFlush((void *) physaddr, 4096);
+}
+
+EXPORT_SYMBOL_GPL(wrhv_int_lock);
+EXPORT_SYMBOL_GPL(wrhv_int_unlock);
+EXPORT_SYMBOL_GPL(wrhv_int_lvl_get);
diff --git a/arch/powerpc/kernel/vbi/vmmu_display.c b/arch/powerpc/kernel/vbi/vmmu_display.c
new file mode 100644
index 0000000..237797a
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/vmmu_display.c
@@ -0,0 +1,166 @@
+/* vbi/vmmuDisplay.c - hypervisor VMMU operations */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,03may07,md   removed vxWorks.h
+01a,19apr07,md   written
+*/
+
+/*
+This module displays the contents of a VMMU page table
+*/
+
+#include <linux/kernel.h>
+#include <vbi/interface.h>
+#include <vbi/support/sys/vmmu.h>
+
+#define __va(paddr) (((unsigned long )(paddr))+0xC0000000)
+#define __pa(vaddr) (((unsigned long )(vaddr))-0xC0000000)
+
+
+/*******************************************************************************
+*
+* vmmuPageTableDisplay - display information about the specified page table
+*
+* This routine display all the VMMU PTE entries in the specified table
+*
+*/
+
+void vmmuPageTableDisplay
+    (
+    VMMU_LEVEL_1_DESC *l1,
+    int                vmmuon
+    )
+    {
+    VMMU_LEVEL_2_DESC  *l2;
+    VMMU_PTE	       *pte;
+    VMMU_EFFECTIVE_ADDR ea;
+    u_int l1_index;
+    u_int i,j;
+
+    l1_index = 0;
+    ea.addr = 0;
+
+    printk ("Logical           Physical          R C U[01234567] WIMGE S[XWR] U[XWR]\n");
+    printk ("----------------- ----------------- - -  ---------- -----  -----  -----\n");
+
+    /* run through all the entries */
+
+    for (i=0; i<VMMU_L1_ENTRIES; i++)
+	{
+	if (l1->field.v)
+	    {
+	    ea.field.l1index = l1_index;
+	    l2 = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba);
+    	    if (vmmuon)
+                l2 = __va (l2);
+	    pte = (VMMU_PTE *)l2;
+	    for (j=0; j<VMMU_L2_ENTRIES; j++)
+		{
+		if (pte->field.v)
+		    {
+		    ea.field.l2index = j;
+		    printk ("%08x-%08x %08x-%08x %d %d ",
+			ea.addr, (u_int)ea.addr + 0xfff,
+			pte->field.rpn << VMMU_RPN_SHIFT,
+			(pte->field.rpn << VMMU_RPN_SHIFT) + 0xfff,
+			pte->field.r, pte->field.c);
+		    printk ("  %d%d%d%d%d%d%d%d  %d%d%d%d%d   %c%c%c    %c%c%c\n",
+			pte->field.u0, pte->field.u1,
+			pte->field.u2, pte->field.u3,
+			pte->field.u4, pte->field.u5,
+			pte->field.u6, pte->field.u7,
+			pte->field.w, pte->field.i, pte->field.m,
+			pte->field.g, pte->field.e,
+			pte->field.sx ? 'X' : ' ',
+			pte->field.sw ? 'W' : ' ',
+			pte->field.sr ? 'R' : ' ',
+			pte->field.ux ? 'X' : ' ',
+			pte->field.uw ? 'W' : ' ',
+			pte->field.ur ? 'R' : ' ');
+		    }
+		pte++;
+		}
+	    }
+	l1++;
+	l1_index++;
+	}
+    }
+
+/*******************************************************************************
+*
+* vmmuPteDisplay - display a specific PTE entry
+*
+* This routine display the VMMU PTE entrie corresponding to the specified
+* virtual address.
+*
+*/
+
+unsigned int vmmuPteDisplay
+    (
+    VMMU_LEVEL_1_DESC *l1, /* pointer to level-1 page table */
+    void   *vaddr	   /* virtual address to display */
+    )
+    {
+    volatile VMMU_LEVEL_2_DESC  *l2;
+    VMMU_PTE	       *pte;
+
+    /* find the level-1 page table descriptor for the virtual address */
+
+    l1 += VMMU_L1_INDEX(vaddr);
+
+    /* if no level-2 table exists abort and return error */
+
+    if (!l1->field.v)
+	{
+	return (-1);
+	}
+
+    /* locate correct PTE entry in level-2 table */
+
+    l2  = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba) +
+	   VMMU_L2_INDEX(vaddr);
+
+    l2 = __va (l2);
+
+    pte = &l2->pte;
+
+    /* if pte is not valid abort and return error */
+
+    if (!pte->field.v)
+	{
+	return (-1);
+	}
+
+    printk ("PTE for virtual address 0x%08x:\n", vaddr);
+    printk ("  Page Number:  0x%08x\n", pte->field.rpn<<VMMU_RPN_SHIFT);
+    printk ("  Referenced:   %d\n", pte->field.r);
+    printk ("  Changed:      %d\n", pte->field.c);
+    printk ("  User bits:    %d%d%d%d%d%d%d%d\n",
+	pte->field.u0, pte->field.u1,
+	pte->field.u2, pte->field.u3,
+	pte->field.u4, pte->field.u5,
+	pte->field.u6, pte->field.u7);
+    printk ("  WIMGE:        %d%d%d%d%d\n",
+	pte->field.w, pte->field.i, pte->field.m,
+	pte->field.g, pte->field.e);
+    printk ("  Supv Perms:   %c%c%c\n",
+	pte->field.sr ? 'R' : '-',
+	pte->field.sw ? 'W' : '-',
+	pte->field.sx ? 'X' : '-');
+    printk ("  User Perms:   %c%c%c\n",
+	pte->field.ur ? 'R' : '-',
+	pte->field.uw ? 'W' : '-',
+	pte->field.ux ? 'X' : '-');
+
+    return (0);
+    }
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
new file mode 100644
index 0000000..7b020a7
--- /dev/null
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -0,0 +1,956 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2009 Wind River Systems, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/profile.h>
+#include <linux/wrhv.h>
+#include <linux/interrupt.h>
+#include <vbi/interface.h>
+#include <vbi/interrupt.h>
+#include <vbi/errors.h>
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+
+#include <linux/threads.h>
+#include <linux/kernel_stat.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <trace/trap.h>
+
+#include <linux/seq_file.h>
+#include <linux/cpumask.h>
+#include <linux/bitops.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+#include <linux/mutex.h>
+#include <linux/bootmem.h>
+#include <linux/pci.h>
+#include <linux/debugfs.h> 
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/cache.h>
+#include <asm/prom.h>
+#include <asm/machdep.h>
+#include <asm/udbg.h>
+#include <asm/firmware.h>
+
+#include <asm/pgalloc.h>
+#include <asm/mmu_context.h>
+#include <asm/mmu.h>
+#include <asm/smp.h>
+#include <asm/btext.h>
+#include <asm/tlb.h>
+#include <asm/sections.h>
+
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/highmem.h>
+#include <linux/initrd.h>
+#include <linux/pagemap.h>
+
+#include <linux/kprobes.h>
+#include <linux/kexec.h>
+#include <linux/backlight.h>
+#include <linux/bug.h>
+#include <linux/kdebug.h>
+#include <linux/ltt-core.h>
+#include <linux/kallsyms.h>
+
+#include <mm/mmu_decl.h>
+#include <linux/lmb.h>
+
+#include <linux/major.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+#include <linux/spi/spi.h>
+#include <linux/fsl_devices.h>
+#include <linux/fs_enet_pd.h>
+#include <linux/fs_uart_pd.h>
+
+#include <asm/irq.h>
+#include <sysdev/fsl_soc.h>
+#include <asm/cpm2.h>
+
+#include <linux/kgdb.h>
+#include <asm/current.h>
+#include <asm/processor.h>
+
+#include <asm/paravirt.h>
+
+
+/* powerpc clocksource/clockevent code */
+
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+
+static VB_CONFIG __wrhvConfig;
+VB_CONFIG *wrhvConfig;  /* TODO kernel relocation friendly ? */
+VB_CONTROL *wrhvControl;
+VB_STATUS *wrhvStatus;
+VB_CONFIG *razorConfig;
+EXPORT_SYMBOL(wrhvConfig);
+EXPORT_SYMBOL(razorConfig);
+
+void wrhv_mapping(void);
+void mpc85xx_power_down(void);
+
+extern int map_page(unsigned long, phys_addr_t, int);
+
+extern int vb_context_mmu_on(int pid,  /* context id */
+			void *pgtable,    /* level 1 page table */
+			int pagesize, int debug);
+
+unsigned long wrhv_cpu_freq = 0;
+
+void wrhv_mapping(void)
+{
+	/* map in vbConfig address */
+
+	/* WRHV VB_CONFIG should really add a length field for each
+	 * of the objected we mapped.  As the sizes are WRHV
+	 * implementation AND worse, configuration dependent.
+	 *
+	 * For now, we just use 1 page which is fine for the time being.
+	 */
+
+	map_page((unsigned long)wrhvConfig, (unsigned long)wrhvConfig,
+		 _PAGE_RAM);
+
+	map_page((unsigned long)wrhvConfig->vbStatus,
+		 (unsigned long)wrhvConfig->vbStatus, _PAGE_RAM);
+	map_page((unsigned long)wrhvConfig->vbControl,
+		 (unsigned long)wrhvConfig->vbControl, _PAGE_RAM);
+	map_page((unsigned long)wrhvConfig->interruptConfiguration,
+		 (unsigned long)wrhvConfig->interruptConfiguration, _PAGE_RAM);
+	map_page((unsigned long)wrhvConfig->vbControl->vIoapic,
+		 (unsigned long)wrhvConfig->vbControl->vIoapic, _PAGE_RAM);
+
+	razorConfig = wrhvConfig;
+	memcpy(&__wrhvConfig, wrhvConfig, sizeof(__wrhvConfig));
+	/* map any shared memory region info */
+
+	if (wrhvConfig->sharedMemoryRegionsConfigAddress != 0)
+		map_page((unsigned long)wrhvConfig->
+			 sharedMemoryRegionsConfigAddress,
+			 (unsigned long)wrhvConfig->
+			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
+	/* MIPC */
+	map_page(0xfd000000, 0xfd000000, _PAGE_IO);
+	/* devices mapped by the hypervisor xml coqnfiguration */
+
+	return;
+}
+
+unsigned long __init wrhv_find_end_of_memory(void)
+{
+	return wrhvConfig->physicalMemorySize;
+}
+
+void wrhv_power_save(void)
+{
+	local_irq_enable();
+	vbiIdle(1);
+}
+
+void wrhv_restart(void)
+{
+	int ret;
+	vbiVbMgmt(VBI_VBMGMT_RESET, __wrhvConfig.pid, &ret,
+			VBI_VBMGMT_RESET_CLEAR,0);
+	while (1);
+}
+
+static struct irqaction wrhv_timer_irq = {
+	.handler = wrhv_timer_interrupt,
+	.flags= IRQF_DISABLED,
+	.mask = CPU_MASK_NONE,
+	.name = "timer",
+};
+
+void __init wrhv_calibrate_decr(void)
+{
+	/* The timebase is updated every 8 bus clocks */
+	ppc_tb_freq = wrhv_cpu_freq / 8;
+	printk(KERN_DEBUG "WRHV-TIME: wrhv_cpu_freq=%lu  ppc_tb_freq =%lu\n",
+			wrhv_cpu_freq, ppc_tb_freq);
+	
+}
+
+void __init wrhv_time_init(void)
+{
+	return;
+}
+
+void __init wrhv_init_irq(void)
+{
+	int i;
+
+	wrhv_irq_chip.typename = "WRHV-PIC";
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED | IRQ_LEVEL;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+		set_irq_chip_and_handler(i, &wrhv_irq_chip, handle_fasteoi_irq);
+	}
+}
+
+#ifdef CONFIG_DEBUG_VIRTUAL_IRQS
+static irqreturn_t wrhv_vbint(int irq, void * dev_id)
+{
+	printk("[DEBUG VIRTUAL IRQS] Handling the DEBUG IRQ %d\n", irq);
+	return IRQ_HANDLED;
+}
+
+static int __init wrhv_late_init_irq(void)
+{
+	int dev_id = 1;
+	int i;
+
+	/* IRQ 0 is unknown IRQ number for Hypervisor */
+	for (i = 1; i < 32; i++) {
+		if(request_irq(i, wrhv_vbint, IRQF_SHARED, "vbint_single", &dev_id))
+			printk("Unable request IRQ for IRQ %d\n", i);
+	}
+
+	return 0;
+}
+subsys_initcall(wrhv_late_init_irq);
+#endif
+
+unsigned int wrhv_vioapic_get_irq(void)
+{
+	unsigned int irq;
+
+	irq = wrhvControl->intPending;
+
+#ifdef CONFIG_DEBUG_VIRTUAL_IRQS
+	/* Maybe this is useless for real external interrupt */
+	wrhvStatus->intPending = 0;
+#endif
+
+	if (irq == 0xffff)
+		irq = NO_IRQ_IGNORE;
+	else
+		wrhvControl->intPending = 0xffff;
+
+	return irq;
+}
+
+/* refer to native implementation in arch/powerpc/kernel/irq.c */
+extern int get_ppc_spurious_interrupts(void);
+extern void set_ppc_spurious_interrupts(int value);
+
+void wrhv_do_IRQ(struct pt_regs *regs)
+{
+        struct pt_regs *old_regs = set_irq_regs(regs);
+        unsigned int irq;
+#ifdef CONFIG_IRQSTACKS
+        struct thread_info *curtp, *irqtp;
+#endif
+
+        irq_enter();
+
+#ifdef CONFIG_DEBUG_STACKOVERFLOW
+        /* Debugging check for stack overflow: is there less than 2KB free? */
+        {
+                long sp;
+
+                sp = __get_SP() & (THREAD_SIZE-1);
+
+                if (unlikely(sp < (sizeof(struct thread_info) + 2048))) {
+                        printk("do_IRQ: stack overflow: %ld\n",
+                                sp - sizeof(struct thread_info));
+                        dump_stack();
+                }
+        }
+#endif
+
+        /*
+         * Every platform is required to implement ppc_md.get_irq.
+         * This function will either return an irq number or NO_IRQ to
+         * indicate there are no more pending.
+         * The value NO_IRQ_IGNORE is for buggy hardware and means that this
+         * IRQ has already been handled. -- Tom
+         */
+#ifdef CONFIG_WRHV
+check_again:
+#endif
+        irq = ppc_md.get_irq();
+
+        if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
+#ifdef CONFIG_IRQSTACKS
+                /* Switch to the irq stack to handle this */
+                curtp = current_thread_info();
+                irqtp = hardirq_ctx[smp_processor_id()];
+                if (curtp != irqtp) {
+                        struct irq_desc *desc = irq_desc + irq;
+                        void *handler = desc->handle_irq;
+                        unsigned long saved_sp_limit = current->thread.ksp_limit;
+                        if (handler == NULL)
+                                handler = &__do_IRQ;
+                        irqtp->task = curtp->task;
+                        irqtp->flags = 0;
+
+                        /* Copy the softirq bits in preempt_count so that the
+                         * softirq checks work in the hardirq context.
+                         */
+                        irqtp->preempt_count =
+                                (irqtp->preempt_count & ~SOFTIRQ_MASK) |
+                                (curtp->preempt_count & SOFTIRQ_MASK);
+
+                        current->thread.ksp_limit = (unsigned long)irqtp +
+                                _ALIGN_UP(sizeof(struct thread_info), 16);
+  			call_handle_irq(irq, desc, irqtp, handler);
+                        current->thread.ksp_limit = saved_sp_limit;
+                        irqtp->task = NULL;
+
+
+                        /* Set any flag that may have been set on the
+                         * alternate stack
+                         */
+                        if (irqtp->flags)
+                                set_bits(irqtp->flags, &curtp->flags);
+                } else
+#endif
+                        generic_handle_irq(irq);
+#ifdef CONFIG_WRHV
+                goto check_again;
+#endif
+        } else if (irq != NO_IRQ_IGNORE)
+                /* That's not SMP safe ... but who cares ? */
+                set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
+
+        irq_exit();
+        set_irq_regs(old_regs);
+
+#ifdef CONFIG_PPC_ISERIES
+        if (firmware_has_feature(FW_FEATURE_ISERIES) &&
+                        get_lppaca()->int_dword.fields.decr_int) {
+                get_lppaca()->int_dword.fields.decr_int = 0;
+                /* Signal a fake decrementer interrupt */
+                timer_interrupt(regs);
+        }
+#endif
+}
+
+unsigned int wrhv_irq_of_parse_and_map(struct device_node *dev, int index)
+{
+	int irq;
+
+        irq = vbiIntVecFind(dev->full_name, VB_INPUT_INT);
+        if (irq == VBI_INVALID_IRQ)
+                return NO_IRQ;
+
+        return irq;
+}
+
+unsigned int wrhv_get_pvr(void)
+{
+       return 0x80200000;
+}
+
+
+
+
+/* arch/powerpc/kernel/time.c */
+#define HWTIMER_USE_JIFFY 1
+static void wrhv_set_mode(enum clock_event_mode mode,
+                                 struct clock_event_device *dev)
+{
+        return;
+}
+
+static int wrhv_set_next_event(unsigned long evt,
+                                      struct clock_event_device *dev)
+{
+        return 0;
+}
+static struct clock_event_device wrhv_clockevent = {
+       .name           = "wrhv",
+       .shift          = 32,
+       .irq            = 0,
+       .mult           = 1,     /* To be filled in */
+       .set_mode       = wrhv_set_mode,
+       .set_next_event = wrhv_set_next_event,
+       .features       = CLOCK_EVT_FEAT_ONESHOT,
+};
+
+void wrhv_hw_timer_interrupt(struct pt_regs * regs)
+{
+        struct pt_regs *old_regs;
+
+        if (atomic_read(&ppc_n_lost_interrupts) != 0)
+                do_IRQ(regs);
+
+        old_regs = set_irq_regs(regs);
+        irq_enter();
+
+        calculate_steal_time();
+
+        trace_trap_entry(regs, regs->trap);
+
+        wrhv_timer_interrupt(0, NULL);
+
+	irq_exit();
+        set_irq_regs(old_regs);
+        trace_trap_exit();
+}
+
+void __init wrhv_hw_clocksource_init(void)
+{
+	return;
+}
+extern atomic_t hwtimer_cpu_trigger[];
+
+void __init wrhv_hw_time_init(void)
+{
+	return;
+}
+
+
+/* arch/powerpc/mm/fault.c */
+void wrhv_vmmu_restore (void)
+{
+	/*
+	 * this function is called by the end of page fault handling to reinstall
+	 * the vmmu
+	 */
+        wrhvControl->vmmu0 = wrhvStatus->vmmu0;
+        wrhvControl->vmmu1 = wrhvStatus->vmmu1;
+        return;
+}
+
+/* arch/powerpc/mm/fsl_booke_mmu.c */
+void __init wrhv_MMU_init_hw(void)
+{
+	return;
+}
+
+unsigned long __init wrhv_mmu_mapin_ram(void)
+{
+       return 0;
+}
+
+/* arch/powerpc/mm/init_32.c */
+void wrhv_MMU_setup(void)
+{
+        __map_without_bats = 1;
+
+#ifdef CONFIG_DEBUG_PAGEALLOC
+        __map_without_bats = 1;
+        __map_without_ltlbs = 1;
+#endif
+}
+
+void __init wrhv_MMU_init(void)
+{
+        if (ppc_md.progress)
+                ppc_md.progress("MMU:enter", 0x111);
+
+        /* parse args from command line */
+        wrhv_MMU_setup();
+
+        if (lmb.memory.cnt > 1) {
+                lmb.memory.cnt = 1;
+                lmb_analyze();
+                printk(KERN_WARNING "Only using first contiguous memory region");
+        }
+
+        total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
+        lowmem_end_addr = memstart_addr + total_lowmem;
+
+#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_WRHV)
+        /* Freescale Book-E parts expect lowmem to be mapped by fixed TLB
+         * entries, so we need to adjust lowmem to match the amount we can map
+         * in the fixed entries */
+        adjust_total_lowmem();
+#endif /* CONFIG_FSL_BOOKE && !CONFIG_WRHV*/
+
+        if (total_lowmem > __max_low_memory) {
+                total_lowmem = __max_low_memory;
+                lowmem_end_addr = memstart_addr + total_lowmem;
+#ifndef CONFIG_HIGHMEM
+                total_memory = total_lowmem;
+                lmb_enforce_memory_limit(lowmem_end_addr);
+                lmb_analyze();
+#endif /* CONFIG_HIGHMEM */
+        }
+
+        /* Initialize the MMU hardware */
+        if (ppc_md.progress)
+                ppc_md.progress("MMU:hw init", 0x300);
+        MMU_init_hw();
+
+        /* Map in all of RAM starting at KERNELBASE */
+        if (ppc_md.progress)
+                ppc_md.progress("MMU:mapin", 0x301);
+        mapin_ram();
+#ifdef CONFIG_HIGHMEM
+        ioremap_base = PKMAP_BASE;
+#else
+        ioremap_base = 0xfe000000UL;    /* for now, could be 0xfffff000 */
+#endif /* CONFIG_HIGHMEM */
+        ioremap_bot = ioremap_base;
+
+        /* Map in I/O resources */
+        if (ppc_md.progress)
+                ppc_md.progress("MMU:setio", 0x302);
+
+        /* Initialize the context management stuff */
+        mmu_context_init();
+
+        if (ppc_md.progress)
+                ppc_md.progress("MMU:exit", 0x211);
+
+        /* From now on, btext is no longer BAT mapped if it was at all */
+#ifdef CONFIG_BOOTX_TEXT
+        btext_unmap();
+#endif
+
+        /* we enables the mmu here without having to do this from the caller
+         * (which is in assembly world)
+         */
+        vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+}
+
+
+/* sysdev/fsl_soc.c */
+extern const char * get_gfar_tx_intr(void);
+extern const char * get_gfar_rx_intr(void);
+extern const char * get_gfar_err_intr(void);
+
+int __init wrhv_gfar_of_init(void)
+{
+        struct device_node *np;
+        unsigned int i;
+        struct platform_device *gfar_dev;
+        struct resource res;
+        int ret;
+
+        for (np = NULL, i = 0;
+             (np = of_find_compatible_node(np, "network", "gianfar")) != NULL;
+             i++) {
+                struct resource r[4];
+                struct device_node *phy, *mdio;
+                struct gianfar_platform_data gfar_data;
+                const unsigned int *id;
+                const char *model;
+                const char *ctype;
+                const void *mac_addr;
+                const phandle *ph;
+                int n_res = 2;
+
+                if (!of_device_is_available(np))
+                        continue;
+
+                memset(r, 0, sizeof(r));
+                memset(&gfar_data, 0, sizeof(gfar_data));
+
+                ret = of_address_to_resource(np, 0, &r[0]);
+                if (ret)
+                        goto err;
+
+                of_irq_to_resource(np, 0, &r[1]);
+
+                model = of_get_property(np, "model", NULL);
+
+                /* If we aren't the FEC we have multiple interrupts */
+                if (model && strcasecmp(model, "FEC")) {
+#if defined(CONFIG_WRHV)
+#include <vbi/interrupt.h>
+                        int vector;
+                        char eTsec_tx[10];
+                        char eTsec_rx[10];
+                        char eTsec_err[10];
+
+                        sprintf(eTsec_tx,"etsec%d_tx", i+1);
+                        sprintf(eTsec_rx,"etsec%d_rx", i+1);
+                        sprintf(eTsec_err,"etsec%d_err", i+1);
+
+                        r[1].name = get_gfar_tx_intr();
+                        vector = vbiIntVecFind(eTsec_tx, VB_INPUT_INT);
+                        r[1].start = vector;
+                        r[1].end = vector;
+                        r[1].flags = IORESOURCE_IRQ;
+
+                        r[2].name = get_gfar_rx_intr();
+                        vector = vbiIntVecFind(eTsec_rx, VB_INPUT_INT);
+                        r[2].start = vector;
+                        r[2].end = vector;
+                        r[2].flags = IORESOURCE_IRQ;
+
+                        r[3].name = get_gfar_err_intr();
+                        vector = vbiIntVecFind(eTsec_err, VB_INPUT_INT);
+                        r[3].start = vector;
+			r[3].end = vector;
+                        r[3].flags = IORESOURCE_IRQ;
+#else
+                        r[1].name = gfar_tx_intr;
+
+                        r[2].name = gfar_rx_intr;
+                        of_irq_to_resource(np, 1, &r[2]);
+
+                        r[3].name = gfar_err_intr;
+                        of_irq_to_resource(np, 2, &r[3]);
+#endif
+                        n_res += 2;
+                }
+
+                gfar_dev =
+                    platform_device_register_simple("fsl-gianfar", i, &r[0],
+                                                    n_res);
+
+                if (IS_ERR(gfar_dev)) {
+                        ret = PTR_ERR(gfar_dev);
+                        goto err;
+                }
+
+                mac_addr = of_get_mac_address(np);
+                if (mac_addr)
+                        memcpy(gfar_data.mac_addr, mac_addr, 6);
+
+                if (model && !strcasecmp(model, "TSEC"))
+                        gfar_data.device_flags =
+                            FSL_GIANFAR_DEV_HAS_GIGABIT |
+                            FSL_GIANFAR_DEV_HAS_COALESCE |
+                            FSL_GIANFAR_DEV_HAS_RMON |
+                            FSL_GIANFAR_DEV_HAS_MULTI_INTR;
+                if (model && !strcasecmp(model, "eTSEC"))
+                        gfar_data.device_flags =
+                            FSL_GIANFAR_DEV_HAS_GIGABIT |
+                            FSL_GIANFAR_DEV_HAS_COALESCE |
+                            FSL_GIANFAR_DEV_HAS_RMON |
+                            FSL_GIANFAR_DEV_HAS_MULTI_INTR |
+                            FSL_GIANFAR_DEV_HAS_CSUM |
+                            FSL_GIANFAR_DEV_HAS_VLAN |
+                            FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
+
+                ctype = of_get_property(np, "phy-connection-type", NULL);
+
+                /* We only care about rgmii-id.  The rest are autodetected */
+                if (ctype && !strcmp(ctype, "rgmii-id"))
+                        gfar_data.interface = PHY_INTERFACE_MODE_RGMII_ID;
+                else
+                        gfar_data.interface = PHY_INTERFACE_MODE_MII;
+
+                if (of_get_property(np, "fsl,magic-packet", NULL))
+                        gfar_data.device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
+
+                ph = of_get_property(np, "phy-handle", NULL);
+		if (ph == NULL) {
+                        u32 *fixed_link;
+
+                        fixed_link = (u32 *)of_get_property(np, "fixed-link",
+                                                           NULL);
+                        if (!fixed_link) {
+                                ret = -ENODEV;
+                                goto unreg;
+                        }
+
+                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "0");
+                        gfar_data.phy_id = fixed_link[0];
+                } else {
+                        phy = of_find_node_by_phandle(*ph);
+
+                        if (phy == NULL) {
+                                ret = -ENODEV;
+                                goto unreg;
+                        }
+
+                        mdio = of_get_parent(phy);
+
+                        id = of_get_property(phy, "reg", NULL);
+                        ret = of_address_to_resource(mdio, 0, &res);
+                        if (ret) {
+                                of_node_put(phy);
+                                of_node_put(mdio);
+                                goto unreg;
+                        }
+
+                        gfar_data.phy_id = *id;
+                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "%llx",
+                                 (unsigned long long)res.start&0xfffff);
+
+                        of_node_put(phy);
+                        of_node_put(mdio);
+                }
+
+                ret =
+                    platform_device_add_data(gfar_dev, &gfar_data,
+                                             sizeof(struct
+                                                    gianfar_platform_data));
+                if (ret)
+                        goto unreg;
+        }
+
+        return 0;
+
+unreg:
+        platform_device_unregister(gfar_dev);
+err:
+        return ret;
+}
+
+/* arch/powerpc/mm/mem.c */
+extern void __flush_dcache_icache_phys(unsigned long physaddr);
+void wrhv_flush_dcache_page(struct page *page)
+{
+        if (cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
+                return;
+        /* avoid an atomic op if possible */
+        if (test_bit(PG_arch_1, &page->flags))
+                clear_bit(PG_arch_1, &page->flags);
+        __flush_dcache_icache_phys(page_to_pfn(page) << PAGE_SHIFT);
+}
+
+void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
+                      pte_t pte)
+{
+#ifndef CONFIG_WRHV
+#ifdef CONFIG_PPC_STD_MMU
+        unsigned long access = 0, trap;
+#endif
+#endif /* !CONFIG_WRHV */
+        unsigned long pfn = pte_pfn(pte);
+
+        /* handle i-cache coherency */
+        if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE) &&
+            !cpu_has_feature(CPU_FTR_NOEXECUTE) &&
+            pfn_valid(pfn)) {
+                struct page *page = pfn_to_page(pfn);
+#ifdef CONFIG_8xx
+                /* On 8xx, cache control instructions (particularly
+                 * "dcbst" from flush_dcache_icache) fault as write
+                 * operation if there is an unpopulated TLB entry
+                 * for the address in question. To workaround that,
+                 * we invalidate the TLB here, thus avoiding dcbst
+                 * misbehaviour.
+                 */
+                _tlbie(address, 0 /* 8xx doesn't care about PID */);
+#endif
+                /* The _PAGE_USER test should really be _PAGE_EXEC, but
+                 * older glibc versions execute some code from no-exec
+                 * pages, which for now we are supporting.  If exec-only
+                 * pages are ever implemented, this will have to change.
+                 */
+                if (!PageReserved(page) && (pte_val(pte) & _PAGE_USER)
+                    && !test_bit(PG_arch_1, &page->flags)) {
+                        if (vma->vm_mm == current->active_mm) {
+                                __flush_dcache_icache((void *) address);
+                        } else
+                                flush_dcache_icache_page(page);
+                        set_bit(PG_arch_1, &page->flags);
+                }
+        }
+
+#ifndef CONFIG_WRHV
+#ifdef CONFIG_PPC_STD_MMU
+        /* We only want HPTEs for linux PTEs that have _PAGE_ACCESSED set */
+        if (!pte_young(pte) || address >= TASK_SIZE)
+                return;
+
+        /* We try to figure out if we are coming from an instruction
+         * access fault and pass that down to __hash_page so we avoid
+         * double-faulting on execution of fresh text. We have to test
+         * for regs NULL since init will get here first thing at boot
+         *
+         * We also avoid filling the hash if not coming from a fault
+         */
+        if (current->thread.regs == NULL)
+                return;
+        trap = TRAP(current->thread.regs);
+  	if (trap == 0x400)
+                access |= _PAGE_EXEC;
+        else if (trap != 0x300)
+                return;
+        hash_preload(vma->vm_mm, address, access, trap);
+#endif /* CONFIG_PPC_STD_MMU */
+#endif /* !CONFIG_WRHV */
+}
+
+/* arch/powerpc/mm/mmu_context_32.c */
+void set_context(unsigned long contextId, pgd_t * pgd)
+{
+
+        pgd_t * kpdStart, *kpdEnd, *updStart;
+        /* we attach (copy) kernel page mapping to the user page table
+         * Note, we only copy the L1 entrys to user L1 pageTable,
+         * then letting L1 share the same L2 page table
+         */
+
+        kpdStart = pgd_offset_k(KERNELBASE);
+        kpdEnd =   pgd_offset_k(0xffffffff);
+
+        updStart = pgd + pgd_index(KERNELBASE);
+
+        memcpy(updStart, kpdStart, (kpdEnd - kpdStart + 1) * sizeof (pgd_t));
+
+        /* in linux context, page table entry is not set up yet */
+        vb_context_mmu_on(contextId, pgd, PAGE_SIZE, 0);
+}
+
+/* arch/powerpc/mm/pgtable_32.c */
+int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
+{
+        pmd_t *pd;
+        pte_t *pg;
+        int err = -ENOMEM;
+
+        /* Use upper 10 bits of VA to index the first level map */
+        pd = pmd_offset(pud_offset(pgd_offset_k(va), va), va);
+        /* Use middle 10 bits of VA to index the second-level map */
+        pg = pte_alloc_kernel(pd, va);
+        if (pg != 0) {
+                err = 0;
+                /* The PTE should never be already set nor present in the
+                 * hash table
+                 */
+                BUG_ON(pte_val(*pg) & (_PAGE_PRESENT | _PAGE_HASHPTE));
+                set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
+                                                     __pgprot(flags)));
+        }
+        if (mem_init_done)
+                flush_HPTE(0, va, pmd_val(*pmd));
+        return err;
+}
+
+
+/* arch/powerpc/kernel/traps.c */
+void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_status)
+{
+        debug_status = wrhvControl->vbControlRegs.dbsr;
+        wrhvControl->vbControlRegs.emsr &= ~MSR_DE;
+        
+	if (debug_status & DBSR_IC) {   /* instruction completion */
+                regs->msr &= ~MSR_DE;
+                if (notify_die(DIE_SSTEP, "single_step", regs, 5,
+                               5, SIGTRAP) == NOTIFY_STOP) {
+                        return;
+                }
+
+                if (debugger_sstep(regs))
+                        return;
+
+                if (user_mode(regs)) {
+                        current->thread.dbcr0 &= ~DBCR0_IC;
+                }
+
+                _exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);
+        } else if (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {
+                regs->msr &= ~MSR_DE;
+
+                if (user_mode(regs)) {
+                        current->thread.dbcr0 &= ~(DBSR_DAC1R | DBSR_DAC1W |
+                                                                DBCR0_IDM);
+                } else {
+                        /* Disable DAC interupts */
+                        mtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~(DBSR_DAC1R |
+                                                DBSR_DAC1W | DBCR0_IDM));
+
+                        /* Clear the DAC event */
+                        mtspr(SPRN_DBSR, (DBSR_DAC1R | DBSR_DAC1W));
+                }
+                /* Setup and send the trap to the handler */
+                do_dabr(regs, mfspr(SPRN_DAC1), debug_status);
+        }
+}
+
+/* arch/powerpc/kernel/kgdb.c */
+int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
+                               char *remcom_in_buffer, char *remcom_out_buffer,
+                               struct pt_regs *linux_regs)
+{
+        char *ptr = &remcom_in_buffer[1];
+        unsigned long addr; 
+
+        switch (remcom_in_buffer[0]) {
+                /*
+                 * sAA..AA   Step one instruction from AA..AA
+                 * This will return an error to gdb ..
+                 */
+        case 's':
+        case 'c':
+                /* handle the optional parameter */
+                if (kgdb_hex2long(&ptr, &addr))
+                        linux_regs->nip = addr;
+
+                atomic_set(&kgdb_cpu_doing_single_step, -1);
+                /* set the trace bit if we're stepping */
+                if (remcom_in_buffer[0] == 's') {
+#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
+#ifdef CONFIG_WRHV
+                        wrhvControl->vbControlRegs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
+#else
+                        mtspr(SPRN_DBCR0,
+                              mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);
+#endif
+                        linux_regs->msr |= MSR_DE;
+#else
+                        linux_regs->msr |= MSR_SE;
+#endif
+                        kgdb_single_step = 1;
+                        atomic_set(&kgdb_cpu_doing_single_step,
+                                   raw_smp_processor_id());
+                }
+                return 0;
+        }
+
+        return -1;
+}
+
+
+void wrhv_init(void)
+{
+	pv_time_ops.hw_time_init = wrhv_hw_time_init;
+        pv_time_ops.hw_timer_interrupt = wrhv_hw_timer_interrupt;
+        pv_time_ops.hw_clocksource_init = wrhv_hw_clocksource_init;
+
+        pv_irq_ops.do_IRQ = wrhv_do_IRQ;
+        pv_irq_ops.irq_of_parse_and_map =
+			wrhv_irq_of_parse_and_map;
+
+	pv_cpu_ops.get_pvr = wrhv_get_pvr;
+	pv_cpu_ops.gfar_of_init =  wrhv_gfar_of_init;
+        pv_cpu_ops.DebugException = wrhv_DebugException;
+        pv_cpu_ops.kgdb_arch_handle_exception = 
+                wrhv_kgdb_arch_handle_exception;
+
+	pv_mmu_ops.vmmu_restore = wrhv_vmmu_restore;
+        pv_mmu_ops.MMU_init_hw = wrhv_MMU_init_hw;
+        pv_mmu_ops.mmu_mapin_ram = wrhv_mmu_mapin_ram;
+        pv_mmu_ops.MMU_setup = wrhv_MMU_setup;
+        pv_mmu_ops.MMU_init = wrhv_MMU_init;
+        pv_mmu_ops.flush_dcache_page = wrhv_flush_dcache_page;
+        pv_mmu_ops.update_mmu_cache = wrhv_update_mmu_cache;
+        pv_mmu_ops.map_page = wrhv_map_page;
+}
diff --git a/arch/powerpc/kernel/vbiPpcDoc.c b/arch/powerpc/kernel/vbiPpcDoc.c
deleted file mode 100644
index 0234e13..0000000
--- a/arch/powerpc/kernel/vbiPpcDoc.c
+++ /dev/null
@@ -1,691 +0,0 @@
-/* vbiPpcDoc.c - Virtual Board Interface APIs supplement for PPC */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind RIver License agreement.
- */
-
-/*
-modification history
---------------------
-01j,24sep09,mpk  updates docs for vbiVbRegisterRead
-01i,10sep09,mmi  update ppc header file path
-01h,10sep09,mmi  update ppc docs
-01g,31jul09,mpk  update comments for vbiVbRegisterRead, vbiVbRegisterWrite
-01f,18jul09,mmi  fix example for mdio
-01e,18jul09,mmi  update info about sending message to bspserver
-01d,07jul09,mmi  fix int lock macro comments
-01c,12jun09,mmi  remove vioapic from here
-01b,26may09,mmi  ensure that vbiIntCoreLock returns the previous state
-01a,12may09,mmi written
-*/
-
-/*
-DESCRIPTION
-The module contains the VBI PowerPc architecture supplement. The APIs described
-below are either available only for PPC platforms or their behaviour is architecture
-dependant.
-
-\sh HYPERCALLS
-This file implements the APIs to make hypercalls to perform operations that require
-hypervisor assistant. A hypercall is based on system call trap that jumps to
-hypervisor exception handler. Some operations that are time critical are implemented
-using a mechanism referred as "fast hypercall". A fast hypercall is identical to a
-regular hypercall except that the system call handler is hand crafted to avoid the
-need of an exception stack.  In some instances they a hypercall may not even return
-(eg. context loading). 
-
-All hypercalls preserve the following registers:
-\ms 
-\m -
-	SRR0 (PC)
-\m -
-	CR (condition register)
-\m -
-	SRR1 (MSR)
-\m -
-	sp (stack pointer)
-\m -
-	lr (link register)
-\m -
-	r2 (sdata2 pointer)
-\m -
-	r13 (sdata pointer)
-\m -
-	r14-r32 (global registers)
-\me
-
-
-\sh FAST HYPERCALLS
-Following is the list of APIs that utilize fast hypercalls mechanism. 
-\ms
-\m - 
-void VBI_CTX_LOAD(void):
-This is a assembly MACRO that may be used by a guest OS to switch to a new context.
-The guest sets the register sets to be loaded in the VB control structures and calls
-this MACRO to make the hypercall.
-\m -
-vbiStatus_t vbiICacheFlush():
-This routine flushes the instruction cache for the calling core.
-\m -
-This routine flushes the data cache for the calling core.
-vbiStatus_t vbiDCacheFlush():
-\m -
-vbiStatus_t vbiIntVCoreUnlock():
-This routine unlocks interrupts for the calling core. For optimization purpose a 
-hypercall is made only if interrupts were queue while locked.
-\me
-
-\sh ACCESSING WRHV BSP DEVICES
-
-Devices that are shared between the different guests are managed by WRHV
-hyperkernel. These devices manager accepts request submitted using vbiSend().
-The guest finds the server handle by using vbiNsLookup (), initializes the
-predefined input/output message buffers then invokes vbiSend() to transmit the
-request. The input message buffer type is VBI_BSP_MSG. The reply message buffer
-type is VBI_BSP_MSG_REPLY. The request type in the input message is based on
-the nature of the request which can be one of the following types:
-\ms 
-\m - VBI_MDIO_READ for reading an MDIO register
-\m - VBI_MDIO_WRITE for modifying an MDIO register
-\m - VBI_BSP_CLK_FREQ  for reading the BSP clok frequency
-\me
-
-\cs
-\sh BSP MESSAGES BUFFER FORMAT
-
-/@ Input message format @/
-
-typedef struct vbiBspMsg
-    {
-    MSG_HEADER hdr;                     /@ message header @/
-    uint32_t   request;                 /@ request type @/
-
-    union
-        {
-        struct
-            {
-            uint32_t bus;
-            uint32_t phyAddr;
-            uint32_t regNum;
-            uint32_t page;
-            } mdioRead;
-        struct
-            {
-            uint32_t bus;
-            uint32_t phyAddr;
-            uint32_t regNum;
-            uint32_t page;
-            uint32_t dataVal;
-            } mdioWrite;
-        } arg;
-
-    } VBI_BSP_MSG;
-
-/@ Output message format @/
-
-typedef struct
-    {
-    MSG_HEADER hdr;                     /@ message header 	    @/
-    uint32_t   status;                  /@ request completion status @/
-    uint32_t   dataVal;
-    } VBI_BSP_MSG_REPLY;
-
-/@Generic message header @/
-
-typedef struct msg_header {
-    uint32_t msgId;     /@ message type identification @/
-    uint32_t msgArg;    /@ argument associated with message type @/
-} MSG_HEADER;
-
-\ce
-
-\sh Example
-\cs
-        VBI_BSP_MSG             inMsg; /@ input message buffer  @/
-        VBI_BSP_MSG_REPLY       reply; /@ output message buffer @/
-        VBI_NS_HANDLE		serviceHandle;
-        vbiStatus_t		rc;
-
-	/@ 
-	 @ What is the request type ?
-         @ VBI_MDIO_READ, VBI_MDIO_READ or VBI_BSP_CLK_FREQ
-	 @    
-	 @/
-
-        mdioMsg.request = <request type>; 
-	
-	/@ 
-         @ The input message structure is populated according to the type
-	 @ request specified. For example for writting to a phy the user
-	 @ must specify the bus, phy addr, reg number, and the input 
-	 @ value. See the union used for the inMsg type. 
-         @ The example is for writting a value to a phy register.
-         @/
-
-	/@ bus number    @/
-        
-	*((uint32_t*)&inMsg.arg.mdioRead.bus) = <phyBusNumber>;   
-	
-	/@ the phy address @/
-
-        *((uint32_t*)&inMsg.arg.mdioRead.phyAddr) = <phyaddr>;  
-	
-	/@ the register number @/
-
-        *((uint32_t*)&inMsg.arg.mdioRead.regNum) = <regNum>;	
-
-	/@ Find the destination server to send the message to @/
-
-        rc = vbiNsLookup ("bspServer", 0, &serviceHandle);
-
-        if (rc != OK)
-            kprintf ("vbiSend returned error\n");
-
-        rc = vbiSend (serviceHandle, &inMsg,
-                sizeof(inMsg), &reply, sizeof(reply), NULL, NULL);
-
-        kprintf ("replied value 0x%d\n", reply.dataVal);
-\ce
-\APPEND ../../../vbi/include/ppc/vbiPpcArch.h
-*/
-
-/*******************************************************************************
-*
-* VBI_CTX_LOAD - Load a guest context
-*
-* This routine is implemented as an assembly MACRO since it's callers can't
-* reference C functions. This MACRO  makes a hypercall to load a context for a guest
-* OS. The guest OS running on the core is expected to store a set of registers that
-* represent the new context to load in the it's control structure then call 
-* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
-* loaded from the control structure:
-*
-*\ms
-*\m 1 -
-* VB_CONTROL_SRR0	     ------->  SRR0
-*\m 2 -
-* VB_CONTROL_SRR1	     -------> SRR1 
-*\m 3 -
-* VB_CONTROL_CR		     -------> CR
-*\m 4 -
-* VB_CONTROL_R0		     -------> R0
-*\m 5 -
-* VB_CONTROL_EMSR	     -------> MSR 
-*\m 6 -
-* VB_CONTROL_DBCR0	     -------> DBCR0 
-*\m 7 -
-* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
-* If interrupts are being reenabled then we ensure that any pending interrupts are
-* delivered before the new context is actived.
-*
-* Note that registers that are not saved by Hypervisor must be loaded by the guest
-* OS.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* void  VBI_CTX_LOAD () 
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
-*           VBI_INT_VCORE_STATE_GET()
-*/
-
-
-/*******************************************************************************
-*
-* vbiIcacheFlush - flush the instruction cache
-*
-* This routine makes a hypercall to flush the instruction cache of the calling
-* core for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiIcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the instruction cache to flush @/
-*	    size_t len  /@ length of memory to flush @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiDcacheFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiDcacheFlush - flush the specified Data cache
-*
-* This routine makes a hypercall to flush the data cache of the calling core
-* for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiDcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the data cache to flush @/
-*	    size_t len  /@ length of memory to flush                   @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
-*/
-
-/*******************************************************************************
-*
-* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
-*
-* This routine makes a hypercall to flush the data cache then invalidates the
-* instruction cache of the calling core for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiCacheTextUpdate 
-*	    (
-*	    void * addr /@ starting address to perform textUpdate operation @/
-*	    size_t len  /@ length of memory in bytes			    @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
-*/
-
-/******************************************************************************
-*
-* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
-*
-* This MACRO disables the currently running core interrupts and returns the
-* previous interrupts state. The interrupt status field in wrhvVbControl
-* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
-* interrupts state is loaded to the register passed in as the first argument to
-* this MACRO. 
-* A hypercall is not needed to perform this operation. 
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
-*	{
-*	load -1 to reg1
-*	load wrhvVbControl address to reg2
-*       read the previous value and store in reg0
-*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
-*	}
-*\ce
-*
-* RETURNS: TRUE is interrupts were locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
-*
-* This MACRO is implemented in assembly to enable a core's interrupts. It
-* enables the interrupts by clearing to zero the value in the core's control
-* structure and and makes a fast hypercall if need be. A hypercall is made only
-* if found that interrupts are pending. The pending interrupts are checked by
-* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
-* positive integer greater than zero indicates that interrupts are pending
-* which causes this macro to make a hypercall in order to drain the pending
-* interrupts. This MACRO expects two general purpose registers. The first 
-* register is used to load the value to store and the second is used for
-* holding the destination address of the control or status structure.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
-*	{
-*	load "0" to reg1
-*	load address of wrhvVbControl in reg0 
-*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
-*
-* checkStatus:
-*	load address of wrhvVbStatus in reg0
-*       load VB_STATUS_INT_PENDING(reg0) in reg1
-*       check if reg1 is equal to zero
-*       if true return
-*	otherwise send an hypercall 
-*       go to checkStatus
-*	}
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_STATE_GET - Get interrupts state
-*
-* This MACRO is implemented in assembly to read the interrupt state of the
-* currently running core. It relies on a passed in general purpose register
-* to store the current state of interrupts. The status is -1 if locked
-* otherwise 0.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_STATE_GET (reg0)
-*	{
-*       Load the interrupt status from wrhvVbControl to reg0
-*	}
-*\ce
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreLock - lock interrupts
-*
-* This routine locks interrupts for the calling core. This is a C wrapper 
-* function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
-* and returns the previous state of interrupts.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntState_t vbiIntVCoreLock (void)
-*
-*\ce
-*
-* RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
-*
-* This routine enables interrupts and makes a fast hypercall if pending
-* interrupts are detected for the calling core. This is a C wrapper function for
-* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* void vbiIntVCoreUnlock (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiIntVCoreStateGet - Get interrupts state for running core
-*
-* This routine returns the interrupts state for the calling core. This is C 
-* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
-* returns TRUE if interrupts are locked otherwise FALSE.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntStatus_t vbiIntVCoreStateGet (void)
-*
-*\ce
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-/*******************************************************************************
-*
-* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
-*
-* This routine changes the exceptions vector table base address for the active
-* virtual core. By default the base address of the exception table is at address
-* 0x0.
-* If the guest OS programmer wishes to move this address then this function must
-* be called to inform hypervisor. This function must be called with interrupts
-* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcBaseSet 
-*	    (
-*	    void * excTblBase /@ New exception table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-/*******************************************************************************
-*
-* vbiVbRegisterRead - Read a remote core's registers
-*
-* This routine makes a hypercall to read a remote core's registers. The register
-* control structure contains information about the registers to read and the
-* destination buffers to store them.
-* 
-* It is possible to read registers while the target VB's core is still running
-* it doesnt have to be suspended before reading the registers.
-* 
-* SYNOPSIS
-*\cs
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiVbRegisterRead 
-*	(
-*	VB_HREG_SET	*regCtl,	    /@ Registers read - OUT	    @/
-*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
-*	vbiCore_t   core		    /@ core within the target VB    @/
-*	)
-*
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VB_HREG_SET;
-* 
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-/*******************************************************************************
-*
-* vbiVbRegisterWrite - write to a remote core's registers
-*
-* This routine makes a hypercall to write to a remote core's registers. The
-* register control structure contains the set of registers to write. 
-* The user must ensure to read first the destination core's registers using
-* vbiVbRegisterRead() then write back the modified set of registers in the 
-* registers control structure.
-* 
-* Target VB's core has to be suspended before writing the registers. If it
-* is still running, vbiVbRegisterWrite call will fail.
-* 
-*\cs
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VB_HREG_SET;
-* 
-*\ce 
-* VBI PPC Architecture Supplements
-*
-* SYNOPSIS
-*\cs
-* vbiStatus_t vbiVbRegisterWrite
-*	(
-*	VB_HREG_SET		*regCtl,	/@ registers to write - IN	 @/
-*	vbiVb_t			targetBoard,	/@ The target board		 @/
-*	vbiCore_t		core		/@ The target core within the VB @/
-*	)
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-/*******************************************************************************
-*
-* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
-*
-* This routine changes the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* If the guest OS programmer wishes to move these address then this function 
-* must be called to inform hypervisor. This function must be called with 
-* interrupts disabled to prevent hypervisor to deliver interrupts to an 
-* incorrect exception offset. The table is not validated by the hypervisor so
-* it must be complete and functional otherwize the VB will not behave as 
-* expected.
-* For SMP systems it is recommended this API be called for each core as it is
-* started up and before it's added to the scheduler for the guest OS.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsSet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiExcOffsetsGet
-*/
-
-/*******************************************************************************
-*
-* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
-*
-* This routine gets the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsGet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiExcOffsetsSet
-*/
diff --git a/arch/powerpc/kernel/vbiPpcShow.c b/arch/powerpc/kernel/vbiPpcShow.c
deleted file mode 100644
index db61a75..0000000
--- a/arch/powerpc/kernel/vbiPpcShow.c
+++ /dev/null
@@ -1,102 +0,0 @@
-/* vbiPpcShow.c - vbi PowerPC show routines */
-
-/*
- * Copyright (c) 2008 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01d,15jun09,mmi  update vb regs
-01c,07feb09,mmi  fix build errors
-01b,22jan09,mmi  change vbCtrlRegsDisplay to vbiCrlRegsDisplay()
-01a,22jan09,mmi created
-*/
-
-/*
-This module provides the PowerPC show routines for the Virtual Board running
-on Wind River hypervisor.
-*/
-
-#ifdef CONFIG_WRHV
-#include <linux/kernel.h>
-#include <vbi/vbi.h>
-#define kprintf printk
-#else
-#include <vbi.h>
-#endif
-
-/*******************************************************************************
-*
-* vbiStsRegsDisplay - display registers from a EREG_SET
-*
-* This routine display the contents of the PowerPC emulated status registers
-* structure on the console.
-*
-*/
-
-void vbiStsRegsDisplay ()
-    {
-    VB_STATUS *p = VBI_STATUS_ADDR_GET();
-
-#if CPU == PPC85XX /* don't know how to handle cpu variant */
-    VB_PRINTF ("  srr0/srr1:          0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, srr0) ,
-		VB_STATUS_REGS_ACCESS (p, srr1));
-
-    VB_PRINTF ("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, mcsrr0) ,
-		VB_STATUS_REGS_ACCESS (p, mcsrr1));
-
-    VB_PRINTF ("  mcsr/mcar:          0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, mcsr) ,
-		VB_STATUS_REGS_ACCESS (p, mcar));
-
-    VB_PRINTF ("  dear/esr:           0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, dear) , 
-		VB_STATUS_REGS_ACCESS (p, esr));
-
-    VB_PRINTF ("  svr/pvr:            0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, svr) ,
-		VB_STATUS_REGS_ACCESS (p, pvr));
-
-    VB_PRINTF ("  hid0/hid1:          0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, hid0) ,
-		VB_STATUS_REGS_ACCESS (p, hid1));
-
-    VB_PRINTF ("  l1csr0/l1csr1:      0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, l1csr0) ,
-		VB_STATUS_REGS_ACCESS (p, l1csr1));
-
-    VB_PRINTF ("  bucsr:              0x%08x\n",  
-		VB_STATUS_REGS_ACCESS (p, bucsr));
-#endif
-    }
-
-/*******************************************************************************
-*
-* vbiCtrlRegsDisplay - display registers from a EREG_SET
-*
-* This routine display the contents of the PowerPC emulated status registers
-* structure on the console.
-*
-*/
-
-void vbiCtrlRegsDisplay (void)
-    {
-    VB_CONTROL * p = VBI_CNTRL_ADDR_GET();
-
-#if CPU == PPC85XX /* don't know how to handler cpu variant */
-    VB_PRINTF ("  srr0/srr1:           0x%08x 0x%08x\n", 
-		VB_CONTROL_REGS_ACCESS (p, srr0),  
-		VB_CONTROL_REGS_ACCESS (p, srr1));
-
-    VB_PRINTF ("  cr/r0:               0x%08x 0x%08x\n", 
-		VB_CONTROL_REGS_ACCESS (p, cr), 
-		VB_CONTROL_REGS_ACCESS (p, r0));
-#endif
-    }
diff --git a/arch/powerpc/kernel/vbiSyscalls.S b/arch/powerpc/kernel/vbiSyscalls.S
deleted file mode 100644
index a8fd6a7..0000000
--- a/arch/powerpc/kernel/vbiSyscalls.S
+++ /dev/null
@@ -1,1669 +0,0 @@
-/* vbiSyscalls.s - hypervisor system calls */
-
-/*
- * Copyright (c) 2007-2008 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-02j,03sep09,dtr  Fixed vbExcBaseSet.Added vbiExcOffsetsSet/Get.
-02i,02sep09,mmi  rename vbiReceive to vbiReceiveOp
-02h,27aug09,mmi  fix defect WIND00178035
-02g,06jul09,mmi  update vb mangement syscall numbers, memory read/write,
-		 registers read/write, interrupt direct op, debug shell start
-02f,26jun09,mmi  add vbiIoapicOp
-02e,23jun09,mmi  add vbi 2.0 apis
-02d,11jun09,mmi  update interrupts apis according to vbi2.0
-02c,10jun09,mmi  remove VxWorks consideration
-02b,28feb09,mmi  add vbiNsOp
-02a,09feb09,mmi  add vbMgmt API
-01z,27jan09,mmi  include vbi.h header file
-01y,23jan09,mmi  update vbiSyscall prototype in comments
-01x,18jan09,mmi  fix vbiIoapicIoctl, remove vbiShelf
-01w,12dec08,md   rename header files
-01v,11dec08,mmi  change name of VB structure pointers
-01u,02dec08,mmi  remove obsolete API's
-01t,19nov08,mmi  adopt new naming convention for vbi API's
-01s,04sep08,dcc  added vdkIoapicIoctl
-01r,20jun08,md   fix header file inclusion
-01q,19jun08,md   change VxWorks define
-01p,28nov07,foo  vdk doc
-01o,21nov07,md   include VxWorks header files if being compiled in a project
-01o,21nov07,foo  vdk interrupts
-01n,25oct07,foo  added vdkIntControllerDone, vdkIntEnable, vdkShelf	
-01m,05oct07,md   remove vxworks header files
-01l,10sep07,md   re-number hypervisor system calls
-01k,05jul07,foo  added vdkBspIoctl	
-01j,04jun07,md   added vdkHyCtxctl, vdkMmuPageProtect and vdkMmuPageUnprotect
-01i,24may07,ymz  added port system calls.
-01h,18may07,md   added vdkHyIoctl
-01g,20apr07,md   add vmmu system calls
-01f,18apr07,md   renamed syscalls to start with vdk
-01e,10apr07,md   split kprintf into kputs and kputc
-01d,02apr07,md   header file re-org
-01c,19mar07,foo	 fix macro names
-01b,15mar07,md   added hyInt, hyIntDone
-01a,11mar07,md   written
-*/
-
-/*
-DESCRIPTION
-
-This file implements the hypervisor system call stubs for the hypervisor.
-
-*/
-
-#define _ASMLANGUAGE
-
-#ifdef CONFIG_WRHV
-#include <vbi/vbi.h>
-#include <vbi/support/asm.h>
-#else
-#include <vbi.h>
-#include <asm.h>
-#endif /* CONFIG_WRHV */
-
-#define HCALL sc
-
-	/* globals */
-
-	FUNC_EXPORT(vbiVcoreIntRed_op)
-	FUNC_EXPORT(vbiDebugShellStart)
-	FUNC_EXPORT(vbiVbMemoryRead)
-	FUNC_EXPORT(vbiVbMemoryWrite)
-	FUNC_EXPORT(vbiVbRegisterRead)
-	FUNC_EXPORT(vbiVbRegisterWrite)
-	FUNC_EXPORT(vbiIoapicOp)
-	FUNC_EXPORT(vbiIoapicIoctl)
-	FUNC_EXPORT(vbiHyIoctl)
-	FUNC_EXPORT(vbiCtxctl)
-	FUNC_EXPORT(vbiSend)
-	FUNC_EXPORT(vbiReceiveOp)
-	FUNC_EXPORT(vbiReply)
-	FUNC_EXPORT(vbiIcacheFlush)
-	FUNC_EXPORT(vbiDcacheFlush)
-	FUNC_EXPORT(vbiCacheTextUpdate)
-	FUNC_EXPORT(vbiTlbFlush)
-	FUNC_EXPORT(vbiPanic)
-	FUNC_EXPORT(vbiPs)
-	FUNC_EXPORT(vbiKputs)
-	FUNC_EXPORT(vbiKputc)
-	FUNC_EXPORT(vbiIntVCoreUnlock)
-	FUNC_EXPORT(vbiIntVCoreLock)
-	FUNC_EXPORT(vbiExcBaseSet)
-	FUNC_EXPORT(vbiExcOffsetsSet)
-	FUNC_EXPORT(vbiExcOffsetsGet)
-	FUNC_EXPORT(vbiMemAttrSet)
-	FUNC_EXPORT(vbiMemAttrGet)
-	FUNC_EXPORT(vbiVmmuConfig)
-	FUNC_EXPORT(vbiVmmuEnable)
-	FUNC_EXPORT(vbiVmmuDisable)
-	FUNC_EXPORT(vbiVmmuTlbLoad)
-	FUNC_EXPORT(vbiVmmuTlbFlush)
-	FUNC_EXPORT(vbiVbMgmt)
-	FUNC_EXPORT(vbiNsOp)
-	FUNC_EXPORT(vbiVbSuspend)
-	FUNC_EXPORT(vbiVbReset)
-	FUNC_EXPORT(vbiVbRestart)
-	FUNC_EXPORT(vbiVbResume)
-
-	_WRS_TEXT_SEG_START
-
-/******************************************************************************
-*
-* sys_vbMgmt - virtual board management
-* 
-* This routine executes the specified command on a given virtual board. The
-* possible commands are:
-* 
-* VBI_VBMGMT_ATTACH 
-* Attach the requesting Virtual Board to the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_DETACH
-* Detatch the requesting Virtual Board from the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_SUSPEND
-* Suspends target Virtual Board from operation.  Fails if Virtual Board
-* has already been suspended
-*
-* VBI_VBMGMT_RESET
-* Resume a target virtual board.  Fails if a Virtual Board has not been
-* suspended. Currently no options are supported
-*
-* VBI_VBMGMT_RESUME
-* Restarts a target Virtual Board which has Preload=0 set in the xml file.
-* Fails if Virtual Board is preloaded (Preload=1)
-*
-* The fourth argument to this routine specifies an flag that must be defined
-* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
-* The possible flgas are:
-*   VBI_VTLB_OP_UPDATE_PMD	
-*   VBI_VTLB_OP_UPDATE_PTE	
-*   VBI_VTLB_OP_DELETE_PMD	
-*   VBI_VTLB_OP_SET_PTE_AT	
-*   VBI_VTLB_OP_SET_PTE	
-*   VBI_VTLB_OP_FLUSH_OPS	
-*   VBI_VTLB_OP_INIT	
-* 
-* RETURNS: OK or error in case of failure
-* 
-*
-* int32_t sys_vbMgmt 
-*    (
-*    uint32_t cmd,	/@ attach, detach, suspend, reset or resume @/
-*    uint32_t boardId,	/@ the operation target board id @/
-*    int32_t *outError, /@ where to set error : OK or error flag @/ 
-*    uint32_t flags	/@ options required by the cmd executed @/
-*    )
-*/
-
-FUNC_LABEL(vbiVbMgmt)
-        lis     r0, HI(VBI_SYS_vbMgmt)
-        ori     r0, r0, LO(VBI_SYS_vbMgmt)
-        HCALL
-        blr
-FUNC_END(vbiVbMgmt)
-
-
-/*******************************************************************************
-*
-* vbiVbSuspend - Suspend a virtual board's core
-*
-* This routine makes a hypercall in order to suspend one or more cores that
-* exist within the specified virtual board. The target core(s) enter HALT state
-* until vbiVbResume() is called change the state of the core(s). This function
-* will return only after all victim cores are suspended unless the opration
-* fails to complete. The second argument passed to this function specifies one
-* or more target cores. For suspending every core within the specified VB the
-* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
-* requesting the suspension may also be included in the list to be suspended.
-* To suspend everyone but the recipient then the second argument passed to this
-* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
-* should be a valid core number within the VB. This hypercall sends a message
-* to a given hypervisor manager that provides virtual board managment service.
-*
-* SYNOPSIS
-*\cs
-*
-*
-* vbiStatus_t vbiVbSuspend
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO:
-*
-* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
-*/
-
-FUNC_LABEL(vbiVbSuspend)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-	
-        lis     r0, HI(VBI_SYS_vbSuspend)
-        ori     r0, r0, LO(VBI_SYS_vbSuspend)
-        HCALL
-        blr
-FUNC_END(vbiVbSuspend)
-
-/*******************************************************************************
-*
-* vbiVbReset - Reset a virtual board's core
-*
-* This routine makes a hypercall in order to reset one or more cores that exist
-* within the specified virtual board. Calling this function puts the target
-* core(s) program counter to it's ENTRY function. The ENTRY function is 
-* determined based on the loaded binary image. A core does not execute beyond
-* it's ENTRY function unless vbiVbRestart() is explitly called. 
-* Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
-* option is set in the flag passed as the third argument to this routine.
-* The hypercall sends a message to a manager that provides VB managment 
-* services. 
-* This function will return only after all victim cores are reset unless the
-* operation fails to complete. The order of which the victim cores are reset
-* is not determined. The second argument identifies the cores to perform the
-* operation on.
-* The value of the second argument should be set to one of the following:
-*
-*\ms
-*\m -
-* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*\m -
-* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*\m -
-* A valid core number: Reset the specified core that exist within the Virtual
-* Board.
-*\me
-*
-* The third argument argument passed to this function specifies options that are
-* applicable only when the second argument is VBI_VB_CORES_ALL. The options
-* may be
-* one of the following or a combination:
-*
-*\ms
-*\m -
-* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
-*\m -
-* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
-*\me
-*
-*
-* IMPORTANT:
-* If a user chooses to restart core without reloading the executable image then
-* the data section must be restored to prevent critical errors. It is the guest
-* OS's responsibility to clear the bss data sections in such scenario.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiVbReset
-*    (
-*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
-*    vbiCore_t     core,            /@ Core within the VB           @/
-*    uint32_t     options   /@ reload , start options       @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO:
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
-*/
-
-FUNC_LABEL(vbiVbReset)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 * r5 - options
-	 */
-
-        lis     r0, HI(VBI_SYS_vbReset)
-        ori     r0, r0, LO(VBI_SYS_vbReset)
-        HCALL
-        blr
-FUNC_END(vbiVbReset)
-
-
-/*******************************************************************************
-*
-* vbiVbRestart - Restart a virtual board's core
-*
-* This routine makes a hypercall in order to restart a virtual cores from reset.
-* It's called to start running a core or cores that were previously reset by
-* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
-* function retrieved from the corresponding binary image.
-* This function will return only after  all cores are out of reset unless the
-* operation fails to complete.  The second argument represents the cores to
-* restart.
-* For restarting every core in reset mode within the specified VB the second
-* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
-* VB then the core number must be passed in the second argument.
-*
-* This hypercall sends a message to a manager that provides VB managment
-* services.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiVbRestart
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO:
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
-*/
-
-FUNC_LABEL(vbiVbRestart)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-
-        lis     r0, HI(VBI_SYS_vbRestart)
-        ori     r0, r0, LO(VBI_SYS_vbRestart)
-        HCALL
-        blr
-FUNC_END(vbiVbRestart)
-
-/*******************************************************************************
-*
-* vbiVbResume - Resume a virtual board's core
-*
-* This routine makes a hypercall in order to resume one or cores within
-* the specified virtual board. It reactivates a cores or cores that were
-* previously suspended by calling vbiVbResume(). This function will return only
-* after all victim cores are resumed unless the operation fails. The order of
-* which the cores are resumed is not determined. The second argument may a
-* magic number instead of a valid core number to indicate that the operation
-* is intended for more than one core. For resuming every core within the
-* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
-* This implies to resume every core within the specified VB. Using this option
-* when some of the cores within the VB are already running is not considered
-* as programming error.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiVbResume
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO:
-*
-* SEE ALSO: vbiVbResume(), vbiVbSuspend()
-*/
-
-FUNC_LABEL(vbiVbResume)
-
-	/* 
-	 * r3 - virtual board id
-	 * r4 - virtual core ( a flag or a valid vcore id)
-	 */
-
-        lis     r0, HI(VBI_SYS_vbResume)
-        ori     r0, r0, LO(VBI_SYS_vbResume)
-        HCALL
-        blr
-FUNC_END(vbiVbResume)
-
-/*******************************************************************************
-*
-* vbiSend - Send a message to another context
-*
-* This routine makes a hypercall to send a message to the specified context and
-* waits for a reply.  The caller will block until the sender replies to the sent
-* message.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiStatus_t vbiSend
-*    (
-*    vbiCtx_t     id,    /@ context id to send the message to @/
-*    void *       smsg,  /@ pointer to message to send        @/
-*    size_t       slen,  /@ length of message to send         @/
-*    void *       rmsg,  /@ pointer to receive message buffer @/
-*    size_t       rlen,  /@ length of receive message         @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
-*/
-
-FUNC_LABEL(vbiSend)
-
-	/*
-	 * r3 - ctx id
-	 * r4 - smsg pointer 
-	 * r5 - size of smsg 
-	 * r6 - rmsg pointer
-	 * r7 - rmsg length
-	 * r8 - info pointer
-	 * r9 - ctl pointer
-	 */
-
-	lis	r0, HI(VBI_SYS_send)
-	ori	r0, r0, LO(VBI_SYS_send)
-	HCALL
-	blr
-FUNC_END(vbiSend)
-
-/*******************************************************************************
-*
-* vbiReceiveOp - Receive a message from another context
-*
-* This routine makes a hypercall and waits for a message to be received from
-* another context. It blocks until a message is received.
-*
-* SYNOPSIS
-*\cs
-*
-* vbiCtx_t vbiReceiveOp
-*    (
-*    void *       smsg,  /@ pointer to message to receive  @/
-*    size_t       len,   /@ length of message to receive   @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*\ce
-*
-* RETURNS: sender context Id or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
-*/
-
-FUNC_LABEL(vbiReceiveOp)
-
-	/*
-	 * r3 - smsg pointer 
-	 * r4 - size of smsg 
-	 * r5 - info pointer
-	 * r6 - ctl pointer
-	 */
-
-	lis	r0, HI(VBI_SYS_receive)
-	ori	r0, r0, LO(VBI_SYS_receive)
-	HCALL
-	blr
-FUNC_END(vbiReceiveOp)
-
-/*******************************************************************************
-*
-* vbiReply - Reply to message received from another context
-*
-* This routine makes a hypercall in order to reply to a message received from
-* another context. A message is received from remote context by calling
-* vbiReceive(). The reply will unblock the recipient which may preempt
-* the caller.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiReply
-*    (
-*    vbiCtx_t	    id,    /@ context id to reply the message to    @/
-*    void *	    buff,  /@ pointer to reply message		    @/
-*    size_t	    len,   /@ length of message to reply	    @/
-*    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
-*    )
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
-*/
-
-FUNC_LABEL(vbiReply)
-	lis	r0, HI(VBI_SYS_reply)
-	ori	r0, r0, LO(VBI_SYS_reply)
-	HCALL
-	blr
-FUNC_END(vbiReply)
-
-/*******************************************************************************
-*
-* vbiKputs - print a string on the hypervisor kernel console
-*
-* This routine makes a hypercall and prints a string of characters to to
-* hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiKputc() 
-*/
-
-FUNC_LABEL(vbiKputs)
-	lis	r0, HI(VBI_SYS_kputs)
-	ori	r0, r0, LO(VBI_SYS_kputs)
-	HCALL
-	blr
-FUNC_END(vbiKputs)
-
-/*******************************************************************************
-*
-* vbiKputc - print a character on the hypervisor kernel console
-*
-* This routine makes a hypercall in order to print the specified character to
-* hypervisor console.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiKputc (int c) /@ character to print @/
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERRNO: N/A
-*
-* SEE ALSO: vbiKputs()
-*/
-
-FUNC_LABEL(vbiKputc)
-	lis	r0, HI(VBI_SYS_kputc)
-	ori	r0, r0, LO(VBI_SYS_kputc)
-	HCALL
-	blr
-FUNC_END(vbiKputc)
-
-/*******************************************************************************
-*
-* vbiPanic - halt the system and dump debug info 
-*
-* This routine makes a hypercall in order to halt the system and display debug
-* information on hypervisor console. If hypervisor is configured with
-* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
-* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
-* the offending cores registers dump is displayed on hypervisor console. If
-* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
-* the debug manager.
-*
-*
-* SYNOPSIS
-*\cs
-* 
-* void vbiPanic (const char *msg) /@ pointer to message to print @/
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-*/
-
-FUNC_LABEL(vbiPanic)
-	lis	r0, HI(VBI_SYS_panic)
-	ori	r0, r0, LO(VBI_SYS_panic)
-	HCALL
-	blr
-FUNC_END(vbiPanic)
-
-/*******************************************************************************
-*
-* vbiDebugShellStart - start the hypervisor debug shell
-*
-* This routine sends a message to the hypervisor debug shell manager in order to
-* start the WRHV shell program. The shell program spins therefore does not share
-* the processor with any other WRHV context. By default a caller of this routine 
-* is detached to allow the caling core to continue executing (as long as the are not
-* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
-* specified to force the caller virtual board core to block while the shell program
-* is running. 
-*
-* SYNOPSIS
-*\cs
-*
-* void vbiDebugShellStart 
-*          (
-*          uint32_t  flags /@ detach by default @/
-*          ) 
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERRNO: N/A
-*
-* SEE ALSO: 
-*/
-
-FUNC_LABEL(vbiDebugShellStart)
-
-	/* r3 - flags for attachement behaviour */
-
-	lis	r0, HI(VBI_SYS_dbgShStart)
-	ori	r0, r0, LO(VBI_SYS_dbgShStart)
-	HCALL
-	blr
-FUNC_END(vbiDebugShellStart)
-
-/*******************************************************************************
-*
-* vbiIcacheFlush - flush the instruction cache
-*
-* This routine makes a hypercall to flush the instruction cache of the calling
-* core for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiIcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the instruction cache to flush @/
-*	    size_t len  /@ length of memory to flush @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiDcacheFlush()
-*/
-
-FUNC_LABEL(vbiIcacheFlush)
-	lis	r0, HI(VBI_SYS_icache_flush)
-	ori	r0, r0, LO(VBI_SYS_icache_flush)
-	HCALL
-	blr
-FUNC_END(vbiIcacheFlush)
-
-/*******************************************************************************
-*
-* vbiDcacheFlush - flush the specified Data cache
-*
-* This routine makes a hypercall to flush the data cache of the calling core
-* for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiDcacheFlush 
-*	    (
-*	    void * addr /@ starting address of the data cache to flush @/
-*	    size_t len  /@ length of memory to flush                   @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
-*/
-
-FUNC_LABEL(vbiDcacheFlush)
-	lis	r0, HI(VBI_SYS_dcache_flush)
-	ori	r0, r0, LO(VBI_SYS_dcache_flush)
-	HCALL
-	blr
-FUNC_END(vbiDcacheFlush)
-
-
-/******************************************************************************
-*
-* vbiTlbFlush - flush an MMU TLB entry
-*
-* This system call flushes the TLB associated with the specified context id 
-*
-* C interface:
-*
-*   vbiTlbFlush (unsigned int id) /@ the entry to flush @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiTlbFlush)
-	lis	r0, HI(VBI_SYS_tlb_flush)
-	ori	r0, r0, LO(VBI_SYS_tlb_flush)
-	HCALL
-	blr
-FUNC_END(vbiTlbFlush)
-
-/*******************************************************************************
-*
-* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
-*
-* This routine enables interrupts and makes a fast hypercall if pending
-* interrupts are detected for the calling core. This is a C wrapper function for
-* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* void vbiIntVCoreUnlock (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
-*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-FUNC_LABEL(vbiIntVCoreUnlock)
-	
-	lis	p0, HIADJ(wrhvVbControl)
-	lwz	p0, LO(wrhvVbControl)(p0)
-	stw	p1, VB_CONTROL_INT_DISABLE(p0)
-	
-tryAgain:		
-	lis	p0, HIADJ(wrhvVbStatus)
-	lwz	p0, LO(wrhvVbStatus)(p0)
-	lwz	p1, VB_STATUS_INT_PENDING(p0)
-	
-	/* Perform System Call to re-enable ints if ints pending */
-	cmplwi  p1, 0
-	beq     0f
-
-	lis	r0, HI(VBI_SYS_int_enable)
-	ori	r0, r0, LO(VBI_SYS_int_enable)
-	HCALL
-	b	tryAgain
-0:
-	blr
-FUNC_END(vbiIntVCoreUnlock)
-
- /*******************************************************************************   
- *
- * vbiIntVCoreLock - lock interrupts
- *
- * This routine locks interrupts for the calling core. This is a C wrapper 
- * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
- * and returns the previous state of interrupts.
- *
- * SYNOPSIS
- *\cs
- * 
- * VBI PPC Architecture Supplements
- *
- * vbiIntState_t vbiIntVCoreLock (void)
- *
- *\ce
- *
- * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
- *
- * ERROR CODES: N/A
- *
- * SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
- *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
- */
-
-FUNC_LABEL(vbiIntVCoreLock)
-	li	p1, -1
-	lis	p2, HIADJ(wrhvVbControl)
-	lwz	p2, LO(wrhvVbControl)(p2)
-	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
-	stw	p1, VB_CONTROL_INT_DISABLE(p2)
-	blr
-FUNC_END(vbiIntVCoreLock)
-
-/*******************************************************************************
-*
-* vbiIntVCoreStateGet - Get interrupts state for running core
-*
-* This routine returns the interrupts state for the calling core. This is C 
-* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
-* returns TRUE if interrupts are locked otherwise FALSE.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiIntStatus_t vbiIntVCoreStateGet (void)
-*
-*\ce
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
-*/
-
-FUNC_LABEL(vbiIntVCoreStateGet)
-    lis	p2, HIADJ(wrhvVbControl)
-    lwz	p2, LO(wrhvVbControl)(p2)
-    lwz	p0, VB_CONTROL_INT_DISABLE(p2)
-    blr
-FUNC_END(vbiIntVCoreStateGet)
-
-/*******************************************************************************
-*
-* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
-*
-* This routine changes the exceptions vector table base address for the active
-* virtual core. By default the base address of the exception table is at address
-* 0x0.
-* If the guest OS programmer wishes to move this address then this function must
-* be called to inform hypervisor. This function must be called with interrupts
-* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcBaseSet 
-*	    (
-*	    void * excTblBase /@ New exception table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
-*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
-*/
-
-FUNC_LABEL(vbiExcBaseSet)
-
-	/* 
-	 * r3 has the base address to set; make sure it is aligned  
-	 * align to 32 bytes  
-	 */	    
-
-	andi. r4, r3, 31
-	cmpwi r4, 0
-	bne- baseAlignError
-
-	/* set command for the ioctl */
-
-	mr      r4, r3
-	li	r3, VBI_HYIOCTL_EXCBASE
-	
-	/* set the hypercall number */
-
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
-	blr
-baseAlignError:
-	li r3, VBI_EXCBASE_SET_ERROR
-	blr	
-
-FUNC_END(vbiExcBaseSet)
-
-/*******************************************************************************
-*
-* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
-*
-* This routine changes the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* If the guest OS programmer wishes to move these address then this function 
-* must be called to inform hypervisor. This function must be called with 
-* interrupts disabled to prevent hypervisor to deliver interrupts to an 
-* incorrect exception offset. The table is not validated by the hypervisor so
-* it must be complete and functional otherwize the VB will not behave as 
-* expected.
-* For SMP systems it is recommended this API be called for each core as it is
-* started up and before it's added to the scheduler for the guest OS.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsSet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiExcOffsetsGet
-*/
-
-FUNC_LABEL(vbiExcOffsetsSet)
-	/* set command for the ioctl */
-	mr      r4, r3
-	li	r3, VBI_HYIOCTL_EXCOFFSETS_SET
-	
-	/* set the hypercall number */
-
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
-	blr
-FUNC_END(vbiExcOffsetsSet)
-
-/*******************************************************************************
-*
-* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
-*
-* This routine gets the exceptions vector table offset addresses for the 
-* active virtual core. By default they follow the standard PPC exception 
-* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
-* virtual board. The offset table uses an index based on IVOR number.
-* 
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiExcOffsetsGet 
-*	    (
-*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
-*	    )
-*
-*\ce
-*
-* RETURNS: OK or error number if operation fails to complete 
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiExcOffsetsSet
-*/
-
-FUNC_LABEL(vbiExcOffsetsGet)
-	/* set command for the ioctl */
-	mr      r4, r3
-	li	r3, VBI_HYIOCTL_EXCOFFSETS_GET
-	
-	/* set the hypercall number */
-
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
-	blr
-FUNC_END(vbiExcOffsetsGet)
-
-/*******************************************************************************
-*
-* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
-*
-* This routine makes a hypercall to flush the data cache then invalidates the
-* instruction cache of the calling core for the specified address range.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiCacheTextUpdate 
-*	    (
-*	    void * addr /@ starting address to perform textUpdate operation @/
-*	    size_t len  /@ length of memory in bytes			    @/
-*	    ) 
-*
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
-*/
-
-FUNC_LABEL(vbiCacheTextUpdate)
-	lis	r0, HI(VBI_SYS_cache_text_update)
-	ori	r0, r0, LO(VBI_SYS_cache_text_update)
-	HCALL
-	blr
-FUNC_END(vbiCacheTextUpdate)
-
-/******************************************************************************
-*
-* vbiVmmuConfig - configure the hypervisor virtual MMU
-*
-* This system call configures the context's virtual MMU within the hypervisor.
-*
-* C interface:
-*
-*   vbiVmmuConfig (VMMU_CONFIG *config) /@ The vmmu configuration @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiVmmuConfig)
-	lis	r0, HI(VBI_SYS_vmmu_config)
-	ori	r0, r0, LO(VBI_SYS_vmmu_config)
-	HCALL
-	blr
-FUNC_END(vbiVmmuConfig)
-
-
-/******************************************************************************
-*
-* vbiVmmuEnable - enables the virtual MMU
-*
-* This system call enables a context's virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuEnable (unsigned int vmmu_num) /@ Enable the specified VMMU @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiVmmuEnable)
-	lis	r0, HI(VBI_SYS_vmmu_enable)
-	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
-	HCALL
-	blr
-FUNC_END(vbiVmmuEnable)
-
-
-/******************************************************************************
-*
-* vbiVmmuDisable - disable the virtual MMU
-*
-* This system call disables a context's virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuDisable (unsigned int vmmu_num) /@ Disable the specified VMMU @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiVmmuDisable)
-	lis	r0, HI(VBI_SYS_vmmu_disable)
-	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
-	HCALL
-	blr
-FUNC_END(vbiVmmuDisable)
-
-
-/******************************************************************************
-*
-* vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
-*
-* This system call loads the TLB entries for the specified address range into
-* the virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuTlbLoad (VMMU_CONFIG *config, /@ The VMMU being used @/
-*                   void *addr,		 /@ Starting address    @/
-*                   unsigned int len)    /@ length              @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiVmmuTlbLoad)
-	lis	r0, HI(VBI_SYS_vmmu_tlbload)
-	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
-	HCALL
-	blr
-FUNC_END(vbiVmmuTlbLoad)
-
-
-/******************************************************************************
-*
-* vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
-*
-* This system call flushes the TLB entries for the specified address range
-* from the virtual MMU.
-*
-* C interface:
-*
-*   vbiVmmuTlbFlush (VMMU_CONFIG *config, /@ The VMMU configuration to use @/
-*		     void *addr,          /@ Starting address              @/
-*		     unsigned int len)    /@ length                        @/
-*
-* Returns: OK or ERROR
-*
-*/
-
-FUNC_LABEL(vbiVmmuTlbFlush)
-	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
-	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
-	HCALL
-	blr
-FUNC_END(vbiVmmuTlbFlush)
-
-
-/******************************************************************************
-*
-* vbiHyIoctl - hypervisor ioctl call
-*
-* This system call interfaces to the general purpose hypervisor ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_HYIOCTL_GETPID
-*     VBI_HYIOCTL_GETPRIORITY
-*     VBI_HYIOCTL_PSDISPLAY
-*     VBI_HYIOCTL_GETSTATS
-*     VBI_HYIOCTL_EXCBASE
-*		
-* C interface:
-*
-*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*               void *arg)          /@ address of information @/
-*
-* Returns: ioctl specific value
-*
-*/
-
-FUNC_LABEL(vbiHyIoctl)
-	lis	r0, HI(VBI_SYS_hyIoctl)
-	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	HCALL
-	blr
-FUNC_END(vbiHyIoctl)
-
-/******************************************************************************
-*
-* vbiCtxctl - hypervisor context control call
-*
-* This system call interfaces to the general purpose hypervisor context
-* control function.
-*
-* Possbile operations:
-*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
-*
-* C interface:
-*
-*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
-*		 void *arg)		 /@ address of argument @/
-*
-* Returns: ioctl specific value
-*
-*/
-
-FUNC_LABEL(vbiCtxctl)
-	lis	r0, HI(VBI_SYS_ctxctl)
-	ori	r0, r0, LO(VBI_SYS_ctxctl)
-	HCALL
-	blr
-FUNC_END(vbiCtxctl)
-
-/*******************************************************************************
-*
-* vbiMemAttrSet - Set protection for a page of memory
-*
-* This routine makes a hypercall to set the MMU attribures for the specified
-* memory range. The possible attributes one or a combinarion of the following:
-* 
-* VBI_MMU_PROT_READ -  allow supervisor and user read
-* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
-* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiMemAttrSet 
-*		(
-*		void	 *gaddr,	/@ Address of page to change attr   @/
-*		size_t   length,	/@ length of address		    @/
-*		uint32_t attr		/@ mmu attributes to set	    @/
-*		)
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-FUNC_LABEL(vbiMemAttrSet)
-	lis	r0, HI(VBI_SYS_mmu_attr_set)
-	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
-	HCALL
-	blr
-FUNC_END(vbiMemAttrSet)
-
-/******************************************************************************
-*
-* vbiMemAttrGet - Get MMU page protections
-*
-* This routine makes a hypercall to retrieve the MMU attributes associated for
-* the page where the specified address is mapped. This is not the VMMU
-* attributes. A guest OS has direct access to the mapping table of its VMMU
-* therefore a hypercall is not necessary.
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiMemAttrGet 
-*		(
-*		void	 *gaddr		/@ Address of page to change attr   @/
-*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
-*		)
-*\ce
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
-FUNC_LABEL(vbiMemAttrGet)
-	lis	r0, HI(VBI_SYS_mmu_attr_get)
-	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
-	HCALL
-	blr
-FUNC_END(vbiMemAttrGet)
-
-/******************************************************************************
-*
-* vbiIoapicIoctl - virtual IO APIC ioctl call
-*
-* This system call interfaces to the virtual IO APIC ioctl
-* function. For PPC this is a nop routine for now.
-*
-* Possible ioctl commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*		
-* C interface:
-*
-*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*                   unsigned arg1,      /@ address of information @/
-*                   unsigned arg2)      /@ address of information @/
-*
-* Returns: OK
-*
-*/
-
-FUNC_LABEL(vbiIoapicIoctl)
-	lis   r0, HI(VBI_SYS_vIoapicIoctl)
-	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	HCALL
-	blr
-FUNC_END(vbiIoapicIoctl)
-
-/******************************************************************************
-*
-* vbiNsOp - virtua board name service call
-*
-* This system call interfaces to the virtual board
-*
-* commands:
-*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
-*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
-*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
-*				
-* C interface:
-*
-*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
-*	    char * name,		    /@ the service name		@/
-*	    uint32_t revision,	    /@ service revision		@/
-*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
-*	  )
-*
-* Returns: OK or ERROR in case of failure
-*
-*/
-
-FUNC_LABEL(vbiNsOp)
-	lis   r0, HI(VBI_SYS_ns_op)
-	ori	r0, r0, LO(VBI_SYS_ns_op)
-	HCALL
-	blr
-FUNC_END(vbiNsOp)
-
-/*******************************************************************************
-*
-* vbiVbMemoryRead - Read a virtual board's memory
-*
-* This routine makes a hypercall to read a remote board's memory. The memory control
-* structure contains information about the target memory to read and the destination
-* buffer that hypervisor must populate with the data read. This routine is used
-* to copy data from a remote VB. It is the user's responsability to ensure that
-* the memory read is accessed orthogonally.
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-*
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	    @/
-*   void	*pAddress;	    /@ address of calling context	    @/
-*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
-*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
-*   uint32_t	reserved;	    /@ reserved for future use		    @/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbMemoryRead 
-*	(
-*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
-*	vbiVb_t	    targetBoard	    /@ target board				@/
-*	)
-*
-*\ce
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-FUNC_LABEL(vbiVbMemoryRead)
-	lis   r0, HI(VBI_SYS_memRead_op)
-	ori	r0, r0, LO(VBI_SYS_memRead_op)
-	HCALL
-	blr
-FUNC_END(vbiVbMemoryRead)
-
-/*******************************************************************************
-*
-* vbiVbMemoryWrite - copy data to a remote board's memory
-*
-* This routine makes a hypercall to copy to a remote board memory. If the
-* VBI_DCACHE_FLUSH is set in the control memory control structure then this
-* routine flushes the data caches lines corresponding to the range of memory
-* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
-* cache lines corresponding to the range of address is invalidated after the
-* memory is copied. Invalidating the instruction is required if data containing
-* is updated since the instruction cache is not aware of the content in data
-* cache. Therefore flushing the data cache ensures that memory contains the
-* updated data and invalidating the instruction cache ensures that the stale
-* values in the instruction cache is thrown away. 
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-* 
-* 
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	@/
-*   void	*pAddress;	    /@ address of calling context	@/
-*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
-*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
-*   uint32_t	flags;		    /@ data/instruction flush option	@/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*\cs
-* 
-* vbiStatus_t vbiVbMemoryWrite 
-*	(
-*	VBI_MEM_CTL	*memCtl, 
-*	vbiVb_t		targetBoard 
-*	)
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-FUNC_LABEL(vbiVbMemoryWrite)
-	lis	r0, HI(VBI_SYS_memWrite_op)
-	ori	r0, r0, LO(VBI_SYS_memWrite_op)
-	HCALL
-	blr
-FUNC_END(vbiVbMemoryWrite)
-
-/******************************************************************************
-*
-* vbiIoapicOp - virtual IO APIC operation
-*
-* This system call interfaces to the virtual IO APIC ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*		
-* C interface:
-*
-*   vbiIoapicOp (unsigned int ioctl,	/@ the ioctl command      @/
-*                vbiIrq_t irq,		/@ address of information @/
-*                uint32_t filter),      /@ address of information @/
-*                vbiVb_t vbId)		/@ address of information @/
-*
-* Returns: OK
-*
-*/
-
-FUNC_LABEL(vbiIoapicOp)
-	lis   r0, HI(VBI_SYS_vIoapicIoctl)
-	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	HCALL
-	blr
-FUNC_END(vbiIoapicOp)
-
-/*******************************************************************************
-*
-* vbiVbRegisterRead - Read a remote core's registers
-*
-* This routine makes a hypercall to read a remote core's registers. The register
-* control structure contains information about the registers to read and the
-* destination buffers to store them.
-* 
-* SYNOPSIS
-*\cs
-* VBI PPC Architecture Supplements
-*
-* vbiStatus_t vbiVbRegisterRead 
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
-*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
-*	vbiCore_t   core		    /@ core within the target VB    @/
-*	)
-*
-* typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
-*
-*    uint32_t srr0;		/@  0: PC				    @/
-*    uint32_t srr1;		/@  1: MSR				    @/
-*    uint32_t cr;		/@  2: condition registers		    @/
-*    uint32_t r0;		/@  3: General register R0		    @/
-*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;		/@  5: General register R2		    @/
-*    uint32_t r3;		/@  6: General register R3		    @/
-*    uint32_t r4;		/@  7: General register R4		    @/
-*    uint32_t r5;		/@  8: General register R5		    @/
-*    uint32_t r6;		/@  9: General register R6		    @/
-*    uint32_t r7;		/@ 10: General register R7		    @/
-*    uint32_t r8;		/@ 11: General register R8		    @/
-*    uint32_t r9;		/@ 12: General register R9		    @/
-*    uint32_t r10;		/@ 13: General register R10		    @/
-*    uint32_t r11;		/@ 14: General register R11		    @/
-*    uint32_t r12;		/@ 15: General register R12		    @/
-*    uint32_t r13;		/@ 16: General register R13		    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2			    @/
-*
-*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
-*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
-*
-*    /@ data address compare registers DAC1-DAC2.			    @/
-*
-*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
-*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
-*
-*    /@ reserved fields for future use					    @/
-*
-*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-FUNC_LABEL(vbiVbRegisterRead)
-	lis   r0, HI(VBI_SYS_RegsRead_op)
-	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
-	HCALL
-	blr
-FUNC_END(vbiVbRegisterRead)
-
-/*******************************************************************************
-*
-* vbiVbRegisterWrite - write to a remote core's registers
-*
-* This routine makes a hypercall to write to a remote core's registers. The
-* register control structure contains the set of registers to write. 
-* The user must ensure to read first the destination core's registers using
-* vbiVbRegisterRead() then write back the modified set of registers in the 
-* registers control structure.
-* 
-*\cs
-*typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
-*
-*    uint32_t srr0;		/@  0: PC				    @/
-*    uint32_t srr1;		/@  1: MSR				    @/
-*    uint32_t cr;		/@  2: condition registers		    @/
-*    uint32_t r0;		/@  3: General register R0		    @/
-*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;		/@  5: General register R2		    @/
-*    uint32_t r3;		/@  6: General register R3		    @/
-*    uint32_t r4;		/@  7: General register R4		    @/
-*    uint32_t r5;		/@  8: General register R5		    @/
-*    uint32_t r6;		/@  9: General register R6		    @/
-*    uint32_t r7;		/@ 10: General register R7		    @/
-*    uint32_t r8;		/@ 11: General register R8		    @/
-*    uint32_t r9;		/@ 12: General register R9		    @/
-*    uint32_t r10;		/@ 13: General register R10		    @/
-*    uint32_t r11;		/@ 14: General register R11		    @/
-*    uint32_t r12;		/@ 15: General register R12		    @/
-*    uint32_t r13;		/@ 16: General register R13		    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers						    @/
-*    
-*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2			    @/
-*
-*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
-*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
-*
-*    /@ data address compare registers DAC1-DAC2.			    @/
-*
-*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
-*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
-*
-*    /@ reserved fields for future use					    @/
-*
-*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*\ce 
-* VBI PPC Architecture Supplements
-*
-* SYNOPSIS
-*\cs
-* vbiStatus_t vbiVbRegisterWrite
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
-*	vbiVb_t			targetBoard,	/@ The target board		 @/
-*	vbiCore_t		core		/@ The target core within the VB @/
-*	)
-*\ce
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-FUNC_LABEL(vbiVbRegisterWrite)
-	lis   r0, HI(VBI_SYS_RegsWrite_op)
-	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
-	HCALL
-	blr
-FUNC_END(vbiVbRegisterWrite)
-
-
-/*******************************************************************************
-*
-* vbiVcoreIntRed_op - redirect an irq to another vcore
-*
-* SYNOPSIS
-*\cs
-* vbiStatus_t vbiVcoreIntRed_op 
-*	(
-*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
-*	vbiCore_t		core	/@ destination vcore		 @/
-*	)
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: 
-*
-* SEE ALSO: vbiVioapicIntRedirect()
-* 
-*\NOMANUAL
-*/
-
-FUNC_LABEL(vbiVcoreIntRed_op)
-	lis   r0, HI(VBI_SYS_intRedirect)
-	ori	r0, r0, LO(VBI_SYS_intRedirect)
-	HCALL
-	blr
-FUNC_END(vbiVcoreIntRed_op)
diff --git a/arch/powerpc/kernel/vbiUtil.c b/arch/powerpc/kernel/vbiUtil.c
deleted file mode 100644
index 1f46f86..0000000
--- a/arch/powerpc/kernel/vbiUtil.c
+++ /dev/null
@@ -1,144 +0,0 @@
-/* vbi/vbiUtil.c - utilities routines for guest OS para-virtualization */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01a,17jul07, ymz written
-02a,08nov07, mb  moved wrhv_int_lock and friends from init/main.c; formatting fixes
-*/
-
-/*
-This module implements a library which is handy for para-virtualized
-guest os to use. The routines are developed based on the need while
-para-virtualize linux, therefore, may need some tweaks to be generic.
-*/
-
-#include <asm/page.h>
-#include <linux/module.h>
-#include <vbi/interface.h>
-#include <vbi/support/sys/vmmu.h>
-#include <vbi/syscall.h>
-
-
-/* defines */
-
-/* globals */
-
-/*
- * wrhvConfig is initialized as part of the guest os init, before os turns on
- * MMU. For paravirualized linux, it is initialized in plaform_init().
- */
-
-extern VB_CONFIG *wrhvConfig;
-extern VB_STATUS *wrhvStatus;
-extern VB_CONTROL *wrhvControl;
-
-/* local */
-
-/* extern */
-extern void pteAttrSet(VMMU_PTE * pte, u_int attr);
-extern void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon);
-
-/* forward declarations */
-
-unsigned int vb_memsize_get(void)
-{
-	if ((VB_CONFIG *) - 1 == wrhvConfig) {
-		/* vb_memsize_get should not be called before wrhvConfig is init,
-		 * REALLY
-		 */
-		return 0;
-	}
-
-	return (((VB_CONFIG *) wrhvConfig)->physicalMemorySize);
-}
-
-unsigned int vb_context_get(void)
-{
-	if ((VB_CONFIG *) - 1 == wrhvConfig)
-		return 0xdeadbee0;
-	return (((VB_CONFIG *) wrhvConfig)->pid);
-}
-
-void vb_pte_set(void *pPte, unsigned long paddr, int protval)
-{
-
-	/* caller has guaranteed pPte != NULL */
-
-	*(uint *) pPte = (uint) VMMU_PTE_VALID_MASK;
-
-	/* linux uses more than the permission bits, in word1 of PTE */
-
-	*((uint *) ((uint *) pPte) + 1) = (((u_int) paddr & VMMU_PTE_RPN_MASK) | (protval & 0xfff));
-
-	return;
-}
-
-/*
- * turn on mmu for the particular context
- *
- * note, caller must make sure, context switch inside the guest OS must
- * not happen during this call.
- */
-
-int vb_context_mmu_on(int pid,	/* context id */
-		      void *pgtable,	/* level 1 page table */
-		      int pagesize, int debug)
-{
-	static VMMU_CONFIG vmmu_cfg;
-
-	if ((VB_CONFIG *) - 1 == wrhvConfig || NULL == pgtable || pagesize <= 0)
-		return -1;
-
-	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
-	vmmu_cfg.pageSize = pagesize;
-	vmmu_cfg.contextId = pid;
-	vmmu_cfg.vmmuNum = 0;	/* only vmmu 0 is support for the time being */
-
-	if ((vbiVmmuConfig(&vmmu_cfg)) != 0)
-		return -1;
-
-	if (debug) {
-		printk("L1 page table address %p\n", pgtable);
-		vmmuPageTableDisplay(pgtable, 0);
-		printk("End of page table display \n");
-	}
-
-	vbiVmmuEnable(vmmu_cfg.vmmuNum);
-
-	return 0;
-}
-
-void vb__flush_dcache_icache(void *start)
-{
-	vbiIcacheFlush(start, 4096);
-	vbiDcacheFlush(start, 4096);
-}
-
-void vb_flush_dcache_range(unsigned long start, unsigned long stop)
-{
-	vbiDcacheFlush((void *) start, (stop - start + 1));
-}
-
-void vb__flush_icache_range(unsigned long start, unsigned long stop)
-{
-	vbiIcacheFlush((void *) start, (stop - start + 1));
-}
-
-void vb__flush_dcache_icache_phys(unsigned long physaddr)
-{
-	vbiIcacheFlush((void *) physaddr, 4096);
-	vbiDcacheFlush((void *) physaddr, 4096);
-}
-
-EXPORT_SYMBOL_GPL(wrhv_int_lock);
-EXPORT_SYMBOL_GPL(wrhv_int_unlock);
-EXPORT_SYMBOL_GPL(wrhv_int_lvl_get);
diff --git a/arch/powerpc/kernel/vmmuDisplay.c b/arch/powerpc/kernel/vmmuDisplay.c
deleted file mode 100644
index 237797a..0000000
--- a/arch/powerpc/kernel/vmmuDisplay.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/* vbi/vmmuDisplay.c - hypervisor VMMU operations */
-
-/*
- * Copyright (c) 2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-01b,03may07,md   removed vxWorks.h
-01a,19apr07,md   written
-*/
-
-/*
-This module displays the contents of a VMMU page table
-*/
-
-#include <linux/kernel.h>
-#include <vbi/interface.h>
-#include <vbi/support/sys/vmmu.h>
-
-#define __va(paddr) (((unsigned long )(paddr))+0xC0000000)
-#define __pa(vaddr) (((unsigned long )(vaddr))-0xC0000000)
-
-
-/*******************************************************************************
-*
-* vmmuPageTableDisplay - display information about the specified page table
-*
-* This routine display all the VMMU PTE entries in the specified table
-*
-*/
-
-void vmmuPageTableDisplay
-    (
-    VMMU_LEVEL_1_DESC *l1,
-    int                vmmuon
-    )
-    {
-    VMMU_LEVEL_2_DESC  *l2;
-    VMMU_PTE	       *pte;
-    VMMU_EFFECTIVE_ADDR ea;
-    u_int l1_index;
-    u_int i,j;
-
-    l1_index = 0;
-    ea.addr = 0;
-
-    printk ("Logical           Physical          R C U[01234567] WIMGE S[XWR] U[XWR]\n");
-    printk ("----------------- ----------------- - -  ---------- -----  -----  -----\n");
-
-    /* run through all the entries */
-
-    for (i=0; i<VMMU_L1_ENTRIES; i++)
-	{
-	if (l1->field.v)
-	    {
-	    ea.field.l1index = l1_index;
-	    l2 = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba);
-    	    if (vmmuon)
-                l2 = __va (l2);
-	    pte = (VMMU_PTE *)l2;
-	    for (j=0; j<VMMU_L2_ENTRIES; j++)
-		{
-		if (pte->field.v)
-		    {
-		    ea.field.l2index = j;
-		    printk ("%08x-%08x %08x-%08x %d %d ",
-			ea.addr, (u_int)ea.addr + 0xfff,
-			pte->field.rpn << VMMU_RPN_SHIFT,
-			(pte->field.rpn << VMMU_RPN_SHIFT) + 0xfff,
-			pte->field.r, pte->field.c);
-		    printk ("  %d%d%d%d%d%d%d%d  %d%d%d%d%d   %c%c%c    %c%c%c\n",
-			pte->field.u0, pte->field.u1,
-			pte->field.u2, pte->field.u3,
-			pte->field.u4, pte->field.u5,
-			pte->field.u6, pte->field.u7,
-			pte->field.w, pte->field.i, pte->field.m,
-			pte->field.g, pte->field.e,
-			pte->field.sx ? 'X' : ' ',
-			pte->field.sw ? 'W' : ' ',
-			pte->field.sr ? 'R' : ' ',
-			pte->field.ux ? 'X' : ' ',
-			pte->field.uw ? 'W' : ' ',
-			pte->field.ur ? 'R' : ' ');
-		    }
-		pte++;
-		}
-	    }
-	l1++;
-	l1_index++;
-	}
-    }
-
-/*******************************************************************************
-*
-* vmmuPteDisplay - display a specific PTE entry
-*
-* This routine display the VMMU PTE entrie corresponding to the specified
-* virtual address.
-*
-*/
-
-unsigned int vmmuPteDisplay
-    (
-    VMMU_LEVEL_1_DESC *l1, /* pointer to level-1 page table */
-    void   *vaddr	   /* virtual address to display */
-    )
-    {
-    volatile VMMU_LEVEL_2_DESC  *l2;
-    VMMU_PTE	       *pte;
-
-    /* find the level-1 page table descriptor for the virtual address */
-
-    l1 += VMMU_L1_INDEX(vaddr);
-
-    /* if no level-2 table exists abort and return error */
-
-    if (!l1->field.v)
-	{
-	return (-1);
-	}
-
-    /* locate correct PTE entry in level-2 table */
-
-    l2  = (VMMU_LEVEL_2_DESC *)VMMU_LBA_TO_ADDR(l1->field.l2ba) +
-	   VMMU_L2_INDEX(vaddr);
-
-    l2 = __va (l2);
-
-    pte = &l2->pte;
-
-    /* if pte is not valid abort and return error */
-
-    if (!pte->field.v)
-	{
-	return (-1);
-	}
-
-    printk ("PTE for virtual address 0x%08x:\n", vaddr);
-    printk ("  Page Number:  0x%08x\n", pte->field.rpn<<VMMU_RPN_SHIFT);
-    printk ("  Referenced:   %d\n", pte->field.r);
-    printk ("  Changed:      %d\n", pte->field.c);
-    printk ("  User bits:    %d%d%d%d%d%d%d%d\n",
-	pte->field.u0, pte->field.u1,
-	pte->field.u2, pte->field.u3,
-	pte->field.u4, pte->field.u5,
-	pte->field.u6, pte->field.u7);
-    printk ("  WIMGE:        %d%d%d%d%d\n",
-	pte->field.w, pte->field.i, pte->field.m,
-	pte->field.g, pte->field.e);
-    printk ("  Supv Perms:   %c%c%c\n",
-	pte->field.sr ? 'R' : '-',
-	pte->field.sw ? 'W' : '-',
-	pte->field.sx ? 'X' : '-');
-    printk ("  User Perms:   %c%c%c\n",
-	pte->field.ur ? 'R' : '-',
-	pte->field.uw ? 'W' : '-',
-	pte->field.ux ? 'X' : '-');
-
-    return (0);
-    }
diff --git a/arch/powerpc/kernel/wrhv.c b/arch/powerpc/kernel/wrhv.c
deleted file mode 100644
index 7b020a7..0000000
--- a/arch/powerpc/kernel/wrhv.c
+++ /dev/null
@@ -1,956 +0,0 @@
-/*
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2, or (at your option) any
- *  later version.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  Copyright (C) 2009 Wind River Systems, Inc.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/profile.h>
-#include <linux/wrhv.h>
-#include <linux/interrupt.h>
-#include <vbi/interface.h>
-#include <vbi/interrupt.h>
-#include <vbi/errors.h>
-
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/time.h>
-
-#include <linux/threads.h>
-#include <linux/kernel_stat.h>
-#include <linux/signal.h>
-#include <linux/sched.h>
-#include <linux/ptrace.h>
-#include <linux/ioport.h>
-#include <linux/timex.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <trace/trap.h>
-
-#include <linux/seq_file.h>
-#include <linux/cpumask.h>
-#include <linux/bitops.h>
-#include <linux/list.h>
-#include <linux/radix-tree.h>
-#include <linux/mutex.h>
-#include <linux/bootmem.h>
-#include <linux/pci.h>
-#include <linux/debugfs.h> 
-
-#include <asm/uaccess.h>
-#include <asm/system.h>
-#include <asm/io.h>
-#include <asm/cache.h>
-#include <asm/prom.h>
-#include <asm/machdep.h>
-#include <asm/udbg.h>
-#include <asm/firmware.h>
-
-#include <asm/pgalloc.h>
-#include <asm/mmu_context.h>
-#include <asm/mmu.h>
-#include <asm/smp.h>
-#include <asm/btext.h>
-#include <asm/tlb.h>
-#include <asm/sections.h>
-
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/stddef.h>
-#include <linux/highmem.h>
-#include <linux/initrd.h>
-#include <linux/pagemap.h>
-
-#include <linux/kprobes.h>
-#include <linux/kexec.h>
-#include <linux/backlight.h>
-#include <linux/bug.h>
-#include <linux/kdebug.h>
-#include <linux/ltt-core.h>
-#include <linux/kallsyms.h>
-
-#include <mm/mmu_decl.h>
-#include <linux/lmb.h>
-
-#include <linux/major.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/of_platform.h>
-#include <linux/phy.h>
-#include <linux/phy_fixed.h>
-#include <linux/spi/spi.h>
-#include <linux/fsl_devices.h>
-#include <linux/fs_enet_pd.h>
-#include <linux/fs_uart_pd.h>
-
-#include <asm/irq.h>
-#include <sysdev/fsl_soc.h>
-#include <asm/cpm2.h>
-
-#include <linux/kgdb.h>
-#include <asm/current.h>
-#include <asm/processor.h>
-
-#include <asm/paravirt.h>
-
-
-/* powerpc clocksource/clockevent code */
-
-#include <linux/clockchips.h>
-#include <linux/clocksource.h>
-
-static VB_CONFIG __wrhvConfig;
-VB_CONFIG *wrhvConfig;  /* TODO kernel relocation friendly ? */
-VB_CONTROL *wrhvControl;
-VB_STATUS *wrhvStatus;
-VB_CONFIG *razorConfig;
-EXPORT_SYMBOL(wrhvConfig);
-EXPORT_SYMBOL(razorConfig);
-
-void wrhv_mapping(void);
-void mpc85xx_power_down(void);
-
-extern int map_page(unsigned long, phys_addr_t, int);
-
-extern int vb_context_mmu_on(int pid,  /* context id */
-			void *pgtable,    /* level 1 page table */
-			int pagesize, int debug);
-
-unsigned long wrhv_cpu_freq = 0;
-
-void wrhv_mapping(void)
-{
-	/* map in vbConfig address */
-
-	/* WRHV VB_CONFIG should really add a length field for each
-	 * of the objected we mapped.  As the sizes are WRHV
-	 * implementation AND worse, configuration dependent.
-	 *
-	 * For now, we just use 1 page which is fine for the time being.
-	 */
-
-	map_page((unsigned long)wrhvConfig, (unsigned long)wrhvConfig,
-		 _PAGE_RAM);
-
-	map_page((unsigned long)wrhvConfig->vbStatus,
-		 (unsigned long)wrhvConfig->vbStatus, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->vbControl,
-		 (unsigned long)wrhvConfig->vbControl, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->interruptConfiguration,
-		 (unsigned long)wrhvConfig->interruptConfiguration, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->vbControl->vIoapic,
-		 (unsigned long)wrhvConfig->vbControl->vIoapic, _PAGE_RAM);
-
-	razorConfig = wrhvConfig;
-	memcpy(&__wrhvConfig, wrhvConfig, sizeof(__wrhvConfig));
-	/* map any shared memory region info */
-
-	if (wrhvConfig->sharedMemoryRegionsConfigAddress != 0)
-		map_page((unsigned long)wrhvConfig->
-			 sharedMemoryRegionsConfigAddress,
-			 (unsigned long)wrhvConfig->
-			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
-	/* MIPC */
-	map_page(0xfd000000, 0xfd000000, _PAGE_IO);
-	/* devices mapped by the hypervisor xml coqnfiguration */
-
-	return;
-}
-
-unsigned long __init wrhv_find_end_of_memory(void)
-{
-	return wrhvConfig->physicalMemorySize;
-}
-
-void wrhv_power_save(void)
-{
-	local_irq_enable();
-	vbiIdle(1);
-}
-
-void wrhv_restart(void)
-{
-	int ret;
-	vbiVbMgmt(VBI_VBMGMT_RESET, __wrhvConfig.pid, &ret,
-			VBI_VBMGMT_RESET_CLEAR,0);
-	while (1);
-}
-
-static struct irqaction wrhv_timer_irq = {
-	.handler = wrhv_timer_interrupt,
-	.flags= IRQF_DISABLED,
-	.mask = CPU_MASK_NONE,
-	.name = "timer",
-};
-
-void __init wrhv_calibrate_decr(void)
-{
-	/* The timebase is updated every 8 bus clocks */
-	ppc_tb_freq = wrhv_cpu_freq / 8;
-	printk(KERN_DEBUG "WRHV-TIME: wrhv_cpu_freq=%lu  ppc_tb_freq =%lu\n",
-			wrhv_cpu_freq, ppc_tb_freq);
-	
-}
-
-void __init wrhv_time_init(void)
-{
-	return;
-}
-
-void __init wrhv_init_irq(void)
-{
-	int i;
-
-	wrhv_irq_chip.typename = "WRHV-PIC";
-	for (i = 0; i < NR_IRQS; i++) {
-		irq_desc[i].status = IRQ_DISABLED | IRQ_LEVEL;
-		irq_desc[i].action = NULL;
-		irq_desc[i].depth = 1;
-		set_irq_chip_and_handler(i, &wrhv_irq_chip, handle_fasteoi_irq);
-	}
-}
-
-#ifdef CONFIG_DEBUG_VIRTUAL_IRQS
-static irqreturn_t wrhv_vbint(int irq, void * dev_id)
-{
-	printk("[DEBUG VIRTUAL IRQS] Handling the DEBUG IRQ %d\n", irq);
-	return IRQ_HANDLED;
-}
-
-static int __init wrhv_late_init_irq(void)
-{
-	int dev_id = 1;
-	int i;
-
-	/* IRQ 0 is unknown IRQ number for Hypervisor */
-	for (i = 1; i < 32; i++) {
-		if(request_irq(i, wrhv_vbint, IRQF_SHARED, "vbint_single", &dev_id))
-			printk("Unable request IRQ for IRQ %d\n", i);
-	}
-
-	return 0;
-}
-subsys_initcall(wrhv_late_init_irq);
-#endif
-
-unsigned int wrhv_vioapic_get_irq(void)
-{
-	unsigned int irq;
-
-	irq = wrhvControl->intPending;
-
-#ifdef CONFIG_DEBUG_VIRTUAL_IRQS
-	/* Maybe this is useless for real external interrupt */
-	wrhvStatus->intPending = 0;
-#endif
-
-	if (irq == 0xffff)
-		irq = NO_IRQ_IGNORE;
-	else
-		wrhvControl->intPending = 0xffff;
-
-	return irq;
-}
-
-/* refer to native implementation in arch/powerpc/kernel/irq.c */
-extern int get_ppc_spurious_interrupts(void);
-extern void set_ppc_spurious_interrupts(int value);
-
-void wrhv_do_IRQ(struct pt_regs *regs)
-{
-        struct pt_regs *old_regs = set_irq_regs(regs);
-        unsigned int irq;
-#ifdef CONFIG_IRQSTACKS
-        struct thread_info *curtp, *irqtp;
-#endif
-
-        irq_enter();
-
-#ifdef CONFIG_DEBUG_STACKOVERFLOW
-        /* Debugging check for stack overflow: is there less than 2KB free? */
-        {
-                long sp;
-
-                sp = __get_SP() & (THREAD_SIZE-1);
-
-                if (unlikely(sp < (sizeof(struct thread_info) + 2048))) {
-                        printk("do_IRQ: stack overflow: %ld\n",
-                                sp - sizeof(struct thread_info));
-                        dump_stack();
-                }
-        }
-#endif
-
-        /*
-         * Every platform is required to implement ppc_md.get_irq.
-         * This function will either return an irq number or NO_IRQ to
-         * indicate there are no more pending.
-         * The value NO_IRQ_IGNORE is for buggy hardware and means that this
-         * IRQ has already been handled. -- Tom
-         */
-#ifdef CONFIG_WRHV
-check_again:
-#endif
-        irq = ppc_md.get_irq();
-
-        if (irq != NO_IRQ && irq != NO_IRQ_IGNORE) {
-#ifdef CONFIG_IRQSTACKS
-                /* Switch to the irq stack to handle this */
-                curtp = current_thread_info();
-                irqtp = hardirq_ctx[smp_processor_id()];
-                if (curtp != irqtp) {
-                        struct irq_desc *desc = irq_desc + irq;
-                        void *handler = desc->handle_irq;
-                        unsigned long saved_sp_limit = current->thread.ksp_limit;
-                        if (handler == NULL)
-                                handler = &__do_IRQ;
-                        irqtp->task = curtp->task;
-                        irqtp->flags = 0;
-
-                        /* Copy the softirq bits in preempt_count so that the
-                         * softirq checks work in the hardirq context.
-                         */
-                        irqtp->preempt_count =
-                                (irqtp->preempt_count & ~SOFTIRQ_MASK) |
-                                (curtp->preempt_count & SOFTIRQ_MASK);
-
-                        current->thread.ksp_limit = (unsigned long)irqtp +
-                                _ALIGN_UP(sizeof(struct thread_info), 16);
-  			call_handle_irq(irq, desc, irqtp, handler);
-                        current->thread.ksp_limit = saved_sp_limit;
-                        irqtp->task = NULL;
-
-
-                        /* Set any flag that may have been set on the
-                         * alternate stack
-                         */
-                        if (irqtp->flags)
-                                set_bits(irqtp->flags, &curtp->flags);
-                } else
-#endif
-                        generic_handle_irq(irq);
-#ifdef CONFIG_WRHV
-                goto check_again;
-#endif
-        } else if (irq != NO_IRQ_IGNORE)
-                /* That's not SMP safe ... but who cares ? */
-                set_ppc_spurious_interrupts(get_ppc_spurious_interrupts()+1);
-
-        irq_exit();
-        set_irq_regs(old_regs);
-
-#ifdef CONFIG_PPC_ISERIES
-        if (firmware_has_feature(FW_FEATURE_ISERIES) &&
-                        get_lppaca()->int_dword.fields.decr_int) {
-                get_lppaca()->int_dword.fields.decr_int = 0;
-                /* Signal a fake decrementer interrupt */
-                timer_interrupt(regs);
-        }
-#endif
-}
-
-unsigned int wrhv_irq_of_parse_and_map(struct device_node *dev, int index)
-{
-	int irq;
-
-        irq = vbiIntVecFind(dev->full_name, VB_INPUT_INT);
-        if (irq == VBI_INVALID_IRQ)
-                return NO_IRQ;
-
-        return irq;
-}
-
-unsigned int wrhv_get_pvr(void)
-{
-       return 0x80200000;
-}
-
-
-
-
-/* arch/powerpc/kernel/time.c */
-#define HWTIMER_USE_JIFFY 1
-static void wrhv_set_mode(enum clock_event_mode mode,
-                                 struct clock_event_device *dev)
-{
-        return;
-}
-
-static int wrhv_set_next_event(unsigned long evt,
-                                      struct clock_event_device *dev)
-{
-        return 0;
-}
-static struct clock_event_device wrhv_clockevent = {
-       .name           = "wrhv",
-       .shift          = 32,
-       .irq            = 0,
-       .mult           = 1,     /* To be filled in */
-       .set_mode       = wrhv_set_mode,
-       .set_next_event = wrhv_set_next_event,
-       .features       = CLOCK_EVT_FEAT_ONESHOT,
-};
-
-void wrhv_hw_timer_interrupt(struct pt_regs * regs)
-{
-        struct pt_regs *old_regs;
-
-        if (atomic_read(&ppc_n_lost_interrupts) != 0)
-                do_IRQ(regs);
-
-        old_regs = set_irq_regs(regs);
-        irq_enter();
-
-        calculate_steal_time();
-
-        trace_trap_entry(regs, regs->trap);
-
-        wrhv_timer_interrupt(0, NULL);
-
-	irq_exit();
-        set_irq_regs(old_regs);
-        trace_trap_exit();
-}
-
-void __init wrhv_hw_clocksource_init(void)
-{
-	return;
-}
-extern atomic_t hwtimer_cpu_trigger[];
-
-void __init wrhv_hw_time_init(void)
-{
-	return;
-}
-
-
-/* arch/powerpc/mm/fault.c */
-void wrhv_vmmu_restore (void)
-{
-	/*
-	 * this function is called by the end of page fault handling to reinstall
-	 * the vmmu
-	 */
-        wrhvControl->vmmu0 = wrhvStatus->vmmu0;
-        wrhvControl->vmmu1 = wrhvStatus->vmmu1;
-        return;
-}
-
-/* arch/powerpc/mm/fsl_booke_mmu.c */
-void __init wrhv_MMU_init_hw(void)
-{
-	return;
-}
-
-unsigned long __init wrhv_mmu_mapin_ram(void)
-{
-       return 0;
-}
-
-/* arch/powerpc/mm/init_32.c */
-void wrhv_MMU_setup(void)
-{
-        __map_without_bats = 1;
-
-#ifdef CONFIG_DEBUG_PAGEALLOC
-        __map_without_bats = 1;
-        __map_without_ltlbs = 1;
-#endif
-}
-
-void __init wrhv_MMU_init(void)
-{
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:enter", 0x111);
-
-        /* parse args from command line */
-        wrhv_MMU_setup();
-
-        if (lmb.memory.cnt > 1) {
-                lmb.memory.cnt = 1;
-                lmb_analyze();
-                printk(KERN_WARNING "Only using first contiguous memory region");
-        }
-
-        total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
-        lowmem_end_addr = memstart_addr + total_lowmem;
-
-#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_WRHV)
-        /* Freescale Book-E parts expect lowmem to be mapped by fixed TLB
-         * entries, so we need to adjust lowmem to match the amount we can map
-         * in the fixed entries */
-        adjust_total_lowmem();
-#endif /* CONFIG_FSL_BOOKE && !CONFIG_WRHV*/
-
-        if (total_lowmem > __max_low_memory) {
-                total_lowmem = __max_low_memory;
-                lowmem_end_addr = memstart_addr + total_lowmem;
-#ifndef CONFIG_HIGHMEM
-                total_memory = total_lowmem;
-                lmb_enforce_memory_limit(lowmem_end_addr);
-                lmb_analyze();
-#endif /* CONFIG_HIGHMEM */
-        }
-
-        /* Initialize the MMU hardware */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:hw init", 0x300);
-        MMU_init_hw();
-
-        /* Map in all of RAM starting at KERNELBASE */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:mapin", 0x301);
-        mapin_ram();
-#ifdef CONFIG_HIGHMEM
-        ioremap_base = PKMAP_BASE;
-#else
-        ioremap_base = 0xfe000000UL;    /* for now, could be 0xfffff000 */
-#endif /* CONFIG_HIGHMEM */
-        ioremap_bot = ioremap_base;
-
-        /* Map in I/O resources */
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:setio", 0x302);
-
-        /* Initialize the context management stuff */
-        mmu_context_init();
-
-        if (ppc_md.progress)
-                ppc_md.progress("MMU:exit", 0x211);
-
-        /* From now on, btext is no longer BAT mapped if it was at all */
-#ifdef CONFIG_BOOTX_TEXT
-        btext_unmap();
-#endif
-
-        /* we enables the mmu here without having to do this from the caller
-         * (which is in assembly world)
-         */
-        vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
-}
-
-
-/* sysdev/fsl_soc.c */
-extern const char * get_gfar_tx_intr(void);
-extern const char * get_gfar_rx_intr(void);
-extern const char * get_gfar_err_intr(void);
-
-int __init wrhv_gfar_of_init(void)
-{
-        struct device_node *np;
-        unsigned int i;
-        struct platform_device *gfar_dev;
-        struct resource res;
-        int ret;
-
-        for (np = NULL, i = 0;
-             (np = of_find_compatible_node(np, "network", "gianfar")) != NULL;
-             i++) {
-                struct resource r[4];
-                struct device_node *phy, *mdio;
-                struct gianfar_platform_data gfar_data;
-                const unsigned int *id;
-                const char *model;
-                const char *ctype;
-                const void *mac_addr;
-                const phandle *ph;
-                int n_res = 2;
-
-                if (!of_device_is_available(np))
-                        continue;
-
-                memset(r, 0, sizeof(r));
-                memset(&gfar_data, 0, sizeof(gfar_data));
-
-                ret = of_address_to_resource(np, 0, &r[0]);
-                if (ret)
-                        goto err;
-
-                of_irq_to_resource(np, 0, &r[1]);
-
-                model = of_get_property(np, "model", NULL);
-
-                /* If we aren't the FEC we have multiple interrupts */
-                if (model && strcasecmp(model, "FEC")) {
-#if defined(CONFIG_WRHV)
-#include <vbi/interrupt.h>
-                        int vector;
-                        char eTsec_tx[10];
-                        char eTsec_rx[10];
-                        char eTsec_err[10];
-
-                        sprintf(eTsec_tx,"etsec%d_tx", i+1);
-                        sprintf(eTsec_rx,"etsec%d_rx", i+1);
-                        sprintf(eTsec_err,"etsec%d_err", i+1);
-
-                        r[1].name = get_gfar_tx_intr();
-                        vector = vbiIntVecFind(eTsec_tx, VB_INPUT_INT);
-                        r[1].start = vector;
-                        r[1].end = vector;
-                        r[1].flags = IORESOURCE_IRQ;
-
-                        r[2].name = get_gfar_rx_intr();
-                        vector = vbiIntVecFind(eTsec_rx, VB_INPUT_INT);
-                        r[2].start = vector;
-                        r[2].end = vector;
-                        r[2].flags = IORESOURCE_IRQ;
-
-                        r[3].name = get_gfar_err_intr();
-                        vector = vbiIntVecFind(eTsec_err, VB_INPUT_INT);
-                        r[3].start = vector;
-			r[3].end = vector;
-                        r[3].flags = IORESOURCE_IRQ;
-#else
-                        r[1].name = gfar_tx_intr;
-
-                        r[2].name = gfar_rx_intr;
-                        of_irq_to_resource(np, 1, &r[2]);
-
-                        r[3].name = gfar_err_intr;
-                        of_irq_to_resource(np, 2, &r[3]);
-#endif
-                        n_res += 2;
-                }
-
-                gfar_dev =
-                    platform_device_register_simple("fsl-gianfar", i, &r[0],
-                                                    n_res);
-
-                if (IS_ERR(gfar_dev)) {
-                        ret = PTR_ERR(gfar_dev);
-                        goto err;
-                }
-
-                mac_addr = of_get_mac_address(np);
-                if (mac_addr)
-                        memcpy(gfar_data.mac_addr, mac_addr, 6);
-
-                if (model && !strcasecmp(model, "TSEC"))
-                        gfar_data.device_flags =
-                            FSL_GIANFAR_DEV_HAS_GIGABIT |
-                            FSL_GIANFAR_DEV_HAS_COALESCE |
-                            FSL_GIANFAR_DEV_HAS_RMON |
-                            FSL_GIANFAR_DEV_HAS_MULTI_INTR;
-                if (model && !strcasecmp(model, "eTSEC"))
-                        gfar_data.device_flags =
-                            FSL_GIANFAR_DEV_HAS_GIGABIT |
-                            FSL_GIANFAR_DEV_HAS_COALESCE |
-                            FSL_GIANFAR_DEV_HAS_RMON |
-                            FSL_GIANFAR_DEV_HAS_MULTI_INTR |
-                            FSL_GIANFAR_DEV_HAS_CSUM |
-                            FSL_GIANFAR_DEV_HAS_VLAN |
-                            FSL_GIANFAR_DEV_HAS_EXTENDED_HASH;
-
-                ctype = of_get_property(np, "phy-connection-type", NULL);
-
-                /* We only care about rgmii-id.  The rest are autodetected */
-                if (ctype && !strcmp(ctype, "rgmii-id"))
-                        gfar_data.interface = PHY_INTERFACE_MODE_RGMII_ID;
-                else
-                        gfar_data.interface = PHY_INTERFACE_MODE_MII;
-
-                if (of_get_property(np, "fsl,magic-packet", NULL))
-                        gfar_data.device_flags |= FSL_GIANFAR_DEV_HAS_MAGIC_PACKET;
-
-                ph = of_get_property(np, "phy-handle", NULL);
-		if (ph == NULL) {
-                        u32 *fixed_link;
-
-                        fixed_link = (u32 *)of_get_property(np, "fixed-link",
-                                                           NULL);
-                        if (!fixed_link) {
-                                ret = -ENODEV;
-                                goto unreg;
-                        }
-
-                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "0");
-                        gfar_data.phy_id = fixed_link[0];
-                } else {
-                        phy = of_find_node_by_phandle(*ph);
-
-                        if (phy == NULL) {
-                                ret = -ENODEV;
-                                goto unreg;
-                        }
-
-                        mdio = of_get_parent(phy);
-
-                        id = of_get_property(phy, "reg", NULL);
-                        ret = of_address_to_resource(mdio, 0, &res);
-                        if (ret) {
-                                of_node_put(phy);
-                                of_node_put(mdio);
-                                goto unreg;
-                        }
-
-                        gfar_data.phy_id = *id;
-                        snprintf(gfar_data.bus_id, MII_BUS_ID_SIZE, "%llx",
-                                 (unsigned long long)res.start&0xfffff);
-
-                        of_node_put(phy);
-                        of_node_put(mdio);
-                }
-
-                ret =
-                    platform_device_add_data(gfar_dev, &gfar_data,
-                                             sizeof(struct
-                                                    gianfar_platform_data));
-                if (ret)
-                        goto unreg;
-        }
-
-        return 0;
-
-unreg:
-        platform_device_unregister(gfar_dev);
-err:
-        return ret;
-}
-
-/* arch/powerpc/mm/mem.c */
-extern void __flush_dcache_icache_phys(unsigned long physaddr);
-void wrhv_flush_dcache_page(struct page *page)
-{
-        if (cpu_has_feature(CPU_FTR_COHERENT_ICACHE))
-                return;
-        /* avoid an atomic op if possible */
-        if (test_bit(PG_arch_1, &page->flags))
-                clear_bit(PG_arch_1, &page->flags);
-        __flush_dcache_icache_phys(page_to_pfn(page) << PAGE_SHIFT);
-}
-
-void wrhv_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
-                      pte_t pte)
-{
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-        unsigned long access = 0, trap;
-#endif
-#endif /* !CONFIG_WRHV */
-        unsigned long pfn = pte_pfn(pte);
-
-        /* handle i-cache coherency */
-        if (!cpu_has_feature(CPU_FTR_COHERENT_ICACHE) &&
-            !cpu_has_feature(CPU_FTR_NOEXECUTE) &&
-            pfn_valid(pfn)) {
-                struct page *page = pfn_to_page(pfn);
-#ifdef CONFIG_8xx
-                /* On 8xx, cache control instructions (particularly
-                 * "dcbst" from flush_dcache_icache) fault as write
-                 * operation if there is an unpopulated TLB entry
-                 * for the address in question. To workaround that,
-                 * we invalidate the TLB here, thus avoiding dcbst
-                 * misbehaviour.
-                 */
-                _tlbie(address, 0 /* 8xx doesn't care about PID */);
-#endif
-                /* The _PAGE_USER test should really be _PAGE_EXEC, but
-                 * older glibc versions execute some code from no-exec
-                 * pages, which for now we are supporting.  If exec-only
-                 * pages are ever implemented, this will have to change.
-                 */
-                if (!PageReserved(page) && (pte_val(pte) & _PAGE_USER)
-                    && !test_bit(PG_arch_1, &page->flags)) {
-                        if (vma->vm_mm == current->active_mm) {
-                                __flush_dcache_icache((void *) address);
-                        } else
-                                flush_dcache_icache_page(page);
-                        set_bit(PG_arch_1, &page->flags);
-                }
-        }
-
-#ifndef CONFIG_WRHV
-#ifdef CONFIG_PPC_STD_MMU
-        /* We only want HPTEs for linux PTEs that have _PAGE_ACCESSED set */
-        if (!pte_young(pte) || address >= TASK_SIZE)
-                return;
-
-        /* We try to figure out if we are coming from an instruction
-         * access fault and pass that down to __hash_page so we avoid
-         * double-faulting on execution of fresh text. We have to test
-         * for regs NULL since init will get here first thing at boot
-         *
-         * We also avoid filling the hash if not coming from a fault
-         */
-        if (current->thread.regs == NULL)
-                return;
-        trap = TRAP(current->thread.regs);
-  	if (trap == 0x400)
-                access |= _PAGE_EXEC;
-        else if (trap != 0x300)
-                return;
-        hash_preload(vma->vm_mm, address, access, trap);
-#endif /* CONFIG_PPC_STD_MMU */
-#endif /* !CONFIG_WRHV */
-}
-
-/* arch/powerpc/mm/mmu_context_32.c */
-void set_context(unsigned long contextId, pgd_t * pgd)
-{
-
-        pgd_t * kpdStart, *kpdEnd, *updStart;
-        /* we attach (copy) kernel page mapping to the user page table
-         * Note, we only copy the L1 entrys to user L1 pageTable,
-         * then letting L1 share the same L2 page table
-         */
-
-        kpdStart = pgd_offset_k(KERNELBASE);
-        kpdEnd =   pgd_offset_k(0xffffffff);
-
-        updStart = pgd + pgd_index(KERNELBASE);
-
-        memcpy(updStart, kpdStart, (kpdEnd - kpdStart + 1) * sizeof (pgd_t));
-
-        /* in linux context, page table entry is not set up yet */
-        vb_context_mmu_on(contextId, pgd, PAGE_SIZE, 0);
-}
-
-/* arch/powerpc/mm/pgtable_32.c */
-int wrhv_map_page(unsigned long va, phys_addr_t pa, int flags)
-{
-        pmd_t *pd;
-        pte_t *pg;
-        int err = -ENOMEM;
-
-        /* Use upper 10 bits of VA to index the first level map */
-        pd = pmd_offset(pud_offset(pgd_offset_k(va), va), va);
-        /* Use middle 10 bits of VA to index the second-level map */
-        pg = pte_alloc_kernel(pd, va);
-        if (pg != 0) {
-                err = 0;
-                /* The PTE should never be already set nor present in the
-                 * hash table
-                 */
-                BUG_ON(pte_val(*pg) & (_PAGE_PRESENT | _PAGE_HASHPTE));
-                set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
-                                                     __pgprot(flags)));
-        }
-        if (mem_init_done)
-                flush_HPTE(0, va, pmd_val(*pmd));
-        return err;
-}
-
-
-/* arch/powerpc/kernel/traps.c */
-void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_status)
-{
-        debug_status = wrhvControl->vbControlRegs.dbsr;
-        wrhvControl->vbControlRegs.emsr &= ~MSR_DE;
-        
-	if (debug_status & DBSR_IC) {   /* instruction completion */
-                regs->msr &= ~MSR_DE;
-                if (notify_die(DIE_SSTEP, "single_step", regs, 5,
-                               5, SIGTRAP) == NOTIFY_STOP) {
-                        return;
-                }
-
-                if (debugger_sstep(regs))
-                        return;
-
-                if (user_mode(regs)) {
-                        current->thread.dbcr0 &= ~DBCR0_IC;
-                }
-
-                _exception(SIGTRAP, regs, TRAP_TRACE, regs->nip);
-        } else if (debug_status & (DBSR_DAC1R | DBSR_DAC1W)) {
-                regs->msr &= ~MSR_DE;
-
-                if (user_mode(regs)) {
-                        current->thread.dbcr0 &= ~(DBSR_DAC1R | DBSR_DAC1W |
-                                                                DBCR0_IDM);
-                } else {
-                        /* Disable DAC interupts */
-                        mtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~(DBSR_DAC1R |
-                                                DBSR_DAC1W | DBCR0_IDM));
-
-                        /* Clear the DAC event */
-                        mtspr(SPRN_DBSR, (DBSR_DAC1R | DBSR_DAC1W));
-                }
-                /* Setup and send the trap to the handler */
-                do_dabr(regs, mfspr(SPRN_DAC1), debug_status);
-        }
-}
-
-/* arch/powerpc/kernel/kgdb.c */
-int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
-                               char *remcom_in_buffer, char *remcom_out_buffer,
-                               struct pt_regs *linux_regs)
-{
-        char *ptr = &remcom_in_buffer[1];
-        unsigned long addr; 
-
-        switch (remcom_in_buffer[0]) {
-                /*
-                 * sAA..AA   Step one instruction from AA..AA
-                 * This will return an error to gdb ..
-                 */
-        case 's':
-        case 'c':
-                /* handle the optional parameter */
-                if (kgdb_hex2long(&ptr, &addr))
-                        linux_regs->nip = addr;
-
-                atomic_set(&kgdb_cpu_doing_single_step, -1);
-                /* set the trace bit if we're stepping */
-                if (remcom_in_buffer[0] == 's') {
-#if defined(CONFIG_40x) || defined(CONFIG_BOOKE)
-#ifdef CONFIG_WRHV
-                        wrhvControl->vbControlRegs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
-#else
-                        mtspr(SPRN_DBCR0,
-                              mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);
-#endif
-                        linux_regs->msr |= MSR_DE;
-#else
-                        linux_regs->msr |= MSR_SE;
-#endif
-                        kgdb_single_step = 1;
-                        atomic_set(&kgdb_cpu_doing_single_step,
-                                   raw_smp_processor_id());
-                }
-                return 0;
-        }
-
-        return -1;
-}
-
-
-void wrhv_init(void)
-{
-	pv_time_ops.hw_time_init = wrhv_hw_time_init;
-        pv_time_ops.hw_timer_interrupt = wrhv_hw_timer_interrupt;
-        pv_time_ops.hw_clocksource_init = wrhv_hw_clocksource_init;
-
-        pv_irq_ops.do_IRQ = wrhv_do_IRQ;
-        pv_irq_ops.irq_of_parse_and_map =
-			wrhv_irq_of_parse_and_map;
-
-	pv_cpu_ops.get_pvr = wrhv_get_pvr;
-	pv_cpu_ops.gfar_of_init =  wrhv_gfar_of_init;
-        pv_cpu_ops.DebugException = wrhv_DebugException;
-        pv_cpu_ops.kgdb_arch_handle_exception = 
-                wrhv_kgdb_arch_handle_exception;
-
-	pv_mmu_ops.vmmu_restore = wrhv_vmmu_restore;
-        pv_mmu_ops.MMU_init_hw = wrhv_MMU_init_hw;
-        pv_mmu_ops.mmu_mapin_ram = wrhv_mmu_mapin_ram;
-        pv_mmu_ops.MMU_setup = wrhv_MMU_setup;
-        pv_mmu_ops.MMU_init = wrhv_MMU_init;
-        pv_mmu_ops.flush_dcache_page = wrhv_flush_dcache_page;
-        pv_mmu_ops.update_mmu_cache = wrhv_update_mmu_cache;
-        pv_mmu_ops.map_page = wrhv_map_page;
-}
-- 
1.6.3.3

