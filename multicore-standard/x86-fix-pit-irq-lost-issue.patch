From 77c565f23f2a513c6ef397e70dfafecbc6092db4 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 30 Nov 2009 23:36:12 -0800
Subject: [PATCH] x86: fix pit irq lost issue

PIT is programmed as an edge triggered interrupt by wrhv,
and the interrupt can be lost when it is in mask status
on IO-APIC. Here use handle_edge_irq() to handle PIT timer
interrupt so as to make hypervisor first unmask it on IO-APIC,
then handle it in guest side.

Here also create struct irq_chip wrhv_ipi_irq_chip which is dedicated
to IPI interrupts, and it avoids setting ack to NULL for wrhv_irq_chip.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c |   17 +++++++++++------
 1 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 752817d..67bfeea 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -868,28 +868,31 @@ static unsigned int smp_wrhv_startup_irq(unsigned int irq)
 	return 0;
 }
 
+static struct irq_chip wrhv_ipi_irq_chip;
 void __init wrhv_smp_prepare_cpus(unsigned int max_cpus)
 {
 	int ret;
 	native_smp_prepare_cpus(max_cpus);
 
-	wrhv_irq_chip.ack = NULL;
+	memcpy(&wrhv_ipi_irq_chip, &wrhv_irq_chip, sizeof(wrhv_irq_chip));
+	wrhv_ipi_irq_chip.ack = NULL;
+
 	wrhv_irq_chip.startup = smp_wrhv_startup_irq;
 	wrhv_irq_chip.shutdown = smp_wrhv_shutdown_irq;
 
 	set_irq_chip_and_handler_name(WRHV_IPI_RESCHED,
-			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 	set_irq_chip_and_handler_name(WRHV_IPI_INV_TLB,
-			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 	set_irq_chip_and_handler_name(WRHV_IPI_FUNC_CALL,
-			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 	set_irq_chip_and_handler_name(WRHV_IPI_FUNC_CALL_SINGLE,
-			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 
 #ifdef CONFIG_WRHV_X86_HRTIMERS
 	if (enable_hrtimer)
 		set_irq_chip_and_handler_name(DUMMY_TIMER_INT,
-				&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 #endif
 
 	ret = request_irq(WRHV_IPI_RESCHED, wrhv_ipi_resched_handler,
@@ -1262,6 +1265,8 @@ void __init wrhv_setup_timer_irq(void)
 		printk(KERN_INFO "WRHV: HRTIMER is NOT present.\n");
 	} else {
 		enable_hrtimer = 1;
+		set_irq_chip_and_handler_name(TIMER_INT_NUM, &wrhv_irq_chip,
+					      handle_edge_irq, "edge");
 		printk(KERN_INFO "WRHV: HRTIMER is present.\n");
 	}
 #else
-- 
1.6.5.2

