From da244ec4fc0704d2e12dc214e4cc6df8210ec720 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Wed, 2 Dec 2009 19:51:35 -0800
Subject: [PATCH 58/59] common irq_chip adjustment

Move specific irq_chip functions which are implemented
on x86 platform into common file.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c |   58 ------------------------------------
 include/linux/wrhv.h       |    4 ++
 kernel/vbi/wrhv.c          |   70 ++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 74 insertions(+), 58 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 2b02d9e..c687982 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -817,69 +817,11 @@ static void inline wrhv_umask_IPIs_for_vcore(void)
 #endif
 }
 
-static void x86_wrhv_mask_irq(void *irq)
-{
-	vbi_mask_vioapic_irq((unsigned int)irq);
-}
-
-static void x86_wrhv_unmask_irq(void *irq)
-{
-	vbi_unmask_vioapic_irq((unsigned int)irq);
-}
-
-/* Currently all the external interrupts are routed to cpu 0 and
- * handled by cpu0, so we need make sure the startup/shutdown functions
- * operate cpu 0's vioapic.
- */
-static void smp_wrhv_shutdown_irq(unsigned int irq)
-{
-	if (smp_processor_id() == 0)
-		x86_wrhv_mask_irq((void *)irq);
-	else {
-		struct call_single_data *data;
-
-		data = kmalloc(sizeof(*data), GFP_ATOMIC);
-		if (!data)
-			return;
-
-		data->flags = CSD_FLAG_ALLOC;
-		data->func = x86_wrhv_mask_irq;
-		data->info = (void *)irq;
-		__smp_call_function_single(0, data);
-	}
-}
-
-static unsigned int smp_wrhv_startup_irq(unsigned int irq)
-{
-	if (smp_processor_id() == 0)
-		x86_wrhv_unmask_irq((void *)irq);
-	else {
-		struct call_single_data *data;
-
-		data = kmalloc(sizeof(*data), GFP_ATOMIC);
-		if (!data)
-			return -ENOMEM;
-
-		data->flags = CSD_FLAG_ALLOC;
-		data->func = x86_wrhv_unmask_irq;
-		data->info = (void *)irq;
-		__smp_call_function_single(0, data);
-	}
-	return 0;
-}
-
-static struct irq_chip wrhv_ipi_irq_chip;
 void __init wrhv_smp_prepare_cpus(unsigned int max_cpus)
 {
 	int ret;
 	native_smp_prepare_cpus(max_cpus);
 
-	memcpy(&wrhv_ipi_irq_chip, &wrhv_irq_chip, sizeof(wrhv_irq_chip));
-	wrhv_ipi_irq_chip.ack = NULL;
-
-	wrhv_irq_chip.startup = smp_wrhv_startup_irq;
-	wrhv_irq_chip.shutdown = smp_wrhv_shutdown_irq;
-
 	set_irq_chip_and_handler_name(WRHV_IPI_RESCHED,
 			&wrhv_ipi_irq_chip, handle_percpu_irq, "per_cpu");
 	set_irq_chip_and_handler_name(WRHV_IPI_INV_TLB,
diff --git a/include/linux/wrhv.h b/include/linux/wrhv.h
index 663cfc4..885269d 100644
--- a/include/linux/wrhv.h
+++ b/include/linux/wrhv.h
@@ -20,6 +20,10 @@ extern irqreturn_t wrhv_timer_interrupt(int irq, void *dev_id);
 extern unsigned long wrhv_calculate_cpu_khz(void);
 extern struct irq_chip wrhv_irq_chip;
 
+#ifdef CONFIG_SMP
+extern struct irq_chip wrhv_ipi_irq_chip;
+#endif
+
 /* IO APIC register get/set macros */
 /* Accesses are double words using an
  * indirect addressing scheme.
diff --git a/kernel/vbi/wrhv.c b/kernel/vbi/wrhv.c
index a7748e8..59fa6a7 100644
--- a/kernel/vbi/wrhv.c
+++ b/kernel/vbi/wrhv.c
@@ -19,6 +19,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/wrhv.h>
 #include <linux/sched.h>
+#include <linux/smp.h>
 #include <vbi/vbi.h>
 
 #define VIOAPIC_BASE_ADDR	(&wr_vb_control->vIoapic)
@@ -57,8 +58,65 @@ static void wrhv_unmask_irq(unsigned int irq)
 		vbi_unmask_vioapic_irq(irq);
 }
 
+#ifdef CONFIG_SMP
+static void smp_wrhv_mask_irq(void *irq)
+{
+	vbi_mask_vioapic_irq((unsigned int)irq);
+}
+
+static void smp_wrhv_unmask_irq(void *irq)
+{
+	vbi_unmask_vioapic_irq((unsigned int)irq);
+}
+
+/* Currently all the external interrupts are routed to cpu 0 and
+ * handled by cpu0, so we need make sure the startup/shutdown functions
+ * operate cpu 0's vioapic.
+ */
+static void smp_wrhv_shutdown_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		smp_wrhv_mask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = smp_wrhv_mask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+}
+
+static unsigned int smp_wrhv_startup_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		smp_wrhv_unmask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = smp_wrhv_unmask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+	return 0;
+}
+#endif
+
 struct irq_chip wrhv_irq_chip = {
 	.name		= "WRHV-PIC",
+#ifdef CONFIG_SMP
+	.startup	= smp_wrhv_startup_irq,
+	.shutdown	= smp_wrhv_shutdown_irq,
+#endif
 	.mask		= wrhv_mask_irq,
 	.ack		= wrhv_ack_irq,
 	.disable	= wrhv_disable_irq,
@@ -68,6 +126,18 @@ struct irq_chip wrhv_irq_chip = {
 	.eoi		= wrhv_ack_irq,
 };
 
+#ifdef CONFIG_SMP
+struct irq_chip wrhv_ipi_irq_chip = {
+	.name		= "WRHV-IPI-PIC",
+	.mask		= wrhv_mask_irq,
+	.disable	= wrhv_disable_irq,
+	.enable		= wrhv_enable_irq,
+	.unmask		= wrhv_unmask_irq,
+	.mask_ack	= wrhv_maskack_irq,
+	.eoi		= wrhv_ack_irq,
+};
+#endif
+
 unsigned long wrhv_calculate_cpu_khz(void)
 {
 	printk(KERN_DEBUG "WRHV: Timestamp Frequency %u Hz\n",
-- 
1.6.5.2

