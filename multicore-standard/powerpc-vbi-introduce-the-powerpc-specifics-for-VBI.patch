From 4177fe0d6dac21ece0a91f032843e28649e9bedd Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:07:08 -0400
Subject: [PATCH 03/20] powerpc vbi: introduce the powerpc specifics for VBI

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/powerpc/include/asm/vbiPpcArch.h |  691 ++++++++++++++
 arch/powerpc/kernel/vbiSyscalls.S     | 1626 +++++++++++++++++++++++++++++++++
 arch/powerpc/kernel/vbiUtil.c         |  144 +++
 include/vbi/ppc/vbiPpcArch.h          |  934 +++++++++++++++++++
 include/vbi/support/sys/ppc/asm.h     |  526 +++++++++++
 include/vbi/support/sys/ppc/ppc85xx.h |  641 +++++++++++++
 include/vbi/support/sys/ppc/regs.h    |   69 ++
 7 files changed, 4631 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/include/asm/vbiPpcArch.h
 create mode 100644 arch/powerpc/kernel/vbiSyscalls.S
 create mode 100644 arch/powerpc/kernel/vbiUtil.c
 create mode 100644 include/vbi/ppc/vbiPpcArch.h
 create mode 100644 include/vbi/support/sys/ppc/asm.h
 create mode 100644 include/vbi/support/sys/ppc/ppc85xx.h
 create mode 100644 include/vbi/support/sys/ppc/regs.h

diff --git a/arch/powerpc/include/asm/vbiPpcArch.h b/arch/powerpc/include/asm/vbiPpcArch.h
new file mode 100644
index 0000000..ac30c7d
--- /dev/null
+++ b/arch/powerpc/include/asm/vbiPpcArch.h
@@ -0,0 +1,691 @@
+/* vbiPpcArch.h - PowerPC architecture specific definitions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01m,07jul09,mmi  fix comment of int locking macro
+01l,22jun09,mmi  add assembly macros to read regs.
+01k,11jun09,mmi  add interrupts macros
+01j,10jun09,mmi  add assembly macro's for context switch and interrupts
+01i,08jun09,md   add define for maximum number of cores
+01h,08jun09,mmi  update descriptions
+01g,25may09,md   add byte order define
+01f,09feb09,mmi  add defines for vbi exception management
+01e,29jan09,dtr  debug.
+01d,29jan09,dtr  Remove some old defs.
+01c,28jan09,dtr  Use new structures.
+01b,23jan09,mmi  add debug registers
+01a,21jan09,mmi  created
+*/
+
+#ifndef __INCvbiPpcArchh
+#define __INCvbiPpcArchh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PPC uses big endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
+
+/* exceptions generated by the hypervisor */
+
+#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
+#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
+#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
+#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
+#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
+#define VBI_EXC_OFF_PROG	0x0700	/* program check */
+#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
+#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
+#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
+#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
+#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
+#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+/* exception defines */
+
+#define ARCH_MAX_INTERRUPT		    36
+#define VBI_ARCH_EXC_TABLE_SIZE		    36
+#define VBI_ARCH_IRQ_TABLE_SIZE		    256
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#define _WRHV_ARCH_HAS_STATUS_REGS	    1
+#define _WRHV_ARCH_HAS_CTRL_REGS	    1
+
+#define VB_STATUS_REGS_OFFSET_BASE	 0
+#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
+#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
+#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
+#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
+#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
+#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
+#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
+#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
+#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
+#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
+#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
+#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
+#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
+#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
+#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
+#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
+#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
+#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
+#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
+#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
+#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
+#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
+#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
+#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
+#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
+#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
+#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
+#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
+#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
+#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
+#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
+#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
+
+
+#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
+
+
+#define VB_CONTROL_REGS_OFFSET_BASE	 0
+#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
+#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
+#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
+#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
+#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
+#define VB_CONTROL_SP			VB_CONTROL_R1
+#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
+#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
+#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
+#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
+#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
+#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
+#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
+#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
+#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
+#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
+#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
+#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
+#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
+#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
+#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
+#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
+#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
+#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
+#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
+#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
+#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
+#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
+
+/* status register size for ppc */
+
+#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
+
+#ifndef _ASMLANGUAGE
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+	base->vbStatusRegs.field		
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+	base->vbControlRegs.field		
+
+/*******************************************************************************
+*
+* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
+*
+* Virtual board emulated control registers. These registers are used
+* by a guest running on hypervisor to configure the virtual CPU register.
+*
+* SYNOPSIS
+*
+* PPC Control structure graphical illustration
+*\cs
+*        _______________   
+*       |       PC      |   
+*       |---------------|
+*       |       MSR     |	    
+*       |---------------|
+*       |       CR      |
+*       |---------------|
+*       |		|
+*       |general purpose|
+*       |     r[0:13]   | 
+*       |		|
+*       |---------------|
+*       |emulated MSR   |
+*       |---------------|
+*       |       dbsr    |
+*       |---------------|
+*       | dbcr[0:2]     |
+*       |---------------|
+*       |IAC[1:2]       |
+*       |---------------|
+*       |DAC[1:2]       |
+*       |---------------|
+*       |reserved[0:9]  |
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's control C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
+*
+*    uint32_t srr0;	/@  0: PC		    @/
+*    uint32_t srr1;	/@  1: MSR		    @/
+*    uint32_t cr;	/@  2: condition registers	    @/
+*    uint32_t r0;	/@  3: General register R0	    @/
+*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;	/@  5: General register R2	    @/
+*    uint32_t r3;	/@  6: General register R3	    @/
+*    uint32_t r4;	/@  7: General register R4	    @/
+*    uint32_t r5;	/@  8: General register R5	    @/
+*    uint32_t r6;	/@  9: General register R6	    @/
+*    uint32_t r7;	/@ 10: General register R7	    @/
+*    uint32_t r8;	/@ 11: General register R8	    @/
+*    uint32_t r9;	/@ 12: General register R9	    @/
+*    uint32_t r10;	/@ 13: General register R10	    @/
+*    uint32_t r11;	/@ 14: General register R11	    @/
+*    uint32_t r12;	/@ 15: General register R12	    @/
+*    uint32_t r13;	/@ 16: General register R13	    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbsr; /@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2		    @/
+*
+*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
+*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
+*
+*    /@ data address compare registers DAC1-DAC2.	        @/
+*
+*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
+*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
+*
+*    /@ reserved fields for future use			    @/
+*
+*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*\COMMAND
+*/
+
+typedef struct vbArchControlRegs
+    {
+
+    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+
+    uint32_t srr0;		/*  0: PC */
+    uint32_t srr1;		/*  1: MSR */
+    uint32_t cr;		/*  2: condition registers */
+    uint32_t r0;		/*  3: General register R0 */
+    uint32_t sp;		/*  4: General register R1 (stack pointer) */
+    uint32_t r2;		/*  5: General register R2 */
+    uint32_t r3;		/*  6: General register R3 */
+    uint32_t r4;		/*  7: General register R4 */
+    uint32_t r5;		/*  8: General register R5 */
+    uint32_t r6;		/*  9: General register R6 */
+    uint32_t r7;		/* 10: General register R7 */
+    uint32_t r8;		/* 11: General register R8 */
+    uint32_t r9;		/* 12: General register R9 */
+    uint32_t r10;		/* 13: General register R10 */
+    uint32_t r11;		/* 14: General register R11 */
+    uint32_t r12;		/* 15: General register R12 */
+    uint32_t r13;		/* 16: General register R13 */
+
+    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;		/* 17: emulated MSR register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbsr; /* 18 - debug status register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbcr0; /* 19 - debug control register 0 */
+    uint32_t     dbcr1; /* 20 - debug control register 1 */
+    uint32_t     dbcr2; /* 21 - debug control register 2 */
+
+    /* instruction address compare registers IAC1-IAC2 */
+
+    uint32_t     iac1; /* 22 - instructions access control 1 */
+    uint32_t     iac2; /* 23 - instructions access control 2 */
+
+    /* data address compare registers DAC1-DAC2. */
+
+    uint32_t     dac1; /* 24 - instructions access control 3 */
+    uint32_t     dac2; /* 25 - instructions access control 4 */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved[10];      /* 26: Reserved */ 
+    } VB_ARCH_CONTROL_REGS;
+
+/*******************************************************************************
+*
+* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
+*
+* Virtual board emulated CPU status registers
+*
+* SYNOPSIS
+*
+* PPC Status structure graphical illustration
+*\cs
+*        _______________   ---------------------------
+*       |    SRR0       |   
+*       |---------------|
+*       |    SRR1       |   Registers save by WRHV	
+*       |---------------|   before injecting an exception/interrupt
+*       |    CR		|
+*       |---------------|
+*       |    LR		|
+*       |---------------|
+*       |    r3		| 
+*       |---------------|
+*       |    r4         |
+*       |---------------|   ---------------------------
+*	|    mcsrr0	|	
+*       |---------------|  Registers saved duing exception handling
+*       |    mcssr1     |
+*       |---------------|
+*       |    esr        |
+*       |---------------|
+*       |    mcsr       |
+*       |---------------|
+*       |    mcar       |
+*       |---------------|
+*       |    dear       |
+*       |---------------|
+*       |    emsr       |
+*       |---------------|
+*       |    esrr0      |
+*       |---------------|
+*       |    esrr1      |
+*       |---------------|    -------------------------
+*       | reserved[8]   |      8 x 32bits for future enhencements
+*       |---------------|    -------------------------
+*       |    svr        |
+*       |---------------|
+*       |    pir        |
+*       |---------------|
+*       |    pvr        |    Configuration registers updated
+*       |---------------|    upon board creation    
+*       |    hid0       |  
+*       |---------------|
+*       |    hid1       |
+*       |---------------|
+*       |    buscr      |
+*       |---------------|       
+*       |    l1csr0     |
+*       |---------------|
+*       |    l1csr1     |
+*       |---------------|   --------------------------
+*       | reserved[0:8] | 9x 32bit
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_ARCH_STATUS_REGS structure definition
+*
+* typedef struct archStatusRegs
+*    {
+*
+*    /@ 
+*     @ registers saved by WRHV for all interrupts exceptions
+*     @ before setting the PC in the virtual board to the exception/interrupt
+*     @ vector address
+*     @/
+*
+*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
+*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
+*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
+*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
+*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
+*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
+*
+*    /@ Registers saved by WRHV during exception processing only    @/
+*
+*    uint32_t mcsrr0; /@  6:			    @/
+*    uint32_t mcsrr1; /@  7:			    @/
+*    uint32_t esr;    /@  8:			    @/
+*    uint32_t mcsr;   /@  9:			    @/
+*    uint32_t mcar;   /@ 10			@/
+*    uint32_t dear;   /@ 11:			    @/
+*    uint32_t emsr;   /@ 12:			    @/
+*    uint32_t esrr0;  /@ 13:			    @/
+*    uint32_t esrr1;  /@ 14:			    @/
+*
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved1[8]; /@ 15 - 22			@/
+*
+*    /@ Configuration registers (only updated upon board creation   @/
+*
+*    uint32_t svr;     /@ 23			    @/     
+*    uint32_t pir;     /@ 24			    @/
+*    uint32_t pvr;     /@ 25			    @/  
+*    uint32_t hid0;    /@ 26			    @/
+*    uint32_t hid1;    /@ 27			    @/
+*    uint32_t bucsr;   /@ 28			    @/
+*    uint32_t l1csr0;  /@ 29			    @/
+*    uint32_t l1csr1;  /@ 30			    @/
+*    
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved2[9]; /@ 31 - 39			@/
+*
+*    } VB_ARCH_STATUS_REGS; 
+*
+*
+*\ce
+*
+* SEE ALSO: VB_STATUS 
+*\COMMAND
+*/
+
+typedef struct archStatusRegs
+    {
+
+    /* 
+     * registers saved by Razor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+
+    uint32_t srr0; /* 0: PC at time of the interrupt */
+    uint32_t srr1; /* 1: MSR at time of the interrupt */
+    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 3: Link register at time of the interrupt */
+    uint32_t r3;   /* 4: R3 at time of the interrupt */
+    uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+    /* Registers saved by Razor during exception processing only */
+
+    uint32_t mcsrr0; /*  6: */
+    uint32_t mcsrr1; /*  7: */
+    uint32_t esr;    /*  8: */
+    uint32_t mcsr;   /*  9: */
+    uint32_t mcar;   /* 10  */
+    uint32_t dear;   /* 11: */
+    uint32_t emsr;   /* 12: */
+    uint32_t esrr0;  /* 13: */
+    uint32_t esrr1;  /* 14: */
+
+/* 
+ * keep this part in a separate structure in order to keep the offsets
+ * to remain the same as in VB_STATUS
+ */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved1[8]; /* 15 - 22  */
+
+    /* Configuration registers (only updated upon board creation */
+
+    uint32_t svr;     /* 23 */     
+    uint32_t pir;     /* 24 */
+    uint32_t pvr;     /* 25 */  
+    uint32_t hid0;    /* 26 */
+    uint32_t hid1;    /* 27 */
+    uint32_t bucsr;   /* 28 */
+    uint32_t l1csr0;  /* 29 */
+    uint32_t l1csr1;  /* 30 */
+    
+    /* reserved fields for future use */
+
+    uint32_t reserved2[9]; /* 31 - 39 */
+
+    } VB_ARCH_STATUS_REGS; 
+
+#else /*_ASMLANGUAGE */
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+#define VBI_CTX_LOAD(reg)				    \
+	lis	reg, HI(VBI_SYS_ctx_load);		    \
+	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
+	sc
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
+	li	reg1, -1;				\
+        lis     reg2, HIADJ(wrhvVbControl);		\
+        lwz     reg2, LO(wrhvVbControl)(reg2);		\
+        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
+        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+checkIntVcorePending:						\
+	lis	reg0, HIADJ(wrhvVbStatus);			\
+	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
+	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
+								\
+	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
+	beq     endIntVcoreLock;				\
+	lis	r0, HI(VBI_SYS_int_enable);			\
+	ori	r0, r0, LO(VBI_SYS_int_enable);			\
+	sc;							\
+	b	checkIntVcorePending;				\
+endIntVcoreLock:
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+#define VBI_INT_VCORE_STATE_GET(reg0)				\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+
+#endif /*_ASMLANGUAGE */
+    
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __INCvbiPpcArchh */
diff --git a/arch/powerpc/kernel/vbiSyscalls.S b/arch/powerpc/kernel/vbiSyscalls.S
new file mode 100644
index 0000000..e984b47
--- /dev/null
+++ b/arch/powerpc/kernel/vbiSyscalls.S
@@ -0,0 +1,1626 @@
+/* vbiSyscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02g,06jul09,mmi  update vb mangement syscall numbers, memory read/write,
+		 registers read/write, interrupt direct op, debug shell start
+02f,26jun09,mmi  add vbiIoapicOp
+02e,23jun09,mmi  add vbi 2.0 apis
+02d,11jun09,mmi  update interrupts apis according to vbi2.0
+02c,10jun09,mmi  remove VxWorks consideration
+02b,28feb09,mmi  add vbiNsOp
+02a,09feb09,mmi  add vbMgmt API
+01z,27jan09,mmi  include vbi.h header file
+01y,23jan09,mmi  update vbiSyscall prototype in comments
+01x,18jan09,mmi  fix vbiIoapicIoctl, remove vbiShelf
+01w,12dec08,md   rename header files
+01v,11dec08,mmi  change name of VB structure pointers
+01u,02dec08,mmi  remove obsolete API's
+01t,19nov08,mmi  adopt new naming convention for vbi API's
+01s,04sep08,dcc  added vdkIoapicIoctl
+01r,20jun08,md   fix header file inclusion
+01q,19jun08,md   change VxWorks define
+01p,28nov07,foo  vdk doc
+01o,21nov07,md   include VxWorks header files if being compiled in a project
+01o,21nov07,foo  vdk interrupts
+01n,25oct07,foo  added vdkIntControllerDone, vdkIntEnable, vdkShelf	
+01m,05oct07,md   remove vxworks header files
+01l,10sep07,md   re-number hypervisor system calls
+01k,05jul07,foo  added vdkBspIoctl	
+01j,04jun07,md   added vdkHyCtxctl, vdkMmuPageProtect and vdkMmuPageUnprotect
+01i,24may07,ymz  added port system calls.
+01h,18may07,md   added vdkHyIoctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed syscalls to start with vdk
+01e,10apr07,md   split kprintf into kputs and kputc
+01d,02apr07,md   header file re-org
+01c,19mar07,foo	 fix macro names
+01b,15mar07,md   added hyInt, hyIntDone
+01a,11mar07,md   written
+*/
+
+/*
+DESCRIPTION
+
+This file implements the hypervisor system call stubs for the hypervisor.
+
+*/
+
+#define _ASMLANGUAGE
+#ifdef __KERNEL__
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/asm-offsets.h>
+#include <asm/cache.h>
+#include <vbi/sys/vbiSyscall.h>
+
+#define FUNC_LABEL(func)       _GLOBAL(func)
+#define	FUNC_EXPORT(func)
+#define	FUNC_END(func)
+#define	_WRS_TEXT_SEG_START
+#define	HI(sym) sym@h
+#define	HIADJ(sym)      sym@ha
+#define	LO(sym) sym@l
+#else  /* __KERNEL__ */
+#include <wrhv.h>
+#include <sys/arch.h>
+#include <sys/regs.h>
+#include <sys/vbiSyscall.h>
+#endif
+
+#define p0	r3      /* argument register, volatile */
+#define p1	r4      /* argument register, volatile */
+#define p2	r5      /* argument register, volatile */
+#define p3	r6      /* argument register, volatile */
+#define p4	r7      /* argument register, volatile */
+#define p5	r8      /* argument register, volatile */
+#define p6	r9      /* argument register, volatile */
+#define p7	r10     /* argument register, volatile */
+#define	wrhvVbStatus	wrhvStatus
+#define wrhvVbControl	wrhvControl
+
+	/* globals */
+
+	FUNC_EXPORT(vbiVcoreIntRed_op)
+	FUNC_EXPORT(vbiDebugShellStart)
+	FUNC_EXPORT(vbiVbMemoryRead)
+	FUNC_EXPORT(vbiVbMemoryWrite)
+	FUNC_EXPORT(vbiVbRegisterRead)
+	FUNC_EXPORT(vbiVbRegisterWrite)
+	FUNC_EXPORT(vbiIoapicOp)
+	FUNC_EXPORT(vbiIoapicIoctl)
+	FUNC_EXPORT(vbiHyIoctl)
+	FUNC_EXPORT(vbiCtxctl)
+	FUNC_EXPORT(vbiBspIoctl)
+	FUNC_EXPORT(vbiSend)
+	FUNC_EXPORT(vbiReceive)
+	FUNC_EXPORT(vbiReply)
+	FUNC_EXPORT(vbiIcacheFlush)
+	FUNC_EXPORT(vbiDcacheFlush)
+	FUNC_EXPORT(vbiCacheTextUpdate)
+	FUNC_EXPORT(vbiTlbFlush)
+	FUNC_EXPORT(vbiPanic)
+	FUNC_EXPORT(vbiPs)
+	FUNC_EXPORT(vbiKputs)
+	FUNC_EXPORT(vbiKputc)
+	FUNC_EXPORT(vbiIntVCoreUnlock)
+	FUNC_EXPORT(vbiIntVCoreLock)
+	FUNC_EXPORT(vbiExcBaseSet)
+	FUNC_EXPORT(vbiMemAttrSet)
+	FUNC_EXPORT(vbiMemAttrGet)
+	FUNC_EXPORT(vbiVmmuConfig)
+	FUNC_EXPORT(vbiVmmuEnable)
+	FUNC_EXPORT(vbiVmmuDisable)
+	FUNC_EXPORT(vbiVmmuTlbLoad)
+	FUNC_EXPORT(vbiVmmuTlbFlush)
+	FUNC_EXPORT(vbiVbMgmt)
+	FUNC_EXPORT(vbiNsOp)
+	FUNC_EXPORT(vbiVbSuspend)
+	FUNC_EXPORT(vbiVbReset)
+	FUNC_EXPORT(vbiVbRestart)
+	FUNC_EXPORT(vbiVbResume)
+
+	_WRS_TEXT_SEG_START
+
+/******************************************************************************
+*
+* sys_vbMgmt - virtual board management
+* 
+* This routine executes the specified command on a given virtual board. The
+* possible commands are:
+* 
+* VBI_VBMGMT_ATTACH 
+* Attach the requesting Virtual Board to the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_DETACH
+* Detatch the requesting Virtual Board from the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_SUSPEND
+* Suspends target Virtual Board from operation.  Fails if Virtual Board
+* has already been suspended
+*
+* VBI_VBMGMT_RESET
+* Resume a target virtual board.  Fails if a Virtual Board has not been
+* suspended. Currently no options are supported
+*
+* VBI_VBMGMT_RESUME
+* Restarts a target Virtual Board which has Preload=0 set in the xml file.
+* Fails if Virtual Board is preloaded (Preload=1)
+*
+* The fourth argument to this routine specifies an flag that must be defined
+* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+* The possible flgas are:
+*   VBI_VTLB_OP_UPDATE_PMD	
+*   VBI_VTLB_OP_UPDATE_PTE	
+*   VBI_VTLB_OP_DELETE_PMD	
+*   VBI_VTLB_OP_SET_PTE_AT	
+*   VBI_VTLB_OP_SET_PTE	
+*   VBI_VTLB_OP_FLUSH_OPS	
+*   VBI_VTLB_OP_INIT	
+* 
+* RETURNS: OK or error in case of failure
+* 
+*
+* int32_t sys_vbMgmt 
+*    (
+*    uint32_t cmd,	/@ attach, detach, suspend, reset or resume @/
+*    uint32_t boardId,	/@ the operation target board id @/
+*    int32_t *outError, /@ where to set error : OK or error flag @/ 
+*    uint32_t flags	/@ options required by the cmd executed @/
+*    )
+*/
+
+FUNC_LABEL(vbiVbMgmt)
+        lis     r0, HI(VBI_SYS_vbMgmt)
+        ori     r0, r0, LO(VBI_SYS_vbMgmt)
+        sc
+        blr
+FUNC_END(vbiVbMgmt)
+
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service.
+*
+* SYNOPSIS
+*\cs
+*
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbSuspend)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+	
+        lis     r0, HI(VBI_SYS_vbSuspend)
+        ori     r0, r0, LO(VBI_SYS_vbSuspend)
+        sc
+        blr
+FUNC_END(vbiVbSuspend)
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target
+* core(s) program counter to it's ENTRY function. The ENTRY function is 
+* determined based on the loaded binary image. A core does not execute beyond
+* it's ENTRY function unless vbiVbRestart() is explitly called. 
+* Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
+* option is set in the flag passed as the third argument to this routine.
+* The hypercall sends a message to a manager that provides VB managment 
+* services. 
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset
+* is not determined. The second argument identifies the cores to perform the
+* operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual
+* Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options
+* may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest
+* OS's responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
+*    vbiCore_t     core,            /@ Core within the VB           @/
+*    uint32_t     options   /@ reload , start options       @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbReset)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 * r5 - options
+	 */
+
+        lis     r0, HI(VBI_SYS_vbReset)
+        ori     r0, r0, LO(VBI_SYS_vbReset)
+        sc
+        blr
+FUNC_END(vbiVbReset)
+
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to
+* restart.
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+FUNC_LABEL(vbiVbRestart)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbRestart)
+        ori     r0, r0, LO(VBI_SYS_vbRestart)
+        sc
+        blr
+FUNC_END(vbiVbRestart)
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*/
+
+FUNC_LABEL(vbiVbResume)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbResume)
+        ori     r0, r0, LO(VBI_SYS_vbResume)
+        sc
+        blr
+FUNC_END(vbiVbResume)
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiSend)
+
+	/*
+	 * r3 - ctx id
+	 * r4 - smsg pointer 
+	 * r5 - size of smsg 
+	 * r6 - rmsg pointer
+	 * r7 - rmsg length
+	 * r8 - info pointer
+	 * r9 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_send)
+	ori	r0, r0, LO(VBI_SYS_send)
+	sc
+	blr
+FUNC_END(vbiSend)
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReceive)
+
+	/*
+	 * r3 - smsg pointer 
+	 * r4 - size of smsg 
+	 * r5 - info pointer
+	 * r6 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_receive)
+	ori	r0, r0, LO(VBI_SYS_receive)
+	sc
+	blr
+FUNC_END(vbiReceive)
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t	    id,    /@ context id to reply the message to    @/
+*    void *	    buff,  /@ pointer to reply message		    @/
+*    size_t	    len,   /@ length of message to reply	    @/
+*    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReply)
+	lis	r0, HI(VBI_SYS_reply)
+	ori	r0, r0, LO(VBI_SYS_reply)
+	sc
+	blr
+FUNC_END(vbiReply)
+
+/*******************************************************************************
+*
+* vbiKputs - print a string on the hypervisor kernel console
+*
+* This routine makes a hypercall and prints a string of characters to to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputc() 
+*/
+
+FUNC_LABEL(vbiKputs)
+	lis	r0, HI(VBI_SYS_kputs)
+	ori	r0, r0, LO(VBI_SYS_kputs)
+	sc
+	blr
+FUNC_END(vbiKputs)
+
+/*******************************************************************************
+*
+* vbiKputc - print a character on the hypervisor kernel console
+*
+* This routine makes a hypercall in order to print the specified character to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputc (int c) /@ character to print @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputs()
+*/
+
+FUNC_LABEL(vbiKputc)
+	lis	r0, HI(VBI_SYS_kputc)
+	ori	r0, r0, LO(VBI_SYS_kputc)
+	sc
+	blr
+FUNC_END(vbiKputc)
+
+/*******************************************************************************
+*
+* vbiPanic - halt the system and dump debug info 
+*
+* This routine makes a hypercall in order to halt the system and display debug
+* information on hypervisor console. If hypervisor is configured with
+* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
+* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
+* the offending cores registers dump is displayed on hypervisor console. If
+* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
+* the debug manager.
+*
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiPanic (const char *msg) /@ pointer to message to print @/
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+FUNC_LABEL(vbiPanic)
+	lis	r0, HI(VBI_SYS_panic)
+	ori	r0, r0, LO(VBI_SYS_panic)
+	sc
+	blr
+FUNC_END(vbiPanic)
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine 
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running. 
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart 
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          ) 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiDebugShellStart)
+
+	/* r3 - flags for attachement behaviour */
+
+	lis	r0, HI(VBI_SYS_dbgShStart)
+	ori	r0, r0, LO(VBI_SYS_dbgShStart)
+	sc
+	blr
+FUNC_END(vbiDebugShellStart)
+
+/*******************************************************************************
+*
+* vbiIcacheFlush - flush the instruction cache
+*
+* This routine makes a hypercall to flush the instruction cache of the calling
+* core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiIcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the instruction cache to flush @/
+*	    size_t len  /@ length of memory to flush @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush()
+*/
+
+FUNC_LABEL(vbiIcacheFlush)
+	lis	r0, HI(VBI_SYS_icache_flush)
+	ori	r0, r0, LO(VBI_SYS_icache_flush)
+	sc
+	blr
+FUNC_END(vbiIcacheFlush)
+
+/*******************************************************************************
+*
+* vbiDcacheFlush - flush the specified Data cache
+*
+* This routine makes a hypercall to flush the data cache of the calling core
+* for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiDcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the data cache to flush @/
+*	    size_t len  /@ length of memory to flush                   @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiDcacheFlush)
+	lis	r0, HI(VBI_SYS_dcache_flush)
+	ori	r0, r0, LO(VBI_SYS_dcache_flush)
+	sc
+	blr
+FUNC_END(vbiDcacheFlush)
+
+
+/******************************************************************************
+*
+* vbiTlbFlush - flush an MMU TLB entry
+*
+* This system call flushes the TLB associated with the specified context id 
+*
+* C interface:
+*
+*   vbiTlbFlush (unsigned int id) /@ the entry to flush @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiTlbFlush)
+	lis	r0, HI(VBI_SYS_tlb_flush)
+	ori	r0, r0, LO(VBI_SYS_tlb_flush)
+	sc
+	blr
+FUNC_END(vbiTlbFlush)
+
+/*******************************************************************************
+*
+* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+*
+* This routine enables interrupts and makes a fast hypercall if pending
+* interrupts are detected for the calling core. This is a C wrapper function for
+* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void vbiIntVCoreUnlock (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreUnlock)
+	
+	lis	p0, HIADJ(wrhvVbControl)
+	lwz	p0, LO(wrhvVbControl)(p0)
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+	
+tryAgain:		
+	lis	p0, HIADJ(wrhvVbStatus)
+	lwz	p0, LO(wrhvVbStatus)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+	
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis	r0, HI(VBI_SYS_int_enable)
+	ori	r0, r0, LO(VBI_SYS_int_enable)
+	sc
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbiIntVCoreUnlock)
+
+ /*******************************************************************************   
+ *
+ * vbiIntVCoreLock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper 
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ * SYNOPSIS
+ *\cs
+ * 
+ * VBI PPC Architecture Supplements
+ *
+ * vbiIntState_t vbiIntVCoreLock (void)
+ *
+ *\ce
+ *
+ * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
+ *
+ * ERROR CODES: N/A
+ *
+ * SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+ *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+ */
+
+FUNC_LABEL(vbiIntVCoreLock)
+	li	p1, -1
+	lis	p2, HIADJ(wrhvVbControl)
+	lwz	p2, LO(wrhvVbControl)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+	blr
+FUNC_END(vbiIntVCoreLock)
+
+/*******************************************************************************
+*
+* vbiIntVCoreStateGet - Get interrupts state for running core
+*
+* This routine returns the interrupts state for the calling core. This is C 
+* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+* returns TRUE if interrupts are locked otherwise FALSE.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntStatus_t vbiIntVCoreStateGet (void)
+*
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreStateGet)
+    lis	p2, HIADJ(wrhvVbControl)
+    lwz	p2, LO(wrhvVbControl)(p2)
+    lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+    blr
+FUNC_END(vbiIntVCoreStateGet)
+
+/*******************************************************************************
+*
+* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+*
+* This routine changes the exceptions vector table base address for the active
+* virtual core. By default the base address of the exception table is at address
+* 0x0.
+* If the guest OS programmer wishes to move this address then this function must
+* be called to inform hypervisor. This function must be called with interrupts
+* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcBaseSet 
+*	    (
+*	    void * excTblBase /@ New exception table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+FUNC_LABEL(vbiExcBaseSet)
+
+	/* 
+	 * r3 has the base address to set; make sure it is aligned  
+	 * align to 32 bytes  
+	 */	    
+
+	clrrwi  r3,r3, 5
+	
+	/* set command for the ioctl */
+
+	li	r4, VBI_HYIOCTL_EXCBASE
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
+	blr
+FUNC_END(vbiExcBaseSet)
+	
+/*******************************************************************************
+*
+* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+*
+* This routine makes a hypercall to flush the data cache then invalidates the
+* instruction cache of the calling core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiCacheTextUpdate 
+*	    (
+*	    void * addr /@ starting address to perform textUpdate operation @/
+*	    size_t len  /@ length of memory in bytes			    @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiCacheTextUpdate)
+	lis	r0, HI(VBI_SYS_cache_text_update)
+	ori	r0, r0, LO(VBI_SYS_cache_text_update)
+	sc
+	blr
+FUNC_END(vbiCacheTextUpdate)
+
+/******************************************************************************
+*
+* vbiVmmuConfig - configure the hypervisor virtual MMU
+*
+* This system call configures the context's virtual MMU within the hypervisor.
+*
+* C interface:
+*
+*   vbiVmmuConfig (VMMU_CONFIG *config) /@ The vmmu configuration @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuConfig)
+	lis	r0, HI(VBI_SYS_vmmu_config)
+	ori	r0, r0, LO(VBI_SYS_vmmu_config)
+	sc
+	blr
+FUNC_END(vbiVmmuConfig)
+
+
+/******************************************************************************
+*
+* vbiVmmuEnable - enables the virtual MMU
+*
+* This system call enables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuEnable (unsigned int vmmu_num) /@ Enable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuEnable)
+	lis	r0, HI(VBI_SYS_vmmu_enable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
+	sc
+	blr
+FUNC_END(vbiVmmuEnable)
+
+
+/******************************************************************************
+*
+* vbiVmmuDisable - disable the virtual MMU
+*
+* This system call disables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuDisable (unsigned int vmmu_num) /@ Disable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuDisable)
+	lis	r0, HI(VBI_SYS_vmmu_disable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
+	sc
+	blr
+FUNC_END(vbiVmmuDisable)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
+*
+* This system call loads the TLB entries for the specified address range into
+* the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbLoad (VMMU_CONFIG *config, /@ The VMMU being used @/
+*                   void *addr,		 /@ Starting address    @/
+*                   unsigned int len)    /@ length              @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbLoad)
+	lis	r0, HI(VBI_SYS_vmmu_tlbload)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
+	sc
+	blr
+FUNC_END(vbiVmmuTlbLoad)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
+*
+* This system call flushes the TLB entries for the specified address range
+* from the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbFlush (VMMU_CONFIG *config, /@ The VMMU configuration to use @/
+*		     void *addr,          /@ Starting address              @/
+*		     unsigned int len)    /@ length                        @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbFlush)
+	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
+	sc
+	blr
+FUNC_END(vbiVmmuTlbFlush)
+
+
+/******************************************************************************
+*
+* vbiHyIoctl - hypervisor ioctl call
+*
+* This system call interfaces to the general purpose hypervisor ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_HYIOCTL_GETPID
+*     VBI_HYIOCTL_GETPRIORITY
+*     VBI_HYIOCTL_PSDISPLAY
+*     VBI_HYIOCTL_GETSTATS
+*     VBI_HYIOCTL_EXCBASE
+*		
+* C interface:
+*
+*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*               void *arg)          /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiHyIoctl)
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
+	blr
+FUNC_END(vbiHyIoctl)
+
+/******************************************************************************
+*
+* vbiCtxctl - hypervisor context control call
+*
+* This system call interfaces to the general purpose hypervisor context
+* control function.
+*
+* Possbile operations:
+*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+*
+* C interface:
+*
+*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
+*		 void *arg)		 /@ address of argument @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiCtxctl)
+	lis	r0, HI(VBI_SYS_ctxctl)
+	ori	r0, r0, LO(VBI_SYS_ctxctl)
+	sc
+	blr
+FUNC_END(vbiCtxctl)
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrSet)
+	lis	r0, HI(VBI_SYS_mmu_attr_set)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
+	sc
+	blr
+FUNC_END(vbiMemAttrSet)
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrGet)
+	lis	r0, HI(VBI_SYS_mmu_attr_get)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
+	sc
+	blr
+FUNC_END(vbiMemAttrGet)
+
+
+/******************************************************************************
+*
+* vbiBspIoctl - bsp ioctl call
+*
+* This system call interfaces to the Board Support Package
+* I/O drivers etc
+*
+* Knwon BSP ioctl commands:
+*	VBI_BSPIOCTL_ENABLE_INT   /@ Enable HW interrupt @/
+*	VBI_BSPIOCTL_DISABLE_INT  /@ Disable HW interrupt@/
+*	VBI_BSPIOCTL_RESET	  /@ Reset HW device     @/
+*				
+* C interface:
+*
+*   vbiBspIoctl (unsigned int ioctl, /@ the BSP ioctl command  @/
+*                unsigned int arg1   /@ arguments to the ioctl @/
+*                unsigned int arg2
+*                unsigned int arg3
+*                unsigned int arg4
+*                unsigned int arg5
+*                unsigned int arg6
+*                unsigned int arg7)
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiBspIoctl)
+	lis	r0, HI(VBI_SYS_bspIoctl)
+	ori	r0, r0, LO(VBI_SYS_bspIoctl)
+	sc
+	blr
+FUNC_END(vbiBspIoctl)
+
+/******************************************************************************
+*
+* vbiIoapicIoctl - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function. For PPC this is a nop routine for now.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*                   unsigned arg1,      /@ address of information @/
+*                   unsigned arg2)      /@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicIoctl)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
+	blr
+FUNC_END(vbiIoapicIoctl)
+
+/******************************************************************************
+*
+* vbiNsOp - virtua board name service call
+*
+* This system call interfaces to the virtual board
+*
+* commands:
+*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+*				
+* C interface:
+*
+*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
+*	    char * name,		    /@ the service name		@/
+*	    uint32_t revision,	    /@ service revision		@/
+*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
+*	  )
+*
+* Returns: OK or ERROR in case of failure
+*
+*/
+
+FUNC_LABEL(vbiNsOp)
+	lis   r0, HI(VBI_SYS_ns_op)
+	ori	r0, r0, LO(VBI_SYS_ns_op)
+	sc
+	blr
+FUNC_END(vbiNsOp)
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryRead)
+	lis   r0, HI(VBI_SYS_memRead_op)
+	ori	r0, r0, LO(VBI_SYS_memRead_op)
+	sc
+	blr
+FUNC_END(vbiVbMemoryRead)
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryWrite)
+	lis	r0, HI(VBI_SYS_memWrite_op)
+	ori	r0, r0, LO(VBI_SYS_memWrite_op)
+	sc
+	blr
+FUNC_END(vbiVbMemoryWrite)
+
+/******************************************************************************
+*
+* vbiIoapicOp - virtual IO APIC operation
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicOp (unsigned int ioctl,	/@ the ioctl command      @/
+*                vbiIrq_t irq,		/@ address of information @/
+*                uint32_t filter),      /@ address of information @/
+*                vbiVb_t vbId)		/@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicOp)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
+	blr
+FUNC_END(vbiIoapicOp)
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* SYNOPSIS
+*\cs
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterRead)
+	lis   r0, HI(VBI_SYS_RegsRead_op)
+	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
+	sc
+	blr
+FUNC_END(vbiVbRegisterRead)
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+*\cs
+*typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*\ce 
+* VBI PPC Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterWrite)
+	lis   r0, HI(VBI_SYS_RegsWrite_op)
+	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
+	sc
+	blr
+FUNC_END(vbiVbRegisterWrite)
+
+
+/*******************************************************************************
+*
+* vbiVcoreIntRed_op - redirect an irq to another vcore
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVcoreIntRed_op 
+*	(
+*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
+*	vbiCore_t		core	/@ destination vcore		 @/
+*	)
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: vbiVioapicIntRedirect()
+* 
+*\NOMANUAL
+*/
+
+FUNC_LABEL(vbiVcoreIntRed_op)
+	lis   r0, HI(VBI_SYS_intRedirect)
+	ori	r0, r0, LO(VBI_SYS_intRedirect)
+	sc
+	blr
+FUNC_END(vbiVcoreIntRed_op)
diff --git a/arch/powerpc/kernel/vbiUtil.c b/arch/powerpc/kernel/vbiUtil.c
new file mode 100644
index 0000000..1e9acda
--- /dev/null
+++ b/arch/powerpc/kernel/vbiUtil.c
@@ -0,0 +1,144 @@
+/* vbi/vbiUtil.c - utilities routines for guest OS para-virtualization */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01a,17jul07, ymz written
+02a,08nov07, mb  moved wrhv_int_lock and friends from init/main.c; formatting fixes
+*/
+
+/*
+This module implements a library which is handy for para-virtualized
+guest os to use. The routines are developed based on the need while
+para-virtualize linux, therefore, may need some tweaks to be generic.
+*/
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <vbi/vbInterface.h>
+#include <vbi/sys/vmmu.h>
+#include <vbi/sys/vbiSyscall.h>
+
+
+/* defines */
+
+/* globals */
+
+/*
+ * wrhvConfig is initialized as part of the guest os init, before os turns on
+ * MMU. For paravirualized linux, it is initialized in plaform_init().
+ */
+
+extern VB_CONFIG *wrhvConfig;
+extern VB_STATUS *wrhvStatus;
+extern VB_CONTROL *wrhvControl;
+
+/* local */
+
+/* extern */
+extern void pteAttrSet(VMMU_PTE * pte, u_int attr);
+extern void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon);
+
+/* forward declarations */
+
+unsigned int vb_memsize_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig) {
+		/* vb_memsize_get should not be called before wrhvConfig is init,
+		 * REALLY
+		 */
+		return 0;
+	}
+
+	return (((VB_CONFIG *) wrhvConfig)->physicalMemorySize);
+}
+
+unsigned int vb_context_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig)
+		return 0xdeadbee0;
+	return (((VB_CONFIG *) wrhvConfig)->pid);
+}
+
+void vb_pte_set(void *pPte, unsigned long paddr, int protval)
+{
+
+	/* caller has guaranteed pPte != NULL */
+
+	*(uint *) pPte = (uint) VMMU_PTE_VALID_MASK;
+
+	/* linux uses more than the permission bits, in word1 of PTE */
+
+	*((uint *) ((uint *) pPte) + 1) = (((u_int) paddr & VMMU_PTE_RPN_MASK) | (protval & 0xfff));
+
+	return;
+}
+
+/*
+ * turn on mmu for the particular context
+ *
+ * note, caller must make sure, context switch inside the guest OS must
+ * not happen during this call.
+ */
+
+int vb_context_mmu_on(int pid,	/* context id */
+		      void *pgtable,	/* level 1 page table */
+		      int pagesize, int debug)
+{
+	static VMMU_CONFIG vmmu_cfg;
+
+	if ((VB_CONFIG *) - 1 == wrhvConfig || NULL == pgtable || pagesize <= 0)
+		return -1;
+
+	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
+	vmmu_cfg.pageSize = pagesize;
+	vmmu_cfg.contextId = pid;
+	vmmu_cfg.vmmuNum = 0;	/* only vmmu 0 is support for the time being */
+
+	if ((vbiVmmuConfig(&vmmu_cfg)) != 0)
+		return -1;
+
+	if (debug) {
+		printk("L1 page table address %#X\n", pgtable);
+		vmmuPageTableDisplay(pgtable, 0);
+		printk("End of page table display \n");
+	}
+
+	vbiVmmuEnable(vmmu_cfg.vmmuNum);
+
+	return 0;
+}
+
+void vb__flush_dcache_icache(void *start)
+{
+	vbiIcacheFlush(start, 4096);
+	vbiDcacheFlush(start, 4096);
+}
+
+void vb_flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	vbiDcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_icache_range(unsigned long start, unsigned long stop)
+{
+	vbiIcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_dcache_icache_phys(unsigned long physaddr)
+{
+	vbiIcacheFlush((void *) physaddr, 4096);
+	vbiDcacheFlush((void *) physaddr, 4096);
+}
+
+EXPORT_SYMBOL_GPL(wrhv_int_lock);
+EXPORT_SYMBOL_GPL(wrhv_int_unlock);
+EXPORT_SYMBOL_GPL(wrhv_int_lvl_get);
diff --git a/include/vbi/ppc/vbiPpcArch.h b/include/vbi/ppc/vbiPpcArch.h
new file mode 100644
index 0000000..f0f0ef2
--- /dev/null
+++ b/include/vbi/ppc/vbiPpcArch.h
@@ -0,0 +1,934 @@
+/* vbiPpcArch.h - PowerPC architecture specific definitions */
+
+/* Copyright 2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01u,08sep09,dtr  Add definitions for new API vbiExcOffsetsGet/Set.
+01t,28aug09,mmi  add MSG_HEADER definitions
+01s,26aug09,mmi  fix defect WIND00178026 and WIND00178028: remove extra ";"
+		 from VBI_STATUS_ADDR_GET (), VBI_CNTRL_ADDR_GET(), 
+		 VBI_CONFIG_ADDR_GET(). 
+01r,27jul09,mpk  add hardware register set to vbi
+01q,18jul09,mmi  add bsp server message layout
+01p,16jul09,mmi  initialize to zero the register loaded in intdisable field
+01o,15jul09,mmi  fix VBI_INT_VCORE_LOCK() error
+01n,14jul09,mmi  add macro to find base addresses for status, control and
+                 config
+01m,07jul09,mmi  fix comment of int locking macro
+01l,22jun09,mmi  add assembly macros to read regs.
+01k,11jun09,mmi  add interrupts macros
+01j,10jun09,mmi  add assembly macro's for context switch and interrupts
+01i,08jun09,md   add define for maximum number of cores
+01h,08jun09,mmi  update descriptions
+01g,25may09,md   add byte order define
+01f,09feb09,mmi  add defines for vbi exception management
+01e,29jan09,dtr  debug.
+01d,29jan09,dtr  Remove some old defs.
+01c,28jan09,dtr  Use new structures.
+01b,23jan09,mmi  add debug registers
+01a,21jan09,mmi  created
+*/
+
+#ifndef __INCvbiPpcArchh
+#define __INCvbiPpcArchh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PPC uses big endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
+
+/* exceptions generated by the hypervisor */
+
+#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
+#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
+#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
+#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
+#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
+#define VBI_EXC_OFF_PROG	0x0700	/* program check */
+#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
+#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
+#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
+#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
+#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
+#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+/* exception defines */
+
+#define ARCH_MAX_INTERRUPT		    36
+#define VBI_ARCH_EXC_TABLE_SIZE		    36
+#define VBI_ARCH_IRQ_TABLE_SIZE		    256
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#define _WRHV_ARCH_HAS_STATUS_REGS	    1
+#define _WRHV_ARCH_HAS_CTRL_REGS	    1
+
+#define VB_STATUS_REGS_OFFSET_BASE	 0
+#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
+#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
+#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
+#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
+#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
+#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
+#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
+#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
+#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
+#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
+#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
+#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
+#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
+#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
+#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
+#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
+#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
+#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
+#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
+#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
+#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
+#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
+#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
+#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
+#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
+#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
+#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
+#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
+#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
+#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
+#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
+#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
+
+
+#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
+
+
+#define VB_CONTROL_REGS_OFFSET_BASE	 0
+#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
+#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
+#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
+#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
+#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
+#define VB_CONTROL_SP			VB_CONTROL_R1
+#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
+#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
+#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
+#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
+#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
+#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
+#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
+#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
+#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
+#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
+#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
+#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
+#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
+#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
+#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
+#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
+#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
+#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
+#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
+#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
+#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
+#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
+
+/* status register size for ppc */
+
+#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
+
+/* mdio messages */
+#define MDIO_READ	    1
+#define MDIO_WRITE	    2
+#define MDIO_INT_ENABLE	    3
+#define MDIO_INT_DISABLE    4
+#define BSP_CLK_FREQ	    5
+
+#ifndef _ASMLANGUAGE
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+	base->vbStatusRegs.field		
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+	base->vbControlRegs.field		
+
+/*******************************************************************************
+*
+* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
+*
+* Virtual board emulated control registers. These registers are used
+* by a guest running on hypervisor to configure the virtual CPU register.
+*
+* SYNOPSIS
+*
+* PPC Control structure graphical illustration
+*\cs
+*        _______________   
+*       |       PC      |   
+*       |---------------|
+*       |       MSR     |	    
+*       |---------------|
+*       |       CR      |
+*       |---------------|
+*       |		|
+*       |general purpose|
+*       |     r[0:13]   | 
+*       |		|
+*       |---------------|
+*       |emulated MSR   |
+*       |---------------|
+*       |       dbsr    |
+*       |---------------|
+*       | dbcr[0:2]     |
+*       |---------------|
+*       |IAC[1:2]       |
+*       |---------------|
+*       |DAC[1:2]       |
+*       |---------------|
+*       |reserved[0:9]  |
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's control C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
+*
+*    uint32_t srr0;	/@  0: PC		    @/
+*    uint32_t srr1;	/@  1: MSR		    @/
+*    uint32_t cr;	/@  2: condition registers	    @/
+*    uint32_t r0;	/@  3: General register R0	    @/
+*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;	/@  5: General register R2	    @/
+*    uint32_t r3;	/@  6: General register R3	    @/
+*    uint32_t r4;	/@  7: General register R4	    @/
+*    uint32_t r5;	/@  8: General register R5	    @/
+*    uint32_t r6;	/@  9: General register R6	    @/
+*    uint32_t r7;	/@ 10: General register R7	    @/
+*    uint32_t r8;	/@ 11: General register R8	    @/
+*    uint32_t r9;	/@ 12: General register R9	    @/
+*    uint32_t r10;	/@ 13: General register R10	    @/
+*    uint32_t r11;	/@ 14: General register R11	    @/
+*    uint32_t r12;	/@ 15: General register R12	    @/
+*    uint32_t r13;	/@ 16: General register R13	    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbsr; /@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2		    @/
+*
+*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
+*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
+*
+*    /@ data address compare registers DAC1-DAC2.	        @/
+*
+*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
+*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
+*
+*    /@ reserved fields for future use			    @/
+*
+*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*\COMMAND
+*/
+
+typedef struct vbArchControlRegs
+    {
+
+    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+
+    uint32_t srr0;		/*  0: PC */
+    uint32_t srr1;		/*  1: MSR */
+    uint32_t cr;		/*  2: condition registers */
+    uint32_t r0;		/*  3: General register R0 */
+    uint32_t sp;		/*  4: General register R1 (stack pointer) */
+    uint32_t r2;		/*  5: General register R2 */
+    uint32_t r3;		/*  6: General register R3 */
+    uint32_t r4;		/*  7: General register R4 */
+    uint32_t r5;		/*  8: General register R5 */
+    uint32_t r6;		/*  9: General register R6 */
+    uint32_t r7;		/* 10: General register R7 */
+    uint32_t r8;		/* 11: General register R8 */
+    uint32_t r9;		/* 12: General register R9 */
+    uint32_t r10;		/* 13: General register R10 */
+    uint32_t r11;		/* 14: General register R11 */
+    uint32_t r12;		/* 15: General register R12 */
+    uint32_t r13;		/* 16: General register R13 */
+
+    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;		/* 17: emulated MSR register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbsr; /* 18 - debug status register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbcr0; /* 19 - debug control register 0 */
+    uint32_t     dbcr1; /* 20 - debug control register 1 */
+    uint32_t     dbcr2; /* 21 - debug control register 2 */
+
+    /* instruction address compare registers IAC1-IAC2 */
+
+    uint32_t     iac1; /* 22 - instructions access control 1 */
+    uint32_t     iac2; /* 23 - instructions access control 2 */
+
+    /* data address compare registers DAC1-DAC2. */
+
+    uint32_t     dac1; /* 24 - instructions access control 3 */
+    uint32_t     dac2; /* 25 - instructions access control 4 */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved[10];      /* 26: Reserved */ 
+    } VB_ARCH_CONTROL_REGS;
+
+/*******************************************************************************
+*
+* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
+*
+* Virtual board emulated CPU status registers
+*
+* SYNOPSIS
+*
+* PPC Status structure graphical illustration
+*\cs
+*        _______________   ---------------------------
+*       |    SRR0       |   
+*       |---------------|
+*       |    SRR1       |   Registers save by WRHV	
+*       |---------------|   before injecting an exception/interrupt
+*       |    CR		|
+*       |---------------|
+*       |    LR		|
+*       |---------------|
+*       |    r3		| 
+*       |---------------|
+*       |    r4         |
+*       |---------------|   ---------------------------
+*	|    mcsrr0	|	
+*       |---------------|  Registers saved duing exception handling
+*       |    mcssr1     |
+*       |---------------|
+*       |    esr        |
+*       |---------------|
+*       |    mcsr       |
+*       |---------------|
+*       |    mcar       |
+*       |---------------|
+*       |    dear       |
+*       |---------------|
+*       |    emsr       |
+*       |---------------|
+*       |    esrr0      |
+*       |---------------|
+*       |    esrr1      |
+*       |---------------|    -------------------------
+*       | reserved[8]   |      8 x 32bits for future enhencements
+*       |---------------|    -------------------------
+*       |    svr        |
+*       |---------------|
+*       |    pir        |
+*       |---------------|
+*       |    pvr        |    Configuration registers updated
+*       |---------------|    upon board creation    
+*       |    hid0       |  
+*       |---------------|
+*       |    hid1       |
+*       |---------------|
+*       |    buscr      |
+*       |---------------|       
+*       |    l1csr0     |
+*       |---------------|
+*       |    l1csr1     |
+*       |---------------|   --------------------------
+*       | reserved[0:8] | 9x 32bit
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_ARCH_STATUS_REGS structure definition
+*
+* typedef struct archStatusRegs
+*    {
+*
+*    /@ 
+*     @ registers saved by WRHV for all interrupts exceptions
+*     @ before setting the PC in the virtual board to the exception/interrupt
+*     @ vector address
+*     @/
+*
+*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
+*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
+*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
+*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
+*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
+*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
+*
+*    /@ Registers saved by WRHV during exception processing only    @/
+*
+*    uint32_t mcsrr0; /@  6:			    @/
+*    uint32_t mcsrr1; /@  7:			    @/
+*    uint32_t esr;    /@  8:			    @/
+*    uint32_t mcsr;   /@  9:			    @/
+*    uint32_t mcar;   /@ 10			@/
+*    uint32_t dear;   /@ 11:			    @/
+*    uint32_t emsr;   /@ 12:			    @/
+*    uint32_t esrr0;  /@ 13:			    @/
+*    uint32_t esrr1;  /@ 14:			    @/
+*
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved1[8]; /@ 15 - 22			@/
+*
+*    /@ Configuration registers (only updated upon board creation   @/
+*
+*    uint32_t svr;     /@ 23			    @/     
+*    uint32_t pir;     /@ 24			    @/
+*    uint32_t pvr;     /@ 25			    @/  
+*    uint32_t hid0;    /@ 26			    @/
+*    uint32_t hid1;    /@ 27			    @/
+*    uint32_t bucsr;   /@ 28			    @/
+*    uint32_t l1csr0;  /@ 29			    @/
+*    uint32_t l1csr1;  /@ 30			    @/
+*    
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved2[9]; /@ 31 - 39			@/
+*
+*    } VB_ARCH_STATUS_REGS; 
+*
+*
+*\ce
+*
+* SEE ALSO: VB_STATUS 
+*\COMMAND
+*/
+
+typedef struct archStatusRegs
+    {
+
+    /* 
+     * registers saved by Razor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+
+    uint32_t srr0; /* 0: PC at time of the interrupt */
+    uint32_t srr1; /* 1: MSR at time of the interrupt */
+    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 3: Link register at time of the interrupt */
+    uint32_t r3;   /* 4: R3 at time of the interrupt */
+    uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+    /* Registers saved by Razor during exception processing only */
+
+    uint32_t mcsrr0; /*  6: */
+    uint32_t mcsrr1; /*  7: */
+    uint32_t esr;    /*  8: */
+    uint32_t mcsr;   /*  9: */
+    uint32_t mcar;   /* 10  */
+    uint32_t dear;   /* 11: */
+    uint32_t emsr;   /* 12: */
+    uint32_t esrr0;  /* 13: */
+    uint32_t esrr1;  /* 14: */
+
+/* 
+ * keep this part in a separate structure in order to keep the offsets
+ * to remain the same as in VB_STATUS
+ */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved1[8]; /* 15 - 22  */
+
+    /* Configuration registers (only updated upon board creation */
+
+    uint32_t svr;     /* 23 */     
+    uint32_t pir;     /* 24 */
+    uint32_t pvr;     /* 25 */  
+    uint32_t hid0;    /* 26 */
+    uint32_t hid1;    /* 27 */
+    uint32_t bucsr;   /* 28 */
+    uint32_t l1csr0;  /* 29 */
+    uint32_t l1csr1;  /* 30 */
+    
+    /* reserved fields for future use */
+
+    uint32_t reserved2[9]; /* 31 - 39 */
+
+    } VB_ARCH_STATUS_REGS; 
+
+
+/*******************************************************************************
+*
+* VBI_HREG_SET - hardware register set, for read/write
+*
+* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
+* another VB
+* 
+* SYNOPSIS
+*
+* VB hardware register set C data structure type definition
+*
+*\cs
+*
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VBI_HREG_SET;
+* 
+*
+*\ce
+* SEE ALSO: NONE
+* 
+*/
+
+#define GREG_NUM	32	/* has 32 32/64-bit data registers */
+
+typedef struct
+    {
+    uint32_t gpr[GREG_NUM];	/* general purpose registers */
+    uint32_t msr;		/* machine state register */
+    uint32_t lr;		/* link register */
+    uint32_t ctr;		/* count register */
+    uint32_t pc;		/* program counter */
+    uint32_t cr;		/* condition register */
+    uint32_t xer;		/* fixed-point exception register */
+    uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
+    uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+    } HREG_SET;
+
+/* VBI_HREG_SET is same as HREG_SET in ppc */
+typedef HREG_SET VBI_HREG_SET;
+
+/* mdio messages */
+
+#define VBI_MDIO_READ           MDIO_READ
+#define VBI_MDIO_WRITE          MDIO_WRITE
+#define VBI_BSP_CLK_FREQ        BSP_CLK_FREQ
+
+/* This should exceed the number of IVOR registers defined in the hardware 
+* It also defined the size of the excVectorTable size 
+* VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000 */
+#define VBI_ARCH_MAX_EXC_OFFSETS	64	
+
+typedef struct
+    {
+    uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
+    } VBI_EXC_OFFSETS_TABLE;
+
+extern status_t vbiExcOffsetsSet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+extern status_t vbiExcOffsetsGet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+
+/* common system wide message header structure */
+
+typedef struct vbi_msg_header {
+    uint32_t msgId;	/* message type identification */
+    uint32_t msgArg;	/* argument associated with message type */
+} VBI_MSG_HEADER;
+
+/* request message */
+
+typedef struct 
+    {
+    VBI_MSG_HEADER hdr;			/* message header */
+    uint32_t   request;			/* request type */
+
+    union 
+	{
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t phyAddr;
+	    uint32_t regNum;
+	    uint32_t page;
+	    } mdioRead;
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t phyAddr;
+	    uint32_t regNum;
+	    uint32_t page;
+	    uint32_t dataVal;
+	    } mdioWrite;
+#if 0 /* not supported for now */
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t vbIntNum;
+	    HY_CTX *pCtx;
+	    } mdioIntEnable;
+    	struct 
+	    {
+	    uint32_t bus;	
+	    uint32_t vbIntNum;
+	    HY_CTX *pCtx;
+	    } mdioIntDisable;
+#endif
+	} arg;				
+    
+    } VBI_BSP_MSG;
+
+typedef struct 
+    {
+    VBI_MSG_HEADER hdr;			/* message header */
+    uint32_t   status;			/* request completion status */
+    uint32_t   dataVal;
+    } VBI_BSP_MSG_REPLY;
+
+#else /*_ASMLANGUAGE */
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+#define VBI_CTX_LOAD(reg)				    \
+	lis	reg, HI(VBI_SYS_ctx_load);		    \
+	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
+	sc
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
+	li	reg1, -1;				\
+        lis     reg2, HIADJ(wrhvVbControl);		\
+        lwz     reg2, LO(wrhvVbControl)(reg2);		\
+        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
+        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	li	reg1, 0;					\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+checkIntVcorePending:						\
+	lis	reg0, HIADJ(wrhvVbStatus);			\
+	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
+	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
+								\
+	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
+	beq     endIntVcoreLock;				\
+	lis	r0, HI(VBI_SYS_int_enable);			\
+	ori	r0, r0, LO(VBI_SYS_int_enable);			\
+	sc;							\
+	b	checkIntVcorePending;				\
+endIntVcoreLock:
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+#define VBI_INT_VCORE_STATE_GET(reg0)				\
+	VBI_CNTRL_ADDR_GET(reg0);				\
+	lwz	reg0, VB_CONTROL_INT_DISABLE(reg0);		
+
+/*******************************************************************************
+*
+* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+*
+* This macro returns the base address of the configuration structure of the 
+* running core. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro for PPC assembly code
+*
+* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CONFIG_ADDR_GET(reg)		    \
+        lis     reg, HIADJ(wrhvVbConfig);	    \
+        lwz     reg, LO(wrhvVbConfig)(reg)	    
+
+/*******************************************************************************
+*
+* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+*
+* This macro returns the base address of the running virtual core's control
+* structure.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CNTRL_ADDR_GET(reg)			    \
+        lis     reg, HIADJ(wrhvVbControl);	    \
+        lwz     reg, LO(wrhvVbControl)(reg) 	     
+
+/*******************************************************************************
+*
+* VBI_STATUS_ADDR_GET - Get virtual core status structure address
+*
+* This macro returns the base address of the status structure of currently
+* running core. This structure is read-only and contains a description of
+* the running virtual core. Hypervisor uses this data to inform the
+* virtual board time variant data that may be updated during hypervisor context
+* Switch. Typical that are available in the status structure are:
+*
+*\ms
+*\m - 
+*Timer tick counter
+*\m -
+*Pending interrupt state
+*\m -
+*The interrupt state before this core was schedule
+*\m -
+*VMMU configuration
+*\m -
+*Virtual core registers state
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_STATUS * VBI_STATUS_ADDR_GET(void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_STATUS_ADDR_GET(reg)			    \
+        lis     reg, HIADJ(wrhvVbStatus);		    \
+        lwz     reg, LO(wrhvVbStatus)(reg)	     
+
+#endif /*_ASMLANGUAGE */
+    
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __INCvbiPpcArchh */
diff --git a/include/vbi/support/sys/ppc/asm.h b/include/vbi/support/sys/ppc/asm.h
new file mode 100644
index 0000000..427de23
--- /dev/null
+++ b/include/vbi/support/sys/ppc/asm.h
@@ -0,0 +1,526 @@
+/* sys/ppc/asm.h - PowerPC tool dependent headers */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+/*
+modification history
+--------------------
+01c,15jul09,dtr  Support CPU PPCE500MC.
+01b,23nov07,foo  add spr defines
+01a,03oct07,md   written from VxWorks toolPpc.h version 02c
+*/
+
+#ifndef __INCsysPpcAsmh
+#define __INCsysPpcAsmh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if	!defined(_DIAB_TOOL) && !defined(_GNU_TOOL)
+#define	_GNU_TOOL
+#endif
+
+/* PowerPC specific settings */
+#if (CPU==PPCE500MC)
+#define	_PPC_HREG_SIZE		4	/* default register size */
+#define _PPC_TEXT_SEG_ALIGN     8       /* 8 byte text segment alignment */
+#else
+#define	_PPC_HREG_SIZE		4	/* default register size */
+#define _PPC_TEXT_SEG_ALIGN     4       /* 4 byte text segment alignment */
+#endif
+
+/* macros for stack frame */
+
+/*
+SVR4 Stack space allocation:
+
+    Before Dynamic stack allocation
+
+    +----------------------------------+
+    |       Back Chain                 |
+    |----------------------------------|
+    |  Register save areas             |
+    |----------------------------------|
+    |  local,non-static variables      |
+    |----------------------------------|
+    |  parameter lists for callees     | (overloaded parameters with #)
+    |----------------------------------|
+    |      LR save word                |
+    |----------------------------------|
+SP=>|      Back chain                  |
+    +----------------------------------+
+
+    After Dynamic stack allocation
+
+    +----------------------------------+
+    |       Back Chain                 |
+    |----------------------------------|
+    |  Register save areas             |
+    |----------------------------------|
+    |  local,non-static variables      |
+    |----------------------------------|
+    |  Dynamic Allocation Area         | 16 byte stack alignment
+    |----------------------------------|
+    |  parameter lists for callees     |
+    |----------------------------------|
+    |      LR save word                |
+    |----------------------------------|
+SP=>|      Back chain                  |
+    +----------------------------------+ 16 bytes stack alignment
+*/
+
+  /* Stack and Allocation alignment */
+
+/*
+ * While it is possible to use different stack alignments for different
+ * PPC processors, current compilers use 16-byte alignment for all.
+ */
+
+#define _CPU_STACK_ALIGN_SIZE	16	/* stack alignment (for all PPC) */
+#define	_CPU_STACK_ALIGN_SHIFT	4
+
+#if	((CPU == PPC604) || (CPU == PPC85XX) || (CPU == PPCE500MC) || (CPU == PPC970)) /* Altivec, E500 EABI */
+# define _CPU_ALLOC_ALIGN_SIZE	16	/* allocation alignment */
+#elif	(CPU != PPC32)			/* for others, !defined for generic */
+# define _CPU_ALLOC_ALIGN_SIZE	8	/* allocation alignment */
+#endif	/* PPC604|PPC85XX|PPC970 : !PPC32 */
+
+#define	FRAMEBASESZ		16	/* minimum stack frame size */
+
+/*
+*
+* _WRS_ARCH_USER_STACK_FRAME_EXTENSION - creating words on the stack for the 
+*                                        back chain word and the LR register.
+*
+* This macro is used in creating the initial stack frame for an RTP's initial 
+* task. It performs the extra steps of creating words on the stack for the 
+* back chain word and the LR register. Both these locations are set to 0 to 
+* prevent stack traces and debuggers from looking ahead.
+*
+* NOMANUAL
+*/
+
+#define _WRS_ARCH_USER_STACK_FRAME_EXTENSION(sp)			     \
+    do									     \
+	{								     \
+	(sp) -= 2*sizeof(int *);					     \
+	*((int *)(sp)) = (int)0;					     \
+	*((int *)((sp)+4)) = (int)0;					     \
+	} while ((0))
+
+
+#ifdef	_ASMLANGUAGE
+
+/* register definition */
+
+/* common SPR registers */
+
+#ifndef XER
+#define XER 1
+#endif
+#ifndef LR
+#define LR 8
+#endif						
+#ifndef CTR
+#define CTR 9
+#endif
+
+/* volatile registers that are not saved across subroutine calls */
+
+#define p0	r3	/* argument register, volatile */
+#define p1	r4	/* argument register, volatile */
+#define p2	r5	/* argument register, volatile */
+#define p3	r6	/* argument register, volatile */
+#define p4	r7	/* argument register, volatile */
+#define p5	r8	/* argument register, volatile */
+#define p6	r9	/* argument register, volatile */
+#define p7	r10	/* argument register, volatile */
+#define glr0	r0	/* prologs(PO,EABI), epilogs, glink routines(EABI) /
+			 * language specific purpose(SVR4), volatile */
+#define glr1	r11	/* prologs, epilogs, as Pascal environment pointer(EABI)
+			 * language specific purpose (SVR4)
+			 * calls by pointer, as Pascal environment(PO), 
+			 * volatile */
+#define glr2	r12	/* prologs, epilogs, glink routines, calls by 
+			 * pointer(EABI), language specific purpose (SVR4),
+			 * glue code, exception handling (PO), volatile */
+#define retval0	r3	/* return register 0, volatile */
+#define retval1	r4	/* return register 1, volatile */
+
+
+/* non-volatile and dedicated registers saved across subroutine calls */
+
+#define	sp	r1	/* stack pointer, dedicated */
+
+#define t0	r14	/* temporary registers, non-volatile */
+#define t1	r15	/* temporary registers, non-volatile */
+#define t2	r16	/* temporary registers, non-volatile */
+#define t3	r17	/* temporary registers, non-volatile */
+#define t4	r18	/* temporary registers, non-volatile */
+#define t5	r19	/* temporary registers, non-volatile */
+#define t6	r20	/* temporary registers, non-volatile */
+#define t7	r21	/* temporary registers, non-volatile */
+#define t8	r22	/* temporary registers, non-volatile */
+#define t9	r23	/* temporary registers, non-volatile */
+#define t10	r24	/* temporary registers, non-volatile */
+#define t11	r25	/* temporary registers, non-volatile */
+#define t12	r26	/* temporary registers, non-volatile */
+#define t13	r27	/* temporary registers, non-volatile */
+#define t14	r28	/* temporary registers, non-volatile */
+#define t15	r29	/* temporary registers, non-volatile */
+#define t16	r30	/* temporary registers, non-volatile */
+#define t17	r31	/* temporary registers, non-volatile */
+
+#ifdef	_GNU_TOOL
+
+/* GP register names */
+
+#define r0	0
+#define r1	1
+#define r2	2
+#define r3	3
+#define r4	4
+#define r5	5
+#define r6	6
+#define r7	7
+#define r8	8
+#define r9	9
+#define r10	10
+#define r11	11
+#define r12	12
+#define r13	13
+#define r14	14
+#define r15	15
+#define r16	16
+#define r17	17
+#define r18	18
+#define r19	19
+#define r20	20
+#define r21	21
+#define r22	22
+#define r23	23
+#define r24	24
+#define r25	25
+#define r26	26
+#define r27	27
+#define r28	28
+#define r29	29
+#define r30	30
+#define r31	31
+
+#ifdef	_PPC_MSR_FP
+/* FP register names */
+
+#define	fp0	0
+#define	fr0	0
+#define	f0	0
+#define	fp1	1
+#define	fr1	1
+#define	f1	1
+#define	fp2	2
+#define	fr2	2
+#define	f2	2
+#define	fp3	3
+#define	fr3	3
+#define	f3	3
+#define	fp4	4
+#define	fr4	4
+#define	f4	4
+#define	fp5	5
+#define	fr5	5
+#define	f5	5
+#define	fp6	6
+#define	fr6	6
+#define	f6	6
+#define	fp7	7
+#define	fr7	7
+#define	f7	7
+#define	fp8	8
+#define	fr8	8
+#define	f8	8
+#define	fp9	9
+#define	fr9	9
+#define	f9	9
+#define	fp10	10
+#define	fr10	10
+#define	f10	10
+#define	fp11	11
+#define	fr11	11
+#define	f11	11
+#define	fp12	12
+#define	fr12	12
+#define	f12	12
+#define	fp13	13
+#define	fr13	13
+#define	f13	13
+#define	fp14	14
+#define	fr14	14
+#define	f14	14
+#define	fp15	15
+#define	fr15	15
+#define	f15	15
+#define	fp16	16
+#define	fr16	16
+#define	f16	16
+#define	fp17	17
+#define	fr17	17
+#define	f17	17
+#define	fp18	18
+#define	fr18	18
+#define	f18	18
+#define	fp19	19
+#define	fr19	19
+#define	f19	19
+#define	fp20	20
+#define	fr20	20
+#define	f20	20
+#define	fp21	21
+#define	fr21	21
+#define	f21	21
+#define	fp22	22
+#define	fr22	22
+#define	f22	22
+#define	fp23	23
+#define	fr23	23
+#define	f23	23
+#define	fp24	24
+#define	fr24	24
+#define	f24	24
+#define	fp25	25
+#define	fr25	25
+#define	f25	25
+#define	fp26	26
+#define	fr26	26
+#define	f26	26
+#define	fp27	27
+#define	fr27	27
+#define	f27	27
+#define	fp28	28
+#define	fr28	28
+#define	f28	28
+#define	fp29	29
+#define	fr29	29
+#define	f29	29
+#define	fp30	30
+#define	fr30	30
+#define	f30	30
+#define	fp31	31
+#define	fr31	31
+#define	f31	31
+#endif	/* _PPC_MSR_FP */
+
+/* Condition register names */
+
+#define cr0	0
+#define cr1	1
+#define cr2	2
+#define cr3	3
+#define cr4	4
+#define cr5	5
+#define cr6	6
+#define cr7	7
+
+/* Macro for hiadjust and lo */
+
+#define HIADJ(arg)	arg@ha
+#define HI(arg)		arg@h
+#define LO(arg)		arg@l
+
+#ifdef _PPC_MSR_VEC
+
+/* ALTIVEC Vector register names */
+
+#define v0      0
+#define v1      1
+#define v2      2
+#define v3      3
+#define v4      4
+#define v5      5
+#define v6      6
+#define v7      7
+#define v8      8
+#define v9      9
+#define v10     10
+#define v11     11
+#define v12     12
+#define v13     13
+#define v14     14
+#define v15     15
+#define v16     16
+#define v17     17
+#define v18     18
+#define v19     19
+#define v20     20
+#define v21     21
+#define v22     22
+#define v23     23
+#define v24     24
+#define v25     25
+#define v26     26
+#define v27     27
+#define v28     28
+#define v29     29
+#define v30     30
+#define v31     31
+
+#endif /* _PPC_MSR_VEC */
+
+#endif	/* _GNU_TOOL */
+
+#ifdef	_DIAB_TOOL
+
+#ifdef	_PPC_MSR_FP
+/* Diab Data FP register names */
+
+#define	fp0	f0
+#define	fr0	f0
+#define	fp1	f1
+#define	fr1	f1
+#define	fp2	f2
+#define	fr2	f2
+#define	fp3	f3
+#define	fr3	f3
+#define	fp4	f4
+#define	fr4	f4
+#define	fp5	f5
+#define	fr5	f5
+#define	fp6	f6
+#define	fr6	f6
+#define	fp7	f7
+#define	fr7	f7
+#define	fp8	f8
+#define	fr8	f8
+#define	fp9	f9
+#define	fr9	f9
+#define	fp10	f10
+#define	fr10	f10
+#define	fp11	f11
+#define	fr11	f11
+#define	fp12	f12
+#define	fr12	f12
+#define	fp13	f13
+#define	fr13	f13
+#define	fp14	f14
+#define	fr14	f14
+#define	fp15	f15
+#define	fr15	f15
+#define	fp16	f16
+#define	fr16	f16
+#define	fp17	f17
+#define	fr17	f17
+#define	fp18	f18
+#define	fr18	f18
+#define	fp19	f19
+#define	fr19	f19
+#define	fp20	f20
+#define	fr20	f20
+#define	fp21	f21
+#define	fr21	f21
+#define	fp22	f22
+#define	fr22	f22
+#define	fp23	f23
+#define	fr23	f23
+#define	fp24	f24
+#define	fr24	f24
+#define	fp25	f25
+#define	fr25	f25
+#define	fp26	f26
+#define	fr26	f26
+#define	fp27	f27
+#define	fr27	f27
+#define	fp28	f28
+#define	fr28	f28
+#define	fp29	f29
+#define	fr29	f29
+#define	fp30	f30
+#define	fr30	f30
+#define	fp31	f31
+#define	fr31	f31
+#endif	/* _PPC_MSR_FP */
+
+/* Macro for hiadjust and lo */
+
+#define HIADJ(arg)      %hiadj(arg)
+#define HI(arg)		%hi(arg)
+#define LO(arg)      	%lo(arg)
+
+#endif	/* _DIAB_TOOL */
+
+/*
+ * define r2 as VTOC/GOT(EABI), system use(SVR4)/TOC/GOT(PO),dedicated. 
+ * define r13 as CTOC/GOT anchor pointer, dedicated (EABI), non-volatile
+ * register (SVR4, PO) 
+ */
+
+#define FUNC(func)	    func
+#define FUNC_LABEL(func)    func:
+
+#define FUNC_DECL(range, func)
+#define VAR_DECL(var)   var
+#define VAR(var)        var(r0)
+
+/*
+ * These macros are used to declare assembly language symbols that need
+ * to be typed properly(func or data) to be visible to the OMF tool.  
+ * So that the build tool could mark them as an entry point to be linked
+ * by another PD.
+ */
+
+#define GTEXT(sym) FUNC(sym) ;  .type   FUNC(sym),@function
+#define GDATA(sym) VAR_DECL(sym) ;  .type   VAR_DECL(sym),@object
+
+/* Introduced to abstract assembler idiosyncrasies */
+
+#define	FUNC_EXPORT(func)	.globl	GTEXT(func)
+#define	DATA_EXPORT(var)	.globl	GDATA(var)
+#define	FUNC_IMPORT(func)	.extern	FUNC(func)
+#define	DATA_IMPORT(var)	.extern	VAR_DECL(var)
+#define	FUNC_BEGIN(func)	FUNC_LABEL(func)
+#define	FUNC_END(func)		.size	FUNC(func), . - FUNC(func)
+
+/* Macro for beginning a text segment */
+
+#define _WRS_TEXT_SEG_START \
+        .text ; .balign _PPC_TEXT_SEG_ALIGN
+
+#define	FRAMESZ(nregs)	\
+    	  ROUND_UP((FRAMEBASESZ + nregs * _PPC_HREG_SIZE), _STACK_ALIGN_SIZE)
+
+#define	LOADPTR(reg,const32) \
+	  addis reg,r0,HIADJ(const32); addi reg,reg,LO(const32)
+
+#define	LOADVAR(reg,const32) \
+	  addis reg,r0,HIADJ(const32); lwz reg,LO(const32)(reg)
+
+#else	/* _ASMLANGUAGE */
+
+#define _WRS_ASM(x) __asm volatile (x)
+
+/*
+ * Use constant sizes if known (when building for a specific CPU type)
+ * else fetch from a global variable (when building for generic PPC32)
+ */
+
+#ifdef	_CPU_STACK_ALIGN_SIZE
+#define	_STACK_ALIGN_SIZE	_CPU_STACK_ALIGN_SIZE
+#else	/* _CPU_STACK_ALIGN_SIZE */
+#define	_STACK_ALIGN_SIZE	_ppcStackAlignSize
+extern	int	_ppcStackAlignSize;
+#endif	/* _CPU_STACK_ALIGN_SIZE */
+
+#ifdef	_CPU_ALLOC_ALIGN_SIZE
+#define	_ALLOC_ALIGN_SIZE	_CPU_ALLOC_ALIGN_SIZE
+#else	/* _CPU_ALLOC_ALIGN_SIZE */
+#define	_ALLOC_ALIGN_SIZE	_ppcAllocationQuantumSize
+extern	int	_ppcAllocationQuantumSize;
+#endif	/* _CPU_ALLOC_ALIGN_SIZE */
+
+#define	FUNCREF(func)	func
+
+#endif	/* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCsysPpcAsmh */
diff --git a/include/vbi/support/sys/ppc/ppc85xx.h b/include/vbi/support/sys/ppc/ppc85xx.h
new file mode 100644
index 0000000..ae71d29
--- /dev/null
+++ b/include/vbi/support/sys/ppc/ppc85xx.h
@@ -0,0 +1,641 @@
+/* ppc85xx.h - PowerPC specific header */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,15sep09,dtr  Seperate out e500mc specific defs to another header file.
+01f,25aug09,dtr  Add additional SPR registers for E500MC.
+01e,19jun09,dtr  Modifying for e500mc. Some cleanup.
+01d,23apr09,dtr  Set mask for allowed MSR values.
+01c,11feb09,dtr  Assume e500v2 support.
+01b,17oct07,md   remove MSR specific settings
+01a,03oct07,md   written from VxWorks ppc85xx.h version 01v 
+*/
+
+#ifndef __INCppc85xxh
+#define __INCppc85xxh
+
+#if (CPU == PPCE500MC)
+#include <sys/ppc/ppcE500mc.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if (CPU==PPC85XX)
+#define PPC_e500v2
+#endif
+
+
+/* Maximum cache line size for the cpu */
+#undef	_CPU_CACHE_ALIGN_SIZE
+#if (CPU == PPCE500MC)
+#define	_CPU_CACHE_ALIGN_SHIFT	6	/* cache align size = 32 */
+#define	_CPU_CACHE_ALIGN_SIZE	64	/* cannot use (1<<5) because compiler*/
+#else
+#define	_CPU_CACHE_ALIGN_SHIFT	5	/* cache align size = 32 */
+#define	_CPU_CACHE_ALIGN_SIZE	32	/* cannot use (1<<5) because compiler
+                                         * directive __attribute__ cant hdl */
+#endif
+/* MMU supports software TLB miss handler */
+
+#undef  _WRS_TLB_MISS_CLASS_HW
+#define _WRS_TLB_MISS_CLASS_SW  1
+
+/* MMU uses PID register to extend virtual address tag */
+
+#undef	_WRS_MMU_CLASS_NONE
+#undef	_WRS_MMU_CLASS_SR_REGS
+#define _WRS_MMU_CLASS_PID_REG	1
+
+/* MMU ASID context register name for _WRS_MMU_CLASS_PID_REG */
+
+#define	_PPC_PID_REG		PID0
+
+/* MMU cannot be disabled */
+
+#define	PPC_NO_REAL_MODE
+
+/*
+ * MMU supports the M attribute bit, allowing the coherency-required property
+ * to be configured on a per-page basis.  Therefore, even when snooping is
+ * enabled, cacheDmaMalloc needs to call arch support to set the M bit.
+ */
+#define	_WRS_SNOOP_NEEDS_DMA_MALLOC_SUPPORT
+
+#if  (CPU != PPCE500MC)
+#define _WRS_SPE_SUPPORT	1
+#endif /* (CPU != PPCE500MC) */
+
+#define _WRS_E500_FIXED_POINT_SUPPORT 1
+
+#ifdef _WRS_SPE_SUPPORT
+#undef _PPC_MSR_FP
+#define _PPC_MSR_SPE_U		0x0200
+#define _PPC_MSR_SPE		0x02000000
+#define MSR_SPE_BIT_SHIFT	25
+#endif /* _WRS_SPE_SUPPORT */
+
+/* #define IMMR	638	* bogus hack */
+
+/* Special Purpose Register (SPR) numbers */
+
+#define CSRR0   58      /* Critical SRR0 */
+#define CSRR1   59      /* Critical SRR1 */
+#define DEAR    61      /* Data Exception Address Register */
+#define ESR     62      /* Exception Syndrome Register */
+#define IVPR    63      /* Interrupt Vector Prefix Register */
+#define IVOR0   400     /* IVOR Critical Input */
+#define IVOR1   401     /* IVOR Machine Check */
+#define IVOR2   402     /* IVOR Data Storage */
+#define IVOR3   403     /* IVOR Instruction Storage */
+#define IVOR4   404     /* IVOR External Input */
+#define IVOR5   405     /* IVOR Alignment */
+#define IVOR6   406     /* IVOR Program */
+#define IVOR7   407     /* IVOR Floating Point Unavailable */
+#define IVOR8   408     /* IVOR System Call */
+#define IVOR9   409     /* IVOR Auxiliary Processor Unavailable */
+#define IVOR10  410     /* IVOR Decrementer */
+#define IVOR11  411     /* IVOR Fixed Interval Timer */
+#define IVOR12  412     /* IVOR Watchdog Timer */
+#define IVOR13  413     /* IVOR Data TLB Error */
+#define IVOR14  414     /* IVOR Instruction TLB Error */
+#define IVOR15  415     /* IVOR Debug */
+#if (CPU==PPC85XX)
+#define IVOR32  528     /* IVOR SPE */
+#define IVOR33  529     /* IVOR Vector FP Data */
+#define IVOR34  530     /* IVOR Vector FP Round */
+#endif
+#ifndef PPC_e200 
+#define IVOR35  531     /* IVOR Performance Monitor */
+#endif
+
+#ifndef PPC_e200 
+#define MCSRR0  570     /* Machine Check SRR0 */
+#define MCSRR1  571     /* Machine Check SRR1 */
+#define MCAR    573     /* Machine Check Address Register */
+#else
+#define MCSRR0  CSRR0     /* Machine Check SRR0 */
+#define MCSRR1  CSRR1     /* Machine Check SRR1 */
+#undef MCAR         /* Machine Check Address Register */
+#endif
+
+#define MCSR    572     /* Machine Check Syndrome Register */
+
+#if (CPU==PPC85XX)
+#define SPEFSCR 512     /* SPE Floating-pt Status and Control Register */
+#endif
+
+/* SPRG0-SPRG3 are defined correctly in asmPpc.h */
+#define SPRG4_R 260     /* Special Purpose Register General 4, read */
+#define SPRG4_W 276     /* Special Purpose Register General 4, write */
+#define SPRG5_R 261     /* Special Purpose Register General 5, read */
+#define SPRG5_W 277     /* Special Purpose Register General 5, write */
+#define SPRG6_R 262     /* Special Purpose Register General 6, read */
+#define SPRG6_W 278     /* Special Purpose Register General 6, write */
+#define SPRG7_R 263     /* Special Purpose Register General 7, read */
+#define SPRG7_W 279     /* Special Purpose Register General 7, write */
+#define TBL_R   268     /* Time Base Lower, read */
+#define TBL_W   284     /* Time Base Lower, write */
+#define TBU_R   269     /* Time Base Upper, read */
+#define TBU_W   285     /* Time Base Upper, write */
+#define TCR     340     /* Timer Control Register */
+#define TSR     336     /* Timer Status Register */
+#define USPRG0  256     /* User Special Purpose Register General 0 */
+#define DBCR0   308     /* Debug Control Register 0 */
+#define DBCR1   309     /* Debug Control Register 1 */
+#define DBCR2   310     /* Debug Control Register 2 */
+#define DBSR    304     /* Debug Status Register */
+#define IAC1    312     /* Instr Address Compare Register 1 */
+#define IAC2    313     /* Instr Address Compare Register 2 */
+#define DAC1    316     /* Data Address Compare Register 1 */
+#define DAC2    317     /* Data Address Compare Register 2 */
+#define L1CFG0  515     /* L1 Config Register 0 */
+#define L1CFG1  516     /* L1 Config Register 1 */
+#define L1CSR0  1010    /* L1 Control Status Register 0 */
+#define L1CSR1  1011    /* L1 Control Status Register 1 */
+#ifdef PPC_e200
+#define L1FINV0 1016
+#endif
+
+#define MAS0    624     /* MMU Assist Register 0 */
+#define MAS1    625     /* MMU Assist Register 1 */
+#define MAS2    626     /* MMU Assist Register 2 */
+#define MAS3    627     /* MMU Assist Register 3 */
+#define MAS4    628     /* MMU Assist Register 4 */
+
+#define MAS6    630     /* MMU Assist Register 6 */
+#if defined(PPC_e500v2) || (CPU == PPCE500MC)
+#define MAS7    944     /* MMU Assist Register 7 */
+#endif /* PPC_e500v2 */
+
+#define TLB0CFG 688     /* TLB 0 Config Register */
+#define TLB1CFG 689     /* TLB 1 Config Register */
+#define MMUCSR0 1012    /* MMU Control Status Register 0 */
+#define MMUCFG  1015    /* MMU Config Register */
+
+
+/*
+ * Machine check exception class is new to PPC in E500.  Although
+ * bit position is same as classic MSR[ME] and is named the same,
+ * the define of _PPC_MSR_MCE signifies the present of this
+ * class of exception.  If present, both _PPC_MSR_MCE and
+ * _PPC_MSR_ME should be defined to the mask of 0x1000.
+ * In addition, Critical Exception Class is also a requirement.
+ * The critical exception code stub does not mask exceptions
+ * and is used for machine check exception class as well.
+ * Therefore, _EXC_OFF_CRTL should be defined.
+ */
+
+#ifndef PPC_e200
+#define _PPC_MSR_MCE    _PPC_MSR_ME	/* machine check enable */
+#else
+#undef _PPC_MSR_MCE
+#endif
+
+#define	_PPC_MSR_BIT_WE		13
+#define	_PPC_MSR_BIT_CE		14
+#define	_PPC_MSR_BIT_DE		22
+#define _PPC_MSR_BIT_IS		26
+#define _PPC_MSR_BIT_DS		27
+
+/* Only allow the following bits to be modified by the guest 
+ * Some of these are also forced on by the hypervisor */
+#if (CPU==PPC85XX)
+#define CONTROL_MSR_MASK  (_PPC_MSR_CE | _PPC_MSR_SPE | _PPC_MSR_EE |\
+			   _PPC_MSR_PR | _PPC_MSR_ME | _PPC_MSR_DE |\
+			   _PPC_MSR_IS | _PPC_MSR_DS | _PPC_MSR_RI)
+#endif
+
+#define _PPC_MSR_MMU_EXTRACT(src, dst) \
+	rlwinm	dst, src, 0, _PPC_MSR_BIT_IS, _PPC_MSR_BIT_DS
+
+/* INT_MASK definition (mask EE & CE bits) : overwrite the one in asmPpc.h */
+
+#undef  INT_MASK
+#define INT_MASK(src, des) \
+	rlwinm  des, src, 0, _PPC_MSR_BIT_EE+1, _PPC_MSR_BIT_EE-1; \
+	rlwinm  des, des, 0, _PPC_MSR_BIT_CE+1, _PPC_MSR_BIT_CE-1
+
+
+#define HID0  1008
+#if (CPU != PPCE500MC)
+#define HID1  1009
+#endif
+
+#define DECAR 54
+#define BUCSR 1013
+
+#define _PPC_BUCSR_FI 0x200            /* Invalidate branch cache */
+#define _PPC_BUCSR_E 0x1               /* Enable branch prediction */
+
+/* E500core other than e500mc has no FPU */
+
+#if (CPU==PPCE500MC)
+#define _WRS_HARDWARE_FP
+#endif
+
+#ifndef _WRS_HARDWARE_FP
+#undef  _PPC_MSR_FP             /* floating point not available */
+#undef  _PPC_MSR_FE1            /* floating point not available */
+#undef  _PPC_MSR_FE0            /* floating point not available */
+#undef  _PPC_MSR_BIT_FP         /* MSR Floating Point Aval. bit - FP */
+#undef  _PPC_MSR_BIT_FE0        /* MSR FP exception mode 0 bit - FE0 */
+#undef  _PPC_MSR_BIT_FE1        /* MSR FP exception mode 1 bit - FE1 */
+#undef  _EXC_PROG_SRR1_FPU      /* floating point not available */
+#else	/* _WRS_HARDWARE_FP */
+#define _WRS_FP_CLASS_HW	1
+#define  _PPC_MSR_BIT_FP         18
+#define  _PPC_MSR_BIT_FE0        20
+#define  _PPC_MSR_BIT_FE1        23
+#endif	/* _WRS_HARDWARE_FP */
+
+
+
+/*
+ * Exception syndrome register mask bits:
+ * 0 - error not occured 1 - error occured
+ */
+
+#define _PPC_ESR_PIL_U 0x0800      /* Pgm Interrupt -- Illegal Insn */
+#define _PPC_ESR_PPR_U 0x0400      /* Pgm Interrupt -- Previleged Insn */
+#define _PPC_ESR_PTR_U 0x0200      /* Pgm Interrupt -- Trap */
+#if (CPU == PPCE500MC)
+#define _PPC_ESR_FP_U  0x0100      /* Floating Point Operation */
+#endif /* (CPU == PPCE500MC) */
+#define _PPC_ESR_ST_U  0x0080      /* Store Operation */
+#define _PPC_ESR_DLK_U 0x0020      /* Data Locked -- DSI occured */
+#define _PPC_ESR_ILK_U 0x0010      /* Inst Locked -- DSI occured */
+#define _PPC_ESR_AP_U  0x0008      /* AP Operation */
+#define _PPC_ESR_BO_U  0x0002      /* Byte Ordering Exception */
+#define _PPC_ESR_PIL   0x08000000  /* Pgm Interrupt -- Illegal Insn */
+#define _PPC_ESR_PPR   0x04000000  /* Pgm Interrupt -- Previleged Insn */
+#define _PPC_ESR_PTR   0x02000000  /* Pgm Interrupt -- Trap */
+#if (CPU == PPCE500MC)
+#define _PPC_ESR_FP    0x01000000  /* Floating Point Operation */
+#endif /* (CPU == PPCE500MC) */
+#define _PPC_ESR_ST    0x00800000  /* Store Operation */
+#define _PPC_ESR_DLK   0x00200000  /* Data Storage Interrupt -- Locking */
+#define _PPC_ESR_ILK   0x00100000  /* Inst Locked -- DSI occured */
+#define _PPC_ESR_AP    0x00080000  /* AP Operation */
+#define _PPC_ESR_BO    0x00020000  /* Byte Ordering Exception */
+#define _PPC_ESR_SPE   0x00000080  /* SPE exception */
+#define _PPC_ESR_EPID  0x00000040 /* External PID Access */
+#define _PPC_ESR_VLEMI 0x00000020 /* VLE instruction */
+#define _PPC_ESR_MIF   0x00000002 /* Misaligned Insn Fetch (ITLB, ISI) */
+#define _PPC_ESR_XTE   0x00000001 /* External Transaction Err (ISI, DSI) */
+
+
+#define   _PPC_EPCR_EXTGS      0x80000000 /* Guest gets external ints */
+#define   _PPC_EPCR_DTLBGS     0x40000000 /* Guest gets DTLB errors */
+#define   _PPC_EPCR_ITLBGS     0x20000000 /* Guest gets ITLB errors */
+#define   _PPC_EPCR_DSIGS      0x10000000 /* Guest gets DSIs */
+#define   _PPC_EPCR_ISIGS      0x08000000 /* Guest gets ISIs */
+#define   _PPC_EPCR_DUVD       0x04000000 /* Disable Embedded HV Debug */
+#define   _PPC_EPCR_DGTMI      0x00800000 /* Disable guest TLB management insns*/
+#define   _PPC_EPCR_DMIUH      0x00400000 /* Disable MAS int updates for hypervisor*/
+
+/* Bits in the upper half of TCR */
+
+#define _PPC_TCR_WP_U     0xc000  /* Watchdog Timer Period */
+#define _PPC_TCR_WRC_U    0x3000  /* Watchdog Timer Reset Control */
+#define _PPC_TCR_WIE_U    0x0800  /* Watchdog Timer Interrupt Enable */
+#define _PPC_TCR_DIE_U    0x0400  /* Decrementer Interrupt Enable */
+#define _PPC_TCR_FP_U     0x0300  /* Fixed Interval Timer Period */
+#define _PPC_TCR_FIE_U    0x0080  /* Fixed Interval Timer Interrupt Enable */
+#define _PPC_TCR_ARE_U    0x0040  /* Decrementer Auto-Reload Enable */
+#define _PPC_TCR_WPEXT_U  0x0040  /* Decrementer Auto-Reload Enable */
+#define _PPC_TCR_FPEXT_U  0x0040  /* Decrementer Auto-Reload Enable */
+
+/* Bits in the upper half of TSR */
+
+#define _PPC_TSR_ENW_U  0x8000  /* Enable Next Watchdog Timer Exception */
+#define _PPC_TSR_WIS_U  0x4000  /* Watchdog Timer Interrupt Status */
+#define _PPC_TSR_WRS_U  0x3000  /* Watchdog Timer Reset Status */
+#define _PPC_TSR_DIS_U  0x0800  /* Decrementer Interrupt Status */
+#define _PPC_TSR_FIS_U  0x0400  /* Fixed Interval Timer Interrupt Status */
+
+/* versions of the aligned for 32-bit TCR/TSR register access */
+
+#define _PPC_TCR_DIE (_PPC_TCR_DIE_U << 16)
+#define _PPC_TSR_DIS (_PPC_TSR_DIS_U << 16)
+
+/* hardware dependent register 0 */
+
+#define _PPC_HID0_DOZE  0x00800000      /* DOZE power management mode */
+#define _PPC_HID0_NAP   0x00400000      /* NAP power management mode */
+#define _PPC_HID0_SLEEP 0x00200000      /* SLEEP power management mode */
+#define _PPC_HID0_TBEN	0x00004000	/* time base enable */
+#define _PPC_HID0_MAS7EN  0x00000080    /* Enable use of MAS7 for tlbre */
+#define _PPC_HID0_DCFA    0x00000040    /* Use this bit to flush only valid entries same as 74XX */
+#define _PPC_HID0_BIT_MAS7EN   24
+#define _PPC_HID0_BIT_DCFA     25
+#define _PPC_85XX_USE_DCFA
+
+/* hardware dependent register 1 */
+
+#define _PPC_HID1_ABE   0x00001000      /* Address broadcast enable */
+
+/* Cache Defines */ 
+
+/* Instruction and Data Cache bit fields are the same */
+
+#ifndef PPC_e200
+#define _PPC_L1CSR_E   0x00000001 /* Enable */
+#define _PPC_L1CSR_FI  0x00000002 /* Flash Invalidate */
+#define _PPC_L1CSR_FLR 0x00000100 /* Lock Bits Flash */
+#define _PPC_L1CSR_LO  0x00000200 /* Lock Overflow */
+#define _PPC_L1CSR_UL  0x00000400 /* Unable to lock   - status bit */
+#define _PPC_L1CSR_UL_V(x)  (x >> 10)
+#define _PPC_L1CSR_SLC 0x00000800 /* Snoop lock clear  - status bit */
+#define _PPC_L1CSR_SLC_V(x) (x >> 11)
+#define _PPC_L1CSR_PIE 0x00008000 /* Parity Injection Enable */
+#define _PPC_L1CSR_CPE 0x00010000 /* Parity Enable */
+
+/* Instruction and Data Cache bit fields are the same */
+
+#define _PPC_L1CFG_SIZE_MASK   0x00000FFF
+#define _PPC_L1CFG_NWAY_MASK   0x000FF000
+#define _PPC_L1CFG_NWAY_V(x)   (x >> 12)
+#define _PPC_L1CFG_PA_MASK     0x00100000
+#define _PPC_L1CFG_PA_V(x)     (x >> 16)
+#define _PPC_L1CFG_LA_MASK     0x00200000
+#define _PPC_L1CFG_LA_V(x)     (x >> 17)
+#define _PPC_L1CFG_REPL_MASK   0x00400000
+#define _PPC_L1CFG_REPL_V(x)   (x >> 18)
+#define _PPC_L1CFG_BSIZE_MASK  0x01800000
+#define _PPC_L1CFG_BSIZE_V(x)  (x >> 19)
+#define _PPC_L1CFG_CARCH_MASK  0xC0000000    /* L1CFG0 only */
+#define _PPC_L1CFG_CARCH_V(x)  (x >> 30)
+
+#else /* PPC_e200 */
+
+#define _PPC_L1CSR_WID_MSK 0xf0000000
+#define _PPC_L1CSR_WID_SHFT 28
+#define _PPC_L1CSR_WDD_MSK 0x0f000000
+#define _PPC_L1CSR_WDD_SHFT 24
+#define _PPC_L1CSR_WID_SET(x)  ((x<<_PPC_L1CSR_WID_SHFT) & _PPC_L1CSR_WID_MSK)
+#define _PPC_L1CSR_WDD_SET(x)  ((x<<_PPC_L1CSR_WDD_SHFT) & _PPC_L1CSR_WDD_MSK)
+#define _PPC_L1CSR_WID_GET(x)  ((x & _PPC_L1CSR_WID_MSK)>>_PPC_L1CSR_WID_SHFT)
+#define _PPC_L1CSR_WDD_GET(x)  ((x & _PPC_L1CSR_WDD_MSK)>>_PPC_L1CSR_WDD_SHFT)
+
+#define _PPC_L1CSR_AWID   0x00800000
+#define _PPC_L1CSR_AWDD   0x00400000
+#define _PPC_L1CSR_CWM    0x00100000
+#define _PPC_L1CSR_DPB    0x00080000
+#define _PPC_L1CSR_DSB    0x00040000
+#define _PPC_L1CSR_DSTRM  0x00020000
+#define _PPC_L1CSR_CPE    0x00010000
+#define _PPC_L1CSR_CUL    0x00000800
+#define _PPC_L1CSR_CLO    0x00000400
+#define _PPC_L1CSR_CLFC   0x00000200
+#define _PPC_L1CSR_CABT   0x00000004
+#define _PPC_L1CSR_CINV   0x00000002
+#define _PPC_L1CSR_CE     0x00000001
+
+#define _PPC_L1CFG_SIZE_MASK   0x000007FF
+#define _PPC_L1CFG_NWAY_MASK   0x007FF100
+#define _PPC_L1CFG_NWAY_V(x)   (x >> 11)
+#define _PPC_L1CFG_PA_MASK     0x00080000
+#define _PPC_L1CFG_PA_V(x)     (x >> 19)
+#define _PPC_L1CFG_LA_MASK     0x00100000
+#define _PPC_L1CFG_LA_V(x)     (x >> 20)
+#define _PPC_L1CFG_REPL_MASK   0x00600000
+#define _PPC_L1CFG_REPL_V(x)   (x >> 21)
+#define _PPC_L1CFG_BSIZE_MASK  0x01800000
+#define _PPC_L1CFG_BSIZE_V(x)  (x >> 23)
+#define _PPC_L1CFG_CFISWA_MASK 0x08000000  
+#define _PPC_L1CFG_CFAHA_MASK  0x10000000
+#define _PPC_L1CFG_CWPA_MASK   0x20000000
+#define _PPC_L1CFG_CARCH_MASK  0xC0000000  
+#define _PPC_L1CFG_CARCH_V(x)  (x >> 30)
+
+#define _PPC_L1FINV0_CWAY_MSK  0x07000000
+#define _PPC_L1FINV0_CWAY_SET(x) ((x << 24) & _PPC_L1FINV0_CWAY_MSK)
+#define _PPC_L1FINV0_CSET_MSK  0x00000FC0
+#define _PPC_L1FINV0_CSET_SET(x) ((x << 6) & _PPC_L1FINV0_CSET_MSK)
+#define _PPC_L1FINV0_CCMD_MSK  0x00000003
+#define _PPC_L1FINV0_CCMD_SET(x) (x & _PPC_L1FINV0_CCMD_MSK)
+
+#ifndef _ASMLANGUAGE
+typedef union e200_l1cfg0
+    {
+    UINT32 l1Cfg0;
+    struct 
+	{
+	uint32_t carch:2;
+	uint32_t cwpa:1;
+	uint32_t cfaha:1;
+	uint32_t cfiswa:1;
+	uint32_t :2;
+	uint32_t cbsize:2;
+	uint32_t crepl:2;
+	uint32_t cla:1;
+	uint32_t cpa:1;
+	uint32_t cnway:8;
+	uint32_t csize:11;
+	} field;
+    } E200_L1CFG0;
+#endif /* _ASMLANGUAGE */
+
+#endif /* PPC_e200 */
+
+/* MMU register defines */
+				 
+#define PID     48
+#define PID_MASK 0x0FF
+#define PID0    48
+#if (CPU != PPCE500MC)
+#define PID1    633
+#define PID2    634
+#endif /* (CPU != PPCE500MC) */
+
+
+
+#define _PPC_MMUCSR0_L2TLB1_FI  0x00000002
+#define _PPC_MMUCSR0_L2TLB1_FI_V(x) (x >> 1)
+#define _PPC_MMUCSR0_L2TLB0_FI  0x00000004
+#define _PPC_MMUCSR0_L2TLB0_FI_V(x) (x >> 2)
+#define _PPC_MMUCSR0_DL1MMU_FI  0x00000008
+#define _PPC_MMUCSR0_DL1MMU_FI_V(x) (x >> 3)
+#define _PPC_MMUCSR0_IL1MMU_FI  0x00000010
+#define _PPC_MMUCSR0_IL1MMU_FI_V(x) (x >> 4)
+
+#if (CPU==PPCE500MC)
+#define _PPC_MMUCSR0_DYN_INVAL  (_PPC_MMUCSR0_L2TLB0_FI)
+#else
+#define _PPC_MMUCSR0_DYN_INVAL  (_PPC_MMUCSR0_DL1MMU_FI | \
+			       _PPC_MMUCSR0_IL1MMU_FI | \
+			       _PPC_MMUCSR0_L2TLB0_FI)
+#endif
+
+/* Standard PTE registers */
+#define _PPC_MAS0_NV           0x00000000
+#define _PPC_MAS0_ESEL_MASK    0x03ff0000
+#define _PPC_MAS0_ESEL_BIT     16
+#define _PPC_MAS0_ESEL_V(x)    (x >> _PPC_MAS0_ESEL_BIT)
+#define _PPC_MAS0_TLBSEL1      0x10000000
+#define _PPC_MAS0_TLBSEL_MASK  0x30000000
+
+/* Standard PTE registers */
+#define _PPC_MAS1_V            0x80000000
+#define _PPC_MAS1_IPROT        0x40000000
+#define _PPC_MAS1_TID_MASK     0x00ff0000
+#define _PPC_MAS1_TS           0x00001000
+#define _PPC_MAS1_TSIZE_MASK   0x00000f00
+
+/* Standard PTE registers */
+#define _PPC_MAS2_EPN_MASK     0xFFFFF000
+#define _PPC_MAS2_X0           0x00000040
+#define _PPC_MAS2_X1           0x00000020
+#define _PPC_MAS2_W            0x00000010
+#define _PPC_MAS2_I            0x00000008
+#define _PPC_MAS2_M            0x00000004
+#define _PPC_MAS2_G            0x00000002
+#define _PPC_MAS2_E            0x00000001
+
+/* Standard PTE registers */
+#define _PPC_MAS3_RPN_MASK     0xFFFFF000
+#define _PPC_MAS3_U0_U3_MASK   0x000003C0
+#define _PPC_MAS3_UX           0x00000020
+#define _PPC_MAS3_SX           0x00000010
+#define _PPC_MAS3_UW           0x00000008
+#define _PPC_MAS3_SW           0x00000004
+#define _PPC_MAS3_UR           0x00000002
+#define _PPC_MAS3_SR           0x00000001
+
+/* Default value register for MAS0-3 */
+#define _PPC_MAS4_TLBSELD      0x10000000
+#define _PPC_MAS4_TSIZED       0x00000F00
+#define _PPC_MAS4_X0D          0x00000040
+#define _PPC_MAS4_X1D          0x00000020
+#define _PPC_MAS4_WD           0x00000010
+#define _PPC_MAS4_ID           0x00000008
+#define _PPC_MAS4_MD           0x00000004
+#define _PPC_MAS4_GD           0x00000002
+#define _PPC_MAS4_ED           0x00000001
+
+/* used in tlbsx */
+#define _PPC_MAS5_SGS          0x80000000
+#define _PPC_MAS5_SLPID_MASK   0x000000FF
+
+/* used in tlbsx */
+#define _PPC_MAS6_SPID_MASK    0x00FF0000
+#define _PPC_MAS6_SAS          0x00000001
+
+/* e500v2/e500mc */
+#define _PPC_MAS7_ERPN_MASK    0x0000000F
+
+/* Possible Extension to PTE - probably just program based LPI info */
+#define _PPC_MAS8_TGS          0x80000000
+#define _PPC_MAS8_VF           0x40000000
+#define _PPC_MAS8_TLPID_MASK   0x000000FF
+
+/* Range of hardware context numbers (PID register & TLB TID field) */
+
+#define MMU_ASID_MIN            1
+#define MMU_ASID_MAX            255
+#define MMU_ASID_GLOBAL         MMU_ASID_MIN
+
+/* debug control register 0 */
+
+#define _DBCR0_IDM_U    0x4000          /* internal debug mode */
+#define _DBCR0_RST_U    0x3000          /* reset */
+#define _DBCR0_ICMP_U   0x0800          /* instruction completion debug event */
+#define _DBCR0_BRT_U    0x0400          /* branch taken debug event */
+#define _DBCR0_IRPT_U   0x0200          /* interrupt debug event */
+#define _DBCR0_TRAP_U   0x0100          /* trap debug event */
+#define _DBCR0_IAC1_U   0x0080          /* instruction address compare 1 */
+#define _DBCR0_IAC2_U   0x0040          /* instruction address compare 2 */
+#define _DBCR0_DAC1R_U  0x0008          /* data address compare 1 Read */
+#define _DBCR0_DAC1W_U  0x0004          /* data address compare 1 Write */
+#define _DBCR0_DAC2R_U  0x0002          /* data address compare 2 Read */
+#define _DBCR0_DAC2W_U  0x0001          /* data address compare 2 Write */
+#define _DBCR0_IDM      0x40000000      /* internal debug mode */
+#define _DBCR0_RST      0x30000000      /* reset */
+#define _DBCR0_ICMP     0x08000000      /* instruction completion debug event */
+#define _DBCR0_BRT      0x04000000      /* branch taken */
+#define _DBCR0_IRPT     0x02000000      /* exception debug event */
+#define _DBCR0_TRAP     0x01000000      /* trap debug event */
+#define _DBCR0_IAC1     0x00800000      /* instruction address compare 1 */
+#define _DBCR0_IAC2     0x00400000      /* instruction address compare 2 */
+#define _DBCR0_DAC1R    0x00080000      /* data address compare 1 Read */
+#define _DBCR0_DAC1W    0x00040000      /* data address compare 1 Write */
+#define _DBCR0_DAC2R    0x00020000      /* data address compare 2 Read */
+#define _DBCR0_DAC2W    0x00010000      /* data address compare 2 Write */
+#define _DBCR0_RET      0x00008000      /* return debug event */
+#define _DBCR0_FT       0x00000001      /* freeze timers on debug */
+
+/* debug control register 1 */
+
+#define _DBCR1_IAC1US_U   0xc000        /* IAC 1 User/Supervisor */
+#define _DBCR1_IAC1ER_U   0x3000        /* IAC 1 Effective/Real */
+#define _DBCR1_IAC2US_U   0x0c00        /* IAC 2 User/Supervisor */
+#define _DBCR1_IAC2ER_U   0x0300        /* IAC 2 Effective/Real */
+#define _DBCR1_IAC12M_U   0x00c0        /* IAC 1/2 Mode */
+#define _DBCR1_IAC12AT_U  0x0001        /* IAC 1/2 Auto-Toggle Enable */
+#define _DBCR1_IAC1US     0xc0000000    /* IAC 1 User/Supervisor */
+#define _DBCR1_IAC1ER     0x30000000    /* IAC 1 Effective/Real */
+#define _DBCR1_IAC2US     0x0c000000    /* IAC 2 User/Supervisor */
+#define _DBCR1_IAC2ER     0x03000000    /* IAC 2 Effective/Real */
+#define _DBCR1_IAC12M     0x00c00000    /* IAC 1/2 Mode */
+
+/* debug control register 2 */
+
+#define _DBCR2_DAC1US_U   0xc000        /* DAC 1 User/Supervisor */
+#define _DBCR2_DAC1ER_U   0x3000        /* DAC 1 Effective/Real */
+#define _DBCR2_DAC2US_U   0x0c00        /* DAC 2 User/Supervisor */
+#define _DBCR2_DAC2ER_U   0x0300        /* DAC 2 Effective/Real */
+#define _DBCR2_DAC12M_U   0x00c0        /* DAC 1/2 Mode */
+#define _DBCR2_DAC1US     0xc0000000    /* DAC 1 User/Supervisor */
+#define _DBCR2_DAC1ER     0x30000000    /* DAC 1 Effective/Real */
+#define _DBCR2_DAC2US     0x0c000000    /* DAC 2 User/Supervisor */
+#define _DBCR2_DAC2ER     0x03000000    /* DAC 2 Effective/Real */
+#define _DBCR2_DAC12M     0x00c00000    /* DAC 1/2 Mode */
+
+/* debug status register */
+
+#define _DBSR_IDE_U     0x8000          /* Imprecise Debug Event */
+#define _DBSR_UDE_U     0x4000          /* Unconditional Debug Event */
+#define _DBSR_MRR_U     0x3000          /* Most Recent Reset */
+#define _DBSR_ICMP_U    0x0800          /* Instruction Completion Debug Event */
+#define _DBSR_BRT_U     0x0400          /* Branch Taken Debug Event */
+#define _DBSR_IRPT_U    0x0200          /* Interrupt Debug Event */
+#define _DBSR_TRAP_U    0x0100          /* Trap Debug Event */
+#define _DBSR_IAC1_U    0x0080          /* IAC 1 Debug Event */
+#define _DBSR_IAC2_U    0x0040          /* IAC 2 Debug Event */
+#define _DBSR_DAC1R_U   0x0008          /* DAC/DVC 1 Read Debug Event */
+#define _DBSR_DAC1W_U   0x0004          /* DAC/DVC 1 Write Debug Event */
+#define _DBSR_DAC2R_U   0x0002          /* DAC/DVC 2 Read Debug Event */
+#define _DBSR_DAC2W_U   0x0001          /* DAC/DVC 2 Write Debug Event */
+#define _DBSR_IDE       0x80000000      /* Imprecise Debug Event */
+#define _DBSR_UDE       0x40000000      /* Unconditional Debug Event */
+#define _DBSR_MRR       0x30000000      /* Most Recent Reset */
+#define _DBSR_ICMP      0x08000000      /* Instruction Completion Debug Event */
+#define _DBSR_BRT       0x04000000      /* Branch Taken Debug Event */
+#define _DBSR_IRPT      0x02000000      /* Interrupt Debug Event */
+#define _DBSR_TRAP      0x01000000      /* Trap Debug Event */
+#define _DBSR_IAC1      0x00800000      /* IAC 1 Debug Event */
+#define _DBSR_IAC2      0x00400000      /* IAC 2 Debug Event */
+#define _DBSR_DAC1R     0x00080000      /* DAC/DVC 1 Read Debug Event */
+#define _DBSR_DAC1W     0x00040000      /* DAC/DVC 1 Write Debug Event */
+#define _DBSR_DAC2R     0x00020000      /* DAC/DVC 2 Read Debug Event */
+#define _DBSR_DAC2W     0x00010000      /* DAC/DVC 2 Write Debug Event */
+#define _DBSR_RET       0x00008000      /* Return Debug Event */
+
+/* mask for hardware breakpoints */
+
+#define _DBSR_HWBP_MSK  ( _DBSR_IAC1 | _DBSR_IAC2 | \
+                          _DBSR_DAC1R | _DBSR_DAC1W | \
+                          _DBSR_DAC2R | _DBSR_DAC2W )
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCppc85xxh */
diff --git a/include/vbi/support/sys/ppc/regs.h b/include/vbi/support/sys/ppc/regs.h
new file mode 100644
index 0000000..7f5abe7
--- /dev/null
+++ b/include/vbi/support/sys/ppc/regs.h
@@ -0,0 +1,69 @@
+/* sys/ppc/regs.h - PowerPC cpu registers */
+
+/*
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute or otherwise make use of this software
+ * may be licensed only pursuant to the terms of an applicable Wind River
+ * license agreement. 
+ */
+
+/*
+modification history
+--------------------
+01d,31aug09,mmi  mv VBI_HREG_SET to vbiPpcArch.h
+01c,15jul09,dtr  Add PPCE500MC CPU.
+01b,30jul09,mpk  add VBI_HREG_SET for supporting register read, write
+01a,03oct07,md   written based on VxWorks 01l version
+*/
+
+#ifndef __INCppcRegsh
+#define __INCppcRegsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GREG_NUM	32	/* has 32 32/64-bit data registers */
+#define	_PPC_HREG_SIZE	4	/* only support 32-bit registers */
+
+#ifndef	_ASMLANGUAGE
+
+/* some common names for registers */
+
+#define spReg	gpr[1]	/* stack pointer */
+#define	fpReg	gpr[31]	/* frame pointer */
+#define reg_pc	pc	/* program counter */
+#define reg_sp	spReg	/* stack pointer */
+#define reg_fp	fpReg	/* frame pointer */
+
+#endif	/* _ASMLANGUAGE */
+
+
+#define HREG_SET_GRBASE	0x00	/* general purpose register base */
+#define HREG_SET_GR(n)		(HREG_SET_GRBASE + _PPC_HREG_SIZE*(n))
+#define HREG_SET_MSR		(HREG_SET_GR(GREG_NUM))
+#define HREG_SET_LR		(HREG_SET_MSR + _PPC_HREG_SIZE)
+#define HREG_SET_CTR		(HREG_SET_LR + _PPC_HREG_SIZE)
+#define HREG_SET_PC		(HREG_SET_CTR + _PPC_HREG_SIZE)
+#define HREG_SET_CR		(HREG_SET_PC + _PPC_HREG_SIZE)
+#define HREG_SET_XER		(HREG_SET_CR + 4)
+#define HREG_SET_SPEFSCR	(HREG_SET_XER + 4)
+#define HREG_SET_CASID		(HREG_SET_SPEFSCR + 4)
+#define HREG_SET_SP		(HREG_SET_GR(1))
+
+/* size of the full REG_SET structure, including spare bytes */
+
+#define _PPC_HREG_SET_SIZE       (_PPC_HREG_SIZE * (GREG_NUM + 7))
+
+/* include any cpu specific register declarations */
+
+#if (CPU == PPC85XX) || (CPU == PPCE500MC)
+# include <sys/ppc/ppc85xx.h>
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCppcRegsh */
-- 
1.6.5.rc1

