From 973b84d01b3b7b93262793f6b9700f3436e6985e Mon Sep 17 00:00:00 2001
From: Liang Li <liang.li@windriver.com>
Date: Fri, 6 Nov 2009 12:17:34 +0800
Subject: [PATCH] x86: rearrange HRT code

Rearrange HRT code then it is safe to add CONFIG_WRHV_X86_HRTIMERS=y
as default kernel configure option. We just need to use different
XML file to make HRT enabled or not.

Signed-off-by: Liang Li <liang.li@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c |  115 +++++++++++++++++++++++++-------------------
 include/asm-x86/wrhv.h     |    1 +
 2 files changed, 66 insertions(+), 50 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index ab2b2f1..12483cf 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -66,6 +66,7 @@ static cpumask_t flush_cpumask;
 static struct mm_struct *flush_mm;
 static unsigned long flush_va;
 static DEFINE_SPINLOCK(tlbstate_lock);
+static int enable_hrtimer = 0;
 
 #define VBI_VTLB_OPTIM_OPTION (\
 			 VBI_VTLB_OPTIM_ENABLED |  \
@@ -88,6 +89,7 @@ static void wrhv_pre_intr_init_hook(void)
 	}
 }
 
+void wrhv_setup_timer_irq(void);
 void __init wrhv_init_IRQ(void)
 {
 	int i;
@@ -129,11 +131,7 @@ void __init wrhv_init_IRQ(void)
 
 	irq_ctx_init(smp_processor_id());
 
-	/* race during reboot might have left a timer interrupt
-	 * pending and unacked */
-	/*
-	irq_desc[0].chip->ack(0);
-	*/
+	wrhv_setup_timer_irq();
 }
 
 static void wrhv_init_timer(enum clock_event_mode mode,
@@ -154,14 +152,16 @@ static void wrhv_timer_broadcast(cpumask_t mask)
 }
 
 struct clock_event_device wrhv_clock_event = {
-	.name		= "wrhv",
-	.features	= CLOCK_EVT_FEAT_PERIODIC,
-	.set_mode	= wrhv_init_timer,
+	.name           = "wrhv",
+	.features       = CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode       = wrhv_init_timer,
 	.set_next_event = wrhv_set_next_event,
-	.broadcast	= wrhv_timer_broadcast,
-	.shift		= 32,
-	.mult		= 1,
-	.irq		= 0,
+	.broadcast      = wrhv_timer_broadcast,
+	.max_delta_ns   = 0xffffffff,
+	.min_delta_ns   = 10000,
+	.shift          = 32,
+	.mult           = 1,
+	.irq            = 0,
 };
 
 DEFINE_PER_CPU(struct clock_event_device, wrhv_clock_events);
@@ -212,19 +212,21 @@ void __devinit wrhv_setup_boot_clock(void)
 	int ret;
 	struct clock_event_device *evt;
 
-	wrhv_mask_timer_for_vcore();
-	evt = &per_cpu(wrhv_clock_events, 0);
-	memcpy(evt, &wrhv_clock_event, sizeof(*evt));
-	evt->cpumask = cpumask_of_cpu(0);
-	evt->features = CLOCK_EVT_FEAT_DUMMY | CLOCK_EVT_FEAT_ONESHOT;
-	evt->irq = DUMMY_TIMER_INT;
-	evt->rating = 1;
-	clockevents_register_device(evt);
-	wrhv_timer_irq.name = "dummy_ipi_timer";
-	wrhv_timer_irq.handler = wrhv_dummy_timer_interrupt;
-	ret = setup_irq(DUMMY_TIMER_INT, &wrhv_timer_irq);
-	if (ret)
-		printk(KERN_WARNING "setup dummy timer irq failed\n");
+	if (enable_hrtimer) {
+		wrhv_mask_timer_for_vcore();
+		evt = &per_cpu(wrhv_clock_events, 0);
+		memcpy(evt, &wrhv_clock_event, sizeof(*evt));
+		evt->cpumask = cpumask_of_cpu(0);
+		evt->features = CLOCK_EVT_FEAT_DUMMY | CLOCK_EVT_FEAT_ONESHOT;
+		evt->irq = DUMMY_TIMER_INT;
+		evt->rating = 1;
+		clockevents_register_device(evt);
+		wrhv_timer_irq.name = "dummy_ipi_timer";
+		wrhv_timer_irq.handler = wrhv_dummy_timer_interrupt;
+		ret = setup_irq(DUMMY_TIMER_INT, &wrhv_timer_irq);
+		if (ret)
+			printk(KERN_WARNING "setup dummy timer irq failed\n");
+	}
 #endif
 }
 
@@ -240,14 +242,15 @@ void __devinit wrhv_setup_secondary_clock(void)
 	evt->cpumask = cpumask_of_cpu(cpu);
 
 #ifdef CONFIG_WRHV_X86_HRTIMERS
-	evt->features = CLOCK_EVT_FEAT_DUMMY | CLOCK_EVT_FEAT_ONESHOT;
-	evt->irq = DUMMY_TIMER_INT;
-	evt->rating = 1;
+	if (enable_hrtimer) {
+		evt->features = CLOCK_EVT_FEAT_DUMMY | CLOCK_EVT_FEAT_ONESHOT;
+		evt->irq = DUMMY_TIMER_INT;
+		evt->rating = 1;
+	}
 #endif
 	clockevents_register_device(evt);
 }
 
-#ifndef CONFIG_WRHV_X86_HRTIMERS
 static void __init wrhv_time_init(void)
 {
 	struct clock_event_device *evt;
@@ -260,7 +263,6 @@ static void __init wrhv_time_init(void)
 	wrhv_timer_irq.mask = cpumask_of_cpu(0);
 	setup_irq(0, &wrhv_timer_irq);
 }
-#endif
 
 #ifdef CONFIG_PCI
 static int wrhv_pci_enable_irq(struct pci_dev *dev)
@@ -792,13 +794,14 @@ EXPORT_SYMBOL(wrhv_calibrate_smp_cpus);
 
 static void inline wrhv_umask_IPIs_for_vcore(void)
 {
-       /* unmask ipi interrupt for vcore */
-       vbiVioapicIntUnmask(WRHV_IPI_RESCHED);
-       vbiVioapicIntUnmask(WRHV_IPI_INV_TLB);
-       vbiVioapicIntUnmask(WRHV_IPI_FUNC_CALL);
-       vbiVioapicIntUnmask(WRHV_IPI_FUNC_CALL_SINGLE);
+	/* unmask ipi interrupt for vcore */
+	vbiVioapicIntUnmask(WRHV_IPI_RESCHED);
+	vbiVioapicIntUnmask(WRHV_IPI_INV_TLB);
+	vbiVioapicIntUnmask(WRHV_IPI_FUNC_CALL);
+	vbiVioapicIntUnmask(WRHV_IPI_FUNC_CALL_SINGLE);
 #ifdef CONFIG_WRHV_X86_HRTIMERS
-	vbiVioapicIntUnmask(DUMMY_TIMER_INT);
+	if (enable_hrtimer)
+		vbiVioapicIntUnmask(DUMMY_TIMER_INT);
 #endif
 }
 
@@ -872,8 +875,9 @@ void __init wrhv_smp_prepare_cpus(unsigned int max_cpus)
 			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
 
 #ifdef CONFIG_WRHV_X86_HRTIMERS
-	set_irq_chip_and_handler_name(DUMMY_TIMER_INT,
-			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
+	if (enable_hrtimer)
+		set_irq_chip_and_handler_name(DUMMY_TIMER_INT,
+				&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
 #endif
 
 	ret = request_irq(WRHV_IPI_RESCHED, wrhv_ipi_resched_handler,
@@ -1031,9 +1035,9 @@ static void __cpuinit wrhv_smp_start_cpu(void)
 
 	setup_secondary_clock();
 
-#ifndef CONFIG_WRHV_X86_HRTIMERS
-	wrhv_umask_timer_for_vcore();
-#endif
+	if (!enable_hrtimer)
+		wrhv_umask_timer_for_vcore();
+
 	wmb();
 
 	local_irq_enable();
@@ -1259,6 +1263,26 @@ void wrhv_restart(void)
 	while (1);
 }
 
+void __init wrhv_setup_timer_irq(void)
+{
+	int irq;
+	irq = vbiIntVecFind(HRTIMER_IRQ_NAME, 1);
+	if (irq == VBI_INVALID_IRQ) {
+		enable_hrtimer = 0;
+		pv_time_ops.time_init = wrhv_time_init;
+		pv_time_ops.get_tsc_khz = wrhv_calculate_cpu_khz;
+		printk(KERN_INFO "WRHV: HRTIMER is NOT present.\n");
+	} else {
+		enable_hrtimer = 1;
+		printk(KERN_INFO "WRHV: HRTIMER is present.\n");
+	}
+
+#ifdef CONFIG_X86_LOCAL_APIC
+	pv_apic_ops.setup_boot_clock = wrhv_setup_boot_clock;
+	pv_apic_ops.setup_secondary_clock = wrhv_setup_secondary_clock;
+#endif
+}
+
 void __init wrhv_init(void)
 {
 	pv_info.name = "wrhv";
@@ -1271,19 +1295,10 @@ void __init wrhv_init(void)
 	pv_cpu_ops.write_msr = wrhv_write_msr;
 	pv_cpu_ops.read_msr = wrhv_read_msr;
 
-#ifndef CONFIG_WRHV_X86_HRTIMERS
-	pv_time_ops.time_init = wrhv_time_init;
-	pv_time_ops.get_tsc_khz = wrhv_calculate_cpu_khz;
-#endif
-
 	pv_irq_ops.init_IRQ = wrhv_init_IRQ;
 	pv_cpu_ops.get_debugreg = wrhv_get_debugreg;
 	pv_cpu_ops.set_debugreg = wrhv_set_debugreg;
 
-#ifdef CONFIG_X86_LOCAL_APIC
-	pv_apic_ops.setup_boot_clock = wrhv_setup_boot_clock;
-	pv_apic_ops.setup_secondary_clock = wrhv_setup_secondary_clock;
-#endif
 	machine_ops.emergency_restart = wrhv_restart;
 
 #ifdef CONFIG_KGDB
diff --git a/include/asm-x86/wrhv.h b/include/asm-x86/wrhv.h
index 233eaac..5474179 100644
--- a/include/asm-x86/wrhv.h
+++ b/include/asm-x86/wrhv.h
@@ -37,6 +37,7 @@ DECLARE_PER_CPU(struct clock_event_device, wrhv_clock_events);
  * If external HW timers are used as system timer(Now it only happens when
  * hrtimer is enabled), we have to use other int number.
  **/  
+#define HRTIMER_IRQ_NAME "PIT_Timer"
 #define TIMER_INT_NUM 10
 
 #define DUMMY_TIMER_INT 12
-- 
1.6.5.2

