From 96e7357f3242572745f1831b7ca3f591bf1602ac Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Tue, 17 Nov 2009 17:47:01 -0800
Subject: [PATCH] x86: fix leave_mm() vtlb issue

When vtlb optim is on, leave_mm will block os flushing
related vtlb, and finally cause vltb unsync with guest
os page tables.Here delete corresponding vtlb when
leave_mm is issued.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/x86/kernel/tlb_32.c   |   11 +++++++++++
 arch/x86/kernel/vbi/wrhv.c |    9 +++------
 include/asm-x86/wrhv.h     |    2 ++
 3 files changed, 16 insertions(+), 6 deletions(-)

diff --git a/arch/x86/kernel/tlb_32.c b/arch/x86/kernel/tlb_32.c
index 592b9c0..08997b3 100644
--- a/arch/x86/kernel/tlb_32.c
+++ b/arch/x86/kernel/tlb_32.c
@@ -3,6 +3,11 @@
 #include <linux/interrupt.h>
 #include <trace/irq.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#include <asm/wrhv.h>
+#endif
+
 #include <asm/tlbflush.h>
 
 
@@ -38,6 +43,12 @@ void leave_mm(int cpu)
 {
 	if (per_cpu(cpu_tlbstate, cpu).state == TLBSTATE_OK)
 		BUG();
+
+#ifdef CONFIG_WRHV
+	wrhv_vtlb_op(VBI_VTLB_OP_DELETE_PMD,
+		     __pa(per_cpu(cpu_tlbstate, cpu).active_mm->pgd), 0, 0);
+#endif
+
 	cpu_clear(cpu, per_cpu(cpu_tlbstate, cpu).active_mm->cpu_vm_mask);
 	load_cr3(swapper_pg_dir);
 }
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 3ad542f..dac8372 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -76,8 +76,6 @@ static int enable_hrtimer = 0;
 
 #define VBI_VTLB_OPTIM_OPTION_NOOPT (VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED)
 
-static void wrhv_vtlb_op (unsigned int op, unsigned long arg1,
-				unsigned long arg2, unsigned long arg3);
 
 static void wrhv_pre_intr_init_hook(void)
 {
@@ -449,8 +447,6 @@ irqreturn_t wrhv_ipi_inv_tlb_handler(int irq, void *dev_id)
 			else
 				__flush_tlb_one(flush_va);
 		} else {
-			wrhv_vtlb_op(VBI_VTLB_OP_DELETE_PMD,
-					__pa(flush_mm->pgd), 0, 0);
 			leave_mm(cpu);
 		}
 	} else {
@@ -461,7 +457,7 @@ irqreturn_t wrhv_ipi_inv_tlb_handler(int irq, void *dev_id)
 	    else
 			wrhv_vtlb_op(VBI_VTLB_OP_UPDATE_PTE,
 					__pa(flush_mm->pgd),
-					(unsigned long)flush_mm, 0);
+					(unsigned long)flush_va, 0);
 
 	}
 
@@ -482,7 +478,8 @@ irqreturn_t wrhv_ipi_resched_handler(int irq, void *dev_id)
 }
 #endif
 
-static void wrhv_vtlb_op (unsigned int op, unsigned long arg1, unsigned long arg2, unsigned long arg3)
+void wrhv_vtlb_op(unsigned int op, unsigned long arg1,
+		  unsigned long arg2, unsigned long arg3)
 {
 	unsigned long flags;
 	int i;
diff --git a/include/asm-x86/wrhv.h b/include/asm-x86/wrhv.h
index 5474179..7895736 100644
--- a/include/asm-x86/wrhv.h
+++ b/include/asm-x86/wrhv.h
@@ -25,6 +25,8 @@
 extern void wrhv_init(void);
 extern void wrhv_boot_config(void);
 extern void wrhv_cpu_workarounds(struct cpuinfo_x86 *);
+extern void wrhv_vtlb_op(unsigned int, unsigned long,
+			 unsigned long, unsigned long);
 extern int wrhv_pci_bus_scan(void);
 extern int wrhv_pci_probeonly;
 
-- 
1.6.5.2

