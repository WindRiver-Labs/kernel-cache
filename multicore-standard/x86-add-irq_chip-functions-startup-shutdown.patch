From 6d855ebdc2a88e9b1ebb44e17fa54d0afdd32c8b Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 19 Oct 2009 10:21:47 +0800
Subject: [PATCH 1/4] x86: add irq_chip functions startup/shutdown

Since hypervisor provides each core an independent vioapic but
all ext ints are handled by BP, it causes uncertain status when
run default startup/shutdown on AP. So here implement these
functions which only operate cpu 0 vioapic.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Zwane Mwaikambo <Zwane Mwaikambo@windriver.com>
---
 arch/x86/kernel/wrhv.c |   54 ++++++++++++++++++++++++++++++++++++++++++++++++
 include/linux/smp.h    |    6 +++++
 kernel/smp.c           |    5 ----
 3 files changed, 60 insertions(+), 5 deletions(-)

diff --git a/arch/x86/kernel/wrhv.c b/arch/x86/kernel/wrhv.c
index 7a3fedf..344ff27 100644
--- a/arch/x86/kernel/wrhv.c
+++ b/arch/x86/kernel/wrhv.c
@@ -851,12 +851,66 @@ static void inline wrhv_umask_IPIs_for_vcore(void)
 #endif
 }
 
+static void x86_wrhv_mask_irq(void *irq)
+{
+	vbiVioapicIntMask((unsigned int)irq);
+}
+
+static void x86_wrhv_unmask_irq(void *irq)
+{
+	vbiVioapicIntUnmask((unsigned int)irq);
+}
+
+/* Currently all the external interrupts are routed to cpu 0 and
+ * handled by cpu0, so we need make sure the startup/shutdown functions
+ * operate cpu 0's vioapic.
+ */
+static void smp_wrhv_shutdown_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		x86_wrhv_mask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = x86_wrhv_mask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+}
+
+static unsigned int smp_wrhv_startup_irq(unsigned int irq)
+{
+	if (smp_processor_id() == 0)
+		x86_wrhv_unmask_irq((void *)irq);
+	else {
+		struct call_single_data *data;
+
+		data = kmalloc(sizeof(*data), GFP_ATOMIC);
+		if (!data)
+			return -ENOMEM;
+
+		data->flags = CSD_FLAG_ALLOC;
+		data->func = x86_wrhv_unmask_irq;
+		data->info = (void *)irq;
+		__smp_call_function_single(0, data);
+	}
+	return 0;
+}
+
 void __init wrhv_smp_prepare_cpus(unsigned int max_cpus)
 {
 	int ret;
 	native_smp_prepare_cpus(max_cpus);
 
 	wrhv_irq_chip.ack = NULL;
+	wrhv_irq_chip.startup = smp_wrhv_startup_irq;
+	wrhv_irq_chip.shutdown = smp_wrhv_shutdown_irq;
+
 	set_irq_chip_and_handler_name(WRHV_IPI_RESCHED,
 			&wrhv_irq_chip, handle_percpu_irq, "per_cpu");
 	set_irq_chip_and_handler_name(WRHV_IPI_INV_TLB,
diff --git a/include/linux/smp.h b/include/linux/smp.h
index 66484d4..fdebfdb 100644
--- a/include/linux/smp.h
+++ b/include/linux/smp.h
@@ -168,4 +168,10 @@ static inline void init_call_single_data(void)
 
 void smp_setup_processor_id(void);
 
+enum {
+	CSD_FLAG_WAIT		= 0x01,
+	CSD_FLAG_ALLOC		= 0x02,
+};
+
+
 #endif /* __LINUX_SMP_H */
diff --git a/kernel/smp.c b/kernel/smp.c
index f362a85..6c04381 100644
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -15,11 +15,6 @@ static DEFINE_PER_CPU(struct call_single_queue, call_single_queue);
 static LIST_HEAD(call_function_queue);
 __cacheline_aligned_in_smp DEFINE_SPINLOCK(call_function_lock);
 
-enum {
-	CSD_FLAG_WAIT		= 0x01,
-	CSD_FLAG_ALLOC		= 0x02,
-};
-
 struct call_function_data {
 	struct call_single_data csd;
 	spinlock_t lock;
-- 
1.6.3.3

