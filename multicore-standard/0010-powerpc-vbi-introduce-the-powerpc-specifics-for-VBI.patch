From d58ac8e68e8baf1d2d116be975219e96850940c9 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:07:08 -0400
Subject: [PATCH 10/24] powerpc vbi: introduce the powerpc specifics for VBI

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/powerpc/include/asm/vbiPpcArch.h |  691 ++++++++++++++
 arch/powerpc/kernel/vbiSyscalls.S     | 1626 +++++++++++++++++++++++++++++++++
 arch/powerpc/kernel/vbiUtil.c         |  144 +++
 3 files changed, 2461 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/include/asm/vbiPpcArch.h
 create mode 100644 arch/powerpc/kernel/vbiSyscalls.S
 create mode 100644 arch/powerpc/kernel/vbiUtil.c

diff --git a/arch/powerpc/include/asm/vbiPpcArch.h b/arch/powerpc/include/asm/vbiPpcArch.h
new file mode 100644
index 0000000..ac30c7d
--- /dev/null
+++ b/arch/powerpc/include/asm/vbiPpcArch.h
@@ -0,0 +1,691 @@
+/* vbiPpcArch.h - PowerPC architecture specific definitions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01m,07jul09,mmi  fix comment of int locking macro
+01l,22jun09,mmi  add assembly macros to read regs.
+01k,11jun09,mmi  add interrupts macros
+01j,10jun09,mmi  add assembly macro's for context switch and interrupts
+01i,08jun09,md   add define for maximum number of cores
+01h,08jun09,mmi  update descriptions
+01g,25may09,md   add byte order define
+01f,09feb09,mmi  add defines for vbi exception management
+01e,29jan09,dtr  debug.
+01d,29jan09,dtr  Remove some old defs.
+01c,28jan09,dtr  Use new structures.
+01b,23jan09,mmi  add debug registers
+01a,21jan09,mmi  created
+*/
+
+#ifndef __INCvbiPpcArchh
+#define __INCvbiPpcArchh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PPC uses big endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
+
+/* exceptions generated by the hypervisor */
+
+#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
+#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
+#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
+#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
+#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
+#define VBI_EXC_OFF_PROG	0x0700	/* program check */
+#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
+#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
+#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
+#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
+#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
+#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+/* exception defines */
+
+#define ARCH_MAX_INTERRUPT		    36
+#define VBI_ARCH_EXC_TABLE_SIZE		    36
+#define VBI_ARCH_IRQ_TABLE_SIZE		    256
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#define _WRHV_ARCH_HAS_STATUS_REGS	    1
+#define _WRHV_ARCH_HAS_CTRL_REGS	    1
+
+#define VB_STATUS_REGS_OFFSET_BASE	 0
+#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
+#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
+#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
+#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
+#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
+#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
+#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
+#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
+#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
+#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
+#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
+#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
+#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
+#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
+#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
+#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
+#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
+#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
+#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
+#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
+#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
+#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
+#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
+#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
+#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
+#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
+#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
+#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
+#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
+#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
+#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
+#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
+
+
+#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
+
+
+#define VB_CONTROL_REGS_OFFSET_BASE	 0
+#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
+#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
+#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
+#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
+#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
+#define VB_CONTROL_SP			VB_CONTROL_R1
+#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
+#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
+#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
+#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
+#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
+#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
+#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
+#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
+#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
+#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
+#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
+#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
+#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
+#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
+#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
+#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
+#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
+#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
+#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
+#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
+#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
+#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
+
+/* status register size for ppc */
+
+#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
+
+#ifndef _ASMLANGUAGE
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+	base->vbStatusRegs.field		
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+	base->vbControlRegs.field		
+
+/*******************************************************************************
+*
+* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
+*
+* Virtual board emulated control registers. These registers are used
+* by a guest running on hypervisor to configure the virtual CPU register.
+*
+* SYNOPSIS
+*
+* PPC Control structure graphical illustration
+*\cs
+*        _______________   
+*       |       PC      |   
+*       |---------------|
+*       |       MSR     |	    
+*       |---------------|
+*       |       CR      |
+*       |---------------|
+*       |		|
+*       |general purpose|
+*       |     r[0:13]   | 
+*       |		|
+*       |---------------|
+*       |emulated MSR   |
+*       |---------------|
+*       |       dbsr    |
+*       |---------------|
+*       | dbcr[0:2]     |
+*       |---------------|
+*       |IAC[1:2]       |
+*       |---------------|
+*       |DAC[1:2]       |
+*       |---------------|
+*       |reserved[0:9]  |
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's control C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
+*
+*    uint32_t srr0;	/@  0: PC		    @/
+*    uint32_t srr1;	/@  1: MSR		    @/
+*    uint32_t cr;	/@  2: condition registers	    @/
+*    uint32_t r0;	/@  3: General register R0	    @/
+*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;	/@  5: General register R2	    @/
+*    uint32_t r3;	/@  6: General register R3	    @/
+*    uint32_t r4;	/@  7: General register R4	    @/
+*    uint32_t r5;	/@  8: General register R5	    @/
+*    uint32_t r6;	/@  9: General register R6	    @/
+*    uint32_t r7;	/@ 10: General register R7	    @/
+*    uint32_t r8;	/@ 11: General register R8	    @/
+*    uint32_t r9;	/@ 12: General register R9	    @/
+*    uint32_t r10;	/@ 13: General register R10	    @/
+*    uint32_t r11;	/@ 14: General register R11	    @/
+*    uint32_t r12;	/@ 15: General register R12	    @/
+*    uint32_t r13;	/@ 16: General register R13	    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbsr; /@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2		    @/
+*
+*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
+*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
+*
+*    /@ data address compare registers DAC1-DAC2.	        @/
+*
+*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
+*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
+*
+*    /@ reserved fields for future use			    @/
+*
+*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*\COMMAND
+*/
+
+typedef struct vbArchControlRegs
+    {
+
+    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+
+    uint32_t srr0;		/*  0: PC */
+    uint32_t srr1;		/*  1: MSR */
+    uint32_t cr;		/*  2: condition registers */
+    uint32_t r0;		/*  3: General register R0 */
+    uint32_t sp;		/*  4: General register R1 (stack pointer) */
+    uint32_t r2;		/*  5: General register R2 */
+    uint32_t r3;		/*  6: General register R3 */
+    uint32_t r4;		/*  7: General register R4 */
+    uint32_t r5;		/*  8: General register R5 */
+    uint32_t r6;		/*  9: General register R6 */
+    uint32_t r7;		/* 10: General register R7 */
+    uint32_t r8;		/* 11: General register R8 */
+    uint32_t r9;		/* 12: General register R9 */
+    uint32_t r10;		/* 13: General register R10 */
+    uint32_t r11;		/* 14: General register R11 */
+    uint32_t r12;		/* 15: General register R12 */
+    uint32_t r13;		/* 16: General register R13 */
+
+    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;		/* 17: emulated MSR register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbsr; /* 18 - debug status register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbcr0; /* 19 - debug control register 0 */
+    uint32_t     dbcr1; /* 20 - debug control register 1 */
+    uint32_t     dbcr2; /* 21 - debug control register 2 */
+
+    /* instruction address compare registers IAC1-IAC2 */
+
+    uint32_t     iac1; /* 22 - instructions access control 1 */
+    uint32_t     iac2; /* 23 - instructions access control 2 */
+
+    /* data address compare registers DAC1-DAC2. */
+
+    uint32_t     dac1; /* 24 - instructions access control 3 */
+    uint32_t     dac2; /* 25 - instructions access control 4 */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved[10];      /* 26: Reserved */ 
+    } VB_ARCH_CONTROL_REGS;
+
+/*******************************************************************************
+*
+* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
+*
+* Virtual board emulated CPU status registers
+*
+* SYNOPSIS
+*
+* PPC Status structure graphical illustration
+*\cs
+*        _______________   ---------------------------
+*       |    SRR0       |   
+*       |---------------|
+*       |    SRR1       |   Registers save by WRHV	
+*       |---------------|   before injecting an exception/interrupt
+*       |    CR		|
+*       |---------------|
+*       |    LR		|
+*       |---------------|
+*       |    r3		| 
+*       |---------------|
+*       |    r4         |
+*       |---------------|   ---------------------------
+*	|    mcsrr0	|	
+*       |---------------|  Registers saved duing exception handling
+*       |    mcssr1     |
+*       |---------------|
+*       |    esr        |
+*       |---------------|
+*       |    mcsr       |
+*       |---------------|
+*       |    mcar       |
+*       |---------------|
+*       |    dear       |
+*       |---------------|
+*       |    emsr       |
+*       |---------------|
+*       |    esrr0      |
+*       |---------------|
+*       |    esrr1      |
+*       |---------------|    -------------------------
+*       | reserved[8]   |      8 x 32bits for future enhencements
+*       |---------------|    -------------------------
+*       |    svr        |
+*       |---------------|
+*       |    pir        |
+*       |---------------|
+*       |    pvr        |    Configuration registers updated
+*       |---------------|    upon board creation    
+*       |    hid0       |  
+*       |---------------|
+*       |    hid1       |
+*       |---------------|
+*       |    buscr      |
+*       |---------------|       
+*       |    l1csr0     |
+*       |---------------|
+*       |    l1csr1     |
+*       |---------------|   --------------------------
+*       | reserved[0:8] | 9x 32bit
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_ARCH_STATUS_REGS structure definition
+*
+* typedef struct archStatusRegs
+*    {
+*
+*    /@ 
+*     @ registers saved by WRHV for all interrupts exceptions
+*     @ before setting the PC in the virtual board to the exception/interrupt
+*     @ vector address
+*     @/
+*
+*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
+*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
+*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
+*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
+*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
+*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
+*
+*    /@ Registers saved by WRHV during exception processing only    @/
+*
+*    uint32_t mcsrr0; /@  6:			    @/
+*    uint32_t mcsrr1; /@  7:			    @/
+*    uint32_t esr;    /@  8:			    @/
+*    uint32_t mcsr;   /@  9:			    @/
+*    uint32_t mcar;   /@ 10			@/
+*    uint32_t dear;   /@ 11:			    @/
+*    uint32_t emsr;   /@ 12:			    @/
+*    uint32_t esrr0;  /@ 13:			    @/
+*    uint32_t esrr1;  /@ 14:			    @/
+*
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved1[8]; /@ 15 - 22			@/
+*
+*    /@ Configuration registers (only updated upon board creation   @/
+*
+*    uint32_t svr;     /@ 23			    @/     
+*    uint32_t pir;     /@ 24			    @/
+*    uint32_t pvr;     /@ 25			    @/  
+*    uint32_t hid0;    /@ 26			    @/
+*    uint32_t hid1;    /@ 27			    @/
+*    uint32_t bucsr;   /@ 28			    @/
+*    uint32_t l1csr0;  /@ 29			    @/
+*    uint32_t l1csr1;  /@ 30			    @/
+*    
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved2[9]; /@ 31 - 39			@/
+*
+*    } VB_ARCH_STATUS_REGS; 
+*
+*
+*\ce
+*
+* SEE ALSO: VB_STATUS 
+*\COMMAND
+*/
+
+typedef struct archStatusRegs
+    {
+
+    /* 
+     * registers saved by Razor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+
+    uint32_t srr0; /* 0: PC at time of the interrupt */
+    uint32_t srr1; /* 1: MSR at time of the interrupt */
+    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 3: Link register at time of the interrupt */
+    uint32_t r3;   /* 4: R3 at time of the interrupt */
+    uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+    /* Registers saved by Razor during exception processing only */
+
+    uint32_t mcsrr0; /*  6: */
+    uint32_t mcsrr1; /*  7: */
+    uint32_t esr;    /*  8: */
+    uint32_t mcsr;   /*  9: */
+    uint32_t mcar;   /* 10  */
+    uint32_t dear;   /* 11: */
+    uint32_t emsr;   /* 12: */
+    uint32_t esrr0;  /* 13: */
+    uint32_t esrr1;  /* 14: */
+
+/* 
+ * keep this part in a separate structure in order to keep the offsets
+ * to remain the same as in VB_STATUS
+ */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved1[8]; /* 15 - 22  */
+
+    /* Configuration registers (only updated upon board creation */
+
+    uint32_t svr;     /* 23 */     
+    uint32_t pir;     /* 24 */
+    uint32_t pvr;     /* 25 */  
+    uint32_t hid0;    /* 26 */
+    uint32_t hid1;    /* 27 */
+    uint32_t bucsr;   /* 28 */
+    uint32_t l1csr0;  /* 29 */
+    uint32_t l1csr1;  /* 30 */
+    
+    /* reserved fields for future use */
+
+    uint32_t reserved2[9]; /* 31 - 39 */
+
+    } VB_ARCH_STATUS_REGS; 
+
+#else /*_ASMLANGUAGE */
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+#define VBI_CTX_LOAD(reg)				    \
+	lis	reg, HI(VBI_SYS_ctx_load);		    \
+	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
+	sc
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
+	li	reg1, -1;				\
+        lis     reg2, HIADJ(wrhvVbControl);		\
+        lwz     reg2, LO(wrhvVbControl)(reg2);		\
+        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
+        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+checkIntVcorePending:						\
+	lis	reg0, HIADJ(wrhvVbStatus);			\
+	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
+	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
+								\
+	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
+	beq     endIntVcoreLock;				\
+	lis	r0, HI(VBI_SYS_int_enable);			\
+	ori	r0, r0, LO(VBI_SYS_int_enable);			\
+	sc;							\
+	b	checkIntVcorePending;				\
+endIntVcoreLock:
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+#define VBI_INT_VCORE_STATE_GET(reg0)				\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+
+#endif /*_ASMLANGUAGE */
+    
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __INCvbiPpcArchh */
diff --git a/arch/powerpc/kernel/vbiSyscalls.S b/arch/powerpc/kernel/vbiSyscalls.S
new file mode 100644
index 0000000..e984b47
--- /dev/null
+++ b/arch/powerpc/kernel/vbiSyscalls.S
@@ -0,0 +1,1626 @@
+/* vbiSyscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02g,06jul09,mmi  update vb mangement syscall numbers, memory read/write,
+		 registers read/write, interrupt direct op, debug shell start
+02f,26jun09,mmi  add vbiIoapicOp
+02e,23jun09,mmi  add vbi 2.0 apis
+02d,11jun09,mmi  update interrupts apis according to vbi2.0
+02c,10jun09,mmi  remove VxWorks consideration
+02b,28feb09,mmi  add vbiNsOp
+02a,09feb09,mmi  add vbMgmt API
+01z,27jan09,mmi  include vbi.h header file
+01y,23jan09,mmi  update vbiSyscall prototype in comments
+01x,18jan09,mmi  fix vbiIoapicIoctl, remove vbiShelf
+01w,12dec08,md   rename header files
+01v,11dec08,mmi  change name of VB structure pointers
+01u,02dec08,mmi  remove obsolete API's
+01t,19nov08,mmi  adopt new naming convention for vbi API's
+01s,04sep08,dcc  added vdkIoapicIoctl
+01r,20jun08,md   fix header file inclusion
+01q,19jun08,md   change VxWorks define
+01p,28nov07,foo  vdk doc
+01o,21nov07,md   include VxWorks header files if being compiled in a project
+01o,21nov07,foo  vdk interrupts
+01n,25oct07,foo  added vdkIntControllerDone, vdkIntEnable, vdkShelf	
+01m,05oct07,md   remove vxworks header files
+01l,10sep07,md   re-number hypervisor system calls
+01k,05jul07,foo  added vdkBspIoctl	
+01j,04jun07,md   added vdkHyCtxctl, vdkMmuPageProtect and vdkMmuPageUnprotect
+01i,24may07,ymz  added port system calls.
+01h,18may07,md   added vdkHyIoctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed syscalls to start with vdk
+01e,10apr07,md   split kprintf into kputs and kputc
+01d,02apr07,md   header file re-org
+01c,19mar07,foo	 fix macro names
+01b,15mar07,md   added hyInt, hyIntDone
+01a,11mar07,md   written
+*/
+
+/*
+DESCRIPTION
+
+This file implements the hypervisor system call stubs for the hypervisor.
+
+*/
+
+#define _ASMLANGUAGE
+#ifdef __KERNEL__
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/asm-offsets.h>
+#include <asm/cache.h>
+#include <vbi/sys/vbiSyscall.h>
+
+#define FUNC_LABEL(func)       _GLOBAL(func)
+#define	FUNC_EXPORT(func)
+#define	FUNC_END(func)
+#define	_WRS_TEXT_SEG_START
+#define	HI(sym) sym@h
+#define	HIADJ(sym)      sym@ha
+#define	LO(sym) sym@l
+#else  /* __KERNEL__ */
+#include <wrhv.h>
+#include <sys/arch.h>
+#include <sys/regs.h>
+#include <sys/vbiSyscall.h>
+#endif
+
+#define p0	r3      /* argument register, volatile */
+#define p1	r4      /* argument register, volatile */
+#define p2	r5      /* argument register, volatile */
+#define p3	r6      /* argument register, volatile */
+#define p4	r7      /* argument register, volatile */
+#define p5	r8      /* argument register, volatile */
+#define p6	r9      /* argument register, volatile */
+#define p7	r10     /* argument register, volatile */
+#define	wrhvVbStatus	wrhvStatus
+#define wrhvVbControl	wrhvControl
+
+	/* globals */
+
+	FUNC_EXPORT(vbiVcoreIntRed_op)
+	FUNC_EXPORT(vbiDebugShellStart)
+	FUNC_EXPORT(vbiVbMemoryRead)
+	FUNC_EXPORT(vbiVbMemoryWrite)
+	FUNC_EXPORT(vbiVbRegisterRead)
+	FUNC_EXPORT(vbiVbRegisterWrite)
+	FUNC_EXPORT(vbiIoapicOp)
+	FUNC_EXPORT(vbiIoapicIoctl)
+	FUNC_EXPORT(vbiHyIoctl)
+	FUNC_EXPORT(vbiCtxctl)
+	FUNC_EXPORT(vbiBspIoctl)
+	FUNC_EXPORT(vbiSend)
+	FUNC_EXPORT(vbiReceive)
+	FUNC_EXPORT(vbiReply)
+	FUNC_EXPORT(vbiIcacheFlush)
+	FUNC_EXPORT(vbiDcacheFlush)
+	FUNC_EXPORT(vbiCacheTextUpdate)
+	FUNC_EXPORT(vbiTlbFlush)
+	FUNC_EXPORT(vbiPanic)
+	FUNC_EXPORT(vbiPs)
+	FUNC_EXPORT(vbiKputs)
+	FUNC_EXPORT(vbiKputc)
+	FUNC_EXPORT(vbiIntVCoreUnlock)
+	FUNC_EXPORT(vbiIntVCoreLock)
+	FUNC_EXPORT(vbiExcBaseSet)
+	FUNC_EXPORT(vbiMemAttrSet)
+	FUNC_EXPORT(vbiMemAttrGet)
+	FUNC_EXPORT(vbiVmmuConfig)
+	FUNC_EXPORT(vbiVmmuEnable)
+	FUNC_EXPORT(vbiVmmuDisable)
+	FUNC_EXPORT(vbiVmmuTlbLoad)
+	FUNC_EXPORT(vbiVmmuTlbFlush)
+	FUNC_EXPORT(vbiVbMgmt)
+	FUNC_EXPORT(vbiNsOp)
+	FUNC_EXPORT(vbiVbSuspend)
+	FUNC_EXPORT(vbiVbReset)
+	FUNC_EXPORT(vbiVbRestart)
+	FUNC_EXPORT(vbiVbResume)
+
+	_WRS_TEXT_SEG_START
+
+/******************************************************************************
+*
+* sys_vbMgmt - virtual board management
+* 
+* This routine executes the specified command on a given virtual board. The
+* possible commands are:
+* 
+* VBI_VBMGMT_ATTACH 
+* Attach the requesting Virtual Board to the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_DETACH
+* Detatch the requesting Virtual Board from the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_SUSPEND
+* Suspends target Virtual Board from operation.  Fails if Virtual Board
+* has already been suspended
+*
+* VBI_VBMGMT_RESET
+* Resume a target virtual board.  Fails if a Virtual Board has not been
+* suspended. Currently no options are supported
+*
+* VBI_VBMGMT_RESUME
+* Restarts a target Virtual Board which has Preload=0 set in the xml file.
+* Fails if Virtual Board is preloaded (Preload=1)
+*
+* The fourth argument to this routine specifies an flag that must be defined
+* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+* The possible flgas are:
+*   VBI_VTLB_OP_UPDATE_PMD	
+*   VBI_VTLB_OP_UPDATE_PTE	
+*   VBI_VTLB_OP_DELETE_PMD	
+*   VBI_VTLB_OP_SET_PTE_AT	
+*   VBI_VTLB_OP_SET_PTE	
+*   VBI_VTLB_OP_FLUSH_OPS	
+*   VBI_VTLB_OP_INIT	
+* 
+* RETURNS: OK or error in case of failure
+* 
+*
+* int32_t sys_vbMgmt 
+*    (
+*    uint32_t cmd,	/@ attach, detach, suspend, reset or resume @/
+*    uint32_t boardId,	/@ the operation target board id @/
+*    int32_t *outError, /@ where to set error : OK or error flag @/ 
+*    uint32_t flags	/@ options required by the cmd executed @/
+*    )
+*/
+
+FUNC_LABEL(vbiVbMgmt)
+        lis     r0, HI(VBI_SYS_vbMgmt)
+        ori     r0, r0, LO(VBI_SYS_vbMgmt)
+        sc
+        blr
+FUNC_END(vbiVbMgmt)
+
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service.
+*
+* SYNOPSIS
+*\cs
+*
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbSuspend)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+	
+        lis     r0, HI(VBI_SYS_vbSuspend)
+        ori     r0, r0, LO(VBI_SYS_vbSuspend)
+        sc
+        blr
+FUNC_END(vbiVbSuspend)
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target
+* core(s) program counter to it's ENTRY function. The ENTRY function is 
+* determined based on the loaded binary image. A core does not execute beyond
+* it's ENTRY function unless vbiVbRestart() is explitly called. 
+* Except for core0 within the target VB where VBI_VBMGMT_RESET_AND_START_CORE0
+* option is set in the flag passed as the third argument to this routine.
+* The hypercall sends a message to a manager that provides VB managment 
+* services. 
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset
+* is not determined. The second argument identifies the cores to perform the
+* operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual
+* Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options
+* may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest
+* OS's responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
+*    vbiCore_t     core,            /@ Core within the VB           @/
+*    uint32_t     options   /@ reload , start options       @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*/
+
+FUNC_LABEL(vbiVbReset)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 * r5 - options
+	 */
+
+        lis     r0, HI(VBI_SYS_vbReset)
+        ori     r0, r0, LO(VBI_SYS_vbReset)
+        sc
+        blr
+FUNC_END(vbiVbReset)
+
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to
+* restart.
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+FUNC_LABEL(vbiVbRestart)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbRestart)
+        ori     r0, r0, LO(VBI_SYS_vbRestart)
+        sc
+        blr
+FUNC_END(vbiVbRestart)
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*/
+
+FUNC_LABEL(vbiVbResume)
+
+	/* 
+	 * r3 - virtual board id
+	 * r4 - virtual core ( a flag or a valid vcore id)
+	 */
+
+        lis     r0, HI(VBI_SYS_vbResume)
+        ori     r0, r0, LO(VBI_SYS_vbResume)
+        sc
+        blr
+FUNC_END(vbiVbResume)
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiSend)
+
+	/*
+	 * r3 - ctx id
+	 * r4 - smsg pointer 
+	 * r5 - size of smsg 
+	 * r6 - rmsg pointer
+	 * r7 - rmsg length
+	 * r8 - info pointer
+	 * r9 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_send)
+	ori	r0, r0, LO(VBI_SYS_send)
+	sc
+	blr
+FUNC_END(vbiSend)
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReceive)
+
+	/*
+	 * r3 - smsg pointer 
+	 * r4 - size of smsg 
+	 * r5 - info pointer
+	 * r6 - ctl pointer
+	 */
+
+	lis	r0, HI(VBI_SYS_receive)
+	ori	r0, r0, LO(VBI_SYS_receive)
+	sc
+	blr
+FUNC_END(vbiReceive)
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t	    id,    /@ context id to reply the message to    @/
+*    void *	    buff,  /@ pointer to reply message		    @/
+*    size_t	    len,   /@ length of message to reply	    @/
+*    VBI_MSG_CTL    *ctl   /@ control data structure pointer	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+FUNC_LABEL(vbiReply)
+	lis	r0, HI(VBI_SYS_reply)
+	ori	r0, r0, LO(VBI_SYS_reply)
+	sc
+	blr
+FUNC_END(vbiReply)
+
+/*******************************************************************************
+*
+* vbiKputs - print a string on the hypervisor kernel console
+*
+* This routine makes a hypercall and prints a string of characters to to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputs (const char *s) /@ string to display @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputc() 
+*/
+
+FUNC_LABEL(vbiKputs)
+	lis	r0, HI(VBI_SYS_kputs)
+	ori	r0, r0, LO(VBI_SYS_kputs)
+	sc
+	blr
+FUNC_END(vbiKputs)
+
+/*******************************************************************************
+*
+* vbiKputc - print a character on the hypervisor kernel console
+*
+* This routine makes a hypercall in order to print the specified character to
+* hypervisor console.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiKputc (int c) /@ character to print @/
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiKputs()
+*/
+
+FUNC_LABEL(vbiKputc)
+	lis	r0, HI(VBI_SYS_kputc)
+	ori	r0, r0, LO(VBI_SYS_kputc)
+	sc
+	blr
+FUNC_END(vbiKputc)
+
+/*******************************************************************************
+*
+* vbiPanic - halt the system and dump debug info 
+*
+* This routine makes a hypercall in order to halt the system and display debug
+* information on hypervisor console. If hypervisor is configured with
+* WRHV_DISPLAY_ERROR_MSGS this routine prints the specified string to hypervisor
+* console. If hypervisor is configured with WRHV_DISPLAY_EXC_INFO component
+* the offending cores registers dump is displayed on hypervisor console. If
+* hypervisor is configured with WRHV_INCLUDE_DEBUG_MGR a message is sent to the
+* the debug manager.
+*
+*
+* SYNOPSIS
+*\cs
+* 
+* void vbiPanic (const char *msg) /@ pointer to message to print @/
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+*/
+
+FUNC_LABEL(vbiPanic)
+	lis	r0, HI(VBI_SYS_panic)
+	ori	r0, r0, LO(VBI_SYS_panic)
+	sc
+	blr
+FUNC_END(vbiPanic)
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine 
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running. 
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart 
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          ) 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERRNO: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiDebugShellStart)
+
+	/* r3 - flags for attachement behaviour */
+
+	lis	r0, HI(VBI_SYS_dbgShStart)
+	ori	r0, r0, LO(VBI_SYS_dbgShStart)
+	sc
+	blr
+FUNC_END(vbiDebugShellStart)
+
+/*******************************************************************************
+*
+* vbiIcacheFlush - flush the instruction cache
+*
+* This routine makes a hypercall to flush the instruction cache of the calling
+* core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiIcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the instruction cache to flush @/
+*	    size_t len  /@ length of memory to flush @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush()
+*/
+
+FUNC_LABEL(vbiIcacheFlush)
+	lis	r0, HI(VBI_SYS_icache_flush)
+	ori	r0, r0, LO(VBI_SYS_icache_flush)
+	sc
+	blr
+FUNC_END(vbiIcacheFlush)
+
+/*******************************************************************************
+*
+* vbiDcacheFlush - flush the specified Data cache
+*
+* This routine makes a hypercall to flush the data cache of the calling core
+* for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiDcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the data cache to flush @/
+*	    size_t len  /@ length of memory to flush                   @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiDcacheFlush)
+	lis	r0, HI(VBI_SYS_dcache_flush)
+	ori	r0, r0, LO(VBI_SYS_dcache_flush)
+	sc
+	blr
+FUNC_END(vbiDcacheFlush)
+
+
+/******************************************************************************
+*
+* vbiTlbFlush - flush an MMU TLB entry
+*
+* This system call flushes the TLB associated with the specified context id 
+*
+* C interface:
+*
+*   vbiTlbFlush (unsigned int id) /@ the entry to flush @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiTlbFlush)
+	lis	r0, HI(VBI_SYS_tlb_flush)
+	ori	r0, r0, LO(VBI_SYS_tlb_flush)
+	sc
+	blr
+FUNC_END(vbiTlbFlush)
+
+/*******************************************************************************
+*
+* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+*
+* This routine enables interrupts and makes a fast hypercall if pending
+* interrupts are detected for the calling core. This is a C wrapper function for
+* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void vbiIntVCoreUnlock (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreUnlock)
+	
+	lis	p0, HIADJ(wrhvVbControl)
+	lwz	p0, LO(wrhvVbControl)(p0)
+	stw	p1, VB_CONTROL_INT_DISABLE(p0)
+	
+tryAgain:		
+	lis	p0, HIADJ(wrhvVbStatus)
+	lwz	p0, LO(wrhvVbStatus)(p0)
+	lwz	p1, VB_STATUS_INT_PENDING(p0)
+	
+	/* Perform System Call to re-enable ints if ints pending */
+	cmplwi  p1, 0
+	beq     0f
+
+	lis	r0, HI(VBI_SYS_int_enable)
+	ori	r0, r0, LO(VBI_SYS_int_enable)
+	sc
+	b	tryAgain
+0:
+	blr
+FUNC_END(vbiIntVCoreUnlock)
+
+ /*******************************************************************************   
+ *
+ * vbiIntVCoreLock - lock interrupts
+ *
+ * This routine locks interrupts for the calling core. This is a C wrapper 
+ * function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+ * and returns the previous state of interrupts.
+ *
+ * SYNOPSIS
+ *\cs
+ * 
+ * VBI PPC Architecture Supplements
+ *
+ * vbiIntState_t vbiIntVCoreLock (void)
+ *
+ *\ce
+ *
+ * RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
+ *
+ * ERROR CODES: N/A
+ *
+ * SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+ *           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+ */
+
+FUNC_LABEL(vbiIntVCoreLock)
+	li	p1, -1
+	lis	p2, HIADJ(wrhvVbControl)
+	lwz	p2, LO(wrhvVbControl)(p2)
+	lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+	stw	p1, VB_CONTROL_INT_DISABLE(p2)
+	blr
+FUNC_END(vbiIntVCoreLock)
+
+/*******************************************************************************
+*
+* vbiIntVCoreStateGet - Get interrupts state for running core
+*
+* This routine returns the interrupts state for the calling core. This is C 
+* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+* returns TRUE if interrupts are locked otherwise FALSE.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntStatus_t vbiIntVCoreStateGet (void)
+*
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+FUNC_LABEL(vbiIntVCoreStateGet)
+    lis	p2, HIADJ(wrhvVbControl)
+    lwz	p2, LO(wrhvVbControl)(p2)
+    lwz	p0, VB_CONTROL_INT_DISABLE(p2)
+    blr
+FUNC_END(vbiIntVCoreStateGet)
+
+/*******************************************************************************
+*
+* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+*
+* This routine changes the exceptions vector table base address for the active
+* virtual core. By default the base address of the exception table is at address
+* 0x0.
+* If the guest OS programmer wishes to move this address then this function must
+* be called to inform hypervisor. This function must be called with interrupts
+* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcBaseSet 
+*	    (
+*	    void * excTblBase /@ New exception table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+FUNC_LABEL(vbiExcBaseSet)
+
+	/* 
+	 * r3 has the base address to set; make sure it is aligned  
+	 * align to 32 bytes  
+	 */	    
+
+	clrrwi  r3,r3, 5
+	
+	/* set command for the ioctl */
+
+	li	r4, VBI_HYIOCTL_EXCBASE
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
+	blr
+FUNC_END(vbiExcBaseSet)
+	
+/*******************************************************************************
+*
+* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+*
+* This routine makes a hypercall to flush the data cache then invalidates the
+* instruction cache of the calling core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiCacheTextUpdate 
+*	    (
+*	    void * addr /@ starting address to perform textUpdate operation @/
+*	    size_t len  /@ length of memory in bytes			    @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*/
+
+FUNC_LABEL(vbiCacheTextUpdate)
+	lis	r0, HI(VBI_SYS_cache_text_update)
+	ori	r0, r0, LO(VBI_SYS_cache_text_update)
+	sc
+	blr
+FUNC_END(vbiCacheTextUpdate)
+
+/******************************************************************************
+*
+* vbiVmmuConfig - configure the hypervisor virtual MMU
+*
+* This system call configures the context's virtual MMU within the hypervisor.
+*
+* C interface:
+*
+*   vbiVmmuConfig (VMMU_CONFIG *config) /@ The vmmu configuration @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuConfig)
+	lis	r0, HI(VBI_SYS_vmmu_config)
+	ori	r0, r0, LO(VBI_SYS_vmmu_config)
+	sc
+	blr
+FUNC_END(vbiVmmuConfig)
+
+
+/******************************************************************************
+*
+* vbiVmmuEnable - enables the virtual MMU
+*
+* This system call enables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuEnable (unsigned int vmmu_num) /@ Enable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuEnable)
+	lis	r0, HI(VBI_SYS_vmmu_enable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
+	sc
+	blr
+FUNC_END(vbiVmmuEnable)
+
+
+/******************************************************************************
+*
+* vbiVmmuDisable - disable the virtual MMU
+*
+* This system call disables a context's virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuDisable (unsigned int vmmu_num) /@ Disable the specified VMMU @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuDisable)
+	lis	r0, HI(VBI_SYS_vmmu_disable)
+	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
+	sc
+	blr
+FUNC_END(vbiVmmuDisable)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbLoad - load a TLB entry into the virtual MMU
+*
+* This system call loads the TLB entries for the specified address range into
+* the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbLoad (VMMU_CONFIG *config, /@ The VMMU being used @/
+*                   void *addr,		 /@ Starting address    @/
+*                   unsigned int len)    /@ length              @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbLoad)
+	lis	r0, HI(VBI_SYS_vmmu_tlbload)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
+	sc
+	blr
+FUNC_END(vbiVmmuTlbLoad)
+
+
+/******************************************************************************
+*
+* vbiVmmuTlbFlush - load a TLB entry into the virtual MMU
+*
+* This system call flushes the TLB entries for the specified address range
+* from the virtual MMU.
+*
+* C interface:
+*
+*   vbiVmmuTlbFlush (VMMU_CONFIG *config, /@ The VMMU configuration to use @/
+*		     void *addr,          /@ Starting address              @/
+*		     unsigned int len)    /@ length                        @/
+*
+* Returns: OK or ERROR
+*
+*/
+
+FUNC_LABEL(vbiVmmuTlbFlush)
+	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
+	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
+	sc
+	blr
+FUNC_END(vbiVmmuTlbFlush)
+
+
+/******************************************************************************
+*
+* vbiHyIoctl - hypervisor ioctl call
+*
+* This system call interfaces to the general purpose hypervisor ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_HYIOCTL_GETPID
+*     VBI_HYIOCTL_GETPRIORITY
+*     VBI_HYIOCTL_PSDISPLAY
+*     VBI_HYIOCTL_GETSTATS
+*     VBI_HYIOCTL_EXCBASE
+*		
+* C interface:
+*
+*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*               void *arg)          /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiHyIoctl)
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	sc
+	blr
+FUNC_END(vbiHyIoctl)
+
+/******************************************************************************
+*
+* vbiCtxctl - hypervisor context control call
+*
+* This system call interfaces to the general purpose hypervisor context
+* control function.
+*
+* Possbile operations:
+*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+*
+* C interface:
+*
+*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
+*		 void *arg)		 /@ address of argument @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiCtxctl)
+	lis	r0, HI(VBI_SYS_ctxctl)
+	ori	r0, r0, LO(VBI_SYS_ctxctl)
+	sc
+	blr
+FUNC_END(vbiCtxctl)
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrSet)
+	lis	r0, HI(VBI_SYS_mmu_attr_set)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
+	sc
+	blr
+FUNC_END(vbiMemAttrSet)
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+FUNC_LABEL(vbiMemAttrGet)
+	lis	r0, HI(VBI_SYS_mmu_attr_get)
+	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
+	sc
+	blr
+FUNC_END(vbiMemAttrGet)
+
+
+/******************************************************************************
+*
+* vbiBspIoctl - bsp ioctl call
+*
+* This system call interfaces to the Board Support Package
+* I/O drivers etc
+*
+* Knwon BSP ioctl commands:
+*	VBI_BSPIOCTL_ENABLE_INT   /@ Enable HW interrupt @/
+*	VBI_BSPIOCTL_DISABLE_INT  /@ Disable HW interrupt@/
+*	VBI_BSPIOCTL_RESET	  /@ Reset HW device     @/
+*				
+* C interface:
+*
+*   vbiBspIoctl (unsigned int ioctl, /@ the BSP ioctl command  @/
+*                unsigned int arg1   /@ arguments to the ioctl @/
+*                unsigned int arg2
+*                unsigned int arg3
+*                unsigned int arg4
+*                unsigned int arg5
+*                unsigned int arg6
+*                unsigned int arg7)
+*
+* Returns: ioctl specific value
+*
+*/
+
+FUNC_LABEL(vbiBspIoctl)
+	lis	r0, HI(VBI_SYS_bspIoctl)
+	ori	r0, r0, LO(VBI_SYS_bspIoctl)
+	sc
+	blr
+FUNC_END(vbiBspIoctl)
+
+/******************************************************************************
+*
+* vbiIoapicIoctl - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function. For PPC this is a nop routine for now.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*                   unsigned arg1,      /@ address of information @/
+*                   unsigned arg2)      /@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicIoctl)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
+	blr
+FUNC_END(vbiIoapicIoctl)
+
+/******************************************************************************
+*
+* vbiNsOp - virtua board name service call
+*
+* This system call interfaces to the virtual board
+*
+* commands:
+*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+*				
+* C interface:
+*
+*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
+*	    char * name,		    /@ the service name		@/
+*	    uint32_t revision,	    /@ service revision		@/
+*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
+*	  )
+*
+* Returns: OK or ERROR in case of failure
+*
+*/
+
+FUNC_LABEL(vbiNsOp)
+	lis   r0, HI(VBI_SYS_ns_op)
+	ori	r0, r0, LO(VBI_SYS_ns_op)
+	sc
+	blr
+FUNC_END(vbiNsOp)
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryRead)
+	lis   r0, HI(VBI_SYS_memRead_op)
+	ori	r0, r0, LO(VBI_SYS_memRead_op)
+	sc
+	blr
+FUNC_END(vbiVbMemoryRead)
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbMemoryWrite)
+	lis	r0, HI(VBI_SYS_memWrite_op)
+	ori	r0, r0, LO(VBI_SYS_memWrite_op)
+	sc
+	blr
+FUNC_END(vbiVbMemoryWrite)
+
+/******************************************************************************
+*
+* vbiIoapicOp - virtual IO APIC operation
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicOp (unsigned int ioctl,	/@ the ioctl command      @/
+*                vbiIrq_t irq,		/@ address of information @/
+*                uint32_t filter),      /@ address of information @/
+*                vbiVb_t vbId)		/@ address of information @/
+*
+* Returns: OK
+*
+*/
+
+FUNC_LABEL(vbiIoapicOp)
+	lis   r0, HI(VBI_SYS_vIoapicIoctl)
+	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
+	sc
+	blr
+FUNC_END(vbiIoapicOp)
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* SYNOPSIS
+*\cs
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterRead)
+	lis   r0, HI(VBI_SYS_RegsRead_op)
+	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
+	sc
+	blr
+FUNC_END(vbiVbRegisterRead)
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+*\cs
+*typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call @/
+*
+*    uint32_t srr0;		/@  0: PC				    @/
+*    uint32_t srr1;		/@  1: MSR				    @/
+*    uint32_t cr;		/@  2: condition registers		    @/
+*    uint32_t r0;		/@  3: General register R0		    @/
+*    uint32_t sp;		/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;		/@  5: General register R2		    @/
+*    uint32_t r3;		/@  6: General register R3		    @/
+*    uint32_t r4;		/@  7: General register R4		    @/
+*    uint32_t r5;		/@  8: General register R5		    @/
+*    uint32_t r6;		/@  9: General register R6		    @/
+*    uint32_t r7;		/@ 10: General register R7		    @/
+*    uint32_t r8;		/@ 11: General register R8		    @/
+*    uint32_t r9;		/@ 12: General register R9		    @/
+*    uint32_t r10;		/@ 13: General register R10		    @/
+*    uint32_t r11;		/@ 14: General register R11		    @/
+*    uint32_t r12;		/@ 15: General register R12		    @/
+*    uint32_t r13;		/@ 16: General register R13		    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;		/@ 17: emulated MSR register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbsr;		/@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers						    @/
+*    
+*    uint32_t     dbcr0;	/@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1;	/@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2;	/@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2			    @/
+*
+*    uint32_t     iac1;		/@ 22 - instructions access control 1	    @/
+*    uint32_t     iac2;		/@ 23 - instructions access control 2	    @/
+*
+*    /@ data address compare registers DAC1-DAC2.			    @/
+*
+*    uint32_t     dac1;		/@ 24 - instructions access control 3	    @/
+*    uint32_t     dac2;		/@ 25 - instructions access control 4	    @/
+*
+*    /@ reserved fields for future use					    @/
+*
+*    uint32_t reserved[10];      /@ 26: Reserved			    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*\ce 
+* VBI PPC Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+FUNC_LABEL(vbiVbRegisterWrite)
+	lis   r0, HI(VBI_SYS_RegsWrite_op)
+	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
+	sc
+	blr
+FUNC_END(vbiVbRegisterWrite)
+
+
+/*******************************************************************************
+*
+* vbiVcoreIntRed_op - redirect an irq to another vcore
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVcoreIntRed_op 
+*	(
+*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
+*	vbiCore_t		core	/@ destination vcore		 @/
+*	)
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: vbiVioapicIntRedirect()
+* 
+*\NOMANUAL
+*/
+
+FUNC_LABEL(vbiVcoreIntRed_op)
+	lis   r0, HI(VBI_SYS_intRedirect)
+	ori	r0, r0, LO(VBI_SYS_intRedirect)
+	sc
+	blr
+FUNC_END(vbiVcoreIntRed_op)
diff --git a/arch/powerpc/kernel/vbiUtil.c b/arch/powerpc/kernel/vbiUtil.c
new file mode 100644
index 0000000..1e9acda
--- /dev/null
+++ b/arch/powerpc/kernel/vbiUtil.c
@@ -0,0 +1,144 @@
+/* vbi/vbiUtil.c - utilities routines for guest OS para-virtualization */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01a,17jul07, ymz written
+02a,08nov07, mb  moved wrhv_int_lock and friends from init/main.c; formatting fixes
+*/
+
+/*
+This module implements a library which is handy for para-virtualized
+guest os to use. The routines are developed based on the need while
+para-virtualize linux, therefore, may need some tweaks to be generic.
+*/
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <vbi/vbInterface.h>
+#include <vbi/sys/vmmu.h>
+#include <vbi/sys/vbiSyscall.h>
+
+
+/* defines */
+
+/* globals */
+
+/*
+ * wrhvConfig is initialized as part of the guest os init, before os turns on
+ * MMU. For paravirualized linux, it is initialized in plaform_init().
+ */
+
+extern VB_CONFIG *wrhvConfig;
+extern VB_STATUS *wrhvStatus;
+extern VB_CONTROL *wrhvControl;
+
+/* local */
+
+/* extern */
+extern void pteAttrSet(VMMU_PTE * pte, u_int attr);
+extern void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon);
+
+/* forward declarations */
+
+unsigned int vb_memsize_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig) {
+		/* vb_memsize_get should not be called before wrhvConfig is init,
+		 * REALLY
+		 */
+		return 0;
+	}
+
+	return (((VB_CONFIG *) wrhvConfig)->physicalMemorySize);
+}
+
+unsigned int vb_context_get(void)
+{
+	if ((VB_CONFIG *) - 1 == wrhvConfig)
+		return 0xdeadbee0;
+	return (((VB_CONFIG *) wrhvConfig)->pid);
+}
+
+void vb_pte_set(void *pPte, unsigned long paddr, int protval)
+{
+
+	/* caller has guaranteed pPte != NULL */
+
+	*(uint *) pPte = (uint) VMMU_PTE_VALID_MASK;
+
+	/* linux uses more than the permission bits, in word1 of PTE */
+
+	*((uint *) ((uint *) pPte) + 1) = (((u_int) paddr & VMMU_PTE_RPN_MASK) | (protval & 0xfff));
+
+	return;
+}
+
+/*
+ * turn on mmu for the particular context
+ *
+ * note, caller must make sure, context switch inside the guest OS must
+ * not happen during this call.
+ */
+
+int vb_context_mmu_on(int pid,	/* context id */
+		      void *pgtable,	/* level 1 page table */
+		      int pagesize, int debug)
+{
+	static VMMU_CONFIG vmmu_cfg;
+
+	if ((VB_CONFIG *) - 1 == wrhvConfig || NULL == pgtable || pagesize <= 0)
+		return -1;
+
+	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
+	vmmu_cfg.pageSize = pagesize;
+	vmmu_cfg.contextId = pid;
+	vmmu_cfg.vmmuNum = 0;	/* only vmmu 0 is support for the time being */
+
+	if ((vbiVmmuConfig(&vmmu_cfg)) != 0)
+		return -1;
+
+	if (debug) {
+		printk("L1 page table address %#X\n", pgtable);
+		vmmuPageTableDisplay(pgtable, 0);
+		printk("End of page table display \n");
+	}
+
+	vbiVmmuEnable(vmmu_cfg.vmmuNum);
+
+	return 0;
+}
+
+void vb__flush_dcache_icache(void *start)
+{
+	vbiIcacheFlush(start, 4096);
+	vbiDcacheFlush(start, 4096);
+}
+
+void vb_flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	vbiDcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_icache_range(unsigned long start, unsigned long stop)
+{
+	vbiIcacheFlush((void *) start, (stop - start + 1));
+}
+
+void vb__flush_dcache_icache_phys(unsigned long physaddr)
+{
+	vbiIcacheFlush((void *) physaddr, 4096);
+	vbiDcacheFlush((void *) physaddr, 4096);
+}
+
+EXPORT_SYMBOL_GPL(wrhv_int_lock);
+EXPORT_SYMBOL_GPL(wrhv_int_unlock);
+EXPORT_SYMBOL_GPL(wrhv_int_lvl_get);
-- 
1.6.3.3

