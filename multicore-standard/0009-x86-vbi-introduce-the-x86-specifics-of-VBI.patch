From 8edbd39a5eae0ef47b2758da923690bf9cccf8c7 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:06:38 -0400
Subject: [PATCH 09/24] x86 vbi: introduce the x86 specifics of VBI

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/x86/kernel/vbiIntController.c |  116 ++++
 arch/x86/kernel/vbiSyscalls.S      | 1180 ++++++++++++++++++++++++++++++++++++
 include/asm-x86/vbiX86Arch.h       |  192 ++++++
 3 files changed, 1488 insertions(+), 0 deletions(-)
 create mode 100644 arch/x86/kernel/vbiIntController.c
 create mode 100644 arch/x86/kernel/vbiSyscalls.S
 create mode 100644 include/asm-x86/vbiX86Arch.h

diff --git a/arch/x86/kernel/vbiIntController.c b/arch/x86/kernel/vbiIntController.c
new file mode 100644
index 0000000..59f93d4
--- /dev/null
+++ b/arch/x86/kernel/vbiIntController.c
@@ -0,0 +1,116 @@
+/* vbiIntController.c - virtual interrupt controller device */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01b,25oct07,foo  update for real hardware interrupt implementation
+01a,09may07,foo  written
+*/
+
+/*
+ * This module contains the code for accessing and controlling the
+ * virtual interrupt controller as presented to a Virtual Board.
+ */
+/* #define DEBUG 1 */
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#include <vbi/vbInterface.h>
+#include <vbi/vbInterrupt.h>
+
+#include <linux/string.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/module.h>
+
+typedef irqreturn_t (*IRQHANDLER) (unsigned int a, ...);
+
+/* Type for storing interrupt handlers provided by the application */
+typedef struct vbiIntControllerHandler
+    {
+    IRQHANDLER handler;  /* The handler to call for the interrupt */
+    void *        param;    /* The parameter to be passed first */
+    } VBI_INT_CONTROLLER_HANDLER;
+
+/* Storage for interrupt handlers */
+VBI_INT_CONTROLLER_HANDLER vbiIntControllerHandlers[VB_MAX_INTERRUPTS];
+
+#define CALL_INT_HANDLER() handle_simple_irq(vector, &irq_desc[vector])
+#define HANDLERFUNCPTR irqreturn_t(*handler)()
+
+void vbiIntControllerHandle(void);
+
+/******************************************************************************
+*
+* vbiIntControllerConnect - connect to a specific vector in the virtual controller
+*
+* RETURNS: None
+*
+*/
+void vbiIntControllerConnect
+    (
+    int vector,
+    VOIDFUNCPTR handler,
+    void * param
+    )
+{
+}
+EXPORT_SYMBOL(vbiIntControllerConnect);
+
+/******************************************************************************
+*
+* vbiIntControllerFindVector - determine the interrupt vector for a specified
+*                              interrupt
+*
+* RETURNS: None
+*
+*/
+void vbiIntControllerFindVector
+    (
+    char * intName,        /* String name of the interrupt */
+    int    inputInterrupt, /* Input vector = 1, Output vector = 0 */
+    int *  vector          /* vector number returned here, -1 if not found */
+    )
+    {
+    VB_INT_INFO * info = wrhvConfig->interruptConfiguration;
+    int           num  = wrhvConfig->numInts;
+    int           i;
+
+    *vector = -1;
+    for (i = 0; i < num; i++, info++)
+        {
+        if (inputInterrupt)
+            {
+            if (info->intDirection != VB_INPUT_INT)
+                {
+                continue;
+                }
+            }
+        else
+            {
+            if (info->intDirection == VB_INPUT_INT)
+                {
+                continue;
+                }
+            }
+        if (!strncmp (intName, info->intName, VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *vector = info->intNumber;
+            return;
+            }
+        }
+
+    }
+EXPORT_SYMBOL(vbiIntControllerFindVector);
diff --git a/arch/x86/kernel/vbiSyscalls.S b/arch/x86/kernel/vbiSyscalls.S
new file mode 100644
index 0000000..355fd41
--- /dev/null
+++ b/arch/x86/kernel/vbiSyscalls.S
@@ -0,0 +1,1180 @@
+/* vbiSyscalls.s - hypervisor system calls */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01s,25aug09,mmi  remove bspIoctl
+01r,13aug09,dtr  Update to vbiHyIoctl.
+01q,06jul09,mmi  added vbi 2.0 vbMgmt api, interrupt redirect op,
+		 registers read/write, memory read/write, 
+01p,02jul09,mmi  add interrupt send syscall stub
+01o,27jun09,mmi  fix stack adjustment for vbiReply
+01n,23jun09,mmi  add vbi 2.0 API's
+01m,18jun09,mmi  changed vbiIntVCoreUnlock not expect a flag
+01l,12jun09,mmi  introduce vbiIntVCoreLock/Unlock APIs
+01k,26feb09,mmi  add name service hypercall
+01j,12feb09,mmi  update API descriptions, descriptions, fix vbiReply #arg pushed
+		 to the stack 
+01i,08feb09,mmi  fix vbiIntEnable/vbiIntDisable routines, remove vbiInt
+01h,23jan09,mmi  update vbiSend/vbiReceive and vbiReply comments
+01g,05dec08,mes  Replaced vbiShelf with vbiVbMgmt
+01f,02dec08,mmi  remove obsolete API's
+01e,20nov08,mmi  adopt vbi naming
+01d,04sep08,dcc  modified vdkInt() to call vdkIoapicIoctl()
+01c,19may08,gws  add vdkIoapicIoctl
+01b,18apr08,md   add extra arg to vdkHyIoctl
+01a,03mar08,md   written
+*/
+
+/*
+DESCRIPTION
+
+This file implements the hypervisor system call stubs for the Razor hypervisor.
+
+*/
+
+#define _ASMLANGUAGE
+
+#include <vbi/sys/vbiSyscall.h>
+#define EFLAGS_IF	0x200
+
+	/* globals */
+	.globl vbiDebugShellStart
+	.globl vbiVbMemoryWrite
+	.globl vbiVbMemoryRead
+	.globl vbiIoapicOp
+	.globl vbiIoapicIoctl
+	.globl vbiHyIoctl
+	.globl vbiCtxctl
+	.globl vbiSend
+	.globl vbiReceive
+	.globl vbiReply
+	.globl vbiTlbFlush
+	.globl vbiPanic
+	.globl vbiPs
+	.globl vbiKputs
+	.globl vbiKputc
+	.globl vbiIntVCoreUnlock
+	.globl vbiIntVCoreLock
+	.globl vbiVbMgmt
+	.globl vbiMemAttrSet
+	.globl vbiMemAttrGet
+	.globl vbiNsOp
+	.globl vbiVbReset
+	.globl vbiVbRestart
+	.globl vbiVbResume
+	.globl vbiVbSuspend
+	.globl vbiVcoreIntRed_op 
+	.globl vbiVbRegisterRead 
+	.globl vbiVbRegisterWrite 
+	.globl vbiVtlbOp
+	.text
+	.balign 16
+
+#define VBI_STACK_FRAME_SIZE	4
+
+/*******************************************************************************
+*
+* vbiSend - Send a message to another context
+*
+* This routine makes a hypercall to send a message to the specified context and
+* waits for a reply.  The caller will block until the sender replies to the sent
+* message.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiSend
+*    (
+*    vbiCtx_t     id,    /@ context id to send the message to @/
+*    void *       smsg,  /@ pointer to message to send        @/
+*    size_t       slen,  /@ length of message to send         @/
+*    void *       rmsg,  /@ pointer to receive message buffer @/
+*    size_t       rlen,  /@ length of receive message         @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiReceive(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiSend:
+	movl    $VBI_SYS_send,%eax		/* system call number */
+	push	$7				/* number of arguments */
+	vmcall
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+	ret
+
+/*******************************************************************************
+*
+* vbiReceive - Receive a message from another context
+*
+* This routine makes a hypercall and waits for a message to be received from
+* another context. It blocks until a message is received.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiCtx_t vbiReceive
+*    (
+*    void *       smsg,  /@ pointer to message to receive  @/
+*    size_t       len,   /@ length of message to receive   @/
+*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: sender context Id or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
+*/
+
+vbiReceive:
+	movl    $VBI_SYS_receive,%eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiReply - Reply to message received from another context
+*
+* This routine makes a hypercall in order to reply to a message received from
+* another context. A message is received from remote context by calling
+* vbiReceive(). The reply will unblock the recipient which may preempt
+* the caller.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiReply
+*    (
+*    vbiCtx_t   id,    /@ context id to reply the message to @/
+*    void *       buff,  /@ pointer to reply message  @/
+*    size_t       len,   /@ length of message to reply   @/
+*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO: N/A
+*
+* SEE ALSO: vbiSend(), vbiReceive(), WRHV  messaging user's guide
+*/
+
+vbiReply:
+	movl    $VBI_SYS_reply,%eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiKputs - print a string on the kernel console
+*
+* This system call sends the specified string to the system console.
+*
+* C interface:
+*
+*   vbiKputs (char *s)		/@ pointer to string			@/
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiKputs:
+	movl    $VBI_SYS_kputs,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiKputc - print a character on the kernel console
+*
+* This system call sends the specified character to the system console.
+*
+* C interface:
+*
+*   vbiKputc (char c)		/@ character to print			@/
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiKputc:
+	movl    $VBI_SYS_kputc,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiPanic - panic the system and halt all activity
+*
+* This system call causes the hypervisor to enter a panic state and display
+* various pieces of information on the system console.  The hypervisor
+* then enters an idle state and stops all CPU processing.
+*
+* C interface:
+*
+*   vbiPanic (char *msg)	/@ message string to print on console	@/
+*
+* Returns: does not return
+*
+*/
+
+vbiPanic:
+	movl    $VBI_SYS_panic,%eax		/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiPs - display the list of contexts on the console
+*
+* This system call sends a "ps" like output of the hypervisor contexts to
+* the system console.
+*
+* C interface:
+*
+*   vbiPs (void)
+*
+* Returns: OK or ERROR
+*
+*/
+
+vbiPs:
+	movl    $VBI_SYS_ps,%eax		/* system call number */
+	push	$0				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiIntVCoreUnlock - Re-enable interrupts in the virtual board
+*
+* This call re-enables interrupts in the virtual board, and calls
+* Razor if interrupts are pending.  The value level is the value returned
+* by the corresponding 	
+*
+* C interface:
+*
+*   vbiIntVCoreUnlock (void)
+*
+* Returns: does not return
+*
+*/
+
+vbiIntVCoreUnlock:
+	sti				/* UNLOCK INTERRUPTS */
+	ret
+
+/******************************************************************************
+*
+* vbiIntVCoreLock - Disable interrupts in the virtual core
+*
+* This call disables interrupts in the virtual board.
+*
+* C interface:
+*
+*   int vbiIntVCoreLock (void)
+*
+* Returns: the old value of the interrupt disable 
+*
+*/
+
+vbiIntVCoreLock:
+    pushf				/* push EFLAGS on stack */
+    popl	%eax			/* get EFLAGS in EAX */
+    andl	$EFLAGS_IF,%eax		/* mask it with IF bit */
+    cli				/* LOCK INTERRUPTS */
+    ret
+
+/******************************************************************************
+*
+* vbiVbMgmt - virtual board management
+* 
+* This routine executes the specified command on a given virtual board. The
+* possible commands are:
+* 
+* VBI_VBMGMT_ATTACH 
+* Attach the requesting Virtual Board to the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_DETACH
+* Detatch the requesting Virtual Board from the VB management agent for
+* operations on the specified VB.
+*
+* VBI_VBMGMT_SUSPEND
+* Suspends target Virtual Board from operation.  Fails if Virtual Board
+* has already been suspended
+*
+* VBI_VBMGMT_RESET
+* Resume a target virtual board.  Fails if a Virtual Board has not been
+* suspended. Currently no options are supported
+*
+* VBI_VBMGMT_RESUME
+* Restarts a target Virtual Board which has Preload=0 set in the xml file.
+* Fails if Virtual Board is preloaded (Preload=1)
+*
+*
+* The fourth argument to this routine specifies an flag that must be defined
+* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+* The possible flgas are:
+*   VBI_VTLB_OP_UPDATE_PMD	
+*   VBI_VTLB_OP_UPDATE_PTE	
+*   VBI_VTLB_OP_DELETE_PMD	
+*   VBI_VTLB_OP_SET_PTE_AT	
+*   VBI_VTLB_OP_SET_PTE	
+*   VBI_VTLB_OP_FLUSH_OPS	
+*   VBI_VTLB_OP_INIT	
+*
+* int32_t vbiVbMgmt 
+*    (
+*    uint32_t	cmd,	    /@ attach, detach, suspend, reset or resume @/
+*    uint32_t	handle,    /@ the operation target board handle @/
+*    int32_t	*outError,  /@ where to set error : OK or error flag @/ 
+*    uint32_t	flags,	    /@ options required by the cmd executed @/
+*    void *ctl		    /@ memory / registers data		    @/ 
+*    )
+*
+* RETURNS: OK or error in case of failure
+*/
+
+vbiVbMgmt:
+	movl    $VBI_SYS_vbMgmt,%eax		/* system call number */
+	push	$5				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbSuspend - Suspend a virtual board's core
+*
+* This routine makes a hypercall in order to suspend one or more cores that
+* exist within the specified virtual board. The target core(s) enter HALT state
+* until vbiVbResume() is called change the state of the core(s). This function
+* will return only after all victim cores are suspended unless the opration
+* fails to complete. The second argument passed to this function specifies one
+* or more target cores. For suspending every core within the specified VB the
+* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
+* requesting the suspension may also be included in the list to be suspended.
+* To suspend everyone but the recipient then the second argument passed to this
+* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
+* should be a valid core number within the VB. This hypercall sends a message
+* to a given hypervisor manager that provides virtual board managment service.
+*
+* SYNOPSIS
+*\cs
+*
+*
+* vbiStatus_t vbiVbSuspend
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbReset(), vbiVbRestart()
+*/
+
+vbiVbSuspend:
+	movl    $VBI_SYS_vbSuspend,%eax		/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbReset - Reset a virtual board's core
+*
+* This routine makes a hypercall in order to reset one or more cores that exist
+* within the specified virtual board. Calling this function puts the target core(s)
+* program counter to it's ENTRY function. The ENTRY function is determined based on
+* the loaded binary image. A core does not execute beyond it's ENTRY function
+* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
+* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+* the third argument to this routine.
+* The hypercall sends a message to a manager that provides VB managment services.
+* This function will return only after all victim cores are reset unless the
+* operation fails to complete. The order of which the victim cores are reset is not
+* determined. The second argument identifies the cores to perform the operation on.
+* The value of the second argument should be set to one of the following:
+*
+*\ms
+*\m -
+* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+*\m -
+* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
+*\m -
+* A valid core number: Reset the specified core that exist within the Virtual Board.
+*\me
+*
+* The third argument argument passed to this function specifies options that are
+* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
+* one of the following or a combination:
+*
+*\ms
+*\m -
+* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+*\m -
+* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+*\me
+*
+*
+* IMPORTANT:
+* If a user chooses to restart core without reloading the executable image then
+* the data section must be restored to prevent critical errors. It is the guest OS's
+* responsibility to clear the bss data sections in such scenario.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbReset
+*    (
+*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
+*    vbiCore_t     core,            /@ Core within the VB           @/
+*    uint32_t     options   /@ reload , start options       @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
+*/
+
+vbiVbReset:
+        movl    $VBI_SYS_vbReset,%eax            /* system call number */
+        push    $3                              /* number of arguments */
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/*******************************************************************************
+*
+* vbiVbRestart - Restart a virtual board's core
+*
+* This routine makes a hypercall in order to restart a virtual cores from reset.
+* It's called to start running a core or cores that were previously reset by
+* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
+* function retrieved from the corresponding binary image.
+* This function will return only after  all cores are out of reset unless the
+* operation fails to complete.  The second argument represents the cores to restart.
+* For restarting every core in reset mode within the specified VB the second
+* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
+* VB then the core number must be passed in the second argument.
+*
+* This hypercall sends a message to a manager that provides VB managment
+* services.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbRestart
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend(), vbiVbReset()
+*/
+
+vbiVbRestart:
+        movl    $VBI_SYS_vbRestart,%eax            /* system call number */
+        push    $3                              /* number of arguments */
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/*******************************************************************************
+*
+* vbiVbResume - Resume a virtual board's core
+*
+* This routine makes a hypercall in order to resume one or cores within
+* the specified virtual board. It reactivates a cores or cores that were
+* previously suspended by calling vbiVbResume(). This function will return only
+* after all victim cores are resumed unless the operation fails. The order of
+* which the cores are resumed is not determined. The second argument may a
+* magic number instead of a valid core number to indicate that the operation
+* is intended for more than one core. For resuming every core within the
+* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
+* This implies to resume every core within the specified VB. Using this option
+* when some of the cores within the VB are already running is not considered
+* as programming error.
+*
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiVbResume
+*    (
+*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
+*    vbiCore_t     core   /@ Core within the VB         @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERRNO:
+*
+* SEE ALSO: vbiVbResume(), vbiVbSuspend()
+*/
+
+vbiVbResume:
+        movl    $VBI_SYS_vbResume,%eax            /* system call number	*/
+        push    $2                              /* number of arguments	*/
+
+        vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+        ret
+
+/******************************************************************************
+*
+* vbiHyIoctl - hypervisor ioctl call
+*
+* This system call interfaces to the general purpose hypervisor ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_HYIOCTL_GETPID
+*     VBI_HYIOCTL_GETPRIORITY
+*     VBI_HYIOCTL_GETSTATS
+*     VBI_HYIOCTL_PADDR
+*		
+* C interface:
+*
+*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*               void *arg1,         /@ address of information @/
+*               void *arg2,         /@ address of information @/
+*               void *arg3,         /@ address of information @/
+*               void *arg4)         /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiHyIoctl:
+	movl    $VBI_SYS_hyIoctl,%eax		/* system call number */
+	push	$5				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiIoapicIoctl - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC ioctl
+* function.
+*
+* Possible ioctl commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*		
+* C interface:
+*
+*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
+*                   unsigned arg1,      /@ address of information @/
+*                   unsigned arg2)      /@ address of information @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiIoapicIoctl:
+	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiIoapicOp - virtual IO APIC ioctl call
+*
+* This system call interfaces to the virtual IO APIC.
+*
+* function.
+*
+* Possible commands:
+*     VBI_IOAPICIOCTL_UNMASK
+*     VBI_IOAPICIOCTL_SEND
+*     VBI_IOAPICIOCTL_MASK
+*
+* C interface:
+*
+*   vbiIoapicOp	    (uint32_t cmd,      /@ the operation command     @/
+*                   vbiIrq_t irq,       /@ irq number                @/
+*                   uint32_t filter,    /@ filter                    @/
+*                   vbiVb_t  vbId,      /@ target vb id              @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiIoapicOp:
+	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/******************************************************************************
+*
+* vbiCtxctl - hypervisor context control call
+*
+* This system call interfaces to the general purpose hypervisor context
+* control function.
+*
+* Possbile operations:
+*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+*
+* C interface:
+*
+*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
+*		 void *arg)		 /@ address of argument @/
+*
+* Returns: ioctl specific value
+*
+*/
+
+vbiCtxctl:
+	movl    $VBI_SYS_ctxctl,%eax		/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiMemAttrSet - Set protection for a page of memory
+*
+* This routine makes a hypercall to set the MMU attribures for the specified
+* memory range. The possible attributes one or a combinarion of the following:
+* 
+* VBI_MMU_PROT_READ -  allow supervisor and user read
+* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrSet 
+*		(
+*		void	 *gaddr,	/@ Address of page to change attr   @/
+*		size_t   length,	/@ length of address		    @/
+*		uint32_t attr		/@ mmu attributes to set	    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+vbiMmuAttrSet:
+	movl    $VBI_SYS_mmu_attr_set,%eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiMemAttrGet - Get MMU page protections
+*
+* This routine makes a hypercall to retrieve the MMU attributes associated for
+* the page where the specified address is mapped. This is not the VMMU
+* attributes. A guest OS has direct access to the mapping table of its VMMU
+* therefore a hypercall is not necessary.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemAttrGet 
+*		(
+*		void	 *gaddr		/@ Address of page to change attr   @/
+*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
+*		)
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+*/
+
+vbiMmuAttrGet:
+	movl    $VBI_SYS_mmu_attr_get,%eax	/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiNsOp - virtua board name service call
+*
+* This system call interfaces to the virtual board
+*
+* commands:
+*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
+*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
+*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
+*				
+* C interface:
+*
+*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
+*	    char * name,		    /@ the service name		@/
+*	    uint32_t revision,	    /@ service revision		@/
+*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
+*	  )
+*
+* Returns: OK or ERROR in case of failure
+*
+*/
+
+vbiNsOp:
+	movl    $VBI_SYS_ns_op, %eax		/* system call number */
+	push	$4				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbMemoryWrite - copy data to a remote board's memory
+*
+* This routine makes a hypercall to copy to a remote board memory. If the
+* VBI_DCACHE_FLUSH is set in the control memory control structure then this
+* routine flushes the data caches lines corresponding to the range of memory
+* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
+* cache lines corresponding to the range of address is invalidated after the
+* memory is copied. Invalidating the instruction is required if data containing
+* is updated since the instruction cache is not aware of the content in data
+* cache. Therefore flushing the data cache ensures that memory contains the
+* updated data and invalidating the instruction cache ensures that the stale
+* values in the instruction cache is thrown away. 
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+* 
+* 
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	@/
+*   void	*pAddress;	    /@ address of calling context	@/
+*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
+*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
+*   uint32_t	flags;		    /@ data/instruction flush option	@/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryWrite 
+*	(
+*	VBI_MEM_CTL	*memCtl, 
+*	vbiVb_t		targetBoard 
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+vbiVbMemoryWrite:
+	movl    $VBI_SYS_memWrite_op, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbMemoryRead - Read a virtual board's memory
+*
+* This routine makes a hypercall to read a remote board's memory. The memory control
+* structure contains information about the target memory to read and the destination
+* buffer that hypervisor must populate with the data read. This routine is used
+* to copy data from a remote VB. It is the user's responsability to ensure that
+* the memory read is accessed orthogonally.
+* The sizeIn parameter specifies the number of bytes desired to be copied. 
+* The sizeOut parameter indicates the number of bytes successfully copied.
+* A user may set the sizeOut parameter to zero if the output size is not of
+* interest otherwise to a value different than zero.
+*
+* struct vbiMemCtl
+*   {
+*   void	*pBuffer;	    /@ address of target context	    @/
+*   void	*pAddress;	    /@ address of calling context	    @/
+*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
+*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
+*   uint32_t	reserved;	    /@ reserved for future use		    @/
+*    } VBI_MEM_CTL;
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiVbMemoryRead 
+*	(
+*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
+*	vbiVb_t	    targetBoard	    /@ target board				@/
+*	)
+*
+*\ce
+*
+* RETURNS: returns OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+vbiVbMemoryRead:
+	movl    $VBI_SYS_memRead_op, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiDebugShellStart - start the hypervisor debug shell
+*
+* This routine sends a message to the hypervisor debug shell manager in order to
+* start the WRHV shell program. The shell program spins therefore does not share
+* the processor with any other WRHV context. By default a caller of this routine
+* is detached to allow the caling core to continue executing (as long as the are not
+* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
+* specified to force the caller virtual board core to block while the shell program
+* is running.
+*
+* SYNOPSIS
+*\cs
+*
+* void vbiDebugShellStart
+*          (
+*          uint32_t  flags /@ detach by default @/
+*          )
+*
+*\ce
+*
+* RETURNS: N/A
+*
+*
+* SEE ALSO: 
+*/
+
+vbiDebugShellStart:
+
+	movl    $VBI_SYS_dbgShStart, %eax	/* system call number */
+	push	$1				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* SYNOPSIS
+* VBI X86 Architecture Supplements
+*\cs
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*\sh VB_ARCH_CONTROL_REGS definition
+*
+*The control registers type used for vbiVbRegister[Read:write] API's
+*
+*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
+*    {
+*    uint32_t  edi;		/@ 00: general register		@/
+*    uint32_t  esi;		/@ 04: general register		@/
+*    uint32_t  ebp;		/@ 08: frame pointer register	@/
+*    uint32_t  esp;		/@ 0C: stack pointer register	@/
+*    uint32_t  ebx;		/@ 10: general register		@/
+*    uint32_t  edx;		/@ 14: general register		@/
+*    uint32_t  ecx;		/@ 18: general register		@/
+*    uint32_t  eax;		/@ 1C: general register		@/
+*    uint32_t  eflags;		/@ 20: status register		@/
+*    INSTR *pc;			/@ 24: program counter		@/
+*    uint32_t  cr0;		/@ 28: control register 0	@/
+*    uint32_t  cr2;		/@ 2C: control register 2	@/
+*    uint32_t  cr3;		/@ 30: control register 3	@/
+*    uint32_t  cr4;		/@ 34: control register 4	@/
+*    uint32_t  cs;		/@ 28: code segment		@/
+*    uint32_t  ds;		/@ 3C: data segment		@/
+*    uint32_t  ss;		/@ 40: stack segment		@/
+*    uint32_t  es;		/@ 44: E segment		@/
+*    uint32_t  fs;		/@ 48: F segment		@/
+*    uint32_t  gs;		/@ 4C: G segment		@/
+*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
+*    } VB_ARCH_CONTROL_REGS;
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES:
+*
+* SEE ALSO: 
+*/
+
+vbiVbRegisterRead:
+
+	movl    $VBI_SYS_RegsRead_op, %eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+* VBI X86 Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*
+*\sh VB_ARCH_CONTROL_REGS definition
+*
+*The control registers type used for vbiVbRegister[Read:write] API's
+*
+*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
+*    {
+*    uint32_t  edi;		/@ 00: general register		@/
+*    uint32_t  esi;		/@ 04: general register		@/
+*    uint32_t  ebp;		/@ 08: frame pointer register	@/
+*    uint32_t  esp;		/@ 0C: stack pointer register	@/
+*    uint32_t  ebx;		/@ 10: general register		@/
+*    uint32_t  edx;		/@ 14: general register		@/
+*    uint32_t  ecx;		/@ 18: general register		@/
+*    uint32_t  eax;		/@ 1C: general register		@/
+*    uint32_t  eflags;		/@ 20: status register		@/
+*    INSTR *pc;			/@ 24: program counter		@/
+*    uint32_t  cr0;		/@ 28: control register 0	@/
+*    uint32_t  cr2;		/@ 2C: control register 2	@/
+*    uint32_t  cr3;		/@ 30: control register 3	@/
+*    uint32_t  cr4;		/@ 34: control register 4	@/
+*    uint32_t  cs;		/@ 28: code segment		@/
+*    uint32_t  ds;		/@ 3C: data segment		@/
+*    uint32_t  ss;		/@ 40: stack segment		@/
+*    uint32_t  es;		/@ 44: E segment		@/
+*    uint32_t  fs;		/@ 48: F segment		@/
+*    uint32_t  gs;		/@ 4C: G segment		@/
+*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: 
+*/
+
+vbiVbRegisterWrite:
+	movl    $VBI_SYS_RegsWrite_op, %eax	/* system call number */
+	push	$3				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/*******************************************************************************
+*
+* vbiVcoreIntRed_op - redirect an irq to another vcore
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVcoreIntRed_op 
+*	(
+*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
+*	vbiCore_t		core	/@ destination vcore		 @/
+*	)
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: 
+*
+* SEE ALSO: vbiVioapicIntRedirect()
+* 
+*\NOMANUAL
+*/
+vbiVcoreIntRed_op:
+
+	movl    $VBI_SYS_intRedirect, %eax	/* system call number */
+	push	$2				/* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
+
+/******************************************************************************
+*
+* vbiVtlbOp - execute a specified VTLB operation
+*
+* This system call executed the specified VTLB operation
+*
+* C interface:
+*
+*   vbiVtlbOp (
+*            unsigned int op,          /@ VTLB operation @/
+*            unsigned long arg1,       /@ VTLB operation argument 1 @/
+*            unsigned long arg2,       /@ VTLB operation argument 2 @/
+*            unsigned long arg3                /@ VTLB operation argument 3 @/
+*            )
+*
+* Returns: OK or ERROR
+*/
+
+vbiVtlbOp:
+	movl    $VBI_SYS_vtlb_op, %eax          /* system call number */
+	pushl   $4                              /* number of arguments */
+
+	vmcall
+
+	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+
+	ret
diff --git a/include/asm-x86/vbiX86Arch.h b/include/asm-x86/vbiX86Arch.h
new file mode 100644
index 0000000..4cc6e41
--- /dev/null
+++ b/include/asm-x86/vbiX86Arch.h
@@ -0,0 +1,192 @@
+/* vbiX86Arch.h - x86 architecture specific definitions */
+
+/* Copyright 2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01h,26aug09,mmi  fix WIND00178026: update file name
+01g,17aug09,md   fix comments
+01f,14aug09,md   update to match hypervisor version
+01e,28jul09,mpk  add hardware register set to vbi
+01d,08jun09,md   add define for maximum number of cores
+01c,25may09,md   add byte order define
+01b,06feb09,mmi  add MAX interrupts definition
+01a,14jan09,mmi  created
+*/
+
+#ifndef __INCvbiX86Archh
+#define __INCvbiX86Archh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef _ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_HREG_SET - hardware register set, for read/write
+*
+* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
+* another VB
+* 
+* SYNOPSIS
+*
+* VB hardware register set C data structure type definition
+*
+*\cs
+*     typedef struct		/@ VB_REG_SET - used for sys_regsRead/Write @/
+*         {
+*         uint32_t  eax;	/@ 00: general register		@/
+*         uint32_t  ebx;	/@ 04: general register		@/
+*         uint32_t  ecx;	/@ 08: general register		@/
+*         uint32_t  edx;	/@ 0C: general register		@/
+*         uint32_t  esi;	/@ 10: general register		@/
+*         uint32_t  edi;	/@ 14: general register		@/
+*         uint32_t  eip;	/@ 18: program counter		@/
+*         uint32_t  ebp;	/@ 1C: frame pointer register	@/
+*         uint32_t  esp;	/@ 20: stack pointer register	@/
+*         uint32_t  eflags;	/@ 24: status register		@/
+*         uint32_t  cr0;	/@ 28: control register 0	@/
+*         uint32_t  cr3;	/@ 2C: control register 3	@/
+*         uint32_t  cr4;	/@ 30: control register 4	@/
+*         uint32_t  idtr;	/@ 34: IDT task register	@/
+*         uint32_t  gdtr;	/@ 38: GDT task register	@/
+*         uint32_t  ldtr;	/@ 3C: LDT task register	@/
+*         uint32_t  cs;		/@ 40: code segment		@/
+*         uint32_t  ss;		/@ 44: stack segment		@/
+*         uint32_t  ds;		/@ 48: data segment		@/
+*         uint32_t  es;		/@ 4C: E segment		@/
+*         uint32_t  fs;		/@ 50: F segment		@/
+*         uint32_t  gs;		/@ 54: G segment		@/
+*         uint32_t  tr;		/@ 58: task register		@/
+*         } VB_HREG_SET;
+*
+*\ce
+* SEE ALSO: NONE
+* 
+*/
+
+typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
+    {
+    uint32_t  eax;		/* 00: general register		*/
+    uint32_t  ebx;		/* 04: general register		*/
+    uint32_t  ecx;		/* 08: general register		*/
+    uint32_t  edx;		/* 0C: general register		*/
+    uint32_t  esi;		/* 10: general register		*/
+    uint32_t  edi;		/* 14: general register		*/
+    uint32_t  eip;		/* 18: program counter		*/
+    uint32_t  ebp;		/* 1C: frame pointer register	*/
+    uint32_t  esp;		/* 20: stack pointer register	*/
+    uint32_t  eflags;		/* 24: status register		*/
+    uint32_t  cr0;		/* 28: control register 0	*/
+    uint32_t  cr3;		/* 2C: control register 3	*/
+    uint32_t  cr4;		/* 30: control register 4	*/
+    uint32_t  idtr;		/* 34: IDT task register	*/
+    uint32_t  gdtr;		/* 38: GDT task register	*/
+    uint32_t  ldtr;		/* 3C: LDT task register	*/
+    uint32_t  cs;		/* 40: code segment		*/
+    uint32_t  ss;		/* 44: stack segment		*/
+    uint32_t  ds;		/* 48: data segment		*/
+    uint32_t  es;		/* 4C: E segment		*/
+    uint32_t  fs;		/* 50: F segment		*/
+    uint32_t  gs;		/* 54: G segment		*/
+    uint32_t  tr;		/* 58: task register		*/
+    } VB_HREG_SET;
+#endif /* _ASMLANGUAGE */
+
+/* x86 uses little endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_LITTLE_ENDIAN
+
+#define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define VBI_ARCH_EXC_TABLE_SIZE     32
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)            
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+#define VBI_IN_DIVIDE_ERROR		 0
+#define VBI_IN_DEBUG			 1
+#define VBI_IN_NON_MASKABLE		 2
+#define VBI_IN_BREAKPOINT		 3
+#define VBI_IN_OVERFLOW			 4
+#define VBI_IN_BOUND			 5
+#define VBI_IN_INVALID_OPCODE		 6
+#define VBI_IN_NO_DEVICE		 7
+#define VBI_IN_DOUBLE_FAULT		 8
+#define VBI_IN_CP_OVERRUN		 9
+#define VBI_IN_INVALID_TSS		10
+#define VBI_IN_NO_SEGMENT		11
+#define VBI_IN_STACK_FAULT		12
+#define VBI_IN_PROTECTION_FAULT		13
+#define VBI_IN_PAGE_FAULT		14
+#define VBI_IN_RESERVED			15
+#define VBI_IN_CP_ERROR			16
+#define VBI_IN_ALIGNMENT		17
+#define VBI_IN_MACHINE_CHECK		18
+#define VBI_IN_SIMD			19
+
+/* 19-31 Intel reserved exceptions  */
+
+/* 32-255 user defined exceptions  */
+
+#define VBI_IN_EXT_IRQ_BASE		32	/* local timer interrupt */
+
+#define VBI_IN_EXT_IRQ0			(VBI_IN_EXT_IRQ_BASE + 0)	
+#define VBI_IN_EXT_IRQ1			(VBI_IN_EXT_IRQ_BASE + 1)	
+#define VBI_IN_EXT_IRQ2			(VBI_IN_EXT_IRQ_BASE + 2)	
+#define VBI_IN_EXT_IRQ3 		(VBI_IN_EXT_IRQ_BASE + 3)	
+#define VBI_IN_EXT_IRQ4			(VBI_IN_EXT_IRQ_BASE + 4)	
+#define VBI_IN_EXT_IRQ5			(VBI_IN_EXT_IRQ_BASE + 5)	
+#define VBI_IN_EXT_IRQ6			(VBI_IN_EXT_IRQ_BASE + 6)	
+#define VBI_IN_EXT_IRQ7			(VBI_IN_EXT_IRQ_BASE + 7)	
+#define VBI_IN_EXT_IRQ8			(VBI_IN_EXT_IRQ_BASE + 8)	
+#define VBI_IN_EXT_IRQ9			(VBI_IN_EXT_IRQ_BASE + 9)	
+#define VBI_IN_EXT_IRQ10		(VBI_IN_EXT_IRQ_BASE + 10)	
+#define VBI_IN_EXT_IRQ11		(VBI_IN_EXT_IRQ_BASE + 11)	
+#define VBI_IN_EXT_IRQ12		(VBI_IN_EXT_IRQ_BASE + 12)	
+#define VBI_IN_EXT_IRQ13		(VBI_IN_EXT_IRQ_BASE + 13)	
+#define VBI_IN_EXT_IRQ14		(VBI_IN_EXT_IRQ_BASE + 14)	
+#define VBI_IN_EXT_IRQ15		(VBI_IN_EXT_IRQ_BASE + 15)	
+#define VBI_IN_EXT_IRQ16		(VBI_IN_EXT_IRQ_BASE + 16)	
+#define VBI_IN_EXT_IRQ17		(VBI_IN_EXT_IRQ_BASE + 17)	
+#define VBI_IN_EXT_IRQ18		(VBI_IN_EXT_IRQ_BASE + 18)	
+#define VBI_IN_EXT_IRQ19		(VBI_IN_EXT_IRQ_BASE + 19)	
+#define VBI_IN_EXT_IRQ20		(VBI_IN_EXT_IRQ_BASE + 20)	
+#define VBI_IN_EXT_IRQ21		(VBI_IN_EXT_IRQ_BASE + 21)	
+#define VBI_IN_EXT_IRQ22		(VBI_IN_EXT_IRQ_BASE + 22)	
+#define VBI_IN_EXT_IRQ23		(VBI_IN_EXT_IRQ_BASE + 23)	
+#define VBI_IN_EXT_IRQ24		(VBI_IN_EXT_IRQ_BASE + 24)	
+#define VBI_IN_EXT_IRQ25		(VBI_IN_EXT_IRQ_BASE + 25)	
+#define VBI_IN_EXT_IRQ26		(VBI_IN_EXT_IRQ_BASE + 26)	
+#define VBI_IN_EXT_IRQ27		(VBI_IN_EXT_IRQ_BASE + 27)	
+#define VBI_IN_EXT_IRQ28		(VBI_IN_EXT_IRQ_BASE + 28)	
+#define VBI_IN_EXT_IRQ29		(VBI_IN_EXT_IRQ_BASE + 29)	
+#define VBI_IN_EXT_IRQ30		(VBI_IN_EXT_IRQ_BASE + 30)	
+#define VBI_IN_EXT_IRQ31		(VBI_IN_EXT_IRQ_BASE + 31)	
+#define VBI_IN_EXT_IRQ32		(VBI_IN_EXT_IRQ_BASE + 32)	
+#define VBI_IN_EXT_IRQ33		(VBI_IN_EXT_IRQ_BASE + 33)	
+#define VBI_IN_EXT_IRQ34		(VBI_IN_EXT_IRQ_BASE + 34)	
+#define VBI_IN_EXT_IRQ35		(VBI_IN_EXT_IRQ_BASE + 35)	
+#define VBI_IN_EXT_IRQ36		(VBI_IN_EXT_IRQ_BASE + 36)	
+#define VBI_IN_EXT_IRQ37		(VBI_IN_EXT_IRQ_BASE + 37)	
+#define VBI_IN_EXT_IRQ38		(VBI_IN_EXT_IRQ_BASE + 38)	
+#define VBI_IN_EXT_IRQ39		(VBI_IN_EXT_IRQ_BASE + 39)	
+#define VBI_IN_EXT_IRQ40		(VBI_IN_EXT_IRQ_BASE + 40)	
+#define VBI_IN_EXT_IRQ41		(VBI_IN_EXT_IRQ_BASE + 41)	
+#define VBI_IN_EXT_IRQ42		(VBI_IN_EXT_IRQ_BASE + 42)	
+#define VBI_IN_EXT_IRQ43		(VBI_IN_EXT_IRQ_BASE + 43)	
+#define VBI_IN_EXT_IRQ44		(VBI_IN_EXT_IRQ_BASE + 44)	
+#define VBI_IN_EXT_IRQ45		(VBI_IN_EXT_IRQ_BASE + 45)	
+#define VBI_IN_EXT_IRQ46		(VBI_IN_EXT_IRQ_BASE + 46)	
+#define VBI_IN_EXT_IRQ47		(VBI_IN_EXT_IRQ_BASE + 47)	
+
+/* timer vector */
+
+#define VBI_CLOCK_TIMER_VECTOR		(0)
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)    
+#ifdef __cplusplus
+}
+#endif
+#endif /* __INCVbiX86Archh */
-- 
1.6.3.3

