From aadeb80e5078ef86a59d3b5a2e03052bc979ea34 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 22 Oct 2009 14:47:11 -0400
Subject: [PATCH 6/8] vbi: cosmetic cleanup, whitespace, redundant comments, etc.

Some files had complete copies of the relevant structs encoded
a second time within the comments above the struct, with no
extra descriptions or value adds.  The comment blocks have been
cleaned up/pruned/reformatted to suck less, some of the trailing
whitespace crimes were removed, and some struct entries have been
shuffled from 4 spaces to tabs as well.

This is a big diff, but no functional code changes are made by
this commit.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h | 1006 +++++++++--------------
 arch/powerpc/kernel/vbi/show.c      |   42 +-
 arch/x86/kernel/vbi/syscalls.S      | 1546 ++++++++++++-----------------------
 include/asm-x86/arch_vbi.h          |  108 +--
 include/vbi/errors.h                |    4 +-
 include/vbi/interface.h             |  942 +++++++++-------------
 include/vbi/io_apic.h               |  116 ++--
 include/vbi/private.h               |   46 +-
 include/vbi/shmem.h                 |   23 +-
 include/vbi/syscall.h               |  150 ++--
 include/vbi/syscalls.h              |  116 ++--
 include/vbi/types.h                 |   20 +-
 include/vbi/vbi.h                   | 1220 ++++++++++------------------
 include/vbi/vmmu.h                  |  163 ++--
 kernel/vbi/show.c                   |  392 +++------
 15 files changed, 2211 insertions(+), 3683 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index aa4e82f..752e492 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -45,7 +45,7 @@
 
 /* VIOAPIC number of entries */
 
-#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+#define VB_VIOAPIC_ENTRIES_SIZE		    64
 
 #define _WRHV_ARCH_HAS_STATUS_REGS	    1
 #define _WRHV_ARCH_HAS_CTRL_REGS	    1
@@ -66,31 +66,31 @@
 #define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
 #define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
 #define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
-#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
-#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
-#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
-#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
-#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
-#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
-#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
-#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
-#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
-#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
-#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
-#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
-#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
-#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
-#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
-#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
-#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
-#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
-#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
-#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
-#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
-#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
-#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
-#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
-#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
+#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15))
+#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16))
+#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17))
+#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18))
+#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19))
+#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20))
+#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21))
+#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22))
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23))
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24))
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25))
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26))
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27))
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28))
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29))
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30))
+#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31))
+#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32))
+#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33))
+#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34))
+#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35))
+#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36))
+#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37))
+#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38))
+#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39))
 
 
 #define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
@@ -159,385 +159,234 @@
 #define VB_CONTROL_REGS_ACCESS(base, field)	\
 	base->vbControlRegs.field		
 
-/*******************************************************************************
-*
-* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
-*
-* Virtual board emulated control registers. These registers are used
-* by a guest running on hypervisor to configure the virtual CPU register.
-*
-* SYNOPSIS
-*
-* PPC Control structure graphical illustration
-*
-*        _______________   
-*       |       PC      |   
-*       |---------------|
-*       |       MSR     |	    
-*       |---------------|
-*       |       CR      |
-*       |---------------|
-*       |		|
-*       |general purpose|
-*       |     r[0:13]   | 
-*       |		|
-*       |---------------|
-*       |emulated MSR   |
-*       |---------------|
-*       |       dbsr    |
-*       |---------------|
-*       | dbcr[0:2]     |
-*       |---------------|
-*       |IAC[1:2]       |
-*       |---------------|
-*       |DAC[1:2]       |
-*       |---------------|
-*       |reserved[0:9]  |
-*       |---------------|
-*
-*
-*
-* Virtual core's control C data structure type definition
-*
-*
-* VB_STATUS structure definition
-*
-* typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
-*
-*    uint32_t srr0;	/@  0: PC		    @/
-*    uint32_t srr1;	/@  1: MSR		    @/
-*    uint32_t cr;	/@  2: condition registers	    @/
-*    uint32_t r0;	/@  3: General register R0	    @/
-*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;	/@  5: General register R2	    @/
-*    uint32_t r3;	/@  6: General register R3	    @/
-*    uint32_t r4;	/@  7: General register R4	    @/
-*    uint32_t r5;	/@  8: General register R5	    @/
-*    uint32_t r6;	/@  9: General register R6	    @/
-*    uint32_t r7;	/@ 10: General register R7	    @/
-*    uint32_t r8;	/@ 11: General register R8	    @/
-*    uint32_t r9;	/@ 12: General register R9	    @/
-*    uint32_t r10;	/@ 13: General register R10	    @/
-*    uint32_t r11;	/@ 14: General register R11	    @/
-*    uint32_t r12;	/@ 15: General register R12	    @/
-*    uint32_t r13;	/@ 16: General register R13	    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbsr; /@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2		    @/
-*
-*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
-*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
-*
-*    /@ data address compare registers DAC1-DAC2.	        @/
-*
-*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
-*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
-*
-*    /@ reserved fields for future use			    @/
-*
-*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*
-*
-*
-*VB_ARCH_CONTROL_REGS, architecture supplement document 
-*
-*/
+/*
+ *
+ * VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
+ *
+ * Virtual board emulated control registers. These registers are used
+ * by a guest running on hypervisor to configure the virtual CPU register.
+ *
+ * PPC Control structure graphical illustration
+ *
+ *        _______________
+ *       |       PC      |
+ *       |---------------|
+ *       |       MSR     |	
+ *       |---------------|
+ *       |       CR      |
+ *       |---------------|
+ *       |		|
+ *       |general purpose|
+ *       |     r[0:13]   |
+ *       |		|
+ *       |---------------|
+ *       |emulated MSR   |
+ *       |---------------|
+ *       |       dbsr    |
+ *       |---------------|
+ *       | dbcr[0:2]     |
+ *       |---------------|
+ *       |IAC[1:2]       |
+ *       |---------------|
+ *       |DAC[1:2]       |
+ *       |---------------|
+ *       |reserved[0:9]  |
+ *       |---------------|
+ *
+ *
+ */
 
 typedef struct vbArchControlRegs
     {
 
     /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
 
-    uint32_t srr0;		/*  0: PC */
-    uint32_t srr1;		/*  1: MSR */
-    uint32_t cr;		/*  2: condition registers */
-    uint32_t r0;		/*  3: General register R0 */
-    uint32_t sp;		/*  4: General register R1 (stack pointer) */
-    uint32_t r2;		/*  5: General register R2 */
-    uint32_t r3;		/*  6: General register R3 */
-    uint32_t r4;		/*  7: General register R4 */
-    uint32_t r5;		/*  8: General register R5 */
-    uint32_t r6;		/*  9: General register R6 */
-    uint32_t r7;		/* 10: General register R7 */
-    uint32_t r8;		/* 11: General register R8 */
-    uint32_t r9;		/* 12: General register R9 */
-    uint32_t r10;		/* 13: General register R10 */
-    uint32_t r11;		/* 14: General register R11 */
-    uint32_t r12;		/* 15: General register R12 */
-    uint32_t r13;		/* 16: General register R13 */
+	uint32_t srr0;		/*  0: PC */
+	uint32_t srr1;		/*  1: MSR */
+	uint32_t cr;		/*  2: condition registers */
+	uint32_t r0;		/*  3: General register R0 */
+	uint32_t sp;		/*  4: General register R1 (stack pointer) */
+	uint32_t r2;		/*  5: General register R2 */
+	uint32_t r3;		/*  6: General register R3 */
+	uint32_t r4;		/*  7: General register R4 */
+	uint32_t r5;		/*  8: General register R5 */
+	uint32_t r6;		/*  9: General register R6 */
+	uint32_t r7;		/* 10: General register R7 */
+	uint32_t r8;		/* 11: General register R8 */
+	uint32_t r9;		/* 12: General register R9 */
+	uint32_t r10;		/* 13: General register R10 */
+	uint32_t r11;		/* 14: General register R11 */
+	uint32_t r12;		/* 15: General register R12 */
+	uint32_t r13;		/* 16: General register R13 */
 
     /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
 
-    uint32_t emsr;		/* 17: emulated MSR register */
+	uint32_t emsr;		/* 17: emulated MSR register */
 
     /* Debug control registers */
-    
-    uint32_t     dbsr; /* 18 - debug status register */
+
+	uint32_t     dbsr; /* 18 - debug status register */
 
     /* Debug control registers */
-    
-    uint32_t     dbcr0; /* 19 - debug control register 0 */
-    uint32_t     dbcr1; /* 20 - debug control register 1 */
-    uint32_t     dbcr2; /* 21 - debug control register 2 */
+
+	uint32_t     dbcr0; /* 19 - debug control register 0 */
+	uint32_t     dbcr1; /* 20 - debug control register 1 */
+	uint32_t     dbcr2; /* 21 - debug control register 2 */
 
     /* instruction address compare registers IAC1-IAC2 */
 
-    uint32_t     iac1; /* 22 - instructions access control 1 */
-    uint32_t     iac2; /* 23 - instructions access control 2 */
+	uint32_t     iac1; /* 22 - instructions access control 1 */
+	uint32_t     iac2; /* 23 - instructions access control 2 */
 
     /* data address compare registers DAC1-DAC2. */
 
-    uint32_t     dac1; /* 24 - instructions access control 3 */
-    uint32_t     dac2; /* 25 - instructions access control 4 */
+	uint32_t     dac1; /* 24 - instructions access control 3 */
+	uint32_t     dac2; /* 25 - instructions access control 4 */
 
     /* reserved fields for future use */
 
-    uint32_t reserved[10];      /* 26: Reserved */ 
+	uint32_t reserved[10];      /* 26: Reserved */
     } VB_ARCH_CONTROL_REGS;
 
-/*******************************************************************************
-*
-* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
-*
-* Virtual board emulated CPU status registers
-*
-* SYNOPSIS
-*
-* PPC Status structure graphical illustration
-*
-*        _______________   ---------------------------
-*       |    SRR0       |   
-*       |---------------|
-*       |    SRR1       |   Registers save by WRHV	
-*       |---------------|   before injecting an exception/interrupt
-*       |    CR		|
-*       |---------------|
-*       |    LR		|
-*       |---------------|
-*       |    r3		| 
-*       |---------------|
-*       |    r4         |
-*       |---------------|   ---------------------------
-*	|    mcsrr0	|	
-*       |---------------|  Registers saved duing exception handling
-*       |    mcssr1     |
-*       |---------------|
-*       |    esr        |
-*       |---------------|
-*       |    mcsr       |
-*       |---------------|
-*       |    mcar       |
-*       |---------------|
-*       |    dear       |
-*       |---------------|
-*       |    emsr       |
-*       |---------------|
-*       |    esrr0      |
-*       |---------------|
-*       |    esrr1      |
-*       |---------------|    -------------------------
-*       | reserved[8]   |      8 x 32bits for future enhencements
-*       |---------------|    -------------------------
-*       |    svr        |
-*       |---------------|
-*       |    pir        |
-*       |---------------|
-*       |    pvr        |    Configuration registers updated
-*       |---------------|    upon board creation    
-*       |    hid0       |  
-*       |---------------|
-*       |    hid1       |
-*       |---------------|
-*       |    buscr      |
-*       |---------------|       
-*       |    l1csr0     |
-*       |---------------|
-*       |    l1csr1     |
-*       |---------------|   --------------------------
-*       | reserved[0:8] | 9x 32bit
-*       |---------------|
-*
-*
-*
-* Virtual core's status C data structure type definition
-*
-*
-* VB_ARCH_STATUS_REGS structure definition
-*
-* typedef struct archStatusRegs
-*    {
-*
-*    /@ 
-*     @ registers saved by WRHV for all interrupts exceptions
-*     @ before setting the PC in the virtual board to the exception/interrupt
-*     @ vector address
-*     @/
-*
-*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
-*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
-*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
-*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
-*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
-*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
-*
-*    /@ Registers saved by WRHV during exception processing only    @/
-*
-*    uint32_t mcsrr0; /@  6:			    @/
-*    uint32_t mcsrr1; /@  7:			    @/
-*    uint32_t esr;    /@  8:			    @/
-*    uint32_t mcsr;   /@  9:			    @/
-*    uint32_t mcar;   /@ 10			@/
-*    uint32_t dear;   /@ 11:			    @/
-*    uint32_t emsr;   /@ 12:			    @/
-*    uint32_t esrr0;  /@ 13:			    @/
-*    uint32_t esrr1;  /@ 14:			    @/
-*
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved1[8]; /@ 15 - 22			@/
-*
-*    /@ Configuration registers (only updated upon board creation   @/
-*
-*    uint32_t svr;     /@ 23			    @/     
-*    uint32_t pir;     /@ 24			    @/
-*    uint32_t pvr;     /@ 25			    @/  
-*    uint32_t hid0;    /@ 26			    @/
-*    uint32_t hid1;    /@ 27			    @/
-*    uint32_t bucsr;   /@ 28			    @/
-*    uint32_t l1csr0;  /@ 29			    @/
-*    uint32_t l1csr1;  /@ 30			    @/
-*    
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved2[9]; /@ 31 - 39			@/
-*
-*    } VB_ARCH_STATUS_REGS; 
-*
-*
-*
-*
-*VB_STATUS 
-*
-*/
+/*
+ *
+ * VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
+ *
+ * Virtual board emulated CPU status registers
+ *
+ * PPC Status structure graphical illustration
+ *
+ *        _______________   ---------------------------
+ *       |    SRR0       |
+ *       |---------------|
+ *       |    SRR1       |   Registers save by WRHV	
+ *       |---------------|   before injecting an exception/interrupt
+ *       |    CR         |
+ *       |---------------|
+ *       |    LR         |
+ *       |---------------|
+ *       |    r3         |
+ *       |---------------|
+ *       |    r4         |
+ *       |---------------|   ---------------------------
+ *       |    mcsrr0     |	
+ *       |---------------|  Registers saved duing exception handling
+ *       |    mcssr1     |
+ *       |---------------|
+ *       |    esr        |
+ *       |---------------|
+ *       |    mcsr       |
+ *       |---------------|
+ *       |    mcar       |
+ *       |---------------|
+ *       |    dear       |
+ *       |---------------|
+ *       |    emsr       |
+ *       |---------------|
+ *       |    esrr0      |
+ *       |---------------|
+ *       |    esrr1      |
+ *       |---------------|    -------------------------
+ *       | reserved[8]   |      8 x 32bits for future enhencements
+ *       |---------------|    -------------------------
+ *       |    svr        |
+ *       |---------------|
+ *       |    pir        |
+ *       |---------------|
+ *       |    pvr        |    Configuration registers updated
+ *       |---------------|    upon board creation
+ *       |    hid0       |
+ *       |---------------|
+ *       |    hid1       |
+ *       |---------------|
+ *       |    buscr      |
+ *       |---------------|
+ *       |    l1csr0     |
+ *       |---------------|
+ *       |    l1csr1     |
+ *       |---------------|   --------------------------
+ *       | reserved[0:8] | 9x 32bit
+ *       |---------------|
+ *
+ */
 
 typedef struct archStatusRegs
-    {
+{
 
-    /* 
-     * registers saved by Razor for all interrupts exceptions
+    /*
+     * registers saved by hypervisor for all interrupts exceptions
      * before setting the PC in the virtual board to the exception/interrupt
      * vector address
      */
 
-    uint32_t srr0; /* 0: PC at time of the interrupt */
-    uint32_t srr1; /* 1: MSR at time of the interrupt */
-    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
-    uint32_t lr;   /* 3: Link register at time of the interrupt */
-    uint32_t r3;   /* 4: R3 at time of the interrupt */
-    uint32_t r4;   /* 5: R4 at time of the interrupt */
-
-    /* Registers saved by Razor during exception processing only */
-
-    uint32_t mcsrr0; /*  6: */
-    uint32_t mcsrr1; /*  7: */
-    uint32_t esr;    /*  8: */
-    uint32_t mcsr;   /*  9: */
-    uint32_t mcar;   /* 10  */
-    uint32_t dear;   /* 11: */
-    uint32_t emsr;   /* 12: */
-    uint32_t esrr0;  /* 13: */
-    uint32_t esrr1;  /* 14: */
-
-/* 
+	uint32_t srr0; /* 0: PC at time of the interrupt */
+	uint32_t srr1; /* 1: MSR at time of the interrupt */
+	uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+	uint32_t lr;   /* 3: Link register at time of the interrupt */
+	uint32_t r3;   /* 4: R3 at time of the interrupt */
+	uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+    /* Registers saved by hypervisor during exception processing only */
+
+	uint32_t mcsrr0; /*  6: */
+	uint32_t mcsrr1; /*  7: */
+	uint32_t esr;    /*  8: */
+	uint32_t mcsr;   /*  9: */
+	uint32_t mcar;   /* 10  */
+	uint32_t dear;   /* 11: */
+	uint32_t emsr;   /* 12: */
+	uint32_t esrr0;  /* 13: */
+	uint32_t esrr1;  /* 14: */
+
+/*
  * keep this part in a separate structure in order to keep the offsets
  * to remain the same as in VB_STATUS
  */
 
     /* reserved fields for future use */
 
-    uint32_t reserved1[8]; /* 15 - 22  */
+	uint32_t reserved1[8]; /* 15 - 22  */
 
     /* Configuration registers (only updated upon board creation */
 
-    uint32_t svr;     /* 23 */     
-    uint32_t pir;     /* 24 */
-    uint32_t pvr;     /* 25 */  
-    uint32_t hid0;    /* 26 */
-    uint32_t hid1;    /* 27 */
-    uint32_t bucsr;   /* 28 */
-    uint32_t l1csr0;  /* 29 */
-    uint32_t l1csr1;  /* 30 */
-    
+	uint32_t svr;     /* 23 */
+	uint32_t pir;     /* 24 */
+	uint32_t pvr;     /* 25 */
+	uint32_t hid0;    /* 26 */
+	uint32_t hid1;    /* 27 */
+	uint32_t bucsr;   /* 28 */
+	uint32_t l1csr0;  /* 29 */
+	uint32_t l1csr1;  /* 30 */
+
     /* reserved fields for future use */
 
-    uint32_t reserved2[9]; /* 31 - 39 */
-
-    } VB_ARCH_STATUS_REGS; 
-
-
-/*******************************************************************************
-*
-* VBI_HREG_SET - hardware register set, for read/write
-*
-* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
-* another VB
-* 
-* SYNOPSIS
-*
-* VB hardware register set C data structure type definition
-*
-*
-*
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VBI_HREG_SET;
-* 
-*
-*
-*NONE
-* 
-*/
+	uint32_t reserved2[9]; /* 31 - 39 */
+
+} VB_ARCH_STATUS_REGS;
+
+
+/*
+ * VBI_HREG_SET - hardware register set, for read/write
+ *
+ * Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in
+ * another VB
+ *
+ */
 
 #define GREG_NUM	32	/* has 32 32/64-bit data registers */
 
 typedef struct
-    {
-    uint32_t gpr[GREG_NUM];	/* general purpose registers */
-    uint32_t msr;		/* machine state register */
-    uint32_t lr;		/* link register */
-    uint32_t ctr;		/* count register */
-    uint32_t pc;		/* program counter */
-    uint32_t cr;		/* condition register */
-    uint32_t xer;		/* fixed-point exception register */
-    uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
-    uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
-    } HREG_SET;
+{
+	uint32_t gpr[GREG_NUM];	/* general purpose registers */
+	uint32_t msr;		/* machine state register */
+	uint32_t lr;		/* link register */
+	uint32_t ctr;		/* count register */
+	uint32_t pc;		/* program counter */
+	uint32_t cr;		/* condition register */
+	uint32_t xer;		/* fixed-point exception register */
+	uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
+	uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+} HREG_SET;
 
 /* VBI_HREG_SET is same as HREG_SET in ppc */
 typedef HREG_SET VBI_HREG_SET;
@@ -548,15 +397,16 @@ typedef HREG_SET VBI_HREG_SET;
 #define VBI_MDIO_WRITE          MDIO_WRITE
 #define VBI_BSP_CLK_FREQ        BSP_CLK_FREQ
 
-/* This should exceed the number of IVOR registers defined in the hardware 
-* It also defined the size of the excVectorTable size 
-* VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000 */
+/* This should exceed the number of IVOR registers defined in the hardware
+ * It also defined the size of the excVectorTable size
+ * VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000
+ */
 #define VBI_ARCH_MAX_EXC_OFFSETS	64	
 
 typedef struct
-    {
-    uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
-    } VBI_EXC_OFFSETS_TABLE;
+{
+	uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
+} VBI_EXC_OFFSETS_TABLE;
 
 #ifdef CONFIG_WRHV
 typedef int32_t  status_t;      /* operation/function status */
@@ -568,27 +418,27 @@ extern status_t vbiExcOffsetsGet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
 /* common system wide message header structure */
 
 typedef struct vbi_msg_header {
-    uint32_t msgId;	/* message type identification */
-    uint32_t msgArg;	/* argument associated with message type */
+	uint32_t msgId;	/* message type identification */
+	uint32_t msgArg;	/* argument associated with message type */
 } VBI_MSG_HEADER;
 
 /* request message */
 
-typedef struct 
-    {
+typedef struct
+{
     VBI_MSG_HEADER hdr;			/* message header */
     uint32_t   request;			/* request type */
 
-    union 
+    union
 	{
-    	struct 
+    	struct
 	    {
 	    uint32_t bus;		
 	    uint32_t phyAddr;
 	    uint32_t regNum;
 	    uint32_t page;
 	    } mdioRead;
-    	struct 
+    	struct
 	    {
 	    uint32_t bus;		
 	    uint32_t phyAddr;
@@ -597,13 +447,13 @@ typedef struct
 	    uint32_t dataVal;
 	    } mdioWrite;
 #if 0 /* not supported for now */
-    	struct 
+    	struct
 	    {
 	    uint32_t bus;		
 	    uint32_t vbIntNum;
 	    HY_CTX *pCtx;
 	    } mdioIntEnable;
-    	struct 
+    	struct
 	    {
 	    uint32_t bus;	
 	    uint32_t vbIntNum;
@@ -611,104 +461,80 @@ typedef struct
 	    } mdioIntDisable;
 #endif
 	} arg;				
-    
-    } VBI_BSP_MSG;
 
-typedef struct 
-    {
+} VBI_BSP_MSG;
+
+typedef struct
+{
     VBI_MSG_HEADER hdr;			/* message header */
-    uint32_t   status;			/* request completion status */
-    uint32_t   dataVal;
-    } VBI_BSP_MSG_REPLY;
+	uint32_t   status;			/* request completion status */
+	uint32_t   dataVal;
+} VBI_BSP_MSG_REPLY;
 
 #else /*_ASMLANGUAGE */
 
-/*******************************************************************************
-*
-* VBI_CTX_LOAD - Load a guest context
-*
-* This routine is implemented as an assembly MACRO since it's callers can't
-* reference C functions. This MACRO  makes a hypercall to load a context for a guest
-* OS. The guest OS running on the core is expected to store a set of registers that
-* represent the new context to load in the it's control structure then call 
-* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
-* loaded from the control structure:
-*
-*
-*
-* VB_CONTROL_SRR0	     ------->  SRR0
-*
-* VB_CONTROL_SRR1	     -------> SRR1 
-*
-* VB_CONTROL_CR		     -------> CR
-*
-* VB_CONTROL_R0		     -------> R0
-*
-* VB_CONTROL_EMSR	     -------> MSR 
-*
-* VB_CONTROL_DBCR0	     -------> DBCR0 
-*
-* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
-* If interrupts are being reenabled then we ensure that any pending interrupts are
-* delivered before the new context is actived.
-*
-* Note that registers that are not saved by Hypervisor must be loaded by the guest
-* OS.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* void  VBI_CTX_LOAD () 
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
-*           VBI_INT_VCORE_STATE_GET()
-*/
+/*
+ *
+ * VBI_CTX_LOAD - Load a guest context
+ *
+ * This routine is implemented as an assembly MACRO since it's callers can't
+ * reference C functions. This MACRO  makes a hypercall to load a context for
+ * a guest * OS. The guest OS running on the core is expected to store a set
+ * of registers that represent the new context to load in the it's control
+ * structure then call VBI_CTX_LOAD() MACRO to switch to the new context.
+ * The Following are the registers loaded from the control structure:
+ *
+ * VB_CONTROL_SRR0	     ------->  SRR0
+ *
+ * VB_CONTROL_SRR1	     -------> SRR1
+ *
+ * VB_CONTROL_CR		     -------> CR
+ *
+ * VB_CONTROL_R0		     -------> R0
+ *
+ * VB_CONTROL_EMSR	     -------> MSR
+ *
+ * VB_CONTROL_DBCR0	     -------> DBCR0
+ *
+ * VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE
+ *
+ * If interrupts are being reenabled then we ensure that any pending
+ * interrupts are delivered before the new context is actived.
+ *
+ * Note that registers that are not saved by Hypervisor must be loaded
+ * by the guest OS.
+ *
+ */
 
 #define VBI_CTX_LOAD(reg)				    \
 	lis	reg, HI(VBI_SYS_ctx_load);		    \
 	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
 	sc
 
-/******************************************************************************
-*
-* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
-*
-* This MACRO disables the currently running core interrupts and returns the
-* previous interrupts state. The interrupt status field in wrhvVbControl
-* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
-* interrupts state is loaded to the register passed in as the first argument to
-* this MACRO. 
-* A hypercall is not needed to perform this operation. 
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
-*	{
-*	load -1 to reg1
-*	load wrhvVbControl address to reg2
-*       read the previous value and store in reg0
-*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
-*	}
-*
-*
-* RETURNS: TRUE is interrupts were locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
+/*
+ *
+ * VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+ *
+ * This MACRO disables the currently running core interrupts and returns the
+ * previous interrupts state. The interrupt status field in wrhvVbControl
+ * structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+ * interrupts state is loaded to the register passed in as the first argument to
+ * this MACRO.
+ * A hypercall is not needed to perform this operation.
+ *
+ *
+ * VBI_INT_VCORE_LOCK (reg0, reg1, reg2)
+ * {
+ *	load -1 to reg1
+ *	load wrhvVbControl address to reg2
+ *       read the previous value and store in reg0
+ *	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+ * }
+ *
+ *
+ * RETURNS: TRUE if interrupts were locked otherwise FALSE
+ *
+ */
 #define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
 	li	reg1, -1;				\
         lis     reg2, HIADJ(wrhvVbControl);		\
@@ -716,49 +542,39 @@ typedef struct
         lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
         stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
 
-/*******************************************************************************
-*
-* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
-*
-* This MACRO is implemented in assembly to enable a core's interrupts. It
-* enables the interrupts by clearing to zero the value in the core's control
-* structure and and makes a fast hypercall if need be. A hypercall is made only
-* if found that interrupts are pending. The pending interrupts are checked by
-* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
-* positive integer greater than zero indicates that interrupts are pending
-* which causes this macro to make a hypercall in order to drain the pending
-* interrupts. This MACRO expects two general purpose registers. The first 
-* register is used to load the value to store and the second is used for
-* holding the destination address of the control or status structure.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
-*	{
-*	load "0" to reg1
-*	load address of wrhvVbControl in reg0 
-*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
-*
-* checkStatus:
-*	load address of wrhvVbStatus in reg0
-*       load VB_STATUS_INT_PENDING(reg0) in reg1
-*       check if reg1 is equal to zero
-*       if true return
-*	otherwise send an hypercall 
-*       go to checkStatus
-*	}
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
+/*
+ *
+ * VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+ *
+ * This MACRO is implemented in assembly to enable a core's interrupts. It
+ * enables the interrupts by clearing to zero the value in the core's control
+ * structure and and makes a fast hypercall if need be. A hypercall is made only
+ * if found that interrupts are pending. The pending interrupts are checked by
+ * reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+ * positive integer greater than zero indicates that interrupts are pending
+ * which causes this macro to make a hypercall in order to drain the pending
+ * interrupts. This MACRO expects two general purpose registers. The first
+ * register is used to load the value to store and the second is used for
+ * holding the destination address of the control or status structure.
+ *
+ *
+ * VBI_INT_VCORE_UNLOCK (reg0, reg1)
+ * {
+ *	load "0" to reg1
+ *	load address of wrhvVbControl in reg0
+ *	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+ *
+ * checkStatus:
+ *	load address of wrhvVbStatus in reg0
+ *       load VB_STATUS_INT_PENDING(reg0) in reg1
+ *       check if reg1 is equal to zero
+ *       if true return
+ *	otherwise send an hypercall
+ *       go to checkStatus
+ * }
+ *
+ *
+ */
 #define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
 	lis	reg0, HIADJ(wrhvVbControl);			\
 	lwz	reg0, LO(wrhvVbControl)(reg0);			\
@@ -777,137 +593,85 @@ checkIntVcorePending:						\
 	b	checkIntVcorePending;				\
 endIntVcoreLock:
 
-/*******************************************************************************
-*
-* VBI_INT_VCORE_STATE_GET - Get interrupts state
-*
-* This MACRO is implemented in assembly to read the interrupt state of the
-* currently running core. It relies on a passed in general purpose register
-* to store the current state of interrupts. The status is -1 if locked
-* otherwise 0.
-*
-* SYNOPSIS
-*
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_STATE_GET (reg0)
-*	{
-*       Load the interrupt status from wrhvVbControl to reg0
-*	}
-*
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-*vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
-*/
+/*
+ *
+ * VBI_INT_VCORE_STATE_GET - Get interrupts state
+ *
+ * This MACRO is implemented in assembly to read the interrupt state of the
+ * currently running core. It relies on a passed in general purpose register
+ * to store the current state of interrupts. The status is -1 if locked
+ * otherwise 0.
+ *
+ *
+ * VBI_INT_VCORE_STATE_GET (reg0)
+ * {
+ *       Load the interrupt status from wrhvVbControl to reg0
+ * }
+ *
+ *
+ * RETURNS: TRUE if interrupts are locked otherwise FALSE
+ *
+ */
 
 #define VBI_INT_VCORE_STATE_GET(reg0)				\
 	VBI_CNTRL_ADDR_GET(reg0);				\
 	lwz	reg0, VB_CONTROL_INT_DISABLE(reg0);		
 
-/*******************************************************************************
-*
-* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
-*
-* This macro returns the base address of the configuration structure of the 
-* running core. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
-*
-*
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-*
-*/
+/*
+ * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+ *
+ * This macro returns the base address of the configuration structure of the
+ * running core.
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
 
 #define VBI_CONFIG_ADDR_GET(reg)		    \
         lis     reg, HIADJ(wrhvVbConfig);	    \
-        lwz     reg, LO(wrhvVbConfig)(reg)	    
-
-/*******************************************************************************
-*
-* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
-*
-* This macro returns the base address of the running virtual core's control
-* structure.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*
-*/
+        lwz     reg, LO(wrhvVbConfig)(reg)	
+
+/*
+ * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+ *
+ * This macro returns the base address of the running virtual core's control
+ * structure.
+ *
+ */
 
 #define VBI_CNTRL_ADDR_GET(reg)			    \
         lis     reg, HIADJ(wrhvVbControl);	    \
-        lwz     reg, LO(wrhvVbControl)(reg) 	     
-
-/*******************************************************************************
-*
-* VBI_STATUS_ADDR_GET - Get virtual core status structure address
-*
-* This macro returns the base address of the status structure of currently
-* running core. This structure is read-only and contains a description of
-* the running virtual core. Hypervisor uses this data to inform the
-* virtual board time variant data that may be updated during hypervisor context
-* Switch. Typical that are available in the status structure are:
-*
-*
-* 
-*Timer tick counter
-*
-*Pending interrupt state
-*
-*The interrupt state before this core was schedule
-*
-*VMMU configuration
-*
-*Virtual core registers state
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_STATUS * VBI_STATUS_ADDR_GET(void)
-*
-*
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-*
-*/
+        lwz     reg, LO(wrhvVbControl)(reg) 	
+
+/*
+ * VBI_STATUS_ADDR_GET - Get virtual core status structure address
+ *
+ * This macro returns the base address of the status structure of currently
+ * running core. This structure is read-only and contains a description of
+ * the running virtual core. Hypervisor uses this data to inform the
+ * virtual board time variant data that may be updated during hypervisor context
+ * Switch. Typical that are available in the status structure are:
+ *
+ *
+ *Timer tick counter
+ *
+ *Pending interrupt state
+ *
+ *The interrupt state before this core was scheduled
+ *
+ *VMMU configuration
+ *
+ *Virtual core registers state
+ *
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
 
 #define VBI_STATUS_ADDR_GET(reg)			    \
         lis     reg, HIADJ(wrhvVbStatus);		    \
-        lwz     reg, LO(wrhvVbStatus)(reg)	     
+        lwz     reg, LO(wrhvVbStatus)(reg)	
 
 #endif /*_ASMLANGUAGE */
-    
+
 #endif /* __INCvbiPpcArchh */
diff --git a/arch/powerpc/kernel/vbi/show.c b/arch/powerpc/kernel/vbi/show.c
index 10d3d5f..c57c1b4 100644
--- a/arch/powerpc/kernel/vbi/show.c
+++ b/arch/powerpc/kernel/vbi/show.c
@@ -17,17 +17,16 @@
 #include <linux/kernel.h>
 #include <vbi/vbi.h>
 
-/*******************************************************************************
-*
-* vbiStsRegsDisplay - display registers from a EREG_SET
-*
-* This routine display the contents of the PowerPC emulated status registers
-* structure on the console.
-*
-*/
+/*
+ * vbiStsRegsDisplay - display registers from a EREG_SET
+ *
+ * This routine display the contents of the PowerPC emulated status registers
+ * structure on the console.
+ *
+ */
 
-void vbiStsRegsDisplay ()
-    {
+void vbiStsRegsDisplay(void)
+{
     VB_STATUS *p = VBI_STATUS_ADDR_GET();
 
 #if CPU == PPC85XX /* don't know how to handle cpu variant */
@@ -62,19 +61,18 @@ void vbiStsRegsDisplay ()
     VB_PRINTF ("  bucsr:              0x%08x\n",  
 		VB_STATUS_REGS_ACCESS (p, bucsr));
 #endif
-    }
+}
 
-/*******************************************************************************
-*
-* vbiCtrlRegsDisplay - display registers from a EREG_SET
-*
-* This routine display the contents of the PowerPC emulated status registers
-* structure on the console.
-*
-*/
+/*
+ * vbiCtrlRegsDisplay - display registers from a EREG_SET
+ *
+ * This routine display the contents of the PowerPC emulated status registers
+ * structure on the console.
+ *
+ */
 
-void vbiCtrlRegsDisplay (void)
-    {
+void vbiCtrlRegsDisplay(void)
+{
     VB_CONTROL * p = VBI_CNTRL_ADDR_GET();
 
 #if CPU == PPC85XX /* don't know how to handler cpu variant */
@@ -86,4 +84,4 @@ void vbiCtrlRegsDisplay (void)
 		VB_CONTROL_REGS_ACCESS (p, cr), 
 		VB_CONTROL_REGS_ACCESS (p, r0));
 #endif
-    }
+}
diff --git a/arch/x86/kernel/vbi/syscalls.S b/arch/x86/kernel/vbi/syscalls.S
index 2b275d7..ac184a3 100644
--- a/arch/x86/kernel/vbi/syscalls.S
+++ b/arch/x86/kernel/vbi/syscalls.S
@@ -14,1152 +14,662 @@
  *
  */
 
+/*
+ * FIXME -- repitition! This needs to be a table with nr args!
+ */
+
 #define _ASMLANGUAGE
 
 #include <asm/reg_vbi.h>
 #include <asm/vbi.h>
 #include <vbi/syscall.h>
 
-	/* globals */
-	.globl vbiDebugShellStart
-	.globl vbiVbMemoryWrite
-	.globl vbiVbMemoryRead
-	.globl vbiIoapicOp
-	.globl vbiIoapicIoctl
-	.globl vbiHyIoctl
-	.globl vbiCtxctl
-	.globl vbiSend
-	.globl vbiReceiveOp
-	.globl vbiReply
-	.globl vbiTlbFlush
-	.globl vbiPanic
-	.globl vbiPs
-	.globl vbiKputs
-	.globl vbiKputc
-	.globl vbiIntVCoreUnlock
-	.globl vbiIntVCoreLock
-	.globl vbiVbMgmt
-	.globl vbiMemAttrSet
-	.globl vbiMemAttrGet
-	.globl vbiNsOp
-	.globl vbiVbReset
-	.globl vbiVbRestart
-	.globl vbiVbResume
-	.globl vbiVbSuspend
-	.globl vbiVcoreIntRed_op 
-	.globl vbiVbRegisterRead 
-	.globl vbiVbRegisterWrite 
-	.globl vbiVtlbOp 
-	.text
-	.balign 16
+/* globals */
+.globl vbiDebugShellStart
+.globl vbiVbMemoryWrite
+.globl vbiVbMemoryRead
+.globl vbiIoapicOp
+.globl vbiIoapicIoctl
+.globl vbiHyIoctl
+.globl vbiCtxctl
+.globl vbiSend
+.globl vbiReceiveOp
+.globl vbiReply
+.globl vbiTlbFlush
+.globl vbiPanic
+.globl vbiPs
+.globl vbiKputs
+.globl vbiKputc
+.globl vbiIntVCoreUnlock
+.globl vbiIntVCoreLock
+.globl vbiVbMgmt
+.globl vbiMemAttrSet
+.globl vbiMemAttrGet
+.globl vbiNsOp
+.globl vbiVbReset
+.globl vbiVbRestart
+.globl vbiVbResume
+.globl vbiVbSuspend
+.globl vbiVcoreIntRed_op 
+.globl vbiVbRegisterRead 
+.globl vbiVbRegisterWrite 
+.globl vbiVtlbOp 
+.text
+.balign 16
 
 #define VBI_STACK_FRAME_SIZE	4
 
-/*******************************************************************************
-*
-* vbiSend - Send a message to another context
-*
-* This routine makes a hypercall to send a message to the specified context and
-* waits for a reply.  The caller will block until the sender replies to the sent
-* message.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiSend
-*    (
-*    vbiCtx_t     id,    /@ context id to send the message to @/
-*    void *       smsg,  /@ pointer to message to send        @/
-*    size_t       slen,  /@ length of message to send         @/
-*    void *       rmsg,  /@ pointer to receive message buffer @/
-*    size_t       rlen,  /@ length of receive message         @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer     @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer    @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiReceive(), vbiReply(), WRHV  messaging user's guide
-*/
-
+/*
+ * vbiSend - Send a message to another context
+ *
+ * This routine makes a hypercall to send a message to the specified context
+ * and waits for a reply.  The caller will block until the sender replies to
+ * the sent message.
+ *
+ *
+ */
 vbiSend:
-	movl    $VBI_SYS_send,%eax		/* system call number */
-	push	$7				/* number of arguments */
+	movl $VBI_SYS_send,%eax
+	push $7
 	vmcall
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiReceiveOp - Receive a message from another context
-*
-* This routine makes a hypercall and waits for a message to be received from
-* another context. It blocks until a message is received.
-*
-* SYNOPSIS
-*
-*
-* vbiCtx_t vbiReceiveOp
-*    (
-*    void *       smsg,  /@ pointer to message to receive  @/
-*    size_t       len,   /@ length of message to receive   @/
-*    VBI_MSG_INFO *info  /@ status info structure pointer  @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*
-*
-* RETURNS: sender context Id or an error number in case of failure
-*
-*
-*
-*vbiSend(), vbiReply(), WRHV  messaging user's guide
-*/
-
+/*
+ * vbiReceiveOp - Receive a message from another context
+ *
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received.
+ *
+ * RETURNS: sender context Id or an error number in case of failure
+ *
+ */
 vbiReceiveOp:
-	movl    $VBI_SYS_receive,%eax		/* system call number */
-	push	$4				/* number of arguments */
-
+	movl $VBI_SYS_receive,%eax
+	push $4
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiReply - Reply to message received from another context
-*
-* This routine makes a hypercall in order to reply to a message received from
-* another context. A message is received from remote context by calling
-* vbiReceive(). The reply will unblock the recipient which may preempt
-* the caller.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiReply
-*    (
-*    vbiCtx_t   id,    /@ context id to reply the message to @/
-*    void *       buff,  /@ pointer to reply message  @/
-*    size_t       len,   /@ length of message to reply   @/
-*    VBI_MSG_CTL  *ctl   /@ control data structure pointer @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiSend(), vbiReceive(), WRHV  messaging user's guide
-*/
-
+/*
+ * vbiReply - Reply to message received from another context
+ *
+ * This routine makes a hypercall in order to reply to a message received from
+ * another context. A message is received from remote context by calling
+ * vbiReceive(). The reply will unblock the recipient which may preempt
+ * the caller.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
 vbiReply:
-	movl    $VBI_SYS_reply,%eax		/* system call number */
-	push	$4				/* number of arguments */
-
+	movl $VBI_SYS_reply,%eax
+	push $4
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiKputs - print a string on the kernel console
-*
-* This system call sends the specified string to the system console.
-*
-* C interface:
-*
-*   vbiKputs (char *s)		/@ pointer to string			@/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiKputs - print a string on the kernel console
+ *
+ * This system call sends the specified string to the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
 vbiKputs:
-	movl    $VBI_SYS_kputs,%eax		/* system call number */
-	push	$1				/* number of arguments */
-
+	movl $VBI_SYS_kputs,%eax
+	push $1
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiKputc - print a character on the kernel console
-*
-* This system call sends the specified character to the system console.
-*
-* C interface:
-*
-*   vbiKputc (char c)		/@ character to print			@/
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiKputc - print a character on the kernel console
+ *
+ * This system call sends the specified character to the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
 vbiKputc:
-	movl    $VBI_SYS_kputc,%eax		/* system call number */
-	push	$1				/* number of arguments */
-
+	movl $VBI_SYS_kputc,%eax
+	push $1
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiPanic - panic the system and halt all activity
-*
-* This system call causes the hypervisor to enter a panic state and display
-* various pieces of information on the system console.  The hypervisor
-* then enters an idle state and stops all CPU processing.
-*
-* C interface:
-*
-*   vbiPanic (char *msg)	/@ message string to print on console	@/
-*
-* Returns: does not return
-*
-*/
-
+/*
+ * vbiPanic - panic the system and halt all activity
+ *
+ * This system call causes the hypervisor to enter a panic state and display
+ * various pieces of information on the system console.  The hypervisor
+ * then enters an idle state and stops all CPU processing.
+ *
+ * Returns: does not return
+ *
+ */
 vbiPanic:
-	movl    $VBI_SYS_panic,%eax		/* system call number */
-	push	$1				/* number of arguments */
-
+	movl $VBI_SYS_panic,%eax
+	push $1
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiPs - display the list of contexts on the console
-*
-* This system call sends a "ps" like output of the hypervisor contexts to
-* the system console.
-*
-* C interface:
-*
-*   vbiPs (void)
-*
-* Returns: OK or ERROR
-*
-*/
-
+/*
+ * vbiPs - display the list of contexts on the console
+ *
+ * This system call sends a "ps" like output of the hypervisor contexts to
+ * the system console.
+ *
+ * Returns: OK or ERROR
+ *
+ */
 vbiPs:
-	movl    $VBI_SYS_ps,%eax		/* system call number */
-	push	$0				/* number of arguments */
-
+	movl $VBI_SYS_ps,%eax
+	push $0
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiIntVCoreUnlock - Re-enable interrupts in the virtual board
-*
-* This call re-enables interrupts in the virtual board, and calls
-* Razor if interrupts are pending.  The value level is the value returned
-* by the corresponding 	
-*
-* C interface:
-*
-*   vbiIntVCoreUnlock (void)
-*
-* Returns: does not return
-*
-*/
-
+/*
+ * vbiIntVCoreUnlock - Re-enable interrupts in the virtual board
+ *
+ * This call re-enables interrupts in the virtual board, and calls the
+ * hypervisor if interrupts are pending.  The value level is the value returned
+ * by the corresponding 	
+ *
+ */
 vbiIntVCoreUnlock:
 	sti				/* UNLOCK INTERRUPTS */
 	ret
 
-/******************************************************************************
-*
-* vbiIntVCoreLock - Disable interrupts in the virtual core
-*
-* This call disables interrupts in the virtual board.
-*
-* C interface:
-*
-*   int vbiIntVCoreLock (void)
-*
-* Returns: the old value of the interrupt disable 
-*
-*/
-
+/*
+ * vbiIntVCoreLock - Disable interrupts in the virtual core
+ *
+ * This call disables interrupts in the virtual board.
+ *
+ * Returns: the old value of the interrupt disable 
+ *
+ */
 vbiIntVCoreLock:
     pushf				/* push EFLAGS on stack */
     popl	%eax			/* get EFLAGS in EAX */
     andl	$EFLAGS_IF,%eax		/* mask it with IF bit */
-    cli				/* LOCK INTERRUPTS */
+    cli					/* LOCK INTERRUPTS */
     ret
 
-/******************************************************************************
-*
-* vbiVbMgmt - virtual board management
-* 
-* This routine executes the specified command on a given virtual board. The
-* possible commands are:
-* 
-* VBI_VBMGMT_ATTACH 
-* Attach the requesting Virtual Board to the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_DETACH
-* Detatch the requesting Virtual Board from the VB management agent for
-* operations on the specified VB.
-*
-* VBI_VBMGMT_SUSPEND
-* Suspends target Virtual Board from operation.  Fails if Virtual Board
-* has already been suspended
-*
-* VBI_VBMGMT_RESET
-* Resume a target virtual board.  Fails if a Virtual Board has not been
-* suspended. Currently no options are supported
-*
-* VBI_VBMGMT_RESUME
-* Restarts a target Virtual Board which has Preload=0 set in the xml file.
-* Fails if Virtual Board is preloaded (Preload=1)
-*
-*
-* The fourth argument to this routine specifies an flag that must be defined
-* when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
-* The possible flgas are:
-*   VBI_VTLB_OP_UPDATE_PMD	
-*   VBI_VTLB_OP_UPDATE_PTE	
-*   VBI_VTLB_OP_DELETE_PMD	
-*   VBI_VTLB_OP_SET_PTE_AT	
-*   VBI_VTLB_OP_SET_PTE	
-*   VBI_VTLB_OP_FLUSH_OPS	
-*   VBI_VTLB_OP_INIT	
-*
-* int32_t vbiVbMgmt 
-*    (
-*    uint32_t	cmd,	    /@ attach, detach, suspend, reset or resume @/
-*    uint32_t	handle,    /@ the operation target board handle @/
-*    int32_t	*outError,  /@ where to set error : OK or error flag @/ 
-*    uint32_t	flags,	    /@ options required by the cmd executed @/
-*    void *ctl		    /@ memory / registers data		    @/ 
-*    )
-*
-* RETURNS: OK or error in case of failure
-*/
-
+/*
+ * vbiVbMgmt - virtual board management
+ * 
+ * This routine executes the specified command on a given virtual board. The
+ * possible commands are:
+ * 
+ * VBI_VBMGMT_ATTACH 
+ * Attach the requesting Virtual Board to the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_DETACH
+ * Detatch the requesting Virtual Board from the VB management agent for
+ * operations on the specified VB.
+ *
+ * VBI_VBMGMT_SUSPEND
+ * Suspends target Virtual Board from operation.  Fails if Virtual Board
+ * has already been suspended
+ *
+ * VBI_VBMGMT_RESET
+ * Resume a target virtual board.  Fails if a Virtual Board has not been
+ * suspended. Currently no options are supported
+ *
+ * VBI_VBMGMT_RESUME
+ * Restarts a target Virtual Board which has Preload=0 set in the xml file.
+ * Fails if Virtual Board is preloaded (Preload=1)
+ *
+ *
+ * The fourth argument to this routine specifies an flag that must be defined
+ * when executing VBI_VBMGMT_RESUME operation. Otherwise the command fails.
+ * The possible flgas are:
+ *   VBI_VTLB_OP_UPDATE_PMD	
+ *   VBI_VTLB_OP_UPDATE_PTE	
+ *   VBI_VTLB_OP_DELETE_PMD	
+ *   VBI_VTLB_OP_SET_PTE_AT	
+ *   VBI_VTLB_OP_SET_PTE	
+ *   VBI_VTLB_OP_FLUSH_OPS	
+ *   VBI_VTLB_OP_INIT	
+ *
+ * RETURNS: OK or error in case of failure
+ */
 vbiVbMgmt:
-	movl    $VBI_SYS_vbMgmt,%eax		/* system call number */
-	push	$5				/* number of arguments */
-
+	movl $VBI_SYS_vbMgmt,%eax
+	push $5
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVbSuspend - Suspend a virtual board's core
-*
-* This routine makes a hypercall in order to suspend one or more cores that
-* exist within the specified virtual board. The target core(s) enter HALT state
-* until vbiVbResume() is called change the state of the core(s). This function
-* will return only after all victim cores are suspended unless the opration
-* fails to complete. The second argument passed to this function specifies one
-* or more target cores. For suspending every core within the specified VB the
-* second argument must be set to VBI_VB_CORES_ALL. This implies that the core
-* requesting the suspension may also be included in the list to be suspended.
-* To suspend everyone but the recipient then the second argument passed to this
-* function should be set to VBI_VB_CORES_OTHERS. Otherwise the second argument
-* should be a valid core number within the VB. This hypercall sends a message
-* to a given hypervisor manager that provides virtual board managment service.
-*
-* SYNOPSIS
-*
-*
-*
-* vbiStatus_t vbiVbSuspend
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbReset(), vbiVbRestart()
-*/
-
+/*
+ * vbiVbSuspend - Suspend a virtual board's core
+ *
+ * This routine makes a hypercall in order to suspend one or more cores
+ * that exist within the specified virtual board. The target core(s)
+ * enter HALT state until vbiVbResume() is called change the state of
+ * the core(s). This function will return only after all victim cores
+ * are suspended unless the opration fails to complete. The second
+ * argument passed to this function specifies one or more target cores.
+ * For suspending every core within the specified VB the second argument
+ * must be set to VBI_VB_CORES_ALL. This implies that the core
+ * requesting the suspension may also be included in the list to be
+ * suspended.  To suspend everyone but the recipient then the second
+ * argument passed to this function should be set to
+ * VBI_VB_CORES_OTHERS. Otherwise the second argument should be a valid
+ * core number within the VB. This hypercall sends a message to a given
+ * hypervisor manager that provides virtual board managment service.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
 vbiVbSuspend:
-	movl    $VBI_SYS_vbSuspend,%eax		/* system call number */
-	push	$2				/* number of arguments */
-
+	movl $VBI_SYS_vbSuspend,%eax
+	push $2
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVbReset - Reset a virtual board's core
-*
-* This routine makes a hypercall in order to reset one or more cores that exist
-* within the specified virtual board. Calling this function puts the target core(s)
-* program counter to it's ENTRY function. The ENTRY function is determined based on
-* the loaded binary image. A core does not execute beyond it's ENTRY function
-* unless vbiVbRestart() is explitly called. Except for core0 within the target VB
-* where VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
-* the third argument to this routine.
-* The hypercall sends a message to a manager that provides VB managment services.
-* This function will return only after all victim cores are reset unless the
-* operation fails to complete. The order of which the victim cores are reset is not
-* determined. The second argument identifies the cores to perform the operation on.
-* The value of the second argument should be set to one of the following:
-*
-*
-*
-* VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
-*
-* VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the victim VB
-*
-* A valid core number: Reset the specified core that exist within the Virtual Board.
-*\me
-*
-* The third argument argument passed to this function specifies options that are
-* applicable only when the second argument is VBI_VB_CORES_ALL. The options may be
-* one of the following or a combination:
-*
-*
-*
-* VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
-*
-* VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
-*\me
-*
-*
-* IMPORTANT:
-* If a user chooses to restart core without reloading the executable image then
-* the data section must be restored to prevent critical errors. It is the guest OS's
-* responsibility to clear the bss data sections in such scenario.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbReset
-*    (
-*    vbiVb_t      id,       /@ Id of the VB to suspend      @/
-*    vbiCore_t     core,            /@ Core within the VB           @/
-*    uint32_t     options   /@ reload , start options       @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbRestart()
-*/
+/*
+ * vbiVbReset - Reset a virtual board's core
+ *
+ * This routine makes a hypercall in order to reset one or more cores
+ * that exist within the specified virtual board. Calling this function
+ * puts the target core(s) program counter to it's ENTRY function. The
+ * ENTRY function is determined based on the loaded binary image. A core
+ * does not execute beyond it's ENTRY function unless vbiVbRestart() is
+ * explitly called. Except for core0 within the target VB where
+ * VBI_VBMGMT_RESET_AND_START_CORE0 option is set in the flag passed as
+ * the third argument to this routine.  The hypercall sends a message to
+ * a manager that provides VB managment services.  This function will
+ * return only after all victim cores are reset unless the operation
+ * fails to complete. The order of which the victim cores are reset is
+ * not determined. The second argument identifies the cores to perform
+ * the operation on.  The value of the second argument should be set to
+ * one of the following:
+ *
+ * VBI_VB_CORES_ALL: Reset all cores in the specified virtual board
+ *
+ * VBI_VB_CORES_OTHERS: Exclude the recipient if it belongs to the
+ * victim VB
+ *
+ * A valid core number: Reset the specified core that exist within the
+ * Virtual Board.
+ *
+ * The third argument argument passed to this function specifies options
+ * that are applicable only when the second argument is
+ * VBI_VB_CORES_ALL. The options may be one of the following or a
+ * combination:
+ *
+ * VBI_VBMGMT_RESET_DOWNLOAD: Reset the cores and reload the executable images
+ *
+ * VBI_VBMGMT_RESET_AND_START_CORE0: Reset and start core0 within the VB
+ *
+ *
 
+ * IMPORTANT: If a user chooses to restart core without reloading the
+ * executable image then the data section must be restored to prevent
+ * critical errors. It is the guest OS's responsibility to clear the bss
+ * data sections in such scenario.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
 vbiVbReset:
-        movl    $VBI_SYS_vbReset,%eax            /* system call number */
-        push    $3                              /* number of arguments */
-
+        movl $VBI_SYS_vbReset,%eax
+        push $3
         vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
         ret
 
-/*******************************************************************************
-*
-* vbiVbRestart - Restart a virtual board's core
-*
-* This routine makes a hypercall in order to restart a virtual cores from reset.
-* It's called to start running a core or cores that were previously reset by
-* calling vbiVbReset(). The target core(s) start(s) executing from the ENTRY
-* function retrieved from the corresponding binary image.
-* This function will return only after  all cores are out of reset unless the
-* operation fails to complete.  The second argument represents the cores to restart.
-* For restarting every core in reset mode within the specified VB the second
-* argument is set to VBI_VB_CORES_ALL. To restart a specific core within the
-* VB then the core number must be passed in the second argument.
-*
-* This hypercall sends a message to a manager that provides VB managment
-* services.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbRestart
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend(), vbiVbReset()
-*/
-
+/*
+ * vbiVbRestart - Restart a virtual board's core
+ *
+ * This routine makes a hypercall in order to restart a virtual cores
+ * from reset.  It's called to start running a core or cores that were
+ * previously reset by calling vbiVbReset(). The target core(s) start(s)
+ * executing from the ENTRY function retrieved from the corresponding
+ * binary image.  This function will return only after  all cores are
+ * out of reset unless the operation fails to complete.  The second
+ * argument represents the cores to restart.  For restarting every core
+ * in reset mode within the specified VB the second argument is set to
+ * VBI_VB_CORES_ALL. To restart a specific core within the VB then the
+ * core number must be passed in the second argument.
+
+ * This hypercall sends a message to a manager that provides VB managment
+ * services.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
 vbiVbRestart:
-        movl    $VBI_SYS_vbRestart,%eax            /* system call number */
-        push    $3                              /* number of arguments */
-
+        movl $VBI_SYS_vbRestart,%eax
+        push $3
         vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
         ret
 
-/*******************************************************************************
-*
-* vbiVbResume - Resume a virtual board's core
-*
-* This routine makes a hypercall in order to resume one or cores within
-* the specified virtual board. It reactivates a cores or cores that were
-* previously suspended by calling vbiVbResume(). This function will return only
-* after all victim cores are resumed unless the operation fails. The order of
-* which the cores are resumed is not determined. The second argument may a
-* magic number instead of a valid core number to indicate that the operation
-* is intended for more than one core. For resuming every core within the
-* specified VB then the second argument is set to be equal to VBI_VB_RESUME_ALL.
-* This implies to resume every core within the specified VB. Using this option
-* when some of the cores within the VB are already running is not considered
-* as programming error.
-*
-* SYNOPSIS
-*
-*
-* vbiStatus_t vbiVbResume
-*    (
-*    vbiVb_t      id,    /@ Id of the VB to suspend     @/
-*    vbiCore_t     core   /@ Core within the VB         @/
-*    )
-*
-*
-* RETURNS: OK or an error number in case of failure
-*
-*
-*
-*vbiVbResume(), vbiVbSuspend()
-*/
-
+/*
+ * vbiVbResume - Resume a virtual board's core
+ *
+ * This routine makes a hypercall in order to resume one or cores within
+ * the specified virtual board. It reactivates a cores or cores that
+ * were previously suspended by calling vbiVbResume(). This function
+ * will return only after all victim cores are resumed unless the
+ * operation fails. The order of which the cores are resumed is not
+ * determined. The second argument may a magic number instead of a valid
+ * core number to indicate that the operation is intended for more than
+ * one core. For resuming every core within the specified VB then the
+ * second argument is set to be equal to VBI_VB_RESUME_ALL.  This
+ * implies to resume every core within the specified VB. Using this
+ * option when some of the cores within the VB are already running is
+ * not considered as programming error.
+ *
+ * RETURNS: OK or an error number in case of failure
+ *
+ */
 vbiVbResume:
-        movl    $VBI_SYS_vbResume,%eax            /* system call number	*/
-        push    $2                              /* number of arguments	*/
-
+        movl $VBI_SYS_vbResume,%eax
+        push $2
         vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
         ret
 
-/******************************************************************************
-*
-* vbiHyIoctl - hypervisor ioctl call
-*
-* This system call interfaces to the general purpose hypervisor ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_HYIOCTL_GETPID
-*     VBI_HYIOCTL_GETPRIORITY
-*     VBI_HYIOCTL_GETSTATS
-*     VBI_HYIOCTL_PADDR
-*		
-* C interface:
-*
-*   vbiHyIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*               void *arg1,         /@ address of information @/
-*               void *arg2,         /@ address of information @/
-*               void *arg3,         /@ address of information @/
-*               void *arg4)         /@ address of information @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ * vbiHyIoctl - hypervisor ioctl call
+ *
+ * This system call interfaces to the general purpose hypervisor ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_HYIOCTL_GETPID
+ *     VBI_HYIOCTL_GETPRIORITY
+ *     VBI_HYIOCTL_GETSTATS
+ *     VBI_HYIOCTL_PADDR
+ *		
+ * Returns: ioctl specific value
+ *
+ */
 vbiHyIoctl:
-	movl    $VBI_SYS_hyIoctl,%eax		/* system call number */
-	push	$5				/* number of arguments */
-
+	movl $VBI_SYS_hyIoctl,%eax
+	push $5
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/******************************************************************************
-*
-* vbiIoapicIoctl - virtual IO APIC ioctl call
-*
-* This system call interfaces to the virtual IO APIC ioctl
-* function.
-*
-* Possible ioctl commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*		
-* C interface:
-*
-*   vbiIoapicIoctl (unsigned int ioctl, /@ the ioctl command      @/
-*                   unsigned arg1,      /@ address of information @/
-*                   unsigned arg2)      /@ address of information @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ * vbiIoapicIoctl - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC ioctl
+ * function.
+ *
+ * Possible ioctl commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *		
+ * Returns: ioctl specific value
+ *
+ */
 vbiIoapicIoctl:
-	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
-	push	$3				/* number of arguments */
-
+	movl $VBI_SYS_vIoapicIoctl,%eax
+	push $3
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/******************************************************************************
-*
-* vbiIoapicOp - virtual IO APIC ioctl call
-*
-* This system call interfaces to the virtual IO APIC.
-*
-* function.
-*
-* Possible commands:
-*     VBI_IOAPICIOCTL_UNMASK
-*     VBI_IOAPICIOCTL_SEND
-*     VBI_IOAPICIOCTL_MASK
-*
-* C interface:
-*
-*   vbiIoapicOp	    (uint32_t cmd,      /@ the operation command     @/
-*                   vbiIrq_t irq,       /@ irq number                @/
-*                   uint32_t filter,    /@ filter                    @/
-*                   vbiVb_t  vbId,      /@ target vb id              @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ * vbiIoapicOp - virtual IO APIC ioctl call
+ *
+ * This system call interfaces to the virtual IO APIC.
+ *
+ * function.
+ *
+ * Possible commands:
+ *     VBI_IOAPICIOCTL_UNMASK
+ *     VBI_IOAPICIOCTL_SEND
+ *     VBI_IOAPICIOCTL_MASK
+ *
+ * Returns: ioctl specific value
+ *
+ */
 vbiIoapicOp:
-	movl    $VBI_SYS_vIoapicIoctl,%eax	/* system call number */
-	push	$4				/* number of arguments */
-
+	movl $VBI_SYS_vIoapicIoctl,%eax
+	push $4
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiCtxctl - hypervisor context control call
-*
-* This system call interfaces to the general purpose hypervisor context
-* control function.
-*
-* Possbile operations:
-*	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
-*
-* C interface:
-*
-*   vbiHyCtxctl (unsigned int operation, /@ context operation   @/
-*		 void *arg)		 /@ address of argument @/
-*
-* Returns: ioctl specific value
-*
-*/
-
+/*
+ * vbiCtxctl - hypervisor context control call
+ *
+ * This system call interfaces to the general purpose hypervisor context
+ * control function.
+ *
+ * Possbile operations:
+ *	VBI_CTXCTL_IDLE /@ Make this virtual board go idle @/
+ *
+ * Returns: ioctl specific value
+ *
+ */
 vbiCtxctl:
-	movl    $VBI_SYS_ctxctl,%eax		/* system call number */
-	push	$2				/* number of arguments */
-
+	movl $VBI_SYS_ctxctl,%eax
+	push $2
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiMemAttrSet - Set protection for a page of memory
-*
-* This routine makes a hypercall to set the MMU attribures for the specified
-* memory range. The possible attributes one or a combinarion of the following:
-* 
-* VBI_MMU_PROT_READ -  allow supervisor and user read
-* VBI_MMU_PROT_WRITE -  Allow supervisor and user write
-* VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrSet 
-*		(
-*		void	 *gaddr,	/@ Address of page to change attr   @/
-*		size_t   length,	/@ length of address		    @/
-*		uint32_t attr		/@ mmu attributes to set	    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
+/*
+ * vbiMemAttrSet - Set protection for a page of memory
+ *
+ * This routine makes a hypercall to set the MMU attribures for the specified
+ * memory range. The possible attributes one or a combinarion of the following:
+ * 
+ * VBI_MMU_PROT_READ -  allow supervisor and user read
+ * VBI_MMU_PROT_WRITE -  Allow supervisor and user write
+ * VBI_MMU_PROT_EXECUTE - allow supervisor and user execute
+ *
+ * RETURNS: OK or error number in case of failure
+ *
+ */
 vbiMmuAttrSet:
-	movl    $VBI_SYS_mmu_attr_set,%eax	/* system call number */
-	push	$3				/* number of arguments */
-
+	movl $VBI_SYS_mmu_attr_set,%eax
+	push $3
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/******************************************************************************
-*
-* vbiMemAttrGet - Get MMU page protections
-*
-* This routine makes a hypercall to retrieve the MMU attributes associated for
-* the page where the specified address is mapped. This is not the VMMU
-* attributes. A guest OS has direct access to the mapping table of its VMMU
-* therefore a hypercall is not necessary.
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiMemAttrGet 
-*		(
-*		void	 *gaddr		/@ Address of page to change attr   @/
-*		uint32_t *attr		/@ OUT - returned mmu attributes    @/
-*		)
-*
-*
-* RETURNS: OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*/
-
+/*
+ * vbiMemAttrGet - Get MMU page protections
+ *
+ * This routine makes a hypercall to retrieve the MMU attributes associated for
+ * the page where the specified address is mapped. This is not the VMMU
+ * attributes. A guest OS has direct access to the mapping table of its VMMU
+ * therefore a hypercall is not necessary.
+ *
+ * RETURNS: OK or error number in case of failure
+ *
+ */
 vbiMmuAttrGet:
-	movl    $VBI_SYS_mmu_attr_get,%eax	/* system call number */
-	push	$1				/* number of arguments */
-
+	movl $VBI_SYS_mmu_attr_get,%eax
+	push $1
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/******************************************************************************
-*
-* vbiNsOp - virtua board name service call
-*
-* This system call interfaces to the virtual board
-*
-* commands:
-*	VBI_VBI_NS_REGISTER	   /@ register service	 @/
-*	VBI_VBI_NS_UNREGISTER	   /@ unregister service @/
-*	VBI_VBI_NS_LOOKUP	   /@ lookup service	 @/
-*				
-* C interface:
-*
-*   vbiNsOp ( uint32_t cmd,	    /@ the BSP ioctl command	@/
-*	    char * name,		    /@ the service name		@/
-*	    uint32_t revision,	    /@ service revision		@/
-*	    VBI_HANDLE *handle,	    /@ service handle pointer	@/
-*	  )
-*
-* Returns: OK or ERROR in case of failure
-*
-*/
-
+/*
+ * vbiNsOp - virtua board name service call
+ *
+ * This system call interfaces to the virtual board
+ *
+ * commands:
+ *	VBI_VBI_NS_REGISTER	    register service
+ *	VBI_VBI_NS_UNREGISTER	    unregister service
+ *	VBI_VBI_NS_LOOKUP	    lookup service
+ *				
+ * Returns: OK or ERROR in case of failure
+ *
+ */
 vbiNsOp:
-	movl    $VBI_SYS_ns_op, %eax		/* system call number */
-	push	$4				/* number of arguments */
-
+	movl $VBI_SYS_ns_op, %eax
+	push $4
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVbMemoryWrite - copy data to a remote board's memory
-*
-* This routine makes a hypercall to copy to a remote board memory. If the
-* VBI_DCACHE_FLUSH is set in the control memory control structure then this
-* routine flushes the data caches lines corresponding to the range of memory
-* specified. If VBI_ICACHE_INV then this routine ensure that the instruction
-* cache lines corresponding to the range of address is invalidated after the
-* memory is copied. Invalidating the instruction is required if data containing
-* is updated since the instruction cache is not aware of the content in data
-* cache. Therefore flushing the data cache ensures that memory contains the
-* updated data and invalidating the instruction cache ensures that the stale
-* values in the instruction cache is thrown away. 
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-* 
-* 
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	@/
-*   void	*pAddress;	    /@ address of calling context	@/
-*   size_t	sizeIn;		    /@ IN: number bytes requested	@/
-*   size_t	sizeOut;	    /@ OUT: number of total bytes read	@/
-*   uint32_t	flags;		    /@ data/instruction flush option	@/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryWrite 
-*	(
-*	VBI_MEM_CTL	*memCtl, 
-*	vbiVb_t		targetBoard 
-*	)
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbMemoryWrite - copy data to a remote board's memory
+ *
+ * This routine makes a hypercall to copy to a remote board memory. If
+ * the VBI_DCACHE_FLUSH is set in the control memory control structure
+ * then this routine flushes the data caches lines corresponding to the
+ * range of memory specified. If VBI_ICACHE_INV then this routine ensure
+ * that the instruction cache lines corresponding to the range of
+ * address is invalidated after the memory is copied. Invalidating the
+ * instruction is required if data containing is updated since the
+ * instruction cache is not aware of the content in data cache.
+ * Therefore flushing the data cache ensures that memory contains the
+ * updated data and invalidating the instruction cache ensures that the
+ * stale values in the instruction cache is thrown away.  The sizeIn
+ * parameter specifies the number of bytes desired to be copied.  The
+ * sizeOut parameter indicates the number of bytes successfully copied.
+ * A user may set the sizeOut parameter to zero if the output size is
+ * not of interest otherwise to a value different than zero.
+ * 
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
 vbiVbMemoryWrite:
-	movl    $VBI_SYS_memWrite_op, %eax	/* system call number */
-	push	$2				/* number of arguments */
-
+	movl $VBI_SYS_memWrite_op, %eax
+	push $2
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVbMemoryRead - Read a virtual board's memory
-*
-* This routine makes a hypercall to read a remote board's memory. The memory control
-* structure contains information about the target memory to read and the destination
-* buffer that hypervisor must populate with the data read. This routine is used
-* to copy data from a remote VB. It is the user's responsability to ensure that
-* the memory read is accessed orthogonally.
-* The sizeIn parameter specifies the number of bytes desired to be copied. 
-* The sizeOut parameter indicates the number of bytes successfully copied.
-* A user may set the sizeOut parameter to zero if the output size is not of
-* interest otherwise to a value different than zero.
-*
-* struct vbiMemCtl
-*   {
-*   void	*pBuffer;	    /@ address of target context	    @/
-*   void	*pAddress;	    /@ address of calling context	    @/
-*   size_t	sizeIn;		    /@ number of bytes to be read	    @/
-*   size_t	sizeOut;	    /@ number of bytes successfully read    @/
-*   uint32_t	reserved;	    /@ reserved for future use		    @/
-*    } VBI_MEM_CTL;
-*
-* SYNOPSIS
-*
-* 
-* vbiStatus_t vbiVbMemoryRead 
-*	(
-*	VBI_MEM_CTL *memCtl,	    /@ control structure for INPUT and OUTPUT	@/
-*	vbiVb_t	    targetBoard	    /@ target board				@/
-*	)
-*
-*
-*
-* RETURNS: returns OK or an error number in case of failure
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * vbiVbMemoryRead - Read a virtual board's memory
+ *
+ * This routine makes a hypercall to read a remote board's memory. The
+ * memory control structure contains information about the target memory
+ * to read and the destination buffer that hypervisor must populate with
+ * the data read. This routine is used to copy data from a remote VB. It
+ * is the user's responsability to ensure that the memory read is
+ * accessed orthogonally.  The sizeIn parameter specifies the number of
+ * bytes desired to be copied.  The sizeOut parameter indicates the
+ * number of bytes successfully copied.  A user may set the sizeOut
+ * parameter to zero if the output size is not of interest otherwise to
+ * a value different than zero.
+ *
+ * RETURNS: returns OK or an error number in case of failure
+ *
+ */
 vbiVbMemoryRead:
-	movl    $VBI_SYS_memRead_op, %eax	/* system call number */
-	push	$2				/* number of arguments */
-
+	movl $VBI_SYS_memRead_op, %eax
+	push $2
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiDebugShellStart - start the hypervisor debug shell
-*
-* This routine sends a message to the hypervisor debug shell manager in order to
-* start the WRHV shell program. The shell program spins therefore does not share
-* the processor with any other WRHV context. By default a caller of this routine
-* is detached to allow the caling core to continue executing (as long as the are not
-* scheduled to run on the same processor). An optional flag VBI_SHELL_ATTACH can be
-* specified to force the caller virtual board core to block while the shell program
-* is running.
-*
-* SYNOPSIS
-*
-*
-* void vbiDebugShellStart
-*          (
-*          uint32_t  flags /@ detach by default @/
-*          )
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*/
-
+/*
+ * vbiDebugShellStart - start the hypervisor debug shell
+ *
+ * This routine sends a message to the hypervisor debug shell manager in
+ * order to start the WRHV shell program. The shell program spins
+ * therefore does not share the processor with any other WRHV context.
+ * By default a caller of this routine is detached to allow the caling
+ * core to continue executing (as long as the are not scheduled to run
+ * on the same processor). An optional flag VBI_SHELL_ATTACH can be
+ * specified to force the caller virtual board core to block while the
+ * shell program is running.
+ *
+ */
 vbiDebugShellStart:
-
-	movl    $VBI_SYS_dbgShStart, %eax	/* system call number */
-	push	$1				/* number of arguments */
-
+	movl $VBI_SYS_dbgShStart, %eax
+	push	$1
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
 
-/*******************************************************************************
-*
-* vbiVbRegisterRead - Read a remote core's registers
-*
-* This routine makes a hypercall to read a remote core's registers. The register
-* control structure contains information about the registers to read and the
-* destination buffers to store them.
-* 
-* SYNOPSIS
-* VBI X86 Architecture Supplements
-*
-* vbiStatus_t vbiVbRegisterRead 
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,    /@ Registers read - OUT	    @/
-*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
-*	vbiCore_t   core		    /@ core within the target VB    @/
-*	)
-*\sh VB_ARCH_CONTROL_REGS definition
-*
-*The control registers type used for vbiVbRegister[Read:write] API's
-*
-*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
-*    {
-*    uint32_t  edi;		/@ 00: general register		@/
-*    uint32_t  esi;		/@ 04: general register		@/
-*    uint32_t  ebp;		/@ 08: frame pointer register	@/
-*    uint32_t  esp;		/@ 0C: stack pointer register	@/
-*    uint32_t  ebx;		/@ 10: general register		@/
-*    uint32_t  edx;		/@ 14: general register		@/
-*    uint32_t  ecx;		/@ 18: general register		@/
-*    uint32_t  eax;		/@ 1C: general register		@/
-*    uint32_t  eflags;		/@ 20: status register		@/
-*    INSTR *pc;			/@ 24: program counter		@/
-*    uint32_t  cr0;		/@ 28: control register 0	@/
-*    uint32_t  cr2;		/@ 2C: control register 2	@/
-*    uint32_t  cr3;		/@ 30: control register 3	@/
-*    uint32_t  cr4;		/@ 34: control register 4	@/
-*    uint32_t  cs;		/@ 28: code segment		@/
-*    uint32_t  ds;		/@ 3C: data segment		@/
-*    uint32_t  ss;		/@ 40: stack segment		@/
-*    uint32_t  es;		/@ 44: E segment		@/
-*    uint32_t  fs;		/@ 48: F segment		@/
-*    uint32_t  gs;		/@ 4C: G segment		@/
-*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
-*    } VB_ARCH_CONTROL_REGS;
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES:
-*
-*
-*/
-
+/*
+ * vbiVbRegisterRead - Read a remote core's registers
+ *
+ * This routine makes a hypercall to read a remote core's registers. The
+ * register control structure contains information about the registers
+ * to read and the destination buffers to store them.
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
 vbiVbRegisterRead:
-
-	movl    $VBI_SYS_RegsRead_op, %eax	/* system call number */
-	push	$3				/* number of arguments */
-
+	movl $VBI_SYS_RegsRead_op, %eax
+	push $3
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVbRegisterWrite - write to a remote core's registers
-*
-* This routine makes a hypercall to write to a remote core's registers. The
-* register control structure contains the set of registers to write. 
-* The user must ensure to read first the destination core's registers using
-* vbiVbRegisterRead() then write back the modified set of registers in the 
-* registers control structure.
-* 
-* VBI X86 Architecture Supplements
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVbRegisterWrite
-*	(
-*	VB_ARCH_CONTROL_REGS	*regCtl,	/@ registers to write - IN	 @/
-*	vbiVb_t			targetBoard,	/@ The target board		 @/
-*	vbiCore_t		core		/@ The target core within the VB @/
-*	)
-*
-*\sh VB_ARCH_CONTROL_REGS definition
-*
-*The control registers type used for vbiVbRegister[Read:write] API's
-*
-*typedef struct vbArchControlRegs /@ REG_SET - x86 register set	@/
-*    {
-*    uint32_t  edi;		/@ 00: general register		@/
-*    uint32_t  esi;		/@ 04: general register		@/
-*    uint32_t  ebp;		/@ 08: frame pointer register	@/
-*    uint32_t  esp;		/@ 0C: stack pointer register	@/
-*    uint32_t  ebx;		/@ 10: general register		@/
-*    uint32_t  edx;		/@ 14: general register		@/
-*    uint32_t  ecx;		/@ 18: general register		@/
-*    uint32_t  eax;		/@ 1C: general register		@/
-*    uint32_t  eflags;		/@ 20: status register		@/
-*    INSTR *pc;			/@ 24: program counter		@/
-*    uint32_t  cr0;		/@ 28: control register 0	@/
-*    uint32_t  cr2;		/@ 2C: control register 2	@/
-*    uint32_t  cr3;		/@ 30: control register 3	@/
-*    uint32_t  cr4;		/@ 34: control register 4	@/
-*    uint32_t  cs;		/@ 28: code segment		@/
-*    uint32_t  ds;		/@ 3C: data segment		@/
-*    uint32_t  ss;		/@ 40: stack segment		@/
-*    uint32_t  es;		/@ 44: E segment		@/
-*    uint32_t  fs;		/@ 48: F segment		@/
-*    uint32_t  gs;		/@ 4C: G segment		@/
-*    uint32_t  tsp;		/@ 50: transition stack pointer	@/
-*    } VB_ARCH_CONTROL_REGS;
-*
-*
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: 
-*
-*
-*/
-
+/*
+ * vbiVbRegisterWrite - write to a remote core's registers
+ *
+ * This routine makes a hypercall to write to a remote core's registers. The
+ * register control structure contains the set of registers to write. 
+ * The user must ensure to read first the destination core's registers using
+ * vbiVbRegisterRead() then write back the modified set of registers in the 
+ * registers control structure.
+ * 
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
 vbiVbRegisterWrite:
-	movl    $VBI_SYS_RegsWrite_op, %eax	/* system call number */
-	push	$3				/* number of arguments */
-
+	movl $VBI_SYS_RegsWrite_op, %eax
+	push $3
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/*******************************************************************************
-*
-* vbiVcoreIntRed_op - redirect an irq to another vcore
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVcoreIntRed_op 
-*	(
-*	vbiIrq_t		irq,	/@ irq number to redirect	 @/
-*	vbiCore_t		core	/@ destination vcore		 @/
-*	)
-*
-* RETURNS: returns OK or error number in case of failure
-*
-* ERROR CODES: 
-*
-*vbiVioapicIntRedirect()
-* 
-*
-*/
+/*
+ * vbiVcoreIntRed_op - redirect an irq to another vcore
+ *
+ * RETURNS: returns OK or error number in case of failure
+ *
+ */
 vbiVcoreIntRed_op:
-
-	movl    $VBI_SYS_intRedirect, %eax	/* system call number */
-	push	$2				/* number of arguments */
-
+	movl $VBI_SYS_intRedirect, %eax
+	push $2
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp			/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
 
-/******************************************************************************
-*
-* vbiVtlbOp - execute a specified VTLB operation
-*
-* This system call executes the specified VTLB operation. The possible VTLB
-* operations are:
-*
-*   VBI_VTLB_OP_UPDATE_PMD	
-*   VBI_VTLB_OP_UPDATE_PTE	
-*   VBI_VTLB_OP_DELETE_PMD	
-*   VBI_VTLB_OP_SET_PTE_AT	
-*   VBI_VTLB_OP_SET_PTE	
-*   VBI_VTLB_OP_FLUSH_OPS	
-*   VBI_VTLB_OP_INIT	
-*
-* SYNOPSIS
-*
-* vbiStatus_t vbiVtlbOp (
-*            unsigned int op,          /@ VTLB operation @/
-*            unsigned long arg1,       /@ VTLB operation argument 1 @/
-*            unsigned long arg2,       /@ VTLB operation argument 2 @/
-*            unsigned long arg3        /@ VTLB operation argument 3 @/
-*            )
-*
-*
-* Returns: OK or ERROR if the VTLB operation has failed
-*/
-
+/*
+ * vbiVtlbOp - execute a specified VTLB operation
+ *
+ * This system call executes the specified VTLB operation. The possible VTLB
+ * operations are:
+ *
+ *   VBI_VTLB_OP_UPDATE_PMD	
+ *   VBI_VTLB_OP_UPDATE_PTE	
+ *   VBI_VTLB_OP_DELETE_PMD	
+ *   VBI_VTLB_OP_SET_PTE_AT	
+ *   VBI_VTLB_OP_SET_PTE	
+ *   VBI_VTLB_OP_FLUSH_OPS	
+ *   VBI_VTLB_OP_INIT	
+ *
+ * Returns: OK or ERROR if the VTLB operation has failed
+ */
 vbiVtlbOp:
-	movl    $VBI_SYS_vtlb_op, %eax	/* system call number */
-	pushl   $4			/* number of arguments */
-
+	movl $VBI_SYS_vtlb_op, %eax
+	pushl $4
 	vmcall
-
-	addl	$VBI_STACK_FRAME_SIZE, %esp	/* adjust stack */
-
+	addl $VBI_STACK_FRAME_SIZE, %esp
 	ret
diff --git a/include/asm-x86/arch_vbi.h b/include/asm-x86/arch_vbi.h
index f872a46..078cb84 100644
--- a/include/asm-x86/arch_vbi.h
+++ b/include/asm-x86/arch_vbi.h
@@ -19,76 +19,42 @@
 
 #ifndef _ASMLANGUAGE
 
-/*******************************************************************************
-*
-* VB_HREG_SET - hardware register set, for read/write
-*
-* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
-* another VB
-* 
-* SYNOPSIS
-*
-* VB hardware register set C data structure type definition
-*
-*
-*     typedef struct		/@ VB_REG_SET - used for sys_regsRead/Write @/
-*         {
-*         uint32_t  eax;	/@ 00: general register		@/
-*         uint32_t  ebx;	/@ 04: general register		@/
-*         uint32_t  ecx;	/@ 08: general register		@/
-*         uint32_t  edx;	/@ 0C: general register		@/
-*         uint32_t  esi;	/@ 10: general register		@/
-*         uint32_t  edi;	/@ 14: general register		@/
-*         uint32_t  eip;	/@ 18: program counter		@/
-*         uint32_t  ebp;	/@ 1C: frame pointer register	@/
-*         uint32_t  esp;	/@ 20: stack pointer register	@/
-*         uint32_t  eflags;	/@ 24: status register		@/
-*         uint32_t  cr0;	/@ 28: control register 0	@/
-*         uint32_t  cr3;	/@ 2C: control register 3	@/
-*         uint32_t  cr4;	/@ 30: control register 4	@/
-*         uint32_t  idtr;	/@ 34: IDT task register	@/
-*         uint32_t  gdtr;	/@ 38: GDT task register	@/
-*         uint32_t  ldtr;	/@ 3C: LDT task register	@/
-*         uint32_t  cs;		/@ 40: code segment		@/
-*         uint32_t  ss;		/@ 44: stack segment		@/
-*         uint32_t  ds;		/@ 48: data segment		@/
-*         uint32_t  es;		/@ 4C: E segment		@/
-*         uint32_t  fs;		/@ 50: F segment		@/
-*         uint32_t  gs;		/@ 54: G segment		@/
-*         uint32_t  tr;		/@ 58: task register		@/
-*         } VB_HREG_SET;
-*
-*
-* SEE ALSO: NONE
-* 
-*/
+/*
+ *
+ * VB_HREG_SET - hardware register set, for read/write
+ *
+ * Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in
+ * another VB
+ *
+ *
+ */
 
 typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
-    {
-    uint32_t  eax;		/* 00: general register		*/
-    uint32_t  ebx;		/* 04: general register		*/
-    uint32_t  ecx;		/* 08: general register		*/
-    uint32_t  edx;		/* 0C: general register		*/
-    uint32_t  esi;		/* 10: general register		*/
-    uint32_t  edi;		/* 14: general register		*/
-    uint32_t  eip;		/* 18: program counter		*/
-    uint32_t  ebp;		/* 1C: frame pointer register	*/
-    uint32_t  esp;		/* 20: stack pointer register	*/
-    uint32_t  eflags;		/* 24: status register		*/
-    uint32_t  cr0;		/* 28: control register 0	*/
-    uint32_t  cr3;		/* 2C: control register 3	*/
-    uint32_t  cr4;		/* 30: control register 4	*/
-    uint32_t  idtr;		/* 34: IDT task register	*/
-    uint32_t  gdtr;		/* 38: GDT task register	*/
-    uint32_t  ldtr;		/* 3C: LDT task register	*/
-    uint32_t  cs;		/* 40: code segment		*/
-    uint32_t  ss;		/* 44: stack segment		*/
-    uint32_t  ds;		/* 48: data segment		*/
-    uint32_t  es;		/* 4C: E segment		*/
-    uint32_t  fs;		/* 50: F segment		*/
-    uint32_t  gs;		/* 54: G segment		*/
-    uint32_t  tr;		/* 58: task register		*/
-    } VBI_HREG_SET;
+{
+	uint32_t  eax;		/* 00: general register		*/
+	uint32_t  ebx;		/* 04: general register		*/
+	uint32_t  ecx;		/* 08: general register		*/
+	uint32_t  edx;		/* 0C: general register		*/
+	uint32_t  esi;		/* 10: general register		*/
+	uint32_t  edi;		/* 14: general register		*/
+	uint32_t  eip;		/* 18: program counter		*/
+	uint32_t  ebp;		/* 1C: frame pointer register	*/
+	uint32_t  esp;		/* 20: stack pointer register	*/
+	uint32_t  eflags;	/* 24: status register		*/
+	uint32_t  cr0;		/* 28: control register 0	*/
+	uint32_t  cr3;		/* 2C: control register 3	*/
+	uint32_t  cr4;		/* 30: control register 4	*/
+	uint32_t  idtr;		/* 34: IDT task register	*/
+	uint32_t  gdtr;		/* 38: GDT task register	*/
+	uint32_t  ldtr;		/* 3C: LDT task register	*/
+	uint32_t  cs;		/* 40: code segment		*/
+	uint32_t  ss;		/* 44: stack segment		*/
+	uint32_t  ds;		/* 48: data segment		*/
+	uint32_t  es;		/* 4C: E segment		*/
+	uint32_t  fs;		/* 50: F segment		*/
+	uint32_t  gs;		/* 54: G segment		*/
+	uint32_t  tr;		/* 58: task register		*/
+} VBI_HREG_SET;
 
 #endif /* _ASMLANGUAGE */
 
@@ -98,7 +64,7 @@ typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
 
 #define	VBI_X86_MAX_VECTORS         256	/* maximum number of vectors */
 #define VBI_ARCH_EXC_TABLE_SIZE     32
-#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)            
+#define VBI_ARCH_IRQ_TABLE_SIZE     (VBI_X86_MAX_VECTORS - VBI_ARCH_EXC_TABLE_SIZE)         
 
 #define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
 
@@ -180,7 +146,7 @@ typedef struct			/* VBI_REG_SET - used for sys_regsRead/Write */
 
 /* timer vector */
 
-#define VBI_CLOCK_TIMER_VECTOR		(0)
-#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0)    
+#define VBI_CLOCK_TIMER_VECTOR		0
+#define VBI_IN_APIC_TIMER		(VBI_IN_EXT_IRQ0) 
 
 #endif /* __INCVbiX86Archh */
diff --git a/include/vbi/errors.h b/include/vbi/errors.h
index 555631a..580623b 100644
--- a/include/vbi/errors.h
+++ b/include/vbi/errors.h
@@ -1,7 +1,7 @@
 /*
  * errors.h - vbi errors
- * 
- * Copyright (c) 2009 Wind River Systems, Inc. 
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 5468879..add0daa 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -16,69 +16,66 @@
 
 /*
 DESCRIPTION
-This module defines the data structures used for information flow between
-wind river Hypervisor and a Virtual Board. There are three structures employed
-for this purpose: 
-\ms
-\m - 
- configuration 
-\m - 
- status 
-\m -
- control
-\me
-
-The configuration structure is the first data exchanged between a given virtual 
-board and Hypervisor kernel. The pointers to the status and control structures are
-derived from the configuration structure. It contains pointers to the status, 
-control and other information about resources assigned to a virtual board. 
-The configuration data is shared accross the cores in the same virtual board unlike
-the data in the control and status structure which may be different for each core.
-The information in the configuration structure is static in the sense that the data
-it contains remain unmodified at least during the life of a boot cycle.
-
-The status structure is used to inform a virtual core at runtime about the state it
-is excecuting (interrupts, vmmu, elapsed time etc...). 
-
-The control structure is put in place as a fast method to pass information from
-the VB to Hypervisor or vis-versa. For examples during a virtual board context
-switch the control structure allows to store the incoming virtual board context
-setting before the virtual board sends a Hypercall using VBI_CTX_LOAD().
-
-Hypervisor passes (as parameter) a pointer of the configuration structure to the 
-entry function of the virtual core and a boot option flag. 
-
-The VBI library provides a initialization function vbiInit() to ensures that 
-Hypervisor version number is compatible with the VBI library in use. If the versions
-match then the configuration, status and control pointers are stored respectively to
-wrhvVbConfig, wrhvStatus and wrhvVbControl. 
-
-Therefore a virtual board must always call vbiInit() before accessing any data
-provided by Hypervisor nor send a hypercall to it. Refer to to vbiInit() description in the VBI API description document for more information. 
-
-Once the VBI library is initialized the virtual board should employ the provided 
-macros in order to access the fieds in wrhVbConfig, wrhvVbStatus and wrhvVbControl
-data structures. Accessing these structures via the VBI function guaranties source
-level compatibily between VBI versions.
-
-A guest OS should port vbiInit(), the access macros along with the necessary header
-files where the data structrures layout is defined.
- To be aware:
-\ms
-\m -
- Changing the order of the field this structure may have serious impact on the
- integrity of the system. It exists hand crafted macros to match the C
- structures offset. Therefore any change should be reflected in the macros
- 
-\m -
- When a virtual core boots the VMMU is not enbled but a programmer may choose
- to turn-on the VMMU. In that scenario proper care must be taken to ensure that
- the address where the control, status or configureation structure is reflected
- in the VMMU mapping. Technically these area should be treated as I/O region
- therefore it is encouraged that they are identity mapped.  
-\me
-
-\APPEND vbi/vbi.h
+This module defines the data structures used for information flow between the
+Wind River Hypervisor and a virtual board. There are three structures employed
+for this purpose:
+
+		configuration status control
+
+The configuration structure is the first data exchanged between a given
+virtual board and Hypervisor kernel. The pointers to the status and
+control structures are derived from the configuration structure. It
+contains pointers to the status, control and other information about
+resources assigned to a virtual board.  The configuration data is shared
+accross the cores in the same virtual board unlike the data in the
+control and status structure which may be different for each core.  The
+information in the configuration structure is static in the sense that
+the data it contains remain unmodified at least during the life of a
+boot cycle.
+
+The status structure is used to inform a virtual core at runtime about
+the state it is excecuting (interrupts, vmmu, elapsed time etc...).
+
+The control structure is put in place as a fast method to pass
+information from the VB to Hypervisor or vis-versa. For examples during
+a virtual board context switch the control structure allows to store the
+incoming virtual board context setting before the virtual board sends a
+Hypercall using VBI_CTX_LOAD().
+
+Hypervisor passes (as parameter) a pointer of the configuration
+structure to the entry function of the virtual core and a boot option
+flag.
+
+The VBI library provides a initialization function vbiInit() to ensures
+that Hypervisor version number is compatible with the VBI library in
+use. If the versions match then the configuration, status and control
+pointers are stored respectively to wrhvVbConfig, wrhvStatus and
+wrhvVbControl.
+
+Therefore a virtual board must always call vbiInit() before accessing
+any data provided by Hypervisor nor send a hypercall to it. Refer to to
+vbiInit() description in the VBI API description document for more
+information.
+
+Once the VBI library is initialized the virtual board should employ the
+provided macros in order to access the fieds in wrhVbConfig,
+wrhvVbStatus and wrhvVbControl data structures. Accessing these
+structures via the VBI function guaranties source level compatibily
+between VBI versions.
+
+A guest OS should port vbiInit(), the access macros along with the
+necessary header files where the data structrures layout is defined.  To
+be aware:  Changing the order of the field this structure may
+have serious impact on the integrity of the system. It exists hand
+crafted macros to match the C structures offset. Therefore any change
+should be reflected in the macros
+
+When a virtual core boots the VMMU is not enbled but a programmer may
+choose to turn-on the VMMU. In that scenario proper care must be taken
+to ensure that the address where the control, status or configureation
+structure is reflected in the VMMU mapping. Technically these area
+should be treated as I/O region therefore it is encouraged that they are
+identity mapped.
 
 */
 
@@ -97,103 +94,99 @@ files where the data structrures layout is defined.
 /* macro to align guest fields for a 64-bit hypervisor */
 
 #if defined(LP64)
-# define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
 			   __attribute__(( aligned(8) )) \
 			   decl_var
 #else
-# if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
-#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+#if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
 			    __attribute__(( aligned(8) )) \
 			    decl_var; \
 			    uint32_t pad_var
-# else
-#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+#else
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
 			    __attribute__(( aligned(8) )) \
 			    uint32_t pad_var; \
 			    decl_var
-# endif
+#endif
 #endif
 
 #define VB_PRINTF(fmt, args...)    printk(fmt, ##args)
 
 #undef VB_DEBUG  /* define it to turn on debugging */
 #ifdef VB_DEBUG
-# define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
+#define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
 #else
-# define VB_DEBUG_MSG(fmt, args...)
+#define VB_DEBUG_MSG(fmt, args...)
 #endif
 
 
 /* Configuration Filename for the hypervisor this must not change */
-
 #define VB_WRHV_CONFIGURATION_FILE "wrhvConfig.xml"
 
 /* Hard limits for now */
+#define VB_MAX_VIRTUAL_BOARDS		1024
+#define VB_MAX_BUSES			1024
 
-#define VB_MAX_VIRTUAL_BOARDS    1024
-#define VB_MAX_BUSES             1024
-
-#define VB_MAX_CORES     	 8
+#define VB_MAX_CORES			8
 
 /* Type definitions for all name identifer strings in the hypervisor */
-
-#define VB_MAX_WRHV_NAME_LENGTH 64
+#define VB_MAX_WRHV_NAME_LENGTH		64
 
 #ifndef	_ASMLANGUAGE
 typedef int8_t VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
 
-#define VB_MAX_BOOTLINE_LENGTH   256
+#define VB_MAX_BOOTLINE_LENGTH		256
 
 /* Virtual board timestamp is 64 bits */
-
 typedef uint64_t VB_TIMESTAMP;
 #endif
 
-/* Virtual Interrupt Controller definitions --------------------------- */
+/* Virtual Interrupt Controller definitions */
 
-/* 32 is chosen as the maximum number of interrupt sources allowed.
+/*
+ * 32 is chosen as the maximum number of interrupt sources allowed.
  * care must be taken if this is changed, since some algorithms and
  * data structures will require modifications and become more complex
  */
 
-#define VB_MAX_INTERRUPTS     32
+#define VB_MAX_INTERRUPTS		32
 
-/* The maximum number of associated data stored with each interrupt.
+/*
+ * The maximum number of associated data stored with each interrupt.
  * This can be modified without any impacts, tho it should not be
  * set to 0
  */
 
-#define VB_MAX_INTERRUPT_DATA 16
+#define VB_MAX_INTERRUPT_DATA		16
 
 /* Structure offsets for assembler */
 
 #if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
-# define VB_CONTROL_REG_STRUCT_END 0
+#define VB_CONTROL_REG_STRUCT_END	0
 #endif
 
-# define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
 #if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
 #else
-# define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
-# define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
 #endif /* __VBI_BYTE_ORDER */
 
 /* Bit Mask definitions for VB_STATUS_INT_PENDING */
-
 #define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
 #define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
 
 /* Assembler offsets for VB_STATUS */
-
 #if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
-# define VB_STATUS_REG_STRUCT_END	0
+#define VB_STATUS_REG_STRUCT_END	0
 #endif
 
 #define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
@@ -202,43 +195,40 @@ typedef uint64_t VB_TIMESTAMP;
 #define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
 #define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
 #if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
 #else
-# define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
-# define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
 #endif /* __VBI_BYTE_ORDER */
 
 /* Assembler offsets for VB_CONFIG */
-
 #if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
-# define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
-# define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
-# define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
-# define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
-# define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+#define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+#define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+#define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+#define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
 #else
-# define VB_CONFIG_VBSTATUS		((2+0) * 8)
-# define VB_CONFIG_VBCONTROL		((2+1) * 8)
-# define VB_CONFIG_SMINFO		((2+2) * 8)
-# define VB_CONFIG_MEMINFO		((2+3) * 8)
-# define VB_CONFIG_INTINFO		((2+4) * 8)
+#define VB_CONFIG_VBSTATUS		((2+0) * 8)
+#define VB_CONFIG_VBCONTROL		((2+1) * 8)
+#define VB_CONFIG_SMINFO		((2+2) * 8)
+#define VB_CONFIG_MEMINFO		((2+3) * 8)
+#define VB_CONFIG_INTINFO		((2+4) * 8)
 #endif /* __VBI_BYTE_ORDER */
 
 /* Defines for vbIntInfo intDirection field */
-
-#define VB_INPUT_INT  1
-#define VB_OUTPUT_INT 2
+#define VB_INPUT_INT	1
+#define VB_OUTPUT_INT	2
 
 /*
  * Defines for the second parameter passed to the startup program
- * in a virtual board by Razor
+ * in a virtual board by the hypervisor.
  */
-
 #define VB_BOOT_COLD	1
 #define VB_BOOT_WARM	2
 #define VB_BOOT_RESTART	3
@@ -249,380 +239,258 @@ typedef uint64_t VB_TIMESTAMP;
 
 #ifndef	_ASMLANGUAGE
 
-/*******************************************************************************
-*
-* VB_CONTROL - Virtual board cores control structure 
-*
-* VB_CONTROL is a data type that defines a virtual core's control structure.
-* This is called the control structure because a core uses to modify it's 
-* state. The code running in the context of a virtual core puts the desired
-* setting in this control and passes to Hypervisor via the Hypercall mechanism.
-* It is suggested to use the provided APIs for manipulating the virtual core
-* control structure instead of directly accessing it's members. 
-* Typically use cases for this structure are for following:
-*
-* 
-* During context switch for setting the incoming context's register state.
-* For more information about this refer to VBI_CTX_LOAD() description in the
-* architecture supplement API documentation.
-*
-* Locking/unlocking the virtual core interrupts.
-*
-* Loading the VMMU configuration data.
-*
-* VIOAPIC configuration registers.
-* 
-*\me   
-* The control structure definition is generic accross the various architecture
-* flavours supported by Hypervisor with the exception of the emulated registers. 
-* There is an architecture specific extention available via a pointer of type 
-* VB_ARCH_STATUS_REGS to accomodate the registers unique for a given hardware
-* platform.
-* However that does imply that other fields defined in this structure are used
-* in every architecture. A field is considered generic if it is usefull at least to
-* two CPU families but not necessary to all CPUs.
-* The VIOAPIC is the only field that is meaning full accross all architectures.
-* Note that some architectures like Intel with VT technology don't require emulated
-* registers. The pointer of emulated registers is included only if 
-*_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
-* with read/write access attribute for the purpose of serving as duplex 
-* communication channel between Hypervisor and a virtual core. This mechanism
-* is fall back when it is not possible to use registers for transmitting data
-* from the virtual core to Hypervisor or vis-versa. More information about 
-* VB_ARCH_CONTROL_REGS may be found in the architecture supplement document.
-*
-* 
-* Control structure graphical illustration
-*
-*    ______________
-*   |              |
-*   |              |<------- 64bits - pointer to arch specific registers 
-*   |              |          (See architecture supplement documentation)         
-*   |--------------|
-*   |              |<------- 32bits -  interrupt state flag
-*   |--------------|
-*   |              |<------- 32bits - virtual core to be loaded context's 
-*   |--------------|                  interrupt state    
-*   |              | 
-*   |              |<------- 64bits - pointer to VMMU configuration
-*   |--------------|
-*   |              |<------- 64bits - pointer to additional VMMU 
-*   |              |                  configuration (reserved for enhancement)  
-*   |--------------|
-*   |              | <------ 64bits - VIOAPIC information header (internal use only)
-*   |              |
-*   |--------------|
-*   |		   |
-*   |              |<------- Nbytes - VIOAPIC redirection table    
-*   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE   
-*   |              |
-*   |--------------|<------- 32bits - Pending interrupt vector number  
-*   |______________|            
-*
-*
-* SYNOPSIS
-*
-* Virtual core's control C data structure type definition
-*
-* typedef struct vbControl {
-*
-*    /@
-*     @ Some architecture like Intel with hardware virtualization support don't
-*     @ make use vbControlRegs.
-*     @/
-*
-*#ifdef  _WRHV_ARCH_HAS_CTRL_REGS         
-*    VB_ALIGN_FIELD_64 (VB_ARCH_CONTROL_REGS  * vbControlRegs, pad1);
-*#endif
-*
-*   /@  0: -1 => Disable all interrupts					@/
-*
-*    uint32_t	intDisable;	
-*
-*   /@ 
-*    @ future interrupt state of a context to be loaded in 
-*    @ vbControl->intDisable after a context switch	    
-*    @/
-*
-*    uint32_t	newIntDisable;	
-*
-*   /@  2: VMMU 0 table for context switch				@/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
-*
-*   /@  3: VMMU 1 table for context switch				@/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
-*
-*   /@ Virtual I/O APIC							@/
-*
-*    VB_ALIGN_FIELD_64 (uint32_t    vIoapicRegisters[VB_VIOAPIC_SIZE], pad4);
-*
-*   /@ actual virtual interrupt pending					@/
-*
-*    uint32_t	intPending;
-*
-*   } VB_CONTROL;
-*
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-*
-* INTERNAL
-* warning!!!!!!!
-* 1. Any modification of this structure field should be reflected in the
-* description.
-* 2. Make sure that VIOAPIC_SIZE is used in the structure
-* 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
-*     the code
-* 
-*/
+/*
+ * VB_CONTROL - Virtual board cores control structure
+ *
+ * VB_CONTROL is a data type that defines a virtual core's control structure.
+ * This is called the control structure because a core uses to modify it's
+ * state. The code running in the context of a virtual core puts the desired
+ * setting in this control and passes to Hypervisor via Hypercall mechanism.
+ * It is suggested to use the provided APIs for manipulating the virtual core
+ * control structure instead of directly accessing it's members.
+ * Typically use cases for this structure are for following:
+ *
+ *
+ * During context switch for setting the incoming context's register state.
+ * For more information about this refer to VBI_CTX_LOAD() description in the
+ * architecture supplement API documentation.
+ *
+ * Locking/unlocking the virtual core interrupts.
+ *
+ * Loading the VMMU configuration data.
+ *
+ * VIOAPIC configuration registers.
+ *
+ * The control structure definition is generic accross the various
+ * architecture flavours supported by Hypervisor with the exception of
+ * the emulated registers.  There is an architecture specific extention
+ * available via a pointer of type VB_ARCH_STATUS_REGS to accomodate the
+ * registers unique for a given hardware platform.  However that does
+ * imply that other fields defined in this structure are used in every
+ * architecture. A field is considered generic if it is usefull at least
+ * to two CPU families but not necessary to all CPUs.  The VIOAPIC is
+ * the only field that is meaning full accross all architectures.  Note
+ * that some architectures like Intel with VT technology don't require
+ * emulated registers. The pointer of emulated registers is included
+ * only if_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure
+ * is mapped with read/write access attribute for the purpose of serving
+ * as duplex communication channel between Hypervisor and a virtual
+ * core. This mechanism is fall back when it is not possible to use
+ * registers for transmitting data from the virtual core to Hypervisor
+ * or vis-versa.  More information about VB_ARCH_CONTROL_REGS may be
+ * found in the architecture supplement document.
+ *
+ *
+ * Control structure graphical illustration
+ *
+ *    ______________
+ *   |              |
+ *   |              |<------- 64bits - pointer to arch specific registers
+ *   |              |          (See architecture supplement documentation)
+ *   |--------------|
+ *   |              |<------- 32bits -  interrupt state flag
+ *   |--------------|
+ *   |              |<------- 32bits - virtual core to be loaded context's
+ *   |--------------|                  interrupt state
+ *   |              |
+ *   |              |<------- 64bits - pointer to VMMU configuration
+ *   |--------------|
+ *   |              |<------- 64bits - pointer to additional VMMU
+ *   |              |                  configuration (reserved for enhancement)
+ *   |--------------|
+ *   |              | <------ 64bits - VIOAPIC information header
+ *   |              |				 (internal use only)
+ *   |--------------|
+ *   |		    |
+ *   |              |<------- Nbytes - VIOAPIC redirection table
+ *   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE
+ *   |              |
+ *   |--------------|<------- 32bits - Pending interrupt vector number
+ *   |______________|
+ *
+ *
+ * INTERNAL warning!!!!!!!
+ * 1. Any modification of this structure field should be reflected in the
+ * description.
+ * 2. Make sure that VIOAPIC_SIZE is used in the structure
+ * 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
+ *     the code
+ *
+ */
 
-typedef struct vbControl {
+typedef struct vbControl
+{
 
-#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	      
-    VB_ARCH_CONTROL_REGS  vbControlRegs;
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	
+	VB_ARCH_CONTROL_REGS  vbControlRegs;
 #endif
 
-    uint32_t	intDisable;	/*  0: -1 => Disable all interrupts */
-    uint32_t	newIntDisable;	/*  1: New value for vbControl->intDisable */
-
-				/*  2: VMMU 0 table for context switch */
-    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
-
-				/*  3: VMMU 1 table for context switch */
-    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+	uint32_t intDisable;		/*  0: -1 => Disable all interrupts */
+	uint32_t newIntDisable;		/*  1: New value for ->intDisable */
 
-    uint32_t	intLevelDisable;/* interrupt level enabling */
+					/*  2: VMMU 0 table for ctxt switch */
+	VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
 
-    /* Virtual I/O APIC */
+					/*  3: VMMU 1 table for ctxt switch */
+	VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
 
-    VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
+	uint32_t intLevelDisable;	/* interrupt level enabling */
 
-    /* actual virtual interrupt pending */
+					/* Virtual I/O APIC */
+	VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
 
-    uint32_t	intPending;
+	uint32_t intPending;		/* actual virtual interrupt pending */
 
 } VB_CONTROL;
 
 
-/*******************************************************************************
-*
-* VB_STATUS - Virtual board's core status structure
-*
-* VB_STATUS is a C data type structure that provides the definition of an area
-* where the state of a given core is posted by Hypervisor before a virtual core is 
-* scheduled to run. The fields of this structure are architecture agnostic. 
-* A pointer is provided to accomodate anything that is specific to the underlying
-* hardware. The architecture specific structure is included only if 
-* _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type  VB_STATUS_ARCH_REGS
-* holding the architecture dependent registers is defined by a file pulled
-* vbi/arch.h at compile type according to CPU value.
-* The definition of VB_ARCH_STATUS_REGS can be found in the architecture
-* supplement documentation.
-* The purpose of this structure is to inform a virtual core at runtime the
-* status of a core's time variant data such as:
-*
-* 
-* Interrupts state
-*
-*\m *
-* current interrupt state
-*\m *
-* previous interrupt state if the core is in an ISR context
-*\m *
-* The pending vector number if any
-*\me
-*
-* A free running clock timestamp
-*
-* Virtual core elapsed timer ticks
-*
-* Current VMMU configuration
-*\me
-*  
-* SYNOPSIS
-*
-* Control structure graphical illustration
-*
-*        _______________   
-*       |		|	
-*       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
-*       |		|		structure pointer
-*       |---------------|
-*       |		|<-------32bits - intPending; pending vector number
-*       |---------------|
-*       |///////////////|<-------32bits - Reserved for future enhencements
-*       |---------------|
-*       |		|<-------64bits - timeStamp; free running clock ticks
-*       |		|
-*       |---------------|
-*       |		|<-------32bits - oldIntDisable; interrupt state before
-*       |---------------|		   an interrupt was injected
-*       |		|<-------32bits - 
-*       |---------------|
-*       |		|
-*       |		|<-------64bits - vmmu0; current VMMU configuration
-*       |---------------|
-*       |		|<-------64bits - vmmu1; reserved for future use
-*       |		|
-*       |---------------|
-*       |		|<-------64bits - tickCount; elapsed virtual core ticks
-*       |		|
-*       |---------------|
-*
-*
-*
-* Virtual core's status C data structure type definition
-*
-*
-* VB_STATUS structure definition
-*
-* typedef struct vbStatus {
-*    /@
-*     @ Some architecture like Intel with hardware virtualization support don't
-*     @ make use vbStatusRegs
-*     @/
-*
-* #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-*    VB_ALIGN_FIELD_64 (VB_ARCH_STATUS_REGS  vbStatusRegs, pad1);
-* #endif
-*
-*    /@ Bits indicating which interrupts are pending			    @/
-*
-*    uint64_t	intPendingType;
-*
-*    /@ reserved field for future use, required for timeStamp alignment	    @/
-*
-*    uint32_t	reserved1;
-*
-*    /@ Timestamp when last interrupt was delivered			    @/
-*
-*    VB_TIMESTAMP timeStamp;  
-*
-*    /@ 
-*     @ Interrupt registers when the hypervisor interrupts a virtual board, 
-*     @ it saves the following information here for use by the virtual board.
-*     @/
-*
-*    /@ value of control->intDisable at time of the interrupt.
-*     @ control->intDisable is set to -1 by WRHV at the time of delivery of
-*     @ the interrupt
-*     @/
-*
-*    uint32_t	oldIntDisable; 
-*
-*    /@ VMMU tables which were active when an MMU exception occurred	    @/
-*
-*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
-*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
-*
-*    /@ VB wall clock time expressed in the VB clock frequency  @/
-*
-*    uint64_t tickCount;
-*
-* } VB_STATUS;
-*
-*
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-* INTERNAL
-* Make sure that intPendingType modification is reflected in the code
-*
-*
-*/
+/*
+ * VB_STATUS - Virtual board's core status structure
+ *
+ * VB_STATUS is a C data type structure that provides the definition of
+ * an area where the state of a given core is posted by Hypervisor
+ * before a virtual core is scheduled to run. The fields of this
+ * structure are architecture agnostic.  A pointer is provided to
+ * accomodate anything that is specific to the underlying hardware. The
+ * architecture specific structure is included only if
+ * _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type
+ * VB_STATUS_ARCH_REGS holding the architecture dependent registers is
+ * defined by a file pulled vbi/arch.h at compile type according to CPU
+ * value.  The definition of VB_ARCH_STATUS_REGS can be found in the
+ * architecture supplement documentation.  The purpose of this structure
+ * is to inform a virtual core at runtime the status of a core's time
+ * variant data such as:
+ *
+ *
+ * Interrupts state
+ *
+ * current interrupt state
+ *
+ * previous interrupt state if the core is in an ISR context
+ *
+ * The pending vector number if any
+ *
+ * A free running clock timestamp
+ *
+ * Virtual core elapsed timer ticks
+ *
+ * Current VMMU configuration
+ *
+ *
+ * Control structure graphical illustration
+ *
+ *        ______________
+ *       |		|	
+ *       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
+ *       |		|		structure pointer
+ *       |--------------|
+ *       |		|<-------32bits - intPending; pending vector number
+ *       |--------------|
+ *       |//////////////|<-------32bits - Reserved for future enhencements
+ *       |--------------|
+ *       |		|<-------64bits - timeStamp; free running clock ticks
+ *       |		|
+ *       |--------------|
+ *       |		|<-------32bits - oldIntDisable; interrupt state before
+ *       |--------------|		   an interrupt was injected
+ *       |		|<-------32bits -
+ *       |--------------|
+ *       |		|
+ *       |		|<-------64bits - vmmu0; current VMMU configuration
+ *       |--------------|
+ *       |		|<-------64bits - vmmu1; reserved for future use
+ *       |		|
+ *       |--------------|
+ *       |		|<-------64bits - tickCount; elapsed virtual core ticks
+ *       |		|
+ *       |--------------|
+ *
+ */
 
 typedef struct vbStatus {
 
-#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    VB_ARCH_STATUS_REGS  vbStatusRegs;
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS
+	VB_ARCH_STATUS_REGS  vbStatusRegs;
 #endif
 
-    /* Bits indicating which interrupts are pending */
-
-    uint32_t	intPendingType;
-
-    /* reserved field for future use, required for timeStamp alignment */
-
-    uint32_t	reserved1;
-
-    /* Timestamp when last interrupt was delivered */
-
-    VB_TIMESTAMP timeStamp;  
-
-    /* Interrupt registers
-     *
-     * When the hypervisor interrupts a virtual board, it saves the following
-     * information here for use by the virtual board.
-     */
-
-    /* value of control->intDisable at time of the interrupt.
-     * control->intDisable is set to -1 by WRHV at the time of delivery of
-     * the interrupt
-     */
-
-    uint32_t	oldIntDisable; 
+	/* Bits indicating which interrupts are pending */
+	uint32_t intPendingType;
 
-    /* VMMU tables which were active when an MMU exception occurred */
+	/* reserved field for future use, required for timeStamp alignment */
+	uint32_t reserved1;
 
-    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
-    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+	/* Timestamp when last interrupt was delivered */
+	VB_TIMESTAMP timeStamp;
 
-    /* Virtual Board clock tick count */
+	/*
+	 * Interrupt registers
+	 * When the hypervisor interrupts a VB, it saves the following
+	 * information here for use by the virtual board.
+	 *
+	 * value of control->intDisable at time of the interrupt.
+	 * control->intDisable is set to -1 by WRHV at the time of delivery of
+	 * the interrupt
+	 */
+	uint32_t	oldIntDisable;
 
-    uint64_t tickCount;
+	/* VMMU tables which were active when an MMU exception occurred */
+	VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+	VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
 
-    /* number of times this core has booted */
+	/* Virtual Board clock tick count */
+	uint64_t tickCount;
 
-    uint32_t	 bootCount;	 
+	/* number of times this core has booted */
+	uint32_t bootCount;	
 
-    /* initial program load flag */
+	/* initial program load flag */
 
-    uint32_t	 ipl;	 
+	uint32_t ipl;	
 
-    /* The simulatror flag  */
+	/* The simulatror flag  */
 
-    uint32_t	 sim;	 
+	uint32_t sim;	
 
 } VB_STATUS;
 
 /*
- * ----------------------- Virtual BOARD STATUS PAGE -----------------------
+ * Virtual board status page
  *
  * Read only page used to provide static configuration to the Virtual Board
  *
  */
 
 /* Configuration information for interrupts */
-
-typedef struct vbIntInfo {
-    VB_WRHV_NAME intName;	/* the name of this interrupt */
-    uint16_t	 intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
-    uint16_t	 intNumber;	/* the local VB interrupt number */
-    uint32_t	 intCore;	/* the receiving core for this incomming int */
+typedef struct vbIntInfo
+{
+	VB_WRHV_NAME intName;	/* the name of this interrupt */
+	uint16_t intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
+	uint16_t intNumber;	/* the local VB interrupt number */
+	uint32_t intCore;	/* the receiving core for this incomming int */
 } VB_INT_INFO;
 
 /* Information about a shared memory region */
-
-typedef struct vbSmInfo {
-    VB_WRHV_NAME name;		/* the name of the shared memory region */
+typedef struct vbSmInfo
+{
+	VB_WRHV_NAME name;	/* the name of the shared memory region */
 				/* the vbphysical address of the region */
-    VB_ALIGN_FIELD_64 (void *addr, pad1);
-    uint32_t	 length;	/* the length in bytes of the region */
-    uint32_t	 attr;		/* the MMU attributes of the region */
-    uint32_t	 type;		/* shared memory type field */
+	VB_ALIGN_FIELD_64 (void *addr, pad1);
+	uint32_t length;	/* the length in bytes of the region */
+	uint32_t attr;		/* the MMU attributes of the region */
+	uint32_t type;		/* shared memory type field */
 				/* id's of connected boards */
-    VB_ALIGN_FIELD_64 (void *boardIds, pad2);
+	VB_ALIGN_FIELD_64 (void *boardIds, pad2);
 } VB_SM_INFO;
 
 /* Information for the memory map info */
-
-typedef struct vbMemInfo {
-    VB_WRHV_NAME name;		/* the name of the memory region */
+typedef struct vbMemInfo
+{
+	VB_WRHV_NAME name;	/* the name of the memory region */
 				/* the vbphysical address of the region */
-    VB_ALIGN_FIELD_64 (void *addr, pad1);
-    uint32_t	 length;	/* the length in bytes of the region */
-    uint32_t	 attr;		/* the MMU attributes of the region */
-    VB_WRHV_NAME type;		/* the type of the region */
+	VB_ALIGN_FIELD_64 (void *addr, pad1);
+	uint32_t length;	/* the length in bytes of the region */
+	uint32_t attr;		/* the MMU attributes of the region */
+	VB_WRHV_NAME type;		/* the type of the region */
 } VB_MEM_INFO;
 
 
@@ -631,137 +499,115 @@ typedef struct vbMemInfo {
  * the Virtual Board itself.  The address of this structure is passed as the
  * first parameter to the virtual board when it is started at its entry point.
  */
+typedef struct vbConfig
+{
 
-typedef struct vbConfig {
-
-    /* 
-     *  structure versioning information
-     *  --------------------------------
-     */
-
-    uint32_t major;	/* major revision number */
-    uint32_t minor;	/* minor revision number */
-    uint32_t maint;	/* maintenance revision number */
-    uint32_t pad;
-
-    /* 
-     *  pointers to secondary configuration structures
-     *  ----------------------------------------------
-     */
-
-    /* read-only status information */
-
-    VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
-
-    /* read-write control information */
+	/*
+	 *  structure versioning information
+	 */
 
-    VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
+	uint32_t major;	/* major revision number */
+	uint32_t minor;	/* minor revision number */
+	uint32_t maint;	/* maintenance revision number */
+	uint32_t pad;
 
-    /* shared memory information (memory map) */
+	/*
+	 *  pointers to secondary configuration structures
+	 */
 
-    VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
+	/* read-only status information */
+	VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
 
-    /* memory regions information (memory map) */
+	/* read-write control information */
+	VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
 
-    VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
+	/* shared memory information (memory map) */
+	VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
 
-    /* information about incoming and outgoing interrupt connections */
+	/* memory regions information (memory map) */
+	VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
 
-    VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
+	/* information about incoming and outgoing interrupt connections */
+	VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
 
-    /* 
-     *  general board specific configuration information
-     *  ------------------------------------------------
-     */
+	/*
+	 *  general board specific configuration information
+	 */
 
-    uint32_t	 pid;		 /* hypervisor context id */
-    vbiVb_t	 boardID;	 /* board ID from the XML configuration */
+	uint32_t pid;		/* hypervisor context id */
+	vbiVb_t boardID;	/* board ID from the XML configuration */
 
-    int32_t	 supervisoryMode;/* board is running in privileged mode */
+	int32_t supervisoryMode;/* board is running in privileged mode */
 
-    VB_WRHV_NAME boardName;	 /* the name of this board */
-    uint32_t	 boardType;	 /* the type of this board */
-    uint32_t	 bootCount;	 /* number of times this core has booted */
+	VB_WRHV_NAME boardName;	/* the name of this board */
+	uint32_t boardType;	/* the type of this board */
+	uint32_t bootCount;	/* number of times this core has booted */
 
-				 /* entry point for this VB */
-    VB_ALIGN_FIELD_64 (void *resetPC, pad6);
+				/* entry point for this VB */
+	VB_ALIGN_FIELD_64 (void *resetPC, pad6);
 
-    /* 
-     *  virtual core specific information
-     *  ---------------------------------
-     */
+	/*
+	 *  virtual core specific information
+	 */
 
-    uint32_t  coreId;		  /* virtual core cpu id */
-    uint32_t  numCores;		  /* number of virtual cores */
-    uint32_t  corePrivateSize;	  /* size of core private memory */
-				  /* pointer to core private memory */
-    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+	uint32_t coreId;	/* virtual core cpu id */
+	uint32_t numCores;	/* number of virtual cores */
+	uint32_t corePrivateSize;/* size of core private memory */
+				/* pointer to core private memory */
+	VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
 
-    /* 
-     *  main memory configuration settings 
-     *  ----------------------------------
-     */
+	/*
+	 *  main memory configuration settings
+	 */
 
-    uint32_t  physicalMemorySize; /* the vbPhysical size of RAM */
-    uint32_t  memoryAliasAddress; /* address to which memory is aliased */
-    uint32_t  memoryAliasSize;	  /* size of aliases memory */
-    uint32_t  numMem;		  /* number of memory regions */
+	uint32_t physicalMemorySize;	/* the vbPhysical size of RAM */
+	uint32_t memoryAliasAddress;	/* address to which memory is aliased */
+	uint32_t memoryAliasSize;	/* size of aliases memory */
+	uint32_t numMem;		/* number of memory regions */
 
-    /* 
-     *  shared memory configuration settings
-     *  ------------------------------------
-     */
+	/*
+	 *  shared memory configuration settings
+	 */
 
-    /* number of shared memory regions */
+	/* number of shared memory regions */
+	uint32_t numSm;
 
-    uint32_t  numSm;
+	/* shared memory state information */
+	VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
 
-    /* shared memory state information */
+	/*
+	 *  clock and interrupt configuration
+	 */
 
-    VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
+	/* the frequency of the periodic tick interrupt */
+	uint32_t tickTimerFrequency;	/* ticks per second */
 
-    /* 
-     *  clock and interrupt configuration
-     *  ---------------------------------
-     */
+	/* the frequency of the timestamp */
+	uint32_t timeStampFrequency;	/* ticks per second */
 
-    /* the frequency of the periodic tick interrupt */
+	/* number of interrupts connected to this board */
+	uint32_t numInts;
 
-    uint32_t  tickTimerFrequency;	/* ticks per second */
+	/*
+	 *  misc settings
+	 */
 
-    /* the frequency of the timestamp */
+	/* OS specific boot line */
+	char bootLine[VB_MAX_BOOTLINE_LENGTH];
 
-    uint32_t  timeStampFrequency;	/* ticks per second */
+	/* spare 32-bit fields for future use */
+	uint32_t spare32[16];
 
-    /* number of interrupts connected to this board */
+	/* spare 64-bit fields for future use */
+	uint64_t spare64[16];
 
-    uint32_t  numInts;
-
-    /* 
-     *  misc settings
-     *  -------------
-     */
-
-    /* OS specific boot line */
-
-    char      bootLine[VB_MAX_BOOTLINE_LENGTH];
-
-    /* spare 32-bit fields for future use */
-
-    uint32_t	spare32[16];
-
-    /* spare 64-bit fields for future use */
-
-    uint64_t	spare64[16];
-
-    /* direct function call interface table */
+	/* direct function call interface table */
 
 #if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
-    VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
-    VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
+	VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
+	VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
 #endif
 } VB_CONFIG;
 
 #endif /*_ASMLANGUAGE */
-
 #endif  /* __INCvbInterfaceh */
diff --git a/include/vbi/io_apic.h b/include/vbi/io_apic.h
index 43c269a..64f2a2f 100644
--- a/include/vbi/io_apic.h
+++ b/include/vbi/io_apic.h
@@ -31,77 +31,81 @@
 /* data structures */
 
 /* IO APIC ID register */
-typedef union {
-    struct {
-	uint32_t reserved1:24;	/* reserved bits */
-	uint32_t IOAPIC_id:4;	/* apic id */
-	uint32_t reserved2:4;	/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t reserved1:24;	/* reserved bits */
+		uint32_t IOAPIC_id:4;	/* apic id */
+		uint32_t reserved2:4;	/* reserved bits */
+	} field;
+	uint32_t value;
 } VIOAPIC_ID;
 
 
 /* IO APIC Version Register */
 
-typedef union {
-    struct {
-	uint32_t version:8;		/* version identifier */
-	uint32_t reserved1:8;		/* reserved bits */
-	uint32_t maxRedirEntry:8;	/* maximum number of entries - 1, or
-					 * number of IRQ pins - 1 */
-	uint32_t reserved2:8;		/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t version:8;		/* version identifier */
+		uint32_t reserved1:8;		/* reserved bits */
+		uint32_t maxRedirEntry:8;	/* max # of entries - 1, or
+						 * number of IRQ pins - 1 */
+		uint32_t reserved2:8;		/* reserved bits */
+	} field;
+
+	uint32_t value;
 } VIOAPIC_VERSION;
 
 /* Virtual IO APIC redirection table entry. Split into high/low 32 */
 
-typedef union {
-    struct {
-	uint32_t reserved:24;	/* reserved bits */
-	uint32_t destination:8;	/* destination field */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t reserved:24;	/* reserved bits */
+		uint32_t destination:8;	/* destination field */
+	} field;
+	uint32_t value;
 } VIOAPIC_REDIR_HIGH;
 
-typedef union {
-    struct {
-	uint32_t vector:8;	/* vector number */
-	uint32_t deliveryMode:3;/* delivery mode:
-				 * fixed, lowest, SMI, reserved, NMI, 
-				 * INIT, reserved, extInt */
-	uint32_t destMode:1;	/* destination mode: 0=physical, 1=logical */
-	uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
-	uint32_t polarity:1;	/* polarity: 0=high active */
-	uint32_t irr:1;		/* remote IRR (level only): 1 before LAPIC
-				 * accepts level, 0 after EOI */
-	uint32_t trigger:1;	/* 0=edge, 1=level */
-	uint32_t mask:1;	/* 1=masked */
-	uint32_t reserved:15;	/* reserved bits */
-    } field;
-
-    uint32_t value;
+typedef union
+{
+	struct
+	{
+		uint32_t vector:8;	/* vector number */
+		uint32_t deliveryMode:3;/* delivery mode:
+					 * fixed, lowest, SMI, reserved, NMI,
+					 * INIT, reserved, extInt */
+		uint32_t destMode:1;	/* dest mode: 0=physical, 1=logical */
+		uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
+		uint32_t polarity:1;	/* polarity: 0=high active */
+		uint32_t irr:1;		/* rem. IRR (lvl only): 1 before LAPIC
+					 * accepts level, 0 after EOI */
+		uint32_t trigger:1;	/* 0=edge, 1=level */
+		uint32_t mask:1;	/* 1=masked */
+		uint32_t reserved:15;	/* reserved bits */
+	} field;
+	uint32_t value;
 } VIOAPIC_REDIR_LOW;
 
-typedef struct vioapicEntry 
-    {
-    VIOAPIC_REDIR_LOW	vioapicLow;
-    VIOAPIC_REDIR_HIGH	vioapicHigh;
+typedef struct vioapicEntry
+{
+	VIOAPIC_REDIR_LOW	vioapicLow;
+	VIOAPIC_REDIR_HIGH	vioapicHigh;
+} VIOAPIC_ENTRY;
 
-    } VIOAPIC_ENTRY;
-    
 typedef struct vioapic
-    {
-    VIOAPIC_ID	    id;
-    VIOAPIC_VERSION version;
-    uint32_t	    arb;
-    uint32_t	    boot;
-    uint32_t	    reserved[6];
-    VIOAPIC_ENTRY   entry [VIOAPIC_MAX_REDTABLE_ENTRIES];
-    } VIOAPIC;
+{
+	VIOAPIC_ID id;
+	VIOAPIC_VERSION version;
+	uint32_t arb;
+	uint32_t boot;
+	uint32_t reserved[6];
+	VIOAPIC_ENTRY   entry [VIOAPIC_MAX_REDTABLE_ENTRIES];
+} VIOAPIC;
 
 /* external declarations */
 
diff --git a/include/vbi/private.h b/include/vbi/private.h
index 519b679..4a3a308 100644
--- a/include/vbi/private.h
+++ b/include/vbi/private.h
@@ -14,7 +14,6 @@
  *
  */
 
-
 #ifndef __INCvbiPrvh
 #define __INCvbiPrvh
 
@@ -29,48 +28,33 @@
 
 #ifndef _ASMLANGUAGE
 
-
-_WRS_INLINE vbiStatus_t _vbiStrncmp 
-    (
-    const char * s1, 
-    const char * s2, 
-    size_t n
-    )
-    {                                        
-    if (n == 0)
-	return (0);
+_WRS_INLINE vbiStatus_t _vbiStrncmp(const char * s1, const char * s2, size_t n)
+{                                        
+	if (n == 0)
+		return (0);
  
-    while (*s1++ == *s2++)
+	while (*s1++ == *s2++)
 	{
- 	if ((s1 [-1] == EOS) || (--n == 0))
- 	    return (0);
-        }
+ 		if ((s1 [-1] == EOS) || (--n == 0))
+ 		    return (0);
+	}
  
-    return ((s1 [-1]) - (s2 [-1]));
-    }
+	return ((s1 [-1]) - (s2 [-1]));
+}
 
 /* private ioapic operator */
-
-extern LINKAGE vbiStatus_t  vbiIoapicOp (uint32_t ioctl, vbiIrq_t irq, uint32_t filter, vbiVb_t vbId);
+extern LINKAGE vbiStatus_t vbiIoapicOp (uint32_t ioctl, vbiIrq_t irq, uint32_t filter, vbiVb_t vbId);
 
 /* private interrupt redirection operator */
-
-extern LINKAGE vbiStatus_t  vbiVcoreIntRed_op (vbiIrq_t irq, vbiCore_t CoreId);
+extern LINKAGE vbiStatus_t vbiVcoreIntRed_op(vbiIrq_t irq, vbiCore_t CoreId);
 
 /* Name service private operator */
-
-extern LINKAGE vbiStatus_t  vbiNsOp (uint32_t op, char* name, uint32_t rev, 
+extern LINKAGE vbiStatus_t vbiNsOp(uint32_t op, char* name, uint32_t rev, 
 			VBI_NS_HANDLE *handle);
 
 /* Message receive private operator */
-
-extern LINKAGE vbiStatus_t vbiReceiveOp
-    (
-    void		*rmsg, /* pointer to message to receive  */
-    uint32_t		rlen,  /* length of message to receive   */
-    VBI_MSG_INFO	*info, /* status info structure pointer  */
-    VBI_MSG_CTL     	*ctl   /* control data structure pointer */
-    );                                   
+extern LINKAGE vbiStatus_t vbiReceiveOp(void *rmsg, uint32_t rlen, 
+			VBI_MSG_INFO *info, VBI_MSG_CTL *ctl);                                   
 
 #endif
 
diff --git a/include/vbi/shmem.h b/include/vbi/shmem.h
index 15a7617..a6fa9e5 100644
--- a/include/vbi/shmem.h
+++ b/include/vbi/shmem.h
@@ -27,25 +27,14 @@ This header file declares the vbi API for managing memory regions
 
 #ifndef	_ASMLANGUAGE
 
-extern vbiStatus_t vbiShmemRegionFind
-    (
-    int8_t *         smName,      /* String name of the region */
-    void * *       addr,        /* Location - OUT */
-    uint32_t * length,      /* Length - OUT */
-    uint32_t * attr         /* MMU Attributes - OUT */
-    );
-
-extern vbiStatus_t vbiMemRegionFind
-    (
-    int8_t *         name,        /* String name of the region */
-    void * *       addr,        /* Location - OUT */
-    uint32_t * length,      /* Length - OUT */
-    uint32_t * attr         /* MMU Attributes - OUT */
-    );
+extern vbiStatus_t vbiShmemRegionFind(int8_t *smName, void **addr,
+		uint32_t *length, uint32_t *attr);
 
-/* find the base address and length of a core's private memory */
+extern vbiStatus_t vbiMemRegionFind( int8_t * name, void **addr,       
+		uint32_t *length, uint32_t *attr);
 
-extern vbiStatus_t vbiCorePrvMemFind (void * * addr, size_t *  length);  
+/* find the base address and length of a core's private memory */
+extern vbiStatus_t vbiCorePrvMemFind (void **addr, size_t *length);  
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index 54b6f83..6363b80 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -17,7 +17,6 @@
 #ifndef __INCvbiSyscallh
 #define __INCvbiSyscallh
 
-#define LINKAGE asmlinkage
 #include <linux/linkage.h>
 #include <vbi/types.h>
 #include <vbi/arch.h>
@@ -31,14 +30,15 @@ struct VB_ARCH_CONTROL_REGS;
 
 /* information about incoming message */
 
-typedef struct vbiMsgInfo {
-    vbiCtx_t    id;	/* context id of sender */
-    uint32_t type;	/* message type (msg/event) */
-    size_t   slen;	/* length of sent buffer */
-    size_t   rlen;	/* length of received buffer */
-    uint32_t error;	/* extended error status */
-    time_t   timestamp;	/* time message was sent */
-    uint32_t nmsg;	/* number of queued messages remaining */
+typedef struct vbiMsgInfo
+{
+	vbiCtx_t    id;	/* context id of sender */
+	uint32_t type;	/* message type (msg/event) */
+	size_t   slen;	/* length of sent buffer */
+	size_t   rlen;	/* length of received buffer */
+	uint32_t error;	/* extended error status */
+	time_t   timestamp;	/* time message was sent */
+	uint32_t nmsg;	/* number of queued messages remaining */
 } VBI_MSG_INFO;
 
 /* extended error codes reported in "error" field */
@@ -58,118 +58,106 @@ typedef struct vbiMsgInfo {
 
 /* modifiers for message processing */
 
-typedef struct vbiMsgCtl {
-    uint32_t flags;	/* operation flags */
-    uint32_t ordering;	/* order to receive messages */
-    time_t   timeout;	/* receive timeout */
+typedef struct vbiMsgCtl
+{
+	uint32_t flags;		/* operation flags */
+	uint32_t ordering;	/* order to receive messages */
+	time_t timeout;		/* receive timeout */
 } VBI_MSG_CTL;
 
 /* message control flags */
 #define VBI_MSG_CTL_FLAG_RETRY 1
 
 /* memory read/write control structure */
-
 typedef struct vbiMemCtl
-    {
-    void	*pBuffer;	    /* address of target context	    */
-    void	*pAddress;	    /* address of calling context	    */
-    size_t	sizeIn;		    /* number of bytes to be read	    */
-    size_t	sizeOut;	    /* number of bytes successfully read    */
-    uint32_t	flags;	    	    /* data/instruction flush option	    */
-  } VBI_MEM_CTL;
+{
+	void *pBuffer;	    /* address of target context	    */
+	void *pAddress;	    /* address of calling context	    */
+	size_t sizeIn;	    /* number of bytes to be read	    */
+	size_t sizeOut;	    /* number of bytes successfully read    */
+	uint32_t flags;	    /* data/instruction flush option	    */
+} VBI_MEM_CTL;
 
 #define VBI_DCACHE_FLUSH 	0x0001
 #define VBI_ICACHE_INV 		0x0002
 
 /* system call prototypes for use within a context */
 
-extern LINKAGE int  vbiHyIoctl (unsigned ioctl, void *arg1, void *arg2, void *arg3, void *arg4);
-extern LINKAGE int  vbiIoapicIoctl (unsigned ioctl, unsigned arg1, unsigned arg2);
-extern LINKAGE int  vbiCtxctl (unsigned operation, unsigned arg1, unsigned arg2);
-extern LINKAGE int32_t vbiVbMgmt (uint32_t cmd, uint32_t boardId, int32_t *outError,
-			  uint32_t flags, void * ctl);
-extern LINKAGE int  vbiVtlbOp (unsigned int op, unsigned long arg1,
-			  unsigned long arg2, unsigned long arg3);
+extern asmlinkage int vbiHyIoctl(unsigned ioctl, void *arg1, void *arg2,
+				void *arg3, void *arg4);
+extern asmlinkage int vbiIoapicIoctl(unsigned ioctl, unsigned arg1,
+				unsigned arg2);
+extern asmlinkage int vbiCtxctl(unsigned operation, unsigned arg1,
+				unsigned arg2);
+extern asmlinkage int32_t vbiVbMgmt(uint32_t cmd, uint32_t boardId,
+				int32_t *outError, uint32_t flags, void * ctl);
+extern asmlinkage int vbiVtlbOp(unsigned int op, unsigned long arg1,
+			  	unsigned long arg2, unsigned long arg3);
 
-/*******************************************************************************
+/*
  * Modified APIs for VBI 2.0 
  */
 
-/* Message send	    */
-
-extern LINKAGE vbiStatus_t vbiSend (vbiCtx_t	    id, 
-			    void	    *smsg, 
-			    size_t	    slen, 
-			    void	    *rmsg,
-			    size_t	    rlen, 
-			    VBI_MSG_INFO    *info, 
-			    VBI_MSG_CTL    *ctl);
-/* message receive  */
-
-extern vbiStatus_t vbiReceive (void		*rmsg, 
-			       uint32_t		rlen, 
-			       VBI_MSG_INFO	*info,
-			       VBI_MSG_CTL     *ctl);                                   
+/* Message send */
+extern asmlinkage vbiStatus_t vbiSend(vbiCtx_t id, void *smsg, size_t slen, 
+			    void *rmsg, size_t rlen, VBI_MSG_INFO *info, 
+			    VBI_MSG_CTL *ctl);
+/* message receive */
+extern vbiStatus_t vbiReceive(void *rmsg, uint32_t rlen, VBI_MSG_INFO *info,
+				VBI_MSG_CTL *ctl);
 /* message reply */
-
-extern LINKAGE int32_t vbiReply (vbiCtx_t	    id, 
-			 void		    *smsg, 
-			 size_t		    slen, 
-			 VBI_MSG_CTL	    *ctl);
-
-extern LINKAGE vbiStatus_t vbiPanic (const char *msg);
-extern vbiStatus_t vbiDcacheFlush (void *saddr, size_t size);
-extern vbiStatus_t vbiIcacheFlush (void *saddr, size_t size);
-extern LINKAGE vbiStatus_t vbiKputs (const char *s);
-extern LINKAGE vbiStatus_t vbiKputc (int c);
-extern vbiStatus_t vbiVmmuConfig (struct vmmuConfig * config);
-extern vbiStatus_t vbiVmmuEnable (uint32_t  vmmu_num);
-extern vbiStatus_t vbiVmmuDisable (uint32_t vmmu_num);
-extern vbiStatus_t vbiNsRegister (char  *name, uint32_t  revision);
-extern vbiStatus_t vbiNsUnRegister (char *name, uint32_t  revision);
-extern vbiStatus_t vbiNsLookup (char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle);
-extern vbiStatus_t vbiVmmuTlbFlush (struct vmmuConfig * config, void *addr, size_t len);
+extern asmlinkage int32_t vbiReply(vbiCtx_t id, void *smsg, size_t slen, 
+				VBI_MSG_CTL *ctl);
+
+extern asmlinkage vbiStatus_t vbiPanic(const char *msg);
+extern vbiStatus_t vbiDcacheFlush(void *saddr, size_t size);
+extern vbiStatus_t vbiIcacheFlush(void *saddr, size_t size);
+extern asmlinkage vbiStatus_t vbiKputs(const char *s);
+extern asmlinkage vbiStatus_t vbiKputc(int c);
+extern vbiStatus_t vbiVmmuConfig(struct vmmuConfig * config);
+extern vbiStatus_t vbiVmmuEnable(uint32_t  vmmu_num);
+extern vbiStatus_t vbiVmmuDisable(uint32_t vmmu_num);
+extern vbiStatus_t vbiNsRegister(char  *name, uint32_t  revision);
+extern vbiStatus_t vbiNsUnRegister(char *name, uint32_t  revision);
+extern vbiStatus_t vbiNsLookup(char *name, uint32_t  rev, VBI_NS_HANDLE *pHandle);
+extern vbiStatus_t vbiVmmuTlbFlush(struct vmmuConfig * config, void *addr, size_t len);
 
 
 /* Prior to vbi 2.0 these api were vbiMmuAttrSet/Get */
 
-extern LINKAGE vbiStatus_t  vbiMemAttrSet (void *vaddr, size_t len, vbiMemAttr_t attr);
-extern LINKAGE vbiStatus_t  vbiMemAttrGet (void *vaddr, vbiMemAttr_t * attr);
+extern asmlinkage vbiStatus_t  vbiMemAttrSet (void *vaddr, size_t len, vbiMemAttr_t attr);
+extern asmlinkage vbiStatus_t  vbiMemAttrGet (void *vaddr, vbiMemAttr_t * attr);
 
-/*******************************************************************************
+/*
  * START: New APIs introduced for vbi 2.0  
  */
 
-extern LINKAGE vbiStatus_t vbiIntVCoreUnlock (void);
-extern LINKAGE vbiIntState_t vbiIntVCoreLock (void);
+extern asmlinkage vbiStatus_t vbiIntVCoreUnlock (void);
+extern asmlinkage vbiIntState_t vbiIntVCoreLock (void);
 extern vbiStatus_t vbiCacheTextUpdate (void *saddr, size_t size);
 extern vbiStatus_t  vbiExcBaseSet (void * excTblBase);
 
 /* virtual board management API's */
-
-extern LINKAGE vbiStatus_t vbiVbSuspend (vbiVb_t id, vbiCore_t core);
-extern LINKAGE vbiStatus_t vbiVbReset (vbiVb_t id, vbiCore_t core, uint32_t options);
-extern LINKAGE vbiStatus_t vbiVbRestart (vbiVb_t id, vbiCore_t core);
-extern LINKAGE vbiStatus_t vbiVbResume (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbSuspend (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbReset (vbiVb_t id, vbiCore_t core, uint32_t options);
+extern asmlinkage vbiStatus_t vbiVbRestart (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbResume (vbiVb_t id, vbiCore_t core);
 
 /* read remote vb's memory */
-
-extern LINKAGE vbiStatus_t vbiVbMemoryRead (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
-extern LINKAGE vbiStatus_t vbiVbMemoryWrite (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
-extern LINKAGE void vbiDebugShellStart (uint32_t  flags);
+extern asmlinkage vbiStatus_t vbiVbMemoryRead (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern asmlinkage vbiStatus_t vbiVbMemoryWrite (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern asmlinkage void vbiDebugShellStart (uint32_t  flags);
 
 /* read remote vb's registers */
-
-extern LINKAGE vbiStatus_t vbiVbRegisterRead (VBI_HREG_SET *regCtl, 
+extern asmlinkage vbiStatus_t vbiVbRegisterRead (VBI_HREG_SET *regCtl, 
 				       vbiVb_t targetBoard, vbiCore_t core);
-extern LINKAGE vbiStatus_t vbiVbRegisterWrite (VBI_HREG_SET *regCtl, 
+extern asmlinkage vbiStatus_t vbiVbRegisterWrite (VBI_HREG_SET *regCtl, 
 					vbiVb_t targetBoard, vbiCore_t core);
 
-/*******************************************************************************
+/*
  * END: New APIs introduced for vbi 2.0  
  */
 
 
 #endif	/* _ASMLANGUAGE */
-
 #endif  /* __INCvbiSyscallh */
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index af8cd1d..de9f176 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -49,8 +49,8 @@
 #define	HY_FAST_SYSCALL_SHIFT	24
 #define	HY_FAST_SYSCALL_BIT	0x80000000
 #define	HY_FAST_SYSCALL(x)	\
-    ((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
-     HY_FAST_SYSCALL_BIT)
+	((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+	 HY_FAST_SYSCALL_BIT)
 
 /* C driven system calls */
 
@@ -58,7 +58,7 @@
 #define	HY_SYSCALL_SHIFT	0
 #define	HY_SYSCALL_BIT		0x40000000
 #define	HY_SYSCALL(x)	\
-    ((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
 
 /* fast system calls */
 
@@ -219,17 +219,15 @@
 #define VBI_ERR_INVALID_ARG         -102   /* General error */
 
 /* vbMgmt reset macros */
-#define VBI_VBMGMT_RESET_DOWNLOAD	    0x00000001     /* disable ELF reloading */
-#define VBI_VBMGMT_RESET_CLEAR		    0x00000002     /* do not clear memory */
-#define VBI_VBMGMT_RESET_AND_START_CORE0    0x00000004
+#define VBI_VBMGMT_RESET_DOWNLOAD	 0x00000001 /* disable ELF reloading */
+#define VBI_VBMGMT_RESET_CLEAR		 0x00000002 /* do not clear memory */
+#define VBI_VBMGMT_RESET_AND_START_CORE0 0x00000004
 
 /* target vb options */
-
 #define VBI_VB_CORES_ALL	(0x80000000)		    
 #define VBI_VB_CORES_OTHERS	(0x40000000)
 
 /* VTLB operation command and flags (intel-vt specific) */
-
 #define	VBI_VTLB_OP_UPDATE_PMD		1
 #define	VBI_VTLB_OP_UPDATE_PTE		2
 #define	VBI_VTLB_OP_DELETE_PMD		3
@@ -239,19 +237,16 @@
 #define	VBI_VTLB_OP_INIT		7
 
 /* VTLB macros */
-
 #define	VBI_VTLB_OP_MAX_OPS		100
 #define	VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
 
 /* VTLB optimization supported options */
-
 #define	VBI_VTLB_OPTIM_ENABLED			1
 #define	VBI_VTLB_CR3_CACHE_ENABLED		2
 #define	VBI_VTLB_OPS_CACHE_ENABLED		4
 #define	VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
 
 /* vbiNsOp system call supported operations */
-
 #define	VBI_NS_REGISTER		1	/* register service name    */
 #define	VBI_NS_UNREGISTER	2	/* unregister service name  */
 #define	VBI_NS_LOOKUP	        3	/* look up service name	    */
@@ -260,44 +255,45 @@
 
 /* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
 
-typedef struct {
-    unsigned long ctx_type;          /* type of context (user, supv, etc) */
-    unsigned long switchin;          /* number of times switched in       */
-    unsigned long pended;            /* number of times in pend state     */
-    unsigned long tsCtxSwitchOutH;   /* timestamp: context switch (high)  */
-    unsigned long tsCtxSwitchOutL;   /* timestamp: context switch (low)   */
-    unsigned long tsCtxSwitchInH;    /* timestamp: context switch (high)  */
-    unsigned long tsCtxSwitchInL;    /* timestamp: context switch (low)   */
-    unsigned long tsCtxExcInH;	   /* timestamp: exception entry (high) */
-    unsigned long tsCtxExcInL;	   /* timestamp: exception entry (low)  */
-    unsigned long reset;            /* number of times context reset */
+typedef struct
+{
+	unsigned long ctx_type;		/* type of context (user, supv, etc) */
+	unsigned long switchin;		/* number of times switched in       */
+	unsigned long pended;		/* number of times in pend state     */
+	unsigned long tsCtxSwitchOutH;  /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchOutL;  /* timestamp: context switch (low)   */
+	unsigned long tsCtxSwitchInH;   /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchInL;   /* timestamp: context switch (low)   */
+	unsigned long tsCtxExcInH;	/* timestamp: exception entry (high) */
+	unsigned long tsCtxExcInL;	/* timestamp: exception entry (low)  */
+	unsigned long reset;		/* number of times context reset     */
 } VBI_CTX_STATS;
 
 /* VTLB operation structures (x86 specific) */
-
-typedef struct vbi_vtlb_op		/* VTLB operation */
-    {
-    uint32_t		op;		/* VTLB operation id */
-    uint32_t		arg1;		/* VTLB operation arg 1 */
-    uint32_t		arg2;		/* VTLB operation arg 2 */
-    uint32_t		arg3;		/* VTLB operation arg 3 */
-    } VBI_VTLB_OP;
+typedef struct vbi_vtlb_op
+{
+	uint32_t op;		/* VTLB operation id */
+	uint32_t arg1;		/* VTLB operation arg 1 */
+	uint32_t arg2;		/* VTLB operation arg 2 */
+	uint32_t arg3;		/* VTLB operation arg 3 */
+} VBI_VTLB_OP;
 
 typedef struct vbi_vtlb_cr3_cache
-    {
-    uint32_t		guest_cr3;	/* Guest CR3 register */
-    uint32_t		host_cr3;	/* Host CR3 register */
-    } VBI_VTLB_CR3_CACHE;
-    
+{
+	uint32_t guest_cr3;	/* Guest CR3 register */
+	uint32_t host_cr3;	/* Host CR3 register */
+} VBI_VTLB_CR3_CACHE;
+	
 typedef struct vbi_vtlb_control
-    {
-    uint32_t		size;		/* VTLB Control structure size */
-    uint32_t		mode;		/* VTLB module */
-    uint32_t		vtlb_ops_ix;	/* VTLB operation index */
-    VBI_VTLB_OP		vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
-    uint32_t		cr3_cache_ix;	/* CR3 cache index */
-    VBI_VTLB_CR3_CACHE	cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES]; /* cr3 cache*/
-    } VBI_VTLB_CONTROL;			/* VBI VTLB control */
+{
+	uint32_t size;		/* VTLB Control structure size */
+	uint32_t mode;		/* VTLB module */
+	uint32_t vtlb_ops_ix;	/* VTLB operation index */
+	VBI_VTLB_OP vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
+	uint32_t cr3_cache_ix;	/* CR3 cache index */
+				/* cr3 cache*/
+	VBI_VTLB_CR3_CACHE cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES];
+} VBI_VTLB_CONTROL;
 
 /*
  * Control structure used by vbiVbMgmt for commands memory read, memory write, 
@@ -305,25 +301,25 @@ typedef struct vbi_vtlb_control
  */
 
 typedef struct vbMgmtCtl 
-    {
-    union 
+{
+	union 
 	{
-	struct 
-	    {
-	    uint32_t *pBuffer;  /* address of target context */
-	    uint32_t *pAddress; /* address of calling context */
-	    uint32_t size;	/* number of total bytes */
-	    uint32_t width;	/* bus width in bytes */
-	    } vbMgmtMem;
-	struct 
-	    {
-	    uint32_t *pBuffer;  /* address of target context */
-	    uint32_t regSet;	/* register set */
-	    uint32_t reg;	/* macro to specify register */
-	    uint32_t size;	/* number of total bytes */
-	    } vbMgmtReg;
+		struct 
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t *pAddress; /* address of calling context */
+			uint32_t size;	/* number of total bytes */
+			uint32_t width;	/* bus width in bytes */
+		} vbMgmtMem;
+		struct 
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t regSet;	/* register set */
+			uint32_t reg;	/* macro to specify register */
+			uint32_t size;	/* number of total bytes */
+		} vbMgmtReg;
 	} data;
-    } VBMGMT_CTL;
+} VBMGMT_CTL;
 
 typedef uint32_t VBMGMT_HANDLE;
 typedef uint32_t VBI_NS_HANDLE;
diff --git a/include/vbi/types.h b/include/vbi/types.h
index cb96980..5e62c5f 100644
--- a/include/vbi/types.h
+++ b/include/vbi/types.h
@@ -34,16 +34,16 @@
 
 #ifndef _ASMLANGUAGE
 
-typedef uint32_t		vbiVb_t;
-typedef int32_t			vbiCore_t;
-typedef int32_t			vbiCtx_t;
-typedef uint64_t    		vbiPhysAddr_t;
-typedef void *       		vbiGuestPhysAddr_t;
-typedef int32_t			vbiStatus_t;		
-typedef int32_t			vbiIntState_t;		
-typedef int32_t			vbiMemAttr_t;		
-typedef int32_t			vbiVector_t;		
-typedef uint32_t		vbiIrq_t;		
+typedef uint32_t vbiVb_t;
+typedef int32_t vbiCore_t;
+typedef int32_t vbiCtx_t;
+typedef uint64_t vbiPhysAddr_t;
+typedef void *vbiGuestPhysAddr_t;
+typedef int32_t vbiStatus_t;		
+typedef int32_t vbiIntState_t;		
+typedef int32_t vbiMemAttr_t;		
+typedef int32_t vbiVector_t;		
+typedef uint32_t vbiIrq_t;		
 
 #endif	/* _ASMLANGUAGE */
 
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index 9e7f1d1..91931a7 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -36,30 +36,14 @@ various data structures.
 
 /* Access macros for VB control structure */
 
-/*******************************************************************************
-*
-* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
-*
-* This macro returns the base address of the running virtual core's control
-* structure.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ *
+ * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+ *
+ * This macro returns the base address of the running virtual core's control
+ * structure.
+ *
+ */
 #define VBI_CNTRL_ADDR_GET()        (wrhvVbControl)
 
 #define VBI_INT_STATE_GET()             \
@@ -72,835 +56,472 @@ various data structures.
 #define VBI_INT_PENDING_SET(value)        \
         (VBI_CNTRL_ADDR_GET()->intPending = value)
 
-/*******************************************************************************
-*
-* VBI_VIOAPIC_BASE_GET - Get the virtual I/O APIC base address
-*
-* This macro returns the virtual I/O APIC base address in the configuration
-* structure. This is a table that controls the state of individual IRQ 
-* connected to a virtual board. If the underlying hardware supports an IRQ can
-* be redirected to a specific vector number. The redirection capability is not
-* used for PPC platforms since all interrupts are funneled via vector 0x500. 
-* The VIOAPIC is comprised of a description header and a redirection table. Each
-* entry in the redirection table is 64 bits wide. The size of the redirection
-* table is architecture specific. See the VBI user's guide for more detailed 
-* information.
-*
-* API's for controlling the VIOAPIC:
-*
-* 
-* vbiVioapicIntSend()
-* 
-* vbiVioapicVectorSet()
-* 
-* vbiVioapicVectorGet()
-* 
-* vbiVioapicIntAck()
-* 
-* vbiVioapicIntMask()
-* 
-* vbiVioapicIntUnmask()
-*\me
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* void * VBI_VIOAPIC_BASE_GET (void)
-*
-*
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-*vbiIoapicIntUnmask(), vbiVioapicVectorGet(), vbiIoapicIntMask(), 
-*           vbiIoapicIntSend(), vbiIoapicIntRedirect(), vbiIoapicIntAck(),
-*	    VBI User's Guide
-*/
-
+/*
+ *
+ * VBI_VIOAPIC_BASE_GET - Get the virtual I/O APIC base address
+ *
+ * This macro returns the virtual I/O APIC base address in the configuration
+ * structure. This is a table that controls the state of individual IRQ
+ * connected to a virtual board. If the underlying hardware supports an IRQ can
+ * be redirected to a specific vector number. The redirection capability is not
+ * used for PPC platforms since all interrupts are funneled via vector 0x500.
+ * The VIOAPIC is comprised of a description header and a redirection table.
+ * Each entry in the redirection table is 64 bits wide. The size of the
+ * redirection table is architecture specific. See the VBI user's guide for
+ * more detailed information.
+ *
+ * API's for controlling the VIOAPIC:
+ *
+ * 
+ * vbiVioapicIntSend()
+ * 
+ * vbiVioapicVectorSet()
+ * 
+ * vbiVioapicVectorGet()
+ * 
+ * vbiVioapicIntAck()
+ * 
+ * vbiVioapicIntMask()
+ * 
+ * vbiVioapicIntUnmask()
+ *
+ */
 #define VBI_VIOAPIC_BASE_GET()		\
         (VBI_CNTRL_ADDR_GET()->vIoapic)
 
 /* VMMU0 and VMMU1 tables for context switch access macro's */
-
 #define VBI_VMMU0_GET()                   \
         (VBI_CNTRL_ADDR_GET()->vmmu0)
 
 #define VBI_VMMU0_SET(value)              \
         (VBI_CNTRL_VMMU0_GET() = value)
 
-/*******************************************************************************
-*
-* VBI_STATUS_ADDR_GET - Get virtual core status structure address
-*
-* This macro returns the base address of the status structure of currently
-* running core. This structure is read-only and contains a description of
-* the running virtual core. Hypervisor uses this data to inform the
-* virtual board time variant data that may be updated during hypervisor context
-* Switch. Typical that are available in the status structure are:
-*
-*
-* 
-*Timer tick counter
-*
-*Pending interrupt state
-*
-*The interrupt state before this core was schedule
-*
-*VMMU configuration
-*
-*Virtual core registers state
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_STATUS * VBI_STATUS_ADDR_GET(void)
-*
-*
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_STATUS_ADDR_GET - Get virtual core status structure address
+ *
+ * This macro returns the base address of the status structure of currently
+ * running core. This structure is read-only and contains a description of
+ * the running virtual core. Hypervisor uses this data to inform the
+ * virtual board time variant data that may be updated during hypervisor context
+ * Switch. Typical that are available in the status structure are:
+ *
+ *
+ * 
+ *Timer tick counter
+ *
+ *Pending interrupt state
+ *
+ *The interrupt state before this core was schedule
+ *
+ *VMMU configuration
+ *
+ *Virtual core registers state
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
 #define VBI_STATUS_ADDR_GET()       (wrhvVbStatus)
 
-/*******************************************************************************
-*
-* VBI_INT_VCORE_PENDING - Get the pending interrupt 
-*
-* This returns the pending interrupts vector number for the running core. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiVector_t VBI_INT_VCORE_PENDING (void)
-*
-*
-*
-* RETURNS: VB Interrupt Vector or 0xffff (PowerPC) Not applicable for X86
-*
-* ERROR CODES: N/A
-*
-*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
-*              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
-*/
-
+/*
+ *
+ * VBI_INT_VCORE_PENDING - Get the pending interrupt 
+ *
+ * This returns the pending interrupts vector number for the running core. 
+ *
+ * RETURNS: VB Interrupt Vector or 0xffff (PowerPC) Not applicable for X86
+ *
+ */
 #define VBI_INT_VCORE_PENDING()				    \
         (VBI_CNTRL_ADDR_GET()->intPending)
 
-/*******************************************************************************
-*
-* VBI_INT_VCORE_PENDING_TYPE_GET - Get the pending interrupts
-*
-* This returns the type of pending interrupts for the running core. This API
-* are not use by hardware with virtualization support.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiVector_t VBI_INT_VCORE_PENDING_TYPE_GET(void)
-*
-*
-*
-* RETURNS: 2 for timer interrupt, 1 for other external interrupts or
-*	    0 if none is pending
-*
-* ERROR CODES: N/A
-*
-*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
-*              VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_PREVSTATE_GET()
-*/
-
-
+/*
+ * VBI_INT_VCORE_PENDING_TYPE_GET - Get the pending interrupts
+ *
+ * This returns the type of pending interrupts for the running core. This API
+ * are not use by hardware with virtualization support.
+ *
+ * RETURNS: 2 for timer interrupt, 1 for other external interrupts or
+ *	    0 if none is pending
+ */
 #define VBI_INT_VCORE_PENDING_TYPE_GET()            \
         (VBI_STATUS_ADDR_GET()->intPendingType)
 
-/*******************************************************************************
-*
-* VBI_INT_VCORE_PREVSTATE_GET - Get the core's previous interrupt status 
-*
-* This returns the previous interrupt state of the currently running core. This
-* flag reflects the state of interrupts before Hypervisor injected an
-* interrupt. The guest OS must restore this flag in the control structure
-* before returning from the interrupt service routine.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* bool VBI_INT_VCORE_PREVSTATE_GET (void)
-*
-*
-*
-* RETURNS: TRUE if locked otherwise FALSE
-*
-* ERROR CODES: 
-*
-*VBI_INT_VCORE_STATE_GET(), VBI_INT_VCORE_LOCK(),
-*              VBI_INT_VCORE_UNLOCK()
-*/
-
+/*
+ * VBI_INT_VCORE_PREVSTATE_GET - Get the core's previous interrupt status 
+ *
+ * This returns the previous interrupt state of the currently running core. This
+ * flag reflects the state of interrupts before Hypervisor injected an
+ * interrupt. The guest OS must restore this flag in the control structure
+ * before returning from the interrupt service routine.
+ *
+ * RETURNS: TRUE if locked otherwise FALSE
+ *
+ */
 #define VBI_INT_VCORE_PREVSTATE_GET()				\
         ((VBI_STATUS_ADDR_GET()->oldIntDisable) == -1? TRUE: FALSE)
 
 /* timeStamp field  */
-
 #define VBI_TIMESTAMP_GET()					\
         (VBI_STATUS_ADDR_GET()->timeStamp)
 
 /* vmm[0,1] access macro */
 
-
-/*******************************************************************************
-*
-* VBI_VMMU_CONFIG_GET - Get a core's VMMU configuration addr
-*
-* This macro gets the core's VMMU configuration structure address. The VMMU
-* structure is a descriptor of the VMMU context with the following info:
-*
-*
-*
-* The VMMU page table base address 
-* 
-* The VMMU pages
-*
-* The page size granularity 
-*\me 
-*
-* VMMU_CONFIG definition:
-*
-* typedef struct vmmuConfig
-*    {
-*    VMMU_LEVEL_1_DESC *addr;
-*    size_t         pageSize;
-*    uint32_t       reserved;
-*    uint32_t       vmmu_num;
-*    } VMMU_CONFIG;
-*
-* The vmmu virtual address space is restricted to 32 bits and is decoded using
-* a level-1/level-2 page table.  The virtual address is decoded as follows:
-*
-*
-*
-*
-*
-*
-*
-*
-*
-*                          32-bit Virtual Address
-*        +---------------------------------------------------------+
-*        |      L1 offset       | L2 offset |    Page offset       |
-*        +---------------------------------------------------------+
-*                11 bits           9 bits           12 bits
-*                  |                 |
-*                  |                 |
-*    +-------------+                 |
-*    |                               |
-*    |                               |
-*    |           L1 Table            |            L2 Table
-*    |    2047 +----------+          |      511 +----------+
-*    |         |          |          |          |          |
-*    |         |          |          |          |          |
-*    |         |          |          |          |----------|
-*    |         |          |          |   +----->|    PTE   | 8 byte PTE
-*    |         |          |          |   |      |----------|
-*    |         |          |          |   |      |          |
-*    |         |----------| 20 bits  |   |      |          |
-*    +-------->|  L2 ptr  |----------+---+      |          |
-*              |----------|                     |          |
-*              |          |                     |          |
-*              |          |                     |          |
-*            0 +----------+                   0 +----------+
-*               2 page (8KB)                    1 page (4KB)
-*             2048 L2 pointers                 512 PTE entries
-*
-* Each page table entry is 8 bytes (2 words) and uses the following format:
-*
-* word 0 (32-bits):
-*          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
-*                                          6 7 8 9 0 1 2 3
-*         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-*         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
-*         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
-*         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
-*
-*                V          - valid bit
-*                Hypervisor - reserved for use by hypervisor
-*                U0-U7      - user defined attributes
-*                ERPN       - extended real page number bits
-*                ATTR       - page attributes
-*
-* word 1 (32-bits):
-*
-*          0                                19 20      23 2 2 2 2 2 2 3 3
-*                                                         4 5 6 7 8 9 0 1
-*         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-*         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
-*         |                                   |          | | |X|X|W|W|R|R|
-*         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
-*
-*                RPN        - real page number
-*                R          - page referenced bit
-*                C          - page changed bit
-*                SX,SW,SR   - supervisor mode protection bits
-*                UX,UW,UR   - user mode protection bits
-*
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VMMU_CONFIG * VBI_VMMU_CONFIG_GET (void)
-*
-*
-*
-* RETURNS: A pointer to the cores VMMU_CONFIG structure
-*
-* ERROR CODES: N/A
-*
-*vbiVmmuConfig(), vbiVmmuEnable(), vbiVmmuDisable(),
-*           vbiVmmuTlbFlush(), vbiVmmuTlbLoad()
-*/
-
-
+/*
+ * VBI_VMMU_CONFIG_GET - Get a core's VMMU configuration addr
+ *
+ * This macro gets the core's VMMU configuration structure address. The VMMU
+ * structure is a descriptor of the VMMU context with the following info:
+ *
+ *
+ *
+ * The VMMU page table base address 
+ * 
+ * The VMMU pages
+ *
+ * The page size granularity 
+ *\me 
+ *
+ * VMMU_CONFIG definition:
+ *
+ * typedef struct vmmuConfig
+ *    {
+ *    VMMU_LEVEL_1_DESC *addr;
+ *    size_t         pageSize;
+ *    uint32_t       reserved;
+ *    uint32_t       vmmu_num;
+ *    } VMMU_CONFIG;
+ *
+ * The vmmu virtual address space is restricted to 32 bits and is decoded using
+ * a level-1/level-2 page table.  The virtual address is decoded as follows:
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *                          32-bit Virtual Address
+ *        +---------------------------------------------------------+
+ *        |      L1 offset       | L2 offset |    Page offset       |
+ *        +---------------------------------------------------------+
+ *                11 bits           9 bits           12 bits
+ *                  |                 |
+ *                  |                 |
+ *    +-------------+                 |
+ *    |                               |
+ *    |                               |
+ *    |           L1 Table            |            L2 Table
+ *    |    2047 +----------+          |      511 +----------+
+ *    |         |          |          |          |          |
+ *    |         |          |          |          |          |
+ *    |         |          |          |          |----------|
+ *    |         |          |          |   +----->|    PTE   | 8 byte PTE
+ *    |         |          |          |   |      |----------|
+ *    |         |          |          |   |      |          |
+ *    |         |----------| 20 bits  |   |      |          |
+ *    +-------->|  L2 ptr  |----------+---+      |          |
+ *              |----------|                     |          |
+ *              |          |                     |          |
+ *              |          |                     |          |
+ *            0 +----------+                   0 +----------+
+ *               2 page (8KB)                    1 page (4KB)
+ *             2048 L2 pointers                 512 PTE entries
+ *
+ * Each page table entry is 8 bytes (2 words) and uses the following format:
+ *
+ * word 0 (32-bits):
+ *          0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+ *                                          6 7 8 9 0 1 2 3
+ *         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+ *         |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+ *         | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+ *         +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+ *
+ *                V          - valid bit
+ *                Hypervisor - reserved for use by hypervisor
+ *                U0-U7      - user defined attributes
+ *                ERPN       - extended real page number bits
+ *                ATTR       - page attributes
+ *
+ * word 1 (32-bits):
+ *
+ *          0                                19 20      23 2 2 2 2 2 2 3 3
+ *                                                         4 5 6 7 8 9 0 1
+ *         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+ *         |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+ *         |                                   |          | | |X|X|W|W|R|R|
+ *         +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+ *
+ *                RPN        - real page number
+ *                R          - page referenced bit
+ *                C          - page changed bit
+ *                SX,SW,SR   - supervisor mode protection bits
+ *                UX,UW,UR   - user mode protection bits
+ *
+ *
+ * RETURNS: A pointer to the cores VMMU_CONFIG structure
+ *
+ */
 #define VBI_VMMU0_CONFIG_GET()          \
         (VBI_STATUS_ADDR_GET()->vmmu0)
 
 #define VBI_VMMU1_CONFIG_GET()          \
         (VBI_STATUS_ADDR_GET()->vmmu1)
 
-/*******************************************************************************
-*
-* VBI_TICKS_COUNT_GET - Get the elapsed ticks count
-*
-* This returns the number timer ticks elapsed since the board has started. 
-* The frequency of the counter is based on the virtual board configuration XML
-* file "TimerTicksFrequency" flag.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiTicks_t VBI_TICKS_COUNT_GET (void)
-*
-*
-*
-* RETURNS: count number of elapsed ticks for a VB
-*
-* ERROR CODES: 
-*
-*
-*/
-
+/*
+ * VBI_TICKS_COUNT_GET - Get the elapsed ticks count
+ *
+ * This returns the number timer ticks elapsed since the board has started. 
+ * The frequency of the counter is based on the virtual board configuration XML
+ * file "TimerTicksFrequency" flag.
+ *
+ * RETURNS: count number of elapsed ticks for a VB
+ *
+ */
 #define VBI_TICK_COUNT_GET()             \
         (VBI_STATUS_ADDR_GET()->tickCount)
 
-/*******************************************************************************
-*
-* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
-*
-* This macro returns the base address of the configuration structure of the 
-* running core. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
-*
-*
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+ *
+ * This macro returns the base address of the configuration structure of the 
+ * running core. 
+ *
+ * RETURNS: virtual core configuration structure base address
+ *
+ */
 #define VBI_CONFIG_ADDR_GET()       (wrhvVbConfig)
 
-/*******************************************************************************
-*
-* VBI_CONTEXT_ID_GET - Get virtual core context Id
-*
-* This macro returns the virtual core context id. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiCtx_t VBI_CONTEXT_ID_GET (void)
-*
-*
-*
-* RETURNS: virtual core context id
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_CONTEXT_ID_GET - Get virtual core context Id
+ *
+ * This macro returns the virtual core context id. 
+ *
+ * RETURNS: virtual core context id
+ *
+ */
 #define VBI_CONTEXT_ID_GET()             \
         (VBI_CONFIG_ADDR_GET()->pid)
 
-/*******************************************************************************
-*
-* VBI_BOARD_ID_GET - Get virtual Id
-*
-* This macro returns the virtual board id that the running core is attached.
-* This is positive integer in the range [1, N]. Where N is the total number of
-* boards in the system.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiVb_t VBI_BOARD_ID_GET (void)
-*
-*
-*
-* RETURNS: virtual board id;
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_BOARD_ID_GET - Get virtual Id
+ *
+ * This macro returns the virtual board id that the running core is attached.
+ * This is positive integer in the range [1, N]. Where N is the total number of
+ * boards in the system.
+ *
+ * RETURNS: virtual board id;
+ *
+ */
 #define VBI_BOARD_ID_GET()               \
         (VBI_CONFIG_ADDR_GET()->boardID)
 
-/*******************************************************************************
-*
-* VBI_VCORES_COUNT_GET - Get the number of cores in a VB.
-*
-* This macro returns the number of virtual cores in the VB that the calling
-* core is attached. This is a positive integer in the range of [1:N]. Where N
-* the total number of cores in the virtual board.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* uint32_t VBI_VCORES_COUNT_GET (void)
-*
-*
-*
-* RETURNS: number of cores in a virtual board
-*
-* ERROR CODES: N/A
-*
-*VBI_VCORE_ID_GET()
-*/
-
+/*
+ * VBI_VCORES_COUNT_GET - Get the number of cores in a VB.
+ *
+ * This macro returns the number of virtual cores in the VB that the calling
+ * core is attached. This is a positive integer in the range of [1:N]. Where N
+ * the total number of cores in the virtual board.
+ *
+ * RETURNS: number of cores in a virtual board
+ *
+ */
 #define VBI_VCORES_COUNT_GET()               \
         (VBI_CONFIG_ADDR_GET()->numCores)
 
-/*******************************************************************************
-*
-* VBI_VCORE_ID_GET - Get a core's id
-*
-* This macro returns the running core id. This is a positive integer in the
-* range of [0:N-1]; Where N is the total number of cores in the system.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiCore_t VBI_CORE_ID_GET (void)
-*
-*
-*
-* RETURNS: the running core id
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ *
+ * VBI_VCORE_ID_GET - Get a core's id
+ *
+ * This macro returns the running core id. This is a positive integer in the
+ * range of [0:N-1]; Where N is the total number of cores in the system.
+ *
+ * RETURNS: the running core id
+ *
+ */
 #define VBI_VCORE_ID_GET()			\
         (VBI_CONFIG_ADDR_GET()->coreId)
 
-/*******************************************************************************
-*
-* VBI_VCORE_PRIVMEM_SIZE_GET - Get core's private memory size
-*
-* This macro returns the size in bytes of the running core's private memory
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* size_t VBI_VCORE_PRIVMEM_SIZE_GET (void)
-*
-*
-*
-* RETURNS: size in bytes of the core's private memory
-*
-* ERROR CODES: N/A
-*
-*vbiCorePrvMemFind 
-*/
-
+/*
+ * VBI_VCORE_PRIVMEM_SIZE_GET - Get core's private memory size
+ *
+ * This macro returns the size in bytes of the running core's private memory
+ *
+ * RETURNS: size in bytes of the core's private memory
+ *
+ */
 #define VBI_VCORE_PRIVMEM_SIZE_GET()               \
         (VBI_CONFIG_ADDR_GET()->corePrivateSize)
 
-/*******************************************************************************
-*
-* VBI_VCORE_PRIVMEM_BASE_GET - Get core's private memory base address
-*
-* This macro returns the base of the private memory associated to the running
-* core's private memory
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* void * VBI_VCORE_PRIVMEM_BASE_GET (void)
-*
-*
-*
-* RETURNS: a pointer to the core's private memory
-*
-* ERROR CODES: N/A
-*
-*vbiCorePrvMemFind 
-*/
-
+/*
+ * VBI_VCORE_PRIVMEM_BASE_GET - Get core's private memory base address
+ *
+ * This macro returns the base of the private memory associated to the running
+ * core's private memory
+ *
+ * RETURNS: a pointer to the core's private memory
+ *
+ */
 #define VBI_VCORE_PRIVMEM_BASE_GET()               \
         (VBI_CONFIG_ADDR_GET()->corePrivate)
 
-/*******************************************************************************
-*
-* VBI_PRV_MODE_GET - Get virtual core privilege mode
-*
-* This macro returns the virtual core privilege mode. A privileged core has
-* has full privilege access to hardware. If a core is configured to run in
-* privilege mode then care must be taken to prevent negative impact to the
-* rest of the system. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* uint32_t VBI_PRV_MODE_GET (void)
-*
-*
-*
-* RETURNS: 1 if core has supervisor privilege otherwise 0
-*
-* ERROR CODES: N/A
-* 
-*
-*
-*/
-
+/*
+ * VBI_PRV_MODE_GET - Get virtual core privilege mode
+ *
+ * This macro returns the virtual core privilege mode. A privileged core has
+ * has full privilege access to hardware. If a core is configured to run in
+ * privilege mode then care must be taken to prevent negative impact to the
+ * rest of the system. 
+ *
+ * RETURNS: 1 if core has supervisor privilege otherwise 0
+ *
+ */
 #define VBI_PRIV_MODE_GET()			    \
         (VBI_CONFIG_ADDR_GET()->supervisorMode)
 
-/*******************************************************************************
-*
-* VBI_BOARD_NAME - Get a VB name
-*
-* This macro returns the name of the virtual board that the running core is
-* attached. This is a NULL terminated string of a maximum length of 64 bytes. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* char * VBI_BOARD_NAME (void)
-*
-*
-*
-* RETURNS: a string representing the board name
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_BOARD_NAME - Get a VB name
+ *
+ * This macro returns the name of the virtual board that the running core is
+ * attached. This is a NULL terminated string of a maximum length of 64 bytes. 
+ *
+ * RETURNS: a string representing the board name
+ *
+ */
 #define VBI_BOARD_NAME_GET()			    \
         (VBI_CONFIG_ADDR_GET()->boardName)
 
 #define VBI_BOARD_TYPE_GET()			    \
         (VBI_CONFIG_ADDR_GET()->boardType)
 
-/*******************************************************************************
-*
-* VBI_BOOT_COUNT_GET - Get the number of times this board has booted
-*
-* This macro returns the number of times a board has booted. This may used to
-* determine if the .bss data region needs to clear after a reset. This is a
-* zero value since the board has booted at least one time to call this API.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* uint32_t VBI_BOOT_COUNT (void)
-*
-*
-*
-* RETURNS: a positive number greater than 0
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_BOOT_COUNT_GET - Get the number of times this board has booted
+ *
+ * This macro returns the number of times a board has booted. This may used to
+ * determine if the .bss data region needs to clear after a reset. This is a
+ * zero value since the board has booted at least one time to call this API.
+ *
+ * RETURNS: a positive number greater than 0
+ *
+ */
 #define VBI_BOOT_COUNT_GET()			    \
         (VBI_CONFIG_ADDR_GET()->bootCount)
 
-/*******************************************************************************
-*
-* VBI_MEM_SIZE_GET - Get the virtual board ram size 
-*
-* This macro returns the size of ram memory in bytes that a virtual board
-* has been assigned. If a virtual board has more than one core then it's memory
-* is shared among all cores. Hypervisor maps the size of memory provided in the
-* board's XML configuration file "RamSize" flag. 
-* This is a virtual memory region from Hypervisor perspective but serves as the
-* phyisical memory for the virtual board. 
-*
-* The size returned by this macro does not include the following:
-*
-*
-*
-* Private memory of each core attached to this virtual board
-*
-* The regions that contain the configuration, status and control structures
-*
-* The shared memory with other boards
-*\me
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* size_t VBI_MEM_SIZE_GET (void)
-*
-*
-*
-* RETURNS: The size of memory in bytes for virtual board 
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ *
+ * VBI_MEM_SIZE_GET - Get the virtual board ram size 
+ *
+ * This macro returns the size of ram memory in bytes that a virtual board
+ * has been assigned. If a virtual board has more than one core then it's memory
+ * is shared among all cores. Hypervisor maps the size of memory provided in the
+ * board's XML configuration file "RamSize" flag. 
+ * This is a virtual memory region from Hypervisor perspective but serves as the
+ * phyisical memory for the virtual board. 
+ *
+ * The size returned by this macro does not include the following:
+ *
+ *
+ *
+ * Private memory of each core attached to this virtual board
+ *
+ * The regions that contain the configuration, status and control structures
+ *
+ * The shared memory with other boards
+ *
+ * RETURNS: The size of memory in bytes for virtual board 
+ *
+ */
 #define VBI_MEM_SIZE_GET()			    \
         (VBI_CONFIG_ADDR_GET()->physicalMemorySize)
 
-/*******************************************************************************
-*
-* VBI_MEM_ALIAS_SIZE_GET - Get the size of aliased ram
-*
-* This macro returns a virtual board's aliased memory size. 
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* size_t VBI_MEM_ALIAS_SIZE_GET (void)
-*
-*
-*
-* RETURNS: The aliased memory size.
-*
-* ERROR CODES: N/A
-*
-*
-*
-*/
-
+/*
+ * VBI_MEM_ALIAS_SIZE_GET - Get the size of aliased ram
+ *
+ * This macro returns a virtual board's aliased memory size. 
+ *
+ * RETURNS: The aliased memory size.
+ *
+ */
 #define VBI_MEM_ALIAS_SIZE_GET()		    \
         (VBI_CONFIG_ADDR_GET()->memoryAliasSize)
 
-/*******************************************************************************
-*
-* VBI_MEM_ALIAS_ADDR_GET - Get the virtual board ram alias address 
-*
-* This macro returns a virtual board's ram alias base address. This is a
-* physical address from the board's perspective but a virtual address mapped
-* to the board's ram address from Hypervisor's perspective. 
-* Hypervisor maps this address based on "RamAliasAddr" value in the board's XML 
-* configuration file. The virtual board's ram and this address point to the
-* same physical address. This is convenient mechanism for a virtual board that
-* needs to remap it's physical address to a different address.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* void * VBI_MEM_ALIAS_ADDR_GET (void)
-*
-*
-*
-* RETURNS: The base address of ram alias address 
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_MEM_ALIAS_ADDR_GET - Get the virtual board ram alias address 
+ *
+ * This macro returns a virtual board's ram alias base address. This is a
+ * physical address from the board's perspective but a virtual address mapped
+ * to the board's ram address from Hypervisor's perspective. 
+ * Hypervisor maps this address based on "RamAliasAddr" value in the board's
+ * XML configuration file. The virtual board's ram and this address point to the
+ * same physical address. This is convenient mechanism for a virtual board that
+ * needs to remap it's physical address to a different address.
+ *
+ * RETURNS: The base address of ram alias address 
+ *
+ */
 #define VBI_MEM_ALIAS_ADDR_GET()			    \
         (VBI_CONFIG_ADDR_GET()->memoryAliasAddress)
 
 
-/*******************************************************************************
-*
-* VBI_MEM_ENTRY_RTN - Get a core entry point function
-*
-* This macro returns the address of the entry point function of a particular
-* core. This address is derived from the guest OS binary image a compile time
-* while creating the hypervisor system.elf image. Hypervisor calls this
-* function and passes it to the configuration address and the boot flag when
-* launching a virtual core.
-* 
-* SYNOPSIS
-*
-*
-*
-*
-*
-* void * VBI_MEM_ENTRY_RTN(void)
-*
-*
-*
-* RETURNS: The entry point function of a virtual core 
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_MEM_ENTRY_RTN - Get a core entry point function
+ *
+ * This macro returns the address of the entry point function of a particular
+ * core. This address is derived from the guest OS binary image a compile time
+ * while creating the hypervisor system.elf image. Hypervisor calls this
+ * function and passes it to the configuration address and the boot flag when
+ * launching a virtual core.
+ * 
+ * RETURNS: The entry point function of a virtual core 
+ *
+ */
 #define VBI_ENTRY_RTN_GET()			    \
         (VBI_CONFIG_ADDR_GET()->resetPC)
 
-/*******************************************************************************
-*
-* VBI_TICK_TIMER_FREQ_GET - Get a core timer tick frequency
-*
-* This macro returns a core's timer clock frequency. It is the number of timer
-* ticks per second. It is based on the "TickTimerFrequency" flag specified in
-* the board's XML configuration file.
-* The timer tick interrupt is delivered to only the running core of a VB. If a
-* core is not running the counter in the status page is incremented. 
-* If "TickTimerFrequency" is set to a value of 0 for a board it  disables the
-* timer tick.
-*
-* SYNOPSIS
-*
-*
-*
-*
-*
-* vbiTicks_t VBI_TICK_TIMER_FREQ_GET (void)
-*
-*
-*
-* RETURNS: The number of ticks per second
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_TICK_TIMER_FREQ_GET - Get a core timer tick frequency
+ *
+ * This macro returns a core's timer clock frequency. It is the number of timer
+ * ticks per second. It is based on the "TickTimerFrequency" flag specified in
+ * the board's XML configuration file.
+ * The timer tick interrupt is delivered to only the running core of a VB. If a
+ * core is not running the counter in the status page is incremented. 
+ * If "TickTimerFrequency" is set to a value of 0 for a board it  disables the
+ * timer tick.
+ *
+ * RETURNS: The number of ticks per second
+ *
+ */
 #define VBI_TICK_TIMER_FREQ_GET()		        \
         (VBI_CONFIG_ADDR_GET()->tickTimerFrequency)
 
 #define VBI_TIMESTAMP_FREQ_GET()			\
         (VBI_CONFIG_ADDR_GET()->timeStampFrequency)
 
-/*******************************************************************************
-*
-* VBI_BOOTLINE_ADDR_GET - Get a virtual board bootline parameters address
-*
-* The bootline parameters is a string that contains configuration data that a
-* user may specify in the virtual XML configuration "BootLine" flag. A guest
-* OS running on Hypervisor must use this bootline instead of it's native
-* bootline parameters. For example VxWorks bootline parameters are not passed
-* to the VB running VxWorks. The size of the bootline parameters string is
-* determined by VB_MAX_BOOTLINE_LENGTH at compile time flag. The bootline is
-* NULL terminated string.
-* 
-* SYNOPSIS
-*
-*
-*
-*
-*
-* const char * VBI_BOOTLINE_ADDR_GET (void)
-*
-*
-*
-* RETURNS: The address of the bootline parameters.
-*
-* ERROR CODES: N/A
-*
-*
-*/
-
+/*
+ * VBI_BOOTLINE_ADDR_GET - Get a virtual board bootline parameters address
+ *
+ * The bootline parameters is a string that contains configuration data that a
+ * user may specify in the virtual XML configuration "BootLine" flag. A guest
+ * OS running on Hypervisor must use this bootline instead of it's native
+ * bootline parameters. For example VxWorks bootline parameters are not passed
+ * to the VB running VxWorks. The size of the bootline parameters string is
+ * determined by VB_MAX_BOOTLINE_LENGTH at compile time flag. The bootline is
+ * NULL terminated string.
+ * 
+ */
 #define VBI_BOOTLINE_ADDR_GET()				\
         (VBI_CONFIG_ADDR_GET()->bootLine)
 
-#define VBI_PANIC(vector, halt)				\
-    {							\
-    VB_PRINTF ("core%d: unhandled exception: 0x%x\n",   \
-		wrhvVbConfig->coreId, vector);		\
-    if (halt)						\
-        {						\
-        vbiPanic ("unhandled exception");		\
-	}						\
-    }							 
+#define VBI_PANIC(vector, halt)					\
+{								\
+	VB_PRINTF ("core%d: unhandled exception: 0x%x\n",	\
+		wrhvVbConfig->coreId, vector);			\
+	if (halt)						\
+        	vbiPanic("unhandled exception");		\
+}							 
 
 #ifndef ERROR
 #define ERROR	(-1)
@@ -913,54 +534,47 @@ various data structures.
 #endif
 
 /* typedefs */
-
 typedef struct vbiClkHook
-    {
-    void (*rtn)(void *pArg);
-    void * pArg;
-    } VBI_CLK_HOOK_INFO, * VBI_CLK_HOOK_INFO_PTR;
+{
+	void (*rtn)(void *pArg);
+	void * pArg;
+} VBI_CLK_HOOK_INFO, * VBI_CLK_HOOK_INFO_PTR;
 
 /* externs */
 
-extern VB_CONFIG  * wrhvVbConfig;
-extern VB_STATUS  * wrhvVbStatus;
-extern VB_CONTROL * wrhvVbControl;
-extern int32_t      wrhvVbIntNested;
-extern void vbiInit (VB_CONFIG * config);
-extern void vbiExcStub (void);
-extern void ASSERT_FN (const char *, const char *, int);
-extern void vbiIdle (uint64_t);
-extern void * vbiVioapicAddrGet (void);
-extern vbiStatus_t vbiVioapicVectorSet (vbiIrq_t irq, vbiVector_t vector); 
-extern vbiVector_t vbiVioapicVectorGet (vbiIrq_t irq);
-extern vbiStatus_t vbiVioapicIntUnmask (vbiIrq_t irq);
-extern vbiStatus_t vbiVioapicIntMask (vbiIrq_t irq);
-extern vbiStatus_t vbiVioapicIntAck (vbiIrq_t irq);
-extern vbiStatus_t vbiVioapicIntSend (vbiIrq_t irq, uint32_t filter,
+extern VB_CONFIG *wrhvVbConfig;
+extern VB_STATUS *wrhvVbStatus;
+extern VB_CONTROL *wrhvVbControl;
+extern int32_t wrhvVbIntNested;
+extern void vbiInit(VB_CONFIG *config);
+extern void vbiExcStub(void);
+extern void ASSERT_FN(const char *, const char *, int);
+extern void vbiIdle(uint64_t);
+extern void *vbiVioapicAddrGet(void);
+extern vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector); 
+extern vbiVector_t vbiVioapicVectorGet(vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntUnmask(vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntMask(vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntAck(vbiIrq_t irq);
+extern vbiStatus_t vbiVioapicIntSend(vbiIrq_t irq, uint32_t filter,
 				      vbiVb_t target);
-extern vbiStatus_t vbiVioapicIntSend (vbiIrq_t irq, uint32_t filter, 
+extern vbiStatus_t vbiVioapicIntSend(vbiIrq_t irq, uint32_t filter, 
 				     vbiVb_t vb);
 extern vbiStatus_t vbiVioapicIntRedirect(vbiIrq_t irq, vbiCore_t tCore);
 
-extern vbiStatus_t vbiGuestDmaAddrGet
-    (
-    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    );
-extern vbiStatus_t vbiGuestPhysToPhysAddr
-    (
-    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
-    vbiPhysAddr_t  *paddr	/* translated physical address */
-    );
-
-extern void vbiVioapicDisplay (void);
-extern void vbiSharedMemoryShow (VB_CONFIG * config);
-extern void vbiStatusShow (VB_STATUS * p);
-extern void vbiControlShow (VB_CONTROL * p);
-extern void vbiConfigShow (VB_CONFIG * p);
-extern void vbiMemoryShow  ( VB_CONFIG * config);
-extern void vbiStsRegsDisplay (void);
-extern void vbiCtrlRegsDisplay (void);
+extern vbiStatus_t vbiGuestDmaAddrGet(vbiGuestPhysAddr_t gaddr,
+				vbiPhysAddr_t  *paddr);
+extern vbiStatus_t vbiGuestPhysToPhysAddr(vbiGuestPhysAddr_t gaddr,
+				vbiPhysAddr_t  *paddr);
+
+extern void vbiVioapicDisplay(void);
+extern void vbiSharedMemoryShow(VB_CONFIG *config);
+extern void vbiStatusShow(VB_STATUS *p);
+extern void vbiControlShow(VB_CONTROL *p);
+extern void vbiConfigShow(VB_CONFIG *p);
+extern void vbiMemoryShow(VB_CONFIG *config);
+extern void vbiStsRegsDisplay(void);
+extern void vbiCtrlRegsDisplay(void);
 
 #endif	/* _ASMLANGUAGE */
 
diff --git a/include/vbi/vmmu.h b/include/vbi/vmmu.h
index 838dd6f..dd12ff9 100644
--- a/include/vbi/vmmu.h
+++ b/include/vbi/vmmu.h
@@ -93,119 +93,117 @@ word 1 (32-bits):
 /* Page Table Entry Definition */
 
 typedef union vmmu_pte		/* vmmu pte format */
-    {
-    struct			/* Bit field description */
+{
+	struct			/* Bit field description */
 	{
-	/* word 0 */
-
-	u_int v:1;		/* valid bit */
-	u_int hy:7;		/* reserved for use by hypervisor */
-	u_int rsvd1:8;		/* reserved */
-	u_int u0:1;		/* user attribute 0 */
-	u_int u1:1;		/* user attribute 1 */
-	u_int u2:1;		/* user attribute 2 */
-	u_int u3:1;		/* user attribute 3 */
-	u_int u4:1;		/* user attribute 4 */
-	u_int u5:1;		/* user attribute 5 */
-	u_int u6:1;		/* user attribute 6 */
-	u_int u7:1;		/* user attribute 7 */
-	u_int erpn:3;		/* extended real page number bits */
-	u_int w:1;		/* write thru/back */
-	u_int i:1;		/* cache inhibited */
-	u_int m:1;		/* memory coherent */
-	u_int g:1;		/* memory guarded  */
-	u_int e:1;		/* little endian bit */
-
-	/* word 1 */
-
-	u_int rpn:20;		/* real page number */
-	u_int rsvd2:4;		/* reserved */
-	u_int r:1;		/* page referenced bit */
-	u_int c:1;		/* page changed bit */
-	u_int ux:1;		/* user execute protection */
-	u_int sx:1;		/* supervisor execute protection */
-	u_int uw:1;		/* user write protection */
-	u_int sw:1;		/* supervisor write protection */
-	u_int ur:1;		/* user read protection */
-	u_int sr:1;		/* supervisor read protection */
+		/* word 0 */
+		u_int v:1;		/* valid bit */
+		u_int hy:7;		/* reserved for use by hypervisor */
+		u_int rsvd1:8;		/* reserved */
+		u_int u0:1;		/* user attribute 0 */
+		u_int u1:1;		/* user attribute 1 */
+		u_int u2:1;		/* user attribute 2 */
+		u_int u3:1;		/* user attribute 3 */
+		u_int u4:1;		/* user attribute 4 */
+		u_int u5:1;		/* user attribute 5 */
+		u_int u6:1;		/* user attribute 6 */
+		u_int u7:1;		/* user attribute 7 */
+		u_int erpn:3;		/* extended real page number bits */
+		u_int w:1;		/* write thru/back */
+		u_int i:1;		/* cache inhibited */
+		u_int m:1;		/* memory coherent */
+		u_int g:1;		/* memory guarded  */
+		u_int e:1;		/* little endian bit */
+
+		/* word 1 */
+		u_int rpn:20;		/* real page number */
+		u_int rsvd2:4;		/* reserved */
+		u_int r:1;		/* page referenced bit */
+		u_int c:1;		/* page changed bit */
+		u_int ux:1;		/* user execute protection */
+		u_int sx:1;		/* supervisor execute protection */
+		u_int uw:1;		/* user write protection */
+		u_int sw:1;		/* supervisor write protection */
+		u_int ur:1;		/* user read protection */
+		u_int sr:1;		/* supervisor read protection */
 	} field;
 
-    struct 
+	struct 
 	{
-	u_int word0;		/* word 0 */
-	u_int word1;		/* word 1 */
+		u_int word0;		/* word 0 */
+		u_int word1;		/* word 1 */
 	} words;
-    } VMMU_PTE;
+} VMMU_PTE;
 
 /* Effective Address Definition */
 
 typedef union vmmuEffectiveAddr /* effective Address structure */
-    {
-    struct
+{
+	struct
         {
-        u_int l1index:11;	/* Level 1 Index (2K) */
-        u_int l2index:9;	/* Level 2 Index (512) */
-        u_int po:12;		/* Page Offset (4K) */
+		u_int l1index:11;	/* Level 1 Index (2K) */
+		u_int l2index:9;	/* Level 2 Index (512) */
+		u_int po:12;		/* Page Offset (4K) */
         } field;
-    void * addr;
-    } VMMU_EFFECTIVE_ADDR;
+	void *addr;
+} VMMU_EFFECTIVE_ADDR;
 
 /* Real Address Definition */
 
 typedef union vmmuRealAddress	/* Real Address Structure */
-    {
-    struct                      /* Bit field description */
-        {
-        u_int rpn:20;           /* Real Page Number */
-        u_int po:12;            /* Page Offset */
+{
+	struct			/* Bit field description */
+	{
+       		u_int rpn:20;	/* Real Page Number */
+	        u_int po:12;	/* Page Offset */
         }field;
-    void * realAddr;            /* Real Address */
-    } VMMU_REAL_ADDRESS;
+	void *realAddr;	/* Real Address */
+} VMMU_REAL_ADDRESS;
 
 /* Level-1 descriptor definition */
 
 typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
-    {
-    struct                      /* Bit field desciption */
-        {
-        u_int l2ba:20;          /* Level 2 table Base Address */
-        u_int reserved:10;      /* Reserved */
-        u_int b:1;              /* Block translation */
-        u_int v:1;              /* Segment Valid bit */
+{
+	struct			/* Bit field desciption */
+	{
+		u_int l2ba:20;		/* Level 2 table Base Address */
+		u_int reserved:10;	/* Reserved */
+		u_int b:1;		/* Block translation */
+		u_int v:1;		/* Segment Valid bit */
         } field;
-    u_int l1desc;               /* Level 1 descriptor */
-    } VMMU_LEVEL_1_DESC;
+	u_int l1desc;		/* Level 1 descriptor */
+} VMMU_LEVEL_1_DESC;
 
 /* Level-2 descriptor definition */
 
 typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
-    {
-    VMMU_PTE pte;		/* a full PTE entry */
-    } VMMU_LEVEL_2_DESC;
+{
+	VMMU_PTE pte;		/* a full PTE entry */
+} VMMU_LEVEL_2_DESC;
 
 /* Level-2 table pointer definition */
 
 typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
-    {
-    struct                      /* Bit field description */
-        {
-        u_int l2tb:20;          /* Level 2 Table Base */
-        u_int l2index:9;	/* Level 2 table Index */
-        u_int reserved:3;       /* Reserved */
+{
+	struct		/* Bit field description */
+	{
+		u_int l2tb:20;		/* Level 2 Table Base */
+		u_int l2index:9;	/* Level 2 table Index */
+		u_int reserved:3;	/* Reserved */
         } field;
-    VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
-    } VMMU_LEVEL_2_TBL_PTR;
+	VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
+} VMMU_LEVEL_2_TBL_PTR;
 
 
 /* VMMU configuration system call paramter */
 
 typedef struct vmmuConfig
-    {
-    VMMU_LEVEL_1_DESC *addr;
-    u_int	  pageSize;
-    u_int	  contextId;
-    u_int	  vmmuNum;
-    } VMMU_CONFIG;
+{
+VMMU_LEVEL_1_DESC *addr;
+	u_int pageSize;
+	u_int contextId;
+	u_int vmmuNum;
+} VMMU_CONFIG;
 
 #endif /* _ASMLANGUAGE */
 
@@ -246,7 +244,6 @@ typedef struct vmmuConfig
 				VMMU_PROT_SUPV_EXECUTE
 
 /* VMMU cache attributes */
-
 #define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
 #define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
 #define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
@@ -255,39 +252,31 @@ typedef struct vmmuConfig
 #define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
 
 /* VMMU page table structure */
-
 #define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
 #define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
 #define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
 #define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
 
 /* address to level-1 table offset */
-
 #define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
 
 /* address to level-2 table offset */
-
 #define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
 
 /* offset within page */
-
 #define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
 
 /* address to logical block number */
-
 #define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
 #define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
 
 /* bit masks for PTE fields */
-
 /* word 0 */
-
 #define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
 #define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
 #define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
 
 /* word 1 */
-
 #define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
 #define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
 #define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
diff --git a/kernel/vbi/show.c b/kernel/vbi/show.c
index 939c085..2f3507c 100644
--- a/kernel/vbi/show.c
+++ b/kernel/vbi/show.c
@@ -27,286 +27,166 @@ control and configuration data structures.
 #include <linux/kernel.h>
 #include <vbi/vbi.h>
 
-/*******************************************************************************
-*
-* vbiSharedMemoryShow - print information about the shared memory configuration
-*
-* This routine traverse the array of shared memories descriptor for a given board
-* and displays the information on hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* void vbiSharedMemoryShow (void)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-* \NOMANUAL
-*/
-
-void vbiSharedMemoryShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_SM_INFO * p = config->sharedMemoryRegionsConfigAddress;
-    int          numSm = config->numSm;
-    void *       pState = config->sharedMemoryRegionsStateAddress;
-    int          i;
-
-    VB_PRINTF("%d Shared memory regions, Config at 0x%x:\n", numSm, p);
-
-    /* dump shared memory info if we have any attached */
-
-    for (i=0; i < numSm; i++,p++)
-        {
-	VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x)\n",
-		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
-		p->attr);
-        }
-
-    VB_PRINTF("Shared memory State at 0x%x:\n", pState);
-
-
-    }
-
-/*******************************************************************************
-*
-* vbiMemoryShow - print information about a board's  memory configuration
-*
-* This routine traverse the array of memory regions descriptor for a given board
-* and displays the information on hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* void vbiSharedMemoryShow (void)
-*
-*
-*
-* RETURNS: returns OK or errno in case of failure
-*
-*
-*
-*
-*
-*
-*/
-
-void vbiMemoryShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_MEM_INFO * p = config->memoryRegionsConfigAddress;
-    int          numSm = config->numMem;
-    int          i;
-
-    VB_PRINTF ("%d memory regions, Config at 0x%x:\n", numSm, p);
-
-    /* dump shared memory info if we have any attached */
+/*
+ * vbiSharedMemoryShow - print information about the shared memory
+ * configuration
+ *
+ * This routine traverse the array of shared memories descriptor for a
+ * given board and displays the information on hypervisor console.
+ *
+ */
 
-    for (i=0; i < numSm; i++,p++)
-        {
-	VB_PRINTF ("%8s: 0x%08x -> 0x%08x  (attr: 0x%x) (type: %s)\n",
-		p->name, p->addr, ((unsigned int)p->addr + p->length) - 1,
-                p->attr, p->type);
-        }
-    }
+void vbiSharedMemoryShow(VB_CONFIG *config)
+{
+	VB_SM_INFO *p = config->sharedMemoryRegionsConfigAddress;
+	int numSm = config->numSm;
+	void *pState = config->sharedMemoryRegionsStateAddress;
+	int i;
 
-/*******************************************************************************
-*
-* vbiInterruptsShow - print information about a board's interrupts configuration
-*
-* This routine traverse the interrupts descriptors table for a given board and
-* displays the information on hypervisor console.
-*
-* SYNOPSIS
-*
-* 
-* void vbiInterruptsShow (void)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*
-*
-*/
+	VB_PRINTF("%d Shared memory regions, Config at 0x%x:\n", numSm, p);
 
-static void vbiInterruptsShow
-    (
-    VB_CONFIG * config
-    )
-    {
-    VB_INT_INFO * p = config->interruptConfiguration;
-    int           numInt = config->numInts;
-    int           i;
+	/* dump shared memory info if we have any attached */
+	for (i=0; i < numSm; i++,p++) {
+		VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x)\n",
+		p->name, p->addr,
+		((unsigned int)p->addr + p->length) - 1, p->attr);
+	}
 
-    VB_PRINTF ("%d interrupt configurations, Config at 0x%x\n", numInt, p);
+	VB_PRINTF("Shared memory State at 0x%x:\n", pState);
+}
 
-    for (i = 0; i < numInt; i++, p++)
-        {
-	if (p->intDirection == VB_INPUT_INT)
-	    {
-	    VB_PRINTF ("%8s: Direction: In, Vector Number: %d, Core: %d\n",
-                p->intName, p->intNumber, p->intCore);
-	    }
-	else
-	    {
-	    VB_PRINTF ("%8s: Direction: Out, Vector Number: %d\n",
-                p->intName, p->intNumber);
-	    }
-        }
-    }
-
-/*******************************************************************************
-*
-* vbiStatusShow - print information about a board's status structures
-*
-* This routine displays information in the status structure for a given board.
-*
-* SYNOPSIS
-*
-* 
-* void vbiStatusShow (void)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*
-*
-*/
+/*
+ * vbiMemoryShow - print information about a board's  memory
+ * configuration
+ *
+ * This routine traverse the array of memory regions descriptor for a
+ * given board and displays the information on hypervisor console.
+ *
+ * RETURNS: returns OK or errno in case of failure
+ *
+ */
+void vbiMemoryShow(VB_CONFIG *config)
+{
+	VB_MEM_INFO *p = config->memoryRegionsConfigAddress;
+	int numSm = config->numMem;
+	int i;
+
+	VB_PRINTF("%d memory regions, Config at 0x%x:\n", numSm, p);
+
+	/* dump shared memory info if we have any attached */
+	for (i=0; i < numSm; i++,p++) {
+		VB_PRINTF("%8s: 0x%08x -> 0x%08x  (attr: 0x%x) (type: %s)\n",
+			p->name, p->addr,
+			((unsigned int)p->addr + p->length) - 1,
+			p->attr, p->type);
+	}
+}
 
-void vbiStatusShow
-    (
-    VB_STATUS *p
-    )
-    {
+/*
+ * vbiInterruptsShow - print information about a board's
+ * interrupts configuration
+ *
+ * This routine traverse the interrupts descriptors table for a given
+ * board and displays the information on hypervisor console.
+ *
+ */
+static void vbiInterruptsShow(VB_CONFIG *config)
+{
+	VB_INT_INFO * p = config->interruptConfiguration;
+	int numInt = config->numInts;
+	int i;
+
+	VB_PRINTF("%d interrupt configurations, Config at 0x%x\n", numInt, p);
+
+	for (i = 0; i < numInt; i++, p++) {
+		if (p->intDirection == VB_INPUT_INT)
+			VB_PRINTF("%8s: Dir: In, Vector #: %d, Core: %d\n",
+		            p->intName, p->intNumber, p->intCore);
+		else 
+			VB_PRINTF("%8s: Dir: Out, Vector #: %d\n",
+		            p->intName, p->intNumber);
+	}
+}
 
-    VB_PRINTF ("VB status: 0x%x\n", p);
+/*
+ * vbiStatusShow - print information about a board's status structures
+ *
+ * This routine displays information in the status structure for a given board.
+ *
+ */
+void vbiStatusShow(VB_STATUS *p)
+{
+	VB_PRINTF("VB status: 0x%x\n", p);
 
-    VB_PRINTF ("  Pending interrupts: 0x%08x\n", p->intPendingType);
-    VB_PRINTF ("  timestamp:          %lld\n", p->timeStamp);
-    VB_PRINTF ("  old int disable:    0x%08x\n", p->oldIntDisable);
+	VB_PRINTF("  Pending interrupts: 0x%08x\n", p->intPendingType);
+	VB_PRINTF("  timestamp:          %lld\n", p->timeStamp);
+	VB_PRINTF("  old int disable:    0x%08x\n", p->oldIntDisable);
 #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiStsRegsDisplay ();
+	vbiStsRegsDisplay();
 #endif
-    }
-
-/*******************************************************************************
-*
-* vbiControlShow - print information about a board's control structures
-*
-* This routine displays information in the control structure for a given board.
-*
-* SYNOPSIS
-*
-* 
-* void vbiControlShow (void)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*
-*
-*/
+}
 
-void vbiControlShow
-    (
-    VB_CONTROL * p
-    )
-    {
-    int i;
+/*
+ * vbiControlShow - print information about a board's control structures
+ *
+ * This routine displays information in the control structure for a given board.
+ *
+ */
+void vbiControlShow(VB_CONTROL *p)
+{
+	int i;
 
-    VB_PRINTF ("VB control data: 0x%x\n", p);
+	VB_PRINTF("VB control data: 0x%x\n", p);
 
-    VB_PRINTF ("  Disable interrupts:  0x%08x\n", p->intDisable);
+	VB_PRINTF("  Disable interrupts:  0x%08x\n", p->intDisable);
 
 #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiCtrlRegsDisplay (); 
+	vbiCtrlRegsDisplay (); 
 #endif
 
-    VB_PRINTF ("  Disabled interrupts:");
-    for (i=0; i < VB_MAX_INTERRUPTS; i++)
-        {
-	if ((p->intLevelDisable & (1 << (32 - i))) != 0)
-            {
-	    VB_PRINTF (" %d", i);
-            }
-        }
-    VB_PRINTF ("\n");
-    }
-
-/*******************************************************************************
-*
-* vbiConfigShow - print information about a board's config structures
-*
-* This routine displays information in the config structure for a given board.
-*
-* SYNOPSIS
-*
-* 
-* void vbiConfigShow (void)
-*
-*
-*
-* RETURNS: N/A
-*
-*
-*
-*
-*
-*/
+	VB_PRINTF("  Disabled interrupts:");
+	for (i=0; i < VB_MAX_INTERRUPTS; i++) {
+		if ((p->intLevelDisable & (1 << (32 - i))) != 0)
+			VB_PRINTF(" %d", i);
+	}
+	VB_PRINTF("\n");
+}
 
-void vbiConfigShow
-    (
-    VB_CONFIG * p
-    )
-    {
+/*
+ * vbiConfigShow - print information about a board's config structures
+ *
+ * This routine displays information in the config structure for a given board.
+ *
+ */
 
-    VB_PRINTF ("VB config data: 0x%x\n", p);
+void vbiConfigShow(VB_CONFIG *p)
+{
+	VB_PRINTF("VB config data: 0x%x\n", p);
 
-    VB_PRINTF ("pid:                %d\n",	    p->pid);
-    VB_PRINTF ("Board ID:           %d\n",	    p->boardID);
+	VB_PRINTF("pid:                %d\n", p->pid);
+	VB_PRINTF("Board ID:           %d\n", p->boardID);
 
-    VB_PRINTF ("Status Address:     " LONG_FMT "\n", p->vbStatus);
-    VB_PRINTF ("Control Address:    " LONG_FMT "\n", p->vbControl);
+	VB_PRINTF("Status Address:     " LONG_FMT "\n", p->vbStatus);
+	VB_PRINTF("Control Address:    " LONG_FMT "\n", p->vbControl);
 #if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
-    VB_PRINTF ("Syscall Table Address:    " LONG_FMT "\n", p->vbSyscallTable);
+	VB_PRINTF("Syscall Table Address:    " LONG_FMT "\n",
+			p->vbSyscallTable);
 #endif
-    VB_PRINTF ("SupervisoryMode:    %d\n",	    p->supervisoryMode);
-
-    VB_PRINTF ("Board Name:         %s\n",	    p->boardName);
-    VB_PRINTF ("Board Type:         %d\n",	    p->boardType);
-    VB_PRINTF ("Physical Memory:    %d\n",     p->physicalMemorySize);
-    VB_PRINTF ("Memory Alias Addr:  0x%08x\n", p->memoryAliasAddress);
-    VB_PRINTF ("Memory Alias Size:  %u\n",     p->memoryAliasSize);
-    VB_PRINTF ("Reset PC:           0x%08x\n", p->resetPC);
+	VB_PRINTF("SupervisoryMode:    %d\n", p->supervisoryMode);
 
-    VB_PRINTF ("Timer Frequency:     %d/sec\n",	    p->tickTimerFrequency);
-    VB_PRINTF ("TimeStamp Frequency: %dULL/sec\n",	    p->timeStampFrequency);
+	VB_PRINTF("Board Name:         %s\n", p->boardName);
+	VB_PRINTF("Board Type:         %d\n", p->boardType);
+	VB_PRINTF("Physical Memory:    %d\n", p->physicalMemorySize);
+	VB_PRINTF("Memory Alias Addr:  0x%08x\n", p->memoryAliasAddress);
+	VB_PRINTF("Memory Alias Size:  %u\n", p->memoryAliasSize);
+	VB_PRINTF("Reset PC:           0x%08x\n", p->resetPC);
 
-    VB_PRINTF ("numInts:             %d\n",	    p->numInts);
+	VB_PRINTF("Timer Frequency:     %d/sec\n", p->tickTimerFrequency);
+	VB_PRINTF("TimeStamp Frequency: %dULL/sec\n", p->timeStampFrequency);
 
-    vbiMemoryShow (p);
-    vbiSharedMemoryShow (p);
-    vbiInterruptsShow (p);
+	VB_PRINTF("numInts:             %d\n", p->numInts);
 
-    }
+	vbiMemoryShow(p);
+	vbiSharedMemoryShow(p);
+	vbiInterruptsShow(p);
+}
-- 
1.6.5.rc3

