From 85321af225b0512f7de7b49accedb51f8476f7b2 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Mon, 16 Nov 2009 09:10:24 -0800
Subject: [PATCH] Support novtlbopt in the bootargs.

Refactored the code by placing common vtlb initialization
into its own routine.  Check for novtlbopt in the bootargs
and do not enable vtlb optimization if it is there.

Use strstr() because we have to check even earlier than the
early_param() interface allows.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/x86/kernel/vbi/wrhv.c |   48 +++++++++++++++++--------------------------
 1 files changed, 19 insertions(+), 29 deletions(-)

diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 12483cf..9c59bd6 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -74,6 +74,8 @@ static int enable_hrtimer = 0;
 			 VBI_VTLB_OPS_CACHE_ENABLED |  \
 			 VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED)
 
+#define VBI_VTLB_OPTIM_OPTION_NOOPT (VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED)
+
 static void wrhv_vtlb_op (unsigned int op, unsigned long arg1,
 				unsigned long arg2, unsigned long arg3);
 
@@ -689,7 +691,7 @@ static void wrhv_exit_mmap (struct mm_struct *mm)
 #endif
 }
 
-static void wrhv_init_mm(void)
+static void wrhv_init_vtlb_per_cpu(void)
 {
 	/* Initialize the cached copy of cr3 */
 	VTLB_GET_CPU_VAR(cr3_val) = native_read_cr3();
@@ -707,9 +709,16 @@ static void wrhv_init_mm(void)
 	   one will actually be in use.
 	*/
 
-	VTLB_GET_CPU_VAR(vtlb_ctrl).mode = VBI_VTLB_OPTIM_OPTION;
+	if (strstr(boot_command_line, "novtlbopt")) {
+		VTLB_GET_CPU_VAR(vtlb_ctrl).mode = VBI_VTLB_OPTIM_OPTION_NOOPT;
+		printk("WRHV:  CPU %d vtlb optimization disabled\n",
+			smp_processor_id());
+	}
+	else
+		VTLB_GET_CPU_VAR(vtlb_ctrl).mode = VBI_VTLB_OPTIM_OPTION;
 
-	vbiVtlbOp(VBI_VTLB_OP_INIT, __pa_symbol(&VTLB_GET_CPU_VAR(vtlb_ctrl)), 0, 0);
+	vbiVtlbOp(VBI_VTLB_OP_INIT, __pa_symbol(&VTLB_GET_CPU_VAR(vtlb_ctrl)),
+		 0, 0);
 
 	if (VTLB_GET_CPU_VAR(vtlb_ctrl).mode & VBI_VTLB_CR3_CACHE_ENABLED)
 		VTLB_GET_CPU_VAR(is_cr3_cache_enabled) = 1;
@@ -718,6 +727,12 @@ static void wrhv_init_mm(void)
 	if (VTLB_GET_CPU_VAR(vtlb_ctrl).mode & VBI_VTLB_OPS_CACHE_ENABLED)
 		VTLB_GET_CPU_VAR(is_vtlb_ops_cache_enabled) = 1;
 
+}
+
+static void wrhv_init_mm(void)
+{
+	wrhv_init_vtlb_per_cpu();
+
 	pv_mmu_ops.read_cr3 = wrhv_read_cr3;
 	pv_mmu_ops.write_cr3 = wrhv_write_cr3;
 
@@ -978,32 +993,7 @@ static void __cpuinit wrhv_smp_start_cpu(void)
 {
 	wrhv_mask_timer_for_vcore();
 
-	/* Initialize the cached copy of cr3 */
-	VTLB_GET_CPU_VAR(cr3_val) = native_read_cr3();
-
-	/*
-	 * set the size of the vtlb_ctrl structure in the structure provided
-	 * to the hypervisor; the hypervisor may be able to use this later
-	 * for backward compatibility.
-	 */
-
-	VTLB_GET_CPU_VAR(vtlb_ctrl).size = sizeof (VTLB_GET_CPU_VAR(vtlb_ctrl));
-
-	/* First set the options supported by the guest OS. The host will
-	   then update the mode field of vtlb_ctrl option to indicate which
-	   one will actually be in use.
-	*/
-
-	VTLB_GET_CPU_VAR(vtlb_ctrl).mode = VBI_VTLB_OPTIM_OPTION;
-
-	vbiVtlbOp(VBI_VTLB_OP_INIT, __pa_symbol(&VTLB_GET_CPU_VAR(vtlb_ctrl)), 0, 0);
-
-	if (VTLB_GET_CPU_VAR(vtlb_ctrl).mode & VBI_VTLB_CR3_CACHE_ENABLED)
-		VTLB_GET_CPU_VAR(is_cr3_cache_enabled) = 1;
-	if (VTLB_GET_CPU_VAR(vtlb_ctrl).mode & VBI_VTLB_OPTIM_ENABLED)
-		VTLB_GET_CPU_VAR(is_vtlb_optim_enabled) = 1;
-	if (VTLB_GET_CPU_VAR(vtlb_ctrl).mode & VBI_VTLB_OPS_CACHE_ENABLED)
-		VTLB_GET_CPU_VAR(is_vtlb_ops_cache_enabled) = 1;
+	wrhv_init_vtlb_per_cpu();
 
 	cpu_init();
 	wrhv_umask_IPIs_for_vcore();
-- 
1.6.5.2

