From 15115a9921c4b996624ecf2abb6b236181f63ebc Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:23:11 -0400
Subject: [PATCH 21/24] drivers: changes to various drivers for hypervisor/guest

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 drivers/net/gianfar.c         |    3 ++-
 drivers/net/gianfar.h         |    1 -
 drivers/net/gianfar_mii.c     |    6 ++++++
 drivers/serial/8250.c         |   40 +++++++++++++++++++++++++++++++++++++++-
 drivers/serial/serial_core.c  |    9 +++++++++
 drivers/usb/host/pci-quirks.c |    3 +++
 6 files changed, 59 insertions(+), 3 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index c9e6a5d..d046cde 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -698,6 +698,7 @@ void stop_gfar(struct net_device *dev)
  		free_irq(priv->interruptTransmit, dev);
 	}
 
+skip_free_irq:
 	free_skb_resources(priv);
 
 	dma_free_coherent(&dev->dev,
@@ -949,7 +950,7 @@ int startup_gfar(struct net_device *dev)
 			goto err_irq_fail;
 		}
 	}
-
+skip_request_irq:
 	phy_start(priv->phydev);
 
 	/* Configure the coalescing support */
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index 4c95693..130adf9 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -743,7 +743,6 @@ struct gfar_private {
 	unsigned int interruptTransmit;
 	unsigned int interruptReceive;
 	unsigned int interruptError;
-
 	/* info structure initialized by platform code */
 	struct gianfar_platform_data *einfo;
 
diff --git a/drivers/net/gianfar_mii.c b/drivers/net/gianfar_mii.c
index ebcfb27..1d7e30f 100644
--- a/drivers/net/gianfar_mii.c
+++ b/drivers/net/gianfar_mii.c
@@ -42,6 +42,12 @@
 #include "gianfar.h"
 #include "gianfar_mii.h"
 
+#define MDIO_READ 1
+#define MDIO_WRITE 2
+#define MDIO_INT_ENABLE 3
+#define MDIO_INT_DISABLE 4
+#define MDIO_RESET 5
+
 /*
  * Write value to the PHY at mii_id at register regnum,
  * on the bus attached to the local interface, which may be different from the
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 537a245..093864a 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -44,6 +44,11 @@
 
 #include "8250.h"
 
+#include <linux/wrhv.h>
+#if defined(CONFIG_WRHV) && defined(CONFIG_PPC) && !defined(CONFIG_WRHV_8572)
+#define WRHV_PPC_DUART 1
+#endif
+
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -940,6 +945,10 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		return;
 	}
 
+#ifdef WRHV_PPC_DUART
+	/* This doesn't co-operate very well with the DUART being
+	 * used from another guest OS */
+#else
 	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
@@ -974,6 +983,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_outp(up, UART_IER, iersave);
+#endif /* WRHV_PPC_DUART */
 }
 
 /*
@@ -1239,8 +1249,9 @@ static void serial8250_start_tx(struct uart_port *port)
 
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
+#ifndef WRHV_PPC_DUART
 		serial_out(up, UART_IER, up->ier);
-
+#endif
 		if (up->bugs & UART_BUG_TXEN) {
 			unsigned char lsr, iir;
 			lsr = serial_in(up, UART_LSR);
@@ -1443,6 +1454,25 @@ serial8250_handle_port(struct uart_8250_port *up)
 		return;
 	}
 
+#if defined(CONFIG_MPC834x) || defined(CONFIG_MPC85xx_CDS) || \
+	defined(CONFIG_SBC8548) || defined (CONFIG_PPC_MPC832x)
+	/*
+	 * There appears to be a quirk in the implementation on some 8xxx
+	 * where after a break is rec'd (UART_LSR_BI), the UART generates
+	 * a short duration burst of bogus IRQ events with the signature
+	 * of RFE set (along with "normal" bits set) in the LSR.
+	 */
+
+#define RFE_8xxx_ERR_BITS (	UART_LSR_RFE    | UART_LSR_TEMT | \
+				UART_LSR_THRE   | UART_LSR_BI   | \
+				UART_LSR_DR     )
+
+	if (status == RFE_8xxx_ERR_BITS) {
+		spin_unlock(&up->port.lock);
+		return;
+	}
+#endif
+
 	DEBUG_INTR("status = %x...", status);
 
 	if (status & (UART_LSR_DR | UART_LSR_BI))
@@ -1608,7 +1638,9 @@ static void serial8250_timeout(unsigned long data)
 	unsigned int iir;
 
 	iir = serial_in(up, UART_IIR);
+#ifndef WRHV_PPC_DUART
 	if (!(iir & UART_IIR_NO_INT))
+#endif
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
 }
@@ -1984,6 +2016,9 @@ static int serial8250_startup(struct uart_port *port)
 	if (up->port.flags & UPF_NO_TXEN_TEST)
 		goto dont_test_tx_en;
 
+#ifdef WRHV_PPC_DUART
+	up->bugs |= UART_BUG_TXEN;
+#else
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -2002,6 +2037,7 @@ static int serial8250_startup(struct uart_port *port)
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
+#endif /* WRHV_PPC_DUART */
 
 dont_test_tx_en:
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2023,8 +2059,10 @@ dont_test_tx_en:
 	 * are set via set_termios(), which will be occurring imminently
 	 * anyway, so we don't enable them here.
 	 */
+#ifndef WRHV_PPC_DUART
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
 	serial_outp(up, UART_IER, up->ier);
+#endif
 
 	if (up->port.flags & UPF_FOURPORT) {
 		unsigned int icp;
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 7547e94..4784808 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2492,6 +2492,15 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 		lockdep_set_class(&port->lock, &port_lock_key);
 	}
 
+#ifdef CONFIG_WRHV
+#define __MIPC_MSD_MAJOR	236
+	if (!uart_console(port) && (drv->major != __MIPC_MSD_MAJOR)) {
+		ret = -EBUSY;
+		goto out;
+	}
+#undef __MIPC_MSD_MAJOR
+#endif
+
 	uart_configure_port(drv, state, port);
 
 	/*
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 5ef25db..055a17e 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -354,6 +354,9 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 
 static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 {
+	if (paravirt_enabled())
+		return;
+
 	if (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)
 		quirk_usb_handoff_uhci(pdev);
 	else if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)
-- 
1.6.3.3

