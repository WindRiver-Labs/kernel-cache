From 0222487133704703da8bb14c2eae6af76441872a Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 15 Oct 2009 17:02:48 -0400
Subject: [PATCH 19/23] vbi: relocate x86 arch.h to arch specific dir.

This file isn't currently being used either, but relocate it
to a sane place regardless...

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 include/asm-x86/sys_vbi.h          |  763 ++++++++++++++++++++++++++++++++++++
 include/vbi/support/sys/x86/arch.h |  763 ------------------------------------
 2 files changed, 763 insertions(+), 763 deletions(-)
 create mode 100644 include/asm-x86/sys_vbi.h
 delete mode 100644 include/vbi/support/sys/x86/arch.h

diff --git a/include/asm-x86/sys_vbi.h b/include/asm-x86/sys_vbi.h
new file mode 100644
index 0000000..a807015
--- /dev/null
+++ b/include/asm-x86/sys_vbi.h
@@ -0,0 +1,763 @@
+/* sys/x86/arch.h - x86 architecture specific definitions */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02w,24sep09,mmi  add virtual interrupts
+02v,01sep09,mmi  include interface.h
+02u,19aug09,md   add VBI register load/save region
+02t,28jul09,mpk  add cache align size
+02s,18jun09,dtr  Move excMgrId def here.
+02r,11jun09,md   add MSI interrupt space
+02q,09jun09,md   add support for additional I/O APICs
+02p,16jul09,dbt  Added vmx_cr4 registery in ARCH_INFO structure.
+02o,13jul09,dbt  Added x86Vb32IdtXxx() API prototypes.
+02n,10jul09,dbt  Added information about guest MMU mode (32 bits, 64bits,...).
+02m,03jul09,dbt  Added HY_TSS_GDT_ENTRY_SIZE macro.
+02l,30jun09,dbt  64-bits support.
+		 Added support for 32-bits VB GDT
+02k,25jun09,dbt  Updated bitClear prototype.
+02j,19jun09,dbt  Updated idtIntGateCreate() prototype for 64 bits support.
+02m,14jul09,rdd  VT-d integration
+02i,20may09,md   add byte order define
+02h,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02g,20apr09,mpk  context vaddr start
+02f,09mar09,md   add test and set function
+02e,13feb09,md   add per-cpu hypervisor TSS
+02d,20jan09,mmi  add VIOAPIC entries size
+02c,15jan09,md   add configuration options
+02b,20nov08,dtr  Remove vIoapic entries in ARCH_INFO.
+02a,18nov08,dbt  Added MSR area.
+01z,12nov08,md   fix isCpuCorePresent macro
+01y,28oct08,dbt  Added vtlbInit() prototype. Added vtlb_desc structure to
+                 ARCH_INFO.
+01x,27oct08,md   re-work multi-core ipi
+01w,17oct08,md   add ipi interrupt vector definitions
+01v,22sep08,md   add interrupt statistics
+01u,03sep08,md   update CPU_MAPPING to indicate if core is present
+01t,31jul08,md   add vmcs bitmap pointers
+01s,17jul08,md   add cpu mapping table
+01r,20may08,md   add multi-core support
+01q,19may08,gws  replace interrupt queues
+01p,23apr08,gws  macro rename
+01o,17apr08,gws  add macros for int vectors
+01n,14apr08,md   re-work interrupt delivery
+01m,27mar08,md   add pointer to queued interrupts
+01l,17mar08,md   add arch specific stats
+01k,07mar08,md   add cached copies of CR0 and CR3
+01j,04mar08,md   add FRAMEBASESZ
+01i,26feb08,md   add APIC timer interrupt
+01h,19feb08,md   add VT-x register save area
+01g,28jan08,md   add VT-x support
+01f,05oct07,md   add network/host translation functions
+01e,05sep07,md   clean up
+01d,30aug07,md   added IDT and syscall transition defines
+01c,31jul07,md   added gdtInit() and gdtTssCreate() prototypes
+01b,27jul07,md   added struct arch_info
+01a,06jul07,md   written.
+*/
+
+#ifndef __INCx86Archh
+#define __INCx86Archh
+
+#include <sys/regs.h>
+#include <sys/x86/vmx.h>
+#include <interface.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LP64
+#define _WRS_PORTABLE_bLib
+#define _WRS_BLIB_ALIGNMENT     1       /* 2 byte alignment mask */
+#endif
+
+/* x86 uses little endian byte ordering */
+
+#define	__BYTE_ORDER	__LITTLE_ENDIAN
+
+/* maximum number of cpu's supported */
+
+#if defined(WRHV_INCLUDE_MULTI_CORE)
+# define HY_MAX_CPU		16
+#else
+# define HY_MAX_CPU		1
+#endif
+
+/* boot processor number */
+
+#define	HY_BOOT_CPU		0
+
+/* attribute declaration for cpu specific variable */
+
+#define	CPU_PRIVATE	__attribute__((__section__(".cpu_private")))
+
+/* interrupt related defines */
+
+#define	X86_MAX_VECTORS         256	/* maximum number of vectors */
+#define X86_MAX_INTERRUPTS      (X86_MAX_VECTORS - X86_INT_VECTOR_BASE)
+#define INT_QUEUE_DEPTH	5	/* per interrupt source */
+#define NUM_WDS_PER_ISR		(256 / 32)
+#define INT_QUEUE_OPTIMIZE
+#define ARCH_RESERVED_VECTORS   0x20
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#ifndef	_ASMLANGUAGE
+
+typedef long ptrdiff_t;
+
+/* per context interrupt statistics */
+
+typedef struct arch_int_stats {
+    uint32_t  intDeliverCount;		/* interrupt delivery count	   */
+    uint32_t  intAckCount;		/* interrupt acknowledge count	   */
+    } ARCH_INT_STATS;
+
+/* per context architecture specific statistics */
+
+typedef struct arch_stats {
+    uint32_t  VMexitCount[NUM_VM_EXITS]; /* per vm-exit count		   */
+    uint32_t  VMexitUnhandled;		 /* number of unhandled exits	   */
+					 /* interrupt stats		   */
+    ARCH_INT_STATS interrupt[X86_MAX_VECTORS];
+    } ARCH_STATS;
+
+/* queued interrupt information */
+
+typedef struct arch_int {
+    uint32_t	     intNum;	 	/* interrupt number to deliver	   */
+    uint32_t	     errorCode;	 	/* exrror code to push on stack	   */
+    struct arch_int *next;		/* pointer to next interrupt	   */
+    } ARCH_INT;
+
+/* Guest MMU mode */
+
+typedef enum arch_mmu_mmode
+    {
+    MMU32,			/* 32-bit MMU				*/
+    MMU32_PAE,			/* 32-bit MMU with PAE support		*/
+    MMU64			/* 64-bit MMU				*/
+    } ARCH_MMU_MODE;
+
+/* per context architecture specific information */
+
+typedef struct arch_info {
+    void       *vmcs;		/* pointer to VT-x VMCS data region	*/
+    ARCH_STATS *stats;		/* architecture specific statistics	*/
+    void       *ioBitmapA;	/* pointer to VMCS I/O bitmap A	   	*/
+    void       *ioBitmapB;	/* pointer to VMCS I/O bitmap B	   	*/
+
+    /* The portion of HREG_SET that is not saved in the VMCS: */
+
+#ifdef LP64
+    _RType	vmx_rax;	/* general register			*/
+    _RType	vmx_rbx;	/* general register			*/
+    _RType	vmx_rcx;	/* general register			*/
+    _RType	vmx_rdx;	/* general register			*/
+    _RType	vmx_rsp;	/* stack pointer register		*/
+    _RType	vmx_rbp;	/* frame pointer register		*/
+    _RType	vmx_rsi;	/* general register			*/
+    _RType	vmx_rdi;	/* general register			*/
+    _RType	vmx_r8;		/* general register			*/
+    _RType	vmx_r9;		/* general register			*/
+    _RType	vmx_r10;	/* general register			*/
+    _RType	vmx_r11;	/* general register			*/
+    _RType	vmx_r12;	/* general register			*/
+    _RType	vmx_r13;	/* general register			*/
+    _RType	vmx_r14;	/* general register			*/
+    _RType	vmx_r15;	/* general register			*/
+    _RType	vmx_cr0;	/* control register 0			*/
+    _RType	vmx_cr3;	/* control register 3			*/
+    _RType	vmx_cr4;	/* control register 4			*/
+#else
+    size_t	tssIndex;	/* entry this tss is using in the GDT  	*/
+    TSS	       *tss;		/* pointer to task state segment struct	*/
+    _RType	vmx_eax;	/* VMX saved general register		*/
+    _RType	vmx_ebx;	/* VMX saved general register		*/
+    _RType	vmx_ecx;	/* VMX saved general register		*/
+    _RType	vmx_edx;	/* VMX saved general register		*/
+    _RType	vmx_edi;	/* VMX saved general register		*/
+    _RType	vmx_esi;	/* VMX saved general register		*/
+    _RType	vmx_ebp;	/* VMX saved frame pointer register	*/
+    _RType	vmx_cr0;	/* VMX cached CR0 register value	*/
+    _RType	vmx_cr3;	/* VMX saved CR3 (page table) register	*/
+    _RType	vmx_cr4;	/* VMX cached CR0 register value */
+#endif
+
+    /* Intel VT-d IOMMU domain attributes */
+
+    uint32_t   iommu_domid;
+    uint32_t   iommu_transtype;
+    uint32_t   iommu_agaw;
+    void       *pageroot_maddr;
+
+    /* MSR management */
+
+    void       *msrBitmap;	/* pointer to VMCS MSR bitmap		*/
+    void       *msrEntries;	/* pointer to VM MSR load/save area	*/
+    void       *msrHostEntries;	/* pointer to Host MSR load area	*/
+    uint32_t	msrMaxEntries;	/* maximum number of MSR entries	*/
+    uint32_t	msrMaxHostEntries;/* maximum number of Host MSR entries	*/
+
+    uint32_t	archFlags;	/* 30: arch specific flags		*/
+    uint32_t	idtVector;	/* 34: IDT vectoring information	*/
+    uint32_t	idtCode;	/* 38: IDT vectoring error code		*/
+
+    /* VTLB stuff */
+
+    struct vtlb_desc *	pVtlbDesc;	/* VTLB context descriptor	*/
+    ARCH_MMU_MODE	mmuMode;	/* Guest MMU mode */
+
+    /* VBI interface register read/write cache area */
+
+    uint32_t	  vbiRegsValid;	/* registers values have been set	*/
+    VBI_HREG_SET  vbiRegs;	/* register values set by VBI API	*/
+
+    } ARCH_INFO;
+
+/* information for per-core architecture mapping */
+
+typedef struct cpu_core_mapping {
+    uint32_t present;
+    uint32_t apicId;
+} CPU_CORE_MAPPING;
+
+struct hy_ctx;
+
+/* arch specific functions */
+
+extern void gdtInit (void *addr);
+extern int  gdtTssCreate (uint32_t gdtNumber, TSS *pTss, uint32_t tssSize,
+			  uint32_t priv);
+extern int  gdtCallCreate (uint32_t gdtNumber, void *addr, uint32_t priv);
+extern int  gdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
+
+extern void idtInit (void *addr);
+extern int  idtTaskGateCreate (uint32_t idtNumber, uint32_t gdtEntry,
+			       uint32_t priv);
+extern int  idtIntGateCreate (uint32_t idtNumber, void *addr, uint32_t priv);
+
+extern void bitSet (void *addr, unsigned long position);
+extern void bitClear (void *addr, unsigned long position);
+extern void vtlbInit (struct hy_ctx * ctx);
+extern int  vtlbMmuOp (uint32_t op, uint32_t arg1,
+		       uint32_t arg2, uint32_t arg3);
+extern uint32_t testAndSet (void *addr);
+extern int	x86Guest32GdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
+extern void *	x86Guest32GdtAddrGet (void);
+extern size_t	x86Guest32GdtSizeGet (void);
+extern size_t	x86Guest32GdtLimitGet (void);
+extern void *	x86Guest32IdtAddrGet (void);
+extern size_t	x86Guest32IdtSizeGet (void);
+extern size_t	x86Guest32IdtLimitGet (void);
+
+/* arch specific globals */
+
+extern CPU_CORE_MAPPING cpuCoreMapping[HY_MAX_CPU];
+extern ARCH_INT_STATS   cpuIntStats[HY_MAX_CPU][X86_MAX_VECTORS];
+CPU_PRIVATE extern ctx_t excMgrId;	/* exception mananger */
+
+#endif	/* _ASMLANGUAGE */
+
+/* struct arch_info offsets */
+
+#ifdef LP64
+#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer	       */
+#define CTX_ARCH_STATS_OFF	8   /* offset to ARCH_STATS	       */
+#define CTX_ARCH_IO_A_OFF	16  /* offset to *ioBitmapA	       */
+#define CTX_ARCH_IO_B_OFF	24  /* offset to *ioBitmapB	       */
+#define	CTX_ARCH_VRAX_OFF	32  /* offset to vmx RAX register save */
+#define	CTX_ARCH_VRBX_OFF	40  /* offset to vmx RBX register save */
+#define	CTX_ARCH_VRCX_OFF	48  /* offset to vmx RCX register save */
+#define	CTX_ARCH_VRDX_OFF	56  /* offset to vmx RDX register save */
+#define	CTX_ARCH_VRSP_OFF	64  /* offset to vmx RSP register save */
+#define	CTX_ARCH_VRBP_OFF	72  /* offset to vmx RBP register save */
+#define	CTX_ARCH_VRSI_OFF	80  /* offset to vmx RSI register save */
+#define	CTX_ARCH_VRDI_OFF	88  /* offset to vmx RDI register save */
+#define	CTX_ARCH_VR8_OFF	96  /* offset to vmx R8; register save */
+#define	CTX_ARCH_VR9_OFF	104 /* offset to vmx R9; register save */
+#define	CTX_ARCH_VR10_OFF	112 /* offset to vmx R10 register save */
+#define	CTX_ARCH_VR11_OFF	120 /* offset to vmx R11 register save */
+#define	CTX_ARCH_VR12_OFF	128 /* offset to vmx R12 register save */
+#define	CTX_ARCH_VR13_OFF	136 /* offset to vmx R13 register save */
+#define	CTX_ARCH_VR14_OFF	144 /* offset to vmx R14 register save */
+#define	CTX_ARCH_VR15_OFF	152 /* offset to vmx R15 register save */
+#define	CTX_ARCH_VCR0_OFF	160 /* offset to vmx CR0 register save */
+#define	CTX_ARCH_VCR3_OFF	168 /* offset to vmx CR3 register save */
+#define	CTX_ARCH_VCR4_OFF	176 /* offset to vmx CR4 register save */
+#define	CTX_ARCH_MSRBMP_OFF	184 /* offset to VMCS MSR bitmap       */
+#define	CTX_ARCH_MSRENT_OFF	192 /* offset to VM MSR load/save area */
+#define	CTX_ARCH_MSRHENT_OFF	200 /* offset to Host MSR load area    */
+#define	CTX_ARCH_MSRMAXENT_OFF	208 /* offset to maxnum MSR entries    */
+#define	CTX_ARCH_MSRMAXHENT_OFF	216 /* offset to maxnum Host MSR ents  */
+#define	CTX_ARCH_ARCHFLAGS_OFF	224 /* offset to arch specific flags   */
+#define	CTX_ARCH_IDTVECT_OFF	228 /* offset to IDT vector	       */
+#define	CTX_ARCH_IDTCODE_OFF	232 /* offset to IDT error code	       */
+#else
+#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer		*/
+#define CTX_ARCH_STATS_OFF	4   /* offset to ARCH_STATS		*/
+#define CTX_ARCH_IO_A_OFF	8   /* offset to *ioBitmapA		*/
+#define CTX_ARCH_IO_B_OFF	12  /* offset to *ioBitmapB		*/
+#define	CTX_ARCH_TINDEX_OFF	16  /* offset to tss index		*/
+#define	CTX_ARCH_TSS_OFF	20  /* offset to tss pointer		*/
+#define	CTX_ARCH_VEAX_OFF	24  /* offset to vmx EAX register save	*/
+#define	CTX_ARCH_VEBX_OFF	28  /* offset to vmx EBX register save	*/
+#define	CTX_ARCH_VECX_OFF	32  /* offset to vmx ECX register save	*/
+#define	CTX_ARCH_VEDX_OFF	36  /* offset to vmx EDX register save	*/
+#define	CTX_ARCH_VEDI_OFF	40  /* offset to vmx EDI register save	*/
+#define	CTX_ARCH_VESI_OFF	44  /* offset to vmx ESI register save	*/
+#define	CTX_ARCH_VEBP_OFF	48  /* offset to vmx EBP register save	*/
+#define	CTX_ARCH_VCR0_OFF	52  /* offset to vmx CR0 register save	*/
+#define	CTX_ARCH_VCR3_OFF	56  /* offset to vmx CR3 register save	*/
+#define	CTX_ARCH_VCR4_OFF	60  /* offset to vmx CR4 register save	*/
+#define	CTX_ARCH_MSRBMP_OFF	64  /* offset to VMCS MSR bitmap        */
+#define	CTX_ARCH_MSRENT_OFF	68  /* offset to VM MSR load/save area  */
+#define	CTX_ARCH_MSRHENT_OFF	72  /* offset to Host MSR load area     */
+#define	CTX_ARCH_MSRMAXENT_OFF	76  /* offset to maxnum MSR entries     */
+#define	CTX_ARCH_MSRMAXHENT_OFF	80  /* offset to maxnum Host MSR ents   */
+#define	CTX_ARCH_ARCHFLAGS_OFF	84  /* offset to arch specific flags    */
+#define	CTX_ARCH_IDTVECT_OFF	88  /* offset to IDT vector	        */
+#define	CTX_ARCH_IDTCODE_OFF	92  /* offset to IDT error code	        */
+#endif /* LP64 */
+
+/* arch specific flags */
+
+#define	ARCH_FLAG_INTRUN	0x01	/* interrupts running 		*/
+#define	ARCH_FLAG_IWIN		0x02	/* interrupt window exiting on	*/
+
+/* macros to locate stack boundaries (stacks grow down in x86) */
+
+#define	STACK_START_ADDR(begin, size)	((begin) + (size) - sizeof(int))
+#define	STACK_END_ADDR(begin, size)	(begin)
+
+#define	FRAMEBASESZ	8		/* minimum stack frame size */
+
+
+/* maximum number of entries in the GDT table */
+
+#define GDT_MAX_ENTRIES	64
+
+/* maximum number of entries in the IDT table */
+
+#define IDT_MAX_ENTRIES	256
+
+/* maximum number of entries in the TSS table */
+
+					/* maximum number of TSS structs    */
+#define TSS_MAX_ENTRIES		(32 + HY_MAX_CPU)
+#define TSS_HYPERVISOR_ENTRY	0	/* TSS entry used by the hypervisor */
+					/* first entry which we can use     */
+#define TSS_FIRST_CTX_ENTRY	HY_MAX_CPU
+
+/* GDT assignments */
+
+#define	CS_SYS_GDT_ENTRY	1	/* entry  1: code for the supervisor */
+#define	DS_SYS_GDT_ENTRY	2	/* entry  2: data for the supervisor */
+#define	CS_EXC_GDT_ENTRY	3	/* entry  3: code for exceptions     */
+#define	CS_INT_GDT_ENTRY	4	/* entry  4: code for interrupts     */
+#define	CS_CTX_GDT_ENTRY	5	/* entry  5: code for the user task  */
+#define	DS_CTX_GDT_ENTRY	6	/* entry  6: data for the user task  */
+#define	HY_TSS_GDT_ENTRY	7	/* entry  7: task state (hypervisor) */
+					/* entry  7+cpu: system call gate    */
+
+#ifdef	LP64
+/* In 64 bits mode, a system segment entry requires to GDT entry slots */
+
+#define	HY_SYS_SEG_ENTRY_SIZE	2
+#else	/* LP64 */
+#define	HY_SYS_SEG_ENTRY_SIZE	1
+#endif	/* LP64 */
+
+#define	HY_SYSCALL_GDT_ENTRY	(HY_TSS_GDT_ENTRY + \
+					(HY_SYS_SEG_ENTRY_SIZE * HY_MAX_CPU))
+					/* first entry we can use for TSS's  */
+#define	CTX_FIRST_GDT_ENTRY     (HY_SYSCALL_GDT_ENTRY + HY_SYS_SEG_ENTRY_SIZE)
+
+/*
+ * Context memory layout:
+ *
+ *         +---------------+ 0xFFFFFFFF
+ *         |               |
+ *         |               |
+ *         |    unused     |
+ *         |               |
+ *         +---------------+ 0xFFC0B000
+ *         |   Transition  |
+ *         |     Stack     |
+ *         +---------------+ 0xFFC0A000 (supv R/W)
+ *         |    System     |
+ *         |    Control    |
+ *         +---------------+ 0xFFC09000 (supv R/O)
+ *         |   Transition  |
+ *         |      Stub     |
+ *         | (syscall and  |
+ *         |  exceptions)  |
+ *         +---------------+ 0xFFC08000 (supv R/O)
+ *         |               |
+ *         |      TSS      |
+ *         |   Structures  |
+ *         |               |
+ *         +---------------+ 0xFFC02000 (supv R/O)
+ *         |               |
+ *         |      IDT      |
+ *         |               |
+ *         +---------------+ 0xFFC01000 (user R/O)
+ *         |               |
+ *         |      GDT      |
+ *         |               | 0xFFFC0000 (user R/O)
+ *         +---------------+
+ *         |               | 0xFFFBFFFF
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |    Context    |
+ *         |    Memory     |
+ *         |    Space      |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         |               |
+ *         +---------------+ 0x00000000
+ *
+ */
+
+/* maximum address useable by a VM context */
+
+#define	CTX_VADDR_MAX	0xFFFFFFFF - 0x00400000
+
+/*
+ * virtual address at which the GDT is mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_GDT	0xFFC00000
+
+/*
+ * virtual address at which the IDT is mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_IDT	0xFFC01000
+
+/*
+ * virtual address at which the TSS's are mapped (not used for Hypervisor
+ * context in 64-bits mode)
+ */
+
+#define	CTX_VADDR_TSS	0xFFC02000
+
+#if	!defined(USE_VTX)
+/* virtual address of the system call and exception stubs */
+
+#define	CTX_VADDR_STUBS	  0xFFC08000
+
+/* virtual address of the hypervisor x86 control page */
+
+#define	CTX_VADDR_SYSCTL  0xFFC09000
+
+/* virtual address of the system call stub */
+
+#define	CTX_VADDR_SYSCALL CTX_VADDR_STUBS
+#endif	/* USE_VTX */
+
+/*
+ * virtual address of the transition stack (not used for Hypervisor 
+ * memory context)
+ */
+
+#define	CTX_VADDR_TSTACK  0xFFC0A000
+
+/* hypervisor per-cpu storage area */
+
+#define	HY_VADDR_CPU_MEM	0xFF800000
+#define	HY_CPU_MEM_PAGES	8
+
+/* Maximum cache line size for the cpu */
+
+#define	_CPU_CACHE_ALIGN_SHIFT	5
+#undef	_CPU_CACHE_ALIGN_SIZE
+#define	_CPU_CACHE_ALIGN_SIZE	32
+
+/* Core interrupt vector assignments: */
+
+/* level 0:    0-15  (Intel assigned exception vectors) */
+/* level 1:   16-31  (Intel assigned exception vectors) */
+
+#define IN_DIVIDE_ERROR			 0
+#define IN_DEBUG			 1
+#define IN_NON_MASKABLE			 2
+#define IN_BREAKPOINT			 3
+#define IN_OVERFLOW			 4
+#define IN_BOUND			 5
+#define IN_INVALID_OPCODE		 6
+#define IN_NO_DEVICE			 7
+#define IN_DOUBLE_FAULT			 8
+#define IN_CP_OVERRUN			 9
+#define IN_INVALID_TSS			10
+#define IN_NO_SEGMENT			11
+#define IN_STACK_FAULT			12
+#define IN_PROTECTION_FAULT		13
+#define IN_PAGE_FAULT			14
+#define IN_RESERVED			15
+#define IN_CP_ERROR			16
+#define IN_ALIGNMENT			17
+#define IN_MACHINE_CHECK		18
+#define IN_SIMD				19
+
+/* level 2:   32-47  */
+/* level 3:   48-63  */
+
+#define IN_APIC_TIMER			32	/* local timer interrupt */
+
+#define X86_INT_VECTOR_BASE		40	/* IRQ vectors, 40-63 */
+
+/* Interrupt controller IRQ's */
+
+/* first I/O APIC (40-63) */
+
+#define	X86_IOAPIC0_VECTOR_BASE		 X86_INT_VECTOR_BASE
+
+#define IN_EXT_IRQ0			X86_IOAPIC0_VECTOR_BASE + 0
+#define IN_EXT_IRQ1			X86_IOAPIC0_VECTOR_BASE + 1
+#define IN_EXT_IRQ2			X86_IOAPIC0_VECTOR_BASE + 2
+#define IN_EXT_IRQ3			X86_IOAPIC0_VECTOR_BASE + 3
+#define IN_EXT_IRQ4			X86_IOAPIC0_VECTOR_BASE + 4
+#define IN_EXT_IRQ5			X86_IOAPIC0_VECTOR_BASE + 5
+#define IN_EXT_IRQ6			X86_IOAPIC0_VECTOR_BASE + 6
+#define IN_EXT_IRQ7			X86_IOAPIC0_VECTOR_BASE + 7
+#define IN_EXT_IRQ8			X86_IOAPIC0_VECTOR_BASE + 8
+#define IN_EXT_IRQ9			X86_IOAPIC0_VECTOR_BASE + 9
+#define IN_EXT_IRQ10			X86_IOAPIC0_VECTOR_BASE + 10
+#define IN_EXT_IRQ11			X86_IOAPIC0_VECTOR_BASE + 11
+#define IN_EXT_IRQ12			X86_IOAPIC0_VECTOR_BASE + 12
+#define IN_EXT_IRQ13			X86_IOAPIC0_VECTOR_BASE + 13
+#define IN_EXT_IRQ14			X86_IOAPIC0_VECTOR_BASE + 14
+#define IN_EXT_IRQ15			X86_IOAPIC0_VECTOR_BASE + 15
+#define IN_EXT_IRQ16			X86_IOAPIC0_VECTOR_BASE + 16
+#define IN_EXT_IRQ17			X86_IOAPIC0_VECTOR_BASE + 17
+#define IN_EXT_IRQ18			X86_IOAPIC0_VECTOR_BASE + 18
+#define IN_EXT_IRQ19			X86_IOAPIC0_VECTOR_BASE + 19
+#define IN_EXT_IRQ20			X86_IOAPIC0_VECTOR_BASE + 20
+#define IN_EXT_IRQ21			X86_IOAPIC0_VECTOR_BASE + 21
+#define IN_EXT_IRQ22			X86_IOAPIC0_VECTOR_BASE + 22
+#define IN_EXT_IRQ23			X86_IOAPIC0_VECTOR_BASE + 23
+
+/* level 4:   64-79  */
+/* level 5:   80-95  */
+
+/* second I/O APIC (64-87) */
+
+#define	X86_IOAPIC1_VECTOR_BASE		(X86_INT_VECTOR_BASE + 24)
+
+#define IN_EXT_IRQ24			X86_IOAPIC1_VECTOR_BASE + 0
+#define IN_EXT_IRQ25			X86_IOAPIC1_VECTOR_BASE + 1
+#define IN_EXT_IRQ26			X86_IOAPIC1_VECTOR_BASE + 2
+#define IN_EXT_IRQ27			X86_IOAPIC1_VECTOR_BASE + 3
+#define IN_EXT_IRQ28			X86_IOAPIC1_VECTOR_BASE + 4
+#define IN_EXT_IRQ29			X86_IOAPIC1_VECTOR_BASE + 5
+#define IN_EXT_IRQ30			X86_IOAPIC1_VECTOR_BASE + 6
+#define IN_EXT_IRQ31			X86_IOAPIC1_VECTOR_BASE + 7
+#define IN_EXT_IRQ32			X86_IOAPIC1_VECTOR_BASE + 8
+#define IN_EXT_IRQ33			X86_IOAPIC1_VECTOR_BASE + 9
+#define IN_EXT_IRQ34			X86_IOAPIC1_VECTOR_BASE + 10
+#define IN_EXT_IRQ35			X86_IOAPIC1_VECTOR_BASE + 11
+#define IN_EXT_IRQ36			X86_IOAPIC1_VECTOR_BASE + 12
+#define IN_EXT_IRQ37			X86_IOAPIC1_VECTOR_BASE + 13
+#define IN_EXT_IRQ38			X86_IOAPIC1_VECTOR_BASE + 14
+#define IN_EXT_IRQ39			X86_IOAPIC1_VECTOR_BASE + 15
+#define IN_EXT_IRQ40			X86_IOAPIC1_VECTOR_BASE + 16
+#define IN_EXT_IRQ41			X86_IOAPIC1_VECTOR_BASE + 17
+#define IN_EXT_IRQ42			X86_IOAPIC1_VECTOR_BASE + 18
+#define IN_EXT_IRQ43			X86_IOAPIC1_VECTOR_BASE + 19
+#define IN_EXT_IRQ44			X86_IOAPIC1_VECTOR_BASE + 20
+#define IN_EXT_IRQ45			X86_IOAPIC1_VECTOR_BASE + 21
+#define IN_EXT_IRQ46			X86_IOAPIC1_VECTOR_BASE + 22
+#define IN_EXT_IRQ47			X86_IOAPIC1_VECTOR_BASE + 23
+
+/* level 6:   96-111 */
+
+/* third I/O APIC (88-111) */
+
+#define	X86_IOAPIC2_VECTOR_BASE		(X86_INT_VECTOR_BASE + 48)
+
+#define IN_EXT_IRQ48			X86_IOAPIC2_VECTOR_BASE + 0
+#define IN_EXT_IRQ49			X86_IOAPIC2_VECTOR_BASE + 1
+#define IN_EXT_IRQ50			X86_IOAPIC2_VECTOR_BASE + 2
+#define IN_EXT_IRQ51			X86_IOAPIC2_VECTOR_BASE + 3
+#define IN_EXT_IRQ52			X86_IOAPIC2_VECTOR_BASE + 4
+#define IN_EXT_IRQ53			X86_IOAPIC2_VECTOR_BASE + 5
+#define IN_EXT_IRQ54			X86_IOAPIC2_VECTOR_BASE + 6
+#define IN_EXT_IRQ55			X86_IOAPIC2_VECTOR_BASE + 7
+#define IN_EXT_IRQ56			X86_IOAPIC2_VECTOR_BASE + 8
+#define IN_EXT_IRQ57			X86_IOAPIC2_VECTOR_BASE + 9
+#define IN_EXT_IRQ58			X86_IOAPIC2_VECTOR_BASE + 10
+#define IN_EXT_IRQ59			X86_IOAPIC2_VECTOR_BASE + 11
+#define IN_EXT_IRQ60			X86_IOAPIC2_VECTOR_BASE + 12
+#define IN_EXT_IRQ61			X86_IOAPIC2_VECTOR_BASE + 13
+#define IN_EXT_IRQ62			X86_IOAPIC2_VECTOR_BASE + 14
+#define IN_EXT_IRQ63			X86_IOAPIC2_VECTOR_BASE + 15
+#define IN_EXT_IRQ64			X86_IOAPIC2_VECTOR_BASE + 16
+#define IN_EXT_IRQ65			X86_IOAPIC2_VECTOR_BASE + 17
+#define IN_EXT_IRQ66			X86_IOAPIC2_VECTOR_BASE + 18
+#define IN_EXT_IRQ67			X86_IOAPIC2_VECTOR_BASE + 19
+#define IN_EXT_IRQ68			X86_IOAPIC2_VECTOR_BASE + 20
+#define IN_EXT_IRQ69			X86_IOAPIC2_VECTOR_BASE + 21
+#define IN_EXT_IRQ70			X86_IOAPIC2_VECTOR_BASE + 22
+#define IN_EXT_IRQ71			X86_IOAPIC2_VECTOR_BASE + 23
+
+/* level 7:  112-127 */
+/* level 8:  128-143 */
+
+/* fourth I/O APIC (112-135) */
+
+#define	X86_IOAPIC3_VECTOR_BASE		(X86_INT_VECTOR_BASE + 72)
+
+#define IN_EXT_IRQ72			X86_IOAPIC3_VECTOR_BASE + 0
+#define IN_EXT_IRQ73			X86_IOAPIC3_VECTOR_BASE + 1
+#define IN_EXT_IRQ74			X86_IOAPIC3_VECTOR_BASE + 2
+#define IN_EXT_IRQ75			X86_IOAPIC3_VECTOR_BASE + 3
+#define IN_EXT_IRQ76			X86_IOAPIC3_VECTOR_BASE + 4
+#define IN_EXT_IRQ77			X86_IOAPIC3_VECTOR_BASE + 5
+#define IN_EXT_IRQ78			X86_IOAPIC3_VECTOR_BASE + 6
+#define IN_EXT_IRQ79			X86_IOAPIC3_VECTOR_BASE + 7
+#define IN_EXT_IRQ80			X86_IOAPIC3_VECTOR_BASE + 8
+#define IN_EXT_IRQ81			X86_IOAPIC3_VECTOR_BASE + 9
+#define IN_EXT_IRQ82			X86_IOAPIC3_VECTOR_BASE + 10
+#define IN_EXT_IRQ83			X86_IOAPIC3_VECTOR_BASE + 11
+#define IN_EXT_IRQ84			X86_IOAPIC3_VECTOR_BASE + 12
+#define IN_EXT_IRQ85			X86_IOAPIC3_VECTOR_BASE + 13
+#define IN_EXT_IRQ86			X86_IOAPIC3_VECTOR_BASE + 14
+#define IN_EXT_IRQ87			X86_IOAPIC3_VECTOR_BASE + 15
+#define IN_EXT_IRQ88			X86_IOAPIC3_VECTOR_BASE + 16
+#define IN_EXT_IRQ89			X86_IOAPIC3_VECTOR_BASE + 17
+#define IN_EXT_IRQ90			X86_IOAPIC3_VECTOR_BASE + 18
+#define IN_EXT_IRQ91			X86_IOAPIC3_VECTOR_BASE + 19
+#define IN_EXT_IRQ92			X86_IOAPIC3_VECTOR_BASE + 20
+#define IN_EXT_IRQ93			X86_IOAPIC3_VECTOR_BASE + 21
+#define IN_EXT_IRQ94			X86_IOAPIC3_VECTOR_BASE + 22
+#define IN_EXT_IRQ95			X86_IOAPIC3_VECTOR_BASE + 23
+
+/* level 9:  144-159 */
+/* level 10: 160-175 */
+
+#define IN_MSI_START			144	/* first MSI interrupt */
+#define IN_MSI_END			175	/* last MSI interrupt */
+#define IN_MSI_VTD_IRQ                  IN_MSI_END /*JWU vtd fault reporting vector */
+
+/* level 11: 176-191 */
+/* level 12: 192-207 */
+
+#define IN_IGNORE			192	/* all interrupts to ignore */
+
+/* level 13: 208-223 */
+/* level 14: 224-239 */
+
+#define IN_IPI_CORE0			224	/* cross-call start, core 0 */
+#define IN_IPI_CORE1			225	/* cross-call start, core 1 */
+#define IN_IPI_CORE2			226	/* cross-call start, core 2 */
+#define IN_IPI_CORE3			227	/* cross-call start, core 3 */
+#define IN_IPI_CORE4			228	/* cross-call start, core 4 */
+#define IN_IPI_CORE5			229	/* cross-call start, core 5 */
+#define IN_IPI_CORE6			230	/* cross-call start, core 6 */
+#define IN_IPI_CORE7			231	/* cross-call start, core 7 */
+#define IN_IPI_CORE8			232	/* cross-call start, core 8 */
+#define IN_IPI_CORE9			233	/* cross-call start, core 9 */
+#define IN_IPI_CORE10			234	/* cross-call start, core 10 */
+#define IN_IPI_CORE11			235	/* cross-call start, core 11 */
+#define IN_IPI_CORE12			236	/* cross-call start, core 12 */
+#define IN_IPI_CORE13			237	/* cross-call start, core 13 */
+#define IN_IPI_CORE14			238	/* cross-call start, core 14 */
+#define IN_IPI_CORE15			239	/* cross-call start, core 15 */
+
+/* level 15: 240-255 */
+
+#define IN_IPI_DONE_CORE0		240	/* cross-call done, core 0 */
+#define IN_IPI_DONE_CORE1		241	/* cross-call done, core 1 */
+#define IN_IPI_DONE_CORE2		242	/* cross-call done, core 2 */
+#define IN_IPI_DONE_CORE3		243	/* cross-call done, core 3 */
+#define IN_IPI_DONE_CORE4		244	/* cross-call done, core 4 */
+#define IN_IPI_DONE_CORE5		245	/* cross-call done, core 5 */
+#define IN_IPI_DONE_CORE6		246	/* cross-call done, core 6 */
+#define IN_IPI_DONE_CORE7		247	/* cross-call done, core 7 */
+#define IN_IPI_DONE_CORE8		248	/* cross-call done, core 8 */
+#define IN_IPI_DONE_CORE9		249	/* cross-call done, core 9 */
+#define IN_IPI_DONE_CORE10		250	/* cross-call done, core 10 */
+#define IN_IPI_DONE_CORE11		251	/* cross-call done, core 11 */
+#define IN_IPI_DONE_CORE12		252	/* cross-call done, core 12 */
+#define IN_IPI_DONE_CORE13		253	/* cross-call done, core 13 */
+#define IN_IPI_DONE_CORE14		254	/* cross-call done, core 14 */
+#define IN_IPI_DONE_CORE15		255	/* cross-call done, core 15 */
+
+#define OUT_VIRTUAL_IRQ_START		300	/* base of virtual devices IRQ's */
+
+/* VT-x defines */
+
+#define	VMXON_REGION_NPAGES	1	/* number of 4KB pages for VMXON */
+#define	VMCS_REGION_NPAGES	1	/* number of 4KB pages for VMCS */
+
+/* network <-> host translations (for use by romfs) */
+
+#define ntohl(x)        ((((x) & 0x000000ff) << 24) | \
+                         (((x) & 0x0000ff00) <<  8) | \
+                         (((x) & 0x00ff0000) >>  8) | \
+                         (((x) & 0xff000000) >> 24))
+
+#define htonl(x)        ((((x) & 0x000000ff) << 24) | \
+                         (((x) & 0x0000ff00) <<  8) | \
+                         (((x) & 0x00ff0000) >>  8) | \
+                         (((x) & 0xff000000) >> 24))
+
+#define ntohs(x)        ((((x) & 0x00ff) << 8) | \
+                         (((x) & 0xff00) >> 8))
+
+#define htons(x)        ((((x) & 0x00ff) << 8) | \
+                         (((x) & 0xff00) >> 8))
+
+/* context virtual address start for the VB */
+
+#define CTX_VADDR_START 		0x0
+#define ARCH_VB_VMEM_ALIGN 		0x0
+#define ARCH_SUPERVISOR_SUPPORTED 	0
+
+/* macros for cpu core information */
+
+#define isCpuCoreAlive(x)\
+			(cpu_state[x].state == CPU_STATE_ONLINE ? 1 : 0)
+
+#define isCpuCorePresent(x)\
+			((x) < HY_MAX_CPU ? \
+			(cpuCoreMapping[x].present ? isCpuCoreAlive(x) : 0) : 0)
+
+/* macro which maps the numerical core id to the arch specific id */
+
+#define cpuCoreId(x)	     cpuCoreMapping[x].apicId
+
+/* macro which determines which interrupt to use when sending to core "x" */
+
+#define cpuCoreIpiNum(x)     (IN_IPI_CORE0 + cpuId)
+
+/* macro which determines which interrupt to use when done core "x" requests */
+
+#define cpuCoreIpiDoneNum(x) (IN_IPI_DONE_CORE0 + cpuId)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCx86Archh */
diff --git a/include/vbi/support/sys/x86/arch.h b/include/vbi/support/sys/x86/arch.h
deleted file mode 100644
index a807015..0000000
--- a/include/vbi/support/sys/x86/arch.h
+++ /dev/null
@@ -1,763 +0,0 @@
-/* sys/x86/arch.h - x86 architecture specific definitions */
-
-/*
- * Copyright (c) 2007-2009 Wind River Systems, Inc.
- *
- * The right to copy, distribute, modify or otherwise make use
- * of this software may be licensed only pursuant to the terms
- * of an applicable Wind River license agreement.
- */
-
-/*
-modification history
---------------------
-02w,24sep09,mmi  add virtual interrupts
-02v,01sep09,mmi  include interface.h
-02u,19aug09,md   add VBI register load/save region
-02t,28jul09,mpk  add cache align size
-02s,18jun09,dtr  Move excMgrId def here.
-02r,11jun09,md   add MSI interrupt space
-02q,09jun09,md   add support for additional I/O APICs
-02p,16jul09,dbt  Added vmx_cr4 registery in ARCH_INFO structure.
-02o,13jul09,dbt  Added x86Vb32IdtXxx() API prototypes.
-02n,10jul09,dbt  Added information about guest MMU mode (32 bits, 64bits,...).
-02m,03jul09,dbt  Added HY_TSS_GDT_ENTRY_SIZE macro.
-02l,30jun09,dbt  64-bits support.
-		 Added support for 32-bits VB GDT
-02k,25jun09,dbt  Updated bitClear prototype.
-02j,19jun09,dbt  Updated idtIntGateCreate() prototype for 64 bits support.
-02m,14jul09,rdd  VT-d integration
-02i,20may09,md   add byte order define
-02h,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
-02g,20apr09,mpk  context vaddr start
-02f,09mar09,md   add test and set function
-02e,13feb09,md   add per-cpu hypervisor TSS
-02d,20jan09,mmi  add VIOAPIC entries size
-02c,15jan09,md   add configuration options
-02b,20nov08,dtr  Remove vIoapic entries in ARCH_INFO.
-02a,18nov08,dbt  Added MSR area.
-01z,12nov08,md   fix isCpuCorePresent macro
-01y,28oct08,dbt  Added vtlbInit() prototype. Added vtlb_desc structure to
-                 ARCH_INFO.
-01x,27oct08,md   re-work multi-core ipi
-01w,17oct08,md   add ipi interrupt vector definitions
-01v,22sep08,md   add interrupt statistics
-01u,03sep08,md   update CPU_MAPPING to indicate if core is present
-01t,31jul08,md   add vmcs bitmap pointers
-01s,17jul08,md   add cpu mapping table
-01r,20may08,md   add multi-core support
-01q,19may08,gws  replace interrupt queues
-01p,23apr08,gws  macro rename
-01o,17apr08,gws  add macros for int vectors
-01n,14apr08,md   re-work interrupt delivery
-01m,27mar08,md   add pointer to queued interrupts
-01l,17mar08,md   add arch specific stats
-01k,07mar08,md   add cached copies of CR0 and CR3
-01j,04mar08,md   add FRAMEBASESZ
-01i,26feb08,md   add APIC timer interrupt
-01h,19feb08,md   add VT-x register save area
-01g,28jan08,md   add VT-x support
-01f,05oct07,md   add network/host translation functions
-01e,05sep07,md   clean up
-01d,30aug07,md   added IDT and syscall transition defines
-01c,31jul07,md   added gdtInit() and gdtTssCreate() prototypes
-01b,27jul07,md   added struct arch_info
-01a,06jul07,md   written.
-*/
-
-#ifndef __INCx86Archh
-#define __INCx86Archh
-
-#include <sys/regs.h>
-#include <sys/x86/vmx.h>
-#include <interface.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef LP64
-#define _WRS_PORTABLE_bLib
-#define _WRS_BLIB_ALIGNMENT     1       /* 2 byte alignment mask */
-#endif
-
-/* x86 uses little endian byte ordering */
-
-#define	__BYTE_ORDER	__LITTLE_ENDIAN
-
-/* maximum number of cpu's supported */
-
-#if defined(WRHV_INCLUDE_MULTI_CORE)
-# define HY_MAX_CPU		16
-#else
-# define HY_MAX_CPU		1
-#endif
-
-/* boot processor number */
-
-#define	HY_BOOT_CPU		0
-
-/* attribute declaration for cpu specific variable */
-
-#define	CPU_PRIVATE	__attribute__((__section__(".cpu_private")))
-
-/* interrupt related defines */
-
-#define	X86_MAX_VECTORS         256	/* maximum number of vectors */
-#define X86_MAX_INTERRUPTS      (X86_MAX_VECTORS - X86_INT_VECTOR_BASE)
-#define INT_QUEUE_DEPTH	5	/* per interrupt source */
-#define NUM_WDS_PER_ISR		(256 / 32)
-#define INT_QUEUE_OPTIMIZE
-#define ARCH_RESERVED_VECTORS   0x20
-
-/* VIOAPIC number of entries */
-
-#define VB_VIOAPIC_ENTRIES_SIZE		    64 
-
-#ifndef	_ASMLANGUAGE
-
-typedef long ptrdiff_t;
-
-/* per context interrupt statistics */
-
-typedef struct arch_int_stats {
-    uint32_t  intDeliverCount;		/* interrupt delivery count	   */
-    uint32_t  intAckCount;		/* interrupt acknowledge count	   */
-    } ARCH_INT_STATS;
-
-/* per context architecture specific statistics */
-
-typedef struct arch_stats {
-    uint32_t  VMexitCount[NUM_VM_EXITS]; /* per vm-exit count		   */
-    uint32_t  VMexitUnhandled;		 /* number of unhandled exits	   */
-					 /* interrupt stats		   */
-    ARCH_INT_STATS interrupt[X86_MAX_VECTORS];
-    } ARCH_STATS;
-
-/* queued interrupt information */
-
-typedef struct arch_int {
-    uint32_t	     intNum;	 	/* interrupt number to deliver	   */
-    uint32_t	     errorCode;	 	/* exrror code to push on stack	   */
-    struct arch_int *next;		/* pointer to next interrupt	   */
-    } ARCH_INT;
-
-/* Guest MMU mode */
-
-typedef enum arch_mmu_mmode
-    {
-    MMU32,			/* 32-bit MMU				*/
-    MMU32_PAE,			/* 32-bit MMU with PAE support		*/
-    MMU64			/* 64-bit MMU				*/
-    } ARCH_MMU_MODE;
-
-/* per context architecture specific information */
-
-typedef struct arch_info {
-    void       *vmcs;		/* pointer to VT-x VMCS data region	*/
-    ARCH_STATS *stats;		/* architecture specific statistics	*/
-    void       *ioBitmapA;	/* pointer to VMCS I/O bitmap A	   	*/
-    void       *ioBitmapB;	/* pointer to VMCS I/O bitmap B	   	*/
-
-    /* The portion of HREG_SET that is not saved in the VMCS: */
-
-#ifdef LP64
-    _RType	vmx_rax;	/* general register			*/
-    _RType	vmx_rbx;	/* general register			*/
-    _RType	vmx_rcx;	/* general register			*/
-    _RType	vmx_rdx;	/* general register			*/
-    _RType	vmx_rsp;	/* stack pointer register		*/
-    _RType	vmx_rbp;	/* frame pointer register		*/
-    _RType	vmx_rsi;	/* general register			*/
-    _RType	vmx_rdi;	/* general register			*/
-    _RType	vmx_r8;		/* general register			*/
-    _RType	vmx_r9;		/* general register			*/
-    _RType	vmx_r10;	/* general register			*/
-    _RType	vmx_r11;	/* general register			*/
-    _RType	vmx_r12;	/* general register			*/
-    _RType	vmx_r13;	/* general register			*/
-    _RType	vmx_r14;	/* general register			*/
-    _RType	vmx_r15;	/* general register			*/
-    _RType	vmx_cr0;	/* control register 0			*/
-    _RType	vmx_cr3;	/* control register 3			*/
-    _RType	vmx_cr4;	/* control register 4			*/
-#else
-    size_t	tssIndex;	/* entry this tss is using in the GDT  	*/
-    TSS	       *tss;		/* pointer to task state segment struct	*/
-    _RType	vmx_eax;	/* VMX saved general register		*/
-    _RType	vmx_ebx;	/* VMX saved general register		*/
-    _RType	vmx_ecx;	/* VMX saved general register		*/
-    _RType	vmx_edx;	/* VMX saved general register		*/
-    _RType	vmx_edi;	/* VMX saved general register		*/
-    _RType	vmx_esi;	/* VMX saved general register		*/
-    _RType	vmx_ebp;	/* VMX saved frame pointer register	*/
-    _RType	vmx_cr0;	/* VMX cached CR0 register value	*/
-    _RType	vmx_cr3;	/* VMX saved CR3 (page table) register	*/
-    _RType	vmx_cr4;	/* VMX cached CR0 register value */
-#endif
-
-    /* Intel VT-d IOMMU domain attributes */
-
-    uint32_t   iommu_domid;
-    uint32_t   iommu_transtype;
-    uint32_t   iommu_agaw;
-    void       *pageroot_maddr;
-
-    /* MSR management */
-
-    void       *msrBitmap;	/* pointer to VMCS MSR bitmap		*/
-    void       *msrEntries;	/* pointer to VM MSR load/save area	*/
-    void       *msrHostEntries;	/* pointer to Host MSR load area	*/
-    uint32_t	msrMaxEntries;	/* maximum number of MSR entries	*/
-    uint32_t	msrMaxHostEntries;/* maximum number of Host MSR entries	*/
-
-    uint32_t	archFlags;	/* 30: arch specific flags		*/
-    uint32_t	idtVector;	/* 34: IDT vectoring information	*/
-    uint32_t	idtCode;	/* 38: IDT vectoring error code		*/
-
-    /* VTLB stuff */
-
-    struct vtlb_desc *	pVtlbDesc;	/* VTLB context descriptor	*/
-    ARCH_MMU_MODE	mmuMode;	/* Guest MMU mode */
-
-    /* VBI interface register read/write cache area */
-
-    uint32_t	  vbiRegsValid;	/* registers values have been set	*/
-    VBI_HREG_SET  vbiRegs;	/* register values set by VBI API	*/
-
-    } ARCH_INFO;
-
-/* information for per-core architecture mapping */
-
-typedef struct cpu_core_mapping {
-    uint32_t present;
-    uint32_t apicId;
-} CPU_CORE_MAPPING;
-
-struct hy_ctx;
-
-/* arch specific functions */
-
-extern void gdtInit (void *addr);
-extern int  gdtTssCreate (uint32_t gdtNumber, TSS *pTss, uint32_t tssSize,
-			  uint32_t priv);
-extern int  gdtCallCreate (uint32_t gdtNumber, void *addr, uint32_t priv);
-extern int  gdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
-
-extern void idtInit (void *addr);
-extern int  idtTaskGateCreate (uint32_t idtNumber, uint32_t gdtEntry,
-			       uint32_t priv);
-extern int  idtIntGateCreate (uint32_t idtNumber, void *addr, uint32_t priv);
-
-extern void bitSet (void *addr, unsigned long position);
-extern void bitClear (void *addr, unsigned long position);
-extern void vtlbInit (struct hy_ctx * ctx);
-extern int  vtlbMmuOp (uint32_t op, uint32_t arg1,
-		       uint32_t arg2, uint32_t arg3);
-extern uint32_t testAndSet (void *addr);
-extern int	x86Guest32GdtEntryGet (uint32_t gdtNumber, GDT_ENTRY *gdtEntry);
-extern void *	x86Guest32GdtAddrGet (void);
-extern size_t	x86Guest32GdtSizeGet (void);
-extern size_t	x86Guest32GdtLimitGet (void);
-extern void *	x86Guest32IdtAddrGet (void);
-extern size_t	x86Guest32IdtSizeGet (void);
-extern size_t	x86Guest32IdtLimitGet (void);
-
-/* arch specific globals */
-
-extern CPU_CORE_MAPPING cpuCoreMapping[HY_MAX_CPU];
-extern ARCH_INT_STATS   cpuIntStats[HY_MAX_CPU][X86_MAX_VECTORS];
-CPU_PRIVATE extern ctx_t excMgrId;	/* exception mananger */
-
-#endif	/* _ASMLANGUAGE */
-
-/* struct arch_info offsets */
-
-#ifdef LP64
-#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer	       */
-#define CTX_ARCH_STATS_OFF	8   /* offset to ARCH_STATS	       */
-#define CTX_ARCH_IO_A_OFF	16  /* offset to *ioBitmapA	       */
-#define CTX_ARCH_IO_B_OFF	24  /* offset to *ioBitmapB	       */
-#define	CTX_ARCH_VRAX_OFF	32  /* offset to vmx RAX register save */
-#define	CTX_ARCH_VRBX_OFF	40  /* offset to vmx RBX register save */
-#define	CTX_ARCH_VRCX_OFF	48  /* offset to vmx RCX register save */
-#define	CTX_ARCH_VRDX_OFF	56  /* offset to vmx RDX register save */
-#define	CTX_ARCH_VRSP_OFF	64  /* offset to vmx RSP register save */
-#define	CTX_ARCH_VRBP_OFF	72  /* offset to vmx RBP register save */
-#define	CTX_ARCH_VRSI_OFF	80  /* offset to vmx RSI register save */
-#define	CTX_ARCH_VRDI_OFF	88  /* offset to vmx RDI register save */
-#define	CTX_ARCH_VR8_OFF	96  /* offset to vmx R8; register save */
-#define	CTX_ARCH_VR9_OFF	104 /* offset to vmx R9; register save */
-#define	CTX_ARCH_VR10_OFF	112 /* offset to vmx R10 register save */
-#define	CTX_ARCH_VR11_OFF	120 /* offset to vmx R11 register save */
-#define	CTX_ARCH_VR12_OFF	128 /* offset to vmx R12 register save */
-#define	CTX_ARCH_VR13_OFF	136 /* offset to vmx R13 register save */
-#define	CTX_ARCH_VR14_OFF	144 /* offset to vmx R14 register save */
-#define	CTX_ARCH_VR15_OFF	152 /* offset to vmx R15 register save */
-#define	CTX_ARCH_VCR0_OFF	160 /* offset to vmx CR0 register save */
-#define	CTX_ARCH_VCR3_OFF	168 /* offset to vmx CR3 register save */
-#define	CTX_ARCH_VCR4_OFF	176 /* offset to vmx CR4 register save */
-#define	CTX_ARCH_MSRBMP_OFF	184 /* offset to VMCS MSR bitmap       */
-#define	CTX_ARCH_MSRENT_OFF	192 /* offset to VM MSR load/save area */
-#define	CTX_ARCH_MSRHENT_OFF	200 /* offset to Host MSR load area    */
-#define	CTX_ARCH_MSRMAXENT_OFF	208 /* offset to maxnum MSR entries    */
-#define	CTX_ARCH_MSRMAXHENT_OFF	216 /* offset to maxnum Host MSR ents  */
-#define	CTX_ARCH_ARCHFLAGS_OFF	224 /* offset to arch specific flags   */
-#define	CTX_ARCH_IDTVECT_OFF	228 /* offset to IDT vector	       */
-#define	CTX_ARCH_IDTCODE_OFF	232 /* offset to IDT error code	       */
-#else
-#define	CTX_ARCH_VMCS_OFF	0   /* offset to VMCS pointer		*/
-#define CTX_ARCH_STATS_OFF	4   /* offset to ARCH_STATS		*/
-#define CTX_ARCH_IO_A_OFF	8   /* offset to *ioBitmapA		*/
-#define CTX_ARCH_IO_B_OFF	12  /* offset to *ioBitmapB		*/
-#define	CTX_ARCH_TINDEX_OFF	16  /* offset to tss index		*/
-#define	CTX_ARCH_TSS_OFF	20  /* offset to tss pointer		*/
-#define	CTX_ARCH_VEAX_OFF	24  /* offset to vmx EAX register save	*/
-#define	CTX_ARCH_VEBX_OFF	28  /* offset to vmx EBX register save	*/
-#define	CTX_ARCH_VECX_OFF	32  /* offset to vmx ECX register save	*/
-#define	CTX_ARCH_VEDX_OFF	36  /* offset to vmx EDX register save	*/
-#define	CTX_ARCH_VEDI_OFF	40  /* offset to vmx EDI register save	*/
-#define	CTX_ARCH_VESI_OFF	44  /* offset to vmx ESI register save	*/
-#define	CTX_ARCH_VEBP_OFF	48  /* offset to vmx EBP register save	*/
-#define	CTX_ARCH_VCR0_OFF	52  /* offset to vmx CR0 register save	*/
-#define	CTX_ARCH_VCR3_OFF	56  /* offset to vmx CR3 register save	*/
-#define	CTX_ARCH_VCR4_OFF	60  /* offset to vmx CR4 register save	*/
-#define	CTX_ARCH_MSRBMP_OFF	64  /* offset to VMCS MSR bitmap        */
-#define	CTX_ARCH_MSRENT_OFF	68  /* offset to VM MSR load/save area  */
-#define	CTX_ARCH_MSRHENT_OFF	72  /* offset to Host MSR load area     */
-#define	CTX_ARCH_MSRMAXENT_OFF	76  /* offset to maxnum MSR entries     */
-#define	CTX_ARCH_MSRMAXHENT_OFF	80  /* offset to maxnum Host MSR ents   */
-#define	CTX_ARCH_ARCHFLAGS_OFF	84  /* offset to arch specific flags    */
-#define	CTX_ARCH_IDTVECT_OFF	88  /* offset to IDT vector	        */
-#define	CTX_ARCH_IDTCODE_OFF	92  /* offset to IDT error code	        */
-#endif /* LP64 */
-
-/* arch specific flags */
-
-#define	ARCH_FLAG_INTRUN	0x01	/* interrupts running 		*/
-#define	ARCH_FLAG_IWIN		0x02	/* interrupt window exiting on	*/
-
-/* macros to locate stack boundaries (stacks grow down in x86) */
-
-#define	STACK_START_ADDR(begin, size)	((begin) + (size) - sizeof(int))
-#define	STACK_END_ADDR(begin, size)	(begin)
-
-#define	FRAMEBASESZ	8		/* minimum stack frame size */
-
-
-/* maximum number of entries in the GDT table */
-
-#define GDT_MAX_ENTRIES	64
-
-/* maximum number of entries in the IDT table */
-
-#define IDT_MAX_ENTRIES	256
-
-/* maximum number of entries in the TSS table */
-
-					/* maximum number of TSS structs    */
-#define TSS_MAX_ENTRIES		(32 + HY_MAX_CPU)
-#define TSS_HYPERVISOR_ENTRY	0	/* TSS entry used by the hypervisor */
-					/* first entry which we can use     */
-#define TSS_FIRST_CTX_ENTRY	HY_MAX_CPU
-
-/* GDT assignments */
-
-#define	CS_SYS_GDT_ENTRY	1	/* entry  1: code for the supervisor */
-#define	DS_SYS_GDT_ENTRY	2	/* entry  2: data for the supervisor */
-#define	CS_EXC_GDT_ENTRY	3	/* entry  3: code for exceptions     */
-#define	CS_INT_GDT_ENTRY	4	/* entry  4: code for interrupts     */
-#define	CS_CTX_GDT_ENTRY	5	/* entry  5: code for the user task  */
-#define	DS_CTX_GDT_ENTRY	6	/* entry  6: data for the user task  */
-#define	HY_TSS_GDT_ENTRY	7	/* entry  7: task state (hypervisor) */
-					/* entry  7+cpu: system call gate    */
-
-#ifdef	LP64
-/* In 64 bits mode, a system segment entry requires to GDT entry slots */
-
-#define	HY_SYS_SEG_ENTRY_SIZE	2
-#else	/* LP64 */
-#define	HY_SYS_SEG_ENTRY_SIZE	1
-#endif	/* LP64 */
-
-#define	HY_SYSCALL_GDT_ENTRY	(HY_TSS_GDT_ENTRY + \
-					(HY_SYS_SEG_ENTRY_SIZE * HY_MAX_CPU))
-					/* first entry we can use for TSS's  */
-#define	CTX_FIRST_GDT_ENTRY     (HY_SYSCALL_GDT_ENTRY + HY_SYS_SEG_ENTRY_SIZE)
-
-/*
- * Context memory layout:
- *
- *         +---------------+ 0xFFFFFFFF
- *         |               |
- *         |               |
- *         |    unused     |
- *         |               |
- *         +---------------+ 0xFFC0B000
- *         |   Transition  |
- *         |     Stack     |
- *         +---------------+ 0xFFC0A000 (supv R/W)
- *         |    System     |
- *         |    Control    |
- *         +---------------+ 0xFFC09000 (supv R/O)
- *         |   Transition  |
- *         |      Stub     |
- *         | (syscall and  |
- *         |  exceptions)  |
- *         +---------------+ 0xFFC08000 (supv R/O)
- *         |               |
- *         |      TSS      |
- *         |   Structures  |
- *         |               |
- *         +---------------+ 0xFFC02000 (supv R/O)
- *         |               |
- *         |      IDT      |
- *         |               |
- *         +---------------+ 0xFFC01000 (user R/O)
- *         |               |
- *         |      GDT      |
- *         |               | 0xFFFC0000 (user R/O)
- *         +---------------+
- *         |               | 0xFFFBFFFF
- *         |               |
- *         |               |
- *         |               |
- *         |    Context    |
- *         |    Memory     |
- *         |    Space      |
- *         |               |
- *         |               |
- *         |               |
- *         |               |
- *         |               |
- *         |               |
- *         |               |
- *         |               |
- *         +---------------+ 0x00000000
- *
- */
-
-/* maximum address useable by a VM context */
-
-#define	CTX_VADDR_MAX	0xFFFFFFFF - 0x00400000
-
-/*
- * virtual address at which the GDT is mapped (not used for Hypervisor
- * context in 64-bits mode)
- */
-
-#define	CTX_VADDR_GDT	0xFFC00000
-
-/*
- * virtual address at which the IDT is mapped (not used for Hypervisor
- * context in 64-bits mode)
- */
-
-#define	CTX_VADDR_IDT	0xFFC01000
-
-/*
- * virtual address at which the TSS's are mapped (not used for Hypervisor
- * context in 64-bits mode)
- */
-
-#define	CTX_VADDR_TSS	0xFFC02000
-
-#if	!defined(USE_VTX)
-/* virtual address of the system call and exception stubs */
-
-#define	CTX_VADDR_STUBS	  0xFFC08000
-
-/* virtual address of the hypervisor x86 control page */
-
-#define	CTX_VADDR_SYSCTL  0xFFC09000
-
-/* virtual address of the system call stub */
-
-#define	CTX_VADDR_SYSCALL CTX_VADDR_STUBS
-#endif	/* USE_VTX */
-
-/*
- * virtual address of the transition stack (not used for Hypervisor 
- * memory context)
- */
-
-#define	CTX_VADDR_TSTACK  0xFFC0A000
-
-/* hypervisor per-cpu storage area */
-
-#define	HY_VADDR_CPU_MEM	0xFF800000
-#define	HY_CPU_MEM_PAGES	8
-
-/* Maximum cache line size for the cpu */
-
-#define	_CPU_CACHE_ALIGN_SHIFT	5
-#undef	_CPU_CACHE_ALIGN_SIZE
-#define	_CPU_CACHE_ALIGN_SIZE	32
-
-/* Core interrupt vector assignments: */
-
-/* level 0:    0-15  (Intel assigned exception vectors) */
-/* level 1:   16-31  (Intel assigned exception vectors) */
-
-#define IN_DIVIDE_ERROR			 0
-#define IN_DEBUG			 1
-#define IN_NON_MASKABLE			 2
-#define IN_BREAKPOINT			 3
-#define IN_OVERFLOW			 4
-#define IN_BOUND			 5
-#define IN_INVALID_OPCODE		 6
-#define IN_NO_DEVICE			 7
-#define IN_DOUBLE_FAULT			 8
-#define IN_CP_OVERRUN			 9
-#define IN_INVALID_TSS			10
-#define IN_NO_SEGMENT			11
-#define IN_STACK_FAULT			12
-#define IN_PROTECTION_FAULT		13
-#define IN_PAGE_FAULT			14
-#define IN_RESERVED			15
-#define IN_CP_ERROR			16
-#define IN_ALIGNMENT			17
-#define IN_MACHINE_CHECK		18
-#define IN_SIMD				19
-
-/* level 2:   32-47  */
-/* level 3:   48-63  */
-
-#define IN_APIC_TIMER			32	/* local timer interrupt */
-
-#define X86_INT_VECTOR_BASE		40	/* IRQ vectors, 40-63 */
-
-/* Interrupt controller IRQ's */
-
-/* first I/O APIC (40-63) */
-
-#define	X86_IOAPIC0_VECTOR_BASE		 X86_INT_VECTOR_BASE
-
-#define IN_EXT_IRQ0			X86_IOAPIC0_VECTOR_BASE + 0
-#define IN_EXT_IRQ1			X86_IOAPIC0_VECTOR_BASE + 1
-#define IN_EXT_IRQ2			X86_IOAPIC0_VECTOR_BASE + 2
-#define IN_EXT_IRQ3			X86_IOAPIC0_VECTOR_BASE + 3
-#define IN_EXT_IRQ4			X86_IOAPIC0_VECTOR_BASE + 4
-#define IN_EXT_IRQ5			X86_IOAPIC0_VECTOR_BASE + 5
-#define IN_EXT_IRQ6			X86_IOAPIC0_VECTOR_BASE + 6
-#define IN_EXT_IRQ7			X86_IOAPIC0_VECTOR_BASE + 7
-#define IN_EXT_IRQ8			X86_IOAPIC0_VECTOR_BASE + 8
-#define IN_EXT_IRQ9			X86_IOAPIC0_VECTOR_BASE + 9
-#define IN_EXT_IRQ10			X86_IOAPIC0_VECTOR_BASE + 10
-#define IN_EXT_IRQ11			X86_IOAPIC0_VECTOR_BASE + 11
-#define IN_EXT_IRQ12			X86_IOAPIC0_VECTOR_BASE + 12
-#define IN_EXT_IRQ13			X86_IOAPIC0_VECTOR_BASE + 13
-#define IN_EXT_IRQ14			X86_IOAPIC0_VECTOR_BASE + 14
-#define IN_EXT_IRQ15			X86_IOAPIC0_VECTOR_BASE + 15
-#define IN_EXT_IRQ16			X86_IOAPIC0_VECTOR_BASE + 16
-#define IN_EXT_IRQ17			X86_IOAPIC0_VECTOR_BASE + 17
-#define IN_EXT_IRQ18			X86_IOAPIC0_VECTOR_BASE + 18
-#define IN_EXT_IRQ19			X86_IOAPIC0_VECTOR_BASE + 19
-#define IN_EXT_IRQ20			X86_IOAPIC0_VECTOR_BASE + 20
-#define IN_EXT_IRQ21			X86_IOAPIC0_VECTOR_BASE + 21
-#define IN_EXT_IRQ22			X86_IOAPIC0_VECTOR_BASE + 22
-#define IN_EXT_IRQ23			X86_IOAPIC0_VECTOR_BASE + 23
-
-/* level 4:   64-79  */
-/* level 5:   80-95  */
-
-/* second I/O APIC (64-87) */
-
-#define	X86_IOAPIC1_VECTOR_BASE		(X86_INT_VECTOR_BASE + 24)
-
-#define IN_EXT_IRQ24			X86_IOAPIC1_VECTOR_BASE + 0
-#define IN_EXT_IRQ25			X86_IOAPIC1_VECTOR_BASE + 1
-#define IN_EXT_IRQ26			X86_IOAPIC1_VECTOR_BASE + 2
-#define IN_EXT_IRQ27			X86_IOAPIC1_VECTOR_BASE + 3
-#define IN_EXT_IRQ28			X86_IOAPIC1_VECTOR_BASE + 4
-#define IN_EXT_IRQ29			X86_IOAPIC1_VECTOR_BASE + 5
-#define IN_EXT_IRQ30			X86_IOAPIC1_VECTOR_BASE + 6
-#define IN_EXT_IRQ31			X86_IOAPIC1_VECTOR_BASE + 7
-#define IN_EXT_IRQ32			X86_IOAPIC1_VECTOR_BASE + 8
-#define IN_EXT_IRQ33			X86_IOAPIC1_VECTOR_BASE + 9
-#define IN_EXT_IRQ34			X86_IOAPIC1_VECTOR_BASE + 10
-#define IN_EXT_IRQ35			X86_IOAPIC1_VECTOR_BASE + 11
-#define IN_EXT_IRQ36			X86_IOAPIC1_VECTOR_BASE + 12
-#define IN_EXT_IRQ37			X86_IOAPIC1_VECTOR_BASE + 13
-#define IN_EXT_IRQ38			X86_IOAPIC1_VECTOR_BASE + 14
-#define IN_EXT_IRQ39			X86_IOAPIC1_VECTOR_BASE + 15
-#define IN_EXT_IRQ40			X86_IOAPIC1_VECTOR_BASE + 16
-#define IN_EXT_IRQ41			X86_IOAPIC1_VECTOR_BASE + 17
-#define IN_EXT_IRQ42			X86_IOAPIC1_VECTOR_BASE + 18
-#define IN_EXT_IRQ43			X86_IOAPIC1_VECTOR_BASE + 19
-#define IN_EXT_IRQ44			X86_IOAPIC1_VECTOR_BASE + 20
-#define IN_EXT_IRQ45			X86_IOAPIC1_VECTOR_BASE + 21
-#define IN_EXT_IRQ46			X86_IOAPIC1_VECTOR_BASE + 22
-#define IN_EXT_IRQ47			X86_IOAPIC1_VECTOR_BASE + 23
-
-/* level 6:   96-111 */
-
-/* third I/O APIC (88-111) */
-
-#define	X86_IOAPIC2_VECTOR_BASE		(X86_INT_VECTOR_BASE + 48)
-
-#define IN_EXT_IRQ48			X86_IOAPIC2_VECTOR_BASE + 0
-#define IN_EXT_IRQ49			X86_IOAPIC2_VECTOR_BASE + 1
-#define IN_EXT_IRQ50			X86_IOAPIC2_VECTOR_BASE + 2
-#define IN_EXT_IRQ51			X86_IOAPIC2_VECTOR_BASE + 3
-#define IN_EXT_IRQ52			X86_IOAPIC2_VECTOR_BASE + 4
-#define IN_EXT_IRQ53			X86_IOAPIC2_VECTOR_BASE + 5
-#define IN_EXT_IRQ54			X86_IOAPIC2_VECTOR_BASE + 6
-#define IN_EXT_IRQ55			X86_IOAPIC2_VECTOR_BASE + 7
-#define IN_EXT_IRQ56			X86_IOAPIC2_VECTOR_BASE + 8
-#define IN_EXT_IRQ57			X86_IOAPIC2_VECTOR_BASE + 9
-#define IN_EXT_IRQ58			X86_IOAPIC2_VECTOR_BASE + 10
-#define IN_EXT_IRQ59			X86_IOAPIC2_VECTOR_BASE + 11
-#define IN_EXT_IRQ60			X86_IOAPIC2_VECTOR_BASE + 12
-#define IN_EXT_IRQ61			X86_IOAPIC2_VECTOR_BASE + 13
-#define IN_EXT_IRQ62			X86_IOAPIC2_VECTOR_BASE + 14
-#define IN_EXT_IRQ63			X86_IOAPIC2_VECTOR_BASE + 15
-#define IN_EXT_IRQ64			X86_IOAPIC2_VECTOR_BASE + 16
-#define IN_EXT_IRQ65			X86_IOAPIC2_VECTOR_BASE + 17
-#define IN_EXT_IRQ66			X86_IOAPIC2_VECTOR_BASE + 18
-#define IN_EXT_IRQ67			X86_IOAPIC2_VECTOR_BASE + 19
-#define IN_EXT_IRQ68			X86_IOAPIC2_VECTOR_BASE + 20
-#define IN_EXT_IRQ69			X86_IOAPIC2_VECTOR_BASE + 21
-#define IN_EXT_IRQ70			X86_IOAPIC2_VECTOR_BASE + 22
-#define IN_EXT_IRQ71			X86_IOAPIC2_VECTOR_BASE + 23
-
-/* level 7:  112-127 */
-/* level 8:  128-143 */
-
-/* fourth I/O APIC (112-135) */
-
-#define	X86_IOAPIC3_VECTOR_BASE		(X86_INT_VECTOR_BASE + 72)
-
-#define IN_EXT_IRQ72			X86_IOAPIC3_VECTOR_BASE + 0
-#define IN_EXT_IRQ73			X86_IOAPIC3_VECTOR_BASE + 1
-#define IN_EXT_IRQ74			X86_IOAPIC3_VECTOR_BASE + 2
-#define IN_EXT_IRQ75			X86_IOAPIC3_VECTOR_BASE + 3
-#define IN_EXT_IRQ76			X86_IOAPIC3_VECTOR_BASE + 4
-#define IN_EXT_IRQ77			X86_IOAPIC3_VECTOR_BASE + 5
-#define IN_EXT_IRQ78			X86_IOAPIC3_VECTOR_BASE + 6
-#define IN_EXT_IRQ79			X86_IOAPIC3_VECTOR_BASE + 7
-#define IN_EXT_IRQ80			X86_IOAPIC3_VECTOR_BASE + 8
-#define IN_EXT_IRQ81			X86_IOAPIC3_VECTOR_BASE + 9
-#define IN_EXT_IRQ82			X86_IOAPIC3_VECTOR_BASE + 10
-#define IN_EXT_IRQ83			X86_IOAPIC3_VECTOR_BASE + 11
-#define IN_EXT_IRQ84			X86_IOAPIC3_VECTOR_BASE + 12
-#define IN_EXT_IRQ85			X86_IOAPIC3_VECTOR_BASE + 13
-#define IN_EXT_IRQ86			X86_IOAPIC3_VECTOR_BASE + 14
-#define IN_EXT_IRQ87			X86_IOAPIC3_VECTOR_BASE + 15
-#define IN_EXT_IRQ88			X86_IOAPIC3_VECTOR_BASE + 16
-#define IN_EXT_IRQ89			X86_IOAPIC3_VECTOR_BASE + 17
-#define IN_EXT_IRQ90			X86_IOAPIC3_VECTOR_BASE + 18
-#define IN_EXT_IRQ91			X86_IOAPIC3_VECTOR_BASE + 19
-#define IN_EXT_IRQ92			X86_IOAPIC3_VECTOR_BASE + 20
-#define IN_EXT_IRQ93			X86_IOAPIC3_VECTOR_BASE + 21
-#define IN_EXT_IRQ94			X86_IOAPIC3_VECTOR_BASE + 22
-#define IN_EXT_IRQ95			X86_IOAPIC3_VECTOR_BASE + 23
-
-/* level 9:  144-159 */
-/* level 10: 160-175 */
-
-#define IN_MSI_START			144	/* first MSI interrupt */
-#define IN_MSI_END			175	/* last MSI interrupt */
-#define IN_MSI_VTD_IRQ                  IN_MSI_END /*JWU vtd fault reporting vector */
-
-/* level 11: 176-191 */
-/* level 12: 192-207 */
-
-#define IN_IGNORE			192	/* all interrupts to ignore */
-
-/* level 13: 208-223 */
-/* level 14: 224-239 */
-
-#define IN_IPI_CORE0			224	/* cross-call start, core 0 */
-#define IN_IPI_CORE1			225	/* cross-call start, core 1 */
-#define IN_IPI_CORE2			226	/* cross-call start, core 2 */
-#define IN_IPI_CORE3			227	/* cross-call start, core 3 */
-#define IN_IPI_CORE4			228	/* cross-call start, core 4 */
-#define IN_IPI_CORE5			229	/* cross-call start, core 5 */
-#define IN_IPI_CORE6			230	/* cross-call start, core 6 */
-#define IN_IPI_CORE7			231	/* cross-call start, core 7 */
-#define IN_IPI_CORE8			232	/* cross-call start, core 8 */
-#define IN_IPI_CORE9			233	/* cross-call start, core 9 */
-#define IN_IPI_CORE10			234	/* cross-call start, core 10 */
-#define IN_IPI_CORE11			235	/* cross-call start, core 11 */
-#define IN_IPI_CORE12			236	/* cross-call start, core 12 */
-#define IN_IPI_CORE13			237	/* cross-call start, core 13 */
-#define IN_IPI_CORE14			238	/* cross-call start, core 14 */
-#define IN_IPI_CORE15			239	/* cross-call start, core 15 */
-
-/* level 15: 240-255 */
-
-#define IN_IPI_DONE_CORE0		240	/* cross-call done, core 0 */
-#define IN_IPI_DONE_CORE1		241	/* cross-call done, core 1 */
-#define IN_IPI_DONE_CORE2		242	/* cross-call done, core 2 */
-#define IN_IPI_DONE_CORE3		243	/* cross-call done, core 3 */
-#define IN_IPI_DONE_CORE4		244	/* cross-call done, core 4 */
-#define IN_IPI_DONE_CORE5		245	/* cross-call done, core 5 */
-#define IN_IPI_DONE_CORE6		246	/* cross-call done, core 6 */
-#define IN_IPI_DONE_CORE7		247	/* cross-call done, core 7 */
-#define IN_IPI_DONE_CORE8		248	/* cross-call done, core 8 */
-#define IN_IPI_DONE_CORE9		249	/* cross-call done, core 9 */
-#define IN_IPI_DONE_CORE10		250	/* cross-call done, core 10 */
-#define IN_IPI_DONE_CORE11		251	/* cross-call done, core 11 */
-#define IN_IPI_DONE_CORE12		252	/* cross-call done, core 12 */
-#define IN_IPI_DONE_CORE13		253	/* cross-call done, core 13 */
-#define IN_IPI_DONE_CORE14		254	/* cross-call done, core 14 */
-#define IN_IPI_DONE_CORE15		255	/* cross-call done, core 15 */
-
-#define OUT_VIRTUAL_IRQ_START		300	/* base of virtual devices IRQ's */
-
-/* VT-x defines */
-
-#define	VMXON_REGION_NPAGES	1	/* number of 4KB pages for VMXON */
-#define	VMCS_REGION_NPAGES	1	/* number of 4KB pages for VMCS */
-
-/* network <-> host translations (for use by romfs) */
-
-#define ntohl(x)        ((((x) & 0x000000ff) << 24) | \
-                         (((x) & 0x0000ff00) <<  8) | \
-                         (((x) & 0x00ff0000) >>  8) | \
-                         (((x) & 0xff000000) >> 24))
-
-#define htonl(x)        ((((x) & 0x000000ff) << 24) | \
-                         (((x) & 0x0000ff00) <<  8) | \
-                         (((x) & 0x00ff0000) >>  8) | \
-                         (((x) & 0xff000000) >> 24))
-
-#define ntohs(x)        ((((x) & 0x00ff) << 8) | \
-                         (((x) & 0xff00) >> 8))
-
-#define htons(x)        ((((x) & 0x00ff) << 8) | \
-                         (((x) & 0xff00) >> 8))
-
-/* context virtual address start for the VB */
-
-#define CTX_VADDR_START 		0x0
-#define ARCH_VB_VMEM_ALIGN 		0x0
-#define ARCH_SUPERVISOR_SUPPORTED 	0
-
-/* macros for cpu core information */
-
-#define isCpuCoreAlive(x)\
-			(cpu_state[x].state == CPU_STATE_ONLINE ? 1 : 0)
-
-#define isCpuCorePresent(x)\
-			((x) < HY_MAX_CPU ? \
-			(cpuCoreMapping[x].present ? isCpuCoreAlive(x) : 0) : 0)
-
-/* macro which maps the numerical core id to the arch specific id */
-
-#define cpuCoreId(x)	     cpuCoreMapping[x].apicId
-
-/* macro which determines which interrupt to use when sending to core "x" */
-
-#define cpuCoreIpiNum(x)     (IN_IPI_CORE0 + cpuId)
-
-/* macro which determines which interrupt to use when done core "x" requests */
-
-#define cpuCoreIpiDoneNum(x) (IN_IPI_DONE_CORE0 + cpuId)
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __INCx86Archh */
-- 
1.6.3.3

