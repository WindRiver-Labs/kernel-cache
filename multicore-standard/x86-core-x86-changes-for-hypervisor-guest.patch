From 0f986fb333f9dd56888972d06452dafbc94f211c Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:14:05 -0400
Subject: [PATCH] x86: core x86 changes for hypervisor/guest

These changes represent the footprint of the guest implemention
into existing x86 kernel files.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/x86/Kconfig                       |    1 +
 arch/x86/kernel/Makefile               |    1 +
 arch/x86/kernel/alternative.c          |    3 ++
 arch/x86/kernel/asm-offsets_32.c       |   12 ++++++++++
 arch/x86/kernel/cpu/intel.c            |    8 +++++++
 arch/x86/kernel/cpu/mcheck/non-fatal.c |    3 ++
 arch/x86/kernel/e820.c                 |    5 ++++
 arch/x86/kernel/head_32.S              |   30 +++++++++++++++++++++++++
 arch/x86/kernel/i8237.c                |    8 ++++++-
 arch/x86/kernel/i8253.c                |    3 ++
 arch/x86/kernel/i8259.c                |    8 ++++++-
 arch/x86/kernel/kgdb.c                 |   15 +++++++++++++
 arch/x86/kernel/microcode.c            |    4 +++
 arch/x86/kernel/pci-dma.c              |   19 ++++++++++++++++
 arch/x86/kernel/pci-nommu.c            |   17 ++++++++++++++
 arch/x86/kernel/process.c              |   19 ++++++++++++++++
 arch/x86/kernel/ptrace.c               |    6 +++++
 arch/x86/kernel/setup.c                |   22 +++++++++++++++++-
 arch/x86/kernel/tlb_32.c               |   11 +++++++++
 arch/x86/kernel/tsc.c                  |    4 +++
 arch/x86/kernel/vmlinux_32.lds.S       |    8 +++++++
 arch/x86/mach-default/setup.c          |    3 +-
 include/asm-x86/dma-mapping.h          |   37 +++++++++++++++++++++++++++++--
 include/asm-x86/mmu_context_32.h       |    2 +
 24 files changed, 241 insertions(+), 8 deletions(-)

diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 8d5feb2..814f7f9 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -102,6 +102,9 @@
 #include <asm/percpu.h>
 #include <asm/topology.h>
 #include <asm/apicdef.h>
+#ifdef CONFIG_WRHV
+#include <asm/wrhv.h>
+#endif
 #ifdef CONFIG_X86_64
 #include <asm/numa_64.h>
 #endif
@@ -617,6 +629,9 @@ static struct dmi_system_id __initdata bad_bios_dmi_table[] = {
 
 void __init setup_arch(char **cmdline_p)
 {
+#ifdef CONFIG_WRHV
+	wrhv_boot_config();
+#endif
 #ifdef CONFIG_X86_32
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
 	visws_early_detect();
@@ -696,6 +710,9 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
 
+#ifdef CONFIG_WRHV
+	wrhv_init();
+#endif
 	parse_early_param();
 
 #ifdef CONFIG_X86_64
@@ -902,6 +918,11 @@ void __init setup_arch(char **cmdline_p)
 
 	e820_setup_gap();
+
+#ifdef CONFIG_WRHV
+	wrhv_calibrate_smp_cpus();
+#endif
+
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 31027aa..2fbfda3 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -17,6 +17,9 @@
 
 #include "cpu.h"
 
+#ifdef CONFIG_WRHV
+#include <asm/wrhv.h>
+#endif
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/mpspec.h>
 #include <asm/apic.h>
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 5e5d037..680886a 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -92,6 +92,7 @@ obj-$(CONFIG_DEBUG_NX_TEST)	+= test_nx.o
 obj-$(CONFIG_VMI)		+= vmi_32.o vmiclock_32.o
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o
 obj-$(CONFIG_KVM_CLOCK)		+= kvmclock.o
+obj-$(CONFIG_WRHV)		+= vbi/
 obj-$(CONFIG_PARAVIRT)		+= paravirt.o paravirt_patch_$(BITS).o
 obj-$(CONFIG_PARAVIRT_CLOCK)	+= pvclock.o
 
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index a84ac7b..f396193 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -345,8 +345,11 @@ void alternatives_smp_switch(int smp)
 	printk("lockdep: fixing up alternatives.\n");
 #endif
 
+#ifndef CONFIG_WRHV
 	if (noreplace_smp || smp_alt_once)
 		return;
+#endif
+
 	BUG_ON(!smp && (num_online_cpus() > 1));
 
 	mutex_lock(&smp_alt);
diff --git a/arch/x86/kernel/asm-offsets_32.c b/arch/x86/kernel/asm-offsets_32.c
index 77b6f0f..3ffc69b 100644
--- a/arch/x86/kernel/asm-offsets_32.c
+++ b/arch/x86/kernel/asm-offsets_32.c
@@ -21,6 +21,10 @@
 
 #include <xen/interface/xen.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/interface.h>
+#endif
+
 #include <linux/lguest.h>
 #include "../../../drivers/lguest/lg.h"
 
@@ -116,6 +120,14 @@ void foo(void)
 	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);
 #endif
 
+#ifdef CONFIG_WRHV
+	BLANK();
+	DEFINE(WRHV_VB_CONFIG_SIZE, sizeof(struct vb_config));
+	DEFINE(VB_MAX_BOOTLINE_LENGTH, VB_MAX_BOOTLINE_LENGTH);
+	OFFSET(WRHV_COREID_OFFSET, vb_config, coreId);
+	OFFSET(WRHV_BOOTLINE_OFFSET, vb_config, bootLine);
+#endif
+
 #ifdef CONFIG_XEN
 	BLANK();
 	OFFSET(XEN_vcpu_info_mask, vcpu_info, evtchn_upcall_mask);
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 31027aa..2fbfda3 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -32,6 +33,7 @@ struct movsl_mask movsl_mask __read_mostly;
 
 static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 {
+#ifndef CONFIG_WRHV
 	/* Unmask CPUID levels if masked: */
 	if (c->x86 == 6 && c->x86_model >= 15) {
 		u64 misc_enable;
@@ -44,6 +46,7 @@ static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 			c->cpuid_level = cpuid_eax(0);
 		}
 	}
+#endif
 
 	/* Netburst reports 64 bytes clflush size, but does IO in 128 bytes */
 	if (c->x86 == 15 && c->x86_cache_alignment == 64)
@@ -79,6 +82,7 @@ int __cpuinit ppro_with_ram_bug(void)
  */
 static void __cpuinit Intel_errata_workarounds(struct cpuinfo_x86 *c)
 {
+#ifndef CONFIG_WRHV
 	unsigned long lo, hi;
 
 	if ((c->x86 == 15) && (c->x86_model == 1) && (c->x86_mask == 1)) {
@@ -90,6 +94,10 @@ static void __cpuinit Intel_errata_workarounds(struct cpuinfo_x86 *c)
 			wrmsr (MSR_IA32_MISC_ENABLE, lo, hi);
 		}
 	}
+
+#else
+	wrhv_cpu_workarounds(c);
+#endif
 }
 
 
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 66e48aa..436bdf5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -237,9 +237,11 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	int old_nr, new_nr, chg_nr;
 	int i;
 
+#ifndef CONFIG_WRHV
 	/* if there's only one memory region, don't bother */
 	if (*pnr_map < 2)
 		return -1;
+#endif
 
 	old_nr = *pnr_map;
 	BUG_ON(old_nr > max_nr_map);
@@ -1293,6 +1295,9 @@ void __init e820_reserve_resources(void)
 
 	for (i = 0; i < e820_saved.nr_map; i++) {
 		struct e820entry *entry = &e820_saved.map[i];
+#ifdef CONFIG_WRHV
+		if (entry->size > 0)
+#endif
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size - 1,
 			e820_type_to_string(entry->type));
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index a7010c3..a1e7d70 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -83,10 +83,13 @@ INIT_MAP_BEYOND_END = BOOTBITMAP_SIZE + (PAGE_TABLE_SIZE + ALLOCATOR_SLOP)*PAGE_
  */
 .section .text.head,"ax",@progbits
 ENTRY(startup_32)
+
+#ifndef CONFIG_WRHV
 	/* test KEEP_SEGMENTS flag to see if the bootloader is asking
 		us to not reload segments */
 	testb $(1<<6), BP_loadflags(%esi)
 	jnz 2f
+#endif
 
 /*
  * Set segments to known values.
@@ -98,6 +101,13 @@ ENTRY(startup_32)
 	movl %eax,%fs
 	movl %eax,%gs
 2:
+#if defined(CONFIG_WRHV) && defined(CONFIG_SMP)
+	movl 0x4(%esp), %esi
+	movl WRHV_COREID_OFFSET(%esi), %eax
+	cmpl $0,%eax
+	jne startup_32_smp
+#endif
+
 
 /*
  * Clear BSS first so that there are no surprises...
@@ -117,6 +127,7 @@ ENTRY(startup_32)
  * (kexec on panic case). Hence copy out the parameters before initializing
  * page tables.
  */
+#ifndef CONFIG_WRHV
 	movl $pa(boot_params),%edi
 	movl $(PARAM_SIZE/4),%ecx
 	cld
@@ -162,6 +173,25 @@ subarch_entries:
 num_subarch_entries = (. - subarch_entries) / 4
 .previous
 #endif /* CONFIG_PARAVIRT */
+#else  /* CONFIG_WRHV */
+	/* Copy over the wrhv config, it's assumed the stack hasn't been fiddled with yet */
+	movl 0x4(%esp), %esi
+	/* Store the address of wrhv config so we can map it in later */
+	movl %esi, pa(_wr_config)
+	movl $pa(__wr_config), %edi
+	movl $(WRHV_VB_CONFIG_SIZE/4),%ecx
+	cld
+	rep
+	movsl
+
+	/* Fill in the boot command line */
+	movl $pa(__wr_config + WRHV_BOOTLINE_OFFSET), %esi
+	movl $pa(boot_command_line),%edi
+	movl $(VB_MAX_BOOTLINE_LENGTH/4),%ecx
+	rep
+	movsl
+#endif
+
 
 /*
  * Initialize page tables.  This creates a PDE and a set of page
diff --git a/arch/x86/kernel/kgdb.c b/arch/x86/kernel/kgdb.c
index 25ca4f5..676a274 100644
--- a/arch/x86/kernel/kgdb.c
+++ b/arch/x86/kernel/kgdb.c
@@ -330,6 +330,15 @@ void kgdb_post_primary_code(struct pt_regs *regs, int e_vector, int err_code)
 }
 
 #ifdef CONFIG_SMP
+
+#ifdef CONFIG_WRHV
+static int kgdb_call_nmi_hook(struct pt_regs *regs)
+{
+       kgdb_nmicallback(raw_smp_processor_id(), regs);
+       return 0;
+}
+#endif
+
 /**
  *	kgdb_roundup_cpus - Get other CPUs into a holding pattern
  *	@flags: Current IRQ state
@@ -348,7 +357,13 @@ void kgdb_post_primary_code(struct pt_regs *regs, int e_vector, int err_code)
  */
 void kgdb_roundup_cpus(unsigned long flags)
 {
+#ifdef CONFIG_WRHV
+	local_irq_enable();
+	smp_call_function(kgdb_call_nmi_hook, NULL, 0);
+	local_irq_disable();
+#else
 	send_IPI_allbutself(APIC_DM_NMI);
+#endif
 }
 #endif
 
diff --git a/arch/x86/kernel/microcode.c b/arch/x86/kernel/microcode.c
index 652fa5c..545bb29 100644
--- a/arch/x86/kernel/microcode.c
+++ b/arch/x86/kernel/microcode.c
@@ -810,6 +810,10 @@ static int __init microcode_init (void)
 {
 	int error;
 
+#ifdef CONFIG_WRHV
+	return -1;
+#endif
+
 	printk(KERN_INFO
 		"IA-32 Microcode Update Driver: v" MICROCODE_VERSION " <tigran@aivazian.fsnet.co.uk>\n");
 
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index 876e918..c663815 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -9,6 +9,10 @@
 #include <linux/clockchips.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#endif
+
 unsigned long idle_halt;
 EXPORT_SYMBOL(idle_halt);
 unsigned long idle_nomwait;
@@ -177,6 +181,16 @@ static void mwait_idle(void)
 		local_irq_enable();
 }
 
+#ifdef CONFIG_WRHV
+static void wrhv_idle(void)
+{
+	if (!need_resched()) {
+		local_irq_enable();
+		vbi_idle(1);
+	}
+}
+#endif
+
 /*
  * On SMP it's slightly faster (but much more power-consuming!)
  * to poll the ->work.need_resched flag instead of waiting for the
@@ -363,6 +377,11 @@ static int __init idle_setup(char *str)
 		 */
 		idle_nomwait = 1;
 		return 0;
+#ifdef CONFIG_WRHV
+	} else if (!strncmp(str, "wrhv", 5)) {
+		printk("using hypercall in idle threads\n");
+		pm_idle = wrhv_idle;
+#endif
 	} else
 		return -1;
 
diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c
index 5625407..ad4aa4f 100644
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@ -896,8 +896,14 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 			tmp = getreg(child, addr);
 		else if (addr >= offsetof(struct user, u_debugreg[0]) &&
 			 addr <= offsetof(struct user, u_debugreg[7])) {
+#ifdef CONFIG_WRHV
+			ret = -EIO;
+			break;
+#else
+
 			addr -= offsetof(struct user, u_debugreg[0]);
 			tmp = ptrace_get_debugreg(child, addr / sizeof(data));
+#endif
 		}
 		ret = put_user(tmp, datap);
 		break;
diff --git a/arch/x86/kernel/tlb_32.c b/arch/x86/kernel/tlb_32.c
index 592b9c0..08997b3 100644
--- a/arch/x86/kernel/tlb_32.c
+++ b/arch/x86/kernel/tlb_32.c
@@ -3,6 +3,11 @@
 #include <linux/interrupt.h>
 #include <trace/irq.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#include <asm/wrhv.h>
+#endif
+
 #include <asm/tlbflush.h>
 
 
@@ -38,6 +43,12 @@ void leave_mm(int cpu)
 {
 	if (per_cpu(cpu_tlbstate, cpu).state == TLBSTATE_OK)
 		BUG();
+
+#ifdef CONFIG_WRHV
+	wrhv_vtlb_op(VBI_VTLB_OP_DELETE_PMD,
+		     __pa(per_cpu(cpu_tlbstate, cpu).active_mm->pgd), 0, 0);
+#endif
+
 	cpu_clear(cpu, per_cpu(cpu_tlbstate, cpu).active_mm->cpu_vm_mask);
 	load_cr3(swapper_pg_dir);
 }
diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index de850e9..730641e 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -514,8 +514,12 @@ static struct clocksource clocksource_tsc = {
 	.read                   = read_tsc,
 	.mask                   = CLOCKSOURCE_MASK(64),
 	.shift                  = 22,
+#ifdef CONFIG_WRHV
+	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS, 
+#else
 	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS |
 				  CLOCK_SOURCE_MUST_VERIFY,
+#endif
 #ifdef CONFIG_X86_64
 	.vread                  = vread_tsc,
 #endif
diff --git a/arch/x86/kernel/vmlinux_32.lds.S b/arch/x86/kernel/vmlinux_32.lds.S
index 9d8dba8..f974e0e 100644
--- a/arch/x86/kernel/vmlinux_32.lds.S
+++ b/arch/x86/kernel/vmlinux_32.lds.S
@@ -177,6 +177,14 @@ SECTIONS
 	__initramfs_end = .;
   }
 #endif
+#if defined(CONFIG_WRHV)
+  . = ALIGN(4096);
+  .initrd : {
+	__initrd_start = .;
+	*(.initrd)
+	__initrd_end = .;
+  }
+#endif
   . = ALIGN(PAGE_SIZE);
   .data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) {
 	__per_cpu_start = .;
diff --git a/include/asm-x86/dma-mapping.h b/include/asm-x86/dma-mapping.h
index ad9cd6d..ee4413d 100644
--- a/include/asm-x86/dma-mapping.h
+++ b/include/asm-x86/dma-mapping.h
@@ -10,6 +10,12 @@
 #include <asm/io.h>
 #include <asm/swiotlb.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/interface.h>
+#include <vbi/vbi.h>
+#endif
+
+
 extern dma_addr_t bad_dma_address;
 extern int iommu_merge;
 extern struct device fallback_dev;
@@ -102,10 +108,24 @@ static inline dma_addr_t
 dma_map_single(struct device *hwdev, void *ptr, size_t size,
 	       int direction)
 {
+	phys_addr_t paddr;
+
 	struct dma_mapping_ops *ops = get_dma_ops(hwdev);
 
 	BUG_ON(!valid_dma_direction(direction));
-	return ops->map_single(hwdev, virt_to_phys(ptr), size, direction);
+
+#ifdef CONFIG_WRHV
+	if (paravirt_enabled()) {
+		u64 tmp_paddr;
+		if (vbi_get_guest_dma_addr((void *)virt_to_phys(ptr),
+						&tmp_paddr) != 0)
+			return -1;
+		else
+			paddr = (phys_addr_t)tmp_paddr;
+	} else
+#endif
+	paddr = virt_to_phys(ptr);
+	return ops->map_single(hwdev, paddr, size, direction);
 }
 
 static inline void
@@ -220,11 +240,22 @@ static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
 				      size_t offset, size_t size,
 				      int direction)
 {
+	phys_addr_t paddr;
 	struct dma_mapping_ops *ops = get_dma_ops(dev);
 
 	BUG_ON(!valid_dma_direction(direction));
-	return ops->map_single(dev, page_to_phys(page) + offset,
-			       size, direction);
+#ifdef CONFIG_WRHV
+	if (paravirt_enabled()) {
+		u64 tmp_paddr;
+		if (vbi_get_guest_dma_addr((void *)page_to_phys(page),
+						 &tmp_paddr) == 0)
+			paddr = (phys_addr_t)tmp_paddr + offset;
+		else
+			return -1;
+	} else
+#endif
+	paddr = page_to_phys(page) + offset;
+	return ops->map_single(dev, paddr, size, direction);
 }
 
 static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
diff --git a/include/asm-x86/mmu_context_32.h b/include/asm-x86/mmu_context_32.h
index 824fc57..cf4d7d1 100644
--- a/include/asm-x86/mmu_context_32.h
+++ b/include/asm-x86/mmu_context_32.h
@@ -18,7 +18,9 @@ static inline void switch_mm(struct mm_struct *prev,
 
 	if (likely(prev != next)) {
 		/* stop flush ipis for the previous mm */
+#if !defined(CONFIG_WRHV)
 		cpu_clear(cpu, prev->cpu_vm_mask);
+#endif
 #ifdef CONFIG_SMP
 		per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;
 		per_cpu(cpu_tlbstate, cpu).active_mm = next;
-- 
1.6.5.2

diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c
index 87d4d69..1fec06f 100644
--- a/arch/x86/kernel/pci-dma.c
+++ b/arch/x86/kernel/pci-dma.c
@@ -3,6 +3,11 @@
 #include <linux/bootmem.h>
 #include <linux/pci.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/interface.h>
+#include <vbi/vbi.h>
+#endif
+
 #include <asm/proto.h>
 #include <asm/dma.h>
 #include <asm/iommu.h>
@@ -336,6 +341,18 @@ dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,
 
 		memset(memory, 0, size);
 		if (!mmu) {
+#ifdef CONFIG_WRHV
+			u64 paddr;
+
+			if (vbi_get_guest_dma_addr((void *)bus, &paddr) == 0)
+				*dma_handle = (dma_addr_t)paddr;
+			else {
+				free_pages((unsigned long)memory,
+				   			get_order(size));
+				return NULL;
+			}
+#else
 			*dma_handle = bus;
+#endif
 			return memory;
 		}
diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c
index 3f91f71..b00fbbe 100644
--- a/arch/x86/kernel/pci-nommu.c
+++ b/arch/x86/kernel/pci-nommu.c
@@ -7,6 +7,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/interface.h>
+#include <vbi/vbi.h>
+#endif
+
+
 #include <asm/iommu.h>
 #include <asm/processor.h>
 #include <asm/dma.h>
@@ -63,6 +69,18 @@ static int nommu_map_sg(struct device *hwdev, struct scatterlist *sg,
 
 	for_each_sg(sg, s, nents, i) {
 		BUG_ON(!sg_page(s));
+#ifdef CONFIG_WRHV
+		{
+			u64 paddr;
+			dma_addr_t addr = sg_phys(s);
+
+			if (vbi_get_guest_dma_addr((void *)addr, &paddr) == 0)
+				s->dma_address = (dma_addr_t)paddr;
+			else
+				s->dma_address = -1;
+		}
+#else
 		s->dma_address = sg_phys(s);
+#endif
 		if (!check_addr("map_sg", hwdev, s->dma_address, s->length))
 			return 0;
diff --git a/arch/x86/mach-default/setup.c b/arch/x86/mach-default/setup.c
index 3d31783..36854ab 100644
--- a/arch/x86/mach-default/setup.c
+++ b/arch/x86/mach-default/setup.c
@@ -9,6 +9,7 @@
 #include <asm/arch_hooks.h>
 #include <asm/e820.h>
 #include <asm/setup.h>
+#include <asm/wrhv.h>	/* for TIMER_INT_NUM, used for WRHV and !WRHV */
 
 #ifdef CONFIG_HOTPLUG_CPU
 #define DEFAULT_SEND_IPI	(1)
@@ -132,7 +133,7 @@ void __init time_init_hook(void)
 	}
 
 	irq0.mask = cpumask_of_cpu(0);
-	setup_irq(0, &irq0);
+	setup_irq(TIMER_INT_NUM, &irq0);
 }
 
 #ifdef CONFIG_MCA
