From 25044be1b496f3cb453400d918f1b56e233d9991 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:16:53 -0400
Subject: [PATCH 11/19] powerpc: introduce paravirt ops for hypervisor/guest

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/powerpc/include/asm/paravirt.h         |   84 +++++++++
 arch/powerpc/include/asm/pv_dma-mapping.h   |   78 +++++++++
 arch/powerpc/include/asm/pv_hw_irq.h        |   65 +++++++
 arch/powerpc/include/asm/pv_pgtable-ppc32.h |  131 ++++++++++++++
 arch/powerpc/include/asm/reg_paravirt.h     |   22 +++
 arch/powerpc/kernel/paravirt.c              |  247 +++++++++++++++++++++++++++
 arch/powerpc/kernel/paravirt_entry_32.S     |   34 ++++
 arch/powerpc/kernel/paravirt_misc_32.S      |   36 ++++
 8 files changed, 697 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/include/asm/paravirt.h
 create mode 100644 arch/powerpc/include/asm/pv_dma-mapping.h
 create mode 100644 arch/powerpc/include/asm/pv_hw_irq.h
 create mode 100644 arch/powerpc/include/asm/pv_pgtable-ppc32.h
 create mode 100644 arch/powerpc/include/asm/reg_paravirt.h
 create mode 100644 arch/powerpc/kernel/paravirt.c
 create mode 100644 arch/powerpc/kernel/paravirt_entry_32.S
 create mode 100644 arch/powerpc/kernel/paravirt_misc_32.S

diff --git a/arch/powerpc/include/asm/paravirt.h b/arch/powerpc/include/asm/paravirt.h
new file mode 100644
index 0000000..a8a6fd7
--- /dev/null
+++ b/arch/powerpc/include/asm/paravirt.h
@@ -0,0 +1,84 @@
+#ifndef __ASM_PARAVIRT_H
+#define __ASM_PARAVIRT_H
+
+#ifdef CONFIG_PARAVIRT
+/* 
+ * native functions 
+ */
+extern void native_do_IRQ(struct pt_regs *regs);
+extern unsigned int native_irq_of_parse_and_map(struct device_node *dev, int index);
+extern unsigned int native_get_pvr(void);
+extern void native_timer_interrupt(struct pt_regs * regs);
+extern void __init native_time_init(void);
+extern void __init native_clocksource_init(void);
+extern void native_vmmu_restore (void);
+extern void __init native_MMU_init_hw(void);
+extern unsigned long __init native_mmu_mapin_ram(void);
+extern void native_MMU_setup(void);
+extern void __init native_MMU_init(void);
+extern void native_flush_dcache_page(struct page *page);
+extern void native_update_mmu_cache(struct vm_area_struct *vma, unsigned long address,
+				pte_t pte);
+extern int native_map_page(unsigned long va, phys_addr_t pa, int flags);
+extern int native_kgdb_arch_handle_exception(int vector, int signo, int err_code,
+                               char *remcom_in_buffer, char *remcom_out_buffer,
+                               struct pt_regs *linux_regs);
+extern int __init native_gfar_of_init(void);
+extern void __kprobes native_DebugException(struct pt_regs *regs, unsigned long debug_status);
+extern int paravirt_kgdb_arch_handle_exception(int vector, int signo, int err_code,
+                               char *remcom_in_buffer, char *remcom_out_buffer,
+                               struct pt_regs *linux_regs);
+
+/*
+ * paravirtual operations structure 
+ */
+struct pv_time_ops {
+	void (*hw_time_init)(void);
+	void (*hw_timer_interrupt)(struct pt_regs *regs);
+	void (*hw_clocksource_init)(void);
+};
+
+struct pv_cpu_ops {
+	unsigned int (*get_pvr)(void);
+	int (*gfar_of_init)(void);
+	void (*DebugException)(struct pt_regs *regs, unsigned long debug_status);
+	int (*kgdb_arch_handle_exception)(int vector, int signo, int err_code,
+                               char *remcom_in_buffer, char *remcom_out_buffer,
+                               struct pt_regs *linux_regs);
+};
+
+struct pv_irq_ops {
+	void (*do_IRQ)(struct pt_regs *regs);
+	unsigned int (*irq_of_parse_and_map)
+		(struct device_node *dev, int index);
+};
+
+struct pv_apic_ops {
+	unsigned int (*get_irq)(void);
+	void (*do_irq)(struct pt_regs *regs);
+	int (*get_ppc_spurious_interrupts)(void);
+	void (*set_ppc_spurious_interrupts)(int value);
+	unsigned int (*irq_of_parse_and_map)
+		(struct device_node *dev, int index);
+
+};
+
+struct pv_mmu_ops {
+	void (*vmmu_restore)(void);
+	void (*MMU_init_hw)(void);
+	unsigned long (*mmu_mapin_ram)(void);
+	void (*MMU_setup)(void);
+	void (*MMU_init)(void);
+	void (*flush_dcache_page)(struct page *page);
+	void (*update_mmu_cache)(struct vm_area_struct *vma, 
+			unsigned long address, pte_t pte);
+	int (*map_page)(unsigned long va, phys_addr_t pa, int flags);
+};
+
+extern struct pv_time_ops pv_time_ops;
+extern struct pv_cpu_ops pv_cpu_ops;
+extern struct pv_irq_ops pv_irq_ops;
+extern struct pv_mmu_ops pv_mmu_ops;
+
+#endif /* CONFIG_PARAVIRT */
+#endif	/* __ASM_PARAVIRT_H */
diff --git a/arch/powerpc/include/asm/pv_dma-mapping.h b/arch/powerpc/include/asm/pv_dma-mapping.h
new file mode 100644
index 0000000..bd148ed
--- /dev/null
+++ b/arch/powerpc/include/asm/pv_dma-mapping.h
@@ -0,0 +1,78 @@
+#ifndef _ASM_PV_DMA_MAPPING_H
+#define _ASM_PV_DMA_MAPPING_H
+
+/* default native inline */
+#define dma_alloc_coherent	native_dma_alloc_coherent
+#define dma_map_single		native_dma_map_single
+
+/* redefine hypervisor specific inline */
+#ifdef CONFIG_WRHV
+#undef dma_alloc_coherent
+#undef dma_map_single
+
+#define dma_alloc_coherent	paravirt_dma_alloc_coherent
+#define dma_map_single		paravirt_dma_map_single
+
+#include <vbi/vbiPaddr.h>
+
+static inline void *paravirt_dma_alloc_coherent(struct device *dev, size_t size,
+                                       dma_addr_t * dma_handle,
+                                       gfp_t gfp)
+{
+#ifdef CONFIG_NOT_COHERENT_CACHE
+        return __dma_alloc_coherent(size, dma_handle, gfp);
+#else
+        void *ret;
+        /* ignore region specifiers */
+        gfp &= ~(__GFP_DMA | __GFP_HIGHMEM);
+
+        if (dev == NULL || dev->coherent_dma_mask < 0xffffffff)
+                gfp |= GFP_DMA;
+
+        ret = (void *)__get_free_pages(gfp, get_order(size));
+
+        if (ret != NULL) {
+#ifdef CONFIG_WRHV
+                u64 paddr;
+#endif /* CONFIG_WRHV */
+                memset(ret, 0, size);
+#ifdef CONFIG_WRHV
+                if (vbiGuestDmaAddrGet(ret, &paddr) == 0) {
+                        *dma_handle = (dma_addr_t)paddr;
+                } else {
+                        free_pages((unsigned long)ret, get_order(size));
+                        ret = NULL;
+                }
+#else
+                *dma_handle = virt_to_bus(ret);
+#endif /* CONFIG_WRHV */
+        }
+
+        return ret;
+#endif
+
+}
+
+static inline dma_addr_t
+paravirt_dma_map_single(struct device *dev, void *ptr, size_t size,
+               enum dma_data_direction direction)
+{
+#ifdef CONFIG_WRHV
+        u64 paddr;
+#endif /* CONFIG_WRHV */
+        BUG_ON(direction == DMA_NONE);
+
+        __dma_sync(ptr, size, direction);
+#ifdef CONFIG_WRHV
+        if (vbiGuestDmaAddrGet(ptr, &paddr) == 0)
+                return (dma_addr_t)paddr;
+        else
+                return (dma_addr_t)NULL;
+#else
+        return virt_to_bus(ptr);
+#endif /* CONFIG_WRHV */
+
+}
+#endif /* CONFIG_WRHV */
+
+#endif	/* _ASM_PV_DMA_MAPPING_H */
diff --git a/arch/powerpc/include/asm/pv_hw_irq.h b/arch/powerpc/include/asm/pv_hw_irq.h
new file mode 100644
index 0000000..4cdcd5a
--- /dev/null
+++ b/arch/powerpc/include/asm/pv_hw_irq.h
@@ -0,0 +1,65 @@
+#ifndef PV_HW_IRQ_H
+#define PV_HW_IRQ_H
+
+/* set default definiation to native implemenation */
+#define local_irq_disable native_local_irq_disable
+#define local_irq_enable native_local_irq_enable
+#define local_irq_save_ptr native_local_irq_save_ptr
+#define irqs_disabled_flags native_irqs_disabled_flags
+
+#define local_save_flags native_local_save_flags
+#define local_irq_save native_local_irq_save
+#define irqs_disabled native_irqs_disabled
+
+#define hard_irq_enable native_hard_irq_enable
+#define hard_irq_disable native_hard_irq_disable
+
+
+/* Hypervisor specific irq implementation */
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+extern void wrhv_int_lock(void);
+extern void wrhv_int_unlock(int lvl);
+extern int wrhv_int_lvl_get (void);
+
+/* undefine native implementation */
+#undef local_irq_restore
+#undef local_save_flags
+#undef local_irq_save
+#undef irqs_disabled
+#undef local_irq_disable
+#undef local_irq_enable
+#undef local_irq_save_ptr
+#undef hard_irq_enable
+#undef hard_irq_disable
+
+/* WRHV specific static inline implementation */
+static inline void local_irq_disable(void)
+{
+        wrhv_int_lock();
+}
+
+static inline void local_irq_enable(void)
+{
+        wrhv_int_unlock(0);
+}
+
+static inline void local_irq_save_ptr(unsigned long *flags)
+{
+        *flags = wrhv_int_lvl_get();
+        wrhv_int_lock();
+}
+
+/* WRHV specific defination */
+#define local_irq_restore(flags) (flags == 0 ? local_irq_enable() : local_irq_disable ());
+#define local_save_flags(flags)	((flags) = wrhv_int_lvl_get())
+#define local_irq_save(flags) local_irq_save_ptr(&flags)
+#define irqs_disabled()	(wrhv_int_lvl_get() != 0)
+
+#define hard_irq_enable()      local_irq_enable()
+#define hard_irq_disable()     local_irq_disable()
+
+
+#endif /* CONFIG_WRHV */
+#endif /* PV_HW_IRQ_H */
+
diff --git a/arch/powerpc/include/asm/pv_pgtable-ppc32.h b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
new file mode 100644
index 0000000..dde80b7
--- /dev/null
+++ b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
@@ -0,0 +1,131 @@
+#ifndef _ASM_PV_DEF_PGTABLE_PPC32_H
+#define _ASM_PV_DEF_PGTABLE_PPC32_H
+
+#include <asm-generic/pgtable-nopmd.h>
+
+/* define native inline functions */
+#define set_pte_at native_set_pte_at
+
+#if defined(CONFIG_WRHV)
+#include <vbi/sys/vmmu.h>
+#include <vbi/vbInterface.h>
+
+/* redefine wrhv paravirtual operations */
+#undef set_pte_at
+#define set_pte_at wrhv_set_pte_at
+
+/*
+ * refer to include/sys/vmmu.h on what format the hypervisor expects
+ * the guest OS software page table to be
+ */
+
+#define _PAGE_PRESENT		VMMU_PROT_SUPV_READ
+#define _PAGE_USER		(VMMU_PROT_USER_READ|VMMU_PROT_USER_EXECUTE)
+#define _PAGE_FILE      	_PAGE_USER
+#define _PAGE_ACCESSED	        VMMU_PROT_SUPV_WRITE
+#define _PAGE_HWWRITE   	VMMU_PROT_USER_WRITE
+#define	 _PAGE_RW		(VMMU_PROT_SUPV_EXECUTE|VMMU_PROT_USER_WRITE)
+#define _PAGE_HWEXEC    	VMMU_PROT_USER_EXECUTE
+
+#define _PAGE_ENDIAN		VMMU_CACHE_LE
+#define _PAGE_GUARDED		VMMU_CACHE_GUARDED
+#define _PAGE_COHERENT		VMMU_CACHE_COHERENT
+#define _PAGE_NO_CACHE		VMMU_CACHE_INHIBIT
+#define _PAGE_WRITETHRU		VMMU_CACHE_WRITETHROUGH
+
+#define _PAGE_DIRTY		VMMU_PTE_CHG_MASK
+
+#define _PAGE_EXEC		VMMU_CACHE_COHERENT
+
+#define _PTE_NONE_MASK		0xffffffff00000fffULL
+
+/* based on hypervisor VMMU_LEVEL_1_DESC definition */
+#define _PMD_PRESENT		0x00000001   /* big endian */
+#define _PMD_PRESENT_MASK	(_PMD_PRESENT)
+#define _PMD_BAD		(~PAGE_MASK & ~0x03)
+
+#define _PAGE_BASE		(_PAGE_PRESENT | _PAGE_ACCESSED | VMMU_PROT_USER_READ)
+
+#define PFN_SIZE		(1UL << PFN_SHIFT_OFFSET)
+#define PFN_MASK		(~(PFN_SIZE-1))
+#define pte_to_pa(x)		(pte_val(x) & PFN_MASK)
+#define pte_to_prot(x)		(pte_val(x) & (PFN_SIZE-1))
+
+/*
+ * Some bits are only used on some cpu families...
+ */
+#ifndef _PAGE_HASHPTE
+#define _PAGE_HASHPTE   0
+#endif
+
+#ifndef __ASSEMBLY__
+/* WRHV paravirtual ops */
+static inline void wrhv_set_pte_at(struct mm_struct *mm, unsigned long addr,
+                              pte_t *ptep, pte_t pte)
+{
+#if _PAGE_HASHPTE != 0
+        pte_update(ptep, ~_PAGE_HASHPTE, pte_val(pte) & ~_PAGE_HASHPTE);
+#else
+        *ptep = pte;
+
+#ifdef CONFIG_WRHV
+        /* linux does not use valid bit, hypervisor does, in word0 */
+        *(u_int *)ptep |= (u_int) VMMU_PTE_VALID_MASK;
+
+#endif /* CONFIG_WRHV */
+
+#endif
+}
+#endif /* __ASSEMBLY__ */
+
+#elif defined(CONFIG_FSL_BOOKE) 	/* ! defined(CONFIG_WRHV) */
+/* native CONFIG_FSL_BOOKE defines */
+/*
+   MMU Assist Register 3:
+
+   32 33 34 35 36  ... 50 51 52 53 54 55 56 57 58 59 60 61 62 63
+   RPN......................  0  0 U0 U1 U2 U3 UX SX UW SW UR SR
+
+   - PRESENT *must* be in the bottom three bits because swap cache
+     entries use the top 29 bits.
+
+   - FILE *must* be in the bottom three bits because swap cache
+     entries use the top 29 bits.
+*/
+
+/* Definitions for FSL Book-E Cores */
+#define _PAGE_PRESENT	0x00001	/* S: PTE contains a translation */
+#define _PAGE_USER	0x00002	/* S: User page (maps to UR) */
+#define _PAGE_FILE	0x00002	/* S: when !present: nonlinear file mapping */
+#define _PAGE_ACCESSED	0x00004	/* S: Page referenced */
+#define _PAGE_HWWRITE	0x00008	/* H: Dirty & RW, set in exception */
+#define _PAGE_RW	0x00010	/* S: Write permission */
+#define _PAGE_HWEXEC	0x00020	/* H: UX permission */
+
+#define _PAGE_ENDIAN	0x00040	/* H: E bit */
+#define _PAGE_GUARDED	0x00080	/* H: G bit */
+#define _PAGE_COHERENT	0x00100	/* H: M bit */
+#define _PAGE_NO_CACHE	0x00200	/* H: I bit */
+#define _PAGE_WRITETHRU	0x00400	/* H: W bit */
+
+#ifdef CONFIG_PTE_64BIT
+#define _PAGE_DIRTY	0x08000	/* S: Page dirty */
+
+/* ERPN in a PTE never gets cleared, ignore it */
+#define _PTE_NONE_MASK	0xffffffffffff0000ULL
+#else
+#define _PAGE_DIRTY	0x00800	/* S: Page dirty */
+#endif
+
+#define _PMD_PRESENT	0
+#define _PMD_PRESENT_MASK (PAGE_MASK)
+#define _PMD_BAD	(~PAGE_MASK)
+
+/* Until my rework is finished, FSL BookE still needs atomic PTE updates */
+#define PTE_ATOMIC_UPDATES	1
+
+#define _PAGE_BASE      (_PAGE_PRESENT | _PAGE_ACCESSED)
+
+#endif
+
+#endif /* _ASM_PV_DEF_PGTABLE_PPC32_H */
diff --git a/arch/powerpc/include/asm/reg_paravirt.h b/arch/powerpc/include/asm/reg_paravirt.h
new file mode 100644
index 0000000..b765cce
--- /dev/null
+++ b/arch/powerpc/include/asm/reg_paravirt.h
@@ -0,0 +1,22 @@
+/*
+ * Contains the definition of registers common to all PowerPC variants.
+ * If a register definition has been changed in a different PowerPC
+ * variant, we will case it in #ifndef XXX ... #endif, and have the
+ * number used in the Programming Environments Manual For 32-Bit
+ * Implementations of the PowerPC Architecture (a.k.a. Green Book) here.
+ */
+
+#ifndef _ASM_POWERPC_REG_PARAVIRT_H
+#define _ASM_POWERPC_REG_PARAVIRT_H
+#ifdef __KERNEL__
+
+/* default native macros */
+#define PARAVIRT_MFSPR_SPRG3(a) mfspr a,SPRN_SPRG3 
+
+/* pickup individual hypervisor specific regs */
+#ifdef CONFIG_WRHV
+#include <asm/reg_wrhv.h>
+#endif
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_POWERPC_REG_PARAVIRT_H */
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
new file mode 100644
index 0000000..62a0252
--- /dev/null
+++ b/arch/powerpc/kernel/paravirt.c
@@ -0,0 +1,247 @@
+/*  Paravirtualization interfaces
+    Copyright (C) 2006 Rusty Russell IBM Corporation
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+    2007 - x86_64 support added by Glauber de Oliveira Costa, Red Hat Inc
+
+    2009 - adaptation from x86 version to powerpc by Wind River Systems.
+*/
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/efi.h>
+#include <linux/bcd.h>
+#include <linux/highmem.h>
+
+#include <asm/bug.h>
+#include <asm/setup.h>
+#include <asm/pgtable.h>
+#include <asm/time.h>
+#include <asm/pgalloc.h>
+#include <asm/irq.h>
+#include <asm/delay.h>
+#include <asm/fixmap.h>
+#include <asm/tlbflush.h>
+#include <asm/machdep.h>
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/init.h>
+#include <linux/bootmem.h>
+#include <linux/initrd.h>
+#include <linux/pagemap.h>
+
+#include <linux/kprobes.h>
+#include <linux/kexec.h>
+#include <linux/backlight.h> 
+#include <linux/bug.h>
+#include <linux/kdebug.h>
+#include <linux/ltt-core.h>
+#include <trace/trap.h>
+#include <linux/kallsyms.h> 
+
+#include <mm/mmu_decl.h>
+#include <linux/lmb.h>
+
+#include <linux/major.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+#include <linux/spi/spi.h>
+#include <linux/fsl_devices.h>
+#include <linux/fs_enet_pd.h>
+#include <linux/fs_uart_pd.h>
+
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <sysdev/fsl_soc.h>
+#include <asm/cpm2.h>
+
+#include <linux/kgdb.h>
+#include <linux/smp.h>
+#include <linux/signal.h>
+#include <linux/ptrace.h>
+#include <asm/current.h>
+#include <asm/processor.h>
+
+#include <asm/paravirt.h>
+
+#ifdef CONFIG_WRHV
+extern void wrhv_init(void);
+#endif
+
+/* XXX fixme - use an existing implementation */
+#if 1
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt , ...)       do { } while (0)
+#endif
+
+/* paravirt init */
+void paravirt_init(void)
+{
+#ifdef CONFIG_WRHV
+	wrhv_init();
+#endif
+}
+
+/* default native operations */
+struct pv_time_ops pv_time_ops = {
+#if 0
+	.hw_time_init = native_time_init,
+	.hw_timer_interrupt = native_timer_interrupt,
+	.hw_clocksource_init = native_clocksource_init,
+
+#endif
+};
+
+struct pv_irq_ops pv_irq_ops = {
+	.do_IRQ = native_do_IRQ,
+	.irq_of_parse_and_map = native_irq_of_parse_and_map,
+};
+
+struct pv_cpu_ops pv_cpu_ops = {
+	.get_pvr = native_get_pvr,
+	.gfar_of_init = native_gfar_of_init,
+	.DebugException = native_DebugException,
+	.kgdb_arch_handle_exception = native_kgdb_arch_handle_exception,
+};
+
+struct pv_mmu_ops pv_mmu_ops = {
+	.vmmu_restore = native_vmmu_restore,
+	.MMU_init_hw = native_MMU_init_hw,
+	.mmu_mapin_ram = native_mmu_mapin_ram,
+	.MMU_setup = native_MMU_setup,
+	.MMU_init = native_MMU_init,
+	.flush_dcache_page = native_flush_dcache_page,
+	.update_mmu_cache = native_update_mmu_cache,
+	.map_page = native_map_page,
+};
+
+
+/* pv_time_ops */
+void __init paravirt_time_init(void)
+{
+	pv_time_ops.hw_time_init();
+}
+
+void paravirt_timer_interrupt(struct pt_regs * regs)
+{	
+	pv_time_ops.hw_timer_interrupt(regs);
+}
+
+void __init wrhv_clocksource_init(void)
+{
+	pv_time_ops.hw_clocksource_init();
+}
+
+
+/* pv_irq_ops */
+void paravirt_do_IRQ(struct pt_regs *regs)
+{
+	pv_irq_ops.do_IRQ(regs);
+}
+
+
+unsigned int paravirt_irq_of_parse_and_map(struct device_node *dev, int index)
+{
+	return pv_irq_ops.irq_of_parse_and_map(dev, index);
+}
+
+/* pv_cpu_ops */
+unsigned int paravirt_get_pvr(void)
+{
+	return pv_cpu_ops.get_pvr();
+}
+
+int __init paravirt_gfar_of_init(void)
+{
+	return pv_cpu_ops.gfar_of_init();
+}
+
+void __kprobes paravirt_DebugException(struct pt_regs *regs, unsigned long debug_status)
+{
+	pv_cpu_ops.DebugException(regs, debug_status);
+
+}
+int paravirt_kgdb_arch_handle_exception(int vector, int signo, int err_code,
+			char *remcom_in_buffer, char *remcom_out_buffer,
+			struct pt_regs *linux_regs)
+{
+
+	return pv_cpu_ops.kgdb_arch_handle_exception(vector, signo, err_code,
+			remcom_in_buffer, remcom_out_buffer, linux_regs);
+}
+
+/* pv_mmu_ops */
+void paravirt_vmmu_restore (void)
+{
+	pv_mmu_ops.vmmu_restore();
+}
+
+void __init paravirt_MMU_init_hw(void)
+{
+	pv_mmu_ops.MMU_init_hw();
+}
+
+unsigned long __init paravirt_mmu_mapin_ram(void)
+{
+	return pv_mmu_ops.mmu_mapin_ram();
+}
+
+void paravirt_MMU_setup(void)
+{
+	pv_mmu_ops.MMU_setup();
+}
+
+void __init paravirt_MMU_init(void)
+{
+	pv_mmu_ops.MMU_init();
+}
+
+void paravirt_flush_dcache_page(struct page *page)
+{
+	pv_mmu_ops.flush_dcache_page(page);
+}
+
+void paravirt_update_mmu_cache(struct vm_area_struct *vma,
+		unsigned long address, pte_t pte)
+{
+	pv_mmu_ops.update_mmu_cache(vma, address, pte);
+}
+
+int paravirt_map_page(unsigned long va, phys_addr_t pa, int flags)
+{
+	return	pv_mmu_ops.map_page(va, pa, flags);
+}
+
+
+extern struct pv_time_ops pv_time_ops;
+extern struct pv_cpu_ops pv_cpu_ops;
+extern struct pv_irq_ops pv_irq_ops;
+extern struct pv_mmu_ops pv_mmu_ops; 
+
+EXPORT_SYMBOL_GPL(pv_time_ops);
+EXPORT_SYMBOL    (pv_cpu_ops);
+EXPORT_SYMBOL    (pv_mmu_ops);
+EXPORT_SYMBOL    (pv_irq_ops);
diff --git a/arch/powerpc/kernel/paravirt_entry_32.S b/arch/powerpc/kernel/paravirt_entry_32.S
new file mode 100644
index 0000000..a12087f
--- /dev/null
+++ b/arch/powerpc/kernel/paravirt_entry_32.S
@@ -0,0 +1,34 @@
+/*
+ *  Normally this file would contain the system call entry code, context
+ *  switch code, and exception/interrupt return code for PowerPC.
+ *  In this paravirt version of entry_32.S only a few redirects remain.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <asm/reg.h>
+#include <asm/ppc_asm.h>
+#include <asm/asm-offsets.h>
+
+	.globl	paravirt_transfer_to_handler
+paravirt_transfer_to_handler:
+	b	native_transfer_to_handler
+
+	.globl	paravirt_ret_from_syscall
+paravirt_ret_from_syscall:
+	b	native_ret_from_syscall
+
+	.globl  paravirt_syscall_exit_work
+paravirt_syscall_exit_work:
+	b	native_syscall_exit_work
+
+	.globl	paravirt_restore
+paravirt_restore:
+	b	native_restore
+
+_GLOBAL(paravirt_switch)
+	b	native_switch
diff --git a/arch/powerpc/kernel/paravirt_misc_32.S b/arch/powerpc/kernel/paravirt_misc_32.S
new file mode 100644
index 0000000..d881a7d
--- /dev/null
+++ b/arch/powerpc/kernel/paravirt_misc_32.S
@@ -0,0 +1,36 @@
+/*
+ *  misc operations, for paravirt implementation.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <asm/ppc_asm.h>
+#include <asm/asm-offsets.h>
+
+_GLOBAL(paravirt_tlbia)
+	b	native_tlbia
+
+_GLOBAL(_tlbie)
+	b	native_tlbie
+
+_GLOBAL(clean_dcache_range)
+	b	native_clean_dcache_range
+
+_GLOBAL(paravirt__flush_dcache_icache)
+        b       native__flush_dcache_icache
+
+_GLOBAL(paravirt_flush_dcache_range)
+        b       native_flush_dcache_range
+
+_GLOBAL(paravirt__flush_icache_range)
+        b       native__flush_icache_range
+
+_GLOBAL(paravirt__flush_dcache_icache_phys)
+        b       native__flush_dcache_icache_phys
+
+
+
-- 
1.6.5.rc1

