From 27ca5c25796acd65f8c9c5a68e911682e75cd608 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 28 Oct 2009 20:34:24 -0400
Subject: [PATCH 03/26] vbi: yet another cosmetic cleanup

Nothing to see here.  Move along. Eyes on the road, please.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |  157 +++++++++++++++++------------------
 include/vbi/interface.h             |    5 -
 include/vbi/vbi.h                   |   19 ----
 3 files changed, 78 insertions(+), 103 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 2acfd83..3895a56 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -175,10 +175,10 @@
  *       |---------------|
  *       |       CR      |
  *       |---------------|
- *       |		|
+ *       |               |
  *       |general purpose|
  *       |     r[0:13]   |
- *       |		|
+ *       |               |
  *       |---------------|
  *       |emulated MSR   |
  *       |---------------|
@@ -197,9 +197,9 @@
  */
 
 typedef struct vbArchControlRegs
-    {
+{
 
-    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+	/* Registers to be restored by the VDK_SYS_ctx_load fast system call */
 
 	uint32_t srr0;		/*  0: PC */
 	uint32_t srr1;		/*  1: MSR */
@@ -219,34 +219,34 @@ typedef struct vbArchControlRegs
 	uint32_t r12;		/* 15: General register R12 */
 	uint32_t r13;		/* 16: General register R13 */
 
-    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
+	/* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
 
 	uint32_t emsr;		/* 17: emulated MSR register */
 
-    /* Debug control registers */
+	/* Debug control registers */
 
 	uint32_t     dbsr; /* 18 - debug status register */
 
-    /* Debug control registers */
+	/* Debug control registers */
 
 	uint32_t     dbcr0; /* 19 - debug control register 0 */
 	uint32_t     dbcr1; /* 20 - debug control register 1 */
 	uint32_t     dbcr2; /* 21 - debug control register 2 */
 
-    /* instruction address compare registers IAC1-IAC2 */
+	/* instruction address compare registers IAC1-IAC2 */
 
 	uint32_t     iac1; /* 22 - instructions access control 1 */
 	uint32_t     iac2; /* 23 - instructions access control 2 */
 
-    /* data address compare registers DAC1-DAC2. */
+	/* data address compare registers DAC1-DAC2. */
 
 	uint32_t     dac1; /* 24 - instructions access control 3 */
 	uint32_t     dac2; /* 25 - instructions access control 4 */
 
-    /* reserved fields for future use */
+	/* reserved fields for future use */
 
 	uint32_t reserved[10];      /* 26: Reserved */
-    } VB_ARCH_CONTROL_REGS;
+} VB_ARCH_CONTROL_REGS;
 
 /*
  *
@@ -313,11 +313,11 @@ typedef struct vbArchControlRegs
 typedef struct archStatusRegs
 {
 
-    /*
-     * registers saved by hypervisor for all interrupts exceptions
-     * before setting the PC in the virtual board to the exception/interrupt
-     * vector address
-     */
+	/*
+	 * registers saved by hypervisor for all interrupts exceptions
+	 * before setting the PC in the virtual board to the exception/interrupt
+	 * vector address
+	 */
 
 	uint32_t srr0; /* 0: PC at time of the interrupt */
 	uint32_t srr1; /* 1: MSR at time of the interrupt */
@@ -326,7 +326,7 @@ typedef struct archStatusRegs
 	uint32_t r3;   /* 4: R3 at time of the interrupt */
 	uint32_t r4;   /* 5: R4 at time of the interrupt */
 
-    /* Registers saved by hypervisor during exception processing only */
+	/* Registers saved by hypervisor during exception processing only */
 
 	uint32_t mcsrr0; /*  6: */
 	uint32_t mcsrr1; /*  7: */
@@ -338,16 +338,16 @@ typedef struct archStatusRegs
 	uint32_t esrr0;  /* 13: */
 	uint32_t esrr1;  /* 14: */
 
-/*
- * keep this part in a separate structure in order to keep the offsets
- * to remain the same as in VB_STATUS
- */
+	/*
+	 * keep this part in a separate structure in order to keep
+	 * the offsets to remain the same as in VB_STATUS
+	 */
 
-    /* reserved fields for future use */
+	/* reserved fields for future use */
 
 	uint32_t reserved1[8]; /* 15 - 22  */
 
-    /* Configuration registers (only updated upon board creation */
+	/* Configuration registers (only updated upon board creation */
 
 	uint32_t svr;     /* 23 */
 	uint32_t pir;     /* 24 */
@@ -358,7 +358,7 @@ typedef struct archStatusRegs
 	uint32_t l1csr0;  /* 29 */
 	uint32_t l1csr1;  /* 30 */
 
-    /* reserved fields for future use */
+	/* reserved fields for future use */
 
 	uint32_t reserved2[9]; /* 31 - 39 */
 
@@ -384,7 +384,7 @@ typedef struct
 	uint32_t pc;		/* program counter */
 	uint32_t cr;		/* condition register */
 	uint32_t xer;		/* fixed-point exception register */
-	uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
+	uint32_t spefscr;	/* SPE floating-point status & ctrl reg */
 	uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
 } HREG_SET;
 
@@ -426,47 +426,46 @@ typedef struct vbi_msg_header {
 
 typedef struct
 {
-    VBI_MSG_HEADER hdr;			/* message header */
-    uint32_t   request;			/* request type */
+	VBI_MSG_HEADER hdr;			/* message header */
+	uint32_t   request;			/* request type */
 
-    union
+	union
 	{
-    	struct
-	    {
-	    uint32_t bus;		
-	    uint32_t phyAddr;
-	    uint32_t regNum;
-	    uint32_t page;
-	    } mdioRead;
-    	struct
-	    {
-	    uint32_t bus;		
-	    uint32_t phyAddr;
-	    uint32_t regNum;
-	    uint32_t page;
-	    uint32_t dataVal;
-	    } mdioWrite;
+		struct
+		{
+			uint32_t bus;		
+			uint32_t phyAddr;
+			uint32_t regNum;
+			uint32_t page;
+		} mdioRead;
+		struct
+		{
+			uint32_t bus;		
+			uint32_t phyAddr;
+			uint32_t regNum;
+			uint32_t page;
+			uint32_t dataVal;
+	} mdioWrite;
 #if 0 /* not supported for now */
-    	struct
-	    {
-	    uint32_t bus;		
-	    uint32_t vbIntNum;
-	    HY_CTX *pCtx;
-	    } mdioIntEnable;
-    	struct
-	    {
-	    uint32_t bus;	
-	    uint32_t vbIntNum;
-	    HY_CTX *pCtx;
-	    } mdioIntDisable;
+		struct
+		{
+			uint32_t bus;		
+			uint32_t vbIntNum;
+			HY_CTX *pCtx;
+		} mdioIntEnable;
+		struct
+		{
+			uint32_t bus;	
+			uint32_t vbIntNum;
+			HY_CTX *pCtx;
+		} mdioIntDisable;
 #endif
 	} arg;				
-
 } VBI_BSP_MSG;
 
 typedef struct
 {
-    VBI_MSG_HEADER hdr;			/* message header */
+	VBI_MSG_HEADER hdr;			/* message header */
 	uint32_t   status;			/* request completion status */
 	uint32_t   dataVal;
 } VBI_BSP_MSG_REPLY;
@@ -488,9 +487,9 @@ typedef struct
  *
  * VB_CONTROL_SRR1	     -------> SRR1
  *
- * VB_CONTROL_CR		     -------> CR
+ * VB_CONTROL_CR	     -------> CR
  *
- * VB_CONTROL_R0		     -------> R0
+ * VB_CONTROL_R0	     -------> R0
  *
  * VB_CONTROL_EMSR	     -------> MSR
  *
@@ -506,9 +505,9 @@ typedef struct
  *
  */
 
-#define VBI_CTX_LOAD(reg)				    \
-	lis	reg, HI(VBI_SYS_ctx_load);		    \
-	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
+#define VBI_CTX_LOAD(reg)			\
+	lis reg, HI(VBI_SYS_ctx_load);		\
+	ori reg, reg, LO(VBI_SYS_ctx_load);	\
 	sc
 
 /*
@@ -537,10 +536,10 @@ typedef struct
  */
 #define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
 	li	reg1, -1;				\
-        lis     reg2, HIADJ(wrhvVbControl);		\
-        lwz     reg2, LO(wrhvVbControl)(reg2);		\
-        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
-        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+	lis     reg2, HIADJ(wrhvVbControl);		\
+	lwz     reg2, LO(wrhvVbControl)(reg2);		\
+	lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
+	stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
 
 /*
  *
@@ -569,7 +568,7 @@ typedef struct
  *       load VB_STATUS_INT_PENDING(reg0) in reg1
  *       check if reg1 is equal to zero
  *       if true return
- *	otherwise send an hypercall
+ *       otherwise send an hypercall
  *       go to checkStatus
  * }
  *
@@ -613,9 +612,9 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_INT_VCORE_STATE_GET(reg0)				\
-	VBI_CNTRL_ADDR_GET(reg0);				\
-	lwz	reg0, VB_CONTROL_INT_DISABLE(reg0);		
+#define VBI_INT_VCORE_STATE_GET(reg0)			\
+	VBI_CNTRL_ADDR_GET(reg0);			\
+	lwz reg0, VB_CONTROL_INT_DISABLE(reg0);		
 
 /*
  * VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
@@ -627,9 +626,9 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_CONFIG_ADDR_GET(reg)		    \
-        lis     reg, HIADJ(wrhvVbConfig);	    \
-        lwz     reg, LO(wrhvVbConfig)(reg)	
+#define VBI_CONFIG_ADDR_GET(reg)		\
+	    lis reg, HIADJ(wrhvVbConfig);	\
+	    lwz reg, LO(wrhvVbConfig)(reg)	
 
 /*
  * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
@@ -639,9 +638,9 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_CNTRL_ADDR_GET(reg)			    \
-        lis     reg, HIADJ(wrhvVbControl);	    \
-        lwz     reg, LO(wrhvVbControl)(reg) 	
+#define VBI_CNTRL_ADDR_GET(reg)			\
+	    lis reg, HIADJ(wrhvVbControl);	\
+	    lwz reg, LO(wrhvVbControl)(reg) 	
 
 /*
  * VBI_STATUS_ADDR_GET - Get virtual core status structure address
@@ -668,9 +667,9 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_STATUS_ADDR_GET(reg)			    \
-        lis     reg, HIADJ(wrhvVbStatus);		    \
-        lwz     reg, LO(wrhvVbStatus)(reg)	
+#define VBI_STATUS_ADDR_GET(reg)		\
+	lis reg, HIADJ(wrhvVbStatus);		\
+	lwz reg, LO(wrhvVbStatus)(reg)	
 
 #endif /*_ASMLANGUAGE */
 
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index f0c651e..ca04d24 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -86,13 +86,11 @@ identity mapped.
 #include <vbi/arch.h>
 
 /* VB versioning information */
-
 #define	VBI_VERSION_MAJOR	2	/* major version */
 #define	VBI_VERSION_MINOR	0	/* minor version */
 #define	VBI_VERSION_MAINT	0	/* maintenance version */
 
 /* macro to align guest fields for a 64-bit hypervisor */
-
 #if defined(LP64)
 #define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
 			   __attribute__(( aligned(8) )) \
@@ -149,7 +147,6 @@ typedef uint64_t VB_TIMESTAMP;
  * care must be taken if this is changed, since some algorithms and
  * data structures will require modifications and become more complex
  */
-
 #define VB_MAX_INTERRUPTS		32
 
 /*
@@ -157,11 +154,9 @@ typedef uint64_t VB_TIMESTAMP;
  * This can be modified without any impacts, tho it should not be
  * set to 0
  */
-
 #define VB_MAX_INTERRUPT_DATA		16
 
 /* Structure offsets for assembler */
-
 #if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
 #define VB_CONTROL_REG_STRUCT_END	0
 #endif
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index dcea36e..4519505 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -14,7 +14,6 @@
  *
  */
 
-
 #ifndef _VBI_VBI_H
 #define _VBI_VBI_H
 
@@ -179,29 +178,11 @@ various data structures.
  * The VMMU pages
  *
  * The page size granularity 
- *\me 
- *
- * VMMU_CONFIG definition:
- *
- * typedef struct vmmuConfig
- *    {
- *    VMMU_LEVEL_1_DESC *addr;
- *    size_t         pageSize;
- *    uint32_t       reserved;
- *    uint32_t       vmmu_num;
- *    } VMMU_CONFIG;
  *
  * The vmmu virtual address space is restricted to 32 bits and is decoded using
  * a level-1/level-2 page table.  The virtual address is decoded as follows:
  *
  *
- *
- *
- *
- *
- *
- *
- *
  *                          32-bit Virtual Address
  *        +---------------------------------------------------------+
  *        |      L1 offset       | L2 offset |    Page offset       |
-- 
1.6.5.2

