From af928637908dd9d1577bf92daca0e91b207fb7ad Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Wed, 31 Mar 2010 14:36:33 +0800
Subject: [PATCH V2] ppc: separate CONFIG_PARAVIRT and CONFIG_WRHV

When CONFIG_PARAVIRT=yes && CONFIG_WRHV=no, we should
be able to get a workable native ppc kernel, but we can't
now. here seperate CONFIG_PARAVIRT and CONFIG_WRHV to achieve
our goal.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/powerpc/include/asm/machdep.h       |    2 +-
 arch/powerpc/include/asm/mmu_context.h   |    2 +-
 arch/powerpc/include/asm/page_32.h       |    2 +-
 arch/powerpc/include/asm/pgalloc-32.h    |    2 +-
 arch/powerpc/include/asm/pgtable-ppc32.h |   16 +++++++-------
 arch/powerpc/include/asm/ptrace.h        |    2 +-
 arch/powerpc/include/asm/pv_hw_irq.h     |    1 +
 arch/powerpc/include/asm/system.h        |    2 +-
 arch/powerpc/kernel/Makefile             |    4 ++-
 arch/powerpc/kernel/entry_32.S           |   12 ++++++++--
 arch/powerpc/kernel/head_booke.h         |    2 +-
 arch/powerpc/kernel/irq.c                |    3 ++
 arch/powerpc/kernel/module.c             |    1 -
 arch/powerpc/kernel/paravirt.c           |    2 +-
 arch/powerpc/kernel/paravirt_entry_32.S  |   34 ++++++++++++++++++++++++++++++
 arch/powerpc/kernel/paravirt_misc_32.S   |   33 +++++++++++++++++++++++++++++
 arch/powerpc/kernel/process.c            |    2 +-
 arch/powerpc/kernel/setup-common.c       |    4 +++
 arch/powerpc/kernel/setup_32.c           |    4 +-
 arch/powerpc/kernel/time.c               |    2 +-
 arch/powerpc/mm/init_32.c                |    4 +-
 arch/powerpc/mm/mmu_decl.h               |    3 +-
 arch/powerpc/mm/pgtable_32.c             |    4 +-
 arch/powerpc/sysdev/fsl_soc.c            |    2 +
 24 files changed, 115 insertions(+), 30 deletions(-)
 create mode 100644 arch/powerpc/kernel/paravirt_entry_32.S
 create mode 100644 arch/powerpc/kernel/paravirt_misc_32.S

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index 7fc9cdd..ad8a1f3 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -262,7 +262,7 @@ struct machdep_calls {
 	void (*suspend_enable_irqs)(void);
 #endif
 
-#ifdef CONFIG_VIRTUALIZATION
+#ifdef CONFIG_PARAVIRT
 	int (*earlycon_setup)(void);
 #endif
 };
diff --git a/arch/powerpc/include/asm/mmu_context.h b/arch/powerpc/include/asm/mmu_context.h
index 096cd9b..b68aaf6 100644
--- a/arch/powerpc/include/asm/mmu_context.h
+++ b/arch/powerpc/include/asm/mmu_context.h
@@ -65,7 +65,7 @@ static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 #define LAST_CONTEXT    	255
 #define FIRST_CONTEXT    	1
 
-#elif defined(CONFIG_E200) || defined(CONFIG_E500) || defined(CONFIG_PARAVIRT)
+#elif defined(CONFIG_E200) || defined(CONFIG_E500) || defined(CONFIG_WRHV)
 #define NO_CONTEXT      	256
 #define LAST_CONTEXT    	255
 #define FIRST_CONTEXT    	1
diff --git a/arch/powerpc/include/asm/page_32.h b/arch/powerpc/include/asm/page_32.h
index eef1d35..1bb08e8 100644
--- a/arch/powerpc/include/asm/page_32.h
+++ b/arch/powerpc/include/asm/page_32.h
@@ -18,7 +18,7 @@
  * The basic type of a PTE - 64 bits for those CPUs with > 32 bit
  * physical addressing.  For now this just the IBM PPC440.
  */
-#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_WRHV)
 typedef unsigned long long pte_basic_t;
 #define PTE_SHIFT	(PAGE_SHIFT - 3)	/* 512 ptes per page */
 #else
diff --git a/arch/powerpc/include/asm/pgalloc-32.h b/arch/powerpc/include/asm/pgalloc-32.h
index f579541..53d3b00 100644
--- a/arch/powerpc/include/asm/pgalloc-32.h
+++ b/arch/powerpc/include/asm/pgalloc-32.h
@@ -17,7 +17,7 @@ extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);
 #define __pmd_free_tlb(tlb,x)		do { } while (0)
 /* #define pgd_populate(mm, pmd, pte)      BUG() */
 
-#if !defined(CONFIG_BOOKE) || defined (CONFIG_PARAVIRT)
+#if !defined(CONFIG_BOOKE) || defined (CONFIG_WRHV)
 #define pmd_populate_kernel(mm, pmd, pte)	\
 		(pmd_val(*(pmd)) = __pa(pte) | _PMD_PRESENT)
 #define pmd_populate(mm, pmd, pte)	\
diff --git a/arch/powerpc/include/asm/pgtable-ppc32.h b/arch/powerpc/include/asm/pgtable-ppc32.h
index c998cc5..ddf2aa9 100644
--- a/arch/powerpc/include/asm/pgtable-ppc32.h
+++ b/arch/powerpc/include/asm/pgtable-ppc32.h
@@ -284,7 +284,7 @@ extern int icache_44x_need_flush;
 #define _PTE_NONE_MASK	0xffffffff00000000ULL
 
 
-#elif defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_PARAVIRT)
+#elif defined(CONFIG_FSL_BOOKE)
 /*
    MMU Assist Register 3:
 
@@ -602,7 +602,7 @@ extern void add_hash_page(unsigned context, unsigned long va,
  * the old pte value.  In the 64-bit PTE case we lock around the
  * low PTE word since we expect ALL flag bits to be there
  */
-#if !defined(CONFIG_PTE_64BIT) && !defined(CONFIG_PARAVIRT)
+#if !defined(CONFIG_PTE_64BIT) && !defined(CONFIG_WRHV)
 static inline unsigned long pte_update(pte_t *p,
 				       unsigned long clr,
 				       unsigned long set)
@@ -631,7 +631,7 @@ static inline unsigned long pte_update(pte_t *p,
 #endif
 	return old;
 }
-#else /* CONFIG_PTE_64BIT && CONFIG_PARAVIRT */
+#else /* CONFIG_PTE_64BIT && CONFIG_WRHV */
 /* TODO: Change that to only modify the low word and move set_pte_at()
  * out of line
  */
@@ -665,7 +665,7 @@ static inline unsigned long long pte_update(pte_t *p,
 #endif
 	return old;
 }
-#endif /* CONFIG_PTE_64BIT && CONFIG_PARAVIRT */
+#endif /* CONFIG_PTE_64BIT && CONFIG_WRHV */
 
 /*
  * set_pte stores a linux PTE into the linux page table.
@@ -701,7 +701,7 @@ static inline void native_set_pte_at(struct mm_struct *mm, unsigned long addr,
  * for our hash-based implementation, we fix that up here.
  */
 #define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
-#ifndef CONFIG_PARAVIRT
+#ifndef CONFIG_WRHV
 static inline int __ptep_test_and_clear_young(unsigned int context, unsigned long addr, pte_t *ptep)
 {
 	unsigned long old;
@@ -716,7 +716,7 @@ static inline int __ptep_test_and_clear_young(unsigned int context, unsigned lon
 }
 #define ptep_test_and_clear_young(__vma, __addr, __ptep) \
 	__ptep_test_and_clear_young((__vma)->vm_mm->context.id, __addr, __ptep)
-#else /* CONFIG_PARAVIRT */
+#else /* CONFIG_WRHV */
 static inline int __ptep_test_and_clear_young(mm_context_t * ctx,
                                               unsigned long addr, pte_t *ptep)
 {
@@ -730,7 +730,7 @@ static inline int __ptep_test_and_clear_young(mm_context_t * ctx,
 
 #define ptep_test_and_clear_young(__vma, __addr, __ptep) \
 	__ptep_test_and_clear_young(&(__vma)->vm_mm->context.id, __addr, __ptep)
-#endif   /* CONFIG_PARAVIRT */
+#endif   /* CONFIG_WRHV */
 
 #define __HAVE_ARCH_PTEP_GET_AND_CLEAR
 static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,
@@ -790,7 +790,7 @@ extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
  * handler).  On everything else the pmd contains the physical address
  * of the pte page.  -- paulus
  */
-#if !defined(CONFIG_BOOKE) || defined(CONFIG_PARAVIRT)
+#if !defined(CONFIG_BOOKE) || defined(CONFIG_WRHV)
 #define pmd_page_vaddr(pmd)	\
 	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
 #define pmd_page(pmd)		\
diff --git a/arch/powerpc/include/asm/ptrace.h b/arch/powerpc/include/asm/ptrace.h
index 172c5fb..0009421 100644
--- a/arch/powerpc/include/asm/ptrace.h
+++ b/arch/powerpc/include/asm/ptrace.h
@@ -136,7 +136,7 @@ do {									      \
 /*
  * These are defined as per linux/ptrace.h, which see.
  */
-#ifndef CONFIG_PARAVIRT
+#ifndef CONFIG_WRHV
 #define arch_has_single_step()	(1)
 #else
 #define arch_has_single_step()	(0)
diff --git a/arch/powerpc/include/asm/pv_hw_irq.h b/arch/powerpc/include/asm/pv_hw_irq.h
index 184631e..6f2174b 100644
--- a/arch/powerpc/include/asm/pv_hw_irq.h
+++ b/arch/powerpc/include/asm/pv_hw_irq.h
@@ -7,6 +7,7 @@
 #define local_irq_save_ptr native_local_irq_save_ptr
 #define irqs_disabled_flags native_irqs_disabled_flags
 
+#define local_irq_restore native_local_irq_restore
 #define local_save_flags native_local_save_flags
 #define local_irq_save native_local_irq_save
 #define irqs_disabled native_irqs_disabled
diff --git a/arch/powerpc/include/asm/system.h b/arch/powerpc/include/asm/system.h
index d4b9329..f18625a 100644
--- a/arch/powerpc/include/asm/system.h
+++ b/arch/powerpc/include/asm/system.h
@@ -199,7 +199,7 @@ extern u32 booke_wdt_period;
 struct device_node;
 extern void note_scsi_host(struct device_node *, void *);
 
-#ifdef CONFIG_PARAVIRT
+#ifdef CONFIG_WRHV
 #define prepare_arch_switch(next)      local_irq_disable()
 #endif
 
diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index cf4f4f8..ed81822 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -60,7 +60,9 @@ obj64-$(CONFIG_HIBERNATION)	+= swsusp_asm64.o
 obj-$(CONFIG_MODULES)		+= module.o module_$(CONFIG_WORD_SIZE).o
 
 ifeq ($(CONFIG_WRHV),y)
-obj-$(CONFIG_WRHV)              += wrhv_entry_32.o wrhv_misc_32.o
+obj-$(CONFIG_WRHV)		+= wrhv_entry_32.o wrhv_misc_32.o
+else
+obj-$(CONFIG_PARAVIRT)		+= paravirt_entry_32.o paravirt_misc_32.o
 endif
 
 obj-$(CONFIG_44x)		+= cpu_setup_44x.o
diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 00628e0..be9604d 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -32,6 +32,11 @@
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
 
+#ifndef CONFIG_WRHV
+#undef SHOW_SYSCALLS
+#undef SHOW_SYSCALLS_TASK
+#endif
+
 /*
  * MSR_KERNEL is > 0x10000 on 4xx/Book-E since it include MSR_CE.
  */
@@ -168,7 +173,7 @@ native_transfer_to_handler:
 	beq	2f			/* if from user, fix up THREAD.regs */
 	addi	r11,r1,STACK_FRAME_OVERHEAD
 	stw	r11,PT_REGS(r12)
-#if defined(CONFIG_40x) || defined(CONFIG_BOOKE) && !defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_40x) || defined(CONFIG_BOOKE) && !defined(CONFIG_WRHV)
 	/* Check to see if the dbcr0 register is set up to debug.  Use the
 	   internal debug mode bit to do this. */
 	lwz	r12,THREAD_DBCR0(r12)
@@ -320,7 +325,7 @@ native_ret_from_syscall:
 	oris	r11,r11,0x1000	/* Set SO bit in CR */
 	stw	r11,_CCR(r1)
 syscall_exit_cont:
-#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE) && !(CONFIG_PARAVIRT)
+#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE) && !(CONFIG_WRHV)
 	/* If the process has its own DBCR0 value, load it up.  The internal
 	   debug mode bit tells us that dbcr0 should be loaded. */
 	lwz	r0,THREAD+THREAD_DBCR0(r2)
@@ -767,7 +772,7 @@ user_exc_return:		/* r10 contains MSR_KERNEL here */
 	bne	do_work
 
 restore_user:
-#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE) && !defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE) && !defined(CONFIG_WRHV)
 	/* Check whether this process has its own DBCR0 value.  The internal
 	   debug mode bit tells us that dbcr0 should be loaded. */
 	lwz	r0,THREAD+THREAD_DBCR0(r2)
@@ -807,6 +812,7 @@ restore:
 	b	paravirt_restore
 #endif
 
+	.globl native_restore
 native_restore:
 #ifdef CONFIG_44x
 	lis	r4,icache_44x_need_flush@ha
diff --git a/arch/powerpc/kernel/head_booke.h b/arch/powerpc/kernel/head_booke.h
index a0c0685..f9f9419 100644
--- a/arch/powerpc/kernel/head_booke.h
+++ b/arch/powerpc/kernel/head_booke.h
@@ -78,7 +78,7 @@
 
 #define EXC_LVL_FRAME_OVERHEAD	(THREAD_SIZE - INT_FRAME_SIZE - EXC_LVL_SIZE)
 
-#if defined(CONFIG_SMP) && !defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_SMP) && !defined(CONFIG_WRHV)
 #define BOOKE_LOAD_EXC_LEVEL_STACK(level)		\
 	mfspr	r8,SPRN_PIR;				\
 	slwi	r8,r8,2;				\
diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index 2bdbaa1..7a269ad 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -71,6 +71,8 @@
 #endif
 
 int __irq_offset_value;
+
+#ifdef CONFIG_WRHV
 /* get and set method for ppc_spurious_interrupts, so other file
    have access to this variable
  */
@@ -84,6 +86,7 @@ void set_ppc_spurious_interrupts(int value)
 {
        ppc_spurious_interrupts = value;
 }
+#endif
 
 static int ppc_spurious_interrupts;
 
diff --git a/arch/powerpc/kernel/module.c b/arch/powerpc/kernel/module.c
index fdc5d3f..bca7d51 100644
--- a/arch/powerpc/kernel/module.c
+++ b/arch/powerpc/kernel/module.c
@@ -30,7 +30,6 @@
 #include "setup.h"
 
 LIST_HEAD(module_bug_list);
-extern void flush_dcache_page(struct page *page);
 void *module_alloc(unsigned long size)
 {
 	if (size == 0)
diff --git a/arch/powerpc/kernel/paravirt.c b/arch/powerpc/kernel/paravirt.c
index 888418e..8a0621e 100644
--- a/arch/powerpc/kernel/paravirt.c
+++ b/arch/powerpc/kernel/paravirt.c
@@ -264,7 +264,7 @@ inline int paravirt_enabled(void)
         return pv_info.paravirt_enabled;
 }
 
-#ifdef CONFIG_PCI
+#if defined(CONFIG_PCI) && defined(CONIFG_WRHV)
 int paravirt_pci_read_irq_line(struct pci_dev *dev)
 {
 #ifdef CONFIG_WRHV_8572
diff --git a/arch/powerpc/kernel/paravirt_entry_32.S b/arch/powerpc/kernel/paravirt_entry_32.S
new file mode 100644
index 0000000..a12087f
--- /dev/null
+++ b/arch/powerpc/kernel/paravirt_entry_32.S
@@ -0,0 +1,34 @@
+/*
+ *  Normally this file would contain the system call entry code, context
+ *  switch code, and exception/interrupt return code for PowerPC.
+ *  In this paravirt version of entry_32.S only a few redirects remain.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <asm/reg.h>
+#include <asm/ppc_asm.h>
+#include <asm/asm-offsets.h>
+
+	.globl	paravirt_transfer_to_handler
+paravirt_transfer_to_handler:
+	b	native_transfer_to_handler
+
+	.globl	paravirt_ret_from_syscall
+paravirt_ret_from_syscall:
+	b	native_ret_from_syscall
+
+	.globl  paravirt_syscall_exit_work
+paravirt_syscall_exit_work:
+	b	native_syscall_exit_work
+
+	.globl	paravirt_restore
+paravirt_restore:
+	b	native_restore
+
+_GLOBAL(paravirt_switch)
+	b	native_switch
diff --git a/arch/powerpc/kernel/paravirt_misc_32.S b/arch/powerpc/kernel/paravirt_misc_32.S
new file mode 100644
index 0000000..b489eaf
--- /dev/null
+++ b/arch/powerpc/kernel/paravirt_misc_32.S
@@ -0,0 +1,33 @@
+/*
+ *  misc operations, for paravirt implementation.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <asm/ppc_asm.h>
+#include <asm/asm-offsets.h>
+
+_GLOBAL(paravirt_tlbia)
+	b	native_tlbia
+
+_GLOBAL(paravirt_tlbie)
+	b	native_tlbie
+
+_GLOBAL(paravirt_clean_dcache_range)
+	b	native_clean_dcache_range
+
+_GLOBAL(paravirt__flush_dcache_icache)
+        b       native__flush_dcache_icache
+
+_GLOBAL(paravirt_flush_dcache_range)
+        b       native_flush_dcache_range
+
+_GLOBAL(paravirt__flush_icache_range)
+        b       native__flush_icache_range
+
+_GLOBAL(paravirt__flush_dcache_icache_phys)
+        b       native__flush_dcache_icache_phys
diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c
index 34e37d1..62b48a7 100644
--- a/arch/powerpc/kernel/process.c
+++ b/arch/powerpc/kernel/process.c
@@ -187,7 +187,7 @@ void flush_vsx_to_thread(struct task_struct *tsk)
 #ifdef CONFIG_SPE
 
 
-#ifdef CONFIG_PARAVIRT
+#ifdef CONFIG_WRHV
 /* refer to native implementation in
  * linux/arch/powerpc/kernel/head_fsl_booke.S
  */
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index a3a8f1e..1e794f1 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -213,7 +213,11 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	}
 
 #ifdef CONFIG_PARAVIRT
+#ifdef CONFIG_SMP
+	pvr = per_cpu(pvr, cpu_id);
+#else
 	pvr = get_pvr();
+#endif
 #else
 #ifdef CONFIG_SMP
 	pvr = per_cpu(pvr, cpu_id);
diff --git a/arch/powerpc/kernel/setup_32.c b/arch/powerpc/kernel/setup_32.c
index 889df0c..660d9dd 100644
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@ -141,7 +141,7 @@ notrace void __init machine_init(unsigned long dt_ptr, unsigned long phys)
 		ppc_md.power_save = ppc6xx_idle;
 #endif
 
-#if defined(CONFIG_E500) && !defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_E500) && !defined(CONFIG_WRHV)
 	if (cpu_has_feature(CPU_FTR_CAN_DOZE) ||
 	    cpu_has_feature(CPU_FTR_CAN_NAP))
 		ppc_md.power_save = e500_idle;
@@ -303,7 +303,7 @@ void __init setup_arch(char **cmdline_p)
 	if (ppc_md.init_early)
 		ppc_md.init_early();
 
-#ifdef CONFIG_VIRTUALIZATION
+#ifdef CONFIG_PARAVIRT
 	/* give an opportunity for special legacy serial or
 	   other setup to be run */
 	if (ppc_md.earlycon_setup)
diff --git a/arch/powerpc/kernel/time.c b/arch/powerpc/kernel/time.c
index 12c55f1..29c5f79 100644
--- a/arch/powerpc/kernel/time.c
+++ b/arch/powerpc/kernel/time.c
@@ -79,7 +79,7 @@
 #include <linux/clockchips.h>
 #include <linux/clocksource.h>
 
-#ifdef CONFIG_PARAVIRT
+#ifdef CONFIG_WRHV
 #define HWTIMER_USE_JIFFY 1
 #endif
 
diff --git a/arch/powerpc/mm/init_32.c b/arch/powerpc/mm/init_32.c
index 9c2fcea..2b62ff3 100644
--- a/arch/powerpc/mm/init_32.c
+++ b/arch/powerpc/mm/init_32.c
@@ -151,12 +151,12 @@ void __init native_MMU_init(void)
 	total_lowmem = total_memory = lmb_end_of_DRAM() - memstart_addr;
 	lowmem_end_addr = memstart_addr + total_lowmem;
 
-#if defined(CONFIG_FSL_BOOKE) && ! defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_FSL_BOOKE) && ! defined(CONFIG_WRHV)
 	/* Freescale Book-E parts expect lowmem to be mapped by fixed TLB
 	 * entries, so we need to adjust lowmem to match the amount we can map
 	 * in the fixed entries */
 	adjust_total_lowmem();
-#endif /* CONFIG_FSL_BOOKE && ! defined(CONFIG_PARAVIRT) */
+#endif /* CONFIG_FSL_BOOKE && ! defined(CONFIG_WRHV) */
 
 	if (total_lowmem > __max_low_memory) {
 		total_lowmem = __max_low_memory;
diff --git a/arch/powerpc/mm/mmu_decl.h b/arch/powerpc/mm/mmu_decl.h
index 4d5471b..2d1631a 100644
--- a/arch/powerpc/mm/mmu_decl.h
+++ b/arch/powerpc/mm/mmu_decl.h
@@ -62,6 +62,7 @@ extern phys_addr_t lowmem_end_addr;
 #define flush_HPTE(pid, va, pg)	_tlbie(va, pid)
 extern void MMU_init_hw(void);
 extern unsigned long mmu_mapin_ram(void);
+extern void adjust_total_lowmem(void);
 
 #elif defined(CONFIG_8xx)
 #define flush_HPTE(X, va, pg)	_tlbie(va, 0 /* 8xx doesn't care about PID */)
@@ -73,7 +74,7 @@ extern unsigned long mmu_mapin_ram(void);
 extern void MMU_init_hw(void);
 extern unsigned long mmu_mapin_ram(void);
 
-#elif defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_PARAVIRT)
+#elif defined(CONFIG_FSL_BOOKE)
 #define flush_HPTE(pid, va, pg)	_tlbie(va, pid)
 extern void MMU_init_hw(void);
 extern unsigned long mmu_mapin_ram(void);
diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c
index 1b83ce3..db75bb7 100644
--- a/arch/powerpc/mm/pgtable_32.c
+++ b/arch/powerpc/mm/pgtable_32.c
@@ -48,7 +48,7 @@ EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */
 #define HAVE_BATS	1
 #endif
 
-#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_FSL_BOOKE) && !defined(CONFIG_WRHV)
 #define HAVE_TLBCAM	1
 #endif
 
@@ -78,7 +78,7 @@ extern unsigned long p_mapped_by_tlbcam(phys_addr_t pa);
 #define p_mapped_by_tlbcam(x)	(0UL)
 #endif /* HAVE_TLBCAM */
 
-#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_PARAVIRT)
+#if defined(CONFIG_PTE_64BIT) || defined(CONFIG_WRHV)
 /* 44x uses an 8kB pgdir because it has 8-byte Linux PTEs. */
 #define PGDIR_ORDER	1
 #else
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 9707113..232fc17 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -267,6 +267,7 @@ static const char *gfar_tx_intr = "tx";
 static const char *gfar_rx_intr = "rx";
 static const char *gfar_err_intr = "error";
 
+#ifdef CONFIG_WRHV
 const char * get_gfar_tx_intr(void)
 {
 	return gfar_tx_intr;
@@ -281,6 +282,7 @@ const char * get_gfar_err_intr(void)
 {
 	return gfar_err_intr;
 }
+#endif
 
 int paravirt_gfar_of_init(void)
 	__attribute__((weak, alias("native_gfar_of_init")));
-- 
1.6.6

