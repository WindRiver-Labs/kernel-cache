From 3a659910437a14be6d410a49ae94f9299f9766d9 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Thu, 15 Oct 2009 19:30:42 -0400
Subject: [PATCH 22/27] vbiPpcArch.h: relocate to sane dir with sane filename

Someone had already relocated the file to the appropriate
arch specific dir, but it was an older copy and still had
the non-linux-like filename.  Delete that and map the more
recent version into place, and point users at the new location.

  renamed:    include/vbi/ppc/vbiPpcArch.h -> arch/powerpc/include/asm/arch_vbi.h
  deleted:    arch/powerpc/include/asm/vbiPpcArch.h

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h   |  938 +++++++++++++++++++++++++++++++++
 arch/powerpc/include/asm/vbiPpcArch.h |  691 ------------------------
 arch/powerpc/kernel/head_wrhv.h       |    2 +-
 arch/powerpc/kernel/wrhv_entry_32.S   |    2 +-
 include/vbi/ppc/vbiPpcArch.h          |  938 ---------------------------------
 5 files changed, 940 insertions(+), 1631 deletions(-)
 create mode 100644 arch/powerpc/include/asm/arch_vbi.h
 delete mode 100644 arch/powerpc/include/asm/vbiPpcArch.h
 delete mode 100644 include/vbi/ppc/vbiPpcArch.h

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
new file mode 100644
index 0000000..e3c7800
--- /dev/null
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -0,0 +1,938 @@
+/* vbiPpcArch.h - PowerPC architecture specific definitions */
+
+/* Copyright 2009 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01u,08sep09,dtr  Add definitions for new API vbiExcOffsetsGet/Set.
+01t,28aug09,mmi  add MSG_HEADER definitions
+01s,26aug09,mmi  fix defect WIND00178026 and WIND00178028: remove extra ";"
+		 from VBI_STATUS_ADDR_GET (), VBI_CNTRL_ADDR_GET(), 
+		 VBI_CONFIG_ADDR_GET(). 
+01r,27jul09,mpk  add hardware register set to vbi
+01q,18jul09,mmi  add bsp server message layout
+01p,16jul09,mmi  initialize to zero the register loaded in intdisable field
+01o,15jul09,mmi  fix VBI_INT_VCORE_LOCK() error
+01n,14jul09,mmi  add macro to find base addresses for status, control and
+                 config
+01m,07jul09,mmi  fix comment of int locking macro
+01l,22jun09,mmi  add assembly macros to read regs.
+01k,11jun09,mmi  add interrupts macros
+01j,10jun09,mmi  add assembly macro's for context switch and interrupts
+01i,08jun09,md   add define for maximum number of cores
+01h,08jun09,mmi  update descriptions
+01g,25may09,md   add byte order define
+01f,09feb09,mmi  add defines for vbi exception management
+01e,29jan09,dtr  debug.
+01d,29jan09,dtr  Remove some old defs.
+01c,28jan09,dtr  Use new structures.
+01b,23jan09,mmi  add debug registers
+01a,21jan09,mmi  created
+*/
+
+#ifndef __INCvbiPpcArchh
+#define __INCvbiPpcArchh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* PPC uses big endian byte ordering */
+
+#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
+
+/* exceptions generated by the hypervisor */
+
+#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
+#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
+#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
+#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
+#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
+#define VBI_EXC_OFF_PROG	0x0700	/* program check */
+#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
+#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
+#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
+#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
+#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
+#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
+
+#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
+
+/* exception defines */
+
+#define ARCH_MAX_INTERRUPT		    36
+#define VBI_ARCH_EXC_TABLE_SIZE		    36
+#define VBI_ARCH_IRQ_TABLE_SIZE		    256
+
+/* VIOAPIC number of entries */
+
+#define VB_VIOAPIC_ENTRIES_SIZE		    64 
+
+#define _WRHV_ARCH_HAS_STATUS_REGS	    1
+#define _WRHV_ARCH_HAS_CTRL_REGS	    1
+
+#define VB_STATUS_REGS_OFFSET_BASE	 0
+#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
+#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
+#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
+#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
+#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
+#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
+#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
+#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
+#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
+#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
+#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
+#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
+#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
+#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
+#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
+#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
+#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
+#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
+#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
+#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
+#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
+#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
+#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
+#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
+#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
+#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
+#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
+#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
+#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
+#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
+#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
+#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
+#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
+#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
+#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
+#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
+#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
+#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
+#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
+#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
+
+
+#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
+
+
+#define VB_CONTROL_REGS_OFFSET_BASE	 0
+#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
+#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
+#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
+#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
+#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
+#define VB_CONTROL_SP			VB_CONTROL_R1
+#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
+#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
+#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
+#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
+#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
+#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
+#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
+#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
+#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
+#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
+#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
+#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
+#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
+#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
+#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
+#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
+#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
+#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
+#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
+#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
+#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
+#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
+#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
+#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
+#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
+#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
+#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
+#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
+#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
+#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
+#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
+
+/* status register size for ppc */
+
+#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
+
+/* mdio messages */
+#define MDIO_READ	    1
+#define MDIO_WRITE	    2
+#define MDIO_INT_ENABLE	    3
+#define MDIO_INT_DISABLE    4
+#define BSP_CLK_FREQ	    5
+
+#ifndef _ASMLANGUAGE
+
+#define VB_STATUS_REGS_ACCESS(base, field)	\
+	base->vbStatusRegs.field		
+
+#define VB_CONTROL_REGS_ACCESS(base, field)	\
+	base->vbControlRegs.field		
+
+/*******************************************************************************
+*
+* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
+*
+* Virtual board emulated control registers. These registers are used
+* by a guest running on hypervisor to configure the virtual CPU register.
+*
+* SYNOPSIS
+*
+* PPC Control structure graphical illustration
+*\cs
+*        _______________   
+*       |       PC      |   
+*       |---------------|
+*       |       MSR     |	    
+*       |---------------|
+*       |       CR      |
+*       |---------------|
+*       |		|
+*       |general purpose|
+*       |     r[0:13]   | 
+*       |		|
+*       |---------------|
+*       |emulated MSR   |
+*       |---------------|
+*       |       dbsr    |
+*       |---------------|
+*       | dbcr[0:2]     |
+*       |---------------|
+*       |IAC[1:2]       |
+*       |---------------|
+*       |DAC[1:2]       |
+*       |---------------|
+*       |reserved[0:9]  |
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's control C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbArchControlRegs
+*    {
+*
+*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
+*
+*    uint32_t srr0;	/@  0: PC		    @/
+*    uint32_t srr1;	/@  1: MSR		    @/
+*    uint32_t cr;	/@  2: condition registers	    @/
+*    uint32_t r0;	/@  3: General register R0	    @/
+*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
+*    uint32_t r2;	/@  5: General register R2	    @/
+*    uint32_t r3;	/@  6: General register R3	    @/
+*    uint32_t r4;	/@  7: General register R4	    @/
+*    uint32_t r5;	/@  8: General register R5	    @/
+*    uint32_t r6;	/@  9: General register R6	    @/
+*    uint32_t r7;	/@ 10: General register R7	    @/
+*    uint32_t r8;	/@ 11: General register R8	    @/
+*    uint32_t r9;	/@ 12: General register R9	    @/
+*    uint32_t r10;	/@ 13: General register R10	    @/
+*    uint32_t r11;	/@ 14: General register R11	    @/
+*    uint32_t r12;	/@ 15: General register R12	    @/
+*    uint32_t r13;	/@ 16: General register R13	    @/
+*
+*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
+*
+*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbsr; /@ 18 - debug status register		    @/
+*
+*    /@ Debug control registers			        @/
+*    
+*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
+*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
+*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
+*
+*    /@ instruction address compare registers IAC1-IAC2		    @/
+*
+*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
+*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
+*
+*    /@ data address compare registers DAC1-DAC2.	        @/
+*
+*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
+*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
+*
+*    /@ reserved fields for future use			    @/
+*
+*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
+*    } VB_ARCH_CONTROL_REGS;
+*
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*\COMMAND
+*/
+
+typedef struct vbArchControlRegs
+    {
+
+    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
+
+    uint32_t srr0;		/*  0: PC */
+    uint32_t srr1;		/*  1: MSR */
+    uint32_t cr;		/*  2: condition registers */
+    uint32_t r0;		/*  3: General register R0 */
+    uint32_t sp;		/*  4: General register R1 (stack pointer) */
+    uint32_t r2;		/*  5: General register R2 */
+    uint32_t r3;		/*  6: General register R3 */
+    uint32_t r4;		/*  7: General register R4 */
+    uint32_t r5;		/*  8: General register R5 */
+    uint32_t r6;		/*  9: General register R6 */
+    uint32_t r7;		/* 10: General register R7 */
+    uint32_t r8;		/* 11: General register R8 */
+    uint32_t r9;		/* 12: General register R9 */
+    uint32_t r10;		/* 13: General register R10 */
+    uint32_t r11;		/* 14: General register R11 */
+    uint32_t r12;		/* 15: General register R12 */
+    uint32_t r13;		/* 16: General register R13 */
+
+    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
+
+    uint32_t emsr;		/* 17: emulated MSR register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbsr; /* 18 - debug status register */
+
+    /* Debug control registers */
+    
+    uint32_t     dbcr0; /* 19 - debug control register 0 */
+    uint32_t     dbcr1; /* 20 - debug control register 1 */
+    uint32_t     dbcr2; /* 21 - debug control register 2 */
+
+    /* instruction address compare registers IAC1-IAC2 */
+
+    uint32_t     iac1; /* 22 - instructions access control 1 */
+    uint32_t     iac2; /* 23 - instructions access control 2 */
+
+    /* data address compare registers DAC1-DAC2. */
+
+    uint32_t     dac1; /* 24 - instructions access control 3 */
+    uint32_t     dac2; /* 25 - instructions access control 4 */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved[10];      /* 26: Reserved */ 
+    } VB_ARCH_CONTROL_REGS;
+
+/*******************************************************************************
+*
+* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
+*
+* Virtual board emulated CPU status registers
+*
+* SYNOPSIS
+*
+* PPC Status structure graphical illustration
+*\cs
+*        _______________   ---------------------------
+*       |    SRR0       |   
+*       |---------------|
+*       |    SRR1       |   Registers save by WRHV	
+*       |---------------|   before injecting an exception/interrupt
+*       |    CR		|
+*       |---------------|
+*       |    LR		|
+*       |---------------|
+*       |    r3		| 
+*       |---------------|
+*       |    r4         |
+*       |---------------|   ---------------------------
+*	|    mcsrr0	|	
+*       |---------------|  Registers saved duing exception handling
+*       |    mcssr1     |
+*       |---------------|
+*       |    esr        |
+*       |---------------|
+*       |    mcsr       |
+*       |---------------|
+*       |    mcar       |
+*       |---------------|
+*       |    dear       |
+*       |---------------|
+*       |    emsr       |
+*       |---------------|
+*       |    esrr0      |
+*       |---------------|
+*       |    esrr1      |
+*       |---------------|    -------------------------
+*       | reserved[8]   |      8 x 32bits for future enhencements
+*       |---------------|    -------------------------
+*       |    svr        |
+*       |---------------|
+*       |    pir        |
+*       |---------------|
+*       |    pvr        |    Configuration registers updated
+*       |---------------|    upon board creation    
+*       |    hid0       |  
+*       |---------------|
+*       |    hid1       |
+*       |---------------|
+*       |    buscr      |
+*       |---------------|       
+*       |    l1csr0     |
+*       |---------------|
+*       |    l1csr1     |
+*       |---------------|   --------------------------
+*       | reserved[0:8] | 9x 32bit
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_ARCH_STATUS_REGS structure definition
+*
+* typedef struct archStatusRegs
+*    {
+*
+*    /@ 
+*     @ registers saved by WRHV for all interrupts exceptions
+*     @ before setting the PC in the virtual board to the exception/interrupt
+*     @ vector address
+*     @/
+*
+*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
+*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
+*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
+*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
+*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
+*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
+*
+*    /@ Registers saved by WRHV during exception processing only    @/
+*
+*    uint32_t mcsrr0; /@  6:			    @/
+*    uint32_t mcsrr1; /@  7:			    @/
+*    uint32_t esr;    /@  8:			    @/
+*    uint32_t mcsr;   /@  9:			    @/
+*    uint32_t mcar;   /@ 10			@/
+*    uint32_t dear;   /@ 11:			    @/
+*    uint32_t emsr;   /@ 12:			    @/
+*    uint32_t esrr0;  /@ 13:			    @/
+*    uint32_t esrr1;  /@ 14:			    @/
+*
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved1[8]; /@ 15 - 22			@/
+*
+*    /@ Configuration registers (only updated upon board creation   @/
+*
+*    uint32_t svr;     /@ 23			    @/     
+*    uint32_t pir;     /@ 24			    @/
+*    uint32_t pvr;     /@ 25			    @/  
+*    uint32_t hid0;    /@ 26			    @/
+*    uint32_t hid1;    /@ 27			    @/
+*    uint32_t bucsr;   /@ 28			    @/
+*    uint32_t l1csr0;  /@ 29			    @/
+*    uint32_t l1csr1;  /@ 30			    @/
+*    
+*    /@ reserved fields for future use			@/
+*
+*    uint32_t reserved2[9]; /@ 31 - 39			@/
+*
+*    } VB_ARCH_STATUS_REGS; 
+*
+*
+*\ce
+*
+* SEE ALSO: VB_STATUS 
+*\COMMAND
+*/
+
+typedef struct archStatusRegs
+    {
+
+    /* 
+     * registers saved by Razor for all interrupts exceptions
+     * before setting the PC in the virtual board to the exception/interrupt
+     * vector address
+     */
+
+    uint32_t srr0; /* 0: PC at time of the interrupt */
+    uint32_t srr1; /* 1: MSR at time of the interrupt */
+    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
+    uint32_t lr;   /* 3: Link register at time of the interrupt */
+    uint32_t r3;   /* 4: R3 at time of the interrupt */
+    uint32_t r4;   /* 5: R4 at time of the interrupt */
+
+    /* Registers saved by Razor during exception processing only */
+
+    uint32_t mcsrr0; /*  6: */
+    uint32_t mcsrr1; /*  7: */
+    uint32_t esr;    /*  8: */
+    uint32_t mcsr;   /*  9: */
+    uint32_t mcar;   /* 10  */
+    uint32_t dear;   /* 11: */
+    uint32_t emsr;   /* 12: */
+    uint32_t esrr0;  /* 13: */
+    uint32_t esrr1;  /* 14: */
+
+/* 
+ * keep this part in a separate structure in order to keep the offsets
+ * to remain the same as in VB_STATUS
+ */
+
+    /* reserved fields for future use */
+
+    uint32_t reserved1[8]; /* 15 - 22  */
+
+    /* Configuration registers (only updated upon board creation */
+
+    uint32_t svr;     /* 23 */     
+    uint32_t pir;     /* 24 */
+    uint32_t pvr;     /* 25 */  
+    uint32_t hid0;    /* 26 */
+    uint32_t hid1;    /* 27 */
+    uint32_t bucsr;   /* 28 */
+    uint32_t l1csr0;  /* 29 */
+    uint32_t l1csr1;  /* 30 */
+    
+    /* reserved fields for future use */
+
+    uint32_t reserved2[9]; /* 31 - 39 */
+
+    } VB_ARCH_STATUS_REGS; 
+
+
+/*******************************************************************************
+*
+* VBI_HREG_SET - hardware register set, for read/write
+*
+* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
+* another VB
+* 
+* SYNOPSIS
+*
+* VB hardware register set C data structure type definition
+*
+*\cs
+*
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VBI_HREG_SET;
+* 
+*
+*\ce
+* SEE ALSO: NONE
+* 
+*/
+
+#define GREG_NUM	32	/* has 32 32/64-bit data registers */
+
+typedef struct
+    {
+    uint32_t gpr[GREG_NUM];	/* general purpose registers */
+    uint32_t msr;		/* machine state register */
+    uint32_t lr;		/* link register */
+    uint32_t ctr;		/* count register */
+    uint32_t pc;		/* program counter */
+    uint32_t cr;		/* condition register */
+    uint32_t xer;		/* fixed-point exception register */
+    uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
+    uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
+    } HREG_SET;
+
+/* VBI_HREG_SET is same as HREG_SET in ppc */
+typedef HREG_SET VBI_HREG_SET;
+
+/* mdio messages */
+
+#define VBI_MDIO_READ           MDIO_READ
+#define VBI_MDIO_WRITE          MDIO_WRITE
+#define VBI_BSP_CLK_FREQ        BSP_CLK_FREQ
+
+/* This should exceed the number of IVOR registers defined in the hardware 
+* It also defined the size of the excVectorTable size 
+* VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000 */
+#define VBI_ARCH_MAX_EXC_OFFSETS	64	
+
+typedef struct
+    {
+    uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
+    } VBI_EXC_OFFSETS_TABLE;
+
+#ifdef CONFIG_WRHV
+typedef int32_t  status_t;      /* operation/function status */
+#endif /* CONFIG_WRHV */
+
+extern status_t vbiExcOffsetsSet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+extern status_t vbiExcOffsetsGet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
+
+/* common system wide message header structure */
+
+typedef struct vbi_msg_header {
+    uint32_t msgId;	/* message type identification */
+    uint32_t msgArg;	/* argument associated with message type */
+} VBI_MSG_HEADER;
+
+/* request message */
+
+typedef struct 
+    {
+    VBI_MSG_HEADER hdr;			/* message header */
+    uint32_t   request;			/* request type */
+
+    union 
+	{
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t phyAddr;
+	    uint32_t regNum;
+	    uint32_t page;
+	    } mdioRead;
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t phyAddr;
+	    uint32_t regNum;
+	    uint32_t page;
+	    uint32_t dataVal;
+	    } mdioWrite;
+#if 0 /* not supported for now */
+    	struct 
+	    {
+	    uint32_t bus;		
+	    uint32_t vbIntNum;
+	    HY_CTX *pCtx;
+	    } mdioIntEnable;
+    	struct 
+	    {
+	    uint32_t bus;	
+	    uint32_t vbIntNum;
+	    HY_CTX *pCtx;
+	    } mdioIntDisable;
+#endif
+	} arg;				
+    
+    } VBI_BSP_MSG;
+
+typedef struct 
+    {
+    VBI_MSG_HEADER hdr;			/* message header */
+    uint32_t   status;			/* request completion status */
+    uint32_t   dataVal;
+    } VBI_BSP_MSG_REPLY;
+
+#else /*_ASMLANGUAGE */
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+#define VBI_CTX_LOAD(reg)				    \
+	lis	reg, HI(VBI_SYS_ctx_load);		    \
+	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
+	sc
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
+	li	reg1, -1;				\
+        lis     reg2, HIADJ(wrhvVbControl);		\
+        lwz     reg2, LO(wrhvVbControl)(reg2);		\
+        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
+        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
+	lis	reg0, HIADJ(wrhvVbControl);			\
+	lwz	reg0, LO(wrhvVbControl)(reg0);			\
+	li	reg1, 0;					\
+	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
+checkIntVcorePending:						\
+	lis	reg0, HIADJ(wrhvVbStatus);			\
+	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
+	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
+								\
+	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
+	beq     endIntVcoreLock;				\
+	lis	r0, HI(VBI_SYS_int_enable);			\
+	ori	r0, r0, LO(VBI_SYS_int_enable);			\
+	sc;							\
+	b	checkIntVcorePending;				\
+endIntVcoreLock:
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+#define VBI_INT_VCORE_STATE_GET(reg0)				\
+	VBI_CNTRL_ADDR_GET(reg0);				\
+	lwz	reg0, VB_CONTROL_INT_DISABLE(reg0);		
+
+/*******************************************************************************
+*
+* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
+*
+* This macro returns the base address of the configuration structure of the 
+* running core. 
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro for PPC assembly code
+*
+* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CONFIG_ADDR_GET(reg)		    \
+        lis     reg, HIADJ(wrhvVbConfig);	    \
+        lwz     reg, LO(wrhvVbConfig)(reg)	    
+
+/*******************************************************************************
+*
+* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
+*
+* This macro returns the base address of the running virtual core's control
+* structure.
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_CNTRL_ADDR_GET(reg)			    \
+        lis     reg, HIADJ(wrhvVbControl);	    \
+        lwz     reg, LO(wrhvVbControl)(reg) 	     
+
+/*******************************************************************************
+*
+* VBI_STATUS_ADDR_GET - Get virtual core status structure address
+*
+* This macro returns the base address of the status structure of currently
+* running core. This structure is read-only and contains a description of
+* the running virtual core. Hypervisor uses this data to inform the
+* virtual board time variant data that may be updated during hypervisor context
+* Switch. Typical that are available in the status structure are:
+*
+*\ms
+*\m - 
+*Timer tick counter
+*\m -
+*Pending interrupt state
+*\m -
+*The interrupt state before this core was schedule
+*\m -
+*VMMU configuration
+*\m -
+*Virtual core registers state
+*
+* SYNOPSIS
+*
+*\cs
+*
+*  C Preprocessor Macro
+*
+* VB_STATUS * VBI_STATUS_ADDR_GET(void)
+*
+*\ce
+*
+* RETURNS: virtual core configuration structure base address
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+#define VBI_STATUS_ADDR_GET(reg)			    \
+        lis     reg, HIADJ(wrhvVbStatus);		    \
+        lwz     reg, LO(wrhvVbStatus)(reg)	     
+
+#endif /*_ASMLANGUAGE */
+    
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* __INCvbiPpcArchh */
diff --git a/arch/powerpc/include/asm/vbiPpcArch.h b/arch/powerpc/include/asm/vbiPpcArch.h
deleted file mode 100644
index ac30c7d..0000000
--- a/arch/powerpc/include/asm/vbiPpcArch.h
+++ /dev/null
@@ -1,691 +0,0 @@
-/* vbiPpcArch.h - PowerPC architecture specific definitions */
-
-/* Copyright 2008 Wind River Systems, Inc. */
-
-/*
-modification history
---------------------
-01m,07jul09,mmi  fix comment of int locking macro
-01l,22jun09,mmi  add assembly macros to read regs.
-01k,11jun09,mmi  add interrupts macros
-01j,10jun09,mmi  add assembly macro's for context switch and interrupts
-01i,08jun09,md   add define for maximum number of cores
-01h,08jun09,mmi  update descriptions
-01g,25may09,md   add byte order define
-01f,09feb09,mmi  add defines for vbi exception management
-01e,29jan09,dtr  debug.
-01d,29jan09,dtr  Remove some old defs.
-01c,28jan09,dtr  Use new structures.
-01b,23jan09,mmi  add debug registers
-01a,21jan09,mmi  created
-*/
-
-#ifndef __INCvbiPpcArchh
-#define __INCvbiPpcArchh
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* PPC uses big endian byte ordering */
-
-#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
-
-/* exceptions generated by the hypervisor */
-
-#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
-#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
-#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
-#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
-#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
-#define VBI_EXC_OFF_PROG	0x0700	/* program check */
-#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
-#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
-#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
-#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
-#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
-#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
-
-#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
-
-/* exception defines */
-
-#define ARCH_MAX_INTERRUPT		    36
-#define VBI_ARCH_EXC_TABLE_SIZE		    36
-#define VBI_ARCH_IRQ_TABLE_SIZE		    256
-
-/* VIOAPIC number of entries */
-
-#define VB_VIOAPIC_ENTRIES_SIZE		    64 
-
-#define _WRHV_ARCH_HAS_STATUS_REGS	    1
-#define _WRHV_ARCH_HAS_CTRL_REGS	    1
-
-#define VB_STATUS_REGS_OFFSET_BASE	 0
-#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
-#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
-#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
-#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
-#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
-#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
-#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
-#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
-#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
-#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
-#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
-#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
-#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
-#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
-#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
-#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
-#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
-#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
-#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
-#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
-#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
-#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
-#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
-#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
-#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
-#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
-#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
-#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
-#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
-#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
-#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
-#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
-#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
-#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
-#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
-#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
-#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
-#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
-#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
-#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
-
-
-#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
-
-/* Bit Mask definitions for VB_STATUS_INT_PENDING */
-
-#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
-#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
-
-
-#define VB_CONTROL_REGS_OFFSET_BASE	 0
-#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
-#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
-#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
-#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
-#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
-#define VB_CONTROL_SP			VB_CONTROL_R1
-#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
-#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
-#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
-#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
-#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
-#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
-#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
-#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
-#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
-#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
-#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
-#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
-#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
-#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
-#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
-#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
-#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
-#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
-#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
-#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
-#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
-#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
-#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
-#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
-#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
-#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
-#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
-#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
-#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
-#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
-#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
-
-/* status register size for ppc */
-
-#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
-
-#ifndef _ASMLANGUAGE
-
-#define VB_STATUS_REGS_ACCESS(base, field)	\
-	base->vbStatusRegs.field		
-
-#define VB_CONTROL_REGS_ACCESS(base, field)	\
-	base->vbControlRegs.field		
-
-/*******************************************************************************
-*
-* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
-*
-* Virtual board emulated control registers. These registers are used
-* by a guest running on hypervisor to configure the virtual CPU register.
-*
-* SYNOPSIS
-*
-* PPC Control structure graphical illustration
-*\cs
-*        _______________   
-*       |       PC      |   
-*       |---------------|
-*       |       MSR     |	    
-*       |---------------|
-*       |       CR      |
-*       |---------------|
-*       |		|
-*       |general purpose|
-*       |     r[0:13]   | 
-*       |		|
-*       |---------------|
-*       |emulated MSR   |
-*       |---------------|
-*       |       dbsr    |
-*       |---------------|
-*       | dbcr[0:2]     |
-*       |---------------|
-*       |IAC[1:2]       |
-*       |---------------|
-*       |DAC[1:2]       |
-*       |---------------|
-*       |reserved[0:9]  |
-*       |---------------|
-*
-*\ce
-*
-* Virtual core's control C data structure type definition
-*
-*\cs
-* VB_STATUS structure definition
-*
-* typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
-*
-*    uint32_t srr0;	/@  0: PC		    @/
-*    uint32_t srr1;	/@  1: MSR		    @/
-*    uint32_t cr;	/@  2: condition registers	    @/
-*    uint32_t r0;	/@  3: General register R0	    @/
-*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;	/@  5: General register R2	    @/
-*    uint32_t r3;	/@  6: General register R3	    @/
-*    uint32_t r4;	/@  7: General register R4	    @/
-*    uint32_t r5;	/@  8: General register R5	    @/
-*    uint32_t r6;	/@  9: General register R6	    @/
-*    uint32_t r7;	/@ 10: General register R7	    @/
-*    uint32_t r8;	/@ 11: General register R8	    @/
-*    uint32_t r9;	/@ 12: General register R9	    @/
-*    uint32_t r10;	/@ 13: General register R10	    @/
-*    uint32_t r11;	/@ 14: General register R11	    @/
-*    uint32_t r12;	/@ 15: General register R12	    @/
-*    uint32_t r13;	/@ 16: General register R13	    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbsr; /@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2		    @/
-*
-*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
-*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
-*
-*    /@ data address compare registers DAC1-DAC2.	        @/
-*
-*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
-*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
-*
-*    /@ reserved fields for future use			    @/
-*
-*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*
-*\ce
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-*\COMMAND
-*/
-
-typedef struct vbArchControlRegs
-    {
-
-    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
-
-    uint32_t srr0;		/*  0: PC */
-    uint32_t srr1;		/*  1: MSR */
-    uint32_t cr;		/*  2: condition registers */
-    uint32_t r0;		/*  3: General register R0 */
-    uint32_t sp;		/*  4: General register R1 (stack pointer) */
-    uint32_t r2;		/*  5: General register R2 */
-    uint32_t r3;		/*  6: General register R3 */
-    uint32_t r4;		/*  7: General register R4 */
-    uint32_t r5;		/*  8: General register R5 */
-    uint32_t r6;		/*  9: General register R6 */
-    uint32_t r7;		/* 10: General register R7 */
-    uint32_t r8;		/* 11: General register R8 */
-    uint32_t r9;		/* 12: General register R9 */
-    uint32_t r10;		/* 13: General register R10 */
-    uint32_t r11;		/* 14: General register R11 */
-    uint32_t r12;		/* 15: General register R12 */
-    uint32_t r13;		/* 16: General register R13 */
-
-    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
-
-    uint32_t emsr;		/* 17: emulated MSR register */
-
-    /* Debug control registers */
-    
-    uint32_t     dbsr; /* 18 - debug status register */
-
-    /* Debug control registers */
-    
-    uint32_t     dbcr0; /* 19 - debug control register 0 */
-    uint32_t     dbcr1; /* 20 - debug control register 1 */
-    uint32_t     dbcr2; /* 21 - debug control register 2 */
-
-    /* instruction address compare registers IAC1-IAC2 */
-
-    uint32_t     iac1; /* 22 - instructions access control 1 */
-    uint32_t     iac2; /* 23 - instructions access control 2 */
-
-    /* data address compare registers DAC1-DAC2. */
-
-    uint32_t     dac1; /* 24 - instructions access control 3 */
-    uint32_t     dac2; /* 25 - instructions access control 4 */
-
-    /* reserved fields for future use */
-
-    uint32_t reserved[10];      /* 26: Reserved */ 
-    } VB_ARCH_CONTROL_REGS;
-
-/*******************************************************************************
-*
-* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
-*
-* Virtual board emulated CPU status registers
-*
-* SYNOPSIS
-*
-* PPC Status structure graphical illustration
-*\cs
-*        _______________   ---------------------------
-*       |    SRR0       |   
-*       |---------------|
-*       |    SRR1       |   Registers save by WRHV	
-*       |---------------|   before injecting an exception/interrupt
-*       |    CR		|
-*       |---------------|
-*       |    LR		|
-*       |---------------|
-*       |    r3		| 
-*       |---------------|
-*       |    r4         |
-*       |---------------|   ---------------------------
-*	|    mcsrr0	|	
-*       |---------------|  Registers saved duing exception handling
-*       |    mcssr1     |
-*       |---------------|
-*       |    esr        |
-*       |---------------|
-*       |    mcsr       |
-*       |---------------|
-*       |    mcar       |
-*       |---------------|
-*       |    dear       |
-*       |---------------|
-*       |    emsr       |
-*       |---------------|
-*       |    esrr0      |
-*       |---------------|
-*       |    esrr1      |
-*       |---------------|    -------------------------
-*       | reserved[8]   |      8 x 32bits for future enhencements
-*       |---------------|    -------------------------
-*       |    svr        |
-*       |---------------|
-*       |    pir        |
-*       |---------------|
-*       |    pvr        |    Configuration registers updated
-*       |---------------|    upon board creation    
-*       |    hid0       |  
-*       |---------------|
-*       |    hid1       |
-*       |---------------|
-*       |    buscr      |
-*       |---------------|       
-*       |    l1csr0     |
-*       |---------------|
-*       |    l1csr1     |
-*       |---------------|   --------------------------
-*       | reserved[0:8] | 9x 32bit
-*       |---------------|
-*
-*\ce
-*
-* Virtual core's status C data structure type definition
-*
-*\cs
-* VB_ARCH_STATUS_REGS structure definition
-*
-* typedef struct archStatusRegs
-*    {
-*
-*    /@ 
-*     @ registers saved by WRHV for all interrupts exceptions
-*     @ before setting the PC in the virtual board to the exception/interrupt
-*     @ vector address
-*     @/
-*
-*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
-*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
-*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
-*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
-*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
-*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
-*
-*    /@ Registers saved by WRHV during exception processing only    @/
-*
-*    uint32_t mcsrr0; /@  6:			    @/
-*    uint32_t mcsrr1; /@  7:			    @/
-*    uint32_t esr;    /@  8:			    @/
-*    uint32_t mcsr;   /@  9:			    @/
-*    uint32_t mcar;   /@ 10			@/
-*    uint32_t dear;   /@ 11:			    @/
-*    uint32_t emsr;   /@ 12:			    @/
-*    uint32_t esrr0;  /@ 13:			    @/
-*    uint32_t esrr1;  /@ 14:			    @/
-*
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved1[8]; /@ 15 - 22			@/
-*
-*    /@ Configuration registers (only updated upon board creation   @/
-*
-*    uint32_t svr;     /@ 23			    @/     
-*    uint32_t pir;     /@ 24			    @/
-*    uint32_t pvr;     /@ 25			    @/  
-*    uint32_t hid0;    /@ 26			    @/
-*    uint32_t hid1;    /@ 27			    @/
-*    uint32_t bucsr;   /@ 28			    @/
-*    uint32_t l1csr0;  /@ 29			    @/
-*    uint32_t l1csr1;  /@ 30			    @/
-*    
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved2[9]; /@ 31 - 39			@/
-*
-*    } VB_ARCH_STATUS_REGS; 
-*
-*
-*\ce
-*
-* SEE ALSO: VB_STATUS 
-*\COMMAND
-*/
-
-typedef struct archStatusRegs
-    {
-
-    /* 
-     * registers saved by Razor for all interrupts exceptions
-     * before setting the PC in the virtual board to the exception/interrupt
-     * vector address
-     */
-
-    uint32_t srr0; /* 0: PC at time of the interrupt */
-    uint32_t srr1; /* 1: MSR at time of the interrupt */
-    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
-    uint32_t lr;   /* 3: Link register at time of the interrupt */
-    uint32_t r3;   /* 4: R3 at time of the interrupt */
-    uint32_t r4;   /* 5: R4 at time of the interrupt */
-
-    /* Registers saved by Razor during exception processing only */
-
-    uint32_t mcsrr0; /*  6: */
-    uint32_t mcsrr1; /*  7: */
-    uint32_t esr;    /*  8: */
-    uint32_t mcsr;   /*  9: */
-    uint32_t mcar;   /* 10  */
-    uint32_t dear;   /* 11: */
-    uint32_t emsr;   /* 12: */
-    uint32_t esrr0;  /* 13: */
-    uint32_t esrr1;  /* 14: */
-
-/* 
- * keep this part in a separate structure in order to keep the offsets
- * to remain the same as in VB_STATUS
- */
-
-    /* reserved fields for future use */
-
-    uint32_t reserved1[8]; /* 15 - 22  */
-
-    /* Configuration registers (only updated upon board creation */
-
-    uint32_t svr;     /* 23 */     
-    uint32_t pir;     /* 24 */
-    uint32_t pvr;     /* 25 */  
-    uint32_t hid0;    /* 26 */
-    uint32_t hid1;    /* 27 */
-    uint32_t bucsr;   /* 28 */
-    uint32_t l1csr0;  /* 29 */
-    uint32_t l1csr1;  /* 30 */
-    
-    /* reserved fields for future use */
-
-    uint32_t reserved2[9]; /* 31 - 39 */
-
-    } VB_ARCH_STATUS_REGS; 
-
-#else /*_ASMLANGUAGE */
-
-/*******************************************************************************
-*
-* VBI_CTX_LOAD - Load a guest context
-*
-* This routine is implemented as an assembly MACRO since it's callers can't
-* reference C functions. This MACRO  makes a hypercall to load a context for a guest
-* OS. The guest OS running on the core is expected to store a set of registers that
-* represent the new context to load in the it's control structure then call 
-* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
-* loaded from the control structure:
-*
-*\ms
-*\m 1 -
-* VB_CONTROL_SRR0	     ------->  SRR0
-*\m 2 -
-* VB_CONTROL_SRR1	     -------> SRR1 
-*\m 3 -
-* VB_CONTROL_CR		     -------> CR
-*\m 4 -
-* VB_CONTROL_R0		     -------> R0
-*\m 5 -
-* VB_CONTROL_EMSR	     -------> MSR 
-*\m 6 -
-* VB_CONTROL_DBCR0	     -------> DBCR0 
-*\m 7 -
-* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
-* If interrupts are being reenabled then we ensure that any pending interrupts are
-* delivered before the new context is actived.
-*
-* Note that registers that are not saved by Hypervisor must be loaded by the guest
-* OS.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* void  VBI_CTX_LOAD () 
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
-*           VBI_INT_VCORE_STATE_GET()
-*/
-
-#define VBI_CTX_LOAD(reg)				    \
-	lis	reg, HI(VBI_SYS_ctx_load);		    \
-	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
-	sc
-
-/******************************************************************************
-*
-* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
-*
-* This MACRO disables the currently running core interrupts and returns the
-* previous interrupts state. The interrupt status field in wrhvVbControl
-* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
-* interrupts state is loaded to the register passed in as the first argument to
-* this MACRO. 
-* A hypercall is not needed to perform this operation. 
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
-*	{
-*	load -1 to reg1
-*	load wrhvVbControl address to reg2
-*       read the previous value and store in reg0
-*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
-*	}
-*\ce
-*
-* RETURNS: TRUE is interrupts were locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
-	li	reg1, -1;				\
-        lis     reg2, HIADJ(wrhvVbControl);		\
-        lwz     reg2, LO(wrhvVbControl)(reg2);		\
-        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
-        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
-*
-* This MACRO is implemented in assembly to enable a core's interrupts. It
-* enables the interrupts by clearing to zero the value in the core's control
-* structure and and makes a fast hypercall if need be. A hypercall is made only
-* if found that interrupts are pending. The pending interrupts are checked by
-* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
-* positive integer greater than zero indicates that interrupts are pending
-* which causes this macro to make a hypercall in order to drain the pending
-* interrupts. This MACRO expects two general purpose registers. The first 
-* register is used to load the value to store and the second is used for
-* holding the destination address of the control or status structure.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
-*	{
-*	load "0" to reg1
-*	load address of wrhvVbControl in reg0 
-*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
-*
-* checkStatus:
-*	load address of wrhvVbStatus in reg0
-*       load VB_STATUS_INT_PENDING(reg0) in reg1
-*       check if reg1 is equal to zero
-*       if true return
-*	otherwise send an hypercall 
-*       go to checkStatus
-*	}
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
-	lis	reg0, HIADJ(wrhvVbControl);			\
-	lwz	reg0, LO(wrhvVbControl)(reg0);			\
-	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
-checkIntVcorePending:						\
-	lis	reg0, HIADJ(wrhvVbStatus);			\
-	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
-	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
-								\
-	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
-	beq     endIntVcoreLock;				\
-	lis	r0, HI(VBI_SYS_int_enable);			\
-	ori	r0, r0, LO(VBI_SYS_int_enable);			\
-	sc;							\
-	b	checkIntVcorePending;				\
-endIntVcoreLock:
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_STATE_GET - Get interrupts state
-*
-* This MACRO is implemented in assembly to read the interrupt state of the
-* currently running core. It relies on a passed in general purpose register
-* to store the current state of interrupts. The status is -1 if locked
-* otherwise 0.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_STATE_GET (reg0)
-*	{
-*       Load the interrupt status from wrhvVbControl to reg0
-*	}
-*\ce
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
-*/
-
-#define VBI_INT_VCORE_STATE_GET(reg0)				\
-	lis	reg0, HIADJ(wrhvVbControl);			\
-	lwz	reg0, LO(wrhvVbControl)(reg0);			\
-	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
-
-#endif /*_ASMLANGUAGE */
-    
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __INCvbiPpcArchh */
diff --git a/arch/powerpc/kernel/head_wrhv.h b/arch/powerpc/kernel/head_wrhv.h
index 83da0e0..5615acd 100644
--- a/arch/powerpc/kernel/head_wrhv.h
+++ b/arch/powerpc/kernel/head_wrhv.h
@@ -15,7 +15,7 @@
 #ifndef __HEAD_WRHV_H__
 #define __HEAD_WRHV_H__
 
-#include <asm/vbiPpcArch.h>
+#include <asm/arch_vbi.h>
 
 	/* Interrupts are disabled by hypervisor at this entry point.
 	 * It puts the following registers into the status page:
diff --git a/arch/powerpc/kernel/wrhv_entry_32.S b/arch/powerpc/kernel/wrhv_entry_32.S
index 061c067..1c060bb 100644
--- a/arch/powerpc/kernel/wrhv_entry_32.S
+++ b/arch/powerpc/kernel/wrhv_entry_32.S
@@ -36,7 +36,7 @@
 #include <asm/ftrace.h>
 #ifdef CONFIG_WRHV
 #include <vbi/interface.h>
-#include <asm/vbiPpcArch.h>
+#include <asm/arch_vbi.h>
 #include <vbi/syscalls.h>
 #endif /* CONFIG_WRHV */
 
diff --git a/include/vbi/ppc/vbiPpcArch.h b/include/vbi/ppc/vbiPpcArch.h
deleted file mode 100644
index e3c7800..0000000
--- a/include/vbi/ppc/vbiPpcArch.h
+++ /dev/null
@@ -1,938 +0,0 @@
-/* vbiPpcArch.h - PowerPC architecture specific definitions */
-
-/* Copyright 2009 Wind River Systems, Inc. */
-
-/*
-modification history
---------------------
-01u,08sep09,dtr  Add definitions for new API vbiExcOffsetsGet/Set.
-01t,28aug09,mmi  add MSG_HEADER definitions
-01s,26aug09,mmi  fix defect WIND00178026 and WIND00178028: remove extra ";"
-		 from VBI_STATUS_ADDR_GET (), VBI_CNTRL_ADDR_GET(), 
-		 VBI_CONFIG_ADDR_GET(). 
-01r,27jul09,mpk  add hardware register set to vbi
-01q,18jul09,mmi  add bsp server message layout
-01p,16jul09,mmi  initialize to zero the register loaded in intdisable field
-01o,15jul09,mmi  fix VBI_INT_VCORE_LOCK() error
-01n,14jul09,mmi  add macro to find base addresses for status, control and
-                 config
-01m,07jul09,mmi  fix comment of int locking macro
-01l,22jun09,mmi  add assembly macros to read regs.
-01k,11jun09,mmi  add interrupts macros
-01j,10jun09,mmi  add assembly macro's for context switch and interrupts
-01i,08jun09,md   add define for maximum number of cores
-01h,08jun09,mmi  update descriptions
-01g,25may09,md   add byte order define
-01f,09feb09,mmi  add defines for vbi exception management
-01e,29jan09,dtr  debug.
-01d,29jan09,dtr  Remove some old defs.
-01c,28jan09,dtr  Use new structures.
-01b,23jan09,mmi  add debug registers
-01a,21jan09,mmi  created
-*/
-
-#ifndef __INCvbiPpcArchh
-#define __INCvbiPpcArchh
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* PPC uses big endian byte ordering */
-
-#define __VBI_BYTE_ORDER __VBI_BIG_ENDIAN
-
-/* exceptions generated by the hypervisor */
-
-#define VBI_EXC_OFF_MACH	0x0200	/* machine check */
-#define VBI_EXC_OFF_DATA	0x0300	/* data storage */
-#define VBI_EXC_OFF_INST	0x0400	/* instruction storage */
-#define VBI_EXC_OFF_INTR	0x0500	/* external interrupt*/
-#define VBI_EXC_OFF_ALIGN	0x0600	/* alignment error */
-#define VBI_EXC_OFF_PROG	0x0700	/* program check */
-#define VBI_EXC_OFF_FPU		0x0800	/* floating point */
-#define VBI_EXC_OFF_SYSCALL	0x0900	/* system call */
-#define VBI_EXC_OFF_DATA_MISS	0x0e00	/* MMU data miss */
-#define VBI_EXC_OFF_INST_MISS	0x0f00	/* MMU instruction miss*/
-#define VBI_EXC_OFF_DECR	0x0b00	/* decrementer */
-#define VBI_CLOCK_TIMER_VECTOR  (VBI_EXC_OFF_DECR >> 8)
-
-#define	VBI_MAX_CORES		    8	/* maximum number of virtual cores */
-
-/* exception defines */
-
-#define ARCH_MAX_INTERRUPT		    36
-#define VBI_ARCH_EXC_TABLE_SIZE		    36
-#define VBI_ARCH_IRQ_TABLE_SIZE		    256
-
-/* VIOAPIC number of entries */
-
-#define VB_VIOAPIC_ENTRIES_SIZE		    64 
-
-#define _WRHV_ARCH_HAS_STATUS_REGS	    1
-#define _WRHV_ARCH_HAS_CTRL_REGS	    1
-
-#define VB_STATUS_REGS_OFFSET_BASE	 0
-#define VB_STATUS_SRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +0))
-#define VB_STATUS_SRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +1))
-#define VB_STATUS_CR			(4 * (VB_STATUS_REGS_OFFSET_BASE +2))
-#define VB_STATUS_LR			(4 * (VB_STATUS_REGS_OFFSET_BASE +3))
-#define VB_STATUS_R3			(4 * (VB_STATUS_REGS_OFFSET_BASE +4))
-#define VB_STATUS_R4			(4 * (VB_STATUS_REGS_OFFSET_BASE +5))
-#define VB_STATUS_MCSRR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +6))
-#define VB_STATUS_MCSRR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +7))
-#define VB_STATUS_ESR			(4 * (VB_STATUS_REGS_OFFSET_BASE +8))
-#define VB_STATUS_MCSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +9))
-#define VB_STATUS_MCAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +10))
-#define VB_STATUS_DEAR			(4 * (VB_STATUS_REGS_OFFSET_BASE +11))
-#define VB_STATUS_EMSR			(4 * (VB_STATUS_REGS_OFFSET_BASE +12))
-#define VB_STATUS_ESRR0			(4 * (VB_STATUS_REGS_OFFSET_BASE +13))
-#define VB_STATUS_ESRR1			(4 * (VB_STATUS_REGS_OFFSET_BASE +14))
-#define VB_STATUS_RESERVED1_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +15)) 
-#define VB_STATUS_RESERVED1_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +16)) 
-#define VB_STATUS_RESERVED1_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +17)) 
-#define VB_STATUS_RESERVED1_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +18)) 
-#define VB_STATUS_RESERVED1_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +19)) 
-#define VB_STATUS_RESERVED1_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +20)) 
-#define VB_STATUS_RESERVED1_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +21)) 
-#define VB_STATUS_RESERVED1_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +22)) 
-#define VB_STATUS_SVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +23)) 
-#define VB_STATUS_PIR			(4 * (VB_STATUS_REGS_OFFSET_BASE +24)) 
-#define VB_STATUS_PVR			(4 * (VB_STATUS_REGS_OFFSET_BASE +25)) 
-#define VB_STATUS_HID0			(4 * (VB_STATUS_REGS_OFFSET_BASE +26)) 
-#define VB_STATUS_HID1			(4 * (VB_STATUS_REGS_OFFSET_BASE +27)) 
-#define VB_STATUS_BUSCR			(4 * (VB_STATUS_REGS_OFFSET_BASE +28)) 
-#define VB_STATUS_L1CSR0		(4 * (VB_STATUS_REGS_OFFSET_BASE +29)) 
-#define VB_STATUS_L1CSR1		(4 * (VB_STATUS_REGS_OFFSET_BASE +30)) 
-#define VB_STATUS_RESERVED2_0           (4 * (VB_STATUS_REGS_OFFSET_BASE +31)) 
-#define VB_STATUS_RESERVED2_1           (4 * (VB_STATUS_REGS_OFFSET_BASE +32)) 
-#define VB_STATUS_RESERVED2_2           (4 * (VB_STATUS_REGS_OFFSET_BASE +33)) 
-#define VB_STATUS_RESERVED2_3           (4 * (VB_STATUS_REGS_OFFSET_BASE +34)) 
-#define VB_STATUS_RESERVED2_4           (4 * (VB_STATUS_REGS_OFFSET_BASE +35)) 
-#define VB_STATUS_RESERVED2_5           (4 * (VB_STATUS_REGS_OFFSET_BASE +36)) 
-#define VB_STATUS_RESERVED2_6           (4 * (VB_STATUS_REGS_OFFSET_BASE +37)) 
-#define VB_STATUS_RESERVED2_7           (4 * (VB_STATUS_REGS_OFFSET_BASE +38)) 
-#define VB_STATUS_RESERVED2_8           (4 * (VB_STATUS_REGS_OFFSET_BASE +39)) 
-
-
-#define VB_STATUS_REG_STRUCT_END	(4 * (VB_STATUS_REGS_OFFSET_BASE +40))
-
-/* Bit Mask definitions for VB_STATUS_INT_PENDING */
-
-#define VB_STATUS_INT_PENDING_INT        1	/* Interrupt controller */
-#define VB_STATUS_INT_PENDING_TICK       2	/* Tick interrupt */
-
-
-#define VB_CONTROL_REGS_OFFSET_BASE	 0
-#define VB_CONTROL_SRR0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 0))
-#define VB_CONTROL_SRR1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 1))
-#define VB_CONTROL_CR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 2))
-#define VB_CONTROL_R0			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 3))
-#define VB_CONTROL_R1			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 4))
-#define VB_CONTROL_SP			VB_CONTROL_R1
-#define VB_CONTROL_R2			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 5))
-#define VB_CONTROL_R3			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 6))
-#define VB_CONTROL_R4			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 7))
-#define VB_CONTROL_R5			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 8))
-#define VB_CONTROL_R6			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 9))
-#define VB_CONTROL_R7			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 10))
-#define VB_CONTROL_R8			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 11))
-#define VB_CONTROL_R9			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 12))
-#define VB_CONTROL_R10			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 13))
-#define VB_CONTROL_R11			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 14))
-#define VB_CONTROL_R12			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 15))
-#define VB_CONTROL_R13			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 16))
-#define VB_CONTROL_EMSR			(4 * (VB_CONTROL_REGS_OFFSET_BASE + 17))
-#define VB_CONTROL_DBSR		        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 18))
-#define VB_CONTROL_DBCR0	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 19))
-#define VB_CONTROL_DBCR1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 20))
-#define VB_CONTROL_DBCR2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 21))
-#define VB_CONTROL_IAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 22))
-#define VB_CONTROL_IAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 23))
-#define VB_CONTROL_DAC1       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 24))
-#define VB_CONTROL_DAC2       	        (4 * (VB_CONTROL_REGS_OFFSET_BASE + 25))
-#define VB_CONTROL_RESERVED0		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 26))
-#define VB_CONTROL_RESERVED1		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 27))
-#define VB_CONTROL_RESERVED2		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 28))
-#define VB_CONTROL_RESERVED3		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 29))
-#define VB_CONTROL_RESERVED4		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 30))
-#define VB_CONTROL_RESERVED5		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 31))
-#define VB_CONTROL_RESERVED6		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 32))
-#define VB_CONTROL_RESERVED7		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 33))
-#define VB_CONTROL_RESERVED8		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 34))
-#define VB_CONTROL_RESERVED9		(4 * (VB_CONTROL_REGS_OFFSET_BASE + 35))
-
-/* status register size for ppc */
-
-#define VB_CONTROL_REG_STRUCT_END	(4 * (VB_CONTROL_REGS_OFFSET_BASE + 36))
-
-/* mdio messages */
-#define MDIO_READ	    1
-#define MDIO_WRITE	    2
-#define MDIO_INT_ENABLE	    3
-#define MDIO_INT_DISABLE    4
-#define BSP_CLK_FREQ	    5
-
-#ifndef _ASMLANGUAGE
-
-#define VB_STATUS_REGS_ACCESS(base, field)	\
-	base->vbStatusRegs.field		
-
-#define VB_CONTROL_REGS_ACCESS(base, field)	\
-	base->vbControlRegs.field		
-
-/*******************************************************************************
-*
-* VB_ARCH_CONTROL_REGS - Virtual core PPC control structure
-*
-* Virtual board emulated control registers. These registers are used
-* by a guest running on hypervisor to configure the virtual CPU register.
-*
-* SYNOPSIS
-*
-* PPC Control structure graphical illustration
-*\cs
-*        _______________   
-*       |       PC      |   
-*       |---------------|
-*       |       MSR     |	    
-*       |---------------|
-*       |       CR      |
-*       |---------------|
-*       |		|
-*       |general purpose|
-*       |     r[0:13]   | 
-*       |		|
-*       |---------------|
-*       |emulated MSR   |
-*       |---------------|
-*       |       dbsr    |
-*       |---------------|
-*       | dbcr[0:2]     |
-*       |---------------|
-*       |IAC[1:2]       |
-*       |---------------|
-*       |DAC[1:2]       |
-*       |---------------|
-*       |reserved[0:9]  |
-*       |---------------|
-*
-*\ce
-*
-* Virtual core's control C data structure type definition
-*
-*\cs
-* VB_STATUS structure definition
-*
-* typedef struct vbArchControlRegs
-*    {
-*
-*    /@ Registers to be restored by the VDK_SYS_ctx_load fast system call   @/
-*
-*    uint32_t srr0;	/@  0: PC		    @/
-*    uint32_t srr1;	/@  1: MSR		    @/
-*    uint32_t cr;	/@  2: condition registers	    @/
-*    uint32_t r0;	/@  3: General register R0	    @/
-*    uint32_t sp;	/@  4: General register R1 (stack pointer)  @/
-*    uint32_t r2;	/@  5: General register R2	    @/
-*    uint32_t r3;	/@  6: General register R3	    @/
-*    uint32_t r4;	/@  7: General register R4	    @/
-*    uint32_t r5;	/@  8: General register R5	    @/
-*    uint32_t r6;	/@  9: General register R6	    @/
-*    uint32_t r7;	/@ 10: General register R7	    @/
-*    uint32_t r8;	/@ 11: General register R8	    @/
-*    uint32_t r9;	/@ 12: General register R9	    @/
-*    uint32_t r10;	/@ 13: General register R10	    @/
-*    uint32_t r11;	/@ 14: General register R11	    @/
-*    uint32_t r12;	/@ 15: General register R12	    @/
-*    uint32_t r13;	/@ 16: General register R13	    @/
-*
-*    /@ emulated registers used by the VDK_SYS_ctx_load_vmmu system call    @/
-*
-*    uint32_t emsr;	/@ 17: emulated MSR register	        @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbsr; /@ 18 - debug status register		    @/
-*
-*    /@ Debug control registers			        @/
-*    
-*    uint32_t     dbcr0; /@ 19 - debug control register 0	    @/
-*    uint32_t     dbcr1; /@ 20 - debug control register 1	    @/
-*    uint32_t     dbcr2; /@ 21 - debug control register 2	    @/
-*
-*    /@ instruction address compare registers IAC1-IAC2		    @/
-*
-*    uint32_t     iac1; /@ 22 - instructions access control 1	        @/
-*    uint32_t     iac2; /@ 23 - instructions access control 2	        @/
-*
-*    /@ data address compare registers DAC1-DAC2.	        @/
-*
-*    uint32_t     dac1;	    /@ 24 - instructions access control 3       @/
-*    uint32_t     dac2;	    /@ 25 - instructions access control 4       @/
-*
-*    /@ reserved fields for future use			    @/
-*
-*    uint32_t reserved[10]; /@ 26: Reserved		    @/ 
-*    } VB_ARCH_CONTROL_REGS;
-*
-*\ce
-*
-* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
-*\COMMAND
-*/
-
-typedef struct vbArchControlRegs
-    {
-
-    /* Registers to be restored by the VDK_SYS_ctx_load fast system call */
-
-    uint32_t srr0;		/*  0: PC */
-    uint32_t srr1;		/*  1: MSR */
-    uint32_t cr;		/*  2: condition registers */
-    uint32_t r0;		/*  3: General register R0 */
-    uint32_t sp;		/*  4: General register R1 (stack pointer) */
-    uint32_t r2;		/*  5: General register R2 */
-    uint32_t r3;		/*  6: General register R3 */
-    uint32_t r4;		/*  7: General register R4 */
-    uint32_t r5;		/*  8: General register R5 */
-    uint32_t r6;		/*  9: General register R6 */
-    uint32_t r7;		/* 10: General register R7 */
-    uint32_t r8;		/* 11: General register R8 */
-    uint32_t r9;		/* 12: General register R9 */
-    uint32_t r10;		/* 13: General register R10 */
-    uint32_t r11;		/* 14: General register R11 */
-    uint32_t r12;		/* 15: General register R12 */
-    uint32_t r13;		/* 16: General register R13 */
-
-    /* emulated registers used by the VDK_SYS_ctx_load_vmmu system call */
-
-    uint32_t emsr;		/* 17: emulated MSR register */
-
-    /* Debug control registers */
-    
-    uint32_t     dbsr; /* 18 - debug status register */
-
-    /* Debug control registers */
-    
-    uint32_t     dbcr0; /* 19 - debug control register 0 */
-    uint32_t     dbcr1; /* 20 - debug control register 1 */
-    uint32_t     dbcr2; /* 21 - debug control register 2 */
-
-    /* instruction address compare registers IAC1-IAC2 */
-
-    uint32_t     iac1; /* 22 - instructions access control 1 */
-    uint32_t     iac2; /* 23 - instructions access control 2 */
-
-    /* data address compare registers DAC1-DAC2. */
-
-    uint32_t     dac1; /* 24 - instructions access control 3 */
-    uint32_t     dac2; /* 25 - instructions access control 4 */
-
-    /* reserved fields for future use */
-
-    uint32_t reserved[10];      /* 26: Reserved */ 
-    } VB_ARCH_CONTROL_REGS;
-
-/*******************************************************************************
-*
-* VB_ARCH_STATUS_REGS - Virtual core PPC emulated status registers
-*
-* Virtual board emulated CPU status registers
-*
-* SYNOPSIS
-*
-* PPC Status structure graphical illustration
-*\cs
-*        _______________   ---------------------------
-*       |    SRR0       |   
-*       |---------------|
-*       |    SRR1       |   Registers save by WRHV	
-*       |---------------|   before injecting an exception/interrupt
-*       |    CR		|
-*       |---------------|
-*       |    LR		|
-*       |---------------|
-*       |    r3		| 
-*       |---------------|
-*       |    r4         |
-*       |---------------|   ---------------------------
-*	|    mcsrr0	|	
-*       |---------------|  Registers saved duing exception handling
-*       |    mcssr1     |
-*       |---------------|
-*       |    esr        |
-*       |---------------|
-*       |    mcsr       |
-*       |---------------|
-*       |    mcar       |
-*       |---------------|
-*       |    dear       |
-*       |---------------|
-*       |    emsr       |
-*       |---------------|
-*       |    esrr0      |
-*       |---------------|
-*       |    esrr1      |
-*       |---------------|    -------------------------
-*       | reserved[8]   |      8 x 32bits for future enhencements
-*       |---------------|    -------------------------
-*       |    svr        |
-*       |---------------|
-*       |    pir        |
-*       |---------------|
-*       |    pvr        |    Configuration registers updated
-*       |---------------|    upon board creation    
-*       |    hid0       |  
-*       |---------------|
-*       |    hid1       |
-*       |---------------|
-*       |    buscr      |
-*       |---------------|       
-*       |    l1csr0     |
-*       |---------------|
-*       |    l1csr1     |
-*       |---------------|   --------------------------
-*       | reserved[0:8] | 9x 32bit
-*       |---------------|
-*
-*\ce
-*
-* Virtual core's status C data structure type definition
-*
-*\cs
-* VB_ARCH_STATUS_REGS structure definition
-*
-* typedef struct archStatusRegs
-*    {
-*
-*    /@ 
-*     @ registers saved by WRHV for all interrupts exceptions
-*     @ before setting the PC in the virtual board to the exception/interrupt
-*     @ vector address
-*     @/
-*
-*    uint32_t srr0; /@ 0: PC at time of the interrupt		@/
-*    uint32_t srr1; /@ 1: MSR at time of the interrupt		@/
-*    uint32_t cr;   /@ 2: Condition registers at time of the interrupt	@/
-*    uint32_t lr;   /@ 3: Link register at time of the interrupt    @/
-*    uint32_t r3;   /@ 4: R3 at time of the interrupt		@/
-*    uint32_t r4;   /@ 5: R4 at time of the interrupt		@/
-*
-*    /@ Registers saved by WRHV during exception processing only    @/
-*
-*    uint32_t mcsrr0; /@  6:			    @/
-*    uint32_t mcsrr1; /@  7:			    @/
-*    uint32_t esr;    /@  8:			    @/
-*    uint32_t mcsr;   /@  9:			    @/
-*    uint32_t mcar;   /@ 10			@/
-*    uint32_t dear;   /@ 11:			    @/
-*    uint32_t emsr;   /@ 12:			    @/
-*    uint32_t esrr0;  /@ 13:			    @/
-*    uint32_t esrr1;  /@ 14:			    @/
-*
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved1[8]; /@ 15 - 22			@/
-*
-*    /@ Configuration registers (only updated upon board creation   @/
-*
-*    uint32_t svr;     /@ 23			    @/     
-*    uint32_t pir;     /@ 24			    @/
-*    uint32_t pvr;     /@ 25			    @/  
-*    uint32_t hid0;    /@ 26			    @/
-*    uint32_t hid1;    /@ 27			    @/
-*    uint32_t bucsr;   /@ 28			    @/
-*    uint32_t l1csr0;  /@ 29			    @/
-*    uint32_t l1csr1;  /@ 30			    @/
-*    
-*    /@ reserved fields for future use			@/
-*
-*    uint32_t reserved2[9]; /@ 31 - 39			@/
-*
-*    } VB_ARCH_STATUS_REGS; 
-*
-*
-*\ce
-*
-* SEE ALSO: VB_STATUS 
-*\COMMAND
-*/
-
-typedef struct archStatusRegs
-    {
-
-    /* 
-     * registers saved by Razor for all interrupts exceptions
-     * before setting the PC in the virtual board to the exception/interrupt
-     * vector address
-     */
-
-    uint32_t srr0; /* 0: PC at time of the interrupt */
-    uint32_t srr1; /* 1: MSR at time of the interrupt */
-    uint32_t cr;   /* 2: Condition registers at time of the interrupt */
-    uint32_t lr;   /* 3: Link register at time of the interrupt */
-    uint32_t r3;   /* 4: R3 at time of the interrupt */
-    uint32_t r4;   /* 5: R4 at time of the interrupt */
-
-    /* Registers saved by Razor during exception processing only */
-
-    uint32_t mcsrr0; /*  6: */
-    uint32_t mcsrr1; /*  7: */
-    uint32_t esr;    /*  8: */
-    uint32_t mcsr;   /*  9: */
-    uint32_t mcar;   /* 10  */
-    uint32_t dear;   /* 11: */
-    uint32_t emsr;   /* 12: */
-    uint32_t esrr0;  /* 13: */
-    uint32_t esrr1;  /* 14: */
-
-/* 
- * keep this part in a separate structure in order to keep the offsets
- * to remain the same as in VB_STATUS
- */
-
-    /* reserved fields for future use */
-
-    uint32_t reserved1[8]; /* 15 - 22  */
-
-    /* Configuration registers (only updated upon board creation */
-
-    uint32_t svr;     /* 23 */     
-    uint32_t pir;     /* 24 */
-    uint32_t pvr;     /* 25 */  
-    uint32_t hid0;    /* 26 */
-    uint32_t hid1;    /* 27 */
-    uint32_t bucsr;   /* 28 */
-    uint32_t l1csr0;  /* 29 */
-    uint32_t l1csr1;  /* 30 */
-    
-    /* reserved fields for future use */
-
-    uint32_t reserved2[9]; /* 31 - 39 */
-
-    } VB_ARCH_STATUS_REGS; 
-
-
-/*******************************************************************************
-*
-* VBI_HREG_SET - hardware register set, for read/write
-*
-* Used by vbiVbRegisterRead/vbiVbRegisterWrite to read/write registers in 
-* another VB
-* 
-* SYNOPSIS
-*
-* VB hardware register set C data structure type definition
-*
-*\cs
-*
-* typedef struct
-*     {
-*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
-*     uint32_t msr;		/@ machine state register @/
-*     uint32_t lr;		/@ link register @/
-*     uint32_t ctr;		/@ count register @/
-*     uint32_t pc;		/@ program counter @/
-*     uint32_t cr;		/@ condition register @/
-*     uint32_t xer;		/@ fixed-point exception register @/
-*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
-*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
-*     } VBI_HREG_SET;
-* 
-*
-*\ce
-* SEE ALSO: NONE
-* 
-*/
-
-#define GREG_NUM	32	/* has 32 32/64-bit data registers */
-
-typedef struct
-    {
-    uint32_t gpr[GREG_NUM];	/* general purpose registers */
-    uint32_t msr;		/* machine state register */
-    uint32_t lr;		/* link register */
-    uint32_t ctr;		/* count register */
-    uint32_t pc;		/* program counter */
-    uint32_t cr;		/* condition register */
-    uint32_t xer;		/* fixed-point exception register */
-    uint32_t spefscr;		/* SPE floating-point status & ctrl reg */
-    uint32_t casid;		/* PPC405, Book E PID and PPC860 M_CASID */
-    } HREG_SET;
-
-/* VBI_HREG_SET is same as HREG_SET in ppc */
-typedef HREG_SET VBI_HREG_SET;
-
-/* mdio messages */
-
-#define VBI_MDIO_READ           MDIO_READ
-#define VBI_MDIO_WRITE          MDIO_WRITE
-#define VBI_BSP_CLK_FREQ        BSP_CLK_FREQ
-
-/* This should exceed the number of IVOR registers defined in the hardware 
-* It also defined the size of the excVectorTable size 
-* VBI_ARCH_MAX_EXC_OFFSETS * 256 == 0x4000 */
-#define VBI_ARCH_MAX_EXC_OFFSETS	64	
-
-typedef struct
-    {
-    uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
-    } VBI_EXC_OFFSETS_TABLE;
-
-#ifdef CONFIG_WRHV
-typedef int32_t  status_t;      /* operation/function status */
-#endif /* CONFIG_WRHV */
-
-extern status_t vbiExcOffsetsSet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
-extern status_t vbiExcOffsetsGet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
-
-/* common system wide message header structure */
-
-typedef struct vbi_msg_header {
-    uint32_t msgId;	/* message type identification */
-    uint32_t msgArg;	/* argument associated with message type */
-} VBI_MSG_HEADER;
-
-/* request message */
-
-typedef struct 
-    {
-    VBI_MSG_HEADER hdr;			/* message header */
-    uint32_t   request;			/* request type */
-
-    union 
-	{
-    	struct 
-	    {
-	    uint32_t bus;		
-	    uint32_t phyAddr;
-	    uint32_t regNum;
-	    uint32_t page;
-	    } mdioRead;
-    	struct 
-	    {
-	    uint32_t bus;		
-	    uint32_t phyAddr;
-	    uint32_t regNum;
-	    uint32_t page;
-	    uint32_t dataVal;
-	    } mdioWrite;
-#if 0 /* not supported for now */
-    	struct 
-	    {
-	    uint32_t bus;		
-	    uint32_t vbIntNum;
-	    HY_CTX *pCtx;
-	    } mdioIntEnable;
-    	struct 
-	    {
-	    uint32_t bus;	
-	    uint32_t vbIntNum;
-	    HY_CTX *pCtx;
-	    } mdioIntDisable;
-#endif
-	} arg;				
-    
-    } VBI_BSP_MSG;
-
-typedef struct 
-    {
-    VBI_MSG_HEADER hdr;			/* message header */
-    uint32_t   status;			/* request completion status */
-    uint32_t   dataVal;
-    } VBI_BSP_MSG_REPLY;
-
-#else /*_ASMLANGUAGE */
-
-/*******************************************************************************
-*
-* VBI_CTX_LOAD - Load a guest context
-*
-* This routine is implemented as an assembly MACRO since it's callers can't
-* reference C functions. This MACRO  makes a hypercall to load a context for a guest
-* OS. The guest OS running on the core is expected to store a set of registers that
-* represent the new context to load in the it's control structure then call 
-* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
-* loaded from the control structure:
-*
-*\ms
-*\m 1 -
-* VB_CONTROL_SRR0	     ------->  SRR0
-*\m 2 -
-* VB_CONTROL_SRR1	     -------> SRR1 
-*\m 3 -
-* VB_CONTROL_CR		     -------> CR
-*\m 4 -
-* VB_CONTROL_R0		     -------> R0
-*\m 5 -
-* VB_CONTROL_EMSR	     -------> MSR 
-*\m 6 -
-* VB_CONTROL_DBCR0	     -------> DBCR0 
-*\m 7 -
-* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
-* If interrupts are being reenabled then we ensure that any pending interrupts are
-* delivered before the new context is actived.
-*
-* Note that registers that are not saved by Hypervisor must be loaded by the guest
-* OS.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* void  VBI_CTX_LOAD () 
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
-*           VBI_INT_VCORE_STATE_GET()
-*/
-
-#define VBI_CTX_LOAD(reg)				    \
-	lis	reg, HI(VBI_SYS_ctx_load);		    \
-	ori	reg, reg, LO(VBI_SYS_ctx_load);		    \
-	sc
-
-/******************************************************************************
-*
-* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
-*
-* This MACRO disables the currently running core interrupts and returns the
-* previous interrupts state. The interrupt status field in wrhvVbControl
-* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
-* interrupts state is loaded to the register passed in as the first argument to
-* this MACRO. 
-* A hypercall is not needed to perform this operation. 
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
-*	{
-*	load -1 to reg1
-*	load wrhvVbControl address to reg2
-*       read the previous value and store in reg0
-*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
-*	}
-*\ce
-*
-* RETURNS: TRUE is interrupts were locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-#define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
-	li	reg1, -1;				\
-        lis     reg2, HIADJ(wrhvVbControl);		\
-        lwz     reg2, LO(wrhvVbControl)(reg2);		\
-        lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
-        stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
-*
-* This MACRO is implemented in assembly to enable a core's interrupts. It
-* enables the interrupts by clearing to zero the value in the core's control
-* structure and and makes a fast hypercall if need be. A hypercall is made only
-* if found that interrupts are pending. The pending interrupts are checked by
-* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
-* positive integer greater than zero indicates that interrupts are pending
-* which causes this macro to make a hypercall in order to drain the pending
-* interrupts. This MACRO expects two general purpose registers. The first 
-* register is used to load the value to store and the second is used for
-* holding the destination address of the control or status structure.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
-*	{
-*	load "0" to reg1
-*	load address of wrhvVbControl in reg0 
-*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
-*
-* checkStatus:
-*	load address of wrhvVbStatus in reg0
-*       load VB_STATUS_INT_PENDING(reg0) in reg1
-*       check if reg1 is equal to zero
-*       if true return
-*	otherwise send an hypercall 
-*       go to checkStatus
-*	}
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
-*/
-#define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
-	lis	reg0, HIADJ(wrhvVbControl);			\
-	lwz	reg0, LO(wrhvVbControl)(reg0);			\
-	li	reg1, 0;					\
-	stw	reg1, VB_CONTROL_INT_DISABLE(reg0);		\
-checkIntVcorePending:						\
-	lis	reg0, HIADJ(wrhvVbStatus);			\
-	lwz	reg0, LO(wrhvVbStatus)(reg0);			\
-	lwz	reg1, VB_STATUS_INT_PENDING(reg0);		\
-								\
-	cmplwi  reg1, 0; /* may need to make a hypercall*/	\
-	beq     endIntVcoreLock;				\
-	lis	r0, HI(VBI_SYS_int_enable);			\
-	ori	r0, r0, LO(VBI_SYS_int_enable);			\
-	sc;							\
-	b	checkIntVcorePending;				\
-endIntVcoreLock:
-
-/*******************************************************************************
-*
-* VBI_INT_VCORE_STATE_GET - Get interrupts state
-*
-* This MACRO is implemented in assembly to read the interrupt state of the
-* currently running core. It relies on a passed in general purpose register
-* to store the current state of interrupts. The status is -1 if locked
-* otherwise 0.
-*
-* SYNOPSIS
-*\cs
-* 
-* VBI PPC Architecture Supplements
-*
-* VBI_INT_VCORE_STATE_GET (reg0)
-*	{
-*       Load the interrupt status from wrhvVbControl to reg0
-*	}
-*\ce
-*
-* RETURNS: TRUE if interrupts are locked otherwise FALSE
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
-*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
-*/
-
-#define VBI_INT_VCORE_STATE_GET(reg0)				\
-	VBI_CNTRL_ADDR_GET(reg0);				\
-	lwz	reg0, VB_CONTROL_INT_DISABLE(reg0);		
-
-/*******************************************************************************
-*
-* VBI_CONFIG_ADDR_GET - Get virtual core configuration structure base address
-*
-* This macro returns the base address of the configuration structure of the 
-* running core. 
-*
-* SYNOPSIS
-*
-*\cs
-*
-*  C Preprocessor Macro for PPC assembly code
-*
-* VB_CONFIG * VBI_CONFIG_ADDR_GET (void)
-*
-*\ce
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-#define VBI_CONFIG_ADDR_GET(reg)		    \
-        lis     reg, HIADJ(wrhvVbConfig);	    \
-        lwz     reg, LO(wrhvVbConfig)(reg)	    
-
-/*******************************************************************************
-*
-* VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
-*
-* This macro returns the base address of the running virtual core's control
-* structure.
-*
-* SYNOPSIS
-*
-*\cs
-*
-*  C Preprocessor Macro
-*
-* VB_CONTROL * VBI_CNTRL_ADDR_GET (void)
-*
-*\ce
-*
-* RETURNS: N/A
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-#define VBI_CNTRL_ADDR_GET(reg)			    \
-        lis     reg, HIADJ(wrhvVbControl);	    \
-        lwz     reg, LO(wrhvVbControl)(reg) 	     
-
-/*******************************************************************************
-*
-* VBI_STATUS_ADDR_GET - Get virtual core status structure address
-*
-* This macro returns the base address of the status structure of currently
-* running core. This structure is read-only and contains a description of
-* the running virtual core. Hypervisor uses this data to inform the
-* virtual board time variant data that may be updated during hypervisor context
-* Switch. Typical that are available in the status structure are:
-*
-*\ms
-*\m - 
-*Timer tick counter
-*\m -
-*Pending interrupt state
-*\m -
-*The interrupt state before this core was schedule
-*\m -
-*VMMU configuration
-*\m -
-*Virtual core registers state
-*
-* SYNOPSIS
-*
-*\cs
-*
-*  C Preprocessor Macro
-*
-* VB_STATUS * VBI_STATUS_ADDR_GET(void)
-*
-*\ce
-*
-* RETURNS: virtual core configuration structure base address
-*
-* ERROR CODES: N/A
-*
-* SEE ALSO: 
-*/
-
-#define VBI_STATUS_ADDR_GET(reg)			    \
-        lis     reg, HIADJ(wrhvVbStatus);		    \
-        lwz     reg, LO(wrhvVbStatus)(reg)	     
-
-#endif /*_ASMLANGUAGE */
-    
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-#endif /* __INCvbiPpcArchh */
-- 
1.6.3.3

