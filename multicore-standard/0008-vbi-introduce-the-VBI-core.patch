From 0a1a89988c428425a130febde0813ea084e5c51e Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:05:12 -0400
Subject: [PATCH 08/24] vbi: introduce the VBI core

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 include/vbi/sys/syscalls.h   |  395 ++++++++++++++++++++
 include/vbi/sys/vbiSyscall.h |  222 +++++++++++
 include/vbi/sys/vmmu.h       |  308 +++++++++++++++
 include/vbi/vbInterface.h    |  841 ++++++++++++++++++++++++++++++++++++++++++
 include/vbi/vbInterrupt.h    |   48 +++
 include/vbi/vbShmem.h        |   49 +++
 include/vbi/vbiArch.h        |   54 +++
 include/vbi/vbiErrors.h      |   63 ++++
 include/vbi/vbiInterrupt.h   |   46 +++
 include/vbi/vbiPaddr.h       |   53 +++
 include/vbi/vbiShmem.h       |   59 +++
 include/vbi/vbiTypes.h       |   48 +++
 kernel/vbiInterrupt.c        |   96 +++++
 kernel/vbiPaddr.c            |  114 ++++++
 kernel/vbiShmem.c            |  206 +++++++++++
 15 files changed, 2602 insertions(+), 0 deletions(-)
 create mode 100644 include/vbi/sys/syscalls.h
 create mode 100644 include/vbi/sys/vbiSyscall.h
 create mode 100644 include/vbi/sys/vmmu.h
 create mode 100644 include/vbi/vbInterface.h
 create mode 100644 include/vbi/vbInterrupt.h
 create mode 100644 include/vbi/vbShmem.h
 create mode 100644 include/vbi/vbiArch.h
 create mode 100644 include/vbi/vbiErrors.h
 create mode 100644 include/vbi/vbiInterrupt.h
 create mode 100644 include/vbi/vbiPaddr.h
 create mode 100644 include/vbi/vbiShmem.h
 create mode 100644 include/vbi/vbiTypes.h
 create mode 100644 kernel/vbiInterrupt.c
 create mode 100644 kernel/vbiPaddr.c
 create mode 100644 kernel/vbiShmem.c

diff --git a/include/vbi/sys/syscalls.h b/include/vbi/sys/syscalls.h
new file mode 100644
index 0000000..f904c58
--- /dev/null
+++ b/include/vbi/sys/syscalls.h
@@ -0,0 +1,395 @@
+/* syscalls.h - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02u,12aug09,dtr  Add defines for additional arg to vbiHyIoctl.
+02t,13jul09,dbt  stop using long for VTLB VBI system calls
+02s,16jul09,mmi  change NO_RESET to RESET and NO_DOWNLOAD to DOWNLOAD
+02r,13jul09,mmi  fix reset flag reset
+02q,13jul09,mmi  add VBI_VBMGMT_RESET_DOWNLOAD
+02p,06jul09,mmi  add vb managment syscall numbers
+02o,02jul09,mmi  update the interrupt sending options, fix textUpdate
+		 fast syscall number
+02n,23jun09,mmi  add VBI_VBMGM_RESTART
+02s,16jul09,mmi  change NO_RESET to RESET and NO_DOWNLOAD to DOWNLOAD
+02r,13jul09,mmi  fix reset flag reset
+02q,13jul09,mmi  add VBI_VBMGMT_RESET_DOWNLOAD
+02p,06jul09,mmi  add vb managment syscall numbers
+02o,02jul09,mmi  update the interrupt sending options, fix textUpdate
+		 fast syscall number
+02n,23jun09,mmi  add VBI_VBMGM_RESTART
+02m,10jun09,mmi  add cache text update fast system call
+02l,29may09,mes  Fixed VBI_CTX_STATS to match HY_CTX_STATS
+02k,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02j,19mar09,mes  Fixed type of VBI_ERROR_CODE
+02i,02feb09,mmi  add name service system call
+02h,02mar09,mmi  fix header name define
+02g,24feb09,mmi  decouple vbi definitions from internal data, add vbMgmt API
+02f,19jan09,mmi  update msg API prototypes
+02e,12jan09,dtr  Add driver ioctl calls, remove legacy interrupt defns.
+02d,12dec08,md   rename header files
+02c,05dec08,mes  Removed shelf macros, added vbMgmt macros
+02b,01dec08,md   add VBI_IOAPICIOCTL_SEND options
+02a,21nov08,md   remove port and ED&R syscalls
+01z,20nov08,mmi  adtopt new naming convention
+01y,31oct08,dbt  Added vdkVtlbMmuOp hypercall.
+01x,16jun08,mmi  fix vdkBspIoctl prototype
+01w,19may08,gws  add vIoapicIoctl
+01v,18apr08,md   add extra arg to vdkHyioctl
+01u,11apr08,md   add EOI ioctl
+01t,06mar08,md   add debug shell ioctl
+01s,06dec07,foo  update hw ints
+01r,23nov07,foo  fix prototype, use basic types
+01q,25oct07,foo  updated with new vdk functions
+01p,27sep07,md   added exception profiling fields
+01o,26sep07,md   added profiling statistics and stats ioctl
+01n,10sep07,md   re-number hypervisor system calls
+01m,21aug07,md   added VDK_SYS_ctx_load_vmmu
+01l,05jul07,foo  added bspIoctl calls and defines
+01k,04jun07,md   added ctxctl and mmu system calls
+01j,17may07,ymz  added port syscall.
+01i,28may07,foo  update vdkInt prototype
+01h,18may07,md   add hypervisor ioctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed to vdk
+01e,10apr07,md   replace kprintf syscall with kputs and kputc
+01d,19mar07,foo  fix macro
+01c,17mar07,foo  modify definitions to all start with HY
+01b,15mar07,md   added interrupt system calls
+01a,09mar07,md   written
+*/
+
+#ifndef __INCsyscallsh
+#define __INCsyscallsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+ *
+ *
+ * System call number encoding:
+ *
+ * 31                                                                        0
+ *
+ *  |               |               |        |               |               |
+ *  +---------------+---------------+        +---------------+---------------+
+ *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
+ *  +---------------+---------------+        +---------------+---------------+
+ *   ^ ^ ^         ^ ^                                                      ^
+ *   | | \--------/  \------------------------------------------------------/
+ *   | |      |                                |
+ *   | |      |                                |
+ *   | |      |                                +-- System call number
+ *   | |      |
+ *   | |      +-- Fast hypervisor system call number
+ *   | |
+ *   | +--------- Hypervisor system call
+ *   |
+ *   +----------- Fast hypervisor system call
+ *
+ *
+ *
+ *
+ */
+
+/* fast system call numbers handled by assembler code */
+
+#define	HY_FAST_SYSCALL_MASK	0x3f000000
+#define	HY_FAST_SYSCALL_SHIFT	24
+#define	HY_FAST_SYSCALL_BIT	0x80000000
+#define	HY_FAST_SYSCALL(x)	\
+    ((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+     HY_FAST_SYSCALL_BIT)
+
+/* C driven system calls */
+
+#define	HY_SYSCALL_MASK		0x00ffffff
+#define	HY_SYSCALL_SHIFT	0
+#define	HY_SYSCALL_BIT		0x40000000
+#define	HY_SYSCALL(x)	\
+    ((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+
+/* fast system calls */
+
+#define	VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush			*/
+#define	VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush	*/
+#define	VBI_SYS_dcache_flush	HY_FAST_SYSCALL(3) /* data cache flush		*/
+#define	VBI_SYS_ctx_load	HY_FAST_SYSCALL(4) /* context load		*/
+#define	VBI_SYS_int_enable	HY_FAST_SYSCALL(5) /* int enable		*/
+#define	VBI_SYS_cache_text_update		    \
+				HY_FAST_SYSCALL(6) /* cache text update		*/
+
+
+
+/* hypervisor services */
+
+#define	VBI_SYS_hyIoctl		 HY_SYSCALL(1)	/* hypervisor ioctl	     */
+#define	VBI_SYS_vmContextCreate	 HY_SYSCALL(2)	/* context create	     */
+#define	VBI_SYS_send		 HY_SYSCALL(3)	/* send a messages	     */
+#define	VBI_SYS_receive		 HY_SYSCALL(4)	/* receive a messages	     */
+#define	VBI_SYS_reply		 HY_SYSCALL(5)	/* reply to a messages	     */
+#define	VBI_SYS_panic		 HY_SYSCALL(6)	/* halt the system	     */
+#define	VBI_SYS_int 		 HY_SYSCALL(7)	/* deliver an interrupt	     */
+#define	VBI_SYS_int_controller_done HY_SYSCALL(8)/* done interrupt processing*/
+#define	VBI_SYS_ctxctl 	 	 HY_SYSCALL(9)	/* context control operation */
+
+/* VMMU operations */
+
+#define	VBI_SYS_vmmu_config 	HY_SYSCALL(10)	/* configure the virtual MMU */
+#define	VBI_SYS_vmmu_enable 	HY_SYSCALL(11)	/* enable the virtual MMU    */
+#define	VBI_SYS_vmmu_disable 	HY_SYSCALL(12)	/* disable the virtual MMU   */
+#define	VBI_SYS_vmmu_tlbload 	HY_SYSCALL(13)	/* load a VMMU TLB entry     */
+#define	VBI_SYS_vmmu_tlbflush 	HY_SYSCALL(14)	/* flush a VMMU TLB entry    */
+#define	VBI_SYS_ctx_load_vmmu	HY_SYSCALL(15)	/* load context with vmmu    */
+
+/* MMU operations */
+
+#define	VBI_SYS_mmu_attr_set	HY_SYSCALL(16)	/* set physical memory attr  */
+#define	VBI_SYS_mmu_attr_get	HY_SYSCALL(17)	/* get physical memory attr  */
+
+/* BSP specific interface */
+
+#define VBI_SYS_bspIoctl	HY_SYSCALL(18)	/* BSP specific opreration   */
+
+/* vbMgmt services */
+
+#define VBI_SYS_vbMgmt          HY_SYSCALL(20)
+
+/* Virtual IO APIC services */
+
+#define VBI_SYS_vIoapicIoctl	HY_SYSCALL(21)
+
+#define VBI_SYS_vbReset         HY_SYSCALL(22)	/* reset  vcores	*/
+#define VBI_SYS_vbRestart       HY_SYSCALL(23)	/* restart vcores	*/
+#define VBI_SYS_vbSuspend       HY_SYSCALL(24)	/* suspend vcores	*/
+#define VBI_SYS_vbResume        HY_SYSCALL(25)  /* Resume vcores	*/
+
+
+#define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
+
+/* debug facilities */
+
+#define	VBI_SYS_kputs		HY_SYSCALL(50)	/* print a string to the cons*/
+#define	VBI_SYS_kputc		HY_SYSCALL(51)	/* print a char to the cons  */
+#define VBI_SYS_ps		HY_SYSCALL(52)	/* process status display    */
+#define VBI_SYS_dbgShStart	HY_SYSCALL(53)	/* start debug shell	     */
+
+/* VTLB MMU operations */
+
+#define VBI_SYS_vtlb_op		HY_SYSCALL(55)	/* VTLB operation */
+
+/* Name services */
+
+#define VBI_SYS_ns_op		HY_SYSCALL(60)	/* Name service operation */
+
+/* remote board memory services */
+
+#define VBI_SYS_memWrite_op	HY_SYSCALL(70)	/* memory write service operation */
+
+#define VBI_SYS_memRead_op	HY_SYSCALL(71)	/* memory read service operation */
+
+
+/* remote board memory services */
+
+#define VBI_SYS_RegsWrite_op	HY_SYSCALL(72)	/* regs write service operation */
+
+#define VBI_SYS_RegsRead_op	HY_SYSCALL(73)	/* regs service operation */
+
+/* Max number of syscalls*/
+#define VBI_SYS_max 		(73 + 1)
+
+/* hyIoctl system call supported ioctl's */
+
+#define	VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define	VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define	VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define	VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define	VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define	VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define	VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define	VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+
+/* vIoapicIoctl system call supported ioctl's */
+
+#define	VBI_IOAPICIOCTL_UNMASK	 1	/* unmask v io apic interrupt src */
+#define	VBI_IOAPICIOCTL_SEND	 2	/* inject a v io apic interrupt */
+#define	VBI_IOAPICIOCTL_EOI	 3	/* end of interrupt acknowledge */
+/* remove this after vbControl is working, we don't need a hypercall for it: */
+#define	VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
+
+/* VBI_IOAPICIOCTL_SEND options */
+
+#define	VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
+#define	VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
+#define	VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
+#define	VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
+#define	VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
+
+/* hyCtxctl system call supported operations */
+
+#define	VBI_CTXCTL_IDLE	 	1	/* make current context idle	*/
+
+/* MMU protection attributes */
+
+#define	VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define	VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define	VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+
+/* ETSEC MDIO supported ioctl's */
+#define VBI_BSPIOCTL_DRV_MDIO 1         /* mdio messages */
+
+/* system clock frequency query */
+#define VBI_BSPIOCTL_SYS_CLK 2
+
+#define	VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
+
+#define MDIO_READ 1
+#define MDIO_WRITE 2
+#define MDIO_INT_ENABLE 3
+#define MDIO_INT_DISABLE 4
+
+/* vbiHyIoctl for PADDR */
+#define VBI_HYIOCTL_PADDR_DMA        0x0 /* Default used for DMA */
+#define VBI_HYIOCTL_PADDR_PHYS       0x1 /* When absolute phys addr needed */
+
+/* vbMgmt commands */
+#define VBI_VBMGMT_ATTACH       1       /* Attach to VB for control */
+#define VBI_VBMGMT_DETACH       2       /* Detech from VB */
+#define VBI_VBMGMT_SUSPEND      3       /* Suspend/halt VB */
+#define VBI_VBMGMT_RESUME       4       /* Resume/start a VB */
+#define VBI_VBMGMT_RESET        5       /* Reset VB */
+#define VBI_VBMGMT_RESTART      6       /* Restart a VB */
+
+/* vbMgmt error codes */
+#define VBI_ERROR_CODE              int32_t
+#define VBI_ERR_GENERAL             -101   /* General error */
+#define VBI_ERR_INVALID_ARG         -102   /* General error */
+
+/* vbMgmt reset macros */
+#define VBI_VBMGMT_RESET_DOWNLOAD	    0x00000001     /* disable ELF reloading */
+#define VBI_VBMGMT_RESET_CLEAR		    0x00000002     /* do not clear memory */
+#define VBI_VBMGMT_RESET_AND_START_CORE0    0x00000004
+
+/* target vb options */
+
+#define VBI_VB_CORES_ALL	(0x80000000)		    
+#define VBI_VB_CORES_OTHERS	(0x40000000)
+
+/* VTLB operation command and flags (intel-vt specific) */
+
+#define	VBI_VTLB_OP_UPDATE_PMD		1
+#define	VBI_VTLB_OP_UPDATE_PTE		2
+#define	VBI_VTLB_OP_DELETE_PMD		3
+#define VBI_VTLB_OP_SET_PTE_AT		4
+#define	VBI_VTLB_OP_SET_PTE		5
+#define	VBI_VTLB_OP_FLUSH_OPS		6
+#define	VBI_VTLB_OP_INIT		7
+
+/* VTLB macros */
+
+#define	VBI_VTLB_OP_MAX_OPS		100
+#define	VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
+
+/* VTLB optimization supported options */
+
+#define	VBI_VTLB_OPTIM_ENABLED			1
+#define	VBI_VTLB_CR3_CACHE_ENABLED		2
+#define	VBI_VTLB_OPS_CACHE_ENABLED		4
+#define	VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
+
+/* vbiNsOp system call supported operations */
+
+#define	VBI_NS_REGISTER		1	/* register service name    */
+#define	VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define	VBI_NS_LOOKUP	        3	/* look up service name	    */
+
+#ifndef	_ASMLANGUAGE
+
+/* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
+
+typedef struct {
+    unsigned long ctx_type;          /* type of context (user, supv, etc) */
+    unsigned long switchin;          /* number of times switched in       */
+    unsigned long pended;            /* number of times in pend state     */
+    unsigned long tsCtxSwitchOutH;   /* timestamp: context switch (high)  */
+    unsigned long tsCtxSwitchOutL;   /* timestamp: context switch (low)   */
+    unsigned long tsCtxSwitchInH;    /* timestamp: context switch (high)  */
+    unsigned long tsCtxSwitchInL;    /* timestamp: context switch (low)   */
+    unsigned long tsCtxExcInH;	   /* timestamp: exception entry (high) */
+    unsigned long tsCtxExcInL;	   /* timestamp: exception entry (low)  */
+    unsigned long reset;            /* number of times context reset */
+} VBI_CTX_STATS;
+
+/* VTLB operation structures (x86 specific) */
+
+typedef struct vbi_vtlb_op		/* VTLB operation */
+    {
+    uint32_t		op;		/* VTLB operation id */
+    uint32_t		arg1;		/* VTLB operation arg 1 */
+    uint32_t		arg2;		/* VTLB operation arg 2 */
+    uint32_t		arg3;		/* VTLB operation arg 3 */
+    } VBI_VTLB_OP;
+
+typedef struct vbi_vtlb_cr3_cache
+    {
+    uint32_t		guest_cr3;	/* Guest CR3 register */
+    uint32_t		host_cr3;	/* Host CR3 register */
+    } VBI_VTLB_CR3_CACHE;
+    
+typedef struct vbi_vtlb_control
+    {
+    uint32_t		size;		/* VTLB Control structure size */
+    uint32_t		mode;		/* VTLB module */
+    uint32_t		vtlb_ops_ix;	/* VTLB operation index */
+    VBI_VTLB_OP		vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
+    uint32_t		cr3_cache_ix;	/* CR3 cache index */
+    VBI_VTLB_CR3_CACHE	cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES]; /* cr3 cache*/
+    } VBI_VTLB_CONTROL;			/* VBI VTLB control */
+
+/*
+ * Control structure used by vbiVbMgmt for commands memory read, memory write, 
+ *  register read, and register write.
+ */
+
+typedef struct vbMgmtCtl 
+    {
+    union 
+	{
+	struct 
+	    {
+	    uint32_t *pBuffer;  /* address of target context */
+	    uint32_t *pAddress; /* address of calling context */
+	    uint32_t size;	/* number of total bytes */
+	    uint32_t width;	/* bus width in bytes */
+	    } vbMgmtMem;
+	struct 
+	    {
+	    uint32_t *pBuffer;  /* address of target context */
+	    uint32_t regSet;	/* register set */
+	    uint32_t reg;	/* macro to specify register */
+	    uint32_t size;	/* number of total bytes */
+	    } vbMgmtReg;
+	} data;
+    } VBMGMT_CTL;
+
+typedef uint32_t VBMGMT_HANDLE;
+typedef uint32_t VBI_NS_HANDLE;
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCsyscallsh */
diff --git a/include/vbi/sys/vbiSyscall.h b/include/vbi/sys/vbiSyscall.h
new file mode 100644
index 0000000..53885f0
--- /dev/null
+++ b/include/vbi/sys/vbiSyscall.h
@@ -0,0 +1,222 @@
+/* vbiSyscall.h - hypervisor system calls */
+
+/*
+ * Copyright (c) 2007-2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02q,26aug09,mmi  Fix defect WIND00178030: add vbiKputc proto
+02p,12aug09,dtr  Update vbiHyIoctl API to add additional argument.
+02o,22jul09,mpk  support vbi register read, write
+02n,03jul09,mmi  move vbiNsOp to private header file, add
+		 vbiVbRegRead/Write
+02m,02jul09,mmi  add one more parameter to vbiIoapicIoctl
+02l,23jun09,mmi  add vbi2.0 apis
+02k,11jun09,mmi  update interrupts api protortype
+02j,10jun09,mmi  update hypercall interface according to vbi 2.0 spec
+02i,26feb09,mmi  add vbiNs
+02h,24feb09,mmi  remove duplicate defines already in syscalls.h
+02g,06feb09,mmi  include vbiMsg.h
+02f,19jan09,mmi  update msg API prototypes
+02e,12jan09,dtr  Add driver ioctl calls, remove legacy interrupt defns.
+02d,12dec08,md   rename header files
+02c,05dec08,mes  Removed shelf macros, added vbMgmt macros
+02b,01dec08,md   add VBI_IOAPICIOCTL_SEND options
+02a,21nov08,md   remove port and ED&R syscalls
+01z,20nov08,mmi  adtopt new naming convention
+01y,31oct08,dbt  Added vdkVtlbMmuOp hypercall.
+01x,16jun08,mmi  fix vdkBspIoctl prototype
+01w,19may08,gws  add vIoapicIoctl
+01v,18apr08,md   add extra arg to vdkHyioctl
+01u,11apr08,md   add EOI ioctl
+01t,06mar08,md   add debug shell ioctl
+01s,06dec07,foo  update hw ints
+01r,23nov07,foo  fix prototype, use basic types
+01q,25oct07,foo  updated with new vdk functions
+01p,27sep07,md   added exception profiling fields
+01o,26sep07,md   added profiling statistics and stats ioctl
+01n,10sep07,md   re-number hypervisor system calls
+01m,21aug07,md   added VDK_SYS_ctx_load_vmmu
+01l,05jul07,foo  added bspIoctl calls and defines
+01k,04jun07,md   added ctxctl and mmu system calls
+01j,17may07,ymz  added port syscall.
+01i,28may07,foo  update vdkInt prototype
+01h,18may07,md   add hypervisor ioctl
+01g,20apr07,md   add vmmu system calls
+01f,18apr07,md   renamed to vdk
+01e,10apr07,md   replace kprintf syscall with kputs and kputc
+01d,19mar07,foo  fix macro
+01c,17mar07,foo  modify definitions to all start with HY
+01b,15mar07,md   added interrupt system calls
+01a,09mar07,md   written
+*/
+
+#ifndef __INCvbiSyscallh
+#define __INCvbiSyscallh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <vbi/sys/syscalls.h>
+#include <linux/linkage.h>
+
+#ifndef	_ASMLANGUAGE
+
+/* Forward declaration */
+struct vmmuConfig;
+struct VB_ARCH_CONTROL_REGS; 
+
+/* information about incoming message */
+
+typedef struct vbiMsgInfo {
+    vbiCtx_t    id;	/* context id of sender */
+    uint32_t type;	/* message type (msg/event) */
+    size_t   slen;	/* length of sent buffer */
+    size_t   rlen;	/* length of received buffer */
+    uint32_t error;	/* extended error status */
+    time_t   timestamp;	/* time message was sent */
+    uint32_t nmsg;	/* number of queued messages remaining */
+} VBI_MSG_INFO;
+
+/* modifiers for message processing */
+
+typedef struct vbiMsgCtl {
+    uint32_t flags;	/* operation flags */
+    uint32_t ordering;	/* order to receive messages */
+    time_t   timeout;	/* receive timeout */
+} VBI_MSG_CTL;
+
+/* memory read/write control structure */
+
+typedef struct vbiMemCtl
+    {
+    void	*pBuffer;	    /* address of target context	    */
+    void	*pAddress;	    /* address of calling context	    */
+    size_t	sizeIn;		    /* number of bytes to be read	    */
+    size_t	sizeOut;	    /* number of bytes successfully read    */
+    uint32_t	flags;	    	    /* data/instruction flush option	    */
+  } VBI_MEM_CTL;
+
+#define VBI_DCACHE_FLUSH 	0x0001
+#define VBI_ICACHE_INV 		0x0002
+
+
+/* system call prototypes for use within a context */
+
+extern asmlinkage int  vbiHyIoctl (unsigned ioctl, void *arg1, void *arg2,
+				   void *arg3, void *arg4);
+extern asmlinkage int  vbiIoapicIoctl (unsigned ioctl, unsigned arg1,
+					unsigned arg2);
+extern asmlinkage int  vbiCtxctl (unsigned operation, unsigned arg1,
+				  unsigned arg2);
+extern asmlinkage int32_t vbiVbMgmt (uint32_t cmd, uint32_t boardId,
+			int32_t *outError, uint32_t flags, void * ctl);
+extern asmlinkage int  vbiVtlbOp (unsigned int op, unsigned long arg1,
+				  unsigned long arg2, unsigned long arg3);
+
+/*******************************************************************************
+ * Modified APIs for VBI 2.0 
+ */
+
+/* Message send	    */
+
+extern asmlinkage vbiStatus_t vbiSend (vbiCtx_t	    id, 
+					void	    *smsg, 
+					size_t	    slen, 
+					void	    *rmsg,
+					size_t	    rlen, 
+					VBI_MSG_INFO    *info, 
+					VBI_MSG_CTL    *ctl);
+/* message receive  */
+
+extern asmlinkage vbiStatus_t vbiReceive (void		*rmsg, 
+					uint32_t		rlen, 
+					VBI_MSG_INFO	*info,
+					VBI_MSG_CTL     *ctl);                                   
+/* message reply */
+
+extern asmlinkage int32_t vbiReply (vbiCtx_t	    id, 
+				    void		    *smsg, 
+				    size_t		    slen, 
+				    VBI_MSG_CTL	    *ctl);
+
+extern asmlinkage vbiStatus_t vbiPanic (const char *msg);
+extern asmlinkage vbiStatus_t vbiDcacheFlush (void *saddr, size_t size);
+extern asmlinkage vbiStatus_t vbiIcacheFlush (void *saddr, size_t size);
+extern asmlinkage vbiStatus_t vbiKputs (const char *s);
+extern asmlinkage vbiStatus_t vbiKputc (int c);
+extern asmlinkage vbiStatus_t vbiVmmuConfig (struct vmmuConfig * config);
+extern asmlinkage vbiStatus_t vbiVmmuEnable (uint32_t  vmmu_num);
+extern asmlinkage vbiStatus_t vbiVmmuDisable (uint32_t vmmu_num);
+extern asmlinkage vbiStatus_t vbiNsRegister (char  *name, uint32_t  revision);
+extern asmlinkage vbiStatus_t vbiNsUnRegister (char *name, uint32_t  revision);
+extern asmlinkage vbiStatus_t vbiNsLookup (char *name, uint32_t  rev,
+					   VBI_NS_HANDLE *pHandle);
+extern asmlinkage vbiStatus_t vbiVmmuTlbFlush (struct vmmuConfig * config,
+						void *addr, size_t len);
+extern asmlinkage int  vbiBspIoctl (unsigned ioctl, int p1, int p2, int p3, int p4,
+                       int p5, int p6, int p7);
+extern asmlinkage int32_t vbiVbMgmt (uint32_t cmd, uint32_t boardId, int32_t *outError,
+                         uint32_t flags, void * ctl);
+
+
+/* Prior to vbi 2.0 these api were vbiMmuAttrSet/Get */
+
+extern asmlinkage vbiStatus_t  vbiMemAttrSet (void *vaddr, size_t len,
+						vbiMemAttr_t attr);
+extern asmlinkage vbiStatus_t  vbiMemAttrGet (void *vaddr, vbiMemAttr_t * attr);
+
+/*******************************************************************************
+ * START: New APIs introduced for vbi 2.0  
+ */
+
+extern asmlinkage vbiStatus_t vbiIntVCoreUnlock (void);
+extern asmlinkage vbiIntState_t vbiIntVCoreLock (void);
+extern asmlinkage vbiStatus_t vbiCacheTextUpdate (void *saddr, size_t size);
+extern asmlinkage vbiStatus_t  vbiExcBaseSet (void * excTblBase);
+
+extern asmlinkage vbiStatus_t vbiVcoreIntRed_op(vbiIrq_t, vbiCore_t);
+extern asmlinkage vbiStatus_t vbiIoapicOp(uint32_t, vbiIrq_t, uint32_t, vbiVb_t);
+/* virtual board management API's */
+
+extern asmlinkage vbiStatus_t vbiVbSuspend (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbReset (vbiVb_t id, vbiCore_t core,
+					  uint32_t options);
+extern asmlinkage vbiStatus_t vbiVbRestart (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbResume (vbiVb_t id, vbiCore_t core);
+
+/* read remote vb's memory */
+
+extern asmlinkage vbiStatus_t vbiVbMemoryRead (VBI_MEM_CTL *memCtl,
+						vbiVb_t targetBoard);
+extern asmlinkage vbiStatus_t vbiVbMemoryWrite (VBI_MEM_CTL *memCtl,
+						vbiVb_t targetBoard);
+extern asmlinkage void vbiDebugShellStart (uint32_t  flags);
+
+/* read remote vb's registers */
+
+#ifdef CONFIG_X86
+extern asmlinkage vbiStatus_t vbiVbRegisterRead (VB_HREG_SET *regCtl, 
+				       vbiVb_t targetBoard, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbRegisterWrite (VB_HREG_SET *regCtl, 
+					vbiVb_t targetBoard, vbiCore_t core);
+#endif
+
+/*******************************************************************************
+ * END: New APIs introduced for vbi 2.0  
+ */
+
+
+#endif
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiSyscallh */
diff --git a/include/vbi/sys/vmmu.h b/include/vbi/sys/vmmu.h
new file mode 100644
index 0000000..b59daf3
--- /dev/null
+++ b/include/vbi/sys/vmmu.h
@@ -0,0 +1,308 @@
+/* sys/vmmu.h - wrhv hypervisor virtual MMU structure definitions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01d,21aug07,md   removed vxWorks.h
+01c,16may07,md   update defines and comments to match structure layout
+01b,24apr07,md   adjust fields to better match e500 pte
+01a,19apr07,md   written
+*/
+
+#ifndef __INCvmmuh
+#define __INCvmmuh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/*
+
+The vmmu virtual address space is restricted to 32 bits and is decoded using
+a level-1/level-2 page table.  The virtual address is decoded as follows:
+
+
+                          32-bit Virtual Address
+        +---------------------------------------------------------+
+        |      L1 offset       | L2 offset |    Page offset       |
+        +---------------------------------------------------------+
+		11 bits           9 bits           12 bits
+                  |                 |
+                  |                 |
+    +-------------+                 |
+    |                               |
+    |                               |
+    |           L1 Table            |            L2 Table
+    |    2047 +----------+          |      511 +----------+
+    |         |          |          |          |          |
+    |         |          |          |          |          |
+    |         |          |          |          |----------|
+    |         |          |          |   +----->|    PTE   | 8 byte PTE
+    |         |          |          |   |      |----------|
+    |         |          |          |   |      |          |
+    |         |----------| 20 bits  |   |      |          |
+    +-------->|  L2 ptr  |----------+---+      |          |
+              |----------|                     |          |
+              |          |                     |          |
+              |          |                     |          |
+            0 +----------+                   0 +----------+
+               2 page (8KB)                    1 page (4KB)
+             2048 L2 pointers                 512 PTE entries
+
+
+
+Each page table entry is 8 bytes (2 words) and uses the following format:
+
+
+word 0 (32-bits):
+
+	  0 1            7 8           15 1 1 1 1 2 2 2 2 24   26 27  31
+	                                  6 7 8 9 0 1 2 3
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+	 |V|  Hypervisor  |   Reserved   |U|U|U|U|U|U|U|U| ERPN  | ATTR |
+	 | |   Reserved   |              |0|1|2|3|4|5|6|7|       |      |
+	 +-+--------------+--------------+-+-+-+-+-+-+-+-+-------+------+
+
+		V          - valid bit
+		Hypervisor - reserved for use by hypervisor
+		U0-U7      - user defined attributes
+		ERPN       - extended real page number bits
+		ATTR       - page attributes
+
+
+word 1 (32-bits):
+
+	  0                                19 20      23 2 2 2 2 2 2 3 3
+	                                                 4 5 6 7 8 9 0 1
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+	 |                RPN                | Reserved |R|C|U|S|U|S|U|S|
+	 |                                   |          | | |X|X|W|W|R|R|
+	 +-----------------------------------+----------+-+-+-+-+-+-+-+-+
+
+		RPN        - real page number
+		R          - page referenced bit
+		C          - page changed bit
+		SX,SW,SR   - supervisor mode protection bits
+		UX,UW,UR   - user mode protection bits
+
+*/
+
+#ifndef	_ASMLANGUAGE
+
+/* Page Table Entry Definition */
+
+typedef union vmmu_pte		/* vmmu pte format */
+    {
+    struct			/* Bit field description */
+	{
+	/* word 0 */
+
+	u_int v:1;		/* valid bit */
+	u_int hy:7;		/* reserved for use by hypervisor */
+	u_int rsvd1:8;		/* reserved */
+	u_int u0:1;		/* user attribute 0 */
+	u_int u1:1;		/* user attribute 1 */
+	u_int u2:1;		/* user attribute 2 */
+	u_int u3:1;		/* user attribute 3 */
+	u_int u4:1;		/* user attribute 4 */
+	u_int u5:1;		/* user attribute 5 */
+	u_int u6:1;		/* user attribute 6 */
+	u_int u7:1;		/* user attribute 7 */
+	u_int erpn:3;		/* extended real page number bits */
+	u_int w:1;		/* write thru/back */
+	u_int i:1;		/* cache inhibited */
+	u_int m:1;		/* memory coherent */
+	u_int g:1;		/* memory guarded  */
+	u_int e:1;		/* little endian bit */
+
+	/* word 1 */
+
+	u_int rpn:20;		/* real page number */
+	u_int rsvd2:4;		/* reserved */
+	u_int r:1;		/* page referenced bit */
+	u_int c:1;		/* page changed bit */
+	u_int ux:1;		/* user execute protection */
+	u_int sx:1;		/* supervisor execute protection */
+	u_int uw:1;		/* user write protection */
+	u_int sw:1;		/* supervisor write protection */
+	u_int ur:1;		/* user read protection */
+	u_int sr:1;		/* supervisor read protection */
+	} field;
+
+    struct
+	{
+	u_int word0;		/* word 0 */
+	u_int word1;		/* word 1 */
+	} words;
+    } VMMU_PTE;
+
+/* Effective Address Definition */
+
+typedef union vmmuEffectiveAddr /* effective Address structure */
+    {
+    struct
+        {
+        u_int l1index:11;	/* Level 1 Index (2K) */
+        u_int l2index:9;	/* Level 2 Index (512) */
+        u_int po:12;		/* Page Offset (4K) */
+        } field;
+    void * addr;
+    } VMMU_EFFECTIVE_ADDR;
+
+/* Real Address Definition */
+
+typedef union vmmuRealAddress	/* Real Address Structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int rpn:20;           /* Real Page Number */
+        u_int po:12;            /* Page Offset */
+        }field;
+    void * realAddr;            /* Real Address */
+    } VMMU_REAL_ADDRESS;
+
+/* Level-1 descriptor definition */
+
+typedef union vmmu_level_1_desc	/* Level 1 descriptor format */
+    {
+    struct                      /* Bit field desciption */
+        {
+        u_int l2ba:20;          /* Level 2 table Base Address */
+        u_int reserved:10;      /* Reserved */
+        u_int b:1;              /* Block translation */
+        u_int v:1;              /* Segment Valid bit */
+        } field;
+    u_int l1desc;               /* Level 1 descriptor */
+    } VMMU_LEVEL_1_DESC;
+
+/* Level-2 descriptor definition */
+
+typedef union vmmu_level_2_desc	/* Level 2 descriptor format */
+    {
+    VMMU_PTE pte;		/* a full PTE entry */
+    } VMMU_LEVEL_2_DESC;
+
+/* Level-2 table pointer definition */
+
+typedef union vmmu_level_2_tbl_ptr /* Level 2 Table pointer structure */
+    {
+    struct                      /* Bit field description */
+        {
+        u_int l2tb:20;          /* Level 2 Table Base */
+        u_int l2index:9;	/* Level 2 table Index */
+        u_int reserved:3;       /* Reserved */
+        } field;
+    VMMU_LEVEL_2_DESC *pL2Desc;	/* Level 2 descriptor table pointer */
+    } VMMU_LEVEL_2_TBL_PTR;
+
+
+/* VMMU configuration system call paramter */
+
+typedef struct vmmuConfig
+    {
+    VMMU_LEVEL_1_DESC *addr;
+    u_int	  pageSize;
+    u_int	  contextId;
+    u_int	  vmmuNum;
+    } VMMU_CONFIG;
+
+#endif /* _ASMLANGUAGE */
+
+#ifndef	VMMU_PAGE_SIZE
+#define	VMMU_PAGE_SIZE	4096	/* always use a 4KB page size */
+#define	VMMU_RPN_SHIFT	12
+#endif
+#define	NVPAGES(x)		((x)/VMMU_PAGE_SIZE)
+
+/* VMMU protection attributes */
+
+#define	VMMU_PROT_SUPV_READ	0x00000001	/* supervisor read allowed    */
+#define	VMMU_PROT_USER_READ	0x00000002	/* user read allowed	      */
+#define	VMMU_PROT_SUPV_WRITE	0x00000004	/* supervisor write allowed   */
+#define	VMMU_PROT_USER_WRITE	0x00000008	/* user write allowed	      */
+#define	VMMU_PROT_SUPV_EXECUTE	0x00000010	/* supervisor execute allowed */
+#define	VMMU_PROT_USER_EXECUTE	0x00000020	/* user execute allowed	      */
+
+
+#define	VMMU_PROT_USER_RWX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE | \
+				VMMU_PROT_USER_EXECUTE \
+
+#define	VMMU_PROT_USER_RW	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_WRITE
+
+#define	VMMU_PROT_USER_RX	VMMU_PROT_USER_READ | \
+				VMMU_PROT_USER_EXECUTE
+
+#define	VMMU_PROT_SUPV_RWX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE | \
+				VMMU_PROT_SUPV_EXECUTE \
+
+#define	VMMU_PROT_SUPV_RW	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_WRITE
+
+#define	VMMU_PROT_SUPV_RX	VMMU_PROT_SUPV_READ | \
+				VMMU_PROT_SUPV_EXECUTE
+
+/* VMMU cache attributes */
+
+#define	VMMU_CACHE_LE		0x00000001	/* cache little endian	*/
+#define	VMMU_CACHE_GUARDED	0x00000002	/* cache guarded	*/
+#define	VMMU_CACHE_COHERENT	0x00000004	/* cache coherency	*/
+#define	VMMU_CACHE_INHIBIT	0x00000008	/* cache inhibit 	*/
+#define	VMMU_CACHE_WRITETHROUGH	0x00000010	/* cache write through	*/
+#define	VMMU_CACHE_COPYBACK	0x00000000	/* cache copy back	*/
+
+/* VMMU page table structure */
+
+#define	VMMU_L1_ENTRIES	2048	/* top 11 bits of address	*/
+#define	VMMU_L1_SIZE	2	/* table size in pages (8KB)	*/
+#define	VMMU_L2_ENTRIES	512	/* middle 9 bits of address	*/
+#define	VMMU_L2_SIZE	1	/* table size in pages (4KB)	*/
+
+/* address to level-1 table offset */
+
+#define	VMMU_L1_INDEX(v)	(((u_int)(v)) >> 21)
+
+/* address to level-2 table offset */
+
+#define	VMMU_L2_INDEX(v)	((((u_int)(v)) >> 12) & 0x1ff)
+
+/* offset within page */
+
+#define	VMMU_PAGE_OFFSET(v)	(((u_int)(v)) & 0xfff)
+
+/* address to logical block number */
+
+#define	VMMU_ADDR_TO_LBA(v)	(((u_int)(v)) >> VMMU_RPN_SHIFT)
+#define	VMMU_LBA_TO_ADDR(v)	(((u_int)(v)) << VMMU_RPN_SHIFT)
+
+/* bit masks for PTE fields */
+
+/* word 0 */
+
+#define	VMMU_PTE_ATTR_MASK	0x0000001f	/* page attributes */
+#define	VMMU_PTE_ERPN_MASK	0x000000e0	/* extended real page number */
+#define	VMMU_PTE_VALID_MASK	0x80000000	/* pte valid */
+
+/* word 1 */
+
+#define	VMMU_PTE_PERM_MASK	0x0000003f	/* page permissions */
+#define	VMMU_PTE_CHG_MASK	0x00000040	/* page changed bit */
+#define	VMMU_PTE_REF_MASK	0x00000080	/* page referenced bit */
+#define	VMMU_PTE_RPN_MASK	0xfffff000	/* real page number */
+
+#ifndef _ASMLANGUAGE
+#ifdef CONFIG_WRHV
+extern int vb_context_mmu_on (int pid, void * pgtable, int pagesize, int debug);
+#endif
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvmmuh */
diff --git a/include/vbi/vbInterface.h b/include/vbi/vbInterface.h
new file mode 100644
index 0000000..6565915
--- /dev/null
+++ b/include/vbi/vbInterface.h
@@ -0,0 +1,841 @@
+/* vbInterface.h - virtual board interface header file */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+02p,26aug09,mmi  fix WIND00178026: update copyright dates
+02o,06aug09,dtr  Modify status intPending to intPendingType as per docs.
+02n,03jul09,mmi  rename version flags
+02m,16jun09,mmi  make vioapic field a pointer, move bootCount field to VB_STATUS
+02l,08jun09,mmi  fix apigen syntax
+02k,08jun09,mmi  update descriptions
+02j,22may09,md   adjust fields for 64-bit
+02i,22may09,mpk  use exception Stack for running Privileged VBI calls
+02h,14may09,md   add per-core private memory page
+02g,18may09,mpk  64-bit hypervisor, 32-bit Virtual Board
+02f,29apr09,mpk  move syscalls.h include to vbi.h
+02e,27apr09,mpk  Supervisor Syscall Interface for Privileged Guest OS
+02d,21apr09,md   add SMP guest information
+02d,17apr09,mpk  64-bit hypervisor, and supervisor vbi calls
+02c,29jan09,dtr  Fix reg offset macros.
+02b,28jan09,mmi  merge arch registers in vb status struct, use arch specific
+		 define for vioapic size, put regs struct at the beginning
+02a,22jan09,mmi  add ctypes.h
+01z,22jan09,mmi  abstract arch specific registers
+01y,23dec08,mmi  move vb function prototypes to vbMgr.h
+01x,14dec08,mmi  define VB_PRINTF to printf for vxWorks
+01w,12dec08,mmi  replace RAZOR name reference to WRHV
+01v,11dec08,mmi  use typedef instead of native types
+01u,02dec08,mmi  remove obsolete API definitions
+01t,19nov08,dtr  Remove interrupt controller.
+01s,03oct08,dbt  Added tickCount to VB_STATUS.
+01r,01aug08,md   add tracking of region data type
+01q,19may08,gws  add virtual IO APIC
+01p,23nov07,foo  add boot defines
+01o,08nov07,md   add bootline support
+01n,09nov07,foo  remove includes
+01m,25oct07,foo  updated for hardware interrupts
+01l,09oct07,md   add emulated srr1 register
+01k,04oct07,md   include sys/cpu_types.h
+01j,11sep07,md   added emulated MSR register for PPC
+01i,23aug07,md   added vmmu and PPC volatile regs to control page
+01h,25jul07,md   added memory aliasing information
+01g,29may07,ymz  added port support.
+01f,25may07,foo  updated for inter-board interrupts
+01e,17may07,foo  updated for improved interrupt delivery
+01d,23apr07,foo  added fields for user mode virtual boards and interrupts
+01c,16mar07,foo  renamed RAZOR_CPU to CPU 
+01b,16mar07,foo  update for generalized interface and interrupt delivery
+01a,15feb07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module defines the data structures used for information flow between
+wind river Hypervisor and a Virtual Board. There are three structures employed
+for this purpose: 
+\ms
+\m - 
+ configuration 
+\m - 
+ status 
+\m -
+ control
+\me
+
+The configuration structure is the first data exchanged between a given virtual 
+board and Hypervisor kernel. The pointers to the status and control structures are
+derived from the configuration structure. It contains pointers to the status, 
+control and other information about resources assigned to a virtual board. 
+The configuration data is shared accross the cores in the same virtual board unlike
+the data in the control and status structure which may be different for each core.
+The information in the configuration structure is static in the sense that the data
+it contains remain unmodified at least during the life of a boot cycle.
+
+The status structure is used to inform a virtual core at runtime about the state it
+is excecuting (interrupts, vmmu, elapsed time etc...). 
+
+The control structure is put in place as a fast method to pass information from
+the VB to Hypervisor or vis-versa. For examples during a virtual board context
+switch the control structure allows to store the incoming virtual board context
+setting before the virtual board sends a Hypercall using VBI_CTX_LOAD().
+
+Hypervisor passes (as parameter) a pointer of the configuration structure to the 
+entry function of the virtual core and a boot option flag. 
+
+The VBI library provides a initialization function vbiInit() to ensures that 
+Hypervisor version number is compatible with the VBI library in use. If the versions
+match then the configuration, status and control pointers are stored respectively to
+wrhvVbConfig, wrhvStatus and wrhvVbControl. 
+
+Therefore a virtual board must always call vbiInit() before accessing any data
+provided by Hypervisor nor send a hypercall to it. Refer to to vbiInit() description in the VBI API description document for more information. 
+
+Once the VBI library is initialized the virtual board should employ the provided 
+macros in order to access the fieds in wrhVbConfig, wrhvVbStatus and wrhvVbControl
+data structures. Accessing these structures via the VBI function guaranties source
+level compatibily between VBI versions.
+
+A guest OS should port vbiInit(), the access macros along with the necessary header
+files where the data structrures layout is defined.
+ To be aware:
+\ms
+\m -
+ Changing the order of the field this structure may have serious impact on the
+ integrity of the system. It exists hand crafted macros to match the C
+ structures offset. Therefore any change should be reflected in the macros
+ 
+\m -
+ When a virtual core boots the VMMU is not enbled but a programmer may choose
+ to turn-on the VMMU. In that scenario proper care must be taken to ensure that
+ the address where the control, status or configureation structure is reflected
+ in the VMMU mapping. Technically these area should be treated as I/O region
+ therefore it is encouraged that they are identity mapped.  
+\me
+
+\APPEND vbi/vbi.h
+
+*/
+
+#ifndef __INCvbInterfaceh
+#define __INCvbInterfaceh
+
+#ifdef __ASSEMBLY__
+#define _ASMLANGUAGE
+#else
+#include <linux/types.h>
+#endif
+
+#include <vbi/vbiArch.h>
+#include <vbi/vbiTypes.h>
+#include <vbi/sys/vbiSyscall.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* VB versioning information */
+
+#define	VBI_VERSION_MAJOR	2	/* major version */
+#define	VBI_VERSION_MINOR	0	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+/* macro to align guest fields for a 64-bit hypervisor */
+
+#if defined(LP64)
+# define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			   __attribute__(( aligned(8) )) \
+			   decl_var
+#else
+# if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    decl_var; \
+			    uint32_t pad_var
+# else
+#  define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    uint32_t pad_var; \
+			    decl_var
+# endif
+#endif
+
+#ifdef PRJ_BUILD
+# define VB_PRINTF(fmt, args...)    printf(fmt, ##args)
+#else
+# define VB_PRINTF(fmt, args...)    kprintf(fmt, ##args)
+#endif
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+# define VB_DEBUG_MSG(fmt, args...)    VB_PRINTF(fmt, ##args)
+#else
+# define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+
+/* Configuration Filename for the hypervisor this must not change */
+
+#define VB_WRHV_CONFIGURATION_FILE "wrhvConfig.xml"
+
+/* Hard limits for now */
+
+#define VB_MAX_VIRTUAL_BOARDS    1024
+#define VB_MAX_BUSES             1024
+
+#define VB_MAX_CORES     	 8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+
+#define VB_MAX_WRHV_NAME_LENGTH 64
+
+#ifndef	_ASMLANGUAGE
+typedef int8_t VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
+
+/* Virtual board timestamp is 64 bits */
+
+typedef uint64_t VB_TIMESTAMP;
+#endif
+
+#define VB_MAX_BOOTLINE_LENGTH   256
+#define VB_CONFIG_BOOTLINE_OFFSET	0xdc
+
+/* Virtual Interrupt Controller definitions --------------------------- */
+
+/* 32 is chosen as the maximum number of interrupt sources allowed.
+ * care must be taken if this is changed, since some algorithms and
+ * data structures will require modifications and become more complex
+ */
+
+#define VB_MAX_INTERRUPTS     32
+
+/* The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+
+#define VB_MAX_INTERRUPT_DATA 16
+
+/* Structure offsets for assembler */
+
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+# define VB_CONTROL_REG_STRUCT_END 0
+#endif
+
+# define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#else
+# define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+# define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+/* Assembler offsets for VB_STATUS */
+
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+# define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#else
+# define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+# define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Assembler offsets for VB_CONFIG */
+
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+# define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+# define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+# define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+# define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+# define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#else
+# define VB_CONFIG_VBSTATUS		((2+0) * 8)
+# define VB_CONFIG_VBCONTROL		((2+1) * 8)
+# define VB_CONFIG_SMINFO		((2+2) * 8)
+# define VB_CONFIG_MEMINFO		((2+3) * 8)
+# define VB_CONFIG_INTINFO		((2+4) * 8)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Defines for vbIntInfo intDirection field */
+
+#define VB_INPUT_INT  1
+#define VB_OUTPUT_INT 2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by Razor
+ */
+
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+#ifndef VB_VIOAPIC_ENTRIES_SIZE
+#define VB_VIOAPIC_ENTRIES_SIZE 64
+#endif
+
+#ifndef	_ASMLANGUAGE
+
+/*******************************************************************************
+*
+* VB_CONTROL - Virtual board cores control structure 
+*
+* VB_CONTROL is a data type that defines a virtual core's control structure.
+* This is called the control structure because a core uses to modify it's 
+* state. The code running in the context of a virtual core puts the desired
+* setting in this control and passes to Hypervisor via the Hypercall mechanism.
+* It is suggested to use the provided APIs for manipulating the virtual core
+* control structure instead of directly accessing it's members. 
+* Typically use cases for this structure are for following:
+*\ms
+*\m - 
+* During context switch for setting the incoming context's register state.
+* For more information about this refer to VBI_CTX_LOAD() description in the
+* architecture supplement API documentation.
+*\m -
+* Locking/unlocking the virtual core interrupts.
+*\m -
+* Loading the VMMU configuration data.
+*\m -
+* VIOAPIC configuration registers.
+* 
+*\me   
+* The control structure definition is generic accross the various architecture
+* flavours supported by Hypervisor with the exception of the emulated registers. 
+* There is an architecture specific extention available via a pointer of type 
+* VB_ARCH_STATUS_REGS to accomodate the registers unique for a given hardware
+* platform.
+* However that does imply that other fields defined in this structure are used
+* in every architecture. A field is considered generic if it is usefull at least to
+* two CPU families but not necessary to all CPUs.
+* The VIOAPIC is the only field that is meaning full accross all architectures.
+* Note that some architectures like Intel with VT technology don't require emulated
+* registers. The pointer of emulated registers is included only if 
+*_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
+* with read/write access attribute for the purpose of serving as duplex 
+* communication channel between Hypervisor and a virtual core. This mechanism
+* is fall back when it is not possible to use registers for transmitting data
+* from the virtual core to Hypervisor or vis-versa. More information about 
+* VB_ARCH_CONTROL_REGS may be found in the architecture supplement document.
+*
+* 
+* Control structure graphical illustration
+*\cs
+*    ______________
+*   |              |
+*   |              |<------- 64bits - pointer to arch specific registers 
+*   |              |          (See architecture supplement documentation)         
+*   |--------------|
+*   |              |<------- 32bits -  interrupt state flag
+*   |--------------|
+*   |              |<------- 32bits - virtual core to be loaded context's 
+*   |--------------|                  interrupt state    
+*   |              | 
+*   |              |<------- 64bits - pointer to VMMU configuration
+*   |--------------|
+*   |              |<------- 64bits - pointer to additional VMMU 
+*   |              |                  configuration (reserved for enhancement)  
+*   |--------------|
+*   |              | <------ 64bits - VIOAPIC information header (internal use only)
+*   |              |
+*   |--------------|
+*   |		   |
+*   |              |<------- Nbytes - VIOAPIC redirection table    
+*   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE   
+*   |              |
+*   |--------------|<------- 32bits - Pending interrupt vector number  
+*   |______________|            
+*\ce
+*
+* SYNOPSIS
+*
+* Virtual core's control C data structure type definition
+*\cs
+* typedef struct vbControl {
+*
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbControlRegs.
+*     @/
+*
+*#ifdef  _WRHV_ARCH_HAS_CTRL_REGS         
+*    VB_ALIGN_FIELD_64 (VB_ARCH_CONTROL_REGS  * vbControlRegs, pad1);
+*#endif
+*
+*   /@  0: -1 => Disable all interrupts					@/
+*
+*    uint32_t	intDisable;	
+*
+*   /@ 
+*    @ future interrupt state of a context to be loaded in 
+*    @ vbControl->intDisable after a context switch	    
+*    @/
+*
+*    uint32_t	newIntDisable;	
+*
+*   /@  2: VMMU 0 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*
+*   /@  3: VMMU 1 table for context switch				@/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*   /@ Virtual I/O APIC							@/
+*
+*    VB_ALIGN_FIELD_64 (uint32_t    vIoapicRegisters[VB_VIOAPIC_SIZE], pad4);
+*
+*   /@ actual virtual interrupt pending					@/
+*
+*    uint32_t	intPending;
+*
+*   } VB_CONTROL;
+*\ce
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+*
+* INTERNAL
+* warning!!!!!!!
+* 1. Any modification of this structure field should be reflected in the
+* description.
+* 2. Make sure that VIOAPIC_SIZE is used in the structure
+* 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
+*     the code
+*\COMMAND 
+*/
+
+typedef struct vbControl {
+
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	      
+    VB_ARCH_CONTROL_REGS  vbControlRegs;
+#endif
+
+    uint32_t	intDisable;	/*  0: -1 => Disable all interrupts */
+    uint32_t	newIntDisable;	/*  1: New value for vbControl->intDisable */
+
+				/*  2: VMMU 0 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+
+				/*  3: VMMU 1 table for context switch */
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    uint32_t	intLevelDisable;/* interrupt level enabling */
+
+    /* Virtual I/O APIC */
+
+    VB_ALIGN_FIELD_64 (void *vIoapic, pad3);
+
+    /* actual virtual interrupt pending */
+
+    uint32_t	intPending;
+
+} VB_CONTROL;
+
+
+/*******************************************************************************
+*
+* VB_STATUS - Virtual board's core status structure
+*
+* VB_STATUS is a C data type structure that provides the definition of an area
+* where the state of a given core is posted by Hypervisor before a virtual core is 
+* scheduled to run. The fields of this structure are architecture agnostic. 
+* A pointer is provided to accomodate anything that is specific to the underlying
+* hardware. The architecture specific structure is included only if 
+* _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type  VB_STATUS_ARCH_REGS
+* holding the architecture dependent registers is defined by a file pulled
+* vbi/vbiArch.h at compile type according to CPU value.
+* The definition of VB_ARCH_STATUS_REGS can be found in the architecture
+* supplement documentation.
+* The purpose of this structure is to inform a virtual core at runtime the
+* status of a core's time variant data such as:
+*\ms
+*\m - 
+* Interrupts state
+*\ms
+*\m *
+* current interrupt state
+*\m *
+* previous interrupt state if the core is in an ISR context
+*\m *
+* The pending vector number if any
+*\me
+*\m -
+* A free running clock timestamp
+*\m -
+* Virtual core elapsed timer ticks
+*\m -
+* Current VMMU configuration
+*\me
+*  
+* SYNOPSIS
+*
+* Control structure graphical illustration
+*\cs
+*        _______________   
+*       |		|	
+*       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
+*       |		|		structure pointer
+*       |---------------|
+*       |		|<-------32bits - intPending; pending vector number
+*       |---------------|
+*       |///////////////|<-------32bits - Reserved for future enhencements
+*       |---------------|
+*       |		|<-------64bits - timeStamp; free running clock ticks
+*       |		|
+*       |---------------|
+*       |		|<-------32bits - oldIntDisable; interrupt state before
+*       |---------------|		   an interrupt was injected
+*       |		|<-------32bits - 
+*       |---------------|
+*       |		|
+*       |		|<-------64bits - vmmu0; current VMMU configuration
+*       |---------------|
+*       |		|<-------64bits - vmmu1; reserved for future use
+*       |		|
+*       |---------------|
+*       |		|<-------64bits - tickCount; elapsed virtual core ticks
+*       |		|
+*       |---------------|
+*
+*\ce
+*
+* Virtual core's status C data structure type definition
+*
+*\cs
+* VB_STATUS structure definition
+*
+* typedef struct vbStatus {
+*    /@
+*     @ Some architecture like Intel with hardware virtualization support don't
+*     @ make use vbStatusRegs
+*     @/
+*
+* #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+*    VB_ALIGN_FIELD_64 (VB_ARCH_STATUS_REGS  vbStatusRegs, pad1);
+* #endif
+*
+*    /@ Bits indicating which interrupts are pending			    @/
+*
+*    uint64_t	intPendingType;
+*
+*    /@ reserved field for future use, required for timeStamp alignment	    @/
+*
+*    uint32_t	reserved1;
+*
+*    /@ Timestamp when last interrupt was delivered			    @/
+*
+*    VB_TIMESTAMP timeStamp;  
+*
+*    /@ 
+*     @ Interrupt registers when the hypervisor interrupts a virtual board, 
+*     @ it saves the following information here for use by the virtual board.
+*     @/
+*
+*    /@ value of control->intDisable at time of the interrupt.
+*     @ control->intDisable is set to -1 by WRHV at the time of delivery of
+*     @ the interrupt
+*     @/
+*
+*    uint32_t	oldIntDisable; 
+*
+*    /@ VMMU tables which were active when an MMU exception occurred	    @/
+*
+*    VB_ALIGN_FIELD_64 (void *vmmu0, pad2);
+*    VB_ALIGN_FIELD_64 (void *vmmu1, pad3);
+*
+*    /@ VB wall clock time expressed in the VB clock frequency  @/
+*
+*    uint64_t tickCount;
+*
+* } VB_STATUS;
+*\ce
+*
+*
+* SEE ALSO: VB_ARCH_CONTROL_REGS, architecture supplement document 
+* INTERNAL
+* Make sure that intPendingType modification is reflected in the code
+*
+*\COMMAND
+*/
+
+typedef struct vbStatus {
+
+#ifdef _WRHV_ARCH_HAS_STATUS_REGS   
+    VB_ARCH_STATUS_REGS  vbStatusRegs;
+#endif
+
+    /* Bits indicating which interrupts are pending */
+
+    uint32_t	intPendingType;
+
+    /* reserved field for future use, required for timeStamp alignment */
+
+    uint32_t	reserved1;
+
+    /* Timestamp when last interrupt was delivered */
+
+    VB_TIMESTAMP timeStamp;  
+
+    /* Interrupt registers
+     *
+     * When the hypervisor interrupts a virtual board, it saves the following
+     * information here for use by the virtual board.
+     */
+
+    /* value of control->intDisable at time of the interrupt.
+     * control->intDisable is set to -1 by WRHV at the time of delivery of
+     * the interrupt
+     */
+
+    uint32_t	oldIntDisable; 
+
+    /* VMMU tables which were active when an MMU exception occurred */
+
+    VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
+    VB_ALIGN_FIELD_64 (void *vmmu1, pad2);
+
+    /* Virtual Board clock tick count */
+
+    uint64_t tickCount;
+
+    /* number of times this core has booted */
+
+    uint32_t	 bootCount;	 
+
+    /* initial program load flag */
+
+    uint32_t	 ipl;	 
+
+    /* The simulatror flag  */
+
+    uint32_t	 sim;	 
+
+} VB_STATUS;
+
+/*
+ * ----------------------- Virtual BOARD STATUS PAGE -----------------------
+ *
+ * Read only page used to provide static configuration to the Virtual Board
+ *
+ */
+
+/* Configuration information for interrupts */
+
+typedef struct vbIntInfo {
+    VB_WRHV_NAME intName;	/* the name of this interrupt */
+    uint16_t	 intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
+    uint16_t	 intNumber;	/* the local VB interrupt number */
+    uint32_t	 intCore;	/* the receiving core for this incomming int */
+} VB_INT_INFO;
+
+/* Information about a shared memory region */
+
+typedef struct vbSmInfo {
+    VB_WRHV_NAME name;		/* the name of the shared memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    uint32_t	 type;		/* shared memory type field */
+				/* id's of connected boards */
+    VB_ALIGN_FIELD_64 (void *boardIds, pad2);
+} VB_SM_INFO;
+
+/* Information for the memory map info */
+
+typedef struct vbMemInfo {
+    VB_WRHV_NAME name;		/* the name of the memory region */
+				/* the vbphysical address of the region */
+    VB_ALIGN_FIELD_64 (void *addr, pad1);
+    uint32_t	 length;	/* the length in bytes of the region */
+    uint32_t	 attr;		/* the MMU attributes of the region */
+    VB_WRHV_NAME type;		/* the type of the region */
+} VB_MEM_INFO;
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+
+typedef struct vbConfig {
+
+    /* 
+     *  structure versioning information
+     *  --------------------------------
+     */
+
+    uint32_t major;	/* major revision number */
+    uint32_t minor;	/* minor revision number */
+    uint32_t maint;	/* maintenance revision number */
+    uint32_t pad;
+
+    /* 
+     *  pointers to secondary configuration structures
+     *  ----------------------------------------------
+     */
+
+    /* read-only status information */
+
+    VB_ALIGN_FIELD_64 (VB_STATUS *vbStatus, pad1);
+
+    /* read-write control information */
+
+    VB_ALIGN_FIELD_64 (VB_CONTROL *vbControl, pad2);
+
+    /* shared memory information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_SM_INFO *sharedMemoryRegionsConfigAddress, pad3);
+
+    /* memory regions information (memory map) */
+
+    VB_ALIGN_FIELD_64 (VB_MEM_INFO *memoryRegionsConfigAddress, pad4);
+
+    /* information about incoming and outgoing interrupt connections */
+
+    VB_ALIGN_FIELD_64 (VB_INT_INFO *interruptConfiguration, pad5);
+
+    /* 
+     *  general board specific configuration information
+     *  ------------------------------------------------
+     */
+
+    uint32_t	 pid;		 /* hypervisor context id */
+    uint32_t	 boardID;	 /* board ID from the XML configuration */
+
+    int32_t	 supervisoryMode;/* board is running in privileged mode */
+
+    VB_WRHV_NAME boardName;	 /* the name of this board */
+    uint32_t	 boardType;	 /* the type of this board */
+    uint32_t	 bootCount;	 /* number of times this core has booted */
+
+				 /* entry point for this VB */
+    VB_ALIGN_FIELD_64 (void *resetPC, pad6);
+
+    /* 
+     *  virtual core specific information
+     *  ---------------------------------
+     */
+
+    uint32_t  coreId;		  /* virtual core cpu id */
+    uint32_t  numCores;		  /* number of virtual cores */
+    uint32_t  corePrivateSize;	  /* size of core private memory */
+				  /* pointer to core private memory */
+    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+
+    /* 
+     *  main memory configuration settings 
+     *  ----------------------------------
+     */
+
+    uint32_t  physicalMemorySize; /* the vbPhysical size of RAM */
+    uint32_t  memoryAliasAddress; /* address to which memory is aliased */
+    uint32_t  memoryAliasSize;	  /* size of aliases memory */
+    uint32_t  numMem;		  /* number of memory regions */
+
+    /* 
+     *  shared memory configuration settings
+     *  ------------------------------------
+     */
+
+    /* number of shared memory regions */
+
+    uint32_t  numSm;
+
+    /* shared memory state information */
+
+    VB_ALIGN_FIELD_64 (void *sharedMemoryRegionsStateAddress, pad7);
+
+    /* 
+     *  clock and interrupt configuration
+     *  ---------------------------------
+     */
+
+    /* the frequency of the periodic tick interrupt */
+
+    uint32_t  tickTimerFrequency;	/* ticks per second */
+
+    /* the frequency of the timestamp */
+
+    uint32_t  timeStampFrequency;	/* ticks per second */
+
+    /* number of interrupts connected to this board */
+
+    uint32_t  numInts;
+
+    /* 
+     *  misc settings
+     *  -------------
+     */
+
+    /* OS specific boot line */
+
+    char      bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+    /* spare 32-bit fields for future use */
+
+    uint32_t	spare32[16];
+
+    /* spare 64-bit fields for future use */
+
+    uint64_t	spare64[16];
+
+    /* direct function call interface table */
+
+#if defined (_WRHV_ARCH_HAS_VB_SYSTBL)
+    VB_ALIGN_FIELD_64 (VB_SYSCALL *vbSyscallTable, pad9);
+    VB_ALIGN_FIELD_64 (VB_SYSCALL_STUB2 *vbSyscallStub2, pad10);
+#endif
+
+} VB_CONFIG;
+
+extern VB_CONFIG *wrhvConfig;
+extern VB_CONTROL *wrhvControl;
+extern VB_STATUS *wrhvStatus;
+
+#ifndef __INCvxWorksh 
+extern int kprintf (const char *, ...);
+#else
+extern int printf (const char *, ...);
+#endif 
+
+#endif /*_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbInterfaceh */
diff --git a/include/vbi/vbInterrupt.h b/include/vbi/vbInterrupt.h
new file mode 100644
index 0000000..dc5cb68
--- /dev/null
+++ b/include/vbi/vbInterrupt.h
@@ -0,0 +1,48 @@
+/* vbi/vbInterrupt.h - wrhv virtual interrupt device functions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for managind the virtual interruptor.
+
+*/
+
+#ifndef __INCvbiVbInterrupth
+#define __INCvbiVbInterrupth
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Flags for use with vbiIntControllerVectorFind */
+#define VBI_INT_CONTROLLER_FIND_INPUT_INT  1
+#define VBI_INT_CONTROLLER_FIND_OUTPUT_INT 0
+
+#ifndef _VOIDFUNCPTR_DEFINED
+#define _VOIDFUNCPTR_DEFINED
+typedef void (*VOIDFUNCPTR) (unsigned int, ...);
+#endif /* _VOIDFUNCPTR_DEFINED */
+
+#ifndef	_ASMLANGUAGE
+
+extern void vbiIntControllerHandle (void);
+extern void vbiIntControllerConnect (int vector, VOIDFUNCPTR handler,
+                                     void * param);
+extern void vbiIntControllerFindVector (char * intName, int inputInterrupt,
+                                        int * vector);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiVbInterrupth */
diff --git a/include/vbi/vbShmem.h b/include/vbi/vbShmem.h
new file mode 100644
index 0000000..f323a98
--- /dev/null
+++ b/include/vbi/vbShmem.h
@@ -0,0 +1,49 @@
+/* vbi/vbShmem.h - wrhv memory utility functions */
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for managing memory regions
+
+*/
+
+#ifndef __INCvbiVbShmemh
+#define __INCvbiVbShmemh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+void vbiShmemRegionFind
+    (
+    char *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    unsigned int * length,      /* Length - OUT */
+    unsigned int * attr         /* MMU Attributes - OUT */
+    );
+
+void vbiMemRegionFind
+    (
+    char *         name,        /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    unsigned int * length,      /* Length - OUT */
+    unsigned int * attr         /* MMU Attributes - OUT */
+    );
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiVbShmemh */
diff --git a/include/vbi/vbiArch.h b/include/vbi/vbiArch.h
new file mode 100644
index 0000000..3567d96
--- /dev/null
+++ b/include/vbi/vbiArch.h
@@ -0,0 +1,54 @@
+/* vbi/vbiArch.h - vbi architecture specific definitions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01e,25may09,md   add endian order type defines
+01d,17mar09,mpk  Cavium OCTEON MIPS64 port for hypervisor
+01c,29jan09,mmi  add vbi/ to the header files path
+01b,28jan09,mmi  check PENTIUM4 and PENTIUM, consider error case
+01a,21jan08,mmi  written.
+*/
+
+#ifndef __INCvbiArchh
+#define __INCvbiArchh
+
+/* endian types selectable by the arch specific header files */
+
+#define __VBI_LITTLE_ENDIAN 1234  /* least-significant byte first         */
+#define __VBI_BIG_ENDIAN    4321  /* most-significant byte first          */
+#define __VBI_PDP_ENDIAN    3412  /* LSB first in word, MSW first in long */
+
+/* include the appropriate arch specific header file */
+
+#define PPC85XX		1
+#define PPC32		2
+#define PENTIUM		3
+#define PENTIUM4	4
+#define MIPSI64R2	5
+
+#ifdef CONFIG_X86
+#define CPU	PENTIUM
+#elif defined(CONFIG_PPC)
+#define CPU	PPC85XX
+#endif
+
+#if (CPU == MIPSI64R2)
+# include <vbi/mips64/vbiMips64Arch.h>
+#elif (CPU == PPC85XX) || (CPU == PPC32)
+# include <asm/vbiPpcArch.h>
+#elif (CPU == PENTIUM) || (CPU == PENTIUM4)
+# include <asm/vbiX86Arch.h>
+#else
+# error "no arch header file included"
+#endif
+
+/* ensure the arch has specified a byte ordering */
+
+#if !defined(__VBI_BYTE_ORDER)
+# error: Architecture has not defined a byte order!
+#endif
+
+#endif /* __INCvbiArchh */
diff --git a/include/vbi/vbiErrors.h b/include/vbi/vbiErrors.h
new file mode 100644
index 0000000..d8bf8cd
--- /dev/null
+++ b/include/vbi/vbiErrors.h
@@ -0,0 +1,63 @@
+/* vbi/VbiErrors.h - vbi errors */
+
+/* 
+ * Copyright (c) 2009 Wind River Systems, Inc. 
+ *
+ * The right to copy, distribute, modify or otherwise make use 
+ * of this software may be licensed only pursuant to the terms 
+ * of an applicable Wind River license agreement. 
+ */
+
+/*
+modification history
+--------------------
+01e,14jul09,mmi  add vbi memory errors
+01d,07jul09,mmi  add vbMgmt error numbers
+01c,17jun09,mmi  add VBI_VIOAPIC_NULL
+01b,11jun09,mmi  add VBI_EXCBASE_SET_ERROR
+01a,16apr0r9,mmi written
+*/
+
+#ifndef __INCvbiErrorsh
+#define __INCvbiErrorsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define VBI_ERRORS_START		(0)
+
+/* generic vbi errors */
+
+#define VBI_INVALID_VERSION		(VBI_ERRORS_START + (-1))
+#define VBI_INVALID_IRQ			(VBI_ERRORS_START + (-2))
+#define VBI_INVALID_SHMEM		(VBI_ERRORS_START + (-3))
+#define VBI_INVALID_MEM			(VBI_ERRORS_START + (-4))
+
+/* vbi Exceptions error */
+
+#define VBI_EXC_ERROR_START		(VBI_ERRORS_START + (-1000))
+#define VBI_EXCBASE_SET_ERROR		(VBI_EXC_ERROR_START + (-1))
+
+/* VIOAPIC errors   */
+#define VBI_VIOAPIC_ERROR_START		(VBI_EXC_ERROR_START + (-100))		
+#define VBI_VIOAPIC_NULL		(VBI_VIOAPIC_ERROR_START + (-1))
+#define VBI_VIOAPIC_IRQ_OUTBOUND	(VBI_VIOAPIC_ERROR_START + (-2))
+#define VBI_VIOAPIC_IRQ_INVALID_DIR	(VBI_VIOAPIC_ERROR_START + (-3))
+#define VBI_VIOAPIC_UNAVAIL		(VBI_VIOAPIC_ERROR_START + (-4))
+
+
+/* VB MANAGEMENT errors */
+
+#define VBI_VBMGMT_ERROR_START		(VBI_VIOAPIC_ERROR_START +  (-100))
+#define VBI_ERR_VBMGMT_VB_INVALID	VBI_VBMGMT_ERROR_START +    (-1)	
+#define VBI_ERR_VBMGMT_INVALID_ARG	VBI_VBMGMT_ERROR_START +    (-2)
+#define VBI_ERR_VBGMT_RESET_FAILED	VBI_VBMGMT_ERROR_START +    (-3)
+#define VBI_ERR_VBMGMT_CTX_INVALID	VBI_VBMGMT_ERROR_START +    (-4)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INCvbiVersionh */
diff --git a/include/vbi/vbiInterrupt.h b/include/vbi/vbiInterrupt.h
new file mode 100644
index 0000000..b8b898c
--- /dev/null
+++ b/include/vbi/vbiInterrupt.h
@@ -0,0 +1,46 @@
+/* vbiInterrupt.h - utility functions to read interrupt configuration data*/
+
+/* Copyright 2007 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01i,02jul09,mmi  fix return type
+01h,18jun09,mmi  rename the file
+01g,31mar09,mmi  change interrupt direction flags
+01f,26feb09,mmi  change vbiIntVecFind definition to return vector
+01e,17dec08,mmi  rename vbiIntCtrlFindVector
+01d,20nov08,mmi  adopt new naming convention
+01c,04sep08,dcc  modified vbiIntCtrlConnect() signature
+01b,27nov07,foo  fix parameter
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for utility functions for reading the 
+interrupts configuration data.
+
+*/
+
+#ifndef __INCinterrupth
+#define __INCinterrupth
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+#include <vbi/vbiTypes.h>
+
+extern vbiIrq_t vbiIntVecFind (char * intName, int32_t intDirection);
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCinterrupth */
diff --git a/include/vbi/vbiPaddr.h b/include/vbi/vbiPaddr.h
new file mode 100644
index 0000000..6b84c08
--- /dev/null
+++ b/include/vbi/vbiPaddr.h
@@ -0,0 +1,53 @@
+/* vbiPaddr.h - translate virtual address to a physical address */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01a,03sep09,foo written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for translating virtual address to a physical address.
+
+*/
+
+ 
+#ifndef __INCvbiPaddrh
+#define __INCvbiPaddrh
+
+#include <vbi/vbiTypes.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+extern vbiStatus_t vbiGuestDmaAddrGet
+    (
+    vbiGuestPhysAddr_t gaddr,   /* guest physical address to translate */
+    vbiPhysAddr_t  *paddr       /* translated physical address */
+    );
+extern vbiStatus_t vbiGuestPhysToPhysAddr
+    (
+    vbiGuestPhysAddr_t gaddr,   /* guest physical address to translate */
+    vbiPhysAddr_t  *paddr       /* translated physical address */
+    );
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiPaddrh */
diff --git a/include/vbi/vbiShmem.h b/include/vbi/vbiShmem.h
new file mode 100644
index 0000000..6ce7945
--- /dev/null
+++ b/include/vbi/vbiShmem.h
@@ -0,0 +1,59 @@
+/* vbiShmem.h - Virtual Interface  memory utility functions */
+
+/* Copyright 2008 Wind River Systems, Inc. */
+
+/*
+modification history
+--------------------
+01g,14jul09,mmi  update with vbiStatus_t return type
+01f,03jul09,mmi  add private memory function
+01e,12dec08,mmi  replace razor with wrhv
+01d,11dec08,mmi  use typedef's instead natives
+01c,20nov08,mmi  adopt new naming convention
+01b,26nov07,foo  update prototype
+01a,25may07,foo  written
+*/
+
+/*
+DESCRIPTION
+
+This header file declares the vbi API for managing memory regions
+
+*/
+
+#ifndef __INCvbiShmemh
+#define __INCvbiShmemh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef	_ASMLANGUAGE
+
+extern vbiStatus_t vbiShmemRegionFind
+    (
+    int8_t *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    );
+
+extern vbiStatus_t vbiMemRegionFind
+    (
+    int8_t *         name,        /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    );
+
+/* find the base address and length of a core's private memory */
+
+extern vbiStatus_t vbiCorePrvMemFind (void * * addr, size_t *  length);  
+
+#endif /* _ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiShmemh */
diff --git a/include/vbi/vbiTypes.h b/include/vbi/vbiTypes.h
new file mode 100644
index 0000000..dd346eb
--- /dev/null
+++ b/include/vbi/vbiTypes.h
@@ -0,0 +1,48 @@
+/* vbiTypes.h - virtual board interfaces types definitions */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+
+/*
+modification history
+--------------------
+01d,12aug09,dtr  ADd vbiGuestPhysAddr type.
+01c,02jul09,mmi  fixe vbiIrq_t and vbiVector_t types
+01b,11jun09,mmi  add vbiIntState_t, vbiMemAttr_t, etc..
+01a,09jun09,mmi  written
+*/
+
+#ifndef __INCvbiTypesh
+#define __INCvbiTypesh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef _ASMLANGUAGE
+#include <linux/types.h>
+
+typedef int32_t			vbiVb_t;
+typedef int32_t			vbiCore_t;
+typedef int32_t			vbiCtx_t;
+typedef uint64_t    		vbiPhysAddr_t;
+typedef void *       		vbiGuestPhysAddr_t;
+typedef int32_t			vbiStatus_t;		
+typedef int32_t			vbiIntState_t;		
+typedef int32_t			vbiMemAttr_t;		
+typedef int32_t			vbiVector_t;		
+typedef int32_t			vbiIrq_t;		
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif  /* __INCvbiTypesh */
diff --git a/kernel/vbiInterrupt.c b/kernel/vbiInterrupt.c
new file mode 100644
index 0000000..245372c
--- /dev/null
+++ b/kernel/vbiInterrupt.c
@@ -0,0 +1,96 @@
+/* vbiInterrupt.c - virtual board interrupt configuration utility */
+
+/*
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01k,03jul09,mmi  update description
+01j,19jun09,mmi  revert to previous name for this file
+01i,26feb09,mmi  change vbiIntVecFind definition to return vector
+01h,17dec08,mmi  rename vbiIntCtrlFindVector with vbiIntVecFind
+01g,13dec08,mmi  remove razorVxWorks.h 
+01f,21nov08,mmi  include vbi.h instead of vdk.h
+01e,19nov08,mmi  change API's names to vbiXXX and miscl. cleanup
+01d,10sep08,md   fix vbiIntCtlrConnect parameters
+01c,23nov07,foo  fix includes
+01b,25oct07,foo  update for real hardware interrupt implementation
+01a,09may07,foo  written
+*/
+
+/*
+ * This module contains the code for accessing the the interrupts configuration
+ * of the virtual board.
+ */
+
+/*#define DEBUG 1*/
+#ifdef DEBUG
+#define DEBUGM(x) x
+#else
+#define DEBUGM(x)
+#endif
+
+#include <vbi/vbInterface.h>
+#include <vbi/vbiInterrupt.h>
+#include <vbi/vbiErrors.h>
+
+#include <linux/string.h>
+#include <linux/irq.h>
+#include <linux/irqreturn.h>
+#include <linux/module.h>
+
+
+
+/******************************************************************************
+*
+* vbiIntVecFind - determine the irq for a specified name
+*
+* This function finds the irq number of a named interrupt from  the virtual
+* board configuration information.
+* 
+* The <intDirection> is either input or output. VB_INPUT_INT for input,
+* VB_OUTPUT_INT for output.
+*
+* EXAMPLES:
+* \cs
+*     fredIntVector = vbiIntVecFind ("fred", VB_INPUT_INT);
+* \ce
+*
+* RETURNS: vector number, VBI_INVALID_IRQ if not found
+*
+*/
+
+vbiIrq_t vbiIntVecFind
+    (
+    char *  intName,		/* string name of the interrupt */
+    int32_t  intDirection 	/* interrupt direction */
+    )
+    {
+    VB_INT_INFO * info = wrhvConfig->interruptConfiguration;
+    int32_t       num  = wrhvConfig->numInts;
+    int32_t       i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (intDirection != (int32_t)(info->intDirection))
+            continue;
+
+        if (!strncmp ((char *)intName, (char *)info->intName,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+
+            /* Found */
+
+            return (int32_t)info->intNumber;
+            }
+        }
+
+    return (VBI_INVALID_IRQ); /* no match */
+    }
+EXPORT_SYMBOL(vbiIntVecFind);
diff --git a/kernel/vbiPaddr.c b/kernel/vbiPaddr.c
new file mode 100644
index 0000000..741e61c
--- /dev/null
+++ b/kernel/vbiPaddr.c
@@ -0,0 +1,114 @@
+/* vbiPaddr.c - translate virtual address to a physical address */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01h,12aug09,dtr  Add vbiGuestDmaAddrGet and change name of vbiVirtToPhys to be
+                 vbiGuestPhysToPhys.
+01g,09jun09,mmi  rename physAddr_t to vbiPhysAddr_t
+01f,25may09,mmi  fix function prototype to use  physAddr_t for the physical
+                 address
+01e,15may09,mmi  fix apigen errors
+01d,23jan09,mmi  fix included header file
+01c,13dec08,mmi  replace vbiSyscalls.h with vbiSyscall.h
+01b,19nov08,mmi  introduced the VBI terminology
+01a,18apr08,md   written
+*/
+
+/*
+DESCRIPTION
+These modules provide interfaces to translate the current context's guest
+physical address into the physical machine address. vbiGuestDmaAddrGet is 
+specifically for a guest wanting an address that can be used by a DMA device.
+vbiGuestPhysToPhysAddr is used to return an absolute physical address to used 
+perhaps to communicate with the hypervisor itself maybe buffer pointers.
+*/
+
+/* includes */
+
+#include <vbi/vbInterface.h>
+
+
+/*******************************************************************************
+*
+* vbiGuestPhysToPhysAddr - translate the spcified guest physical to physical 
+*                          address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address to physical address. This may be required for quick buffer 
+* transfer that requires the physical address of a memory region. The 
+* hypervisor may be running with > 4GB memory so the phys address is always 
+* 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestPhysToPhysAddr 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ guest phys addr to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure. The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestPhysToPhysAddr
+    (
+    vbiGuestPhysAddr_t gaddr,	/* guest physical address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 ));
+    }
+
+/*******************************************************************************
+*
+* vbiGuestDmaAddrGet - translate the spcified guest physical to DMA address
+*
+* This function makes a hypervisor call to translate the specified guest 
+* physical address  to a physical address. This may be required for a device 
+* driver that requires the address it can use for DMA. The hypervisor may be 
+* running with > 4GB memory so the phys address is always 64-bit.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiGuestDmaAddrGet 
+*		(
+*		vbiGuestPhysAddr_t gaddr,  /@ virtual address to translate @/
+*		vbiPhysAddr_t *paddr /@ pointer to the the physical  @/
+*               )
+*\ce
+*
+* RETURNS: Ok or an error number in case of failure.  The vbiPhysAddr  
+* populated by the hypervisor with the required physical address (64-bit)
+*
+* ERRNO: N/A
+*
+*/
+vbiStatus_t vbiGuestDmaAddrGet
+    (
+    vbiGuestPhysAddr_t gaddr,	/* virtual address to translate */
+    vbiPhysAddr_t  *paddr	/* translated physical address */
+    )
+    {
+
+    /* use the hypervisor ioctl system call to do the translation */
+
+    return (vbiHyIoctl (VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0));
+    }
diff --git a/kernel/vbiShmem.c b/kernel/vbiShmem.c
new file mode 100644
index 0000000..bf63a4e
--- /dev/null
+++ b/kernel/vbiShmem.c
@@ -0,0 +1,206 @@
+/* vbiShmem.c - shared memory utility functions */
+
+/*
+ * Copyright (c) 2007 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01k,14jul09,mmi  fix private memory base get
+01j,03jul09,mmi  add private memory utility function
+01i,25may09,mmi  introduce vbiAttr_t for memory region attributes
+01h,22may09,mmi  revert to previous type function argument
+01g,15may09,mmi  fix apigen errors
+01f,17dec08,mmi  Use the correct number of memory region
+01e,12dec08,mmi  replace VB_MAX_RAZOR with VB_MAX_WRHV
+01d,11dec08,mmi  include vbi.h by default
+01c,19nov08,mmi  removed duplicate definition and rename functions to vbiXXX
+01b,23nov07,foo  fix includes
+01a,09may07,foo  written
+*/
+
+/*
+DESCRIPTION
+This module contains the code for retriving the memory regions assigned to
+a virtual board. The information is passed in to the virtual board via the
+configuration structure. There is a descriptor table for each type of memory.
+
+\sh MEMORY TYPES
+\ms
+\m -
+There is a memory memory region assigned only to each board which can be
+retrieved by calling vbiMemRegionFind().
+\m -
+There is a shared memory which may be shared with other boards in the
+system. The shared memory can be retrieved by using vbiShmemRegionFind()
+
+\m -
+Each core in the system is assigned a private memory region. The base address
+and the length of this region may obtained by calling vbiCorePrvMemFind ()
+Alternatively the following macros can be used to obtained similar information
+    - 
+    -
+*/
+
+#include <vbi/vbInterface.h>
+#include <vbi/vbiShmem.h>
+#include <vbi/vbiErrors.h>
+#include <linux/string.h>
+#include <linux/module.h>
+
+/******************************************************************************
+*
+* vbiShmemRegionFind - locate the shared memory parameters for a given region
+*
+* This function finds the shared memory region associated with the name 
+* specified. The first argument to this function indicates the name of the
+* shared to find. If this region exists in the list of configured regions the
+* address, length and MMU attributes are set in the pointers passed in as 
+* arguments.
+* 
+* SYNOPSIS
+*\cs
+*
+* vbiStatus_t vbiShmemRegionFind
+*   (
+*   const char *    smName,	/@ String name of the region    @/
+*   void * *	    addr,	/@ Location - OUT		@/
+*   size_t *	    length,	/@ Length - OUT			@/
+*   vbiAttr_t *	    attr	/@ MMU Attributes - OUT		@/
+*    )
+*\ce
+*
+* RETURNS: OK or an errror number in case of failure
+*
+* ERRNO:                                
+*
+* SEE ALSO: vbiMemRegionFind() 
+*/
+
+vbiStatus_t vbiShmemRegionFind
+    (
+    int8_t *         smName,      /* String name of the region */
+    void * *       addr,        /* Location - OUT */
+    uint32_t * length,      /* Length - OUT */
+    uint32_t * attr         /* MMU Attributes - OUT */
+    )
+    {
+    VB_SM_INFO * info = wrhvConfig->sharedMemoryRegionsConfigAddress;
+    int32_t          num  = wrhvConfig->numSm;
+    int32_t          i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!strncmp ((char *)smName, (char *)info->name, 
+	    VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return 0;
+            }
+        }
+    *addr = 0;
+    return (VBI_INVALID_SHMEM);
+    }
+EXPORT_SYMBOL(vbiShmemRegionFind);
+/******************************************************************************
+*
+* vbiMemRegionFind - locate the memory parameters for a given region
+*
+* This function finds the memory region associated with the name specified. 
+* The first argument to this function indicates the name of the memory to find
+* If this region exists in the list of configured regions the address, 
+* length and MMU attributes are set in the pointers passed in as
+* arguments.
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiMemRegionFind
+*   (
+*   const char *    name,   /@ String name of the region    @/
+*   void * *	    addr,   /@ Location - OUT		    @/
+*   size_t *	    length, /@ Length - OUT		    @/
+*   vbiAttr_t *	    attr    /@ MMU Attributes - OUT	    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiMemRegionFind
+    (
+    int8_t   *	    name,	/* String name of the region  */
+    void   * *	    addr,	/* Location - OUT		    */
+    uint32_t    *length,	/* Length - OUT		    */
+    uint32_t *	    attr	/* MMU Attributes - OUT	    */
+    )
+    {
+    VB_MEM_INFO * info = wrhvConfig->memoryRegionsConfigAddress;
+    int32_t      num  = wrhvConfig->numMem;
+    int32_t      i;
+
+    for (i = 0; i < num; i++, info++)
+        {
+        if (!strncmp ((char *)name, (char *)info->name,
+            VB_MAX_WRHV_NAME_LENGTH))
+            {
+            /* Found */
+            *addr   = info->addr;
+            *length = info->length;
+            *attr   = info->attr;
+            return 0;
+            }
+        }
+    *addr = 0;
+
+    return (VBI_INVALID_SHMEM);
+    
+    }
+
+/******************************************************************************
+*
+* vbiCorePrvMemFind - locate the private memory for a core
+*
+* This function gets the base address of the private memory region assigned to
+* the running core. 
+*
+* SYNOPSIS
+*\cs
+* 
+* vbiStatus_t vbiCorePrvMemFind 
+*   (
+*   void * *    addr,	    /@ Location - OUT		    @/
+*   size_t *	length	    /@ Length - OUT		    @/
+*    )
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* RETURNS: None
+*
+*/
+
+vbiStatus_t vbiCorePrvMemFind 
+    (
+    void * *       addr,      /* Location - OUT */
+    size_t *     length       /* Length - OUT */
+    )
+    {
+
+    *addr = (void *)wrhvConfig->corePrivate;
+    *length = wrhvConfig->corePrivateSize;
+    
+    return 0;
+    }
+
-- 
1.6.3.3

