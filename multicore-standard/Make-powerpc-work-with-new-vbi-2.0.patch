From fddc6bdb16f0da77587981d33d7686810da64ce1 Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Thu, 8 Oct 2009 21:23:29 -0400
Subject: [PATCH] Make powerpc work with new vbi 2.0.

Cutover from old to new interfaces is NOT complete, as
entries under arch/powerpc/kernel/ are still using
interfaces which are supposed to be hidden.  The plan is
to migrate off them now that the full vbi with the new
interfaces is available.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/powerpc/include/asm/pv_dma-mapping.h   |    2 +-
 arch/powerpc/include/asm/pv_pgtable-ppc32.h |    2 +-
 arch/powerpc/include/asm/wrhv.h             |    2 +-
 arch/powerpc/kernel/Makefile                |    3 +-
 arch/powerpc/kernel/entry_32.S              |    3 +
 arch/powerpc/kernel/head_wrhv.S             |    3 +-
 arch/powerpc/kernel/vbiPpcDoc.c             |  691 +++++++++++++++++++++++++++
 arch/powerpc/kernel/vbiPpcShow.c            |  102 ++++
 arch/powerpc/kernel/vbiSyscalls.S           |  267 ++++++-----
 arch/powerpc/kernel/vbiUtil.c               |    6 +-
 arch/powerpc/kernel/vmmuDisplay.c           |    4 +-
 arch/powerpc/kernel/wrhv.c                  |   12 +-
 arch/powerpc/kernel/wrhv_entry_32.S         |    1 +
 arch/powerpc/kernel/wrhv_misc_32.S          |    1 +
 arch/powerpc/platforms/85xx/wrhv_8572ds.c   |   42 ++-
 include/vbi/ppc/vbiPpcArch.h                |    4 +
 include/vbi/support/asm.h                   |    8 +
 include/vbi/support/sys/vmmu.h              |    2 -
 include/vbi/vbiArch.h                       |    4 +
 include/vbi/vbiTypes.h                      |    6 +
 kernel/vbiShow.c                            |    4 +-
 21 files changed, 1035 insertions(+), 134 deletions(-)
 create mode 100644 arch/powerpc/kernel/vbiPpcDoc.c
 create mode 100644 arch/powerpc/kernel/vbiPpcShow.c

diff --git a/arch/powerpc/include/asm/pv_dma-mapping.h b/arch/powerpc/include/asm/pv_dma-mapping.h
index bd148ed..2a6fc4a 100644
--- a/arch/powerpc/include/asm/pv_dma-mapping.h
+++ b/arch/powerpc/include/asm/pv_dma-mapping.h
@@ -13,7 +13,7 @@
 #define dma_alloc_coherent	paravirt_dma_alloc_coherent
 #define dma_map_single		paravirt_dma_map_single
 
-#include <vbi/vbiPaddr.h>
+#include <vbi/vbi.h>
 
 static inline void *paravirt_dma_alloc_coherent(struct device *dev, size_t size,
                                        dma_addr_t * dma_handle,
diff --git a/arch/powerpc/include/asm/pv_pgtable-ppc32.h b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
index dde80b7..e61758d 100644
--- a/arch/powerpc/include/asm/pv_pgtable-ppc32.h
+++ b/arch/powerpc/include/asm/pv_pgtable-ppc32.h
@@ -7,7 +7,7 @@
 #define set_pte_at native_set_pte_at
 
 #if defined(CONFIG_WRHV)
-#include <vbi/sys/vmmu.h>
+#include <vbi/support/sys/vmmu.h>
 #include <vbi/vbInterface.h>
 
 /* redefine wrhv paravirtual operations */
diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 9adb8c9..84a4881 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -20,7 +20,7 @@ extern void wrhv_mapping(void);
 extern void wrhv_restart(void);
 extern unsigned long __init wrhv_find_end_of_memory(void);
 extern void wrhv_power_save(void);
-extern int wrhv_vioapic_get_irq(void);
+extern unsigned int wrhv_vioapic_get_irq(void);
 extern void wrhv_init_irq(void);
 extern void __init wrhv_calibrate_decr(void);
 extern void __init wrhv_time_init(void);
diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index 4e7b08f..39af9b7 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -112,7 +112,8 @@ obj-$(CONFIG_8XX_MINIMAL_FPEMU) += softemu8xx.o
 
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o
 
-obj-$(CONFIG_WRHV)		+= vbiSyscalls.o vbiUtil.o wrhv.o vmmuDisplay.o
+obj-$(CONFIG_WRHV)		+= vbiSyscalls.o vbiUtil.o wrhv.o \
+				   vmmuDisplay.o vbiPpcDoc.o vbiPpcShow.o
 
 obj-$(CONFIG_PARAVIRT)         += paravirt.o
 
diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S
index 7dcdf97..5ea8c58 100644
--- a/arch/powerpc/kernel/entry_32.S
+++ b/arch/powerpc/kernel/entry_32.S
@@ -31,6 +31,9 @@
 #include <asm/asm-offsets.h>
 #include <asm/unistd.h>
 #include <asm/ftrace.h>
+#ifdef CONFIG_WRHV
+#include <vbi/syscalls.h>
+#endif /* CONFIG_WRHV */
 
 /*
  * MSR_KERNEL is > 0x10000 on 4xx/Book-E since it include MSR_CE.
diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index 8514995..0a45140 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -45,7 +45,8 @@
 #include "head_booke.h"
 #include "head_wrhv.h"
 #include <vbi/vbInterface.h>
-#include <vbi/sys/vmmu.h>
+#include <vbi/support/sys/vmmu.h>
+#include <vbi/syscalls.h>
 
 /* As with the other PowerPC ports, it is expected that when code
  * execution begins here, the following registers contain valid, yet
diff --git a/arch/powerpc/kernel/vbiPpcDoc.c b/arch/powerpc/kernel/vbiPpcDoc.c
new file mode 100644
index 0000000..0234e13
--- /dev/null
+++ b/arch/powerpc/kernel/vbiPpcDoc.c
@@ -0,0 +1,691 @@
+/* vbiPpcDoc.c - Virtual Board Interface APIs supplement for PPC */
+
+/*
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind RIver License agreement.
+ */
+
+/*
+modification history
+--------------------
+01j,24sep09,mpk  updates docs for vbiVbRegisterRead
+01i,10sep09,mmi  update ppc header file path
+01h,10sep09,mmi  update ppc docs
+01g,31jul09,mpk  update comments for vbiVbRegisterRead, vbiVbRegisterWrite
+01f,18jul09,mmi  fix example for mdio
+01e,18jul09,mmi  update info about sending message to bspserver
+01d,07jul09,mmi  fix int lock macro comments
+01c,12jun09,mmi  remove vioapic from here
+01b,26may09,mmi  ensure that vbiIntCoreLock returns the previous state
+01a,12may09,mmi written
+*/
+
+/*
+DESCRIPTION
+The module contains the VBI PowerPc architecture supplement. The APIs described
+below are either available only for PPC platforms or their behaviour is architecture
+dependant.
+
+\sh HYPERCALLS
+This file implements the APIs to make hypercalls to perform operations that require
+hypervisor assistant. A hypercall is based on system call trap that jumps to
+hypervisor exception handler. Some operations that are time critical are implemented
+using a mechanism referred as "fast hypercall". A fast hypercall is identical to a
+regular hypercall except that the system call handler is hand crafted to avoid the
+need of an exception stack.  In some instances they a hypercall may not even return
+(eg. context loading). 
+
+All hypercalls preserve the following registers:
+\ms 
+\m -
+	SRR0 (PC)
+\m -
+	CR (condition register)
+\m -
+	SRR1 (MSR)
+\m -
+	sp (stack pointer)
+\m -
+	lr (link register)
+\m -
+	r2 (sdata2 pointer)
+\m -
+	r13 (sdata pointer)
+\m -
+	r14-r32 (global registers)
+\me
+
+
+\sh FAST HYPERCALLS
+Following is the list of APIs that utilize fast hypercalls mechanism. 
+\ms
+\m - 
+void VBI_CTX_LOAD(void):
+This is a assembly MACRO that may be used by a guest OS to switch to a new context.
+The guest sets the register sets to be loaded in the VB control structures and calls
+this MACRO to make the hypercall.
+\m -
+vbiStatus_t vbiICacheFlush():
+This routine flushes the instruction cache for the calling core.
+\m -
+This routine flushes the data cache for the calling core.
+vbiStatus_t vbiDCacheFlush():
+\m -
+vbiStatus_t vbiIntVCoreUnlock():
+This routine unlocks interrupts for the calling core. For optimization purpose a 
+hypercall is made only if interrupts were queue while locked.
+\me
+
+\sh ACCESSING WRHV BSP DEVICES
+
+Devices that are shared between the different guests are managed by WRHV
+hyperkernel. These devices manager accepts request submitted using vbiSend().
+The guest finds the server handle by using vbiNsLookup (), initializes the
+predefined input/output message buffers then invokes vbiSend() to transmit the
+request. The input message buffer type is VBI_BSP_MSG. The reply message buffer
+type is VBI_BSP_MSG_REPLY. The request type in the input message is based on
+the nature of the request which can be one of the following types:
+\ms 
+\m - VBI_MDIO_READ for reading an MDIO register
+\m - VBI_MDIO_WRITE for modifying an MDIO register
+\m - VBI_BSP_CLK_FREQ  for reading the BSP clok frequency
+\me
+
+\cs
+\sh BSP MESSAGES BUFFER FORMAT
+
+/@ Input message format @/
+
+typedef struct vbiBspMsg
+    {
+    MSG_HEADER hdr;                     /@ message header @/
+    uint32_t   request;                 /@ request type @/
+
+    union
+        {
+        struct
+            {
+            uint32_t bus;
+            uint32_t phyAddr;
+            uint32_t regNum;
+            uint32_t page;
+            } mdioRead;
+        struct
+            {
+            uint32_t bus;
+            uint32_t phyAddr;
+            uint32_t regNum;
+            uint32_t page;
+            uint32_t dataVal;
+            } mdioWrite;
+        } arg;
+
+    } VBI_BSP_MSG;
+
+/@ Output message format @/
+
+typedef struct
+    {
+    MSG_HEADER hdr;                     /@ message header 	    @/
+    uint32_t   status;                  /@ request completion status @/
+    uint32_t   dataVal;
+    } VBI_BSP_MSG_REPLY;
+
+/@Generic message header @/
+
+typedef struct msg_header {
+    uint32_t msgId;     /@ message type identification @/
+    uint32_t msgArg;    /@ argument associated with message type @/
+} MSG_HEADER;
+
+\ce
+
+\sh Example
+\cs
+        VBI_BSP_MSG             inMsg; /@ input message buffer  @/
+        VBI_BSP_MSG_REPLY       reply; /@ output message buffer @/
+        VBI_NS_HANDLE		serviceHandle;
+        vbiStatus_t		rc;
+
+	/@ 
+	 @ What is the request type ?
+         @ VBI_MDIO_READ, VBI_MDIO_READ or VBI_BSP_CLK_FREQ
+	 @    
+	 @/
+
+        mdioMsg.request = <request type>; 
+	
+	/@ 
+         @ The input message structure is populated according to the type
+	 @ request specified. For example for writting to a phy the user
+	 @ must specify the bus, phy addr, reg number, and the input 
+	 @ value. See the union used for the inMsg type. 
+         @ The example is for writting a value to a phy register.
+         @/
+
+	/@ bus number    @/
+        
+	*((uint32_t*)&inMsg.arg.mdioRead.bus) = <phyBusNumber>;   
+	
+	/@ the phy address @/
+
+        *((uint32_t*)&inMsg.arg.mdioRead.phyAddr) = <phyaddr>;  
+	
+	/@ the register number @/
+
+        *((uint32_t*)&inMsg.arg.mdioRead.regNum) = <regNum>;	
+
+	/@ Find the destination server to send the message to @/
+
+        rc = vbiNsLookup ("bspServer", 0, &serviceHandle);
+
+        if (rc != OK)
+            kprintf ("vbiSend returned error\n");
+
+        rc = vbiSend (serviceHandle, &inMsg,
+                sizeof(inMsg), &reply, sizeof(reply), NULL, NULL);
+
+        kprintf ("replied value 0x%d\n", reply.dataVal);
+\ce
+\APPEND ../../../vbi/include/ppc/vbiPpcArch.h
+*/
+
+/*******************************************************************************
+*
+* VBI_CTX_LOAD - Load a guest context
+*
+* This routine is implemented as an assembly MACRO since it's callers can't
+* reference C functions. This MACRO  makes a hypercall to load a context for a guest
+* OS. The guest OS running on the core is expected to store a set of registers that
+* represent the new context to load in the it's control structure then call 
+* VBI_CTX_LOAD() MACRO to switch to the new context. The Following are the registers
+* loaded from the control structure:
+*
+*\ms
+*\m 1 -
+* VB_CONTROL_SRR0	     ------->  SRR0
+*\m 2 -
+* VB_CONTROL_SRR1	     -------> SRR1 
+*\m 3 -
+* VB_CONTROL_CR		     -------> CR
+*\m 4 -
+* VB_CONTROL_R0		     -------> R0
+*\m 5 -
+* VB_CONTROL_EMSR	     -------> MSR 
+*\m 6 -
+* VB_CONTROL_DBCR0	     -------> DBCR0 
+*\m 7 -
+* VB_CONTROL_NEW_INT_DISABLE -------> VB_CONTROL_INT_DISABLE 
+* If interrupts are being reenabled then we ensure that any pending interrupts are
+* delivered before the new context is actived.
+*
+* Note that registers that are not saved by Hypervisor must be loaded by the guest
+* OS.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void  VBI_CTX_LOAD () 
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK(), 
+*           VBI_INT_VCORE_STATE_GET()
+*/
+
+
+/*******************************************************************************
+*
+* vbiIcacheFlush - flush the instruction cache
+*
+* This routine makes a hypercall to flush the instruction cache of the calling
+* core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiIcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the instruction cache to flush @/
+*	    size_t len  /@ length of memory to flush @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or an error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiDcacheFlush - flush the specified Data cache
+*
+* This routine makes a hypercall to flush the data cache of the calling core
+* for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiDcacheFlush 
+*	    (
+*	    void * addr /@ starting address of the data cache to flush @/
+*	    size_t len  /@ length of memory to flush                   @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiTlbFlush(), vbiIcacheFlush()
+*/
+
+/*******************************************************************************
+*
+* vbiCacheTextUpdate - flush data cache then invalidate instruction cache
+*
+* This routine makes a hypercall to flush the data cache then invalidates the
+* instruction cache of the calling core for the specified address range.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiCacheTextUpdate 
+*	    (
+*	    void * addr /@ starting address to perform textUpdate operation @/
+*	    size_t len  /@ length of memory in bytes			    @/
+*	    ) 
+*
+*\ce
+*
+* RETURNS: OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiDcacheFlush(), vbiIcacheFlush()
+*/
+
+/******************************************************************************
+*
+* VBI_INT_VCORE_LOCK - lock a core's interrupts macro
+*
+* This MACRO disables the currently running core interrupts and returns the
+* previous interrupts state. The interrupt status field in wrhvVbControl
+* structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
+* interrupts state is loaded to the register passed in as the first argument to
+* this MACRO. 
+* A hypercall is not needed to perform this operation. 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_LOCK (reg0, reg1, reg2)	\
+*	{
+*	load -1 to reg1
+*	load wrhvVbControl address to reg2
+*       read the previous value and store in reg0
+*	Disable interrupts by loading reg1 to VB_CONTROL_INT_DISABLE(reg2)
+*	}
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
+*
+* This MACRO is implemented in assembly to enable a core's interrupts. It
+* enables the interrupts by clearing to zero the value in the core's control
+* structure and and makes a fast hypercall if need be. A hypercall is made only
+* if found that interrupts are pending. The pending interrupts are checked by
+* reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
+* positive integer greater than zero indicates that interrupts are pending
+* which causes this macro to make a hypercall in order to drain the pending
+* interrupts. This MACRO expects two general purpose registers. The first 
+* register is used to load the value to store and the second is used for
+* holding the destination address of the control or status structure.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_UNLOCK (reg0, reg1) 
+*	{
+*	load "0" to reg1
+*	load address of wrhvVbControl in reg0 
+*	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
+*
+* checkStatus:
+*	load address of wrhvVbStatus in reg0
+*       load VB_STATUS_INT_PENDING(reg0) in reg1
+*       check if reg1 is equal to zero
+*       if true return
+*	otherwise send an hypercall 
+*       go to checkStatus
+*	}
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_STATE_GET()  
+*/
+
+/*******************************************************************************
+*
+* VBI_INT_VCORE_STATE_GET - Get interrupts state
+*
+* This MACRO is implemented in assembly to read the interrupt state of the
+* currently running core. It relies on a passed in general purpose register
+* to store the current state of interrupts. The status is -1 if locked
+* otherwise 0.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* VBI_INT_VCORE_STATE_GET (reg0)
+*	{
+*       Load the interrupt status from wrhvVbControl to reg0
+*	}
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), vbiIntVCoreStateGet(),
+*	    VBI_INT_VCORE_LOCK(), VBI_INT_VCORE_UNLOCK()  
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreLock - lock interrupts
+*
+* This routine locks interrupts for the calling core. This is a C wrapper 
+* function for VBI_INT_VCORE_LOCK() assembly macro. It locks interrupts returns
+* and returns the previous state of interrupts.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntState_t vbiIntVCoreLock (void)
+*
+*\ce
+*
+* RETURNS: TRUE is interrupts were locked before this operation otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreUnlock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreUnlock - unlock interrupts interrupts for running core
+*
+* This routine enables interrupts and makes a fast hypercall if pending
+* interrupts are detected for the calling core. This is a C wrapper function for
+* the assembly MACRO VBI_INT_VCORE_UNLOCK(). 
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* void vbiIntVCoreUnlock (void)
+*
+*\ce
+*
+* RETURNS: N/A
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreStateGet(), VBI_INT_VCORE_LOCK(),
+*           VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiIntVCoreStateGet - Get interrupts state for running core
+*
+* This routine returns the interrupts state for the calling core. This is C 
+* wrapper function for VBI_INT_VCORE_STATE_GET(). If interrupts are locked it
+* returns TRUE if interrupts are locked otherwise FALSE.
+*
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiIntStatus_t vbiIntVCoreStateGet (void)
+*
+*\ce
+*
+* RETURNS: TRUE if interrupts are locked otherwise FALSE
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiIntVCoreLock(), vbiIntVCoreUnlock(), VBI_INT_VCORE_LOCK(),
+*	    VBI_INT_VCORE_UNLOCK(), VBI_INT_VCORE_STATE_GET()
+*/
+
+/*******************************************************************************
+*
+* vbiExcBaseSet - Set the exceptions vector table base for a virtual core
+*
+* This routine changes the exceptions vector table base address for the active
+* virtual core. By default the base address of the exception table is at address
+* 0x0.
+* If the guest OS programmer wishes to move this address then this function must
+* be called to inform hypervisor. This function must be called with interrupts
+* disabled to prevent hypervisor to deliver interrupts to an incorrect table.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcBaseSet 
+*	    (
+*	    void * excTblBase /@ New exception table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiVioapicIntUnmask(),vbiVioapicIntMask() vbiVioapicIntAck(),
+*	    vbiVioapicIntRedirect(), vbiVioapicIntSend()
+*/
+
+/*******************************************************************************
+*
+* vbiVbRegisterRead - Read a remote core's registers
+*
+* This routine makes a hypercall to read a remote core's registers. The register
+* control structure contains information about the registers to read and the
+* destination buffers to store them.
+* 
+* It is possible to read registers while the target VB's core is still running
+* it doesnt have to be suspended before reading the registers.
+* 
+* SYNOPSIS
+*\cs
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiVbRegisterRead 
+*	(
+*	VB_HREG_SET	*regCtl,	    /@ Registers read - OUT	    @/
+*	vbiVb_t	    targetBoard,	    /@ target VB		    @/ 
+*	vbiCore_t   core		    /@ core within the target VB    @/
+*	)
+*
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VB_HREG_SET;
+* 
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiVbRegisterWrite - write to a remote core's registers
+*
+* This routine makes a hypercall to write to a remote core's registers. The
+* register control structure contains the set of registers to write. 
+* The user must ensure to read first the destination core's registers using
+* vbiVbRegisterRead() then write back the modified set of registers in the 
+* registers control structure.
+* 
+* Target VB's core has to be suspended before writing the registers. If it
+* is still running, vbiVbRegisterWrite call will fail.
+* 
+*\cs
+* typedef struct
+*     {
+*     uint32_t gpr[GREG_NUM];	/@ general purpose registers @/
+*     uint32_t msr;		/@ machine state register @/
+*     uint32_t lr;		/@ link register @/
+*     uint32_t ctr;		/@ count register @/
+*     uint32_t pc;		/@ program counter @/
+*     uint32_t cr;		/@ condition register @/
+*     uint32_t xer;		/@ fixed-point exception register @/
+*     uint32_t spefscr;		/@ SPE floating-point status & ctrl reg @/
+*     uint32_t casid;		/@ PPC405, Book E PID and PPC860 M_CASID @/
+*     } VB_HREG_SET;
+* 
+*\ce 
+* VBI PPC Architecture Supplements
+*
+* SYNOPSIS
+*\cs
+* vbiStatus_t vbiVbRegisterWrite
+*	(
+*	VB_HREG_SET		*regCtl,	/@ registers to write - IN	 @/
+*	vbiVb_t			targetBoard,	/@ The target board		 @/
+*	vbiCore_t		core		/@ The target core within the VB @/
+*	)
+*\ce
+*
+* RETURNS: returns OK or error number in case of failure
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: 
+*/
+
+/*******************************************************************************
+*
+* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
+*
+* This routine changes the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* If the guest OS programmer wishes to move these address then this function 
+* must be called to inform hypervisor. This function must be called with 
+* interrupts disabled to prevent hypervisor to deliver interrupts to an 
+* incorrect exception offset. The table is not validated by the hypervisor so
+* it must be complete and functional otherwize the VB will not behave as 
+* expected.
+* For SMP systems it is recommended this API be called for each core as it is
+* started up and before it's added to the scheduler for the guest OS.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsSet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsGet
+*/
+
+/*******************************************************************************
+*
+* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
+*
+* This routine gets the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsGet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsSet
+*/
diff --git a/arch/powerpc/kernel/vbiPpcShow.c b/arch/powerpc/kernel/vbiPpcShow.c
new file mode 100644
index 0000000..db61a75
--- /dev/null
+++ b/arch/powerpc/kernel/vbiPpcShow.c
@@ -0,0 +1,102 @@
+/* vbiPpcShow.c - vbi PowerPC show routines */
+
+/*
+ * Copyright (c) 2008 Wind River Systems, Inc.
+ *
+ * The right to copy, distribute, modify or otherwise make use
+ * of this software may be licensed only pursuant to the terms
+ * of an applicable Wind River license agreement.
+ */
+
+/*
+modification history
+--------------------
+01d,15jun09,mmi  update vb regs
+01c,07feb09,mmi  fix build errors
+01b,22jan09,mmi  change vbCtrlRegsDisplay to vbiCrlRegsDisplay()
+01a,22jan09,mmi created
+*/
+
+/*
+This module provides the PowerPC show routines for the Virtual Board running
+on Wind River hypervisor.
+*/
+
+#ifdef CONFIG_WRHV
+#include <linux/kernel.h>
+#include <vbi/vbi.h>
+#define kprintf printk
+#else
+#include <vbi.h>
+#endif
+
+/*******************************************************************************
+*
+* vbiStsRegsDisplay - display registers from a EREG_SET
+*
+* This routine display the contents of the PowerPC emulated status registers
+* structure on the console.
+*
+*/
+
+void vbiStsRegsDisplay ()
+    {
+    VB_STATUS *p = VBI_STATUS_ADDR_GET();
+
+#if CPU == PPC85XX /* don't know how to handle cpu variant */
+    VB_PRINTF ("  srr0/srr1:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, srr0) ,
+		VB_STATUS_REGS_ACCESS (p, srr1));
+
+    VB_PRINTF ("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, mcsrr0) ,
+		VB_STATUS_REGS_ACCESS (p, mcsrr1));
+
+    VB_PRINTF ("  mcsr/mcar:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, mcsr) ,
+		VB_STATUS_REGS_ACCESS (p, mcar));
+
+    VB_PRINTF ("  dear/esr:           0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, dear) , 
+		VB_STATUS_REGS_ACCESS (p, esr));
+
+    VB_PRINTF ("  svr/pvr:            0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, svr) ,
+		VB_STATUS_REGS_ACCESS (p, pvr));
+
+    VB_PRINTF ("  hid0/hid1:          0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, hid0) ,
+		VB_STATUS_REGS_ACCESS (p, hid1));
+
+    VB_PRINTF ("  l1csr0/l1csr1:      0x%08x 0x%08x\n", 
+		VB_STATUS_REGS_ACCESS (p, l1csr0) ,
+		VB_STATUS_REGS_ACCESS (p, l1csr1));
+
+    VB_PRINTF ("  bucsr:              0x%08x\n",  
+		VB_STATUS_REGS_ACCESS (p, bucsr));
+#endif
+    }
+
+/*******************************************************************************
+*
+* vbiCtrlRegsDisplay - display registers from a EREG_SET
+*
+* This routine display the contents of the PowerPC emulated status registers
+* structure on the console.
+*
+*/
+
+void vbiCtrlRegsDisplay (void)
+    {
+    VB_CONTROL * p = VBI_CNTRL_ADDR_GET();
+
+#if CPU == PPC85XX /* don't know how to handler cpu variant */
+    VB_PRINTF ("  srr0/srr1:           0x%08x 0x%08x\n", 
+		VB_CONTROL_REGS_ACCESS (p, srr0),  
+		VB_CONTROL_REGS_ACCESS (p, srr1));
+
+    VB_PRINTF ("  cr/r0:               0x%08x 0x%08x\n", 
+		VB_CONTROL_REGS_ACCESS (p, cr), 
+		VB_CONTROL_REGS_ACCESS (p, r0));
+#endif
+    }
diff --git a/arch/powerpc/kernel/vbiSyscalls.S b/arch/powerpc/kernel/vbiSyscalls.S
index e984b47..a8fd6a7 100644
--- a/arch/powerpc/kernel/vbiSyscalls.S
+++ b/arch/powerpc/kernel/vbiSyscalls.S
@@ -11,6 +11,9 @@
 /*
 modification history
 --------------------
+02j,03sep09,dtr  Fixed vbExcBaseSet.Added vbiExcOffsetsSet/Get.
+02i,02sep09,mmi  rename vbiReceive to vbiReceiveOp
+02h,27aug09,mmi  fix defect WIND00178035
 02g,06jul09,mmi  update vb mangement syscall numbers, memory read/write,
 		 registers read/write, interrupt direct op, debug shell start
 02f,26jun09,mmi  add vbiIoapicOp
@@ -56,39 +59,16 @@ This file implements the hypervisor system call stubs for the hypervisor.
 */
 
 #define _ASMLANGUAGE
-#ifdef __KERNEL__
-#include <asm/processor.h>
-#include <asm/page.h>
-#include <asm/ppc_asm.h>
-#include <asm/cputable.h>
-#include <asm/asm-offsets.h>
-#include <asm/cache.h>
-#include <vbi/sys/vbiSyscall.h>
-
-#define FUNC_LABEL(func)       _GLOBAL(func)
-#define	FUNC_EXPORT(func)
-#define	FUNC_END(func)
-#define	_WRS_TEXT_SEG_START
-#define	HI(sym) sym@h
-#define	HIADJ(sym)      sym@ha
-#define	LO(sym) sym@l
-#else  /* __KERNEL__ */
-#include <wrhv.h>
-#include <sys/arch.h>
-#include <sys/regs.h>
-#include <sys/vbiSyscall.h>
-#endif
-
-#define p0	r3      /* argument register, volatile */
-#define p1	r4      /* argument register, volatile */
-#define p2	r5      /* argument register, volatile */
-#define p3	r6      /* argument register, volatile */
-#define p4	r7      /* argument register, volatile */
-#define p5	r8      /* argument register, volatile */
-#define p6	r9      /* argument register, volatile */
-#define p7	r10     /* argument register, volatile */
-#define	wrhvVbStatus	wrhvStatus
-#define wrhvVbControl	wrhvControl
+
+#ifdef CONFIG_WRHV
+#include <vbi/vbi.h>
+#include <vbi/support/asm.h>
+#else
+#include <vbi.h>
+#include <asm.h>
+#endif /* CONFIG_WRHV */
+
+#define HCALL sc
 
 	/* globals */
 
@@ -102,9 +82,8 @@ This file implements the hypervisor system call stubs for the hypervisor.
 	FUNC_EXPORT(vbiIoapicIoctl)
 	FUNC_EXPORT(vbiHyIoctl)
 	FUNC_EXPORT(vbiCtxctl)
-	FUNC_EXPORT(vbiBspIoctl)
 	FUNC_EXPORT(vbiSend)
-	FUNC_EXPORT(vbiReceive)
+	FUNC_EXPORT(vbiReceiveOp)
 	FUNC_EXPORT(vbiReply)
 	FUNC_EXPORT(vbiIcacheFlush)
 	FUNC_EXPORT(vbiDcacheFlush)
@@ -117,6 +96,8 @@ This file implements the hypervisor system call stubs for the hypervisor.
 	FUNC_EXPORT(vbiIntVCoreUnlock)
 	FUNC_EXPORT(vbiIntVCoreLock)
 	FUNC_EXPORT(vbiExcBaseSet)
+	FUNC_EXPORT(vbiExcOffsetsSet)
+	FUNC_EXPORT(vbiExcOffsetsGet)
 	FUNC_EXPORT(vbiMemAttrSet)
 	FUNC_EXPORT(vbiMemAttrGet)
 	FUNC_EXPORT(vbiVmmuConfig)
@@ -186,7 +167,7 @@ This file implements the hypervisor system call stubs for the hypervisor.
 FUNC_LABEL(vbiVbMgmt)
         lis     r0, HI(VBI_SYS_vbMgmt)
         ori     r0, r0, LO(VBI_SYS_vbMgmt)
-        sc
+        HCALL
         blr
 FUNC_END(vbiVbMgmt)
 
@@ -235,7 +216,7 @@ FUNC_LABEL(vbiVbSuspend)
 	
         lis     r0, HI(VBI_SYS_vbSuspend)
         ori     r0, r0, LO(VBI_SYS_vbSuspend)
-        sc
+        HCALL
         blr
 FUNC_END(vbiVbSuspend)
 
@@ -314,7 +295,7 @@ FUNC_LABEL(vbiVbReset)
 
         lis     r0, HI(VBI_SYS_vbReset)
         ori     r0, r0, LO(VBI_SYS_vbReset)
-        sc
+        HCALL
         blr
 FUNC_END(vbiVbReset)
 
@@ -363,7 +344,7 @@ FUNC_LABEL(vbiVbRestart)
 
         lis     r0, HI(VBI_SYS_vbRestart)
         ori     r0, r0, LO(VBI_SYS_vbRestart)
-        sc
+        HCALL
         blr
 FUNC_END(vbiVbRestart)
 
@@ -409,7 +390,7 @@ FUNC_LABEL(vbiVbResume)
 
         lis     r0, HI(VBI_SYS_vbResume)
         ori     r0, r0, LO(VBI_SYS_vbResume)
-        sc
+        HCALL
         blr
 FUNC_END(vbiVbResume)
 
@@ -457,13 +438,13 @@ FUNC_LABEL(vbiSend)
 
 	lis	r0, HI(VBI_SYS_send)
 	ori	r0, r0, LO(VBI_SYS_send)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiSend)
 
 /*******************************************************************************
 *
-* vbiReceive - Receive a message from another context
+* vbiReceiveOp - Receive a message from another context
 *
 * This routine makes a hypercall and waits for a message to be received from
 * another context. It blocks until a message is received.
@@ -471,7 +452,7 @@ FUNC_END(vbiSend)
 * SYNOPSIS
 *\cs
 *
-* vbiCtx_t vbiReceive
+* vbiCtx_t vbiReceiveOp
 *    (
 *    void *       smsg,  /@ pointer to message to receive  @/
 *    size_t       len,   /@ length of message to receive   @/
@@ -487,7 +468,7 @@ FUNC_END(vbiSend)
 * SEE ALSO: vbiSend(), vbiReply(), WRHV  messaging user's guide
 */
 
-FUNC_LABEL(vbiReceive)
+FUNC_LABEL(vbiReceiveOp)
 
 	/*
 	 * r3 - smsg pointer 
@@ -498,9 +479,9 @@ FUNC_LABEL(vbiReceive)
 
 	lis	r0, HI(VBI_SYS_receive)
 	ori	r0, r0, LO(VBI_SYS_receive)
-	sc
+	HCALL
 	blr
-FUNC_END(vbiReceive)
+FUNC_END(vbiReceiveOp)
 
 /*******************************************************************************
 *
@@ -533,7 +514,7 @@ FUNC_END(vbiReceive)
 FUNC_LABEL(vbiReply)
 	lis	r0, HI(VBI_SYS_reply)
 	ori	r0, r0, LO(VBI_SYS_reply)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiReply)
 
@@ -561,7 +542,7 @@ FUNC_END(vbiReply)
 FUNC_LABEL(vbiKputs)
 	lis	r0, HI(VBI_SYS_kputs)
 	ori	r0, r0, LO(VBI_SYS_kputs)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiKputs)
 
@@ -589,7 +570,7 @@ FUNC_END(vbiKputs)
 FUNC_LABEL(vbiKputc)
 	lis	r0, HI(VBI_SYS_kputc)
 	ori	r0, r0, LO(VBI_SYS_kputc)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiKputc)
 
@@ -622,7 +603,7 @@ FUNC_END(vbiKputc)
 FUNC_LABEL(vbiPanic)
 	lis	r0, HI(VBI_SYS_panic)
 	ori	r0, r0, LO(VBI_SYS_panic)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiPanic)
 
@@ -661,7 +642,7 @@ FUNC_LABEL(vbiDebugShellStart)
 
 	lis	r0, HI(VBI_SYS_dbgShStart)
 	ori	r0, r0, LO(VBI_SYS_dbgShStart)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiDebugShellStart)
 
@@ -695,7 +676,7 @@ FUNC_END(vbiDebugShellStart)
 FUNC_LABEL(vbiIcacheFlush)
 	lis	r0, HI(VBI_SYS_icache_flush)
 	ori	r0, r0, LO(VBI_SYS_icache_flush)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiIcacheFlush)
 
@@ -729,7 +710,7 @@ FUNC_END(vbiIcacheFlush)
 FUNC_LABEL(vbiDcacheFlush)
 	lis	r0, HI(VBI_SYS_dcache_flush)
 	ori	r0, r0, LO(VBI_SYS_dcache_flush)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiDcacheFlush)
 
@@ -751,7 +732,7 @@ FUNC_END(vbiDcacheFlush)
 FUNC_LABEL(vbiTlbFlush)
 	lis	r0, HI(VBI_SYS_tlb_flush)
 	ori	r0, r0, LO(VBI_SYS_tlb_flush)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiTlbFlush)
 
@@ -797,7 +778,7 @@ tryAgain:
 
 	lis	r0, HI(VBI_SYS_int_enable)
 	ori	r0, r0, LO(VBI_SYS_int_enable)
-	sc
+	HCALL
 	b	tryAgain
 0:
 	blr
@@ -907,20 +888,117 @@ FUNC_LABEL(vbiExcBaseSet)
 	 * align to 32 bytes  
 	 */	    
 
-	clrrwi  r3,r3, 5
-	
+	andi. r4, r3, 31
+	cmpwi r4, 0
+	bne- baseAlignError
+
 	/* set command for the ioctl */
 
-	li	r4, VBI_HYIOCTL_EXCBASE
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCBASE
 	
 	/* set the hypercall number */
 
 	lis	r0, HI(VBI_SYS_hyIoctl)
 	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	sc
+	HCALL
 	blr
+baseAlignError:
+	li r3, VBI_EXCBASE_SET_ERROR
+	blr	
+
 FUNC_END(vbiExcBaseSet)
+
+/*******************************************************************************
+*
+* vbiExcOffsetsSet - Set the exceptions vector offsetcs for a virtual core
+*
+* This routine changes the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsGet will provide the offsets being used for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* If the guest OS programmer wishes to move these address then this function 
+* must be called to inform hypervisor. This function must be called with 
+* interrupts disabled to prevent hypervisor to deliver interrupts to an 
+* incorrect exception offset. The table is not validated by the hypervisor so
+* it must be complete and functional otherwize the VB will not behave as 
+* expected.
+* For SMP systems it is recommended this API be called for each core as it is
+* started up and before it's added to the scheduler for the guest OS.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsSet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsGet
+*/
+
+FUNC_LABEL(vbiExcOffsetsSet)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_SET
 	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbiExcOffsetsSet)
+
+/*******************************************************************************
+*
+* vbiExcOffsetsGet - Get the exceptions vector offsetcs for a virtual core
+*
+* This routine gets the exceptions vector table offset addresses for the 
+* active virtual core. By default they follow the standard PPC exception 
+* offsets. vbiExcOffsetsSet will enable the offsets to be changed for the 
+* virtual board. The offset table uses an index based on IVOR number.
+* 
+* SYNOPSIS
+*\cs
+* 
+* VBI PPC Architecture Supplements
+*
+* vbiStatus_t vbiExcOffsetsGet 
+*	    (
+*	    VBI_EXC_OFFSETS_TABLE * excOffsetsTable /@ New exception offsets table to register @/
+*	    )
+*
+*\ce
+*
+* RETURNS: OK or error number if operation fails to complete 
+*
+* ERROR CODES: N/A
+*
+* SEE ALSO: vbiExcOffsetsSet
+*/
+
+FUNC_LABEL(vbiExcOffsetsGet)
+	/* set command for the ioctl */
+	mr      r4, r3
+	li	r3, VBI_HYIOCTL_EXCOFFSETS_GET
+	
+	/* set the hypercall number */
+
+	lis	r0, HI(VBI_SYS_hyIoctl)
+	ori	r0, r0, LO(VBI_SYS_hyIoctl)
+	HCALL
+	blr
+FUNC_END(vbiExcOffsetsGet)
+
 /*******************************************************************************
 *
 * vbiCacheTextUpdate - flush data cache then invalidate instruction cache
@@ -951,7 +1029,7 @@ FUNC_END(vbiExcBaseSet)
 FUNC_LABEL(vbiCacheTextUpdate)
 	lis	r0, HI(VBI_SYS_cache_text_update)
 	ori	r0, r0, LO(VBI_SYS_cache_text_update)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiCacheTextUpdate)
 
@@ -972,7 +1050,7 @@ FUNC_END(vbiCacheTextUpdate)
 FUNC_LABEL(vbiVmmuConfig)
 	lis	r0, HI(VBI_SYS_vmmu_config)
 	ori	r0, r0, LO(VBI_SYS_vmmu_config)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVmmuConfig)
 
@@ -994,7 +1072,7 @@ FUNC_END(vbiVmmuConfig)
 FUNC_LABEL(vbiVmmuEnable)
 	lis	r0, HI(VBI_SYS_vmmu_enable)
 	ori	r0, r0, LO(VBI_SYS_vmmu_enable)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVmmuEnable)
 
@@ -1016,7 +1094,7 @@ FUNC_END(vbiVmmuEnable)
 FUNC_LABEL(vbiVmmuDisable)
 	lis	r0, HI(VBI_SYS_vmmu_disable)
 	ori	r0, r0, LO(VBI_SYS_vmmu_disable)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVmmuDisable)
 
@@ -1041,7 +1119,7 @@ FUNC_END(vbiVmmuDisable)
 FUNC_LABEL(vbiVmmuTlbLoad)
 	lis	r0, HI(VBI_SYS_vmmu_tlbload)
 	ori	r0, r0, LO(VBI_SYS_vmmu_tlbload)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVmmuTlbLoad)
 
@@ -1066,7 +1144,7 @@ FUNC_END(vbiVmmuTlbLoad)
 FUNC_LABEL(vbiVmmuTlbFlush)
 	lis	r0, HI(VBI_SYS_vmmu_tlbflush)
 	ori	r0, r0, LO(VBI_SYS_vmmu_tlbflush)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVmmuTlbFlush)
 
@@ -1097,7 +1175,7 @@ FUNC_END(vbiVmmuTlbFlush)
 FUNC_LABEL(vbiHyIoctl)
 	lis	r0, HI(VBI_SYS_hyIoctl)
 	ori	r0, r0, LO(VBI_SYS_hyIoctl)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiHyIoctl)
 
@@ -1123,7 +1201,7 @@ FUNC_END(vbiHyIoctl)
 FUNC_LABEL(vbiCtxctl)
 	lis	r0, HI(VBI_SYS_ctxctl)
 	ori	r0, r0, LO(VBI_SYS_ctxctl)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiCtxctl)
 
@@ -1158,7 +1236,7 @@ FUNC_END(vbiCtxctl)
 FUNC_LABEL(vbiMemAttrSet)
 	lis	r0, HI(VBI_SYS_mmu_attr_set)
 	ori	r0, r0, LO(VBI_SYS_mmu_attr_set)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiMemAttrSet)
 
@@ -1190,45 +1268,10 @@ FUNC_END(vbiMemAttrSet)
 FUNC_LABEL(vbiMemAttrGet)
 	lis	r0, HI(VBI_SYS_mmu_attr_get)
 	ori	r0, r0, LO(VBI_SYS_mmu_attr_get)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiMemAttrGet)
 
-
-/******************************************************************************
-*
-* vbiBspIoctl - bsp ioctl call
-*
-* This system call interfaces to the Board Support Package
-* I/O drivers etc
-*
-* Knwon BSP ioctl commands:
-*	VBI_BSPIOCTL_ENABLE_INT   /@ Enable HW interrupt @/
-*	VBI_BSPIOCTL_DISABLE_INT  /@ Disable HW interrupt@/
-*	VBI_BSPIOCTL_RESET	  /@ Reset HW device     @/
-*				
-* C interface:
-*
-*   vbiBspIoctl (unsigned int ioctl, /@ the BSP ioctl command  @/
-*                unsigned int arg1   /@ arguments to the ioctl @/
-*                unsigned int arg2
-*                unsigned int arg3
-*                unsigned int arg4
-*                unsigned int arg5
-*                unsigned int arg6
-*                unsigned int arg7)
-*
-* Returns: ioctl specific value
-*
-*/
-
-FUNC_LABEL(vbiBspIoctl)
-	lis	r0, HI(VBI_SYS_bspIoctl)
-	ori	r0, r0, LO(VBI_SYS_bspIoctl)
-	sc
-	blr
-FUNC_END(vbiBspIoctl)
-
 /******************************************************************************
 *
 * vbiIoapicIoctl - virtual IO APIC ioctl call
@@ -1254,7 +1297,7 @@ FUNC_END(vbiBspIoctl)
 FUNC_LABEL(vbiIoapicIoctl)
 	lis   r0, HI(VBI_SYS_vIoapicIoctl)
 	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiIoapicIoctl)
 
@@ -1284,7 +1327,7 @@ FUNC_END(vbiIoapicIoctl)
 FUNC_LABEL(vbiNsOp)
 	lis   r0, HI(VBI_SYS_ns_op)
 	ori	r0, r0, LO(VBI_SYS_ns_op)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiNsOp)
 
@@ -1332,7 +1375,7 @@ FUNC_END(vbiNsOp)
 FUNC_LABEL(vbiVbMemoryRead)
 	lis   r0, HI(VBI_SYS_memRead_op)
 	ori	r0, r0, LO(VBI_SYS_memRead_op)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVbMemoryRead)
 
@@ -1386,7 +1429,7 @@ FUNC_END(vbiVbMemoryRead)
 FUNC_LABEL(vbiVbMemoryWrite)
 	lis	r0, HI(VBI_SYS_memWrite_op)
 	ori	r0, r0, LO(VBI_SYS_memWrite_op)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVbMemoryWrite)
 
@@ -1416,7 +1459,7 @@ FUNC_END(vbiVbMemoryWrite)
 FUNC_LABEL(vbiIoapicOp)
 	lis   r0, HI(VBI_SYS_vIoapicIoctl)
 	ori	r0, r0, LO(VBI_SYS_vIoapicIoctl)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiIoapicOp)
 
@@ -1503,7 +1546,7 @@ FUNC_END(vbiIoapicOp)
 FUNC_LABEL(vbiVbRegisterRead)
 	lis   r0, HI(VBI_SYS_RegsRead_op)
 	ori	r0, r0, LO(VBI_SYS_RegsRead_op)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVbRegisterRead)
 
@@ -1592,7 +1635,7 @@ FUNC_END(vbiVbRegisterRead)
 FUNC_LABEL(vbiVbRegisterWrite)
 	lis   r0, HI(VBI_SYS_RegsWrite_op)
 	ori	r0, r0, LO(VBI_SYS_RegsWrite_op)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVbRegisterWrite)
 
@@ -1621,6 +1664,6 @@ FUNC_END(vbiVbRegisterWrite)
 FUNC_LABEL(vbiVcoreIntRed_op)
 	lis   r0, HI(VBI_SYS_intRedirect)
 	ori	r0, r0, LO(VBI_SYS_intRedirect)
-	sc
+	HCALL
 	blr
 FUNC_END(vbiVcoreIntRed_op)
diff --git a/arch/powerpc/kernel/vbiUtil.c b/arch/powerpc/kernel/vbiUtil.c
index 1e9acda..7e560ba 100644
--- a/arch/powerpc/kernel/vbiUtil.c
+++ b/arch/powerpc/kernel/vbiUtil.c
@@ -24,8 +24,8 @@ para-virtualize linux, therefore, may need some tweaks to be generic.
 #include <asm/page.h>
 #include <linux/module.h>
 #include <vbi/vbInterface.h>
-#include <vbi/sys/vmmu.h>
-#include <vbi/sys/vbiSyscall.h>
+#include <vbi/support/sys/vmmu.h>
+#include <vbi/vbiSyscall.h>
 
 
 /* defines */
@@ -107,7 +107,7 @@ int vb_context_mmu_on(int pid,	/* context id */
 		return -1;
 
 	if (debug) {
-		printk("L1 page table address %#X\n", pgtable);
+		printk("L1 page table address %p\n", pgtable);
 		vmmuPageTableDisplay(pgtable, 0);
 		printk("End of page table display \n");
 	}
diff --git a/arch/powerpc/kernel/vmmuDisplay.c b/arch/powerpc/kernel/vmmuDisplay.c
index 2186513..a3f218c 100644
--- a/arch/powerpc/kernel/vmmuDisplay.c
+++ b/arch/powerpc/kernel/vmmuDisplay.c
@@ -19,9 +19,9 @@ modification history
 This module displays the contents of a VMMU page table
 */
 
-#include <vbi/vbInterface.h>
-#include <vbi/sys/vmmu.h>
 #include <linux/kernel.h>
+#include <vbi/vbInterface.h>
+#include <vbi/support/sys/vmmu.h>
 
 #define __va(paddr) (((unsigned long )(paddr))+0xC0000000)
 #define __pa(vaddr) (((unsigned long )(vaddr))-0xC0000000)
diff --git a/arch/powerpc/kernel/wrhv.c b/arch/powerpc/kernel/wrhv.c
index b4fc87b..704dec6 100644
--- a/arch/powerpc/kernel/wrhv.c
+++ b/arch/powerpc/kernel/wrhv.c
@@ -126,6 +126,10 @@ void mpc85xx_power_down(void);
 
 extern int map_page(unsigned long, phys_addr_t, int);
 
+extern int vb_context_mmu_on(int pid,  /* context id */
+			void *pgtable,    /* level 1 page table */
+			int pagesize, int debug);
+
 unsigned long wrhv_cpu_freq = 0;
 
 void wrhv_mapping(void)
@@ -195,7 +199,7 @@ void __init wrhv_calibrate_decr(void)
 {
 	/* The timebase is updated every 8 bus clocks */
 	ppc_tb_freq = wrhv_cpu_freq / 8;
-	printk(KERN_DEBUG "WRHV-TIME: wrhv_cpu_freq=%u  ppc_tb_freq =%u\r \n",
+	printk(KERN_DEBUG "WRHV-TIME: wrhv_cpu_freq=%lu  ppc_tb_freq =%lu\n",
 			wrhv_cpu_freq, ppc_tb_freq);
 	
 }
@@ -241,9 +245,9 @@ static int __init wrhv_late_init_irq(void)
 subsys_initcall(wrhv_late_init_irq);
 #endif
 
-int wrhv_vioapic_get_irq(void)
+unsigned int wrhv_vioapic_get_irq(void)
 {
-	int irq;
+	unsigned int irq;
 
 	irq = wrhvControl->intPending;
 
@@ -402,8 +406,6 @@ static struct clock_event_device wrhv_clockevent = {
 void wrhv_hw_timer_interrupt(struct pt_regs * regs)
 {
         struct pt_regs *old_regs;
-        struct clock_event_device *evt = &wrhv_clockevent;
-        u64 now;
 
         if (atomic_read(&ppc_n_lost_interrupts) != 0)
                 do_IRQ(regs);
diff --git a/arch/powerpc/kernel/wrhv_entry_32.S b/arch/powerpc/kernel/wrhv_entry_32.S
index ba29593..b3c8030 100644
--- a/arch/powerpc/kernel/wrhv_entry_32.S
+++ b/arch/powerpc/kernel/wrhv_entry_32.S
@@ -37,6 +37,7 @@
 #ifdef CONFIG_WRHV
 #include <vbi/vbInterface.h>
 #include <asm/vbiPpcArch.h>
+#include <vbi/syscalls.h>
 #endif /* CONFIG_WRHV */
 
 #undef SHOW_SYSCALLS
diff --git a/arch/powerpc/kernel/wrhv_misc_32.S b/arch/powerpc/kernel/wrhv_misc_32.S
index c32908d..62b6486 100644
--- a/arch/powerpc/kernel/wrhv_misc_32.S
+++ b/arch/powerpc/kernel/wrhv_misc_32.S
@@ -30,6 +30,7 @@
 #include <asm/processor.h>
 #include <asm/kexec.h>
 #include <vbi/vbInterface.h>
+#include <vbi/syscalls.h>
 
 	.text
 
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index 81f4fc5..f84e1f3 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -63,6 +63,38 @@ static int mpc85xx_exclude_device(struct pci_controller *hose,
 }
 #endif /* CONFIG_PCI */
 
+#ifdef CONFIG_WRHV
+static int get_bsp_clock_freq(void)
+{
+	VBI_BSP_MSG		clk_msg;
+	VBI_BSP_MSG_REPLY	clk_reply;
+	VBI_NS_HANDLE		serviceHandle;
+	int32_t			rc;
+
+	rc = vbiNsLookup ("bspServer", 0, &serviceHandle);
+
+	if (rc != OK) {
+		printk ("bspServer lookup returned error code: %d\n", rc);
+		return 0;
+	}
+
+	clk_msg.request = VBI_BSP_CLK_FREQ; /* read or write */
+
+	rc = vbiSend (serviceHandle, &clk_msg,
+		sizeof(clk_msg), &clk_reply, sizeof(clk_reply), NULL, NULL);
+
+	if (rc != OK) {
+		printk("vbiSend to the bspServer returned error code: %d\n",
+			rc);
+		return 0;
+	}
+
+	printk("bspServer replied clock freq value 0x%x\n",
+		 clk_reply.dataVal);
+	return clk_reply.dataVal;
+}
+#endif /* CONFIG_WRHV */
+
 /*
  * Setup the architecture
  */
@@ -76,8 +108,7 @@ static void __init wrhv_8572ds_setup_arch(void)
 		ppc_md.progress("wrhv_8572ds_setup_arch()", 0);
 
 #ifdef CONFIG_WRHV
-#define VBI_BSPIOCTL_SYS_CLK   2
-	wrhv_cpu_freq = vbiBspIoctl(VBI_BSPIOCTL_SYS_CLK,0,0,0,0,0,0,0);
+	wrhv_cpu_freq = get_bsp_clock_freq();
 #endif
 
 #ifdef CONFIG_PCI
@@ -107,6 +138,10 @@ static void wrhv_8572ds_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
 }
 
+extern VB_CONFIG	*wrhvConfig;
+extern VB_STATUS	*wrhvStatus;
+extern VB_CONTROL	*wrhvControl;
+
 /*
  * Called very early, device-tree isn't unflattened
  */
@@ -118,7 +153,8 @@ static int __init wrhv_8572ds_probe(void)
 	wrhvControl = wrhvConfig->vbControl;
 	wrhvStatus = wrhvConfig->vbStatus;
 
-	wrhv_mapping(); /* Map VB_CONFOG structure */
+	wrhv_mapping(); /* Map VB_CONFIG structure */
+	vbiInit(wrhvConfig);
 
 	strncpy(cmd_line, wrhvConfig->bootLine, VB_MAX_BOOTLINE_LENGTH - 1);
 	cmd_line[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
diff --git a/include/vbi/ppc/vbiPpcArch.h b/include/vbi/ppc/vbiPpcArch.h
index f0f0ef2..e3c7800 100644
--- a/include/vbi/ppc/vbiPpcArch.h
+++ b/include/vbi/ppc/vbiPpcArch.h
@@ -580,6 +580,10 @@ typedef struct
     uint32_t excOffset[VBI_ARCH_MAX_EXC_OFFSETS];
     } VBI_EXC_OFFSETS_TABLE;
 
+#ifdef CONFIG_WRHV
+typedef int32_t  status_t;      /* operation/function status */
+#endif /* CONFIG_WRHV */
+
 extern status_t vbiExcOffsetsSet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
 extern status_t vbiExcOffsetsGet(VBI_EXC_OFFSETS_TABLE *excOffsetsTable);
 
diff --git a/include/vbi/support/asm.h b/include/vbi/support/asm.h
index 577b31c..287046f 100644
--- a/include/vbi/support/asm.h
+++ b/include/vbi/support/asm.h
@@ -14,14 +14,22 @@ modification history
 #ifndef __INCasmh
 #define __INCasmh
 
+#ifdef CONFIG_WRHV
+#include "sys/cpu_types.h"
+#else
 #include <sys/cpu_types.h>
+#endif /* CONFIG_WRHV */
 
 /* include the appropriate arch specific header file */
 
 #if (CPU == MIPSI64R2)
 # include <sys/mips64/asm.h>
 #elif (CPU == PPC85XX)
+#ifdef CONFIG_WRHV
+# include "sys/ppc/asm.h"
+#else
 # include <sys/ppc/asm.h>
+#endif /* CONFIG_WRHV */
 #elif (CPU == PPCE500MC)
 # include <sys/ppc/asm.h>
 #elif (CPU == PENTIUM)
diff --git a/include/vbi/support/sys/vmmu.h b/include/vbi/support/sys/vmmu.h
index ec24eb8..6ecd491 100644
--- a/include/vbi/support/sys/vmmu.h
+++ b/include/vbi/support/sys/vmmu.h
@@ -19,8 +19,6 @@ modification history
 extern "C" {
 #endif /* __cplusplus */
 
-#include <wrhv.h>
-
 /*
 
 The vmmu virtual address space is restricted to 32 bits and is decoded using
diff --git a/include/vbi/vbiArch.h b/include/vbi/vbiArch.h
index 64e9ef2..d79e4ea 100644
--- a/include/vbi/vbiArch.h
+++ b/include/vbi/vbiArch.h
@@ -28,7 +28,11 @@ modification history
 #if (CPU == MIPSI64R2)
 # include <mips64/vbiMips64Arch.h>
 #elif (CPU == PPC85XX) || (CPU == PPC32) || (CPU == PPCE500MC)
+#ifdef CONFIG_WRHV
+#include <vbi/ppc/vbiPpcArch.h>
+#else
 # include <ppc/vbiPpcArch.h>
+#endif /* CONFIG_WRHV */
 #elif (CPU == PENTIUM) || (CPU == PENTIUM4)
 #ifdef CONFIG_WRHV
 # include "x86/vbiX86Arch.h"
diff --git a/include/vbi/vbiTypes.h b/include/vbi/vbiTypes.h
index 08c6c71..e814212 100644
--- a/include/vbi/vbiTypes.h
+++ b/include/vbi/vbiTypes.h
@@ -27,6 +27,12 @@ modification history
 #define CPU PENTIUM
 #define PPC32 -1
 #endif /* CONFIG_X86 */
+#ifdef CONFIG_PPC
+#define CPU PPC85XX   /* Currently all PPC treated the same in vbi */
+#ifdef __ASSEMBLY__
+#define _ASMLANGUAGE
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_PPC */
 #include "support/sys/cpu_types.h"
 #else
 #include <ctype.h>
diff --git a/kernel/vbiShow.c b/kernel/vbiShow.c
index 9745ef8..c0a7111 100644
--- a/kernel/vbiShow.c
+++ b/kernel/vbiShow.c
@@ -217,7 +217,7 @@ void vbiStatusShow
     VB_PRINTF ("  timestamp:          %lld\n", p->timeStamp);
     VB_PRINTF ("  old int disable:    0x%08x\n", p->oldIntDisable);
 #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiStsRegsDisplay (p);
+    vbiStsRegsDisplay ();
 #endif
     }
 
@@ -255,7 +255,7 @@ void vbiControlShow
     VB_PRINTF ("  Disable interrupts:  0x%08x\n", p->intDisable);
 
 #ifdef _WRHV_ARCH_HAS_STATUS_REGS   
-    vbiCtrlRegsDisplay (p); 
+    vbiCtrlRegsDisplay (); 
 #endif
 
     VB_PRINTF ("  Disabled interrupts:");
-- 
1.6.5.rc3

