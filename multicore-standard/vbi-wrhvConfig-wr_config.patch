From b4c5d11129168c73aff9775fa64d71e1f490323b Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 2 Dec 2009 19:44:11 -0500
Subject: [PATCH 27/43] vbi: wrhvConfig --> wr_config

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/kernel/vbi/util.c            |   12 ++++----
 arch/powerpc/kernel/vbi/wrhv.c            |   42 ++++++++++++++--------------
 arch/powerpc/platforms/85xx/wrhv_8572ds.c |    6 ++--
 arch/x86/kernel/head_32.S                 |    6 ++--
 arch/x86/kernel/vbi/wrhv.c                |   18 ++++++------
 include/vbi/compat.h                      |    1 +
 kernel/vbi/lib.c                          |    2 +-
 7 files changed, 44 insertions(+), 43 deletions(-)

diff --git a/arch/powerpc/kernel/vbi/util.c b/arch/powerpc/kernel/vbi/util.c
index 16e2437..bdc41a0 100644
--- a/arch/powerpc/kernel/vbi/util.c
+++ b/arch/powerpc/kernel/vbi/util.c
@@ -33,11 +33,11 @@ para-virtualize linux, therefore, may need some tweaks to be generic.
 /* globals */
 
 /*
- * wrhvConfig is initialized as part of the guest os init, before os turns on
+ * wr_config is initialized as part of the guest os init, before os turns on
  * MMU. For paravirualized linux, it is initialized in plaform_init().
  */
 
-extern struct vb_config *wrhvConfig;
+extern struct vb_config *wr_config;
 extern struct vb_status *wrhvStatus;
 extern struct vb_control *wr_control;
 
@@ -50,18 +50,18 @@ extern void vmmuPageTableDisplay(VMMU_LEVEL_1_DESC *l1, int vmmuon);
 /* forward declarations */
 
 /*
- * vb_memsize_get should not be called before wrhvConfig is initialized
+ * vb_memsize_get should not be called before wr_config is initialized
  */
 unsigned int vb_memsize_get(void)
 {
-	if (wrhvConfig == (struct vb_config *)(-1)) 
+	if (wr_config == (struct vb_config *)(-1)) 
 		return 0;
 	return VBI_MEM_SIZE_GET();
 }
 
 unsigned int vb_context_get(void)
 {
-	if (wrhvConfig == (struct vb_config *)(-1))
+	if (wr_config == (struct vb_config *)(-1))
 		return 0xdeadbee0;
 	return VBI_CONTEXT_ID_GET();
 }
@@ -93,7 +93,7 @@ int vb_context_mmu_on(int pid,	/* context id */
 {
 	static VMMU_CONFIG vmmu_cfg;
 
-	if (wrhvConfig == (struct vb_config *)(- 1) || pgtable == NULL || pagesize <= 0)
+	if (wr_config == (struct vb_config *)(- 1) || pgtable == NULL || pagesize <= 0)
 		return -1;
 
 	vmmu_cfg.addr = (VMMU_LEVEL_1_DESC *) pgtable;
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index c723798..9b0b406 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -115,11 +115,11 @@
 #include <linux/clocksource.h>
 #include <linux/hwtimer.h>
 
-static struct vb_config __wrhvConfig;
-struct vb_config *wrhvConfig;		/* TODO kernel relocation friendly ? */
+static struct vb_config __wr_config;
+struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
 struct vb_control *wr_control;
 struct vb_status *wrhvStatus;
-EXPORT_SYMBOL(wrhvConfig);
+EXPORT_SYMBOL(wr_config);
 
 void wrhv_mapping(void);
 void mpc85xx_power_down(void);
@@ -179,25 +179,25 @@ void wrhv_mapping(void)
 	 * For now, we just use 1 page which is fine for the time being.
 	 */
 
-	map_page((unsigned long)wrhvConfig, (unsigned long)wrhvConfig,
+	map_page((unsigned long)wr_config, (unsigned long)wr_config,
 		 _PAGE_RAM);
 
-	map_page((unsigned long)wrhvConfig->vbStatus,
-		 (unsigned long)wrhvConfig->vbStatus, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->vbControl,
-		 (unsigned long)wrhvConfig->vbControl, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->interruptConfiguration,
-		 (unsigned long)wrhvConfig->interruptConfiguration, _PAGE_RAM);
-	map_page((unsigned long)wrhvConfig->vbControl->vIoapic,
-		 (unsigned long)wrhvConfig->vbControl->vIoapic, _PAGE_RAM);
+	map_page((unsigned long)wr_config->vbStatus,
+		 (unsigned long)wr_config->vbStatus, _PAGE_RAM);
+	map_page((unsigned long)wr_config->vbControl,
+		 (unsigned long)wr_config->vbControl, _PAGE_RAM);
+	map_page((unsigned long)wr_config->interruptConfiguration,
+		 (unsigned long)wr_config->interruptConfiguration, _PAGE_RAM);
+	map_page((unsigned long)wr_config->vbControl->vIoapic,
+		 (unsigned long)wr_config->vbControl->vIoapic, _PAGE_RAM);
 
-	memcpy(&__wrhvConfig, wrhvConfig, sizeof(__wrhvConfig));
+	memcpy(&__wr_config, wr_config, sizeof(__wr_config));
 	/* map any shared memory region info */
 
-	if (wrhvConfig->sharedMemoryRegionsConfigAddress != 0)
-		map_page((unsigned long)wrhvConfig->
+	if (wr_config->sharedMemoryRegionsConfigAddress != 0)
+		map_page((unsigned long)wr_config->
 			 sharedMemoryRegionsConfigAddress,
-			 (unsigned long)wrhvConfig->
+			 (unsigned long)wr_config->
 			 sharedMemoryRegionsConfigAddress, _PAGE_RAM);
 	/* MIPC */
 	map_page(0xfd000000, 0xfd000000, _PAGE_IO);
@@ -208,7 +208,7 @@ void wrhv_mapping(void)
 
 unsigned long __init wrhv_find_end_of_memory(void)
 {
-	return wrhvConfig->phys_mem_size;
+	return wr_config->phys_mem_size;
 }
 
 int wrhv_early_init_dt_scan_memory(unsigned long node,
@@ -961,13 +961,13 @@ int wrhv_ppc_cpu_freq(void)
 
 void wrhv_init(void)
 {
-	/* initialize wrhvConfig so that we can access
+	/* initialize wr_config so that we can access
 	 * vbi configuration. The vbi configuration space
 	 * is defined in Hypervisor linux.xml
 	 */
-	wrhvConfig = (struct vb_config *)0xF0000000;
-	wr_control = wrhvConfig->vbControl;
-	wrhvStatus = wrhvConfig->vbStatus;
+	wr_config = (struct vb_config *)0xF0000000;
+	wr_control = wr_config->vbControl;
+	wrhvStatus = wr_config->vbStatus;
 
 	pv_info.name = "wrhv";
 	pv_info.paravirt_enabled = 1;
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index f061895..b59f455 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -36,7 +36,7 @@
 #include <asm/udbg.h>
 #include <asm/wrhv.h>
 
-extern struct vb_config *wrhvConfig;
+extern struct vb_config *wr_config;
 extern struct vb_status *wrhvStatus;
 extern struct vb_control *wr_control;
 
@@ -145,11 +145,11 @@ static int __init wrhv_8572ds_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
 
-	/* wrhvConfig should have been initialized in wrhv_init(),
+	/* wr_config should have been initialized in wrhv_init(),
 	 * continue to complete the vbi initialization here.
 	 */
 	wrhv_mapping(); /* Map vb_config structure */
-	vbi_init(wrhvConfig);
+	vbi_init(wr_config);
 
 	strncpy(cmd_line, VBI_BOOTLINE_ADDR_GET(), VB_MAX_BOOTLINE_LENGTH - 1);
 	cmd_line[VB_MAX_BOOTLINE_LENGTH - 1] = 0;
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index e66c361..a1e7d70 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -177,15 +177,15 @@ num_subarch_entries = (. - subarch_entries) / 4
 	/* Copy over the wrhv config, it's assumed the stack hasn't been fiddled with yet */
 	movl 0x4(%esp), %esi
 	/* Store the address of wrhv config so we can map it in later */
-	movl %esi, pa(_wrhvConfig)
-	movl $pa(__wrhvConfig), %edi
+	movl %esi, pa(_wr_config)
+	movl $pa(__wr_config), %edi
 	movl $(WRHV_VB_CONFIG_SIZE/4),%ecx
 	cld
 	rep
 	movsl
 
 	/* Fill in the boot command line */
-	movl $pa(__wrhvConfig + WRHV_BOOTLINE_OFFSET), %esi
+	movl $pa(__wr_config + WRHV_BOOTLINE_OFFSET), %esi
 	movl $pa(boot_command_line),%edi
 	movl $(VB_MAX_BOOTLINE_LENGTH/4),%ecx
 	rep
diff --git a/arch/x86/kernel/vbi/wrhv.c b/arch/x86/kernel/vbi/wrhv.c
index 68e036e..f7a20c8 100644
--- a/arch/x86/kernel/vbi/wrhv.c
+++ b/arch/x86/kernel/vbi/wrhv.c
@@ -38,9 +38,9 @@
 #define WRHV_POLL_IRQ		7
 
 /* Copied over during early bootstrap */
-struct vb_config __wrhvConfig = { .pid = -1 };
-struct vb_config *_wrhvConfig; /* Pointer passed from hypervisor */
-struct vb_config *wrhvConfig = &__wrhvConfig;
+struct vb_config __wr_config = { .pid = -1 };
+struct vb_config *_wr_config; /* Pointer passed from hypervisor */
+struct vb_config *wr_config = &__wr_config;
 struct vb_status *wrhvStatus;
 struct vb_control *wr_control;
 
@@ -110,14 +110,14 @@ void __init wrhv_init_IRQ(void)
 	   
 	for (i=0; i<(FIX_WRHV_END - FIX_WRHV_START); i++) {
 		__set_fixmap(FIX_WRHV_END - i,
-			 (unsigned long)_wrhvConfig+(i*PAGE_SIZE), PAGE_KERNEL);
+			 (unsigned long)_wr_config+(i*PAGE_SIZE), PAGE_KERNEL);
 	}
 
 	/* We no longer need to use the vbconfig copy, map it straight in */
-	wrhvConfig = (struct vb_config *)fix_to_virt(FIX_WRHV_END);
+	wr_config = (struct vb_config *)fix_to_virt(FIX_WRHV_END);
 		
 	/* Setup the global variables used by the vbi */
-	vbi_init(wrhvConfig);
+	vbi_init(wr_config);
 
 	wrhv_pre_intr_init_hook();
 
@@ -400,7 +400,7 @@ void wrhv_boot_config(void)
 	   actual hypervisor config/status/control space yet */
         snprintf(boot_command_line, COMMAND_LINE_SIZE,
 		"retain_initrd pci=conf1 idle=wrhv mem=nopentium serialnumber nolapic nomce nosep memmap=exactmap memmap=%dK@0 %s",
-		wrhvConfig->phys_mem_size / 1024, wrhvConfig->bootLine);
+		wr_config->phys_mem_size / 1024, wr_config->bootLine);
 #endif
 }
 
@@ -784,8 +784,8 @@ void __init wrhv_calibrate_smp_cpus(void)
 {
 	/* Use the config space copy here, since we haven't mapped in the
 	   actual hypervisor config/status/control space yet */
-	int cpus = wrhvConfig->numCores;
-	int cpuid = wrhvConfig->coreId;
+	int cpus = wr_config->numCores;
+	int cpuid = wr_config->coreId;
 	if (cpuid != 0)
 		return;
 	printk(KERN_INFO "WRHV: calibrate CPU information according to vbConfig \n");
diff --git a/include/vbi/compat.h b/include/vbi/compat.h
index e9dff53..cfe4ced 100644
--- a/include/vbi/compat.h
+++ b/include/vbi/compat.h
@@ -66,6 +66,7 @@
  */
 #define vbControlRegs		vb_control_regs
 #define wrhvControl		wr_control
+#define wrhvConfig		wr_config
 #define wrhvVbStatus		wr_vb_status
 #define wrhvVbControl		wr_vb_control
 #define wrhvVbConfig		wr_vb_config
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index 701112b..16e1b69 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -81,7 +81,7 @@ A virtual board core is presented by hypervisor with 3 memory areas:
 
 This write protected memory area provides fixed configuration information to
 the virtual board.  The address of this is kept in the global variable
-wrhvConfig.  The address of this area is passed to the virtual board as the
+wr_config.  The address of this area is passed to the virtual board as the
 first parameter when the virtual board is started running at it's boot location.
 
 2) Virtual Board Status Area
-- 
1.6.5.2

