From 1cab25fcefaf120fca1ad1155b841a94d5bade51 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:14:05 -0400
Subject: [PATCH 15/24] x86: core x86 changes for hypervisor/guest

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
---
 arch/x86/Kconfig                       |    1 +
 arch/x86/kernel/Makefile               |    9 ++++++++
 arch/x86/kernel/alternative.c          |    3 ++
 arch/x86/kernel/asm-offsets_32.c       |    9 ++++++++
 arch/x86/kernel/cpu/intel.c            |    8 +++++++
 arch/x86/kernel/cpu/mcheck/non-fatal.c |    3 ++
 arch/x86/kernel/e820.c                 |    5 ++++
 arch/x86/kernel/head_32.S              |   36 ++++++++++++++++++++++++++++++++
 arch/x86/kernel/i8237.c                |    8 ++++++-
 arch/x86/kernel/i8253.c                |    3 ++
 arch/x86/kernel/i8259.c                |    8 ++++++-
 arch/x86/kernel/microcode.c            |    4 +++
 arch/x86/kernel/pci-dma.c              |   19 ++++++++++++++++
 arch/x86/kernel/pci-nommu.c            |   18 ++++++++++++++++
 arch/x86/kernel/process.c              |   19 ++++++++++++++++
 arch/x86/kernel/ptrace.c               |    6 +++++
 arch/x86/kernel/setup.c                |   22 +++++++++++++++++-
 arch/x86/kernel/tsc.c                  |    4 +++
 arch/x86/kernel/vmlinux_32.lds.S       |    8 +++++++
 arch/x86/mach-default/setup.c          |    3 +-
 include/asm-x86/dma-mapping.h          |   35 ++++++++++++++++++++++++++++--
 include/asm-x86/fixmap_32.h            |    7 ++++++
 include/asm-x86/mmu_context_32.h       |    2 +
 include/asm-x86/serial.h               |   11 +++++++--
 24 files changed, 240 insertions(+), 11 deletions(-)

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 8cc688a..6ad1f73 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -438,6 +438,7 @@ source "arch/x86/lguest/Kconfig"
 
 config PARAVIRT
 	bool "Enable paravirtualization code"
+	default y
 	depends on !X86_VOYAGER
 	help
 	  This changes the kernel so it can modify itself when it is run
diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 5e5d037..a06e1b7 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -92,6 +92,7 @@ obj-$(CONFIG_DEBUG_NX_TEST)	+= test_nx.o
 obj-$(CONFIG_VMI)		+= vmi_32.o vmiclock_32.o
 obj-$(CONFIG_KVM_GUEST)		+= kvm.o
 obj-$(CONFIG_KVM_CLOCK)		+= kvmclock.o
+obj-$(CONFIG_WRHV)		+= wrhv.o wrhv_initrd.o vbiSyscalls.o
 obj-$(CONFIG_PARAVIRT)		+= paravirt.o paravirt_patch_$(BITS).o
 obj-$(CONFIG_PARAVIRT_CLOCK)	+= pvclock.o
 
@@ -124,3 +125,11 @@ ifeq ($(CONFIG_X86_64),y)
 
         obj-$(CONFIG_PCI_MMCONFIG)	+= mmconf-fam10h_64.o
 endif
+
+# wrhv embeds an initrd in the vmlinux
+$(obj)/wrhv_initrd.o: FORCE
+	@ $(AS) $(srctree)/$(src)/wrhv_initrd.S -o $@
+ifneq (X$(INITRD), X)
+	@ $(OBJCOPY) --add-section .initrd=$(INITRD) $@
+	@ $(OBJCOPY) --set-section-flags .initrd=alloc,load $@
+endif
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index a84ac7b..f396193 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -345,8 +345,11 @@ void alternatives_smp_switch(int smp)
 	printk("lockdep: fixing up alternatives.\n");
 #endif
 
+#ifndef CONFIG_WRHV
 	if (noreplace_smp || smp_alt_once)
 		return;
+#endif
+
 	BUG_ON(!smp && (num_online_cpus() > 1));
 
 	mutex_lock(&smp_alt);
diff --git a/arch/x86/kernel/asm-offsets_32.c b/arch/x86/kernel/asm-offsets_32.c
index 77b6f0f..c6cc239 100644
--- a/arch/x86/kernel/asm-offsets_32.c
+++ b/arch/x86/kernel/asm-offsets_32.c
@@ -21,6 +21,10 @@
 
 #include <xen/interface/xen.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+#endif
+
 #include <linux/lguest.h>
 #include "../../../drivers/lguest/lg.h"
 
@@ -116,6 +120,11 @@ void foo(void)
 	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);
 #endif
 
+#ifdef CONFIG_WRHV
+	BLANK();
+	DEFINE(WRHV_VB_CONFIG_SIZE, sizeof(VB_CONFIG));
+#endif
+
 #ifdef CONFIG_XEN
 	BLANK();
 	OFFSET(XEN_vcpu_info_mask, vcpu_info, evtchn_upcall_mask);
diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c
index 31027aa..2fbfda3 100644
--- a/arch/x86/kernel/cpu/intel.c
+++ b/arch/x86/kernel/cpu/intel.c
@@ -17,6 +17,7 @@
 
 #include "cpu.h"
 
+#include <asm/wrhv.h>
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/mpspec.h>
 #include <asm/apic.h>
@@ -32,6 +33,7 @@ struct movsl_mask movsl_mask __read_mostly;
 
 static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 {
+#ifndef CONFIG_WRHV
 	/* Unmask CPUID levels if masked: */
 	if (c->x86 == 6 && c->x86_model >= 15) {
 		u64 misc_enable;
@@ -44,6 +46,7 @@ static void __cpuinit early_init_intel(struct cpuinfo_x86 *c)
 			c->cpuid_level = cpuid_eax(0);
 		}
 	}
+#endif
 
 	/* Netburst reports 64 bytes clflush size, but does IO in 128 bytes */
 	if (c->x86 == 15 && c->x86_cache_alignment == 64)
@@ -79,6 +82,7 @@ int __cpuinit ppro_with_ram_bug(void)
  */
 static void __cpuinit Intel_errata_workarounds(struct cpuinfo_x86 *c)
 {
+#ifndef CONFIG_WRHV
 	unsigned long lo, hi;
 
 	if ((c->x86 == 15) && (c->x86_model == 1) && (c->x86_mask == 1)) {
@@ -90,6 +94,10 @@ static void __cpuinit Intel_errata_workarounds(struct cpuinfo_x86 *c)
 			wrmsr (MSR_IA32_MISC_ENABLE, lo, hi);
 		}
 	}
+
+#else
+	wrhv_cpu_workarounds(c);
+#endif
 }
 
 
diff --git a/arch/x86/kernel/cpu/mcheck/non-fatal.c b/arch/x86/kernel/cpu/mcheck/non-fatal.c
index cc1fccd..5583677 100644
--- a/arch/x86/kernel/cpu/mcheck/non-fatal.c
+++ b/arch/x86/kernel/cpu/mcheck/non-fatal.c
@@ -67,6 +67,9 @@ static int __init init_nonfatal_mce_checker(void)
 {
 	struct cpuinfo_x86 *c = &boot_cpu_data;
 
+	if (mce_disabled == 1)
+		return -ENODEV;
+
 	/* Check for MCE support */
 	if (!cpu_has(c, X86_FEATURE_MCE))
 		return -ENODEV;
diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c
index 66e48aa..436bdf5 100644
--- a/arch/x86/kernel/e820.c
+++ b/arch/x86/kernel/e820.c
@@ -237,9 +237,11 @@ int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,
 	int old_nr, new_nr, chg_nr;
 	int i;
 
+#ifndef CONFIG_WRHV
 	/* if there's only one memory region, don't bother */
 	if (*pnr_map < 2)
 		return -1;
+#endif
 
 	old_nr = *pnr_map;
 	BUG_ON(old_nr > max_nr_map);
@@ -1293,6 +1295,9 @@ void __init e820_reserve_resources(void)
 
 	for (i = 0; i < e820_saved.nr_map; i++) {
 		struct e820entry *entry = &e820_saved.map[i];
+#ifdef CONFIG_WRHV
+		if (entry->size > 0)
+#endif
 		firmware_map_add_early(entry->addr,
 			entry->addr + entry->size - 1,
 			e820_type_to_string(entry->type));
diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S
index a7010c3..dab6d4b 100644
--- a/arch/x86/kernel/head_32.S
+++ b/arch/x86/kernel/head_32.S
@@ -19,6 +19,9 @@
 #include <asm/asm-offsets.h>
 #include <asm/setup.h>
 #include <asm/processor-flags.h>
+#include <vbi/vbInterface.h>
+
+#define WRHV_COREID_OFFSET	0x98
 
 /* Physical address */
 #define pa(X) ((X) - __PAGE_OFFSET)
@@ -83,6 +86,12 @@ INIT_MAP_BEYOND_END = BOOTBITMAP_SIZE + (PAGE_TABLE_SIZE + ALLOCATOR_SLOP)*PAGE_
  */
 .section .text.head,"ax",@progbits
 ENTRY(startup_32)
+
+/*
+	mov $0x65, %al
+	mov $0x2f8, %dx
+	outb %al, %dx
+*/
 	/* test KEEP_SEGMENTS flag to see if the bootloader is asking
 		us to not reload segments */
 	testb $(1<<6), BP_loadflags(%esi)
@@ -98,6 +107,13 @@ ENTRY(startup_32)
 	movl %eax,%fs
 	movl %eax,%gs
 2:
+#if defined(CONFIG_WRHV) && defined(CONFIG_SMP)
+	movl 0x4(%esp), %esi
+	movl WRHV_COREID_OFFSET(%esi), %eax
+	cmpl $0,%eax
+	jne startup_32_smp
+#endif
+
 
 /*
  * Clear BSS first so that there are no surprises...
@@ -117,6 +133,7 @@ ENTRY(startup_32)
  * (kexec on panic case). Hence copy out the parameters before initializing
  * page tables.
  */
+#ifndef CONFIG_WRHV
 	movl $pa(boot_params),%edi
 	movl $(PARAM_SIZE/4),%ecx
 	cld
@@ -162,6 +179,25 @@ subarch_entries:
 num_subarch_entries = (. - subarch_entries) / 4
 .previous
 #endif /* CONFIG_PARAVIRT */
+#else  /* CONFIG_WRHV */
+	/* Copy over the wrhv config, it's assumed the stack hasn't been fiddled with yet */
+	movl 0x4(%esp), %esi
+	/* Store the address of wrhv config so we can map it in later */
+	movl %esi, pa(_wrhvConfig)
+	movl $pa(__wrhvConfig), %edi
+	movl $(WRHV_VB_CONFIG_SIZE/4),%ecx
+	cld
+	rep
+	movsl
+
+	/* Fill in the boot command line */
+	movl $pa(__wrhvConfig + VB_CONFIG_BOOTLINE_OFFSET), %esi
+	movl $pa(boot_command_line),%edi
+	movl $(VB_MAX_BOOTLINE_LENGTH/4),%ecx
+	rep
+	movsl
+#endif
+
 
 /*
  * Initialize page tables.  This creates a PDE and a set of page
diff --git a/arch/x86/kernel/i8237.c b/arch/x86/kernel/i8237.c
index dbd6c1d..3fbf38c 100644
--- a/arch/x86/kernel/i8237.c
+++ b/arch/x86/kernel/i8237.c
@@ -63,9 +63,15 @@ static struct sys_device device_i8237A = {
 
 static int __init i8237A_init_sysfs(void)
 {
-	int error = sysdev_class_register(&i8237_sysdev_class);
+	int error = -ENOSYS;
+
+	if (paravirt_enabled())
+		goto done;
+
+	error = sysdev_class_register(&i8237_sysdev_class);
 	if (!error)
 		error = sysdev_register(&device_i8237A);
+done:
 	return error;
 }
 
diff --git a/arch/x86/kernel/i8253.c b/arch/x86/kernel/i8253.c
index c1b5e3e..7471305 100644
--- a/arch/x86/kernel/i8253.c
+++ b/arch/x86/kernel/i8253.c
@@ -214,6 +214,9 @@ static void pit_disable_clocksource(void)
 
 static int __init init_pit_clocksource(void)
 {
+	if (paravirt_enabled())
+		return 0;
+
 	 /*
 	  * Several reasons not to register PIT as a clocksource:
 	  *
diff --git a/arch/x86/kernel/i8259.c b/arch/x86/kernel/i8259.c
index dc92b49..bd18e15 100644
--- a/arch/x86/kernel/i8259.c
+++ b/arch/x86/kernel/i8259.c
@@ -274,9 +274,15 @@ static struct sys_device device_i8259A = {
 
 static int __init i8259A_init_sysfs(void)
 {
-	int error = sysdev_class_register(&i8259_sysdev_class);
+	int error = -ENOSYS;
+
+	if (paravirt_enabled())
+		goto done;
+
+	error = sysdev_class_register(&i8259_sysdev_class);
 	if (!error)
 		error = sysdev_register(&device_i8259A);
+done:
 	return error;
 }
 
diff --git a/arch/x86/kernel/microcode.c b/arch/x86/kernel/microcode.c
index 652fa5c..545bb29 100644
--- a/arch/x86/kernel/microcode.c
+++ b/arch/x86/kernel/microcode.c
@@ -810,6 +810,10 @@ static int __init microcode_init (void)
 {
 	int error;
 
+#ifdef CONFIG_WRHV
+	return -1;
+#endif
+
 	printk(KERN_INFO
 		"IA-32 Microcode Update Driver: v" MICROCODE_VERSION " <tigran@aivazian.fsnet.co.uk>\n");
 
diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c
index 87d4d69..1d63a11 100644
--- a/arch/x86/kernel/pci-dma.c
+++ b/arch/x86/kernel/pci-dma.c
@@ -3,6 +3,11 @@
 #include <linux/bootmem.h>
 #include <linux/pci.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+#include <vbi/vbiPaddr.h>
+#endif
+
 #include <asm/proto.h>
 #include <asm/dma.h>
 #include <asm/iommu.h>
@@ -336,6 +341,20 @@ dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,
 
 		memset(memory, 0, size);
 		if (!mmu) {
+#ifdef CONFIG_WRHV
+			if (paravirt_enabled()) {
+				u64 paddr;
+
+				if (vbiGuestDmaAddrGet((void *)memory,
+							&paddr) == 0)
+					*dma_handle = (dma_addr_t)paddr;
+				else {
+					free_pages((unsigned long)memory,
+				   			get_order(size));
+					return NULL;
+				}
+			} else
+#endif
 			*dma_handle = bus;
 			return memory;
 		}
diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c
index 3f91f71..7c83139 100644
--- a/arch/x86/kernel/pci-nommu.c
+++ b/arch/x86/kernel/pci-nommu.c
@@ -7,6 +7,12 @@
 #include <linux/dma-mapping.h>
 #include <linux/scatterlist.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+#include <vbi/vbiPaddr.h>
+#endif
+
+
 #include <asm/iommu.h>
 #include <asm/processor.h>
 #include <asm/dma.h>
@@ -63,6 +69,18 @@ static int nommu_map_sg(struct device *hwdev, struct scatterlist *sg,
 
 	for_each_sg(sg, s, nents, i) {
 		BUG_ON(!sg_page(s));
+#ifdef CONFIG_WRHV
+		if (paravirt_enabled()) {
+			struct page *page;
+			u64 paddr;
+
+			page = sg_page(s);
+			if (vbiGuestDmaAddrGet((void *)page, &paddr) == 0)
+				s->dma_address = (dma_addr_t)paddr + s->offset;
+			else
+				s->dma_address = -1;
+		} else
+#endif
 		s->dma_address = sg_phys(s);
 		if (!check_addr("map_sg", hwdev, s->dma_address, s->length))
 			return 0;
diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c
index 876e918..41355d5 100644
--- a/arch/x86/kernel/process.c
+++ b/arch/x86/kernel/process.c
@@ -9,6 +9,10 @@
 #include <linux/clockchips.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+#endif
+
 unsigned long idle_halt;
 EXPORT_SYMBOL(idle_halt);
 unsigned long idle_nomwait;
@@ -177,6 +181,16 @@ static void mwait_idle(void)
 		local_irq_enable();
 }
 
+#ifdef CONFIG_WRHV
+static void wrhv_idle(void)
+{
+	if (!need_resched()) {
+		local_irq_enable();
+		vbiCtxctl(VBI_CTXCTL_IDLE, 1, 0);
+	}
+}
+#endif
+
 /*
  * On SMP it's slightly faster (but much more power-consuming!)
  * to poll the ->work.need_resched flag instead of waiting for the
@@ -363,6 +377,11 @@ static int __init idle_setup(char *str)
 		 */
 		idle_nomwait = 1;
 		return 0;
+#ifdef CONFIG_WRHV
+	} else if (!strncmp(str, "wrhv", 5)) {
+		printk("using hypercall in idle threads\n");
+		pm_idle = wrhv_idle;
+#endif
 	} else
 		return -1;
 
diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c
index 5625407..ad4aa4f 100644
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@ -896,8 +896,14 @@ long arch_ptrace(struct task_struct *child, long request, long addr, long data)
 			tmp = getreg(child, addr);
 		else if (addr >= offsetof(struct user, u_debugreg[0]) &&
 			 addr <= offsetof(struct user, u_debugreg[7])) {
+#ifdef CONFIG_WRHV
+			ret = -EIO;
+			break;
+#else
+
 			addr -= offsetof(struct user, u_debugreg[0]);
 			tmp = ptrace_get_debugreg(child, addr / sizeof(data));
+#endif
 		}
 		ret = put_user(tmp, datap);
 		break;
diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c
index 8d5feb2..814f7f9 100644
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@ -102,6 +102,7 @@
 #include <asm/percpu.h>
 #include <asm/topology.h>
 #include <asm/apicdef.h>
+#include <asm/wrhv.h>
 #ifdef CONFIG_X86_64
 #include <asm/numa_64.h>
 #endif
@@ -250,13 +251,15 @@ static inline void copy_edd(void)
 
 #ifdef CONFIG_BLK_DEV_INITRD
 
+#ifdef CONFIG_X86_32
+
 #define MAX_MAP_CHUNK	(NR_FIX_BTMAPS << PAGE_SHIFT)
 static void __init relocate_initrd(void)
 {
 
 	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
-	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
+	u64 end_of_lowmem = max_low_pfn << PAGE_SHIFT;
 	u64 ramdisk_here;
 	unsigned long slop, clen, mapaddr;
 	char *p, *q;
@@ -313,12 +316,14 @@ static void __init relocate_initrd(void)
 		ramdisk_here, ramdisk_here + ramdisk_size - 1);
 }
 
+#endif
+
 static void __init reserve_initrd(void)
 {
 	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
 	u64 ramdisk_end   = ramdisk_image + ramdisk_size;
-	u64 end_of_lowmem = max_low_pfn_mapped << PAGE_SHIFT;
+	u64 end_of_lowmem = max_low_pfn << PAGE_SHIFT;
 
 	if (!boot_params.hdr.type_of_loader ||
 	    !ramdisk_image || !ramdisk_size)
@@ -348,7 +353,14 @@ static void __init reserve_initrd(void)
 		return;
 	}
 
+#ifdef CONFIG_X86_32
 	relocate_initrd();
+#else
+	printk(KERN_ERR "initrd extends beyond end of memory "
+              "(0x%08llx > 0x%08llx)\ndisabling initrd\n",
+              ramdisk_end, end_of_lowmem);
+	initrd_start = 0;
+#endif
 
 	free_early(ramdisk_image, ramdisk_end);
 }
@@ -617,6 +629,7 @@ static struct dmi_system_id __initdata bad_bios_dmi_table[] = {
 
 void __init setup_arch(char **cmdline_p)
 {
+	wrhv_boot_config();
 #ifdef CONFIG_X86_32
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
 	visws_early_detect();
@@ -630,6 +643,7 @@ void __init setup_arch(char **cmdline_p)
 
 	early_trap_init();
 	early_cpu_init();
+
 	early_ioremap_init();
 
 	ROOT_DEV = old_decode_dev(boot_params.hdr.root_dev);
@@ -696,6 +710,8 @@ void __init setup_arch(char **cmdline_p)
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
 
+	wrhv_init();
+
 	parse_early_param();
 
 #ifdef CONFIG_X86_64
@@ -902,6 +918,8 @@ void __init setup_arch(char **cmdline_p)
 
 	e820_setup_gap();
 
+	wrhv_calibrate_smp_cpus();
+
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c
index de850e9..730641e 100644
--- a/arch/x86/kernel/tsc.c
+++ b/arch/x86/kernel/tsc.c
@@ -514,8 +514,12 @@ static struct clocksource clocksource_tsc = {
 	.read                   = read_tsc,
 	.mask                   = CLOCKSOURCE_MASK(64),
 	.shift                  = 22,
+#ifdef CONFIG_WRHV
+	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS, 
+#else
 	.flags                  = CLOCK_SOURCE_IS_CONTINUOUS |
 				  CLOCK_SOURCE_MUST_VERIFY,
+#endif
 #ifdef CONFIG_X86_64
 	.vread                  = vread_tsc,
 #endif
diff --git a/arch/x86/kernel/vmlinux_32.lds.S b/arch/x86/kernel/vmlinux_32.lds.S
index 9d8dba8..f974e0e 100644
--- a/arch/x86/kernel/vmlinux_32.lds.S
+++ b/arch/x86/kernel/vmlinux_32.lds.S
@@ -177,6 +177,14 @@ SECTIONS
 	__initramfs_end = .;
   }
 #endif
+#if defined(CONFIG_WRHV)
+  . = ALIGN(4096);
+  .initrd : {
+	__initrd_start = .;
+	*(.initrd)
+	__initrd_end = .;
+  }
+#endif
   . = ALIGN(PAGE_SIZE);
   .data.percpu  : AT(ADDR(.data.percpu) - LOAD_OFFSET) {
 	__per_cpu_start = .;
diff --git a/arch/x86/mach-default/setup.c b/arch/x86/mach-default/setup.c
index 3d31783..36854ab 100644
--- a/arch/x86/mach-default/setup.c
+++ b/arch/x86/mach-default/setup.c
@@ -9,6 +9,7 @@
 #include <asm/arch_hooks.h>
 #include <asm/e820.h>
 #include <asm/setup.h>
+#include <asm/wrhv.h>
 
 #ifdef CONFIG_HOTPLUG_CPU
 #define DEFAULT_SEND_IPI	(1)
@@ -132,7 +133,7 @@ void __init time_init_hook(void)
 	}
 
 	irq0.mask = cpumask_of_cpu(0);
-	setup_irq(0, &irq0);
+	setup_irq(TIMER_INT_NUM, &irq0);
 }
 
 #ifdef CONFIG_MCA
diff --git a/include/asm-x86/dma-mapping.h b/include/asm-x86/dma-mapping.h
index ad9cd6d..41bbcc9 100644
--- a/include/asm-x86/dma-mapping.h
+++ b/include/asm-x86/dma-mapping.h
@@ -10,6 +10,12 @@
 #include <asm/io.h>
 #include <asm/swiotlb.h>
 
+#ifdef CONFIG_WRHV
+#include <vbi/vbInterface.h>
+#include <vbi/vbiPaddr.h>
+#endif
+
+
 extern dma_addr_t bad_dma_address;
 extern int iommu_merge;
 extern struct device fallback_dev;
@@ -102,10 +108,23 @@ static inline dma_addr_t
 dma_map_single(struct device *hwdev, void *ptr, size_t size,
 	       int direction)
 {
+	phys_addr_t paddr;
+
 	struct dma_mapping_ops *ops = get_dma_ops(hwdev);
 
 	BUG_ON(!valid_dma_direction(direction));
-	return ops->map_single(hwdev, virt_to_phys(ptr), size, direction);
+
+#ifdef CONFIG_WRHV
+	if (paravirt_enabled()) {
+		u64 tmp_paddr;
+		if (vbiGuestDmaAddrGet((void *)ptr, &tmp_paddr) != 0)
+			return -1;
+		else
+			paddr = (phys_addr_t)tmp_paddr;
+	} else
+#endif
+	paddr = virt_to_phys(ptr);
+	return ops->map_single(hwdev, paddr, size, direction);
 }
 
 static inline void
@@ -220,11 +239,21 @@ static inline dma_addr_t dma_map_page(struct device *dev, struct page *page,
 				      size_t offset, size_t size,
 				      int direction)
 {
+	phys_addr_t paddr;
 	struct dma_mapping_ops *ops = get_dma_ops(dev);
 
 	BUG_ON(!valid_dma_direction(direction));
-	return ops->map_single(dev, page_to_phys(page) + offset,
-			       size, direction);
+#ifdef CONFIG_WRHV
+	if (paravirt_enabled()) {
+		u64 tmp_paddr;
+		if (vbiGuestDmaAddrGet((void *)page_address(page), &tmp_paddr) == 0)
+			paddr = (phys_addr_t)tmp_paddr + offset;
+		else
+			return -1;
+	} else
+#endif
+	paddr = page_to_phys(page) + offset;
+	return ops->map_single(dev, paddr, size, direction);
 }
 
 static inline void dma_unmap_page(struct device *dev, dma_addr_t addr,
diff --git a/include/asm-x86/fixmap_32.h b/include/asm-x86/fixmap_32.h
index f1ac2b2..d972791 100644
--- a/include/asm-x86/fixmap_32.h
+++ b/include/asm-x86/fixmap_32.h
@@ -85,6 +85,13 @@ enum fixed_addresses {
 #ifdef CONFIG_PARAVIRT
 	FIX_PARAVIRT_BOOTMAP,
 #endif
+#ifdef CONFIG_WRHV
+	FIX_WRHV_VBCONFIG,
+	FIX_WRHV_VBCONTROL,
+	FIX_WRHV_VBSTATUS,
+	FIX_WRHV_SHMCONFIG,
+	FIX_WRHV_INTCONFIG,
+#endif
 	__end_of_permanent_fixed_addresses,
 	/*
 	 * 256 temporary boot-time mappings, used by early_ioremap(),
diff --git a/include/asm-x86/mmu_context_32.h b/include/asm-x86/mmu_context_32.h
index 824fc57..cf4d7d1 100644
--- a/include/asm-x86/mmu_context_32.h
+++ b/include/asm-x86/mmu_context_32.h
@@ -18,7 +18,9 @@ static inline void switch_mm(struct mm_struct *prev,
 
 	if (likely(prev != next)) {
 		/* stop flush ipis for the previous mm */
+#if !defined(CONFIG_WRHV)
 		cpu_clear(cpu, prev->cpu_vm_mask);
+#endif
 #ifdef CONFIG_SMP
 		per_cpu(cpu_tlbstate, cpu).state = TLBSTATE_OK;
 		per_cpu(cpu_tlbstate, cpu).active_mm = next;
diff --git a/include/asm-x86/serial.h b/include/asm-x86/serial.h
index 628c801..dd26c58 100644
--- a/include/asm-x86/serial.h
+++ b/include/asm-x86/serial.h
@@ -21,9 +21,14 @@
 
 #define SERIAL_PORT_DFNS			\
 	/* UART CLK   PORT IRQ     FLAGS        */			\
-	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
-	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
+	{ 0, BASE_BAUD, 0x3F8, 0, STD_COM_FLAGS },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, 0, STD_COM_FLAGS },	/* ttyS1 */	\
 	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
-	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
+	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */	\
+	{ 0, BASE_BAUD, 0x220, 0, STD_COM_FLAGS },      /* ttyS4 */     \
+	{ 0, BASE_BAUD, 0x238, 0, STD_COM_FLAGS },      /* ttyS5 */     \
+	{ 0, BASE_BAUD, 0xDCC8, 0, STD_COM_FLAGS },     /* ttyS6 */     \
+	{ 0, BASE_BAUD, 0xDCD0, 0, STD_COM_FLAGS },     /* ttyS7 */
+
 
 #endif /* _ASM_X86_SERIAL_H */
-- 
1.6.3.3

