From 18aba249afecac9fa03e869494d6fd447d5b91e6 Mon Sep 17 00:00:00 2001
From: Paul Gortmaker <paul.gortmaker@windriver.com>
Date: Wed, 4 Nov 2009 13:41:47 -0500
Subject: [PATCH 04/22] vbi: cosmetic diff; whitespace, MACRO -> macro, etc

Lots of little changes here, but all cosmetic.  No impact
on generated code or runtime behaviour.

Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
---
 arch/powerpc/include/asm/arch_vbi.h |   71 +++++++--------
 arch/powerpc/include/asm/vbi.h      |   27 +++---
 arch/powerpc/kernel/vbi/show.c      |   28 +++---
 arch/powerpc/kernel/vbi/syscalls.S  |    1 -
 include/vbi/interface.h             |  109 +++++++++++------------
 include/vbi/syscall.h               |   30 +++---
 include/vbi/syscalls.h              |  168 +++++++++++++++-------------------
 include/vbi/types.h                 |   10 +-
 kernel/vbi/interrupt.c              |   13 +--
 kernel/vbi/io_apic.c                |   55 ++++-------
 kernel/vbi/lib.c                    |  142 ++++++++++++++----------------
 kernel/vbi/msg.c                    |   15 ++--
 kernel/vbi/ns.c                     |   14 +--
 kernel/vbi/paddr.c                  |   14 +--
 kernel/vbi/shmem.c                  |   76 +++++++---------
 15 files changed, 348 insertions(+), 425 deletions(-)

diff --git a/arch/powerpc/include/asm/arch_vbi.h b/arch/powerpc/include/asm/arch_vbi.h
index 830f6b9..937e719 100644
--- a/arch/powerpc/include/asm/arch_vbi.h
+++ b/arch/powerpc/include/asm/arch_vbi.h
@@ -336,8 +336,8 @@ struct vb_arch_stat_regs
 	uint32_t esrr1;  /* 14: */
 
 	/*
-	 * keep this part in a separate structure in order to keep
-	 * the offsets to remain the same as in VB_STATUS
+	 * keep this part in a separate structure in order to keep the offsets
+	 * to remain the same as in VB_STATUS
 	 */
 
 	/* reserved fields for future use */
@@ -389,7 +389,6 @@ typedef struct
 typedef HREG_SET VBI_HREG_SET;
 
 /* mdio messages */
-
 #define VBI_MDIO_READ           MDIO_READ
 #define VBI_MDIO_WRITE          MDIO_WRITE
 #define VBI_BSP_CLK_FREQ        BSP_CLK_FREQ
@@ -435,7 +434,7 @@ typedef struct
 			uint32_t regNum;
 			uint32_t page;
 			uint32_t dataVal;
-	} mdioWrite;
+		} mdioWrite;
 #if 0 /* not supported for now */
 		struct
 		{
@@ -466,11 +465,11 @@ typedef struct
  *
  * VBI_CTX_LOAD - Load a guest context
  *
- * This routine is implemented as an assembly MACRO since it's callers can't
- * reference C functions. This MACRO  makes a hypercall to load a context for
+ * This routine is implemented as an assembly macro since it's callers can't
+ * reference C functions. This macro  makes a hypercall to load a context for
  * a guest * OS. The guest OS running on the core is expected to store a set
  * of registers that represent the new context to load in the it's control
- * structure then call VBI_CTX_LOAD() MACRO to switch to the new context.
+ * structure then call VBI_CTX_LOAD() macro to switch to the new context.
  * The Following are the registers loaded from the control structure:
  *
  * VB_CONTROL_SRR0	     ------->  SRR0
@@ -495,20 +494,19 @@ typedef struct
  *
  */
 
-#define VBI_CTX_LOAD(reg)			\
-	lis reg, HI(VBI_SYS_ctx_load);		\
-	ori reg, reg, LO(VBI_SYS_ctx_load);	\
+#define VBI_CTX_LOAD(reg)			    \
+	lis reg, HI(VBI_SYS_ctx_load);		    \
+	ori reg, reg, LO(VBI_SYS_ctx_load);	    \
 	sc
 
 /*
- *
  * VBI_INT_VCORE_LOCK - lock a core's interrupts macro
  *
- * This MACRO disables the currently running core interrupts and returns the
+ * This macro disables the currently running core interrupts and returns the
  * previous interrupts state. The interrupt status field in wrhvVbControl
  * structure at offset VB_CONTROL_INT_DISABLE is set to -1 and the previous
  * interrupts state is loaded to the register passed in as the first argument to
- * this MACRO.
+ * this macro.
  * A hypercall is not needed to perform this operation.
  *
  *
@@ -525,24 +523,23 @@ typedef struct
  *
  */
 #define VBI_INT_VCORE_LOCK(reg0, reg1, reg2)		\
-	li	reg1, -1;				\
-	lis     reg2, HIADJ(wrhvVbControl);		\
-	lwz     reg2, LO(wrhvVbControl)(reg2);		\
-	lwz     reg0, VB_CONTROL_INT_DISABLE(reg2);	\
-	stw     reg1, VB_CONTROL_INT_DISABLE(reg2)		
+	li reg1, -1;					\
+	lis reg2, HIADJ(wrhvVbControl);			\
+	lwz reg2, LO(wrhvVbControl)(reg2);		\
+	lwz reg0, VB_CONTROL_INT_DISABLE(reg2);		\
+	stw reg1, VB_CONTROL_INT_DISABLE(reg2)		
 
 /*
- *
  * VBI_INT_VCORE_UNLOCK - unlock a core's interrupts
  *
- * This MACRO is implemented in assembly to enable a core's interrupts. It
+ * This macro is implemented in assembly to enable a core's interrupts. It
  * enables the interrupts by clearing to zero the value in the core's control
  * structure and and makes a fast hypercall if need be. A hypercall is made only
  * if found that interrupts are pending. The pending interrupts are checked by
  * reading the wrhvVbStatus structure at offset VB_STATUS_INT_PENDING. A
  * positive integer greater than zero indicates that interrupts are pending
  * which causes this macro to make a hypercall in order to drain the pending
- * interrupts. This MACRO expects two general purpose registers. The first
+ * interrupts. This macro expects two general purpose registers. The first
  * register is used to load the value to store and the second is used for
  * holding the destination address of the control or status structure.
  *
@@ -553,16 +550,15 @@ typedef struct
  *	load address of wrhvVbControl in reg0
  *	store reg1 to VB_CONTROL_INT_DISABLE(reg0)
  *
- * checkStatus:
+ * checkstatus:
  *	load address of wrhvVbStatus in reg0
- *       load VB_STATUS_INT_PENDING(reg0) in reg1
- *       check if reg1 is equal to zero
- *       if true return
- *       otherwise send an hypercall
- *       go to checkStatus
+ *	load VB_STATUS_INT_PENDING(reg0) in reg1
+ *	check if reg1 is equal to zero
+ *	if true return
+ *	otherwise send an hypercall
+ *	go to checkstatus
  * }
  *
- *
  */
 #define VBI_INT_VCORE_UNLOCK(reg0, reg1);			\
 	lis	reg0, HIADJ(wrhvVbControl);			\
@@ -583,10 +579,9 @@ checkIntVcorePending:						\
 endIntVcoreLock:
 
 /*
- *
  * VBI_INT_VCORE_STATE_GET - Get interrupts state
  *
- * This MACRO is implemented in assembly to read the interrupt state of the
+ * This macro is implemented in assembly to read the interrupt state of the
  * currently running core. It relies on a passed in general purpose register
  * to store the current state of interrupts. The status is -1 if locked
  * otherwise 0.
@@ -602,8 +597,8 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_INT_VCORE_STATE_GET(reg0)			\
-	VBI_CNTRL_ADDR_GET(reg0);			\
+#define VBI_INT_VCORE_STATE_GET(reg0)		\
+	VBI_CNTRL_ADDR_GET(reg0);		\
 	lwz reg0, VB_CONTROL_INT_DISABLE(reg0);		
 
 /*
@@ -617,8 +612,8 @@ endIntVcoreLock:
  */
 
 #define VBI_CONFIG_ADDR_GET(reg)		\
-	    lis reg, HIADJ(wrhvVbConfig);	\
-	    lwz reg, LO(wrhvVbConfig)(reg)	
+	lis reg, HIADJ(wrhvVbConfig);		\
+	lwz reg, LO(wrhvVbConfig)(reg)	
 
 /*
  * VBI_CNTRL_ADDR_GET - Get virtual core control structure base address
@@ -629,8 +624,8 @@ endIntVcoreLock:
  */
 
 #define VBI_CNTRL_ADDR_GET(reg)			\
-	    lis reg, HIADJ(wrhvVbControl);	\
-	    lwz reg, LO(wrhvVbControl)(reg) 	
+	lis reg, HIADJ(wrhvVbControl);		\
+	lwz reg, LO(wrhvVbControl)(reg) 	
 
 /*
  * VBI_STATUS_ADDR_GET - Get virtual core status structure address
@@ -657,8 +652,8 @@ endIntVcoreLock:
  *
  */
 
-#define VBI_STATUS_ADDR_GET(reg)		\
-	lis reg, HIADJ(wrhvVbStatus);		\
+#define VBI_STATUS_ADDR_GET(reg)		    \
+	lis reg, HIADJ(wrhvVbStatus);		    \
 	lwz reg, LO(wrhvVbStatus)(reg)	
 
 #endif /*_ASMLANGUAGE */
diff --git a/arch/powerpc/include/asm/vbi.h b/arch/powerpc/include/asm/vbi.h
index 77fbe0a..a1c4d78 100644
--- a/arch/powerpc/include/asm/vbi.h
+++ b/arch/powerpc/include/asm/vbi.h
@@ -94,24 +94,23 @@ SP=>|      Back chain                  |
 #define	FRAMEBASESZ		16	/* minimum stack frame size */
 
 /*
-*
-* _WRS_ARCH_USER_STACK_FRAME_EXTENSION - creating words on the stack for the 
-*                                        back chain word and the LR register.
-*
-* This macro is used in creating the initial stack frame for an RTP's initial 
-* task. It performs the extra steps of creating words on the stack for the 
-* back chain word and the LR register. Both these locations are set to 0 to 
-* prevent stack traces and debuggers from looking ahead.
-*
-*/
-
+ *
+ * _WRS_ARCH_USER_STACK_FRAME_EXTENSION - creating words on the stack for the 
+ *                                        back chain word and the LR register.
+ *
+ * This macro is used in creating the initial stack frame for an RTP's initial 
+ * task. It performs the extra steps of creating words on the stack for the 
+ * back chain word and the LR register. Both these locations are set to 0 to 
+ * prevent stack traces and debuggers from looking ahead.
+ *
+ */
 #define _WRS_ARCH_USER_STACK_FRAME_EXTENSION(sp)			     \
-    do									     \
-	{								     \
+do									     \
+{								     \
 	(sp) -= 2*sizeof(int *);					     \
 	*((int *)(sp)) = (int)0;					     \
 	*((int *)((sp)+4)) = (int)0;					     \
-	} while ((0))
+} while ((0))
 
 
 #ifdef	_ASMLANGUAGE
diff --git a/arch/powerpc/kernel/vbi/show.c b/arch/powerpc/kernel/vbi/show.c
index 912c40e..0ec60ae 100644
--- a/arch/powerpc/kernel/vbi/show.c
+++ b/arch/powerpc/kernel/vbi/show.c
@@ -33,35 +33,35 @@ void vbiStsRegsDisplay(void)
 #endif
 
 #if CPU == PPC85XX /* don't know how to handle cpu variant */
-    printk("  srr0/srr1:          0x%08x 0x%08x\n", 
+    printk("  srr0/srr1:          0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, srr0) ,
 		VB_STATUS_REGS_ACCESS (p, srr1));
 
-    printk("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n", 
+    printk("  mcsrr0/mcsrr1:      0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, mcsrr0) ,
 		VB_STATUS_REGS_ACCESS (p, mcsrr1));
 
-    printk("  mcsr/mcar:          0x%08x 0x%08x\n", 
+    printk("  mcsr/mcar:          0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, mcsr) ,
 		VB_STATUS_REGS_ACCESS (p, mcar));
 
-    printk("  dear/esr:           0x%08x 0x%08x\n", 
-		VB_STATUS_REGS_ACCESS (p, dear) , 
+    printk("  dear/esr:           0x%08x 0x%08x\n",
+		VB_STATUS_REGS_ACCESS (p, dear) ,
 		VB_STATUS_REGS_ACCESS (p, esr));
 
-    printk("  svr/pvr:            0x%08x 0x%08x\n", 
+    printk("  svr/pvr:            0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, svr) ,
 		VB_STATUS_REGS_ACCESS (p, pvr));
 
-    printk("  hid0/hid1:          0x%08x 0x%08x\n", 
+    printk("  hid0/hid1:          0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, hid0) ,
 		VB_STATUS_REGS_ACCESS (p, hid1));
 
-    printk("  l1csr0/l1csr1:      0x%08x 0x%08x\n", 
+    printk("  l1csr0/l1csr1:      0x%08x 0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, l1csr0) ,
 		VB_STATUS_REGS_ACCESS (p, l1csr1));
 
-    printk("  bucsr:              0x%08x\n",  
+    printk("  bucsr:              0x%08x\n",
 		VB_STATUS_REGS_ACCESS (p, bucsr));
 #endif
 }
@@ -78,13 +78,13 @@ void vbiCtrlRegsDisplay(void)
 {
     struct vb_control *p = VBI_CNTRL_ADDR_GET();
 
-#if CPU == PPC85XX /* don't know how to handler cpu variant */
-    printk("  srr0/srr1:           0x%08x 0x%08x\n", 
-		VB_CONTROL_REGS_ACCESS (p, srr0),  
+#if CPU == PPC85XX /* don't know how to handle cpu variant */
+    printk("  srr0/srr1:           0x%08x 0x%08x\n",
+		VB_CONTROL_REGS_ACCESS (p, srr0),
 		VB_CONTROL_REGS_ACCESS (p, srr1));
 
-    printk("  cr/r0:               0x%08x 0x%08x\n", 
-		VB_CONTROL_REGS_ACCESS (p, cr), 
+    printk("  cr/r0:               0x%08x 0x%08x\n",
+		VB_CONTROL_REGS_ACCESS (p, cr),
 		VB_CONTROL_REGS_ACCESS (p, r0));
 #endif
 }
diff --git a/arch/powerpc/kernel/vbi/syscalls.S b/arch/powerpc/kernel/vbi/syscalls.S
index d473f25..7a7bc8a 100644
--- a/arch/powerpc/kernel/vbi/syscalls.S
+++ b/arch/powerpc/kernel/vbi/syscalls.S
@@ -408,7 +408,6 @@ FUNC_END(vbiTlbFlush)
  *
  */
 FUNC_LABEL(vbiIntVCoreUnlock)
-
 	lis	p0, HIADJ(wrhvVbControl)
 	lwz	p0, LO(wrhvVbControl)(p0)
 	stw	p1, VB_CONTROL_INT_DISABLE(p0)
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index dcb37c4..b5deed9 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -64,11 +64,12 @@ structures via the VBI function guaranties source level compatibily
 between VBI versions.
 
 A guest OS should port vbiInit(), the access macros along with the
-necessary header files where the data structrures layout is defined.  To
-be aware:  Changing the order of the field this structure may
-have serious impact on the integrity of the system. It exists hand
-crafted macros to match the C structures offset. Therefore any change
-should be reflected in the macros
+necessary header files where the data structrures layout is defined.
+
+To be aware: Changing the order of the field this structure may have
+serious impact on the integrity of the system. It exists hand crafted
+macros to match the C structures offset. Therefore any change should be
+reflected in the macros
 
 When a virtual core boots the VMMU is not enbled but a programmer may
 choose to turn-on the VMMU. In that scenario proper care must be taken
@@ -251,24 +252,27 @@ identity mapped.
  *
  * VIOAPIC configuration registers.
  *
- * The control structure definition is generic accross the various
- * architecture flavours supported by Hypervisor with the exception of
- * the emulated registers.  There is an architecture specific extention
- * available via a pointer of type vb_arch_stat_regs to accomodate the
- * registers unique for a given hardware platform.  However that does
- * imply that other fields defined in this structure are used in every
- * architecture. A field is considered generic if it is usefull at least
- * to two CPU families but not necessary to all CPUs.  The VIOAPIC is
- * the only field that is meaning full accross all architectures.  Note
- * that some architectures like Intel with VT technology don't require
- * emulated registers. The pointer of emulated registers is included
- * only if_WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure
- * is mapped with read/write access attribute for the purpose of serving
- * as duplex communication channel between Hypervisor and a virtual
- * core. This mechanism is fall back when it is not possible to use
- * registers for transmitting data from the virtual core to Hypervisor
- * or vis-versa.  More information about vb_arch_ctrl_regs may be
- * found in the architecture supplement document.
+ * The control structure definition is generic accross the various architecture
+ * flavours supported by Hypervisor with the exception of the emulated
+ * registers.
+ *
+ * There is an architecture specific extention available via a pointer of type
+ * vb_arch_stat_regs to accomodate the registers unique for a given hardware
+ * platform.
+ *
+ * However that does imply that other fields defined in this structure are used
+ * in every architecture. A field is considered generic if it is usefull at
+ * least to two CPU families but not necessary to all CPUs.
+ *
+ * The VIOAPIC is the only field that is meaningful accross all architectures.
+ * Note that some architectures like Intel with VT technology don't require
+ * emulated registers. The pointer of emulated registers is included only if
+ * _WRHV_ARCH_HAS_CTRL_REGS flag is defined. The control structure is mapped
+ * with read/write access attribute for the purpose of serving as duplex
+ * communication channel between Hypervisor and a virtual core. This mechanism
+ * is fall back when it is not possible to use registers for transmitting data
+ * from the virtual core to Hypervisor or vis-versa. More information about
+ * vb_arch_ctrl_regs may be found in the architecture supplement document.
  *
  *
  * Control structure graphical illustration
@@ -289,9 +293,9 @@ identity mapped.
  *   |              |                  configuration (reserved for enhancement)
  *   |--------------|
  *   |              | <------ 64bits - VIOAPIC information header
- *   |              |				 (internal use only)
+ *   |              |                  (internal use only)
  *   |--------------|
- *   |		    |
+ *   |              |
  *   |              |<------- Nbytes - VIOAPIC redirection table
  *   |              |             *Where N = VB_VIOAPIC_ENTRIES_SIZE
  *   |              |
@@ -299,19 +303,12 @@ identity mapped.
  *   |______________|
  *
  *
- * INTERNAL warning!!!!!!!
- * 1. Any modification of this structure field should be reflected in the
- * description.
- * 2. Make sure that VIOAPIC_SIZE is used in the structure
- * 3. Make sure the vbControlRegs, vIoapicRegisters are changed to pointers in
- *     the code
- *
  */
 
 struct vb_control
 {
 
-#ifdef  _WRHV_ARCH_HAS_CTRL_REGS	
+#ifdef  _WRHV_ARCH_HAS_CTRL_REGS
 	struct vb_arch_ctrl_regs vbControlRegs;
 #endif
 
@@ -337,20 +334,22 @@ struct vb_control
 /*
  * vb_status - Virtual board's core status structure
  *
- * vb_status is a C data type structure that provides the definition of
- * an area where the state of a given core is posted by Hypervisor
- * before a virtual core is scheduled to run. The fields of this
- * structure are architecture agnostic.  A pointer is provided to
- * accomodate anything that is specific to the underlying hardware. The
- * architecture specific structure is included only if
- * _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type
- * VB_STATUS_ARCH_REGS holding the architecture dependent registers is
- * defined by a file pulled vbi/arch.h at compile type according to CPU
- * value.  The definition of vb_arch_stat_regs can be found in the
- * architecture supplement documentation.  The purpose of this structure
- * is to inform a virtual core at runtime the status of a core's time
- * variant data such as:
+ * vb_status is a C data type structure that provides the definition of an area
+ * where the state of a given core is posted by Hypervisor before a virtual
+ * core is scheduled to run. The fields of this structure are architecture
+ * agnostic.
  *
+ * A pointer is provided to accomodate anything that is specific to the
+ * underlying hardware. The architecture specific structure is included only
+ * if _WRHV_ARCH_HAS_STATUS_REGS flag is defined. The data type
+ * VB_STATUS_ARCH_REGS holding the architecture dependent registers is defined
+ * by a file pulled vbi/arch.h at compile type according to CPU value.
+ *
+ * The definition of vb_arch_stat_regs can be found in the architecture
+ * supplement documentation.
+ *
+ * The purpose of this structure is to inform a virtual core at runtime the
+ * status of a core's time variant data such as:
  *
  * Interrupts state
  *
@@ -370,8 +369,8 @@ struct vb_control
  * Control structure graphical illustration
  *
  *        ______________
- *       |		|	
- *       |		|<-------64bits - vb_arch_stat_regs; arch dependent
+ *       |		|
+ *       |		|<-------64bits - VB_ARCH_STATUS_REGS; arch dependent
  *       |		|		structure pointer
  *       |--------------|
  *       |		|<-------32bits - int_pend; pending vector number
@@ -421,7 +420,7 @@ struct vb_status {
 	 * control->intDisable is set to -1 by WRHV at the time of delivery of
 	 * the interrupt
 	 */
-	uint32_t	oldIntDisable;
+	uint32_t oldIntDisable;
 
 	/* VMMU tables which were active when an MMU exception occurred */
 	VB_ALIGN_FIELD_64 (void *vmmu0, pad1);
@@ -434,19 +433,17 @@ struct vb_status {
 	uint32_t boot_count;
 
 	/* initial program load flag */
-
-	uint32_t ipl;	
+	uint32_t ipl;
 
 	/* The simulatror flag  */
-
-	uint32_t sim;	
+	uint32_t sim;
 
 };
 
 /* Configuration information for interrupts */
 struct vb_int_info
 {
-	char intName[VB_NAMELEN];	/* the name of this interrupt */
+	char intName[VB_NAMELEN];/* the name of this interrupt */
 	uint16_t intDirection;	/* interrupt direction: INPUT_INT, OUTPUT_INT */
 	uint16_t intNumber;	/* the local VB interrupt number */
 	uint32_t intCore;	/* the receiving core for this incomming int */
@@ -473,7 +470,7 @@ struct vb_mem_info
 	VB_ALIGN_FIELD_64 (void *addr, pad1);
 	uint32_t length;	/* the length in bytes of the region */
 	uint32_t attr;		/* the MMU attributes of the region */
-	char type[VB_NAMELEN];		/* the type of the region */
+	char type[VB_NAMELEN];	/* the type of the region */
 };
 
 
@@ -522,7 +519,7 @@ struct vb_config
 
 	int32_t supervisoryMode;/* board is running in privileged mode */
 
-	char board_name[VB_NAMELEN];	/* the name of this board */
+	char board_name[VB_NAMELEN];/* the name of this board */
 	uint32_t board_type;	/* the type of this board */
 	uint32_t boot_count;	/* number of times this core has booted */
 
diff --git a/include/vbi/syscall.h b/include/vbi/syscall.h
index e7910d9..8a15005 100644
--- a/include/vbi/syscall.h
+++ b/include/vbi/syscall.h
@@ -124,33 +124,33 @@ extern vbiStatus_t vbiVmmuTlbFlush(struct vmmuConfig * config, void *addr, size_
 
 /* Prior to vbi 2.0 these api were vbiMmuAttrSet/Get */
 
-extern asmlinkage vbiStatus_t  vbiMemAttrSet (void *vaddr, size_t len, vbiMemAttr_t attr);
-extern asmlinkage vbiStatus_t  vbiMemAttrGet (void *vaddr, vbiMemAttr_t * attr);
+extern asmlinkage vbiStatus_t  vbiMemAttrSet(void *vaddr, size_t len, vbiMemAttr_t attr);
+extern asmlinkage vbiStatus_t  vbiMemAttrGet(void *vaddr, vbiMemAttr_t * attr);
 
 /*
  * START: New APIs introduced for vbi 2.0  
  */
 
-extern asmlinkage vbiStatus_t vbiIntVCoreUnlock (void);
-extern asmlinkage vbiIntState_t vbiIntVCoreLock (void);
-extern vbiStatus_t vbiCacheTextUpdate (void *saddr, size_t size);
-extern vbiStatus_t  vbiExcBaseSet (void * excTblBase);
+extern asmlinkage vbiStatus_t vbiIntVCoreUnlock(void);
+extern asmlinkage vbiIntState_t vbiIntVCoreLock(void);
+extern vbiStatus_t vbiCacheTextUpdate(void *saddr, size_t size);
+extern vbiStatus_t  vbiExcBaseSet(void * excTblBase);
 
 /* virtual board management API's */
-extern asmlinkage vbiStatus_t vbiVbSuspend (vbiVb_t id, vbiCore_t core);
-extern asmlinkage vbiStatus_t vbiVbReset (vbiVb_t id, vbiCore_t core, uint32_t options);
-extern asmlinkage vbiStatus_t vbiVbRestart (vbiVb_t id, vbiCore_t core);
-extern asmlinkage vbiStatus_t vbiVbResume (vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbSuspend(vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbReset(vbiVb_t id, vbiCore_t core, uint32_t options);
+extern asmlinkage vbiStatus_t vbiVbRestart(vbiVb_t id, vbiCore_t core);
+extern asmlinkage vbiStatus_t vbiVbResume(vbiVb_t id, vbiCore_t core);
 
 /* read remote vb's memory */
-extern asmlinkage vbiStatus_t vbiVbMemoryRead (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
-extern asmlinkage vbiStatus_t vbiVbMemoryWrite (VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
-extern asmlinkage void vbiDebugShellStart (uint32_t  flags);
+extern asmlinkage vbiStatus_t vbiVbMemoryRead(VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern asmlinkage vbiStatus_t vbiVbMemoryWrite(VBI_MEM_CTL *memCtl, vbiVb_t targetBoard);
+extern asmlinkage void vbiDebugShellStart(uint32_t  flags);
 
 /* read remote vb's registers */
-extern asmlinkage vbiStatus_t vbiVbRegisterRead (VBI_HREG_SET *regCtl, 
+extern asmlinkage vbiStatus_t vbiVbRegisterRead(VBI_HREG_SET *regCtl, 
 				       vbiVb_t targetBoard, vbiCore_t core);
-extern asmlinkage vbiStatus_t vbiVbRegisterWrite (VBI_HREG_SET *regCtl, 
+extern asmlinkage vbiStatus_t vbiVbRegisterWrite(VBI_HREG_SET *regCtl, 
 					vbiVb_t targetBoard, vbiCore_t core);
 
 /*
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index 3e03528..42a6da9 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -44,70 +44,61 @@
  */
 
 /* fast system call numbers handled by assembler code */
-
-#define	HY_FAST_SYSCALL_MASK	0x3f000000
-#define	HY_FAST_SYSCALL_SHIFT	24
-#define	HY_FAST_SYSCALL_BIT	0x80000000
-#define	HY_FAST_SYSCALL(x)	\
+#define HY_FAST_SYSCALL_MASK	0x3f000000
+#define HY_FAST_SYSCALL_SHIFT	24
+#define HY_FAST_SYSCALL_BIT	0x80000000
+#define HY_FAST_SYSCALL(x)	\
 	((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
 	 HY_FAST_SYSCALL_BIT)
 
 /* C driven system calls */
-
-#define	HY_SYSCALL_MASK		0x00ffffff
-#define	HY_SYSCALL_SHIFT	0
-#define	HY_SYSCALL_BIT		0x40000000
-#define	HY_SYSCALL(x)	\
+#define HY_SYSCALL_MASK		0x00ffffff
+#define HY_SYSCALL_SHIFT	0
+#define HY_SYSCALL_BIT		0x40000000
+#define HY_SYSCALL(x)	\
 	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
 
 /* fast system calls */
-
-#define	VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush			*/
-#define	VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush	*/
-#define	VBI_SYS_dcache_flush	HY_FAST_SYSCALL(3) /* data cache flush		*/
-#define	VBI_SYS_ctx_load	HY_FAST_SYSCALL(4) /* context load		*/
-#define	VBI_SYS_int_enable	HY_FAST_SYSCALL(5) /* int enable		*/
-#define	VBI_SYS_cache_text_update		    \
+#define VBI_SYS_tlb_flush	HY_FAST_SYSCALL(1) /* TLB flush			*/
+#define VBI_SYS_icache_flush	HY_FAST_SYSCALL(2) /* instruction cache flush	*/
+#define VBI_SYS_dcache_flush	HY_FAST_SYSCALL(3) /* data cache flush		*/
+#define VBI_SYS_ctx_load	HY_FAST_SYSCALL(4) /* context load		*/
+#define VBI_SYS_int_enable	HY_FAST_SYSCALL(5) /* int enable		*/
+#define VBI_SYS_cache_text_update		    \
 				HY_FAST_SYSCALL(6) /* cache text update		*/
 
 
 
 /* hypervisor services */
-
-#define	VBI_SYS_hyIoctl		 HY_SYSCALL(1)	/* hypervisor ioctl	     */
-#define	VBI_SYS_vmContextCreate	 HY_SYSCALL(2)	/* context create	     */
-#define	VBI_SYS_send		 HY_SYSCALL(3)	/* send a messages	     */
-#define	VBI_SYS_receive		 HY_SYSCALL(4)	/* receive a messages	     */
-#define	VBI_SYS_reply		 HY_SYSCALL(5)	/* reply to a messages	     */
-#define	VBI_SYS_panic		 HY_SYSCALL(6)	/* halt the system	     */
-#define	VBI_SYS_int 		 HY_SYSCALL(7)	/* deliver an interrupt	     */
-#define	VBI_SYS_int_controller_done HY_SYSCALL(8)/* done interrupt processing*/
-#define	VBI_SYS_ctxctl 	 	 HY_SYSCALL(9)	/* context control operation */
+#define VBI_SYS_hyIoctl		 HY_SYSCALL(1)	/* hypervisor ioctl	     */
+#define VBI_SYS_vmContextCreate	 HY_SYSCALL(2)	/* context create	     */
+#define VBI_SYS_send		 HY_SYSCALL(3)	/* send a messages	     */
+#define VBI_SYS_receive		 HY_SYSCALL(4)	/* receive a messages	     */
+#define VBI_SYS_reply		 HY_SYSCALL(5)	/* reply to a messages	     */
+#define VBI_SYS_panic		 HY_SYSCALL(6)	/* halt the system	     */
+#define VBI_SYS_int 		 HY_SYSCALL(7)	/* deliver an interrupt	     */
+#define VBI_SYS_int_controller_done HY_SYSCALL(8)/* done interrupt processing*/
+#define VBI_SYS_ctxctl 	 	 HY_SYSCALL(9)	/* context control operation */
 
 /* VMMU operations */
-
-#define	VBI_SYS_vmmu_config 	HY_SYSCALL(10)	/* configure the virtual MMU */
-#define	VBI_SYS_vmmu_enable 	HY_SYSCALL(11)	/* enable the virtual MMU    */
-#define	VBI_SYS_vmmu_disable 	HY_SYSCALL(12)	/* disable the virtual MMU   */
-#define	VBI_SYS_vmmu_tlbload 	HY_SYSCALL(13)	/* load a VMMU TLB entry     */
-#define	VBI_SYS_vmmu_tlbflush 	HY_SYSCALL(14)	/* flush a VMMU TLB entry    */
-#define	VBI_SYS_ctx_load_vmmu	HY_SYSCALL(15)	/* load context with vmmu    */
+#define VBI_SYS_vmmu_config 	HY_SYSCALL(10)	/* configure the virtual MMU */
+#define VBI_SYS_vmmu_enable 	HY_SYSCALL(11)	/* enable the virtual MMU    */
+#define VBI_SYS_vmmu_disable 	HY_SYSCALL(12)	/* disable the virtual MMU   */
+#define VBI_SYS_vmmu_tlbload 	HY_SYSCALL(13)	/* load a VMMU TLB entry     */
+#define VBI_SYS_vmmu_tlbflush 	HY_SYSCALL(14)	/* flush a VMMU TLB entry    */
+#define VBI_SYS_ctx_load_vmmu	HY_SYSCALL(15)	/* load context with vmmu    */
 
 /* MMU operations */
-
-#define	VBI_SYS_mmu_attr_set	HY_SYSCALL(16)	/* set physical memory attr  */
-#define	VBI_SYS_mmu_attr_get	HY_SYSCALL(17)	/* get physical memory attr  */
+#define VBI_SYS_mmu_attr_set	HY_SYSCALL(16)	/* set physical memory attr  */
+#define VBI_SYS_mmu_attr_get	HY_SYSCALL(17)	/* get physical memory attr  */
 
 /* BSP specific interface */
-
 #define VBI_SYS_bspIoctl	HY_SYSCALL(18)	/* BSP specific opreration   */
 
 /* vbMgmt services */
-
 #define VBI_SYS_vbMgmt          HY_SYSCALL(20)
 
 /* Virtual IO APIC services */
-
 #define VBI_SYS_vIoapicIoctl	HY_SYSCALL(21)
 
 #define VBI_SYS_vbReset         HY_SYSCALL(22)	/* reset  vcores	*/
@@ -115,33 +106,27 @@
 #define VBI_SYS_vbSuspend       HY_SYSCALL(24)	/* suspend vcores	*/
 #define VBI_SYS_vbResume        HY_SYSCALL(25)  /* Resume vcores	*/
 
-
 #define VBI_SYS_intRedirect     HY_SYSCALL(40)  /* vcores int redirect	*/
 
 /* debug facilities */
-
-#define	VBI_SYS_kputs		HY_SYSCALL(50)	/* print a string to the cons*/
-#define	VBI_SYS_kputc		HY_SYSCALL(51)	/* print a char to the cons  */
+#define VBI_SYS_kputs		HY_SYSCALL(50)	/* print a string to the cons*/
+#define VBI_SYS_kputc		HY_SYSCALL(51)	/* print a char to the cons  */
 #define VBI_SYS_ps		HY_SYSCALL(52)	/* process status display    */
 #define VBI_SYS_dbgShStart	HY_SYSCALL(53)	/* start debug shell	     */
 
 /* VTLB MMU operations */
-
 #define VBI_SYS_vtlb_op		HY_SYSCALL(55)	/* VTLB operation */
 
 /* Name services */
-
 #define VBI_SYS_ns_op		HY_SYSCALL(60)	/* Name service operation */
 
 /* remote board memory services */
-
 #define VBI_SYS_memWrite_op	HY_SYSCALL(70)	/* memory write service operation */
 
 #define VBI_SYS_memRead_op	HY_SYSCALL(71)	/* memory read service operation */
 
 
 /* remote board memory services */
-
 #define VBI_SYS_RegsWrite_op	HY_SYSCALL(72)	/* regs write service operation */
 
 #define VBI_SYS_RegsRead_op	HY_SYSCALL(73)	/* regs service operation */
@@ -150,43 +135,38 @@
 #define VBI_SYS_max 		(73 + 1)
 
 /* hyIoctl system call supported ioctl's */
-
-#define	VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
-#define	VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
-#define	VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
-#define	VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
-#define	VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
-#define	VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
-#define	VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
-#define	VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
-#define	VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
-#define	VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+#define VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+#define VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
+#define VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
 
 /* vIoapicIoctl system call supported ioctl's */
-
-#define	VBI_IOAPICIOCTL_UNMASK	 1	/* unmask v io apic interrupt src */
-#define	VBI_IOAPICIOCTL_SEND	 2	/* inject a v io apic interrupt */
-#define	VBI_IOAPICIOCTL_EOI	 3	/* end of interrupt acknowledge */
+#define VBI_IOAPICIOCTL_UNMASK	    1	/* unmask v io apic interrupt src */
+#define VBI_IOAPICIOCTL_SEND	    2	/* inject a v io apic interrupt */
+#define VBI_IOAPICIOCTL_EOI	    3	/* end of interrupt acknowledge */
 /* remove this after vbControl is working, we don't need a hypercall for it: */
-#define	VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
+#define VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
 
 /* VBI_IOAPICIOCTL_SEND options */
-
-#define	VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
-#define	VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
-#define	VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
-#define	VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
-#define	VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
+#define VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
+#define VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
+#define VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
+#define VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
+#define VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
 
 /* hyCtxctl system call supported operations */
-
-#define	VBI_CTXCTL_IDLE	 	1	/* make current context idle	*/
+#define VBI_CTXCTL_IDLE	 	1	/* make current context idle	*/
 
 /* MMU protection attributes */
-
-#define	VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
-#define	VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
-#define	VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+#define VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
 
 /* ETSEC MDIO supported ioctl's */
 #define VBI_BSPIOCTL_DRV_MDIO 1         /* mdio messages */
@@ -194,7 +174,7 @@
 /* system clock frequency query */
 #define VBI_BSPIOCTL_SYS_CLK 2
 
-#define	VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
+#define VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
 
 #define MDIO_READ 1
 #define MDIO_WRITE 2
@@ -228,30 +208,30 @@
 #define VBI_VB_CORES_OTHERS	(0x40000000)
 
 /* VTLB operation command and flags (intel-vt specific) */
-#define	VBI_VTLB_OP_UPDATE_PMD		1
-#define	VBI_VTLB_OP_UPDATE_PTE		2
-#define	VBI_VTLB_OP_DELETE_PMD		3
+#define VBI_VTLB_OP_UPDATE_PMD		1
+#define VBI_VTLB_OP_UPDATE_PTE		2
+#define VBI_VTLB_OP_DELETE_PMD		3
 #define VBI_VTLB_OP_SET_PTE_AT		4
-#define	VBI_VTLB_OP_SET_PTE		5
-#define	VBI_VTLB_OP_FLUSH_OPS		6
-#define	VBI_VTLB_OP_INIT		7
+#define VBI_VTLB_OP_SET_PTE		5
+#define VBI_VTLB_OP_FLUSH_OPS		6
+#define VBI_VTLB_OP_INIT		7
 
 /* VTLB macros */
-#define	VBI_VTLB_OP_MAX_OPS		100
-#define	VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
+#define VBI_VTLB_OP_MAX_OPS		100
+#define VBI_VTLB_OP_CR3_CACHE_ENTRIES	4
 
 /* VTLB optimization supported options */
-#define	VBI_VTLB_OPTIM_ENABLED			1
-#define	VBI_VTLB_CR3_CACHE_ENABLED		2
-#define	VBI_VTLB_OPS_CACHE_ENABLED		4
-#define	VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
+#define VBI_VTLB_OPTIM_ENABLED			1
+#define VBI_VTLB_CR3_CACHE_ENABLED		2
+#define VBI_VTLB_OPS_CACHE_ENABLED		4
+#define VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	8
 
 /* vbiNsOp system call supported operations */
-#define	VBI_NS_REGISTER		1	/* register service name    */
-#define	VBI_NS_UNREGISTER	2	/* unregister service name  */
-#define	VBI_NS_LOOKUP	        3	/* look up service name	    */
+#define VBI_NS_REGISTER		1	/* register service name    */
+#define VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define VBI_NS_LOOKUP	        3	/* look up service name	    */
 
-#ifndef	_ASMLANGUAGE
+#ifndef _ASMLANGUAGE
 
 /* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
 
@@ -326,4 +306,4 @@ typedef uint32_t VBI_NS_HANDLE;
 
 #endif	/* _ASMLANGUAGE */
 
-#endif  /* _VBI_SYSCALLS_H */
+#endif	/* _VBI_SYSCALLS_H */
diff --git a/include/vbi/types.h b/include/vbi/types.h
index ef7f001..cd9cc1e 100644
--- a/include/vbi/types.h
+++ b/include/vbi/types.h
@@ -43,11 +43,11 @@ typedef int32_t vbiCore_t;
 typedef int32_t vbiCtx_t;
 typedef uint64_t vbiPhysAddr_t;
 typedef void *vbiGuestPhysAddr_t;
-typedef int32_t vbiStatus_t;		
-typedef int32_t vbiIntState_t;		
-typedef int32_t vbiMemAttr_t;		
-typedef int32_t vbiVector_t;		
-typedef uint32_t vbiIrq_t;		
+typedef int32_t vbiStatus_t;
+typedef int32_t vbiIntState_t;
+typedef int32_t vbiMemAttr_t;
+typedef int32_t vbiVector_t;
+typedef uint32_t vbiIrq_t;
 
 #endif	/* _ASMLANGUAGE */
 
diff --git a/kernel/vbi/interrupt.c b/kernel/vbi/interrupt.c
index c36a75b..02540ed 100644
--- a/kernel/vbi/interrupt.c
+++ b/kernel/vbi/interrupt.c
@@ -50,19 +50,16 @@ vbiIrq_t vbiIntVecFind(char *intName, int32_t intDirection)
 	int32_t num  = config->num_ints;
 	int32_t i;
 
-	for (i = 0; i < num; i++, info++)
-	{
+	for (i = 0; i < num; i++, info++) {
 		if (intDirection != (int32_t)(info->intDirection))
 			continue;
 
 		if (!strncmp((char *)intName, (char *)info->intName,
-				VB_NAMELEN)) {
-
-		        /* Found */
-	        	return (int32_t)info->intNumber;
-	        }
+					VB_NAMELEN)) {
+			/* Found */
+			return (int32_t)info->intNumber;
+		}
 	}
-
 	return VBI_INVALID_IRQ; /* no match */
 }
 
diff --git a/kernel/vbi/io_apic.c b/kernel/vbi/io_apic.c
index 477bb56..37ca33f 100644
--- a/kernel/vbi/io_apic.c
+++ b/kernel/vbi/io_apic.c
@@ -79,11 +79,11 @@ typedef union
 {
 	struct
 	{
-		uint32_t version:8;		/* version identifier */
-		uint32_t reserved1:8;		/* reserved bits */
-		uint32_t maxRedirEntry:8;	/* max number of entries - 1,
-						 * or number of IRQ pins - 1 */
-		uint32_t reserved2:8;		/* reserved bits */
+		uint32_t version:8;	/* version identifier */
+		uint32_t reserved1:8;	/* reserved bits */
+		uint32_t maxRedirEntry:8;/* maximum number of entries - 1, or
+					 * number of IRQ pins - 1 */
+		uint32_t reserved2:8;	/* reserved bits */
 	} field;
 	uint32_t value;
 } VIOAPIC_VERSION;
@@ -96,7 +96,6 @@ typedef union
 		uint32_t reserved:24;	/* reserved bits */
 		uint32_t destination:8;	/* destination field */
 	} field;
-
 	uint32_t value;
 } VIOAPIC_REDIR_HIGH;
 
@@ -108,11 +107,11 @@ typedef union
 		uint32_t deliveryMode:3;/* delivery mode:
 					 * fixed, lowest, SMI, reserved, NMI,
 					 * INIT, reserved, extInt */
-		uint32_t destMode:1;	/* dest mode: 0=physical, 1=logical */
+		uint32_t destMode:1;	/* dest. mode: 0=physical, 1=logical */
 		uint32_t delivStatus:1;	/* delivery status: 0=idle, 1=pending*/
 		uint32_t polarity:1;	/* polarity: 0=high active */
 		uint32_t irr:1;		/* remote IRR (level only): 1 before
-				 	 * LAPIC accepts level, 0 after EOI */
+					 * LAPIC accepts level, 0 after EOI */
 		uint32_t trigger:1;	/* 0=edge, 1=level */
 		uint32_t mask:1;	/* 1=masked */
 		uint32_t reserved:15;	/* reserved bits */
@@ -142,8 +141,6 @@ typedef struct vioapic
  * This routine gets the base address of the VIOAPIC specified in the VB
  * control structure.
  *
- * RETURNS: the base address of the VB VIOAPIC base address
- *
  */
 void *vbiVioapicAddrGet(void)
 {
@@ -157,7 +154,7 @@ void *vbiVioapicAddrGet(void)
  * redirection table. The previous entry in the table is trashed. Before
  * setting the new vector in the entry the user can obtain the previous
  * entry by calling vbiVioapicVectorGet(). The first argument passed to
- * this function represent the index to the VIOAPIC redirection table. The
+ * this function represent the index to the VIOAPIC redirection table.  The
  * second argument is the vector to set in the specified entry.  For Intel
  * architectures when an interrupt is raised the vector determines the
  * Interrupt descriptor table (IDT) entry where the IRQ is delivered.
@@ -175,14 +172,13 @@ vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
 	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
 		return VBI_VIOAPIC_IRQ_OUTBOUND;
 
-	VB_DEBUG_MSG ("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
-	VB_DEBUG_MSG ("Set vector %d: @ 0x%x\n", vioapicBase,
+	VB_DEBUG_MSG("vbiVioapicVectorSet: base @ 0x%x\n", vioapicBase);
+	VB_DEBUG_MSG("Set vector %d: @ 0x%x\n", vioapicBase,
 		 &(pVioapic->entry[irq].value));
 
 	pVioapic->entry[irq].vioapicLow.field.vector = vector;
 
 	return 0;
-
 }
 
 /*
@@ -195,8 +191,6 @@ vbiStatus_t vbiVioapicVectorSet(vbiIrq_t irq, vbiVector_t vector)
  *
  * This routine is currently not supported for PPC
  *
- * RETURNS: vector number or error number in case of failure
- *
  */
 vbiVector_t vbiVioapicVectorGet(vbiIrq_t irq)
 {
@@ -215,8 +209,7 @@ vbiVector_t vbiVioapicVectorGet(vbiIrq_t irq)
 
 	VB_DEBUG_MSG("vbiVioapicVectorGet: vector %d: for irq 0x%x\n", vector, irq);
 
-	return vector ;
-
+	return vector;
 }
 
 /*
@@ -242,8 +235,7 @@ vbiStatus_t vbiVioapicIntUnmask(vbiIrq_t irq)
 	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
 		return VBI_VIOAPIC_IRQ_OUTBOUND;
 
-	return vbiIoapicOp (VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
-	
+	return vbiIoapicOp(VBI_IOAPICIOCTL_UNMASK, irq, 0, 0);
 }
 EXPORT_SYMBOL(vbiVioapicIntUnmask);
 
@@ -270,7 +262,6 @@ vbiStatus_t vbiVioapicIntMask(vbiIrq_t irq)
 	pVioapic->entry[irq].vioapicLow.field.mask = 1;
 
 	return 0;
-
 }
 
 /*
@@ -290,7 +281,7 @@ vbiStatus_t vbiVioapicIntAck(vbiIrq_t irq)
 	if (irq > VIOAPIC_MAX_REDTABLE_ENTRIES-1)
 		return VBI_VIOAPIC_IRQ_OUTBOUND;
 
-	return vbiIoapicOp (VBI_IOAPICIOCTL_EOI, irq, 0, 0);
+	return vbiIoapicOp(VBI_IOAPICIOCTL_EOI, irq, 0, 0);
 }
 
 /*
@@ -323,23 +314,20 @@ vbiStatus_t vbiVioapicIntAck(vbiIrq_t irq)
  * VIOAPIC_SEND_ALL	- Send to the group of virtual boards connected to this
  *                        IRQ include the sender board.
  *
- * VIOAPIC_SEND_OTHERS  - Send to the group of virtual boards connected
+ * VIOAPIC_SEND_OTHERS	- Send to the group of virtual boards connected
  *			  to this IRQ excluding the sender board
  *
- * VIOAPIC_SEND_UNICAST	- Send an interrupt to specified virtual board. This
- *		          will be delivered only if the destination board is
- *                        connected to this IRQ
- *
- * VIOAPIC_SEND_NONE	- Ignore this call.
+ * VIOAPIC_SEND_UNICAST	- Send an interrupt to the specified virtual board. This
+ *			  will be delivered only if the destination board is
+ *			  connected to this IRQ
  *
  *
- * INTERNAL
- * Important!! ignore filter and target arguments for now.
+ * VIOAPIC_SEND_NONE	- Ignore this call.
  *
  */
 vbiStatus_t vbiVioapicIntSend(vbiIrq_t irq, uint32_t filter, vbiVb_t target)
 {
-	return vbiIoapicOp (VBI_IOAPICIOCTL_SEND, irq, filter, target);
+	return vbiIoapicOp(VBI_IOAPICIOCTL_SEND, irq, filter, target);
 }
 EXPORT_SYMBOL(vbiVioapicIntSend);
 
@@ -350,9 +338,8 @@ EXPORT_SYMBOL(vbiVioapicIntSend);
  * within the same virtual board.
  *
  */
-vbiStatus_t vbiVioapicIntRedirect( vbiIrq_t irq, vbiCore_t core)
+vbiStatus_t vbiVioapicIntRedirect(vbiIrq_t irq, vbiCore_t core)
 {
-	/* call interrupt redirect operator */
 	return vbiVcoreIntRed_op(irq, core);
 }
 
@@ -379,7 +366,6 @@ void vbiVioapicDisplay(void)
 	};
 
 	/* get the general virtual I/O APIC info */
-
 	printk("Virtual I/O APIC:\n");
 	printk("  Base address: 0x%p\n", pVioapic);
 	printk("  id:          %d\n", pVioapic->id.field.IOAPIC_id);
@@ -387,7 +373,6 @@ void vbiVioapicDisplay(void)
 	printk("  max entries: %d\n", pVioapic->version.field.maxRedirEntry);
 
 	/* dump the virtual I/O APIC table */
-
 	printk("\nRedirection Table:\n");
 	printk("Entry Vector Mask Status Trig"
 		"  Pol IRR DeliverMode Destination\n");
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index 12d9820..eeade37 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -16,21 +16,22 @@
 
 /*
 
-DESCRIPTION The vbi library (Virtual board interface) provides support
-functionality for software developers who are writing Virtual board
-applications, or as a guide to developers porting an operating system to
-the virtual board environment.  This file contains the generic API that
-architecture independent. Separate documents are provided as supplement
-for APIs tied to a particular hardware architecture platform.
-
-A given system may be composed of multiple VB where each VB may contain
-multiple Cores. During system bring-up stage hypervisor VB manager
-allocates resources specified in the XML configuration file for the each
-VB and initializes the configuration structure. Then the cores are
-launched starting at the entry point specified in the guest payload image.
-Hypervisor passes a pointer of the configuration page and a 32bit flag
-that holds the boot options of the core.  These parameters are passed via
-stack or registers based on the underlying architecture platform.
+DESCRIPTION
+The vbi library (Virtual board interface) provides support functionality for
+software developers who are writing Virtual board applications, or as a guide
+to developers porting an operating system to the virtual board environment.
+This file contains the generic API that architecture independent. Separate
+documents are provided as supplement for APIs tied to a particular hardware
+architecture platform.
+
+A given system may be composed of multiple VB where each VB may contain multiple
+Cores. During system bring-up stage hypervisor VB manager allocates resources
+specified in the XML configuration file for the each VB and initializes the
+configuration structure. Then the cores are launched starting at the entry point
+specified in the guest payload image. Hypervisor passes a pointer of the
+configuration page and a 32bit flag that holds the boot options of the core.
+These parameters are passed via stack or registers based on the underlying
+architecture platform.
 
 
 figure 1.1: A simplified overview diagram of a hypervisor system.
@@ -65,39 +66,36 @@ figure 1.1: A simplified overview diagram of a hypervisor system.
                                              guest/hypervisor
                                               speration line
 
-Once the guest starts running it must call vbiInit() with the save
-parameters passed to it's entry routine which is the base address of the
-configuration.  page. This routine retrieves the control and status page
-page pointers and saves them in the corresponding global variables.
+Once the guest starts running it must call vbiInit() with the save parameters
+passed to it's entry routine which is the base address of the configuration.
+page. This routine retrieves the control and status page page pointers and
+saves them in the corresponding global variables.
 
-If the VMMU is turned on care must be taken to ensure that the memory
-regions below are mapped via the VMMU. It is suggested to treat these
-regions as devices regions where the mapping is flat and the cache
-attribute is guarded.
+If the VMMU is turned on care must be taken to ensure that the memory regions
+below are mapped via the VMMU. It is suggested to treat these regions as
+devices regions where the mapping is flat and the cache attribute is guarded.
 
 A virtual board core is presented by hypervisor with 3 memory areas:
 
 1) Virtual Board Configuration Area
 
-This write protected memory area provides fixed configuration information
-to the virtual board.  The address of this is kept in the global variable
-wrhvConfig.  The address of this area is passed to the virtual board as
-the first parameter when the virtual board is started running at it's boot
-location.
+This write protected memory area provides fixed configuration information to
+the virtual board.  The address of this is kept in the global variable
+wrhvConfig.  The address of this area is passed to the virtual board as the
+first parameter when the virtual board is started running at it's boot location.
 
-2)Virtual Board Status Area
+2) Virtual Board Status Area
 
 This write protected memory area provides data to the virtual board that
 changes due to run-time activity, such as registers saved due to an
 interrupt, timestamps, virtual interrupts etc.  The address of this is
 kept in the global variable wrhvStatus.
 
-3)Virtual Board Control Area
+3) Virtual Board Control Area
 
 This writable memory area is used by the virtual board to communicate
-information to the hypervisor, where they cannot be passed in a faster
-manner.  The address of this area is kept in the global variable
-wrhvControl.
+information to the hypervisor, where they cannot be passed in a faster manner.
+The address of this area is kept in the global variable wrhvControl.
 
 */
 
@@ -110,54 +108,46 @@ struct vb_config *wrhvVbConfig;	/* The address of the core's Config area
 				 * as the first parameter upon startup */
 EXPORT_SYMBOL(wrhvVbConfig);
 
-struct vb_control *wrhvVbControl; /* The address of the core's Control area */
+struct vb_control *wrhvVbControl;/* The address of the core's Control area */
 
-struct vb_status *wrhvVbStatus;  /* The address of the core's Status area */
-
-int32_t wrhvVbIntNested; /* Used by VBI interrupt/exception management */
+struct vb_status *wrhvVbStatus;	/* The address of the core's Status area */
 
+int32_t wrhvVbIntNested;	/* Used by VBI IRQ/exception management */
 
 /*
-* vbiInit - Initialize support for vbi library functions
-*
-* This routine initializes the vbi library
-*
-* The routine should be called before accessing the virtual board configuration
-* data or making any hypercall. The parameters passed to this function should be
-* same as the boot parameters passed to the first executing program in the
-* running core by hypervisor which is a pointer to the core configuration
-* address. This routine retrieves the status and control page from the
-* configuration page and initializes the following global variables for future
-* reference.
-*
-* Configuration page base address is stored in wrhvVbConfig
-* Status page base address is stored in wrhvVbStatus
-* Control page base address is stored in wrhvVbControl
-*
-* The user must ensure that this memory regions are mapped if the MMU is
-* turn-on.
-* A good practice would be to map these regions as devices meaning 1-1
-* translation.
-*
-*/
-
+ * vbiInit - Initialize support for vbi library functions
+ *
+ * This routine initializes the vbi library
+ *
+ * The routine should be called before accessing the virtual board configuration
+ * data or making any hypercall. The parameters passed to this function should
+ * be same as the boot parameters passed to the first executing program in the
+ * running core by hypervisor which is a pointer to the core configuration
+ * address. This routine retrieves the status and control page from the
+ * configuration page and initializes the following global variables for future
+ * reference.
+ *
+ * Configuration page base address is stored in wrhvVbConfig
+ * Status page base address is stored in wrhvVbStatus
+ * Control page base address is stored in wrhvVbControl
+ *
+ * The user must ensure that this memory regions are mapped if the MMU is
+ * turn-on.
+ * A good practice would be to map these regions as devices meaning 1-1
+ * translation.
+ *
+ */
 void vbiInit(struct vb_config *config)
 {
-
-    /*
-     * validate the vbi version; minor and maintenance should be backward
-     * compatible.
-     */
-
-    if (config->major < vbiVersionMajor )
-	{
-	vbiPanic("Invalid vbi version");
-	}	
-
-    /* Init global variables for config, status and control structures */
-
-    wrhvVbConfig    = config;
-    wrhvVbControl   = wrhvVbConfig->vbControl;
-    wrhvVbStatus    = wrhvVbConfig->vbStatus;
+	/*
+	 * validate the vbi version; minor and maintenance should be backward
+	 * compatible.
+	 */
+	if (config->major < vbiVersionMajor)
+		vbiPanic("Invalid vbi version");
+
+	wrhvVbConfig = config;
+	wrhvVbControl = wrhvVbConfig->vbControl;
+	wrhvVbStatus = wrhvVbConfig->vbStatus;
 
 }
diff --git a/kernel/vbi/msg.c b/kernel/vbi/msg.c
index 3703607..9408df6 100644
--- a/kernel/vbi/msg.c
+++ b/kernel/vbi/msg.c
@@ -23,13 +23,12 @@
 /*
  * vbiReceive - Receive a message from another context
  *
- * This routine makes a hypercall and waits for a message to be received
- * from another context. It blocks until a message is received. This
- * operation may be aborted if an interrupt is delivered to the waiting
- * Virtual board. If the "flags" field in the control structure passed to
- * this function is set to be VBI_MSG_CTL_FLAG_RETRY the receive operation
- * will be retried in case it was aborted before the expected message was
- * received successfully.
+ * This routine makes a hypercall and waits for a message to be received from
+ * another context. It blocks until a message is received. This operation may
+ * be aborted if an interrupt is delivered to the waiting Virtual board. If the
+ * "flags" field in the control structure passed to this function is set to be
+ * VBI_MSG_CTL_FLAG_RETRY the receive operation will be retried in case it was
+ * aborted before the expected message was received successfully.
  *
  */
 
@@ -49,7 +48,7 @@ vbiStatus_t vbiReceive(void *rmsg, uint32_t rlen, VBI_MSG_INFO *info,
 		/* if retry flag is set _AND_ msg was aborted, retry */
 		if (info->error != VBI_MSG_ERROR_ABORTED)
 			break;
-	
+
 		DEBUGM("%s aborted, retrying \n", __FUNCTION__);
 	}
 	return retval;
diff --git a/kernel/vbi/ns.c b/kernel/vbi/ns.c
index 089b91e..1a3cf1f 100644
--- a/kernel/vbi/ns.c
+++ b/kernel/vbi/ns.c
@@ -29,13 +29,6 @@ for processing.
 #include <vbi/vbi.h>
 #include <vbi/private.h>
 
-
-/* enable/disable debugging */
-
-/*
- * #define DEBUG  define DEBUG to turn on debugging
- */
-
 #ifdef DEBUG
 #define DEBUGM(fmt, args...)    printk(fmt, ##args)
 #else
@@ -55,7 +48,7 @@ vbiStatus_t vbiNsRegister(char *name, uint32_t revision)
 	if (name == NULL)
 		return -1;
 
-	return vbiNsOp (VBI_NS_REGISTER, name, revision, NULL);
+	return vbiNsOp(VBI_NS_REGISTER, name, revision, NULL);
 }
 
 /*
@@ -71,7 +64,7 @@ vbiStatus_t vbiNsUnregister(char *name, uint32_t revision)
 	if (name == NULL)
 		return -1;
 
-	return vbiNsOp (VBI_NS_UNREGISTER, name, revision, NULL);
+	return vbiNsOp(VBI_NS_UNREGISTER, name, revision, NULL);
 }
 
 /*
@@ -80,11 +73,12 @@ vbiStatus_t vbiNsUnregister(char *name, uint32_t revision)
  * This routine uses the naming system to look up the context id of the
  * provider of the specified service.  A message for the request is
  * formulated and sent off to the name service manager for processing.
+ *
  */
 vbiStatus_t vbiNsLookup(char *name, uint32_t revision, VBI_NS_HANDLE *handle)
 {
 	if (name == NULL || handle == NULL)
 		return -1;
 
-	return  vbiNsOp (VBI_NS_LOOKUP , name, revision, handle);
+	return vbiNsOp(VBI_NS_LOOKUP , name, revision, handle);
 }
diff --git a/kernel/vbi/paddr.c b/kernel/vbi/paddr.c
index 8529efe..0367eb5 100644
--- a/kernel/vbi/paddr.c
+++ b/kernel/vbi/paddr.c
@@ -23,8 +23,6 @@ vbiGuestPhysToPhysAddr is used to return an absolute physical address to used
 perhaps to communicate with the hypervisor itself maybe buffer pointers.
 */
 
-/* includes */
-
 #include <linux/types.h>
 #include <vbi/private.h>
 
@@ -40,10 +38,9 @@ perhaps to communicate with the hypervisor itself maybe buffer pointers.
  *
  */
 vbiStatus_t vbiGuestPhysToPhysAddr(vbiGuestPhysAddr_t gaddr,
-					 vbiPhysAddr_t  *paddr)
+					vbiPhysAddr_t *paddr)
 {
-    /* use the hypervisor ioctl system call to do the translation */
-    return  vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 );
+	return vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, (void*)VBI_HYIOCTL_PADDR_PHYS, 0 );
 }
 
 /*
@@ -55,10 +52,7 @@ vbiStatus_t vbiGuestPhysToPhysAddr(vbiGuestPhysAddr_t gaddr,
  * running with > 4GB memory so the phys address is always 64-bit.
  *
  */
-vbiStatus_t vbiGuestDmaAddrGet(vbiGuestPhysAddr_t gaddr,
-					vbiPhysAddr_t *paddr)
+vbiStatus_t vbiGuestDmaAddrGet(vbiGuestPhysAddr_t gaddr, vbiPhysAddr_t *paddr)
 {
-
-	/* use the hypervisor ioctl system call to do the translation */
-    	return vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0);
+	return vbiHyIoctl(VBI_HYIOCTL_PADDR, gaddr, paddr, VBI_HYIOCTL_PADDR_DMA, 0);
 }
diff --git a/kernel/vbi/shmem.c b/kernel/vbi/shmem.c
index 5049120..30afff4 100644
--- a/kernel/vbi/shmem.c
+++ b/kernel/vbi/shmem.c
@@ -41,31 +41,29 @@ Alternatively the following macros can be used to obtained similar information
 #include <vbi/private.h>
 
 /*
-* vbiShmemRegionFind - locate the shared memory parameters for a given region
-*
-* This function finds the shared memory region associated with the name
-* specified. The first argument to this function indicates the name of the
-* shared to find. If this region exists in the list of configured regions the
-* address, length and MMU attributes are set in the pointers passed in as
-* arguments.
-*
-*/
+ * vbiShmemRegionFind - locate the shared memory parameters for a given region
+ *
+ * This function finds the shared memory region associated with the name
+ * specified. The first argument to this function indicates the name of the
+ * shared to find. If this region exists in the list of configured regions the
+ * address, length and MMU attributes are set in the pointers passed in as
+ * arguments.
+ *
+ */
 vbiStatus_t vbiShmemRegionFind(int8_t *smName, void **addr,
-				 uint32_t *length, uint32_t *attr)
+				uint32_t *length, uint32_t *attr)
 {
 	struct vb_config *config = VBI_CONFIG_ADDR_GET();
 	struct vb_sm_info *info = config->sharedMemoryRegionsConfigAddress;
 	int32_t num = config->num_sm;
 	int32_t i;
 
-	for (i = 0; i < num; i++, info++)
-        {
-		if (!strncmp((char *)smName, (char *)info->name,
-				VB_NAMELEN)) {
+	for (i = 0; i < num; i++, info++) {
+		if (!strncmp((char *)smName, (char *)info->name, VB_NAMELEN)) {
 			/* Found */
-			*addr   = info->addr;
+			*addr = info->addr;
 			*length = info->length;
-			*attr   = info->attr;
+			*attr = info->attr;
 			return 0;
 		}
 	}
@@ -75,47 +73,43 @@ vbiStatus_t vbiShmemRegionFind(int8_t *smName, void **addr,
 EXPORT_SYMBOL(vbiShmemRegionFind);
 
 /*
-* vbiMemRegionFind - locate the memory parameters for a given region
-*
-* This function finds the memory region associated with the name specified.
-* The first argument to this function indicates the name of the memory to find
-* If this region exists in the list of configured regions the address,
-* length and MMU attributes are set in the pointers passed in as
-* arguments.
-*
-*/
-
+ * vbiMemRegionFind - locate the memory parameters for a given region
+ *
+ * This function finds the memory region associated with the name specified.
+ * The first argument to this function indicates the name of the memory to find
+ * If this region exists in the list of configured regions the address,
+ * length and MMU attributes are set in the pointers passed in as
+ * arguments.
+ *
+ */
 vbiStatus_t vbiMemRegionFind(int8_t *name, void **addr,
-				 uint32_t *length, uint32_t *attr)
+				uint32_t *length, uint32_t *attr)
 {
 	struct vb_config *config = VBI_CONFIG_ADDR_GET();
 	struct vb_mem_info *info = config->memoryRegionsConfigAddress;
-	int32_t num  = config->num_mem;
+	int32_t num = config->num_mem;
 	int32_t i;
 
-	for (i = 0; i < num; i++, info++)
-	{
-		if (!strncmp((char *)name, (char *)info->name,
-			VB_NAMELEN)) {
+	for (i = 0; i < num; i++, info++) {
+		if (!strncmp((char *)name, (char *)info->name, VB_NAMELEN)) {
 			/* Found */
-			*addr   = info->addr;
+			*addr = info->addr;
 			*length = info->length;
-			*attr   = info->attr;
+			*attr = info->attr;
 			return 0;
 		}
 	}
 	*addr = 0;
-
 	return VBI_INVALID_SHMEM;
 }
 
 /*
-* vbiCorePrvMemFind - locate the private memory for a core
-*
-* This function gets the base address of the private memory region assigned to
-* the running core.
-*
-*/
+ * vbiCorePrvMemFind - locate the private memory for a core
+ *
+ * This function gets the base address of the private memory region assigned to
+ * the running core.
+ *
+ */
 vbiStatus_t vbiCorePrvMemFind(void **addr, size_t *length)
 {
 	*addr = (void *)VBI_VCORE_PRIVMEM_BASE_GET();
-- 
1.6.5.2

