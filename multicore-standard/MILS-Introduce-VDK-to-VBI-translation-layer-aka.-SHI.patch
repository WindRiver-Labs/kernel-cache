From 07f26b2af183820e0bf9e186c6e160d2443cdcda Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Thu, 26 Nov 2009 12:16:52 -0800
Subject: [PATCH] MILS: Introduce VDK to VBI translation layer (aka. SHIM)

The MILS hypervisor is coded to a slightly different ABI than
the WR VBI 2.0 specification currently used by the Linux guest OS.
The addition of this mapping between the two ABI allows the Linux
guest OS to be used on the MILS hypervisor.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/x86/kernel/vbi/Makefile       |    4 +
 arch/x86/kernel/vbi/vdk_syscalls.S |   35 +++
 drivers/serial/serial_core.c       |    7 +
 include/vbi/interface.h            |    4 +
 include/vbi/interrupt.h            |    7 +
 include/vbi/syscalls.h             |    5 +-
 include/vbi/vbi.h                  |    6 +
 include/vbi/vdk_interface.h        |  521 ++++++++++++++++++++++++++++++++++++
 include/vbi/vdk_syscalls.h         |  392 +++++++++++++++++++++++++++
 init/Kconfig.wrhv                  |    9 +
 kernel/vbi/Makefile                |    6 +-
 kernel/vbi/lib.c                   |    2 +
 12 files changed, 995 insertions(+), 3 deletions(-)
 create mode 100644 arch/x86/kernel/vbi/vdk_syscalls.S
 create mode 100644 include/vbi/vdk_interface.h
 create mode 100644 include/vbi/vdk_syscalls.h

diff --git a/arch/x86/kernel/vbi/Makefile b/arch/x86/kernel/vbi/Makefile
index 79a6269..a25ef58 100644
--- a/arch/x86/kernel/vbi/Makefile
+++ b/arch/x86/kernel/vbi/Makefile
@@ -4,6 +4,10 @@
 
 obj-y		= wrhv.o wrhv_initrd.o syscalls.o
 
+ifeq ($(CONFIG_WRHV_MILS),y)
+obj-y	+= vdk_syscalls.o
+endif
+
 # wrhv embeds an initrd in the vmlinux
 $(obj)/wrhv_initrd.o: FORCE
 	@ $(AS) $(srctree)/$(src)/wrhv_initrd.S -o $@
diff --git a/arch/x86/kernel/vbi/vdk_syscalls.S b/arch/x86/kernel/vbi/vdk_syscalls.S
new file mode 100644
index 0000000..274594b
--- /dev/null
+++ b/arch/x86/kernel/vbi/vdk_syscalls.S
@@ -0,0 +1,35 @@
+/*
+ * vdk_syscalls.S - hypervisor system calls
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#define _ASMLANGUAGE
+
+#include <asm/reg_vbi.h>
+#include <asm/vbi.h>
+#include <vbi/syscall.h>
+
+/* globals */
+.globl vdk_virt_to_phys
+.text
+.balign 16
+
+#define VBI_STACK_FRAME_SIZE	4
+
+vdk_virt_to_phys:
+        movl $VDK_SYS_virtToPhys, %eax
+        push $2
+        vmcall
+        addl $VBI_STACK_FRAME_SIZE, %esp
+        ret
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 7547e94..bcdc4b1 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2152,6 +2152,13 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 {
 	char address[64];
 
+#ifdef CONFIG_WRHV_MILS
+if(port->irq != 0) {
+	/* Everything in the MILS world has to be polled */
+	printk(" WRHV MILS: invalid uart IRQ#%d requested, adjusting\n",port->irq);
+	port->irq = 0;
+}
+#endif
 	switch (port->iotype) {
 	case UPIO_PORT:
 		snprintf(address, sizeof(address),
diff --git a/include/vbi/interface.h b/include/vbi/interface.h
index 51754d4..a78e221 100644
--- a/include/vbi/interface.h
+++ b/include/vbi/interface.h
@@ -80,6 +80,9 @@ identity mapped.
 
 */
 
+#ifdef CONFIG_WRHV_MILS
+#include <vbi/vdk_interface.h>
+#else
 #ifndef _VBI_INTERFACE_H
 #define _VBI_INTERFACE_H
 
@@ -583,3 +586,4 @@ struct vb_config
 
 #endif /*_ASMLANGUAGE */
 #endif  /* _VBI_INTERFACE_H */
+#endif /* ! CONFIG_WRHV_MILS */
diff --git a/include/vbi/interrupt.h b/include/vbi/interrupt.h
index b5c5fc0..3f3bed2 100644
--- a/include/vbi/interrupt.h
+++ b/include/vbi/interrupt.h
@@ -26,7 +26,14 @@ interrupts configuration data.
 
 #ifndef	_ASMLANGUAGE
 
+#ifdef CONFIG_WRHV_MILS
+static inline uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir)
+{
+	return VBI_INVALID_IRQ;
+}
+#else
 extern uint32_t vbi_find_irq(char *irq_name, int32_t irq_dir);
+#endif /* CONFIG_WRHV_MILS */
 
 #endif /* _ASMLANGUAGE */
 
diff --git a/include/vbi/syscalls.h b/include/vbi/syscalls.h
index ab61c84..33396ff 100644
--- a/include/vbi/syscalls.h
+++ b/include/vbi/syscalls.h
@@ -14,7 +14,7 @@
  *
  */
 
-#ifndef _VBI_SYSCALLS_H
+#if !defined(_VBI_SYSCALLS_H) && !defined(CONFIG_WRHV_MILS)
 #define _VBI_SYSCALLS_H
 
 /*
@@ -312,4 +312,7 @@ typedef uint32_t VBI_NS_HANDLE;
 
 #endif	/* _ASMLANGUAGE */
 
+#else
+#include <vbi/vdk_syscalls.h>
+
 #endif	/* _VBI_SYSCALLS_H */
diff --git a/include/vbi/vbi.h b/include/vbi/vbi.h
index fcc765b..6ff2a65 100644
--- a/include/vbi/vbi.h
+++ b/include/vbi/vbi.h
@@ -85,8 +85,14 @@ various data structures.
  * vbi_unmask_vioapic_irq()
  *
  */
+
+#ifndef CONFIG_WRHV_MILS
 #define VBI_VIOAPIC_BASE_GET()		\
         (VBI_CNTRL_ADDR_GET()->vIoapic)
+#else
+#define VBI_VIOAPIC_BASE_GET() 		\
+	(return NULL)
+#endif
 
 /* VMMU0 and VMMU1 tables for context switch access macro's */
 #define VBI_VMMU0_GET()                   \
diff --git a/include/vbi/vdk_interface.h b/include/vbi/vdk_interface.h
new file mode 100644
index 0000000..a242f71
--- /dev/null
+++ b/include/vbi/vdk_interface.h
@@ -0,0 +1,521 @@
+/*
+ * vdk_interface.h - virtual board interface header file
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+
+#if !defined(_VDK_INTERFACE_H) && defined(CONFIG_WRHV_MILS)
+#define _VDK_INTERFACE_H
+
+#include <linux/linkage.h>
+#include <asm/page.h>
+#include <vbi/types.h>
+#include <vbi/arch.h>
+
+
+/* VB versioning information */
+#define	VBI_VERSION_MAJOR	1	/* major version */
+#define	VBI_VERSION_MINOR	2	/* minor version */
+#define	VBI_VERSION_MAINT	0	/* maintenance version */
+
+/* macro to align guest fields for a 64-bit hypervisor */
+#if defined(LP64)
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			   __attribute__(( aligned(8) )) \
+			   decl_var
+#else
+#if (__VBI_BYTE_ORDER == __VBI_LITTLE_ENDIAN)
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    decl_var; \
+			    uint32_t pad_var
+#else
+#define VB_ALIGN_FIELD_64(decl_var, pad_var)	\
+			    __attribute__(( aligned(8) )) \
+			    uint32_t pad_var; \
+			    decl_var
+#endif
+#endif
+
+#undef VB_DEBUG  /* define it to turn on debugging */
+#ifdef VB_DEBUG
+#define VB_DEBUG_MSG(fmt, args...)    printk(fmt, ##args)
+#else
+#define VB_DEBUG_MSG(fmt, args...)
+#endif
+
+
+/* Configuration Filename for the hypervisor this must not change */
+#define VB_WRHV_CONFIGURATION_FILE "milsKernel.xml"
+
+/* Hard limits for now */
+#define VB_MAX_VIRTUAL_BOARDS		1024
+#define VB_MAX_BUSES			1024
+
+#define VB_MAX_CORES			8
+
+/* Type definitions for all name identifer strings in the hypervisor */
+#define VB_NAMELEN		64
+
+#ifndef	_ASMLANGUAGE
+
+#define VB_MAX_BOOTLINE_LENGTH		256
+
+#endif
+
+/* Virtual Interrupt Controller definitions */
+
+/*
+ * 32 is chosen as the maximum number of interrupt sources allowed.
+ * care must be taken if this is changed, since some algorithms and
+ * data structures will require modifications and become more complex
+ */
+#define VB_MAX_INTERRUPTS		32
+
+#define VIOAPIC_MAX_REDTABLE_ENTRIES	VB_MAX_INTERRUPTS
+
+/*
+ * The maximum number of associated data stored with each interrupt.
+ * This can be modified without any impacts, tho it should not be
+ * set to 0
+ */
+#define VB_MAX_INTERRUPT_DATA		16
+
+/* Structure offsets for assembler */
+#if !defined(_WRHV_ARCH_HAS_CTRL_REGS)
+#define VB_CONTROL_REG_STRUCT_END	0
+#endif
+
+#define VB_CONTROL_INT_DISABLE		((4*0) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_NEW_INT_DISABLE	((4*1) + VB_CONTROL_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_CONTROL_VMMU0_HIGH		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#else
+#define VB_CONTROL_VMMU0		((4*2) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU0_HIGH		((4*3) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1		((4*4) + VB_CONTROL_REG_STRUCT_END)
+#define VB_CONTROL_VMMU1_HIGH		((4*5) + VB_CONTROL_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Bit Mask definitions for VB_STATUS_INT_PENDING */
+#define VB_STATUS_INT_PENDING_INT	1	/* Interrupt controller */
+#define VB_STATUS_INT_PENDING_TICK	2	/* Tick interrupt */
+
+/* Assembler offsets for vb_status */
+#if !defined(_WRHV_ARCH_HAS_STATUS_REGS)
+#define VB_STATUS_REG_STRUCT_END	0
+#endif
+
+#define VB_STATUS_INT_PENDING		((4*0) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_RESERVED1		((4*1) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_HIGH	((4*2) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_TIMESTAMP_LOW		((4*3) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_OLD_INT_DISABLE	((4*4) + VB_STATUS_REG_STRUCT_END)
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_STATUS_VMMU0_HIGH		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*8) + VB_STATUS_REG_STRUCT_END)
+#else
+#define VB_STATUS_VMMU0		((4*5) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU0_HIGH		((4*6) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1		((4*7) + VB_STATUS_REG_STRUCT_END)
+#define VB_STATUS_VMMU1_HIGH		((4*8) + VB_STATUS_REG_STRUCT_END)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Assembler offsets for vb_config */
+#if (__VBI_BYTE_ORDER == __VBI_BIG_ENDIAN)
+#define VB_CONFIG_VBSTATUS		(((2+0) * 8) + 4)
+#define VB_CONFIG_VBCONTROL		(((2+1) * 8) + 4)
+#define VB_CONFIG_SMINFO		(((2+2) * 8) + 4)
+#define VB_CONFIG_MEMINFO		(((2+3) * 8) + 4)
+#define VB_CONFIG_INTINFO		(((2+4) * 8) + 4)
+#else
+#define VB_CONFIG_VBSTATUS		((2+0) * 8)
+#define VB_CONFIG_VBCONTROL		((2+1) * 8)
+#define VB_CONFIG_SMINFO		((2+2) * 8)
+#define VB_CONFIG_MEMINFO		((2+3) * 8)
+#define VB_CONFIG_INTINFO		((2+4) * 8)
+#endif /* __VBI_BYTE_ORDER */
+
+/* Defines for vbIntInfo intDirection field */
+#define VB_INPUT_INT	1
+#define VB_OUTPUT_INT	2
+
+/*
+ * Defines for the second parameter passed to the startup program
+ * in a virtual board by the hypervisor.
+ */
+#define VB_BOOT_COLD	1
+#define VB_BOOT_WARM	2
+#define VB_BOOT_RESTART	3
+
+#ifndef VB_VIOAPIC_ENTRIES_SIZE
+#define VB_VIOAPIC_ENTRIES_SIZE 64
+#endif
+
+#ifndef	_ASMLANGUAGE
+
+/* Type definitions for all name identifer strings in hypervisor */
+#define VB_MAX_WRHV_NAME_LENGTH 64
+typedef char VB_WRHV_NAME[VB_MAX_WRHV_NAME_LENGTH];
+
+#define VB_MAX_EXCEPTION_TYPES	32
+#define MAX_NAME_LENGTH 80
+
+typedef struct portConfig
+{
+    UINT32              id;                    /* unique port ID                   */
+    unsigned char     * buf;                   /* port payload buffer vaddr        */
+    UINT32              bufAttr;               /* port payload buffer attribute    */
+    char                name[MAX_NAME_LENGTH]; /* port name                        */
+    UINT32              vbId;                  /* parent vb                        */
+    UINT32              moduleId;              /* parent module                    */
+    UINT32              inChannel;             /* in channel                       */
+    UINT32              outChannel;            /* out channel                      */
+    PORT_DIRECTION_TYPE direction;             /* SOURCE or DESTINATION            */
+    PORT_MODE_TYPE      mode;                  /* QUEUING or SAMPLING              */
+    PORT_PROTOCOL_TYPE  protocol;              /* RECEIVER_DISCARD or SENDER_BLOCK */
+    UINT32              msgSize;               /* max. message size (PAGE_ALIGNED) */
+    UINT32              numMsgs;               /* max. capacity for queuing ports  */
+} PORT_CONFIG;
+
+typedef struct partPortConfig
+{
+    UINT32              numPorts;
+    PORT_CONFIG         portInfo[];
+} PART_PORT_CONFIG;
+
+typedef struct portConfig VB_PORT_INFO;
+typedef struct portStatus VB_PORT_STATUS;
+
+typedef struct vb_log_cfg
+{
+    signed long recordSize;      /* size of each record entry */
+    signed long maxRecords;      /* maximum number of log records */
+} VB_LOG_CFG;
+
+/* Info for the memory map info */
+struct vb_mem_info
+{
+    VB_WRHV_NAME name;   /* The name of the shared memory region */
+    void *        addr;   /* The vbphysical address of the region */
+    unsigned int  length; /* The length in bytes of the region */
+    unsigned int  attr;   /* The arch specific MMU attributes of the region */
+    unsigned int  type;   /* padding */
+};
+
+typedef enum log_state
+{
+   /* Log types - first code must be non zero
+    * and all types will use a hamming distance of 2.
+    */
+   LOG_OK   = 0x00000101,
+   LOG_FULL = 0x00000102,
+} LOG_STATE;
+
+/* Log types (so far only three types) */
+
+typedef enum log_type
+{
+   /* Log types - first code must be non zero
+    * and all types will use a hamming distance of 2.
+    */
+   LOG_TYPE_TRUSTED_BOOT = 0x00000101,	 /* Trusted Boot trace log */
+   LOG_TYPE_SEC_AUDIT    = 0x00000102,	 /* Security Audit event log */
+   LOG_TYPE_SAFETY       = 0x00000104    /* Safety Critical event log: */
+} LOG_TYPE;
+
+typedef struct vb_log_status
+{
+    LOG_STATE   logState;        /* State of log: overrun or not */
+    signed long numRecords;      /* number of records in log */
+    signed long logOverwrite;    /* overwritten entry */
+    signed long numOverwrites;   /* number of overwrites occured */
+    signed long lastCollectedVb; /* used by collection VB */
+} VB_LOG_STATUS;
+
+
+/* Status information about one interrupt */
+typedef struct vbInterruptLevel
+{
+    uint64_t       timeStamp;    /* Time when last interrupt delivered here */
+    unsigned long  numInts;      /* How many interrupts since last delivered */
+    unsigned long  numIntData;   /* How many data elements have been stored */
+    unsigned long  intData[VB_MAX_INTERRUPT_DATA];
+} VB_INTERRUPT_LEVEL;
+
+/* The virtual interrupt controller, with individual interrupt sources */
+typedef struct vbInterruptController
+{
+    unsigned long      intPending; /* Which interrupts are pending
+                                    * high order bit (value 0x80000000)
+                                    * is int #0
+                                    */
+    VB_INTERRUPT_LEVEL intLevel[VB_MAX_INTERRUPTS];
+} VB_INTERRUPT_CONTROLLER;
+
+
+
+/* Configuration information for one interrupt */
+struct vb_int_info
+{
+    VB_WRHV_NAME  irq_name;      /* The name for this interrupt */
+    unsigned short irq_dir;      /* INPUT_INT or OUTPUT_INT */
+    unsigned short irq_num;      /* The interrupt number to be used by the vb*/
+    unsigned short irq_core;     /* the receiving core for this incomming int */
+};
+
+
+/* time donation status */
+
+typedef struct td_status
+{
+    unsigned int  clientTwId;    /* active client TW object ID */
+    unsigned int  clientPortId;  /* port ID associated to client TW */
+    unsigned int  serverTwId;    /* active server TW object ID */
+    unsigned int  serverPortId;  /* port ID associated to server TW */
+} TD_STATUS;
+
+
+/* Do not change the order of these fields */
+struct vb_status
+{
+    unsigned int irq_pend_type; /* 0: Bits indicating which interrupts are pending */
+
+    /* reserved field for future use, required for timeStamp alignment */
+    unsigned long reserved1; /* 1: */
+
+    /* Timestamp when last interrupt was delivered */
+    uint64_t timeStamp;  /* 2-3:    64 bits*/
+
+    /* Interrupt registers
+     *
+     * When hypervisor interrupts a virtual board, it saves information here
+     * to be read by the virtual board software.
+     */
+
+    /* value of control->intDisable at time of the interrupt.
+     * control->intDisable is set to -1 by WRHV at the time of delivery of
+     * the interrupt
+     */
+    unsigned long prev_irq_disable;                /*  4: */
+
+    /* VMMU tables which were active when an MMU exception occurred */
+
+    void *vmmu0;                                /* 5: */
+    void *vmmu1;                                /* 6: */
+
+    /* current schedule status */
+    unsigned long currentSchedule;              /* 7: */
+    unsigned long currentTimeSlice;             /* 8: */
+    unsigned long remainingTicks;               /* 9: */
+
+    /* Location in vbPhyscial memory of the virtual interrupt controller */
+
+    VB_INTERRUPT_CONTROLLER * vbInterruptController;  /* 10: */
+    VB_PORT_STATUS *          portStatus;             /* 11: port status */
+
+    VB_LOG_STATUS secAuditLogStatus; /* 12-16: Security Audit Event log status */
+    VB_LOG_STATUS safetyLogStatus;   /* 17-21: Safety Critical Event log status */
+    TD_STATUS     tdStatus;          /* 22-25: time donation status */
+    unsigned long tick_count;    /* how many ticks VB should have received */
+};
+
+/*
+ * ----------------------- VIRTUAL BOARD CONTROL PAGE -----------------------
+ *
+ * Read/write page used as a communication channel from the VB to hypervisor.
+ *
+ * Any information that cannot be passed in machine registers from the
+ * virtual board to hypervisor are passed in this structure.
+ *
+ * Also state communication from the virtual board to wrhv (such as
+ * disabling all interrupts) uses this page
+ *
+ */
+
+/* Do not change the order of these fields */
+
+struct vb_control
+{
+    unsigned long irq_disable;	/*  0: -1 => Disable all interrupts */
+    unsigned long next_irq_disable;/*  1: New value for vbControl->intDisable */
+
+    void *        vmmu0;	/*  2: VMMU 0 table for context switch */
+    void *        vmmu1;	/*  3: VMMU 1 table for context switch */
+
+    unsigned long level_irq_disable; /* TBD interrupt level enabling */
+    unsigned long vIoapic;  /* filler */
+};
+
+
+
+/* Information about a shared memory region */
+struct vb_sm_info
+{
+    VB_WRHV_NAME  name;   /* The name of the shared memory region */
+    void *         addr;   /* The vbphysical address of the region */
+    unsigned int   length; /* The length in bytes of the region */
+    unsigned int   attr;   /* The arch specific MMU attributes of the region */
+    unsigned int   type;   /* TBD shared memory type field */
+    unsigned int * BoardIds; /* TBD board IDS connected */
+};
+
+/* info for IO port region */
+typedef struct vb_io_port_info
+{
+    VB_WRHV_NAME      name;   /* The name of the shared memory region */
+    unsigned int       port;   /* unique port addr                   */
+    unsigned int       size;   /* port addr size */
+} VB_IOPORT_INFO;
+
+
+/*
+ * Fixed information about the configuration of a Virtual Board as seen by
+ * the Virtual Board itself.  The address of this structure is passed as the
+ * first parameter to the virtual board when it is started at its entry point.
+ */
+struct vb_config
+{
+    unsigned int  sizeConfig;  /* The size in pages of the configuration area */
+    int           boardID;     /* partition ID from the XML configuration */
+
+    unsigned int  sizeStatus;  /* effective size of vbStatus */
+    struct vb_status *vb_status;    /* Read only status */
+    unsigned int  sizeControl; /* effective size of vbControl */
+    struct vb_control *vb_control;   /* Read Write area */
+    int           supervisoryMode; /* Is this board is privileged mode? */
+
+    char board_name[VB_NAMELEN];   /* The name of this board */
+    unsigned int  partitionType;  /* TBD field */
+    unsigned int  phys_mem_size; /* The vbPhysical size of RAM */
+    unsigned int  mem_alias_addr;	/* address to which memory is aliased */
+    unsigned int  mem_alias_size;	/* size of aliases memory */
+    void *        reset_pc;              /* partition reset vector */
+
+    /* The frequency of the periodic tick interrupt */
+
+    unsigned int  tick_freq; /* Ticks per second */
+
+    /* The frequency of the timestamp */
+
+    unsigned int  stamp_freq; /* Ticks per second */
+
+    /* Interrupt configuration of this board */
+
+    unsigned int  num_ints;    /* Number of interrupt configurations */
+    struct vb_int_info *interruptConfiguration; /* Configuration location */
+
+    /* Shared memory configuration information */
+
+    unsigned int  num_sm;     /* Number of shared memory regions */
+    struct vb_sm_info *sharedMemoryRegionsConfigAddress; /* config info */
+
+    /* Shared memory state information */
+
+    void *        sharedMemoryRegionsStateAddress;
+
+    /* Memory map configuration for this virtual board */
+
+    unsigned int  num_mem;     /* Number of memory regions */
+    struct vb_mem_info *memoryRegionsConfigAddress; /* configuration info */
+
+    /* IO port region for the virtual board */
+    unsigned int     numIoPortRgn;     /* number of io port regions */
+    VB_IOPORT_INFO * vbIoPortRgn;      /* IO port Region Info  array*/
+
+    int           numExc;     /* how many exceptions to forward to VB */
+    unsigned int  exceptions [VB_MAX_EXCEPTION_TYPES]; /* forward EXC list */
+
+    /* OS specific boot line */
+
+    char	  bootLine[VB_MAX_BOOTLINE_LENGTH];
+
+    /* partition cache mode */
+
+    unsigned int  cacheMode;
+
+    unsigned int   numPorts;  /* number of ports defined for the VB */
+    VB_PORT_INFO * portInfo;  /* port configuration and status */
+
+    VB_LOG_CFG      secAuditLogCfg;
+    VB_LOG_CFG      safetyLogCfg;
+    int		    coreId;  /* Just a filler since MILS can only run on 1 core */
+    int             corePrivateSize; /* Just another filler */
+    VB_ALIGN_FIELD_64 (void *corePrivate, pad8);
+    int		    pid;   /*filler */
+    int		    board_type; /* filler*/
+
+};
+
+/* IOAPIC and IRQ chip stubs */
+static inline int32_t vbi_send_vcore_vioapic_irq (uint32_t irq,
+	uint32_t vcoreSet, uint32_t options)
+{
+	return 0;
+}
+
+static inline int32_t vbi_mask_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline void vbi_idle(uint64_t timeStamp)
+{
+}
+
+static inline int32_t vbi_set_vioapic_vec(uint32_t irq, int32_t vector)
+{
+	return 0;
+}
+
+static inline int32_t vbi_get_vioapic_vec(uint32_t irq)
+{
+	return 0;
+}
+
+static inline int32_t vbi_unmask_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline int32_t vbi_ack_vioapic_irq(uint32_t irq)
+{
+	return 0;
+}
+
+static inline int32_t vbi_send_vioapic_irq(uint32_t irq, uint32_t filter,
+                                     uint32_t vb)
+{
+	return 0;
+}
+
+static inline int32_t vbi_redir_vioapic_irq(uint32_t irq, int32_t tCore)
+{
+	return 0;
+}
+
+extern asmlinkage int vdk_virt_to_phys (void * pVirtAddr, void *pPaddr);
+
+static inline int32_t vbi_get_guest_dma_addr(void *gaddr, uint64_t *paddr)
+{
+	return vdk_virt_to_phys(__va(gaddr), paddr);
+}
+#endif /*_ASMLANGUAGE */
+#endif  /* _VDK_INTERFACE_H */
+
diff --git a/include/vbi/vdk_syscalls.h b/include/vbi/vdk_syscalls.h
new file mode 100644
index 0000000..f199d8b
--- /dev/null
+++ b/include/vbi/vdk_syscalls.h
@@ -0,0 +1,392 @@
+/*
+ * vdk_syscalls.h - MILS VDK hypervisor system calls
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#ifndef _VDK_SYSCALLS_H
+#define _VDK_SYSCALLS_H
+
+/*
+ * System call number encoding:
+ *
+ * 31                                                                        0
+ *
+ *  |               |               |        |               |               |
+ *  +---------------+---------------+        +---------------+---------------+
+ *  | | | | | | | | | | | | | | | | | ...... | | | | | | | | | | | | | | | | |
+ *  +---------------+---------------+        +---------------+---------------+
+ *   ^ ^ ^         ^ ^                                                      ^
+ *   | | \--------/  \------------------------------------------------------/
+ *   | |      |                                |
+ *   | |      |                                |
+ *   | |      |                                +-- System call number
+ *   | |      |
+ *   | |      +-- Fast hypervisor system call number
+ *   | |
+ *   | +--------- Hypervisor system call
+ *   |
+ *   +----------- Fast hypervisor system call
+ *
+ *
+ *
+ *
+ */
+
+/* fast system call numbers handled by assembler code */
+#define HY_FAST_SYSCALL_MASK	0x3f000000
+#define HY_FAST_SYSCALL_SHIFT	24
+#define HY_FAST_SYSCALL_BIT	0x80000000
+#define HY_FAST_SYSCALL(x)	\
+	((((x) << HY_FAST_SYSCALL_SHIFT) & HY_FAST_SYSCALL_MASK) | \
+	 HY_FAST_SYSCALL_BIT)
+
+/* C driven system calls */
+#define HY_SYSCALL_MASK		0x00ffffff
+#define HY_SYSCALL_SHIFT	0
+#define HY_SYSCALL_BIT		0x40000000
+#define HY_SYSCALL(x)	\
+	((((x) << HY_SYSCALL_SHIFT) & HY_SYSCALL_MASK) | HY_SYSCALL_BIT)
+
+/*
+   NOTE:  Hypercall X represents no direct mapping.
+          F represents a "fast" hypercall
+
+-------------------------------------------------------------------------------
+|  Standard                    |  MILS                         |              |
+|  Hypercall                   |  Hypercall                    |  Hypercall # |
+------------------------------------------------------------------------------|
+|  VBI_SYS_tlb_flush           |  VDK_SYS_invalidate_tlb_entry |      5  F    |
+|  VBI_SYS_icache_flush        |  VDK_SYS_icache_flush         |      1  F    |
+|  VBI_SYS_dcache_flush        |  VDK_SYS_dcache_flush         |      2  F    |
+|  VBI_SYS_ctx_load            |  VDK_SYS_CTX_LOAD             |      3  F    |
+|  VBI_SYS_int_enable          |  VDK_SYS_int_enable           |      4  F    |
+|  VBI_SYS_cache_text_update   |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_excVecBaseSet       |  VDK_SYS_excVecBaseSet        |      0       |
+|  VBI_SYS_hyIoctl             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vmContextCreate     |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_send                |  VDK_SYS_portSend             |      18      |
+|  VBI_SYS_receive             |  VDK_SYS_portGetRecvBuf       |      19      |
+|  VBI_SYS_reply               |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_panic               |  VDK_SYS_panic                |      2       |
+|  VBI_SYS_int                 |  VDK_SYS_int                  |      3       |
+|  VBI_SYS_int_controller_done |  VDK_SYS_int_controller_done  |      4       |
+|  VBI_SYS_ctxctl              |  VDK_SYS_null                 |      X       |
+|  VBI_SYS_vmmu_config         |  VDK_SYS_vmmu_config          |      5       |
+|  VBI_SYS_vmmu_enable         |  VDK_SYS_vmmu_enable          |      6       |
+|  VBI_SYS_vmmu_disable        |  VDK_SYS_vmmu_disable         |      7       |
+|  VBI_SYS_vmmu_tlbload        |  VDK_SYS_vmmu_tlbload         |      8       |
+|  VBI_SYS_vmmu_tlbflush       |  VDK_SYS_vmmu_tlbflush        |      9       |
+|  VBI_SYS_ctx_load_vmmu       |  VDK_SYS_ctx_load_vmmu        |      10      |
+|  VBI_SYS_mmu_attr_set        |  VDK_SYS_mmu_attr_set         |      11      |
+|  VBI_SYS_mmu_attr_get        |  VDK_SYS_mmu_attr_get         |      12      |
+|  VBI_SYS_bspIoctl            |  VDK_SYS_bspIoctl             |      13      |
+|  VBI_SYS_ctxctl              |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbMgmt              |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vIoapicIoctl        |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbReset             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbRestart           |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbSuspend           |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vbResume            |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_kputs               |  VDK_SYS_kputs                |      21      |
+|  VBI_SYS_kputc               |  VDK_SYS_kputc                |      22      |
+|  VBI_SYS_ps                  |  VDK_SYS_ps                   |      23      |
+|  VBI_SYS_dbgShStart          |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_vtlb_op             |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_ns_op               |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_memWrite_op         |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_memRead_op          |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_RegsWrite_op        |  VDK_SYS_NULL                 |      X       |
+|  VBI_SYS_RegsRead_op         |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_DELETE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PTE      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_MAX_OPS         |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_FLUSH_OPS       |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_CR3_CACHE_ENTR  |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_UPDATE_PTE      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_DELETE_PMD      |  VDK_SYS_NULL                 |      X       |
+|  VBI_VTLB_OP_SET_PTE_AT      |  VDK_SYS_NULL                 |      X       |
+------------------------------------------------------------------------------|
+
+*/
+
+/* No direct mapping */
+/* Until the MILS dudes get themselves up to VBI 2.0 they
+have mapped a NULL / no-op to HY_SYSCALL(23) */
+#define VDK_SYS_NULL             HY_SYSCALL(23) /* define a non-existant system call */
+
+/* fast system calls */
+#define VBI_SYS_tlb_flush        HY_FAST_SYSCALL(5) /* TLB flush */
+#define VBI_SYS_icache_flush     HY_FAST_SYSCALL(1) /* instruction cache flush */
+#define VBI_SYS_dcache_flush     HY_FAST_SYSCALL(2) /* data cache flush  */
+#define VBI_SYS_ctx_load         HY_FAST_SYSCALL(3) /* context load */
+#define VBI_SYS_int_enable       HY_FAST_SYSCALL(4) /* int enable */
+#define VBI_SYS_cache_text_update                   \
+                                 VDK_SYS_NULL /* cache text update */
+/* Normal system calls */
+#define VBI_SYS_excVecBaseSet    HY_SYSCALL(0)  /* VDK_SYS_excVecBaseSet */
+/* hypervisor services */
+#define VBI_SYS_hyIoctl          VDK_SYS_NULL  /* hypervisor ioctl */
+#define VBI_SYS_vmContextCreate  VDK_SYS_NULL  /* context create */
+#define VBI_SYS_send             VDK_SYS_NULL  /* send a message */
+#define VBI_SYS_receive          VDK_SYS_NULL  /* receive a message */
+#define VBI_SYS_reply            VDK_SYS_NULL  /* reply to a messages */
+#define VBI_SYS_panic            HY_SYSCALL(2)  /* halt the system */
+#define VBI_SYS_int              HY_SYSCALL(3)  /* deliver an interrupt */
+#define VBI_SYS_int_controller_done HY_SYSCALL(4) /* done intr processing*/
+#define VBI_SYS_ctxctl           VDK_SYS_NULL  /* context control operation */
+
+/* VMMU operations */
+#define VBI_SYS_vmmu_config     HY_SYSCALL(5)  /* configure the virtual MMU */
+#define VBI_SYS_vmmu_enable     HY_SYSCALL(6)  /* enable the virtual MMU    */
+#define VBI_SYS_vmmu_disable    HY_SYSCALL(7)  /* disable the virtual MMU   */
+#define VBI_SYS_vmmu_tlbload    HY_SYSCALL(8)  /* load a VMMU TLB entry     */
+#define VBI_SYS_vmmu_tlbflush   HY_SYSCALL(9)  /* flush a VMMU TLB entry    */
+#define VBI_SYS_ctx_load_vmmu   HY_SYSCALL(10)  /* load context with vmmu    */
+
+/* MMU operations */
+#define VBI_SYS_mmu_attr_set    HY_SYSCALL(11)  /* set physical memory attr  */
+#define VBI_SYS_mmu_attr_get    HY_SYSCALL(12)  /* get physical memory attr  */
+
+/* BSP specific interface */
+#define VDK_SYS_bspIoctl        HY_SYSCALL(13)  /* BSP specific opreration   */
+
+/* vbMgmt services */
+#define VBI_SYS_ctxctl          VDK_SYS_NULL  /* context control operation */
+#define VBI_SYS_vbMgmt          VDK_SYS_NULL
+
+/* Virtual IO APIC services */
+/* Not allowed to enable intr in MILS*/
+#define VBI_SYS_vIoapicIoctl    VDK_SYS_NULL
+
+/* Unicorn only */
+#define VBI_SYS_vbReset         VDK_SYS_NULL  /* reset  vcores        */
+#define VBI_SYS_vbRestart       VDK_SYS_NULL  /* restart vcores       */
+#define VBI_SYS_vbSuspend       VDK_SYS_NULL  /* suspend vcores       */
+#define VBI_SYS_vbResume        VDK_SYS_NULL  /* Resume vcores        */
+#define VBI_SYS_intRedirect     VDK_SYS_NULL  /* vcores int redirect  */
+
+/* debug facilities */
+#define VBI_SYS_kputs           HY_SYSCALL(21)  /* print a string to the cons*/
+#define VBI_SYS_kputc           HY_SYSCALL(22)  /* print a char to the cons  */
+#define VBI_SYS_ps              VDK_SYS_NULL    /* process status display    */
+/* This doesn't work on MILS -XXX- Fix ME! */
+#define VBI_SYS_dbgShStart      VDK_SYS_NULL  /* start debug shell         */
+
+/* VTLB MMU operations */
+#define VBI_SYS_vtlb_op         VDK_SYS_NULL /* VTLB operation */
+
+/* Name services */
+#define VBI_SYS_ns_op           VDK_SYS_NULL  /* Name service operation */
+
+/* remote board memory services */
+/* Breaks MILS security model */
+#define VBI_SYS_memWrite_op     VDK_SYS_NULL  /* memory write service operation */
+/* Breaks MILS security model */
+#define VBI_SYS_memRead_op      VDK_SYS_NULL  /* memory read service operation */
+
+/* remote board register services */
+/* Breaks MILS security model */
+#define VBI_SYS_RegsWrite_op    VDK_SYS_NULL  /* regs write service operation */
+/* Breaks MILS security model */
+#define VBI_SYS_RegsRead_op     VDK_SYS_NULL  /* regs service operation */
+
+#define VDK_SYS_virtToPhys      HY_SYSCALL(1)
+
+/* VTLB operation command and flags (intel-vt specific) */
+#define VBI_VTLB_OP_UPDATE_PMD		0
+#define VBI_VTLB_OP_UPDATE_PTE		0
+#define VBI_VTLB_OP_DELETE_PMD		0
+#define VBI_VTLB_OP_SET_PTE_AT		0
+#define VBI_VTLB_OP_SET_PTE		0
+#define VBI_VTLB_OP_FLUSH_OPS		0
+#define VBI_VTLB_OP_INIT		0
+
+/* VTLB macros */
+#define VBI_VTLB_OP_MAX_OPS		0
+#define VBI_VTLB_OP_CR3_CACHE_ENTRIES   0
+
+/* VTLB optimization supported options */
+#define VBI_VTLB_OPTIM_ENABLED			0
+#define VBI_VTLB_CR3_CACHE_ENABLED		0
+#define VBI_VTLB_OPS_CACHE_ENABLED		0
+#define VBI_VTLB_DIRTY_BIT_SUPPORT_ENABLED	0
+
+
+
+/* Max number of syscalls*/
+#define VBI_SYS_max		(73 + 1)
+
+/* hyIoctl system call supported ioctl's */
+#define VBI_HYIOCTL_GETPID	 1	/* get context's pid		*/
+#define VBI_HYIOCTL_GETPRIORITY	 2	/* get context's priority	*/
+#define VBI_HYIOCTL_PSDISPLAY	 3	/* print context list on console*/
+#define VBI_HYIOCTL_EXCBASE	 4	/* exception vector base addr	*/
+#define VBI_HYIOCTL_INTBASE	 5	/* interrupt vector base addr	*/
+#define VBI_HYIOCTL_GETSTATS	 6	/* get context statistics	*/
+#define VBI_HYIOCTL_DEBUG_SHELL	 7	/* start the debug shell	*/
+#define VBI_HYIOCTL_PADDR	 9	/* translate to physical address*/
+#define VBI_HYIOCTL_EXCOFFSETS_SET  10  /* set exc vector offsets for the VB*/
+#define VBI_HYIOCTL_EXCOFFSETS_GET  11	/* get exc vector offsets for the VB*/
+
+/* vIoapicIoctl system call supported ioctl's */
+#define VBI_IOAPICIOCTL_UNMASK	    1	/* unmask v io apic interrupt src */
+#define VBI_IOAPICIOCTL_SEND	    2	/* inject a v io apic interrupt */
+#define VBI_IOAPICIOCTL_EOI	    3	/* end of interrupt acknowledge */
+#define VBI_IOAPICIOCTL_VCORE_SEND  4	/* Send an irq to a core	*/
+/* remove this after vbControl is working, we don't need a hypercall for it: */
+#define VBI_IOAPICIOCTL_MASK	 10	/* mask v io apic interrupt src */
+
+/* VBI_IOAPICIOCTL_SEND options */
+#define VBI_IOAPICSEND_ALL	 0	/* send interrupt to all incl self */
+#define VBI_IOAPICSEND_OTHERS	 1	/* send interrupt to all except self */
+#define VBI_IOAPICSEND_SELF	 2	/* send interrupt to self only */
+#define VBI_IOAPICSEND_UNICAST	 3	/* send interrupt to a only one vb*/
+#define VBI_IOAPICSEND_NONE	 4	/* ignore this call	       */
+
+/* sent interrupt to a virtual flags */
+#define VBI_IOAPICSEND_VCORE_NONE 0	/* there no option available for now */
+
+
+/* hyCtxctl system call supported operations */
+#define VBI_CTXCTL_IDLE		1	/* make current context idle	*/
+
+/* MMU protection attributes */
+#define VBI_MMU_PROT_READ	0x00000001	/* read allowed    */
+#define VBI_MMU_PROT_WRITE	0x00000002	/* write allowed   */
+#define VBI_MMU_PROT_EXECUTE	0x00000004	/* execute allowed */
+
+/* ETSEC MDIO supported ioctl's */
+#define VBI_BSPIOCTL_DRV_MDIO 1         /* mdio messages */
+
+/* system clock frequency query */
+#define VBI_BSPIOCTL_SYS_CLK 2
+
+#define VBI_BSPIOCTL_CLK_FREQ 2	/* Request system clk freq */
+
+#define MDIO_READ 1
+#define MDIO_WRITE 2
+#define MDIO_INT_ENABLE 3
+#define MDIO_INT_DISABLE 4
+
+/* vbi_hy_ioctl for PADDR */
+#define VBI_HYIOCTL_PADDR_DMA        0x0 /* Default used for DMA */
+#define VBI_HYIOCTL_PADDR_PHYS       0x1 /* When absolute phys addr needed */
+
+/* vbMgmt commands */
+#define VBI_VBMGMT_ATTACH       1       /* Attach to VB for control */
+#define VBI_VBMGMT_DETACH       2       /* Detech from VB */
+#define VBI_VBMGMT_SUSPEND      3       /* Suspend/halt VB */
+#define VBI_VBMGMT_RESUME       4       /* Resume/start a VB */
+#define VBI_VBMGMT_RESET        5       /* Reset VB */
+#define VBI_VBMGMT_RESTART      6       /* Restart a VB */
+
+/* vbMgmt error codes */
+#define VBI_ERROR_CODE              int32_t
+#define VBI_ERR_GENERAL             -101   /* General error */
+#define VBI_ERR_INVALID_ARG         -102   /* General error */
+
+/* vbMgmt reset macros */
+#define VBI_VBMGMT_RESET_NON_CORE0	    0x00000000     /* APs dont clear mem */
+#define VBI_VBMGMT_RESET_DOWNLOAD	 0x00000001 /* disable ELF reloading */
+#define VBI_VBMGMT_RESET_CLEAR		 0x00000002 /* do not clear memory */
+#define VBI_VBMGMT_RESET_AND_START_CORE0 0x00000004
+
+/* target vb options */
+#define VBI_VB_CORES_ALL	(0x80000000)
+#define VBI_VB_CORES_OTHERS	(0x40000000)
+
+
+
+/* vbi_ns_op system call supported operations */
+#define VBI_NS_REGISTER		1	/* register service name    */
+#define VBI_NS_UNREGISTER	2	/* unregister service name  */
+#define VBI_NS_LOOKUP	        3	/* look up service name	    */
+
+#ifndef _ASMLANGUAGE
+
+/* statistics structure returned by VBI_HYIOCTL_GETSTATS ioctl */
+
+struct vbi_ctx_stats
+{
+	unsigned long ctx_type;		/* type of context (user, supv, etc) */
+	unsigned long switchin;		/* number of times switched in       */
+	unsigned long pended;		/* number of times in pend state     */
+	unsigned long tsCtxSwitchOutH;  /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchOutL;  /* timestamp: context switch (low)   */
+	unsigned long tsCtxSwitchInH;   /* timestamp: context switch (high)  */
+	unsigned long tsCtxSwitchInL;   /* timestamp: context switch (low)   */
+	unsigned long tsCtxExcInH;	/* timestamp: exception entry (high) */
+	unsigned long tsCtxExcInL;	/* timestamp: exception entry (low)  */
+	unsigned long reset;		/* number of times context reset     */
+};
+
+/* VTLB operation structures (x86 specific) */
+struct vbi_vtlb_op
+{
+	uint32_t op;		/* VTLB operation id */
+	uint32_t arg1;		/* VTLB operation arg 1 */
+	uint32_t arg2;		/* VTLB operation arg 2 */
+	uint32_t arg3;		/* VTLB operation arg 3 */
+};
+
+struct vbi_vtlb_cr3_cache
+{
+	uint32_t guest_cr3;	/* Guest CR3 register */
+	uint32_t host_cr3;	/* Host CR3 register */
+};
+
+struct vbi_vtlb_control
+{
+	uint32_t size;		/* VTLB Control structure size */
+	uint32_t mode;		/* VTLB module */
+	uint32_t vtlb_ops_ix;	/* VTLB operation index */
+	struct vbi_vtlb_op vtlb_ops[VBI_VTLB_OP_MAX_OPS];	/* VTLB ops array */
+	uint32_t cr3_cache_ix;	/* CR3 cache index */
+				/* cr3 cache*/
+	struct vbi_vtlb_cr3_cache cr3_cache[VBI_VTLB_OP_CR3_CACHE_ENTRIES];
+};
+
+/*
+ * Control structure used by vbi_vb_mgmt for commands memory read, memory write,
+ *  register read, and register write.
+ */
+
+typedef struct vbMgmtCtl
+{
+	union
+	{
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t *pAddress; /* address of calling context */
+			uint32_t size;	/* number of total bytes */
+			uint32_t width;	/* bus width in bytes */
+		} vbMgmtMem;
+		struct
+		{
+			uint32_t *pBuffer;  /* address of target context */
+			uint32_t regSet;	/* register set */
+			uint32_t reg;	/* macro to specify register */
+			uint32_t size;	/* number of total bytes */
+		} vbMgmtReg;
+	} data;
+} VBMGMT_CTL;
+
+typedef uint32_t VBMGMT_HANDLE;
+typedef uint32_t VBI_NS_HANDLE;
+
+#endif	/* _ASMLANGUAGE */
+
+#endif	/* _VDK_SYSCALLS_H */
diff --git a/init/Kconfig.wrhv b/init/Kconfig.wrhv
index 5cc80a8..3ac41ca 100644
--- a/init/Kconfig.wrhv
+++ b/init/Kconfig.wrhv
@@ -8,6 +8,15 @@ config WRHV
 	select SERIAL_CORE
 	select SERIAL_CORE_CONSOLE
 
+
+config WRHV_MILS
+	bool "MILS grade Hypervisor"
+	default n
+	depends on WRHV
+	help
+	  This option selects the MILS secure hypervisor virtualization extensions
+	  in the Linux Kernel.
+
 config DEBUG_VIRTUAL_IRQS
 	bool "Debug VIOAPIC with software IRQ"
 	default n
diff --git a/kernel/vbi/Makefile b/kernel/vbi/Makefile
index 2d0af85..f7ca6fc 100644
--- a/kernel/vbi/Makefile
+++ b/kernel/vbi/Makefile
@@ -1,6 +1,8 @@
 #
 # Makefile for the vbi goodies.
 #
+obj-y := lib.o shmem.o version.o msg.o ns.o show.o wrhv.o
+ifeq ($(CONFIG_WRHV_MILS),)
+obj-y += io_apic.o interrupt.o idle.o paddr.o
+endif
 
-obj-y     = shmem.o wrhv.o interrupt.o paddr.o idle.o io_apic.o lib.o \
-	    version.o msg.o ns.o show.o
diff --git a/kernel/vbi/lib.c b/kernel/vbi/lib.c
index a524769..0a42821 100644
--- a/kernel/vbi/lib.c
+++ b/kernel/vbi/lib.c
@@ -182,6 +182,7 @@ struct vb_status *wr_vb_status;	/* The address of the core's Status area */
  */
 void vbi_init(struct vb_config *config)
 {
+#ifndef CONFIG_WRHV_MILS
 	/*
 	 * validate the vbi version; minor and maintenance should be backward
 	 * compatible.
@@ -189,6 +190,7 @@ void vbi_init(struct vb_config *config)
 	if ((config->major != vbi_version_major) ||
 					 (config->minor < vbi_version_minor))
 		vbi_panic("Invalid vbi version");
+#endif
 
 	wr_vb_config = config;
 	wr_vb_control = wr_vb_config->vb_control;
-- 
1.6.5.2

